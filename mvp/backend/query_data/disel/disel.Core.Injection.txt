From mathcomp.ssreflect

Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.

From mathcomp

Require Import path.

Require Import Eqdep.

Require Import Relation_Operators.

From fcsl

Require Import axioms pred prelude ordtype finmap pcm unionmap heap.

From DiSeL

Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Actions.
(* Freshness:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Keys.
Variables (K : ordType) (V : Type) (U : union_map_class K V).
Implicit Types (k : K) (v : V) (f : U).

Lemma keys_last_mono f1 f2 k :
        path oleq k (dom f1) ->
        path oleq k (dom f2) ->
        (forall x, x \in dom f1 -> x \in dom f2) ->
        oleq (last k (dom f1)) (last k (dom f2)).

End Keys.

Section FreshLastKey.
Variable V : Type.
Implicit Type f : union_map [ordType of nat] V.

Definition last_key f := last 0 (dom f).

Lemma last_key0 : last_key Unit = 0.

Lemma last_key_dom f : valid f -> last_key f \notin dom f -> f = Unit.

Lemma dom_last_key f :  valid f -> ~~ empb f -> last_key f \in dom f.

Lemma last_key_max f x : x \in dom f -> x <= last_key f.

Lemma max_key_last f x :
        x \in dom f -> {in dom f, forall y, y <= x} -> last_key f = x.

Lemma last_keyPt (x : nat) v : last_key (x \\-> v) = x.

Lemma hist_path f : path oleq 0 (dom f).

Lemma last_key_mono f1 f2 :
        {subset dom f1 <= dom f2} -> last_key f1 <= last_key f2.

Lemma last_keyfUn f1 f2 :
        valid (f1 \+ f2) -> last_key f1 <= last_key (f1 \+ f2).

Lemma last_keyUnf f1 f2 :
        valid (f1 \+ f2) -> last_key f2 <= last_key (f1 \+ f2).

Definition fresh f := (last_key f).+1.

Lemma dom_ordfresh f x : x \in dom f -> x < fresh f.

Lemma dom_freshn f n : fresh f + n \notin dom f.

Lemma dom_fresh f : fresh f \notin dom f.

Lemma valid_fresh f v : valid (f \+ fresh f \\-> v) = valid f.

Lemma valid_fresh' f v i w :
  valid (f \+ i \\-> w) ->
  valid (f \+ fresh (f \+ i \\-> w) \\-> v).

Lemma last_fresh f v : valid f -> last_key (f \+ fresh f \\-> v) = fresh f.

End FreshLastKey. *)
(* State:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness DepMaps EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section TaggedMessages. 

  Structure TaggedMessage :=
    TMsg {
        tag: nat;
                tms_cont :> seq nat          
      }.

End TaggedMessages.

Section Shared.

  Definition Label := [ordType of nat].

  Structure msg (mtype : Type) :=
    Msg {content  : mtype;
         from     : nat;
         to       : nat;
         active   : bool }.

  Definition mid := [ordType of nat].

  Definition soup : Type :=
    union_map mid (msg (TaggedMessage)).

  Variables (s: soup) (V: valid s).

  Definition post_msg m : soup * mid :=
    let: f := fresh s in (s \+ f \\-> m, f).

  Lemma post_valid m :  valid (post_msg m).1.

  Lemma post_fresh m : (post_msg m).2 \notin dom s.

  Definition mark_msg T (m : msg T) : msg T :=
    Msg (content m) (from m) (to m) false.

  Definition consume_msg (s : soup) (id : mid) : soup :=
    let: mr := find id s in
    if mr is Some m then upd id (mark_msg m) s else s.

  Definition is_active (id : mid) :=
    exists m, find id s = Some m /\ active m.

  Definition is_consumed (id : mid) :=
    exists m, find id s = Some m /\ ~~ active m.

  Lemma find_consume s' (id: mid) m:
    valid s' -> find id s' = Some m ->
    find id (consume_msg s' id) = Some (mark_msg m).

  Lemma find_mark m s' msg :
    valid s' -> find m (consume_msg s' m) = Some msg ->
    exists msg', find m s' = Some msg' /\ msg = mark_msg msg'.

  Lemma mark_other m m' s' :
    valid s' -> m' == m = false -> find m' (consume_msg s' m) = find m' s'.

  Lemma consume_valid s' m : valid s' -> valid (consume_msg s' m).

  Lemma consumeUn (s': soup) (i : mid) mm
        (j : mid) : valid (s' \+ i \\-> mm) ->
    consume_msg (s' \+ i \\-> mm) j = 
    if i == j then s' \+ i \\-> mark_msg mm
    else (consume_msg s' j) \+ (i \\-> mm).

  Notation "'{{' m 'in' s 'at' id '}}'" := (find id s = Some m).
  Notation "'{{' m 'in' s '}}'" := (exists id, {{m in s at id}}).

End Shared.

Section Local.

  Variable U : Type.

  Definition nid := nat.

  Definition lstate_type := union_map [ordType of nid] U.

End Local.

Section Statelets.

  Structure dstatelet  :=
    DStatelet {
                dstate     : lstate_type heap;
        dsoup      : soup
    }.

  Fixpoint empty_lstate (ns : seq nid) :=
    if ns is n :: ns'
    then n \\-> Heap.empty \+ (empty_lstate ns')
    else  Unit.
    
  Definition empty_dstatelet : dstatelet :=
    @DStatelet (empty_lstate [::]) Unit.

  Lemma valid_mt_soup : valid (dsoup empty_dstatelet).

  Lemma valid_mt_state  : valid (dstate empty_dstatelet).

  Lemma mt_nodes : dom (dstate empty_dstatelet) =i [::].

End Statelets.

Module StateGetters.
Section StateGetters.

Definition state := union_map Label dstatelet.

Definition getStatelet (s: state) (i : Label) : dstatelet :=
  match find i s with
  | Some d => d
  | None => empty_dstatelet
  end.

End StateGetters.
End StateGetters.

Export StateGetters. *)
(* EqTypeX:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module EqualityX.

Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).

Structure mixin_of T := Mixin {op : rel T; _ : axiom op}.
Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variables (T : Type) (cT : type).

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Definition pack c := @Pack T c T.
Definition clone := fun c & cT -> T & phant_id (pack c) cT => pack c.

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation eqTypeX := type.
Notation EqMixinX := Mixin.
Notation EqTypeX T m := (@pack T m).
End Exports.

End EqualityX.
Export EqualityX.Exports.

Section EqualityConversion.

Variable U: eqTypeX.
Definition eq_opX T := EqualityX.op (EqualityX.class T).

Lemma eqxP : Equality.axiom (@eq_opX U).

Canonical eqMixinX := EqMixin eqxP.
Canonical eqTypeX' := EqType U eqMixinX.                                   

End EqualityConversion. *)
(* Protocols:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition getLocal (n : nid) (d : dstatelet) : heap :=
  match find n (dstate d) with
  | Some h => h
  | None => Unit
  end.

Lemma getLocalU n m d s :
  valid (dstate d) -> m \in dom (dstate d) ->
  getLocal n d = (getLocal n {| dstate := upd m (getLocal m d) (dstate d); dsoup := s |}).
        
Module Coherence.

Section CohDef.

Variable nodes: dstatelet -> pred nid.

Notation protocol_soup  := (soup (TaggedMessage)).

Structure mixin_of (coh : Pred dstatelet) := Mixin {
    _   : forall d, coh d -> valid (dstate d);
    _   : forall d, coh d -> valid (dsoup d);
    _   : forall d, coh d -> dom (dstate d) =i nodes d;
}.

End CohDef.

Section ClassDef.

Variable nodes: dstatelet -> pred nid.

Notation class_of := mixin_of (only parsing).

Structure cohpred : Type := Pack {sort : dstatelet -> Prop;
                                  _ : class_of nodes sort}.
Local Coercion sort : cohpred >-> Funclass.

Variables (T : dstatelet -> Prop) (cT : cohpred).

Definition class := let: Pack _ c as cT' := cT
                    return class_of nodes cT' in c.

Definition pack c := @Pack T c.
Definition clone := fun c & T = cT & phant_id (pack c) cT => pack c. 

End ClassDef.

Module Exports.
Section Exports.

Variable Lstate : Type.
Variable nodes: dstatelet -> pred nid.

Coercion sort : cohpred >-> Funclass.
Definition cohpred := cohpred.
Definition CohPredMixin := Mixin.
Definition CohPred T m := (@pack T m).

Notation "[ 'cohPredMixin' 'of' T ]" := (class _ : mixin_of T)
  (at level 0, format "[ 'cohPredMixin'  'of'  T ]") : form_scope.
Notation "[ 'cohpred' 'of' T 'for' C ]" := (@clone T C _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T  'for'  C ]") : form_scope.
Notation "[ 'cohpred' 'of' T ]" := (@clone T _ _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T ]") : form_scope.

Canonical cohpred_PredType := mkPredType (@sort nodes).

Variable coh : cohpred nodes.

Lemma cohVl d : d \In coh -> valid (dstate d).

Lemma cohVs d : d \In coh -> valid (dsoup d).

Lemma cohDom d : d \In coh -> dom (dstate d) =i nodes d.

End Exports.
End Exports.
End Coherence.

Export Coherence.Exports.

Module Transitions.
Section Transitions.

Variable nodes: dstatelet -> pred nid.

Variable coh : cohpred nodes.

Notation lstate := heap%type.

Definition send_step_t (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop) :=
  forall (this to : nid) (d : dstatelet)
         (msg : seq nat) (pf : send_safe this to d msg),
    option lstate.

Definition s_step_coh_t t_snd
           (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop)
           (send_step : send_step_t send_safe) :=
  forall this to d msg (pf : send_safe this to d msg) b,
    let: f := dstate d in
    let: s := dsoup d  in
    Some b = @send_step this to d msg pf ->         
    let: f' := upd this b f in
    let: tms := TMsg t_snd msg in 
    let: s' := (post_msg s (Msg tms this to true)).1 in 
    coh (DStatelet f' s').

Structure send_trans := SendTrans
    {
      t_snd : nat;

      send_safe : nid -> nid -> dstatelet -> seq nat -> Prop;
      s_safe_coh : forall this to d m, send_safe this to d m -> coh d;
      s_safe_in  : forall this to d m, send_safe this to d m ->
                                       this \in nodes d /\ to \in nodes d;  

      send_step : send_step_t send_safe;

      s_safe_def : forall this to d msg,
          send_safe this to d msg <->
          exists b pf, @send_step this to d msg pf = Some b;

      s_step_coh : s_step_coh_t t_snd send_step 
    }.

Definition receive_step_t :=
  forall (this from: nid) (m : seq nat)
         (d : dstatelet) (pf : coh d)
         (pf' : this \in nodes d), lstate.

Definition r_step_coh_t (msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool)
           t_rcv (receive_step : receive_step_t) :=
  forall (d : dstatelet) from this i (C : coh d) (pf' : this \in nodes d)
         (m : TaggedMessage),
    let: f := dstate d in
    let: s := dsoup d  in
    this \in dom f ->
    find i s = Some (Msg m from this true) ->
    msg_wf d C this from m -> tag m = t_rcv ->
    let: loc' := receive_step this from m d C pf' in
    let: s'' := consume_msg s i in
    let: f' := upd this loc' f in
    coh (DStatelet f' s'').

Structure receive_trans := ReceiveTrans
    {
      t_rcv : nat;

      msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool;

      receive_step : receive_step_t;

      r_step_coh : r_step_coh_t msg_wf t_rcv receive_step
    }.

End Transitions.

Module Exports.

Definition SendTrans := SendTrans.
Definition send_trans := send_trans.
Definition ReceiveTrans := ReceiveTrans.
Definition receive_trans := receive_trans.

Definition t_snd := t_snd.
Definition send_safe := send_safe.
Definition send_step := send_step.
Definition send_step_t := send_step_t.

Definition s_safe_coh := s_safe_coh.
Definition s_safe_in := s_safe_in.
Definition s_safe_def := s_safe_def.
Definition s_step_coh := s_step_coh.
Definition s_step_coh_t := s_step_coh_t.

Definition t_rcv := t_rcv.
Definition msg_wf := msg_wf.

Definition receive_step := receive_step.
Definition receive_step_t := receive_step_t.
Definition r_step_coh := r_step_coh.
Definition r_step_coh_t := r_step_coh_t.

End Exports.

End Transitions.

Export Transitions.Exports.

Module Protocols.
Section Protocols.

Definition snd_tags {nodes} {coh : cohpred nodes}
           (sts : seq (send_trans coh)) := 
  map (@t_snd nodes _) sts.

Definition rcv_tags {nodes} {coh : cohpred nodes} (sts : seq (receive_trans coh)) :=
  map (@t_rcv nodes _) sts.

Structure protocol := Protocol {
  nodes: dstatelet -> pred nid;
  plab : Label;                        
  coh : cohpred nodes ;
  snd_trans : seq (send_trans coh);
  rcv_trans : seq (receive_trans coh);

  snd_uniq : uniq (snd_tags snd_trans);
  rcv_uniq : uniq (rcv_tags rcv_trans);
}.

End Protocols.

Module Exports.
Section Exports.

Definition protocol := protocol.
Definition Protocol := Protocol.
Definition plab := plab.
Definition nodes := nodes.
Definition coh := coh.
Definition snd_trans := snd_trans.
Definition rcv_trans := rcv_trans.

Definition snd_tags p := snd_tags (snd_trans p).
Definition rcv_tags p := rcv_tags (rcv_trans p).

Definition snd_uniq := snd_uniq.
Definition rcv_uniq := rcv_uniq.

Definition cohMT d := d = empty_dstatelet.

Lemma pred0v1 d: cohMT d -> valid (dstate d).

Lemma pred0v2 d: cohMT d -> valid (dsoup d).

Lemma pred0v3 d: cohMT d -> dom (dstate d) =i [::].

Definition EmptyProtMixin := CohPredMixin pred0v1 pred0v2 pred0v3.
Definition empty_coh := CohPred EmptyProtMixin.

Lemma snd_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.snd_tags _ coh ([::] : seq (send_trans coh))).

Lemma rcv_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.rcv_tags nodes _ ([::] : seq (receive_trans coh))).

Definition EmptyProt i : protocol :=
  @Protocol (fun _ => pred0) i empty_coh [::] [::] snd_uniq0 rcv_uniq0.

End Exports.
End Exports.

End Protocols.

Export Protocols.Exports. *)
(* Worlds:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module WorldGetters.
Section WorldGetters.

Definition context := union_map Label protocol.

Definition hook_domain := [ordType of ((nat * Label) * (Label * nat))%type].

Definition hook_type := heap -> heap -> seq nat -> nid -> Prop.

Definition hooks := union_map hook_domain hook_type.
Definition world := (context * hooks)%type.

Definition getc (w: world) : context := fst w.
Coercion getc : world >-> context.

Definition geth (w: world) : hooks := snd w.
Coercion geth : world >-> hooks.

Variable w : world.

Variables (p : protocol).

Definition getProtocol i : protocol:=
  match find i (getc w) with
  | Some p => p
  | None => EmptyProt i 
  end.

End WorldGetters.
End WorldGetters.

Export WorldGetters.

Module Worlds.

Module Core.
Section Core.

Definition hooks_consistent (c : context) (h : hooks) : Prop :=
  forall z lc ls t, ((z, lc), (ls, t)) \in dom h ->
  (lc \in dom c) && (ls \in dom c).

Definition hook_complete w := hooks_consistent (getc w) (geth w).

Lemma hook_complete0 c : hook_complete (c, Unit).

Definition Coh (w : world) : Pred state := fun s =>
  let: c := fst w in
  let: h := snd w in                                           
  [/\ valid w, valid s, hook_complete w,
      dom c =i dom s &
      forall l, coh (getProtocol w l) (getStatelet s l)].

Lemma cohW w s : Coh w s -> valid w.

Lemma cohS w s : Coh w s -> valid s.

Lemma cohH w s : Coh w s -> hook_complete w.

Lemma cohD w s : Coh w s -> dom (getc w) =i dom s.

Lemma coh_coh w s l : Coh w s -> coh (getProtocol w l) (getStatelet s l).

Lemma unit_coh w s :
  Coh w s -> w = Unit <-> s = Unit.

Lemma Coh0 (w : world) (s : state) :
  w = Unit -> s = Unit -> Coh w s.

Lemma CohUn (w1 w2 : world) (s1 s2 : state) :
  Coh w1 s1 -> Coh w2 s2 ->
  valid (w1 \+ w2) -> Coh (w1 \+ w2) (s1 \+ s2).

Lemma coh_prec w: precise (Coh w).

Lemma locE i n k x y :
  k \in dom i -> valid i -> valid (dstate (getStatelet i k)) ->
  getLocal n (getStatelet (upd k
       {| dstate := upd n x (dstate (getStatelet i k));
          dsoup := y |} i) k) = x.

Lemma locE' d n x y :
  valid (dstate d) ->
  getLocal n {| dstate := upd n x (dstate d);
                dsoup := y |} = x.

Lemma locU n n' x st s :
  n != n' ->
  valid st ->
  getLocal n {| dstate := upd n' x st; dsoup := s |} =
  getLocal n {| dstate := st; dsoup := s |}.

Section MakeWorld.

Variable p : protocol.
Notation l := (plab p).

Definition mkWorld : world := (l \\-> p, Unit).

Lemma prEq : (getProtocol mkWorld l) = p.
                          
End MakeWorld.

End Core.
End Core.

End Worlds.

Export Worlds.Core. *)
(* NetworkSem:
From mathcomp.ssreflect 
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section NetworkSemantics.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := (getStatelet).
Notation getp := (@getProtocol w).

Definition get_coh l := @coh (getp l).
Definition get_st l := @snd_trans (getp l).
Definition get_rt l := @rcv_trans (getp l).

Lemma getsE l s : l \in dom s -> find l s = Some (gets s l).

Lemma coh_s l s: Coh w s -> coh (getp l) (gets s l).

Lemma Coh_dom l s : l \in dom s -> Coh w s -> 
                     dom (dstate (gets s l)) =i nodes (getp l) (gets s l).

Definition all_hooks_fire (h : hooks) l st s n (msg : seq nat) to :=
  
  forall z lc hk, Some hk = find ((z, lc), (l, st)) h ->
  lc \in dom s -> l \in dom s ->               
  let: core_local   := getl n (gets s lc) in
  let: client_local := getl n (gets s l)  in              
  hk core_local client_local msg to.

Inductive network_step (s1 s2 : state) : Prop :=
  
  Idle of s1 \In Coh w /\ s1 = s2

| SendMsg 
          l st (_ : st \In @get_st l) to msg b
          (pf: this \in (nodes (getp l) (gets s1 l)))
          (pf' : l \in dom s1) (C: Coh w s1)
          
          (S : send_safe st this to (gets s1 l) msg)

          (pf_hooks : all_hooks_fire (geth w) l (t_snd st) s1 this msg to)
          
          (spf : Some b = send_step S) of
          
          let: d :=  gets s1 l in

          let: f' := upd this b (dstate d) in
          let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                              this to true)).1 in
          s2 = upd l (DStatelet f' s') s1

| ReceiveMsg l rt (_ : rt \In @get_rt l) i from
             
             (pf: this \in (nodes (getp l)) (gets s1 l))
             (pf': l \in dom s1) (C: Coh w s1)
             (msg : TaggedMessage)
             (pf': tag msg = t_rcv rt) of
             let: d := (gets s1 l) in
             let: f := dstate d in
             let: s := dsoup d  in

             [/\ find i s = Some (Msg msg from this true),
              msg_wf rt (coh_s l C) this from msg &
              
              let loc' := receive_step rt from msg (coh_s l C) pf in
              let: f' := upd this loc' f in
              let: s'' := consume_msg s i in
              s2 = upd l (DStatelet f' s'') s1].

Lemma step_coh s1 s2: network_step s1 s2 ->
                      Coh w s1 /\ Coh w s2.

Lemma step_preserves_labels s1 s2 :
  network_step s1 s2 -> dom s1 =i dom s2.

Lemma step_is_local s1 s2 l: network_step s1 s2 ->
  forall z, z != this ->
  find z (dstate (gets s1 l)) = find z (dstate (gets s2 l)).

Lemma stepV1 s1 s2: network_step s1 s2 -> valid s1.

Lemma stepV2 s1 s2: network_step s1 s2 -> valid s2.

Lemma step_preserves_node_ids s1 s2 l:
  l \in dom s1 -> network_step s1 s2 ->
  dom (dstate (gets s1 l)) =i dom (dstate (gets s2 l)).

End NetworkSemantics. *)
(* Actions:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Require Classical_Prop.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Actions.

Section Actions.

Variable W : world.
Notation getS s l := (getStatelet s l).

Structure action (V : Type) (this : nid)
  := Action
       {
         
         a_safe : state -> Prop;

         a_safe_coh : forall s, a_safe s -> s \In Coh W;

         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;

         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;

         step_sem  : forall s1 (pf : a_safe s1) s2 r,
             a_step pf s2 r -> network_step W this s1 s2

       }.

Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):
  this != n -> a_step pf s2 r ->
  getLocal n (getS s1 l) = getLocal n (getS s2 l).

End Actions.

Section SkipActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.
Variable l : Label.
Variable p : protocol.
Variable pf : getP l = p.

Definition skip_safe s := Coh W s.

Variable V : Type.

Variable f : forall s, coh p (getS s l) -> V.

Lemma safe_local s : skip_safe s -> coh p (getS s l).

Definition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=
  [/\ s1 \In Coh W, s1 = s2 & r = f (safe_local pf)].

Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.

Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.

Lemma skip_step_sem s1 (S : skip_safe s1) s2 r:
  skip_step S s2 r -> network_step W this s1 s2.

Definition skip_action_wrapper :=
  Action skip_safe_coh skip_step_total skip_step_sem.

End SkipActionWrapper.

Section TryReceiveActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable filter : Label -> nid -> nat -> pred (seq nat).

Variable f_valid_label : forall l n t m ,
    filter l n t m -> l \in dom (getc W).

Definition tryrecv_act_safe (s : state) := s \In Coh W.

Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.

Definition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=
  exists (pf : s1 \In Coh W),
  
    ([/\ (forall l m tms from rt b,
          this \in nodes (getP l) (getS s1 l) -> 
          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->
          rt \In (rcv_trans (getP l)) ->
          tag tms = (t_rcv rt) ->
          
          msg_wf rt (coh_s l pf) this from tms ->
             
          filter l from (t_rcv rt) (tms_cont tms) ->
          ~~b),
    r = None & s2 = s1] \/
   
   exists l m tms from rt (pf' : this \in nodes (getP l) (getS s1 l)),
     let: d :=  getS s1 l in
     [/\ [/\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),
          rt \In (rcv_trans (getP l)),
          tag tms = (t_rcv rt),
          
          msg_wf rt (coh_s l pf) this from tms &
             
          filter l from (t_rcv rt) (tms_cont tms)],
      let loc' := receive_step rt from tms (coh_s l pf) pf' in
      let: f' := upd this loc' (dstate d) in
      let: s' := consume_msg (dsoup d) m in
      s2 = upd l (DStatelet f' s') s1 &
      r = Some (from, tag tms, tms_cont tms)]).

Import Classical_Prop.

Lemma tryrecv_act_step_total s:
  tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.

Lemma tryrecv_act_step_safe s1 s2 r:
  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.

Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:
  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.

Definition tryrecv_action_wrapper :=
  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.

End TryReceiveActionWrapper.

Section SendActionWrapper.

Variable W : world.
Variable p : protocol.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable l : Label.

Variable pf : (getProtocol W l) = p.

Variable st: send_trans (coh p).

Variable pf' : st \In (snd_trans p).

Variable msg : seq nat.
Variable to  : nid.

Definition can_send (s : state) := (l \in dom s) && (this \in nodes p (getS s l)).

Definition filter_hooks (h : hooks) :=
  um_filter (fun e => e.2 == (l, t_snd st)) h.

Definition send_act_safe s :=
  [/\ Coh W s, send_safe st this to (getS s l) msg, can_send s &
               
      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].

Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.

Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.

Definition send_act_step s1 (S: send_act_safe s1) s2 r :=
   r = msg /\
   exists b,
     Some b = send_step (safe_safe S) /\
     let: d :=  getS s1 l in
     let: f' := upd this b (dstate d) in
     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                         this to true)).1 in
     s2 = upd l (DStatelet f' s') s1.

Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.

Lemma send_act_step_sem s1 (S : send_act_safe s1) s2 r:
  send_act_step S s2 r -> network_step W this s1 s2.

Definition send_action_wrapper :=
  Action send_act_safe_coh send_act_step_total send_act_step_sem.

End SendActionWrapper.

End Actions.

Module ActionExports.

Definition action := Actions.action.
Definition a_safe := Actions.a_safe.
Definition a_step := Actions.a_step.

Definition a_safe_coh := Actions.a_safe_coh.
Definition a_step_total := Actions.step_total.
Definition a_step_sem := Actions.step_sem.
Definition a_step_other := Actions.step_other.

Definition skip_action_wrapper := Actions.skip_action_wrapper.
Definition send_action_wrapper := Actions.send_action_wrapper.
Definition tryrecv_action_wrapper := Actions.tryrecv_action_wrapper.

End ActionExports.

Export ActionExports. *)

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Module Injection.

Section Injection.



Variable W : world.



Structure injects (U V : world) (K : hooks) := Inject {

  

  E : world;

                                       

  _ : hook_complete U /\ hook_complete E;



  _ : V = U \+ E \+ (Unit, K);



  _ : hooks_consistent (getc (U \+ E)) K;

  

  _ : forall s, Coh V s <-> exists s1 s2,

        [/\ s = s1 \+ s2, Coh U s1 & Coh E s2];



  _ : forall s1 s2 s this,

      s1 \+ s \In Coh V -> network_step U this s1 s2 ->

      network_step V this (s1 \+ s) (s2 \+ s);



  _ : forall s1 s2 s1' s2' this,

      s1 \In Coh U -> s2 \In Coh U ->

      network_step V this (s1 \+ s1') (s2 \+ s2') ->

      (network_step U this s1 s2   /\ s1' = s2') \/

      (network_step E this s1' s2' /\ s1 = s2); }.



End Injection.



Module Exports.

Section Exports.



Definition inj_ext := E.

Definition injects := injects. 

Definition Inject := Inject.



Lemma cohK (U V : world) (K : hooks) (w : injects U V K) :

  V = U \+ inj_ext w \+ (Unit, K).

Proof. by case: w=>E/=. Qed.



Lemma cohE (U V : world) (K : hooks) (w : injects U V K) s :

  Coh V s <-> exists s1 s2,

      [/\ s = s1 \+ s2, Coh U s1 & Coh (inj_ext w) s2].

Proof. by case: w=>W ??? cohE sL sR; apply: cohE. Qed.



Lemma sem_extend (U V : world) (K : hooks) (w : injects U V K) s1 s2 s this: 

      s1 \+ s \In Coh V -> s2 \+ s \In Coh V ->

      network_step U this s1 s2 -> network_step V this (s1 \+ s) (s2 \+ s).

Proof.

by case: w=>W _ _ _ cohE sL sR C G; apply: sL=>//.

Qed.



Lemma sem_split (U V : world) (K : hooks) (w : injects U V K) s1 s1' s2 s2' this: 

      s1 \In Coh U -> s2 \In Coh U ->

      network_step V this (s1 \+ s1') (s2 \+ s2') ->

      (network_step U this s1 s2   /\ s1' = s2') \/

      (network_step (inj_ext w) this s1' s2' /\ s1 = s2).

Proof. by case: w=>W ??? cohE sl sR; apply: sR. Qed.



Definition extends (U V : world) (K : hooks) (w : injects U V K) s s1 := 

  exists s2, [/\ s = s1 \+ s2, s1 \In Coh U & s \In Coh V].



Notation dom_filt W := (fun k => k \in dom W).



Definition projectS (W : world) (s : state) :=

  um_filter (dom_filt (getc W)) s.



Lemma projectS_cohL W1 W2 s :

  s \In Coh (W1 \+ W2) -> hook_complete W1 -> projectS W1 s \In Coh W1.

Proof.

case=>V1 V2 G1 D H G2; split=>//; first by move/validL: V1.

- by rewrite valid_umfilt.

- move=>z; case B: (z \in dom (getc W1)).

  + by rewrite dom_umfilt !inE B/= -D/=domUn !inE B/=; case/andP:V1=>->.

  by rewrite dom_umfilt !inE B.

move=>l; move: (H l)=>{H}H.

case B: (l \in dom (getc W1)); last first.

- rewrite /getProtocol /getStatelet; move: (B).

  case: dom_find=>//-> _.

  suff X: ~~(l \in dom (projectS W1 s)) by case: dom_find X=>//-> _. 

  by rewrite /projectS dom_umfilt inE/= B.

have E1: find l s = find l (projectS W1 s).

- by rewrite /projectS/= find_umfilt B.

have E2: getProtocol (W1 \+ W2) l = getProtocol W1 l.

  - rewrite /getProtocol findUnL//?B//.

    by rewrite /valid/= in V1; case/andP: V1.

by rewrite -E2 /getStatelet -E1 in H *.  

Qed.



Lemma projectS_cohR W1 W2 s :

  s \In Coh (W1 \+ W2) -> hook_complete W2 -> projectS W2 s \In Coh W2.

Proof. by rewrite joinC; apply: projectS_cohL. Qed.



Lemma projectSE W1 W2 s :

  s \In Coh (W1 \+ W2) ->

  s = projectS W1 s \+ projectS W2 s.

Proof.

case=>Vw Vs G D H; rewrite /projectS.

have X: {in dom s, dom_filt (getc W2) =1 predD (dom_filt (getc W2)) (dom_filt (getc W1))}.

- move=>z _/=; case I : (z \in dom (W1.1 \+ W2.1)).

  + move: I; rewrite domUn !inE/==>/andP[V']/orP[]Z; rewrite Z/=.

    - by case: validUn V'=>//_ _/(_ z Z)/=G' _;apply/negbTE. 

    rewrite joinC in V'; case: validUn V'=>//_ _/(_ z Z)G' _.

    by rewrite andbC.

  move: I; rewrite domUn inE/==>/negbT; rewrite negb_and negb_or/=.

  have X: valid (W1 \+ W2) by [].

  by case/andP: X=>->/=_/andP[]->.

rewrite (eq_in_umfilt X) -umfilt_predU/=; clear X.

suff X: {in dom s, predU (dom_filt (getc W1)) (dom_filt (getc W2)) =1 predT}.

- by rewrite (eq_in_umfilt X) umfilt_predT. 

by move=>z; rewrite/= -D domUn inE=>/andP[].

Qed.



Lemma coh_split W1 W2 s :

  s \In Coh (W1 \+ W2) ->

  hook_complete W1 -> hook_complete W2 ->

  exists s1 s2 : state,

    [/\ s1 \In Coh W1, s2 \In Coh W2 & s = s1 \+ s2].

Proof.

move=>C G1 G2; move/projectSE: (C)->.

exists (projectS W1 s), (projectS W2 s).

split=>//; [by apply: projectS_cohL C G1| by apply: projectS_cohR C G2].

Qed.



Lemma injExtL' (W1 W2 : world) K (pf : injects W1 (W1 \+ W2) K) :

  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W2.

Proof.

move=>H; case: pf=>W2' _ E/=_ _ _ _.

rewrite -joinA in E.

case/andP: H=>H1 H2.

rewrite /PCM.join/= in H1 H2 E *.

case: W2 H1 H2 E=>/=c2 h2 H1 H2 [E1 E2].

by rewrite (joinxK H1 E1) (joinxK H2 E2).

Qed.



Lemma injExtR' W1 W2 K (pf : injects W2 (W1 \+ W2) K) :

  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W1.

Proof.

move=>H; case: pf=>W2' _ E/= _ _ _ _.

rewrite -(joinC W2) in E H.

case/andP: H=>H1 H2; rewrite -joinA in E.

rewrite /PCM.join/= in H1 H2 E *.

case: W1 H1 H2 E=>/=c1 h1 H1 H2 [E1 E2].

by rewrite (joinxK H1 E1) (joinxK H2 E2).

Qed.



Lemma injExtL W1 W2 (pf : injects W1 (W1 \+ W2) Unit) :

  valid (W1 \+ W2) -> inj_ext pf = W2.

Proof. by move/(injExtL' pf); rewrite unitR. Qed.



Lemma injExtR W1 W2 (pf : injects W2 (W1 \+ W2) Unit) :

  valid (W1 \+ W2) -> inj_ext pf  = W1.

Proof. by move/(injExtR' pf); rewrite unitR. Qed.



End Exports.

End Exports.



End Injection.



Export Injection.Exports.



Module InjectExtra.



Lemma cohUnKR U W s s':

  s \+ s' \In Coh (U \+ W) -> s \In Coh U ->

  hook_complete W -> s' \In Coh W.

Proof.

move=>H C G2; move: (cohH C) => G1.

suff X: s' = projectS W (s \+ s').

- by rewrite X; apply: (projectS_cohR H).

suff X: s = projectS U (s \+ s').

- move: (cohS H)=>V; move/projectSE: (H)=>E.

  rewrite E in V.

  rewrite {1}X in E.

  by rewrite (joinxK V (sym_eq E)).

rewrite /projectS.

suff X: {in dom (s \+ s'), dom U.1 =i dom s}.

- by rewrite (eq_in_umfilt X) umfilt_dom ?(cohS H)//.

by move=>z _; move: (cohD C z); rewrite /in_mem.

Qed.



Lemma cohUnKL U W s s':

  s \+ s' \In Coh (U \+ W) -> s' \In Coh W ->

  hook_complete U -> s \In Coh U .

Proof.

by move=>H C G1; rewrite [U \+ W]joinC [s\+_]joinC in H; apply: (cohUnKR H).

Qed.



Lemma getPUn (U W : world) l :

  valid (U \+ W) -> l \in dom U.1 ->

  getProtocol U l = getProtocol (U \+ W) l.

Proof.

move=>V; rewrite /getProtocol=>D.

case/andP: (V)=>V1 V2.

by rewrite findUnL ?V1// D.

Qed.



Lemma getSUn s1 s2 l :

  valid (s1 \+ s2) -> l \in dom s1 ->

  getStatelet s1 l = getStatelet (s1 \+ s2) l.

Proof.

move=>V; rewrite /getStatelet=>D.

by rewrite findUnL ?V// D.

Qed.



Lemma hook_completeL (U : world) K :

  valid (U \+ (Unit, K)) ->

  hook_complete (U \+ (Unit, K)) -> hook_complete U.

Proof.

case: U=>c h=> V H z lc ls st D.

move: (H z lc ls st); rewrite domUn inE/= D/=.

case/andP: V=>_->/==>/(_ is_true_true)=>/andP[].

by rewrite !unitR=>->->.

Qed.



Lemma get_protocol_hooks (U: world) K l:

  valid U -> getProtocol (U \+ (Unit, K)) l = getProtocol U l.

Proof.

move=>V; rewrite /getProtocol.

by rewrite findUnR ?dom0 ?inE//; rewrite unitR; case/andP: V.

Qed.



Lemma coh_hooks (U : world) K s :

  s \In (Coh (U \+ (Unit, K))) -> s \In (Coh U).

Proof.

case=>V Vs Hk D L.

split=>//; first by move/validL: V.

- by apply: hook_completeL V Hk.

- move=>z; rewrite -D domUn !inE/= unitR dom0 orbC/=.

  by move/validL:V=>/andP[]->_.

by move=>l; move: (L l); rewrite (get_protocol_hooks K l (validL V)).

Qed.



Lemma inj_hooks_complete (U W : world) K:

  valid (U \+ W \+ (Unit, K)) ->

  hook_complete U -> hook_complete W ->

  hooks_consistent (U \+ W).1 K ->

  hook_complete (U \+ W \+ (Unit, K)).

Proof.

move=>V G1 G2 G.

move=>z lc ls st; rewrite domUn !inE/= !unitR.

move/andP: (V)=>[_]->/=; case/orP; last by move/G.

rewrite !domUn !inE; case/validL/andP:V=>->->/=.

case/orP; first by case/G1/andP=>->->.

by case/G2/andP=>->->; rewrite -!(orbC true).

Qed.



Lemma inject_step U W K this s1 s2 s1' s2' :

  valid (U \+ W) ->

  s1 \In Coh U -> s2 \In Coh U ->

  hook_complete U -> hook_complete W ->

  network_step (U \+ W \+ (Unit, K)) this (s1 \+ s1') (s2 \+ s2') ->

  network_step U this s1 s2 /\ s1' = s2' \/

  network_step W this s1' s2' /\ s1 = s2.

Proof.

move=>V C1 C2 Hu Hw S; move/step_coh: (S)=>[C1' C2'].

move: (cohW C1')=>V1.

move: (coh_hooks C1')(coh_hooks C2')=>{C1'}C1'{C2'}C2'.

move: (cohUnKR C1' C1 Hw) (cohUnKR C2' C2 Hw)=>D1 D2.

case: S; first 2 last.



move=>l rt R i from H1.

rewrite domUn inE=>/andP[Vs]/=/orP; case=>D C msg H2 [H3 H4]/=;

[rewrite updUnL D|rewrite updUnR D]=>G;[left|right].

- have X: s1' = s2'.

  + move: (C2'); rewrite (joinC U) G -[upd _ _ _ \+ s1'](joinC s1'). 

    move/cohUnKR/(_ D1)/(_ Hu)=>C1''.

    move: (coh_prec (cohS C2') C2 C1'' G)=>Z; rewrite -Z in G; clear Z.

    by rewrite (joinxK (cohS C2') G).

  split=>//; subst s2'; rewrite -![_ \+ s1'](joinC s1') in G C2'.

  rewrite -[upd _ _ _ \+ s1'](joinC s1') in G; rewrite (joinC U) in C2'.

  move: (joinxK (cohS C2') G)=>{G}G. 

  have E: getProtocol U l = getProtocol (U \+ W) l.

    by rewrite (getPUn V)// (cohD C1).

  have E': getStatelet s1 l = getStatelet (s1 \+ s1') l.

    by rewrite (getSUn (cohS C1')). 

  rewrite /get_rt /InMem/= in R. 

  move: (getStatelet (s1 \+ s1') l) E' C (coh_s l C) H1 G H3 H4=>_<-_.

  move: (getProtocol (U \+ W \+ (Unit, K)) l)

        (get_protocol_hooks K l V) E rt R H2=>_-><-rt R H2 coh_s H1 G H3 H4.

  apply: (ReceiveMsg R D H2 (i := i) (from := from) (s2 := s2) (C := C1)). 

  split=>//=; move: (NetworkSem.coh_s l C1)=>coh_s';

  by rewrite -(pf_irr coh_s coh_s').



move: U W V {V1} Hw Hu s1 s2 s1' s2' C1 C2 C1' C2' D1 D2 rt H1 H2 Vs D C R H3 H4 G.

move=>W U V Hw Hu s1' s2' s1 s2 D1 D2.

rewrite !(joinC W) -!(joinC s1) -!(joinC s2)=> C1' C2' C1 C2.

move=>rt H1 H2 Vs D C R H3 H4 G.

have X: s1' = s2'.

- move: (C2'); rewrite (joinC U) G. 

  move/cohUnKR/(_ D1)/(_ Hw)=>C1''; rewrite (joinC s1') in G.

  move: (coh_prec (cohS C2') C2 C1'' G)=>Z; rewrite -Z in G; clear Z.

  by rewrite (joinxK (cohS C2') G).

split=>//; subst s2'; rewrite -!(joinC s1') in G C2'.

rewrite (joinC U) in C2'; move: (joinxK (cohS C2') G)=>{G}G.

rewrite joinC in V.

have E: getProtocol U l = getProtocol (U \+ W) l.

  by rewrite (getPUn V)// (cohD C1).

have E': getStatelet s1 l = getStatelet (s1 \+ s1') l.

  by rewrite (getSUn (cohS C1')). 

rewrite /get_rt /InMem/= in R. 

move: (getStatelet (s1 \+ s1') l) E' C (coh_s l C) H1 G H3 H4=>_<-_.

move: (getProtocol (U \+ W \+ (Unit, K)) l)

      (get_protocol_hooks K l V) E rt R H2=>_-><-rt R H2 coh_s H1 G H3 H4.

apply: (ReceiveMsg R D H2 (i := i) (from := from) (s2 := s2) (C := C1)). 

split=>//=; move: (NetworkSem.coh_s l C1)=>coh_s';

by rewrite -(pf_irr coh_s coh_s').



- case=>_ E; move: (coh_prec (cohS C1') C1 C2 E)=>Z; subst s2.

  rewrite (joinC U) (joinC s1) in C1'; rewrite !(joinC s1) in E.

  move: (coh_prec (cohS C1') D1 D2 E)=>Z; subst s2'.

  by left; split=>//; apply: Idle.



- move=>l st H1 to msg h H2.

  rewrite domUn inE=>/andP[Vs]/orP; case=> D _ S Hk H3;

  [rewrite updUnL D|rewrite updUnR D]=>G;[left|right];

  [| move: U W V1 Hu Hw V s1 s2 s1' s2' C1 C2 C1' C2' D1 D2 st Hk H1 H2 Vs D S H3 G;

    move=> W U V1 Hw Hu V s1' s2' s1 s2 D1 D2 C1' C2' C1 C2 st Hk H1 H2 Vs D S H3 G;

     rewrite (joinC W) in V C1' C2' st H1 S H3 G H2 Hk;

     rewrite -?(joinC s1) -?(joinC s2) in C1' C2' S G H3 Vs].

  + have X: s1' = s2'.

    - move: (C2'); rewrite (joinC U) G -[upd _ _ _ \+ s1'](joinC s1'). 

      move/cohUnKR/(_ D1)/(_ Hu)=>C1''.

      move: (coh_prec (cohS C2') C2 C1'' G)=>Z; rewrite -Z in G; clear Z.

      by rewrite (joinxK (cohS C2') G).

    split=>//; subst s2'; rewrite -!(joinC s1') in G C2'.

    rewrite (joinC U) in C2'; move: (joinxK (cohS C2') G)=>{G}G.

    rewrite (joinC s1') in G.

    have E: getProtocol U l = getProtocol (U \+ W) l.

      by rewrite (getPUn V)// (cohD C1).

    have E': getStatelet s1 l = getStatelet (s1 \+ s1') l.

      by rewrite (getSUn Vs). 

    rewrite /get_st /InMem in H1.

    move: (getStatelet (s1 \+ s1') l) (E') H2 S H3 G=>_<- H2 S H3 G.

    move: (getProtocol (U \+ W \+ (Unit, K)) l)

     (get_protocol_hooks K l V) E st H1 S H2 H3 G Hk=>_-><- st H1 S H2 H3 G Hk.

    apply: (SendMsg H1 H2 D C1 _ H3 G).



    move=>z lc hk F A1 A2.

    apply sym_eq in F.

    move: (Hk z lc hk).

    rewrite -F -joinA !domUn !inE !Vs A1 A2 findUnL ?E' ?(find_some F)/=;

      last by case/andP:V1; rewrite-joinA =>_->.

    move/(_ erefl is_true_true is_true_true).

    by rewrite {1 3}/getStatelet findUnL// A1.



  have X: s1' = s2'.

  - move: (C2'); rewrite (joinC U) G. 

    move/cohUnKR/(_ D1)/(_ Hu)=>C1''; rewrite (joinC s1') in G.

    move: (coh_prec (cohS C2') C2 C1'' G)=>Z; rewrite -Z in G; clear Z.

    by rewrite (joinxK (cohS C2') G).

  split=>//; subst s2'; rewrite -!(joinC s1') in G C2'.

  rewrite (joinC U) in C2'; move: (joinxK (cohS C2') G)=>{G}G.

  rewrite (joinC s1') in G.

  have E: getProtocol U l = getProtocol (U \+ W) l.

    by rewrite (getPUn V)// (cohD C1).

  have E': getStatelet s1 l = getStatelet (s1 \+ s1') l.

    by rewrite (getSUn Vs). 

  rewrite /get_st /InMem in H1; rewrite (joinC s1') in H2.

    move: (getStatelet (s1 \+ s1') l) (E') H2 S H3 G=>_<- H2 S H3 G.

    move: (getProtocol (U \+ W \+ (Unit, K)) l)

     (get_protocol_hooks K l V) E st H1 S H2 H3 G Hk=>_-><- st H1 S H2 H3 G Hk.

    apply: (SendMsg H1 H2 D C1 _ H3 G).



    move=>z lc hk F A1 A2.

    apply sym_eq in F.

    move: (Hk z lc hk).

    rewrite -F -joinA !domUn !inE A1 A2 findUnL ?E' ?(find_some F)/=;

      last by rewrite joinA (joinC U.2); case/andP:V1=>_->.

    rewrite !(joinC s1') !Vs/= -!(orbC true).

    move/(_ erefl is_true_true is_true_true).

    by rewrite {1 3}/getStatelet findUnL// A1.

Qed.



Definition not_hooked_by (K : hooks) l :=

  forall z lc l' st, (z, lc, (l', st)) \in dom K -> l != l'.



Definition world_not_hooked (W: world) K :=

  forall l, l \in dom W.1 -> not_hooked_by K l.



Lemma hooks_frame (U W : world) (K : hooks) l st s s' n msg to :

  hook_complete U -> hook_complete W ->

  hooks_consistent (U \+ W).1 K ->

  l \in dom s -> s \In Coh U -> s \+ s' \In Coh (U \+ W \+ (Unit, K)) ->

  not_hooked_by K l ->        

  all_hooks_fire (geth U) l st s n msg to ->

  all_hooks_fire (geth (U \+ W \+ (Unit, K))) l st (s \+ s') n msg to.

Proof.

move=>G1 G2 G D' C1 C' N A z lc hk F D1 D2; move: F.

case/andP: (cohW C')=>/=V1 V2.

move: (cohUnKR (coh_hooks C') C1 G2) => C2.

rewrite findUnL ?V2//=; case: ifP=>D3; last first.

- move => F; apply sym_eq in F; move: F.

  by move/find_some/N/negP; rewrite eqxx. 

rewrite findUnR ?(validL V2)//; case: ifP=>[D|_].

+ case/G2/andP: D=>_ D; rewrite (cohD C2) in D.

  by case: validUn (cohS C')=>//_ _/(_ _ D'); rewrite D.

move => F.

apply sym_eq in F.

have D'': lc \in dom s by case/andP:(G1 _ _ _ _ (find_some F)); rewrite (cohD C1).

have E: getStatelet s l = getStatelet (s \+ s') l

  by rewrite (getSUn (cohS C'))// -?(cohD C1').

have E': getStatelet s lc = getStatelet (s \+ s') lc.

  by rewrite (getSUn (cohS C'))// -?(cohD C1').

move: (getStatelet (s \+ s') l) (getStatelet (s \+ s') lc) E E'.

by move=>y1 y2 Z1 Z2; subst y1 y2; apply sym_eq in F; apply: (A z).

Qed.



Lemma inject_frame U W K this s1 s2 s:

  s1 \+ s \In Coh (U \+ W \+ (Unit, K)) ->

  network_step U this s1 s2 ->

  hook_complete U -> hook_complete W ->

  hooks_consistent (U \+ W).1 K ->

  

  world_not_hooked U K ->

  network_step (U \+ W \+ (Unit, K)) this (s1 \+ s) (s2 \+ s).

Proof.

move=>C1 S Ku Kw Hk N; move/step_coh: (S)=>[C1' C2'].

case: S; first by move=>[_ <-]; apply: Idle. 



- move=>l st H1 to msg h H2 H3 _ S A H4 G.

  have E: getProtocol U l = getProtocol (U \+ W \+ (Unit, K)) l.

  have Y: getProtocol U l = getProtocol (U \+ W) l.

    + by rewrite (getPUn (validL (cohW C1)))// (cohD C1').

    rewrite Y; rewrite (getPUn (cohW C1))// domUn inE (cohD C1') H3/=.

    by case/andP: (validL (cohW C1))=>->.

  have E': getStatelet s1 l = getStatelet (s1 \+ s) l.

    by rewrite (getSUn (cohS C1))// -?(cohD C1').

  have X: l \in dom (s1 \+ s) by rewrite domUn inE H3 (cohS C1).

  move: (getProtocol U) (E) H2=>_ -> H2.

  rewrite /get_st /InMem/= in H1.

  rewrite E' in H2 G S H4; clear E'.

  move: (getProtocol U l) E st H1 S H4 G H2 A=>_->st H1 S H4 G H2 A.

  apply: (SendMsg H1 H2 X C1 _ H4 (s2 := s2 \+ s)); last first.

  - by rewrite updUnL H3; congr (_ \+ _).

  by apply: hooks_frame=>//; apply: N; rewrite -(cohD C1') in H3.

 

move=> l rt H1 msg from H2 H3 C tms G [G1 G2/= G3].

have E: getProtocol U l = getProtocol (U \+ W \+ (Unit, K)) l.

  have Y: getProtocol U l = getProtocol (U \+ W) l.

  - by rewrite (getPUn (validL (cohW C1)))// (cohD C1').

  rewrite Y; rewrite (getPUn (cohW C1))// domUn inE (cohD C1') H3/=.

  by case/andP: (validL (cohW C1))=>->.

have E': getStatelet s1 l = getStatelet (s1 \+ s) l.

  by rewrite (getSUn (cohS C1))// -?(cohD C1').

have X: l \in dom (s1 \+ s) by rewrite domUn inE (cohS C1) H3.

rewrite /get_rt /InMem /= in H1.

move: (getProtocol U l) (getStatelet s1 l) E E' C H2

      (coh_s l C) rt G3 G G2 H1 G1=>z1 z2 Z1 Z2.

subst z1 z2=>C pf C' G3 G G2 H1 H2 G1.

apply: (ReceiveMsg H2 X G2 (i := msg) (from := from) (s2 := s2 \+ s)).

split=>//=; first by rewrite (pf_irr (coh_s l C1) C').

rewrite updUnL H3; congr (_ \+ _); move: (NetworkSem.coh_s l C1)=>pf'. 

by rewrite (pf_irr pf' C').

Qed.



Lemma injectL (U W : world) K :

  valid (U \+ W \+ (Unit, K)) ->

  hook_complete U -> hook_complete W ->

  hooks_consistent (getc (U \+ W)) K ->

  world_not_hooked U K ->

  injects U (U \+ W \+ (Unit, K)) K.

Proof.

move=>H G1 G2 G N.

exists W=>//[s|s1 s2 s this|s1 s2 s1' s2' this]; [split | |].

- move/coh_hooks=>C; exists (projectS U s), (projectS W s).

  split; [by apply projectSE|by apply: (projectS_cohL C)|

          by apply: (projectS_cohR C)].

- case=>s1[s2][Z]C1 C2; subst s.

  have W1 : valid (s1 \+ s2).

  + case: validUn; rewrite ?(cohS C1) ?(cohS C2)//.

    move=>l; rewrite -(cohD C1)-(cohD C2).

    case/validL/andP: H=>H _;

    by case: validUn H=>//_ _/(_ l) G' _/G'; move/negbTE=>->.

  split=>//[||l].

  + by apply: inj_hooks_complete.

  + move=>l; rewrite !domUn !inE !unitR dom0 orbC/=.

    rewrite W1/= -(cohD C1)-(cohD C2) domUn !inE//=.

    by move/validL/andP:H=>[->]_.

  + rewrite (get_protocol_hooks K l (validL H)).

    rewrite /getProtocol/getStatelet !findUnL//; last by case/validL/andP:H.

    by rewrite (cohD C1); case B: (l \in dom s1)=>//; apply: coh_coh.

- by move=>C1 C2; apply: inject_frame. 

by move=>C1 C2; apply: (inject_step (validL H)).

Qed.



Lemma injectR (U W : world) K :

  valid (W \+ U \+ (Unit, K)) ->

  hook_complete U -> hook_complete W ->

  hooks_consistent (getc (U \+ W)) K ->

  world_not_hooked U K ->

  injects U (W \+ U \+ (Unit, K)) K.

Proof. by rewrite (joinC W); apply: injectL. Qed.



Lemma locProjL (W1 W2 : world) l s1 s2:

  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W1.1 ->

  s1 \In Coh W1 -> getStatelet (s1 \+ s2) l = getStatelet s1 l.

Proof.

move=>C D C1; rewrite (cohD C1) in D.

by rewrite (getSUn (cohS C) D).

Qed.



Lemma locProjR (W1 W2 : world) l s1 s2:

  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W2.1 ->

  s2 \In Coh W2 -> getStatelet (s1 \+ s2) l = getStatelet s2 l.

Proof. by rewrite !(joinC W1) !(joinC s1); apply: locProjL. Qed.



End InjectExtra.



Export InjectExtra.

