From DiSeL

Require Import DiSeLExtraction.
(* DiSeLExtraction:
From DiSeL
Require Import While.

Require Import ExtrOcamlBasic.

Extraction Inline ssrbool.SimplPred.

Extract Constant Actions.Actions.tryrecv_action_wrapper => "DiSeL.tryrecv_action_wrapper".
Extract Constant Actions.Actions.send_action_wrapper => "DiSeL.send_action_wrapper".
Extract Constant Actions.Actions.skip_action_wrapper => "DiSeL.skip_action_wrapper".

Extract Constant HoareTriples.act_prog => "DiSeL.act_prog".
Extract Constant HoareTriples.ret_prog => "DiSeL.ret_prog".
Extract Constant HoareTriples.bnd_prog => "DiSeL.bnd_prog".
Extract Constant HoareTriples.DTLattice.sup_prog => "DiSeL.sup_prog".
Extract Constant HoareTriples.inject_prog => "DiSeL.inject_prog".
Extract Constant HoareTriples.with_inv_prog => "DiSeL.with_inv_prog".

Extract Constant HoareTriples.ffix => "DiSeL.ffix".
Extract Constant While.while => "DiSeL.coq_while".

Extract Inductive HoareTriples.prog => "DiSeL.prog" ["DiSeL.mkProg"] "DiSeL.elimProg".

Extract Inductive Actions.Actions.action => "DiSeL.action" ["DiSeL.mkAction"] "DiSeL.elimAction". *)

From DiSeL

Require Import SimpleCalculatorApp.
(* SimpleCalculatorApp:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always HoareTriples InferenceRules.
From DiSeL
Require Import InductiveInv While.
From DiSeL
Require Import CalculatorProtocol CalculatorInvariant.
From DiSeL
Require Import CalculatorClientLib CalculatorServerLib.
From DiSeL
Require Import DelegatingCalculatorServer SimpleCalculatorServers.

Export CalculatorProtocol.

Section CalculatorApp.

Definition l1 := 1.
Definition l2 := 2.

Definition f args :=
  match args with
  | x::y::_ => Some (x + y)
  | _ => None
  end.

Definition prec (args : input) :=
  if args is x::y::_ then true else false.

Lemma prec_valid :
  forall i, prec i -> exists v, f i = Some v.

Definition cs1 := [::1].
Definition cls1 := [::2].

Definition cs2 := [::3].
Definition cls2 := [::1].

Notation nodes1 := (cs1 ++ cls1).
Notation nodes2 := (cs2 ++ cls2).
Lemma Huniq1 : uniq nodes1. Proof. by []. Qed.

Notation cal1 := (cal_with_inv l1 f prec cs1 cls1).
Notation cal2 := (cal_with_inv l2 f prec cs2 cls2).

Notation W1 := (mkWorld cal1).
Notation W2 := (mkWorld cal2).

Definition V := W1 \+ W2.
Lemma validV : valid V.

Definition sv : nid := 1.
Definition cl : nid := 2.

Lemma  Hc2 : sv \in cls2. Proof. by []. Qed.

Definition sd := 3.

Notation loc i k := (getLocal sv (getStatelet i k)).
Notation loc1 i := (loc i l1).
Notation loc2 i := (loc i l2).

Definition init_loc := st :-> ([::] : reqs). 

Definition init_dstate1 := sv \\-> init_loc \+ cl \\-> init_loc.
Definition init_dstate2 := sv \\-> init_loc \+ sd \\-> init_loc.

Lemma valid_init_dstate1 : valid init_dstate1.

Lemma valid_init_dstate2 : valid init_dstate2.

Notation init_dstatelet1 := (DStatelet init_dstate1 Unit).
Notation init_dstatelet2 := (DStatelet init_dstate2 Unit).

Definition init_state : state :=
  l1 \\-> init_dstatelet1 \+ l2 \\-> init_dstatelet2.

Lemma validI : valid init_state.

Lemma coh1': calcoh prec cs1 cls1 init_dstatelet1 /\
             CalcInv l1 f prec cs1 cls1 init_dstatelet1.

Lemma coh1 : l1 \\-> init_dstatelet1 \In Coh W1.

Lemma coh2' : calcoh prec cs2 cls2 init_dstatelet2 /\
              CalcInv l2 f prec cs2 cls2 init_dstatelet2.

Lemma coh2 : l2 \\-> init_dstatelet2 \In Coh W2.

Lemma init_coh : init_state \In Coh V.

Definition client_input :=
  [:: [::1; 2]; [::3; 4]; [::5; 6]; [::7; 8]; [::9; 10]].

Definition compute_input := compute_list_f l1 f prec cs1 cls1 cl Hc1 sv.

Program Definition client_run (u : unit) :
  DHT [cl, V]
   (fun i => network_rely V cl init_state i,
   fun (res : seq (input * nat)) m =>
     [/\ all (fun e => f e.1 == Some e.2) res &

Definition delegating_server (u : unit) :=
  delegating_server_loop l1 l2 lab_dis f prec cs1 cls1 cs2 cls2 sv
                         Hs1 Hc2 sd Hs2.

Program Definition server1_run (u : unit) :
  DHT [sv, V]
   (fun i => network_rely V sv init_state i,
   fun (res : unit) m => False) :=
  Do (delegating_server u).

Definition secondary_server (u : unit) :=
  with_inv (ii l2 f prec cs2 cls2)
           (memoizing_server l2 f prec prec_valid cs2 cls2 sd Hs2).  

Program Definition server2_run (u : unit) :
  DHT [sd, V]
   (fun i => network_rely V sd init_state i,
    fun (res : unit) m => False) :=
  Do _ (@inject sd W2 V Unit _ _ (secondary_server u);; ret _ _ tt).

End CalculatorApp.

Definition c_runner (u : unit) := client_run u.
Definition s_runner1 (u : unit) := server1_run u.
Definition s_runner2 (u : unit) := server2_run u. *)



Cd "extraction".

  Cd "calculator".

    Separate Extraction State.StateGetters.getStatelet init_state c_runner s_runner1 s_runner2.

  Cd "..".

Cd "..".

