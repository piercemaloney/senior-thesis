From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
(* Freshness:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Keys.
Variables (K : ordType) (V : Type) (U : union_map_class K V).
Implicit Types (k : K) (v : V) (f : U).

Lemma keys_last_mono f1 f2 k :
        path oleq k (dom f1) ->
        path oleq k (dom f2) ->
        (forall x, x \in dom f1 -> x \in dom f2) ->
        oleq (last k (dom f1)) (last k (dom f2)).

End Keys.

Section FreshLastKey.
Variable V : Type.
Implicit Type f : union_map [ordType of nat] V.

Definition last_key f := last 0 (dom f).

Lemma last_key0 : last_key Unit = 0.

Lemma last_key_dom f : valid f -> last_key f \notin dom f -> f = Unit.

Lemma dom_last_key f :  valid f -> ~~ empb f -> last_key f \in dom f.

Lemma last_key_max f x : x \in dom f -> x <= last_key f.

Lemma max_key_last f x :
        x \in dom f -> {in dom f, forall y, y <= x} -> last_key f = x.

Lemma last_keyPt (x : nat) v : last_key (x \\-> v) = x.

Lemma hist_path f : path oleq 0 (dom f).

Lemma last_key_mono f1 f2 :
        {subset dom f1 <= dom f2} -> last_key f1 <= last_key f2.

Lemma last_keyfUn f1 f2 :
        valid (f1 \+ f2) -> last_key f1 <= last_key (f1 \+ f2).

Lemma last_keyUnf f1 f2 :
        valid (f1 \+ f2) -> last_key f2 <= last_key (f1 \+ f2).

Definition fresh f := (last_key f).+1.

Lemma dom_ordfresh f x : x \in dom f -> x < fresh f.

Lemma dom_freshn f n : fresh f + n \notin dom f.

Lemma dom_fresh f : fresh f \notin dom f.

Lemma valid_fresh f v : valid (f \+ fresh f \\-> v) = valid f.

Lemma valid_fresh' f v i w :
  valid (f \+ i \\-> w) ->
  valid (f \+ fresh (f \+ i \\-> w) \\-> v).

Lemma last_fresh f v : valid f -> last_key (f \+ fresh f \\-> v) = fresh f.

End FreshLastKey. *)
(* State:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness DepMaps EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section TaggedMessages. 

  Structure TaggedMessage :=
    TMsg {
        tag: nat;
                tms_cont :> seq nat          
      }.

End TaggedMessages.

Section Shared.

  Definition Label := [ordType of nat].

  Structure msg (mtype : Type) :=
    Msg {content  : mtype;
         from     : nat;
         to       : nat;
         active   : bool }.

  Definition mid := [ordType of nat].

  Definition soup : Type :=
    union_map mid (msg (TaggedMessage)).

  Variables (s: soup) (V: valid s).

  Definition post_msg m : soup * mid :=
    let: f := fresh s in (s \+ f \\-> m, f).

  Lemma post_valid m :  valid (post_msg m).1.

  Lemma post_fresh m : (post_msg m).2 \notin dom s.

  Definition mark_msg T (m : msg T) : msg T :=
    Msg (content m) (from m) (to m) false.

  Definition consume_msg (s : soup) (id : mid) : soup :=
    let: mr := find id s in
    if mr is Some m then upd id (mark_msg m) s else s.

  Definition is_active (id : mid) :=
    exists m, find id s = Some m /\ active m.

  Definition is_consumed (id : mid) :=
    exists m, find id s = Some m /\ ~~ active m.

  Lemma find_consume s' (id: mid) m:
    valid s' -> find id s' = Some m ->
    find id (consume_msg s' id) = Some (mark_msg m).

  Lemma find_mark m s' msg :
    valid s' -> find m (consume_msg s' m) = Some msg ->
    exists msg', find m s' = Some msg' /\ msg = mark_msg msg'.

  Lemma mark_other m m' s' :
    valid s' -> m' == m = false -> find m' (consume_msg s' m) = find m' s'.

  Lemma consume_valid s' m : valid s' -> valid (consume_msg s' m).

  Lemma consumeUn (s': soup) (i : mid) mm
        (j : mid) : valid (s' \+ i \\-> mm) ->
    consume_msg (s' \+ i \\-> mm) j = 
    if i == j then s' \+ i \\-> mark_msg mm
    else (consume_msg s' j) \+ (i \\-> mm).

  Notation "'{{' m 'in' s 'at' id '}}'" := (find id s = Some m).
  Notation "'{{' m 'in' s '}}'" := (exists id, {{m in s at id}}).

End Shared.

Section Local.

  Variable U : Type.

  Definition nid := nat.

  Definition lstate_type := union_map [ordType of nid] U.

End Local.

Section Statelets.

  Structure dstatelet  :=
    DStatelet {
                dstate     : lstate_type heap;
        dsoup      : soup
    }.

  Fixpoint empty_lstate (ns : seq nid) :=
    if ns is n :: ns'
    then n \\-> Heap.empty \+ (empty_lstate ns')
    else  Unit.
    
  Definition empty_dstatelet : dstatelet :=
    @DStatelet (empty_lstate [::]) Unit.

  Lemma valid_mt_soup : valid (dsoup empty_dstatelet).

  Lemma valid_mt_state  : valid (dstate empty_dstatelet).

  Lemma mt_nodes : dom (dstate empty_dstatelet) =i [::].

End Statelets.

Module StateGetters.
Section StateGetters.

Definition state := union_map Label dstatelet.

Definition getStatelet (s: state) (i : Label) : dstatelet :=
  match find i s with
  | Some d => d
  | None => empty_dstatelet
  end.

End StateGetters.
End StateGetters.

Export StateGetters. *)
(* EqTypeX:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module EqualityX.

Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).

Structure mixin_of T := Mixin {op : rel T; _ : axiom op}.
Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variables (T : Type) (cT : type).

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Definition pack c := @Pack T c T.
Definition clone := fun c & cT -> T & phant_id (pack c) cT => pack c.

End ClassDef.

Module Exports.
Coercion sort : type >-> Sortclass.
Notation eqTypeX := type.
Notation EqMixinX := Mixin.
Notation EqTypeX T m := (@pack T m).
End Exports.

End EqualityX.
Export EqualityX.Exports.

Section EqualityConversion.

Variable U: eqTypeX.
Definition eq_opX T := EqualityX.op (EqualityX.class T).

Lemma eqxP : Equality.axiom (@eq_opX U).

Canonical eqMixinX := EqMixin eqxP.
Canonical eqTypeX' := EqType U eqMixinX.                                   

End EqualityConversion. *)
(* DepMaps:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module DepMaps.

Section DepMaps.

Definition Label := [ordType of nat].

Variable V : Type.
Variable labF: V -> Label.

Definition dmDom (u : union_map Label V) : bool :=
    all (fun l => if find l u is Some p then (labF p) == l else false) (dom u).

Record depmap := DepMap {
   dmap : union_map Label V;
   pf   : dmDom dmap;
}.

Section PCMOps.

Variable dm : depmap.

Lemma dmDom_unit : dmDom Unit.

Definition unit := DepMap dmDom_unit.

End PCMOps.

Section DJoin.

Variables (dm1 dm2 : depmap). 

Lemma dmDom_join um1 um2:
  dmDom um1 -> dmDom um2 -> dmDom (um1 \+ um2).

Definition join : depmap := DepMap (dmDom_join (@pf dm1) (@pf dm2)).

Definition valid (dm : depmap) := valid (dmap dm).

End DJoin.

End DepMaps.

Section PCMLaws.

Variables (V : Type) (labF: V -> [ordType of nat]).
Implicit Type f : depmap labF.

Local Notation "f1 \+ f2" := (join f1 f2)
                               (at level 43, left associativity).

Local Notation unit := (unit labF).

Lemma joinC f1 f2 : f1 \+ f2 = f2 \+ f1.

Lemma joinCA f1 f2 f3 : f1 \+ (f2 \+ f3) = f2 \+ (f1 \+ f3).

Lemma joinA f1 f2 f3 : f1 \+ (f2 \+ f3) = (f1 \+ f2) \+ f3.

Lemma validL f1 f2 : valid (f1 \+ f2) -> valid f1.

Lemma unitL f : unit \+ f = f.

Lemma validU : valid unit.

End PCMLaws.

Module Exports.
Section Exports.
Variable V : Type.
Variable labF: V -> Label.
Definition depmap := depmap.
Definition DepMap := DepMap.

Lemma dep_unit (d : depmap labF) : dmap d = Unit -> d = unit labF.

Coercion dmap := dmap.
Definition ddom (d : depmap labF) := dom (dmap d).
Definition dfind x (d : depmap labF) := find x (dmap d).

Definition depmap_classPCMMixin :=
  PCMMixin (@joinC V labF) (@joinA V labF) (@unitL V labF) (@validL V labF) (validU labF).

Canonical depmap_classPCM := Eval hnf in PCM (depmap labF) depmap_classPCMMixin.

End Exports.
End Exports.

End DepMaps.

Export DepMaps.Exports. *)
(* Protocols:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Definition getLocal (n : nid) (d : dstatelet) : heap :=
  match find n (dstate d) with
  | Some h => h
  | None => Unit
  end.

Lemma getLocalU n m d s :
  valid (dstate d) -> m \in dom (dstate d) ->
  getLocal n d = (getLocal n {| dstate := upd m (getLocal m d) (dstate d); dsoup := s |}).
        
Module Coherence.

Section CohDef.

Variable nodes: dstatelet -> pred nid.

Notation protocol_soup  := (soup (TaggedMessage)).

Structure mixin_of (coh : Pred dstatelet) := Mixin {
    _   : forall d, coh d -> valid (dstate d);
    _   : forall d, coh d -> valid (dsoup d);
    _   : forall d, coh d -> dom (dstate d) =i nodes d;
}.

End CohDef.

Section ClassDef.

Variable nodes: dstatelet -> pred nid.

Notation class_of := mixin_of (only parsing).

Structure cohpred : Type := Pack {sort : dstatelet -> Prop;
                                  _ : class_of nodes sort}.
Local Coercion sort : cohpred >-> Funclass.

Variables (T : dstatelet -> Prop) (cT : cohpred).

Definition class := let: Pack _ c as cT' := cT
                    return class_of nodes cT' in c.

Definition pack c := @Pack T c.
Definition clone := fun c & T = cT & phant_id (pack c) cT => pack c. 

End ClassDef.

Module Exports.
Section Exports.

Variable Lstate : Type.
Variable nodes: dstatelet -> pred nid.

Coercion sort : cohpred >-> Funclass.
Definition cohpred := cohpred.
Definition CohPredMixin := Mixin.
Definition CohPred T m := (@pack T m).

Notation "[ 'cohPredMixin' 'of' T ]" := (class _ : mixin_of T)
  (at level 0, format "[ 'cohPredMixin'  'of'  T ]") : form_scope.
Notation "[ 'cohpred' 'of' T 'for' C ]" := (@clone T C _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T  'for'  C ]") : form_scope.
Notation "[ 'cohpred' 'of' T ]" := (@clone T _ _ (erefl _) id)
  (at level 0, format "[ 'cohpred'  'of'  T ]") : form_scope.

Canonical cohpred_PredType := mkPredType (@sort nodes).

Variable coh : cohpred nodes.

Lemma cohVl d : d \In coh -> valid (dstate d).

Lemma cohVs d : d \In coh -> valid (dsoup d).

Lemma cohDom d : d \In coh -> dom (dstate d) =i nodes d.

End Exports.
End Exports.
End Coherence.

Export Coherence.Exports.

Module Transitions.
Section Transitions.

Variable nodes: dstatelet -> pred nid.

Variable coh : cohpred nodes.

Notation lstate := heap%type.

Definition send_step_t (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop) :=
  forall (this to : nid) (d : dstatelet)
         (msg : seq nat) (pf : send_safe this to d msg),
    option lstate.

Definition s_step_coh_t t_snd
           (send_safe : nid -> nid -> dstatelet -> seq nat -> Prop)
           (send_step : send_step_t send_safe) :=
  forall this to d msg (pf : send_safe this to d msg) b,
    let: f := dstate d in
    let: s := dsoup d  in
    Some b = @send_step this to d msg pf ->         
    let: f' := upd this b f in
    let: tms := TMsg t_snd msg in 
    let: s' := (post_msg s (Msg tms this to true)).1 in 
    coh (DStatelet f' s').

Structure send_trans := SendTrans
    {
      t_snd : nat;

      send_safe : nid -> nid -> dstatelet -> seq nat -> Prop;
      s_safe_coh : forall this to d m, send_safe this to d m -> coh d;
      s_safe_in  : forall this to d m, send_safe this to d m ->
                                       this \in nodes d /\ to \in nodes d;  

      send_step : send_step_t send_safe;

      s_safe_def : forall this to d msg,
          send_safe this to d msg <->
          exists b pf, @send_step this to d msg pf = Some b;

      s_step_coh : s_step_coh_t t_snd send_step 
    }.

Definition receive_step_t :=
  forall (this from: nid) (m : seq nat)
         (d : dstatelet) (pf : coh d)
         (pf' : this \in nodes d), lstate.

Definition r_step_coh_t (msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool)
           t_rcv (receive_step : receive_step_t) :=
  forall (d : dstatelet) from this i (C : coh d) (pf' : this \in nodes d)
         (m : TaggedMessage),
    let: f := dstate d in
    let: s := dsoup d  in
    this \in dom f ->
    find i s = Some (Msg m from this true) ->
    msg_wf d C this from m -> tag m = t_rcv ->
    let: loc' := receive_step this from m d C pf' in
    let: s'' := consume_msg s i in
    let: f' := upd this loc' f in
    coh (DStatelet f' s'').

Structure receive_trans := ReceiveTrans
    {
      t_rcv : nat;

      msg_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool;

      receive_step : receive_step_t;

      r_step_coh : r_step_coh_t msg_wf t_rcv receive_step
    }.

End Transitions.

Module Exports.

Definition SendTrans := SendTrans.
Definition send_trans := send_trans.
Definition ReceiveTrans := ReceiveTrans.
Definition receive_trans := receive_trans.

Definition t_snd := t_snd.
Definition send_safe := send_safe.
Definition send_step := send_step.
Definition send_step_t := send_step_t.

Definition s_safe_coh := s_safe_coh.
Definition s_safe_in := s_safe_in.
Definition s_safe_def := s_safe_def.
Definition s_step_coh := s_step_coh.
Definition s_step_coh_t := s_step_coh_t.

Definition t_rcv := t_rcv.
Definition msg_wf := msg_wf.

Definition receive_step := receive_step.
Definition receive_step_t := receive_step_t.
Definition r_step_coh := r_step_coh.
Definition r_step_coh_t := r_step_coh_t.

End Exports.

End Transitions.

Export Transitions.Exports.

Module Protocols.
Section Protocols.

Definition snd_tags {nodes} {coh : cohpred nodes}
           (sts : seq (send_trans coh)) := 
  map (@t_snd nodes _) sts.

Definition rcv_tags {nodes} {coh : cohpred nodes} (sts : seq (receive_trans coh)) :=
  map (@t_rcv nodes _) sts.

Structure protocol := Protocol {
  nodes: dstatelet -> pred nid;
  plab : Label;                        
  coh : cohpred nodes ;
  snd_trans : seq (send_trans coh);
  rcv_trans : seq (receive_trans coh);

  snd_uniq : uniq (snd_tags snd_trans);
  rcv_uniq : uniq (rcv_tags rcv_trans);
}.

End Protocols.

Module Exports.
Section Exports.

Definition protocol := protocol.
Definition Protocol := Protocol.
Definition plab := plab.
Definition nodes := nodes.
Definition coh := coh.
Definition snd_trans := snd_trans.
Definition rcv_trans := rcv_trans.

Definition snd_tags p := snd_tags (snd_trans p).
Definition rcv_tags p := rcv_tags (rcv_trans p).

Definition snd_uniq := snd_uniq.
Definition rcv_uniq := rcv_uniq.

Definition cohMT d := d = empty_dstatelet.

Lemma pred0v1 d: cohMT d -> valid (dstate d).

Lemma pred0v2 d: cohMT d -> valid (dsoup d).

Lemma pred0v3 d: cohMT d -> dom (dstate d) =i [::].

Definition EmptyProtMixin := CohPredMixin pred0v1 pred0v2 pred0v3.
Definition empty_coh := CohPred EmptyProtMixin.

Lemma snd_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.snd_tags _ coh ([::] : seq (send_trans coh))).

Lemma rcv_uniq0 {nodes} {coh : cohpred nodes} :
  uniq (@Protocols.rcv_tags nodes _ ([::] : seq (receive_trans coh))).

Definition EmptyProt i : protocol :=
  @Protocol (fun _ => pred0) i empty_coh [::] [::] snd_uniq0 rcv_uniq0.

End Exports.
End Exports.

End Protocols.

Export Protocols.Exports. *)
(* Worlds:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module WorldGetters.
Section WorldGetters.

Definition context := union_map Label protocol.

Definition hook_domain := [ordType of ((nat * Label) * (Label * nat))%type].

Definition hook_type := heap -> heap -> seq nat -> nid -> Prop.

Definition hooks := union_map hook_domain hook_type.
Definition world := (context * hooks)%type.

Definition getc (w: world) : context := fst w.
Coercion getc : world >-> context.

Definition geth (w: world) : hooks := snd w.
Coercion geth : world >-> hooks.

Variable w : world.

Variables (p : protocol).

Definition getProtocol i : protocol:=
  match find i (getc w) with
  | Some p => p
  | None => EmptyProt i 
  end.

End WorldGetters.
End WorldGetters.

Export WorldGetters.

Module Worlds.

Module Core.
Section Core.

Definition hooks_consistent (c : context) (h : hooks) : Prop :=
  forall z lc ls t, ((z, lc), (ls, t)) \in dom h ->
  (lc \in dom c) && (ls \in dom c).

Definition hook_complete w := hooks_consistent (getc w) (geth w).

Lemma hook_complete0 c : hook_complete (c, Unit).

Definition Coh (w : world) : Pred state := fun s =>
  let: c := fst w in
  let: h := snd w in                                           
  [/\ valid w, valid s, hook_complete w,
      dom c =i dom s &
      forall l, coh (getProtocol w l) (getStatelet s l)].

Lemma cohW w s : Coh w s -> valid w.

Lemma cohS w s : Coh w s -> valid s.

Lemma cohH w s : Coh w s -> hook_complete w.

Lemma cohD w s : Coh w s -> dom (getc w) =i dom s.

Lemma coh_coh w s l : Coh w s -> coh (getProtocol w l) (getStatelet s l).

Lemma unit_coh w s :
  Coh w s -> w = Unit <-> s = Unit.

Lemma Coh0 (w : world) (s : state) :
  w = Unit -> s = Unit -> Coh w s.

Lemma CohUn (w1 w2 : world) (s1 s2 : state) :
  Coh w1 s1 -> Coh w2 s2 ->
  valid (w1 \+ w2) -> Coh (w1 \+ w2) (s1 \+ s2).

Lemma coh_prec w: precise (Coh w).

Lemma locE i n k x y :
  k \in dom i -> valid i -> valid (dstate (getStatelet i k)) ->
  getLocal n (getStatelet (upd k
       {| dstate := upd n x (dstate (getStatelet i k));
          dsoup := y |} i) k) = x.

Lemma locE' d n x y :
  valid (dstate d) ->
  getLocal n {| dstate := upd n x (dstate d);
                dsoup := y |} = x.

Lemma locU n n' x st s :
  n != n' ->
  valid st ->
  getLocal n {| dstate := upd n' x st; dsoup := s |} =
  getLocal n {| dstate := st; dsoup := s |}.

Section MakeWorld.

Variable p : protocol.
Notation l := (plab p).

Definition mkWorld : world := (l \\-> p, Unit).

Lemma prEq : (getProtocol mkWorld l) = p.
                          
End MakeWorld.

End Core.
End Core.

End Worlds.

Export Worlds.Core. *)
(* NetworkSem:
From mathcomp.ssreflect 
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section NetworkSemantics.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := (getStatelet).
Notation getp := (@getProtocol w).

Definition get_coh l := @coh (getp l).
Definition get_st l := @snd_trans (getp l).
Definition get_rt l := @rcv_trans (getp l).

Lemma getsE l s : l \in dom s -> find l s = Some (gets s l).

Lemma coh_s l s: Coh w s -> coh (getp l) (gets s l).

Lemma Coh_dom l s : l \in dom s -> Coh w s -> 
                     dom (dstate (gets s l)) =i nodes (getp l) (gets s l).

Definition all_hooks_fire (h : hooks) l st s n (msg : seq nat) to :=
  
  forall z lc hk, Some hk = find ((z, lc), (l, st)) h ->
  lc \in dom s -> l \in dom s ->               
  let: core_local   := getl n (gets s lc) in
  let: client_local := getl n (gets s l)  in              
  hk core_local client_local msg to.

Inductive network_step (s1 s2 : state) : Prop :=
  
  Idle of s1 \In Coh w /\ s1 = s2

| SendMsg 
          l st (_ : st \In @get_st l) to msg b
          (pf: this \in (nodes (getp l) (gets s1 l)))
          (pf' : l \in dom s1) (C: Coh w s1)
          
          (S : send_safe st this to (gets s1 l) msg)

          (pf_hooks : all_hooks_fire (geth w) l (t_snd st) s1 this msg to)
          
          (spf : Some b = send_step S) of
          
          let: d :=  gets s1 l in

          let: f' := upd this b (dstate d) in
          let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                              this to true)).1 in
          s2 = upd l (DStatelet f' s') s1

| ReceiveMsg l rt (_ : rt \In @get_rt l) i from
             
             (pf: this \in (nodes (getp l)) (gets s1 l))
             (pf': l \in dom s1) (C: Coh w s1)
             (msg : TaggedMessage)
             (pf': tag msg = t_rcv rt) of
             let: d := (gets s1 l) in
             let: f := dstate d in
             let: s := dsoup d  in

             [/\ find i s = Some (Msg msg from this true),
              msg_wf rt (coh_s l C) this from msg &
              
              let loc' := receive_step rt from msg (coh_s l C) pf in
              let: f' := upd this loc' f in
              let: s'' := consume_msg s i in
              s2 = upd l (DStatelet f' s'') s1].

Lemma step_coh s1 s2: network_step s1 s2 ->
                      Coh w s1 /\ Coh w s2.

Lemma step_preserves_labels s1 s2 :
  network_step s1 s2 -> dom s1 =i dom s2.

Lemma step_is_local s1 s2 l: network_step s1 s2 ->
  forall z, z != this ->
  find z (dstate (gets s1 l)) = find z (dstate (gets s2 l)).

Lemma stepV1 s1 s2: network_step s1 s2 -> valid s1.

Lemma stepV2 s1 s2: network_step s1 s2 -> valid s2.

Lemma step_preserves_node_ids s1 s2 l:
  l \in dom s1 -> network_step s1 s2 ->
  dom (dstate (gets s1 l)) =i dom (dstate (gets s2 l)).

End NetworkSemantics. *)
(* Rely:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Rely.

Variable w : world.
Variable this: nid.

Notation getl := (getLocal).
Notation gets := getStatelet.
Notation getp := (@getProtocol _ w).

Fixpoint network_rely' n s1 s2 :=
  if n is n'.+1
  then exists z s3,
        [/\ this != z, network_step w z s1 s3 & network_rely' n' s3 s2]
    else s1 = s2 /\ s1 \In Coh w.

Definition network_rely s1 s2 := exists n, network_rely' n s1 s2.

Lemma rely_refl s : s \In Coh w -> network_rely s s.

Lemma rely_trans s1 s2 s3 :
  network_rely s1 s2 -> network_rely s2 s3 -> network_rely s1 s3.

Lemma rely_coh' n s1 s2 :
  network_rely' n s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_coh s1 s2 :
  network_rely s1 s2 -> Coh w s1 /\ Coh w s2.

Lemma rely_loc s1 s2 l:
  network_rely s1 s2 -> find this (dstate (gets s1 l)) = find this (dstate (gets s2 l)).

Lemma step_consume_other l s s' m tm from z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma rely_consume_other l s s' m tm from:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm from this true) ->
  find m (dsoup (gets s' l)) = Some (Msg tm from this true).

Lemma step_send_other l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma rely_send_other l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s' l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s l)) = Some (Msg tm this to b') /\ (b -> b').

Lemma step_send_other' l s s' m tm to b z:
  this != z -> network_step w z s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Lemma rely_send_other' l s s' m tm to b:
  network_rely s s' ->
  find m (dsoup (gets s l)) = Some (Msg tm this to b) ->
  exists b', find m (dsoup (gets s' l)) = Some (Msg tm this to b') /\ (b' -> b).

Notation loc i l := (getLocal this (getStatelet i l)).
Notation msgs i l := (dsoup (getStatelet i l)).

Lemma rely_loc' l i j : network_rely i j -> loc j l = loc i l.

End Rely. *)
From DiSeL
Require Import Actions Injection Process Always HoareTriples InferenceRules.
(* Actions:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem.
Require Classical_Prop.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Actions.

Section Actions.

Variable W : world.
Notation getS s l := (getStatelet s l).

Structure action (V : Type) (this : nid)
  := Action
       {
         
         a_safe : state -> Prop;

         a_safe_coh : forall s, a_safe s -> s \In Coh W;

         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;

         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;

         step_sem  : forall s1 (pf : a_safe s1) s2 r,
             a_step pf s2 r -> network_step W this s1 s2

       }.

Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):
  this != n -> a_step pf s2 r ->
  getLocal n (getS s1 l) = getLocal n (getS s2 l).

End Actions.

Section SkipActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.
Variable l : Label.
Variable p : protocol.
Variable pf : getP l = p.

Definition skip_safe s := Coh W s.

Variable V : Type.

Variable f : forall s, coh p (getS s l) -> V.

Lemma safe_local s : skip_safe s -> coh p (getS s l).

Definition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=
  [/\ s1 \In Coh W, s1 = s2 & r = f (safe_local pf)].

Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.

Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.

Lemma skip_step_sem s1 (S : skip_safe s1) s2 r:
  skip_step S s2 r -> network_step W this s1 s2.

Definition skip_action_wrapper :=
  Action skip_safe_coh skip_step_total skip_step_sem.

End SkipActionWrapper.

Section TryReceiveActionWrapper.

Variable W : world.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable filter : Label -> nid -> nat -> pred (seq nat).

Variable f_valid_label : forall l n t m ,
    filter l n t m -> l \in dom (getc W).

Definition tryrecv_act_safe (s : state) := s \In Coh W.

Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.

Definition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=
  exists (pf : s1 \In Coh W),
  
    ([/\ (forall l m tms from rt b,
          this \in nodes (getP l) (getS s1 l) -> 
          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->
          rt \In (rcv_trans (getP l)) ->
          tag tms = (t_rcv rt) ->
          
          msg_wf rt (coh_s l pf) this from tms ->
             
          filter l from (t_rcv rt) (tms_cont tms) ->
          ~~b),
    r = None & s2 = s1] \/
   
   exists l m tms from rt (pf' : this \in nodes (getP l) (getS s1 l)),
     let: d :=  getS s1 l in
     [/\ [/\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),
          rt \In (rcv_trans (getP l)),
          tag tms = (t_rcv rt),
          
          msg_wf rt (coh_s l pf) this from tms &
             
          filter l from (t_rcv rt) (tms_cont tms)],
      let loc' := receive_step rt from tms (coh_s l pf) pf' in
      let: f' := upd this loc' (dstate d) in
      let: s' := consume_msg (dsoup d) m in
      s2 = upd l (DStatelet f' s') s1 &
      r = Some (from, tag tms, tms_cont tms)]).

Import Classical_Prop.

Lemma tryrecv_act_step_total s:
  tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.

Lemma tryrecv_act_step_safe s1 s2 r:
  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.

Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:
  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.

Definition tryrecv_action_wrapper :=
  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.

End TryReceiveActionWrapper.

Section SendActionWrapper.

Variable W : world.
Variable p : protocol.
Notation getP l := (getProtocol W l).
Notation getS s l := (getStatelet s l).
Variable this : nid.

Variable l : Label.

Variable pf : (getProtocol W l) = p.

Variable st: send_trans (coh p).

Variable pf' : st \In (snd_trans p).

Variable msg : seq nat.
Variable to  : nid.

Definition can_send (s : state) := (l \in dom s) && (this \in nodes p (getS s l)).

Definition filter_hooks (h : hooks) :=
  um_filter (fun e => e.2 == (l, t_snd st)) h.

Definition send_act_safe s :=
  [/\ Coh W s, send_safe st this to (getS s l) msg, can_send s &
               
      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].

Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.

Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.

Definition send_act_step s1 (S: send_act_safe s1) s2 r :=
   r = msg /\
   exists b,
     Some b = send_step (safe_safe S) /\
     let: d :=  getS s1 l in
     let: f' := upd this b (dstate d) in
     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)
                                         this to true)).1 in
     s2 = upd l (DStatelet f' s') s1.

Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.

Lemma send_act_step_sem s1 (S : send_act_safe s1) s2 r:
  send_act_step S s2 r -> network_step W this s1 s2.

Definition send_action_wrapper :=
  Action send_act_safe_coh send_act_step_total send_act_step_sem.

End SendActionWrapper.

End Actions.

Module ActionExports.

Definition action := Actions.action.
Definition a_safe := Actions.a_safe.
Definition a_step := Actions.a_step.

Definition a_safe_coh := Actions.a_safe_coh.
Definition a_step_total := Actions.step_total.
Definition a_step_sem := Actions.step_sem.
Definition a_step_other := Actions.step_other.

Definition skip_action_wrapper := Actions.skip_action_wrapper.
Definition send_action_wrapper := Actions.send_action_wrapper.
Definition tryrecv_action_wrapper := Actions.tryrecv_action_wrapper.

End ActionExports.

Export ActionExports. *)
(* Injection:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Actions.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module Injection.
Section Injection.

Variable W : world.

Structure injects (U V : world) (K : hooks) := Inject {
  
  E : world;
                                       
  _ : hook_complete U /\ hook_complete E;

  _ : V = U \+ E \+ (Unit, K);

  _ : hooks_consistent (getc (U \+ E)) K;
  
  _ : forall s, Coh V s <-> exists s1 s2,
        [/\ s = s1 \+ s2, Coh U s1 & Coh E s2];

  _ : forall s1 s2 s this,
      s1 \+ s \In Coh V -> network_step U this s1 s2 ->
      network_step V this (s1 \+ s) (s2 \+ s);

  _ : forall s1 s2 s1' s2' this,
      s1 \In Coh U -> s2 \In Coh U ->
      network_step V this (s1 \+ s1') (s2 \+ s2') ->
      (network_step U this s1 s2   /\ s1' = s2') \/
      (network_step E this s1' s2' /\ s1 = s2); }.

End Injection.

Module Exports.
Section Exports.

Definition inj_ext := E.
Definition injects := injects. 
Definition Inject := Inject.

Lemma cohK (U V : world) (K : hooks) (w : injects U V K) :
  V = U \+ inj_ext w \+ (Unit, K).

Lemma cohE (U V : world) (K : hooks) (w : injects U V K) s :
  Coh V s <-> exists s1 s2,
      [/\ s = s1 \+ s2, Coh U s1 & Coh (inj_ext w) s2].

Lemma sem_extend (U V : world) (K : hooks) (w : injects U V K) s1 s2 s this: 
      s1 \+ s \In Coh V -> s2 \+ s \In Coh V ->
      network_step U this s1 s2 -> network_step V this (s1 \+ s) (s2 \+ s).

Lemma sem_split (U V : world) (K : hooks) (w : injects U V K) s1 s1' s2 s2' this: 
      s1 \In Coh U -> s2 \In Coh U ->
      network_step V this (s1 \+ s1') (s2 \+ s2') ->
      (network_step U this s1 s2   /\ s1' = s2') \/
      (network_step (inj_ext w) this s1' s2' /\ s1 = s2).

Definition extends (U V : world) (K : hooks) (w : injects U V K) s s1 := 
  exists s2, [/\ s = s1 \+ s2, s1 \In Coh U & s \In Coh V].

Notation dom_filt W := (fun k => k \in dom W).

Definition projectS (W : world) (s : state) :=
  um_filter (dom_filt (getc W)) s.

Lemma projectS_cohL W1 W2 s :
  s \In Coh (W1 \+ W2) -> hook_complete W1 -> projectS W1 s \In Coh W1.

Lemma projectS_cohR W1 W2 s :
  s \In Coh (W1 \+ W2) -> hook_complete W2 -> projectS W2 s \In Coh W2.

Lemma projectSE W1 W2 s :
  s \In Coh (W1 \+ W2) ->
  s = projectS W1 s \+ projectS W2 s.

Lemma coh_split W1 W2 s :
  s \In Coh (W1 \+ W2) ->
  hook_complete W1 -> hook_complete W2 ->
  exists s1 s2 : state,
    [/\ s1 \In Coh W1, s2 \In Coh W2 & s = s1 \+ s2].

Lemma injExtL' (W1 W2 : world) K (pf : injects W1 (W1 \+ W2) K) :
  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W2.

Lemma injExtR' W1 W2 K (pf : injects W2 (W1 \+ W2) K) :
  valid (W1 \+ W2) -> inj_ext pf \+ (Unit, K) = W1.

Lemma injExtL W1 W2 (pf : injects W1 (W1 \+ W2) Unit) :
  valid (W1 \+ W2) -> inj_ext pf = W2.

Lemma injExtR W1 W2 (pf : injects W2 (W1 \+ W2) Unit) :
  valid (W1 \+ W2) -> inj_ext pf  = W1.

End Exports.
End Exports.

End Injection.

Export Injection.Exports.

Module InjectExtra.

Lemma cohUnKR U W s s':
  s \+ s' \In Coh (U \+ W) -> s \In Coh U ->
  hook_complete W -> s' \In Coh W.

Lemma cohUnKL U W s s':
  s \+ s' \In Coh (U \+ W) -> s' \In Coh W ->
  hook_complete U -> s \In Coh U .

Lemma getPUn (U W : world) l :
  valid (U \+ W) -> l \in dom U.1 ->

Lemma getSUn s1 s2 l :
  valid (s1 \+ s2) -> l \in dom s1 ->
  getStatelet s1 l = getStatelet (s1 \+ s2) l.

Lemma hook_completeL (U : world) K :
  valid (U \+ (Unit, K)) ->
  hook_complete (U \+ (Unit, K)) -> hook_complete U.

Lemma get_protocol_hooks (U: world) K l:
  valid U -> getProtocol (U \+ (Unit, K)) l = getProtocol U l.

Lemma coh_hooks (U : world) K s :
  s \In (Coh (U \+ (Unit, K))) -> s \In (Coh U).

Lemma inj_hooks_complete (U W : world) K:
  valid (U \+ W \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma inject_step U W K this s1 s2 s1' s2' :
  valid (U \+ W) ->
  s1 \In Coh U -> s2 \In Coh U ->
  hook_complete U -> hook_complete W ->
  network_step (U \+ W \+ (Unit, K)) this (s1 \+ s1') (s2 \+ s2') ->
  network_step U this s1 s2 /\ s1' = s2' \/
  network_step W this s1' s2' /\ s1 = s2.

Definition not_hooked_by (K : hooks) l :=
  forall z lc l' st, (z, lc, (l', st)) \in dom K -> l != l'.

Definition world_not_hooked (W: world) K :=
  forall l, l \in dom W.1 -> not_hooked_by K l.

Lemma hooks_frame (U W : world) (K : hooks) l st s s' n msg to :
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma inject_frame U W K this s1 s2 s:
  s1 \+ s \In Coh (U \+ W \+ (Unit, K)) ->
  network_step U this s1 s2 ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (U \+ W).1 K ->

Lemma injectL (U W : world) K :
  valid (U \+ W \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (getc (U \+ W)) K ->
  world_not_hooked U K ->
  injects U (U \+ W \+ (Unit, K)) K.

Lemma injectR (U W : world) K :
  valid (W \+ U \+ (Unit, K)) ->
  hook_complete U -> hook_complete W ->
  hooks_consistent (getc (U \+ W)) K ->
  world_not_hooked U K ->
  injects U (W \+ U \+ (Unit, K)) K.

Lemma locProjL (W1 W2 : world) l s1 s2:
  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W1.1 ->

Lemma locProjR (W1 W2 : world) l s1 s2:
  (s1 \+ s2) \In Coh (W1 \+ W2) -> l \in dom W2.1 ->

End InjectExtra.

Export InjectExtra. *)
(* Process:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem.
From DiSeL
Require Import Actions Injection InductiveInv.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section ProcessSyntax.

Variable this : nid.

Inductive proc (W : world) A :=
  Unfinished | Ret of A | Act of action W A this |
  Seq B of proc W B & B -> proc W A |
  Inject V K of injects V W K & proc V A |
  WithInv p I (ii : InductiveInv p I) of
          W = mkWorld (ProtocolWithIndInv ii) & proc (mkWorld p) A.  

Definition pcat W A B (t : proc W A) (k : A -> Pred (proc W B)) :=
  [Pred s | exists q, s = Seq t q /\ forall x, q x \In k x].

Inductive schedule :=
  ActStep | SeqRet | SeqStep of schedule |  
  InjectStep of schedule | InjectRet |
  WithInvStep of schedule | WithInvRet.

End ProcessSyntax.

Arguments Unfinished [this W A].
Arguments Ret [this W A].
Arguments Act [this W A].
Arguments Seq [this W A B].
Arguments WithInv [this W A].

Section ProcessSemantics.

Variable this : nid.

Fixpoint step (W : world) A (s1 : state) (p1 : proc this W A)
         sc (s2 : state) (p2 : proc this W A) : Prop :=
  match sc, p1 with
    
  | ActStep, Act a => exists v pf, @a_step _ _ _ a s1 pf s2 v /\ p2 = Ret v
    
  | SeqRet, Seq _ (Ret v) k => s2 = s1 /\ p2 = k v
  | SeqStep sc', Seq _ p' k1 => 
    exists p'', step s1 p' sc' s2 p'' /\ p2 = Seq p'' k1
  
  | InjectRet, Inject V K pf (Ret v) =>
     exists s1', [/\ s2 = s1, p2 = Ret v & extends pf s1 s1']
  | InjectStep sc', Inject V K pf t1' =>
    exists s1' s2' s t2', 
    [/\ p2 = Inject pf t2', s1 = s1' \+ s, s2 = s2' \+ s, 
     s1' \In Coh V & step s1' t1' sc' s2' t2']
  
  | WithInvRet, WithInv p inv ii pf (Ret v) =>
     exists s1', [/\ s2 = s1, p2 = Ret v & s1 = s1']
  | WithInvStep sc', WithInv p inv ii pf t1' =>
    exists t2', p2 = WithInv p inv ii pf t2' /\  
                     step s1 t1' sc' s2 t2'   
  | _, _ => False
  end.

Fixpoint good (W : world) A (p : proc this W A) sc  : Prop :=
  match sc, p with
  | ActStep, Act _ => True
  | SeqRet, Seq _ (Ret _) _ => True
  | SeqStep sc', Seq _ p' _ => good p' sc'
  | InjectStep sc', Inject _ _ _ p' => good p' sc'
  | InjectRet, Inject _ _ _ (Ret _) => True
  | WithInvStep sc', WithInv _ _ _ _ p' => good p' sc'
  | WithInvRet, WithInv _ _ _ _ (Ret _) => True
  | _, _ => False
  end.

Fixpoint safe (W : world) A (p : proc this W A) sc (s : state)  : Prop :=
  match sc, p with
  | ActStep, Act a => a_safe a s
  | SeqRet, Seq _ (Ret _) _ => True
  | SeqStep sc', Seq _ p' _ => safe p' sc' s
  | InjectStep sc', Inject V K pf p' =>
      exists s', extends pf s s' /\ safe p' sc' s'
  | InjectRet, Inject V K pf (Ret _) => exists s', extends pf s s'
  | WithInvStep sc', WithInv _ _ _ _ p' => safe p' sc' s
  | WithInvRet, WithInv _ _ _ _ (Ret _) => True
  | _, _ => True
  end.

Definition pstep (W : world) A s1 (p1 : proc this W A) sc s2 p2 := 
  [/\ s1 \In Coh W, safe p1 sc s1 & step s1 p1 sc s2 p2].

Lemma pstep_safe (W : world) A s1 (t : proc this W A) sc s2 q : 
        pstep s1 t sc s2 q -> safe t sc s1.

Lemma proc_progress W A s (p : proc this W A) sc : 
        s \In Coh W -> safe p sc s -> good p sc ->  
        exists s' (p' : proc this W A), pstep s p sc s' p'.

Lemma stepUnfin W A s1 sc s2 (t : proc this W A) : 
        pstep s1 Unfinished sc s2 t <-> False.

Lemma stepRet W A s1 sc s2 (t : proc this W A) v : 
        pstep s1 (Ret v) sc s2 t <-> False.

Lemma stepAct W A s1 a sc s2 (t : proc this W A) : 
        pstep s1 (Act a) sc s2 t <->
        exists v pf, [/\ sc = ActStep, t = Ret v & @a_step _ _ _ a s1 pf s2 v].

Lemma stepSeq W A B s1 (t : proc this W B) k sc s2 (q : proc this W A) :
        pstep s1 (Seq t k) sc s2 q <->
        (exists v, [/\ sc = SeqRet, t = Ret v, q = k v, s2 = s1 &
                       s1 \In Coh W]) \/
         exists sc' p',
           [/\ sc = SeqStep sc', q = Seq p' k & pstep s1 t sc' s2 p'].

Lemma stepInject V W K A (em : injects V W K) 
                s1 (t : proc this V A) sc s2 (q : proc this W A) :
  pstep s1 (Inject em t) sc s2 q <->
  
  (exists s1' v, [/\ sc = InjectRet, t = Ret v, q = Ret v, s2 = s1 &
                     extends em s1 s1']) \/
  
  exists sc' t' s1' s2' s, 
    [/\ sc = InjectStep sc', q = Inject em t', 
     s1 = s1' \+ s, s2 = s2' \+ s, s1 \In Coh W &
              pstep s1' t sc' s2' t'].

Lemma stepWithInv W A pr I (ii : InductiveInv pr I) s1 
      (t : proc this (mkWorld pr) A) sc s2 (q : proc this W A) pf :
  pstep s1 (WithInv pr I ii pf t) sc s2 q <-> 
  (exists v, [/\ sc = WithInvRet, t = Ret v, q = Ret v, s2 = s1,
                 s1 \In Coh W & W = mkWorld (ProtocolWithIndInv ii)]) \/
  exists sc' t' , [/\ sc = WithInvStep sc', q = WithInv pr I ii pf t',
                      W = mkWorld (ProtocolWithIndInv ii),
                      s1 \In Coh W & pstep s1 t sc' s2 t'].

Lemma pstep_network_sem (W : world) A s1 (t : proc this W A) sc s2 q :
        pstep s1 t sc s2 q -> network_step W this s1 s2.

Lemma pstep_inv A pr I (ii : InductiveInv pr I) s1 s2 sc
      (t t' : proc this (mkWorld pr) A):
  s1 \In Coh (mkWorld (ProtocolWithIndInv ii)) ->
  pstep s1 t sc s2 t' -> 
  s2 \In Coh (mkWorld (ProtocolWithIndInv ii)).

End ProcessSemantics. *)
(* Always:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process InductiveInv.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Always.

Variable this : nid.
Variable W : world.

Notation coherent := (Coh W).

Arguments proc [this W].

Fixpoint always_sc A (s1 : state) p scs (P : state -> proc A -> Prop) : Prop :=
  s1 \In coherent /\ 
  if scs is sc :: scs' then 
    forall s2, network_rely W this s1 s2 -> 
      [/\ safe p sc s2, P s2 p &
          forall s3 q, @pstep this W A s2 p sc s3 q -> always_sc s3 q scs' P]
  else forall s2, network_rely W this s1 s2 -> P s2 p.

Definition always A s (p : proc A) P := forall scs, always_sc s p scs P.

Lemma alw_coh' A s (p : proc A) scs P : 
        always_sc s p scs P -> s \In coherent.

Lemma alw_coh A s (p : proc A) P : 
        always s p P -> s \In coherent.

Lemma alw_safe' A s (p : proc A) sc scs P : 
        always_sc s p (sc :: scs) P -> safe p sc s.

Lemma alw_safe A s (p : proc A) P :
        always s p P -> forall sc, safe p sc s.

Lemma alw_refl' A s (p : proc A) sc P : always_sc s p sc P -> P s p.

Lemma alw_refl A s (p : proc A) P : always s p P -> P s p.

Lemma alw_envs' A s1 (p : proc A) scs s2 P : 
        always_sc s1 p scs P -> network_rely W this s1 s2 -> always_sc s2 p scs P.
 
Lemma alw_envs A s1 (p : proc A) s2 P :
        always s1 p P -> network_rely W this s1 s2 -> always s2 p P.

Lemma alw_step A s1 (p : proc A) sc s2 q P :
        always s1 p P -> pstep s1 p sc s2 q -> always s2 q P.

Lemma alwp_envsq A s1 (p1 : proc A) scs (P : _ -> _ -> Prop) : 
        always_sc s1 p1 scs P ->
        always_sc s1 p1 scs 
          (fun s2 p2 => forall s3, network_rely W this s2 s3 -> P s3 p2).

Lemma alw_envsq A s1 (p1 : proc A) (P : _ -> _ -> Prop) : 
        always s1 p1 P ->
        always s1 p1 (fun s2 p2 => forall s3, network_rely W this s2 s3 -> P s3 p2).

Lemma alw_unfin' A s1 scs (P : state -> proc A -> Prop) :
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 Unfinished) -> 
        always_sc s1 Unfinished scs P.

Lemma alw_unfin A s1 (P : state -> proc A -> Prop) :
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 Unfinished) ->
        always s1 Unfinished P.

Lemma alw_ret' A s1 (v : A) scs (P : state -> proc A -> Prop) : 
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 (Ret v)) -> 
        always_sc s1 (Ret v) scs P.

Lemma alw_ret A s1 (v : A) (P : state -> proc A -> Prop) : 
        s1 \In coherent -> 
        (forall s2, network_rely W this s1 s2 -> P s2 (Ret v)) -> 
        always s1 (Ret v) P.

Lemma alw_act A s1 (a : action W A this) (P : state -> proc A -> Prop) :
        s1 \In coherent ->
        (forall s2, network_rely W this s1 s2 -> exists S : a_safe a s2,
        P s2 (Act a) /\
        forall s3 v s4, a_step S s3 v -> 
                        network_rely W this s3 s4 -> P s4 (Ret v)) ->
        always s1 (Act a) P. 

Notation alwsafe_sc s p scs := (always_sc s p scs (fun _ _ => True)).
Notation alwsafe s p := (always s p (fun _ _ => True)).

Lemma alw_imp' A s (p : proc A) scs (P1 P2 : state -> proc A -> Prop) : 
         (forall s p, s \In coherent -> P1 s p -> P2 s p) -> 
         always_sc s p scs P1 -> always_sc s p scs P2.

Lemma alw_imp A s (p : proc A) (P1 P2 : state -> proc A -> Prop) : 
        (forall s p, s \In coherent -> P1 s p -> P2 s p) -> 
        always s p P1 -> always s p P2.

Lemma alwA' A B s (p : proc A) scs (P : B -> state -> proc A -> Prop) : 
        alwsafe_sc s p scs ->
        (always_sc s p scs (fun s' p' => forall x, P x s' p') <->
         forall x, always_sc s p scs (fun s' p' => P x s' p')).

Lemma alwA A B s (p : proc A) (P : B -> state -> proc A -> Prop) : 
        alwsafe s p ->
        (always s p (fun s' p' => forall x, P x s' p') <->
         forall x, always s p (fun s' p' => P x s' p')).

Arguments alwA [A B s p P].

Lemma alwI' A s (p : proc A) scs (P : Prop) (Q : state -> proc A -> Prop) : 
        alwsafe s p ->
        (always_sc s p scs (fun s' p' => P -> Q s' p') <->
         (P -> always_sc s p scs (fun s' p' => Q s' p'))).

Lemma alwI A s (p : proc A) (P : Prop) (Q : state -> proc A -> Prop) : 
        alwsafe s p ->
         always s p (fun s' p' => P -> Q s' p') <->
         (P -> always s p (fun s' p' => Q s' p')). 

Arguments alwI [A s p P Q].

Lemma alw_bnd A B (p1 : proc A) (p12 : proc B) pp2 s1 
                 (P : state -> B -> Prop) :
        p12 \In pcat p1 pp2 -> 
        always s1 p1 (fun s2 p2 =>
                        
          forall p v, p2 = Ret v -> p \In pp2 v -> 
                      always s2 p (fun s q => forall v, q = Ret v -> P s v)) ->
        always s1 p12 (fun s p => forall v, p = Ret v -> P s v).

Lemma alwsafe_bnd A B (p1 : proc A) (p12 : proc B) s1 pp2 :
        p12 \In pcat p1 pp2 ->
        always s1 p1 (fun s2 p2 =>
          forall p v, p2 = Ret v -> p \In pp2 v -> alwsafe s2 p) ->
        alwsafe s1 p12.

Definition after A s (p : proc A) (P : A -> state -> Prop) := 
  always s p (fun s2 p2 => forall v, p2 = Ret v -> P v s2).

Lemma aft_bnd A B (p1 : proc A) (p12 : proc B) pp2 s1 P :
        p12 \In pcat p1 pp2 -> 
        after s1 p1 (fun v s => 
          forall p, p \In pp2 v -> after s p P) ->
        after s1 p12 P.

Lemma aftI A s (p : proc A) (P : Prop) (Q : A -> state -> Prop) : 
        alwsafe s p ->
         after s p (fun v s' => P -> Q v s') <->
         (P -> after s p (fun v s' => Q v s')).

Lemma aft_alwsf A s (p : proc A) :
        alwsafe s p <-> after s p (fun v s => True).

Lemma aft_imp A s (p : proc A) (P1 P2 : A -> state -> Prop) : 
        (forall v s, s \In coherent -> 
                     P1 v s -> P2 v s) -> 
        after s p P1 -> after s p P2.

Lemma aftA A B s (p : proc A) (P : B -> A -> state -> Prop) : 
        alwsafe s p ->
        (after s p (fun v s' => forall x, P x v s') <->
         forall x, after s p (fun v s' => P x v s')).

Arguments aftA [A B s p P].
Arguments aftI [A s p P Q].

End Always.

Section AlwaysInject.
Variables (V W : world) (K : hooks) (A : Type) (w : injects V W K) (this: nid).
Notation W2 := (inj_ext w).

Lemma rely_ext i j s : 
        i \In Coh V -> 
        network_rely W this (i \+ j) s ->  
        exists i' j', s = i' \+ j' /\ i' \In Coh V.

Lemma rely_split' z s1 s1' s2 s2' : 
  s1 \In Coh V -> s2 \In Coh V ->
  network_step W z (s1 \+ s1') (s2 \+ s2') ->
  network_step V z s1 s2 /\ network_step (inj_ext w) z s1' s2'.

Lemma rely_split s1 s1' s2 s2' : 
  s1 \In Coh V -> s2 \In Coh V ->
  network_rely W this (s1 \+ s1') (s2 \+ s2') ->
  network_rely V this s1 s2 /\ network_rely (inj_ext w) this s1' s2'.

Lemma alw_inject (p : proc this V A)
      (P : state -> proc this V A -> Prop) i j :
        i \+ j \In Coh W ->
        always i p P ->
        always (i \+ j) (Inject w p)
          (fun m q => exists i' j', 
             [/\ m = i' \+ j', i' \In Coh V, network_rely W2 this j j' &
                 (exists q', q = Inject w q' /\ P i' q') \/
                 (exists v', q = Ret v' /\ P i' (Ret v'))]).

Lemma aft_inject (p : proc this V A) (P : A -> state -> Prop) i j :
        i \+ j \In Coh W ->
        after i p P ->
        after (i \+ j) (Inject w p)
          (fun v m => exists i' j', 
             [/\ m = i' \+ j', i' \In Coh V, 
                 network_rely W2 this j j' & P v i']).

End AlwaysInject.

Notation alwsafe_sc s p scs := (always_sc s p scs (fun _ _ => True)).
Notation alwsafe s p := (always s p (fun _ _ => True)).

Module AlwaysInductiveInv.
Section AlwaysInductiveInv.
Import InductiveInv.
Variable pr : protocol.

Notation l := (plab pr).
Notation coh := (coh pr).
Variable I : dstatelet -> pred nid -> Prop.
Variable ii : InductiveInv pr I.

Variables (A : Type) (this: nid).
Notation V := (mkWorld pr).
Notation W := (mkWorld (ProtocolWithIndInv ii)).

Lemma alw_ind_inv (p : proc this V A)
      (P : state -> proc this V A -> Prop) i :
        i \In Coh W ->
        always i p P ->
        always i (WithInv pr I ii (erefl _) p)
          (fun m q => m \In Coh W /\
                 ((exists q', q = WithInv pr I ii (erefl _) q' /\ P m q') \/
                  (exists v', q = Ret v' /\ P m (Ret v')))).

Lemma aft_ind_inv (p : proc this V A) (P : A -> state -> Prop) i :
        i \In Coh W ->
        after i p P ->
        after i (WithInv pr I ii (erefl _) p)
          (fun v m => m \In Coh W /\ P v m).

End AlwaysInductiveInv.
End AlwaysInductiveInv.

Export AlwaysInductiveInv. *)
(* HoareTriples:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Domain Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Structure prog (W : world) A (this : nid) :=
  Prog {
      set_of : proc this W A -> Prop; 
      
      _ : set_of Unfinished
  }.

Section Programs.

Variable this : nid.
Variable W : world.
Variable A : Type.

Notation coherent := (Coh W).

Arguments Prog [W A].
Arguments Prog [W A this].

Coercion set_of : prog >-> Funclass. 
Canonical prog_PredType W A := mkPredType (fun p => @set_of W A this p). 

Lemma progE (T1 T2 : prog W A this) : 
        T1 = T2 <-> set_of T1 = set_of T2.

Definition pre := state -> Prop.

Definition post A := state -> A -> state -> Prop.
Definition cont A := A -> state -> Prop.
Definition spec A := prod pre (post A).

Definition has_spec (s : spec A) := 
  [Pred T : prog W A this | forall i t, 
     s.1 i -> i \In Coh W -> t \In T -> after i t (s.2 i)]. 

End Programs.

Module DTbin.
Section DTbin.

Variable this : nid.

Structure DTbin (W : world) A (s : spec A) := DTbin_make {
  prog_of : prog W A this; 
  _ : prog_of \In has_spec this W s}.

End DTbin.
End DTbin.

Notation DTbin := DTbin.DTbin.
Notation DTbin_make := DTbin.DTbin_make.

Coercion DTbin.prog_of : DTbin >-> prog.

Section Specs.

Variable this : nid.

Lemma stsepE (W : world) A (s : spec A) (e1 e2 : DTbin this W s) : 
        e1 = e2 <-> e1 = e2 :> prog W A this.

Lemma prog_unfin (W : world) A (s : spec A) (e : DTbin this W s) : 
        Unfinished \In DTbin.prog_of e.

Inductive DT (W: world) A :=
  with_spec (s : spec A) of DTbin this W s.

Definition spec_of W A (e : DT W A) := let: with_spec s _ := e in s.
Definition pre_of W A := fun e : DT W A => (spec_of e).1. 
Definition post_of W A := fun e : DT W A => (spec_of e).2. 

Definition code_of (W : world) A (e : DT W A) := 
  let: with_spec _ c := e return DTbin this W (spec_of e) in c.

Arguments pre_of [W A].
Arguments post_of [W A].
Arguments with_spec [W A].
Prenex Implicits pre_of post_of.

Coercion with_spec : DTbin >-> DT.

Definition verify (W : world) A (i : state) (e : DT W A) r := 
  i \In Coh W -> 
  forall p, p \In DTbin.prog_of (code_of e) -> after i p r. 

End Specs.

Module DTLattice.
Section DTLattice.

Variable this : nid.
Variable W : world.
Variables (A : Type) (s : spec A).
Notation prog A := (@prog W A this).
Notation DTbin s := (@DTbin this W A s).

Definition leq (e1 e2 : DTbin s) := 
  set_of (DTbin.prog_of e1) <== set_of (DTbin.prog_of e2).

Lemma leq_refl e : leq e e. 

Lemma leq_trans e1 e2 e3 : leq e1 e2 -> leq e2 e3 -> leq e1 e3.

Lemma leq_asym e1 e2 : leq e1 e2 -> leq e2 e1 -> e1 = e2.

Definition bot_set t := t = @Unfinished this W A. 
Definition bot_prg := @Prog _ _ _ bot_set (erefl _).

Lemma bot_spec : bot_prg \In has_spec this W s.

Definition bot := DTbin_make bot_spec.

Lemma bot_bot e : leq bot e.

Definition sup_set (es : Pred (DTbin s)) t := 
  t = Unfinished \/ exists e : DTbin s, t \In DTbin.prog_of e /\ e \In es.
Definition sup_prog es := @Prog _ _ _ (sup_set es) (or_introl (erefl _)).

Lemma sup_spec es : sup_prog es \In has_spec this W s.

Definition sup es := DTbin_make (@sup_spec es).

Lemma sup_supB es e : e \In es -> leq e (sup es).

Lemma sup_supL es e : (forall c, c \In es -> leq c e) -> leq (sup es) e.

End DTLattice.

Module Exports.
Section Exports.
Variable this : nid.
Variable W : world.
Variables (A : Type) (s : spec A).

Definition stPosetMixin := PosetMixin (@leq_refl this W A s) 
                                      (@leq_asym this W A s) (@leq_trans this W A s).
Canonical stPoset := Eval hnf in Poset (@DTbin this W A s) stPosetMixin.

Definition stLatticeMixin := LatticeMixin (@sup_supB this W A s) (@sup_supL this W A s).
Canonical stLattice := Eval hnf in Lattice (@DTbin this W A s) stLatticeMixin.

End Exports.
End Exports.

End DTLattice.

Export DTLattice.Exports.

Section Fix. 

Variable this : nid.
Variable W : world.
Variables (A : Type)  (B : A -> Type) (s : forall x, spec (B x)).

Notation tp := (forall x, DTbin this W (s x)).
Notation lat := (dfunLattice (fun x => [lattice of DTbin this W (s x)])).
Variable (f : tp -> tp).

Definition f' (e : lat) := sup [Pred t : lat | exists e', e' <== e /\ t = f e'].

Definition ffix : tp := tarski_lfp f'. 

End Fix.

Section Return.
Variable this : nid.
Variable W : world.
Variables (A : Type)  (x : A).

Definition ret_set t := t = Unfinished \/ t = @Ret this W A x.

Definition ret_prog := @Prog _ _ _ ret_set (or_introl (erefl _)).

Definition ret_s : spec A := 
  (fun i => True, fun i y m => network_rely W this i m /\ y = x). 

Lemma ret_has_spec : ret_prog \In has_spec this W ret_s.

Definition ret := with_spec (DTbin_make ret_has_spec). 

End Return.

Section Act.
Variable this : nid.
Variable W : world.
Variables (A : Type)  (x : A).
Variable a : action W A this.

Definition act_set t := t = Unfinished \/ t = @Act this W A a.
Definition act_prog := @Prog _ _ _ act_set (or_introl (erefl _)).

Definition act_s : spec A := 
  (fun i => forall j, network_rely W this i j -> a_safe a j,
   fun i y m => exists j k, 
       [/\ network_rely W this i j,
        exists (S: a_safe a j), a_step S k y & network_rely W this k m]). 

Lemma act_has_spec : act_prog \In has_spec this W act_s.

Definition act := with_spec (DTbin_make act_has_spec).

End Act.

Section Bind.

Variable this : nid.
Variable W : world.
Variables (A B : Type).

Section Prog.
Variables (T : prog W A this) (K : A -> prog W B this).

Definition bnd_set t := 
  t = Unfinished \/ exists t', t \In pcat t' K /\ t' \In T.
Definition bnd_prog := @Prog _ _ _ bnd_set (or_introl (erefl _)).

End Prog.

Variables (e1 : DT this W A) (e2 : A -> DT this W B).

Notation s1 := (spec_of e1).

Notation s2 := (fun x => spec_of (e2 x)).

Definition bind_s : spec B := 
  (fun i => s1.1 i /\ forall x s, s1.2 i x s -> (s2 x).1 s,
   fun i y m => exists x s, s1.2 i x s /\ (s2 x).2 s y m).

Lemma bind_has_spec : 
        bnd_prog (code_of e1) (fun x => let y := e2 x in code_of y) \In has_spec this W bind_s.

Definition bind := with_spec (DTbin_make bind_has_spec).

End Bind.

Section Inject.
Variables (this : nid) (V W : world) (K : hooks) (A : Type) (w : injects V W K). 
Variable (e : DT this V A).
Notation W2 := (inj_ext w). 
Notation s := (spec_of e).

Section Prog.

Variable T : prog V A this.

Definition inject_set t := 
  t = Unfinished \/ exists t', t' \In T /\ t = Inject w t'. 
Definition inject_prog := @Prog _ _ _ inject_set (or_introl (erefl _)).
End Prog.

Definition inject_s : spec A :=
  (fun i => exists i1 i2, i = i1 \+ i2 /\ i1 \In Coh V /\ s.1 i1, 
   fun i y m => forall i1 i2, i = i1 \+ i2 -> i1 \In Coh V -> 
     exists m1 m2, [/\ m = m1 \+ m2, s.2 i1 y m1 &
                       network_rely W2 this i2 m2]).

Lemma inject_has_spec : inject_prog (code_of e) \In has_spec this W inject_s.

Definition inject := with_spec (DTbin_make inject_has_spec).

End Inject.

From DiSeL
Require Import InductiveInv.

Section InductiveInv.
Variable pr : protocol.

Notation l := (plab pr).
Notation coh := (coh pr).
Variable I : dstatelet -> pred nid -> Prop.
Variable ii : InductiveInv pr I.

Variables (A : Type) (this: nid).
Notation V := (mkWorld pr).
Notation W := (mkWorld (ProtocolWithIndInv ii)).

Variable (e : DT this V A).
Notation s := (spec_of e).

Section Prog.

Variable T : prog V A this.

Definition with_inv_set t := 
  t = Unfinished \/ exists t', t' \In T /\ t = WithInv pr I ii (erefl _) t'. 
Definition with_inv_prog := @Prog _ _ _ with_inv_set (or_introl (erefl _)).
End Prog.

Notation getS i := (getStatelet i l).

Definition with_inv_s : spec A :=
  (fun i => s.1 i, 
   fun i y m => m \In Coh W /\ s.2 i y m).

Lemma with_inv_has_spec : with_inv_prog (code_of e) \In has_spec this W with_inv_s.

Definition with_inv := with_spec (DTbin_make with_inv_has_spec).

End InductiveInv.

Definition conseq (W : world) A this (e : DT this W A) (s : spec A) := 
  forall i, s.1 i -> verify i e (s.2 i). 

Lemma conseq_refl (W : world) A this (e : DT this W A) :
  conseq e (spec_of e).

Hint Resolve conseq_refl.

Section Do.

Variable this : nid.
Variables (W : world) (A : Type) (s2 : spec A).
Variables (e : DT this W A) (pf : conseq e s2).

Definition do_prog := DTbin.prog_of (code_of e).

Lemma do_has_spec : do_prog \In has_spec this W s2. 

Definition do' := DTbin_make do_has_spec.

End Do.

Notation iinject x := (@inject _ _ _ _ _ _ x).
Notation uinject x := (@inject _ _ _ Unit _ _ x).

Notation "'Do' e" := (@do' _ _ _ _ e _) (at level 80).

Notation "x '<--' c1 ';' c2" := (bind c1 (fun x => c2)) 
  (at level 81, right associativity).
Notation "c1 ';;' c2" := (bind c1 (fun _ => c2)) 
  (at level 81, right associativity). *)
(* InferenceRules:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Domain Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always HoareTriples InductiveInv.
Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Definition logvar {B A} (s : A -> spec B) : spec B := 
  (fun i => exists x : A, (s x).1 i, 
   fun y i m => forall x : A, (s x).2 y i m).

Definition binarify {A} (p : pre) (q : cont A) : spec A := 
  (p, fun i y m => p i -> q y m).

Notation "'DHT' [ this , W ] ( p , q ) " := 
  (DTbin this W (binarify p q)) (at level 0, 
   format "'[hv ' DHT  [ this , W ]  ( '[' p , '/' q ']' ) ']'").  

Notation "{ x .. y }, 'DHT' [ this , W ] ( p , q )" :=
  (DTbin this W (logvar (fun x => .. (logvar (fun y => binarify p q)) .. )))
   (at level 0, x binder, y binder, right associativity,
    format "'[hv ' { x .. y }, '/ ' DHT  [ this , W ]  ( '[' p , '/' q ']' ) ']'").

Section BasicRules.

Variable this : nid.

Lemma vrf_coh W A (e : DT this W A) i r : 
        (i \In Coh W -> verify i e r) -> verify i e r.

Lemma vrf_pre W A (e : DT this W A) i i' (k : cont A) : 
        verify i e k -> network_rely W this i i' -> verify i' e k. 

Lemma vrf_post W A (e : DT this W A) i (k : cont A) : 
        verify i e k ->
        verify i e (fun x m => forall m', network_rely W this m m' -> k x m').

Lemma bind_rule W A B (e1 : DT this W A) (e2 : A -> DT this W B) i 
             (q : cont A) (r : cont B) : 
        verify i e1 q -> 
        (forall y j, q y j -> j \In Coh W  -> verify j (e2 y) r) ->
        verify i (bind e1 e2) r.

Arguments bind_rule [W A B e1 e2 i].

Lemma step W A B (e1 : DT this W A) (e2 : A -> DT this W B) i (r : cont B) : 
        verify i e1 (fun y m => verify m (e2 y) r) ->
        verify i (bind e1 e2) r.

Lemma call_rule' W A i (f : DT this W A) (k : cont A) : 
  
  (i \In Coh W -> pre_of f i) ->
  
  (forall x m, post_of f i x m -> m \In Coh W -> k x m) ->
  verify i f k.

Lemma call_rule W A (p : Pred state) (q : A -> Pred state) i
      {e} (k : cont A) : 
        (i \In Coh W -> p i) -> 
        (forall x m, q x m -> m \In Coh W -> k x m) ->
        verify i (@with_spec this W A (binarify p q) e) k.

Section GhostRules.

Variables (W : world) (A B C : Type). 

Lemma vrf_mono (e : DT this W A) i (r1 r2 : cont A) : 
        r1 <== r2 -> verify i e r1 -> verify i e r2. 

Variable (e : DT this W A).

Lemma ghE (s : B -> C -> spec A) : 
        conseq e (logvar (fun x => logvar (s x))) <->
        conseq e (logvar (fun xy => s xy.1 xy.2)).

Lemma ghC (p : B -> pre) (q : B -> A -> pre) :
        (forall i x, p x i -> i \In Coh W -> verify i e (q x)) ->
        conseq e (logvar (fun x => binarify (p x) (q x))).

Variables (s : C -> spec A) (f : DTbin this W (logvar s)).

Lemma gh_conseq t : conseq f (s t).

Lemma gh_ex g i (k : cont A) : 
        verify i (do' (@gh_conseq g)) k ->
        verify i (@with_spec this W A (logvar s) f) k.

End GhostRules.

Arguments gh_ex [W A C s f].

Lemma act_rule W A (a: action W A this) i (r : cont A) :
  (forall j, network_rely W this i j -> a_safe a j /\
   forall y k m, (exists pf : a_safe a j, a_step pf k y) -> network_rely W this k m -> r y m) ->
        verify i (act a) r. 

Lemma ret_rule W A i (v : A) (r : cont A) : 
       (forall m, network_rely W this i m -> r v m) ->       
       verify i (ret this W v) r. 

End BasicRules.

Section InjectLemmas.

Variable this : nid.
Variables (W V : world) (K : hooks) (A : Type) (w : injects V W K).
Notation W2 := (inj_ext w).

Variable (e1 : DT this V A).

Lemma inject_rule i j (r : cont A) : 
        i \In Coh V -> 
        verify i e1 (fun x i' => forall j', 
          i' \+ j' \In Coh W -> network_rely W2 this j j' -> r x (i' \+ j')) ->
        verify (i \+ j) (inject w e1) r.

End InjectLemmas.

Section InductiveInvLemmas.

Variable pr : protocol.

Notation l := (plab pr).
Variable I : dstatelet -> pred nid -> Prop.
Variable ii : InductiveInv pr I.

Variables (A : Type) (this: nid).
Notation V := (mkWorld pr).
Notation W := (mkWorld (ProtocolWithIndInv ii)).

Variable (e : DT this V A).

Notation getS i := (getStatelet i l).

Lemma with_inv_rule' i (r : cont A) : 
  verify i e (fun x m =>
              I (getS m) (nodes pr (getS m)) -> r x m) ->
        verify i (with_inv ii e) r.

Lemma with_inv_rule i (r : cont A) : 
        verify i e (fun x m => r x m) ->
        verify i (with_inv ii e) r.

End InductiveInvLemmas. *)
From DiSeL
Require Import InductiveInv While StatePredicates.
(* InductiveInv:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.
Require FunctionalExtensionality.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Module ProtocolWithInvariant.
Section ProtocolWithInvariant.

Variable p : protocol.

Notation l := (plab p).
Notation coh := (coh p).

Variable I : dstatelet -> pred nid -> Prop.

Variable d0 : dstatelet.

Definition W := mkWorld p.

Notation toSt d := (l \\-> d).

Definition cohI :=
  [Pred d | coh d /\ I d (nodes p d)].

Lemma cohIVd d : cohI d -> valid (dstate d).

Lemma cohIVs d : cohI d -> valid (dsoup d).

Lemma cohIDom d : cohI d -> dom (dstate d) =i nodes p d.

Definition CohI := CohPred (CohPredMixin cohIVd cohIVs cohIDom).

Lemma st_helper d : (getStatelet (toSt d) l) = d.

Lemma cohSt d : coh d -> Coh W (toSt d).

Section SendInvWrapper.

Variable st : send_trans coh.

Definition send_safeI this to d m :=
  send_safe st this to d m /\ I d (nodes p d).

Lemma s_safe_cohI this to d m : send_safeI this to d m -> CohI d.

Lemma s_safe_inI this to d m : send_safeI this to d m ->
                               this \in nodes p d /\ to \in nodes p d.

Definition send_stepI: send_step_t (send_safeI) :=
  fun this to d msg S => (@send_step _ _ st this to d msg (proj1 S)).

Lemma s_safe_defI this to d msg :
  send_safeI this to d msg <->
  exists b pf, @send_stepI this to d msg pf = Some b.

Definition S_inv := forall this to d msg (S : send_safe st this to d msg) b,
    I d (nodes p d) -> Some b = send_step S ->
    let: f' := upd this b (dstate d) in
    let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in
    let: d' := DStatelet f' s' in
    (forall z, z == this = false -> getLocal z d' = getLocal z d) ->
    I d' (nodes p d').

Hypothesis HIstep : S_inv.

Lemma s_step_cohI : s_step_coh_t CohI (t_snd st) send_stepI.

Definition snd_transI := SendTrans s_safe_cohI s_safe_inI s_safe_defI s_step_cohI.

End SendInvWrapper.

Section ReceiveInvWrapper.

Variable rt : receive_trans coh.

Definition receive_stepI: receive_step_t CohI :=
  fun this from m d C pf => receive_step rt from m (proj1 C) pf.

Definition R_inv := forall d from this i (C : coh d) m
                           (pf: this \in nodes p d),
    I d (nodes p d) ->
    find i (dsoup d) = Some (Msg m from this true) ->
    this \in dom (dstate d) ->
    msg_wf rt C this from m -> tag m = t_rcv rt ->
    let: loc' := receive_step rt from m C pf in
    let: s'' := consume_msg (dsoup d) i in
    let: f' := upd this loc' (dstate d) in
    let: d' := (DStatelet f' s'') in
    (forall z, z == this = false -> getLocal z d' = getLocal z d) ->
    I d' (nodes p d').

Hypothesis HIstep : R_inv.

Notation msg_wfI := (fun d (C : CohI d) => msg_wf rt (proj1 C)).

Lemma r_step_cohI :
  r_step_coh_t msg_wfI (t_rcv rt) receive_stepI.

Definition rcv_transI := @ReceiveTrans _ CohI _ msg_wfI _ r_step_cohI.

End ReceiveInvWrapper.

Structure SendInv := SI {
  st : send_trans coh;
  st_inv : S_inv st;
}.

Structure ReceiveInv := RI {
  rt : receive_trans coh;
  rt_inv : R_inv rt;
}.

Structure InductiveInv := II {
  sts : seq SendInv;
  rts : seq ReceiveInv;
  _ : map st sts = snd_trans p;
  _ : map rt rts = rcv_trans p
}.

Definition stsI sts := map (fun stt =>
                          @snd_transI (st stt) (@st_inv stt)) sts.
Definition rtsI rts := map (fun rtt =>
                          @rcv_transI (rt rtt) (@rt_inv rtt)) rts.

Import FunctionalExtensionality.

Variable ii : InductiveInv.

Lemma us : uniq (map (@t_snd _ _) (stsI (sts ii))).

Lemma ur : uniq (map (@t_rcv _ _) (rtsI (rts ii))).

Definition ProtocolWithIndInv := @Protocol _ l _ _ _ us ur.

Lemma stIn (s : SendInv) :
  s \In (sts ii) ->
  (snd_transI (@st_inv s)) \In (snd_trans ProtocolWithIndInv).

Lemma rtIn (r : ReceiveInv) :
  r \In (rts ii) ->
  (rcv_transI (@rt_inv r)) \In (rcv_trans ProtocolWithIndInv).

Lemma getInvSendTrans st z to msg s1 h :
  st \In (snd_trans ProtocolWithIndInv) ->
  forall (S : send_safe st z to (getStatelet s1 (plab p)) msg),
  Some h = send_step S ->
  exists st', [/\ st' \In get_st (mkWorld p) (plab p),
     t_snd st' = t_snd st,
     all_hooks_fire (mkWorld p) (plab p) (t_snd st') s1 z msg to &          
     exists S': (send_safe st' z to (getStatelet s1 (plab p)) msg),
       Some h = send_step S'].

End ProtocolWithInvariant.

Section InductiveInvConj.

Variable p : protocol.

Definition s_inv_conj (I1 I2 : dstatelet -> pred nid -> Prop)
           (st : send_trans (coh p)) :=
  S_inv (fun d n => I1 d n /\ I2 d n) st.

Lemma s_inv_conjC I1 I2 st :
  s_inv_conj I1 I2 st <-> s_inv_conj I2 I1 st.

Lemma s_inv_conjA I1 I2 I3 st :
  s_inv_conj I1 (fun d n => I2 d n /\ I3 d n) st <->
  s_inv_conj (fun d n => I1 d n /\ I2 d n) I3 st.

Definition r_inv_conj (I1 I2 : dstatelet -> pred nid -> Prop)
           (rt : receive_trans (coh p)) :=
  R_inv (fun d n => I1 d n /\ I2 d n) rt.

Lemma r_inv_conjC I1 I2 rt :
  r_inv_conj I1 I2 rt <-> r_inv_conj I2 I1 rt.

Lemma r_inv_conjA I1 I2 I3 rt :
  r_inv_conj I1 (fun d n => I2 d n /\ I3 d n) rt <->
  r_inv_conj (fun d n => I1 d n /\ I2 d n) I3 rt.

End InductiveInvConj.

End ProtocolWithInvariant.

Module PWIExports.
Section PWIExports.

Import ProtocolWithInvariant.

Definition st_helper := st_helper.
Definition cohSt := cohSt.

Definition S_inv := ProtocolWithInvariant.S_inv.
Definition R_inv := ProtocolWithInvariant.R_inv.

Definition SendInv := SendInv.
Definition SI := SI.
Definition ReceiveInv := ReceiveInv.
Definition RI := RI.

Definition InductiveInv := InductiveInv.

Lemma with_inv_coh pr I (ii : InductiveInv pr I) s:
  s \In Coh (mkWorld (ProtocolWithIndInv ii)) ->    
  s \In Coh (mkWorld pr).

Lemma with_inv_nodes pr I (ii : InductiveInv pr I) l :
  nodes (getProtocol (mkWorld (ProtocolWithIndInv ii)) l) =
  nodes (getProtocol (mkWorld pr) l).

Lemma with_inv_labE pr I (ii : InductiveInv pr I):
  plab (ProtocolWithIndInv ii) = plab pr.

Lemma with_inv_step pr I (ii : InductiveInv pr I) z s1 s2:
  s1 \In Coh (mkWorld (ProtocolWithIndInv ii)) ->
  network_step (mkWorld pr) z s1 s2 ->
  network_step (mkWorld (ProtocolWithIndInv ii)) z s1 s2.

Lemma with_inv_step' pr I (ii : InductiveInv pr I) z s1 s2:
  network_step (mkWorld (ProtocolWithIndInv ii)) z s1 s2 ->
  network_step (mkWorld pr) z s1 s2.

Lemma with_inv_rely' pr I (ii : InductiveInv pr I) z s1 s2:
  network_rely (mkWorld (ProtocolWithIndInv ii)) z s1 s2 ->
  network_rely (mkWorld pr) z s1 s2.

Definition ProtocolWithIndInv := ProtocolWithIndInv.

End PWIExports.
End PWIExports.

Export PWIExports. *)
(* While:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always HoareTriples InferenceRules.
Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Section While.
Variable this : nid.
Variable W : world.

Variable A B : Type.
Variable cond : B -> bool.
Variable I : A -> cont B.
Variable I_stable : forall a b s0 s1, I a b s0 -> network_rely W this s0 s1 -> I a b s1.

Notation body_spec' :=
  (fun b a => binarify (fun s => cond b /\ I a b s) (fun b' s1 => I a b' s1)).

Notation body_spec := (forall b : B, DTbin this W (logvar (body_spec' b))).

Variable body : body_spec.

Definition loop_spec := forall b, 
  {a : A}, DHT [this, W]
  (fun s => I a b s, fun b' s1 => ~~ cond b' /\ I a b' s1).

Program Definition while b0 : 
  {a : A}, DHT [this, W]
  (fun s => I a b0 s,
   fun b' s1 => ~~ cond b' /\ I a b' s1) :=
  Do (ffix (fun (rec : loop_spec) (b : B) =>
              Do (if cond b
                  then (b' <-- body b;
                       rec b')
                  else ret _ _ b)) b0).

End While. *)
(* StatePredicates:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section SoupPredicates.

Definition msg_in_soup (from to : nid) (criterion : nat -> seq nat -> bool)
           (d : soup) : Prop :=
  (exists! i, exists t c,
        find i d = Some (Msg (TMsg t c) from to true)) /\
  forall i t c,
    find i d = Some (Msg (TMsg t c) from to true) ->
    criterion t c.

Definition msg_spec from to tg cnt :=
  msg_in_soup from to (fun x y => (x == tg) && (y == cnt)).

Definition no_msg_from (from : nid) (d : soup) : Prop :=
  forall i to tms b, find i d = Some (Msg tms from to b) -> b = false.

Definition no_msg_to (to : nid) (d : soup) : Prop :=
  forall i from tms b, find i d = Some (Msg tms from to b) -> b = false.

Lemma no_msg_from_post (from from' to : nid) (s : soup) tms :
  valid s ->
  no_msg_from from s -> from' != from ->
  no_msg_from from (post_msg s (Msg tms from' to true)).1.

Lemma no_msg_from_consume from from' to s i m :
  find i s = Some {| content := m; from := from'; to := to; active := true |} ->
  valid s ->
  no_msg_from from s ->
  no_msg_from from (consume_msg s i).

Definition no_msg_from_to from to (d : soup) :=
  forall i tms b,
    find i d = Some (Msg tms from to b) -> b = false.

Lemma no_msg_from_to_consume from to s i:
  valid s ->
  no_msg_from_to from to s ->
  no_msg_from_to from to (consume_msg s i).

Lemma msg_spec_consume s from to tg cnt cnt' i :
  valid s -> 
  find i s = Some {| content := TMsg tg cnt';
                     from := from; to := to; active := true |} ->
  msg_spec from to tg cnt s ->
  no_msg_from_to from to (consume_msg s i).

Lemma msg_specE_consume s pt from to to' tg cnt i m :
  valid s ->
  find i s =
  Some {| content := m; from := from; to := to'; active := true |} ->
  (pt != from) || (to != to') ->
  msg_spec pt to tg cnt s ->
  msg_spec pt to tg cnt (consume_msg s i).

Lemma msg_specE_consume1 s pt from to to' tg cnt i m :
  valid s ->
  find i s =
  Some {| content := m; from := from; to := to'; active := true |} ->
  (pt != from) ->
  msg_spec pt to tg cnt s ->
  msg_spec pt to tg cnt (consume_msg s i).

Lemma msg_specE_consume2 s pt from to to' tg cnt i m :
  valid s ->
  find i s =
  Some {| content := m; from := from; to := to'; active := true |} ->
  (to != to') ->
  msg_spec pt to tg cnt s ->
  msg_spec pt to tg cnt (consume_msg s i).

Definition no_msg_from_imp from to d :
  no_msg_from from d -> no_msg_from_to from to d.

Lemma no_msg_from_toE from to s tms to':
  valid s -> 
  no_msg_from_to from to s -> to == to' = false ->
  no_msg_from_to from to (post_msg s (Msg tms from to' true)).1.

Lemma no_msg_from_toE' from to s tms from' to':
  valid s -> 
  no_msg_from_to from to s -> from' == from = false ->
  no_msg_from_to from to (post_msg s (Msg tms from' to' true)).1.

Lemma msg_specE s from to tg cnt :
  valid s ->
  no_msg_from_to from to s ->
  msg_spec from to tg cnt (post_msg s (Msg (TMsg tg cnt) from to true)).1.

Lemma msg_specE' s from to to' tg cnt tms :
  valid s -> to == to' = false ->
  msg_spec from to tg cnt s ->
  msg_spec from to tg cnt (post_msg s (Msg tms from to' true)).1.

Lemma msg_specE'' s from from' to to' tg cnt tms :
  valid s -> from == from' = false ->
  msg_spec from to tg cnt s ->
  msg_spec from to tg cnt (post_msg s (Msg tms from' to' true)).1.

End SoupPredicates.

Lemma has_all_true xs (ps : seq nid) x:
  perm_eq [seq i.1 | i <- xs] ps ->

Lemma has_some_false (xs : seq (nid * bool)) ps x:
  perm_eq [seq i.1 | i <- xs] ps ->

Definition no_msg_from_to' from to
           (criterion : nat -> seq nat -> bool) (d : soup) :=
  forall i t c,
    find i d = Some (Msg (TMsg t c) from to true) ->
    ~~criterion t c.

Lemma no_msg_from_to_consume' from to cond s i:
  valid s ->
  no_msg_from_to' from to cond s ->
  no_msg_from_to' from to cond (consume_msg s i). *)
From DiSeL
Require Import TwoPhaseProtocol TwoPhaseInductiveInv.
(* TwoPhaseProtocol:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always HoareTriples InferenceRules.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Module TPCProtocol.

Module States.

Definition data := seq nid.

Inductive CState :=

| CInit
         
| CSentPrep of data & seq nid

| CWaitPrepResponse of data & seq (nid * bool)

| CSentCommit of data & seq nid
| CSentAbort of data & seq nid
                        
| CWaitAckCommit of data & seq nid
                       
| CWaitAckAbort of data & seq nid.

Inductive PState :=
| PInit
| PGotRequest of data 
| PRespondedYes of data | PRespondedNo of data
| PCommitted of data | PAborted of data.

Definition st := ptr_nat 1.
Definition log := ptr_nat 2.

Definition Log := seq (bool * (seq nat)).

Definition CStateT := (nat * CState)%type.
Definition PStateT := (nat * PState)%type.

End States.

Import States.

Section TPCProtocol.

Variable cn : nid.

Variable pts : seq nid.

Variable others : seq nid.

Hypothesis Hnin : cn \notin pts.
Hypothesis Puniq : uniq pts.

Definition localCoh (n : nid) : Pred heap :=
  [Pred h | valid h /\
   if n == cn
   then exists (s : CStateT) (l : Log),
       h = st :-> s \+ log :-> l
   else if n \in pts
   then exists (s : PStateT) (l : Log),
       h = st :-> s \+ log :-> l
   else log \notin dom h].

Definition nodes := [:: cn] ++ pts ++ others.

Definition prep_req : nat := 0.
Definition prep_yes : nat := 1.
Definition prep_no : nat := 2.
Definition commit_req : nat := 3.
Definition abort_req : nat := 4.
Definition commit_ack : nat := 5.
Definition abort_ack : nat := 6.

Definition eval_req : nat := 7.
Definition eval_resp : nat := 8.

Definition ttag := nat.
Definition payload := seq nat.

Definition tags : seq ttag :=
  [:: prep_req;
     prep_yes;
     prep_no;
     commit_req;
     abort_req;
     commit_ack;
     abort_ack;
     eval_req;
     eval_resp].

Definition tagFromParticipant (t : nat) : bool :=
  (t \in [:: prep_yes; prep_no; commit_ack; abort_ack]).

Definition msgFromParticipant (tms : TaggedMessage) (y : nat) : bool :=
    tagFromParticipant (tag tms)
    && (tms_cont tms == [:: y]).

Definition tagFromCoordinator (t : nat) : bool :=
  (t \in [:: prep_req; commit_req; abort_req]).

Definition msgFromCoordinator (tms : TaggedMessage) (y : nat) : Prop :=
  let: body := tms_cont tms in
  if tag tms == prep_req
  then exists data, body = y :: data
  else if tag tms == commit_req
       then body = [:: y] 
       else if tag tms == abort_req
            then body = [:: y]
            else False.

Definition cohMsg (ms: msg TaggedMessage) (y : nat) : Prop :=
  if from ms == cn
  then to ms \in pts /\ msgFromCoordinator (content ms) y
  else if from ms \in pts
       then to ms == cn /\ msgFromParticipant (content ms) y
       else True.

Definition soupCoh : Pred soup :=
  [Pred s | valid s /\
            forall m ms, find m s = Some ms -> exists y, cohMsg ms y].

Definition tpc_coh d : Prop :=
  let: dl := dstate d in
  let: ds := dsoup d in
  [/\ soupCoh ds, dom dl =i nodes,
   valid dl &
   forall n, n \in nodes -> localCoh n (getLocal n d)].

Lemma l1 d: tpc_coh d -> valid (dstate d).

Lemma l2 d: tpc_coh d -> valid (dsoup d).

Lemma l3 d: tpc_coh d -> dom (dstate d) =i nodes.

Definition TPCCoh := CohPred (CohPredMixin l1 l2 l3).

Section TransitionLemmas.

Lemma send_soupCoh d m : 
    soupCoh (dsoup d) -> (exists y, cohMsg m y) -> soupCoh (post_msg (dsoup d) m).1.

Lemma trans_updDom this d s :
  this \in nodes -> TPCCoh d -> dom (upd this s (dstate d)) =i nodes.

Lemma consume_coh d m : TPCCoh d -> soupCoh (consume_msg (dsoup d) m).

Lemma this_not_pts this : this \in pts -> this == cn = false.

Lemma this_not_pts' this : this == cn -> this \notin pts.

End TransitionLemmas.

Lemma locCn n d (C : TPCCoh d):
  n \in nodes -> 
  valid (getLocal n d) /\
  if n == cn
  then exists (s : CStateT) (l : Log),
      getLocal n d = st :-> s \+ log :-> l
  else if n \in pts
       then exists (s : PStateT) (l : Log),
           getLocal n d = st :-> s \+ log :-> l
       else log \notin dom (getLocal n d).            

Lemma cohStC d (C : TPCCoh d) s:
  find st (getLocal cn d) = Some s ->
  dyn_tp s = CStateT. 

Lemma cohStP n d (C : TPCCoh d) (H : n \in pts) s:
  find st (getLocal n d) = Some s ->
  dyn_tp s = PStateT. 

Definition getStC d (C : TPCCoh d) : CStateT :=
  match find st (getLocal cn d) as f return _ = f -> _ with
    Some v => fun epf => icast (sym_eq (cohStC C epf)) (dyn_val v)
  | _ => fun epf => (0, CInit)
  end (erefl _).

Lemma getStC_K d (C : TPCCoh d) m (l : Log):
  getLocal cn d = st :-> m \+ log :-> l -> getStC C = m.

Program Definition getStP n d (C : TPCCoh d) (pf : n \in nodes) : PStateT.

Lemma getStP_K n d (C : TPCCoh d) (pf : n \in nodes) m (l : Log):
  n \in pts -> getLocal n d = st :-> m \+ log :-> l -> getStP C pf = m.

Lemma cohStL d (C : TPCCoh d) n (H : n \in nodes) l:
  find log (getLocal n d) = Some l -> dyn_tp l = Log.

Definition getStL n d (C : TPCCoh d) (pf : n \in nodes) : Log :=
  match find log (getLocal n d) as f return _ = f -> _ with
    Some v => fun epf => icast (sym_eq (cohStL C pf epf)) (dyn_val v) 
  | _ => fun epf => [::]
  end (erefl _).

Lemma getStL_Kc n d (C : TPCCoh d) (pf : n \in nodes) (m : CStateT) (l : Log):
  getLocal n d = st :-> m \+ log :-> l -> getStL C pf = l.

Lemma getStL_Kp n d (C : TPCCoh d) (pf : n \in nodes) (m : PStateT) (l : Log):
  getLocal n d = st :-> m \+ log :-> l -> getStL C pf = l.

Lemma cn_in : cn \in nodes.

Lemma pts_in n: n \in pts -> n \in nodes.

Lemma cn_pts_in this : this \in cn :: pts -> this \in nodes.

Lemma getStCE l i j pf pf' :
  getLocal cn (getStatelet j l) = getLocal cn (getStatelet i l) ->
  @getStC (getStatelet j l) pf' = @getStC (getStatelet i l) pf.

Lemma getStPE l n i j C C' pf :
  n \in pts -> 
  getLocal n (getStatelet j l) = getLocal n (getStatelet i l) ->
  @getStP n (getStatelet j l) C' pf = @getStP n (getStatelet i l) C pf.

Lemma getStLE l this i j pf pf' :
  forall (N : this \in cn :: pts),
  getLocal this (getStatelet j l) = getLocal this (getStatelet i l) ->
  @getStL _ (getStatelet j l) pf' (cn_pts_in N) =
  @getStL _ (getStatelet i l) pf (cn_pts_in N).

Definition cstep_send (cs: CStateT) (to : nid) (d : data) (l : Log) :
  CStateT * Log :=
  
  if to \in pts then
    let: (e, s) := cs in
    match s with
    | CInit =>
      if pts == [:: to]
      then (e, CWaitPrepResponse d [::], l)
      else (e, CSentPrep d [:: to], l)
    
    | CSentPrep d' tos =>
      
      if perm_eq (to :: tos) pts
      
      then (e, CWaitPrepResponse d' [::], l)
      else (e, CSentPrep d' (to :: tos), l)                  
    | CWaitPrepResponse d' res =>
      
      if (perm_eq (map fst res) pts)
      then if all (fun r => r) (map snd res)
           then if pts == [:: to]
                then (e, CWaitAckCommit d' [::], l)
                else (e, CSentCommit d' [:: to], l)
           else if pts == [:: to]
                then (e, CWaitAckAbort d' [::], l)
                else (e, CSentAbort  d' [:: to], l)
      else (cs, l)
    | CSentCommit d' tos =>
      
      if perm_eq (to :: tos) pts
      then (e, CWaitAckCommit d' [::], l)
      else (e, CSentCommit d' (to :: tos), l)                  
    | CSentAbort d' tos =>
      if perm_eq (to :: tos) pts
      then (e, CWaitAckAbort d' [::], l)
      else (e, CSentAbort d' (to :: tos), l)                  
    | _ => (cs, l) 
    end
  else (cs, l).

Definition c_matches_tag s mtag : bool :=
  match  s with
  | CWaitPrepResponse _ _ => (mtag == prep_yes) || (mtag == prep_no)
  | CWaitAckCommit _ _ => mtag == commit_ack
  | CWaitAckAbort _ _ => mtag == abort_ack
  | _ => false
  end.

Definition cstep_recv' (cs : CStateT) (from : nid) (mtag : ttag)
           (mbody : payload) (l : Log) : CStateT * Log  :=
  let: (e, s) := cs in
  match s with
  | CWaitPrepResponse d' res =>
        if (from \in (map fst res))
    then (cs, l)
    
    else (e, CWaitPrepResponse d' ((from, mtag == prep_yes) :: res), l)
  | CWaitAckCommit d' res =>
    if from \in res then (cs, l)
    else if (perm_eq (from :: res) pts)
         then ((e.+1, CInit), rcons l (true, d'))
         else (e, CWaitAckCommit d' (from :: res), l)
  | CWaitAckAbort d' res =>
    if from \in res then (cs, l)
    else if (perm_eq (from :: res) pts)
         then ((e.+1, CInit), rcons l (false, d'))
         else (e, CWaitAckAbort d' (from :: res), l)
  | _ => (cs, l)
  end.

Definition cstep_recv (cs: CStateT) (from : nid) (mtag : ttag)
           (mbody : payload) (l : Log) : CStateT * Log  :=
  if (from \notin pts) then (cs, l)
  else let: (e, s) := cs in
    
    if (head 0 mbody != e) then (cs, l) else
      cstep_recv' cs from mtag mbody l
.
    
Section CoordinatorGenericSendTransitions.

Notation coh := TPCCoh.

Definition HCn this to := (this == cn /\ to \in pts).
Definition mkLocal {T} (sl : T * Log) := st :-> sl.1 \+ log :-> sl.2.

Variable stag : ttag.

Variable prec : CStateT -> nid -> payload -> Prop.

Hypothesis cn_prec_safe :
  forall this to s m,
    HCn this to -> prec s to m -> cohMsg (Msg (TMsg stag m) this to true) s.1.

Definition cn_safe (this n : nid)
           (d : dstatelet) (msg : data) :=
  HCn this n /\
  exists (C : coh d), prec (getStC C) n msg.

Lemma cn_safe_coh this to d m : cn_safe this to d m -> coh d.

Lemma cn_this_in this to : HCn this to -> this \in nodes.

Lemma cn_to_in this to : HCn this to -> to \in nodes.

Lemma cn_safe_in this to d m : cn_safe this to d m ->
                                  this \in nodes /\ to \in nodes.

Definition cn_step (this to : nid) (d : dstatelet)
           (msg : seq nat)
           (pf : cn_safe this to d msg) :=
  let C := cn_safe_coh pf in 
  let s := getStC C in
  let l := getStL C (cn_this_in (proj1 pf)) in
  Some (mkLocal (cstep_send s to (behead msg) l)). 

Lemma cn_step_coh : s_step_coh_t coh stag cn_step.

Lemma cn_safe_def this to d msg :
      cn_safe this to d msg <->
      exists b pf, @cn_step this to d msg pf = Some b.

Definition cn_send_trans :=
  SendTrans cn_safe_coh cn_safe_in cn_safe_def cn_step_coh.

End CoordinatorGenericSendTransitions.

Section CoordinatorSendTransitions.

Definition send_prep_prec (p : CStateT) to (m : payload) :=
  (exists n, p = (n, CInit) /\ exists d, m = n :: d) \/
  exists n d ps, [/\ p = (n, CSentPrep d ps), m = n :: d & to \notin ps].

Program Definition cn_send_prep_trans : send_trans TPCCoh :=
  @cn_send_trans prep_req send_prep_prec _.

Definition send_commit_prec (p :  CStateT) to (m : payload) :=
  (exists n d res,
    [/\ p = (n, CWaitPrepResponse d res), m = [::n],
     perm_eq (map fst res) pts & all (fun r => r) (map snd res)])
  \/ exists n d ps, [/\ p = (n, CSentCommit d ps), m = [::n] & to \notin ps].

Program Definition cn_send_commit_trans : send_trans TPCCoh :=
  @cn_send_trans commit_req send_commit_prec _.

Definition send_abort_prec (p : CStateT) to (m : payload) :=
  (exists n d res,
    [/\ p = (n, CWaitPrepResponse d res), m = [::n],
        perm_eq (map fst res) pts & has (fun r => negb r) (map snd res)]) \/
    exists n d ps, [/\ p = (n, CSentAbort d ps), m = [::n] & to \notin ps].
  
Program Definition cn_send_abort_trans : send_trans TPCCoh :=
  @cn_send_trans abort_req send_abort_prec _.

End CoordinatorSendTransitions.

Section CoordinatorGenericReceiveTransitions.

Notation coh := TPCCoh.

Variable rc_tag : ttag.
Variable rc_wf : forall d, coh d -> nid -> nid -> TaggedMessage -> bool.

Definition rc_step : receive_step_t coh :=
  fun this (from : nid) (m : seq nat) d (pf : coh d) (pt : this \in nodes) =>
    if (this == cn)
    then let s := getStC pf in
         let l := @getStL this d pf pt in
         mkLocal (cstep_recv s from rc_tag m l)
    else getLocal this d.

Lemma rc_step_coh : r_step_coh_t rc_wf rc_tag rc_step.

Definition rc_recv_trans := ReceiveTrans rc_step_coh.

End CoordinatorGenericReceiveTransitions.

Section CoordinatorReceiveTransitions.

Definition cn_msg_wf d (C : TPCCoh d) (this from : nid) :=
  [pred m : TaggedMessage | c_matches_tag (getStC C).2 (tag m)].

Definition cn_receive_prep_yes_trans := rc_recv_trans prep_yes cn_msg_wf.
Definition cn_receive_prep_no_trans := rc_recv_trans prep_no cn_msg_wf.

Definition cn_receive_commit_ack_trans := rc_recv_trans commit_ack cn_msg_wf.
Definition cn_receive_abort_ack_trans := rc_recv_trans abort_ack cn_msg_wf.

End CoordinatorReceiveTransitions.

Definition pstep_send (cs: PStateT) (l : Log) (commit : bool) : PStateT * Log :=
  let: (e, s) := cs in
  match s with
  | PGotRequest d =>
    if commit then (e, PRespondedYes d, l) else (e, PRespondedNo d, l)
  | PCommitted d => (e.+1, PInit, l)
  | PAborted d => (e.+1, PInit, l)
  | _ => (cs, l)
  end.

Definition p_matches_tag s mtag : bool :=
  match s with
  | PInit => mtag == prep_req
    | PRespondedYes _ => (mtag == commit_req) || (mtag == abort_req)
  | PRespondedNo _ => mtag == abort_req
  | _ => false
  end.

Definition pstep_recv (ps: PStateT) (from : nid) (mtag : ttag)
           (mbody : payload) (l : Log) : PStateT * Log :=
  if (negb (p_matches_tag ps.2 mtag)) || (from != cn) || (head 0 mbody != ps.1)
  then (ps, l)
  else let: (e, s) := ps in
       match s with
       | PInit => (e, PGotRequest (behead mbody), l)
       | PRespondedYes d =>
         if mtag == commit_req
         then (e, PCommitted d, rcons l (true, d))
         else
           
           (e, PAborted d, rcons l (false, d))
       | PRespondedNo d => (e, PAborted d, rcons l (false, d))
       | _ => (ps, l)
       end.

Section ParticipantGenericSendTransitions.

Notation coh := TPCCoh.

Definition HPn this to := (this \in pts /\ to == cn).

Variable ptag : ttag.

Variable prec : PStateT -> payload -> Prop.

Hypothesis pn_prec_safe :
  forall this to s m,
    HPn this to -> prec s m -> cohMsg (Msg (TMsg ptag m) this to true) s.1.

Lemma pn_this_in this to : HPn this to -> this \in nodes.

Definition pn_safe (this n : nid)
           (d : dstatelet) (msg : data) :=
  HPn this n /\ 
  exists (Hp : HPn this n) (C : coh d), prec (getStP C (pn_this_in Hp)) msg. 

Lemma pn_safe_coh this to d m : pn_safe this to d m -> coh d.

Lemma pn_to_in this to : HCn this to -> to \in nodes.

Lemma pn_safe_in this to d m : pn_safe this to d m ->
                               this \in nodes /\ to \in nodes.

Variable commit : bool.

Definition pn_step (this to : nid) (d : dstatelet)
           (msg : seq nat)
           (pf : pn_safe this to d msg) :=
  let C := pn_safe_coh pf in 
  let s := getStP C (pn_this_in (proj1 pf)) in
  let l := getStL C (pn_this_in (proj1 pf)) in
  Some (mkLocal (pstep_send s l commit)). 

Lemma pn_step_coh : s_step_coh_t coh ptag pn_step.

Lemma pn_safe_def this to d msg :
      pn_safe this to d msg <->
      exists b pf, @pn_step this to d msg pf = Some b.

Definition pn_send_trans :=
  SendTrans pn_safe_coh pn_safe_in pn_safe_def pn_step_coh.

End ParticipantGenericSendTransitions.

Section ParticipantSendTransitions.

Definition send_prep_resp_prec (ps : data -> PState)
           (p : PStateT) (m : payload) :=
  exists n d, p = (n, ps d) /\  m = [:: n].

Program Definition pn_gen_send_trans (t : ttag)
        (T: t \in [:: prep_yes; prep_no; commit_ack; abort_ack])
        (ps : data -> PState) c :=
  @pn_send_trans t (send_prep_resp_prec ps) _ c.

Program Definition pn_send_yes_trans :=
  @pn_gen_send_trans prep_yes _ PGotRequest true.

Program Definition pn_send_no_trans :=
  @pn_gen_send_trans prep_no _ PGotRequest false.

Program Definition pn_commit_ack_trans :=
  @pn_gen_send_trans commit_ack _ PCommitted true.

Program Definition pn_abort_ack_trans :=
  @pn_gen_send_trans abort_ack _ PAborted false.

End ParticipantSendTransitions.

Section ParticipantGenericReceiveTransitions.

Notation coh := TPCCoh.

Variable rp_tag : ttag.
Variable rp_wf : forall d, coh d -> nid -> nid -> pred payload.

Definition rp_step : receive_step_t coh :=
  fun this (from : nid) (m : seq nat) d (pf : coh d) (pt : this \in nodes) =>
    if (this \in pts)
    then let s := getStP pf pt in
         let l := @getStL this d pf pt in
         mkLocal (pstep_recv s from rp_tag m l)
    else getLocal this d.

Lemma rp_step_coh : r_step_coh_t rp_wf rp_tag rp_step.

Definition rp_recv_trans := ReceiveTrans rp_step_coh.

End ParticipantGenericReceiveTransitions.

Section ParticipantReceiveTransitions.

Definition pn_msg_wf d (_ : TPCCoh d) (this from : nid) :=
  [pred p : payload | true].

Definition pn_receive_got_prep_trans := rp_recv_trans prep_req pn_msg_wf.

Definition pn_receive_commit_ack_trans := rp_recv_trans commit_req pn_msg_wf.

Definition pn_receive_abort_ack_trans := rp_recv_trans abort_req pn_msg_wf.

End ParticipantReceiveTransitions.

Section Protocol.

Variable l : Label.

Definition tpc_sends :=
  [::
     cn_send_prep_trans;
     cn_send_commit_trans;
     cn_send_abort_trans;

     pn_send_yes_trans;
     pn_send_no_trans;
     pn_commit_ack_trans;
     pn_abort_ack_trans
  ].

Definition tpc_receives :=
  [::
     cn_receive_prep_yes_trans;
     cn_receive_prep_no_trans;
     cn_receive_commit_ack_trans;
     cn_receive_abort_ack_trans;

     pn_receive_got_prep_trans;
     pn_receive_commit_ack_trans;
     pn_receive_abort_ack_trans
  ].

Program Definition TwoPhaseCommitProtocol : protocol :=
  @Protocol _ l _ tpc_sends tpc_receives _ _.

End Protocol.
End TPCProtocol.

Module Exports.
Section Exports.
      
Definition TwoPhaseCommitProtocol := TwoPhaseCommitProtocol.

Definition cn_send_prep_trans := cn_send_prep_trans.
Definition cn_send_commit_trans := cn_send_commit_trans.
Definition cn_send_abort_trans := cn_send_abort_trans.

Definition pn_send_yes_trans := pn_send_yes_trans.
Definition pn_send_no_trans := pn_send_no_trans.
Definition pn_commit_ack_trans := pn_commit_ack_trans.
Definition pn_abort_ack_trans := pn_abort_ack_trans.

Definition cn_receive_prep_yes_trans := cn_receive_prep_yes_trans.
Definition cn_receive_prep_no_trans := cn_receive_prep_no_trans.
Definition cn_receive_commit_ack_trans := cn_receive_commit_ack_trans.
Definition cn_receive_abort_ack_trans := cn_receive_abort_ack_trans.

Definition pn_receive_got_prep_trans := pn_receive_got_prep_trans.
Definition pn_receive_commit_ack_trans := pn_receive_commit_ack_trans.
Definition pn_receive_abort_ack_trans := pn_receive_abort_ack_trans.

Definition prep_req := prep_req.
Definition prep_yes := prep_yes.
Definition prep_no := prep_no.
Definition commit_req := commit_req.
Definition abort_req := abort_req.
Definition commit_ack := commit_ack.
Definition abort_ack := abort_ack.

Definition getStC := getStC.
Definition getStP := getStP.
Definition getStL := getStL.

Definition getStCE := getStCE.
Definition getStPE := getStPE.
Definition getStCL := getStLE.

End Exports.
End Exports.

End TPCProtocol.

Export TPCProtocol.States.
Export TPCProtocol.Exports. *)
(* TwoPhaseInductiveInv:
From mathcomp.ssreflect
Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.
From mathcomp
Require Import path.
Require Import Eqdep.
Require Import Relation_Operators.
From fcsl
Require Import axioms pred prelude ordtype finmap pcm unionmap heap.
From DiSeL
Require Import Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.
From DiSeL
Require Import Actions Injection Process Always HoareTriples InferenceRules.
From DiSeL
Require Import InductiveInv While StatePredicates.
From DiSeL
Require Import TwoPhaseProtocol.

Require Import Omega.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Section TwoPhaseInductiveInv.

Variable l : Label.
Variables (cn : nid) (pts : seq nid) (others : seq nid).
Hypothesis Hnin : cn \notin pts.
Hypothesis PtsNonEmpty : pts != [::].

Lemma pt_not_cn pt : pt \in pts -> pt != cn.

Definition tpc := TwoPhaseCommitProtocol others Hnin l.

Notation sts := (snd_trans tpc).
Notation rts := (rcv_trans tpc).

Notation loc z d := (getLocal z d).

Definition cn_state (d : dstatelet) (c : CStateT) (l : Log) : Prop :=
  loc cn d = st :-> c \+ log :-> l.

Definition pt_state (d : dstatelet) (p : PStateT) (l : Log) (pt : nid) : Prop :=
  loc pt d = st :-> p \+ log :-> l.

Definition EverythingInit (d : dstatelet) (round : nat) (l : Log) : Prop :=
  [/\ cn_state d (round, CInit) l &
      forall pt, pt \in pts ->
            [/\ pt_state d (round, PInit) l pt,
               no_msg_from_to pt cn (dsoup d) &
               no_msg_from_to cn pt (dsoup d)]].

Definition pt_PhaseOne (d : dstatelet) (round : nat)
           (next_data : data) (l : Log) (pt : nid) : Prop :=
  [\/ [/\ pt_state d (round, PInit) l pt,
       no_msg_from_to pt cn (dsoup d) &
       msg_spec cn pt prep_req (round :: next_data) (dsoup d)]
   ,  [/\ pt_state d (round, PGotRequest next_data) l pt,
       no_msg_from_to pt cn (dsoup d) &
       no_msg_from_to cn pt (dsoup d)]
   ,  [/\ pt_state d (round, PRespondedYes next_data) l pt,
       no_msg_from_to cn pt (dsoup d) &
       msg_spec pt cn prep_yes [::round] (dsoup d)]
   |  [/\ pt_state d (round, PRespondedNo next_data) l pt,
       no_msg_from_to cn pt (dsoup d) &
       msg_spec pt cn prep_no [::round] (dsoup d)]].

Definition pt_PhaseOneResponded (d : dstatelet) (round : nat) (next_data : data)
           (l : Log) (committed : bool) (pt : nid) : Prop :=
  [/\ no_msg_from_to cn pt (dsoup d), no_msg_from_to pt cn (dsoup d) &
      if committed
      then pt_state d (round, PRespondedYes next_data) l pt
      else pt_state d (round, PRespondedNo next_data) l pt].

Definition pt_Init d round l pt :=
  [/\ pt_state d (round, PInit) l pt,
     no_msg_from_to pt cn (dsoup d) &
     no_msg_from_to cn pt (dsoup d)].

Definition cn_PhaseOneSend d round next_data l sent :=
    [/\ cn_state d (round, CSentPrep next_data sent) l,
     uniq sent, {subset sent <= pts} &
                forall pt, pt \in pts ->
                           if pt \in sent
                           then pt_PhaseOne d round next_data l pt
                           else pt_Init d round l pt].

Definition cn_PhaseOneReceive d round next_data l recvd :=
     let rps := map fst recvd in
     [/\ cn_state d (round, CWaitPrepResponse next_data recvd) l,
      uniq rps, {subset rps <= pts} ,
      forall pt b, pt \in pts -> (pt, b) \in recvd ->
                   pt_PhaseOneResponded d round next_data l b pt &
      forall pt,   pt \in pts -> pt \notin rps ->
                   pt_PhaseOne d round next_data l pt].

Definition PhaseOne (d : dstatelet) (round : nat) (next_data : data) (l : Log) :=
  (exists sent, cn_PhaseOneSend d round next_data l sent) \/
  (exists recvd, cn_PhaseOneReceive d round next_data l recvd).

Definition pt_PhaseTwoCommit d round next_data l pt :=
  [\/ [/\ pt_state d (round, PRespondedYes next_data) l pt,
       msg_spec cn pt commit_req [::round] (dsoup d) &
       no_msg_from_to pt cn (dsoup d)]
   , [/\ pt_state d (round, PCommitted next_data) (rcons l (true, next_data)) pt,
      no_msg_from_to cn pt (dsoup d) & no_msg_from_to pt cn (dsoup d)]
  | [/\ pt_state d (round.+1, PInit) (rcons l (true, next_data)) pt,
     no_msg_from_to cn pt (dsoup d) &
     msg_spec pt cn commit_ack [::round] (dsoup d)
  ]].

Definition pt_PhaseTwoAbort d round next_data l pt :=
  [\/ [/\ (pt_state d (round, PRespondedYes next_data) l pt \/
           pt_state d (round, PRespondedNo next_data) l pt),
       msg_spec cn pt abort_req [::round] (dsoup d) &
       no_msg_from_to pt cn (dsoup d)]
   , [/\ pt_state d (round, PAborted next_data) (rcons l (false, next_data)) pt,
      no_msg_from_to cn pt (dsoup d) & no_msg_from_to pt cn (dsoup d)]
  | [/\ pt_state d (round.+1, PInit) (rcons l (false, next_data)) pt,
     no_msg_from_to cn pt (dsoup d) &
     msg_spec pt cn abort_ack [::round] (dsoup d)
  ]].

Definition pt_PhaseTwoResponded d round next_data l b pt :=
  [/\ pt_state d (round.+1, PInit) (rcons l (b, next_data)) pt,
   no_msg_from_to cn pt (dsoup d) & no_msg_from_to pt cn (dsoup d)].

Definition cn_PhaseTwoSendCommits d round next_data l sent :=
     [/\ cn_state d (round, CSentCommit next_data sent) l,
      uniq sent, {subset sent <= pts} &
       forall pt, pt \in pts ->
       if pt \in sent
       then pt_PhaseTwoCommit d round next_data l pt
       else pt_PhaseOneResponded d round next_data l true pt].

Definition cn_PhaseTwoSendAborts d round next_data l sent :=
     [/\ cn_state d (round, CSentAbort next_data sent) l,
      uniq sent, {subset sent <= pts} &
      forall pt, pt \in pts ->
      if pt \in sent
      then pt_PhaseTwoAbort d round next_data l pt
      else exists b, pt_PhaseOneResponded d round next_data l b pt].

Definition cn_PhaseTwoReceiveCommits d round next_data l recvd :=
      [/\ cn_state d (round, CWaitAckCommit next_data recvd) l,
       uniq recvd, {subset recvd <= pts} &
       forall pt, pt \in pts ->
       if pt \in recvd
       then pt_PhaseTwoResponded d round next_data l true pt
       else pt_PhaseTwoCommit d round next_data l pt].

Definition cn_PhaseTwoReceiveAborts d round next_data l recvd :=
     [/\ cn_state d (round, CWaitAckAbort next_data recvd) l,
      uniq recvd, {subset recvd <= pts} &
      forall pt, pt \in pts ->
      if pt \in recvd
      then pt_PhaseTwoResponded d round next_data l false pt
      else pt_PhaseTwoAbort d round next_data l pt].

Definition PhaseTwoCommit d round next_data lg :=
  [\/ exists sent : seq nid, cn_PhaseTwoSendCommits d round next_data lg sent |
     exists recvd : seq nid, cn_PhaseTwoReceiveCommits d round next_data lg recvd ].

Definition PhaseTwoAbort d round next_data lg :=
  [\/ exists sent : seq nid, cn_PhaseTwoSendAborts d round next_data lg sent |
     exists recvd : seq nid, cn_PhaseTwoReceiveAborts d round next_data lg recvd ].

Definition PhaseTwo (d : dstatelet) (round : nat) (next_data : data) (l : Log) :=
  [\/ exists sent, cn_PhaseTwoSendCommits d round next_data l sent,
     exists sent, cn_PhaseTwoSendAborts d round next_data l sent,
     exists recvd, cn_PhaseTwoReceiveCommits d round next_data l recvd |
   exists recvd, cn_PhaseTwoReceiveAborts d round next_data l recvd].

Definition Inv (d : dstatelet) :=
  exists round l,
  [\/ EverythingInit d round l
   , exists next_data, PhaseOne d round next_data l
  | exists next_data, PhaseTwo d round next_data l].

Notation coh d := (coh tpc d).
Notation PI := pf_irr.
Export TPCProtocol.

Lemma inv_init d e (C : coh d):
  Inv d -> getStC C = (e, CInit) -> exists lg, EverythingInit d e lg.

Lemma inv_prep_send d e dt ps (C : coh d):
  Inv d -> getStC C = (e, CSentPrep dt ps) ->
  exists lg sent, cn_PhaseOneSend d e dt lg sent.

Lemma inv_waitprep d r (C : coh d) next_data recvd:
  Inv d -> getStC C = (r, CWaitPrepResponse next_data recvd) ->
  exists lg, cn_PhaseOneReceive d r next_data lg recvd.

Lemma inv_sentcommit d r (C : coh d) next_data sent:
  Inv d -> getStC C = (r, CSentCommit next_data sent) ->
  exists lg, cn_PhaseTwoSendCommits d r next_data lg sent.

Lemma inv_sentabort d r (C : coh d) next_data sent:
  Inv d -> getStC C = (r, CSentAbort next_data sent) ->
  exists lg, cn_PhaseTwoSendAborts d r next_data lg sent.

Lemma inv_waitcommit d r (C : coh d) next_data sent:
  Inv d -> getStC C = (r, CWaitAckCommit next_data sent) ->
  exists lg, cn_PhaseTwoReceiveCommits d r next_data lg sent.

Lemma inv_waitabort d r (C : coh d) next_data sent:
  Inv d -> getStC C = (r, CWaitAckAbort next_data sent) ->
  exists lg, cn_PhaseTwoReceiveAborts d r next_data lg sent.

Lemma prep_no_pt_inv d i m pt round next_data lg :
  tag m = prep_no ->
  find i (dsoup d) =
  Some {| content := m; from := pt; to := cn; active := true |} ->
  pt_PhaseOne d round next_data lg pt ->
  [/\ pt_state d (round, PRespondedNo next_data) lg pt,
       no_msg_from_to cn pt (dsoup d) &
       msg_spec pt cn prep_no [::round] (dsoup d)].

Lemma prep_yes_pt_inv d i m pt round next_data lg :
  tag m = prep_yes ->
  find i (dsoup d) =
  Some {| content := m; from := pt; to := cn; active := true |} ->
  pt_PhaseOne d round next_data lg pt ->
  [/\ pt_state d (round, PRespondedYes next_data) lg pt,
       no_msg_from_to cn pt (dsoup d) &
       msg_spec pt cn prep_yes [::round] (dsoup d)].

Lemma commit_ack_pt_inv d i m pt round next_data lg :
  tag m = commit_ack ->
  find i (dsoup d) =
    Some {| content := m; from := pt; to := cn; active := true |} ->
  pt_PhaseTwoCommit d round next_data lg pt ->
  [/\ pt_state d (round.+1, PInit) (rcons lg (true, next_data)) pt,

Lemma abort_ack_pt_inv d i m pt round next_data lg :
  tag m = abort_ack ->
  find i (dsoup d) =
    Some {| content := m; from := pt; to := cn; active := true |} ->
  pt_PhaseTwoAbort d round next_data lg pt ->
  [/\ pt_state d (round.+1, PInit) (rcons lg (false, next_data)) pt,

Lemma prep_req_cn_inv d i m pt :
  tag m = prep_req ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := m; from := cn; to := pt; active := true |} ->
  Inv d ->
  exists round lg next_data, PhaseOne d round next_data lg.

Lemma prep_req_pt_inv d i m pt round next_data lg :
  find i (dsoup d) =
  Some {| content := m; from := cn; to := pt; active := true |} ->
  pt_PhaseOne d round next_data lg pt ->
  [/\ pt_state d (round, PInit) lg pt, no_msg_from_to pt cn (dsoup d)
      & msg_spec cn pt Exports.prep_req (round :: next_data) (dsoup d)].

Lemma commit_req_pt_inv d i m pt round next_data lg :
  find i (dsoup d) =
  Some {| content := m; from := cn; to := pt; active := true |} ->
  pt_PhaseTwoCommit d round next_data lg pt ->
  [/\ pt_state d (round, PRespondedYes next_data) lg pt,
        msg_spec cn pt Exports.commit_req [:: round] (dsoup d)

Lemma abort_req_pt_inv d i m pt round next_data lg :
  find i (dsoup d) =
  Some {| content := m; from := cn; to := pt; active := true |} ->
  pt_PhaseTwoAbort d round next_data lg pt ->
[/\ pt_state d (round, PRespondedYes next_data) lg pt \/
        pt_state d (round, PRespondedNo next_data) lg pt,
        msg_spec cn pt Exports.abort_req [:: round] (dsoup d)

Lemma in_map_exists (x : nid) xs :
  (exists b : bool, (x, b) \in xs) \/ x \notin map fst xs.

Lemma commit_req_cn_inv d i m pt :
  tag m = commit_req ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := m; from := cn; to := pt; active := true |} ->
  Inv d ->
  exists round lg next_data,
    PhaseTwoCommit d round next_data lg.

Lemma abort_req_cn_inv d i m pt :
  tag m = abort_req ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := m; from := cn; to := pt; active := true |} ->
  Inv d ->
  exists round lg next_data,
    PhaseTwoAbort d round next_data lg.

Lemma PhaseTwoCommit_req_round d i m pt round lg next_data :
  tag m = commit_req ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := m; from := cn; to := pt; active := true |} ->
  PhaseTwoCommit d round next_data lg ->
  exists ps, pt_state d (round, ps) lg pt.

Lemma PhaseTwoAbort_req_round d i m pt round lg next_data :
  tag m = abort_req ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := m; from := cn; to := pt; active := true |} ->
  PhaseTwoAbort d round next_data lg ->
  exists ps, pt_state d (round, ps) lg pt.

Lemma PhaseTwoAbort_round_cn d round lg next_data :
  PhaseTwoAbort d round next_data lg ->
  exists cs, cn_state d (round, cs) lg.

Lemma PhaseTwoCommit_round_cn d round lg next_data :
  PhaseTwoCommit d round next_data lg ->
  exists cs, cn_state d (round, cs) lg.

Lemma PhaseOne_round_cn d round lg next_data :
  PhaseOne d round next_data lg ->
  exists cs, cn_state d (round, cs) lg.

Lemma PhaseOne_round_pt d pt round lg next_data :
  pt \in pts ->
  PhaseOne d round next_data lg ->
  exists ps, pt_state d (round, ps) lg pt.

Lemma c_matches_tag_prep_yes_inv cs :
  c_matches_tag cs prep_yes ->
  exists next_data recvd,
    cs = CWaitPrepResponse next_data recvd.

Lemma c_matches_tag_prep_no_inv cs :
  c_matches_tag cs prep_no ->
  exists next_data recvd,
    cs = CWaitPrepResponse next_data recvd.

Lemma c_matches_tag_commit_ack_inv cs :
  c_matches_tag cs commit_ack ->
  exists next_data recvd,
    cs = CWaitAckCommit next_data recvd.

Lemma c_matches_tag_abort_ack_inv cs :
  c_matches_tag cs abort_ack ->
  exists next_data recvd,
    cs = CWaitAckAbort next_data recvd.

Lemma pt_state_functional d pt ps1 lg1 ps2 lg2 :
  valid (loc pt d) ->
  pt_state d ps1 lg1 pt ->
  pt_state d ps2 lg2 pt ->
  ps1 = ps2 /\ lg1 = lg2.

Lemma PhaseOne_PGotRequest_next_data_pt d pt round lg next_data r nd :
  coh d ->
  pt \in pts ->
  pt_state d (r, PGotRequest nd) lg pt ->
  PhaseOne d round next_data lg ->
  [/\ pt_state d (round, PGotRequest next_data) lg pt, no_msg_from_to pt cn (dsoup d)
      & no_msg_from_to cn pt (dsoup d)].

Lemma inv_gotrequest d r nd (C : coh d) this (Hthis : this \in nodes cn pts others) :
  this \in pts ->
  getStP Hnin C Hthis = (r, PGotRequest nd) ->
  Inv d ->
  exists lg, PhaseOne d r nd lg.

Lemma inv_committed d r nd (C : coh d) this (Hthis : this \in nodes cn pts others) :
  this \in pts ->
  getStP Hnin C Hthis = (r, PCommitted nd) ->
  Inv d ->
  exists lg, PhaseTwo d r nd lg.

Lemma inv_aborted d r nd (C : coh d) this (Hthis : this \in nodes cn pts others) :
  this \in pts ->
  getStP Hnin C Hthis = (r, PAborted nd) ->
  Inv d ->
  exists lg, PhaseTwo d r nd lg.

Lemma pt_PhaseOneE d e dt lg pt to ds tms:
  let d' :=   {|
    dstate := upd cn ds (dstate d);
    dsoup := (post_msg (dsoup d) (Msg tms cn to true)).1

Lemma pt_PhaseOneRespondedE d e dt lg b pt to ds tms:
  let d' :=   {|
    dstate := upd cn ds (dstate d);
    dsoup := (post_msg (dsoup d) (Msg tms cn to true)).1

Lemma pt_PhaseTwoCommitE d e dt lg pt to ds tms:
  let d' :=   {|
    dstate := upd cn ds (dstate d);
    dsoup := (post_msg (dsoup d) (Msg tms cn to true)).1

Lemma pt_PhaseTwoAbortE d e dt lg pt to ds tms:
  let d' :=   {|
    dstate := upd cn ds (dstate d);
    dsoup := (post_msg (dsoup d) (Msg tms cn to true)).1

Lemma cn_state_consume d ds cs lg i n :
  let: d' := {|
       dstate := upd n ds (dstate d);
       dsoup := consume_msg (dsoup d) i
  |} in
  cn != n ->
  coh d ->
  cn_state d cs lg ->
  cn_state d' cs lg.

Lemma pt_state_consume d ds ps lg pt i n :
  let: d' := {|
       dstate := upd n ds (dstate d);
       dsoup := consume_msg (dsoup d) i
  |} in
  pt != n ->
  coh d ->
  pt_state d ps lg pt ->
  pt_state d' ps lg pt .

Lemma pt_InitE_consume d e lg pt ds i from to m:
  let: d' :=   {|
    dstate := upd to ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d -> pt \in pts ->
  pt != from ->
  pt != to ->
  find i (dsoup d) =
  Some {| content := m; from := from; to := to; active := true |} ->
  pt_Init d e lg pt ->
  pt_Init d' e lg pt.

Lemma pt_PhaseOneE_consume d e dt lg pt ds i from to m:
  let d' :=   {|
    dstate := upd to ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d -> pt \in pts ->
  pt != from ->
  pt != to ->
  find i (dsoup d) =
  Some {| content := m; from := from; to := to; active := true |} ->
  pt_PhaseOne d e dt lg pt ->
  pt_PhaseOne d' e dt lg pt.

Lemma pt_PhaseOneRespondedE_consume d e dt lg b pt ds i from:
  let: d' :=   {|
    dstate := upd from ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d -> pt \in pts ->
  pt != from ->
  pt_PhaseOneResponded d e dt lg b pt ->
  pt_PhaseOneResponded d' e dt lg b pt.

Lemma cn_PhaseOneReceive_consume d round next_data lg recvd i m from :
  cn_PhaseOneReceive d round next_data lg recvd ->
  find i (dsoup d) = Some {| content := m; from := from; to := cn; active := true |} ->
  from \in pts ->
  from \in map fst recvd ->
  coh d ->
  let: d' :=
     {|
       dstate := upd cn (mkLocal (round, CWaitPrepResponse next_data recvd, lg)) (dstate d);
       dsoup := consume_msg (dsoup d) i |}
  in
  cn_PhaseOneReceive d' round next_data lg recvd.

Lemma pt_PhaseTwoRespondedE_consume d e dt lg b pt ds i this:
  let: d' :=   {|
    dstate := upd this ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d -> pt \in pts -> pt != this ->
  pt_PhaseTwoResponded d e dt lg b pt ->
  pt_PhaseTwoResponded d' e dt lg b pt.

Lemma pt_PhaseTwoCommitE_consume d e dt lg pt ds from to i m:
  let: d' :=   {|
    dstate := upd to ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d ->
  pt != from ->
  pt != to ->
  find i (dsoup d) =
  Some {| content := m; from := from; to := to; active := true |} ->
  pt_PhaseTwoCommit d e dt lg pt ->
  pt_PhaseTwoCommit d' e dt lg pt.

Lemma pt_PhaseTwoAbortE_consume d e dt lg pt ds from to i m:
  let: d' :=   {|
    dstate := upd to ds (dstate d);
    dsoup := consume_msg (dsoup d) i
  |} in
  coh d ->
  pt != from ->
  pt != to ->
  find i (dsoup d) =
  Some {| content := m; from := from; to := to; active := true |} ->
  pt_PhaseTwoAbort d e dt lg pt ->
  pt_PhaseTwoAbort d' e dt lg pt.

Lemma cn_state_soupE d ds this h cs lg :
  let: d' := {| dstate := upd this h (dstate d);
                dsoup := ds |} in
  coh d ->
  this != cn ->
  cn_state d cs lg ->
  cn_state d' cs lg.

Lemma pt_state_soupE d ds h ps lg pt n :
  let: d' := {|
       dstate := upd n h (dstate d);
       dsoup := ds
  |} in
  coh d ->
  pt != n ->
  pt_state d ps lg pt ->
  pt_state d' ps lg pt .

Lemma pt_PhaseOneE' d r nd lg pt from h to m :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma pt_InitE d r lg pt from h to m :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma pt_PhaseOneRespondedE' d r nd lg pt from h to m b :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma PhaseTwo_PCommitted_pt d pt round lg next_data r nd (C : coh d)
      (Hpt : pt \in nodes _ _ _) :
  pt \in pts ->
  getStP Hnin C Hpt = (r, PCommitted nd) ->
  PhaseTwo d round next_data lg ->
  [/\ pt_state d (round, PCommitted next_data) (rcons lg (true, next_data)) pt,
        no_msg_from_to cn pt (dsoup d)
      & no_msg_from_to pt cn (dsoup d)].

Lemma pt_PhaseTwoCommitE' d r nd lg pt from h to m :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma pt_PhaseTwoAbortE' d r nd lg pt from h to m :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma pt_PhaseTwoRespondedE' d r nd lg pt from h to m b :
  let: d' := {| dstate := upd from h (dstate d);
                dsoup := (post_msg (dsoup d)
                  {| content := m; from := from; to := to; active := true |}).1 |} in

Lemma PhaseTwo_PAborted_pt d pt round lg next_data r nd (C : coh d)
      (Hpt : pt \in nodes _ _ _) :
  pt \in pts ->
  getStP Hnin C Hpt = (r, PAborted nd) ->
  PhaseTwo d round next_data lg ->
  [/\ pt_state d (round, PAborted next_data) (rcons lg (false, next_data)) pt,
        no_msg_from_to cn pt (dsoup d)
      & no_msg_from_to pt cn (dsoup d)].

Definition coord_msg tag (from to : nid) : bool :=
  [&& from == cn, to \in pts & tagFromCoordinator tag].

Definition participant_msg tag (from to : nid) : bool :=
  [&& from \in pts, to == cn & tagFromParticipant tag].

Definition internal_msg (tag : nat) (from to : nid) : bool :=
  coord_msg tag from to || participant_msg tag from to.

Lemma internal_msg_tagFromParticipant_to_cn tag from to :
  internal_msg tag from to ->
  tagFromParticipant tag ->
  to == cn.

Lemma internal_msg_tagFromParticipant_from_pts tag from to :
  internal_msg tag from to ->
  tagFromParticipant tag ->
  from \in pts.

Lemma internal_msg_tagFromCoordinator_to_pts tag from to :
  internal_msg tag from to ->
  tagFromCoordinator tag ->
  to \in pts.

Lemma internal_msg_tagFromCoordinator_from_cn tag from to :
  internal_msg tag from to ->
  tagFromCoordinator tag ->
  from == cn.

Lemma internal_msg_to_cn tag from :
  internal_msg tag from cn ->
  participant_msg tag from cn.

Lemma inv_msg_round d (C : coh d) i tag m from to round cs :
  find i (dsoup d) =
    Some {| content := {| tag := tag; tms_cont := m |};
            from := from;
            to := to;
            active := true |} ->
  internal_msg tag from to ->
  Inv d ->
  getStC C = (round, cs) ->
  head 0 m == round.

Definition E_consume_external d i this tag m from P :=
  let: d' := {| dstate := upd this (loc this d) (dstate d);
                dsoup := consume_msg (dsoup d) i |} in
  coh d ->
  find i (dsoup d) =
    Some {| content := {| tag := tag; tms_cont := m |};
            from := from;
            to := this;
            active := true |} ->
  ~~ internal_msg tag from this ->
  P d ->
  P d'.

Lemma cn_stateE_consume_external d i this tag m from cs log :
  E_consume_external d i this tag m from (fun d => cn_state d cs log).

Lemma pt_stateE_consume_external d i this tag m from ps lg pt :
  E_consume_external d i this tag m from (fun d => pt_state d ps lg pt).

Lemma msg_specE_consume_external d i this tag m from from' to' tag' m' :
  internal_msg tag' from' to' ->
  E_consume_external d i this tag m from (fun d => msg_spec from' to' tag' m' (dsoup d)).

Lemma pt_PhaseOneE_consume_external d i this tag m from round next_data lg pt :
  pt \in pts ->
  E_consume_external d i this tag m from (fun d => pt_PhaseOne d round next_data lg pt).

Lemma pt_InitE_consume_external d i this tag m from round lg pt :
  E_consume_external d i this tag m from (fun d => pt_Init d round lg pt).

Lemma pt_PhaseOneRespondedE_consume_external d i this tag m from round next_data lg b pt :
  E_consume_external d i this tag m from (fun d => pt_PhaseOneResponded d round next_data lg b pt).

Lemma pt_PhaseTwoRespondedE_consume_external d i this tag m from round next_data lg b pt :
  E_consume_external d i this tag m from (fun d => pt_PhaseTwoResponded d round next_data lg b pt).

Lemma pt_PhaseTwoCommitE_consume_external d i this tag m from round next_data lg pt :
  pt \in pts ->
  E_consume_external d i this tag m from (fun d => pt_PhaseTwoCommit d round next_data lg pt).

Lemma pt_PhaseTwoAbortE_consume_external d i this tag m from round next_data lg pt :
  pt \in pts ->
  E_consume_external d i this tag m from (fun d => pt_PhaseTwoAbort d round next_data lg pt).

Lemma invE_consume_external d i this tag m from :
  E_consume_external d i this tag m from Inv.

Lemma rc_step_external d (C : coh d) this (Hthis : this \in nodes cn pts others) tag from m i :
  ~~ internal_msg tag from this ->
   find i (dsoup d) =
    Some {| content := {| tag := tag; tms_cont := m |};
            from := from;
            to := this;
            active := true |} ->
 rc_step tag from m C Hthis = loc this d.

Lemma rp_step_external d (C : coh d) this (Hthis : this \in nodes cn pts others) tag from m i :
  ~~ internal_msg tag from this ->
   find i (dsoup d) =
    Some {| content := {| tag := tag; tms_cont := m |};
            from := from;
            to := this;
            active := true |} ->
 rp_step Hnin tag from m C Hthis = loc this d.

Lemma internal_msg_from_cn tag to :
  internal_msg tag cn to ->
  coord_msg tag cn to.

Lemma p_matches_tag_internal_inv d i t m pt r ps lg :
  coh d ->
  pt \in pts ->
  find i (dsoup d) =
    Some {| content := {| tag := t; tms_cont := m |};
            from := cn;
            to := pt;
            active := true |} ->
  internal_msg t cn pt ->
  pt_state d (r, ps) lg pt ->
  Inv d ->
  p_matches_tag ps t.

Lemma PhaseOne_msg_next_data d (C : coh d) i m pt round next_data lg  :
  find i (dsoup d) =
    Some {| content := {| tag := prep_req; tms_cont := m |};
            from := cn;
            to := pt;
            active := true |} ->
  internal_msg prep_req cn pt ->
  PhaseOne d round next_data lg ->
  behead m == next_data.

Lemma cn_state_functional d cs1 lg1 cs2 lg2 :
  valid (loc cn d) ->
  cn_state d cs1 lg1 ->
  cn_state d cs2 lg2 ->
  cs1 = cs2 /\ lg1 = lg2.

Lemma pt_log_agreement d r lg pt :
  coh d ->
  pt \in pts ->
  pt_state d (r, PInit) lg pt ->
  Inv d ->
  forall pt' ps' r' lg',
    pt' \in pts ->
    pt_state d (r', ps') lg' pt' ->
    r' = r ->
    lg' = lg.

Lemma cn_log_agreement d r lg pt :
  coh d ->
  cn_state d (r, CInit) lg ->
  Inv d ->
  pt \in pts ->
  pt_state d (r, PInit) lg pt.

End TwoPhaseInductiveInv. *)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Section TwoPhaseInductiveProof.

Variable l : Label.
Variables (cn : nid) (pts : seq nid) (others : seq nid).
Hypothesis Hnin : cn \notin pts.
Hypothesis PtsNonEmpty : pts != [::].

Definition tpc := TwoPhaseCommitProtocol others Hnin l.

Notation sts := (snd_trans tpc).
Notation rts := (rcv_trans tpc).

Notation loc z d := (getLocal z d).

Notation Sinv := (@S_inv tpc (fun d _ => Inv cn pts d)).
Notation Rinv := (@R_inv tpc (fun d _ => Inv cn pts d)).
Notation coh d := (coh tpc d).
Notation PI := pf_irr.

Export TPCProtocol.

Program Definition s1: Sinv (cn_send_prep_trans cn pts others).
Proof.
move=>this to d msg S h/= Hi/=[]T G.
case: (S)=>[][/eqP]Z H1[C]; subst this.
case=>[[e[E1][dt]Z']|[e][dt][ps][E1]Z']; subst msg;
rewrite (PI (cn_safe_coh _) C) E1 in T.

case: (@inv_init l cn pts others Hnin d e _ Hi E1)=>lg{Hi E1}[E1]H2.
rewrite (PI (cn_this_in _ _) (cn_in _ _ _))
        (getStL_Kc C (cn_in _ _ _) E1) in T; subst h=>/=.
exists e, lg; constructor 2; exists dt.
have Y: {subset [::to] <= pts} by move=>z; rewrite inE=>/eqP->.
case X: (pts == [::to]); [right; exists [::]|left; exists [::to]];
split=>//=; do?[by rewrite /cn_state locE'?(cohVl C)///cstep_send H1 X];
move=>pt Hp.

- move/eqP: X=>Z; rewrite Z inE in Hp; move/eqP: Hp=>Hp _; subst pt.
  constructor 1=>/=; simpl in G. case/H2: (H1)=>H1' H1''.
  split=>//; rewrite /pt_state//; last first.
  apply: msg_specE; rewrite ?(cohVs C)//.
  apply: no_msg_from_toE'; rewrite ?(cohVs C)//.
  + by move: (this_not_pts Hnin H1); rewrite eq_sym.
  by rewrite (G _ (this_not_pts Hnin H1)); rewrite /pt_state in H1'.
- case: ifP.
  rewrite inE=>/eqP=>Z; subst pt.
  constructor 1=>/=; simpl in G; case/H2: (H1)=>H1' H1''.
  split=>//; rewrite /pt_state//; last first.
  apply: msg_specE; rewrite ?(cohVs C)//.
  apply: no_msg_from_toE'; rewrite ?(cohVs C)//.
  + by move: (this_not_pts Hnin H1); rewrite eq_sym.
  by move:(this_not_pts Hnin H1)=>/G->; rewrite/pt_state in H1'.
- rewrite /pt_Init.
  move=>N/=;simpl in G; case/H2: (Hp)=>H1' H1''; rewrite/pt_state/=.
  move: (this_not_pts Hnin Hp)=>Hp'; rewrite (G _ Hp'); split=>//.
  - apply: no_msg_from_toE'; rewrite ?(cohVs C)//.
    by move: (this_not_pts Hnin Hp); rewrite eq_sym.
  apply: no_msg_from_toE; rewrite ?(cohVs C)//.
  by apply/negbTE/negP=>/eqP Z; subst to; rewrite inE eqxx in N.

case: (@inv_prep_send l cn pts others Hnin d e _ _ _ Hi E1).
move=> lg{Hi}[ps'][E1']H2 H3 H4 H5.
rewrite (PI (cn_this_in _ _) (cn_in _ _ _))
        (getStL_Kc C (cn_in _ _ _) E1') in T; subst h=>/=.
rewrite (getStC_K C E1') in E1; case: E1=>Z; subst ps'.
exists e, lg; constructor 2; simpl in G; exists dt.
case X: (perm_eq (to :: ps) pts);
  [right; exists [::]|left; exists (to::ps)]=>/=;
split; do?[by rewrite /cn_state locE'?(cohVl C)///cstep_send H1 X]=>//;
[move=>pt Hp _| move=>/=; by rewrite H5| |move=>pt Hp]; first 1 last.

- move=>z; rewrite inE=>/orP[];[by move/eqP=>->|by apply: H3].
- case: ifP; last first.
  + rewrite inE=>/Bool.orb_false_iff[Z1]Z2.
    move: (H4 _ Hp); rewrite Z2; move=>[G1 G2].
    split; first by move:(this_not_pts Hnin Hp)=>/G; rewrite /pt_state=>->.
    - apply: no_msg_from_toE'; rewrite ?(cohVs C)//.
      by move: (this_not_pts Hnin Hp); rewrite eq_sym.
  by apply: no_msg_from_toE; rewrite ?(cohVs C)//.

- rewrite inE=>/orP[].
  move/eqP=>Z;subst to.
  move: (H4 _ Hp); move/negbTE: H5->; case=>G1 G2 G3.
  constructor 1=>/=; split=>//; last 2 first.
  + apply:no_msg_from_toE'=>//;
  rewrite ?(cohVs C)//; move:(this_not_pts Hnin Hp).
  by rewrite eq_sym.
- by apply:msg_specE;rewrite ?(cohVs C)//.
  move:(this_not_pts Hnin Hp)=>/G; rewrite /pt_state=>->.
  by rewrite /pt_state.

- move=>Z; move: (H4 _ Hp); rewrite Z.
  have Z1: pt == to = false.
  + by apply/negbTE/negP=>/eqP=>Z1; subst to; rewrite Z in H5.
  by apply:(@pt_PhaseOneE l cn pts others Hnin d e dt lg pt to _ _ C Hp Z1 G).

case Z1: (pt == to); last first.
- move/perm_eq_mem: X=>/(_ pt); rewrite inE Z1/= Hp=>Z.
  move: (H4 _ Hp); rewrite Z.
  by apply:(@pt_PhaseOneE l cn pts others Hnin d e dt lg pt to _ _ C Hp Z1 G).
move/eqP:Z1=>Z1; subst to.
move: (H4 _ H1); rewrite (negbTE H5); case=>G1 G2.
constructor 1=>/=; split=>//; last 2 first.
- apply:no_msg_from_toE'=>//;
  rewrite ?(cohVs C)//; move: (this_not_pts Hnin Hp).
  by rewrite eq_sym.
- by apply:msg_specE;rewrite ?(cohVs C)//.
move:(this_not_pts Hnin Hp)=>/G; rewrite /pt_state=>->.
by rewrite /pt_state.
Qed.

Program Definition s2: Sinv (cn_send_commit_trans cn pts others).
Proof.
move=>this to d msg S h/= Hi/=[]T G.
case: (S)=>[][/eqP]Z Hto[C]; subst this.

move=>[[round][next_data][recvd]|[round][next_data][sent]].
- move=>[St M P A]. subst msg.
  rewrite (PI (cn_safe_coh _) C) St in T.
  case: (@inv_waitprep l cn pts others Hnin _ round C next_data recvd Hi St) =>lg.
  move=>[] Hst Huniq Hsub Hrecvd1 Hrecvd2.
  exists round, lg. constructor 3.
  exists next_data.
  rewrite (getStL_Kc C _ Hst) /cstep_send Hto P A in T.
  case X: (pts == [::to]);
    [constructor 3; exists [::]|constructor 1; exists [:: to]];
    rewrite X in T; subst h; split=>//;
    do?[by rewrite /cn_state locE' ?(cohVl C)//]; first 1 last.
  + by move=>x; rewrite inE => /eqP->.
  + move=>pt Hpt.
    case: ifP; rewrite inE.
    * move=>/eqP ?; subst pt.
      have Htorecv: (to, true) \in recvd by apply (has_all_true P A).
      case: (Hrecvd1 _ _ Hpt Htorecv) => M1 M2 PS.
      constructor 1; split.
      by move: PS; rewrite /pt_state (G _ (this_not_pts Hnin Hpt)).
      by apply: msg_specE; rewrite ?(cohVs C).
      by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
    * move=> Npt.
      have Hptrecvd: (pt, true) \in recvd by apply (has_all_true P A).
      move: (Hrecvd1 _ _ Hpt Hptrecvd).
      by apply: (@pt_PhaseOneRespondedE l cn pts others Hnin).
  + move=>pt Hpt.
    rewrite in_nil.
    move/eqP in X.
    rewrite X inE in Hpt.
    move /eqP in Hpt. subst pt.
    have Htorecv: (to, true) \in recvd by apply (has_all_true P A).
    case: (Hrecvd1 _ _ Hto Htorecv) => M1 M2 PS.
    constructor 1; split.
    by move: PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto)).
    by apply: msg_specE; rewrite ?(cohVs C).
    by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
- move=>[St ? HtoNsent]. subst msg.
  rewrite (PI (cn_safe_coh _) C) St in T.
  case: (@inv_sentcommit l cn pts others Hnin _ round C next_data sent Hi St) =>lg.
  case => Hst Huniq Hsub Hsent.
  exists round, lg. constructor 3.
  exists next_data.
  rewrite (getStL_Kc C _ Hst) /cstep_send Hto in T.
  case X: (perm_eq (to :: sent) pts); subst h; rewrite X; rewrite X in G.
  + constructor 3. exists [::].
    split=>//.
    by rewrite /cn_state locE' ?(cohVl C).
    move=>pt Hpt.
    rewrite in_nil.
    move/perm_eq_mem: X=>/(_ pt); rewrite inE Hpt.
    case/orP.
    * move/eqP=>?; subst pt.
      move: (Hsent to Hto).
      move: HtoNsent => /negbTE->.
      case=> M1 M2 PS.
      constructor 1; split.
      by move: PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto)).
      by apply: msg_specE; rewrite ?(cohVs C).
      by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
    * move=> Hptsent.
      move: (Hsent _ Hpt).
      rewrite Hptsent.
      apply: (@pt_PhaseTwoCommitE l cn pts others Hnin)=>//.
      apply/negP. move=>/eqP ?; subst pt.
      move/negbTE in HtoNsent.
      congruence.
  + constructor 1. exists (to :: sent).
    split.
    * by rewrite /cn_state locE' ?(cohVl C).
    * by rewrite cons_uniq Huniq andbT.
    * by rewrite /sub_mem => x; rewrite in_cons => /orP[/eqP->|/Hsub].
    * move=>pt Hpt.
      rewrite in_cons.
      case: ifP.
      case/orP.
      -- move/eqP=>?; subst pt.
         move: (Hsent to Hto).
         move: HtoNsent => /negbTE->.
         case=> M1 M2 PS.
         constructor 1; split.
         by move: PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto)).
         by apply: msg_specE; rewrite ?(cohVs C).
         by apply: (no_msg_from_toE' (cohVs C))=>//;
                   rewrite eq_sym (this_not_pts Hnin Hto).
      -- move=> Hptsent.
         move: (Hsent _ Hpt).
         rewrite Hptsent.
         apply: (@pt_PhaseTwoCommitE l cn pts others Hnin)=>//.
         apply/negP. move=>/eqP ?. subst pt.
         move/negbTE in HtoNsent.
         congruence.
      -- move/Bool.orb_false_elim=>[N] HptNsent.
         move: (Hsent pt Hpt).
         rewrite HptNsent.
         by apply: (@pt_PhaseOneRespondedE l cn pts others Hnin).
Qed.

Program Definition s3: Sinv (cn_send_abort_trans cn pts others).
Proof.
move=>this to d msg S h/= Hi/=[]T G.
case: (S)=>[][/eqP]Z Hto[C]; subst this.

move=>[[round][next_data][recvd]|[round][next_data][sent]].

- move=>[St M P A]. subst msg.
  rewrite has_predC in A; move/negbTE: A=>A.
  rewrite (PI (cn_safe_coh _) C) St in T.
  case: (@inv_waitprep l cn pts others Hnin _ round C next_data recvd Hi St) =>lg.
  move=>[] Hst Huniq Hsub Hrecvd1 Hrecvd2.
  exists round, lg; constructor 3.
  exists next_data.
  rewrite (getStL_Kc C _ Hst) /cstep_send Hto P A in T.
  case X: (pts == [::to]);
    [constructor 4; exists [::]|constructor 2; exists [:: to]];
    rewrite X in T; subst h; split=>//;
    do?[by rewrite /cn_state locE' ?(cohVl C)//]; first 1 last.
  + by move=>x; rewrite inE => /eqP->.
  + move=>pt Hpt.
    case: ifP; rewrite inE.
    * move=>/eqP ?; subst pt.
      have Htorecv: exists b, (to, b) \in recvd
           by apply: (has_some_false P Hpt).
      case: Htorecv=>b Htorecv.
      case: (Hrecvd1 _ _ Hpt Htorecv) => M1 M2 PS.
      constructor 1; split=>/={Htorecv}.
      by case: b PS; rewrite /pt_state (G _ (this_not_pts Hnin Hpt));
         [left | right].
      by apply: msg_specE; rewrite ?(cohVs C).
      by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
    * move=> Npt.
      have Htorecv: exists b, (pt, b) \in recvd
          by apply: (has_some_false P Hpt).
      case: Htorecv=>b Htorecv/=; exists b.
      apply: (@pt_PhaseOneRespondedE l cn pts others Hnin)=>//.
      by apply: (Hrecvd1 pt _ _ Htorecv).
  + move=>pt Hpt.
    rewrite in_nil.
    move/eqP in X.
    rewrite X inE in Hpt.
    move /eqP in Hpt. subst pt.
    have Htorecv: exists b, (to, b) \in recvd
        by apply: (has_some_false P Hto).
    case: Htorecv=>b Htorecv.
    case: (Hrecvd1 _ _ Hto Htorecv) => M1 M2 PS {Htorecv}.
    constructor 1; split.
    by case: b PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto));
       [left | right].
    by apply: msg_specE; rewrite ?(cohVs C).
    by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
- move=>[St ? HtoNsent]. subst msg.
  rewrite (PI (cn_safe_coh _) C) St in T.
  case: (@inv_sentabort l cn pts others Hnin _ round C next_data sent Hi St) =>lg.
  case => Hst Huniq Hsub Hsent.
  exists round, lg. constructor 3.
  exists next_data.
  rewrite (getStL_Kc C _ Hst) /cstep_send Hto in T.
  case X: (perm_eq (to :: sent) pts); subst h; rewrite X; rewrite X in G.
  + constructor 4; exists [::].
    split=>//.
    by rewrite /cn_state locE' ?(cohVl C).
    move=>pt Hpt.
    rewrite in_nil.
    move/perm_eq_mem: X=>/(_ pt); rewrite inE Hpt.
    case/orP.
    * move/eqP=>?; subst pt.
      move: (Hsent to Hto).
      move: HtoNsent => /negbTE->.
      case=>b [M1] M2 PS.
      constructor 1; split.
      by case: b PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto)); [left|right].
      by apply: msg_specE; rewrite ?(cohVs C).
      by apply: (no_msg_from_toE' (cohVs C))=>//;
         rewrite eq_sym (this_not_pts Hnin Hto).
    * move=> Hptsent.
      move: (Hsent _ Hpt).
      rewrite Hptsent.
      apply: (@pt_PhaseTwoAbortE l cn pts others Hnin)=>//.
      apply/negP. move=>/eqP ?. subst pt.
      move/negbTE in HtoNsent.
      congruence.
  + constructor 2. exists (to :: sent).
    split.
    * by rewrite /cn_state locE' ?(cohVl C).
    * by rewrite cons_uniq Huniq andbT.
    * by rewrite /sub_mem => x; rewrite in_cons => /orP[/eqP->|/Hsub].
    * move=>pt Hpt.
      rewrite in_cons.
      case: ifP.
      case/orP.
      -- move/eqP=>?; subst pt.
         move: (Hsent to Hto).
         move: HtoNsent => /negbTE->.
         case=>b[M1] M2 PS.
         constructor 1; split.
         by case: b PS; rewrite /pt_state (G _ (this_not_pts Hnin Hto));
            [left|right].
         by apply: msg_specE; rewrite ?(cohVs C).
         by apply: (no_msg_from_toE' (cohVs C))=>//;
                   rewrite eq_sym (this_not_pts Hnin Hto).
      -- move=> Hptsent.
         move: (Hsent _ Hpt).
         rewrite Hptsent.
         apply: (@pt_PhaseTwoAbortE l cn pts others Hnin)=>//.
         apply/negP. move=>/eqP ?. subst pt.
         move/negbTE in HtoNsent.
         congruence.
      -- move/Bool.orb_false_elim=>[N] HptNsent.
         move: (Hsent pt Hpt).
         rewrite HptNsent; case=>b H; exists b.
         by apply: (@pt_PhaseOneRespondedE l cn pts others Hnin).
Qed.

Program Definition s4: Sinv (pn_send_yes_trans others Hnin).
Proof.
move=>this to d m S h I [] T G.
case: (S)=>[][] Hthis /eqP ? [H][C] [r][nd][PS] ?. subst to m.
have Vl := cohVl C.
have Vs := cohVs C.
move: (inv_gotrequest(l:=l) Hthis PS I)=> [lg]PO.
move: (PhaseOne_round_pt Hthis PO) => [ps] PS'.
move: PS.
rewrite (getStP_K Hnin C _ Hthis PS').
case=>?. subst ps.
move: PS'=>PS.
exists r, lg.
constructor 2.
exists nd.
move: (PhaseOne_PGotRequest_next_data_pt(l:=l)(Hnin:=Hnin) C Hthis PS PO) =>[]_ NM1 NM2.
case: PO=>[[sent]|[recvd]].
- case=>CS' U Sub Pts.
  left. exists sent.
  split=>//.
  + apply /(cn_state_soupE(Hnin := Hnin) _ _ C)=>//.
    by apply: (pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case E: (this == pt).
    + move/eqP in E. subst pt.
      case: ifP.
      * move=>_ _.
        constructor 3.
        split.
        -- rewrite /pt_state locE'//. subst.
           by rewrite (getStP_K Hnin _ _ Hthis PS)
                      (getStL_Kp _ _ PS).
        -- apply /no_msg_from_toE'=>//.
           by apply/negbTE/(pt_not_cn Hnin).
        -- by apply /msg_specE.
      * move=>_ [] PS'.
        move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
        move: (pt_state_functional V PS PS')=>[]; discriminate.
    + move/negbT in E.
      case: ifP.
      * move=>_.
        apply: (pt_PhaseOneE' _ _ _ C)=>//.
        by apply/(pt_not_cn Hnin).
      * move=>_.
        apply: (pt_InitE _ _ _ C)=>//.
        by apply/(pt_not_cn Hnin).
- case=>CS' U Sub Hrecvd1 Hrecvd2.
  right. exists recvd.
  split=>//.
  + apply /(cn_state_soupE _ _ C)=>//.
    by apply: (pt_not_cn Hnin).
  + move=>pt b Hpt Hr.
    case E: (this == pt).
    * move/eqP in E. subst pt.
      exfalso.
      case: (Hrecvd1 _ _ Hpt Hr)=> _ _.
      case: ifP=>_ PS';
        move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
        move: (pt_state_functional V PS PS')=>[]; discriminate.
    * move: (Hrecvd1 pt b Hpt Hr).
      apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
      by apply /negbT.
      by apply: (pt_not_cn Hnin).
  + move=>pt Hpt Hr.
    case E: (this == pt).
    * move/eqP in E. subst pt.
      constructor 3.
      split.
      -- rewrite /pt_state locE'//. subst.
           by rewrite (getStP_K Hnin _ _ Hthis PS)
                      (getStL_Kp _ _ PS).
      -- apply /no_msg_from_toE'=>//.
         by apply /negbTE/(pt_not_cn Hnin).
      -- by apply msg_specE=>//.
    * move: (Hrecvd2 pt Hpt Hr).
      apply: (pt_PhaseOneE' _ _ _ C)=>//.
      by apply /negbT.
      by apply: (pt_not_cn Hnin).
Qed.

Program Definition s5: Sinv (pn_send_no_trans others Hnin).
Proof.
move=>this to d m S h I [] T G.
case: (S)=>[][] Hthis /eqP ? [H][C] [r][nd][PS] ?. subst to m.
have Vl := cohVl C.
have Vs := cohVs C.
move: (inv_gotrequest(l := l) Hthis PS I)=> [lg]PO.
move: (PhaseOne_round_pt Hthis PO) => [ps] PS'.
move: PS.
rewrite (getStP_K Hnin C _ Hthis PS').
case=>?. subst ps.
move: PS'=>PS.
exists r, lg.
constructor 2.
exists nd.
move: (PhaseOne_PGotRequest_next_data_pt(l:=l)(Hnin:=Hnin) C Hthis PS PO) =>[]_ NM1 NM2.
case: PO=>[[sent]|[recvd]].
- case=>CS' U Sub Pts.
  left. exists sent.
  split=>//.
  + apply /(cn_state_soupE _ _ C)=>//.
    by apply: (pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case E: (this == pt).
    + move/eqP in E. subst pt.
      case: ifP.
      * move=>_ _.
        constructor 4.
        split.
        -- rewrite /pt_state locE'//. subst.
           by rewrite (getStP_K Hnin _ _ Hthis PS)
                      (getStL_Kp _ _ PS).
        -- apply /no_msg_from_toE'=>//.
           by apply/negbTE/(pt_not_cn Hnin).
        -- by apply /msg_specE.
      * move=>_ [] PS'.
        move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
        move: (pt_state_functional V PS PS')=>[]; discriminate.
    + move/negbT in E.
      case: ifP.
      * move=>_.
        apply: (pt_PhaseOneE' _ _ _ C)=>//.
        by apply/(pt_not_cn Hnin).
      * move=>_.
        apply: (pt_InitE _ _ _ C)=>//.
        by apply/(pt_not_cn Hnin).
- case=>CS' U Sub Hrecvd1 Hrecvd2.
  right. exists recvd.
  split=>//.
  + apply /(cn_state_soupE _ _ C)=>//.
    by apply: (pt_not_cn Hnin).
  + move=>pt b Hpt Hr.
    case E: (this == pt).
    * move/eqP in E. subst pt.
      exfalso.
      case: (Hrecvd1 _ _ Hpt Hr)=> _ _.
      case: ifP=>_ PS';
        move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
        move: (pt_state_functional V PS PS')=>[]; discriminate.
    * move: (Hrecvd1 pt b Hpt Hr).
      apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
      by apply /negbT.
      by apply: (pt_not_cn Hnin).
  + move=>pt Hpt Hr.
    case E: (this == pt).
    * move/eqP in E. subst pt.
      constructor 4.
      split.
      -- rewrite /pt_state locE'//. subst.
           by rewrite (getStP_K Hnin _ _ Hthis PS)
                      (getStL_Kp _ _ PS).
      -- apply /no_msg_from_toE'=>//.
         by apply /negbTE/(pt_not_cn Hnin).
      -- by apply msg_specE=>//.
    * move: (Hrecvd2 pt Hpt Hr).
      apply: (pt_PhaseOneE' _ _ _ C)=>//.
      by apply /negbT.
      by apply: (pt_not_cn Hnin).
Qed.

Program Definition s6: Sinv (pn_commit_ack_trans others Hnin).
Proof.
move=>this to d m S h I [] T G.
case: (S)=>[][] Hthis /eqP ? [H][C] [r][nd][PS] ?. subst to m.
have Vl := cohVl C.
have Vs := cohVs C.

move: (inv_committed(l:=l) Hthis PS I)=> [lg] PT.
case: (PhaseTwo_PCommitted_pt(l := l)(Hnin := Hnin) Hthis PS PT)=>{PS}PS NM1 NM2.
exists r, lg.
constructor 3.
exists nd.
have: this != cn by apply: (pt_not_cn Hnin).
case: PT=>[[sent]|[sent]|[recvd]|[recvd]] {I}I;
  [constructor 1; exists sent|constructor 2; exists sent|
   constructor 3; exists recvd|constructor 4; exists recvd];
case: I=> CS U S' Pts; split=>//;
do?[by apply /(cn_state_soupE _ _ C)=>//];
move=> pt Hpt; move: (Pts pt Hpt); case: ifP=>_.
- case E: (this == pt).
  + move/eqP in E. subst pt.
    move=>_.
    constructor 3.
    split.
    * by rewrite /pt_state locE'// T
              (getStP_K _ _ _ _ PS)//
              (getStL_Kp _ _ PS).
    * apply /no_msg_from_toE'=>//.
      by apply: negbTE.
    * by apply: msg_specE=>//.
  + move/negbT in E.
    by apply: (pt_PhaseTwoCommitE' _ _ _ C)=>//.
- move=>H1.
  apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => _ _ PS'.
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoAbortE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => [][][]PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>[b] H1.
  exists b.
  apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => _ _; case: ifP=>_ PS';
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1=> PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- case E: (this == pt).
  + move/eqP in E. subst pt.
    move=>_.
    constructor 3.
    split.
    * by rewrite /pt_state locE'// T
              (getStP_K _ _ _ _ PS)//
              (getStL_Kp _ _ PS).
    * apply /no_msg_from_toE'=>//.
      by apply: negbTE.
    * by apply: msg_specE=>//.
  + move/negbT in E.
    by apply: (pt_PhaseTwoCommitE' _ _ _ C)=>//.
- move=>H1.
  apply: (pt_PhaseTwoRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1=> PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoAbortE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => [][][]PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
Qed.

Program Definition s7: Sinv (pn_abort_ack_trans others Hnin).
Proof.
move=>this to d m S h I [] T G.
case: (S)=>[][] Hthis /eqP ? [H][C] [r][nd][PS] ?. subst to m.
have Vl := cohVl C.
have Vs := cohVs C.

move: (inv_aborted(l:=l) Hthis PS I)=> [lg] PT.
case: (PhaseTwo_PAborted_pt(l:=l)(Hnin:=Hnin) Hthis PS PT)=>{PS}PS NM1 NM2.
exists r, lg.
constructor 3.
exists nd.
have: this != cn by apply: (pt_not_cn Hnin).
case: PT=>[[sent]|[sent]|[recvd]|[recvd]] {I}I;
  [constructor 1; exists sent|constructor 2; exists sent|
   constructor 3; exists recvd|constructor 4; exists recvd];
case: I=> CS U S' Pts; split=>//;
do?[by apply /(cn_state_soupE _ _ C)=>//];
move=> pt Hpt; move: (Pts pt Hpt); case: ifP=>_.
- move=>H1.
  apply: (pt_PhaseTwoCommitE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => [][][]PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => _ _ PS'.
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- case E: (this == pt).
  + move/eqP in E. subst pt.
    move=>_.
    constructor 3.
    split.
    * by rewrite /pt_state locE'// T
              (getStP_K _ _ _ _ PS)//
              (getStL_Kp _ _ PS).
    * apply /no_msg_from_toE'=>//.
      by apply: negbTE.
    * by apply: msg_specE=>//.
  + move/negbT in E.
    by apply: (pt_PhaseTwoAbortE' _ _ _ C)=>//.
- move=>[b] H1.
  exists b.
  apply: (pt_PhaseOneRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => _ _; case: ifP=>_ PS';
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1=> PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoCommitE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1 => [][][]PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- move=>H1.
  apply: (pt_PhaseTwoRespondedE' _ _ _ C)=>//.
  case E: (this == pt)=>//.
  move/eqP in E. subst pt.
  case: H1=> PS' _ _;
  move: C=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _;
  move: (pt_state_functional V PS PS')=>[]; discriminate.
- case E: (this == pt).
  + move/eqP in E. subst pt.
    move=>_.
    constructor 3.
    split.
    * by rewrite /pt_state locE'// T
              (getStP_K _ _ _ _ PS)//
              (getStL_Kp _ _ PS).
    * apply /no_msg_from_toE'=>//.
      by apply: negbTE.
    * by apply: msg_specE=>//.
  + move/negbT in E.
    by apply: (pt_PhaseTwoAbortE' _ _ _ C)=>//.
Qed.

Program Definition r1: Rinv (cn_receive_prep_yes_trans cn pts others).
Proof.
move=>d from this i C [tag m] H1 I F D/= Hmatch Et G.
subst tag.

case Hinternal: (internal_msg cn pts prep_yes from this); first last.
- move /negbT in Hinternal.
  rewrite (rc_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rc_step/cstep_recv.
case CS: (getStC (cn:=cn) (pts:=pts) (others:=others) (d:=d) C) => [round cs].
have Hthis := (internal_msg_tagFromParticipant_to_cn Hinternal erefl).
rewrite Hthis. move/eqP in Hthis. subst this.
have Hfrom := (internal_msg_tagFromParticipant_from_pts Hinternal erefl).
rewrite Hfrom/=.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/=.

move: Hmatch.
rewrite CS/=.
move=>/c_matches_tag_prep_yes_inv [next_data] [recvd] ?.
subst cs.
move: (CS)=>/inv_waitprep.
move => /(_ I){I} [lg] I.
case: (I) => []Hst U Hsub Hrecvd1 Hrecvd2.
exists round, lg. constructor 2.
exists next_data. right.
case: ifP.
- move => Hignore.
  exists recvd.
  rewrite (getStL_Kc C _ Hst).
  by apply: (@cn_PhaseOneReceive_consume l cn pts others _ _ _ _ _ _ _ _ from); try exact: F.
move /negbT=>Hnew.
exists ((from, true) :: recvd).
split.
- rewrite /cn_state locE'; last by exact: (cohVl C).
  by rewrite (getStL_Kc C _ Hst) eqxx.
- by rewrite cons_uniq /= Hnew.
- by move => x; rewrite inE /=; move=> /orP[/eqP->|]//; exact: Hsub.
- move => pt b Hpt.
  rewrite inE => /orP[].
  + move=>/eqP[] ? ?. subst pt b.
    move: Hnew.
    move /(Hrecvd2 _ Hpt)/(@prep_yes_pt_inv cn _ _ _ _ _ _ _ _ F).
    move /(_ erefl).
    case=>[]PS NM M.
    split=>/=.
    by apply /no_msg_from_to_consume=>//; rewrite (cohVs C).
    clear G.
    by apply: (msg_spec_consume (cohVs C) F M).
    rewrite /pt_state.
    have HfromN: from != cn.
    * apply /negbT.
      case H: (from == cn)=>//.
      move/eqP in H. subst from.
      by move: (Hnin); rewrite Hpt.
    by rewrite locU// (cohVl C).
  move=>Hr; apply /(@pt_PhaseOneRespondedE_consume l cn pts others _)=>//.
  by apply: (pt_not_cn Hnin).
  by apply Hrecvd1; auto.
- move=>pt Hpt.
  rewrite inE.
  move=>/norP/=[] N Hr.
  apply /(@pt_PhaseOneE_consume l cn pts others _ _ _ _ _ _ _ _ from _)=>//; try exact: F.
  by apply /(pt_not_cn _ Hpt).
  apply /Hrecvd2=>//.
Qed.

Program Definition r2: Rinv (cn_receive_prep_no_trans cn pts others).
Proof.
move=>d from this i C [tag m] H1 I F D/= Hmatch Et G.
subst tag.

case Hinternal: (internal_msg cn pts prep_yes from this); first last.
- move /negbT in Hinternal.
  rewrite (rc_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rc_step/cstep_recv.
case CS: (getStC (cn:=cn) (pts:=pts) (others:=others) (d:=d) C) => [round cs].
have Hthis := (internal_msg_tagFromParticipant_to_cn Hinternal erefl).
rewrite Hthis. move/eqP in Hthis. subst this.
have Hfrom := (internal_msg_tagFromParticipant_from_pts Hinternal erefl).
rewrite Hfrom/=.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/=.

move: Hmatch.
rewrite CS/=.
move=>/c_matches_tag_prep_yes_inv [next_data] [recvd] ?.
subst cs.
move: (CS)=>/inv_waitprep.
move => /(_ I){I} [lg] I.
case: (I) => []Hst U Hsub Hrecvd1 Hrecvd2.
exists round, lg. constructor 2.
exists next_data. right.
case: ifP.
- move => Hignore.
  exists recvd.
  rewrite (getStL_Kc C _ Hst).
  by apply: (@cn_PhaseOneReceive_consume l cn pts others _ _ _ _ _ _ _ _ from _ F).
move /negbT=>Hnew.
exists ((from, false) :: recvd).
split.
- rewrite /cn_state locE'; last by exact: (cohVl C).
  by rewrite (getStL_Kc C _ Hst).
- by rewrite cons_uniq /= Hnew.
- by move => x; rewrite inE /=; move=> /orP[/eqP->|]//; exact: Hsub.
- move => pt b Hpt.
  rewrite inE => /orP[].
  + move=>/eqP[] ? ?. subst pt b.
    move: Hnew.
    move /(Hrecvd2 _ Hpt)/(@prep_no_pt_inv cn _ _ _ _ _ _ _ _ F).
    move /(_ erefl).
    case=>[]PS NM M.
    split=>/=.
    by apply /no_msg_from_to_consume=>//; rewrite (cohVs C).
    clear G.
    by apply: (msg_spec_consume (cohVs C) F M).
    rewrite /pt_state.
    have HfromN: from != cn.
    * apply /negbT.
      case H: (from == cn)=>//.
      move/eqP in H. subst from.
      by move: (Hnin); rewrite Hpt.
    by rewrite locU// (cohVl C).
  move=>Hr; apply /(@pt_PhaseOneRespondedE_consume l cn pts others _)=>//.
  by apply: (pt_not_cn Hnin).
  by apply Hrecvd1; auto.
- move=>pt Hpt.
  rewrite inE.
  move=>/norP/=[] N Hr.
  apply /(pt_PhaseOneE_consume _ C _ _ _ F)=>//.
  by apply /(pt_not_cn Hnin).
  apply /Hrecvd2=>//.
Qed.

Program Definition r3: Rinv (cn_receive_commit_ack_trans cn pts others).
Proof.
move=>d from this i C [tag m] H1 I F D/= Hmatch Et G.
subst tag.
have Vl := cohVl C.
have Vs := cohVs C.

case Hinternal: (internal_msg cn pts prep_yes from this); first last.
- move /negbT in Hinternal.
  rewrite (rc_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rc_step/cstep_recv.
case CS: (getStC (cn:=cn) (pts:=pts) (others:=others) (d:=d) C) => [round cs].
have Hthis := (internal_msg_tagFromParticipant_to_cn Hinternal erefl).
rewrite Hthis. move/eqP in Hthis. subst this.
have Hfrom := (internal_msg_tagFromParticipant_from_pts Hinternal erefl).
rewrite Hfrom/=.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/=.

move: Hmatch.
rewrite CS/=.
move=>/c_matches_tag_commit_ack_inv [next_data] [recvd] ?.
subst cs.
move: (CS)=>/inv_waitcommit.
move => /(_ I){I} [lg] I.
case: (I) => [] Hst U Hsub Pts.
case: ifP.
- move => Hignore.
  exfalso.
  move: (Pts _ Hfrom). rewrite Hignore.
  by move=>[] _ _ /(_ _ _ _ F).
move=>/negbT Hr.
case: ifP.
- move=>P.
  exists round.+1, (rcons lg (true, next_data)).
  constructor 1.
  split.
  + rewrite /cn_state locE'//.
    by rewrite (getStL_Kc C _ Hst).
  + move=>pt Hpt.
    move/Pts: (Hpt).
    move: (perm_eq_mem P) => {P}P.
    move: (Hpt).
    rewrite -P inE.
    case/orP.
    * move/eqP=>?. subst pt.
      rewrite (negbTE Hr).
      move/(commit_ack_pt_inv _ F)=>/(_ erefl)[] PS NM M.
      split.
      -- rewrite /pt_state locU//.
         by apply /(@pt_not_cn cn pts Hnin from)=>//.
      -- by apply /(msg_spec_consume _ F M).
      -- by apply /no_msg_from_to_consume=>//.
    * move=>->[] PS NM1 NM2.
      split.
      -- apply /(pt_state_consume _ _ _ C)=>//.
         by apply /(@pt_not_cn cn pts Hnin pt)=>//.
      -- by apply /no_msg_from_to_consume=>//.
      -- by apply /no_msg_from_to_consume=>//.
- move=>P.
  exists round, lg.
  constructor 3.
  exists next_data.
  constructor 3.
  exists (from :: recvd).
  split.
  + rewrite /cn_state locE'//.
    by rewrite (getStL_Kc C _ Hst).
  + by rewrite cons_uniq /= Hr.
  + by move => x; rewrite inE /=; move=> /orP[/eqP->|]//; exact: Hsub.
  + move=> pt Hpt.
    rewrite inE.
    move: (Pts pt Hpt).
    case: ifP.
    * rewrite orbT=>Hr'.
       apply: (pt_PhaseTwoRespondedE_consume(pts:=pts) _ _ C)=>//.
       by apply: (pt_not_cn Hnin).
    * rewrite orbF.
      case: ifP.
      -- move/eqP => ? _. subst pt.
         move/(commit_ack_pt_inv _ F)=>/(_ erefl)[] PS NM M.
         split.
         ++ rewrite /pt_state locU//.
            by apply /(@pt_not_cn cn pts Hnin from)=>//.
         ++ by apply /no_msg_from_to_consume=>//.
         ++ by apply /(msg_spec_consume _ F M).
      -- move=>/negbT N /negbT H.
         apply: (pt_PhaseTwoCommitE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
Qed.

Program Definition r4: Rinv (cn_receive_abort_ack_trans cn pts others).
Proof.
move=>d from this i C [tag m] H1 I F D/= Hmatch Et G.
subst tag.
have Vl := cohVl C.
have Vs := cohVs C.

case Hinternal: (internal_msg cn pts prep_yes from this); first last.
- move /negbT in Hinternal.
  rewrite (rc_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rc_step/cstep_recv.
case CS: (getStC (cn:=cn) (pts:=pts) (others:=others) (d:=d) C) => [round cs].
have Hthis := (internal_msg_tagFromParticipant_to_cn Hinternal erefl).
rewrite Hthis. move/eqP in Hthis. subst this.
have Hfrom := (internal_msg_tagFromParticipant_from_pts Hinternal erefl).
rewrite Hfrom/=.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/=.

move: Hmatch.
rewrite CS/=.
move=>/c_matches_tag_abort_ack_inv [next_data] [recvd] ?.
subst cs.
move: (CS)=>/inv_waitabort.
move => /(_ I){I} [lg] I.
case: (I) => [] Hst U Hsub Pts.
case: ifP.
- move => Hignore.
  exfalso.
  move: (Pts _ Hfrom). rewrite Hignore.
  by move=>[] _ _ /(_ _ _ _ F).
move=>/negbT Hr.
case: ifP.
- move=>P.
  exists round.+1, (rcons lg (false, next_data)).
  constructor 1.
  split.
  + rewrite /cn_state locE'//.
    by rewrite (getStL_Kc C _ Hst).
  + move=>pt Hpt.
    move/Pts: (Hpt).
    move: (perm_eq_mem P) => {P}P.
    move: (Hpt).
    rewrite -P inE.
    case/orP.
    * move/eqP=>?. subst pt.
      rewrite (negbTE Hr).
      move/(abort_ack_pt_inv _ F)=>/(_ erefl)[] PS NM M.
      split.
      -- rewrite /pt_state locU//.
         by apply /(@pt_not_cn cn pts Hnin from)=>//.
      -- by apply /(msg_spec_consume _ F M).
      -- by apply /no_msg_from_to_consume=>//.
    * move=>->[] PS NM1 NM2.
      split.
      -- apply /(pt_state_consume _ _ _ C)=>//.
         by apply /(@pt_not_cn cn pts Hnin pt)=>//.
      -- by apply /no_msg_from_to_consume=>//.
      -- by apply /no_msg_from_to_consume=>//.
- move=>P.
  exists round, lg.
  constructor 3.
  exists next_data.
  constructor 4.
  exists (from :: recvd).
  split.
  + rewrite /cn_state locE'//.
    by rewrite (getStL_Kc C _ Hst).
  + by rewrite cons_uniq /= Hr.
  + by move => x; rewrite inE /=; move=> /orP[/eqP->|]//; exact: Hsub.
  + move=> pt Hpt.
    rewrite inE.
    move: (Pts pt Hpt).
    case: ifP.
    * rewrite orbT=>Hr'.
      apply: (pt_PhaseTwoRespondedE_consume(pts:=pts) _ _ C)=>//.
      by apply: (pt_not_cn Hnin).
    * rewrite orbF.
      case: ifP.
      -- move/eqP => ? _. subst pt.
         move/(abort_ack_pt_inv _ F)=>/(_ erefl)[] PS NM M.
         split.
         ++ rewrite /pt_state locU//.
            by apply /(@pt_not_cn cn pts Hnin from)=>//.
         ++ by apply /no_msg_from_to_consume=>//.
         ++ by apply /(msg_spec_consume _ F M).
      -- move=>/negbT N /negbT H.
         apply: (pt_PhaseTwoAbortE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
Qed.

Program Definition r5: Rinv (pn_receive_got_prep_trans others Hnin).
Proof.
move=>d from this i C [tag m] H1 I F D/= _ Et G.
subst tag.
have Vl := cohVl C.
have Vs := cohVs C.

case Hinternal: (internal_msg cn pts prep_req from this); first last.
- move /negbT in Hinternal.
  rewrite (rp_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rp_step/pstep_recv.
case PS: (getStP Hnin C H1) => [round ps].
have Hthis := (internal_msg_tagFromCoordinator_to_pts Hinternal erefl).
rewrite Hthis.
have Hfrom := (internal_msg_tagFromCoordinator_from_cn Hinternal erefl).
rewrite Hfrom/=. move/eqP in Hfrom. subst from.

move: (fun H => prep_req_cn_inv H Hthis F I) => /(_ erefl) [r][lg][nd] PO.
move: (PhaseOne_round_pt Hthis PO)=>[ps'] PS'.
move: PS.
rewrite (getStP_K Hnin C H1 Hthis PS').
case=> ? ?. subst.
move: (PhaseOne_round_cn PO)=>[cs] CS.
move /(getStC_K C) in CS.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/= !orbF.

have Hmatch := (p_matches_tag_internal_inv C Hthis F Hinternal PS' I).
rewrite Hmatch /=.

move: Hmatch. rewrite /p_matches_tag.
destruct ps=>// _.
exists round, lg.
constructor 2.
exists nd.
move: (PhaseOne_msg_next_data C F Hinternal PO) => /eqP Hnd. subst.
move: PO=>[].
- move=>[sent][] CS' U S Pts.
  left. exists sent. split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case: ifP => _ H.
    * case E: (pt == this).
      -- move /eqP in E. subst pt.
         case/(prep_req_pt_inv F): H=>_ NM M.
         constructor 2.
         split.
         ++ by rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
         ++ by apply /no_msg_from_to_consume.
         ++ by apply /(msg_spec_consume _ F M).
      -- move /negbT in E.
         apply /(pt_PhaseOneE_consume _ C _ _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
    * case E: (pt == this).
      -- move/eqP in E. subst pt.
         case: H => PS NM1 NM2.
         by move: (NM2 _ _ _ F).
      -- move/negbT in E.
         apply /(pt_InitE_consume _ C _ _ _ F)=>//.
         by apply /(pt_not_cn Hnin).
- move=>[recvd][] CS' U S Hrecvd1 Hrecvd2.
  right. exists recvd. split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt b Hpt Hr.
    case E: (pt == this).
    * move/eqP in E. subst pt.
      case: (Hrecvd1 _ _ Hpt Hr).
      by move=>/(_ _ _ _ F).
    * move/negbT in E.
      apply /(pt_PhaseOneRespondedE_consume _ _ C)=>//.
      by apply: Hrecvd1.
  + move=>pt Hpt Hr.
    move: (Hrecvd2 _ Hpt Hr).
    case E: (pt == this).
    * move/eqP in E. subst pt.
      case/(prep_req_pt_inv F)=>_ NM1 M.
      constructor 2. split.
      ++ by rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
      ++ by apply /no_msg_from_to_consume.
      ++ by apply /(msg_spec_consume _ F M).
    * move/negbT in E.
      apply /(pt_PhaseOneE_consume _ C _ _ _ F)=>//.
      by apply: (pt_not_cn Hnin).
Qed.

Program Definition r6: Rinv (pn_receive_commit_ack_trans others Hnin).
Proof.
move=>d from this i C [tag m] H1 I F D/= _ Et G.
subst tag.
have Vl := cohVl C.
have Vs := cohVs C.

case Hinternal: (internal_msg cn pts prep_req from this); first last.
- move /negbT in Hinternal.
  rewrite (rp_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rp_step/pstep_recv.
case PS: (getStP Hnin C H1) => [round ps].
have Hthis := (internal_msg_tagFromCoordinator_to_pts Hinternal erefl).
rewrite Hthis.
have Hfrom := (internal_msg_tagFromCoordinator_from_cn Hinternal erefl).
rewrite Hfrom/=. move/eqP in Hfrom. subst from.

move: (fun H => commit_req_cn_inv H Hthis F I) => /(_ erefl) [r][lg][nd] PT.
move: (fun H => PhaseTwoCommit_req_round H Hthis F PT) => /(_ erefl) [ps'] PS'.
move: PS.
rewrite (getStP_K Hnin C H1 Hthis PS').
case=> ? ?. subst.
move: (PhaseTwoCommit_round_cn PT)=>[cs] CS.
move /(getStC_K C) in CS.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/= !orbF.

have Hmatch := (p_matches_tag_internal_inv C Hthis F Hinternal PS' I).
rewrite Hmatch /=.

move: Hmatch. rewrite /p_matches_tag.
destruct ps=>// _.
exists round, lg.
constructor 3.
exists nd.
move: PT=>[].
- move=>[sent][] CS' U S Pts.
  constructor 1. exists sent.
  split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case: ifP => _ H.
    * case E: (pt == this).
      -- move /eqP in E. subst pt.
         case/(commit_req_pt_inv F): H=>PS'' M NM.
         pose proof C as C'.
         move: C'=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
         move: (pt_state_functional V PS' PS'')=>[][]? ?. subst.
         constructor 2.
         split.
         ++ by rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
         ++ by apply /(msg_spec_consume _ F M).
         ++ by apply /no_msg_from_to_consume.
      -- move /negbT in E.
         apply /(pt_PhaseTwoCommitE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
    * case E: (pt == this).
      -- move/eqP in E. subst pt.
         case: H => NM1 NM2 PS.
         by move: (NM1 _ _ _ F).
      -- move/negbT in E.
         by apply /(pt_PhaseOneRespondedE_consume _ _ C)=>//.
- move=>[recvd][] CS' U S Pts.
  constructor 3. exists recvd.
  split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case: ifP => _ H.
    * case E: (pt == this).
      -- move/eqP in E. subst pt.
         case: H => PS NM1 NM2.
         by move: (NM1 _ _ _ F).
      -- move/negbT in E.
         by apply /(pt_PhaseTwoRespondedE_consume _ _ C).
    * case E: (pt == this).
      -- move /eqP in E. subst pt.
         case/(commit_req_pt_inv F): H=>PS'' M NM.
         pose proof C as C'.
         move: C'=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
         move: (pt_state_functional V PS' PS'')=>[][]? ?. subst.
         constructor 2.
         split.
         ++ by rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
         ++ by apply /(msg_spec_consume _ F M).
         ++ by apply /no_msg_from_to_consume.
      -- move /negbT in E.
         apply /(pt_PhaseTwoCommitE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
Qed.

Program Definition r7: Rinv (pn_receive_abort_ack_trans others Hnin).
Proof.
move=>d from this i C [tag m] H1 I F D/= _ Et G.
subst tag.
have Vl := cohVl C.
have Vs := cohVs C.

case Hinternal: (internal_msg cn pts prep_req from this); first last.
- move /negbT in Hinternal.
  rewrite (rp_step_external _ _ _ F)//.
  by apply /(invE_consume_external C F)=>//.

rewrite /rp_step/pstep_recv.
case PS: (getStP Hnin C H1) => [round ps].
have Hthis := (internal_msg_tagFromCoordinator_to_pts Hinternal erefl).
rewrite Hthis.
have Hfrom := (internal_msg_tagFromCoordinator_from_cn Hinternal erefl).
rewrite Hfrom/=. move/eqP in Hfrom. subst from.

move: (fun H => abort_req_cn_inv H Hthis F I) => /(_ erefl) [r][lg][nd] PT.
move: (fun H => PhaseTwoAbort_req_round H Hthis F PT) => /(_ erefl) [ps'] PS'.
move: PS.
rewrite (getStP_K Hnin C H1 Hthis PS').
case=> ? ?. subst.
move: (PhaseTwoAbort_round_cn PT)=>[cs] CS.
move /(getStC_K C) in CS.
have Hround := (inv_msg_round F Hinternal I CS).
rewrite Hround/= !orbF.

have Hmatch := (p_matches_tag_internal_inv C Hthis F Hinternal PS' I).
rewrite Hmatch /=.

move: Hmatch. rewrite /p_matches_tag.
exists round, lg.
constructor 3.
exists nd.
move: PT=>[].
- move=>[sent][] CS' U S Pts.
  constructor 2. exists sent.
  split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case: ifP => _ H.
    * case E: (pt == this).
      -- move /eqP in E. subst pt.
         case/(abort_req_pt_inv F): H=>PS'' M NM.
         pose proof C as C'.
         move: C'=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
         constructor 2.
         split.
         ++ rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
            move: Hmatch. destruct ps=>//;
            (case: PS''=>PS'';
            move: (pt_state_functional V PS' PS'')=>[]); try discriminate;
            by move => [] ? ?; subst.
         ++ by apply /(msg_spec_consume _ F M).
         ++ by apply /no_msg_from_to_consume.
      -- move /negbT in E.
         apply /(pt_PhaseTwoAbortE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
    * move: H => [b] H.
      exists b.
      case E: (pt == this).
      -- move/eqP in E. subst pt.
         case: H => NM1 NM2 PS.
         by move: (NM1 _ _ _ F).
      -- move/negbT in E.
         by apply /(pt_PhaseOneRespondedE_consume _ _ C)=>//.

- move=>[recvd][] CS' U S Pts.
  constructor 4. exists recvd.
  split=>//.
  + apply/(cn_state_consume _ _ _ C)=>//.
    by apply /eqP/nesym/eqP/(pt_not_cn Hnin).
  + move=>pt Hpt.
    move: (Pts _ Hpt).
    case: ifP => _ H.
    * case E: (pt == this).
      -- move/eqP in E. subst pt.
         case: H => PS NM1 NM2.
         by move: (NM1 _ _ _ F).
      -- move/negbT in E.
         by apply /(pt_PhaseTwoRespondedE_consume _ _ C).
    * case E: (pt == this).
      -- move /eqP in E. subst pt.
         case/(abort_req_pt_inv F): H=>PS'' M NM.
         pose proof C as C'.
         move: C'=>[] _ _ _ /(_ _ (pts_in cn others Hpt)) [] V _.
         constructor 2.
         split.
         ++ rewrite/ pt_state locE'// (getStL_Kp C H1 PS').
            move: Hmatch. destruct ps=>//;
            (case: PS''=>PS'';
            move: (pt_state_functional V PS' PS'')=>[]); try discriminate;
            by move => [] ? ?; subst.
         ++ by apply /(msg_spec_consume _ F M).
         ++ by apply /no_msg_from_to_consume.
      -- move /negbT in E.
         apply /(pt_PhaseTwoAbortE_consume _ C _ _ F)=>//.
         by apply: (pt_not_cn Hnin).
Qed.

Definition sts' := [:: SI s1; SI s2; SI s3; SI s4; SI s5; SI s6; SI s7].
Definition rts' := [:: RI r1; RI r2; RI r3; RI r4; RI r5; RI r6; RI r7].

Program Definition ii := @ProtocolWithInvariant.II _ _ sts' rts' _ _.

Definition tpc_with_inv := ProtocolWithIndInv ii.

End TwoPhaseInductiveProof.
