

Require Import nat_trees.
(* nat_trees:
Global Set Asymmetric Patterns.
Require Export Peano_dec.

Inductive nat_tree : Set :=
  | NIL : nat_tree
  | bin : nat -> nat_tree -> nat_tree -> nat_tree.

Inductive binp : nat_tree -> Prop :=
    binp_intro : forall (n : nat) (t1 t2 : nat_tree), binp (bin n t1 t2).

Hint Resolve binp_intro: searchtrees.

Lemma NIL_not_bin : ~ binp NIL.
Hint Resolve NIL_not_bin: searchtrees.

Lemma diff_nil_bin : forall (n : nat) (t1 t2 : nat_tree), bin n t1 t2 <> NIL.

Hint Resolve diff_nil_bin: searchtrees.

Inductive occ : nat_tree -> nat -> Prop :=
  | occ_root : forall (n : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) n
  | occ_l :
      forall (n p : nat) (t1 t2 : nat_tree), occ t1 p -> occ (bin n t1 t2) p
  | occ_r :
      forall (n p : nat) (t1 t2 : nat_tree), occ t2 p -> occ (bin n t1 t2) p.

Hint Resolve occ_root occ_l occ_r: searchtrees.

Definition member (n : nat) (t : nat_tree) := occ t n.

Derive Inversion_clear OCC_INV with
 (forall (n p : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) p).

Lemma occ_inv :
 forall (n p : nat) (t1 t2 : nat_tree),
 occ (bin n t1 t2) p -> n = p \/ occ t1 p \/ occ t2 p.

Hint Resolve occ_inv: searchtrees.

Lemma not_occ_nil : forall p : nat, ~ occ NIL p.

Hint Resolve not_occ_nil: searchtrees. *)

Require Import search_trees.
(* search_trees:
Require Export nat_trees.
Require Import Lt.

Inductive min (p : nat) (t : nat_tree) : Prop :=
    min_intro : (forall q : nat, occ t q -> p < q) -> min p t.

Hint Resolve min_intro: searchtrees.

Inductive maj (p : nat) (t : nat_tree) : Prop :=
    maj_intro : (forall q : nat, occ t q -> q < p) -> maj p t.

Hint Resolve maj_intro: searchtrees.

Inductive search : nat_tree -> Prop :=
  | nil_search : search NIL
  | bin_search :
      forall (n : nat) (t1 t2 : nat_tree),
      search t1 -> search t2 -> maj n t1 -> min n t2 -> search (bin n t1 t2).

Hint Resolve nil_search bin_search: searchtrees.

Lemma min_nil : forall p : nat, min p NIL.

Hint Resolve min_nil: searchtrees.

Lemma maj_nil : forall p : nat, maj p NIL.

Hint Resolve maj_nil: searchtrees.

Lemma maj_not_occ : forall (p : nat) (t : nat_tree), maj p t -> ~ occ t p.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (p : nat) (t : nat_tree), min p t -> ~ occ t p.

Hint Resolve min_not_occ: searchtrees.
 
Section search_tree_basic_properties.

     Variable n : nat.
     Variable t1 t2 : nat_tree.
     Hypothesis se : search (bin n t1 t2).

     Lemma search_l : search t1.

     Hint Resolve search_l: searchtrees.

    Lemma search_r : search t2.
     Hint Resolve search_r: searchtrees.

     Lemma maj_l : maj n t1.
     Hint Resolve maj_l: searchtrees.

     Lemma min_r : min n t2.
     Hint Resolve min_r: searchtrees.

     Lemma not_right : forall p : nat, p <= n -> ~ occ t2 p.
     Hint Resolve not_right: searchtrees.
 
     Lemma not_left : forall p : nat, n <= p -> ~ occ t1 p.
     Hint Resolve not_left: searchtrees.

     Lemma go_left : forall p : nat, occ (bin n t1 t2) p -> p < n -> occ t1 p.

     Lemma go_right :
      forall p : nat, occ (bin n t1 t2) p -> n < p -> occ t2 p.

     Lemma search_inv :
      forall P : Prop,
      (search t1 -> search t2 -> maj n t1 -> min n t2 -> P) -> P.

End search_tree_basic_properties. *)

Require Import Arith.



Inductive RMAX (t t' : nat_tree) (n : nat) : Prop :=

    rmax_intro :

      occ t n ->

      (forall p : nat, occ t p -> p <= n) ->

      (forall q : nat, occ t' q -> occ t q) ->

      (forall q : nat, occ t q -> occ t' q \/ n = q) ->

      ~ occ t' n -> search t' -> RMAX t t' n.



Hint Resolve rmax_intro: searchtrees.



Lemma rmax_nil_nil : forall n : nat, RMAX (bin n NIL NIL) NIL n.



Proof.

 intro n; split; auto with searchtrees arith.

 intros p H; inversion_clear H; auto with searchtrees arith.

 absurd (occ NIL p); auto with searchtrees arith.

 absurd (occ NIL p); auto with searchtrees arith.

 intros q H; inversion_clear H; auto with searchtrees arith.

Defined.



Lemma rmax_t_NIL :

 forall (t : nat_tree) (n : nat),

 search (bin n t NIL) -> RMAX (bin n t NIL) t n.



Proof.

 intros t n H; split; auto with searchtrees arith. 

 intros p H0.

 elim (occ_inv n p t NIL H0); intro H1.

 elim H1; auto with searchtrees arith. 

 elim H1; intro H2.

 apply lt_le_weak. 

 elim (maj_l n t NIL H); auto with searchtrees arith.

 absurd (occ NIL p); auto with searchtrees arith.

 intros q H1; elim (occ_inv n q t NIL H1); intros; auto with searchtrees arith.

 elim H0.

 auto with searchtrees arith.

 intro H'; absurd (occ NIL q); auto with searchtrees arith.

 apply not_left with n NIL; auto with searchtrees arith.

 apply search_l with n NIL; auto with searchtrees arith.

Defined.



Hint Resolve rmax_t_NIL: searchtrees.



Section RMAX_np.

     Variable n p q : nat.

     Variable t1 t2 t3 t' : nat_tree.

     Hypothesis S1 : search (bin n t1 (bin p t2 t3)).

     Hypothesis R1 : RMAX (bin p t2 t3) t' q.

     Hint Resolve S1 R1: searchtrees.

     

     Remark rmax_1 : occ (bin n t1 (bin p t2 t3)) q.

     

     Proof.

      elim R1; auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_1: searchtrees.



     Remark rmax_2 : n < p.

     

     Proof.

      elim (min_r _ _ _ S1); auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_2: searchtrees.

     

     Remark rmax_3 : min n t'. 

     

     Proof.

      apply min_intro.

      intros q' H.

      elim R1; intros.

      elim (min_r _ _ _ S1); auto with searchtrees arith.

     Qed.

     Hint Resolve rmax_3: searchtrees.

     

     Remark rmax_4 : search (bin n t1 t').

     

     Proof.

      apply bin_search.

      apply search_l with n (bin p t2 t3); auto with searchtrees arith. 

      elim R1; auto with searchtrees arith.

      apply maj_l with (bin p t2 t3); auto with searchtrees arith.

      auto with searchtrees arith.

     Qed. 



     Hint Resolve rmax_4: searchtrees.

     

     Remark rmax_5 : n < q.

     

     Proof.

      elim R1; intros; apply lt_le_trans with p; auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_5: searchtrees.



     Remark rmax_6 :

      forall p0 : nat, occ (bin n t1 (bin p t2 t3)) p0 -> p0 <= q.

     

     Proof.

      intros p0 H.

      elim R1.

      intros H0 H1 H2 H3 H4 H5.

      elim (occ_inv _ _ _ _ H); intro H6.

      elim H6; auto with searchtrees arith.

      elim H6; intro H7.

      elim (maj_l _ _ _ S1). 

      intro H8.

      cut (p0 < n); auto with searchtrees arith.

      intro; apply lt_le_weak.

      apply lt_trans with n; auto with searchtrees arith.

      elim (min_r _ _ _ S1); auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_6: searchtrees.

     

     Remark rmax_7 :

      forall q' : nat,

      occ (bin n t1 t') q' -> occ (bin n t1 (bin p t2 t3)) q'.

     

     Proof.

      intros q' H; elim (occ_inv _ _ _ _ H); intro H0.

      elim H0; auto with searchtrees arith.

      elim H0; auto with searchtrees arith. 

      intro H1; elim R1; auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_7: searchtrees.

     

     Remark rmax_8 : ~ occ (bin n t1 t') q.

     

     Proof.

      unfold not in |- *; intro F.

      elim (occ_inv _ _ _ _ F).

      intro eg; absurd (n < q); auto with searchtrees arith.

      elim eg; auto with searchtrees arith.

      simple induction 1; intro H1.

      absurd (occ t1 q); auto with searchtrees arith. 

      apply not_left with n (bin p t2 t3); auto with searchtrees arith.

      elim R1; auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_8: searchtrees.



     Remark rmax_9 :

      forall q0 : nat,

      occ (bin n t1 (bin p t2 t3)) q0 -> occ (bin n t1 t') q0 \/ q = q0.

     

     Proof.

      intros q0 H.

      elim (occ_inv _ _ _ _ H).

      simple induction 1; left; auto with searchtrees arith.

      simple induction 1; intro H'.

      left; auto with searchtrees arith.

      elim R1; intros H1 H2 H3 H4 H5 H6.

      elim (H4 _ H'); auto with searchtrees arith.

     Qed.



     Hint Resolve rmax_9: searchtrees.



     Lemma rmax_t1_t2t3 : RMAX (bin n t1 (bin p t2 t3)) (bin n t1 t') q.

     

     Proof.

      apply rmax_intro; auto with searchtrees arith.

     Qed.



End RMAX_np.



Hint Resolve rmax_t1_t2t3: searchtrees.



Lemma rmax :

 forall t : nat_tree,

 search t -> binp t -> {q : nat &  {t' : nat_tree | RMAX t t' q}}.



Proof.



simple induction t;

 [ intros s b; exists 0; exists NIL

 | intros n t1 hr1 t2; case t2;

    [ intros hr2 s b; exists n; exists t1

    | intros n' t1' t2' hr2 s b; elim hr2;

       [ intros num ex; elim ex; intros tr htr; exists num;

          exists (bin n t1 tr)

       | idtac

       | idtac ] ] ]; auto with searchtrees arith.

absurd (binp NIL); auto with searchtrees arith.

eapply search_r; eauto with searchtrees arith.



Defined.

