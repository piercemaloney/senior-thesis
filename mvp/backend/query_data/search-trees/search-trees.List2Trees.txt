

Set Nested Proofs Allowed.

Require Import nat_trees.
(* nat_trees:
Global Set Asymmetric Patterns.
Require Export Peano_dec.

Inductive nat_tree : Set :=
  | NIL : nat_tree
  | bin : nat -> nat_tree -> nat_tree -> nat_tree.

Inductive binp : nat_tree -> Prop :=
    binp_intro : forall (n : nat) (t1 t2 : nat_tree), binp (bin n t1 t2).

Hint Resolve binp_intro: searchtrees.

Lemma NIL_not_bin : ~ binp NIL.
Hint Resolve NIL_not_bin: searchtrees.

Lemma diff_nil_bin : forall (n : nat) (t1 t2 : nat_tree), bin n t1 t2 <> NIL.

Hint Resolve diff_nil_bin: searchtrees.

Inductive occ : nat_tree -> nat -> Prop :=
  | occ_root : forall (n : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) n
  | occ_l :
      forall (n p : nat) (t1 t2 : nat_tree), occ t1 p -> occ (bin n t1 t2) p
  | occ_r :
      forall (n p : nat) (t1 t2 : nat_tree), occ t2 p -> occ (bin n t1 t2) p.

Hint Resolve occ_root occ_l occ_r: searchtrees.

Definition member (n : nat) (t : nat_tree) := occ t n.

Derive Inversion_clear OCC_INV with
 (forall (n p : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) p).

Lemma occ_inv :
 forall (n p : nat) (t1 t2 : nat_tree),
 occ (bin n t1 t2) p -> n = p \/ occ t1 p \/ occ t2 p.

Hint Resolve occ_inv: searchtrees.

Lemma not_occ_nil : forall p : nat, ~ occ NIL p.

Hint Resolve not_occ_nil: searchtrees. *)

Require Import More_on_Lists.
(* More_on_Lists:
Require Export List.

Hint Resolve in_nil: searchtrees.

Hint Resolve in_inv: searchtrees. *)

Require Import search_trees.
(* search_trees:
Require Export nat_trees.
Require Import Lt.

Inductive min (p : nat) (t : nat_tree) : Prop :=
    min_intro : (forall q : nat, occ t q -> p < q) -> min p t.

Hint Resolve min_intro: searchtrees.

Inductive maj (p : nat) (t : nat_tree) : Prop :=
    maj_intro : (forall q : nat, occ t q -> q < p) -> maj p t.

Hint Resolve maj_intro: searchtrees.

Inductive search : nat_tree -> Prop :=
  | nil_search : search NIL
  | bin_search :
      forall (n : nat) (t1 t2 : nat_tree),
      search t1 -> search t2 -> maj n t1 -> min n t2 -> search (bin n t1 t2).

Hint Resolve nil_search bin_search: searchtrees.

Lemma min_nil : forall p : nat, min p NIL.

Hint Resolve min_nil: searchtrees.

Lemma maj_nil : forall p : nat, maj p NIL.

Hint Resolve maj_nil: searchtrees.

Lemma maj_not_occ : forall (p : nat) (t : nat_tree), maj p t -> ~ occ t p.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (p : nat) (t : nat_tree), min p t -> ~ occ t p.

Hint Resolve min_not_occ: searchtrees.
 
Section search_tree_basic_properties.

     Variable n : nat.
     Variable t1 t2 : nat_tree.
     Hypothesis se : search (bin n t1 t2).

     Lemma search_l : search t1.

     Hint Resolve search_l: searchtrees.

    Lemma search_r : search t2.
     Hint Resolve search_r: searchtrees.

     Lemma maj_l : maj n t1.
     Hint Resolve maj_l: searchtrees.

     Lemma min_r : min n t2.
     Hint Resolve min_r: searchtrees.

     Lemma not_right : forall p : nat, p <= n -> ~ occ t2 p.
     Hint Resolve not_right: searchtrees.
 
     Lemma not_left : forall p : nat, n <= p -> ~ occ t1 p.
     Hint Resolve not_left: searchtrees.

     Lemma go_left : forall p : nat, occ (bin n t1 t2) p -> p < n -> occ t1 p.

     Lemma go_right :
      forall p : nat, occ (bin n t1 t2) p -> n < p -> occ t2 p.

     Lemma search_inv :
      forall P : Prop,
      (search t1 -> search t2 -> maj n t1 -> min n t2 -> P) -> P.

End search_tree_basic_properties. *)

Require Import Adding.
(* Adding:
Require Import nat_trees.
Require Import search_trees.
Require Import Compare_dec.

Inductive INSERT (n : nat) (t t' : nat_tree) : Prop :=
    insert_intro :
      (forall p : nat, occ t p -> occ t' p) ->
      occ t' n ->
      (forall p : nat, occ t' p -> occ t p \/ n = p) ->
      search t' -> INSERT n t t'.

Hint Resolve insert_intro: searchtrees.

Definition INSERT_SPEC (n : nat) (t : nat_tree) :=
  {t' : nat_tree | INSERT n t t'}.

Lemma insert_nil : forall n : nat, INSERT n NIL (bin n NIL NIL).
Hint Resolve insert_nil: searchtrees.

Lemma insert_l :
 forall (n p : nat) (t1 t'1 t2 : nat_tree),
 n < p ->
 search (bin p t1 t2) ->
 INSERT n t1 t'1 -> INSERT n (bin p t1 t2) (bin p t'1 t2).

Lemma insert_r :
 forall (n p : nat) (t1 t2 t'2 : nat_tree),
 p < n ->
 search (bin p t1 t2) ->
 INSERT n t2 t'2 -> INSERT n (bin p t1 t2) (bin p t1 t'2).

Lemma insert_eq :
 forall (n : nat) (t1 t2 : nat_tree),
 search (bin n t1 t2) -> INSERT n (bin n t1 t2) (bin n t1 t2).

Hint Resolve insert_l insert_r insert_eq: searchtrees.

Lemma insert : forall (n : nat) (t : nat_tree), search t -> INSERT_SPEC n t.
Hint Resolve insert: searchtrees. *)



Theorem list2trees :

 forall l : list nat,

 {t : nat_tree | search t /\ (forall p : nat, In p l <-> occ t p)}.



Proof.



 Lemma list2trees_aux :

  forall (l : list nat) (t : nat_tree),

  search t ->

  {t' : nat_tree |

  search t' /\ (forall p : nat, In p l \/ occ t p <-> occ t' p)}.

 Proof.

simple induction l;

 [ intros t s; exists t

 | intros hd tl hr t H; elim (insert hd t H); intros x i; elim (hr x);

    [ intros n a; exists n | idtac ] ].



  split; auto with searchtrees datatypes.

  intro p; unfold iff in |- *; split; intros H0.

  elim H0; auto with searchtrees datatypes.

  intro; absurd (In p nil); auto with searchtrees datatypes.

  auto with searchtrees datatypes.



2: elim i; auto with searchtrees datatypes.

  

  split; elim a; auto with searchtrees datatypes.

  

  intros; unfold iff in |- *; split; intros.

  elim H2; intros.

  inversion_clear H3.

  rewrite <- H4.

  elim (H1 hd); intros.

  apply H3. 

  right; elim i; auto with searchtrees datatypes.

  elim (H1 p); auto with searchtrees datatypes.

  elim (H1 p); intros.

  apply H4.

  right; elim i; auto with searchtrees datatypes.

  elim (H1 p); intros.

  elim (H4 H2); intros. 

  auto with searchtrees datatypes.

  elim i; intros.

  elim (H8 p).

  auto with searchtrees datatypes.

  simple induction 1; auto with searchtrees datatypes.

  auto with searchtrees datatypes.

 Defined.



 intros l; elim (list2trees_aux l NIL); [ intros x a; exists x | idtac ].

 

 elim a; split; [ auto with searchtrees datatypes | idtac ].

 intro p0; unfold iff in |- *; split; intros.

 elim (H0 p0); intros.

 auto with searchtrees datatypes.

 elim (H0 p0); intros. 

 elim (H3 H1); auto with searchtrees datatypes.

 intro; absurd (occ NIL p0); auto with searchtrees datatypes.

 auto with searchtrees datatypes.

Defined.



