

Require Import search_trees.
(* search_trees:
Require Export nat_trees.
Require Import Lt.

Inductive min (p : nat) (t : nat_tree) : Prop :=
    min_intro : (forall q : nat, occ t q -> p < q) -> min p t.

Hint Resolve min_intro: searchtrees.

Inductive maj (p : nat) (t : nat_tree) : Prop :=
    maj_intro : (forall q : nat, occ t q -> q < p) -> maj p t.

Hint Resolve maj_intro: searchtrees.

Inductive search : nat_tree -> Prop :=
  | nil_search : search NIL
  | bin_search :
      forall (n : nat) (t1 t2 : nat_tree),
      search t1 -> search t2 -> maj n t1 -> min n t2 -> search (bin n t1 t2).

Hint Resolve nil_search bin_search: searchtrees.

Lemma min_nil : forall p : nat, min p NIL.

Hint Resolve min_nil: searchtrees.

Lemma maj_nil : forall p : nat, maj p NIL.

Hint Resolve maj_nil: searchtrees.

Lemma maj_not_occ : forall (p : nat) (t : nat_tree), maj p t -> ~ occ t p.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (p : nat) (t : nat_tree), min p t -> ~ occ t p.

Hint Resolve min_not_occ: searchtrees.
 
Section search_tree_basic_properties.

     Variable n : nat.
     Variable t1 t2 : nat_tree.
     Hypothesis se : search (bin n t1 t2).

     Lemma search_l : search t1.

     Hint Resolve search_l: searchtrees.

    Lemma search_r : search t2.
     Hint Resolve search_r: searchtrees.

     Lemma maj_l : maj n t1.
     Hint Resolve maj_l: searchtrees.

     Lemma min_r : min n t2.
     Hint Resolve min_r: searchtrees.

     Lemma not_right : forall p : nat, p <= n -> ~ occ t2 p.
     Hint Resolve not_right: searchtrees.
 
     Lemma not_left : forall p : nat, n <= p -> ~ occ t1 p.
     Hint Resolve not_left: searchtrees.

     Lemma go_left : forall p : nat, occ (bin n t1 t2) p -> p < n -> occ t1 p.

     Lemma go_right :
      forall p : nat, occ (bin n t1 t2) p -> n < p -> occ t2 p.

     Lemma search_inv :
      forall P : Prop,
      (search t1 -> search t2 -> maj n t1 -> min n t2 -> P) -> P.

End search_tree_basic_properties. *)

Require Import Adding.
(* Adding:
Require Import nat_trees.
Require Import search_trees.
Require Import Compare_dec.

Inductive INSERT (n : nat) (t t' : nat_tree) : Prop :=
    insert_intro :
      (forall p : nat, occ t p -> occ t' p) ->
      occ t' n ->
      (forall p : nat, occ t' p -> occ t p \/ n = p) ->
      search t' -> INSERT n t t'.

Hint Resolve insert_intro: searchtrees.

Definition INSERT_SPEC (n : nat) (t : nat_tree) :=
  {t' : nat_tree | INSERT n t t'}.

Lemma insert_nil : forall n : nat, INSERT n NIL (bin n NIL NIL).
Hint Resolve insert_nil: searchtrees.

Lemma insert_l :
 forall (n p : nat) (t1 t'1 t2 : nat_tree),
 n < p ->
 search (bin p t1 t2) ->
 INSERT n t1 t'1 -> INSERT n (bin p t1 t2) (bin p t'1 t2).

Lemma insert_r :
 forall (n p : nat) (t1 t2 t'2 : nat_tree),
 p < n ->
 search (bin p t1 t2) ->
 INSERT n t2 t'2 -> INSERT n (bin p t1 t2) (bin p t1 t'2).

Lemma insert_eq :
 forall (n : nat) (t1 t2 : nat_tree),
 search (bin n t1 t2) -> INSERT n (bin n t1 t2) (bin n t1 t2).

Hint Resolve insert_l insert_r insert_eq: searchtrees.

Lemma insert : forall (n : nat) (t : nat_tree), search t -> INSERT_SPEC n t.
Hint Resolve insert: searchtrees. *)

Require Import Searching.
(* Searching:
Require Import nat_trees.
Require Import search_trees.
Require Import Compare_dec.

Theorem sch :
 forall (p : nat) (t : nat_tree), search t -> {occ t p} + {~ occ t p}. *)

Require Import DeleteMax.
(* DeleteMax:
Require Import nat_trees.
Require Import search_trees.
Require Import Arith.

Inductive RMAX (t t' : nat_tree) (n : nat) : Prop :=
    rmax_intro :
      occ t n ->
      (forall p : nat, occ t p -> p <= n) ->
      (forall q : nat, occ t' q -> occ t q) ->
      (forall q : nat, occ t q -> occ t' q \/ n = q) ->
      ~ occ t' n -> search t' -> RMAX t t' n.

Hint Resolve rmax_intro: searchtrees.

Lemma rmax_nil_nil : forall n : nat, RMAX (bin n NIL NIL) NIL n.

Lemma rmax_t_NIL :
 forall (t : nat_tree) (n : nat),
 search (bin n t NIL) -> RMAX (bin n t NIL) t n.

Hint Resolve rmax_t_NIL: searchtrees.

Section RMAX_np.
     Variable n p q : nat.
     Variable t1 t2 t3 t' : nat_tree.
     Hypothesis S1 : search (bin n t1 (bin p t2 t3)).
     Hypothesis R1 : RMAX (bin p t2 t3) t' q.
     Hint Resolve S1 R1: searchtrees.
     
     Remark rmax_1 : occ (bin n t1 (bin p t2 t3)) q.

     Hint Resolve rmax_1: searchtrees.

     Remark rmax_2 : n < p.

     Hint Resolve rmax_2: searchtrees.
     
     Remark rmax_3 : min n t'. 
     Hint Resolve rmax_3: searchtrees.
     
     Remark rmax_4 : search (bin n t1 t').

     Hint Resolve rmax_4: searchtrees.
     
     Remark rmax_5 : n < q.

     Hint Resolve rmax_5: searchtrees.

     Remark rmax_6 :
      forall p0 : nat, occ (bin n t1 (bin p t2 t3)) p0 -> p0 <= q.

     Hint Resolve rmax_6: searchtrees.
     
     Remark rmax_7 :
      forall q' : nat,
      occ (bin n t1 t') q' -> occ (bin n t1 (bin p t2 t3)) q'.

     Hint Resolve rmax_7: searchtrees.
     
     Remark rmax_8 : ~ occ (bin n t1 t') q.

     Hint Resolve rmax_8: searchtrees.

     Remark rmax_9 :
      forall q0 : nat,
      occ (bin n t1 (bin p t2 t3)) q0 -> occ (bin n t1 t') q0 \/ q = q0.

     Hint Resolve rmax_9: searchtrees.

     Lemma rmax_t1_t2t3 : RMAX (bin n t1 (bin p t2 t3)) (bin n t1 t') q.

End RMAX_np.

Hint Resolve rmax_t1_t2t3: searchtrees.

Lemma rmax :
 forall t : nat_tree,
 search t -> binp t -> {q : nat &  {t' : nat_tree | RMAX t t' q}}. *)

Require Import Deleting.
(* Deleting:
Require Import nat_trees.
Require Import search_trees.
Require Import DeleteMax.
Require Import Arith.
Require Import Compare_dec.

Inductive RM (n : nat) (t t' : nat_tree) : Prop :=
    rm_intro :
      ~ occ t' n ->
      (forall p : nat, occ t' p -> occ t p) ->
      (forall p : nat, occ t p -> occ t' p \/ n = p) ->
      search t' -> RM n t t'.

Hint Resolve rm_intro: searchtrees.

Remark RM_0 : forall n : nat, RM n NIL NIL.

Hint Resolve RM_0: searchtrees.

Remark RM_1 : forall n : nat, RM n (bin n NIL NIL) NIL.

Hint Resolve RM_1: searchtrees.

Remark rm_left :
 forall (n p : nat) (t1 t2 t' : nat_tree),
 p < n ->
 search (bin n t1 t2) -> RM p t1 t' -> RM p (bin n t1 t2) (bin n t' t2).

Hint Resolve rm_left: searchtrees.

Remark rm_right :
 forall (n p : nat) (t1 t2 t' : nat_tree),
 n < p ->
 search (bin n t1 t2) -> RM p t2 t' -> RM p (bin n t1 t2) (bin n t1 t').

Hint Resolve rm_right: searchtrees.

Remark rm_NILt :
 forall (n : nat) (t : nat_tree),
 search (bin n NIL t) -> RM n (bin n NIL t) t.

Hint Resolve rm_NILt: searchtrees.

Section rm_root.
     Variable n p : nat.
     Variable t1 t2 t' : nat_tree.
     Hypothesis S : search (bin n (bin p t1 t2) t').
     Variable q : nat.
     Variable t0 : nat_tree.
     Hypothesis R : RMAX (bin p t1 t2) t0 q.
     Hint Resolve S: searchtrees.
     
     Remark rm_2 : q < n.

     Hint Resolve rm_2: searchtrees.
     
     Remark rm_3 : ~ occ (bin q t0 t') n.

     Hint Resolve rm_3: searchtrees.
     
     Remark rm_4 :
      forall p0 : nat,
      occ (bin q t0 t') p0 -> occ (bin n (bin p t1 t2) t') p0.

     Hint Resolve rm_4: searchtrees.
     
     Remark rm_5 :
      forall p0 : nat,
      occ (bin n (bin p t1 t2) t') p0 -> occ (bin q t0 t') p0 \/ n = p0.

     Hint Resolve rm_5: searchtrees.
     
     Remark rm_6 : search (bin q t0 t').

     Hint Resolve rm_6: searchtrees.
     
     Lemma rm_root_lemma : RM n (bin n (bin p t1 t2) t') (bin q t0 t').
     
End rm_root.

Theorem rm :
 forall (n : nat) (t : nat_tree), search t -> {t' : nat_tree | RM n t t'}. *)

Require Import List2Trees.
(* List2Trees:
Set Nested Proofs Allowed.
Require Import nat_trees.
Require Import More_on_Lists.
Require Import search_trees.
Require Import Adding.

Theorem list2trees :
 forall l : list nat,
 {t : nat_tree | search t /\ (forall p : nat, In p l <-> occ t p)}.

Proof.

 Lemma list2trees_aux :
  forall (l : list nat) (t : nat_tree),
  search t ->
  {t' : nat_tree |
  search t' /\ (forall p : nat, In p l \/ occ t p <-> occ t' p)}. *)

Require Extraction.



Extraction "searchtrees.ml" insert sch rmax rm list2trees list2trees_aux.

                               

