
Require Import nat_trees.
(* nat_trees:
Global Set Asymmetric Patterns.
Require Export Peano_dec.

Inductive nat_tree : Set :=
  | NIL : nat_tree
  | bin : nat -> nat_tree -> nat_tree -> nat_tree.

Inductive binp : nat_tree -> Prop :=
    binp_intro : forall (n : nat) (t1 t2 : nat_tree), binp (bin n t1 t2).

Hint Resolve binp_intro: searchtrees.

Lemma NIL_not_bin : ~ binp NIL.
Hint Resolve NIL_not_bin: searchtrees.

Lemma diff_nil_bin : forall (n : nat) (t1 t2 : nat_tree), bin n t1 t2 <> NIL.

Hint Resolve diff_nil_bin: searchtrees.

Inductive occ : nat_tree -> nat -> Prop :=
  | occ_root : forall (n : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) n
  | occ_l :
      forall (n p : nat) (t1 t2 : nat_tree), occ t1 p -> occ (bin n t1 t2) p
  | occ_r :
      forall (n p : nat) (t1 t2 : nat_tree), occ t2 p -> occ (bin n t1 t2) p.

Hint Resolve occ_root occ_l occ_r: searchtrees.

Definition member (n : nat) (t : nat_tree) := occ t n.

Derive Inversion_clear OCC_INV with
 (forall (n p : nat) (t1 t2 : nat_tree), occ (bin n t1 t2) p).

Lemma occ_inv :
 forall (n p : nat) (t1 t2 : nat_tree),
 occ (bin n t1 t2) p -> n = p \/ occ t1 p \/ occ t2 p.

Hint Resolve occ_inv: searchtrees.

Lemma not_occ_nil : forall p : nat, ~ occ NIL p.

Hint Resolve not_occ_nil: searchtrees. *)
Require Import search_trees.
(* search_trees:
Require Export nat_trees.
Require Import Lt.

Inductive min (p : nat) (t : nat_tree) : Prop :=
    min_intro : (forall q : nat, occ t q -> p < q) -> min p t.

Hint Resolve min_intro: searchtrees.

Inductive maj (p : nat) (t : nat_tree) : Prop :=
    maj_intro : (forall q : nat, occ t q -> q < p) -> maj p t.

Hint Resolve maj_intro: searchtrees.

Inductive search : nat_tree -> Prop :=
  | nil_search : search NIL
  | bin_search :
      forall (n : nat) (t1 t2 : nat_tree),
      search t1 -> search t2 -> maj n t1 -> min n t2 -> search (bin n t1 t2).

Hint Resolve nil_search bin_search: searchtrees.

Lemma min_nil : forall p : nat, min p NIL.

Hint Resolve min_nil: searchtrees.

Lemma maj_nil : forall p : nat, maj p NIL.

Hint Resolve maj_nil: searchtrees.

Lemma maj_not_occ : forall (p : nat) (t : nat_tree), maj p t -> ~ occ t p.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (p : nat) (t : nat_tree), min p t -> ~ occ t p.

Hint Resolve min_not_occ: searchtrees.
 
Section search_tree_basic_properties.

     Variable n : nat.
     Variable t1 t2 : nat_tree.
     Hypothesis se : search (bin n t1 t2).

     Lemma search_l : search t1.

     Hint Resolve search_l: searchtrees.

    Lemma search_r : search t2.
     Hint Resolve search_r: searchtrees.

     Lemma maj_l : maj n t1.
     Hint Resolve maj_l: searchtrees.

     Lemma min_r : min n t2.
     Hint Resolve min_r: searchtrees.

     Lemma not_right : forall p : nat, p <= n -> ~ occ t2 p.
     Hint Resolve not_right: searchtrees.
 
     Lemma not_left : forall p : nat, n <= p -> ~ occ t1 p.
     Hint Resolve not_left: searchtrees.

     Lemma go_left : forall p : nat, occ (bin n t1 t2) p -> p < n -> occ t1 p.

     Lemma go_right :
      forall p : nat, occ (bin n t1 t2) p -> n < p -> occ t2 p.

     Lemma search_inv :
      forall P : Prop,
      (search t1 -> search t2 -> maj n t1 -> min n t2 -> P) -> P.

End search_tree_basic_properties. *)
Require Import DeleteMax.
(* DeleteMax:
Require Import nat_trees.
Require Import search_trees.
Require Import Arith.

Inductive RMAX (t t' : nat_tree) (n : nat) : Prop :=
    rmax_intro :
      occ t n ->
      (forall p : nat, occ t p -> p <= n) ->
      (forall q : nat, occ t' q -> occ t q) ->
      (forall q : nat, occ t q -> occ t' q \/ n = q) ->
      ~ occ t' n -> search t' -> RMAX t t' n.

Hint Resolve rmax_intro: searchtrees.

Lemma rmax_nil_nil : forall n : nat, RMAX (bin n NIL NIL) NIL n.

Lemma rmax_t_NIL :
 forall (t : nat_tree) (n : nat),
 search (bin n t NIL) -> RMAX (bin n t NIL) t n.

Hint Resolve rmax_t_NIL: searchtrees.

Section RMAX_np.
     Variable n p q : nat.
     Variable t1 t2 t3 t' : nat_tree.
     Hypothesis S1 : search (bin n t1 (bin p t2 t3)).
     Hypothesis R1 : RMAX (bin p t2 t3) t' q.
     Hint Resolve S1 R1: searchtrees.
     
     Remark rmax_1 : occ (bin n t1 (bin p t2 t3)) q.

     Hint Resolve rmax_1: searchtrees.

     Remark rmax_2 : n < p.

     Hint Resolve rmax_2: searchtrees.
     
     Remark rmax_3 : min n t'. 
     Hint Resolve rmax_3: searchtrees.
     
     Remark rmax_4 : search (bin n t1 t').

     Hint Resolve rmax_4: searchtrees.
     
     Remark rmax_5 : n < q.

     Hint Resolve rmax_5: searchtrees.

     Remark rmax_6 :
      forall p0 : nat, occ (bin n t1 (bin p t2 t3)) p0 -> p0 <= q.

     Hint Resolve rmax_6: searchtrees.
     
     Remark rmax_7 :
      forall q' : nat,
      occ (bin n t1 t') q' -> occ (bin n t1 (bin p t2 t3)) q'.

     Hint Resolve rmax_7: searchtrees.
     
     Remark rmax_8 : ~ occ (bin n t1 t') q.

     Hint Resolve rmax_8: searchtrees.

     Remark rmax_9 :
      forall q0 : nat,
      occ (bin n t1 (bin p t2 t3)) q0 -> occ (bin n t1 t') q0 \/ q = q0.

     Hint Resolve rmax_9: searchtrees.

     Lemma rmax_t1_t2t3 : RMAX (bin n t1 (bin p t2 t3)) (bin n t1 t') q.

End RMAX_np.

Hint Resolve rmax_t1_t2t3: searchtrees.

Lemma rmax :
 forall t : nat_tree,
 search t -> binp t -> {q : nat &  {t' : nat_tree | RMAX t t' q}}. *)
Require Import Arith.
Require Import Compare_dec.

Inductive RM (n : nat) (t t' : nat_tree) : Prop :=
    rm_intro :
      ~ occ t' n ->
      (forall p : nat, occ t' p -> occ t p) ->
      (forall p : nat, occ t p -> occ t' p \/ n = p) ->
      search t' -> RM n t t'.

Hint Resolve rm_intro: searchtrees.

Remark RM_0 : forall n : nat, RM n NIL NIL.

Proof.
intro n; apply rm_intro; auto with searchtrees arith.
Defined.

Hint Resolve RM_0: searchtrees.

Remark RM_1 : forall n : nat, RM n (bin n NIL NIL) NIL.

Proof.
intros; apply rm_intro; auto with searchtrees arith.
intros p H; elim (occ_inv n _ _ _ H); auto with searchtrees arith.
tauto.
Defined.

Hint Resolve RM_1: searchtrees.

Remark rm_left :
 forall (n p : nat) (t1 t2 t' : nat_tree),
 p < n ->
 search (bin n t1 t2) -> RM p t1 t' -> RM p (bin n t1 t2) (bin n t' t2).

Proof.
intros n p t1 t2 t' H H0 H1.
apply rm_intro. unfold not in |- *; intro H2.
elim (occ_inv n p t' t2).
intro eg; absurd (p < p); auto with searchtrees arith.
pattern p at 2 in |- *; elim eg; auto with searchtrees arith.
intro D; elim D; intro H3. 
elim H1; auto with searchtrees arith.
absurd (occ t2 p); auto with searchtrees arith.
apply not_right with n t1; auto with searchtrees arith.
auto with searchtrees arith.
intros p0 H2.
elim (occ_inv n p0 t' t2).
simple induction 1; auto with searchtrees arith.
simple induction 1; auto with searchtrees arith.
intro; elim H1; auto with searchtrees arith.
auto with searchtrees arith.
intros.
elim (occ_inv n p0 t1 t2).
simple induction 1; auto with searchtrees arith.
simple induction 1; intro H4.
elim H1.
intros H5 H6 H7 H8.
elim (H7 p0 H4); auto with searchtrees arith.
auto with searchtrees arith.
auto with searchtrees arith.
apply bin_search.
elim H1; auto with searchtrees arith.
apply search_r with n t1; auto with searchtrees arith.
apply maj_intro; intros q H2.
cut (occ t1 q).
intro; elim (maj_l n t1 t2 H0); intros; auto with searchtrees arith.
auto with searchtrees arith.
elim H1; auto with searchtrees arith.
apply min_r with t1; auto with searchtrees arith.
Defined.

Hint Resolve rm_left: searchtrees.

Remark rm_right :
 forall (n p : nat) (t1 t2 t' : nat_tree),
 n < p ->
 search (bin n t1 t2) -> RM p t2 t' -> RM p (bin n t1 t2) (bin n t1 t').

Proof.
intros n p t1 t2 t' H H0 H1.
apply rm_intro.
unfold not in |- *; intro H2.
elim (occ_inv n p t1 t').
intro eg; absurd (p < p); auto with searchtrees arith.
pattern p at 1 in |- *; elim eg; auto with searchtrees arith.
intro D; elim D; intro H3. 
elim H1; auto with searchtrees arith.
absurd (occ t1 p).
apply not_left with n t2; auto with searchtrees arith.
auto with searchtrees arith.
elim H1; auto with searchtrees arith.
auto with searchtrees arith.
intros p0 H2.
elim (occ_inv n p0 t1 t').
simple induction 1; auto with searchtrees arith.
simple induction 1; auto with searchtrees arith.
intro; elim H1; auto with searchtrees arith.
auto with searchtrees arith.
intros.
elim (occ_inv n p0 t1 t2).
simple induction 1; auto with searchtrees arith.
simple induction 1; auto with searchtrees arith.
intro H4.
elim H1; intros H5 H6 H7 H8.
elim (H7 p0 H4); auto with searchtrees arith.
auto with searchtrees arith.
apply bin_search.
apply search_l with n t2; auto with searchtrees arith.
elim H1; auto with searchtrees arith.
apply maj_l with t2; auto with searchtrees arith.
apply min_intro; intros q H2.
cut (occ t2 q).
intro.
elim (min_r n t1 t2 H0); auto with searchtrees arith. 
elim H1; auto with searchtrees arith.
Defined.

Hint Resolve rm_right: searchtrees.

Remark rm_NILt :
 forall (n : nat) (t : nat_tree),
 search (bin n NIL t) -> RM n (bin n NIL t) t.

Proof.
intros; apply rm_intro.
apply not_right with n NIL; auto with searchtrees arith.
auto with searchtrees arith.
intros p H1; elim (occ_inv n p NIL t H1); intro H2.
right; auto with searchtrees arith.
elim H2; intro.
absurd (occ NIL p); auto with searchtrees arith.
left; auto with searchtrees arith.
apply search_r with n NIL; auto with searchtrees arith.
Defined.

Hint Resolve rm_NILt: searchtrees.

Section rm_root.
     Variable n p : nat.
     Variable t1 t2 t' : nat_tree.
     Hypothesis S : search (bin n (bin p t1 t2) t').
     Variable q : nat.
     Variable t0 : nat_tree.
     Hypothesis R : RMAX (bin p t1 t2) t0 q.
     Hint Resolve S: searchtrees.
     
     Remark rm_2 : q < n.
     
     Proof.
     elim R.
     intros.
     elim (maj_l n (bin p t1 t2) t').
     auto with searchtrees arith.
     auto with searchtrees arith.
     Qed.

     Hint Resolve rm_2: searchtrees.
     
     Remark rm_3 : ~ occ (bin q t0 t') n.
     
     Proof.
     unfold not in |- *; intro H.
     elim (occ_inv q n t0 t').
     intro eg; absurd (q < q); auto with searchtrees arith.
     pattern q at 2 in |- *; rewrite eg; auto with searchtrees arith.
     intro D; elim D; intro H'.
     elim R; intros H0 H1 H2 H3 H4 H5.
     absurd (occ (bin p t1 t2) n); auto with searchtrees arith.
     apply not_left with n t'; auto with searchtrees arith.
     absurd (occ t' n); auto with searchtrees arith.
     apply not_right with n (bin p t1 t2); auto with searchtrees arith.
     auto with searchtrees arith.
     Qed.

     Hint Resolve rm_3: searchtrees.
     
     Remark rm_4 :
      forall p0 : nat,
      occ (bin q t0 t') p0 -> occ (bin n (bin p t1 t2) t') p0.
     
     Proof. 
     intros p0 H.
     elim (occ_inv q p0 t0 t' H).  
     intro eg.
     elim R; rewrite eg; auto with searchtrees arith.
     simple induction 1; auto with searchtrees arith.
     intro H'. elim R; auto with searchtrees arith.
     Qed.

     Hint Resolve rm_4: searchtrees.
     
     Remark rm_5 :
      forall p0 : nat,
      occ (bin n (bin p t1 t2) t') p0 -> occ (bin q t0 t') p0 \/ n = p0.
     
     Proof.
     intros p0 H.
     elim (occ_inv n p0 (bin p t1 t2) t'). 
     simple induction 1; auto with searchtrees arith.
     simple induction 1.
     intro H1.
     elim R; intros H2 H3 H4 H5 H6 H7.
     elim (H5 p0 H1). intro; left; auto with searchtrees arith.
     simple induction 1; left; auto with searchtrees arith.
     intro; left; auto with searchtrees arith.
     auto with searchtrees arith.
     Qed.

     Hint Resolve rm_5: searchtrees.
     
     Remark rm_6 : search (bin q t0 t').
     
     Proof.
     apply bin_search.
     elim R; auto with searchtrees arith.
     apply search_r with n (bin p t1 t2); auto with searchtrees arith.
     elim R; intros H H0 H1 H2 H3 H4.
     apply maj_intro.
     intros q0 H5; elim (le_lt_or_eq q0 q (H0 q0 (H1 q0 H5))).
     auto with searchtrees arith.
     intro eg; absurd (occ t0 q0).
     rewrite eg; auto with searchtrees arith.
     auto with searchtrees arith.
     apply min_intro.
     intros q0 H. 
     apply lt_trans with n. 
     elim R; auto with searchtrees arith.
     elim (min_r n (bin p t1 t2) t'). 
     auto with searchtrees arith. 
     auto with searchtrees arith.
     Qed.

     Hint Resolve rm_6: searchtrees.
     
     Lemma rm_root_lemma : RM n (bin n (bin p t1 t2) t') (bin q t0 t').
     
     Proof.
     apply rm_intro; auto with searchtrees arith.
     Qed.
     
End rm_root.

Theorem rm :
 forall (n : nat) (t : nat_tree), search t -> {t' : nat_tree | RM n t t'}.

Proof.
 simple induction t;
  [ intros s; exists NIL
  | intros p; elim (le_gt_dec n p); intros h;
     [ elim (le_lt_eq_dec n p h); intros h';
        [ intros t1 hr1 t2 hr2 s; elim hr1;
           [ intros t3 h3; exists (bin p t3 t2) | idtac ]
        | intros t1; case t1;
           [ intros hr1 t2 hr2 s; exists t2
           | intros p' t1' t2' hr1 t2 hr2 s; elim (rmax (bin p' t1' t2'));
              [ intros q ex; elim ex; intros t' H; exists (bin q t' t2)
              | idtac
              | idtac ] ] ]
     | intros t1 hr1 t2 hr2 s; elim hr2;
        [ intros t3 h3; exists (bin p t1 t3) | idtac ] ] ];
  auto with searchtrees arith.

 eapply search_l; eauto with searchtrees arith.
 rewrite h'; apply rm_NILt; auto with searchtrees arith.
 rewrite h'; apply rm_root_lemma; auto with searchtrees arith.
 eapply search_l; eauto with searchtrees arith.
 eapply search_r; eauto with searchtrees arith.
 
Defined.

