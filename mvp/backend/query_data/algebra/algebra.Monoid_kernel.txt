
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_util.
(* Monoid_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_monoid.
Require Export Abelian_group_cat.

Section Monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.

Definition f := uncurry fcomp.

Lemma fassoc : associative f.

Lemma eunitr : unit_r f e.

Lemma eunitl : unit_l f e.

Definition sg := Build_sgroup (Build_sgroup_on fassoc).

Definition BUILD_MONOID : MONOID :=
  Build_monoid (Build_monoid_on (A:=sg) (monoid_unit:=e) eunitr eunitl).
End Monoid.
Section Abelian_monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).

Definition M := BUILD_MONOID fcomp genlawassoc eunitgenlawr eunitgenlawl.

Definition asg : abelian_sgroup.

Definition BUILD_ABELIAN_MONOID : ABELIAN_MONOID :=
  Build_abelian_monoid (Build_abelian_monoid_on (M:=M) asg).
End Abelian_monoid.
Section Hom.
Variable G G' : MONOID.
Variable ff : G -> G'.
Hypothesis ffcomp : forall x y : G, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : G,
    Equal (ff (sgroup_law _ x y)) (sgroup_law _ (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit G)) (monoid_unit G').

Definition f2 := Build_Map ffcomp.

Definition fhomsg := Build_sgroup_hom (sgroup_map:=f2) fflaw.

Definition BUILD_HOM_MONOID : Hom G G' :=
  Build_monoid_hom (monoid_sgroup_hom:=fhomsg) ffunit.
End Hom.
Section Build_sub_monoid.
Variable G : MONOID.
Variable H : part_set G.
Hypothesis
  Hlaw :
    forall x y : G,
    in_part x H -> in_part y H -> in_part (sgroup_law _ x y) H.
Hypothesis Hunit : in_part (monoid_unit G) H.

Definition BUILD_SUB_MONOID : submonoid G :=
  Build_submonoid (G:=G) (submonoid_subsgroup:=Build_subsgroup Hlaw) Hunit.
End Build_sub_monoid. *)
Require Export Parts2.
(* Parts2:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Classical_Prop.
Require Export Parts.

Comments "We define here complement of a part, image of a part by a map.".
Section Complement1.
Variable E : Setoid.

Lemma not_in_comp_l :
 forall (E : Setoid) (A : part_set E) (x y : E),
 ~ in_part x A -> Equal y x -> ~ in_part y A.

Lemma not_in_comp_r :
 forall (E : Setoid) (A B : part_set E) (x : E),
 ~ in_part x A -> Equal A B -> ~ in_part x B.

Definition compl : part_set E -> part_set E.

Lemma compl_in :
 forall (A : part_set E) (x : E), ~ in_part x A -> in_part x (compl A).
Hint Resolve compl_in: algebra.

Lemma in_compl :
 forall (A : part_set E) (x : E), in_part x (compl A) -> ~ in_part x A.

Lemma compl_comp :
 forall A B : part_set E, Equal A B -> Equal (compl A) (compl B).
Hint Resolve compl_comp: algebra.

Lemma compl_comp_rev :
 forall A B : part_set E, Equal (compl A) (compl B) -> Equal A B.

Lemma compl_compl : forall A : part_set E, Equal (compl (compl A)) A.
Hint Resolve compl_compl: algebra.

Lemma compl_not_in :
 forall (A : part_set E) (x : E), in_part x A -> ~ in_part x (compl A).
Hint Resolve compl_not_in: algebra.

Lemma not_in_compl :
 forall (A : part_set E) (x : E), in_part x (compl A) -> ~ in_part x A.

Lemma compl_included :
 forall A B : part_set E, included A B -> included (compl B) (compl A).

Lemma compl_not_compl :
 forall (A : part_set E) (x : E), in_part x A \/ in_part x (compl A).
End Complement1.
Hint Resolve compl_included compl_not_in compl_compl compl_comp compl_in:
  algebra.
Section Images1.
Variable E F : Setoid.
Variable f : MAP E F.

Definition image : part_set E -> part_set F.

Lemma image_in :
 forall (A : part_set E) (y : F),
 in_part y (image A) -> exists x : E, in_part x A /\ Equal y (f x).

Lemma in_image :
 forall (A : part_set E) (x : E) (y : F),
 in_part x A -> Equal y (f x) -> in_part y (image A).
Hint Resolve in_image: algebra.

Lemma image_included :
 forall A B : part_set E, included A B -> included (image A) (image B).
Hint Resolve image_included: algebra.

Lemma image_comp :
 forall A B : part_set E, Equal A B -> Equal (image A) (image B).
Hint Resolve image_comp: algebra.

Lemma image_in_image :
 forall (A : part_set E) (x : E), in_part x A -> in_part (f x) (image A).
Hint Resolve image_in_image: algebra.

Definition image_map := image (full E).

Let surj_set_image_fun : E -> image_map.

Definition surj_set_image : MAP E image_map.

Lemma surj_set_image_surjective : surjective surj_set_image.

Let surj_part_image_fun : forall A : part_set E, A -> image A.

Definition surj_part_image : forall A : part_set E, MAP A (image A).

Lemma surj_part_image_surjective :
 forall A : part_set E, surjective (surj_part_image A).
End Images1.
Hint Resolve in_image image_included image_comp image_in_image
  surj_set_image_surjective surj_part_image_surjective: algebra. *)
Section Image_hom.
Variable M M' : MONOID.
Variable f : Hom M M'.

Definition image_monoid_hom : submonoid M'.
apply (BUILD_SUB_MONOID (G:=M') (H:=image_map f)).
simpl in |- *.
intros x y H' H'0; try assumption.
elim H'0; intros x0 E; elim E; intros H'1 H'2; try exact H'1; clear E H'0.
elim H'; intros x1 E; elim E; intros H'0 H'3; try exact H'0; clear E H'.
exists (sgroup_law M x1 x0); split; [ try assumption | idtac ].
apply
 Trans
  with
    (sgroup_law M' (Ap (sgroup_map (monoid_sgroup_hom f)) x1)
       (Ap (sgroup_map (monoid_sgroup_hom f)) x0)); 
 auto with algebra.
simpl in |- *.
exists (monoid_unit M); split; [ try assumption | idtac ].
auto with algebra.
auto with algebra.
Defined.

Lemma image_monoid_prop : forall x : M, in_part (f x) image_monoid_hom.
simpl in |- *.
intros x; exists x; split; [ try assumption | idtac ]; auto with algebra.
Qed.

Lemma image_monoid_prop_rev :
 forall y : M', in_part y image_monoid_hom -> exists x : M, Equal y (f x).
simpl in |- *.
intros y H'; try assumption.
elim H'; intros x E; elim E; intros H'0 H'1; try exact H'0; clear E H'.
exists x; try assumption.
Qed.
End Image_hom.
Hint Resolve image_monoid_prop image_monoid_prop: algebra.