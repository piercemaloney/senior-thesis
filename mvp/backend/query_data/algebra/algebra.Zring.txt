
Set Implicit Arguments.
Unset Strict Implicit.
Require Export ZArith.
Require Export ZArith.
Require Export auxiliary.
Require Export ZArith_dec.
Require Export Zmisc.
Hint Resolve Zle_refl: algebra.
Require Export Ring_util.
(* Ring_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
Require Export Monoid_util.
Require Export Ring_cat.

Section Ring.
Variable E : Setoid.
Variable ringplus : E -> E -> E.
Variable ringmult : E -> E -> E.
Variable zero : E.
Variable un : E.
Variable ringopp : E -> E.
Hypothesis
  ringpluscomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringplus x y) (ringplus x' y').
Hypothesis
  ringplusassoc :
    forall x y z : E,
    Equal (ringplus (ringplus x y) z) (ringplus x (ringplus y z)).
Hypothesis zerounitringplusr : forall x : E, Equal (ringplus x zero) x.
Hypothesis
  oppcomp : forall x y : E, Equal x y -> Equal (ringopp x) (ringopp y).
Hypothesis ringoppr : forall x : E, Equal (ringplus x (ringopp x)) zero.
Hypothesis ringpluscom : forall x y : E, Equal (ringplus x y) (ringplus y x).
Hypothesis
  ringmultcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringmult x y) (ringmult x' y').
Hypothesis
  ringmultassoc :
    forall x y z : E,
    Equal (ringmult (ringmult x y) z) (ringmult x (ringmult y z)).
Hypothesis ununitringmultr : forall x : E, Equal (ringmult x un) x.
Hypothesis ununitlringmult : forall x : E, Equal (ringmult un x) x.
Hypothesis
  ringdistl :
    forall x y z : E,
    Equal (ringmult x (ringplus y z))
      (ringplus (ringmult x y) (ringmult x z)).
Hypothesis
  ringdistr :
    forall x y z : E,
    Equal (ringmult (ringplus x y) z)
      (ringplus (ringmult x z) (ringmult y z)).

Definition G :=
  BUILD_ABELIAN_GROUP ringpluscomp ringplusassoc zerounitringplusr oppcomp
    ringoppr ringpluscom.

Definition M :=
  BUILD_MONOID ringmultcomp ringmultassoc ununitringmultr ununitlringmult.

Definition BUILD_RING : RING.
End Ring.
Section Hom.
Variable Ring1 Ring2 : ring.
Variable ff : Ring1 -> Ring2.
Hypothesis ffcomp : forall x y : Ring1, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  ffplus :
    forall x y : Ring1,
    Equal (ff (sgroup_law Ring1 x y)) (sgroup_law Ring2 (ff x) (ff y)).
Hypothesis ffzero : Equal (ff (monoid_unit Ring1)) (monoid_unit Ring2).
Hypothesis
  ffmult :
    forall x y : Ring1, Equal (ff (ring_mult x y)) (ring_mult (ff x) (ff y)).
Hypothesis ffone : Equal (ff (ring_unit Ring1)) (ring_unit Ring2).

Definition BUILD_HOM_RING : Hom (Ring1:RING) (Ring2:RING).
End Hom. *)
Require Export Integral_domain_facts.
(* Integral_domain_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Integral_domain_cat.
Require Export Ring_facts.
Require Export Classical_Prop.

Section Lemmas.
Variable R : INTEGRAL_DOMAIN.

Lemma INTEGRAL_DOMAIN_prop_rev :
 forall x y : R,
 ~ Equal x (monoid_unit R) ->
 ~ Equal y (monoid_unit R) -> ~ Equal (ring_mult x y) (monoid_unit R).

Lemma INTEGRAL_DOMAIN_prop :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 Equal x (monoid_unit R) \/ Equal y (monoid_unit R).

Lemma INTEGRAL_DOMAIN_mult_l :
 forall x y : R,
 ~ Equal (ring_mult x y) (monoid_unit R) -> ~ Equal x (monoid_unit R).

Lemma INTEGRAL_DOMAIN_mult_r :
 forall x y : R,
 ~ Equal (ring_mult x y) (monoid_unit R) -> ~ Equal y (monoid_unit R).

Lemma INTEGRAL_DOMAIN_mult_n0_r :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 ~ Equal y (monoid_unit R) -> Equal x (monoid_unit R).

Lemma INTEGRAL_DOMAIN_mult_n0_l :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 ~ Equal x (monoid_unit R) -> Equal y (monoid_unit R).
Hint Resolve INTEGRAL_DOMAIN_prop INTEGRAL_DOMAIN_prop_rev
  INTEGRAL_DOMAIN_mult_l INTEGRAL_DOMAIN_mult_r INTEGRAL_DOMAIN_mult_n0_l
  INTEGRAL_DOMAIN_mult_n0_r: algebra.

Lemma INTEGRAL_DOMAIN_simpl_r :
 forall x y z : R,
 ~ Equal z (monoid_unit R) ->
 Equal (ring_mult x z) (ring_mult y z) -> Equal x y.

Lemma INTEGRAL_DOMAIN_simpl_l :
 forall x y z : R,
 ~ Equal z (monoid_unit R) ->
 Equal (ring_mult z x) (ring_mult z y) -> Equal x y.

Lemma INTEGRAL_DOMAIN_mult_eq_r :
 forall x y z : R,
 Equal (ring_mult x z) (ring_mult y z) ->
 Equal x y \/ Equal z (monoid_unit R).

Lemma INTEGRAL_DOMAIN_mult_eq_l :
 forall x y z : R,
 Equal (ring_mult z x) (ring_mult z y) ->
 Equal x y \/ Equal z (monoid_unit R).
End Lemmas.
Hint Resolve INTEGRAL_DOMAIN_prop INTEGRAL_DOMAIN_prop_rev
  INTEGRAL_DOMAIN_mult_l INTEGRAL_DOMAIN_mult_r INTEGRAL_DOMAIN_mult_n0_l
  INTEGRAL_DOMAIN_mult_n0_r: algebra.
Hint Resolve INTEGRAL_DOMAIN_simpl_r INTEGRAL_DOMAIN_simpl_l: algebra. *)

Definition Zr_aux : RING.
apply
 (BUILD_RING (E:=Leibnitz_set BinInt.Z) (ringplus:=Zplus) (ringmult:=Zmult)
    (zero:=0%Z) (un:=1%Z) (ringopp:=Zopp)).
simpl in |- *.
intros x x' y y' H' H'0; try assumption.
rewrite H'0.
rewrite H'.
auto with algebra.
intros x y z; try assumption.
apply Sym.
simpl in |- *.
generalize BinInt.Zplus_assoc.
intros H'; try assumption.
rewrite (H' x y z).
auto with algebra.
simpl in |- *.
intros x; try assumption.
generalize BinInt.Zplus_0_r.
intros H'; try assumption.
rewrite (H' x); auto with algebra.
simpl in |- *.
intros x y H'; try assumption.
rewrite H'; auto with algebra.
simpl in |- *.
intros x; try assumption.
generalize BinInt.Zplus_opp_r.
intros H'; try assumption.
rewrite (H' x); auto with algebra.
simpl in |- *.
intros x y; try assumption.
generalize BinInt.Zplus_comm.
intros H'; try assumption.
rewrite (H' x y); auto with algebra.
simpl in |- *.
intros x x' y y' H' H'0; try assumption.
rewrite H'0.
rewrite H'.
auto with algebra.
simpl in |- *.
intros x y z; try assumption.
generalize BinInt.Zmult_assoc.
intros H'; try assumption.
rewrite (H' x y z); auto with algebra.
simpl in |- *.
intros x; try assumption.
generalize BinInt.Zmult_1_l.
intros H'; try assumption.
replace (x * 1)%Z with (1 * x)%Z.
rewrite (H' x); auto with algebra.
apply BinInt.Zmult_comm.
intros x; try assumption.
generalize BinInt.Zmult_1_l.
intros H'; try assumption.
rewrite (H' x); auto with algebra.
intros x y z; try assumption.
generalize BinInt.Zmult_plus_distr_r.
intros H'; try assumption.
rewrite (H' x y z); auto with algebra.
intros x y z; try assumption.
generalize BinInt.Zmult_plus_distr_l.
intros H'; try assumption.
rewrite (H' x y z); auto with algebra.
Defined.

Definition Zr : CRING.
apply (Build_cring (cring_ring:=Zr_aux)).
apply (Build_cring_on (R:=Zr_aux)).
red in |- *.
simpl in |- *.
intros x y; try assumption.
generalize BinInt.Zmult_comm.
intros H'; try assumption.
rewrite (H' x y); auto with algebra.
Defined.

Definition Zzero_dec :
  forall x : Zr, {Equal x (monoid_unit Zr)} + {~ Equal x (monoid_unit Zr)}.
simpl in |- *.
intros x; try assumption.
case (Z_eq_dec x 0).
intros H'; try assumption.
cut (x = 0%Z :>BinInt.Z).
auto with algebra.
rewrite H'.
auto with algebra.
intros H'; try assumption.
cut (x <> 0%Z :>BinInt.Z).
auto with algebra.
red in |- *.
intros H'0; try assumption.
apply H'.
rewrite H'0.
auto with algebra.
Defined.

Definition ZZ : INTEGRAL_DOMAIN.
apply (Build_idomain (idomain_ring:=Zr)).
apply Build_idomain_on.
red in |- *.
intros x y; try assumption.
simpl in |- *.
generalize (BinInt.Zmult_integral_l x y).
unfold not in |- *.
intros H' H'0 H'1 H'2; try assumption.
apply H'1.
rewrite H'.
auto with algebra.
intros H'3; try assumption.
apply H'0.
rewrite H'3.
auto with algebra.
rewrite <- H'2.
change (Equal (ring_mult y x) (ring_mult x y)) in |- *.
auto with algebra.
Defined.
