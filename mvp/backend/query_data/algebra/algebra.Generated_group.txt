
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_kernel.
(* Group_kernel:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
Require Export Group_quotient.
Require Export Parts2.

Section Def.
Variable G G' : GROUP.
Variable f : Hom G G'.

Definition kernel_part : part_set G.

Definition Ker : subgroup G.

Definition coKer : subgroup G'.

Lemma kernel_normal : normal Ker.
Set Strict Implicit.
Unset Implicit Arguments.

Definition group_quo_ker := group_quo G Ker kernel_normal.
Set Implicit Arguments.
Unset Strict Implicit.

Lemma Ker_prop : forall x : G, in_part x Ker -> Equal (f x) (monoid_unit G').

Lemma Ker_prop_rev :
 forall x : G, Equal (f x) (monoid_unit G') -> in_part x Ker.

Lemma coKer_prop : forall x : G, in_part (f x) coKer.
End Def.
Hint Resolve kernel_normal Ker_prop coKer_prop: algebra. *)
Require Export Free_group.
(* Free_group:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
Section Free_group_def.
Variable V : SET.

Inductive FG : Type :=
  | Var : V -> FG
  | Law : FG -> FG -> FG
  | Unit : FG
  | Inv : FG -> FG.

Inductive eqFG : FG -> FG -> Prop :=
  | eqFG_Var : forall x y : V, Equal x y -> (eqFG (Var x) (Var y):Prop)
  | eqFG_law :
      forall x x' y y' : FG,
      eqFG x x' -> eqFG y y' -> (eqFG (Law x y) (Law x' y'):Prop)
  | eqFG_law_assoc :
      forall x y z : FG, eqFG (Law (Law x y) z) (Law x (Law y z)):Prop
  | eqFG_law0r : forall x : FG, eqFG (Law x Unit) x:Prop
  | eqFG_inv : forall x y : FG, eqFG x y -> eqFG (Inv x) (Inv y)
  | eqFG_invr : forall x : FG, eqFG (Law x (Inv x)) Unit
  | eqFG_refl : forall x : FG, eqFG x x:Prop
  | eqFG_sym : forall x y : FG, eqFG x y -> (eqFG y x:Prop)
  | eqFG_trans : forall x y z : FG, eqFG x y -> eqFG y z -> (eqFG x z:Prop).
Hint Resolve eqFG_Var eqFG_law eqFG_law_assoc eqFG_law0r eqFG_invr eqFG_refl:
  algebra.
Hint Immediate eqFG_sym: algebra.

Lemma eqFG_Equiv : equivalence eqFG.

Definition FG_set := Build_Setoid eqFG_Equiv.

Definition FreeGroup : GROUP.
Section Universal_prop.
Variable G : GROUP.
Variable f : Hom V G.

Fixpoint FG_lift_fun (p : FreeGroup) : G :=
  match p with
  | Var v => f v
  | Law p1 p2 => sgroup_law _ (FG_lift_fun p1) (FG_lift_fun p2)
  | Unit => monoid_unit G
  | Inv p1 => group_inverse G (FG_lift_fun p1)
  end.

Definition FG_lift : Hom FreeGroup G.

Definition FG_var : Hom V FreeGroup.

Lemma FG_comp_prop :
 Equal f (comp_hom (FG_lift:Hom (FreeGroup:SET) G) FG_var).
End Universal_prop.
End Free_group_def.
Hint Resolve FG_comp_prop: algebra. *)
Section Generated_group_def.
Variable G : GROUP.
Variable A : part_set G.

Definition generated_group : subgroup G := coKer (FG_lift (inj_part A)).
End Generated_group_def.

Lemma generated_group_minimal :
 forall (G : GROUP) (A : part_set G) (H : subgroup G),
 included A H -> included (generated_group A) H.
unfold included in |- *.
simpl in |- *.
intros G A H H' x H'0; try assumption.
elim H'0; intros x0; clear H'0.
generalize x; clear x.
elim x0.
intros c; try assumption.
elim c.
simpl in |- *.
intros y subtype_prf x H'0; elim H'0; intros H'1 H'2; try exact H'2;
 clear H'0.
apply in_part_comp_l with y; auto with algebra.
intros f H'0 f0 H'1 x H'2; elim H'2; intros H'3 H'4; try exact H'4; clear H'2.
simpl in H'4.
apply
 in_part_comp_l
  with
    (sgroup_law G (FG_lift_fun (inj_part A) f) (FG_lift_fun (inj_part A) f0));
 auto with algebra.
simpl in |- *.
intros x H'0; elim H'0; intros H'1 H'2; try exact H'2; clear H'0.
apply in_part_comp_l with (monoid_unit G); auto with algebra.
intros f H'0 x H'1; try assumption.
elim H'1; intros H'2 H'3; simpl in H'3; clear H'1.
apply in_part_comp_l with (group_inverse G (FG_lift_fun (inj_part A) f));
 auto with algebra.
Qed.

Lemma generated_group_prop_included :
 forall (G : GROUP) (A : part_set G), included A (generated_group A).
unfold included in |- *.
simpl in |- *.
intros G A x H'; try assumption.
exists (Var (V:=A) (Build_subtype (E:=G) (P:=A) (subtype_elt:=x) H')); split;
 [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
auto with algebra.
Qed.

Lemma generated_group_prop :
 forall (G : GROUP) (A : part_set G) (y : G),
 in_part y (generated_group A) ->
 exists x : FG A, Equal y (FG_lift (inj_part A) x).
simpl in |- *; auto with algebra.
intros G A y H'; try assumption.
elim H'; intros x E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists x; try assumption.
Qed.

Lemma generated_group_prop_rev :
 forall (G : GROUP) (A : part_set G) (y : G),
 (exists x : FG A, Equal y (FG_lift (inj_part A) x)) ->
 in_part y (generated_group A).
intros G A y H'; try assumption.
elim H'; intros x E; try exact E; clear H'.
simpl in |- *; auto with algebra.
exists x; split; [ idtac | try assumption ].
auto with algebra.
Qed.
Hint Resolve generated_group_minimal generated_group_prop_included
  generated_group_prop_rev: algebra.
