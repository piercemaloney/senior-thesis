
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_util.
(* Module_util:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_cat.
Require Export Monoid_util.
Require Export Group_util.

Section Module.
Variable R : RING.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Variable gen_module_op : R -> E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).
Hypothesis
  op_comp :
    forall (a b : R) (x y : E),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : E),
    Equal (gen_module_op (sgroup_law R a b) x)
      (genlaw (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : E),
    Equal (gen_module_op a (genlaw x y))
      (genlaw (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : E),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis opunit : forall x : E, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el : forall a : R, Endo_SET E.

Definition module_util_op : operation (ring_monoid R) E.

Definition module_util_G : ABELIAN_GROUP.

Definition BUILD_MODULE : MODULE R.
End Module.
Section Hom.
Variable R : RING.
Variable Mod Mod' : MODULE R.
Variable ff : Mod -> Mod'.
Hypothesis ffcomp : forall x y : Mod, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : Mod,
    Equal (ff (sgroup_law Mod x y)) (sgroup_law Mod' (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit Mod)) (monoid_unit Mod').
Hypothesis
  ffop :
    forall (a : R) (x : Mod),
    Equal (ff (module_mult a x)) (module_mult a (ff x)).

Definition BUILD_HOM_MODULE : Hom Mod Mod' :=
  Build_module_hom
    (module_monoid_hom:=BUILD_HOM_GROUP (G:=Mod) (G':=Mod') (ff:=ff) ffcomp
                          fflaw ffunit) ffop.
End Hom.
Section Module_on_group.
Variable R : RING.
Variable module_util_G : ABELIAN_GROUP.
Variable gen_module_op : R -> module_util_G -> module_util_G.
Hypothesis
  op_comp :
    forall (a b : R) (x y : module_util_G),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op (sgroup_law R a b) x)
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : module_util_G),
    Equal (gen_module_op a (sgroup_law module_util_G x y))
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis
  opunit : forall x : module_util_G, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el2 : forall a : R, Endo_SET module_util_G.

Definition module_util_op2 : operation (ring_monoid R) module_util_G.

Definition BUILD_MODULE_GROUP : MODULE R.
End Module_on_group. *)
Require Export Sub_module.
(* Sub_module:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_group.
Require Export Module_facts.
Require Export Module_util.
Require Export Monoid_util.
Require Export Group_util.
Section Def.
Variable R : RING.
Variable M : MODULE R.
Section Sub_module.
Variable N : subgroup M.
Hypothesis
  Nop : forall (a : R) (x : M), in_part x N -> in_part (module_mult a x) N.

Let Na : ABELIAN_GROUP.

Let endofun : R -> Endo_SET Na.

Definition submodule_op : operation (ring_monoid R) Na.

Definition submodule_module : module R.
End Sub_module.

Record submodule : Type := 
  {submodule_subgroup : subgroup M;
   submodule_prop :
    forall (a : R) (x : M),
    in_part x submodule_subgroup ->
    in_part (module_mult a x) submodule_subgroup}.

Definition module_of_submodule (N : submodule) :=
  submodule_module (submodule_prop (s:=N)).
End Def.
Coercion module_of_submodule : submodule >-> module.
Coercion submodule_subgroup : submodule >-> subgroup.
Section Injection.
Variable R : RING.
Variable M : MODULE R.
Variable N : submodule M.

Lemma submodule_in_prop :
 forall (a : R) (x : M), in_part x N -> in_part (module_mult a x) N.

Definition inj_submodule : Hom (N:MODULE R) M.

Lemma inj_submodule_injective : injective inj_submodule.
End Injection.
Hint Resolve submodule_in_prop inj_submodule_injective: algebra. *)
Require Export Group_kernel.
(* Group_kernel:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
Require Export Group_quotient.
Require Export Parts2.

Section Def.
Variable G G' : GROUP.
Variable f : Hom G G'.

Definition kernel_part : part_set G.

Definition Ker : subgroup G.

Definition coKer : subgroup G'.

Lemma kernel_normal : normal Ker.
Set Strict Implicit.
Unset Implicit Arguments.

Definition group_quo_ker := group_quo G Ker kernel_normal.
Set Implicit Arguments.
Unset Strict Implicit.

Lemma Ker_prop : forall x : G, in_part x Ker -> Equal (f x) (monoid_unit G').

Lemma Ker_prop_rev :
 forall x : G, Equal (f x) (monoid_unit G') -> in_part x Ker.

Lemma coKer_prop : forall x : G, in_part (f x) coKer.
End Def.
Hint Resolve kernel_normal Ker_prop coKer_prop: algebra. *)

Section Def.
Variable R : RING.
Variable Mod Mod2 : MODULE R.
Variable f : Hom Mod Mod2.

Definition Ker : submodule Mod.
apply (Build_submodule (R:=R) (M:=Mod) (submodule_subgroup:=Ker f)).
simpl in |- *.
intros a x H'; try assumption.
apply Trans with (module_mult a (f x)); auto with algebra.
apply Trans with (module_mult a (monoid_unit (module_carrier Mod2)));
 auto with algebra.
Defined.

Definition coKer : submodule Mod2.
apply (Build_submodule (R:=R) (M:=Mod2) (submodule_subgroup:=coKer f)).
simpl in |- *.
intros a x H'; try assumption.
elim H'; intros x0 E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists (module_mult a x0); split; [ try assumption | idtac ].
apply Trans with (module_mult a (f x0)); auto with algebra.
Defined.

Lemma Ker_prop :
 forall x : Mod, in_part x Ker -> Equal (f x) (monoid_unit Mod2).
auto with algebra.
Qed.

Lemma Ker_prop_rev :
 forall x : Mod, Equal (f x) (monoid_unit Mod2) -> in_part x Ker.
auto with algebra.
Qed.

Lemma coKer_prop : forall x : Mod, in_part (f x) coKer.
simpl in |- *.
intros x; exists x; split; [ idtac | try assumption ]; auto with algebra.
Qed.
End Def.
Hint Resolve Ker_prop coKer_prop: algebra.
