
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.
(* Ring_cat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Abelian_group_cat.

Section Objects.

Definition dist_r (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple (g (couple x y)) z))
    (g (couple (f (couple x z)) (f (couple y z)))).

Definition dist_l (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple x (g (couple y z))))
    (g (couple (f (couple x y)) (f (couple x z)))).

Record ring_on (R : abelian_group) : Type := 
  {ring_mult_sgroup : sgroup_on R;
   ring_mult_monoid : monoid_on ring_mult_sgroup;
   ring_monoid :> monoid_on ring_mult_monoid;
   ring_dist_r_prf :
    dist_r (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R);
   ring_dist_l_prf :
    dist_l (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R)}.

Record ring : Type := 
  {ring_group :> abelian_group; ring_on_def :> ring_on ring_group}.
Coercion Build_ring : ring_on >-> ring.

Definition ring_mult (R : ring) (x y : R) : R :=
  sgroup_law_map (ring_mult_sgroup R) (couple x y).

Definition ring_unit (R : ring) : R := monoid_unit (ring_monoid R).

Record cring_on (R : ring) : Type := 
  {cring_com_prf : commutative (sgroup_law_map (ring_mult_monoid R))}.

Record cring : Type := 
  {cring_ring :> ring; cring_on_def :> cring_on cring_ring}.
Coercion Build_cring : cring_on >-> cring.

Definition cring_monoid : cring -> abelian_monoid.
End Objects.
Section Hom.
Variable E F : ring.

Definition ring_mult_hom_unit_prop (f : Map E F) :=
  Equal (f (ring_unit E)) (ring_unit F).

Definition ring_mult_hom_prop (f : Map E F) :=
  forall x y : E, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Record ring_hom : Type := 
  {ring_plus_hom :> monoid_hom E F;
   ring_mult_hom_unit : ring_mult_hom_unit_prop ring_plus_hom;
   ring_mult_hom_prf : ring_mult_hom_prop ring_plus_hom}.
End Hom.

Definition ring_hom_comp :
  forall E F G : ring, ring_hom F G -> ring_hom E F -> ring_hom E G.

Definition ring_id : forall E : ring, ring_hom E E.

Definition RING : category.

Definition CRING := full_subcat (C:=RING) (C':=cring) cring_ring. *)
Require Export Group_facts.
(* Group_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_cat.
Require Export Sgroup_facts.
Require Export Monoid_facts.
Section Lemmas.
Variable G : GROUP.

Lemma GROUP_comp :
 forall x x' : G,
 Equal x x' -> Equal (group_inverse _ x) (group_inverse _ x').

Lemma GROUP_inverse_r :
 forall x : G, Equal (sgroup_law _ x (group_inverse _ x)) (monoid_unit G).

Lemma GROUP_inverse_l :
 forall x : G, Equal (sgroup_law _ (group_inverse _ x) x) (monoid_unit G).
Hint Resolve GROUP_comp GROUP_inverse_r GROUP_inverse_l: algebra.

Lemma GROUP_unit_inverse :
 Equal (group_inverse _ (monoid_unit G)) (monoid_unit G).

Lemma GROUP_reg_left :
 forall x y z : G, Equal (sgroup_law _ x y) (sgroup_law _ x z) -> Equal y z.

Lemma GROUP_reg_right :
 forall x y z : G, Equal (sgroup_law _ y x) (sgroup_law _ z x) -> Equal y z.

Lemma GROUP_inverse_inverse :
 forall x : G, Equal (group_inverse _ (group_inverse _ x)) x.

Lemma GROUP_law_inverse :
 forall x y : G,
 Equal (sgroup_law _ x y) (monoid_unit G) -> Equal (group_inverse _ x) y.

Lemma GROUP_inverse_law :
 forall x y : G,
 Equal (group_inverse _ (sgroup_law _ x y))
   (sgroup_law _ (group_inverse _ y) (group_inverse _ x)).
End Lemmas.
Section Lemmas2.
Variable G F : GROUP.
Variable f : Hom G F.

Lemma GROUP_hom_prop :
 forall x : G, Equal (f (group_inverse _ x)) (group_inverse _ (f x)).
End Lemmas2.
Hint Resolve GROUP_comp GROUP_inverse_r GROUP_inverse_l GROUP_unit_inverse
  GROUP_reg_left GROUP_reg_right GROUP_inverse_inverse GROUP_law_inverse
  GROUP_inverse_law: algebra.
Hint Resolve GROUP_hom_prop: algebra. *)
Require Export Abelian_group_facts.
(* Abelian_group_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Abelian_group_cat.
Require Export Group_facts.

Section Sgroup.
Variable S : ABELIAN_SGROUP.

Lemma ABELIAN_SGROUP_com :
 forall x y : S, Equal (sgroup_law _ x y) (sgroup_law _ y x).

Lemma ABELIAN_SGROUP_permute :
 forall x y z : S,
 Equal (sgroup_law _ x (sgroup_law _ y z))
   (sgroup_law _ y (sgroup_law _ x z)).

Lemma ABELIAN_SGROUP4 :
 forall x y z t : S,
 Equal (sgroup_law _ (sgroup_law _ x y) (sgroup_law _ z t))
   (sgroup_law _ (sgroup_law _ x z) (sgroup_law _ y t)).
End Sgroup.
Hint Immediate ABELIAN_SGROUP_com ABELIAN_SGROUP_permute ABELIAN_SGROUP4:
  algebra.
Section Monoid.
Variable M : ABELIAN_MONOID.

Lemma ABELIAN_MONOID_com :
 forall x y : M, Equal (sgroup_law _ x y) (sgroup_law _ y x).

Lemma ABELIAN_MONOID_permute :
 forall x y z : M,
 Equal (sgroup_law _ x (sgroup_law _ y z))
   (sgroup_law _ y (sgroup_law _ x z)).

Lemma ABELIAN_MONOID4 :
 forall x y z t : M,
 Equal (sgroup_law _ (sgroup_law _ x y) (sgroup_law _ z t))
   (sgroup_law _ (sgroup_law _ x z) (sgroup_law _ y t)).
End Monoid.
Hint Immediate ABELIAN_MONOID_com ABELIAN_MONOID_permute ABELIAN_MONOID4:
  algebra.
Section Group.
Variable G : ABELIAN_GROUP.

Lemma ABELIAN_GROUP_com :
 forall x y : G, Equal (sgroup_law _ x y) (sgroup_law _ y x).

Lemma ABELIAN_GROUP_permute :
 forall x y z : G,
 Equal (sgroup_law _ x (sgroup_law _ y z))
   (sgroup_law _ y (sgroup_law _ x z)).

Lemma ABELIAN_GROUP4 :
 forall x y z t : G,
 Equal (sgroup_law _ (sgroup_law _ x y) (sgroup_law _ z t))
   (sgroup_law _ (sgroup_law _ x z) (sgroup_law _ y t)).
End Group.
Hint Immediate ABELIAN_GROUP_com ABELIAN_GROUP_permute ABELIAN_GROUP4:
  algebra. *)

Section Lemmas.
Variable R : RING.

Lemma RING_assoc :
 forall x y z : R,
 Equal (ring_mult (ring_mult x y) z) (ring_mult x (ring_mult y z)).
exact (sgroup_assoc_prf (E:=R) (ring_monoid R)).
Qed.

Lemma RING_comp :
 forall x x' y y' : R,
 Equal x x' -> Equal y y' -> Equal (ring_mult x y) (ring_mult x' y').
unfold ring_mult in |- *; auto with algebra.
Qed.

Lemma RING_unit_r : forall x : R, Equal (ring_mult x (ring_unit R)) x.
exact (monoid_unit_r_prf (ring_monoid R)).
Qed.

Lemma RING_unit_l : forall x : R, Equal (ring_mult (ring_unit R) x) x.
exact (monoid_unit_l_prf (ring_monoid R)).
Qed.

Lemma RING_dist_r :
 forall x y z : R,
 Equal (ring_mult (sgroup_law R x y) z)
   (sgroup_law R (ring_mult x z) (ring_mult y z)).
exact (ring_dist_r_prf R).
Qed.

Lemma RING_dist_l :
 forall x y z : R,
 Equal (ring_mult x (sgroup_law R y z))
   (sgroup_law R (ring_mult x y) (ring_mult x z)).
exact (ring_dist_l_prf R).
Qed.
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l: algebra.

Lemma RING_absorbant_r :
 forall x : R, Equal (ring_mult x (monoid_unit R)) (monoid_unit R).
intros x; try assumption.
apply GROUP_reg_right with (ring_mult x (monoid_unit R)).
apply Trans with (ring_mult x (sgroup_law R (monoid_unit R) (monoid_unit R)));
 auto with algebra.
apply Trans with (ring_mult x (monoid_unit R)); auto with algebra.
Qed.
Hint Resolve RING_absorbant_r: algebra.

Lemma RING_absorbant_l :
 forall x : R, Equal (ring_mult (monoid_unit R) x) (monoid_unit R).
intros x; try assumption.
apply GROUP_reg_right with (ring_mult (monoid_unit R) x).
apply Trans with (ring_mult (sgroup_law R (monoid_unit R) (monoid_unit R)) x);
 auto with algebra.
apply Trans with (ring_mult (monoid_unit R) x); auto with algebra.
Qed.
Hint Resolve RING_absorbant_l: algebra.

Lemma RING_op_mult_l :
 forall x y : R,
 Equal (ring_mult (group_inverse R x) y) (group_inverse R (ring_mult x y)).
intros x y; try assumption.
apply Sym.
apply GROUP_law_inverse.
apply Trans with (ring_mult (sgroup_law R x (group_inverse R x)) y);
 auto with algebra.
apply Trans with (ring_mult (monoid_unit R) y); auto with algebra.
Qed.
Hint Resolve RING_op_mult_l: algebra.

Lemma RING_op_mult_r :
 forall x y : R,
 Equal (ring_mult x (group_inverse R y)) (group_inverse R (ring_mult x y)).
intros x y; try assumption.
apply Sym.
apply GROUP_law_inverse.
apply Trans with (ring_mult x (sgroup_law R y (group_inverse R y)));
 auto with algebra.
apply Trans with (ring_mult x (monoid_unit R)); auto with algebra.
Qed.
End Lemmas.
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l RING_absorbant_r RING_absorbant_l RING_op_mult_l
  RING_op_mult_r: algebra.
Section Commutative_rings.
Variable R1 : CRING.

Lemma CRING_com : forall x y : R1, Equal (ring_mult x y) (ring_mult y x).
exact (cring_com_prf R1).
Qed.
Hint Immediate CRING_com: algebra.

Lemma CRING_mult4 :
 forall a b c d : R1,
 Equal (ring_mult (ring_mult a b) (ring_mult c d))
   (ring_mult (ring_mult a c) (ring_mult b d)).
intros a b c d; try assumption.
apply Trans with (ring_mult a (ring_mult b (ring_mult c d)));
 auto with algebra.
apply Trans with (ring_mult a (ring_mult (ring_mult b c) d));
 auto with algebra.
apply Trans with (ring_mult a (ring_mult (ring_mult c b) d));
 auto with algebra.
apply Trans with (ring_mult a (ring_mult c (ring_mult b d)));
 auto with algebra.
Qed.
Hint Resolve CRING_mult4: algebra.

Lemma CRING_mult3 :
 forall x y z : R1,
 Equal (ring_mult x (ring_mult y z)) (ring_mult y (ring_mult x z)).
intros x y z; try assumption.
apply Trans with (ring_mult (ring_mult x y) z); auto with algebra.
apply Trans with (ring_mult (ring_mult y x) z); auto with algebra.
Qed.
Hint Resolve CRING_mult3: algebra.

Lemma CRING_mult3bis :
 forall x y z : R1,
 Equal (ring_mult (ring_mult x y) z) (ring_mult (ring_mult x z) y).
intros x y z; try assumption.
apply Trans with (ring_mult z (ring_mult x y)); auto with algebra.
apply Trans with (ring_mult z (ring_mult y x)); auto with algebra.
apply Trans with (ring_mult y (ring_mult z x)); auto with algebra.
apply Trans with (ring_mult (ring_mult z x) y); auto with algebra.
Qed.
Hint Resolve CRING_mult3bis: algebra.
End Commutative_rings.
Hint Resolve CRING_mult4 CRING_mult3 CRING_mult3bis: algebra.
Hint Immediate CRING_com: algebra.
Section Hom_lemmas.
Hint Resolve RING_comp: algebra.
Variable R R' : RING.
Variable f : Hom R R'.

Lemma RING_hom_prop :
 forall x y : R, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).
case f; auto with algebra.
Qed.

Lemma RING_one_prop : Equal (f (ring_unit R)) (ring_unit R').
case f; auto with algebra.
Qed.

Lemma RING_hom_ext :
 forall f g : Hom R R', (forall x : R, Equal (f x) (g x)) -> Equal f g.
auto with algebra.
Qed.
End Hom_lemmas.
Hint Resolve RING_hom_prop RING_one_prop: algebra.