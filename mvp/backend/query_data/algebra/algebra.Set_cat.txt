
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Categories.
(* Categories:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Cartesian.

Comments "Some basic category theory.".
Section Category_def.
Section Category_def1.
Variable Ob : Type.
Variable Hom : Ob -> Ob -> Setoid.
Variable
  Hom_comp : forall a b c : Ob, MAP (cart (Hom b c) (Hom a b)) (Hom a c).
Variable Hom_id : forall a : Ob, Hom a a.

Definition Hom_comp_assoc :=
  forall (a b c d : Ob) (f : Hom a b) (g : Hom b c) (h : Hom c d),
  Equal (Hom_comp a b d (couple (Hom_comp b c d (couple h g)) f))
    (Hom_comp a c d (couple h (Hom_comp a b c (couple g f)))).

Definition Hom_comp_unit_l :=
  forall (a b : Ob) (f : Hom a b),
  Equal (Hom_comp a b b (couple (Hom_id b) f)) f.

Definition Hom_comp_unit_r :=
  forall (a b : Ob) (f : Hom a b),
  Equal (Hom_comp a a b (couple f (Hom_id a))) f.
End Category_def1.

Record category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Hom_comp : forall a b c : Ob, MAP (cart (Hom b c) (Hom a b)) (Hom a c);
   Hom_id : forall a : Ob, Hom a a;
   Hom_comp_assoc_prf : Hom_comp_assoc Hom_comp;
   Hom_comp_unit_l_prf : Hom_comp_unit_l Hom_comp Hom_id;
   Hom_comp_unit_r_prf : Hom_comp_unit_r Hom_comp Hom_id}.
Section Category_comp.
Variable C : category.

Definition comp_hom (a b c : C) (g : Hom b c) (f : Hom a b) :=
  Hom_comp a b c (couple g f).

Lemma comp_hom_compatible :
 forall (a b c : C) (x x' : Hom b c) (y y' : Hom a b),
 Equal x x' -> Equal y y' -> Equal (comp_hom x y) (comp_hom x' y').

Lemma comp_hom_assoc :
 forall (a b c d : C) (f : Hom a b) (g : Hom b c) (h : Hom c d),
 Equal (comp_hom (comp_hom h g) f) (comp_hom h (comp_hom g f)).

Lemma comp_hom_unit_l :
 forall (a b : C) (f : Hom a b), Equal (comp_hom (Hom_id b) f) f.

Lemma comp_hom_unit_r :
 forall (a b : C) (f : Hom a b), Equal (comp_hom f (Hom_id a)) f.
End Category_comp.
Hint Resolve comp_hom_compatible comp_hom_assoc comp_hom_unit_l
  comp_hom_unit_r: algebra.
Section Full_subcat_def.
Variable C : category.
Variable C' : Type.
Variable i : C' -> C.

Definition fsubcat_Hom (a b : C') := Hom (i a) (i b).

Definition fsubcat_Hom_comp :
  forall a b c : C',
  MAP (cart (fsubcat_Hom b c) (fsubcat_Hom a b)) (fsubcat_Hom a c).

Definition fsubcat_Hom_id (a : C') := Hom_id (i a).

Definition full_subcat : category.
End Full_subcat_def.
End Category_def.
Hint Resolve comp_hom_compatible comp_hom_assoc comp_hom_unit_l
  comp_hom_unit_r: algebra. *)

Section Def.

Lemma comp_map_map_compatible :
 forall E F G : Setoid, fun2_compatible (comp_map_map (E:=E) (F:=F) (G:=G)).
intros E F G; red in |- *.
auto with algebra.
Qed.

Definition SET : category.
apply
 (Build_category (Ob:=Setoid) (Hom:=MAP)
    (Hom_comp:=fun E F G : Setoid =>
               uncurry (comp_map_map_compatible (E:=E) (F:=F) (G:=G)))
    (Hom_id:=Id)); red in |- *; simpl in |- *; unfold Map_eq in |- *;
 auto with algebra.
Defined.
End Def.