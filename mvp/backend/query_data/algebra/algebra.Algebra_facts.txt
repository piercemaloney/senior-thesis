
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Algebra.
(* Algebra:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Hom_module.
Section algebra_def.
Variable R : CRING.

Record algebra_on (Mod : MODULE R) : Type := 
  {algebra_bilinear_map : Hom_module Mod (Hom_module Mod Mod)}.

Record algebra : Type := 
  {algebra_carrier :> module R; algebra_on_def :> algebra_on algebra_carrier}.
Coercion Build_algebra : algebra_on >-> algebra.

Definition algebra_mult (A : algebra) (x y : A) : A :=
  algebra_bilinear_map A x y.

Record ring_algebra_on (A : algebra) : Type := 
  {ring_algebra_assoc :
    forall x y z : A,
    Equal (algebra_mult (algebra_mult x y) z)
      (algebra_mult x (algebra_mult y z));
   ring_algebra_unit : A;
   ring_algebra_unit_l :
    forall x : A, Equal (algebra_mult ring_algebra_unit x) x;
   ring_algebra_unit_r :
    forall x : A, Equal (algebra_mult x ring_algebra_unit) x}.

Record ring_algebra : Type := 
  {ring_algebra_algebra :> algebra;
   ring_algebra_on_def :> ring_algebra_on ring_algebra_algebra}.
Coercion Build_ring_algebra : ring_algebra_on >-> ring_algebra.
End algebra_def. *)
Require Export Ring_util.
(* Ring_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
Require Export Monoid_util.
Require Export Ring_cat.

Section Ring.
Variable E : Setoid.
Variable ringplus : E -> E -> E.
Variable ringmult : E -> E -> E.
Variable zero : E.
Variable un : E.
Variable ringopp : E -> E.
Hypothesis
  ringpluscomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringplus x y) (ringplus x' y').
Hypothesis
  ringplusassoc :
    forall x y z : E,
    Equal (ringplus (ringplus x y) z) (ringplus x (ringplus y z)).
Hypothesis zerounitringplusr : forall x : E, Equal (ringplus x zero) x.
Hypothesis
  oppcomp : forall x y : E, Equal x y -> Equal (ringopp x) (ringopp y).
Hypothesis ringoppr : forall x : E, Equal (ringplus x (ringopp x)) zero.
Hypothesis ringpluscom : forall x y : E, Equal (ringplus x y) (ringplus y x).
Hypothesis
  ringmultcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringmult x y) (ringmult x' y').
Hypothesis
  ringmultassoc :
    forall x y z : E,
    Equal (ringmult (ringmult x y) z) (ringmult x (ringmult y z)).
Hypothesis ununitringmultr : forall x : E, Equal (ringmult x un) x.
Hypothesis ununitlringmult : forall x : E, Equal (ringmult un x) x.
Hypothesis
  ringdistl :
    forall x y z : E,
    Equal (ringmult x (ringplus y z))
      (ringplus (ringmult x y) (ringmult x z)).
Hypothesis
  ringdistr :
    forall x y z : E,
    Equal (ringmult (ringplus x y) z)
      (ringplus (ringmult x z) (ringmult y z)).

Definition G :=
  BUILD_ABELIAN_GROUP ringpluscomp ringplusassoc zerounitringplusr oppcomp
    ringoppr ringpluscom.

Definition M :=
  BUILD_MONOID ringmultcomp ringmultassoc ununitringmultr ununitlringmult.

Definition BUILD_RING : RING.
End Ring.
Section Hom.
Variable Ring1 Ring2 : ring.
Variable ff : Ring1 -> Ring2.
Hypothesis ffcomp : forall x y : Ring1, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  ffplus :
    forall x y : Ring1,
    Equal (ff (sgroup_law Ring1 x y)) (sgroup_law Ring2 (ff x) (ff y)).
Hypothesis ffzero : Equal (ff (monoid_unit Ring1)) (monoid_unit Ring2).
Hypothesis
  ffmult :
    forall x y : Ring1, Equal (ff (ring_mult x y)) (ring_mult (ff x) (ff y)).
Hypothesis ffone : Equal (ff (ring_unit Ring1)) (ring_unit Ring2).

Definition BUILD_HOM_RING : Hom (Ring1:RING) (Ring2:RING).
End Hom. *)
Section Lemmas.
Variable R : CRING.
Variable A : algebra R.

Lemma ALGEBRA_comp :
 forall x x' y y' : A,
 Equal x x' -> Equal y y' -> Equal (algebra_mult x y) (algebra_mult x' y').
intros x x' y y' H' H'0; try assumption.
unfold algebra_mult in |- *.
apply Ap_comp.
auto with algebra.
apply
 (Ap_comp (B:=Hom_module (algebra_carrier A) (algebra_carrier A))
    (f:=algebra_bilinear_map (algebra_on_def A))
    (g:=algebra_bilinear_map (algebra_on_def A)) H').
auto with algebra.
Qed.

Lemma ALGEBRA_lin_right :
 forall x y z : A,
 Equal (algebra_mult x (sgroup_law A y z))
   (sgroup_law A (algebra_mult x y) (algebra_mult x z)).
intros x y z; try assumption.
unfold algebra_mult in |- *.
auto with algebra.
Qed.
Parameter
  ALGEBRA_lin_left :
    forall x y z : A,
    Equal (algebra_mult (sgroup_law A x y) z)
      (sgroup_law A (algebra_mult x z) (algebra_mult y z)).

Lemma ALGEBRA_mult_lin_right :
 forall (x y : A) (a : R),
 Equal (algebra_mult x (module_mult a y)) (module_mult a (algebra_mult x y)).
intros x y a; try assumption.
unfold algebra_mult in |- *.
auto with algebra.
Qed.
Parameter
  ALGEBRA_mult_lin_left :
    forall (x y : A) (a : R),
    Equal (algebra_mult (module_mult a x) y)
      (module_mult a (algebra_mult x y)).
End Lemmas.
Hint Resolve ALGEBRA_comp ALGEBRA_lin_right ALGEBRA_lin_left
  ALGEBRA_mult_lin_right ALGEBRA_mult_lin_left: algebra.
Section Lemmas2.
Variable R : CRING.
Variable A : ring_algebra R.

Lemma RING_ALGEBRA_assoc :
 forall x y z : A,
 Equal (algebra_mult (algebra_mult x y) z)
   (algebra_mult x (algebra_mult y z)).
exact (ring_algebra_assoc A).
Qed.

Lemma RING_ALGEBRA_unit_l :
 forall x : A, Equal (algebra_mult (ring_algebra_unit A) x) x.
exact (ring_algebra_unit_l A).
Qed.

Lemma RING_ALGEBRA_unit_r :
 forall x : A, Equal (algebra_mult x (ring_algebra_unit A)) x.
exact (ring_algebra_unit_r A).
Qed.
End Lemmas2.
Hint Resolve RING_ALGEBRA_assoc RING_ALGEBRA_unit_l RING_ALGEBRA_unit_r:
  algebra.
Section Ring_algebra_as_ring.
Variable R : CRING.
Variable A : ring_algebra R.

Definition ring_algebra_ring : ring.
apply
 (BUILD_RING (E:=A) (ringplus:=sgroup_law A)
    (ringmult:=algebra_mult (R:=R) (A:=A)) (zero:=monoid_unit A)
    (un:=ring_algebra_unit A) (ringopp:=group_inverse A)).
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
auto with algebra.
Defined.
End Ring_algebra_as_ring.
Coercion ring_algebra_ring : ring_algebra >-> ring.