
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_kernel.
(* Monoid_kernel:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_util.
Require Export Parts2.
Section Image_hom.
Variable M M' : MONOID.
Variable f : Hom M M'.

Definition image_monoid_hom : submonoid M'.

Lemma image_monoid_prop : forall x : M, in_part (f x) image_monoid_hom.

Lemma image_monoid_prop_rev :
 forall y : M', in_part y image_monoid_hom -> exists x : M, Equal y (f x).
End Image_hom.
Hint Resolve image_monoid_prop image_monoid_prop: algebra. *)
Require Export Free_monoid.
(* Free_monoid:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_cat.
Require Export Sgroup_facts.
Require Export Monoid_facts.
Require Export Monoid_util.
Section Free_monoid_def.
Variable V : SET.

Inductive FM : Type :=
  | Var : V -> FM
  | Law : FM -> FM -> FM
  | Unit : FM.

Inductive eqFM : FM -> FM -> Prop :=
  | eqFM_Var : forall x y : V, Equal x y -> (eqFM (Var x) (Var y):Prop)
  | eqFM_law :
      forall x x' y y' : FM,
      eqFM x x' -> eqFM y y' -> (eqFM (Law x y) (Law x' y'):Prop)
  | eqFM_law_assoc :
      forall x y z : FM, eqFM (Law (Law x y) z) (Law x (Law y z)):Prop
  | eqFM_law0r : forall x : FM, eqFM (Law x Unit) x:Prop
  | eqFM_law0l : forall x : FM, eqFM (Law Unit x) x:Prop
  | eqFM_refl : forall x : FM, eqFM x x:Prop
  | eqFM_sym : forall x y : FM, eqFM x y -> (eqFM y x:Prop)
  | eqFM_trans : forall x y z : FM, eqFM x y -> eqFM y z -> (eqFM x z:Prop).
Hint Resolve eqFM_Var eqFM_law eqFM_law_assoc eqFM_law0r eqFM_law0l
  eqFM_refl: algebra.
Hint Immediate eqFM_sym: algebra.

Lemma eqFM_Equiv : equivalence eqFM.

Definition FM_set := Build_Setoid eqFM_Equiv.

Definition FreeMonoid : MONOID.
Section Universal_prop.
Variable M : MONOID.
Variable f : Hom V M.

Fixpoint FM_lift_fun (p : FreeMonoid) : M :=
  match p with
  | Var v => f v
  | Law p1 p2 => sgroup_law _ (FM_lift_fun p1) (FM_lift_fun p2)
  | Unit => monoid_unit M
  end.

Definition FM_lift : Hom FreeMonoid M.

Definition FM_var : Hom V FreeMonoid.

Lemma FM_comp_prop :
 Equal f (comp_hom (FM_lift:Hom (FreeMonoid:SET) M) FM_var).
End Universal_prop.
End Free_monoid_def.
Hint Resolve FM_comp_prop: algebra. *)
Section Generated_monoid_def.
Variable M : MONOID.
Variable A : part_set M.

Definition generated_monoid : submonoid M :=
  image_monoid_hom (FM_lift (inj_part A)).
End Generated_monoid_def.

Lemma generated_monoid_minimal :
 forall (M : MONOID) (A : part_set M) (H : submonoid M),
 included A H -> included (generated_monoid A) H.
unfold included in |- *.
simpl in |- *.
intros M A H H' x H'0; try assumption.
elim H'0; intros x0; clear H'0.
generalize x; clear x.
elim x0.
intros c; try assumption.
elim c.
simpl in |- *.
intros y subtype_prf x H'0; elim H'0; intros H'1 H'2; try exact H'2;
 clear H'0.
apply in_part_comp_l with y; auto with algebra.
intros f H'0 f0 H'1 x H'2; elim H'2; intros H'3 H'4; try exact H'4; clear H'2.
simpl in H'4.
apply
 in_part_comp_l
  with
    (sgroup_law M (FM_lift_fun (inj_part A) f) (FM_lift_fun (inj_part A) f0));
 auto with algebra.
simpl in |- *.
intros x H'0; elim H'0; intros H'1 H'2; try exact H'2; clear H'0.
apply in_part_comp_l with (monoid_unit M); auto with algebra.
Qed.

Lemma generated_monoid_prop_included :
 forall (M : MONOID) (A : part_set M), included A (generated_monoid A).
unfold included in |- *.
simpl in |- *.
intros M A x H'; try assumption.
exists (Var (V:=A) (Build_subtype (E:=M) (P:=A) (subtype_elt:=x) H')); split;
 [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
auto with algebra.
Qed.

Lemma generated_monoid_prop :
 forall (M : MONOID) (A : part_set M) (y : M),
 in_part y (generated_monoid A) ->
 exists x : FM A, Equal y (FM_lift (inj_part A) x).
simpl in |- *; auto with algebra.
intros M A y H'; try assumption.
elim H'; intros x E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists x; try assumption.
Qed.

Lemma generated_monoid_prop_rev :
 forall (M : MONOID) (A : part_set M) (y : M),
 (exists x : FM A, Equal y (FM_lift (inj_part A) x)) ->
 in_part y (generated_monoid A).
intros M A y H'; try assumption.
elim H'; intros x E; try exact E; clear H'.
simpl in |- *; auto with algebra.
exists x; split; [ idtac | try assumption ].
auto with algebra.
Qed.
Hint Resolve generated_monoid_minimal generated_monoid_prop_included
  generated_monoid_prop_rev: algebra.
