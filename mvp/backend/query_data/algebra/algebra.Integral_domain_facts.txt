
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Integral_domain_cat.
(* Integral_domain_cat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.

Section Objects.

Definition idomain_prop (R : CRING) :=
  forall x y : R,
  ~ Equal x (monoid_unit R) ->
  ~ Equal y (monoid_unit R) -> ~ Equal (ring_mult x y) (monoid_unit R).

Record idomain_on (R : cring) : Type :=  {idomain_prf : idomain_prop R}.

Record idomain : Type := 
  {idomain_ring :> cring; idomain_on_def :> idomain_on idomain_ring}.
Coercion Build_idomain : idomain_on >-> idomain.

Definition INTEGRAL_DOMAIN :=
  full_subcat (C:=CRING) (C':=idomain) idomain_ring.
End Objects. *)
Require Export Ring_facts.
(* Ring_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.
Require Export Group_facts.
Require Export Abelian_group_facts.

Section Lemmas.
Variable R : RING.

Lemma RING_assoc :
 forall x y z : R,
 Equal (ring_mult (ring_mult x y) z) (ring_mult x (ring_mult y z)).

Lemma RING_comp :
 forall x x' y y' : R,
 Equal x x' -> Equal y y' -> Equal (ring_mult x y) (ring_mult x' y').

Lemma RING_unit_r : forall x : R, Equal (ring_mult x (ring_unit R)) x.

Lemma RING_unit_l : forall x : R, Equal (ring_mult (ring_unit R) x) x.

Lemma RING_dist_r :
 forall x y z : R,
 Equal (ring_mult (sgroup_law R x y) z)
   (sgroup_law R (ring_mult x z) (ring_mult y z)).

Lemma RING_dist_l :
 forall x y z : R,
 Equal (ring_mult x (sgroup_law R y z))
   (sgroup_law R (ring_mult x y) (ring_mult x z)).
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l: algebra.

Lemma RING_absorbant_r :
 forall x : R, Equal (ring_mult x (monoid_unit R)) (monoid_unit R).
Hint Resolve RING_absorbant_r: algebra.

Lemma RING_absorbant_l :
 forall x : R, Equal (ring_mult (monoid_unit R) x) (monoid_unit R).
Hint Resolve RING_absorbant_l: algebra.

Lemma RING_op_mult_l :
 forall x y : R,
 Equal (ring_mult (group_inverse R x) y) (group_inverse R (ring_mult x y)).
Hint Resolve RING_op_mult_l: algebra.

Lemma RING_op_mult_r :
 forall x y : R,
 Equal (ring_mult x (group_inverse R y)) (group_inverse R (ring_mult x y)).
End Lemmas.
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l RING_absorbant_r RING_absorbant_l RING_op_mult_l
  RING_op_mult_r: algebra.
Section Commutative_rings.
Variable R1 : CRING.

Lemma CRING_com : forall x y : R1, Equal (ring_mult x y) (ring_mult y x).
Hint Immediate CRING_com: algebra.

Lemma CRING_mult4 :
 forall a b c d : R1,
 Equal (ring_mult (ring_mult a b) (ring_mult c d))
   (ring_mult (ring_mult a c) (ring_mult b d)).
Hint Resolve CRING_mult4: algebra.

Lemma CRING_mult3 :
 forall x y z : R1,
 Equal (ring_mult x (ring_mult y z)) (ring_mult y (ring_mult x z)).
Hint Resolve CRING_mult3: algebra.

Lemma CRING_mult3bis :
 forall x y z : R1,
 Equal (ring_mult (ring_mult x y) z) (ring_mult (ring_mult x z) y).
Hint Resolve CRING_mult3bis: algebra.
End Commutative_rings.
Hint Resolve CRING_mult4 CRING_mult3 CRING_mult3bis: algebra.
Hint Immediate CRING_com: algebra.
Section Hom_lemmas.
Hint Resolve RING_comp: algebra.
Variable R R' : RING.
Variable f : Hom R R'.

Lemma RING_hom_prop :
 forall x y : R, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Lemma RING_one_prop : Equal (f (ring_unit R)) (ring_unit R').

Lemma RING_hom_ext :
 forall f g : Hom R R', (forall x : R, Equal (f x) (g x)) -> Equal f g.
End Hom_lemmas.
Hint Resolve RING_hom_prop RING_one_prop: algebra. *)
Require Export Classical_Prop.

Section Lemmas.
Variable R : INTEGRAL_DOMAIN.

Lemma INTEGRAL_DOMAIN_prop_rev :
 forall x y : R,
 ~ Equal x (monoid_unit R) ->
 ~ Equal y (monoid_unit R) -> ~ Equal (ring_mult x y) (monoid_unit R).
exact (idomain_prf R).
Qed.

Lemma INTEGRAL_DOMAIN_prop :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 Equal x (monoid_unit R) \/ Equal y (monoid_unit R).
intros x y H'; try assumption.
generalize (INTEGRAL_DOMAIN_prop_rev (x:=x) (y:=y)).
apply NNPP; tauto.
Qed.

Lemma INTEGRAL_DOMAIN_mult_l :
 forall x y : R,
 ~ Equal (ring_mult x y) (monoid_unit R) -> ~ Equal x (monoid_unit R).
unfold not in |- *.
intros x y H' H'0; try assumption.
absurd (Equal (ring_mult x y) (monoid_unit R)); auto with algebra.
apply Trans with (ring_mult (monoid_unit R) y); auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_mult_r :
 forall x y : R,
 ~ Equal (ring_mult x y) (monoid_unit R) -> ~ Equal y (monoid_unit R).
unfold not in |- *.
intros x y H' H'0; try assumption.
absurd (Equal (ring_mult x y) (monoid_unit R)); auto with algebra.
apply Trans with (ring_mult x (monoid_unit R)); auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_mult_n0_r :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 ~ Equal y (monoid_unit R) -> Equal x (monoid_unit R).
intros x y H' H'0; try assumption.
intuition.
elim (INTEGRAL_DOMAIN_prop (x:=x) (y:=y)); auto with algebra.
intros H'1; try assumption.
absurd (Equal y (monoid_unit R)); auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_mult_n0_l :
 forall x y : R,
 Equal (ring_mult x y) (monoid_unit R) ->
 ~ Equal x (monoid_unit R) -> Equal y (monoid_unit R).
intros x y H' H'0; try assumption.
elim (INTEGRAL_DOMAIN_prop (x:=x) (y:=y)); auto with algebra.
intros H'1; try assumption.
absurd (Equal x (monoid_unit R)); auto with algebra.
Qed.
Hint Resolve INTEGRAL_DOMAIN_prop INTEGRAL_DOMAIN_prop_rev
  INTEGRAL_DOMAIN_mult_l INTEGRAL_DOMAIN_mult_r INTEGRAL_DOMAIN_mult_n0_l
  INTEGRAL_DOMAIN_mult_n0_r: algebra.

Lemma INTEGRAL_DOMAIN_simpl_r :
 forall x y z : R,
 ~ Equal z (monoid_unit R) ->
 Equal (ring_mult x z) (ring_mult y z) -> Equal x y.
intros x y z H' H'0; try assumption.
cut
 (Equal (ring_mult (sgroup_law R x (group_inverse R y)) z) (monoid_unit R)).
intros H'1; try assumption.
cut (Equal (sgroup_law R x (group_inverse R y)) (monoid_unit R)).
intros H'2; try assumption.
apply GROUP_reg_right with (group_inverse R y); auto with algebra.
apply Trans with (monoid_unit R); auto with algebra.
apply INTEGRAL_DOMAIN_mult_n0_r with z; auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (ring_mult (group_inverse R y) z));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (group_inverse R (ring_mult y z)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (group_inverse R (ring_mult x z)));
 auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_simpl_l :
 forall x y z : R,
 ~ Equal z (monoid_unit R) ->
 Equal (ring_mult z x) (ring_mult z y) -> Equal x y.
intros x y z H' H'0; try assumption.
cut
 (Equal (ring_mult z (sgroup_law R x (group_inverse R y))) (monoid_unit R)).
intros H'1; try assumption.
cut (Equal (sgroup_law R x (group_inverse R y)) (monoid_unit R)).
intros H'2; try assumption.
apply GROUP_reg_right with (group_inverse R y); auto with algebra.
apply Trans with (monoid_unit R); auto with algebra.
apply INTEGRAL_DOMAIN_mult_n0_l with z; auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (ring_mult z (group_inverse R y)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (group_inverse R (ring_mult z y)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (group_inverse R (ring_mult z x)));
 auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_mult_eq_r :
 forall x y z : R,
 Equal (ring_mult x z) (ring_mult y z) ->
 Equal x y \/ Equal z (monoid_unit R).
intros x y z H'; try assumption.
cut
 (Equal (ring_mult (sgroup_law R x (group_inverse R y)) z) (monoid_unit R)).
intros H'0; try assumption.
elim (INTEGRAL_DOMAIN_prop (x:=sgroup_law R x (group_inverse R y)) (y:=z));
 auto with algebra.
intros H'1; try assumption.
left; try assumption.
apply GROUP_reg_right with (group_inverse R y); auto with algebra.
apply Trans with (monoid_unit R); auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (ring_mult (group_inverse R y) z));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (group_inverse R (ring_mult y z)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult x z) (group_inverse R (ring_mult x z)));
 auto with algebra.
Qed.

Lemma INTEGRAL_DOMAIN_mult_eq_l :
 forall x y z : R,
 Equal (ring_mult z x) (ring_mult z y) ->
 Equal x y \/ Equal z (monoid_unit R).
intros x y z H'; try assumption.
cut
 (Equal (ring_mult z (sgroup_law R x (group_inverse R y))) (monoid_unit R)).
intros H'0; try assumption.
elim (INTEGRAL_DOMAIN_prop (x:=z) (y:=sgroup_law R x (group_inverse R y)));
 auto with algebra.
intros H'1; try assumption.
left; try assumption.
apply GROUP_reg_right with (group_inverse R y); auto with algebra.
apply Trans with (monoid_unit R); auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (ring_mult z (group_inverse R y)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (group_inverse R (ring_mult z y)));
 auto with algebra.
apply
 Trans with (sgroup_law R (ring_mult z x) (group_inverse R (ring_mult z x)));
 auto with algebra.
Qed.
End Lemmas.
Hint Resolve INTEGRAL_DOMAIN_prop INTEGRAL_DOMAIN_prop_rev
  INTEGRAL_DOMAIN_mult_l INTEGRAL_DOMAIN_mult_r INTEGRAL_DOMAIN_mult_n0_l
  INTEGRAL_DOMAIN_mult_n0_r: algebra.
Hint Resolve INTEGRAL_DOMAIN_simpl_r INTEGRAL_DOMAIN_simpl_l: algebra.
