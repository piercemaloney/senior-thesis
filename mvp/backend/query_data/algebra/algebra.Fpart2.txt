
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Fpart.
(* Fpart:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Union.
Require Export Singleton.
Require Export Diff.
Require Export Classical_Prop.
Section fparts_in_def.
Variable E : Setoid.

Definition add_part (A : part_set E) (x : E) := union A (single x).

Lemma add_part_comp :
 forall (A A' : part_set E) (x x' : E),
 Equal A A' -> Equal x x' -> Equal (add_part A x) (add_part A' x').
Hint Resolve add_part_comp: algebra.

Lemma add_part_in : forall (A : part_set E) (x : E), in_part x (add_part A x).
Hint Resolve add_part_in: algebra.

Lemma add_part_com :
 forall (A : part_set E) (x y : E),
 Equal (add_part (add_part A x) y) (add_part (add_part A y) x).
Hint Immediate add_part_com: algebra.

Lemma add_in :
 forall (A : part_set E) (x : E), in_part x A -> Equal (add_part A x) A.
Hint Resolve add_in: algebra.

Lemma add_part_in_el_diff :
 forall (A : part_set E) (x y : E),
 in_part y (add_part A x) -> ~ Equal y x -> in_part y A.

Lemma add_part_in_el_not_in :
 forall (A : part_set E) (x y : E),
 in_part y (add_part A x) -> ~ in_part y A -> Equal y x.

Lemma add_part_simpl :
 forall (A B : part_set E) (x : E),
 ~ in_part x A ->
 ~ in_part x B -> Equal (add_part A x) (add_part B x) -> Equal A B.

Definition minus_part (A : part_set E) (x : E) := diff A (single x).

Lemma minus_part_comp :
 forall (A A' : part_set E) (x x' : E),
 Equal A A' -> Equal x x' -> Equal (minus_part A x) (minus_part A' x').
Hint Resolve minus_part_comp: algebra.

Lemma minus_part_not_in :
 forall (A : part_set E) (x : E), ~ in_part x (minus_part A x).
Hint Resolve minus_part_not_in: algebra.

Lemma minus_part_com :
 forall (A : part_set E) (x y : E),
 Equal (minus_part (minus_part A x) y) (minus_part (minus_part A y) x).
Hint Immediate minus_part_com: algebra.

Lemma minus_not_in :
 forall (A : part_set E) (x : E), ~ in_part x A -> Equal (minus_part A x) A.
Hint Resolve minus_not_in: algebra.

Lemma minus_trans_not_in :
 forall (A : part_set E) (x y : E),
 ~ in_part y A -> ~ in_part y (minus_part A x).
Hint Resolve minus_trans_not_in: algebra.

Lemma union_unit_l : forall A : part_set E, Equal (union (empty E) A) A.
Hint Resolve union_unit_l: algebra.

Lemma single_add : forall x : E, Equal (single x) (add_part (empty E) x).
Hint Resolve single_add: algebra.

Lemma minus_add :
 forall (A : part_set E) (x : E),
 in_part x A -> Equal (add_part (minus_part A x) x) A.
Hint Resolve minus_add: algebra.

Lemma add_minus :
 forall (A : part_set E) (x : E),
 ~ in_part x A -> Equal (minus_part (add_part A x) x) A.
Hint Resolve add_minus: algebra.

Inductive cardinal : part_set E -> nat -> Prop :=
  | cardinal_empty : forall A : part_set E, Equal A (empty E) -> cardinal A 0
  | cardinal_add :
      forall (A B : part_set E) (n : nat),
      cardinal B n ->
      forall x : E,
      ~ in_part x B -> Equal A (add_part B x) -> cardinal A (S n).
Hint Immediate cardinal_empty: algebra.

Lemma cardinal_comp :
 forall (A B : part_set E) (n m : nat),
 Equal A B -> n = m -> cardinal A n -> cardinal B m.
Hint Resolve cardinal_comp: algebra.

Lemma cardinal_comp_l :
 forall (A B : part_set E) (n : nat),
 Equal A B -> cardinal A n -> cardinal B n.

Lemma cardinal_comp_r :
 forall (A : part_set E) (n m : nat), n = m -> cardinal A n -> cardinal A m.

Lemma cardinal_empty_O : cardinal (empty E) 0.
Hint Resolve cardinal_empty_O: algebra.

Lemma cardinal_single : forall x : E, cardinal (single x) 1.
Hint Resolve cardinal_single: algebra.

Lemma cardinal_pair :
 forall x y : E, ~ Equal x y -> cardinal (union (single x) (single y)) 2.
Hint Resolve cardinal_pair: algebra.

Lemma cardinal_O_empty :
 forall A : part_set E, cardinal A 0 -> Equal A (empty E).
Hint Resolve cardinal_O_empty: algebra.

Lemma cardinal_1_single :
 forall A : part_set E, cardinal A 1 -> exists x : E, Equal A (single x).

Lemma not_in_empty :
 forall A : part_set E, (forall x : E, ~ in_part x A) -> Equal A (empty E).
Hint Immediate not_in_empty: algebra.

Lemma not_in_part_trans :
 forall (x : E) (A B : part_set E),
 ~ in_part x A -> Equal A B -> ~ in_part x B.

Lemma not_in_part_trans_eq :
 forall (x y : E) (A : part_set E),
 ~ in_part x A -> Equal x y -> ~ in_part y A.

Lemma cardinal_sup3 :
 forall (A B C : part_set E) (x y : E),
 Equal A (add_part B x) ->
 Equal A (add_part C y) ->
 ~ in_part x B ->
 ~ in_part y C ->
 ~ Equal x y ->
 exists D : part_set E,
   Equal B (add_part D y) /\
   Equal C (add_part D x) /\ ~ in_part x D /\ ~ in_part y D.

Lemma cardinal_ind2 :
 forall P : forall (n : nat) (A : part_set E), cardinal A n -> Prop,
 (forall (A : part_set E) (c : cardinal A 0), P 0 A c) ->
 (forall n : nat,
  (forall (B : part_set E) (c : cardinal B n), P n B c) ->
  forall (A B : part_set E) (x : E),
  ~ in_part x B ->
  Equal A (add_part B x) -> forall c' : cardinal A (S n), P (S n) A c') ->
 forall (n : nat) (A : part_set E) (c : cardinal A n), P n A c.

Lemma cardinal_S :
 forall (n : nat) (A B : part_set E) (x : E),
 ~ in_part x B -> Equal A (add_part B x) -> cardinal A (S n) -> cardinal B n.

Lemma cardinalO_unique :
 forall A : part_set E, cardinal A 0 -> forall m : nat, cardinal A m -> 0 = m.

Lemma cardinal_unique :
 forall (n : nat) (A : part_set E),
 cardinal A n -> forall m : nat, cardinal A m -> n = m.

End fparts_in_def.
Hint Resolve single_law add_part_comp add_part_in add_in minus_part_comp
  minus_part_not_in minus_not_in minus_trans_not_in union_unit_l single_add
  minus_add add_minus cardinal_comp cardinal_empty_O cardinal_single
  cardinal_pair cardinal_O_empty: algebra.
Hint Immediate single_prop: algebra.
Hint Immediate single_prop_rev: algebra.
Hint Immediate add_part_com: algebra.
Hint Immediate minus_part_com: algebra.
Hint Immediate cardinal_empty: algebra.
Hint Immediate not_in_empty: algebra. *)
Require Export Inter.
(* Inter:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Union.

Section Inter1.
Variable E : Setoid.

Definition inter : part_set E -> part_set E -> part_set E.

Lemma included_inter_l : forall A B : part_set E, included (inter A B) A.

Lemma included_inter_r : forall A B : part_set E, included (inter A B) B.

Lemma in_part_inter_l :
 forall (A B : part_set E) (x : E), in_part x (inter A B) -> in_part x A.

Lemma in_part_inter_r :
 forall (A B : part_set E) (x : E), in_part x (inter A B) -> in_part x B.

Lemma in_part_inter :
 forall (A B : part_set E) (x : E),
 in_part x A -> in_part x B -> in_part x (inter A B).

Lemma inter_not_in_l :
 forall (A B : part_set E) (x : E), ~ in_part x A -> ~ in_part x (inter A B).

Lemma inter_not_in_r :
 forall (A B : part_set E) (x : E), ~ in_part x B -> ~ in_part x (inter A B).

Lemma included2_inter :
 forall A B C : part_set E,
 included A C -> included B C -> included (inter A B) C.

Lemma inter_comp :
 forall A A' B B' : part_set E,
 Equal A A' -> Equal B B' -> Equal (inter A B) (inter A' B').

Lemma inter_assoc :
 forall A B C : part_set E, Equal (inter A (inter B C)) (inter (inter A B) C).

Lemma inter_com : forall A B : part_set E, Equal (inter A B) (inter B A).

Parameter
  inter_union_dist_r :
    forall A B C : part_set E,
    Equal (inter (union A B) C) (union (inter A C) (inter B C)).
Parameter
  inter_union_dist_l :
    forall A B C : part_set E,
    Equal (inter A (union B C)) (union (inter A B) (inter A C)).
End Inter1.
Hint Resolve included_inter_l included_inter_r in_part_inter_l
  in_part_inter_r in_part_inter included2_inter inter_comp inter_assoc
  inter_not_in_l inter_not_in_r inter_union_dist_r inter_union_dist_l:
  algebra.
Hint Immediate inter_com: algebra. *)
Require Export Arith.
Section fparts2_def.
Variable E : Setoid.

Definition disjoint (A B : part_set E) := Equal (inter A B) (empty E).

Lemma disjoint_comp :
 forall A A' B B' : part_set E,
 Equal A A' -> Equal B B' -> disjoint A B -> disjoint A' B'.
unfold disjoint in |- *.
intros A A' B B' H' H'0 H'1; try assumption.
apply Trans with (inter A B).
auto with *.
auto with *.
Qed.

Lemma empty_not_in :
 forall A : part_set E, Equal A (empty E) -> forall x : E, ~ in_part x A.
intros A; case A; intros a pa; simpl in |- *.
unfold eq_part, empty in |- *; simpl in |- *.
intuition.
intros.
elim (H x); auto with *.
Qed.

Lemma disjoint_inclus :
 forall A B C : part_set E, included A B -> disjoint B C -> disjoint A C.
unfold included, disjoint in |- *.
intros A B C H' H'0; try assumption.
apply not_in_empty.
unfold not in |- *; intros.
cut (in_part x (inter B C)).
generalize (empty_not_in (A:=inter B C) H'0).
unfold not in |- *; intros.
apply H0 with (x := x).
auto with *.
auto with *.
apply in_part_inter.
apply H'.
apply in_part_inter_l with C.
auto with *.
apply in_part_inter_r with A.
auto with *.
Qed.

Lemma included_add_part :
 forall (A : part_set E) (x : E), included A (add_part A x).
intros A x; red in |- *.
unfold add_part in |- *.
auto with *.
Qed.
Hint Resolve included_add_part: algebra.

Lemma union_not_in :
 forall (A B : part_set E) (x : E),
 ~ in_part x A -> ~ in_part x B -> ~ in_part x (union A B).
unfold not in |- *; intros.
cut (in_part x A \/ in_part x B).
intros H'; try assumption.
intuition.
auto with *.
Qed.
Hint Resolve union_not_in: algebra.

Lemma disjoint_not_in_r :
 forall (A B : part_set E) (x : E),
 disjoint A B -> in_part x A -> ~ in_part x B.
unfold disjoint in |- *.
unfold not in |- *; intros.
cut (in_part x (empty E)).
auto with *.
apply in_part_comp_r with (inter A B).
auto with *.
auto with *.
Qed.

Lemma cardinal_union_disjoint :
 forall (a b : nat) (A B : part_set E),
 cardinal A a -> cardinal B b -> disjoint A B -> cardinal (union A B) (a + b).
simple induction a.
intros.
apply cardinal_comp_l with (union (empty E) B); auto with *.
apply union_comp; auto with *.
apply Sym.
auto with *.
apply cardinal_comp_l with B; auto with *.
intros.
inversion H0.
simpl in |- *.
apply cardinal_add with (union B0 B) x; auto with *.
apply H; auto with *.
apply disjoint_inclus with (add_part B0 x); auto with *.
apply disjoint_comp with A B; auto with *.
apply union_not_in; auto with *.
apply disjoint_not_in_r with A; auto with *.
apply in_part_comp_r with (add_part B0 x); auto with *.
apply Trans with (union (add_part B0 x) B); auto with *.
unfold add_part in |- *.
apply Trans with (union B0 (union (single x) B)); auto with *.
apply Trans with (union B0 (union B (single x))); auto with *.
Qed.
Hint Resolve cardinal_union_disjoint: algebra.

Lemma in_eq_part :
 forall A B : part_set E,
 (forall x : E, in_part x A -> in_part x B) ->
 (forall x : E, in_part x B -> in_part x A) -> Equal A B.
intros A B.
case A; case B; simpl in |- *.
intros a pa b pb.
unfold eq_part in |- *; simpl in |- *.
intuition.
Qed.

Lemma diff_in_l :
 forall (A B : part_set E) (x : E), in_part x (diff A B) -> in_part x A.
intros A B.
case A; case B; simpl in |- *.
intros a pa b pb.
unfold eq_part in |- *; simpl in |- *.
intuition.
Qed.

Lemma diff_in_r :
 forall (A B : part_set E) (x : E), in_part x (diff A B) -> ~ in_part x B.
intros A B.
case A; case B; simpl in |- *.
intros a pa b pb.
unfold eq_part in |- *; simpl in |- *.
intuition.
Qed.

Lemma in_diff :
 forall (A B : part_set E) (x : E),
 in_part x A -> ~ in_part x B -> in_part x (diff A B).
intros A B.
case A; case B; simpl in |- *.
intros a pa b pb.
unfold eq_part in |- *; simpl in |- *.
intuition.
Qed.
Hint Resolve in_diff: algebra.

Lemma union_diff :
 forall A B : part_set E, Equal (union A (diff B A)) (union A B).
intros A B; try assumption.
apply in_eq_part.
intros x H'; try assumption.
elim (in_part_union H').
auto with *.
intros H'0; try assumption.
cut (in_part x B).
auto with *.
exact (diff_in_l H'0).
intros x H'; try assumption.
elim (in_part_union H').
auto with *.
intros H'0; try assumption.
elim (classic (in_part x A)).
auto with *.
intros H'1; try assumption.
cut (in_part x (diff B A)).
auto with *.
auto with *.
Qed.
Hint Resolve union_diff: algebra.

Lemma disjoint_diff : forall A B : part_set E, disjoint A (diff B A).
red in |- *.
intros A B; try assumption.
apply not_in_empty.
intros x; red in |- *; intros H'; try exact H'.
absurd (in_part x A).
apply diff_in_r with B.
auto with *.
apply in_part_inter_r with A; auto with *.
apply in_part_inter_l with (diff B A); auto with *.
Qed.
Hint Resolve disjoint_diff: algebra.

Lemma cardinal_union :
 forall (a b : nat) (A B : part_set E),
 cardinal A a -> cardinal (diff B A) b -> cardinal (union A B) (a + b).
intros.
apply cardinal_comp_l with (union A (diff B A)); auto with *.
Qed.
Hint Resolve cardinal_union: algebra.

Lemma empty_diff : forall A : part_set E, Equal (diff (empty E) A) (empty E).
intros A; try assumption.
apply in_eq_part.
intro.
intros H'; try assumption.
apply diff_in_l with A; auto with *.
intros x H'; try assumption.
absurd (in_part x (empty E)); auto with *.
Qed.
Hint Resolve empty_diff: algebra.

Lemma empty_inter :
 forall A : part_set E, Equal (inter (empty E) A) (empty E).
intros A; try assumption.
apply in_eq_part.
intros x H'; try assumption.
apply in_part_inter_l with A; auto with *.
intros x H'; try assumption.
absurd (in_part x (empty E)); auto with *.
Qed.
Hint Resolve empty_inter: algebra.

Lemma in_part_trans_eq :
 forall (A : part_set E) (x y : E), in_part x A -> Equal y x -> in_part y A.
intros A; case A; simpl in |- *.
intros a pa.
intros x y H' H'0; try assumption.
apply pa with x; auto with *.
Qed.

Lemma diff_add_part :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) -> in_part x B -> Equal (diff B0 B) (diff A B).
intros A B0 B x H' H'0 H'1; try assumption.
apply in_eq_part.
intros x0 H'2; try assumption.
apply in_diff.
apply in_part_comp_r with (add_part B0 x).
cut (in_part x0 B0).
unfold add_part in |- *.
auto with *.
apply diff_in_l with B; auto with *.
auto with *.
apply diff_in_r with B0; auto with *.
intros x0 H'2; try assumption.
elim (classic (Equal x0 x)).
intros H'3; try assumption.
absurd (in_part x B); auto with *.
cut (in_part x (diff A B)).
intros H'4; try assumption.
apply diff_in_r with A; auto with *.
apply in_part_trans_eq with x0; auto with *.
intros H'3; try assumption.
apply in_diff.
apply add_part_in_el_diff with x; auto with *.
apply in_part_comp_r with A; auto with *.
apply diff_in_l with B; auto with *.
apply diff_in_r with A; auto with *.
Qed.

Lemma diff_not_in :
 forall (A B : part_set E) (x : E), ~ in_part x A -> ~ in_part x (diff A B).
unfold not in |- *; intros.
apply H.
apply diff_in_l with B; auto with *.
Qed.
Hint Resolve diff_not_in: algebra.

Lemma inter_not_in :
 forall (A B : part_set E) (x : E), ~ in_part x A -> ~ in_part x (inter A B).
unfold not in |- *; intros.
apply H.
apply in_part_inter_l with B; auto with *.
Qed.
Hint Resolve inter_not_in: algebra.

Lemma inter_add_part :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) ->
 in_part x B -> Equal (inter A B) (add_part (inter B0 B) x).
unfold add_part in |- *.
intros A B0 B x H' H'0 H'1; try assumption.
apply Trans with (inter (union B0 (single x)) B).
auto with *.
apply Trans with (union (inter B0 B) (inter (single x) B)).
auto with *.
apply union_comp; auto with *.
apply in_eq_part.
intros x0 H'2; try assumption.
apply in_part_inter_l with B; auto with *.
intros x0 H'2; try assumption.
apply in_part_inter; auto with *.
apply in_part_trans_eq with x; auto with *.
Qed.
Hint Resolve inter_add_part: algebra.

Lemma diff_add_part_not_in :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) ->
 ~ in_part x B -> Equal (diff A B) (add_part (diff B0 B) x).
intros A B0 B x H' H'0 H'1; try assumption.
apply in_eq_part.
intros x0 H'2; try assumption.
elim (classic (Equal x0 x)).
intros H'3; try assumption.
apply in_part_trans_eq with x; auto with *.
intros H'3; try assumption.
unfold add_part in |- *.
apply in_part_union_or.
left.
apply in_diff.
apply add_part_in_el_diff with x; auto with *.
apply in_part_comp_r with A; auto with *.
apply diff_in_l with B; auto with *.
apply diff_in_r with A; auto with *.
intros x0 H'2; try assumption.
apply in_diff.
apply in_part_comp_r with (add_part B0 x); auto with *.
elim (classic (Equal x0 x)).
intros H'3; try assumption.
apply in_part_trans_eq with x; auto with *.
intros H'3; try assumption.
unfold add_part in |- *.
apply in_part_union_or.
left.
unfold add_part in H'2.
elim (in_part_union H'2).
intros H'4; try assumption.
apply diff_in_l with B; auto with *.
intros H'4; try assumption.
absurd (in_part x0 (single x)); auto with *.
elim (classic (Equal x0 x)).
intros H'3; try assumption.
unfold not in |- *; intros.
unfold not in H'1.
apply H'1.
apply in_part_trans_eq with x0; auto with *.
intros H'3; try assumption.
apply diff_in_r with B0; auto with *.
apply add_part_in_el_diff with x; auto with *.
Qed.
Hint Resolve diff_add_part_not_in: algebra.

Lemma inter_add_part_not_in :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) -> ~ in_part x B -> Equal (inter B0 B) (inter A B).
unfold add_part in |- *.
intros A B0 B x H' H'0 H'1; try assumption.
apply Trans with (inter (union B0 (single x)) B).
auto with *.
apply Trans with (union (inter B0 B) (inter (single x) B)).
apply Trans with (union (inter B0 B) (empty E)).
auto with *.
apply union_comp; auto with *.
apply Sym.
apply in_eq_part.
intros x0 H'2; try assumption.
cut (Equal x x0).
intros H'3; try assumption.
absurd (in_part x0 B).
unfold not in |- *; intro.
unfold not in H'1.
apply H'1.
apply in_part_trans_eq with x0; auto with *.
apply in_part_inter_r with (single x).
auto with *.
cut (in_part x0 (single x)).
auto with *.
apply in_part_inter_l with B.
auto with *.
intros x0 H'2; try assumption.
absurd (in_part x0 (empty E)); auto with *.
auto with *.
auto with *.
Qed.

Lemma cardinal_diff :
 forall (a : nat) (A B : part_set E),
 cardinal A a ->
 exists b : nat,
   (exists c : nat,
      cardinal (diff A B) b /\ cardinal (inter A B) c /\ a = b + c).
simple induction a; intros.
exists 0; intros.
exists 0; intros.
simpl in |- *.
split.
apply cardinal_empty.
apply Trans with (diff (empty E) B); auto with *.
split.
apply cardinal_empty.
apply Trans with (inter (empty E) B); auto with *.
auto with *.
inversion H0.
elim (H B0 B); intros.
case H6; clear H6; intros.
case H6; clear H6; intros.
case H7; clear H7; intros.
case (classic (in_part x B)); intros.
exists x0.
exists (S x1).
split.
apply cardinal_comp_l with (diff B0 B); auto with *.
apply diff_add_part with x; auto with *.
split.
apply cardinal_add with (inter B0 B) x; auto with *.
rewrite H8.
auto with *.
exists (S x0).
exists x1.
split.
apply cardinal_add with (diff B0 B) x; auto with *.
split.
apply cardinal_comp_l with (inter B0 B); auto with *.
apply inter_add_part_not_in with x; auto with *.
rewrite H8; auto with *.
auto with *.
Qed.

Lemma cardinal_union_inter :
 forall (A B : part_set E) (a b c : nat),
 cardinal A a ->
 cardinal B b -> cardinal (inter A B) c -> cardinal (union A B) (a + b - c).
intros.
case (cardinal_diff A H0); intros.
case H2; clear H2; intros.
case H2; clear H2; intros.
case H3; clear H3; intros.
apply cardinal_comp with (union A (diff B A)) (a + x); auto with *.
rewrite H4.
replace c with x0.
rewrite plus_assoc.
replace (a + x + x0) with (x0 + (a + x)); auto with *.
apply (cardinal_unique H3); auto with *.
apply cardinal_comp_l with (inter A B); auto with *.
Qed.
Hint Resolve cardinal_union_inter: algebra.
End fparts2_def.
