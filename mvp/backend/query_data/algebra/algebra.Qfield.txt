
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Zring.
(* Zring:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export ZArith.
Require Export ZArith.
Require Export auxiliary.
Require Export ZArith_dec.
Require Export Zmisc.
Hint Resolve Zle_refl: algebra.
Require Export Ring_util.
Require Export Integral_domain_facts.

Definition Zr_aux : RING.

Definition Zr : CRING.

Definition Zzero_dec :
  forall x : Zr, {Equal x (monoid_unit Zr)} + {~ Equal x (monoid_unit Zr)}.

Definition ZZ : INTEGRAL_DOMAIN. *)
Require Export Fraction_field.
(* Fraction_field:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Integral_domain_facts.
Require Export Cfield_cat.
Require Export Abelian_group_facts.
Require Export Ring_util.

Section Def.
Variable R : INTEGRAL_DOMAIN.
Variable diff10 : ~ Equal (ring_unit R) (monoid_unit R).
Set Strict Implicit.
Unset Implicit Arguments.

Record fraction : Type := 
  {num : R; den : R; den_prf : ~ Equal den (monoid_unit R)}.
Set Implicit Arguments.
Unset Strict Implicit.
Hint Resolve den_prf: algebra.

Definition eqfraction (x y : fraction) :=
  Equal (ring_mult (num x) (den y)) (ring_mult (num y) (den x)).

Lemma eqfraction_refl : reflexive eqfraction.

Definition fraction0 := Build_fraction (monoid_unit R) (ring_unit R) diff10.

Lemma eqfraction0 :
 forall x : fraction, eqfraction x fraction0 -> Equal (num x) (monoid_unit R).

Lemma eqfraction_num0 :
 forall x : fraction, Equal (num x) (monoid_unit R) -> eqfraction x fraction0.

Lemma eqfraction_sym : symmetric eqfraction.

Lemma eqfraction_trans : transitive eqfraction.

Definition fraction_set : SET.

Definition addfraction_fun (x y : fraction_set) : fraction_set :=
  Build_fraction
    (sgroup_law R (ring_mult (num x) (den y)) (ring_mult (num y) (den x)))
    (ring_mult (den x) (den y))
    (INTEGRAL_DOMAIN_prop_rev (den_prf x) (den_prf y)).

Definition opfraction_fun (x : fraction_set) : fraction_set :=
  Build_fraction (group_inverse R (num x)) (den x) (den_prf x).

Definition multfraction_fun (x y : fraction_set) : fraction_set :=
  Build_fraction (ring_mult (num x) (num y)) (ring_mult (den x) (den y))
    (INTEGRAL_DOMAIN_prop_rev (den_prf x) (den_prf y)).

Definition fraction1 : fraction_set :=
  Build_fraction (ring_unit R) (ring_unit R) diff10.

Lemma addfraction_law_l :
 forall x x' y : fraction_set,
 Equal x x' -> Equal (addfraction_fun x y) (addfraction_fun x' y).

Lemma addfraction_fun_com :
 forall x y : fraction_set, Equal (addfraction_fun x y) (addfraction_fun y x).

Lemma addfraction_law_r :
 forall x y y' : fraction_set,
 Equal y y' -> Equal (addfraction_fun x y) (addfraction_fun x y').

Lemma addfraction_law : fun2_compatible addfraction_fun.

Lemma multfraction_dist_l :
 forall x y z : fraction_set,
 Equal (multfraction_fun x (addfraction_fun y z))
   (addfraction_fun (multfraction_fun x y) (multfraction_fun x z)).

Lemma multfraction_com :
 forall x y : fraction_set,
 Equal (multfraction_fun x y) (multfraction_fun y x).

Definition fract_field_ring_aux : RING.

Definition fract_field_ring : CRING.
Variable
  zero_dec :
    forall x : R, {Equal x (monoid_unit R)} + {~ Equal x (monoid_unit R)}.

Definition invfraction_fun : fract_field_ring -> fract_field_ring :=
  fun x : fraction_set =>
  match zero_dec (num x) with
  | left _ => x
  | right n => Build_fraction (den x) (num x) n
  end.

Definition invfraction : MAP fract_field_ring fract_field_ring.

Let ff_inr_r :
  forall x : fract_field_ring,
  ~ Equal x (monoid_unit fract_field_ring) ->
  Equal (ring_mult x (Ap invfraction x)) (ring_unit fract_field_ring).

Hint Resolve ff_inr_r: algebra.

Let ff_field_on : field_on fract_field_ring.

Definition fraction_cfield := Build_cfield ff_field_on.
End Def. *)

Lemma Z_one_diff_zero : ~ Equal (ring_unit ZZ) (monoid_unit ZZ).
simpl in |- *.
unfold not in |- *; intros.
inversion H.
Qed.

Definition Q := fraction_cfield Z_one_diff_zero Zzero_dec.
