
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Cartesian.
(* Cartesian:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sets.

Section Def.
Variable E F : Setoid.
Comments "The type of elements of a cartesian product:".

Record cart_type : Type :=  {cart_l : E; cart_r : F}.
Comments "Equality of couples:".

Definition cart_eq (x y : cart_type) :=
  Equal (cart_l x) (cart_l y) /\ Equal (cart_r x) (cart_r y).

Lemma cart_eq_equiv : equivalence cart_eq.

Definition cart : Setoid := Build_Setoid cart_eq_equiv.
Comments "We will denote the cartesian product of" E "and" F "with"
  (cart E F).
End Def.
Section Projections.
Variable E F : Setoid.

Definition proj1 (x : cart E F) : E := cart_l x.

Definition proj2 (x : cart E F) : F := cart_r x.
Comments "We note" (proj1 x) "and" (proj2 x) "the components of a couple" x
  "in " (cart E F).

Lemma proj1_comp :
 forall x y : cart E F, Equal x y -> Equal (proj1 x) (proj1 y).

Lemma proj2_comp :
 forall x y : cart E F, Equal x y -> Equal (proj2 x) (proj2 y).
Hint Resolve proj1_comp proj2_comp: algebra.

Definition proj1_map : MAP (cart E F) E := Build_Map proj1_comp.

Definition proj2_map : MAP (cart E F) F := Build_Map proj2_comp.

Definition couple (x : E) (y : F) : cart E F := Build_cart_type x y.

Lemma couple_comp :
 forall (x x' : E) (y y' : F),
 Equal x x' -> Equal y y' -> Equal (couple x y) (couple x' y').
Hint Resolve couple_comp: algebra.

Lemma coupl_proj : forall x : cart E F, Equal (couple (proj1 x) (proj2 x)) x.
Hint Resolve coupl_proj: algebra.
End Projections.
Section Maps.
Variable E F G : Setoid.

Definition curry (f : MAP (cart E F) G) (x : E) (y : F) := f (couple x y).

Definition fun2_compatible (f : E -> F -> G) :=
  forall (x x' : E) (y y' : F),
  Equal x x' -> Equal y y' -> Equal (f x y) (f x' y').

Definition uncurry :
  forall f : E -> F -> G, fun2_compatible f -> MAP (cart E F) G.
Variable f : MAP E (cart F G).

Definition map_proj1 : MAP E F := comp_map_map (proj1_map F G) f.

Definition map_proj2 : MAP E G := comp_map_map (proj2_map F G) f.

Definition map_couple : MAP E F -> MAP E G -> MAP E (cart F G).

Lemma map_couple_proj_prop : Equal (map_couple map_proj1 map_proj2) f.
End Maps.
Hint Resolve proj1_comp proj2_comp couple_comp coupl_proj
  map_couple_proj_prop: algebra. *)

Comments "Some basic category theory.".
Section Category_def.
Section Category_def1.
Variable Ob : Type.
Variable Hom : Ob -> Ob -> Setoid.
Variable
  Hom_comp : forall a b c : Ob, MAP (cart (Hom b c) (Hom a b)) (Hom a c).
Variable Hom_id : forall a : Ob, Hom a a.

Definition Hom_comp_assoc :=
  forall (a b c d : Ob) (f : Hom a b) (g : Hom b c) (h : Hom c d),
  Equal (Hom_comp a b d (couple (Hom_comp b c d (couple h g)) f))
    (Hom_comp a c d (couple h (Hom_comp a b c (couple g f)))).

Definition Hom_comp_unit_l :=
  forall (a b : Ob) (f : Hom a b),
  Equal (Hom_comp a b b (couple (Hom_id b) f)) f.

Definition Hom_comp_unit_r :=
  forall (a b : Ob) (f : Hom a b),
  Equal (Hom_comp a a b (couple f (Hom_id a))) f.
End Category_def1.

Record category : Type := 
  {Ob :> Type;
   Hom : Ob -> Ob -> Setoid;
   Hom_comp : forall a b c : Ob, MAP (cart (Hom b c) (Hom a b)) (Hom a c);
   Hom_id : forall a : Ob, Hom a a;
   Hom_comp_assoc_prf : Hom_comp_assoc Hom_comp;
   Hom_comp_unit_l_prf : Hom_comp_unit_l Hom_comp Hom_id;
   Hom_comp_unit_r_prf : Hom_comp_unit_r Hom_comp Hom_id}.
Section Category_comp.
Variable C : category.

Definition comp_hom (a b c : C) (g : Hom b c) (f : Hom a b) :=
  Hom_comp a b c (couple g f).

Lemma comp_hom_compatible :
 forall (a b c : C) (x x' : Hom b c) (y y' : Hom a b),
 Equal x x' -> Equal y y' -> Equal (comp_hom x y) (comp_hom x' y').
intros a b c x x' y y' H' H'0; try assumption.
unfold comp_hom in |- *; auto with algebra.
Qed.

Lemma comp_hom_assoc :
 forall (a b c d : C) (f : Hom a b) (g : Hom b c) (h : Hom c d),
 Equal (comp_hom (comp_hom h g) f) (comp_hom h (comp_hom g f)).
exact (Hom_comp_assoc_prf (c:=C)).
Qed.

Lemma comp_hom_unit_l :
 forall (a b : C) (f : Hom a b), Equal (comp_hom (Hom_id b) f) f.
exact (Hom_comp_unit_l_prf (c:=C)).
Qed.

Lemma comp_hom_unit_r :
 forall (a b : C) (f : Hom a b), Equal (comp_hom f (Hom_id a)) f.
exact (Hom_comp_unit_r_prf (c:=C)).
Qed.
End Category_comp.
Hint Resolve comp_hom_compatible comp_hom_assoc comp_hom_unit_l
  comp_hom_unit_r: algebra.
Section Full_subcat_def.
Variable C : category.
Variable C' : Type.
Variable i : C' -> C.

Definition fsubcat_Hom (a b : C') := Hom (i a) (i b).

Definition fsubcat_Hom_comp :
  forall a b c : C',
  MAP (cart (fsubcat_Hom b c) (fsubcat_Hom a b)) (fsubcat_Hom a c).
intros a b c; try assumption.
exact (Hom_comp (i a) (i b) (i c)).
Defined.

Definition fsubcat_Hom_id (a : C') := Hom_id (i a).

Definition full_subcat : category.
apply
 (Build_category (Ob:=C') (Hom:=fsubcat_Hom) (Hom_comp:=fsubcat_Hom_comp)
    (Hom_id:=fsubcat_Hom_id)).
red in |- *.
unfold fsubcat_Hom, fsubcat_Hom_comp in |- *; simpl in |- *.
intros a b c d f g h; try assumption.
apply (Hom_comp_assoc_prf (c:=C)).
red in |- *.
unfold fsubcat_Hom, fsubcat_Hom_comp, fsubcat_Hom_id in |- *; simpl in |- *.
intros a b f; try assumption.
apply (Hom_comp_unit_l_prf (c:=C)).
red in |- *.
unfold fsubcat_Hom, fsubcat_Hom_comp, fsubcat_Hom_id in |- *; simpl in |- *.
intros a b f; try assumption.
apply (Hom_comp_unit_r_prf (c:=C)).
Defined.
End Full_subcat_def.
End Category_def.
Hint Resolve comp_hom_compatible comp_hom_assoc comp_hom_unit_l
  comp_hom_unit_r: algebra.