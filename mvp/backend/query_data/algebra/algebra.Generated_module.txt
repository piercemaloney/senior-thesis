
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_kernel.
(* Module_kernel:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_util.
Require Export Sub_module.
Require Export Group_kernel.

Section Def.
Variable R : RING.
Variable Mod Mod2 : MODULE R.
Variable f : Hom Mod Mod2.

Definition Ker : submodule Mod.

Definition coKer : submodule Mod2.

Lemma Ker_prop :
 forall x : Mod, in_part x Ker -> Equal (f x) (monoid_unit Mod2).

Lemma Ker_prop_rev :
 forall x : Mod, Equal (f x) (monoid_unit Mod2) -> in_part x Ker.

Lemma coKer_prop : forall x : Mod, in_part (f x) coKer.
End Def.
Hint Resolve Ker_prop coKer_prop: algebra. *)
Require Export Free_module.
(* Free_module:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_util.
Require Export Module_facts.
Section Free_Module_def.
Variable R : RING.
Variable V : SET.

Inductive FMd : Type :=
  | Var : V -> FMd
  | Law : FMd -> FMd -> FMd
  | Unit : FMd
  | Inv : FMd -> FMd
  | Op : R -> FMd -> FMd.

Inductive eqFMd : FMd -> FMd -> Prop :=
  | eqFMd_Var : forall x y : V, Equal x y -> (eqFMd (Var x) (Var y):Prop)
  | eqFMd_law :
      forall x x' y y' : FMd,
      eqFMd x x' -> eqFMd y y' -> (eqFMd (Law x y) (Law x' y'):Prop)
  | eqFMd_law_assoc :
      forall x y z : FMd, eqFMd (Law (Law x y) z) (Law x (Law y z)):Prop
  | eqFMd_law0r : forall x : FMd, eqFMd (Law x Unit) x:Prop
  | eqFMd_inv : forall x y : FMd, eqFMd x y -> eqFMd (Inv x) (Inv y)
  | eqFMd_invr : forall x : FMd, eqFMd (Law x (Inv x)) Unit
  | eqFMd_refl : forall x : FMd, eqFMd x x:Prop
  | eqFMd_sym : forall x y : FMd, eqFMd x y -> (eqFMd y x:Prop)
  | eqFMd_trans :
      forall x y z : FMd, eqFMd x y -> eqFMd y z -> (eqFMd x z:Prop)
  | eqFMd_com : forall x y : FMd, eqFMd (Law x y) (Law y x)
  | eqFMd_op_comp :
      forall (a b : R) (x y : FMd),
      Equal a b -> eqFMd x y -> (eqFMd (Op a x) (Op b y):Prop)
  | eqFMd_oplin_l :
      forall (a b : R) (x : FMd),
      eqFMd (Op (sgroup_law R a b) x) (Law (Op a x) (Op b x))
  | eqFMd_oplin_r :
      forall (a : R) (x y : FMd),
      eqFMd (Op a (Law x y)) (Law (Op a x) (Op a y))
  | eqFMd_op_assoc :
      forall (a b : R) (x : FMd),
      eqFMd (Op a (Op b x)) (Op (ring_mult a b) x)
  | eqFMd_op_unit : forall x : FMd, eqFMd (Op (ring_unit R) x) x.
Hint Resolve eqFMd_Var eqFMd_law eqFMd_law_assoc eqFMd_law0r eqFMd_invr
  eqFMd_refl: algebra.
Hint Immediate eqFMd_sym: algebra.

Lemma eqFMd_Equiv : equivalence eqFMd.

Definition FMd_set := Build_Setoid eqFMd_Equiv.

Definition FreeModule : MODULE R.
Section Universal_prop.
Variable Mod : MODULE R.
Variable f : Hom V Mod.

Fixpoint FMd_lift_fun (p : FreeModule) : Mod :=
  match p with
  | Var v => f v
  | Law p1 p2 => sgroup_law Mod (FMd_lift_fun p1) (FMd_lift_fun p2)
  | Unit => monoid_unit Mod
  | Inv p1 => group_inverse Mod (FMd_lift_fun p1)
  | Op a p1 => module_mult a (FMd_lift_fun p1)
  end.

Definition FMd_lift : Hom FreeModule Mod.

Definition FMd_var : Hom V FreeModule.

Lemma FMd_comp_prop :
 Equal f (comp_hom (FMd_lift:Hom (FreeModule:SET) Mod) FMd_var).
End Universal_prop.
End Free_Module_def.
Hint Resolve FMd_comp_prop: algebra. *)
Section Generated_module_def.
Variable R : RING.
Variable Mod : MODULE R.
Variable A : part_set Mod.

Definition generated_module : submodule Mod := coKer (FMd_lift (inj_part A)).
End Generated_module_def.

Lemma generated_module_minimal :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (H : submodule Mod),
 included A H -> included (generated_module A) H.
unfold included in |- *.
simpl in |- *.
intros R Mod A H H' x H'0; try assumption.
elim H'0; intros x0; clear H'0.
generalize x; clear x.
elim x0.
intros c; try assumption.
elim c.
simpl in |- *.
intros y subtype_prf x H'0; elim H'0; intros H'1 H'2; try exact H'2;
 clear H'0.
apply in_part_comp_l with y; auto with algebra.
intros f H'0 f0 H'1 x H'2; elim H'2; intros H'3 H'4; try exact H'4; clear H'2.
simpl in H'4.
apply
 in_part_comp_l
  with
    (sgroup_law Mod (FMd_lift_fun (inj_part A) f)
       (FMd_lift_fun (inj_part A) f0)); auto with algebra.
simpl in |- *.
intros x H'0; elim H'0; intros H'1 H'2; try exact H'2; clear H'0.
apply in_part_comp_l with (monoid_unit Mod); auto with algebra.
intros f H'0 x H'1; try assumption.
elim H'1; intros H'2 H'3; simpl in H'3; clear H'1.
apply in_part_comp_l with (group_inverse Mod (FMd_lift_fun (inj_part A) f));
 auto with algebra.
intros c f H'0 x H'1; try assumption.
simpl in H'1.
elim H'1; intros H'2 H'3; try exact H'3; clear H'1.
apply in_part_comp_l with (module_mult c (FMd_lift_fun (inj_part A) f));
 auto with algebra.
Qed.

Lemma generated_module_prop_included :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod),
 included A (generated_module A).
unfold included in |- *.
simpl in |- *.
intros R Mod A x H'; try assumption.
exists (Var R (V:=A) (Build_subtype (E:=Mod) (P:=A) (subtype_elt:=x) H'));
 split; [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
auto with algebra.
Qed.

Lemma generated_module_prop :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (y : Mod),
 in_part y (generated_module A) ->
 exists x : FMd R A, Equal y (FMd_lift (inj_part A) x).
simpl in |- *; auto with algebra.
intros R Mod A y H'; try assumption.
elim H'; intros x E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists x; try assumption.
Qed.

Lemma generated_module_prop_rev :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (y : Mod),
 (exists x : FMd R A, Equal y (FMd_lift (inj_part A) x)) ->
 in_part y (generated_module A).
intros R Mod A y H'; try assumption.
elim H'; intros x E; try exact E; clear H'.
simpl in |- *; auto with algebra.
exists x; split; [ idtac | try assumption ].
auto with algebra.
Qed.
Hint Resolve generated_module_minimal generated_module_prop_included
  generated_module_prop_rev: algebra.
