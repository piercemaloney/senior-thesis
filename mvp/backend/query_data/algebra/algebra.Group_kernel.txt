
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
(* Group_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_group.
Require Export Abelian_group_cat.

Section Group.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.

Lemma geninvl : forall x : E, Equal (genlaw (geninv x) x) e.
Hint Resolve geninvl: algebra.

Lemma eunitgenlawl : forall x : E, Equal (genlaw e x) x.
Hint Resolve eunitgenlawl: algebra.

Definition f := uncurry fcomp.

Lemma fassoc : associative f.

Lemma eunitr : unit_r f e.

Lemma eunitl : unit_l f e.

Definition inv := Build_Map (Ap:=geninv) invcomp.

Lemma invr : inverse_r f e inv.

Lemma invl : inverse_l f e inv.

Definition sg := Build_sgroup (Build_sgroup_on fassoc).

Definition m :=
  Build_monoid (Build_monoid_on (A:=sg) (monoid_unit:=e) eunitr eunitl).

Definition BUILD_GROUP : GROUP :=
  Build_group (Build_group_on (G:=m) (group_inverse_map:=inv) invr invl).
End Group.
Section Abelian_group.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).

Definition G := BUILD_GROUP fcomp genlawassoc eunitgenlawr invcomp geninvr.

Definition asg : abelian_sgroup.

Definition BUILD_ABELIAN_GROUP : ABELIAN_GROUP :=
  Build_abelian_group
    (Build_abelian_group_on (G:=G)
       (Build_abelian_monoid (Build_abelian_monoid_on (M:=G) asg))).
End Abelian_group.
Section Hom.
Variable G G' : GROUP.
Variable ff : G -> G'.
Hypothesis ffcomp : forall x y : G, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : G,
    Equal (ff (sgroup_law _ x y)) (sgroup_law _ (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit G)) (monoid_unit G').

Definition f2 := Build_Map ffcomp.

Definition fhomsg := Build_sgroup_hom (sgroup_map:=f2) fflaw.

Definition BUILD_HOM_GROUP : Hom G G' :=
  Build_monoid_hom (monoid_sgroup_hom:=fhomsg) ffunit.
End Hom.
Section Build_sub_group.
Variable G : GROUP.
Variable H : part_set G.
Hypothesis
  Hlaw :
    forall x y : G,
    in_part x H -> in_part y H -> in_part (sgroup_law _ x y) H.
Hypothesis Hunit : in_part (monoid_unit G) H.
Hypothesis Hinv : forall x : G, in_part x H -> in_part (group_inverse _ x) H.

Definition BUILD_SUB_GROUP : subgroup G :=
  Build_subgroup (G:=G)
    (subgroup_submonoid:=Build_submonoid (G:=G)
                           (submonoid_subsgroup:=Build_subsgroup Hlaw) Hunit)
    Hinv.
End Build_sub_group. *)
Require Export Group_quotient.
(* Group_quotient:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_group.
Require Export Group_util.

Section Def.
Variable G : GROUP.
Variable H : subgroup G.

Definition normal :=
  forall x y : G,
  in_part y H ->
  in_part (sgroup_law _ x (sgroup_law _ y (group_inverse _ x))) H.
Hypothesis Hnormal : normal.

Definition group_quo_eq (x y : G) :=
  in_part (sgroup_law _ x (group_inverse _ y)) H.

Definition group_quo_eqrel : Relation G.

Lemma group_quo_eqrel_equiv : equivalence group_quo_eqrel.

Definition group_quo_set := quotient G group_quo_eqrel group_quo_eqrel_equiv.

Lemma normal_com_in :
 forall x y : G, in_part (sgroup_law _ x y) H -> in_part (sgroup_law _ y x) H.
Hint Immediate normal_com_in: algebra.
Set Strict Implicit.
Unset Implicit Arguments.

Definition group_quo : group.
Set Implicit Arguments.
Unset Strict Implicit.

Definition group_quo_surj : Hom G group_quo.
End Def.
Hint Immediate normal_com_in: algebra. *)
Require Export Parts2.
(* Parts2:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Classical_Prop.
Require Export Parts.

Comments "We define here complement of a part, image of a part by a map.".
Section Complement1.
Variable E : Setoid.

Lemma not_in_comp_l :
 forall (E : Setoid) (A : part_set E) (x y : E),
 ~ in_part x A -> Equal y x -> ~ in_part y A.

Lemma not_in_comp_r :
 forall (E : Setoid) (A B : part_set E) (x : E),
 ~ in_part x A -> Equal A B -> ~ in_part x B.

Definition compl : part_set E -> part_set E.

Lemma compl_in :
 forall (A : part_set E) (x : E), ~ in_part x A -> in_part x (compl A).
Hint Resolve compl_in: algebra.

Lemma in_compl :
 forall (A : part_set E) (x : E), in_part x (compl A) -> ~ in_part x A.

Lemma compl_comp :
 forall A B : part_set E, Equal A B -> Equal (compl A) (compl B).
Hint Resolve compl_comp: algebra.

Lemma compl_comp_rev :
 forall A B : part_set E, Equal (compl A) (compl B) -> Equal A B.

Lemma compl_compl : forall A : part_set E, Equal (compl (compl A)) A.
Hint Resolve compl_compl: algebra.

Lemma compl_not_in :
 forall (A : part_set E) (x : E), in_part x A -> ~ in_part x (compl A).
Hint Resolve compl_not_in: algebra.

Lemma not_in_compl :
 forall (A : part_set E) (x : E), in_part x (compl A) -> ~ in_part x A.

Lemma compl_included :
 forall A B : part_set E, included A B -> included (compl B) (compl A).

Lemma compl_not_compl :
 forall (A : part_set E) (x : E), in_part x A \/ in_part x (compl A).
End Complement1.
Hint Resolve compl_included compl_not_in compl_compl compl_comp compl_in:
  algebra.
Section Images1.
Variable E F : Setoid.
Variable f : MAP E F.

Definition image : part_set E -> part_set F.

Lemma image_in :
 forall (A : part_set E) (y : F),
 in_part y (image A) -> exists x : E, in_part x A /\ Equal y (f x).

Lemma in_image :
 forall (A : part_set E) (x : E) (y : F),
 in_part x A -> Equal y (f x) -> in_part y (image A).
Hint Resolve in_image: algebra.

Lemma image_included :
 forall A B : part_set E, included A B -> included (image A) (image B).
Hint Resolve image_included: algebra.

Lemma image_comp :
 forall A B : part_set E, Equal A B -> Equal (image A) (image B).
Hint Resolve image_comp: algebra.

Lemma image_in_image :
 forall (A : part_set E) (x : E), in_part x A -> in_part (f x) (image A).
Hint Resolve image_in_image: algebra.

Definition image_map := image (full E).

Let surj_set_image_fun : E -> image_map.

Definition surj_set_image : MAP E image_map.

Lemma surj_set_image_surjective : surjective surj_set_image.

Let surj_part_image_fun : forall A : part_set E, A -> image A.

Definition surj_part_image : forall A : part_set E, MAP A (image A).

Lemma surj_part_image_surjective :
 forall A : part_set E, surjective (surj_part_image A).
End Images1.
Hint Resolve in_image image_included image_comp image_in_image
  surj_set_image_surjective surj_part_image_surjective: algebra. *)

Section Def.
Variable G G' : GROUP.
Variable f : Hom G G'.

Definition kernel_part : part_set G.
apply
 (Build_Predicate (E:=G)
    (Pred_fun:=fun x : G => Equal (f x) (monoid_unit G'))).
red in |- *.
intros x y H' H'0; try assumption.
apply Trans with (Ap (sgroup_map (monoid_sgroup_hom f)) x); auto with algebra.
Defined.

Definition Ker : subgroup G.
apply (BUILD_SUB_GROUP (G:=G) (H:=kernel_part)).
simpl in |- *.
intros x y H' H'0; try assumption.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (Ap (sgroup_map (monoid_sgroup_hom f)) y)); 
 auto with algebra.
apply Trans with (sgroup_law G' (monoid_unit G') (monoid_unit G'));
 auto with algebra.
simpl in |- *.
auto with algebra.
simpl in |- *.
intros x H'; try assumption.
apply Trans with (group_inverse _ (Ap (sgroup_map (monoid_sgroup_hom f)) x));
 auto with algebra.
apply Trans with (group_inverse _ (monoid_unit G')); auto with algebra.
Defined.

Definition coKer : subgroup G'.
apply (BUILD_SUB_GROUP (G:=G') (H:=image f (full G))).
intros x y H' H'0; try assumption.
elim H'0; intros x0 E; elim E; intros H'1 H'2; try exact H'2; clear E H'0.
elim H'; intros x1 E; elim E; intros H'0 H'3; try exact H'3; clear E H'.
exists (sgroup_law _ x1 x0); split; [ try assumption | idtac ].
apply
 Trans
  with
    (sgroup_law G' (Ap (sgroup_map (monoid_sgroup_hom f)) x1)
       (Ap (sgroup_map (monoid_sgroup_hom f)) x0)); 
 auto with algebra.
simpl in |- *.
exists (monoid_unit G); auto with algebra.
simpl in |- *.
intros x H'; try assumption.
elim H'; intros x0 E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists (group_inverse _ x0); split; [ try assumption | idtac ].
apply
 Trans with (group_inverse G' (Ap (sgroup_map (monoid_sgroup_hom f)) x0));
 auto with algebra.
Defined.

Lemma kernel_normal : normal Ker.
red in |- *.
simpl in |- *.
intros x y H'; try assumption.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (Ap (sgroup_map (monoid_sgroup_hom f))
          (sgroup_law G y (group_inverse G x)))); auto with algebra.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) y)
          (Ap (sgroup_map (monoid_sgroup_hom f)) (group_inverse G x))));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) y)
          (group_inverse _ (Ap (sgroup_map (monoid_sgroup_hom f)) x))));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (sgroup_law _ (monoid_unit G')
          (group_inverse _ (Ap (sgroup_map (monoid_sgroup_hom f)) x))));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)
       (group_inverse _ (Ap (sgroup_map (monoid_sgroup_hom f)) x)));
 auto with algebra.
Qed.
Set Strict Implicit.
Unset Implicit Arguments.

Definition group_quo_ker := group_quo G Ker kernel_normal.
Set Implicit Arguments.
Unset Strict Implicit.

Lemma Ker_prop : forall x : G, in_part x Ker -> Equal (f x) (monoid_unit G').
auto with algebra.
Qed.

Lemma Ker_prop_rev :
 forall x : G, Equal (f x) (monoid_unit G') -> in_part x Ker.
auto with algebra.
Qed.

Lemma coKer_prop : forall x : G, in_part (f x) coKer.
simpl in |- *.
intros x; exists x; split; [ idtac | try assumption ]; auto with algebra.
Qed.
End Def.
Hint Resolve kernel_normal Ker_prop coKer_prop: algebra.