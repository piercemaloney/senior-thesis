
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_cat.
(* Monoid_cat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sgroup_cat.

Section Unit.
Variable E : SET.
Variable f : law_of_composition E.
Variable e : E.

Definition unit_r := forall x : E, Equal (f (couple x e)) x.

Definition unit_l := forall x : E, Equal (f (couple e x)) x.
End Unit.

Record monoid_on (A : sgroup) : Type := 
  {monoid_unit : A;
   monoid_unit_r_prf : unit_r (sgroup_law_map A) monoid_unit;
   monoid_unit_l_prf : unit_l (sgroup_law_map A) monoid_unit}.

Record monoid : Type := 
  {monoid_sgroup :> sgroup; monoid_on_def :> monoid_on monoid_sgroup}.
Coercion Build_monoid : monoid_on >-> monoid.
Section Hom.
Variable E F : monoid.

Definition monoid_hom_prop (f : E -> F) :=
  Equal (f (monoid_unit E)) (monoid_unit F).

Record monoid_hom : Type := 
  {monoid_sgroup_hom :> sgroup_hom E F;
   monoid_hom_prf : monoid_hom_prop monoid_sgroup_hom}.
End Hom.

Definition monoid_hom_comp :
  forall E F G : monoid, monoid_hom F G -> monoid_hom E F -> monoid_hom E G.

Definition monoid_id : forall E : monoid, monoid_hom E E.

Definition MONOID : category. *)
Require Export Sgroup_facts.
(* Sgroup_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sgroup_cat.
Section Lemmas.
Variable E : SGROUP.

Lemma SGROUP_assoc :
 forall x y z : E,
 Equal (sgroup_law _ (sgroup_law _ x y) z)
   (sgroup_law _ x (sgroup_law _ y z)).

Lemma SGROUP_comp :
 forall x x' y y' : E,
 Equal x x' -> Equal y y' -> Equal (sgroup_law _ x y) (sgroup_law _ x' y').
Variable F : SGROUP.
Variable f : Hom E F.

Lemma SGROUP_hom_prop :
 forall x y : E, Equal (f (sgroup_law _ x y)) (sgroup_law _ (f x) (f y)).
End Lemmas.
Hint Resolve SGROUP_assoc SGROUP_comp SGROUP_hom_prop: algebra. *)
Require Export Monoid_facts.
(* Monoid_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Monoid_cat.
Section Lemmas.
Variable E : MONOID.

Lemma MONOID_unit_r : forall x : E, Equal (sgroup_law _ x (monoid_unit E)) x.

Lemma MONOID_unit_l : forall x : E, Equal (sgroup_law _ (monoid_unit E) x) x.

Lemma MONOID_unit_unique :
 forall e : E,
 (forall x : E, Equal (sgroup_law _ x e) x) ->
 (forall x : E, Equal (sgroup_law _ e x) x) -> Equal e (monoid_unit E).
Variable F : MONOID.
Variable f : Hom E F.

Lemma MONOID_hom_prop : Equal (f (monoid_unit E)) (monoid_unit F).
End Lemmas.
Hint Resolve MONOID_unit_r MONOID_unit_l MONOID_unit_unique MONOID_hom_prop:
  algebra. *)
Require Export Monoid_util.
(* Monoid_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_monoid.
Require Export Abelian_group_cat.

Section Monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.

Definition f := uncurry fcomp.

Lemma fassoc : associative f.

Lemma eunitr : unit_r f e.

Lemma eunitl : unit_l f e.

Definition sg := Build_sgroup (Build_sgroup_on fassoc).

Definition BUILD_MONOID : MONOID :=
  Build_monoid (Build_monoid_on (A:=sg) (monoid_unit:=e) eunitr eunitl).
End Monoid.
Section Abelian_monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).

Definition M := BUILD_MONOID fcomp genlawassoc eunitgenlawr eunitgenlawl.

Definition asg : abelian_sgroup.

Definition BUILD_ABELIAN_MONOID : ABELIAN_MONOID :=
  Build_abelian_monoid (Build_abelian_monoid_on (M:=M) asg).
End Abelian_monoid.
Section Hom.
Variable G G' : MONOID.
Variable ff : G -> G'.
Hypothesis ffcomp : forall x y : G, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : G,
    Equal (ff (sgroup_law _ x y)) (sgroup_law _ (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit G)) (monoid_unit G').

Definition f2 := Build_Map ffcomp.

Definition fhomsg := Build_sgroup_hom (sgroup_map:=f2) fflaw.

Definition BUILD_HOM_MONOID : Hom G G' :=
  Build_monoid_hom (monoid_sgroup_hom:=fhomsg) ffunit.
End Hom.
Section Build_sub_monoid.
Variable G : MONOID.
Variable H : part_set G.
Hypothesis
  Hlaw :
    forall x y : G,
    in_part x H -> in_part y H -> in_part (sgroup_law _ x y) H.
Hypothesis Hunit : in_part (monoid_unit G) H.

Definition BUILD_SUB_MONOID : submonoid G :=
  Build_submonoid (G:=G) (submonoid_subsgroup:=Build_subsgroup Hlaw) Hunit.
End Build_sub_monoid. *)
Section Free_monoid_def.
Variable V : SET.

Inductive FM : Type :=
  | Var : V -> FM
  | Law : FM -> FM -> FM
  | Unit : FM.

Inductive eqFM : FM -> FM -> Prop :=
  | eqFM_Var : forall x y : V, Equal x y -> (eqFM (Var x) (Var y):Prop)
  | eqFM_law :
      forall x x' y y' : FM,
      eqFM x x' -> eqFM y y' -> (eqFM (Law x y) (Law x' y'):Prop)
  | eqFM_law_assoc :
      forall x y z : FM, eqFM (Law (Law x y) z) (Law x (Law y z)):Prop
  | eqFM_law0r : forall x : FM, eqFM (Law x Unit) x:Prop
  | eqFM_law0l : forall x : FM, eqFM (Law Unit x) x:Prop
  | eqFM_refl : forall x : FM, eqFM x x:Prop
  | eqFM_sym : forall x y : FM, eqFM x y -> (eqFM y x:Prop)
  | eqFM_trans : forall x y z : FM, eqFM x y -> eqFM y z -> (eqFM x z:Prop).
Hint Resolve eqFM_Var eqFM_law eqFM_law_assoc eqFM_law0r eqFM_law0l
  eqFM_refl: algebra.
Hint Immediate eqFM_sym: algebra.

Lemma eqFM_Equiv : equivalence eqFM.
red in |- *.
split; [ try assumption | idtac ].
exact eqFM_refl.
red in |- *.
split; [ try assumption | idtac ].
exact eqFM_trans.
exact eqFM_sym.
Qed.

Definition FM_set := Build_Setoid eqFM_Equiv.

Definition FreeMonoid : MONOID.
apply (BUILD_MONOID (E:=FM_set) (genlaw:=Law) (e:=Unit)).
exact eqFM_law.
exact eqFM_law_assoc.
exact eqFM_law0r.
exact eqFM_law0l.
Defined.
Section Universal_prop.
Variable M : MONOID.
Variable f : Hom V M.

Fixpoint FM_lift_fun (p : FreeMonoid) : M :=
  match p with
  | Var v => f v
  | Law p1 p2 => sgroup_law _ (FM_lift_fun p1) (FM_lift_fun p2)
  | Unit => monoid_unit M
  end.

Definition FM_lift : Hom FreeMonoid M.
apply (BUILD_HOM_MONOID (G:=FreeMonoid) (G':=M) (ff:=FM_lift_fun)).
intros x y H'; try assumption.
elim H'; simpl in |- *; auto with algebra.
intros x0 y0 z H'0 H'1 H'2 H'3; try assumption.
apply Trans with (FM_lift_fun y0); auto with algebra.
simpl in |- *; auto with algebra.
simpl in |- *; auto with algebra.
Defined.

Definition FM_var : Hom V FreeMonoid.
apply (Build_Map (A:=V) (B:=FreeMonoid) (Ap:=Var)).
red in |- *.
simpl in |- *; auto with algebra.
Defined.

Lemma FM_comp_prop :
 Equal f (comp_hom (FM_lift:Hom (FreeMonoid:SET) M) FM_var).
simpl in |- *.
red in |- *.
simpl in |- *.
auto with algebra.
Qed.
End Universal_prop.
End Free_monoid_def.
Hint Resolve FM_comp_prop: algebra.