
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_util.
(* Module_util:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_cat.
Require Export Monoid_util.
Require Export Group_util.

Section Module.
Variable R : RING.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Variable gen_module_op : R -> E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).
Hypothesis
  op_comp :
    forall (a b : R) (x y : E),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : E),
    Equal (gen_module_op (sgroup_law R a b) x)
      (genlaw (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : E),
    Equal (gen_module_op a (genlaw x y))
      (genlaw (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : E),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis opunit : forall x : E, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el : forall a : R, Endo_SET E.

Definition module_util_op : operation (ring_monoid R) E.

Definition module_util_G : ABELIAN_GROUP.

Definition BUILD_MODULE : MODULE R.
End Module.
Section Hom.
Variable R : RING.
Variable Mod Mod' : MODULE R.
Variable ff : Mod -> Mod'.
Hypothesis ffcomp : forall x y : Mod, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : Mod,
    Equal (ff (sgroup_law Mod x y)) (sgroup_law Mod' (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit Mod)) (monoid_unit Mod').
Hypothesis
  ffop :
    forall (a : R) (x : Mod),
    Equal (ff (module_mult a x)) (module_mult a (ff x)).

Definition BUILD_HOM_MODULE : Hom Mod Mod' :=
  Build_module_hom
    (module_monoid_hom:=BUILD_HOM_GROUP (G:=Mod) (G':=Mod') (ff:=ff) ffcomp
                          fflaw ffunit) ffop.
End Hom.
Section Module_on_group.
Variable R : RING.
Variable module_util_G : ABELIAN_GROUP.
Variable gen_module_op : R -> module_util_G -> module_util_G.
Hypothesis
  op_comp :
    forall (a b : R) (x y : module_util_G),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op (sgroup_law R a b) x)
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : module_util_G),
    Equal (gen_module_op a (sgroup_law module_util_G x y))
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis
  opunit : forall x : module_util_G, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el2 : forall a : R, Endo_SET module_util_G.

Definition module_util_op2 : operation (ring_monoid R) module_util_G.

Definition BUILD_MODULE_GROUP : MODULE R.
End Module_on_group. *)
Require Export Module_facts.
(* Module_facts:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_cat.
Require Export Abelian_group_facts.
Section Lemmas.
Variable R : RING.
Variable Mod : MODULE R.

Lemma MODULE_comp :
 forall (a b : R) (x y : Mod),
 Equal a b -> Equal x y -> Equal (module_mult a x) (module_mult b y).

Lemma MODULE_assoc :
 forall (a b : R) (x : Mod),
 Equal (module_mult (ring_mult a b) x) (module_mult a (module_mult b x)).

Lemma MODULE_dist_r :
 forall (a b : R) (x : Mod),
 Equal (module_mult (sgroup_law R a b) x)
   (sgroup_law Mod (module_mult a x) (module_mult b x)).

Lemma MODULE_dist_l :
 forall (a : R) (x y : Mod),
 Equal (module_mult a (sgroup_law Mod x y))
   (sgroup_law Mod (module_mult a x) (module_mult a y)).

Lemma MODULE_unit_l : forall x : Mod, Equal (module_mult (ring_unit R) x) x.
Hint Resolve MODULE_comp MODULE_dist_r MODULE_dist_l MODULE_assoc
  MODULE_unit_l: algebra.

Lemma MODULE_absorbant_l :
 forall x : Mod, Equal (module_mult (monoid_unit R) x) (monoid_unit Mod).

Lemma MODULE_absorbant_r :
 forall a : R, Equal (module_mult a (monoid_unit Mod)) (monoid_unit Mod).

Lemma MODULE_mult_op_r :
 forall (a : R) (x : Mod),
 Equal (module_mult a (group_inverse Mod x))
   (group_inverse Mod (module_mult a x)).

Lemma MODULE_mult_op_l :
 forall (a : R) (x : Mod),
 Equal (module_mult (group_inverse R a) x)
   (group_inverse Mod (module_mult a x)).
Variable Mod' : MODULE R.
Variable f : Hom Mod Mod'.

Lemma MODULE_hom_prop :
 forall (a : R) (x : Mod), Equal (f (module_mult a x)) (module_mult a (f x)).
End Lemmas.
Hint Resolve MODULE_comp MODULE_assoc MODULE_dist_r MODULE_dist_l
  MODULE_unit_l MODULE_absorbant_l MODULE_absorbant_r MODULE_mult_op_l
  MODULE_mult_op_r MODULE_hom_prop: algebra. *)
Section Free_Module_def.
Variable R : RING.
Variable V : SET.

Inductive FMd : Type :=
  | Var : V -> FMd
  | Law : FMd -> FMd -> FMd
  | Unit : FMd
  | Inv : FMd -> FMd
  | Op : R -> FMd -> FMd.

Inductive eqFMd : FMd -> FMd -> Prop :=
  | eqFMd_Var : forall x y : V, Equal x y -> (eqFMd (Var x) (Var y):Prop)
  | eqFMd_law :
      forall x x' y y' : FMd,
      eqFMd x x' -> eqFMd y y' -> (eqFMd (Law x y) (Law x' y'):Prop)
  | eqFMd_law_assoc :
      forall x y z : FMd, eqFMd (Law (Law x y) z) (Law x (Law y z)):Prop
  | eqFMd_law0r : forall x : FMd, eqFMd (Law x Unit) x:Prop
  | eqFMd_inv : forall x y : FMd, eqFMd x y -> eqFMd (Inv x) (Inv y)
  | eqFMd_invr : forall x : FMd, eqFMd (Law x (Inv x)) Unit
  | eqFMd_refl : forall x : FMd, eqFMd x x:Prop
  | eqFMd_sym : forall x y : FMd, eqFMd x y -> (eqFMd y x:Prop)
  | eqFMd_trans :
      forall x y z : FMd, eqFMd x y -> eqFMd y z -> (eqFMd x z:Prop)
  | eqFMd_com : forall x y : FMd, eqFMd (Law x y) (Law y x)
  | eqFMd_op_comp :
      forall (a b : R) (x y : FMd),
      Equal a b -> eqFMd x y -> (eqFMd (Op a x) (Op b y):Prop)
  | eqFMd_oplin_l :
      forall (a b : R) (x : FMd),
      eqFMd (Op (sgroup_law R a b) x) (Law (Op a x) (Op b x))
  | eqFMd_oplin_r :
      forall (a : R) (x y : FMd),
      eqFMd (Op a (Law x y)) (Law (Op a x) (Op a y))
  | eqFMd_op_assoc :
      forall (a b : R) (x : FMd),
      eqFMd (Op a (Op b x)) (Op (ring_mult a b) x)
  | eqFMd_op_unit : forall x : FMd, eqFMd (Op (ring_unit R) x) x.
Hint Resolve eqFMd_Var eqFMd_law eqFMd_law_assoc eqFMd_law0r eqFMd_invr
  eqFMd_refl: algebra.
Hint Immediate eqFMd_sym: algebra.

Lemma eqFMd_Equiv : equivalence eqFMd.
red in |- *.
split; [ try assumption | idtac ].
exact eqFMd_refl.
red in |- *.
split; [ try assumption | idtac ].
exact eqFMd_trans.
exact eqFMd_sym.
Qed.

Definition FMd_set := Build_Setoid eqFMd_Equiv.

Definition FreeModule : MODULE R.
apply
 (BUILD_MODULE (R:=R) (E:=FMd_set) (genlaw:=Law) (e:=Unit) (geninv:=Inv)
    (gen_module_op:=Op)).
exact eqFMd_law.
exact eqFMd_law_assoc.
exact eqFMd_law0r.
exact eqFMd_inv.
exact eqFMd_invr.
exact eqFMd_com.
exact eqFMd_op_comp.
exact eqFMd_oplin_l.
exact eqFMd_oplin_r.
exact eqFMd_op_assoc.
exact eqFMd_op_unit.
Defined.
Section Universal_prop.
Variable Mod : MODULE R.
Variable f : Hom V Mod.

Fixpoint FMd_lift_fun (p : FreeModule) : Mod :=
  match p with
  | Var v => f v
  | Law p1 p2 => sgroup_law Mod (FMd_lift_fun p1) (FMd_lift_fun p2)
  | Unit => monoid_unit Mod
  | Inv p1 => group_inverse Mod (FMd_lift_fun p1)
  | Op a p1 => module_mult a (FMd_lift_fun p1)
  end.

Definition FMd_lift : Hom FreeModule Mod.
apply
 (BUILD_HOM_MODULE (R:=R) (Mod:=FreeModule) (Mod':=Mod) (ff:=FMd_lift_fun)).
intros x y H'; try assumption.
elim H'; simpl in |- *; auto with algebra.
intros x0 y0 z H'0 H'1 H'2 H'3; try assumption.
apply Trans with (FMd_lift_fun y0); auto with algebra.
simpl in |- *; auto with algebra.
simpl in |- *; auto with algebra.
simpl in |- *; auto with algebra.
Defined.

Definition FMd_var : Hom V FreeModule.
apply (Build_Map (A:=V) (B:=FreeModule) (Ap:=Var)).
red in |- *.
simpl in |- *; auto with algebra.
Defined.

Lemma FMd_comp_prop :
 Equal f (comp_hom (FMd_lift:Hom (FreeModule:SET) Mod) FMd_var).
simpl in |- *.
red in |- *.
red in |- *.
simpl in |- *.
intros x; try assumption.
exact (Refl (f x)).
Qed.
End Universal_prop.
End Free_Module_def.
Hint Resolve FMd_comp_prop: algebra.
