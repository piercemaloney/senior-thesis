
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sets.
(* Sets:
Global Set Automatic Coercions Import.
Global Set Asymmetric Patterns.
Set Implicit Arguments.
Unset Strict Implicit.

Section Sets1.
Comments
  "Basically, algebraic structures are sets, in which we talk about elements, belonging, equality,"
  "applications, equivalence relations, quotient sets, etc".
Comments
  "Types in Coq are not well-suited to represent sets, because they cannot be quotiented".
Comments "We will define sets in Coq as types with an equivalence relation".
Comments "First, we need some definitions on binary relations on types:".
Section Relations.
Variable E : Type.

Definition relation (E : Type) := E -> E -> Prop.

Definition app_rel (R : relation E) (x y : E) := R x y.

Definition reflexive (R : relation E) : Prop := forall x : E, app_rel R x x.

Definition symmetric (R : relation E) : Prop :=
  forall x y : E, app_rel R x y -> app_rel R y x.

Definition transitive (R : relation E) : Prop :=
  forall x y z : E, app_rel R x y -> app_rel R y z -> app_rel R x z.
Comments "A partial equivalence on" E
  " is a relation which is transitive and symmetric:".

Definition partial_equivalence (R : relation E) : Prop :=
  transitive R /\ symmetric R.
Comments "An equivalence relation is reflexive, symmetric and transitive:".

Definition equivalence (R : relation E) : Prop :=
  reflexive R /\ partial_equivalence R.
Comments "Some immediate properties:".

Lemma equiv_refl : forall R : relation E, equivalence R -> reflexive R.

Lemma equiv_sym : forall R : relation E, equivalence R -> symmetric R.

Lemma equiv_trans : forall R : relation E, equivalence R -> transitive R.
End Relations.
Hint Unfold reflexive transitive symmetric partial_equivalence equivalence:
  algebra.
Hint Resolve equiv_refl equiv_sym equiv_trans: algebra.
Comments "Then we define a dedicated structure to represent sets:".

Record Setoid : Type := 
  {Carrier :> Type; Equal : relation Carrier; Prf_equiv :> equivalence Equal}.
Hint Resolve Prf_equiv: algebra.
Comments
  "A set is then given by a type (for its elements), a binary relation"
  "and a proof that this relation is an equivalence relation".
Comments "We will write" (Equal x y)
  "for the equality of two elements of a set".

Lemma Refl : forall (E : Setoid) (x : E), Equal x x.

Lemma Sym : forall (E : Setoid) (x y : E), Equal x y -> Equal y x.

Lemma Trans :
 forall (E : Setoid) (x y z : E), Equal x y -> Equal y z -> Equal x z.
Hint Resolve Refl: algebra.
Hint Immediate Sym: algebra.
Comments
  "Every type in Coq can be seen as a set, with the Leibnitz equality:".

Let eqT_equiv : forall A : Type, equivalence (eq (A:=A)).

Definition Leibnitz_set (A : Type) : Setoid := Build_Setoid (eqT_equiv A).

Lemma Leibnitz_set_prop :
 forall (A : Type) (x y : Leibnitz_set A), Equal x y -> x = y.

Lemma Leibnitz_set_prop_rev :
 forall (A : Type) (x y : Leibnitz_set A), x = y -> Equal x y.
Section Quotient1.
Comments
  "We can now define quotient sets, using equivalence relations on sets".
Comments
  "A binary relation on a set is a binary relation on its carrier, which is compatible with equality:".
Variable E : Setoid.

Definition rel_compatible (R : relation E) : Prop :=
  forall x x' y y' : E,
  Equal x x' -> Equal y y' -> app_rel R x y -> app_rel R x' y'.

Record Relation : Type := 
  {Rel_fun :> relation E; Rel_compatible_prf : rel_compatible Rel_fun}.

Lemma Rel_comp :
 forall (R : Relation) (x x' y y' : E),
 Equal x x' -> Equal y y' -> app_rel R x y -> app_rel R x' y'.
Hint Resolve Rel_comp: algebra.
Variable R : Relation.
Hypothesis R_equiv : equivalence R.
Set Strict Implicit.
Unset Implicit Arguments.

Definition quotient : Setoid := Build_Setoid R_equiv.
Set Implicit Arguments.
Unset Strict Implicit.
End Quotient1.
Section Maps1.
Comments
  "Maps between two sets are functions which are compatible with equalities:".
Section Maps1_1.
Variable A B : Setoid.

Definition fun_compatible (f : A -> B) : Prop :=
  forall x y : A, Equal x y -> Equal (f x) (f y).

Record Map : Type := 
  {Ap :> A -> B; Map_compatible_prf :> fun_compatible Ap:Prop}.
Comments "Two maps are equal when they have the same values:".

Definition Map_eq (f g : Map) : Prop := forall x : A, Equal (f x) (g x).

Let Map_eq_equiv : equivalence Map_eq.

Definition MAP : Setoid := Build_Setoid Map_eq_equiv.
Comments "We note" (MAP A B) "the set of maps between" A "and" B.
End Maps1_1.
Comments "Some immediate properties of maps:".

Lemma Ap_comp :
 forall (A B : Setoid) (f g : MAP A B) (x y : A),
 Equal x y -> Equal f g -> Equal (f x) (g y).
Hint Resolve Ap_comp: algebra.

Lemma map_ext :
 forall (A B : Setoid) (f g : MAP A B),
 (forall x : A, Equal (f x) (g x)) -> Equal f g.
Hint Resolve map_ext: algebra.
Section Maps1_2.
Comments "We define now injections, surjections and bijections.".
Variable A B : Setoid.

Definition injective (f : MAP A B) : Prop :=
  forall x y : A, Equal (f x) (f y) -> Equal x y.

Definition surjective (f : MAP A B) : Prop :=
  forall y : B, exists x : A, Equal y (f x).

Definition bijective (f : MAP A B) : Prop := injective f /\ surjective f.
End Maps1_2.
Comments "These definitions are coherent with equality of maps:".

Lemma injective_comp :
 forall (A B : Setoid) (f f' : MAP A B),
 injective f -> Equal f f' -> injective f'.

Lemma surjective_comp :
 forall (A B : Setoid) (f f' : MAP A B),
 surjective f -> Equal f f' -> surjective f'.

Lemma bijective_comp :
 forall (A B : Setoid) (f f' : MAP A B),
 bijective f -> Equal f f' -> bijective f'.
Comments "Trivialities:".

Lemma bijective_injective :
 forall (A B : Setoid) (f : MAP A B), bijective f -> injective f.
Hint Resolve bijective_injective: algebra.

Lemma bijective_surjective :
 forall (A B : Setoid) (f : MAP A B), bijective f -> surjective f.
Hint Resolve bijective_surjective: algebra.
Set Strict Implicit.
Unset Implicit Arguments.

Definition surj_set_quo :
  forall (E : Setoid) (R : Relation E) (p : equivalence R),
  MAP E (quotient E R p).
Set Implicit Arguments.
Unset Strict Implicit.

Lemma surj_set_quo_surjective :
 forall (E : Setoid) (R : Relation E) (p : equivalence R),
 surjective (surj_set_quo E R p).
Section Maps1_3.
Comments "We define the composition of maps:".
Variable E F G : Setoid.
Variable g : MAP F G.
Variable f : MAP E F.
Comments
  "First, we define the composition of the functions associated to two maps:"
  f "and" g.

Definition comp_map_fun (x : E) := g (f x).
Comments "Then, we proof that the result is compatible with equality:".

Lemma comp_map_fun_compatible : fun_compatible comp_map_fun.
Comments "With this result, we can build the composed map:".

Definition comp_map_map : MAP E G := Build_Map comp_map_fun_compatible.
End Maps1_3.
Comments "We note" (comp_map_map g f) "the composition of" g "and" f.
Comments "Composition is compatible with equality of maps:".

Lemma comp_map_comp :
 forall (A B C : Setoid) (f f' : MAP A B) (g g' : MAP B C),
 Equal f f' -> Equal g g' -> Equal (comp_map_map g f) (comp_map_map g' f').
Hint Resolve comp_map_comp: algebra.
Comments "Composition is associative:".

Lemma comp_map_assoc :
 forall (A B C D : Setoid) (f : MAP A B) (g : MAP B C) (h : MAP C D),
 Equal (comp_map_map h (comp_map_map g f))
   (comp_map_map (comp_map_map h g) f).
Hint Resolve comp_map_assoc: algebra.
Comments "We define now the identity map:".

Definition Id : forall A : Setoid, MAP A A.
Comments "Identity map is a unit element for composition:".

Lemma Id_unit_r :
 forall (A B : Setoid) (f : MAP A B), Equal (comp_map_map f (Id A)) f.
Hint Resolve Id_unit_r: algebra.

Lemma Id_unit_l :
 forall (A B : Setoid) (f : MAP A B), Equal (comp_map_map (Id B) f) f.
Hint Resolve Id_unit_l: algebra.

Lemma Id_is_bijective : forall A : Setoid, bijective (Id A).
Hint Resolve Id_is_bijective: algebra.
Comments "Some properties of composition:".

Lemma comp_injective :
 forall (A B C : Setoid) (f : MAP A B) (g : MAP B C),
 injective (comp_map_map g f) -> injective f.
Hint Resolve comp_injective: algebra.

Lemma comp_surjective :
 forall (A B C : Setoid) (f : MAP A B) (g : MAP B C),
 surjective (comp_map_map g f) -> surjective g.

Lemma comp_is_id_then_bijective :
 forall (A B : Setoid) (f : MAP A B) (g : MAP B A),
 Equal (comp_map_map g f) (Id A) ->
 Equal (comp_map_map f g) (Id B) -> bijective f.

Lemma comp_is_id_then_injective :
 forall (A B : Setoid) (f : MAP A B) (g : MAP B A),
 Equal (comp_map_map g f) (Id A) -> injective f.

Lemma comp_is_id_then_surjective :
 forall (A B : Setoid) (f : MAP A B) (g : MAP B A),
 Equal (comp_map_map f g) (Id B) -> surjective f.
End Maps1.
End Sets1.
Hint Immediate Sym: algebra.
Hint Unfold reflexive transitive symmetric partial_equivalence equivalence:
  algebra.
Hint Resolve equiv_refl equiv_sym equiv_trans Prf_equiv Refl Rel_comp Ap_comp
  map_ext bijective_injective bijective_surjective surj_set_quo_surjective
  comp_map_comp comp_map_assoc Id_unit_r Id_unit_l Id_is_bijective
  comp_injective: algebra. *)

Section Def.
Variable E F : Setoid.
Comments "The type of elements of a cartesian product:".

Record cart_type : Type :=  {cart_l : E; cart_r : F}.
Comments "Equality of couples:".

Definition cart_eq (x y : cart_type) :=
  Equal (cart_l x) (cart_l y) /\ Equal (cart_r x) (cart_r y).

Lemma cart_eq_equiv : equivalence cart_eq.
red in |- *.
split; [ try assumption | idtac ].
red in |- *.
intros x; red in |- *.
elim x.
unfold cart_eq in |- *; simpl in |- *; auto with algebra.
red in |- *.
split; [ idtac | try assumption ].
red in |- *.
unfold app_rel, cart_eq in |- *.
intros x y z H' H'0; split; [ try assumption | idtac ].
apply Trans with (cart_l y); intuition.
apply Trans with (cart_r y); intuition.
red in |- *.
unfold app_rel, cart_eq in |- *.
intuition.
Qed.

Definition cart : Setoid := Build_Setoid cart_eq_equiv.
Comments "We will denote the cartesian product of" E "and" F "with"
  (cart E F).
End Def.
Section Projections.
Variable E F : Setoid.

Definition proj1 (x : cart E F) : E := cart_l x.

Definition proj2 (x : cart E F) : F := cart_r x.
Comments "We note" (proj1 x) "and" (proj2 x) "the components of a couple" x
  "in " (cart E F).

Lemma proj1_comp :
 forall x y : cart E F, Equal x y -> Equal (proj1 x) (proj1 y).
red in |- *.
simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Qed.

Lemma proj2_comp :
 forall x y : cart E F, Equal x y -> Equal (proj2 x) (proj2 y).
red in |- *.
simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Qed.
Hint Resolve proj1_comp proj2_comp: algebra.

Definition proj1_map : MAP (cart E F) E := Build_Map proj1_comp.

Definition proj2_map : MAP (cart E F) F := Build_Map proj2_comp.

Definition couple (x : E) (y : F) : cart E F := Build_cart_type x y.

Lemma couple_comp :
 forall (x x' : E) (y y' : F),
 Equal x x' -> Equal y y' -> Equal (couple x y) (couple x' y').
simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Qed.
Hint Resolve couple_comp: algebra.

Lemma coupl_proj : forall x : cart E F, Equal (couple (proj1 x) (proj2 x)) x.
simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Qed.
Hint Resolve coupl_proj: algebra.
End Projections.
Section Maps.
Variable E F G : Setoid.

Definition curry (f : MAP (cart E F) G) (x : E) (y : F) := f (couple x y).

Definition fun2_compatible (f : E -> F -> G) :=
  forall (x x' : E) (y y' : F),
  Equal x x' -> Equal y y' -> Equal (f x y) (f x' y').

Definition uncurry :
  forall f : E -> F -> G, fun2_compatible f -> MAP (cart E F) G.
intros f H'; try assumption.
apply (Build_Map (Ap:=fun x : cart E F => f (proj1 x) (proj2 x))).
red in |- *.
intros x y; try assumption.
elim x.
elim y.
simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Defined.
Variable f : MAP E (cart F G).

Definition map_proj1 : MAP E F := comp_map_map (proj1_map F G) f.

Definition map_proj2 : MAP E G := comp_map_map (proj2_map F G) f.

Definition map_couple : MAP E F -> MAP E G -> MAP E (cart F G).
intros g h.
apply (Build_Map (Ap:=fun x : E => couple (g x) (h x))).
red in |- *.
intros x y H'; try assumption.
apply couple_comp; auto with algebra.
Defined.

Lemma map_couple_proj_prop : Equal (map_couple map_proj1 map_proj2) f.
simpl in |- *.
red in |- *.
unfold map_proj1, map_proj2 in |- *; simpl in |- *.
unfold app_rel, cart_eq in |- *; intuition.
Qed.
End Maps.
Hint Resolve proj1_comp proj2_comp couple_comp coupl_proj
  map_couple_proj_prop: algebra.