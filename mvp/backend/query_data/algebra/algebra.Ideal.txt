
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_facts.
(* Ring_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.
Require Export Group_facts.
Require Export Abelian_group_facts.

Section Lemmas.
Variable R : RING.

Lemma RING_assoc :
 forall x y z : R,
 Equal (ring_mult (ring_mult x y) z) (ring_mult x (ring_mult y z)).

Lemma RING_comp :
 forall x x' y y' : R,
 Equal x x' -> Equal y y' -> Equal (ring_mult x y) (ring_mult x' y').

Lemma RING_unit_r : forall x : R, Equal (ring_mult x (ring_unit R)) x.

Lemma RING_unit_l : forall x : R, Equal (ring_mult (ring_unit R) x) x.

Lemma RING_dist_r :
 forall x y z : R,
 Equal (ring_mult (sgroup_law R x y) z)
   (sgroup_law R (ring_mult x z) (ring_mult y z)).

Lemma RING_dist_l :
 forall x y z : R,
 Equal (ring_mult x (sgroup_law R y z))
   (sgroup_law R (ring_mult x y) (ring_mult x z)).
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l: algebra.

Lemma RING_absorbant_r :
 forall x : R, Equal (ring_mult x (monoid_unit R)) (monoid_unit R).
Hint Resolve RING_absorbant_r: algebra.

Lemma RING_absorbant_l :
 forall x : R, Equal (ring_mult (monoid_unit R) x) (monoid_unit R).
Hint Resolve RING_absorbant_l: algebra.

Lemma RING_op_mult_l :
 forall x y : R,
 Equal (ring_mult (group_inverse R x) y) (group_inverse R (ring_mult x y)).
Hint Resolve RING_op_mult_l: algebra.

Lemma RING_op_mult_r :
 forall x y : R,
 Equal (ring_mult x (group_inverse R y)) (group_inverse R (ring_mult x y)).
End Lemmas.
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l RING_absorbant_r RING_absorbant_l RING_op_mult_l
  RING_op_mult_r: algebra.
Section Commutative_rings.
Variable R1 : CRING.

Lemma CRING_com : forall x y : R1, Equal (ring_mult x y) (ring_mult y x).
Hint Immediate CRING_com: algebra.

Lemma CRING_mult4 :
 forall a b c d : R1,
 Equal (ring_mult (ring_mult a b) (ring_mult c d))
   (ring_mult (ring_mult a c) (ring_mult b d)).
Hint Resolve CRING_mult4: algebra.

Lemma CRING_mult3 :
 forall x y z : R1,
 Equal (ring_mult x (ring_mult y z)) (ring_mult y (ring_mult x z)).
Hint Resolve CRING_mult3: algebra.

Lemma CRING_mult3bis :
 forall x y z : R1,
 Equal (ring_mult (ring_mult x y) z) (ring_mult (ring_mult x z) y).
Hint Resolve CRING_mult3bis: algebra.
End Commutative_rings.
Hint Resolve CRING_mult4 CRING_mult3 CRING_mult3bis: algebra.
Hint Immediate CRING_com: algebra.
Section Hom_lemmas.
Hint Resolve RING_comp: algebra.
Variable R R' : RING.
Variable f : Hom R R'.

Lemma RING_hom_prop :
 forall x y : R, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Lemma RING_one_prop : Equal (f (ring_unit R)) (ring_unit R').

Lemma RING_hom_ext :
 forall f g : Hom R R', (forall x : R, Equal (f x) (g x)) -> Equal f g.
End Hom_lemmas.
Hint Resolve RING_hom_prop RING_one_prop: algebra. *)
Require Export Generated_module.
(* Generated_module:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_kernel.
Require Export Free_module.
Section Generated_module_def.
Variable R : RING.
Variable Mod : MODULE R.
Variable A : part_set Mod.

Definition generated_module : submodule Mod := coKer (FMd_lift (inj_part A)).
End Generated_module_def.

Lemma generated_module_minimal :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (H : submodule Mod),
 included A H -> included (generated_module A) H.

Lemma generated_module_prop_included :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod),
 included A (generated_module A).

Lemma generated_module_prop :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (y : Mod),
 in_part y (generated_module A) ->
 exists x : FMd R A, Equal y (FMd_lift (inj_part A) x).

Lemma generated_module_prop_rev :
 forall (R : RING) (Mod : MODULE R) (A : part_set Mod) (y : Mod),
 (exists x : FMd R A, Equal y (FMd_lift (inj_part A) x)) ->
 in_part y (generated_module A).
Hint Resolve generated_module_minimal generated_module_prop_included
  generated_module_prop_rev: algebra. *)
Section ideals.
Variable R : RING.

Definition is_ideal (I : subgroup R) :=
  forall x : R, in_part x I -> forall a : R, in_part (ring_mult a x) I.

Record ideal : Type := 
  {ideal_subgroup :> subgroup R; ideal_prf : is_ideal ideal_subgroup}.

Lemma ideal_prop :
 forall (I : ideal) (x : I) (a : R), in_part (ring_mult a (I x)) I.
intros I x a; try assumption.
apply (ideal_prf (i:=I)).
case x; simpl in |- *; auto with algebra.
Qed.

Lemma ideal_prop2 :
 forall (I : ideal) (x a : R), in_part x I -> in_part (ring_mult a x) I.
intros I x a H'; try assumption.
apply (ideal_prf (i:=I)); auto with algebra.
Qed.

Lemma ideal_prop3 :
 forall (I : ideal) (x y : R),
 in_part x I -> in_part y I -> in_part (sgroup_law R x y) I.
auto with algebra.
Qed.

Lemma ideal_prop4 :
 forall (I : ideal) (x : R), in_part x I -> in_part (group_inverse R x) I.
auto with algebra.
Qed.
End ideals.
Hint Resolve ideal_prop2: algebra.
Section Ring_as_module.
Variable R : ring.

Definition ring_module : module R.
apply
 (BUILD_MODULE_GROUP (R:=R) (module_util_G:=R)
    (gen_module_op:=fun a x : R => ring_mult a x));
 abstract auto with algebra.
Defined.
End Ring_as_module.
Coercion ring_module : ring >-> module.
Section Generated_ideal.
Variable R : RING.
Variable A : part_set R.

Definition generated_module_subgroup : subgroup R.
apply (BUILD_SUB_GROUP (G:=R) (H:=generated_module (R:=R) (Mod:=R) A));
 simpl in |- *; auto with algebra.
intros x y H' H'0; try assumption.
elim H'0; intros x0 E; elim E; intros H'1 H'2; try exact H'2; clear E H'0.
elim H'; intros x1 E; elim E; intros H'0 H'3; try exact H'3; clear E H'.
exists (Law x1 x0); split; [ try assumption | idtac ].
simpl in |- *.
exact (SGROUP_comp (E:=R) H'3 H'2).
exists (Unit R A); split; [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
auto with algebra.
intros x H'; try assumption.
elim H'; intros x0 E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists (Inv x0); split; [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
exact (GROUP_comp (G:=R) H'1).
Defined.

Definition generated_ideal : ideal R.
apply (Build_ideal (R:=R) (ideal_subgroup:=generated_module_subgroup)).
red in |- *.
simpl in |- *.
intros x H' a; try assumption.
elim H'; intros x0 E; elim E; intros H'0 H'1; try exact H'1; clear E H'.
exists (Op a x0); split; [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
exact (MODULE_comp (R:=R) (Mod:=R:MODULE R) (Refl a) H'1).
Defined.

Lemma generated_ideal_included : included A generated_ideal.
red in |- *.
simpl in |- *.
intros x H';
 exists (Var R (V:=A) (Build_subtype (E:=R) (P:=A) (subtype_elt:=x) H'));
 split; [ idtac | try assumption ].
auto with algebra.
simpl in |- *.
auto with algebra.
Qed.

Lemma generated_ideal_minimal :
 forall I : ideal R, included A I -> included generated_ideal I.
unfold included in |- *.
simpl in |- *.
intros I H' x H'0; try assumption.
elim H'0; intros x0 E; elim E; intros H'1 H'2; try exact H'2; clear E H'0.
generalize H'2; clear H'2; clear H'1.
generalize x; clear x.
elim x0.
simpl in |- *.
intros c x H'0; try assumption.
apply H'.
apply in_part_comp_l with (subtype_elt c); auto with algebra.
case c; auto with algebra.
intros f H'0 f0 H'1 x H'2; try assumption.
simpl in H'2.
apply
 in_part_comp_l
  with
    (sgroup_law R
       (FMd_lift_fun (R:=R) (V:=A) (Mod:=R:MODULE R) (inj_part A) f)
       (FMd_lift_fun (R:=R) (V:=A) (Mod:=R:MODULE R) (inj_part A) f0));
 auto with algebra.
simpl in |- *.
intros x H'0; try assumption.
apply in_part_comp_l with (monoid_unit R); auto with algebra.
intros f H'0 x H'1; try assumption.
simpl in H'1.
apply
 in_part_comp_l
  with
    (group_inverse R
       (FMd_lift_fun (R:=R) (V:=A) (Mod:=R:MODULE R) (inj_part A) f));
 auto with algebra.
intros c f H'0 x H'1; try assumption.
simpl in H'1.
apply
 in_part_comp_l
  with
    (module_mult c
       (FMd_lift_fun (R:=R) (V:=A) (Mod:=R:MODULE R) (inj_part A) f));
 auto with algebra.
change
  (in_part
     (ring_mult c
        (FMd_lift_fun (R:=R) (V:=A) (Mod:=R:MODULE R) (inj_part A) f))
     (subsgroup_part
        (submonoid_subsgroup (subgroup_submonoid (ideal_subgroup I)))))
 in |- *.
apply ideal_prop2; auto with algebra.
Qed.
End Generated_ideal.
Hint Resolve generated_ideal_minimal generated_ideal_included: algebra.
