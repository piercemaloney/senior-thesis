
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.
(* Ring_cat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Abelian_group_cat.

Section Objects.

Definition dist_r (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple (g (couple x y)) z))
    (g (couple (f (couple x z)) (f (couple y z)))).

Definition dist_l (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple x (g (couple y z))))
    (g (couple (f (couple x y)) (f (couple x z)))).

Record ring_on (R : abelian_group) : Type := 
  {ring_mult_sgroup : sgroup_on R;
   ring_mult_monoid : monoid_on ring_mult_sgroup;
   ring_monoid :> monoid_on ring_mult_monoid;
   ring_dist_r_prf :
    dist_r (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R);
   ring_dist_l_prf :
    dist_l (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R)}.

Record ring : Type := 
  {ring_group :> abelian_group; ring_on_def :> ring_on ring_group}.
Coercion Build_ring : ring_on >-> ring.

Definition ring_mult (R : ring) (x y : R) : R :=
  sgroup_law_map (ring_mult_sgroup R) (couple x y).

Definition ring_unit (R : ring) : R := monoid_unit (ring_monoid R).

Record cring_on (R : ring) : Type := 
  {cring_com_prf : commutative (sgroup_law_map (ring_mult_monoid R))}.

Record cring : Type := 
  {cring_ring :> ring; cring_on_def :> cring_on cring_ring}.
Coercion Build_cring : cring_on >-> cring.

Definition cring_monoid : cring -> abelian_monoid.
End Objects.
Section Hom.
Variable E F : ring.

Definition ring_mult_hom_unit_prop (f : Map E F) :=
  Equal (f (ring_unit E)) (ring_unit F).

Definition ring_mult_hom_prop (f : Map E F) :=
  forall x y : E, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Record ring_hom : Type := 
  {ring_plus_hom :> monoid_hom E F;
   ring_mult_hom_unit : ring_mult_hom_unit_prop ring_plus_hom;
   ring_mult_hom_prf : ring_mult_hom_prop ring_plus_hom}.
End Hom.

Definition ring_hom_comp :
  forall E F G : ring, ring_hom F G -> ring_hom E F -> ring_hom E G.

Definition ring_id : forall E : ring, ring_hom E E.

Definition RING : category.

Definition CRING := full_subcat (C:=RING) (C':=cring) cring_ring. *)
Require Export Operation_of_monoid.
(* Operation_of_monoid:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Endo_set.

Section Def.
Variable M : MONOID.
Variable S : SET.

Definition operation := Hom M (Endo_SET S).
Variable op : operation.

Lemma operation_assoc :
 forall (x y : M) (s : S), Equal (op (sgroup_law _ x y) s) (op x (op y s)).

Lemma operation_unit : forall s : S, Equal (op (monoid_unit M) s) s.
End Def.
Hint Resolve operation_assoc operation_unit: algebra. *)

Section Def.
Variable R : RING.
Section Module_def.
Variable Mod : abelian_group.
Variable op : operation (ring_monoid R) Mod.

Definition op_lin_left :=
  forall (a b : R) (x : Mod),
  Equal (op (sgroup_law R a b) x) (sgroup_law Mod (op a x) (op b x)).

Definition op_lin_right :=
  forall (a : R) (x y : Mod),
  Equal (op a (sgroup_law Mod x y)) (sgroup_law Mod (op a x) (op a y)).
End Module_def.

Record module_on (M : abelian_group) : Type := 
  {module_op : operation (ring_monoid R) M;
   module_op_lin_left_prf : op_lin_left module_op;
   module_op_lin_right_prf : op_lin_right module_op}.

Record module : Type := 
  {module_carrier :> abelian_group;
   module_on_def :> module_on module_carrier}.
Coercion Build_module : module_on >-> module.

Definition module_mult (B : module) (a : R) (x : B) := module_op B a x.
Section Hom.
Variable E F : module.

Definition module_hom_prop (f : E -> F) :=
  forall (a : R) (x : E), Equal (f (module_mult a x)) (module_mult a (f x)).

Record module_hom : Type := 
  {module_monoid_hom :> monoid_hom E F;
   module_hom_prf : module_hom_prop module_monoid_hom}.
End Hom.

Definition module_hom_comp :
  forall E F Mod : module,
  module_hom F Mod -> module_hom E F -> module_hom E Mod.
intros E F Mod g f; try assumption.
apply
 (Build_module_hom (E:=E) (F:=Mod) (module_monoid_hom:=monoid_hom_comp g f)).
unfold module_hom_prop in |- *; auto with algebra.
simpl in |- *.
unfold comp_map_fun in |- *.
intros a x; try assumption.
apply
 Trans
  with
    (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom g)))
       (module_mult a
          (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom f))) x))).
cut
 (Equal
    (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom f)))
       (module_mult a x))
    (module_mult a
       (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom f))) x))).
auto with algebra.
apply (module_hom_prf f).
apply (module_hom_prf g).
Defined.

Definition module_id : forall E : module, module_hom E E.
intros E; try assumption.
apply (Build_module_hom (module_monoid_hom:=monoid_id E)).
red in |- *.
simpl in |- *; auto with algebra.
Defined.

Definition MODULE : category.
apply
 (subcat (C:=MONOID) (C':=module) (i:=module_carrier)
    (homC':=fun E F : module =>
            Build_subtype_image (E:=Hom (c:=ABELIAN_GROUP) E F)
              (subtype_image_carrier:=module_hom E F)
              (module_monoid_hom (E:=E) (F:=F))) (CompC':=module_hom_comp)
    (idC':=module_id)).
simpl in |- *.
intros a; try assumption.
red in |- *.
auto with algebra.
simpl in |- *.
intros a b c g f; try assumption.
red in |- *.
auto with algebra.
Defined.
End Def.