
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Group_util.
(* Group_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_group.
Require Export Abelian_group_cat.

Section Group.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.

Lemma geninvl : forall x : E, Equal (genlaw (geninv x) x) e.
Hint Resolve geninvl: algebra.

Lemma eunitgenlawl : forall x : E, Equal (genlaw e x) x.
Hint Resolve eunitgenlawl: algebra.

Definition f := uncurry fcomp.

Lemma fassoc : associative f.

Lemma eunitr : unit_r f e.

Lemma eunitl : unit_l f e.

Definition inv := Build_Map (Ap:=geninv) invcomp.

Lemma invr : inverse_r f e inv.

Lemma invl : inverse_l f e inv.

Definition sg := Build_sgroup (Build_sgroup_on fassoc).

Definition m :=
  Build_monoid (Build_monoid_on (A:=sg) (monoid_unit:=e) eunitr eunitl).

Definition BUILD_GROUP : GROUP :=
  Build_group (Build_group_on (G:=m) (group_inverse_map:=inv) invr invl).
End Group.
Section Abelian_group.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).

Definition G := BUILD_GROUP fcomp genlawassoc eunitgenlawr invcomp geninvr.

Definition asg : abelian_sgroup.

Definition BUILD_ABELIAN_GROUP : ABELIAN_GROUP :=
  Build_abelian_group
    (Build_abelian_group_on (G:=G)
       (Build_abelian_monoid (Build_abelian_monoid_on (M:=G) asg))).
End Abelian_group.
Section Hom.
Variable G G' : GROUP.
Variable ff : G -> G'.
Hypothesis ffcomp : forall x y : G, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : G,
    Equal (ff (sgroup_law _ x y)) (sgroup_law _ (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit G)) (monoid_unit G').

Definition f2 := Build_Map ffcomp.

Definition fhomsg := Build_sgroup_hom (sgroup_map:=f2) fflaw.

Definition BUILD_HOM_GROUP : Hom G G' :=
  Build_monoid_hom (monoid_sgroup_hom:=fhomsg) ffunit.
End Hom.
Section Build_sub_group.
Variable G : GROUP.
Variable H : part_set G.
Hypothesis
  Hlaw :
    forall x y : G,
    in_part x H -> in_part y H -> in_part (sgroup_law _ x y) H.
Hypothesis Hunit : in_part (monoid_unit G) H.
Hypothesis Hinv : forall x : G, in_part x H -> in_part (group_inverse _ x) H.

Definition BUILD_SUB_GROUP : subgroup G :=
  Build_subgroup (G:=G)
    (subgroup_submonoid:=Build_submonoid (G:=G)
                           (submonoid_subsgroup:=Build_subsgroup Hlaw) Hunit)
    Hinv.
End Build_sub_group. *)
Require Export Monoid_util.
(* Monoid_util:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Sub_monoid.
Require Export Abelian_group_cat.

Section Monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.

Definition f := uncurry fcomp.

Lemma fassoc : associative f.

Lemma eunitr : unit_r f e.

Lemma eunitl : unit_l f e.

Definition sg := Build_sgroup (Build_sgroup_on fassoc).

Definition BUILD_MONOID : MONOID :=
  Build_monoid (Build_monoid_on (A:=sg) (monoid_unit:=e) eunitr eunitl).
End Monoid.
Section Abelian_monoid.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis eunitgenlawl : forall x : E, Equal (genlaw e x) x.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).

Definition M := BUILD_MONOID fcomp genlawassoc eunitgenlawr eunitgenlawl.

Definition asg : abelian_sgroup.

Definition BUILD_ABELIAN_MONOID : ABELIAN_MONOID :=
  Build_abelian_monoid (Build_abelian_monoid_on (M:=M) asg).
End Abelian_monoid.
Section Hom.
Variable G G' : MONOID.
Variable ff : G -> G'.
Hypothesis ffcomp : forall x y : G, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : G,
    Equal (ff (sgroup_law _ x y)) (sgroup_law _ (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit G)) (monoid_unit G').

Definition f2 := Build_Map ffcomp.

Definition fhomsg := Build_sgroup_hom (sgroup_map:=f2) fflaw.

Definition BUILD_HOM_MONOID : Hom G G' :=
  Build_monoid_hom (monoid_sgroup_hom:=fhomsg) ffunit.
End Hom.
Section Build_sub_monoid.
Variable G : MONOID.
Variable H : part_set G.
Hypothesis
  Hlaw :
    forall x y : G,
    in_part x H -> in_part y H -> in_part (sgroup_law _ x y) H.
Hypothesis Hunit : in_part (monoid_unit G) H.

Definition BUILD_SUB_MONOID : submonoid G :=
  Build_submonoid (G:=G) (submonoid_subsgroup:=Build_subsgroup Hlaw) Hunit.
End Build_sub_monoid. *)
Require Export Ring_cat.
(* Ring_cat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Abelian_group_cat.

Section Objects.

Definition dist_r (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple (g (couple x y)) z))
    (g (couple (f (couple x z)) (f (couple y z)))).

Definition dist_l (E : SET) (f g : law_of_composition E) :=
  forall x y z : E,
  Equal (f (couple x (g (couple y z))))
    (g (couple (f (couple x y)) (f (couple x z)))).

Record ring_on (R : abelian_group) : Type := 
  {ring_mult_sgroup : sgroup_on R;
   ring_mult_monoid : monoid_on ring_mult_sgroup;
   ring_monoid :> monoid_on ring_mult_monoid;
   ring_dist_r_prf :
    dist_r (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R);
   ring_dist_l_prf :
    dist_l (sgroup_law_map ring_mult_sgroup) (sgroup_law_map R)}.

Record ring : Type := 
  {ring_group :> abelian_group; ring_on_def :> ring_on ring_group}.
Coercion Build_ring : ring_on >-> ring.

Definition ring_mult (R : ring) (x y : R) : R :=
  sgroup_law_map (ring_mult_sgroup R) (couple x y).

Definition ring_unit (R : ring) : R := monoid_unit (ring_monoid R).

Record cring_on (R : ring) : Type := 
  {cring_com_prf : commutative (sgroup_law_map (ring_mult_monoid R))}.

Record cring : Type := 
  {cring_ring :> ring; cring_on_def :> cring_on cring_ring}.
Coercion Build_cring : cring_on >-> cring.

Definition cring_monoid : cring -> abelian_monoid.
End Objects.
Section Hom.
Variable E F : ring.

Definition ring_mult_hom_unit_prop (f : Map E F) :=
  Equal (f (ring_unit E)) (ring_unit F).

Definition ring_mult_hom_prop (f : Map E F) :=
  forall x y : E, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Record ring_hom : Type := 
  {ring_plus_hom :> monoid_hom E F;
   ring_mult_hom_unit : ring_mult_hom_unit_prop ring_plus_hom;
   ring_mult_hom_prf : ring_mult_hom_prop ring_plus_hom}.
End Hom.

Definition ring_hom_comp :
  forall E F G : ring, ring_hom F G -> ring_hom E F -> ring_hom E G.

Definition ring_id : forall E : ring, ring_hom E E.

Definition RING : category.

Definition CRING := full_subcat (C:=RING) (C':=cring) cring_ring. *)

Section Ring.
Variable E : Setoid.
Variable ringplus : E -> E -> E.
Variable ringmult : E -> E -> E.
Variable zero : E.
Variable un : E.
Variable ringopp : E -> E.
Hypothesis
  ringpluscomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringplus x y) (ringplus x' y').
Hypothesis
  ringplusassoc :
    forall x y z : E,
    Equal (ringplus (ringplus x y) z) (ringplus x (ringplus y z)).
Hypothesis zerounitringplusr : forall x : E, Equal (ringplus x zero) x.
Hypothesis
  oppcomp : forall x y : E, Equal x y -> Equal (ringopp x) (ringopp y).
Hypothesis ringoppr : forall x : E, Equal (ringplus x (ringopp x)) zero.
Hypothesis ringpluscom : forall x y : E, Equal (ringplus x y) (ringplus y x).
Hypothesis
  ringmultcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (ringmult x y) (ringmult x' y').
Hypothesis
  ringmultassoc :
    forall x y z : E,
    Equal (ringmult (ringmult x y) z) (ringmult x (ringmult y z)).
Hypothesis ununitringmultr : forall x : E, Equal (ringmult x un) x.
Hypothesis ununitlringmult : forall x : E, Equal (ringmult un x) x.
Hypothesis
  ringdistl :
    forall x y z : E,
    Equal (ringmult x (ringplus y z))
      (ringplus (ringmult x y) (ringmult x z)).
Hypothesis
  ringdistr :
    forall x y z : E,
    Equal (ringmult (ringplus x y) z)
      (ringplus (ringmult x z) (ringmult y z)).

Definition G :=
  BUILD_ABELIAN_GROUP ringpluscomp ringplusassoc zerounitringplusr oppcomp
    ringoppr ringpluscom.

Definition M :=
  BUILD_MONOID ringmultcomp ringmultassoc ununitringmultr ununitlringmult.

Definition BUILD_RING : RING.
apply (Build_ring (ring_group:=G)).
apply (Build_ring_on (R:=G) (ring_mult_sgroup:=M) (ring_mult_monoid:=M) M).
abstract (red in |- *; simpl in |- *; intros x y z;
           apply Trans with (ringmult (ringplus x y) z); 
           auto with algebra).
abstract (red in |- *; simpl in |- *; auto with algebra).
Defined.
End Ring.
Section Hom.
Variable Ring1 Ring2 : ring.
Variable ff : Ring1 -> Ring2.
Hypothesis ffcomp : forall x y : Ring1, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  ffplus :
    forall x y : Ring1,
    Equal (ff (sgroup_law Ring1 x y)) (sgroup_law Ring2 (ff x) (ff y)).
Hypothesis ffzero : Equal (ff (monoid_unit Ring1)) (monoid_unit Ring2).
Hypothesis
  ffmult :
    forall x y : Ring1, Equal (ff (ring_mult x y)) (ring_mult (ff x) (ff y)).
Hypothesis ffone : Equal (ff (ring_unit Ring1)) (ring_unit Ring2).

Definition BUILD_HOM_RING : Hom (Ring1:RING) (Ring2:RING).
apply
 (Build_ring_hom (E:=Ring1) (F:=Ring2)
    (ring_plus_hom:=BUILD_HOM_GROUP ffcomp ffplus ffzero));
 abstract (red in |- *; simpl in |- *; auto with algebra).
Defined.
End Hom.