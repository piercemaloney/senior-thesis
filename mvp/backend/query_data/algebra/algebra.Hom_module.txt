
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_util.
(* Module_util:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_cat.
Require Export Monoid_util.
Require Export Group_util.

Section Module.
Variable R : RING.
Variable E : Setoid.
Variable genlaw : E -> E -> E.
Variable e : E.
Variable geninv : E -> E.
Variable gen_module_op : R -> E -> E.
Hypothesis
  fcomp :
    forall x x' y y' : E,
    Equal x x' -> Equal y y' -> Equal (genlaw x y) (genlaw x' y').
Hypothesis
  genlawassoc :
    forall x y z : E, Equal (genlaw (genlaw x y) z) (genlaw x (genlaw y z)).
Hypothesis eunitgenlawr : forall x : E, Equal (genlaw x e) x.
Hypothesis invcomp : forall x y : E, Equal x y -> Equal (geninv x) (geninv y).
Hypothesis geninvr : forall x : E, Equal (genlaw x (geninv x)) e.
Hypothesis fcom : forall x y : E, Equal (genlaw x y) (genlaw y x).
Hypothesis
  op_comp :
    forall (a b : R) (x y : E),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : E),
    Equal (gen_module_op (sgroup_law R a b) x)
      (genlaw (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : E),
    Equal (gen_module_op a (genlaw x y))
      (genlaw (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : E),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis opunit : forall x : E, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el : forall a : R, Endo_SET E.

Definition module_util_op : operation (ring_monoid R) E.

Definition module_util_G : ABELIAN_GROUP.

Definition BUILD_MODULE : MODULE R.
End Module.
Section Hom.
Variable R : RING.
Variable Mod Mod' : MODULE R.
Variable ff : Mod -> Mod'.
Hypothesis ffcomp : forall x y : Mod, Equal x y -> Equal (ff x) (ff y).
Hypothesis
  fflaw :
    forall x y : Mod,
    Equal (ff (sgroup_law Mod x y)) (sgroup_law Mod' (ff x) (ff y)).
Hypothesis ffunit : Equal (ff (monoid_unit Mod)) (monoid_unit Mod').
Hypothesis
  ffop :
    forall (a : R) (x : Mod),
    Equal (ff (module_mult a x)) (module_mult a (ff x)).

Definition BUILD_HOM_MODULE : Hom Mod Mod' :=
  Build_module_hom
    (module_monoid_hom:=BUILD_HOM_GROUP (G:=Mod) (G':=Mod') (ff:=ff) ffcomp
                          fflaw ffunit) ffop.
End Hom.
Section Module_on_group.
Variable R : RING.
Variable module_util_G : ABELIAN_GROUP.
Variable gen_module_op : R -> module_util_G -> module_util_G.
Hypothesis
  op_comp :
    forall (a b : R) (x y : module_util_G),
    Equal a b -> Equal x y -> Equal (gen_module_op a x) (gen_module_op b y).
Hypothesis
  oplin_l :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op (sgroup_law R a b) x)
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op b x)).
Hypothesis
  oplin_r :
    forall (a : R) (x y : module_util_G),
    Equal (gen_module_op a (sgroup_law module_util_G x y))
      (sgroup_law module_util_G (gen_module_op a x) (gen_module_op a y)).
Hypothesis
  opassoc :
    forall (a b : R) (x : module_util_G),
    Equal (gen_module_op a (gen_module_op b x))
      (gen_module_op (ring_mult a b) x).
Hypothesis
  opunit : forall x : module_util_G, Equal (gen_module_op (ring_unit R) x) x.

Definition module_util_endo_el2 : forall a : R, Endo_SET module_util_G.

Definition module_util_op2 : operation (ring_monoid R) module_util_G.

Definition BUILD_MODULE_GROUP : MODULE R.
End Module_on_group. *)
Require Export Ring_facts.
(* Ring_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Ring_cat.
Require Export Group_facts.
Require Export Abelian_group_facts.

Section Lemmas.
Variable R : RING.

Lemma RING_assoc :
 forall x y z : R,
 Equal (ring_mult (ring_mult x y) z) (ring_mult x (ring_mult y z)).

Lemma RING_comp :
 forall x x' y y' : R,
 Equal x x' -> Equal y y' -> Equal (ring_mult x y) (ring_mult x' y').

Lemma RING_unit_r : forall x : R, Equal (ring_mult x (ring_unit R)) x.

Lemma RING_unit_l : forall x : R, Equal (ring_mult (ring_unit R) x) x.

Lemma RING_dist_r :
 forall x y z : R,
 Equal (ring_mult (sgroup_law R x y) z)
   (sgroup_law R (ring_mult x z) (ring_mult y z)).

Lemma RING_dist_l :
 forall x y z : R,
 Equal (ring_mult x (sgroup_law R y z))
   (sgroup_law R (ring_mult x y) (ring_mult x z)).
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l: algebra.

Lemma RING_absorbant_r :
 forall x : R, Equal (ring_mult x (monoid_unit R)) (monoid_unit R).
Hint Resolve RING_absorbant_r: algebra.

Lemma RING_absorbant_l :
 forall x : R, Equal (ring_mult (monoid_unit R) x) (monoid_unit R).
Hint Resolve RING_absorbant_l: algebra.

Lemma RING_op_mult_l :
 forall x y : R,
 Equal (ring_mult (group_inverse R x) y) (group_inverse R (ring_mult x y)).
Hint Resolve RING_op_mult_l: algebra.

Lemma RING_op_mult_r :
 forall x y : R,
 Equal (ring_mult x (group_inverse R y)) (group_inverse R (ring_mult x y)).
End Lemmas.
Hint Resolve RING_assoc RING_comp RING_unit_r RING_unit_l RING_dist_r
  RING_dist_l RING_absorbant_r RING_absorbant_l RING_op_mult_l
  RING_op_mult_r: algebra.
Section Commutative_rings.
Variable R1 : CRING.

Lemma CRING_com : forall x y : R1, Equal (ring_mult x y) (ring_mult y x).
Hint Immediate CRING_com: algebra.

Lemma CRING_mult4 :
 forall a b c d : R1,
 Equal (ring_mult (ring_mult a b) (ring_mult c d))
   (ring_mult (ring_mult a c) (ring_mult b d)).
Hint Resolve CRING_mult4: algebra.

Lemma CRING_mult3 :
 forall x y z : R1,
 Equal (ring_mult x (ring_mult y z)) (ring_mult y (ring_mult x z)).
Hint Resolve CRING_mult3: algebra.

Lemma CRING_mult3bis :
 forall x y z : R1,
 Equal (ring_mult (ring_mult x y) z) (ring_mult (ring_mult x z) y).
Hint Resolve CRING_mult3bis: algebra.
End Commutative_rings.
Hint Resolve CRING_mult4 CRING_mult3 CRING_mult3bis: algebra.
Hint Immediate CRING_com: algebra.
Section Hom_lemmas.
Hint Resolve RING_comp: algebra.
Variable R R' : RING.
Variable f : Hom R R'.

Lemma RING_hom_prop :
 forall x y : R, Equal (f (ring_mult x y)) (ring_mult (f x) (f y)).

Lemma RING_one_prop : Equal (f (ring_unit R)) (ring_unit R').

Lemma RING_hom_ext :
 forall f g : Hom R R', (forall x : R, Equal (f x) (g x)) -> Equal f g.
End Hom_lemmas.
Hint Resolve RING_hom_prop RING_one_prop: algebra. *)
Require Export Module_facts.
(* Module_facts:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Module_cat.
Require Export Abelian_group_facts.
Section Lemmas.
Variable R : RING.
Variable Mod : MODULE R.

Lemma MODULE_comp :
 forall (a b : R) (x y : Mod),
 Equal a b -> Equal x y -> Equal (module_mult a x) (module_mult b y).

Lemma MODULE_assoc :
 forall (a b : R) (x : Mod),
 Equal (module_mult (ring_mult a b) x) (module_mult a (module_mult b x)).

Lemma MODULE_dist_r :
 forall (a b : R) (x : Mod),
 Equal (module_mult (sgroup_law R a b) x)
   (sgroup_law Mod (module_mult a x) (module_mult b x)).

Lemma MODULE_dist_l :
 forall (a : R) (x y : Mod),
 Equal (module_mult a (sgroup_law Mod x y))
   (sgroup_law Mod (module_mult a x) (module_mult a y)).

Lemma MODULE_unit_l : forall x : Mod, Equal (module_mult (ring_unit R) x) x.
Hint Resolve MODULE_comp MODULE_dist_r MODULE_dist_l MODULE_assoc
  MODULE_unit_l: algebra.

Lemma MODULE_absorbant_l :
 forall x : Mod, Equal (module_mult (monoid_unit R) x) (monoid_unit Mod).

Lemma MODULE_absorbant_r :
 forall a : R, Equal (module_mult a (monoid_unit Mod)) (monoid_unit Mod).

Lemma MODULE_mult_op_r :
 forall (a : R) (x : Mod),
 Equal (module_mult a (group_inverse Mod x))
   (group_inverse Mod (module_mult a x)).

Lemma MODULE_mult_op_l :
 forall (a : R) (x : Mod),
 Equal (module_mult (group_inverse R a) x)
   (group_inverse Mod (module_mult a x)).
Variable Mod' : MODULE R.
Variable f : Hom Mod Mod'.

Lemma MODULE_hom_prop :
 forall (a : R) (x : Mod), Equal (f (module_mult a x)) (module_mult a (f x)).
End Lemmas.
Hint Resolve MODULE_comp MODULE_assoc MODULE_dist_r MODULE_dist_l
  MODULE_unit_l MODULE_absorbant_l MODULE_absorbant_r MODULE_mult_op_l
  MODULE_mult_op_r MODULE_hom_prop: algebra. *)
Section Hom_module_def.
Variable R : CRING.
Variable Mod1 Mod2 : MODULE R.

Definition add_hom_module : forall f g : Hom Mod1 Mod2, Hom Mod1 Mod2.
intros f0 g.
apply
 (BUILD_HOM_MODULE (R:=R) (Mod:=Mod1) (Mod':=Mod2)
    (ff:=fun x : Mod1 => sgroup_law Mod2 (f0 x) (g x))).
abstract auto with algebra.
abstract (intros x y;
           apply
            Trans
             with
               (sgroup_law (module_carrier Mod2)
                  (sgroup_law (module_carrier Mod2)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) y))
                  (sgroup_law (module_carrier Mod2)
                     (Ap
                        (sgroup_map (monoid_sgroup_hom (module_monoid_hom g)))
                        x)
                     (Ap
                        (sgroup_map (monoid_sgroup_hom (module_monoid_hom g)))
                        y))); auto with algebra).
abstract (apply
           Trans
            with
              (sgroup_law (module_carrier Mod2)
                 (monoid_unit (module_carrier Mod2))
                 (monoid_unit (module_carrier Mod2))); 
           auto with algebra).
abstract (intros a x;
           apply
            Trans
             with
               (sgroup_law (module_carrier Mod2)
                  (module_mult a
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x))
                  (module_mult a
                     (Ap
                        (sgroup_map (monoid_sgroup_hom (module_monoid_hom g)))
                        x))); auto with algebra).
Defined.

Definition zero_hom_module : Hom Mod1 Mod2.
apply
 (BUILD_HOM_MODULE (R:=R) (Mod:=Mod1) (Mod':=Mod2)
    (ff:=fun x : Mod1 => monoid_unit Mod2)); abstract 
 auto with algebra.
Defined.

Definition opp_hom_module : forall f : Hom Mod1 Mod2, Hom Mod1 Mod2.
intros f0.
apply
 (BUILD_HOM_MODULE (R:=R) (Mod:=Mod1) (Mod':=Mod2)
    (ff:=fun x : Mod1 => group_inverse Mod2 (f0 x))).
abstract auto with algebra.
abstract (intros x y;
           apply
            Trans
             with
               (group_inverse (module_carrier Mod2)
                  (sgroup_law (module_carrier Mod2)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) y)));
           auto with algebra;
           apply
            Trans
             with
               (group_inverse (module_carrier Mod2)
                  (sgroup_law (module_carrier Mod2)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) y)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)));
           auto with algebra).
abstract (apply
           Trans
            with
              (group_inverse (module_carrier Mod2)
                 (monoid_unit (module_carrier Mod2))); 
           auto with algebra).
abstract (intros a x;
           apply
            Trans
             with
               (group_inverse (module_carrier Mod2)
                  (module_mult a
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)));
           auto with algebra).
Defined.

Definition mult_hom_module :
  forall (a : R) (f : Hom Mod1 Mod2), Hom Mod1 Mod2.
intros a f0.
apply
 (BUILD_HOM_MODULE (R:=R) (Mod:=Mod1) (Mod':=Mod2)
    (ff:=fun x : Mod1 => module_mult a (f0 x))).
abstract auto with algebra.
abstract (intros x y;
           apply
            Trans
             with
               (module_mult a
                  (sgroup_law (module_carrier Mod2)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) y)));
           auto with algebra).
abstract (apply
           Trans with (module_mult a (monoid_unit (module_carrier Mod2)));
           auto with algebra).
abstract (intros a0 x;
           apply
            Trans
             with
               (module_mult a
                  (module_mult a0
                     (Ap
                        (sgroup_map
                           (monoid_sgroup_hom (module_monoid_hom f0))) x)));
           auto with algebra;
           apply
            Trans
             with
               (module_mult (ring_mult a a0)
                  (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom f0)))
                     x)); auto with algebra;
           apply
            Trans
             with
               (module_mult (ring_mult a0 a)
                  (Ap (sgroup_map (monoid_sgroup_hom (module_monoid_hom f0)))
                     x)); auto with algebra).
Defined.

Definition Hom_module : MODULE R.
apply
 (BUILD_MODULE (R:=R) (E:=Hom Mod1 Mod2) (genlaw:=add_hom_module)
    (e:=zero_hom_module) (geninv:=opp_hom_module)
    (gen_module_op:=mult_hom_module));
 try
  abstract (simpl in |- *; unfold Map_eq in |- *; simpl in |- *;
             auto with algebra).
Defined.
End Hom_module_def.
