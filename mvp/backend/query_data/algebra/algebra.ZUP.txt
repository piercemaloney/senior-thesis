
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Z_group_facts.
(* Z_group_facts:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Z_group.

Section Lemmas.
Variable G : GROUP.

Lemma Z_to_group_nat_eq_pos :
 forall (n : Z) (g : G), Equal (Z_to_group_nat_fun g n) (Z_to_group_fun g n).
Hint Resolve Z_to_group_nat_eq_pos: algebra.

Lemma Zopp1 : forall n : Z, (n < 0)%Z -> (- n > 0)%Z.
Hint Resolve Zopp1: algebra.

Lemma Zopp2 : forall n : Z, (n > 0)%Z -> (- n < 0)%Z.
Hint Resolve Zopp2: algebra.

Lemma pos_abs_comp :
 forall (x : Z) (p p' : (x > 0)%Z), pos_abs p = pos_abs p'.
Hint Resolve Zl2 Zl1 Zl3 nat_to_group_inverse: algebra.

Lemma nat_to_group_comp :
 forall (r r' : G) (n : nat),
 Equal r r' -> Equal (nat_to_group r n) (nat_to_group r' n).
Hint Resolve nat_to_group_comp: algebra.

Lemma Z_to_group_nat_fun_comp :
 forall (r r' : G) (n : Z),
 Equal r r' -> Equal (Z_to_group_nat_fun r n) (Z_to_group_nat_fun r' n).
Hint Resolve Z_to_group_nat_fun_comp: algebra.

Lemma Z_to_group_nat_neg :
 forall (p : positive) (r : G),
 Equal (Z_to_group_nat_fun r (Zneg p))
   (Z_to_group_nat_fun (group_inverse G r) (Zpos p)).
Hint Resolve Z_to_group_nat_neg: algebra.

Lemma Z_to_group_nat_inv :
 forall (n : Z) (r : G),
 Equal (Z_to_group_nat_fun r (- n)%Z)
   (Z_to_group_nat_fun (group_inverse G r) n).
Hint Resolve Z_to_group_nat_inv: algebra.

Lemma nat_to_group_mult :
 forall (r : G) (n m : nat),
 Equal (nat_to_group r (n * m)) (nat_to_group (nat_to_group r n) m).
Hint Resolve nat_to_group_mult: algebra.

Lemma nat_to_group_unit :
 forall n : nat, Equal (nat_to_group (monoid_unit G) n) (monoid_unit G).
Hint Resolve nat_to_group_unit: algebra.

Lemma Z_to_group_nat_unit :
 forall n : Z, Equal (Z_to_group_nat_fun (monoid_unit G) n) (monoid_unit G).
Hint Resolve Z_to_group_nat_unit: algebra.

Lemma group_power_plus :
 forall (g : G) (n m : ZZ),
 Equal (group_power G g (sgroup_law ZZ n m))
   (sgroup_law G (group_power G g n) (group_power G g m)).
Hint Resolve group_power_plus: algebra.

Lemma group_power_S :
 forall (g : G) (n : ZZ),
 Equal (group_power G g (sgroup_law ZZ n (ring_unit ZZ)))
   (sgroup_law G (group_power G g n) g).
Hint Resolve group_power_S: algebra.

Lemma group_power_0 :
 forall g : G, Equal (group_power G g (monoid_unit ZZ)) (monoid_unit G).
Hint Resolve group_power_0: algebra.

Lemma group_power_1 : forall g : G, Equal (group_power G g (ring_unit ZZ)) g.
Hint Resolve group_power_1: algebra.

Lemma group_power_inv :
 forall (g : G) (n : ZZ),
 Equal (group_power G g (group_inverse ZZ n))
   (group_power G (group_inverse G g) n).
Hint Resolve group_power_inv: algebra.

Lemma Z_group_nat_fun_mult_pos :
 forall (p q : positive) (g : G),
 Equal (Z_to_group_nat_fun g (Zpos p * Zpos q)%Z)
   (Z_to_group_nat_fun (Z_to_group_nat_fun g (Zpos p)) (Zpos q)).
Hint Resolve Z_group_nat_fun_mult_pos: algebra.

Lemma group_power_mult :
 forall (g : G) (n m : ZZ),
 Equal (group_power G g (ring_mult n m))
   (group_power G (group_power G g n) m).
Hint Resolve group_power_mult: algebra.
End Lemmas.
Hint Resolve group_power_plus group_power_S group_power_0 group_power_1
  group_power_inv group_power_mult: algebra. *)

Section Zup1.
Variable R : RING.
Hint Resolve Z_to_group_nat_eq_pos: algebra.
Hint Resolve Z_to_group_nat_unit: algebra.
Hint Resolve Zl1: algebra.
Hint Resolve Zl2: algebra.

Lemma nat_to_group_mult :
 forall n m : nat,
 Equal (nat_to_group (ring_unit R) (n * m))
   (ring_mult (nat_to_group (ring_unit R) n) (nat_to_group (ring_unit R) m)).
simple induction n; simpl in |- *.
auto with algebra.
intros n0 H' m; try assumption.
apply
 Trans
  with
    (sgroup_law R (nat_to_group (ring_unit R) m)
       (nat_to_group (ring_unit R) (n0 * m))); auto with algebra.
apply
 Trans
  with
    (sgroup_law R
       (ring_mult (nat_to_group (ring_unit R) n0)
          (nat_to_group (ring_unit R) m))
       (ring_mult (ring_unit R) (nat_to_group (ring_unit R) m)));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law R
       (ring_mult (nat_to_group (ring_unit R) n0)
          (nat_to_group (ring_unit R) m)) (nat_to_group (ring_unit R) m));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law R (nat_to_group (ring_unit R) m)
       (ring_mult (nat_to_group (ring_unit R) n0)
          (nat_to_group (ring_unit R) m))); auto with algebra.
Qed.
Hint Resolve nat_to_group_mult: algebra.
Hint Resolve Zl3: algebra.

Definition Z_to_ring : Hom (ZZ:RING) R.
apply
 (BUILD_HOM_RING (Ring1:=ZZ:RING) (Ring2:=R) (ff:=Z_to_group (ring_unit R))).
auto with algebra.
auto with algebra.
auto with algebra.
simpl in |- *.
intros x y; try assumption.
apply Trans with (Z_to_group_nat_fun (ring_unit R) (ring_mult (x:ZZ) y));
 auto with algebra.
apply
 Trans
  with
    (ring_mult (Z_to_group_nat_fun (ring_unit R) x)
       (Z_to_group_nat_fun (ring_unit R) y)); auto with algebra.
elim x; simpl in |- *; unfold ring_mult at 1 in |- *; simpl in |- *; intros.
apply
 Trans with (ring_mult (monoid_unit R) (Z_to_group_nat_fun (ring_unit R) y));
 auto with algebra.
apply Trans with (monoid_unit R); auto with algebra.
elim y; simpl in |- *; intros.
apply Trans with (monoid_unit R); auto with algebra.
apply
 Trans
  with
    (ring_mult (Z_to_group_nat_fun (ring_unit R) (Zpos p)) (monoid_unit R));
 auto with algebra.
apply
 Trans
  with
    (nat_to_group (ring_unit R)
       (nat_of_P
          (pos_abs
             (ax3
                ((fun (x : positive) (_ : positive -> positive)
                    (y : positive) => (x * y)%positive) p
                   (fun y : positive => y) p0))))); 
 auto with algebra.
simpl in |- *.
rewrite
 (fun (x y : positive) (_ : positive -> positive) =>
  nat_of_P_mult_morphism x y).
apply
 Trans
  with
    (ring_mult (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p))))
       (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p0)))));
 auto with algebra.
apply
 Trans
  with
    (group_inverse R
       (nat_to_group (ring_unit R)
          (nat_of_P
             (pos_abs
                (ax3
                   ((fun (x : positive) (_ : positive -> positive)
                       (y : positive) => (x * y)%positive) p
                      (fun y : positive => y) p0)))))); 
 auto with algebra.
simpl in |- *.
rewrite
 (fun (x y : positive) (_ : positive -> positive) =>
  nat_of_P_mult_morphism x y).
apply
 Trans
  with
    (ring_mult (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p))))
       (group_inverse R
          (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p0))))));
 auto with algebra.
simpl in |- *.
apply
 Trans
  with
    (group_inverse R
       (ring_mult (nat_to_group (ring_unit R) (nat_of_P p))
          (nat_to_group (ring_unit R) (nat_of_P p0)))); 
 auto with algebra.
elim y; simpl in |- *; intros.
apply Trans with (monoid_unit R); auto with algebra.
apply
 Trans
  with
    (ring_mult (Z_to_group_nat_fun (ring_unit R) (Zneg p)) (monoid_unit R));
 auto with algebra.
apply
 Trans
  with
    (group_inverse R
       (nat_to_group (ring_unit R)
          (nat_of_P
             (pos_abs
                (ax3
                   ((fun (x : positive) (_ : positive -> positive)
                       (y : positive) => (x * y)%positive) p
                      (fun y : positive => y) p0)))))); 
 auto with algebra.
simpl in |- *.
rewrite
 (fun (x y : positive) (_ : positive -> positive) =>
  nat_of_P_mult_morphism x y).
apply
 Trans
  with
    (ring_mult
       (group_inverse R
          (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p)))))
       (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p0)))));
 auto with algebra.
simpl in |- *.
apply
 Trans
  with
    (group_inverse R
       (ring_mult (nat_to_group (ring_unit R) (nat_of_P p))
          (nat_to_group (ring_unit R) (nat_of_P p0)))); 
 auto with algebra.
apply
 Trans
  with
    (nat_to_group (ring_unit R)
       (nat_of_P
          (pos_abs
             (ax3
                ((fun (x : positive) (_ : positive -> positive)
                    (y : positive) => (x * y)%positive) p
                   (fun y : positive => y) p0))))); 
 auto with algebra.
simpl in |- *.
rewrite
 (fun (x y : positive) (_ : positive -> positive) =>
  nat_of_P_mult_morphism x y).
apply
 Trans
  with
    (ring_mult
       (group_inverse R
          (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p)))))
       (group_inverse R
          (nat_to_group (ring_unit R) (nat_of_P (pos_abs (ax3 p0))))));
 auto with algebra.
apply
 Trans
  with
    (ring_mult (nat_to_group (ring_unit R) (nat_of_P p))
       (nat_to_group (ring_unit R) (nat_of_P p0))); 
 auto with algebra.
simpl in |- *.
apply
 Trans
  with
    (group_inverse R
       (ring_mult (nat_to_group (ring_unit R) (nat_of_P p))
          (group_inverse R (nat_to_group (ring_unit R) (nat_of_P p0)))));
 auto with algebra.
apply
 Trans
  with
    (group_inverse R
       (group_inverse R
          (ring_mult (nat_to_group (ring_unit R) (nat_of_P p))
             (nat_to_group (ring_unit R) (nat_of_P p0))))); 
 auto with algebra.
simpl in |- *; auto with algebra.
Defined.

End Zup1.