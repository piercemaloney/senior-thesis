
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Fpart2.
(* Fpart2:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Fpart.
Require Export Inter.
Require Export Arith.
Section fparts2_def.
Variable E : Setoid.

Definition disjoint (A B : part_set E) := Equal (inter A B) (empty E).

Lemma disjoint_comp :
 forall A A' B B' : part_set E,
 Equal A A' -> Equal B B' -> disjoint A B -> disjoint A' B'.

Lemma empty_not_in :
 forall A : part_set E, Equal A (empty E) -> forall x : E, ~ in_part x A.

Lemma disjoint_inclus :
 forall A B C : part_set E, included A B -> disjoint B C -> disjoint A C.

Lemma included_add_part :
 forall (A : part_set E) (x : E), included A (add_part A x).
Hint Resolve included_add_part: algebra.

Lemma union_not_in :
 forall (A B : part_set E) (x : E),
 ~ in_part x A -> ~ in_part x B -> ~ in_part x (union A B).
Hint Resolve union_not_in: algebra.

Lemma disjoint_not_in_r :
 forall (A B : part_set E) (x : E),
 disjoint A B -> in_part x A -> ~ in_part x B.

Lemma cardinal_union_disjoint :
 forall (a b : nat) (A B : part_set E),
 cardinal A a -> cardinal B b -> disjoint A B -> cardinal (union A B) (a + b).
Hint Resolve cardinal_union_disjoint: algebra.

Lemma in_eq_part :
 forall A B : part_set E,
 (forall x : E, in_part x A -> in_part x B) ->
 (forall x : E, in_part x B -> in_part x A) -> Equal A B.

Lemma diff_in_l :
 forall (A B : part_set E) (x : E), in_part x (diff A B) -> in_part x A.

Lemma diff_in_r :
 forall (A B : part_set E) (x : E), in_part x (diff A B) -> ~ in_part x B.

Lemma in_diff :
 forall (A B : part_set E) (x : E),
 in_part x A -> ~ in_part x B -> in_part x (diff A B).
Hint Resolve in_diff: algebra.

Lemma union_diff :
 forall A B : part_set E, Equal (union A (diff B A)) (union A B).
Hint Resolve union_diff: algebra.

Lemma disjoint_diff : forall A B : part_set E, disjoint A (diff B A).
Hint Resolve disjoint_diff: algebra.

Lemma cardinal_union :
 forall (a b : nat) (A B : part_set E),
 cardinal A a -> cardinal (diff B A) b -> cardinal (union A B) (a + b).
Hint Resolve cardinal_union: algebra.

Lemma empty_diff : forall A : part_set E, Equal (diff (empty E) A) (empty E).
Hint Resolve empty_diff: algebra.

Lemma empty_inter :
 forall A : part_set E, Equal (inter (empty E) A) (empty E).
Hint Resolve empty_inter: algebra.

Lemma in_part_trans_eq :
 forall (A : part_set E) (x y : E), in_part x A -> Equal y x -> in_part y A.

Lemma diff_add_part :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) -> in_part x B -> Equal (diff B0 B) (diff A B).

Lemma diff_not_in :
 forall (A B : part_set E) (x : E), ~ in_part x A -> ~ in_part x (diff A B).
Hint Resolve diff_not_in: algebra.

Lemma inter_not_in :
 forall (A B : part_set E) (x : E), ~ in_part x A -> ~ in_part x (inter A B).
Hint Resolve inter_not_in: algebra.

Lemma inter_add_part :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) ->
 in_part x B -> Equal (inter A B) (add_part (inter B0 B) x).
Hint Resolve inter_add_part: algebra.

Lemma diff_add_part_not_in :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) ->
 ~ in_part x B -> Equal (diff A B) (add_part (diff B0 B) x).
Hint Resolve diff_add_part_not_in: algebra.

Lemma inter_add_part_not_in :
 forall (A B0 B : part_set E) (x : E),
 ~ in_part x B0 ->
 Equal A (add_part B0 x) -> ~ in_part x B -> Equal (inter B0 B) (inter A B).

Lemma cardinal_diff :
 forall (a : nat) (A B : part_set E),
 cardinal A a ->
 exists b : nat,
   (exists c : nat,
      cardinal (diff A B) b /\ cardinal (inter A B) c /\ a = b + c).

Lemma cardinal_union_inter :
 forall (A B : part_set E) (a b c : nat),
 cardinal A a ->
 cardinal B b -> cardinal (inter A B) c -> cardinal (union A B) (a + b - c).
Hint Resolve cardinal_union_inter: algebra.
End fparts2_def. *)
Section tiroirs_def.
Variable E F : Setoid.
Variable f : MAP E F.

Lemma diff_add_part2 :
 forall (E : Setoid) (A : part_set E) (x : E),
 in_part x A -> Equal A (add_part (diff A (single x)) x).
intros E0 A x H'; try assumption.
apply in_eq_part.
intros x0 H'0; try assumption.
elim (classic (Equal x x0)); intros.
apply in_part_trans_eq with x; auto with *.
cut (in_part x0 (diff A (single x))).
unfold add_part in |- *; auto with *.
apply in_diff; auto with *.
intros x0 H'0; try assumption.
elim (classic (Equal x x0)); intros.
apply in_part_trans_eq with x; auto with *.
cut (in_part x0 (diff A (single x))).
intros H'1; try assumption.
apply diff_in_l with (single x).
auto with *.
unfold add_part in H'0.
elim (in_part_union H'0); intros.
auto with *.
absurd (Equal x x0); auto with *.
Qed.
Hint Resolve diff_add_part2: algebra.

Lemma cardinal_minus_part :
 forall (B : part_set F) (x : F) (n : nat),
 cardinal B (S n) -> in_part x B -> cardinal (diff B (single x)) n.
intros B x n H' H'0; try assumption.
apply cardinal_S with B x; auto with *.
unfold not in |- *; intros.
cut (~ in_part x (single x)).
unfold not in |- *; auto with *.
apply diff_in_r with B; auto with *.
Qed.
Hint Resolve cardinal_minus_part: algebra.

Lemma tiroirs :
 forall (n : nat) (Chaussettes : part_set E),
 cardinal Chaussettes n ->
 forall (m : nat) (Tiroirs : part_set F),
 cardinal Tiroirs m ->
 m < n ->
 (forall x : E, in_part x Chaussettes -> in_part (f x) Tiroirs) ->
 exists x : E, (exists y : E, ~ Equal x y /\ Equal (f x) (f y)).
simple induction n.
intros Chaussettes H' m Tiroirs H'0 H'1; try assumption.
inversion H'1.
intros n0 H' Chaussettes H'0 m Tiroirs H'1 H'2 H'3; try assumption.
inversion H'0.
elim (classic (ex (fun y : E => ~ Equal x y /\ Equal (Ap f x) (Ap f y))));
 intros.
exists x; try assumption.
cut (exists m0 : nat, m = S m0).
intros H'4; try assumption.
case H'4; clear H'4; intros.
apply H' with (diff Chaussettes (single x)) x0 (diff Tiroirs (single (f x))).
apply cardinal_S with Chaussettes x.
unfold not in |- *; intros.
absurd (~ in_part x (single x)); auto with *.
apply diff_in_r with Chaussettes; auto with *.
auto with *.
apply diff_add_part2.
apply in_part_comp_r with (add_part B x); auto with *.
auto with *.
apply cardinal_minus_part.
rewrite <- H5; auto with *.
apply H'3; auto with *.
apply in_part_comp_r with (add_part B x).
auto with *.
auto with *.
rewrite H5 in H'2; auto with *.
intros x1 H'4; try assumption.
apply in_diff.
apply H'3; auto with *.
apply diff_in_l with (single x); auto with *.
unfold not in |- *; intros.
unfold not in H4.
apply H4.
exists x1; try assumption.
split.
intros H'5; try assumption.
cut (~ in_part x1 (single x)).
intro.
apply H7.
apply in_part_trans_eq with x; auto with *.
apply diff_in_r with Chaussettes; auto with *.
auto with *.
inversion H'1.
cut (in_part (f x) Tiroirs).
intros H'4; try assumption.
absurd (in_part (f x) (empty F)); auto with *.
apply in_part_comp_r with Tiroirs; auto with *.
apply H'3.
apply in_part_comp_r with (add_part B x); auto with *.
exists n2; try assumption.
auto with *.
Qed.
End tiroirs_def.
