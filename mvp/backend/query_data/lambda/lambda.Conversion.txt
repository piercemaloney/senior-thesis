
Require Import Terms.
(* Terms:
Require Import Arith.
Require Import Test.

Inductive lambda : Set :=
  | Ref : nat -> lambda
  | Abs : lambda -> lambda
  | App : lambda -> lambda -> lambda.

Definition relocate (i k n : nat) :=
  match test k i with
  
       | left _ => n + i
    | _ => i
  end.

Fixpoint lift_rec (L : lambda) : nat -> nat -> lambda :=
  fun k n : nat =>
  match L with
  | Ref i => Ref (relocate i k n)
  | Abs M => Abs (lift_rec M (S k) n)
  | App M N => App (lift_rec M k n) (lift_rec N k n)
  end.

Definition lift (n : nat) (N : lambda) := lift_rec N 0 n.

Definition insert_Ref (N : lambda) (i k : nat) :=
  match compare k i with
  
       | inleft (left _) => Ref (pred i)
    | inleft _ => lift k N
    | _ => Ref i
  end.

Fixpoint subst_rec (L : lambda) : lambda -> nat -> lambda :=
  fun (N : lambda) (k : nat) =>
  match L with
  | Ref i => insert_Ref N i k
  | Abs M => Abs (subst_rec M N (S k))
  | App M M' => App (subst_rec M N k) (subst_rec M' N k)
  end.

Definition subst (N M : lambda) := subst_rec M N 0. *)
Require Import Reduction.
(* Reduction:
Require Import Arith.
Require Import Test.
Require Import Terms.

Inductive red1 : lambda -> lambda -> Prop :=
  | beta : forall M N : lambda, red1 (App (Abs M) N) (subst N M)
  | abs_red : forall M N : lambda, red1 M N -> red1 (Abs M) (Abs N)
  | app_red_l :
      forall M1 N1 : lambda,
      red1 M1 N1 -> forall M2 : lambda, red1 (App M1 M2) (App N1 M2)
  | app_red_r :
      forall M2 N2 : lambda,
      red1 M2 N2 -> forall M1 : lambda, red1 (App M1 M2) (App M1 N2).

Inductive red : lambda -> lambda -> Prop :=
  | one_step_red : forall M N : lambda, red1 M N -> red M N
  | refl_red : forall M : lambda, red M M
  | trans_red : forall M N P : lambda, red M N -> red N P -> red M P.

Lemma red_abs : forall M M' : lambda, red M M' -> red (Abs M) (Abs M').

Lemma red_appl :
 forall M M' : lambda,
 red M M' -> forall N : lambda, red (App M N) (App M' N).

Lemma red_appr :
 forall M M' : lambda,
 red M M' -> forall N : lambda, red (App N M) (App N M').

Lemma red_app :
 forall M M' N N' : lambda, red M M' -> red N N' -> red (App M N) (App M' N').

Lemma red_beta :
 forall M M' N N' : lambda,
 red M M' -> red N N' -> red (App (Abs M) N) (subst N' M').

Inductive par_red1 : lambda -> lambda -> Prop :=
  | par_beta :
      forall M M' : lambda,
      par_red1 M M' ->
      forall N N' : lambda,
      par_red1 N N' -> par_red1 (App (Abs M) N) (subst N' M')
  | ref_par_red : forall n : nat, par_red1 (Ref n) (Ref n)
  | abs_par_red :
      forall M M' : lambda, par_red1 M M' -> par_red1 (Abs M) (Abs M')
  | app_par_red :
      forall M M' : lambda,
      par_red1 M M' ->
      forall N N' : lambda, par_red1 N N' -> par_red1 (App M N) (App M' N').

Hint Resolve par_beta ref_par_red abs_par_red app_par_red.

Lemma refl_par_red1 : forall M : lambda, par_red1 M M.

Hint Resolve refl_par_red1.

Lemma red1_par_red1 : forall M N : lambda, red1 M N -> par_red1 M N.

Inductive par_red : lambda -> lambda -> Prop :=
  | one_step_par_red : forall M N : lambda, par_red1 M N -> par_red M N
  | trans_par_red :
      forall M N P : lambda, par_red M N -> par_red N P -> par_red M P.

Lemma red_par_red : forall M N : lambda, red M N -> par_red M N.

Lemma par_red_red : forall M N : lambda, par_red M N -> red M N. *)
Require Import Confluence.
(* Confluence:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Marks.
Require Import Substitution.
Require Import Residuals.
Require Import Simulation.
Require Import Cube.

Definition confluence (A : Set) (R : A -> A -> Prop) :=
  forall x y : A,
  R x y -> forall z : A, R x z -> exists u : A, R y u /\ R z u.

Lemma lemma1 : confluence lambda par_red -> confluence lambda red.

Definition strip :=
  forall x y : lambda,
  par_red x y ->
  forall z : lambda,
  par_red1 x z -> exists u : lambda, par_red1 y u /\ par_red z u.

Lemma strip_lemma_r : confluence lambda par_red1 -> strip.

Lemma strip_lemma_l : strip -> confluence lambda par_red.

Lemma lemma2 : confluence lambda par_red1 -> confluence lambda par_red.

Lemma parallel_moves : confluence lambda par_red1.

Lemma confluence_parallel_reduction : confluence lambda par_red.

Theorem confluence_beta_reduction : confluence lambda red. *)

Inductive conv1 : lambda -> lambda -> Prop :=
  | red1_conv : forall M N : lambda, red1 M N -> conv1 M N
  | exp1_conv : forall M N : lambda, red1 N M -> conv1 M N.

Inductive conv : lambda -> lambda -> Prop :=
  | one_step_conv : forall M N : lambda, conv1 M N -> conv M N
  | refl_conv : forall M : lambda, conv M M
  | trans_conv : forall M N P : lambda, conv M N -> conv N P -> conv M P.

Lemma sym_conv : forall M N : lambda, conv M N -> conv N M.
Proof.
simple induction 1.
simple induction 1; intros; apply one_step_conv.
apply exp1_conv; trivial.
apply red1_conv; trivial.
intro; apply refl_conv; trivial.
intros; apply trans_conv with N0; trivial.
Qed.

Require Import Confluence.
(* Confluence:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Marks.
Require Import Substitution.
Require Import Residuals.
Require Import Simulation.
Require Import Cube.

Definition confluence (A : Set) (R : A -> A -> Prop) :=
  forall x y : A,
  R x y -> forall z : A, R x z -> exists u : A, R y u /\ R z u.

Lemma lemma1 : confluence lambda par_red -> confluence lambda red.

Definition strip :=
  forall x y : lambda,
  par_red x y ->
  forall z : lambda,
  par_red1 x z -> exists u : lambda, par_red1 y u /\ par_red z u.

Lemma strip_lemma_r : confluence lambda par_red1 -> strip.

Lemma strip_lemma_l : strip -> confluence lambda par_red.

Lemma lemma2 : confluence lambda par_red1 -> confluence lambda par_red.

Lemma parallel_moves : confluence lambda par_red1.

Lemma confluence_parallel_reduction : confluence lambda par_red.

Theorem confluence_beta_reduction : confluence lambda red. *)

Theorem Church_Rosser :
 forall M N : lambda, conv M N -> exists P : lambda, red M P /\ red N P.
Proof.
simple induction 1.
simple induction 1; intros.
exists N1; split; [ apply one_step_red; trivial | apply refl_red; trivial ].
exists M1; split; [ apply refl_red; trivial | apply one_step_red; trivial ].
intro M0; exists M0; split; apply refl_red; trivial.
intros; elim H1; intros P0 C0; elim H3; intros P1 C1; elim C0; elim C1;
 intros.
elim confluence_beta_reduction with N0 P0 P1; trivial.
intros Q C3; exists Q; elim C3; split.
apply trans_red with P0; trivial.
apply trans_red with P1; trivial.
Qed.
