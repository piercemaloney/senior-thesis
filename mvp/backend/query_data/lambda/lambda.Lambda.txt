

Require Import Terms.
(* Terms:
Require Import Arith.
Require Import Test.

Inductive lambda : Set :=
  | Ref : nat -> lambda
  | Abs : lambda -> lambda
  | App : lambda -> lambda -> lambda.

Definition relocate (i k n : nat) :=
  match test k i with
  
       | left _ => n + i
    | _ => i
  end.

Fixpoint lift_rec (L : lambda) : nat -> nat -> lambda :=
  fun k n : nat =>
  match L with
  | Ref i => Ref (relocate i k n)
  | Abs M => Abs (lift_rec M (S k) n)
  | App M N => App (lift_rec M k n) (lift_rec N k n)
  end.

Definition lift (n : nat) (N : lambda) := lift_rec N 0 n.

Definition insert_Ref (N : lambda) (i k : nat) :=
  match compare k i with
  
       | inleft (left _) => Ref (pred i)
    | inleft _ => lift k N
    | _ => Ref i
  end.

Fixpoint subst_rec (L : lambda) : lambda -> nat -> lambda :=
  fun (N : lambda) (k : nat) =>
  match L with
  | Ref i => insert_Ref N i k
  | Abs M => Abs (subst_rec M N (S k))
  | App M M' => App (subst_rec M N k) (subst_rec M' N k)
  end.

Definition subst (N M : lambda) := subst_rec M N 0. *)

Require Import Reduction.
(* Reduction:
Require Import Arith.
Require Import Test.
Require Import Terms.

Inductive red1 : lambda -> lambda -> Prop :=
  | beta : forall M N : lambda, red1 (App (Abs M) N) (subst N M)
  | abs_red : forall M N : lambda, red1 M N -> red1 (Abs M) (Abs N)
  | app_red_l :
      forall M1 N1 : lambda,
      red1 M1 N1 -> forall M2 : lambda, red1 (App M1 M2) (App N1 M2)
  | app_red_r :
      forall M2 N2 : lambda,
      red1 M2 N2 -> forall M1 : lambda, red1 (App M1 M2) (App M1 N2).

Inductive red : lambda -> lambda -> Prop :=
  | one_step_red : forall M N : lambda, red1 M N -> red M N
  | refl_red : forall M : lambda, red M M
  | trans_red : forall M N P : lambda, red M N -> red N P -> red M P.

Lemma red_abs : forall M M' : lambda, red M M' -> red (Abs M) (Abs M').

Lemma red_appl :
 forall M M' : lambda,
 red M M' -> forall N : lambda, red (App M N) (App M' N).

Lemma red_appr :
 forall M M' : lambda,
 red M M' -> forall N : lambda, red (App N M) (App N M').

Lemma red_app :
 forall M M' N N' : lambda, red M M' -> red N N' -> red (App M N) (App M' N').

Lemma red_beta :
 forall M M' N N' : lambda,
 red M M' -> red N N' -> red (App (Abs M) N) (subst N' M').

Inductive par_red1 : lambda -> lambda -> Prop :=
  | par_beta :
      forall M M' : lambda,
      par_red1 M M' ->
      forall N N' : lambda,
      par_red1 N N' -> par_red1 (App (Abs M) N) (subst N' M')
  | ref_par_red : forall n : nat, par_red1 (Ref n) (Ref n)
  | abs_par_red :
      forall M M' : lambda, par_red1 M M' -> par_red1 (Abs M) (Abs M')
  | app_par_red :
      forall M M' : lambda,
      par_red1 M M' ->
      forall N N' : lambda, par_red1 N N' -> par_red1 (App M N) (App M' N').

Hint Resolve par_beta ref_par_red abs_par_red app_par_red.

Lemma refl_par_red1 : forall M : lambda, par_red1 M M.

Hint Resolve refl_par_red1.

Lemma red1_par_red1 : forall M N : lambda, red1 M N -> par_red1 M N.

Inductive par_red : lambda -> lambda -> Prop :=
  | one_step_par_red : forall M N : lambda, par_red1 M N -> par_red M N
  | trans_par_red :
      forall M N P : lambda, par_red M N -> par_red N P -> par_red M P.

Lemma red_par_red : forall M N : lambda, red M N -> par_red M N.

Lemma par_red_red : forall M N : lambda, par_red M N -> red M N. *)

Require Import Redexes.
(* Redexes:
Require Import Arith.
Require Import Test.
Require Import Terms.
Require Import Reduction.

Inductive redexes : Set :=
  | Var : nat -> redexes
  | Fun : redexes -> redexes
  | Ap : bool -> redexes -> redexes -> redexes.

Inductive sub : redexes -> redexes -> Prop :=
  | Sub_Var : forall n : nat, sub (Var n) (Var n)
  | Sub_Fun : forall U V : redexes, sub U V -> sub (Fun U) (Fun V)
  | Sub_Ap1 :
      forall U1 V1 : redexes,
      sub U1 V1 ->
      forall U2 V2 : redexes,
      sub U2 V2 -> forall b : bool, sub (Ap false U1 U2) (Ap b V1 V2)
  | Sub_Ap2 :
      forall U1 V1 : redexes,
      sub U1 V1 ->
      forall U2 V2 : redexes,
      sub U2 V2 -> forall b : bool, sub (Ap true U1 U2) (Ap true V1 V2).

Definition bool_max (b b' : bool) :=
  match b return bool with
  | true => true
  | false => b'
  end.

Lemma max_false : forall b : bool, bool_max b false = b.

Inductive union : redexes -> redexes -> redexes -> Prop :=
  | Union_Var : forall n : nat, union (Var n) (Var n) (Var n)
  | Union_Fun :
      forall U V W : redexes, union U V W -> union (Fun U) (Fun V) (Fun W)
  | Union_Ap :
      forall U1 V1 W1 : redexes,
      union U1 V1 W1 ->
      forall U2 V2 W2 : redexes,
      union U2 V2 W2 ->
      forall b1 b2 : bool,
      union (Ap b1 U1 U2) (Ap b2 V1 V2) (Ap (bool_max b1 b2) W1 W2).

Lemma union_l : forall U V W : redexes, union U V W -> sub U W.

Lemma union_r : forall U V W : redexes, union U V W -> sub V W.

Lemma bool_max_Sym : forall b b' : bool, bool_max b b' = bool_max b' b.

Lemma union_sym : forall U V W : redexes, union U V W -> union V U W.

Inductive comp : redexes -> redexes -> Prop :=
  | Comp_Var : forall n : nat, comp (Var n) (Var n)
  | Comp_Fun : forall U V : redexes, comp U V -> comp (Fun U) (Fun V)
  | Comp_Ap :
      forall U1 V1 : redexes,
      comp U1 V1 ->
      forall U2 V2 : redexes,
      comp U2 V2 -> forall b1 b2 : bool, comp (Ap b1 U1 U2) (Ap b2 V1 V2).

Hint Resolve Comp_Var Comp_Fun Comp_Ap.

Lemma comp_refl : forall U : redexes, comp U U.

Lemma comp_sym : forall U V : redexes, comp U V -> comp V U.

Lemma comp_trans :
 forall U V : redexes,
 comp U V -> forall (W : redexes) (CVW : comp V W), comp U W.

Lemma union_defined :
 forall U V : redexes, comp U V -> exists W : redexes, union U V W.

Fixpoint regular (U : redexes) : Prop :=
  match U with
  | Var n => True
  | Fun V => regular V
  | Ap true (Fun _ as V) W => regular V /\ regular W
  | Ap true _ W => False
  | Ap false V W => regular V /\ regular W
  end.

Lemma union_preserve_regular :
 forall U V W : redexes, union U V W -> regular U -> regular V -> regular W. *)

Require Import Residuals.
(* Residuals:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Substitution.

Inductive residuals : redexes -> redexes -> redexes -> Prop :=
  | Res_Var : forall n : nat, residuals (Var n) (Var n) (Var n)
  | Res_Fun :
      forall U V W : redexes,
      residuals U V W -> residuals (Fun U) (Fun V) (Fun W)
  | Res_Ap :
      forall U1 V1 W1 : redexes,
      residuals U1 V1 W1 ->
      forall U2 V2 W2 : redexes,
      residuals U2 V2 W2 ->
      forall b : bool, residuals (Ap b U1 U2) (Ap false V1 V2) (Ap b W1 W2)
  | Res_redex :
      forall U1 V1 W1 : redexes,
      residuals U1 V1 W1 ->
      forall U2 V2 W2 : redexes,
      residuals U2 V2 W2 ->
      forall b : bool,
      residuals (Ap b (Fun U1) U2) (Ap true (Fun V1) V2) (subst_r W2 W1).

Hint Resolve Res_Var Res_Fun Res_Ap Res_redex.

Lemma residuals_function :
 forall U V W : redexes,
 residuals U V W -> forall (W' : redexes) (R : residuals U V W'), W' = W.

Lemma residuals_lift_rec :
 forall U1 U2 U3 : redexes,
 residuals U1 U2 U3 ->
 forall k n : nat,
 residuals (lift_rec_r U1 n k) (lift_rec_r U2 n k) (lift_rec_r U3 n k).

Lemma residuals_lift :
 forall U1 U2 U3 : redexes,
 residuals U1 U2 U3 ->
 forall k : nat, residuals (lift_r k U1) (lift_r k U2) (lift_r k U3).
Hint Resolve residuals_lift.

Lemma residuals_subst_rec :
 forall U1 U2 U3 V1 V2 V3 : redexes,
 residuals U1 U2 U3 ->
 residuals V1 V2 V3 ->
 forall k : nat,
 residuals (subst_rec_r U1 V1 k) (subst_rec_r U2 V2 k) (subst_rec_r U3 V3 k).
Hint Resolve residuals_subst_rec.

Theorem commutation :
 forall U1 U2 U3 V1 V2 V3 : redexes,
 residuals U1 U2 U3 ->
 residuals V1 V2 V3 ->
 residuals (subst_r V1 U1) (subst_r V2 U2) (subst_r V3 U3).

Lemma residuals_comp : forall U V W : redexes, residuals U V W -> comp U V.

Lemma preservation1 :
 forall U V UV : redexes,
 residuals U V UV ->
 forall (T : redexes) (UVT : union U V T), residuals T V UV.

Lemma preservation :
 forall U V W UV : redexes,
 union U V W -> residuals U V UV -> residuals W V UV.

Lemma mutual_residuals_comp :
 forall (W U UW : redexes) (RU : residuals U W UW) 
   (V VW : redexes) (RV : residuals V W VW), comp UW VW.

Lemma residuals_regular :
 forall U V W : redexes, residuals U V W -> regular V.

Lemma residuals_intro :
 forall U V : redexes,
 comp U V -> regular V -> exists W : redexes, residuals U V W.

Lemma residuals_preserve_regular :
 forall U V W : redexes, residuals U V W -> regular U -> regular W. *)

Require Import Cube.
(* Cube:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Substitution.
Require Import Residuals.

Inductive compat : redexes -> redexes -> redexes -> Prop :=
  | Compat_Var : forall n : nat, compat (Var n) (Var n) (Var n)
  | Compat_Fun :
      forall U V W : redexes, compat U V W -> compat (Fun U) (Fun V) (Fun W)
  | Compat_Ap1 :
      forall U1 V1 W1 : redexes,
      compat U1 V1 W1 ->
      forall U2 V2 W2 : redexes,
      compat U2 V2 W2 ->
      forall b : bool, compat (Ap false U1 U2) (Ap false V1 V2) (Ap b W1 W2)
  | Compat_Ap2 :
      forall U1 V1 W1 : redexes,
      compat U1 V1 W1 ->
      forall U2 V2 W2 : redexes,
      compat U2 V2 W2 ->
      forall b b' : bool,
      compat (Ap true (Fun U1) U2) (Ap b (Fun V1) V2) (Ap b' (Fun W1) W2).

Lemma compat_intro :
 forall U W WU : redexes,
 residuals W U WU ->
 forall (V WV : redexes) (R2 : residuals W V WV) (S : sub V U), compat U V W.

Lemma prism0 :
 forall U V W : redexes,
 compat U V W ->
 forall (UV : redexes) (R1 : residuals U V UV) (WU WV : redexes)
   (R2 : residuals W U WU) (R3 : residuals W V WV), 
 residuals WV UV WU.

Lemma prism1 :
 forall U V W : redexes,
 sub V U ->
 forall UV : redexes,
 residuals U V UV ->
 forall WV : redexes,
 residuals W V WV ->
 forall WU : redexes, residuals W U WU -> residuals WV UV WU.

Lemma prism2 :
 forall U V W : redexes,
 sub V U ->
 regular U ->
 forall UV : redexes,
 residuals U V UV ->
 forall WV : redexes,
 residuals W V WV ->
 forall WU : redexes, residuals WV UV WU -> residuals W U WU.

Theorem prism :
 forall U V W : redexes,
 sub V U ->
 forall UV : redexes,
 residuals U V UV ->
 forall WV : redexes,
 residuals W V WV ->
 forall WU : redexes, residuals W U WU <-> regular U /\ residuals WV UV WU.

Lemma cube :
 forall U V UV VU : redexes,
 residuals U V UV ->
 residuals V U VU ->
 forall W WU WV WUV : redexes,
 residuals W U WU ->
 residuals WU VU WUV -> residuals W V WV -> residuals WV UV WUV.

Lemma paving :
 forall U V W WU WV : redexes,
 residuals W U WU ->
 residuals W V WV ->
 exists UV : redexes,
   (exists VU : redexes,
      (exists WUV : redexes, residuals WU VU WUV /\ residuals WV UV WUV)). *)

Require Import Simulation.
(* Simulation:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Marks.
Require Import Substitution.
Require Import Residuals.

Lemma mark_lift_rec :
 forall (M : lambda) (n k : nat),
 lift_rec_r (mark M) k n = mark (lift_rec M k n).

Lemma mark_lift :
 forall (M : lambda) (n : nat), lift_r n (mark M) = mark (lift n M).

Lemma mark_subst_rec :
 forall (N M : lambda) (n : nat),
 subst_rec_r (mark M) (mark N) n = mark (subst_rec M N n).

Lemma mark_subst :
 forall M N : lambda, subst_r (mark M) (mark N) = mark (subst M N).

Lemma simulation :
 forall M M' : lambda,
 par_red1 M M' -> exists V : redexes, residuals (mark M) V (mark M').

Lemma unmark_lift_rec :
 forall (U : redexes) (n k : nat),
 lift_rec (unmark U) k n = unmark (lift_rec_r U k n).

Lemma unmark_lift :
 forall (U : redexes) (n : nat), lift n (unmark U) = unmark (lift_r n U).

Lemma unmark_subst_rec :
 forall (V U : redexes) (n : nat),
 subst_rec (unmark U) (unmark V) n = unmark (subst_rec_r U V n).

Lemma unmark_subst :
 forall U V : redexes, subst (unmark U) (unmark V) = unmark (subst_r U V).

Lemma completeness :
 forall U V W : redexes, residuals U V W -> par_red1 (unmark U) (unmark W).

Definition reduction (M : lambda) (U : redexes) (N : lambda) :=
  residuals (mark M) U (mark N).

Lemma reduction_function :
 forall (M N P : lambda) (U : redexes),
 reduction M U N -> reduction M U P -> N = P. *)

Require Import Confluence.
(* Confluence:
Require Import Arith.
Require Import Terms.
Require Import Reduction.
Require Import Redexes.
Require Import Test.
Require Import Marks.
Require Import Substitution.
Require Import Residuals.
Require Import Simulation.
Require Import Cube.

Definition confluence (A : Set) (R : A -> A -> Prop) :=
  forall x y : A,
  R x y -> forall z : A, R x z -> exists u : A, R y u /\ R z u.

Lemma lemma1 : confluence lambda par_red -> confluence lambda red.

Definition strip :=
  forall x y : lambda,
  par_red x y ->
  forall z : lambda,
  par_red1 x z -> exists u : lambda, par_red1 y u /\ par_red z u.

Lemma strip_lemma_r : confluence lambda par_red1 -> strip.

Lemma strip_lemma_l : strip -> confluence lambda par_red.

Lemma lemma2 : confluence lambda par_red1 -> confluence lambda par_red.

Lemma parallel_moves : confluence lambda par_red1.

Lemma confluence_parallel_reduction : confluence lambda par_red.

Theorem confluence_beta_reduction : confluence lambda red. *)

Require Import Conversion.
(* Conversion:
Require Import Terms.
Require Import Reduction.
Require Import Confluence.

Inductive conv1 : lambda -> lambda -> Prop :=
  | red1_conv : forall M N : lambda, red1 M N -> conv1 M N
  | exp1_conv : forall M N : lambda, red1 N M -> conv1 M N.

Inductive conv : lambda -> lambda -> Prop :=
  | one_step_conv : forall M N : lambda, conv1 M N -> conv M N
  | refl_conv : forall M : lambda, conv M M
  | trans_conv : forall M N P : lambda, conv M N -> conv N P -> conv M P.

Lemma sym_conv : forall M N : lambda, conv M N -> conv N M.

Require Import Confluence.

Theorem Church_Rosser :
 forall M N : lambda, conv M N -> exists P : lambda, red M P /\ red N P. *)

