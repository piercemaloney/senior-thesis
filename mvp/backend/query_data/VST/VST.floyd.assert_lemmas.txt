From compcert Require Export Clightdefs.

Require Export VST.veric.SeparationLogic.

Require Export VST.msl.Extensionality.

Require Export compcert.lib.Coqlib.

Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.

Require Import VST.floyd.val_lemmas.
(* VST.floyd.val_lemmas:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.floyd.functional_base.

Lemma is_int_dec i s v: {is_int i s v} + {~ is_int i s v}.

Lemma tc_val_dec t v: {tc_val t v} + {~ tc_val t v}.

Lemma sem_add_pi_ptr:
   forall {cs: compspecs}  t p i si,
    isptr p ->
    match si with
    | Signed => Int.min_signed <= i <= Int.max_signed
Hint Rewrite @sem_add_pi_ptr using (solve [auto with norm]) : norm.

Lemma sem_cast_i2i_correct_range: forall sz s v,
  is_int sz s v -> sem_cast_i2i sz s v = Some v.
Hint Rewrite sem_cast_i2i_correct_range using (solve [auto with norm]) : norm.

Lemma sem_cast_neutral_ptr:
  forall p, isptr p -> sem_cast_pointer p = Some p.
Hint Rewrite sem_cast_neutral_ptr using (solve [auto with norm]): norm.

Lemma sem_cast_neutral_Vint: forall v,
  sem_cast_pointer (Vint v) = Some (Vint v).
Hint Rewrite sem_cast_neutral_Vint : norm.

Definition isVint v := match v with Vint _ => True | _ => False end.

Lemma is_int_is_Vint: forall i s v, is_int i s v -> isVint v.

Lemma is_int_I32_Vint: forall s v, is_int I32 s (Vint v).
Hint Resolve is_int_I32_Vint.

Lemma sem_cast_neutral_int: forall v,
  isVint v ->
  sem_cast_pointer v = Some v.

Hint Rewrite sem_cast_neutral_int using
  (auto;
   match goal with H: is_int ?i ?s ?v |- isVint ?v => apply (is_int_is_Vint i s v H) end) : norm.

Lemma sizeof_tuchar: forall {cs: compspecs}, sizeof tuchar = 1%Z.
Hint Rewrite @sizeof_tuchar: norm.

Hint Rewrite Z.mul_1_l Z.mul_1_r Z.add_0_l Z.add_0_r Z.sub_0_r : norm.

Hint Rewrite eval_id_same : norm.
Hint Rewrite eval_id_other using solve [clear; intro Hx; inversion Hx] : norm.
Hint Rewrite Int.sub_idem Int.sub_zero_l  Int.add_neg_zero : norm.
Hint Rewrite Ptrofs.sub_idem Ptrofs.sub_zero_l  Ptrofs.add_neg_zero : norm.

Lemma eval_expr_Etempvar:
  forall {cs: compspecs}  i t, eval_expr (Etempvar i t) = eval_id i.
Hint Rewrite @eval_expr_Etempvar : eval.

Lemma eval_expr_binop: forall {cs: compspecs}  op a1 a2 t, eval_expr (Ebinop op a1 a2 t) =
          `(eval_binop op (typeof a1) (typeof a2)) (eval_expr a1) (eval_expr a2).
Hint Rewrite @eval_expr_binop : eval.

Lemma eval_expr_unop: forall {cs: compspecs} op a1 t, eval_expr (Eunop op a1 t) =
          lift1 (eval_unop op (typeof a1)) (eval_expr a1).
Hint Rewrite @eval_expr_unop : eval.

Hint Resolve  eval_expr_Etempvar.

Lemma eval_expr_Etempvar' : forall {cs: compspecs}  i t, eval_id i = eval_expr (Etempvar i t).
Hint Resolve  @eval_expr_Etempvar'.

Hint Rewrite Int.add_zero  Int.add_zero_l Int.sub_zero_l : norm.
Hint Rewrite Ptrofs.add_zero  Ptrofs.add_zero_l Ptrofs.sub_zero_l : norm.

Lemma eval_var_env_set:
  forall i t j v (rho: environ), eval_var i t (env_set rho j v) = eval_var i t rho.
Hint Rewrite eval_var_env_set : norm.

Lemma eval_expropt_Some: forall {cs: compspecs}  e, eval_expropt (Some e) = `Some (eval_expr e).
Lemma eval_expropt_None: forall  {cs: compspecs} , eval_expropt None = `None.
Hint Rewrite @eval_expropt_Some @eval_expropt_None : eval.

Lemma deref_noload_tarray:
  forall ty n, deref_noload (tarray ty n) = (fun v => v).
Hint Rewrite deref_noload_tarray : norm.

Lemma deref_noload_Tarray:
  forall ty n a, deref_noload (Tarray ty n a) = (fun v => v).
Hint Rewrite deref_noload_Tarray : norm.

Lemma flip_lifted_eq:
  forall (v1: environ -> val) (v2: val),
    `eq v1 `(v2) = `(eq v2) v1.
Hint Rewrite flip_lifted_eq : norm.

Lemma isptr_is_pointer_or_null:
  forall v, isptr v -> is_pointer_or_null v.
Hint Resolve isptr_is_pointer_or_null.

Definition add_ptr_int  {cs: compspecs}  (ty: type) (v: val) (i: Z) : val :=
           eval_binop Cop.Oadd (tptr ty) tint v (Vint (Int.repr i)).

Lemma add_ptr_int_offset:
  forall  {cs: compspecs}  t v n,
  repable_signed (sizeof t) ->
  repable_signed n ->
  add_ptr_int t v n = offset_val (sizeof t * n) v.
Abort. 

Lemma typed_false_cmp:
  forall op i j ,
   typed_false tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp (negate_comparison op) i j = true.

Lemma typed_true_cmp:
  forall op i j,
   typed_true tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp op i j = true.

Definition Zcmp (op: comparison) : Z -> Z -> Prop :=
 match op with
 | Ceq => eq
 | Cne => (fun i j => i<>j)
 | Clt => Z.lt
 | Cle => Z.le
 | Cgt => Z.gt
 | Cge => Z.ge
 end.

Lemma int_cmp_repr:
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = true ->

Lemma typed_false_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_false tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Lemma typed_true_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_true tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Ltac intcompare H :=
 (apply typed_false_cmp_repr in H || apply typed_true_cmp_repr in H);
   [ simpl in H | auto; unfold repable_signed, Int.min_signed, Int.max_signed in *; omega .. ].

Lemma isptr_deref_noload:
 forall t p, access_mode t = By_reference -> isptr (deref_noload t p) = isptr p.
Hint Rewrite isptr_deref_noload using reflexivity : norm.

Definition headptr (v: val): Prop :=
  exists b,  v = Vptr b Ptrofs.zero.

Lemma headptr_isptr: forall v,
  headptr v -> isptr v.
Hint Resolve headptr_isptr.

Lemma headptr_offset_zero: forall v,
  headptr (offset_val 0 v) <->
  headptr v.

Lemma typed_false_ptr:
  forall {t a v},  typed_false (Tpointer t a) v -> v=nullval.

Lemma typed_true_ptr:
  forall {t a v},  typed_true (Tpointer t a) v -> isptr v.

Lemma int_cmp_repr':
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = false ->

Lemma typed_false_of_bool:
 forall x, typed_false tint (Val.of_bool x) -> (x=false).

Lemma typed_true_of_bool:
 forall x, typed_true tint (Val.of_bool x) -> (x=true).

Lemma typed_false_tint:
 Archi.ptr64=false -> 

Lemma typed_false_tlong:
 Archi.ptr64=true -> 

Lemma typed_true_e:
 forall t v, typed_true t v -> v<>nullval.

Lemma typed_false_tint_Vint:
  forall v, typed_false tint (Vint v) -> v = Int.zero.

Lemma typed_true_tint_Vint:
  forall v, typed_true tint (Vint v) -> v <> Int.zero.

Lemma typed_true_tlong_Vlong:
  forall v, typed_true tlong (Vlong v) -> v <> Int64.zero.

Ltac intro_redundant_prop :=
  
match goal with |- ?P -> _ =>
  ((assert P by immediate; fail 1) || fail 1) || intros _
end.

Ltac fancy_intro aggressive :=
 match goal with
 | |- ?P -> _ => match type of P with Prop => idtac end
 | |- ~ _ => idtac
 end;
 let H := fresh in
 intro H;
 try simple apply ptr_eq_e in H;
 try simple apply Vint_inj in H;
 try match type of H with
 | tc_val _ _ => unfold tc_val in H; try change (eqb_type _ _) with false in H; cbv iota in H
 end;
 match type of H with
 | ?P => clear H; 
              match goal with H': P |- _ => idtac end 
             + (((assert (H:P) by (clear; immediate); fail 1) || fail 1) || idtac)
                
 | ?x = ?y => constr_eq aggressive true;
                     first [subst x | subst y
                             | is_var x; rewrite H
                             | is_var y; rewrite <- H
                             | idtac]
 | headptr (_ ?x) => let Hx1 := fresh "HP" x in
                     let Hx2 := fresh "P" x in
                       rename H into Hx1;
                       pose proof headptr_isptr _ Hx1 as Hx2
 | headptr ?x => let Hx1 := fresh "HP" x in
                 let Hx2 := fresh "P" x in
                   rename H into Hx1;
                   pose proof headptr_isptr _ Hx1 as Hx2
 | isptr ?x => let Hx := fresh "P" x in rename H into Hx
 | is_pointer_or_null ?x => let Hx := fresh "PN" x in rename H into Hx
 | typed_false _ _ =>
        first [simple apply typed_false_of_bool in H
               | apply typed_false_tint_Vint in H
               | apply (typed_false_tint (eq_refl _)) in H
               | apply (typed_false_tlong (eq_refl _)) in H
               | apply typed_false_ptr in H
               | idtac ]
 | typed_true _ _ =>
        first [simple apply typed_true_of_bool in H
               | apply typed_true_tint_Vint in H
               | apply typed_true_tlong_Vlong in H

               | apply typed_true_ptr in H
               | idtac ]
 
 | _ => try solve [discriminate H]
 end.

Ltac fancy_intros aggressive :=
 repeat match goal with
  | |- (_ <= _ < _) -> _ => fancy_intro aggressive
  | |- (_ < _ <= _) -> _ => fancy_intro aggressive
  | |- (_ <= _ <= _) -> _ => fancy_intro aggressive
  | |- (_ < _ < _) -> _ => fancy_intro aggressive
  | |- (?A /\ ?B) -> ?C => apply (@and_ind A B C) 
  | |- _ -> _ => fancy_intro aggressive
  end.

Ltac fold_types :=
 fold noattr tuint tint tschar tuchar;
 repeat match goal with
 | |- context [Tpointer ?t noattr] =>
      change (Tpointer t noattr) with (tptr t)
 | |- context [Tarray ?t ?n noattr] =>
      change (Tarray t n noattr) with (tarray t n)
 end.

Ltac fold_types1 :=
  match goal with |- _ -> ?A =>
  let a := fresh "H" in set (a:=A); fold_types; subst a
  end.

Lemma is_int_Vbyte: forall c, is_int I8 Signed (Vbyte c).
Hint Resolve is_int_Vbyte. *)

Local Open Scope logic.



Ltac _destruct_var_types i Heq_vt Heq_ve t b ::=

  let HH := fresh "H" in

  match goal with

  | H: typecheck_var_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_var_types___instead _ _ H i as HH

  | H: typecheck_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_var_types___instead _ _ (proj1 (proj2 H)) i as HH

  | H: tc_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_var_types___instead _ _ (proj1 (proj2 H)) i as HH

  end;

  match type of HH with

  | match ?o with _ => _ end =>

      match goal with

      | H: o = Some _ |- _ =>

          rewrite H in HH

      | H: Some _ = o |- _ =>

          rewrite <- H in HH

      | H: o = None |- _ =>

          rewrite H in HH

      | H: None = o |- _ =>

          rewrite <- H in HH

      | _ =>

          let HH' := fresh "H" in

          pose proof eq_refl o as HH';

          destruct o as [t |] in HH, HH' at 2;

          pose proof HH' as Heq_vt; clear HH'

      end

  end;

  match type of HH with

  | ex _ =>

      pose proof HH as [b Heq_ve]

  | _ =>

      pose proof HH as Heq_ve

  end;

  clear HH.



Ltac _destruct_glob_types i Heq_gt Heq_ge t b ::=

  let HH := fresh "H" in

  match goal with

  | H: typecheck_glob_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_glob_types___instead _ _ H i as HH

  | H: typecheck_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_glob_types___instead _ _ (proj2 (proj2 H)) i as HH

  | H: tc_environ _ _ |- _ =>

      pose proof WARNING___________you_should_use_tactic___destruct_glob_types___instead _ _ (proj2 (proj2 H)) i as HH

  end;

  match type of HH with

  | match ?o with _ => _ end =>

      match goal with

      | H: o = Some _ |- _ =>

          rewrite H in HH

      | H: Some _ = o |- _ =>

          rewrite <- H in HH

      | H: o = None |- _ =>

          rewrite H in HH

      | H: None = o |- _ =>

          rewrite <- H in HH

      | _ =>

          let HH' := fresh "H" in

          pose proof eq_refl o as HH';

          destruct o as [t |] in HH, HH' at 2;

          pose proof HH' as Heq_gt; clear HH'

      end

  end;

  match type of HH with

  | ex _ =>

      pose proof HH as [b Heq_ge]

  | _ =>

      idtac

  end;

  clear HH.



Global Transparent Int.repr.

Global Transparent Ptrofs.repr.



Definition loop1x_ret_assert (Inv : environ -> mpred) (R : ret_assert) :=

  {| RA_normal := Inv; RA_break := FF; RA_continue := Inv; RA_return := R.(RA_return) |}.



Lemma loop1x_ret_assert_EK_normal:

 forall Inv R, RA_normal (loop1x_ret_assert Inv R) = Inv.

Proof. reflexivity. Qed.

Hint Rewrite loop1x_ret_assert_EK_normal: ret_assert.



Definition loop1y_ret_assert (Inv : environ -> mpred) :=

  {| RA_normal := Inv; RA_break := FF; RA_continue := Inv; RA_return := FF |}.



Definition for_ret_assert (I: environ->mpred) (Post: ret_assert) :=

 match Post with 

  {| RA_normal := _; RA_break := _; RA_continue := _; RA_return := r |} =>

  {| RA_normal := I; RA_break := FF; RA_continue := I; RA_return := r |}

 end.



Ltac simpl_ret_assert := 

 cbn [RA_normal RA_break RA_continue RA_return 

      normal_ret_assert overridePost loop1_ret_assert

      loop2_ret_assert function_body_ret_assert frame_ret_assert

      switch_ret_assert loop1x_ret_assert loop1y_ret_assert

      for_ret_assert loop_nocontinue_ret_assert].



Lemma RA_normal_loop2_ret_assert: 

  forall Inv R, RA_normal (loop2_ret_assert Inv R) = Inv.

Proof. destruct R; reflexivity. Qed.

Hint Rewrite RA_normal_loop2_ret_assert : ret_assert.



Lemma liftTrue: forall rho, `True rho.

Proof. intro. unfold_lift; apply Coq.Init.Logic.I. Qed.

Hint Resolve liftTrue.



Lemma overridePost_normal:

  forall P Q, overridePost P (normal_ret_assert Q) = normal_ret_assert P.

Proof.

reflexivity.

Qed.



Lemma frame_normal:

  forall P F,

   frame_ret_assert (normal_ret_assert P) F = normal_ret_assert (P * F).

Proof.

intros.

unfold normal_ret_assert; simpl.

f_equal; try solve [extensionality rho; normalize].

extensionality vl rho; normalize.

Qed.



Lemma frame_for1:

  forall Q R F,

   frame_ret_assert (loop1_ret_assert Q R) F =

   loop1_ret_assert (Q * F) (frame_ret_assert R F).

Proof.

intros.

destruct R; simpl; normalize.

Qed.



Lemma frame_loop1:

  forall Q R F,

   frame_ret_assert (loop2_ret_assert Q R) F =

   loop2_ret_assert (Q * F) (frame_ret_assert R F).

Proof.

intros.

destruct R; simpl.

f_equal; try solve [extensionality rho; normalize].

Qed.



Hint Rewrite frame_normal frame_for1 frame_loop1

                 overridePost_normal: ret_assert.

Hint Resolve @TT_right.



Lemma overridePost_overridePost:

 forall P Q R, overridePost P (overridePost Q R) = overridePost P R.

Proof.

intros.

destruct R; reflexivity.

Qed.

Hint Rewrite overridePost_overridePost : ret_assert.



Lemma overridePost_normal':

  forall P R, RA_normal (overridePost P R) = P.

Proof.

 intros. destruct R; reflexivity. 

Qed.

Hint Rewrite overridePost_normal' : ret_assert.



Lemma liftx_id:

    forall {T} e, @liftx (Tarrow T (LiftEnviron T)) (fun v => v) e = e.

Proof.

 intros. extensionality rho; simpl; auto.

Qed.

Hint Rewrite @liftx_id : norm2.



Lemma liftx3_liftx2:

 forall {A1 A2 A3 B} f (x: A1),

  @liftx (Tarrow A1 (Tarrow A2 (Tarrow A3 (LiftEnviron B)))) f (@liftx (LiftEnviron A1) x) =

  @liftx (Tarrow A2 (Tarrow A3 (LiftEnviron B))) (f x).

Proof. reflexivity. Qed.



Lemma liftx2_liftx1:

 forall {A1 A2 B} f (x: A1),

  @liftx (Tarrow A1 (Tarrow A2 (LiftEnviron B))) f (@liftx (LiftEnviron A1) x) =

  @liftx (Tarrow A2 (LiftEnviron B)) (f x).

Proof. reflexivity. Qed.



Lemma liftx1_liftx0:

  forall {A1 B} f (x: A1),

  @liftx (Tarrow A1 (LiftEnviron B)) f (@liftx (LiftEnviron A1) x) =

  @liftx (LiftEnviron B) (f x).

Proof. reflexivity. Qed.



Hint Rewrite @liftx3_liftx2 @liftx2_liftx1 @liftx1_liftx0 : norm2.



Lemma lift1_lift0:

 forall {A1 B} (f: A1 -> B) (x: A1), lift1 f (lift0 x) = lift0 (f x).

Proof.

intros. extensionality rho; reflexivity.

Qed.

Hint Rewrite @lift1_lift0 : norm2.



Lemma const_liftx0:

  forall B (P: B), (fun _ : environ => P) = `P.

Proof. reflexivity. Qed.

Hint Rewrite const_liftx0 : norm2.



Lemma lift_identity:

  forall A f, `(fun v: A => v) f = f.

Proof. intros. reflexivity. Qed.

Hint Rewrite lift_identity : norm2.



Lemma tc_eval_gvar_zero:

  forall Delta t i rho, tc_environ Delta rho ->

            (var_types Delta) ! i = None ->

            (glob_types Delta) ! i = Some t ->

            exists b, eval_var i t rho = Vptr b Ptrofs.zero.

Proof.

 intros. unfold eval_var; simpl.

 destruct_var_types i.

 destruct_glob_types i.

 rewrite Heqo0, Heqo1.

 eauto.

Qed.



Lemma tc_eval_gvar_i:

  forall Delta t i rho, tc_environ Delta rho ->

            (var_types Delta) ! i = None ->

            (glob_types Delta) ! i = Some t ->

             tc_val (Tpointer t noattr) (eval_var i t rho).

Proof.

 intros.

 red.

 destruct (tc_eval_gvar_zero _ _ _ _ H H0 H1) as [b ?].

 rewrite H2.  destruct (eqb_type _ _); apply Coq.Init.Logic.I.

Qed.



Lemma local_lift2_and: forall P Q, local (`and P Q) =

        local P && local Q.

Proof. intros; extensionality rho. unfold local; super_unfold_lift.

simpl.

 apply pred_ext; normalize. destruct H; normalize.

Qed.

Hint Rewrite local_lift2_and : norm2.



Lemma subst_TT {A}{NA: NatDed A}: forall i v, subst i v TT = TT.

Proof.

intros. extensionality rho; reflexivity.

Qed.



Lemma subst_FF {A}{NA: NatDed A}: forall i v, subst i v FF = FF.

Proof.

intros. extensionality rho; reflexivity.

Qed.

Hint Rewrite @subst_TT @subst_FF: subst.

Hint Rewrite (@subst_TT mpred Nveric) (@subst_FF mpred Nveric): subst.



Lemma subst_sepcon: forall i v (P Q: environ->mpred),

  subst i v (P * Q) = (subst i v P * subst i v Q).

Proof. reflexivity. Qed.

Hint Rewrite subst_sepcon : subst.



Lemma subst_wand: forall i v (P Q: environ->mpred),

  subst i v (P -* Q) = (subst i v P -* subst i v Q).

Proof. reflexivity. Qed.

Hint Rewrite subst_wand : subst.



Lemma subst_exp:

  forall (A B: Type) (NA : NatDed A) (a : ident) (v : environ -> val) (P: B -> environ -> A),

    subst a v (EX b: B, P b) = EX b: B, subst a v (P b).

Proof. intros; reflexivity. Qed.



Lemma env_set_env_set: forall id v1 v2 rho, env_set (env_set rho id v1) id v2 = env_set rho id v2.

Proof.

  intros.

  unfold env_set.

  f_equal.

  apply Map.ext. intro j.

  destruct (eq_dec id j). subst. repeat rewrite Map.gss. f_equal.

  simpl.

  repeat rewrite Map.gso by auto. auto.

Qed.



Lemma env_set_eval_id: forall id rho Delta t,

  tc_environ Delta rho ->

  (temp_types Delta) ! id = Some t ->

  env_set rho id (eval_id id rho) = rho.

Proof.

  intros.

  destruct H as [? _].

  specialize (H _ _ H0).

  destruct H as [? [? ?]].

  unfold eval_id, env_set, force_val.

  destruct rho; simpl in *.

  f_equal.

  rewrite H.

  apply Map.ext.

  intros.

  destruct (Pos.eq_dec id x0).

  - subst.

    rewrite Map.gss; auto.

  - rewrite Map.gso; auto.

Qed.



Lemma resubst: forall {A} i (v v1: val) (e: environ -> A), subst i (`v1) (subst i `(v) e) = subst i `(v) e.

Proof.

 intros. extensionality rho. unfold subst.

 f_equal.

 unfold env_set.

 f_equal.

 apply Map.ext. intro j.

 destruct (eq_dec i j). subst. repeat rewrite Map.gss. f_equal.

 simpl.

 repeat rewrite Map.gso by auto. auto.

Qed.



Hint Rewrite @resubst : subst.



Lemma resubst_full: forall {A} i (v: environ -> val) v1 (e: environ -> A), subst i v1 (subst i v e) = subst i (subst i v1 v) e.

Proof.

  intros.

  extensionality rho. unfold subst.

 f_equal.

 unfold env_set.

 f_equal.

 apply Map.ext. intro j.

 destruct (eq_dec i j). subst. repeat rewrite Map.gss. f_equal.

 simpl.

 repeat rewrite Map.gso by auto. auto.

Qed.



Lemma subst_ewand: forall i v (P Q: environ->mpred),

  subst i v (ewand P Q) = ewand (subst i v P) (subst i v Q).

Proof. reflexivity. Qed.

Hint Rewrite subst_ewand : subst.



Lemma subst_andp {A}{NA: NatDed A}:

  forall id v (P Q: environ-> A), subst id v (P && Q) = subst id v P && subst id v Q.

Proof.

intros.

extensionality rho; unfold subst; simpl.

auto.

Qed.



Lemma subst_prop {A}{NA: NatDed A}: forall i v P,

    subst i v (prop P) = prop P.

Proof.

intros; reflexivity.

Qed.

Hint Rewrite @subst_andp subst_prop : subst.



Lemma eval_expr_Econst_int: forall {cs: compspecs}  i t, eval_expr (Econst_int i t) = `(Vint i).

Proof. reflexivity. Qed.

Hint Rewrite @eval_expr_Econst_int : eval.



Lemma subst_eval_var:

  forall id v id' t, subst id v (eval_var id' t) = eval_var id' t.

Proof.

intros. unfold subst, eval_var. extensionality rho.

simpl. auto.

Qed.

Hint Rewrite subst_eval_var : subst.



Lemma subst_local: forall id v P,

  subst id v (local P) = local (subst id v P).

Proof. reflexivity. Qed.

Hint Rewrite subst_local : subst.



Lemma eval_lvalue_Ederef:

  forall {cs: compspecs}  e t, eval_lvalue (Ederef e t) = eval_expr e.

Proof. reflexivity. Qed.

Hint Rewrite @eval_lvalue_Ederef : eval.



Lemma local_lift0_True:     local (`True) = TT.

Proof. reflexivity. Qed.

Hint Rewrite local_lift0_True : norm2.



Lemma overridePost_EK_return:

  forall Q P, RA_return (overridePost Q P) = RA_return P.

Proof.

 destruct P; reflexivity.

Qed.

Hint Rewrite overridePost_EK_return : ret_assert.



Lemma frame_ret_assert_emp:

  forall P, frame_ret_assert P emp = P.

Proof. intros.

 destruct P; simpl; f_equal; extensionality; try extensionality; normalize.

Qed.



Lemma frame_ret_assert_EK_return:

 forall P Q vl, RA_return (frame_ret_assert P Q) vl =  RA_return P vl * Q.

Proof.

 destruct P; simpl; reflexivity.

Qed.

Hint Rewrite frame_ret_assert_EK_return : ret_assert.



Lemma function_body_ret_assert_EK_return:

  forall t P vl, RA_return (function_body_ret_assert t P) vl = bind_ret vl t P.

Proof. reflexivity. Qed.

Hint Rewrite function_body_ret_assert_EK_return : ret_assert.



Lemma bind_ret1_unfold:

  forall v t Q, bind_ret (Some v) t Q = !!tc_val t v && `Q (make_args (ret_temp :: nil)(v::nil)).

Proof. reflexivity. Qed.

Hint Rewrite bind_ret1_unfold : norm2.



Lemma bind_ret1_unfold':

  forall v t Q rho,

  bind_ret (Some v) t Q rho = !!(tc_val t v) && Q (make_args (ret_temp::nil)(v::nil) rho).

Proof.

 intros. reflexivity.

Qed.

Hint Rewrite bind_ret1_unfold' : norm2.  



Lemma normal_ret_assert_elim:

 forall P, RA_normal (normal_ret_assert P) = P.

Proof.

reflexivity.

Qed.



Lemma overridePost_EK_break:

 forall P Q, RA_break (overridePost P Q) = RA_break Q.

Proof. destruct Q; reflexivity.

Qed.



Lemma loop1_ret_assert_EK_break:

 forall P Q, RA_break (loop1_ret_assert P Q) = RA_normal Q.

Proof. destruct Q;   reflexivity.

Qed.



Hint Rewrite overridePost_EK_break loop1_ret_assert_EK_break

  normal_ret_assert_elim : ret_assert.



Lemma loop1_ret_assert_normal:

  forall P Q, RA_normal (loop1_ret_assert P Q) = P.

Proof. 

  destruct Q; reflexivity.

Qed.

Hint Rewrite loop1_ret_assert_normal: ret_assert.



Lemma unfold_make_args': forall fsig args rho,

    make_args' fsig args rho = make_args (map (@fst _ _) (fst fsig)) (args rho) rho.

Proof. reflexivity. Qed.

Hint Rewrite unfold_make_args' : norm2.

Lemma unfold_make_args_cons: forall i il v vl rho,

   make_args (i::il) (v::vl) rho = env_set (make_args il vl rho) i v.

Proof. reflexivity. Qed.

Lemma unfold_make_args_nil: make_args nil nil = globals_only.

Proof. reflexivity. Qed.

Hint Rewrite unfold_make_args_cons unfold_make_args_nil : norm2.



Lemma clear_rhox:  

 forall (P: mpred) (f: environ -> environ),

    @liftx (Tarrow environ (LiftEnviron mpred))

                    (@liftx (LiftEnviron mpred) P) f

       = `P.

Proof. intros. reflexivity. Qed.

Hint Rewrite clear_rhox: norm2.



Lemma eval_make_args':

  forall (Q: val -> Prop) i fsig args,

  @liftx (Tarrow environ (LiftEnviron Prop))

      (@liftx (Tarrow val (LiftEnviron Prop)) Q (eval_id i))

   (make_args' fsig args) =

  `Q (`(eval_id i) (make_args' fsig args)).

Proof. reflexivity. Qed.

Hint Rewrite eval_make_args' : norm2.



Lemma eval_make_args_same:

 forall {cs: compspecs}  i t fsig t0 tl (e: expr) el,

 `(eval_id i) (make_args' ((i,t)::fsig, t0) (eval_exprlist (t::tl) (e::el))) =

   `force_val (`(sem_cast (typeof e) t) (eval_expr e)).

Proof.

intros.

extensionality rho.

unfold make_args'.

unfold_lift.

simpl.

unfold eval_id.

simpl.

rewrite Map.gss.

simpl.

unfold_lift.

reflexivity.

Qed.



Lemma eval_make_args_other:

 forall {cs: compspecs}  i j fsig t0 t t' tl (e: expr) el,

   i<>j ->

  `(eval_id i) (make_args' ((j,t)::fsig, t0) (eval_exprlist (t'::tl) (e::el))) =

   `(eval_id i) (make_args' (fsig, t0) (eval_exprlist tl el)).

Proof.

intros. extensionality rho.

unfold make_args'.

unfold_lift.

simpl.

unfold eval_id.

simpl.

rewrite Map.gso; auto.

Qed.



Hint Rewrite @eval_make_args_same : norm2.

Hint Rewrite @eval_make_args_other using (solve [clear; intro Hx; inversion Hx]) : norm.



Infix "oo" := Basics.compose (at level 54, right associativity).

Arguments Basics.compose {A B C} g f x / .



Lemma compose_backtick:

  forall A B C (F: B -> C) (G: A -> B) (J: environ -> A),

   `F (`G  J) = `(Basics.compose F G) J.

Proof. reflexivity. Qed.

Hint Rewrite compose_backtick : norm.



Lemma compose_eval_make_args_same:

  forall {cs: compspecs}  (Q: val -> Prop) i t fsig t0 tl e el,

  @liftx (Tarrow environ (LiftEnviron Prop))

      (Q oo (eval_id i)) (make_args' ((i,t)::fsig,t0) (eval_exprlist (t::tl) (e::el))) =

  `Q (`force_val (`(sem_cast (typeof e) t) (eval_expr e))).

Proof.

  intros.

  rewrite <- compose_backtick.

  f_equal. apply eval_make_args_same.

Qed.



Lemma compose_eval_make_args_other:

  forall {cs: compspecs}  Q i j fsig t0 t t' tl (e: expr) el,

   i<>j ->

    @liftx (Tarrow environ (LiftEnviron Prop))

     (Q oo (eval_id i)) (make_args' ((j,t)::fsig, t0) (eval_exprlist (t'::tl) (e::el))) =

     `Q (`(eval_id i) (make_args' (fsig, t0) (eval_exprlist tl el))).

Proof.

  intros.

  rewrite <- compose_backtick.

  f_equal. apply eval_make_args_other; auto.

Qed.



Hint Rewrite @compose_eval_make_args_same : norm.

Hint Rewrite @compose_eval_make_args_other using (solve [clear; intro Hx; inversion Hx]) : norm.



Lemma substopt_unfold {A}: forall id v, @substopt A (Some id) v = @subst A id v.

Proof. reflexivity. Qed.

Lemma substopt_unfold_nil {A}: forall v (P:  environ -> A), substopt None v P = P.

Proof. reflexivity. Qed.

Hint Rewrite @substopt_unfold @substopt_unfold_nil : subst.



Lemma get_result_unfold: forall id, get_result (Some id) = get_result1 id.

Proof. reflexivity. Qed.

Lemma get_result_None: get_result None = globals_only.

Proof. reflexivity. Qed.

Hint Rewrite get_result_unfold get_result_None : norm.



Lemma elim_globals_only:

  forall Delta g i t rho,

  tc_environ Delta rho /\ (var_types Delta) ! i = None /\ (glob_types Delta) ! i = Some g ->

  eval_var i t (globals_only rho) = eval_var i t rho.

Proof.

intros.

destruct H as [H [H8 H0]].

unfold eval_var, globals_only.

simpl.

destruct_var_types i.

destruct_glob_types i.

rewrite Heqo0, Heqo1.

auto.

Qed.

Hint Rewrite elim_globals_only using (split3; [eassumption | reflexivity.. ]) : norm.



Lemma elim_globals_only':

 forall a: mpred,

 (@liftx (Tarrow environ (LiftEnviron mpred)) (`a) globals_only) = `a.

Proof. reflexivity. Qed.

Hint Rewrite elim_globals_only' : norm.



Lemma globvar_eval_var:

  forall Delta rho id t,

      tc_environ Delta rho ->

     (var_types Delta) ! id = None ->

     (glob_types Delta) ! id = Some  t ->

     exists b,  eval_var id t rho = Vptr b Ptrofs.zero

            /\ Map.get (ge_of rho) id = Some b.

Proof.

intros.

unfold eval_var; simpl.

destruct_var_types id.

destruct_glob_types id.

rewrite Heqo0, Heqo1.

eauto.

Qed.



Lemma globvars2pred_unfold: forall gv vl rho,

    globvars2pred gv vl rho =

     andp (prop (gv = globals_of_env rho))

      (fold_right sepcon emp (map (fun idv => globvar2pred gv idv rho) vl)).

Proof. intros. unfold globvars2pred.

  unfold lift2. f_equal.

   induction vl; simpl; auto. normalize; f_equal; auto.

Qed.

Hint Rewrite globvars2pred_unfold : norm.



Hint Rewrite @exp_trivial : norm.



Lemma eval_var_isptr:

  forall Delta t i rho,

            tc_environ Delta rho ->

            ((var_types Delta) ! i = Some t \/

             (var_types Delta)!i = None /\

            (glob_types Delta) ! i = Some t) ->

            isptr (eval_var i t rho).

Proof.

 intros.

 unfold isptr, eval_var; simpl.

 destruct H0 as [? | [? ?]].

 + destruct_var_types i.

   rewrite Heqo0.

   rewrite eqb_type_refl.

   auto.

 + destruct_var_types i.

   destruct_glob_types i.

   rewrite Heqo0, Heqo1.

   auto.

Qed.



Lemma ENTAIL_trans:

  forall Delta P Q R,

  local (tc_environ Delta) && P |-- Q ->

  local (tc_environ Delta) && Q |-- R ->

  local (tc_environ Delta) && P |-- R.

Proof.

intros.

eapply derives_trans.

apply andp_right; [ | apply H].

apply andp_left1; apply derives_refl.

auto.

Qed.



Lemma ENTAIL_refl:

  forall Delta P,

  local (tc_environ Delta) && P |-- P.

Proof. intros. apply andp_left2, derives_refl. Qed.



Lemma corable_andp_bupd: forall (P Q: environ -> mpred),

  corable P ->

  (P && |==> Q) |-- |==> P && Q.

Proof.

  intros.

  rewrite !(andp_comm P).

  apply bupd_andp2_corable; auto.

Qed.



Lemma local_andp_bupd: forall P Q,

  (local P && |==> Q) |-- |==> (local P && Q).

Proof.

  intros.

  rewrite !(andp_comm (local P)).

  apply bupd_andp2_corable.

  intro; apply corable_prop.

Qed.



Lemma bupd_andp_local: forall P Q,

  (|==> P) && local Q |-- |==> (P && local Q).

Proof.

  intros.

  apply bupd_andp2_corable.

  intro; apply corable_prop.

Qed.



Lemma derives_bupd_trans: forall TC P Q R,

  local TC && P |-- |==> Q ->

  local TC && Q |-- |==> R ->

  local TC && P |-- |==> R.

Proof.

  intros.

  rewrite (add_andp _ _ H).

  rewrite (andp_comm _ P), andp_assoc; apply andp_left2.

  eapply derives_trans; [apply local_andp_bupd |].

  rewrite (add_andp _ _ H0).

  rewrite (andp_comm _ Q), andp_assoc; eapply derives_trans; [apply bupd_mono, andp_left2, derives_refl |].

  eapply derives_trans; [apply bupd_mono,local_andp_bupd |].

  eapply derives_trans; [apply bupd_trans|].

  apply bupd_mono; solve_andp.

Qed.



Lemma derives_bupd_refl: forall TC P,

  local TC && P |-- |==> P.

Proof. intros. apply andp_left2, bupd_intro. Qed.



Lemma derives_bupd0_refl: forall TC P,

  local TC && P |-- |==> ((|> FF) || P).

Proof. intros. apply (derives_trans _ _ _ (derives_bupd_refl TC P)), bupd_mono, orp_right2, derives_refl. Qed.



Lemma derives_bupd0_trans: forall TC P Q R,

  local TC && P |-- |==> ((|> FF) || Q) ->

  local TC && Q |-- |==> ((|> FF) || R) ->

  local TC && P |-- |==> ((|> FF) || R).

Proof.

  intros.

  eapply derives_bupd_trans; [exact H |].

  rewrite andp_comm, distrib_orp_andp, !(andp_comm _ (local _)).

  apply orp_left.

  + eapply derives_trans; [| apply bupd_intro].

    apply orp_right1, andp_left2, derives_refl.

  + eapply derives_bupd_trans; [exact H0 |].

    rewrite andp_comm, distrib_orp_andp, !(andp_comm _ (local _)).

    apply orp_left.

    - eapply derives_trans; [| apply bupd_intro].

      apply orp_right1, andp_left2, derives_refl.

    - apply derives_bupd0_refl.

Qed.



Lemma derives_full_refl: forall Delta P,

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- |==> ((|> FF) || P).

Proof. intros. refine (derives_trans _ _ _ _ (derives_bupd0_refl (tc_environ Delta) P)). solve_andp. Qed.



Lemma derives_full_trans: forall Delta P Q R,

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- |==> ((|> FF) || Q) ->

  local (tc_environ Delta) && (allp_fun_id Delta && Q) |-- |==> ((|> FF) || R) ->

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- |==> ((|> FF) || R).

Proof.

  intros.

  eapply derives_bupd0_trans; [| exact H0].

  rewrite (add_andp _ _ H).

  apply derives_trans with ((|==> |> FF || Q) && allp_fun_id Delta); [solve_andp |].

  eapply derives_trans; [apply bupd_andp2_corable; intro; apply corable_allp_fun_id |].

  apply bupd_mono.

  rewrite distrib_orp_andp.

  apply orp_derives; solve_andp.

Qed.



Lemma derives_ENTAIL: forall TC P Q,

  P |-- Q ->

  local TC && P |-- Q.

Proof. intros. apply andp_left2, H. Qed.



Lemma ENTAIL_derives_bupd: forall TC P Q,

  local TC && P |-- Q ->

  local TC && P |-- |==> Q.

Proof. intros. apply (derives_trans _ _ _ H), bupd_intro. Qed.



Lemma derives_bupd_derives_bupd0: forall TC P Q,

  local TC && P |-- |==> Q ->

  local TC && P |-- |==> ((|> FF) || Q).

Proof. intros. apply (derives_trans _ _ _ H), bupd_mono, orp_right2, derives_refl. Qed.



Lemma derives_bupd0_derives_full: forall Delta P Q,

  local (tc_environ Delta) && P |-- |==> ((|> FF) || Q) ->

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- |==> ((|> FF) || Q).

Proof. intros. refine (derives_trans _ _ _ _ H). solve_andp. Qed.



Lemma andp_ENTAIL: forall TC P P' Q Q',

  local TC && P |-- P' ->

  local TC && Q |-- Q' ->

  local TC && (P && Q) |-- P' && Q'.

Proof.

  intros.

  eapply derives_trans; [| apply andp_derives; [exact H | exact H0]].

  solve_andp.

Qed.



Lemma orp_ENTAIL: forall TC P P' Q Q',

  local TC && P |-- P' ->

  local TC && Q |-- Q' ->

  local TC && (P || Q) |-- P' || Q'.

Proof.

  intros.

  rewrite andp_comm, distrib_orp_andp.

  apply orp_derives; rewrite andp_comm; auto.

Qed.



Lemma sepcon_ENTAIL: forall TC P P' Q Q',

  local TC && P |-- P' ->

  local TC && Q |-- Q' ->

  local TC && (P * Q) |-- P' * Q'.

Proof.

  intros.

  eapply derives_trans; [| apply sepcon_derives; [exact H | exact H0]].

  rewrite corable_andp_sepcon1, corable_sepcon_andp1 by (intro; apply corable_prop).

  solve_andp.

Qed.



Lemma wand_ENTAIL: forall TC P P' Q Q',

  local TC && P' |-- P ->

  local TC && Q |-- Q' ->

  local TC && (P -* Q) |-- P' -* Q'.

Proof.

  intros.

  rewrite <- wand_sepcon_adjoint.

  eapply derives_trans; [| apply H0].

  rewrite corable_andp_sepcon1 by (intro; apply corable_prop).

  apply andp_right; [apply andp_left1, derives_refl |].

  rewrite <- corable_sepcon_andp1 by (intro; apply corable_prop).

  rewrite sepcon_comm, wand_sepcon_adjoint.

  eapply derives_trans; [apply H |].

  rewrite <- wand_sepcon_adjoint.

  apply modus_ponens_wand.

Qed.



Lemma exp_ENTAIL: forall Delta B (P Q: B -> environ -> mpred),

  (forall x: B, local (tc_environ Delta) && P x |-- Q x) ->

  local (tc_environ Delta) && exp P |-- exp Q.

Proof.

  intros.

  rewrite exp_andp2.

  apply exp_derives; auto.

Qed.



Lemma later_ENTAIL: forall Delta P Q,

  local (tc_environ Delta) && P |-- Q ->

  local (tc_environ Delta) && |> P |-- |> Q.

Proof.

  intros.

  apply later_left2, H.

Qed.



Lemma andp_ENTAILL: forall Delta P P' Q Q',

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- P' ->

  local (tc_environ Delta) && (allp_fun_id Delta && Q) |-- Q' ->

  local (tc_environ Delta) && (allp_fun_id Delta && (P && Q)) |-- P' && Q'.

Proof.

  intros.

  eapply derives_trans; [| apply andp_derives; [exact H | exact H0]].

  solve_andp.

Qed.



Lemma orp_ENTAILL: forall Delta P P' Q Q',

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- P' ->

  local (tc_environ Delta) && (allp_fun_id Delta && Q) |-- Q' ->

  local (tc_environ Delta) && (allp_fun_id Delta && (P || Q)) |-- P' || Q'.

Proof.

  intros.

  rewrite <- andp_assoc in *.

  rewrite andp_comm, distrib_orp_andp.

  apply orp_derives; rewrite andp_comm; auto.

Qed.



Lemma sepcon_ENTAILL: forall Delta P P' Q Q',

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- P' ->

  local (tc_environ Delta) && (allp_fun_id Delta && Q) |-- Q' ->

  local (tc_environ Delta) && (allp_fun_id Delta && (P * Q)) |-- P' * Q'.

Proof.

  intros.

  rewrite <- andp_assoc in *.

  eapply derives_trans; [| apply sepcon_derives; [exact H | exact H0]].

  rewrite corable_andp_sepcon1, corable_sepcon_andp1 by (intro; simpl; apply corable_andp; [apply corable_prop | apply corable_allp_fun_id]).

  solve_andp.

Qed.



Lemma wand_ENTAILL: forall Delta P P' Q Q',

  local (tc_environ Delta) && (allp_fun_id Delta && P') |-- P ->

  local (tc_environ Delta) && (allp_fun_id Delta && Q) |-- Q' ->

  local (tc_environ Delta) && (allp_fun_id Delta && (P -* Q)) |-- P' -* Q'.

Proof.

  intros.

  rewrite <- andp_assoc in *.

  rewrite <- wand_sepcon_adjoint.

  eapply derives_trans; [| apply H0].

  rewrite corable_andp_sepcon1 by (intro; simpl; apply corable_andp; [apply corable_prop | apply corable_allp_fun_id]).

  apply andp_right; [apply andp_left1, derives_refl |].

  rewrite <- corable_sepcon_andp1 by (intro; simpl; apply corable_andp; [apply corable_prop | apply corable_allp_fun_id]).

  rewrite sepcon_comm, wand_sepcon_adjoint.

  eapply derives_trans; [apply H |].

  rewrite <- wand_sepcon_adjoint.

  apply modus_ponens_wand.

Qed.



Lemma exp_ENTAILL: forall Delta B (P Q: B -> environ -> mpred),

  (forall x: B, local (tc_environ Delta) && (allp_fun_id Delta && P x) |-- Q x) ->

  local (tc_environ Delta) && (allp_fun_id Delta && exp P) |-- exp Q.

Proof.

  intros.

  rewrite !exp_andp2.

  apply exp_derives; auto.

Qed.



Lemma later_ENTAILL: forall Delta P Q,

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- Q ->

  local (tc_environ Delta) && (allp_fun_id Delta && |> P) |-- |> Q.

Proof.

  intros.

  rewrite <- andp_assoc in *.

  apply later_left2, H.

Qed.



Lemma andp_subst_ENTAILL: forall Delta P P' Q Q' i v t,

  (temp_types Delta) ! i = Some t ->

  local (tc_environ Delta) && (allp_fun_id Delta && P') |-- local (`(tc_val' t) v) ->

  local (tc_environ Delta) && (allp_fun_id Delta && P') |-- Q' ->

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- Q ->

  local (tc_environ Delta) && (allp_fun_id Delta && (P' && subst i v P)) |-- Q' && subst i v Q.

Proof.

  intros.

  apply (subst_derives i v) in H2.

  autorewrite with subst in H2.

  eapply derives_trans; [| apply andp_derives; eassumption].

  repeat apply andp_right; try solve_andp.

  rewrite <- !andp_assoc; apply andp_left1; rewrite andp_assoc.

  rewrite (add_andp _ _ H0).

  unfold local, lift1; unfold_lift.

  intro rho; simpl; normalize; clear H0 H1 H2.

  apply prop_right.

  unfold subst, env_set.

  destruct rho; simpl in *.

  destruct H3; split; auto.

  clear H1; simpl in *.

  hnf; intros.

  specialize (H0 _ _ H1).

  destruct H0 as [? [? ?]].

  destruct (Pos.eq_dec i id).

  + subst.

    rewrite Map.gss.

    exists (v (mkEnviron ge ve te)); split; auto.

    rewrite H in H1.

    inv H1.

    auto.

  + exists x.

    rewrite Map.gso by auto.

    auto.

Qed.



Lemma derives_bupd_bupd_left: forall TC P Q,

  local TC && P |-- |==> Q ->

  (local TC && |==> P) |-- |==> Q.

Proof.

  intros.

  eapply derives_trans; [apply local_andp_bupd |].

  eapply derives_trans; [apply bupd_mono, H |].

  apply bupd_trans.

Qed.



Lemma derives_bupd0_bupd0_left: forall TC P Q,

  local TC && P |-- |==> |> FF || Q ->

  (local TC && |==> |> FF || P) |-- |==> |> FF || Q.

Proof.

  intros.

  apply derives_bupd_bupd_left.

  rewrite andp_comm, distrib_orp_andp, !(andp_comm _ (local _)).

  apply orp_left.

  + apply andp_left2.

    eapply derives_trans; [| apply bupd_intro].

    apply orp_right1; auto.

  + auto.

Qed.



Lemma derives_full_bupd0_left: forall Delta P Q,

  local (tc_environ Delta) && (allp_fun_id Delta && P) |-- |==> |> FF || Q ->

  local (tc_environ Delta) && (allp_fun_id Delta && |==> |> FF || P) |-- |==> |> FF || Q.

Proof.

  intros.

  rewrite <- andp_assoc in H |- *.

  eapply derives_trans; [apply corable_andp_bupd; intro; simpl; apply corable_andp; [apply corable_prop | apply corable_allp_fun_id] |].

  eapply derives_trans; [apply bupd_mono | apply bupd_trans].

  rewrite andp_comm, distrib_orp_andp, !(andp_comm _ (_ && _)).

  apply orp_left.

  + apply andp_left2.

    eapply derives_trans; [| apply bupd_intro].

    apply orp_right1; auto.

  + auto.

Qed.



Ltac lifted_derives_L2R H :=

  eapply ENTAIL_trans; [apply H |].



Ltac ENTAIL_L2R H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply ENTAIL_trans; [apply H |]

  | _ =>

      eapply ENTAIL_trans; [apply derives_ENTAIL, H |]

  end.



Ltac derives_bupd_L2R H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_bupd_trans; [apply H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_bupd_trans; [apply ENTAIL_derives_bupd, H |]

  | _ =>

      eapply derives_bupd_trans; [apply ENTAIL_derives_bupd, derives_ENTAIL, H |]

  end.



Ltac derives_bupd0_L2R H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

      eapply derives_bupd0_trans; [apply H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_bupd0_trans; [apply derives_bupd_derives_bupd0, H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_bupd0_trans; [apply derives_bupd_derives_bupd0, ENTAIL_derives_bupd, H |]

  | _ =>

      eapply derives_bupd0_trans; [apply derives_bupd_derives_bupd0, ENTAIL_derives_bupd, derives_ENTAIL, H |]

  end.



Ltac derives_full_L2R H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ ?Delta) && (allp_fun_id ?Delta && _)) (|==> |> FF || _) =>

      eapply derives_full_trans; [apply H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

      eapply derives_full_trans; [apply derives_bupd0_derives_full, H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_full_trans; [apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, H |]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_full_trans; [apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, ENTAIL_derives_bupd, H |]

  | _ =>

      eapply derives_full_trans; [apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, ENTAIL_derives_bupd, derives_ENTAIL, H |]

  end.



Tactic Notation "derives_rewrite" "->" constr(H) :=

  match goal with

  | |- @derives (environ -> mpred) _ (local (tc_environ ?Delta) && (allp_fun_id ?Delta && _)) (|==> |> FF || _) =>

         derives_full_L2R H

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

         derives_bupd0_L2R H

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

         derives_bupd_L2R H

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

         ENTAIL_L2R H

  | |- _ =>

         lifted_derives_L2R H

  end.



Ltac lifted_derives_R2L H :=

  eapply derives_trans; [| apply H].



Ltac ENTAIL_R2L H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply ENTAIL_trans; [| apply H]

  | _ =>

      eapply ENTAIL_trans; [| apply derives_ENTAIL, H]

  end.



Ltac derives_bupd_R2L H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_bupd_trans; [| apply H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_bupd_trans; [| apply ENTAIL_derives_bupd, H]

  | _ =>

      eapply derives_bupd_trans; [| apply ENTAIL_derives_bupd, derives_ENTAIL, H]

  end.



Ltac derives_bupd0_R2L H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

      eapply derives_bupd0_trans; [| apply H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_bupd0_trans; [| apply derives_bupd_derives_bupd0, H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_bupd0_trans; [| apply derives_bupd_derives_bupd0, ENTAIL_derives_bupd, H]

  | _ =>

      eapply derives_bupd0_trans; [| apply derives_bupd_derives_bupd0, ENTAIL_derives_bupd, derives_ENTAIL, H]

  end.



Ltac derives_full_R2L H :=

  match type of H with

  | @derives (environ -> mpred) _ (local (tc_environ ?Delta) && (allp_fun_id ?Delta && _)) (|==> |> FF || _) =>

      eapply derives_bupd0_trans; [| apply H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

      eapply derives_bupd0_trans; [| apply derives_bupd0_derives_full, H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

      eapply derives_bupd0_trans; [| apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, H]

  | @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

      eapply derives_bupd0_trans; [| apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, ENTAIL_derives_bupd, H]

  | _ =>

      eapply derives_bupd0_trans; [| apply derives_bupd0_derives_full, derives_bupd_derives_bupd0, ENTAIL_derives_bupd, derives_ENTAIL, H]

  end.



Tactic Notation "derives_rewrite" "<-" constr(H) :=

  match goal with

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> |> FF || _) =>

         derives_bupd0_R2L H

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) (|==> _) =>

         derives_bupd_R2L H

  | |- @derives (environ -> mpred) _ (local (tc_environ _) && _) _ =>

         ENTAIL_R2L H

  | |- _ =>

         lifted_derives_R2L H

  end.



Ltac solve_derives_trans :=

  first [simple apply derives_full_refl | eapply derives_full_trans; [eassumption | solve_derives_trans]].



Lemma aux1_reduceR: forall P Q: environ -> mpred,

  P |-- |==> Q ->

  P |-- |==> |> FF || Q.

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply bupd_mono.

  apply orp_right2; auto.

Qed.



Lemma aux2_reduceR: forall P Q: environ -> mpred,

  P |-- Q ->

  P |-- |==> Q.

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply bupd_intro.

Qed.



Ltac reduceR :=

  match goal with

  | |- _ |-- |==> |> FF || _ => apply aux1_reduceR

  | _ => idtac

  end;

  match goal with

  | |- _ |-- |==> _ => apply aux2_reduceR

  | _ => idtac

  end.



Lemma aux_reduceL: forall P Q R S: environ -> mpred,

  P && R |-- S ->

  P && (Q && R) |-- S.

Proof.

  intros.

  eapply derives_trans; [| exact H].

  solve_andp.

Qed.



Ltac reduceLL :=

  match goal with

  | |- local (tc_environ ?Delta) && (allp_fun_id ?Delta && _) |-- _ => apply aux_reduceL

  | _ => idtac

  end.



Ltac reduceL :=

  match goal with

  | |- local (tc_environ ?Delta) && (allp_fun_id ?Delta && _) |-- _ => apply aux_reduceL

  | _ => idtac

  end;

  match goal with

  | |- local (tc_environ _) && _ |-- _ => apply derives_ENTAIL

  | _ => idtac

  end.



Ltac reduce2derives :=

  reduceL; reduceR.



Ltac reduce2ENTAIL :=

  reduceLL; reduceR.

