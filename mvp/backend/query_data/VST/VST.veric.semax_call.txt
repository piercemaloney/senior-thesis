Require Import Coq.Logic.FunctionalExtensionality.

Require Import VST.veric.juicy_base.
(* VST.veric.juicy_base:
Require Export VST.veric.base.
Require Export VST.msl.msl_standard.
Require Export VST.veric.rmaps.

Require Export VST.veric.rmaps_lemmas.

Require Export VST.veric.compcert_rmaps.

Export Mem.
Open Scope Z. *)

Require Import VST.msl.normalize.
(* VST.msl.normalize:
Require Import VST.msl.msl_standard.

Local Open Scope pred.

Lemma andp_TT {A}`{ageable A}: forall (P: pred A), P && TT = P.

Lemma sepcon_andp_prop' {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall P Q R, (!!Q && P)*R = !!Q&&(P*R).

Hint Rewrite @sepcon_emp @emp_sepcon @TT_and @andp_TT
             @exp_sepcon1 @exp_sepcon2
               @exp_andp1 @exp_andp2
         @sepcon_andp_prop @sepcon_andp_prop'
        : normalize.

Definition pure {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}
     (P: pred A) : Prop :=
   P |-- emp.

Lemma pure_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall (P : pred A), pure P -> P*P=P.

Lemma pure_e {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall (P: pred A), pure P -> (P |-- emp).

Hint Resolve @pure_e.

Lemma sepcon_pure_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
 forall P Q, pure P -> pure Q -> ((P * Q) = (P && Q)).

Lemma pure_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: pure emp.
Hint Resolve @pure_emp.

Lemma join_equiv_refl {A}: forall x:A, @join A (Join_equiv A) x x x.
Hint Resolve @join_equiv_refl.

Lemma pure_sepcon1'' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall P Q R, pure P -> Q |-- R -> P * Q |-- R.

Lemma pure_existential {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
   forall B (P: B -> pred A),    (forall x: B , pure (P x)) -> pure (exp P).

Hint Resolve @pure_existential.

Lemma pure_core {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall P w, pure P -> P w -> P (core w).

Lemma FF_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
           forall P, FF * P = FF.
Lemma sepcon_FF {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
            forall P, P * FF = FF.
Hint Rewrite @FF_sepcon @sepcon_FF : normalize.

Hint Rewrite @prop_true_andp using (solve [auto]) : normalize.

Lemma true_eq {A} `{ageable A}:  forall P: Prop, P -> (!! P) = (TT: pred A).
Hint Rewrite @true_eq using (solve [auto]) : normalize.

Lemma pure_con' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
      forall P Q, pure P -> pure Q -> pure (P*Q).
Hint Resolve @pure_con'.

Lemma pure_intersection1: forall {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}
       (P Q: pred A), pure P -> pure (P && Q).
Lemma pure_intersection2: forall {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}
     (P Q: pred A), pure Q -> pure (P && Q).
Hint Resolve @pure_intersection1 @pure_intersection2.

Lemma FF_andp {A} `{ageable A}:  forall P: pred A, FF && P = FF.
Lemma andp_FF {A}`{ageable A}:  forall P: pred A, P && FF = FF.
Hint Rewrite @FF_andp @andp_FF : normalize.

Hint Rewrite @andp_dup : normalize.

Lemma andp_emp_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
 forall (Q: pred A),
     (forall w1 w2, core w1 = core w2 -> Q w1 -> Q w2) ->
      (Q && emp * TT = Q).

Lemma sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
   forall (P: pred A), P |-- (P * TT).
Hint Resolve @sepcon_TT.

Lemma imp_extract_exp_left {B A: Type} `{ageable A}:
    forall    (p : B -> pred A) (q: pred A),
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma pure_sepcon_TT_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall P Q, pure P -> (P * TT) && Q = (P*Q).

Lemma pure_sepcon_TT_andp' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall P Q, pure P -> Q && (P * TT) = (Q*P).

Hint Rewrite @pure_sepcon_TT_andp @pure_sepcon_TT_andp' using (solve [auto]): normalize.

Lemma pure_sepcon1' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall P Q R, pure P -> P * Q |-- P * R -> P * Q |-- R.

Lemma pull_right {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
 forall P Q R,
   (Q * P * R) = (Q * R * P).

Lemma pull_right0 {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall P Q,
   (P * Q) = (Q * P).

Ltac pull_left A := repeat (rewrite <- (pull_right A) || rewrite <- (pull_right0 A)).

Ltac pull_right A := repeat (rewrite (pull_right A) || rewrite (pull_right0 A)).

Lemma pure_modus {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall P Q,  P |-- Q -> pure Q -> P |-- Q && P.

Lemma imp_exp_right {B A : Type} `{saA: ageable A}:
  forall (x: B) (p: pred A) (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma derives_extract_prop {A} `{ageable A}:
  forall (P: Prop) (Q R: pred A), (P -> Q |-- R) ->  !!P && Q |-- R.

Lemma derives_extract_prop' {A} `{ageable A}:
  forall (P: Prop) (Q R: pred A), (P -> Q |-- R) ->  Q && !!P|-- R.

Ltac normalize1 :=
             match goal with
                | |- _ => contradiction
                | |- context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) by (auto with normalize)
                | |- context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) by (auto with normalize)
                | |- context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) by (auto with normalize)
                | |- context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) by (auto with normalize)
                | |- _ => progress  (autorewrite with normalize); auto with typeclass_instances
                | |- _ = ?x -> _ => intro; subst x
                | |- ?x = _ -> _ => intro; subst x
                |  |- ?ZZ -> _ => match type of ZZ with
                                               | Prop =>
                                                    let H := fresh in
                                                       ((assert (H:ZZ) by auto; clear H; intros _) || intro H)
                                               | _ => intros _
                                              end
                | |- forall _, _ => let x := fresh "x" in (intro x; normalize1; try generalize dependent x)
                | |- exp _ |-- _ => apply imp_extract_exp_left
                | |- !! _ && _ |-- _ => apply derives_extract_prop
                | |- _ && !! _ |-- _ => apply derives_extract_prop'
                | |- _ |-- !! (?x = ?y) && _ =>
                            (rewrite prop_true_andp with (P:= (x=y))
                                            by (unfold y; reflexivity); unfold y in *; clear y) ||
                            (rewrite prop_true_andp with (P:=(x=y))
                                            by (unfold x; reflexivity); unfold x in *; clear x)
                | |- _ => solve [auto with typeclass_instances]
                end.

Ltac normalize1_in Hx :=
             match type of Hx with
                | app_pred (exp _) _ => destruct Hx
                | app_pred (!! _ && _) _ => let H1 := fresh in destruct Hx as [H1 Hx]; unfold prop in H1
                | context [ !! ?P ] =>
                                    rewrite (true_eq P) in Hx by auto with typeclass_instances
                | context [ !! ?P && ?Q ] =>
                                    rewrite (prop_true_andp P Q) in Hx by auto with typeclass_instances
                | context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) in Hx by (auto with normalize)
                | context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) in Hx by (auto with normalize)
                | context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) in Hx by (auto with normalize)
                | context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) in Hx by (auto with normalize)
                | _ => progress  (autorewrite with normalize in Hx); auto with typeclass_instances
                end.

Ltac normalize := repeat normalize1.

Tactic Notation "normalize" "in" hyp(H) := repeat (normalize1_in H).

Definition mark {A: Type} (i: nat) (j: A) := j.

Lemma swap_mark1 {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall i j Pi Pj B, (i<j)%nat -> B * mark i Pi * mark j Pj = B * mark j Pj * mark i Pi.

Lemma swap_mark0 {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall i j Pi Pj,  (i<j)%nat -> mark i Pi * mark j Pj = mark j Pj * mark i Pi.

Ltac select_left n :=
  repeat match goal with
 | |- context [(_ * mark ?i _ * mark n _)%pred] =>
      rewrite (swap_mark1 i n); [ | solve [simpl; auto]]
 | |- context [(mark ?i _ * mark n _)%pred] =>
      rewrite (swap_mark0 i n); [ | solve [simpl; auto]]
end.
Ltac select_all n := match n with
                                | O => idtac
                                | S ?n' => select_left n; select_all n'
                              end.
Ltac markem n P :=
   match P with
   | (?Y * ?Z) =>
        (match goal with H: mark _ Z = Z |- _ => idtac end
        || assert (mark n Z = Z) by auto); markem (S n) Y
   | ?Z =>  match goal with H: mark _ Z = Z |- _ => idtac end
                || assert (mark n Z = Z) by auto
  end.

Ltac prove_assoc_commut :=
 clear;
 try (match goal with |- ?F _ -> ?G _ => replace G with F; auto end);
  (repeat rewrite <- sepcon_assoc;
   match goal with |- ?P = _ => markem O P end;
   let LEFT := fresh "LEFT" in match goal with |- ?P = _ => set (LEFT := P) end;
  match goal with H: mark ?n _ = _ |- _ =>
     repeat  match goal with H: mark ?n _ = ?P |- _ => rewrite <- H; clear H end;
     select_all n;
     reflexivity
   end).

Lemma test_prove_assoc_commut {T}{JA: Join T}{PA: Perm_alg T}{agA: ageable T}{AgeA: Age_alg T} : forall A B C D E : pred T,
   D * E * A * C * B = A * B * C * D * E. *)

Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
(* VST.veric.juicy_mem:
Require Import VST.veric.base.
Require Import VST.veric.Memory.
Require Import VST.veric.juicy_base.
Require Import VST.veric.shares.
Import cjoins.

Definition dec_share_nonidentity (sh: Share.t) : {~identity sh}+{identity sh} :=
   (Sumbool.sumbool_not _ _ (dec_share_identity sh)).

Definition perm_of_sh (sh: Share.t): option permission :=
  if writable0_share_dec sh
  then if eq_dec sh Share.top
            then Some Freeable
            else Some Writable
    else if readable_share_dec sh
         then Some Readable
         else if eq_dec sh Share.bot
                   then None
              else Some Nonempty.
Functional Scheme perm_of_sh_ind := Induction for perm_of_sh Sort Prop.

Definition contents_at (m: mem) (loc: address) : memval :=
  ZMap.get (snd loc) (PMap.get (fst loc) (mem_contents m)).

Definition contents_cohere (m: mem) (phi: rmap) :=
  forall rsh sh v loc pp, phi @ loc = YES rsh sh (VAL v) pp -> contents_at m loc = v /\ pp=NoneP.

Definition valshare (r: resource) : share :=
    match r with
      | YES sh rsh _ _ => Share.glb Share.Rsh sh
      | _ => Share.bot
    end.

Definition res_retain' (r: resource) : Share.t :=
 match r with
  | NO sh _ => sh
  | YES sh _ _ _ => Share.glb Share.Lsh sh
  | PURE _ _ => Share.top
 end.

Definition perm_of_res (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh rsh (VAL _) _ => perm_of_sh sh
 | YES sh rsh _ _ => Some Nonempty
 end.

Definition perm_of_res_lock_explicit
             (r : compcert_rmaps.RML.R.resource):=
    match r with
    | compcert_rmaps.RML.R.NO _ _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ =>
      if writable0_share_dec (Share.glb Share.Rsh sh)
      then if eq_dec (Share.glb Share.Rsh sh) Share.top then Some Freeable else Some Writable
      else if readable_share_dec (Share.glb Share.Rsh sh) then Some Readable else
             if eq_dec  (Share.glb Share.Rsh sh) Share.bot then None else Some Nonempty
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => None
    | compcert_rmaps.RML.R.PURE _ _ => None
    end.
      
  Functional Scheme perm_of_res_lock_expl_ind := Induction for perm_of_res_lock_explicit Sort Prop.

Definition perm_of_res' (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh _ _ _ => perm_of_sh sh
 end.

Definition perm_of_res_lock (r: resource) := 
  
 match r with
 | YES sh rsh (LK _ _) _ => perm_of_sh (Share.glb Share.Rsh sh)
 | _ => None 
 end.

Definition perm_of_res_explicit
               (r : compcert_rmaps.RML.R.resource):=
        match r with
        | compcert_rmaps.RML.R.NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ =>
             if writable0_share_dec sh
             then if eq_dec sh Share.top then Some Freeable else Some Writable
             else
               if readable_share_dec sh
               then Some Readable
               else if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.PURE _ _ => Some Nonempty
        end.
      
Functional Scheme perm_of_res_expl_ind := Induction for perm_of_res_explicit Sort Prop.

Lemma Rsh_not_top: Share.Rsh <> Share.top.

Lemma nonidentity_Rsh: ~identity Share.Rsh.

Lemma perm_of_sh_fullshare: perm_of_sh fullshare = Some Freeable.

Lemma nonreadable_extern_retainer: ~readable_share extern_retainer.

Lemma Lsh_nonreadable: ~readable_share Share.Lsh.

Lemma perm_of_res_op1:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res r).

Lemma perm_of_res_op2:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res_lock r).

Definition access_cohere (m: mem)  (phi: rmap) :=
  forall loc,  access_at m loc Cur = perm_of_res (phi @ loc).

Definition max_access_at m loc := access_at m loc Max.

Definition max_access_cohere (m: mem) (phi: rmap)  :=
  forall loc,
    perm_order'' (max_access_at m loc) (perm_of_res' (phi @ loc)).

Definition alloc_cohere (m: mem) (phi: rmap) :=
 forall loc,  (fst loc >= nextblock m)%positive -> phi @ loc = NO Share.bot bot_unreadable.

Inductive juicy_mem: Type :=
  mkJuicyMem: forall (m: mem) (phi: rmap)
    (JMcontents: contents_cohere m phi)
    (JMaccess: access_cohere m phi)
    (JMmax_access: max_access_cohere m phi)
    (JMalloc: alloc_cohere m phi),
       juicy_mem.

Section selectors.
Variable (j: juicy_mem).
Definition m_dry := match j with mkJuicyMem m _ _ _ _ _ => m end.
Definition m_phi := match j with mkJuicyMem _ phi _ _ _ _ => phi end.
Lemma juicy_mem_contents: contents_cohere m_dry m_phi.
Lemma juicy_mem_access: access_cohere m_dry m_phi.
Lemma juicy_mem_max_access: max_access_cohere m_dry m_phi.
Lemma juicy_mem_alloc_cohere: alloc_cohere m_dry m_phi.
End selectors.

Definition juicy_mem_resource: forall jm m', resource_at m' = resource_at (m_phi jm) ->
  {jm' | m_phi jm' = m' /\ m_dry jm' = m_dry jm}.

Lemma perm_of_empty_inv {s} : perm_of_sh s = None -> s = Share.bot.

Lemma writable_join_sub: forall loc phi1 phi2,
  join_sub phi1 phi2 -> writable loc phi1 -> writable loc phi2.

Lemma writable_inv: forall phi loc, writable loc phi ->
  exists sh, exists rsh, exists k, exists pp, 
       phi @ loc = YES sh rsh k pp /\ 
       writable0_share sh /\
       isVAL k.

Lemma nreadable_inv: forall phi loc, ~readable loc phi 
  -> (exists sh, exists nsh, phi @ loc = NO sh nsh)
   \/ (exists sh, exists rsh, exists k, exists pp, phi @ loc = YES sh rsh k pp /\ ~isVAL k)
   \/ (exists k, exists pp, phi @ loc = PURE k pp).

Lemma age1_joinx {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3 phi1' phi2' phi3',
             age phi1 phi1' -> age phi2 phi2' -> age phi3 phi3' ->
             join phi1 phi2 phi3 -> join phi1' phi2' phi3'.

Lemma constructive_age1_join  {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall x y z x' : A,
       join x y z ->
       age x x' ->
       { yz' : A*A | join x' (fst yz') (snd yz') /\ age y (fst yz') /\ age z (snd yz')}.

Lemma age1_constructive_joins_eq : forall {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}  {phi1 phi2},
  constructive_joins phi1 phi2
  -> forall {phi1'}, age1 phi1 = Some phi1'
  -> forall {phi2'}, age1 phi2 = Some phi2'
  -> constructive_joins phi1' phi2'.

Program Definition age1_juicy_mem (j: juicy_mem): option juicy_mem :=
      match age1 (m_phi j) with
        | Some phi' => Some (mkJuicyMem (m_dry j) phi' _ _ _ _)
        | None => None
      end.

Lemma age1_juicy_mem_unpack: forall j j',
  age1_juicy_mem j = Some j' ->
  age (m_phi j)  (m_phi j')
  /\ m_dry j = m_dry j'.

Lemma age1_juicy_mem_unpack': forall j j',
  age (m_phi j)  (m_phi j')  /\ m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma age1_juicy_mem_unpack'': forall j j',
  age (m_phi j)  (m_phi j')  -> m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma rmap_join_eq_level: forall phi1 phi2: rmap, joins phi1 phi2 -> level phi1 = level phi2.

Lemma rmap_join_sub_eq_level: forall phi1 phi2: rmap,
          join_sub phi1 phi2 -> level phi1 = level phi2.

Lemma age1_juicy_mem_None1:
  forall j, age1_juicy_mem j = None -> age1 (m_phi j) = None.

Lemma age1_juicy_mem_None2:
  forall j, age1 (m_phi j) = None -> age1_juicy_mem j = None.

Lemma age1_juicy_mem_Some:
  forall j j', age1_juicy_mem j = Some j' -> age1 (m_phi j) = Some (m_phi j').

Lemma unage_juicy_mem: forall j' : juicy_mem,
   exists j : juicy_mem, age1_juicy_mem j = Some j'.

Lemma level1_juicy_mem: forall j: juicy_mem,
  age1_juicy_mem j = None <-> level (m_phi j) = 0%nat.

Lemma level2_juicy_mem: forall j1 j2: juicy_mem,
   age1_juicy_mem j1 = Some j2 -> level (m_phi j1) = S (level (m_phi j2)).

Lemma juicy_mem_ageable_facts: ageable_facts juicy_mem (fun j => level (m_phi j)) age1_juicy_mem.

Instance juicy_mem_ageable: ageable juicy_mem :=
  mkAgeable _ (fun j => level (m_phi j)) age1_juicy_mem juicy_mem_ageable_facts.

Lemma level_juice_level_phi: forall (j: juicy_mem), level j = level (m_phi j).

Lemma juicy_mem_ext: forall j1 j2,
       m_dry j1 = m_dry j2  ->
       m_phi j1 = m_phi j2 ->
       j1=j2.

Lemma unage_writable: forall (phi phi': rmap) loc,
  age phi phi' -> writable loc phi' -> writable loc phi.

Lemma unage_readable: forall (phi phi': rmap) loc,
  age phi phi' -> readable loc phi' -> readable loc phi.

Lemma readable_inv: forall phi loc, readable loc phi ->
  exists rsh, exists sh, exists v, exists pp, phi @ loc = YES rsh sh (VAL v) pp.

Definition fmap_option {A B} (v: option A) (m: B) (f: A -> B): B :=
  match v with
    | None => m
    | Some v' => f v'
  end.

Lemma resource_at_make_rmap: forall f g lev H Hg, resource_at (proj1_sig (make_rmap f g lev H Hg)) = f.

Lemma resource_at_remake_rmap: forall f g lev H Hg, resource_at (proj1_sig (remake_rmap f g lev H Hg)) = f.

Lemma ghost_of_make_rmap: forall f g lev H Hg, ghost_of (proj1_sig (make_rmap f g lev H Hg)) = g.

Lemma ghost_of_remake_rmap: forall f g lev H Hg, ghost_of (proj1_sig (remake_rmap f g lev H Hg)) = g.

Lemma level_make_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (make_rmap f g lev H Hg)) = lev.

Lemma level_remake_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (remake_rmap f g lev H Hg)) = lev.

Section inflate.
Variables (m: mem) (phi: rmap).

Definition inflate_initial_mem' (w: rmap) (loc: address) :=
   match access_at m loc Cur with
           | Some Freeable => YES Share.top readable_share_top (VAL (contents_at m loc)) NoneP
           | Some Writable => YES Ews (writable_readable writable_Ews) (VAL (contents_at m loc)) NoneP
           | Some Readable => YES Ers readable_Ers (VAL (contents_at m loc)) NoneP
           | Some Nonempty => 
                         match w @ loc with PURE _ _ => w @ loc | _ => NO _ nonreadable_extern_retainer end
           | None =>  NO Share.bot bot_unreadable
         end.

Lemma inflate_initial_mem'_fmap:
 forall w, resource_fmap (approx (level w)) (approx (level w)) oo inflate_initial_mem' w =
                inflate_initial_mem' w.

Definition inflate_initial_mem (w: rmap): rmap :=
    proj1_sig (make_rmap (inflate_initial_mem' w) (ghost_of w) _
            (inflate_initial_mem'_fmap w) (ghost_of_approx w)).

Lemma inflate_initial_mem_level: forall w, level (inflate_initial_mem w) = level w.

Definition all_VALs (phi: rmap) :=
  forall l, match phi @ l with
              | YES _ _ k _ => isVAL k
              | _ => True
            end.

Lemma inflate_initial_mem_all_VALs: forall lev, all_VALs (inflate_initial_mem lev).

Definition inflate_alloc: rmap.

Lemma approx_map_idem: forall n (lp: preds),
  preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) lp) =
  preds_fmap (approx n) (approx n) lp.

Definition inflate_store: rmap. refine (

End inflate.

Lemma adr_inv0: forall (b b': block) (ofs ofs': Z) (sz: Z),
  ~ adr_range (b, ofs) sz (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + sz.

Lemma adr_inv: forall (b b': block) (ofs ofs': Z) ch,
  ~ adr_range (b, ofs) (size_chunk ch) (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + size_chunk ch.

Lemma range_inv0: forall ofs ofs' sz,
  ~ ofs <= ofs' < ofs + sz ->
  ofs' < ofs \/ ofs' >= ofs + sz.

Lemma range_inv: forall ofs ofs' ch,
  ~ ofs <= ofs' < ofs + size_chunk ch ->
  ofs' < ofs \/ ofs' >= ofs + size_chunk ch.

Lemma perm_of_sh_Freeable_top: forall sh, perm_of_sh sh = Some Freeable -> 
     sh = Share.top.

Lemma nextblock_access_empty: forall m b ofs k, (b >= nextblock m)%positive
  -> access_at m (b, ofs) k = None.

Section initial_mem.
Variables (m: mem) (w: rmap).

Definition initial_rmap_ok := 
   forall loc, ((fst loc >= nextblock m)%positive -> core w @ loc = NO Share.bot bot_unreadable) /\
                   (match w @ loc with 
                    | PURE _ _ => (fst loc < nextblock m)%positive /\ 
                                           access_at m loc Cur = Some Nonempty /\  
                                            max_access_at m loc = Some Nonempty 
                    | _ => True end).
Hypothesis IOK: initial_rmap_ok.
End initial_mem.

Definition empty_retainer (loc: address) := Share.bot.

Lemma perm_of_freeable: perm_of_sh Share.top = Some Freeable.

Lemma perm_of_writable: 
   forall sh, writable_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

Lemma perm_of_readable:
  forall sh (rsh: readable_share sh), ~writable0_share sh -> perm_of_sh sh = Some Readable.

Lemma perm_of_nonempty:
  forall sh, sh <> Share.bot -> ~readable_share sh -> perm_of_sh sh = Some Nonempty.

Lemma perm_of_empty:
    perm_of_sh Share.bot = None.

Lemma perm_of_Ews: perm_of_sh Ews = Some Writable.

Lemma perm_of_Ers: perm_of_sh Ers = Some Readable.

Lemma extern_retainer_neq_bot: extern_retainer <> Share.bot.

Lemma perm_order''_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Definition initial_mem (m: mem) lev (IOK: initial_rmap_ok m lev) : juicy_mem.

Definition juicy_mem_level (j: juicy_mem) (lev: nat) :=
  level (m_phi j) = lev.

Lemma initial_mem_level: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_level j (level lev).

Lemma initial_mem_all_VALs: forall lev m j IOK, j = initial_mem m lev IOK
  -> all_VALs (m_phi j).

Lemma perm_mem_access: forall m b ofs p,
  perm m b ofs Cur p ->
  exists p', (perm_order p' p /\ access_at m (b, ofs) Cur = Some p').

Section store.
Variables (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m').

Lemma store_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (size_chunk ch) loc'
  -> (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP -> contents_at m' loc' = mv.

Definition store_juicy_mem: juicy_mem.

End store.

Section storebytes.
Variables (jm: juicy_mem) (m': mem) (b: block) (ofs: Z) (bytes: list memval)
  (STOREBYTES: storebytes (m_dry jm) b ofs bytes = Some m').

Lemma storebytes_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (Zlength bytes) loc' ->
  (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP ->
  contents_at m' loc' = mv.

Definition storebytes_juicy_mem: juicy_mem.

End storebytes.

Lemma free_smaller_None : forall m b b' ofs lo hi m',
  access_at m (b, ofs) Cur = None
  -> free m b' lo hi = Some m'
  -> access_at m' (b, ofs) Cur = None.

Lemma free_nadr_range_eq : forall m b b' ofs' lo hi m',
  ~ adr_range (b, lo) (hi - lo) (b', ofs')
  -> free m b lo hi = Some m'
  -> access_at m (b', ofs') = access_at m' (b', ofs')
  /\  contents_at m (b', ofs') = contents_at m' (b', ofs').

Section free.
Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable).

Definition inflate_free: rmap. refine (

Definition free_juicy_mem: juicy_mem.

End free.

Lemma free_not_freeable_eq : forall m b lo hi m' b' ofs',
  free m b lo hi = Some m'
  -> access_at m (b', ofs') Cur <> Some Freeable
  -> access_at m (b', ofs') Cur = access_at m' (b', ofs') Cur.

Definition after_alloc' 
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else phi @ loc.

Lemma adr_range_eq_block : forall b ofs n b' ofs',
  adr_range (b,ofs) n (b',ofs') ->
  b=b'.

Lemma after_alloc'_ok : forall lo hi b phi H,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (after_alloc' lo hi b phi H)
  = after_alloc' lo hi b phi H.

Definition after_alloc
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable) : rmap :=
  proj1_sig (make_rmap (after_alloc' lo hi b phi H) (ghost_of phi)
    (level phi)
    (after_alloc'_ok lo hi b phi H) (ghost_of_approx phi)).

Definition mod_after_alloc' (phi: rmap) (lo hi: Z) (b: block)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else core phi @ loc.

Lemma mod_after_alloc'_ok : forall phi lo hi b,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (mod_after_alloc'  phi lo hi b)
  = mod_after_alloc' phi lo hi b.

Definition mod_after_alloc (phi: rmap) (lo hi: Z) (b: block) :=
  proj1_sig (make_rmap (mod_after_alloc' phi lo hi b) (ghost_of phi)
    _
    (mod_after_alloc'_ok phi lo hi b) (ghost_of_approx phi)).

Transparent alloc.

Lemma adr_range_inv: forall loc loc' n,
  ~ adr_range loc n loc' ->
  fst loc <> fst loc' \/ (fst loc=fst loc' /\ ~snd loc <= snd loc' < snd loc + n).

Lemma dry_noperm_juicy_nonreadable : forall m loc,
  access_at (m_dry m) loc Cur = None ->   ~readable loc (m_phi m).

Lemma fullempty_after_alloc : forall m1 m2 lo n b ofs,
  alloc m1 lo n = (m2, b) ->
  access_at m2 (b, ofs) Cur = None \/ access_at m2 (b, ofs) Cur = Some Freeable.

Lemma alloc_dry_unchanged_on : forall m1 m2 loc lo hi b0,
  alloc m1 lo hi = (m2, b0) ->
  ~adr_range (b0,lo) (hi-lo) loc ->
  access_at m1 loc = access_at m2 loc /\
  (access_at m1 loc Cur <> None -> contents_at m1 loc= contents_at m2 loc).

Lemma adr_range_zle_fact : forall b lo hi loc,
  adr_range (b,lo) (hi-lo) loc ->
  zle lo (snd loc) && zlt (snd loc) hi = true.

Lemma alloc_dry_updated_on : forall m1 m2 lo hi b loc,
  alloc m1 lo hi = (m2, b) ->
  adr_range (b, lo) (hi - lo) loc ->
  access_at m2 loc Cur=Some Freeable /\
  contents_at m2 loc=Undef.

Definition resource_decay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
 forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = 
                       YES sh (writable0_readable wsh) (VAL v) NoneP /\ 
       phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)
  \/ ((fst l >= nextb)%positive /\ exists v, phi2 @ l = YES Share.top readable_share_top (VAL v) NoneP)
  \/ (exists v, exists pp, phi1 @ l = YES Share.top readable_share_top (VAL v) pp 
                        /\ phi2 @ l = NO Share.bot bot_unreadable)).

Definition resource_nodecay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
  forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = YES sh (writable0_readable wsh) (VAL v) NoneP
      /\ phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)).

Lemma resource_nodecay_decay:
   forall b phi1 phi2, resource_nodecay b phi1 phi2 -> resource_decay b phi1 phi2.

Lemma resource_decay_refl: forall b phi, 
  (forall l, (fst l >= b)%positive -> phi @ l = NO Share.bot bot_unreadable) ->

Lemma resource_decay_trans: forall b b' m1 m2 m3,
  (b <= b')%positive ->
  resource_decay b m1 m2 -> resource_decay b' m2 m3 -> resource_decay b m1 m3.

Lemma level_store_juicy_mem:
 forall jm m ch b i v H, level (store_juicy_mem jm m ch b i v H) = level jm.

Lemma level_storebytes_juicy_mem:
 forall jm m b i bytes H, level (storebytes_juicy_mem jm m b i bytes H) = level jm.

Lemma inflate_store_resource_nodecay:
  forall (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable))
          phi',
  inflate_store m' (m_phi jm) = phi' -> resource_nodecay (nextblock (m_dry jm)) (m_phi jm) phi'.

Lemma inflate_free_resource_decay:
 forall (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs : Z,
             lo <= ofs < hi -> perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),
   resource_decay (nextblock (m_dry jm)) (m_phi jm) (inflate_free jm b lo hi).

Lemma juicy_store_nodecay:
  forall jm m' ch b ofs v
       (H: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable)),
       resource_nodecay (nextblock (m_dry jm)) (m_phi jm) (m_phi (store_juicy_mem jm _ _ _ _ _ H)).

Lemma can_age1_juicy_mem: forall j r,
  age (m_phi j) r -> exists j', age1 j = Some j'.

Lemma can_age_jm:
  forall jm, age1 (m_phi jm) <> None -> exists jm', age jm jm'.

Lemma age_jm_dry: forall {jm jm'}, age jm jm' -> m_dry jm = m_dry jm'.

Lemma age_jm_phi: forall {jm jm'}, age jm jm' -> age (m_phi jm) (m_phi jm').

Lemma age1_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma age1_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma age1_PURE_2 {phi phi' l k P} :
  age1 phi = Some phi' ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma perm_of_res_age x y loc :
  age x y -> perm_of_res (x @ loc) = perm_of_res (y @ loc).

Lemma contents_cohere_age m : hereditary age (contents_cohere m).

Lemma access_cohere_age m : hereditary age (access_cohere m).

Lemma max_access_cohere_age m : hereditary age (max_access_cohere m).

Lemma alloc_cohere_age m : hereditary age (alloc_cohere m).

Definition unage {A} {_:ageable A} x y := age y x.

Lemma unage_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma unage_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma unage_PURE_2 {phi phi' l k P} :
  age1 phi' = Some phi ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma contents_cohere_unage m : hereditary unage (contents_cohere m).

Lemma access_cohere_unage m : hereditary unage (access_cohere m).

Lemma max_access_cohere_unage m : hereditary unage (max_access_cohere m).

Lemma alloc_cohere_unage m : hereditary unage (alloc_cohere m).

Lemma juicy_mem_unage jm' : { jm | age jm jm' }. *)
(* VST.veric.juicy_mem_lemmas:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.
Require Import VST.veric.shares.

Definition juicy_mem_core (j: juicy_mem) : rmap := core (m_phi j).

Definition no_VALs (phi: rmap) := forall loc,
  match phi @ loc with
    | YES _ _ (VAL _) _ => False | _ => True
  end.

Lemma components_join_joins {A} {JA: Join A}{PA: Perm_alg A}{TA: Trip_alg A}: forall a b c d,
   join a b c -> joins a d -> joins b d -> joins c d.

Lemma contents_cohere_join_sub: forall m phi phi',
  contents_cohere m phi -> join_sub phi' phi -> contents_cohere m phi'.

Lemma perm_of_sh_join_sub: forall (sh1 sh2: Share.t) p,

Lemma perm_order'_trans: forall p1 p2 p3,
  perm_order' (Some p1) p2 -> perm_order' (Some p2) p3 -> perm_order' (Some p1) p3.

Lemma rmap_unage_YES: forall phi phi' sh rsh k pp loc, 
  age phi phi' 
  -> phi' @ loc = YES sh rsh k pp 
  -> exists pp', phi @ loc = YES sh rsh k pp'.

Lemma preds_fmap_NoneP_approx: forall pp lev1 lev2,
  preds_fmap (approx lev1) (approx lev1) pp = NoneP ->
  preds_fmap (approx lev2) (approx lev2) pp = NoneP.
Proof.
intros.
destruct pp.
unfold NoneP, approx, compose in *.
simpl in *. unfold compose in *.
inv H. simpl in *.
apply EqdepFacts.eq_sigT_eq_dep in H2.

Lemma oracle_unage:
  forall (jm': juicy_mem) (w: rmap), age w (m_phi jm') ->
       exists jm, age jm jm' /\ m_phi jm = w.

Lemma writable_perm:
  forall b i jm, writable (b,i) (m_phi jm) -> Mem.perm (m_dry jm) b i Cur Writable.

Lemma valid_access_None: forall m ch b b' ofs ofs' p,
  Mem.valid_access m ch b ofs p

Lemma core_load_getN: forall ch v b ofs bl phi m,
  contents_cohere m phi
  -> (core_load' ch (b, ofs) v bl)%pred phi
  -> bl = Mem.getN (size_chunk_nat ch) ofs (PMap.get b (Mem.mem_contents m)).

Lemma core_load_valid: forall ch v b ofs m phi,
  (core_load ch (b, ofs) v)%pred phi
  -> access_cohere m phi
  -> Mem.valid_access m ch b ofs Readable.

Lemma core_load_load': forall ch b ofs v m,
  core_load ch (b, ofs) v (m_phi m) -> Mem.load ch (m_dry m) b ofs = Some v.

Lemma Zminus_lem: forall z1 z2, z1 <= z2 -> nat_of_Z (z2 - z1) = O -> z1=z2.

Lemma nat_of_Z_lem1: forall n z, S n = nat_of_Z z -> n = nat_of_Z (z - 1).

Lemma nat_of_Z_lem2: forall n z1 z2, S n = nat_of_Z (z1 - z2) -> n = nat_of_Z (z1 - z2 - 1).

Lemma nth_getN: forall m b ofs ofs' z,
  ofs <= ofs' < ofs + z
  -> z >= 0
  -> contents_at m (b, ofs')
  = nth (nat_of_Z (ofs' - ofs)) (Mem.getN (nat_of_Z z) ofs (PMap.get b (Mem.mem_contents m))) Undef.

Lemma load_core_load: forall ch b ofs v m,
  Mem.load ch (m_dry m) b ofs = Some v ->

Lemma core_load_load: forall ch b ofs v m,
  (forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi m @ (b,z))) (Some Readable)) ->
  (core_load ch (b, ofs) v (m_phi m) <-> Mem.load ch (m_dry m) b ofs = Some v).

Lemma mapsto_valid_access: forall ch v sh b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Readable.

Lemma mapsto_valid_access_wr: forall ch v sh (wsh: writable0_share sh) b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Writable.

Program Definition mapsto_can_store_definition ch v sh (wsh: writable0_share sh) b ofs jm (v':val)
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)):
  Memory.mem. 

Lemma mapsto_can_store_property: forall (ch:memory_chunk) v sh (wsh: writable0_share sh) b ofs jm v'
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)),
  Mem.store ch (m_dry jm) b ofs v' = 

Lemma mapsto_can_store: forall ch v sh (wsh: writable0_share sh) b ofs jm v',
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> exists m', Mem.store ch (m_dry jm) b ofs v' = Some m'.

Lemma store_outside':
   forall ch m b z v m',
          Mem.store ch m b z v = Some m' ->

Lemma adr_range_zle_zlt : forall  b lo hi ofs,
  adr_range (b,lo) (hi-lo) (b,ofs)
  -> zle lo ofs && zlt ofs hi = true.

Lemma join_top: forall sh2 sh, join Share.top sh2 sh -> sh = Share.top.

Lemma juicy_free_aux_lemma:
 forall phi b lo hi F,
 app_pred (VALspec_range (hi-lo) Share.top (b,lo) * F) phi ->

Lemma juicy_free_lemma:
  forall {j b lo hi m' m1 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Section free.

Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable)
          (phi1 phi2 : rmap) (Hphi1: VALspec_range (hi-lo) Share.top (b,lo) phi1)
          (Hjoin : join phi1 phi2 (m_phi jm)).

Lemma phi2_eq : m_phi (free_juicy_mem _ _ _ _ _ FREE) = phi2.

End free.

Lemma juicy_free_lemma':
  forall {j b lo hi m' m1 m2 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Lemma initial_mem_core: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_core j = core lev.

Lemma writable_writable_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  writable loc (m_phi (initial_mem m1 lev IOK1)) ->
  writable loc (m_phi (initial_mem m2 lev IOK2)).

Lemma readable_eq_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  readable loc (m_phi (initial_mem m1 lev IOK1)) ->
  m_phi (initial_mem m1 lev IOK1) @ loc=m_phi (initial_mem m2 lev IOK2) @ loc.

Lemma necR_m_dry:
  forall jm jm', necR jm jm' -> m_dry jm = m_dry jm'.

Lemma perm_order''_trans p1 p2 p3 :
  perm_order'' p1 p2 ->
  perm_order'' p2 p3 ->
  perm_order'' p1 p3.

Lemma po_join_sub_sh sh1 sh2 :
  join_sub sh2 sh1 ->
  Mem.perm_order'' (perm_of_sh sh1) (perm_of_sh sh2).

Lemma po_join_sub r1 r2 :
  join_sub r2 r1 ->
  Mem.perm_order'' (perm_of_res r1) (perm_of_res r2).

Lemma perm_of_res_lock_not_Freeable:
  forall r,
    perm_order'' (Some Writable) (perm_of_res_lock r).

Definition readable_perm (p: option permission) :
  {perm_order'' p (Some Readable)}+{~perm_order'' p (Some Readable)}.

Definition rebuild_juicy_mem_fmap (jm: juicy_mem) (m': mem) : (AV.address -> resource) :=
 fun loc =>
   match m_phi jm @ loc with
    PURE k pp => PURE k pp
   | NO sh rsh => if readable_perm (access_at m' loc Cur)
                            then YES Tsh (writable_readable writable_share_top)
                                        (VAL (contents_at m' loc)) NoneP
                            else NO sh rsh 
   | YES sh rsh (VAL _) _ => 
                 if readable_perm (access_at m' loc Cur)
                 then YES sh rsh (VAL (contents_at m' loc)) NoneP
                 else NO _ bot_unreadable
   | YES sh rsh _ _ => m_phi jm @ loc
end.

Definition rebuild_juicy_mem_rmap (jm: juicy_mem) (m': mem) :
  {phi : rmap |
  level phi = level jm /\
  resource_at phi = rebuild_juicy_mem_fmap jm m' /\
  ghost_of phi = ghost_of (m_phi jm)}. *)
(* VST.veric.juicy_mem_ops:
Require Import VST.veric.juicy_base.
Import cjoins.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.shares.

Module Type JUICY_MEM_OPS.
Parameter juicy_mem_store
  : juicy_mem -> memory_chunk -> block -> Z -> val -> option juicy_mem.

Parameter juicy_mem_storebytes
  : juicy_mem -> block -> Z -> list memval -> option juicy_mem.

Parameter juicy_mem_alloc
  : juicy_mem -> Z -> Z -> juicy_mem * block.

Axiom juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.
Axiom juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JUICY_MEM_OPS.

Obligation Tactic := Tactics.program_simpl.

Module JuicyMemOps <: JUICY_MEM_OPS.
Program Definition juicy_mem_store j ch b ofs v: option juicy_mem :=
  if valid_access_dec (m_dry j) ch b ofs Writable
    then Some (store_juicy_mem j _ ch b ofs v _)
    else None.

Lemma juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.

Program Definition juicy_mem_storebytes j b ofs bytes: option juicy_mem :=
  if range_perm_dec (m_dry j) b ofs (ofs + Z_of_nat (length bytes)) Cur Writable
    then Some (storebytes_juicy_mem j _ b ofs bytes _)
    else None.

Lemma juicy_mem_storebytes_succeeds: forall j j' b ofs bytes,
  juicy_mem_storebytes j b ofs bytes = Some j' ->
  exists m', storebytes (m_dry j) b ofs bytes = Some m' /\ m' = m_dry j'.

Lemma pshare_sh_bot: forall p, pshare_sh p = Share.bot -> False.

Lemma juicy_mem_alloc_aux1:
  forall jm lo hi m' b, alloc (m_dry jm) lo hi = (m',b) ->
        forall ofs, m_phi jm @ (b,ofs) = NO Share.bot bot_unreadable.

Lemma after_alloc_contents_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
  contents_cohere m'
    (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_max_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 max_access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_alloc_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 alloc_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Definition juicy_mem_alloc (jm: juicy_mem) (lo hi: Z) : juicy_mem * block :=
         (mkJuicyMem (fst (alloc (m_dry jm) lo hi))
                     (after_alloc lo hi (snd (alloc (m_dry jm) lo hi)) (m_phi jm)
                            (juicy_mem_alloc_aux1 _ _ _ _ _ (eq_refl _)))
                     (after_alloc_contents_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_max_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_alloc_cohere _ _ _ _ _ (eq_refl _)),
           snd (alloc (m_dry jm) lo hi)).

Lemma juicy_mem_alloc_at:
  forall jm lo hi jm' b,
     juicy_mem_alloc jm lo hi = (jm',b) ->
     forall loc, m_phi jm' @ loc =
       if adr_range_dec (b, lo) (hi - lo) loc
       then YES Share.top readable_share_top (VAL Undef) NoneP

Lemma juicy_mem_alloc_level:
 forall jm lo hi jm' b,
   juicy_mem_alloc jm lo hi = (jm', b) -> level jm = level jm'.

Lemma juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JuicyMemOps.

Module Abs := JuicyMemOps.
Require Import VST.veric.local.

Inductive AbsPrimcom : relation juicy_mem -> Prop :=
| AbsPrimcom_store : forall ch b ofs v,
  AbsPrimcom (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
| AbsPrimcom_alloc : forall lo hi,
  AbsPrimcom (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
.
Inductive AbsPrimexpr : pfunc juicy_mem val -> Prop :=.

Instance abstract : GenericSemantics juicy_mem AbsPrimcom AbsPrimexpr := {}.

Inductive ConcPrimcom : relation mem -> Prop :=
| ConcPrimcom_store : forall ch b ofs v,
  ConcPrimcom (fun m m' => store ch m b ofs v = Some m')
| ConcPrimcom_alloc : forall lo hi,
  ConcPrimcom (fun m m' => fst (alloc m lo hi) = m')
| ConcPrimcom_free : forall b ofs n,
  ConcPrimcom (fun m m' => free m b ofs n = Some m').

Inductive ConcPrimexpr : pfunc mem val -> Prop :=.

Instance concrete : GenericSemantics mem ConcPrimcom ConcPrimexpr := {}.

Inductive VU : relation juicy_mem -> relation mem -> Prop :=
| VU_store : forall ch b ofs v,
  VU (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
     (fun m m' => store ch m b ofs v = Some m')
| VU_alloc : forall lo hi,
  VU (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
     (fun m m' => fst (alloc m lo hi) = m')
.

Inductive GF : pfunc juicy_mem val -> pfunc mem val -> Prop :=.

Lemma PrimexprErasure : forall g f, GF g f -> False. Proof. inversion 1. Qed.

Lemma PrimcomErasure : forall v u j j' m m',
  VU v u -> m_dry j = m -> v j j' -> u m m' -> m_dry j' = m'.

Lemma PrimcomSafety : forall v u j j' m,
  VU v u -> m_dry j = m -> v j j' -> exists m', u m m'. *)

Require Import VST.veric.res_predicates.
(* VST.veric.res_predicates:
Require Import VST.msl.log_normalize.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.  
Require Import VST.veric.shares. 
Require Import VST.veric.address_conflict.

Import RML. Import R.
Local Open Scope pred.

Program Definition kind_at (k: kind) (l: address) : pred rmap :=
   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.

Program Definition yesat_raw (pp: preds) (k: kind) 
                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=
   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

Obligation Tactic := idtac.

Program Definition yesat (pp: preds) (k: kind) : spec :=
 fun (sh: share) (l: AV.address) (m: rmap) =>

Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

Ltac do_map_arg :=
match goal with |- ?a = ?b =>
  match a with context [map ?x _] =>
    match b with context [map ?y _] => replace y with x; auto end end end.

Lemma yesat_raw_eq_aux:
  forall pp k rsh sh l,
    hereditary age
    (fun phi : rmap =>
     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Lemma yesat_raw_eq: yesat_raw =
  fun pp k rsh sh l =>
  ((exist (hereditary age)
   (fun phi =>
   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))
   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Lemma yesat_eq_aux: 
  forall pp k sh l, 
    hereditary age
    (fun m : rmap =>
      exists rsh, 
     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =
     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Lemma yesat_eq: yesat = fun pp k sh l =>
 exist (hereditary age)
  (fun m => 
  exists rsh, 
   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 
   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))
   (yesat_eq_aux pp k sh l).

Lemma map_compose_approx_succ_e:
  forall A n pp pp',
       map (compose (A:=A) (approx (S n))) pp =
    map (compose (A:=A) (approx (S n))) pp' ->
  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Program Definition noat (l: AV.address) : pred rmap :=

Definition resource_share (r: resource) : option share :=
 match r with
 | YES sh _ _ _ => Some sh
 | NO sh _ => Some sh
 | PURE _ _ => None
 end.

Definition nonlock (r: resource) : Prop :=
 match r with
 | YES _ _ k _ => isVAL k \/ isFUN k
 | NO _ _ => True
 | PURE _ _ => False
 end.

Lemma age1_nonlock: forall phi phi' l,
  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Lemma age1_resource_share: forall phi phi' l,
  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  join sh1 sh2 sh ->
  resource_share r = Some sh.

Lemma resource_share_joins: forall r1 r2 sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  joins r1 r2 ->
  joins sh1 sh2.

Lemma nonlock_join: forall r1 r2 r,
  nonlock r1 ->
  nonlock r2 ->
  join r1 r2 r ->
  nonlock r.

Program Definition nonlockat (l: AV.address): pred rmap :=

Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=
  fun (l: B) m => if S l then P l m else Q l m.

Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,
      (forall (x: A), boxy m (P x)) ->
      (forall x, boxy m (Q x)) ->
      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),
      (forall (x: A), boxy extendM (P x)) ->
      (forall x, boxy extendM (Q x)) ->
      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Definition jam_vacuous:
  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),
  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  {w' | level w' = level w /\ resource_at w' =
       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=
  forall l w, (p l) w = q (w @ l) l (level w).

Definition resource_stable (p: address -> pred rmap) :=
  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.

Lemma is_resource_pred_resource_stable: forall {p},
  (exists q, is_resource_pred p q) -> resource_stable p.

Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l})
  (R_DEC: forall l, {R l} + {~ R l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (exists resp, is_resource_pred r resp) ->
  Ensemble_join Q R P ->
  (forall l, Q l -> p l = q l) ->
  (forall l, R l -> p l = r l) ->
  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  allp (jam P_DEC p noat) && noghost =
  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->
  (exists l, P l /\ Q l) ->
  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Lemma yesat_join_diff:
  forall pp pp' k k' sh sh' l w, k <> k' -> 
                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Lemma yesat_raw_join:
  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),
  nonunit x -> join x y z -> nonunit z.

Lemma yesat_join:
  forall pp k sh1 sh2 sh3 l m1 m2 m3,
   join sh1 sh2 sh3 ->   
   yesat pp k sh1 l m1 ->
   yesat pp k sh2 l m2 ->
   join m1 m2 m3 ->
   yesat pp k sh3 l m3.

Definition spec_parametric (Q: address -> spec) : Prop :=
   forall l l', exists pp, exists ok,
             forall sh m,
           Q l sh l' m = 
            (exists p, exists k, ok k /\ m @ l' = 
                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).

Lemma YES_ext:
  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Definition VALspec : spec :=
       fun (sh: Share.t) (l: address) =>
          allp (jam (eq_dec l)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat) && noghost.

Definition VALspec_range (n: Z) : spec :=
     fun (sh: Share.t) (l: address) =>
          andp (allp (jam (adr_range_dec l n)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat)) noghost.

Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=
  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.

Definition nthbyte (n: Z) (l: list memval) : memval :=
     nth (nat_of_Z n) l Undef.

Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address)  => 
             allp (jam (adr_range_dec l (size_chunk ch)) 
                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')
                           noat).

Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address) =>
           EX bl: list memval, 
               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&
                (allp (jam (adr_range_dec l (size_chunk ch))
                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)
                                    noat)) && noghost.

Lemma address_mapsto_align: forall ch v sh l,
  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Lemma address_mapsto_fun:
  forall ch sh sh' l v v',
          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Definition LKspec lock_size (R: pred rmap) : spec :=
   fun (sh: Share.t) (l: AV.address)  =>
    allp (jam (adr_range_dec l lock_size)
               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')
               noat) && noghost.

Definition TTat (l: address) : pred rmap := TT.

Lemma address_mapsto_old_parametric: forall ch v, 
   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Lemma VALspec_parametric: 
  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Lemma LKspec_parametric lock_size: forall R: pred rmap,
  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Definition val2address (v: val) : option AV.address := 
  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.

Lemma VALspec_readable:
  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.

Lemma address_mapsto_VALspec:
  forall ch v sh l i, 0 <= i < size_chunk ch ->
        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Lemma address_mapsto_exists:
  forall ch v sh (rsh: readable_share sh) loc w0
      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

Lemma VALspec1: VALspec_range 1 = VALspec.

Lemma VALspec_range_exp_address_mapsto:
  forall ch sh l,
    (align_chunk ch | snd l) ->
    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Lemma address_mapsto_VALspec_range:
  forall ch v sh l,
        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Lemma approx_eq_i:
  forall (P Q: pred rmap) (w: rmap),
      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},
         laterR (level w) n' ->
       exists w', laterR w w' /\ n' = level w'.

Lemma VALspec_range_bytes_readable:
  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Lemma VALspec_range_bytes_writable:
  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Lemma yesat_join_sub:
  forall pp k l sh m m',
          join_sub m m' ->
          yesat pp k sh l m ->
         exists sh', yesat pp k sh' l m'.

Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Lemma nonlock_permission_bytes_precise: forall sh p n,
  precise (nonlock_permission_bytes sh p n).

Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=
  EX bl: list memval,
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)
  : pred rmap :=
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.
Hint Resolve VALspec_range_0: normalize.

Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,
  ~ nonunit sh ->
  nonlock_permission_bytes sh p n |-- emp.

Lemma is_resource_pred_YES_VAL sh:
  is_resource_pred
    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')
    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_YES_VAL' sh v:
  is_resource_pred
    (fun l' => yesat NoneP (VAL (v l')) sh l')
    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_nonlock_shareat sh:
  is_resource_pred
    (fun i : address => shareat i sh && nonlockat i)
    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Lemma VALspec_range_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma nonlock_permission_bytes_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma VALspec_range_VALspec:
  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,
  adr_range p1 n1 p2 ->
  n2 > 0 ->
  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Lemma address_mapsto_overlap':
  forall sh ch1 v1 ch2 v2 a1 a2,
     adr_range a1 (size_chunk ch1) a2 ->
     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,
  range_overlap l1 n1 l2 n2 ->
  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,
  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->
  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Lemma nonlock_permission_bytes_overlap:
  forall sh n1 n2 p1 p2,
  nonunit sh ->
  range_overlap p1 n1 p2 n2 ->
  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Lemma address_mapsto_value_cohere':
  forall ch v1 v2 sh1 sh2 a r
 (Hmaps1 : address_mapsto ch v1 sh1 a r)
 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Lemma address_mapsto_value_cohere:
  forall ch v1 v2 sh1 sh2 a,
 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Definition almost_empty rm: Prop:=
  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.

Definition no_locks phi :=
  forall addr sh sh' z z' P,
phi @ addr <> YES sh sh' (LK z z') P. *)

Require Import VST.veric.extend_tc.
(* VST.veric.extend_tc:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.

Local Open Scope pred.

Definition tc_expr {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred:=
  fun rho => denote_tc_assert (typecheck_expr Delta e) rho.

Definition tc_exprlist {CS: compspecs} (Delta: tycontext) (t : list type) (e: list expr) : environ -> mpred :=
      fun rho => denote_tc_assert (typecheck_exprlist Delta t e) rho.

Definition tc_lvalue {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred :=
     fun rho => denote_tc_assert (typecheck_lvalue Delta e) rho.

Definition tc_temp_id {CS: compspecs} (id : positive) (ty : type)
  (Delta : tycontext) (e : expr) : environ -> mpred  :=
     fun rho => denote_tc_assert (typecheck_temp_id id ty Delta e) rho.

Definition tc_expropt {CS: compspecs} Delta (e: option expr) (t: type) : environ -> mpred :=
   match e with None => `!!(t=Tvoid)
                     | Some e' => tc_expr Delta (Ecast e' t)
   end.

Definition tc_temp_id_load id tfrom Delta v : environ -> mpred  :=
fun rho => !! (exists tto, (temp_types Delta) ! id = Some tto
                      /\ tc_val tto (eval_cast tfrom tto (v rho))).

Lemma extend_prop: forall P, boxy extendM (prop P).

Hint Resolve extend_prop.

Lemma extend_tc_temp_id_load :  forall id tfrom Delta v rho, boxy extendM (tc_temp_id_load id tfrom Delta v rho).

Lemma extend_tc_andp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp A B) rho).

Lemma extend_tc_bool:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert (tc_bool A B) rho).

Lemma extend_tc_int_or_ptr_type:
 forall {CS: compspecs} A rho,
   boxy extendM (denote_tc_assert (tc_int_or_ptr_type A) rho).

Lemma extend_tc_Zge:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zge v i) rho).

Lemma extend_tc_Zle:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zle v i) rho).

Lemma extend_tc_iszero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_iszero v) rho).

Lemma extend_valid_pointer':
  forall a b, boxy extendM (valid_pointer' a b).

Lemma extend_andp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (andp P Q).

Lemma extend_orp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (orp P Q).

Lemma extend_tc_test_eq:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_eq e1 e2) rho).

Lemma extend_tc_test_order:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_order e1 e2) rho).

Lemma extend_isCastResultType:
 forall {CS: compspecs} t t' v rho,
   boxy extendM (denote_tc_assert (isCastResultType t t' v) rho).

Lemma extend_tc_temp_id: forall {CS: compspecs} id ty Delta e rho, boxy extendM (tc_temp_id id ty Delta e rho).

Lemma extend_tc_samebase:
  forall {CS: compspecs} e1 e2 rho,
boxy extendM (denote_tc_assert (tc_samebase e1 e2) rho).

Lemma extend_tc_nonzero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_nonzero v) rho).

Lemma extend_tc_nodivover:
 forall {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nodivover e1 e2) rho).

Lemma extend_tc_nosignedover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nosignedover op e1 e2) rho).

Lemma extend_tc_nobinover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nobinover op e1 e2) rho).

Lemma boxy_orp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Lemma extend_tc_orp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_orp A B) rho).

Lemma extend_tc_ilt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_ilt e i) rho).

Lemma extend_tc_llt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_llt e i) rho).

Lemma extend_tc_andp':
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp' A B) rho).

Ltac extend_tc_prover := 
  match goal with
  | |- _ => solve [immediate]
  | |- _ => apply extend_prop
  | |- _ => first
              [ simple apply extend_tc_bool
              | simple apply extend_tc_int_or_ptr_type
              | simple apply extend_tc_andp
              | simple apply extend_tc_andp'
              | simple apply extend_tc_Zge
              | simple apply extend_tc_Zle
              | simple apply extend_tc_iszero
              | simple apply extend_tc_nonzero
              | simple apply extend_tc_nodivover
              | simple apply extend_tc_nobinover
              | simple apply extend_tc_samebase
              | simple apply extend_tc_ilt
              | simple apply extend_tc_llt
              | simple apply extend_isCastResultType
              | simple apply extend_tc_test_eq
              | simple apply extend_tc_test_order]
  | |- boxy _ (denote_tc_assert (if ?A then _ else _) _) => destruct A
  | |- boxy _ (denote_tc_assert match tc_bool ?A _ with _ => _ end _) =>
             destruct A
  | |- boxy _ (denote_tc_assert match ?A with Some _ => _ | None => _ end _) =>
          destruct A
  end.

Lemma extend_tc_binop: forall {CS: compspecs} Delta e1 e2 b t rho, 
  boxy extendM (denote_tc_assert (typecheck_expr Delta e1) rho) ->
  boxy extendM (denote_tc_assert (typecheck_expr Delta e2) rho) ->
  boxy extendM (denote_tc_assert (isBinOpResultType b e1 e2 t) rho).

Lemma extend_tc_expr: forall {CS: compspecs} Delta e rho, boxy extendM (tc_expr Delta e rho)
 with extend_tc_lvalue: forall {CS: compspecs} Delta e rho, boxy extendM (tc_lvalue Delta e rho).

Lemma extend_tc_exprlist: forall {CS: compspecs} Delta t e rho, boxy extendM (tc_exprlist Delta t e rho).

Lemma extend_tc_expropt: forall {CS: compspecs} Delta e t rho, boxy extendM (tc_expropt Delta e t rho).

Hint Resolve extend_tc_expr extend_tc_temp_id extend_tc_temp_id_load extend_tc_exprlist extend_tc_expropt extend_tc_lvalue.
Hint Resolve (@extendM_refl rmap _ _ _ _ _). *)

Require Import VST.veric.Clight_seplog.
(* VST.veric.Clight_seplog:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.res_predicates.

Require Import VST.veric.mpred.
Require Import VST.veric.address_conflict.
Require Export VST.veric.shares.

Require Export VST.veric.seplog.

Require Export VST.veric.mapsto_memory_block.

Local Open Scope pred.

Require Import compcert.cfrontend.Clight. 
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.
Require Export VST.veric.Clight_mapsto_memory_block.

Local Open Scope pred.

Definition expr_true {CS: compspecs} e := lift1 (typed_true (typeof e)) (eval_expr e).

Definition expr_false {CS: compspecs} e := lift1 (typed_false (typeof e)) (eval_expr e).

Definition eval_lvar (id: ident) (ty: type) (rho: environ) :=
 match Map.get (ve_of rho) id with
| Some (b, ty') => if eqb_type ty ty' then Vptr b Ptrofs.zero else Vundef
| None => Vundef
end.

Definition var_block (sh: Share.t) {cs: compspecs} (idt: ident * type) (rho: environ): mpred :=
  !! (sizeof (snd idt) <= Ptrofs.max_unsigned) &&
  (memory_block sh (sizeof (snd idt))) (eval_lvar (fst idt) (snd idt) rho).

Definition stackframe_of {cs: compspecs} (f: Clight.function) : assert :=
  fold_right (fun P Q rho => P rho * Q rho) (fun rho => emp) (map (fun idt => var_block Share.top idt) (Clight.fn_vars f)).

Lemma stackframe_of_eq : forall {cs: compspecs}, stackframe_of =
        fun f rho => fold_right sepcon emp (map (fun idt => var_block Share.top idt rho) (Clight.fn_vars f)).

Lemma  subst_derives:
 forall a v P Q, (forall rho, P rho |-- Q rho) -> forall rho, subst a v P rho |-- subst a v Q rho.

Definition tc_formals (formals: list (ident * type)) : environ -> Prop :=
     fun rho => tc_vals (map (@snd _ _) formals) (map (fun xt => (eval_id (fst xt) rho)) formals).

Program Definition close_precondition (params vars: list (ident * type)) (P: environ -> pred rmap) (rho: environ) : pred rmap :=
 fun phi =>
   exists ve', exists te',
   (forall i, In i (map (@fst _ _) params) -> Map.get te' i = Map.get (te_of rho) i) /\

Lemma close_precondition_i:
  forall params vars P rho,
  P rho |-- close_precondition params vars P rho.

Definition precondition_closed (f: function) {A: TypeTree}
  (P: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred) : Prop :=
 forall ts x,
  closed_wrt_vars (not_a_param (fn_params f)) (P ts x) /\
  closed_wrt_lvars (is_a_local (fn_vars f)) (P ts x).

Lemma close_precondition_e:
   forall f (A: TypeTree) (P:  forall ts, dependent_type_functor_rec ts (AssertTT A) mpred),
    precondition_closed f P ->
  forall ts x rho,
   close_precondition (fn_params f) (fn_vars f) (P ts x) rho |-- P ts x rho.

Definition bind_args (formals vars: list (ident * type)) (P: environ -> pred rmap) : assert :=
          fun rho => !! tc_formals formals rho && close_precondition formals vars P rho.

Definition ret_temp : ident := 1%positive.

Definition get_result1 (ret: ident) (rho: environ) : environ :=
   make_args (ret_temp::nil) (eval_id ret rho :: nil) rho.

Definition get_result (ret: option ident) : environ -> environ :=
 match ret with
 | None => make_args nil nil
 | Some x => get_result1 x
 end.

Definition bind_ret (vl: option val) (t: type) (Q: assert) : assert :=
     match vl, t with
     | None, Tvoid => fun rho => Q (make_args nil nil rho)
     | Some v, _ => fun rho => !! (tc_val t v) &&
                               Q (make_args (ret_temp::nil) (v::nil) rho)
     | _, _ => fun rho => FF
     end.

Definition funassert (Delta: tycontext): assert := funspecs_assert (glob_specs Delta).

Definition proj_ret_assert (Q: ret_assert) (ek: exitkind) (vl: option val) : assert :=
 match ek with
 | EK_normal => RA_normal Q
 | EK_break => RA_break Q
 | EK_continue => RA_continue Q
 | EK_return => RA_return Q vl
 end.

Definition overridePost  (Q: assert)  (R: ret_assert) :=
 match R with 
  {| RA_normal := _; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Q; RA_break := b; RA_continue := c; RA_return := r |}
 end.

Definition existential_ret_assert {A: Type} (R: A -> ret_assert) :=
  {| RA_normal := fun rho => EX x:A, (R x).(RA_normal) rho;
     RA_break := fun rho => EX x:A, (R x).(RA_break) rho;
     RA_continue := fun rho => EX x:A, (R x).(RA_continue) rho;
     RA_return := fun vl rho => EX x:A, (R x).(RA_return) vl rho
   |}.

Definition normal_ret_assert (Q: assert) : ret_assert :=
  {| RA_normal := Q; RA_break := seplog.FF; RA_continue := seplog.FF; RA_return := fun _ => seplog.FF |}.

Definition frame_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho * F rho; 
     RA_break := fun rho => b rho * F rho; 
     RA_continue := fun rho => c rho * F rho;
     RA_return := fun vl rho => r vl rho * F rho |}
 end.

Definition conj_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho && F rho; 
     RA_break := fun rho => b rho && F rho; 
     RA_continue := fun rho => c rho && F rho;
     RA_return := fun vl rho => r vl rho && F rho |}
 end.

Definition switch_ret_assert (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := seplog.FF; 
     RA_break := n; 
     RA_continue := c;
     RA_return := r |}
 end.

Require Import VST.msl.normalize.

Lemma normal_ret_assert_derives:
 forall P Q rho,
  P rho |-- Q rho ->
  forall ek vl, proj_ret_assert (normal_ret_assert P) ek vl rho 
            |-- proj_ret_assert (normal_ret_assert Q) ek vl rho.
Hint Resolve normal_ret_assert_derives.

Lemma normal_ret_assert_FF:
  forall ek vl rho, proj_ret_assert (normal_ret_assert (fun rho => FF)) ek vl rho = FF.

Lemma frame_normal:
  forall P F,
   frame_ret_assert (normal_ret_assert P) F = normal_ret_assert (fun rho => P rho * F rho).

Lemma proj_frame:
  forall P F ek vl,
    proj_ret_assert (frame_ret_assert P F) ek vl = fun rho => F rho * proj_ret_assert P ek vl rho.

Lemma proj_conj:
  forall P F ek vl,
    proj_ret_assert (conj_ret_assert P F) ek vl = fun rho => F rho && proj_ret_assert P ek vl rho.

Definition loop1_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n; 
     RA_continue := Inv;
     RA_return := r |}
 end.

Definition loop2_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n;
     RA_continue := seplog.FF;
     RA_return := r |}
 end.

Lemma frame_for1:
  forall Q R F,
   frame_ret_assert (loop1_ret_assert Q R) F =
   loop1_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma frame_loop1:
  forall Q R F,
   frame_ret_assert (loop2_ret_assert Q R) F =
   loop2_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma overridePost_normal:
  forall P Q, overridePost P (normal_ret_assert Q) = normal_ret_assert P.

Hint Rewrite normal_ret_assert_FF frame_normal frame_for1 frame_loop1
                 overridePost_normal: normalize.

Definition function_body_ret_assert (ret: type) (Q: assert) : ret_assert :=
 {| RA_normal := seplog.FF;
    RA_break := seplog.FF; 
    RA_continue := seplog.FF;
    RA_return := fun vl => bind_ret vl ret Q |}.

Lemma same_glob_funassert:
  forall Delta1 Delta2,
     (forall id, (glob_specs Delta1) ! id = (glob_specs Delta2) ! id) ->
              funassert Delta1 = funassert Delta2. *)

Require Import VST.veric.Clight_assert_lemmas.
(* VST.veric.Clight_assert_lemmas:
Require Export VST.veric.base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_seplog.
Require Export VST.veric.assert_lemmas.

Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.extend_tc.

Local Open Scope pred.

Lemma corable_funassert:
  forall G rho, corable (funassert G rho).

Hint Resolve corable_funassert.

Definition allp_fun_id (Delta : tycontext) (rho : environ): pred rmap :=
(ALL id : ident ,
 (ALL fs : funspec ,
  !! ((glob_specs Delta) ! id = Some fs) -->
  (EX b : block, !! (Map.get (ge_of rho) id = Some b) && func_at fs (b, 0)))).

Lemma corable_allp_fun_id: forall Delta rho,
  corable (allp_fun_id Delta rho).
  
Lemma allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  allp_fun_id Delta' rho |-- allp_fun_id Delta rho.

Lemma funassert_allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  funassert Delta' rho |-- allp_fun_id Delta rho.

Lemma prop_derives {A}{H: ageable A}:
 forall (P Q: Prop), (P -> Q) -> prop P |-- prop Q.

Section STABILITY.
Variable CS: compspecs.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma tc_bool_e_sub: forall b b' err rho phi,
  (b = true -> b' = true) ->
  denote_tc_assert (tc_bool b err) rho phi ->
  denote_tc_assert (tc_bool b' err) rho phi.

Lemma tc_bool_e_i:
  forall b c rho phi,
   b = true ->
  app_pred (denote_tc_assert (tc_bool b c) rho) phi.

Lemma tc_expr_lvalue_sub: forall rho,
  typecheck_environ Delta rho ->
  forall e,
    tc_expr Delta e rho |-- tc_expr Delta' e rho /\
    tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_expr_sub:
    forall e rho, typecheck_environ Delta rho -> tc_expr Delta e rho |-- tc_expr Delta' e rho.

Lemma tc_lvalue_sub:
    forall e rho, typecheck_environ Delta rho -> tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_temp_id_sub:
    forall id t e rho,
   tc_temp_id id t Delta e rho |-- tc_temp_id id t Delta' e rho.

Lemma tc_temp_id_load_sub:
   forall id t v rho,
   tc_temp_id_load id t Delta v rho |--    tc_temp_id_load id t Delta' v rho.

Lemma tc_exprlist_sub:
  forall e t rho, typecheck_environ Delta rho -> tc_exprlist Delta e t rho |-- tc_exprlist Delta' e t rho.

Definition typeof_temp (Delta: tycontext) (id: ident) : option type :=
 match (temp_types Delta) ! id with
 | Some t => Some t
 | None => None
 end.

Lemma typeof_temp_sub:
   forall i t,
    typeof_temp Delta i = Some t ->
    typeof_temp Delta' i = Some t.

End STABILITY. *)

Require Import VST.veric.Clight_new.
(* VST.veric.Clight_new:
Require Import VST.sepcomp.semantics.
Require Import VST.veric.Clight_base.
Require Import VST.veric.Clight_lemmas.
Require compcert.common.Globalenvs.

Inductive cont': Type :=
  | Kseq: statement -> cont'       
  | Kloop1: statement -> statement -> cont'
  | Kloop2: statement -> statement  -> cont'
  | Kswitch: cont'       
  | Kcall: forall (l: option ident),                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont'.

Definition cont := list cont'.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k => call_cont k
  | Kloop1 _ _ :: k => call_cont k
  | Kloop2 _ _ :: k => call_cont k
  | Kswitch :: k => call_cont k
  | _ => k
  end.

Fixpoint current_function (k: cont) : option function :=
 match k with
  | Kseq s :: k => current_function k
  | Kloop1 _ _ :: k => current_function k
  | Kloop2 _ _:: k =>current_function k
  | Kswitch :: k => current_function k
  | Kcall _ f _ _ :: _ => Some f
  | _ => None
  end.

Fixpoint continue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => continue_cont k'
  | Kloop1 s1 s2 :: k' => Kseq s2 :: Kloop2 s1 s2 :: k'
  | Kswitch :: k' => continue_cont k'
  | _ => nil 
  end.

Lemma call_cont_nonnil: forall k f, current_function k = Some f -> call_cont k <> nil.

Fixpoint precontinue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => precontinue_cont k'
  | Kloop1 _ _ :: _ => k
  | Kswitch :: k' => precontinue_cont k'
  | _ => nil 
  end.

Fixpoint break_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => break_cont k'
  | Kloop1 _ _ :: k' => k'
  | Kloop2 _ _ :: k' => k'
  | Kswitch :: k' => k'
  | _ =>  nil 
  end.

Inductive corestate :=
 | State: forall (ve: env) (te: temp_env) (k: cont), corestate
 | ExtCall: forall (ef: external_function) (args: list val)
                   (lid: option ident) (ve: env) (te: temp_env) (k: cont),
                corestate.

Fixpoint strip_skip (k: cont) : cont :=
 match k with Kseq Sskip :: k' => strip_skip k' | _ => k end.

Definition cl_at_external (c: corestate) : option (external_function * list val) :=
  match c with
  | State _ _ k => None
  | ExtCall ef args lid ve te k => Some (ef, args)
 end.

Definition cl_after_external (vret: option val) (c: corestate) : option corestate :=
  match vret, c with
  | Some v, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id v te) k)
  | None, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id Vundef te) k)
  | Some v, ExtCall ef args None ve te k => Some (State ve te k)
  | None, ExtCall ef args None ve te k => Some (State ve te k)
  | _, _ => None
  end.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option cont :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 :: k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 a3 =>
      match find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 a3 :: k) with
      | Some sk => Some sk
      | None => find_label lbl a3 (Kloop2 s1 a3 :: k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch :: k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(Kseq s' :: k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option cont :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') :: k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Inductive cl_step (ge: Clight.genv): forall (q: corestate) (m: mem) (q': corestate) (m': mem), Prop :=

  | step_assign: forall ve te k m a1 a2 loc ofs v2 v m',
     type_is_volatile (typeof a1) = false ->
      Clight.eval_lvalue ge ve te m a1 loc ofs ->
      Clight.eval_expr ge ve te m a2 v2 ->
      Cop.sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      Clight.assign_loc ge (typeof a1) m loc ofs v m' ->
      cl_step ge (State ve te (Kseq (Sassign a1 a2):: k)) m (State ve te k) m'

  | step_set:   forall ve te k m id a v,
      Clight.eval_expr ge ve te m a v ->
      cl_step ge (State ve te (Kseq (Sset id a) :: k)) m (State ve (PTree.set id v te) k) m

  | step_call_internal:   forall ve te k m optid a al tyargs tyres cc vf vargs f m1 ve' le',
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (Internal f) ->
      type_of_function f = Tfunction tyargs tyres cc ->
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_temps)) ->
      forall (NRV: list_norepet (var_names f.(fn_vars))),
      Clight.alloc_variables ge empty_env m (f.(fn_vars)) ve' m1 ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some
le' ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m
                   (State ve' le' (Kseq f.(fn_body) :: Kseq (Sreturn None) :: Kcall optid f ve te :: k)) m1

  | step_call_external:   forall ve te k m optid a al tyargs tyres cc vf vargs ef,
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (External ef tyargs tyres cc) ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m (ExtCall ef vargs optid ve te k) m

  | step_seq: forall ve te k m s1 s2 st' m',
          cl_step ge (State ve te (Kseq s1 :: Kseq s2 :: k)) m st' m' ->
          cl_step ge (State ve te (Kseq (Ssequence s1 s2) :: k)) m st' m'

  | step_skip: forall ve te k m st' m',
          cl_step ge (State ve te k) m st' m' ->
          cl_step ge (State ve te (Kseq Sskip :: k)) m st' m'

  | step_continue: forall ve te k m st' m',
           cl_step ge (State ve te (continue_cont k)) m st' m' ->
           cl_step ge (State ve te (Kseq Scontinue :: k)) m st' m'

  | step_break: forall ve te k m st' m',
                   cl_step ge (State ve te (break_cont k)) m st' m' ->
                   cl_step ge (State ve te (Kseq Sbreak :: k)) m st' m'

  | step_ifthenelse:  forall ve te k m a s1 s2 v1 b,
      Clight.eval_expr ge ve te m a v1 ->
      Cop.bool_val v1 (typeof a) m = Some b ->
      cl_step ge (State ve te (Kseq (Sifthenelse a s1 s2) :: k)) m (State ve te  (Kseq (if b then s1 else s2) :: k)) m

  | step_for: forall ve te k m s1 s2,
      cl_step ge (State ve te (Kseq (Sloop s1 s2) :: k)) m
              (State ve te (Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: k)) m

  | step_loop2: forall ve te k m a3 s,
      cl_step ge (State ve te (Kloop2 s a3 :: k)) m
             (State ve te (Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: k)) m

  | step_return: forall f ve te optexp optid k m v' m' ve' te' te'' k',
      call_cont k = Kcall optid f ve' te' :: k' ->
      Mem.free_list m (Clight.blocks_of_env ge ve) = Some m' ->
      match optexp with None => v' = Vundef
                                  | Some a => exists v, Clight.eval_expr ge ve te m a v
                                     /\ Cop.sem_cast v (typeof a) f.(fn_return) m = Some v'
                            end ->
      match optid with None => True /\ te''=te'
                                | Some id => True /\ te'' = PTree.set id v' te'
      end ->
      cl_step ge (State ve te (Kseq (Sreturn optexp) :: k)) m (State ve' te'' k') m'

  | step_switch: forall ve te k m a sl v n,
      Clight.eval_expr ge ve te m a v ->
      Cop.sem_switch_arg v (typeof a) = Some n ->
      cl_step ge (State ve te (Kseq (Sswitch a sl) :: k)) m
              (State ve te (Kseq (seq_of_labeled_statement (select_switch n sl)) :: Kswitch :: k)) m

  | step_label: forall ve te k m lbl s st' m',
       cl_step ge (State ve te (Kseq s :: k)) m st' m' ->
       cl_step ge (State ve te (Kseq (Slabel lbl s) :: k)) m st' m'

  | step_goto: forall f ve te k m lbl k'
                     
      (CUR: current_function k = Some f),
      find_label lbl f.(fn_body) (Kseq (Sreturn None) :: (call_cont k)) = Some k' ->
      cl_step ge (State ve te (Kseq (Sgoto lbl) :: k)) m (State ve te k') m.

Definition vret2v (vret: list val) : val :=
  match vret with v::nil => v | _ => Vundef end.

Definition cl_halted (c: corestate) : option val := None.

Definition empty_function : function := mkfunction Tvoid cc_default nil nil nil Sskip.

Fixpoint temp_bindings (i: positive) (vl: list val) :=
 match vl with
 | nil => PTree.empty val
 | v::vl' => PTree.set i v (temp_bindings (i+1)%positive vl')
 end.

Definition Tint32s := Tint I32 Signed noattr.
Definition true_expr : Clight.expr := Clight.Econst_int Int.one Tint32s.

Fixpoint typed_params (i: positive) (n: nat) : list (ident * type) :=
  match n with
  | O => nil
  | S n' => (i, Tint32s) :: typed_params (i+1)%positive n'
  end.

Fixpoint params_of_types (i: positive) (l : list type) : list (ident * type) :=
  match l with
  | nil => nil
  | t :: l => (i, t) :: params_of_types (i+1)%positive l
  end.

Fixpoint typelist2list (tl: typelist) : list type :=
  match tl with
  | Tcons t r => t::typelist2list r
  | Tnil => nil
  end.

Definition params_of_fundef (f: fundef) : list type :=
  match f with
  | Internal {| fn_params := fn_params |} => map snd fn_params
  | External _ t _ _ => typelist2list t
  end.

Inductive val_casted_list: list val -> typelist -> Prop :=
  | vcl_nil:
      val_casted_list nil Tnil
  | vcl_cons: forall v1 vl ty1 tyl,
      val_casted v1 ty1 -> val_casted_list vl tyl ->
      val_casted_list (v1 :: vl) (Tcons  ty1 tyl).

Definition cl_initial_core (ge: genv) (v: val) (args: list val) (q: corestate) : Prop :=
  match v with
    Vptr b i =>
    if Ptrofs.eq_dec i Ptrofs.zero then
      match Genv.find_funct_ptr ge b with
        Some f =>
        match type_of_fundef f with Tfunction targs _ c =>
        c = cc_default /\
        val_casted_list args targs /\
        Val.has_type_list args (Ctypes.typlist_of_typelist targs) /\
        q = State empty_env (temp_bindings 1%positive (v::args))
                    (Kseq (Scall None
                                 (Etempvar 1%positive (type_of_fundef f))
                                 (map (fun x => Etempvar (fst x) (snd x))
                                      (params_of_types 2%positive
                                                       (params_of_fundef f)))) ::
                          Kseq (Sloop Sskip Sskip) :: nil)
        | _ => False end
      | _ => False end
    else False
  | _ => False
end.

Lemma cl_corestep_not_at_external:
  forall ge m q m' q', cl_step ge q m q' m' -> cl_at_external q = None.

Lemma cl_corestep_not_halted :
  forall ge m q m' q', cl_step ge q m q' m' -> cl_halted q = None.

Lemma cl_after_at_external_excl :
  forall retv q q', cl_after_external retv q = Some q' -> cl_at_external q' = None.

Definition arg_well_formed args m0:=
  Val.inject_list (Mem.flat_inj (Mem.nextblock m0)) args args.

Program Definition cl_core_sem  (ge: genv):
  @CoreSemantics corestate mem :=
  @Build_CoreSemantics _ _
    
    (fun _ m c m' v args => cl_initial_core ge v args c /\ arg_well_formed args m /\ m' = m)
    (fun c _ => cl_at_external c)
    (fun ret c _ => cl_after_external ret c)
    (fun c _ =>  False )
    (cl_step ge)
    _
    (cl_corestep_not_at_external ge).

Lemma cl_corestep_fun: forall ge m q m1 q1 m2 q2,
    cl_step ge q m q1 m1 ->
    cl_step ge q m q2 m2 ->
    (q1,m1)=(q2,m2). *)

Require Import VST.sepcomp.extspec.
(* VST.sepcomp.extspec:
Require Import Coq.Lists.ListSet.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Maps.

Definition PTree_injective {A} (t: PTree.t A) : Prop :=
  forall id1 id2 b, t ! id1 = Some b -> t ! id2 = Some b -> id1 = id2.

Definition injective_PTree A := sig (@PTree_injective A).

Structure external_specification (M E Z : Type) :=
  { ext_spec_type : E -> Type
  ; ext_spec_pre: forall e: E,
    ext_spec_type e -> injective_PTree block -> list typ -> list val -> Z -> M -> Prop
  ; ext_spec_post: forall e: E,
    ext_spec_type e -> injective_PTree block -> option typ -> option val -> Z -> M ->  Prop
  ; ext_spec_exit: option val -> Z -> M ->  Prop }.

Arguments ext_spec_type {M E Z} _ _.
Arguments ext_spec_pre {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_post {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_exit {M E Z} _ _ _ _.

Definition ext_spec := external_specification mem external_function.

Lemma extfunct_eqdec (ef1 ef2 : external_function) : {ef1=ef2} + {~ef1=ef2}.

Set Implicit Arguments.

Definition ef_ext_spec (M Z : Type) :=
  external_specification M AST.external_function Z.

Definition spec_of
  (M Z : Type) (ef : AST.external_function) (spec : ef_ext_spec M Z) :=
  (ext_spec_pre spec ef, ext_spec_post spec ef).

Definition oval_inject j (v tv : option val) :=
  match v, tv with
    | None, None => True
    | Some v', Some tv' => Val.inject j v' tv'
    | _, _ => False
  end.

Module ExtSpecProperties.

Definition det (M E Z : Type) (spec : external_specification M E Z) :=
  forall ef (x x' : ext_spec_type spec ef) ge tys z vals m
         oty' ov' z' m' oty'' ov'' z'' m'',
  ext_spec_pre spec ef x ge tys vals z m ->
  ext_spec_post spec ef x ge oty' ov' z' m' ->
  ext_spec_pre spec ef x' ge tys vals z m ->
  ext_spec_post spec ef x' ge oty'' ov'' z'' m'' ->
  oty'=oty'' /\ ov'=ov'' /\ z'=z'' /\ m'=m''.

Record closed (Z : Type) (spec : ext_spec Z) :=
  { P_closed :
      forall ef (x : ext_spec_type spec ef) ge j tys vals z m tvals tm,
      ext_spec_pre spec ef x ge tys vals z m ->
      Val.inject_list j vals tvals ->
      Mem.inject j m tm ->
      ext_spec_pre spec ef x ge tys tvals z tm
  ; Q_closed :
      forall ef (x : ext_spec_type spec ef) ge j oty ov z m otv tm,
      ext_spec_post spec ef x ge oty ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_post spec ef x ge oty otv z tm
  ; exit_closed :
      forall j ov z m otv tm,
      ext_spec_exit spec ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_exit spec otv z tm }.

End ExtSpecProperties. *)

Require Import VST.sepcomp.step_lemmas.
(* VST.sepcomp.step_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.

Require Import compcert.common.AST.
Require Import compcert.common.Values.

Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Definition has_opttyp (v : option val) (t : option typ) :=
  match v, t with
    None, None => True
  | Some v, Some t => Val.has_type v t
  | _, _ => False
  end.

Section safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context {Hrel: nat -> M -> M -> Prop}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).

  Variable ge : G.

  Inductive safeN_ : nat -> Z -> C -> M -> Prop :=
  | safeN_0: forall z c m, safeN_ O z c m
  | safeN_step:
      forall n z c m c' m',
      corestep Hcore c m c' m' ->
      safeN_ n z c' m' ->
      safeN_ (S n) z c m
  | safeN_external:
      forall n z c m e args x,
      at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           after_external Hcore ret c m' = Some c' /\
           safeN_ n' z' c' m') ->
      safeN_ (S n) z c m
  | safeN_halted:
      forall n z c m i,
      halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      safeN_ n z c m.

  Definition corestep_fun  :=
       forall m q m1 q1 m2 q2 ,
       corestep Hcore q m q1 m1 ->
       corestep Hcore q m q2 m2 ->
       (q1, m1) = (q2, m2).

  Lemma safe_corestep_forward:
     corestep_fun ->
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ (S n) z c m -> safeN_ n z c' m'.

  Lemma safe_corestep_backward:
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ n z c' m' -> safeN_ (S n) z c m.

  Lemma safe_downward1 :
    forall n c m z,
      safeN_ (S n) z c m -> safeN_ n z c m.

  Lemma safe_downward :
    forall n n' c m z,
      le n' n ->
      safeN_ n z c m -> safeN_ n' z c m.

  Lemma safe_corestepN_forward:
    corestep_fun ->
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n + S n0) z c m ->
      safeN_ n z c' m'.

  Lemma safe_step'_back2 :
    forall
      {ora st m st' m' n},
      corestep Hcore st m st' m' ->
      safeN_ (n-1) ora st' m' ->
      safeN_ n ora st m.

  Lemma safe_corestepN_backward:
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n - n0) z c' m' ->
      safeN_ n z c m.

  Lemma convergent_controls_safe :
    forall m q1 q2,
      (at_external Hcore q1 m = at_external Hcore q2 m) ->
      (forall ret m q', after_external Hcore ret q1 m = Some q' ->
                      after_external Hcore ret q2 m = Some q') ->
      (halted Hcore q1 = halted Hcore q2) ->
      (forall q' m', corestep Hcore q1 m q' m' ->
                     corestep Hcore q2 m q' m') ->
      (forall n z, safeN_ n z q1 m -> safeN_ n z q2 m).

  Lemma wlog_safeN_gt0 : forall
    n z q m,
    (lt 0 n -> safeN_ n z q m) ->
    safeN_ n z q m.

End safety.

Section dry_safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).
  Definition dry_safeN := @safeN_ G C M Z genv_symb (fun n' m m' => True) Hcore Hspec.
End dry_safety. *)

Require Import VST.veric.juicy_safety.
(* VST.veric.juicy_safety:
Require Import compcert.lib.Maps.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.ageable.

Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.

Definition pures_sub (phi phi' : rmap) :=
  forall adr,
  match resource_at phi adr with
    | PURE k pp => resource_at phi' adr
                 = PURE k (preds_fmap (approx (level phi')) (approx (level phi')) pp)
    | _ => True
  end.

Lemma pures_sub_trans phi1 phi2 phi3 :
  (level phi3 <= level phi2)%nat ->
  pures_sub phi1 phi2 ->
  pures_sub phi2 phi3 ->
  pures_sub phi1 phi3.

Lemma pures_sub_refl phi : pures_sub phi phi.

Definition pures_eq (phi phi' : rmap) :=
  pures_sub phi phi' /\
  (forall adr,
   match resource_at phi' adr with
    | PURE k pp' => exists pp, resource_at phi adr = PURE k pp
    | _ => True
  end).

Lemma pures_eq_refl phi : pures_eq phi phi.

Lemma pures_eq_trans phi1 phi2 phi3 :
  level phi3 <= level phi2 ->
  pures_eq phi1 phi2 ->
  pures_eq phi2 phi3 ->
  pures_eq phi1 phi3. *)

Require Import VST.veric.juicy_extspec.
(* VST.veric.juicy_extspec:
Require Import VST.veric.juicy_base.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.shares.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.juicy_mem. 

Require Import VST.veric.ghost_PCM. 
Require Import VST.veric.own. 

Require Import VST.veric.age_to_resource_at.

Local Open Scope nat_scope.
Local Open Scope pred.

Record juicy_ext_spec (Z: Type) := {
  JE_spec:> external_specification juicy_mem external_function Z;
  JE_pre_hered: forall e t ge_s typs args z, hereditary age (ext_spec_pre JE_spec e t ge_s typs args z);
  JE_post_hered: forall e t ge_s tret rv z, hereditary age (ext_spec_post JE_spec e t ge_s tret rv z);
  JE_exit_hered: forall rv z, hereditary age (ext_spec_exit JE_spec rv z)
}.

Class OracleKind := {
  OK_ty : Type;
  OK_spec: juicy_ext_spec OK_ty
}.

Definition void_spec T : external_specification juicy_mem external_function T :=
    Build_external_specification
      juicy_mem external_function T
      (fun ef => False)
      (fun ef Hef ge tys vl m z => False)
      (fun ef Hef ge ty vl m z => False)
      (fun rv m z => False).

Definition ok_void_spec (T : Type) : OracleKind.

Definition j_initial_core {C} (csem: @CoreSemantics C mem)
     (n: nat) (m: juicy_mem) (q: C) (m': juicy_mem) (v: val) (args: list val) 
     : Prop :=
  m' = m /\
  semantics.initial_core csem n (m_dry m) q (m_dry m') v args.

Definition j_at_external {C} (csem: @CoreSemantics C mem)
   (q: C) (jm: juicy_mem) : option (external_function * list val) :=
   semantics.at_external csem q (m_dry jm).

Definition j_after_external {C} (csem: @CoreSemantics C mem)
    (ret: option val) (q: C) (jm: juicy_mem) :=
   semantics.after_external csem ret q (m_dry jm).

Definition jstep {C} (csem: @CoreSemantics C mem)
  (q: C) (jm: juicy_mem) (q': C) (jm': juicy_mem) : Prop :=
 corestep csem q (m_dry jm) q' (m_dry jm') /\ 
 resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm') /\
 level jm = S (level jm') /\
 ghost_of (m_phi jm') = ghost_approx jm' (ghost_of (m_phi jm)).

Definition j_halted {C} (csem: @CoreSemantics C mem)
       (c: C) (i: int): Prop :=
     halted csem c i.

Lemma jstep_not_at_external {C} (csem: @CoreSemantics C mem):
  forall m q m' q', jstep csem q m q' m' -> at_external csem q (m_dry m) = None.

Lemma jstep_not_halted  {C} (csem: @CoreSemantics C mem):
  forall m q m' q' i, jstep csem q m q' m' -> ~j_halted csem q i.

Definition juicy_core_sem
  {C} (csem: @CoreSemantics C mem) :
   @CoreSemantics C juicy_mem :=
  @Build_CoreSemantics _ juicy_mem
    (j_initial_core csem)
    (j_at_external csem)
    (j_after_external csem)
    (j_halted csem)
    (jstep csem)
    (jstep_not_halted csem)
    (jstep_not_at_external csem)
.

Section upd_exit.
  Context {Z : Type}.
  Variable spec : juicy_ext_spec Z.

  Definition upd_exit' (Q_exit : option val -> Z -> juicy_mem -> Prop) :=
  {| ext_spec_type := ext_spec_type spec
   ; ext_spec_pre := ext_spec_pre spec
   ; ext_spec_post := ext_spec_post spec
   ; ext_spec_exit := Q_exit |}.

  Definition upd_exit'' (ef : external_function) (x : ext_spec_type spec ef) ge :=
    upd_exit' (ext_spec_post spec ef x ge (sig_res (ef_sig ef))).

  Program Definition upd_exit {ef : external_function} (x : ext_spec_type spec ef) ge :=
    Build_juicy_ext_spec _ (upd_exit'' _ x ge) _ _ _.
End upd_exit.

Obligation Tactic := Tactics.program_simpl.

Program Definition juicy_mem_op (P : pred rmap) : pred juicy_mem :=
  fun jm => P (m_phi jm).

Lemma age_resource_decay:
   forall b jm1 jm2 jm1' jm2',
        resource_decay b jm1 jm2 ->
        age jm1 jm1' -> age jm2 jm2' ->
        level jm1 = S (level jm2) ->
        resource_decay b jm1' jm2'.

Lemma necR_PURE' phi0 phi k p adr :
  necR phi0 phi ->
  phi @ adr = PURE k p ->
  
  exists pp, phi0 @ adr = PURE k pp.

Definition jm_update m m' := m_dry m' = m_dry m /\ level m' = level m /\
  resource_at (m_phi m') = resource_at (m_phi m).

Lemma jm_update_age: forall m1 m2 m1', jm_update m1 m2 -> age m1 m1' ->
  exists m2', jm_update m1' m2' /\ age m2 m2'.

Definition has_ext {Z} (ora : Z) : pred rmap := @own (ext_PCM _) 0 (Some (Tsh, Some ora), None) NoneP.

Definition jm_bupd {Z} (ora : Z) P m := forall C : ghost,
  
  join_sub (Some (ext_ref ora, NoneP) :: nil) C ->
  joins (ghost_of (m_phi m)) (ghost_approx m C) ->
  exists m' : juicy_mem, joins (ghost_of (m_phi m')) ((ghost_approx m) C) /\
    jm_update m m' /\ P m'.

Lemma jm_bupd_intro: forall {Z} (ora : Z) (P : juicy_mem -> Prop) m, P m -> jm_bupd ora P m.

Section juicy_safety.
  Context {G C Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C mem).
  Variable (Hspec : juicy_ext_spec Z).
  Variable ge : G.

  Definition Hrel n' m m' :=
    n' = level m' /\
    (level m' < level m)%nat /\
    pures_eq (m_phi m) (m_phi m').

  Inductive jsafeN_:
    nat -> Z -> C -> juicy_mem -> Prop :=
  | jsafeN_0: forall z c m, jsafeN_ O z c m
  | jsafeN_step:
      forall n z c m c' m',
      jstep Hcore c m c' m' ->
      jm_bupd z (jsafeN_ n z c') m' ->
      jsafeN_ (S n) z c m
  | jsafeN_external:
      forall n z c m e args x,
      j_at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           semantics.after_external Hcore ret c (m_dry m') = Some c' /\
           jm_bupd z' (jsafeN_ n' z' c') m') ->
      jsafeN_ (S n) z c m
  | jsafeN_halted:
      forall n z c m i,
      semantics.halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      jsafeN_ n z c m.

  Lemma jsafe_corestep_backward:
    forall c m c' m' n z,
    jstep Hcore c m c' m' ->
    jsafeN_ n z c' m' -> jsafeN_ (S n) z c m.

  Lemma jsafe_downward1 :
    forall n c m z,
      jsafeN_ (S n) z c m -> jsafeN_ n z c m.

  Lemma jsafe_downward :
    forall n n' c m z,
      le n' n ->
      jsafeN_ n z c m -> jsafeN_ n' z c m.

  Lemma jsafe_step'_back2 :
    forall
      {ora st m st' m' n},
      jstep Hcore st m st' m' ->
      jsafeN_ (n-1) ora st' m' ->
      jsafeN_ n ora st m.

  Lemma jsafe_corestepN_backward:
    forall z c m c' m' n n0,
      semantics_lemmas.corestepN (juicy_core_sem Hcore) n0 c m c' m' ->

  Lemma convergent_controls_jsafe :
    forall m q1 q2,
      (j_at_external Hcore q1 m = j_at_external Hcore q2 m) ->
      (forall ret m q', semantics.after_external Hcore ret q1 m = Some q' ->

  Lemma wlog_jsafeN_gt0 : forall
    n z q m,
    (lt 0 n -> jsafeN_ n z q m) ->
    jsafeN_ n z q m.

Lemma make_join_ext : forall (ora : Z) a c n,
  join_sub (Some (ext_ref ora, NoneP) :: nil) c ->
  joins (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) c) ->
  join_sub (Some (ext_ref ora, NoneP) :: nil) (make_join a c).

Lemma age_safe:
  forall jm jm0, age jm0 jm ->
  forall ora c,
   jsafeN_ (level jm0) ora c jm0 ->
   jsafeN_ (level jm) ora c jm.

End juicy_safety.

Lemma juicy_core_sem_preserves_corestep_fun
  {C} (csem: @CoreSemantics C mem) :
  corestep_fun csem ->
  corestep_fun (juicy_core_sem csem). *)

Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)

Require Import VST.veric.expr.
(* VST.veric.expr:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_lemmas.
Require Export VST.veric.lift.
Require Export VST.veric.Clight_Cop2.
Require Export VST.veric.val_lemmas.

Definition eval_unop (op: Cop.unary_operation) (t1 : type) :=
       force_val1 (Clight_Cop2.sem_unary_operation op t1).

Definition op_to_cmp cop :=
match cop with
| Cop.Oeq => Ceq | Cop.One =>  Cne
| Cop.Olt => Clt | Cop.Ogt =>  Cgt
| Cop.Ole => Cle | Cop.Oge =>  Cge
| _ => Ceq 
end.

Definition is_comparison op :=
match op with
  | Cop.Oeq | Cop.One | Cop.Olt | Cop.Ogt | Cop.Ole | Cop.Oge => true
  | _ => false
end.

Definition eval_binop {CS:compspecs} (op: Cop.binary_operation) (t1 t2 : type) :=
       force_val2 (Clight_Cop2.sem_binary_operation'  op t1 t2).
Arguments eval_binop CS op t1 t2 / v1 v2.

Definition eval_cast (t1 t2 : type) :=
  force_val1 (sem_cast t1 t2).
Arguments eval_cast t1 t2 / v.

Definition eval_field {CS: compspecs} (ty: type) (fld: ident) : val -> val :=
          match ty with
             | Tstruct id att =>
                 match cenv_cs ! id with
                 | Some co =>
                         match field_offset cenv_cs fld (co_members co) with
                         | Errors.OK delta => offset_val delta
                         | _ => always Vundef
                         end
                 | _ => always Vundef
                 end
             | Tunion id att =>
                 match cenv_cs ! id with
                 | Some co => force_ptr
                 | _ => always Vundef
                 end
             | _ => always Vundef
          end.

Definition eval_var (id:ident) (ty: type) (rho: environ) : val :=
                         match Map.get (ve_of rho) id with
                         | Some (b,ty') => if eqb_type ty ty'
                                                    then Vptr b Ptrofs.zero
                                                    else Vundef
                         | None =>
                            match Map.get (ge_of rho) id with
                            | Some b => Vptr b Ptrofs.zero
                            | None => Vundef
                            end
                        end.

Definition deref_noload (ty: type) : val -> val :=
 match access_mode ty with
 | By_reference => Datatypes.id
 | _ => always Vundef
 end.

Fixpoint eval_expr {CS: compspecs} (e: expr) : environ -> val :=
 match e with
 | Econst_int i ty => `(Vint i)
 | Econst_long i ty => `(Vlong i)
 | Econst_float f ty => `(Vfloat f)
 | Econst_single f ty => `(Vsingle f)
 | Etempvar id ty => eval_id id
 | Eaddrof a ty => eval_lvalue a
 | Eunop op a ty =>  `(eval_unop op (typeof a)) (eval_expr a)
 | Ebinop op a1 a2 ty =>
                  `(eval_binop op (typeof a1) (typeof a2)) (eval_expr a1) (eval_expr a2)
 | Ecast a ty => `(eval_cast (typeof a) ty) (eval_expr a)
 | Evar id ty => eval_var id ty 
 | Ederef a ty => eval_expr a 
 | Efield a i ty => `(eval_field (typeof a) i) (eval_lvalue a) 
 | Esizeof t ty => `(Vptrofs (Ptrofs.repr (sizeof t)))
 | Ealignof t ty => `(Vptrofs (Ptrofs.repr (alignof t)))
 end

 with eval_lvalue {CS: compspecs} (e: expr) : environ -> val :=
 match e with
 | Evar id ty => eval_var id ty
 | Ederef a ty => eval_expr a 
 | Efield a i ty => `(eval_field (typeof a) i) (eval_lvalue a)
 | _  => `Vundef
 end.

Fixpoint eval_exprlist {CS: compspecs} (et: list type) (el:list expr) : environ -> list val :=
 match et, el with
 | t::et', e::el' =>
    `(@cons val) (`force_val (`(sem_cast (typeof e) t) (eval_expr e))) (eval_exprlist et' el')
 | _, _ => `nil
 end.

Definition eval_expropt {CS: compspecs} (e: option expr) : environ -> option val :=
 match e with Some e' => `(@Some val) (eval_expr e')  | None => `None end.

Definition bool_type (t: type) : bool :=
  match t with
  | Tpointer _ _ => negb (eqb_type t int_or_ptr_type)
  | Tint _ _ _ | Tlong _ _ | Tarray _ _ _ | Tfunction _ _ _ | Tfloat _ _ =>  true
  | _ => false
  end.

Definition is_scalar_type (ty:type) : bool :=
match ty with
| Tint _ _ _ => true
| Tfloat _ _ => true
| _ => false
end.

Definition is_int_type ty :=
match ty with
| Tint _ _ _ => true
| _ => false
end.

Definition is_int32_type ty :=
match ty with
| Tint I32 _ _ => true
| _ => false
end.

Definition is_long_type ty :=
match ty with
| Tlong _ _ => true
| _ => false
end.

Definition is_ptrofs_type :=
 if Archi.ptr64 then is_long_type else is_int32_type.

Definition is_float_type ty :=
match ty with
| Tfloat F64 _ => true
| _ => false
end.

Definition is_single_type ty :=
match ty with
| Tfloat F32 _ => true
| _ => false
end.

Definition is_anyfloat_type ty :=
match ty with
| Tfloat F64 _ => true
| Tfloat F32 _ => true
| _ => false
end.

Definition is_pointer_type ty :=
match ty with
| (Tpointer _ _ 
   | Tarray _ _ _ | Tfunction _ _ _
   | Tstruct _ _  | Tunion _ _) => 
    negb (eqb_type ty int_or_ptr_type)
| _ => false
end.

Inductive tc_error :=
| op_result_type : expr -> tc_error
| arg_type : expr -> tc_error
| pp_compare_size_0 : type -> tc_error
| pp_compare_size_exceed : type -> tc_error
| invalid_cast : type -> type -> tc_error
| invalid_cast_result : type -> type -> tc_error
| invalid_expression : expr -> tc_error
| var_not_in_tycontext : tycontext -> positive  -> tc_error
| mismatch_context_type : type -> type -> tc_error
| deref_byvalue : type -> tc_error
| volatile_load : type -> tc_error
| invalid_field_access : expr -> tc_error
| invalid_composite_name: ident -> tc_error
| invalid_struct_field : ident  -> ident  -> tc_error
| invalid_lvalue : expr -> tc_error
| wrong_signature : tc_error
| int_or_ptr_type_error : tc_error
| miscellaneous_typecheck_error : tc_error.

Inductive tc_assert :=
| tc_FF: tc_error -> tc_assert
| tc_TT : tc_assert
| tc_andp': tc_assert -> tc_assert -> tc_assert
| tc_orp' : tc_assert -> tc_assert -> tc_assert
| tc_nonzero': expr -> tc_assert
| tc_iszero': expr -> tc_assert
| tc_isptr: expr -> tc_assert
| tc_isint: expr -> tc_assert
| tc_islong: expr -> tc_assert
| tc_test_eq': expr -> expr -> tc_assert
| tc_test_order': expr -> expr -> tc_assert
| tc_ilt': expr -> int -> tc_assert
| tc_llt': expr -> int64 -> tc_assert
| tc_Zle: expr -> Z -> tc_assert
| tc_Zge: expr -> Z -> tc_assert
| tc_samebase: expr -> expr -> tc_assert
| tc_nodivover': expr -> expr -> tc_assert
| tc_initialized: PTree.elt -> type -> tc_assert
| tc_nosignedover: (Z->Z->Z) -> expr -> expr -> tc_assert.

Definition tc_noproof := tc_FF miscellaneous_typecheck_error.

Definition tc_iszero {CS: compspecs} (e: expr) : tc_assert :=
  match eval_expr e any_environ with
  | Vint i => if Int.eq i Int.zero then tc_TT else tc_FF (pp_compare_size_0 Tvoid)
  | Vlong i => if Int64.eq i Int64.zero then tc_TT else tc_FF (pp_compare_size_0 Tvoid)
  | _ => tc_iszero' e
  end.

Definition tc_nonzero {CS: compspecs} (e: expr) : tc_assert :=
  match eval_expr e any_environ with
   | Vint i => if negb (Int.eq i Int.zero) then tc_TT else tc_nonzero' e
   | Vlong i => if negb (Int64.eq i Int64.zero) then tc_TT else tc_nonzero' e
   | _ => tc_nonzero' e
   end.

Definition tc_test_eq {CS: compspecs} (e1 e2: expr) : tc_assert :=
 match eval_expr e1 any_environ, eval_expr e2 any_environ with
 | Vint i, Vint j => if andb (negb Archi.ptr64)
                             (andb (Int.eq i Int.zero) (Int.eq j Int.zero))
                             then tc_TT else tc_test_eq' e1 e2
 | Vlong i, Vlong j => if andb Archi.ptr64
                             (andb (Int64.eq i Int64.zero) (Int64.eq j Int64.zero))
                             then tc_TT else tc_test_eq' e1 e2
 | _, _ => tc_test_eq' e1 e2
 end.

Definition tc_test_order {CS: compspecs} (e1 e2: expr) : tc_assert :=
 match eval_expr e1 any_environ, eval_expr e2 any_environ with
 | Vint i, Vint j => if  andb (negb Archi.ptr64)
                                  (andb (Int.eq i Int.zero) (Int.eq j Int.zero))
                             then tc_TT else tc_test_order' e1 e2
 | Vlong i, Vlong j => if  andb Archi.ptr64
                                  (andb (Int64.eq i Int64.zero) (Int64.eq j Int64.zero))
                             then tc_TT else tc_test_order' e1 e2
 | _, _ => tc_test_order' e1 e2
 end.

Definition tc_nodivover {CS: compspecs} (e1 e2: expr) : tc_assert :=
 match eval_expr e1 any_environ, eval_expr e2 any_environ with
                           | Vint n1, Vint n2 => if (negb
                                   (Int.eq n1 (Int.repr Int.min_signed)
                                    && Int.eq n2 Int.mone))
                                     then tc_TT else tc_nodivover' e1 e2
                           | Vlong n1, Vlong n2 => if (negb
                                   (Int64.eq n1 (Int64.repr Int64.min_signed)
                                    && Int64.eq n2 Int64.mone))
                                     then tc_TT else tc_nodivover' e1 e2
                           | Vint n1, Vlong n2 => tc_TT
                           | Vlong n1, Vint n2 => if (negb
                                   (Int64.eq n1 (Int64.repr Int64.min_signed)
                                    && Int.eq n2 Int.mone))
                                     then tc_TT else tc_nodivover' e1 e2
                           | _ , _ => tc_nodivover' e1 e2
                          end.

Definition if_expr_signed (e: expr) (tc: tc_assert) : tc_assert :=
 match typeof e with
 | Tint _ Signed _ => tc
 | Tlong Signed _ => tc
 | _ => tc_TT
 end.

Definition tc_nobinover (op: Z->Z->Z) {CS: compspecs} (e1 e2: expr) : tc_assert :=
 if_expr_signed e1
 match eval_expr e1 any_environ, eval_expr e2 any_environ with
 | Vint n1, Vint n2 => 
    if range_s32 (op (Int.signed n1) (Int.signed n2))
     then tc_TT else tc_nosignedover op e1 e2
 | Vlong n1, Vlong n2 => 
    if range_s64 (op (Int64.signed n1) (Int64.signed n2))
     then tc_TT else tc_nosignedover op e1 e2
 | Vint n1, Vlong n2 =>
    if range_s64 (op (Int.signed n1) (Int64.signed n2))
     then tc_TT else tc_nosignedover op e1 e2
 | Vlong n1, Vint n2 =>
    if range_s64 (op (Int64.signed n1) (Int.signed n2))
     then tc_TT else tc_nosignedover op e1 e2
 | _ , _ => tc_nosignedover op e1 e2
 end.

Definition tc_andp (a1: tc_assert) (a2 : tc_assert) : tc_assert :=
match a1 with
| tc_TT => a2
| tc_FF e => tc_FF e
| _ => match a2 with
      | tc_TT => a1
      | tc_FF e => tc_FF e
      | _ => tc_andp' a1 a2
      end
end.

Definition tc_orp (a1: tc_assert) (a2 : tc_assert) : tc_assert :=
match a1 with
| tc_TT => tc_TT
| tc_FF _ => a2
| _ => match a2 with
       | tc_TT => tc_TT
       | tc_FF _ => a1
       | _ => tc_orp' a1 a2
       end
end.

Definition tc_bool (b : bool) (e: tc_error) :=
if b then tc_TT else tc_FF e.

Definition check_pp_int {CS: compspecs} e1 e2 op t e :=
  match op with
  | Cop.Oeq | Cop.One =>
      tc_andp
        (tc_test_eq e1 e2)
        (tc_bool (is_int_type t) (op_result_type e))
  | Cop.Ole | Cop.Olt | Cop.Oge | Cop.Ogt =>
      tc_andp
        (tc_test_order e1 e2)
        (tc_bool (is_int_type t) (op_result_type e))
  | _ => tc_noproof
  end.

Definition binarithType t1 t2 ty deferr reterr : tc_assert :=
  match Cop.classify_binarith t1 t2 with
  | Cop.bin_case_i sg =>  tc_bool (is_int32_type ty) reterr
  | Cop.bin_case_l sg => tc_bool (is_long_type ty) reterr
  | Cop.bin_case_f   => tc_bool (is_float_type ty) reterr
  | Cop.bin_case_s   => tc_bool (is_single_type ty) reterr
  | Cop.bin_default => tc_FF deferr
  end.

Definition is_numeric_type t :=
match t with Tint _ _ _ | Tlong _ _ | Tfloat _ _ => true | _ => false end.

Definition tc_ilt {CS: compspecs} (e: expr) (j: int) :=
    match eval_expr e any_environ with
    | Vint i => if Int.ltu i j then tc_TT else tc_ilt' e j
    | _ => tc_ilt' e j
    end.

Definition tc_llt {CS: compspecs} (e: expr) (j: int64) :=
    match eval_expr e any_environ with
    | Vlong i => if Int64.ltu i j then tc_TT else tc_llt' e j
    | _ => tc_llt' e j
    end.

Definition tc_int_or_ptr_type (t: type) : tc_assert :=
 tc_bool (negb (eqb_type t int_or_ptr_type)) int_or_ptr_type_error.

Definition isUnOpResultType {CS: compspecs} op a ty : tc_assert :=
match op with
  | Cop.Onotbool => match typeof a with
                        | Tint _ _ _ | Tlong _ _ | Tfloat _ _ =>
                                        tc_bool (is_int_type ty) (op_result_type a)
                        | Tpointer _ _ => 
                             tc_andp (tc_int_or_ptr_type (typeof a))
                             (tc_andp (tc_bool (is_int_type ty) (op_result_type a))
                              (tc_test_eq a 
                                (if Archi.ptr64 
                                 then Econst_long Int64.zero (Tlong Signed noattr)
                                 else Econst_int Int.zero (Tint I32 Signed noattr))))
                        | _ => tc_FF (op_result_type a)
                        end
  | Cop.Onotint => match Cop.classify_notint (typeof a) with
                        | Cop.notint_default => tc_FF (op_result_type a)
                        | Cop.notint_case_i _ => tc_bool (is_int32_type ty) (op_result_type a)
                        | Cop.notint_case_l _ => tc_bool (is_long_type ty) (op_result_type a)
                        end
  | Cop.Oneg => match Cop.classify_neg (typeof a) with
                    | Cop.neg_case_i sg => 
                          tc_andp (tc_bool (is_int32_type ty) (op_result_type a))
                          match (typeof a) with
                          | Tint _ Signed _ => tc_nosignedover Z.sub (Econst_int Int.zero (typeof a)) a
                          | Tlong Signed _ => tc_nosignedover Z.sub (Econst_long Int64.zero (typeof a)) a
                          | _ => tc_TT
                          end
                    | Cop.neg_case_f => tc_bool (is_float_type ty) (op_result_type a)
                    | Cop.neg_case_s => tc_bool (is_single_type ty) (op_result_type a)
                    | _ => tc_FF (op_result_type a)
                    end
  | Cop.Oabsfloat =>match Cop.classify_neg (typeof a) with
                    | Cop.neg_case_i sg => tc_bool (is_float_type ty) (op_result_type a)
                    | Cop.neg_case_l _ => tc_bool (is_float_type ty) (op_result_type a)
                    | Cop.neg_case_f => tc_bool (is_float_type ty) (op_result_type a)
                    | Cop.neg_case_s => tc_bool (is_float_type ty) (op_result_type a)
                    | _ => tc_FF (op_result_type a)
                    end
end.

Definition isBinOpResultType {CS: compspecs} op a1 a2 ty : tc_assert :=
let e := (Ebinop op a1 a2 ty) in
let reterr := op_result_type e in
let deferr := arg_type e in
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t si => tc_andp (tc_andp (tc_andp (tc_isptr a1)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a1)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.add_case_ip si t => tc_andp (tc_andp (tc_andp (tc_isptr a2)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a2)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.add_case_pl t => tc_andp (tc_andp (tc_andp (tc_isptr a1)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a1)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.add_case_lp t => tc_andp (tc_andp (tc_andp (tc_isptr a2)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a2)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.add_default => tc_andp 
                                           (binarithType (typeof a1) (typeof a2) ty deferr reterr)
                                           (tc_nobinover Z.add a1 a2)
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t si => tc_andp (tc_andp (tc_andp (tc_isptr a1)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a1)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.sub_case_pl t => tc_andp (tc_andp (tc_andp (tc_isptr a1)
                                           (tc_bool (complete_type cenv_cs t) reterr))
                                            (tc_int_or_ptr_type (typeof a1)))
                                            (tc_bool (is_pointer_type ty) reterr)
                    | Cop.sub_case_pp t =>
                             tc_andp (tc_andp (tc_andp (tc_andp (tc_andp (tc_andp (tc_andp 
                               (tc_andp (tc_samebase a1 a2)
                             (tc_isptr a1))
                              (tc_isptr a2))
                               (tc_int_or_ptr_type (typeof a1)))
                               (tc_int_or_ptr_type (typeof a2)))
                               (tc_bool (is_ptrofs_type ty) reterr))
			        (tc_bool (negb (Z.eqb (sizeof t) 0))
                                      (pp_compare_size_0 t)))
                                 (tc_bool (complete_type cenv_cs t) reterr))
                                   (tc_bool (Z.leb (sizeof t) Ptrofs.max_signed)
                                          (pp_compare_size_exceed t))
                    | Cop.sub_default => tc_andp 
                                    (binarithType (typeof a1) (typeof a2) ty deferr reterr)
                                    (tc_nobinover Z.sub a1 a2)
            end
  | Cop.Omul => tc_andp (binarithType (typeof a1) (typeof a2) ty deferr reterr)
                                    (tc_nobinover Z.mul a1 a2)
  | Cop.Omod => match Cop.classify_binarith (typeof a1) (typeof a2) with
                    | Cop.bin_case_i Unsigned =>
                           tc_andp (tc_nonzero a2)
                           (tc_bool (is_int32_type ty) reterr)
                    | Cop.bin_case_l Unsigned =>
                           tc_andp (tc_nonzero a2)
                           (tc_bool (is_long_type ty) reterr)
                    | Cop.bin_case_i Signed => tc_andp (tc_andp (tc_nonzero a2)
                                                      (tc_nodivover a1 a2))
                                                     (tc_bool (is_int32_type ty) reterr)
                    | Cop.bin_case_l Signed => tc_andp (tc_andp (tc_nonzero a2)
                                                      (tc_nodivover a1 a2))
                                                     (tc_bool (is_long_type ty) reterr)
                    | _ => tc_FF deferr
            end
  | Cop.Odiv => match Cop.classify_binarith (typeof a1) (typeof a2) with
                    | Cop.bin_case_i Unsigned => tc_andp (tc_nonzero a2) (tc_bool (is_int32_type ty) reterr)
                    | Cop.bin_case_l Unsigned => tc_andp (tc_nonzero a2) (tc_bool (is_long_type ty) reterr)
                    | Cop.bin_case_i Signed => tc_andp (tc_andp (tc_nonzero a2) (tc_nodivover a1 a2))
                                                        (tc_bool (is_int32_type ty) reterr)
                    | Cop.bin_case_l Signed => tc_andp (tc_andp (tc_nonzero a2) (tc_nodivover a1 a2))
                                                        (tc_bool (is_long_type ty) reterr)
                    | Cop.bin_case_f  =>  tc_bool (is_float_type ty) reterr
                    | Cop.bin_case_s  =>  tc_bool (is_single_type ty) reterr
                    | Cop.bin_default => tc_FF deferr
            end
  | Cop.Oshl | Cop.Oshr => match Cop.classify_shift (typeof a1) (typeof a2) with
                    | Cop.shift_case_ii _ =>  tc_andp (tc_ilt a2 Int.iwordsize) (tc_bool (is_int32_type ty)
                                                                                         reterr)
                    | Cop.shift_case_il _ =>  tc_andp (tc_llt a2 (Int64.repr 32)) (tc_bool (is_int32_type ty)
                                                                                         reterr)
                    | Cop.shift_case_li _ =>  tc_andp (tc_ilt a2 Int64.iwordsize') (tc_bool (is_long_type ty)
                                                                                         reterr)
                    | Cop.shift_case_ll _ =>  tc_andp (tc_llt a2 Int64.iwordsize) (tc_bool (is_long_type ty)
                                                                                         reterr)
                    | Cop.shift_default => tc_FF deferr
                   end
  | Cop.Oand | Cop.Oor | Cop.Oxor =>
                   match Cop.classify_binarith (typeof a1) (typeof a2) with
                    | Cop.bin_case_i _ =>tc_bool (is_int32_type ty) reterr
                    | Cop.bin_case_l _ =>tc_bool (is_long_type ty) reterr
                    | Cop.bin_case_f => tc_FF deferr
                    | Cop.bin_case_s => tc_FF deferr
                    | Cop.bin_default => tc_FF deferr
                   end
  | Cop.Oeq | Cop.One | Cop.Olt | Cop.Ogt | Cop.Ole | Cop.Oge =>
         match Cop.classify_cmp (typeof a1) (typeof a2) with
              | Cop.cmp_default =>
                           tc_bool (is_numeric_type (typeof a1)
                                         && is_numeric_type (typeof a2)
                                          && is_int_type ty)
                                             deferr
	            | Cop.cmp_case_pp => 
                     tc_andp (tc_andp (tc_int_or_ptr_type (typeof a1)) 
                                      (tc_int_or_ptr_type (typeof a2)))
                       (check_pp_int a1 a2 op ty e)
              | Cop.cmp_case_pi si =>
                     tc_andp (tc_int_or_ptr_type (typeof a1))
                       (check_pp_int a1 (Ecast a2 size_t) op ty e)
              | Cop.cmp_case_ip si => 
                     tc_andp (tc_int_or_ptr_type (typeof a2))
                    (check_pp_int (Ecast a1 size_t) a2 op ty e)
              | Cop.cmp_case_pl => 
                     tc_andp (tc_int_or_ptr_type (typeof a1))
                       (check_pp_int a1 (Ecast a2 size_t) op ty e)
              | Cop.cmp_case_lp => 
                     tc_andp (tc_int_or_ptr_type (typeof a2))
                    (check_pp_int (Ecast a1 size_t) a2 op ty e)
              end
  end.

Definition isCastResultType {CS: compspecs} tfrom tto a : tc_assert :=
  
match classify_cast tfrom tto with
| Cop.cast_case_default => tc_FF (invalid_cast tfrom tto)
| Cop.cast_case_f2i _ Signed => tc_andp (tc_Zge a Int.min_signed ) (tc_Zle a Int.max_signed)
| Cop.cast_case_s2i _ Signed => tc_andp (tc_Zge a Int.min_signed ) (tc_Zle a Int.max_signed)
| Cop.cast_case_f2i _ Unsigned => tc_andp (tc_Zge a 0) (tc_Zle a Int.max_unsigned)
| Cop.cast_case_s2i _ Unsigned => tc_andp (tc_Zge a 0) (tc_Zle a Int.max_unsigned)
| Cop.cast_case_i2l _ => 
           tc_andp (tc_bool (is_int_type tfrom) (invalid_cast_result tfrom tto))
             (if is_pointer_type tto then tc_iszero a else tc_TT)
| Cop.cast_case_l2i _ _ => 
           tc_andp (tc_bool (is_long_type tfrom) (invalid_cast_result tfrom tto))
             (if is_pointer_type tto then tc_iszero a else tc_TT)
| Cop.cast_case_pointer  => 
           if eqb_type tfrom tto then tc_TT else
           if orb  (andb (is_pointer_type tto) (is_pointer_type tfrom))
                       (if Archi.ptr64
                        then (andb (is_long_type tto) (is_long_type tfrom)) 
                        else (andb (is_int_type tto) (is_int_type tfrom)))
           then tc_TT else 
           if (andb (eqb_type tto int_or_ptr_type) ((if Archi.ptr64 then is_long_type else is_int_type) tfrom))
           then tc_TT else
           if (andb (eqb_type tto int_or_ptr_type) (is_pointer_type tfrom))
           then tc_TT else
           if (andb (eqb_type tfrom int_or_ptr_type) (is_pointer_type tto))
           then tc_isptr a else
           if (andb (eqb_type tfrom int_or_ptr_type) ((if Archi.ptr64 then is_long_type else is_int_type) tto))
           then (if Archi.ptr64 then tc_islong else tc_isint) a
           else tc_iszero a
| Cop.cast_case_l2l => tc_bool (is_long_type tfrom && is_long_type tto) (invalid_cast_result tto tto)
| Cop.cast_case_void => tc_noproof
| Cop.cast_case_f2bool => tc_bool (is_float_type tfrom) (invalid_cast_result tfrom tto)
| Cop.cast_case_s2bool => tc_bool (is_single_type tfrom) (invalid_cast_result tfrom tto)

| Cop.cast_case_l2bool => 
      if is_pointer_type tfrom
      then tc_test_eq a (Econst_long Int64.zero (Tlong Unsigned noattr))
      else tc_TT
| Cop.cast_case_i2bool =>
      if is_pointer_type tfrom
      then tc_test_eq a (Econst_int Int.zero (Tint I32 Unsigned noattr))
      else tc_TT
| _ => match tto with
      | Tint _ _ _  => tc_bool (is_int_type tfrom) (invalid_cast_result tto tto)
      | Tfloat F64 _  => tc_bool (is_anyfloat_type tfrom) (invalid_cast_result tto tto)
      | Tfloat F32 _  => tc_bool (is_anyfloat_type tfrom) (invalid_cast_result tto tto)
      | _ => tc_FF (invalid_cast tfrom tto)
      end
end.

Definition is_neutral_cast t1 t2 :=
 match t1, t2 with
 | Tint IBool _ _, Tint _ _ _ => true
 | Tint I8 Signed _, Tint I8 Signed _ => true
 | Tint I8 Signed _, Tint I16 Signed _ => true
 | Tint I16 Signed _, Tint I16 Signed _ => true
 | Tint I8 Unsigned _, Tint I8 Unsigned _ => true
 | Tint I8 Unsigned _, Tint I16 Unsigned _ => true
 | Tint I16 Unsigned _, Tint I16 Unsigned _ => true
 | Tint _ _ _, Tint I32 _ _ => true
 | Tlong _ _, Tlong _ _ => true
 | Tfloat F64 _, Tfloat F64 _ => true
 | Tfloat F32 _, Tfloat F32 _ => true
 | Tpointer _ _, Tpointer _ _ => eqb_type t1 t2 
                    || negb (eqb_type t1 int_or_ptr_type) 
                     && negb (eqb_type t2 int_or_ptr_type)
 | _, _ => false
 end.

Definition get_var_type (Delta : tycontext) id : option type :=
match (var_types Delta) ! id with
| Some ty => Some ty
| None => match (glob_types Delta) ! id with
         | Some g => Some g
         | None => None
           end
end.

Definition same_base_type t1 t2 : bool :=
match t1, t2 with
| (Tarray _ _ _ | Tfunction _ _ _),
   (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>
     Bool.eqb (eqb_type t1 int_or_ptr_type)
              (eqb_type t2 int_or_ptr_type)
| (Tstruct _ _ | Tunion _ _), (Tstruct _ _ | Tunion _ _ ) => true
| _, _ => false
end.

Fixpoint typecheck_expr {CS: compspecs} (Delta : tycontext) (e: expr) : tc_assert :=
let tcr := typecheck_expr Delta in
match e with
 | Econst_int _ (Tint I32 _ _) => tc_TT
 | Econst_float _ (Tfloat F64 _) => tc_TT
 | Econst_single _ (Tfloat F32 _) => tc_TT
 | Etempvar id ty =>
                       match (temp_types Delta)!id with
                         | Some ty' => if is_neutral_cast ty' ty || same_base_type ty' ty then
                                         tc_initialized id ty'
                                       else tc_FF (mismatch_context_type ty ty')
		         | None => tc_FF (var_not_in_tycontext Delta id)
                       end
 | Eaddrof a ty => tc_andp (typecheck_lvalue Delta a) (tc_bool (is_pointer_type ty)
                                                      (op_result_type e))
 | Eunop op a ty => tc_andp (isUnOpResultType op a ty) (tcr a)
 | Ebinop op a1 a2 ty => tc_andp (tc_andp (isBinOpResultType op a1 a2 ty)  (tcr a1)) (tcr a2)
 | Ecast a ty => tc_andp (tcr a) (isCastResultType (typeof a) ty a)
 | Evar id ty => match access_mode ty with
                         | By_reference =>
                            match get_var_type Delta id with
                            | Some ty' => tc_bool (eqb_type ty ty')
                                                           (mismatch_context_type ty ty')
                            | None => tc_FF (var_not_in_tycontext Delta id)
                            end
                         | _ => tc_FF (deref_byvalue ty)
                        end
 | Efield a i ty => match access_mode ty with
                         | By_reference =>
                            tc_andp (typecheck_lvalue Delta a) (match typeof a with
                            | Tstruct id att =>
                               match cenv_cs ! id with
                               | Some co =>
                                  match field_offset cenv_cs i (co_members co) with
                                  | Errors.OK delta => tc_TT
                                  | _ => tc_FF (invalid_struct_field i id)
                                  end
                               | _ => tc_FF (invalid_composite_name id)
                               end
                            | Tunion id att =>
                               match cenv_cs ! id with
                               | Some co => tc_TT
                               | _ => tc_FF (invalid_composite_name id)
                               end
                            | _ => tc_FF (invalid_field_access e)
                            end)
                         | _ => tc_FF (deref_byvalue ty)
                        end
 | Ederef a ty => match access_mode ty with
                  | By_reference => tc_andp
                       (tc_andp
                          (typecheck_expr Delta a)
                          (tc_bool (is_pointer_type (typeof a))(op_result_type e)))
                       (tc_isptr a)
                  | _ => tc_FF (deref_byvalue ty)
                  end
 | Esizeof ty t => tc_andp (tc_bool (complete_type cenv_cs ty) (invalid_expression e))
                     (tc_bool (eqb_type t size_t) (invalid_expression e))
 | Ealignof ty t => tc_andp (tc_bool (complete_type cenv_cs ty) (invalid_expression e))
                     (tc_bool (eqb_type t size_t) (invalid_expression e))
 | _ => tc_FF (invalid_expression e)
end

with typecheck_lvalue {CS: compspecs}(Delta: tycontext) (e: expr) : tc_assert :=
match e with
 | Evar id ty => match get_var_type Delta id with
                  | Some ty' => tc_bool (eqb_type ty ty')
                                           (mismatch_context_type ty ty')
                  | None => tc_FF (var_not_in_tycontext Delta id)
                 end
 | Ederef a ty => tc_andp
                       (tc_andp
                          (typecheck_expr Delta a)
                          (tc_bool (is_pointer_type (typeof a))(op_result_type e)))
                       (tc_isptr a)
 | Efield a i ty => tc_andp
                         (typecheck_lvalue Delta a)
                         (match typeof a with
                            | Tstruct id att =>
                              match cenv_cs ! id with
                              | Some co =>
                                   match field_offset cenv_cs i (co_members co) with
                                     | Errors.OK delta => tc_TT
                                     | _ => tc_FF (invalid_struct_field i id)
                                   end
                              | _ => tc_FF (invalid_composite_name id)
                              end
                            | Tunion id att =>
                              match cenv_cs ! id with
                              | Some co => tc_TT
                              | _ => tc_FF (invalid_composite_name id)
                              end
                            | _ => tc_FF (invalid_field_access e)
                          end)
 | _  => tc_FF (invalid_lvalue e)
end.

Definition implicit_deref (t: type) : type :=
  match t with
  | Tarray t' _ _ => Tpointer t' noattr
  | _ => t
  end.

Definition typecheck_temp_id {CS: compspecs}id ty Delta a : tc_assert :=
  match (temp_types Delta)!id with
  | Some t =>
      tc_andp (tc_bool (is_neutral_cast (implicit_deref ty) t) (invalid_cast ty t))
                  (isCastResultType (implicit_deref ty) t a)
  | None => tc_FF (var_not_in_tycontext Delta id)
 end.

Fixpoint tc_might_be_true (asn : tc_assert) :=
match asn with
 | tc_FF _ => false
 | tc_andp' a1 a2 => tc_might_be_true a1 && tc_might_be_true a2
 | _ => true
end.

Fixpoint tc_always_true (asn : tc_assert) :=
match asn with
 | tc_TT => true
 | tc_andp' a1 a2 => tc_always_true a1 && tc_always_true a2
 | _ => false
end.

Definition typecheck_b {CS: compspecs}Delta e :=  tc_might_be_true (typecheck_expr Delta e).

Definition typecheck_pure_b {CS: compspecs}Delta e := tc_always_true (typecheck_expr Delta e).

Fixpoint typecheck_exprlist {CS: compspecs}(Delta : tycontext) (tl : list type) (el : list expr) : tc_assert :=
match tl,el with
| t::tl', e:: el' => tc_andp (typecheck_expr Delta (Ecast e t))
                      (typecheck_exprlist Delta tl' el')
| nil, nil => tc_TT
| _, _ => tc_FF wrong_signature
end.

Definition typecheck_temp_environ
(te: tenviron) (tc: PTree.t type) :=
forall id ty , tc ! id = Some ty  -> exists v, Map.get te id = Some v /\ tc_val' ty v.

Definition typecheck_var_environ
(ve: venviron) (tc: PTree.t type) :=
forall id ty, tc ! id = Some ty <-> exists v, Map.get ve id = Some(v,ty).

Definition typecheck_glob_environ
(ge: genviron) (tc: PTree.t type) :=
forall id  t,  tc ! id = Some t ->
(exists b, Map.get ge id = Some b).

Definition typecheck_environ (Delta: tycontext) (rho : environ) :=
typecheck_temp_environ (te_of rho) (temp_types Delta) /\
typecheck_var_environ  (ve_of rho) (var_types Delta) /\
typecheck_glob_environ (ge_of rho) (glob_types Delta).

Lemma typecheck_var_environ_None: forall ve vt,
  typecheck_var_environ ve vt ->
  forall i,
  vt ! i = None <-> Map.get ve i = None.

Lemma WARNING___________you_should_use_tactic___destruct_var_types___instead:
  forall (ve : venviron) (vt : PTree.t type), typecheck_var_environ ve vt -> forall i : positive,

Lemma WARNING___________you_should_use_tactic___destruct_glob_types___instead:
  forall (ge : genviron) (gt : PTree.t type), typecheck_glob_environ ge gt -> forall i : positive,

Ltac _destruct_var_types i Heq_vt Heq_ve t b :=
  let HH := fresh "H" in
  match goal with
  | H: typecheck_var_environ _ _ |- _ =>
      pose proof WARNING___________you_should_use_tactic___destruct_var_types___instead _ _ H i as HH
  | H: typecheck_environ _ _ |- _ =>
      pose proof WARNING___________you_should_use_tactic___destruct_var_types___instead _ _ (proj1 (proj2 H)) i as HH
  end;
  match type of HH with
  | match ?o with _ => _ end =>
      match goal with
      | H: o = Some _ |- _ =>
          rewrite H in HH
      | H: Some _ = o |- _ =>
          rewrite <- H in HH
      | H: o = None |- _ =>
          rewrite H in HH
      | H: None = o |- _ =>
          rewrite <- H in HH
      | _ =>
          let HH' := fresh "H" in
          pose proof eq_refl o as HH';
          destruct o as [t |] in HH, HH' at 2;
          pose proof HH' as Heq_vt; clear HH'
      end
  end;
  match type of HH with
  | ex _ =>
      pose proof HH as [b Heq_ve]
  | _ =>
      pose proof HH as Heq_ve
  end;
  clear HH.

Tactic Notation "destruct_var_types" constr(i) :=
  let Heq_vt := fresh "Heqo" in
  let Heq_ve := fresh "Heqo" in
  let t := fresh "t" in
  let b := fresh "b" in
  _destruct_var_types i Heq_vt Heq_ve t b.

Tactic Notation "destruct_var_types" constr(i) "as" "[" ident(t) ident(b) "]" :=
  let Heq_vt := fresh "Heqo" in
  let Heq_ve := fresh "Heqo" in
  _destruct_var_types i Heq_vt Heq_ve t b.

Tactic Notation "destruct_var_types" constr(i) "eqn" ":" simple_intropattern(Heq_vt) "&" simple_intropattern(Heq_ve) :=
  let t := fresh "t" in
  let b := fresh "b" in
  _destruct_var_types i Heq_vt Heq_ve t b.

Tactic Notation "destruct_var_types" constr(i) "as" "[" ident(t) ident(b) "]" "eqn" ":" simple_intropattern(Heq_vt) "&" simple_intropattern(Heq_ve) :=
  _destruct_var_types i Heq_vt Heq_ve t b.

Ltac _destruct_glob_types i Heq_gt Heq_ge t b :=
  let HH := fresh "H" in
  match goal with
  | H: typecheck_glob_environ _ _ |- _ =>
      pose proof WARNING___________you_should_use_tactic___destruct_glob_types___instead _ _ H i as HH
  | H: typecheck_environ _ _ |- _ =>
      pose proof WARNING___________you_should_use_tactic___destruct_glob_types___instead _ _ (proj2 (proj2 H)) i as HH
  end;
  match type of HH with
  | match ?o with _ => _ end =>
      match goal with
      | H: o = Some _ |- _ =>
          rewrite H in HH
      | H: Some _ = o |- _ =>
          rewrite <- H in HH
      | H: o = None |- _ =>
          rewrite H in HH
      | H: None = o |- _ =>
          rewrite <- H in HH
      | _ =>
          let HH' := fresh "H" in
          pose proof eq_refl o as HH';
          destruct o as [t |] in HH, HH' at 2;
          pose proof HH' as Heq_gt; clear HH'
      end
  end;
  match type of HH with
  | ex _ =>
      pose proof HH as [b Heq_ge]
  | _ =>
      idtac
  end;
  clear HH.

Tactic Notation "destruct_glob_types" constr(i) :=
  let Heq_gt := fresh "Heqo" in
  let Heq_ge := fresh "Heqo" in
  let t := fresh "t" in
  let b := fresh "b" in
  _destruct_glob_types i Heq_gt Heq_ge t b.

Tactic Notation "destruct_glob_types" constr(i) "as" "[" ident(t) ident(b) "]" :=
  let Heq_gt := fresh "Heqo" in
  let Heq_ge := fresh "Heqo" in
  _destruct_glob_types i Heq_gt Heq_ge t b.

Tactic Notation "destruct_glob_types" constr(i) "eqn" ":" simple_intropattern(Heq_gt) "&" simple_intropattern(Heq_ge) :=
  let t := fresh "t" in
  let b := fresh "b" in
  _destruct_glob_types i Heq_gt Heq_ge t b.

Tactic Notation "destruct_glob_types" constr(i) "as" "[" ident(t) ident(b) "]" "eqn" ":" simple_intropattern(Heq_gt) "&" simple_intropattern(Heq_ge) :=
  _destruct_glob_types i Heq_gt Heq_ge t b.

Fixpoint match_fsig_aux (bl: list expr) (tl: list (ident*type)) : bool :=
 match bl, tl with
 | b::bl', (_,t'):: tl' => if eqb_type (typeof b) t' then match_fsig_aux bl' tl' else false
 | nil, nil => true
 | nil, _::_ => false
 | _::_, nil => false
 end.

Definition match_fsig (fs: funsig) (bl: list expr) (ret: option ident) : bool :=
  andb (match_fsig_aux bl (fst fs))
          (match snd fs, ret with
            | Tvoid , None => true
            | Tvoid, Some _ => false
            | _, None => false
            | _, Some _ => true
            end).

Lemma match_fsig_e: forall fs bl ret,
  match_fsig fs bl ret = true ->
  map typeof bl = map (@snd _ _) (fst fs) /\ (snd fs=Tvoid <-> ret=None).

Definition expr_closed_wrt_vars {CS: compspecs}(S: ident -> Prop) (e: expr) : Prop :=
  forall rho te',
     (forall i, S i \/ Map.get (te_of rho) i = Map.get te' i) ->
     eval_expr e rho = eval_expr e (mkEnviron (ge_of rho) (ve_of rho) te').

Definition lvalue_closed_wrt_vars {CS: compspecs}(S: ident -> Prop) (e: expr) : Prop :=
  forall rho te',
     (forall i, S i \/ Map.get (te_of rho) i = Map.get te' i) ->
     eval_lvalue e rho = eval_lvalue e (mkEnviron (ge_of rho) (ve_of rho) te').

Definition typecheck_store e1 :=
(is_int_type (typeof e1) = true -> typeof e1 = Tint I32 Signed noattr) /\
(is_float_type (typeof e1) = true -> typeof e1 = Tfloat F64 noattr).

Ltac tc_assert_ext :=
repeat match goal with
| [H : _ /\ _ |- _] => destruct H
end.

Ltac of_bool_destruct :=
match goal with
  | [ |- context[Val.of_bool ?X] ] => destruct X
end.

Lemma orb_if : forall {D} b c (d:D) (e:D), (if (b || c) then d else e) = if b then d else if c then d else e.

Lemma andb_if : forall {D} b c (d:D) (e:D), (if (b && c) then d else e) = if b then (if c then d else e) else e.

Program Definition valid_pointer' (p: val) (d: Z) : mpred :=
 match p with
 | Vint i => if Archi.ptr64 then FF else prop (i = Int.zero)

Definition valid_pointer (p: val) : mpred :=
 (valid_pointer' p 0).

Definition weak_valid_pointer (p: val) : mpred :=
 orp (valid_pointer' p 0) (valid_pointer' p (-1)). *)

Require Import VST.veric.expr2.
(* VST.veric.expr2:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_lemmas.
Require Export VST.veric.expr.

Require Import VST.veric.mpred.

Lemma neutral_cast_lemma: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> eval_cast t1 t2 v = v.

Lemma neutral_cast_subsumption: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Lemma neutral_cast_subsumption': forall t1 t2 v,
  is_neutral_cast (implicit_deref t1) t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Definition denote_tc_iszero v : mpred :=
         match v with
         | Vint i => prop (is_true (Int.eq i Int.zero))
         | Vlong i => prop (is_true (Int64.eq i Int64.zero))
         | _ => FF
         end.

Definition denote_tc_nonzero v : mpred :=
         match v with
         | Vint i => prop (i <> Int.zero)
         | Vlong i =>prop (i <> Int64.zero)
         | _ => FF end.

Definition denote_tc_igt i v : mpred :=
     match v with
     | Vint i1 => prop (Int.unsigned i1 < Int.unsigned i)
     | _ => FF
     end.

Definition denote_tc_lgt l v : mpred :=
     match v with
     | Vlong l1 => prop (Int64.unsigned l1 < Int64.unsigned l)
     | _ => FF
     end.

Definition Zoffloat (f:float): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition Zofsingle (f: float32): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition denote_tc_Zge z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition denote_tc_Zle z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition sameblock v1 v2 : bool :=
         match v1, v2 with
          | Vptr b1 _, Vptr b2 _ => peq b1 b2
          | _, _ => false
         end.

Definition denote_tc_samebase v1 v2 : mpred :=
       prop (is_true (sameblock v1 v2)).

Definition denote_tc_nodivover v1 v2 : mpred :=
match v1, v2 with
          | Vint n1, Vint n2 => prop (~(n1 = Int.repr Int.min_signed /\ n2 = Int.mone))
          | Vlong n1, Vlong n2 => prop (~(n1 = Int64.repr Int64.min_signed /\ n2 = Int64.mone))
          | Vint n1, Vlong n2 => TT
          | Vlong n1, Vint n2 => prop (~ (n1 = Int64.repr Int64.min_signed  /\ n2 = Int.mone))
          | _ , _ => FF
        end.

Definition denote_tc_nosignedover (op: Z->Z->Z) v1 v2 : mpred :=
 match v1,v2 with
 | Vint n1, Vint n2 => 
   prop (Int.min_signed <= op (Int.signed n1) (Int.signed n2) <= Int.max_signed)
 | Vlong n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vint n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vlong n1, Vint n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int.signed n2) <= Int64.max_signed)
 | _, _ => FF
 end.

Definition denote_tc_initialized id ty rho : mpred :=
    prop (exists v, Map.get (te_of rho) id = Some v
               /\ tc_val ty v).

Definition denote_tc_isptr v : mpred :=
  prop (isptr v).

Definition denote_tc_isint v : mpred :=
  prop (is_int I32 Signed v).

Definition denote_tc_islong v : mpred :=
  prop (is_long v).

Definition test_eq_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else (andp (valid_pointer v1) (valid_pointer v2)).

Definition test_order_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else FF.

Definition denote_tc_test_eq v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => 
     if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => 
     if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vint i, Vptr _ _ =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v2)
 | Vlong i, Vptr _ _ =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v2) else FF
 | Vptr _ _, Vint i =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v1)
 | Vptr _ _, Vlong i =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v1) else FF
 | Vptr _ _, Vptr _ _ =>
      test_eq_ptrs v1 v2
 | _, _ => FF
 end.

Definition denote_tc_test_order v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vptr _ _, Vptr _ _ =>
      test_order_ptrs v1 v2
 | _, _ => FF
 end.

Definition typecheck_error (e: tc_error) : Prop := False.

Fixpoint denote_tc_assert {CS: compspecs}(a: tc_assert) : environ -> mpred :=
  match a with
  | tc_FF msg => `(prop (typecheck_error msg))
  | tc_TT => `TT
  | tc_andp' b c => `andp (denote_tc_assert b) (denote_tc_assert c)
  | tc_orp' b c => `orp (denote_tc_assert b) (denote_tc_assert c)
  | tc_nonzero' e => `denote_tc_nonzero (eval_expr e)
  | tc_isptr e => `denote_tc_isptr (eval_expr e)
  | tc_isint e => `denote_tc_isint (eval_expr e)
  | tc_islong e => `denote_tc_islong (eval_expr e)
  | tc_test_eq' e1 e2 => `denote_tc_test_eq (eval_expr e1) (eval_expr e2)
  | tc_test_order' e1 e2 => `denote_tc_test_order (eval_expr e1) (eval_expr e2)
  | tc_ilt' e i => `(denote_tc_igt i) (eval_expr e)
  | tc_llt' e l => `(denote_tc_lgt l) (eval_expr e)
  | tc_Zle e z => `(denote_tc_Zge z) (eval_expr e)
  | tc_Zge e z => `(denote_tc_Zle z) (eval_expr e)
  | tc_samebase e1 e2 => `denote_tc_samebase (eval_expr e1) (eval_expr e2)
  | tc_nodivover' v1 v2 => `denote_tc_nodivover (eval_expr v1) (eval_expr v2)
  | tc_initialized id ty => denote_tc_initialized id ty
  | tc_iszero' e => `denote_tc_iszero (eval_expr e)
  | tc_nosignedover op e1 e2 => `(denote_tc_nosignedover op) (eval_expr e1) (eval_expr e2)
 end.

Lemma and_False: forall x, (x /\ False) = False.

Lemma and_True: forall x, (x /\ True) = x.

Lemma True_and: forall x, (True /\ x) = x.

Lemma False_and: forall x, (False /\ x) = False.

Lemma tc_andp_sound : forall {CS: compspecs} a1 a2 rho m,
    denote_tc_assert  (tc_andp a1 a2) rho m <->
    denote_tc_assert  (tc_andp' a1 a2) rho m.

Lemma denote_tc_assert_andp:
  forall {CS: compspecs} a b rho, denote_tc_assert (tc_andp a b) rho =
             andp (denote_tc_assert a rho) (denote_tc_assert b rho).

Lemma neutral_isCastResultType:
  forall {CS: compspecs} t t' v rho,
   is_neutral_cast t' t = true ->
   forall m, denote_tc_assert (isCastResultType t' t v) rho m.

Lemma is_true_e: forall b, is_true b -> b=true.

Lemma tc_bool_e: forall {CS: compspecs} b a rho m,
  app_pred (denote_tc_assert (tc_bool b a) rho) m ->
  b = true. *)

Require Import VST.veric.expr_lemmas.
(* VST.veric.expr_lemmas:
Require Import VST.veric.Clight_base.
Require Import VST.msl.msl_standard.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Export VST.veric.environ_lemmas.
Require Import VST.veric.binop_lemmas2.
Require Import VST.veric.binop_lemmas3.
Require Import VST.veric.binop_lemmas.
Require Import VST.veric.binop_lemmas4.
Require Import VST.veric.expr_lemmas2.
Require Export VST.veric.expr_lemmas3.
Require Export VST.veric.expr_lemmas4.
Require Import VST.veric.juicy_mem.
Import Cop.
Import Cop2.
Import Clight_Cop2.

Lemma tc_bool_val:
  forall v t,
       tc_val t v ->
       bool_type t = true ->
      exists b, strict_bool_val v t = Some b.

Lemma bool_val_strict: forall t v b, tc_val t v -> bool_type t = true -> bool_val t v = Some b ->
  strict_bool_val v t = Some b.

Lemma bool_val_Cop: forall t v m b b', bool_val t v = Some b -> Cop.bool_val v t m = Some b' ->

Lemma map_ptree_rel : forall id v te, Map.set id v (make_tenv te) = make_tenv (PTree.set id v te).

Lemma cast_exists : forall {CS: compspecs} Delta e2 t rho phi
(TC: typecheck_environ Delta rho),
denote_tc_assert (typecheck_expr Delta e2) rho phi ->
denote_tc_assert (isCastResultType (typeof e2) t e2)
  rho phi ->
sem_cast (typeof e2) t (eval_expr e2 rho)  =
Some (force_val (sem_cast (typeof e2) t (eval_expr e2 rho))).

Definition func_tycontext_t_denote :=
forall p t id ty ,  list_norepet (map fst p ++ map fst t ) ->
((make_tycontext_t p t) ! id = Some ty <-> (In (id,ty) p \/ In (id,ty) t)).

Definition func_tycontext_v_denote :=
forall v id ty, list_norepet (map fst v) ->
((make_tycontext_v v) ! id = Some ty <-> In (id,ty) v).

Lemma func_tycontext_v_sound : func_tycontext_v_denote.

Lemma set_inside : forall i0 t1 t p id,
list_disjoint (map fst p) (i0 :: map fst t) ->
(fold_right
          (fun param : ident * type =>
           PTree.set (fst param) (snd param, true))

Lemma func_tycontext_t_sound : func_tycontext_t_denote.

Definition cast_no_val_change (from: type)(to:type) : bool :=
match from, to with
| Tint _ _ _, Tint I32 _ _ => true
| Tpointer _ _, Tpointer _ _ => 
    eqb_type from to || 
    negb (eqb_type from int_or_ptr_type) && 
    negb (eqb_type to int_or_ptr_type)
| Tfloat F64 _ , Tfloat F64 _ => true
| Tfloat F32 _ , Tfloat F32 _ => true
| _, _ => false
end.

Lemma cast_no_change : forall v from to m,
tc_val from v ->
is_true (cast_no_val_change from to) ->
Cop.sem_cast v from to m = Some v.

Lemma tc_exprlist_length : forall {CS: compspecs} Delta tl el rho phi,
denote_tc_assert (typecheck_exprlist Delta tl el) rho phi ->
length tl = length el.

Lemma neutral_cast_tc_val : forall {CS: compspecs} e t rho phi Delta,
true = is_neutral_cast (implicit_deref (typeof e)) t ->
denote_tc_assert (isCastResultType (implicit_deref (typeof e)) t  e) rho phi ->
denote_tc_assert (typecheck_expr Delta e) rho phi ->
typecheck_environ Delta rho ->
tc_val t (eval_expr e rho).

Opaque Int.repr.

Definition typecheck_tid_ptr_compare
Delta id :=
match (temp_types Delta) ! id with
| Some t => is_int_type t
| None => false
end.

Lemma typecheck_tid_ptr_compare_sub:
   forall Delta Delta',
    tycontext_sub Delta Delta' ->
    forall id, typecheck_tid_ptr_compare Delta id = true ->
                typecheck_tid_ptr_compare Delta' id = true.

Lemma int64_eq_e:
 forall i j, Int64.eq i j = true -> i=j.

Lemma tc_val_sem_cast:
  forall {CS: compspecs} t2 e2 rho phi Delta,
      typecheck_environ Delta rho ->
      denote_tc_assert (typecheck_expr Delta e2) rho phi ->
      denote_tc_assert (isCastResultType (typeof e2) t2  e2) rho phi ->
      tc_val t2 (force_val (sem_cast (typeof e2) t2 (eval_expr e2 rho))). *)

Require Import VST.veric.expr_lemmas4.
(* VST.veric.expr_lemmas4:
Require Import VST.veric.Clight_base.
Require Import VST.msl.msl_standard.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Export VST.veric.environ_lemmas.
Require Import VST.veric.binop_lemmas2.
Require Import VST.veric.binop_lemmas.
Require Import VST.veric.binop_lemmas4.
Require Import VST.veric.binop_lemmas5.
Require Import VST.veric.binop_lemmas6.
Require Import VST.veric.expr_lemmas2.
Require Export VST.veric.expr_lemmas3.
Require Import VST.veric.juicy_mem.
Import Cop.
Import Cop2.
Import Clight_Cop2.

Lemma typecheck_both_sound:
  forall {CS: compspecs} Delta rho m e ,
             typecheck_environ Delta rho ->
             (denote_tc_assert (typecheck_expr Delta e) rho m ->
             tc_val (typeof e) (eval_expr e rho)) /\
             (forall pt,
             denote_tc_assert (typecheck_lvalue Delta e) rho m ->
             is_pointer_type pt = true ->
             tc_val pt (eval_lvalue e rho)).

Lemma typecheck_expr_sound : forall {CS: compspecs} Delta rho m e,
 typecheck_environ Delta rho ->
              denote_tc_assert (typecheck_expr Delta e) rho m ->
              tc_val (typeof e) (eval_expr e rho).

Lemma typecheck_lvalue_sound : forall {CS: compspecs} Delta rho m e,
  typecheck_environ Delta rho ->
  denote_tc_assert (typecheck_lvalue Delta e) rho m ->
  is_pointer_or_null (eval_lvalue e rho).

Ltac unfold_cop2_sem_cmp :=
unfold Clight_Cop2.sem_cmp, Clight_Cop2.sem_cmp_pl, Clight_Cop2.sem_cmp_lp, Clight_Cop2.sem_cmp_pp.

Lemma eval_binop_relate:
 forall {CS: compspecs} Delta (ge: genv) te ve rho b e1 e2 t m
        (Hcenv: genv_cenv ge = @cenv_cs CS),
    rho = construct_rho (filter_genv ge) ve te ->
    typecheck_environ Delta rho ->
    ((denote_tc_assert (typecheck_expr Delta e1) rho) (m_phi m) ->
      Clight.eval_expr ge ve te (m_dry m) e1 (eval_expr e1 rho)) ->

Lemma valid_pointer_dry0:
  forall b ofs m, app_pred (valid_pointer (Vptr b ofs)) (m_phi m) ->
           Mem.valid_pointer (m_dry m) b (Ptrofs.unsigned ofs) = true.

Definition some_pt_type := Tpointer Tvoid noattr.

Lemma tc_force_Some : forall ov t, tc_val t (force_val ov)
-> exists v, ov = Some v.

Lemma typecheck_binop_sound2:
 forall {CS: compspecs} (Delta : tycontext) (rho : environ) m (b : binary_operation)
     (e1 e2 : expr) (t : type),
   denote_tc_assert (typecheck_expr Delta e2) rho m ->
   denote_tc_assert (isBinOpResultType b e1 e2 t) rho m ->
   denote_tc_assert (typecheck_expr Delta e1) rho m ->
   tc_val (typeof e2) (eval_expr e2 rho) ->
   tc_val (typeof e1) (eval_expr e1 rho) ->
   tc_val t
     (eval_binop b (typeof e1) (typeof e2) (eval_expr e1 rho) (eval_expr e2 rho)).

Lemma eval_binop_relate_fail :
forall {CS: compspecs} (Delta : tycontext) (rho : environ) (b : binary_operation)
  (e1 e2 : expr) (t : type) m,
typecheck_environ  Delta rho ->
forall (ge : genv) te ve,
rho = construct_rho (filter_genv ge) ve te ->
denote_tc_assert (typecheck_expr Delta e2) rho (m_phi m) ->
denote_tc_assert (isBinOpResultType b e1 e2 t) rho (m_phi m) ->
denote_tc_assert (typecheck_expr Delta e1) rho (m_phi m) ->
None =
sem_binary_operation' b  (typeof e1) (typeof e2) (eval_expr e1 rho) (eval_expr e2 rho) ->
Clight.eval_expr ge ve te (m_dry m) e2 (eval_expr e2 rho) ->

Opaque tc_andp.

Lemma tc_test_eq0:
  forall b i m,
  (denote_tc_test_eq (Vptr b i) (Vint Int.zero)) (m_phi m) ->

Lemma cop2_sem_cast :
    forall t1 t2 v m,
 (classify_cast t1 t2 = classify_cast size_t tbool ->
   denote_tc_test_eq v (Vint Int.zero) (m_phi m) )->

Ltac destruct_eqb_type := 
match goal with H: context [eqb_type ?t1 ?t2] |- _ =>
 let J := fresh "J" in 
  destruct (eqb_type t1 t2) eqn:?J;
 [apply eqb_type_true in J | apply eqb_type_false in J]
end.

Lemma classify_cast_eq:
 forall t1 t2,
  t1 <> int_or_ptr_type ->
  t2 <> int_or_ptr_type ->
  classify_cast t1 t2 = Cop.classify_cast t1 t2.

Definition cast_pointer_to_bool t1 t2 :=
 match t1 with (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) => 
           match t2 with Tint IBool _ _ => true | _ => false end
 | _ => false
end.

Lemma sem_cast_e1:
 forall t t1 v1 v m,
   sem_cast t t1 v = Some v1 ->
   cast_pointer_to_bool t t1 = false ->
   tc_val t v ->
   Cop.sem_cast v t t1 m = Some v1.

Lemma cop2_sem_cast' :
    forall {CS: compspecs} t2 e rho m,
 (denote_tc_assert (isCastResultType (typeof e) t2 e) rho) (m_phi m) ->
  tc_val (typeof e) (eval_expr e rho) ->
 Cop.sem_cast (eval_expr e rho) (typeof e) t2 (m_dry m) =

Lemma isBinOpResultType_binop_stable: forall {CS: compspecs} b e1 e2 t rho phi,
  denote_tc_assert (isBinOpResultType b e1 e2 t) rho phi ->
  binop_stable cenv_cs b e1 e2 = true.

Lemma eval_unop_relate:
 forall {CS: compspecs} Delta (ge: genv) te ve rho u e t m 
 (Hcenv : genv_cenv ge = @cenv_cs CS)
 (H : rho = construct_rho (filter_genv ge) ve te)
 (H0 : typecheck_environ Delta rho)
 (H1 : (denote_tc_assert (typecheck_expr Delta e) rho) (m_phi m) ->
     Clight.eval_expr ge ve te (m_dry m) e (eval_expr e rho))

Lemma eqb_type_sym: forall a b, eqb_type a b = eqb_type b a.

Lemma Ptrofs_to_int_repr: 
  Archi.ptr64=false -> 

Lemma eval_both_relate:
  forall {CS: compspecs} Delta ge te ve rho e m,
           genv_cenv ge = cenv_cs ->
           rho = construct_rho (filter_genv ge) ve te ->
           typecheck_environ Delta rho ->
           (denote_tc_assert (typecheck_expr Delta e) rho (m_phi m) ->
             Clight.eval_expr ge ve te (m_dry m) e  (eval_expr e rho))

Lemma eval_expr_relate:
  forall {CS: compspecs} Delta ge te ve rho e m,
           genv_cenv ge = cenv_cs ->
           rho = construct_rho (filter_genv ge) ve te ->
           typecheck_environ Delta rho ->
           (denote_tc_assert (typecheck_expr Delta e) rho (m_phi m) ->
             Clight.eval_expr ge ve te (m_dry m) e  (eval_expr e rho)).

Lemma eval_lvalue_relate:
  forall {CS: compspecs} Delta ge te ve rho e m,
           genv_cenv ge = cenv_cs ->
           rho = construct_rho (filter_genv ge) ve te->
           typecheck_environ Delta rho ->
           (denote_tc_assert (typecheck_lvalue Delta e) rho (m_phi m) ->
             exists b, exists ofs,
              Clight.eval_lvalue ge ve te (m_dry m) e b ofs /\ *)

Require Import VST.veric.semax.
(* VST.veric.semax:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
Require Import VST.veric.res_predicates.
Require Import VST.veric.extend_tc.
Require Import VST.veric.Clight_seplog.
Require Import VST.veric.Clight_assert_lemmas.
Require Import VST.veric.Clight_new.
Require Import VST.veric.Clight_lemmas.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.
Require Import VST.veric.own.

Local Open Scope nat_scope.
Local Open Scope pred.

Definition closed_wrt_modvars c (F: assert) : Prop :=
    closed_wrt_vars (modifiedvars c) F.

Definition genv_symb_injective {F V} (ge: Genv.t F V) : extspec.injective_PTree block.

Definition jsafeN {Z} (Hspec : juicy_ext_spec Z) (ge: genv) :=
  @jsafeN_ genv _ _ genv_symb_injective 
               (cl_core_sem ge) Hspec ge.

Lemma ext_join_approx : forall {Z} (z : Z) n g,
  joins g (Some (ghost_PCM.ext_ref z, NoneP) :: nil) ->

Lemma ext_join_unapprox : forall {Z} (z : Z) n g,
  joins (ghost_fmap (approx n) (approx n) g) (Some (ghost_PCM.ext_ref z, NoneP) :: nil) ->

Program Definition ext_compat {Z} (ora : Z) : mpred :=
  fun w => joins (ghost_of w) (Some (ghost_PCM.ext_ref ora, NoneP) :: nil).

Program Definition assert_safe
     (Espec : OracleKind)
     (ge: genv) ve te (ctl: cont) : assert :=
  fun rho => bupd (fun w => forall ora (jm:juicy_mem),
       ext_compat ora w ->
       rho = construct_rho (filter_genv ge) ve te ->
       m_phi jm = w ->
             jsafeN (@OK_spec Espec) ge (level w) ora (State ve te ctl) jm).

Definition list2opt {T: Type} (vl: list T) : option T :=
 match vl with nil => None | x::_ => Some x end.

Definition match_venv (ve: venviron) (vars: list (ident * type)) :=
 forall id, match ve id with Some (b,t) => In (id,t) vars | _ => True end.

Definition guard_environ (Delta: tycontext) (f: option function) (rho: environ) : Prop :=
   typecheck_environ Delta rho /\
  match f with
  | Some f' => match_venv (ve_of rho) (fn_vars f')
                /\ ret_type Delta = fn_return f'
  | None => True
  end.

Lemma guard_environ_e1:
   forall Delta f rho, guard_environ Delta f rho ->
     typecheck_environ Delta rho.

Definition _guard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext) (P : assert) (f: option function) (ctl: cont) : pred nat :=
     ALL tx : Clight.temp_env, ALL vx : env,
          let rho := construct_rho (filter_genv gx) vx tx in
          !! guard_environ Delta f rho
                  && P rho && funassert Delta rho
             >=> assert_safe Espec gx vx tx ctl rho.

Definition guard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext) (P : assert)  (ctl: cont) : pred nat :=
  _guard Espec gx Delta P (current_function ctl) ctl.

Definition zap_fn_return (f: function) : function :=
 mkfunction Tvoid f.(fn_callconv) f.(fn_params) f.(fn_vars) f.(fn_temps) f.(fn_body).

Definition exit_cont (ek: exitkind) (vl: option val) (k: cont) : cont :=
  match ek with
  | EK_normal => k
  | EK_break => break_cont k
  | EK_continue => continue_cont k
  | EK_return =>
         match vl, call_cont k with
         | Some v, Kcall (Some x) f ve te :: k' =>
                    Kseq (Sreturn None) :: Kcall None (zap_fn_return f) ve (PTree.set x v te) :: k'
         | _,_ => Kseq (Sreturn None) :: call_cont k
         end
   end.

Definition rguard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext)  (R : ret_assert) (ctl: cont) : pred nat :=
  ALL ek: exitkind, ALL vl: option val,
    _guard Espec gx Delta (proj_ret_assert R ek vl) (current_function ctl) (exit_cont ek vl ctl).

Record semaxArg :Type := SemaxArg {
 sa_Delta: tycontext;
 sa_P: assert;
 sa_c: statement;
 sa_R: ret_assert
}.

Definition ext_spec_pre' (Espec: OracleKind) (ef: external_function)
   (x': ext_spec_type OK_spec ef) (ge_s: injective_PTree block)
   (ts: list typ) (args: list val) (z: OK_ty) : pred juicy_mem :=
  exist (hereditary age)
     (ext_spec_pre OK_spec ef x' ge_s ts args z)
     (JE_pre_hered _ _ _ _ _ _ _ _).

Program Definition ext_spec_post' (Espec: OracleKind)
   (ef: external_function) (x': ext_spec_type OK_spec ef) (ge_s: injective_PTree block)
   (tret: option typ) (ret: option val) (z: OK_ty) : pred juicy_mem :=
  exist (hereditary age)
   (ext_spec_post OK_spec ef x' ge_s tret ret z)
     (JE_post_hered _ _ _ _ _ _ _ _).

Definition juicy_mem_pred (P : pred rmap) (jm: juicy_mem): pred nat :=
     # diamond fashionM (exactly (m_phi jm) && P).

Fixpoint make_ext_args (gx: genviron) (ids: list ident) (vl: list val)  :=
  match ids, vl with
  | id::ids', v::vl' => env_set (make_ext_args gx ids' vl') id v
  | _, v::vl' => env_set (make_ext_args gx ids vl') 1%positive v
  | _, _ => mkEnviron gx (Map.empty _) (Map.empty _)
 end.

Definition make_ext_rval  (gx: genviron) (v: option val):=
  match v with
  | Some v' =>  mkEnviron gx (Map.empty _)
                              (Map.set 1%positive v' (Map.empty _))
  | None => mkEnviron gx (Map.empty _) (Map.empty _)
  end.

Definition semax_external
  (Hspec: OracleKind) (ids: list ident) ef
  (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)):
        pred nat :=
 ALL gx: genv, ALL Ts: list Type,
 ALL x: (dependent_type_functor_rec Ts A (pred rmap)),
   |>  ALL F: pred rmap, ALL ts: list typ,
   ALL args: list val,
   !!Val.has_type_list args (sig_args (ef_sig ef)) &&
   juicy_mem_op (P Ts x (make_ext_args (filter_genv gx) ids args) * F) >=>
   EX x': ext_spec_type OK_spec ef,
    (ALL z:_, juicy_mem_op (ext_compat z) -->
     ext_spec_pre' Hspec ef x' (genv_symb_injective gx) ts args z) &&
     ! ALL tret: option typ, ALL ret: option val, ALL z': OK_ty,
      ext_spec_post' Hspec ef x' (genv_symb_injective gx) tret ret z' >=>
          juicy_mem_op (Q Ts x (make_ext_rval (filter_genv gx) ret) * F).

Definition tc_option_val (sig: type) (ret: option val) :=
  match sig, ret with
    | Tvoid, None => True
    | Tvoid, Some _ => False
    | ty, Some v => tc_val ty v
    | _, _ => False
  end.

Fixpoint zip_with_tl {A : Type} (l1 : list A) (l2 : typelist) : list (A*type) :=
  match l1, l2 with
    | a::l1', Tcons b l2' => (a,b)::zip_with_tl l1' l2'
    | _, _ => nil
  end.

Definition believe_external (Hspec: OracleKind) (gx: genv) (v: val) (fsig: funsig) cc
  (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)):
  pred nat :=
  match Genv.find_funct gx v with
  | Some (External ef sigargs sigret cc') =>
      let ids := fst (split (fst fsig)) in
        !! (fsig = (zip_with_tl ids sigargs, sigret) /\ cc'=cc
           /\ ef_sig ef = mksignature
                           (typlist_of_typelist (type_of_params (fst fsig)))
                           (opttyp_of_type (snd fsig)) cc
           /\ length (typelist2list sigargs)=length ids)
        && semax_external Hspec ids ef A P Q
        && ! (ALL ts: list Type,
              ALL x: dependent_type_functor_rec ts A (pred rmap),
              ALL ret:option val,
                Q ts x (make_ext_rval (filter_genv gx) ret)
                  && !!has_opttyp ret (opttyp_of_type (snd fsig))
                  >=> !! tc_option_val sigret ret)
  | _ => FF
  end.

Definition fn_funsig (f: function) : funsig := (fn_params f, fn_return f).

Definition var_sizes_ok (cenv: composite_env) (vars: list (ident*type)) :=
   Forall (fun var : ident * type => @sizeof cenv (snd var) <= Ptrofs.max_unsigned)%Z vars.

Definition var_block' (sh: Share.t) (cenv: composite_env) (idt: ident * type) (rho: environ): mpred :=
  !! (sizeof (snd idt) <= Ptrofs.max_unsigned)%Z &&
  (memory_block sh (sizeof (snd idt))) (eval_lvar (fst idt) (snd idt) rho).

Definition stackframe_of' (cenv: composite_env) (f: Clight.function) : assert :=
  fold_right (fun P Q rho => P rho * Q rho) (fun rho => emp)
     (map (fun idt => var_block' Share.top cenv idt) (Clight.fn_vars f)).

Definition believe_internal_
  (semax:semaxArg -> pred nat)
  (gx: genv) (Delta: tycontext) v (fsig: funsig) cc (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)) : pred nat :=
  (EX b: block, EX f: function,
   prop (v = Vptr b Ptrofs.zero /\ Genv.find_funct_ptr gx b = Some (Internal f)
                 /\ Forall (fun it => complete_type (genv_cenv gx) (snd it) = true) (fn_vars f)
                 /\ list_norepet (map (@fst _ _) f.(fn_params) ++ map (@fst _ _) f.(fn_temps))
                 /\ list_norepet (map (@fst _ _) f.(fn_vars)) /\ var_sizes_ok (genv_cenv gx) (f.(fn_vars))
                 /\ fsig = fn_funsig f /\ f.(fn_callconv) = cc)
  && ALL ts: list Type,
     ALL x : dependent_type_functor_rec ts A (pred rmap),
           |> semax (SemaxArg  (func_tycontext' f Delta)
                                (fun rho => (bind_args f.(fn_params) f.(fn_vars) (P ts x) rho * stackframe_of' (genv_cenv gx) f rho)
                                             && funassert (func_tycontext' f Delta) rho)
                              (Ssequence f.(fn_body) (Sreturn None))
           (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of' (genv_cenv gx) f)))).

Definition empty_environ (ge: genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Definition claims (ge: genv) (Delta: tycontext) v fsig cc A P Q : Prop :=
  exists id HP HQ, (glob_specs Delta)!id = Some (mk_funspec fsig cc A P Q HP HQ) /\
    exists b, Genv.find_symbol ge id = Some b /\ v = Vptr b Ptrofs.zero.

Definition believepred (Espec: OracleKind) (semax: semaxArg -> pred nat)
              (Delta: tycontext) (gx: genv)  (Delta': tycontext) : pred nat :=
  ALL v:val, ALL fsig: funsig, ALL cc: calling_convention,
  ALL A: TypeTree,
  ALL P: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred,
  ALL Q: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred,
       !! claims gx Delta' v fsig cc A P Q  -->
      (believe_external Espec gx v fsig cc A P Q
        || believe_internal_ semax gx Delta v fsig cc A P Q).

Definition semax_  {CS: compspecs}  (Espec: OracleKind)
       (semax: semaxArg -> pred nat) (a: semaxArg) : pred nat :=
 match a with SemaxArg Delta P c R =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs)-->
      (believepred Espec semax Delta' gx Delta') -->
     ALL k: cont, ALL F: assert,
       (!! (closed_wrt_modvars c F) &&
              rguard Espec gx Delta' (frame_ret_assert R F) k) -->
        guard Espec gx Delta' (fun rho => F rho * P rho) (Kseq c :: k)
  end.

Definition semax'  {CS: compspecs} (Espec: OracleKind) Delta P c R : pred nat :=
     HORec (semax_  Espec) (SemaxArg Delta P c R).

Definition believe_internal {CS: compspecs} (Espec:  OracleKind)
  (gx: genv) (Delta: tycontext) v (fsig: funsig) cc (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)) : pred nat :=
  (EX b: block, EX f: function,
   prop (v = Vptr b Ptrofs.zero /\ Genv.find_funct_ptr gx b = Some (Internal f)
                 /\ Forall (fun it => complete_type (genv_cenv gx) (snd it) = true) (fn_vars f)
                 /\ list_norepet (map (@fst _ _) f.(fn_params) ++ map (@fst _ _) f.(fn_temps))
                 /\ list_norepet (map (@fst _ _) f.(fn_vars)) /\ var_sizes_ok (genv_cenv gx) (f.(fn_vars))
                 /\ fsig = fn_funsig f /\ f.(fn_callconv) = cc)
  && ALL ts: list Type,
     ALL x : dependent_type_functor_rec ts A (pred rmap),
        |> semax' Espec (func_tycontext' f Delta)
                                (fun rho => (bind_args f.(fn_params) f.(fn_vars) (P ts x) rho * stackframe_of' (genv_cenv gx)  f rho)
                                             && funassert (func_tycontext' f Delta) rho)
                               (Ssequence f.(fn_body) (Sreturn None))
           (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of' (genv_cenv gx) f))).

Definition believe {CS: compspecs} (Espec:OracleKind)
              (Delta: tycontext) (gx: genv) (Delta': tycontext): pred nat :=
  ALL v:val, ALL fsig: funsig, ALL cc: calling_convention,
  ALL A: TypeTree,
  ALL P: (forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)),
  ALL Q: (forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)),
       !! claims gx Delta' v fsig cc A P Q  -->
      (believe_external Espec gx v fsig cc A P Q
        || believe_internal Espec gx Delta v fsig cc A P Q).

Lemma semax_fold_unfold : forall {CS: compspecs} (Espec : OracleKind),
  semax' Espec = fun Delta P c R =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs) -->
       believe Espec Delta' gx Delta' -->
     ALL k: cont, ALL F: assert,
        (!! (closed_wrt_modvars c F) && rguard Espec gx Delta' (frame_ret_assert R F) k) -->
        guard Espec gx Delta' (fun rho => F rho * P rho) (Kseq c :: k).

Definition weakest_pre {CS: compspecs} (Espec: OracleKind) (Delta: tycontext) c Q: assert :=
  fun rho: environ =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs) -->
       unfash (believe Espec Delta' gx Delta') -->
     ALL k: cont, ALL F: assert,
        unfash (!! (closed_wrt_modvars c F) && rguard Espec gx Delta' (frame_ret_assert Q F) k) -->
        
        ALL tx : Clight.temp_env, ALL vx : env,
          (!! (rho = construct_rho (filter_genv gx) vx tx)) -->
          ((!! guard_environ Delta' (current_function (Kseq c :: k)) rho && funassert Delta' rho) -->
             (F rho -* assert_safe Espec gx vx tx (Kseq c :: k) rho)).

Opaque semax'.

Definition semax {CS: compspecs} (Espec: OracleKind) (Delta: tycontext) P c Q :=
  forall n, semax' Espec Delta P c Q n.

Lemma any_level_pred_nat: forall P: pred nat, (forall n, P n) <-> TT |-- P.

Lemma semax_weakest_pre_aux: forall {A: Type} (P: pred nat) (Q R: A -> pred rmap),
  P = fash (ALL x: A, Q x --> R x) ->
  (TT |-- P <-> forall x, Q x |-- R x).

Lemma unfash_allp:  forall {A} {agA: ageable A} {B} (f: B -> pred nat),
  @unfash _ agA (allp f) = allp (fun x:B => unfash (f x)).

Lemma fash_TT: forall {A} {agA: ageable A}, @unfash A agA TT = TT.

Lemma allp_andp: 
  forall {A} {NA: ageable A} {B: Type} (b0: B) (P: B -> pred A) (Q: pred A),
   (allp P && Q = allp (fun x => P x && Q))%pred.

Lemma unfash_prop_imp:
  forall {A} {agA: ageable A} (P: Prop) (Q: pred nat),
  (@unfash _ agA (prop P --> Q) = prop P --> @unfash _ agA Q)%pred.

Import age_to.

Lemma unfash_imp:
  forall {A} {NA: ageable A} (P Q: pred nat),
  (@unfash A _ (P --> Q) = (@unfash A _ P) --> @unfash A _ Q)%pred.

Lemma unfash_andp:  forall {A} {agA: ageable A} (P Q: pred nat),
  (@unfash A agA (andp P Q) = andp (@unfash A agA P) (@unfash A agA Q)).

Lemma andp_imp_e':
  forall (A : Type) (agA : ageable A) (P Q : pred A),
   P && (P --> Q) |-- P && Q.

Lemma unfash_fash:
  forall (A : Type) (agA : ageable A) (P : pred A),
   unfash (fash P) |-- P.

Lemma imp_imp:
  forall (A : Type) (agA : ageable A) (P Q R: pred A),
    P --> (Q --> R) = P && Q --> R.

Lemma imp_allp:
  forall B (A : Type) (agA : ageable A) (P: pred A) (Q: B -> pred A),
    P --> allp Q  = ALL x: B, P --> Q x.

Lemma fash_prop: forall P: Prop,
  fash (!! P: pred rmap) = !! P.

Lemma fash_unfash:
  forall (P : pred nat),
   fash (unfash P: pred rmap) = P.

Lemma prop_true_imp:
  forall (P: Prop) (Q: pred rmap),
    P -> !! P --> Q = Q.

Lemma corable_unfash:
  forall (A : Type) (JA : Join A) (PA : Perm_alg A) (SA : Sep_alg A) (agA : ageable A) 
    (AgeA : Age_alg A) (P : pred nat), corable (! P). *)

Require Import VST.veric.semax_lemmas.
(* VST.veric.semax_lemmas:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
Require Import VST.veric.res_predicates.
Require Import VST.veric.extend_tc.
Require Import VST.veric.Clight_seplog.
Require Import VST.veric.Clight_assert_lemmas.
Require Import VST.veric.Clight_new.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.semax.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.own.

Local Open Scope pred.

Hint Resolve @now_later @andp_derives @sepcon_derives.

Lemma no_dups_swap:
  forall F V a b c, @no_dups F V (a++b) c -> @no_dups F V (b++a) c.

Lemma join_sub_share_top: forall sh, join_sub Share.top sh -> sh = Share.top.

Lemma opt2list2opt: forall {A:Type} (l: option A), list2opt (opt2list l) = l.

Lemma nat_of_Z_minus_le : forall z a b,
  b <= a ->
  (nat_of_Z (z - a) <= nat_of_Z (z - b))%nat.

Section SemaxContext.

Lemma universal_imp_unfold {A} {agA: ageable A}:
   forall B (P Q: B -> pred A) w,
     (ALL psi : B, P psi --> Q psi) w = (forall psi : B, (P psi --> Q psi) w).

Lemma guard_environ_put_te':
 forall ge te ve Delta id v k,
 guard_environ Delta k (mkEnviron ge ve te)  ->
    (forall t,
        (temp_types Delta) ! id = Some t -> tc_val' t v) ->
 guard_environ Delta k (mkEnviron ge ve (Map.set id v te)).

Lemma prop_imp_derives {A}{agA: ageable A}:
  forall (P: Prop) (Q Q': pred A),  (P -> Q |-- Q') -> !!P --> Q |-- !!P --> Q'.

Lemma prop_imp {A}{agA: ageable A}:
  forall (P: Prop) (Q Q': pred A),  (P -> Q = Q') -> !!P --> Q = !!P --> Q'.

Lemma age_laterR {A} `{ageable A}: forall {x y}, age x y -> laterR x y.
Hint Resolve @age_laterR.

Lemma typecheck_environ_sub:
  forall Delta Delta', tycontext_sub Delta Delta' ->
   forall rho,
   typecheck_environ Delta' rho -> typecheck_environ Delta rho.

Lemma funassert_resource: forall Delta rho a a' (Hl: level a = level a')
  (Hr: resource_at a = resource_at a'),
  funassert Delta rho a -> funassert Delta rho a'.

Lemma cl_corestep_fun': forall ge, corestep_fun (cl_core_sem ge).
Hint Resolve cl_corestep_fun'.

Lemma derives_skip:
  forall {CS: compspecs} {Espec: OracleKind} p Delta (R: ret_assert),
      (forall rho, p rho |-- proj_ret_assert R EK_normal None rho) ->
        semax Espec Delta p Clight.Sskip R.

Lemma jsafe_corestep_forward:
  forall {Espec: OracleKind} ge c m c' m' n z,
    jstep (cl_core_sem ge) c m c' m' -> jsafeN (@OK_spec Espec) ge (S n) z c m ->
    jm_bupd z (jsafeN (@OK_spec Espec) ge n z c') m'.

Lemma semax_unfold {CS: compspecs} {Espec: OracleKind}:
  semax Espec = fun Delta P c R =>
    forall (psi: Clight.genv) Delta' (w: nat)

Fixpoint list_drop (A: Type) (n: nat) (l: list A) {struct n} : list A :=
  match n with O => l | S i => match l with nil => nil | _ :: l' => list_drop A i l' end end.
Arguments list_drop [A] _ _.

Definition straightline (c: Clight.statement) :=
 forall ge ve te k m ve' te' k' m',
        cl_step ge (State ve te (Kseq c :: k)) m (State ve' te' k') m' ->  k=k'.

Lemma straightline_assign: forall e0 e, straightline (Clight.Sassign e0 e).

Lemma extract_exists_pre_later {CS: compspecs} {Espec: OracleKind}:
  forall  (A : Type) (Q: assert) (P : A -> assert) c Delta (R: ret_assert),
  (forall x, semax Espec Delta (fun rho => Q rho && |> P x rho) c R) ->
   semax Espec Delta (fun rho => Q rho && |> exp (fun x => P x rho)) c R.

Lemma extract_exists_pre {CS: compspecs} {Espec: OracleKind}:
  forall  (A : Type) (P : A -> assert) c Delta (R: ret_assert),
  (forall x, semax Espec Delta (P x) c R) ->
   semax Espec Delta (fun rho => exp (fun x => P x rho)) c R.

Definition G0: funspecs := nil.

Definition empty_genv prog_pub cenv: Clight.genv :=
   Build_genv (Genv.globalenv (AST.mkprogram (F:=Clight.fundef)(V:=type) nil prog_pub (1%positive))) cenv.

Lemma empty_program_ok {CS: compspecs} {Espec: OracleKind}: forall Delta ge w,
    glob_specs Delta = PTree.empty _ ->

Definition all_assertions_computable  :=
  forall (Espec: OracleKind) psi tx vx (Q: assert), 
     exists k,  assert_safe Espec psi tx vx k = Q.

Lemma ewand_TT_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
    ewand TT emp = emp.

Lemma subp_derives' {A}{agA: ageable A}:
  forall P Q: pred A, (forall n, (P >=> Q) n) -> P |-- Q.

Lemma guard_environ_sub:
  forall {Delta Delta' f rho},
   tycontext_sub Delta Delta' ->
   guard_environ Delta' f rho ->
   guard_environ Delta f rho.

Lemma guard_environ_eqv:
  forall Delta Delta' f rho,
  tycontext_eqv Delta Delta' ->
  guard_environ Delta f rho -> guard_environ Delta' f rho.

Lemma proj_frame_ret_assert:
 forall (R: ret_assert) (F: assert) ek vl,
  proj_ret_assert (frame_ret_assert R F) ek vl = 
  seplog.sepcon (proj_ret_assert R ek vl) F.

Lemma semax_extensionality0 {CS: compspecs} {Espec: OracleKind}:
       TT |--
      ALL Delta:tycontext, ALL Delta':tycontext,
      ALL P:assert, ALL P':assert,
      ALL c: statement, ALL R:ret_assert, ALL R':ret_assert,
       ((!! tycontext_sub Delta Delta'
       &&  (ALL ek: exitkind, ALL  vl : option val, ALL rho: environ,  
               (proj_ret_assert R ek vl rho >=> proj_ret_assert R' ek vl rho))
      && (ALL rho:environ, P' rho >=> P rho)  && semax' Espec Delta P c R) >=> semax' Espec Delta' P' c R').

Lemma semax_extensionality1 {CS: compspecs} {Espec: OracleKind}:
  forall Delta Delta' (P P': assert) c (R R': ret_assert) ,
       tycontext_sub Delta Delta' ->
       ((ALL ek: exitkind, ALL  vl : option val, ALL rho: environ,  
          (proj_ret_assert R ek vl rho >=> proj_ret_assert R' ek vl rho))
      && (ALL rho:environ, P' rho >=> P rho)  && (semax' Espec Delta P c R) |-- semax' Espec Delta' P' c R').

Lemma semax_frame {CS: compspecs} {Espec: OracleKind}:  forall Delta P s R F,
   closed_wrt_modvars s F ->
  semax Espec Delta P s R ->
    semax Espec Delta (fun rho => P rho * F rho) s (frame_ret_assert R F).

Lemma assert_safe_last:
  forall {Espec: OracleKind} ge ve te st rho w,
   (forall w', age w w' -> assert_safe Espec ge ve te st rho w) ->
    assert_safe Espec ge ve te st rho w.

Lemma pred_sub_later' {A} `{H: ageable A}:
  forall (P Q: pred A),
           (|> P >=> |> Q)  |--  (|> (P >=> Q)).

Lemma later_strengthen_safe1:
  forall {Espec: OracleKind} (P: pred rmap) ge ve te k rho,
              ((|> P) >=> assert_safe Espec ge ve te k rho) |--   |>  (P >=> assert_safe Espec ge ve te k rho).

End SemaxContext.

Hint Resolve @age_laterR.

Fixpoint filter_seq (k: cont) : cont :=
 match k with
  | Kseq s :: k1 => filter_seq k1
  | _ => k
  end.

Lemma cons_app: forall A (x: A) (y: list A), x::y = (x::nil)++y.

Lemma cons_app': forall A (x:A) y z,
      x::y++z = (x::y)++z.

Lemma cat_prefix_empty:
   forall {A} prefix (ctl: list A), ctl =  prefix ++ ctl -> prefix = nil.

Definition true_expr : Clight.expr := Clight.Econst_int Int.one (Tint I32 Signed noattr).

Lemma dec_skip: forall s, {s=Sskip}+{s<>Sskip}.

Lemma strip_step:  
  forall ge ve te k m st' m',
     cl_step ge (State ve te (strip_skip k)) m st' m' =
    cl_step ge (State ve te k) m st' m'.

 Lemma strip_skip_app:
  forall k k', strip_skip k = nil -> strip_skip (k++k') = strip_skip k'.

Lemma strip_strip: forall k, strip_skip (strip_skip k) = strip_skip k.

Lemma strip_skip_app_cons:
 forall {k c l}, strip_skip k = c::l -> forall k', strip_skip  (k++k') = c::l++k'.

Lemma filter_seq_current_function:
  forall ctl1 ctl2, filter_seq ctl1 = filter_seq ctl2 ->
       current_function ctl1 = current_function ctl2.

Lemma filter_seq_call_cont:
  forall ctl1 ctl2, filter_seq ctl1 = filter_seq ctl2 -> call_cont ctl1 = call_cont ctl2.

Lemma call_cont_app_nil:
  forall l k, call_cont l = nil -> call_cont (l++k) = call_cont k.
Lemma call_cont_app_cons:
  forall l c l', call_cont l = c::l' -> forall k, call_cont (l++k) = c::l' ++ k.

Lemma and_FF : forall {A} `{ageable A} (P:pred A),
  P && FF = FF.

Lemma sepcon_FF : forall {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (P:pred A),
  (P * FF = FF)%pred.

Section extensions.

Lemma age1_resource_decay:
  forall jm jm', age jm jm' -> resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm').

Lemma safe_loop_skip:
  forall {Espec: OracleKind}
    ge ora ve te k m,
    jsafeN (@OK_spec Espec) ge (level m) ora
           (State ve te (Kseq (Sloop Clight.Sskip Clight.Sskip) :: k)) m.

Lemma safe_seq_skip {Espec: OracleKind} ge n ora ve te k m :
  jsafeN OK_spec ge n ora (State ve te k) m ->
  jsafeN OK_spec ge n ora (State ve te (Kseq Sskip :: k)) m.

Lemma safe_seq_skip' {Espec: OracleKind} ge n ora ve te k m :
  jsafeN OK_spec ge n ora (State ve te (Kseq Sskip :: k)) m ->
  jsafeN OK_spec ge n ora (State ve te k) m.

Lemma safe_step_forward {Espec: OracleKind}:
  forall psi n ora st m,
   cl_at_external st = None ->
   jsafeN (@OK_spec Espec) psi (S n) ora st m ->
 exists st', exists m',
   jstep (cl_core_sem psi) st m st' m' /\ jm_bupd ora (jsafeN (@OK_spec Espec) psi n ora  st') m'.

Lemma safeN_strip {Espec: OracleKind}:
  forall ge n ora ve te k m,
     jsafeN (@OK_spec Espec) ge n ora (State ve te (strip_skip k)) m =
     jsafeN (@OK_spec Espec) ge n ora (State ve te k) m.

Local Open Scope nat_scope.

Definition control_as_safe {Espec: OracleKind} ge n ctl1 ctl2 :=
 forall (ora : OK_ty) (ve : env) (te : temp_env) (m : juicy_mem) (n' : nat),
     n' <= n ->
     jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl1) m ->
     jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl2) m.

Fixpoint prebreak_cont (k: cont) : cont :=
  match k with
  | Kloop1 s e3 :: k' => k
  | Kseq s :: k' => prebreak_cont k'
  | Kloop2 s e3 :: k' => k
  | Kswitch :: k' => k
  | _ =>  nil 
  end.

Lemma prebreak_cont_is: forall k,
  match (prebreak_cont k) with
  | Kloop1 _ _ :: _ => True
  | Kloop2 _ _ :: _ => True
  | Kswitch :: _ => True
  | nil => True
  | _ => False
  end.

Lemma find_label_prefix:
  forall lbl s ctl k, find_label lbl s ctl = Some k -> exists j, k = j++ctl
with
  find_label_ls_prefix:
  forall lbl s ctl k, find_label_ls lbl s ctl = Some k -> exists j, k = j++ctl.

Lemma find_label_None:
  forall lbl s ctl, find_label lbl s ctl = None -> forall ctl', find_label lbl s ctl' = None
with
  find_label_ls_None:
  forall lbl s ctl, find_label_ls lbl s ctl = None ->  forall ctl', find_label_ls lbl s ctl' = None.

Lemma find_label_prefix2':
 forall lbl s k1 pre, find_label lbl s k1 = Some (pre++k1) ->
               forall k2, find_label lbl s k2 = Some (pre++k2)
with find_label_ls_prefix2':
 forall lbl s k1 pre, find_label_ls lbl s k1 = Some (pre++k1) ->
               forall k2, find_label_ls lbl s k2 = Some (pre++k2) .

Lemma find_label_prefix2:
  forall lbl s pre j ctl1 ctl2,
   find_label lbl s (pre++ctl1) = Some (j++ctl1) ->
   find_label lbl s (pre++ctl2) = Some (j++ctl2).

Lemma control_as_safe_bupd {Espec: OracleKind}: forall ge n ctl1 ctl2, control_as_safe ge n ctl1 ctl2 ->
 forall (ora : OK_ty) (ve : env) (te : temp_env) (m : juicy_mem) (n' : nat),
     n' <= n ->
     jm_bupd ora (jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl1)) m ->
     jm_bupd ora (jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl2)) m.

Lemma corestep_preservation_lemma {Espec: OracleKind}:
   forall ge ctl1 ctl2 ora ve te m n c l c' m',
       filter_seq ctl1 = filter_seq ctl2 ->
      (forall k : list cont', control_as_safe ge n (k ++ ctl1) (k ++ ctl2)) ->
      control_as_safe ge (S n) ctl1 ctl2 ->
      jstep (cl_core_sem ge) (State ve te (c :: l ++ ctl1)) m c' m' ->
      jm_bupd ora (jsafeN (@OK_spec Espec) ge n ora c') m' ->
   exists c2 : corestate,
     exists m2 : juicy_mem,
       jstep (cl_core_sem ge) (State ve te (c :: l ++ ctl2)) m c2 m2 /\
       jm_bupd ora (jsafeN (@OK_spec Espec) ge n ora c2) m2.

Lemma control_as_safe_le {Espec: OracleKind}:
  forall n' n ge ctl1 ctl2, n' <= n -> control_as_safe ge n ctl1 ctl2 -> control_as_safe ge n' ctl1 ctl2.

Lemma control_suffix_safe {Espec: OracleKind}:
    forall
      ge n ctl1 ctl2 k,
      filter_seq ctl1 = filter_seq ctl2 ->
      control_as_safe ge n ctl1 ctl2 ->
      control_as_safe ge n (k ++ ctl1) (k ++ ctl2).

Lemma guard_safe_adj {Espec: OracleKind}:
 forall
   psi Delta P k1 k2,
   current_function k1 = current_function k2 ->
  (forall ora m ve te n,
     jsafeN (@OK_spec Espec) psi n ora (State ve te k1) m ->
     jsafeN (@OK_spec Espec) psi n ora (State ve te k2) m) ->
  guard Espec psi Delta P k1 |-- guard Espec psi Delta P k2.

Lemma assert_safe_adj:
  forall {Espec: OracleKind} ge ve te k k' rho,
      (forall n, control_as_safe ge n k k') ->
     assert_safe Espec ge ve te k rho |-- assert_safe Espec ge ve te k' rho.

Lemma assert_safe_adj':
  forall {Espec: OracleKind} ge ve te k k' rho P w,
      (forall n, control_as_safe ge n k k') ->
     app_pred (P >=> assert_safe Espec ge ve te k rho) w ->
     app_pred (P >=> assert_safe Espec ge ve te k' rho) w.

Lemma rguard_adj:
  forall {Espec: OracleKind} ge Delta R k k',
      current_function k = current_function k' ->
      (forall ek vl n, control_as_safe ge n (exit_cont ek vl k) (exit_cont ek vl k')) ->
      rguard Espec ge Delta R k |-- rguard Espec ge Delta R k'.

Lemma assert_safe_last': forall {Espec: OracleKind} ge ve te ctl rho w,
            (age1 w <> None -> assert_safe Espec ge ve te ctl rho w) ->
             assert_safe Espec ge ve te ctl rho w.

Lemma pjoinable_emp_None {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall w: option (psepalg.lifted JA), identity w ->  w=None.

Lemma pjoinable_None_emp {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
           identity (None: option (psepalg.lifted JA)).

Lemma unage_mapsto:
  forall sh t v1 v2 w, age1 w <> None -> (|> mapsto sh t v1 v2) w -> mapsto sh t v1 v2 w.

Lemma semax_extensionality_Delta {CS: compspecs} {Espec: OracleKind}:
  forall Delta Delta' P c R,
       tycontext_sub Delta Delta' ->
     semax Espec Delta P c R -> semax Espec Delta' P c R.

End extensions.

Definition Cnot (e: Clight.expr) : Clight.expr :=
   Clight.Eunop Cop.Onotbool e type_bool.

Section statement_rect.
  Variable P : statement -> Type.
  Variable Q : labeled_statements -> Type.
  Variable f : P Sskip.
  Variable f0 : forall e e0 : expr, P (Sassign e e0).
  Variable f1 : forall (i : ident) (e : expr), P (Sset i e).
  Variable f2 : forall (o : option ident) (e : expr) (l : list expr), P (Scall o e l).
  Variable f3 : forall (o : option ident) (e : external_function) (t : typelist) (l : list expr), P (Sbuiltin o e t l).
  Variable f4 : forall s : statement, P s -> forall s0 : statement, P s0 -> P (Ssequence s s0).
  Variable f5 : forall (e : expr) (s : statement), P s -> forall s0 : statement, P s0 -> P (Sifthenelse e s s0).
  Variable f6 : forall s : statement, P s -> forall s0 : statement, P s0 -> P (Sloop s s0).
  Variable f7 : P Sbreak.
  Variable f8 : P Scontinue.
  Variable f9 : forall o : option expr, P (Sreturn o).
  Variable f10 : forall (e : expr) (l : labeled_statements), Q l -> P (Sswitch e l).
  Variable f11 : forall (l : label) (s : statement), P s -> P (Slabel l s).
  Variable f12 : forall l : label, P (Sgoto l).
  Variable f13 : Q LSnil.
  Variable f14 : forall (o : option Z) (s : statement) (l : labeled_statements), P s -> Q l -> Q (LScons o s l).

  Fixpoint statement_rect (s : statement) : P s :=
  match s as s0 return (P s0) with
  | Sskip => f
  | Sassign e e0 => f0 e e0
  | Sset i e => f1 i e
  | Scall o e l => f2 o e l
  | Sbuiltin o e t l => f3 o e t l
  | Ssequence s0 s1 => f4 s0 (statement_rect s0) s1 (statement_rect s1)
  | Sifthenelse e s0 s1 => f5 e s0 (statement_rect s0) s1 (statement_rect s1)
  | Sloop s0 s1 => f6 s0 (statement_rect s0) s1 (statement_rect s1)
  | Sbreak => f7
  | Scontinue => f8
  | Sreturn o => f9 o
  | Sswitch e l => f10 e l (labeled_statements_rect l)
  | Slabel l s0 => f11 l s0 (statement_rect s0)
  | Sgoto l => f12 l
  end
  with labeled_statements_rect (l : labeled_statements) : Q l :=
  match l as l0 return (Q l0) with
  | LSnil => f13
  | LScons o s l0 => f14 o s l0 (statement_rect s) (labeled_statements_rect l0)
  end.
End statement_rect.

Require Import VST.msl.eq_dec.

Section eq_dec.
  Local Ltac t := hnf; decide equality; auto.

  Let eq_dec_type := type_eq.
  Let eq_dec_float := Float.eq_dec.
  Let eq_dec_float32 := Float32.eq_dec.
  Let eq_dec_int := Int.eq_dec.
  Let eq_dec_int64 := Int64.eq_dec.
  Let eq_dec_ident := ident_eq.
  Let eq_dec_signature := signature_eq.
  Let eq_dec_signedness : EqDec signedness. t. Qed.
  Let eq_dec_floatsize : EqDec floatsize. t. Qed.
  Let eq_dec_calling_convention : EqDec calling_convention. repeat t. Qed.
  Let eq_dec_option_ident := option_eq (ident_eq).
  Let eq_dec_option_Z : EqDec (option Z). repeat t. Qed.

  Lemma eq_dec_expr : EqDec expr.

  Let eq_dec_expr := eq_dec_expr.
  Let eq_dec_option_expr : EqDec (option expr). repeat t. Qed.

  Local Ltac eq_dec a a' :=
    let H := fresh in
    assert (H : {a = a'} + {a <> a'}) by (auto; repeat (decide equality ; auto));
    destruct H; [subst; auto | try (right; congruence)].

  Lemma eq_dec_statement : forall s s' : statement, { s = s' } + { s <> s' }.

  Lemma eq_dec_labeled_statements : forall l l' : labeled_statements, { l = l' } + { l <> l' }.

End eq_dec.

Instance EqDec_statement: EqDec statement := eq_dec_statement.
Instance EqDec_external_function: EqDec external_function := eq_dec_external_function.

Lemma closed_Slabel l c F: closed_wrt_modvars (Slabel l c) F = closed_wrt_modvars c F.

Lemma closed_Sifthenelse b c1 c2 F: closed_wrt_modvars (Sifthenelse b c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Lemma closed_Sloop c1 c2 F: closed_wrt_modvars (Sloop c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Lemma closed_Ssequence c1 c2 F: closed_wrt_modvars (Ssequence c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Lemma closed_Sswitch e sl F:
  closed_wrt_modvars (Sswitch e sl) F ->
  (forall n, closed_wrt_modvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) F).

Lemma semax_eq:
 forall {CS: compspecs} {Espec: OracleKind} Delta P c R,
  semax Espec Delta P c R = 
  (TT |-- (ALL psi : genv,
         ALL Delta' : tycontext,
         !! (tycontext_sub Delta Delta' /\ genv_cenv psi = cenv_cs) -->
         believe Espec Delta' psi Delta' -->
         ALL k : cont ,
         ALL F : assert ,
         !! closed_wrt_modvars c F &&
         rguard Espec psi Delta' (frame_ret_assert R F) k -->
         guard Espec psi Delta' (fun rho : environ => F rho * P rho) (Kseq c :: k))).

Lemma safe_kseq_Slabel {Espec: OracleKind} psi n ora ve te l c k m :
  @jsafeN (@OK_ty Espec) (@OK_spec Espec) psi n ora
      (State ve te (@cons cont' (Kseq c) k)) m ->
@jsafeN (@OK_ty Espec) (@OK_spec Espec) psi n ora
  (State ve te (@cons cont' (Kseq (Slabel l c)) k)) m.

Lemma semax_Slabel {cs:compspecs} {Espec: OracleKind}
       (Gamma:tycontext) (P:environ -> mpred) (c:statement) (Q:ret_assert) l:
@semax cs Espec Gamma P c Q -> @semax cs Espec Gamma P (Slabel l c) Q.

Lemma denote_tc_resource: forall {cs: compspecs} rho a a' t, resource_at a = resource_at a' ->
  denote_tc_assert t rho a -> denote_tc_assert t rho a'.

Lemma bupd_denote_tc: forall {cs: compspecs} P t rho a,
  denote_tc_assert t rho a -> bupd P a -> bupd (denote_tc_assert t rho && P) a.

Lemma assert_safe_jsafe: forall {Espec: OracleKind} ge ve te ctl ora jm,
  assert_safe Espec ge ve te ctl (construct_rho (filter_genv ge) ve te) (m_phi jm) ->
  jm_bupd ora (jsafeN OK_spec ge (level jm) ora (State ve te ctl)) jm. *)

Require Import VST.veric.Clight_lemmas.
(* VST.veric.Clight_lemmas:
Require Import VST.veric.Clight_base.
Require Import compcert.cfrontend.Clight.

Definition var_name (V: Type) (bdec: ident * globvar V) : ident :=
   fst bdec.

Definition no_dups (F V: Type) (fdecs: list (ident * F)) (bdecs: list (ident * globvar V)) : Prop :=
  list_norepet (map (@fst ident F) fdecs ++ map (@var_name V) bdecs).
Arguments no_dups [F V] _ _.

Lemma no_dups_inv:
  forall  (A V: Type) id f fdecs bdecs,
    no_dups ((id,f)::fdecs) bdecs ->
    no_dups fdecs bdecs /\
     ~ In id (map (@fst ident A) fdecs) /\
     ~ In id (map (@var_name V) bdecs).
Arguments no_dups_inv [A V] _ _ _ _ _.

Lemma of_bool_Int_eq_e:
  forall i j, Val.of_bool (Int.eq i j) = Vtrue -> i = j.

Lemma eq_block_lem:
    forall (A: Set) a (b: A) c, (if eq_block a a then b else c) = b.

Lemma signed_zero: Int.signed Int.zero = 0.

Lemma equiv_e1 : forall A B: Prop, A=B -> A -> B.
Arguments equiv_e1 [A B] _ _.

Lemma deref_loc_fun: forall {ty m b z v v'},
   Clight.deref_loc ty m b z v -> Clight.deref_loc ty m b z v' -> v=v'.

Lemma eval_expr_lvalue_fun:
  forall ge e le m,
    (forall a v v', Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v') /\

Lemma eval_expr_fun:   forall {ge e le m a v v'},
    Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v'.

Lemma eval_exprlist_fun:   forall {ge e le m a ty v v'},
    Clight.eval_exprlist ge e le m a ty v -> Clight.eval_exprlist ge e le m a ty v' -> v=v'.

Lemma eval_lvalue_fun:   forall {ge e le m a b b' z z'},
    Clight.eval_lvalue ge e le m a b z -> Clight.eval_lvalue ge e le m a b' z' -> (b,z)=(b',z').

Lemma inv_find_symbol_fun:
  forall {ge id id' b},
    Senv.find_symbol ge id = Some b ->

Lemma assign_loc_fun:
  forall {cenv ty m b ofs v m1 m2},
   assign_loc cenv ty m b ofs v m1 ->
   assign_loc cenv ty m b ofs v m2 ->
   m1=m2.

Lemma alloc_variables_fun:
  forall {ge e m vl e1 m1 e2 m2},
     Clight.alloc_variables ge e m vl e1 m1 ->

Lemma bind_parameters_fun:
  forall {ge e m p v m1 m2},
    Clight.bind_parameters ge e m p v m1 ->

Lemma eventval_list_match_fun:
  forall {se a a' t v},
    Events.eventval_list_match se a t v ->

Ltac fun_tac :=
  match goal with
  | H: ?A = Some _, H': ?A = Some _ |- _ => inversion2 H H'
  | H: Clight.eval_expr ?ge ?e ?le ?m ?A _,
    H': Clight.eval_expr ?ge ?e ?le ?m ?A _ |- _ =>
        apply (eval_expr_fun H) in H'; subst
  | H: Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _,
    H': Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _ |- _ =>
        apply (eval_exprlist_fun H) in H'; subst
  | H: Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _,
    H': Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _ |- _ =>
        apply (eval_lvalue_fun H) in H'; inv H'
  | H: Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _,
    H': Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _ |- _ =>
        apply (assign_loc_fun H) in H'; inv H'
  | H: Clight.deref_loc ?ty ?m ?b ?ofs _,
    H': Clight.deref_loc ?ty ?m ?b ?ofs _ |- _ =>
        apply (deref_loc_fun H) in H'; inv H'
  | H: Clight.alloc_variables ?ge ?e ?m ?vl _ _,
    H': Clight.alloc_variables ?ge ?e ?m ?vl _ _ |- _ =>
        apply (alloc_variables_fun H) in H'; inv H'
  | H: Clight.bind_parameters ?ge ?e ?m ?p ?vl _,
    H': Clight.bind_parameters ?ge ?e ?m ?p ?vl _ |- _ =>
        apply (bind_parameters_fun H) in H'; inv H'
  | H: Senv.find_symbol ?ge _ = Some ?b,
    H': Senv.find_symbol ?ge _ = Some ?b |- _ =>
       apply (inv_find_symbol_fun H) in H'; inv H'
  | H: Events.eventval_list_match ?ge _ ?t ?v,
    H': Events.eventval_list_match ?ge _ ?t ?v |- _ =>
       apply (eventval_list_match_fun H) in H'; inv H'
 end. *)



Local Open Scope pred.

Section extensions.

Context {CS: compspecs} {Espec: OracleKind}.



Lemma opt2list_inj: forall A (a b: option A), opt2list a = opt2list b -> a=b.

Proof.

destruct a; destruct b; intros; inv H; auto.

Qed.



Lemma age_twin' {A B} `{HA: ageable A} `{HB: ageable B}:

  forall (x: A) (y: B) (x': A),

       level x = level y -> age x x' ->

       exists y', level x' = level y' /\ age y y'.

Proof.

intros x y x' H0 H1.

unfold fashionR in *.

destruct (age1_levelS _ _ H1) as [n ?].

rewrite H0 in H.

destruct (levelS_age1 _ _ H) as [y' ?].

exists y'; split.

apply age_level in H2.

apply age_level in H1.

congruence.

auto.

Qed.



Lemma later_twin' {A B} `{HA: ageable A} `{HB: ageable B}:

  forall (x: A) (y: B) (x': A),

       level x = level y -> laterR x x' ->

       exists y', level x' = level y' /\ laterR y y'.

Proof.

intros x y x' H0 H1.

revert y H0; induction H1; intros.

destruct (age_twin' _ _ _ H0 H) as [y' [? ?]].

exists y'; split; auto.

specialize (IHclos_trans1 _ H0).

destruct IHclos_trans1 as [y2 [? ?]].

specialize (IHclos_trans2 _ H).

destruct IHclos_trans2 as [u [? ?]].

exists u; split; auto.

apply t_trans with y2; auto.

Qed.



Lemma later_twin {A} `{ageable A}:

   forall phi1 phi2 phi1',

     level phi1 = level phi2 ->

     laterR phi1 phi1' ->

     exists phi2', level phi1' = level phi2' /\ laterR phi2 phi2'.

Proof.

intros.

eapply later_twin'; eauto.

Qed.



Lemma someP_inj:  forall A P Q, SomeP A P = SomeP A Q -> P=Q.

Proof. intros. injection H; intro. apply inj_pair2 in H0. auto. Qed.



Lemma function_pointer_aux:

  forall A P P' Q Q' (w: rmap),

    super_non_expansive P ->

    super_non_expansive Q ->

    super_non_expansive P' ->

    super_non_expansive Q' ->

   SomeP (SpecTT A) (fmap (fpi _) (approx (level w)) (approx (level w)) (packPQ P Q)) =

   SomeP (SpecTT A) (fmap (fpi _) (approx (level w)) (approx (level w)) (packPQ P' Q')) ->

   ( (forall ts x vl, (! |> (P' ts x vl <=> P ts x vl)) w) /\

     (forall ts x vl, (! |> (Q' ts x vl <=> Q ts x vl)) w)).

Proof.

  intros ? ? ? ? ? ? NEP NEQ NEP' NEQ' H.

  apply someP_inj in H.

  unfold packPQ in H; simpl in H.

  split; intros.

  + apply equal_f_dep with ts in H.

    apply equal_f with x in H.

    apply equal_f with true in H.

    apply equal_f with vl in H.

    simpl in H.

    rewrite @later_fash; auto with typeclass_instances.

    intros ? ? m' ?.

    assert (forall m'', necR m' m'' -> (level m'' < level w)%nat).

    {

      intros.

      clear - H0 H1 H2; hnf in H1.

      apply laterR_level in H1.

      apply necR_level in H2; simpl in *.

      omega.

    }

    split; intros m'' ? ?.

    - apply f_equal with (f:= fun x => app_pred x m'') in H.

      apply prop_unext in H.

      apply approx_p with (level w).

      rewrite NEP.

      apply H.

      rewrite <- NEP'.

      apply approx_lt; auto.

    - apply f_equal with (f:= fun x => app_pred x m'') in H.

      apply prop_unext in H.

      apply approx_p with (level w).

      rewrite NEP'.

      apply H.

      rewrite <- NEP.

      apply approx_lt; auto.

  + apply equal_f_dep with ts in H.

    apply equal_f with x in H.

    apply equal_f with false in H.

    apply equal_f with vl in H.

    simpl in H.

    rewrite @later_fash; auto with typeclass_instances; intros ? ? m' ?.

    assert (forall m'', necR m' m'' -> (level m'' < level w)%nat).

    {

      intros.

      clear - H0 H1 H2; hnf in H1.

      apply laterR_level in H1.

      apply necR_level in H2; simpl in *.

      omega.

    }

    split; intros m'' ? ?.

    - apply f_equal with (f:= fun x => app_pred x m'') in H.

      apply prop_unext in H.

      apply approx_p with (level w).

      rewrite NEQ.

      apply H.

      rewrite <- NEQ'.

     apply approx_lt; auto.

    - apply f_equal with (f:= fun x => app_pred x m'') in H.

      apply prop_unext in H.

      apply approx_p with (level w).

      rewrite NEQ'.

      apply H.

      rewrite <- NEQ.

     apply approx_lt; auto.

Qed.



Import JuicyMemOps.



Fixpoint alloc_juicy_variables (ge: genv) (rho: env) (jm: juicy_mem) (vl: list (ident*type)) : env * juicy_mem :=

 match vl with

 | nil => (rho,jm)

 | (id,ty)::vars => match JuicyMemOps.juicy_mem_alloc jm 0 (@sizeof ge ty) with

                              (m1,b1) => alloc_juicy_variables ge (PTree.set id (b1,ty) rho) m1 vars

                           end

 end.



Lemma juicy_mem_alloc_core:

  forall jm lo hi jm' b, JuicyMemOps.juicy_mem_alloc jm lo hi = (jm', b) ->

    core (m_phi jm) = core (m_phi jm').

Proof.

 unfold JuicyMemOps.juicy_mem_alloc, after_alloc; intros.

 inv H.

 simpl.

 apply rmap_ext.

 repeat rewrite level_core. rewrite level_make_rmap. auto.

 intro loc.

 repeat rewrite <- core_resource_at.

 rewrite resource_at_make_rmap.

 unfold after_alloc'.

 if_tac; auto.

 destruct loc as [b z].

 simpl in H.

 rewrite core_YES.

 rewrite juicy_mem_alloc_cohere. rewrite core_NO; auto.

 simpl. destruct H.

 revert H; case_eq (alloc (m_dry jm) lo hi); intros.

 simpl in *. subst b0. apply alloc_result in H. subst b; xomega.

 rewrite <- (core_ghost_of (proj1_sig _)), ghost_of_make_rmap, core_ghost_of; auto.

Qed.



Lemma alloc_juicy_variables_e:

  forall ge rho jm vl rho' jm',

    alloc_juicy_variables ge rho jm vl = (rho', jm') ->

  Clight.alloc_variables ge rho (m_dry jm) vl rho' (m_dry jm')

   /\ level jm = level jm'

   /\ core (m_phi jm) = core (m_phi jm').

Proof.

 intros.

 revert rho jm H; induction vl; intros.

 inv H. split; auto. constructor.

 unfold alloc_juicy_variables in H; fold alloc_juicy_variables in H.

 destruct a as [id ty].

 revert H; case_eq (JuicyMemOps.juicy_mem_alloc jm 0 (@sizeof ge ty)); intros jm1 b1 ? ?.

 specialize (IHvl (PTree.set id (b1,ty) rho) jm1 H0).

 destruct IHvl as [? [? ?]]; split3; auto.

 apply alloc_variables_cons  with  (m_dry jm1) b1; auto.

 apply JuicyMemOps.juicy_mem_alloc_succeeds in H. auto.

 apply JuicyMemOps.juicy_mem_alloc_level in H.

 congruence.

 rewrite <- H3.

 eapply  juicy_mem_alloc_core; eauto.

Qed.



Lemma alloc_juicy_variables_match_venv:

  forall ge jm vl ve' jm',

     alloc_juicy_variables ge empty_env jm vl = (ve',jm') ->

     match_venv (make_venv ve') vl.

Proof.

intros.

  intro i.

 unfold make_venv.

  destruct (ve' ! i) as [[? ?] | ] eqn:?; auto.

  assert (H0: (exists b, empty_env ! i = Some (b,t)) \/ In (i,t) vl).

2: destruct H0; auto; destruct H0; rewrite PTree.gempty in H0; inv H0.

 forget empty_env as e.

  revert jm e H; induction vl; simpl; intros.

  inv H.

  left; eexists; eauto.

  destruct a.

  apply IHvl in H; clear IHvl.

 destruct (ident_eq i0 i). subst i0.

 destruct H; auto. destruct H as [b' ?].

 rewrite PTree.gss in H. inv H. right. auto.

 destruct H; auto. left. destruct H as [b' ?].

 rewrite PTree.gso in H by auto. eauto.

Qed.



Lemma build_call_temp_env:

  forall f vl,

     length (fn_params f) = length vl ->

  exists te,  bind_parameter_temps (fn_params f) vl

                     (create_undef_temps (fn_temps f)) = Some te.

Proof.

 intros.

 forget (create_undef_temps (fn_temps f)) as rho.

 revert rho vl H; induction (fn_params f); destruct vl; intros; inv H; try congruence.

 exists rho; reflexivity.

 destruct a; simpl.

 apply IHl. auto.

Qed.



Lemma resource_decay_funassert:

  forall G rho b w w',

         necR (core w) (core w') ->

         resource_decay b w w' ->

         app_pred (funassert G rho) w ->

         app_pred (funassert G rho) w'.

Proof.

unfold resource_decay, funassert; intros until w'; intro CORE; intros.

destruct H.

destruct H0.

split; [clear H2 | clear H0].

intros id fs w2 Hw2 H3.

specialize (H0 id fs). cbv beta in H0.

specialize (H0 _ (necR_refl _) H3).

destruct H0 as [loc [? ?]].

exists loc; split; auto.

destruct fs as [f cc A a a0].

simpl in H2|-*.

pose proof (necR_resource_at (core w) (core w') (loc,0)

         (PURE (FUN f cc) (SomeP (SpecTT A) (packPQ a a0))) CORE).

pose proof (necR_resource_at _ _ (loc,0)

         (PURE (FUN f cc) (SomeP (SpecTT A) (packPQ a a0))) Hw2).

apply H5.

clear - H4 H2.

repeat rewrite <- core_resource_at in *.

spec H4. rewrite H2.  rewrite core_PURE.  simpl.  rewrite level_core; reflexivity.

destruct (w' @ (loc,0)).

 rewrite core_NO in H4; inv H4.

 rewrite core_YES in H4; inv H4.

 rewrite core_PURE in H4; inv H4. rewrite level_core; reflexivity.



intros loc fs w2 Hw2 H6.

specialize (H2 loc fs _ (necR_refl _)).

spec H2.

clear - Hw2 CORE H6.

destruct fs; simpl in *.

destruct H6 as [pp H6].

 rewrite <- resource_at_approx.

case_eq (w @ (loc,0)); intros.

assert (core w @ (loc,0) = resource_fmap (approx (level (core w))) (approx (level (core w))) (NO _ bot_unreadable)).

 rewrite <- core_resource_at.

simpl; erewrite <- core_NO; f_equal; eassumption.

pose proof (necR_resource_at _ _ _ _ CORE H0).

pose proof (necR_resource_at _ _ _ _ (necR_core _ _ Hw2) H1).

rewrite <- core_resource_at in H2; rewrite H6 in H2;

 rewrite core_PURE in H2; inv H2.

assert (core w @ (loc,0) = resource_fmap (approx (level (core w))) (approx (level (core w))) (NO _ bot_unreadable)).

 rewrite <- core_resource_at.

simpl; erewrite <- core_YES; f_equal; eassumption.

pose proof (necR_resource_at _ _ _ _ CORE H0).

pose proof (necR_resource_at _ _ _ _ (necR_core _ _ Hw2) H1).

rewrite <- core_resource_at in H2; rewrite H6 in H2;

 rewrite core_PURE in H2; inv H2.

pose proof (resource_at_approx w (loc,0)).

pattern (w @ (loc,0)) at 1 in H0; rewrite H in H0.

symmetry in H0.

assert (core (w @ (loc,0)) = core (resource_fmap (approx (level w)) (approx (level w))

       (PURE k p))) by (f_equal; auto).

rewrite core_resource_at in H1.

assert (core w @ (loc,0) =

        resource_fmap (approx (level (core w))) (approx (level (core w)))

         (PURE k p)).

 rewrite H1.  simpl. rewrite level_core; rewrite core_PURE; auto.

pose proof (necR_resource_at _ _ _ _ CORE H2).

 assert (w' @ (loc,0) = resource_fmap

       (approx (level w')) (approx (level w')) (PURE k p)).

 rewrite <- core_resource_at in H3. rewrite level_core in H3.

 destruct (w' @ (loc,0)).

  rewrite core_NO in H3; inv H3.

  rewrite core_YES in H3; inv H3.

  rewrite core_PURE in H3; inv H3.

 reflexivity.

 pose proof (necR_resource_at _ _ _ _ Hw2 H4).

 inversion2 H6 H5.

 exists p. reflexivity.

 

destruct H2 as [id [? ?]].

exists id. split; auto.

Qed.



Definition substopt {A} (ret: option ident) (v: val) (P: environ -> A)  : environ -> A :=

   match ret with

   | Some id => subst id v P

   | None => P

   end.



Lemma fst_split {T1 T2}: forall vl: list (T1*T2), fst (split vl) = map fst vl.

Proof. induction vl; try destruct a; simpl; auto.

  rewrite <- IHvl; clear IHvl.

 destruct (split vl); simpl in *; auto.

Qed.



Lemma snd_split {T1 T2}: forall vl: list (T1*T2), snd (split vl) = map snd vl.

Proof. induction vl; try destruct a; simpl; auto.

  rewrite <- IHvl; clear IHvl.

 destruct (split vl); simpl in *; auto.

Qed.



Lemma eval_exprlist_relate:

  forall (Delta : tycontext) (fsig0 : funsig)

     (bl : list expr) (psi : genv) (vx : env) (tx : temp_env)

     (rho : environ) m,

   denote_tc_assert (typecheck_exprlist Delta (snd (split (fst fsig0))) bl) rho (m_phi m) ->

   typecheck_environ Delta rho ->

   genv_cenv psi = cenv_cs ->

   rho = construct_rho (filter_genv psi) vx tx ->

   forall f : function,

   fsig0 = fn_funsig f ->

   Clight.eval_exprlist psi vx tx (m_dry m) bl

     (type_of_params (fn_params f))

     (eval_exprlist (snd (split (fst fsig0))) bl rho).

Proof.

  intros.

  destruct fsig0. unfold fn_funsig in *. inversion H3; clear H3; subst l t. simpl in *.

  forget (fn_params f) as vl.

  forget (fn_temps f) as tl.

  clear f.

  clear - H0 H1 H2 H.



 rewrite snd_split. rewrite snd_split in H.

 assert (length (map snd vl) = length bl).

 apply tc_exprlist_length in H; auto.

 revert vl H H3; induction bl; destruct vl; intros; inv H3; simpl.

 constructor.

 destruct p. simpl in *; subst.

 rewrite !denote_tc_assert_andp in H.

 super_unfold_lift.

 destruct H as [[? ?] ?].

 specialize (IHbl _ H3 H5).

 clear - IHbl H3 H H0 H1 H2.

 constructor 2 with (eval_expr a (construct_rho (filter_genv psi) vx tx)); auto.

 eapply eval_expr_relate; eauto.

 pose proof (cast_exists Delta a _ _ _ H0 H H2).

 forget (force_val

          (sem_cast (typeof a) t

             (eval_expr a

                (construct_rho (filter_genv psi) vx tx)))) as v.

 rewrite cop2_sem_cast'; try eassumption.

 eapply typecheck_expr_sound; eassumption.

Qed.



Lemma bind_parameter_temps_excludes :

forall l1 l2 t id t1,

~In id (map fst l1) ->

(bind_parameter_temps l1 l2 t) = Some t1 ->

t1 ! id = t ! id.

Proof.

induction l1;

intros.

simpl in *. destruct l2; inv H0. auto.

simpl in H0. destruct a. destruct l2; inv H0.

specialize (IHl1 l2 (PTree.set i v t) id t1).

simpl in H. intuition. rewrite PTree.gsspec in H3.

destruct (peq id i). subst; intuition. auto.

Qed.



Lemma pass_params_ni :

  forall  l2

     (te' : temp_env) (id : positive) te l,

   bind_parameter_temps l2 l (te) = Some te' ->

   (In id (map fst l2) -> False) ->

   Map.get (make_tenv te') id = te ! id.

Proof.

intros. eapply bind_parameter_temps_excludes in H.

unfold make_tenv, Map.get.

apply H. intuition.

Qed.



Lemma bind_exists_te : forall l1 l2 t1 t2 te,

bind_parameter_temps l1 l2 t1 = Some te ->

exists te2, bind_parameter_temps l1 l2 t2 = Some te2.

Proof.

induction l1; intros.

+ simpl in H. destruct l2; inv H. simpl. eauto.



+ destruct a. simpl in *. destruct l2; inv H. eapply IHl1.

apply H1.

Qed.



Lemma smaller_temps_exists2 : forall l1 l2 t1 t2 te te2 i,

bind_parameter_temps l1 l2 t1 = Some te ->

bind_parameter_temps l1 l2 t2 = Some te2 ->

t1 ! i = t2 ! i ->

te ! i = te2 ! i.

Proof.

induction l1; intros; simpl in *; try destruct a; destruct l2; inv H; inv H0.

apply H1.

eapply IHl1. apply H3. apply H2.

repeat rewrite PTree.gsspec. destruct (peq i i0); auto.

Qed.



Lemma smaller_temps_exists' : forall l l1 te te' id i t,

bind_parameter_temps l l1 (PTree.set id Vundef t)=  Some te ->

i <> id ->

(bind_parameter_temps l l1 t = Some te') -> te' ! i = te ! i.

Proof.

induction l; intros.

simpl in *. destruct l1; inv H. inv H1. rewrite PTree.gso; auto.



simpl in *. destruct a. destruct l1; inv H.

eapply smaller_temps_exists2. apply H1. apply H3.

intros. repeat rewrite PTree.gsspec. destruct (peq i i0); auto.

destruct (peq i id). subst. intuition. auto.

Qed.



Lemma smaller_temps_exists'' : forall l l1 te id i t,

bind_parameter_temps l l1 (PTree.set id Vundef t)=  Some te ->

i <> id ->

exists te', (bind_parameter_temps l l1 t = Some te').

Proof.

intros.

eapply bind_exists_te; eauto.

Qed.



Lemma smaller_temps_exists : forall l l1 te id i t,

bind_parameter_temps l l1 (PTree.set id Vundef t)=  Some te ->

i <> id ->

exists te', (bind_parameter_temps l l1 t = Some te' /\ te' ! i = te ! i).

Proof.

intros. copy H. eapply smaller_temps_exists'' in H; eauto.

destruct H. exists x. split. auto.

eapply smaller_temps_exists'; eauto.

Qed.



Lemma alloc_vars_lookup :

forall ge id m1 l ve m2 e ,

list_norepet (map fst l) ->

(forall i, In i (map fst l) -> e ! i = None) ->

Clight.alloc_variables ge (e) m1 l ve m2 ->

(exists v, e ! id = Some v) ->

ve ! id = e ! id.

Proof.

intros.

generalize dependent e.

revert ve m1 m2.



induction l; intros.

inv H1. auto.



inv H1. simpl in *. inv H.

destruct H2.

assert (id <> id0).

intro. subst.  specialize (H0 id0). spec H0. auto. congruence.

eapply IHl in H10.

rewrite PTree.gso in H10; auto.

auto. intros. rewrite PTree.gsspec. if_tac. subst. intuition.

apply H0. auto.

rewrite PTree.gso; auto. eauto.

Qed.



Lemma alloc_vars_lemma : forall ge id l m1 m2 ve ve'

(SD : forall i, In i (map fst l) -> ve ! i = None),

list_norepet (map fst l) ->



Clight.alloc_variables ge ve m1 l ve' m2 ->

(In id (map fst l) ->

exists v, ve' ! id = Some v).

Proof.

intros.

generalize dependent ve.

revert m1 m2.

induction l; intros. inv H1.

simpl in *. destruct a; simpl in *.

destruct H1. subst. inv H0. inv H.  apply alloc_vars_lookup with (id := id) in H9; auto.

rewrite H9. rewrite PTree.gss. eauto. intros.

destruct (peq i id). subst. intuition. rewrite PTree.gso; auto.

rewrite PTree.gss; eauto.



inv H0. apply IHl in H10; auto. inv H; auto.

intros. rewrite PTree.gsspec. if_tac. subst. inv H. intuition.

auto.

Qed.



Lemma semax_call_typecheck_environ:

  forall (Delta : tycontext) (bl : list expr) (psi : genv) (vx : env) (tx : temp_env)

           (jm : juicy_mem) (b : block) (f : function)

     (H17 : list_norepet (map fst (fn_params f) ++ map fst (fn_temps f)))

     (H17' : list_norepet (map fst (fn_vars f)))

     (H16 : Genv.find_funct_ptr psi b = Some (Internal f))

     (ve' : env) (jm' : juicy_mem) (te' : temp_env)

     (H15 : alloc_variables psi empty_env (m_dry jm) (fn_vars f) ve' (m_dry jm'))

    (TC3 : typecheck_temp_environ (make_tenv tx) (temp_types Delta))

    (TC4 : typecheck_var_environ (make_venv vx) (var_types Delta))

    (TC5 : typecheck_glob_environ (filter_genv psi) (glob_types Delta))

   (H : forall (b : ident) (b0 : funspec) (a' : rmap),

    necR (m_phi jm') a' ->

    (glob_specs Delta) ! b = Some b0 ->



    exists b1 : block,

        filter_genv psi b = Some b1 /\

        func_at b0 (b1,0) a')

    (H1: forall (b : block) (b0 : funspec) (a' : rmap),

     necR (m_phi jm') a' ->

     (func_at' b0 (b, 0)) a' ->

     exists (b1 : ident),

       filter_genv psi b1 = Some b /\

       (exists fs : funspec, (glob_specs Delta) ! b1 = Some fs))

   (l : list ident) (l0 : list type)

    (Heqp : (l, l0) = split (fn_params f))

   (TC2 : denote_tc_assert (typecheck_exprlist Delta l0 bl)

        (mkEnviron (filter_genv psi) (make_venv vx) (make_tenv tx)) (m_phi jm)) 

   (H21 : bind_parameter_temps (fn_params f)

        (eval_exprlist l0 bl

           (mkEnviron (filter_genv psi) (make_venv vx) (make_tenv tx)))

        (create_undef_temps (fn_temps f)) = Some te')

   (TE : typecheck_environ

        Delta (mkEnviron (filter_genv psi) (make_venv vx) (make_tenv tx))),

   typecheck_environ

    (mk_tycontext

      (make_tycontext_t (fn_params f) (fn_temps f))

      (make_tycontext_v (fn_vars f))

      (fn_return f)  (glob_types Delta) (glob_specs Delta) (annotations Delta))

     (mkEnviron (filter_genv psi) (make_venv ve') (make_tenv te')).

Proof.

 intros.

 pose (rho3 := mkEnviron (filter_genv psi) (make_venv ve') (make_tenv te')).



unfold typecheck_environ. repeat rewrite andb_true_iff.

split3.

*

clear H H1 H15.

unfold typecheck_temp_environ in *. intros. simpl.

unfold temp_types in *. simpl in *.

apply func_tycontext_t_sound in H; auto.

 clear - H21 H TC2 TC3 Heqp H17 TE.



destruct H. 

forget (create_undef_temps (fn_temps f)) as temps.

generalize dependent temps.

generalize dependent l. generalize dependent l0.

generalize dependent bl. generalize dependent te'.

{  induction (fn_params f); intros.

   + inv H.

   + simpl in *.

     destruct a. simpl in *. remember (split l). destruct p.

     simpl in *. destruct H.

      - clear IHl. destruct bl. inv H.  inv Heqp. inv TC2.

        inv H. inv Heqp. simpl in *.

        rewrite !denote_tc_assert_andp in TC2.

        simpl in *; super_unfold_lift.

        destruct TC2 as [[? ?] ?].

        rewrite (pass_params_ni _ _ id _ _ H21) by (inv H17; contradict H4; apply in_app; auto).

        rewrite PTree.gss.

        eexists.  split. reflexivity. apply tc_val_tc_val'.

        eapply tc_val_sem_cast; eauto.

      - inv Heqp. destruct bl. inv TC2. inv H17. simpl in TC2.

        repeat (rewrite tc_andp_sound in TC2; simpl in TC2; super_unfold_lift).

        destruct TC2 as [[? ?] ?]. assert (i <> id). intro. subst.

        apply H2. apply in_or_app. left. apply in_map with (f := fst) in H. apply H.

        remember (eval_exprlist (t :: l3) (e :: bl)

            (mkEnviron (filter_genv psi) (make_venv vx) (make_tenv tx))).

        destruct l0; inv H21. simpl in Heql0.

        super_unfold_lift. inv Heql0.

        eapply IHl; eauto.

}



apply list_norepet_app in H17. destruct H17 as [? [? ?]].

generalize dependent (fn_params f). generalize dependent bl.

generalize dependent l0. generalize dependent l. generalize dependent te'.



induction (fn_temps f); intros.

inv H.



simpl in *. destruct H. destruct a. inv H. simpl in *.

clear IHl. exists Vundef. simpl in *. split; [| hnf; congruence]. inv H1.

assert (In id (map fst (l2)) -> False).

intros.

unfold list_disjoint in *. eapply H2. eauto. left. auto. auto.

eapply pass_params_ni with (id := id) in H21; auto.  rewrite PTree.gss in *. auto.



destruct a.

destruct (peq id i). subst.

apply pass_params_ni with (id := i) in H21.

rewrite PTree.gss in *. exists Vundef. split; [auto | hnf; congruence].

intros. unfold list_disjoint in *. intuition.

eapply H2. eauto. left. auto. auto.



apply smaller_temps_exists with (i := id) in H21.

destruct H21.  destruct H3.

eapply IHl in H3; auto.

destruct H3. destruct H3.

exists x0. split. unfold Map.get in *.

unfold make_tenv in *. rewrite <- H4. auto. auto.

inv H1; auto. unfold list_disjoint in *. intros.

apply H2. auto. right. auto. apply Heqp. auto.

*



simpl in *.

unfold typecheck_var_environ in *. intros.

clear TC3 TC5.

simpl in *. unfold typecheck_var_environ in *.

unfold func_tycontext' in *. unfold var_types in *.

simpl in *.

rewrite (func_tycontext_v_sound (fn_vars f) id ty); auto.

transitivity ((exists b, empty_env ! id = Some (b,ty) )\/ In (id,ty) (fn_vars f)).

clear; intuition. destruct H0. unfold empty_env in H.

rewrite PTree.gempty in H; inv H.

generalize dependent (m_dry jm).

clear - H17'.

assert (forall id, empty_env ! id <> None -> ~ In id (map fst (fn_vars f))).

intros. unfold empty_env in H. rewrite PTree.gempty in H. contradiction H; auto.

generalize dependent empty_env.

unfold Map.get, make_venv.

induction (fn_vars f); intros.

inv H15.

destruct (ve' ! id); intuition.

inv H15.

inv H17'.

specialize (IHl H3); clear H3.

specialize (IHl (PTree.set id0 (b1,ty0) e)).

spec IHl.

intros id' H8; specialize (H id').

destruct (ident_eq id0 id'). subst. auto.

rewrite PTree.gso  in H8 by auto.

specialize (H H8). contradict H.

right; auto.

specialize (IHl _ H7).

clear - H H2 IHl.

destruct (ident_eq id0 id). subst id0.

rewrite PTree.gss in IHl.

split; intro.

destruct H0.

destruct H0. specialize (H id).

destruct (e!id); try discriminate.

inv H0.

spec H; [congruence | ].

contradiction H. left; auto.

destruct H0. inv H0.

apply IHl. left; eauto.

contradiction H2. apply in_map with (f:=fst) in H0. apply H0.

rewrite <- IHl in H0.

destruct H0.

destruct H0. inv H0. right; left; auto.

contradiction H2.

apply in_map with (f:=fst) in H0. auto.

rewrite PTree.gso in IHl by auto.

rewrite <- IHl.

intuition. inv H5. inv H0. intuition.

apply H4 in H0. apply H1; auto.

*

unfold ge_of in *. simpl in *. auto.

Qed.



Lemma free_juicy_mem_level:

  forall jm m b lo hi H, level (free_juicy_mem jm m b lo hi H) = level jm.

Proof.

 intros;  simpl;  unfold inflate_free; simpl.

 rewrite level_make_rmap. auto.

Qed.



Lemma free_juicy_mem_ghost:

  forall jm m b lo hi H,

    ghost_of (m_phi (free_juicy_mem jm m b lo hi H)) = ghost_of (m_phi jm).

Proof.

 intros;  simpl;  unfold inflate_free; simpl.

 rewrite ghost_of_make_rmap. auto.

Qed.



Lemma free_list_free:

  forall m b lo hi l' m',

       free_list m ((b,lo,hi)::l') = Some m' ->

         {m2 | free m b lo hi = Some m2 /\ free_list m2 l' = Some m'}.

Proof.

simpl; intros.

 destruct (free m b lo hi). eauto. inv H.

Qed.



Definition freeable_blocks: list (block * BinInt.Z * BinInt.Z) -> mpred :=

  fold_right (fun (bb: block*BinInt.Z * BinInt.Z) a => 

                        match bb with (b,lo,hi) => 

                                          sepcon (VALspec_range (hi-lo) Share.top (b,lo)) a

                        end)

                    emp.



Inductive free_list_juicy_mem:

      forall  (jm: juicy_mem) (bl: list (block * BinInt.Z * BinInt.Z))

                                         (jm': juicy_mem), Prop :=

| FLJM_nil: forall jm, free_list_juicy_mem jm nil jm

| FLJM_cons: forall jm b lo hi bl jm2 jm'

                          (H: free (m_dry jm) b lo hi = Some (m_dry jm2))

                          (H0 : forall ofs : Z,

                        lo <= ofs < hi ->

                        perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),

                          free_juicy_mem jm (m_dry jm2) b lo hi H = jm2 ->

                          free_list_juicy_mem jm2 bl jm' ->

                          free_list_juicy_mem jm ((b,lo,hi)::bl) jm'.



Lemma perm_of_res_val : forall r, perm_of_res r = Some Freeable ->

  exists v pp, r = YES Share.top readable_share_top (VAL v) pp.

Proof.

  destruct r; simpl; try if_tac; try discriminate.

  destruct k; try discriminate.

  unfold perm_of_sh.

  repeat if_tac; try discriminate.

  subst; intro; do 2 eexists; f_equal.

  apply proof_irr.

Qed.



Lemma free_list_juicy_mem_i:

  forall jm bl m' F,

   free_list (m_dry jm) bl = Some m' ->

   app_pred (freeable_blocks bl * F) (m_phi jm) ->

   exists jm', free_list_juicy_mem jm bl jm'

                  /\ m_dry jm' = m'

                  /\ level jm = level jm'.

Proof.

intros jm bl; revert jm; induction bl; intros.

*

 inv H; exists jm; split3; auto. constructor.

*

 simpl freeable_blocks in H0. destruct a as [[b lo] hi].

 rewrite sepcon_assoc in H0.

 destruct (free_list_free _ _ _ _ _ _ H) as [m2 [? ?]].

 generalize H0; intro H0'.

 destruct H0 as [phi1 [phi2 [? [? H6]]]].



 assert (H10:= @juicy_free_lemma' jm b lo hi m2 phi1 _ _ H1 H0' H3 H0).

 match type of H10 with m_phi ?A = _ => set (jm2:=A) in H10 end; subst.



 specialize (IHbl  jm2 m' F H2 H6).

 destruct IHbl as [jm' [? [? ?]]].

 exists jm'; split3; auto.

 apply (FLJM_cons jm b lo hi bl jm2 jm' H1

   (juicy_free_aux_lemma (m_phi jm) b lo hi (freeable_blocks bl * F) H0') (eq_refl _) H4).

 rewrite <- H7.

 unfold jm2.

 symmetry; apply free_juicy_mem_level.

Qed.



Lemma free_juicy_mem_ext:

  forall jm1 jm2 b lo hi m1 m2 H1 H2,

      jm1=jm2 -> m1=m2 ->

     free_juicy_mem jm1 m1 b lo hi H1 = free_juicy_mem jm2 m2 b lo hi H2.

Proof.

intros. subst. proof_irr. auto.

Qed.



Lemma free_list_juicy_mem_lem:

  forall P jm bl jm',

     free_list_juicy_mem jm bl jm' ->

     app_pred (freeable_blocks bl * P) (m_phi jm) ->

     app_pred P (m_phi jm').

Proof.

 intros.

 revert H0; induction H; simpl freeable_blocks.

 intros.  rewrite emp_sepcon in H0; auto.

 rename H0 into H99. rename H1 into H0; rename H2 into H1.

 intro.

 rewrite sepcon_assoc in H2.

 generalize H2; intro H2'.

 destruct H2 as [phi1 [phi2 [? [? ?]]]].

 apply IHfree_list_juicy_mem.

 pose proof  (@juicy_free_lemma' jm b lo hi _ phi1 _ _ H H2' H3 H2).

 match type of H5 with m_phi ?A = _ => set (jm3 := A) in H5 end.

 replace jm2 with jm3 by (subst jm3; rewrite <- H0; apply free_juicy_mem_ext; auto).

 subst; auto.

Qed.



Lemma xelements_app:

 forall A (rho: PTree.t A) i al bl,

    PTree.xelements rho i al ++ bl = PTree.xelements rho i (al++bl).

Proof.

 induction rho; simpl; intros; auto.

 destruct o; simpl.

 rewrite IHrho1. simpl. rewrite IHrho2; auto.

 rewrite IHrho1. simpl. rewrite IHrho2; auto.

Qed.



Lemma PTree_elements_remove: forall {A} (T: PTree.tree A) i e,

  In e (PTree.elements (PTree.remove i T)) ->

  In e (PTree.elements T) /\ fst e <> i.

Proof.

  intros.

  destruct e as [i0 v0].

  apply PTree.elements_complete in H.

  destruct (peq i0 i).

  + subst.

    rewrite PTree.grs in H.

    inversion H.

  + rewrite PTree.gro in H by auto.

    split; [| simpl; auto].

    apply PTree.elements_correct.

    auto.

Qed.



Lemma stackframe_of_freeable_blocks:

  forall Delta f rho ge ve,

      genv_cenv ge = cenv_cs ->

      Forall (fun it => complete_type cenv_cs (snd it) = true) (fn_vars f) ->

      list_norepet (map fst (fn_vars f)) ->

      ve_of rho = make_venv ve ->

      guard_environ (func_tycontext' f Delta) (Some f) rho ->

       stackframe_of f rho |-- freeable_blocks (blocks_of_env ge ve).

Proof.

  intros until ve.

  intros HGG COMPLETE.

 intros.

 destruct H1. destruct H2 as [H7 _].

 unfold stackframe_of.

 unfold func_tycontext' in H1.

 unfold typecheck_environ in H1.

 destruct H1 as [_ [?  _]].

 rewrite H0 in H1.

 unfold make_venv in H1.

 unfold var_types in H1.

 simpl in H1. unfold make_tycontext_v in H1.

 unfold blocks_of_env.

match goal with |- ?A |-- _ =>

 replace A

  with (fold_right (@sepcon _ _ _ _ _) emp

            (map (fun idt : ident * type => var_block Share.top idt rho)

            (fn_vars f)))

end.

 2: clear; induction (fn_vars f); simpl; f_equal; auto.

 unfold var_block. unfold eval_lvar. simpl.

  rewrite H0. unfold make_venv. forget (ge_of rho) as ZZ. rewrite H0 in H7; clear rho H0.

 revert ve H1 H7; induction (fn_vars f); simpl; intros.

 case_eq (PTree.elements ve); simpl; intros; auto.

 destruct p as [id ?].

 pose proof (PTree.elements_complete ve id p). rewrite H0 in H2. simpl in H2.

 specialize (H7 id). unfold make_venv in H7. rewrite H2 in H7; auto.

 destruct p; inv H7.

 inv H.

 destruct a as [id ty]. simpl in *.

 simpl in COMPLETE. inversion COMPLETE; subst.

 clear COMPLETE; rename H5 into COMPLETE; rename H2 into COMPLETE_HD.

 specialize (IHl COMPLETE H4 (PTree.remove id ve)).

 assert (exists b, ve ! id = Some (b,ty)). {

  specialize (H1 id ty).

  rewrite PTree.gss in H1. destruct H1 as [[b ?] _]; auto. exists b; apply H.

 }

 destruct H as [b H].

 destruct (@PTree.elements_remove _ id (b,ty) ve H) as [l1 [l2 [? ?]]].

 rewrite H0.

 rewrite map_app. simpl map.

 apply derives_trans with (freeable_blocks ((b,0,@sizeof ge ty) ::  (map (block_of_binding ge) (l1 ++ l2)))).

 2:{

   clear.

   induction l1; simpl; try auto.

   destruct a as [id' [hi lo]]. simpl. rewrite <- sepcon_assoc. 

   rewrite (sepcon_comm (VALspec_range (@sizeof ge ty - 0) Share.top (b, 0))).

   rewrite sepcon_assoc. apply sepcon_derives; auto.

 }

 unfold freeable_blocks; simpl. rewrite <- H2.

 apply sepcon_derives.

 unfold Map.get. rewrite H. rewrite eqb_type_refl.



 unfold memory_block. normalize. {



  rename H6 into H99.

 normalize. 

 rewrite memory_block'_eq.

 2: rewrite Ptrofs.unsigned_zero; omega.

 2:{

 rewrite Ptrofs.unsigned_zero. rewrite Zplus_0_r.

 rewrite Coqlib.nat_of_Z_eq.

 change (Ptrofs.unsigned Ptrofs.zero) with 0 in H99.

 omega.

 pose proof (sizeof_pos ty); omega.

}

 rewrite Z.sub_0_r.

 unfold memory_block'_alt.

 rewrite if_true by apply readable_share_top.

 rewrite Coqlib.nat_of_Z_eq.

 + rewrite HGG. auto.

 + pose proof (sizeof_pos ty); omega.

}

 eapply derives_trans; [ | apply IHl]; clear IHl.

 clear - H3.

 induction l; simpl; auto.

 destruct a as [id' ty']. simpl in *.

 apply sepcon_derives; auto.

 replace (Map.get (fun id0 : positive => (PTree.remove id ve) ! id0) id')

   with (Map.get (fun id0 : positive => ve ! id0) id'); auto.

 unfold Map.get.

 rewrite PTree.gro; auto.

 intros id' ty'; specialize (H1 id' ty').

 {split; intro.

 - destruct H1 as [H1 _].

   assert (id<>id').

   intro; subst id'.

   clear - H3 H5; induction l; simpl in *. rewrite PTree.gempty in H5; inv H5.

   destruct a; simpl in *.

   rewrite PTree.gso in H5. auto. auto.

   destruct H1 as [v ?].

   rewrite PTree.gso; auto.

   exists v. unfold Map.get. rewrite PTree.gro; auto.

 - unfold Map.get in H1,H5.

   assert (id<>id').

     clear - H5; destruct H5. intro; subst. rewrite PTree.grs in H. inv H.

   rewrite PTree.gro in H5 by auto.

   rewrite <- H1 in H5. rewrite PTree.gso in H5 by auto. auto.

 }

 hnf; intros.

 destruct (make_venv (PTree.remove id ve) id0) eqn:H5; auto.

 destruct p.

 unfold make_venv in H5.

 destruct (peq id id0).

 subst.  rewrite PTree.grs in H5. inv H5.

 rewrite PTree.gro in H5 by auto.

 specialize (H7 id0). unfold make_venv in H7. rewrite H5 in H7.

 destruct H7; auto. inv H6; congruence.

Qed.



Definition maybe_retval (Q: environ -> mpred) retty ret :=

 match ret with

 | Some id => fun rho => Q (get_result1 id rho)

 | None =>

    match retty with

    | Tvoid => (fun rho => Q (globals_only rho))

    | _ => fun rho => EX v: val, Q (make_args (ret_temp::nil) (v::nil) rho)

    end

 end.



Lemma VALspec_range_free:

  forall n b phi1 jm,

  app_pred (VALspec_range n Share.top (b, 0)) phi1 ->

  join_sub phi1 (m_phi jm) ->

  {m' | free (m_dry jm) b 0 n = Some m' }.

Proof.

intros.

apply range_perm_free.

destruct H0 as [phi2 H0].

hnf; intros.

pose proof (juicy_mem_access jm (b,ofs)).

hnf. unfold access_at in H2. simpl in H2.

destruct H as [H _]; specialize (H (b,ofs)).

hnf in H.

rewrite if_true in H by (split; auto; omega).

destruct H as [v ?].

apply (resource_at_join _ _ _ (b,ofs)) in  H0.

destruct H.

hnf in H.

rewrite H in H0.

rewrite H2.

inv H0; simpl; apply join_top in RJ; subst sh3; rewrite perm_of_freeable; constructor.

Qed.



Lemma Forall_filter: forall {A} P (l: list A) f, Forall P l -> Forall P (filter f l).

Proof.

  intros.

  induction l.

  + constructor.

  + inversion H; subst.

    apply IHl in H3.

    simpl.

    simple_if_tac.

    - constructor; auto.

    - auto.

Qed.



Lemma can_free_list:

  forall Delta F f jm ge ve te

  (NOREP: list_norepet (map (@fst _ _) (fn_vars f)))

  (COMPLETE: Forall (fun it => complete_type cenv_cs (snd it) = true) (fn_vars f))

  (HGG:  genv_cenv ge = cenv_cs),

   guard_environ (func_tycontext' f Delta) (Some f)

        (construct_rho (filter_genv ge) ve te) ->

    (F * stackframe_of f (construct_rho (filter_genv ge)ve te))%pred (m_phi jm) ->

   exists m2, free_list (m_dry jm) (blocks_of_env ge ve) = Some m2.

Proof.

  intros.

  destruct H0 as [? [? [? [_ ?]]]].

  unfold stackframe_of in H1.

  unfold blocks_of_env in *.

  destruct H as [_ [H _]]; clear - NOREP COMPLETE HGG H H0 H1. simpl in H.

  pose (F vl := (fold_right

          (fun (P Q : environ -> pred rmap) (rho : environ) => P rho * Q rho)

          (fun _ : environ => emp)

          (map (fun idt : ident * type => var_block Share.top idt) vl))).

  change ((F (fn_vars f)  (construct_rho (filter_genv ge) ve te)) x0) in H1.

  assert (forall id b t, In (id,(b,t)) (PTree.elements ve) ->

                In (id,t) (fn_vars f)). {

   intros.

    apply PTree.elements_complete in  H2.

    specialize (H id); unfold make_venv in H; rewrite H2 in H.

     apply H.

  }

  clear H.

  assert (Hve: forall i bt, In (i,bt) (PTree.elements ve) -> ve ! i = Some bt)

    by apply PTree.elements_complete.

  assert (NOREPe: list_norepet (map (@fst _ _) (PTree.elements ve)))

    by apply PTree.elements_keys_norepet.

  forget (PTree.elements ve) as el.

  rename x0 into phi.

  assert (join_sub phi (m_phi jm)).

  econstructor; eauto.

  clear H0.

  forget (fn_vars f) as vl.

  revert vl phi jm H H1 H2 Hve NOREP NOREPe COMPLETE; induction el; intros;

    [ solve [simpl; eauto] | ].

  simpl in H2.

  destruct a as [id [b t]]. simpl in NOREPe,H2|-*.

  assert (H2': In (id,t) vl) by (apply H2 with b; auto).

  specialize (IHel (filter (fun idt => negb (eqb_ident (fst idt) id)) vl)).

  replace (F vl (construct_rho (filter_genv ge) ve te))

    with  (var_block Share.top (id,t) (construct_rho (filter_genv ge) ve te)

    * F (filter (fun idt => negb (eqb_ident (fst idt) id)) vl) (construct_rho (filter_genv ge) ve te)) in H1.

  2:{

    clear - H2' NOREP.

    induction vl; inv H2'.

    simpl in NOREP.

    inv NOREP.

    unfold F; simpl fold_right.

    f_equal.

    f_equal.

    f_equal.

    replace (eqb_ident id id) with true

      by (symmetry; apply (eqb_ident_spec id id); auto).

    simpl.

    clear - H1.

    induction vl; simpl; auto.

    replace (negb (eqb_ident (fst a) id)) with true.

    f_equal.

    apply IHvl.

    contradict H1. right; auto.

    pose proof (eqb_ident_spec (fst a) id).

    destruct (eqb_ident (fst a) id) eqn:?; auto.

    elimtype False; apply H1. left. rewrite <- H; auto.

    transitivity

     (var_block Share.top a (construct_rho (filter_genv ge) ve te) *

         F vl (construct_rho (filter_genv ge) ve te)); [ | reflexivity].

    inv NOREP.

    rewrite <- IHvl; auto.

    repeat rewrite <- sepcon_assoc.

    simpl filter.

    replace (eqb_ident (fst a) id) with false.

    simpl.

    unfold F at 1.

    simpl.

    symmetry;

    rewrite (sepcon_comm (var_block _ _ _ )).

    repeat rewrite sepcon_assoc.

    reflexivity.

    pose proof (eqb_ident_spec (fst a) id).

    destruct (eqb_ident (fst a) id); auto.

    assert (fst a = id) by (apply H0; auto).

    subst id.

    contradiction H2.

    replace (fst a) with (fst (fst a, t)) by reflexivity.

    apply in_map; auto.

  }

  pose (H0:=True).

  destruct H1 as [phi1 [phi2 [? [? ?]]]].

  unfold var_block in H3.

  normalize in H3.

  simpl in H3.

  assert (0 <= sizeof t) by (pose proof (sizeof_pos t); omega).

  simpl in H5.

  unfold eval_lvar, Map.get in H3. simpl in H3.

  unfold make_venv in H3.

  rewrite (Hve id (b,t)) in H3 by (left; auto).

  rewrite eqb_type_refl in H3.

  

  simpl in H3; destruct H3 as [H99 H3].

  change nat_of_Z with Z.to_nat in H3.

  rewrite memory_block'_eq in H3;

  try rewrite Ptrofs.unsigned_zero; try omega.

  2:{

   rewrite Z.add_0_r; rewrite Z2Nat.id by omega. change (Ptrofs.unsigned Ptrofs.zero) with 0 in H99; omega.

  }

  unfold memory_block'_alt in H3.

  rewrite Ptrofs.unsigned_zero in H3.

  rewrite Z2Nat.id in H3 by omega.

  rewrite if_true in H3 by apply readable_share_top.

  assert (join_sub phi1 (m_phi jm)) as H7

   by ( apply join_sub_trans with phi; auto; eexists; eauto).

  destruct (VALspec_range_free _ _ _ _ H3 H7)

   as [m3 ?H].

  assert (VR: app_pred (VALspec_range (sizeof t-0) Share.top (b, 0) * TT) (m_phi jm)).

    clear - H3 H7. destruct H7.

  rewrite Z.sub_0_r; exists phi1; exists x; split3; auto.

  pose (jm3 := free_juicy_mem _ _ _ _ _ H8 ).

  destruct H as [phix H].

  destruct (join_assoc H1 H) as [phi3 []].

  assert (phi3 = m_phi jm3).

  { subst jm3; symmetry; eapply juicy_free_lemma'; eauto.

    rewrite Z.sub_0_r; auto.

  }

  subst phi3.  assert (join_sub phi2 (m_phi jm3)) as Hphi2 by (eexists; eauto).

  destruct (IHel phi2 jm3 Hphi2) as [m4 ?]; auto; clear IHel.

  + intros.

    specialize (H2 id0 b0 t0).

    spec H2; [ auto |].

    assert (id0 <> id).

    {

      clear - NOREPe H11.

      inv NOREPe. intro; subst.

      apply H1. change id with (fst (id,(b0,t0))); apply in_map; auto.

    }

    clear - H2 H12.

    induction vl; simpl in *; auto.

    destruct H2. subst a. simpl.

    replace (eqb_ident id0 id) with false; simpl; auto.

    pose proof (eqb_ident_spec id0 id); destruct (eqb_ident id0 id); simpl in *; auto.

    contradiction H12; apply H; auto.

    pose proof (eqb_ident_spec (fst a) id); destruct (eqb_ident (fst a) id); simpl in *; auto.

  + intros; eapply Hve; eauto.

    right; auto.

  + clear - NOREP.

    induction vl; simpl; auto.

    pose proof (eqb_ident_spec (fst a) id); destruct (eqb_ident (fst a) id); simpl in *; auto.

    assert (fst a = id) by ( apply H; auto); subst.

    apply IHvl; inv NOREP; auto.

    inv NOREP.

    constructor; auto.

    clear - H2.

    contradict H2.

    induction vl; simpl in *; auto.

    destruct (eqb_ident (fst a0) id); simpl in *; auto.

    destruct H2; auto.

  + inv NOREPe; auto.

  + apply Forall_filter; auto.

  + pose proof (proj1 (Forall_forall _ _) COMPLETE (id, t) H2').

    simpl in H11.

    exists m4.

    rewrite HGG.

    rewrite H8. auto.

Qed.



Lemma necR_m_dry':

  forall jm jm', m_dry jm = m_dry jm' ->

                (necR (m_phi jm) (m_phi jm')) ->

            necR jm jm'.

Proof.

intros.

remember (m_phi jm) as phi.

remember (m_phi jm') as phi'.

unfold necR in *.

rewrite clos_rt_rt1n_iff in *.

revert jm jm' Heqphi Heqphi' H; induction H0; intros; subst.

replace jm' with jm. constructor 1.

apply juicy_mem_ext; auto.

destruct (can_age_jm jm) as [jm1 ?].

destruct (age1 (m_phi jm)) eqn:?; congruence.

constructor 2 with jm1; auto.

apply age1_juicy_mem_unpack in H2. destruct H2.

apply IHclos_refl_trans_1n.

hnf in H,H2. congruence.

congruence.

congruence.

Qed. 



Lemma age_juicy_mem_i:

  forall jm jm', m_dry jm = m_dry jm' ->

        age (m_phi jm) (m_phi jm') ->

       age jm jm'.

Proof.

intros.

hnf in H0 |-*.

unfold age1; simpl.

apply age1_juicy_mem_unpack'; auto.

Qed. 



Lemma free_juicy_mem_resource_decay:

  forall jm b lo hi m' jm'

     (H : free (m_dry jm) b lo hi = Some m')

     (H0 : forall ofs : Z,  lo <= ofs < hi ->

             perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),

    free_juicy_mem jm m' b lo hi H = jm' ->

    resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm').

Proof.

intros.

 subst jm'. simpl.

 apply (inflate_free_resource_decay _ _ _ _ _ H H0).

Qed.



Lemma free_list_resource_decay:

  forall bl jm jm',

  free_list_juicy_mem jm bl jm' ->

  resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm').

Proof.

induction 1; intros.

apply resource_decay_refl; intros.

apply (juicy_mem_alloc_cohere jm l H).

apply resource_decay_trans with (nextblock (m_dry jm)) (m_phi jm2).

apply Pos.le_refl.

eapply free_juicy_mem_resource_decay; eauto.

rewrite <- (nextblock_free _ _ _ _ _ H).

apply IHfree_list_juicy_mem.

Qed.



Definition tc_fn_return (Delta: tycontext) (ret: option ident) (t: type) :=

 match ret with

 | None => True

 | Some i => match (temp_types Delta) ! i with Some t' => t=t' | _ => False end

 end.



Lemma derives_refl' {A: Type}  `{ageable A}:

    forall P Q: pred A, P=Q -> P |-- Q.

Proof.  intros; subst; apply derives_refl. Qed.



 Lemma free_juicy_mem_core:

  forall jm m b lo hi H

   (H0 : forall ofs : Z,

     lo <= ofs < hi -> perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),

   core (m_phi (free_juicy_mem jm m b lo hi H)) = core (m_phi jm).

Proof.

 intros.

 apply rmap_ext.

 do 2  rewrite level_core.

 apply free_juicy_mem_level.

 intros.

 repeat rewrite <- core_resource_at.

 simpl. unfold inflate_free; simpl;  rewrite resource_at_make_rmap.

 destruct (m_phi jm @ l) eqn:?; auto.

 if_tac; rewrite !core_NO; auto.

 if_tac. rewrite core_YES, core_NO; auto. rewrite !core_YES; auto.

 if_tac; auto.

 destruct l; destruct H1; subst. specialize (H0 z).

 spec H0; [omega | ]. rewrite Heqr in H0. inv H0.

 rewrite !ghost_of_core, free_juicy_mem_ghost; auto.

Qed.



Lemma same_glob_funassert':

  forall Delta1 Delta2 rho rho',

     (forall id, (glob_specs Delta1) ! id = (glob_specs Delta2) ! id) ->

      ge_of rho = ge_of rho' ->

              funassert Delta1 rho = funassert Delta2 rho'.

Proof.

assert (forall Delta Delta' rho rho',

             (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id) ->

             ge_of rho = ge_of rho' ->

             funassert Delta rho |-- funassert Delta' rho').

intros.

unfold funassert.

intros w [? ?]; split.

clear H2; intro id. rewrite <- (H id), <- H0; auto.

intros loc fs w' Hw' H4; destruct (H2 loc fs w' Hw' H4)  as [id H3].

exists id; rewrite <- (H id), <- H0; auto.

intros.

apply pred_ext; apply H; intros; auto.

Qed.



Lemma semax_call_external:

forall (Delta : tycontext) (A : TypeTree)

  (P Q Q' : forall ts, dependent_type_functor_rec ts (AssertTT A) mpred)

  (ts: list Type) (x : dependent_type_functor_rec ts A mpred)

  (F : environ -> pred rmap) (F0 : assert)

  (ret : option ident) (params : list (ident * type)) (retty : type) cc

  (a : expr) (bl : list expr) (R : ret_assert) (psi : genv) (vx : env)

  (tx : temp_env) (k : cont) (rho : environ) (ora : OK_ty) (jm : juicy_mem)

  (b : block)

 (Hora : juicy_mem_op (ext_compat ora) jm)

 (TC0 : Cop.classify_fun (typeof a) =

      Cop.fun_case_f (type_of_params params) retty cc)

 (TCret : tc_fn_return Delta ret retty)

 (TC1 : (|> tc_expr Delta a rho) (m_phi jm))

 (TC2 : (|> tc_exprlist Delta (map snd params) bl rho) (m_phi jm))

 (TC3 : guard_environ Delta (current_function k) rho)

 (TC5 : retty = Tvoid -> ret = None)

 (H : closed_wrt_modvars (Scall ret a bl) F0)

 (HR : RA_normal R =

     (fun rho0 : environ =>

      EX  old : val,

      substopt ret old F rho0 * maybe_retval (Q ts x) retty ret rho0))

 (HGG:  genv_cenv psi = cenv_cs)

 (H0 : rho = construct_rho (filter_genv psi) vx tx)

 (H3 : eval_expr a rho = Vptr b Ptrofs.zero)

 (H4 : (funassert Delta rho) (m_phi jm))

 (H1 : (rguard Espec psi Delta

        (frame_ret_assert R F0) k) (level (m_phi jm)))

 (H11 : forall vl : environ, (!|>(Q' ts x vl <=> Q ts x vl)) (m_phi jm))

 (H14 : (|>(F0 rho * F rho *

          P ts x

            (make_args (map fst params)

               (eval_exprlist (map snd params) bl rho) rho))) (m_phi jm))

 (n : nat)

 (H2 : level (m_phi jm) = S n)

 (H15 : (believe_external Espec psi (Vptr b Ptrofs.zero) (params, retty) cc A P Q')

        (level (m_phi jm))),

 exists (c' : corestate) (m' : juicy_mem),

  jstep (cl_core_sem psi) (State vx tx (Kseq (Scall ret a bl) :: k)) jm c' m' /\

  jm_bupd ora (jsafeN OK_spec psi n ora c') m'.

Proof.

intros.

destruct TC3 as [TC3 TC3'].

rewrite <- snd_split in TC2.

rewrite <- level_juice_level_phi in H2.

destruct (levelS_age1 _ _ H2) as [jm' Hage].

specialize (TC1 (m_phi jm') (t_step _ _ _ _ (age_jm_phi Hage))).

specialize (TC2 (m_phi jm') (t_step _ _ _ _ (age_jm_phi Hage))).

assert (H21 := eval_exprlist_relate Delta (params,retty) bl psi vx tx _

      jm' TC2 TC3 HGG H0

      (mkfunction retty cc params nil nil Sskip)

      (eq_refl _)). simpl in H21.

rewrite snd_split in TC2.



unfold believe_external in H15.

destruct (Genv.find_funct psi (Vptr b Ptrofs.zero)) eqn:H22; try (contradiction H15).

destruct f eqn:Ef; try (contradiction H15).



destruct H15 as [[H5 H15] Hretty]. hnf in H5.

destruct H5 as [H5 [H5' [Eef Hlen]]]. subst c.

inversion H5. subst t0. rename t into tys. subst rho.

specialize (H15 psi ts x n).

spec H15; [constructor 1; rewrite <- level_juice_level_phi, H2; constructor | ].

specialize (H15

  (F0 (construct_rho (filter_genv psi) vx tx) *

          F (construct_rho (filter_genv psi) vx tx))

   (typlist_of_typelist tys)

  (eval_exprlist (snd (split params)) bl

                  (construct_rho (filter_genv psi) vx tx))

   jm').

spec H15; [ apply age_level in Hage; omega | ].

specialize (H15 _ (necR_refl _)).

spec H15. { clear H15.

assert ((|> (P ts x

      (make_ext_args (filter_genv psi) (map fst params)

         (eval_exprlist (snd (split params)) bl

            (construct_rho (filter_genv psi) vx tx))) *

    (F0 (construct_rho (filter_genv psi) vx tx) *

     F (construct_rho (filter_genv psi) vx tx)))) (m_phi jm)). {

eapply later_derives; try apply H14.

rewrite sepcon_comm.

apply sepcon_derives; auto.

apply derives_refl'. f_equal.

rewrite H7 in TC2.

clear - TC2 H7 Hlen.

revert bl tys TC2 H7 Hlen; induction params; destruct bl; simpl; intros; auto.

{ destruct tys; try congruence.

simpl in Hlen. destruct a. destruct (split params). inv Hlen.

destruct a. revert TC2. case_eq (split params). intros l1 l2 Heq. simpl.

  intros; inv TC2.

}

destruct tys.

simpl in Hlen. destruct a. destruct (split params). inv Hlen.

destruct a. revert TC2. case_eq (split params). intros l1 l2 Heq.

  simpl in *. intros TC2.

unfold tc_exprlist in TC2; simpl in TC2.

repeat rewrite denote_tc_assert_andp in TC2.

destruct TC2 as [[? ?] ?].

inversion H7.

rewrite Heq in *. simpl in *.

specialize (IHparams _ _ H1). spec IHparams. inv H3; auto.

rewrite IHparams; auto.

}

simpl.

rewrite fst_split.

split.

{ 

  rewrite Eef; simpl.

  clear -TC2 TC3.

  revert bl TC2.

  induction params. now auto.

  destruct a as (id, ty).

  intros [ | b bl] TC2.

  - rewrite snd_split in *.

    simpl in *.

    inversion TC2.

  - rewrite snd_split.

    simpl in *.

    unfold tc_exprlist in *.

    simpl in TC2.

    repeat rewrite denote_tc_assert_andp in TC2.

    destruct TC2 as ((tcb & tcb') & tcbl).

    split.

    + pose proof tc_val_sem_cast _ _ _ _ _ TC3 tcb tcb' as tc.

      apply tc_val_has_type.

      auto.

    + rewrite <-snd_split.

      apply (IHparams bl).

      apply tcbl.

}

apply H0.

constructor 1.

apply age_jm_phi; auto.

}

clear H14 TC2.

destruct H15 as [x' H15].

clear H5.

destruct H15 as [H5 H15].

specialize (H15 (opttyp_of_type retty)).

do 3 red in H15.



assert (Hty: type_of_params params = tys).

{ clear -H7 Hlen.

  rewrite H7. clear H7. revert tys Hlen. induction params.

  simpl. destruct tys; auto. inversion 1.

  intros; simpl. destruct a. case_eq (split params). intros l1 l2 Heq. simpl.

  destruct tys; auto. simpl. rewrite Heq in IHparams. rewrite IHparams; auto.

  simpl in Hlen|-*. rewrite Heq in Hlen. inv Hlen. rewrite Heq. auto. }

eexists; exists jm'.

split.

econstructor.

rewrite (age_jm_dry Hage).

eapply step_call_external; try eassumption.

eapply eval_expr_relate; try eassumption.

reflexivity.

rewrite H3.

rewrite H22.

rewrite Hty. reflexivity.

split.

apply age1_resource_decay; auto.

split; [apply age_level; auto|].

apply age1_ghost_of, age_jm_phi; auto.

apply jm_bupd_intro.

destruct n as [ | n ].

constructor.

eapply jsafeN_external with (x0 := x'); eauto.

reflexivity.

rewrite Eef. subst tys. apply H5; auto.

{ eapply pred_hereditary; eauto. }

intros.

specialize (H15 ret0 z').

change ((ext_spec_post' Espec e x' (genv_symb_injective psi) (opttyp_of_type retty) ret0 z' >=>

        juicy_mem_op

          (Q' ts x (make_ext_rval  (filter_genv psi) ret0) *

              (F0 (construct_rho (filter_genv psi) vx tx) *

               F (construct_rho (filter_genv psi) vx tx)))) (level jm')) in H15.

assert (level jm' > level m')%nat.

{

 destruct H6 as (?&?&?); auto.

}

apply (pred_nec_hereditary _ _ (level m')) in H15;

 [ | apply nec_nat; omega].

rewrite Eef in *.

specialize (H15 m' (le_refl _) _ (necR_refl _) H8).



pose (tx' := match ret,ret0 with

                   | Some id, Some v => PTree.set id v tx

                   | _, _ => tx

                   end).



specialize (H1 EK_normal None tx' vx (m_phi m')).

spec H1.

{ clear - Hage H9.

  change (level jm >= level m')%nat.

  apply age_level in Hage. omega.

}

rewrite proj_frame_ret_assert in H1.

simpl proj_ret_assert in H1.

rewrite HR in H1; clear R HR.

simpl exit_cont in H1.

do 3 red in H5.

specialize (H1 _ (necR_refl _)).



assert (Htc: tc_option_val retty ret0).

{clear - TCret TC3 H0 TC5 H15 Hretty Hretty0 H6 H9 Hage.

 destruct H15 as [phi1 [phi2 [Ha [Hb Hc]]]].

 specialize (Hretty ts x ret0 phi1).

 spec Hretty.

 { apply join_level in Ha. destruct Ha as [? ?].

   rewrite H. cut ((level jm > level jm')%nat). intros.

   simpl. unfold natLevel. do 2 rewrite <-level_juice_level_phi. omega.

   apply age_level in Hage. omega.

 }

 specialize (Hretty phi1).

 spec Hretty. apply rt_refl.

 spec Hretty. split. apply Hb. apply Hretty0.

 simpl in Hretty. auto.

}



spec H1. { clear H1.

split; [split; [split |] |].

*

 split.

 2:{

 clear - TC3.

 destruct TC3; simpl in *.

 destruct ret; try apply H0.

 }

 simpl.

 destruct TC3 as [TC3 _].

 destruct ret; try apply TC3. {

 clear - TCret TC3 H0 TC5 H15 Hretty Hretty0 H6 H8 Hage.

 simpl in TCret.

 destruct ((temp_types Delta) ! i) eqn:?; try contradiction.

 subst retty.

 unfold tx' in *; clear tx'. simpl in TC3.

 assert (Hu: exists u, opttyp_of_type t = Some u).

 { clear - TC5; destruct t as [ | [ | | | ] [ | ] | [ | ] | [ | ] | | | | | ];

   try (eexists; reflexivity).

   spec TC5; [auto | congruence].

 }

 destruct Hu as [u Hu].  clear TC5.

 destruct H15 as [phi1 [phi2 [Ha [Hb Hc]]]].

 specialize (Hretty ts x ret0 phi1).

 spec Hretty.

 { apply join_level in Ha. destruct Ha as [? ?].

   rewrite H. cut ((level jm > level jm')%nat). intros.

   simpl. unfold natLevel. do 2 rewrite <-level_juice_level_phi. destruct H6; omega.

   apply age_level in Hage. omega.

 }

 specialize (Hretty phi1).

 spec Hretty. apply rt_refl. spec Hretty. split. apply Hb. apply Hretty0. simpl in Hretty.

 unfold typecheck_temp_environ. intros id ty Hty.

 destruct (ident_eq i id).

 + subst i.

 rewrite Heqo in Hty.

 destruct ret0; auto.

 inversion Hty. subst t. simpl.

 exists v. split. rewrite <-map_ptree_rel, Map.gss; auto.

 assert (ty <> Tvoid). { destruct ty; try inv Hu; intros C; congruence. }

 assert (tc_val ty v). { destruct ty; auto. }

 apply tc_val_tc_val'; auto.

 inversion Hty. subst t. simpl.

 assert (ty = Tvoid). { destruct ty; auto; inv Hretty. } subst ty.

 simpl in Hu. inv Hu.

 + destruct ret0.

 rewrite <-map_ptree_rel, Map.gso; auto.

 assert (t = Tvoid). { destruct t; auto; inv Hretty. } subst t.

 simpl in Hu. inv Hu.

}

*

 destruct (current_function k); auto.

*

do 3 red in H15.

rewrite (sepcon_comm (F0 _)) in H15.

rewrite <- sepcon_assoc in H15.

assert (H15': ((!!tc_option_val retty ret0 && Q ts x (make_ext_rval (filter_genv psi) ret0)) *

       F (construct_rho (filter_genv psi) vx tx) *

       F0 (construct_rho (filter_genv psi) vx tx))%pred (m_phi m')). {

rewrite sepcon_assoc in H15|-*.

destruct H15 as [w1 [w2 [? [? ?]]]]; exists w1; exists w2; split3; auto.

clear - H1 H9 H10 H11 Hage Hretty Hretty0.

specialize (H11 (make_ext_rval (filter_genv psi) ret0) (level (m_phi jm'))).

specialize (Hretty ts x ret0 w1).

spec H11.

constructor 1.

repeat rewrite <- level_juice_level_phi.

apply age_level in Hage. rewrite Hage.

reflexivity.

spec Hretty.

repeat rewrite <- level_juice_level_phi.

apply age_level in Hage. rewrite Hage.

apply join_level in H1. destruct H1.

rewrite H. change (S (level jm') >= level m')%nat.

omega.

split.

apply Hretty; auto. split; auto.

destruct (H11 w1) as [? _].

apply join_level in H1. destruct H1.

rewrite <- level_juice_level_phi in *.

omega.

apply H; auto.

}

clear H15.

revert Htc.

normalize in H15'.

do 2 red in H1.

intros Htc.

rewrite (sepcon_comm (Q _ _ _)) in H15'.

unfold seplog.sepcon, seplog.LiftSepLog .

rewrite <- exp_sepcon1.

eapply sepcon_derives; [apply sepcon_derives | | apply H15']; clear H15'.



+ 

  destruct TC3 as [TC3 _].

  hnf in TC3; simpl in TC3.

 hnf in TCret.

apply exp_right with

  match ret with

       | Some id =>

           match tx ! id with

           | Some old => old

           | None => Vundef

           end

       | None => Vundef

       end.

unfold substopt.

unfold tx' in *; clear tx'.

destruct ret; auto.

destruct ((temp_types Delta) ! i) as [ti|] eqn:H29; try contradiction.

specialize (TC3 _ _ H29).

destruct TC3 as [v [? ?]].

unfold subst.

apply derives_refl'.

f_equal.

unfold env_set, construct_rho.

simpl. f_equal.

unfold Map.set,Map.get, make_tenv in H10 |- *; rewrite H10.

destruct (type_eq retty Tvoid).

spec TC5; auto. inv TC5.

extensionality j.

if_tac. subst j. auto.

destruct ret0; auto.

rewrite PTree.gso; auto.

+ 

destruct (type_eq retty Tvoid).

subst retty. unfold maybe_retval.

hnf in H1.

destruct ret0; try contradiction.

simpl make_ext_rval.

spec TC5; auto. unfold tx' in *; subst ret.

apply derives_refl.

destruct ret0; hnf in H1; simpl in H1.

assert (tc_val retty v).

destruct retty; try congruence; auto.

clear H1.

unfold maybe_retval.

destruct ret.

 apply derives_refl'; f_equal.

unfold tx'.

unfold make_ext_rval, get_result1; simpl.

unfold ret_temp, eval_id, env_set; simpl.

f_equal.

unfold Map.get, make_tenv; simpl.

rewrite PTree.gss; reflexivity.

apply derives_trans with

  (EX  v0 : val, Q ts x (make_args (ret_temp :: nil) (v0 :: nil) (construct_rho (filter_genv psi) vx tx'))).

apply exp_right with v.

unfold make_args, make_ext_rval; simpl.

unfold env_set, globals_only; simpl.

apply derives_refl.

destruct retty; try congruence.

repeat match goal with

| _ => destruct retty; try contradiction

| _ => congruence 

end.

+

clear - H.

apply derives_refl'; apply H; intros.

unfold tx'; clear.

unfold modifiedvars; simpl.

destruct ret; simpl; auto.

destruct (ident_eq i0 i).

subst.

left. unfold insert_idset. rewrite PTree.gss; apply I.

right.

unfold Map.get, make_tenv.

destruct ret0; auto.

rewrite PTree.gso by auto.

auto.

*

assert (H4': (funassert Delta (construct_rho (filter_genv psi) vx tx)) (m_phi m')).

{ clear - Hage H6 H4.

destruct H6 as (?&?&?).

destruct H4.

assert (Hnec: necR (m_phi jm) (m_phi jm')). {

  cut (age jm jm'). intro Hx.

  constructor. apply age_jm_phi in Hx; auto. eauto.

}

split.

* intros id fs ???.

specialize (H2 id fs (m_phi jm')).

specialize (H2 Hnec); spec H2; auto.

destruct H2 as [b [? ?]].

destruct H1 as [H1 H1'].

specialize (H1 (b,0)).

unfold func_at in H6. destruct fs; simpl in *.

rewrite H6 in H1.

apply (necR_PURE (m_phi m') a') in H1; eauto.

exists b. split; auto. rewrite H1. simpl.

f_equal. f_equal.

assert (Hlev1: (level (m_phi m') >= level a')%nat).

{ apply necR_level in H4; auto. }

extensionality ts x.

extensionality b0 rho.

rewrite !fmap_app.

match goal with

| |- ?A (?B (?C ?D)) = _ => change (A (B (C D))) with ((A oo B oo C) D)

end.

rewrite approx_oo_approx' by omega.

rewrite approx_oo_approx' by omega.

rewrite approx'_oo_approx by omega.

rewrite approx'_oo_approx by omega.

auto.

* intros b fs ???.

specialize (H3 b fs (m_phi jm')).

specialize (H3 Hnec); spec H3; auto.

destruct H1 as [H1 H1'].

specialize (H1' (b,0)).

destruct fs; simpl in *.

destruct H5 as [b0 ?].

destruct (m_phi m' @ (b,0)) eqn:?.

eapply necR_NOx in Heqr; try apply H4. inversion2 H5 Heqr.

eapply necR_YES in Heqr; try apply H4. inversion2 H5 Heqr.

destruct H1' as [pp ?].

rewrite H6.

exists pp.

assert (H9 := necR_PURE _ _ _ _ _ H4 Heqr).

rewrite H5 in H9. inv H9.

f_equal.

pose proof (resource_at_approx (m_phi jm') (b,0)).

rewrite H6 in H; simpl in H.

injection H; intro. symmetry in H7. apply H7.

}

match type of H4' with ?A => match goal with |- ?B => replace B with A; auto end end.

}

exists

match ret0 with

| Some v =>

    match ret with

    | Some id => (State vx (PTree.set id v tx) k)

    | None => (State vx tx k) 

    end

| None => match ret with

          | Some _ => (State vx tx k) 

          | None => (State vx tx k)

          end

end.

split.

unfold cl_after_external.

revert Htc TC5.

destruct (type_eq retty Tvoid).

+ subst retty. simpl. destruct ret0; try solve[inversion 1].

  intros _. intros X; spec X; auto. rewrite X; auto.

+ intros Hret0.

  assert (Hv: exists v, ret0 = Some v).

  { revert Hret0.

    destruct retty; destruct ret0; simpl;

      try solve[intros _; eexists; eauto]; try inversion 1.

    exfalso; auto. }

  revert TCret.

  unfold tc_fn_return.

  destruct Hv as [v Hv]. rewrite Hv.

  destruct ret; auto.

+

destruct H6 as (?&?&?).

subst n'.

rewrite level_juice_level_phi.

destruct ret; destruct ret0; apply assert_safe_jsafe; auto.

Qed.



Lemma alloc_juicy_variables_age:

  forall {ge rho jm jm1 vl rho' jm' jm1'},

   age jm jm1 -> age jm' jm1' ->

   alloc_juicy_variables ge rho jm vl = (rho', jm') ->

   alloc_juicy_variables ge rho jm1 vl = (rho', jm1').

Proof.

  intros.

  revert jm jm1 H rho H1.

  induction vl; intros.

  {

    simpl in *; inv H1.

    hnf in H0,H. congruence.

  }

  destruct a.

  simpl in H1|-*.

  eapply IHvl; [| rewrite <- (age_jm_dry H); eassumption].

  apply age_juicy_mem_i; [simpl; rewrite (age_jm_dry H); auto |].

  simpl.

  apply rmap_age_i.

  {

    unfold after_alloc; simpl. repeat rewrite level_make_rmap.

    apply age_level. apply age_jm_phi; auto.

  }

  intro. unfold resource_fmap; simpl.

  unfold after_alloc; simpl.

  do 2  rewrite resource_at_make_rmap.

  unfold after_alloc'.

  if_tac; [rewrite if_true | rewrite if_false].

  + f_equal.

  + rewrite <- (age_jm_dry H); assumption.

  + clear H1.

    destruct (m_phi jm @ l) eqn:?.

    - symmetry;  eapply necR_NOx; try apply Heqr.

      constructor 1. apply age_jm_phi; auto.

    - symmetry.

      rewrite level_make_rmap.

      eapply necR_YES. constructor 1. eapply age_jm_phi. eassumption.

      auto.

    - rewrite level_make_rmap.

      symmetry.

      eapply necR_PURE. constructor 1. eapply age_jm_phi. eassumption.  auto.

  + rewrite <- (age_jm_dry H); assumption.

  + unfold after_alloc; rewrite !ghost_of_make_rmap, level_make_rmap.

    symmetry; apply age1_ghost_of, age_jm_phi; auto.

Qed.



Lemma alloc_juicy_variables_resource_decay:

  forall ge rho jm vl rho' jm',

    alloc_juicy_variables ge rho jm vl = (rho', jm') ->

    resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm') /\

    (nextblock (m_dry jm) <= nextblock (m_dry jm'))%positive.

Proof.

 intros.

 revert rho jm H; induction vl; intros.

 inv H. split. apply resource_decay_refl.

   apply juicy_mem_alloc_cohere. apply Pos.le_refl.

 destruct a as [id ty].

 unfold alloc_juicy_variables in H; fold alloc_juicy_variables in H.

 revert H; case_eq (juicy_mem_alloc jm 0 (@sizeof ge ty)); intros jm1 b1 ? ?.

 pose proof (juicy_mem_alloc_succeeds _ _ _ _ _ H).



 specialize (IHvl _ _ H0).

 symmetry in H1; pose proof (nextblock_alloc _ _ _ _ _ H1).

 destruct IHvl.

 split; [ |  rewrite H2 in H4; xomega].

 eapply resource_decay_trans; try eassumption.

 rewrite H2; xomega.

 clear - H H1.

 pose proof (juicy_mem_alloc_level _ _ _ _ _ H).

 unfold resource_decay.

 split. repeat rewrite <- level_juice_level_phi; rewrite H0; auto.

 intro loc.

 split.

 apply juicy_mem_alloc_cohere.

 rewrite (juicy_mem_alloc_at _ _ _ _ _ H).

 rewrite Z.sub_0_r.

 destruct loc as [b z]. simpl in *.

 if_tac. destruct H2; subst b1.

 right. right. left. split. apply alloc_result in H1; subst b; xomega.

 eauto.

 rewrite <- H0. left. apply resource_at_approx.

Qed.



Lemma make_args_close_precondition:

  forall params args ge ve te m tx ve' te' m' P vars,

    list_norepet (map fst params) ->

    bind_parameter_temps params args tx = Some te' ->

    alloc_juicy_variables ge empty_env m vars = (ve', m') ->

    P (make_args (map fst params) args (construct_rho (filter_genv ge) ve te))

   |-- close_precondition params vars P (construct_rho (filter_genv ge) ve' te').

Proof.

intros.

intros phi ?.

exists (Map.empty (block * type)).

assert (exists e : temp_env,

    forall i, e ! i = if in_dec ident_eq i (map fst params) then te' ! i else None). {

 clear - H H0.

 revert args tx H H0; induction params as [ | [? ?]]; destruct args; intros; simpl in *; inv H0.

 exists empty_tenv; intros; apply PTree.gempty.

 inv H.

 destruct (IHparams _ _ H4 H2) as [e ?]; clear IHparams.

 exists (PTree.set i v e); intro j; specialize (H j).

 destruct (ident_eq i j). subst.

 symmetry.

 rewrite PTree.gss.

 assert ((PTree.set j v tx) ! j = Some v) by (apply PTree.gss).

 forget (PTree.set j v tx) as tz.

 clear - H0 H2 H3; revert args tz H0 H2; induction params as [ | [? ? ]]; destruct args; intros; simpl in *; inv H2; auto.

 apply IHparams with args (PTree.set i v0 tz); auto.

 rewrite PTree.gso; auto.

 rewrite PTree.gso by auto.

 destruct (in_dec ident_eq j (map fst params)); auto.

}

destruct H3 as [e ?].

exists (fun i => e!i).

split3; intros.

*

unfold Map.get.

simpl. specialize (H3 i). rewrite if_true in H3 by auto. auto.

*

simpl.

 destruct (in_dec ident_eq i (map fst vars)).

 auto.

 right.

 unfold Map.get, Map.empty.

 symmetry.

 clear - H1 n.

 unfold make_venv.

 assert (empty_env ! i = None) by apply PTree.gempty.

 forget empty_env as ve.

 revert ve m H H1; induction vars as [ | [? ?]]; intros. inv H1; auto.

 spec IHvars. contradict n. right; auto.

 unfold alloc_juicy_variables in H1; fold alloc_juicy_variables in H1.

 destruct (juicy_mem_alloc m 0 (@sizeof ge t)).

 eapply IHvars; try apply H1.

 rewrite PTree.gso; auto.

 contradict n. left. auto.

*

 simpl.

 replace (mkEnviron (filter_genv ge) (Map.empty (block * type)) (fun i : positive => e ! i))

   with  (make_args (map fst params) args (construct_rho (filter_genv ge) ve te)); auto.

 replace (fun i : positive => e ! i)

  with (fun i => if in_dec ident_eq i (map fst params) then te' ! i else None)

   by (extensionality j; auto).

 clear - H H0.

 change (filter_genv ge) with (ge_of (construct_rho (filter_genv ge) ve te)) at 2.

 forget (construct_rho (filter_genv ge) ve te) as rho. clear - H H0.

 revert args tx rho H H0; induction params as [ | [? ? ]]; destruct args; intros; inv H0.

 reflexivity.

 simpl.

 inv H.

 rewrite (IHparams args (PTree.set i v tx) rho); auto.

 unfold env_set. simpl.

 f_equal. unfold Map.set; extensionality j.

 destruct (ident_eq j i). subst.

 rewrite if_true by auto.

 clear - H2 H3.

 symmetry.

 replace (Some v) with ((PTree.set i v tx) ! i) by (rewrite PTree.gss; auto).

 forget (PTree.set i v tx) as tz.

 revert args tz H2 H3; induction params as [ | [? ? ]]; destruct args; intros; inv H2; auto.

 rewrite (IHparams args (PTree.set i0 v0 tz)); auto. apply PTree.gso; auto.

 contradict H3; left; auto. contradict H3; right; auto.

 destruct (ident_eq i j); try congruence.

 destruct (in_dec ident_eq j (map fst params)); auto.

Qed.



Lemma juicy_mem_alloc_block:

 forall jm n jm2 b F,

   juicy_mem_alloc jm 0 n = (jm2, b) ->

   app_pred F (m_phi jm)  ->

   0 <= n < Ptrofs.modulus ->

   app_pred (F * memory_block Share.top n (Vptr b Ptrofs.zero)) (m_phi jm2).

Proof.

intros. rename H1 into Hn.

inv H.

unfold after_alloc; simpl m_phi.

match goal with |- context [proj1_sig ?A] => destruct A; simpl proj1_sig end.

rename x into phi2.

destruct a as (? & ? & Hg).

unfold after_alloc' in H1.

destruct (allocate (m_phi jm)

    (fun loc : address =>

      if adr_range_dec (snd (alloc (m_dry jm) 0 n), 0) (n - 0) loc

      then YES Share.top readable_share_top (VAL Undef) NoneP

      else core (m_phi jm @ loc)) (core (ghost_of phi2)))

  as [phi3 [phi4  [? [? Hg']]]].

* extensionality loc; unfold compose.

  if_tac. unfold resource_fmap. rewrite preds_fmap_NoneP. reflexivity.

  repeat rewrite core_resource_at.

  rewrite <- level_core.

  apply resource_at_approx.

*

 intros.

 simpl; if_tac.

 exists (YES Share.top readable_share_top (VAL Undef) NoneP).

 destruct l as [b ofs]; destruct H2.

 rewrite juicy_mem_alloc_cohere. constructor.

 apply join_unit1; auto.

 destruct (alloc (m_dry jm) 0 n) eqn:?H.

 apply alloc_result in H4. subst. simpl.

 xomega.

 exists (m_phi jm @ l).

 apply join_comm.

 apply core_unit.

*

rewrite ghost_core; auto.

*

rewrite <- Hg; eexists; apply join_comm, core_unit.

*

assert (phi4 = phi2). {

 apply rmap_ext. apply join_level in H2. destruct H2; omega.

 intro loc; apply (resource_at_join _ _ _ loc) in H2.

 rewrite H3 in H2; rewrite H1.

 if_tac.

 inv H2; apply YES_ext; apply (join_top _ _ (join_comm RJ)).

 apply join_comm in H2.

 apply core_identity in H2. auto.

 apply ghost_of_join in H2.

 rewrite Hg' in H2.

 apply join_comm, core_identity in H2; congruence.

}

subst phi4.

exists (m_phi jm), phi3; split3; auto.

split.

do 3 red.

rewrite Ptrofs.unsigned_zero.

omega.

rewrite Ptrofs.unsigned_zero.

rewrite memory_block'_eq; try omega.

2: rewrite Coqlib.nat_of_Z_eq; omega.

unfold memory_block'_alt.

rewrite if_true by apply readable_share_top.

split.

intro loc. hnf.

rewrite Coqlib.nat_of_Z_eq by omega.

if_tac.

exists Undef.

exists readable_share_top.

hnf.

rewrite H3.

rewrite Z.sub_0_r.

rewrite if_true by auto.

rewrite preds_fmap_NoneP.

f_equal.

unfold noat. simpl.

rewrite H3.

rewrite Z.sub_0_r.

rewrite if_false by auto.

apply core_identity.

simpl; rewrite Hg'; apply core_identity.

Qed.



Lemma alloc_juicy_variables_lem2:

  forall jm f (ge: genv) ve te jm' (F: pred rmap)

      (HGG:  genv_cenv ge = cenv_cs)

      (COMPLETE: Forall (fun it => complete_type cenv_cs (snd it) = true) (fn_vars f))

      (Hsize: Forall (fun var => @sizeof ge (snd var) <= Ptrofs.max_unsigned) (fn_vars f)),

      list_norepet (map fst (fn_vars f)) ->

      alloc_juicy_variables ge empty_env jm (fn_vars f) = (ve, jm') ->

      app_pred F (m_phi jm) ->

      app_pred (F * stackframe_of f (construct_rho (filter_genv ge) ve te)) (m_phi jm').

Proof.

intros.

unfold stackframe_of.

forget (fn_vars f) as vars. clear f.



forget empty_env as ve0.

revert F ve0 jm Hsize H0 H1; induction vars; intros.

simpl in H0. inv H0.

simpl fold_right. rewrite sepcon_emp; auto.

inv Hsize. rename H4 into Hsize'; rename H5 into Hsize.

simpl fold_right.

unfold alloc_juicy_variables in H0; fold alloc_juicy_variables in H0.

destruct a as [id ty].

destruct (juicy_mem_alloc jm 0 (@sizeof ge ty)) eqn:?H.

rewrite <- sepcon_assoc.

inv H.

simpl in COMPLETE; inversion COMPLETE; subst.

rename H7 into COMPLETE'.

rename H4 into COMPLETE_HD.

eapply IHvars; eauto. clear IHvars.



pose proof I.

unfold var_block, eval_lvar.

simpl sizeof; simpl typeof.

simpl Map.get. simpl ge_of.

assert (Map.get (make_venv ve) id = Some (b,ty)). {

 clear - H0 H5.

 unfold Map.get, make_venv.

 assert ((PTree.set id (b,ty) ve0) ! id = Some (b,ty)) by (apply PTree.gss).

 forget (PTree.set id (b, ty) ve0) as ve1.

 rewrite <- H; clear H.

 revert ve1 j H0 H5; induction vars; intros.

 inv H0; auto.

 unfold alloc_juicy_variables in H0; fold alloc_juicy_variables in H0.

 destruct a as [id' ty'].

 destruct (juicy_mem_alloc j 0 (@sizeof ge ty')) eqn:?H.

 rewrite (IHvars _ _ H0).

 rewrite PTree.gso; auto. contradict H5. subst; left; auto.

 contradict H5; right; auto.

}

rewrite H3. rewrite eqb_type_refl.

simpl in Hsize'.

rewrite <- HGG.

rewrite prop_true_andp by auto.

assert (0 <= @sizeof ge ty <= Ptrofs.max_unsigned) by (pose proof (@sizeof_pos ge ty); omega).

simpl.

forget (@sizeof ge ty) as n.

clear - H2 H1 H4.

eapply juicy_mem_alloc_block; eauto.

unfold Ptrofs.max_unsigned in H4; omega.

Qed.



Lemma free_list_juicy_mem_ghost: forall m l m', free_list_juicy_mem m l m' ->

  ghost_of (m_phi m') = ghost_of (m_phi m).

Proof.

  induction 1; auto.

  rewrite IHfree_list_juicy_mem, <- H1.

  apply free_juicy_mem_ghost.

Qed.



Lemma alloc_juicy_variables_ghost: forall l ge rho jm,

  ghost_of (m_phi (snd (alloc_juicy_variables ge rho jm l))) = ghost_of (m_phi jm).

Proof.

  induction l; auto; simpl; intros.

  destruct a; simpl.

  rewrite IHl; simpl.

  apply ghost_of_make_rmap.

Qed.



Lemma semax_call_aux:

 forall (Delta : tycontext)

  (A : TypeTree)

  (P Q Q' : forall ts, dependent_type_functor_rec ts (AssertTT A) mpred)

  (NEP: super_non_expansive P) (NEQ': super_non_expansive Q')

  (ts: list Type) (x : dependent_type_functor_rec ts A mpred)

  (F : environ -> pred rmap)

  (F0 : assert) (ret : option ident) (fsig0 : funsig) cc (a : expr)

  (bl : list expr) (R : ret_assert) (psi : genv) (vx:env) (tx:Clight.temp_env) (k : cont) (rho : environ)

  (ora : OK_ty) (jm : juicy_mem) (b : block) (id : ident)

  (Hora : juicy_mem_op (ext_compat ora) jm),

   Cop.classify_fun (typeof a) =

   Cop.fun_case_f (type_of_params (fst fsig0)) (snd fsig0) cc ->

   tc_fn_return Delta ret (snd fsig0) ->

   (|>tc_expr Delta a rho) (m_phi jm) ->

   (|>tc_exprlist Delta (snd (split (fst fsig0))) bl rho) (m_phi jm) ->

    

    guard_environ Delta (current_function k) rho ->

    (snd fsig0 =Tvoid -> ret=None) ->

    closed_wrt_modvars (Scall ret a bl) F0 ->

    RA_normal R = (fun rho0 : environ => EX old:val, substopt ret old F rho0 * maybe_retval (Q ts x) (snd fsig0) ret rho0) ->



    genv_cenv psi = cenv_cs ->

    rho = construct_rho (filter_genv psi) vx tx ->

    

    eval_expr a rho = Vptr b Ptrofs.zero ->

    (funassert Delta rho) (m_phi jm) ->

    (rguard Espec psi Delta (frame_ret_assert R F0) k) (level (m_phi jm)) ->

    (believe Espec Delta psi Delta) (level (m_phi jm)) ->

    (glob_specs Delta)!id = Some (mk_funspec fsig0 cc A P Q' NEP NEQ') ->

    Genv.find_symbol psi id = Some b ->

    (forall vl : environ, (!|>(Q' ts x vl <=> Q ts x vl)) (m_phi jm)) ->

    (|>(F0 rho * F rho *

           P ts x (make_args (map (@fst  _ _) (fst fsig0))

             (eval_exprlist (snd (split (fst fsig0))) bl rho) rho)

            )) (m_phi jm) ->

   jsafeN (@OK_spec Espec) psi (level (m_phi jm)) ora

     (State (vx) (tx) (Kseq (Scall ret a bl) :: k)) jm.

Proof.

intros Delta A P Q Q' NEP NEQ' ts x F F0 ret fsig cc a bl R psi vx tx k rho ora jm b id Hora.

intros TC0 TCret TC1 TC2 TC3 TC5 H HR HGG H0 H3 H4 H1 Prog_OK H8 H7 H11 H14.

pose (H6:=True); pose (H9 := True); pose (H16:=True);

pose (H12:=True); pose (H10 := True); pose (H5:=True).



assert (Prog_OK' := Prog_OK).

specialize (Prog_OK' (Vptr b Ptrofs.zero) fsig cc A P Q' _ (necR_refl _)).



case_eq (level (m_phi jm)); [solve [simpl; constructor] | intros n H2].

simpl.

rewrite <- level_juice_level_phi in H2.

destruct (levelS_age1 _ _ H2) as [jmx H13].

assert (LATER: laterR (level (m_phi jm)) n) by (constructor 1; rewrite <- level_juice_level_phi, H2; reflexivity).

spec Prog_OK'.

hnf. exists id, NEP, NEQ'; split; auto.

exists b; split; auto.

clear H16.

clear H10 H6 H5 H8.

do 4 (pose proof I).

destruct Prog_OK'. {

clear H5 H6 H8 H10 H9 H12.

destruct fsig as [params retty].

simpl @fst in *; simpl @snd in *.

rewrite @snd_split in *.

clear LATER.

clear id H7.

clear jmx H13.

clear Prog_OK.

edestruct semax_call_external; eauto.

destruct H5 as [? [? ?]].

inv H5.

econstructor; eauto.

simpl. constructor; auto.

}

specialize (TC1 _ (age_laterR (age_jm_phi H13))).

specialize (TC2 _ (age_laterR (age_jm_phi H13))).

specialize (H14 _ (age_laterR (age_jm_phi H13))).

destruct H15 as [b' [f [[? [? [COMPLETE [? ?]]]] ?]]].

destruct H18 as [H17' [Hvars [H18 H18']]].

inversion H15; clear H15; subst b'.

specialize (H19 ts x n LATER).

rewrite semax_fold_unfold in H19.

apply (pred_nec_hereditary _ _ n (laterR_necR LATER)) in Prog_OK.

pose (F0F := fun _: environ => F0 rho * F rho).

specialize (H19 _ _ _ (necR_refl _) (conj (tycontext_sub_refl _) HGG)  _ (necR_refl _) (Prog_OK)

                      ( Kcall ret f (vx) (tx) :: k)

                       F0F _ (necR_refl _)).

unfold F0F in *; clear F0F.

spec H19 ; [clear H19 |]. {

 split.

 repeat intro; f_equal.

 intros ek vl te ve.

 rewrite !proj_frame_ret_assert.

 unfold seplog.sepcon, seplog.LiftSepLog .

 remember ((construct_rho (filter_genv psi) ve te)) as rho'.

 replace (stackframe_of' psi f rho') with (stackframe_of f rho')

   by (rewrite HGG; auto).

 simpl seplog.sepcon.

 rewrite <- (sepcon_comm (stackframe_of f rho')).

 unfold function_body_ret_assert.

 destruct ek; simpl proj_ret_assert; try solve [normalize].



 rewrite andp_assoc.

 apply prop_andp_subp; intro. simpl in H15.

 repeat rewrite andp_assoc.

 apply subp_trans' with

  (F0 rho * F rho * (stackframe_of f rho' * bind_ret vl (fn_return f) (Q ts x) rho') && funassert Delta rho').

 apply andp_subp'; auto.

 rewrite (sepcon_comm (F0 rho * F rho)).

 apply sepcon_subp'; auto.

 apply sepcon_subp'; auto.

 unfold bind_ret.

 destruct vl.

 apply andp_subp'; auto.

 apply pred_eq_e1; apply (H11 _ _ LATER).

 destruct (fn_return f); auto.

 apply pred_eq_e1; apply (H11 _ _ LATER).

 clear Q' NEQ' H11.

 pose proof I.

 pose proof I.



 intros wx ? w' ? ?.

 assert (n >= level w')%nat.

 apply necR_level in H21.

 apply le_trans with (level wx); auto.

 clear wx H20 H21.

 apply own.bupd_intro.

 intros ora' jm' Hora' VR ?.

 subst w'.

 pose (H20:=True).

 assert (FL: exists m2, free_list (m_dry jm')  (Clight.blocks_of_env psi ve) = Some m2). {

 subst rho'.

 rewrite (sepcon_comm (stackframe_of f _)) in H22.

 repeat rewrite <- sepcon_assoc in H22.

 clear - COMPLETE HGG H17' H22 H15.

 destruct H22 as [H22 _].

 eapply can_free_list; try eassumption.

 rewrite <- HGG. auto.

}

destruct FL as [m2 FL2].

 rewrite HGG in COMPLETE.

 assert (ve_of rho' = make_venv ve) by (subst rho'; reflexivity).

 assert (SFFB := stackframe_of_freeable_blocks Delta _ rho' _ ve HGG COMPLETE H17' H21 H15).

 clear H21.

 destruct (free_list_juicy_mem_i _ _ _ (F0 rho * F rho * bind_ret vl (fn_return f) (Q ts x) rho') FL2)

 as [jm2 [FL [? FL3]]].

 eapply sepcon_derives. apply SFFB. apply derives_refl.

 forget (F0 rho * F rho) as F0F.

 rewrite <- sepcon_assoc.

 rewrite (sepcon_comm (stackframe_of _ _)). rewrite sepcon_assoc.

 destruct H22 as [H22 _].

 auto.

 subst m2.

pose (rval := match vl with Some v => v | None => Vundef end).

pose (te2 := match ret with

            | None => tx

            | Some rid => PTree.set rid rval tx

            end).

specialize (H1 EK_normal None te2 vx).

rewrite proj_frame_ret_assert in H1.

simpl proj_ret_assert in H1.

rewrite HR in H1; clear R HR. simpl exit_cont in H1.

unfold seplog.sepcon,  seplog.LiftSepLog  in H1.

specialize (H1 (m_phi jm2)).

spec H1.

clear - FL3 H2 H23.

repeat rewrite <- level_juice_level_phi in *. omega.

specialize (H1 _ (necR_refl _)). simpl in H15.

spec H1; [clear H1 | ].

split; [split |].

{

destruct H22 as [H22 _].

simpl. unfold te2. destruct ret; unfold rval.

destruct vl.

assert (tc_val' (fn_return f) v).

 apply tc_val_tc_val'.

 clear - H22; unfold bind_ret in H22; normalize in H22; try contradiction; auto.

unfold construct_rho. rewrite <- map_ptree_rel.

apply guard_environ_put_te'. subst rho; auto.

intros.

 cut (t = fn_return f). intros. rewrite H24; auto.

hnf in TCret; rewrite H21 in TCret. subst; auto.

assert (f.(fn_return)=Tvoid).

clear - H22; unfold bind_ret in H22; destruct (f.(fn_return)); normalize in H22; try contradiction; auto.

unfold fn_funsig in H18. rewrite H1 in H18. rewrite H18 in TC5. simpl in TC5.

specialize (TC5 (eq_refl _)); congruence.

rewrite <- H0. auto.

}

{

 destruct H22 as [H22a H22b].

 rewrite seplog.sepcon_comm.

 rewrite <- exp_sepcon1.

 simpl seplog.sepcon.

  rewrite <- sepcon_assoc.

 rewrite sepcon_comm in H22a|-*.

  rewrite sepcon_assoc in H22a.

 assert (bind_ret vl (fn_return f) (Q ts x) rho' * (F0 rho * F rho)

            |-- (maybe_retval (Q ts x) (snd fsig) ret (construct_rho (filter_genv psi) vx te2) *

 (F0 (construct_rho (filter_genv psi) vx te2) *

  EX old: val, substopt ret old F (construct_rho (filter_genv psi) vx te2)))). {

apply sepcon_derives.

*

 clear dependent a. clear H11 H19 H20 H10 H9 H12 H5 H6 H8 Hora Hora'.

 clear Prog_OK ora ora'.  subst rho' fsig.

 clear H22b VR. clear FL jm2 FL2 FL3.

 clear b H16 H7. clear bl TC2 H14.

 unfold te2; clear te2. unfold rval; clear rval.

 unfold bind_ret.

 unfold get_result1. simpl.

 unfold bind_ret.

 destruct vl.

 +apply derives_extract_prop; intro.

    unfold maybe_retval.

   destruct ret.

   unfold get_result1. simpl.

   apply derives_refl'. f_equal.

   unfold env_set; simpl.

   f_equal. unfold eval_id; simpl.

   f_equal. unfold Map.get. unfold make_tenv. rewrite PTree.gss. reflexivity.

   destruct (fn_return f); try contradiction H;

   apply exp_right with v;    apply derives_refl.

 +

   unfold fn_funsig in TC5. simpl in TC5.

   destruct (fn_return f) eqn:?; try apply FF_derives.

   specialize (TC5 (eq_refl _)). subst ret.

   unfold maybe_retval. apply derives_refl.

*

  subst rho.

  unfold te2.

 destruct ret; apply sepcon_derives; auto.

 +

  clear - H.

  apply derives_refl'.

  apply H. intros. destruct (ident_eq i i0).

  subst; left; hnf; simpl. unfold insert_idset. rewrite PTree.gss; auto.

  right; unfold Map.get; simpl; unfold make_tenv; simpl.

  rewrite PTree.gso; auto.

+

  simpl in TCret.

  destruct ((temp_types Delta) ! i) eqn:?; try contradiction.

  subst t.

  destruct TC3 as [[TC3 _] _].

  hnf in TC3; simpl in TC3.

  specialize (TC3 _ _ Heqo).

  destruct TC3 as [old [? _]].

  apply exp_right with old. unfold substopt, subst.

  apply derives_refl'. f_equal.

  unfold env_set, construct_rho.

   f_equal. unfold make_tenv. extensionality j.

  simpl. unfold Map.set. if_tac. subst.

  apply H0. rewrite PTree.gso; auto.

+

  apply exp_right with Vundef; simpl; auto.

}

 apply H1; clear H1.

 eapply free_list_juicy_mem_lem; eauto.

 eapply sepcon_derives; try apply H22a; auto.

}

{

 destruct H22 as [H22a H22b].

 rewrite VR in H22b; clear - FL H22b. {

 unfold te2; clear te2.

 rewrite corable_funassert in H22b.

 rewrite corable_funassert.

 replace (core (m_phi jm2)) with (core (m_phi jm')).

 apply H22b.

 clear - FL.

 induction FL; auto.

 rewrite <-IHFL.

 rewrite <- H1.

 rewrite free_juicy_mem_core; auto.

}

}

case_eq (@level rmap ag_rmap (m_phi jm')); intros; [solve [constructor] |].

rewrite <- level_juice_level_phi in H21.

destruct (levelS_age1 jm' _ H21) as [jm'' ?].

rewrite -> level_juice_level_phi in H21.

destruct (age_twin' jm' jm2 jm'') as [jm2'' [? ?]]; auto.

apply jsafeN_step with (c' := State (vx)(te2) k) (m' := jm2'').

replace n0 with (level jm2'')

 by (rewrite <- H25;

      apply age_level in H24;

      try rewrite <- level_juice_level_phi in H21;

      clear - H21 H24; omega).

split; auto.

simpl.

rewrite (age_jm_dry H26) in FL2.

destruct vl.

2:{

unfold fn_funsig in H18.

rewrite H18 in TC5. simpl in TC5.

assert (fn_return f = Tvoid). {

 clear - H22; unfold bind_ret in H22; normalize in H22; try contradiction; auto.

 destruct H22. repeat rewrite <- sepcon_assoc in H.

 destruct H as [? [? [? [_ ?]]]]. destruct (fn_return f); try contradiction H1. auto.

}

specialize (TC5 H27).

apply step_return with f ret Vundef (tx); simpl; auto.

unfold te2.

rewrite TC5. split; auto.

}

assert (tc_val (fn_return f) v).

 clear - H22; unfold bind_ret in H22; normalize in H22; try contradiction; auto.

 destruct H22. destruct H. apply H.

simpl.

unfold rval.

destruct ret.

apply step_return with (zap_fn_return f) None Vundef (PTree.set i v tx); simpl; auto.

apply step_return with f None Vundef tx; simpl; auto.

split; [ | split; [rewrite <- H25; apply age_level; auto|]]. {

 rewrite (age_jm_dry H26) in FL2.

 clear FL3 H1.

 apply resource_decay_trans with (nextblock (m_dry jm')) (m_phi jm2).

 apply Pos.le_refl.

 eapply free_list_resource_decay; eauto.

 replace (nextblock (m_dry jm')) with (nextblock (m_dry jm2)).

 apply age1_resource_decay; auto.

 symmetry.

 rewrite (age_jm_dry H26).

 clear - FL2.

 forget (m_dry jm') as m.

 revert m FL2; induction (blocks_of_env psi ve); intros.

 simpl in FL2. inv FL2; auto.

 simpl in FL2. destruct a as [[b lo] hi].

 destruct (free m b lo hi) eqn:?; inv FL2.

 rewrite <- (IHl _ H0).

 apply nextblock_free in Heqo; auto.

}

{ rewrite <- (free_list_juicy_mem_ghost _ _ _ FL).

  apply age1_ghost_of, age_jm_phi; auto. }

replace n0 with (level jm2'')

 by (rewrite <- H25;

      apply age_level in H24;

      try rewrite <- level_juice_level_phi in H21;

      clear - H21 H24; omega).

eapply assert_safe_jsafe, pred_hereditary, H1.

apply age_jm_phi; auto.

}



remember (alloc_juicy_variables psi empty_env jm (fn_vars f)) eqn:AJV.

destruct p as [ve' jm']; symmetry in AJV.

destruct (alloc_juicy_variables_e _ _ _ _ _ _ AJV) as [H15 [H20' CORE]].

assert (MATCH := alloc_juicy_variables_match_venv _ _ _ _ _ AJV).

assert (H20 := alloc_juicy_variables_resource_decay _ _ _ _ _ _ AJV).

rewrite <- Genv.find_funct_find_funct_ptr in H16.

destruct (build_call_temp_env f (eval_exprlist (snd (split (fst fsig))) bl rho))

as [te' ?]; auto.

simpl in TC2.

apply tc_exprlist_length in TC2.

clear - H18 TC2.

unfold fn_funsig in *; subst; simpl in *.

revert bl TC2; induction (fn_params f); destruct bl; intros; auto.

simpl in TC2. destruct a. destruct (split l). inv TC2.

simpl in *.

destruct a. simpl.

destruct (split l); simpl in *. unfold_lift; simpl. f_equal; auto.

destruct (levelS_age1 jm' n) as [jm'' H20x]. rewrite <- H20'; assumption.

apply jsafeN_step

  with (c' := State ve' te' (Kseq f.(fn_body) :: Kseq (Sreturn None)

                                              :: Kcall ret f (vx) (tx) :: k))

       (m' := jm''); auto.

split; auto.

eapply step_call_internal with (vargs:=eval_exprlist (snd (split (fst fsig))) bl rho); eauto.

rewrite <- H3.

erewrite age_jm_dry by eauto.

eapply eval_expr_relate; try solve[rewrite H0; auto]; auto. destruct TC3; eassumption. eauto.

destruct (fsig). unfold fn_funsig in *. inv H18.

erewrite age_jm_dry by eauto.

eapply eval_exprlist_relate; try eassumption; auto.

destruct TC3 ; auto.

unfold type_of_function.

rewrite H18'; destruct fsig; inv H18; auto.

rewrite <- (age_jm_dry H20x); auto.

split.

 destruct H20;  apply resource_decay_trans with (nextblock (m_dry jm')) (m_phi jm'); auto.

 apply age1_resource_decay; auto.

 split.

 rewrite H20'; apply age_level; auto.

 erewrite <- (alloc_juicy_variables_ghost _ _ _ jm), AJV; simpl.

 apply age1_ghost_of, age_jm_phi; auto.



assert (n >= level jm'')%nat.

clear - H2 H20' H20x.

apply age_level in H20x; omega.

pose (rho3 := mkEnviron (ge_of rho) (make_venv ve') (make_tenv te')).

assert (app_pred (funassert Delta rho3) (m_phi jm'')).

{

apply (resource_decay_funassert _ _ (nextblock (m_dry jm)) _ (m_phi jm'')) in H4.

2: apply laterR_necR; apply age_laterR; auto.

unfold rho3; clear rho3.

apply H4.

rewrite CORE. apply age_core. apply age_jm_phi; auto.

 destruct H20;  apply resource_decay_trans with (nextblock (m_dry jm')) (m_phi jm'); auto.

 apply age1_resource_decay; auto.

}

specialize (H19 te' ve' _ H22 _ (necR_refl _)).

spec H19; [clear H19|]. {

split; [split  |]; auto.

3:{

unfold rho3 in H23. unfold construct_rho. rewrite H0 in H23.

simpl ge_of in H23. auto.

}

split.

2:{ simpl.

split; [ | reflexivity].

apply MATCH.

}

{

rewrite (age_jm_dry H20x) in H15.

unfold func_tycontext'.

unfold construct_rho.



clear - H0 TC2 TC3 H18 H16 H21 H15 H23 H17 H17' H13.

unfold rho3 in *. simpl in *. destruct H23.

destruct rho. inv H0. simpl in *.

remember (split (fn_params f)). destruct p.

assert (TE := TC3).

 destruct TC3 as [TC3 TC3'].

destruct TC3 as [TC3 [TC4 TC5]].

simpl in *. if_tac in H16; try congruence. clear H0.

eapply semax_call_typecheck_environ with (jm := jmx); try eassumption.

erewrite <- age_jm_dry by eauto; auto.

destruct TE; intros; auto.

}

normalize.

split; auto. unfold rho3 in H23. unfold construct_rho. rewrite H0 in H23.

simpl ge_of in H23. auto.

unfold bind_args.

unfold tc_formals.

normalize.

rewrite <- sepcon_assoc.

normalize.

split.

hnf.

{

subst fsig.

destruct TC3 as [TC3 _].

clear - TC3 TC2 H21 H17.

simpl in *.

rewrite list_norepet_app in H17. destruct H17 as [H17 [_ _]].

forget (create_undef_temps (fn_temps f)) as te.

revert  bl te TC2 H21 H17.

induction (fn_params f); simpl; intros; auto.

destruct a. destruct (split l) eqn:?. simpl. simpl @snd in *. simpl @fst in *.

destruct bl; try solve [inv H21].

simpl in H21.

unfold_lift in H21.

inv H17.

unfold tc_exprlist in TC2;

simpl in TC2. repeat rewrite denote_tc_assert_andp in TC2.

destruct TC2. destruct H.

set (te1 := PTree.set i (force_val (sem_cast (typeof e) t (eval_expr e rho))) te) in *.

specialize (IHl bl te1 H0 H21 H2).

split; auto.

assert (eval_id i (construct_rho (filter_genv psi) ve' te') =

             force_val (sem_cast (typeof e) t (eval_expr e rho))). {

clear - H21 H1.

forget (force_val (sem_cast (typeof e) t (eval_expr e rho))) as v.

unfold te1 in *; clear te1.

forget (eval_exprlist l1 bl rho) as dl.

assert ((PTree.set i v te) ! i = Some v).

apply PTree.gss.

forget  (PTree.set i v te) as te0.

revert te0 H1 dl H21 H; induction l; simpl; intros.

unfold eval_id. simpl. destruct dl; inv H21.

unfold make_tenv, Map.get. rewrite H. reflexivity.

destruct a.

destruct dl; try solve [inv H21].

eapply IHl.

contradict H1; auto.

eassumption.

rewrite PTree.gso; auto.

}

rewrite H4.

eapply tc_val_sem_cast; eassumption.

}

{

forget (F0 rho * F rho) as Frame.

subst fsig.

rewrite @snd_split in *.

simpl @fst in *.

 apply (alloc_juicy_variables_age H13 H20x) in AJV.

 forget (fn_params f) as params.

 forget (eval_exprlist (map snd params) bl rho) as args.

 clear - H21 H14 AJV H17 H17' H0 Hvars HGG COMPLETE.

 assert (app_pred (Frame * close_precondition params (fn_vars f) (P ts x)

                               (construct_rho (filter_genv psi) ve' te')) (m_phi jmx)).

 eapply sepcon_derives; try apply H14; auto.

 subst rho.

 eapply make_args_close_precondition; eauto.

 apply list_norepet_app in H17; intuition.

 clear H14.

 forget (Frame *

     close_precondition params (fn_vars f) (P ts x)

       (construct_rho (filter_genv psi) ve' te')) as Frame2.

 clear - H17' H21 AJV H Hvars HGG COMPLETE.

 rewrite HGG. change (stackframe_of' cenv_cs) with stackframe_of.

 eapply alloc_juicy_variables_lem2; eauto.

 unfold var_sizes_ok in Hvars;

 rewrite Forall_forall in Hvars, COMPLETE |- *.

 intros.

 specialize (COMPLETE x H0).

 specialize (Hvars x H0).

 rewrite <- HGG; auto.

}



}

replace n with (level jm'').

eapply assert_safe_jsafe, own.bupd_mono, H19.

intros ? Hsafe ?? Hora0 ??.

subst; specialize (Hsafe ora0 _ Hora0 eq_refl eq_refl).

clear - Hsafe.

destruct (level (m_phi jm0)); simpl in *. constructor.

inv Hsafe. econstructor; eauto. inv H0. inv H. split; auto.

simpl in *. congruence.

simpl in *. unfold cl_halted in H. contradiction.

apply age_level in H20x.

rewrite <- level_juice_level_phi in *; congruence.

Qed.



Lemma func_at_func_at':

 forall fs loc, func_at fs loc |-- func_at' fs loc.

Proof.

unfold func_at, func_at'; destruct fs; intros. hnf; intros.

eexists; eauto.

Qed.



Lemma semax_call:

  forall Delta (A: TypeTree)

  (P Q : forall ts, dependent_type_functor_rec ts (AssertTT A) mpred)

  (NEP: super_non_expansive P) (NEQ: super_non_expansive Q)

  (ts: list Type) (x : dependent_type_functor_rec ts A mpred)

   F ret argsig retsig cc a bl,

           Cop.classify_fun (typeof a) =

           Cop.fun_case_f (type_of_params argsig) retsig cc ->

            (retsig = Tvoid -> ret = None) ->

          tc_fn_return Delta ret retsig ->

  semax Espec Delta

       (fun rho => (|>(tc_expr Delta a rho && tc_exprlist Delta (snd (split argsig)) bl rho))  &&

           (func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ) (eval_expr a rho) &&

          (|>(F rho * P ts x (make_args (map (@fst  _ _) argsig)

                (eval_exprlist (snd (split argsig)) bl rho) rho )))))

         (Scall ret a bl)

         (normal_ret_assert

          (fun rho => (EX old:val, substopt ret old F rho * maybe_retval (Q ts x) retsig ret rho))).

Proof.

rewrite semax_unfold. intros ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? TCF TC5 TC7.

intros.

rename H0 into H1.

intros tx vx.

intros ? ? ? ? [[TC3 ?] ?].

assert (H0': necR w (level a')).

apply nec_nat. apply necR_level in H2. apply le_trans with (level y); auto.

eapply pred_nec_hereditary in H1; [ | apply H0'].

eapply pred_nec_hereditary in Prog_OK; [ | apply H0'].

clear w H0' H0 y H2.

rename a' into w.



rewrite !later_andp in H3.

apply extend_sepcon_andp in H3; auto.

destruct H3 as [H2 H3].

normalize in H3. unfold func_ptr in *.

destruct H3 as [[b [H3 H6]] H5].

generalize H4; intros [_ H7].

destruct (level w) eqn: Hl.

{ apply own.bupd_intro; repeat intro.

  rewrite Hl; constructor. }

rewrite <- Hl in *.

destruct (levelS_age w n) as (w' & Hage & Hw'); auto.

specialize (H7 (b) (mk_funspec (argsig,retsig) cc A P Q NEP NEQ) _ (necR_refl _)).

spec H7.

1: apply func_at_func_at'; apply H6.

destruct H7 as [id [H7 H9]].

hnf in H9.

destruct H2 as [TC1 TC2].

generalize H9; intros [fs H8].

generalize H4; intros [H10 _].

specialize (H10 id fs _ (necR_refl _) H8).

destruct H10 as [v' [H10 H13]].

assert (H11: filter_genv psi = ge_of (construct_rho (filter_genv psi) vx tx)) by reflexivity.

simpl in H10. simpl in H7. inversion2 H7 H10.

unfold func_at in H13.



destruct fs as [fsig' cc' A' P' Q' NEP' NEQ'].

hnf in H6,H13.

inversion2 H13 H6.

apply inj_pair2 in H14. rename H14 into H15.

pose (H6:=True).

clear H9; pose (H9:=True).



unfold filter_genv in H7.

remember (construct_rho (filter_genv psi) vx tx) as rho.

set (args := eval_exprlist (snd (split argsig)) bl rho).

fold args in H5.

rename H11 into H10'.



destruct (function_pointer_aux A' P P' Q Q' w NEP NEQ NEP' NEQ') as [H10 H11].

f_equal; auto.

clear H15.

specialize (H10 ts x (make_args (map (@fst  _ _) argsig) (eval_exprlist (snd (split argsig))bl rho) rho)).

specialize (H11 ts x).

assert (H14: app_pred (|> (F0 rho * F rho * P' ts x (make_args (map (@fst  _ _) argsig)

  (eval_exprlist (snd (split argsig)) bl rho) rho))) w).

{

  do 3 red in H10.

  apply eqp_later1 in H10.

  apply pred_eq_e2 in H10.

  rewrite later_sepcon.

  eapply (sepcon_subp' (|>(F0 rho * F rho)) _ (|> P ts x (make_args (map (@fst  _ _) argsig) (eval_exprlist (snd (split argsig)) bl rho) rho)) _ (level w)); eauto.

  rewrite <- later_sepcon, sepcon_assoc, later_sepcon.

  eapply derives_e, H5.

  apply sepcon_derives, derives_refl; apply now_later.

}

assert (typecheck_environ Delta rho) as TC4.

{

  destruct TC3 as [TC3 TC4].

  eapply typecheck_environ_sub in TC3; [| eauto].

  auto.

}

eapply later_derives in TC2; [|apply (tc_exprlist_sub _ _ _ TS); auto].

eapply later_derives in TC1; [|apply (tc_expr_sub _ _ _ TS); auto].

assert (TC7': tc_fn_return Delta' ret retsig).

{

  clear - TC7 TS.

  hnf in TC7|-*. destruct ret; auto.

  destruct ((temp_types Delta) ! i) eqn:?; try contradiction.

  destruct TS.

  specialize (H i); rewrite Heqo in H. subst t.

  destruct ((temp_types Delta') ! i ).

  destruct H; auto.

  auto.

}

clear TC7.

apply own.bupd_intro; repeat intro; subst.

eapply semax_call_aux; try eassumption;

 try solve [simpl; assumption].

simpl RA_normal.

auto.

Qed.



Lemma semax_call_alt:

 forall Delta (A: TypeTree)

   (P Q : forall ts, dependent_type_functor_rec ts (AssertTT A) mpred)

   (NEP: super_non_expansive P) (NEQ: super_non_expansive Q)

     ts x F ret argsig retsig cc a bl,

           Cop.classify_fun (typeof a) =

           Cop.fun_case_f (type_of_params argsig) retsig cc ->

            (retsig = Tvoid -> ret = None) ->

          tc_fn_return Delta ret retsig ->

  semax Espec Delta

       (fun rho => (|> (tc_expr Delta a rho && tc_exprlist Delta (snd (split argsig)) bl rho))  &&

           (func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ) (eval_expr a rho) &&

          (|>(F rho * P ts x (make_args (map (@fst  _ _) argsig)

                (eval_exprlist (snd (split argsig)) bl rho) rho )))))

         (Scall ret a bl)

         (normal_ret_assert

          (fun rho => (EX old:val, substopt ret old F rho * maybe_retval (Q ts x) retsig ret rho))).

Proof. exact semax_call. Qed.



Lemma semax_call_ext:

   forall (IF_ONLY: False),

     forall Delta P Q ret a tl bl a' bl',

      typeof a = typeof a' ->

      map typeof bl = map typeof bl' ->

      (forall rho,

          !! (typecheck_environ Delta rho) && P rho |--

            tc_expr Delta a rho && tc_exprlist Delta tl bl rho &&

            tc_expr Delta a' rho && tc_exprlist Delta tl bl' rho &&

            !! (eval_expr a rho = eval_expr a' rho /\

                eval_exprlist tl bl rho = eval_exprlist tl bl' rho)) ->

  semax Espec Delta P (Scall ret a bl) Q ->

  semax Espec  Delta P (Scall ret a' bl') Q.

Proof.

intros until 2. intro Hbl. intros.

rewrite semax_unfold in H1|-*.

rename H1 into H2. pose proof I.

intros.

specialize (H2 psi Delta' w TS HGG Prog_OK k F H3 H4).

intros tx vx; specialize (H2 tx vx).

intros ? ? ? ? ?.

specialize (H2 y H5 a'0 H6 H7).

destruct H7 as[[? ?] _].

hnf in H7.

pose proof I.

intros ? J; destruct (H2 _ J) as (? & J' & m' & Hl & Hr & ? & Hsafe); subst.

eexists; split; eauto; exists m'; repeat split; auto.

hnf in Hsafe|-*; intros ?? Hora ??.

specialize (Hsafe ora jm Hora H10).

eapply convergent_controls_jsafe; try apply Hsafe.

reflexivity.

simpl; intros ? ?. unfold cl_after_external. destruct ret0; auto.

reflexivity.

intros.

specialize (Hsafe H11).

destruct H8 as [w1 [w2 [H8' [_ ?]]]]. subst m'.

assert (H8'': extendM w2 a'0) by (eexists; eauto). clear H8'.

remember (construct_rho (filter_genv psi) vx tx) as rho.

assert (H7': typecheck_environ Delta rho).

destruct H7; eapply typecheck_environ_sub; eauto.

destruct H7 as [H7 _].

specialize (H0 rho w2 (conj H7' H8)).

destruct H0 as [[[[TCa TCbl] TCa'] TCbl'] [? ?]].

apply (boxy_e _ _ (extend_tc_expr _ _ _) _ _ H8'') in TCa.

apply (boxy_e _ _ (extend_tc_exprlist _ _ _ _) _ _ H8'') in TCbl.

apply (boxy_e _ _ (extend_tc_expr _ _ _) _ _ H8'') in TCa'.

apply (boxy_e _ _ (extend_tc_exprlist _ _ _ _) _ _ H8'') in TCbl'.

eapply denote_tc_resource with (a'1 := m_phi jm) in TCa; auto.

eapply denote_tc_resource with (a'1 := m_phi jm) in TCa'; auto.

eapply denote_tc_resource with (a'1 := m_phi jm) in TCbl; auto.

eapply denote_tc_resource with (a'1 := m_phi jm) in TCbl'; auto.

assert (forall vf, Clight.eval_expr psi vx tx (m_dry jm) a vf

               -> Clight.eval_expr psi vx tx (m_dry jm) a' vf). {

clear - TCa TCa' H7 H7' H0 Heqrho HGG TS.

intros.

eapply tc_expr_sub in TCa; [| eauto | eauto].

pose proof (eval_expr_relate _ _ _ _ _ _ jm HGG Heqrho H7 TCa).

pose proof (eval_expr_fun H H1). subst vf.

rewrite H0.

eapply eval_expr_relate; eauto.

}

assert (forall tyargs vargs,

             Clight.eval_exprlist psi vx tx (m_dry jm) bl tyargs vargs ->

             Clight.eval_exprlist psi vx tx (m_dry jm) bl' tyargs vargs). {

clear - TS IF_ONLY TCbl TCbl' Hbl H7 H7' H13 Heqrho HGG.

revert bl bl' Hbl TCbl TCbl' H13; induction tl; destruct bl, bl'; simpl; intros; auto;

 try (clear IF_ONLY; contradiction).



 unfold tc_exprlist in TCbl,TCbl'. simpl in TCbl, TCbl'.

repeat rewrite denote_tc_assert_andp in TCbl, TCbl'.

destruct TCbl as [[TCe ?] ?].

destruct TCbl' as [[TCe0 ?] ?].

inversion H; clear H. subst bl0 tyargs vargs.

inversion Hbl; clear Hbl. rewrite <- H5 in *.

eapply (tc_expr_sub _ _ _ TS e rho H7' (m_phi jm)) in TCe.

pose proof (eval_expr_relate _ _ _ _ _ _ _ HGG Heqrho H7 TCe).

pose proof (eval_expr_fun H H6).

repeat rewrite <- cop2_sem_cast in *.

unfold force_val in H1.

rewrite H10 in *.

contradiction IF_ONLY.  

}

destruct H12; split; auto.

inv H12; [eapply step_call_internal | eapply step_call_external ]; eauto.

rewrite <- H; auto.

rewrite <- H; auto.

auto.

Qed.



Lemma call_cont_idem: forall k, call_cont (call_cont k) = call_cont k.

Proof.

induction k; intros.

reflexivity.

destruct a; simpl; auto.

Qed.



Definition cast_expropt (e: option expr) t : environ -> option val :=

 match e with Some e' => `Some (eval_expr (Ecast e' t))  | None => `None end.



Lemma call_cont_current_function:

  forall {k i f e t l}, call_cont k = Kcall i f e t :: l -> current_function k = Some f.

Proof. intros. induction k; try destruct a; simpl in *; inv H; auto.

Qed.



Definition tc_expropt Delta (e: option expr) (t: type) : environ -> mpred :=

   match e with None => `!!(t=Tvoid)

                     | Some e' => denote_tc_assert (typecheck_expr Delta (Ecast e' t))

   end.



Lemma  semax_return:

   forall Delta R ret,

      semax Espec Delta

                (fun rho => tc_expropt Delta ret (ret_type Delta) rho &&

                             RA_return R (cast_expropt ret (ret_type Delta) rho) rho)

                (Sreturn ret)

                R.

Proof.

  intros.

  hnf; intros.

  rewrite semax_fold_unfold.

  intros psi Delta'.

  apply prop_imp_i. intros [TS HGG].

  replace (ret_type Delta) with (ret_type Delta')

    by (destruct TS as [_ [_ [? _]]]; auto).

  apply derives_imp.

  clear n.

  intros w ? k F.

  intros w' ? ?.

  clear H.

  clear w H0.

  rename w' into w.

  destruct H1.

  do 3 red in H.

  intros te ve.

  intros n ? w' ? ?.

  assert (necR w (level w')).

  {

    apply nec_nat.

    apply necR_level in H2.

    apply le_trans with (level n); auto.

  }

  apply (pred_nec_hereditary _ _ _ H4) in H0.

  clear w n H2 H1 H4.

  destruct H3 as [[H3 ?] ?].

  pose proof I.

  remember ((construct_rho (filter_genv psi) ve te)) as rho.

  assert (H1': ((F rho * proj_ret_assert R EK_return (cast_expropt ret (ret_type Delta') rho) rho))%pred w').

  {

    eapply sepcon_derives; try apply H1; auto.

    apply andp_left2; auto.

  }

  assert (TC: (tc_expropt Delta ret (ret_type Delta') rho) w').

  {

    clear - H1. destruct H1 as [w1 [w2 [? [? [? ?]]]]]. intros.

    unfold tc_expropt in *.

    destruct ret; try apply H1.

  apply (boxy_e _ _ (extend_tc_expr _ _ _) w2); auto.

  exists w1; auto.

  }

  clear H1; rename H1' into H1.

  specialize (H0 EK_return (cast_expropt ret (ret_type Delta') rho) te ve).

  specialize (H0 _ (le_refl _) _ (necR_refl _)).

  spec H0.

  {

    rewrite <- Heqrho.

    rewrite proj_frame_ret_assert.

    split; auto.

    split; auto.

    rewrite seplog.sepcon_comm; auto.

  }

  unfold tc_expropt in TC; destruct ret; simpl in TC.

  + eapply own.bupd_mono, bupd_denote_tc, H0; eauto.

    clear TC; intros ? [TC Hsafe] ?? Hora ??.

    specialize (Hsafe ora jm Hora (eq_refl _) H6).

    eapply convergent_controls_jsafe; try apply Hsafe.

    1: simpl; auto.

    1: intros ? ?; simpl; unfold cl_after_external; auto.

    1: simpl; auto.

    intros.

    simpl in H7.

    destruct H7; split; auto.

    revert H7; simpl.

    unfold_lift.

    case_eq (call_cont k); intros.

    - inv H9.

      inv H14.

    - destruct c.

      elimtype False; clear - H7.

       revert l H7; induction k; try destruct a; simpl; intros; try discriminate; eauto.

      elimtype False; clear - H7.

       revert l H7; induction k; try destruct a; simpl; intros; try discriminate; eauto.

      elimtype False; clear - H7.

       revert l H7; induction k; try destruct a; simpl; intros; try discriminate; eauto.

      elimtype False; clear - H7.

       revert l H7; induction k; try destruct a; simpl; intros; try discriminate; eauto.

      destruct l0.

      * clear H0 H2 H8.

        inv H9. fold denote_tc_assert in TC.

        inv H11.

        destruct H17.

        econstructor; try eassumption; simpl.

        2: split; [congruence | eassumption].

        exists (eval_expr e (construct_rho (filter_genv psi) ve te)).

        destruct H3 as [H3' H6].

        assert (typecheck_environ Delta (construct_rho (filter_genv psi) ve te)) as H3

          by (eapply typecheck_environ_sub; eauto).

        assert (TCe: (denote_tc_assert (typecheck_expr Delta e)  (construct_rho (filter_genv psi) ve te)) (m_phi jm)).

        {

          hnf.

          simpl in *.

          rewrite !denote_tc_assert_andp in TC.

          simpl in *; super_unfold_lift.

          destruct TC; auto.

        }

        pose proof tc_expr_sub _ _ _ TS _ _ H3 (m_phi jm) TCe as TCe'.

        split.

        {

          apply eval_expr_relate with (Delta0 := Delta')(m:= jm); auto.

        }

        {

          simpl in H6; rewrite (call_cont_current_function H7) in H6.

          destruct H6 as [_ ?].

          rewrite H6.

          super_unfold_lift.

          rewrite !denote_tc_assert_andp in TC.

          destruct TC as [TC1 TC2]. rewrite H6 in TC2.

          rewrite cop2_sem_cast'; auto.

          2: eapply typecheck_expr_sound; eauto.

          apply cast_exists with (Delta0 := Delta)(phi := m_phi jm); auto.

        }

      * fold denote_tc_assert in TC.

        inv H9.

        symmetry in H14; inv H14.

        destruct H20.

        subst te''. clear H6.

        econstructor; try eassumption; [| simpl; auto].

        exists (eval_expr e (construct_rho (filter_genv psi) ve te)).

        destruct H3 as [H3' H6].

        assert (typecheck_environ Delta (construct_rho (filter_genv psi) ve te)) as H3

          by (eapply typecheck_environ_sub; eauto).

        assert (TCe: (denote_tc_assert (typecheck_expr Delta e)  (construct_rho (filter_genv psi) ve te)) (m_phi jm)).

        {

          hnf.

          simpl in *.

          rewrite !denote_tc_assert_andp in TC.

          simpl in *; super_unfold_lift.

          destruct TC; auto.

        }

        pose proof tc_expr_sub _ _ _ TS _ _ H3 (m_phi jm) TCe as TCe'.

        split.

        {

          apply eval_expr_relate with (Delta0 := Delta); auto.

        }

        {

          simpl in H6; rewrite (call_cont_current_function H7) in H6.

          destruct H6 as [_ ?].

          rewrite !denote_tc_assert_andp in TC.

          destruct TC as [TC1 TC2]. rewrite H6 in TC2.

          rewrite cop2_sem_cast'; auto.

          2: eapply typecheck_expr_sound; eauto.

          apply cast_exists with (Delta0 := Delta)(phi := m_phi jm); auto.

        }

  + eapply own.bupd_mono, H0; eauto.

    intros ? Hsafe ?? Hora ??.

    specialize (Hsafe ora jm Hora (eq_refl _) H6).

    eapply convergent_controls_jsafe; try apply Hsafe.

    1: simpl; auto.

    1: intros ? ?; simpl; unfold cl_after_external; auto.

    1: simpl; auto.

    intros.

    destruct H7; split; auto.

    inv H7.

    rewrite call_cont_idem in H13; auto.

    econstructor; try eassumption.

    auto.

Qed.



End extensions.

