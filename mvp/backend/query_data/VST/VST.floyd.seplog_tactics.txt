Require Import VST.floyd.base.
(* VST.floyd.base:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.veric.juicy_extspec.
Require Import VST.veric.NullExtension.
Require Export VST.floyd.jmeq_lemmas.
Require Export VST.floyd.find_nth_tactic.
Require Export VST.floyd.val_lemmas.
Require Export VST.floyd.assert_lemmas.
Require VST.floyd.SeparationLogicAsLogicSoundness.
Export SeparationLogicAsLogicSoundness.MainTheorem.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Defs.

Local Open Scope logic.

Definition extract_exists_pre:
  forall {CS: compspecs} {Espec: OracleKind},
  forall (A : Type) (P : A -> environ->mpred) c (Delta: tycontext) (R: ret_assert),
  (forall x, @semax CS Espec Delta (P x) c R) ->
   @semax CS Espec Delta (EX x:A, P x) c R
  := @semax_extract_exists.

Arguments alignof_two_p {env} t.

Lemma co_alignof_pos: forall co, (co_alignof co > 0)%Z.

Section GET_CO.

Context {cs: compspecs}.

Open Scope Z.

Definition co_default (s: struct_or_union): composite.

Definition get_co id :=
  match cenv_cs ! id with
  | Some co => co
  | _ => co_default Struct
  end.

Lemma co_default_consistent: forall su, composite_consistent cenv_cs (co_default su).

Lemma get_co_consistent: forall id, composite_consistent cenv_cs (get_co id).

Lemma get_co_members_nil_sizeof_0: forall id,
  co_members (get_co id) = nil -> co_sizeof (get_co id) = 0%Z.

Lemma get_co_members_no_replicate: forall id,
  members_no_replicate (co_members (get_co id)) = true.

Lemma sizeof_Tstruct: forall id a,
  sizeof (Tstruct id a) = co_sizeof (get_co id).

Lemma sizeof_Tunion: forall id a,
  sizeof (Tunion id a) = co_sizeof (get_co id).

End GET_CO.

Lemma co_members_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_members (@get_co cs_from id) = co_members (@get_co cs_to id).

Lemma co_sizeof_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_sizeof (@get_co cs_from id) = co_sizeof (@get_co cs_to id).

Definition member_dec: forall (it0 it1: ident * type), {it0 = it1} + {it0 <> it1}.

Fixpoint fold_right_sepcon (l: list mpred) : mpred :=
 match l with
 | nil => emp
 | b::r => b * fold_right_sepcon r
 end.

Inductive LLRR : Type :=
  | LLLL : LLRR
  | RRRR : LLRR. *)

Require Import VST.floyd.val_lemmas.
(* VST.floyd.val_lemmas:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.floyd.functional_base.

Lemma is_int_dec i s v: {is_int i s v} + {~ is_int i s v}.

Lemma tc_val_dec t v: {tc_val t v} + {~ tc_val t v}.

Lemma sem_add_pi_ptr:
   forall {cs: compspecs}  t p i si,
    isptr p ->
    match si with
    | Signed => Int.min_signed <= i <= Int.max_signed
Hint Rewrite @sem_add_pi_ptr using (solve [auto with norm]) : norm.

Lemma sem_cast_i2i_correct_range: forall sz s v,
  is_int sz s v -> sem_cast_i2i sz s v = Some v.
Hint Rewrite sem_cast_i2i_correct_range using (solve [auto with norm]) : norm.

Lemma sem_cast_neutral_ptr:
  forall p, isptr p -> sem_cast_pointer p = Some p.
Hint Rewrite sem_cast_neutral_ptr using (solve [auto with norm]): norm.

Lemma sem_cast_neutral_Vint: forall v,
  sem_cast_pointer (Vint v) = Some (Vint v).
Hint Rewrite sem_cast_neutral_Vint : norm.

Definition isVint v := match v with Vint _ => True | _ => False end.

Lemma is_int_is_Vint: forall i s v, is_int i s v -> isVint v.

Lemma is_int_I32_Vint: forall s v, is_int I32 s (Vint v).
Hint Resolve is_int_I32_Vint.

Lemma sem_cast_neutral_int: forall v,
  isVint v ->
  sem_cast_pointer v = Some v.

Hint Rewrite sem_cast_neutral_int using
  (auto;
   match goal with H: is_int ?i ?s ?v |- isVint ?v => apply (is_int_is_Vint i s v H) end) : norm.

Lemma sizeof_tuchar: forall {cs: compspecs}, sizeof tuchar = 1%Z.
Hint Rewrite @sizeof_tuchar: norm.

Hint Rewrite Z.mul_1_l Z.mul_1_r Z.add_0_l Z.add_0_r Z.sub_0_r : norm.

Hint Rewrite eval_id_same : norm.
Hint Rewrite eval_id_other using solve [clear; intro Hx; inversion Hx] : norm.
Hint Rewrite Int.sub_idem Int.sub_zero_l  Int.add_neg_zero : norm.
Hint Rewrite Ptrofs.sub_idem Ptrofs.sub_zero_l  Ptrofs.add_neg_zero : norm.

Lemma eval_expr_Etempvar:
  forall {cs: compspecs}  i t, eval_expr (Etempvar i t) = eval_id i.
Hint Rewrite @eval_expr_Etempvar : eval.

Lemma eval_expr_binop: forall {cs: compspecs}  op a1 a2 t, eval_expr (Ebinop op a1 a2 t) =
          `(eval_binop op (typeof a1) (typeof a2)) (eval_expr a1) (eval_expr a2).
Hint Rewrite @eval_expr_binop : eval.

Lemma eval_expr_unop: forall {cs: compspecs} op a1 t, eval_expr (Eunop op a1 t) =
          lift1 (eval_unop op (typeof a1)) (eval_expr a1).
Hint Rewrite @eval_expr_unop : eval.

Hint Resolve  eval_expr_Etempvar.

Lemma eval_expr_Etempvar' : forall {cs: compspecs}  i t, eval_id i = eval_expr (Etempvar i t).
Hint Resolve  @eval_expr_Etempvar'.

Hint Rewrite Int.add_zero  Int.add_zero_l Int.sub_zero_l : norm.
Hint Rewrite Ptrofs.add_zero  Ptrofs.add_zero_l Ptrofs.sub_zero_l : norm.

Lemma eval_var_env_set:
  forall i t j v (rho: environ), eval_var i t (env_set rho j v) = eval_var i t rho.
Hint Rewrite eval_var_env_set : norm.

Lemma eval_expropt_Some: forall {cs: compspecs}  e, eval_expropt (Some e) = `Some (eval_expr e).
Lemma eval_expropt_None: forall  {cs: compspecs} , eval_expropt None = `None.
Hint Rewrite @eval_expropt_Some @eval_expropt_None : eval.

Lemma deref_noload_tarray:
  forall ty n, deref_noload (tarray ty n) = (fun v => v).
Hint Rewrite deref_noload_tarray : norm.

Lemma deref_noload_Tarray:
  forall ty n a, deref_noload (Tarray ty n a) = (fun v => v).
Hint Rewrite deref_noload_Tarray : norm.

Lemma flip_lifted_eq:
  forall (v1: environ -> val) (v2: val),
    `eq v1 `(v2) = `(eq v2) v1.
Hint Rewrite flip_lifted_eq : norm.

Lemma isptr_is_pointer_or_null:
  forall v, isptr v -> is_pointer_or_null v.
Hint Resolve isptr_is_pointer_or_null.

Definition add_ptr_int  {cs: compspecs}  (ty: type) (v: val) (i: Z) : val :=
           eval_binop Cop.Oadd (tptr ty) tint v (Vint (Int.repr i)).

Lemma add_ptr_int_offset:
  forall  {cs: compspecs}  t v n,
  repable_signed (sizeof t) ->
  repable_signed n ->
  add_ptr_int t v n = offset_val (sizeof t * n) v.
Abort. 

Lemma typed_false_cmp:
  forall op i j ,
   typed_false tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp (negate_comparison op) i j = true.

Lemma typed_true_cmp:
  forall op i j,
   typed_true tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp op i j = true.

Definition Zcmp (op: comparison) : Z -> Z -> Prop :=
 match op with
 | Ceq => eq
 | Cne => (fun i j => i<>j)
 | Clt => Z.lt
 | Cle => Z.le
 | Cgt => Z.gt
 | Cge => Z.ge
 end.

Lemma int_cmp_repr:
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = true ->

Lemma typed_false_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_false tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Lemma typed_true_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_true tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Ltac intcompare H :=
 (apply typed_false_cmp_repr in H || apply typed_true_cmp_repr in H);
   [ simpl in H | auto; unfold repable_signed, Int.min_signed, Int.max_signed in *; omega .. ].

Lemma isptr_deref_noload:
 forall t p, access_mode t = By_reference -> isptr (deref_noload t p) = isptr p.
Hint Rewrite isptr_deref_noload using reflexivity : norm.

Definition headptr (v: val): Prop :=
  exists b,  v = Vptr b Ptrofs.zero.

Lemma headptr_isptr: forall v,
  headptr v -> isptr v.
Hint Resolve headptr_isptr.

Lemma headptr_offset_zero: forall v,
  headptr (offset_val 0 v) <->
  headptr v.

Lemma typed_false_ptr:
  forall {t a v},  typed_false (Tpointer t a) v -> v=nullval.

Lemma typed_true_ptr:
  forall {t a v},  typed_true (Tpointer t a) v -> isptr v.

Lemma int_cmp_repr':
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = false ->

Lemma typed_false_of_bool:
 forall x, typed_false tint (Val.of_bool x) -> (x=false).

Lemma typed_true_of_bool:
 forall x, typed_true tint (Val.of_bool x) -> (x=true).

Lemma typed_false_tint:
 Archi.ptr64=false -> 

Lemma typed_false_tlong:
 Archi.ptr64=true -> 

Lemma typed_true_e:
 forall t v, typed_true t v -> v<>nullval.

Lemma typed_false_tint_Vint:
  forall v, typed_false tint (Vint v) -> v = Int.zero.

Lemma typed_true_tint_Vint:
  forall v, typed_true tint (Vint v) -> v <> Int.zero.

Lemma typed_true_tlong_Vlong:
  forall v, typed_true tlong (Vlong v) -> v <> Int64.zero.

Ltac intro_redundant_prop :=
  
match goal with |- ?P -> _ =>
  ((assert P by immediate; fail 1) || fail 1) || intros _
end.

Ltac fancy_intro aggressive :=
 match goal with
 | |- ?P -> _ => match type of P with Prop => idtac end
 | |- ~ _ => idtac
 end;
 let H := fresh in
 intro H;
 try simple apply ptr_eq_e in H;
 try simple apply Vint_inj in H;
 try match type of H with
 | tc_val _ _ => unfold tc_val in H; try change (eqb_type _ _) with false in H; cbv iota in H
 end;
 match type of H with
 | ?P => clear H; 
              match goal with H': P |- _ => idtac end 
             + (((assert (H:P) by (clear; immediate); fail 1) || fail 1) || idtac)
                
 | ?x = ?y => constr_eq aggressive true;
                     first [subst x | subst y
                             | is_var x; rewrite H
                             | is_var y; rewrite <- H
                             | idtac]
 | headptr (_ ?x) => let Hx1 := fresh "HP" x in
                     let Hx2 := fresh "P" x in
                       rename H into Hx1;
                       pose proof headptr_isptr _ Hx1 as Hx2
 | headptr ?x => let Hx1 := fresh "HP" x in
                 let Hx2 := fresh "P" x in
                   rename H into Hx1;
                   pose proof headptr_isptr _ Hx1 as Hx2
 | isptr ?x => let Hx := fresh "P" x in rename H into Hx
 | is_pointer_or_null ?x => let Hx := fresh "PN" x in rename H into Hx
 | typed_false _ _ =>
        first [simple apply typed_false_of_bool in H
               | apply typed_false_tint_Vint in H
               | apply (typed_false_tint (eq_refl _)) in H
               | apply (typed_false_tlong (eq_refl _)) in H
               | apply typed_false_ptr in H
               | idtac ]
 | typed_true _ _ =>
        first [simple apply typed_true_of_bool in H
               | apply typed_true_tint_Vint in H
               | apply typed_true_tlong_Vlong in H

               | apply typed_true_ptr in H
               | idtac ]
 
 | _ => try solve [discriminate H]
 end.

Ltac fancy_intros aggressive :=
 repeat match goal with
  | |- (_ <= _ < _) -> _ => fancy_intro aggressive
  | |- (_ < _ <= _) -> _ => fancy_intro aggressive
  | |- (_ <= _ <= _) -> _ => fancy_intro aggressive
  | |- (_ < _ < _) -> _ => fancy_intro aggressive
  | |- (?A /\ ?B) -> ?C => apply (@and_ind A B C) 
  | |- _ -> _ => fancy_intro aggressive
  end.

Ltac fold_types :=
 fold noattr tuint tint tschar tuchar;
 repeat match goal with
 | |- context [Tpointer ?t noattr] =>
      change (Tpointer t noattr) with (tptr t)
 | |- context [Tarray ?t ?n noattr] =>
      change (Tarray t n noattr) with (tarray t n)
 end.

Ltac fold_types1 :=
  match goal with |- _ -> ?A =>
  let a := fresh "H" in set (a:=A); fold_types; subst a
  end.

Lemma is_int_Vbyte: forall c, is_int I8 Signed (Vbyte c).
Hint Resolve is_int_Vbyte. *)

Local Open Scope logic.



Hint Rewrite <- prop_and : gather_prop.



Lemma gather_prop_left {A}{NA: NatDed A}:

  forall P Q R,  !! P && (!! Q && R) = !!(P/\Q) && R.

Proof. intros. rewrite <- andp_assoc. rewrite <- prop_and; auto.

Qed.



Lemma gather_prop_right {A}{NA: NatDed A}:

  forall P Q R,  R && !! P && !! Q = !!(P/\Q) && R.

Proof. intros. rewrite andp_assoc. rewrite andp_comm.  rewrite <- prop_and; auto.

Qed.

Hint Rewrite gather_prop_left gather_prop_right : gather_prop.



Lemma andp_in_order1 {A}{NA: NatDed A}:

  forall P Q, P && Q = P && (P --> Q).

Proof.

  intros.

  apply pred_ext.

  + apply andp_derives; auto.

    apply imp_andp_adjoint.

    apply andp_left1; auto.

  + apply andp_right.

    - apply andp_left1; auto.

    - apply modus_ponens.

Qed.



Lemma andp_in_order2 {A}{NA: NatDed A}:

  forall P Q, P && Q = Q && (Q --> P).

Proof.

  intros.

  rewrite (andp_comm P Q).

  apply andp_in_order1.

Qed.



Lemma andp_right1{A}{NA: NatDed A}:

  forall P Q R, P |-- Q -> P && Q |-- R -> P |-- Q && R.

Proof.

  intros.

  rewrite andp_in_order1.

  apply andp_right; auto.

  apply imp_andp_adjoint; auto.

Qed.



Lemma andp_right2{A}{NA: NatDed A}:

  forall P Q R, P |-- R -> P && R |-- Q -> P |-- Q && R.

Proof.

  intros.

  rewrite andp_comm.

  apply andp_right1; auto.

Qed.



Definition not_a_prop {A} (P: A) := True.



Ltac not_a_prop := match goal with

  | |- not_a_prop  (prop _) => fail 1

  | |- _ => apply Coq.Init.Logic.I

end.



Lemma flip_prop {A}{NA: NatDed A}: forall P Q,

      not_a_prop P -> (P&& !! Q = !! Q && P).

Proof. intros. apply andp_comm. Qed.



Hint Rewrite @flip_prop using not_a_prop : gather_prop.



Lemma gather_prop3 {A}{NA: NatDed A}:

  forall P Q R,  not_a_prop R -> not_a_prop Q -> R && (!! P && Q) = !!P && (R && Q).

Proof. intros. rewrite andp_comm. rewrite andp_assoc.

        rewrite (andp_comm Q); auto.

Qed.



Hint Rewrite @gather_prop3 using not_a_prop : gather_prop.



Lemma gather_prop4 {A}{NA: NatDed A}:

  forall P Q R,  not_a_prop R -> not_a_prop Q -> (!!P && R) && Q = !!P && (R && Q).

Proof. intros. rewrite andp_assoc. auto.

Qed.

Hint Rewrite @gather_prop4 using not_a_prop : gather_prop.



Lemma gather_prop5 {A}{NA: NatDed A}:

  forall P Q R,  not_a_prop R -> not_a_prop Q -> (R && !!P && Q) = !!P && (R && Q).

Proof. intros. rewrite andp_assoc. rewrite andp_comm. rewrite andp_assoc.

  f_equal; apply andp_comm.

Qed.

Hint Rewrite @gather_prop5 using not_a_prop : gather_prop.



Hint Rewrite @sepcon_andp_prop @sepcon_andp_prop' : gather_prop.



Lemma go_lower_lem1:

  forall (P1 P: Prop) (QR PQR: mpred),

      (P1 -> prop P && QR |-- PQR) ->

      (prop (P1 /\ P ) && QR |-- PQR).

Proof.

 intros.

 apply derives_extract_prop; intros [? ?].

 apply derives_trans with (!!P && QR).

 apply andp_right; auto. apply prop_right; auto.

 apply H; auto.

Qed.



Lemma go_lower_lem1':

  forall (P1 P2 P: Prop) (QR PQR: mpred),

      (prop (P1 /\ (P2 /\ P)) && QR |-- PQR) ->

      (prop ((P1 /\ P2) /\ P ) && QR |-- PQR).

Proof.

 intros.

 eapply derives_trans;  [ | apply H].

 apply andp_derives; auto.

 apply prop_derives; intuition.

Qed.



Hint Extern 2 (?A |-- ?B) => (constr_eq A B; simple apply derives_refl) : cancel.

Hint Extern 2 (?A |-- |> ?B) => (constr_eq A B; simple apply now_later) : cancel.



Lemma cancel1_start:

 forall P Q : mpred,

   P |-- Q * emp ->

   P |-- Q.

Proof. Set Printing All. intros. rewrite sepcon_emp in H; auto.

Qed.



Lemma cancel1_here:

  forall P P' Q1 Q2 Q3 : mpred,

  P' |-- Q2 ->

  P |-- Q1 * Q3 ->

  P * P' |-- Q1 * Q2 * Q3.

Proof.

intros. rewrite (sepcon_comm Q1).

rewrite sepcon_assoc.  rewrite sepcon_comm. apply sepcon_derives; auto.

Qed.



Lemma cancel1_next:

  forall P Q1 Q2 Q3 : mpred,

   P |-- Q1 * (Q2 * Q3) ->

   P |-- Q1 * Q2 * Q3.

Proof. intros. rewrite sepcon_assoc; auto. Qed.



Lemma cancel1_last:

  forall P P' Q2 Q3 : mpred,

  P' |-- Q2 ->

  P |-- Q3 ->

  P * P' |-- Q2 * Q3.

Proof.

 intros. rewrite sepcon_comm; apply sepcon_derives; auto.

Qed.



Lemma cancel1_finish1:

  forall P Q1 Q2 Q3 : mpred,

   P |-- Q1 * Q2 * Q3 ->

   P |-- Q1 * (Q2 * Q3).

Proof.

 intros. rewrite <- sepcon_assoc. auto.

Qed.



Lemma cancel1_finish2:

  forall P Q : mpred,

    P |-- Q ->

   P |-- Q * emp.

Proof. intros. rewrite sepcon_emp; auto.

Qed.



Ltac cancel1 :=

 first [

   simple apply cancel1_here; [

    try match goal with H := _ : list mpred |- _ => clear H end; 


    solve [eauto with nocore cancel]

   | ]

 | simple apply cancel1_next; cancel1

 | simple apply cancel1_last; [

    try match goal with H := _ : list mpred |- _ => clear H end; 


    solve [eauto with nocore cancel] | ]

 ].



Ltac cancel2 :=

  simple apply cancel1_start;

  cancel1;

  repeat simple apply cancel1_finish1;

  try simple apply cancel1_finish2.



Ltac lift1 a e1 rho  :=

 match e1 with

 | lift0 rho => constr:(a)

 | lift0 ?a1 => constr: (lift0 (a a1))

 | _ => constr:(lift1 a e1)

 end.



Ltac lift2 a e1 e2 rho :=

 match e1 with

 |  lift0 ?a1 => lift1 (a a1) e2 rho

 | _ => constr:(lift2 a e1 e2)

 end.



Ltac lift3 a e1 e2 e3 rho :=

 match e1 with

 |  lift0 ?a1 => lift2 (a a1) e2 e3 rho

 | _ => constr:(lift3 a e1 e2 e3)

 end.



Ltac lift4 a e1 e2 e3 e4 rho :=

 match e1 with

 |  lift0 ?a1 => lift3 (a a1) e2 e3 e4 rho

 | _ => constr:(lift4 a e1 e2 e3 e4)

 end.



Ltac abstract_env rho P :=

  match P with

   | @emp mpred _ _ => constr:(@emp (environ->mpred) _ _)

   | @sepcon mpred _ _ ?e1 ?e2 =>

      let e1' := abstract_env rho e1 in let e2' := abstract_env rho e2

       in constr:(@sepcon (environ->mpred) _ _ e1' e2')

   | ?a0 ?a1 ?a2 ?e1 ?e2 ?e3 ?e4 =>

      let e1' := abstract_env rho e1  in let e2' := abstract_env rho e2 in let e3' := abstract_env rho e3 in let e4' := abstract_env rho e4

      in lift3 (a0 a1 a2) e1' e2' e3' e4' rho

   | ?a0 ?a1 ?e1 ?e2 ?e3 ?e4 =>

      let e1' := abstract_env rho e1 in let e2' := abstract_env rho e2 in let e3' := abstract_env rho e3 in let e4' := abstract_env rho e4

      in lift3 (a0 a1) e1' e2' e3' e4' rho

   | ?a0 ?e1 ?e2 ?e3 ?e4 =>

      let e1' := abstract_env rho e1 in let e2' := abstract_env rho e2 in let e3' := abstract_env rho e3 in let e4' := abstract_env rho e4

      in lift4 a0 e1' e2' e3' e4' rho

   | ?a0 ?e1 ?e2 ?e3 =>

      let e1' := abstract_env rho e1 in let e2' := abstract_env rho e2 in let e3' := abstract_env rho e3

      in lift3 a0 e1' e2' e3' rho

   | ?a0 ?e1 ?e2 =>

      let e1' := abstract_env rho e1 in let e2' := abstract_env rho e2

      in lift2 a0 e1' e2' rho

   | ?a0 ?e1 => let e1' := abstract_env rho e1 in lift1 a0 e1' rho

   | rho => constr: (lift1)

   | ?a => constr:(lift0 a)

   end.



Lemma cancel_frame0{A}{ND: NatDed A}{SL: SepLog A}:

  forall rho: environ, emp rho |-- fold_right sepcon emp nil rho.

Proof. intro; apply derives_refl. Qed.



Lemma cancel_frame0_low:

  emp |-- fold_right_sepcon nil.

Proof.  apply derives_refl. Qed.



Lemma cancel_frame2: forall (P Q: environ->mpred) F (rho: environ),

     Q rho |-- 	fold_right sepcon emp F rho ->

    (P * Q) rho |-- fold_right sepcon emp (P::F) rho.

Proof. intros. simpl. apply sepcon_derives; auto.

Qed.



Lemma cancel_frame2_low: forall (P Q: mpred) F,

     Q  |-- fold_right_sepcon F  ->

    (P * Q) |-- fold_right_sepcon (P::F).

Proof. intros. apply sepcon_derives; auto.

Qed.



Lemma cancel_frame1: forall (P: environ->mpred) (rho: environ),

         P rho |-- fold_right sepcon emp (P::nil) rho.

Proof. intros. unfold fold_right. rewrite sepcon_emp; apply derives_refl.

Qed.



Lemma cancel_frame1_low: forall (P: mpred),

         P |-- fold_right_sepcon (P::nil).

Proof. intros. unfold fold_right_sepcon. rewrite sepcon_emp; apply derives_refl.

Qed.



Ltac fixup_lifts :=

 repeat

 match goal with

 | |- context[@lift0 mpred] => change (@lift0 mpred) with (@liftx (LiftEnviron mpred))

 | |- context[@lift1 ?A] => change (@lift1 A mpred) with (@liftx (Tarrow A (LiftEnviron mpred)))

 | |- context[@lift2 ?A ?B] =>  change (@lift2 A B mpred) with (@liftx (Tarrow A (Tarrow B (LiftEnviron mpred))))

 | |- context[@lift3 ?A ?B ?C] => change (@lift3 A B C mpred) with (@liftx (Tarrow A (Tarrow B (Tarrow C (LiftEnviron mpred)))))

 | |- context[@lift4 ?A ?B ?C ?D] => change (@lift4 A B C D mpred) with (@liftx (Tarrow A (Tarrow B (Tarrow C (Tarrow D (LiftEnviron mpred))))))

 end.



Fixpoint fold_right_sepconx (l: list mpred) : mpred :=

match l with

| nil => emp

| a::nil => a

| a::b => a * fold_right_sepconx b

end.



Definition fold_left_sepconx (l: list mpred) : mpred :=

match l with

| nil => emp

| a::l => (fix fold_left_sepconx (a: mpred) (l: list mpred) {struct l}: mpred :=

          match l with

          | nil => a

          | b :: l => fold_left_sepconx (sepcon a b) l

          end) a l

end.



Lemma fold_right_sepconx_eq:

  forall l, fold_right_sepconx l = fold_right_sepcon l.

Proof.

induction l; simpl; auto.

rewrite IHl.

destruct l; simpl; auto. rewrite sepcon_emp; auto.

Qed.



Lemma fold_left_sepconx_eq:

  forall l, fold_left_sepconx l = fold_right_sepcon l.

Proof.

  intros.

  rewrite <- fold_right_sepconx_eq.

  destruct l; auto.

  revert m; induction l; intros.

  + auto.

  + simpl in *.

    rewrite <- IHl.

    clear IHl.

    revert m a; induction l; intros.

    - auto.

    - simpl.

      rewrite sepcon_assoc.

      rewrite IHl.

      auto.

Qed.



Lemma fold_right_sepconx_eqx:

  forall A B, A |-- fold_right_sepconx B -> A |-- fold_right_sepcon B.

Proof.

intros.

rewrite <- fold_right_sepconx_eq; auto.

Qed.



Ltac unfold_right_sepcon A :=

 lazymatch A with

 | (?B * ?C)%logic => let x := unfold_right_sepcon C

                               in let y := constr:(B :: x)

                               in y

 | ?D => let y := constr:(D::nil) in y

end.



Ltac cancel_frame :=

match goal with

| |- _ |-- fold_right_sepcon _  => 

   rewrite !sepcon_assoc; cancel_frame

| F := ?v |- ?A |-- fold_right_sepcon ?F  => 

   is_evar v;

   apply fold_right_sepconx_eqx;

   let w := unfold_right_sepcon A

    in instantiate (1:=w) in (Value of F);

    unfold F;

    unfold fold_right_sepconx;

    simple apply derives_refl



| |- ?P |-- fold_right _ _ ?F ?rho  =>

     let P' := abstract_env rho P in

       change ( P' rho |-- fold_right sepcon emp F rho);

   fixup_lifts; cbv beta;

    repeat rewrite sepcon_assoc;

   repeat match goal with |- (_ * _) _ |-- _ =>

                   apply cancel_frame2

                    end;

    try (unfold F; apply cancel_frame1);

    try (instantiate (1:=nil) in (Value of F); unfold F; apply cancel_frame0)

 end.



Ltac pull_left A :=

 
  repeat match goal with

  | |- context [?Q * ?R * A] => rewrite <- (pull_right A Q R)

  | |- context [?Q * A] => rewrite <- (pull_right0 A Q)

  end.



Lemma cancel_left: forall P Q R: mpred,

   Q |-- R -> P * Q |-- P * R.

Proof.

intros; apply sepcon_derives; auto.

Qed.



Lemma pull_left_special: forall A B C : mpred,

    (B * (A * C)) = (A * (B * C)).

Proof.

intros. rewrite sepcon_comm. rewrite sepcon_assoc. f_equal.

 apply sepcon_comm.

Qed.



Lemma pull_left_special0: forall A B : mpred,

    (B * A) = (A * B).

Proof.

intros; apply sepcon_comm.

Qed.



Ltac qcancel P :=

 lazymatch P with

 | sepcon ?A ?B => 

     match goal with |- _ |-- ?Q =>

       try match Q with context [A] =>

        let a := fresh "A" in set (a:=A);

         rewrite ?(pull_left_special0 a), ?(pull_left_special a);

         apply cancel_left;

         clear a

       end;

       qcancel B

     end

 | ?A => 

     try match goal with |- _ |-- ?Q =>

       lazymatch Q with context [A] =>

        let a := fresh "A" in set (a:=A);

         rewrite ?(pull_left_special0 a), ?(pull_left_special a);

         rewrite ?(pull_left_special0 A), ?(pull_left_special A);

         apply cancel_left;

         clear a

      end

     end

 end.



Ltac is_Type_or_type T :=

  match type of T with

  | Type => idtac

  | type => idtac

  end.



Lemma fun_equal: forall {A B} (f g : A -> B) (x y : A),

  f = g -> x = y -> f x = g y.

Proof. congruence. Qed.



Lemma fun_equal': forall {A B} (f g : forall (x:A), B x) (y : A),

  f = g -> f y = g y.

Proof. congruence. Qed.



Ltac ecareful_unify :=

  match goal with

  | |- ?X = ?X' => first [is_Type_or_type X | is_evar X | is_evar X' | constr_eq X X']; reflexivity

  | |- ?F _ = ?F' _ => first [apply fun_equal | apply fun_equal' with (f := F)]; revgoals; solve[ecareful_unify]

  end; idtac.



Ltac careful_unify :=

  match goal with

  | |- ?X = ?X' => first [is_Type_or_type X | constr_eq X X']; reflexivity

  | |- ?F _ = ?F' _ => first [apply fun_equal | apply fun_equal' with (f := F)]; revgoals; solve[careful_unify]

  end; idtac.



Ltac cancel :=

  rewrite ?sepcon_assoc;

  repeat match goal with |- ?A * _ |-- ?B * _ => 

     constr_eq A B;  simple apply (cancel_left A)

  end;

  match goal with |- ?P |-- _ => qcancel P end;

  repeat first [rewrite emp_sepcon | rewrite sepcon_emp];

  try match goal with |- ?A |-- ?B => 

       constr_eq A B; simple apply (derives_refl A)

  end;

  match goal with |- ?P |-- _ =>

   

   rewrite <- (emp_sepcon P)

  end;

  repeat rewrite <- sepcon_assoc;

  repeat match goal with

    | |- sepcon _ emp |-- _ => fail 1

    | |- sepcon _ TT |-- _ => pull_left (@TT mpred _)

    | |- sepcon _ ?P' |-- _ => first [ cancel2 | pull_left P' ]

   end;

  repeat first [rewrite emp_sepcon | rewrite sepcon_emp];

  pull_left (@TT mpred _);

  first [ simpl; apply derives_refl'; solve [careful_unify]

            
          | apply TT_right

          | apply @sepcon_TT; solve [auto with nocore typeclass_instances]

          | apply @TT_sepcon; solve [auto with nocore typeclass_instances]

          | cancel_frame

          | idtac

          ].



Inductive syntactic_cancel: list mpred -> list mpred -> list mpred -> list mpred -> Prop :=

| syntactic_cancel_nil: forall R, syntactic_cancel R nil R nil

| syntactic_cancel_cons_succeed: forall n R0 R L0 L F Res,

    find_nth_preds (fun R0 => R0 |-- L0) R (Some (n, R0)) ->

    syntactic_cancel (delete_nth n R) L F Res ->

    syntactic_cancel R (L0 :: L) F Res

| syntactic_cancel_cons_fail: forall R L0 L F Res,

    find_nth_preds (fun R0 => R0 |-- L0) R None ->

    syntactic_cancel R L F Res ->

    syntactic_cancel R (L0 :: L) F (L0 :: Res).



Lemma syntactic_cancel_cons: forall nR0 R L0 L F Res,

  find_nth_preds (fun R0 => R0 |-- L0) R nR0 ->

  syntactic_cancel match nR0 with

                   | Some (n, _) => delete_nth n R

                   | None => R

                   end L F Res ->

  syntactic_cancel R (L0 :: L) F (let Res' := Res in

                                 match nR0 with

                                 | Some _ => Res'

                                 | None => L0 :: Res'

                                 end).

Proof.

  intros.

  destruct nR0 as [[? ?]|].

  + eapply syntactic_cancel_cons_succeed; eauto.

  + eapply syntactic_cancel_cons_fail; eauto.

Qed.



Lemma delete_nth_SEP: forall R n R0,

  nth_error R n = Some R0 ->

  fold_right_sepcon R |-- R0 * fold_right_sepcon (delete_nth n R).

Proof.

  intros.

  revert R H; induction n; intros; destruct R; try solve [inv H].

  + inv H.

    simpl.

    auto.

  + simpl in H.

    apply IHn in H.

    simpl.

    rewrite <- sepcon_assoc, (sepcon_comm _ m), sepcon_assoc.

    apply sepcon_derives; auto.

Qed.



Lemma syntactic_cancel_solve1: forall F,

  fold_right_sepcon F |-- fold_right_sepcon nil * fold_right_sepcon F.

Proof.

  intros.

  simpl; rewrite emp_sepcon; auto.

Qed.



Lemma syntactic_cancel_solve2: forall G,

  fold_right_sepcon G |-- fold_right_sepcon nil * TT.

Proof.

  intros.

  simpl; rewrite emp_sepcon.

  apply TT_right.

Qed.



Lemma syntactic_cancel_spec1: forall G1 L1 G2 L2 F,

  syntactic_cancel G1 L1 G2 L2 ->

  fold_right_sepcon G2 |-- fold_right_sepcon L2 * F ->

  fold_right_sepcon G1 |-- fold_right_sepcon L1 * F.

Proof.

  intros.

  revert F H0; induction H; intros.

  + auto.

  + apply IHsyntactic_cancel in H1.

    simpl.

    rewrite sepcon_assoc.

    eapply derives_trans; [| apply sepcon_derives; [apply derives_refl | apply H1]].

    clear IHsyntactic_cancel H1.

    apply find_nth_preds_Some in H.

    destruct H.

    eapply derives_trans; [apply delete_nth_SEP; eauto |].

    apply sepcon_derives; auto.

  + simpl in H1.

    rewrite (sepcon_comm L0), sepcon_assoc in H1.

    apply (IHsyntactic_cancel (L0*F0)) in H1.

    eapply derives_trans; [exact H1 |].

    simpl.

    rewrite <- sepcon_assoc.

    apply sepcon_derives; auto.

    rewrite sepcon_comm; auto.

Qed.



Lemma syntactic_cancel_spec2: forall G1 L1 G2 L2 G3 L3 F,

  syntactic_cancel G1 L1 G2 L2 ->

  syntactic_cancel G2 L2 G3 L3 ->

  fold_right_sepcon G3 |-- fold_right_sepcon L3 * F ->

  fold_right_sepcon G1 |-- fold_right_sepcon L1 * F.

Proof.

  intros.

  eapply syntactic_cancel_spec1; eauto.

  eapply syntactic_cancel_spec1; eauto.

Qed.



Lemma syntactic_cancel_solve3:

  fold_right_sepcon nil |-- fold_right_sepcon nil.

Proof.

  auto.

Qed.



Lemma syntactic_cancel_spec3: forall G1 L1 G2 L2,

  syntactic_cancel G1 L1 G2 L2 ->

  fold_right_sepcon G2 |-- fold_right_sepcon L2 ->

  fold_right_sepcon G1 |-- fold_right_sepcon L1.

Proof.

  intros.

  rewrite <- (sepcon_emp (fold_right_sepcon L1)).

  eapply syntactic_cancel_spec1; eauto.

  rewrite sepcon_emp; auto.

Qed.



Ltac local_cancel_in_syntactic_cancel unify_tac :=

  cbv beta;

  match goal with |- ?A |-- ?B => 

    solve [ constr_eq A B; simple apply (derives_refl A)

          | tryif first [has_evar A | has_evar B] then fail else auto with nocore cancel

          | apply derives_refl'; unify_tac ]

  end.



Ltac syntactic_cancel local_tac :=

  repeat first

         [ simple apply syntactic_cancel_nil

         | simple apply syntactic_cancel_cons;

           [ find_nth local_tac

           | cbv iota; unfold delete_nth; cbv zeta iota

           ]

         ].



Ltac cancel_for_evar_frame' local_tac :=

  eapply syntactic_cancel_spec1;

  [ syntactic_cancel local_tac

  | cbv iota; cbv zeta beta;

    first [ match goal with

            | |- _ |-- _ * fold_right_sepcon ?F => try unfold F

            end;

            simple apply syntactic_cancel_solve1

          | match goal with

            | |- fold_right_sepcon ?A |-- fold_right_sepcon ?B * _ => rewrite <- (fold_left_sepconx_eq A), <- (fold_left_sepconx_eq B)

            end;

            unfold fold_left_sepconx; cbv iota beta ]

  ].



Ltac cancel_for_TT local_tac :=

  eapply syntactic_cancel_spec1;

  [ syntactic_cancel local_tac

  | cbv iota; cbv zeta beta;

    first [ simple apply syntactic_cancel_solve2

          | match goal with

            | |- fold_right_sepcon ?A |-- fold_right_sepcon ?B * _ => rewrite <- (fold_left_sepconx_eq A), <- (fold_left_sepconx_eq B)

            end;

            unfold fold_left_sepconx; cbv iota beta ]

  ].



Ltac cancel_for_normal local_tac :=

  eapply syntactic_cancel_spec3;

  [ syntactic_cancel local_tac

  | cbv iota; cbv zeta beta;

    first [ simple apply syntactic_cancel_solve3

          | match goal with

            | |- fold_right_sepcon ?A |-- fold_right_sepcon ?B => rewrite <- (fold_left_sepconx_eq A), <- (fold_left_sepconx_eq B)

            end;

            unfold fold_left_sepconx; cbv iota beta ]

  ].



Inductive merge_abnormal_mpred: mpred -> option mpred -> option mpred -> Prop :=

| merge_abnormal_mpred_None: forall P, merge_abnormal_mpred P None (Some P)

| merge_abnormal_mpred_TT_Some: forall P, merge_abnormal_mpred TT (Some P) (Some P)

| merge_abnormal_mpred_Some_TT: forall P, merge_abnormal_mpred P (Some TT) (Some P).



Inductive fold_abnormal_mpred: list mpred -> list mpred -> option mpred -> Prop :=

| fold_abnormal_mpred_nil:

    fold_abnormal_mpred nil nil None

| fold_abnormal_mpred_TT: forall R res R' res',

    fold_abnormal_mpred R R' res ->

    merge_abnormal_mpred TT res res' ->

    fold_abnormal_mpred (TT :: R) R' res'

| fold_abnormal_mpred_fold: forall F R res R' res',

    fold_abnormal_mpred R R' res ->

    merge_abnormal_mpred (fold_right_sepcon F) res res' ->

    fold_abnormal_mpred ((fold_right_sepcon F) :: R) R' res'

| fold_abnormal_mpred_normal: forall P R R' res,

    fold_abnormal_mpred R R' res ->

    fold_abnormal_mpred (P :: R) (P :: R') res.



Definition Some_or_emp (res: option mpred) := match res with | Some P => P | _ => emp end.



Lemma merge_abnormal_mpred_spec: forall P res res',

  merge_abnormal_mpred P res res' ->

  Some_or_emp res' |-- P * Some_or_emp res.

Proof.

  intros.

  inv H; simpl.

  + rewrite sepcon_emp; auto.

  + apply TT_sepcon.

  + apply sepcon_TT.

Qed.



Lemma fold_abnormal_mpred_spec: forall R R' res,

  fold_abnormal_mpred R R' res ->

  fold_right_sepcon R' * Some_or_emp res |-- fold_right_sepcon R.

Proof.

  intros.

  induction H; simpl.

  + rewrite emp_sepcon; auto.

  + apply merge_abnormal_mpred_spec in H0.

    eapply derives_trans; [apply sepcon_derives; [apply derives_refl | apply H0] |].

    rewrite <- sepcon_assoc.

    rewrite (sepcon_comm _ TT).

    rewrite sepcon_assoc.

    apply sepcon_derives; auto.

  + apply merge_abnormal_mpred_spec in H0.

    eapply derives_trans; [apply sepcon_derives; [apply derives_refl | apply H0] |].

    rewrite <- sepcon_assoc.

    rewrite (sepcon_comm _ (fold_right_sepcon F)).

    rewrite sepcon_assoc.

    apply sepcon_derives; auto.

  + rewrite sepcon_assoc.

    apply sepcon_derives; auto.

Qed.



Inductive construct_fold_right_sepcon_rec: mpred -> list mpred -> list mpred -> Prop :=

| construct_fold_right_sepcon_rec_sepcon: forall P Q R R' R'',

    construct_fold_right_sepcon_rec Q R R' ->

    construct_fold_right_sepcon_rec P R' R'' ->

    construct_fold_right_sepcon_rec (P * Q) R R''

| construct_fold_right_sepcon_rec_emp: forall R,

    construct_fold_right_sepcon_rec emp R R

| construct_fold_right_sepcon_rec_single: forall P R,

    construct_fold_right_sepcon_rec P R (P :: R).



Local Unset Elimination Schemes. 

Inductive construct_fold_right_sepcon: mpred -> list mpred-> Prop :=

| construct_fold_right_sepcon_constr: forall P R,

    construct_fold_right_sepcon_rec P nil R ->

    construct_fold_right_sepcon P R.

Scheme Minimality for construct_fold_right_sepcon Sort Prop.

Local Set Elimination Schemes.



Lemma construct_fold_right_sepcon_spec: forall P R,

  construct_fold_right_sepcon P R ->

  fold_right_sepcon R = P.

Proof.

  intros.

  destruct H.

  rename R into R'.

  transitivity (fold_right_sepcon nil * P).

  2:{

    simpl.

    rewrite !emp_sepcon.

    auto.

  }

  forget (@nil mpred) as R.

  induction H.

  + etransitivity; [eassumption |].

    transitivity (fold_right_sepcon R * Q * P); [f_equal; eassumption |].

    clear.

    rewrite (sepcon_comm P).

    rewrite !sepcon_assoc; auto.

  + rewrite sepcon_emp; auto.

  + simpl.

    rewrite (sepcon_comm _ P).

    auto.

Qed.



Definition before_symbol_cancel (P Q: list mpred) (res: option mpred): Prop :=

  match res with

  | Some R => fold_right_sepcon P |-- fold_right_sepcon Q * R

  | None => fold_right_sepcon P |-- fold_right_sepcon Q

  end.



Lemma symbolic_cancel_setup: forall P P' Q Q' Q'' Qr,

  construct_fold_right_sepcon P P' ->

  construct_fold_right_sepcon Q Q' ->

  fold_abnormal_mpred Q' Q'' Qr ->

  before_symbol_cancel P' Q'' Qr ->

  P |-- Q.

Proof.

  intros.

  apply construct_fold_right_sepcon_spec in H.

  apply construct_fold_right_sepcon_spec in H0.

  apply fold_abnormal_mpred_spec in H1.

  rewrite <- H, <- H0.

  eapply derives_trans; [| exact H1].

  destruct Qr; auto.

  simpl in H2 |- *.

  rewrite sepcon_emp; auto.

Qed.



Ltac construct_fold_right_sepcon_rec :=

  match goal with

  | |- construct_fold_right_sepcon_rec (sepcon _ _) _ _ =>

         eapply construct_fold_right_sepcon_rec_sepcon;

         [construct_fold_right_sepcon_rec | construct_fold_right_sepcon_rec]

  | |- construct_fold_right_sepcon_rec emp _ _ =>

         apply construct_fold_right_sepcon_rec_emp

  | _ =>

         apply construct_fold_right_sepcon_rec_single

  end.



Ltac merge_abnormal_mpred :=

  first

  [ simple apply merge_abnormal_mpred_None

  | simple apply merge_abnormal_mpred_TT_Some

  | simple apply merge_abnormal_mpred_Some_TT

  | fail 1000 "There should not be two fold_right_sepcon in the right side."

  ].



Ltac construct_fold_right_sepcon :=

  apply construct_fold_right_sepcon_constr;

  construct_fold_right_sepcon_rec.



Ltac is_evar_def F := try first [is_var F; unfold F; fail 1 | fail 2 F "is not evar definition"].



Ltac fold_abnormal_mpred :=

  match goal with

  | |- fold_abnormal_mpred nil _ _ =>

         simple apply fold_abnormal_mpred_nil

  | |- fold_abnormal_mpred (?P :: _) _ _ =>

         match P with

         | TT => simple eapply fold_abnormal_mpred_TT; [fold_abnormal_mpred | merge_abnormal_mpred]

         | prop True => simple eapply fold_abnormal_mpred_TT; [fold_abnormal_mpred | merge_abnormal_mpred]

         | fold_right_sepcon ?F =>

              is_evar_def F;

              simple eapply fold_abnormal_mpred_fold; [fold_abnormal_mpred | merge_abnormal_mpred]

         | _ => simple apply fold_abnormal_mpred_normal; fold_abnormal_mpred

         end

  end.



Ltac new_cancel local_tac :=

  match goal with

  | |- @derives mpred Nveric _ _ => idtac

  | _ => fail 1000 "Tactic cancel can only handle proof goals with form _ |-- _ (unlifted version)."

  end;

  eapply symbolic_cancel_setup;

  [ construct_fold_right_sepcon

  | construct_fold_right_sepcon

  | fold_abnormal_mpred

  | match goal with

    | |- before_symbol_cancel _ _ None =>

           cbv iota beta delta [before_symbol_cancel];

           cancel_for_normal local_tac

    | |- before_symbol_cancel _ _ (Some (fold_right_sepcon _)) =>

           cbv iota beta delta [before_symbol_cancel];

           cancel_for_evar_frame' local_tac

    | |- before_symbol_cancel _ _ (Some TT) =>

           cbv iota beta delta [before_symbol_cancel];

           cancel_for_TT local_tac

    | |- before_symbol_cancel _ _ (Some (prop True)) =>

           cbv iota beta delta [before_symbol_cancel];

           cancel_for_TT local_tac

    end

  ].



Ltac cancel_unify_tac :=

  autorewrite with cancel;

  careful_unify.



Ltac cancel_local_tac :=

  cbv beta;

  match goal with |- ?A |-- ?B =>

    solve [ constr_eq A B; simple apply (derives_refl A)

          | auto with nocore cancel

          | apply derives_refl'; cancel_unify_tac]

  end.



Ltac cancel ::= new_cancel cancel_local_tac.



Ltac no_evar_cancel_local_tac := local_cancel_in_syntactic_cancel cancel_unify_tac.

Ltac no_evar_cancel := new_cancel no_evar_cancel_local_tac.



Ltac ecancel_unify_tac :=

  autorewrite with cancel;

  ecareful_unify.



Ltac ecancel_local_tac := local_cancel_in_syntactic_cancel ecancel_unify_tac.

Ltac pure_ecancel := new_cancel ecancel_local_tac.

Ltac ecancel := no_evar_cancel; pure_ecancel.



Ltac old_local_tac := local_cancel_in_syntactic_cancel careful_unify.

Ltac cancel_for_evar_frame := cancel_for_evar_frame' ecancel_local_tac.



Ltac info_cancel_local_tac :=

  (tryif try (cancel_local_tac; gfail 1)

    then match goal with |- ?Goal => idtac Goal "fail" end

    else match goal with |- ?Goal => idtac Goal "success" end);

  cancel_local_tac.



Ltac info_cancel := new_cancel info_cancel_local_tac.



Ltac info_ecancel_local_tac :=

  (tryif try (ecancel_local_tac; gfail 1)

    then match goal with |- ?Goal => idtac Goal "fail" end

    else match goal with |- ?Goal => idtac Goal "success" end);

  ecancel_local_tac.



Ltac info_ecancel := info_cancel; new_cancel info_ecancel_local_tac.



Ltac apply_find_core X :=

 match X with

 | ?U -> ?V => match type of U with Prop => apply_find_core V end

 | @derives mpred _ _ _ => constr:(X)

 | @eq mpred ?A ?B => constr:(@derives mpred A B)

 end.



Lemma adjust_sep_apply:  forall (Q: mpred) (P: Prop),

   Q |-- !! P ->

   Q |-- !! P && Q.

Proof. intros. apply andp_right; auto. Qed.



Ltac adjust_sep_apply H :=

 match type of H with 

 | _ |-- !! _ => constr:(adjust_sep_apply _ _ H)

 | _ => H

 end.



Ltac adjust2_sep_apply H :=

 let x := adjust_sep_apply H in

 match type of x with

 | @eq mpred _ _ => constr:(derives_refl' _ _ x)

 | _ => x

 end.



Ltac cancel_for_sep_apply := ecancel.



Ltac sep_apply_aux2 H' := 

match type of H' with ?TH =>

     match apply_find_core TH with  ?C |-- ?D =>

      let frame := fresh "frame" in evar (frame: list mpred);

       apply derives_trans with (C * fold_right_sepcon frame);

             [ solve [cancel_for_sep_apply]

             | eapply derives_trans; 

                [apply sepcon_derives; [clear frame; apply H' | apply derives_refl] 

                |  let x := fresh "x" in set (x := fold_right_sepcon frame);

                  subst frame; unfold fold_right_sepcon in x; subst x; 

                  rewrite ?sepcon_emp

                ]

             ]

     end

     end.



Ltac head_of_type_of H :=

 match type of H with ?A => apply_find_core A end.



Ltac sep_apply_aux1 H := 

 let B := head_of_type_of H in

 lazymatch B with

 | ?A |-- _ =>

   lazymatch A with

   | context [!! ?P && _] =>

      let H' := fresh in

      assert (H' := H);

      rewrite ?(andp_assoc (!! P)) in H';

      let H := fresh in 

      assert (H:P);

       [ clear H' | rewrite (prop_true_andp P) in H' by apply H; clear H;

           sep_apply_aux1 H'; clear H' ]

   | _ => sep_apply_aux2 H

    end

 end.



Ltac sep_apply_aux0 H :=

 let B := head_of_type_of H in

 lazymatch B with

 | ?A ?D |-- _ =>

    tryif (match type of D with ?DT => constr_eq DT globals end)

   then

    (tryif (unfold A in H) then sep_apply_aux1 H

    else let H' := fresh in

         tryif (assert (H' := H); unfold A in H')

         then sep_apply_aux1 H'

         else sep_apply_aux1 H)

   else sep_apply_aux1 H

 | _ => sep_apply_aux1 H

 end.



Ltac sep_apply_in_entailment H :=

    match goal with |- _ |-- _ =>

     let H' := adjust2_sep_apply H in

         sep_apply_aux0 H'

    end.



Ltac my_unshelve_evar name T cb evar_tac :=

  let x := fresh name

  in

  unshelve evar (x:T); revgoals;

  [

    let x' := eval unfold x in x

    in

    clear x; cb x'

  |

    evar_tac x

  ].



Ltac new_sep_apply_in_entailment originalH evar_tac prop_tac :=

  let rec sep_apply_in_entailment_rec H :=

    lazymatch type of H with

    | forall x:?T, _ =>

      lazymatch type of T with

      | Prop => let H' := fresh "H" in assert (H':T);

           [ | sep_apply_in_entailment_rec (H H'); clear H'];

           [ prop_tac | .. ]

      | _ => my_unshelve_evar x T

        ltac:(fun x => sep_apply_in_entailment_rec (H x))

        evar_tac

      end

    | ?T -> _ =>

      lazymatch type of T with

      | Prop => let H' := fresh "H" in assert (H':T);

           [ | sep_apply_in_entailment_rec (H H'); clear H'];

           [ prop_tac | .. ]

      | _ => let x := fresh "arg" in

        my_unshelve_evar x T

          ltac:(fun x => sep_apply_in_entailment_rec (H x))

          evar_tac

      end

    | ?A |-- ?B => sep_apply_in_entailment H

    | ?A = ?B => sep_apply_in_entailment H

    | _ => fail 0 originalH "is not an entailment"

    end

  in

  sep_apply_in_entailment_rec originalH.



Lemma wand_refl_cancel_right:

  forall {A}{ND: NatDed A} {SL: SepLog A}{CA: ClassicalSep A}

    (P: A),  emp |-- P -* P.

Proof.

intros. apply wand_sepcon_adjoint.

rewrite emp_sepcon. apply derives_refl.

Qed.



Lemma cancel_emp_wand:

  forall P Q R: mpred,

    P |-- Q ->

    P |-- Q * (R -* R).

Proof.

intros. rewrite <- (sepcon_emp P).

apply sepcon_derives; auto.

apply wand_refl_cancel_right.

Qed.



Ltac cancel_wand :=

  repeat

  match goal with |- _ |-- ?B =>

    match B with context [?A -* ?A] =>

    rewrite ?sepcon_assoc;

    pull_right (A -* A);

    first [apply cancel_emp_wand | apply wand_refl_cancel_right]

    end

  end.



Ltac norm_rewrite := autorewrite with norm.

 
Lemma TEST_L : forall n:nat, n=n -> (n + 1 = S n)%nat.

Proof. intros. rewrite <- plus_n_Sm ,<- plus_n_O. reflexivity.

Qed.

Hint Rewrite TEST_L using reflexivity : test888.

Goal forall n, S n = (n + 1)%nat.

intros.

rewrite_strat (topdown hints test888).

match goal with |- S n = S n => reflexivity end.

Qed.  



Ltac normalize1 :=

         match goal with

            | |- context [@andp ?A (@LiftNatDed ?T ?B ?C) ?D ?E ?F] =>

                      change (@andp A (@LiftNatDed T B C) D E F) with (D F && E F)

            | |- context [@later ?A  (@LiftNatDed ?T ?B ?C) (@LiftIndir ?X1 ?X2 ?X3 ?X4 ?X5) ?D ?F] =>

                   change (@later A  (@LiftNatDed T B C) (@LiftIndir X1 X2 X3 X4 X5) D F)

                     with (@later B C X5 (D F))

            | |- context [@sepcon ?A (@LiftNatDed ?B ?C ?D)

                                                         (@LiftSepLog ?E ?F ?G ?H) ?J ?K ?L] =>

                   change (@sepcon A (@LiftNatDed B C D) (@LiftSepLog E F G H) J K L)

                      with (@sepcon C D H (J L) (K L))

            | |- context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) by (auto with norm)

            | |- context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) by (auto with norm)

            | |- context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) by (auto with norm)

            | |- context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) by (auto with norm)

            | |-  derives ?A   ?B => match A with

                   | FF => apply FF_left

                   | !! _ => apply derives_extract_prop0

                   | exp (fun y => _) => apply imp_extract_exp_left; (intro y || intro)

                   | !! _ && _ => apply derives_extract_prop

                   | _ && !! _ => apply derives_extract_prop'

                   | context [ ((!! ?P) && ?Q) && ?R ] => rewrite (andp_assoc (!!P) Q R)

                   | context [ ?Q && (!! ?P && ?R)] =>

                                  match Q with !! _ => fail 2 | _ => rewrite (andp_assoc' (!!P) Q R) end

                 
                   | context [andp (exp (fun y => _)) _] =>

                               let BB := fresh "BB" in set (BB:=B); norm_rewrite; unfold BB; clear BB;

                               apply imp_extract_exp_left; intro y

                   | context [andp _ (exp (fun y => _))] =>

                               let BB := fresh "BB" in set (BB:=B); norm_rewrite; unfold BB; clear BB;

                               apply imp_extract_exp_left; intro y

                   | context [sepcon (exp (fun y => _)) _] =>

                               let BB := fresh "BB" in set (BB:=B); norm_rewrite; unfold BB; clear BB;

                               apply imp_extract_exp_left; intro y

                   | context [sepcon _ (exp (fun y => _))] =>

                               let BB := fresh "BB" in set (BB:=B); norm_rewrite; unfold BB; clear BB;

                                apply imp_extract_exp_left; intro y

                   | _ => simple apply TT_prop_right

                   | _ => simple apply TT_right

                   | _ => constr_eq A B; apply derives_refl

                   end

              | |- _ => solve [auto]

              | |- _ |-- !! (?x = ?y) && _ =>

                            (rewrite (prop_true_andp' (x=y))

                                            by (unfold y; reflexivity); unfold y in *; clear y) ||

                            (rewrite (prop_true_andp' (x=y))

                                            by (unfold x; reflexivity); unfold x in *; clear x)

              |  |- ?ZZ -> ?YY => match type of ZZ with

                                               | Prop => fancy_intros true || fail 1

                                               | _ => intros _

                                              end

              | |- ~ _ => fancy_intro true

              | |- _ => progress (norm_rewrite) 

              | |- forall _, _ => let x := fresh "x" in (intro x; repeat normalize1; try generalize dependent x)

              end.



Ltac normalize :=

   autorewrite with gather_prop;

   repeat (((repeat simple apply go_lower_lem1'; simple apply go_lower_lem1)

              || simple apply derives_extract_prop

              || simple apply derives_extract_prop');

              fancy_intros true);

   repeat normalize1; try contradiction.



Lemma allp_instantiate:

   forall {A : Type} {NA : NatDed A} {B : Type} (P : B -> A) (x : B),

       ALL y : B, P y |-- P x.

Proof.

intros. apply allp_left with x. auto.

Qed.



Ltac allp_left x := 

 match goal with |- ?A |-- _ => match A with context [@allp ?T ?ND ?B ?P] =>

   sep_apply_in_entailment (@allp_instantiate T ND B P x)

 end end.



Lemma allp_instantiate': forall (B : Type) (P : B -> mpred) (x : B),

  allp P |-- P x.

Proof. intros. apply allp_instantiate. Qed.



Lemma wand_frame_elim'': forall P Q,

  (P -* Q) * P |-- Q.

Proof. intros. rewrite sepcon_comm. apply wand_frame_elim. Qed.



Lemma prop_sepcon: forall {A}{ND: NatDed A}{SL: SepLog A}

    P Q, !! P * Q = !! P && (TT * Q).

Proof.

 intros.

 rewrite <- (andp_TT (!! _)), sepcon_andp_prop'. normalize.

Qed.



Lemma prop_sepcon2: forall {A}{ND: NatDed A}{SL: SepLog A}

    P Q, Q * !! P = !! P && (TT * Q).

Proof.

 intros.

 rewrite sepcon_comm. apply prop_sepcon.

Qed.



