Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import WandDemo.wand_frame.



Ltac pull_left_wand :=

   match goal with

   | |- ?A |-- _ =>

       match A with

       | context [?P -* ?Q] => 

           let frame := fresh "frame" in evar (frame: list mpred);

           apply derives_trans with ((P -* Q) * fold_right_sepcon frame);

           [ solve [cancel] | subst frame; unfold fold_right_sepcon; rewrite ?sepcon_emp]

       end

   end.



Ltac right_ver :=

   match goal with

   | |- (?P -* ?Q) * ?A |-- _ =>

       match A with

       | context [?Q -* ?R] =>

           let frame := fresh "frame" in evar (frame: list mpred);

           apply derives_trans with ((P -* Q) * ((Q -* R) * fold_right_sepcon frame));

           [ apply sepcon_derives; [apply derives_refl | solve [cancel]]

           | rewrite <- sepcon_assoc;

             eapply derives_trans;

             [ apply sepcon_derives; [apply wand_frame_ver | apply derives_refl]

             | subst frame; unfold fold_right_sepcon; rewrite ?sepcon_emp ]]

       end

   end.

   

Ltac left_ver :=

   match goal with

   | |- (?Q -* ?R) * ?A |-- _ =>

       match A with

       | context [?P -* ?Q] =>

           let frame := fresh "frame" in evar (frame: list mpred);

           apply derives_trans with ((Q -* R) * ((P -* Q) * fold_right_sepcon frame));

           [ apply sepcon_derives; [apply derives_refl | solve [cancel]]

           | rewrite <- sepcon_assoc;

             eapply derives_trans;

             [ apply sepcon_derives; [rewrite sepcon_comm; apply wand_frame_ver | apply derives_refl]

             | subst frame; unfold fold_right_sepcon; rewrite ?sepcon_emp ]]

       end

   end.



Ltac apply_wand_frame_ver :=

  try (

    pull_left_wand;

    repeat right_ver;

    repeat left_ver;

    match goal with

    | |- (?P -* ?Q) * ?A |-- _ =>

           let PQ := fresh "PQ" in

           set (PQ := P -* Q);

           apply_wand_frame_ver;

           subst PQ

    end).



Ltac apply_one_wand_frame_elim :=

  match goal with

  | |- (?P -* ?Q) * ?A |-- _ =>

       let frame := fresh "frame" in evar (frame: list mpred);

       apply derives_trans with (P * (P -* Q) * fold_right_sepcon frame);

       [ solve [cancel]

       | eapply derives_trans;

         [ apply sepcon_derives; [apply wand_frame_elim | apply derives_refl]

         | subst frame; unfold fold_right_sepcon; rewrite ?sepcon_emp ]]

   end.



Ltac apply_wand_frame_elim :=

  repeat (

    pull_left_wand;

    apply_one_wand_frame_elim

  ).

      

Goal forall A B C D E F G H: mpred, (B -* C) * E * (A -* B) * (F -* G) * (C -* D) * (G -* H) |-- A * F -* D * E * H.

  intros.

  apply_wand_frame_ver.

  apply -> wand_sepcon_adjoint.

  apply_wand_frame_elim.

  cancel.

Qed.

