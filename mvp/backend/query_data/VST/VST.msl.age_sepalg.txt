

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.ageable.
(* VST.msl.ageable:
Require Import VST.msl.base.
  Require Coq.funind.Recdef.

Local Open Scope nat_scope.

Record ageable_facts (A:Type) (level: A -> nat) (age1:A -> option A)  :=
{ af_unage : forall x':A, exists x, age1 x = Some x'
; af_level1 : forall x, age1 x = None <-> level x = 0
; af_level2 : forall x y, age1 x = Some y -> level x = S (level y)
}.

Arguments af_unage [A] [level] [age1] _ _.
Arguments af_level1 [A] [level] [age1] _ _.
Arguments af_level2 [A] [level] [age1] _ _ _ _.

Class ageable (A:Type) := mkAgeable
{ level : A -> nat
; age1 : A -> option A
; age_facts : ageable_facts A level age1
}.

Definition age {A} `{ageable A} (x y:A) := age1 x = Some y.

Lemma af_wf {A} `{ageable A} :
 well_founded (fun x y => age y x).
Arguments af_wf [A] _ _.

Definition age_induction {A} `{ageable A} :=
  well_founded_induction (af_wf _).

Definition fashionR {A1} `{ageable A1} {A2}`{ageable A2} (x:A1) (y: A2) : Prop :=
  level x = level y.

Lemma fashionR_refl {A} `{ageable A} : reflexive _ fashionR.

Lemma fashionR_trans {A} `{ageable A} {B} `{ageable B} {C} `{ageable C} :
    forall (x: A) (y: B) (z: C), fashionR x y -> fashionR y z -> fashionR x z.

Lemma fashionR_sym {A} `{ageable A} {B} `{ageable B}:
   forall (x: A) (y: B), fashionR x y -> fashionR y x.

Lemma age_level {A} `{ageable A} : forall (x y:A),
  age x y -> level x = S (level y).

Lemma age1_level0 {A} `{ageable A} : forall (x:A),
  age1 x = None <-> level x = 0.

  Theorem level_level' : forall x:A, level x = level' x.
End level'.

Lemma levelS_age1 {A} `{ageable A} : forall (x:A) n,
  level x = S n ->
  exists y, age1 x = Some y.

Lemma age1_levelS {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  exists n, level x = S n.

Lemma age1_level0_absurd {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  level x = 0 ->
  False.

Lemma age1None_levelS_absurd {A} `{ageable A} : forall (x:A) n,
  age1 x = None ->
  level x = S n ->
  False.

Section RtRft.
  Variable A:Type.
  Variable R:relation A.

  Let Rt := clos_trans A R.
  Let Rft := clos_refl_trans A R.

  Lemma Rt_Rft : forall x y, Rt x y -> Rft x y.

  Lemma Rt_Rft_trans : forall x y z, Rt x y -> Rft y z -> Rt x z.

  Lemma Rft_Rt_trans : forall x y z, Rft x y -> Rt y z -> Rt x z.

  Lemma transpose_clos_trans : forall A R x y,
    clos_trans A (transp A R) x y <-> transp A (clos_trans A R) x y.
End RtRft.

Hint Resolve rt_refl.

Definition laterR {A} `{ageable A} : relation A := clos_trans A age.
Definition necR   {A} `{ageable A} : relation A := clos_refl_trans A age.

Require Coq.Wellfounded.Wellfounded.
Lemma laterR_wf {A} `{ageable A} :
  well_founded (transp _ laterR).

Definition laterR_induction {A} `{ageable A} :=
  @well_founded_induction A (transp A laterR) laterR_wf.

Lemma age_irreflexive {A}  `{ageable A}: forall x, age x x -> False.

Lemma laterR_irreflexive {A} `{HA: ageable A} : forall x, laterR x x -> False.

Lemma nec_refl_or_later {A} `{ageable A} : forall x y,
  necR x y -> x = y \/ laterR x y.

Lemma necR_antisym {A} `{ageable A} : forall x y,
  necR x y -> necR y x -> x = y.

Lemma age_later_nec {A} `{HA: ageable A} : forall x y z,
  age x y ->
  laterR x z ->
  necR y z.

Lemma necR_level {A} `{X: ageable A} : forall (x y:A),
  necR x y ->
  level x >= level y.

Lemma laterR_level {A} `{X: ageable A} : forall (x y:A),
  laterR x y ->
  level x > level y.

Section NAT_AGEABLE.

  Definition natLevel (x:nat) : nat := x.
  Definition natAge1 (x:nat) : option nat :=
    match x with
    | 0 => None
    | S n => Some n
    end.
  Definition natUnage (x:nat) : nat := S x.

  Lemma ag_nat_facts :
    ageable_facts nat natLevel natAge1.

  Definition ag_nat : ageable nat :=
    mkAgeable nat natLevel natAge1 ag_nat_facts.

  Lemma nec_nat : forall (n n':nat),
    @necR _ ag_nat n n' <-> n' <= n.

  Lemma later_nat : forall (n n':nat),
    @laterR _ ag_nat n n' <-> n' < n.

End NAT_AGEABLE.

Lemma laterR_level' {A} `{H : ageable A}: forall {w1 w2: A}, laterR w1 w2 -> @laterR _ ag_nat (level w1) (level w2).

Lemma necR_nat {A} `{H : ageable A}:
    forall {x y: A}, necR x y -> @necR nat ag_nat (level x) (level y).

Section BIJECTION.
  Variable A B : Type.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.

  Let levelB (x:B) : nat :=
    level (bij_g _ _ bijAB x).

  Let age1B  (x: B) : option B :=
     match age1 (bij_g _ _ bijAB x) with
     | Some y => Some (bij_f _ _ bijAB y)
     | None => None
     end.

  Let ageB (x y: B) :=age1B x = Some y.

  Lemma age_bij_unage :
    forall x', exists x, age1B x = Some x'.

  Lemma age_bij_level1 :
    forall x, age1B x = None <-> levelB x = 0.

  Lemma age_bij_level2 :
    forall x y, age1B x = Some y -> levelB x = S (levelB y).

  Lemma ag_bij_facts : ageable_facts B levelB age1B.

  Definition ag_bij : ageable B :=
    mkAgeable B levelB age1B ag_bij_facts.
End BIJECTION.

Section PROD.
  Variable A B : Type.
  Variable agA: ageable A.

  Let levelAB (x:prod A B) := level (fst x).
  Let age1AB (x:prod A B) :=
    match age1 (fst x) with
    | None => None
    | Some a' => Some (a',snd x)
    end.

  Lemma ag_prod_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod :=
    mkAgeable (prod A B) levelAB age1AB ag_prod_facts.

  Lemma prod_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod (n,x) (n',x') <-> necR n n' /\ x = x'.

  Lemma prod_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod (n,x) (n',x') <-> laterR n n' /\ x = x'.

End PROD.

Section PROD'.
  Variable A B : Type.
  Variable agB: ageable B.

  Let levelAB (x:prod A B) := level (snd x).
  Let age1AB (x:prod A B) :=
    match age1 (snd x) with
    | None => None
    | Some a' => Some (fst x, a')
    end.

  Lemma ag_prod'_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod' :=
    mkAgeable (prod A B) levelAB age1AB ag_prod'_facts.

  Lemma prod'_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod' (x,n) (x',n') <-> necR n n' /\ x = x'.

  Lemma prod'_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod' (x,n) (x',n') <-> laterR n n' /\ x = x'.

End PROD'.

Fixpoint composeOptN (A: Type) (f: A -> option A)
         (n: nat) (w: A) {struct n} : option A :=
 match n  with
 | S n' => match f w with Some w' => composeOptN A f n' w' | None => None end
 | O => Some w
 end.
Arguments composeOptN [A] _ _ _.

Definition ageN {A} `{ageable A}: nat -> A -> option A := composeOptN age1.

Lemma ageN1  {A} `{ageable A}: ageN 1 = age1.

Lemma ageN_compose {A} `{agA : ageable A}:
 forall a b c phi1 phi2 phi3,ageN a phi1 = Some phi2 ->
       ageN b phi2 = Some phi3 ->  (a+b=c)%nat ->  ageN c phi1 = Some phi3.

Lemma ageN_compose' {A} `{agA : ageable A}:
  forall a b phi1 phi3,
   ageN (a+b)%nat phi1 = Some phi3 -> exists phi2, ageN a phi1 = Some phi2 /\ ageN b phi2 = Some phi3.

Lemma necR_evolve {A} `{agA : ageable A}:
    necR = fun (phi phi': A) => exists n, ageN n phi = Some phi'.

Lemma age_noetherian  {A} `{ageable A}: forall phi, exists n, ageN n phi = None.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma age_noetherian'  {A} `{agA : ageable A}:
       forall phi, exists! n, exists phi', ageN n phi = Some phi' /\ age1 phi' = None.

Lemma ageable_ext:
   forall A (B C: ageable A),
      @age1 _ B = @age1 _ C -> @level _ B = @level _ C -> B=C.

Lemma necR_linear {A} `{H : ageable A}:
  forall {a b c}, necR a b -> necR a c -> necR b c \/ necR c b.

Lemma necR_linear' {A} `{H : ageable A}:
   forall {a b c}, necR a b -> necR a c -> level b = level c -> b=c.

Lemma laterR_necR {A} `{agA : ageable A}:
  forall {x y}, laterR x y -> necR x y.

Lemma necR_refl {A} `{H : ageable A}:
  forall phi, necR phi phi.

Hint Resolve @necR_refl.

Lemma necR_trans  {A} `{H : ageable A}:
  forall phi1 phi2 phi3, necR phi1 phi2 -> necR phi2 phi3 -> necR phi1 phi3.

Lemma necR_laterR {A} `{agA : ageable A}:
  forall w1 w2 w3, necR w1 w2 -> laterR w2 w3 -> laterR w1 w3. *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)



Class Age_alg (A:Type) {JOIN: Join A}{as_age : ageable A} :=

mkAge {

  age1_join : forall x {y z x'}, join x y z -> age x x' ->

    exists y':A, exists z':A, join x' y' z' /\ age y y' /\ age z z'

; age1_join2 : forall x {y z z'}, join x y z -> age z z' ->

    exists x':A, exists y':A, join x' y' z' /\ age x x' /\ age y y'

; unage_join : forall x {x' y' z'}, join x' y' z' -> age x x' ->

    exists y:A, exists z:A, join x y z /\ age y y' /\ age z z'

; unage_join2 : forall z {x' y' z'}, join x' y' z' -> age z z' ->

    exists x:A, exists y:A, join x y z /\ age x x' /\ age y y'

}.



Lemma age1_None_joins {A}{JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2, joins phi1 phi2 -> age1 phi1 = None -> age1 phi2 = None.

Proof.

  intros.

  destruct H.

  case_eq (age1 phi2); intros; auto.

  destruct (age1_join _ (join_comm H) H1)  as [phi1' [x' [? [? ?]]]].

  unfold age in *; rewrite H0 in H3; inv H3.

Qed.



Lemma age1_joins_eq {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2,

        joins phi1 phi2 ->

        forall phi1', age1 phi1 = Some phi1' ->

        forall phi2', age1 phi2 = Some phi2' ->

        joins phi1' phi2'.

Proof.

  intros.

  destruct H.

  destruct (age1_join _ H H0) as [phi7 [x' [? [? ?]]]].

  unfold age in *; rewrite H1 in H3; inv H3.

  exists x'; auto.

Qed.



Section BIJECTION.

  Variables A B : Type.

  Variable JA: Join A.

  Variable PA: Perm_alg A.

  Variable ag: ageable A.

  Variable bijAB: bijection A B.

  Variable asa : Age_alg A.



  Existing Instance PA.



  Instance agB : ageable B := (ag_bij _ _ ag bijAB).



  Theorem asa_bijection : @Age_alg B (Join_bij _ _ _ bijAB) agB.

  Proof.

    constructor; unfold age, Join_bij; simpl;     destruct bijAB as [f g fg gf]; simpl  in *; intros.



    revert H0; case_eq (age1 (g x)); intros; try discriminate.

    inv H1.

    rename a into gx'.  red in H.

    destruct (age1_join _ H H0) as  [gy' [gz' [? [? ?]]]].

    exists (f gy'); exists (f gz').

    split. red.

    repeat rewrite gf. auto.

    rewrite H2; rewrite H3.

    auto.



    revert H0; case_eq (age1 (g z)); intros; try discriminate.

    inv H1.

    rename a into gz'. red in H.

    destruct (age1_join2 _ H H0) as  [gx' [gy' [? [? ?]]]].

    exists (f gx'); exists (f gy').

    split. red; repeat rewrite gf; auto.

    rewrite H2; rewrite H3.

    auto.



    revert H0; case_eq (age1 (g x)); intros; try discriminate.

    inv H1.

    rename a into gx'. red in H.

    rewrite gf in *.

    destruct (unage_join _ H H0) as  [gy' [gz' [? [? ?]]]].

    exists (f gy'); exists (f gz').

    split. red; repeat rewrite gf; auto.

    repeat rewrite gf. rewrite H2; rewrite H3.

    repeat rewrite fg; split; auto.



    revert H0; case_eq (age1 (g z)); intros; try discriminate.

    inv H1.

    rename a into gz'. red in H.

    rewrite gf in *.

    destruct (unage_join2 _ H H0) as  [gx' [gy' [? [? ?]]]].

    exists (f gx'); exists (f gy').

    split. red.    repeat rewrite gf; auto.

    repeat rewrite gf.

    rewrite H2; rewrite H3.

    repeat rewrite fg; split; auto.

  Qed.

End BIJECTION.



Section PROD.

  Variable A : Type.

  Variable J_A: Join A.

  Variable saA : Perm_alg A.

  Variable agA : ageable A.

  Variable B: Type.

  Variable J_B: Join B.

  Variable saB : Perm_alg B.

  Variable asa : Age_alg A.



  Theorem asa_prod : @Age_alg (prod A B) _ (ag_prod A B agA).

  Proof.

    constructor; unfold age; simpl; unfold Join_prod.



    intros [xa xb] [ya yb] [za zb] [xa' xb'] [? ?].

    simpl in *.

    case_eq (age1 xa); intros; inv H2.

    destruct (age1_join _ H H1) as [ya' [za' [? [? ?]]]].

    exists (ya',yb); exists (za',zb);

      rewrite H3; rewrite H4; repeat split; auto.



    intros [xa xb] [ya yb] [za zb] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 za); intros; inv H2.

    destruct (age1_join2 _ H H1) as [xa' [ya' [? [? ?]]]].

    exists (xa',xb); exists (ya',yb);

      rewrite H3; rewrite H4; repeat split; auto.



    intros [xa xb] [xa' xb'] [ya' yb'] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 xa); intros; inv H2.

    destruct (unage_join _ H H1) as [ya [za [? [? ?]]]].

    exists (ya,yb'); exists (za,zb'); simpl.

    rewrite H3; rewrite H4; repeat split; auto.



    intros [za zb] [xa' xb'] [ya' yb'] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 za); intros; inv H2.

    destruct (unage_join2 _ H H1) as [xa [ya [? [? ?]]]].

    exists (xa,xb'); exists (ya,yb'); simpl.

    rewrite H3; rewrite H4; repeat split; auto.

  Qed.

End PROD.



Section PROD'.

  Variable A : Type.

  Variable J_A: Join A.

  Variable saA : Perm_alg A.

  Variable B: Type.

  Variable J_B: Join B.

  Variable saB : Perm_alg B.

  Variable agB : ageable B.

  Variable asb : Age_alg B.



  Theorem asa_prod' : @Age_alg (prod A B) _ (ag_prod' A B agB).

  Proof.

    constructor; unfold age; simpl; unfold Join_prod.



    intros [xa xb] [ya yb] [za zb] [xa' xb'] [? ?].

    simpl in *.

    case_eq (age1 xb); intros; inv H2.

    destruct (age1_join _ H0 H1) as [yb' [zb' [? [? ?]]]].

    exists (ya,yb'); exists (za,zb');

      rewrite H3; rewrite H4; repeat split; auto.



    intros [xa xb] [ya yb] [za zb] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 zb); intros; inv H2.

    destruct (age1_join2 _ H0 H1) as [xb' [yb' [? [? ?]]]].

    exists (xa,xb'); exists (ya,yb');

      rewrite H3; rewrite H4; repeat split; auto.



    intros [xa xb] [xa' xb'] [ya' yb'] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 xb); intros; inv H2.

    destruct (unage_join _ H0 H1) as [yb [zb [? [? ?]]]].

    exists (ya',yb); exists (za',zb); simpl.

    rewrite H3; rewrite H4; repeat split; auto.



    intros [za zb] [xa' xb'] [ya' yb'] [za' zb'] [? ?].

    simpl in *.

    case_eq (age1 zb); intros; inv H2.

    destruct (unage_join2 _ H0 H1) as [xb [yb [? [? ?]]]].

    exists (xa',xb); exists (ya',yb); simpl.

    rewrite H3; rewrite H4; repeat split; auto.

  Qed.

End PROD'.



Lemma joins_fashionR {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A} : forall x y,

  joins x y -> fashionR x y.

Proof.

  pose proof I.

  intros.

  unfold fashionR.

  destruct H0 as [z ?].

  revert y z H0; induction x using age_induction; intros.

  case_eq (age1 x); intros.

  destruct (age1_join _ H1 H2) as [p [q [? [? ?]]]].

  assert (level a = level p).

  apply H0 with q; auto.

  replace (level x) with (S (level a)).

  replace (level y) with (S (level p)).

  f_equal; auto.

  symmetry; apply age_level; auto.

  symmetry; apply age_level; auto.

  case_eq (age1 y); intros.

  apply join_comm in H1.

  destruct (age1_join _ H1 H3) as [p [q [? [? ?]]]].

  hnf in H5; rewrite H5 in H2; discriminate.

  rewrite age1_level0 in H2.

  rewrite age1_level0 in H3.

  congruence.

Qed.



Lemma comparable_fashionR {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A} {XA: Age_alg A} : forall x y,

  comparable x y -> fashionR x y.

Proof.

  intros.

  apply comparable_common_unit in H.

  destruct H as [u [H1 H2]].

  hnf; transitivity (level u).

  apply joins_fashionR; eauto.

  symmetry.

  apply joins_fashionR; eauto.

Qed.



Lemma age_identity {A} `{asaA: Age_alg A}: forall phi phi', age phi phi'->

    identity phi -> identity phi'.

Proof.

intros.

unfold identity in *.

intros.

destruct (unage_join _ H1 H) as [y [? [? [? ?]]]].

specialize ( H0 y x H2).

subst.

unfold age in *. congruence.

Qed.



Lemma age_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A}{asaA: Age_alg A}:

    forall phi1 phi2 phi1' phi2', age phi1 phi1' -> age phi2 phi2' ->

      comparable phi1 phi2 -> comparable phi1' phi2'.

Proof.

  intros.

  destruct (comparable_common_unit H1) as [e [? ?]].

  destruct (age1_join _ (join_comm H2) H) as [a [b [? [? ?]]]].

  destruct (age1_join _ (join_comm H3) H0) as [c [d [? [? ?]]]].

  assert (c=a) by (unfold age in *; congruence); subst c.

  assert (b=phi1') by (unfold age in *; congruence). subst b.

  assert (d=phi2') by (unfold age in *; congruence). subst d.

  apply common_unit_comparable.

  exists a.

  split; apply join_comm; auto.

Qed.



  Lemma asa_nat : @Age_alg nat (Join_equiv nat) ag_nat.

  Proof.

    constructor.

    repeat intro. hnf in H; subst; auto.

    intros.

    destruct H; subst.

    exists x'. exists x'.

    intuition.

    intros.

    destruct H; subst.

    exists z'; exists z'; intuition.

    intros. destruct H; subst.

    exists x; exists x. intuition.

    intros. destruct H; subst.

    exists z; exists z; intuition.

  Qed.



Lemma nec_identity {A} `{asaA: Age_alg A}: forall phi phi', necR phi phi'->

    identity phi -> identity phi'.

Proof.

  induction 1; auto.

  apply age_identity; auto.

Qed.



Lemma nec_join2 {A} `{asaA : Age_alg A}: forall {x y z z' : A},

       join x y z ->

       necR z z' ->

       exists x',

         exists y',

           join x' y' z' /\ necR x x' /\ necR y y'.

Proof.

intros.

revert x y H; induction H0; intros.

edestruct (age1_join2) as [x' [y' [? [? ?]]]]; eauto.

exists x'; exists y'; split; auto.

split; constructor 1; auto.

exists x0; exists y; split; auto.

destruct (IHclos_refl_trans1 _ _ H) as [x' [y' [? [? ?]]]].

destruct (IHclos_refl_trans2 _ _ H0) as [x'' [y'' [? [? ?]]]].

exists x''; exists y''.

split; auto.

split; econstructor 3; eauto.

Qed.



Lemma nec_join {A} `{asaA : Age_alg A}: forall {x y z x' : A},

       join x y z ->

       necR x x' ->

       exists y' ,

         exists z' ,

           join x' y' z' /\ necR y y' /\ necR z z'.

Proof.

intros.

revert y z H; induction H0; intros.

edestruct age1_join as [y' [z' [? [? ?]]]]; eauto.

exists y'; exists z'; split; auto.

split; constructor 1; auto.

exists y; exists z; split; auto.

destruct (IHclos_refl_trans1 _ _ H) as [y' [z' [? [? ?]]]].

destruct (IHclos_refl_trans2 _ _ H0) as [y'' [z'' [? [? ?]]]].

exists y''; exists z''.

split; auto.

split; econstructor 3; eauto.

Qed.



Lemma nec_join4 {A} `{asaA : Age_alg A}: forall z x' y' z' : A,

       join x' y' z' ->

       necR z z' ->

       exists x,

         exists y,

           join x y z /\ necR x x' /\ necR y y'.

Proof.

intros.

revert x' y' H.

induction H0; intros.

destruct (unage_join2 _ H0 H) as  [x0 [y0 [? [? ?]]]].

exists x0; exists y0; split; auto.

split; constructor 1; auto.

exists x'; exists y'; split; auto.



rename x into z1.

rename y into z2.

destruct (IHclos_refl_trans2 _ _ H) as [x'' [y'' [? [? ?]]]].

destruct (IHclos_refl_trans1 _ _ H0) as [x0 [y0 [? [? ?]]]].

exists x0; exists y0.

split; auto.

split; econstructor 3; eauto.

Qed.



Lemma join_level {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{AgeA: Age_alg A}:

  forall x y z, join x y z -> level x = level z /\ level y = level z.

Proof.

  intros.

  assert (exists n, n = level x) by (eexists; reflexivity).

  destruct H0 as [n  ?].

  revert x y z H0 H; induction n; intros.

  case_eq (level y); intros.

  case_eq (level z); intros.

  split; congruence.

  destruct (levelS_age1 _ _ H2).

  destruct (age1_join2 _ H H3) as [u [v [? [? ?]]]].

  apply age_level in H5. congruence.

  destruct (levelS_age1 _ _ H1).

  destruct (age1_join _ (join_comm H) H2) as [u [v [? [? ?]]]].

  apply age_level in H4. congruence.

  symmetry in H0.

  destruct (levelS_age1 _ _ H0) as [x' ?].

  destruct (age1_join _ H H1) as [y' [z' [? [? ?]]]].

  specialize (IHn x' y' z').

  apply age_level in H1. apply age_level in H3. apply age_level in H4.

  destruct IHn; auto. congruence.

  split; congruence.

Qed.



 Lemma level_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

     forall m:A, level (core m) = level m.

 Proof. intros.

  generalize (core_unit m); unfold unit_for; intro.

  apply join_level in H. intuition.

 Qed.



Lemma age_core_eq {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall x y x' y', age x x' -> age y y' -> core x = core y -> core x' = core y'.

Proof.

 intros.

 generalize (core_unit x); unfold unit_for; intro. apply join_comm in H2.

 generalize (core_unit y); unfold unit_for; intro. apply join_comm in H3.

 destruct (age1_join _ H2 H) as [u [v [? [? ?]]]].

 destruct (age1_join _ H3 H0) as [i [j [? [? ?]]]].

 unfold age in *. rewrite H in H6. inv H6. rewrite H0 in H9; inv H9.

 rewrite H1 in *. rewrite H5 in H8; inv H8.

 apply join_core2 in H4. apply join_core2 in H7.

  congruence.

Qed.



Lemma age_twin {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall phi1 phi2 n phi1',

  level phi1 = level phi2 ->

  ageN n phi1 = Some phi1' ->

  exists phi2', ageN n phi2 = Some phi2' /\ level phi1' = level phi2'.

Proof.

intros until n; revert n phi1 phi2.

induction n; intros.

exists phi2.

split; trivial.

inversion H0.

subst phi1'.

trivial.

unfold ageN in H0.

simpl in H0.

revert H0; case_eq (age1 phi1); intros; try discriminate.

rename a into phi.

assert (exists ophi2, age phi2 ophi2 /\ level phi = level ophi2).

generalize (age_level _ _ H0); intro.

rewrite H in H2; apply levelS_age1 in H2. destruct H2 as [y ?].

exists y; split; auto.

apply age_level in H0; apply age_level in H2; omega.

destruct H2 as [ophi2 [? ?]].

specialize (IHn _ _ _ H3 H1).

destruct IHn as [phi2' [? ?]].

exists phi2'.

split; trivial.

unfold ageN.

simpl.

rewrite H2.

trivial.

Qed.



Lemma age1_join_eq {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3,

        join phi1 phi2 phi3 ->

        forall phi1', age1 phi1 = Some phi1' ->

        forall phi2', age1 phi2 = Some phi2' ->

        forall phi3', age1 phi3 = Some phi3' ->

        join phi1' phi2' phi3'.

Proof.

intros until phi3.

intros H phi1' H0 phi2' H1 phi3' H2.

destruct (age1_join _ H H0) as [phi4 [x' [? [? ?]]]].

unfold age in *.

rewrite H4 in H1.

inversion H1.

rewrite <- H7.

rewrite H5 in H2.

inversion H2.

rewrite <- H8.

auto.

Qed.



Lemma strong_nat_ind (P : nat -> Prop) (IH : forall n, (forall i, lt i n -> P i) -> P n) n : P n.

Proof.

  apply IH; induction n; intros i li; inversion li; eauto.

Qed.



Lemma age_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall x y : A, age x y -> age (core x) (core y).

Proof.

 intros. unfold age in *.

 pose proof (core_unit x).

 unfold unit_for in H0.

 destruct (age1_join2 _ H0 H) as [a [b [? [? ?]]]].

 unfold age in H3. rewrite H3 in H; inv H.

 pose proof (core_unit y).

 assert (a = core y); [|subst; auto].

 eapply same_identity; eauto.

 - eapply age_identity; eauto.

   apply core_identity.

 - apply core_identity.

Qed.



Lemma necR_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall x y : A, necR x y -> necR (core x) (core y).

Proof.

 induction 1.

 constructor 1; apply age_core; auto.

 constructor 2.

 constructor 3 with (core y); auto.

Qed.



Definition relation_mul {A: Type} (R0 R1: relation A) (x y: A) := exists z, R0 x z /\ R1 z y.



Fixpoint relation_power {A: Type} (n: nat) (R: relation A) :=

  match n with

  | O => eq

  | S n0 => relation_mul R (relation_power n0 R)

  end.



Fixpoint partial_fun_power {A: Type} (n: nat) (f: A -> option A) (x: A) :=

  match n with

  | O => Some x

  | S n0 => match f x with

            | Some fx => partial_fun_power n0 f fx

            | None => None

            end

  end.



Lemma laterR_power_age: forall {A:Type} {agA:ageable A} (x y: A),

  laterR x y <-> (exists n, relation_power (S n) age x y).

Proof.

  intros.

  remember (level x) eqn:?H.

  revert x y H; induction n; intros.

  + split; intros.

    - apply laterR_level in H0.

      omega.

    - destruct H0 as [n ?H].

      destruct H0 as [z [? ?]].

      apply age_level in H0; omega.

  + split; intros.

    - destruct (age1 x) as [a' |] eqn:?H; [| apply age1_level0 in H1; omega].

      assert (age x a') by auto; clear H1.

      pose proof age_later_nec _ _ _ H2 H0.

      destruct (nec_refl_or_later _ _ H1).

      * exists 0.

        simpl.

        exists y.

        subst; auto.

      * simpl.

        pose proof age_level _ _ H2.

        rewrite <- H in H4; inversion H4; clear H4.

        destruct (IHn a' y H6) as [? _].

        destruct (H4 H3) as [n0 ?H].

        exists (S n0).

        simpl.

        exists a'.

        auto.

    - destruct H0 as [n0 [z [?H ?H]]].

      pose proof age_level _ _ H0.

      rewrite <- H in H2; inversion H2; clear H2.

      destruct (IHn z y H4) as [_ ?H].

      destruct n0.

      * simpl in H1; subst.

        apply t_step; auto.

      * spec H2; [exists n0; auto |].

        eapply t_trans; eauto.

        apply t_step; auto.

Qed.



Lemma necR_power_age: forall {A:Type} {agA:ageable A} (x y: A),

  necR x y <-> (exists n, relation_power n age x y).

Proof.

  intros.

  split; intros.

  + destruct (nec_refl_or_later _ _ H).

    - subst.

      exists 0.

      simpl.

      auto.

    - destruct (laterR_power_age x y) as [? _].

      destruct (H1 H0) as [n0 ?H].

      exists (S n0); auto.

  + destruct H as [n ?H].

    destruct n.

    - simpl in H; subst.

      auto.

    - destruct (laterR_power_age x y) as [_ ?].

      spec H0; [exists n; auto |].

      apply laterR_necR; auto.

Qed.



Lemma power_age_age1: forall {A:Type} {agA:ageable A} n x y,

  relation_power n age x y <-> partial_fun_power n age1 x = Some y.

Proof.

  intros.

  revert x; induction n; intros.

  + simpl.

    split; intros; [subst| inversion H]; reflexivity.

  + simpl.

    split; intros.

    - destruct H as [z [?H ?H]].

      rewrite H.

      apply IHn; auto.

    - destruct (age1 x) as [z |] eqn:?H; [| inversion H].

      exists z.

      split; [auto |].

      apply IHn; auto.

Qed.



Lemma power_age1_level_small: forall {A:Type} {agA:ageable A} n x,

  partial_fun_power n age1 x = None <-> level x < n.

Proof.

  intros.

  revert x; induction n; intros.

  + simpl; split; intros.

    - inversion H.

    - omega.

  + simpl; split; intros.

    - destruct (age1 x) eqn:?H.

      * apply age_level in H0.

        apply IHn in H.

        omega.

      * apply age1_level0 in H0.

        omega.

    - destruct (age1 x) eqn:?H.

      * apply IHn.

        apply age_level in H0.

        omega.

      * reflexivity.

Qed.



Lemma power_age_core: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x y: A) n,

  relation_power n age x y -> relation_power n age (core x) (core y).

Proof.

  intros.

  revert x y H; induction n; intros.

  + simpl in H |- *.

    subst; reflexivity.

  + simpl in H |- *.

    destruct H as [z [?H ?H]].

    exists (core z).

    split.

    - apply age_core; auto.

    - apply IHn; auto.

Qed.



Lemma power_age_core_eq: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y y': A) n,

  relation_power n age x x' -> relation_power n age y y' -> core x = core y -> core x' = core y'.

Proof.

  intros.

  revert x y H H0 H1; induction n; intros.

  + simpl in H, H0 |- *.

    subst; auto.

  + simpl in H, H0 |- *.

    destruct H as [x'' [?H ?H]].

    destruct H0 as [y'' [?H ?H]].

    pose proof age_core_eq _ _ _ _ H H0 H1.

    specialize (IHn x'' y'' H2 H3 H4).

    auto.

Qed.



Lemma levelS_age {A: Type} {agA: ageable A} : forall (x:A) n,

  S n = level x ->

  exists y, age x y /\ n = level y.

Proof.

  intros.

  apply eq_sym in H.

  remember H as H0; clear HeqH0.

  apply levelS_age1 in H0.

  destruct H0 as [y ?].

  exists y.

  assert (age x y).

  unfold age.

  exact H0.

  split.

  exact H1.

  apply age_level in H1.

  rewrite H in H1.

  inversion H1.

  reflexivity.

Qed.



Lemma clos_refl_trans_addone: forall (A : Type) (R : relation A) (x y z: A), R x y -> clos_refl_trans A R y z -> clos_refl_trans A R x z.

Proof.

  intros.

  apply (rt_step A R x y) in H.

  apply rt_trans with y.

  exact H.

  exact H0.

Qed.



Lemma necR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), necR x x' -> level x = level y -> exists y', (necR y y' /\ level x' = level y').

Proof.

  intros A agA x y.

  remember (level x) as n.

  generalize Heqn; clear Heqn.

  generalize x y; clear x y.

  induction n.

  

  + intros.

    apply necR_level in H.

    rewrite <- Heqn in H.

    destruct (level x') eqn:HH; [|omega].

    exists y.

    split.

       unfold necR; auto.

       exact H0.

  + intros.

    apply nec_refl_or_later in H.

    destruct H.

    - exists y.

      split.

         unfold necR; auto.

         rewrite <- H0. rewrite -> Heqn. rewrite H. reflexivity.

    - apply levelS_age in H0; destruct H0 as [y'' [? ?]].

      apply levelS_age in Heqn; destruct Heqn as [x'' [? ?]].

      remember (IHn x'' y'' H3 x') as HH; clear HeqHH.

      assert(necR x'' x').

        apply (age_later_nec x); [exact H2 | exact H].

      apply HH in H4; clear HH; [|exact H1].

      destruct H4 as [y' [? ?]].

      exists y'.

      split; [| exact H5].

      unfold necR.

      apply clos_refl_trans_addone with y''; [exact H0| exact H4].

Qed.



Lemma laterR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), laterR x x' -> level x = level y -> exists y', (laterR y y' /\ level x' = level y').

Proof.

  intros.

  assert (HH: laterR x x'). exact H.

  apply laterR_necR in H.

  assert (exists y' : A, necR y y' /\ level x' = level y').

     apply (necR_same_level x y).

     exact H.

     exact H0.

  destruct H1 as [y' [? ?]].

  exists y'.

  split; [|exact H2].

  apply nec_refl_or_later in H1.

  destruct H1.

  + apply laterR_level in HH.

    subst.

    rewrite <- H0 in H2.

    omega.

  + exact H1.

Qed.



Lemma power_age_parallel: forall {A:Type} {agA:ageable A} (x x' y: A) n,

  level x = level y ->

  relation_power n age x x' ->

  exists y', relation_power n age y y'.

Proof.

  intros.

  destruct (partial_fun_power n age1 y) eqn:?H.

  + exists a.

    apply power_age_age1; auto.

  + apply power_age_age1 in H0.

    apply power_age1_level_small in H1.

    rewrite <- H in H1.

    apply power_age1_level_small in H1.

    rewrite H0 in H1.

    inversion H1.

Qed.



Lemma power_age_parallel': forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y: A) n,

  core x = core y ->

  relation_power n age x x' ->

  exists y', relation_power n age y y' /\ core x' = core y'.

Proof.

  intros.

  assert (level x = level y).

  1:{

    pose proof level_core y.

    pose proof level_core x.

    rewrite H in H2.

    congruence.

  }

  destruct (power_age_parallel x x' y n H1 H0) as [y' ?H].

  exists y'.

  split; [auto |].

  eapply power_age_core_eq; eauto.

Qed.



