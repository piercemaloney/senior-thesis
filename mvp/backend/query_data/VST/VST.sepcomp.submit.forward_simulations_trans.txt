

Require Import Coqlib.

Require Import Events. 

Require Import compcert.common.Values.
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)

Require Import AST.

Require Import Globalenvs.

Require Import Memory.



Require Import sepcomp.Coqlib2.



Require Import sepcomp.mem_lemmas.
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.core_semantics.

Require Import sepcomp.forward_simulations.



Require Import Wellfounded.

Require Import Relations.
(* Relations:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.ZArith.BinInt. 
Require Import Coq.ZArith.Zcomplements. 
Require Import compcert.lib.Integers.          
Require Import Coq.Numbers.Natural.Peano.NPeano.

Require Import Coq.Strings.Ascii.
Require Import Coq.Program.Tactics.
Require Import sha.XorCorrespondence. 
Require Import sha.Bruteforce.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.

Definition Blist := list bool.
Open Scope Z_scope.

Inductive InBlocks {A : Type} (n : nat) : list A -> Prop :=
  | InBlocks_nil : InBlocks n []
  | InBlocks_block : forall (front back full : list A),
                   length front = n ->
                   full = front ++ back ->
                   InBlocks n back ->
                   InBlocks n full.

Lemma InBlocks_len : forall {A : Type} (l : list A) (n : nat),
                       PeanoNat.Nat.divide (n) (length l) -> InBlocks n l.

Inductive bytes_bits_lists : Blist -> list byte -> Prop :=
  | eq_empty : bytes_bits_lists nil nil
  | eq_cons : forall (bits : Blist) (bytes : list byte)
                     (b0 b1 b2 b3 b4 b5 b6 b7 : bool) (b : byte),
                bytes_bits_lists bits bytes ->
                convertByteBits [b0; b1; b2; b3; b4; b5; b6; b7] b ->
                bytes_bits_lists (b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: bits)
                                 (b :: bytes).

Definition div_mod (num : Z) (denom : Z) : bool * Z :=
  (Z.gtb (num / denom) 0, num mod denom).

Definition byteToBits (byte : byte) : Blist :=
  let (b7, rem7) := div_mod (Byte.unsigned byte) 128 in
  let (b6, rem6) := div_mod rem7 64 in
  let (b5, rem5) := div_mod rem6 32 in
  let (b4, rem4) := div_mod rem5 16 in
  let (b3, rem3) := div_mod rem4 8 in
  let (b2, rem2) := div_mod rem3 4 in
  let (b1, rem1) := div_mod rem2 2 in
  let (b0, rem0) := div_mod rem1 1 in
  [b0; b1; b2; b3; b4; b5; b6; b7].

Fixpoint bytesToBits (bytes : list byte) : Blist :=
  match bytes with
    | [] => []
    | byte :: xs => byteToBits byte ++ bytesToBits xs
  end.

Definition bitsToByte (bits : Blist) : byte :=
  Byte.repr 
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: nil =>
      (1 * (asZ b0) + 2 * (asZ b1) + 4 * (asZ b2) + 8 * (asZ b3)
      + 16 * (asZ b4) + 32 * (asZ b5) + 64 * (asZ b6) + 128 * (asZ b7))
    | _ => -1                  
  end.

Fixpoint bitsToBytes (bits : Blist) : list byte :=
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs =>
      bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] :: bitsToBytes xs
    | _ => []
  end.

Lemma byteToBits_length bt: length (byteToBits bt) = 8%nat.

Lemma bytes_bits_length : forall (bits : Blist) (bytes : list byte),
  bytes_bits_lists bits bytes -> length bits = (length bytes * 8)%nat.

Lemma bytesToBits_app : forall (l1 l2 : list byte),
                          bytesToBits (l1 ++ l2) = bytesToBits l1 ++ bytesToBits l2.

Lemma bytesToBits_len : forall (l : list byte),
                          length (bytesToBits l) = (length l * 8)%nat.

Theorem byte_bit_byte_id : forall (b : byte),
                                bitsToByte (byteToBits b) = b.

Theorem bits_byte_bits_id : forall (b0 b1 b2 b3 b4 b5 b6 b7 : bool),
                              [b0; b1; b2; b3; b4; b5; b6; b7] =
                              byteToBits (bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7]).

Theorem bytes_bits_bytes_id : forall (bytes : list byte),
                                bitsToBytes (bytesToBits bytes) = bytes.

Theorem bytes_bits_def_eq : forall (bytes : list byte),
                              bytes_bits_lists (bytesToBits bytes) bytes.

Theorem bytes_bits_comp_ind : forall (bits : Blist) (bytes : list byte),
                               bits = bytesToBits bytes ->
                               bytes_bits_lists bits bytes.

Theorem bytes_bits_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bytes = bitsToBytes bits.

Theorem bits_bytes_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bits = bytesToBits bytes.

Lemma bitsToBytes_app : forall (l m : Blist),
                          InBlocks 8 l ->
                          bitsToBytes (l ++ m) = bitsToBytes l ++ bitsToBytes m.

Lemma bitsToBytes_len_gen : forall (l : Blist) (n : nat),
                          length l = (n * 8)%nat ->
                          length (bitsToBytes l) = n.

Lemma bitsToBytes_len : forall (l : Blist),
                          length l = 512%nat ->
                          Zlength (bitsToBytes l) = 64%Z.

Lemma bits_bytes_bits_id : forall (l : Blist),
                             InBlocks 8 l ->
                             bytesToBits (bitsToBytes l) = l.

Lemma bytes_bits_lists_append:
  forall (l1 : Blist) (l2 : list byte) (m1 : Blist) (m2 : list byte),
    bytes_bits_lists l1 l2
    -> bytes_bits_lists m1 m2
    -> bytes_bits_lists (l1 ++ m1) (l2 ++ m2).

Lemma bytesToBits_nil_inv l: nil = bytesToBits l -> l = nil.

Lemma bytesToBits_cons b l:
      bytesToBits (b::l) = byteToBits b ++ bytesToBits l.

Lemma byteToBits_injective: forall a b,
      byteToBits a = byteToBits b ->
      a = b.

Lemma bytesToBits_injective: forall b1 b2, bytesToBits b1 = bytesToBits b2 ->
       b1=b2.

Lemma bitsToBytes_injective8 b1 b2 (B: bitsToBytes b1 = bitsToBytes b2)
       (L1: PeanoNat.Nat.divide 8 (length b1))

Lemma bitsToByte_cons: forall bits h t, (h::t) = bitsToBytes bits ->
      exists b0, exists b1, exists b2, exists b3,
      exists b4, exists b5, exists b6, exists b7, exists xs,
      bits = b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs /\
      h = bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] /\
      t = bitsToBytes xs.

Definition intsToBits (l : list Int.int) : list bool :=
  bytesToBits (intlist_to_bytelist l).

Definition bitsToInts (l : Blist) : list Int.int :=
  bytelist_to_intlist (bitsToBytes l). *)



Require Import sepcomp.mem_interpolants.

Declare Module MEMAX : MemoryInterpolationAxioms.



Import Forward_simulation.



Definition entrypoints_compose

  (ep12 ep23 ep13 : list (val * val * signature)): Prop :=

  forall v1 v3 sig, In (v1,v3,sig) ep13 =

    exists v2, In (v1,v2,sig) ep12 /\ In (v2,v3,sig) ep23.



Inductive sem_compose_ord_eq_eq {D12 D23:Type}

  (ord12: D12 -> D12 -> Prop) (ord23: D23 -> D23 -> Prop) (C2:Type):

  (D12 * option C2 * D23) ->  (D12 * option C2 * D23) ->  Prop :=

| sem_compose_ord1 :

  forall (d12 d12':D12) (c2:C2) (d23:D23),

    ord12 d12 d12' -> sem_compose_ord_eq_eq ord12 ord23 C2 (d12,Some c2,d23) (d12',Some c2,d23)

| sem_compose_ord2 :

  forall (d12 d12':D12) (c2 c2':C2) (d23 d23':D23),

    ord23 d23 d23' -> sem_compose_ord_eq_eq ord12 ord23 C2 (d12,Some c2,d23) (d12',Some c2',d23').



Lemma well_founded_sem_compose_ord_eq_eq: forall {D12 D23:Type}

  (ord12: D12 -> D12 -> Prop) (ord23: D23 -> D23 -> Prop)  (C2:Type)

  (WF12: well_founded ord12) (WF23: well_founded ord23),

  well_founded (sem_compose_ord_eq_eq ord12 ord23 C2).

Proof.

  intros. intro. destruct a as [[d12 c2] d23].

  revert d12.

  destruct c2.

  2: constructor; intros. 2: inv H.

  revert c.

  induction d23 using (well_founded_induction WF23).

  intros.

  induction d12 using (well_founded_induction WF12).

  constructor; intros. inv H1.

  generalize (H0 d0). simpl. intros.

  apply H1. auto.

  generalize (H d1).

  intros.

  spec H1. auto.

  apply H1.

Qed.



Module Forward_simulation_trans.

Section Coop_sim_trans.

Context {F1 V1 C1 F2 V2 C2 F3 V3 C3:Type}

        (Sem1 : CoopCoreSem (Genv.t F1 V1) C1)

        (Sem2 : CoopCoreSem (Genv.t F2 V2) C2)

        (Sem3 : CoopCoreSem (Genv.t F3 V3) C3)

        (g1 : Genv.t F1 V1)

        (g2 : Genv.t F2 V2)

        (g3 : Genv.t F3 V3)

        epts12 epts23 epts13

        (EPC : entrypoints_compose epts12 epts23 epts13).



Section CaseEQ.

  Import Forward_simulation_eq.



Section EQEQ.

Lemma diagram_eqeq: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> C2 -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m : mem) (st1' : C1) (m' : mem),

                 corestep Sem1 g1 st1 m st1' m' ->

                 forall (d : core_data12) (st2 : C2),

                 match_core12 d st1 st2 ->

                 exists st2' : C2,

                   exists d' : core_data12,

                     match_core12 d' st1' st2' /\

                     (corestep_plus Sem2 g2 st2 m st2' m' \/

                      corestep_star Sem2 g2 st2 m st2' m' /\

                      core_ord12 d' d))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> C3 -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m : mem) (st1' : C2) (m' : mem),

                 corestep Sem2 g2 st1 m st1' m' ->

                 forall (d : core_data23) (st2 : C3),

                 match_core23 d st1 st2 ->

                 exists st2' : C3,

                   exists d' : core_data23,

                     match_core23 d' st1' st2' /\

                     (corestep_plus Sem3 g3 st2 m st2' m' \/

                      corestep_star Sem3 g3 st2 m st2' m' /\

                      core_ord23 d' d))

(c1 : C1)

(m1 : mem)

(c1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 c1 m1 c1' m1')

(d12 : core_data12)

(d23 : core_data23)

(c3 : C3)

(c2 : C2)

(MC12 : match_core12 d12 c1 c2)

(MC23 : match_core23 d23 c2 c3),

exists st2' : C3,

  exists d' : core_data12 * option C2 * core_data23,

    (let (y, d2) := d' in

     let (d1, X) := y in

     exists c0 : C2,

       X = Some c0 /\ match_core12 d1 c1' c0 /\ match_core23 d2 c0 st2') /\

    (corestep_plus Sem3 g3 c3 m1 st2' m1' \/

     corestep_star Sem3 g3 c3 m1 st2' m1' /\

     clos_trans (core_data12 * option C2 * core_data23)

       (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) d'

       (d12, Some c2, d23)).

Proof.

  intros.

  destruct (core_diagram12 _ _ _ _ CS1 _ _ MC12) as [c2' [d12' [MC12' Y]]].

  assert (ZZ: corestep_plus Sem2 g2 c2 m1 c2' m1' \/  (c2,m1) = (c2',m1') /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

     clear Y. destruct ZZ as [CS2 | CS2 ord12'].

     

    destruct CS2.

    clear MC12 CS1.

    revert d23 c2 m1 c2' m1' c3 MC23 MC12' H.

    induction x; intros.

       simpl in H.

          destruct H as [c3' [m3' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ MC23) as [c3' [d23' [? ?]]].

          exists c3'. exists (d12',Some c2',d23').

          split. exists c2'. split. trivial. split; assumption.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [c2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 c2 m1 c2'' m2'' H _ _ MC23) as [c3' [d'' [? ?]]].

           specialize (IHx _ _ _ _ _ _ H1 MC12' H0).

           destruct IHx as [c3'' [d''' [? ?]]].

           exists c3''. exists d'''.

           split; auto.

           
           destruct H2; destruct H4.

           

              left. destruct H2 as [n1 ?]. destruct H4 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H4.

               left. destruct H2 as [n1 ?]. destruct H4 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H4 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H4.

               split. destruct H2 as [n1 ?]. destruct H4 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H5.

  

    destruct CS2. inv H.

    exists c3. exists (d12',Some c2',d23).

    split. exists c2'.  split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

    apply t_step. constructor 1; auto.

Qed.



Lemma eqeq: forall

   (SimEq12 : Forward_simulation_equals Sem1 Sem2 g1 g2 epts12)

   (SimEq23 : Forward_simulation_equals Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_equals Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimEq12 as [core_data12 match_core12 core_ord12 core_ord_wf12

     genvs_dom_eq12 core_diagram12 core_initial12 core_halted12

     core_at_external12 core_after_external12].

  destruct SimEq23 as [core_data23 match_core23 core_ord23 core_ord_wf23

     genvs_dom_eq23 core_diagram23 core_initial23 core_halted23

     core_at_external23 core_after_external23].

  eapply Forward_simulation_eq.Build_Forward_simulation_equals with

    (core_data:= prod (prod core_data12 (option C2)) core_data23)

    (match_core := fun d c1 c3 => match d with (d1,X,d2) =>

      exists c2, X=Some c2 /\ match_core12 d1 c1 c2 /\ match_core23 d2 c2 c3 end)

    (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2)).

           

  eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

           

             eapply genvs_domain_eq_trans; eauto.

           

  clear core_initial23  core_halted23 core_at_external23 core_after_external23 core_initial12

    core_halted12 core_at_external12 core_after_external12  EPC epts12  epts23 epts13.

  intros. destruct d as [[d12 cc2] d23]. destruct H0 as [c2 [X [? ?]]]; subst.

  eapply (diagram_eqeq _ _ _ core_diagram12 _ _ _ core_diagram23); eassumption.

           

  intros. rename v2 into v3. rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

  destruct (core_initial12 _ _ _ EP12 vals) as [d12 [c1 [c2 [Ini1 [Ini2 MC12]]]]].

  destruct (core_initial23 _ _ _ EP23 vals) as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]].

  rewrite Ini22 in Ini2. inv Ini2.

  exists (d12,Some c2,d23). exists c1. exists c3. split; trivial. split; trivial.

    exists c2. split; trivial. split; trivial.

           

  intros. rename c2 into c3. destruct cd as [[d12 cc2] d23].

    destruct H as [c2 [X [MC12 MC23]]]. subst.

  apply (core_halted12 _ _ _ _ MC12) in H0.

  apply (core_halted23 _ _ _ _ MC23) in H0. assumption.

           

  intros. rename st2 into st3. destruct d as [[d12cc2]  d23].

    destruct H as [st2 [X [MC12 MC23]]]; subst.

  apply (core_at_external12 _ _ _ _ _ _ MC12) in H0.

  apply (core_at_external23 _ _ _ _ _ _ MC23) in H0. assumption.

          

  intros. rename st2 into st3. destruct d as [[d12 cc2] d23].

    destruct H as [st2 [X [MC12 MC23]]]; subst.

  specialize (core_at_external12 _ _ _ _ _ _ MC12 H0).

  destruct (core_after_external12 _ _ _ ret _ _ _ MC12 H0 core_at_external12)

    as [c1' [c2' [d12' [AftExt1 [AftExt2 MS12']]]]].

  destruct (core_after_external23 _ _ _ ret _ _ _ MC23 core_at_external12 H1)

    as [c22' [c3' [d23' [AftExt22 [AftExt3 MS23']]]]].

  rewrite AftExt22 in AftExt2. inv AftExt2.

  exists c1'. exists c3'. exists (d12',Some c2',d23'). split; trivial.

    split; trivial. exists c2'. split; trivial. split; trivial.

Qed.



End EQEQ.



Section EQEXT.

  Import Forward_simulation_ext.

Lemma diagram_eqext: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> C2 -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m : mem) (st1' : C1) (m' : mem),

                 corestep Sem1 g1 st1 m st1' m' ->

                 forall (d : core_data12) (st2 : C2),

                 match_core12 d st1 st2 ->

                 exists st2' : C2,

                   exists d' : core_data12,

                     match_core12 d' st1' st2' /\

                     (corestep_plus Sem2 g2 st2 m st2' m' \/

                      corestep_star Sem2 g2 st2 m st2' m' /\

                      core_ord12 d' d))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                 corestep Sem2 g2 st1 m1 st1' m1' ->

                 forall (cd : core_data23) (st2 : C3) (m2 : mem),

                 match_core23 cd st1 m1 st2 m2 ->

                 exists st2' : C3,

                   exists m2' : mem,

                     exists cd' : core_data23,

                       match_core23 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem3 g3 st2 m2 st2' m2' \/

                        corestep_star Sem3 g3 st2 m2 st2' m2' /\ core_ord23 cd' cd))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(m3 : mem)

(st2 : C2)

(MC12: match_core12 d12 st1 st2)

(MC23: match_core23 d23 st2 m1 st3 m3),

exists st2' : C3,

  exists m2' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      (let (y, d2) := cd' in

       let (d1, X) := y in

       exists c2 : C2,

         X = Some c2 /\

         match_core12 d1 st1' c2 /\ match_core23 d2 c2 m1' st2' m2') /\

      (corestep_plus Sem3 g3 st3 m3 st2' m2' \/

       corestep_star Sem3 g3 st3 m3 st2' m2' /\

       clos_trans (core_data12 * option C2 * core_data23)

         (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

         (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ MC12) as [st2' [d12' [MC12' Y]]].

    assert (ZZ: corestep_plus Sem2 g2 st2 m1 st2' m1' \/  (st2,m1) = (st2',m1')

             /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

     

    destruct CS2.

    clear MC12 CS1.

    revert d23 st2 m1 st2' m1' st3 m3 MC23 MC12' H.

    induction x; intros.

       simpl in H.

          destruct H as [st3' [m3' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ _ MC23) as [st3' [m3' [d23' [? ?]]]].

          exists st3'. exists m3'. exists (d12',Some st2',d23').

          split. exists st2'. split. trivial. split; assumption.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [st2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 st2 m1 st2'' m2'' H _ _ _ MC23) as [c3' [m3' [d'' [? ?]]]].

           specialize (IHx _ _ _ _ _ _ _ H1 MC12' H0).

           destruct IHx as [c3'' [m3'' [[[d12''' cc2''] d23'']  [[c2'' [X [MC12'' MC23'']]] ?]]]].

             subst.

           exists c3''. exists m3''. exists (d12''', Some c2'',d23'').

           split. exists c2''. auto.

           
           destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m3. exists (d12',Some st2',d23).

    split. exists st2'.  split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

    apply t_step. constructor 1; auto.

Qed.



Lemma eqext: forall

   (SimEq12 : Forward_simulation_equals Sem1 Sem2 g1 g2 epts12)

   (SimExt23 : Forward_simulation_extends Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_extends Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimEq12 as [core_data12 match_core12 core_ord12 core_ord_wf12

    genvs_dom_eq12 core_diagram12 core_initial12 core_halted12

    core_at_external12 core_after_external12].

  destruct SimExt23 as [core_data23 match_core23 core_ord23 core_ord_wf23

    genvs_dom_eq23 match_validblocks23

    core_diagram23 core_initial23 core_halted23 core_at_external23 core_after_external23].

  eapply Build_Forward_simulation_extends with

    (match_state := fun d c1 m1 c3 m3 => match d with (d1,X,d2) =>

       exists c2, X = Some c2 /\ match_core12 d1 c1 c2 /\ match_core23 d2 c2 m1 c3 m3 end)

    (core_data:= prod (prod core_data12 (option C2)) core_data23)

    (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2)).

           

  eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

           

             eapply genvs_domain_eq_trans; eauto.

            

  intros. rename c2 into c3.  rename m2 into m3.

  destruct d as [[d12 cc2] d23].

  destruct H as [c2 [X [MC12 MC23]]]; subst.

  eapply (match_validblocks23 _ _ _ _ _ MC23); try eassumption.

           

  clear core_initial23  core_halted23 core_at_external23

    core_after_external23 core_initial12  core_halted12

    core_at_external12 core_after_external12

    core_ord_wf23 core_ord_wf12 EPC epts12  epts23 epts13.

  intros. rename st2 into st3.

  destruct cd as [[d12 cc2] d23]. destruct H0 as [st2 [X [? ?]]]; subst. rename m2 into m3.

  eapply (diagram_eqext _ _ _ core_diagram12 _ _ _ core_diagram23); eassumption.

           

  intros. rename v2 into v3. rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

  destruct (core_initial12 _ _ _ EP12 vals) as [d12 [c1 [c2 [Ini1 [Ini2 MC12]]]]].

  destruct (core_initial23 _ _ _ EP23 vals vals' _ _ H0 H1)

    as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]].

  rewrite Ini22 in Ini2. inv Ini2.

  exists (d12,Some c2,d23). exists c1. exists c3.

  split; trivial. split; trivial. exists c2. split; trivial. split; trivial.

           

  intros. rename st2 into c3.

    destruct cd as [[d12 cc2] d23].

    destruct H as [c2 [X [MC12 MC23]]]; subst.

  apply (core_halted12 _ _ _ _ MC12) in H0.

  apply (core_halted23 _ _ _ _ _ _ MC23) in H0. assumption.

           

  intros. rename st2 into st3. destruct cd as [[d12 cc2] d23]. destruct H as [st2 [X [MC12 MC23]]].

  apply (core_at_external12 _ _ _ _ _ _ MC12) in H0.

  apply (core_at_external23 _ _ _ _ _ _ _ _ MC23) in H0. assumption.

           

  intros. rename st2 into st3. destruct cd as [[d12 cc2] d23]. destruct H as [st2 [X [MC12 MC23]]].

  specialize (core_at_external12 _ _ _ _ _ _ MC12 H0).

  rename core_at_external12 into AtExt2.

  destruct (core_after_external12 _ _ _ ret1 _ _ _ MC12 H0 AtExt2)

    as [c1' [c2' [d12' [AftExt1 [AftExt2 MS12']]]]].

  destruct (core_after_external23 _ _ _ _ _ _ _ _ _ _ _ _ _ MC23 AtExt2

    H1 H2 H3 H4 H5 H6 H7)

    as [c22' [c3' [d23' [AftExt22 [AftExt3 MS23']]]]].

  rewrite AftExt22 in AftExt2. inv AftExt2.

  exists c1'. exists c3'. exists (d12',Some c2',d23').

  split; trivial. split; trivial. exists c2'. split; trivial. split; trivial.

Qed.



End EQEXT.



Lemma X: forall {A B} (f g: A ->B)

      (H: (fun b => f b) = (fun b => g b)) b,

       f b = g b.

Proof. intros.

  remember ((fun b => f b) b).

     rewrite H in Heqb0. trivial.

Qed.



Section EQINJ.

  Import Forward_simulation_inj.

Lemma diagram_eqinj: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> C2 -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m : mem) (st1' : C1) (m' : mem),

                 corestep Sem1 g1 st1 m st1' m' ->

                 forall (d : core_data12) (st2 : C2),

                 match_core12 d st1 st2 ->

                 exists st2' : C2,

                   exists d' : core_data12,

                     match_core12 d' st1' st2' /\

                     (corestep_plus Sem2 g2 st2 m st2' m' \/

                      corestep_star Sem2 g2 st2 m st2' m' /\

                      core_ord12 d' d))

(core_data23 : Type)

(match_core23 : core_data23 -> meminj -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                 corestep Sem2 g2 st1 m1 st1' m1' ->

                 forall (cd : core_data23) (st2 : C3) (j : meminj) (m2 : mem),

                 match_core23 cd j st1 m1 st2 m2 ->

                 exists st2' : C3,

                   exists m2' : mem,

                     exists cd' : core_data23,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core23 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem3 g3 st2 m2 st2'

                            m2' \/

                          corestep_star Sem3 g3 st2 m2 st2'

                            m2' /\ core_ord23 cd' cd))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(j : meminj)

(m3 : mem)

(st2 : C2)

(MC12: match_core12 d12 st1 st2)

(MC23: match_core23 d23 j st2 m1 st3 m3),

exists st2' : C3,

  exists m2' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      exists j' : meminj,

        inject_incr j j' /\

        inject_separated j j' m1 m3 /\

        (let (y, d2) := cd' in

         let (d1, X) := y in

         exists c2 : C2,

           X = Some c2 /\

           match_core12 d1 st1' c2 /\ match_core23 d2 j' c2 m1' st2' m2') /\

        (corestep_plus Sem3 g3 st3 m3 st2' m2' \/

         corestep_star Sem3 g3 st3 m3 st2' m2' /\

         clos_trans (core_data12 * option C2 * core_data23)

           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

           (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ MC12)

      as [st2' [d12' [MC12' Y]]]. clear core_diagram12.

    assert (ZZ: corestep_plus Sem2 g2 st2 m1 st2' m1'

      \/  (st2,m1) = (st2',m1') /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

      rename m1 into m2. rename m1' into m2'.

    destruct CS2.

    clear MC12 CS1.

    revert j d23 st2 m2 st2' m2' st3 m3 MC23 MC12' H.

    induction x; intros.

       simpl in H.

          destruct H as [st3' [m3' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ _ _ MC23)

            as [st3' [m3' [d23' [j' [InjInc [InjSep [? ?]]]]]]].

          exists st3'. exists m3'. exists (d12',Some st2',d23'). exists j'.

          split; trivial.

          split; trivial.

          split. exists st2'. split. trivial. split; assumption.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [st2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 st2 m2 st2'' m2'' H _ _ _ _ MC23)

             as [c3' [m3' [d'' [j' [InjInc [InjSep [? ?]]]]]]].

           specialize (IHx _ _ _ _ _ _ _ _ H1 MC12' H0).

           destruct IHx as [c3'' [m3'' [[[d12''' cc2''] d23'']

             [j'' [IncIncr' [InSep' [[c2'' [X [MC12'' MC23'']]] ?]]]]]]]. subst.

           exists c3''. exists m3''. exists (d12''', Some c2'',d23''). exists j''.

           split. eapply inject_incr_trans; eassumption.

           split. apply corestep_fwd in H.

                 intros b; intros.

                 remember (j' b).

                 destruct o; apply eq_sym in Heqo.

                      destruct p. destruct (InjSep _ _ _ H4 Heqo).

                      apply (IncIncr') in Heqo. rewrite Heqo in H5.  inv H5.

                      split; trivial.

                 destruct (InSep' _ _ _ Heqo H5). split.

                    intros N. apply H6. apply H. apply N.

                    intros N. apply H7.

                        assert (FWD: mem_forward m3 m3').

                           destruct H2 as [X | [X _]].

                           eapply corestep_plus_fwd; eassumption.

                           eapply corestep_star_fwd; eassumption.

                        apply FWD. apply N.

           split. exists c2''. auto.

           
           destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m3. exists (d12',Some st2',d23). exists j.

    split. apply inject_incr_refl.

    split. apply inject_separated_same_meminj.

    split. exists st2'.  split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

                       apply t_step. constructor 1; auto.

Qed.



Lemma eqinj: forall

   (SimEq12 : Forward_simulation_equals Sem1 Sem2 g1 g2 epts12)

   (SimInj23 : Forward_simulation_inject Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_inject Sem1 Sem3 g1 g3 epts13.

Proof. intros.

         destruct SimEq12 as [core_data12 match_core12 core_ord12 core_ord_wf12

               genvs_domain_eq12 core_diagram12 core_initial12 core_halted12

               core_at_external12 core_after_external12].

         destruct SimInj23 as [core_data23 match_core23 core_ord23 core_ord_wf23

              match_validblock23 genvs_dom_eq23 match_genv23 core_diagram23

              core_initial23 core_halted23 core_at_external23 core_after_external23].

          eapply Build_Forward_simulation_inject with

                 (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

                 (match_state := fun d j c1 m1 c3 m3 =>

                   match d with (d1,X,d2) =>

                     exists c2, X=Some c2

                       /\ match_core12 d1 c1 c2

                       /\ match_core23 d2 j c2 m1 c3 m3 end).

            

                 eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

             intros. rename c2 into c3.

                         rename m2 into m3. destruct d as [[d12 cc2] d23].

                         destruct H as [c2 [X [MC12 MC23]]]; subst.

                         eapply (match_validblock23 _ _ _ _ _ _ MC23); try eassumption.

           

             eapply genvs_domain_eq_trans; eauto.

            

                 intros.

                 clear core_initial23  core_halted23 core_at_external23

                       core_after_external23 core_initial12 core_halted12

                       core_at_external12 core_after_external12

                       core_diagram12 core_diagram23.

                 rename c2 into st3.

                 destruct d as [[d12 cc2] d23]. destruct H as [st2 [X [? ?]]]; subst.

                   rename m2 into m3.

                 apply meminj_preserves_genv2blocks.

                 rewrite (genvs_domain_eq_match_genvs _ _ genvs_domain_eq12).

                 apply meminj_preserves_genv2blocks.

                 apply (match_genv23 _ _ _ _ _ _ H0).

            

                 clear core_initial23 core_halted23 core_at_external23

                       core_after_external23 core_initial12  core_halted12

                       core_at_external12 core_after_external12

                       EPC epts12 epts23 epts13.

                 intros. rename st2 into st3.

                 destruct cd as [[d12 cc2] d23].

                   destruct H0 as [st2 [X [? ?]]]; subst. rename m2 into m3.

                 eapply (diagram_eqinj _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

            

                  intros. rename v2 into v3. rewrite (EPC v1 v3 sig) in H.

                    destruct H as [v2 [EP12 EP23]].

                  destruct (core_initial12 _ _ _ EP12 vals1)

                    as [d12 [c11 [c2 [Ini1 [Ini2 MC12]]]]]. rewrite Ini1 in H0. inv H0.

                  destruct (core_initial23 _ _ _ EP23 _ _ _ _ _ _  Ini2 H1 H2)

                    as [d23 [c3 [Ini3 MC23]]].

                  apply meminj_preserves_genv2blocks.

                     apply meminj_preserves_genv2blocks in H3.

                     apply (genvs_domain_eq_preserves g1); assumption.

                  exists (d12,Some c2,d23). exists c3. split; trivial. exists c2. auto.

             

                    intros. rename c2 into c3. destruct cd as [[d12 cc2] d23].

                      destruct H as [c2 [X [MC12 MC23]]]; subst.

                    apply (core_halted12 _ _ _ _ MC12) in H0; try assumption.

                    apply (core_halted23 _ _ _ _ _ _ _ MC23) in H0; try assumption.

             

                    intros. rename st2 into st3. destruct cd as [[d12 cc2] d23].

                    destruct H as [c2 [X [MC12 MC23]]]; subst.

                    apply (core_at_external12 _ _ _ _ _ _ MC12) in H0.

                    apply (core_at_external23 _ _ _ _ _ _ _ _ _ MC23) in H0; try assumption.

             

                    intros. rename st2 into st3. destruct cd as [[d12 cc2] d23].

                    destruct H0 as [c2 [X [MC12 MC23]]]; subst.

                    specialize (core_at_external12 _ _ _ _ _ _ MC12 H1).

                    rename core_at_external12 into AtExt2.

                    destruct (core_after_external12 _ _ _ ret1 _ _ _ MC12 H1 AtExt2)

                      as [c1' [c2' [d12' [AftExt1 [AftExt2 MS12']]]]].

                    assert (PG2: meminj_preserves_globals g2 j).

                      solve[apply (match_genv23 _ _ _ _ _ _ MC23)].

                    destruct (core_after_external23 _ _ _ _ _ _ _ _ _ _ _ _ _ _

                        H MC23 AtExt2 PG2 H3 H4 H5 H6 H7 H8 H9 H10)

                    as [d23' [c22' [c3' [AftExt22 [AftExt3 MS23']]]]].

                    rewrite AftExt22 in AftExt2. inv AftExt2.

                    exists (d12',Some c2',d23'). exists c1'. exists c3'.

                    split; trivial. split; trivial. exists c2'. auto.

Qed.

End EQINJ.



Lemma coop_sim_trans_CaseEq: forall

     (SimEq12 : Forward_simulation_equals Sem1 Sem2 g1 g2 epts12)

     (SIM23 : coop_sim Sem2 Sem3 g2 g3 epts23),

     coop_sim Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  induction SIM23; intros.

  eapply coop_sim_eq.

    apply (eqeq SimEq12 R).

  eapply coop_sim_ext.

    apply (eqext SimEq12 R).

  eapply coop_sim_inj.

    apply (eqinj SimEq12 R).

Qed.



End CaseEQ.



Section CaseEXT.

  Import Forward_simulation_ext.



Section EXTEQ.

  Import Forward_simulation_eq.

Lemma  diagram_exteq: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (m2 : mem),

                 match_core12 cd st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       match_core12 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem2 g2 st2 m2 st2'

                          m2' \/

                        corestep_star Sem2 g2 st2 m2 st2'

                          m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> C3 -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m : mem) (st1' : C2) (m' : mem),

                 corestep Sem2 g2 st1 m st1' m' ->

                 forall (d : core_data23) (st2 : C3),

                 match_core23 d st1 st2 ->

                 exists st2' : C3,

                   exists d' : core_data23,

                     match_core23 d' st1' st2' /\

                     (corestep_plus Sem3 g3 st2 m st2' m' \/

                      corestep_star Sem3 g3 st2 m st2' m' /\

                      core_ord23 d' d))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(m3 : mem)

(st2 : C2)

(MC12 : match_core12 d12 st1 m1 st2 m3)

(MC23: match_core23 d23 st2 st3),

exists st3' : C3,

  exists m3' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      (let (y, d2) := cd' in

       let (d1, X) := y in

       exists c2 : C2,

         X = Some c2 /\

         match_core12 d1 st1' m1' c2 m3' /\ match_core23 d2 c2 st3') /\

      (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

       corestep_star Sem3 g3 st3 m3 st3' m3' /\

       clos_trans (core_data12 * option C2 * core_data23)

         (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

         (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ _ MC12)

      as [st2' [m3' [d12' [MC12' Y]]]]. clear core_diagram12.

    assert (ZZ: corestep_plus Sem2 g2 st2 m3 st2' m3' \/  (st2,m3) = (st2',m3')

             /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

     

    destruct CS2.

    clear MC12 CS1.

    revert d23 st2 st2' m3' st3 m3 MC23 MC12' H.

    induction x; intros.

       simpl in H.

          destruct H as [c2 [m2 [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _  MC23) as [st3' [d23' [? ?]]].

          exists st3'. exists m3'. exists (d12',Some st2',d23').

          split. exists st2'. split. trivial. split; assumption.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [st2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 _ _ _ _  H _ _ MC23) as [c3' [d'' [? ?]]].

           specialize (IHx _ _ _ _ _ _ H1 MC12' H0).

           destruct IHx as [c3'' [m3'' [[[d12''' cc2''] d23'']

                           [[c2'' [X [MC12'' MC23'']]] ?]]]]; subst.

           exists c3''. exists m3''. exists (d12''', Some c2'',d23'').

           split. exists c2''. auto.

           
           destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m3'. exists (d12',Some st2',d23).

    split. exists st2'.  split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

                       apply t_step. constructor 1; auto.

Qed.



Lemma exteq: forall

   (SimExt12 : Forward_simulation_extends Sem1 Sem2 g1 g2 epts12)

   (SimEq23 : Forward_simulation_equals Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_extends Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimExt12 as [core_data12 match_core12 core_ord12 core_ord_wf12 genvs_dom_eq12

                 match_validblocks12 core_diagram12 core_initial12 core_halted12

                 core_at_external12 core_after_external12].

  destruct SimEq23 as [core_data23 match_core23 core_ord23 core_ord_wf23

                       genvs_dom_eq23 core_diagram23 core_initial23

                       core_halted23 core_at_external23 core_after_external23].

  eapply Forward_simulation_ext.Build_Forward_simulation_extends with

                 (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

                 (match_state := fun d c1 m1 c3 m3 => match d with (d1,X,d2) =>

                    exists c2, X=Some c2

                      /\ match_core12 d1 c1 m1 c2 m3

                      /\ match_core23 d2 c2 c3 end).

            

                 eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

            

                 eapply genvs_domain_eq_trans; eauto.

             intros. rename c2 into c3.

                 rename m2 into m3. destruct d as [[d12 cc2] d23].

                 destruct H as [c2 [X [MC12 MC23]]]; subst.

                 eapply (match_validblocks12 _ _ _ _ _ MC12); try eassumption.

            

                 clear core_initial23  core_halted23 core_at_external23

                       core_after_external23 core_initial12  core_halted12

                       core_at_external12 core_after_external12

                       EPC epts12  epts23 epts13.

                 intros. rename st2 into st3.

                 destruct cd as [[d12 cc2] d23].

                   destruct H0 as [st2 [X [? ?]]]; subst. rename m2 into m3.

                 eapply (diagram_exteq _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

            

                  intros. rename v2 into v3. rewrite (EPC v1 v3 sig) in H.

                    destruct H as [v2 [EP12 EP23]].

                  destruct (core_initial12 _ _ _ EP12 _ _ _ _ H0 H1)

                    as [d12 [c1 [c2 [Ini1 [Ini2 MC12]]]]].

                  destruct (core_initial23 _ _ _ EP23 vals') as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]].

                  rewrite Ini22 in Ini2. inv Ini2.

                  exists (d12,Some c2, d23). exists c1. exists c3.

                  split; trivial. split; trivial. exists c2. split; trivial. split; trivial.

             

                  intros. rename st2 into c3.  destruct cd as [[d12 cc2] d23].

                    destruct H as [c2 [X [MC12 MC23]]]; subst.

                  apply (core_halted12 _ _ _ _ _ _ MC12) in H0. destruct H0 as [v2 [LD [SH2 Ext]]].

                  apply (core_halted23 _ _ _ _ MC23) in SH2. exists v2.

                    split; trivial. split; trivial.

             

                  intros. rename st2 into st3.

                  destruct cd as [[d12 cc2] d23]. destruct H as [c2 [X [MC12 MC23]]]; subst.

                  apply (core_at_external12 _ _ _ _ _ _ _ _ MC12) in H0.

                    destruct H0 as [vals2 [Ext [LD AtExt2]]].

                    specialize (core_at_external23 _ _ _ _ _ _ MC23 AtExt2).

                    exists vals2. intuition.

             

                  intros. rename st2 into st3. destruct cd as [[d12 cc2] d23].

                  destruct H as [c2 [X [MC12 MC23]]]; subst.

                  rename vals2 into vals3. rename ret2 into ret3.

                  destruct (core_at_external12 _ _ _ _ _ _ _ _ MC12 H0)

                     as [vals2 [Ext [LD AtExt2]]].

                  specialize (core_at_external23 _ _ _ _ _ _ MC23 AtExt2).

                  rename core_at_external23 into AtExt3.

                  rewrite AtExt3 in H1. inv H1.

                  destruct (core_after_external12 _ _ _ _ _ _ _ _ _ _ _ _ _

                       MC12 H0 AtExt2 LD H3 H4 H5 H6 H7)

                    as [c1' [c2' [d12' [AftExt1 [AftExt2 MS12']]]]].

                  destruct (core_after_external23 _ _ _ ret3 _ _ _

                       MC23 AtExt2 AtExt3)

                    as [c22' [c3' [d23' [AftExt22 [AftExt3 MS23']]]]].

                  rewrite AftExt22 in AftExt2. inv AftExt2.

                  exists c1'. exists c3'. exists (d12',Some c2', d23').

                  split; trivial. split; trivial. exists c2'. intuition.

Qed.

End EXTEQ.



Section EXTEXT.

Lemma  diagram_extext: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (m2 : mem),

                 match_core12 cd st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       match_core12 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem2 g2 st2 m2 st2'

                          m2' \/

                        corestep_star Sem2 g2 st2 m2 st2'

                          m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                 corestep Sem2 g2 st1 m1 st1' m1' ->

                 forall (cd : core_data23) (st2 : C3) (m2 : mem),

                 match_core23 cd st1 m1 st2 m2 ->

                 exists st2' : C3,

                   exists m2' : mem,

                     exists cd' : core_data23,

                       match_core23 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem3 g3 st2 m2 st2'

                          m2' \/

                        corestep_star Sem3 g3 st2 m2 st2'

                          m2' /\ core_ord23 cd' cd))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(m3 : mem)

(st2 : C2)

(m2 : mem)

(MC12 : match_core12 d12 st1 m1 st2 m2)

(MC23 : match_core23 d23 st2 m2 st3 m3),

exists st3' : C3,

  exists m3' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      (let (y, d2) := cd' in

       let (d1, X) := y in

       exists c2 : C2,

         exists m2 : mem,

           X = Some c2 /\

           match_core12 d1 st1' m1' c2 m2 /\ match_core23 d2 c2 m2 st3' m3') /\

      (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

       corestep_star Sem3 g3 st3 m3 st3' m3' /\

       clos_trans (core_data12 * option C2 * core_data23)

         (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

         (d12, Some st2, d23)).

Proof.

  intros.

  destruct (core_diagram12 _ _ _ _ CS1 _ _ _ MC12)

           as [st2' [m2' [d12' [MC12' Y]]]].

  clear core_diagram12.

  assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2' \/

               (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

    destruct Y. auto.

    destruct H.

    destruct H. destruct x.

    right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

    

    destruct CS2.

    clear MC12 CS1.

    revert d23 st2 st2' m2' m2 st3 m3 MC23 MC12' H.

    induction x; intros.

     simpl in H.

      destruct H as [c2 [m2'' [? ?]]].

      inv H0.

      destruct (core_diagram23 _ _ _ _ H _ _ _ MC23)

           as [st3' [m3' [d23' [? ?]]]].

      exists st3'. exists m3'. exists (d12',Some st2',d23').

      split. exists st2'. exists m2'. split. trivial. split; assumption.

      destruct H1. left; assumption.

      destruct H1. right. split; trivial.

      apply t_step. constructor 2. apply H2.

    

      remember (S x) as x'. simpl in H.

      destruct H as [st2'' [m2'' [? ?]]]. subst x'.

      destruct (core_diagram23 _ _ _ _  H _ _ _ MC23)

           as [c3' [m3' [d'' [? ?]]]].

      specialize (IHx _ _ _ _ _ _ _ H1 MC12' H0).

      destruct IHx as [c3'' [m3'' [[[d12''' cc2''] d23'']

        [[c2'' [m2'''' [X [MC12'' MC23'']]]] ?]]]]; subst.

      exists c3''. exists m3''. exists (d12''', Some c2'',d23'').

      split. exists c2''. exists m2''''. auto.

      destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m3. exists (d12',Some st2',d23).

    split. exists st2'. exists m2'. split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

    apply t_step. constructor 1; auto.

Qed.



Lemma extext: forall

  (SimExt12 : Forward_simulation_extends Sem1 Sem2 g1 g2 epts12)

  (SimExt23 : Forward_simulation_extends Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_extends Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimExt12 as [core_data12 match_core12 core_ord12 core_ord_wf12

                        genvs_dom_eq12 match_vb12 core_diagram12

                        core_initial12 core_halted12 core_at_external12

                        core_after_external12].

  destruct SimExt23 as [core_data23 match_core23 core_ord23 core_ord_wf23

                        genvs_dom_eq23 match_vb23 core_diagram23

                        core_initial23 core_halted23 core_at_external23

                        core_after_external23].

  eapply Forward_simulation_ext.Build_Forward_simulation_extends with

    (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

    (match_state := fun d c1 m1 c3 m3 =>

      match d with (d1,X,d2) => exists c2, exists m2, X=Some c2

        /\ match_core12 d1 c1 m1 c2 m2 /\ match_core23 d2 c2 m2 c3 m3 end).

 

  eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

 

  eapply genvs_domain_eq_trans; eauto.

 

  intros. rename c2 into c3.  rename m2 into m3. destruct d as [[d12 cc2] d23].

  destruct H as [c2 [m [X [MC12 MC23]]]]; subst.

  split; intros. eapply (match_vb23 _ _ _ _ _ MC23).

  eapply (match_vb12 _ _ _ _ _ MC12). apply H.

  eapply (match_vb12 _ _ _ _ _ MC12).

  eapply (match_vb23 _ _ _ _ _ MC23). apply H.



  clear core_initial23 core_halted23 core_at_external23 core_after_external23

             core_initial12  core_halted12 core_at_external12 core_after_external12

             EPC epts12 epts23 epts13.

  intros. rename st2 into st3. rename m2 into m3.

  destruct cd as [[d12 cc2] d23]. destruct H0 as [st2 [m2 [X [? ?]]]]; subst.

  eapply (diagram_extext _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

 

  intros. rename m2 into m3. rename vals' into args3. rename vals into args1. rename v2 into v3.

  rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

  destruct (core_initial12 _ _ _ EP12 _ _ m1 _ (forall_lessdef_refl args1) (extends_refl _))

    as [d12 [c1 [c2 [Ini1 [Ini2 MC12]]]]]; try assumption.

  destruct (core_initial23 _ _ _ EP23 _ _ _ _ H0 H1)

    as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]]; try assumption.

  rewrite Ini22 in Ini2. inv Ini2.

  exists (d12,Some c2, d23). exists c1. exists c3. split; trivial. split; trivial.

  exists c2. exists m1. split; trivial. split; trivial.

 

  intros. rename st2 into c3. rename m2 into m3.  destruct cd as [[d12 cc2] d23].

  destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

  apply (core_halted12 _ _ _ _ _ _ MC12) in H0; try assumption.

  destruct H0 as [v2 [V12 [SH2 Ext12]]].

  apply (core_halted23 _ _ _ _ _ _ MC23) in SH2; try assumption.

  destruct SH2 as [v3 [V23 [SH3 Ext23]]].

  exists v3. split. eapply Val.lessdef_trans; eassumption.

  split; trivial.

  eapply extends_trans; eassumption.

 

  intros. rename st2 into st3. rename m2 into m3.

  destruct cd as [[d12 cc2] d23].

  destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

  apply (core_at_external12 _ _ _ _ _ _ _ _ MC12) in H0; try assumption.

  destruct H0 as [vals2 [Ext12 [LD12 AtExt2]]].

  apply (core_at_external23 _ _ _ _ _ _ _ _ MC23) in AtExt2; try assumption.

  destruct AtExt2 as [vals3 [Ext23 [LS23 AtExt3]]].

  exists vals3. split. eapply extends_trans; eassumption.

  split. eapply forall_lessdef_trans; eassumption.

  solve[intuition].

 

  intros. rename st2 into st3. rename m2 into m3. rename m2' into m3'.

  rename vals2 into vals3. rename ret2 into ret3.

  destruct cd as [[d12 cc2] d23].

  destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

  destruct (core_at_external12 _ _ _ _ _ _ _ _ MC12 H0)

    as [vals2 [Ext12 [ValsLD12 AtExt2]]]; try assumption.

  destruct (core_at_external23 _ _ _ _ _ _ _ _ MC23 AtExt2)

    as [vals33 [Ext23 [ValsLD23 AtExt3]]]; try assumption.

  rewrite AtExt3 in H1. inv H1.

  assert (UnchOn3 :  Mem.unchanged_on (loc_out_of_bounds m2) m3 m3').

    split; intros; eapply H5; trivial.

    eapply extends_loc_out_of_bounds; eassumption.

    eapply extends_loc_out_of_bounds; eassumption.

  destruct (MEMAX.interpolate_EE _ _ Ext12 _ H3 _ Ext23 _ H4 H7 H5)

    as [m2' [Fwd2 [Ext12' [Ext23' UnchOn2]]]].

  destruct (core_after_external12 _ _ _ _ _ _ _ _ ret1 ret1 _ _ _ MC12 H0

      AtExt2 ValsLD12 H3 Fwd2 UnchOn2 (Val.lessdef_refl _) Ext12')

    as [c1' [c2' [d12' [AftExt1 [AftExt2 MC12']]]]].

  destruct (core_after_external23 _ _ _ _ _ _ _ _ ret1 ret3 _ _ _ MC23 AtExt2

      AtExt3 ValsLD23 Fwd2 H4 UnchOn3 H6 Ext23')

    as [cc2' [c3' [d23' [AftExt22 [AftExt3 MC23']]]]].

  rewrite AftExt22 in AftExt2. inv AftExt2.

  exists c1'. exists c3'. exists (d12',Some c2', d23'). split; trivial. split; trivial.

  exists c2'. exists m2'. intuition.

Qed.



End EXTEXT.



Section EXTINJ.

  Import Forward_simulation_inj.

Lemma  diagram_extinj: forall

(core_data12 : Type)

(match_core12 : core_data12 -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (m2 : mem),

                 match_core12 cd st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       match_core12 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem2 g2 st2 m2 st2'

                          m2' \/

                        corestep_star Sem2 g2 st2 m2 st2'

                          m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> meminj -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                 corestep Sem2 g2 st1 m1 st1' m1' ->

                 forall (cd : core_data23) (st2 : C3) (j : meminj) (m2 : mem),

                 match_core23 cd j st1 m1 st2 m2 ->

                 exists st2' : C3,

                   exists m2' : mem,

                     exists cd' : core_data23,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core23 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem3 g3 st2 m2 st2'

                            m2' \/

                          corestep_star Sem3 g3 st2 m2 st2'

                            m2' /\ core_ord23 cd' cd))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(j : meminj)

(m3 : mem)

(st2 : C2)

(m2 : mem)

(MC12 : match_core12 d12 st1 m1 st2 m2)

(MC23 : match_core23 d23 j st2 m2 st3 m3)

(match_validblocks12: forall cd st1 m1 st2 m2,

   match_core12 cd st1 m1 st2 m2 -> (forall b, Mem.valid_block m1 b -> Mem.valid_block m2 b)),

exists st3' : C3,

  exists m3' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      exists j' : meminj,

        inject_incr j j' /\

        inject_separated j j' m1 m3 /\

        (let (y, d2) := cd' in

         let (d1, X) := y in

         exists c2 : C2,

           exists m2' : mem,

             X = Some c2 /\

             match_core12 d1 st1' m1' c2 m2' /\

             match_core23 d2 j' c2 m2' st3' m3') /\

        (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

         corestep_star Sem3 g3 st3 m3 st3' m3' /\

         clos_trans (core_data12 * option C2 * core_data23)

           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

           (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ _ MC12)

      as [st2' [m2' [d12' [MC12' Y]]]]. clear core_diagram12.

    assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2'

      \/  (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

     

    destruct CS2.

    clear CS1. rename j into j23.

    cut (exists st3' : C3,  exists m3' : mem, exists d23':core_data23, exists j23' : meminj,

                  inject_incr j23 j23' /\ inject_separated j23 j23' m2 m3 /\

                   match_core23 d23' j23' st2' m2' st3' m3' /\

                   (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

                      (corestep_star Sem3 g3 st3 m3 st3' m3' /\

                        clos_trans (core_data12 * option C2 * core_data23)

                           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) (d12', Some st2', d23')

                          (d12, Some st2, d23)))).

           intros XX; destruct XX as [st3' [m3' [d23' [j23' [InjIncr23 [InjSep23 [MC23' ZZ]]]]]]].

           exists st3'. exists m3'. exists (d12', Some st2', d23'). exists j23'.

           split; trivial.

           split; trivial. intros b; intros. destruct (InjSep23 _ _ _ H0 H1).

                 split; try assumption.

                 intros N. apply H2. eapply match_validblocks12. eassumption. apply N.

           split. exists st2'. exists m2'. auto.

          apply ZZ.



    clear MC12 MC12' match_validblocks12. 

          clear st1 m1 st1' m1'. clear C1 Sem1 match_core12.



    revert j23 d23 st2 m2 st3 m3 H MC23.

    induction x; intros.

       simpl in H.

          destruct H as [c2 [m2'' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ _ _ MC23)

            as [st3' [m3' [d23' [j' [InjInc [InjSep [? ?]]]]]]].

          exists st3'. exists m3'. exists d23'. exists j'.

          split; trivial.

          split; trivial.

          split; trivial.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

          remember (S x) as x'. simpl in H.

          destruct H as [st2'' [m2'' [? ?]]]. subst x'.

          destruct (core_diagram23 _ _ _ _  H _ _ _ _ MC23)

            as [c3' [m3' [d'' [j' [InjInc [InjSep [? ?]]]]]]].

          specialize (IHx _ _ _ _ _ _ H0 H1).

          destruct IHx as [c3'' [m3'' [d23'' [j'' [InjIncr' [InjSep' [MC23'' ?]]]]]]]. subst.

          exists c3''. exists m3''. exists d23''. exists j''.

          split. eapply inject_incr_trans; eassumption.

          split. intros b. intros.

                     remember (j' b) as jb.

                     destruct jb; apply eq_sym in Heqjb.

                          destruct p. rewrite (InjIncr' _ _ _ Heqjb) in H5. inv H5.

                                   destruct (InjSep _ _ _ H4 Heqjb).

                                   split; trivial.

                     destruct (InjSep' _ _ _ Heqjb H5).

                                   split; intros N.

                                     apply corestep_fwd in H. apply H6. apply H. assumption.

                                   apply H7.

                                      destruct H2 as [HH | [HH _]].

                                        eapply corestep_plus_fwd. apply HH. assumption.

                                        eapply corestep_star_fwd. apply HH. assumption.

          split. assumption.

          destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m3. exists (d12',Some st2',d23). exists j.

    split. apply inject_incr_refl.

    split. apply inject_separated_same_meminj.

    split. exists st2'. exists m2'. split. trivial. split; assumption.

    right. split. exists O. simpl; auto.

    apply t_step. constructor 1; auto.

Qed.



Lemma extinj: forall

     (SimExt12 : Forward_simulation_extends Sem1 Sem2 g1 g2 epts12)

     (SimInj23 : Forward_simulation_inject Sem2 Sem3 g2 g3 epts23),

      Forward_simulation_inject Sem1 Sem3 g1 g3 epts13.

Proof. intros.

         destruct SimExt12 as [core_data12 match_core12 core_ord12 core_ord_wf12

                               genvs_dom_eq12 match_validblocks12 core_diagram12

                               core_initial12 core_halted12 core_at_external12

                               core_after_external12].

         destruct SimInj23 as [core_data23 match_core23 core_ord23 core_ord_wf23

                      match_validblocks23 genvs_dom_eq23 match_genv23

                      core_diagram23 core_initial23

                      core_halted23 core_at_external23 core_after_external23].

         eapply Forward_simulation_inj.Build_Forward_simulation_inject with

                (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

                (match_state := fun d j c1 m1 c3 m3 =>

                  match d with (d1,X,d2) => exists c2, exists m2, X=Some c2 /\

                    match_core12 d1 c1 m1 c2 m2 /\ match_core23 d2 j c2 m2 c3 m3 end).

            

                 eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

             intros. rename c2 into c3.  rename m2 into m3.

                 destruct d as [[d12 cc2] d23].

                 destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                 destruct (match_validblocks23 _ _ _ _ _ _ MC23 _ _ _ H0).

                 split; trivial.

                 eapply (match_validblocks12 _ _ _ _ _ MC12); try eassumption.

            

                 eapply genvs_domain_eq_trans; eauto.

            

                 clear match_validblocks12 match_validblocks23

                       core_initial23 core_diagram23 core_halted23

                       core_at_external23 core_after_external23

                       core_initial12 core_halted12 core_diagram12

                       core_at_external12 core_after_external12.

                 intros. rename c2 into c3. rename m2 into m3.

                 destruct d as [[d12 cc2] d23].

                 destruct H as [c2 [m2 [X [? ?]]]]; subst.

                 apply meminj_preserves_genv2blocks.

                 specialize (match_genv23 _ _ _ _ _ _ H0).

                 apply meminj_preserves_genv2blocks in match_genv23.

                 eapply genvs_domain_eq_preserves; eassumption.

            

                 clear core_initial23 core_halted23 core_at_external23

                   core_after_external23 core_initial12  core_halted12

                   core_at_external12 core_after_external12

                   EPC epts12 epts23 epts13.

                 intros. rename st2 into st3. rename m2 into m3.

                 destruct cd as [[d12 cc2] d23]. destruct H0 as [st2 [m2 [X [? ?]]]]; subst.

                 eapply (diagram_extinj _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

                       intros. eapply (match_validblocks12 _ _ _ _ _ H2). apply H3.

            

                 intros. rename v2 into v3. rename vals2 into vals3. rename m2 into m3.

                 rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

                 destruct (core_initial12 _ _ _ EP12 _ _ _ _

                            ( forall_lessdef_refl vals1) (Mem.extends_refl m1))

                   as [d12 [c11 [c2 [Ini1 [Ini2 MC12]]]]]. rewrite Ini1 in H0. inv H0.

                 destruct (core_initial23 _ _ _ EP23 _ _ _ _ _ _  Ini2 H1 H2)

                   as [d23 [c3 [Ini3 MC23]]].

                 apply meminj_preserves_genv2blocks.

                    apply meminj_preserves_genv2blocks in H3.

                    apply (genvs_domain_eq_preserves g1); assumption.

                 exists (d12,Some c2, d23). exists c3.

                 split; trivial. exists c2. exists m1. split; trivial. split; trivial.

             

                 intros. rename c2 into c3. rename m2 into m3.

                 destruct cd as [[d12 cc2] d23]. destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                 apply (core_halted12 _ _ _ _ _ _ MC12) in H0; try assumption.

                 destruct H0 as [v2 [LD12 [SH2 Ext12]]].

                 apply (core_halted23 _ _ _ _ _ _ _ MC23) in SH2; try assumption.

                 destruct SH2 as [v3 [InjV23 [SH3 InjM23]]].

                 exists v3. split. eapply val_lessdef_inject_compose; eassumption.

                       split; trivial.

                       eapply Mem.extends_inject_compose; eassumption.

             

                 intros. rename st2 into st3. rename m2 into m3.

                 destruct cd as [[d12 cc2] d23].

                 destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                 apply (core_at_external12 _ _ _ _ _ _ _ _ MC12) in H0; try assumption.

                 destruct H0 as [vals2 [Ext12 [LD12 AtExt2]]].

                 apply (core_at_external23 _ _ _ _ _ _ _ _ _ MC23) in AtExt2; try assumption.

                 destruct AtExt2 as [Inj23 [vals3 [InjVals23 AtExt3]]].

                 split. eapply Mem.extends_inject_compose; eassumption.

                 exists vals3.

                 split. eapply forall_val_lessdef_inject_compose; eassumption.

                 auto.

             

                 clear core_diagram12 core_diagram23 core_initial12 core_initial23

                       core_halted12 core_halted23.

                 intros. rename st2 into st3. rename m2 into m3.

                 rename ret2 into ret3. rename m2' into m3'.

                 destruct cd as [[d12 cc2] d23].

                 destruct H0 as [c2 [m2 [X [MC12 MC23]]]]; subst.

                 destruct (core_at_external12 _ _ _ _ _ _ _ _ MC12 H1)  as

                   [vals2 [Ext12 [LDVals12 AtExt2]]]; try assumption; clear core_at_external12.

                 destruct (core_at_external23 _ _ _ _ _ _ _ _ _  MC23 AtExt2)  as

                   [Inj23 [vals3 [InjVals23 AtExt3]]]; try assumption; clear core_at_external23.

                 assert (UnchOn3 : Mem.unchanged_on (loc_out_of_reach j m2) m3 m3').

                   split; intros; eapply H10; trivial.

                   eapply extends_loc_out_of_reach; eassumption.

                   intros.  eapply extends_loc_out_of_reach; eassumption.

                 assert (Sep23: inject_separated j j' m2 m3).

                 intros b. intros. destruct (H4 _ _ _ H0 H11). split; trivial.

                 intros N. apply H12.  inv Ext12. unfold Mem.valid_block. rewrite mext_next. apply N.

                 destruct (MEMAX.interpolate_EI _ _ _ Ext12 H7 _ _ Inj23 _ H9 _ H5 H10 H3 H4 H8)

                   as [m2' [Fwd2' [Ext12' [Inj23' [UnchOn2 UnchOn2j]]]]].

                 destruct (core_after_external12 _ _ _ _ _ _ _ _ ret1 ret1 _ _ _ MC12 H1 AtExt2

                             LDVals12 H7 Fwd2' UnchOn2 (Val.lessdef_refl _) Ext12')

                   as [c1' [c2' [d12' [AftExt1 [AftExt2 MC12']]]]];

                     try assumption; clear core_after_external12.

                 assert (PG2: meminj_preserves_globals g2 j).

                 apply (match_genv23 _ _ _ _ _ _ MC23).

                 destruct (core_after_external23 _ j j' _ _ _ _ vals2 ret1 _ _ _ ret3 _ Inj23

                             MC23 AtExt2 PG2 H3 Sep23 Inj23' H6 Fwd2' UnchOn2j H9 UnchOn3)

                 as [d23' [cc2' [c3' [AftExt22 [AftExt3 MC23']]]]];

                   try assumption; clear core_after_external23.

                 rewrite AftExt22 in AftExt2. inv AftExt2.

                 exists (d12',Some c2', d23'). exists c1'. exists c3'.

                   split; trivial. split; trivial.

                 exists c2'. exists m2'. intuition.

Qed.

End EXTINJ.



Lemma coop_sim_trans_CaseExt: forall

     (SimExt12 : Forward_simulation_extends Sem1 Sem2 g1 g2 epts12)

     (SIM23 : coop_sim Sem2 Sem3 g2 g3 epts23),

     coop_sim Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  induction SIM23; intros.

  eapply coop_sim_ext.

    apply (exteq SimExt12 R).

  eapply coop_sim_ext.

    apply (extext SimExt12 R).

  eapply coop_sim_inj.

    apply (extinj SimExt12 R).

Qed.



End CaseEXT.



Section CaseINJ.

  Import Forward_simulation_inj.



Section INJEQ.

  Import Forward_simulation_eq.



Lemma  diagram_injeq: forall

(core_data12 : Type)

(match_core12 : core_data12 -> meminj -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (j : meminj) (m2 : mem),

                 match_core12 cd j st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core12 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem2 g2 st2 m2 st2' m2' \/

                          corestep_star Sem2 g2 st2 m2 st2' m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> C3 -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m : mem) (st1' : C2) (m' : mem),

                 corestep Sem2 g2 st1 m st1' m' ->

                 forall (d : core_data23) (st2 : C3),

                 match_core23 d st1 st2 ->

                 exists st2' : C3,

                   exists d' : core_data23,

                     match_core23 d' st1' st2' /\

                     (corestep_plus Sem3 g3 st2 m st2' m' \/

                      corestep_star Sem3 g3 st2 m st2' m' /\

                      core_ord23 d' d))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(j : meminj)

(m2 : mem)

(st2 : C2)

(MC12 : match_core12 d12 j st1 m1 st2 m2)

(MC23 : match_core23 d23 st2 st3),

exists st3' : C3,

  exists m2' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      exists j' : meminj,

        inject_incr j j' /\

        inject_separated j j' m1 m2 /\

        (let (y, d2) := cd' in

         let (d1, X) := y in

         exists c2 : C2,

           X = Some c2 /\

           match_core12 d1 j' st1' m1' c2 m2' /\ match_core23 d2 c2 st3') /\

        (corestep_plus Sem3 g3 st3 m2 st3' m2' \/

         corestep_star Sem3 g3 st3 m2 st3' m2' /\

         clos_trans (core_data12 * option C2 * core_data23)

           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

           (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ _ _ MC12)

      as [st2' [m2' [d12' [j' [InjIncr [InjSep [MC12' Y]]]]]]]; clear core_diagram12.

    assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2'

      \/  (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | CS2 ord12'].

     

    destruct CS2.

    clear MC12 CS1.

     revert j j' d23 st2 st2' m2 st3 m1' MC23 MC12' H InjIncr InjSep.

    induction x; intros.

       simpl in H.

          destruct H as [c2 [m2'' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ MC23) as [st3' [d23' [? ?]]].

          exists st3'. exists m2'. exists (d12',Some st2',d23'). exists j'.

          split; trivial.

          split; trivial.

          split. exists st2'. split. trivial. split. apply MC12'. apply H0.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [st2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 _ _ _ _  H _ _ MC23) as [c3' [d'' [? ?]]].

           specialize (IHx j' _ _ _ _ _ _ _ H1 MC12' H0).

           destruct IHx as [c3'' [m3'' [[[d12''' cc2''] d23'']

             [j'' [InjIncr' [InjSep'' [[c2'' [X [MC12'' MC23'']]] ?]]]]]]].

             intros b; intros. trivial. apply inject_separated_same_meminj. subst.

           exists c3''. exists m3''. exists (d12''', Some c2'',d23''). exists j''.

           split. eapply inject_incr_trans; eassumption.

           split. eapply (inject_separated_incr_fwd _ _ _ _ _ _  InjSep InjSep'' InjIncr').

                    apply (corestep_fwd _ _ _ _ _ _ H).

           split. exists c2''. split. trivial. split. apply MC12''. apply MC23''.

           
           destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    destruct CS2. inv H.

    exists st3. exists m2'. exists (d12',Some st2',d23). exists j'.

    split. assumption.

    split. assumption.

    split. exists st2'. split. trivial. split. apply MC12'. apply MC23.

    right. split. exists O. simpl; auto.

                       apply t_step. constructor 1; auto.

Qed.



Lemma injeq: forall

      (SimInj12 : Forward_simulation_inject Sem1 Sem2 g1 g2 epts12)

      (SimEq23 : Forward_simulation_equals Sem2 Sem3 g2 g3 epts23),

      Forward_simulation_inject Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimInj12 as [core_data12 match_core12 core_ord12 core_ord_wf12

            match_vb12 genvs_dom_eq12 match_genv12

            core_diagram12 core_initial12 core_halted12

            core_at_external12 core_after_external12].

   destruct SimEq23 as [core_data23 match_core23 core_ord23 core_ord_wf23

            genvs_dom_eq23 core_diagram23 core_initial23

            core_halted23 core_at_external23 core_after_external23].

    eapply Forward_simulation_inj.Build_Forward_simulation_inject with

                 (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

                 (match_state := fun d j c1 m1 c3 m3 =>

                   match d with (d1,X,d2) => exists c2, X=Some c2 /\

                     match_core12 d1 j c1 m1 c2 m3 /\ match_core23 d2 c2 c3 end).

            

                 eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

             intros. rename c2 into c3.  rename m2 into m3.

                 destruct d as [[d12 cc2] d23].

                 destruct H as [c2 [X [MC12 MC23]]]; subst.

                 eapply (match_vb12 _ _ _ _ _ _ MC12); try eassumption.

            

              eapply genvs_domain_eq_trans; eauto.

            

                 clear core_initial23  core_halted23 core_at_external23 core_after_external23

                       core_initial12  core_halted12 core_at_external12 core_after_external12

                       match_vb12 core_diagram12 core_diagram23 EPC epts12  epts23 epts13.

                 intros. rename c2 into c3.

                 destruct d as [[d12 cc2] d23]. destruct H as [c2 [X [? ?]]]; subst.

                 apply (match_genv12 _ _ _ _ _ _ H).

            

                 clear core_initial23  core_halted23 core_at_external23

                   core_after_external23 core_initial12  core_halted12

                   core_at_external12 core_after_external12

                   EPC epts12  epts23 epts13.

                 intros. rename st2 into st3.

                 destruct cd as [[d12 cc2] d23]. destruct H0 as [st2 [X [? ?]]]; subst.

                 eapply (diagram_injeq _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

             

                  intros. rename v2 into v3. rewrite (EPC v1 v3 sig) in H.

                    destruct H as [v2 [EP12 EP23]].

                  destruct (core_initial12 _ _ _ EP12 _ _ _ _ _ _ H0 H1 H2 H3)

                    as [d12 [c2 [Ini2 MC12]]].

                  destruct (core_initial23 _ _ _ EP23 vals2)

                    as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]].

                  rewrite Ini22 in Ini2. inv Ini2.

                  exists (d12,Some c2,d23). exists c3. split; trivial.

                  exists c2. split; trivial. split; trivial.

             

                intros. rename c2 into c3.

                destruct cd as [[d12 cc2] d23]. destruct H as [c2 [X [MC12 MC23]]]; subst.

                apply (core_halted12 _ _ _ _ _ _ _ MC12) in H0; try assumption.

                destruct H0 as [v2 [VInj12 [SH2 [MInj12 VV2]]]].

                apply (core_halted23 _ _ _ _ MC23) in SH2; try assumption.

                exists v2. split; trivial. split; trivial. split; trivial.

             

                intros. rename st2 into st3.

                destruct cd as [[d12 cc2] d23]. destruct H as [c2 [X [MC12 MC23]]]; subst.

                apply (core_at_external12 _ _ _ _ _ _ _ _ _ MC12) in H0; try assumption.

                destruct H0 as [Minj12 [vals2 [VInj12 AtExt2]]].

                specialize (core_at_external23 _ _ _ _ _ _ MC23 AtExt2).

                split; trivial.

                exists vals2. intuition.

             

                intros. rename st2 into st3.

                destruct cd as [[d12 cc2] d23]. destruct H0 as [c2 [X [MC12 MC23]]]; subst.

                destruct (core_at_external12 _ _ _ _ _ _ _ _ _ MC12 H1) as

                  [MInj12 [vals2 [VInj12 AtExt2]]]; try assumption.

                specialize (core_at_external23 _ _ _ _ _ _ MC23 AtExt2).

                rename core_at_external23 into AtExt3.

                destruct (core_after_external12 _ _ _ _ _ _ _ _ _ _ _ _ _ _ MInj12 MC12 H1

                  (match_genv12 _ _ _ _ _ _ MC12) H3 H4 H5 H6 H7 H8 H9 H10)

                  as [d12' [c1' [c2' [AftExt1 [AftExt2 MS12']]]]].

                destruct (core_after_external23 _ _ _ ret2 _ _ _ MC23 AtExt2 AtExt3)

                  as [c22' [c3' [d23' [AftExt22 [AftExt3 MS23']]]]].

                rewrite AftExt22 in AftExt2. inv AftExt2.

                exists (d12',Some c2',d23'). exists c1'. exists c3'.

                split; trivial. split; trivial.

                exists c2'. intuition.

Qed.

End INJEQ.



Section INJEXT.

  Import Forward_simulation_ext.

Lemma  diagram_injext: forall

(core_data12 : Type)

(match_core12 : core_data12 -> meminj -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (j : meminj) (m2 : mem),

                 match_core12 cd j st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core12 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem2 g2 st2 m2 st2' m2' \/

                          corestep_star Sem2 g2 st2 m2 st2' m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                 corestep Sem2 g2 st1 m1 st1' m1' ->

                 forall (cd : core_data23) (st2 : C3) (m2 : mem),

                 match_core23 cd st1 m1 st2 m2 ->

                 exists st2' : C3,

                   exists m2' : mem,

                     exists cd' : core_data23,

                       match_core23 cd' st1' m1' st2' m2' /\

                       (corestep_plus Sem3 g3 st2 m2 st2'

                          m2' \/

                        corestep_star Sem3 g3 st2 m2 st2'

                          m2' /\ core_ord23 cd' cd))

(st1 : C1)

(m1 : mem)

(st1' : C1)

(m1' : mem)

(CS1 : corestep Sem1 g1 st1 m1 st1' m1')

(d12 : core_data12)

(d23 : core_data23)

(st3 : C3)

(j : meminj)

(m3 : mem)

(st2 : C2)

(m2 : mem)

(MC12: match_core12 d12 j st1 m1 st2 m2)

(MC23: match_core23 d23 st2 m2 st3 m3)

(MatchHyp12: forall d12 j12 c1 m1 c2 m2,  match_core12 d12 j12 c1 m1 c2 m2 ->

  forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

(MatchHyp23: forall d23 c2 m2 c3 m3,  match_core23 d23 c2 m2 c3 m3 ->

                    forall b, Mem.valid_block m2 b <-> Mem.valid_block m3 b),

exists st2' : C3,

  exists m2' : mem,

    exists cd' : core_data12 * option C2 * core_data23,

      exists j' : meminj,

        inject_incr j j' /\

        inject_separated j j' m1 m3 /\

        (let (y, d2) := cd' in

         let (d1, X) := y in

         exists c2 : C2,

           exists m0 : mem,

             X = Some c2 /\

             match_core12 d1 j' st1' m1' c2 m0 /\

             match_core23 d2 c2 m0 st2' m2') /\

        (corestep_plus Sem3 g3 st3 m3 st2' m2' \/

         corestep_star Sem3 g3 st3 m3 st2' m2' /\

         clos_trans (core_data12 * option C2 * core_data23)

           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

           (d12, Some st2, d23)).

Proof. intros.

    destruct (core_diagram12 _ _ _ _ CS1 _ _ _ _ MC12)

      as [st2' [m2' [d12' [j' [InjIncr [InjSep [MC12' Y]]]]]]]; clear core_diagram12.

    assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2'

      \/  (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

       destruct Y. auto.

       destruct H.

       destruct H. destruct x.

       right. split; auto.

       left. exists x; auto.

    clear Y. destruct ZZ as [CS2 | [CS2 ord12']].

     

    destruct CS2.

    clear CS1. rename j into j23.

    cut (exists st3' : C3,  exists m3' : mem, exists d23':core_data23,

                   match_core23 d23' st2' m2' st3' m3' /\

                   (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

                      (corestep_star Sem3 g3 st3 m3 st3' m3' /\

                        clos_trans (core_data12 * option C2 * core_data23)

                           (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) (d12', Some st2', d23')

                          (d12, Some st2, d23)))).

           intros XX; destruct XX as [st3' [m3' [d23' [MC23' ZZ]]]].

           exists st3'. exists m3'. exists (d12', Some st2', d23'). exists j'.

           split; trivial.

           split; trivial. intros b; intros. destruct (InjSep _ _ _ H0 H1).

                 split; try assumption.

                 intros N. apply H3. eapply MatchHyp23. eassumption. apply N.

           split. exists st2'. exists m2'. auto.

          apply ZZ.



    clear MC12 MC12' MatchHyp12.

          clear InjSep InjIncr j23 j' st1 m1 st1' m1'.

          clear C1 Sem1 match_core12 g1.



    revert d23 st2 m2 st3 m3 H MC23.

    induction x; intros.

       simpl in H.

          destruct H as [c2 [m2'' [? ?]]].

          inv H0.

          destruct (core_diagram23 _ _ _ _ H _ _ _ MC23) as [st3' [m3' [d23' [? ?]]]].

          exists st3'. exists m3'. exists d23'.

          split; trivial.

          destruct H1. left; assumption.

          destruct H1. right. split; trivial.

          apply t_step. constructor 2. apply H2.

     

           remember (S x) as x'. simpl in H.

           destruct H as [st2'' [m2'' [? ?]]]. subst x'.

           destruct (core_diagram23 _ _ _ _  H _ _ _ MC23) as [c3' [m3' [d'' [? ?]]]].

           specialize (IHx _ _ _ _ _ H0 H1).

           destruct IHx as [c3'' [m3'' [d23'' [ MC23'' ?]]]].

           exists c3''. exists m3''. exists d23''.

           split. eassumption.

           destruct H2; destruct H3.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

    inv CS2.

    exists st3. exists m3. exists (d12',Some st2',d23). exists j'.

    split. assumption.

    split. intros b; intros.

                    destruct (InjSep _ _ _ H H0).

                     split; trivial.

                     intros N. apply H2.

                     eapply MatchHyp23. apply MC23. apply N.

    split. exists st2'. exists m2'. split. trivial. split. apply MC12'. apply MC23.

    right. split. exists O. simpl; auto.

                       apply t_step. constructor 1; auto.

Qed.



Lemma injext: forall

      (SimInj12 : Forward_simulation_inject Sem1 Sem2 g1 g2 epts12)

      (SimExt23 : Forward_simulation_extends Sem2 Sem3 g2 g3 epts23),

      Forward_simulation_inject Sem1 Sem3 g1 g3 epts13.

Proof. intros.

    destruct SimInj12 as [core_data12 match_core12 core_ord12 core_ord_wf12

                          match_vb12 genv_dom_eq12 match_genv12

                          core_diagram12 core_initial12 core_halted12

                          core_at_external12 core_after_external12].

    destruct SimExt23 as [core_data23 match_core23 core_ord23 core_ord_wf23

                          genv_dom_eq23 match_vb23 core_diagram23

                          core_initial23 core_halted23

                          core_at_external23 core_after_external23].

    eapply Forward_simulation_inj.Build_Forward_simulation_inject with

                 (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

                 (match_state := fun d j c1 m1 c3 m3 =>

                   match d with (d1,X,d2) =>

                     exists c2, exists m2, X = Some c2 /\

                       match_core12 d1 j c1 m1 c2 m2 /\ match_core23 d2 c2 m2 c3 m3 end).

            

                 eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

            

                 intros. rename c2 into c3.  rename m2 into m3. destruct d as [[d12 cc2] d23].

                 destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                 destruct (match_vb12 _ _ _ _ _ _ MC12 _ _ _ H0).

                 split; try eassumption.

                 eapply (match_vb23 _ _ _ _ _ MC23); try eassumption.

            

              eapply genvs_domain_eq_trans; eauto.

            

                 clear core_initial23  core_halted23 core_at_external23 core_after_external23

                       core_initial12  core_halted12 core_at_external12 core_after_external12

                       core_diagram12 core_diagram23  EPC epts12  epts23 epts13.

                 intros. rename c2 into c3. rename m2 into m3.

                 destruct d as [[d12 cc2] d23]. destruct H as [c2 [m2 [X [? ?]]]]; subst.

                 apply (match_genv12 _ _ _ _ _ _ H).

            

                 clear core_initial23  core_halted23 core_at_external23

                   core_after_external23 core_initial12  core_halted12

                   core_at_external12 core_after_external12

                   EPC epts12  epts23 epts13.

                 intros. rename st2 into st3. rename m2 into m3.

                 destruct cd as [[d12 cc2] d23]. destruct H0 as [st2 [m2 [X [? ?]]]]; subst.

                 eapply (diagram_injext _ _ _ core_diagram12 _ _ _ core_diagram23); try eassumption.

           

                  intros. rename m2 into m3. rename v2 into v3.

                    rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

                  destruct (core_initial12 _ _ _ EP12 _ _ _ _ _ _ H0 H1 H2 H3)

                    as [d12 [c2 [Ini2 MC12]]].

                  destruct (core_initial23 _ _ _ EP23 _ _ _ _

                    (forall_lessdef_refl vals2) (extends_refl m3))

                    as [d23 [c22 [c3 [Ini22 [Ini3 MC23]]]]].

                  rewrite Ini22 in Ini2. inv Ini2.

                  exists (d12,Some c2,d23). exists c3. split; trivial.

                  exists c2. exists m3. split; trivial. split; assumption.

           

                  intros. rename c2 into c3. rename m2 into m3.

                  destruct cd as [[d12 cc2] d23]. destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                  apply (core_halted12 _ _ _ _ _ _ _ MC12) in H0; try assumption.

                  destruct H0 as [v2 [V12 [SH2 MInj12]]].

                  apply (core_halted23 _ _ _ _ _ _ MC23) in SH2; try assumption.

                  destruct SH2 as [v3 [V23 [SH3 Ext23]]].

                  exists v3. split. eapply valinject_lessdef; eassumption.

                    split; trivial.

                    eapply Mem.inject_extends_compose; eassumption.

             

                  intros. rename st2 into st3. rename m2 into m3.

                  destruct cd as [[d12 cc2] d23].

                  destruct H as [c2 [m2 [X [MC12 MC23]]]]; subst.

                  apply (core_at_external12 _ _ _ _ _ _ _ _ _ MC12) in H0; try assumption.

                  destruct H0 as [Minj12 [vals2 [VInj12 AtExt2]]].

                  apply (core_at_external23 _ _ _ _ _ _ _ _ MC23) in AtExt2; try assumption.

                  destruct AtExt2 as [vals3 [Mext23 [LD23 AtExt3]]].

                  split. eapply Mem.inject_extends_compose; eassumption.

                  exists vals3.

                    split. eapply forall_valinject_lessdef; eassumption.

                    auto.

             

                  clear core_diagram12 core_diagram23 core_initial12 core_initial23

                    core_halted12 core_halted23.

                  intros. rename st2 into st3. rename m2 into m3.

                  rename m2' into m3'. rename ret2 into ret3.

                  destruct cd as [[d12 cc2] d23].

                  destruct H0 as [c2 [m2 [X [MC12 MC23]]]]; subst.

                  destruct (core_at_external12 _ _ _ _ _ _ _ _ _ MC12 H1)

                    as [Minj12 [vals2 [ValsLD12 AtExt2]]]; try assumption; clear core_at_external12.

                  destruct (core_at_external23 _ _ _ _ _ _ _ _ MC23 AtExt2)

                    as [vals3 [MExt23 [ValsLD23 AtExt3]]]; try assumption; clear core_at_external23.

                  assert (Sep12: inject_separated j j' m1 m2).

                    intros b; intros. destruct (H4 _ _ _ H0 H11). split; trivial.

                    intros N. apply H13. inv MExt23. unfold Mem.valid_block.

                    rewrite <- mext_next. apply N.

                  assert (UnchLOOB23_3': Mem.unchanged_on (loc_out_of_bounds m2) m3 m3').

                    eapply inject_LOOR_LOOB; eassumption.

                  destruct (MEMAX.interpolate_IE _ _ _ _ Minj12 H7 _ H3 Sep12 H8 _ _ MExt23

                             H9 H10 H5 UnchLOOB23_3')

                    as [m2' [Fwd2' [MExt23' [Minj12' UnchLOORj1_2]]]].

                  destruct (core_after_external12 _ j j' _ _ _ _ _ ret1 m1' _ m2' ret3 _

                             Minj12 MC12 H1 (match_genv12 _ _ _ _ _ _ MC12) H3

                             Sep12 Minj12' H6 H7 H8 Fwd2' UnchLOORj1_2)

                    as  [d12' [c1' [c2' [AftExt1 [AftExt2 MC12']]]]]; clear core_after_external12.

                  destruct (core_after_external23 _ _ _ _ _ _ _ _ ret3 ret3 _ _ _

                             MC23 AtExt2 AtExt3 ValsLD23

                             Fwd2' H9 UnchLOOB23_3' (Val.lessdef_refl _) MExt23')

                    as [cc2' [c3' [d23' [AftExt22 [AftExt3 MC23']]]]]; clear core_after_external23.

                  rewrite AftExt22 in AftExt2. inv AftExt2.

                  exists (d12',Some c2', d23'). exists c1'. exists c3'.

                  split; trivial. split; trivial.

                  exists c2'. exists m2'. intuition.

Qed.

End INJEXT.



Lemma empty_inj: Mem.inject (Mem.flat_inj 1%positive) Mem.empty Mem.empty.

Proof.

  split.

    split. intros. destruct (flatinj_E _ _ _ _ H) as [? [? ?]]. subst.

          rewrite Zplus_0_r. assumption.

       intros. destruct (flatinj_E _ _ _ _ H) as [? [? ?]]. subst.

          apply Z.divide_0_r.

    intros. destruct (flatinj_E _ _ _ _ H) as [? [? ?]]. subst.

         exfalso. xomega.

     intros. unfold Mem.flat_inj.

          remember (plt b 1).

          destruct s; trivial. xomega.

    intros. destruct (flatinj_E _ _ _ _ H) as [? [? ?]]. subst.

         exfalso. xomega.

    intros b; intros.

      destruct (flatinj_E _ _ _ _ H0) as [? [? ?]]. subst.

         exfalso. xomega.

    intros.

      destruct (flatinj_E _ _ _ _ H) as [? [? ?]]. subst.

         exfalso. xomega.

Qed.



Lemma empty_fwd: forall m, mem_forward Mem.empty m.

Proof. intros m b Vb.

   unfold Mem.valid_block in Vb. simpl in Vb. exfalso. xomega.

Qed.



Lemma inject_split: forall j m1 m3 (Inj:Mem.inject j m1 m3),

  exists m2 j1 j2, j = compose_meminj j1 j2 /\

       Mem.inject j1 m1 m2 /\ Mem.inject j2 m2 m3.

Proof. intros.

  destruct (MEMAX.interpolate_II _ _ _ empty_inj _

              (empty_fwd m1) _ _ empty_inj _ (empty_fwd m3) _ Inj)

  as [m2 [j1 [j2 [J [Inc1 [Inc2 [Inj12 [Sep12 [Inj23 Sep23]]]]]]]]].

intros b; intros.

  destruct (compose_meminjD_Some _ _ _ _ _ H) as [? [? [? [? [? ?]]]]].

    subst. destruct (flatinj_E _ _ _ _ H0) as [? [? ?]]. subst.

         exfalso. xomega.

intros b; intros.

   unfold Mem.valid_block; simpl; split; intros N; xomega.

split; intros. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

  apply Mem.perm_valid_block in H0. unfold Mem.valid_block in H0.

    simpl in H0. exfalso; xomega.

split; intros. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

  apply Mem.perm_valid_block in H0. unfold Mem.valid_block in H0.

    simpl in H0. exfalso; xomega.

subst. exists m2, j1, j2. auto.

Qed.



Lemma forall_val_inject_split: forall j1 j2 vals1 vals3

  (V: Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3),

  exists vals2, Forall2 (val_inject j1) vals1 vals2

             /\ Forall2 (val_inject j2) vals2 vals3.

Proof. intros.

  induction V; simpl.

    exists nil; simpl. split; econstructor.

  destruct IHV as [vals [Vals1 Vals2]].

    destruct (val_inject_split _ _ _ _ H) as [z [VV1 VV2]].

    exists (z::vals).

    split; econstructor; eauto.

Qed.



Lemma initial_inject_split: forall j m1 m3 (Inj:Mem.inject j m1 m3),

  exists m2 j1 j2, j = compose_meminj j1 j2 /\

       Mem.inject j1 m1 m2 /\ Mem.inject j2 m2 m3 /\

      (forall b1 b2 ofs2, j1 b1 = Some(b2,ofs2) -> (b1=b2 /\ ofs2=0)) /\

      (forall (b2 b3 : block) (ofs3 : Z),

      j2 b2 = Some (b3, ofs3) ->

      Mem.flat_inj 1%positive b2 = Some (b3, ofs3) \/

      b2 = Mem.nextblock Mem.empty /\

      compose_meminj j1 j2 (Mem.nextblock Mem.empty) = Some (b3, ofs3) \/

      (exists m : positive,

         b2 = (Mem.nextblock Mem.empty + m)%positive /\

         compose_meminj j1 j2 (Mem.nextblock Mem.empty + m)%positive =

         Some (b3, ofs3))).

Proof. intros.

  destruct (MEMAX.interpolate_II_HeqMKI _ _ _ empty_inj _

             (empty_fwd m1) _ _ empty_inj _ (empty_fwd m3) _ Inj)

    as [m2 [j1 [j2 [J [X [Y [Inc1 [Inc2 [Inj12 [_ [Inj23 [? [? [? [XX3 XX4]]]]]]]]]]]]]]].

intros b; intros.

  destruct (compose_meminjD_Some _ _ _ _ _ H) as [? [? [? [? [? ?]]]]].

    subst. destruct (flatinj_E _ _ _ _ H0) as [? [? ?]]. subst.

         exfalso. xomega.

intros b; intros.

   unfold Mem.valid_block; simpl; split; intros N; xomega.

split; intros. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

  apply Mem.perm_valid_block in H0. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

split; intros. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

  apply Mem.perm_valid_block in H0. unfold Mem.valid_block in H0. simpl in H0. exfalso; xomega.

subst. exists m2, j1, j2.

  split; trivial.

  split; trivial.

  split. trivial.

  split; trivial.

  intros. clear - H2 XX3.

    destruct (XX3 _ _ _ H2) as [AA | [AA | AA]].

    apply flatinj_E in AA. destruct AA as [? [? ?]]; subst. intuition.

    destruct AA as [? [? ?]]; subst. intuition.

    destruct AA as [mm [[? ?] ?]]; subst. intuition.

Qed.



Section INJINJ.

Lemma diagram_injinj: forall

(core_data12 : Type)

(match_core12 : core_data12 -> meminj -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (j : meminj) (m2 : mem),

                 match_core12 cd j st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core12 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem2 g2 st2 m2 st2' m2' \/

                          corestep_star Sem2 g2 st2 m2 st2' m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> meminj -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                   corestep Sem2 g2 st1 m1 st1' m1' ->

                   forall (cd : core_data23) (st2 : C3)

                     (j : meminj) (m2 : mem),

                   match_core23 cd j st1 m1 st2 m2 ->

                   exists st2' : C3,

                     exists m2' : mem,

                       exists cd' : core_data23,

                         exists j' : meminj,

                           inject_incr j j' /\

                           inject_separated j j' m1 m2 /\

                           match_core23 cd' j' st1' m1' st2' m2' /\

                           (corestep_plus Sem3 g3 st2 m2

                              st2' m2' \/

                            corestep_star Sem3 g3 st2 m2

                              st2' m2' /\ core_ord23 cd' cd))

 (MatchHyp12: forall d12 j12 c1 m1 c2 m2,  match_core12 d12 j12 c1 m1 c2 m2 ->

                    forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

 (MatchHyp23: forall d23 j23 c2 m2 c3 m3,  match_core23 d23 j23 c2 m2 c3 m3 ->

                    forall b1 b2 ofs, j23 b1 = Some (b2,ofs) -> Mem.valid_block m2 b1 /\ Mem.valid_block m3 b2)

 (st1 : C1)

  (m1 : mem)

  (st1' : C1)

  (m1' : mem)

  (CS1 : corestep Sem1 g1 st1 m1 st1' m1')

  (d12 : core_data12)

  (d23 : core_data23)

  (st3 : C3)

  (m3 : mem)

  (st2 : C2)

  (m2 : mem)

  (j12 : meminj)

  (j23 : meminj)

  (MC12 : match_core12 d12 j12 st1 m1 st2 m2)

  (MC23 : match_core23 d23 j23 st2 m2 st3 m3),

   exists st3' : C3,

     exists m3' : mem,

       exists cd' : core_data12 * option C2 * core_data23,

         exists j' : meminj,

           inject_incr (compose_meminj j12 j23) j' /\

           inject_separated (compose_meminj j12 j23) j' m1 m3 /\

           (let (y, d2) := cd' in

            let (d1, X) := y in

            exists st2' : C2,

              exists m2' : mem,

                exists j12' : meminj,

                  exists j23' : meminj,

                    X = Some st2' /\

                    j' = compose_meminj j12' j23' /\

                    match_core12 d1 j12' st1' m1' st2' m2' /\

                    match_core23 d2 j23' st2' m2' st3' m3') /\

           (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

            corestep_star Sem3 g3 st3 m3 st3' m3' /\

            clos_trans (core_data12 * option C2 * core_data23)

              (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

              (d12, Some st2, d23)).

Proof.

  intros.

  destruct (core_diagram12 _ _ _ _ CS1 _ _ _ _ MC12)

    as [st2' [m2' [d12' [j12' [InjIncr12 [InjSep12 [MC12' Y]]]]]]]; clear core_diagram12.

  assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2' \/

    (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

  destruct Y. auto.

  destruct H.

  destruct H. destruct x.

  right. split; auto.

  left. exists x; auto.

  clear Y. destruct ZZ as [CS2 | [CS2 ord12']].

 

  destruct CS2.

  clear CS1.

  cut (exists st3' : C3,  exists m3' : mem, exists d23':core_data23, exists j23' : meminj,

    inject_incr j23 j23' /\ inject_separated j23 j23' m2 m3 /\

    match_core23 d23' j23' st2' m2' st3' m3' /\

    (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

      (corestep_star Sem3 g3 st3 m3 st3' m3' /\

        clos_trans (core_data12 * option C2 * core_data23)

        (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) (d12', Some st2', d23')

        (d12, Some st2, d23)))).

  intros XX; destruct XX as [st3' [m3' [d23' [j23' [InjIncr23 [InjSep23 [MC23' ZZ]]]]]]].

  exists st3'. exists m3'. exists (d12', Some st2', d23'). exists (compose_meminj j12' j23').

  split. eapply compose_meminj_inject_incr. apply InjIncr12. apply InjIncr23.

  split. eapply compose_meminj_inject_separated. apply InjSep12. apply InjSep23.

  assumption. assumption.

    eapply (MatchHyp12 _ _ _ _ _ _ MC12).

    eapply (MatchHyp23 _ _ _ _ _ _ MC23).

    split. exists st2'. exists m2'. exists j12'. exists j23'. auto.

    apply ZZ.

  clear MC12 InjIncr12 InjSep12 MC12' MatchHyp12.

  clear st1 m1 st1' m1' j12 j12'.

  clear C1 Sem1 match_core12 g1.

  revert j23 d23 st2 m2 st3 m3 H MC23.

  induction x; intros.

    simpl in H.

    destruct H as [c2 [m2'' [? ?]]].

    inv H0.

    destruct (core_diagram23 _ _ _ _ H _ _ _ _ MC23)

      as [st3' [m3' [d23' [j23' [InjInc23 [InjSep23 [? ?]]]]]]].

    exists st3'. exists m3'. exists d23'. exists j23'.

    split; trivial.

    split; trivial.

    split; trivial.

    destruct H1. left; assumption.

    destruct H1. right. split; trivial.

    apply t_step. constructor 2. apply H2.

   

    remember (S x) as x'. simpl in H.

    destruct H as [st2'' [m2'' [? ?]]]. subst x'.

    destruct (core_diagram23 _ _ _ _  H _ _ _ _ MC23)

      as [c3' [m3' [d23' [j23' [InjInc23 [InjSep23 [? ?]]]]]]]. clear core_diagram23.

    specialize (IHx j23' d23' _ _ c3' m3' H0 H1).

    destruct IHx as [c3'' [m3'' [d23'' [j23'' [InjIncr' [InjSep' [MC' XX]]]]]]].

    exists c3''. exists m3''. exists d23''. exists j23''.

    split. eapply inject_incr_trans. apply InjInc23. apply InjIncr'.

    split. clear MC' H1. intros b; intros.

    remember (j23' b).

    destruct o; apply eq_sym in Heqo.

    destruct p. specialize (InjIncr' _ _ _ Heqo). rewrite InjIncr' in H3. inv H3.

    destruct (InjSep23 _ _ _ H1 Heqo). split; trivial.

    destruct (InjSep' _ _ _ Heqo H3).

    split; intros N.

    apply H4. apply corestep_fwd in H. apply H. apply N.

    apply H5. destruct H2 as [H2 | [H2 _]].

    apply corestep_plus_fwd in H2. apply H2. apply N.

    apply corestep_star_fwd in H2. apply H2. apply N.

    split. apply MC'.

    destruct H2; destruct XX.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

   inv CS2.

   exists st3. exists m3. exists (d12',Some st2',d23). exists  (compose_meminj j12' j23).

   split. eapply compose_meminj_inject_incr.  assumption. apply inject_incr_refl.

   split. eapply compose_meminj_inject_separated. eassumption.

   apply inject_separated_same_meminj.

   assumption. apply inject_incr_refl.

   eapply (MatchHyp12 _ _ _ _ _ _ MC12).

   eapply (MatchHyp23 _ _ _ _ _ _ MC23).

   split. exists st2'. exists m2'. exists j12'. exists j23. auto.

   right. split. exists O. simpl; auto.

   apply t_step. constructor 1; auto.

Qed.



Lemma diagram_injinj_injsep: forall

(core_data12 : Type)

(match_core12 : core_data12 -> meminj -> C1 -> mem -> C2 -> mem -> Prop)

(core_ord12 : core_data12 -> core_data12 -> Prop)

(core_diagram12 : forall (st1 : C1) (m1 : mem) (st1' : C1) (m1' : mem),

                 corestep Sem1 g1 st1 m1 st1' m1' ->

                 forall (cd : core_data12) (st2 : C2) (j : meminj) (m2 : mem),

                 match_core12 cd j st1 m1 st2 m2 ->

                 exists st2' : C2,

                   exists m2' : mem,

                     exists cd' : core_data12,

                       exists j' : meminj,

                         inject_incr j j' /\

                         inject_separated j j' m1 m2 /\

                         match_core12 cd' j' st1' m1' st2' m2' /\

                         (corestep_plus Sem2 g2 st2 m2 st2' m2' \/

                          corestep_star Sem2 g2 st2 m2 st2' m2' /\ core_ord12 cd' cd))

(core_data23 : Type)

(match_core23 : core_data23 -> meminj -> C2 -> mem -> C3 -> mem -> Prop)

(core_ord23 : core_data23 -> core_data23 -> Prop)

(core_diagram23 : forall (st1 : C2) (m1 : mem) (st1' : C2) (m1' : mem),

                   corestep Sem2 g2 st1 m1 st1' m1' ->

                   forall (cd : core_data23) (st2 : C3)

                     (j : meminj) (m2 : mem),

                   match_core23 cd j st1 m1 st2 m2 ->

                   exists st2' : C3,

                     exists m2' : mem,

                       exists cd' : core_data23,

                         exists j' : meminj,

                           inject_incr j j' /\

                           inject_separated j j' m1 m2 /\

                           match_core23 cd' j' st1' m1' st2' m2' /\

                           (corestep_plus Sem3 g3 st2 m2

                              st2' m2' \/

                            corestep_star Sem3 g3 st2 m2

                              st2' m2' /\ core_ord23 cd' cd))

 (MatchHyp12: forall d12 j12 c1 m1 c2 m2,  match_core12 d12 j12 c1 m1 c2 m2 ->

              forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1

                /\ Mem.valid_block m2 b2)

 (MatchHyp23: forall d23 j23 c2 m2 c3 m3,  match_core23 d23 j23 c2 m2 c3 m3 ->

              forall b1 b2 ofs, j23 b1 = Some (b2,ofs) -> Mem.valid_block m2 b1

                /\ Mem.valid_block m3 b2)

 (st1 : C1)

  (m1 : mem)

  (st1' : C1)

  (m1' : mem)

  (CS1 : corestep Sem1 g1 st1 m1 st1' m1')

  (d12 : core_data12)

  (d23 : core_data23)

  (st3 : C3)

  (m3 : mem)

  (st2 : C2)

  (m2 : mem)

  (j12 : meminj)

  (j23 : meminj)

  (MC12 : match_core12 d12 j12 st1 m1 st2 m2)

  (MC23 : match_core23 d23 j23 st2 m2 st3 m3),

   exists st3' : C3,

     exists m3' : mem,

       exists cd' : core_data12 * option C2 * core_data23,

         exists j' : meminj,

           inject_incr (compose_meminj j12 j23) j' /\

           inject_separated (compose_meminj j12 j23) j' m1 m3 /\

           (let (y, d2) := cd' in

            let (d1, X) := y in

            exists st2' : C2,

              exists m2' : mem,

                exists j12' : meminj,

                  exists j23' : meminj,

                    X = Some st2' /\

                    j' = compose_meminj j12' j23' /\

                    match_core12 d1 j12' st1' m1' st2' m2' /\

                    match_core23 d2 j23' st2' m2' st3' m3' /\

                    inject_incr j12 j12' /\

                    inject_incr j23 j23' /\

                    inject_separated j12 j12' m1 m2 /\

                    inject_separated j23 j23' m2 m3) /\

           (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

            corestep_star Sem3 g3 st3 m3 st3' m3' /\

            clos_trans (core_data12 * option C2 * core_data23)

              (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) cd'

              (d12, Some st2, d23)).

Proof.

  intros.

  destruct (core_diagram12 _ _ _ _ CS1 _ _ _ _ MC12)

    as [st2' [m2' [d12' [j12' [InjIncr12 [InjSep12 [MC12' Y]]]]]]]; clear core_diagram12.

  assert (ZZ: corestep_plus Sem2 g2 st2 m2 st2' m2' \/

    (st2,m2) = (st2',m2') /\ core_ord12 d12' d12).

  destruct Y. auto.

  destruct H.

  destruct H. destruct x.

  right. split; auto.

  left. exists x; auto.

  clear Y. destruct ZZ as [CS2 | [CS2 ord12']].

 

  destruct CS2.

  clear CS1.

  cut (exists st3' : C3,  exists m3' : mem, exists d23':core_data23, exists j23' : meminj,

    inject_incr j23 j23' /\ inject_separated j23 j23' m2 m3 /\

    match_core23 d23' j23' st2' m2' st3' m3' /\

    (corestep_plus Sem3 g3 st3 m3 st3' m3' \/

      (corestep_star Sem3 g3 st3 m3 st3' m3' /\

        clos_trans (core_data12 * option C2 * core_data23)

        (sem_compose_ord_eq_eq core_ord12 core_ord23 C2) (d12', Some st2', d23')

        (d12, Some st2, d23)))).

  intros XX; destruct XX as [st3' [m3' [d23' [j23' [InjIncr23 [InjSep23 [MC23' ZZ]]]]]]].

  exists st3'. exists m3'. exists (d12', Some st2', d23'). exists (compose_meminj j12' j23').

  split. eapply compose_meminj_inject_incr. apply InjIncr12. apply InjIncr23.

  split. eapply compose_meminj_inject_separated. apply InjSep12. apply InjSep23.

  assumption. assumption.

    eapply (MatchHyp12 _ _ _ _ _ _ MC12).

    eapply (MatchHyp23 _ _ _ _ _ _ MC23).

    split. exists st2'. exists m2'. exists j12'. exists j23'. intuition.

    apply ZZ.

  clear MC12 InjIncr12 InjSep12 MC12' MatchHyp12.

  clear st1 m1 st1' m1' j12 j12'.

  clear C1 Sem1 match_core12 g1.

  revert j23 d23 st2 m2 st3 m3 H MC23.

  induction x; intros.

    simpl in H.

    destruct H as [c2 [m2'' [? ?]]].

    inv H0.

    destruct (core_diagram23 _ _ _ _ H _ _ _ _ MC23)

      as [st3' [m3' [d23' [j23' [InjInc23 [InjSep23 [? ?]]]]]]].

    exists st3'. exists m3'. exists d23'. exists j23'.

    split; trivial.

    split; trivial.

    split; trivial.

    destruct H1. left; assumption.

    destruct H1. right. split; trivial.

    apply t_step. constructor 2. apply H2.

   

    remember (S x) as x'. simpl in H.

    destruct H as [st2'' [m2'' [? ?]]]. subst x'.

    destruct (core_diagram23 _ _ _ _  H _ _ _ _ MC23)

      as [c3' [m3' [d23' [j23' [InjInc23 [InjSep23 [? ?]]]]]]]. clear core_diagram23.

    specialize (IHx j23' d23' _ _ c3' m3' H0 H1).

    destruct IHx as [c3'' [m3'' [d23'' [j23'' [InjIncr' [InjSep' [MC' XX]]]]]]].

    exists c3''. exists m3''. exists d23''. exists j23''.

    split. eapply inject_incr_trans. apply InjInc23. apply InjIncr'.

    split. clear MC' H1. intros b; intros.

    remember (j23' b).

    destruct o; apply eq_sym in Heqo.

    destruct p. specialize (InjIncr' _ _ _ Heqo). rewrite InjIncr' in H3. inv H3.

    destruct (InjSep23 _ _ _ H1 Heqo). split; trivial.

    destruct (InjSep' _ _ _ Heqo H3).

    split; intros N.

    apply H4. apply corestep_fwd in H. apply H. apply N.

    apply H5. destruct H2 as [H2 | [H2 _]].

    apply corestep_plus_fwd in H2. apply H2. apply N.

    apply corestep_star_fwd in H2. apply H2. apply N.

    split. apply MC'.

    destruct H2; destruct XX.

           

              left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                      exists (n1 + S n2)%nat.

                      change (S (n1 + S n2)) with (S n1 + S n2)%nat.

                      rewrite corestepN_add. eauto.

           

               destruct H3.

               left. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       change (S (n1 + n2)) with (S n1 + n2)%nat.

                       rewrite corestepN_add. eauto.

           

               left. destruct H2.

                       destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                       exists (n1 + n2)%nat.

                       replace (S (n1 + n2)) with (n1 + S n2)%nat by omega.

                       rewrite corestepN_add. eauto.

           

               right. destruct H2. destruct H3.

               split. destruct H2 as [n1 ?]. destruct H3 as [n2 ?].

                         exists (n1 + n2)%nat.

                         rewrite corestepN_add. eauto.

              eapply t_trans; eauto.

          

              apply t_step.

              constructor 2. apply H4.

  

   inv CS2.

   exists st3. exists m3. exists (d12',Some st2',d23). exists  (compose_meminj j12' j23).

   split. eapply compose_meminj_inject_incr.  assumption. apply inject_incr_refl.

   split. eapply compose_meminj_inject_separated. eassumption.

   apply inject_separated_same_meminj.

   assumption. apply inject_incr_refl.

   eapply (MatchHyp12 _ _ _ _ _ _ MC12).

   eapply (MatchHyp23 _ _ _ _ _ _ MC23).

   split. exists st2'. exists m2'. exists j12'. exists j23. intuition.

     apply inject_separated_same_meminj.

   right. split. exists O. simpl; auto.

   apply t_step. constructor 1; auto.

Qed.



Lemma injinj: forall

  (SimInj12 : Forward_simulation_inject Sem1 Sem2 g1 g2 epts12)

  (SimInj23 : Forward_simulation_inject Sem2 Sem3 g2 g3 epts23),

   Forward_simulation_inject Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  destruct SimInj12

    as [core_data12 match_core12 core_ord12 core_ord_wf12

        match_validblock12 genvs_dom_eq12 match_genv12

        core_diagram12 core_initial12 core_halted12

        core_at_external12 core_after_external12].

  destruct SimInj23

    as [core_data23 match_core23 core_ord23 core_ord_wf23

        match_validblock23 genvs_dom_eq23 match_genv23

        core_diagram23 core_initial23 core_halted23

        core_at_external23 core_after_external23].

  eapply Forward_simulation_inj.Build_Forward_simulation_inject with

    (core_ord := clos_trans _ (sem_compose_ord_eq_eq core_ord12 core_ord23 C2))

    (match_state := fun d j c1 m1 c3 m3 =>

      match d with (d1,X,d2) =>

        exists c2, exists m2, exists j1, exists j2,

          X=Some c2 /\ j = compose_meminj j1 j2 /\

          meminj_preserves_globals g1 j1 /\

          meminj_preserves_globals g2 j2 /\

          match_core12 d1 j1 c1 m1 c2 m2 /\ match_core23 d2 j2 c2 m2 c3 m3

      end).

 

  eapply wf_clos_trans. eapply well_founded_sem_compose_ord_eq_eq; assumption.

 

  intros. rename c2 into c3.  rename m2 into m3. destruct d as [[d12 cc2] d23].

  destruct H as [c2 [m2 [j12 [j23 [X [J [PG1 [PG2 [MC12 MC23]]]]]]]]]; subst.

  apply compose_meminjD_Some in H0.

  destruct H0 as [b11 [ofs11 [ofs12 [Hb [Hb1 Hdelta]]]]].

  split. eapply (match_validblock12 _ _ _ _ _ _ MC12); try eassumption.

  eapply (match_validblock23 _ _ _ _ _ _ MC23); try eassumption.

 

  eapply genvs_domain_eq_trans; eauto.

 

  clear core_initial23  core_halted23 core_at_external23 core_after_external23

        core_initial12  core_halted12 core_at_external12 core_after_external12

        core_diagram12 core_diagram23 match_validblock12 match_validblock23 EPC epts12 epts23 epts13.

  intros. rename c2 into c3. rename m2 into m3.

  destruct d as [[d12 cc2] d23].

  destruct H as [c2 [m2 [j12 [j23 [X [? [PG1 [PG2 [MC12 MC23]]]]]]]]]; subst.

  apply meminj_preserves_genv2blocks.

  apply meminj_preserves_genv2blocks in PG1.

  apply meminj_preserves_genv2blocks in PG2.

  eapply meminj_preserves_globals_ind_compose; try eassumption.

 

  clear core_initial23  core_halted23 core_at_external23 core_after_external23

    core_initial12  core_halted12 core_at_external12 core_after_external12

    EPC epts12 epts23 epts13.

  intros. rename st2 into st3. rename m2 into m3.

  destruct cd as [[d12 cc2] d23].

  destruct H0 as [st2 [m2 [j12 [j23 [X [? [PG1 [PG2 [MC12 MC23]]]]]]]]]; subst.

  destruct (diagram_injinj_injsep _ _ _ core_diagram12 _ _ _ core_diagram23

    match_validblock12 match_validblock23 _ _ _ _ H _ _ _ _ _ _ _ _ MC12 MC23)

    as [c3' [m3' [[[d12' cc2'] d23'] [j' [INC [SEP [X CS3]]]]]]].

  exists c3', m3', ((d12', cc2'), d23'), j'.

  split; trivial.

  split; trivial.

  split; trivial.

  clear CS3.

  destruct X as [c2' [m2' [j12' [j23' [Y [J' [MC12' [MC23' [INC12 [INC23 [SEP12 SEP23]]]]]]]]]]].

  exists c2', m2', j12', j23'.

  split; trivial.

  split; trivial.

  split. solve [eapply meminj_preserves_incr_sep_vb; try eassumption; eauto].

  split. solve [eapply meminj_preserves_incr_sep_vb; try eassumption; eauto].

  split; trivial.

 

  clear core_diagram23  core_halted23 core_at_external23 core_after_external23

    core_diagram12  core_halted12 core_at_external12 core_after_external12.

  intros. rename m2 into m3. rename v2 into v3. rename vals2 into vals3.

  rewrite (EPC v1 v3 sig) in H. destruct H as [v2 [EP12 EP23]].

  destruct (initial_inject_split _ _ _ H1) as [m2 [j1 [j2 [J [Inj12 [Inj23 [XX3 XX4]]]]]]].

  subst.

  destruct (forall_val_inject_split _ _ _ _ H2) as [vals2 [ValsInj12 ValsInj23]].

  assert (PG1: meminj_preserves_globals g1 j1).

    clear - XX3 H3.

    apply meminj_preserves_genv2blocks.

     apply meminj_preserves_genv2blocks in H3.

      destruct H3 as [AA [BB CC]].

      split; intros.

         specialize (AA _ H).

         destruct (compose_meminjD_Some _ _ _ _ _ AA)

            as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear AA.

         destruct (XX3 _ _ _ J1); subst. trivial.

      split; intros.

         specialize (BB _ H).

         destruct (compose_meminjD_Some _ _ _ _ _ BB)

            as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear BB.

         destruct (XX3 _ _ _ J1); subst. trivial.

      destruct (XX3 _ _ _ H0); subst. trivial.

  assert (PG2: meminj_preserves_globals g2 j2).

    clear - XX4 XX3 PG1 H3 genvs_dom_eq12.

    apply meminj_preserves_genv2blocks.

     apply meminj_preserves_genv2blocks in H3.

      destruct H3 as [AA [BB CC]].

     apply meminj_preserves_genv2blocks in PG1.

      destruct PG1 as [AA1 [BB1 CC1]].

      destruct genvs_dom_eq12.

      split; intros.

         apply H in H1.

         specialize (AA1 _ H1). specialize (AA _ H1).

         destruct (compose_meminjD_Some _ _ _ _ _ AA)

            as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear AA.

         rewrite J1 in AA1. inv AA1. simpl in D. subst. trivial.

      split; intros.

         apply H0 in H1.

         specialize (BB1 _ H1). specialize (BB _ H1).

         destruct (compose_meminjD_Some _ _ _ _ _ BB)

            as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear BB.

         rewrite J1 in BB1. inv BB1. simpl in D. subst. trivial.

      apply H0 in H1.

         specialize (BB1 _ H1). specialize (BB _ H1). rename b2 into b3.

         destruct (compose_meminjD_Some _ _ _ _ _ BB)

            as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear BB.

         destruct (XX3 _ _ _ J1); subst. simpl in D. subst.

         clear BB1 XX3.

         destruct (XX4 _ _ _ H2) as [XX | [XX | XX]].

           apply flatinj_E in XX. destruct XX as [? [? ?]]; subst. trivial.

           destruct XX as [? ?]; subst.

             apply (CC _ _ _ H1 H4).

           destruct XX as [mm [? ?]]; subst.

             apply (CC _ _ _ H1 H4).

  destruct (core_initial12 _ _ _ EP12 _ _ _ _ vals2 _ H0 Inj12)

     as [d12 [c2 [Ini2 MC12]]]; try assumption.

  destruct (core_initial23 _ _ _ EP23 _ _ _ _ vals3 _ Ini2 Inj23)

     as [d23 [c3 [Ini3 MC23]]]; try assumption.

  exists (d12,Some c2,d23). exists c3.

  split; trivial.

  exists c2, m2, j1, j2. intuition.

 

  intros. rename c2 into c3. rename m2 into m3.

  destruct cd as [[d12 cc2] d23].

  destruct H as [c2 [m2 [j12 [j23 [X [Y [PG1 [PG2 [MC12 MC23]]]]]]]]]; subst.

  apply (core_halted12 _ _ _ _ _ _ _ MC12) in H0; try assumption.

  destruct H0 as [v2 [ValsInj12 [SH2 Minj12]]].

  apply (core_halted23 _ _ _ _ _ _ _ MC23) in SH2; try assumption.

  destruct SH2 as [v3 [ValsInj23 [SH3 MInj23]]].

  exists v3. split. apply (val_inject_compose _ _ _ _ _ ValsInj12 ValsInj23).

  split. trivial.

  eapply Mem.inject_compose; eassumption.



  intros. rename st2 into st3. rename m2 into m3.

  destruct cd as [[d12 cc2] d23].

  destruct H as [st2 [m2 [j1 [j2 [Y [J [PG1 [PG2 [MC12 MC23]]]]]]]]]. subst.

  apply (core_at_external12 _ _ _ _ _ _ _ _ _ MC12) in H0; try assumption.

  destruct H0 as [MInj12 [vals2 [ValsInj12 AtExt2]]].

  apply (core_at_external23 _ _ _ _ _ _ _ _ _ MC23) in AtExt2; try assumption.

  destruct AtExt2 as [MInj23 [vals3 [ValsInj23 AtExt3]]].

  split. eapply Mem.inject_compose; eassumption.

  exists vals3.

  split. eapply forall_val_inject_compose; eassumption.

  auto.

  clear core_diagram12 core_initial12 core_halted12

  core_diagram23 core_initial23 core_halted23.

  intros. rename st2 into st3. rename m2 into m3.

  rename ret2 into ret3. rename m2' into m3'.

  destruct cd as [[d12 cc2] d23].

  destruct H0 as [st2 [m2 [j1 [j2 [Y [J [PG1 [PG2 [MC12 MC23]]]]]]]]]. subst.

  rename H1 into AtExt1.

  destruct (core_at_external12 _ _ _ _ _ _ _ _ _ MC12 AtExt1)

   as [MInj12 [vals2 [ValsInj12 AtExt2]]].

  destruct (core_at_external23 _ _ _ _ _ _ _ _ _ MC23 AtExt2)

   as [MInj23 [vals3 [ValsInj23 AtExt3]]].

  clear core_at_external12 core_at_external23.

  destruct (MEMAX.interpolate_II _ _ _ MInj12 _ H7 _ _ MInj23 _ H9 _ H5 H3 H4 H8 H10)

    as [m2' [j12' [j23' [X [Incr12 [Incr23 [MInj12' [Fwd2

      [MInj23' [Unch22 [Sep12 [Sep23 [Unch222' Unch2233']]]]]]]]]]]]].

  subst.

  assert (exists ret2, val_inject j12' ret1 ret2 /\ val_inject j23' ret2 ret3).

    apply val_inject_split in H6. destruct H6 as [ret2 [injRet12 injRet23]].

    exists ret2. split; trivial.

  destruct H0 as [ret2 [injRet12 injRet23]].

  assert (Unch111': Mem.unchanged_on (loc_unmapped j1) m1 m1').

    split; intros; apply H8; unfold compose_meminj, loc_unmapped in *.

    rewrite H0. trivial. trivial.

    intros. rewrite H0. trivial. trivial.

  specialize (core_after_external12 _ _ j12' _ _ _ _ _ ret1 m1' m2 m2' ret2 _

     MInj12 MC12 AtExt1 (match_genv12 _ _ _ _ _ _ MC12)

     Incr12 Sep12 MInj12' injRet12 H7 Unch111' Fwd2 Unch22).

  destruct core_after_external12 as [d12' [c1' [c2' [AftExt1 [AftExt2 MC12']]]]].



  specialize (core_after_external23 _ _ j23' _ _ _ _ vals2 ret2 m2' _ m3' ret3 _

     MInj23 MC23 AtExt2 (match_genv23 _ _ _ _ _ _ MC23)

     Incr23 Sep23 MInj23' injRet23 Fwd2 Unch222' H9 Unch2233').

  destruct core_after_external23 as [d23' [cc2' [c3' [AftExt22 [AftExt3 MC23']]]]].

  rewrite AftExt22 in AftExt2. inv AftExt2.

  exists (d12', Some c2', d23'). exists c1'. exists c3'.

  split. assumption.

  split. assumption.

  exists c2'. exists m2'. exists j12'. exists j23'. intuition.

    eapply (meminj_preserves_incr_sep _ j1); try eassumption.

    eapply (meminj_preserves_incr_sep _ j2); try eassumption.

Qed.

End INJINJ.



Lemma coop_sim_trans_CaseInj: forall

     (SimInj12 : Forward_simulation_inject Sem1 Sem2 g1 g2 epts12)

     (SIM23 : coop_sim Sem2 Sem3 g2 g3 epts23),

     coop_sim Sem1 Sem3 g1 g3 epts13.

Proof. intros.

  induction SIM23; intros.

  eapply coop_sim_inj.

    apply (injeq SimInj12 R).

  eapply coop_sim_inj.

    apply (injext SimInj12 R).

  eapply coop_sim_inj.

    apply (injinj SimInj12 R).

Qed.



End CaseINJ.



Theorem coop_sim_trans: forall

        (SIM12: coop_sim Sem1 Sem2 g1 g2 epts12)

        (SIM23: coop_sim Sem2 Sem3 g2 g3 epts23),

        coop_sim Sem1 Sem3 g1 g3 epts13.

Proof.

  intros SIM12.

  induction SIM12. intros SIM23.

    apply coop_sim_trans_CaseEq; assumption.

    apply coop_sim_trans_CaseExt; assumption.

    apply coop_sim_trans_CaseInj; assumption.

Qed.



End Coop_sim_trans. 

End Forward_simulation_trans. 

