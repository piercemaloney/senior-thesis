Require Import VST.veric.rmaps.
(* VST.veric.rmaps:
Require Import VST.msl.msl_standard.
Require Import VST.msl.ghost.
Require Import VST.msl.Coqlib2.
Require Import VST.veric.shares.

Module Type ADR_VAL.
Parameter address : Type.
Parameter some_address:address.

Parameter kind: Type.
End ADR_VAL.

Inductive TypeTree: Type :=
  | ConstType: Type -> TypeTree
  | Mpred: TypeTree
  | DependentType: nat -> TypeTree
  | ProdType: TypeTree -> TypeTree -> TypeTree
  | ArrowType: TypeTree -> TypeTree -> TypeTree
  | PiType: forall (I : Type), (I -> TypeTree) -> TypeTree
  | ListType: TypeTree -> TypeTree.

Definition dependent_type_functor_rec (ts: list Type): TypeTree -> functor :=
  fix dtfr (T: TypeTree): functor :=
  match T with
  | ConstType A => fconst A
  | Mpred => fidentity
  | DependentType n => fconst (nth n ts unit)
  | ProdType T1 T2 => fpair (dtfr T1) (dtfr T2)
  | ArrowType T1 T2 => ffunc (dtfr T1) (dtfr T2)
  | PiType _ f => fpi (fun i => dtfr (f i))
  | ListType T => flist (dtfr T)
  end.
Opaque dependent_type_functor_rec.

Definition dependent_type_function_rec (ts: list Type) (mpred': Type): TypeTree -> Type :=
  fix dtfr (T: TypeTree): Type :=
  match T with
  | ConstType A => A
  | Mpred => mpred'
  | DependentType n => nth n ts unit
  | ProdType T1 T2 => (dtfr T1 * dtfr T2)%type
  | ArrowType T1 T2 => dtfr T1 -> dtfr T2
  | PiType A f => forall a, dtfr (f a)
  | ListType T => list (dtfr T)
  end.

Definition fpreds: functor :=
  fsig (fun T: TypeTree =>
    fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

Lemma realize_eq: forall {A} (a b: A) P, (exists H: a = b, P H) -> {H: a = b & P H}.

Lemma lower_join_inv : forall {A} {J: Join A} a b c, lower_join J a b c <->
  match a, b, c with
  | Some a, Some b, Some c => join a b c
  | Some a, None, Some c | None, Some a, Some c => a = c
  | None, None, None => True
  | _, _, _ => False
  end.

Module Type STRAT_MODEL.
  Declare Module AV : ADR_VAL.
  Import AV.

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> fpreds PRED -> res PRED
    | PURE': kind -> fpreds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap fpreds f g pds)
      | PURE' k pds => PURE' B k (fmap fpreds f g pds)
    end.
  Axiom ff_res : functorFacts res res_fmap.
  Definition f_res : functor := Functor ff_res.

  Axiom paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Axiom ff_ghost : functorFacts ghost ghost_fmap.
  Definition f_ghost : functor := Functor ff_ghost.
  Axiom paf_ghost : @pafunctor f_ghost ghost_join.

  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Instance Join_pre_rmap (A: Type) : Join (f_pre_rmap A) :=
            Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A).

  Declare Instance Perm_pre_rmap: forall (A: Type), Perm_alg (f_pre_rmap A).
  Declare Instance Sep_pre_rmap: forall (A: Type), Sep_alg (f_pre_rmap A).
  Parameter paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap.

  Existing Instance ghost_join.
  Instance Join_res A : Join (f_res A) := res_join A.

Axiom pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End STRAT_MODEL.

Module StratModel (AV' : ADR_VAL) : STRAT_MODEL with Module AV:=AV'.
  Module AV := AV'.
  Import AV.

  Definition preds: functor :=
    fsig (fun T: TypeTree =>
      fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> preds PRED -> res PRED
    | PURE': kind -> preds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap preds f g pds)
      | PURE' k pds => PURE' B k (fmap preds f g pds)
    end.

  Lemma ff_res : functorFacts res res_fmap.

  Definition f_res : functor := Functor ff_res.

  Definition paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Lemma ff_ghost : functorFacts ghost ghost_fmap.

  Definition f_ghost : functor := Functor ff_ghost.

  Instance preds_join PRED : Join _ := Join_equiv (fpreds PRED).

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join PRED : Join (ghost PRED) :=
  | ghost_join_nil_l m: ghost_join PRED nil m m
  | ghost_join_nil_r m: ghost_join PRED m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join PRED m1 m2 m3 ->
      ghost_join PRED (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Hint Constructors ghost_join.
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall PRED m1 m2 m3, ghost_join PRED m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join PRED m1 m2 m3 end
  end.

  Opaque fpreds.

  Definition paf_ghost : @pafunctor f_ghost ghost_join.

  Definition pre_rmap (A:Type) := ((address -> res A) * ghost A)%type.
  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Notation Join_obj A := (Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A)).

  Instance Join_pre_rmap (A: Type) : Join (pre_rmap A) :=
    Join_obj A.

  Definition paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap :=
    paf_pair (paf_fun address paf_res) paf_ghost.

  Definition Perm_pre_rmap (A: Type): Perm_alg (pre_rmap A) :=
    Perm_prod (Perm_fun address _ _ _) (pa_gj A).

  Definition Sep_pre_rmap (A: Type): Sep_alg (pre_rmap A) :=
    Sep_prod (Sep_fun address _ _ _) (sa_gj A).

Lemma pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End StratModel.

Local Open Scope nat_scope.

Module Type RMAPS.
  Declare Module AV:ADR_VAL.
  Import AV.

  Parameter rmap : Type.
  Axiom Join_rmap: Join rmap. Existing Instance Join_rmap.
  Axiom Perm_rmap: Perm_alg rmap. Existing Instance Perm_rmap.
  Axiom Sep_rmap: Sep_alg rmap. Existing Instance Sep_rmap.
  Axiom ag_rmap: ageable rmap.  Existing Instance ag_rmap.
  Axiom Age_rmap: Age_alg rmap.  Existing Instance Age_rmap.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
      (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~(readable_share sh) -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Inductive res_join : resource -> resource -> resource -> Prop :=
   | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (NO sh2 nsh2) (NO sh3 nsh3)
   | res_join_NO2 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3), 
                 res_join (YES sh1 rsh1 k p) (NO sh2 nsh2) (YES sh3 rsh3 k p) 
   | res_join_NO3 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p) 
   | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
        res_join (YES sh1 rsh1 k p) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p)
   | res_join_PURE : forall k p, res_join (PURE k p) (PURE k p) (PURE k p). 

  Instance Join_resource: Join resource := res_join.
  Axiom Perm_resource: Perm_alg resource. Existing Instance Perm_resource.
  Axiom Sep_resource: Sep_alg resource. Existing Instance Sep_resource.

  Definition preds_fmap (f g: pred rmap -> pred rmap) (x:preds) : preds :=
    match x with SomeP A Q => SomeP A (fmap (fpi _) f g Q)
    end.
  
  Axiom preds_fmap_id : preds_fmap (id _) (id _) = id preds.
  Axiom preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.
  Axiom resource_fmap_id : resource_fmap (id _) (id _) = id resource.
  Axiom resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Axiom Perm_ghost: Perm_alg ghost. Existing Instance Perm_ghost.
  Axiom Sep_ghost: Sep_alg ghost. Existing Instance Sep_ghost.
  Axiom ghost_core: forall (g: ghost), core g = nil.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Axiom ghost_fmap_id : ghost_fmap (id _) (id _) = id ghost.
  Axiom ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap' := ((address -> resource) * ghost)%type.

  Definition rmap_fmap (f g: pred rmap -> pred rmap) (x:rmap') : rmap' :=
    (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Axiom rmap_fmap_id : rmap_fmap (id _) (id _) = id rmap'.
  Axiom rmap_fmap_comp : forall f1 f2 g1 g2,
   rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Parameter squash : (nat * rmap') -> rmap.
  Parameter unsquash : rmap -> (nat * rmap').

  Axiom rmap_level_eq: @level rmap _ = fun x => fst (unsquash x).
  Axiom rmap_age1_eq: @age1 _ _ =
     fun k => match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Axiom join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Program Definition approx (n:nat) (p: pred rmap) : pred rmap :=
    fun w => level w < n /\ p w.

  Axiom squash_unsquash : forall phi, squash (unsquash phi) = phi.
  Axiom unsquash_squash : forall n rm, unsquash (squash (n,rm)) = (n,rmap_fmap (approx n) (approx n) rm).
  Axiom ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

End RMAPS.

Module Rmaps (AV':ADR_VAL): RMAPS with Module AV:=AV'.
  Module AV:=AV'.
  Import AV.

  Module SM := StratModel(AV).
  Import SM.

  Module TyF. 
    Definition F := f_pre_rmap.
  End TyF.

  Module TyFSA <: KNOT_FULL_SA_INPUT with Module KI:=TyF.
    Module KI := TyF.
    Import KI.

    Instance Join_F: forall A, Join (F A) := _.
    Definition Perm_F : forall A, Perm_alg (F A) := Perm_pre_rmap.
    Definition Sep_F := Sep_pre_rmap.
    Definition paf_F := paf_pre_rmap.
  End TyFSA.

  Module K := Knot_MixVariantHeredProp(TyF).
  Module KL := KnotLemmas_MixVariantHeredProp(K).
  Module KSa := KnotFullSa(TyFSA)(K)(KL).

  Definition rmap := K.knot.
  Instance Join_rmap: Join rmap := KSa.Join_knot.
  Instance Perm_rmap : Perm_alg rmap:= KSa.Perm_knot.
  Instance Sep_rmap : Sep_alg rmap:= KSa.Sep_knot.
  Instance ag_rmap : ageable rmap := K.ageable_knot.
  Instance Age_rmap: Age_alg rmap := KSa.asa_knot.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
    (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~ readable_share sh -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition resource2res (r: resource): res (pred rmap) :=
    match r with
      | NO sh nsh => NO' (pred rmap) sh nsh
      | YES sh rsh k (SomeP A l) => YES' (pred rmap) sh rsh k (existT _ A l)
      | PURE k (SomeP A l) => PURE' (pred rmap) k (existT _ A l)
    end.

  Definition res2resource (r: res (pred rmap)) : resource :=
    match r with
      | NO' sh nsh => NO sh nsh
      | YES' sh rsh k (existT A l) => YES sh rsh k (SomeP A l)
      | PURE' k (existT A l) => PURE k (SomeP A l)
    end.

  Lemma res2resource2res: forall x, resource2res (res2resource x) = x.

  Lemma resource2res2resource: forall x, res2resource (resource2res x) = x.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Lemma res_option_rewrite: res_option = SM.res_option (pred rmap) oo resource2res.

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Definition pred2p (p: preds) : fpreds (pred rmap) :=
    match p with SomeP A P => existT _ A P end.

  Definition p2pred (p: fpreds (pred rmap)) : preds :=
    match p with existT A P => SomeP A P end.

  Definition ghost2g (r: ghost): SM.ghost (pred rmap) :=
    map (option_map (fun '(a, b) => (a, pred2p b))) r.

  Definition g2ghost (r: SM.ghost (pred rmap)) : ghost :=
    map (option_map (fun '(a, b) => (a, p2pred b))) r.

  Lemma g2ghost2g: forall x, ghost2g (g2ghost x) = x.

  Lemma ghost2g2ghost: forall x, g2ghost (ghost2g x) = x.

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall m1 m2 m3, ghost_join m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join m1 m2 m3 end
  end.

  Lemma ghost_core : forall (g: ghost), core g = nil.

  Definition rmap' := ((address->resource) * ghost)%type.
  Definition preds_fmap (f g:(pred rmap)->(pred rmap)) (x:preds) : preds :=
    match x with SomeP A ls => SomeP A (fmap (fpi _) f g ls) end.

  Lemma preds_fmap_id : preds_fmap (id (pred rmap)) (id (pred rmap)) = id preds.

  Lemma preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Lemma resource_fmap_id :
    resource_fmap (id (pred rmap)) (id (pred rmap)) = id resource.

  Lemma ghost_fmap_id : ghost_fmap (id (pred rmap)) (id (pred rmap)) = id ghost.

  Lemma resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Lemma ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap_fmap (f g:(pred rmap)->(pred rmap)) (x:rmap') : rmap' :=
              (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Lemma rmap_fmap_id : rmap_fmap (id (pred rmap)) (id (pred rmap)) = id rmap'.

  Lemma rmap_fmap_comp : forall f1 f2 g1 g2,
    rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap'2pre_rmap (f: rmap') : f_pre_rmap (pred rmap) :=
      (fun x : address => resource2res (fst f x), ghost2g (snd f)).

  Definition pre_rmap2rmap' (f: f_pre_rmap (pred rmap)) : rmap' :=
      (fun l : address => res2resource (fst f l), g2ghost (snd f)).

  Lemma rmap'2pre_rmap2rmap' :
    forall x, rmap'2pre_rmap (pre_rmap2rmap' x) = x.

  Lemma pre_rmap2rmap'2pre_rmap :
    forall x,  pre_rmap2rmap' (rmap'2pre_rmap x) = x.

  Definition squash (n_rm:nat * rmap') : rmap :=
    match n_rm with (n,rm) => K.squash (n, rmap'2pre_rmap rm) end.

  Definition unsquash (phi:rmap) : (nat * rmap') :=
    match K.unsquash phi with (n,rm) => (n, pre_rmap2rmap' rm) end.

  Definition rmap_level (phi:rmap) : nat := fst (unsquash phi).
  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Lemma pred_ext': forall {A} `{agA: ageable A} P Q,
                (forall x, app_pred P x <-> app_pred Q x) -> P = Q.

  Lemma squash_unsquash : forall phi, squash (unsquash phi) = phi.

  Program Definition approx (n:nat) (p: (pred rmap)) : (pred rmap) :=
    fun w => level w < n /\ p w.

  Lemma approx_K_approx: approx = K.approx.

  Lemma unsquash_squash : forall n rm, (unsquash (squash (n,rm))) = (n,rmap_fmap (approx n) (approx n) rm).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Lemma g2ghost_inv: forall g1 g2, g2ghost g1 = g2ghost g2 -> g1 = g2.

  Lemma join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Lemma ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

  Definition rmap_age1 (k:rmap) : option rmap :=
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Lemma rmap_age1_knot_age1 :
    rmap_age1 = @age1 _ K.ageable_knot.

  Lemma rmap_age1_eq: @age1 _ ag_rmap = rmap_age1.

  Lemma rmap_level_eq: @level rmap ag_rmap = fun x => fst (unsquash x).

End Rmaps.
Local Close Scope nat_scope. *)

Require Import VST.progs.ghosts.
(* VST.progs.ghosts:
Require Import VST.veric.compcert_rmaps.
Require Export VST.msl.ghost.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.veric.SeparationLogic.
Require Import VST.progs.conclib.
Import List.

Hint Resolve Share.nontrivial.

Definition gname := own.gname.

Instance Inhabitant_preds : Inhabitant preds := NoneP.

Section ghost.

Context {RA: Ghost}.

Lemma own_op' : forall g a1 a2 pp,
  own g a1 pp * own g a2 pp = EX a3 : _, !!(join a1 a2 a3 /\ valid a3) && own g a3 pp.

Lemma own_op_gen : forall g a1 a2 a3 pp, (valid_2 a1 a2 -> join a1 a2 a3) ->
  own g a1 pp * own g a2 pp = !!(valid_2 a1 a2) && own g a3 pp.

Lemma own_list_alloc : forall la lp, Forall valid la -> length lp = length la ->
  emp |-- |==> (EX lg : _, !!(Zlength lg = Zlength la) &&
    iter_sepcon (fun '(g, a, p) => own g a p) (combine (combine lg la) lp)).

Corollary own_list_alloc' : forall a pp i, 0 <= i -> valid a ->
  emp |-- |==> (EX lg : _, !!(Zlength lg = i) && iter_sepcon (fun g => own g a pp) lg).

Lemma own_list_dealloc : forall {A} f (l : list A),
  (forall b, exists g a pp, f b |-- own g a pp) ->
  iter_sepcon f l |-- |==> emp.

Lemma own_list_dealloc' : forall {A} g a p (l : list A),
  iter_sepcon (fun x => own (g x) (a x) (p x)) l |-- |==> emp.

End ghost.

Program Instance exclusive_PCM A : Ghost := { valid a := True;
  Join_G := Join_lower (Join_discrete A) }.

Definition excl {A} g a := own(RA := exclusive_PCM A) g (Some a) NoneP.

Lemma exclusive_update : forall {A} (v v' : A) p, excl p v |-- |==> excl p v'.

Class PCM_order `{P : Ghost} (ord : G -> G -> Prop) := { ord_refl :> RelationClasses.Reflexive ord;
  ord_trans :> RelationClasses.Transitive ord;
  ord_lub : forall a b c, ord a c -> ord b c -> {c' | join a b c' /\ ord c' c};
  join_ord : forall a b c, join a b c -> ord a c /\ ord b c; ord_join : forall a b, ord b a -> join a b a }.

Section Snapshot.

Context `{ORD : PCM_order}.

Lemma join_refl : forall (v : G), join v v v.

Lemma join_compat : forall v1 v2 v' v'', join v2 v' v'' -> ord v1 v2 -> exists v0, join v1 v' v0 /\ ord v0 v''.

Lemma join_ord_eq : forall a b, ord a b <-> exists c, join a c b.

Definition ghost_snap (a : @G P) p := own p (Share.bot, a) NoneP.

Lemma ghost_snap_join : forall v1 v2 p v, join v1 v2 v ->
  ghost_snap v1 p * ghost_snap v2 p = ghost_snap v p.

Lemma ghost_snap_conflict : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p |-- !!(joins v1 v2).

Lemma ghost_snap_join' : forall v1 v2 p,
  ghost_snap v1 p * ghost_snap v2 p = EX v : _, !!(join v1 v2 v) && ghost_snap v p.

Definition ghost_master sh (a : @G P) p := own p (sh, a) NoneP.

Lemma snap_master_join : forall v1 sh v2 p, sh <> Share.bot ->

Corollary snaps_master_join : forall lv sh v2 p, sh <> Share.bot ->

Lemma master_update : forall v v' p, ord v v' -> ghost_master Tsh v p |-- |==> ghost_master Tsh v' p.

Lemma master_init : forall (a : @G P), exists g', joins (Tsh, a) g'.

Lemma make_snap : forall (sh : share) v p, ghost_master sh v p |-- |==> ghost_snap v p * ghost_master sh v p.

Lemma ghost_snap_forget : forall v1 v2 p, ord v1 v2 -> ghost_snap v2 p |-- |==> ghost_snap v1 p.

Lemma ghost_snap_choose : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p |-- |==> ghost_snap v1 p.

Lemma master_share_join : forall sh1 sh2 sh v p, sepalg.join sh1 sh2 sh ->

Lemma master_inj : forall sh1 sh2 v1 v2 p, readable_share sh1 -> readable_share sh2 ->
  ghost_master sh1 v1 p * ghost_master sh2 v2 p |-- !!(v1 = v2).

Lemma master_share_join' : forall sh1 sh2 sh v1 v2 p, readable_share sh1 -> readable_share sh2 ->
  sepalg.join sh1 sh2 sh ->

Definition ghost_master1 a p := ghost_master Tsh a p.

Lemma snap_master_join1 : forall v1 v2 p,
  ghost_snap v1 p * ghost_master1 v2 p = !!(ord v1 v2) && ghost_master1 v2 p.

Lemma snap_master_update1 : forall v1 v2 p v', ord v2 v' ->
  ghost_snap v1 p * ghost_master1 v2 p |-- |==> ghost_snap v' p * ghost_master1 v' p.

End Snapshot.

Definition pos_PCM := ghost_PCM.pos_PCM.
Definition ref_PCM := ghost_PCM.ref_PCM.
Notation completable := ghost_PCM.completable.

Section Reference.

Context {P : Ghost}.

Definition ghost_reference g a := own(RA := ref_PCM P) g (None, Some a) NoneP.
Definition ghost_part g sh a := own(RA := ref_PCM P) g (Some (sh, a), None) NoneP.
Definition ghost_part_ref g sh a r :=
  own(RA := ref_PCM P) g (Some (sh, a), Some r) NoneP.

Lemma ghost_part_ref_join : forall g (sh : share) a b,
  ghost_part g sh a * ghost_reference g b = ghost_part_ref g sh a b.

Lemma ref_sub : forall g sh a b pp,
  own(RA := ref_PCM P) g (Some (sh, a), None) pp * own(RA := ref_PCM P) g (None, Some b) pp |--
    !!(if eq_dec sh Tsh then a = b else exists x, join a x b).

Lemma ref_add : forall g sh a r b a' r' pp
  (Ha : join a b a') (Hr : join r b r') (Hb : forall c, join_sub a c -> join_sub c r -> joins c b),
  own(RA := ref_PCM P) g (Some (sh, a), Some r) pp |-- |==>
  own(RA := ref_PCM P) g (Some (sh, a'), Some r') pp.

Lemma self_completable : forall a, completable (Some (Tsh, a)) a.

End Discrete.

Section GVar.

Context {A : Type}.

Definition ghost_var (sh : share) (v : A) g :=
  own(RA := @pos_PCM (discrete_PCM A)) g (Some (sh, v)) NoneP.

Lemma ghost_var_share_join : forall sh1 sh2 sh v p, sepalg.join sh1 sh2 sh ->

Lemma ghost_var_share_join_gen : forall sh1 sh2 v1 v2 p,
  ghost_var sh1 v1 p * ghost_var sh2 v2 p = EX sh : _,
  !!(v1 = v2 /\ sh1 <> Share.bot /\ sh2 <> Share.bot /\ sepalg.join sh1 sh2 sh) && ghost_var sh v1 p.

Lemma ghost_var_inj : forall sh1 sh2 v1 v2 p, sh1 <> Share.bot -> sh2 <> Share.bot ->

Lemma ghost_var_share_join' : forall sh1 sh2 sh v1 v2 p, sh1 <> Share.bot -> sh2 <> Share.bot ->

Lemma ghost_var_update : forall v p v', ghost_var Tsh v p |-- |==> ghost_var Tsh v' p.

Global Instance max_order : PCM_order le.

Lemma ghost_snap_join_N : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p = ghost_snap (Nat.max v1 v2) p.

Lemma snap_master_join' : forall v1 v2 p,
  ghost_snap v1 p * ghost_master1 v2 p = !!(v1 <= v2)%nat && ghost_master1 v2 p.

Lemma snap_master_update' : forall (v1 v2 : nat) p v', (v2 <= v')%nat ->
  ghost_snap v1 p * ghost_master1 v2 p |-- |==> ghost_snap v' p * ghost_master1 v' p.

End PVar.

Section Maps.

Context {A B : Type} {A_eq : EqDec A}.

Implicit Types (k : A) (v : B) (m : A -> option B).

Definition map_upd m k v k' := if eq_dec k' k then Some v else m k'.

Lemma map_upd_triv : forall m k v, m k = Some v -> map_upd m k v = m.

Fixpoint map_upd_list m l :=
  match l with
  | [] => m
  | (k, v) :: rest => map_upd_list (map_upd m k v) rest
  end.

Definition map_add m1 m2 k := match m1 k with Some v' => Some v' | None => m2 k end.

Definition empty_map k : option B := None.

Global Instance Inhabitant_map : Inhabitant (A -> option B) := empty_map.

Definition singleton k v k1 := if eq_dec k1 k then Some v else None.

Definition map_incl m1 m2 := forall k v, m1 k = Some v -> m2 k = Some v.

Global Instance map_incl_refl : Reflexive map_incl.

Global Instance map_incl_antisym : Antisymmetric _ _ map_incl.

Global Instance map_incl_trans : Transitive map_incl.

Lemma map_add_incl_compat : forall m1 m2 m3, map_incl m1 m2 -> map_incl (map_add m3 m1) (map_add m3 m2).

Definition compatible m1 m2 := forall k v1 v2, m1 k = Some v1 -> m2 k = Some v2 -> v1 = v2.

Global Instance compatible_refl : Reflexive compatible.

Global Instance compatible_comm : Symmetric compatible.

Lemma map_add_comm : forall m1 m2, compatible m1 m2 -> map_add m1 m2 = map_add m2 m1.

Lemma map_add_assoc : forall m1 m2 m3, map_add (map_add m1 m2) m3 = map_add m1 (map_add m2 m3).

Lemma compatible_add_assoc : forall m1 m2 m3, compatible m1 m2 ->
  compatible (map_add m1 m2) m3 -> compatible m1 (map_add m2 m3).

Lemma compatible_incl : forall m1 m2 m (Hcompat : compatible m2 m) (Hincl : map_incl m1 m2), compatible m1 m.

Lemma map_incl_add : forall m1 m2, map_incl m1 (map_add m1 m2).

Lemma map_incl_compatible : forall m1 m2 m3 (Hincl1 : map_incl m1 m3) (Hincl2 : map_incl m2 m3),
  compatible m1 m2.

Lemma map_add_incl : forall m1 m2 m3, map_incl m1 m3 -> map_incl m2 m3 -> map_incl (map_add m1 m2) m3.

Global Instance map_join : Join (A -> option B) :=
  fun a b c => forall k v, c k = Some v <-> a k = Some v \/ b k = Some v.

Lemma map_join_spec : forall m1 m2 m3, join m1 m2 m3 <-> compatible m1 m2 /\ m3 = map_add m1 m2.

Lemma map_snap_join : forall m1 m2 p,
  ghost_snap m1 p * ghost_snap m2 p = !!(compatible m1 m2) && ghost_snap (map_add m1 m2) p.

Lemma map_upd_list_app : forall l1 l2 m, map_upd_list m (l1 ++ l2) = map_upd_list (map_upd_list m l1) l2.

Lemma map_upd_list_out : forall l m k, m k = None -> ~In k (map fst l) -> map_upd_list m l k = None.

Lemma compatible_k : forall m1 m2 (Hcompat : compatible m1 m2) k v, m2 k = Some v -> map_add m1 m2 k = Some v.

Lemma map_join_incl_compat : forall m1 m2 m' m'' (Hincl : map_incl m1 m2) (Hjoin : join m2 m' m''),
  exists m, join m1 m' m /\ map_incl m m''.

Lemma map_add_empty : forall m, map_add m empty_map = m.

Lemma map_upd_incl : forall m1 m2 k v, map_incl m1 m2 ->
  m2 k = Some v -> map_incl (map_upd m1 k v) m2.

Lemma map_add_single : forall m k v, map_add (singleton k v) m = map_upd m k v.

Lemma incl_compatible : forall m1 m2, map_incl m1 m2 -> compatible m1 m2.

Lemma map_add_redundant : forall m1 m2, map_incl m1 m2 -> map_add m1 m2 = m2.

Lemma empty_map_incl : forall m, map_incl empty_map m.

Lemma map_upd2_incl : forall m1 m2 k v, map_incl m1 m2 -> map_incl (map_upd m1 k v) (map_upd m2 k v).

Lemma compatible_upd : forall m1 m2 k v, compatible m1 m2 -> m2 k = None ->
  compatible (map_upd m1 k v) m2.

Lemma map_add_upd : forall m1 m2 k v, map_upd (map_add m1 m2) k v = map_add (map_upd m1 k v) m2.

Notation maps_add l := (fold_right map_add empty_map l).

Lemma in_maps_add : forall l (k : A) (v : B), maps_add l k = Some v -> exists m, In m l /\ m k = Some v.

Definition all_compatible (l : list (A -> option B)) := forall m1 m2, In m1 l -> In m2 l -> compatible m1 m2.

Lemma all_compatible_cons : forall (m : A -> option B) l, all_compatible (m :: l) -> compatible m (maps_add l) /\ all_compatible l.

Lemma maps_add_in : forall l m (k : A) (v : B) (Hcompat : all_compatible l),
  In m l -> m k = Some v -> maps_add l k = Some v.

Lemma fold_right_maps_add : forall l (e : A -> option B), fold_right map_add e l = map_add (maps_add l) e.

Section Maps_Disjoint.

Definition disjoint m1 m2 := forall k v1, m1 k = Some v1 -> m2 k = None.

Global Instance disjoint_comm : Symmetric disjoint.

Lemma disjoint_compatible : forall m1 m2, disjoint m1 m2 -> compatible m1 m2.

Instance map_disj_join : Join (A -> option B) :=
  fun a b c => forall k, match a k, b k with Some v, None | None, Some v => c k = Some v | None, None => c k = None | _, _ => False end.

Lemma map_disj_join_spec : forall m1 m2 m3, join m1 m2 m3 <-> disjoint m1 m2 /\ m3 = map_add m1 m2.

Lemma disjoint_incl : forall m1 m2 m (Hcompat : disjoint m2 m) (Hincl : map_incl m1 m2), disjoint m1 m.

Lemma disjoint_add : forall m1 m2 m3, disjoint m1 m2 -> disjoint m1 m3 -> disjoint m1 (map_add m2 m3).

Lemma disj_join_sub : forall m1 m2, map_incl m1 m2 -> exists m3, join m1 m3 m2.

Definition all_disjoint (l : list (A -> option B)) := forall i j, 0 <= i < Zlength l -> 0 <= j < Zlength l ->
  i <> j -> disjoint (Znth i l) (Znth j l).

Lemma all_disjoint_compatible : forall l, all_disjoint l -> all_compatible l.

Lemma all_disjoint_nil : all_disjoint [].

Lemma all_disjoint_cons : forall (m : A -> option B) l, all_disjoint (m :: l) <-> disjoint m (maps_add l) /\ all_disjoint l.

Lemma all_disjoint_rev1 : forall l, all_disjoint l -> all_disjoint (rev l).

Lemma all_disjoint_rev : forall l, all_disjoint l <-> all_disjoint (rev l).

Lemma maps_add_rev : forall l, all_compatible l -> maps_add (rev l) = maps_add l.

Lemma all_disjoint_snoc : forall m l, all_disjoint (l ++ [m]) <-> disjoint m (maps_add l) /\ all_disjoint l.

Lemma empty_map_disjoint : forall m, disjoint empty_map m.

Definition map_sub (m : A -> option B) k := fun x => if eq_dec x k then None else m x.

Lemma map_upd_sub : forall m (k : A) (v : B), m k = Some v -> map_upd (map_sub m k) k v = m.

Lemma map_sub_upd : forall m (k : A) (v : B), m k = None -> map_sub (map_upd m k v) k = m.

Lemma disjoint_sub : forall (m1 m2 : A -> option B) k, disjoint m1 m2 ->
  disjoint (map_sub m1 k) m2.

End Maps_Disjoint.

End Maps.

Notation maps_add l := (fold_right map_add empty_map l).

Hint Resolve empty_map_incl empty_map_disjoint all_disjoint_nil.

Section GHist.

Context {hist_el : Type}.

Notation hist_part := (nat -> option hist_el).

Definition hist_sub sh (h : hist_part) hr := sh <> Share.bot /\ if eq_dec sh Tsh then h = hr
  else map_incl h hr.

Lemma completable_alt : forall sh h hr, @completable map_disj_PCM (Some (sh, h)) hr <-> hist_sub sh h hr.

Lemma hist_sub_upd : forall sh h hr t' e (Hsub : hist_sub sh h hr),
  hist_sub sh (map_upd h t' e) (map_upd hr t' e).

Definition ghost_hist (sh : share) (h : hist_part) g :=
  own(RA := ref_PCM map_disj_PCM) g (Some (sh, h), None) NoneP.

Lemma ghost_hist_join : forall sh1 sh2 sh h1 h2 p (Hsh : sepalg.join sh1 sh2 sh)

Definition hist_incl (h : hist_part) l := forall t e, h t = Some e -> nth_error l t = Some e.

Definition hist_list (h : hist_part) l := forall t e, h t = Some e <-> nth_error l t = Some e.

Lemma hist_list_inj : forall h l1 l2 (Hl1 : hist_list h l1) (Hl2 : hist_list h l2), l1 = l2.

Lemma hist_list_nil_inv1 : forall l, hist_list empty_map l -> l = [].

Lemma hist_list_nil_inv2 : forall h, hist_list h [] -> h = empty_map.

Definition ghost_ref l g := EX hr : hist_part, !!(hist_list hr l) &&
  own(RA := ref_PCM map_disj_PCM) g (None, Some hr) NoneP.

Lemma hist_next : forall h l (Hlist : hist_list h l), h (length l) = None.

Definition ghost_hist_ref sh (h r : hist_part) g :=
  own(RA := ref_PCM map_disj_PCM) g (Some (sh, h), Some r) NoneP.

Lemma hist_add : forall (sh : share) (h h' : hist_part) e p t' (Hfresh : h' t' = None),
  ghost_hist_ref sh h h' p |-- |==> ghost_hist_ref sh (map_upd h t' e) (map_upd h' t' e) p.

Lemma hist_incl_nil : forall h, hist_incl empty_map h.

Lemma hist_list_nil : hist_list empty_map [].

Lemma hist_list_snoc : forall h l e, hist_list h l ->
  hist_list (map_upd h (length l) e) (l ++ [e]).

Lemma hist_sub_list_incl : forall sh h h' l (Hsub : hist_sub sh h h') (Hlist : hist_list h' l),
  hist_incl h l.

Lemma hist_sub_Tsh : forall h h', hist_sub Tsh h h' <-> (h = h').

Lemma hist_ref_join : forall sh h l p, sh <> Share.bot ->

Corollary hist_ref_join_nil : forall sh p, sh <> Share.bot ->

Lemma hist_ref_incl : forall sh h h' p, sh <> Share.bot ->

Lemma hist_add' : forall sh h h' e p, sh <> Share.bot ->

Definition newer (l : hist_part) t := forall t', l t' <> None -> (t' < t)%nat.

Lemma newer_trans : forall l t1 t2, newer l t1 -> (t1 <= t2)%nat -> newer l t2.

Corollary newer_upd : forall l t1 e t2, newer l t1 -> (t1 < t2)%nat ->
  newer (map_upd l t1 e) t2.

Lemma newer_over : forall h t t', newer h t -> (t <= t')%nat -> h t' = None.

Corollary newer_out : forall h t, newer h t -> h t = None.

Lemma add_new_inj : forall h h' t t' v v' (Ht : newer h t) (Ht' : newer h' t'),
  map_upd h t v = map_upd h' t' v' -> h = h' /\ t = t' /\ v = v'.

Lemma hist_incl_lt : forall h l, hist_incl h l -> newer h (length l).

Corollary hist_list_lt : forall h l, hist_list h l -> newer h (length l).

Inductive hist_list' : hist_part -> list hist_el -> Prop :=
| hist_list'_nil : hist_list' empty_map []
| hist_list'_snoc : forall h l t e (Hlast : newer h t) (Hrest : hist_list' h l),
    hist_list' (map_upd h t e) (l ++ [e]).
Hint Resolve hist_list'_nil.

Lemma hist_list'_in : forall h l (Hl : hist_list' h l) e, (exists t, h t = Some e) <-> In e l.

Lemma hist_list_weak : forall l h (Hl : hist_list h l), hist_list' h l.

Lemma hist_list'_add : forall h1 h2 (l : list hist_el) (Hdisj : disjoint h1 h2), hist_list' (map_add h1 h2) l ->
  exists l1 l2, Permutation l (l1 ++ l2) /\ hist_list' h1 l1 /\ hist_list' h2 l2.

Lemma ghost_hist_init : @valid (ref_PCM (@map_disj_PCM nat hist_el)) (Some (Tsh, empty_map), Some empty_map).

Inductive add_events h : list hist_el -> hist_part -> Prop :=
| add_events_nil : add_events h [] h
| add_events_snoc : forall le h' t e (Hh' : add_events h le h') (Ht : newer h' t),
    add_events h (le ++ [e]) (map_upd h' t e).
Hint Resolve add_events_nil.

Lemma add_events_1 : forall h t e (Ht : newer h t), add_events h [e] (map_upd h t e).

Lemma add_events_trans : forall h le h' le' h'' (H1 : add_events h le h') (H2 : add_events h' le' h''),
  add_events h (le ++ le') h''.

Lemma add_events_add : forall h le h', add_events h le h' ->
  exists h2, h' = map_add h h2 /\ forall t e, h2 t = Some e -> newer h t /\ In e le.

Corollary add_events_dom : forall h le h' t e, add_events h le h' -> h' t = Some e ->
  h t = Some e \/ In e le.

Corollary add_events_incl : forall h le h', add_events h le h' -> map_incl h h'.

Corollary add_events_newer : forall h le h' t, add_events h le h' -> newer h' t -> newer h t.

Lemma add_events_in : forall h le h' e, add_events h le h' -> In e le ->
  exists t, newer h t /\ h' t = Some e.

End GHist.

Hint Resolve hist_incl_nil hist_list_nil hist_list'_nil add_events_nil.

Hint Resolve  master_init  ghost_hist_init : init.

Ltac ghost_alloc G :=
  match goal with |-semax _ (PROPx ?P (LOCALx ?Q (SEPx ?R))) _ _ =>
    apply (semax_pre_bupd (PROPx P (LOCALx Q (SEPx ((EX g : _, G g) :: R)))));
  [go_lower; rewrite !prop_true_andp by (repeat (split; auto));
   rewrite <- emp_sepcon at 1; eapply derives_trans, bupd_frame_r;
   apply sepcon_derives, derives_refl; apply own_alloc; auto; simpl; auto with init|] end.

Ltac ghosts_alloc G n :=
  match goal with |-semax _ (PROPx ?P (LOCALx ?Q (SEPx ?R))) _ _ =>
    apply (semax_pre_bupd (PROPx P (LOCALx Q (SEPx ((EX lg : _, !!(Zlength lg = n) && iter_sepcon G lg) :: R)))));
  [go_lower; rewrite !prop_true_andp by (repeat (split; auto));
   rewrite <- emp_sepcon at 1; eapply derives_trans, bupd_frame_r;
   apply sepcon_derives, derives_refl; apply own_list_alloc'; auto; simpl; auto with init|] end.

Program Definition weak_view_shift (P Q: mpred): mpred :=
  fun w => predicates_hered.derives (approx (S (level w)) P) (own.bupd (approx (S (level w)) Q)).

Lemma view_shift_nonexpansive: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift (approx n P) (approx n Q)).

Lemma view_shift_nonexpansive_l: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift (approx n P) Q).

Lemma view_shift_nonexpansive_R: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift P (approx n Q)).

Lemma view_shift_weak: forall P Q, P |-- |==> Q -> TT |-- weak_view_shift P Q.

Lemma apply_view_shift: forall P Q, (weak_view_shift P Q && emp) * P |-- |==> Q. *)

Require Import atomics.general_atomics.
(* atomics.general_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Import VST.progs.invariants.
Require Import VST.progs.fupd.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Export Ensembles.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs} {inv_names : invG}.

Section atomicity.

Lemma approx_mono: forall n P Q, (P >=> Q) (Nat.pred n) -> approx n P |-- approx n Q.

Lemma subp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P' >=> P -> G |-- Q >=> Q' ->
    G |-- ((P -* Q) >=> (P' -* Q'))%pred.

Lemma eqp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P <=> P' -> G |-- Q <=> Q' ->
    G |-- ((P -* Q) <=> (P' -* Q')).

Lemma subp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P >=> P' ->
    G |-- ((|={E1,E2}=> P) >=> |={E1,E2}=> P').

Lemma eqp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P <=> P' ->
    G |-- ((|={E1,E2}=> P) <=> |={E1,E2}=> P').

Lemma eqp_imp: forall (G : Triv) (P P' Q Q' : mpred),
       G |-- P <=> P' -> G |-- Q <=> Q' -> G |-- (P --> Q) <=> P' --> Q'.

Lemma fview_shift_nonexpansive: forall E1 E2 P Q n,
  approx n (P -* |={E1,E2}=> Q) = approx n (approx n P -* |={E1,E2}=> (approx n Q)).

Lemma emp_dup: forall P, P && emp = (P && emp) * (P && emp).

Definition atomic_shift {A B} (a : A -> mpred) Ei Eo (b : A -> B -> mpred) (Q : B -> mpred) :=
  EX P : mpred, |> P * ((|> P -* |={Eo,Ei}=> (EX x : A, a x *
    ((a x -* |={Ei,Eo}=> |> P) &&
     ALL y : B, b x y -* |={Ei,Eo}=> Q y))) && cored).

End atomicity.

End atomics.

Definition atomic_spec_type W T := ProdType (ProdType W (ArrowType (ConstType T) Mpred)) (ConstType invG).

Definition super_non_expansive_a {A W} (a : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> predicates_hered.pred rmap) :=
  forall n ts w x, approx n (a ts w x) =
  approx n (a ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x).

Definition super_non_expansive_b {A B W} (b : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> B -> predicates_hered.pred rmap) :=
  forall n ts w x y, approx n (b ts w x y) =
  approx n (b ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x y).

Definition super_non_expansive_la {W} la := forall n ts w rho,
  Forall (fun l => approx n (!! locald_denote (l ts w) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w)) rho)) la.

Definition super_non_expansive_lb {B W} lb := forall n ts w (v : B) rho,
  Forall (fun l => approx n (!! locald_denote (l ts w v) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) v) rho)) lb.

Program Definition atomic_spec {A T} W args tz la P a (t : T) lb b Ei Eo
  (Hla : super_non_expansive_la la) (HP : super_non_expansive' P) (Ha : super_non_expansive_a(A := A) a)
  (Hlb : super_non_expansive_lb lb) (Hb : super_non_expansive_b b) :=
  mk_funspec (pair args tz) cc_default (atomic_spec_type W T)
  (fun (ts: list Type) '(w, Q, inv_names) =>
    PROP ()
    (LOCALx (map (fun l => l ts w) la)
    (SEP (atomic_shift(inv_names := inv_names) (a ts w) Ei Eo (b ts w) Q; P ts w))))
  (fun (ts: list Type) '(w, Q, inv_names) => EX v : T,
    PROP () (LOCALx (map (fun l => l ts w v) lb)
    (SEP (Q v)))) _ _.

Ltac start_atomic_function :=
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH u : unit
               PRE  [] main_pre _ nil u
               POST [ tint ] main_post _ nil u) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end; unfold atomic_spec;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match x with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList (x, Q)
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax; simpl. *)

Require Import atomics.acq_rel_atomics.
(* atomics.acq_rel_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.general_atomics.

Set Bullet Behavior "Strict Subproofs".

Parameter objective : mpred -> Prop.
Axiom emp_objective : objective emp.
Axiom data_at_objective : forall {cs : compspecs} sh t v p, objective (data_at sh t v p).
Axiom own_objective : forall {RA : Ghost} g (a : G) pp, objective (own g a pp).
Axiom prop_objective : forall P, objective (!!P).
Axiom andp_objective : forall P Q, objective P -> objective Q -> objective (P && Q).
Axiom exp_objective : forall {A} P, (forall x, objective (P x)) -> objective (EX x : A, P x).
Axiom sepcon_objective : forall P Q, objective P -> objective Q -> objective (P * Q).
Lemma sepcon_list_objective : forall P, Forall objective P -> objective (fold_right sepcon emp P).

Axiom inv_alloc : forall N E P, objective P -> |> P |-- |={E}=> invariant N P.

Corollary make_inv : forall N E P Q, P |-- Q -> objective Q -> P |-- |={E}=> invariant N Q.

Ltac prove_objective := repeat
  match goal with
  | |-objective(if _ then _ else _) => if_tac
  | |-objective(exp _) => apply exp_objective; intro
  | |-objective(ghost_ref _ _) => apply exp_objective; intro
  | |-objective(_ * _) => apply sepcon_objective
  | |-objective(_ && _) => apply andp_objective
  | |-objective(!!_) => apply prop_objective
  | |-objective(own _ _ _) => apply own_objective
  | |-objective(data_at _ _ _ _) => apply data_at_objective
  | |-objective(data_at_ _ _ _) => rewrite data_at__eq; apply data_at_objective
  | |-objective(fold_right sepcon emp _) => apply sepcon_list_objective;
        rewrite ?Forall_map, Forall_forall; intros; simpl
  | _ => try apply own_objective
  end.

Hint Resolve emp_objective data_at_objective own_objective prop_objective andp_objective exp_objective
  sepcon_objective sepcon_list_objective : objective.

Section dup.

Definition duplicable P := P |-- |==> P * P.

Lemma emp_duplicable : duplicable emp.
Hint Resolve emp_duplicable : dup.

Lemma sepcon_duplicable : forall P Q, duplicable P -> duplicable Q -> duplicable (P * Q).
Hint Resolve sepcon_duplicable : dup.

Lemma sepcon_list_duplicable : forall lP, Forall duplicable lP -> duplicable (fold_right sepcon emp lP).

Lemma list_duplicate : forall Q lP, duplicable Q ->
  fold_right sepcon emp lP * Q |-- |==> fold_right sepcon emp (map (sepcon Q) lP) * Q.

Lemma invariant_duplicable' : forall N P, duplicable (invariant N P).
Hint Resolve invariant_duplicable' : dup.

Lemma ghost_snap_duplicable : forall `{_ : PCM_order} (s : G) p, duplicable (ghost_snap s p).
Hint Resolve ghost_snap_duplicable : dup.

Lemma prop_duplicable : forall P Q, duplicable Q -> duplicable (!!P && Q).
Hint Resolve prop_duplicable : dup.

Lemma exp_duplicable : forall {A} (P : A -> mpred), (forall x, duplicable (P x)) -> duplicable (exp P).

Definition weak_dup P := weak_view_shift P (P * P).

Lemma duplicable_super_non_expansive : forall n P,
  approx n (weak_dup P) = approx n (weak_dup (approx n P)).

Lemma dup_weak_dup : forall P, duplicable P -> TT |-- weak_dup P.

End dup.

Hint Resolve emp_duplicable sepcon_duplicable invariant_duplicable' ghost_snap_duplicable prop_duplicable : dup.Section atomics.

Context {CS : compspecs}.

Section protocols.

Class protocol {state : Type} (Iread Ifull : state -> Z -> mpred) :=
  { full_read s v : Ifull s v |-- |==> Ifull s v * Iread s v; read_dup s v : duplicable (Iread s v) }.

Global Instance dup_protocol {state} (T : state -> Z -> mpred) (Ht : forall s v, duplicable (T s v)) :
  protocol T T.

Context {state : Type}.

Parameter protocol_A : val -> state -> (state -> state -> Prop) ->
  ((state -> Z -> mpred) * (state -> Z -> mpred)) -> mpred.

Context (ord : state -> state -> Prop) `{RelationClasses.PreOrder _ ord}
  (Tread Tfull : state -> Z -> mpred).

Axiom ex_protocol_A_precise : forall l ord Tread Tfull, precise (EX s : _, protocol_A l s ord (Tread, Tfull))%logic.

Corollary protocol_A_precise : forall l s ord Tread Tfull, precise (protocol_A l s ord (Tread, Tfull)).

Axiom protocol_A_nonexpansive : forall l s ord Tread1 Tfull1 Tread2 Tfull2,
  (ALL s : state, ALL v : Z, (Tread1 s v <=> Tread2 s v) && (Tfull1 s v <=> Tfull2 s v)) |--
  protocol_A l s ord (Tread1, Tfull1) <=> protocol_A l s ord (Tread2, Tfull2).

Lemma protocol_A_super_non_expansive : forall n l s ord Tread Tfull,
  approx n (protocol_A l s ord (Tread, Tfull)) =
  approx n (protocol_A l s ord (fun s v => approx n (Tread s v), fun s v => approx n (Tfull s v))).

Notation T := (Tread, Tfull).

Axiom protocol_A_duplicable : forall l s, duplicable (protocol_A l s ord T).

Axiom protocol_A_join' : forall l s1 s2,
  protocol_A l s1 ord T * protocol_A l s2 ord T |--
  EX s : _, !!(ord s1 s /\ ord s2 s) && protocol_A l s ord T.

Axiom make_protocol : forall {P : protocol Tread Tfull} l v s, repable_signed v ->
  data_at Tsh tint (vint v) l * |> Tfull s v |-- |==> protocol_A l s ord T.

Axiom protocol_A_later : forall l s,
  protocol_A l s ord (|>Tread, |>Tfull) |-- |>protocol_A l s ord T.

Axiom protocol_A_delay : forall l s,
  protocol_A l s ord T |-- protocol_A l s ord (|>Tread, |>Tfull).

End protocols.

Lemma approx_later : forall n P, approx (S n) (|> P) = |> approx n P.

Lemma approx_0 : forall P, approx 0 P = FF.

Definition OrdType s := ArrowType s (ArrowType s (ConstType Prop)).
Definition PredType s := ArrowType s (ArrowType (ConstType Z) Mpred).

Definition LA_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType
  (ConstType val) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0))))
  Mpred) (ConstType (namespace -> Prop))) (PredType (DependentType 0)).

Program Definition load_acq_spec := TYPE LA_type
  WITH l : val, s : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : Ensemble namespace, Q : _ -> Z -> mpred
  PRE [ 1%positive OF tptr tint ]
   PROP ()
   LOCAL (temp 1%positive l)
   SEP (ALL s' : _, !!(st_ord s s') --> ALL v : _,
          weak_fview_shift E E (fst T s' v * P * protocol_A l s' st_ord T) (Q s' v) && emp;
        P; protocol_A l s st_ord T)
  POST [ tint ]
   EX v : Z, EX s' : _,
   PROP (repable_signed v; st_ord s s')
   LOCAL (temp ret_temp (vint v))
   SEP (Q s' v).

Definition SR_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ProdType
  (ConstType (val * Z)) (DependentType 0)) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0))))
  Mpred) (ConstType (namespace -> Prop))) Mpred.

Definition CRA_type := ProdType (ProdType (ProdType (ProdType (ProdType
  (ProdType (ProdType (ConstType (val * Z * Z)) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0)))) Mpred)
  (ConstType (namespace -> Prop))) (ArrowType (DependentType 0) Mpred))
  (PredType (DependentType 0)).

Program Definition CAS_RA_spec := TYPE CRA_type
  WITH l : val, c : Z, v : Z, s : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : _, Q : _ -> mpred, R : _ -> Z -> mpred
  PRE [ 1%positive OF tptr tint, 2%positive OF tint, 3%positive OF tint ]
   PROP (repable_signed c; repable_signed v)
   LOCAL (temp 1%positive l; temp 2%positive (vint c); temp 3%positive (vint v))
   SEP (ALL s' : _, !!(st_ord s s') --> weak_fview_shift E E (snd T s' c * P)
          (EX s'' : _, !!(st_ord s' s'') && |> snd T s'' v *
           weak_fview_shift E E (protocol_A l s'' st_ord T) (Q s'')) && emp;
        ALL s' : _, ALL v' : _, !!(st_ord s s' /\ repable_signed v' /\ v <> c) -->
          weak_fview_shift E E (|> fst T s' v' * protocol_A l s' st_ord T * P) (R s' v') && emp;
        protocol_A l s st_ord T; P)
  POST [ tint ]
   EX v' : Z, EX s' : _,
   PROP (repable_signed v'; st_ord s s')
   LOCAL (temp ret_temp (Val.of_bool (if eq_dec v' c then true else false)))

End atomics. *)

Require Import VST.progs.conclib.
(* VST.progs.conclib:
Require Import VST.veric.ghost_PCM.
Require Export VST.msl.iter_sepcon.
Require Export VST.concurrency.semax_conc_pred.
Require Export VST.concurrency.semax_conc.
Require Export VST.floyd.proofauto.
Require Import VST.floyd.library.
Require Export VST.floyd.sublist.

Notation vint z := (Vint (Int.repr z)).
Notation vptrofs z := (Vptrofs (Ptrofs.repr z)).

Lemma app_cons_assoc : forall {A} l1 (x : A) l2, l1 ++ x :: l2 = (l1 ++ [x]) ++ l2.

Lemma Forall_forall_Znth : forall {A}{d: Inhabitant A} (P : A -> Prop) l,
  Forall P l <-> forall i, 0 <= i < Zlength l -> P (Znth i l).

Lemma Zmod_smallish : forall x y, y <> 0 -> 0 <= x < 2 * y ->
  x mod y = x \/ x mod y = x - y.

Lemma Zmod_plus_inv : forall a b c d (Hc : c > 0) (Heq : (a + b) mod c = (d + b) mod c),
  a mod c = d mod c.

Lemma Znth_app : forall {A}{d: Inhabitant A} (l1 l2 : list A) i,
      Zlength l1 = i -> Znth i (l1 ++ l2) = Znth 0 l2.

Corollary Znth_app1 : forall {A}{d: Inhabitant A} l1 (x : A) l2 i,
     Zlength l1 = i -> Znth i (l1 ++ x :: l2) = x.

Lemma repable_0 : repable_signed 0.
Hint Resolve repable_0.

Definition complete MAX l := l ++ repeat (vptrofs 0) (Z.to_nat MAX - length l).

Lemma upd_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX l) x = complete MAX (l ++ [x]).

Lemma Znth_complete : forall n l MAX, n < Zlength l -> 
     Znth n (complete MAX l) = Znth n l.

Lemma remove_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX (l ++ [x])) (vptrofs 0) = complete MAX l.

Lemma Forall_app : forall {A} (P : A -> Prop) l1 l2,
  Forall P (l1 ++ l2) <-> Forall P l1 /\ Forall P l2.

Lemma Forall_incl : forall {A} (P : A -> Prop) l1 l2 (Hall : Forall P l2) (Hincl : incl l1 l2),
  Forall P l1.

Lemma repeat_plus : forall {A} (x : A) i j, repeat x (i + j) = repeat x i ++ repeat x j.

Lemma in_insert_iff : forall {A} (x y : A) l1 l2, In x (l1 ++ y :: l2) <-> x = y \/ In x (l1 ++ l2).

Definition remove_at {A} i (l : list A) := firstn i l ++ skipn (S i) l.

Lemma Forall_firstn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (firstn i l).

Lemma Forall_skipn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (skipn i l).

Lemma Forall_upd_Znth : forall {A} (P : A -> Prop) x l i, Forall P l -> P x ->
  Forall P (upd_Znth i l x).

Lemma last_cons : forall {A} (d : A) l x, l <> [] -> last (x :: l) d = last l d.

Lemma nth_last : forall {A} (d : A) l, nth (length l - 1) l d = last l d.

Lemma Znth_last : forall {A}{d: Inhabitant A} l, Znth (Zlength l - 1) l = last l default.

Lemma last_app : forall {A} l1 l2 (d : A), l2 <> [] -> last (l1 ++ l2) d = last l2 d.

Lemma nat_sorted_list_eq : forall d n l (Hl : forall i, (i < n)%nat <-> In i l) (Hlen : length l = n)
  (Hsorted : forall i j, (i < j < n -> nth i l d < nth j l d)%nat) i (Hi : (i < n)%nat), nth i l d = i.

Lemma Forall2_In_l : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l1 ->
  exists y, In y l2 /\ P x y.

Lemma Forall2_In_r : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l2 ->
  exists y, In y l1 /\ P y x.

Lemma last_snoc : forall {A} (d : A) x l, last (l ++ [x]) d = x.

Lemma iter_sepcon_sepcon: forall {A} f g1 g2 l, (forall b : A, f b = g1 b * g2 b) ->
  iter_sepcon f l = iter_sepcon g1 l * iter_sepcon g2 l.

Lemma sepcon_app : forall l1 l2, fold_right sepcon emp (l1 ++ l2) =
  fold_right sepcon emp l1 * fold_right sepcon emp l2.

Definition rotate {A} (l : list A) n m := sublist (m - n) (Zlength l) l ++
  sublist 0 (m - n) l.

Lemma sublist_of_nil : forall {A} i j, sublist i j (@nil A) = [].

Lemma sublist_0_cons : forall {A} j x (l : list A), j > 0 ->
  sublist 0 j (x :: l) = x :: sublist 0 (j - 1) l.

Lemma sublist_S_cons : forall {A} i j x (l : list A), i > 0 ->
  sublist i j (x :: l) = sublist (i - 1) (j - 1) l.

Lemma upd_rotate : forall {A} i (l : list A) n m x (Hl : Zlength l = m) (Hlt : 0 <= n <= m)
  (Hi : 0 <= i < Zlength l),
  upd_Znth i (rotate l n m) x = rotate (upd_Znth ((i - n) mod m) l x) n m.

Lemma Znth_cons_eq : forall {A}{d : Inhabitant A} i x l, 
   Znth i (x :: l) = if eq_dec i 0 then x else Znth (i - 1) l.

Lemma Znth_rotate : forall {A} {d : Inhabitant A} i l n, 
    0 <= n <= Zlength l -> 0 <= i < Zlength l ->
  Znth i (rotate l n (Zlength l)) = Znth ((i - n) mod Zlength l) l.

Lemma rotate_nil : forall {A} n m, rotate (@nil A) n m = [].

Lemma Forall_sublist_le : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i) (Hrangej : j <= Zlength l) (Hi : ~P (Znth i l)) (Hj : Forall P (sublist 0 j l)),
  j <= i.

Corollary Forall_sublist_first : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i <= Zlength l) (Hi : Forall P (sublist 0 i l)) (Hi' : ~P (Znth i l))
  (Hrangej : 0 <= j <= Zlength l) (Hj : Forall P (sublist 0 j l)) (Hj' : ~P (Znth j l)),
  i = j.

Lemma NoDup_Znth_inj : forall {A} {d : Inhabitant A} l i j (HNoDup : NoDup l)
  (Hi : 0 <= i < Zlength l) (Hj : 0 <= j < Zlength l) (Heq : Znth i l = Znth j l ),
  i = j.

Lemma rotate_In : forall {A} (x : A) n m l, 0 <= m - n <= Zlength l -> In x (rotate l n m) <-> In x l.

Lemma rotate_map : forall {A B} (f : A -> B) n m l, rotate (map f l) n m = map f (rotate l n m).

Lemma combine_app : forall {A B} (l1 l2 : list A) (l1' l2' : list B), length l1 = length l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma combine_app' : forall {A B} (l1 l2 : list A) (l1' l2' : list B), Zlength l1 = Zlength l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma Forall_rotate : forall {A} P (l : list A) n m, Forall P l ->
  Forall P (rotate l m n).

Lemma Forall_repeat : forall {A} (P : A -> Prop) x n, P x -> Forall P (repeat x n).

Lemma Forall_complete : forall P l m, Forall P l -> P (vptrofs 0) ->
  Forall P (complete m l).

Lemma app_eq_inv : forall {A} (l1 l2 l3 l4 : list A)
  (Heq : l1 ++ l2 = l3 ++ l4) (Hlen : length l1 = length l3), l1 = l3 /\ l2 = l4.

Lemma rotate_inj : forall {A} (l1 l2 : list A) n m, rotate l1 n m = rotate l2 n m ->
  length l1 = length l2 -> 0 <= n <= m -> m <= Zlength l1 -> l1 = l2.

Lemma complete_inj : forall l1 l2 m, complete m l1 = complete m l2 ->
  length l1 = length l2 -> l1 = l2.

Lemma length_complete : forall l m, Zlength l <= m -> length (complete m l) = Z.to_nat m.

Lemma Zlength_rotate : forall {A} (l : list A) n m, 0 <= n <= m -> m <= Zlength l ->
  Zlength (rotate l n m) = Zlength l.

Lemma Zlength_repeat : forall {A} (x : A) n, Zlength (repeat x n) = Z.of_nat n.

Lemma Zlength_complete : forall l m, Zlength l <= m -> Zlength (complete m l) = m.

Lemma combine_eq : forall {A B} (l : list (A * B)), combine (map fst l) (map snd l) = l.

Lemma signed_inj : forall i1 i2, Int.signed i1 = Int.signed i2 -> i1 = i2.

Lemma mods_repr : forall a b, 0 <= a <= Int.max_signed -> 0 < b <= Int.max_signed ->

Lemma repeat_list_repeat : forall {A} n (x : A), repeat x n = list_repeat n x.

Lemma sublist_repeat : forall {A} i j k (v : A), 0 <= i -> i <= j <= k ->
  sublist i j (repeat v (Z.to_nat k)) = repeat v (Z.to_nat (j - i)).

Lemma Znth_head : forall reqs head m, Zlength reqs <= m -> 0 <= head < m ->
  Zlength reqs > 0 ->
  Znth head (rotate (complete m reqs) head m) = Znth 0 reqs.

Lemma Znth_repeat : forall {A} {x : Inhabitant A} n i, Znth i (repeat default n) = default.

Lemma Znth_repeat' : forall {A} {d: Inhabitant A} (x : A) n i, 
    0 <= i < Z.of_nat n -> Znth i (repeat x n)  = x.

Lemma rotate_1 : forall v l n m, 0 <= n < m -> Zlength l < m ->
  rotate (upd_Znth 0 (complete m (v :: l)) (vptrofs 0)) n m =
  rotate (complete m l) ((n + 1) mod m) m.

Lemma upd_complete_gen : forall {A} (l : list A) x n y, Zlength l < n ->
  upd_Znth (Zlength l) (l ++ repeat y (Z.to_nat (n - Zlength l))) x =

Lemma upd_complete' : forall l x n, (length l < n)%nat ->
  upd_Znth (Zlength l) (map Vint (map Int.repr l) ++ repeat Vundef (n - length l)) (Vint (Int.repr x)) =

Fixpoint upto n :=
  match n with
  | O => []
  | S n' => 0 :: map Z.succ (upto n')
  end.

Opaque Z.of_nat.

Lemma upto_app : forall n m, upto (n + m) = upto n ++ map (fun i => Z.of_nat n + i) (upto m).

Lemma upto_length : forall n, length (upto n) = n.

Corollary Zlength_upto : forall n, Zlength (upto n) = Z.of_nat n.

Lemma skipn_cons : forall {A}{d: Inhabitant A} n (l : list A), (length l > n)%nat ->
  skipn n l = Znth (Z.of_nat n) l :: skipn (S n) l.

Lemma Znth_upto : forall d m n, 
  0 <= n < Z.of_nat m -> @Znth _ d n (upto m) = n.

Transparent Z.of_nat.

Lemma In_Znth : forall {A} {d: Inhabitant A} (l : list A) x,
    In x l ->
    exists i, 0 <= i < Zlength l /\ Znth i l = x.

Lemma In_upd_Znth_old : forall {A}{d: Inhabitant A} i (x y : A) l, In x l -> x <> Znth i l -> 0 <= i <= Zlength l ->
  In x (upd_Znth i l y).

Lemma Znth_combine : forall {A B} {a: Inhabitant A} {b: Inhabitant B} i (l1: list A) (l2: list B), 
   Zlength l1 = Zlength l2 ->
  Znth i (combine l1 l2) = (Znth i l1, Znth i l2).

Lemma Zlength_combine : forall {A B} (l : list A) (l' : list B),
  Zlength (combine l l') = Z.min (Zlength l) (Zlength l').

Lemma nth_Znth : forall {A}{d: Inhabitant A} i l, nth i l default = Znth (Z.of_nat i) l.

Lemma upd_Znth_cons : forall {A} i a l (x : A), i > 0 ->
  upd_Znth i (a :: l) x = a :: upd_Znth (i - 1) l x.

Lemma upd_Znth_triv : forall {A}{d: Inhabitant A} i (l : list A) x (Hi : 0 <= i < Zlength l),
  Znth i l = x -> upd_Znth i l x = l.

Lemma combine_upd_Znth : forall {A B} (l1 : list A) (l2 : list B) i x1 x2, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine (upd_Znth i l1 x1) (upd_Znth i l2 x2) = upd_Znth i (combine l1 l2) (x1, x2).

Corollary combine_upd_Znth1 : forall {A B}{d: Inhabitant B} (l1 : list A) (l2 : list B) i x,
   0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 ->
   combine (upd_Znth i l1 x) l2 = upd_Znth i (combine l1 l2) (x, Znth i l2).

Corollary combine_upd_Znth2 : forall {A B}{d: Inhabitant A} (l1 : list A) (l2 : list B) i x, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine l1 (upd_Znth i l2 x) = upd_Znth i (combine l1 l2) (Znth i l1, x).

Lemma in_concat : forall {A} (l : list (list A)) x, In x (concat l) <-> exists l1, In x l1 /\ In l1 l.

Lemma length_concat : forall {A} (l : list (list A)), length (concat l) = fold_right plus O (map (@length A) l).

Lemma length_concat_min : forall {A}{d: Inhabitant A} (l : list (list A)) i (Hi : 0 <= i < Zlength l),
  (length (Znth i l) <= length (concat l))%nat.

Lemma length_concat_upd : forall {A} {d: Inhabitant A} l i (l' : list A) (Hi : 0 <= i < Zlength l),
  length (concat (upd_Znth i l l')) = (length (concat l) + length l' - length (Znth i l))%nat.

Lemma sepcon_rev : forall l, fold_right sepcon emp (rev l) = fold_right sepcon emp l.

Lemma incl_nil : forall {A} (l : list A), incl [] l.
Hint Resolve incl_nil.

Lemma incl_cons_out : forall {A} (a : A) l1 l2, incl l1 (a :: l2) -> ~In a l1 -> incl l1 l2.

Lemma In_upto : forall n i, In i (upto n) <-> 0 <= i < Z.of_nat n.

Lemma combine_fst : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map fst (combine l l') = l.

Lemma combine_snd : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map snd (combine l l') = l'.

Lemma rev_combine : forall {A B} (l1 : list A) (l2 : list B), length l1 = length l2 ->
  rev (combine l1 l2) = combine (rev l1) (rev l2).

Lemma combine_map_snd : forall {A B C} (l1 : list A) (l2 : list B) (f : B -> C),
  combine l1 (map f l2) = map (fun x => let '(a, b) := x in (a, f b)) (combine l1 l2).

Lemma combine_const1 : forall {A B} (l1 : list A) (x : B) n, Z.of_nat n >= Zlength l1 ->

Lemma combine_const2 : forall {A B} (x : A) n (l2 : list B), Z.of_nat n >= Zlength l2 ->

Lemma map_const: forall {A B} (c : A) (l : list B), map (fun _ => c) l = repeat c (length l).

Lemma In_upd_Znth : forall {A} i l (x y : A), In x (upd_Znth i l y) -> x = y \/ In x l.

Lemma upd_Znth_In : forall {A} i l (x : A), In x (upd_Znth i l x).

Lemma NoDup_Znth_iff : forall {A}{d: Inhabitant A} (l : list A),
  NoDup l <-> forall i j (Hi : 0 <= i < Zlength l)
                            (Hj : 0 <= j < Zlength l), Znth i l = Znth j l -> i = j.

Lemma concat_less_incl : forall {A} l i (l1 l2 : list A) (Hi : 0 <= i < Zlength l)
  (Hless : Znth i l = l1 ++ l2), incl (concat (upd_Znth i l l1)) (concat l).

Lemma NoDup_app : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) ->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Lemma NoDup_app_iff : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Corollary NoDup_app_swap : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <-> NoDup (l2 ++ l1).

Lemma NoDup_concat_less : forall {A} l i (l1 l2 : list A) (Hl : NoDup (concat l))
  (Hi : 0 <= i < Zlength l) (Hless : Znth i l = l1 ++ l2),
  NoDup (concat (upd_Znth i l l1)).

Lemma Forall2_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2 (Hall : Forall2 P l1 l2) i
  (Hi : 0 <= i < Zlength l1), P (Znth i l1) (Znth i l2).

Lemma Forall2_app_inv : forall {A B} (P : A -> B -> Prop) l1 l2 l3 l4 (Hlen : length l1 = length l3),
  Forall2 P (l1 ++ l2) (l3 ++ l4) -> Forall2 P l1 l3 /\ Forall2 P l2 l4.

Lemma Forall2_firstn : forall {A B} (P : A -> B -> Prop) l1 l2 n, Forall2 P l1 l2 ->
  Forall2 P (firstn n l1) (firstn n l2).

Lemma Forall2_upd_Znth : forall {A B} (P : A -> B -> Prop) l1 l2 i x1 x2, Forall2 P l1 l2 ->
  P x1 x2 -> 0 <= i <= Zlength l1 -> Forall2 P (upd_Znth i l1 x1) (upd_Znth i l2 x2).

Lemma Forall2_impl' : forall {A B} (P Q : A -> B -> Prop) l1 l2,
  (forall a b, In a l1 -> In b l2 -> P a b -> Q a b) -> Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma Forall2_impl : forall {A B} (P Q : A -> B -> Prop), (forall a b, P a b -> Q a b) ->
  forall l1 l2, Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma map_id_eq : forall {A} (l : list A), map (@id A) l = l.

Lemma Forall2_map : forall {A B C D} (P : A -> B -> Prop) (f1 : C -> A) (f2 : D -> B) l1 l2,
  Forall2 P (map f1 l1) (map f2 l2) <-> Forall2 (fun a b => P (f1 a) (f2 b)) l1 l2.

Corollary Forall2_map1 : forall {A B C} (P : A -> B -> Prop) (f : C -> A) l1 l2, Forall2 P (map f l1) l2 <->
  Forall2 (fun a b => P (f a) b) l1 l2.

Corollary Forall2_map2 : forall {A B C} (P : A -> B -> Prop) (f : C -> B) l1 l2, Forall2 P l1 (map f l2) <->
  Forall2 (fun a b => P a (f b)) l1 l2.

Lemma sublist_max_length : forall {A} i j (al : list A), Zlength (sublist i j al) <= Zlength al.

Lemma Forall2_sublist : forall {A B} (P : A -> B -> Prop) l1 l2 i j, Forall2 P l1 l2 -> 0 <= i ->
  Forall2 P (sublist i j l1) (sublist i j l2).

Lemma Forall_last : forall {A} (P : A -> Prop) d l, Forall P l -> P d -> P (last l d).

Lemma last_map : forall {A B} (f : A -> B) d l, f (last l d) = last (map f l) (f d).

Lemma In_removelast : forall {A} (l : list A) x, In x (removelast l) -> In x l.

Definition nil_dec {A} (l : list A) : {l = []} + {l <> []}.

Lemma Forall2_upd_Znth_l : forall {A B}{d: Inhabitant B} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P x (Znth i l2) -> 0 <= i < Zlength l1 -> Forall2 P (upd_Znth i l1 x) l2.

Lemma Forall2_upd_Znth_r : forall {A B}{d: Inhabitant A} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P (Znth i l1) x -> 0 <= i < Zlength l1 -> Forall2 P l1 (upd_Znth i l2 x).

Lemma Forall2_eq_upto : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2, Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ Forall (fun i => P (Znth i l1) (Znth i l2)) (upto (Z.to_nat (Zlength l1))).

Lemma Forall2_forall_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B}  (P : A -> B -> Prop) l1 l2,
  Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ (forall i, 0 <= i < Zlength l1 -> P (Znth i l1) (Znth i l2)).

Lemma Znth_inbounds : forall {A}{d: Inhabitant A} i (l : list A), 
    Znth i l <> default -> 0 <= i < Zlength l.

Lemma sublist_next : forall {A}{d: Inhabitant A} i j l,
      0 <= i < j -> j <= Zlength l ->
  sublist i j l = Znth i l :: sublist (i + 1) j l.

Lemma upd_init : forall {A} (l : list A) i b v v', i < b -> Zlength l = i ->
  upd_Znth i (l ++ repeat v (Z.to_nat (b - i))) v' = l ++ v' :: repeat v (Z.to_nat (b - (i + 1))).

Corollary upd_init_const : forall {A} i b (v v' : A), 0 <= i < b ->
  upd_Znth i (repeat v' (Z.to_nat i) ++ repeat v (Z.to_nat (b - i))) v' =

Lemma list_Znth_eq : forall {A}{d: Inhabitant A} (l : list A),
    l = map (fun j => Znth j l) (upto (length l)).

Arguments eq_dec _ _ _ _ : simpl never.

Lemma upd_Znth_eq : forall {A} {EqDec : EqDec A} {d: Inhabitant A} (x : A) (l : list A) i, 0 <= i < Zlength l ->
  upd_Znth i l x = map (fun j => if eq_dec j i then x else Znth j l) (upto (length l)).

Lemma upd_Znth_diff' : forall {A}{d: Inhabitant A} i j l (u : A),
    0 <= j < Zlength l -> i <> j ->
  Znth i (upd_Znth j l u) = Znth i l.

Lemma list_nth_error_eq : forall {A} (l1 l2 : list A)
  (Heq : forall j, nth_error l1 j = nth_error l2 j), l1 = l2.

Lemma list_Znth_eq' : forall {A} {d: Inhabitant A} (l1 l2 : list A)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> Znth j l1 = Znth j l2), l1 = l2.

Corollary upd_Znth_eq' : forall {A}{d: Inhabitant A} x (l1 l2 : list A) i (Hi : 0 <= i < Zlength l1)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> j <> i -> Znth j l1 = Znth j l2),
  upd_Znth i l1 x = upd_Znth i l2 x.

Lemma upd_Znth_twice : forall {A} i l (x y : A), 0 <= i < Zlength l ->
  upd_Znth i (upd_Znth i l x) y = upd_Znth i l y.

Lemma hd_Znth : forall {A}{d: Inhabitant A} (l : list A), hd default l = Znth 0 l.

Lemma NoDup_filter : forall {A} (f : A -> bool) l, NoDup l -> NoDup (filter f l).

Lemma Permutation_Zlength : forall {A} (l1 l2 : list A), Permutation.Permutation l1 l2 ->

Lemma Permutation_filter : forall {A} (f : A -> bool) l1 l2, Permutation.Permutation l1 l2 ->

Lemma NoDup_add : forall {A} l1 l2 (x : A), NoDup (l1 ++ l2) -> ~In x (l1 ++ l2) -> NoDup (l1 ++ x :: l2).

Lemma list_in_count : forall {A} {A_eq : EqDec A} (l l' : list A), NoDup l' ->
  (length (filter (fun x => if in_dec eq_dec x l then true else false) l') <= length l)%nat.

Lemma filter_length : forall {A} (f : A -> bool) l,
  length l = (length (filter f l) + length (filter (fun x => negb (f x)) l))%nat.

Lemma Zlength_filter : forall {A} f (l : list A), Zlength (filter f l) <= Zlength l.

Lemma Zlength_concat : forall {A} (l : list (list A)),
  Zlength (concat l) = fold_right Z.add 0 (map (@Zlength A) l).

Lemma Zlength_concat_le : forall {A} (l : list (list A)) n,
  Forall (fun l => Zlength l <= n) l -> Zlength (concat l) <= n * Zlength l.

Lemma filter_app : forall {A} (f : A -> bool) l1 l2, filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_concat : forall {A} f (l : list (list A)),
  filter f (concat l) = concat (map (filter f) l).

Lemma NoDup_upto : forall n, NoDup (upto n).

Lemma In_remove : forall {A} {A_eq : EqDec A} (x y : A) l, In x (remove A_eq y l) <-> In x l /\ x <> y.

Lemma remove_NoDup : forall {A} {A_eq : EqDec A} (x : A) l, NoDup l -> NoDup (remove A_eq x l).

Lemma remove_out : forall {A} {A_eq : EqDec A} (x : A) l, ~In x l -> remove A_eq x l = l.

Lemma remove_from_NoDup : forall {A} {A_eq : EqDec A} (x : A) l1 l2, NoDup (l1 ++ x :: l2) ->
  remove A_eq x (l1 ++ x :: l2) = l1 ++ l2.

Lemma incl_remove_add : forall {A} {A_eq : EqDec A} (x : A) l1 l2, incl l1 l2 -> incl l1 (x :: remove A_eq x l2).

Lemma list_pigeonhole : forall l n, Zlength l < n -> exists a, 0 <= a < n /\ ~In a l.

Lemma In_sublist_upto : forall n x i j, In x (sublist i j (upto n)) -> 0 <= i ->
  i <= x < j /\ x < Z.of_nat n.

Lemma incl_cons_iff : forall {A} (a : A) b c, incl (a :: b) c <-> In a c /\ incl b c.

Lemma lt_le_1 : forall i j, i < j <-> i + 1 <= j.

Lemma firstn_all : forall {A} n (l : list A), (length l <= n)%nat -> firstn n l = l.

Lemma sublist_all : forall {A} i (l : list A), Zlength l <= i -> sublist 0 i l = l.

Lemma sublist_prefix : forall {A} i j (l : list A), sublist 0 i (sublist 0 j l) = sublist 0 (Z.min i j) l.

Lemma sublist_suffix : forall {A} i j (l : list A), 0 <= i -> 0 <= j ->
  sublist i (Zlength l - j) (sublist j (Zlength l) l) = sublist (i + j) (Zlength l) l.

Lemma sublist_parts1 : forall {A} i j (l : list A), 0 <= i -> sublist i j l = sublist i j (sublist 0 j l).

Lemma sublist_parts2 : forall {A} i j (l : list A), 0 <= i -> j <= Zlength l ->
  sublist i j l = sublist 0 (j - i) (sublist i (Zlength l) l).

Lemma Forall_Forall2 : forall {A} (P : A -> Prop) Q l1 l2 (HP : Forall P l1) (HQ : Forall2 Q l1 l2)
  (Htransfer : forall x y, P x -> Q x y -> P y), Forall P l2.

Lemma Forall_suffix_max : forall {A} (P : A -> Prop) l1 l2 i j
  (Hi : 0 <= i <= Zlength l1) (Hj : 0 <= j <= Zlength l1)
  (Hl1 : Forall P (sublist j (Zlength l1) l1))
  (Hl2 : sublist i (Zlength l1) l1 = sublist i (Zlength l2) l2),
  Forall P (sublist (Z.max i j) (Zlength l2) l2).

Fixpoint extend {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (x :: y) :: extend xs ys
  | _, _ => ls
  end.

Lemma Zlength_extend : forall {A} (l : list A) ls, Zlength (extend l ls) = Zlength ls.

Lemma Znth_extend_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extend l ls) = Znth i l :: Znth i ls.

Lemma Znth_extend_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extend l ls) = Znth i ls.

Fixpoint extendr {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (y ++ [x]) :: extendr xs ys
  | _, _ => ls
  end.

Lemma Zlength_extendr : forall {A} (l : list A) ls, Zlength (extendr l ls) = Zlength ls.

Lemma Znth_extendr_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extendr l ls) = Znth i ls ++ [Znth i l].

Lemma Znth_extendr_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extendr l ls) = Znth i ls.

Lemma list_join_eq : forall (b : list share) a c c'
  (Hc : sepalg_list.list_join a b c) (Hc' : sepalg_list.list_join a b c'), c = c'.

Lemma readable_share_list_join : forall sh shs sh', sepalg_list.list_join sh shs sh' ->

Lemma sublist_0_cons' : forall {A} i j (x : A) l, i <= 0 -> j > i -> sublist i j (x :: l) =
  x :: sublist i (j - 1) l.

Lemma sublist_combine : forall {A B} (l1 : list A) (l2 : list B) i j,
  sublist i j (combine l1 l2) = combine (sublist i j l1) (sublist i j l2).

Lemma extend_nil : forall {A} (l : list A), extend l [] = [].

Lemma extend_cons : forall {A} (l : list A) l1 ls, extend l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (a :: l1) :: extend l' ls end.

Lemma sublist_extend : forall {A} (l : list A) ls i j,
  sublist i j (extend l ls) = extend (sublist i j l) (sublist i j ls).

Lemma extendr_nil : forall {A} (l : list A), extendr l [] = [].

Lemma extendr_cons : forall {A} (l : list A) l1 ls, extendr l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (l1 ++ [a]) :: extendr l' ls end.

Lemma sublist_extendr : forall {A} (l : list A) ls i j,
  sublist i j (extendr l ls) = extendr (sublist i j l) (sublist i j ls).

Lemma sublist_over : forall {A} (l : list A) i j, Zlength l <= i -> sublist i j l = [].

Lemma make_tycontext_s_distinct : forall a l (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (make_tycontext_s l) ! (fst a) = Some (snd a).

Lemma lookup_distinct : forall {A B} (f : A -> B) a l t (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! (fst a) =

Lemma lookup_out : forall {A B} (f : A -> B) a l t (Ha : ~In a (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! a = t ! a.

Lemma data_at__eq : forall {cs : compspecs} sh t p, data_at_ sh t p = data_at sh t (default_val t) p.

Lemma func_tycontext_sub : forall f V G A V2 G2 (HV : incl V V2) (HG : incl G G2)
  (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  tycontext_sub (func_tycontext f V G A) (func_tycontext f V2 G2 A).

Lemma semax_body_mono : forall V G {cs : compspecs} f s V2 G2
  (HV : incl V V2) (HG : incl G G2) (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  semax_body V G f s -> semax_body V2 G2 f s.

Lemma weak_exclusive_conflict : forall P,
  predicates_hered.derives ((weak_exclusive_mpred P && emp) * P * P) FF.

Lemma exclusive_sepcon1 : forall (P Q : mpred) (HP : exclusive_mpred P), exclusive_mpred (P * Q).

Lemma exclusive_sepcon2 : forall (P Q : mpred) (HP : exclusive_mpred Q), exclusive_mpred (P * Q).

Lemma exclusive_andp1 : forall P Q (HP : exclusive_mpred P), exclusive_mpred (P && Q).

Lemma exclusive_andp2 : forall P Q (HQ : exclusive_mpred Q), exclusive_mpred (P && Q).

Lemma lock_inv_exclusive : forall v sh R, exclusive_mpred (lock_inv sh v R).

Lemma selflock_exclusive : forall R sh v, exclusive_mpred R -> exclusive_mpred (selflock R v sh).

Lemma exclusive_FF : exclusive_mpred FF.

Lemma derives_exclusive : forall P Q (Hderives : P |-- Q) (HQ : exclusive_mpred Q),
  exclusive_mpred P.

Lemma mapsto_exclusive : forall (sh : Share.t) (t : type) (v : val),

Lemma field_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Lemma ex_field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Corollary field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) v (p : val),

Lemma ex_data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Corollary data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) v (p : val),

Corollary data_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Lemma cond_var_exclusive : forall {cs} sh p, sepalg.nonidentity sh ->

Lemma lock_inv_isptr : forall sh v R, lock_inv sh v R = !!isptr v && lock_inv sh v R.

Lemma cond_var_isptr : forall {cs} sh v, @cond_var cs sh v = !! isptr v && cond_var sh v.
Hint Resolve lock_inv_isptr cond_var_isptr : saturate_local.

Lemma cond_var_share_join : forall {cs} sh1 sh2 sh v (Hjoin : sepalg.join sh1 sh2 sh),

Hint Resolve lock_inv_exclusive selflock_exclusive cond_var_exclusive data_at_exclusive
  data_at__exclusive field_at_exclusive field_at__exclusive selflock_rec.

Lemma eq_dec_refl : forall {A B} {A_eq : EqDec A} (a : A) (b c : B), (if eq_dec a a then b else c) = b.

Lemma LKspec_readable lock_size :
  0 < lock_size ->
  forall R sh p, predicates_hered.derives (res_predicates.LKspec lock_size R sh p)

Lemma lock_inv_share_join : forall sh1 sh2 sh v R (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (Hjoin : sepalg.join sh1 sh2 sh),

Lemma comp_join_top : forall sh, sepalg.join sh (Share.comp sh) Tsh.

Lemma unreadable_bot : ~readable_share Share.bot.
Hint Resolve unreadable_bot.

Definition join_Bot := join_Bot.

Lemma join_Tsh : forall a b, sepalg.join Tsh a b -> b = Tsh /\ a = Share.bot.

Definition gsh1 := fst (slice.cleave Tsh).
Definition gsh2 := snd (slice.cleave Tsh).

Lemma readable_gsh1 : readable_share gsh1.

Lemma readable_gsh2 : readable_share gsh2.

Lemma gsh1_gsh2_join : sepalg.join gsh1 gsh2 Tsh.

Hint Resolve readable_gsh1 readable_gsh2 gsh1_gsh2_join.

Lemma gsh1_not_bot : gsh1 <> Share.bot.

Lemma gsh2_not_bot : gsh2 <> Share.bot.
Hint Resolve gsh1_not_bot gsh2_not_bot.

Lemma split_readable_share sh :
  readable_share sh ->
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 sh.

Lemma split_Ews :
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 Ews.

Definition remove_Znth {A} i (al : list A) := sublist 0 i al ++ sublist (i + 1) (Zlength al) al.

Lemma remove_Znth0 : forall {A} (l : list A), remove_Znth 0 l = sublist 1 (Zlength l) l.

Lemma remove_Znth_cons : forall {A} i a (l : list A), i > 0 ->
  remove_Znth i (a :: l) = a :: remove_Znth (i - 1) l.

Lemma Zlength_remove_Znth : forall {A} i (l : list A), 0 <= i < Zlength l ->
  Zlength (remove_Znth i l) = Zlength l - 1.

Lemma remove_upd_Znth: forall {A} i l (a : A), 0 <= i < Zlength l ->
  remove_Znth i (upd_Znth i l a) = remove_Znth i l.

Lemma remove_Znth_map: forall {A B} (f : A -> B) i l,
  remove_Znth i (map f l) = map f (remove_Znth i l).

Lemma remove_Znth_combine: forall {A B} i (l1 : list A) (l2 : list B),
  0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  remove_Znth i (combine l1 l2) = combine (remove_Znth i l1) (remove_Znth i l2).

Lemma iter_sepcon_Znth: forall {A} {d : Inhabitant A} f (l : list A) i, 0 <= i < Zlength l ->
  iter_sepcon f l = f (Znth i l) * iter_sepcon f (remove_Znth i l).

Lemma iter_sepcon2_Znth: forall {A B} {d1 : Inhabitant A} {d2 : Inhabitant B}
  f (l1 : list A) (l2 : list B) i, 0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  iter_sepcon2 f l1 l2 =
  f (Znth i l1) (Znth i l2) * iter_sepcon2 f (remove_Znth i l1) (remove_Znth i l2).

Instance Inhabitant_share : Inhabitant share := Share.bot.  
Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.  

Lemma join_shares_nth : forall shs sh1 sh i, sepalg_list.list_join sh1 shs sh -> 0 <= i < Zlength shs ->

Lemma list_join_comm : forall (l1 l2 : list share) a b, sepalg_list.list_join a (l1 ++ l2) b ->

Lemma split_shares : forall n sh, readable_share sh ->
  exists sh1 shs, Zlength shs = Z.of_nat n /\ readable_share sh1 /\ Forall readable_share shs /\

Lemma data_at_shares_join : forall {cs} sh t v p shs sh1 (Hsplit : sepalg_list.list_join sh1 shs sh),

Lemma exp_comm : forall {A B} P,
  (EX x : A, EX y : B, P x y) = EX y : B, EX x : A, P x y.

Lemma mapsto_value_eq: forall sh1 sh2 t p v1 v2, readable_share sh1 -> readable_share sh2 ->
  v1 <> Vundef -> v2 <> Vundef -> mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- !!(v1 = v2).

Lemma mapsto_value_cohere: forall sh1 sh2 t p v1 v2, readable_share sh1 ->
  mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- mapsto sh1 t p v1 * mapsto sh2 t p v1.

Lemma struct_pred_value_cohere : forall {cs : compspecs} m sh1 sh2 p t f off v1 v2
  (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (IH : Forall (fun it : ident * type => forall v1 v2 (p : val),
        readable_share sh1 -> readable_share sh2 ->
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v2 p |--
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v1 p) m),
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v2 p |--
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v1 p.

Lemma data_at_value_cohere : forall {cs : compspecs} sh1 sh2 t v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 t v1 p * data_at sh2 t v2 p |--
  data_at sh1 t v1 p * data_at sh2 t v1 p.

Lemma data_at_array_value_cohere : forall {cs : compspecs} sh1 sh2 t z a v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v2 p |--
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v1 p.

Lemma extract_nth_sepcon : forall l i, 0 <= i < Zlength l ->
  fold_right sepcon emp l = Znth i l * fold_right sepcon emp (upd_Znth i l emp).

Lemma replace_nth_sepcon : forall P l i, P * fold_right sepcon emp (upd_Znth i l emp) =
  fold_right sepcon emp (upd_Znth i l P).

Lemma sepcon_derives_prop : forall P Q R, P |-- !!R -> P * Q |-- !!R.

Lemma sepcon_map : forall {A} P Q (l : list A), fold_right sepcon emp (map (fun x => P x * Q x) l) =
  fold_right sepcon emp (map P l) * fold_right sepcon emp (map Q l).

Lemma sepcon_list_derives : forall l1 l2 (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall i, 0 <= i < Zlength l1 -> Znth i l1 |-- Znth i l2),
  fold_right sepcon emp l1 |-- fold_right sepcon emp l2.

Lemma sepcon_rotate : forall lP m n, 0 <= n - m < Zlength lP ->
  fold_right sepcon emp lP = fold_right sepcon emp (rotate lP m n).

Lemma wand_eq : forall P Q R, P = Q * R -> P = Q * (Q -* P).

Lemma wand_twice : forall P Q R, P -* Q -* R = P * Q -* R.

Lemma sepcon_In : forall l P, In P l -> exists Q, fold_right sepcon emp l = P * Q.

Lemma extract_wand_sepcon : forall l P, In P l ->
  fold_right sepcon emp l = P * (P -* fold_right sepcon emp l).

Lemma wand_sepcon_map : forall {A} (R : A -> mpred) l P Q
  (HR : forall i, In i l -> R i = P i * Q i),
  fold_right sepcon emp (map R l) = fold_right sepcon emp (map P l) *
    (fold_right sepcon emp (map P l) -* fold_right sepcon emp (map R l)).

Lemma wand_frame : forall P Q R, P -* Q |-- P * R -* Q * R.

Lemma semax_extract_later_prop'':
  forall {CS : compspecs} {Espec: OracleKind},
    forall (Delta : tycontext) (PP : Prop) P Q R c post P1 P2,
      P2 |-- !!PP ->
      (PP -> semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post) ->
      semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post.

Lemma field_at_array_inbounds : forall {cs : compspecs} sh t z a i v p,
  field_at sh (Tarray t z a) [ArraySubsc i] v p |-- !!(0 <= i < z).

Lemma valid_pointer_isptr : forall v, valid_pointer v |-- !!(is_pointer_or_null v).

Hint Resolve valid_pointer_isptr : saturate_local.

Lemma approx_imp : forall n P Q, compcert_rmaps.RML.R.approx n (predicates_hered.imp P Q) =

Definition super_non_expansive' {A} P := forall n ts x, compcert_rmaps.RML.R.approx n (P ts x) =
  compcert_rmaps.RML.R.approx n (P ts (functors.MixVariantFunctor.fmap (rmaps.dependent_type_functor_rec ts A)
        (compcert_rmaps.RML.R.approx n) (compcert_rmaps.RML.R.approx n) x)).

Lemma approx_sepcon_list: forall n lP, lP <> [] ->
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP) =

Corollary approx_sepcon_list' : forall n lP P,
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP)  * compcert_rmaps.RML.R.approx n P =

Lemma approx_FF : forall n, compcert_rmaps.RML.R.approx n FF = FF.

Lemma later_nonexpansive : nonexpansive (@later mpred _ _).

Lemma eqp_refl : forall (G : Triv) P, G |-- P <=> P.

Lemma eqp_sepcon : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P * Q <=> P' * Q'.

Lemma eqp_andp : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P && Q <=> P' && Q'.

Lemma eqp_exp : forall (A : Type) (NA : NatDed A) (IA : Indir A) (RecIndir : RecIndir A)
    (G : Triv) (B : Type) (X Y : B -> A),
  (forall x : B, G |-- X x <=> Y x) ->
  G |-- (EX x : _, X x) <=> (EX x : _, Y x).

Lemma fold_right_sepcon_nonexpansive : forall lP1 lP2, Zlength lP1 = Zlength lP2 ->
  (ALL i : Z, Znth i lP1 <=> Znth i lP2) |--
  fold_right sepcon emp lP1 <=> fold_right sepcon emp lP2.

Lemma void_ret : ifvoid tvoid (` (PROP ( )  LOCAL ()  SEP ()) (make_args [] []))
  (EX v : val, ` (PROP ( )  LOCAL ()  SEP ()) (make_args [ret_temp] [v])) = emp.

Ltac lock_props := rewrite ?sepcon_assoc; rewrite <- sepcon_emp at 1; rewrite sepcon_comm; apply sepcon_derives;
  [repeat apply andp_right; auto; eapply derives_trans;
   try (apply exclusive_weak_exclusive || (apply rec_inv_weak_rec_inv; try apply selflock_rec)); auto |
   try timeout 20 cancel].

Ltac join_sub := repeat (eapply sepalg.join_sub_trans;
  [eexists; first [eassumption | simple eapply sepalg.join_comm; eassumption]|]); eassumption.

Ltac join_inj := repeat match goal with H1 : sepalg.join ?a ?b ?c, H2 : sepalg.join ?a ?b ?d |- _ =>
    pose proof (sepalg.join_eq H1 H2); clear H1 H2; subst; auto end.

Ltac fast_cancel := rewrite ?sepcon_emp, ?emp_sepcon; rewrite ?sepcon_assoc;
  repeat match goal with
    | |- ?P |-- ?P => apply derives_refl
    | |- ?P * _ |-- ?P * _ => apply sepcon_derives; [apply derives_refl|]
    | |- _ |-- ?P * _ => rewrite <- !sepcon_assoc, (sepcon_comm _ P), !sepcon_assoc end;
  try cancel_frame.

Lemma semax_fun_id'' id f gv Espec {cs} Delta P Q R Post c :
  (var_types Delta) ! id = None ->
  (glob_specs Delta) ! id = Some f ->
  (glob_types Delta) ! id = Some (type_of_funspec f) ->
  snd (local2ptree Q) = Some gv ->
  @semax cs Espec Delta
    (PROPx P
      (LOCALx Q
      (SEPx ((func_ptr' f (gv id)) :: R)))) c Post ->
  @semax cs Espec Delta (PROPx P (LOCALx Q (SEPx R))) c Post.

Ltac get_global_function'' _f :=
eapply (semax_fun_id'' _f); try reflexivity.

Ltac start_dep_function := 
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH _ : globals
               PRE  [] main_pre _ nil _
               POST [ tint ] main_post _ nil _) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match _ with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList i
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax.

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => P%assert end)
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, 
             x5 at level 0, x6 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             P at level 100, Q at level 100).

Definition call_setup2'
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost
  (bl: list expr) (vl : list val)
  (Qactuals : PTree.t _)
  (witness: functors.MixVariantFunctor._functor (rmaps.dependent_type_functor_rec ts A) mpred)
  (Frame: list mpred)
  (Ppre: list Prop) (Qpre : list localdef) (Rpre: list mpred)
  (Qpre_temp : PTree.t _) GV' :=
 call_setup1 cs Qtemp Qvar GV a Delta P Q R R' fs argsig retty cc A Pre Post NEPre NEPost bl vl Qactuals /\
  Pre ts witness = PROPx Ppre (LOCALx Qpre (SEPx Rpre)) /\
  local2ptree Qpre = (Qpre_temp, PTree.empty _, nil, GV') /\
  ENTAIL Delta, PROPx P (LOCALx Q (SEPx R))
           |-- !! Forall (check_one_temp_spec Qactuals) (PTree.elements Qpre_temp) /\
  check_gvars_spec GV GV' /\
  fold_right_sepcon R |-- fold_right_sepcon Rpre * fold_right_sepcon Frame.

Lemma call_setup2'_i:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree) Pre Post NEPre NEPost

Ltac check_witness_type' ts A witness :=
  (unify A (rmaps.ConstType Ridiculous); 
             elimtype False)
 ||
 let TA := constr:(functors.MixVariantFunctor._functor
     (rmaps.dependent_type_functor_rec ts A) mpred) in
  let TA' := eval cbv 
     [functors.MixVariantFunctor._functor
      functors.MixVariantFunctorGenerator.fpair
      functors.MixVariantFunctorGenerator.fconst
      functors.MixVariantFunctorGenerator.fidentity
      rmaps.dependent_type_functor_rec
      functors.GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
      functors.CovariantFunctorGenerator.fconst
      functors.CovariantFunctorGenerator.fidentity
      functors.CovariantBiFunctor._functor
      functors.CovariantBiFunctorGenerator.Fpair
      functors.GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
      functors.CovariantFunctor._functor
      functors.MixVariantFunctor.fmap
      ] in TA
 in let TA'' := eval simpl in TA'
  in match type of witness with ?T => 
       unify T TA''
      + (fail "Type of witness does not match type required by funspec WITH clause.
Witness value: " witness "
Witness type: " T "
Funspec type: " TA'')
     end.

Ltac prove_call_setup' ts witness :=
 prove_call_setup1 subsume_funspec_refl;
 [ .. | 
 match goal with |- call_setup1  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?A _ _ _ _ _ _ _ -> _ =>
      check_witness_type' ts A witness
 end;
 let H := fresh in
 intro H;
 match goal with | |- @semax ?CS _ _ _ _ _ =>
 let Frame := fresh "Frame" in evar (Frame: list mpred);
 exploit (call_setup2'_i _ _ _ _ _ _ _ _ _ _ _ _ _ _ ts _ _ _ _ _ _ _ _ H witness Frame); clear H;
 simpl functors.MixVariantFunctor._functor;
 [ reflexivity
 | check_prove_local2ptree
 | Forall_pTree_from_elements
 | unfold check_gvars_spec; solve [exact I | reflexivity]
 | try change_compspecs CS; cancel_for_forward_call
 | 
 ]
 end].

Lemma semax_call_aux55:
 forall (cs: compspecs) (Qtemp: PTree.t val) (Qvar: PTree.t (type * val)) GV (a: expr)

Lemma semax_call_id00_wow:
 forall  
  (cs: compspecs) Qtemp Qvar a GV Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_x_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_y_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id01_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Ltac  forward_call_id1_wow' := 
let H := fresh in intro H;
eapply (semax_call_id1_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H);
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [check_result_type
 |apply Logic.I
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_x_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_x_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_y_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_y_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id01_wow' :=
let H := fresh in intro H;
eapply (semax_call_id01_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ apply Coq.Init.Logic.I 
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id00_wow'  :=
let H := fresh in intro H;
eapply (semax_call_id00_wow _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type 
 | cbv beta iota zeta; unfold_post; extensionality rho;
    repeat rewrite exp_uncurry;
    try rewrite no_post_exists0;
    repeat rewrite exp_unfold;
    first [reflexivity | extensionality; simpl; reflexivity | give_EX_warning]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac fwd_call'_dep ts witness :=
lazymatch goal with
| |- semax _ _ (Ssequence (Scall _ _ _) _) _ =>
  eapply semax_seq';
    [prove_call_setup' ts witness;
     clear_Delta_specs; clear_MORE_POST;
     [ .. |
      lazymatch goal with
      | |- _ -> semax _ _ (Scall (Some _) _ _) _ =>
         forward_call_id1_wow'
      | |- call_setup2' _ _ _ _ _ _ _ _ _ _ _ _ ?retty _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ -> 
                semax _ _ (Scall None _ _) _ =>
        tryif (unify retty Tvoid)
        then forward_call_id00_wow'
        else forward_call_id01_wow'
     end]
   | after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Ecast (Etempvar ?ret'2 _) _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_x_wow' ]
         |  after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Etempvar ?ret'2 _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_y_wow' ]
         |  after_forward_call ]
| |- _ => rewrite <- seq_assoc; fwd_call'_dep ts witness
end.

Ltac fwd_call_dep ts witness :=
 try lazymatch goal with
      | |- semax _ _ (Scall _ _ _) _ => rewrite -> semax_seq_skip
      end;
 repeat lazymatch goal with
  | |- semax _ _ (Ssequence (Ssequence (Ssequence _ _) _) _) _ =>
      rewrite <- seq_assoc
 end;
lazymatch goal with |- @semax ?CS _ ?Delta _ (Ssequence ?C _) _ =>
  lazymatch C with context [Scall _ _ _] =>
         fwd_call'_dep ts witness
    end
end.

Tactic Notation "forward_call_dep" constr(ts) constr(witness) := fwd_call_dep ts witness.

Lemma PROP_into_SEP : forall P Q R, PROPx P (LOCALx Q (SEPx R)) =
  PROPx [] (LOCALx Q (SEPx (!!fold_right and True P && emp :: R))).

Ltac cancel_for_forward_spawn :=
  eapply symbolic_cancel_setup;
   [ construct_fold_right_sepcon
   | construct_fold_right_sepcon
   | fold_abnormal_mpred
   | cbv beta iota delta [before_symbol_cancel]; cancel_for_forward_call].

Ltac forward_spawn id arg wit :=
  match goal with gv : globals |- _ =>
  make_func_ptr id; let f := fresh "f_" in set (f := gv id);
  match goal with |- context[func_ptr' (NDmk_funspec _ _ (val * ?A) ?Pre _) f] =>
    let y := fresh "y" in let Q := fresh "Q" in let R := fresh "R" in
    evar (y : ident); evar (Q : A -> globals); evar (R : A -> val -> mpred);
    replace Pre with (fun '(a, w) => PROPx [] (LOCALx (temp y a :: gvars (Q w) :: nil) (SEPx [R w a])));
    [|let x := fresh "x" in extensionality x; destruct x as (?, x);
      instantiate (1 := fun w a => _ w) in (Value of R);
      repeat (destruct x as (x, ?);
        instantiate (1 := fun '(a, b) => _ a) in (Value of Q);
        instantiate (1 := fun '(a, b) => _ a) in (Value of R));
      etransitivity; [|symmetry; apply PROP_into_SEP]; f_equal; f_equal ; [instantiate (1 := fun _ => _) in (Value of Q); subst y Q; f_equal; simpl; f_equal |
       unfold SEPx; extensionality; simpl; rewrite sepcon_emp; instantiate (1 := fun _ => _); reflexivity]];
  forward_call_dep [A] (f, arg, Q, wit, R); subst Q R; [ .. | subst y f]; try (Exists y; subst y f; simpl; cancel_for_forward_spawn) end end. *)

Require Import atomics.maps.
(* atomics.maps:
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import RelationClasses.

Section ListMaps.

Context {A B : Type} {A_eq : EqDec A} {d : Inhabitant B}.

Definition map_Znth i (L : A -> option (list B)) k := option_map (fun v => Znth i v) (L k).

Lemma map_Znth_single : forall i (k : A) (v : list B),
  map_Znth i (singleton k v) = singleton k (Znth i v).

Lemma map_Znth_add : forall (m1 m2 : A -> option (list B)) i,
  map_Znth i (map_add m1 m2) = map_add (map_Znth i m1) (map_Znth i m2).

Lemma map_Znth_eq : forall (L : A -> option (list B)) k vs (Hlength : forall vs', L k = Some vs' -> Zlength vs' = Zlength vs)
  (Hnz : vs <> []) (Hall : forall i, 0 <= i < Zlength vs -> map_Znth i L k = Some (Znth i vs)),
  L k = Some vs.

Lemma map_Znth_upd : forall (m : A -> option (list B)) k v i,
  map_Znth i (map_upd m k v) = map_upd (map_Znth i m) k (Znth i v).

Lemma map_incl_Znth : forall (m1 m2 : A -> option (list B)) i, map_incl m1 m2 ->
  map_incl (map_Znth i m1) (map_Znth i m2).

End ListMaps.

Section Logs.

Context {B : Type}.

Definition log_latest s (v1 : Z) (v2 : B) := s v1 = Some v2 /\ forall v', v1 < v' -> s v' = None.

Lemma log_latest_singleton : forall v1 v2, log_latest (singleton v1 v2) v1 v2.

Lemma log_incl_latest : forall k1 k2 v1 v2 log1 log2 (Hincl : map_incl log1 log2)
  (Hv1 : log1 k1 = Some v1) (Hlatest : log_latest log2 k2 v2), k1 <= k2.

Lemma log_latest_upd : forall log v1 v2 v1' v2', log_latest log v1 v2 -> v1 < v1' ->
  map_incl log (map_upd log v1' v2') /\ log_latest (map_upd log v1' v2') v1' v2'.

Lemma log_latest_inj : forall log v1 v2 v1' v2' (H1 : log_latest log v1 v2) (H1' : log_latest log v1' v2'),
  v1 = v1' /\ v2 = v2'.

Lemma log_latest_add : forall m1 m2 k1 k2 (v1 v2 : B)
  (Hlatest1 : log_latest m1 k1 v1) (Hlatest2 : log_latest m2 k2 v2),
  log_latest (map_add m1 m2) (Z.max k1 k2) (if zlt k1 k2 then v2 else v1).

Lemma log_latest_upd_list : forall l (m : Z -> option B) k v k' v' (Hm : log_latest m k v)
  (Hlast : last l (k, v) = (k', v')) (Hlt : k <= k') (Hordered : Forall (fun '(k, v) => k <= k') l),
  log_latest (map_upd_list m l) k' v'.

End Logs.

Lemma map_Znth_log_latest : forall {B} {d : Inhabitant B} m k (v : list B) i, log_latest m k v ->
  log_latest (map_Znth i m) k (Znth i v). *)

Require Import VST.floyd.library.
(* VST.floyd.library:
Require Import VST.floyd.base2.
Require Import VST.floyd.sublist.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.closed_lemmas.
Require Import VST.floyd.compare_lemmas.
Require Import VST.floyd.semax_tactics.
Require Import VST.floyd.forward.
Require Import VST.floyd.call_lemmas.
Require Import VST.floyd.forward_lemmas.
Require Import VST.floyd.for_lemmas.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.nested_field_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import VST.floyd.mapsto_memory_block.
Require Import VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.data_at_rec_lemmas.
Require Import VST.floyd.field_at.
Require Import VST.floyd.field_compat.
Require Import VST.floyd.stronger.
Require Import VST.floyd.loadstore_mapsto.
Require Import VST.floyd.loadstore_field_at.
Require Import VST.floyd.nested_loadstore.
Require Import VST.floyd.local2ptree_denote.
Require Import VST.floyd.local2ptree_eval.
Require Import VST.floyd.proj_reptype_lemmas.
Require Import VST.floyd.replace_refill_reptype_lemmas.
Require Import VST.floyd.sc_set_load_store.

Require Import VST.floyd.entailer.
Require Import VST.floyd.globals_lemmas.
Require Import VST.floyd.diagnosis.
Require Import VST.floyd.freezer.
Import ListNotations.
Import String.

Definition body_lemma_of_funspec  {Espec: OracleKind} (ef: external_function) (f: funspec) :=
  match f with mk_funspec sig _ A P Q _ _ =>
    semax_external (map fst (fst sig)) ef A P Q
  end.

Definition try_spec  (name: string) (spec: funspec) : 
   list (ident * globdef Clight.fundef type) -> list (ident*funspec) :=
fun defs => 
 match ext_link_prog' defs name with
 | Some id => [(id,spec)]
 | None => nil
 end.
Arguments try_spec name spec defs / .

Definition exit_spec' :=
 WITH u: unit
 PRE [1%positive OF tint]
   PROP () LOCAL() SEP()
 POST [ tvoid ]
   PROP(False) LOCAL() SEP().

Definition exit_spec := try_spec "exit" exit_spec'.

Parameter body_exit:
 forall {Espec: OracleKind},
  body_lemma_of_funspec
    (EF_external "exit"
       {| sig_args := AST.Tint :: nil; sig_res := None; sig_cc := cc_default |})
   exit_spec'.

Parameter mem_mgr: globals -> mpred.
Axiom create_mem_mgr: forall gv, emp |-- mem_mgr gv.

Parameter malloc_token : forall {cs: compspecs}, share -> type -> val -> mpred.
Parameter malloc_token_valid_pointer:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- valid_pointer p.
Hint Resolve malloc_token_valid_pointer : valid_pointer.

Parameter malloc_token_local_facts:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- !! malloc_compatible (sizeof t) p.
Hint Resolve malloc_token_local_facts : saturate_local.
Parameter malloc_token_change_composite: forall {cs_from cs_to} {CCE : change_composite_env cs_from cs_to} sh t,
  cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->
  @malloc_token cs_from sh t = @malloc_token cs_to sh t.
Ltac change_compspecs' cs cs' ::=
  match goal with
  | |- context [@data_at cs' ?sh ?t ?v1] => erewrite (@data_at_change_composite cs' cs _ sh t); [| apply JMeq_refl | reflexivity]
  | |- context [@field_at cs' ?sh ?t ?gfs ?v1] => erewrite (@field_at_change_composite cs' cs _ sh t gfs); [| apply JMeq_refl | reflexivity]
  | |- context [@data_at_ cs' ?sh ?t] => erewrite (@data_at__change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [@field_at_ cs' ?sh ?t ?gfs] => erewrite (@field_at__change_composite cs' cs _ sh t gfs); [| reflexivity]
  | |- context [@malloc_token cs' ?sh ?t] => erewrite (@malloc_token_change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [?A cs'] => change (A cs') with (A cs)
  | |- context [?A cs' ?B] => change (A cs' B) with (A cs B)
  | |- context [?A cs' ?B ?C] => change (A cs' B C) with (A cs B C)
  | |- context [?A cs' ?B ?C ?D] => change (A cs' B C D) with (A cs B C D)
  | |- context [?A cs' ?B ?C ?D ?E] => change (A cs' B C D E) with (A cs B C D E)
  | |- context [?A cs' ?B ?C ?D ?E ?F] => change (A cs' B C D E F) with (A cs B C D E F)
 end.

Definition malloc_spec'  {cs: compspecs} :=
   WITH t:type, gv: globals
   PRE [ 1%positive OF size_t ]
       PROP (0 <= sizeof t <= Ptrofs.max_unsigned;
                complete_legal_cosu_type t = true;
                natural_aligned natural_alignment t = true)
       LOCAL (temp 1%positive (Vptrofs (Ptrofs.repr (sizeof t))); gvars gv)
       SEP (mem_mgr gv)
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (mem_mgr gv;
             if eq_dec p nullval then emp
            else (malloc_token Ews t p * data_at_ Ews t p)).

Parameter body_malloc:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_malloc malloc_spec'.

Definition free_spec'  {cs: compspecs} :=
   WITH t: type, p:val, gv: globals
   PRE [ 1%positive OF tptr tvoid ]
       PROP ()
       LOCAL (temp 1%positive p; gvars gv)
       SEP (mem_mgr gv;
              if eq_dec p nullval then emp
              else (malloc_token Ews t p * data_at_ Ews t p))
    POST [ Tvoid ]
       PROP ()
       LOCAL ()
       SEP (mem_mgr gv).

Parameter body_free:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_free free_spec'.

Definition library_G  {cs: compspecs} prog :=
 let defs := prog_defs prog in 
  try_spec "exit" exit_spec' defs ++
  try_spec "_malloc" malloc_spec' defs ++
  try_spec "_free" free_spec' defs.

Ltac with_library prog G :=
  let pr := eval unfold prog in prog in  
 let x := constr:(library_G pr ++ G) in
  let x := eval cbv beta delta [app library_G] in x in
  let x := simpl_prog_defs x in 
  let x := eval cbv beta iota zeta delta [try_spec] in x in 
  let x := eval simpl in x in 
    with_library' pr x.

Lemma semax_func_cons_malloc_aux:
  forall {cs: compspecs} (gv: globals) (gx : genviron) (t :type) (ret : option val),
(EX p : val,
 PROP ( )
 LOCAL (temp ret_temp p)
 SEP (mem_mgr gv;
      if eq_dec p nullval
      then emp
      else malloc_token Ews t p * data_at_ Ews t p))%assert
  (make_ext_rval gx ret) |-- !! is_pointer_or_null (force_val ret). *)

Require Import VST.floyd.sublist.
(* VST.floyd.sublist:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Require Import Coq.Lists.List.
Import ListNotations.

Class Inhabitant (A: Type) := default : A.

Instance Inhabitant_Z : Inhabitant Z := 0.
Instance Inhabitant_nat : Inhabitant nat := O.
Instance Inhabitant_positive : Inhabitant positive := 1%positive.
Instance Inhabitant_list {T: Type} : Inhabitant (list T) := @nil T.
Instance Inhabitant_fun {T1 T2: Type} {H: Inhabitant T2} : Inhabitant (T1->T2) := fun _ => H.
Instance Inhabitant_Prop : Inhabitant Prop := False.
Instance Inhabitant_bool : Inhabitant bool := false.
Instance Inhabitant_pair {T1 T2 : Type} {x1: Inhabitant T1} {x2: Inhabitant T2} : Inhabitant (T1*T2)%type := (x1,x2).

Lemma Zlength_length:
  forall A (al: list A) (n: Z),
    0 <= n ->
    (Zlength al = n <-> length al = Z.to_nat n).

Lemma firstn_app1: forall {A} n (p l: list A),
  (n <= Datatypes.length p)%nat ->

Lemma firstn_app2: forall {A} (n: nat) (al bl: list A),
 (n >= length al)%nat ->
 firstn n (al++bl) = al ++ firstn (n - length al) bl.

Lemma firstn_list_repeat {A} (v:A): forall i k, (i<=k)%nat ->
      firstn i (list_repeat k v) = list_repeat i v.

Lemma firstn_app:
 forall {A} n m (al: list A), firstn n al ++ firstn m (skipn n al) =
  firstn (n+m) al.

Lemma nth_skipn:
  forall {A} i n data (d:A),
       nth i (skipn n data) d = nth (i+n) data d.

Lemma skipn_skipn: forall {A} n m (xs: list A),
  skipn n (skipn m xs) = skipn (m + n) xs.

Lemma firstn_exact_length: forall {A} (xs: list A), firstn (length xs) xs = xs.

Lemma skipn_exact_length: forall {A} (xs: list A), skipn (length xs) xs = nil.

Lemma len_le_1_rev: forall {A} (contents: list A),
  (length contents <= 1)%nat ->
  contents = rev contents.

Lemma firstn_firstn: forall {A} (contents: list A) n m,
  (n <= m)%nat ->
  firstn n (firstn m contents) = firstn n contents.

Lemma firstn_1_skipn: forall {A} n (ct: list A) d,
  (n < length ct)%nat ->
  nth n ct d :: nil = firstn 1 (skipn n ct).

Lemma skipn_length: forall {A} (contents: list A) n,
  length (skipn n contents) = (length contents - n)%nat.

Lemma nth_firstn: forall {A} (contents: list A) n m d,
  (n < m)%nat ->
  nth n (firstn m contents) d = nth n contents d.

Lemma skipn_length_short:
  forall {A} n (al: list A),
    (length al <= n)%nat ->
    (length (skipn n al) = 0)%nat.

Lemma skipn_short:
   forall {A} n (al: list A), (n >= length al)%nat -> skipn n al = nil.

Lemma nth_map':
  forall {A B} (f: A -> B) d d' i al,
  (i < length al)%nat ->
   nth i (map f al) d = f (nth i al d').

Lemma skipn_nil: forall A n, skipn n (@nil A) = nil.

Lemma skipn_drop:
 forall A n m (al: list A), skipn n (skipn m al) = skipn (n+m) al.

Lemma skipn_app1:
 forall A n (al bl: list A),
  (n <= length al)%nat ->
  skipn n (al++bl) = skipn n al ++ bl.

Lemma skipn_app2:
 forall A n (al bl: list A),
  (n >= length al)%nat ->
  skipn n (al++bl) = skipn (n-length al) bl.

Lemma list_repeat_app: forall A a b (x:A),
  list_repeat a x ++ list_repeat b x = list_repeat (a+b) x.

Lemma firstn_same:
  forall A n (b: list A), (n >= length b)%nat -> firstn n b = b.

Lemma nth_firstn_low:
 forall A i n al (d: A),
  (i < n <= length al)%nat -> nth i (firstn n al) d = nth i al d.

Lemma nth_error_nth:
  forall A (d: A) i al, (i < length al)%nat -> nth_error al i = Some (nth i al d).

Lemma skipn_rev:
  forall {A} n (vl: list A),
   skipn n (rev vl) = rev (firstn (length vl - n) vl).

Lemma Forall_list_repeat:
  forall {A} (P: A -> Prop) (n: nat) (a: A),
    P a -> Forall P (list_repeat n a).

Lemma skipn_firstn: forall {A} n m (xs: list A),
  skipn n (firstn m xs) = firstn (m-n) (skipn n xs).

Lemma rev_skipn:
 forall {A} n (vl: list A),
  rev (skipn n vl) = firstn (length vl -n) (rev vl).

Lemma firstn_skipn_rev:
  forall {A} lo n (vl: list A),
  (n+lo <= length vl)%nat ->
  firstn n (skipn lo (rev vl)) =
  rev (firstn n (skipn (length vl - (lo+n))%nat vl)).

Lemma map_firstn:
  forall A B (F: A -> B) n (al: list A),
  map F (firstn n al) = firstn n (map F al).

Lemma map_skipn:
  forall A B (F: A -> B) n (al: list A),
  map F (skipn n al) = skipn n (map F al).

Lemma Zlength_app: forall T (al bl: list T),
    Zlength (al++bl) = Zlength al + Zlength bl.

Lemma Zlength_rev: forall T (vl: list T), Zlength (rev vl) = Zlength vl.

Lemma Zlength_map: forall A B (f: A -> B) l, Zlength (map f l) = Zlength l.

Lemma ZtoNat_Zlength:
 forall {A} (l: list A), Z.to_nat (Zlength l) = length l.
Hint Rewrite @ZtoNat_Zlength : norm.

Lemma Zlength_nonneg:
 forall {A} (l: list A), 0 <= Zlength l.

Definition Zlength' := @Zlength.

Ltac pose_Zlength_nonneg1 T A :=
     lazymatch goal with
      | H:  0 <= @Zlength T A |- _ => idtac
      | H:  0 <= @Zlength T A /\ _ |- _ => idtac
      | |- _ => pose proof (@Zlength_nonneg T A)
     end;
     
     let x := fresh "x" in set (x:= @Zlength T A) in *;
     let y := fresh "y" in set (y := @Zlength) in x;
     fold @Zlength' in y; subst y; subst x.

Ltac pose_Zlength_nonneg :=
 repeat
  match goal with
  | |- context [@Zlength ?T ?A] => pose_Zlength_nonneg1 T A
  | H: context [@Zlength ?T ?A] |- _ => pose_Zlength_nonneg1 T A
 end;
  unfold Zlength' in *.

Ltac list_solve := autorewrite with sublist; pose_Zlength_nonneg; omega.

Definition Znth {X}{d: Inhabitant X} n (xs: list X) :=
  if (zlt n 0) then default else nth (Z.to_nat n) xs d.

Lemma Znth_map:
  forall {A:Type} {da: Inhabitant A}{B:Type}{db: Inhabitant B} i (f: A -> B) (al: list A),
  0 <= i < Zlength al ->
  Znth i (map f al)  = f (Znth i al).

Hint Rewrite 
   (@Znth_map Z _) (@Znth_map nat _) (@Znth_map positive _)
    using (auto; rewrite ?Zlength_map in *; omega) : sublist.

Lemma Znth_succ: forall {A}{a: Inhabitant A} i lo (v: list A), Z.succ lo <= i -> Znth (i - lo) v = Znth (i - (Z.succ lo)) (skipn 1 v).

Lemma Znth_0_cons {A}{a: Inhabitant A} l (v:A): Znth 0 (v::l) = v.
Hint Rewrite @Znth_0_cons : sublist.

Lemma Znth_pos_cons {A}{a: Inhabitant A} i l (v:A): 0<i -> Znth i (v::l) = Znth (i-1) l.

Lemma Znth_In : forall {A}{a: Inhabitant A} i l, 0 <= i < Zlength l -> In (Znth i l) l.

Lemma split3_full_length_list: forall {A}{a: Inhabitant A} lo mid hi (ct: list A),
  lo <= mid < hi ->
  Zlength ct = hi - lo ->
  ct = firstn (Z.to_nat (mid - lo)) ct ++

Lemma Forall_Znth:
 forall {A}{a: Inhabitant A} (F: A -> Prop) (al: list A) i,
   0 <= i < Zlength al ->
   Forall F al ->
   F (Znth i al).

Hint Rewrite @app_nil_l @app_nil_r : sublist.

Lemma app_Znth1:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i < Zlength l -> Znth i (l++l') = Znth i l.

Lemma app_Znth2:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i >= Zlength l -> Znth i (l++l') = Znth (i-Zlength l) l'.

Lemma Znth_firstn:
  forall {A}{a: Inhabitant A} (al: list A) (n m : Z),
  n<m -> Znth n (firstn (Z.to_nat m) al) = Znth n al.

Lemma Znth_skipn: forall {A}{a: Inhabitant A}  i n xs,
  0 <= i ->
  0 <= n ->
  Znth i (skipn (nat_of_Z n) xs) = Znth (i+n) xs.

Lemma Z2Nat_neg: forall i, i < 0 -> Z.to_nat i = 0%nat.

Lemma Zlength_firstn:
  forall {A} n (v: list A), Zlength (firstn (Z.to_nat n) v) = Z.min (Z.max 0 n) (Zlength v).

Lemma Zlength_skipn:
  forall {A} n (v: list A),
  Zlength (skipn (Z.to_nat n) v) = Z.max 0 (Zlength v - (Z.max 0n)).

Lemma Znth_cons:
 forall {A}(a: Inhabitant A)  i (al: list A) bl,
  0 <= i < Zlength al  ->
  Znth i al :: bl = firstn (Z.to_nat 1) (skipn (Z.to_nat i) al) ++ bl.

Lemma Zfirstn_app1:
 forall A n (al bl: list A),
  n <= Zlength al -> firstn (Z.to_nat n) (al++bl) = firstn (Z.to_nat n) al.

Lemma Zfirstn_same:
  forall A n (b: list A), n >= Zlength b -> firstn (Z.to_nat n) b = b.

Lemma Zfirstn_app2: forall {A} n (al bl: list A),
 n >= Zlength al ->
 firstn (Z.to_nat n) (al++bl) = al ++ firstn (Z.to_nat (n - Zlength al)) bl.

Lemma Zfirstn_firstn: forall {A} (contents: list A) n m,
  n <= m ->
  firstn (Z.to_nat n) (firstn (Z.to_nat m) contents) = firstn (Z.to_nat n) contents.
Lemma Zskipn_app1:
 forall A n (al bl: list A),
  n <= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat n) al ++ bl.

Lemma Zskipn_app2:
 forall A n (al bl: list A),
  n >= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat (n-Zlength al)) bl.

Lemma Znth_rev:
  forall {A}{d: Inhabitant A} i (al:list A),
  0 <= i < Zlength al ->
  Znth i (rev al) = Znth (Zlength al - i - 1) al.

Lemma Zskipn_firstn: forall {A} n m (xs: list A),
 0 <= n ->
 skipn (Z.to_nat n) (firstn (Z.to_nat m) xs) =

Lemma Zskipn_skipn: forall {A} n m (xs: list A),
  0 <= n -> 0 <= m ->
  skipn (Z.to_nat n) (skipn (Z.to_nat m) xs) = skipn (Z.to_nat (m + n)) xs.

Lemma Zfirstn_app:
 forall {A} n m (al: list A),
  0 <= n -> 0 <= m ->
  firstn (Z.to_nat n) al ++ firstn (Z.to_nat m) (skipn (Z.to_nat n) al) =

Lemma Zfirstn_exact_length:
  forall {A} n (al: list A),
  n = Zlength al ->
  firstn (Z.to_nat n) al = al.

Definition sublist {A} (lo hi: Z) (al: list A) : list A :=
  firstn (Z.to_nat (hi-lo)) (skipn (Z.to_nat lo) al).

Definition upd_Znth {A} (i: Z) (al: list A) (x: A): list A :=
   sublist 0 i al ++ x :: sublist (i+1) (Zlength al) al.

Lemma sublist_sublist {A} i j k m (l:list A): 0<=m -> 0<=k <=i -> i <= j-m ->
  sublist k i (sublist m j l) = sublist (k+m) (i+m) l.

Lemma sublist_rejoin:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid hi al = sublist lo hi al.

Lemma sublist_map:
  forall {A B} (F: A -> B) lo hi (al: list A),
  sublist lo hi (map F al) = map F (sublist lo hi al).

Lemma map_sublist:
  forall {A B} (F: A -> B) lo hi (al: list A),
  map F (sublist lo hi al) = sublist lo hi (map F al).

Lemma sublist_len_1:
  forall {A}{d: Inhabitant A} i (al: list A),
  0 <= i < Zlength al ->
  sublist i (i+1) al = Znth i al :: nil.

Lemma Znth_cons_sublist:
  forall {A}{d: Inhabitant A} i (al: list A) bl,
  0 <= i < Zlength al ->
  Znth i al :: bl = sublist i (i+1) al ++ bl.

Lemma Zlength_sublist:
  forall {A} lo hi (al: list A),
 0 <= lo <= hi -> hi <= Zlength al ->
 Zlength (sublist lo hi al) = hi-lo.

Lemma sublist_same_gen:
forall {A} lo hi (al: list A),
  lo = 0 -> hi >= Zlength al ->
  sublist lo hi al = al.

Lemma sublist_same:
forall {A} lo hi (al: list A),
  lo = 0 -> hi = Zlength al ->
  sublist lo hi al = al.

Lemma Znth_sublist:
  forall {A}{d: Inhabitant A} lo i hi (al: list A),
 0 <= lo ->
 0 <= i < hi-lo ->
 Znth i (sublist lo hi al) = Znth (i+lo) al.

Lemma rev_sublist:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  rev (sublist lo hi al) = sublist (Zlength al - hi) (Zlength al - lo) (rev al).

Lemma sublist_nil:
  forall {A} lo (al: list A),
  sublist lo lo al = nil.

Lemma sublist_nil_gen : forall {A} (l : list A) i j, j <= i -> sublist i j l = [].

Lemma sublist_rev:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  sublist lo hi (rev al) = rev (sublist (Zlength al - hi) (Zlength al - lo) al).

Lemma sublist_app:
  forall {A} lo hi (al bl: list A),
  0 <= lo <= hi -> hi <= Zlength al + Zlength bl ->
  sublist lo hi (al++bl) =
  sublist (Z.min lo (Zlength al)) (Z.min hi (Zlength al)) al ++

Lemma sublist_split:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo hi al = sublist lo mid al ++ sublist mid hi al.

Lemma sublist_last_1 : forall {A}{d: Inhabitant A} lo hi (al : list A), 0 <= lo <= hi -> hi + 1 <= Zlength al ->
  sublist lo (hi + 1) al = sublist lo hi al ++ [Znth hi al].

Lemma Zlen_le_1_rev:
 forall {A} (al: list A),
  Zlength al <= 1 -> rev al = al.

Lemma skipn_0:
  forall A (l: list A), skipn 0 l = l.

Lemma sublist_1_cons {A} l (v:A) n: sublist 1 n (v::l) = sublist 0 (n-1) l.

Lemma sublist_nil': forall (A : Type) (lo lo': Z) (al : list A), lo=lo' -> sublist lo lo' al = [].

Lemma sublist_skip {A} (l:list A) i : 0<=i ->  sublist i (Zlength l) l = skipn (Z.to_nat i) l.

Lemma sublist_firstn {A} (l:list A) i: sublist 0 i l = firstn (Z.to_nat i) l.

Lemma sublist_app1:
  forall (A : Type) (k i : Z) (al bl : list A),
  0 <= k <= i -> i <= Zlength al -> sublist k i (al ++ bl) = sublist k i al.

Lemma sublist0_app1 {A} i (al bl:list A): 0<= i <= Zlength al ->
  sublist 0 i (al ++ bl) = sublist 0 i al.

Lemma sublist_app2 {A} i j (al bl:list A): 0<=Zlength al <= i->
  sublist i j (al ++ bl) = sublist (i-Zlength al) (j-Zlength al) bl.

Lemma sublist_sublist0 {A} i j k (l:list A): 0<=k -> k<=i<=j ->
  sublist k i (sublist 0 j l) = sublist k i l.

Lemma sublist_sublist00 {A} i j (l:list A): 0<=i<=j ->
  sublist 0 i (sublist 0 j l) = sublist 0 i l.

Lemma skipn_list_repeat:
   forall A k n (a: A),
     (k <= n)%nat -> skipn k (list_repeat n a) = list_repeat (n-k) a.

Lemma sublist_list_repeat {A} i j k (v:A) (I: 0<=i)
          (IJK: i <= j <= k):
      sublist i j (list_repeat (Z.to_nat k) v) = list_repeat (Z.to_nat (j-i)) v.

Lemma Zlength_list_repeat:
  forall {A} n (x: A),
  0 <= n ->
  Zlength (list_repeat (Z.to_nat n) x) = n.

Lemma list_repeat_0:
  forall {A} (x:A), list_repeat (Z.to_nat 0) x = nil.

Lemma Znth_list_repeat_inrange:
  forall {A}{d: Inhabitant A} i n (a: A),
   (0 <= i < n)%Z ->
   Znth i (list_repeat (Z.to_nat n) a) = a.

Lemma firstn_nil {A} n: firstn n (nil:list A) = nil.

Lemma firstn_In {A} (x:A): forall l n, In x (firstn n l) -> In x l.
Lemma skipn_In {A} (x:A): forall l n, In x (skipn n l) -> In x l.

Lemma sublist_In {A} lo hi data (x:A) (I:In x (sublist lo hi data)): In x data.

Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Lemma sublist0_app2 {A : Type} i (al bl : list A):
  Zlength al <= i <= Zlength al + Zlength bl ->
  sublist 0 i (al ++ bl) = al ++ sublist 0 (i - Zlength al) bl.

Lemma sublist_rejoin':
  forall {A} lo mid mid' hi (al: list A),
  mid=mid' ->
  0 <= lo <= mid ->
  mid' <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid' hi al = sublist lo hi al.

Hint Rewrite @sublist_nil' using list_solve: sublist.
Hint Rewrite @app_nil_l : sublist.
Hint Rewrite @Zlength_rev : sublist.
Hint Rewrite @sublist_rejoin' using list_solve : sublist.

Lemma subsub1:
 forall a b : Z, (a-(a-b)) = b.
Hint Rewrite subsub1 : sublist.

Lemma sublist_app':
  forall {A} lo hi (al bl: list A),
  0 <= lo <= Zlength al ->
  0 <= hi-Zlength al <= Zlength bl ->
  sublist lo hi (al++bl) =
  sublist lo (Zlength al) al ++
  sublist 0 (hi-Zlength al) bl.

Lemma upd_Znth_Zlength {A} i (l:list A) v: 0<=i < Zlength l ->
      Zlength (upd_Znth i l v) = Zlength l.

Lemma upd_Znth_map {A B} (f:A -> B) i l v:
      upd_Znth i (map f l) (f v) =
      map f (upd_Znth i l v).

Lemma upd_Znth_lookup K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i j (v:A) (I: 0<=i<K) (J: 0<=j<K),
   (i=j /\ Znth i (upd_Znth j l v) = v) \/
   (i<>j /\ Znth i (upd_Znth j l v) = Znth i l).

Lemma upd_Znth_lookup' K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i (I: 0<=i<K) j (J: 0<=j<K) (v:A),
    Znth i (upd_Znth j l v) = if zeq i j then v else Znth i l.

Lemma upd_Znth_char {A} n l1 (v:A) l2 w: Zlength l1=n ->
      upd_Znth n (l1 ++ v :: l2) w = l1 ++ w :: l2.

Lemma upd_Znth_same {A}{d: Inhabitant A}: forall i l u, 0<= i< Zlength l -> Znth i (upd_Znth i l u) = u.

Lemma upd_Znth_diff {A}{d: Inhabitant A}: forall i j l u, 0<= i< Zlength l -> 0<= j< Zlength l -> i<>j ->
      Znth i (upd_Znth j l u) = Znth i l.

Lemma upd_Znth_app1 {A} i l1 l2 (I: 0 <= i < Zlength l1) (v:A):
      upd_Znth i (l1++l2) v = upd_Znth i l1 v ++ l2.

Lemma upd_Znth_app2 {A} (l1 l2:list A) i v:
  Zlength l1 <= i <= Zlength l1 + Zlength l2 ->
  upd_Znth i (l1 ++ l2) v = l1 ++ upd_Znth (i-Zlength l1) l2 v.

Lemma upd_Znth0 {A} (l:list A) v:
upd_Znth 0 l v = v :: sublist 1 (Zlength l) l.

Lemma sublist_upd_Znth_l: forall {A} (l: list A) i lo hi v,
  0 <= lo <= hi ->
  hi <= i < Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_r: forall {A} (l: list A) i lo hi v,
  0 <= i < lo ->
  lo <= hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_lr: forall {A} (l: list A) i lo hi v,
  0 <= lo <= i->
  i < hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = upd_Znth (i - lo) (sublist lo hi l) v.

Hint Rewrite @Znth_list_repeat_inrange : sublist.
Hint Rewrite @Zlength_cons @Zlength_nil: sublist.
Hint Rewrite @list_repeat_0: sublist.
Hint Rewrite <- @app_nil_end : sublist.
Hint Rewrite @Zlength_app: sublist.
Hint Rewrite @Zlength_map: sublist.
Hint Rewrite @Zlength_list_repeat using list_solve: sublist.
Hint Rewrite Z.sub_0_r Z.add_0_l Z.add_0_r : sublist.
Hint Rewrite @Zlength_sublist using list_solve: sublist.
Hint Rewrite Z.max_r Z.max_l using omega : sublist.
Hint Rewrite Z.min_r Z.min_l using omega : sublist.
Hint Rewrite Z.add_simpl_r Z.sub_add Z.sub_diag : sublist.
Hint Rewrite @sublist_sublist using list_solve : sublist.
Hint Rewrite @sublist_app1 using list_solve : sublist.
Hint Rewrite @sublist_app2 using list_solve : sublist.
Hint Rewrite @sublist_list_repeat  using list_solve : sublist.
Hint Rewrite @sublist_same using list_solve : sublist.
Hint Rewrite Z.add_simpl_l : sublist.
Hint Rewrite Z.add_add_simpl_l_l Z.add_add_simpl_l_r
     Z.add_add_simpl_r_l Z.add_add_simpl_r_r : sublist.
Hint Rewrite Z.add_0_r : sublist.
Hint Rewrite @app_Znth1 using list_solve : sublist.
Hint Rewrite @app_Znth2 using list_solve : sublist.
Hint Rewrite @Znth_sublist using list_solve : sublist.
Hint Rewrite @upd_Znth_Zlength using list_solve : sublist.

Hint Rewrite @sublist_nil : sublist.

Lemma list_repeat_app':
 forall {A: Type} a b (x:A), 
    0 <= a -> 0 <= b ->
    list_repeat (Z.to_nat a) x ++ list_repeat (Z.to_nat b) x = list_repeat (Z.to_nat (a+b)) x.

Lemma Znth_overflow:
  forall {A}{d: Inhabitant A} i (al: list A), i >= Zlength al -> Znth i al = d.

Lemma Znth_underflow:
  forall {A}{d: Inhabitant A} i (al: list A),  i < 0 -> Znth i al = d.

Lemma Znth_outofbounds:
  forall {A}{d: Inhabitant A} i (al: list A),  (i < 0 \/ i >= Zlength al) -> Znth i al = d.

Lemma sublist_one:
  forall {A}{d: Inhabitant A} lo hi (al: list A),
    0 <= lo -> hi <= Zlength al ->
    lo+1=hi -> sublist lo hi al = Znth lo al :: nil.

Lemma Forall_app :
forall {A} P (l1 l2 :list A),
Forall P (l1 ++ l2) <->
Forall P l1 /\ Forall P l2.

Lemma Forall_firstn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (firstn n l).

Lemma Forall_skipn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (skipn n l).

Lemma Forall_map:
  forall {A B} (f: B -> Prop) (g: A -> B) al,
   Forall f (map g al) <-> Forall (Basics.compose f g) al.

Lemma Forall_sublist:
  forall {A} (f: A -> Prop) lo hi al,
   Forall f al -> Forall f (sublist lo hi al).

Hint Rewrite @upd_Znth_app1 using list_solve : sublist.
Hint Rewrite @upd_Znth_app2 using list_solve : sublist.

Lemma map_list_repeat: forall {A B} (f: A->B) n (x:A), map f (list_repeat n x) = list_repeat n (f x).
Hint Rewrite @map_list_repeat : sublist.

Lemma Zlength_sublist_correct: forall {A} (l: list A) (lo hi: Z),
  0 <= lo <= hi ->
  hi <= Zlength l ->
  Zlength (sublist lo hi l) = hi - lo.

Lemma Zlength_sublist_incorrect: forall {A} (l: list A) (lo hi: Z),
  0 <= lo < hi ->
  hi > Zlength l ->
  Zlength (sublist lo hi l) < hi - lo.

Lemma nth_Znth {A} {d: Inhabitant A}:
forall n (xs:list A), 0 <= n < Zlength xs -> (nth (Z.to_nat n) xs d) = (Znth n xs). *)

Require Import atomics.hashtable_atomic_ra.
(* atomics.hashtable_atomic_ra:
From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats AST Ctypes Cop Clight Clightdefs.
Local Open Scope Z_scope.

Definition _CAS_RA : ident := 67%positive.
Definition ___builtin_annot : ident := 12%positive.
Definition ___builtin_annot_intval : ident := 13%positive.
Definition ___builtin_bswap : ident := 6%positive.
Definition ___builtin_bswap16 : ident := 8%positive.
Definition ___builtin_bswap32 : ident := 7%positive.
Definition ___builtin_bswap64 : ident := 38%positive.
Definition ___builtin_clz : ident := 39%positive.
Definition ___builtin_clzl : ident := 40%positive.
Definition ___builtin_clzll : ident := 41%positive.
Definition ___builtin_ctz : ident := 42%positive.
Definition ___builtin_ctzl : ident := 43%positive.
Definition ___builtin_ctzll : ident := 44%positive.
Definition ___builtin_debug : ident := 56%positive.
Definition ___builtin_fabs : ident := 9%positive.
Definition ___builtin_fmadd : ident := 47%positive.
Definition ___builtin_fmax : ident := 45%positive.
Definition ___builtin_fmin : ident := 46%positive.
Definition ___builtin_fmsub : ident := 48%positive.
Definition ___builtin_fnmadd : ident := 49%positive.
Definition ___builtin_fnmsub : ident := 50%positive.
Definition ___builtin_fsqrt : ident := 10%positive.
Definition ___builtin_membar : ident := 14%positive.
Definition ___builtin_memcpy_aligned : ident := 11%positive.
Definition ___builtin_nop : ident := 55%positive.
Definition ___builtin_read16_reversed : ident := 51%positive.
Definition ___builtin_read32_reversed : ident := 52%positive.
Definition ___builtin_va_arg : ident := 16%positive.
Definition ___builtin_va_copy : ident := 17%positive.
Definition ___builtin_va_end : ident := 18%positive.
Definition ___builtin_va_start : ident := 15%positive.
Definition ___builtin_write16_reversed : ident := 53%positive.
Definition ___builtin_write32_reversed : ident := 54%positive.
Definition ___compcert_i64_dtos : ident := 23%positive.
Definition ___compcert_i64_dtou : ident := 24%positive.
Definition ___compcert_i64_sar : ident := 35%positive.
Definition ___compcert_i64_sdiv : ident := 29%positive.
Definition ___compcert_i64_shl : ident := 33%positive.
Definition ___compcert_i64_shr : ident := 34%positive.
Definition ___compcert_i64_smod : ident := 31%positive.
Definition ___compcert_i64_smulh : ident := 36%positive.
Definition ___compcert_i64_stod : ident := 25%positive.
Definition ___compcert_i64_stof : ident := 27%positive.
Definition ___compcert_i64_udiv : ident := 30%positive.
Definition ___compcert_i64_umod : ident := 32%positive.
Definition ___compcert_i64_umulh : ident := 37%positive.
Definition ___compcert_i64_utod : ident := 26%positive.
Definition ___compcert_i64_utof : ident := 28%positive.
Definition ___compcert_va_composite : ident := 22%positive.
Definition ___compcert_va_float64 : ident := 21%positive.
Definition ___compcert_va_int32 : ident := 19%positive.
Definition ___compcert_va_int64 : ident := 20%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 61%positive.
Definition _add_item : ident := 81%positive.
Definition _arg : ident := 83%positive.
Definition _entry : ident := 5%positive.
Definition _exit : ident := 57%positive.
Definition _f : ident := 89%positive.
Definition _free : ident := 58%positive.
Definition _freelock2 : ident := 62%positive.
Definition _get_item : ident := 80%positive.
Definition _i : ident := 74%positive.
Definition _i__1 : ident := 90%positive.
Definition _i__2 : ident := 91%positive.
Definition _i__3 : ident := 93%positive.
Definition _idx : ident := 76%positive.
Definition _init_table : ident := 82%positive.
Definition _integer_hash : ident := 75%positive.
Definition _key : ident := 3%positive.
Definition _keys : ident := 94%positive.
Definition _l : ident := 85%positive.
Definition _l__1 : ident := 92%positive.
Definition _load_acq : ident := 65%positive.
Definition _lock_t : ident := 2%positive.
Definition _m_entries : ident := 68%positive.
Definition _main : ident := 96%positive.
Definition _makelock : ident := 60%positive.
Definition _malloc : ident := 59%positive.
Definition _n : ident := 71%positive.
Definition _p : ident := 72%positive.
Definition _probed_key : ident := 77%positive.
Definition _r : ident := 88%positive.
Definition _release2 : ident := 63%positive.
Definition _res : ident := 86%positive.
Definition _result : ident := 78%positive.
Definition _results : ident := 70%positive.
Definition _set_item : ident := 79%positive.
Definition _spawn : ident := 64%positive.
Definition _store_rel : ident := 66%positive.
Definition _surely_malloc : ident := 73%positive.
Definition _t : ident := 84%positive.
Definition _thread_locks : ident := 69%positive.
Definition _total : ident := 87%positive.
Definition _value : ident := 4%positive.
Definition _values : ident := 95%positive.
Definition _t'1 : ident := 97%positive.
Definition _t'2 : ident := 98%positive.
Definition _t'3 : ident := 99%positive.
Definition _t'4 : ident := 100%positive.
Definition _t'5 : ident := 101%positive.

Definition v_m_entries := {|
  gvar_info := (tarray (Tstruct _entry noattr) 16384);
  gvar_init := (Init_space 131072 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_thread_locks := {|
  gvar_info := (tarray (tptr (Tstruct _lock_t noattr)) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_results := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_surely_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
      ((Etempvar _n tuint) :: nil))
    (Sset _p (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
      (Scall None (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
        ((Econst_int (Int.repr 1) tint) :: nil))
      Sskip)
    (Sreturn (Some (Etempvar _p (tptr tvoid))))))
|}.

Definition f_integer_hash := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_i, tint) :: nil);
  fn_vars := nil;
  fn_temps := nil;
  fn_body :=
(Sreturn (Some (Ebinop Omul (Ecast (Etempvar _i tint) tuint)
                 (Ecast (Econst_int (Int.repr 654435761) tint) tuint) tuint)))
|}.

Definition f_set_item := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_result, tint) :: (_t'4, tint) :: (_t'3, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint
                                  cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                 (Econst_int (Int.repr 0) tint) tint)
                    Scontinue
                    Sskip)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'3)
                        (Evar _CAS_RA (Tfunction
                                        (Tcons (tptr tint)
                                          (Tcons tint (Tcons tint Tnil)))
                                        tint cc_default))
                        ((Etempvar _i (tptr tint)) ::
                         (Econst_int (Int.repr 0) tint) ::
                         (Etempvar _key tint) :: nil))
                      (Sset _result (Etempvar _t'3 tint)))
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_acq (Tfunction
                                              (Tcons (tptr tint) Tnil) tint
                                              cc_default))
                            ((Etempvar _i (tptr tint)) :: nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          Scontinue
                          Sskip))
                      Sskip)))
                Sskip)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint)))
                (Ssequence
                  (Scall None
                    (Evar _store_rel (Tfunction
                                       (Tcons (tptr tint) (Tcons tint Tnil))
                                       tvoid cc_default))
                    ((Etempvar _i (tptr tint)) :: (Etempvar _value tint) ::
                     nil))
                  (Sreturn None))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_get_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint
                                  cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sset _i
                    (Efield
                      (Ederef
                        (Ebinop Oadd
                          (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                          (Etempvar _idx tint)
                          (tptr (Tstruct _entry noattr)))
                        (Tstruct _entry noattr)) _value (tptr tint)))
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil)
                                        tint cc_default))
                      ((Etempvar _i (tptr tint)) :: nil))
                    (Sreturn (Some (Etempvar _t'3 tint)))))
                Sskip)
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Econst_int (Int.repr 0) tint) tint)
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))
                Sskip))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_add_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_result, tint) :: (_t'5, tint) :: (_t'4, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint
                                  cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                 (Econst_int (Int.repr 0) tint) tint)
                    Scontinue
                    Sskip)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'3)
                        (Evar _CAS_RA (Tfunction
                                        (Tcons (tptr tint)
                                          (Tcons tint (Tcons tint Tnil)))
                                        tint cc_default))
                        ((Etempvar _i (tptr tint)) ::
                         (Econst_int (Int.repr 0) tint) ::
                         (Etempvar _key tint) :: nil))
                      (Sset _result (Etempvar _t'3 tint)))
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_acq (Tfunction
                                              (Tcons (tptr tint) Tnil) tint
                                              cc_default))
                            ((Etempvar _i (tptr tint)) :: nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          Scontinue
                          Sskip))
                      Sskip)))
                Sskip)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint)))
                (Ssequence
                  (Scall (Some _t'5)
                    (Evar _CAS_RA (Tfunction
                                    (Tcons (tptr tint)
                                      (Tcons tint (Tcons tint Tnil))) tint
                                    cc_default))
                    ((Etempvar _i (tptr tint)) ::
                     (Econst_int (Int.repr 0) tint) ::
                     (Etempvar _value tint) :: nil))
                  (Sreturn (Some (Etempvar _t'5 tint))))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_init_table := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_p, (tptr tint)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Sset _i (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                     (Econst_int (Int.repr 16384) tint) tint)
        Sskip
        Sbreak)
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                   cc_default))
            ((Esizeof tint tuint) :: nil))
          (Sset _p (Etempvar _t'1 (tptr tvoid))))
        (Ssequence
          (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
            (Econst_int (Int.repr 0) tint))
          (Ssequence
            (Sassign
              (Efield
                (Ederef
                  (Ebinop Oadd
                    (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                    (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                  (Tstruct _entry noattr)) _key (tptr tint))
              (Etempvar _p (tptr tint)))
            (Ssequence
              (Ssequence
                (Scall (Some _t'2)
                  (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                         (tptr tvoid) cc_default))
                  ((Esizeof tint tuint) :: nil))
                (Sset _p (Etempvar _t'2 (tptr tvoid))))
              (Ssequence
                (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
                  (Econst_int (Int.repr 0) tint))
                (Sassign
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint))
                  (Etempvar _p (tptr tint)))))))))
    (Sset _i
      (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_f := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_t, tint) :: (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_res, (tptr tint)) :: (_total, tint) :: (_i, tint) ::
               (_r, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _t (Ederef (Ecast (Etempvar _arg (tptr tvoid)) (tptr tint)) tint))
  (Ssequence
    (Sset _l
      (Ederef
        (Ebinop Oadd
          (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
          (Etempvar _t tint) (tptr (tptr (Tstruct _lock_t noattr))))
        (tptr (Tstruct _lock_t noattr))))
    (Ssequence
      (Sset _res
        (Ederef
          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
            (Etempvar _t tint) (tptr (tptr tint))) (tptr tint)))
      (Ssequence
        (Sset _total (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default)) ((Etempvar _arg (tptr tvoid)) :: nil))
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 3) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'1)
                        (Evar _add_item (Tfunction
                                          (Tcons tint (Tcons tint Tnil)) tint
                                          cc_default))
                        ((Ebinop Oadd (Etempvar _i tint)
                           (Econst_int (Int.repr 1) tint) tint) ::
                         (Econst_int (Int.repr 1) tint) :: nil))
                      (Sset _r (Etempvar _t'1 tint)))
                    (Sifthenelse (Etempvar _r tint)
                      (Sset _total
                        (Ebinop Oadd (Etempvar _total tint)
                          (Econst_int (Int.repr 1) tint) tint))
                      Sskip)))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Sassign (Ederef (Etempvar _res (tptr tint)) tint)
                (Etempvar _total tint))
              (Ssequence
                (Scall None
                  (Evar _release2 (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                    cc_default))
                  ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))))))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_keys, (tarray tint 16384)) ::
              (_values, (tarray tint 16384)) :: nil);
  fn_temps := ((_total, tint) :: (_i, tint) ::
               (_l, (tptr (Tstruct _lock_t noattr))) :: (_i__1, tint) ::
               (_t, (tptr tint)) :: (_i__2, tint) ::
               (_l__1, (tptr (Tstruct _lock_t noattr))) ::
               (_r, (tptr tint)) :: (_i__3, tint) :: (_t'3, (tptr tvoid)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _total (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Scall None (Evar _init_table (Tfunction Tnil tvoid cc_default)) nil)
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof (Tstruct _lock_t noattr) tuint) :: nil))
                  (Sset _l
                    (Ecast (Etempvar _t'1 (tptr tvoid))
                      (tptr (Tstruct _lock_t noattr)))))
                (Ssequence
                  (Sassign
                    (Ederef
                      (Ebinop Oadd
                        (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                        (Etempvar _i tint)
                        (tptr (tptr (Tstruct _lock_t noattr))))
                      (tptr (Tstruct _lock_t noattr)))
                    (Etempvar _l (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                               (tptr tvoid) cc_default))
                        ((Esizeof tint tuint) :: nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
                            (Etempvar _i tint) (tptr (tptr tint)))
                          (tptr tint))
                        (Ecast (Etempvar _t'2 (tptr tvoid)) (tptr tint))))
                    (Scall None
                      (Evar _makelock (Tfunction (Tcons (tptr tvoid) Tnil)
                                        tvoid cc_default))
                      ((Ecast (Etempvar _l (tptr (Tstruct _lock_t noattr)))
                         (tptr tvoid)) :: nil))))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Ssequence
          (Ssequence
            (Sset _i__1 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__1 tint)
                               (Econst_int (Int.repr 3) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                             (tptr tvoid) cc_default))
                      ((Esizeof tint tuint) :: nil))
                    (Sset _t
                      (Ecast (Etempvar _t'3 (tptr tvoid)) (tptr tint))))
                  (Ssequence
                    (Sassign (Ederef (Etempvar _t (tptr tint)) tint)
                      (Etempvar _i__1 tint))
                    (Scall None
                      (Evar _spawn (Tfunction
                                     (Tcons
                                       (tptr (Tfunction
                                               (Tcons (tptr tvoid) Tnil)
                                               (tptr tvoid) cc_default))
                                       (Tcons (tptr tvoid) Tnil)) tvoid
                                     cc_default))
                      ((Ecast
                         (Eaddrof
                           (Evar _f (Tfunction (Tcons (tptr tvoid) Tnil)
                                      (tptr tvoid) cc_default))
                           (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                   (tptr tvoid) cc_default))) (tptr tvoid)) ::
                       (Ecast (Etempvar _t (tptr tint)) (tptr tvoid)) :: nil)))))
              (Sset _i__1
                (Ebinop Oadd (Etempvar _i__1 tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Ssequence
            (Sset _i__2 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__2 tint)
                               (Econst_int (Int.repr 3) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Sset _l__1
                    (Ederef
                      (Ebinop Oadd
                        (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                        (Etempvar _i__2 tint)
                        (tptr (tptr (Tstruct _lock_t noattr))))
                      (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _acquire (Tfunction (Tcons (tptr tvoid) Tnil)
                                       tvoid cc_default))
                      ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                       nil))
                    (Ssequence
                      (Scall None
                        (Evar _freelock2 (Tfunction (Tcons (tptr tvoid) Tnil)
                                           tvoid cc_default))
                        ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                         nil))
                      (Ssequence
                        (Scall None
                          (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil)
                                        tvoid cc_default))
                          ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                           nil))
                        (Ssequence
                          (Sset _r
                            (Ederef
                              (Ebinop Oadd
                                (Evar _results (tarray (tptr tint) 3))
                                (Etempvar _i__2 tint) (tptr (tptr tint)))
                              (tptr tint)))
                          (Ssequence
                            (Sset _i__3
                              (Ederef (Etempvar _r (tptr tint)) tint))
                            (Ssequence
                              (Scall None
                                (Evar _free (Tfunction
                                              (Tcons (tptr tvoid) Tnil) tvoid
                                              cc_default))
                                ((Etempvar _r (tptr tint)) :: nil))
                              (Sset _total
                                (Ebinop Oadd (Etempvar _total tint)
                                  (Etempvar _i__3 tint) tint))))))))))
              (Sset _i__2
                (Ebinop Oadd (Etempvar _i__2 tint)
                  (Econst_int (Int.repr 1) tint) tint))))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _lock_t Struct ((_a, (tarray (tptr tvoid) 2)) :: nil) noattr ::
 Composite _entry Struct
   ((_key, (tptr tint)) :: (_value, (tptr tint)) :: nil)
   noattr :: nil).

Definition global_definitions : list (ident * globdef fundef type) :=
((___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___compcert_i64_dtos,
   Gfun(External (EF_runtime "__compcert_i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___compcert_i64_dtou,
   Gfun(External (EF_runtime "__compcert_i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___compcert_i64_stod,
   Gfun(External (EF_runtime "__compcert_i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___compcert_i64_utod,
   Gfun(External (EF_runtime "__compcert_i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___compcert_i64_stof,
   Gfun(External (EF_runtime "__compcert_i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___compcert_i64_utof,
   Gfun(External (EF_runtime "__compcert_i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___compcert_i64_sdiv,
   Gfun(External (EF_runtime "__compcert_i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_udiv,
   Gfun(External (EF_runtime "__compcert_i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_smod,
   Gfun(External (EF_runtime "__compcert_i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umod,
   Gfun(External (EF_runtime "__compcert_i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_shl,
   Gfun(External (EF_runtime "__compcert_i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_shr,
   Gfun(External (EF_runtime "__compcert_i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___compcert_i64_sar,
   Gfun(External (EF_runtime "__compcert_i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_smulh,
   Gfun(External (EF_runtime "__compcert_i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umulh,
   Gfun(External (EF_runtime "__compcert_i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_exit,
   Gfun(External (EF_external "exit"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons tint Tnil) tvoid cc_default)) ::
 (_free, Gfun(External EF_free (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_malloc,
   Gfun(External EF_malloc (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_makelock,
   Gfun(External (EF_external "makelock"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_acquire,
   Gfun(External (EF_external "acquire"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_freelock2,
   Gfun(External (EF_external "freelock2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_release2,
   Gfun(External (EF_external "release2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_spawn,
   Gfun(External (EF_external "spawn"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons
       (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default))
       (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (_load_acq,
   Gfun(External (EF_external "load_acq"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_rel,
   Gfun(External (EF_external "store_rel"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_CAS_RA,
   Gfun(External (EF_external "CAS_RA"
                   (mksignature (AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     (Some AST.Tint) cc_default))
     (Tcons (tptr tint) (Tcons tint (Tcons tint Tnil))) tint cc_default)) ::
 (_m_entries, Gvar v_m_entries) :: (_thread_locks, Gvar v_thread_locks) ::
 (_results, Gvar v_results) ::
 (_surely_malloc, Gfun(Internal f_surely_malloc)) ::
 (_integer_hash, Gfun(Internal f_integer_hash)) ::
 (_set_item, Gfun(Internal f_set_item)) ::
 (_get_item, Gfun(Internal f_get_item)) ::
 (_add_item, Gfun(Internal f_add_item)) ::
 (_init_table, Gfun(Internal f_init_table)) :: (_f, Gfun(Internal f_f)) ::
 (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _f :: _init_table :: _add_item :: _get_item :: _set_item ::
 _integer_hash :: _surely_malloc :: _results :: _thread_locks ::
 _m_entries :: _CAS_RA :: _store_rel :: _load_acq :: _spawn :: _release2 ::
 _freelock2 :: _acquire :: _makelock :: _malloc :: _free :: _exit ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap64 :: ___compcert_i64_umulh :: ___compcert_i64_smulh ::
 ___compcert_i64_sar :: ___compcert_i64_shr :: ___compcert_i64_shl ::
 ___compcert_i64_umod :: ___compcert_i64_smod :: ___compcert_i64_udiv ::
 ___compcert_i64_sdiv :: ___compcert_i64_utof :: ___compcert_i64_stof ::
 ___compcert_i64_utod :: ___compcert_i64_stod :: ___compcert_i64_dtou ::
 ___compcert_i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fsqrt ::
 ___builtin_fabs :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: nil).

Definition prog : Clight.program := 
  mkprogram composites global_definitions public_idents _main Logic.I. *)

Require Import atomics.hashtable.
(* atomics.hashtable:
Require Import VST.progs.conclib.
Require Import VST.floyd.sublist.

Set Bullet Behavior "Strict Subproofs".

Fixpoint index_of (m : list (Z * Z)) (k : Z) :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of rest k)
  end.

Lemma index_of_spec : forall k m, match index_of m k with
  | Some i => 0 <= i < Zlength m /\ fst (Znth i m) = k /\ Forall (fun x => fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) end.

Class hash_fun := { size : Z; hash : Z -> Z; size_pos : size > 0; hash_range : forall i, 0 <= hash i < size }.

Section Hashtable.

Context {hf : hash_fun}.
Hint Resolve size_pos hash_range.

Definition rebase {A} (m : list A) i := rotate m (Zlength m - i) (Zlength m).

Definition well_chained (m : list (Z * Z)) := forall k i, index_of (rebase m (hash k)) k = Some i ->
  Forall (fun x => fst x <> 0) (sublist 0 i (rebase m (hash k))).

Definition wf_map (m : list (Z * Z)) := NoDup (map fst m).

Definition indices i j := (map (fun x => (i + x) mod size) (upto (Z.to_nat ((j - i) mod size)))).

Fixpoint index_of' (m : list (Z * Z)) k :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 0 then Some 0 else
                        if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of' rest k)
  end.

Definition lookup (m : list (Z * Z)) (k : Z) :=
  option_map (fun i => (i + hash k) mod size) (index_of' (rebase m (hash k)) k).

Definition set m k v := option_map (fun i => upd_Znth i m (k, v)) (lookup m k).

Definition get m k := match lookup m k with Some i => let '(k', v') := Znth i m in
  if eq_dec k' 0 then None else Some v' | None => None end.

Lemma rebase_0 : forall {A} {d : Inhabitant A} (m : list A) i, 0 <= i < Zlength m -> Znth 0 (rebase m i) = Znth i m.

Lemma index_of'_spec : forall k m, match index_of' m k with
  | Some i => 0 <= i < Zlength m /\ (fst (Znth i m) = k \/ fst (Znth i m) = 0) /\
              Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) /\ ~In 0 (map fst m)
  end.

Lemma Znth_rebase : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth i (rebase m j) = Znth ((i + j) mod Zlength m) m.

Corollary Znth_rebase' : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth ((i - j) mod Zlength m) (rebase m j) = Znth i m.

Lemma index_of'_upd : forall m k v i (Hrange : 0 <= i < Zlength m)
  (Hi : fst (Znth i m) = k \/ fst (Znth i m) = 0),
  index_of' (upd_Znth i m (k, v)) k = index_of' m k.

Lemma Zlength_rebase : forall {A} (m : list A) i, 0 <= i < Zlength m -> Zlength (rebase m i) = Zlength m.

Lemma rebase_upd : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth i m x) j = upd_Znth ((i - j) mod Zlength m) (rebase m j) x.

Corollary rebase_upd' : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth ((i + j) mod Zlength m) m x) j = upd_Znth i (rebase m j) x.

Lemma lookup_set : forall m k v m', set m k v = Some m' -> Zlength m = size -> lookup m' k = lookup m k.

Lemma lookup_range : forall m k i, lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m.

Lemma index_of'_upd2 : forall m k i k' v' (Hrange : 0 <= i < Zlength m)
  (Hi : index_of' m k <> Some i) (Hdiff : k' <> k /\ k' <> 0),
  index_of' (upd_Znth i m (k', v')) k = index_of' m k.

Lemma lookup_upd_same : forall m k i v', lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  lookup (upd_Znth i m (k, v')) k = lookup m k.

Lemma lookup_upd_diff : forall m k i k' v', lookup m k <> Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  k' <> k /\ k' <> 0 ->
  lookup (upd_Znth i m (k', v')) k = lookup m k.

Lemma Zlength_set : forall m k v m', set m k v = Some m' -> Zlength m = size ->
  Zlength m' = size.

Lemma get_set_same : forall m k v m', set m k v = Some m' -> Zlength m = size -> k <> 0 ->
  get m' k = Some v.

Lemma get_override : forall m k v m' v', set m k v = Some m' -> Zlength m = size -> set m' k v' = set m k v'.

Lemma index_of_app : forall k m1 m2, index_of (m1 ++ m2) k =
  match index_of m1 k with Some i => Some i | None => option_map (Z.add (Zlength m1)) (index_of m2 k) end.

Lemma index_of_out : forall k m, Forall (fun x => fst x <> k) m -> index_of m k = None.

Lemma index_of_sublist : forall m a b i k (HNoDup : NoDup (map fst m))
  (Hi : index_of (sublist a b m) k = Some i) (Ha : 0 <= a) (Hb : b <= Zlength m),
  index_of m k = Some (i + a).

Lemma index_of_rotate : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rotate m n (Zlength m)) k = option_map (fun i => (i + n) mod Zlength m) (index_of m k).

Corollary index_of_rebase : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rebase m n) k = option_map (fun i => (i - n) mod Zlength m) (index_of m k).

Lemma index_of'_succeeds : forall k m i (Hi : 0 <= i < Zlength m)
  (Hnz : Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m))
  (Hk : fst (Znth i m) = k \/ fst (Znth i m) = 0), index_of' m k = Some i.

Lemma lookup_spec : forall m k (Hwf : wf_map m) (Hchain : well_chained m) (Hlen : Zlength m = size)
  (Hnz : k <> 0) (Hin : In k (map fst m)), lookup m k = index_of m k.

End Hashtable.

Lemma sepcon_rebase : forall l m, 0 <= m <= Zlength l ->
  fold_right sepcon emp l = fold_right sepcon emp (rebase l m).

Lemma rebase_map : forall {A B} (f : A -> B) l m, rebase (map f l) m = map f (rebase l m). *)



Set Bullet Behavior "Strict Subproofs".



Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.



Definition makelock_spec := DECLARE _makelock (makelock_spec _).

Definition freelock2_spec := DECLARE _freelock2 (freelock2_spec _).

Definition acquire_spec := DECLARE _acquire acquire_spec.

Definition release2_spec := DECLARE _release2 release2_spec.

Definition spawn_spec := DECLARE _spawn spawn_spec.

Definition load_acq_spec := DECLARE _load_acq load_acq_spec.



Definition CAS_RA_spec := DECLARE _CAS_RA CAS_RA_spec.



Definition surely_malloc_spec :=

 DECLARE _surely_malloc

   WITH t:type

   PRE [ _n OF tuint ]

       PROP (0 <= sizeof t <= Int.max_unsigned;

                complete_legal_cosu_type t = true;

                natural_aligned natural_alignment t = true)

       LOCAL (temp _n (Vint (Int.repr (sizeof t))))

       SEP ()

    POST [ tptr tvoid ] EX p:_,

       PROP ()

       LOCAL (temp ret_temp p)

       SEP (malloc_token Tsh t p * data_at_ Tsh t p).



Definition integer_hash_spec :=

 DECLARE _integer_hash

  WITH i : Z

  PRE [ _i OF tint ]

   PROP () LOCAL (temp _i (vint i)) SEP ()

  POST [ tint ]

   PROP () LOCAL (temp ret_temp (vint (i * 654435761))) SEP ().



Definition tentry := Tstruct _entry noattr.



Definition has_size : {x : Z | x = 16384}.

Proof.

  eexists; eauto.

Qed.



Instance hf1 : hash_fun := { size := proj1_sig has_size; hash i := (i * 654435761) mod (proj1_sig has_size) }.

Proof.

  - rewrite (proj2_sig has_size); computable.

  - intro; apply Z_mod_lt; rewrite (proj2_sig has_size); computable.

Defined.



Definition value_of (m : Z -> option Z) v := exists j, log_latest m j v.



Lemma value_of_0 : value_of (singleton 0 0) 0.

Proof.

  eexists; apply log_latest_singleton.

Qed.

Hint Resolve value_of_0.



Definition v_T sh g s (v : Z) := !!(value_of s v /\ (v = 0 -> forall j v', s j = Some v' -> v' = 0)) &&

  @ghost_master _ _ fmap_order sh s g.



Instance v_prot g : protocol (v_T Share.bot g) (v_T gsh2 g).

Proof.

  split; intros; unfold v_T.

  - Intros.

    eapply derives_trans, bupd_mono; [apply make_snap|].

    entailer!; apply derives_refl.

  - apply prop_duplicable, ghost_snap_duplicable.

Qed.



Notation v_T' g := (v_T Share.bot g, v_T gsh2 g).



Notation v_state i lg l s := (protocol_A l s map_incl (v_T' (Znth i lg))).



Definition zero_ord a b := a = 0 \/ a = b.



Instance zero_RA : Ghost := { valid a := True;

  Join_G a b c := if eq_dec a 0 then c = b else a = c /\ zero_ord b c }.

Proof.

  - exists (fun _ => 0); auto; intro.

    hnf; auto.

  - constructor.

    + intros; hnf in *.

      destruct (eq_dec _ _); subst; auto.

      unfold zero_ord in *; omega.

    + intros; hnf in *.

      destruct (eq_dec _ _), (eq_dec _ _); subst; eexists; split; hnf; auto.

      * rewrite if_false; auto.

      * unfold zero_ord in *; rewrite if_true by omega; auto.

      * rewrite if_true by omega; auto.

      * unfold zero_ord in *.

        instantiate (1 := if eq_dec b 0 then c else b).

        if_tac; auto; omega.

      * rewrite if_false by auto.

        unfold zero_ord in *.

        if_tac; omega.

    + intros; hnf in *.

      unfold zero_ord in *; if_tac; destruct (eq_dec _ _); subst; auto; omega.

    + intros; hnf in *.

      destruct (eq_dec _ _), (eq_dec _ _); unfold zero_ord in *; omega.

  - auto.

Defined.



Instance zero_order : PCM_order zero_ord.

Proof.

  constructor; repeat intro; unfold zero_ord in *; auto; try omega.

  - exists (if eq_dec a 0 then b else a); split; hnf; destruct (eq_dec _ _); auto.

    unfold zero_ord; omega.

  - hnf in H.

    destruct (eq_dec _ _); auto.

    unfold zero_ord in *; omega.

  - hnf.

    if_tac; auto; omega.

Qed.



Definition k_T (sh : share) g s v := !!(s = v) && ghost_master sh v g.



Instance k_prot g : protocol (k_T Share.bot g) (k_T gsh2 g).

Proof.

  split; intros; unfold k_T.

  - Intros.

    eapply derives_trans, bupd_mono; [apply make_snap|].

    entailer!; apply derives_refl.

  - apply prop_duplicable, ghost_snap_duplicable.

Qed.



Notation k_T' g := (k_T Share.bot g, k_T gsh2 g).



Notation k_state i lg l s := (protocol_A l s zero_ord (k_T' (Znth i lg))).



Definition lookup' {B} (T : list (Z * B)) := lookup (combine (map fst T) (repeat 0 (Z.to_nat size))).



Definition wf_table (T : list (Z * (Z -> option Z))) := forall k i, k <> 0 -> fst (Znth i T) = k ->

  lookup' T k = Some i.



Definition hashtable_entry (T : list (Z * (Z -> option Z))) lgk lgv i :=

  let '(k, lv) := Znth i T in !!(exists v, value_of lv v /\ (k = 0 -> v = 0) /\

    (v = 0 -> forall j v', lv j = Some v' -> v' = 0)) &&

  ghost_master gsh1 k (Znth i lgk) * @ghost_master _ _ fmap_order gsh1 lv (Znth i lgv).



Existing Instance exclusive_PCM.



Definition hashtable H g lgk lgv := EX T : list (Z * (Z -> option Z)),

  !!(Zlength T = size /\ wf_table T /\

     forall k lv, H k = Some lv <-> In (k, lv) T /\ exists v, value_of lv v /\ v <> 0) &&

  excl g H * fold_right sepcon emp (map (hashtable_entry T lgk lgv) (upto (Z.to_nat size))).



Definition hashtable_entry_A T lgk lgv entries i := let '(pk, pv) := Znth i entries in

  let '(k, lv) := Znth i T in !!(exists v, value_of lv v /\ (k = 0 -> v = 0) /\

    (v = 0 -> forall j v', lv j = Some v' -> v' = 0)) && k_state i lgk pk k * v_state i lgv pv lv.



Definition hashtable_A T lgk lgv entries :=

  fold_right sepcon emp (map (hashtable_entry_A T lgk lgv entries) (upto (Z.to_nat size))).



Definition HT_upd (H : Z -> option (Z -> option Z)) k v H' := exists lv, H' = map_upd H k lv /\ value_of lv v /\

  match H k with Some lv0 => map_incl lv0 lv | None => True end.



Definition table_incl (T1 T2 : list (Z * (Z -> option Z))) := forall i,

  zero_ord (fst (Znth i T1)) (fst (Znth i T2)) /\

  map_incl (snd (Znth i T1)) (snd (Znth i T2)).



Program Definition get_item_spec := DECLARE _get_item atomic_spec

  (ConstType (Z * val * share * list (val * val) * gname * list gname * list gname * list (Z * (Z -> option Z))))

  [(_key, tint)] tint

  [fun _ '(k, p, sh, entries, g, lgk, lgv, T0) => temp _key (vint k);

   fun _ '(k, p, sh, entries, g, lgk, lgv, T0) => gvar _m_entries p]

  (fun _ '(k, p, sh, entries, g, lgk, lgv, T0) => !!(readable_share sh /\ repable_signed k /\ k <> 0 /\

   Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lgk = size /\ Zlength lgv = size /\

   Zlength T0 = size ) &&

   data_at sh (tarray tentry size) entries p * hashtable_A T0 lgk lgv entries)

  (fun _ '(k, p, sh, entries, g, lgk, lgv, T0) H => hashtable H g lgk lgv)

  (0, empty_map) [fun _ _ x => temp ret_temp (vint (fst x))]

  (fun _ '(k, p, sh, entries, g, lgk, lgv, T0) H '(v, lv) => (data_at sh (tarray tentry size) entries p *

   EX T : _, !!(table_incl T0 T /\ Zlength T = size /\  exists i,

     lookup' T k = Some i /\ snd (Znth i T) = lv) && hashtable_A T lgk lgv entries) *

     (!!(value_of lv v /\ (v <> 0 -> exists lv', H k = Some lv' /\ map_incl lv lv')) &&

      hashtable H g lgk lgv)) Empty_set Full_set _ _ _ _ _.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.



Program Definition add_item_spec := DECLARE _add_item atomic_spec

  (ConstType (Z * Z * val * share * list (val * val) * gname * list gname * list gname * list (Z * (Z -> option Z))))

  [(_key, tint); (_value, tint)] tint

  [fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) => temp _key (vint k);

   fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) => temp _value (vint v);

   fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) => gvar _m_entries p]

  (fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) => !!(readable_share sh /\ repable_signed k /\ repable_signed v /\

   k <> 0 /\ v <> 0 /\ Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lgk = size /\ Zlength lgv = size /\

   Zlength T0 = size ) &&

   data_at sh (tarray tentry size) entries p * hashtable_A T0 lgk lgv entries)

  (fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) H => hashtable H g lgk lgv)

  (true, empty_map) [fun _ _ x => temp ret_temp (Val.of_bool (fst x))]

  (fun _ '(k, v, p, sh, entries, g, lgk, lgv, T0) H '(b, lv) => (data_at sh (tarray tentry size) entries p *

   EX T : _, !!(table_incl T0 T /\ Zlength T = size  /\ exists i, lookup' T k = Some i /\

     Znth i T = (k, lv)) && hashtable_A T lgk lgv entries) *

   (!!((H k = None <-> b = true) /\ (b = true -> value_of lv v)) &&

     hashtable (if b then map_upd H k lv else H) g lgk lgv)) Empty_set Full_set _ _ _ _ _.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.

Next Obligation.

Proof.

  intros ?? w; decompose [prod] w; auto.

Qed.



Definition init_table_spec :=

 DECLARE _init_table

  WITH p : val

  PRE [ ]

   PROP ()

   LOCAL (gvar _m_entries p)

   SEP (data_at_ Ews (tarray tentry size) p)

  POST [ tvoid ]

   EX entries : list (val * val), EX g : gname, EX lgk : list gname, EX lgv : list gname,

   PROP (Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength lgk = size; Zlength lgv = size)

   LOCAL ()

   SEP (data_at Ews (tarray tentry size) entries p; fold_right sepcon emp (map (fun '(pk, pv) =>

          malloc_token Tsh tint pk * malloc_token Tsh tint pv) entries);

        hashtable (fun _ => None) g lgk lgv;

        hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries).



Inductive hashtable_hist_el :=

  | HSet (k : Z) (v : Z) | HGet (k : Z) (v : Z) | HAdd (k : Z) (v : Z) (r : bool).



Notation hist := (list (nat * hashtable_hist_el)).



Fixpoint apply_hist H h H' :=

  match h with

  | [] => H' = H

  | HSet k v :: h' => exists H1, HT_upd H k v H1 /\ apply_hist H1 h' H'

  | HGet k v :: h' => (v <> 0 -> exists lv, H k = Some lv /\ exists j, lv j = Some v) /\ apply_hist H h' H'

  | HAdd k v r :: h' => if r then H k = None /\ exists H1, HT_upd H k v H1 /\ apply_hist H1 h' H'

                        else H k <> None /\ apply_hist H h' H'

  end.



Definition hashtable_inv gh g lgk lgv := EX H : _, hashtable H g lgk lgv *

  EX hr : _, !!(apply_hist (fun _ => None) hr H) && ghost_ref hr gh.



Definition f_lock_inv N sh gsh entries gh g lgk lgv p t locksp lockt resultsp res :=

  EX b1 : bool, EX b2 : bool, EX b3 : bool, EX h : _,

    !!(add_events empty_map [HAdd 1 1 b1; HAdd 2 1 b2; HAdd 3 1 b3] h) && ghost_hist gsh h gh *

    data_at sh (tarray tentry size) entries p *

    invariant N (hashtable_inv gh g lgk lgv) * hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries *

    data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp *

    data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp *

    data_at Tsh tint (vint (Zlength (filter id [b1; b2; b3]))) res.



Definition f_lock_pred N tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res :=

  selflock (f_lock_inv N sh gsh entries gh g lgk lgv p t locksp lockt resultsp res) tsh lockt.



Definition f_spec :=

 DECLARE _f

  WITH tid : val, x : namespace * share * share * share * list (val * val) * gname * gname *

                      list gname * list gname * val * Z * val * val * val * val

  PRE [ _arg OF (tptr tvoid) ]

   let '(N, sh, gsh, tsh, entries, gh, g, lgk, lgv, p, t, locksp, lockt, resultsp, res) := x in

   PROP (0 <= t < 3; isptr lockt; readable_share sh; readable_share tsh; gsh <> Share.bot;

         Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength lgk = size; Zlength lgv = size)

   LOCAL (temp _arg tid; gvar _m_entries p; gvar _thread_locks locksp; gvar _results resultsp)

   SEP (data_at sh (tarray tentry size) entries p; invariant N (hashtable_inv gh g lgk lgv);

        hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries;

        ghost_hist(hist_el := hashtable_hist_el) gsh empty_map gh;

        data_at Tsh tint (vint t) tid; malloc_token Tsh tint tid;

        data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

        data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

        data_at_ Tsh tint res;

        lock_inv tsh lockt (f_lock_pred N tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res))

  POST [ tptr tvoid ] PROP () LOCAL () SEP ().



Definition main_spec :=

 DECLARE _main

  WITH gv : globals

  PRE  [] main_pre prog nil gv

  POST [ tint ] main_post prog nil gv.



Definition Gprog : funspecs := ltac:(with_library prog [makelock_spec; freelock2_spec; acquire_spec;

  release2_spec; spawn_spec; surely_malloc_spec; load_acq_spec; CAS_RA_spec;

  integer_hash_spec; get_item_spec; add_item_spec; init_table_spec; f_spec; main_spec]).



Lemma body_integer_hash: semax_body Vprog Gprog f_integer_hash integer_hash_spec.

Proof.

  start_function.

  forward.

Qed.



Opaque upto.



Lemma hashtable_entry_A_duplicable : forall T lgk lgv entries i, duplicable (hashtable_entry_A T lgk lgv entries i).

Proof.

  intros; unfold hashtable_entry_A.

  destruct (Znth i entries), (Znth i T).

  apply sepcon_duplicable, protocol_A_duplicable.

  apply prop_duplicable, protocol_A_duplicable.

Qed.



Lemma hashtable_A_duplicable : forall T lgk lgv entries, duplicable (hashtable_A T lgk lgv entries).

Proof.

  intros; unfold hashtable_A.

  apply sepcon_list_duplicable.

  rewrite Forall_map, Forall_forall; intros; simpl.

  apply hashtable_entry_A_duplicable.

Qed.



Lemma zero_ord_0 : forall z, zero_ord 0 z.

Proof.

  unfold zero_ord; auto.

Qed.

Hint Resolve zero_ord_0.



Lemma lookup'_succeeds : forall k i i1 (T : list (Z * (Z -> option Z))) (Hk : k <> 0) (Hi : 0 <= i < size)

  (Hi1 : (i + hash k) mod size = i1 mod size) (HT : Zlength T = size)

  (Hfail : Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i (rebase T (hash k))))

  (Hhit : fst (Znth (i1 mod size) T) = k \/ fst (Znth (i1 mod size) T) = 0),

  lookup' T k = Some (i1 mod size).

Proof.

  intros.

  assert (0 <= hash k < Zlength T) by (replace (Zlength T) with size; apply hash_range).

  assert (Zlength (map fst T) = Zlength (repeat 0 (Z.to_nat size))).

  { rewrite Zlength_map, Zlength_repeat, Z2Nat.id; auto; omega. }

  assert (Zlength (combine (map fst T) (repeat 0 (Z.to_nat size))) = size) as Hsize.

  { rewrite Zlength_combine, Z.min_l; auto; try omega; rewrite Zlength_map; auto. }

  assert (Zlength (rebase (combine (map fst T) (repeat 0 (Z.to_nat size))) (hash k)) = size).

  { rewrite Zlength_rebase; auto; omega. }

  assert (forall j, 0 <= j < size -> Znth j (rebase (combine (map fst T) (repeat 0 (Z.to_nat size))) (hash k)) =

    (fst (Znth ((j + hash k) mod size) T), 0)) as Hj.

  { intros; rewrite Znth_rebase, Znth_combine, Znth_repeat'; auto; try omega.

    erewrite Znth_map; rewrite Hsize; eauto.

    replace (Zlength T) with size; apply Z_mod_lt; omega.

    { rewrite Hsize, Z2Nat.id by omega; apply Z_mod_lt; omega. } }

  unfold lookup', lookup; rewrite index_of'_succeeds with (i := i).

  unfold option_map; congruence.

  { omega. }

  { rewrite Forall_forall_Znth.

    rewrite Zlength_sublist by omega; intros.

    rewrite Znth_sublist, Hj by (auto; omega).

    eapply Forall_Znth with (i2 := (i0 + 0)) in Hfail; [|rewrite Zlength_sublist; rewrite ?Zlength_rebase; omega].

    rewrite Znth_sublist, Znth_rebase, Z.add_0_r in Hfail by omega; replace size with (Zlength T); eauto. }

  { rewrite Hj, Hi1; auto. }

Qed.



Lemma failed_entries : forall k i i1 keys lgk lgv T (Hk : k <> 0) (Hi : 0 <= i < size)

  (Hi1 : (i + hash k) mod size = i1 mod size) (HT : Zlength T = size) (Hlg : Zlength lgk = size)

  (Hkeys: Zlength keys = size)

  (Hfail : Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k)))),

  fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry T lgk lgv) (upto (Z.to_nat size))) emp) *

  fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)

    (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i)))

  |-- !! Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i (rebase T (hash k))).

Proof.

  intros.

  rewrite Forall_forall, prop_forall; apply allp_right; intros (k', v').

  rewrite prop_forall; apply allp_right; intro Hin.

  apply In_Znth in Hin; destruct Hin as (j & Hj & Hjth).

  pose proof (hash_range k).

  rewrite Zlength_sublist in Hj by (rewrite ?Zlength_rebase; omega).

  rewrite Znth_sublist, Znth_rebase in Hjth by omega.

  assert (0 <= (j + hash k) mod size < size) by (apply Z_mod_lt, size_pos).

  pose proof (Z_mod_lt i1 _ size_pos).

  rewrite extract_nth_sepcon with (i := (j + hash k) mod size), extract_nth_sepcon with (i := j)(l := map _ _)

    by (rewrite ?upd_Znth_Zlength; rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).

  assert ((j + hash k) mod size <> i1 mod size).

  { rewrite <- Hi1; intro Heq.

    apply Zmod_plus_inv in Heq; [|apply size_pos].

    rewrite !Zmod_small in Heq; omega. }

  erewrite !upd_Znth_diff', !Znth_map, !Znth_upto by

    (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; omega).

  unfold hashtable_entry.

  rewrite Z.add_0_r in Hjth; replace (Zlength T) with size in Hjth; rewrite Hjth.

  Intros; rewrite <- !sepcon_assoc. setoid_rewrite (sepcon_comm _ (ghost_snap (Znth _ _) _)).

  rewrite <- !sepcon_assoc, snap_master_join by auto.

  Intros; apply prop_right; simpl.

  eapply Forall_Znth in Hfail.

  rewrite Znth_sublist, Z.add_0_r, Znth_rebase with (i0 := j) in Hfail; auto; try omega.

  replace (Zlength keys) with size in Hfail.

  match goal with H : zero_ord _ _ |- _ => destruct H; [destruct Hfail; contradiction|] end.

  simpl in *; subst; intuition.

  { rewrite Zlength_sublist; auto; try omega.

    rewrite Zlength_rebase; omega. }

Qed.



Corollary entries_lookup : forall k i i1 keys lgk lgv T (Hk : k <> 0) (Hi : 0 <= i < size)

  (Hi1 : (i + hash k) mod size = i1 mod size) (HT : Zlength T = size) (Hlg : Zlength lgk = size)

  (Hkeys: Zlength keys = size)

  (Hfail : Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k))))

  (Hhit : fst (Znth (i1 mod size) T) = k \/ fst (Znth (i1 mod size) T) = 0),

  fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry T lgk lgv) (upto (Z.to_nat size))) emp) *

  fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)

    (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i)))

  |-- !! (lookup' T k = Some (i1 mod size)).

Proof.

  intros.

  eapply derives_trans; [apply failed_entries; eauto | apply prop_left; intro; apply prop_right].

  eapply lookup'_succeeds; eauto.

Qed.



Lemma wf_table_upd : forall T k v i (Hwf : wf_table T) (HT : Zlength T = size) (Hi : lookup' T k = Some i)

  (Hk : k <> 0), wf_table (upd_Znth i T (k, v)).

Proof.

  intros; intros ?? Hj ?.

  unfold lookup' in Hi.

  pose proof size_pos.

  assert (Zlength (map fst T) = Zlength (repeat 0 (Z.to_nat size))).

  { rewrite Zlength_map, ?Zlength_repeat, ?Z2Nat.id; auto; omega. }

  assert (Zlength (combine (map fst T) (repeat 0 (Z.to_nat size))) = size).

  { rewrite Zlength_combine, Z.min_l; auto; try omega; rewrite Zlength_map; auto. }

  exploit lookup_range; eauto.

  intros; unfold lookup'.

  erewrite <- upd_Znth_map, combine_upd_Znth1 by (auto; rewrite Zlength_map; omega).

  destruct (eq_dec i0 i); subst.

  - rewrite upd_Znth_same, lookup_upd_same; auto; omega.

  - rewrite upd_Znth_diff' in Hj |- * by (auto; omega); simpl.

    assert (lookup (combine (map fst T) (repeat 0 (Z.to_nat size))) (fst (Znth i0 T)) <> Some i).

    { specialize (Hwf (fst (Znth i0 T)) i0).

      unfold lookup' in Hwf; rewrite Hwf; auto; congruence. }

    rewrite lookup_upd_diff; eauto.

    split; auto.

    intro; specialize (Hwf k); unfold lookup' in Hwf.

    erewrite Hwf in Hi by eauto; congruence.

Qed.



Corollary wf_table_upd_same : forall T k v i (Hwf : wf_table T) (HT : Zlength T = size)

  (Hi : fst (Znth i T) = k) (Hk : k <> 0), wf_table (upd_Znth i T (k, v)).

Proof.

  intros; apply wf_table_upd; auto.

Qed.



Lemma hash_size : forall k, (k * 654435761) mod size = hash k mod size.

Proof.

  intro; simpl.

  rewrite Zmod_mod; split; auto; omega.

Qed.



Arguments size : simpl never.

Arguments hash : simpl never.



Lemma upd_entries : forall T lgk lgv i k lv v, value_of lv v -> (k = 0 -> v = 0) ->

  (v = 0 -> forall j v', lv j = Some v' -> v' = 0) -> Zlength T = size -> 0 <= i < size ->

  map (hashtable_entry (upd_Znth i T (k, lv)) lgk lgv) (upto (Z.to_nat size)) =

  upd_Znth i (map (hashtable_entry T lgk lgv) (upto (Z.to_nat size)))

    (ghost_master gsh1 k (Znth i lgk) * @ghost_master _ _ fmap_order gsh1 lv (Znth i lgv)).

Proof.

  intros; apply list_Znth_eq'.

  { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto.

    rewrite Zlength_upto, Z2Nat.id; auto; omega. }

  rewrite Zlength_map; intros.

  unfold hashtable_entry.

  erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).

  destruct (eq_dec j i).

  - subst; rewrite !upd_Znth_same by (rewrite ?Zlength_map; auto; omega).

    rewrite prop_true_andp; eauto.

  - rewrite !upd_Znth_diff' by (rewrite ?Zlength_map; auto; rewrite ?Zlength_upto, ?Z2Nat.id; omega).

    erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega); auto.

Qed.



Lemma value_of_inj : forall m v v', value_of m v -> value_of m v' -> v = v'.

Proof.

  unfold value_of; intros ??? (? & ?) (? & ?); eapply log_latest_inj; eauto.

Qed.



Lemma upd_entries_A : forall T lgk lgv entries pk pv i k lv v, Znth i entries = (pk, pv) ->

  Zlength T = size -> 0 <= i < size -> value_of lv v -> (k = 0 -> v = 0) ->

  (v = 0 -> forall j v' : Z, lv j = Some v' -> v' = 0) ->

  map (hashtable_entry_A (upd_Znth i T (k, lv)) lgk lgv entries) (upto (Z.to_nat size)) =

  upd_Znth i (map (hashtable_entry_A T lgk lgv entries) (upto (Z.to_nat size))) (k_state i lgk pk k * v_state i lgv pv lv).

Proof.

  intros; apply list_Znth_eq'.

  { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto.

    rewrite Zlength_upto, Z2Nat.id; auto; omega. }

  rewrite Zlength_map; intros.

  unfold hashtable_entry_A.

  erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).

  destruct (eq_dec j i).

  - subst; rewrite H, !upd_Znth_same by (rewrite ?Zlength_map; auto; omega).

    rewrite prop_true_andp; eauto.

  - rewrite !upd_Znth_diff' by (rewrite ?Zlength_map; auto; rewrite ?Zlength_upto, ?Z2Nat.id; omega).

    erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega); auto.

Qed.



Lemma sepcon_hoist_if : forall {A} {A_eq : EqDec A} (b c : A) P1 P2 Q,

  (if eq_dec b c then P1 * Q else P2 * Q) = Q * if eq_dec b c then P1 else P2.

Proof.

  intros; if_tac; apply sepcon_comm.

Qed.



Instance zero_ord_preorder : RelationClasses.PreOrder zero_ord.

Proof.

  split; [apply (@ord_refl _ _ zero_order) | apply (@ord_trans _ _ zero_order)].

Qed.



Instance table_incl_preorder : RelationClasses.PreOrder table_incl.

Proof.

  split.

  - repeat intro; split; reflexivity.

  - intros ??? Hincl1 Hincl2 ?.

    destruct (Hincl1 i), (Hincl2 i).

    split; etransitivity; eauto.

Qed.



Lemma table_incl_upd : forall T i k v, 0 <= i < Zlength T -> zero_ord (fst (Znth i T)) k ->

  map_incl (snd (Znth i T)) v -> table_incl T (upd_Znth i T (k, v)).

Proof.

  repeat intro.

  destruct (eq_dec i0 i).

  - subst; rewrite upd_Znth_same; auto.

  - rewrite upd_Znth_diff' by auto; split; reflexivity.

Qed.



Lemma HT_upd_exists : forall H k v (HH : match H k with Some lv => exists v, value_of lv v | None => True end),

  exists H', HT_upd H k v H'.

Proof.

  intros; unfold HT_upd.

  destruct (H k) as [lv|] eqn: Hk.

  - destruct HH as (v0 & j & ? & Hj).

    destruct (log_latest_upd lv j v0 (j + 1) v); unfold log_latest; auto; try omega.

    do 3 eexists; eauto; split; eauto.

    eexists; eauto.

  - eexists _, (singleton 0 v); split; auto; split; auto.

    eexists; apply log_latest_singleton.

Qed.



Lemma zero_ord_0_inv : forall z, zero_ord z 0 -> z = 0.

Proof.

  intros ? [|]; auto.

Qed.



Lemma andp_emp_dup : forall P, P && emp = (P && emp) * (P && emp).

Proof.

  change mpred with (predicates_hered.pred compcert_rmaps.R.rmap); intro;

    apply predicates_hered.pred_ext.

  - intros a ?; exists a, a; split; auto.

    apply sepalg.identity_unit', H.

  - intros ? (? & ? & ? & [? Hemp] & []).

    apply Hemp in H; subst; split; auto.

Qed.



Lemma body_get_item : semax_body Vprog Gprog f_get_item get_item_spec.

Proof.

  start_atomic_function.

  destruct x as (((((((k, p), sh), entries), g), lgk), lgv), T0); Intros.

  freeze [0] SHIFT.

  forward_call k.

  pose proof size_pos.

  forward_loop (@exp (environ -> mpred) _ _ (fun i => @exp (environ -> mpred) _ _ (fun i1 => @exp (environ -> mpred) _ _ (fun T =>

    PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength T = size; table_incl T0 T;

          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase (map fst T) (hash k))))

    LOCAL (temp _idx (vint i1); temp _key (vint k); gvar _m_entries p)

    SEP (FRZL SHIFT; @data_at CompSpecs sh (tarray tentry size) entries p; hashtable_A T lgk lgv entries;

         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T))

           (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i))))))))

    continue: (@exp (environ -> mpred) _ _ (fun i => @exp (environ -> mpred) _ _ (fun i1 => @exp (environ -> mpred) _ _ (fun T =>

        PROP (0 <= i1 <= size; i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength T = size; table_incl T0 T;

          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 (i + 1) (rebase (map fst T) (hash k))))

        LOCAL (temp _idx (vint i1); temp _key (vint k); gvar _m_entries p)

        SEP (FRZL SHIFT; @data_at CompSpecs sh (tarray tentry size) entries p; hashtable_A T lgk lgv entries;

             fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T))

               (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat (i + 1))))))))).

  { Exists 0 (k * 654435761)%Z T0; rewrite sublist_nil; entailer!; try apply derives_refl.

    apply hash_size. }

  Intros i i1 T; forward.

  rewrite sub_repr, and_repr; simpl.

  rewrite Zland_two_p with (n := 14) by omega.

  replace (2 ^ 14) with size by (setoid_rewrite (proj2_sig has_size); auto).

  exploit (Z_mod_lt i1 size); [omega | intro Hi1].

  assert_PROP (Zlength entries = size) as Hentries by entailer!.

  assert (0 <= i1 mod size < Zlength entries) as Hi1' by omega.

  match goal with H : Forall _ _ |- _ => pose proof (Forall_Znth _ _ _ Hi1' H) as Hptr end.

  destruct (Znth (i1 mod size) entries) as (pki, pvi) eqn: Hpi; destruct Hptr.

  forward; setoid_rewrite Hpi.

  { entailer!. }

  assert (0 <= i1 mod size < Zlength (upto (Z.to_nat size))).

  { rewrite Zlength_upto, Z2Nat.id; auto; omega. }

  unfold hashtable_A; rewrite extract_nth_sepcon with (i := i1 mod size) by (rewrite Zlength_map; auto).

  erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).

  unfold hashtable_entry_A at 1; rewrite Hpi.

  destruct (Znth (i1 mod size) T) as (ki, lvi) eqn: HTi; Intros.

  assert (Zlength (rebase (map fst T) (hash k)) = size) as Hrebase.

  { rewrite Zlength_rebase; rewrite Zlength_map; auto; replace (Zlength T) with size; apply hash_range. }

  

  forward_call_dep [Z : Type] (pki, ki, zero_ord, k_T' (Znth (i1 mod size) lgk),

    FRZL SHIFT * fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T))

        (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i))) *

        data_at sh (tarray tentry size) entries p * v_state (i1 mod size) lgv pvi lvi *

      fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry_A T lgk lgv entries) (upto (Z.to_nat size))) emp),

    @Full_set namespace,

    fun s v => !!(s = v) && if eq_dec v 0 then Q (0, lvi)

      else FRZL SHIFT * k_state (i1 mod size) lgk pki v * ghost_snap v (Znth (i1 mod size) lgk) *

        fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T))

          (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i))) *

          data_at sh (tarray tentry size) entries p * v_state (i1 mod size) lgv pvi lvi *

      fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry_A T lgk lgv entries) (upto (Z.to_nat size))) emp)).

  { subst Frame; instantiate (1 := nil); simpl.

    rewrite sepcon_emp, sepcon_comm, !sepcon_assoc, (sepcon_comm _ (_ * _)).

    rewrite <- sepcon_emp at 1; apply sepcon_derives; [apply derives_refl|].

    apply allp_right; intro s'.

    rewrite <- imp_andp_adjoint; Intros.

    apply allp_right; intro v.

    apply andp_right; auto.

    eapply derives_trans, fview_shift_weak; auto.

    thaw SHIFT; unfold atomic_shift.

    Intros P.

    rewrite andp_emp_dup.

    rewrite <- 4sepcon_assoc, (sepcon_comm _ (_ * _)).

    rewrite <- sepcon_assoc, 7sepcon_assoc; eapply derives_trans; [apply sepcon_derives, derives_refl|].

    { rewrite sepcon_comm; apply apply_fview_shift. }

    eapply derives_trans, fupd_trans; eapply derives_trans, fupd_mono; [apply fupd_frame_r|].

    Intros H'.

    if_tac.

    + unfold k_T at 1; simpl; Intros; subst.

      rewrite emp_sepcon, prop_true_andp by auto.

      rewrite <- sepcon_assoc, sepcon_comm.

      rewrite <- !sepcon_assoc, 6sepcon_assoc.

      eapply derives_trans; [apply sepcon_derives, derives_refl; apply sepcon_derives;

        [apply own_dealloc | apply own_list_dealloc]|].

      eapply derives_trans; [apply sepcon_derives, derives_refl; apply bupd_sepcon|].

      eapply derives_trans; [apply bupd_frame_r|].

      apply fupd_bupd, bupd_mono.

      rewrite !emp_sepcon.

      rewrite <- 4sepcon_assoc, sepcon_comm, !sepcon_assoc.

      eapply derives_trans, apply_fview_shift; apply sepcon_derives.

      { eapply derives_trans, derives_refl.

        eapply andp_left2, allp_left, derives_refl. }

      exploit zero_ord_0_inv; eauto; intro; subst.

      match goal with H : exists v, _ |- _ => destruct H as (? & ? & Hz & ?) end.

      specialize (Hz eq_refl); subst.

      eapply derives_trans; [apply sepcon_derives, derives_refl; apply andp_left2, derives_refl|].

      Exists T; entailer!.

      { exists (i1 mod size); rewrite HTi; split; auto.

        apply lookup'_succeeds with (i := i); rewrite ?HTi; auto.

        match goal with H : Forall _ (sublist _ _ _) |- _ => rewrite rebase_map, sublist_map, Forall_map in H end.

        eapply Forall_impl; eauto; simpl; auto. }

      rewrite sepcon_comm, <- sepcon_assoc, replace_nth_sepcon, upd_Znth_triv; [apply derives_refl | ..].

      { rewrite Zlength_map; auto. }

      { rewrite Znth_map, Znth_upto by (auto; rewrite Z2Nat.id; omega).

        unfold hashtable_entry_A; rewrite Hpi, HTi.

        rewrite prop_true_andp; eauto. }

    + rewrite <- 4sepcon_assoc, 4sepcon_assoc.

      eapply derives_trans; [apply sepcon_derives, derives_refl|].

      { eapply derives_trans, apply_fview_shift.

        rewrite sepcon_comm; apply sepcon_derives, derives_refl.

        apply andp_left1, derives_refl. }

      eapply derives_trans, fupd_mono; [apply fupd_frame_r|].

      unfold k_T at 1; simpl; Exists P; unfold ghost_master, ghost_snap; entailer!. }

  Intros x; destruct x as (k1, ?); simpl fst in *; simpl snd in *.

  pose proof (hash_range k).

  match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

    forward_if (PROP (k1 <> k) (LOCALx Q (SEPx R))) end.

  + subst; if_tac; [contradiction | Intros].

    forward; setoid_rewrite Hpi.

    { entailer!. }

    forward_call_dep [(Z -> option Z) : Type] (pvi, lvi, @map_incl Z Z, v_T' (Znth (i1 mod size) lgv),

      FRZL SHIFT * ghost_snap k (Znth (i1 mod size) lgk) *

        fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T))

          (Znth ((i + hash k) mod size) lgk)) (upto (Z.to_nat i))) *

        data_at sh (tarray tentry size) entries p * k_state (i1 mod size) lgk pki k *

        fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry_A T lgk lgv entries) (upto (Z.to_nat size))) emp),

      @Full_set namespace,

      fun s v => !!(value_of s v /\ (v = 0 -> forall j v', s j = Some v' -> v' = 0)) && Q (v, s)).

    { subst Frame; instantiate (1 := nil); simpl.

      rewrite sepcon_emp.

      apply allp_right; intro s'.

      rewrite <- imp_andp_adjoint; Intros.

      apply allp_right; intro v.

      apply andp_right; auto.

      eapply derives_trans, fview_shift_weak; auto.

      thaw SHIFT; unfold atomic_shift.

      Intros P.

      rewrite <- 4sepcon_assoc, (sepcon_comm _ (_ * _)).

      rewrite sepcon_emp, 6sepcon_assoc; eapply derives_trans; [apply sepcon_derives, derives_refl|].

      { rewrite sepcon_comm; apply apply_fview_shift. }

      eapply derives_trans, fupd_trans; eapply derives_trans, fupd_mono; [apply fupd_frame_r|].

      Intros H'.

      unfold v_T at 1; Intros.

      rewrite prop_true_andp by auto.

      assert_PROP ((v <> 0 -> exists lv' : Z -> option Z, H' k = Some lv' /\ map_incl s' lv')).

      { rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)).

        rewrite <- !sepcon_assoc, (sepcon_comm _ (@ghost_master _ _ fmap_order _ s' _)).

        rewrite <- !sepcon_assoc, 5sepcon_assoc; apply sepcon_derives_prop.

        unfold hashtable.

        Intros T1.

        rewrite extract_nth_sepcon with (i := i1 mod size) by (rewrite Zlength_map; auto).

        rewrite Znth_map, Znth_upto by (auto; rewrite Z2Nat.id; omega).

        unfold hashtable_entry.

        destruct (Znth (i1 mod size) T1) as (?, lvi') eqn: HT1; Intros.

        rewrite <- !sepcon_assoc, (sepcon_comm _ (@ghost_master _ _ fmap_order _ lvi' _)).

        rewrite <- !sepcon_assoc, (sepcon_comm (ghost_master _ _ _)); setoid_rewrite snap_master_join; auto; Intros.

        rewrite (sepcon_comm _ (ghost_snap _ _)), (sepcon_comm _ (ghost_master _ _ _)).

        rewrite <- !sepcon_assoc, (sepcon_comm (ghost_master _ _ _)); setoid_rewrite snap_master_join; auto; Intros.

        apply prop_right; intros.

        exists lvi'; split; auto.

        match goal with H : forall _ _, _ <-> _ |- _ => rewrite H end.

        match goal with H : zero_ord k _ |- _ => destruct H; [contradiction | subst] end.

        split; [rewrite <- HT1; apply Znth_In; omega|].

        match goal with H : exists v, _ /\ _ |- _ => destruct H as (? & ? & ? & Hz) end.

        match goal with H : value_of s' v |- _ => destruct H as (? & ? & ?) end.

        do 2 eexists; eauto. }

      rewrite sepcon_comm.

      rewrite <- !sepcon_assoc, 5sepcon_assoc.

      eapply derives_trans; [apply sepcon_derives, derives_refl; apply sepcon_derives;

        [apply sepcon_derives; apply own_dealloc | apply own_list_dealloc]|].

      eapply derives_trans; [apply sepcon_derives, derives_refl;

        eapply derives_trans, bupd_sepcon; apply sepcon_derives, derives_refl; apply bupd_sepcon|].

      eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd, bupd_mono].

      rewrite !emp_sepcon.

      rewrite <- 4sepcon_assoc, sepcon_comm, !sepcon_assoc.

      eapply derives_trans, apply_fview_shift; apply sepcon_derives.

      { eapply derives_trans, derives_refl.

        eapply andp_left2, allp_left, derives_refl. }

      Exists (upd_Znth (i1 mod size) T (k, s')); entailer!.

      { split; [etransitivity; eauto; apply table_incl_upd; rewrite ?HTi; auto; try omega; etransitivity; eauto|].

        assert (Zlength (upd_Znth (i1 mod size) T (k, s')) = size) by (rewrite upd_Znth_Zlength; auto; omega).

        split; auto.

        exists (i1 mod size); split; [|rewrite upd_Znth_same; auto; omega].

        apply lookup'_succeeds with (i := i); auto; [|rewrite upd_Znth_same; auto; omega].

        replace (i1 mod size) with ((i + hash k) mod size); replace size with (Zlength T).

        rewrite rebase_upd', sublist_upd_Znth_l by (rewrite ?Zlength_rebase; omega).

        match goal with H : Forall _ (sublist _ _ _) |- _ => rewrite rebase_map, sublist_map, Forall_map in H end.

        eapply Forall_impl; eauto; simpl; auto. }

      rewrite sepcon_comm, <- sepcon_assoc, replace_nth_sepcon, sepcon_comm.

      unfold hashtable_A; erewrite upd_entries_A; try apply derives_refl; eauto; contradiction. }

    Intros x; destruct x as (v, lvi').

    

    unfold POSTCONDITION, abbreviate; simpl map.

    forward.

    Exists (v, lvi'); entailer!.

  + forward.

    entailer!.

  + Intros; match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (k1 <> 0) (LOCALx Q (SEPx R))) end.

    * subst; simpl.

      unfold POSTCONDITION, abbreviate; simpl map.

      forward.

      Exists (0, lvi); entailer!.

    * if_tac; [contradiction|].

      forward.

      entailer!.

    * Intros; rewrite if_false by auto.

      Intros; Exists i (i1 mod size) (upd_Znth (i1 mod size) T (k1, lvi)).

      gather_SEP 1 5 6; rewrite <- sepcon_assoc, replace_nth_sepcon.

      match goal with H : exists v, _ |- _ => destruct H as (? & ? & ? & ?) end.

      unfold hashtable_A; erewrite upd_entries_A by (eauto; contradiction).

      rewrite Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.

      change (upto (Z.to_nat 1)) with [0]; simpl fold_right; rewrite Z2Nat.id, Z.add_0_r by omega.

      replace ((i + hash k) mod size) with (i1 mod size); rewrite <- upd_Znth_map, upd_Znth_same by (rewrite Zlength_map; omega).

      rewrite upd_Znth_map; entailer!.

      { rewrite Zmod_mod; split; auto.

        assert (Zlength (upd_Znth (i1 mod size) T (k1, lvi)) = size) by (rewrite upd_Znth_Zlength; auto; omega).

        split; auto.

        split; [etransitivity; eauto; apply table_incl_upd; rewrite ?HTi; try omega; try reflexivity; auto|].

        replace (i1 mod size) with ((i + hash k) mod size).

        rewrite <- upd_Znth_map.

        replace size with (Zlength (map fst T)) by (rewrite Zlength_map; auto).

        rewrite rebase_upd' by (rewrite Zlength_map; auto; omega).

        rewrite sublist_upd_Znth_lr by (try omega; setoid_rewrite Hrebase; omega).

        rewrite sublist_split with (mid := i), sublist_len_1 by (try omega; setoid_rewrite Hrebase; omega).

        rewrite Z.sub_0_r, upd_Znth_app2, Forall_app; rewrite Zlength_sublist;

          rewrite ?Zlength_cons, ?Zlength_nil; try omega; try (setoid_rewrite Hrebase; omega).

        split; auto.

        rewrite Z.sub_0_r, Zminus_diag, upd_Znth0, Zlength_cons, sublist_1_cons, sublist_same by (auto; omega).

        repeat constructor; auto; tauto. }

      apply sepcon_derives; [apply derives_refl|].

      erewrite map_ext_in; [apply derives_refl | intros; simpl].

      rewrite <- upd_Znth_map, upd_Znth_diff'; auto; rewrite ?Zlength_map; try omega.

      replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.

      rewrite In_upto, Z2Nat.id in * by omega.

      rewrite !Zmod_small in X; omega.

  + Intros i i1 keys.

    forward.

    { entailer!.

      rewrite !Int.signed_repr; try computable; split; pose proof Int.min_signed_neg; try omega;

        transitivity (size + 1); try omega; setoid_rewrite (proj2_sig has_size); computable. }

    Exists (i + 1) (i1 + 1) keys; entailer!.

    split.

    { rewrite <- Zplus_mod_idemp_l.

      replace (i1 mod _) with ((i + hash k) mod size); simpl.

      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }

    admit. 

Admitted.



Lemma body_add_item : semax_body Vprog Gprog f_add_item add_item_spec.

Proof.

  start_atomic_function.

  destruct x as ((((((((k, v), p), sh), entries), g), lgk), lgv), T0); Intros.

  destruct H as (HP & HQ).

  forward_call k.

  pose proof size_pos.

  eapply semax_pre with (P' := EX i : Z, EX i1 : Z, EX T : list (Z * (Z -> option Z)),

    PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength T = size; table_incl T0 T;

          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase (map fst T) (hash k))))

    LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvar _m_entries p)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p; hashtable_A T lgk lgv entries;

         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

           (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i)));

         fold_right sepcon emp (map (fun p0 => invariant (II p0)) lI); P)).

  { Exists 0 (k * 654435761)%Z T0; rewrite sublist_nil; entailer!.

    apply hash_size. }

  eapply semax_loop.

  - Intros i i1 T; forward.

    forward.

    rewrite sub_repr, and_repr; simpl.

    rewrite Zland_two_p with (n := 14) by omega.

    replace (2 ^ 14) with size by (setoid_rewrite (proj2_sig has_size); auto).

    exploit (Z_mod_lt i1 size); [omega | intro Hi1].

    assert_PROP (Zlength entries = size) as Hentries by entailer!.

    assert (0 <= i1 mod size < Zlength entries) as Hi1' by omega.

    match goal with H : Forall _ _ |- _ => pose proof (Forall_Znth _ _ _ (Vundef, Vundef) Hi1' H) as Hptr end.

    destruct (Znth (i1 mod size) entries (Vundef, Vundef)) as (pki, pvi) eqn: Hpi; destruct Hptr.

    forward; rewrite Hpi.

    { entailer!. }

    assert (0 <= i1 mod size < Zlength (upto (Z.to_nat size))).

    { rewrite Zlength_upto, Z2Nat.id; auto; omega. }

    unfold hashtable_A; rewrite extract_nth_sepcon with (i := i1 mod size) by (rewrite Zlength_map; auto).

    erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).

    assert (Zlength (rebase (map fst T) (hash k)) = size) as Hrebase.

    { rewrite Zlength_rebase; rewrite Zlength_map; replace (Zlength T) with size; auto; apply hash_range. }

    unfold hashtable_entry_A at 1; rewrite Hpi.

    destruct (Znth (i1 mod size) T (0, empty_map)) as (ki, lvi) eqn: HTi; Intros.

    forward_call_dep [Z : Type] (load_acq_witness pki ki zero_ord (k_T' (Znth (i1 mod size) lgk Vundef))

      emp (k_T Share.bot (Znth (i1 mod size) lgk Vundef))).

    { simpl; cancel. }

    { split; simpl; intros; rewrite ?emp_sepcon, ?sepcon_emp; [reflexivity|].

      rewrite sepcon_comm; reflexivity. }

    unfold k_T at 3; Intros x; destruct x as (k1, ?); simpl fst in *; simpl snd in *; subst.

    pose proof (hash_range k).

    assert (forall x, Zlength (upd_Znth (i1 mod size) T x) = size).

    { intro; rewrite upd_Znth_Zlength; auto; omega. }

    gather_SEP 1 2.

    match goal with |- semax _ (PROP () (LOCALx (_ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>

      forward_if (PROP (zero_ord k1 k) (LOCALx Q (SEPx (k_state (i1 mod size) lgk pki k ::

        ghost_snap k (Znth (i1 mod size) lgk Vundef) :: R)))) end.

    + assert (forall k1 v, (k1 <> k /\ k1 <> 0) ->

        Forall (fun z => z <> 0 /\ z <> k)

          (sublist 0 (i + 1) (rebase (map fst (upd_Znth (i1 mod size) T (k1, v))) (hash k)))).

      { intros; replace (i1 mod size) with ((i + hash k) mod size).

        replace size with (Zlength (map fst T)) by (rewrite Zlength_map; auto).

        rewrite <- upd_Znth_map, rebase_upd' by (rewrite Zlength_map; auto; omega).

        rewrite sublist_upd_Znth_lr by (try omega; setoid_rewrite Hrebase; omega).

        rewrite sublist_split with (mid := i), sublist_len_1 with (d := 0) by (try omega; setoid_rewrite Hrebase; omega).

        rewrite Z.sub_0_r, upd_Znth_app2, Forall_app; rewrite Zlength_sublist;

          rewrite ?Zlength_cons, ?Zlength_nil; try omega; try (setoid_rewrite Hrebase; omega).

        split; auto.

        rewrite Z.sub_0_r, Zminus_diag, upd_Znth0, Zlength_cons, sublist_1_cons, sublist_same

          by (auto; omega).

        repeat constructor; auto; tauto. }

      match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

        forward_if (PROP (k1 = 0) (LOCALx Q (SEPx R))) end.

      { eapply semax_pre; [|apply semax_continue].

        unfold POSTCONDITION, abbreviate, overridePost.

        destruct (eq_dec EK_continue EK_normal); [discriminate|].

        unfold loop1_ret_assert.

        instantiate (1 := EX i : Z, EX i1 : Z, EX T : list (Z * (Z -> option Z)),

          PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength T = size; table_incl T0 T;

            Forall (fun z => z <> 0 /\ z <> k) (sublist 0 (i + 1) (rebase (map fst T) (hash k))))

          LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvar _m_entries p)

          SEP (@data_at CompSpecs sh (tarray tentry size) entries p; hashtable_A T lgk lgv entries;

               fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

                 (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat (i + 1))));

               fold_right sepcon emp (map (fun p0 => invariant (II p0)) lI); P)).

        Exists i (i1 mod size) (upd_Znth (i1 mod size) T (k1, snd (Znth (i1 mod size) T (0, empty_map)))); rewrite Zmod_mod, Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.

        change (upto (Z.to_nat 1)) with [0]; simpl fold_right.

        rewrite Z2Nat.id, Z.add_0_r by omega.

        replace ((i + hash k) mod size) with (i1 mod size).

        rewrite Znth_map' with (b := (0, empty_map)), upd_Znth_same by omega.

        Intros.

        gather_SEP 0 4 5 6; rewrite <- !sepcon_assoc, replace_nth_sepcon.

        match goal with H : exists v, _ |- _ => destruct H as (? & ? & ? & ?) end.

        unfold hashtable_A; erewrite upd_entries_A by (eauto; rewrite ?HTi; eauto; contradiction).

        unfold ghost_snap, share; rewrite HTi; entailer!.

        { etransitivity; eauto; apply table_incl_upd; rewrite ?HTi; auto; try omega; reflexivity. }

        erewrite map_ext_in; eauto; intros; simpl.

        rewrite <- upd_Znth_map, upd_Znth_diff'; auto; rewrite ?Zlength_map; try omega.

        replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.

        rewrite In_upto, Z2Nat.id in * by omega.

        rewrite !Zmod_small in X; omega. }

      { forward.

        entailer!. }

      Intros; subst.

      forward_call_dep [Z : Type] (pki, 0, k, 0, zero_ord, k_T' (Znth (i1 mod size) lgk Vundef),

        P * ghost (Share.bot, 0) (Znth (i1 mod size) lgk Vundef) * k_state (i1 mod size) lgk pki 0 *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))), II, lI,

        ghost (Share.bot, 0) (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))) * EX H' : _, hashtable H' g lgk lgv * R H',

        fun s => !!(s = k) && ghost_snap k (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))) * EX H' : _, hashtable H' g lgk lgv * R H',

        fun s v => !!(s = v) && ghost_snap v (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))) * EX H' : _, hashtable H' g lgk lgv * R H',

        fun s v => P * (!!(if eq_dec v 0 then s = k else s = v) && k_state (i1 mod size) lgk pki s *

          ghost_snap s (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))))).

      { unfold share; cancel. }

      { repeat (split; auto); intros.

        * rewrite <- !sepcon_assoc, 2sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].

          apply derives_view_shift; cancel.

        * simpl; view_shift_intro H'.

          unfold k_T, hashtable; view_shift_intro T1; view_shift_intros.

          rewrite extract_nth_sepcon with (i := (i1 mod size))(l := map _ (upto (Z.to_nat size))) by (rewrite Zlength_map; auto).

          erewrite Znth_map, Znth_upto by (auto; rewrite Z2Nat.id; omega).

          unfold hashtable_entry at 1.

          destruct (Znth (i1 mod size) T1 (0, empty_map)) as (?, lv) eqn: HT1; view_shift_intros.

          rewrite <- !sepcon_assoc, sepcon_comm.

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh1, _) (Znth _ lgk _))).

          erewrite <- !sepcon_assoc, master_share_join' by eauto; view_shift_intros.

          erewrite master_share_join by eauto.

          rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, master_update with (v' := k); auto|].

          erewrite <- master_share_join by eauto.

          subst; match goal with H : exists v, _ /\ _ |- _ => destruct H as (? & ? & Hz & ?);

            specialize (Hz eq_refl); subst end.

          rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, make_snap|].

          apply derives_view_shift; Exists k H' (upd_Znth (i1 mod size) T1 (k, lv)).

          assert_PROP (lookup' T1 k = Some (i1 mod size)) as Hindex.

          { pose proof (entries_lookup k i i1 (map fst T) lgk lgv T1) as Hlookup.

            subst; sep_apply Hlookup; auto.

            { rewrite Zlength_map; auto. }

            { rewrite HT1; auto. }

            apply sepcon_derives_prop; auto. }

          unfold share; entailer!.

          { assert (Zlength (upd_Znth (i1 mod size) T1 (k, lv)) = size)

              by (rewrite upd_Znth_Zlength; auto; omega).

            split; auto.

            split; [apply wf_table_upd; auto|].

            intros.

            etransitivity; eauto; split; intros (Hin & ?); split; auto.

            - eapply In_upd_Znth_old; auto; try omega.

              intro X; rewrite <- X in HT1; inv HT1.

              match goal with H : exists v, _ /\ _ |- _ => destruct H as (? & ? & Hnz) end.

              contradiction Hnz; eapply value_of_inj; eauto.

            - apply In_upd_Znth in Hin; destruct Hin as [X|]; auto.

              inv X.

              match goal with H : exists v, _ /\ _ |- _ => destruct H as (? & ? & Hnz) end.

              contradiction Hnz; eapply value_of_inj; eauto. }

          erewrite replace_nth_sepcon, upd_entries; eauto.

        * simpl; view_shift_intro H'.

          unfold k_T; view_shift_intros; subst.

          rewrite sepcon_comm, <- !sepcon_assoc; setoid_rewrite ghost_snap_join with (v0 := v');

            [|simpl; unfold zero_ord; auto].

          apply derives_view_shift; Exists H'; entailer!.

        * rewrite !sepcon_hoist_if.

          rewrite sepcon_comm, !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].

          apply derives_view_shift; cancel; if_tac; entailer!. }

      Intros x; destruct x as (k1, ?); simpl fst in *; simpl snd in *.

      gather_SEP 2 3.

      match goal with |- semax _ (PROP () (LOCALx (_ :: _ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>

        forward_if (PROP (zero_ord k1 k) ((LOCALx Q) (SEPx (k_state (i1 mod size) lgk pki k ::

          ghost_snap k (Znth (i1 mod size) lgk Vundef) :: R)))) end.

      * if_tac; [discriminate | Intros; subst].

        forward_call_dep [Z : Type] (load_acq_witness pki k1 zero_ord

          (k_T' (Znth (i1 mod size) lgk Vundef)) emp (k_T Share.bot (Znth (i1 mod size) lgk Vundef))).

        { split; simpl; intros; rewrite ?emp_sepcon, ?sepcon_emp; [reflexivity|].

          rewrite sepcon_comm; reflexivity. }

        unfold k_T at 3; Intros x; destruct x as (k2, ?); simpl fst in *; simpl snd in *; subst.

        match goal with H : zero_ord k1 k2 |- _ => destruct H; [contradiction | subst k2] end.

        gather_SEP 2 3; setoid_rewrite ghost_snap_join; [|apply join_refl].

        match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

          forward_if (PROP (k1 = k) (LOCALx Q (SEPx R))) end.

        { gather_SEP 2 7 8 9; rewrite <- !sepcon_assoc, replace_nth_sepcon.

          eapply semax_pre; [|apply semax_continue].

          unfold POSTCONDITION, abbreviate, overridePost.

          destruct (eq_dec EK_continue EK_normal); [discriminate|].

          unfold loop1_ret_assert.

          go_lower.

          Exists i (i1 mod size) (upd_Znth (i1 mod size) T (k1, lvi)); rewrite Zmod_mod.

          match goal with H : exists v, _ |- _ => destruct H as (? & ? & ? & ?) end.

          unfold hashtable_A; erewrite upd_entries_A by (eauto; contradiction).

          rewrite Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.

          change (upto (Z.to_nat 1)) with [0]; simpl fold_right; rewrite Z2Nat.id, Z.add_0_r by omega.

          replace ((i + hash k) mod size) with (i1 mod size); rewrite <- upd_Znth_map, upd_Znth_same by (rewrite Zlength_map; omega).

          rewrite upd_Znth_map; entailer!.

          { etransitivity; eauto; apply table_incl_upd; rewrite ?HTi; try omega; try reflexivity.

            etransitivity; eauto. }

          erewrite sepcon_comm, map_ext_in; eauto; intros; simpl.

          rewrite <- upd_Znth_map, upd_Znth_diff'; auto; rewrite ?Zlength_map; try omega.

          replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.

          rewrite In_upto, Z2Nat.id in * by omega.

          rewrite !Zmod_small in X; omega. }

        { forward.

          entailer!. }

        intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

        rewrite eq_dec_refl; entailer!.

      * forward.

        if_tac; [Intros; subst | discriminate].

        entailer!.

      * intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

        rewrite eq_dec_refl; entailer!.

    + forward.

      subst; entailer!.

    + forward; rewrite Hpi.

      { entailer!. }

      forward_call_dep [(Z -> option Z) : Type] (pvi, 0, v, lvi, @map_incl Z Z, v_T' (Znth (i1 mod size) lgv Vundef),

        P * v_state (i1 mod size) lgv pvi lvi * ghost_snap k (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))), II, lI,

        ghost_snap k (Znth (i1 mod size) lgk Vundef) *

          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) (map fst T) 0)

            (Znth ((i + hash k) mod size) lgk Vundef)) (upto (Z.to_nat i))) *

          EX H' : _, hashtable H' g lgk lgv * R H',

        fun s'' => !!(value_of s'' v) && EX H' : _, !!(H' k = None) && hashtable (map_upd H' k s'') g lgk lgv * R H',

        fun s' v' => !!(value_of s' v') && EX H' : _, !!(H' k <> None) && hashtable H' g lgk lgv * R H',

        fun s' v' => (EX H' : _, Q H' (if eq_dec v' 0 then true else false, s')) *

          (!!(value_of s' (if eq_dec v' 0 then v else v')) && v_state (i1 mod size) lgv pvi s')).

      { repeat (split; auto); intros.

        * rewrite <- !sepcon_assoc, 2sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].

          apply derives_view_shift; cancel.

        * simpl; view_shift_intro H'.

          unfold v_T; view_shift_intros.

          unfold hashtable; view_shift_intro T1; view_shift_intros.

          rewrite extract_nth_sepcon with (i := (i1 mod size))(l := map _ (upto (Z.to_nat size))) by (rewrite Zlength_map; auto).

          erewrite Znth_map, Znth_upto by (auto; rewrite Z2Nat.id; omega).

          unfold hashtable_entry at 1.

          destruct (Znth (i1 mod size) T1 (0, empty_map)) as (k', lv) eqn: HT1; view_shift_intros.

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh1, _) (Znth _ lgk _))).

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap k _)).

          rewrite snap_master_join by auto; view_shift_intros.

          match goal with H : zero_ord k _ |- _ => destruct H; [contradiction | subst k'] end.

          rewrite (sepcon_comm _ (ghost (gsh2, _) _)), <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh1, _) _)).

          erewrite <- !sepcon_assoc, master_share_join' by eauto.

          view_shift_intros; subst.

          match goal with H : exists v, _ /\ _ |- _ => destruct H as (v0 & (j & Hlv) & _ & Hz) end.

          destruct (log_latest_upd s' j v0 (j + 1) v); auto; try omega.

          rewrite !sepcon_assoc; etransitivity;

            [apply view_shift_sepcon1, master_update with (v' := map_upd s' (j + 1) v); auto|].

          erewrite <- master_share_join by eauto.

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ g)).

          rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1,

            exclusive_update with (v' := map_upd H' k (map_upd s' (j + 1) v))|].

          assert (value_of (map_upd s' (j + 1) v) v) by (eexists; eauto).

          apply view_shift_assert with (PP := lookup' T1 k = Some (i1 mod size)).

          { pose proof (entries_lookup k i i1 (map fst T) lgk lgv T1) as Hlookup.

            subst; sep_apply Hlookup; auto.

            { rewrite Zlength_map; auto. }

            { rewrite HT1; auto. }

            apply sepcon_derives_prop; auto. }

          intro Hindex; apply derives_view_shift; Exists (map_upd s' (j + 1) v) H'

            (upd_Znth (i1 mod size) T1 (k, map_upd s' (j + 1) v)).

          pose proof (entries_absorb k i i1 T1 lgk lgv (map fst T)) as Habsorb; sep_apply Habsorb; auto.

          unfold share; entailer!.

          { destruct (H' k) eqn: Hk.

            { match goal with H : forall _ _, _ <-> _ |- _ => rewrite H in Hk end.

              destruct Hk as (Hk & ? & ? & Hnz).

              eapply In_Znth in Hk; destruct Hk as (i' & ? & Hk).

              match goal with H : wf_table T1 |- _ => exploit (H k i'); rewrite ?Hk; auto end.

              intro X; rewrite X in Hindex; inv Hindex.

              rewrite Hk in HT1; inv HT1.

              contradiction Hnz; eapply value_of_inj; eauto. }

            split; auto.

            assert (Zlength (upd_Znth (i1 mod size) T1 (k, map_upd s' (j + 1) v)) = size)

              by (rewrite upd_Znth_Zlength; auto; omega).

            split; auto.

            split; [apply wf_table_upd; auto|].

            unfold map_upd at 1.

            intro k0; if_tac.

            * split; [intro X; inv X; split; eauto; apply upd_Znth_In|].

              subst; intros (Hin & ?).

              apply In_Znth with (d := (0, empty_map)) in Hin; destruct Hin as (i' & Hi' & Hith).

              destruct (eq_dec i' (i1 mod size)).

              { subst; rewrite upd_Znth_same in Hith by omega; inv Hith; auto. }

              rewrite upd_Znth_diff' in Hith by (auto; omega).

              match goal with H : wf_table T1 |- _ => exploit (H k i'); rewrite ?Hith; auto; congruence end.

            * etransitivity; eauto; split; intros (Hin & ?); split; auto.

              -- eapply In_upd_Znth_old; auto; try omega.

                 intro X; rewrite <- X in HT1; inv HT1; contradiction.

              -- apply In_upd_Znth in Hin; destruct Hin as [X|]; [inv X; tauto | auto]. }

          erewrite sepcon_comm, (sepcon_comm _ (ghost _ _)), <- sepcon_assoc, replace_nth_sepcon, upd_entries;

            eauto; contradiction.

        * simpl; view_shift_intro H'.

          unfold v_T; view_shift_intros.

          unfold hashtable; view_shift_intro T1; view_shift_intros.

          rewrite extract_nth_sepcon with (i := (i1 mod size))(l := map _ (upto (Z.to_nat size))) by (rewrite Zlength_map; auto).

          erewrite Znth_map, Znth_upto by (auto; rewrite Z2Nat.id; omega).

          unfold hashtable_entry at 1.

          destruct (Znth (i1 mod size) T1 (0, empty_map)) as (k', lv) eqn: HT1; view_shift_intros.

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh1, _) (Znth _ lgk _))).

          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap k _)).

          rewrite snap_master_join by auto; view_shift_intros.

          match goal with H : zero_ord k _ |- _ => destruct H; [contradiction | subst k'] end.

          rewrite (sepcon_comm _ (ghost (gsh1, lv) _)).

          rewrite <- !sepcon_assoc, sepcon_comm.

          rewrite <- !sepcon_assoc; setoid_rewrite snap_master_join; auto; view_shift_intros.

          apply derives_view_shift; Exists H' T1.

          pose proof (entries_absorb k i i1 T1 lgk lgv (map fst T)) as Habsorb; sep_apply Habsorb; auto.

          entailer!.

          { assert (H' k = Some lv) as Hk; [|rewrite Hk in *; discriminate].

            match goal with H : forall _ _, _ <-> _ |- _ => rewrite H end.

            split; [rewrite <- HT1; apply Znth_In; omega|].

            match goal with H : exists v, _ |- _ => destruct H as (? & ? & ? & Hz) end.

            do 2 eexists; eauto.

            intro X; specialize (Hz X).

            match goal with H : value_of s' _ |- _ => destruct H as (? & ? & ?); eauto end. }

          erewrite sepcon_comm, (sepcon_comm _ (ghost _ _)), <- sepcon_assoc, replace_nth_sepcon, upd_Znth_triv;

            auto.

          { rewrite Zlength_map; auto. }

          { rewrite Znth_map', Znth_upto by (rewrite Zlength_upto in *; omega).

            unfold hashtable_entry.

            rewrite HT1, prop_true_andp, sepcon_comm; auto. }

        * if_tac.

          -- view_shift_intro H'.

             etransitivity; [|etransitivity; [apply view_shift_sepcon1, HQ | apply derives_view_shift;

               Exists H'; rewrite sepcon_assoc; eauto]].

             view_shift_intro H''; view_shift_intros; subst.

             apply derives_view_shift; entailer!.

             split; auto.

          -- view_shift_intro H'.

             etransitivity; [|etransitivity; [apply view_shift_sepcon1, HQ | apply derives_view_shift;

               Exists H'; rewrite sepcon_assoc; eauto]].

             view_shift_intros; subst; apply derives_view_shift; entailer!.

             { split; [|discriminate].

              split; [contradiction | discriminate]. }

             admit. }

      Intros x H'; destruct x as (v', lvi').

      gather_SEP 3 2 6; rewrite <- !sepcon_assoc, replace_nth_sepcon.

      erewrite <- upd_entries_A; eauto; try contradiction; try (if_tac; contradiction).

      unfold POSTCONDITION, abbreviate; simpl map.

      forward.

      Exists (if eq_dec v' 0 then true else false, lvi') H' (upd_Znth (i1 mod size) T (k, lvi')); entailer!.

      split; [etransitivity; eauto; apply table_incl_upd; rewrite ?HTi; auto; try omega; etransitivity; eauto|].

      exists (i1 mod size); split; [|rewrite upd_Znth_same; auto; omega].

      apply lookup'_succeeds with (i := i); auto; [|rewrite upd_Znth_same; auto; omega].

      replace (i1 mod size) with ((i + hash k) mod size); replace size with (Zlength T).

      rewrite rebase_upd', sublist_upd_Znth_l by (rewrite ?Zlength_rebase; omega).

      match goal with H : Forall _ (sublist _ _ _) |- _ => rewrite rebase_map, sublist_map, Forall_map in H end.

      eapply Forall_impl; eauto; simpl; auto.

  - Intros i i1 T.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) (i1 + 1) T; entailer!.

    split.

    { rewrite <- Zplus_mod_idemp_l.

      replace (i1 mod _) with ((i + hash k) mod size); simpl.

      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }

    admit. 

Admitted.



Opaque Znth.



Lemma body_init_table : semax_body Vprog Gprog f_init_table init_table_spec.

Proof.

  start_function.

  forward_for_simple_bound size (EX i : Z, EX entries : list (val * val),

    PROP (Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength entries = i)

    LOCAL (gvar _m_entries p)

    SEP (@data_at CompSpecs Ews (tarray tentry size) (entries ++ repeat (Vundef, Vundef) (Z.to_nat (size - i))) p;

         fold_right sepcon emp (map (fun x =>

           malloc_token Tsh (sizeof tint) (fst x) * malloc_token Tsh (sizeof tint) (snd x)) entries);

         fold_right sepcon emp (map (fun '(pk, pv) => data_at Tsh tint (vint 0) pk) entries);

         fold_right sepcon emp (map (fun '(pk, pv) => data_at Tsh tint (vint 0) pv) entries))).

  { pose proof size_pos; split; [computable | omega]. }

  { setoid_rewrite (proj2_sig has_size); computable. }

  - go_lower.

    Exists (@nil (val * val)); entailer!.

    { setoid_rewrite (proj2_sig has_size); auto. }

    rewrite data_at__eq; unfold default_val; simpl.

    rewrite repeat_list_repeat, Z.sub_0_r; auto.

  - rewrite sepcon_map.

    forward_malloc tint pk.

    repeat forward.

    forward_malloc tint pv.

    repeat forward.

    assert (0 <= i < Zlength (x ++ repeat (Vundef, Vundef) (Z.to_nat (size - i)))).

    { rewrite Zlength_app, Zlength_repeat, Z2Nat.id; omega. }

    rewrite upd_Znth_twice, upd_Znth_same by auto.

    go_lower; Exists (x ++ [(pk, pv)]).

    rewrite !map_app, !sepcon_app, upd_init, <- app_assoc, sepcon_map by (auto; omega).

    rewrite Zlength_app, Zlength_cons, Zlength_nil; simpl; entailer!; auto.

    split; [setoid_rewrite (proj2_sig has_size); auto|].

    rewrite Forall_app; repeat constructor; auto.

  - Intros entries.

    rewrite Zminus_diag, app_nil_r.

    pose proof size_pos.

    eapply ghost_list_alloc' with (g := (Tsh, 0))(i := size); auto with init; try omega.

    Intros lgk.

    eapply ghost_list_alloc' with (g := (Tsh, singleton 0 0))(i := size); auto with init; try omega.

    Intros lgv.

    gather_SEP 4 5 0 1; rewrite <- sepcon_assoc, <- sepcon_map.

    eapply view_shift_trans; [|reflexivity|].

    { rewrite (list_Znth_eq (Vundef, Vundef) entries).

      replace (length entries) with (Z.to_nat size).

      rewrite map_map, <- 2sepcon_map.

      apply view_shift_sepcon_list.

      { rewrite 2Zlength_map; reflexivity. }

      rewrite Zlength_map; intros.

      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).

      instantiate (1 := fun i => hashtable_entry_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries i *

        hashtable_entry (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv i); simpl.

      unfold hashtable_entry_A, hashtable_entry.

      rewrite Znth_repeat' by (rewrite Zlength_upto in *; auto).

      erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).

      destruct (Znth i entries (Vundef, Vundef)).

      erewrite <- (master_share_join _ _ _ 0) by eauto.

      rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, 0) _)).

      rewrite <- !sepcon_assoc, 2sepcon_assoc.

      rewrite (sepcon_comm (ghost (gsh2, 0) _)); etransitivity; [apply view_shift_sepcon1|].

      { etransitivity; [|apply (@make_protocol _ _ zero_ord _ _ (k_prot (Znth i lgk Vundef)) v 0 0); auto].

        unfold k_T; apply derives_view_shift; entailer!. }

      erewrite <- (master_share_join _ _ _ (singleton 0 0)) by eauto.

      rewrite sepcon_comm, <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) _)).

      rewrite <- !sepcon_assoc, 2sepcon_assoc.

      assert (forall j v', singleton 0 0 j = Some v' -> v' = 0).

      { intros ??; unfold singleton; if_tac; intro X; inv X; auto. }

      etransitivity; [apply view_shift_sepcon1|].

      { etransitivity; [|apply (@make_protocol _ _ map_incl _ _ (v_prot (Znth i lgv Vundef)) v0 0 (singleton 0 0)); auto].

        unfold v_T; apply derives_view_shift; entailer!. }

      apply derives_view_shift; entailer!.

      { split; eauto. }

      { replace size with (Zlength entries); apply ZtoNat_Zlength. } }

    rewrite sepcon_map.

    eapply (@ghost_alloc _ _ exclusive_PCM (Some (fun _ => None))).

    { exists None; exists (Some (fun _ : Z => @None (Z -> option Z))); simpl; auto. }

    Intro g.

    forward.

    unfold hashtable, hashtable_A.

    Exists entries g lgk lgv (repeat (0, singleton 0 0) (Z.to_nat size)); entailer!.

    { split; [rewrite Zlength_repeat, Z2Nat.id; auto; pose proof size_pos; omega|].

      split.

      + intros ??? Hj.

        destruct (zlt i 0); [rewrite Znth_underflow in Hj by auto; subst; contradiction|].

        destruct (zlt i size); [rewrite Znth_repeat' in Hj | rewrite Znth_overflow in Hj]; subst; try contradiction.

        * rewrite Z2Nat.id; omega.

        * rewrite Zlength_repeat, Z2Nat.id; omega.

      + split; [discriminate|].

        intros (Hin & ?); apply repeat_spec in Hin; inv Hin.

        match goal with H : exists v, _ |- _ => destruct H as (? & (? & Heq & ?) & ?) end.

        unfold singleton in Heq; destruct (eq_dec _ _); inv Heq; contradiction. }

    erewrite map_ext; eauto; intros (?, ?); auto.

Qed.



Lemma lock_struct_array : forall sh z (v : list val) p,

  data_at sh (tarray (tptr (Tstruct _lock_t noattr)) z) v p =

  data_at sh (tarray (tptr tlock) z) v p.

Proof.

  intros.

  unfold data_at, field_at, at_offset; rewrite !data_at_rec_eq; simpl; f_equal.

Qed.



Lemma f_pred_precise : forall tsh sh gsh (entries : list (val * val)) gh g lgk lgv p t locksp lockt resultsp res,

  readable_share sh -> Zlength lgk = Zlength entries -> Zlength lgv = Zlength entries ->

  precise (f_lock_pred tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res).

Proof.

  intros; unfold f_lock_pred.

  apply selflock_precise.

  unfold f_lock_inv.

  eapply derives_precise' with (Q := (EX g : option (share * hist) * option hist, ghost g gh) *

    data_at_ _ _ _ * invariant (hashtable_inv gh g lgk lgv) *

    hashtable_A _ _ _ _ * data_at_ sh _ _ * data_at_ _ _ _ * data_at_ _ _ _).

  - Intros b1 b2 b3 h.

    repeat (apply sepcon_derives; try apply data_at_data_at_); eauto.

    unfold ghost_hist.

    Exists (Some (gsh, h), @None hist); auto.

  - repeat (apply precise_sepcon; auto).

    + apply ex_ghost_precise.

    + apply invariant_precise.

    + apply precise_fold_right.

      rewrite Forall_map, Forall_forall; intros; simpl.

      unfold hashtable_entry_A.

      destruct (Znth x entries (Vundef, Vundef)).

      rewrite Znth_repeat' by (rewrite In_upto in *; auto).

      apply precise_sepcon; [apply precise_andp2|]; apply protocol_A_precise.

Qed.



Lemma f_pred_positive : forall tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res,

  positive_mpred (f_lock_pred tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res).

Proof.

  intros; apply selflock_positive.

Qed.

Hint Resolve f_pred_precise f_pred_positive.



Lemma apply_hist_app : forall h1 h2 H H', apply_hist H (h1 ++ h2) H' <->

  exists H1, apply_hist H h1 H1 /\ apply_hist H1 h2 H'.

Proof.

  induction h1; auto; simpl; intros.

  { split; [|intros (? & ? & ?)]; subst; eauto. }

  destruct a.

  - split.

    + intros (? & ? & H1); rewrite IHh1 in H1.

      destruct H1 as (? & ? & ?); eauto.

    + intros (? & (? & ? & ?) & ?); eexists; rewrite IHh1; eauto.

  - split.

    + intros (? & H1); rewrite IHh1 in H1.

      destruct H1 as (? & ? & ?); eauto.

    + intros (? & (? & ?) & ?); rewrite IHh1; eauto.

  - split.

    + destruct r.

      * intros (? & ? & ? & H1); rewrite IHh1 in H1.

        destruct H1 as (? & ? & ?); eauto 6.

      * intros (? & H1); rewrite IHh1 in H1.

        destruct H1 as (? & ? & ?); eauto.

    + destruct r.

      * intros (? & (? & ? & ? & ?) & ?); split; auto.

        eexists; rewrite IHh1; eauto.

      * intros (? & (? & ?) & ?); rewrite IHh1; eauto.

Qed.



Lemma hashtable_A_forget : forall T lgk lgv entries, Forall (fun '(_, lv) => map_incl (singleton 0 0) lv) T ->

  Zlength T = size ->

  view_shift (hashtable_A T lgk lgv entries)

             (hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries).

Proof.

  intros; apply view_shift_sepcon_list; rewrite !Zlength_map; auto; intros.

  erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).

  unfold hashtable_entry_A.

  destruct (Znth i entries (Vundef, Vundef)), (Znth i T (0, empty_map)) eqn: HTi.

  rewrite Zlength_upto in *.

  rewrite Znth_repeat' by auto.

  view_shift_intros.

  etransitivity; [apply view_shift_sepcon|].

  - apply protocol_A_forget with (s1 := 0); auto.

  - apply protocol_A_forget with (s1 := singleton 0 0).

    pose proof size_pos.

    eapply Forall_Znth with (i0 := i) in H; [|rewrite Z2Nat.id in *; omega].

    rewrite HTi in H; auto.

  - apply derives_view_shift; entailer!.

    exists 0; repeat split; auto.

    intros ???; unfold singleton; if_tac; intro X; inv X; auto.

Qed.



Lemma body_f : semax_body Vprog Gprog f_f f_spec.

Proof.

  start_function.

  rewrite (data_at_isptr Tsh); Intros.

  assert (force_val (sem_cast_neutral tid) = tid) as Htid.

  { destruct tid; try contradiction; auto. }

  focus_SEP 4.

  forward.

  rewrite <- lock_struct_array.

  forward.

  { entailer!.

    rewrite upd_Znth_same; auto. }

  forward.

  { entailer!.

    rewrite upd_Znth_same; auto. }

  rewrite !upd_Znth_same by auto.

  forward.

  forward_call (tid, sizeof tint).

  { rewrite !sepcon_assoc; apply sepcon_derives; [apply data_at_memory_block | cancel_frame]. }

  forward_for_simple_bound 3 (EX i : Z, EX ls : list bool,

    PROP (Zlength ls = i)

    LOCAL (temp _total (vint (Zlength (filter id ls))); temp _res res; temp _l lockt; temp _t (vint t);

           temp _arg tid; gvar _m_entries p; gvar _thread_locks locksp; gvar _results resultsp)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p; invariant (hashtable_inv gh g lgk lgv);

         hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries;

         EX h : _, !!(add_events [] (map (fun j => HAdd (j + 1) 1 (Znth j ls false)) (upto (Z.to_nat i))) h) &&

           ghost_hist gsh h gh;

         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

         data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

         data_at_ Tsh tint res;

         lock_inv tsh lockt (f_lock_pred tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res))).

  - Exists (@nil bool) (@nil (nat * hashtable_hist_el)); entailer!.

  - Intros h.

    forward_call (i + 1, 1, p, sh, entries, g, lgk, lgv, repeat (0, singleton 0 0) (Z.to_nat size), ghost_hist gsh h gh,

      fun (_ : Z -> option (Z -> option Z)) (x : (bool * (Z -> option Z))) => EX h' : _,

        !!(add_events h [HAdd (i + 1) 1 (fst x)] h') && ghost_hist gsh h' gh,

      fun H => ghost_hist gsh h gh * EX hr : _, !!(apply_hist empty_map hr H) && ghost_ref hr gh,

      fun _ : Z => hashtable_inv gh g lgk lgv, [0]).

    { simpl; entailer!.

      split; [split|].

      + pose proof (Int.min_signed_neg); omega.

      + transitivity 4; [omega | computable].

      + split; [|pose proof size_pos; rewrite Zlength_repeat, Z2Nat.id by omega; auto].

        match goal with H : Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries |- _ =>

          eapply Forall_impl, H end; intros (?, ?); auto. }

    { split; simpl; rewrite sepcon_emp.

      + unfold hashtable_inv; split; apply derives_view_shift; Intros HT; Exists HT; cancel.

      + intros HT (b, lv).

        view_shift_intro hr; view_shift_intros.

        rewrite sepcon_comm.

        rewrite (add_andp (ghost_hist _ _ _ * _) (!!hist_incl h hr)), andp_comm by (apply hist_ref_incl; auto).

        view_shift_intros.

        etransitivity; [apply view_shift_sepcon1|].

        { apply hist_add' with (e := HAdd (i + 1) 1 b); auto. }

        apply derives_view_shift.

        unfold hashtable_inv; Exists (h ++ [(length hr, HAdd (i + 1) 1 b)]); entailer!.

        { apply add_events_1, hist_incl_lt; auto. }

        Exists (if b then map_upd HT (Zlength x + 1) lv else HT) (hr ++ [HAdd (Zlength x + 1) 1 b]); entailer!.

        rewrite apply_hist_app; do 2 eexists; eauto; simpl.

        destruct b.

        * split; [tauto|].

          do 2 eexists; eauto.

          unfold HT_upd; do 2 eexists; eauto.

          match goal with H : _ <-> true = true |- _=> destruct H as (_ & Hc) end.

          rewrite Hc; auto.

        * split; auto.

          match goal with H : _ <-> false = true |- _=> destruct H as (Hc & _) end.

          intro X; specialize (Hc X); discriminate. }

    Intro y; destruct y as ((s, lv), HT); simpl.

    Intros T h'.

    focus_SEP 1; apply hashtable_A_forget; auto.

    { rewrite Forall_forall_Znth with (d := (0, empty_map)); intros j ?.

      match goal with H : table_incl _ _ |- _ => specialize (H j); rewrite Znth_repeat' in H by (rewrite Z2Nat.id; omega); destruct H end.

      destruct (Znth j T (0, empty_map)); auto. }

    match goal with |- semax _ (PROP () (LOCALx (?a :: ?b :: temp _total _ :: ?Q) (SEPx ?R))) _ _ =>

      forward_if (PROP () (LOCALx (a :: b :: temp _total (vint (Zlength (filter id (x ++ [s])))) :: Q)

                 (SEPx R))) end.

    + Intros; forward.

      subst; rewrite filter_app, Zlength_app; entailer!.

    + forward.

      subst; rewrite filter_app, Zlength_app; entailer!.

    + intros.

      unfold exit_tycon, overridePost.

      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

      Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

      Exists (x ++ [s]); rewrite ?Zlength_app, ?Zlength_cons, ?Zlength_nil; entailer!.

      Exists h'; entailer!.

      rewrite Z2Nat.inj_add, upto_app, map_app, Z2Nat.id by omega; change (upto (Z.to_nat 1)) with [0]; simpl.

      rewrite Z.add_0_r, app_Znth2, Zminus_diag, Znth_0_cons by omega.

      eapply add_events_trans; eauto.

      erewrite map_ext_in; eauto.

      intros j Hj; rewrite app_Znth1; auto.

      rewrite In_upto, Z2Nat.id in Hj; omega.

  - Intros ls h.

    forward.

    forward_call (lockt, tsh, f_lock_inv sh gsh entries gh g lgk lgv p t locksp lockt resultsp res,

                  f_lock_pred tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res).

    { assert_PROP (Zlength entries = size) by (pose proof size_pos; entailer!).

      lock_props.

      { apply f_pred_precise; auto; omega. }

      { apply selflock_rec. }

      unfold f_lock_pred at 2.

      rewrite selflock_eq.

      unfold f_lock_inv at 1.

      rewrite lock_struct_array.

      Exists (Znth 0 ls false) (Znth 1 ls false) (Znth 2 ls false) h; entailer!.

      rewrite (list_Znth_eq false ls) at 1.

      replace (length ls) with (Z.to_nat 3) by (symmetry; rewrite <- Zlength_length by computable; auto).

      cancel.

      subst Frame; instantiate (1 := []); simpl; rewrite sepcon_emp; apply lock_inv_later. }

    forward.

Qed.



Lemma lock_struct : forall p, data_at_ Tsh (Tstruct _lock_t noattr) p |-- data_at_ Tsh tlock p.

Proof.

  intros.

  unfold data_at_, field_at_; unfold_field_at 1%nat.

  unfold field_at, at_offset; simpl.

  rewrite field_compatible_cons; simpl; entailer!.

Qed.



Lemma add_fails : forall k v b l H H' (HH : apply_hist H l H') (Hadd : In (HAdd k v b) l)

  (Hk : H k <> None), b = false.

Proof.

  induction l; simpl; intros; [contradiction|].

  destruct a; try (destruct Hadd as [X|]; [inv X|]).

  - destruct HH as (? & (? & ? & ?) & ?); subst.

    eapply IHl; eauto.

    unfold map_upd; if_tac; auto; discriminate.

  - destruct HH; eauto.

  - destruct b; auto.

    destruct HH, (H k); [discriminate | contradiction].

  - destruct (H k0), r; destruct HH as (? & HH); try discriminate; eauto.

    destruct HH as (? & (? & ? & ?) & ?); subst.

    eapply IHl; eauto.

    unfold map_upd; if_tac; auto; discriminate.

Qed.



Lemma only_one_add_succeeds : forall k v1 v2 l i1 i2 H0 H (HH : apply_hist H0 l H)

  (Hin1 : Znth i1 l (HGet 0 0) = HAdd k v1 true) (Hin2 : Znth i2 l (HGet 0 0) = HAdd k v2 true),

  i2 = i1 /\ v2 = v1.

Proof.

  induction l; simpl; intros.

  { rewrite Znth_nil in Hin1; discriminate. }

  assert (i2 = i1); [|subst; rewrite Hin2 in Hin1; inv Hin1; auto].

  exploit (Znth_inbounds i1 (a :: l) (HGet 0 0)); [rewrite Hin1; discriminate|].

  exploit (Znth_inbounds i2 (a :: l) (HGet 0 0)); [rewrite Hin2; discriminate|].

  rewrite !Zlength_cons; intros.

  destruct (eq_dec i1 0), (eq_dec i2 0); subst; auto.

  - rewrite Znth_0_cons in Hin1; subst.

    rewrite Znth_pos_cons in Hin2 by omega.

    destruct HH as (? & ? & (? & ? & ?) & HH), (H0 k); [discriminate | subst].

    eapply add_fails in HH; [|rewrite <- Hin2; apply Znth_In; omega|]; [discriminate|].

    unfold map_upd; rewrite eq_dec_refl; discriminate.

  - rewrite Znth_0_cons in Hin2; subst.

    rewrite Znth_pos_cons in Hin1 by omega.

    destruct HH as (? & ? & (? & ? & ?) & HH), (H0 k); [discriminate | subst].

    eapply add_fails in HH; [|rewrite <- Hin1; apply Znth_In; omega|]; [discriminate|].

    unfold map_upd; rewrite eq_dec_refl; discriminate.

  - rewrite Znth_pos_cons in Hin1, Hin2 by omega.

    assert (i2 - 1 = i1 - 1); [|omega].

    destruct a.

    + destruct HH as (? & ? & ?); eapply IHl; eauto.

    + destruct HH, (H0 k0); eapply IHl; eauto.

    + destruct (H0 k0), r, HH as (? & HH); try discriminate; try solve [eapply IHl; eauto].

      destruct HH as (? & ? & ?); eapply IHl; eauto.

Qed.



Lemma one_add_succeeds : forall k v b l H0 H (HH : apply_hist H0 l H) (Hk : H0 k = None)

  (Hin : In (HAdd k v b) l) (Hout : forall v, ~In (HSet k v) l), exists v', In (HAdd k v' true) l.

Proof.

  induction l; simpl; intros; [contradiction|].

  assert (forall v, ~In (HSet k v) l).

  { intros v0 ?; contradiction (Hout v0); auto. }

  destruct a; try (destruct Hin as [X|]; [discriminate|]).

  - destruct (eq_dec k0 k); [contradiction (Hout v0); subst; auto|].

    destruct HH as (? & (? & ? & ?) & ?); subst.

    exploit IHl; eauto.

    { unfold map_upd; if_tac; auto; subst; contradiction. }

    intros (? & ?); eauto.

  - destruct (H0 k0), HH; exploit IHl; eauto; intros (? & ?); eauto.

  - destruct (eq_dec k0 k).

    + subst; rewrite Hk in HH.

      destruct r; [eauto | destruct HH; contradiction].

    + destruct Hin as [X|]; [inv X; contradiction|].

      destruct (H0 k0), r, HH as (? & HH); try discriminate; try solve [exploit IHl; eauto; intros (? & ?); eauto].

      destruct HH as (? & (? & ? & ?) & ?); subst.

      exploit IHl; eauto; [|intros (? & ?); eauto].

      unfold map_upd; if_tac; auto; subst; contradiction.

Qed.



Lemma filter_find_count : forall {A} (f : A -> bool) d l li (Hunique : NoDup li)

  (Hli : forall i, In i li -> f (Znth i l d) = true) (Hrest : forall i, ~In i li -> f (Znth i l d) = false),

  Zlength (filter f l) = Zlength li.

Proof.

  induction l; simpl; intros.

  - exploit (list_pigeonhole li (Zlength li + 1)); [omega|].

    intros (i' & ? & ?).

    destruct li; auto.

    exploit (Hli z); simpl; auto.

    exploit Hrest; eauto.

    rewrite !Znth_nil; intros ->; discriminate.

  - assert (f d = false) as Hd.

    { exploit (list_pigeonhole (upto (Z.to_nat (Zlength (a :: l))) ++ li)

       (Zlength (upto (Z.to_nat (Zlength (a :: l))) ++ li) + 1)); [omega|].

      intros (j' & ? & Hout); exploit (Hrest j').

      { intro X; contradiction Hout; rewrite in_app; auto. }

      rewrite Znth_overflow; auto.

      { destruct (zlt j' (Zlength (a :: l))); auto.

        contradiction Hout; rewrite in_app; left.

        rewrite In_upto, Z2Nat.id; omega. } }

    destruct (in_dec Z.eq_dec 0 li).

    + exploit Hli; eauto.

      rewrite Znth_0_cons; intros ->.

      rewrite Zlength_cons.

      exploit in_split; eauto; intros (li1 & li2 & ?); subst.

      apply NoDup_remove in Hunique; destruct Hunique.

      rewrite Zlength_app, Zlength_cons.

      erewrite (IHl (map (fun i => i - 1) (li1 ++ li2))), Zlength_map, Zlength_app; auto; try omega.

      * apply FinFun.Injective_map_NoDup; auto.

        intros ??; omega.

      * intros ? Hj; rewrite in_map_iff in Hj; destruct Hj as (j & ? & Hj); subst.

        exploit (Hli j).

        { rewrite in_insert_iff; auto. }

        destruct (eq_dec j 0); [subst; contradiction|].

        destruct (zlt j 0).

        { rewrite Znth_underflow, Hd by auto; discriminate. }

        rewrite Znth_pos_cons by omega; auto.

      * intros j Hj.

        destruct (zlt j 0); [rewrite Znth_underflow; auto|].

        specialize (Hrest (j + 1)); specialize (Hli (j + 1));

          rewrite Znth_pos_cons, Z.add_simpl_r in Hrest, Hli by omega.

        destruct (in_dec Z.eq_dec (j + 1) (li1 ++ 0 :: li2)); auto.

        rewrite in_insert_iff in i0; destruct i0; [omega|].

        contradiction Hj; rewrite in_map_iff; do 2 eexists; eauto; omega.

    + exploit Hrest; eauto.

      rewrite Znth_0_cons; intros ->.

      erewrite (IHl (map (fun i => i - 1) li)), Zlength_map; try omega.

      * apply FinFun.Injective_map_NoDup; auto.

        intros ??; omega.

      * intros ? Hj; rewrite in_map_iff in Hj; destruct Hj as (j & ? & Hj); subst.

        specialize (Hli _ Hj).

        destruct (eq_dec j 0); [subst; contradiction|].

        destruct (zlt j 0).

        { rewrite Znth_underflow, Hd in Hli by auto; discriminate. }

        rewrite Znth_pos_cons in Hli by omega; auto.

      * intros j Hj.

        destruct (zlt j 0); [rewrite Znth_underflow; auto|].

        specialize (Hrest (j + 1)); specialize (Hli (j + 1));

          rewrite Znth_pos_cons, Z.add_simpl_r in Hrest, Hli by omega.

        destruct (in_dec Z.eq_dec (j + 1) li); auto.

        contradiction Hj; rewrite in_map_iff; do 2 eexists; eauto; omega.

Qed.



Lemma hists_eq : forall lr (Hlr : Forall (fun '(h, ls) => add_events []

  [HAdd 1 1 (Znth 0 ls false); HAdd 2 1 (Znth 1 ls false); HAdd 3 1 (Znth 2 ls false)] h) lr)

  (Hlens : Forall (fun '(_, ls) => Zlength ls = 3) lr),

  map snd lr = map (fun x => map (fun e => match snd e with | HAdd _ _ b => b | _ => false end) (fst x)) lr.

Proof.

  intros; apply list_Znth_eq' with (d := []); rewrite !Zlength_map; auto.

  intros.

  rewrite !Znth_map with (d' := ([], [])) by auto.

  apply Forall_Znth with (i := j)(d := ([], [])) in Hlr; auto.

  apply Forall_Znth with (i := j)(d := ([], [])) in Hlens; auto.

  destruct (Znth j lr ([], [])); simpl.

  apply add_events_add in Hlr; destruct Hlr as (l' & ? & Heq); subst.

  destruct l0; [discriminate | rewrite Zlength_cons in *].

  destruct l0; [discriminate | rewrite Zlength_cons in *].

  destruct l0; [discriminate | rewrite Zlength_cons in *].

  destruct l0; [|rewrite Zlength_cons in *; pose proof (Zlength_nonneg l0); omega].

  destruct l' as [|(?, ?)]; [discriminate | inv Heq].

  destruct l' as [|(?, ?)]; [discriminate | match goal with H : map _ _ = _ |- _ => inv H end].

  destruct l' as [|(?, ?)]; [discriminate | match goal with H : map _ _ = _ |- _ => inv H end].

  destruct l'; [auto | match goal with H : map _ _ = _ |- _ => inv H end].

Qed.



Lemma add_three : forall lr HT l (Hlr : Zlength lr = 3)

  (Hhists : Forall (fun '(h, ls) => add_events [] [HAdd 1 1 (Znth 0 ls false); HAdd 2 1 (Znth 1 ls false);

     HAdd 3 1 (Znth 2 ls false)] h) lr) (Hlens : Forall (fun '(_, ls) => Zlength ls = 3) lr)

  (Hl : hist_list (concat (map fst lr)) l) (HHT : apply_hist empty_map l HT),

  Zlength (filter id (concat (map snd lr))) = 3.

Proof.

  intros.

  assert (Permutation.Permutation (filter id (concat (map snd lr)))

    (filter id (map (fun e => match e with HAdd _ _ b => b | _ => false end) l))) as Hperm.

  { apply Permutation_filter.

    apply hist_list_perm in Hl.

    etransitivity; [|apply Permutation.Permutation_map; eauto].

    rewrite map_map, concat_map, map_map, hists_eq; auto. }

  destruct Hl as (HNoDup & Hl).

  rewrite (Permutation_Zlength _ _ Hperm).

  assert (forall k v, ~ In (HSet k v) l).

  { repeat intro.

    apply In_nth_error in H; destruct H as (? & H).

    rewrite <- Hl, in_concat in H; destruct H as (? & ? & Hin).

    rewrite in_map_iff in Hin; destruct Hin as ((h, ?) & ? & Hin); subst.

    assert (In (HSet k v) (map snd h)) as Hin' by (rewrite in_map_iff; do 2 eexists; eauto; auto).

    rewrite Forall_forall in Hhists; specialize (Hhists _ Hin); simpl in Hhists.

    erewrite add_events_snd in Hin' by eauto; simpl in Hin'.

    decompose [or] Hin'; try discriminate; contradiction. }

  assert (forall i, 0 <= i < 3 -> In (HAdd (i + 1) 1 (Znth i (snd (Znth 0 lr ([], []))) false)) l) as Hins.

  { intros.

    assert (exists t, In (t, HAdd (i + 1) 1 (Znth i (snd (Znth 0 lr ([], []))) false)) (concat (map fst lr)))

      as (t & Hin).

    { setoid_rewrite in_concat; setoid_rewrite in_map_iff.

      exploit (Znth_In 0 lr ([], [])); [omega | intro Hin].

      rewrite Forall_forall in Hhists; specialize (Hhists _ Hin).

      destruct (Znth 0 lr ([], [])) as (h, ?); simpl in *.

      exploit (Znth_In i (map snd h) (HGet 0 0)).

      { erewrite add_events_snd; eauto; simpl.

        rewrite !Zlength_cons, Zlength_nil; auto. }

      intro Hin'; rewrite in_map_iff in Hin'; destruct Hin' as ((t, ?) & ? & Hin'); simpl in *; subst.

      erewrite add_events_snd in Hin' by eauto; simpl in Hin'.

      do 3 eexists; eauto.

      destruct (eq_dec i 0); [subst; apply Hin'|].

      destruct (eq_dec i 1); [subst; apply Hin'|].

      destruct (eq_dec i 2); [subst; apply Hin' | omega]. }

    rewrite Hl in Hin; eapply nth_error_in; eauto. }

  exploit (one_add_succeeds 1 1 (Znth 0 (snd (Znth 0 lr ([], []))) false) l); eauto.

  { eapply (Hins 0); auto; omega. }

  exploit (one_add_succeeds 2 1 (Znth 1 (snd (Znth 0 lr ([], []))) false) l); eauto.

  { eapply (Hins 1); auto; omega. }

  exploit (one_add_succeeds 3 1 (Znth 2 (snd (Znth 0 lr ([], []))) false) l); eauto.

  { eapply (Hins 2); auto; omega. }

  intros (v3 & Hin3) (v2 & Hin2) (v1 & Hin1).

  apply In_Znth with (d := HGet 0 0) in Hin1; destruct Hin1 as (t1 & ? & Ht1).

  apply In_Znth with (d := HGet 0 0) in Hin2; destruct Hin2 as (t2 & ? & Ht2).

  apply In_Znth with (d := HGet 0 0) in Hin3; destruct Hin3 as (t3 & ? & Ht3).

  rewrite filter_find_count with (d := false)(li := [t1; t2; t3]); auto; simpl.

  - repeat constructor; auto; simpl.

    + intros [|[|]]; try contradiction; subst.

      * rewrite Ht1 in Ht2; inv Ht2.

      * rewrite Ht1 in Ht3; inv Ht3.

    + intros [|]; try contradiction; subst.

      rewrite Ht2 in Ht3; inv Ht3.

  - intros ? [|[|[|]]]; try contradiction; subst; erewrite Znth_map by auto.

    + rewrite Ht1; auto.

    + rewrite Ht2; auto.

    + rewrite Ht3; auto.

  - intros i Hi.

    destruct (zlt i 0); [rewrite Znth_underflow; auto|].

    destruct (zlt i (Zlength l)); [|rewrite Znth_overflow by (rewrite Zlength_map; omega); auto].

    erewrite Znth_map with (d' := HGet 0 0) by omega.

    destruct (Znth i l (HGet 0 0)) eqn: Hith; auto.

    destruct r; auto.

    contradiction Hi.

    assert (k = 1 \/ k = 2 \/ k = 3) as Hk.

    { rewrite <- (Z2Nat.id i), <- nth_Znth in Hith by omega.

      exploit nth_error_nth; [apply Nat2Z.inj_lt; rewrite Z2Nat.id, <- Zlength_correct; eauto; omega|].

      rewrite Hith; intro Hin.

      rewrite <- Hl, in_concat in Hin; destruct Hin as (? & ? & Hin).

      rewrite in_map_iff in Hin; destruct Hin as ((h, ?) & ? & Hin); subst.

      assert (In (HAdd k v true) (map snd h)) as Hin' by (rewrite in_map_iff; do 2 eexists; eauto; auto).

      rewrite Forall_forall in Hhists; specialize (Hhists _ Hin); simpl in Hhists.

      erewrite add_events_snd in Hin' by eauto; destruct Hin' as [X | [X | [X | X]]]; inv X; auto. }

    destruct Hk as [|[|]]; [left | right; left | right; right; left];

      match goal with |-?P => assert (P /\ Znth (k - 1) [v1; v2; v3] 0 = v); [|tauto] end;

      subst; eapply only_one_add_succeeds; eauto.

Qed.



Lemma hashtable_A_join : forall lgk lgv entries,

  hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries * hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries =

  hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries.

Proof.

  intros; unfold hashtable_A; rewrite <- sepcon_map.

  erewrite map_ext_in; eauto; intros.

  unfold hashtable_entry_A.

  destruct (Znth a entries (Vundef, Vundef)).

  rewrite Znth_repeat' by (rewrite In_upto in *; auto).

  assert (forall v, value_of (singleton 0 0) v -> v = 0) as Hz.

  { intros ? (? & Hz & ?); unfold singleton in Hz; destruct (eq_dec _ _); inv Hz; auto. }

  rewrite !sepcon_andp_prop', sepcon_andp_prop, <- andp_assoc, andp_dup.

  rewrite (sepcon_comm (k_state _ _ _ _)) at 1.

  erewrite <- sepcon_assoc, (sepcon_assoc (v_state _ _ _ _)), protocol_A_join by apply join_refl.

  erewrite (sepcon_comm (v_state _ _ _ _)), sepcon_assoc, protocol_A_join by apply join_refl; auto.

Qed.



Lemma body_main : semax_body Vprog Gprog f_main main_spec.

Proof.

  name m_entries _m_entries.

  name locksp _thread_locks.

  name resp _results.

  name keys _keys.

  name values _values.

  start_function.

  replace 16384 with size by (setoid_rewrite (proj2_sig has_size); auto).

  forward.

  forward_call m_entries.

  { fast_cancel. }

  Intros x; destruct x as (((entries, g), lgk), lgv).

  apply ghost_alloc with (g0 := (Some (Tsh, [] : hist), Some ([] : hist))); auto with init.

  Intro gh.

  rewrite <- hist_ref_join_nil by (apply Share.nontrivial); Intros.

  gather_SEP 4 1; apply make_inv with (Q := hashtable_inv gh g lgk lgv).

  { unfold hashtable_inv, hashtable; Exists (@empty_map Z (Z -> option Z)) (@nil hashtable_hist_el); entailer!. }

  { unfold hashtable_inv, hashtable, hashtable_entry; prove_objective.

    destruct (Znth _ _ _); auto with objective. }

  destruct (split_shares 3 Ews) as (sh0 & shs & ? & ? & ? & Hshs); auto.

  destruct (split_shares 3 Tsh) as (sh0' & shs' & ? & ? & ? & Hshs'); auto.

  destruct (split_readable_share Tsh) as (sh1 & sh2 & ? & ? & ?); auto.

  rewrite <- seq_assoc.

  set (f_lock j l r := f_lock_pred sh2 (Znth j shs Ews) (Znth j shs' Tsh) entries gh g lgk lgv m_entries

                                         j locksp l resp r).

  forward_for_simple_bound 3 (EX i : Z, PROP ()

    LOCAL (temp _total (vint 0); lvar _values (tarray tint size) values;

           lvar _keys (tarray tint size) keys; gvar _results resp;

           gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs Ews (tarray tentry size) entries m_entries;

         data_at_ Tsh (tarray tint size) values; data_at_ Tsh (tarray tint size) keys;

         invariant (hashtable_inv gh g lgk lgv); ghost_hist Tsh ([] : hist) gh;

         fold_right sepcon emp (map (fun x => malloc_token Tsh 4 (fst x) * malloc_token Tsh 4 (snd x))

           entries); hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries;

         EX res : list val, !!(Zlength res = i) &&

           data_at Ews (tarray (tptr tint) 3) (res ++ repeat Vundef (Z.to_nat (3 - i))) resp *

           fold_right sepcon emp (map (data_at_ Tsh tint) res) *

           fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) res) *

         EX locks : list val, !!(Zlength locks = i) &&

           data_at Ews (tarray (tptr (Tstruct _lock_t noattr)) 3)

             (locks ++ repeat Vundef (Z.to_nat (3 - i))) locksp *

           fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) locks) *

           fold_right sepcon emp (map (fun j => lock_inv Tsh (Znth j locks Vundef)

             (f_lock j (Znth j locks Vundef) (Znth j res Vundef))) (upto (Z.to_nat i))))).

  { Exists (@nil val) (@nil val); rewrite !data_at__eq; entailer!.

    erewrite map_ext; eauto; intros (?, ?); auto. }

  { 

    Intros res locks.

    forward_malloc (Tstruct _lock_t noattr) l.

    rewrite sepcon_map; Intros.

    forward.

    forward_malloc tint r.

    forward.

    focus_SEP 3.

    forward_call (l, Tsh, f_lock i l r).

    { rewrite !sepcon_assoc; apply sepcon_derives; [apply lock_struct | cancel_frame]. }

    Exists (res ++ [r]) (locks ++ [l]); rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; entailer!.

    rewrite lock_inv_isptr, data_at__isptr; Intros.

    rewrite Z2Nat.inj_add, upto_app, !map_app, !sepcon_app by omega.

    simpl; change (upto 1) with [0]; simpl.

    rewrite Z2Nat.id, Z.add_0_r by omega.

    replace (Zlength res + 1) with (Zlength (res ++ [r]))

      by (rewrite Zlength_app, Zlength_cons, Zlength_nil; auto).

    rewrite <- upd_complete_gen by omega.

    replace (Zlength (res ++ [r])) with (Zlength (locks ++ [l]))

      by (rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; auto; omega).

    rewrite <- upd_complete_gen by omega.

    rewrite !app_Znth2 by omega.

    replace (Zlength locks) with (Zlength res); rewrite Zminus_diag, !Znth_0_cons.

    destruct r; try contradiction.

    destruct l; try contradiction.

    rewrite sepcon_map; cancel.

    apply sepcon_list_derives; rewrite !Zlength_map, !Zlength_upto, <- Zlength_correct.

    { rewrite Z2Nat.id; auto; omega. }

    intros.

    erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, <- ?Zlength_correct, ?Z2Nat.id; auto; omega).

    rewrite !app_Znth1 by omega; auto. }

  Intros res locks.

  rewrite !app_nil_r.

  assert_PROP (Zlength entries = size) by (pose proof size_pos; entailer!).

  rewrite <- seq_assoc.

  forward_for_simple_bound 3 (EX i : Z, EX sh : share,

    PROP (sepalg_list.list_join sh0 (sublist i 3 shs) sh)

    LOCAL (temp _total (vint 0); lvar _values (tarray tint size) values; lvar _keys (tarray tint size) keys;

           gvar _results resp; gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries m_entries;

         data_at_ Tsh (tarray tint size) values; data_at_ Tsh (tarray tint size) keys;

         invariant (hashtable_inv gh g lgk lgv);

         EX sh' : _, !!(sepalg_list.list_join sh0' (sublist i 3 shs') sh') && ghost_hist sh' ([] : hist) gh;

         fold_right sepcon emp (map (fun x => malloc_token Tsh 4 (fst x) * malloc_token Tsh 4 (snd x))

           entries); hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries;

         data_at sh (tarray (tptr tint) 3) res resp;

         fold_right sepcon emp (map (data_at_ Tsh tint) (sublist i 3 res));

         fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) res);

         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) locks);

         fold_right sepcon emp (map (fun j => lock_inv (if zlt j i then sh1 else Tsh) (Znth j locks Vundef)

           (f_lock j (Znth j locks Vundef) (Znth j res Vundef))) (upto 3)))).

  { rewrite !sublist_same by auto; Exists Ews Tsh; entailer!. }

  { 

    forward_malloc tint t.

    Intros sh'.

    rewrite sepcon_map; Intros.

    forward.

    simpl in *; assert (3 <= Zlength shs) by omega.

    match goal with H : sepalg_list.list_join sh0 _ _ |- _ => rewrite sublist_next with (d := Ews) in H by auto;

      inversion H as [|????? Hj1 Hj2]; subst end.

    apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (sh3 & ? & Hj3).

    assert (3 <= Zlength shs') by omega.

    match goal with H : sepalg_list.list_join sh0' _ _ |- _ => rewrite sublist_next with (d := Tsh) in H by auto;

      inversion H as [|????? Hj1' Hj2']; subst end.

    apply sepalg.join_comm in Hj1'; destruct (sepalg_list.list_join_assoc1 Hj1' Hj2') as (sh3' & ? & Hj3').

    rewrite <- hashtable_A_join.

    rewrite invariant_duplicable.

    get_global_function'' _f; Intros.

    apply extract_exists_pre; intros f_.

    forward_spawn (share * share * share * list (val * val) * val * val * list val * list val * val * Z * val * val * val * val)%type

      (f_, t, (fun x : (share * share * share * list (val * val) * val * val * list val * list val * val * Z * val * val * val * val) =>

        let '(sh, gsh, tsh, entries, gh, g, lgk, lgv, p, t, locksp, lockt, resultsp, res) := x in

        [(_m_entries, p); (_thread_locks, locksp); (_results, resultsp)]),

        (Znth i shs Ews, Znth i shs' Tsh, sh2, entries, gh, g, lgk, lgv, m_entries, i, locksp, Znth i locks Vundef, resp,

               Znth i res Vundef),

    fun (x : (share * share * share * list (val * val) * val * val * list val * list val * val * Z * val * val * val * val)%type)

        (tid : val) =>

    let '(sh, gsh, tsh, entries, gh, g, lgk, lgv, p, t, locksp, lockt, resultsp, res) := x in

    fold_right sepcon emp

      [!!(0 <= t < 3 /\ isptr lockt /\ readable_share sh /\ readable_share tsh /\ gsh <> Share.bot /\

          Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lgk = size /\ Zlength lgv = size) && emp;

        data_at sh (tarray tentry size) entries p; invariant (hashtable_inv gh g lgk lgv);

        hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries; ghost_hist gsh (@nil (nat * hashtable_hist_el)) gh;

        data_at Tsh tint (vint t) tid; malloc_token Tsh (sizeof tint) tid;

        data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

        data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

        data_at_ Tsh tint res;

        lock_inv tsh lockt (f_lock_pred tsh sh gsh entries gh g lgk lgv p t locksp lockt resultsp res)]).

    { unfold spawn_pre; go_lower.

      erewrite gvar_eval_var, !(force_val_sem_cast_neutral_gvar' _ f_), !force_val_sem_cast_neutral_isptr' by

        (rewrite ?force_val_sem_cast_neutral_isptr'; eauto).

      assert (0 <= i < Zlength shs) by omega.

      assert (Znth i shs' Tsh <> Share.bot).

      { intro X; contradiction unreadable_bot; rewrite <- X.

        apply Forall_Znth; auto; omega. }

      rewrite (extract_nth_sepcon (map _ (upto 3)) i) by (rewrite Zlength_map; auto).

      erewrite Znth_map, Znth_upto by (auto; simpl; omega).

      destruct (zlt i i); [omega|].

      rewrite lock_inv_isptr; Intros.

      Exists _arg; entailer!.

      { repeat split; try apply gvar_denote_global; auto.

        apply Forall_Znth; auto. }

      rewrite !sepcon_assoc; apply sepcon_derives.

      { apply derives_refl'.

        f_equal; f_equal; extensionality.

        destruct x0 as (?, x0); repeat destruct x0 as (x0, ?); simpl.

        extensionality; apply mpred_ext; entailer!. }

      rewrite <- !(data_at_share_join _ _ _ _ _ _ Hj3).

      rewrite (add_andp (ghost_hist _ _ _) (!!disjoint ([] : hist) [])) by entailer!.

      rewrite andp_comm, <- (ghost_hist_join _ _ _ _ _ _ _ Hj3'); auto.

      rewrite <- (lock_inv_share_join sh1 sh2) by auto.

      fast_cancel; cancel.

      rewrite (sepcon_comm _ (data_at (Znth i shs Ews) _ _ locksp)), !sepcon_assoc; apply sepcon_derives.

      { rewrite lock_struct_array; apply stronger_array_ext.

        - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.

        - intros j ???; unfold unfold_reptype; simpl.

          destruct (eq_dec j i).

          + subst; rewrite upd_Znth_same; auto.

          + rewrite upd_Znth_diff by auto.

            rewrite Znth_repeat with (x1 := Vundef)(n0 := 3%nat); apply stronger_default_val. }

      rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at (Znth i shs Ews) _ _ resp)),

        !sepcon_assoc; apply sepcon_derives.

      { apply stronger_array_ext.

        - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.

        - intros j ???; unfold unfold_reptype; simpl.

          destruct (eq_dec j i).

          + subst; rewrite upd_Znth_same; auto.

          + rewrite upd_Znth_diff' by auto.

            rewrite Znth_repeat with (x1 := Vundef)(n0 := 3%nat); apply stronger_default_val. }

      erewrite sublist_next by (auto; omega); simpl; fast_cancel.

      { intro; subst; contradiction unreadable_bot.

        eapply join_readable1, readable_share_list_join; eauto. } }

    go_lower.

    Exists sh3 sh3'; rewrite sepcon_map; entailer!.

    rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; rewrite !Zlength_map;

      auto.

    intros j ?; destruct (eq_dec j i).

    - subst; rewrite upd_Znth_same by auto.

      erewrite Znth_map, Znth_upto by (auto; simpl; omega).

      if_tac; [auto | omega].

    - rewrite upd_Znth_diff' by auto.

      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).

      if_tac; if_tac; auto; omega. }

  Intros sh sh'.

  rewrite sublist_nil.

  repeat match goal with H : sepalg_list.list_join _ (sublist 3 3 _) _ |- _ =>

    rewrite sublist_nil in H; inv H end.

  forward_for_simple_bound 3 (EX i : Z, EX x : (share * (list (hist * list bool))),

    PROP (readable_share (fst x); sepalg_list.list_join (fst x) (sublist i 3 shs) Ews; Zlength (snd x) = i;

          Forall (fun p => let '(h, ls) := p in add_events []

            [HAdd 1 1 (Znth 0 ls false); HAdd 2 1 (Znth 1 ls false); HAdd 3 1 (Znth 2 ls false)] h) (snd x);

          Forall (fun '(h, ls) => Zlength ls = 3) (snd x))

    LOCAL (let ls := map snd (snd x) in temp _total (vint (Zlength (filter id (concat ls))));

           lvar _values (tarray tint size) values; lvar _keys (tarray tint size) keys; gvar _results resp;

           gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs (fst x) (tarray tentry size) entries m_entries;

         invariant (hashtable_inv gh g lgk lgv);

         EX sh' : share, !!(readable_share sh' /\ sepalg_list.list_join sh' (sublist i 3 shs') Tsh) &&

           let h := map fst (snd x) in ghost_hist sh' (concat h) gh;

         fold_right sepcon emp (map (fun x => malloc_token Tsh 4 (fst x) * malloc_token Tsh 4 (snd x))

           entries); hashtable_A (repeat (0, singleton 0 0) (Z.to_nat size)) lgk lgv entries;

         data_at_ Tsh (tarray tint size) values; data_at_ Tsh (tarray tint size) keys;

         data_at (fst x) (tarray (tptr tint) 3) res resp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) (sublist i 3 res));

         data_at (fst x) (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) (sublist i 3 locks));

         fold_right sepcon emp (map (fun j => lock_inv sh1 (Znth j locks Vundef)

           (f_lock j (Znth j locks Vundef) (Znth j res Vundef))) (sublist i 3 (upto 3))))).

  { rewrite !(sublist_same 0 3) by auto.

    Exists (sh, @nil (hist * list bool)) sh'; entailer!. }

  { 

    destruct x as (sh3, lr); Intros sh3'; simpl in *.

    erewrite sublist_next with (l := upto 3), Znth_upto by (auto; rewrite ?Zlength_upto; simpl; omega); simpl.

    rewrite lock_inv_isptr, sepcon_map; Intros.

    forward.

    forward_call (Znth i locks Vundef, sh1, f_lock i (Znth i locks Vundef) (Znth i res Vundef)).

    forward_call (Znth i locks Vundef, Tsh, sh2,

      |>f_lock_inv (Znth i shs Ews) (Znth i shs' Tsh) entries gh g lgk lgv m_entries i locksp (Znth i locks Vundef) resp (Znth i res Vundef),

      |>f_lock i (Znth i locks Vundef) (Znth i res Vundef)).

    { rewrite ?sepcon_assoc; rewrite <- sepcon_emp at 1; rewrite sepcon_comm; apply sepcon_derives;

        [repeat apply andp_right; auto; eapply derives_trans;

         try (apply precise_weak_precise || apply positive_weak_positive || apply rec_inv_weak_rec_inv); auto |].

      { apply later_positive; subst f_lock; simpl; auto. }

      { apply later_rec_lock, selflock_rec. }

      unfold f_lock at 2; unfold f_lock_pred.

      rewrite selflock_eq.

      rewrite <- !sepcon_assoc, (sepcon_comm _ (lock_inv _ _ _)), !sepcon_assoc, <- sepcon_assoc;

        apply sepcon_derives; [|cancel_frame].

      rewrite <- (lock_inv_share_join sh1 sh2 Tsh) by auto; unfold f_lock, f_lock_pred; cancel.

      apply lock_inv_later. }

    erewrite sublist_next with (l := locks) by (auto; omega); simpl.

    forward_call (Znth i locks Vundef, sizeof (Tstruct _lock_t noattr)).

    { entailer!. }

    { entailer!. }

    { fast_cancel.

      apply sepcon_derives; [|cancel_frame].

      rewrite data_at__memory_block; Intros; auto. }

    unfold f_lock_inv at 1; Intros b1 b2 b3 hi.

    assert (0 <= i < Zlength shs) by omega.

    assert (readable_share (Znth i shs Ews)) by (apply Forall_Znth; auto).

    forward.

    { assert (0 <= i < 3) as Hi by auto; clear - Hi; entailer!.

      rewrite upd_Znth_same; auto. }

    rewrite upd_Znth_same by auto.

    forward.

    erewrite sublist_next with (l := res) by (auto; omega); simpl.

    forward_call (Znth i res Vundef, sizeof tint).

    { entailer!. }

    { entailer!. }

    { fast_cancel.

      rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at _ _ _ (Znth i res Vundef))), !sepcon_assoc;

        apply sepcon_derives; [|cancel_frame].

      apply data_at_memory_block. }

    assert (3 <= Zlength shs) by omega.

    match goal with H : sepalg_list.list_join sh3 _ _ |- _ => rewrite sublist_next with (d := Ews) in H by auto;

      inversion H as [|??? w1 ? Hj1]; subst end.

    match goal with H : sepalg_list.list_join sh3' _ _ |- _ => rewrite sublist_next with (d := Tsh) in H by (auto; omega);

      inversion H as [|??? w1' ? Hj1']; subst end.

    gather_SEP 16 2.

    replace_SEP 0 (data_at w1 (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp).

    { go_lower.

      rewrite <- lock_struct_array.

      eapply derives_trans; [apply data_at_array_value_cohere; auto|].

      erewrite data_at_share_join; eauto. }

    gather_SEP 14 3.

    replace_SEP 0 (data_at w1 (tarray (tptr tint) 3) res resp).

    { go_lower.

      eapply derives_trans; [apply data_at_array_value_cohere; auto|].

      erewrite data_at_share_join; eauto. }

    gather_SEP 5 6; rewrite <- invariant_duplicable.

    gather_SEP 9 10; rewrite hashtable_A_join.

    gather_SEP 7 4; erewrite ghost_hist_join; eauto.

    gather_SEP 6 5; erewrite data_at_share_join by eauto.

    forward.

    go_lower; Exists (w1, lr ++ [(hi, [b1; b2; b3])]) w1'; rewrite sepcon_map; entailer!.

    rewrite map_app, concat_app, filter_app, !Zlength_app, Zlength_cons, Zlength_nil; simpl;

      repeat (split; auto).

    - eapply join_readable1; eauto.

    - rewrite Forall_app; repeat constructor; auto.

    - rewrite Forall_app; repeat constructor; auto.

    - eapply join_readable1; eauto.

    - rewrite map_app, concat_app; simpl.

      rewrite app_nil_r; auto.

    - intro; subst; contradiction unreadable_bot.

    - intro X; contradiction unreadable_bot; rewrite <- X.

      apply Forall_Znth; auto; omega. }

  Intros x sh''; destruct x as (?, lr); simpl in *.

  repeat match goal with H : sepalg_list.list_join _ (sublist 3 3 _) _ |- _ =>

    rewrite sublist_nil in H; inv H end.

  gather_SEP 2 1; apply invariant_view_shift with (Q := !!(exists l HT, hist_list (concat (map fst lr)) l /\

    apply_hist empty_map l HT) && ghost_hist Tsh (concat (map fst lr)) gh).

  { eapply view_shift_assert; [|intro X; rewrite prop_true_andp by (apply X); reflexivity].

    unfold hashtable_inv; Intros HT hr.

    rewrite <- sepcon_assoc, (sepcon_comm _ (ghost_ref _ _)), <- sepcon_assoc,

      (sepcon_comm _ (ghost_hist _ _ _)).

    rewrite hist_ref_join by (apply Share.nontrivial).

    Intros h'; apply prop_right.

    exists hr, HT; split; auto.

    match goal with H : hist_sub _ _ _ |- _ => unfold hist_sub in H; rewrite eq_dec_refl in H; subst; auto end. }

  Intros.

  match goal with H : exists l HT, _ |- _ => destruct H as (? & ? & ? & ?) end.

Ltac entailer_for_return ::= idtac.

  unfold size, hf1; simpl.

  rewrite (proj2_sig has_size).

  forward.

  { entailer!. }

  rewrite <- (proj2_sig has_size).

  entailer!.

Qed.

