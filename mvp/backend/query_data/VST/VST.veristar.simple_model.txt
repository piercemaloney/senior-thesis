Load loadpath.
Require Import VST.msl.base VST.msl.sepalg VST.msl.psepalg VST.msl.predicates_sl VST.msl.functors
               VST.msl.sepalg_functors VST.msl.sepalg_generators.
Require Import veristar.variables veristar.model_type.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.model_type:
Load loadpath.
Require Import VST.msl.base VST.msl.sepalg.
Require Import veristar.variables.

Module Type VERISTAR_LOGIC.

Parameters loc val : Type.
Declare Instance Join_val: Join val.
Declare Instance Perm_val: Perm_alg val.
Declare Instance Sep_val: Sep_alg val.
Declare Instance Canc_val: Canc_alg val.
Parameter val2loc : val -> option loc.
Parameter nil_val : val.
Axiom nil_not_loc : val2loc nil_val = None.

Parameter empty_val : val.
Axiom emp_empty_val : forall v, identity v <-> v = empty_val.
Definition full (v : val) := forall v2, joins v v2 -> identity v2.
Axiom val2loc_full : forall v l, val2loc v = Some l -> full v.
Axiom nil_full : full nil_val.
Axiom empty_not_full : ~full empty_val.
Axiom val2loc_inj : forall v1 v2 l,
  val2loc v1 = Some l ->  val2loc v2 = Some l -> v1=v2.
Axiom loc_eq_dec : forall l1 l2 : loc, Decidable.decidable (l1=l2).
Axiom nil_dec : forall v, Decidable.decidable (v=nil_val).

Definition var : Type := Ident.t.
Parameter env : Type.
Parameter env_get : env -> var -> val.
Parameter env_set : var -> val -> env -> env.
Axiom gss_env : forall (x : var) (v : val) (s : env),
  v<>empty_val -> env_get (env_set x v s) x = v.
Axiom gso_env : forall (x y : var) (v : val) (s : env),
  x<>y -> env_get (env_set x v s) y = env_get s y.

Axiom env_reset : forall s x, env_set x (env_get s x) s = s.
Axiom env_reset2 : forall s x z, env_set x (env_get s x) (env_set x z s) = s.

Parameter heap : Type.
Declare Instance Join_heap: Join heap.
Declare Instance Perm_heap: Perm_alg heap.
Declare Instance Sep_heap: Sep_alg heap.
Declare Instance Canc_heap: Canc_alg heap.
Parameter rawnext: forall (x: loc) (y : val) (s : heap), Prop.
Parameter emp_at : forall (l: loc) (h: heap), Prop.
Axiom heap_gempty : forall h l, identity h -> emp_at l h.
Definition nil_or_loc (v: val) := v=nil_val \/ exists l, val2loc v = Some l.
Axiom mk_heap_rawnext : forall h x0 x y, val2loc (x0) = Some x ->
  nil_or_loc y -> exists h', rawnext x y h' /\ comparable h h'.
Axiom rawnext_out : forall {x x0 x' y h},
  rawnext x y h -> val2loc x0 = Some x' -> x'<>x -> emp_at x' h.

Definition rawnext' x y h := exists h0, join_sub h0 h /\ rawnext x y h0.

Axiom rawnext_at1 : forall {x y h1 h2 h},
  rawnext' x y h1 -> join h1 h2 h -> emp_at x h2 /\ rawnext' x y h.

Axiom rawnext_at2 : forall {x y h1 h2 h},
  join h1 h2 h -> rawnext' x y h -> emp_at x h2 -> rawnext' x y h1.

Axiom  rawnext_not_emp : forall {x y h}, rawnext' x y h -> ~emp_at x h.

Axiom emp_at_join: forall {h1 h2 h},
  join h1 h2 h -> forall l, (emp_at l h1 /\ emp_at l h2) <-> emp_at l h.

Axiom rawnext_unique : forall x z z' s s' t t' r,
  rawnext x z s -> rawnext x z' s' -> join s t r -> join s' t' r ->
  z' = z /\ s'=s.

Axiom vars_defined_locs : forall z (e : env),
  exists v, env_get e z = v /\ nil_or_loc v.

End VERISTAR_LOGIC. *)

Module BarebonesStates.
Definition loc := nat.
Definition val := option nat.
Definition var := Ident.t.
Definition env := var -> val.
Definition heap := loc -> val.
End BarebonesStates.

Module BarebonesLogic <: VERISTAR_LOGIC.
Import BarebonesStates.

Definition loc := loc.
Instance Join_loc : Join loc := @Join_equiv _.
Instance Perm_loc : Perm_alg loc := _.
Instance Sep_loc : Sep_alg loc := _.
Instance Canc_loc : Canc_alg loc := _.

Instance Join_nat : Join nat := @Join_discrete _.
Instance Pos_nat : @Pos_alg nat (@Join_discrete _) := @psa_discrete _.
Instance Canc_nat : @Canc_alg nat Join_nat.
unfold Canc_alg; intros ? ? ? ? H; inv H.
Qed.

Definition val := val.
Instance Join_val : Join val := Join_lower Join_nat.
Instance Perm_val : Perm_alg val := _.
Instance Sep_val : Sep_alg val := _.
Instance Canc_val : Canc_alg val := @Canc_lower _ _ _ Canc_nat.

Lemma identity_None: @identity _ Join_val None.
repeat intro. inv H; auto. Qed.
Hint Resolve identity_None.

Definition val2loc (v: val) : option loc :=
  match v with Some (S n) => Some (S n) | _ => None end.

Definition nil_val : val := Some O.

Lemma nil_not_loc: val2loc nil_val = None.
Proof. reflexivity. Qed.

Definition empty_val : val := None.

Lemma emp_empty_val v : identity v <-> v = empty_val.
destruct v; simpl; intuition; [symmetry; apply H; constructor|inv H].
Qed.

Definition full (v: val) := forall v2, joins v v2 -> identity v2.

Lemma val2loc_full v l : val2loc v = Some l -> full v.
intro H; destruct v as [[|n]|]; inv H.
unfold full; intros v2 [[x|] H]; inv H; auto; inversion H3.
Qed.

Lemma nil_full : full nil_val.
unfold full, nil_val; intros x H; inversion H as [x0 H0]; inv H0; auto; inv H2.
Qed.

Lemma empty_not_full : ~full empty_val.
unfold not, full, empty_val; intros. specialize (H (Some O)).
spec H. econstructor; constructor. specialize (H None (Some O)).
spec H. constructor. inv H.
Qed.

Lemma val2loc_inj v1 v2 l :
  val2loc v1 = Some l ->  val2loc v2 = Some l -> v1=v2.
unfold val2loc; intros. destruct v1; inv H. destruct n; inv H2.
destruct v2; inv H0. destruct n0; inv H1. auto.
Qed.

Lemma loc_eq_dec (l1 l2 : loc) : Decidable.decidable (l1=l2).
intros; case_eq (beq_nat l1 l2); intros.
left; apply beq_nat_eq; auto.
right; apply beq_nat_false; auto.
Qed.

Lemma nil_dec v : Decidable.decidable (v=nil_val).
unfold nil_val; intros. destruct v. destruct n. left; auto. right; congruence.
right; congruence.
Qed.

Definition var := Ident.t.

Definition env := var -> nat.

Definition env_get (rho: env) : var -> val := fun x => Some (rho x).

Definition env_set (x: var) (v: val) (rho: env) : env :=
  match v with
  | None  => rho
  | Some v' => fun y => if Ident.eq_dec x y then v' else rho y
  end.

Lemma gss_env (x: var) (v: val) (s: env) : v<>empty_val -> env_get (env_set x v s) x = v.
unfold env_get, env_set; intros.
destruct v.
destruct (Ident.eq_dec x x); auto.
contradiction n0; auto.
elimtype False; apply H; auto.
Qed.

Lemma gso_env (x y : var) (v: val) (s: env) :
  x<>y -> env_get (env_set x v s) y = env_get s y.
unfold env_get, env_set; intros.
destruct v; auto.
destruct (Ident.eq_dec x y); auto.
contradiction.
Qed.

Lemma env_reset s x : env_set x (env_get s x) s = s.
unfold env_set, env_get; extensionality.
destruct (Ident.eq_dec x x0); auto. subst; auto.
Qed.

Lemma env_reset2 s x z : env_set x (env_get s x) (env_set x z s) = s.
unfold env_set, env_get; extensionality.
destruct (Ident.eq_dec x x0); auto. subst; auto.
destruct z; auto.
destruct (Ident.eq_dec x x0); auto. subst; elimtype False; auto.
Qed.

Definition heap := loc -> val.
Instance Join_heap : Join heap := Join_fun loc val _.
Instance Perm_heap : Perm_alg heap := _.
Instance Sep_heap : Sep_alg heap := _.
Instance Canc_heap : Canc_alg heap := @Canc_fun loc val  _ _.

Definition rawnext (x: loc) (y : val) (s : heap) :=
  y <> None /\ x<>O /\ s x = y /\ forall x', x'<>x -> s x' = None.

Definition emp_at (l: loc) (h: heap) := h l = None.

Lemma heap_gempty h l : identity h -> emp_at l h.
unfold emp_at; case_eq (h l); intros ? H1; auto.
intros H2; elimtype False.
specialize (H2 (fun _ => None) h); rewrite <-H2 in H1; inv H1.
intro; constructor.
Qed.

Definition nil_or_loc (v: val) := v=nil_val \/ exists l, val2loc v = Some l.

Lemma mk_heap_rawnext (h: heap) (x0: val) (x:loc) (y: val) :
  val2loc (x0) = Some x -> nil_or_loc y ->
  exists h', rawnext x y h' /\ comparable h h'.
unfold val2loc, rawnext; intros. destruct x0; inv H. destruct n; inv H2.
exists (fun z => if beq_nat z (S n) then y else None). rewrite <- beq_nat_refl.
split. split; auto. unfold nil_or_loc in H0; intro; subst.
destruct H0. inv H. destruct H. inv H.
split; auto. split; auto. intros.
rewrite <- beq_nat_false_iff in H. rewrite H. auto.
apply common_unit_comparable. exists (fun _ => None).
split; intro x; constructor.
Qed.

Lemma rawnext_out : forall {x: loc} {x0: val} {x': loc} {y: val} {h: heap},
  rawnext x y h -> val2loc x0 =  Some x' -> x'<>x -> emp_at x' h.
unfold rawnext, val2loc, emp_at; intros.
destruct x0; inv H0. destruct n; inv H3.
destruct H as [? [? ?]]. apply H2; auto.
Qed.

Definition rawnext' x y h := exists h0, join_sub h0 h /\ rawnext x y h0.

Lemma rawnext_at1 : forall {x y h1 h2 h},
  rawnext' x y h1 -> join h1 h2 h -> emp_at x h2 /\ rawnext' x y h.
unfold rawnext', emp_at, rawnext; intros.
destruct H as [h' [? [? [? [? ?]]]]].
destruct y; [ | elimtype False; apply H1; auto].
clear H1. destruct H as [h'' ?]. generalize (H x); intros.
rewrite H3 in H1. inv H1; [ | solve [inv H8]].
generalize (H0 x); rewrite <- H8; intro.
inv H1; [ | inv H10]. split; auto. exists h'. split.
apply join_sub_trans with h1; eauto. exists h''; auto. exists h2; auto.
split; auto. congruence.
Qed.

Lemma rawnext_at2 : forall {x y h1 h2 h},
  join h1 h2 h -> rawnext' x y h -> emp_at x h2 -> rawnext' x y h1.
Proof.
 unfold rawnext', emp_at; intros.
 destruct H0 as [h' [? ?]].
 exists h'. split; auto.
 exists (fun z: loc => if beq_nat z x then None else h1 z).
 intro z.
 case_eq (beq_nat z x); intros.
 apply beq_nat_true in H3. subst.
 specialize (H x). rewrite H1 in H.
 apply join_unit2_e in H; auto.
 rewrite H.
 unfold rawnext in H2. destruct H2 as [? [? [? ?]]].
 rewrite H4.
 destruct H0. specialize (H0 x). rewrite H4 in H0.
 inv H0. contradiction H2; auto. constructor.
 inv H9.
 apply beq_nat_false in H3.
 destruct H0 as [h'' ?].
 generalize (H x) as Hx; rewrite H1; intro.
 generalize (H z) as Hz; clear H; intro.
 generalize (H0 x) as H0x; intro.
 specialize (H0 z).
 clear H1.
 apply join_unit2_e in Hx; auto.
 destruct H2 as [? [? [? ?]]].
 rewrite H2 in H0x; clear H2.
 specialize (H4 _ H3). rewrite H4 in *.
 inv H0x.
 contradiction H; auto.
 constructor.
 inv H7.
Qed.

Lemma  rawnext_not_emp:
  forall {x y h}, rawnext' x y h -> ~emp_at x h.
Proof.
 unfold rawnext', emp_at, not; intros.
 destruct H as [h' [? ?]].
 destruct H as [h'' H].
 specialize (H x).
 rewrite H0 in H; clear H0.
 destruct H1 as [? [? [? ?]]].
 rewrite H2 in H.
 inv H; apply H0; auto.
Qed.

Lemma emp_at_join: forall {h1 h2 h}, join h1 h2 h ->
    forall l,  (emp_at l h1 /\ emp_at l h2) <-> emp_at l h.
Proof.
 unfold emp_at; intros.
 specialize (H l).
 intuition. rewrite H1 in *; rewrite H2 in *; inv H; auto.
 rewrite H0 in H; inv H; auto.
 rewrite H0 in H; inv H; auto.
Qed.

Lemma join_same n1 n2 v1 v2 z :
  join (Some n1) v1 z -> join (Some n2) v2 z -> n1 = n2.
Proof.
inversion 1; inversion 1; subst; try congruence.
inversion H3; subst; auto. inversion H4.
inversion H; subst; auto. inversion H5.
inversion H4; subst; auto. inversion H5.
Qed.

Lemma rawnext_unique: forall x z z' s s' t t' r,
  rawnext x z s -> rawnext x z' s' ->
  join s t r -> join s' t' r -> z' = z /\ s'=s.
Proof with simpl; auto; try congruence.
intros until r; intros [H1 [H2 [H3 H4]]] [H5 [H6 [H7 H8]]]; subst.
intros H9 H10. cut (s = s'); [intro H11; subst s; split; auto|].
extensionality x'. spec H9 x'. spec H10 x'.
remember (s x') as b; remember (s' x') as b'; destruct b as [|v]... destruct b' as [|v']...
f_equal; eapply join_same; eauto.
destruct (loc_eq_dec x' x); [subst|]. rewrite <-Heqb' in H5... rewrite (H4 x' H) in Heqb...
destruct (loc_eq_dec x' x); [subst|]. rewrite <-Heqb in H1... rewrite (H8 x' H) in Heqb'...
Qed.

Lemma vars_defined_locs : forall z (e:env),
  exists v: val, env_get e z = v /\ nil_or_loc v.
Proof.
intros.
unfold env_get.
exists (Some (e z)).
split; auto.
unfold nil_or_loc.
unfold nil_val.
destruct (eq_nat_dec (e z) 0).
subst; left; auto.
right; exists (e z); simpl.
destruct (e z); auto.
elimtype False; omega.
Qed.

End BarebonesLogic.

Require Import veristar.model.
(* veristar.model:
Load loadpath.
Require Import Coq.ZArith.ZArith Coq.Lists.List.
Require Import VST.msl.base msl.sepalg VST.msl.sepalg_generators msl.Axioms
               VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.model_type veristar.list_denote.

Module Type VERISTAR_MODEL.
Declare Module VeriStarLogic : VERISTAR_LOGIC.
Import VeriStarLogic.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Axiom rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s : stack) (x : option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
 env_set x v s.

Axiom stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Axiom join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Declare Instance Perm_state: Perm_alg state.
Declare Instance Sep_state: Sep_alg state.
Declare Instance Canc_state: Canc_alg state.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.
Infix "===" := var_eq (at level 35, no associativity).

Axiom var_eq_refl : forall x s, (x === x) s.

Axiom var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Axiom var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Axiom var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Axiom empstate_empheap: forall (s:state), emp s <-> emp (hp s).

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

Axiom var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

End VERISTAR_MODEL.

Module VeriStarModel (VSLog : VERISTAR_LOGIC) : VERISTAR_MODEL
  with Module VeriStarLogic := VSLog.

Module VeriStarLogic := VSLog. Import VSLog.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Lemma rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Lemma var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s: stack) (x: option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
  env_set x v s.

Lemma stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Lemma join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.

Infix "===" := var_eq (at level 35, no associativity).

Lemma var_eq_refl : forall x s, (x === x) s.

Lemma var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Lemma var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Lemma var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Lemma empstate_empheap : forall (s:state), emp s <-> emp (hp s).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

End VeriStarModel. *)

Module BarebonesModel := VeriStarModel BarebonesLogic.

Require Import veristar.veristar_sound.
(* veristar.veristar_sound:
Load loadpath.
Require Import veristar.compare.

Require Import ZArith Coq.Lists.List Permutation Classical.

Require Import VST.msl.Axioms VST.msl.predicates_sa VST.veric.Coqlib2.

Require Import veristar.datatypes veristar.clauses.

Require Import veristar.heapresolve veristar.veristar.

Require Import veristar.superpose_modelsat.

Require Import veristar.model_type veristar.model.

Require Import veristar.clausify_sound veristar.norm_sound
               veristar.wellformed_sound veristar.unfold_sound.

Require Import veristar.superpose_modelsat_sound.

Require Import veristar.list_denote veristar.clause_lemmas.

Module Type VERISTAR_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM.

Axiom check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.

End VERISTAR_SOUND.

Module VeriStarSound (VSM: VERISTAR_MODEL) : VERISTAR_SOUND
  with Module VSM := VSM.

Module VSM := VSM.  Import VSM. Import VeriStarLogic.
Module CS  := Clausify_Sound VSM. Import CS.
Module SPS := SP_Sound VSM.       Import SPS.
Module NS  := Norm_Sound VSM.     Import NS.
Module WFS := WF_Sound VSM.       Import WFS.
Module UFS := UF_Sound VSM.       Import UFS.
Module CL  := CL_Sound VSM.       Import CL.

Import HeapResolve.
Import VeriStar.

Lemma relim1_sound c s st :
  clause_denote c st -> setd clause_denote inter TT s st ->
  setd clause_denote inter TT (relim1 c s) st.

Lemma incorp_sound s t st :
  setd clause_denote inter TT s st -> setd clause_denote inter TT t st ->
  setd clause_denote inter TT (incorp s t) st.

Local Open Scope nat_scope.

Lemma positive_base_case : forall n: positive,
  O = nat_of_P n - 1 -> n=1%positive.

Local Coercion bool2Prop (b: bool) := b = true.

Lemma loop_sound n sigma nc s cl st :
  clause_denote nc st -> space_denote sigma st ->
  setd clause_denote inter TT s st -> the_loop n sigma nc s cl = Valid ->
  clause_denote empty_clause st.

Theorem check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.

End VeriStarSound. *)

Module BarebonesSound := VeriStarSound BarebonesModel.

