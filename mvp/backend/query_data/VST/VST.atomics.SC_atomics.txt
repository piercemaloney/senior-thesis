Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Export VST.progs.invariants.
Require Export VST.progs.fupd.
Require Import atomics.general_atomics.
(* atomics.general_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Import VST.progs.invariants.
Require Import VST.progs.fupd.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Export Ensembles.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs} {inv_names : invG}.

Section atomicity.

Lemma approx_mono: forall n P Q, (P >=> Q) (Nat.pred n) -> approx n P |-- approx n Q.

Lemma subp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P' >=> P -> G |-- Q >=> Q' ->
    G |-- ((P -* Q) >=> (P' -* Q'))%pred.

Lemma eqp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P <=> P' -> G |-- Q <=> Q' ->
    G |-- ((P -* Q) <=> (P' -* Q')).

Lemma subp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P >=> P' ->
    G |-- ((|={E1,E2}=> P) >=> |={E1,E2}=> P').

Lemma eqp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P <=> P' ->
    G |-- ((|={E1,E2}=> P) <=> |={E1,E2}=> P').

Lemma eqp_imp: forall (G : Triv) (P P' Q Q' : mpred),
       G |-- P <=> P' -> G |-- Q <=> Q' -> G |-- (P --> Q) <=> P' --> Q'.

Lemma fview_shift_nonexpansive: forall E1 E2 P Q n,
  approx n (P -* |={E1,E2}=> Q) = approx n (approx n P -* |={E1,E2}=> (approx n Q)).

Lemma emp_dup: forall P, P && emp = (P && emp) * (P && emp).

Definition atomic_shift {A B} (a : A -> mpred) Ei Eo (b : A -> B -> mpred) (Q : B -> mpred) :=
  EX P : mpred, |> P * ((|> P -* |={Eo,Ei}=> (EX x : A, a x *
    ((a x -* |={Ei,Eo}=> |> P) &&
     ALL y : B, b x y -* |={Ei,Eo}=> Q y))) && cored).

End atomicity.

End atomics.

Definition atomic_spec_type W T := ProdType (ProdType W (ArrowType (ConstType T) Mpred)) (ConstType invG).

Definition super_non_expansive_a {A W} (a : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> predicates_hered.pred rmap) :=
  forall n ts w x, approx n (a ts w x) =
  approx n (a ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x).

Definition super_non_expansive_b {A B W} (b : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> B -> predicates_hered.pred rmap) :=
  forall n ts w x y, approx n (b ts w x y) =
  approx n (b ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x y).

Definition super_non_expansive_la {W} la := forall n ts w rho,
  Forall (fun l => approx n (!! locald_denote (l ts w) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w)) rho)) la.

Definition super_non_expansive_lb {B W} lb := forall n ts w (v : B) rho,
  Forall (fun l => approx n (!! locald_denote (l ts w v) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) v) rho)) lb.

Program Definition atomic_spec {A T} W args tz la P a (t : T) lb b Ei Eo
  (Hla : super_non_expansive_la la) (HP : super_non_expansive' P) (Ha : super_non_expansive_a(A := A) a)
  (Hlb : super_non_expansive_lb lb) (Hb : super_non_expansive_b b) :=
  mk_funspec (pair args tz) cc_default (atomic_spec_type W T)
  (fun (ts: list Type) '(w, Q, inv_names) =>
    PROP ()
    (LOCALx (map (fun l => l ts w) la)
    (SEP (atomic_shift(inv_names := inv_names) (a ts w) Ei Eo (b ts w) Q; P ts w))))
  (fun (ts: list Type) '(w, Q, inv_names) => EX v : T,
    PROP () (LOCALx (map (fun l => l ts w v) lb)
    (SEP (Q v)))) _ _.

Ltac start_atomic_function :=
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH u : unit
               PRE  [] main_pre _ nil u
               POST [ tint ] main_post _ nil u) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end; unfold atomic_spec;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match x with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList (x, Q)
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax; simpl. *)
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.

Set Bullet Behavior "Strict Subproofs".

Section SC_atomics.

Context {CS : compspecs} .

Definition AL_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType val) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition load_SC_spec := TYPE AL_type
  WITH p : val, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint ]
   PROP (Included Ei Eo)
   LOCAL (temp 1%positive p)
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v : Z, !!(readable_share sh /\ repable_signed v) &&
              data_at sh tint (vint v) p * P' sh v;
         ALL sh : _, ALL v : _, (!!(readable_share sh /\ repable_signed v) &&
           data_at sh tint (vint v) p * P' sh v) -* |={Ei,Eo}=> Q v;
         P)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (Q v).
Next Obligation.
Proof.
  repeat intro.
  destruct x as ((((((?, ?), ?), ?), ?), ?), ?); simpl.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; f_equal;
    f_equal; rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem.
  f_equal.
  - setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; do 3 apply f_equal.
    rewrite !approx_exp; apply f_equal; extensionality sh.
    rewrite !approx_exp; apply f_equal; extensionality v.
    rewrite !approx_sepcon, approx_idem; auto.
  - f_equal.
    rewrite !(approx_allp _ _ _ Share.bot); apply f_equal; extensionality sh.
    rewrite !(approx_allp _ _ _ 0); apply f_equal; extensionality v.
    setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; apply f_equal; f_equal.
    rewrite !approx_sepcon, approx_idem; auto.
Qed.
Next Obligation.
Proof.
  repeat intro.
  destruct x as ((((((?, ?), ?), ?), ?), ?), ?); simpl.
  rewrite !approx_exp; apply f_equal; extensionality v.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; do 2 apply f_equal;
    rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem; auto.
Qed.

Definition AS_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) Mpred)) Mpred)
  (ConstType invG).

Program Definition store_SC_spec := TYPE AS_type
  WITH p : val, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> mpred, Q : mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint ]
   PROP (repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, !!(writable_share sh) && data_at_ sh tint p * P' sh;
        ALL sh : _, (!!(writable_share sh) && data_at sh tint (vint v) p * P' sh) -* |={Ei,Eo}=> Q; P)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (Q).
Next Obligation.
Proof.
  repeat intro.
  destruct x as (((((((?, ?), ?), ?), ?), ?), ?), ?); simpl.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; f_equal;
    f_equal; rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem.
  f_equal.
  - setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; do 3 apply f_equal.
    rewrite !approx_exp; apply f_equal; extensionality sh.
    rewrite !approx_sepcon, approx_idem; auto.
  - f_equal.
    rewrite !(approx_allp _ _ _ Share.bot); apply f_equal; extensionality sh.
    setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; apply f_equal; f_equal.
    rewrite !approx_sepcon, approx_idem; auto.
Qed.
Next Obligation.
Proof.
  repeat intro.
  destruct x as (((((((?, ?), ?), ?), ?), ?), ?), ?); simpl.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; do 2 apply f_equal;
    rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem; auto.
Qed.

Definition ACAS_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition CAS_SC_spec := TYPE ACAS_type
  WITH p : val, c : Z, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint, 3%positive OF tint ]
   PROP (repable_signed c; repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint c); temp 3%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v0 : Z, !!(writable_share sh /\ repable_signed v0) &&
              data_at sh tint (vint v0) p * P' sh v0;
         ALL sh : _, ALL v0 : _, (!!(writable_share sh /\ repable_signed v0) &&
           data_at sh tint (vint (if eq_dec v0 c then v else v0)) p * P' sh v0) -* |={Ei,Eo}=> Q v0; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (vint (if eq_dec v' c then 1 else 0)))
   SEP (Q v').
Next Obligation.
Proof.
  repeat intro.
  destruct x as ((((((((?, ?), ?), ?), ?), ?), ?), ?), ?); simpl.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; f_equal;
    f_equal; rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem.
  f_equal.
  - setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; do 3 apply f_equal.
    rewrite !approx_exp; apply f_equal; extensionality sh.
    rewrite !approx_exp; apply f_equal; extensionality v0.
    rewrite !approx_sepcon, approx_idem; auto.
  - f_equal.
    rewrite !(approx_allp _ _ _ Share.bot); apply f_equal; extensionality sh.
    rewrite !(approx_allp _ _ _ 0); apply f_equal; extensionality v0.
    setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; apply f_equal; f_equal.
    rewrite !approx_sepcon, approx_idem; auto.
Qed.
Next Obligation.
Proof.
  repeat intro.
  destruct x as ((((((((?, ?), ?), ?), ?), ?), ?), ?), ?); simpl.
  rewrite !approx_exp; apply f_equal; extensionality vr.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; do 2 apply f_equal;
    rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem; auto.
Qed.

Definition AEX_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition AEX_SC_spec := TYPE AEX_type
  WITH p : val, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint ]
   PROP (repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v0 : Z, !!(writable_share sh /\ repable_signed v0) &&
              data_at sh tint (vint v0) p * P' sh v0;
        ALL sh : _, ALL v0 : _, (!!(writable_share sh /\ repable_signed v0) &&
           data_at sh tint (vint v) p * P' sh v0) -* |={Ei,Eo}=> Q v0; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (vint v'))
   SEP (Q v').
Next Obligation.
Proof.
  repeat intro.
  destruct x as (((((((?, ?), ?), ?), ?), ?), ?), ?); simpl.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; f_equal;
    f_equal; rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem.
  f_equal.
  - setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; do 3 apply f_equal.
    rewrite !approx_exp; apply f_equal; extensionality sh.
    rewrite !approx_exp; apply f_equal; extensionality v0.
    rewrite !approx_sepcon, approx_idem; auto.
  - f_equal.
    rewrite !(approx_allp _ _ _ Share.bot); apply f_equal; extensionality sh.
    rewrite !(approx_allp _ _ _ 0); apply f_equal; extensionality v0.
    setoid_rewrite fview_shift_nonexpansive; rewrite approx_idem; apply f_equal; f_equal.
    rewrite !approx_sepcon, approx_idem; auto.
Qed.
Next Obligation.
Proof.
  repeat intro.
  destruct x as (((((((?, ?), ?), ?), ?), ?), ?), ?); simpl.
  rewrite !approx_exp; apply f_equal; extensionality vr.
  unfold PROPx, LOCALx, SEPx; simpl; rewrite !approx_andp; do 2 apply f_equal;
    rewrite !sepcon_emp, ?approx_sepcon, ?approx_idem; auto.
Qed.

End SC_atomics.

Notation store_SC_witness p v P Eo Ei Q invG := (p, v%Z, P, Eo, Ei,
  fun sh => !!(writable_share sh) && data_at sh tint (vint v) p -* Q, Q, invG).

Notation AEX_SC_witness p v P Eo Ei Q invG := (p, v%Z, P, Eo, Ei,
  fun sh v0 => !!(writable_share sh /\ repable_signed v0) && data_at sh tint (vint v) p -* Q v0, Q, invG).

Notation load_SC_witness p P Eo Ei Q invG := (p, P, Eo, Ei,
  fun sh v => !!(readable_share sh /\ repable_signed v) && data_at sh tint (vint v) p -* Q v, Q, invG).

Notation CAS_SC_witness p c v P Eo Ei Q invG := (p, c, v%Z, P, Eo, Ei,
  fun sh v0 => !!(writable_share sh /\ repable_signed v0) &&
    data_at sh tint (vint (if eq_dec v0 c then v else v0)) p -* Q v0, Q, invG).
