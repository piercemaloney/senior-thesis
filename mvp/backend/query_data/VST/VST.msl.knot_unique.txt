

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.ageable.
(* VST.msl.ageable:
Require Import VST.msl.base.
  Require Coq.funind.Recdef.

Local Open Scope nat_scope.

Record ageable_facts (A:Type) (level: A -> nat) (age1:A -> option A)  :=
{ af_unage : forall x':A, exists x, age1 x = Some x'
; af_level1 : forall x, age1 x = None <-> level x = 0
; af_level2 : forall x y, age1 x = Some y -> level x = S (level y)
}.

Arguments af_unage [A] [level] [age1] _ _.
Arguments af_level1 [A] [level] [age1] _ _.
Arguments af_level2 [A] [level] [age1] _ _ _ _.

Class ageable (A:Type) := mkAgeable
{ level : A -> nat
; age1 : A -> option A
; age_facts : ageable_facts A level age1
}.

Definition age {A} `{ageable A} (x y:A) := age1 x = Some y.

Lemma af_wf {A} `{ageable A} :
 well_founded (fun x y => age y x).
Arguments af_wf [A] _ _.

Definition age_induction {A} `{ageable A} :=
  well_founded_induction (af_wf _).

Definition fashionR {A1} `{ageable A1} {A2}`{ageable A2} (x:A1) (y: A2) : Prop :=
  level x = level y.

Lemma fashionR_refl {A} `{ageable A} : reflexive _ fashionR.

Lemma fashionR_trans {A} `{ageable A} {B} `{ageable B} {C} `{ageable C} :
    forall (x: A) (y: B) (z: C), fashionR x y -> fashionR y z -> fashionR x z.

Lemma fashionR_sym {A} `{ageable A} {B} `{ageable B}:
   forall (x: A) (y: B), fashionR x y -> fashionR y x.

Lemma age_level {A} `{ageable A} : forall (x y:A),
  age x y -> level x = S (level y).

Lemma age1_level0 {A} `{ageable A} : forall (x:A),
  age1 x = None <-> level x = 0.

  Theorem level_level' : forall x:A, level x = level' x.
End level'.

Lemma levelS_age1 {A} `{ageable A} : forall (x:A) n,
  level x = S n ->
  exists y, age1 x = Some y.

Lemma age1_levelS {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  exists n, level x = S n.

Lemma age1_level0_absurd {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  level x = 0 ->
  False.

Lemma age1None_levelS_absurd {A} `{ageable A} : forall (x:A) n,
  age1 x = None ->
  level x = S n ->
  False.

Section RtRft.
  Variable A:Type.
  Variable R:relation A.

  Let Rt := clos_trans A R.
  Let Rft := clos_refl_trans A R.

  Lemma Rt_Rft : forall x y, Rt x y -> Rft x y.

  Lemma Rt_Rft_trans : forall x y z, Rt x y -> Rft y z -> Rt x z.

  Lemma Rft_Rt_trans : forall x y z, Rft x y -> Rt y z -> Rt x z.

  Lemma transpose_clos_trans : forall A R x y,
    clos_trans A (transp A R) x y <-> transp A (clos_trans A R) x y.
End RtRft.

Hint Resolve rt_refl.

Definition laterR {A} `{ageable A} : relation A := clos_trans A age.
Definition necR   {A} `{ageable A} : relation A := clos_refl_trans A age.

Require Coq.Wellfounded.Wellfounded.
Lemma laterR_wf {A} `{ageable A} :
  well_founded (transp _ laterR).

Definition laterR_induction {A} `{ageable A} :=
  @well_founded_induction A (transp A laterR) laterR_wf.

Lemma age_irreflexive {A}  `{ageable A}: forall x, age x x -> False.

Lemma laterR_irreflexive {A} `{HA: ageable A} : forall x, laterR x x -> False.

Lemma nec_refl_or_later {A} `{ageable A} : forall x y,
  necR x y -> x = y \/ laterR x y.

Lemma necR_antisym {A} `{ageable A} : forall x y,
  necR x y -> necR y x -> x = y.

Lemma age_later_nec {A} `{HA: ageable A} : forall x y z,
  age x y ->
  laterR x z ->
  necR y z.

Lemma necR_level {A} `{X: ageable A} : forall (x y:A),
  necR x y ->
  level x >= level y.

Lemma laterR_level {A} `{X: ageable A} : forall (x y:A),
  laterR x y ->
  level x > level y.

Section NAT_AGEABLE.

  Definition natLevel (x:nat) : nat := x.
  Definition natAge1 (x:nat) : option nat :=
    match x with
    | 0 => None
    | S n => Some n
    end.
  Definition natUnage (x:nat) : nat := S x.

  Lemma ag_nat_facts :
    ageable_facts nat natLevel natAge1.

  Definition ag_nat : ageable nat :=
    mkAgeable nat natLevel natAge1 ag_nat_facts.

  Lemma nec_nat : forall (n n':nat),
    @necR _ ag_nat n n' <-> n' <= n.

  Lemma later_nat : forall (n n':nat),
    @laterR _ ag_nat n n' <-> n' < n.

End NAT_AGEABLE.

Lemma laterR_level' {A} `{H : ageable A}: forall {w1 w2: A}, laterR w1 w2 -> @laterR _ ag_nat (level w1) (level w2).

Lemma necR_nat {A} `{H : ageable A}:
    forall {x y: A}, necR x y -> @necR nat ag_nat (level x) (level y).

Section BIJECTION.
  Variable A B : Type.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.

  Let levelB (x:B) : nat :=
    level (bij_g _ _ bijAB x).

  Let age1B  (x: B) : option B :=
     match age1 (bij_g _ _ bijAB x) with
     | Some y => Some (bij_f _ _ bijAB y)
     | None => None
     end.

  Let ageB (x y: B) :=age1B x = Some y.

  Lemma age_bij_unage :
    forall x', exists x, age1B x = Some x'.

  Lemma age_bij_level1 :
    forall x, age1B x = None <-> levelB x = 0.

  Lemma age_bij_level2 :
    forall x y, age1B x = Some y -> levelB x = S (levelB y).

  Lemma ag_bij_facts : ageable_facts B levelB age1B.

  Definition ag_bij : ageable B :=
    mkAgeable B levelB age1B ag_bij_facts.
End BIJECTION.

Section PROD.
  Variable A B : Type.
  Variable agA: ageable A.

  Let levelAB (x:prod A B) := level (fst x).
  Let age1AB (x:prod A B) :=
    match age1 (fst x) with
    | None => None
    | Some a' => Some (a',snd x)
    end.

  Lemma ag_prod_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod :=
    mkAgeable (prod A B) levelAB age1AB ag_prod_facts.

  Lemma prod_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod (n,x) (n',x') <-> necR n n' /\ x = x'.

  Lemma prod_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod (n,x) (n',x') <-> laterR n n' /\ x = x'.

End PROD.

Section PROD'.
  Variable A B : Type.
  Variable agB: ageable B.

  Let levelAB (x:prod A B) := level (snd x).
  Let age1AB (x:prod A B) :=
    match age1 (snd x) with
    | None => None
    | Some a' => Some (fst x, a')
    end.

  Lemma ag_prod'_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod' :=
    mkAgeable (prod A B) levelAB age1AB ag_prod'_facts.

  Lemma prod'_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod' (x,n) (x',n') <-> necR n n' /\ x = x'.

  Lemma prod'_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod' (x,n) (x',n') <-> laterR n n' /\ x = x'.

End PROD'.

Fixpoint composeOptN (A: Type) (f: A -> option A)
         (n: nat) (w: A) {struct n} : option A :=
 match n  with
 | S n' => match f w with Some w' => composeOptN A f n' w' | None => None end
 | O => Some w
 end.
Arguments composeOptN [A] _ _ _.

Definition ageN {A} `{ageable A}: nat -> A -> option A := composeOptN age1.

Lemma ageN1  {A} `{ageable A}: ageN 1 = age1.

Lemma ageN_compose {A} `{agA : ageable A}:
 forall a b c phi1 phi2 phi3,ageN a phi1 = Some phi2 ->
       ageN b phi2 = Some phi3 ->  (a+b=c)%nat ->  ageN c phi1 = Some phi3.

Lemma ageN_compose' {A} `{agA : ageable A}:
  forall a b phi1 phi3,
   ageN (a+b)%nat phi1 = Some phi3 -> exists phi2, ageN a phi1 = Some phi2 /\ ageN b phi2 = Some phi3.

Lemma necR_evolve {A} `{agA : ageable A}:
    necR = fun (phi phi': A) => exists n, ageN n phi = Some phi'.

Lemma age_noetherian  {A} `{ageable A}: forall phi, exists n, ageN n phi = None.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma age_noetherian'  {A} `{agA : ageable A}:
       forall phi, exists! n, exists phi', ageN n phi = Some phi' /\ age1 phi' = None.

Lemma ageable_ext:
   forall A (B C: ageable A),
      @age1 _ B = @age1 _ C -> @level _ B = @level _ C -> B=C.

Lemma necR_linear {A} `{H : ageable A}:
  forall {a b c}, necR a b -> necR a c -> necR b c \/ necR c b.

Lemma necR_linear' {A} `{H : ageable A}:
   forall {a b c}, necR a b -> necR a c -> level b = level c -> b=c.

Lemma laterR_necR {A} `{agA : ageable A}:
  forall {x y}, laterR x y -> necR x y.

Lemma necR_refl {A} `{H : ageable A}:
  forall phi, necR phi phi.

Hint Resolve @necR_refl.

Lemma necR_trans  {A} `{H : ageable A}:
  forall phi1 phi2 phi3, necR phi1 phi2 -> necR phi2 phi3 -> necR phi1 phi3.

Lemma necR_laterR {A} `{agA : ageable A}:
  forall w1 w2 w3, necR w1 w2 -> laterR w2 w3 -> laterR w1 w3. *)

Require Import VST.msl.knot.
(* VST.msl.knot:
Require Import VST.msl.base.
Require Import VST.msl.ageable.
Require Import Coq.Logic.Eqdep_dec.
Require Import VST.msl.functors.

Import CovariantFunctor.
Import CovariantFunctorLemmas.
Import CovariantFunctorGenerator.

Local Open Scope nat_scope.

Module Type TY_FUNCTOR.
  Parameter F : functor.

  Parameter T : Type.
  Parameter T_bot : T.

  Parameter other : Type.
End TY_FUNCTOR.

Module Type KNOT.
  Declare Module TF:TY_FUNCTOR.
  Import TF.

  Parameter knot : Type.

  Parameter ag_knot : ageable knot.
  Existing Instance ag_knot.
  Existing Instance ag_prod.

  Definition predicate := (knot * other) -> T.

  Parameter squash : (nat * F predicate) -> knot.
  Parameter unsquash : knot -> (nat * F predicate).

  Definition approx (n:nat) (p:predicate) : predicate :=
     fun w => if le_gt_dec n (level w) then T_bot else p w.

  Axiom squash_unsquash : forall x, squash (unsquash x) = x.
  Axiom unsquash_squash : forall n x', unsquash (squash (n,x')) = (n,fmap F (approx n) x').

  Axiom knot_level : forall k:knot,
    level k = fst (unsquash k).

  Axiom knot_age1 : forall k:knot,
    age1 k =
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

End KNOT.

Module Knot (TF':TY_FUNCTOR) : KNOT with Module TF:=TF'.
  Module TF := TF'.
  Import TF.

  Inductive leT : T -> T -> Prop :=
   | leT_refl : forall t, leT t t
   | leT_bot: forall t, leT T_bot t.

  Lemma leT_asym: forall t t',
    leT t t' -> leT t' t -> t = t'.

  Fixpoint sinv (n: nat) : Type :=
    match n with
      | O => unit
      | S n => prodT (sinv n) ((F (sinv n) * other) -> T)
    end.

  Fixpoint floor (m:nat) (n:nat) (p:sinv (m+n)) : sinv n :=
    match m as m' return forall (p : sinv (m'+n)), sinv n with
    | O => fun p => p
    | S m' => fun p => floor m' n (fst p)
    end p.

  Definition knot := { n:nat & F (sinv n) }.

  Definition predicate := knot * other -> T.

  Fixpoint stratify (n:nat) (Q:predicate) {struct n} : sinv n :=
    match n as n' return sinv n' with
    | O => tt
    | S n' => ( stratify n' Q, fun v => Q (existT (F oo sinv) n' (fst v),snd v) )
    end.

  Lemma decompose_nat : forall (x y:nat), { m:nat & y = (m + S x) } + { ge x y }.

  Definition unstratify (n:nat) (p:sinv n) : predicate := fun w =>
    match w with (existT _ nw w',e) =>
      match decompose_nat nw n with
        | inleft (existT _ m Hm) => snd (floor m (S nw) (eq_rect  n _ p (m + S nw) Hm)) (w', e)
        | inright H => T_bot
      end
    end.

  Definition proof_irr_nat := eq_proofs_unicity dec_eq_nat.
  Arguments proof_irr_nat [x] [y] _ _.

  Lemma floor_shuffle:
    forall (m1 n : nat)
      (p1 : sinv (m1 + S n)) (H1 : (m1 + S n) = (S m1 + n)),
      floor (S m1) n (eq_rect (m1 + S n) sinv p1 (S m1 + n) H1) = fst (floor m1 (S n) p1).

  Lemma stratify_unstratify_more : forall n m1 m2 p1 p2,
    floor m1 n p1 = floor m2 n p2 ->

    (stratify n oo unstratify (m1+n)) p1 =
    (stratify n oo unstratify (m2+n)) p2.

  Lemma stratify_unstratify : forall n,
         stratify n oo unstratify n = id (sinv n).

  Lemma unstratify_stratify1 : forall n (p:predicate) w,
    leT ((unstratify n oo stratify n) p w) (p w).

  Lemma unstratify_stratify2 : forall n p w,
     projT1 (fst w) < n ->
        leT (p w) ((unstratify n oo stratify n) p w).

  Lemma unstratify_stratify3 : forall n (p:predicate) w,
    projT1 (fst w) >= n -> leT ((unstratify n oo stratify n) p w) T_bot.

  Definition squash (x:nat * F predicate) : knot :=
    match x with (n,y) => existT (F oo sinv) n (fmap F (stratify n) y) end.

  Definition unsquash (x:knot) : (nat * F predicate) :=
    match x with existT _ n y => (n, fmap F (unstratify n) y) end.

  Definition def_knot_level (k:knot) := fst (unsquash k).

  Definition def_knot_age1 (k:knot) : option knot :=
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition def_knot_unage (k:knot) : knot :=
    match unsquash k with
    | (n,x) => squash (S n,x)
    end.

  Definition approx (n:nat) (p:predicate) : predicate :=
     fun w => if le_gt_dec n (def_knot_level (fst w)) then T_bot else p w.

  Lemma squash_unsquash : forall x, squash (unsquash x) = x.

  Lemma unsquash_squash : forall n x', unsquash (squash (n,x')) = (n,fmap F (approx n) x').

  Lemma unsquash_inj : forall k1 k2,
    unsquash k1 = unsquash k2 ->
    k1 = k2.
  Arguments unsquash_inj [k1 k2] _.

  Lemma ag_knot_facts : ageable_facts knot def_knot_level def_knot_age1.

  Definition ag_knot : ageable knot :=
    mkAgeable knot def_knot_level def_knot_age1 ag_knot_facts .
  Existing Instance ag_knot.
  Existing Instance ag_prod.

  Lemma knot_level : forall k:knot,
    level k = fst (unsquash k).
  Proof (fun k => refl_equal (def_knot_level k)).

  Lemma knot_age1 : forall k:knot,
    age1 k =
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.
  Proof (fun k => refl_equal (def_knot_age1 k)).

End Knot. *)

Require Import VST.msl.knot_lemmas.
(* VST.msl.knot_lemmas:
Require Import VST.msl.base.
Require Import VST.msl.ageable.
Require Import VST.msl.knot.
Require Import VST.msl.knot_hered.
Require Import VST.msl.functors.

Import CovariantFunctor.
Import CovariantFunctorLemmas.
Import CovariantFunctorGenerator.

Module Knot_Lemmas (K : KNOT).
  Import K.TF.
  Import K.

  Lemma unsquash_inj : forall k1 k2,
    unsquash k1 = unsquash k2 ->
    k1 = k2.
  Arguments unsquash_inj [k1 k2] _.

  Lemma squash_surj : forall k, exists n, exists Fp,
    squash (n, Fp) = k.

  Lemma unsquash_approx : forall k n Fp,
    unsquash k = (n, Fp) ->
    Fp = fmap F (approx n) Fp.
  Arguments unsquash_approx [k n Fp] _.

  Lemma approx_approx1 : forall m n,
    approx n = approx n oo approx (m+n).

  Lemma approx_approx2 : forall m n,
    approx n = approx (m+n) oo approx n.

  Lemma unsquash_squash_unfolded : forall nf,
    unsquash (squash nf) = (fst nf, fmap F (approx (fst nf)) (snd nf)).

  Lemma unsquash_approx_unfolded : forall k,
    unsquash k = (fst (unsquash k), fmap F (approx (fst (unsquash k))) (snd (unsquash k))).

End Knot_Lemmas.

Module KnotHered_Lemmas (K : KNOT_HERED).
  Import K.TF.
  Import K.

  Lemma predicate_eq : forall (p1 p2:predicate),
    proj1_sig p1 = proj1_sig p2 ->
    p1 = p2.

  Lemma unsquash_inj : forall k1 k2,
    unsquash k1 = unsquash k2 ->
    k1 = k2.
  Arguments unsquash_inj [k1 k2] _.

  Lemma squash_surj : forall k, exists n, exists Fp,
    squash (n, Fp) = k.

  Lemma unsquash_approx : forall k n Fp,
    unsquash k = (n, Fp) ->
    Fp = fmap F (approx n) Fp.
  Arguments unsquash_approx [k n Fp] _.

  Lemma approx_approx1 : forall m n,
    approx n = approx n oo approx (m+n).

  Lemma approx_approx2 : forall m n,
    approx n = approx (m+n) oo approx n.

  Lemma unsquash_squash_unfolded : forall nf,
    unsquash (squash nf) = (fst nf, fmap F (approx (fst nf)) (snd nf)).

  Lemma unsquash_approx_unfolded : forall k,
    unsquash k = (fst (unsquash k), fmap F (approx (fst (unsquash k))) (snd (unsquash k))).

End KnotHered_Lemmas. *)

Require Import VST.msl.functors.
(* VST.msl.functors:
Require Import VST.msl.base.

Set Implicit Arguments.

Module CovariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : A -> B), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : B -> C) (g : A -> B),
fmap _ _ f oo fmap _ _ g = fmap _ _ (f oo g)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : A -> B), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End CovariantFunctor.

Module ContraVariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : C -> B) (g : B -> A),
fmap _ _ f oo fmap _ _ g = fmap _ _ (g oo f)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End ContraVariantFunctor.

Module MixVariantFunctor.

Record functorFacts (PS : Type -> Type)
 (fmap : forall A B (f1 : A -> B) (f2 : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) (id A) = id (PS A);
  ff_comp : forall A B C (f1 : B -> C) (f2 : C -> B) (g1 : A -> B)
(g2 : B -> A), fmap _ _ f1 f2 oo fmap _ _ g1 g2 = fmap _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f1 : A -> B) (f2 : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End MixVariantFunctor.

Module CovariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : B2 -> C2)
(g1 : A1 -> B1) (g2 : A2 -> B2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (f2 oo g2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CovariantBiFunctor.

Module CoContraVariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : C2 -> B2)
(g1 : A1 -> B1) (g2 : B2 -> A2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CoContraVariantBiFunctor.

Coercion CovariantFunctor._functor:
  CovariantFunctor.functor >-> Funclass.
Coercion ContraVariantFunctor._functor:
  ContraVariantFunctor.functor >-> Funclass.
Coercion MixVariantFunctor._functor:
  MixVariantFunctor.functor >-> Funclass.
Coercion CovariantBiFunctor._functor:
  CovariantBiFunctor.functor >-> Funclass.
Coercion CoContraVariantBiFunctor._functor:
  CoContraVariantBiFunctor.functor >-> Funclass.

Module CovariantFunctorLemmas.

Import CovariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : B -> C) (g : A -> B),
  fmap F f oo fmap F g = fmap F (f oo g).

Lemma fmap_app {F: functor} : forall A B C (f : B -> C) (g : A -> B) x,
  fmap F f (fmap F g x) = fmap F (f oo g) x.

End CovariantFunctorLemmas.

Module ContraVariantFunctorLemmas.

Import ContraVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : C -> B) (g : B -> A),
  fmap F f oo fmap F g = fmap F (g oo f).

Lemma fmap_app {F: functor} : forall A B C (f : C -> B) (g : B -> A) x,
  fmap F f (fmap F g x) = fmap F (g oo f) x.

End ContraVariantFunctorLemmas.

Module MixVariantFunctorLemmas.

Import MixVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End MixVariantFunctorLemmas.

Module CovariantBiFunctorLemmas.

Import CovariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (f2 oo g2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (f2 oo g2) x.

End CovariantBiFunctorLemmas.

Module CoContraVariantBiFunctorLemmas.

Import CoContraVariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End CoContraVariantBiFunctorLemmas.

Module GeneralFunctorGenerator.

Definition CovariantFunctor_MixVariantFunctor (F: CovariantFunctor.functor):

Definition ContraVariantFunctor_MixVariantFunctor
 (F: ContraVariantFunctor.functor):

Definition CovariantFunctor_CoContraVariantBiFunctor
 (F: CovariantFunctor.functor):

Definition CoContraVariantBiFunctor_MixVariantFunctor
 (F: CoContraVariantBiFunctor.functor):

Definition CovariantFunctor_CovariantFunctor_compose
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f => CovariantFunctor.fmap F1 (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantFunctor_MixVariantFunctor_compose
(F1: CovariantFunctor.functor) (F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f g => CovariantFunctor.fmap F1 (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite MixVariantFunctorLemmas.fmap_id, CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp, MixVariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_CovariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CovariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_MixVariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CovariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_CoContraVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1: CovariantFunctor.functor)
(F2: ContraVariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CoContraVariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (ContraVariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite CovariantFunctorLemmas.fmap_id, ContraVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, CovariantFunctorLemmas.fmap_comp, ContraVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_MixVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CoContraVariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 g f)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

End GeneralFunctorGenerator.

Module CovariantBiFunctorGenerator.

Import CovariantBiFunctor.
Import CovariantBiFunctorLemmas.

Definition Fpair: functor.

Definition Fchoice: functor.

End CovariantBiFunctorGenerator.

Module CoContraVariantBiFunctorGenerator.

Import CoContraVariantBiFunctor.
Import CoContraVariantBiFunctorLemmas.

Definition Ffunc: functor.

End CoContraVariantBiFunctorGenerator.

Module CovariantFunctorGenerator.

Import CovariantFunctor.
Import CovariantFunctorLemmas.

Definition fconst (T : Type): functor.

Definition fidentity: functor.

Definition Foption: functor.

Definition Flist: functor.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Goal forall (F1 F2: functor) (T: Type), fpair F1 F2 T = prod (F1 T) (F2 T).

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Flist
  F.

Goal forall (F : functor) (T: Type), foption F T = option (F T).

Definition ffunc (F1: ContraVariantFunctor.functor) (F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_CoContraVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Goal forall (F1 : ContraVariantFunctor.functor) (F2: functor) (T: Type),

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B (f: A -> B) x, P A x -> P B (fmap F f x)): functor.

End CovariantFunctorGenerator.

Module MixVariantFunctorGenerator.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.

Definition fconst (T : Type): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  (CovariantFunctorGenerator.fconst T).

Definition fidentity: functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  CovariantFunctorGenerator.fidentity.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Flist
  F.

Definition ffunc (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_MixVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fpi {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B f g x, P A x -> P B (fmap F f g x)): functor.

End MixVariantFunctorGenerator.

Unset Implicit Arguments. *)



Import CovariantFunctor.

Import CovariantFunctorLemmas.

Import CovariantFunctorGenerator.



Local Open Scope nat_scope.



Definition map_pair {A B C D} (f:A -> B) (g:C -> D) (x:A * C) : B * D :=

  (f (fst x), g (snd x)).



Module Type ISOMORPHIC_KNOTS.

  Declare Module TF : TY_FUNCTOR.

  Declare Module K1 : KNOT with Module TF := TF.

  Declare Module K2 : KNOT with Module TF := TF.

  Import TF.



  Parameter f : K1.knot -> K2.knot.

  Parameter g : K2.knot -> K1.knot.



  Definition fF : F K1.predicate -> F K2.predicate :=

    fmap F (fun p : K1.knot * other -> K1.TF.T => p oo map_pair g (@id other)).



  Definition gF : F K2.predicate -> F K1.predicate :=

    fmap F (fun p : K2.knot * other -> K2.TF.T => p oo map_pair f (@id other)).



  Axiom iso1 : f oo g = id K2.knot.

  Axiom iso2 : g oo f = id K1.knot.



  Axiom f_squash : forall n F1,

    f (K1.squash (n, F1)) = K2.squash (n, fF F1).



  Axiom g_squash : forall n F2,

    g (K2.squash (n, F2)) = K1.squash (n, gF F2).



  Axiom f_unsquash : forall k1 U1,

    U1 = K1.unsquash k1 ->

    K2.unsquash (f k1) = (fst U1, fF (snd U1)).



  Axiom g_unsquash : forall k2 U2,

    U2 = K2.unsquash k2 ->

    K1.unsquash (g k2) = (fst U2, gF (snd U2)).



End ISOMORPHIC_KNOTS.



Module Unique_Knot (TF' : TY_FUNCTOR)

                                (K1' : KNOT with Module TF := TF')

                                (K2' : KNOT with Module TF := TF') :

                                  ISOMORPHIC_KNOTS

                                    with Module TF := TF'

                                    with Module K1 := K1'

                                    with Module K2 := K2'.

Module TF := TF'.

Import TF.

Module K1 := K1'.

Module K2 := K2'.

Module K1L := Knot_Lemmas K1.

Module K2L := Knot_Lemmas K2.



Section Common.

Variable f : K1.knot -> K2.knot.

Variable g : K2.knot -> K1.knot.



Definition f_pred' (p1 : K1.predicate) : K2.predicate :=

  p1 oo map_pair g (@id other).



Definition g_pred' (p2 : K2.predicate) : K1.predicate :=

  p2 oo map_pair f (@id other).



Variable f_level : forall k, level k = level (f k).

Variable g_level : forall k, level k = level (g k).



Lemma f_pred'_approx: forall n,

f_pred' oo K1.approx n = K2.approx n oo f_pred'.

Proof.

intros.

extensionality P1 k2.

destruct k2; unfold f_pred', compose; simpl.

unfold K1'.approx, K2'.approx; simpl.

rewrite g_level; simpl; auto.

Qed.



Lemma g_pred'_approx : forall n,

g_pred' oo K2.approx n = K1.approx n oo g_pred'.

Proof.

intros.

extensionality P k1.

destruct k1; unfold g_pred', compose; simpl.

unfold K1'.approx, K2'.approx; simpl.

rewrite f_level; simpl; auto.

Qed.



Definition f_F' : TF.F K1.predicate -> TF.F K2.predicate :=

  fmap F f_pred'.



Definition g_F' : TF.F K2.predicate -> TF.F K1.predicate :=

  fmap F g_pred'.



End Common.



Section Z.



Definition fZ_pred (p2 : K2.predicate) : K1.predicate :=

fun k1 => T_bot.



Definition gZ_pred (p1 : K1.predicate) : K2.predicate :=

fun k2 => T_bot.



Definition fF_Z : TF.F K1.predicate -> TF.F K2.predicate :=

  fmap F gZ_pred.



Definition gF_Z : TF.F K2.predicate -> TF.F K1.predicate :=

  fmap F fZ_pred.



Definition f_Z (k1 : K1.knot) : K2.knot :=

  match K1.unsquash k1 with

    (n, F_p1) => K2.squash (n, fF_Z F_p1)

  end.



Definition g_Z (k2 : K2.knot) : K1.knot :=

  match K2.unsquash k2 with

    (n, F_p2) => K1.squash (n, gF_Z F_p2)

  end.



Lemma predZ_iso1: fZ_pred oo K2.approx 0 oo gZ_pred = K1.approx 0.

Proof.

intros.

extensionality p k.

unfold compose, gZ_pred, fZ_pred, K1'.approx in *.

destruct k; simpl; auto.

Qed.



Lemma predZ_iso2: gZ_pred oo K1.approx 0 oo fZ_pred = K2.approx 0.

Proof.

intros.

extensionality p k.

unfold compose, gZ_pred, fZ_pred, K2'.approx in *.

destruct k; simpl; auto.

Qed.



Lemma iso1_Z : forall k, level k <= 0 -> (g_Z oo f_Z) k = k.

Proof.

intros.

unfold compose, g_Z, f_Z.

remember (K1.unsquash k) as unsq_k.

destruct unsq_k as [n0 Fp].

rewrite K2.unsquash_squash.

rewrite K1.knot_level in H.

rewrite <- Hequnsq_k in H.

simpl in H.

replace (fmap F (K2.approx n0) (fF_Z Fp)) with

  ((fmap F (K2.approx n0) oo (fmap F gZ_pred)) Fp) by trivial.

rewrite fmap_comp.

replace (gF_Z (fmap F (K2.approx n0 oo gZ_pred) Fp)) with

  ((fmap F fZ_pred oo fmap F (K2.approx n0 oo gZ_pred)) Fp) by trivial.

rewrite fmap_comp.

assert (n0 = 0) by omega.

clear H; subst n0.

symmetry in Hequnsq_k.

rewrite predZ_iso1; trivial.

rewrite <- (K1L.unsquash_approx Hequnsq_k).

rewrite <- Hequnsq_k.

rewrite K1.squash_unsquash.

trivial.

Qed.



Lemma iso2_Z : forall k, level k <= 0 -> (f_Z oo g_Z) k = k.

Proof.

intros.

unfold compose, g_Z, f_Z.

remember (K2.unsquash k) as unsq_k.

destruct unsq_k as [n0 Fp].

rewrite K1.unsquash_squash.

rewrite K2.knot_level in H.

replace (fmap F (K1.approx n0) (gF_Z Fp)) with

  ((fmap F (K1.approx n0) oo (fmap F fZ_pred)) Fp) by trivial.

rewrite fmap_comp.

replace (fF_Z (fmap F (K1.approx n0 oo fZ_pred) Fp)) with

  ((fmap F gZ_pred oo fmap F (K1.approx n0 oo fZ_pred)) Fp) by trivial.

rewrite fmap_comp.

symmetry in Hequnsq_k.

assert (n0 = 0).

destruct (K2'.unsquash k); inv Hequnsq_k.

simpl in H.

omega.

subst n0.

rewrite predZ_iso2; trivial.

rewrite <- (K2L.unsquash_approx Hequnsq_k).

rewrite <- Hequnsq_k.

rewrite K2.squash_unsquash.

trivial.

Qed.



Lemma f_level_Z: forall k, level k = level (f_Z k).

Proof.

intro.

unfold f_Z.

rewrite K1.knot_level, K2.knot_level.

remember (K1.unsquash k) as uk.

destruct uk.

rewrite K2.unsquash_squash.

trivial.

Qed.



Lemma g_level_Z: forall k, level k = level (g_Z k).

Proof.

intro.

unfold g_Z.

simpl.

rewrite K1.knot_level, K2.knot_level.

remember (K2.unsquash k) as uk.

destruct uk.

rewrite K1.unsquash_squash.

trivial.

Qed.



Lemma fZ_unsquash : forall k1,

  level k1 <= 0 ->

  forall U1,

  U1 = K1.unsquash k1 ->

  K2.unsquash (f_Z k1) = (fst U1, fF_Z (snd U1)).

Proof.

intros.

unfold fF_Z, f_Z.

destruct U1 as [n F1].

simpl.

rewrite <- H0.

rewrite K2.unsquash_squash.

replace (fmap F (K2.approx n) (fF_Z F1)) with

 ((fmap F (K2.approx n) oo fmap F gZ_pred) F1) by trivial.

rewrite fmap_comp.

assert (K2'.approx n oo gZ_pred = gZ_pred).

extensionality P1 k2.

destruct k2.

unfold gZ_pred, compose, K2'.approx; simpl.

destruct (le_gt_dec n (level k)); auto.

congruence.

Qed.



End Z.



Section Sn.



Variable f : K1.knot -> K2.knot.

Variable g : K2.knot -> K1.knot.



Definition f_Sn (k1 : K1.knot) : K2.knot :=

  match K1.unsquash k1 with

    (n, F_p1) => K2.squash (n, f_F' g F_p1)

  end.



Definition g_Sn (k2 : K2.knot) : K1.knot :=

  match K2.unsquash k2 with

    (n, F_p2) => K1.squash (n, g_F' f F_p2)

  end.



Variable n : nat.

Variable iso1 : forall k, level k <= n -> (g oo f) k = k.

Variable iso2 : forall k, level k <= n -> (f oo g) k = k.



Lemma f_inj : forall ka kb,

  level ka <= n ->

  level kb <= n ->

  f ka = f kb ->

  ka = kb.

Proof.

intros.

assert ((g oo f) ka = (g oo f) kb) by (unfold compose; rewrite H1; trivial).

do 2 rewrite iso1 in H2; trivial.

Qed.



Lemma g_inj : forall ka kb,

  level ka <= n ->

  level kb <= n ->

  g ka = g kb ->

  ka = kb.

Proof.

intros.

assert ((f oo g) ka = (f oo g) kb) by (unfold compose; rewrite H1; trivial).

do 2 rewrite iso2 in H2; trivial.

Qed.



Lemma f_surj : forall k2,

  level k2 <= n ->

  exists k1,

  f k1 = k2.

Proof.

intros.

exists (g k2).

rewrite <- iso2; trivial.

Qed.



Lemma g_surj : forall k1,

  level k1 <= n ->

  exists k2,

  g k2 = k1.

Proof.

intros.

exists (f k1).

rewrite <- iso1; trivial.

Qed.



Variable f_level: forall k, level k = level (f k).

Variable g_level: forall k, level k = level (g k).



Lemma predn_iso1: forall m,

  m <= (n+1) ->

  g_pred' f oo K2.approx m oo f_pred' g = K1.approx m.

Proof.

intros.

extensionality p k.

unfold g_pred', f_pred', compose in *.

destruct k.

unfold K2'.approx, map_pair, id; simpl.

unfold K1'.approx; simpl.

rewrite <- f_level.

simpl.

destruct (le_gt_dec m (level k)); auto.

rewrite iso1; auto.

simpl; omega.

Qed.



Lemma predn_iso2: forall m,

  m <= (n+1) ->

  f_pred' g oo K1.approx m oo g_pred' f = K2.approx m.

Proof.

intros.

extensionality p k.

unfold g_pred', f_pred', compose in *.

destruct k.

unfold K1'.approx, map_pair, id; simpl.

unfold K2'.approx; simpl.

rewrite <- g_level.

simpl.

destruct (le_gt_dec m (level k)); auto.

rewrite iso2; auto.

simpl; omega.

Qed.



Lemma iso1_Sn : forall k, level k <= n + 1 -> (g_Sn oo f_Sn) k = k.

Proof.

intros.

unfold compose, g_Sn, f_Sn.

remember (K1.unsquash k) as unsq_k.

destruct unsq_k as [n0 Fp].

rewrite K2.unsquash_squash.

rewrite K1.knot_level in H.

rewrite <- Hequnsq_k in H.

simpl in H.

replace (fmap F (K2.approx n0) (f_F' g Fp)) with

  ((fmap F (K2.approx n0) oo (fmap F (f_pred' g))) Fp) by trivial.

rewrite fmap_comp.

replace (g_F' f (fmap F (K2.approx n0 oo f_pred' g) Fp)) with

  ((fmap F (g_pred' f) oo fmap F (K2.approx n0 oo f_pred' g)) Fp) by trivial.

rewrite fmap_comp.

symmetry in Hequnsq_k.

rewrite predn_iso1; trivial.

rewrite <- (K1L.unsquash_approx Hequnsq_k).

rewrite <- Hequnsq_k.

rewrite K1.squash_unsquash.

trivial.

Qed.



Lemma iso2_Sn : forall k, level k <= n + 1 -> (f_Sn oo g_Sn) k = k.

Proof.

intros.

unfold compose, g_Sn, f_Sn.

remember (K2.unsquash k) as unsq_k.

destruct unsq_k as [n0 Fp].

rewrite K1.unsquash_squash.

simpl in H.

rewrite K2.knot_level in H.

rewrite <- Hequnsq_k in H.

simpl in H.

replace (fmap F (K1.approx n0) (g_F' f Fp)) with

  ((fmap F (K1.approx n0) oo (fmap F (g_pred' f))) Fp) by trivial.

rewrite fmap_comp.

replace (f_F' g (fmap F (K1.approx n0 oo g_pred' f) Fp)) with

  ((fmap F (f_pred' g) oo fmap F (K1.approx n0 oo g_pred' f)) Fp) by trivial.

rewrite fmap_comp.

symmetry in Hequnsq_k.

rewrite predn_iso2; trivial.

rewrite <- (K2L.unsquash_approx Hequnsq_k).

rewrite <- Hequnsq_k.

rewrite K2.squash_unsquash.

trivial.

Qed.



Lemma f_level_Sn: forall k, level k = level (f_Sn k).

Proof.

intro.

unfold f_Sn.

rewrite K1.knot_level, K2.knot_level.

remember (K1.unsquash k) as uk.

destruct uk.

rewrite K2.unsquash_squash.

trivial.

Qed.



Lemma g_level_Sn: forall k, level k = level (g_Sn k).

Proof.

intro.

unfold g_Sn.

rewrite K1.knot_level, K2.knot_level.

remember (K2.unsquash k) as uk.

destruct uk.

rewrite K1.unsquash_squash.

trivial.

Qed.



Variable fn_unsquash : forall k1,

  level k1 <= n ->

  forall U1,

  U1 = K1.unsquash k1 ->

  K2.unsquash (f k1) = (fst U1, f_F' g (snd U1)).



Lemma Fn_iso2 : forall m,

  m <= n + 1 ->

  g_F' f oo f_F' g oo fmap F (K1.approx m) = fmap F (K1.approx m).

Proof.

intros.

unfold g_F', f_F'.

do 2 rewrite fmap_comp.

replace (g_pred' f oo f_pred' g oo K1.approx m) with (K1.approx m); trivial.

rewrite f_pred'_approx; trivial.

rewrite predn_iso1; trivial.

Qed.



Lemma gn_unsquash : forall k2,

  level k2 <= n ->

  forall U2,

  U2 = K2.unsquash k2 ->

  K1.unsquash (g k2) = (fst U2, g_F' f (snd U2)).

Proof.

intros.

destruct U2 as [m F2].

simpl.

generalize (fn_unsquash (g k2)); intro.

rewrite <- g_level in H1.

remember (g k2) as k1.

specialize ( H1 H (K1.unsquash k1)).

firstorder.

assert (f k1 = (f oo g) k2) by (unfold compose; congruence).

rewrite iso2 in H2; trivial.

rewrite H2 in H1.

rewrite <- H0 in H1.

inversion H1.

apply injective_projections; simpl; trivial.

remember (K1.unsquash k1) as U1.

replace (g_F' f (f_F' g (snd U1))) with ((g_F' f oo f_F' g) (snd U1)) by trivial.

destruct U1 as [m' F1].

simpl in *.

subst m'.

clear H1.

symmetry in HeqU1.

generalize (K1L.unsquash_approx HeqU1); intro.

rewrite H1.

replace ((g_F' f oo f_F' g) (fmap F (K1'.approx m) F1)) with

  ((g_F' f oo f_F' g oo fmap F (K1.approx m)) F1) by trivial.

rewrite Fn_iso2.

trivial.

simpl in H.

rewrite K2.knot_level in H.

rewrite <- H0 in H.

simpl in H.

omega.

Qed.



Lemma gn_squash : forall m F2,

  m <= n ->

  g (K2.squash (m, F2)) = K1.squash (m, g_F' f F2).

Proof.

intros.

apply (K1L.unsquash_inj).

assert (level (K2.squash (m , F2)) <= n) by

  (simpl; rewrite K2.knot_level; rewrite K2.unsquash_squash; simpl; trivial).

rewrite (gn_unsquash (K2'.squash (m, F2)) H0 (K2.unsquash (K2'.squash (m, F2)))); trivial.

rewrite K1.unsquash_squash.

rewrite K2.unsquash_squash.

simpl.

replace (g_F' f (fmap F (K2'.approx m) F2)) with

  ((fmap F (g_pred' f) oo (fmap F (K2.approx m))) F2) by trivial.

replace (m, fmap F (K1'.approx m) (g_F' f F2)) with

  (m, (fmap F (K1.approx m) oo fmap F (g_pred' f)) F2) by trivial.

do 2 rewrite fmap_comp.

apply injective_projections; simpl; trivial.

rewrite g_pred'_approx; trivial.

Qed.



Lemma fSn_unsquash : forall k1,

  level k1 <= n + 1 ->

  forall U1,

  U1 = K1.unsquash k1 ->

  K2.unsquash (f_Sn k1) = (fst U1, f_F' (g_Sn) (snd U1)).

Proof.

intros.

unfold f_Sn.

rewrite <- H0.

destruct U1 as [m F1].

simpl.

rewrite K2.unsquash_squash.

apply injective_projections; simpl; trivial.

unfold f_F'.

replace (fmap F (K2'.approx m) (fmap F (f_pred' g) F1)) with

  ((fmap F (K2.approx m) oo fmap F  (f_pred' g)) F1) by trivial.

rewrite fmap_comp.

simpl in H.

rewrite K1.knot_level in H.

rewrite <- H0 in H.

simpl in H.

symmetry in H0.

generalize (K1L.unsquash_approx H0); intro.

pattern F1 at 2.

rewrite H1.

replace (fmap F (f_pred' g_Sn) (fmap F (K1'.approx m) F1)) with

  ((fmap F (f_pred' g_Sn) oo fmap F (K1.approx m)) F1) by trivial.

rewrite fmap_comp.

assert (K2'.approx m oo f_pred' g = f_pred' g_Sn oo K1.approx m); try congruence.

extensionality p1 k2.

destruct k2.

simpl; unfold f_pred', compose, K1.approx, K2.approx, g_Sn; simpl.

rewrite K1.knot_level, K2'.knot_level; unfold g_Sn; simpl.

unfold map_pair; simpl.

remember (K2.unsquash k) as uk2.

destruct uk2 as [m' F2].

rewrite K1.unsquash_squash.

simpl.

destruct (le_gt_dec m m'); auto.

unfold id.

rewrite <- gn_squash in *; [ | omega ].

rewrite Hequk2.

rewrite K2.squash_unsquash; trivial.

Qed.



Lemma gn_gSn_eq_n : forall k,

level k <= n ->

g k = g_Sn k.

Proof.

intros.

unfold g_Sn.

remember (K2.unsquash k) as usqk.

destruct usqk.

simpl in H.

rewrite K2.knot_level in H.

rewrite <- Hequsqk in H.

simpl in H.

rewrite <- gn_squash; try omega.

rewrite Hequsqk.

rewrite K2.squash_unsquash.

trivial.

Qed.



End Sn.



Section FG.



Fixpoint fg (n : nat) {struct n} : ((K1.knot -> K2.knot) * (K2.knot -> K1.knot)) :=

  match n with

   | 0 => (f_Z, g_Z)

   | S n => match fg n with (fn, gn) => (f_Sn gn, g_Sn fn) end

  end.



Lemma fg_level_fst : forall n k, level k = level (fst (fg n) k).

Proof.

intros.

destruct n.

apply f_level_Z.

unfold fg.

fold fg.

destruct (fg n).

apply f_level_Sn.

Qed.



Lemma fg_level_snd : forall n k, level k = level (snd (fg n) k).

Proof.

intros.

destruct n.

apply g_level_Z.

unfold fg.

fold fg.

destruct (fg n).

apply g_level_Sn.

Qed.



Lemma fg_id : forall n k, level k <= n -> (fst (fg n) oo snd (fg n)) k  = k.

Proof.

induction n.

unfold fg.

simpl.

intros.

rewrite iso2_Z; trivial.

unfold fg.

fold fg.

remember (fg n) as fgn.

destruct fgn as [fn gn].

simpl in *.

intros.

rewrite (iso2_Sn fn gn n); trivial; try omega.

intros.

destruct n.

unfold fg in Heqfgn.

inversion Heqfgn.

apply g_level_Z.

unfold fg in Heqfgn.

fold fg in Heqfgn.

destruct (fg n).

inversion Heqfgn.

apply g_level_Sn.

Qed.



Lemma gf_id : forall n k, level k <= n -> (snd (fg n) oo fst (fg n)) k  = k.

Proof.

induction n.

unfold fg.

simpl.

intros.

rewrite iso1_Z; trivial.

unfold fg.

fold fg.

remember (fg n) as fgn.

destruct fgn as [fn gn].

simpl in *.

intros.

rewrite (iso1_Sn fn gn n); trivial; try omega.

intros.

destruct n.

unfold fg in Heqfgn.

inversion Heqfgn.

apply f_level_Z.

unfold fg in Heqfgn.

fold fg in Heqfgn.

destruct (fg n).

inversion Heqfgn.

apply f_level_Sn.

Qed.



Lemma fg_fst_unsquash: forall n k, level k <= n ->

  forall U1,

  U1 = K1.unsquash k ->

  K2.unsquash (fst (fg n) k) = (fst U1, f_F' (snd (fg n)) (snd U1)).

Proof.

induction n;

unfold fg;

fold fg;

simpl;

intros.

rewrite (fZ_unsquash k H U1 H0).



apply injective_projections; simpl; trivial.

unfold f_F', fF_Z.

destruct U1 as [m F1].

simpl.

simpl in H; rewrite K1.knot_level in H.

rewrite <- H0 in H.

simpl in H.

assert (m = 0) by omega.

subst m.

clear H.

symmetry in H0.

generalize (K1L.unsquash_approx H0); intro.

pattern F1 at 2.

rewrite H.

replace (fmap F (f_pred' g_Z) (fmap F (K1'.approx 0) F1)) with

  ((fmap F (f_pred' g_Z) oo fmap F (K1.approx 0)) F1) by trivial.

rewrite fmap_comp.

replace (f_pred' g_Z oo K1'.approx 0) with gZ_pred; trivial.



remember (fg n) as fgn.

destruct fgn as [fn gn].

simpl in *.

replace gn with (snd (fg n)) by (rewrite <- Heqfgn; trivial).

generalize (fSn_unsquash (fst (fg n)) (snd (fg n)) n (gf_id n) (fg_id n) (fg_level_fst n) (fg_level_snd n)); intro.

rewrite <- Heqfgn in H1.

simpl in H1.

replace (n + 1) with (S n) in H1 by omega.

specialize ( H1 IHn k H U1 H0).

rewrite <- Heqfgn.

simpl.

rewrite H1.

trivial.

Qed.



Lemma fg_fg_eq: forall n k2,

level k2 < n ->

snd (fg (level k2)) k2 = snd (fg n) k2.

Proof.

intros.

assert (exists m, level k2 + m = n).

remember (level k2) as m.

clear -H.

induction n.

inversion H.

assert (m = n \/ m < n) by omega.

clear H.

destruct H0.

subst n.

exists 1.

omega.

destruct (IHn H) as [m0 ?].

rewrite <- H0.

exists (m0 + 1).

omega.

destruct H0 as [m ?].

clear H.

revert m H0.

induction n; intros.

replace (level k2) with 0 by omega; trivial.

destruct m.

replace (level k2 + 0) with (level k2) in H0 by trivial.

rewrite H0.

trivial.

specialize ( IHn m).

rewrite IHn; try omega.

unfold fg; fold fg.

remember (fg n) as fgn.

destruct fgn as [fn gn].

simpl.

generalize (gn_gSn_eq_n (fst (fg n)) (snd (fg n)) n (gf_id n) (fg_id n) (fg_level_fst n) (fg_level_snd n) (fg_fst_unsquash n)); intro.

rewrite <- Heqfgn in H.

simpl in H.

apply H.

simpl in *.

omega.

Qed.



End FG.



Definition f (k : K1.knot) : K2.knot := fst (fg (level k)) k.



Definition g (k : K2.knot) : K1.knot := snd (fg (level k)) k.



Definition fF : TF.F K1.predicate -> TF.F K2.predicate :=

  f_F' g.



Definition gF : TF.F K2.predicate -> TF.F K1.predicate :=

  g_F' f.



Lemma iso1 : f oo g = id K2.knot.

Proof.

extensionality k.

unfold id.

unfold compose, f, g.

rewrite <- fg_level_snd.

remember (level k) as n.

replace (fst (fg n) (snd (fg n) k)) with ((fst (fg n) oo snd (fg n)) k) by trivial.

rewrite fg_id; trivial; omega.

Qed.



Lemma iso2 : g oo f = id K1.knot.

Proof.

extensionality k.

unfold id.

unfold compose, f, g.

rewrite <- fg_level_fst.

remember (level k) as n.

replace (snd (fg n) (fst (fg n) k)) with ((snd (fg n) oo fst (fg n)) k) by trivial.

rewrite gf_id; trivial; omega.

Qed.



Lemma fpred_gpred : f_pred' g oo g_pred' f = id (K2.predicate).

Proof.

extensionality P2 k2.

unfold id.

unfold g_pred', f_pred', map_pair, compose; simpl.

destruct k2; simpl.

replace (f (g k)) with ((f oo g) k) by trivial.

rewrite iso1.

trivial.

Qed.



Lemma gpred_fpred : g_pred' f oo f_pred' g = id (K1.predicate).

Proof.

extensionality P1 k1.

unfold id.

unfold g_pred', f_pred', compose.

unfold map_pair; simpl.

destruct k1; simpl.

replace (g (f k)) with ((g oo f) k) by trivial.

rewrite iso2.

trivial.

Qed.



Lemma Fiso1 : fF oo gF = id (F K2.predicate).

Proof.

extensionality F2.

unfold id.

unfold fF, gF, f_F', g_F'.

rewrite fmap_comp.

rewrite fpred_gpred.

rewrite fmap_id.

trivial.

Qed.



Lemma Fiso2 : gF oo fF = id (F K1.predicate).

Proof.

extensionality F1.

unfold id.

unfold fF, gF, f_F', g_F'.

rewrite fmap_comp.

rewrite gpred_fpred.

rewrite fmap_id.

trivial.

Qed.



Lemma f_level : forall k, level k = level (f k).

Proof.

intros.

unfold f.

rewrite <- (fg_level_fst (level k)).

trivial.

Qed.



Lemma g_level : forall k, level k = level (g k).

Proof.

intros.

unfold g.

rewrite <- (fg_level_snd (level k)).

trivial.

Qed.



Lemma f_unsquash : forall k1 U1,

  U1 = K1.unsquash k1 ->

  K2.unsquash (f k1) = (fst U1, fF (snd U1)).

Proof.

intros.

destruct U1 as [n F1].

simpl.

unfold f; simpl; rewrite K1.knot_level.

rewrite <- H.

simpl.

assert (level k1 <= n) by (rewrite K1.knot_level; rewrite <- H; trivial).

rewrite (fg_fst_unsquash n k1 H0 (n, F1)); trivial.

simpl.

apply injective_projections; simpl; trivial.

unfold fF.

symmetry in H.

generalize (K1L.unsquash_approx H); intro.

rewrite H1.

unfold f_F'.

replace (fmap F (f_pred' (snd (fg n))) (fmap F (K1'.approx n) F1)) with

  ((fmap F (f_pred' (snd (fg n))) oo fmap F (K1.approx n)) F1) by trivial.

replace (fmap F (f_pred' g) (fmap F (K1'.approx n) F1)) with

  ((fmap F (f_pred' g) oo fmap F (K1.approx n)) F1) by trivial.

do 2 rewrite fmap_comp.

replace (f_pred' (snd (fg n)) oo K1.approx n) with (f_pred' g oo K1'.approx n); trivial.

extensionality P1 k2.

unfold f_pred', compose.

unfold K1.approx.

unfold map_pair; destruct k2; simpl.

rewrite <- fg_level_snd.

rewrite <- g_level.

simpl.

destruct (le_gt_dec n (level k)); auto.

unfold g.

red in g0.

rewrite (fg_fg_eq n k g0).

auto.

Qed.



Lemma g_unsquash : forall k2 U2,

  U2 = K2.unsquash k2 ->

  K1.unsquash (g k2) = (fst U2, gF (snd U2)).

Proof.

intros.

destruct U2 as [n F2].

simpl.

generalize (f_unsquash (g k2)); intro.

remember (g k2) as k1.

specialize ( H0 (K1.unsquash k1)).

firstorder.

assert (f k1 = (f oo g) k2) by (unfold compose; congruence).

rewrite iso1 in H1.

unfold id in H1.

rewrite H1 in H0.

rewrite <- H in H0.

inversion H0.

remember (K1.unsquash k1) as U1.

replace (gF (fF (snd U1))) with ((gF oo fF) (snd U1)) by trivial.

rewrite Fiso2.

unfold id.

destruct U1.

trivial.

Qed.



Lemma fF_approx : forall n,

fF oo (fmap F (K1.approx n)) = (fmap F (K2.approx n)) oo fF.

Proof.

intros.

unfold fF, f_F'.

do 2 rewrite fmap_comp.

rewrite f_pred'_approx.

trivial.

apply g_level.

Qed.



Lemma gF_approx : forall n,

gF oo (fmap F (K2.approx n)) = (fmap F (K1.approx n)) oo gF.

Proof.

intros.

unfold gF, g_F'.

do 2 rewrite fmap_comp.

rewrite g_pred'_approx.

trivial.

apply f_level.

Qed.



Lemma f_squash : forall n F1,

  f (K1.squash (n, F1)) = K2.squash (n, fF F1).

Proof.

intros.

apply (K2L.unsquash_inj).

rewrite (f_unsquash (K1'.squash (n, F1)) (K1.unsquash (K1'.squash (n, F1)))); trivial.

rewrite K1.unsquash_squash.

rewrite K2.unsquash_squash.

simpl.

replace (fF (fmap F (K1'.approx n) F1)) with

  ((fF oo (fmap F (K1.approx n))) F1) by trivial.

rewrite fF_approx.

trivial.

Qed.



Lemma g_squash : forall n F2,

  g (K2.squash (n, F2)) = K1.squash (n, gF F2).

Proof.

intros.

apply (K1L.unsquash_inj).

rewrite (g_unsquash (K2'.squash (n, F2)) (K2.unsquash (K2'.squash (n, F2)))); trivial.

rewrite K1.unsquash_squash.

rewrite K2.unsquash_squash.

simpl.

replace (gF (fmap F (K2'.approx n) F2)) with

  ((gF oo (fmap F (K2.approx n))) F2) by trivial.

rewrite gF_approx.

trivial.

Qed.



End Unique_Knot.

