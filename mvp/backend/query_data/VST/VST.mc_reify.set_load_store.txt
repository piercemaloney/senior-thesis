Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import mc_reify.bool_funcs.
(* mc_reify.bool_funcs:
Require Import VST.veric.expr.
Require Import VST.veric.SeparationLogic.
Require Import VST.floyd.local2ptree.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import Coq.Bool.Bool.
Require Import Coq.Lists.List.
Require Import mc_reify.clight_expr_eq.

Fixpoint denote_tc_assert_b_norho a:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| tc_orp' a b => orb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| _ => false
end.

Fixpoint denote_tc_assert_b_norho_forgive_isptr a e:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho_forgive_isptr a e)
                       (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_orp' a b => orb (denote_tc_assert_b_norho_forgive_isptr a e)
                     (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_isptr e0 => expr_beq e e0
| _ => false
end.

Lemma denote_tc_assert_b_norho_sound: forall a rho,
  denote_tc_assert_b_norho a = true -> denote_tc_assert a rho.

Lemma denote_tc_assert_b_norho_forgive_isptr_sound: forall a e rho,
  denote_tc_assert_b_norho_forgive_isptr a e = true ->
  isptr (expr.eval_expr e rho) ->

Definition tc_lvalue_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_lvalue Delta e).

Definition tc_expr_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_expr Delta e).

Definition tc_temp_id_b_norho id t Delta e:=
denote_tc_assert_b_norho (typecheck_temp_id id t Delta e).

Definition tc_lvalue_b_norho' Delta e :=
  match e with
  | Ederef e0 t => denote_tc_assert_b_norho_forgive_isptr
                     (typecheck_lvalue Delta e) e0
  | _ => denote_tc_assert_b_norho (typecheck_lvalue Delta e)
  end.

Lemma tc_lvalue_b_sound :
forall e Delta rho,
tc_lvalue_b_norho Delta e = true ->
tc_lvalue Delta e rho .

Lemma tc_expr_b_sound :
forall e Delta rho,
tc_expr_b_norho Delta e = true ->
tc_expr Delta e rho .

Lemma tc_temp_id_b_sound :
forall id t Delta e rho,
tc_temp_id_b_norho id t Delta e= true ->
tc_temp_id id t Delta e rho .

Lemma tc_lvalue_b'_sound :
forall e Delta rho,
tc_lvalue_b_norho' Delta e = true ->
isptr (expr.eval_lvalue e rho) ->

Fixpoint tc_efield_b_norho Delta efs :=
  match efs with
  | nil => true
  | eArraySubsc ei :: efs' =>
      (tc_expr_b_norho Delta ei && tc_efield_b_norho Delta efs')%bool
  | eStructField _ :: efs' => tc_efield_b_norho Delta efs'
  | eUnionField _ :: efs' => tc_efield_b_norho Delta efs'
  end.

Lemma tc_efield_b_sound: forall efs Delta rho,
  tc_efield_b_norho Delta efs = true -> tc_efield Delta efs rho.

Definition tc_LR_b_norho Delta e lr :=
  match lr with
  | LLLL => tc_lvalue_b_norho' Delta e
  | RRRR => tc_expr_b_norho Delta e
  end.

Definition type_is_int (e: Clight.expr) : bool :=
  match typeof e with
  | Tint _ _ _ => true
  | _ => false
  end. *)

Require Import Coq.Logic.JMeq.

Local Open Scope logic.



Require Export mc_reify.reify.

Require Import mc_reify.set_reif.
(* mc_reify.set_reif:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCore.Lambda.ExprCore.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.

Definition match_reif_option {B: Type} (e: expr typ func) (somef : typ -> expr typ func -> B)
           (nonef : typ -> B) (d : B) :=
match e with
| (App (Inj (inr (Other (fsome t)))) e) => somef t e
| (Inj (inr (Other (fnone t)))) => nonef t
| _ => d
end.

Inductive val_e :=
    Vundef : val_e
  | Vint : int -> val_e
  | Vlong : int64 -> val_e
  | Vfloat : float -> val_e
  | Vsingle : float32 -> val_e
  | Vexpr : expr typ func -> val_e
  | Vunop : Cop.unary_operation -> type ->  val_e -> val_e
  | Vbinop : Cop.binary_operation -> type -> type -> val_e -> val_e -> val_e
  | Veval_cast : type -> type -> val_e -> val_e
  | Vforce_ptr : val_e -> val_e
  | Veval_field : type -> ident -> val_e -> val_e.

Definition Vderef_noload (t: type) (e: val_e) : val_e :=
  match access_mode t with
  | By_reference => e
  | _ => Vundef
  end.

Definition val_e_binarith op ty1 ty2 e1 e2 :=
  match op, ty1, ty2, e1, e2 with
  | Oand, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_land) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_and) e1') e2')
      end
  | Oadd, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_add) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_add) e1') e2')
      end
  | _, _, _, _, _ => App (appR (Eval_f (feval_binop op
                                         ty1 ty2)) e1) e2
  end.

Fixpoint val_e_to_expr (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (appR (Intop fint_repr) (injR (Const (fZ (Int.unsigned i))))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr e)
  | Vbinop op ty1 ty2 e1 e2 => val_e_binarith op ty1 ty2 (val_e_to_expr e1) (val_e_to_expr e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr v)
end.

Definition msubst_var id T2 ty :=
match get_reif id T2 (typrod tyc_type tyval) with
  | App (Inj (inr (Other (fsome t))))
        (App (App (Inj (inr (Data (fpair t1 t2))))
                  (Inj (inr (Const (fCtype ty')))))
             v) =>
    if eqb_type ty ty'
    then Some (Vexpr v)
    else None
  | _ => None
end.

Fixpoint msubst_eval_expr_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option (val_e) :=
  match e with
  | Econst_int i ty => Some (Vint i)
  | Econst_long i ty => Some (Vlong i)
  | Econst_float f ty => Some (Vfloat f)
  | Econst_single f ty => Some (Vsingle f)
  | Etempvar id ty => match get_reif id T1 tyval with
                        | (App (Inj (inr (Other (fsome t)))) v) => Some (Vexpr v)
                        | _ => None
                      end
  | Eaddrof a ty => msubst_eval_lvalue_reif T1 T2 a
  | Eunop op a ty =>  option_map (Vunop op (typeof a)) (msubst_eval_expr_reif T1 T2 a)
  | Ebinop op a1 a2 ty => match (msubst_eval_expr_reif T1 T2 a1), (msubst_eval_expr_reif T1 T2 a2) with
                            | Some v1, Some v2 => Some (Vbinop op (typeof a1) (typeof a2) v1 v2)
                            | _, _ => None
                          end
  | Ecast a ty => option_map (Veval_cast (typeof a) ty) (msubst_eval_expr_reif T1 T2 a)
  | Evar id ty => option_map (Vderef_noload ty) (msubst_var id T2 ty)
  | Ederef a ty => option_map (Vderef_noload ty) (option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a))
  | Efield a i ty => option_map (Vderef_noload ty) (option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a))
  end
with
msubst_eval_lvalue_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option val_e :=
  match e with
  | Evar id ty => (msubst_var id T2 ty)
  | Ederef a ty => option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a)
  | Efield a i ty => option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a)
  | _  => Some Vundef
  end.

Definition rmsubst_eval_expr (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue T1 T2 e
| RRRR => rmsubst_eval_expr T1 T2 e
end.

Fixpoint msubst_efield_denote_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
  match efs with
  | nil => Some (injR (Data (fnil tygfield)))
  | cons (eStructField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx fstruct_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eUnionField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx funion_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eArraySubsc ei) efs0 =>
      match typeof ei, rmsubst_eval_expr T1 T2 ei with
      | Tint _ _ _,
        App (Inj (inr (Other (fsome _))))
         (App (Inj (inr (Value fVint))) i) =>
          match i with
          | App (Inj (inr (Intop fint_repr))) i' =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) i')))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          | _ =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) (appR (Intop fint_unsigned) i))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          end
      | _, _ => None
      end
  end.

Definition rmsubst_efield_denote (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
match msubst_efield_denote_reif T1 T2 efs with
| Some e => some_reif e (tylist tygfield)
| None => none_reif (tylist tygfield)
end.

Lemma Forall_reverse :
forall A P (l: list A),
Forall P l <->
Forall P (rev l).

Lemma in_fst :
forall T T2 (p : T) (v: T2) l,
In (p, v) l -> In p (map fst l).

Lemma elt_eq : forall T l p (v:T) v0 ls,
(p, v0) :: l = rev (PTree.elements (PTree.set p v ls)) ->

Definition tempD' := (fun Q i v => `(eq v) (eval_id i) :: Q).
Definition localD' := (fun Q i tv => `(eq (snd tv)) (eval_var i (fst tv)) :: Q).
Definition LocalD_app (T1: PTree.t val) (T2: PTree.t (type * val)) (Q: list (environ -> Prop)) :=
  (PTree.fold tempD' T1 nil) ++
 (PTree.fold localD' T2 nil) ++ Q.

Lemma localD_app_eq : forall t2 q, PTree.fold localD' t2 q = PTree.fold localD' t2 nil ++ q.

Lemma tempD_app_eq : forall t2 q, PTree.fold tempD' t2 q = PTree.fold tempD' t2 nil ++ q.

Lemma LocalD_app_eq :
forall t1 t2 q,
LocalD t1 t2 q = LocalD_app t1 t2 q.

Lemma fold_right_conj :
forall a b rho,
(fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) (a ++ b) rho) <-> ((fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) a rho /\ fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) b rho)).

Lemma LocalD_to_localD : forall P R t l,
PROPx (P) (LOCALx (LocalD t l []) (SEPx (R))) =
PROPx (P) (LOCALx (localD t l) (SEPx (R))).

Fixpoint val_e_to_expr_std (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (injR (Const (fint i))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr_std e)
  | Vbinop op ty1 ty2 e1 e2 => App (appR (Eval_f (feval_binop op ty1 ty2)) (val_e_to_expr_std e1)) (val_e_to_expr_std e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr_std v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr_std v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr_std v)
end.

Definition rmsubst_eval_expr_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue_std T1 T2 e
| RRRR => rmsubst_eval_expr_std T1 T2 e
end. *)

Require Import MirrorCore.Lemma.

Require Import MirrorCharge.RTac.ReifyLemma.

Require Import mc_reify.update_tycon.
(* mc_reify.update_tycon:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.reify.
Require Import MirrorCore.Lambda.ExprCore.

Definition initialized_temp (id : positive) (t : PTree.t (type * bool)) :=
match (t ! id) with
| Some (ty, _) =>
  PTree.set id (ty, true) t
| None => t
end.

Fixpoint update_temp (t : PTree.t (type * bool)) (s : statement) :=
 match s with
 | Sskip | Scontinue | Sbreak => t
 | Sassign e1 e2 => t 
 | Sset id e2 => (initialized_temp id t)
 | Ssequence s1 s2 => let t' := update_temp t s1 in
                      update_temp t' s2
 | Sifthenelse b s1 s2 => join_te (update_temp t s1) (update_temp t s2)
 | Sloop _ _ => t
 | Sswitch e ls => update_temp_labeled t ls
 | Scall (Some id) _ _ => (initialized_temp id t)
 | _ => t  
end
with update_temp_labeled (t : PTree.t (type * bool)) (ls : labeled_statements) :=
       match ls with
         | LSnil => t
         | LScons _ s ls' =>
           join_te (update_temp t s) (update_temp_labeled t ls')
       end.

Lemma initialized_temp_eq : forall t v r gt gs i,
initialized i (mk_tycontext t v r gt gs) = mk_tycontext (initialized_temp i t) v r gt gs.

Lemma update_temp_eq : forall t v r gt gs s,
update_tycon (mk_tycontext t v r gt gs) s = (mk_tycontext (update_temp t s) v r gt gs)
with
update_temp_labeled_eq : forall t v r gt gs s,
join_tycon_labeled s (mk_tycontext t v r gt gs) = (mk_tycontext (update_temp_labeled t s) v r gt gs). *)

Require Export MirrorCore.RTac.Repeat.

Require Import MirrorCore.RTac.Then.

Require Export MirrorCore.RTac.Try.

Require Export MirrorCore.RTac.First.

Require Import MirrorCore.RTac.Fail.

Require Import MirrorCore.RTac.Simplify.

Require Import MirrorCore.Lambda.RedAll.

Require Import MirrorCore.Lambda.ExprUnify_simul.

Require Import MirrorCore.RTac.RTac.

Require Import MirrorCharge.RTac.Instantiate.

Require Import MirrorCharge.RTac.Intro.

Require Import MirrorCharge.RTac.Apply.

Require Import MirrorCharge.RTac.EApply.

Require Export mc_reify.funcs.

Require Import mc_reify.types.
(* mc_reify.types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)

Require Export mc_reify.reflexivity_tacs.

Require Import mc_reify.get_set_reif.
(* mc_reify.get_set_reif:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.
Locate expr.
Definition as_tree (e : expr typ func) : option
  ((typ * expr typ func * expr typ func * expr typ func) + typ) :=
match e with
  | (App (App (App (Inj (inr (Data (fnode t)))) l) o) r) =>
    Some (inl (t, l, o, r))
  | (Inj (inr (Data (fleaf t)))) =>
    Some (inr t)
  | _ => None
end.

Fixpoint set_reif (i : positive) (v : expr typ func) (m : expr typ func) (ty : typ) :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => node l (some_reif v t) r ty
      | xO ii => node (set_reif ii v l ty) o r t
      | xI ii => node l o (set_reif ii v r ty) t
    end
  | Some (inr t) =>
    match i with
      | xH => node (leaf t) (some_reif v t) (leaf t) ty
      | xO ii => node (set_reif ii v (leaf t) ty) (none_reif t) (leaf t) t
      | xI ii => node (leaf t) (none_reif t) (set_reif ii v (leaf t) ty) t
    end
  | _ => (App (App (Inj (inr (Data (fset ty i)))) v) m)
end.

Fixpoint get_reif (i : positive) (m : expr typ func) ty :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => o
      | xO ii => get_reif ii l ty
      | xI ii => get_reif ii r ty
    end
  | Some (inr t) => none_reif t
  | _ => (App (Inj (inr (Data (fget ty i))))  m)
end. *)

Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)

Require Import mc_reify.typ_eq.
(* mc_reify.typ_eq:
Require Import types.
Import Coq.Bool.Bool.

Fixpoint typ_beq a b :=
match a, b with
| tytycontext, tytycontext
| tyc_expr, tyc_expr
| tyc_type, tyc_type
| tyenviron, tyenviron
| tyval, tyval
| tyshare, tyshare
| tyident, tyident
| tyint, tyint
| tyZ, tyZ
| tynat, tynat
| typositive, typositive
| tybool, tybool
| tycomparison, tycomparison
| tytc_assert, tytc_assert
| tyint64, tyint64
| tyfloat, tyfloat
| tyattr, tyattr
| tysignedness, tysignedness
| tyintsize, tyintsize
| tyfloatsize, tyfloatsize
| tytypelist, tytypelist
| tyfieldlist, tyfieldlist
| tybinary_operation, tybinary_operation
| tyunary_operation, tyunary_operation
| tyN, tyN
| typrop, typrop
| tympred, tympred
| tyunit, tyunit
| tyOracleKind, tyOracleKind
| tystatement, tystatement
| tygfield, tygfield
| tyfunspec, tyfunspec
| tyret_assert, tyret_assert => true

| tysum tl1 tr1, tysum tl2 tr2
| typrod tl1 tr1, typrod tl2 tr2
| tyArr tl1 tr1, tyArr tl2 tr2 => andb (typ_beq tl1 tl2) (typ_beq tr1 tr2)
| tyoption t1, tyoption t2 => typ_beq t1 t2
| tylist t1, tylist t2 => typ_beq t1 t2
| _, _ => false
end.

SearchAbout BinPos.Pos.eqb.
Hint Resolve expr.eqb_type_true : beq_sound.
Hint Resolve BinPos.Peqb_true_eq : beq_sound.

Ltac prove_beq_sound :=
try solve [try reflexivity; inversion H];
repeat
match goal with
 | [H : typ_beq _ _ = true |- _ ] => simpl in H; rewrite andb_true_iff in H; destruct H
 | [ |- _ _ _ = _ _ _ ] => try f_equal
 | [ |- _ _  = _ _  ] => try f_equal
 | [H : forall x, _ -> ?a = x |- ?a = _ ] => apply H
end;
auto with beq_sound.

Lemma typ_beq_sound : forall a b, typ_beq a b = true -> a = b. *)

Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)

Require Import mc_reify.rtac_base.
(* mc_reify.rtac_base:
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Import MirrorCore.RTac.Then.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import MirrorCore.LemmaApply.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Util.ListMapT.

Definition rtacP := sigT (fun tac: rtac typ (expr typ func) =>
  forall tbl: SymEnv.functions RType_typ, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac).

Definition my_lemma := lemma typ (ExprCore.expr typ func) (ExprCore.expr typ func).

Definition THEN' (r1 r2 : rtac typ (expr typ func)) := THEN r1 (runOnGoals r2).

Definition THEN (r1 r2 : rtac typ (expr typ func)) :=
  THEN' r1 (THEN' (INSTANTIATE typ func) r2).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.

Lemma THEN_sound : forall t1 t2,
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t1 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t2 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) (THEN t1 t2).
intros. unfold THEN.
unfold THEN'.
apply THEN_sound; auto.
apply runOnGoals_sound; auto;
rtac_derive_soundness.
apply INSTANTIATE_sound.
apply runOnGoals_sound. auto.

Definition APPLY_sound := (@APPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _ _ ).

Definition EAPPLY_sound :=
  (@EAPPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _). 
Lemma APPLY_condition1: vars_to_uvars_spec vars_to_uvars.

Lemma APPLY_condition2:
 forall (subst : Type) (S : Subst subst (expr typ func))
   (SO : SubstOk S) (SU : SubstUpdate subst (expr typ func))
   (SUO : SubstUpdateOk SU SO),
 UnifyI.unify_sound

End tbled.

Definition thenP (t1 t2: rtacP) : rtacP :=
  match t1, t2 with
  | existT tac1 p1, existT tac2 p2 =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
   (THEN tac1 tac2) (fun tbl => THEN_sound tbl _ _ (p1 tbl) (p2 tbl))
  end.

Definition repeatP (n: nat) (t: rtacP) : rtacP :=
  match t with
  | existT tac p =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
        (REPEAT n tac)
        (fun tbl => @REPEAT_sound _ _ _ _ _ (Expr_ok_fs tbl) _ _ _ n _ (p tbl))
  end. *)



Lemma semax_set_localD:

    forall temp var ret gt

      id (e: Clight.expr) ty gs P T1 T2 R Post v,

  forall {Espec: OracleKind},

      typeof_temp (mk_tycontext temp var ret gt gs) id = Some ty ->

      is_neutral_cast (implicit_deref (typeof e)) ty = true ->

      msubst_eval_LR T1 T2 e RRRR = Some v ->

      tc_expr_b_norho (mk_tycontext temp var ret gt gs) e = true ->

      assertD P (localD (PTree.set id v T1) T2) R = Post ->

      semax (mk_tycontext temp var ret gt gs) (|> (assertD P (localD T1 T2) R))

        (Sset id e)

          (normal_ret_assert Post).

Proof.

  intros.

  subst Post.

  eapply semax_PTree_set; eauto.

  intro rho.

  apply tc_expr_b_sound with (rho := rho) in H2.

  normalize.

Qed.



Definition set_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

         (ret : type) (gt : PTree.t type) (id : ident)

         (e : Clight.expr) (ty : type): my_lemma.

reify_lemma reify_vst (semax_set_localD temp var ret gt id e ty).

Defined.



Lemma tc_LR_b_sound: forall Delta P T1 T2 R e1 lr p,

  msubst_eval_LR T1 T2 e1 lr = Some p ->

  assertD P (localD T1 T2) R |-- !! (isptr p) ->

  tc_LR_b_norho Delta e1 lr = true ->

  assertD P (localD T1 T2) R |-- local (tc_LR Delta e1 lr).

Proof.

  intros.

  pose proof msubst_eval_LR_eq P T1 T2 nil (map liftx R) e1 p _ H.

  change (PROPx P (LOCALx (LocalD T1 T2 []) (SEPx (map liftx R)))) with

    (assertD P (localD T1 T2) R) in H2.

  destruct lr; simpl tc_LR in *; simpl tc_LR_b_norho in *; simpl eval_LR in *.

  + rewrite (add_andp _ _ H2).

    rewrite (add_andp _ _ H0).

    rewrite andp_assoc.

    apply andp_left2.

    unfold local, lift1; intro rho; normalize.

    apply tc_lvalue_b'_sound; auto.

  + rewrite (add_andp _ _ H2).

    apply andp_left2.

    unfold local, lift1; intro rho; normalize.

    apply tc_expr_b_sound; auto.

Qed.



Lemma nth_error_prop:

  forall P T1 T2 R Rn (n : nat) S,

  assertD P (localD T1 T2) [Rn] |-- !! S ->

  nth_error R n = Some Rn ->

  assertD P (localD T1 T2) R |-- !! S.

Proof.

  intros.

  unfold assertD in *.

  unfold map in H.

  eapply derives_trans.

  + eapply nth_error_SEP_sepcon_TT with (n := n); [exact H |].

    apply map_nth_error, H0.

  + unfold TT.

    intro rho.

    simpl.

    rewrite @sepcon_prop_prop.

    normalize.

Qed.



Lemma semax_load_localD:

forall (temp : PTree.t (type * bool)) (var : PTree.t type)

     (ret : type) (gt : PTree.t type) (id : ident) (t t_root : type) (e0 e1 : Clight.expr)

     (efs : list efield) (tts : list type)

     (e : type_id_env) (lr : LLRR) (n: nat)

     (gs : PTree.t funspec) (sh : Share.t)

     (P : list Prop) (T1 : PTree.t val) (T2 : PTree.t (type * val))

     (R : list mpred) (Post : environ -> mpred)

     (gfs : list gfield)

     (p p' v : val) (v' : reptype t_root)

     (Espec : OracleKind),

  typeof_temp (mk_tycontext temp var ret gt gs) id = Some t ->

  is_neutral_cast (typeof e0) t = true ->

  msubst_efield_denote T1 T2 efs = Some gfs ->

  legal_nested_efield e t_root e1 gfs tts lr = true ->

  tc_efield_b_norho (mk_tycontext temp var ret gt gs) efs = true ->



  msubst_eval_LR T1 T2 e1 lr = Some p ->

  tc_LR_b_norho (mk_tycontext temp var ret gt gs) e1 lr = true ->

  (@eq (option mpred)) (nth_error R n) (Some (data_at sh t_root v' p')) ->

  (forall rho,

      !!(tc_environ (mk_tycontext temp var ret gt gs) rho) && (assertD P (localD T1 T2) R rho) |-- !! (p = p')) ->

  proj_val t_root gfs v' = v ->

  assertD P (localD (PTree.set id v T1) T2) R = Post ->

  nested_efield e1 efs tts = e0 ->



  (forall rho,

      !! (tc_environ (mk_tycontext temp var ret gt gs) rho) && (assertD P (localD T1 T2) R rho) |--

        !! (tc_val (typeof e0) v) &&

        !! (legal_nested_field t_root gfs)) ->

 semax (mk_tycontext temp var ret gt gs) (|> assertD P (localD T1 T2) R)

        (Sset id e0)

          (normal_ret_assert Post).

Proof.

  intros.

  subst Post e0.

  eapply semax_extract_later_prop'.

  Focus 1. {

    rewrite <- insert_local.

    exact H7.

  } Unfocus.

  intro; subst; clear H7.

  eapply semax_PTree_load with (gfs2 := gfs) (gfs0 := nil) (gfs1 := gfs) (t_root0 := t_root) (sh0 := sh);  eauto.

  + rewrite app_nil_r; reflexivity.

  + unfold assertD, localD, LocalD; simpl; intros. entailer!.

  + reflexivity.

  + repeat apply andp_right.

    - apply andp_left2. eapply tc_LR_b_sound; [eauto | | eauto].

      eapply nth_error_prop with (n := n); eauto.

      rewrite data_at_isptr.

      unfold assertD; entailer!.

    - intros rho.

      apply (derives_trans _ _ _ (H11 rho)).

      normalize.

    - intro rho.

      unfold local, lift1; simpl; apply prop_right.

      apply tc_efield_b_sound; auto.

  + intros rho.

    apply (derives_trans _ _ _ (H11 rho)).

    normalize.

Qed.



Definition load_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

     (ret : type) (gt : PTree.t type) (id : ident) (t t_root : type) (e0 e1 : Clight.expr)

    (efs: list efield) (tts : list type) (e : type_id_env) (lr : LLRR)

    (n: nat): my_lemma.

reify_lemma reify_vst (semax_load_localD temp var ret gt id t t_root e0 e1 efs tts e lr n).

Defined.



Lemma semax_store_localD:

    forall (temp : PTree.t (type * bool)) (var : PTree.t type)

     (ret : type) (gt : PTree.t type) (t t_root : type) (e0 e1 e2: Clight.expr)

     (efs : list efield) (tts : list type)

     (e : type_id_env) (lr : LLRR) (n: nat)

     sh P T1 T2 R gs Post

      (gfs: list gfield)

      (p p': val) (v0: val) (v': reptype t_root),

  forall {Espec: OracleKind},

      typeof (nested_efield e1 efs tts) = t ->

      type_is_by_value t = true ->

      tc_LR_b_norho (mk_tycontext temp var ret gt gs) e1 lr = true ->

      tc_LR_b_norho (mk_tycontext temp var ret gt gs) (Ecast e2 (typeof (nested_efield e1 efs tts))) RRRR = true ->

      tc_efield_b_norho (mk_tycontext temp var ret gt gs) efs = true ->

      msubst_efield_denote T1 T2 efs = Some gfs ->

      msubst_eval_LR T1 T2 e1 lr = Some p ->

      msubst_eval_LR T1 T2 (Ecast e2 t) RRRR = Some v0 ->

      legal_nested_efield e t_root e1 gfs tts lr = true ->



      (@eq (option mpred)) (nth_error R n) (Some (data_at sh t_root v' p')) ->

  (forall rho,

      !!(tc_environ (mk_tycontext temp var ret gt gs) rho) && (assertD P (localD T1 T2) R rho) |-- !! (p = p')) ->

  (forall rho,

      !! (tc_environ (mk_tycontext temp var ret gt gs) rho) && (assertD P (localD T1 T2) R rho) |--

        !! (legal_nested_field t_root gfs)) ->

  (assertD P (localD T1 T2)

                  (replace_nth n R

                    (data_at sh t_root

                      (upd_val t_root gfs v' v0) p))) = Post -> 

      writable_share sh ->

  nested_efield e1 efs tts = e0 ->



      semax (mk_tycontext temp var ret gt gs) (|>assertD P (localD T1 T2) R)

        (Sassign e0 e2)

          (normal_ret_assert Post).

Proof.

  intros.

  assert (Post = assertD P (localD T1 T2)

          (replace_nth n R

             (field_at sh t_root []

                (upd_reptype (nested_field_type2 t_root nil) gfs v'

                   (valinject _ v0)) p))); [| clear H11].

  Focus 1. {

    unfold upd_val in H11.

    rewrite <- data_at_field_at.

    subst Post.

    f_equal.

  } Unfocus.

  subst Post e0.

  eapply semax_extract_later_prop'.

  Focus 1. {

    rewrite <- insert_local.

    exact H9.

  } Unfocus.

  intro; subst; clear H9.

  unfold upd_val.

  eapply semax_PTree_store with (gfs2 := gfs) (gfs0 := nil) (gfs1 := gfs) (t_root0 := t_root) (sh0 := sh);  eauto.

  + rewrite app_nil_r; reflexivity.

  + unfold assertD, localD, LocalD; simpl; intros. entailer!.

  + repeat apply andp_right.

    - apply andp_left2. eapply tc_LR_b_sound; [eauto | | eauto].

      eapply nth_error_prop with (n := n); eauto.

      rewrite data_at_isptr.

      unfold assertD; entailer!.

    - intro rho.

      apply prop_right.

      eapply tc_expr_b_sound; auto.

    - intro rho.

      unfold local, lift1; simpl; apply prop_right.

      apply tc_efield_b_sound; auto.

Qed.



Definition store_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

     (ret : type) (gt : PTree.t type) (t t_root : type) (e0 e1 e2: Clight.expr)

     (efs : list efield) (tts : list type)

     (e : type_id_env) (lr : LLRR) (n: nat): my_lemma.

reify_lemma reify_vst (semax_store_localD temp var ret gt t t_root e0 e1 e2 efs tts e lr n).

Defined.



Section tbled.

Variable n : nat.

Variable tbl : SymEnv.functions RType_typ.



Let RSym_sym := RSym_sym tbl.

Existing Instance RSym_sym.



Let Expr_expr_fs := Expr_expr_fs tbl.

Existing Instance Expr_expr_fs.



Let Expr_ok_fs := Expr_ok_fs tbl.

Existing Instance Expr_ok_fs.



Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.

Existing Instance ExprVar_expr.



Existing Instance MA.



Existing Instance rtac_base.MentionsAnyOk.



Lemma load_store_sound_aux:

  forall t_root, (@funcAs typ func RType_typ

              (func_defs.RSym_sym tbl)

              (@inr

                 (sum

                    (sum SymEnv.func

                       (ModularFunc.ILogicFunc.ilfunc

                       typ))

                    (BILogicFunc.bilfunc typ))

                 func' (Sep (fdata_at t_root)))

              (tyArr tyshare

                 (tyArr

                    (reptyp t_root)

                    (tyArr tyval tympred))) =

            Some

              (fun (sh : share) (rt : typD (reptyp t_root)) (v : val) =>

               data_at sh t_root (reptyp_reptype t_root rt) v)).

Proof.

  intros.

  unfold funcAs; simpl.

  assert (forall pl: (fun t0 : typ =>

    {tyArr t0 (tyArr (reptyp t_root) (tyArr tyval tympred)) =

     tyArr tyshare (tyArr (reptyp t_root) (tyArr tyval tympred))} +

    {tyArr t0 (tyArr (reptyp t_root) (tyArr tyval tympred)) <>

     tyArr tyshare (tyArr (reptyp t_root) (tyArr tyval tympred))})

     tyshare, pl = left eq_refl).

  Focus 1. {

    intros.

    destruct pl; [f_equal; apply proof_irr | congruence].

  } Unfocus.

  match goal with

  | [ |- context [match (match ?e with _ => _ end) with _ => _ end] ] => rewrite (H e)

  end.

  unfold Rcast; simpl.

  reflexivity.

Qed.



Lemma APPLY_sound_store_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)

  (ret : type) (gt : PTree.t type) (t t_root : type)

  (e0 e1 e2 : Clight.expr) (efs : list efield) (tts : list type)

  (e : type_id_env) (lr : LLRR) (n : nat),

  rtac_sound (EAPPLY typ func (store_lemma temp var ret gt t t_root e0 e1 e2 efs tts e lr n)).

Proof.

  intros.

  apply EAPPLY_sound; auto with typeclass_instances.

  + apply APPLY_condition1.

  + apply APPLY_condition2.

  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.

    unfold exprD'_typ0. simpl.

    unfold exprD'. simpl.



    rewrite (load_store_sound_aux t_root); simpl.

    assert (@funcAs typ func RType_typ

                (func_defs.RSym_sym tbl)

                (@inr

                (sum

                (sum SymEnv.func

                (ILogicFunc.ilfunc typ))

                (BILogicFunc.bilfunc typ))

                func'

                (Sep (fupd_val t_root)))

                (tyArr

                (tylist tygfield)

                (tyArr

                (reptyp t_root)

                (tyArr tyval

                (reptyp t_root))))

      = Some

         (fun (gfs : list gfield) (v : typD (reptyp t_root)) (v0 : val) =>

          reptype_reptyp t_root (upd_val t_root gfs (reptyp_reptype t_root v) v0))).

    Focus 1. {

      intros.

      unfold funcAs.

      simpl.

      assert (forall pl: (fun t0 : typ =>

        {tyArr t0 (tyArr (reptyp t_root) (tyArr tyval (reptyp t_root))) =

         tyArr (tylist tygfield)

           (tyArr (reptyp t_root) (tyArr tyval (reptyp t_root)))} +

        {tyArr t0 (tyArr (reptyp t_root) (tyArr tyval (reptyp t_root))) <>

         tyArr (tylist tygfield)

           (tyArr (reptyp t_root) (tyArr tyval (reptyp t_root)))})

         (tylist tygfield), pl = left eq_refl).

      Focus 1. {

        intros.

        destruct pl; [f_equal; apply proof_irr | congruence].

      } Unfocus.

      match goal with

      | [ |- context [match (match ?e with _ => _ end) with _ => _ end] ] => rewrite (H e)

      end.

      unfold Rcast; simpl.

      reflexivity.

    } Unfocus.

    rewrite H. simpl. clear H.

    intros.

    unfold exprT_App, exprT_Inj, Rcast_val, Rcast in *. simpl in *.

    unfold ModularFunc.ILogicFunc.typ2_cast_quant, ModularFunc.ILogicFunc.typ2_cast_bin in *; simpl in *.

    eapply semax_store_localD; eauto.

    rewrite reptyp_reptype_reptype_reptyp in H11.

    exact H11.

Qed.



Lemma APPLY_sound_load_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)

  (ret : type) (gt : PTree.t type) (id : ident) (t t_root : type)

  (e0 e1 : Clight.expr) (efs : list efield) (tts : list type)

  (e : type_id_env) (lr : LLRR) (n : nat),

  rtac_sound (EAPPLY typ func (load_lemma temp var ret gt id t t_root e0 e1 efs tts e lr n)).

Proof.

  intros.

  apply EAPPLY_sound; auto with typeclass_instances.

  + apply APPLY_condition1.

  + apply APPLY_condition2.

  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.



    unfold exprD'_typ0. simpl.

    unfold exprD'. simpl.

    rewrite (load_store_sound_aux t_root); simpl.

    assert (exprT_GetVAs []

                  [tyOracleKind;

                reptyp t_root; tyval; tyval; tyval;

                tylist tygfield;

                tyArr tyenviron tympred;

                tylist tympred;

                typtree (typrod tyc_type tyval);

                typtree tyval;

                tylist typrop; tyshare;

                typtree tyfunspec] 1

                (reptyp t_root) = Some

      (fun (_ : HList.hlist typD [])

         (vs : HList.hlist typD

                [tyOracleKind; reptyp t_root; tyval; tyval; tyval;

                tylist tygfield; tyArr tyenviron tympred;

                tylist tympred; typtree (typrod tyc_type tyval);

                typtree tyval; tylist typrop; tyshare;

                typtree tyfunspec]) => HList.hlist_hd (HList.hlist_tl vs))).

    Focus 1. {

      intros.

      unfold exprT_GetVAs. simpl.

      destruct (typ_eq_dec (reptyp t_root) (reptyp t_root)); [ |congruence].

      assert (e2 = eq_refl) by apply proof_irr.

      subst.

      unfold Rcast_val, Rcast; simpl.

    reflexivity.

    } Unfocus.

    rewrite H. simpl; clear H.

    intros.

    unfold exprT_App, exprT_Inj, Rcast_val, Rcast in *. simpl in *.

    unfold ModularFunc.ILogicFunc.typ2_cast_quant, ModularFunc.ILogicFunc.typ2_cast_bin in *; simpl in *.

    eapply semax_load_localD; eauto.

Qed.



End tbled.

