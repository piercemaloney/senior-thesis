

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)

Require Import VST.msl.psepalg.
(* VST.msl.psepalg:
Require Import VST.msl.base.
Require Import VST.msl.eq_dec.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Lemma pjoin_unit {A} {JA: Join A}{PosA: Pos_alg A}: forall {a b : A},
  join a b b -> False.

Definition cjoins {A} {JA: Join A} (a b : A) : Type := {c : A | join a b c}.

Definition cjoin_sub {A} {JA: Join A} (a c : A) : Type := {b : A | join a b c}.

Lemma joins_comm {A} {JA: Join A}{PA: Perm_alg A} : forall a b,
  joins a b -> joins b a.

Lemma pfull_pmaximal {A} {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A} : full = maximal.

Lemma psub_joins {A}  {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A}{DA: Disj_alg A} : forall a b,
  join_sub a b -> joins a b -> False.
End DISCRETE.

Set Implicit Arguments.

Section PSA_LIFT.
  Variable A : Type.
  Variable J_A: Join A.
  Variable PA_A : Perm_alg A.
  
  Definition lifted : Type := sig nonunit.
  
  Definition lifted_obj (la: lifted) : A := proj1_sig la.

  Coercion lifted_obj : lifted >-> A.
  Definition mk_lifted (a : A) (pf : nonunit a) : lifted :=
    exist nonunit a pf.

  Lemma lifted_eq : forall a b, 
    lifted_obj a = lifted_obj b -> 
    a = b.

  Lemma mk_lifted_refl1: forall (a:A)  (pf1 pf2: nonunit a),
    mk_lifted pf1 = mk_lifted pf2.

  Lemma lifted_pjoins : forall a b : lifted,
    joins a b = @joins A J_A a b.
  
  Lemma lifted_psub : forall a b : lifted, 
    join_sub a b -> @join_sub A J_A a b.  

  Lemma lifted_full {CA: Canc_alg A} : forall a : lifted,
    @full A J_A a -> full a.    

End SA_LOWER.
Arguments Perm_lower _ [Pj_A][PA_A].
Arguments Sep_lower _ [Pj_A].
Arguments Sing_lower _ [Pj_A].
Arguments Canc_lower _ [Pj_A][psa_A][CA] _ _ _ _ _ _.
Arguments Disj_lower _ [Pj_A][PA_A][psa_A][DA] _ _ _.

Existing Instance Join_lower.  
Existing Instance Perm_lower.
Existing Instance Sep_lower.
Existing Instance Sing_lower.
Existing Instance Canc_lower.
Existing Instance Disj_lower.

Lemma None_unit {A}{JOIN: Join A}: 
      forall x: option A, @unit_for (option A) (@Join_lower _ _) None x.

Hint Resolve @None_unit.

Lemma None_identity {A} {JA: Join A}{psaA: Pos_alg A}: 
     @identity (option A) (Join_lower _) None.

Hint Resolve @None_identity.

  Lemma lower_inv: forall {A}{JA: Join A} {PA: Perm_alg A} {psa_A: Pos_alg A} (a b c : option A),
    join a b c ->
    (a = None /\ b = c) + (a = c /\ b = None) + 
    ({a' : A & {b' : A & {c' : A | a = Some a' /\ b = Some b' /\ c = Some c' /\
    join a' b' c'}}}).

Section SA_SMASH.
  Variable T : Type.
  Variable J_T: Join T.
  Variable PA_T : Perm_alg T. 

  Definition smashed : Type := option (lifted J_T).
  Definition Perm_smash :  Perm_alg smashed  := Perm_lower (lifted J_T). 
  Definition Sep_smash : Sep_alg smashed := Sep_lower (lifted J_T).

  Lemma smash_inv: forall a b c : smashed,
    join a b c ->
    (a = None /\ b = c) + (a = c /\ b = None) + 
    ({a' : lifted J_T & {b' : lifted J_T & {c' : lifted J_T | a = Some a' /\ b = Some b' /\ c = Some c' /\
    join (lifted_obj a') (lifted_obj b') (lifted_obj c')}}}).
End SA_SMASH.

Arguments smashed _  [J_T].
Existing Instance Perm_smash. 
Existing Instance Sep_smash. 

Lemma smashed_lifted_None_identity {A}`{Perm_alg A}:
  @identity (smashed A) _ None.

Section FinitePartialMap.
  Variable A:Type.
  Variable dec_A : EqDec A.

  Variable B:Type.
  Variable PJ_B: Join B.
  Variable Perm_B : Perm_alg B.
  Variable Pos_B : Pos_alg B.

  Let Rng := option B.
  Let Join_Rng := Join_lower PJ_B.
  Let Sep_Rng := Sep_lower B.
  Let Perm_Rng := Perm_lower B. 

  Definition finMap (f:A -> Rng) : Prop :=
    exists l, forall a:A, ~In a l -> f a = None.

  Lemma finMap_unit : forall x e,
    finMap x -> @unit_for _ (Join_fun A _ Join_Rng) e x -> finMap e.

  Lemma finMap_join : forall x y z,
    @join _ (Join_fun A _ Join_Rng) x y z -> finMap x -> finMap y -> finMap z.

  Definition fpm := sig finMap.
  Instance Join_fpm : Join fpm := 
     Join_prop (A -> option B)  (Join_fun A (option B) Join_Rng) finMap.

  Definition PAF: (@Perm_alg (A -> Rng)  (Join_fun A Rng Join_Rng))
  := Perm_fun _ _ _ Perm_Rng.

  Instance Perm_fpm : @Perm_alg fpm Join_fpm :=
    Perm_prop (A -> Rng) _ _ finMap finMap_join.

  Lemma finMap_core  x: finMap x -> 
        finMap (@core _ _ (Sep_fun A (option B) Join_Rng _ ) x).

  Definition empty_fpm : fpm.

  Definition lookup_fpm (f:fpm) : A -> Rng := proj1_sig f.

  Definition insert_fpm (a:A) (b: B) (f:fpm) : fpm.

   Definition insert'_fpm (a:A)(b: option B) (f: fpm) : fpm.

  Definition remove_fpm (a:A) (f:fpm) : fpm.

  Lemma fpm_gss: forall  i v rho, 
        lookup_fpm (insert_fpm i v rho) i = Some v.

  Lemma fpm_gso: forall i j v rho, 
       i <> j -> lookup_fpm (insert_fpm j v rho) i =
                               lookup_fpm rho i.

  Lemma empty_fpm_join : forall x,
    @join _ Join_fpm empty_fpm x x.

  Lemma insert_fpm_join : forall i v (x y z:fpm),
    lookup_fpm y i = None ->
    @join _ Join_fpm x y z ->
    @join _ Join_fpm (insert_fpm i v x) y (insert_fpm i v z).
End FinitePartialMap.

Lemma fpm_bij_aux: forall A B B' (f: B -> B') (rho: A -> option B), 
       @finMap A B rho -> 
       @finMap A B' (fun i => match rho i with None => None | Some j => Some (f j) end).
Definition fpm_bij (A B B': Type) (bij: bijection B B') : bijection (fpm A B) (fpm A B').

Lemma lift_prod_aux1 {A}{JA: Join A}{B}:
  forall x,   @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x -> nonunit (fst x).

Definition lift_prod1  {A}{JA: Join A}{B} : (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) -> (@lifted A _ * B).

Lemma lift_prod_aux2 {A}{JA: Join A}{B}: 
  forall x,
    nonunit (fst x) -> @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x.

Definition lift_prod2  {A}{JA: Join A}{B} :(@lifted A _ * B) -> (@lifted (A * B) (Join_prod A _ B (Join_equiv B))).

Definition lift_prod_bij: forall A (JA: Join A) B,
     bijection  (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) (@lifted A _ * B). *)



Section join_hom2.

  Variables (A B C: Type)

            (JA: Join A)

            (JB: Join B)

            (JC: Join C)

            (f: A -> B -> C).



  Definition join_hom2 := forall (a1 a2 a3: A)(b1 b2 b3: B),

      join a1 a2 a3

      -> join b1 b2 b3

      -> join (f a1 b1) (f a2 b2) (f a3 b3).



  Definition join_hom2' := forall (a1 a2 a3: A)(b1 b2 b3: B),

      join a1 a2 a3

      -> join (f a1 b1) (f a2 b2) (f a3 b3).

End join_hom2.



Arguments join_hom2 [A B C JA JB JC] _.

Arguments join_hom2' [A B C JA] _ _.



  Lemma join_hom_id (A: Type) (JA: Join A) : join_hom (fun x => x).

  Proof. unfold join_hom; auto. Qed.



Section join_hom_prod.

  Variables (A A' B B': Type)

            (JA: Join A) (JA': Join A')

            (JB: Join B)  (JB': Join B')

            (f: A -> A') (g: B -> B')

            (join_hom_f: join_hom f)

            (join_hom_g: join_hom g).



  Lemma join_hom2_pair: join_hom2 (fun a b => (f a, g b)).

  Proof. firstorder. Qed.



  Lemma join_hom2_pair' : join_hom2 (fun (a: A) (b: B) => (a, b)).

  Proof. firstorder. Qed.



  Lemma join_hom_prod : join_hom (fun p => (f (fst p), g (snd p))).

  Proof. unfold join_hom; firstorder. Qed.



  Lemma join_hom_prodA

    : forall e: B', join e e e -> join_hom (fun a :A => (f a, e)).

  Proof.

    unfold join_hom in *; intros; simpl; split; auto.

    simpl; auto.

  Qed.



  Lemma join_hom_prodA'

    : forall e: B, join e e e -> join_hom (fun a :A'  => (a, e)).

  Proof.

    unfold join_hom in *; split; simpl; auto.

  Qed.



  Lemma join_hom_prodB

    : forall e: A', join e e e -> join_hom (fun b: B => (e, g b)).

  Proof.

    unfold join_hom in *; split; simpl; auto.

  Qed.



  Lemma join_hom_prodB'

    : forall e: A, join e e e -> join_hom (fun b : B' => (e, b)).

  Proof.

    unfold join_hom in *; simpl; split; auto.

  Qed.



  Lemma join_hom_proj1

    : join_hom (fun p: A*B => fst p).

  Proof. unfold join_hom; firstorder. Qed.



  Lemma join_hom_proj2

    : join_hom (fun p : A*B => snd p).

  Proof. unfold join_hom; firstorder. Qed.

End join_hom_prod.



Arguments join_hom2_pair [A A' B B' JA JA' JB JB'] _ _ _ _ _ _ _ _ _ _ _ _.

Arguments join_hom2_pair' [A B JA JB] _ _ _ _ _ _ _ _.

Arguments join_hom_prodA [A] _ [B' JA] _ [JB'] _ _ _ _ _ _ _ _.

Arguments join_hom_prodA' [A' B JA' JB] _ _ _ _ _ _.

Arguments join_hom_prodB [A' B] _ [JA' JB] _ _ _ _ _ _ _ _ _.

Arguments join_hom_prodB' [A B' JA JB'] _ _ _ _ _ _.

Arguments join_hom_proj1 [A B JA JB] _ _ _ _.

Arguments join_hom_proj2 [A B JA JB] _ _ _ _.



Section join_hom_disjoint_sum.

  Variables (A A' B B': Type)

            (JA: Join A) (JA': Join A')

            (JB: Join B) (JB': Join B')

            (f: A -> A') (g: B -> B')

            (join_hom_f: join_hom f)

            (join_hom_g: join_hom g).



  Lemma join_hom_sum

    : join_hom (fun s: A+B =>

        match s with

          | inl x => inl _ (f x)

          | inr y => inr _ (g y)

        end).

  Proof.

    unfold join_hom.

    destruct x; destruct y; destruct z; firstorder.

  Qed.



  Lemma join_hom_sum_l

    : join_hom (fun s: A+B =>

        match s with

          | inl x => inl _ (f x)

          | inr y => inr _ y

        end).

  Proof.

    unfold join_hom.

    destruct x; destruct y; destruct z; firstorder.

  Qed.



  Lemma join_hom_sum_r

    : join_hom (fun s: A+B =>

        match s with

          | inl x => inl _ x

          | inr y => inr _ (g y)

        end).

  Proof.

    unfold join_hom.

    destruct x; destruct y; destruct z; firstorder.

  Qed.



  Lemma join_hom_inj_l

    : join_hom (fun a : A=> inl Void (f a)).

  Proof. firstorder. Qed.



  Lemma join_hom_inj_r

    : join_hom (fun b => inr Void (g b)).

  Proof. firstorder. Qed.



  Definition sa_sum_option (s: A+unit): option A :=

    match s with

      | inl s' => Some s'

      | inr _ => None

    end.



  Definition option_sa_sum (s: option A): A+unit :=

    match s with

      | Some s' => inl _ s'

      | None => inr _ tt

    end.



  Lemma sa_sum__option: forall s, sa_sum_option (option_sa_sum s) = s.

  Proof. destruct s; firstorder. Qed.



  Lemma option__sa_sum: forall s, option_sa_sum (sa_sum_option s) = s.

  Proof. destruct s; firstorder; destruct u; firstorder. Qed.



  Definition bij_sa_sum_option : bijection (A+unit) (option A) :=

    Bijection _ _ sa_sum_option option_sa_sum sa_sum__option option__sa_sum.

End join_hom_disjoint_sum.



Section join_hom_list.

  Variables (A: Type) (JA: Join A).



  Lemma join_hom_list_nil

    : join_hom (fun a => a :: nil).

  Proof.

    unfold join_hom;

      solve [constructor; auto || constructor].

  Qed.



  Lemma join_hom2_list_cons

    : join_hom2 (fun a l => a :: l).

  Proof.

    unfold join_hom2; constructor; auto.

  Qed.

End join_hom_list.



Section join_hom_fun.

  Variables (Key A: Type)

            (Key_dec_eq: forall k1 k2: Key, {k1=k2}+{~k1=k2})

            (JA: Join A).



  Fixpoint lookup k (rho: list (Key*A)) :=

    match rho with

      | nil => None

      | (k', a) :: rho' =>

          if Key_dec_eq k k' then Some a else lookup k rho'

    end.



  Instance Join_Key : Join Key := @Join_equiv Key.



  Lemma join_hom_fun

    : join_hom (fun env k => lookup k env).

  Proof.

    unfold join_hom; intros x y z H.

    induction H.



    simpl; auto. intro. constructor.



    simpl; intro x0.

    destruct x as [k1 a1]; destruct y as [k2 a2]; destruct z as [k3 a3].

    destruct H. simpl in *. destruct H. subst k2 k3.

    destruct (Key_dec_eq x0 k1); auto. constructor; auto.

  Qed.

End join_hom_fun.

Arguments lookup [Key A] _ _ _.



Lemma join_hom_bij {A: Type} `{Perm_alg A}

            {B: Type}

          (bij: bijection A B):

       @join_hom _ _ _ (Join_bij _ _ _ bij) (bij_f _ _ bij).

  Proof.

    unfold join_hom. intros. do 3 red.

    repeat rewrite bij_gf. auto.

  Qed.



  Lemma join_hom_join_sub {A}{B}`{Join A}`{Join B}:

     forall (f: A -> B) a1 a2, join_sub a1 a2 -> join_hom f -> join_sub (f a1) (f a2).

  Proof.

    intros.

    destruct H1 as [b H1].

    exists (f b).  auto.

  Qed.



  Lemma join_hom_identity  {A}{B}`{Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}`{Perm_alg B}{SB: Sep_alg B}{CB: Disj_alg B}:

      forall (f: A -> B) a1, identity a1 -> join_hom f -> identity (f a1).

  Proof.

    intros.

    rewrite identity_unit_equiv in H1.

    rewrite identity_unit_equiv.

    unfold unit_for in *. auto.

  Qed.



  Lemma join_hom2_identity  {A}{B}{C}

          `{Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}

          `{Perm_alg B}{SB: Sep_alg B}{CB: Disj_alg B}

          `{Perm_alg C}{SC: Sep_alg C}{CC: Disj_alg C}:

   forall (g: A -> B -> C) a1 b1,

      identity a1 -> identity b1 -> join_hom2 g -> identity (g a1 b1).

  Proof.

   intros.

    unfold join_hom2 in *.

    rewrite identity_unit_equiv in H2.

    rewrite identity_unit_equiv in H3.

    rewrite identity_unit_equiv.

    unfold unit_for in *. auto.

  Qed.



  Lemma join_hom_comparable {A}{B}`{Perm_alg A}{SA: Sep_alg A}`{Perm_alg B}{SB:Sep_alg B}:

      forall (f: A -> B) a1 a2, comparable a1 a2 -> join_hom f -> comparable (f a1) (f a2).

  Proof.

    intros.

    unfold join_hom in *.

    destruct (comparable_common_unit H1) as [e [? ?]].

    apply common_unit_comparable.

    exists (f e); split; auto.

  Qed.



  Lemma join_hom2_comparable {A}{B}{C}

          `{Perm_alg A}{SA: Sep_alg A}`{Perm_alg B}{SB: Sep_alg B}`{Perm_alg C}{SC: Sep_alg C}:

   forall (g: A -> B -> C) a1 a2 b1 b2,

     comparable a1 a2

      -> comparable b1 b2

      -> join_hom2 g

      -> comparable (g a1 b1) (g a2 b2).

  Proof.

    intros.

    unfold join_hom2 in *.

    destruct (comparable_common_unit H2) as [ea [? ?]].

    destruct (comparable_common_unit H3) as [eb [? ?]].

    apply common_unit_comparable.

    exists (g ea eb); auto.

  Qed.



