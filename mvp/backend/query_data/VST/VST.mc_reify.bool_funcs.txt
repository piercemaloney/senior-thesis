Require Import VST.veric.expr.
Require Import VST.veric.SeparationLogic.
Require Import VST.floyd.local2ptree.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import Coq.Bool.Bool.
Require Import Coq.Lists.List.
Require Import mc_reify.clight_expr_eq.
(* mc_reify.clight_expr_eq:
Require Import Clight.
Require Import Ctypes.
Require Import VST.veric.expr.
Require Import Integers.
Require Import Floats.
Require Import Zbool.
Require Import Coq.Numbers.BinNums.
Require Import Cop.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.List.

Definition beq_int (i1 i2 : Integers.int) : bool :=
Zbool.Zeq_bool (Int.intval i1) (Int.intval i2).

Lemma beq_int_true : forall a b, beq_int a b = true -> a = b.

Hint Resolve beq_int_true : expr_beq.

Lemma beq_int_refl : forall i, beq_int i i = true.

Hint Resolve beq_int_refl : expr_beq.
Hint Rewrite beq_int_refl : expr_beq.

Definition beq_long (i1 i2 : int64) : bool :=
Zeq_bool (Int64.intval i1) (Int64.intval i2).

Lemma beq_long_true : forall a b, beq_long a b = true -> a = b.

Lemma beq_long_refl : forall i, beq_long i i = true.

Hint Resolve beq_long_refl : expr_beq.
Hint Rewrite beq_long_refl : expr_beq.
Hint Resolve beq_long_true : expr_beq.

Definition beq_float_dec a b:= if Float.eq_dec a b then true else false.

Lemma beq_float_dec_true a b : beq_float_dec a b = true -> a = b.

Lemma beq_float_refl : forall a, beq_float_dec a a = true.

Hint Resolve beq_float_refl : expr_beq.
Hint Rewrite beq_float_refl : expr_beq.
Hint Resolve beq_float_dec_true : expr_beq.

Definition beq_float32_dec a b:= if Float32.eq_dec a b then true else false.

Lemma beq_float32_dec_true a b : beq_float32_dec a b = true -> a = b.

Lemma beq_float32_refl : forall a, beq_float32_dec a a = true.

Hint Resolve beq_float32_refl : expr_beq.
Hint Rewrite beq_float32_refl : expr_beq.

Hint Resolve beq_float32_dec_true : expr_beq.

Definition unary_op_beq a b :=
match a, b with
  | Onotbool, Onotbool
  | Onotint, Onotint
  | Oneg, Oneg
  | Oabsfloat, Oabsfloat => true
  | _, _ => false
end.

Lemma unary_op_beq_sound : forall a b, unary_op_beq a b = true -> a = b .

Lemma unary_op_beq_refl : forall a, unary_op_beq a a = true.

Hint Resolve unary_op_beq_refl : expr_beq.
Hint Rewrite unary_op_beq_refl : expr_beq.
Hint Resolve unary_op_beq_sound: expr_beq.

Definition binary_op_beq a b :=
match a, b with
    Oadd, Oadd
  | Osub, Osub
  | Omul, Omul
  | Odiv, Odiv
  | Omod, Omod
  | Oand, Oand
  | Oor, Oor
  | Oxor, Oxor
  | Oshl, Oshl
  | Oshr, Oshr
  | Oeq, Oeq
  | One, One
  | Olt, Olt
  | Ogt, Ogt
  | Ole, Ole
  | Oge, Oge => true
  | _, _ => false
end.

Lemma binary_op_beq_sound : forall a b, binary_op_beq a b = true -> a = b .

Lemma binary_op_beq_refl : forall a, binary_op_beq a a = true.

Hint Resolve binary_op_beq_refl : expr_beq.
Hint Rewrite binary_op_beq_refl : expr_beq.
Hint Resolve binary_op_beq_sound : expr_beq.

Fixpoint expr_beq a b :=
match a, b with
| Econst_int i1 ty1, Econst_int i2 ty2 => andb (beq_int i1 i2) (eqb_type ty1 ty2)
| Econst_float f1 ty1, Econst_float f2 ty2 => andb (beq_float_dec f1 f2) (eqb_type ty1 ty2)
| Econst_single f1 ty1, Econst_single f2 ty2 => andb (beq_float32_dec f1 f2) (eqb_type ty1 ty2)
| Econst_long l1 ty1, Econst_long l2 ty2 => andb (beq_long l1 l2) (eqb_type ty1 ty2)
| Evar id1 ty1, Evar id2 ty2
| Etempvar id1 ty1, Etempvar id2 ty2 => andb (BinPos.Pos.eqb id1 id2) (eqb_type ty1 ty2)
| Ederef e1 ty1, Ederef e2 ty2
| Eaddrof e1 ty1, Eaddrof e2 ty2
| Ecast e1 ty1, Ecast e2 ty2 => (andb (expr_beq e1 e2) (eqb_type ty1 ty2))
| Eunop op1 e1 ty1, Eunop op2 e2 ty2 => (andb (andb (unary_op_beq op1 op2) (expr_beq e1 e2)) (eqb_type ty1 ty2))
| Ebinop op1 e11 e21 ty1, Ebinop op2 e12 e22 ty2 => (andb (andb (andb (binary_op_beq op1 op2) (expr_beq e11 e12)) (eqb_type ty1 ty2)) (expr_beq e21 e22))
| Efield e1 id1 ty1, Efield e2 id2 ty2 => andb (andb (expr_beq e1 e2) (BinPos.Pos.eqb id1 id2)) (eqb_type ty1 ty2)
| _, _ => false
end.

Hint Rewrite Bool.andb_true_iff : expr_beq.
Hint Resolve eqb_type_true : expr_beq.
Hint Resolve BinPos.Peqb_true_eq : expr_beq.
Hint Rewrite BinPos.Pos.eqb_refl : expr_beq.
Hint Resolve BinPos.Pos.eqb_refl : expr_beq.
Hint Resolve eqb_type_refl : expr_beq.
Hint Rewrite eqb_type_refl : expr_beq.

Ltac solve_expr_beq_sound :=
try solve [simpl in *; try congruence]; try reflexivity;
simpl in *; autorewrite with expr_beq in *;
repeat match goal with
| [ H : _ /\ _  |- _] => destruct H
end;
try match goal with
| [ H : List.list_eqb ?r ?a ?b = _ |- _] => consider ( List.list_eqb r a b); intros
end;
try f_equal;
auto with expr_beq.

Lemma expr_beq_refl : forall a, expr_beq a a = true.

Hint Resolve expr_beq_refl : expr_beq.

Lemma expr_beq_spec : forall a b, expr_beq a b = true <-> a = b.

Lemma expr_beq_sound : forall a b, expr_beq a b = true -> a = b. *)

Fixpoint denote_tc_assert_b_norho a:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| tc_orp' a b => orb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| _ => false
end.

Fixpoint denote_tc_assert_b_norho_forgive_isptr a e:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho_forgive_isptr a e)
                       (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_orp' a b => orb (denote_tc_assert_b_norho_forgive_isptr a e)
                     (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_isptr e0 => expr_beq e e0
| _ => false
end.

Lemma denote_tc_assert_b_norho_sound: forall a rho,
  denote_tc_assert_b_norho a = true -> denote_tc_assert a rho.
Proof.
intros.
induction a; simpl in *; unfold_lift; simpl; auto; try congruence.
rewrite andb_true_iff in *. intuition.
rewrite orb_true_iff in *. intuition.
Qed.

Lemma denote_tc_assert_b_norho_forgive_isptr_sound: forall a e rho,
  denote_tc_assert_b_norho_forgive_isptr a e = true ->
  isptr (expr.eval_expr e rho) ->
  denote_tc_assert a rho.
Proof.
intros.
induction a; simpl in *; unfold_lift; simpl; auto; try congruence.
rewrite andb_true_iff in *. intuition.
rewrite orb_true_iff in *. intuition.
apply expr_beq_spec in H; subst; auto.
Qed.

Definition tc_lvalue_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_lvalue Delta e).

Definition tc_expr_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_expr Delta e).

Definition tc_temp_id_b_norho id t Delta e:=
denote_tc_assert_b_norho (typecheck_temp_id id t Delta e).

Definition tc_lvalue_b_norho' Delta e :=
  match e with
  | Ederef e0 t => denote_tc_assert_b_norho_forgive_isptr
                     (typecheck_lvalue Delta e) e0
  | _ => denote_tc_assert_b_norho (typecheck_lvalue Delta e)
  end.

Lemma tc_lvalue_b_sound :
forall e Delta rho,
tc_lvalue_b_norho Delta e = true ->
tc_lvalue Delta e rho .
Proof.
intros.
apply denote_tc_assert_b_norho_sound; auto.
Qed.

Lemma tc_expr_b_sound :
forall e Delta rho,
tc_expr_b_norho Delta e = true ->
tc_expr Delta e rho .
Proof.
intros.
apply denote_tc_assert_b_norho_sound; auto.
Qed.

Lemma tc_temp_id_b_sound :
forall id t Delta e rho,
tc_temp_id_b_norho id t Delta e= true ->
tc_temp_id id t Delta e rho .
Proof.
intros.
apply denote_tc_assert_b_norho_sound; auto.
Qed.

Lemma tc_lvalue_b'_sound :
forall e Delta rho,
tc_lvalue_b_norho' Delta e = true ->
isptr (expr.eval_lvalue e rho) ->
tc_lvalue Delta e rho .
Proof.
intros.
destruct e eqn:HH; try solve [apply tc_lvalue_b_sound; auto].
eapply denote_tc_assert_b_norho_forgive_isptr_sound; [exact H |].
simpl in H0.
unfold_lift in H0.
destruct (expr.eval_expr e0 rho); try inversion H0.
simpl.
auto.
Qed.

Fixpoint tc_efield_b_norho Delta efs :=
  match efs with
  | nil => true
  | eArraySubsc ei :: efs' =>
      (tc_expr_b_norho Delta ei && tc_efield_b_norho Delta efs')%bool
  | eStructField _ :: efs' => tc_efield_b_norho Delta efs'
  | eUnionField _ :: efs' => tc_efield_b_norho Delta efs'
  end.

Lemma tc_efield_b_sound: forall efs Delta rho,
  tc_efield_b_norho Delta efs = true -> tc_efield Delta efs rho.
Proof.
  intros.
  induction efs.
  + simpl; auto.
  + destruct a; simpl in H |- *.
    - apply andb_true_iff in H.
      destruct H.
      apply tc_expr_b_sound with (rho := rho) in H.
      tauto.
    - tauto.
    - tauto.
Qed.

Definition tc_LR_b_norho Delta e lr :=
  match lr with
  | LLLL => tc_lvalue_b_norho' Delta e
  | RRRR => tc_expr_b_norho Delta e
  end.

Definition type_is_int (e: Clight.expr) : bool :=
  match typeof e with
  | Tint _ _ _ => true
  | _ => false
  end.
