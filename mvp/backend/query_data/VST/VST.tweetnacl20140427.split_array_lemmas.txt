Require Import VST.floyd.proofauto.
Local Open Scope logic.
Require Import List. Import ListNotations.
Require Import ZArith.

Lemma unsigned_add: forall i pos, 0 <= pos -> Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr pos)) = (Ptrofs.unsigned i + pos) mod Ptrofs.modulus.
Proof.
  intros.
  unfold Ptrofs.add.
  pose proof Ptrofs.modulus_pos.
  pose proof Ptrofs.unsigned_range i.
  pose proof Ptrofs.unsigned_range (Ptrofs.repr pos).
  rewrite !Ptrofs.unsigned_repr_eq in *.
  rewrite Z.add_mod by omega.
  rewrite Z.mod_mod by omega.
  rewrite <- Z.add_mod by omega.
  reflexivity.
Qed.

Lemma Arith_aux1: forall i pos z,
  0 <= pos /\ pos + z <= Ptrofs.modulus - Ptrofs.unsigned i ->
  Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr pos)) + z <= Ptrofs.modulus.
Proof.
  intros.
  destruct H.
  rewrite (unsigned_add i pos H).
  cut ((Ptrofs.unsigned i + pos) mod Ptrofs.modulus <= Ptrofs.unsigned i + pos).
    { intros. omega. }
  pose proof Ptrofs.modulus_pos.
  pose proof Ptrofs.unsigned_range i.
  apply Z.mod_le; omega.
Qed.

Lemma offset_in_range_0 v: offset_in_range 0 v.
  destruct v; simpl; trivial. rewrite Z.add_0_r.
  specialize (Ptrofs.unsigned_range i); intros. omega.
Qed.
Lemma offset_in_range_le n m d:
      offset_in_range n d -> 0<=m<=n ->
      offset_in_range m d.
unfold offset_in_range; intros.
destruct d; simpl in *; trivial.
split; try omega.
apply Z.add_nonneg_nonneg. apply (Ptrofs.unsigned_range i). omega.
Qed.

Lemma offset_in_range_offset_val z1 z2 v
        (Z1: 0 <= z1) (Z2: 0 <= z2)
        (Off : offset_in_range (z1 + z2) v):
     offset_in_range z2 (offset_val z1 v).
Proof.
  unfold offset_val, offset_in_range in *. destruct v; trivial.
  split. apply Z.add_nonneg_nonneg; trivial. apply Ptrofs.unsigned_range.
  apply Arith_aux1. omega.
Qed.

Lemma sizeof_Zlength_nonneg {A} {ge: composite_env} t (d:list A): 0 <= sizeof t * Zlength d.
  specialize (Zlength_nonneg d). specialize (sizeof_pos t); intros.
  apply Z.mul_nonneg_nonneg; omega.
Qed.

Definition Select_at {cs} sh n (data2: list val) d :=
   @data_at cs sh (Tarray tuchar (Zlength data2) noattr) data2
             (offset_val n d).

Definition Unselect_at {cs} sh (data1 data2 data3: list val) d :=
  (@data_at cs sh (Tarray tuchar (Zlength data1) noattr) data1 d *
   @data_at cs sh (Tarray tuchar (Zlength data3) noattr) data3
             (offset_val (Zlength data2 + Zlength data1) d)).

Lemma Select_Unselect_Tarray_at {cs} l d sh (data1 data2 data3 data: list val)
  (DATA: (data1 ++ data2 ++ data3) = data)
  (L: l = Zlength data)
  (F: @field_compatible cs (Tarray tuchar (Zlength (data1 ++ data2 ++ data3)) noattr) [] d)
  (ZL: Zlength (data1 ++ data2 ++ data3) < Int.modulus):
  @data_at cs sh (Tarray tuchar l noattr) data d =
  @Select_at cs sh (Zlength data1) data2 d * @Unselect_at cs sh data1 data2 data3 d.
Proof.
  subst l. subst data.
  specialize (Zlength_nonneg data1). intros.
  specialize (Zlength_nonneg data2). intros.
  specialize (Zlength_nonneg data3). intros.
  rewrite split3_data_at_Tarray_tuchar with (n1:=Zlength data1)(n2:=Zlength data2 +Zlength data1); try omega.
Locate split3_data_at_Tarray_tuchar.
  autorewrite with sublist.
  unfold Select_at, Unselect_at. simpl.
  unfold offset_val. red in F. destruct d; intuition.
  rewrite field_address0_offset. simpl.
  rewrite field_address0_offset. simpl.
  rewrite (sepcon_comm (data_at sh (Tarray tuchar (Zlength data2) noattr) data2
  (Vptr b (Ptrofs.add i (Ptrofs.repr (Zlength data1)))))).
  repeat rewrite sepcon_assoc.
  f_equal. repeat rewrite Z.mul_1_l. rewrite sepcon_comm. f_equal.
  repeat rewrite Zlength_app in *.
  red; simpl. intuition; try omega.
  repeat rewrite Zlength_app in *.
  red; simpl. intuition; try omega.
  repeat rewrite Zlength_app in *. omega.
Qed.