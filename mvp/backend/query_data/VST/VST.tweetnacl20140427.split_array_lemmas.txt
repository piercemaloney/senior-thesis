Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Local Open Scope logic.

Require Import List. Import ListNotations.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import ZArith.



Lemma unsigned_add: forall i pos, 0 <= pos -> Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr pos)) = (Ptrofs.unsigned i + pos) mod Ptrofs.modulus.

Proof.

  intros.

  unfold Ptrofs.add.

  pose proof Ptrofs.modulus_pos.

  pose proof Ptrofs.unsigned_range i.

  pose proof Ptrofs.unsigned_range (Ptrofs.repr pos).

  rewrite !Ptrofs.unsigned_repr_eq in *.

  rewrite Z.add_mod by omega.

  rewrite Z.mod_mod by omega.

  rewrite <- Z.add_mod by omega.

  reflexivity.

Qed.



Lemma Arith_aux1: forall i pos z,

  0 <= pos /\ pos + z <= Ptrofs.modulus - Ptrofs.unsigned i ->

  Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr pos)) + z <= Ptrofs.modulus.

Proof.

  intros.

  destruct H.

  rewrite (unsigned_add i pos H).

  cut ((Ptrofs.unsigned i + pos) mod Ptrofs.modulus <= Ptrofs.unsigned i + pos).

    { intros. omega. }

  pose proof Ptrofs.modulus_pos.

  pose proof Ptrofs.unsigned_range i.

  apply Z.mod_le; omega.

Qed.



Lemma offset_in_range_0 v: offset_in_range 0 v.

  destruct v; simpl; trivial. rewrite Z.add_0_r.

  specialize (Ptrofs.unsigned_range i); intros. omega.

Qed.

Lemma offset_in_range_le n m d:

      offset_in_range n d -> 0<=m<=n ->

      offset_in_range m d.

unfold offset_in_range; intros.

destruct d; simpl in *; trivial.

split; try omega.

apply Z.add_nonneg_nonneg. apply (Ptrofs.unsigned_range i). omega.

Qed.



Lemma offset_in_range_offset_val z1 z2 v

        (Z1: 0 <= z1) (Z2: 0 <= z2)

        (Off : offset_in_range (z1 + z2) v):

     offset_in_range z2 (offset_val z1 v).

Proof.

  unfold offset_val, offset_in_range in *. destruct v; trivial.

  split. apply Z.add_nonneg_nonneg; trivial. apply Ptrofs.unsigned_range.

  apply Arith_aux1. omega.

Qed.



Lemma sizeof_Zlength_nonneg {A} {ge: composite_env} t (d:list A): 0 <= sizeof t * Zlength d.

  specialize (Zlength_nonneg d). specialize (sizeof_pos t); intros.

  apply Z.mul_nonneg_nonneg; omega.

Qed.



Definition Select_at {cs} sh n (data2: list val) d :=

   @data_at cs sh (Tarray tuchar (Zlength data2) noattr) data2

             (offset_val n d).



Definition Unselect_at {cs} sh (data1 data2 data3: list val) d :=

  (@data_at cs sh (Tarray tuchar (Zlength data1) noattr) data1 d *

   @data_at cs sh (Tarray tuchar (Zlength data3) noattr) data3

             (offset_val (Zlength data2 + Zlength data1) d)).



Lemma Select_Unselect_Tarray_at {cs} l d sh (data1 data2 data3 data: list val)

  (DATA: (data1 ++ data2 ++ data3) = data)

  (L: l = Zlength data)

  (F: @field_compatible cs (Tarray tuchar (Zlength (data1 ++ data2 ++ data3)) noattr) [] d)

  (ZL: Zlength (data1 ++ data2 ++ data3) < Int.modulus):

  @data_at cs sh (Tarray tuchar l noattr) data d =

  @Select_at cs sh (Zlength data1) data2 d * @Unselect_at cs sh data1 data2 data3 d.

Proof.

  subst l. subst data.

  specialize (Zlength_nonneg data1). intros.

  specialize (Zlength_nonneg data2). intros.

  specialize (Zlength_nonneg data3). intros.

  rewrite split3_data_at_Tarray_tuchar with (n1:=Zlength data1)(n2:=Zlength data2 +Zlength data1); try omega.

Locate split3_data_at_Tarray_tuchar.

  autorewrite with sublist.

  unfold Select_at, Unselect_at. simpl.

  unfold offset_val. red in F. destruct d; intuition.

  rewrite field_address0_offset. simpl.

  rewrite field_address0_offset. simpl.

  rewrite (sepcon_comm (data_at sh (Tarray tuchar (Zlength data2) noattr) data2

  (Vptr b (Ptrofs.add i (Ptrofs.repr (Zlength data1)))))).

  repeat rewrite sepcon_assoc.

  f_equal. repeat rewrite Z.mul_1_l. rewrite sepcon_comm. f_equal.

  repeat rewrite Zlength_app in *.

  red; simpl. intuition; try omega.

  repeat rewrite Zlength_app in *.

  red; simpl. intuition; try omega.

  repeat rewrite Zlength_app in *. omega.

Qed.
