

Require Import Coqlib.

Require Errors.

Require Import Maps.

Require Import AST.

Require Import Integers.

Require Import Switch.

Require Import Op.
(* Op:
Require Import BoolEqual.
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Events.

Set Implicit Arguments.

Inductive condition : Type :=
  | Ccomp (c: comparison)      
  | Ccompu (c: comparison)     
  | Ccompimm (c: comparison) (n: int) 
  | Ccompuimm (c: comparison) (n: int)  
  | Ccompl (c: comparison)      
  | Ccomplu (c: comparison)     
  | Ccomplimm (c: comparison) (n: int64) 
  | Ccompluimm (c: comparison) (n: int64)  
  | Ccompf (c: comparison)     
  | Cnotcompf (c: comparison)  
  | Ccompfs (c: comparison)    
  | Cnotcompfs (c: comparison) 
  | Cmaskzero (n: int)         
  | Cmasknotzero (n: int).     

Inductive addressing: Type :=
  | Aindexed: Z -> addressing       
  | Aindexed2: Z -> addressing      
  | Ascaled: Z -> Z -> addressing   
  | Aindexed2scaled: Z -> Z -> addressing
                                    
  | Aglobal: ident -> ptrofs -> addressing 
  | Abased: ident -> ptrofs -> addressing  
  | Abasedscaled: Z -> ident -> ptrofs -> addressing  
  | Ainstack: ptrofs -> addressing. 

Inductive operation : Type :=
  | Omove                    
  | Ointconst (n: int)       
  | Olongconst (n: int64)    
  | Ofloatconst (n: float)   
  | Osingleconst (n: float32)
  | Oindirectsymbol (id: ident) 

  | Ocast8signed             
  | Ocast8unsigned           
  | Ocast16signed            
  | Ocast16unsigned          
  | Oneg                     
  | Osub                     
  | Omul                     
  | Omulimm (n: int)         
  | Omulhs                   
  | Omulhu                   
  | Odiv                     
  | Odivu                    
  | Omod                     
  | Omodu                    
  | Oand                     
  | Oandimm (n: int)         
  | Oor                      
  | Oorimm (n: int)          
  | Oxor                     
  | Oxorimm (n: int)         
  | Onot                     
  | Oshl                     
  | Oshlimm (n: int)         
  | Oshr                     
  | Oshrimm (n: int)         
  | Oshrximm (n: int)        
  | Oshru                    
  | Oshruimm (n: int)        
  | Ororimm (n: int)         
  | Oshldimm (n: int)        
  | Olea (a: addressing)     

  | Omakelong                
  | Olowlong                 
  | Ohighlong                
  | Ocast32signed            
  | Ocast32unsigned          
  | Onegl                    
  | Oaddlimm (n: int64)      
  | Osubl                    
  | Omull                    
  | Omullimm (n: int64)      
  | Omullhs                  
  | Omullhu                  
  | Odivl                    
  | Odivlu                   
  | Omodl                    
  | Omodlu                   
  | Oandl                    
  | Oandlimm (n: int64)      
  | Oorl                     
  | Oorlimm (n: int64)       
  | Oxorl                    
  | Oxorlimm (n: int64)      
  | Onotl                    
  | Oshll                    
  | Oshllimm (n: int)        
  | Oshrl                    
  | Oshrlimm (n: int)        
  | Oshrxlimm (n: int)       
  | Oshrlu                   
  | Oshrluimm (n: int)       
  | Ororlimm (n: int)        
  | Oleal (a: addressing)    

  | Onegf                    
  | Oabsf                    
  | Oaddf                    
  | Osubf                    
  | Omulf                    
  | Odivf                    
  | Onegfs                   
  | Oabsfs                   
  | Oaddfs                   
  | Osubfs                   
  | Omulfs                   
  | Odivfs                   
  | Osingleoffloat           
  | Ofloatofsingle           

  | Ointoffloat              
  | Ofloatofint              
  | Ointofsingle             
  | Osingleofint             
  | Olongoffloat             
  | Ofloatoflong             
  | Olongofsingle            
  | Osingleoflong            

  | Ocmp (cond: condition).  

Definition eq_condition (x y: condition) : {x=y} + {x<>y}.

Definition eq_addressing (x y: addressing) : {x=y} + {x<>y}.

Definition beq_operation: forall (x y: operation), bool.

Definition eq_operation: forall (x y: operation), {x=y} + {x<>y}.

Global Opaque eq_condition eq_addressing eq_operation.

Definition offset_in_range (n: Z) : bool := zle Int.min_signed n && zle n Int.max_signed.

Definition addressing_valid (a: addressing) : bool :=
  if Archi.ptr64 then
    match a with
    | Aindexed n => offset_in_range n
    | Aindexed2 n => offset_in_range n
    | Ascaled sc ofs => offset_in_range ofs
    | Aindexed2scaled sc ofs => offset_in_range ofs
    | Aglobal s ofs => true
    | Abased s ofs => true
    | Abasedscaled sc s ofs => true
    | Ainstack ofs => offset_in_range (Ptrofs.signed ofs)
    end
  else true.
  
Definition eval_condition (cond: condition) (vl: list val) (m: mem): option bool :=
  match cond, vl with
  | Ccomp c, v1 :: v2 :: nil => Val.cmp_bool c v1 v2
  | Ccompu c, v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2
  | Ccompimm c n, v1 :: nil => Val.cmp_bool c v1 (Vint n)
  | Ccompuimm c n, v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)
  | Ccompl c, v1 :: v2 :: nil => Val.cmpl_bool c v1 v2
  | Ccomplu c, v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
  | Ccomplimm c n, v1 :: nil => Val.cmpl_bool c v1 (Vlong n)
  | Ccompluimm c n, v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)
  | Ccompf c, v1 :: v2 :: nil => Val.cmpf_bool c v1 v2
  | Cnotcompf c, v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)
  | Ccompfs c, v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2
  | Cnotcompfs c, v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)
  | Cmaskzero n, v1 :: nil => Val.maskzero_bool v1 n
  | Cmasknotzero n, v1 :: nil => option_map negb (Val.maskzero_bool v1 n)
  | _, _ => None
  end.

Definition eval_addressing32
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.add v1 (Vint (Int.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.add (Val.add v1 v2) (Vint (Int.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.add (Val.mul v1 (Vint (Int.repr sc))) (Vint (Int.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.add v1 (Val.add (Val.mul v2 (Vint (Int.repr sc))) (Vint (Int.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then None else Some (Genv.symbol_address genv s ofs)
  | Abased s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) v1)
  | Abasedscaled sc s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) (Val.mul v1 (Vint (Int.repr sc))))
  | Ainstack ofs, nil =>
      if Archi.ptr64 then None else Some(Val.offset_ptr sp ofs)
  | _, _ => None
  end.

Definition eval_addressing64
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.addl v1 (Vlong (Int64.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.addl (Val.addl v1 v2) (Vlong (Int64.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.addl (Val.mull v1 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.addl v1 (Val.addl (Val.mull v2 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then Some (Genv.symbol_address genv s ofs) else None
  | Ainstack ofs, nil =>
      if Archi.ptr64 then Some(Val.offset_ptr sp ofs) else None
  | _, _ => None
  end.

Definition eval_addressing
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  if Archi.ptr64
  then eval_addressing64 genv sp addr vl
  else eval_addressing32 genv sp addr vl.

Definition eval_operation
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (op: operation) (vl: list val) (m: mem): option val :=
  match op, vl with
  | Omove, v1::nil => Some v1
  | Ointconst n, nil => Some (Vint n)
  | Olongconst n, nil => Some (Vlong n)
  | Ofloatconst n, nil => Some (Vfloat n)
  | Osingleconst n, nil => Some (Vsingle n)
  | Oindirectsymbol id, nil => Some (Genv.symbol_address genv id Ptrofs.zero)
  | Ocast8signed, v1 :: nil => Some (Val.sign_ext 8 v1)
  | Ocast8unsigned, v1 :: nil => Some (Val.zero_ext 8 v1)
  | Ocast16signed, v1 :: nil => Some (Val.sign_ext 16 v1)
  | Ocast16unsigned, v1 :: nil => Some (Val.zero_ext 16 v1)
  | Oneg, v1::nil => Some (Val.neg v1)
  | Osub, v1::v2::nil => Some (Val.sub v1 v2)
  | Omul, v1::v2::nil => Some (Val.mul v1 v2)
  | Omulimm n, v1::nil => Some (Val.mul v1 (Vint n))
  | Omulhs, v1::v2::nil => Some (Val.mulhs v1 v2)
  | Omulhu, v1::v2::nil => Some (Val.mulhu v1 v2)
  | Odiv, v1::v2::nil => Val.divs v1 v2
  | Odivu, v1::v2::nil => Val.divu v1 v2
  | Omod, v1::v2::nil => Val.mods v1 v2
  | Omodu, v1::v2::nil => Val.modu v1 v2
  | Oand, v1::v2::nil => Some(Val.and v1 v2)
  | Oandimm n, v1::nil => Some (Val.and v1 (Vint n))
  | Oor, v1::v2::nil => Some(Val.or v1 v2)
  | Oorimm n, v1::nil => Some (Val.or v1 (Vint n))
  | Oxor, v1::v2::nil => Some(Val.xor v1 v2)
  | Oxorimm n, v1::nil => Some (Val.xor v1 (Vint n))
  | Onot, v1::nil => Some(Val.notint v1)
  | Oshl, v1::v2::nil => Some (Val.shl v1 v2)
  | Oshlimm n, v1::nil => Some (Val.shl v1 (Vint n))
  | Oshr, v1::v2::nil => Some (Val.shr v1 v2)
  | Oshrimm n, v1::nil => Some (Val.shr v1 (Vint n))
  | Oshrximm n, v1::nil => Val.shrx v1 (Vint n)
  | Oshru, v1::v2::nil => Some (Val.shru v1 v2)
  | Oshruimm n, v1::nil => Some (Val.shru v1 (Vint n))
  | Ororimm n, v1::nil => Some (Val.ror v1 (Vint n))
  | Oshldimm n, v1::v2::nil => Some (Val.or (Val.shl v1 (Vint n))
                                            (Val.shru v2 (Vint (Int.sub Int.iwordsize n))))
  | Olea addr, _ => eval_addressing32 genv sp addr vl
  | Omakelong, v1::v2::nil => Some(Val.longofwords v1 v2)
  | Olowlong, v1::nil => Some(Val.loword v1)
  | Ohighlong, v1::nil => Some(Val.hiword v1)
  | Ocast32signed, v1 :: nil => Some (Val.longofint v1)
  | Ocast32unsigned, v1 :: nil => Some (Val.longofintu v1)
  | Onegl, v1::nil => Some (Val.negl v1)
  | Oaddlimm n, v1::nil => Some (Val.addl v1 (Vlong n))
  | Osubl, v1::v2::nil => Some (Val.subl v1 v2)
  | Omull, v1::v2::nil => Some (Val.mull v1 v2)
  | Omullimm n, v1::nil => Some (Val.mull v1 (Vlong n))
  | Omullhs, v1::v2::nil => Some (Val.mullhs v1 v2)
  | Omullhu, v1::v2::nil => Some (Val.mullhu v1 v2)
  | Odivl, v1::v2::nil => Val.divls v1 v2
  | Odivlu, v1::v2::nil => Val.divlu v1 v2
  | Omodl, v1::v2::nil => Val.modls v1 v2
  | Omodlu, v1::v2::nil => Val.modlu v1 v2
  | Oandl, v1::v2::nil => Some(Val.andl v1 v2)
  | Oandlimm n, v1::nil => Some (Val.andl v1 (Vlong n))
  | Oorl, v1::v2::nil => Some(Val.orl v1 v2)
  | Oorlimm n, v1::nil => Some (Val.orl v1 (Vlong n))
  | Oxorl, v1::v2::nil => Some(Val.xorl v1 v2)
  | Oxorlimm n, v1::nil => Some (Val.xorl v1 (Vlong n))
  | Onotl, v1::nil => Some(Val.notl v1)
  | Oshll, v1::v2::nil => Some (Val.shll v1 v2)
  | Oshllimm n, v1::nil => Some (Val.shll v1 (Vint n))
  | Oshrl, v1::v2::nil => Some (Val.shrl v1 v2)
  | Oshrlimm n, v1::nil => Some (Val.shrl v1 (Vint n))
  | Oshrxlimm n, v1::nil => Val.shrxl v1 (Vint n)
  | Oshrlu, v1::v2::nil => Some (Val.shrlu v1 v2)
  | Oshrluimm n, v1::nil => Some (Val.shrlu v1 (Vint n))
  | Ororlimm n, v1::nil => Some (Val.rorl v1 (Vint n))
  | Oleal addr, _ => eval_addressing64 genv sp addr vl
  | Onegf, v1::nil => Some(Val.negf v1)
  | Oabsf, v1::nil => Some(Val.absf v1)
  | Oaddf, v1::v2::nil => Some(Val.addf v1 v2)
  | Osubf, v1::v2::nil => Some(Val.subf v1 v2)
  | Omulf, v1::v2::nil => Some(Val.mulf v1 v2)
  | Odivf, v1::v2::nil => Some(Val.divf v1 v2)
  | Onegfs, v1::nil => Some(Val.negfs v1)
  | Oabsfs, v1::nil => Some(Val.absfs v1)
  | Oaddfs, v1::v2::nil => Some(Val.addfs v1 v2)
  | Osubfs, v1::v2::nil => Some(Val.subfs v1 v2)
  | Omulfs, v1::v2::nil => Some(Val.mulfs v1 v2)
  | Odivfs, v1::v2::nil => Some(Val.divfs v1 v2)
  | Osingleoffloat, v1::nil => Some(Val.singleoffloat v1)
  | Ofloatofsingle, v1::nil => Some(Val.floatofsingle v1)
  | Ointoffloat, v1::nil => Val.intoffloat v1
  | Ofloatofint, v1::nil => Val.floatofint v1
  | Ointofsingle, v1::nil => Val.intofsingle v1
  | Osingleofint, v1::nil => Val.singleofint v1
  | Olongoffloat, v1::nil => Val.longoffloat v1
  | Ofloatoflong, v1::nil => Val.floatoflong v1
  | Olongofsingle, v1::nil => Val.longofsingle v1
  | Osingleoflong, v1::nil => Val.singleoflong v1
  | Ocmp c, _ => Some(Val.of_optbool (eval_condition c vl m))
  | _, _ => None
  end.

Remark eval_addressing_Aglobal:
  forall (F V: Type) (genv: Genv.t F V) sp id ofs,

Remark eval_addressing_Ainstack:
  forall (F V: Type) (genv: Genv.t F V) sp ofs,

Remark eval_addressing_Ainstack_inv:
  forall (F V: Type) (genv: Genv.t F V) sp ofs vl v,

Ltac FuncInv :=
  match goal with
  | H: (match ?x with nil => _ | _ :: _ => _ end = Some _) |- _ =>
      destruct x; simpl in H; FuncInv
  | H: (match ?v with Vundef => _ | Vint _ => _ | Vfloat _ => _ | Vptr _ _ => _ end = Some _) |- _ =>
      destruct v; simpl in H; FuncInv
  | H: (if Archi.ptr64 then _ else _) = Some _ |- _ =>
      destruct Archi.ptr64 eqn:?; FuncInv
  | H: (Some _ = Some _) |- _ =>
      injection H; intros; clear H; FuncInv
  | H: (None = Some _) |- _ =>
      discriminate H
  | _ =>
      idtac
  end.

Definition type_of_condition (c: condition) : list typ :=
  match c with
  | Ccomp _ => Tint :: Tint :: nil
  | Ccompu _ => Tint :: Tint :: nil
  | Ccompimm _ _ => Tint :: nil
  | Ccompuimm _ _ => Tint :: nil
  | Ccompl _ => Tlong :: Tlong :: nil
  | Ccomplu _ => Tlong :: Tlong :: nil
  | Ccomplimm _ _ => Tlong :: nil
  | Ccompluimm _ _ => Tlong :: nil
  | Ccompf _ => Tfloat :: Tfloat :: nil
  | Cnotcompf _ => Tfloat :: Tfloat :: nil
  | Ccompfs _ => Tsingle :: Tsingle :: nil
  | Cnotcompfs _ => Tsingle :: Tsingle :: nil
  | Cmaskzero _ => Tint :: nil
  | Cmasknotzero _ => Tint :: nil
  end.

Definition type_of_addressing_gen (tyA: typ) (addr: addressing): list typ :=
  match addr with
  | Aindexed _ => tyA :: nil
  | Aindexed2 _ => tyA :: tyA :: nil
  | Ascaled _ _ => tyA :: nil
  | Aindexed2scaled _ _ => tyA :: tyA :: nil
  | Aglobal _ _ => nil
  | Abased _ _ => tyA :: nil
  | Abasedscaled _ _ _ => tyA :: nil
  | Ainstack _ => nil
  end.

Definition type_of_addressing := type_of_addressing_gen Tptr.
Definition type_of_addressing32 := type_of_addressing_gen Tint.
Definition type_of_addressing64 := type_of_addressing_gen Tlong.

Definition type_of_operation (op: operation) : list typ * typ :=
  match op with
  | Omove => (nil, Tint)   
  | Ointconst _ => (nil, Tint)
  | Olongconst _ => (nil, Tlong)
  | Ofloatconst f => (nil, Tfloat)
  | Osingleconst f => (nil, Tsingle)
  | Oindirectsymbol _ => (nil, Tptr)
  | Ocast8signed => (Tint :: nil, Tint)
  | Ocast8unsigned => (Tint :: nil, Tint)
  | Ocast16signed => (Tint :: nil, Tint)
  | Ocast16unsigned => (Tint :: nil, Tint)
  | Oneg => (Tint :: nil, Tint)
  | Osub => (Tint :: Tint :: nil, Tint)
  | Omul => (Tint :: Tint :: nil, Tint)
  | Omulimm _ => (Tint :: nil, Tint)
  | Omulhs => (Tint :: Tint :: nil, Tint)
  | Omulhu => (Tint :: Tint :: nil, Tint)
  | Odiv => (Tint :: Tint :: nil, Tint)
  | Odivu => (Tint :: Tint :: nil, Tint)
  | Omod => (Tint :: Tint :: nil, Tint)
  | Omodu => (Tint :: Tint :: nil, Tint)
  | Oand => (Tint :: Tint :: nil, Tint)
  | Oandimm _ => (Tint :: nil, Tint)
  | Oor => (Tint :: Tint :: nil, Tint)
  | Oorimm _ => (Tint :: nil, Tint)
  | Oxor => (Tint :: Tint :: nil, Tint)
  | Oxorimm _ => (Tint :: nil, Tint)
  | Onot => (Tint :: nil, Tint)
  | Oshl => (Tint :: Tint :: nil, Tint)
  | Oshlimm _ => (Tint :: nil, Tint)
  | Oshr => (Tint :: Tint :: nil, Tint)
  | Oshrimm _ => (Tint :: nil, Tint)
  | Oshrximm _ => (Tint :: nil, Tint)
  | Oshru => (Tint :: Tint :: nil, Tint)
  | Oshruimm _ => (Tint :: nil, Tint)
  | Ororimm _ => (Tint :: nil, Tint)
  | Oshldimm _ => (Tint :: Tint :: nil, Tint)
  | Olea addr => (type_of_addressing32 addr, Tint)
  | Omakelong => (Tint :: Tint :: nil, Tlong)
  | Olowlong => (Tlong :: nil, Tint)
  | Ohighlong => (Tlong :: nil, Tint)
  | Ocast32signed => (Tint :: nil, Tlong)
  | Ocast32unsigned => (Tint :: nil, Tlong)
  | Onegl => (Tlong :: nil, Tlong)
  | Oaddlimm _ => (Tlong :: nil, Tlong)
  | Osubl => (Tlong :: Tlong :: nil, Tlong)
  | Omull => (Tlong :: Tlong :: nil, Tlong)
  | Omullimm _ => (Tlong :: nil, Tlong)
  | Omullhs => (Tlong :: Tlong :: nil, Tlong)
  | Omullhu => (Tlong :: Tlong :: nil, Tlong)
  | Odivl => (Tlong :: Tlong :: nil, Tlong)
  | Odivlu => (Tlong :: Tlong :: nil, Tlong)
  | Omodl => (Tlong :: Tlong :: nil, Tlong)
  | Omodlu => (Tlong :: Tlong :: nil, Tlong)
  | Oandl => (Tlong :: Tlong :: nil, Tlong)
  | Oandlimm _ => (Tlong :: nil, Tlong)
  | Oorl => (Tlong :: Tlong :: nil, Tlong)
  | Oorlimm _ => (Tlong :: nil, Tlong)
  | Oxorl => (Tlong :: Tlong :: nil, Tlong)
  | Oxorlimm _ => (Tlong :: nil, Tlong)
  | Onotl => (Tlong :: nil, Tlong)
  | Oshll => (Tlong :: Tint :: nil, Tlong)
  | Oshllimm _ => (Tlong :: nil, Tlong)
  | Oshrl => (Tlong :: Tint :: nil, Tlong)
  | Oshrlimm _ => (Tlong :: nil, Tlong)
  | Oshrxlimm _ => (Tlong :: nil, Tlong)
  | Oshrlu => (Tlong :: Tint :: nil, Tlong)
  | Oshrluimm _ => (Tlong :: nil, Tlong)
  | Ororlimm _ => (Tlong :: nil, Tlong)
  | Oleal addr => (type_of_addressing64 addr, Tlong)
  | Onegf => (Tfloat :: nil, Tfloat)
  | Oabsf => (Tfloat :: nil, Tfloat)
  | Oaddf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Osubf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Omulf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Odivf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Onegfs => (Tsingle :: nil, Tsingle)
  | Oabsfs => (Tsingle :: nil, Tsingle)
  | Oaddfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osubfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Omulfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Odivfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osingleoffloat => (Tfloat :: nil, Tsingle)
  | Ofloatofsingle => (Tsingle :: nil, Tfloat)
  | Ointoffloat => (Tfloat :: nil, Tint)
  | Ofloatofint => (Tint :: nil, Tfloat)
  | Ointofsingle => (Tsingle :: nil, Tint)
  | Osingleofint => (Tint :: nil, Tsingle)
  | Olongoffloat => (Tfloat :: nil, Tlong)
  | Ofloatoflong => (Tlong :: nil, Tfloat)
  | Olongofsingle => (Tsingle :: nil, Tlong)
  | Osingleoflong => (Tlong :: nil, Tsingle)
  | Ocmp c => (type_of_condition c, Tint)
  end.

Section SOUNDNESS.

Variable A V: Type.
Variable genv: Genv.t A V.

Remark type_add:
  forall v1 v2, Val.has_type (Val.add v1 v2) Tint.

Remark type_addl:
  forall v1 v2, Val.has_type (Val.addl v1 v2) Tlong.

Lemma type_of_addressing64_sound:
  forall addr vl sp v,
  eval_addressing64 genv sp addr vl = Some v ->
  Val.has_type v Tlong.

Lemma type_of_addressing32_sound:
  forall addr vl sp v,
  eval_addressing32 genv sp addr vl = Some v ->
  Val.has_type v Tint.

Corollary type_of_addressing_sound:
  forall addr vl sp v,
  eval_addressing genv sp addr vl = Some v ->
  Val.has_type v Tptr.

Lemma type_of_operation_sound:
  forall op vl sp v m,
  op <> Omove ->
  eval_operation genv sp op vl m = Some v ->
  Val.has_type v (snd (type_of_operation op)).

End SOUNDNESS.

Definition is_move_operation
    (A: Type) (op: operation) (args: list A) : option A :=
  match op, args with
  | Omove, arg :: nil => Some arg
  | _, _ => None
  end.

Lemma is_move_operation_correct:
  forall (A: Type) (op: operation) (args: list A) (a: A),
  is_move_operation op args = Some a ->
  op = Omove /\ args = a :: nil.

Definition negate_condition (cond: condition): condition :=
  match cond with
  | Ccomp c => Ccomp(negate_comparison c)
  | Ccompu c => Ccompu(negate_comparison c)
  | Ccompimm c n => Ccompimm (negate_comparison c) n
  | Ccompuimm c n => Ccompuimm (negate_comparison c) n
  | Ccompl c => Ccompl(negate_comparison c)
  | Ccomplu c => Ccomplu(negate_comparison c)
  | Ccomplimm c n => Ccomplimm (negate_comparison c) n
  | Ccompluimm c n => Ccompluimm (negate_comparison c) n
  | Ccompf c => Cnotcompf c
  | Cnotcompf c => Ccompf c
  | Ccompfs c => Cnotcompfs c
  | Cnotcompfs c => Ccompfs c
  | Cmaskzero n => Cmasknotzero n
  | Cmasknotzero n => Cmaskzero n
  end.

Lemma eval_negate_condition:
  forall cond vl m,
  eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m).

Definition shift_stack_addressing (delta: Z) (addr: addressing) :=
  match addr with
  | Ainstack ofs => Ainstack (Ptrofs.add ofs (Ptrofs.repr delta))
  | _ => addr
  end.

Definition shift_stack_operation (delta: Z) (op: operation) :=
  match op with
  | Olea  addr => Olea  (shift_stack_addressing delta addr)
  | Oleal addr => Oleal (shift_stack_addressing delta addr)
  | _ => op
  end.

Lemma type_shift_stack_addressing:
  forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr.

Lemma type_shift_stack_operation:
  forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op.

Lemma eval_shift_stack_addressing32:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing64:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_operation:
  forall F V (ge: Genv.t F V) sp op vl m delta,

Definition offset_addressing_total (addr: addressing) (delta: Z) : addressing :=
  match addr with
  | Aindexed n => Aindexed (n + delta)
  | Aindexed2 n => Aindexed2 (n + delta)
  | Ascaled sc n => Ascaled sc (n + delta)
  | Aindexed2scaled sc n => Aindexed2scaled sc (n + delta)
  | Aglobal s n => Aglobal s (Ptrofs.add n (Ptrofs.repr delta))
  | Abased s n => Abased s (Ptrofs.add n (Ptrofs.repr delta))
  | Abasedscaled sc s n => Abasedscaled sc s (Ptrofs.add n (Ptrofs.repr delta))
  | Ainstack n => Ainstack (Ptrofs.add n (Ptrofs.repr delta))
  end.

Definition offset_addressing (addr: addressing) (delta: Z) : option addressing :=
  let addr' := offset_addressing_total addr delta in
  if addressing_valid addr' then Some addr' else None.

Lemma eval_offset_addressing_total_32:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing_total_64:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta addr' v,

Definition is_trivial_op (op: operation) : bool :=
  match op with
  | Omove => true
  | Ointconst _ => true
  | Olongconst _ => true
  | Olea (Aglobal _ _) => true
  | Olea (Ainstack _) => true
  | Oleal (Aglobal _ _) => true
  | Oleal (Ainstack _) => true
  | _ => false
  end.

Definition op_depends_on_memory (op: operation) : bool :=
  match op with
  | Ocmp (Ccompu _) => negb Archi.ptr64
  | Ocmp (Ccompuimm _ _) => negb Archi.ptr64
  | Ocmp (Ccomplu _) => Archi.ptr64
  | Ocmp (Ccompluimm _ _) => Archi.ptr64
  | _ => false
  end.

Lemma op_depends_on_memory_correct:
  forall (F V: Type) (ge: Genv.t F V) sp op args m1 m2,

Definition globals_addressing (addr: addressing) : list ident :=
  match addr with
  | Aglobal s n => s :: nil
  | Abased s n => s :: nil
  | Abasedscaled sc s n => s :: nil
  | _ => nil
  end.

Definition globals_operation (op: operation) : list ident :=
  match op with
  | Oindirectsymbol s => s :: nil
  | Olea addr => globals_addressing addr
  | Oleal addr => globals_addressing addr
  | _ => nil
  end.

Section GENV_TRANSF.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Hypothesis agree_on_symbols:
  forall (s: ident), Genv.find_symbol ge2 s = Genv.find_symbol ge1 s.

Lemma eval_addressing32_preserved:
  forall sp addr vl,
  eval_addressing32 ge2 sp addr vl = eval_addressing32 ge1 sp addr vl.

Lemma eval_addressing64_preserved:
  forall sp addr vl,
  eval_addressing64 ge2 sp addr vl = eval_addressing64 ge1 sp addr vl.

Lemma eval_addressing_preserved:
  forall sp addr vl,
  eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.

Lemma eval_operation_preserved:
  forall sp op vl m,
  eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.

End GENV_TRANSF.

Section EVAL_COMPAT.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Variable f: meminj.

Variable m1: mem.
Variable m2: mem.

Hypothesis valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_pointers_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->
  Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Ltac InvInject :=
  match goal with
  | [ H: Val.inject _ (Vint _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vfloat _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vptr _ _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ nil _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ (_ :: _) _ |- _ ] =>
      inv H; InvInject
  | _ => idtac
  end.

Lemma eval_condition_inj:
  forall cond vl1 vl2 b,
  Val.inject_list f vl1 vl2 ->

Ltac TrivialExists :=
  match goal with
  | [ |- exists v2, Some ?v1 = Some v2 /\ Val.inject _ _ v2 ] =>
      exists v1; split; auto
  | _ => idtac
  end.

Lemma eval_addressing32_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing64_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_operation_inj:
  forall op sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_operation op) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

End EVAL_COMPAT.

Section EVAL_LESSDEF.

Variable F V: Type.
Variable genv: Genv.t F V.

Remark valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_no_overflow_extends:
  forall m1 b1 ofs b2 delta,
  Some(b1, 0) = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->

Remark valid_different_pointers_extends:
  forall m1 b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->

Lemma eval_condition_lessdef:
  forall cond vl1 vl2 b m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_operation_lessdef:
  forall sp op vl1 vl2 v1 m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_addressing_lessdef:
  forall sp addr vl1 vl2 v1,
  Val.lessdef_list vl1 vl2 ->

End EVAL_LESSDEF.

Section EVAL_INJECT.

Variable F V: Type.
Variable genv: Genv.t F V.
Variable f: meminj.
Hypothesis globals: meminj_preserves_globals genv f.
Variable sp1: block.
Variable sp2: block.
Variable delta: Z.
Hypothesis sp_inj: f sp1 = Some(sp2, delta).

Remark symbol_address_inject:
  forall id ofs, Val.inject f (Genv.symbol_address genv id ofs) (Genv.symbol_address genv id ofs).

Lemma eval_condition_inject:
  forall cond vl1 vl2 b m1 m2,
  Val.inject_list f vl1 vl2 ->

Lemma eval_addressing_inject:
  forall addr vl1 vl2 v1,
  Val.inject_list f vl1 vl2 ->

Lemma eval_operation_inject:
  forall op vl1 vl2 v1 m1 m2,
  Val.inject_list f vl1 vl2 ->

End EVAL_INJECT.

Definition builtin_arg_ok_1
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match c, ba with
  | OK_all, _ => true
  | OK_const, (BA_int _ | BA_long _ | BA_float _ | BA_single _) => true
  | OK_addrstack, BA_addrstack _ => true
  | OK_addressing, BA_addrstack _ => true
  | OK_addressing, BA_addrglobal _ _ => true
  | OK_addressing, BA_addptr (BA _) (BA_int _ | BA_long _) => true
  | _, _ => false
  end.

Definition builtin_arg_ok
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match ba with
  | (BA _ | BA_splitlong (BA _) (BA _)) => true
  | _ => builtin_arg_ok_1 ba c
  end. *)

Require Import Registers.

Require Import CminorSel.

Require Import RTL.

Require Import RTLgen.
(* RTLgen:
Require Import Coqlib.
Require Errors.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Switch.
Require Import Op.
Require Import Registers.
Require Import CminorSel.
Require Import RTL.

Open Local Scope string_scope.

Record mapping: Type := mkmapping {
  map_vars: PTree.t reg;
  map_letvars: list reg
}.

Record state: Type := mkstate {
  st_nextreg: positive;
  st_nextnode: positive;
  st_code: code;
  st_wf: forall (pc: positive), Plt pc st_nextnode \/ st_code!pc = None
}.

Inductive state_incr: state -> state -> Prop :=
  state_incr_intro:
    forall (s1 s2: state),
    Ple s1.(st_nextnode) s2.(st_nextnode) ->
    Ple s1.(st_nextreg) s2.(st_nextreg) ->
    (forall pc,
      s1.(st_code)!pc = None \/ s2.(st_code)!pc = s1.(st_code)!pc) ->
    state_incr s1 s2.

Lemma state_incr_refl:
  forall s, state_incr s s.

Lemma state_incr_trans:
  forall s1 s2 s3, state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3.

Inductive res (A: Type) (s: state): Type :=
  | Error: Errors.errmsg -> res A s
  | OK: A -> forall (s': state), state_incr s s' -> res A s.

Implicit Arguments OK [A s].
Implicit Arguments Error [A s].

Definition mon (A: Type) : Type := forall (s: state), res A s.

Definition ret (A: Type) (x: A) : mon A :=
  fun (s: state) => OK x s (state_incr_refl s).

Implicit Arguments ret [A].

Definition error (A: Type) (msg: Errors.errmsg) : mon A := fun (s: state) => Error msg.

Implicit Arguments error [A].

Definition bind (A B: Type) (f: mon A) (g: A -> mon B) : mon B :=
  fun (s: state) =>
    match f s with
    | Error msg => Error msg
    | OK a s' i =>
        match g a s' with
        | Error msg => Error msg
        | OK b s'' i' => OK b s'' (state_incr_trans s s' s'' i i')
        end
    end.

Implicit Arguments bind [A B].

Definition bind2 (A B C: Type) (f: mon (A * B)) (g: A -> B -> mon C) : mon C :=
  bind f (fun xy => g (fst xy) (snd xy)).

Implicit Arguments bind2 [A B C].

Notation "'do' X <- A ; B" := (bind A (fun X => B))
   (at level 200, X ident, A at level 100, B at level 200).
Notation "'do' ( X , Y ) <- A ; B" := (bind2 A (fun X Y => B))
   (at level 200, X ident, Y ident, A at level 100, B at level 200).

Definition handle_error (A: Type) (f g: mon A) : mon A :=
  fun (s: state) =>
    match f s with
    | OK a s' i => OK a s' i
    | Error _ => g s
    end.

Implicit Arguments handle_error [A].

Remark init_state_wf:
  forall pc, Plt pc 1%positive \/ (PTree.empty instruction)!pc = None.

Definition init_state : state :=
  mkstate 1%positive 1%positive (PTree.empty instruction) init_state_wf.

Remark add_instr_wf:
  forall s i pc,
  let n := s.(st_nextnode) in

Remark add_instr_incr:
  forall s i,
  let n := s.(st_nextnode) in

Definition add_instr (i: instruction) : mon node :=
  fun s =>
    let n := s.(st_nextnode) in
    OK n
       (mkstate s.(st_nextreg) (Psucc n) (PTree.set n i s.(st_code))
                (add_instr_wf s i))
       (add_instr_incr s i).

Remark reserve_instr_wf:
  forall s pc,
  Plt pc (Psucc s.(st_nextnode)) \/ s.(st_code)!pc = None.

Remark reserve_instr_incr:
  forall s,
  let n := s.(st_nextnode) in

Definition reserve_instr: mon node :=
  fun (s: state) =>
  let n := s.(st_nextnode) in
  OK n
     (mkstate s.(st_nextreg) (Psucc n) s.(st_code) (reserve_instr_wf s))
     (reserve_instr_incr s).

Remark update_instr_wf:
  forall s n i,
  Plt n s.(st_nextnode) ->

Remark update_instr_incr:
  forall s n i (LT: Plt n s.(st_nextnode)),

Definition check_empty_node:
  forall (s: state) (n: node), { s.(st_code)!n = None } + { True }.

Definition update_instr (n: node) (i: instruction) : mon unit :=
  fun s =>
    match plt n s.(st_nextnode), check_empty_node s n with
    | left LT, left EMPTY =>
        OK tt
           (mkstate s.(st_nextreg) s.(st_nextnode) (PTree.set n i s.(st_code))
                    (update_instr_wf s n i LT))
           (update_instr_incr s n i LT EMPTY)
    | _, _ =>
        Error (Errors.msg "RTLgen.update_instr")
    end.

Remark new_reg_incr:
  forall s,
  state_incr s (mkstate (Psucc s.(st_nextreg))

Definition new_reg : mon reg :=
  fun s =>
    OK s.(st_nextreg)
       (mkstate (Psucc s.(st_nextreg)) s.(st_nextnode) s.(st_code) s.(st_wf))
       (new_reg_incr s).

Definition init_mapping : mapping :=
  mkmapping (PTree.empty reg) nil.

Definition add_var (map: mapping) (name: ident) : mon (reg * mapping) :=
  do r <- new_reg;
     ret (r, mkmapping (PTree.set name r map.(map_vars))
                       map.(map_letvars)).

Fixpoint add_vars (map: mapping) (names: list ident)
                  {struct names} : mon (list reg * mapping) :=
  match names with
  | nil => ret (nil, map)
  | n1 :: nl =>
      do (rl, map1) <- add_vars map nl;
      do (r1, map2) <- add_var map1 n1;
      ret (r1 :: rl, map2)
  end.

Definition find_var (map: mapping) (name: ident) : mon reg :=
  match PTree.get name map.(map_vars) with
  | None => error (Errors.MSG "RTLgen: unbound variable " :: Errors.CTX name :: nil)
  | Some r => ret r
  end.

Definition add_letvar (map: mapping) (r: reg) : mapping :=
  mkmapping map.(map_vars) (r :: map.(map_letvars)).

Definition find_letvar (map: mapping) (idx: nat) : mon reg :=
  match List.nth_error map.(map_letvars) idx with
  | None => error (Errors.msg "RTLgen: unbound let variable")
  | Some r => ret r
  end.

Definition alloc_reg (map: mapping) (a: expr) : mon reg :=
  match a with
  | Evar id   => find_var map id
  | Eletvar n => find_letvar map n
  | _         => new_reg
  end.

Fixpoint alloc_regs (map: mapping) (al: exprlist)
                    {struct al}: mon (list reg) :=
  match al with
  | Enil =>
      ret nil
  | Econs a bl =>
      do r  <- alloc_reg map a;
      do rl <- alloc_regs map bl;
      ret (r :: rl)
  end.

Definition alloc_optreg (map: mapping) (dest: option ident) : mon reg :=
  match dest with
  | Some id => find_var map id
  | None => new_reg
  end.

Definition add_move (rs rd: reg) (nd: node) : mon node :=
  if Reg.eq rs rd
  then ret nd
  else add_instr (Iop Omove (rs::nil) rd nd).

Fixpoint transl_expr (map: mapping) (a: expr) (rd: reg) (nd: node)
                     {struct a}: mon node :=
  match a with
  | Evar v =>
      do r <- find_var map v; add_move r rd nd
  | Eop op al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Iop op rl rd nd);
      transl_exprlist map al rl no
  | Eload chunk addr al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Iload chunk addr rl rd nd);
         transl_exprlist map al rl no
  | Econdition a b c =>
      do nfalse <- transl_expr map c rd nd;
      do ntrue  <- transl_expr map b rd nd;
         transl_condexpr map a ntrue nfalse
  | Elet b c =>
      do r  <- new_reg;
      do nc <- transl_expr (add_letvar map r) c rd nd;
         transl_expr map b r nc
  | Eletvar n =>
      do r <- find_letvar map n; add_move r rd nd
  | Ebuiltin ef al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Ibuiltin ef rl rd nd);
      transl_exprlist map al rl no
  | Eexternal id sg al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Icall sg (inr id) rl rd nd);
      transl_exprlist map al rl no
  end

with transl_exprlist (map: mapping) (al: exprlist) (rl: list reg) (nd: node)
                     {struct al} : mon node :=
  match al, rl with
  | Enil, nil =>
      ret nd
  | Econs b bs, r :: rs =>
      do no <- transl_exprlist map bs rs nd; transl_expr map b r no
  | _, _ =>
      error (Errors.msg "RTLgen.transl_exprlist")
  end

with transl_condexpr (map: mapping) (a: condexpr) (ntrue nfalse: node)
                     {struct a} : mon node :=
  match a with
  | CEcond c al =>
      do rl <- alloc_regs map al;
      do nt <- add_instr (Icond c rl ntrue nfalse);
         transl_exprlist map al rl nt
  | CEcondition a b c =>
      do nc <- transl_condexpr map c ntrue nfalse;
      do nb <- transl_condexpr map b ntrue nfalse;
         transl_condexpr map a nb nc
  | CElet b c =>
      do r  <- new_reg;
      do nc <- transl_condexpr (add_letvar map r) c ntrue nfalse;
         transl_expr map b r nc
  end.

Parameter more_likely: condexpr -> stmt -> stmt -> bool.

Parameter compile_switch: nat -> table -> comptree.

Definition transl_exit (nexits: list node) (n: nat) : mon node :=
  match nth_error nexits n with
  | None => error (Errors.msg "RTLgen: wrong exit")
  | Some ne => ret ne
  end.

Fixpoint transl_jumptable (nexits: list node) (tbl: list nat) : mon (list node) :=
  match tbl with
  | nil => ret nil
  | t1 :: tl =>
      do n1 <- transl_exit nexits t1;
      do nl <- transl_jumptable nexits tl;
      ret (n1 :: nl)
  end.

Fixpoint transl_switch (r: reg) (nexits: list node) (t: comptree)
                       {struct t} : mon node :=
  match t with
  | CTaction act =>
      transl_exit nexits act
  | CTifeq key act t' =>
      do ncont <- transl_switch r nexits t';
      do nfound <- transl_exit nexits act;
      add_instr (Icond (Ccompimm Ceq key) (r :: nil) nfound ncont)
  | CTiflt key t1 t2 =>
      do n2 <- transl_switch r nexits t2;
      do n1 <- transl_switch r nexits t1;
      add_instr (Icond (Ccompuimm Clt key) (r :: nil) n1 n2)
  | CTjumptable ofs sz tbl t' =>
      do rt <- new_reg;
      do ttbl <- transl_jumptable nexits tbl;
      do n1 <- add_instr (Ijumptable rt ttbl);
      do n2 <- transl_switch r nexits t';
      do n3 <- add_instr (Icond (Ccompuimm Clt sz) (rt :: nil) n1 n2);
      let op := if Int.eq ofs Int.zero then Omove else Oaddimm (Int.neg ofs) in
      add_instr (Iop op (r :: nil) rt n3)
  end.

Definition labelmap : Type := PTree.t node.

Fixpoint transl_stmt (map: mapping) (s: stmt) (nd: node)
                     (nexits: list node) (ngoto: labelmap) (nret: node) (rret: option reg)
                     {struct s} : mon node :=
  match s with
  | Sskip =>
      ret nd
  | Sassign v b =>
      do r <- find_var map v;
      transl_expr map b r nd
  | Sstore chunk addr al b =>
      do rl <- alloc_regs map al;
      do r <- alloc_reg map b;
      do no <- add_instr (Istore chunk addr rl r nd);
      do ns <- transl_expr map b r no;
         transl_exprlist map al rl ns
  | Scall optid sig (inl b) cl =>
      do rf <- alloc_reg map b;
      do rargs <- alloc_regs map cl;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Icall sig (inl _ rf) rargs r nd);
      do n2 <- transl_exprlist map cl rargs n1;
         transl_expr map b rf n2
  | Scall optid sig (inr id) cl =>
      do rargs <- alloc_regs map cl;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Icall sig (inr _ id) rargs r nd);
      transl_exprlist map cl rargs n1
  | Stailcall sig (inl b) cl =>
      do rf <- alloc_reg map b;
      do rargs <- alloc_regs map cl;
      do n1 <- add_instr (Itailcall sig (inl _ rf) rargs);
      do n2 <- transl_exprlist map cl rargs n1;
         transl_expr map b rf n2
  | Stailcall sig (inr id) cl =>
      do rargs <- alloc_regs map cl;
      do n1 <- add_instr (Itailcall sig (inr _ id) rargs);
      transl_exprlist map cl rargs n1
  | Sbuiltin optid ef al =>
      do rargs <- alloc_regs map al;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Ibuiltin ef rargs r nd);
         transl_exprlist map al rargs n1
  | Sseq s1 s2 =>
      do ns <- transl_stmt map s2 nd nexits ngoto nret rret;
      transl_stmt map s1 ns nexits ngoto nret rret
  | Sifthenelse c strue sfalse =>
      if more_likely c strue sfalse then
        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
           transl_condexpr map c ntrue nfalse
      else
        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
           transl_condexpr map c ntrue nfalse
  | Sloop sbody =>
      do n1 <- reserve_instr;
      do n2 <- transl_stmt map sbody n1 nexits ngoto nret rret;
      do xx <- update_instr n1 (Inop n2);
      add_instr (Inop n2)
  | Sblock sbody =>
      transl_stmt map sbody nd (nd :: nexits) ngoto nret rret
  | Sexit n =>
      transl_exit nexits n
  | Sswitch a cases default =>
      let t := compile_switch default cases in
      if validate_switch default cases t then
        (do r <- alloc_reg map a;
         do ns <- transl_switch r nexits t;
         transl_expr map a r ns)
      else
        error (Errors.msg "RTLgen: wrong switch")
  | Sreturn opt_a =>
      match opt_a, rret with
      | None, _ => ret nret
      | Some a, Some r => transl_expr map a r nret
      | _, _ => error (Errors.msg "RTLgen: type mismatch on return")
      end
  | Slabel lbl s' =>
      do ns <- transl_stmt map s' nd nexits ngoto nret rret;
      match ngoto!lbl with
      | None => error (Errors.msg "RTLgen: unbound label")
      | Some n =>
          do xx <-
            (handle_error (update_instr n (Inop ns))
                          (error (Errors.MSG "Multiply-defined label " ::
                                  Errors.CTX lbl :: nil)));
          ret ns
      end
  | Sgoto lbl =>
      match ngoto!lbl with
      | None => error (Errors.MSG "Undefined defined label " ::
                       Errors.CTX lbl :: nil)
      | Some n => ret n
      end
  end.

Definition alloc_label (lbl: Cminor.label) (maps: labelmap * state) : labelmap * state :=
  let (map, s) := maps in
  let n := s.(st_nextnode) in
  (PTree.set lbl n map,
   mkstate s.(st_nextreg) (Psucc s.(st_nextnode)) s.(st_code) (reserve_instr_wf s)).

Fixpoint reserve_labels (s: stmt) (ms: labelmap * state)
                        {struct s} : labelmap * state :=
  match s with
  | Sseq s1 s2 => reserve_labels s1 (reserve_labels s2 ms)
  | Sifthenelse c s1 s2 => reserve_labels s1 (reserve_labels s2 ms)
  | Sloop s1 => reserve_labels s1 ms
  | Sblock s1 => reserve_labels s1 ms
  | Slabel lbl s1 => alloc_label lbl (reserve_labels s1 ms)
  | _ => ms
  end.

Definition ret_reg (sig: signature) (rd: reg) : option reg :=
  match sig.(sig_res) with
  | None => None
  | Some ty => Some rd
  end.

Definition transl_fun (f: CminorSel.function) (ngoto: labelmap): mon (node * list reg) :=
  do (rparams, map1) <- add_vars init_mapping f.(CminorSel.fn_params);
  do (rvars, map2) <- add_vars map1 f.(CminorSel.fn_vars);
  do rret <- new_reg;
  let orret := ret_reg f.(CminorSel.fn_sig) rret in
  do nret <- add_instr (Ireturn orret);
  do nentry <- transl_stmt map2 f.(CminorSel.fn_body) nret nil ngoto nret orret;
  ret (nentry, rparams).

Definition transl_function (f: CminorSel.function) : Errors.res RTL.function :=
  let (ngoto, s0) := reserve_labels f.(fn_body) (PTree.empty node, init_state) in
  match transl_fun f ngoto s0 with
  | Error msg => Errors.Error msg
  | OK (nentry, rparams) s i =>
      Errors.OK (RTL.mkfunction
                   f.(CminorSel.fn_sig)
                   rparams
                   f.(CminorSel.fn_stackspace)
                   s.(st_code)
                   nentry)
  end.

Definition transl_fundef := transf_partial_fundef transl_function.

Definition transl_program (p: CminorSel.program) : Errors.res RTL.program :=
  transform_partial_program transl_fundef p. *)



Remark bind_inversion:

  forall (A B: Type) (f: mon A) (g: A -> mon B)

         (y: B) (s1 s3: state) (i: state_incr s1 s3),

  bind f g s1 = OK y s3 i ->

  exists x, exists s2, exists i1, exists i2,

  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2.

Proof.

  intros until i. unfold bind. destruct (f s1); intros.

  discriminate.

  exists a; exists s'; exists s.

  destruct (g a s'); inv H.

  exists s0; auto.

Qed.



Remark bind2_inversion:

  forall (A B C: Type) (f: mon (A*B)) (g: A -> B -> mon C)

         (z: C) (s1 s3: state) (i: state_incr s1 s3),

  bind2 f g s1 = OK z s3 i ->

  exists x, exists y, exists s2, exists i1, exists i2,

  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2.

Proof.

  unfold bind2; intros.

  exploit bind_inversion; eauto.

  intros [[x y] [s2 [i1 [i2 [P Q]]]]]. simpl in Q.

  exists x; exists y; exists s2; exists i1; exists i2; auto.

Qed.



Ltac monadInv1 H :=

  match type of H with

  | (OK _ _ _ = OK _ _ _) =>

      inversion H; clear H; try subst

  | (Error _ _ = OK _ _ _) =>

      discriminate

  | (ret _ _ = OK _ _ _) =>

      inversion H; clear H; try subst

  | (error _ _ = OK _ _ _) =>

      discriminate

  | (bind ?F ?G ?S = OK ?X ?S' ?I) =>

      let x := fresh "x" in (

      let s := fresh "s" in (

      let i1 := fresh "INCR" in (

      let i2 := fresh "INCR" in (

      let EQ1 := fresh "EQ" in (

      let EQ2 := fresh "EQ" in (

      destruct (bind_inversion _ _ F G X S S' I H) as [x [s [i1 [i2 [EQ1 EQ2]]]]];

      clear H;

      try (monadInv1 EQ2)))))))

  | (bind2 ?F ?G ?S = OK ?X ?S' ?I) =>

      let x1 := fresh "x" in (

      let x2 := fresh "x" in (

      let s := fresh "s" in (

      let i1 := fresh "INCR" in (

      let i2 := fresh "INCR" in (

      let EQ1 := fresh "EQ" in (

      let EQ2 := fresh "EQ" in (

      destruct (bind2_inversion _ _ _ F G X S S' I H) as [x1 [x2 [s [i1 [i2 [EQ1 EQ2]]]]]];

      clear H;

      try (monadInv1 EQ2))))))))

  end.



Ltac monadInv H :=

  match type of H with

  | (ret _ _ = OK _ _ _) => monadInv1 H

  | (error _ _ = OK _ _ _) => monadInv1 H

  | (bind ?F ?G ?S = OK ?X ?S' ?I) => monadInv1 H

  | (bind2 ?F ?G ?S = OK ?X ?S' ?I) => monadInv1 H

  | (?F _ _ _ _ _ _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ _ _ _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ _ _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  | (?F _ = OK _ _ _) =>

      ((progress simpl in H) || unfold F in H); monadInv1 H

  end.



Hint Resolve state_incr_refl: rtlg.



Lemma instr_at_incr:

  forall s1 s2 n i,

  state_incr s1 s2 -> s1.(st_code)!n = Some i -> s2.(st_code)!n = Some i.

Proof.

  intros. inv H.

  destruct (H3 n); congruence.

Qed.

Hint Resolve instr_at_incr: rtlg.



Ltac saturateTrans :=

  match goal with

  | H1: state_incr ?x ?y, H2: state_incr ?y ?z |- _ =>

      match goal with

      | H: state_incr x z |- _  =>

         fail 1

      | _ =>

         let i := fresh "INCR" in

         (generalize (state_incr_trans x y z H1 H2); intro i;

          saturateTrans)

      end

  | _ => idtac

  end.



Definition reg_valid (r: reg) (s: state) : Prop :=

  Plt r s.(st_nextreg).



Definition reg_fresh (r: reg) (s: state) : Prop :=

  ~(Plt r s.(st_nextreg)).



Lemma valid_fresh_absurd:

  forall r s, reg_valid r s -> reg_fresh r s -> False.

Proof.

  intros r s. unfold reg_valid, reg_fresh; case r; tauto.

Qed.

Hint Resolve valid_fresh_absurd: rtlg.



Lemma valid_fresh_different:

  forall r1 r2 s, reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2.

Proof.

  unfold not; intros. subst r2. eauto with rtlg.

Qed.

Hint Resolve valid_fresh_different: rtlg.



Lemma reg_valid_incr:

  forall r s1 s2, state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2.

Proof.

  intros r s1 s2 INCR.

  inversion INCR.

  unfold reg_valid. intros; apply Plt_Ple_trans with (st_nextreg s1); auto.

Qed.

Hint Resolve reg_valid_incr: rtlg.



Lemma reg_fresh_decr:

  forall r s1 s2, state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1.

Proof.

  intros r s1 s2 INCR. inversion INCR.

  unfold reg_fresh; unfold not; intros.

  apply H4. apply Plt_Ple_trans with (st_nextreg s1); auto.

Qed.

Hint Resolve reg_fresh_decr: rtlg.



Definition regs_valid (rl: list reg) (s: state) : Prop :=

  forall r, In r rl -> reg_valid r s.



Lemma regs_valid_nil:

  forall s, regs_valid nil s.

Proof.

  intros; red; intros. elim H.

Qed.

Hint Resolve regs_valid_nil: rtlg.



Lemma regs_valid_cons:

  forall r1 rl s,

  reg_valid r1 s -> regs_valid rl s -> regs_valid (r1 :: rl) s.

Proof.

  intros; red; intros. elim H1; intro. subst r1; auto. auto.

Qed.



Lemma regs_valid_incr:

  forall s1 s2 rl, state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2.

Proof.

  unfold regs_valid; intros; eauto with rtlg.

Qed.

Hint Resolve regs_valid_incr: rtlg.



Definition reg_in_map (m: mapping) (r: reg) : Prop :=

  (exists id, m.(map_vars)!id = Some r) \/ In r m.(map_letvars).



Definition map_valid (m: mapping) (s: state) : Prop :=

  forall r, reg_in_map m r -> reg_valid r s.



Lemma map_valid_incr:

  forall s1 s2 m,

  state_incr s1 s2 -> map_valid m s1 -> map_valid m s2.

Proof.

  unfold map_valid; intros; eauto with rtlg.

Qed.

Hint Resolve map_valid_incr: rtlg.



Lemma add_instr_at:

  forall s1 s2 incr i n,

  add_instr i s1 = OK n s2 incr -> s2.(st_code)!n = Some i.

Proof.

  intros. monadInv H. simpl. apply PTree.gss.

Qed.

Hint Resolve add_instr_at: rtlg.



Lemma update_instr_at:

  forall n i s1 s2 incr u,

  update_instr n i s1 = OK u s2 incr -> s2.(st_code)!n = Some i.

Proof.

  intros. unfold update_instr in H.

  destruct (plt n (st_nextnode s1)); try discriminate.

  destruct (check_empty_node s1 n); try discriminate.

  inv H. simpl. apply PTree.gss.

Qed.

Hint Resolve update_instr_at: rtlg.



Lemma new_reg_valid:

  forall s1 s2 r i,

  new_reg s1 = OK r s2 i -> reg_valid r s2.

Proof.

  intros. monadInv H.

  unfold reg_valid; simpl. apply Plt_succ.

Qed.

Hint Resolve new_reg_valid: rtlg.



Lemma new_reg_fresh:

  forall s1 s2 r i,

  new_reg s1 = OK r s2 i -> reg_fresh r s1.

Proof.

  intros. monadInv H.

  unfold reg_fresh; simpl.

  exact (Plt_strict _).

Qed.

Hint Resolve new_reg_fresh: rtlg.



Lemma new_reg_not_in_map:

  forall s1 s2 m r i,

  new_reg s1 = OK r s2 i -> map_valid m s1 -> ~(reg_in_map m r).

Proof.

  unfold not; intros; eauto with rtlg.

Qed.

Hint Resolve new_reg_not_in_map: rtlg.



Lemma init_mapping_valid:

  forall s, map_valid init_mapping s.

Proof.

  unfold map_valid, init_mapping.

  intros s r [[id A] | B].

  simpl in A. rewrite PTree.gempty in A; discriminate.

  simpl in B. tauto.

Qed.



Lemma find_var_in_map:

  forall s1 s2 map name r i,

  find_var map name s1 = OK r s2 i -> reg_in_map map r.

Proof.

  intros until r. unfold find_var; caseEq (map.(map_vars)!name).

  intros. inv H0. left; exists name; auto.

  intros. inv H0.

Qed.

Hint Resolve find_var_in_map: rtlg.



Lemma find_var_valid:

  forall s1 s2 map name r i,

  find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.

Proof.

  eauto with rtlg.

Qed.

Hint Resolve find_var_valid: rtlg.



Lemma find_letvar_in_map:

  forall s1 s2 map idx r i,

  find_letvar map idx s1 = OK r s2 i -> reg_in_map map r.

Proof.

  intros until r. unfold find_letvar.

  caseEq (nth_error (map_letvars map) idx); intros; monadInv H0.

  right; apply nth_error_in with idx; auto.

Qed.

Hint Resolve find_letvar_in_map: rtlg.



Lemma find_letvar_valid:

  forall s1 s2 map idx r i,

  find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.

Proof.

  eauto with rtlg.

Qed.

Hint Resolve find_letvar_valid: rtlg.



Lemma add_var_valid:

  forall s1 s2 map1 map2 name r i,

  add_var map1 name s1 = OK (r, map2) s2 i ->

  map_valid map1 s1 ->

  reg_valid r s2 /\ map_valid map2 s2.

Proof.

  intros. monadInv H.

  split. eauto with rtlg.

  inversion EQ. subst. red. intros r' [[id A] | B].

  simpl in A. rewrite PTree.gsspec in A. destruct (peq id name).

  inv A. eauto with rtlg.

  apply reg_valid_incr with s1. eauto with rtlg.

  apply H0. left; exists id; auto.

  simpl in B. apply reg_valid_incr with s1. eauto with rtlg.

  apply H0. right; auto.

Qed.



Lemma add_var_find:

  forall s1 s2 map name r map' i,

  add_var map name s1 = OK (r,map') s2 i -> map'.(map_vars)!name = Some r.

Proof.

  intros. monadInv H. simpl. apply PTree.gss.

Qed.



Lemma add_vars_valid:

  forall namel s1 s2 map1 map2 rl i,

  add_vars map1 namel s1 = OK (rl, map2) s2 i ->

  map_valid map1 s1 ->

  regs_valid rl s2 /\ map_valid map2 s2.

Proof.

  induction namel; simpl; intros; monadInv H.

  split. red; simpl; intros; tauto. auto.

  exploit IHnamel; eauto. intros [A B].

  exploit add_var_valid; eauto. intros [C D].

  split. apply regs_valid_cons; eauto with rtlg.

  auto.

Qed.



Lemma add_var_letenv:

  forall map1 id s1 r map2 s2 i,

  add_var map1 id s1 = OK (r, map2) s2 i ->

  map2.(map_letvars) = map1.(map_letvars).

Proof.

  intros; monadInv H. reflexivity.

Qed.



Lemma add_vars_letenv:

  forall il map1 s1 rl map2 s2 i,

  add_vars map1 il s1 = OK (rl, map2) s2 i ->

  map2.(map_letvars) = map1.(map_letvars).

Proof.

  induction il; simpl; intros; monadInv H.

  reflexivity.

  transitivity (map_letvars x0).

  eapply add_var_letenv; eauto.

  eauto.

Qed.



Lemma add_letvar_valid:

  forall map s r,

  map_valid map s ->

  reg_valid r s ->

  map_valid (add_letvar map r) s.

Proof.

  intros; red; intros.

  destruct H1 as [[id A]|B].

  simpl in A. apply H. left; exists id; auto.

  simpl in B. elim B; intro.

  subst r0; auto. apply H. right; auto.

Qed.



Lemma alloc_reg_valid:

  forall a s1 s2 map r i,

  map_valid map s1 ->

  alloc_reg map a s1 = OK r s2 i -> reg_valid r s2.

Proof.

  intros until r.  unfold alloc_reg.

  case a; eauto with rtlg.

Qed.

Hint Resolve alloc_reg_valid: rtlg.



Lemma alloc_reg_fresh_or_in_map:

  forall map a s r s' i,

  map_valid map s ->

  alloc_reg map a s = OK r s' i ->

  reg_in_map map r \/ reg_fresh r s.

Proof.

  intros until s'. unfold alloc_reg.

  destruct a; intros; try (right; eauto with rtlg; fail).

  left; eauto with rtlg.

  left; eauto with rtlg.

Qed.



Lemma alloc_regs_valid:

  forall al s1 s2 map rl i,

  map_valid map s1 ->

  alloc_regs map al s1 = OK rl s2 i ->

  regs_valid rl s2.

Proof.

  induction al; simpl; intros; monadInv H0.

  apply regs_valid_nil.

  apply regs_valid_cons. eauto with rtlg. eauto with rtlg.

Qed.

Hint Resolve alloc_regs_valid: rtlg.



Lemma alloc_regs_fresh_or_in_map:

  forall map al s rl s' i,

  map_valid map s ->

  alloc_regs map al s = OK rl s' i ->

  forall r, In r rl -> reg_in_map map r \/ reg_fresh r s.

Proof.

  induction al; simpl; intros; monadInv H0.

  elim H1.

  elim H1; intro.

  subst r.

  eapply alloc_reg_fresh_or_in_map; eauto.

  exploit IHal. 2: eauto. apply map_valid_incr with s; eauto with rtlg. eauto.

  intros [A|B]. auto. right; eauto with rtlg.

Qed.



Lemma alloc_optreg_valid:

  forall dest s1 s2 map r i,

  map_valid map s1 ->

  alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.

Proof.

  intros until r.  unfold alloc_reg.

  case dest; eauto with rtlg.

Qed.

Hint Resolve alloc_optreg_valid: rtlg.



Lemma alloc_optreg_fresh_or_in_map:

  forall map dest s r s' i,

  map_valid map s ->

  alloc_optreg map dest s = OK r s' i ->

  reg_in_map map r \/ reg_fresh r s.

Proof.

  intros until s'. unfold alloc_optreg. destruct dest; intros.

  left; eauto with rtlg.

  right; eauto with rtlg.

Qed.



Inductive target_reg_ok (map: mapping) (pr: list reg): expr -> reg -> Prop :=

  | target_reg_var:

      forall id r,

      map.(map_vars)!id = Some r ->

      target_reg_ok map pr (Evar id) r

  | target_reg_letvar:

      forall idx r,

      nth_error map.(map_letvars) idx = Some r ->

      target_reg_ok map pr (Eletvar idx) r

  | target_reg_other:

      forall a r,

      ~(reg_in_map map r) -> ~In r pr ->

      target_reg_ok map pr a r.



Inductive target_regs_ok (map: mapping) (pr: list reg): exprlist -> list reg -> Prop :=

  | target_regs_nil:

      target_regs_ok map pr Enil nil

  | target_regs_cons: forall a1 al r1 rl,

      target_reg_ok map pr a1 r1 ->

      target_regs_ok map (r1 :: pr) al rl ->

      target_regs_ok map pr (Econs a1 al) (r1 :: rl).



Lemma target_reg_ok_append:

  forall map pr a r,

  target_reg_ok map pr a r ->

  forall pr',

  (forall r', In r' pr' -> reg_in_map map r' \/ r' <> r) ->

  target_reg_ok map (pr' ++ pr) a r.

Proof.

  induction 1; intros.

  constructor; auto.

  constructor; auto.

  constructor; auto. red; intros.

  elim (in_app_or _ _ _ H2); intro.

  generalize (H1 _ H3). tauto. tauto.

Qed.



Lemma target_reg_ok_cons:

  forall map pr a r,

  target_reg_ok map pr a r ->

  forall r',

  reg_in_map map r' \/ r' <> r ->

  target_reg_ok map (r' :: pr) a r.

Proof.

  intros. change (r' :: pr) with ((r' :: nil) ++ pr).

  apply target_reg_ok_append; auto.

  intros r'' [A|B]. subst r''; auto. contradiction.

Qed.



Lemma new_reg_target_ok:

  forall map pr s1 a r s2 i,

  map_valid map s1 ->

  regs_valid pr s1 ->

  new_reg s1 = OK r s2 i ->

  target_reg_ok map pr a r.

Proof.

  intros. constructor.

  red; intro. apply valid_fresh_absurd with r s1.

  eauto with rtlg. eauto with rtlg.

  red; intro. apply valid_fresh_absurd with r s1.

  auto. eauto with rtlg.

Qed.



Lemma alloc_reg_target_ok:

  forall map pr s1 a r s2 i,

  map_valid map s1 ->

  regs_valid pr s1 ->

  alloc_reg map a s1 = OK r s2 i ->

  target_reg_ok map pr a r.

Proof.

  intros. unfold alloc_reg in H1. destruct a;

  try (eapply new_reg_target_ok; eauto; fail).

  

  generalize H1; unfold find_var. caseEq (map_vars map)!i0; intros.

  inv H3. constructor. auto. inv H3.

  

  generalize H1; unfold find_letvar. caseEq (nth_error (map_letvars map) n); intros.

  inv H3. constructor. auto. inv H3.

Qed.



Lemma alloc_regs_target_ok:

  forall map al pr s1 rl s2 i,

  map_valid map s1 ->

  regs_valid pr s1 ->

  alloc_regs map al s1 = OK rl s2 i ->

  target_regs_ok map pr al rl.

Proof.

  induction al; intros; monadInv H1.

  constructor.

  constructor.

  eapply alloc_reg_target_ok; eauto.

  apply IHal with s s2 INCR1; eauto with rtlg.

  apply regs_valid_cons; eauto with rtlg.

Qed.



Hint Resolve new_reg_target_ok alloc_reg_target_ok

             alloc_regs_target_ok: rtlg.



Inductive return_reg_ok: state -> mapping -> option reg -> Prop :=

  | return_reg_ok_none:

      forall s map,

      return_reg_ok s map None

  | return_reg_ok_some:

      forall s map r,

      ~(reg_in_map map r) -> reg_valid r s ->

      return_reg_ok s map (Some r).



Lemma return_reg_ok_incr:

  forall s map rret, return_reg_ok s map rret ->

  forall s', state_incr s s' -> return_reg_ok s' map rret.

Proof.

  induction 1; intros; econstructor; eauto with rtlg.

Qed.

Hint Resolve return_reg_ok_incr: rtlg.



Lemma new_reg_return_ok:

  forall s1 r s2 map sig i,

  new_reg s1 = OK r s2 i ->

  map_valid map s1 ->

  return_reg_ok s2 map (ret_reg sig r).

Proof.

  intros. unfold ret_reg. destruct (sig_res sig); constructor.

  eauto with rtlg. eauto with rtlg.

Qed.



Inductive tr_move (c: code):

       node -> reg -> node -> reg -> Prop :=

  | tr_move_0: forall n r,

      tr_move c n r n r

  | tr_move_1: forall ns rs nd rd,

      c!ns = Some (Iop Omove (rs :: nil) rd nd) ->

      tr_move c ns rs nd rd.



Inductive reg_map_ok: mapping -> reg -> option ident -> Prop :=

  | reg_map_ok_novar: forall map rd,

      ~reg_in_map map rd ->

      reg_map_ok map rd None

  | reg_map_ok_somevar: forall map rd id,

      map.(map_vars)!id = Some rd ->

      reg_map_ok map rd (Some id).



Hint Resolve reg_map_ok_novar: rtlg.



Inductive tr_expr (c: code):

       mapping -> list reg -> expr -> node -> node -> reg -> option ident -> Prop :=

  | tr_Evar: forall map pr id ns nd r rd dst,

      map.(map_vars)!id = Some r ->

      ((rd = r /\ dst = None) \/ (reg_map_ok map rd dst /\ ~In rd pr)) ->

      tr_move c ns r nd rd ->

      tr_expr c map pr (Evar id) ns nd rd dst

  | tr_Eop: forall map pr op al ns nd rd n1 rl dst,

      tr_exprlist c map pr al ns n1 rl ->

      c!n1 = Some (Iop op rl rd nd) ->

      reg_map_ok map rd dst -> ~In rd pr ->

      tr_expr c map pr (Eop op al) ns nd rd dst

  | tr_Eload: forall map pr chunk addr al ns nd rd n1 rl dst,

      tr_exprlist c map pr al ns n1 rl ->

      c!n1 = Some (Iload chunk addr rl rd nd) ->

      reg_map_ok map rd dst -> ~In rd pr ->

      tr_expr c map pr (Eload chunk addr al) ns nd rd dst

  | tr_Econdition: forall map pr a ifso ifnot ns nd rd ntrue nfalse dst,

      tr_condition c map pr a ns ntrue nfalse ->

      tr_expr c map pr ifso ntrue nd rd dst ->

      tr_expr c map pr ifnot nfalse nd rd dst ->

      tr_expr c map pr (Econdition a ifso ifnot) ns nd rd dst

  | tr_Elet: forall map pr b1 b2 ns nd rd n1 r dst,

      ~reg_in_map map r ->

      tr_expr c map pr b1 ns n1 r None ->

      tr_expr c (add_letvar map r) pr b2 n1 nd rd dst ->

      tr_expr c map pr (Elet b1 b2) ns nd rd dst

  | tr_Eletvar: forall map pr n ns nd rd r dst,

      List.nth_error map.(map_letvars) n = Some r ->

      ((rd = r /\ dst = None) \/ (reg_map_ok map rd dst /\ ~In rd pr)) ->

      tr_move c ns r nd rd ->

      tr_expr c map pr (Eletvar n) ns nd rd dst

  | tr_Ebuiltin: forall map pr ef al ns nd rd dst n1 rl,

      tr_exprlist c map pr al ns n1 rl ->

      c!n1 = Some (Ibuiltin ef rl rd nd) ->

      reg_map_ok map rd dst -> ~In rd pr ->

      tr_expr c map pr (Ebuiltin ef al) ns nd rd dst

  | tr_Eexternal: forall map pr id sg al ns nd rd dst n1 rl,

      tr_exprlist c map pr al ns n1 rl ->

      c!n1 = Some (Icall sg (inr _ id) rl rd nd) ->

      reg_map_ok map rd dst -> ~In rd pr ->

      tr_expr c map pr (Eexternal id sg al) ns nd rd dst



with tr_condition (c: code):

       mapping -> list reg -> condexpr -> node -> node -> node -> Prop :=

  | tr_CEcond: forall map pr cond bl ns ntrue nfalse n1 rl,

      tr_exprlist c map pr bl ns n1 rl ->

      c!n1 = Some (Icond cond rl ntrue nfalse) ->

      tr_condition c map pr (CEcond cond bl) ns ntrue nfalse

  | tr_CEcondition: forall map pr a1 a2 a3 ns ntrue nfalse n2 n3,

      tr_condition c map pr a1 ns n2 n3 ->

      tr_condition c map pr a2 n2 ntrue nfalse ->

      tr_condition c map pr a3 n3 ntrue nfalse ->

      tr_condition c map pr (CEcondition a1 a2 a3) ns ntrue nfalse

  | tr_CElet: forall map pr a b ns ntrue nfalse r n1,

      ~reg_in_map map r ->

      tr_expr c map pr a ns n1 r None ->

      tr_condition c (add_letvar map r) pr b n1 ntrue nfalse ->

      tr_condition c map pr (CElet a b) ns ntrue nfalse



with tr_exprlist (c: code):

       mapping -> list reg -> exprlist -> node -> node -> list reg -> Prop :=

  | tr_Enil: forall map pr n,

      tr_exprlist c map pr Enil n n nil

  | tr_Econs: forall map pr a1 al ns nd r1 rl n1,

      tr_expr c map pr a1 ns n1 r1 None ->

      tr_exprlist c map (r1 :: pr) al n1 nd rl ->

      tr_exprlist c map pr (Econs a1 al) ns nd (r1 :: rl).



Definition tr_jumptable (nexits: list node) (tbl: list nat) (ttbl: list node) : Prop :=

  forall v act,

  list_nth_z tbl v = Some act ->

  exists n, list_nth_z ttbl v = Some n /\ nth_error nexits act = Some n.



Inductive tr_switch

     (c: code) (map: mapping) (r: reg) (nexits: list node):

     comptree -> node -> Prop :=

  | tr_switch_action: forall act n,

      nth_error nexits act = Some n ->

      tr_switch c map r nexits (CTaction act) n

  | tr_switch_ifeq: forall key act t' n ncont nfound,

      tr_switch c map r nexits t' ncont ->

      nth_error nexits act = Some nfound ->

      c!n = Some(Icond (Ccompimm Ceq key) (r :: nil) nfound ncont) ->

      tr_switch c map r nexits (CTifeq key act t') n

  | tr_switch_iflt: forall key t1 t2 n n1 n2,

      tr_switch c map r nexits t1 n1 ->

      tr_switch c map r nexits t2 n2 ->

      c!n = Some(Icond (Ccompuimm Clt key) (r :: nil) n1 n2) ->

      tr_switch c map r nexits (CTiflt key t1 t2) n

  | tr_switch_jumptable: forall ofs sz tbl t n n1 n2 n3 rt ttbl,

      ~reg_in_map map rt -> rt <> r ->

      c!n = Some(Iop (if Int.eq ofs Int.zero then Omove else Oaddimm (Int.neg ofs))

                     (r ::nil) rt n1) ->

      c!n1 = Some(Icond (Ccompuimm Clt sz) (rt :: nil) n2 n3) ->

      c!n2 = Some(Ijumptable rt ttbl) ->

      tr_switch c map r nexits t n3 ->

      tr_jumptable nexits tbl ttbl ->

      tr_switch c map r nexits (CTjumptable ofs sz tbl t) n.



Inductive tr_stmt (c: code) (map: mapping):

     stmt -> node -> node -> list node -> labelmap -> node -> option reg -> Prop :=

  | tr_Sskip: forall ns nexits ngoto nret rret,

     tr_stmt c map Sskip ns ns nexits ngoto nret rret

  | tr_Sassign: forall id a ns nd nexits ngoto nret rret r,

     map.(map_vars)!id = Some r ->

     tr_expr c map nil a ns nd r (Some id) ->

     tr_stmt c map (Sassign id a) ns nd nexits ngoto nret rret

  | tr_Sstore: forall chunk addr al b ns nd nexits ngoto nret rret rd n1 rl n2,

     tr_exprlist c map nil al ns n1 rl ->

     tr_expr c map rl b n1 n2 rd None ->

     c!n2 = Some (Istore chunk addr rl rd nd) ->

     tr_stmt c map (Sstore chunk addr al b) ns nd nexits ngoto nret rret

  | tr_Scall: forall optid sig b cl ns nd nexits ngoto nret rret rd n1 rf n2 rargs,

     tr_expr c map nil b ns n1 rf None ->

     tr_exprlist c map (rf :: nil) cl n1 n2 rargs ->

     c!n2 = Some (Icall sig (inl _ rf) rargs rd nd) ->

     reg_map_ok map rd optid ->

     tr_stmt c map (Scall optid sig (inl _ b) cl) ns nd nexits ngoto nret rret

  | tr_Scall_imm: forall optid sig id cl ns nd nexits ngoto nret rret rd n2 rargs,

     tr_exprlist c map nil cl ns n2 rargs ->

     c!n2 = Some (Icall sig (inr _ id) rargs rd nd) ->

     reg_map_ok map rd optid ->

     tr_stmt c map (Scall optid sig (inr _ id) cl) ns nd nexits ngoto nret rret

  | tr_Stailcall: forall sig b cl ns nd nexits ngoto nret rret n1 rf n2 rargs,

     tr_expr c map nil b ns n1 rf None ->

     tr_exprlist c map (rf :: nil) cl n1 n2 rargs ->

     c!n2 = Some (Itailcall sig (inl _ rf) rargs) ->

     tr_stmt c map (Stailcall sig (inl _ b) cl) ns nd nexits ngoto nret rret

  | tr_Stailcall_imm: forall sig id cl ns nd nexits ngoto nret rret n2 rargs,

     tr_exprlist c map nil cl ns n2 rargs ->

     c!n2 = Some (Itailcall sig (inr _ id) rargs) ->

     tr_stmt c map (Stailcall sig (inr _ id) cl) ns nd nexits ngoto nret rret

  | tr_Sbuiltin: forall optid ef al ns nd nexits ngoto nret rret rd n1 rargs,

     tr_exprlist c map nil al ns n1 rargs ->

     c!n1 = Some (Ibuiltin ef rargs rd nd) ->

     reg_map_ok map rd optid ->

     tr_stmt c map (Sbuiltin optid ef al) ns nd nexits ngoto nret rret

  | tr_Sseq: forall s1 s2 ns nd nexits ngoto nret rret n,

     tr_stmt c map s2 n nd nexits ngoto nret rret ->

     tr_stmt c map s1 ns n nexits ngoto nret rret ->

     tr_stmt c map (Sseq s1 s2) ns nd nexits ngoto nret rret

  | tr_Sifthenelse: forall a strue sfalse ns nd nexits ngoto nret rret ntrue nfalse,

     tr_stmt c map strue ntrue nd nexits ngoto nret rret ->

     tr_stmt c map sfalse nfalse nd nexits ngoto nret rret ->

     tr_condition c map nil a ns ntrue nfalse ->

     tr_stmt c map (Sifthenelse a strue sfalse) ns nd nexits ngoto nret rret

  | tr_Sloop: forall sbody ns nd nexits ngoto nret rret nloop nend,

     tr_stmt c map sbody nloop nend nexits ngoto nret rret ->

     c!ns = Some(Inop nloop) ->

     c!nend = Some(Inop nloop) ->

     tr_stmt c map (Sloop sbody) ns nd nexits ngoto nret rret

  | tr_Sblock: forall sbody ns nd nexits ngoto nret rret,

     tr_stmt c map sbody ns nd (nd :: nexits) ngoto nret rret ->

     tr_stmt c map (Sblock sbody) ns nd nexits ngoto nret rret

  | tr_Sexit: forall n ns nd nexits ngoto nret rret,

     nth_error nexits n = Some ns ->

     tr_stmt c map (Sexit n) ns nd nexits ngoto nret rret

  | tr_Sswitch: forall a cases default ns nd nexits ngoto nret rret n r t,

     validate_switch default cases t = true ->

     tr_expr c map nil a ns n r None ->

     tr_switch c map r nexits t n ->

     tr_stmt c map (Sswitch a cases default) ns nd nexits ngoto nret rret

  | tr_Sreturn_none: forall nret nd nexits ngoto rret,

     tr_stmt c map (Sreturn None) nret nd nexits ngoto nret rret

  | tr_Sreturn_some: forall a ns nd nexits ngoto nret rret,

     tr_expr c map nil a ns nret rret None ->

     tr_stmt c map (Sreturn (Some a)) ns nd nexits ngoto nret (Some rret)

  | tr_Slabel: forall lbl s ns nd nexits ngoto nret rret n,

     ngoto!lbl = Some n ->

     c!n = Some (Inop ns) ->

     tr_stmt c map s ns nd nexits ngoto nret rret ->

     tr_stmt c map (Slabel lbl s) ns nd nexits ngoto nret rret

  | tr_Sgoto: forall lbl ns nd nexits ngoto nret rret,

     ngoto!lbl = Some ns ->

     tr_stmt c map (Sgoto lbl) ns nd nexits ngoto nret rret.



Inductive tr_function: CminorSel.function -> RTL.function -> Prop :=

  | tr_function_intro:

      forall f code rparams map1 s0 s1 i1 rvars map2 s2 i2 nentry ngoto nret rret orret,

      add_vars init_mapping f.(CminorSel.fn_params) s0 = OK (rparams, map1) s1 i1 ->

      add_vars map1 f.(CminorSel.fn_vars) s1 = OK (rvars, map2) s2 i2 ->

      orret = ret_reg f.(CminorSel.fn_sig) rret ->

      tr_stmt code map2 f.(CminorSel.fn_body) nentry nret nil ngoto nret orret ->

      code!nret = Some(Ireturn orret) ->

      tr_function f (RTL.mkfunction

                       f.(CminorSel.fn_sig)

                       rparams

                       f.(CminorSel.fn_stackspace)

                       code

                       nentry).



Lemma tr_move_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall ns rs nd rd,

  tr_move s1.(st_code) ns rs nd rd ->

  tr_move s2.(st_code) ns rs nd rd.

Proof.

  induction 2; econstructor; eauto with rtlg.

Qed.



Lemma tr_expr_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall map pr a ns nd rd dst,

  tr_expr s1.(st_code) map pr a ns nd rd dst ->

  tr_expr s2.(st_code) map pr a ns nd rd dst

with tr_condition_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall map pr a ns ntrue nfalse,

  tr_condition s1.(st_code) map pr a ns ntrue nfalse ->

  tr_condition s2.(st_code) map pr a ns ntrue nfalse

with tr_exprlist_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall map pr al ns nd rl,

  tr_exprlist s1.(st_code) map pr al ns nd rl ->

  tr_exprlist s2.(st_code) map pr al ns nd rl.

Proof.

  intros s1 s2 EXT.

  pose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).

  induction 1; econstructor; eauto.

  eapply tr_move_incr; eauto.

  eapply tr_move_incr; eauto.

  intros s1 s2 EXT.

  pose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).

  induction 1; econstructor; eauto.

  intros s1 s2 EXT.

  pose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).

  induction 1; econstructor; eauto.

Qed.



Lemma add_move_charact:

  forall s ns rs nd rd s' i,

  add_move rs rd nd s = OK ns s' i ->

  tr_move s'.(st_code) ns rs nd rd.

Proof.

  intros. unfold add_move in H. destruct (Reg.eq rs rd).

  inv H. constructor.

  constructor. eauto with rtlg.

Qed.



Lemma transl_expr_charact:

  forall a map rd nd s ns s' pr INCR

     (TR: transl_expr map a rd nd s = OK ns s' INCR)

     (WF: map_valid map s)

     (OK: target_reg_ok map pr a rd)

     (VALID: regs_valid pr s)

     (VALID2: reg_valid rd s),

   tr_expr s'.(st_code) map pr a ns nd rd None



with transl_exprlist_charact:

  forall al map rl nd s ns s' pr INCR

     (TR: transl_exprlist map al rl nd s = OK ns s' INCR)

     (WF: map_valid map s)

     (OK: target_regs_ok map pr al rl)

     (VALID1: regs_valid pr s)

     (VALID2: regs_valid rl s),

   tr_exprlist s'.(st_code) map pr al ns nd rl



with transl_condexpr_charact:

  forall a map ntrue nfalse s ns s' pr INCR

     (TR: transl_condexpr map a ntrue nfalse s = OK ns s' INCR)

     (WF: map_valid map s)

     (VALID: regs_valid pr s),

   tr_condition s'.(st_code) map pr a ns ntrue nfalse.



Proof.

  induction a; intros; try (monadInv TR); saturateTrans.

  

  generalize EQ; unfold find_var. caseEq (map_vars map)!i; intros; inv EQ1.

  econstructor; eauto.

  inv OK. left; split; congruence. right; eauto with rtlg.

  eapply add_move_charact; eauto.

  

  inv OK.

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  inv OK.

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  inv OK.

  econstructor.

  eauto with rtlg.

  apply tr_expr_incr with s1; auto.

  eapply transl_expr_charact; eauto 2 with rtlg. constructor; auto.

  apply tr_expr_incr with s0; auto.

  eapply transl_expr_charact; eauto 2 with rtlg. constructor; auto.

  

  inv OK.

  econstructor. eapply new_reg_not_in_map; eauto with rtlg.

  eapply transl_expr_charact; eauto 3 with rtlg.

  apply tr_expr_incr with s1; auto.

  eapply transl_expr_charact. eauto.

  apply add_letvar_valid; eauto with rtlg.

  constructor; auto.

  red; unfold reg_in_map. simpl. intros [[id A] | [B | C]].

  elim H. left; exists id; auto.

  subst x. apply valid_fresh_absurd with rd s. auto. eauto with rtlg.

  elim H. right; auto.

  eauto with rtlg. eauto with rtlg.

  

  generalize EQ; unfold find_letvar. caseEq (nth_error (map_letvars map) n); intros; inv EQ0.

  monadInv EQ1.

  econstructor; eauto with rtlg.

  inv OK. left; split; congruence. right; eauto with rtlg.

  eapply add_move_charact; eauto.

  monadInv EQ1.

  

  inv OK.

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  inv OK.

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.



  induction al; intros; try (monadInv TR); saturateTrans.



  destruct rl; inv TR. constructor.

  

  destruct rl; simpl in TR; monadInv TR. inv OK.

  econstructor.

  eapply transl_expr_charact; eauto with rtlg.

  generalize (VALID2 r (in_eq _ _)). eauto with rtlg.

  apply tr_exprlist_incr with s0; auto.

  eapply transl_exprlist_charact; eauto with rtlg.

  apply regs_valid_cons. apply VALID2. auto with coqlib. auto.

  red; intros; apply VALID2; auto with coqlib.



  induction a; intros; try (monadInv TR); saturateTrans.



  econstructor; eauto with rtlg. eapply transl_exprlist_charact; eauto with rtlg.

  

  econstructor; eauto with rtlg.

  apply tr_condition_incr with s1; eauto with rtlg.

  apply tr_condition_incr with s0; eauto with rtlg.

  

  econstructor; eauto with rtlg.

  eapply transl_expr_charact; eauto with rtlg.

  apply tr_condition_incr with s1; eauto with rtlg.

  eapply transl_condexpr_charact; eauto with rtlg.

  apply add_letvar_valid; eauto with rtlg.

Qed.



Lemma transl_expr_assign_charact:

  forall id a map rd nd s ns s' INCR

     (TR: transl_expr map a rd nd s = OK ns s' INCR)

     (WF: map_valid map s)

     (OK: reg_map_ok map rd (Some id)),

   tr_expr s'.(st_code) map nil a ns nd rd (Some id).

Proof.

  induction a; intros; monadInv TR; saturateTrans.

  

  generalize EQ; unfold find_var. caseEq (map_vars map)!i; intros; inv EQ1.

  econstructor; eauto.

  eapply add_move_charact; eauto.

  

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  econstructor; eauto with rtlg.

  eapply transl_condexpr_charact; eauto with rtlg.

  apply tr_expr_incr with s1; auto.

  eapply IHa1; eauto 2 with rtlg.

  apply tr_expr_incr with s0; auto.

  eapply IHa2; eauto 2 with rtlg.

  

  econstructor. eapply new_reg_not_in_map; eauto with rtlg.

  eapply transl_expr_charact; eauto 3 with rtlg.

  apply tr_expr_incr with s1; auto.

  eapply IHa2; eauto.

  apply add_letvar_valid; eauto with rtlg.

  inv OK. constructor. auto.

  

  generalize EQ; unfold find_letvar. caseEq (nth_error (map_letvars map) n); intros; inv EQ0.

  monadInv EQ1.

  econstructor; eauto with rtlg.

  eapply add_move_charact; eauto.

  monadInv EQ1.

  

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

  

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto with rtlg.

Qed.



Lemma alloc_optreg_map_ok:

  forall map optid s1 r s2 i,

  map_valid map s1 ->

  alloc_optreg map optid s1 = OK r s2 i ->

  reg_map_ok map r optid.

Proof.

  unfold alloc_optreg; intros. destruct optid.

  constructor. unfold find_var in H0. destruct (map_vars map)!i0; monadInv H0. auto.

  constructor. eapply new_reg_not_in_map; eauto.

Qed.



Lemma tr_switch_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall map r nexits t ns,

  tr_switch s1.(st_code) map r nexits t ns ->

  tr_switch s2.(st_code) map r nexits t ns.

Proof.

  induction 2; econstructor; eauto with rtlg.

Qed.



Lemma tr_stmt_incr:

  forall s1 s2, state_incr s1 s2 ->

  forall map s ns nd nexits ngoto nret rret,

  tr_stmt s1.(st_code) map s ns nd nexits ngoto nret rret ->

  tr_stmt s2.(st_code) map s ns nd nexits ngoto nret rret.

Proof.

  intros s1 s2 EXT.

  generalize tr_expr_incr tr_condition_incr tr_exprlist_incr; intros I1 I2 I3.

  pose (AT := fun pc i => instr_at_incr s1 s2 pc i EXT).

  induction 1; try (econstructor; eauto; fail).

  econstructor; eauto. eapply tr_switch_incr; eauto.

Qed.



Lemma transl_exit_charact:

  forall nexits n s ne s' incr,

  transl_exit nexits n s = OK ne s' incr ->

  nth_error nexits n = Some ne /\ s' = s.

Proof.

  intros until incr. unfold transl_exit.

  destruct (nth_error nexits n); intro; monadInv H. auto.

Qed.



Lemma transl_jumptable_charact:

  forall nexits tbl s nl s' incr,

  transl_jumptable nexits tbl s = OK nl s' incr ->

  tr_jumptable nexits tbl nl /\ s' = s.

Proof.

  induction tbl; intros.

  monadInv H. split. red. simpl. intros. discriminate. auto.

  monadInv H. exploit transl_exit_charact; eauto. intros [A B].

  exploit IHtbl; eauto. intros [C D].

  split. red. simpl. intros. destruct (zeq v 0). inv H. exists x; auto. auto.

  congruence.

Qed.



Lemma transl_switch_charact:

  forall map r nexits t s ns s' incr,

  map_valid map s -> reg_valid r s ->

  transl_switch r nexits t s = OK ns s' incr ->

  tr_switch s'.(st_code) map r nexits t ns.

Proof.

  induction t; simpl; intros; saturateTrans.



  exploit transl_exit_charact; eauto. intros [A B].

  econstructor; eauto.



  monadInv H1.

  exploit transl_exit_charact; eauto. intros [A B]. subst s1.

  econstructor; eauto 2 with rtlg.

  apply tr_switch_incr with s0; eauto with rtlg.



  monadInv H1.

  econstructor; eauto 2 with rtlg.

  apply tr_switch_incr with s1; eauto with rtlg.

  apply tr_switch_incr with s0; eauto with rtlg.



  monadInv H1.

  exploit transl_jumptable_charact; eauto. intros [A B]. subst s1.

  econstructor. eauto with rtlg.

  apply sym_not_equal. apply valid_fresh_different with s; eauto with rtlg.

  eauto with rtlg. eauto with rtlg. eauto with rtlg.

  apply tr_switch_incr with s3. eauto with rtlg.

  eapply IHt with (s := s2); eauto with rtlg.

  auto.

Qed.



Lemma transl_stmt_charact:

  forall map stmt nd nexits ngoto nret rret s ns s' INCR

    (TR: transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR)

    (WF: map_valid map s)

    (OK: return_reg_ok s map rret),

  tr_stmt s'.(st_code) map stmt ns nd nexits ngoto nret rret.

Proof.

  induction stmt; intros; simpl in TR; try (monadInv TR); saturateTrans.

  

  constructor.

  

  revert EQ. unfold find_var. case_eq (map_vars map)!i; intros; monadInv EQ.

  eapply tr_Sassign; eauto.

  eapply transl_expr_assign_charact; eauto with rtlg.

  constructor. auto.

  

  econstructor; eauto with rtlg.

  eapply transl_exprlist_charact; eauto 3 with rtlg.

  apply tr_expr_incr with s3; auto.

  eapply transl_expr_charact; eauto 4 with rtlg.

  

  destruct s0 as [b | id]; monadInv TR; saturateTrans.

  

  econstructor; eauto 4 with rtlg.

  eapply transl_expr_charact; eauto 3 with rtlg.

  apply tr_exprlist_incr with s5. auto.

  eapply transl_exprlist_charact; eauto 3 with rtlg.

  eapply alloc_regs_target_ok with (s1 := s0); eauto 3 with rtlg.

  apply regs_valid_cons; eauto 3 with rtlg.

  apply regs_valid_incr with s0; eauto 3 with rtlg.

  apply regs_valid_cons; eauto 3 with rtlg.

  apply regs_valid_incr with s2; eauto 3 with rtlg.

  eapply alloc_optreg_map_ok with (s1 := s2); eauto 3 with rtlg.

  

  econstructor; eauto 4 with rtlg.

  eapply transl_exprlist_charact; eauto 3 with rtlg.

  eapply alloc_optreg_map_ok with (s1 := s0); eauto 3 with rtlg.

  

  destruct s0 as [b | id]; monadInv TR; saturateTrans.

  

  assert (RV: regs_valid (x :: nil) s0).

    apply regs_valid_cons; eauto 3 with rtlg.

  econstructor; eauto 3 with rtlg.

  eapply transl_expr_charact; eauto 3 with rtlg.

  apply tr_exprlist_incr with s4; auto.

  eapply transl_exprlist_charact; eauto 4 with rtlg.

  

  econstructor; eauto 3 with rtlg.

  eapply transl_exprlist_charact; eauto 4 with rtlg.

  

  econstructor; eauto 4 with rtlg.

  eapply transl_exprlist_charact; eauto 3 with rtlg.

  eapply alloc_optreg_map_ok with (s1 := s0); eauto with rtlg.

  

  econstructor.

  apply tr_stmt_incr with s0; auto.

  eapply IHstmt2; eauto with rtlg.

  eapply IHstmt1; eauto with rtlg.

  

  destruct (more_likely c stmt1 stmt2); monadInv TR.

  econstructor.

  apply tr_stmt_incr with s1; auto.

  eapply IHstmt1; eauto with rtlg.

  apply tr_stmt_incr with s0; auto.

  eapply IHstmt2; eauto with rtlg.

  eapply transl_condexpr_charact; eauto with rtlg.

  econstructor.

  apply tr_stmt_incr with s0; auto.

  eapply IHstmt1; eauto with rtlg.

  apply tr_stmt_incr with s1; auto.

  eapply IHstmt2; eauto with rtlg.

  eapply transl_condexpr_charact; eauto with rtlg.

  

  econstructor.

  apply tr_stmt_incr with s1; auto.

  eapply IHstmt; eauto with rtlg.

  eauto with rtlg. eauto with rtlg.

  

  econstructor.

  eapply IHstmt; eauto with rtlg.

  

  exploit transl_exit_charact; eauto. intros [A B].

  econstructor. eauto.

  

  generalize TR; clear TR.

  set (t := compile_switch n l).

  caseEq (validate_switch n l t); intro VALID; intros.

  monadInv TR.

  econstructor; eauto with rtlg.

  eapply transl_expr_charact; eauto with rtlg.

  apply tr_switch_incr with s1; auto with rtlg.

  eapply transl_switch_charact with (s := s0); eauto with rtlg.

  monadInv TR.

  

  destruct o.

  destruct rret; inv TR. inv OK.

  econstructor; eauto with rtlg.

  eapply transl_expr_charact; eauto with rtlg.

  constructor. auto. simpl; tauto.

  monadInv TR. constructor.

  

  generalize EQ0; clear EQ0. case_eq (ngoto!l); intros; monadInv EQ0.

  generalize EQ1; clear EQ1. unfold handle_error.

  case_eq (update_instr n (Inop ns) s0); intros; inv EQ1.

  econstructor. eauto. eauto with rtlg.

  eapply tr_stmt_incr with s0; eauto with rtlg.

  

  generalize TR; clear TR. case_eq (ngoto!l); intros; monadInv TR.

  econstructor. auto.

Qed.



Lemma transl_function_charact:

  forall f tf,

  transl_function f = Errors.OK tf ->

  tr_function f tf.

Proof.

  intros until tf. unfold transl_function.

  caseEq (reserve_labels (fn_body f) (PTree.empty node, init_state)).

  intros ngoto s0 RESERVE.

  caseEq (transl_fun f ngoto s0). congruence.

  intros [nentry rparams] sfinal INCR TR E. inv E.

  monadInv TR.

  exploit add_vars_valid. eexact EQ. apply init_mapping_valid.

  intros [A B].

  exploit add_vars_valid. eexact EQ1. auto.

  intros [C D].

  eapply tr_function_intro; eauto with rtlg.

  eapply transl_stmt_charact; eauto with rtlg.

  unfold ret_reg. destruct (sig_res (CminorSel.fn_sig f)).

  constructor. eauto with rtlg. eauto with rtlg.

  constructor.

Qed.

