Require Import VST.concurrency.common.core_semantics.
(* VST.concurrency.common.core_semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Smallstep.

Require Export VST.sepcomp.semantics.

Inductive step2corestep (sem:part_semantics):(state sem) -> mem -> (state sem) -> mem -> Prop :=
  coreify: forall s1 m1 t s2,
    step sem (set_mem s1 m1) t s2 ->
    Smallstep.at_external sem (set_mem s1 m1) = None ->
    step2corestep sem s1 m1 s2 (get_mem s2).
    
Program Definition sem2coresem (sem:part_semantics) corestep_not_halted : CoreSemantics _ _:=
  {|
    initial_core := fun _ m c m' f args => start_stack sem m c f args /\ get_mem c = m'
    ; at_external := fun s m => Smallstep.at_external sem (set_mem s m) *)

Require Import VST.concurrency.common.semantics.
(* VST.concurrency.common.semantics:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.event_semantics.

Require Import VST.concurrency.common.machine_semantics.

Class Semantics:=
  {
        semG: Type;
    semC: Type;
    semSem: @EvSem semC;
    
    the_ge: semG
  }.

Class Resources:=
  {
    res: Type;
    lock_info : Type
  }.

Module Type SEMANTICS.
  Parameter G : Type.
  Parameter C : Type.
  Parameter SEM : @EvSem C.
End SEMANTICS. *)

Require Import VST.sepcomp.event_semantics.
(* VST.sepcomp.event_semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Inductive mem_event :=
  Write : forall (b : block) (ofs : Z) (bytes : list memval), mem_event
| Read : forall (b:block) (ofs n:Z) (bytes: list memval), mem_event
| Alloc: forall (b:block)(lo hi:Z), mem_event

| Free: forall (l: list (block * Z * Z)), mem_event.

Fixpoint ev_elim (m:mem) (T: list mem_event) (m':mem):Prop :=
  match T with
   nil => m'=m
 | (Read b ofs n bytes :: R) => Mem.loadbytes m b ofs n = Some bytes /\ ev_elim m R m'
 | (Write b ofs bytes :: R) => exists m'', Mem.storebytes m b ofs bytes = Some m'' /\ ev_elim m'' R m'
 | (Alloc b lo hi :: R) => exists m'', Mem.alloc m lo hi = (m'',b) /\ ev_elim m'' R m'
 | (Free l :: R) => exists m'', Mem.free_list m l = Some m'' /\ ev_elim m'' R m'
  end.

Definition pmax (popt qopt: option permission): option permission :=
  match popt, qopt with
    _, None => popt
  | None, _ => qopt
  | Some p, Some q => if Mem.perm_order_dec p q then Some p else Some q
  end.

Lemma po_pmax_I p q1 q2:
  Mem.perm_order'' p q1 -> Mem.perm_order'' p q2 -> Mem.perm_order'' p (pmax q1 q2).

Fixpoint cur_perm (l: block * Z) (T: list mem_event): option permission :=
  match T with
      nil => None
    | (mu :: R) =>
          let popt := cur_perm l R in
          match mu, l with
            | (Read b ofs n bytes), (b',ofs') =>
                 pmax (if eq_block b b' && zle ofs ofs' && zlt ofs' (ofs+n)
                       then Some Readable else None) popt
            | (Write b ofs bytes), (b',ofs') =>
                 pmax (if eq_block b b' && zle ofs ofs' && zlt ofs' (ofs+ Zlength bytes)
                       then Some Writable else None) popt
            | (Alloc b lo hi), (b',ofs') =>  
                 if eq_block b b' then None else popt
            | (Free l), (b',ofs') =>
                 List.fold_right (fun tr qopt => match tr with (b,lo,hi) =>
                                                   if eq_block b b' && zle lo ofs' && zlt ofs' hi
                                                   then Some Freeable else qopt
                                                end)
                                 popt l
          end
  end.

Lemma po_None popt: Mem.perm_order'' popt None.

Lemma ev_perm b ofs: forall T m m', ev_elim m T m' ->
      Mem.perm_order'' ((Mem.mem_access m) !! b ofs Cur) (cur_perm (b,ofs) T).

Lemma ev_elim_app: forall T1 m1 m2 (EV1:ev_elim m1 T1 m2) T2 m3  (EV2: ev_elim m2 T2 m3), ev_elim m1 (T1++T2) m3.

Lemma ev_elim_split: forall T1 T2 m1 m3 (EV1:ev_elim m1 (T1++T2) m3),
      exists m2, ev_elim m1 T1 m2 /\ ev_elim m2 T2 m3.

Record EvSem {C} :=
  { 
    msem :> @MemSem C

  ; ev_step: C -> mem -> list mem_event -> C -> mem -> Prop

  ; ev_step_ax1: forall c m T c' m',
       ev_step c m T c' m' ->
            corestep msem c m c' m'
  ; ev_step_ax2: forall c m c' m',
       corestep msem c m c' m' ->
       exists T, ev_step c m T c' m'
  ; ev_step_fun: forall c m T' c' m' T'' c'' m'',
       ev_step c m T' c' m' -> ev_step c m T'' c'' m'' -> T'=T''

  ; ev_step_elim: forall c m T c' m' (STEP: ev_step c m T c' m'),
       ev_elim m T m' 
  }.

Lemma Ev_sem_cur_perm {C} (R: @EvSem C) c m T c' m' b ofs (D: ev_step R c m T c' m'):
      Mem.perm_order'' ((Mem.mem_access m) !! b ofs Cur) (cur_perm (b,ofs) T).

Require Import List.
Import ListNotations.

Definition in_free_list (b : block) ofs xs :=
  exists x, List.In x xs /\
       let '(b', lo, hi) := x in
       b = b' /\
       (lo <= ofs < hi)%Z.

Fixpoint in_free_list_trace (b : block) ofs es :=
  match es with
  | Free l :: es =>
    in_free_list b ofs l \/ in_free_list_trace b ofs es
  | _ :: es =>
    in_free_list_trace b ofs es
  | nil =>
    False
  end.

Lemma EFLT_char es: forall b ofs, in_free_list_trace b ofs es <->
                             exists l lo hi, In (Free l) es /\ In ((b, lo), hi) l /\ lo <= ofs < hi.

Lemma freelist_mem_access_1 b ofs p: forall l m (ACC:(Mem.mem_access m) !! b ofs Cur = Some p)

Lemma freelist_access_2 b ofs: forall l  (FL: in_free_list b ofs l)
                                 m m' (FR : Mem.free_list m l = Some m'),

Lemma freelist_access_3 b ofs: forall l m (ACC: (Mem.mem_access m) !! b ofs Cur = None)

Lemma ev_elim_accessNone b ofs: forall ev m' m'' (EV:ev_elim m'' ev m')
                                  (ACC: (Mem.mem_access m'') !! b ofs Cur = None)

Lemma ev_elim_valid_block: forall ev m m' (EV: ev_elim m ev m') b
                             (VB : Mem.valid_block m b), Mem.valid_block m' b.

Lemma ev_elim_free_1 b ofs:
  forall ev m m',
    ev_elim m ev m' ->
    in_free_list_trace b ofs ev ->
    (Mem.perm m b ofs Cur Freeable \/

Lemma perm_order_pp_refl p: Mem.perm_order'' p p.

Lemma in_free_list_dec b ofs xs: {in_free_list b ofs xs} + {~in_free_list b ofs xs}.

Lemma in_free_list_trace_dec b ofs: forall es, {in_free_list_trace b ofs es} + {~in_free_list_trace b ofs es}.

Lemma freelist_access_1 b ofs: forall l,
    ~ in_free_list b ofs l ->
    forall m m' : mem, Mem.free_list m l = Some m' -> (Mem.mem_access m') !! b ofs Cur = (Mem.mem_access m) !! b ofs Cur.

Lemma ev_elim_free_2 b ofs:
  forall ev m m' (EV: ev_elim m ev m')
    (T: ~ in_free_list_trace b ofs ev),
    Mem.perm_order'' ((Mem.mem_access m') !! b ofs Cur)

Lemma free_list_cases:
  forall l m m' b ofs
    (Hfree: Mem.free_list m l = Some m'), *)



Inductive state_sum (Cs Ct:Type): Type :=

| SState (c:Cs)

| TState (c:Ct).



Definition state_sum_options {Cs Ct:Type} (cso: option Cs): option (state_sum Cs Ct) :=

  match cso with

  | Some cs => Some (SState _ _ cs)

  | _ => None

  end.

Definition state_sum_optiont {Cs Ct:Type} (cto: option Ct): option (state_sum Cs Ct) :=

  match cto with

  | Some ct => Some (TState _ _ ct)

  | _ => None

  end.



Definition state_sum_optionms {Cs Ct M:Type} (cso: option (Cs * option M)): option (state_sum Cs Ct * option M) :=

  match cso with

  | Some (cs, m) => Some (SState _ _ cs, m)

  | _ => None

  end.

Definition state_sum_optionmt {Cs Ct M:Type} (cto: option (Ct * option M)): option (state_sum Cs Ct * option M) :=

  match cto with

  | Some (ct, m) => Some (TState _ _ ct, m)

  | _ => None

  end.



Definition lt_op (n: nat) (no:option nat): Prop :=

  match no with

    | None => False

    | Some n' => n < n' 

  end.



Definition initial_core_sum (no:option nat) (Cs Ct:Type) (M: Type)

           (sinitial_core : nat -> M -> Cs -> M -> Values.val -> list Values.val -> Prop)

           (tinitial_core : nat -> M -> Ct -> M -> Values.val -> list Values.val -> Prop):

  nat -> M -> state_sum Cs Ct -> M -> Values.val -> list Values.val -> Prop :=

  fun (n:nat) m c m' val vals =>

    match c with

    | SState c => lt_op n no /\ sinitial_core n m c m' val vals

    | TState c => ~lt_op n no /\ tinitial_core n m c m' val vals

    end.



Definition sum_func {Cs Ct X:Type} (fs:Cs -> X) (ft:Ct-> X) s:=

  match s with

  | SState c => (fs c)

  | TState c => (ft c)

  end.



Definition sum_func_option {Cs Ct Cs' Ct':Type} 

           (fs: Cs -> option Cs') (ft: Ct-> option Ct') s:=

  match s with

  | SState c => state_sum_options (fs c) 

  | TState c => state_sum_optiont (ft c) 

  end.



Definition at_external_sum (Cs Ct M: Type)

           (sat_external: Cs -> M -> option (AST.external_function * list Values.val))

           (tat_external: Ct -> M -> option (AST.external_function * list Values.val))

           :=

  sum_func sat_external tat_external.



Definition after_external_sum (Cs Ct M: Type)

           (safter_external: option Values.val -> Cs -> M -> option Cs)

           (tafter_external: option Values.val -> Ct -> M -> option Ct)

           :=

  fun vals c m => sum_func_option (fun c => safter_external vals c m)

                                  (fun c => tafter_external vals c m) c.



Definition halted_sum Cs Ct

           (shalted: Cs -> Integers.Int.int -> Prop)

           (thalted: Ct -> Integers.Int.int -> Prop) :=

  sum_func shalted thalted.



Inductive corestep_sum {M Cs Ct}

          (scorestep: Cs -> M -> Cs -> M -> Prop)

          (tcorestep: Ct -> M -> Ct -> M -> Prop):

  state_sum Cs Ct -> M -> state_sum Cs Ct -> M -> Prop:=

| SCorestep: forall s m s' m',

    scorestep s m s' m' ->

    corestep_sum scorestep tcorestep (SState _ _ s) m (SState _ _ s') m'

| TCorestep: forall s m s' m',

    tcorestep s m s' m' ->

    corestep_sum scorestep tcorestep (TState _ _ s) m (TState _ _ s') m'.



Lemma corestep_not_at_external_sum:

  forall M Cs Ct

    {scorestep: Cs -> M -> Cs -> M -> Prop} 

    {sat_external: Cs -> M -> option (AST.external_function * list Values.val)}

    (scorestep_not_at_external: forall (m : M) (q : Cs) (m' : M) (q' : Cs),

        scorestep q m q' m' -> sat_external q m = None)

    {tcorestep: Ct -> M -> Ct -> M -> Prop}

    {tat_external: Ct -> M -> option (AST.external_function * list Values.val)}

    (tcorestep_not_at_external: forall (m : M) (q : Ct) (m' : M) (q' : Ct),

        tcorestep q m q' m' -> tat_external q m = None),

  forall (m : M) (q : state_sum Cs Ct) (m' : M) (q' : state_sum Cs Ct),

    corestep_sum scorestep tcorestep q m q' m' ->

    at_external_sum _ _ _ sat_external tat_external q m = None.

Proof.

  intros.

  inversion H; subst; simpl in *.

  - eapply scorestep_not_at_external; eauto. 

  - eapply tcorestep_not_at_external; eauto.

Qed.



Lemma corestep_not_halted_sum:

  forall  M Cs Ct

    (scorestep: Cs -> M -> Cs -> M -> Prop) 

    (shalted : Cs -> Integers.Int.int -> Prop)

    (scorestep_not_halted: forall (m : M) (q : Cs) (m' : M) (q' : Cs) n,

        scorestep q m q' m' -> ~ shalted q n)

    (tcorestep: Ct -> M -> Ct -> M -> Prop)

    (thalted : Ct -> Integers.Int.int -> Prop)

    (tcorestep_not_halted: forall (m : M) (q : Ct) (m' : M) (q' : Ct) n,

        tcorestep q m q' m' -> ~ thalted q n),

  forall (m : M) (q : state_sum Cs Ct) (m' : M) (q' : state_sum Cs Ct) n,

    corestep_sum scorestep tcorestep q m q' m' ->

    ~ halted_sum _ _ shalted thalted q n.

Proof.

  intros.

  inversion H; subst; simpl; eauto.

Qed.



Program Definition CoreSemanticsSum hb M Cs Ct

        (CSs: CoreSemantics Cs M )

        (CSt: CoreSemantics Ct M ): CoreSemantics (state_sum Cs Ct) M:=

  Build_CoreSemantics _ _

    (initial_core_sum hb _ _ _ (initial_core CSs) (initial_core CSt))

    (at_external_sum _ _ _ (at_external CSs) (at_external CSt))

    (after_external_sum _ _ _ (after_external CSs) (after_external CSt))

    (halted_sum _ _  (halted CSs) (halted CSt))

    (corestep_sum (corestep CSs) (corestep CSt)) 

    _

    _.

Next Obligation.

  eapply corestep_not_halted_sum; try eapply H.

  - eapply CSs.

  - eapply CSt.

Qed.

Next Obligation.

  intros; eapply corestep_not_at_external_sum; eauto; first [apply CSs|apply CSt].

Qed.



Program Definition MemSemanticsSum (hb:option nat) Cs Ct

        (CSs: MemSem Cs )

        (CSt: MemSem Ct ): MemSem (state_sum Cs Ct):=

  Build_MemSem _ (CoreSemanticsSum hb Memory.Mem.mem Cs Ct CSs CSt) _.

Next Obligation.

  intros.

  inversion CS; subst.

  - eapply CSs; eassumption.

  - eapply CSt; eassumption.

Defined.



Inductive ev_step_sum {Cs Ct:Type}

          (ESs: Cs -> Memory.Mem.mem -> list mem_event -> Cs -> Memory.Mem.mem -> Prop)

          (ESt: Ct -> Memory.Mem.mem -> list mem_event -> Ct -> Memory.Mem.mem -> Prop):

  (state_sum Cs Ct) -> Memory.Mem.mem -> list mem_event -> (state_sum Cs Ct) -> Memory.Mem.mem -> Prop

  :=

| SEvstep: forall s m t s' m',

    ESs s m t s' m' ->

    ev_step_sum ESs ESt (SState _ _ s) m t (SState _ _ s') m'

| TEvstep: forall s m t s' m',

    ESt s m t s' m' ->

    ev_step_sum ESs ESt (TState _ _ s) m t (TState _ _ s') m'.

  

Program Definition EvSemanticsSum (hb:option nat) Cs Ct

        (CSs: @EvSem Cs )

        (CSt: @EvSem Ct ): @EvSem (state_sum Cs Ct):=

  Build_EvSem _ (MemSemanticsSum hb Cs Ct CSs CSt) (ev_step_sum (ev_step CSs) (ev_step CSt)) _ _ _ _.

Next Obligation.

  intros.

  inversion H; subst.

  - constructor; eapply CSs; eauto.

  - constructor; eapply CSt; eauto.

Defined.

Next Obligation.

  intros.

  inversion H; subst.

  - eapply CSs in H0; destruct H0 as [T ?]. 

    exists T; constructor; eauto.

  - eapply CSt in H0; destruct H0 as [T ?]. 

    exists T; constructor; eauto.

Defined.

Next Obligation.

  intros.

  inversion H; subst;

  inversion H0; subst.

  - eapply CSs; eauto.

  - eapply CSt; eauto.

Defined.

Next Obligation.

  intros.

  inversion STEP; subst.

  -  eapply (ev_step_elim CSs) in H. 
 trivial.

  -  eapply (ev_step_elim CSt) in H. 
 trivial.

Defined.



Definition CoreSem_Sum (hb:option nat) (Sems Semt: Semantics): Semantics:=

  Build_Semantics _ _

                  (EvSemanticsSum hb _ _ (@semSem Sems) (@semSem Semt))

                  (@the_ge Sems, @the_ge Semt) .



