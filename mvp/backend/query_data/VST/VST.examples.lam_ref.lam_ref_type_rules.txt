
Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)
Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)
Require Import lam_ref_mach_lemmas.
(* lam_ref_mach_lemmas:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Lemma isVal_val2exp : forall v, isValue (val_to_exp v).

Lemma closed_dec : forall e n,
  { closed' n e} + { ~closed' n e}.

Lemma value_dec : forall e,
  { isValue e } + { ~isValue e }.

Ltac show_stopped :=
  let m' := fresh "m'" in
  let e' := fresh "e'" in
  let H := fresh "H" in
  right; intros [m' [e' H]]; inv H.

Lemma stopped_dec : forall e m,
  { st | step (m,e) st} + { stopped m e }.

Lemma closed'_S : forall n e,
  closed' n e ->
  closed' (S n) e.

Lemma closed'_le : forall m n,
  m <= n ->
  forall e,
  closed' m e ->
  closed' n e.

Lemma closed'_subst: forall m e x v,
  closed' m e ->
  subst (x + m) v e = e.

Lemma closed_closed_subst: forall x v e,
  closed e ->
  closed (subst x v e).

Lemma closed_Lam_subst: forall e x v,
  closed (Lam e) ->
  subst x v (Lam e) = Lam e.

Lemma subst_env'_Nat: forall rho m n,
  subst_env' m rho (Nat n) = Nat n.

Lemma subst_env'_Loc: forall rho m l,
  subst_env' m rho (Loc l) = Loc l.

Lemma subst_env'_Var': forall n m rho,
  subst_env' (S (n + m)) rho (Var n) = Var n.

Lemma subst_env'_Var: forall rho n v m,
  nth_error rho n = Some v ->
  subst_env' m rho (Var (n + m)) = val_to_exp v.

Lemma subst_env'_New: forall rho m e,
  subst_env' m rho (New e) = New (subst_env' m rho e).

Lemma subst_env'_Deref: forall rho m e,
  subst_env' m rho (Deref e) = Deref (subst_env' m rho e).

Lemma subst_env'_Update: forall rho m e1 e2 e3,
  subst_env' m rho (Update e1 e2 e3) =
  Update (subst_env' m rho e1) (subst_env' m rho e2) (subst_env' m rho e3).

Lemma subst_env_New: forall rho e,
  subst_env rho (New e) = New (subst_env rho e).

Lemma subst_env_Deref: forall rho e,
  subst_env rho (Deref e) = Deref (subst_env rho e).

Lemma subst_env_Update: forall rho e1 e2 e3,
  subst_env rho (Update e1 e2 e3) =
  Update (subst_env rho e1) (subst_env rho e2) (subst_env rho e3).

Lemma subst_env_App : forall env e1 e2,
  subst_env env (App e1 e2) = App (subst_env env e1) (subst_env env e2).

Lemma subst_env_Prim : forall env f e,
  subst_env env (Prim f e) = Prim f (subst_env env e).

Lemma subst_subst_neq : forall e n m v1 v2,
  n <> m ->
  subst n v1 (subst m v2 e) =
  subst m v2 (subst n v1 e).

Lemma subst_env_split : forall env1 env2 n e,
  subst_env' n (env1 ++ env2) e =
  subst_env' n env1 (subst_env' (length env1 + n) env2 e).

Lemma subst_subst_env_lt : forall env n m v e,
  n < m ->
  subst n v (subst_env' m env e) =
  subst_env' m env (subst n v e).

Lemma subst_closed' :
  forall e n v,
    closed' (S n) e ->
    closed' n (subst n v e).

Lemma closed_subst_env : forall env e x n,
   closed' (length env + x) e ->
   closed' (x + n) (subst_env' (x + n) env e).

Lemma closed_step : forall x y ,
  step x y ->
  closed (snd x) ->
  closed (snd y).

Lemma values_stopped: forall e,
  isValue e ->
  forall m,
  stopped m e.

Lemma stopped_New: forall m e,
  stopped m (New e) ->
  stopped m e.

Lemma stopped_Deref: forall m e,
  stopped m (Deref e) ->
  stopped m e.

Lemma stopped_Update: forall m e1 e2 e3,
  stopped m (Update e1 e2 e3) ->
  stopped m e1 \/ (isValue e1 /\ stopped m e2).

Lemma step_deterministic: forall m e m1 e1 m2 e2,
  step (m,e) (m1,e1) ->
  step (m,e) (m2,e2) ->
  m1 = m2 /\ e1 = e2.

Lemma stepn_value: forall j m v st,
  isValue v ->
  stepn j (m, v) st ->
  st = (m, v).

Lemma stepstar_search : forall f m e m' e',
  (forall m e m' e',
    step (m,e) (m',e') -> step (m,f e) (m',f e')) ->
  stepstar (m,e) (m',e') ->
  stepstar (m,f e) (m', f e').

Lemma stepn_trans : forall n m st1 st2 st3,
  stepn n st1 st2 ->
  stepn m st2 st3 ->
  stepn (n+m) st1 st3.

Lemma stepstar_stepn : forall st st',
  stepstar st st' <-> exists n, stepn n st st'. *)
Require Import lam_ref_type_defs.
(* lam_ref_type_defs:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Require Export lam_ref_type_prelim.

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.

Lemma ty_nat_extends :
  boxy extendM ty_nat.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).

Lemma just_extends : forall v,
  %just v = just v.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau. *)
Require Import lam_ref_type_safety.
(* lam_ref_type_safety:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.

Lemma expr_type_safen: forall k v e tau,
  expr_type e tau (k,v) ->
    forall m, mtype_valid m (k,v) ->
      safen (level k) (m,e).

Theorem typing_implies_safety: forall e tau,
  Typ nil e tau ->
  safe_prog e. *)
Require Import lam_ref_type_lemmas.
(* lam_ref_type_lemmas:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_prelim.
Require Import lam_ref_type_defs.
Require Import lam_ref_type_safety.

Lemma exp_to_val_to_exp : forall v H,
  exp_to_val (val_to_exp v) H = v.

Lemma forces2exprType: forall w v tau,
  forces w v (%tau) ->
  forall v', expr_type (val_to_exp v) tau (w,v').

Lemma exprType_value : forall w e tau m v
  (H:isValue e),
  forces w v (mtype_valid m) ->
  expr_type e tau (w,v) ->
  forces w (exp_to_val e H) (%tau).

Lemma expr_type_search_rule : forall (G Q tau sigma:pred world) (f:expr -> expr),
  forall e a,
         closed (f e) ->
         expr_type e tau a ->
         (Q) a ->
         (|>G) a ->
  forall
  (HQ: boxy extendM Q)
  (HG: boxy extendM G)
  (Hstep : forall m m' x y, step (m,x) (m',y) -> step (m,f x) (m',f y))
  (Hredex:
     forall k v e m (H:isValue e),
         closed (f e) ->
         (|>G) (k,v) ->
         Q (k,v) ->
         mtype_valid m (k,v) ->
         (%tau) (k,exp_to_val e H) ->
         expr_type (f e) sigma (k,v))
  (Hsearch:
     forall e a,
         closed (f e) ->
         G a ->
         Q a ->
         expr_type e tau a ->
         expr_type (f e) sigma a),

  expr_type (f e) sigma a.

Lemma subst_env_valid_closed :  forall env G e a,
  closed' (length G) e ->
  etype_valid env G a ->
  closed (subst_env env e).

Lemma etype_valid_lookup: forall G x tau w env v,
  nth_error G x = Some tau ->
  etype_valid env G (w,v) ->
  exists v,
    nth_error env x = Some v /\ forces w v (%tau).

Lemma etype_valid_val : forall G env m v v',
  etype_valid env G (m,v) ->
  etype_valid env G (m,v').

Lemma expr_type_val' : forall tau,
  TT |-- ALL v:value, ALL e:expr, %(expr_type e tau --> with_val v (expr_type e tau)).

Lemma expr_type_val : forall e tau k v v',
  expr_type e tau (k,v) ->
  expr_type e tau (k,v').

Lemma openValue_valid_value : forall env G a e,
  openValue e ->
  closed' (length G) e ->
  etype_valid env G a ->
  isValue (subst_env env e).

Lemma typ_beta: forall v1 v2 sigma tau w,
  forces w v1 (ty_lam sigma tau) ->
  forces w v2 (%sigma) ->
  forall v', expr_type (App (val_to_exp v1) (val_to_exp v2)) tau (w,v').

Lemma expr_ty_new: forall k v tau,
  forces k v (%tau) ->
  forall v', expr_type (New (val_to_exp v)) (ty_ref tau) (k,v').

Lemma expr_type_upd_Update: forall tau sigma w l v e3 v0,
  forces w (v_Loc l) (ty_ref tau) ->
  forces w v (%tau) ->
  expr_type e3 sigma (w,v0) ->
  expr_type (Update (Loc l) (val_to_exp v) e3) sigma (w,v0).

Lemma expr_ty_deref_loc : forall l tau a,
  expr_type (Loc l) (ty_ref tau) a ->
  expr_type (Deref (Loc l)) tau a. *)

Lemma T_weaken : forall G G' e tau,
  Typ G e tau ->
  Typ (G++G') e tau.
Proof.
  intros.
  unfold Typ in *; intuition.
  apply closed'_le with (length G); auto.
  clear.
  induction G; simpl; omega.
  unfold subst_env in *.

  intro a.
  assert (forall env,
    etype_valid env G a ->
    expr_type (subst_env' 0 env e) tau a).
  intros; eapply H1; auto.
  clear H1.
  intro.
  assert (exists env1, exists env2,
    env = env1 ++ env2 /\ etype_valid env1 G a /\ etype_valid env2 G' a).
  clear -H1.
  revert env H1.
  induction G; simpl; intros.
  exists nil; exists env.
  simpl; intuition.
  destruct env; simpl in H1; destruct H1.
  destruct (IHG env H0) as [e1 [e2 [? [? ?]]]].
  exists (v::e1); exists e2.
  simpl; intuition.
  f_equal; auto.
  destruct H2 as [env1 [env2 [? [? ?]]]].
  replace (subst_env' 0 env e)
    with (subst_env' 0 env1 e).

  apply H; auto.
  subst env.
  rewrite subst_env_split.
  replace (subst_env' (length env1 + 0) env2 e) with e; auto.
  replace (length env1 + 0) with (length G).
  revert H0; generalize (length G); clear.
  revert e; induction env2; simpl; intuition.
  rewrite <- IHenv2.
  symmetry.
  apply (closed'_subst n e 0 a); auto.
  apply closed'_le with n; auto.
  omega.
  clear -H3.
  revert a G H3; induction env1; simpl; intros.
  destruct G; auto.
  elim H3.
  destruct G; auto.
  elim H3.
  simpl.
  f_equal; apply IHenv1 with a0.
  destruct H3; auto.
Qed.

Lemma T_weaken_nil : forall G e tau,
  Typ nil e tau ->
  Typ G e tau.
Proof.
  intros; apply (T_weaken nil); auto.
Qed.

Fixpoint gamma_sub (G G':etype) {struct G} : Prop :=
  match G, G' with
  | nil, nil => True
  | x::xs, y::ys => TT |-- y >=> x /\ gamma_sub xs ys
  | _, _ => False
  end.

Lemma etype_valid_sub : forall G G' env a,
  gamma_sub G G' ->
  etype_valid env G' a ->
  etype_valid env G  a.
Proof.
  induction G; simpl; intros;
    destruct G'; destruct env; intuition.
  split.
  hnf in H0; destruct H0.
  clear H0.
  eapply sub_with_val; try apply H1; eauto.
  apply sub_extend; auto.
  hnf in H0; destruct H0.
  eapply IHG; eauto.
Qed.

Lemma T_weaken_sub : forall G G' e tau,
  gamma_sub G G' ->
  Typ G  e tau ->
  Typ G' e tau.
Proof.
  intros.
  assert (length G = length G').
  clear -H; revert G' H; induction G; simpl; intuition.
  destruct G'; auto.
  elim H.
  destruct G'; auto.
  elim H.
  simpl.
  f_equal; apply IHG; auto.
  destruct H; auto.
  destruct H0; split; auto.
  rewrite <- H1; auto.
  repeat intro.
  apply H2.
  apply etype_valid_sub with G'; auto.
Qed.

Lemma T_sub : forall G tau tau' e,
  TT |-- tau >=> tau' ->
  Typ G e tau ->
  Typ G e tau'.
Proof.
  intros.
  unfold Typ in *; intuition.
  assert (tau |-- tau').
  intro.
  spec H (level a).
  spec H. hnf; auto.
  spec H a. spec H.
  auto.
  eapply H; auto.

  cut ( TT |-- %(ALL e:expr,
    (!!(closed e) && expr_type e tau) --> expr_type e tau')).
  intros.
  hnf; intros.
  spec H3 a.
  spec H3. eauto.
  eapply H3; eauto.
  apply R_extends_refl.
  split; auto. hnf.
  eapply subst_env_valid_closed; eauto.
  eapply H2. auto.

  clear -H0. rename H0 into Htau.
  apply goedel_loeb.
  apply positive_boxy.
  rewrite TT_and.
  hnf.
  rewrite later_commute.
  rewrite box_refl_trans; auto.
  rewrite TT_and.

  apply forallI; intro e.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H0.
  simpl in H0.
  eapply expr_type_search_rule with (f:=@id expr).
  auto.
  apply H1.
  instantiate (1:= TT). auto.
  apply H.
  apply boxy_TT; auto.
  hnf; rewrite box_refl_trans; auto.
  intros; auto.

  clear -Htau; intros.
  unfold id.
  change e with (val_to_exp (exp_to_val e H)).
  eapply forces2exprType; auto.
  unfold forces.
  repeat intro.
  destruct a'.
  destruct H5; subst v0.
  spec H4 (m0,exp_to_val e H).
  spec H4.
  split; auto.
  apply Htau. auto.

  clear -Htau; intros.
  unfold id.
  eapply H0; eauto.
  apply R_extends_refl.
  split; auto.
Qed.

Lemma T_Nat : forall G n,
  Typ G (Nat n) ty_nat.
Proof.
  intros; split; intros.
  simpl; auto.
  do 2 intro.
  unfold subst_env.
  rewrite (subst_env'_Nat env 0).
  clear H.
  change (Nat n) with (val_to_exp (v_Nat n)).
  destruct a.
  apply forces2exprType.
  rewrite ty_nat_extends.
  hnf; eauto.
Qed.

Lemma T_Var: forall G x tau,
  nth_error G x = Some tau -> 
  Typ G (Var x) tau.
Proof.
  intros.
  split.
  revert x H.
  induction G; destruct x; simpl in *; intros; try discriminate.
  omega.
  apply IHG in H.
  omega.
  do 3 intro.
  destruct a.
  destruct (etype_valid_lookup _ _ _ _ _ _ H H0) as [v' [? ?]].
  unfold subst_env.
  generalize (subst_env'_Var env x v' 0 H1); intro.
  replace (x + 0) with x in H3 by omega.
  rewrite H3.
  apply forces2exprType.
  assumption.
Qed.

Lemma T_Abs: forall G sigma e tau,
  Typ (sigma :: G) e tau ->
  Typ G (Lam e) (ty_lam sigma tau).
Proof.
  repeat intro.
  split; intros.
  destruct H; simpl in *.
  replace (length G + 1) with (S (length G)) by omega; auto.
  destruct H.
  simpl in H.
  unfold subst_env.
  replace (subst_env' 0 env (Lam e))
    with (Lam (subst_env' 1 env e)).
  rewrite expr_type_eqn.
  do 2 intro.
  intros z Hz.
  repeat intro; split; repeat intro.
  simpl in H5.
  inv H5.
  simpl in H5.
  assert (closed' 1 (subst_env' 1 env e)).
  change 1 with (1 + 0).
  destruct a.
  eapply closed_subst_env; eauto.
  replace (length env + 1) with (S (length G)).
  auto.
  clear -H1.
  revert env m v H1; induction G; destruct env; simpl; intuition.
  rewrite IHG with env m v0; auto.
  exists (isvLam _ H6).
  rewrite ty_lam_extends.
  exists (subst_env' 1 env e).
  exists H6.
  split.
  simpl; auto.
  simpl; intros.
  destruct a'1.
  rewrite value_knot_laterR in H7.
  destruct H7; subst.
  destruct a'2.
  destruct H8.
  subst v.
  destruct a'3.
  rewrite value_knot_necR in H9.
  destruct H9; subst.
  simpl in H10.
  apply (H0 (b0::env)); auto.
  split; auto.
  match goal with [ |- app_pred (etype_valid env G) (m1,?X) ] =>
    generalize X
  end.
  intros.
  apply pred_nec_hereditary with (m0,v).
  rewrite value_knot_necR; split; auto.
  assert (etype_valid env G (m,v)).
  apply etype_valid_val with (snd a'0).
  apply pred_nec_hereditary with a'0.
  destruct a'0.
  rewrite value_knot_necR; split; simpl; auto.
  apply Rt_Rft; auto.
  apply pred_nec_hereditary with z; auto.
  apply rt_trans with a'; auto.
  rewrite <- etype_valid_extends in H1.
  apply H1; auto.
  rewrite <- etype_valid_extends in H11.
  apply H11.
  simpl; split; auto.

  generalize 0.
  induction env; simpl; intros; auto.
  rewrite <- IHenv.
  simpl.
  replace (n+1) with (S n) by omega.
  trivial.
Qed.

Definition prim (f:nat -> value) : expr -> expr :=
  Prim (val_to_exp oo f).

Lemma T_Prim : forall G f e sigma,
  (forall n, Typ nil (val_to_exp (f n)) sigma) ->
  Typ G e ty_nat ->
  Typ G (prim f e) sigma.
Proof.
  intros.
  destruct H0; split; auto.
  repeat intro.
  spec H1 env a H2.
  unfold prim.
  rewrite subst_env_Prim.
  cut ( TT |-- %(ALL e:expr,
        !!(closed e) && expr_type e ty_nat --> expr_type (Prim (val_to_exp oo f) e) sigma)).
  intros; eapply H3; eauto.
  apply R_extends_refl.
  simpl; auto.
  split; auto.
  eapply subst_env_valid_closed; eauto.
  clear -H.

  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf; rewrite later_commute; rewrite box_refl_trans; auto.
  apply forallI; intro e.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H0.
  destruct H1.
  simpl in H1.
  eapply expr_type_search_rule with (f:= fun x => Prim (val_to_exp oo f) x).
  auto.
  apply H2.
  instantiate (1:=TT); simpl; auto.
  apply H0.
  apply TT_boxy.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_Prim1; auto.

  clear -H.
  intros.
  rewrite expr_type_eqn; repeat intro.
  split; repeat intro.
  simpl in H10.
  inv H10.
  assert (stopped b e) by (apply values_stopped; auto).
  elim H10; eauto.
  exists a'2; split; auto.
  simpl; apply R_extends_refl.
  split.
  apply pred_nec_hereditary with a'0; auto.
  apply rt_trans with a'1; auto.
  apply Rt_Rft; auto.
  spec H n.
  destruct H.
  spec H10 (nil:env) a'2 I.
  apply H10.
  rewrite ty_nat_extends in H5.
  destruct H5.
  inv H5.
  simpl in H10.
  elim H10.
  exists b.
  exists ((val_to_exp oo f) x).
  apply st_Prim2.
  unfold compose.
  destruct (f x); auto.

  clear; intros.
  eapply H0; eauto.
  apply R_extends_refl.
  split; auto.
Qed.

Lemma T_New: forall G e tau,
  Typ G e tau ->
  Typ G (New e) (ty_ref tau).
Proof.
  intros; destruct H; split; simpl; auto.
  repeat intro.
  rewrite subst_env_New.
  spec H0 env a H1.
  assert (closed (subst_env env e)).
  eapply subst_env_valid_closed; eauto.

  cut (TT |-- %(ALL e:expr, !!(closed e) && expr_type e tau --> expr_type (New e) (ty_ref tau))).
  intros.
  eapply H3; eauto.
  apply R_extends_refl.
  simpl; auto.

  clear.
  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf.
  rewrite later_commute.
  rewrite box_refl_trans; auto.
  apply forallI; intro e.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H0.
  simpl in H0.
  eapply expr_type_search_rule.
  unfold closed; simpl; auto.
  apply H1.
  instantiate (1:=TT); simpl; auto.
  apply H.
  apply TT_boxy.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_New1; auto.

  intros.
  change e0 with (val_to_exp (exp_to_val e0 H2)).
  eapply expr_ty_new; auto.

  intros.
  eapply H3; eauto.
  apply R_extends_refl.
  split; auto.
Qed.

Lemma T_App: forall G e1 sigma tau e2,
  Typ G e1 (ty_lam sigma tau) ->
  Typ G e2 sigma ->
  Typ G (App e1 e2) tau.
Proof.
  intros.
  destruct H; destruct H0; split.
  simpl; split; auto.
  repeat intro.

  rewrite subst_env_App.
  spec H1 env a H3.
  spec H2 env a H3.
  cut (TT |-- %(ALL e1:expr, ALL e2:expr, (!!(closed e1 /\ closed e2)) && expr_type e1 (ty_lam sigma tau) && expr_type e2 sigma --> expr_type (App e1 e2) tau)).
  intros; eapply H4; eauto.
  apply R_extends_refl.
  hnf; auto.
  simpl; repeat split; auto.
  eapply subst_env_valid_closed; eauto.
  eapply subst_env_valid_closed; eauto.

  clear.
  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf; rewrite later_commute; rewrite box_refl_trans; auto.
  apply forallI; intro e1.
  apply forallI; intro e2.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H0.
  destruct H0.
  simpl in H0; destruct H0.

  eapply expr_type_search_rule with (f:= fun x => App x e2).
  compute; auto.
  apply H2.
  apply H1.
  apply H.
  hnf; rewrite expr_type_extends; auto.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_App1; auto.

  intros.
  rewrite ty_lam_extends in H9.
  generalize H9; intros.
  destruct H9 as [e' [He [? ?]]].
  inv H9.
  eapply expr_type_search_rule with (f:= fun x => (App (Lam e') x)).
  auto.
  eauto.
  instantiate (1:=(with_val (exp_to_val (Lam e') H4) (ty_lam sigma tau))); auto.
  apply H6.
  hnf; rewrite with_val_extends; rewrite ty_lam_extends; auto.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_App2; auto.
  intros.
  change (Lam e') with (val_to_exp (exp_to_val _ H4)).
  change e with (val_to_exp (exp_to_val _ H9)).
  apply typ_beta with sigma; auto.

  intros.
  eapply H12; eauto.
  apply R_extends_refl.
  repeat split; simpl; auto.
  destruct H9; auto.
  destruct a0.
  change (Lam e') with (val_to_exp (exp_to_val _ H4)).
  apply forces2exprType; auto.
  rewrite ty_lam_extends; auto.

  intros.
  eapply H5; eauto.
  apply R_extends_refl.
  repeat split; simpl; auto.
  destruct H4; auto.
Qed.

Lemma T_Deref: forall G e tau,
  Typ G e (ty_ref tau) ->
  Typ G (Deref e) tau.
Proof.
  intros.
  destruct H.
  split.
  simpl; auto.
  repeat intro.
  spec H0 env a H1.

  rewrite subst_env_Deref.
  cut ( TT |-- %(ALL e:expr, !!(closed e) && expr_type e (ty_ref tau) --> expr_type (Deref e) tau)).
  intros.
  eapply H2.
  2: apply R_extends_refl.
  2: apply rt_refl.
  simpl; auto.
  split; auto.
  simpl; auto.
  eapply subst_env_valid_closed; eauto.

  clear.
  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf.
  rewrite later_commute.
  rewrite box_refl_trans; auto.
  apply forallI; intro e.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H0.
  simpl in H0.
  eapply expr_type_search_rule.
  unfold closed; simpl; auto.
  apply H1.
  instantiate (1:=TT); simpl; auto.
  apply H.
  apply TT_boxy.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_Deref1; auto.

  intros.
  rewrite ty_ref_extends in H7.
  assert (exists l, e0 = Loc l).
  hnf in H7.
  destruct (unsquash k).
  destruct H7 as [l [Hl ?]].
  exists l; inv Hl; auto.
  destruct H8 as [l Hl].
  subst e0.
  eapply expr_ty_deref_loc; auto.
  change (Loc l) with (val_to_exp (exp_to_val (Loc l) H2)).
  eapply forces2exprType.
  rewrite ty_ref_extends.
  auto.

  intros.
  eapply H3; eauto.
  apply R_extends_refl.
  split; auto.
Qed.

Lemma T_Update: forall G e1 tau e2 e3 sigma,
  Typ G e1 (ty_ref tau) ->
  Typ G e2 tau ->
  Typ G e3 sigma ->
  Typ G (Update e1 e2 e3) sigma.
Proof.
  unfold Typ; simpl; intuition.
  repeat intro.
  spec H3 env a H1.
  spec H4 env a H1.
  spec H5 env a H1.

  rewrite subst_env_Update.
  cut ( TT |-- %(ALL e1:expr, ALL e2:expr, ALL e3:expr,
                 !!(closed e1 /\ closed e2 /\ closed e3) &&
                 expr_type e1 (ty_ref tau) &&
                 expr_type e2 tau &&
                 expr_type e3 sigma -->
                 expr_type (Update e1 e2 e3) sigma)).
  intros.
  eapply H6; eauto.
  apply R_extends_refl.
  simpl; auto.
  split; auto.
  split; auto.
  split; auto.
  repeat split; eapply subst_env_valid_closed; eauto.

  clear.
  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf; rewrite later_commute; rewrite box_refl_trans; auto.
  apply forallI; intro e1.
  apply forallI; intro e2.
  apply forallI; intro e3.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H0.
  destruct H0.
  destruct H0.
  simpl in H0; destruct H0.
  destruct H4.
  eapply expr_type_search_rule with (f:= fun x => Update x e2 e3).
  compute; auto.
  apply H3.
  instantiate (1 := expr_type e2 tau && expr_type e3 sigma).
  split; auto.
  apply H.
  hnf; rewrite box_and; do 2  rewrite expr_type_extends; auto.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_Upd1; auto.

  clear; intros.
  destruct H2.
  rewrite ty_ref_extends in H4.
  assert (exists l, e = Loc l).
  hnf in H4.
  destruct (unsquash k); destruct H4 as [l [Hl ?]]; inv Hl; eauto.
  destruct H6 as [l Hl]; subst e.
  eapply expr_type_search_rule with (f := fun x => Update (Loc l) x e3).
  compute; auto.
  apply H2.
  instantiate (1:= with_val (exp_to_val _ H) (ty_ref tau) && expr_type e3 sigma).
  split; auto.
  apply H1.
  hnf; rewrite box_and.
  rewrite expr_type_extends; auto.
  rewrite with_val_extends.
  rewrite ty_ref_extends; auto.
  hnf; rewrite box_refl_trans; auto.
  intros; apply st_Upd2; auto.

  clear; intros.
  change e with (val_to_exp (exp_to_val e H0)).
  destruct H3.
  eapply expr_type_upd_Update; eauto.
  unfold v_Loc.
  replace (isvLoc l) with H by apply proof_irr; auto.

  clear; intros.
  destruct H2.
  eapply H1; eauto.
  apply R_extends_refl.
  simpl; repeat (split; auto).
  destruct a.
  change (Loc l) with (val_to_exp (exp_to_val _ H)).
  apply forces2exprType.
  rewrite ty_ref_extends; auto.

  clear; intros.
  destruct H1.
  eapply H0; eauto.
  apply R_extends_refl.
  simpl; repeat (split; auto).
Qed.

Definition AllBnd (T:pred world) (X:pred world -> pred world)
  := ALL tau:pred world, !!(TT |-- tau >=> T) --> X tau.

Lemma sub_AllBnd : forall T1 T2 (X1 X2:pred world -> pred world),
  TT |-- T2 >=> T1 ->
  (forall x, TT |-- x >=> T2 -> TT |-- X1 x >=> X2 x) ->
  TT |-- AllBnd T1 X1 >=> AllBnd T2 X2.
Proof.
  intros.
  unfold AllBnd.
  apply subp_allp; intro tau.
  spec H0 tau.
  repeat intro.
  eapply H0; eauto.
  eapply H4; eauto.
  repeat intro.
  eapply H; eauto.
  eapply H6; eauto.
Qed.

Lemma AllBnd_ALL : forall (X:pred world -> pred world),
  allp X = AllBnd TT X.
Proof.
  intros.
  apply pred_ext; simpl; repeat intro; intuition.
  eapply pred_nec_hereditary; eauto.
  apply H; auto.
  simpl; split; auto.
Qed.

Lemma T_UnivBoundedI : forall G e T (X:pred world -> pred world),
  openValue e ->
  (forall tau, TT |-- tau >=> T -> Typ G e (X tau)) ->
  Typ G e (AllBnd T X).
Proof.
  intros.
  assert (Hcl:closed' (length G) e).
  destruct (H0 FF).
  apply subp_bot.
  auto.
  split; auto.
  repeat intro.

  rewrite expr_type_eqn.
  repeat intro.
  split.
  repeat intro.
  simpl in H6.
  assert (stopped b (subst_env env e)).
  apply values_stopped; auto.
  eapply openValue_valid_value; eauto.
  elim H8; eauto.

  repeat intro.
  simpl in H6.
  assert (Hv : isValue (subst_env env e)).
  eapply openValue_valid_value; eauto.
  exists Hv.
  repeat intro.
  spec H0 b0.
  simpl in H9.
  destruct H0; auto.
  spec H10 env a H1.
  rewrite expr_type_eqn in H10.
  spec H10 a' H2.
  spec H10 b a'0 H3 H4.
  destruct H10.
  spec H11 a'1 H5.
  detach H11.
  destruct H11.
  apply pred_nec_hereditary with a'2; auto.
  simpl in H11.
  apply H11.
  replace x with Hv by apply proof_irr.
  auto.
  simpl; auto.
Qed.

Lemma T_UnivBoundedE : forall G e T (X:pred world -> pred world) tau,
  TT |-- tau >=> T ->
  Typ G e (AllBnd T X) ->
  Typ G e (X tau).
Proof.
  do 6 intro.
  apply T_sub.
  unfold AllBnd.
  repeat intro.
  apply H3; auto.
Qed.

Lemma T_UnivI : forall G e (X:pred world -> pred world),
  openValue e ->
  (forall tau, Typ G e (X tau)) ->
  Typ G e (allp X).
Proof.
  intros; rewrite AllBnd_ALL.
  apply T_UnivBoundedI; auto.
Qed.

Lemma T_UnivE : forall G e (X:pred world -> pred world) tau,
  Typ G e (allp X) ->
  Typ G e (X tau).
Proof.
  do 4 intro; apply T_sub; apply subp_allp_spec.
Qed.

Definition ty_ex (F:pred world -> pred world) : pred world :=
  EX tau:pred world, !!(boxy extendM tau) && F tau.

Lemma T_ExtI : forall G e (X:pred world -> pred world) tau
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  boxy extendM tau ->
  Typ G e (X tau) ->
  Typ G e (ty_ex X).
Proof.
  intros.
  revert H0; apply T_sub.
  unfold ty_ex.
  repeat intro; auto.
  exists tau; split; auto.
Qed.

Lemma T_ExtE : forall G e f (X:pred world -> pred world) sigma
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  Typ G e (ty_ex X) ->
  (forall tau, Typ (X tau::G) f sigma) ->
  Typ G (App (Lam f) e) sigma.
Proof.
  intros.
  generalize (H0 FF).
  intros.
  destruct H1 as [H1 _].
  simpl in H1.
  destruct H.
  split; auto.
  simpl.
  replace (length G + 1) with (S (length G)); auto.
  omega.
  repeat intro.
  spec H2 env a H3.
  rewrite subst_env_App.
  replace (subst_env env (Lam f)) with (Lam (subst_env' 1 env f)).
  cut (TT |-- %(ALL e:expr,
        (!!(closed e /\ closed' 1 (subst_env' 1 env f)) && (etype_valid env G)) && expr_type e (ty_ex X) -->
        expr_type (App (Lam (subst_env' 1 env f)) e) sigma)).
  intros.
  eapply H4; eauto.
  apply R_extends_refl.
  simpl; auto.
  simpl; repeat (split; auto).
  eapply subst_env_valid_closed; eauto.
  apply (closed_subst_env env f 1 0).
  replace (length env + 1) with (S (length G)); auto.
  clear -H3.
  revert a env H3; induction G; intros; destruct env; simpl in H3; try contradiction;
    simpl; auto.
  destruct H3.
  f_equal; eapply IHG; eauto.

  clear e H H1 H2.
  apply goedel_loeb.
  rewrite TT_and.
  apply positive_boxy.
  hnf; rewrite later_commute; rewrite box_refl_trans; auto.
  apply forallI; intro e.
  rewrite <- imp_andp_adjoint.
  repeat intro.
  destruct H.
  destruct H1.
  destruct H1.
  simpl in H1; destruct H1.

  eapply expr_type_search_rule with (f:=fun x => (App (Lam (subst_env' 1 env f)) x)).
  hnf; auto.
  apply H2.
  apply H4.
  apply H.
  hnf; apply etype_valid_extends.
  hnf; rewrite box_refl_trans; eauto.
  intros; apply st_App2; auto.

  clear -Hext H0; intros.
  spec H5 (k,exp_to_val e H) (R_extends_refl (k,exp_to_val e H)).
  destruct H5 as [tau H5].
  destruct H5.
  simpl in H5.
  spec H0 tau.
  destruct H0.
  rewrite <- Hext in H6; auto.
  spec H7 (exp_to_val e H :: env) (k,v).
  spec H7.
  split; auto.
  rewrite expr_type_eqn.
  repeat intro.
  split; repeat intro.
  simpl in H12.
  inv H12.
  inv H15.
  assert (stopped b e).
  apply values_stopped; auto.
  elim H12; eauto.
  exists a'2; split; auto.
  simpl; apply R_extends_refl.
  split.
  apply pred_nec_hereditary with a'0; auto.
  apply rt_trans with a'1; auto.
  apply Rt_Rft; auto.
  unfold subst_env in H7.
  simpl in H7.
  replace H14 with H by apply proof_irr; auto.
  rewrite <- expr_type_extends in H7.
  spec H7 a' H8.
  apply pred_nec_hereditary with a'; auto.
  apply rt_trans with a'0; auto.
  apply rt_trans with a'1; auto.
  apply Rt_Rft; auto.
  simpl in H12.
  elim H12.
  exists b; exists (subst 0 (exp_to_val e H) (subst_env' 1 env f)).
  apply st_App3.

  clear; intros.
  eapply H0; eauto.
  apply R_extends_refl.
  simpl; repeat (split; auto).
  destruct H; auto.
  destruct H; auto.

  unfold subst_env.
  clear.
  generalize 0; revert f.
  induction env; simpl; intuition.
  rewrite <- IHenv.
  simpl.
  replace (n+1) with (S n) by omega; auto.
Qed.
