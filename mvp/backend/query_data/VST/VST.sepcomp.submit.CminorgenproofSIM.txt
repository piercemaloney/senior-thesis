Require Export Axioms.

Require Import Errors.

Require Import Events.

Require Import Coqlib.

Require Import AST.

Require Import Integers.

Require Import compcert.common.Values.
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)

Require Import Memory.

Require Import Globalenvs.

Require Export Maps.



Require Import Csharpminor.
(* Csharpminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Cminor.
Require Import Smallstep.

Inductive constant : Type :=
  | Ointconst: int -> constant          
  | Ofloatconst: float -> constant      
  | Olongconst: int64 -> constant.      

Definition unary_operation : Type := Cminor.unary_operation.
Definition binary_operation : Type := Cminor.binary_operation.

Inductive expr : Type :=
  | Evar : ident -> expr                
  | Eaddrof : ident -> expr             
  | Econst : constant -> expr           
  | Eunop : unary_operation -> expr -> expr  
  | Ebinop : binary_operation -> expr -> expr -> expr 
  | Eload : memory_chunk -> expr -> expr. 

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sset : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> lbl_stmt -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt

with lbl_stmt : Type :=
  | LSdefault: stmt -> lbl_stmt
  | LScase: int -> stmt -> lbl_stmt -> lbl_stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list (ident * Z);
  fn_temps: list ident;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.

Definition program : Type := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t (block * Z).
Definition temp_env := PTree.t val.

Definition empty_env : env := PTree.empty (block * Z).
Definition empty_temp_env : temp_env := PTree.empty val.

Fixpoint create_undef_temps (temps: list ident) : temp_env :=
  match temps with
  | nil => PTree.empty val
  | id :: temps' => PTree.set id Vundef (create_undef_temps temps')
 end.

Fixpoint bind_parameters (formals: list ident) (args: list val)
                         (le: temp_env) : option temp_env :=
 match formals, args with
 | nil, nil => Some le
 | id :: xl, v :: vl => bind_parameters xl vl (PTree.set id v le)
 | _, _ => None
 end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> env -> temp_env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (e: env)                   
             (le: temp_env)             
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint select_switch (n: int) (sl: lbl_stmt) {struct sl} : lbl_stmt :=
  match sl with
  | LSdefault _ => sl
  | LScase c s sl' => if Int.eq c n then sl else select_switch n sl'
  end.

Fixpoint seq_of_lbl_stmt (sl: lbl_stmt) : stmt :=
  match sl with
  | LSdefault s => s
  | LScase c s sl' => Sseq s (seq_of_lbl_stmt sl')
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Sswitch a sl =>
      find_label_ls lbl sl k
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: lbl_stmt) (k: cont)
                   {struct sl}: option (stmt * cont) :=
  match sl with
  | LSdefault s => find_label lbl s k
  | LScase _ s sl' =>
      match find_label lbl s (Kseq (seq_of_lbl_stmt sl') k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Definition eval_constant (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  end.

Definition eval_unop := Cminor.eval_unop.

Definition eval_binop := Cminor.eval_binop.

Inductive alloc_variables: env -> mem ->
                           list (ident * Z) ->
                           env -> mem -> Prop :=
  | alloc_variables_nil:
      forall e m,
      alloc_variables e m nil e m
  | alloc_variables_cons:
      forall e m id sz vars m1 b1 m2 e2,
      Mem.alloc m 0 sz = (m1, b1) ->
      alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2 ->
      alloc_variables e m ((id, sz) :: vars) e2 m2.

Definition block_of_binding (id_b_sz: ident * (block * Z)) :=
  match id_b_sz with (id, (b, sz)) => (b, 0, sz) end.

Definition blocks_of_env (e: env) : list (block * Z * Z) :=
  List.map block_of_binding (PTree.elements e).

Section RELSEM.

Variable ge: genv.

Inductive eval_var_addr: env -> ident -> block -> Prop :=
  | eval_var_addr_local:
      forall e id b sz,
      PTree.get id e = Some (b, sz) ->
      eval_var_addr e id b
  | eval_var_addr_global:
      forall e id b,
      PTree.get id e = None ->
      Genv.find_symbol ge id = Some b ->
      eval_var_addr e id b.

Section EVAL_EXPR.

Variable e: env.
Variable le: temp_env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      le!id = Some v ->
      eval_expr (Evar id) v
  | eval_Eaddrof: forall id b,
      eval_var_addr e id b ->
      eval_expr (Eaddrof id) (Vptr b Int.zero)
  | eval_Econst: forall cst v,
      eval_constant cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk a v1 v,
      eval_expr a v1 ->
      Mem.loadv chunk m v1 = Some v ->
      eval_expr (Eload chunk a) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k e le m,
      step (State f Sskip (Kseq s k) e le m)
        E0 (State f s k e le m)
  | step_skip_block: forall f k e le m,
      step (State f Sskip (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f Sskip k e le m)
        E0 (Returnstate Vundef k m')

  | step_set: forall f id a k e le m v,
      eval_expr e le m a v ->
      step (State f (Sset id a) k e le m)
        E0 (State f Sskip k e (PTree.set id v le) m)

  | step_store: forall f chunk addr a k e le m vaddr v m',
      eval_expr e le m addr vaddr ->
      eval_expr e le m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k e le m)
        E0 (State f Sskip k e le m')

  | step_call: forall f optid sig a bl k e le m vf vargs fd,
      eval_expr e le m a vf ->
      eval_exprlist e le m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k e le m)
        E0 (Callstate fd vargs (Kcall optid f e le k) m)

  | step_builtin: forall f optid ef bl k e le m vargs t vres m',
      eval_exprlist e le m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k e le m)
         t (State f Sskip k e (Cminor.set_optvar optid vres le) m')

  | step_seq: forall f s1 s2 k e le m,
      step (State f (Sseq s1 s2) k e le m)
        E0 (State f s1 (Kseq s2 k) e le m)

  | step_ifthenelse: forall f a s1 s2 k e le m v b,
      eval_expr e le m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k e le m)
        E0 (State f (if b then s1 else s2) k e le m)

  | step_loop: forall f s k e le m,
      step (State f (Sloop s) k e le m)
        E0 (State f s (Kseq (Sloop s) k) e le m)

  | step_block: forall f s k e le m,
      step (State f (Sblock s) k e le m)
        E0 (State f s (Kblock k) e le m)

  | step_exit_seq: forall f n s k e le m,
      step (State f (Sexit n) (Kseq s k) e le m)
        E0 (State f (Sexit n) k e le m)
  | step_exit_block_0: forall f k e le m,
      step (State f (Sexit O) (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_exit_block_S: forall f n k e le m,
      step (State f (Sexit (S n)) (Kblock k) e le m)
        E0 (State f (Sexit n) k e le m)

  | step_switch: forall f a cases k e le m n,
      eval_expr e le m a (Vint n) ->
      step (State f (Sswitch a cases) k e le m)
        E0 (State f (seq_of_lbl_stmt (select_switch n cases)) k e le m)

  | step_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn None) k e le m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k e le m v m',
      eval_expr e le m a v ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn (Some a)) k e le m)
        E0 (Returnstate v (call_cont k) m')
  | step_label: forall f lbl s k e le m,
      step (State f (Slabel lbl s) k e le m)
        E0 (State f s k e le m)

  | step_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k e le m)
        E0 (State f s' k' e le m)

  | step_internal_function: forall f vargs k m m1 e le,
      list_norepet (map fst f.(fn_vars)) ->
      list_norepet f.(fn_params) ->
      list_disjoint f.(fn_params) f.(fn_temps) ->
      alloc_variables empty_env m (fn_vars f) e m1 ->
      bind_parameters f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k e le m1)

  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f e le k m,
      step (Returnstate v (Kcall optid f e le k) m)
        E0 (State f Sskip k e (Cminor.set_optvar optid v le) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p). *)

Require Import Cminor.
(* Cminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Events.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Switch.

Inductive constant : Type :=
  | Ointconst: int -> constant     
  | Ofloatconst: float -> constant 
  | Olongconst: int64 -> constant  
  | Oaddrsymbol: ident -> int -> constant 
  | Oaddrstack: int -> constant.   

Inductive unary_operation : Type :=
  | Ocast8unsigned: unary_operation        
  | Ocast8signed: unary_operation          
  | Ocast16unsigned: unary_operation       
  | Ocast16signed: unary_operation         
  | Onegint: unary_operation               
  | Onotint: unary_operation               
  | Onegf: unary_operation                 
  | Oabsf: unary_operation                 
  | Osingleoffloat: unary_operation        
  | Ointoffloat: unary_operation           
  | Ointuoffloat: unary_operation          
  | Ofloatofint: unary_operation           
  | Ofloatofintu: unary_operation          
  | Onegl: unary_operation                 
  | Onotl: unary_operation                 
  | Ointoflong: unary_operation            
  | Olongofint: unary_operation            
  | Olongofintu: unary_operation           
  | Olongoffloat: unary_operation          
  | Olonguoffloat: unary_operation         
  | Ofloatoflong: unary_operation          
  | Ofloatoflongu: unary_operation         
  | Osingleoflong: unary_operation         
  | Osingleoflongu: unary_operation.       

Inductive binary_operation : Type :=
  | Oadd: binary_operation                 
  | Osub: binary_operation                 
  | Omul: binary_operation                 
  | Odiv: binary_operation                 
  | Odivu: binary_operation                
  | Omod: binary_operation                 
  | Omodu: binary_operation                
  | Oand: binary_operation                 
  | Oor: binary_operation                  
  | Oxor: binary_operation                 
  | Oshl: binary_operation                 
  | Oshr: binary_operation                 
  | Oshru: binary_operation                
  | Oaddf: binary_operation                
  | Osubf: binary_operation                
  | Omulf: binary_operation                
  | Odivf: binary_operation                
  | Oaddl: binary_operation                
  | Osubl: binary_operation                
  | Omull: binary_operation                
  | Odivl: binary_operation                
  | Odivlu: binary_operation               
  | Omodl: binary_operation                
  | Omodlu: binary_operation               
  | Oandl: binary_operation                
  | Oorl: binary_operation                 
  | Oxorl: binary_operation                
  | Oshll: binary_operation                
  | Oshrl: binary_operation                
  | Oshrlu: binary_operation               
  | Ocmp: comparison -> binary_operation   
  | Ocmpu: comparison -> binary_operation  
  | Ocmpf: comparison -> binary_operation  
  | Ocmpl: comparison -> binary_operation  
  | Ocmplu: comparison -> binary_operation. 

Inductive expr : Type :=
  | Evar : ident -> expr
  | Econst : constant -> expr
  | Eunop : unary_operation -> expr -> expr
  | Ebinop : binary_operation -> expr -> expr -> expr
  | Eload : memory_chunk -> expr -> expr.

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sassign : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Stailcall: signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> list (int * nat) -> nat -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list ident;
  fn_stackspace: Z;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.
Definition program := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t val.

Fixpoint set_params (vl: list val) (il: list ident) {struct il} : env :=
  match il, vl with
  | i1 :: is, v1 :: vs => PTree.set i1 v1 (set_params vs is)
  | i1 :: is, nil => PTree.set i1 Vundef (set_params nil is)
  | _, _ => PTree.empty val
  end.

Fixpoint set_locals (il: list ident) (e: env) {struct il} : env :=
  match il with
  | nil => e
  | i1 :: is => PTree.set i1 Vundef (set_locals is e)
  end.

Definition set_optvar (optid: option ident) (v: val) (e: env) : env :=
  match optid with
  | None => e
  | Some id => PTree.set id v e
  end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> val -> env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (sp: val)                  
             (e: env)                   
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Section RELSEM.

Variable ge: genv.

Definition eval_constant (sp: val) (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  | Oaddrsymbol s ofs =>
      Some(match Genv.find_symbol ge s with
           | None => Vundef
           | Some b => Vptr b ofs end)
  | Oaddrstack ofs => Some (Val.add sp (Vint ofs))
  end.

Definition eval_unop (op: unary_operation) (arg: val) : option val :=
  match op with
  | Ocast8unsigned => Some (Val.zero_ext 8 arg)
  | Ocast8signed => Some (Val.sign_ext 8 arg)
  | Ocast16unsigned => Some (Val.zero_ext 16 arg)
  | Ocast16signed => Some (Val.sign_ext 16 arg)
  | Onegint => Some (Val.negint arg)
  | Onotint => Some (Val.notint arg)
  | Onegf => Some (Val.negf arg)
  | Oabsf => Some (Val.absf arg)
  | Osingleoffloat => Some (Val.singleoffloat arg)
  | Ointoffloat => Val.intoffloat arg
  | Ointuoffloat => Val.intuoffloat arg
  | Ofloatofint => Val.floatofint arg
  | Ofloatofintu => Val.floatofintu arg
  | Onegl => Some (Val.negl arg)
  | Onotl => Some (Val.notl arg)
  | Ointoflong => Some (Val.loword arg)
  | Olongofint => Some (Val.longofint arg)
  | Olongofintu => Some (Val.longofintu arg)
  | Olongoffloat => Val.longoffloat arg
  | Olonguoffloat => Val.longuoffloat arg
  | Ofloatoflong => Val.floatoflong arg
  | Ofloatoflongu => Val.floatoflongu arg
  | Osingleoflong => Val.singleoflong arg
  | Osingleoflongu => Val.singleoflongu arg
  end.

Definition eval_binop
            (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
  match op with
  | Oadd => Some (Val.add arg1 arg2)
  | Osub => Some (Val.sub arg1 arg2)
  | Omul => Some (Val.mul arg1 arg2)
  | Odiv => Val.divs arg1 arg2
  | Odivu => Val.divu arg1 arg2
  | Omod => Val.mods arg1 arg2
  | Omodu => Val.modu arg1 arg2
  | Oand => Some (Val.and arg1 arg2)
  | Oor => Some (Val.or arg1 arg2)
  | Oxor => Some (Val.xor arg1 arg2)
  | Oshl => Some (Val.shl arg1 arg2)
  | Oshr => Some (Val.shr arg1 arg2)
  | Oshru => Some (Val.shru arg1 arg2)
  | Oaddf => Some (Val.addf arg1 arg2)
  | Osubf => Some (Val.subf arg1 arg2)
  | Omulf => Some (Val.mulf arg1 arg2)
  | Odivf => Some (Val.divf arg1 arg2)
  | Oaddl => Some (Val.addl arg1 arg2)
  | Osubl => Some (Val.subl arg1 arg2)
  | Omull => Some (Val.mull arg1 arg2)
  | Odivl => Val.divls arg1 arg2
  | Odivlu => Val.divlu arg1 arg2
  | Omodl => Val.modls arg1 arg2
  | Omodlu => Val.modlu arg1 arg2
  | Oandl => Some (Val.andl arg1 arg2)
  | Oorl => Some (Val.orl arg1 arg2)
  | Oxorl => Some (Val.xorl arg1 arg2)
  | Oshll => Some (Val.shll arg1 arg2)
  | Oshrl => Some (Val.shrl arg1 arg2)
  | Oshrlu => Some (Val.shrlu arg1 arg2)
  | Ocmp c => Some (Val.cmp c arg1 arg2)
  | Ocmpu c => Some (Val.cmpu (Mem.valid_pointer m) c arg1 arg2)
  | Ocmpf c => Some (Val.cmpf c arg1 arg2)
  | Ocmpl c => Val.cmpl c arg1 arg2
  | Ocmplu c => Val.cmplu c arg1 arg2
  end.

Section EVAL_EXPR.

Variable sp: val.
Variable e: env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      PTree.get id e = Some v ->
      eval_expr (Evar id) v
  | eval_Econst: forall cst v,
      eval_constant sp cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk addr vaddr v,
      eval_expr addr vaddr ->
      Mem.loadv chunk m vaddr = Some v ->
      eval_expr (Eload chunk addr) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k sp e m,
      step (State f Sskip (Kseq s k) sp e m)
        E0 (State f s k sp e m)
  | step_skip_block: forall f k sp e m,
      step (State f Sskip (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f Sskip k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef k m')

  | step_assign: forall f id a k sp e m v,
      eval_expr sp e m a v ->
      step (State f (Sassign id a) k sp e m)
        E0 (State f Sskip k sp (PTree.set id v e) m)

  | step_store: forall f chunk addr a k sp e m vaddr v m',
      eval_expr sp e m addr vaddr ->
      eval_expr sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k sp e m)
        E0 (State f Sskip k sp e m')

  | step_call: forall f optid sig a bl k sp e m vf vargs fd,
      eval_expr sp e m a vf ->
      eval_exprlist sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k sp e m)
        E0 (Callstate fd vargs (Kcall optid f sp e k) m)

  | step_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      eval_expr (Vptr sp Int.zero) e m a vf ->
      eval_exprlist (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Stailcall sig a bl) k (Vptr sp Int.zero) e m)
        E0 (Callstate fd vargs (call_cont k) m')

  | step_builtin: forall f optid ef bl k sp e m vargs t vres m',
      eval_exprlist sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k sp e m)
         t (State f Sskip k sp (set_optvar optid vres e) m')

  | step_seq: forall f s1 s2 k sp e m,
      step (State f (Sseq s1 s2) k sp e m)
        E0 (State f s1 (Kseq s2 k) sp e m)

  | step_ifthenelse: forall f a s1 s2 k sp e m v b,
      eval_expr sp e m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k sp e m)
        E0 (State f (if b then s1 else s2) k sp e m)

  | step_loop: forall f s k sp e m,
      step (State f (Sloop s) k sp e m)
        E0 (State f s (Kseq (Sloop s) k) sp e m)

  | step_block: forall f s k sp e m,
      step (State f (Sblock s) k sp e m)
        E0 (State f s (Kblock k) sp e m)

  | step_exit_seq: forall f n s k sp e m,
      step (State f (Sexit n) (Kseq s k) sp e m)
        E0 (State f (Sexit n) k sp e m)
  | step_exit_block_0: forall f k sp e m,
      step (State f (Sexit O) (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_exit_block_S: forall f n k sp e m,
      step (State f (Sexit (S n)) (Kblock k) sp e m)
        E0 (State f (Sexit n) k sp e m)

  | step_switch: forall f a cases default k sp e m n,
      eval_expr sp e m a (Vint n) ->
      step (State f (Sswitch a cases default) k sp e m)
        E0 (State f (Sexit (switch_target n default cases)) k sp e m)

  | step_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn None) k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k sp e m v m',
      eval_expr (Vptr sp Int.zero) e m a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn (Some a)) k (Vptr sp Int.zero) e m)
        E0 (Returnstate v (call_cont k) m')

  | step_label: forall f lbl s k sp e m,
      step (State f (Slabel lbl s) k sp e m)
        E0 (State f s k sp e m)

  | step_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k sp e m)
        E0 (State f s' k' sp e m)

  | step_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k (Vptr sp Int.zero) e m')
  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f sp e k m,
      step (Returnstate v (Kcall optid f sp e k) m)
        E0 (State f Sskip k sp (set_optvar optid v e) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p).

Lemma semantics_receptive:
  forall (p: program), receptive (semantics p).

Inductive outcome: Type :=
  | Out_normal: outcome                
  | Out_exit: nat -> outcome           
  | Out_return: option val -> outcome  
  | Out_tailcall_return: val -> outcome. 

Definition outcome_block (out: outcome) : outcome :=
  match out with
  | Out_exit O => Out_normal
  | Out_exit (S n) => Out_exit n
  | out => out
  end.

Definition outcome_result_value
    (out: outcome) (retsig: option typ) (vres: val) : Prop :=
  match out with
  | Out_normal => vres = Vundef
  | Out_return None => vres = Vundef
  | Out_return (Some v) => retsig <> None /\ vres = v
  | Out_tailcall_return v => vres = v
  | _ => False
  end.

Definition outcome_free_mem
    (out: outcome) (m: mem) (sp: block) (sz: Z) (m': mem) :=
  match out with
  | Out_tailcall_return _ => m' = m
  | _ => Mem.free m sp 0 sz = Some m'
  end.

Section NATURALSEM.

Variable ge: genv.

Inductive eval_funcall:
        mem -> fundef -> list val -> trace ->
        mem -> val -> Prop :=
  | eval_funcall_internal:
      forall m f vargs m1 sp e t e2 m2 out vres m3,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      exec_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t e2 m2 out ->
      outcome_result_value out f.(fn_sig).(sig_res) vres ->
      outcome_free_mem out m2 sp f.(fn_stackspace) m3 ->
      eval_funcall m (Internal f) vargs t m3 vres
  | eval_funcall_external:
      forall ef m args t res m',
      external_call ef ge args m t res m' ->
      eval_funcall m (External ef) args t m' res

with exec_stmt:
         function -> val ->
         env -> mem -> stmt -> trace ->
         env -> mem -> outcome -> Prop :=
  | exec_Sskip:
      forall f sp e m,
      exec_stmt f sp e m Sskip E0 e m Out_normal
  | exec_Sassign:
      forall f sp e m id a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sassign id a) E0 (PTree.set id v e) m Out_normal
  | exec_Sstore:
      forall f sp e m chunk addr a vaddr v m',
      eval_expr ge sp e m addr vaddr ->
      eval_expr ge sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      exec_stmt f sp e m (Sstore chunk addr a) E0 e m' Out_normal
  | exec_Scall:
      forall f sp e m optid sig a bl vf vargs fd t m' vres e',
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      eval_funcall m fd vargs t m' vres ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Scall optid sig a bl) t e' m' Out_normal
  | exec_Sbuiltin:
      forall f sp e m optid ef bl t m' vargs vres e',
      eval_exprlist ge sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Sbuiltin optid ef bl) t e' m' Out_normal
  | exec_Sifthenelse:
      forall f sp e m a s1 s2 v b t e' m' out,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      exec_stmt f sp e m (if b then s1 else s2) t e' m' out ->
      exec_stmt f sp e m (Sifthenelse a s1 s2) t e' m' out
  | exec_Sseq_continue:
      forall f sp e m t s1 t1 e1 m1 s2 t2 e2 m2 out,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 s2 t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sseq s1 s2) t e2 m2 out
  | exec_Sseq_stop:
      forall f sp e m t s1 s2 e1 m1 out,
      exec_stmt f sp e m s1 t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sseq s1 s2) t e1 m1 out
  | exec_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2 e2 m2 out,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 (Sloop s) t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sloop s) t e2 m2 out
  | exec_Sloop_stop:
      forall f sp e m t s e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sloop s) t e1 m1 out
  | exec_Sblock:
      forall f sp e m s t e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      exec_stmt f sp e m (Sblock s) t e1 m1 (outcome_block out)
  | exec_Sexit:
      forall f sp e m n,
      exec_stmt f sp e m (Sexit n) E0 e m (Out_exit n)
  | exec_Sswitch:
      forall f sp e m a cases default n,
      eval_expr ge sp e m a (Vint n) ->
      exec_stmt f sp e m (Sswitch a cases default)
                E0 e m (Out_exit (switch_target n default cases))
  | exec_Sreturn_none:
      forall f sp e m,
      exec_stmt f sp e m (Sreturn None) E0 e m (Out_return None)
  | exec_Sreturn_some:
      forall f sp e m a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sreturn (Some a)) E0 e m (Out_return (Some v))
  | exec_Stailcall:
      forall f sp e m sig a bl vf vargs fd t m' m'' vres,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      eval_funcall m' fd vargs t m'' vres ->
      exec_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t e m'' (Out_tailcall_return vres).

Scheme eval_funcall_ind2 := Minimality for eval_funcall Sort Prop
  with exec_stmt_ind2 := Minimality for exec_stmt Sort Prop.
Combined Scheme eval_funcall_exec_stmt_ind2
  from eval_funcall_ind2, exec_stmt_ind2.

CoInductive evalinf_funcall:
        mem -> fundef -> list val -> traceinf -> Prop :=
  | evalinf_funcall_internal:
      forall m f vargs m1 sp e t,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      execinf_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t ->
      evalinf_funcall m (Internal f) vargs t

with execinf_stmt:
         function -> val -> env -> mem -> stmt -> traceinf -> Prop :=
  | execinf_Scall:
      forall f sp e m optid sig a bl vf vargs fd t,
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      evalinf_funcall m fd vargs t ->
      execinf_stmt f sp e m (Scall optid sig a bl) t
  | execinf_Sifthenelse:
      forall f sp e m a s1 s2 v b t,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      execinf_stmt f sp e m (if b then s1 else s2) t ->
      execinf_stmt f sp e m (Sifthenelse a s1 s2) t
  | execinf_Sseq_1:
      forall f sp e m t s1 s2,
      execinf_stmt f sp e m s1 t ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sseq_2:
      forall f sp e m t s1 t1 e1 m1 s2 t2,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 s2 t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sloop_body:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 (Sloop s) t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sblock:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sblock s) t
  | execinf_Stailcall:
      forall f sp e m sig a bl vf vargs fd m' t,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      evalinf_funcall m' fd vargs t ->
      execinf_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t.

End NATURALSEM.

Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
  | bigstep_program_terminates_intro:
      forall b f m0 t m r,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      eval_funcall ge m0 f nil t m (Vint r) ->
      bigstep_program_terminates p t r.

Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
  | bigstep_program_diverges_intro:
      forall b f m0 t,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      evalinf_funcall ge m0 f nil t ->
      bigstep_program_diverges p t.

Definition bigstep_semantics (p: program) :=
  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).

Section BIGSTEP_TO_TRANSITION.

Variable prog: program.
Let ge := Genv.globalenv prog.

Inductive outcome_state_match
        (sp: val) (e: env) (m: mem) (f: function) (k: cont):
        outcome -> state -> Prop :=
  | osm_normal:
      outcome_state_match sp e m f k
                          Out_normal
                          (State f Sskip k sp e m)
  | osm_exit: forall n,
      outcome_state_match sp e m f k
                          (Out_exit n)
                          (State f (Sexit n) k sp e m)
  | osm_return_none: forall k',
      call_cont k' = call_cont k ->
      outcome_state_match sp e m f k
                          (Out_return None)
                          (State f (Sreturn None) k' sp e m)
  | osm_return_some: forall k' a v,
      call_cont k' = call_cont k ->
      eval_expr ge sp e m a v ->
      outcome_state_match sp e m f k
                          (Out_return (Some v))
                          (State f (Sreturn (Some a)) k' sp e m)
  | osm_tail: forall v,
      outcome_state_match sp e m f k
                          (Out_tailcall_return v)
                          (Returnstate v (call_cont k) m).

Remark is_call_cont_call_cont:
  forall k, is_call_cont (call_cont k).

Remark call_cont_is_call_cont:
  forall k, is_call_cont k -> call_cont k = k.

Lemma eval_funcall_exec_stmt_steps:
  (forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m'))
/\(forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S).

Lemma eval_funcall_steps:
   forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m').
Proof (proj1 eval_funcall_exec_stmt_steps).

Lemma exec_stmt_steps:
   forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S.
Proof (proj2 eval_funcall_exec_stmt_steps).

Lemma evalinf_funcall_forever:
  forall m fd args T k,
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.

Theorem bigstep_semantics_sound:
  bigstep_sound (bigstep_semantics prog) (semantics prog).

End BIGSTEP_TO_TRANSITION. *)

Require Import Cminorgen.

Require Import sepcomp.mem_lemmas.
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.core_semantics.

Require Import sepcomp.Cminor_coop.

Require Import sepcomp.Csharpminor_coop.

Require Import sepcomp.CminorgenproofRestructured.



Require Import Coq.Program.Equality.



Lemma allocvars_blocks_valid: forall vars E m e m1,

 alloc_variables E m vars e m1 ->

 forall b, Mem.valid_block m b -> Mem.valid_block m1 b.

Proof.

  intros. induction H; simpl in *.  assumption.

  apply IHalloc_variables. eapply Mem.valid_block_alloc; eauto.

Qed.



Lemma storev_valid_block_1:

forall ch m addr v m',

Mem.storev ch m addr v = Some m' ->

(forall b, Mem.valid_block m b -> Mem.valid_block m' b).

Proof. intros. destruct addr; inv H. eapply Mem.store_valid_block_1; eauto. Qed.



Lemma storev_valid_block_2:

forall ch m addr v m',

Mem.storev ch m addr v = Some m' ->

(forall b, Mem.valid_block m' b -> Mem.valid_block m b).

Proof. intros. destruct addr; inv H. eapply Mem.store_valid_block_2; eauto. Qed.



Lemma add_global_find_symbol: forall {F V} (g: Genv.t F V) m0 m x

    (G: Genv.alloc_global (Genv.add_global g x) m0 x = Some m)

    (N: Genv.genv_next g = Mem.nextblock m0)

    b (VB: Mem.valid_block m b),

    Mem.valid_block m0 b \/

    exists id, Genv.find_symbol (Genv.add_global g x) id = Some b.

Proof. intros.

unfold Genv.alloc_global in G.

destruct x. destruct g0.

   remember (Mem.alloc m0 0 1) as d.

   destruct d; inv G. apply eq_sym in Heqd.

   apply (Mem.drop_perm_valid_block_2 _ _ _ _ _ _ H0) in VB. clear H0.

   apply (Mem.valid_block_alloc_inv _ _ _ _ _ Heqd) in VB.

   destruct VB; subst; try (left; assumption).

     right. unfold Genv.add_global; simpl.

     unfold Genv.find_symbol; simpl.

     rewrite N. apply Mem.alloc_result in Heqd. subst.

     exists i. apply PTree.gss.

remember (Mem.alloc m0 0 (Genv.init_data_list_size (gvar_init v))) as d.

  destruct d; inv G. apply eq_sym in Heqd.

  remember (store_zeros m1 b0 0 (Genv.init_data_list_size (gvar_init v))) as q.

  destruct q; inv H0. apply eq_sym in Heqq.

  remember (Genv.store_init_data_list (Genv.add_global g (i, Gvar v)) m2 b0 0

         (gvar_init v)) as w.

  destruct w; inv H1. apply eq_sym in Heqw.

  apply (Mem.drop_perm_valid_block_2 _ _ _ _ _ _ H0) in VB. clear H0.

  assert (VB2: Mem.valid_block m2 b). unfold Mem.valid_block.

    rewrite <- (@Genv.store_init_data_list_nextblock _ _ _ _ _ _ _ _ Heqw).

    apply VB.

  clear VB Heqw.

  assert (VB1: Mem.valid_block m1 b). unfold Mem.valid_block.

    rewrite <- (@Genv.store_zeros_nextblock _ _ _ _ _ Heqq).

    apply VB2.

  clear VB2 Heqq.

  apply (Mem.valid_block_alloc_inv _ _ _ _ _ Heqd) in VB1.

   destruct VB1; subst; try (left; assumption).

     right. unfold Genv.add_global; simpl.

     unfold Genv.find_symbol; simpl.

     rewrite N. apply Mem.alloc_result in Heqd. subst.

     exists i. apply PTree.gss.

Qed.



Lemma genv_find_add_global_fresh: forall {F V} (g:Genv.t F V) i i0 v0

   (I:i0 <> i),

   Genv.find_symbol (Genv.add_global g (i0, v0)) i =

   Genv.find_symbol g i.

Proof. intros.

    unfold Genv.find_symbol, Genv.genv_symb. simpl. rewrite PTree.gso. reflexivity.

    intros N. apply I; subst; trivial.

Qed.



Lemma genv_find_add_globals_fresh: forall {F V} defs (g:Genv.t F V) i

  (G: ~ In i (map fst defs)),

  Genv.find_symbol (Genv.add_globals g defs) i =  Genv.find_symbol g i.

Proof. intros F V defs.

  induction defs; simpl; intros. trivial.

  destruct a.

  rewrite IHdefs.

    unfold Genv.find_symbol, Genv.genv_symb. simpl. rewrite PTree.gso. reflexivity.

    intros N. apply G; left. subst; simpl; trivial.

  intros N. apply G; right; trivial.

Qed.



Lemma add_globals_find_symbol: forall {F V} (defs : list (ident * globdef F V))

    (R: list_norepet (map fst defs)) (g: Genv.t F V) m0 m

    (G: Genv.alloc_globals (Genv.add_globals g defs) m0 defs = Some m)

    (N: Genv.genv_next g = Mem.nextblock m0)

    b (VB: Mem.valid_block m b),

    Mem.valid_block m0 b \/

    exists id, Genv.find_symbol (Genv.add_globals g defs) id = Some b.

Proof. intros F V defs.

induction defs; simpl; intros.

  inv G. left; trivial.

remember (Genv.alloc_global (Genv.add_globals (Genv.add_global g a) defs) m0 a) as d.

  destruct d; inv G. apply eq_sym in Heqd.

  inv R.

  specialize (IHdefs H3 _ _ _ H0). simpl in *.

  rewrite N in *.

  assert (P: Pos.succ (Mem.nextblock m0) = Mem.nextblock m1).

    clear IHdefs N VB H0.

    rewrite (@Genv.alloc_global_nextblock _ _ _ _ _ _ Heqd). trivial.

  destruct (IHdefs P _ VB); try (right; assumption).

  clear IHdefs P VB H0.

  destruct a. destruct g0. simpl in Heqd.

   remember (Mem.alloc m0 0 1) as t.

   destruct t; inv Heqd. apply eq_sym in Heqt.

   apply (Mem.drop_perm_valid_block_2 _ _ _ _ _ _ H1) in H. clear H1.

   apply (Mem.valid_block_alloc_inv _ _ _ _ _ Heqt) in H.

   destruct H; subst; try (left; assumption).

     right. apply Mem.alloc_result in Heqt. subst.

     exists i. rewrite genv_find_add_globals_fresh; trivial.

     unfold Genv.find_symbol, Genv.genv_symb. simpl.

     rewrite PTree.gss. rewrite N. trivial.

simpl in *.

  remember (Mem.alloc m0 0 (Genv.init_data_list_size (gvar_init v))) as t.

  destruct t; inv Heqd. apply eq_sym in Heqt.

  remember (store_zeros m2 b0 0 (Genv.init_data_list_size (gvar_init v))) as q.

  destruct q; inv H1. apply eq_sym in Heqq.

  remember (Genv.store_init_data_list

         (Genv.add_globals (Genv.add_global g (i, Gvar v)) defs) m3 b0 0

         (gvar_init v)) as w.

  destruct w; inv H4. apply eq_sym in Heqw.

  apply (Mem.drop_perm_valid_block_2 _ _ _ _ _ _ H1) in H. clear H1.

  assert (VB3: Mem.valid_block m3 b). unfold Mem.valid_block.

    rewrite <- (@Genv.store_init_data_list_nextblock _ _ _ _ _ _ _ _ Heqw).

    apply H.

  clear H Heqw.

  assert (VB2: Mem.valid_block m2 b). unfold Mem.valid_block.

    rewrite <- (@Genv.store_zeros_nextblock _ _ _ _ _ Heqq).

    apply VB3.

  clear VB3 Heqq.

  apply (Mem.valid_block_alloc_inv _ _ _ _ _ Heqt) in VB2.

   destruct VB2; subst; try (left; assumption).

     right. apply Mem.alloc_result in Heqt. subst.

     exists i. rewrite genv_find_add_globals_fresh; trivial.

     unfold Genv.find_symbol, Genv.genv_symb. simpl.

     rewrite PTree.gss. rewrite N. trivial.

Qed.



Section TRANSLATION.

Variable prog: Csharpminor.program.

Variable tprog: Cminor.program.

Hypothesis TRANSL: transl_program prog = OK tprog.

Let ge : Csharpminor.genv := Genv.globalenv prog.



Let tge: genv := Genv.globalenv tprog.



Let core_data := CSharpMin_core.



Inductive match_cores: core_data -> meminj -> CSharpMin_core -> mem -> CMin_core -> mem -> Prop :=

  | MC_states:

      forall d fn s k e le m tfn ts tk sp te tm cenv xenv j lo hi cs sz

      (TRF: transl_funbody cenv sz fn = OK tfn)

      (TR: transl_stmt cenv xenv s = OK ts)

      (MINJ: Mem.inject j m tm)

      (MCS: match_callstack prog j m tm

               (Frame cenv tfn e le te sp lo hi :: cs)

               (Mem.nextblock m) (Mem.nextblock tm))

      (MK: match_cont k tk  cenv xenv cs)

      (PG: meminj_preserves_globals ge j),

      match_cores d j (CSharpMin_State fn s k e le) m

                   (CMin_State tfn ts tk (Vptr sp Int.zero) te) tm

  | MC_state_seq:

      forall d fn s1 s2 k e le m tfn ts1 tk sp te tm cenv xenv j lo hi cs sz

      (TRF: transl_funbody cenv sz fn = OK tfn)

      (TR: transl_stmt cenv xenv s1 = OK ts1)

      (MINJ: Mem.inject j m tm)

      (MCS: match_callstack prog j m tm

               (Frame cenv tfn e le te sp lo hi :: cs)

               (Mem.nextblock m) (Mem.nextblock tm))

      (MK: match_cont (Csharpminor.Kseq s2 k) tk cenv xenv cs)

      (PG: meminj_preserves_globals ge j),

      match_cores d j (CSharpMin_State fn (Csharpminor.Sseq s1 s2) k e le) m

                   (CMin_State tfn ts1 tk (Vptr sp Int.zero) te) tm

  | MC_callstate:

      forall d fd args k m tfd targs tk tm j cs cenv

      (TR: transl_fundef fd = OK tfd)

      (MINJ: Mem.inject j m tm)

      (MCS: match_callstack prog j m tm cs (Mem.nextblock m) (Mem.nextblock tm))

      (MK: match_cont k tk cenv nil cs)

      (ISCC: Csharpminor.is_call_cont k)

      (ARGSINJ: val_list_inject j args targs)

      (PG: meminj_preserves_globals ge j),



      match_cores d j (CSharpMin_Callstate fd args k) m

                   (CMin_Callstate tfd targs tk) tm

  | MC_returnstate:

      forall d v k m tv tk tm j cs cenv

      (MINJ: Mem.inject j m tm)

      (MCS: match_callstack prog j m tm cs (Mem.nextblock m) (Mem.nextblock tm))

      (MK: match_cont k tk cenv nil cs)

      (RESINJ: val_inject j v tv)

      (PG: meminj_preserves_globals ge j),

      match_cores d j (CSharpMin_Returnstate v k) m

                   (CMin_Returnstate tv tk) tm.



Lemma match_cores_valid:

forall d j c1 m1 c2 m2,  match_cores d j c1 m1 c2 m2 ->

          forall b1 b2 ofs, j b1 = Some(b2,ofs) ->

               (Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2).

Proof.

intros.

inv H.

  split. eapply Mem.valid_block_inject_1; eassumption.

         eapply Mem.valid_block_inject_2; eassumption.

  split. eapply Mem.valid_block_inject_1; eassumption.

         eapply Mem.valid_block_inject_2; eassumption.

  split. eapply Mem.valid_block_inject_1; eassumption.

         eapply Mem.valid_block_inject_2; eassumption.

  split. eapply Mem.valid_block_inject_1; eassumption.

         eapply Mem.valid_block_inject_2; eassumption.

Qed.



Lemma match_cores_genvs:

forall d j c1 m1 c2 m2,  match_cores d j c1 m1 c2 m2 ->

          meminj_preserves_globals ge j.

Proof.

intros.

inv H; trivial.

Qed.



Lemma valid_init_is_global :

  forall (R: list_norepet (map fst (prog_defs prog)))

  m (G: Genv.init_mem prog = Some m)

  b (VB: Mem.valid_block m b),

  exists id, Genv.find_symbol (Genv.globalenv prog) id = Some b.

Proof. intros.

  unfold Genv.init_mem, Genv.globalenv in G. simpl in *.

  destruct (add_globals_find_symbol _ R (@Genv.empty_genv _ _ ) _ _ G (eq_refl _) _ VB)

    as [VBEmpty | X]; trivial.

  exfalso. clear - VBEmpty. unfold Mem.valid_block in VBEmpty.

    rewrite Mem.nextblock_empty in VBEmpty. xomega.

Qed.



Lemma match_globalenvs_init':

  forall (R: list_norepet (map fst (prog_defs prog)))

  m j,

  Genv.init_mem prog = Some m ->

  meminj_preserves_globals ge j ->

  match_globalenvs prog j (Mem.nextblock m).

Proof.

  intros.

  destruct H0 as [A [B C]].

  constructor.

  intros b D. intros [[id E]|[[gv E]|[fptr E]]]; eauto.

  cut (exists id, Genv.find_symbol (Genv.globalenv prog) id = Some b).

  intros [id ID].

  solve[eapply A; eauto].

  eapply valid_init_is_global; eauto.

  intros. symmetry. solve[eapply (C _ _ _ _ H0); eauto].

  intros. eapply Genv.find_symbol_not_fresh; eauto.

  intros. eapply Genv.find_funct_ptr_not_fresh ; eauto.

  intros. eapply Genv.find_var_info_not_fresh; eauto.

Qed.



Lemma init_cores: forall (v1 v2 : val) (sig : signature) entrypoints

  (EP: In (v1, v2, sig) entrypoints)

  (entry_points_ok :

    forall v1 v2 sig,

      In (v1, v2, sig) entrypoints ->

      exists b f1 f2,

        v1 = Vptr b Int.zero

        /\ v2 = Vptr b Int.zero

        /\ Genv.find_funct_ptr ge b = Some f1

        /\ Genv.find_funct_ptr tge b = Some f2)

  (vals1 : list val) (c1 : core_data) (m1 : mem) (j : meminj)

  (vals2 : list val) (m2 : mem)

  (CSM_Ini : initial_core CSharpMin_core_sem ge v1 vals1 = Some c1)

  (Inj : Mem.inject j m1 m2)

  (VI: Forall2 (val_inject j) vals1 vals2)

  (PG: meminj_preserves_globals ge j)

  (R: list_norepet (map fst (prog_defs prog)))

  (INIT_MEM: exists m0, Genv.init_mem prog = Some m0

    /\ Ple (Mem.nextblock m0) (Mem.nextblock m1)

    /\ Ple (Mem.nextblock m0) (Mem.nextblock m2)),

exists c2 : CMin_core,

  initial_core CMin_core_sem tge v2 vals2 = Some c2 /\

  match_cores c1 j c1 m1 c2 m2.

Proof. intros.

  inversion CSM_Ini. unfold  CSharpMin_initial_core in H0. unfold ge in *. unfold tge in *.

  destruct v1; inv H0.

  remember (Int.eq_dec i Int.zero) as z; destruct z; inv H1. clear Heqz.

  remember (Genv.find_funct_ptr (Genv.globalenv prog) b) as zz; destruct zz; inv H0.

    apply eq_sym in Heqzz.

  exploit function_ptr_translated; eauto. intros [tf [FIND TR]].

  exists (CMin_Callstate tf vals2 Cminor.Kstop).

  split.

  simpl.

  destruct (entry_points_ok _ _ _ EP) as [b0 [f1 [f2 [A [B [C D]]]]]].

  subst. inv A. rewrite C in Heqzz. inv Heqzz. rewrite D in FIND. inv FIND.

  unfold CMin_initial_core.

  case_eq (Int.eq_dec Int.zero Int.zero). intros ? e.

  solve[rewrite D; auto].

  intros CONTRA.

  solve[elimtype False; auto].

  eapply MC_callstate with (cenv:=PTree.empty _)(cs := @nil frame); try eassumption.

  destruct INIT_MEM as [m0 [INIT_MEM [A B]]].

  assert (Genv.init_mem tprog = Some m0).

    unfold transl_program in TRANSL.

    solve[eapply Genv.init_mem_transf_partial in TRANSL; eauto].

  apply mcs_nil with (Mem.nextblock m0).

  apply match_globalenvs_init'; auto.

  apply A. apply B.

  econstructor. simpl. trivial.

  simpl. apply forall_inject_val_list_inject; auto.

Qed.



Lemma MC_safely_halted: forall (cd : core_data) (j : meminj) (c1 : CSharpMin_core) (m1 : mem)

  (c2 : CMin_core) (m2 : mem) (v1 : val),

match_cores cd j c1 m1 c2 m2 ->

halted CSharpMin_core_sem  c1 = Some v1 ->

exists v2,

halted CMin_core_sem c2 = Some v2 /\ Mem.inject j m1 m2 /\

val_inject j v1 v2.

Proof.

  intros.

  inv H; simpl in *; inv H0.

  destruct k; inv H1. exists tv.

  split.

         inv MK. trivial.

  split; trivial.

Qed.



Lemma MC_at_external: forall (cd : core_data) (j : meminj) (st1 : CSharpMin_core) (m1 : mem)

  (st2 : CMin_core) (m2 : mem) (e : external_function) (vals1 : list val) sig,

(cd = st1 /\ match_cores cd j st1 m1 st2 m2) ->

at_external CSharpMin_core_sem st1 = Some (e, sig, vals1) ->

Mem.inject j m1 m2 /\

Events.meminj_preserves_globals ge j /\

(exists vals2 : list val,

   Forall2 (val_inject j) vals1 vals2 /\

   at_external CMin_core_sem st2 = Some (e, sig, vals2)).

Proof.

  intros. destruct H; subst.

  inv H1; simpl in *; inv H0.

  split; trivial.

  split. destruct (match_callstack_match_globalenvs _ _ _ _ _ _ _ MCS) as [hi Hhi].

              eapply inj_preserves_globals; eassumption.

  destruct fd; inv H1.

  exists targs.

  split. eapply val_list_inject_forall_inject; eassumption.

  inv TR.

  split; trivial.

Qed.



Lemma MC_after_external:forall (d : core_data) (j j' : meminj) (st1 : core_data) (st2 : CMin_core)

  (m1 : mem) (e : external_function) (vals1 : list val) (ret1 : val)

  (m1' m2 m2' : mem) (ret2 : val) (sig : signature),

d = st1 /\ match_cores d j st1 m1 st2 m2 ->

at_external CSharpMin_core_sem st1 = Some (e, sig, vals1) ->

Events.meminj_preserves_globals ge j ->

inject_incr j j' ->

Events.inject_separated j j' m1 m2 ->

Mem.inject j' m1' m2' ->

val_inject j' ret1 ret2 ->

mem_forward m1 m1' ->

Mem.unchanged_on (Events.loc_unmapped j) m1 m1' ->

mem_forward m2 m2' ->

Mem.unchanged_on (Events.loc_out_of_reach j m1) m2 m2' ->

exists st1' : core_data,

  exists st2' : CMin_core,

    exists d' : core_data,

      after_external CSharpMin_core_sem (Some ret1) st1 = Some st1' /\

      after_external CMin_core_sem (Some ret2) st2 = Some st2' /\

      d' = st1' /\ match_cores d' j' st1' m1' st2' m2'.

Proof. intros.

  destruct (MC_at_external _ _ _ _ _ _ _ _ _ H H0)

    as [_ [_ [vals2 [ValsInj AtExt2]]]].

  destruct H as [X MC]; subst.

  inv MC; simpl in *; inv H0.

  destruct fd; inv H10.

  destruct tfd; inv AtExt2.

  exists (CSharpMin_Returnstate ret1 k). eexists. eexists.

    split. reflexivity.

    split. reflexivity.

    split. reflexivity.

  simpl in *.

  econstructor; try eassumption.

  clear TR H10.

  destruct k; simpl in *; try contradiction. 

  

      inv MK; simpl in *.

      apply match_callstack_incr_bound with (Mem.nextblock m1) (Mem.nextblock m2).

      eapply match_callstack_external_call; eauto.

          intros. eapply H6; eauto.

          xomega.

          xomega.

         eapply forward_nextblock; assumption.

         eapply forward_nextblock; assumption.

  

      inv MK; simpl in *.

      apply match_callstack_incr_bound with (Mem.nextblock m1) (Mem.nextblock m2).

      eapply match_callstack_external_call; eauto.

          intros. eapply H6; eauto.

          xomega.

          xomega.

         eapply forward_nextblock; assumption.

         eapply forward_nextblock; assumption.

  solve [eapply meminj_preserves_incr_sep; eassumption].

Qed.



Lemma MC_MSI: forall d j

       q m q' m',

      match_cores d j q m q' m' ->

      match_statesInj prog j  (ToState q m) (Cminor_coop.ToState q' m').

  Proof. intros.

    inv H; simpl in *.

     eapply matchInj_state; try eassumption.

     eapply matchInj_state_seq; try eassumption.

     eapply matchInj_callstate; try eassumption.

     eapply matchInj_returnstate; try eassumption.

Qed.



Lemma MSI_MC: forall j q m q' m' d

       (PG: meminj_preserves_globals ge j),

      match_statesInj prog j (ToState q m) (Cminor_coop.ToState q' m') ->

      match_cores d j q m q' m'.

  Proof. intros.

    inv H; simpl in *.

     destruct q; simpl in *; inv H2.

        destruct q'; simpl in *; inv H3.

        eapply MC_states; try eassumption.

     destruct q; simpl in *; inv H2.

        destruct q'; simpl in *; inv H3.

        eapply MC_state_seq; try eassumption.

     destruct q; simpl in *; inv H2.

        destruct q'; simpl in *; inv H3.

        eapply MC_callstate; try eassumption.

     destruct q; simpl in *; inv H2.

        destruct q'; simpl in *; inv H3.

        eapply MC_returnstate; try eassumption.

Qed.



Lemma MSI_atExt: forall j c1 m1 c2 m2

(H: match_statesInj prog j (ToState c1 m1) (Cminor_coop.ToState c2 m2) ),

(CSharpMin_at_external c1 = None) = (CMin_at_external c2 = None).

Proof.

  intros.

  destruct c1; destruct c2; inv H; simpl in *; trivial.

  destruct f; destruct f0; simpl in *; trivial.

   apply bind_inversion in TR. destruct TR as [z [ZZ1 ZZ2]]; subst.

  inv ZZ2.

  inv TR.

  inv TR.

  apply prop_ext. split; intros; inv H.

Qed.



Parameter MC_order :  core_data -> core_data -> Prop.

Parameter MC_wellfounded: well_founded MC_order.

Definition MC_measure (q:CSharpMin_core): nat :=

  match q with

  | CSharpMin_State fn s k e lenv => seq_left_depth s

  | _ => O

  end.



Lemma MS_step_case_SkipSeq:

forall cenv sz f tfn j m tm  e lenv te sp lo hi cs s k tk xenv

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MK : match_cont (Csharpminor.Kseq s k) tk cenv xenv cs)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State tfn Sskip tk (Vptr sp Int.zero) te) tm c2' m2' /\

        match_cores (CSharpMin_State f s k e lenv) j (CSharpMin_State f s k e lenv) m c2' m2'.



Proof. intros.

  dependent induction MK.



  eexists. eexists.

  split.

    apply corestep_plus_one.

        eapply CompCertStep_CMin_corestep'.  simpl.  econstructor. reflexivity.

  simpl. 
 eapply MC_states; eauto.



  eexists. eexists.

  split.

    apply corestep_plus_one.

        eapply CompCertStep_CMin_corestep'.  simpl.  econstructor. reflexivity.

   simpl. 
 eapply MC_state_seq; eauto.



  exploit IHMK; eauto. clear IHMK.  intros [T2 [m2 [A C]]].

  exists T2; exists m2.

  split.

     eapply corestep_star_plus_trans.

        apply corestep_star_one.  eapply CompCertStep_CMin_corestep'.  simpl.  constructor. reflexivity.

        simpl. apply A.

  apply C.

Qed.



Lemma MS_step_case_SkipBlock:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MK : match_cont (Csharpminor.Kblock k) tk cenv xenv cs)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State tfn Sskip tk (Vptr sp Int.zero) te) tm c2' m2' /\

         match_cores  (CSharpMin_State f Csharpminor.Sskip k e lenv)   j (CSharpMin_State f Csharpminor.Sskip k e lenv) m c2' m2'

.

Proof. intros.

  dependent induction MK.



  eexists. eexists.

  split.

    apply corestep_plus_one.

        eapply CompCertStep_CMin_corestep'.  simpl. constructor. reflexivity.

   simpl. 
 eapply MC_states; eauto.



  exploit IHMK; eauto. clear IHMK.  intros [T2 [m2 [A C]]].

  exists T2; exists m2.

  split.

     eapply corestep_star_plus_trans.

        apply corestep_star_one.  eapply CompCertStep_CMin_corestep'.  simpl.  constructor. reflexivity.

        simpl. apply A.

   apply C.

Qed.



Lemma MS_match_is_call_cont:

  forall tfn te sp tm k tk cenv xenv cs,

  match_cont k tk cenv xenv cs ->

  Csharpminor.is_call_cont k ->

  exists tk',

    corestep_star CMin_core_sem tge (CMin_State tfn Sskip tk sp te) tm

                (CMin_State tfn Sskip tk' sp te) tm

    /\ is_call_cont tk'

    /\ match_cont k tk' cenv nil cs.

Proof.

  induction 1; simpl; intros; try contradiction.

  econstructor; split.

     apply corestep_star_zero. split. exact I. econstructor; eauto.

  exploit IHmatch_cont; eauto.

  intros [tk' [A B]]. exists tk'; split.

  eapply corestep_star_trans; eauto. apply corestep_star_one. simpl. eexists. constructor. auto.



  econstructor; split. apply corestep_star_zero. split. exact I. econstructor; eauto.

Qed.



Lemma MS_step_case_SkipCall:

 forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv m'

(CC: Csharpminor.is_call_cont k)

(FL: Mem.free_list m (blocks_of_env e) = Some m')

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MK : match_cont k tk cenv xenv cs)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State  tfn Sskip tk (Vptr sp Int.zero) te) tm c2' m2' /\

         match_cores  (CSharpMin_Returnstate Vundef k)  j (CSharpMin_Returnstate Vundef k) m' c2' m2'.



Proof. intros.

  exploit MS_match_is_call_cont; eauto. intros [tk' [A [B C]]].

  exploit match_callstack_freelist; eauto. intros [tm' [P [Q R]]].



  eexists. eexists.

  split.

    eapply corestep_star_plus_trans. eexact A. apply corestep_plus_one.

      eapply CompCertStep_CMin_corestep'. apply step_skip_call. assumption.

      eauto.

    eauto.

    econstructor; eauto.

Qed.



Lemma MS_step_case_Assign:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv  x a x0 v id

(EE:Csharpminor.eval_expr ge e lenv m a v)

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MK : match_cont k tk cenv xenv cs)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(EQ : transl_expr cenv a = OK (x, x0))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

    corestep_plus CMin_core_sem tge

     (CMin_State tfn (Sassign id x) tk (Vptr sp Int.zero) te) tm c2' m2' /\

   match_cores

     (CSharpMin_State f Csharpminor.Sskip k e (PTree.set id v lenv)) j

     (CSharpMin_State f Csharpminor.Sskip k e (PTree.set id v lenv)) m c2'

     m2'.



Proof. intros.

 intros.

  exploit transl_expr_correct; eauto. intros [tv [EVAL [VINJ APP]]].



  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

         econstructor. eassumption. reflexivity.

inv MCS.

  econstructor; eauto.

econstructor; eauto.

eapply match_temps_assign; assumption.

Qed.



Lemma MS_step_case_Store:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv x x0 x1 x2

      chunk m' a addr vaddr v

(CH: Mem.storev chunk m vaddr v = Some m')

(EvAddr : Csharpminor.eval_expr ge e lenv m addr vaddr)

(EvA : Csharpminor.eval_expr ge e lenv m a v)

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

                (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

(EQ : transl_expr cenv addr = OK (x, x0))

(EQ1 : transl_expr cenv a = OK (x1, x2))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State  tfn (make_store chunk x x1) tk (Vptr sp Int.zero) te) tm c2' m2' /\

        match_cores (CSharpMin_State f Csharpminor.Sskip k e lenv) j

                      (CSharpMin_State f Csharpminor.Sskip k e lenv) m' c2' m2' .



Proof. intros.

  exploit transl_expr_correct. eauto. eauto. eauto. eexact EvAddr. eauto.

  intros [tv1 [EVAL1 [VINJ1 APP1]]].

  exploit transl_expr_correct. eauto. eauto. eauto. eexact EvA. eauto.

  intros [tv2 [EVAL2 [VINJ2 APP2]]].

  exploit make_store_correct. eexact EVAL1. eexact EVAL2. eauto. eauto. auto. auto.

  intros [tm' [tv' [EXEC [STORE' MINJ']]]].

  eexists; eexists; split.

      apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. eexact EXEC. reflexivity.

  simpl in *.

  inv VINJ1; simpl in CH; try discriminate.

  econstructor; eauto.

  rewrite (Mem.nextblock_store _ _ _ _ _ _ CH).

  rewrite (Mem.nextblock_store _ _ _ _ _ _ STORE').

  eapply match_callstack_invariant ; eauto.

  intros. eapply Mem.perm_store_2; eauto.

  intros. eapply Mem.perm_store_1; eauto.

Qed.



Lemma MS_step_case_Call:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv  x x0 x1 a vf fd optid vargs bl

(EvalA: Csharpminor.eval_expr ge e lenv m a vf)

(EvalBL: Csharpminor.eval_exprlist ge e lenv m bl vargs)

(FF: Genv.find_funct ge vf = Some fd)

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont tk k cenv xenv cs)

(EQ : transl_expr cenv a = OK (x, x0))

(EQ1 : transl_exprlist cenv bl = OK x1)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge

             (CMin_State  tfn (Scall optid (Csharpminor.funsig fd) x x1)  k (Vptr sp Int.zero) te) tm c2' m2' /\

       match_cores (CSharpMin_Callstate fd vargs (Csharpminor.Kcall optid f e lenv tk))  j

              (CSharpMin_Callstate fd vargs (Csharpminor.Kcall optid f e lenv tk)) m c2' m2'.



Proof. intros.

  simpl in FF. exploit functions_translated; eauto. intros [tfd [FIND TRANS]].

  exploit transl_expr_correct; eauto. intros [tvf [EVAL1 [VINJ1 APP1]]].

  assert (tvf = vf).

    exploit match_callstack_match_globalenvs; eauto. intros [bnd MG].

    eapply val_inject_function_pointer; eauto.

  subst tvf.

  exploit transl_exprlist_correct; eauto.

  intros [tvargs [EVAL2 VINJ2]].

  eexists; eexists; split.

      apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

          eapply step_call. eassumption. eassumption. apply FIND.

                      eapply sig_preserved; eauto.

          econstructor; eauto.

  simpl in *.

     
 econstructor; eauto. eapply match_Kcall with (cenv' := cenv); eauto.

            simpl; trivial.

Qed.



Lemma MS_step_case_Builtin:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv x t ef optid vres m' bl vargs

(EvalArgs: Csharpminor.eval_exprlist ge e lenv m bl vargs)

(ExtCall: Events.external_call ef ge vargs m t vres m')

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

(EQ : transl_exprlist cenv bl = OK x)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

      corestep_plus CMin_core_sem tge

           (CMin_State tfn (Sbuiltin optid ef x) tk (Vptr sp Int.zero) te) tm c2' m2' /\

  exists j' : meminj,

        inject_incr j j' /\

        Events.inject_separated j j' m tm /\

       match_cores (CSharpMin_State f Csharpminor.Sskip k e (set_optvar optid vres lenv))  j'

              (CSharpMin_State f Csharpminor.Sskip k e (set_optvar optid vres lenv)) m' c2' m2'.



Proof. intros.

  exploit transl_exprlist_correct; eauto.

  intros [tvargs [EVAL2 VINJ2]].

  exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].

  exploit Events.external_call_mem_inject; eauto.

  intros [j' [vres' [tm' [EC [VINJ [MINJ' [UNMAPPED [OUTOFREACH [INCR SEPARATED]]]]]]]]].

  eexists; eexists; split.

      apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

           econstructor; try eassumption.

             eapply Events.external_call_symbols_preserved; eauto.

                 eapply symbols_preserved; assumption.

                 eapply varinfo_preserved; assumption.

           reflexivity.

  assert (MCS': match_callstack prog j' m' tm'

                 (Frame cenv tfn e lenv te sp lo hi :: cs)

                 (Mem.nextblock m') (Mem.nextblock tm')).

    apply match_callstack_incr_bound with (Mem.nextblock m) (Mem.nextblock tm).

    eapply match_callstack_external_call; eauto.

    intros. eapply Events.external_call_max_perm; eauto.

    xomega. xomega.

    eapply external_call_nextblock; eauto.

    eapply external_call_nextblock; eauto.

exists j'. split. assumption.  split. assumption.

  simpl in *. 
 econstructor; eauto.

Opaque PTree.set.

  unfold set_optvar. destruct optid; simpl.

  eapply match_callstack_set_temp; eauto.

  auto.

solve [eapply meminj_preserves_incr_sep; eassumption].

Qed.



Lemma MS_step_case_Ite:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv x x0 x1 x2 b v a s1 s2

(H : Csharpminor.eval_expr ge e lenv m a v)

(BoolOfVal : Val.bool_of_val v b)

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

(EQ : transl_expr cenv a = OK (x, x0))

(EQ1 : transl_stmt cenv xenv s1 = OK x1)

(EQ0 : transl_stmt cenv xenv s2 = OK x2)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge

             (CMin_State tfn (Sifthenelse x x1 x2) tk (Vptr sp Int.zero) te) tm c2' m2' /\

        match_cores  (CSharpMin_State f (if b then s1 else s2) k e lenv)  j

             (CSharpMin_State f (if b then s1 else s2) k e lenv) m c2' m2'.



Proof. intros.

  exploit transl_expr_correct; eauto. intros [tv [EVAL [VINJ APP]]].

  exists (CMin_State tfn (if b then x1 else x2) tk (Vptr sp Int.zero) te). exists tm.

  split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep.

              eapply step_ifthenelse; eauto. eapply bool_of_val_inject; eauto.

        econstructor; eauto.

  simpl in *.

 
 econstructor; eauto.

       destruct b; auto.

Qed.



Lemma MS_step_case_Loop:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv x s

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont tk k cenv xenv cs)

(EQ : transl_stmt cenv xenv s = OK x)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

      corestep_plus CMin_core_sem tge (CMin_State tfn (Sloop x) k (Vptr sp Int.zero) te) tm c2' m2' /\

      match_cores  (CSharpMin_State f s (Csharpminor.Kseq (Csharpminor.Sloop s) tk) e lenv)  j

          (CSharpMin_State f s (Csharpminor.Kseq (Csharpminor.Sloop s) tk) e lenv) m c2' m2'.



Proof. intros.

  eexists; eexists.

  split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

        econstructor; eauto.

        reflexivity.

  simpl in *.



      econstructor; eauto. econstructor; eauto. simpl. rewrite EQ; auto.

Qed.



Lemma MS_step_case_Block:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv x s

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont tk k cenv xenv cs)

(EQ : transl_stmt cenv (true :: xenv) s = OK x)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State tfn (Sblock x) k (Vptr sp Int.zero) te) tm c2' m2' /\

        match_cores (CSharpMin_State f s (Csharpminor.Kblock tk) e lenv) j

                    (CSharpMin_State f s (Csharpminor.Kblock tk) e lenv) m c2' m2'.



Proof. intros.

  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

        econstructor; eauto.

        reflexivity.

  simpl in *.



      econstructor; eauto. econstructor; eauto.

Qed.



Lemma MS_step_case_ExitSeq:

forall  cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv n s

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont (Csharpminor.Kseq s tk) k cenv xenv cs)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge

               (CMin_State tfn (Sexit (shift_exit xenv n)) k (Vptr sp Int.zero) te) tm c2' m2'  /\

        match_cores (CSharpMin_State f (Csharpminor.Sexit n) tk e lenv) j

                               (CSharpMin_State f (Csharpminor.Sexit n) tk e lenv) m c2' m2'.



Proof. intros.

  dependent induction MK.



  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'.

        econstructor; eauto.

        reflexivity.

  simpl in *.

      
 econstructor; eauto. reflexivity.



  exploit IHMK; eauto. intros [c2' [m2' [A B]]].

  exists c2'. exists m2'.

  split; auto.

     eapply corestep_plus_trans.

         apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. apply A.



  exploit IHMK; eauto.  intros [c2' [m2' [A B]]].

  exists c2'. exists m2'.

  split; auto.

     eapply corestep_plus_trans.

         apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. apply A.

Qed.



Lemma MS_step_case_ExitBlockZero:

forall  cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont (Csharpminor.Kblock tk) k cenv xenv cs)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

   corestep_plus CMin_core_sem tge

     (CMin_State tfn (Sexit (shift_exit xenv 0)) k (Vptr sp Int.zero) te) tm c2' m2' /\

   match_cores  (CSharpMin_State f Csharpminor.Sskip tk e lenv) j

                              (CSharpMin_State f Csharpminor.Sskip tk e lenv) m c2' m2'.



Proof. intros.

  dependent induction MK.



  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

  simpl in *.

    
 econstructor; eauto.



  exploit IHMK; eauto. intros [c2' [m2' [A B]]].

  exists c2'. exists m2'.

  split; auto.

     eapply corestep_plus_trans.

         apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. apply A.

Qed.



Lemma MS_step_case_ExitBlockNonzero:

forall  cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv n

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

                     (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont (Csharpminor.Kblock tk) k cenv xenv cs)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge

          (CMin_State tfn (Sexit (shift_exit xenv (S n))) k (Vptr sp Int.zero) te) tm c2' m2' /\

       match_cores (CSharpMin_State f (Csharpminor.Sexit n) tk e lenv)  j

          (CSharpMin_State f (Csharpminor.Sexit n) tk e lenv) m c2' m2'.

Proof. intros.

  dependent induction MK.



  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

  simpl in *.

    econstructor; eauto. auto.



  exploit IHMK; eauto. intros [c2' [m2' [A B]]].

  exists c2'. exists m2'.

  split; auto.

     eapply corestep_plus_trans.

         apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. apply A.

Qed.



Lemma MS_switch_descent:

  forall cenv xenv k ls body s,

  transl_lblstmt cenv (switch_env ls xenv) ls body = OK s ->

  exists k',

  transl_lblstmt_cont cenv xenv ls k k'

  /\ (forall f sp e m,

      corestep_plus CMin_core_sem tge (CMin_State f s k sp e) m (CMin_State f body k' sp e) m).

Proof.

  induction ls; intros.



  monadInv H.

  eexists; split.

      econstructor; eauto.

  intros. eapply corestep_plus_trans.

                   apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

                   simpl.  apply corestep_plus_one. eapply CompCertStep_CMin_corestep.  constructor. reflexivity.



  monadInv H. exploit IHls; eauto. intros [k' [A B]].

  eexists; split.

      econstructor; eauto.

  intros. eapply corestep_plus_star_trans. eauto.

  eapply corestep_star_trans.

      apply corestep_star_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

      simpl. apply corestep_star_one. eapply CompCertStep_CMin_corestep.  constructor. reflexivity.

Qed.



Lemma MS_switch_ascent:

  forall f n sp e m cenv xenv k ls k1,

  let tbl := switch_table ls O in

  let ls' := select_switch n ls in

  transl_lblstmt_cont cenv xenv ls k k1 ->

  exists k2,

  corestep_star CMin_core_sem tge

    (CMin_State f (Sexit (Switch.switch_target n (length tbl) tbl)) k1 sp e) m

    (CMin_State f (Sexit O) k2 sp e) m

  /\ transl_lblstmt_cont cenv xenv ls' k k2.

Proof.

  induction ls; intros; unfold tbl, ls'; simpl.



  inv H.

  eexists; split.

     apply corestep_star_zero.

     econstructor; eauto.



  simpl in H. inv H.

  rewrite Int.eq_sym. destruct (Int.eq i n).

  econstructor; split.  apply corestep_star_zero. econstructor; eauto.

  exploit IHls; eauto. intros [k2 [A B]].

  rewrite (length_switch_table ls 1%nat 0%nat).

  rewrite switch_table_shift.

  exists k2; split; try exact B.

  eapply corestep_star_trans.

        eapply corestep_star_one.  eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

        simpl. eapply corestep_star_trans.

          eapply corestep_star_one.  eapply CompCertStep_CMin_corestep'. econstructor. reflexivity.

          apply A.

Qed.



Lemma MS_switch_MSI:

  forall fn k e lenv m tfn ts tk sp te tm cenv xenv j lo hi cs sz ls body tk'

    (TRF: transl_funbody cenv sz fn = OK tfn)

    (TR: transl_lblstmt cenv (switch_env ls xenv) ls body = OK ts)

    (MINJ: Mem.inject j m tm)

    (MCS: match_callstack prog j m tm

               (Frame cenv tfn e lenv te sp lo hi :: cs)

               (Mem.nextblock m) (Mem.nextblock tm))

    (MK: match_cont k tk cenv xenv cs)

    (TK: transl_lblstmt_cont cenv xenv ls tk tk'),

  exists S, exists mm,

  corestep_plus CMin_core_sem tge (CMin_State tfn (Sexit O) tk' (Vptr sp Int.zero) te) tm S mm

  /\ match_statesInj prog j (Csharpminor.State fn (seq_of_lbl_stmt ls) k e lenv m) (Cminor_coop.ToState S mm).

Proof.

  intros. destruct ls; simpl.



  inv TK. econstructor; eexists; split.

     eapply corestep_plus_trans.

         eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

    simpl. eapply matchInj_state; eauto.



  inv TK. econstructor; eexists; split.

     eapply corestep_plus_trans.

         eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

         simpl. eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

    simpl.

       eapply matchInj_state_seq; eauto.

        simpl. eapply  switch_match_cont; eauto.

Qed.



Lemma MS_step_case_Switch:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv a x x0 ts cases n

(EvalA: Csharpminor.eval_expr ge e lenv m a (Vint n))

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

(EQ : transl_expr cenv a = OK (x, x0))

(EQ0 : transl_lblstmt cenv (switch_env cases xenv) cases

        (Sswitch x (switch_table cases 0) (length (switch_table cases 0))) =

      OK ts)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

          corestep_plus CMin_core_sem tge (CMin_State tfn ts tk (Vptr sp Int.zero) te) tm c2' m2' /\

         match_cores (CSharpMin_State f (seq_of_lbl_stmt (select_switch n cases)) k e lenv)  j

                               (CSharpMin_State f (seq_of_lbl_stmt (select_switch n cases)) k e lenv) m c2' m2'.

Proof. intros.

  exploit transl_expr_correct; eauto. intros [tv [EVAL [VINJ APP]]].

  inv VINJ.

  exploit MS_switch_descent; eauto. intros [k1 [A B]].

  exploit MS_switch_ascent; eauto. intros [k2 [C D]].

  exploit transl_lblstmt_suffix; eauto. simpl. intros [body' [ts' E]].

  exploit MS_switch_MSI; eauto. intros [T2 [m2' [F G]]].

  exists T2; exists m2'; split.

      eapply corestep_plus_star_trans.

          eapply B.

      eapply corestep_star_trans.

         eapply corestep_star_one. eapply CompCertStep_CMin_corestep'. constructor. eassumption. reflexivity.

      simpl.

        eapply corestep_star_trans.

         apply C.

         eapply corestep_plus_star. eapply F.

  simpl. eapply MSI_MC. apply PG. apply G.

Qed.



Lemma MS_step_case_ReturnNone:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv m'

(Freelist: Mem.free_list m (blocks_of_env e) = Some m')

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

                 (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont tk k cenv xenv cs)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State tfn (Sreturn None) k (Vptr sp Int.zero) te) tm c2' m2'  /\

       match_cores (CSharpMin_Returnstate Vundef (Csharpminor.call_cont tk))  j

                             (CSharpMin_Returnstate Vundef (Csharpminor.call_cont tk)) m' c2' m2'.

Proof. intros.

  exploit match_callstack_freelist; eauto. intros [tm' [A [B C]]].

  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. eapply step_return_0. eauto. reflexivity.

  simpl in *.

    econstructor; eauto. eapply match_call_cont; eauto.

Qed.



Lemma MS_step_case_ReturnSome:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv a x x0 m' v

(EvalA: Csharpminor.eval_expr ge e lenv m a v)

(Freelist: Mem.free_list m (blocks_of_env e) = Some m')

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont tk k cenv xenv cs)

(EQ : transl_expr cenv a = OK (x, x0))

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

        corestep_plus CMin_core_sem tge (CMin_State tfn (Sreturn (Some x)) k (Vptr sp Int.zero) te) tm c2' m2' /\

        match_cores  (CSharpMin_Returnstate v (Csharpminor.call_cont tk)) j

                 (CSharpMin_Returnstate v (Csharpminor.call_cont tk)) m' c2' m2'.

Proof. intros.

  exploit transl_expr_correct; eauto. intros [tv [EVAL [VINJ APP]]].

  exploit match_callstack_freelist; eauto. intros [tm' [A [B C]]].

  eexists; eexists; split.

     apply corestep_plus_one. eapply CompCertStep_CMin_corestep'. eapply step_return_1. eauto. eauto. reflexivity.

  simpl in *.

    econstructor; eauto. eapply match_call_cont; eauto.

Qed.



Lemma MS_step_case_Label:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv lbl x s

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

(EQ : transl_stmt cenv xenv s = OK x)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

       corestep_plus CMin_core_sem tge (CMin_State tfn (Slabel lbl x) tk (Vptr sp Int.zero) te) tm c2' m2' /\

      match_cores (CSharpMin_State f s k e lenv)  j (CSharpMin_State f s k e lenv) m c2' m2'.

Proof. intros.

  eexists; eexists; split.

    eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. constructor. reflexivity.

  simpl.

  econstructor; eauto.

Qed.



Lemma MS_step_case_Goto:

forall cenv sz f tfn j m tm e lenv te sp lo hi cs k tk xenv lbl s' k'

(FindLab: Csharpminor.find_label lbl (Csharpminor.fn_body f)

       (Csharpminor.call_cont k) = Some (s', k'))

(TRF : transl_funbody cenv sz f = OK tfn)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm (Frame cenv tfn e lenv te sp lo hi :: cs)

        (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv xenv cs)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

       corestep_plus CMin_core_sem tge (CMin_State tfn (Sgoto lbl) tk (Vptr sp Int.zero) te) tm c2' m2' /\

       match_cores  (CSharpMin_State f s' k' e lenv) j (CSharpMin_State f s' k' e lenv) m c2' m2'.

Proof. intros.

  exploit transl_find_label_body; eauto.

  intros [ts' [tk' [xenv' [A [B C]]]]].

  eexists; eexists; split.

    eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. apply step_goto. eexact A. reflexivity.

  simpl.

  econstructor; eauto.

Qed.



Lemma MS_match_callstack_alloc_variables_rec:

  forall tm sp tf cenv le te lo cs,

  Mem.valid_block tm sp ->

  fn_stackspace tf <= Int.max_unsigned ->

  (forall ofs k p, Mem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) ->

  (forall ofs k p, 0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) ->

  forall e1 m1 vars e2 m2,

  alloc_variables e1 m1 vars e2 m2 ->

  forall f1,

  list_norepet (map fst vars) ->

  cenv_compat cenv vars (fn_stackspace tf) ->

  cenv_separated cenv vars ->

  cenv_mem_separated cenv vars f1 sp m1 ->

  (forall id sz, In (id, sz) vars -> e1!id = None) ->

  match_callstack prog f1 m1 tm

    (Frame (cenv_remove cenv vars) tf e1 le te sp lo (Mem.nextblock m1) :: cs)

    (Mem.nextblock m1) (Mem.nextblock tm) ->

  Mem.inject f1 m1 tm ->

  exists f2,

    match_callstack prog f2 m2 tm

      (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)

      (Mem.nextblock m2) (Mem.nextblock tm)

  /\ Mem.inject f2 m2 tm

  /\  inject_incr f1 f2



  /\ (forall b, Mem.valid_block m1 b -> f2 b = f1 b)

  /\ (forall b b' d', f1 b = None -> f2 b = Some (b',d') -> b' = sp)

  /\ forall j',  inject_incr f2 j' -> inject_separated f2 j' m2 tm ->

                 inject_separated f2 j' m1 tm.

Proof.

Proof.

  intros until cs; intros VALID REPRES STKSIZE STKPERMS.

  induction 1; intros f1 NOREPET COMPAT SEP1 SEP2 UNBOUND MCS MINJ.

  

  simpl in MCS. exists f1.

   split. assumption.

   split. assumption.

   split. apply inject_incr_refl.

   split. auto.

   split. intros. rewrite H in H0; inv H0.

   intros. assumption.

  

  simpl in NOREPET. inv NOREPET.



  exploit (COMPAT id sz). auto with coqlib. intros [ofs [CENV [ALIGNED [LOB HIB]]]].

  exploit Mem.alloc_left_mapped_inject.

    eexact MINJ.

    eexact H.

    eexact VALID.

    instantiate (1 := ofs). zify. omega.

    intros. exploit STKSIZE; eauto. omega.

    intros. apply STKPERMS. zify. omega.

    replace (sz - 0) with sz by omega. auto.

    intros. eapply SEP2. eauto with coqlib. eexact CENV. eauto. eauto. omega.

  intros [f2 [A [B [C D]]]].

  exploit (IHalloc_variables f2); eauto.

    red; intros. eapply COMPAT. auto with coqlib.

    red; intros. eapply SEP1; eauto with coqlib.

    red; intros. exploit Mem.perm_alloc_inv; eauto. destruct (eq_block b b1); intros P.

    subst b. rewrite C in H5; inv H5.

    exploit SEP1. eapply in_eq. eapply in_cons; eauto. eauto. eauto.

    red; intros; subst id0. elim H3. change id with (fst (id, sz0)). apply in_map; auto.

    omega.

    eapply SEP2. apply in_cons; eauto. eauto.

    rewrite D in H5; eauto. eauto. auto.

    intros. rewrite PTree.gso. eapply UNBOUND; eauto with coqlib.

    red; intros; subst id0. elim H3. change id with (fst (id, sz0)). apply in_map; auto.

    eapply match_callstack_alloc_left; eauto.

    rewrite cenv_remove_gso; auto.

    apply UNBOUND with sz; auto with coqlib.

  intros. destruct H1 as [f3 [HF1 [HF2 [Hf3 [HF4 [HF5 HF6]]]]]].

    exists f3. split; trivial.

    split; trivial.

    split. eapply inject_incr_trans; eassumption.

    split. intros.

        rewrite HF4.

         apply D.

           intros N; subst.

               eapply (Mem.fresh_block_alloc _ _ _ _ _ H H1).

           apply (Mem.valid_block_alloc _ _ _ _ _ H _ H1).

    split; intros.

       destruct (eq_block b b1); subst.

       rewrite (Hf3 _ _ _ C) in H2. inv H2. trivial.

       specialize (D _ n).

         rewrite <- D in H1. apply (HF5 _ _ _ H1 H2).

    intros b; intros.

      destruct (H2 _ _ _ H5 H6).

      split; trivial.

      intros N. apply H7; clear H7.

      apply (Mem.valid_block_alloc _ _ _ _ _ H) in N.

      eapply alloc_variables_forward. eassumption. apply N.

Qed.



Lemma MS_match_callstack_alloc_variables_aux:

  forall tm1 sp tm2 m1 vars e m2 cenv f1 cs fn le te,

  Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp) ->

  fn_stackspace fn <= Int.max_unsigned ->

  alloc_variables empty_env m1 vars e m2 ->

  list_norepet (map fst vars) ->

  cenv_compat cenv vars (fn_stackspace fn) ->

  cenv_separated cenv vars ->

  (forall id ofs, cenv!id = Some ofs -> In id (map fst vars)) ->

  Mem.inject f1 m1 tm1 ->

  match_callstack prog f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1) ->

  match_temps f1 le te ->

  exists f2,

    match_callstack prog f2 m2 tm2 (Frame cenv fn e le te sp (Mem.nextblock m1) (Mem.nextblock m2) :: cs)

                    (Mem.nextblock m2) (Mem.nextblock tm2)

  /\ Mem.inject f2 m2 tm2

  /\  inject_incr f1 f2



  /\ (forall b, Mem.valid_block m1 b -> f2 b = f1 b)

  /\ (forall b b' d', f1 b = None -> f2 b = Some (b',d') -> b' = sp)

  /\ forall j',  inject_incr f2 j' -> Events.inject_separated f2 j' m2 tm2 ->

          Events.inject_separated f2 j' m1 tm1.

Proof. clear core_data.

  intros.

  unfold build_compilenv in H.

assert (AR: exists f',

   match_callstack prog f' m2 tm2

                     (Frame cenv fn e le te sp (Mem.nextblock m1) (Mem.nextblock m2) :: cs)

                     (Mem.nextblock m2) (Mem.nextblock tm2)



  /\ Mem.inject f' m2 tm2

  /\ inject_incr f1 f'

  /\ (forall b, Mem.valid_block m1 b -> f' b = f1 b)

  /\ (forall b b' d', f1 b = None -> f' b = Some (b',d') -> b' = sp)

  /\ forall j',  inject_incr f' j' -> Events.inject_separated f' j' m2 tm2 ->

                  Events.inject_separated f' j' m1 tm2).



  eapply MS_match_callstack_alloc_variables_rec; eauto with mem.

   red; intros. eelim Mem.fresh_block_alloc; eauto.

  eapply Mem.valid_block_inject_2; eauto.

  intros. apply PTree.gempty.

  eapply match_callstack_alloc_right; eauto.

  intros. destruct (In_dec peq id (map fst vars)).

  apply cenv_remove_gss; auto.

  rewrite cenv_remove_gso; auto.

  destruct (cenv!id) as [ofs|] eqn:?; auto. elim n; eauto.

  eapply Mem.alloc_right_inject; eauto.



destruct AR as  [f' [INC [INJ [MC [VB1 [SP SEP]]]]]].

exists f' ; intuition.

  intros b; intros.

  remember (f' b) as z; destruct z; apply eq_sym in Heqz.

   destruct p.

            assert (j' b = Some (b0,z)). apply (H9 _ _ _ Heqz). inv H11.

    assert (HH:= SEP _ H9 H10).

                     destruct (HH _ _ _ Heqz H12).

                     split; trivial.

                     intros N. apply H14. eapply Mem.valid_block_alloc; eauto.

Qed.



Lemma MS_match_callstack_alloc_variables:

  forall tm1 sp tm2 m1 vars e m2 cenv f1 cs fn le te,

  Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp) ->

  fn_stackspace fn <= Int.max_unsigned ->

  alloc_variables empty_env m1 vars e m2 ->

  list_norepet (map fst vars) ->

  cenv_compat cenv vars (fn_stackspace fn) ->

  cenv_separated cenv vars ->

  (forall id ofs, cenv!id = Some ofs -> In id (map fst vars)) ->

  Mem.inject f1 m1 tm1 ->

  match_callstack prog f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1) ->

  match_temps f1 le te ->

  exists f2,

    match_callstack prog f2 m2 tm2 (Frame cenv fn e le te sp (Mem.nextblock m1) (Mem.nextblock m2) :: cs)

                    (Mem.nextblock m2) (Mem.nextblock tm2)

  /\ Mem.inject f2 m2 tm2

  /\  inject_incr f1 f2

  /\  inject_separated f1 f2 m1 tm1.

Proof.

  intros.

  destruct (MS_match_callstack_alloc_variables_aux

     _ _ _ _ _ _ _ _ _ _ _ _ _ H H0 H1 H2 H3 H4 H5 H6 H7 H8)

     as [f2 [MCS2 [INJ2 [INC [HH1 [HH2 HH3]]]]]].

  exists f2.

  split; trivial.

  split; trivial.

  split; trivial.

  intros b; intros.

  specialize (HH2 _ _ _ H9 H10); subst.

  split. intros N. rewrite (HH1 _ N) in H10.

         rewrite H10 in H9; discriminate.

  eapply (Mem.fresh_block_alloc _ _ _ _ _ H).

Qed.



Theorem MS_match_callstack_function_entry:

  forall fn cenv tf m e m' tm tm' sp f cs args targs le,

  build_compilenv fn = (cenv, tf.(fn_stackspace)) ->

  tf.(fn_stackspace) <= Int.max_unsigned ->

  list_norepet (map fst (Csharpminor.fn_vars fn)) ->

  list_norepet (Csharpminor.fn_params fn) ->

  list_disjoint (Csharpminor.fn_params fn) (Csharpminor.fn_temps fn) ->

  alloc_variables Csharpminor.empty_env m (Csharpminor.fn_vars fn) e m' ->

  bind_parameters (Csharpminor.fn_params fn) args (create_undef_temps fn.(fn_temps)) = Some le ->

  val_list_inject f args targs ->

  Mem.alloc tm 0 tf.(fn_stackspace) = (tm', sp) ->

  match_callstack prog f m tm cs (Mem.nextblock m) (Mem.nextblock tm) ->

  Mem.inject f m tm ->

  let te := set_locals (Csharpminor.fn_temps fn) (set_params targs (Csharpminor.fn_params fn)) in

  exists f',

     match_callstack prog f' m' tm'

                     (Frame cenv tf e le te sp (Mem.nextblock m) (Mem.nextblock m') :: cs)

                     (Mem.nextblock m') (Mem.nextblock tm')

  /\ Mem.inject f' m' tm'

  /\  inject_incr f f'

  /\  inject_separated f f' m tm.

Proof.

  intros.

  exploit build_compilenv_sound; eauto. intros [C1 C2].

  eapply MS_match_callstack_alloc_variables; eauto.

  intros. eapply build_compilenv_domain; eauto.

  eapply bind_parameters_agree; eauto.

Qed.



Lemma MS_step_case_InternalCall:

forall cenv  f j m tm e cs k tk vargs targs x m1 lenv

(Param1: list_norepet (map fst (Csharpminor.fn_vars f)))

(Param2 : list_norepet (Csharpminor.fn_params f))

(Param3 : list_disjoint (Csharpminor.fn_params f) (fn_temps f))

(AlocVars : alloc_variables empty_env m (Csharpminor.fn_vars f) e m1)

(BindParams: bind_parameters (Csharpminor.fn_params f) vargs

       (create_undef_temps (fn_temps f)) = Some lenv)

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm cs (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont k tk cenv nil cs)

(ISCC : Csharpminor.is_call_cont k)

(ARGSINJ : val_list_inject j vargs targs)

(EQ : transl_function f = OK x)

 (PG: meminj_preserves_globals ge j),

exists (c2' : CMin_core) (m2' : mem),

  corestep_plus CMin_core_sem tge (CMin_Callstate (AST.Internal x) targs tk) tm c2' m2'

 /\ exists (j' : meminj),

  inject_incr j j' /\

  inject_separated j j' m tm /\

  match_cores (CSharpMin_State f (Csharpminor.fn_body f) k e lenv) j'

    (CSharpMin_State f (Csharpminor.fn_body f) k e lenv) m1 c2' m2'.

Proof. intros.

  generalize EQ; clear EQ; unfold transl_function.

  caseEq (build_compilenv f). intros ce sz BC.

  destruct (zle sz Int.max_unsigned).

  Focus 2. intros. exfalso. clear core_data.  congruence. 


  intro TRBODY.

  generalize TRBODY; intro TMP. monadInv TMP.

  set (tf := mkfunction (Csharpminor.fn_sig f)

                        (Csharpminor.fn_params f)

                        (Csharpminor.fn_temps f)

                        sz

                        x0) in *.

  caseEq (Mem.alloc tm 0 (fn_stackspace tf)). intros tm' sp ALLOC'.

  exploit MS_match_callstack_function_entry; eauto. simpl; eauto. simpl; auto.

  intros [j' [MCS2 [MINJ2 [IINCR SEP]]]].

  exists (CMin_State tf x0 tk (Vptr sp Int.zero)

     (set_locals (fn_temps f) (set_params targs (Csharpminor.fn_params f)))).

  exists tm'.

  split.

    eapply corestep_plus_one. simpl.

    econstructor.

    constructor. assumption. reflexivity.

  exists j'. split. assumption.

  split. assumption.

  econstructor. eexact TRBODY. eauto. eexact MINJ2.

  eexact MCS2.

  inv MK; simpl in ISCC; contradiction || econstructor; eauto.

solve [eapply meminj_preserves_incr_sep; eassumption].

Qed.



Lemma MS_step_case_Return:

forall j m tm cs f e lenv k tk cenv v tv optid

(MINJ : Mem.inject j m tm)

(MCS : match_callstack prog j m tm cs (Mem.nextblock m) (Mem.nextblock tm))

(MK : match_cont (Csharpminor.Kcall optid f e lenv k) tk cenv nil cs)

(RESINJ : val_inject j v tv)

 (PG: meminj_preserves_globals ge j),

exists c2' : CMin_core,

  exists m2' : mem,

       corestep_plus CMin_core_sem tge (CMin_Returnstate tv tk) tm c2' m2'  /\

       match_cores  (CSharpMin_State f Csharpminor.Sskip k e (set_optvar optid v lenv)) j

             (CSharpMin_State f Csharpminor.Sskip k e (set_optvar optid v lenv)) m c2' m2' .

Proof. intros.

  inv MK. simpl.

  eexists; eexists; split.

       eapply corestep_plus_one. eapply CompCertStep_CMin_corestep'. econstructor; eauto. reflexivity.

  simpl.

  unfold set_optvar. destruct optid; simpl option_map; econstructor; eauto.

         eapply match_callstack_set_temp; eauto.

Qed.



Lemma MS_step: forall (c1 : core_data) (m1 : mem) (c1' : core_data) (m1' : mem),

corestep CSharpMin_core_sem ge c1 m1 c1' m1' ->

forall (c2 : CMin_core) (m2 : mem) (j : meminj),

match_cores c1 j c1 m1 c2 m2 ->

(exists c2' : CMin_core,

   exists m2' : mem,

     exists j' : meminj,

       inject_incr j j' /\

       Events.inject_separated j j' m1 m2 /\

       corestep_plus CMin_core_sem tge c2 m2 c2' m2' /\

       match_cores c1' j' c1' m1' c2' m2') \/

(MC_measure c1' < MC_measure c1)%nat /\ match_cores c1' j c1' m1' c2 m2.

Proof.

  intros. unfold core_data in *.

   destruct (CSharpMin_corestep_2_CompCertStep _ _ _ _ _ H) as [t Ht]. simpl in *.

  apply CSharpMin_corestep_not_at_external in H.

   assert (PG:= match_cores_genvs _ _ _ _ _ _ H0).

   apply MC_MSI in H0. rename H0 into MSTATE.

   inv Ht; simpl in *.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

      destruct (MS_step_case_SkipSeq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        TRF MINJ MK MCS PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

      destruct (MS_step_case_SkipBlock _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        TRF MINJ MK MCS PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H10.

      destruct (MS_step_case_SkipCall  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H2 H4 TRF MINJ MK MCS PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

   

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H9.

      rename  m1' into m'. rename m' into m.

      rename m2 into tm. rename k0 into tk.

      rename f0 into tfn. rename e0 into te.

      rename le0 into lenv.

      destruct (MS_step_case_Assign  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        id H3 TRF MINJ MK MCS EQ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

   

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H11.

      rename f0 into tfn. rename m1 into m. rename m2  into tm.

      rename e0 into te. rename k0 into tk. rename  m1' into m'.

      destruct (MS_step_case_Store _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H5 H2 H3 TRF MINJ MCS MK EQ EQ1 PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

   

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H11.

      rename f into fd. rename f0 into f. rename f1 into tfn.

      rename m1' into m. rename m2  into tm. rename e into te.

      rename e0 into e.  rename k0 into tk. rename  le0 into le.

      destruct (MS_step_case_Call _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        optid _ _ H2 H3 H4 TRF MINJ MCS MK EQ EQ1 PG) as [c2' [m2' [cstepPlusMS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE; simpl in *.

      monadInv TR.

      destruct c2; simpl in *; try inv H10.

      rename f0 into tfn.

      rename m1 into m. rename m2  into tm. rename e into te.

      rename e0 into e.  rename k0 into tk. rename  le0 into le.  rename m1' into m'.

      destruct (MS_step_case_Builtin _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ optid

        _ _ _ _ H2 H4 TRF MINJ MCS MK EQ PG)

        as [c2' [m2' [cstepPlus [j' [InjIncr [InjSep MS]]]]]].

      left. exists c2'. exists m2'.  exists j'. auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

     rename k0 into k.

      inv MSTATE.

      

         monadInv TR. left.

         destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

         exists  (CMin_State tfn x (Kseq x0 tk) (Vptr sp Int.zero) te). exists m2.

         exists j.

                split. apply inject_incr_refl.

                split. apply inject_separated_same_meminj.

                split; simpl.

                    eapply corestep_plus_one.

                    eapply CompCertStep_CMin_corestep.

                    econstructor; eauto. reflexivity.

                econstructor; eauto.

                          econstructor; eauto.

      

         destruct c2; simpl in *; try inv H9.

         right. split. omega.

                   econstructor; eauto.



      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H10.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_Ite _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H2 H4 TRF MINJ MCS MK EQ EQ1 EQ0 PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_Loop _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        TRF MINJ MCS MK EQ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.  rename s0 into s.

      destruct (MS_step_case_Block _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        TRF MINJ MCS MK EQ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_ExitSeq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ n _

        TRF MINJ MCS MK PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_ExitBlockZero _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        TRF MINJ MCS MK PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

         rename f0 into tfn. rename e0 into te. rename k0 into tk.

      rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_ExitBlockNonzero _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        n TRF MINJ MCS MK PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H9.

         rename f0 into tfn.  rename e0 into te.

         rename k0 into tk. rename m1' into m. rename m2  into tm.  rename s into ts.

      destruct (MS_step_case_Switch _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H3 TRF MINJ MCS MK EQ EQ0 PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H9.

       rename f into tfn.  rename f0 into f. rename e into te. rename e0 into e.

         rename k0 into tk. rename m1 into m. rename m2  into tm.

         rename m1'  into m'.  rename le0 into le.

      destruct (MS_step_case_ReturnNone _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H3 TRF MINJ MCS MK PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H10.

       rename f into tfn.  rename f0 into f. rename e into te.

         rename e0 into e. rename k into tk.

         rename k0 into k. rename m1 into m. rename m2  into tm.

         rename m1'  into m'.  rename le0 into le. rename v0 into v.

      destruct (MS_step_case_ReturnSome _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H2 H4 TRF MINJ MCS MK EQ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H8.

       rename f0 into tfn. rename e0 into te.

         rename k0 into tk. rename m1' into m. rename m2  into tm. rename s0 into s.

      destruct (MS_step_case_Label _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        lbl _ _ TRF MINJ MCS MK EQ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

  

      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H9.

       rename f0 into tfn. rename e0 into te.

         rename k1 into tk. rename s into s'.  rename k into k'.

         rename k0 into k. rename m1' into m. rename m2  into tm.

      destruct (MS_step_case_Goto _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H3 TRF MINJ MCS MK PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.



      destruct c1; simpl in *; try inv H0.

      destruct c1'; simpl in *; try inv H1.

      inv MSTATE.

      monadInv TR.

      destruct c2; simpl in *; try inv H11.

      rename m1 into m. rename m2 into tm.

      rename f0 into f. rename e0 into e.

      rename m1' into m1. rename args into vargs.

      rename k0 into tk. rename le0 into lenv.

      rename args0 into targs.

      destruct (MS_step_case_InternalCall _ _ _ _ _ _ _ _ _ _ _ _ _ _

        H2 H3 H4 H5 H7 MINJ MCS MK ISCC ARGSINJ EQ PG)

        as [c2' [m2' [cstepPlus [j' [InjIncr [InjSep MS]]]]]].

      left. exists c2'. exists m2'. exists j'. auto.



      destruct c1; simpl in *; try inv H0. inv H.

   

      destruct c1; simpl in *; try inv H1.

      destruct c1'; simpl in *; try inv H3.

      inv MSTATE.

      destruct c2; simpl in *; try inv H5.

      rename m1' into m. rename m2 into tm. rename f0 into f.

      rename e0 into e. rename k into tk. rename k0 into k.

      rename v into tv. rename v0 into v.

      destruct (MS_step_case_Return _ _ _ _ _ _ _ _ _ _ _

        tv optid MINJ MCS MK RESINJ PG) as [c2' [m2' [cstepPlus MS]]].

      left. exists c2'. exists m2'. exists j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      auto.

Qed.



Require Import sepcomp.forward_simulations.



Require Import sepcomp.forward_simulations_lemmas.



Theorem transl_program_correct:

  forall (R: list_norepet (map fst (prog_defs prog)))

         entrypoints

         (entry_points_ok :

            forall v1 v2 sig,

              In (v1, v2, sig) entrypoints ->

              exists b f1 f2,

                v1 = Vptr b Int.zero

                /\ v2 = Vptr b Int.zero

                /\ Genv.find_funct_ptr ge b = Some f1

                /\ Genv.find_funct_ptr tge b = Some f2)

         (init_mem: exists m0, Genv.init_mem prog = Some m0),

  Forward_simulation_inj.Forward_simulation_inject

       CSharpMin_core_sem

       CMin_core_sem ge tge entrypoints.

Proof.

intros.

 eapply inj_simulation_star with

  (match_states:=match_cores)(measure:=MC_measure).

 

    unfold genvs_domain_eq, genv2blocks.

    simpl; split; intros.

     split; intros; destruct H as [id Hid].

      rewrite <- (symbols_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     rewrite (symbols_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     split; intros; destruct H as [id Hid].

      rewrite <- (varinfo_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     rewrite (varinfo_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

  apply match_cores_valid.

  apply match_cores_genvs.

 

    intros.

    eapply (init_cores _ _ _ entrypoints); eauto.

    destruct init_mem as [m0 INIT].

    exists m0; split; auto.

    unfold meminj_preserves_globals in H3.

    destruct H3 as [A [B C]].



    assert (P: forall p q, {Ple p q} + {Plt q p}).

      intros p q.

      case_eq (Pos.leb p q).

      intros TRUE.

      apply Pos.leb_le in TRUE.

      left; auto.

      intros FALSE.

      apply Pos.leb_gt in FALSE.

      right; auto.



    cut (forall b, Plt b (Mem.nextblock m0) ->

           exists id, Genv.find_symbol ge id = Some b). intro D.



    split.

    destruct (P (Mem.nextblock m0) (Mem.nextblock m1)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m1 (Mem.nextblock m1)).

      eapply Mem.valid_block_inject_1; eauto.

    clear - H4; unfold Mem.valid_block in H4.

    xomega.



    destruct (P (Mem.nextblock m0) (Mem.nextblock m2)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m2 (Mem.nextblock m2)).

      eapply Mem.valid_block_inject_2; eauto.

    clear - H4; unfold Mem.valid_block in H4.

    xomega.



    intros b LT.

    unfold ge.

    apply valid_init_is_global with (b := b) in INIT.

    eapply INIT; auto.

    apply R.

    apply LT.



  { intros.

    eapply MC_safely_halted in H; eauto.

    destruct H as [v2 [A [B C]]].

    solve[exists v2; split; auto]. }

  

  { intros.

    destruct (MC_at_external _ _ _ _ _ _ _ _ _ H H0)

           as [Inc [Presv [vals2 [ValsInj AtExt2]]]].

    split; trivial.

    exists vals2.

    split; trivial. }

 

 {  intros.

    assert (PG: meminj_preserves_globals ge j).

      destruct H; subst.

      apply (match_cores_genvs _ _ _ _ _ _ H9).

    destruct (MC_after_external _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0

             PG H1 H2 H3 H4 H5 H6 H7 H8)

           as [dd [core [dd' [afterExtA [afterExtB [ MC X]]]]]].

     subst. eexists; eexists. eexists.

        split. eassumption.

        split. eassumption.

        split. reflexivity. eassumption. }

  

  { intros. destruct (MS_step _ _ _ _ H _ _ _ H0).

    destruct H1 as [c2' [m2' [j' [INC [Sep [CSP MC]]]]]].

      exists c2', m2', j'.

       split; trivial.

       split; trivial.

       split; trivial.

       left; trivial.

    destruct H1.

      exists c2, m2, j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      split; trivial.

      right. split; trivial.

      apply corestep_star_zero. }

Qed.



Lemma MS_step_coopsem: forall (c1 : core_data) (m1 : mem) (c1' : core_data) (m1' : mem),

corestep csharpmin_coop_sem ge c1 m1 c1' m1' ->

forall (c2 : CMin_core) (m2 : mem) (j : meminj),

match_cores c1 j c1 m1 c2 m2 ->

(exists c2' : CMin_core,

   exists m2' : mem,

     exists j' : meminj,

       inject_incr j j' /\

       Events.inject_separated j j' m1 m2 /\

       corestep_plus cmin_coop_sem tge c2 m2 c2' m2' /\

       match_cores c1' j' c1' m1' c2' m2') \/

(MC_measure c1' < MC_measure c1)%nat /\ match_cores c1' j c1' m1' c2 m2.

Proof. intros.

  eapply MS_step; eauto.

Qed.



Theorem transl_program_correct_coopsem:

  forall (R: list_norepet (map fst (prog_defs prog)))

         entrypoints

         (entry_points_ok :

            forall v1 v2 sig,

              In (v1, v2, sig) entrypoints ->

              exists b f1 f2,

                v1 = Vptr b Int.zero

                /\ v2 = Vptr b Int.zero

                /\ Genv.find_funct_ptr ge b = Some f1

                /\ Genv.find_funct_ptr tge b = Some f2)

         (init_mem: exists m0, Genv.init_mem prog = Some m0),

  Forward_simulation_inj.Forward_simulation_inject csharpmin_coop_sem

   cmin_coop_sem ge tge entrypoints.

Proof.

intros.

 eapply inj_simulation_star with

  (match_states:=match_cores)(measure:=MC_measure).

 

    unfold genvs_domain_eq, genv2blocks.

    simpl; split; intros.

     split; intros; destruct H as [id Hid].

      rewrite <- (symbols_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     rewrite (symbols_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     split; intros; destruct H as [id Hid].

      rewrite <- (varinfo_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

     rewrite (varinfo_preserved _ _ TRANSL) in Hid.

      exists id; assumption.

  apply match_cores_valid.

  apply match_cores_genvs.

 

    intros.

    eapply (init_cores _ _ _ entrypoints); eauto.

    destruct init_mem as [m0 INIT].

    exists m0; split; auto.

    unfold meminj_preserves_globals in H3.

    destruct H3 as [A [B C]].



    assert (P: forall p q, {Ple p q} + {Plt q p}).

      intros p q.

      case_eq (Pos.leb p q).

      intros TRUE.

      apply Pos.leb_le in TRUE.

      left; auto.

      intros FALSE.

      apply Pos.leb_gt in FALSE.

      right; auto.



    cut (forall b, Plt b (Mem.nextblock m0) ->

           exists id, Genv.find_symbol ge id = Some b). intro D.



    split.

    destruct (P (Mem.nextblock m0) (Mem.nextblock m1)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m1 (Mem.nextblock m1)).

      eapply Mem.valid_block_inject_1; eauto.

    clear - H4; unfold Mem.valid_block in H4.

    xomega.



    destruct (P (Mem.nextblock m0) (Mem.nextblock m2)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m2 (Mem.nextblock m2)).

      eapply Mem.valid_block_inject_2; eauto.

    clear - H4; unfold Mem.valid_block in H4.

    xomega.



    intros b LT.

    unfold ge.

    apply valid_init_is_global with (b := b) in INIT.

    eapply INIT; auto.

    apply R.

    apply LT.

  

  { intros.

    eapply MC_safely_halted in H; eauto.

    destruct H as [v2 [A [B C]]].

    solve[exists v2; split; auto]. }

  

  { intros.

    destruct (MC_at_external _ _ _ _ _ _ _ _ _ H H0)

           as [Inc [Presv [vals2 [ValsInj AtExt2]]]].

    split; trivial.

    exists vals2.

    split; trivial. }

 

 {  intros.

    assert (PG: meminj_preserves_globals ge j).

      destruct H; subst.

      apply (match_cores_genvs _ _ _ _ _ _ H9).

    destruct (MC_after_external _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0

             PG H1 H2 H3 H4 H5 H6 H7 H8)

           as [dd [core [dd' [afterExtA [afterExtB [ MC X]]]]]].

     subst. eexists; eexists. eexists.

        split. eassumption.

        split. eassumption.

        split. reflexivity. eassumption. }

  

  { intros. destruct (MS_step_coopsem _ _ _ _ H _ _ _ H0).

    destruct H1 as [c2' [m2' [j' [INC [Sep [CSP MC]]]]]].

      exists c2', m2', j'.

       split; trivial.

       split; trivial.

       split; trivial.

       left; trivial.

    destruct H1.

      exists c2, m2, j.

      split. apply inject_incr_refl.

      split. apply inject_separated_same_meminj.

      split; trivial.

      right. split; trivial.

      apply corestep_star_zero. }

Qed.



End TRANSLATION.
