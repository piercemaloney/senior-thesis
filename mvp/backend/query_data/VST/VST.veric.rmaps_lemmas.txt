Require Import VST.msl.msl_standard.
(* VST.msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import VST.msl.cjoins.
(* VST.msl.cjoins:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.

Definition constructive_join_sub {A} {JOIN: Join A} (w1 w3: A) := {w2 | join w1 w2 w3}.

Lemma cjoin_sub_join_sub{A} {JOIN: Join A}:
    forall {w1 w3}, constructive_join_sub w1 w3 -> join_sub w1 w3.

Lemma cjoin_sub_irr {A} `{Perm_alg A}{CA: Canc_alg A}:
    forall {w1 w3: A} (j1 j2: constructive_join_sub w1 w3), proj1_sig j1 = proj1_sig j2.

Lemma cjoin_sub_trans {A} `{Perm_alg A}: forall a b c,
          constructive_join_sub a b -> constructive_join_sub b c -> constructive_join_sub a c.

Lemma constructive_join_sub_refl {A} `{Perm_alg A}{SA: Sep_alg A}: forall x, constructive_join_sub x x.

Hint Resolve @constructive_join_sub_refl.
Definition constructive_joins {A}  {JOIN: Join A} (w1 w2 : A) := {w3 | join w1 w2 w3}.

Lemma cjoins_joins {A}  {JOIN: Join A}: forall {w1 w2}, constructive_joins w1 w2 -> joins w1 w2.

Lemma cjoins_irr {A} `{Perm_alg A}: forall {w1 w2: A}
    (j1 j2: constructive_joins w1 w2), proj1_sig j1 = proj1_sig j2.

Lemma constructive_joins_sym {A} `{Perm_alg A}: forall a b,
      constructive_joins a b = constructive_joins b a.

Definition same_constructive_silhouette {A} {JOIN: Join A} (a b: A) :=
    forall c, (constructive_joins c a -> constructive_joins c b) *
                 (constructive_joins c b -> constructive_joins c a).

  Definition sub_constructive_silhouette {A} {JOIN: Join A}  (a b: A) :=
    forall c, constructive_joins c b -> constructive_joins c a.

  Lemma sub_constructive_silhouette_refl {A} {JOIN: Join A} : forall a, sub_constructive_silhouette a a.

  Lemma sub_constructive_silhouette_trans {A} {JOIN: Join A} : forall a b c,
    sub_constructive_silhouette a b -> sub_constructive_silhouette b c -> sub_constructive_silhouette a c.

  Lemma same_constructive_silhouette_refl {A} {JOIN: Join A} : forall a, same_constructive_silhouette a a.

  Lemma same_constructive_silhouette_sym {A} {JOIN: Join A}: forall a b,
    same_constructive_silhouette a b -> same_constructive_silhouette b a.

  Lemma same_constructive_silhouette_trans {A} {JOIN: Join A}: forall a b c,
    same_constructive_silhouette a b -> same_constructive_silhouette b c -> same_constructive_silhouette a c.

  Lemma same_constructive_silhouette_sub1{A} {JOIN: Join A}: forall a b,
    same_constructive_silhouette a b -> sub_constructive_silhouette a b.

  Lemma same_constructive_silhouette_sub2 {A} {JOIN: Join A}: forall a b,
     same_constructive_silhouette a b -> sub_constructive_silhouette b a.

  Lemma sub_same_constructive_silhouette {A} {JOIN: Join A}:
    forall a b, sub_constructive_silhouette a b -> sub_constructive_silhouette b a -> same_constructive_silhouette a b.

  Lemma same_constructive_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_constructive_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_constructive_silhouette phiz phiz'.

Lemma constructive_join_sub_joins_trans {A} {JA: Join A}{PA: Perm_alg A}: forall {a b c},
  constructive_join_sub a c -> constructive_joins c b -> constructive_joins a b.

Lemma join_constructive_join_sub1 {A} {JA: Join A}{PA: Perm_alg A}: forall {a b c},
  join a b c -> constructive_join_sub a c.

Lemma join_constructive_join_sub2 {A} {JA: Join A}{PA: Perm_alg A}: forall {a b c},
  join a b c -> constructive_join_sub b c.

Lemma join_constructive_joins {A} {JA: Join A}{PA: Perm_alg A}: forall {a b c},
  join a b c -> constructive_joins a b. *)

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Require Import VST.msl.sepalg_list.
(* VST.msl.sepalg_list:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.
Set Implicit Arguments.

Inductive fold_rel (A: Type) (f: A -> A -> A -> Prop):  A -> list A -> A -> Prop :=
| fold_rel_nil: forall w, fold_rel f w nil w
| fold_rel_cons: forall a l w w1 w2,
            f w a w1 ->
            fold_rel f w1 l w2 ->
            fold_rel f w (a::l) w2.

Inductive list_forall2 {A B} (P: A -> B -> Prop): list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 P nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 P al bl ->
      list_forall2 P (a1 :: al) (b1 :: bl).

Fixpoint replace (A: Type) (l: list A) (n:nat) (new: A) {struct n} : option (list A) :=
  match (l, n) with
    | (nil, n) => None
    | (x :: xs, O) => Some (new :: xs)
    | (x :: xs, S n) =>
      match (replace xs n new) with
        |  None => None
        |  Some xs => Some (x :: xs)
      end
  end.

Definition list_join {A} {JA: Join A}: A -> list A -> A -> Prop :=
   fold_rel join.

Lemma list_join_assoc1 {A} {JA: Join A}{PA: Perm_alg A}:
 forall {a b cl d e},
   join a b d -> list_join d cl e ->
  exists f, list_join b cl f /\ join a f e.

Lemma list_join_assoc2 {A}  {JA: Join A}{PA: Perm_alg A}:
  forall {a b: A} {cl e f},
   list_join b cl f -> join a f e ->
   exists d,  join a b d /\ list_join d cl e.

Lemma list_join_app {A} {JA: Join A}:
  forall {a: A} {bl c dl e},
   list_join a bl c -> list_join c dl e -> list_join a (bl++dl) e.

Lemma list_join_unapp {A}  {JA: Join A}:
  forall {a:A}  {bl dl e},
  list_join a (bl++dl) e -> exists c, list_join a bl c /\ list_join c dl e.

Lemma list_join_1 {A} {JA: Join A}:
  forall a b c: A, join a b c = list_join a (b::nil) c.

Definition age1_list {A} `{ageable A} := list_forall2 age.

Lemma age1_list_join {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall l (phi phi' phi2: A),
        age phi phi' ->
        list_join phi l phi2 ->
        exists l', exists phi2', age1_list l l' /\ age phi2 phi2' /\ list_join phi' l' phi2'.

Lemma age1_list_join2 {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall (l: list A) phi phi2 phi2',  age1 phi2 = Some phi2' -> list_join phi l phi2 ->
        exists l', exists phi',  age1 phi = Some phi' /\ age1_list l l' /\ list_join phi' l' phi2'.

Lemma list_join_split_nth {A}{JA: Join A}{PA: Perm_alg A}:
 forall n (l: list A) phin phi phia phib phi2,
  nth_error l n = Some phin -> list_join phi l phi2 -> join phib phia phin ->
           exists phic, exists l',
                 replace l n phib = Some l' /\ join phi phia phic /\ list_join phic l' phi2.

Lemma list_join_join_nth {A} {JA: Join A}{PA: Perm_alg A}:
 forall n (l: list A) phin phi phia phib phi2,
  nth_error l n = Some phin -> list_join phi l phi2 -> join phi2 phia phib ->
           exists phic, exists l',
                 join phin phia phic /\ replace l n phic = Some l' /\ list_join phi l' phib.

Lemma list_join_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall (phi1: A) l phi2, list_join phi1 l phi2 -> comparable phi1 phi2.

Lemma join_comparable'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi2 phi3.

Lemma join_comparable2'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi2 phi1.

Lemma list_join_comparable'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall (phi1: A) l phi2, list_join phi1 l phi2 -> comparable phi2 phi1.

Lemma join_comparable''  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi3 phi2.

Lemma join_comparable'''  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi3 phi1.

Lemma joins_comparable  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2: A, joins phi1 phi2 -> comparable phi1 phi2.

Lemma joins_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall phi1 phi2: A, joins phi2 phi1 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2: A, join_sub phi1 phi2 -> comparable phi1 phi2.

Lemma join_sub_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall phi1 phi2: A, join_sub phi2 phi1 -> comparable phi1 phi2.

Lemma eq_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
   forall phi1 phi2: A, phi1=phi2 -> comparable phi1 phi2.

Lemma eq_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
   forall phi1 phi2: A, phi2=phi1 -> comparable phi1 phi2.

Lemma ageN_join {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall n (w1 w2 w3 w1': A),
   join w1 w2 w3 ->
      ageN n w1 = Some w1' ->
      exists w2', exists w3',
        ageN n w2 = Some w2' /\ ageN n w3 = Some w3' /\ join w1' w2' w3'.

Lemma ageN_join2 {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall n (w1 w2 w3 w3': A),
   join w1 w2 w3 ->
      ageN n w3 = Some w3' ->
      exists w1', exists w2',
        ageN n w1 = Some w1' /\ ageN n w2 = Some w2' /\ join w1' w2' w3'.

Lemma ageN_comparable {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall n (w1 w2 w1' w2': A),
        ageN n w1 = Some w1' -> ageN n w2 = Some w2' -> comparable w1 w2 -> comparable w1' w2'.

Lemma join_unage  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall (phi3 phi1' phi2' phi3': A),
    age1 phi3 = Some phi3' ->
    join phi1' phi2' phi3' ->
    exists phi1, exists phi2, join phi1 phi2 phi3 /\
      age1 phi1 = Some phi1' /\ age1 phi2 = Some phi2'.

Lemma join_unage'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
    forall phi1 phi1' phi2' phi3' : A,
      age1 phi1 = Some phi1' ->
      join phi1' phi2' phi3' ->
      exists phi2, exists phi3, join phi1 phi2 phi3 /\
        age1 phi2 = Some phi2' /\ age1 phi3 = Some phi3'.

Lemma unageN'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall n (phi1 phi1' phi2' phi3' : A),
    ageN n phi1 = Some phi1' ->
    join phi1' phi2' phi3' ->
    exists phi2, exists phi3, join phi1 phi2 phi3 /\
      ageN n phi2 = Some phi2' /\ ageN n phi3 = Some phi3'.

Hint Resolve @join_comparable @join_comparable'  @join_comparable'' @join_comparable'''
      @join_comparable2 @join_comparable2'  @list_join_comparable @list_join_comparable'
      @joins_comparable  @joins_comparable2  @join_sub_comparable  @join_sub_comparable2
      @eq_comparable  @eq_comparable2
  : comparable.

Hint Immediate @comparable_refl  @comparable_sym  : comparable.

Ltac Comp1 phi1 phi2 :=
   solve [ eauto 3 with comparable typeclass_instances |
  match goal with
  | H: comparable phi1 ?phi |- _ => Comp2 H phi1 phi phi2
  | H: comparable ?phi phi1 |- _ => Comp2 H phi1 phi phi2
  | H: join phi1 ?phia ?phib |- _ =>  Comp3 H phi1 phia phib phi2
  | H: join ?phia phi1 ?phib |- _ =>   Comp3 H phi1 phia phib phi2
  | H: join ?phia ?phib phi1 |- _ =>   Comp3 H phi1 phia phib phi2
  | H: joins phi1 ?phi |- _ =>  Comp2 H phi1 phi phi2
  | H: joins ?phi phi1 |- _ =>  Comp2 H phi1 phi phi2
  | H: join_sub phi1 ?phi |- _ => Comp2 H phi1 phi phi2
  | H: join_sub ?phi phi1 |- _ => Comp2 H phi1 phi phi2
  | H: list_join phi1 _ ?phi |- _ =>  Comp2 H phi1 phi phi2
  | H: list_join ?phi _ phi1 |- _ =>  Comp2 H phi1 phi phi2
  | H: phi1 = ?phi  |- _ => Comp2 H phi1 phi phi2
  | H: ?phi = phi1  |- _ => Comp2 H phi1 phi phi2
 end]
  with Comp2 H phi1 phi phi2 :=
            solve [apply comparable_trans with phi;
                         [eauto 3 with comparable  typeclass_instances |clear H; Comp1 phi phi2]
                   | clear H; Comp1 phi1 phi2]
  with Comp3 H phi1 phia phib phi2 :=
           solve [apply comparable_trans with phia;
                          [eauto 3 with comparable typeclass_instances |clear H; Comp1 phia phi2]
                  |apply comparable_trans with phib;
                          [eauto 3 with comparable  typeclass_instances | clear H; Comp1 phib phi2]
                   | clear H; Comp1 phi1 phi2].

Ltac Comp := match goal with
                | |- comparable ?phi1 ?phi2 => Comp1 phi1 phi2
                | |-  level ?phi1 = level ?phi2 => apply comparable_fashionR; Comp1 phi1 phi2

                end.

Definition not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A} (phi phi': A)  : Prop :=
     exists phi1, necR phi phi1 /\ comparable phi1 phi'.

Lemma comparable_not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A} :
    forall phi phi' : A , comparable phi phi' -> not_any_younger phi phi'.

Lemma necR_not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall phi phi' : A, necR phi phi' -> not_any_younger phi phi'.

Lemma not_any_younger_refl {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
 forall phi : A, not_any_younger phi phi.

Lemma not_any_younger_trans {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall phi1 phi2 phi3, not_any_younger phi1 phi2 -> not_any_younger phi2 phi3 ->
            not_any_younger phi1 phi3.

Lemma not_any_younger_None {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall phi phi', age1 phi = None -> not_any_younger phi phi' -> age1 phi' = None.

Lemma nec_join3 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall {x x' y' z' : A},
       join x' y' z' ->
       necR x x' ->
       exists y,
         exists z,
           join x y z /\ necR y y' /\ necR z z'. *)

Require Import VST.veric.shares.
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)

Require Import VST.veric.rmaps.
(* VST.veric.rmaps:
Require Import VST.msl.msl_standard.
Require Import VST.msl.ghost.
Require Import VST.msl.Coqlib2.
Require Import VST.veric.shares.

Module Type ADR_VAL.
Parameter address : Type.
Parameter some_address:address.

Parameter kind: Type.
End ADR_VAL.

Inductive TypeTree: Type :=
  | ConstType: Type -> TypeTree
  | Mpred: TypeTree
  | DependentType: nat -> TypeTree
  | ProdType: TypeTree -> TypeTree -> TypeTree
  | ArrowType: TypeTree -> TypeTree -> TypeTree
  | PiType: forall (I : Type), (I -> TypeTree) -> TypeTree
  | ListType: TypeTree -> TypeTree.

Definition dependent_type_functor_rec (ts: list Type): TypeTree -> functor :=
  fix dtfr (T: TypeTree): functor :=
  match T with
  | ConstType A => fconst A
  | Mpred => fidentity
  | DependentType n => fconst (nth n ts unit)
  | ProdType T1 T2 => fpair (dtfr T1) (dtfr T2)
  | ArrowType T1 T2 => ffunc (dtfr T1) (dtfr T2)
  | PiType _ f => fpi (fun i => dtfr (f i))
  | ListType T => flist (dtfr T)
  end.
Opaque dependent_type_functor_rec.

Definition dependent_type_function_rec (ts: list Type) (mpred': Type): TypeTree -> Type :=
  fix dtfr (T: TypeTree): Type :=
  match T with
  | ConstType A => A
  | Mpred => mpred'
  | DependentType n => nth n ts unit
  | ProdType T1 T2 => (dtfr T1 * dtfr T2)%type
  | ArrowType T1 T2 => dtfr T1 -> dtfr T2
  | PiType A f => forall a, dtfr (f a)
  | ListType T => list (dtfr T)
  end.

Definition fpreds: functor :=
  fsig (fun T: TypeTree =>
    fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

Lemma realize_eq: forall {A} (a b: A) P, (exists H: a = b, P H) -> {H: a = b & P H}.

Lemma lower_join_inv : forall {A} {J: Join A} a b c, lower_join J a b c <->
  match a, b, c with
  | Some a, Some b, Some c => join a b c
  | Some a, None, Some c | None, Some a, Some c => a = c
  | None, None, None => True
  | _, _, _ => False
  end.

Module Type STRAT_MODEL.
  Declare Module AV : ADR_VAL.
  Import AV.

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> fpreds PRED -> res PRED
    | PURE': kind -> fpreds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap fpreds f g pds)
      | PURE' k pds => PURE' B k (fmap fpreds f g pds)
    end.
  Axiom ff_res : functorFacts res res_fmap.
  Definition f_res : functor := Functor ff_res.

  Axiom paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Axiom ff_ghost : functorFacts ghost ghost_fmap.
  Definition f_ghost : functor := Functor ff_ghost.
  Axiom paf_ghost : @pafunctor f_ghost ghost_join.

  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Instance Join_pre_rmap (A: Type) : Join (f_pre_rmap A) :=
            Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A).

  Declare Instance Perm_pre_rmap: forall (A: Type), Perm_alg (f_pre_rmap A).
  Declare Instance Sep_pre_rmap: forall (A: Type), Sep_alg (f_pre_rmap A).
  Parameter paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap.

  Existing Instance ghost_join.
  Instance Join_res A : Join (f_res A) := res_join A.

Axiom pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End STRAT_MODEL.

Module StratModel (AV' : ADR_VAL) : STRAT_MODEL with Module AV:=AV'.
  Module AV := AV'.
  Import AV.

  Definition preds: functor :=
    fsig (fun T: TypeTree =>
      fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> preds PRED -> res PRED
    | PURE': kind -> preds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap preds f g pds)
      | PURE' k pds => PURE' B k (fmap preds f g pds)
    end.

  Lemma ff_res : functorFacts res res_fmap.

  Definition f_res : functor := Functor ff_res.

  Definition paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Lemma ff_ghost : functorFacts ghost ghost_fmap.

  Definition f_ghost : functor := Functor ff_ghost.

  Instance preds_join PRED : Join _ := Join_equiv (fpreds PRED).

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join PRED : Join (ghost PRED) :=
  | ghost_join_nil_l m: ghost_join PRED nil m m
  | ghost_join_nil_r m: ghost_join PRED m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join PRED m1 m2 m3 ->
      ghost_join PRED (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Hint Constructors ghost_join.
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall PRED m1 m2 m3, ghost_join PRED m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join PRED m1 m2 m3 end
  end.

  Opaque fpreds.

  Definition paf_ghost : @pafunctor f_ghost ghost_join.

  Definition pre_rmap (A:Type) := ((address -> res A) * ghost A)%type.
  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Notation Join_obj A := (Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A)).

  Instance Join_pre_rmap (A: Type) : Join (pre_rmap A) :=
    Join_obj A.

  Definition paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap :=
    paf_pair (paf_fun address paf_res) paf_ghost.

  Definition Perm_pre_rmap (A: Type): Perm_alg (pre_rmap A) :=
    Perm_prod (Perm_fun address _ _ _) (pa_gj A).

  Definition Sep_pre_rmap (A: Type): Sep_alg (pre_rmap A) :=
    Sep_prod (Sep_fun address _ _ _) (sa_gj A).

Lemma pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End StratModel.

Local Open Scope nat_scope.

Module Type RMAPS.
  Declare Module AV:ADR_VAL.
  Import AV.

  Parameter rmap : Type.
  Axiom Join_rmap: Join rmap. Existing Instance Join_rmap.
  Axiom Perm_rmap: Perm_alg rmap. Existing Instance Perm_rmap.
  Axiom Sep_rmap: Sep_alg rmap. Existing Instance Sep_rmap.
  Axiom ag_rmap: ageable rmap.  Existing Instance ag_rmap.
  Axiom Age_rmap: Age_alg rmap.  Existing Instance Age_rmap.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
      (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~(readable_share sh) -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Inductive res_join : resource -> resource -> resource -> Prop :=
   | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (NO sh2 nsh2) (NO sh3 nsh3)
   | res_join_NO2 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3), 
                 res_join (YES sh1 rsh1 k p) (NO sh2 nsh2) (YES sh3 rsh3 k p) 
   | res_join_NO3 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p) 
   | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
        res_join (YES sh1 rsh1 k p) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p)
   | res_join_PURE : forall k p, res_join (PURE k p) (PURE k p) (PURE k p). 

  Instance Join_resource: Join resource := res_join.
  Axiom Perm_resource: Perm_alg resource. Existing Instance Perm_resource.
  Axiom Sep_resource: Sep_alg resource. Existing Instance Sep_resource.

  Definition preds_fmap (f g: pred rmap -> pred rmap) (x:preds) : preds :=
    match x with SomeP A Q => SomeP A (fmap (fpi _) f g Q)
    end.
  
  Axiom preds_fmap_id : preds_fmap (id _) (id _) = id preds.
  Axiom preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.
  Axiom resource_fmap_id : resource_fmap (id _) (id _) = id resource.
  Axiom resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Axiom Perm_ghost: Perm_alg ghost. Existing Instance Perm_ghost.
  Axiom Sep_ghost: Sep_alg ghost. Existing Instance Sep_ghost.
  Axiom ghost_core: forall (g: ghost), core g = nil.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Axiom ghost_fmap_id : ghost_fmap (id _) (id _) = id ghost.
  Axiom ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap' := ((address -> resource) * ghost)%type.

  Definition rmap_fmap (f g: pred rmap -> pred rmap) (x:rmap') : rmap' :=
    (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Axiom rmap_fmap_id : rmap_fmap (id _) (id _) = id rmap'.
  Axiom rmap_fmap_comp : forall f1 f2 g1 g2,
   rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Parameter squash : (nat * rmap') -> rmap.
  Parameter unsquash : rmap -> (nat * rmap').

  Axiom rmap_level_eq: @level rmap _ = fun x => fst (unsquash x).
  Axiom rmap_age1_eq: @age1 _ _ =
     fun k => match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Axiom join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Program Definition approx (n:nat) (p: pred rmap) : pred rmap :=
    fun w => level w < n /\ p w.

  Axiom squash_unsquash : forall phi, squash (unsquash phi) = phi.
  Axiom unsquash_squash : forall n rm, unsquash (squash (n,rm)) = (n,rmap_fmap (approx n) (approx n) rm).
  Axiom ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

End RMAPS.

Module Rmaps (AV':ADR_VAL): RMAPS with Module AV:=AV'.
  Module AV:=AV'.
  Import AV.

  Module SM := StratModel(AV).
  Import SM.

  Module TyF. 
    Definition F := f_pre_rmap.
  End TyF.

  Module TyFSA <: KNOT_FULL_SA_INPUT with Module KI:=TyF.
    Module KI := TyF.
    Import KI.

    Instance Join_F: forall A, Join (F A) := _.
    Definition Perm_F : forall A, Perm_alg (F A) := Perm_pre_rmap.
    Definition Sep_F := Sep_pre_rmap.
    Definition paf_F := paf_pre_rmap.
  End TyFSA.

  Module K := Knot_MixVariantHeredProp(TyF).
  Module KL := KnotLemmas_MixVariantHeredProp(K).
  Module KSa := KnotFullSa(TyFSA)(K)(KL).

  Definition rmap := K.knot.
  Instance Join_rmap: Join rmap := KSa.Join_knot.
  Instance Perm_rmap : Perm_alg rmap:= KSa.Perm_knot.
  Instance Sep_rmap : Sep_alg rmap:= KSa.Sep_knot.
  Instance ag_rmap : ageable rmap := K.ageable_knot.
  Instance Age_rmap: Age_alg rmap := KSa.asa_knot.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
    (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~ readable_share sh -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition resource2res (r: resource): res (pred rmap) :=
    match r with
      | NO sh nsh => NO' (pred rmap) sh nsh
      | YES sh rsh k (SomeP A l) => YES' (pred rmap) sh rsh k (existT _ A l)
      | PURE k (SomeP A l) => PURE' (pred rmap) k (existT _ A l)
    end.

  Definition res2resource (r: res (pred rmap)) : resource :=
    match r with
      | NO' sh nsh => NO sh nsh
      | YES' sh rsh k (existT A l) => YES sh rsh k (SomeP A l)
      | PURE' k (existT A l) => PURE k (SomeP A l)
    end.

  Lemma res2resource2res: forall x, resource2res (res2resource x) = x.

  Lemma resource2res2resource: forall x, res2resource (resource2res x) = x.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Lemma res_option_rewrite: res_option = SM.res_option (pred rmap) oo resource2res.

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Definition pred2p (p: preds) : fpreds (pred rmap) :=
    match p with SomeP A P => existT _ A P end.

  Definition p2pred (p: fpreds (pred rmap)) : preds :=
    match p with existT A P => SomeP A P end.

  Definition ghost2g (r: ghost): SM.ghost (pred rmap) :=
    map (option_map (fun '(a, b) => (a, pred2p b))) r.

  Definition g2ghost (r: SM.ghost (pred rmap)) : ghost :=
    map (option_map (fun '(a, b) => (a, p2pred b))) r.

  Lemma g2ghost2g: forall x, ghost2g (g2ghost x) = x.

  Lemma ghost2g2ghost: forall x, g2ghost (ghost2g x) = x.

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall m1 m2 m3, ghost_join m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join m1 m2 m3 end
  end.

  Lemma ghost_core : forall (g: ghost), core g = nil.

  Definition rmap' := ((address->resource) * ghost)%type.
  Definition preds_fmap (f g:(pred rmap)->(pred rmap)) (x:preds) : preds :=
    match x with SomeP A ls => SomeP A (fmap (fpi _) f g ls) end.

  Lemma preds_fmap_id : preds_fmap (id (pred rmap)) (id (pred rmap)) = id preds.

  Lemma preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Lemma resource_fmap_id :
    resource_fmap (id (pred rmap)) (id (pred rmap)) = id resource.

  Lemma ghost_fmap_id : ghost_fmap (id (pred rmap)) (id (pred rmap)) = id ghost.

  Lemma resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Lemma ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap_fmap (f g:(pred rmap)->(pred rmap)) (x:rmap') : rmap' :=
              (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Lemma rmap_fmap_id : rmap_fmap (id (pred rmap)) (id (pred rmap)) = id rmap'.

  Lemma rmap_fmap_comp : forall f1 f2 g1 g2,
    rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap'2pre_rmap (f: rmap') : f_pre_rmap (pred rmap) :=
      (fun x : address => resource2res (fst f x), ghost2g (snd f)).

  Definition pre_rmap2rmap' (f: f_pre_rmap (pred rmap)) : rmap' :=
      (fun l : address => res2resource (fst f l), g2ghost (snd f)).

  Lemma rmap'2pre_rmap2rmap' :
    forall x, rmap'2pre_rmap (pre_rmap2rmap' x) = x.

  Lemma pre_rmap2rmap'2pre_rmap :
    forall x,  pre_rmap2rmap' (rmap'2pre_rmap x) = x.

  Definition squash (n_rm:nat * rmap') : rmap :=
    match n_rm with (n,rm) => K.squash (n, rmap'2pre_rmap rm) end.

  Definition unsquash (phi:rmap) : (nat * rmap') :=
    match K.unsquash phi with (n,rm) => (n, pre_rmap2rmap' rm) end.

  Definition rmap_level (phi:rmap) : nat := fst (unsquash phi).
  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Lemma pred_ext': forall {A} `{agA: ageable A} P Q,
                (forall x, app_pred P x <-> app_pred Q x) -> P = Q.

  Lemma squash_unsquash : forall phi, squash (unsquash phi) = phi.

  Program Definition approx (n:nat) (p: (pred rmap)) : (pred rmap) :=
    fun w => level w < n /\ p w.

  Lemma approx_K_approx: approx = K.approx.

  Lemma unsquash_squash : forall n rm, (unsquash (squash (n,rm))) = (n,rmap_fmap (approx n) (approx n) rm).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Lemma g2ghost_inv: forall g1 g2, g2ghost g1 = g2ghost g2 -> g1 = g2.

  Lemma join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Lemma ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

  Definition rmap_age1 (k:rmap) : option rmap :=
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Lemma rmap_age1_knot_age1 :
    rmap_age1 = @age1 _ K.ageable_knot.

  Lemma rmap_age1_eq: @age1 _ ag_rmap = rmap_age1.

  Lemma rmap_level_eq: @level rmap ag_rmap = fun x => fst (unsquash x).

End Rmaps.
Local Close Scope nat_scope. *)



Module Rmaps_Lemmas (R0: RMAPS).

Module R := R0.

Import R.



Hint Resolve (@subp_sepcon _ Join_rmap Perm_rmap Sep_rmap): contractive.



 Lemma approx_p  : forall (p:pred rmap) n w, approx n p w -> p w.

 Proof. unfold approx; simpl; intuition. Qed.



 Lemma approx_lt : forall (p:pred rmap) n w, lt (level w) n -> p w -> approx n p w.

 Proof. unfold approx; simpl; intuition. Qed.



 Lemma approx_ge : forall p n w, ge (level w) n -> approx n p w -> False.

 Proof. unfold approx; intros. destruct H0; auto. omega. Qed.



  Lemma ageN_level : forall n (phi1 phi2 : rmap),

    ageN n phi1 = Some phi2 -> level phi1 = (n + (level phi2))%nat.

  Proof.

    unfold ageN; induction n; simpl; intros.

    injection H; intros; subst; auto.

    revert H.

    repeat rewrite rmap_level_eq in *.

    intros. invSome.

    specialize (IHn _ _ H2).

    apply  age_level in H.  rewrite rmap_level_eq in *. omega.

  Qed.



Lemma NO_identity: forall nsh, identity (NO Share.bot nsh).

Proof.

  unfold identity; intros.

  inv H;

  apply join_unit1_e in RJ; auto;   subst sh3; repeat proof_irr; auto.

Qed.



Lemma PURE_identity: forall k pds, identity (PURE k pds).

Proof.

  unfold identity; intros.

  inv H; auto.

Qed.



Lemma identity_NO:

  forall r, identity  r -> r = NO Share.bot bot_unreadable \/ exists k, exists pds, r = PURE k pds.

Proof.

  destruct r; auto; intros.

 * left.

   apply identity_unit' in H. inv H.

   apply identity_unit_equiv in RJ. apply identity_share_bot in RJ. subst.

   f_equal. apply proof_irr.

 * apply identity_unit' in H. inv H.

   apply unit_identity in RJ. apply identity_share_bot in RJ. subst.

   contradiction bot_unreadable.

 * right. exists k. exists p. trivial.

Qed.



Lemma age1_resource_at_identity:

  forall phi phi' loc, age1 phi = Some phi' ->

               (identity (phi@loc) <-> identity (phi'@loc)).

Proof.

 split; intro.

 

  generalize (identity_NO _ H0); clear H0; intro.

  unfold resource_at in *.

  rewrite rmap_age1_eq in *.

  revert H H0; case_eq (unsquash phi); simpl; intros.

  destruct n; inv H0.

  rewrite unsquash_squash.

  simpl.

  destruct r. simpl in *.

  unfold compose; simpl. destruct H1 as [H1 | [k [pds H1]]]; rewrite H1; simpl; auto.

  apply NO_identity.

  apply PURE_identity.

 

  generalize (identity_NO _ H0); clear H0; intro.

  unfold resource_at in *. simpl in H.

  rewrite rmap_age1_eq in H.

  revert H H0; case_eq (unsquash phi); simpl; intros.

  destruct n; inv H0.

  rewrite unsquash_squash in H1. simpl in *.

  unfold compose in H1; simpl in H1.

  unfold resource_fmap in H1.

  destruct (fst r loc).

  destruct H1. inv H0;   apply NO_identity. destruct H0 as [? [? H0]]; inv H0.

  destruct H1 as [H1 | [k' [pds' H1]]]; inv H1.

  apply PURE_identity.

Qed.



Lemma necR_resource_at_identity:

  forall phi phi' loc, necR phi phi' ->

         identity (phi@loc) ->

         identity (phi'@loc).

Proof.

  induction 1; auto.

  intro.

 apply -> (age1_resource_at_identity _ _ loc H); auto.

Qed.



Lemma make_rmap': forall f g, 

          exists phi: rmap', phi = (f, g).

Proof.

  intros.

  unfold rmap'. exists (f,g).

  auto.

Qed.



Lemma make_rmap (f: AV.address -> resource) g

    (n: nat) (H: resource_fmap (approx n) (approx n) oo f = f)

    (HG: ghost_fmap (approx n) (approx n) g = g) :

  {phi: rmap | level phi = n /\ resource_at phi = f /\ ghost_of phi = g}.

Proof.

intros.

apply (exist _ (squash (n, (f, g)))).

simpl level; rewrite rmap_level_eq in *; unfold resource_at, ghost_of. rewrite unsquash_squash.

auto.

Qed.



Lemma make_rmap'':

    forall n (f: AV.address -> resource) g,

      exists phi:rmap, level phi = n /\ resource_at phi = resource_fmap (approx n) (approx n) oo f /\

      ghost_of phi = ghost_fmap (approx n) (approx n) g.

  Proof.

    intros.

    exists (squash (n, (f, g))).

    rewrite rmap_level_eq.

      unfold resource_at, ghost_of; rewrite unsquash_squash; simpl; split; auto.

Qed.



Lemma approx_oo_approx':

  forall n n', (n' >= n)%nat -> approx n oo approx n' = approx n.

Proof.

unfold compose; intros.

extensionality P.

 apply pred_ext; intros w ?; unfold approx; simpl in *; intuition.

Qed.



Lemma approx'_oo_approx:

  forall n n', (n' >= n)%nat -> approx n' oo approx n = approx n.

Proof.

unfold compose; intros.

extensionality P.

 apply pred_ext; intros w ?; unfold approx; simpl in *; intuition.

Qed.



Lemma approx_oo_approx: forall n, approx n oo approx n = approx n.

Proof.

intros; apply approx_oo_approx'; omega.

Qed.



Lemma preds_fmap_fmap:

  forall f1 f2 g1 g2 pp, preds_fmap f1 f2 (preds_fmap g1 g2 pp) = preds_fmap (f1 oo g1) (g2 oo f2) pp.

Proof.

destruct pp; simpl; auto.

f_equal; extensionality i.

rewrite <- fmap_comp; auto.

Qed.



Lemma resources_same_level:

   forall f phi,

     (forall l : AV.address, join_sub (f l) (phi @ l)) ->

        resource_fmap (approx (level phi)) (approx (level phi)) oo f = f.

Proof.

  intros.

  rewrite rmap_level_eq.

  unfold resource_fmap, resource_at in *.

  unfold compose; extensionality l. specialize ( H l).

  destruct H as [g ?].

  revert H; case_eq (unsquash phi); intros n ? ?.

  generalize H; rewrite <- (squash_unsquash phi).

  rewrite H. rewrite unsquash_squash.

  simpl; intros.

  injection H0. clear H0. intro.

  clear phi H.

  rewrite <- H0 in H1.

  clear H0.

  unfold rmap_fmap in *.

  simpl in *.

  revert H1.

  unfold resource_fmap, compose.

  destruct (f l); destruct g; destruct (fst r l); simpl; intro; auto; inv H1;

    rewrite preds_fmap_fmap, approx_oo_approx; auto.

Qed.



Lemma ghost_fmap_fmap:  forall f1 f2 g1 g2 r,

  ghost_fmap f1 f2 (ghost_fmap g1 g2 r) = ghost_fmap (f1 oo g1) (g2 oo f2) r.

Proof.

  intros; rewrite <- ghost_fmap_comp; auto.

Qed.



Lemma ghost_same_level:

   forall g phi, join_sub g (ghost_of phi) ->

   ghost_fmap (approx (level phi)) (approx (level phi)) g = g.

Proof.

  intros.

  rewrite rmap_level_eq.

  unfold ghost_of in *.

  revert H; case_eq (unsquash phi); intros n ? ?.

  generalize H; rewrite <- (squash_unsquash phi).

  rewrite H. rewrite unsquash_squash.

  simpl; intros.

  injection H0. clear H0. intro.

  clear phi H.

  rewrite <- H0 in H1.

  clear H0.

  unfold rmap_fmap in *.

  destruct r.

  simpl in H1; destruct H1.

  remember (ghost_fmap (approx n) (approx n) g0) as g'.

  revert dependent g0; induction H; auto; intros; subst.

  - rewrite ghost_fmap_fmap, approx_oo_approx; auto.

  - destruct g0; inv Heqg'.

    simpl; f_equal; eauto.

    inv H; auto; simpl.

    + destruct o as [[]|]; auto; simpl.

      rewrite preds_fmap_fmap, approx_oo_approx; auto.

    + destruct a0, a3, a4; inv H4; simpl in *.

      destruct o as [[]|]; inv H1.

      inv H2.

      rewrite preds_fmap_fmap, approx_oo_approx; auto.

Qed.



Lemma deallocate:

  forall (phi: rmap) (f g : AV.address -> resource) a b,

  (forall l, join  (f l) (g l) (phi@l)) -> join a b (ghost_of phi) ->

   exists phi1, exists phi2,

     join phi1 phi2 phi /\ resource_at phi1 = f /\ ghost_of phi1 = a.

Proof.

  intros until b. intros H0 HG.

  generalize (resources_same_level f phi); intro.

  spec H. intro; econstructor; apply H0.

  generalize (resources_same_level g phi); intro.

  spec H1.

  intro. econstructor; eapply join_comm; eauto.

  generalize (ghost_same_level a phi); intro Ha.

  spec Ha. eexists; eauto.

  generalize (ghost_same_level b phi); intro Hb.

  spec Hb. eexists; eauto.

  generalize (make_rmap'' (level phi) f a); intros [phif [? [Gf Ga]]].

  generalize (make_rmap'' (level phi) g b); intros [phig [? [Gg Gb]]].

  exists phif; exists phig.

  split; [|rewrite Ga, Gf; auto].

  rewrite rmap_level_eq in *.

  unfold resource_at, ghost_of in *.

  revert H0 HG H Gf Ga H1 Gg Gb Ha Hb H2 H3;

  case_eq (unsquash phif); intros nf phif' ?.

  case_eq (unsquash phig); intros ng phig' ?.

  case_eq (unsquash phi); intros n phi' ?.

  simpl.

  intros; subst nf ng.

  rewrite join_unsquash.

  rewrite H; rewrite H0.

  revert H1; case_eq (unsquash phi); intros n' phi'' ?.

  intros.

  inversion H5.

  simpl.

  split.

  simpl; constructor; auto.

  subst n' phi''.

  constructor.

  intro l; specialize ( H2 l).

  simpl.

  rewrite Gf; rewrite Gg; clear Gf Gg.

  rewrite H3; rewrite H4.

  auto.

  simpl; rewrite Ga, Gb; simpl.

  rewrite Ha, Hb; auto.

Qed.



  Lemma unsquash_inj : forall x y,

      unsquash x = unsquash y -> x = y.

  Proof.

    intros.

    rewrite <- (squash_unsquash x).

    rewrite <- (squash_unsquash y).

    rewrite H; auto.

  Qed.



Lemma resource_fmap_fmap:  forall f1 f2 g1 g2 r, resource_fmap f1 f2 (resource_fmap g1 g2 r) =

                                                                      resource_fmap (f1 oo g1) (g2 oo f2) r.

Proof.

destruct r; simpl; auto.

rewrite preds_fmap_fmap; auto.

rewrite preds_fmap_fmap; auto.

Qed.



Lemma ghost_of_approx:

  forall phi,

      ghost_fmap (approx (level phi)) (approx (level phi)) (ghost_of phi) = ghost_of phi.

Proof.

intros. symmetry. rewrite rmap_level_eq. unfold ghost_of.

case_eq (unsquash phi); intros.

simpl.

set (phi' := (squash (n, (resource_fmap (approx n) (approx n) oo fst r, snd r)))).

generalize (unsquash_inj phi phi'); intro.

spec H0.

-

replace (unsquash phi) with (unsquash (squash (unsquash phi))).

2: rewrite squash_unsquash; auto.

rewrite H.

unfold phi'.

repeat rewrite unsquash_squash.

f_equal.

unfold rmap_fmap. simpl.

unfold compose.

f_equal.

extensionality y.

rewrite resource_fmap_fmap.

rewrite approx_oo_approx; auto.

-

unfold phi' in *; clear phi'.

subst.

rewrite unsquash_squash in H.

injection H; clear H; intro.

pattern r at 1; rewrite <- H.

auto.

Qed.



Lemma ghost_same_level_gen:

   forall n a b c, join (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) b) c ->

   ghost_fmap (approx n) (approx n) c = c.

Proof.

  intros.

  remember (ghost_fmap (approx n) (approx n) a) as a'; remember (ghost_fmap (approx n) (approx n) b) as b'.

  revert dependent b; revert dependent a; induction H; intros; subst.

  - rewrite ghost_fmap_fmap, approx_oo_approx; auto.

  - rewrite ghost_fmap_fmap, approx_oo_approx; auto.

  - destruct a, b; inv Heqa'; inv Heqb'.

    simpl; f_equal; eauto.

    inv H; simpl.

    + destruct o0 as [[]|]; auto; simpl.

      rewrite preds_fmap_fmap, approx_oo_approx; auto.

    + destruct o as [[]|]; auto; simpl.

      rewrite preds_fmap_fmap, approx_oo_approx; auto.

    + destruct a1, a2, a0; inv H3; simpl in *.

      destruct o as [[]|]; inv H1; inv H4.

      rewrite preds_fmap_fmap, approx_oo_approx; auto.

Qed.



Lemma allocate:

     forall (phi : rmap) (f : AV.address -> resource) a,

        resource_fmap (approx (level phi)) (approx (level phi)) oo f = f ->

       (forall l, {r' | join (phi@l) (f l) r'}) ->

        ghost_fmap (approx (level phi)) (approx (level phi)) a = a ->

        {a' | join (ghost_of phi) a a'} ->

       exists phi1 : rmap,

         exists phi2 : rmap,

           join phi phi1 phi2 /\ resource_at phi1 = f /\ ghost_of phi1 = a.

Proof.

 intros. rename H0 into Hg. rename X into H1.

 generalize (make_rmap'' (level phi) f a); intros [phif [? [Gf Ga]]].

 pose (g loc := proj1_sig (H1 loc)).

 assert (H3: forall l, join (phi @ l) (f l) (g l))

   by (unfold g; intro; destruct (H1 l); simpl in *; auto).

 clearbody g.

 destruct X0 as [b X0].

 generalize (make_rmap'' (level phi) g b); intro.

 destruct H2 as [phig [H4 [H5 H6]]].

 rename H0 into H2.

 exists phif; exists phig.

 split; [|split; congruence].

 rewrite join_unsquash.

 unfold resource_at, ghost_of in *.

 rewrite rmap_level_eq in *.

 rename H into H0. pose proof I.

 revert H0 H1 Hg X0 H2 H3 H4 H5 H6 Gf Ga.

 case_eq (unsquash phif); intros nf phif' ?.

 case_eq (unsquash phig); intros ng phig' ?.

 case_eq (unsquash phi); intros n phi' ?.

 simpl.

 intros; subst nf ng.

 split. split; trivial.

 simpl.

 split.

 intro l.

 specialize ( H6 l).

 assert (fst phig' l = g l).

   generalize (f_equal squash H2); intro.

   rewrite squash_unsquash in H5.

   subst phi.

   rewrite unsquash_squash in H2.

   injection H2; clear H2; intro.

   rewrite <- H2 in H6.

   rewrite <- H3 in H6.

   rewrite H8.

   clear - H6.

   revert H6.

   unfold rmap_fmap, compose, resource_fmap. simpl.

   destruct (fst phi' l); destruct (f l); destruct (g l); simpl; intros; auto; try inv H6;

              try change (preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) p0)) with

                ((preds_fmap (approx n) (approx n) oo preds_fmap (approx n) (approx n)) p0);

              try change (preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) p)) with

                ((preds_fmap (approx n) (approx n) oo preds_fmap (approx n) (approx n)) p);

                rewrite preds_fmap_comp; rewrite approx_oo_approx; auto.

 rewrite H5.

 rewrite Gf.

 rewrite H3.

 auto.



  erewrite Ga, H9, Hg, ghost_same_level_gen; auto.

  rewrite <- Hg in X0.

  pose proof (ghost_of_approx phi) as X.

  unfold ghost_of in X.

  rewrite rmap_level_eq, H2 in X; simpl in X.

  rewrite X; eauto.

Qed.



  Lemma rmap_ext: forall phi1 phi2,

    level phi1 = level phi2 ->

    (forall l, phi1@l = phi2@l) ->

    ghost_of phi1 = ghost_of phi2 ->

    phi1=phi2.

  Proof.

    intros.

    apply unsquash_inj.

    rewrite rmap_level_eq in *.

    unfold resource_at, ghost_of in *.

    rewrite <- (squash_unsquash phi1).

    rewrite <- (squash_unsquash phi2).

    destruct (unsquash phi1).

    destruct (unsquash phi2).

    simpl in H.

    rewrite H.

    rewrite unsquash_squash.

    rewrite unsquash_squash.

    simpl in H0, H1.

    replace (rmap_fmap (approx n0) (approx n0) r) with (rmap_fmap (approx n0) (approx n0) r0); auto.

    simpl in *. unfold rmap_fmap.

    replace (resource_fmap (approx n0) (approx n0) oo fst r0)

      with (resource_fmap (approx n0) (approx n0) oo fst r).

    destruct r,r0; simpl in *; subst; auto.

    extensionality l.

    unfold compose.

    specialize ( H0 l).

    subst n0.

    rewrite H0; auto.

  Qed.



  Lemma resource_at_join:

    forall phi1 phi2 phi3 loc,

      join phi1 phi2 phi3 ->

      join (phi1@loc) (phi2@loc) (phi3@loc).

  Proof.

    intros.

    revert H; rewrite join_unsquash; unfold resource_at.

    intros [? ?].

    apply H0.

  Qed.



  Lemma ghost_of_join:

    forall phi1 phi2 phi3,

      join phi1 phi2 phi3 ->

      join (ghost_of phi1) (ghost_of phi2) (ghost_of phi3).

  Proof.

    intros.

    revert H; rewrite join_unsquash; unfold resource_at.

    intros [? ?].

    apply H0.

  Qed.



  Lemma resource_at_join2:

    forall phi1 phi2 phi3,

      level phi1 = level phi3 -> level phi2 = level phi3 ->

      (forall loc, join (phi1@loc) (phi2@loc) (phi3@loc)) ->

      join (ghost_of phi1) (ghost_of phi2) (ghost_of phi3) ->

      join phi1 phi2 phi3.

  Proof.

    intros ? ? ?.

    rewrite join_unsquash.

    rewrite rmap_level_eq in *.

    unfold resource_at, ghost_of.

    case_eq (unsquash phi1); case_eq (unsquash phi2); case_eq (unsquash phi3); simpl; intros.

    subst.

    split; auto.

    split; auto.

  Qed.



Lemma all_resource_at_identity:

  forall w, (forall l, identity (w@l)) -> identity (ghost_of w) ->

         identity w.

Proof.

  repeat intro.

  apply rmap_ext.

  { apply join_level in H1; tauto. }

  intro l; specialize (H l).

  apply (resource_at_join _ _ _ l), H in H1; auto.

  apply H0, ghost_of_join; auto.

Qed.



  Lemma ageN_squash : forall d n rm, le d n ->

    ageN d (squash (n, rm)) = Some (squash ((n - d)%nat, rm)).

  Proof.

    induction d; simpl; intros.

    unfold ageN; simpl.

    replace (n-0)%nat with n by omega; auto.

    unfold ageN; simpl.

    rewrite rmap_age1_eq in *.

    rewrite unsquash_squash.

    destruct n.

    inv H.

    replace (S n - S d)%nat with (n - d)%nat by omega.

    unfold ageN in IHd. rewrite rmap_age1_eq in IHd.

    rewrite IHd.

    2: omega.

    f_equal.

    apply unsquash_inj.

    rewrite !unsquash_squash.

    f_equal.

    change (rmap_fmap (approx (n - d)) (approx (n - d))

             (rmap_fmap (approx (S n)) (approx (S n)) rm)) with

           ((rmap_fmap (approx (n - d)) (approx (n - d)) oo

              rmap_fmap (approx (S n)) (approx (S n))) rm).

    rewrite rmap_fmap_comp.

    f_equal.

    + clear.

      assert (n-d <= (S n))%nat by omega.

      revert H; generalize (n-d)%nat (S n).

      clear.

      intros.

      extensionality p.

      apply pred_ext'.  extensionality w.

      unfold compose, approx.

      apply prop_ext; simpl; intuition.

    + clear.

      assert (n-d <= (S n))%nat by omega.

      revert H; generalize (n-d)%nat (S n).

      clear.

      intros.

      extensionality p.

      apply pred_ext'.  extensionality w.

      unfold compose, approx.

      apply prop_ext; simpl; intuition.

  Qed.



  Lemma unageN: forall n (phi': rmap),   exists phi, ageN n phi = Some phi'.

  Proof.

    intros n phi'.

    rewrite <- (squash_unsquash phi').

    destruct (unsquash phi'); clear phi'.

    exists (squash ((n+n0)%nat,r)).

    rewrite ageN_squash.

    replace (n + n0 - n)%nat with n0 by omega; auto.

    omega.

  Qed.



  Lemma ex_level0: exists phi, age1 phi = None.

  Proof.

    Print sig.

    set (g := nil: ghost).

    set (m := (fun _ : AV.address => NO emptyshare nonreadable_emptyshare): AV.address -> resource).

    set (r := (m, g): rmap').

    exists (squash (0%nat, r)).

    rewrite rmap_age1_eq.

    rewrite unsquash_squash.

    auto.

  Qed.



  Lemma ex_level: forall n, exists phi, level phi = n.

  Proof.

    intros.

    destruct ex_level0 as [phi ?].

    rewrite age1_level0 in H.

    destruct (unageN n phi) as [phi' ?].

    exists phi'.

    apply ageN_level in H0.

    omega.

  Qed.



Lemma YES_join_full: 

   forall sh rsh n P r2 r3,

       join (R.YES sh rsh n P) r2 r3 ->

       writable0_share sh ->

       exists sh2 rsh2, r2 = NO sh2 rsh2.

Proof.

  intros.

  inv H. eauto.

  elimtype False; clear - RJ H0 rsh2.

  destruct RJ.

  destruct H0. destruct H0. destruct rsh2. subst sh sh3.

  rewrite Share.glb_commute, Share.distrib1 in H.

  rewrite Share.glb_commute.

  apply lub_bot_e in H. destruct H. rewrite H. apply bot_identity.

Qed.



Lemma YES_not_identity:

  forall sh rsh k Q, ~ identity (YES sh rsh k Q).

Proof.

intros. intro.

apply identity_unit' in H.

unfold unit_for in H.

inv H.

apply share_self_join_bot in RJ; subst.

apply bot_unreadable in rsh. auto.

Qed.



Lemma YES_overlap:

forall sh0 rsh0 sh1 rsh1 (phi0 phi1: rmap) loc k k' p p',

  joins phi0 phi1 ->

  phi1@loc = R.YES sh1 rsh1 k p -> 

  writable0_share sh1 ->

  phi0@loc = R.YES sh0 rsh0 k' p' ->

  False.

Proof.

  intros.

  destruct H as [phi3 ?].

  generalize (resource_at_join _ _ _ loc H); intro.

  rewrite H2 in H3.

  rewrite H0 in H3.

  apply join_comm in H3.

  apply YES_join_full in H3; auto.

  destruct H3 as [? [? H3]]. inv H3.

Qed.



Lemma necR_NOx:

   forall phi phi' l sh nsh, 

      necR phi phi' -> 

      phi@l = NO sh nsh -> 

      phi'@l = NO sh nsh.

Proof.

induction 1; eauto.

unfold age in H; simpl in H.

revert H; rewrite rmap_age1_eq; unfold resource_at.

destruct (unsquash x).

intros; destruct n; inv H.

rewrite unsquash_squash; simpl in *; auto.

destruct r; simpl in *.

unfold compose.

rewrite H0.

auto.

Qed.



Ltac do_map_arg :=

match goal with |- ?a = ?b =>

  match a with context [map ?x _] =>

    match b with context [map ?y _] => replace y with x; auto end end end.



Lemma resource_at_approx:

  forall phi l,

      resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) = phi @ l.

Proof.

intros. symmetry. rewrite rmap_level_eq. unfold resource_at.

case_eq (unsquash phi); intros.

simpl.

set (phi' := (squash (n, (resource_fmap (approx n) (approx n) oo fst r, snd r)))).

pose proof I.

generalize (unsquash_inj phi phi'); intro.

spec H1.

replace (unsquash phi) with (unsquash (squash (unsquash phi))).

2: rewrite squash_unsquash; auto.

rewrite H.

unfold phi'.

repeat rewrite unsquash_squash.

simpl.

f_equal.

unfold rmap_fmap, compose; simpl.

f_equal.

extensionality y.

rewrite resource_fmap_fmap.

rewrite approx_oo_approx; auto.

unfold phi' in *; clear phi'.

subst.

rewrite unsquash_squash in H.

injection H; clear H; intro.

pattern r at 1; rewrite <- H.

unfold rmap_fmap, compose.

simpl; rewrite resource_fmap_fmap.

rewrite approx_oo_approx; auto.

Qed.



Lemma necR_resource_at:

  forall phi phi' loc r,

        necR phi phi' ->

         phi @ loc = resource_fmap (approx (level phi)) (approx (level phi)) r ->

         phi' @ loc = resource_fmap (approx (level phi')) (approx (level phi')) r.

Proof.

intros.

revert r loc H0; induction H; intros; auto.

unfold age in H.

simpl in H.

revert H H0; rewrite rmap_level_eq, rmap_age1_eq; unfold resource_at.

 case_eq (unsquash x); intros.

destruct n; inv H0.

simpl in *.

rewrite unsquash_squash; simpl.

destruct r0; simpl in *.

unfold compose in *.

rewrite H1; clear H1.

rewrite resource_fmap_fmap.

rewrite approx_oo_approx'; auto.

rewrite approx'_oo_approx; auto.

Qed.



Lemma necR_YES:

  forall phi phi' loc rsh sh k pp,

        necR phi phi' ->

         phi @ loc = YES rsh sh k pp ->

         phi' @ loc = YES rsh sh k (preds_fmap (approx (level phi')) (approx (level phi')) pp).

Proof.

intros.

generalize (eq_sym (resource_at_approx phi loc));

pattern (phi @ loc) at 2; rewrite H0; intro.

apply (necR_resource_at _ _ _ _ H H1).

Qed.



Lemma necR_PURE:

  forall phi phi' loc k pp,

        necR phi phi' ->

         phi @ loc = PURE k pp ->

         phi' @ loc = PURE k (preds_fmap (approx (level phi')) (approx (level phi')) pp).

Proof.

  intros.

  generalize (eq_sym (resource_at_approx phi loc));

  pattern (phi @ loc) at 2; rewrite H0; intro.

  apply (necR_resource_at _ _ _ _ H H1).

Qed.



Lemma necR_NO:

   forall phi phi' l sh nsh, necR phi phi' -> 

   (phi@l = NO sh nsh <-> phi'@l = NO sh nsh).

Proof.

  intros; split.

  apply necR_NOx; auto.

  intros.

  case_eq (phi @ l); intros; auto.

  generalize (necR_NOx _ _ l _ _ H H1); intro. congruence.

  generalize (necR_YES _ _ _ _ _ _ _ H H1); congruence.

  generalize (necR_PURE _ _ _ _ _ H H1); congruence.

Qed.



Lemma resource_at_empty: forall phi, 

     identity phi ->

     forall l, phi @ l = NO Share.bot bot_unreadable \/ exists k, exists pds, phi @ l = PURE k pds.

Proof.

  intros.

  apply identity_unit' in H.

  unfold unit_for in H.

  generalize (resource_at_join _ _ _ l H); intro.

  remember (phi @ l) as r.

  destruct r; inv H0; eauto.

  left. clear - RJ.

  apply identity_unit_equiv in RJ; apply identity_share_bot in RJ; subst.

  f_equal. apply proof_irr.

  clear - r RJ.

  apply share_self_join_bot in RJ. subst.

  contradiction (bot_unreadable r).

Qed.

Arguments resource_at_empty [phi] _ _.



Ltac inj_pair_tac :=

 match goal with H: (@existT ?U ?P ?p ?x = @existT _ _ _ ?y) |- _ =>

   generalize (@inj_pair2 U P p x y H); clear H; intro; try (subst x || subst y)

 end.



Lemma preds_fmap_NoneP:

  forall f1 f2, preds_fmap f1 f2 NoneP = NoneP.

Proof.

intros.

unfold NoneP.

auto.

Qed.



Lemma necR_YES':

   forall phi phi' loc rsh sh k,

         necR phi phi' -> (phi@loc = YES rsh sh k NoneP <-> phi'@loc = YES rsh sh k NoneP).

Proof.

intros.

induction H.

rename x into phi; rename y into phi'.

unfold age in H; simpl in H.



inv H.

split; intros.

rewrite (necR_YES phi phi' loc rsh sh k NoneP); auto. constructor 1; auto.

rewrite rmap_age1_eq in *.

unfold resource_at in *.

revert H1; case_eq (unsquash phi); simpl; intros.

destruct n; inv H1.

rewrite unsquash_squash in H. simpl in H.

unfold compose in H.

revert H; destruct (fst r loc); simpl; intros; auto.

destruct p; inv H.

inj_pair_tac. f_equal. apply proof_irr.

unfold NoneP; f_equal.

auto.

inv H.

intuition.

intuition.

Qed.



Lemma necR_YES'':

   forall phi phi' loc rsh sh k,

         necR phi phi' ->

    ((exists pp, phi@loc = YES rsh sh k pp) <->

    (exists pp, phi'@loc = YES rsh sh k pp)).

Proof.

intros.

induction H; try solve [intuition].

rename x into phi; rename y into phi'.

revert H; unfold age; case_eq (age1 phi); intros; try discriminate.

inv H0.

simpl in *.

split; intros [pp ?].

+ econstructor;

  apply (necR_YES phi phi' loc rsh sh k pp).

  constructor 1; auto. auto.

+ rename phi' into r.

  rewrite rmap_age1_eq in *.

  unfold resource_at in *.

  revert H; case_eq (unsquash phi); simpl; intros.

  destruct n; inv H1.

  rewrite unsquash_squash in H0. simpl in H0.

  unfold compose in H0.

  revert H0; destruct (fst r0 loc); simpl; intros; inv H0.

  econstructor; proof_irr; eauto.

Qed.



Lemma necR_PURE':

   forall phi phi' loc k,

         necR phi phi' ->

    ((exists pp, phi@loc = PURE k pp) <->

    (exists pp, phi'@loc = PURE k pp)).

Proof.

intros.

induction H; try solve [intuition].

rename x into phi; rename y into phi'.

revert H; unfold age; case_eq (age1 phi); intros; try discriminate.

inv H0.

simpl in *.

split; intros [pp ?].

+ econstructor;

  apply (necR_PURE phi phi' loc k pp).

  constructor 1; auto. auto.

+ rename phi' into r.

  rewrite rmap_age1_eq in *.

  unfold resource_at in *.

  revert H; case_eq (unsquash phi); simpl; intros.

  destruct n; inv H1.

  rewrite unsquash_squash in H0. simpl in H0.

  unfold compose in H0.

  revert H0; destruct (fst r0 loc); simpl; intros; inv H0.

  eauto.

Qed.



Lemma resource_at_join_sub:

  forall phi1 phi2 l,

       join_sub phi1 phi2 -> join_sub (phi1@l) (phi2@l).

Proof.

intros.

destruct H as [phi ?].

generalize (resource_at_join _ _ _ l H); intro.

econstructor; eauto.

Qed.



Lemma age1_res_option: forall phi phi' loc,

     age1 phi = Some phi' -> res_option (phi @ loc) = res_option (phi' @ loc).

  Proof.

    unfold res_option, resource_at; simpl.

   rewrite rmap_age1_eq; intros phi1 phi2 l.

 case_eq (unsquash phi1); intros. destruct n; inv H0.

 rewrite unsquash_squash.

   destruct r;

    simpl.

   unfold compose. destruct (r l); simpl; auto.

Qed.



Lemma necR_res_option:

  forall (phi phi' : rmap) (loc : AV.address),

  necR phi phi' -> res_option (phi @ loc) = res_option (phi' @ loc).

Proof.

  intros.

  case_eq (phi @ loc); intros.

  rewrite (necR_NO _ _ _ _ n H) in H0. congruence.

  destruct p.

  rewrite (necR_YES phi phi' loc _ _ _ _ H H0); auto.

  rewrite (necR_PURE phi phi' loc _ _ H H0); auto.

Qed.



Lemma age1_resource_at:

     forall phi phi',

          age1 phi = Some phi' ->

         forall loc r,

          phi @ loc = resource_fmap (approx (level phi)) (approx (level phi)) r ->

          phi' @ loc = resource_fmap (approx (level phi')) (approx (level phi')) r.

Proof.

   unfold resource_at; rewrite rmap_age1_eq, rmap_level_eq.

intros until phi'; case_eq (unsquash phi); intros.

simpl in *.

destruct n; inv H0.

rewrite unsquash_squash.

destruct r; simpl in *.

unfold compose; rewrite H1.

rewrite resource_fmap_fmap.

rewrite approx_oo_approx'; auto.

rewrite approx'_oo_approx; auto.

Qed.



Lemma age1_ghost_of:

     forall phi phi',

          age1 phi = Some phi' ->

          ghost_of phi' = ghost_fmap (approx (level phi')) (approx (level phi')) (ghost_of phi).

Proof.

unfold ghost_of; rewrite rmap_age1_eq, rmap_level_eq.

intros until phi'; case_eq (unsquash phi); intros.

simpl in *.

destruct n; inv H0.

rewrite unsquash_squash.

destruct r; auto.

Qed.



Lemma ghost_fmap_join: forall a b c f g, join a b c ->

  join (ghost_fmap f g a) (ghost_fmap f g b) (ghost_fmap f g c).

Proof.

  induction 1; constructor; auto.

  inv H; constructor; auto.

  destruct a0, a4, a5; inv H1; constructor; auto.

  simpl in *; inv H2; constructor; auto.

Qed.



Lemma age1_ghost_of_identity:

  forall phi phi', age1 phi = Some phi' ->

               (identity (ghost_of phi) <-> identity (ghost_of phi')).

Proof.

 intros.

 rewrite (age1_ghost_of _ _ H).

 split; intro.

 - replace (ghost_fmap _ _ _) with (ghost_of phi); auto.

   rewrite (identity_core H0), ghost_core; auto.

 - replace (ghost_of phi) with (core (ghost_of phi)); [apply core_identity|].

   apply identity_core in H0.

   rewrite ghost_core in *; destruct (ghost_of phi); auto; discriminate.

Qed.



Lemma age1_YES: forall phi phi' l rsh sh k ,

  age1 phi = Some phi' -> (phi @ l = YES rsh sh k NoneP <-> phi' @ l = YES rsh sh k NoneP).

Proof.

intros.

apply necR_YES'.

constructor 1; auto.

Qed.



Lemma age1_YES': forall phi phi' l rsh sh k ,

  age1 phi = Some phi' -> ((exists P, phi @ l = YES rsh sh k P) <-> exists P, phi' @ l = YES rsh sh k P).

Proof.

intros.

apply necR_YES''.

constructor 1; auto.

Qed.



Lemma age1_NO: forall phi phi' l sh nsh,

  age1 phi = Some phi' -> (phi @ l = NO sh nsh <-> phi' @ l = NO sh nsh).

Proof.

intros.

apply necR_NO.

constructor 1; auto.

Qed.



Lemma age1_PURE: forall phi phi' l k ,

  age1 phi = Some phi' -> ((exists P, phi @ l = PURE k P) <-> exists P, phi' @ l = PURE k P).

Proof.

  intros.

  apply necR_PURE'.

  constructor 1; auto.

Qed.



Lemma necR_ghost_of:

  forall phi phi',

        necR phi phi' ->

         ghost_of phi' = ghost_fmap (approx (level phi')) (approx (level phi')) (ghost_of phi).

Proof.

  induction 1.

  - apply age1_ghost_of; auto.

  - symmetry; apply ghost_of_approx.

  - rewrite IHclos_refl_trans2, IHclos_refl_trans1, ghost_fmap_fmap.

    apply necR_level in H0.

    rewrite approx_oo_approx', approx'_oo_approx; auto.

Qed.



Lemma empty_NO: forall r, identity r -> r = NO Share.bot bot_unreadable \/ exists k, exists pds, r = PURE k pds.

Proof.

intros.

destruct r; auto.

left. f_equal. apply identity_unit' in H. inv H.

  apply identity_unit_equiv in RJ. apply identity_share_bot in RJ. subst.

 f_equal. apply proof_irr.

unfold identity in H.

specialize ( H (NO Share.bot bot_unreadable) (YES sh r k p)).

spec H.

apply res_join_NO2.

auto.

inv H.

right. exists k. exists p. trivial.

Qed.



Lemma level_age_fash:

  forall m m': rmap, level m = S (level m') -> exists m1, age m m1.

Proof.

  intros.

  case_eq (age1 m); intros.

  exists r. auto.

  elimtype False.

  eapply age1None_levelS_absurd in H0; eauto.

Qed.



Lemma level_later_fash:

 forall m m': rmap, (level m > level m')%nat  -> exists m1, laterR m m1 /\ level m1 = level m'.

Proof.

  intros.

  assert (exists k, level m = S k + level m')%nat.

    exists (level m - S (level m'))%nat.

    omega.

  clear H; destruct H0 as [k ?].

  revert m H; induction k; intros.

  simpl in H.

  destruct (level_age_fash _ _ H) as [m1 ?].

  exists m1; split; auto.

  constructor 1; auto.

  apply age_level in H0. rewrite H in H0. inv H0. trivial.

  case_eq (age1 m); intros.

  specialize ( IHk r).

  rewrite <- ageN1 in H0.

  generalize (ageN_level _ _ _ H0); intro.

  spec IHk; try omega.

  destruct IHk as [m1 [? ?]].

  exists m1; split; auto.

  econstructor 2; eauto.

  rewrite ageN1 in H0.

  constructor 1.

  auto.

  elimtype False.

  eapply age1None_levelS_absurd in H0; eauto.

Qed.



Lemma resource_at_constructive_joins2:

  forall phi1 phi2,

       level phi1 = level phi2 ->

       (forall loc, constructive_joins (phi1 @ loc) (phi2 @ loc)) ->

       constructive_joins (ghost_of phi1) (ghost_of phi2) ->

         constructive_joins phi1 phi2.

Proof.

intros ? ? ? H0 Hg.

pose proof I.

destruct Hg.

destruct (make_rmap (fun loc => proj1_sig (H0 loc)) x (level phi1)) as [phi' [? [? ?]]].

clear H1.

unfold compose; extensionality loc.



destruct (H0 loc) as [? H1]. clear H0.

simpl.

symmetry.

revert H1; case_eq (phi1 @ loc); intros.

inv H1. reflexivity.

pose proof (resource_at_approx phi2 loc). rewrite <- H4 in H1. simpl in H1.

injection H1; intros.

simpl; f_equal; auto. rewrite H; auto.

inv H1.

pose proof (resource_at_approx phi1 loc). rewrite H0 in H1. simpl in H1.

injection H1; intros.

simpl; f_equal; auto.

simpl; f_equal.

pose proof (resource_at_approx phi1 loc). rewrite H0 in H1. simpl in H1.

injection H1; intros; auto.

inv H1.

simpl; f_equal.

pose proof (resource_at_approx phi1 loc). rewrite H0 in H1. simpl in H1.

injection H1; intros; auto.

eapply ghost_same_level_gen.

rewrite ghost_of_approx, H, ghost_of_approx; auto.



exists phi'.

apply resource_at_join2; auto.

congruence.

intros.

rewrite H3.

destruct (H0 loc).

simpl; auto.

rewrite H4; auto.

Qed.



Lemma resource_at_joins2:

  forall phi1 phi2,

       level phi1 = level phi2 ->

       (forall loc, constructive_joins (phi1 @ loc) (phi2 @ loc)) ->

       constructive_joins (ghost_of phi1) (ghost_of phi2) ->

         joins phi1 phi2.

Proof.

  intros.

  apply cjoins_joins.

  apply resource_at_constructive_joins2; trivial.

Qed.



Definition no_preds (r: resource) :=

   match r with NO _ _ => True | YES _ _ _ pp => pp=NoneP | PURE _ pp => pp=NoneP end.



Lemma remake_rmap:

  forall (f: AV.address -> resource) g,

       forall n,

       (forall l, (exists m, level m = n /\ f l = m @ l) \/ no_preds (f l)) ->

       ghost_fmap (approx n) (approx n) g = g ->

       {phi: rmap | level phi = n /\ resource_at phi = f /\ ghost_of phi = g}.

Proof.

  intros.

  apply make_rmap; auto.

  extensionality l.

  unfold compose.

  destruct (H l); clear H.

  destruct H1 as [m [?  ?]].

  rewrite H1.

  subst.

  apply resource_at_approx.

  destruct (f l); simpl in *; auto.

  subst p; reflexivity.

  subst p; reflexivity.

Qed.



Lemma rmap_unage_age:

  forall r, age (rmap_unage r) r.

Proof.

intros; unfold age, rmap_unage; simpl.

case_eq (unsquash r); intros.

rewrite rmap_age1_eq.

rewrite unsquash_squash.

f_equal.

apply unsquash_inj.

rewrite H.

rewrite unsquash_squash.

f_equal.

generalize (equal_f (rmap_fmap_comp (approx (S n)) (approx (S n)) (approx n) (approx n)) r0); intro.

unfold compose at 1 in H0.

rewrite H0.

rewrite approx_oo_approx'; auto.

rewrite approx'_oo_approx; auto.

clear - H.

generalize (unsquash_squash n r0); intros.

rewrite <- H in H0.

rewrite squash_unsquash in H0.

congruence.

Qed.



Lemma ageN_resource_at_eq:

  forall phi1 phi2 loc n phi1' phi2',

          level phi1 = level phi2 ->

          phi1 @ loc = phi2 @ loc ->

         ageN n phi1 = Some phi1' ->

         ageN n phi2 = Some phi2' ->

         phi1' @ loc = phi2' @ loc.

Proof.

intros ? ? ? ? ? ? Hcomp ? ? ?; revert phi1 phi2 phi1' phi2' Hcomp H H0 H1; induction n; intros.

inv H0; inv H1; auto.

unfold ageN in H0, H1.

simpl in *.

revert H0 H1; case_eq (age1 phi1); case_eq (age1 phi2); intros; try discriminate.

assert (level r = level r0) by (apply age_level in H0; apply age_level in H1; omega).

apply (IHn r0 r); auto.

rewrite (age1_resource_at _ _ H0 loc _ (eq_sym (resource_at_approx _ _))).

rewrite (age1_resource_at _ _ H1 loc _ (eq_sym (resource_at_approx _ _))).

rewrite H. rewrite H4; auto.

Qed.



Definition empty_rmap' : rmap' :=

  ((fun _: AV.address => NO Share.bot bot_unreadable), nil).



Definition empty_rmap (n:nat) : rmap := R.squash (n, empty_rmap').



Lemma emp_empty_rmap: forall n, emp (empty_rmap n).

Proof.

intros.

intro; intros.

apply rmap_ext.

Comp.

intros.

apply (resource_at_join _ _ _ l) in H.

unfold empty_rmap, empty_rmap', resource_at in *.

destruct (unsquash a); destruct (unsquash b).

simpl in *.

destruct r; destruct r0; simpl in *.

rewrite unsquash_squash in H.

simpl in *.

unfold compose in H.

inv H; auto; apply join_unit1_e in RJ; auto; subst; proof_irr; auto.

eapply (core_identity nil).

rewrite ghost_core.

replace nil with (ghost_of (empty_rmap n)); [apply ghost_of_join; auto|].

unfold ghost_of, empty_rmap, empty_rmap'.

rewrite unsquash_squash; auto.

Qed.



Lemma empty_rmap_level:

  forall lev, level (empty_rmap lev) = lev.

Proof.

intros.

simpl.

rewrite rmap_level_eq.

unfold  empty_rmap.

rewrite unsquash_squash; auto.

Qed.



Lemma approx_FF: forall n, approx n FF = FF.

Proof.

intros.

apply pred_ext; auto.

unfold approx; intros ? ?.

hnf in H. destruct H; auto.

Qed.



Lemma resource_at_make_rmap: forall f g lev H Hg, 

     resource_at (proj1_sig (make_rmap f g lev H Hg)) = f.

refine (fun f g lev H Hg => match proj2_sig (make_rmap f g lev H Hg) with

                           | conj _ (conj RESOURCE_AT _) => RESOURCE_AT

                         end).

Qed.



Lemma level_make_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (make_rmap f g lev H Hg)) = lev.

refine (fun f g lev H Hg => match proj2_sig (make_rmap f g lev H Hg) with

                           | conj LEVEL _ => LEVEL

                         end).

Qed.



Instance Join_trace : Join (AV.address -> option (rshare * AV.kind)) :=

     (Join_fun AV.address (option (rshare * AV.kind))

                   (Join_lower (Join_prod rshare Join_rshare AV.kind (Join_equiv AV.kind)))).



 Lemma res_option_join:

    forall x y z, 

     join x y z -> 

     @join _ (@Join_lower (rshare * AV.kind)

     (Join_prod rshare Join_rshare AV.kind (Join_equiv AV.kind))) (res_option x) (res_option y) (res_option  z).

 Proof.

   intros.

   inv H; simpl; try constructor.

   erewrite join_readable_part_eq by eassumption. constructor.

   apply join_comm in  RJ.

   erewrite join_readable_part_eq by eassumption. constructor.

   constructor. apply join_readable_part; auto.

   split; auto. 

 Qed.



Ltac uniq_assert name P := 

 lazymatch goal with H: P |- _ => fail 

    | _ => let H1 := fresh "H" name in assert (H1:P) end.



Ltac readable_unreadable_join_prover := 

repeat match goal with

| H: join ?A ?B ?C, H1: ~readable_share ?C |- _ =>

   uniq_assert A (~readable_share A);

    [ clear - H H1; contradict H1; eapply join_readable1; eauto; fail | ]

| H: join ?A ?B ?C, H1: ~readable_share ?C |- _ =>

   uniq_assert B (~readable_share B);

    [ clear - H H1; contradict H1; eapply join_readable2; eauto; fail | ]

| H: join ?A ?B ?C, H0: ~readable_share ?B, H1: readable_share ?C |- _ =>

    (uniq_assert A (readable_share A);

    [ clear - H H0 H1; destruct (readable_share_dec A); 

      [solve [auto]

       |eapply join_unreadable_shares in H; eauto; solve [contradiction]] | ])

| H: join ?A ?B ?C, H0: ~readable_share ?A, H1: readable_share ?C |- _ =>

    (uniq_assert B (readable_share B);

    [ clear - H H0 H1; destruct (readable_share_dec B); 

      [solve [auto]

       | apply join_comm in H; 

         eapply join_unreadable_shares in H; eauto; solve [contradiction]] | ])

end.



Definition res_retain (r: resource) : Share.t :=

 match r with

  | NO sh _ => retainer_part sh

  | YES sh _ _ _ => retainer_part sh

  | PURE _ _ => Share.bot

 end.



Lemma fixup_trace_readable:

  forall a (b: rshare), readable_share (Share.lub (Share.glb Share.Lsh a) (Share.glb Share.Rsh (proj1_sig b))).

Proof.

intros.

destruct b as [b H].

forget (Share.glb Share.Lsh a) as a'. clear a.

simpl.

destruct H as [H' H].

do 3 red in H|-*.

simpl.

contradict H.

rewrite Share.distrib1 in H.

rewrite <- Share.glb_assoc in H.

rewrite Share.glb_idem in H.

apply identity_share_bot in H.

apply lub_bot_e in H. destruct H.

rewrite H0. apply bot_identity.

Qed.



Lemma identity_resource: forall r: resource, identity r <->

    match r with YES _ _ _ _ => False | NO sh rsh => identity sh | PURE _ _ => True end.

Proof.

 intros. destruct r.

 - split; intro.

   + apply identity_unit' in H. inv H; auto. apply identity_unit_equiv; auto.

   + repeat intro.

     inv H0.

     * apply H in RJ; subst.

       f_equal; apply proof_irr.

     * apply H in RJ; subst.

       f_equal; apply proof_irr.

 - intuition.

   specialize (H (NO Share.bot bot_unreadable) (YES sh r k p)).

   spec H. constructor. apply join_unit2; auto. inv H.

 - intuition. intros  ? ? ?. inv H0. auto.

Qed.



Lemma resource_at_core_identity:  forall m i, identity (core m @ i).

Proof.

  intros.

  generalize (core_duplicable m); intro Hdup. apply (resource_at_join _ _ _ i) in Hdup.

  apply identity_resource.

  case_eq (core m @ i); intros; auto.

  rewrite H in Hdup. inv Hdup. apply identity_unit_equiv; auto.

  rewrite H in Hdup. inv Hdup.

  clear - r RJ.

  apply unit_identity in RJ. apply identity_share_bot in RJ.

  subst. apply bot_unreadable in r. auto.

Qed.



Lemma YES_inj: forall sh rsh k pp sh' rsh' k' pp',

           YES sh rsh k pp = YES sh' rsh' k' pp' ->

            (sh,k,pp) = (sh',k',pp').

Proof. intros. inv H. auto. Qed.



Lemma SomeP_inj1: forall t t' a a', SomeP t a = SomeP t' a' -> t=t'.

  Proof. intros. inv H; auto. Qed.

Lemma SomeP_inj2: forall t a a', SomeP t a = SomeP t a' -> a=a'.

  Proof. intros. inv H. apply inj_pair2 in H1. auto. Qed.

Lemma SomeP_inj:

   forall T a b, SomeP T a = SomeP T b -> a=b.

Proof. intros. inv H. apply inj_pair2 in H1. auto.

Qed.



Lemma PURE_inj: forall T x x' y y', PURE x (SomeP T y) = PURE x' (SomeP T y') -> x=x' /\ y=y'.

 Proof. intros. inv H. apply inj_pair2 in H2. subst; auto.

 Qed.



Lemma core_resource_at: forall w i, core (w @ i) = core w @ i.

Proof.

 intros.

 replace (core w @ i) with (core (core w @ i)).

 pose proof (core_unit (w @ i)) as H1.

 pose proof (core_unit w) as H2.

 apply (resource_at_join _ _ _ i) in H2.

 unfold unit_for in *.

 rewrite <- core_idem.

 destruct (join_assoc (join_comm H1) (join_comm H2)) as [? [? ?]].

 eapply join_core2; eauto.

 symmetry; apply identity_core, resource_at_core_identity.

Qed.



Lemma core_ghost_of: forall w, core (ghost_of w) = ghost_of (core w).

Proof.

 symmetry; apply ghost_of_core.

Qed.



Lemma ghost_of_core_identity: forall m, identity (ghost_of (core m)).

Proof.

  intro; rewrite <- core_ghost_of; apply core_identity.

Qed.



Lemma resource_at_identity: forall (m: rmap) (loc: AV.address),

 identity m -> identity (m @ loc).

Proof.

 intros.

 replace m with (core m) in * by (symmetry; apply identity_core; auto).

 apply resource_at_core_identity.

Qed.



Lemma ghost_of_identity: forall (m : rmap),

 identity m -> identity (ghost_of m).

Proof.

 intros.

 replace m with (core m) in * by (symmetry; apply identity_core; auto).

 apply ghost_of_core_identity.

Qed.



Lemma core_YES: forall sh rsh k pp, core (YES sh rsh k pp) = NO Share.bot bot_unreadable.

Proof.

 intros. generalize (core_unit (YES sh rsh k pp)); unfold unit_for; intros. 

 inv H; auto.

 apply unit_identity in RJ. apply identity_share_bot in RJ. subst; auto.

 f_equal. apply proof_irr.

 clear - H1.

 pose proof (core_unit (YES sh rsh k pp)).

 hnf in H. inv H.

 rewrite <- H2 in H1. inv H1.

 rewrite <- H2 in H1. inv H1.

 apply unit_identity in RJ. apply identity_share_bot in RJ. subst sh0.

 contradiction (bot_unreadable rsh0).

Qed.



Lemma core_NO: forall sh nsh, core (NO sh nsh) = NO Share.bot bot_unreadable.

Proof.

 intros.  generalize (core_unit (NO sh nsh)); unfold unit_for; intros.

 inv H; auto.

 pose proof (core_unit (NO sh nsh)).

 apply unit_identity in RJ. apply identity_share_bot in RJ. subst sh1.

 f_equal. apply proof_irr.

Qed.



Lemma core_PURE: forall k pp, core (PURE k pp) = PURE k pp.

Proof.

 intros. generalize (core_unit (PURE k pp)); unfold unit_for; intros.

 inv H; auto.

Qed.



Lemma core_not_YES: forall {w loc rsh sh k pp},

   core w @ loc = YES rsh sh k pp -> False.

Proof.

intros.

pose proof (core_duplicable w) as Hj.

apply (resource_at_join _ _ _ loc) in Hj; rewrite H in Hj.

inv Hj.

eapply readable_nonidentity; eauto.

eapply unit_identity; eauto.

Qed.



Lemma resource_at_empty2:

 forall phi: rmap, (forall l, identity (phi @ l)) -> identity (ghost_of phi) -> identity phi.

Proof.

  apply all_resource_at_identity. 

Qed.



Lemma resource_fmap_core:

  forall w loc, resource_fmap (approx (level w)) (approx (level w)) (core (w @ loc)) = core (w @ loc).

Proof.

intros.

case_eq (w @ loc); intros;

 [rewrite core_NO | rewrite core_YES | rewrite core_PURE]; auto.

rewrite <- H. apply resource_at_approx.

Qed.



End Rmaps_Lemmas.

