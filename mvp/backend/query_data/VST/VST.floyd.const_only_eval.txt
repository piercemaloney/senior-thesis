Require Import VST.floyd.base.
(* VST.floyd.base:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.veric.juicy_extspec.
Require Import VST.veric.NullExtension.
Require Export VST.floyd.jmeq_lemmas.
Require Export VST.floyd.find_nth_tactic.
Require Export VST.floyd.val_lemmas.
Require Export VST.floyd.assert_lemmas.
Require VST.floyd.SeparationLogicAsLogicSoundness.
Export SeparationLogicAsLogicSoundness.MainTheorem.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Defs.

Local Open Scope logic.

Definition extract_exists_pre:
  forall {CS: compspecs} {Espec: OracleKind},
  forall (A : Type) (P : A -> environ->mpred) c (Delta: tycontext) (R: ret_assert),
  (forall x, @semax CS Espec Delta (P x) c R) ->
   @semax CS Espec Delta (EX x:A, P x) c R
  := @semax_extract_exists.

Arguments alignof_two_p {env} t.

Lemma co_alignof_pos: forall co, (co_alignof co > 0)%Z.

Section GET_CO.

Context {cs: compspecs}.

Open Scope Z.

Definition co_default (s: struct_or_union): composite.

Definition get_co id :=
  match cenv_cs ! id with
  | Some co => co
  | _ => co_default Struct
  end.

Lemma co_default_consistent: forall su, composite_consistent cenv_cs (co_default su).

Lemma get_co_consistent: forall id, composite_consistent cenv_cs (get_co id).

Lemma get_co_members_nil_sizeof_0: forall id,
  co_members (get_co id) = nil -> co_sizeof (get_co id) = 0%Z.

Lemma get_co_members_no_replicate: forall id,
  members_no_replicate (co_members (get_co id)) = true.

Lemma sizeof_Tstruct: forall id a,
  sizeof (Tstruct id a) = co_sizeof (get_co id).

Lemma sizeof_Tunion: forall id a,
  sizeof (Tunion id a) = co_sizeof (get_co id).

End GET_CO.

Lemma co_members_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_members (@get_co cs_from id) = co_members (@get_co cs_to id).

Lemma co_sizeof_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_sizeof (@get_co cs_from id) = co_sizeof (@get_co cs_to id).

Definition member_dec: forall (it0 it1: ident * type), {it0 = it1} + {it0 <> it1}.

Fixpoint fold_right_sepcon (l: list mpred) : mpred :=
 match l with
 | nil => emp
 | b::r => b * fold_right_sepcon r
 end.

Inductive LLRR : Type :=
  | LLLL : LLRR
  | RRRR : LLRR. *)

Require Import VST.floyd.val_lemmas.
(* VST.floyd.val_lemmas:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.floyd.functional_base.

Lemma is_int_dec i s v: {is_int i s v} + {~ is_int i s v}.

Lemma tc_val_dec t v: {tc_val t v} + {~ tc_val t v}.

Lemma sem_add_pi_ptr:
   forall {cs: compspecs}  t p i si,
    isptr p ->
    match si with
    | Signed => Int.min_signed <= i <= Int.max_signed
Hint Rewrite @sem_add_pi_ptr using (solve [auto with norm]) : norm.

Lemma sem_cast_i2i_correct_range: forall sz s v,
  is_int sz s v -> sem_cast_i2i sz s v = Some v.
Hint Rewrite sem_cast_i2i_correct_range using (solve [auto with norm]) : norm.

Lemma sem_cast_neutral_ptr:
  forall p, isptr p -> sem_cast_pointer p = Some p.
Hint Rewrite sem_cast_neutral_ptr using (solve [auto with norm]): norm.

Lemma sem_cast_neutral_Vint: forall v,
  sem_cast_pointer (Vint v) = Some (Vint v).
Hint Rewrite sem_cast_neutral_Vint : norm.

Definition isVint v := match v with Vint _ => True | _ => False end.

Lemma is_int_is_Vint: forall i s v, is_int i s v -> isVint v.

Lemma is_int_I32_Vint: forall s v, is_int I32 s (Vint v).
Hint Resolve is_int_I32_Vint.

Lemma sem_cast_neutral_int: forall v,
  isVint v ->
  sem_cast_pointer v = Some v.

Hint Rewrite sem_cast_neutral_int using
  (auto;
   match goal with H: is_int ?i ?s ?v |- isVint ?v => apply (is_int_is_Vint i s v H) end) : norm.

Lemma sizeof_tuchar: forall {cs: compspecs}, sizeof tuchar = 1%Z.
Hint Rewrite @sizeof_tuchar: norm.

Hint Rewrite Z.mul_1_l Z.mul_1_r Z.add_0_l Z.add_0_r Z.sub_0_r : norm.

Hint Rewrite eval_id_same : norm.
Hint Rewrite eval_id_other using solve [clear; intro Hx; inversion Hx] : norm.
Hint Rewrite Int.sub_idem Int.sub_zero_l  Int.add_neg_zero : norm.
Hint Rewrite Ptrofs.sub_idem Ptrofs.sub_zero_l  Ptrofs.add_neg_zero : norm.

Lemma eval_expr_Etempvar:
  forall {cs: compspecs}  i t, eval_expr (Etempvar i t) = eval_id i.
Hint Rewrite @eval_expr_Etempvar : eval.

Lemma eval_expr_binop: forall {cs: compspecs}  op a1 a2 t, eval_expr (Ebinop op a1 a2 t) =
          `(eval_binop op (typeof a1) (typeof a2)) (eval_expr a1) (eval_expr a2).
Hint Rewrite @eval_expr_binop : eval.

Lemma eval_expr_unop: forall {cs: compspecs} op a1 t, eval_expr (Eunop op a1 t) =
          lift1 (eval_unop op (typeof a1)) (eval_expr a1).
Hint Rewrite @eval_expr_unop : eval.

Hint Resolve  eval_expr_Etempvar.

Lemma eval_expr_Etempvar' : forall {cs: compspecs}  i t, eval_id i = eval_expr (Etempvar i t).
Hint Resolve  @eval_expr_Etempvar'.

Hint Rewrite Int.add_zero  Int.add_zero_l Int.sub_zero_l : norm.
Hint Rewrite Ptrofs.add_zero  Ptrofs.add_zero_l Ptrofs.sub_zero_l : norm.

Lemma eval_var_env_set:
  forall i t j v (rho: environ), eval_var i t (env_set rho j v) = eval_var i t rho.
Hint Rewrite eval_var_env_set : norm.

Lemma eval_expropt_Some: forall {cs: compspecs}  e, eval_expropt (Some e) = `Some (eval_expr e).
Lemma eval_expropt_None: forall  {cs: compspecs} , eval_expropt None = `None.
Hint Rewrite @eval_expropt_Some @eval_expropt_None : eval.

Lemma deref_noload_tarray:
  forall ty n, deref_noload (tarray ty n) = (fun v => v).
Hint Rewrite deref_noload_tarray : norm.

Lemma deref_noload_Tarray:
  forall ty n a, deref_noload (Tarray ty n a) = (fun v => v).
Hint Rewrite deref_noload_Tarray : norm.

Lemma flip_lifted_eq:
  forall (v1: environ -> val) (v2: val),
    `eq v1 `(v2) = `(eq v2) v1.
Hint Rewrite flip_lifted_eq : norm.

Lemma isptr_is_pointer_or_null:
  forall v, isptr v -> is_pointer_or_null v.
Hint Resolve isptr_is_pointer_or_null.

Definition add_ptr_int  {cs: compspecs}  (ty: type) (v: val) (i: Z) : val :=
           eval_binop Cop.Oadd (tptr ty) tint v (Vint (Int.repr i)).

Lemma add_ptr_int_offset:
  forall  {cs: compspecs}  t v n,
  repable_signed (sizeof t) ->
  repable_signed n ->
  add_ptr_int t v n = offset_val (sizeof t * n) v.
Abort. 

Lemma typed_false_cmp:
  forall op i j ,
   typed_false tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp (negate_comparison op) i j = true.

Lemma typed_true_cmp:
  forall op i j,
   typed_true tint (force_val (sem_cmp op tint tint (Vint i) (Vint j))) ->
   Int.cmp op i j = true.

Definition Zcmp (op: comparison) : Z -> Z -> Prop :=
 match op with
 | Ceq => eq
 | Cne => (fun i j => i<>j)
 | Clt => Z.lt
 | Cle => Z.le
 | Cgt => Z.gt
 | Cge => Z.ge
 end.

Lemma int_cmp_repr:
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = true ->

Lemma typed_false_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_false tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Lemma typed_true_cmp_repr:
  forall op i j,
   repable_signed i -> repable_signed j ->
   typed_true tint (force_val (sem_cmp op tint tint
                              (Vint (Int.repr i))

Ltac intcompare H :=
 (apply typed_false_cmp_repr in H || apply typed_true_cmp_repr in H);
   [ simpl in H | auto; unfold repable_signed, Int.min_signed, Int.max_signed in *; omega .. ].

Lemma isptr_deref_noload:
 forall t p, access_mode t = By_reference -> isptr (deref_noload t p) = isptr p.
Hint Rewrite isptr_deref_noload using reflexivity : norm.

Definition headptr (v: val): Prop :=
  exists b,  v = Vptr b Ptrofs.zero.

Lemma headptr_isptr: forall v,
  headptr v -> isptr v.
Hint Resolve headptr_isptr.

Lemma headptr_offset_zero: forall v,
  headptr (offset_val 0 v) <->
  headptr v.

Lemma typed_false_ptr:
  forall {t a v},  typed_false (Tpointer t a) v -> v=nullval.

Lemma typed_true_ptr:
  forall {t a v},  typed_true (Tpointer t a) v -> isptr v.

Lemma int_cmp_repr':
 forall op i j, repable_signed i -> repable_signed j ->
   Int.cmp op (Int.repr i) (Int.repr j) = false ->

Lemma typed_false_of_bool:
 forall x, typed_false tint (Val.of_bool x) -> (x=false).

Lemma typed_true_of_bool:
 forall x, typed_true tint (Val.of_bool x) -> (x=true).

Lemma typed_false_tint:
 Archi.ptr64=false -> 

Lemma typed_false_tlong:
 Archi.ptr64=true -> 

Lemma typed_true_e:
 forall t v, typed_true t v -> v<>nullval.

Lemma typed_false_tint_Vint:
  forall v, typed_false tint (Vint v) -> v = Int.zero.

Lemma typed_true_tint_Vint:
  forall v, typed_true tint (Vint v) -> v <> Int.zero.

Lemma typed_true_tlong_Vlong:
  forall v, typed_true tlong (Vlong v) -> v <> Int64.zero.

Ltac intro_redundant_prop :=
  
match goal with |- ?P -> _ =>
  ((assert P by immediate; fail 1) || fail 1) || intros _
end.

Ltac fancy_intro aggressive :=
 match goal with
 | |- ?P -> _ => match type of P with Prop => idtac end
 | |- ~ _ => idtac
 end;
 let H := fresh in
 intro H;
 try simple apply ptr_eq_e in H;
 try simple apply Vint_inj in H;
 try match type of H with
 | tc_val _ _ => unfold tc_val in H; try change (eqb_type _ _) with false in H; cbv iota in H
 end;
 match type of H with
 | ?P => clear H; 
              match goal with H': P |- _ => idtac end 
             + (((assert (H:P) by (clear; immediate); fail 1) || fail 1) || idtac)
                
 | ?x = ?y => constr_eq aggressive true;
                     first [subst x | subst y
                             | is_var x; rewrite H
                             | is_var y; rewrite <- H
                             | idtac]
 | headptr (_ ?x) => let Hx1 := fresh "HP" x in
                     let Hx2 := fresh "P" x in
                       rename H into Hx1;
                       pose proof headptr_isptr _ Hx1 as Hx2
 | headptr ?x => let Hx1 := fresh "HP" x in
                 let Hx2 := fresh "P" x in
                   rename H into Hx1;
                   pose proof headptr_isptr _ Hx1 as Hx2
 | isptr ?x => let Hx := fresh "P" x in rename H into Hx
 | is_pointer_or_null ?x => let Hx := fresh "PN" x in rename H into Hx
 | typed_false _ _ =>
        first [simple apply typed_false_of_bool in H
               | apply typed_false_tint_Vint in H
               | apply (typed_false_tint (eq_refl _)) in H
               | apply (typed_false_tlong (eq_refl _)) in H
               | apply typed_false_ptr in H
               | idtac ]
 | typed_true _ _ =>
        first [simple apply typed_true_of_bool in H
               | apply typed_true_tint_Vint in H
               | apply typed_true_tlong_Vlong in H

               | apply typed_true_ptr in H
               | idtac ]
 
 | _ => try solve [discriminate H]
 end.

Ltac fancy_intros aggressive :=
 repeat match goal with
  | |- (_ <= _ < _) -> _ => fancy_intro aggressive
  | |- (_ < _ <= _) -> _ => fancy_intro aggressive
  | |- (_ <= _ <= _) -> _ => fancy_intro aggressive
  | |- (_ < _ < _) -> _ => fancy_intro aggressive
  | |- (?A /\ ?B) -> ?C => apply (@and_ind A B C) 
  | |- _ -> _ => fancy_intro aggressive
  end.

Ltac fold_types :=
 fold noattr tuint tint tschar tuchar;
 repeat match goal with
 | |- context [Tpointer ?t noattr] =>
      change (Tpointer t noattr) with (tptr t)
 | |- context [Tarray ?t ?n noattr] =>
      change (Tarray t n noattr) with (tarray t n)
 end.

Ltac fold_types1 :=
  match goal with |- _ -> ?A =>
  let a := fresh "H" in set (a:=A); fold_types; subst a
  end.

Lemma is_int_Vbyte: forall c, is_int I8 Signed (Vbyte c).
Hint Resolve is_int_Vbyte. *)

Require Import VST.floyd.typecheck_lemmas.
(* VST.floyd.typecheck_lemmas:
Require Import VST.floyd.base.

Local Open Scope logic.

Lemma denote_tc_assert_andp:
  forall {CS: compspecs} (a b : tc_assert),
  denote_tc_assert (tc_andp a b) = andp (denote_tc_assert a) (denote_tc_assert b).

Lemma denote_tc_assert_orp:
  forall {CS: compspecs} (a b : tc_assert),
  denote_tc_assert (tc_orp a b) = orp (denote_tc_assert a) (denote_tc_assert b).

Lemma denote_tc_assert_bool:
  forall {CS: compspecs} b c, denote_tc_assert (tc_bool b c) =
               prop (b=true).

Lemma neutral_isCastResultType_64:
 Archi.ptr64 = true ->

Lemma neutral_isCastResultType_32:
 Archi.ptr64 = false ->

Lemma neutral_isCastResultType:
  forall {cs: compspecs}  P t t' v rho,
   is_neutral_cast t' t = true ->
   P |-- denote_tc_assert (isCastResultType t' t v) rho.

Lemma tc_andp_TT2:  forall e, tc_andp e tc_TT = e.

Lemma tc_andp_TT1:  forall e, tc_andp tc_TT e = e.
Hint Rewrite tc_andp_TT1 tc_andp_TT2 : norm.

Definition typecheck_LR_strong {cs: compspecs} Delta e lr :=
  match lr with
  | LLLL => typecheck_lvalue Delta e
  | RRRR => typecheck_expr Delta e
  end.

Definition typecheck_LR {cs: compspecs} Delta e lr :=
  match e with
  | Ederef e0 t =>
     match lr with
     | LLLL => tc_andp
                 (typecheck_expr Delta e0)
                 (tc_bool (is_pointer_type (typeof e0))(op_result_type e))
     | RRRR => match access_mode t with
               | By_reference =>
                  tc_andp
                     (typecheck_expr Delta e0)
                     (tc_bool (is_pointer_type (typeof e0))(op_result_type e))
               | _ => tc_FF (deref_byvalue t)
               end
    end
  | _ => typecheck_LR_strong Delta e lr
  end.

Definition tc_LR_strong {cs: compspecs} Delta e lr := denote_tc_assert (typecheck_LR_strong Delta e lr).

Definition tc_LR {cs: compspecs} Delta e lr := denote_tc_assert (typecheck_LR Delta e lr).

Definition eval_LR {cs: compspecs} e lr :=
  match lr with
  | LLLL => eval_lvalue e
  | RRRR => eval_expr e
  end.

Lemma tc_LR_tc_LR_strong: forall {cs: compspecs} Delta e lr rho,
  tc_LR Delta e lr rho && !! isptr (eval_LR e lr rho) |-- tc_LR_strong Delta e lr rho. *)



Definition const_only_isUnOpResultType {CS: compspecs} op typeof_a valueof_a ty : bool :=

match op with

  | Cop.Onotbool => match typeof_a with

                    | Tint _ _ _

                    | Tlong _ _

                    | Tfloat _ _ => is_int_type ty

                    | Tpointer _ _ =>

                        if Archi.ptr64 

                        then match valueof_a with

                             | Vlong v =>

                                andb (negb (eqb_type (typeof_a) int_or_ptr_type))

                                     (andb (is_int_type ty) (Z.eqb 0 (Int64.unsigned v)))

                             | _ => false

                             end

                        else match valueof_a with

                             | Vint v => 

                                andb (negb (eqb_type typeof_a int_or_ptr_type))

                                     (andb (is_int_type ty) (Z.eqb 0 (Int.unsigned v)))

                             | _ => false

                             end

                    | _ => false

                    end

  | Cop.Onotint => match Cop.classify_notint (typeof_a) with

                   | Cop.notint_default => false

                   | Cop.notint_case_i _ => (is_int32_type ty)

                   | Cop.notint_case_l _ => (is_long_type ty)

                   end

  | Cop.Oneg => match Cop.classify_neg (typeof_a) with

                    | Cop.neg_case_i sg => 

                          andb (is_int32_type ty)

                          match (typeof_a) with

                          | Tint _ Signed _ =>

                            match valueof_a with

                            | Vint v => negb (Z.eqb (Int.signed v) Int.min_signed)

                            | _ => false

                            end

                          | Tlong Signed _ =>

                            match valueof_a with

                            | Vlong v => negb (Z.eqb (Int64.signed v) Int64.min_signed)

                            | _ => false

                            end

                          | _ => true

                          end

                    | Cop.neg_case_f => is_float_type ty

                    | Cop.neg_case_s => is_single_type ty

                    | _ => false

                    end

  | Cop.Oabsfloat =>match Cop.classify_neg (typeof_a) with

                    | Cop.neg_case_i sg => is_float_type ty

                    | Cop.neg_case_l _ => is_float_type ty

                    | Cop.neg_case_f => is_float_type ty

                    | Cop.neg_case_s => is_float_type ty

                    | _ => false

                    end

end.



Definition const_only_isBinOpResultType {CS: compspecs} op typeof_a1 valueof_a1 typeof_a2 valueof_a2 ty : bool :=

  match op with

  | Cop.Oadd =>

      match Cop.classify_add (typeof_a1) (typeof_a2) with

      | Cop.add_case_pi t _ | Cop.add_case_pl t =>

        andb

          (andb

             (andb (match valueof_a1 with Vptr _ _ => true | _ => false end) (complete_type cenv_cs t))

             (negb (eqb_type (typeof_a1) int_or_ptr_type)))

          (is_pointer_type ty)

    | Cop.add_case_ip _ t | Cop.add_case_lp t =>

        andb

          (andb

             (andb (match valueof_a2 with Vptr _ _ => true | _ => false end) (complete_type cenv_cs t))

             (negb (eqb_type (typeof_a2) int_or_ptr_type)))

          (is_pointer_type ty)

    | Cop.add_default => false

                           
      end

  | _ => false 

  end.



Definition const_only_isCastResultType {CS: compspecs} (t1 t2: type) (valueof_a: val)  : bool := false. 



Fixpoint const_only_eval_expr {cs: compspecs} (e: Clight.expr): option val :=

  match e with

  | Econst_int i (Tint I32 _ _) => Some (Vint i)

  | Econst_int _ _ => None

  | Econst_long i ty => None 

  | Econst_float f (Tfloat F64 _) => Some (Vfloat f)

  | Econst_float _ _ => None

  | Econst_single f (Tfloat F32 _) => Some (Vsingle f)

  | Econst_single _ _ => None

  | Etempvar id ty => None

  | Evar _ _ => None

  | Eaddrof a ty => None

  | Eunop op a ty =>

      match const_only_eval_expr a with

      | Some v => if const_only_isUnOpResultType op (typeof a) v ty

                  then Some (eval_unop op (typeof a) v)

                  else None

      | None => None

      end

  | Ebinop op a1 a2 ty =>

      match (const_only_eval_expr a1), (const_only_eval_expr a2) with

      | Some v1, Some v2 =>

          if const_only_isBinOpResultType op (typeof a1) v1 (typeof a2) v2 ty

          then Some (eval_binop op (typeof a1) (typeof a2) v1 v2)

          else None

      | _, _ => None

      end

  | Ecast a ty =>

      match const_only_eval_expr a with

      | Some v => if const_only_isCastResultType (typeof a) ty v

                  then Some (eval_cast (typeof a) ty v)

                  else None

      | None => None

      end

  | Ederef a ty => None

  | Efield a i ty => None

  | Esizeof t t0 =>

    if andb (complete_type cenv_cs t) (eqb_type t0 size_t)

    then Some (Vptrofs (Ptrofs.repr (sizeof t)))

    else None

  | Ealignof t t0 =>

    if andb (complete_type cenv_cs t) (eqb_type t0 size_t)

    then Some (Vptrofs (Ptrofs.repr (alignof t)))

    else None

  end.



Lemma const_only_isUnOpResultType_spec: forall {cs: compspecs} rho u e t P,

  const_only_isUnOpResultType u (typeof e) (eval_expr e rho) t = true ->

  P |-- denote_tc_assert (isUnOpResultType u e t) rho.

Proof.

  intros.

  unfold isUnOpResultType.

  unfold const_only_isUnOpResultType in H.

  destruct u.

  + destruct (typeof e);

      try solve [inv H | rewrite H; exact (@prop_right mpred _ True _ I)].

    rewrite !denote_tc_assert_andp.

    match goal with

    | |- context [denote_tc_assert (tc_test_eq ?a ?b)] =>

      change (denote_tc_assert (tc_test_eq a b)) with (expr2.denote_tc_assert (tc_test_eq a b))

    end.

    rewrite binop_lemmas2.denote_tc_assert_test_eq'.

    simpl expr2.denote_tc_assert.

    unfold_lift. simpl.

    unfold tc_int_or_ptr_type.

    destruct Archi.ptr64 eqn:HH.

    - destruct (eval_expr e rho); try solve [inv H].

      rewrite !andb_true_iff in H.

      destruct H as [? [? ?]].

      rewrite H, H0.

      rewrite Z.eqb_eq in H1.

      apply andp_right; [exact (@prop_right mpred _ True _ I) |].

      apply andp_right; [exact (@prop_right mpred _ True _ I) |].

      simpl.

      rewrite HH.

      change (P |-- (!! (i = Int64.zero)) && (!! (Int64.zero = Int64.zero)))%logic.

      apply andp_right; apply prop_right; auto.

      rewrite <- (Int64.repr_unsigned i), <- H1.

      auto.

    - destruct (eval_expr e rho); try solve [inv H].

      rewrite !andb_true_iff in H.

      destruct H as [? [? ?]].

      rewrite H, H0.

      rewrite Z.eqb_eq in H1.

      apply andp_right; [exact (@prop_right mpred _ True _ I) |].

      apply andp_right; [exact (@prop_right mpred _ True _ I) |].

      simpl.

      rewrite HH.

      change (P |-- (!! (i = Int.zero)) && (!! (Int.zero = Int.zero)))%logic.

      apply andp_right; apply prop_right; auto.

      rewrite <- (Int.repr_unsigned i), <- H1.

      auto.

  + destruct (Cop.classify_notint (typeof e));

      try solve [inv H | rewrite H; exact (@prop_right mpred _ True _ I)].

  + destruct (Cop.classify_neg (typeof e));

      try solve [inv H | rewrite H; exact (@prop_right mpred _ True _ I)].

    rewrite !andb_true_iff in H.

    destruct H.

    rewrite H; simpl.

    destruct (typeof e) as [| ? [|] | [|] | | | | | |];

      try solve [exact (@prop_right mpred _ True _ I)].

    - simpl.

      unfold_lift.

      unfold denote_tc_nosignedover.

      destruct (eval_expr e rho); try solve [inv H0].

      rewrite negb_true_iff in H0.

      rewrite Z.eqb_neq in H0.

      apply prop_right.

      change (Int.signed Int.zero) with 0.

      rep_omega.

    - simpl.

      unfold_lift.

      unfold denote_tc_nosignedover.

      destruct (eval_expr e rho); try solve [inv H0].

      rewrite negb_true_iff in H0.

      rewrite Z.eqb_neq in H0.

      apply prop_right.

      change (Int64.signed Int64.zero) with 0.

      rep_omega.

  + destruct (Cop.classify_neg (typeof e)); try solve [inv H | rewrite H; exact (@prop_right mpred _ True _ I)].

Qed.



Lemma const_only_isBinOpResultType_spec: forall {cs: compspecs} rho b e1 e2 t P,

  const_only_isBinOpResultType b (typeof e1) (eval_expr e1 rho) (typeof e2) (eval_expr e2 rho) t = true ->

  P |-- denote_tc_assert (isBinOpResultType b e1 e2 t) rho.

Proof.

  intros.

  unfold isBinOpResultType.

  unfold const_only_isBinOpResultType in H.

  destruct b.

  + destruct (Cop.classify_add (typeof e1) (typeof e2)).

    - rewrite !denote_tc_assert_andp; simpl.

      unfold_lift.

      unfold tc_int_or_ptr_type, denote_tc_isptr.

      destruct (eval_expr e1 rho); inv H.

      rewrite !andb_true_iff in H1.

      destruct H1 as [[? ?] ?].

      rewrite H, H0, H1.

      simpl.

      repeat apply andp_right; apply prop_right; auto.

    - rewrite !denote_tc_assert_andp; simpl.

      unfold_lift.

      unfold tc_int_or_ptr_type, denote_tc_isptr.

      destruct (eval_expr e1 rho); inv H.

      rewrite !andb_true_iff in H1.

      destruct H1 as [[? ?] ?].

      rewrite H, H0, H1.

      simpl.

      repeat apply andp_right; apply prop_right; auto.

    - rewrite !denote_tc_assert_andp; simpl.

      unfold_lift.

      unfold tc_int_or_ptr_type, denote_tc_isptr.

      destruct (eval_expr e2 rho); inv H.

      rewrite !andb_true_iff in H1.

      destruct H1 as [[? ?] ?].

      rewrite H, H0, H1.

      simpl.

      repeat apply andp_right; apply prop_right; auto.

    - rewrite !denote_tc_assert_andp; simpl.

      unfold_lift.

      unfold tc_int_or_ptr_type, denote_tc_isptr.

      destruct (eval_expr e2 rho); inv H.

      rewrite !andb_true_iff in H1.

      destruct H1 as [[? ?] ?].

      rewrite H, H0, H1.

      simpl.

      repeat apply andp_right; apply prop_right; auto.

    - inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

  + inv H.

Qed.



Lemma const_only_isCastResultType_spec: forall {cs: compspecs} rho e t P,

  const_only_isCastResultType (typeof e) t (eval_expr e rho) = true ->

  P |-- denote_tc_assert (isCastResultType (typeof e) t e) rho.

Proof.

  intros.

  inv H.

Qed.



Lemma const_only_eval_expr_eq: forall {cs: compspecs} rho e v,

  const_only_eval_expr e = Some v ->

  eval_expr e rho = v.  

Proof.

  intros.

  revert v H; induction e; try solve [intros; inv H; auto].

  + intros.

    simpl in *.

    destruct t as [| [| | |] | | | | | | |]; inv H.

    auto.

  + intros.

    simpl in *.

    destruct t as [| | | [|] | | | | |]; inv H.

    auto.

  + intros.

    simpl in *.

    destruct t as [| | | [|] | | | | |]; inv H.

    auto.

  + intros.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e); inv H.

    destruct (const_only_isUnOpResultType u (typeof e) v0 t); inv H1.

    specialize (IHe _ eq_refl).

    unfold_lift.

    rewrite IHe; auto.

  + intros.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e1); inv H.

    destruct (const_only_eval_expr e2); inv H1.

    destruct (const_only_isBinOpResultType b (typeof e1) v0 (typeof e2) v1 t); inv H0.

    specialize (IHe1 _ eq_refl).

    specialize (IHe2 _ eq_refl).

    unfold_lift.

    rewrite IHe1, IHe2; auto.

  + intros.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e); inv H. 


  + intros.

    simpl in *.

    destruct (complete_type cenv_cs t && eqb_type t0 size_t); inv H.

    auto.

  + intros.

    simpl in *.

    destruct (complete_type cenv_cs t && eqb_type t0 size_t); inv H.

    auto.

Qed.



Lemma const_only_eval_expr_tc: forall {cs: compspecs} Delta e v P,

  const_only_eval_expr e = Some v ->

  P |-- tc_expr Delta e.

Proof.

  intros.

  intro rho.

  revert v H; induction e; try solve [intros; inv H].

  + intros.

    inv H.

    destruct t as [| [| | |] | | | | | | |]; inv H1.

    exact (@prop_right mpred _ True _ I).

  + intros.

    inv H.

    destruct t as [| | | [|] | | | | |]; inv H1.

    exact (@prop_right mpred _ True _ I).

  + intros.

    inv H.

    destruct t as [| | | [|] | | | | |]; inv H1.

    exact (@prop_right mpred _ True _ I).

  + intros.

    unfold tc_expr in *.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e) eqn:HH; inv H.

    specialize (IHe _ eq_refl).

    unfold_lift.

    rewrite denote_tc_assert_andp; simpl; apply andp_right; auto.

    apply const_only_isUnOpResultType_spec.

    apply (const_only_eval_expr_eq rho) in HH.

    rewrite HH.

    destruct (const_only_isUnOpResultType u (typeof e) v0 t); inv H1; auto.

  + intros.

    unfold tc_expr in *.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e1) eqn:HH1; inv H.

    destruct (const_only_eval_expr e2) eqn:HH2; inv H1.

    specialize (IHe1 _ eq_refl).

    specialize (IHe2 _ eq_refl).

    unfold_lift.

    rewrite !denote_tc_assert_andp; simpl; repeat apply andp_right; auto.

    apply const_only_isBinOpResultType_spec.

    apply (const_only_eval_expr_eq rho) in HH1.

    apply (const_only_eval_expr_eq rho) in HH2.

    rewrite HH1, HH2.

    destruct (const_only_isBinOpResultType b (typeof e1) v0 (typeof e2) v1 t); inv H0; auto.

  + intros.

    unfold tc_expr in *.

    simpl in *.

    unfold option_map in H.

    destruct (const_only_eval_expr e) eqn:HH; inv H. 


  + intros.

    inv H.

    unfold tc_expr.

    simpl typecheck_expr.

    simpl.

    destruct (complete_type cenv_cs t && eqb_type t0 size_t) eqn:HH; inv H1.

    rewrite andb_true_iff in HH.

    unfold tuint in HH; destruct HH.

    rewrite H, H0.

    exact (@prop_right mpred _ True _ I).

  + intros.

    inv H.

    unfold tc_expr.

    simpl typecheck_expr.

    simpl.

    destruct (complete_type cenv_cs t && eqb_type t0 size_t) eqn:HH; inv H1.

    rewrite andb_true_iff in HH.

    unfold tuint in HH; destruct HH.

    rewrite H, H0.

    exact (@prop_right mpred _ True _ I).

Qed.

