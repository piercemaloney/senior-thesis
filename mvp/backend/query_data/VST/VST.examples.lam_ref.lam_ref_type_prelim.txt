

Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)



Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)

Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)



Module TFP <: TY_FUNCTOR_PROP.



  Definition F : Type -> Type := fun K => addr -> option K.



  Definition f_F := f_fun addr (f_option f_identity).



  Definition other : Type := value.

End TFP.



Export TFP.



Module K := KnotHered(TFP). 

Module KL := KnotHered_Lemmas(K).



Export K.

Export KL.



Definition mtype : Type := knot.

Definition world : Type := (mtype * value)%type.



Definition world_ag : ageable world :=

  ag_prod mtype value ag_knot.

Existing Instance world_ag.



Definition knot_extends (k1 k2 : knot) : Prop :=

  match (unsquash k1, unsquash k2) with

    ((n, psi), (n', psi')) => n = n' /\ forall a, (psi a = None) \/ (psi' a = psi a)

  end.



Definition R_extends (w1 w2 : world) : Prop :=

  match (w1, w2) with

    ((k1, v1), (k2, v2)) => knot_extends k1 k2 /\ v1 = v2

  end.



Lemma knot_extends_refl : forall k, knot_extends k k.

Proof.

  intros; hnf.

  destruct (unsquash k); intuition.

Qed.



Lemma knot_extends_trans : forall k1 k2 k3,

  knot_extends k1 k2 ->

  knot_extends k2 k3 ->

  knot_extends k1 k3.

Proof.

  unfold knot_extends; intuition.

  destruct (unsquash k1); destruct (unsquash k2); destruct (unsquash k3).

  intuition; subst.

  destruct (H2 a); destruct (H3 a); subst; auto.

  rewrite <- H; auto.

  rewrite H0; rewrite H; auto.

Qed.



Lemma knot_extends_age_commute1 : forall x y z,

  age x y /\ knot_extends y z -> exists y',

  knot_extends x y' /\ age y' z.

Proof.

  intros.

  case_eq (unsquash x); intros n1 fx Hx.

  case_eq (unsquash y); intros n2 fy Hy.

  case_eq (unsquash z); intros n3 fz Hz.

  destruct H.

  unfold age in H; rewrite knot_age1 in H.

  rewrite Hx in H.

  destruct n1; try discriminate.

  inv H.

  rewrite unsquash_squash in Hy.

  inv Hy.

  hnf in H0.

  rewrite unsquash_squash in H0.

  rewrite Hz in H0.

  destruct H0; subst n3.

  set (f := fun a =>

             match fx a with

             | Some x => Some x

             | None => fz a

             end).

  exists (squash (S n2, f)).

  split.

  hnf.

  case_eq (unsquash x); intros.

  rewrite unsquash_squash.

  rewrite Hx in H.

  inversion H; subst n f0.

  split; auto.

  intros.

  destruct (H0 a).

  left.

  simpl in H1.

  destruct (fx a); try discriminate; auto.

  simpl in *. unfold f.

  case_eq (fx a); intros; auto.

  right.

  generalize H2.

  rewrite (unsquash_approx Hx).

  simpl.

  rewrite H2; auto.

  unfold age; rewrite knot_age1.

  rewrite unsquash_squash.

  f_equal.

  apply unsquash_inj.

  rewrite unsquash_squash.

  rewrite Hz.

  f_equal.

  rewrite fmap_app.

  change (S n2) with (1+n2).

  rewrite <- (approx_approx1 1 n2).

  extensionality q. unfold f; simpl.

  destruct (H0 q). simpl in *.

  case_eq (fx q); intros; rewrite H1 in H; try discriminate.

  case_eq (fz q); intros; auto.

  generalize H2.

  rewrite (unsquash_approx Hz).

  simpl.

  rewrite H2; auto.

  simpl in *.

  case_eq (fx q); intros; rewrite H1 in H; try discriminate; auto.

  rewrite H; auto.

Qed.



Lemma knot_extends_age_commute2 : forall x y z,

  knot_extends x y /\ age y z -> exists y',

  age x y' /\ knot_extends y' z.

Proof.

  intros.

  case_eq (unsquash x); intros n1 fx Hx.

  case_eq (unsquash y); intros n2 fy Hy.

  case_eq (unsquash z); intros n3 fz Hz.

  destruct H.

  unfold age in H0; rewrite knot_age1 in H0.

  rewrite Hy in H0.

  destruct n2; try discriminate.

  inv H0.

  rewrite unsquash_squash in Hz.

  inversion Hz.

  subst n3 fz.

  hnf in H.

  rewrite Hx in H.

  rewrite Hy in H.

  destruct H; subst n1.

  clear Hz.

  exists (squash (n2,fx)).

  split.

  unfold age; rewrite knot_age1.

  rewrite Hx; auto.

  hnf; repeat rewrite unsquash_squash; split; auto.

  intros.

  destruct (H0 a).

  left.

  simpl. rewrite H; auto.

  right.

  simpl. rewrite H; auto.

Qed.



Lemma R_extends_valid_rel :

  valid_rel R_extends.

Proof.

  split; hnf; intros.

  destruct x; destruct y; destruct z; simpl in *.

  unfold age, age1 in H; simpl in H.

  hnf in H0.

  destruct H0; subst v1.

  case_eq (age1 m0); intros.

  rewrite H1 in H; inv H.

  destruct (knot_extends_age_commute2 m1 m0 m); auto.

  exists (x,v); hnf; intuition.

  unfold age1; simpl.

  hnf in H2.

  unfold mtype in *.

  rewrite H2; auto.

  rewrite H1 in H; discriminate.



  destruct x; destruct y; destruct z; simpl in *.

  unfold age in H0; simpl in H0.

  hnf in H.

  destruct H; subst v0.

  case_eq (age1 m1); intros; rewrite H1 in H0; try discriminate.

  inv H0.

  destruct (knot_extends_age_commute1 m1 m0 m); auto.

  exists (x,v); simpl.

  unfold age, age1; simpl.

  destruct H0.

  hnf in H2.

  unfold mtype in *.

  rewrite H2; auto.

  hnf; intuition.

Qed.



Lemma R_extends_refl : reflexive _ R_extends.

Proof.

  hnf; intros.

  hnf; destruct x; split; auto.

  apply knot_extends_refl.

Qed.



Lemma R_extends_trans : transitive _ R_extends.

Proof.

  hnf; intros.

  destruct x; destruct y; destruct z.

  destruct H; destruct H0.

  subst.

  split; auto.

  eapply knot_extends_trans; eauto.

Qed.



Definition knot_contracts := transp _ knot_extends.



Lemma knot_contracts_age_commute1 : forall x y z,

  age x y /\ knot_contracts y z -> exists y',

  knot_contracts x y' /\ age y' z.

Proof.

  unfold knot_contracts, transp; intros.

  case_eq (unsquash x); intros n1 fx Hx.

  case_eq (unsquash y); intros n2 fy Hy.

  case_eq (unsquash z); intros n3 fz Hz.

  destruct H.

  hnf in H0.

  rewrite Hz in H0.

  rewrite Hy in H0.

  destruct H0; subst.

  unfold age in H; rewrite knot_age1 in H.

  rewrite Hx in H.

  destruct n1; try discriminate.

  inv H.

  rewrite unsquash_squash in Hy; inv Hy.

  set (f := fun a =>

        match fz a with

        | Some _ => fx a

        | None => None

        end).

  exists (squash (S n2,f)).



  split.

  hnf.

  rewrite unsquash_squash.

  rewrite Hx.

  split; auto.

  intros. unfold f; simpl.

  destruct (H1 a).

  rewrite H; auto.

  right. simpl.

  rewrite <- H.

  simpl.

  case_eq (fx a); simpl; auto.

  intros.

  rewrite <- H0.

  rewrite (unsquash_approx Hx).

  simpl.

  rewrite H0. simpl. auto.



  unfold age; rewrite knot_age1.

  rewrite unsquash_squash.

  apply f_equal.

  apply unsquash_inj.

  rewrite unsquash_squash.

  rewrite Hz.

  apply f_equal.

  rewrite fmap_app.

  rewrite <- (approx_approx1 1).

  extensionality a; simpl.

  unfold f. simpl.

  destruct (H1 a).

  rewrite H; auto.

  rewrite <- H. simpl.

  case_eq (fx a); auto.

Qed.



Lemma knot_contracts_age_commute2 : forall x y z,

  knot_contracts x y /\ age y z -> exists y',

  age x y' /\ knot_contracts y' z.

Proof.

  unfold knot_contracts, transp; intros.

  case_eq (unsquash x); intros n1 fx Hx.

  case_eq (unsquash y); intros n2 fy Hy.

  case_eq (unsquash z); intros n3 fz Hz.

  destruct H.

  unfold age in H0; rewrite knot_age1 in H0.

  rewrite Hy in H0.

  destruct n2; try discriminate.

  inv H0.

  hnf in H.

  rewrite Hy in H.

  rewrite Hx in H.

  destruct H; subst n1.

  rewrite unsquash_squash in Hz; inv Hz.

  exists (squash (n3,fx)).

  split.

  unfold age; rewrite knot_age1.

  rewrite Hx; auto.

  hnf; repeat rewrite unsquash_squash.

  split; auto.

  intros. simpl.

  destruct (H0 a).

  rewrite H; auto.

  rewrite <- H.

  auto.

Qed.



Definition R_contracts := transp _ R_extends.



Lemma R_contracts_valid_rel :

  valid_rel R_contracts.

Proof.

  unfold R_contracts, transp; split; hnf; simpl; intros.

  destruct x; destruct y; destruct z; simpl in *.

  destruct H0; subst.

  unfold age, age1 in H; simpl in H.

  destruct (knot_contracts_age_commute2 m1 m0 m).

  split; auto.

  hnf; unfold mtype in *.

  destruct (age1 m0); congruence.

  destruct H1.

  exists (x,v); auto.

  split; auto.

  unfold age, age1; simpl.

  destruct (age1 m0).

  inv H.

  hnf in H1.

  unfold mtype in *.

  rewrite H1.

  auto.

  discriminate.



  destruct x; destruct y; destruct z; simpl in *.

  unfold age, age1 in H0; simpl in H0.

  destruct H; subst v0.

  destruct (knot_contracts_age_commute1 m1 m0 m).

  split; auto.

  unfold age.

  unfold mtype in *.

  destruct (age1 m1); congruence.

  destruct H1.

  exists (x,v).

  hnf; simpl.

  unfold mtype in *; rewrite H2.

  auto.

  split; auto.

  destruct (age1 m1); congruence.

Qed.



Definition extendM : modality :=

  exist _ R_extends R_extends_valid_rel.

Definition contractsM : modality :=

  exist _ R_contracts R_contracts_valid_rel.



Notation "'%' e"  := (box extendM e)(at level 30, right associativity): pred.



Lemma value_knot_laterR : forall k k' v v',

  laterR (A:=world) (k,v) (k',v') <-> clos_trans _ age k k' /\ v = v'.

Proof.

  split; intros.

  remember (k,v) as x.

  remember (k',v') as y.

  revert k k' v v' Heqx Heqy.

  induction H; intros; subst; auto.

  unfold age, age1 in H; simpl in H.

  case_eq (age1 k); intros.

  rewrite H0 in H; inv H.

  split; auto.

  apply t_step; auto.

  rewrite H0 in H; discriminate.

  destruct y.

  destruct (IHclos_trans1 k m v v0); auto.

  subst.

  destruct (IHclos_trans2 m k' v0 v'); auto.

  subst.

  split; auto.

  apply t_trans with m; auto.

  destruct H.

  subst v'.

  induction H.

  apply t_step.

  hnf; simpl.

  hnf in H.

  rewrite H; auto.

  eapply t_trans; eauto.

Qed.



Lemma value_knot_necR : forall k k' v v',

  necR (A:=world) (k,v) (k',v') <-> clos_refl_trans _ age k k' /\ v = v'.

Proof.

  split; intros.

  remember (k,v) as x.

  remember (k',v') as y.

  revert k k' v v' Heqx Heqy.

  induction H; intros; subst; auto.

  unfold age, age1 in H; simpl in H.

  case_eq (age1 k); intros.

  rewrite H0 in H; inv H.

  split; auto.

  apply rt_step; auto.

  rewrite H0 in H; discriminate.

  inv Heqy.

  split; auto.

  destruct y.

  destruct (IHclos_refl_trans1 k m v v0); auto.

  subst.

  destruct (IHclos_refl_trans2 m k' v0 v'); auto.

  subst.

  split; auto.

  apply rt_trans with m; auto.

  destruct H.

  subst v'.

  induction H.

  apply rt_step.

  unfold age, age1; simpl.

  hnf in H.

  rewrite H; auto.

  apply rt_refl.

  eapply rt_trans; eauto.

Qed.



Open Scope pred.



Definition approx_eq (n : nat) (tau1 tau2 : predicate) : Prop :=

  approx n tau1 = approx n tau2.



Lemma approx_eq_downward : forall n m p q,

  m <= n ->

  approx_eq n p q ->

  approx_eq m p q.

Proof.

  unfold approx_eq; intros.

  apply pred_ext'.

  extensionality ko.

  assert (approx n p ko <-> approx n q ko).

  rewrite H0. split; auto.

  unfold app_pred in *.

  repeat rewrite approx_spec in *.

  apply prop_ext.

  intuition. spec H1. omega. spec H1; auto.

  destruct H1; auto.

  spec H2. omega. spec H2. auto.

  destruct H2; auto.

Qed.



Lemma approx_eq_sub n P Q :

    ((|> (P <=> Q)) n -> approx_eq n P Q).

Proof.

  intros. hnf.

  apply pred_ext'.

  extensionality ko.

  unfold app_pred in *.

  apply prop_ext. split; intros.

  rewrite approx_spec in H0.

  rewrite approx_spec.

  destruct H0. split; auto.

  spec H (level ko). spec H.

  simpl. rewrite later_nat. auto.

  spec H ko. spec H. auto.

  destruct H.

  eapply H; eauto.

  unfold app_pred in *.

  rewrite approx_spec in H0.

  rewrite approx_spec.

  destruct H0. split; auto.

  spec H (level ko). spec H.

  simpl. rewrite later_nat. auto.

  spec H ko. spec H. auto.

  destruct H.

  eapply H2; eauto.

Qed.



Hint Resolve R_extends_refl R_extends_trans.

