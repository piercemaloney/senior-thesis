Require Import aes.api_specs.
(* aes.api_specs:
Definition t_struct_aesctx := Tstruct _mbedtls_aes_context_struct noattr.
Definition t_struct_tables := Tstruct _aes_tables_struct noattr.

Definition tables_initialized (tables : val) := data_at Ews t_struct_tables
  (map Vint FSb, (map Vint FT0, (map Vint FT1, (map Vint FT2, (map Vint FT3,
  (map Vint RSb, (map Vint RT0, (map Vint RT1, (map Vint RT2, (map Vint RT3,
  (map Vint RCON))))))))))) tables.

Definition Vundef256 : list val := repeat Vundef 256%nat.

Definition tables_uninitialized tables := data_at Ews t_struct_tables (Vundef256, 
  (Vundef256, (Vundef256, (Vundef256, (Vundef256, (Vundef256,
  (Vundef256, (Vundef256, (Vundef256, (Vundef256, 
  (repeat Vundef 10))))))))))) tables.

Definition gen_tables_spec :=
  DECLARE _aes_gen_tables
    WITH gv: globals
    PRE [  ]
      PROP ()
      LOCAL (gvars gv)
      SEP (tables_uninitialized (gv _tables))
    POST [ tvoid ]
      PROP ()
      LOCAL ()
      SEP (tables_initialized (gv _tables))
.

Definition word_to_int (w : (int * int * int * int)) : int :=
  match w with (b0, b1, b2, b3) =>
    (Int.or (Int.or (Int.or
             b0
    (Int.shl b1 (Int.repr  8)))
    (Int.shl b2 (Int.repr 16)))
    (Int.shl b3 (Int.repr 24)))
  end.

Definition SubWord (w: int) : int := word_to_int (
  (Znth (byte0 w) FSb),
  (Znth (byte1 w) FSb),
  (Znth (byte2 w) FSb),
  (Znth (byte3 w) FSb)
).

Definition RotWord(i: int): int := 
  Int.or (Int.and (Int.shl i (Int.repr 8)) (Int.repr (-1))) (Int.shru i (Int.repr 24)).

Definition RCon : list int := map (fun i => Int.shl i (Int.repr 24)) [
   (Int.repr 1);
   (Int.repr 2);
   (Int.repr 4);
   (Int.repr 8);
   (Int.repr 16);
   (Int.repr 32);
   (Int.repr 64)
].

Definition GrowKeyByOne(w: list int): list int :=
  let i := Zlength w in
  let temp := (Znth (i-1) w) in
  let temp' := if (i mod Nk =? 0) then
    Int.xor (SubWord (RotWord temp)) (Znth (i/Nk) RCon)
  else if (i mod Nk =? 4) then
    SubWord temp
  else
    temp
  in
    w ++ [Int.xor (Znth (i-8) w) temp'].

Fixpoint pow_fun{T: Type}(f: T -> T)(n: nat)(a: T): T := match n with
| O => a
| S m => f (pow_fun f m a)
end.

Definition KeyExpansion2: list int -> list int := pow_fun GrowKeyByOne (Z.to_nat (Nb*(Nr+2)-Nk)).

Definition get_uint32_le (arr: list Z) (i: Z) : int :=
 (Int.or (Int.or (Int.or
            (Int.repr (Znth  i    arr))
   (Int.shl (Int.repr (Znth (i+1) arr)) (Int.repr  8)))
   (Int.shl (Int.repr (Znth (i+2) arr)) (Int.repr 16)))
   (Int.shl (Int.repr (Znth (i+3) arr)) (Int.repr 24))).

Definition key_bytes_to_key_words(key_bytes: list Z): list int := 
  fill_list 8 (fun i => get_uint32_le key_bytes (i*4)).

Definition key_expansion_spec :=
  DECLARE _mbedtls_aes_setkey_enc
    WITH ctx : val, key : val, ctx_sh : share, key_sh : share, key_chars : list Z,
         init_done : Z, ish: share, gv: globals
    PRE [ _ctx OF (tptr t_struct_aesctx), _key OF (tptr tuchar), _keybits OF tuint  ]
      PROP (writable_share ctx_sh; readable_share key_sh; readable_share ish;
            Zlength key_chars = 32;
            init_done = 1 )
      LOCAL (temp _ctx ctx; temp _key key; temp _keybits (Vint (Int.repr 256)); 
             gvars gv)
      SEP (data_at ctx_sh t_struct_aesctx 
                   (Vint Int.zero,
                   (nullval, 
                   (map Vint (repeat_op_table 68 Int.zero id)))) ctx;
           data_at key_sh (tarray tuchar (4*8)) (map Vint (map Int.repr key_chars)) key;
           
           data_at ish tint (Vint (Int.repr init_done)) (gv _aes_init_done);
           tables_initialized (gv _tables))
    POST [  tint ]
      PROP () 
      LOCAL (temp ret_temp (Vint Int.zero))
      SEP (data_at key_sh (tarray tuchar (4*8)) (map Vint (map Int.repr key_chars)) key;
           data_at ctx_sh t_struct_aesctx 
                   (Vint (Int.repr 14),
                   ((field_address t_struct_aesctx [StructField _buf] ctx), 
                   (map Vint (KeyExpansion2 (key_bytes_to_key_words key_chars))
                    ++ (repeat_op_table 4 (Vint Int.zero) id)))) ctx;
           data_at ish tint (Vint (Int.repr init_done)) (gv _aes_init_done);
           tables_initialized (gv _tables)).

Definition encryption_spec_ll :=
  DECLARE _mbedtls_aes_encrypt
  WITH ctx : val, input : val, output : val, 
       ctx_sh : share, in_sh : share, out_sh : share, 
       plaintext : list Z, 
       exp_key : list Z, 
       gv: globals 
  PRE [ _ctx OF (tptr t_struct_aesctx), _input OF (tptr tuchar), _output OF (tptr tuchar) ]
    PROP (Zlength plaintext = 16; Zlength exp_key = 60;
          readable_share ctx_sh; readable_share in_sh; writable_share out_sh)
    LOCAL (temp _ctx ctx; temp _input input; temp _output output; gvars gv)
    SEP (data_at ctx_sh (t_struct_aesctx) (
          (Vint (Int.repr Nr)),
          ((field_address t_struct_aesctx [StructField _buf] ctx),
          (map Vint (map Int.repr (exp_key ++ (list_repeat (8%nat) 0)))))
          
         ) ctx;
         data_at in_sh (tarray tuchar 16) (map Vint (map Int.repr plaintext)) input;
         data_at_ out_sh (tarray tuchar 16) output;
         tables_initialized (gv _tables))
  POST [ tvoid ]
    PROP() LOCAL()
    SEP (data_at ctx_sh (t_struct_aesctx) (
          (Vint (Int.repr Nr)),
          ((field_address t_struct_aesctx [StructField _buf] ctx),
          (map Vint (map Int.repr (exp_key ++ (list_repeat (8%nat) 0)))))
         ) ctx;
         data_at in_sh  (tarray tuchar 16)
                 (map Vint (map Int.repr plaintext)) input;
         data_at out_sh (tarray tuchar 16)
                 (map Vint (mbed_tls_aes_enc plaintext (exp_key ++ (list_repeat (8%nat) 0)))) output;
         tables_initialized (gv _tables)).

Definition Gprog : funspecs := ltac:(with_library prog [
  gen_tables_spec; key_expansion_spec; encryption_spec_ll
]).

Global Opaque field_address.

Arguments col _ _ : simpl never.

Arguments Z.land _ _ : simpl never.

Arguments Nat.sub _ _ : simpl never. *)

Require Import aes.spec_encryption_LL.
(* aes.spec_encryption_LL:
Require Export aes.spec_utils_LL.
Require Export aes.tablesLL.
Local Open Scope Z.

Definition mbed_tls_fround_col (col0 col1 col2 col3 : int) (rk : Z) : int :=
  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)
    (Znth (byte0 col0) FT0))
    (Znth (byte1 col1) FT1))
    (Znth (byte2 col2) FT2))
    (Znth (byte3 col3) FT3)).

Definition mbed_tls_final_fround_col (col0 col1 col2 col3 : int) (rk : Z) : int :=
  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)
             (Znth (byte0 col0) FSb)              )
    (Int.shl (Znth (byte1 col1) FSb) (Int.repr 8)))
    (Int.shl (Znth (byte2 col2) FSb) (Int.repr 16)))
    (Int.shl (Znth (byte3 col3) FSb) (Int.repr 24))).

Definition four_ints := (int * (int * (int * int)))%type.

Definition col (i : Z) (s : four_ints) : int := match i with
| 0 => fst s
| 1 => fst (snd s)
| 2 => fst (snd (snd s))
| 3 => snd (snd (snd s))
| _ => Int.zero 
end.

Lemma split_four_ints: forall (S: four_ints),
  S = (col 0 S, (col 1 S, (col 2 S, col 3 S))).

Lemma split_four_ints_eq: forall S c0 c1 c2 c3,
  S = (c0, (c1, (c2, c3))) -> c0 = col 0 S /\ c1 = col 1 S /\ c2 = col 2 S /\ c3 = col 3 S.

Definition mbed_tls_initial_add_round_key_col (col_id : Z) (plaintext : list Z) (rks : list Z) :=
  Int.xor (get_uint32_le plaintext (col_id * 4)) (Int.repr (Znth col_id rks)).

Definition mbed_tls_fround (cols : four_ints) (rks : list Z) (i : Z) : four_ints :=
match cols with (col0, (col1, (col2, col3))) =>
  ((mbed_tls_fround_col col0 col1 col2 col3 (Znth  i    rks)),
  ((mbed_tls_fround_col col1 col2 col3 col0 (Znth (i+1) rks)),
  ((mbed_tls_fround_col col2 col3 col0 col1 (Znth (i+2) rks)),
   (mbed_tls_fround_col col3 col0 col1 col2 (Znth (i+3) rks)))))
end.

Definition mbed_tls_final_fround (cols : four_ints) (rks : list Z) (i : Z) : four_ints :=
match cols with (col0, (col1, (col2, col3))) =>
  ((mbed_tls_final_fround_col col0 col1 col2 col3 (Znth  i    rks)),
  ((mbed_tls_final_fround_col col1 col2 col3 col0 (Znth (i+1) rks)),
  ((mbed_tls_final_fround_col col2 col3 col0 col1 (Znth (i+2) rks)),
   (mbed_tls_final_fround_col col3 col0 col1 col2 (Znth (i+3) rks)))))
end.

Fixpoint mbed_tls_enc_rounds (n : nat) (state : four_ints) (rks : list Z) (i : Z) : four_ints :=
match n with
| O => state
| S m => mbed_tls_fround (mbed_tls_enc_rounds m state rks i) rks (i+4*Z.of_nat m)
end.

Definition mbed_tls_initial_add_round_key (plaintext : list Z) (rks : list Z) : four_ints :=
((mbed_tls_initial_add_round_key_col 0 plaintext rks),
((mbed_tls_initial_add_round_key_col 1 plaintext rks),
((mbed_tls_initial_add_round_key_col 2 plaintext rks),
((mbed_tls_initial_add_round_key_col 3 plaintext rks))))).

Definition output_four_ints_as_bytes (s : four_ints) :=
  (put_uint32_le (col 0 s)) ++
  (put_uint32_le (col 1 s)) ++
  (put_uint32_le (col 2 s)) ++
  (put_uint32_le (col 3 s)).

Definition mbed_tls_aes_enc (plaintext : list Z) (rks : list Z) : list int :=
  let state0  := mbed_tls_initial_add_round_key plaintext rks in
  let state13 := mbed_tls_enc_rounds 13 state0 rks 4 in
  let state14 := mbed_tls_final_fround state13 rks 56 in
  output_four_ints_as_bytes state14. *)

Require Import aes.bitfiddling.
(* aes.bitfiddling:
Require Export aes.conv_HL_to_LL.
Local Open Scope Z.

Lemma byte0_word_to_int: forall b0 b1 b2 b3,
  byte0 (word_to_int (b0, b1, b2, b3)) = Int.unsigned b0.

Lemma byte1_word_to_int: forall b0 b1 b2 b3,
  byte1 (word_to_int (b0, b1, b2, b3)) = Int.unsigned b1.

Lemma byte2_word_to_int: forall b0 b1 b2 b3,
  byte2 (word_to_int (b0, b1, b2, b3)) = Int.unsigned b2.

Lemma byte3_word_to_int: forall b0 b1 b2 b3,
  byte3 (word_to_int (b0, b1, b2, b3)) = Int.unsigned b3.

Lemma xor_byte0_with_FSb: forall b0 b1 b2 b3 i,
  Int.xor (word_to_int (b0, b1, b2, b3)) (Znth i tablesLL.FSb)

Lemma xor_byte1_with_FSb: forall b0 b1 b2 b3 i,
  Int.xor (word_to_int (b0, b1, b2, b3)) (Int.shl (Znth i tablesLL.FSb) (Int.repr 8))

Lemma xor_byte2_with_FSb: forall b0 b1 b2 b3 i,
  Int.xor (word_to_int (b0, b1, b2, b3)) (Int.shl (Znth i tablesLL.FSb) (Int.repr 16))

Lemma xor_byte3_with_FSb: forall b0 b1 b2 b3 i,
  Int.xor (word_to_int (b0, b1, b2, b3)) (Int.shl (Znth i tablesLL.FSb) (Int.repr 24))

Lemma equiv_sbox: forall b,
  Znth (Int.unsigned b) tablesLL.FSb = look_sbox b.

Lemma xor_word_to_int: forall a0 a1 a2 a3 b0 b1 b2 b3,
  Int.xor (word_to_int (a0, a1, a2, a3)) (word_to_int (b0, b1, b2, b3))

Lemma rot8_word_to_int: forall b0 b1 b2 b3,
  rot8 (word_to_int (b0, b1, b2, b3)) = word_to_int (b3, b0, b1, b2).

Lemma mask_byte_nop: forall i,
  0 <= Int.unsigned i < 256 ->

Lemma FSb_range: forall i,
  0 <= Int.unsigned (Znth i FSb) < 256.

Lemma zero_ext_nop: forall i,
  0 <= (Int.unsigned i) < 256 ->

Lemma FSb_inj: forall i j,
  0 <= i < 256 ->
  0 <= j < 256 ->
  Znth i FSb = Znth j FSb ->
  i = j.

Lemma FSb_RSb_id: forall j,
  0 <= j < 256 ->
  j = Int.unsigned (Znth (Int.unsigned (Znth j RSb)) FSb).

Lemma RSb_inj: forall i j,
  0 <= i < 256 ->
  0 <= j < 256 ->
  Znth i RSb = Znth j RSb ->
  i = j.

Lemma RSb_range: forall i,
  0 <= Int.unsigned (Znth i RSb) < 256.

Lemma xor_is_or_4_bytes: forall b0 b1 b2 b3,
  (Int.xor (Int.xor (Int.xor b0

Lemma masked_byte_range: forall i,
  0 <= Z.land i 255 < 256.

Lemma zero_ext_mask: forall i,
  Int.zero_ext 8 i = Int.and i (Int.repr 255). *)

Local Open Scope Z.



Definition encryption_loop_body : statement :=

   ltac:(find_statement_in_body

       f_mbedtls_aes_encrypt

       reassociate_stmt

       ltac:(fun body => match body with

              context [  Sloop

                       (Ssequence

                         (Sifthenelse (Ebinop Ogt (Etempvar _i _) (Econst_int (Int.repr 0) _)  _)

                             Sskip  Sbreak)

                       ?S) _ ] => S

      end)).



Definition encryption_loop_body_proof_statement :=

 forall

  (Espec : OracleKind)

  (ctx input output : val)

  (ctx_sh in_sh out_sh : share)

  (plaintext exp_key : list Z)

  (gv : globals)

  (H : Zlength plaintext = 16)

  (H0 : Zlength exp_key = 60)

  (SH : readable_share ctx_sh)

  (SH0 : readable_share in_sh)

  (SH1 : writable_share out_sh)

  (buf : list Z)

  (Heqbuf : buf = exp_key ++ list_repeat 8 0)

  (Fctx : field_compatible t_struct_aesctx [StructField _buf] ctx)

  (LenBuf : Zlength buf = 68)

  (Eq : forall i : Z,

     0 <= i < 60 ->

     force_val

       (sem_add_ptr_int tuint Signed

          (field_address t_struct_aesctx [ArraySubsc i; StructField _buf] ctx)

          (Vint (Int.repr 1))) =

     field_address t_struct_aesctx [ArraySubsc (i + 1); StructField _buf] ctx)

  (S12 S0 : four_ints)

  (HeqS0 : S0 = mbed_tls_initial_add_round_key plaintext buf)

  (HeqS12 : S12 = mbed_tls_enc_rounds 12 S0 buf 4)

  (i : Z)

  (H1 : 0 < i <= 6),

semax (func_tycontext f_mbedtls_aes_encrypt Vprog Gprog nil)

  (PROP ( )

   LOCAL (temp _i (Vint (Int.repr i));

   temp _RK

     (field_address t_struct_aesctx

        [ArraySubsc (52 - i * 8); StructField _buf] ctx);

   temp _X3

     (Vint (col 3 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)));

   temp _X2

     (Vint (col 2 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)));

   temp _X1

     (Vint (col 1 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)));

   temp _X0

     (Vint (col 0 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)));

   temp _output output;

   gvars gv)

   SEP (data_at_ out_sh (tarray tuchar 16) output;

   data_at Ews t_struct_tables

     (map Vint FSb,

     (map Vint FT0,

     (map Vint FT1,

     (map Vint FT2,

     (map Vint FT3,

     (map Vint RSb,

     (map Vint RT0,

     (map Vint RT1, (map Vint RT2, (map Vint RT3, map Vint RCON))))))))))

     (gv _tables);

   data_at in_sh (tarray tuchar 16) (map Vint (map Int.repr plaintext)) input;

   data_at ctx_sh t_struct_aesctx

     (Vint (Int.repr Nr),

     (field_address t_struct_aesctx [ArraySubsc 0; StructField _buf] ctx,

     map Vint (map Int.repr buf))) ctx))

  encryption_loop_body

  (normal_ret_assert

     (EX a : Z,

      PROP (0 < a <= 6)

      LOCAL (temp _i (Vint (Int.repr a));

      temp _RK

        (field_address t_struct_aesctx

           [ArraySubsc (52 - (a - 1) * 8); StructField _buf] ctx);

      temp _X3

        (Vint

           (col 3 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (a - 1)) S0 buf 4)));

      temp _X2

        (Vint

           (col 2 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (a - 1)) S0 buf 4)));

      temp _X1

        (Vint

           (col 1 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (a - 1)) S0 buf 4)));

      temp _X0

        (Vint

           (col 0 (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (a - 1)) S0 buf 4)));

      temp _output output; gvars gv)

      SEP (data_at_ out_sh (tarray tuchar 16) output;

      data_at Ews t_struct_tables

        (map Vint FSb,

        (map Vint FT0,

        (map Vint FT1,

        (map Vint FT2,

        (map Vint FT3,

        (map Vint RSb,

        (map Vint RT0,

        (map Vint RT1, (map Vint RT2, (map Vint RT3, map Vint RCON))))))))))

        (gv _tables);

      data_at in_sh (tarray tuchar 16) (map Vint (map Int.repr plaintext))

        input;

      data_at ctx_sh t_struct_aesctx

        (Vint (Int.repr Nr),

        (field_address t_struct_aesctx [ArraySubsc 0; StructField _buf] ctx,

        map Vint (map Int.repr buf))) ctx))%assert).



Hint Resolve 0%Z : inhabited.



Lemma encryption_loop_body_proof: encryption_loop_body_proof_statement.

Proof.

  unfold encryption_loop_body_proof_statement. intros.

  unfold encryption_loop_body.

  abbreviate_semax.

  pose proof masked_byte_range.

  assert (H2': forall i, 0 <= Int.unsigned (Int.and i (Int.repr 255)) < 256). {

    clear.  intros. rewrite Int.and_commut.

    pose proof (Int.and_le (Int.repr 255) i).

    rewrite Int.unsigned_repr in H by computable. 

    pose proof (Int.unsigned_range (Int.and (Int.repr 255) i)). omega.

  }



  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.



  replace (52 - i * 8 + 1 + 1 + 1 + 1) with (52 - i * 8 + 4) by omega.

  replace (52 - i * 8 + 1 + 1 + 1)     with (52 - i * 8 + 3) by omega.

  replace (52 - i * 8 + 1 + 1)         with (52 - i * 8 + 2) by omega.



  pose (S' := mbed_tls_fround (mbed_tls_enc_rounds (12-2*Z.to_nat i) S0 buf 4) buf (52-i*8)).



  match goal with |- context [temp _Y0 (Vint ?E0)] =>

    match goal with |- context [temp _Y1 (Vint ?E1)] =>

      match goal with |- context [temp _Y2 (Vint ?E2)] =>

        match goal with |- context [temp _Y3 (Vint ?E3)] =>

          assert (S' = (E0, (E1, (E2, E3)))) as Eq2

        end

      end

    end

  end.

  {

    subst S'.

    rewrite (split_four_ints (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)).

    simpl. unfold mbed_tls_fround_col, byte0, byte1, byte2, byte3, Int.and. simpl.

    rewrite !Int.unsigned_repr by computable.

    rewrite !Int.unsigned_repr by

     match goal with |- context [Z.land ?A] => clear - H2; specialize (H2 A); rep_omega end.

    reflexivity.

  }

  apply split_four_ints_eq in Eq2. destruct Eq2 as [EqY0 [EqY1 [EqY2 EqY3]]].

  rewrite EqY0. rewrite EqY1. rewrite EqY2. rewrite EqY3.

  clear EqY0 EqY1 EqY2 EqY3.



  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward. deadvars!.

  do 2 forward. simpl (temp _RK _). rewrite Eq by omega. do 6 forward.



  pose (S'' := mbed_tls_fround S' buf (52-i*8+4)).



  replace (52 - i * 8 + 4 + 1 + 1 + 1 + 1) with (52 - i * 8 + 4 + 4) by omega.

  replace (52 - i * 8 + 4 + 1 + 1 + 1)     with (52 - i * 8 + 4 + 3) by omega.

  replace (52 - i * 8 + 4 + 1 + 1)         with (52 - i * 8 + 4 + 2) by omega.



  match goal with |- context [temp _X0 (Vint ?E0)] =>

    match goal with |- context [temp _X1 (Vint ?E1)] =>

      match goal with |- context [temp _X2 (Vint ?E2)] =>

        match goal with |- context [temp _X3 (Vint ?E3)] =>

          assert (S'' = (E0, (E1, (E2, E3)))) as Eq2

        end

      end

    end

  end.

  {

    subst S''.

    rewrite (split_four_ints S').

    simpl. unfold mbed_tls_fround_col, byte0, byte1, byte2, byte3, Int.and. simpl.

    rewrite !Int.unsigned_repr by computable.

    rewrite !Int.unsigned_repr by

     match goal with |- context [Z.land ?A] => clear - H2; specialize (H2 A); rep_omega end.

    reflexivity.

  }

  apply split_four_ints_eq in Eq2. destruct Eq2 as [EqX0 [EqX1 [EqX2 EqX3]]].

  rewrite EqX0. rewrite EqX1. rewrite EqX2. rewrite EqX3.

  clear EqX0 EqX1 EqX2 EqX3.



  Exists i.

  replace (52 - i * 8 + 4 + 4) with (52 - (i - 1) * 8) by omega.

  subst S' S''.

  assert (

    (mbed_tls_fround

      (mbed_tls_fround

         (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4)

         buf

         (52 - i * 8))

      buf

      (52 - i * 8 + 4))

  = (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (i - 1)) S0 buf 4)) as Eq2. {

    replace (12 - 2 * Z.to_nat (i - 1))%nat with (S (S (12 - 2 * Z.to_nat i))).

    - unfold mbed_tls_enc_rounds . fold mbed_tls_enc_rounds.

      f_equal.

      * f_equal.

        rewrite Nat2Z.inj_sub. {

          change (Z.of_nat 12) with 12.

          rewrite Nat2Z.inj_mul.

          change (Z.of_nat 2) with 2.

          rewrite Z2Nat.id; omega.

        }

        assert (Z.to_nat i <= 6)%nat. {

          change 6%nat with (Z.to_nat 6).

          apply Z2Nat.inj_le; omega.

        }

        omega.

      * rewrite Nat2Z.inj_succ.

        change 2%nat with (Z.to_nat 2) at 2.

        rewrite <- Z2Nat.inj_mul; [ | omega | omega ].

        change 12%nat with (Z.to_nat 12).

        rewrite <- Z2Nat.inj_sub; [ | omega ].

        rewrite Z2Nat.id; omega.

    - rewrite Z2Nat.inj_sub; [ | omega ].

      change (Z.to_nat 1) with 1%nat.

      assert (Z.to_nat i <= 6)%nat. {

        change 6%nat with (Z.to_nat 6).

        apply Z2Nat.inj_le; omega.

      }

      assert (0 < Z.to_nat i)%nat. {

        change 0%nat with (Z.to_nat 0).

        apply Z2Nat.inj_lt; omega.

      }

      omega.

  }

  rewrite Eq2. clear Eq2.

  remember (mbed_tls_enc_rounds (12 - 2 * Z.to_nat (i - 1)) S0 buf 4) as S''.

  remember (mbed_tls_fround (mbed_tls_enc_rounds (12 - 2 * Z.to_nat i) S0 buf 4) buf (52 - i * 8)) as S'.

  replace (52 - i * 8 + 4 + 4) with (52 - (i - 1) * 8) by omega.

  entailer!.

Time Qed. 



