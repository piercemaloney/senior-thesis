
Set Implicit Arguments.

Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Require Import hmacfcf.HMAC_spec.
(* hmacfcf.HMAC_spec:
Set Implicit Arguments.

Require Import Bvector.
Require Import List.
Require Import Arith.

Definition Blist := list bool.

Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
    | 0 =>
      fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
    | S n' =>
      fun (v : Vector.t A (S n' + m)) =>
        let (v1, v2) := splitVector _ _ (Vector.tl v) in
          (Vector.cons _ (Vector.hd v) _ v1, v2)
  end.

Section HMAC.

  Variable c p : nat.
  Definition b := c + p.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  
  Variable iv : Bvector c.
  
  Definition h_star k (m : list (Bvector b)) :=
    fold_left h m k.
  
  Definition hash_words := h_star iv.

  Variable Message : Set.
  Variable splitAndPad : Message -> list (Bvector b).
  Hypothesis splitAndPad_1_1 :
    forall b1 b2,
      splitAndPad b1 = splitAndPad b2 ->
      b1 = b2.

  Variable fpad : Bvector c -> Bvector p.
  Definition app_fpad (x : Bvector c) : Bvector b :=
    (Vector.append x (fpad x)).

  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GNMAC k m :=
    let (k_Out, k_In) := splitVector c c k in
    h k_Out (app_fpad (h_star k_In m)).

  Definition GHMAC_2K (k : Bvector (b + b)) m :=
    let (k_Out, k_In) := splitVector b b k in
      let h_in := (hash_words (k_In :: m)) in
        hash_words (k_Out :: (app_fpad h_in) :: nil).

  Definition HMAC_2K (k : Bvector (b + b)) (m : Message) :=
    GHMAC_2K k (splitAndPad m).

  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC (k : Bvector b) :=
    GHMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

  Definition HMAC (k : Bvector b) :=
    HMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

End HMAC. *)
Require Import FCF.PRF.
(* FCF.PRF:
Set Implicit Arguments.
Require Import FCF.FCF.
Require Import FCF.CompFold. 
Require Export FCF.Array.
Require Export FCF.Hybrid.

Local Open Scope list_scope.
Local Open Scope array_scope.

Definition oracleMap(D R S: Set)(eqds : EqDec S)(eqdr : EqDec R)(oracle : S  -> D -> Comp (R * S))(s : S)(ds : list D) :=
  compFold _ 
  (fun acc d => [rs, s] <-2 acc; [r, s] <-$2 oracle s d; ret (rs ++ r :: nil, s)) 
  (nil, s) ds.

Theorem oracleMap_wf : 
  forall (D R S : Set)(eqds : EqDec S)(eqdr : EqDec R) (oracle : S -> D -> Comp (R * S))ds s,
  (forall s x, well_formed_comp (oracle s x)) ->
  well_formed_comp (@oracleMap D R S _ _ oracle s ds).

  Hypothesis RndR_wf : well_formed_comp RndR.
  
  Definition randomFunc (f : (list (D * R))) (d : D) : Comp (R * list (D * R)) :=
      match (arrayLookup _ f d) with
        | None => (r <-$ RndR; ret (r, (d, r) :: f))
        | Some r => ret (r, f)
      end.  
  
  Lemma randomFunc_wf : forall f d, 
    well_formed_comp (randomFunc f d).
  
  Hint Resolve randomFunc_wf : wftac.

  Definition RndFunc(lsd : list D) : Comp (list (D * R)) :=
    compFold _ (fun f d => r <-$ RndR; ret (d, r)::f) nil lsd. 
  
End RandomFunc.

Local Open Scope type_scope.
Local Open Scope comp_scope.

Section PRF_concrete.
  
  Variable D R Key : Set.
  Variable RndKey : Comp Key.
  Variable RndR : Comp R.
  Variable f : Key -> D -> R.

  Hypothesis D_EqDec : EqDec D.
  Hypothesis R_EqDec : EqDec R.

  Definition RndR_func : (list (D * R) -> D -> Comp (R * list (D * R))) :=
    (randomFunc RndR _).

  Section PRF_NA_concrete.
  
    Variable State : Set.
    Variable A1 : Comp (list D * State).
    Variable A2 : State -> list R -> Comp bool.

    Definition PRF_NA_G_A : Comp bool := 
      [lsD, s_A] <-$2 A1; 
      lsR <-$ (k <-$ RndKey; ret (map (f k) lsD));
      A2 s_A lsR.
    
    Definition PRF_NA_G_B : Comp bool := 
      [lsD, s_A] <-$2 A1;
      [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD;
      A2 s_A lsR.
    
    Definition PRF_NA_Advantage := 
    | Pr[PRF_NA_G_A] - Pr[PRF_NA_G_B] |.  

  End PRF_NA_concrete.

  Section PRF_NAI_concrete.

    Variable A_state : Set.
    Variable A1 : Comp ((list (list D)) * A_state).
    Variable A2 : A_state -> list (list R) -> Comp bool.

    Definition PRF_NAI_G0 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => k <-$ RndKey; ret (map (f k) lsD)) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_G1 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_Advantage := 
    | Pr[PRF_NAI_G0] - Pr[PRF_NAI_G1] |.   
                         
  Section PRF_NA_impl_NAI.

    Variable maxLists : nat.
    Hypothesis maxLists_correct : 
      forall ls s_A, 
        In (ls, s_A) (getSupport A1) ->
        (length ls <= maxLists)%nat.

    Hypothesis A_state_EqDec : EqDec A_state.
    Hypothesis RndR_wf : well_formed_comp RndR.
    Hypothesis RndKey_wf : well_formed_comp RndKey.

    Variable maxDistance : Rat.
    Hypothesis maxDistance_correct : 
      forall i, 
      PRF_NA_Advantage (B1 nil _ _ A1 i) (B2 (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
              (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
              _ A2) <= maxDistance.

    Theorem PRF_NAI_Advantage_eq_Hybrid:
      PRF_NAI_Advantage == ListHybrid_Advantage 
                             (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
                             (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
                             _ A1 A2.

    Theorem PRF_NA_impl_NAI : 
      PRF_NAI_Advantage <= (maxLists / 1 * maxDistance)%rat.

  End PRF_NA_impl_NAI.

  End PRF_NAI_concrete.

  Section PRF_Full_concrete.
    
    Variable A : OracleComp D R bool.
    
    Definition f_oracle(k : Key)(x : unit)(d : D) :=
      ret (f k d, tt).
    
    Definition PRF_G_A : Comp bool := 
      k <-$ RndKey;
      [b, _] <-$2 A _ _ (f_oracle k) tt;
      ret b.
    
    Definition PRF_G_B : Comp bool := 
      [b, _] <-$2 A _ _ (RndR_func) nil;
      ret b.
    
    Definition PRF_Advantage := 
    | Pr[PRF_G_A] - Pr[PRF_G_B] |.  
    
  End PRF_Full_concrete.

  Section PRF_Finite_concrete.

    Variable dom : list D.
    Variable def : R.
    Variable A : (D -> R) -> Comp bool.

    Definition PRF_Fin_G_A : Comp bool := 
      k <-$ RndKey;
      A (f k).
    
    Definition PRF_Fin_G_B : Comp bool := 
      f <-$ @RndFunc D R RndR _ dom;
      A (fun d => arrayLookupDef _ f d def).

    Definition PRF_Fin_Advantage := 
    | Pr[PRF_Fin_G_A] - Pr[PRF_Fin_G_B] |.

  End PRF_Finite_concrete.
  
End PRF_concrete.

Require Import FCF.Asymptotic.
Require Import FCF.Admissibility.

Section PRF.

  Variable D R Key : DataTypeFamily.
  Variable RndKey : forall n, Comp (Key n).
  Variable RndR : forall n, Comp (R n).
  Variable f : forall n, Key n -> D n -> R n.

  Hypothesis D_EqDec : forall n, EqDec (D n).
  Hypothesis R_EqDec : forall n, EqDec (R n).

  Section PRF_NA.
    Variable admissible_A1 : pred_comp_fam.
    Variable admissible_A2 : pred_comp_func_2_fam.
    
    Definition PRF_NA :=
      forall (State : DataTypeFamily) A1 A2,
        admissible_A1 _ A1 -> 
        admissible_A2 State _ _ A2 ->
        negligible (fun n => PRF_NA_Advantage (RndKey n) (RndR n) (@f n) _ _ (A1 n) (@A2 n)).
  End PRF_NA.

  Section PRF_Full.
    Variable admissible_A : pred_oc_fam.
    
    Definition PRF :=
      forall (A : forall n, OracleComp (D n) (R n) bool),
        admissible_A _ _ _ A -> 
        negligible (fun n => PRF_Advantage (RndKey n) (RndR n) (@f n) _ _ (A n)).
  End PRF_Full.
      
End PRF. *)
Require Import hmacfcf.hF.
(* hmacfcf.hF:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import FCF.PRF.
Require Import hmacfcf.splitVector.
Require Import hmacfcf.cAU.
Require Import FCF.CompFold.
Require Import FCF.DetSem FCF.SemEquiv.

Local Open Scope list_scope.

Section hF.

  Variable b k c : nat.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  Variable F : Bvector k -> list (Bvector b) -> Bvector b.

  Definition hF key m :=
    [k_Out, k_In] <-2 splitVector c k key;
    h k_Out (F k_In m).

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.
  Hypothesis A_wf : well_formed_oc A.

  Definition G0 :=
    k_in <-$ {0, 1}^k;
    k_out <-$ {0, 1}^c;
    [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt;
    ret b.

  Definition G1 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _
    (fun (s : list (Bvector b * Bvector c)) m =>
      randomFunc ({0, 1}^c) _ s (F k_in m)) nil;
    ret b.

  Definition G2 :=
    [b, _] <-$2 A _ _
    (fun (s : list (list (Bvector b) * Bvector c)) m =>
      randomFunc ({0, 1}^c) _ s m) nil;
    ret b.

  Definition G0_1 :=
    [k_out, k_in] <-$2 (
    key <-$ {0, 1}^(c + k);
    ret splitVector c k key);
    [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt;
    ret b.

  Theorem G0_1_equiv :
    Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1].

  Theorem G0_1_G0_equiv :
    Pr[G0_1] == Pr[G0].

  Theorem G0_equiv :
    Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0].

  Definition hF_oracle k_in (s : unit) m : OracleComp (Bvector b) (Bvector c) (Bvector c * unit) :=
    r <--$ OC_Query _ (F k_in m);
    $ ret (r, tt).

  Definition PRF_h_A : OracleComp (Bvector b) (Bvector c) bool :=
    k_in <--$$ {0, 1}^k;
    [r, _] <--$2 OC_Run _ _ _ A (hF_oracle k_in) tt;
    $ ret r.

  Definition G1_1 :=
    k_out <-$ { 0 , 1 }^c;
    [b, _] <-$2 PRF_h_A _ _ (f_oracle h _ k_out) tt;
    ret b.

  Definition G1_2 :=
    [b, _] <-$2 PRF_h_A _ _ (randomFunc ({0, 1}^c) _) nil;
    ret b.

  Local Opaque evalDist.

  Theorem G0_G1_1_equiv :
    Pr[G0] == Pr[G1_1].

  Theorem G1_1_2_close :
    | Pr[G1_1] - Pr[G1_2] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A.

  Theorem G1_2_G1_equiv :
    Pr[G1_2] == Pr[G1].

  Theorem G0_G1_equiv :
    | Pr[G0] - Pr[G1] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A.

  Definition randomFunc_mem (D R : Set)(eqdd : EqDec D)(eqdr : EqDec R)(RndR : Comp R) (ls : list (D * R))d :=
    match (arrayLookup _ ls d) with
      | Some r =>
        ret (r, (d, r) :: ls)
      | None =>
        r <-$ RndR; ret (r, (d, r) :: ls)
    end.

    Theorem randomFunc_mem_spec :
    forall (D R : Set)(eqdd : EqDec D)(eqdr : EqDec R)(RndR : Comp R) (x1 x2 : list (D * R)) a,
      (forall z, arrayLookup _ x1 z = arrayLookup _ x2 z) ->
    comp_spec
     (fun y1 y2 =>
      fst y1 = fst y2 /\
      (forall x,
       arrayLookup _ (snd y1) x =
       arrayLookup _ (snd y2) x))
     (randomFunc_mem _ _ RndR x1 a)
     (randomFunc RndR _ x2 a).

  Definition G2_1 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _ (fun s d => randomFunc_mem _ _ ({0, 1}^c) s (F k_in d)) nil;
    ret b.

  Theorem G2_1_equiv :
    Pr[G1] == Pr[G2_1].

  Fixpoint arrayLookup_f (A B C : Set)(eqd : EqDec B)(ls : list ((A * B) * C))(a : B) :=
    match ls with
      | nil => None
      | ((x, z), y) :: ls' =>
        if (eqb a z) then (Some y) else (arrayLookup_f _ ls' a)
    end.

  Definition F_randomFunc k_in f d :=
    match arrayLookup_f _ f (F k_in d) with
      | Some r => ret (r, ((d, F k_in d), r) :: f)
      | None => r <-$ {0, 1}^c; ret (r, ((d, F k_in d), r) :: f)
    end.

  Definition G2_2 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _ (F_randomFunc k_in) nil;
    ret b.

    Theorem arrayLookup_f_equiv :
      forall (A B C : Set) (eqdb : EqDec B) (x1 : list (B * C)) (x2 : list (A * B * C)) (a : B),
      list_pred
         (fun c0 d =>
          fst c0 = snd (fst d) /\ snd c0 = snd d) x1 x2 ->
         arrayLookup _ x1 a = arrayLookup_f _ x2 a.

  Theorem G2_1_2_equiv :
    Pr[G2_1] == Pr[G2_2].

  Fixpoint findCollision_1 (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a : A)(b : B) :=
    match ls with
      | nil => None
      | (a', b') :: ls' => if
        (eqb b b' && (negb (eqb a a')))
        then (Some a') else (findCollision_1 _ _ ls' a b)
    end.

  Definition collidesWith (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a : A) b :=
    if (findCollision_1 _ _ ls a b) then true else false.

  Fixpoint findCollision(A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B)) : option (A * A * B) :=
    match ls with
      | nil => None
      | (a, b) :: ls' => let a' := (findCollision_1 _ _ ls' a b) in
        match a' with
          | None =>  (findCollision _ _ ls')
          | Some p' => Some (a, p', b)
        end
    end.

  Definition funcCollision (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B)) :=
    if (findCollision _ _ ls) then true else false.

  Definition G2_3 :=
    k_in <-$ {0, 1}^k;
    [b, f] <-$2 A _ _ (F_randomFunc k_in) nil;
    ret (b, funcCollision _ _ (fst (split f))).

  Theorem G2_2_3_equiv :
    Pr[G2_2] == Pr[x <-$ G2_3; ret fst x].

  Definition G2_4 :=
    k_in <-$ {0, 1}^k;
    [b, f] <-$2 A _ _ (fun s a => b <- F k_in a; randomFunc_mem _ _ ({0, 1}^c) s (a, b)) nil;
    ret (b, funcCollision _ _ (fst (split f))).

  Theorem arrayLookup_noCollision_eq :
    forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) a b0 b,
      arrayLookup _ x1 (a, b) = Some b0 ->
      collidesWith _ _ (fst (split x1)) a b = false ->
      arrayLookup_f _ x1 b = Some b0.

  Theorem in_impl_collidesWith :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B),
      In (a, b) ls ->
      a <> a' ->
      collidesWith _ _ ls a' b = true.

  Theorem funcCollision_false_impl_collidesWith_false :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B),
      funcCollision _ _ ls = false ->
      In (a, b) ls ->
      collidesWith _ _ ls a b = false.

  Theorem arrayLookup_Some_In_split:
    forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B),
      arrayLookup eqd arr a = Some b -> In a (fst (split arr)).

  Theorem arrayLookup_noCollision_eq_f :
    forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c,
      arrayLookup_f _ x1 b = Some c ->
      collidesWith _ _ (fst (split x1)) a b = false ->
      arrayLookup _ x1 (a, b) = Some c.

  Theorem funcCollision_true_cons :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a,
      funcCollision _ _ ls = true ->
      funcCollision _ _ (a :: ls) = true.

  Theorem F_randomFunc_preserves_coll :
    forall c0 x d a b0,
      funcCollision _ _ (fst (split c0)) = true ->
      In (a, b0) (getSupport (F_randomFunc x c0 d)) ->
      funcCollision _ _ (fst (split b0)) = true.

  Theorem randomFunc_mem_preserves_coll :
    forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0,
      funcCollision _ _ (fst (split c0)) = true ->
      In (a, b0) (getSupport (randomFunc_mem _ _  RndR c0 d)) ->
      funcCollision _ _ (fst (split b0)) = true.

  Theorem F_randomFunc_wf :
    forall x y z,
      well_formed_comp (F_randomFunc x y z).

  Theorem randomFunc_mem_wf :
    forall (A B : Set) x y z (w : list (A * B)) v,
      well_formed_comp z ->
      well_formed_comp (randomFunc_mem x y z w v).

  Theorem A_randomFunc_F_spec :
    forall x,
      comp_spec (fun y1 y2 =>
        funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y1))) =
       funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y2))) /\
        (funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y1))) = false ->
       y1 = y2))
       (A (list (list (Bvector b) * Bvector b * Bvector c))
        (list_EqDec
           (pair_EqDec
              (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
              (Bvector_EqDec c))) (F_randomFunc x) nil)
     (A (list (list (Bvector b) * Bvector b * Bvector c))
        (list_EqDec
           (pair_EqDec
              (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
              (Bvector_EqDec c)))
        (fun (s : list (list (Bvector b) * Bvector b * Bvector c))
           (a : list (Bvector b)) =>
         randomFunc_mem
           (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
           (Bvector_EqDec c) ({ 0 , 1 }^c) s (a, F x a)) nil).

  Theorem G2_3_4_bad_eq :
    Pr[x <-$ G2_3; ret (snd x)] == Pr[x <-$ G2_4; ret (snd x)].

  Theorem G2_3_4_eq_until_bad :
    forall x,
      evalDist G2_3 (x, false) == evalDist G2_4 (x, false).

  Definition F_randomFunc_O f d :
    OracleComp
    (list (Bvector b))
    (Bvector b)
    (Bvector c * list ((list (Bvector b) * Bvector b) * Bvector c))  :=
    fd <--$ OC_Query _ d;
    match arrayLookup_f _ f fd with
      | Some r => $ ret (r, ((d, fd), r) :: f)
      | None => r <--$$ {0, 1}^c; $ ret (r, ((d, fd), r) :: f)
    end.

  Definition au_F_A : OracleComp (list (Bvector b)) (Bvector b) _ :=
    [_, p ] <--$2 OC_Run _ _ _ A F_randomFunc_O nil;
    let coll :=
      match (findCollision _ _ (fst (split p)) ) with
        | None => (nil, nil)
        | Some p => fst p
      end in
      $ ret (coll).

  Definition G2_3_bad :=
    k_in <-$ {0, 1}^k;
    [p, _] <-$2 au_F_A _ _ (WCR_Oracle _ F k_in) tt;
    [d1, d2] <-2 p;
    ret (negb (eqb d1 d2) && eqb (F k_in d1) (F k_in d2)).

  Theorem G2_3_bad_small :
    Pr[G2_3_bad] == Adv_WCR _ _ F (Rnd k) au_F_A.

    Theorem findCollision_1_correct :
      forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y,
      findCollision_1 eqd1 eqd2 ls x1 y =
       Some x2 ->
       x1 <> x2 /\
       In (x2, y) ls.

    Theorem findCollision_correct :
      forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y,
      findCollision eqd1 eqd2 ls =
       Some (x1, x2, y) ->
       x1 <> x2 /\
       In (x1, y) ls /\
       In (x2, y) ls.

  Theorem G2_3_bad_equiv :
    Pr[x <-$ G2_3; ret (snd x)] == Pr[G2_3_bad].

  Theorem G2_3_4_close :
    | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <=
      Adv_WCR _ _ F (Rnd k) au_F_A.

  Definition G2_5 :=
    [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil;
    ret b.

  Theorem G2_4_5_equiv :
    Pr[x <-$ G2_4; ret fst x] == Pr[G2_5].

  Theorem G2_5_equiv :
    Pr[G2_5] == Pr[G2].

  Theorem G1_G2_equiv :
    | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A.

  Theorem G2_equiv :
    Pr[G2] == Pr[PRF_G_B ({0, 1}^c) _ _ A].

  Theorem hF_PRF :
    PRF_Advantage ({0, 1}^(c + k)) ({0, 1}^c) hF _ _ A <=
    PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A +
    Adv_WCR _ _ F (Rnd k) au_F_A.

End hF. *)

Section GNMAC_PRF.

  Variable c p : nat.
  Definition b := @HMAC_spec.b c p.
  Variable h : Bvector c -> Bvector b -> Bvector c.

  Variable fpad : Bvector c -> Bvector p.
  Definition app_fpad := @app_fpad c p fpad.
  Definition h_star := h_star p h.
  Definition h_star_pad := fun k x => app_fpad (h_star k x).

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.
  Hypothesis A_wf : well_formed_oc A.

  Definition GNMAC := GNMAC h fpad.

  Theorem GNMAC_PRF :
     PRF_Advantage (Rnd (c + c)) (Rnd c) GNMAC _ _ A <=
     PRF_Advantage ({ 0 , 1 }^c) ({ 0 , 1 }^c) h (Bvector_EqDec b)
     _
     (PRF_h_A (h_star_pad) A) +
     cAU.Adv_WCR _ _ (h_star_pad)  ({ 0 , 1 }^c) (au_F_A A).

    specialize (hF_PRF h h_star_pad A_wf); intuition.

  Qed.

End GNMAC_PRF.