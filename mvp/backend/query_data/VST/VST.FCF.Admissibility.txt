

Set Implicit Arguments.



Require Import FCF.Comp.
(* FCF.Comp:
Set Implicit Arguments.

Require Export Bvector.
Require Export List.
Require Export FCF.Blist.
Require Export FCF.EqDec.
Require Import FCF.Fold.

Inductive Comp : Set -> Type :=
| Ret : forall (A : Set), eq_dec A -> A -> Comp A
| Bind : forall (A B : Set), Comp B -> (B -> Comp A) -> Comp A
| Rnd : forall n, Comp (Bvector n)
| Repeat : forall (A : Set), Comp A -> (A -> bool) -> Comp A.

Inductive Comp_eq : forall (A : Set), Comp A -> Comp A -> Prop :=
  | Comp_eq_Ret : forall (A : Set)(pf1 pf2 : eq_dec A)(a : A),
    Comp_eq (Ret pf1 a) (Ret pf2 a)
  | Comp_eq_Bind : forall (A B : Set)(c1x c1y : Comp B)(c2x c2y : B -> Comp A),
    Comp_eq c1x c1y ->
    (forall b, (Comp_eq (c2x b) (c2y b))) ->
    Comp_eq (Bind c1x c2x) (Bind c1y c2y)
  | Comp_eq_Rnd : forall n,
    Comp_eq (Rnd n) (Rnd n)
  | Comp_eq_Repeat : forall (A : Set)(c1 c2 : Comp A)(P1 P2 : A -> bool),
    Comp_eq c1 c2 ->
    (forall a, P1 a = P2 a) ->
    Comp_eq (Repeat c1 P1) (Repeat c2 P2).

Hint Constructors Comp_eq : comp.

Theorem Comp_eq_refl : forall (A : Set)(c : Comp A),
  Comp_eq c c.

Lemma Bvector_exists : forall n,
  Bvector n.

Lemma comp_base_exists : forall (A : Set),
  Comp A ->
  A.

Require Import FCF.EqDec. 

Lemma comp_EqDec : forall (A : Set),
  Comp A ->
  EqDec A.

Lemma comp_eq_dec : forall (A : Set),
  Comp A ->
  eq_dec A.

Lemma bind_EqDec : forall (A B : Set),
  Comp B ->
  (B -> Comp A) ->
  EqDec A.

Lemma bind_eq_dec : forall (A B : Set),
  Comp B ->
  (B -> Comp A) ->
  eq_dec A.

Fixpoint getSupport(A : Set)(c : Comp A) : list A :=
  match c with
    | Ret _ a => a :: nil
    | Bind c1 c2 => getUnique (flatten (map (fun b => (getSupport (c2 b))) (getSupport c1))) (bind_eq_dec c1 c2)
    | Rnd n => getAllBvectors n
    | Repeat c1 P => (filter P (getSupport c1))
  end.

Inductive well_formed_comp : forall (A : Set), Comp A -> Prop :=
  | well_formed_Ret :
    forall (A : Set)(pf : eq_dec A)(a : A),
      well_formed_comp (Ret pf a)
  | well_formed_Bind : 
    forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A),
      well_formed_comp c1 ->
      (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
      well_formed_comp (Bind c1 c2)
   | well_formed_Rnd : forall n,
     well_formed_comp (Rnd n)
   | well_formed_Repeat :
     forall (A : Set)(eqd : eq_dec A)(c : Comp A) P b,
      well_formed_comp c ->
      In b (filter P (getSupport c)) ->
      well_formed_comp (Repeat c P).

Delimit Scope comp_scope with comp.

Theorem lt_eq_false : 
  forall n,
    n < n -> False.

Lemma length_nz_exists : forall (A : Type)(ls : list A),
                           length ls > 0 ->
                           exists a, In a ls.

Theorem getSupport_length_nz : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  length (getSupport c) > 0.

Lemma filter_NoDup : forall (A : Set)(ls : list A)(P : A -> bool),
  NoDup ls ->
  NoDup (filter P ls).

Lemma getSupport_NoDup : forall (A : Set)(c : Comp A),
  NoDup (getSupport c).

Lemma getSupport_Bind_In : forall (A B : Set) (c : Comp B)(f : B -> Comp A) a,
  In a (getSupport (Bind c f)) ->
  exists b, 
    In b (getSupport c) /\
    In a (getSupport (f b)).

Ltac pairInv :=
  match goal with 
    | [H : (_, _) = (_, _) |-_ ] => inversion H; clear H; subst
  end.

Ltac destruct_exists :=
  match goal with
    | [H : exists x, _ |- _ ] =>
      destruct H
  end.

Theorem getSupport_In_Ret : 
  forall (A : Set)(eqd : eq_dec A) x a,
    In x (getSupport (Ret eqd a)) ->
    x = a.

Theorem getSupport_In_Seq :
  forall (A B : Set)(c : Comp A)(f : A -> Comp B) b a,
    In a (getSupport c) ->
    In b (getSupport (f a)) ->
    In b (getSupport (Bind c f)).

Local Open Scope comp_scope.

Definition maybeBind(A B : Type)(opt_a : option A)(f : A -> B) : option B :=
  match opt_a with
    | None => None
    | Some a => Some (f a)
  end.

Inductive OracleComp : Set -> Set -> Set -> Type :=
| OC_Query : forall (A B : Set), A -> OracleComp A B B
| OC_Run : forall (A B C A' B' S : Set), 
  EqDec S ->
  EqDec B ->
  EqDec A ->
  OracleComp A B C ->
  (S -> A -> OracleComp A' B' (B * S)) ->
  S ->
  OracleComp A' B' (C * S)
| OC_Ret : forall A B C, Comp C -> OracleComp A B C
| OC_Bind : forall A B C C', OracleComp A B C -> (C -> OracleComp A B C') -> OracleComp A B C'.

Theorem oc_base_exists : forall (A B C : Set), OracleComp A B C -> (A -> B) -> C.

Theorem oc_EqDec : forall (A B C: Set),  OracleComp A B C -> (A -> B) -> (A -> EqDec B) -> EqDec C.

Lemma well_formed_val_exists : 
  forall (A : Set)(c : Comp A),
    well_formed_comp c ->
    exists x, In x (getSupport c). *)



Definition DataTypeFamily := nat -> Set.



Definition FunctionCostModel := forall (A B : Type), (A -> B) -> nat -> Prop.

Definition CompCostModel := forall (A : Set), Comp A -> nat -> Prop.

Definition OC_CostModel := forall (A B C : Set), OracleComp A B C -> (nat -> nat) -> Prop.



Definition pred_comp_fam := forall (A : nat -> Set), (forall n, Comp (A n)) -> Prop.

Definition pred_comp_func_2_fam := forall (A B C : nat -> Set), (forall n, A n -> B n -> Comp (C n)) -> Prop.



Definition pred_oc_fam := forall (A B C : nat -> Set), (forall n, OracleComp (A n) (B n) (C n)) -> Prop.

Definition pred_oc_func_2_fam := forall (A B C D E : nat -> Set), (forall n, A n -> B n -> OracleComp (C n) (D n) (E n)) -> Prop.

