

Require Import Coqlib.

Require Errors.

Require Import Maps.

Require Import AST.

Require Import Integers.

Require Import Switch.

Require Import Op.
(* Op:
Require Import BoolEqual.
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Events.

Set Implicit Arguments.

Inductive condition : Type :=
  | Ccomp (c: comparison)      
  | Ccompu (c: comparison)     
  | Ccompimm (c: comparison) (n: int) 
  | Ccompuimm (c: comparison) (n: int)  
  | Ccompl (c: comparison)      
  | Ccomplu (c: comparison)     
  | Ccomplimm (c: comparison) (n: int64) 
  | Ccompluimm (c: comparison) (n: int64)  
  | Ccompf (c: comparison)     
  | Cnotcompf (c: comparison)  
  | Ccompfs (c: comparison)    
  | Cnotcompfs (c: comparison) 
  | Cmaskzero (n: int)         
  | Cmasknotzero (n: int).     

Inductive addressing: Type :=
  | Aindexed: Z -> addressing       
  | Aindexed2: Z -> addressing      
  | Ascaled: Z -> Z -> addressing   
  | Aindexed2scaled: Z -> Z -> addressing
                                    
  | Aglobal: ident -> ptrofs -> addressing 
  | Abased: ident -> ptrofs -> addressing  
  | Abasedscaled: Z -> ident -> ptrofs -> addressing  
  | Ainstack: ptrofs -> addressing. 

Inductive operation : Type :=
  | Omove                    
  | Ointconst (n: int)       
  | Olongconst (n: int64)    
  | Ofloatconst (n: float)   
  | Osingleconst (n: float32)
  | Oindirectsymbol (id: ident) 

  | Ocast8signed             
  | Ocast8unsigned           
  | Ocast16signed            
  | Ocast16unsigned          
  | Oneg                     
  | Osub                     
  | Omul                     
  | Omulimm (n: int)         
  | Omulhs                   
  | Omulhu                   
  | Odiv                     
  | Odivu                    
  | Omod                     
  | Omodu                    
  | Oand                     
  | Oandimm (n: int)         
  | Oor                      
  | Oorimm (n: int)          
  | Oxor                     
  | Oxorimm (n: int)         
  | Onot                     
  | Oshl                     
  | Oshlimm (n: int)         
  | Oshr                     
  | Oshrimm (n: int)         
  | Oshrximm (n: int)        
  | Oshru                    
  | Oshruimm (n: int)        
  | Ororimm (n: int)         
  | Oshldimm (n: int)        
  | Olea (a: addressing)     

  | Omakelong                
  | Olowlong                 
  | Ohighlong                
  | Ocast32signed            
  | Ocast32unsigned          
  | Onegl                    
  | Oaddlimm (n: int64)      
  | Osubl                    
  | Omull                    
  | Omullimm (n: int64)      
  | Omullhs                  
  | Omullhu                  
  | Odivl                    
  | Odivlu                   
  | Omodl                    
  | Omodlu                   
  | Oandl                    
  | Oandlimm (n: int64)      
  | Oorl                     
  | Oorlimm (n: int64)       
  | Oxorl                    
  | Oxorlimm (n: int64)      
  | Onotl                    
  | Oshll                    
  | Oshllimm (n: int)        
  | Oshrl                    
  | Oshrlimm (n: int)        
  | Oshrxlimm (n: int)       
  | Oshrlu                   
  | Oshrluimm (n: int)       
  | Ororlimm (n: int)        
  | Oleal (a: addressing)    

  | Onegf                    
  | Oabsf                    
  | Oaddf                    
  | Osubf                    
  | Omulf                    
  | Odivf                    
  | Onegfs                   
  | Oabsfs                   
  | Oaddfs                   
  | Osubfs                   
  | Omulfs                   
  | Odivfs                   
  | Osingleoffloat           
  | Ofloatofsingle           

  | Ointoffloat              
  | Ofloatofint              
  | Ointofsingle             
  | Osingleofint             
  | Olongoffloat             
  | Ofloatoflong             
  | Olongofsingle            
  | Osingleoflong            

  | Ocmp (cond: condition).  

Definition eq_condition (x y: condition) : {x=y} + {x<>y}.

Definition eq_addressing (x y: addressing) : {x=y} + {x<>y}.

Definition beq_operation: forall (x y: operation), bool.

Definition eq_operation: forall (x y: operation), {x=y} + {x<>y}.

Global Opaque eq_condition eq_addressing eq_operation.

Definition offset_in_range (n: Z) : bool := zle Int.min_signed n && zle n Int.max_signed.

Definition addressing_valid (a: addressing) : bool :=
  if Archi.ptr64 then
    match a with
    | Aindexed n => offset_in_range n
    | Aindexed2 n => offset_in_range n
    | Ascaled sc ofs => offset_in_range ofs
    | Aindexed2scaled sc ofs => offset_in_range ofs
    | Aglobal s ofs => true
    | Abased s ofs => true
    | Abasedscaled sc s ofs => true
    | Ainstack ofs => offset_in_range (Ptrofs.signed ofs)
    end
  else true.
  
Definition eval_condition (cond: condition) (vl: list val) (m: mem): option bool :=
  match cond, vl with
  | Ccomp c, v1 :: v2 :: nil => Val.cmp_bool c v1 v2
  | Ccompu c, v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2
  | Ccompimm c n, v1 :: nil => Val.cmp_bool c v1 (Vint n)
  | Ccompuimm c n, v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)
  | Ccompl c, v1 :: v2 :: nil => Val.cmpl_bool c v1 v2
  | Ccomplu c, v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
  | Ccomplimm c n, v1 :: nil => Val.cmpl_bool c v1 (Vlong n)
  | Ccompluimm c n, v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)
  | Ccompf c, v1 :: v2 :: nil => Val.cmpf_bool c v1 v2
  | Cnotcompf c, v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)
  | Ccompfs c, v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2
  | Cnotcompfs c, v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)
  | Cmaskzero n, v1 :: nil => Val.maskzero_bool v1 n
  | Cmasknotzero n, v1 :: nil => option_map negb (Val.maskzero_bool v1 n)
  | _, _ => None
  end.

Definition eval_addressing32
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.add v1 (Vint (Int.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.add (Val.add v1 v2) (Vint (Int.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.add (Val.mul v1 (Vint (Int.repr sc))) (Vint (Int.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.add v1 (Val.add (Val.mul v2 (Vint (Int.repr sc))) (Vint (Int.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then None else Some (Genv.symbol_address genv s ofs)
  | Abased s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) v1)
  | Abasedscaled sc s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) (Val.mul v1 (Vint (Int.repr sc))))
  | Ainstack ofs, nil =>
      if Archi.ptr64 then None else Some(Val.offset_ptr sp ofs)
  | _, _ => None
  end.

Definition eval_addressing64
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.addl v1 (Vlong (Int64.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.addl (Val.addl v1 v2) (Vlong (Int64.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.addl (Val.mull v1 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.addl v1 (Val.addl (Val.mull v2 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then Some (Genv.symbol_address genv s ofs) else None
  | Ainstack ofs, nil =>
      if Archi.ptr64 then Some(Val.offset_ptr sp ofs) else None
  | _, _ => None
  end.

Definition eval_addressing
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  if Archi.ptr64
  then eval_addressing64 genv sp addr vl
  else eval_addressing32 genv sp addr vl.

Definition eval_operation
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (op: operation) (vl: list val) (m: mem): option val :=
  match op, vl with
  | Omove, v1::nil => Some v1
  | Ointconst n, nil => Some (Vint n)
  | Olongconst n, nil => Some (Vlong n)
  | Ofloatconst n, nil => Some (Vfloat n)
  | Osingleconst n, nil => Some (Vsingle n)
  | Oindirectsymbol id, nil => Some (Genv.symbol_address genv id Ptrofs.zero)
  | Ocast8signed, v1 :: nil => Some (Val.sign_ext 8 v1)
  | Ocast8unsigned, v1 :: nil => Some (Val.zero_ext 8 v1)
  | Ocast16signed, v1 :: nil => Some (Val.sign_ext 16 v1)
  | Ocast16unsigned, v1 :: nil => Some (Val.zero_ext 16 v1)
  | Oneg, v1::nil => Some (Val.neg v1)
  | Osub, v1::v2::nil => Some (Val.sub v1 v2)
  | Omul, v1::v2::nil => Some (Val.mul v1 v2)
  | Omulimm n, v1::nil => Some (Val.mul v1 (Vint n))
  | Omulhs, v1::v2::nil => Some (Val.mulhs v1 v2)
  | Omulhu, v1::v2::nil => Some (Val.mulhu v1 v2)
  | Odiv, v1::v2::nil => Val.divs v1 v2
  | Odivu, v1::v2::nil => Val.divu v1 v2
  | Omod, v1::v2::nil => Val.mods v1 v2
  | Omodu, v1::v2::nil => Val.modu v1 v2
  | Oand, v1::v2::nil => Some(Val.and v1 v2)
  | Oandimm n, v1::nil => Some (Val.and v1 (Vint n))
  | Oor, v1::v2::nil => Some(Val.or v1 v2)
  | Oorimm n, v1::nil => Some (Val.or v1 (Vint n))
  | Oxor, v1::v2::nil => Some(Val.xor v1 v2)
  | Oxorimm n, v1::nil => Some (Val.xor v1 (Vint n))
  | Onot, v1::nil => Some(Val.notint v1)
  | Oshl, v1::v2::nil => Some (Val.shl v1 v2)
  | Oshlimm n, v1::nil => Some (Val.shl v1 (Vint n))
  | Oshr, v1::v2::nil => Some (Val.shr v1 v2)
  | Oshrimm n, v1::nil => Some (Val.shr v1 (Vint n))
  | Oshrximm n, v1::nil => Val.shrx v1 (Vint n)
  | Oshru, v1::v2::nil => Some (Val.shru v1 v2)
  | Oshruimm n, v1::nil => Some (Val.shru v1 (Vint n))
  | Ororimm n, v1::nil => Some (Val.ror v1 (Vint n))
  | Oshldimm n, v1::v2::nil => Some (Val.or (Val.shl v1 (Vint n))
                                            (Val.shru v2 (Vint (Int.sub Int.iwordsize n))))
  | Olea addr, _ => eval_addressing32 genv sp addr vl
  | Omakelong, v1::v2::nil => Some(Val.longofwords v1 v2)
  | Olowlong, v1::nil => Some(Val.loword v1)
  | Ohighlong, v1::nil => Some(Val.hiword v1)
  | Ocast32signed, v1 :: nil => Some (Val.longofint v1)
  | Ocast32unsigned, v1 :: nil => Some (Val.longofintu v1)
  | Onegl, v1::nil => Some (Val.negl v1)
  | Oaddlimm n, v1::nil => Some (Val.addl v1 (Vlong n))
  | Osubl, v1::v2::nil => Some (Val.subl v1 v2)
  | Omull, v1::v2::nil => Some (Val.mull v1 v2)
  | Omullimm n, v1::nil => Some (Val.mull v1 (Vlong n))
  | Omullhs, v1::v2::nil => Some (Val.mullhs v1 v2)
  | Omullhu, v1::v2::nil => Some (Val.mullhu v1 v2)
  | Odivl, v1::v2::nil => Val.divls v1 v2
  | Odivlu, v1::v2::nil => Val.divlu v1 v2
  | Omodl, v1::v2::nil => Val.modls v1 v2
  | Omodlu, v1::v2::nil => Val.modlu v1 v2
  | Oandl, v1::v2::nil => Some(Val.andl v1 v2)
  | Oandlimm n, v1::nil => Some (Val.andl v1 (Vlong n))
  | Oorl, v1::v2::nil => Some(Val.orl v1 v2)
  | Oorlimm n, v1::nil => Some (Val.orl v1 (Vlong n))
  | Oxorl, v1::v2::nil => Some(Val.xorl v1 v2)
  | Oxorlimm n, v1::nil => Some (Val.xorl v1 (Vlong n))
  | Onotl, v1::nil => Some(Val.notl v1)
  | Oshll, v1::v2::nil => Some (Val.shll v1 v2)
  | Oshllimm n, v1::nil => Some (Val.shll v1 (Vint n))
  | Oshrl, v1::v2::nil => Some (Val.shrl v1 v2)
  | Oshrlimm n, v1::nil => Some (Val.shrl v1 (Vint n))
  | Oshrxlimm n, v1::nil => Val.shrxl v1 (Vint n)
  | Oshrlu, v1::v2::nil => Some (Val.shrlu v1 v2)
  | Oshrluimm n, v1::nil => Some (Val.shrlu v1 (Vint n))
  | Ororlimm n, v1::nil => Some (Val.rorl v1 (Vint n))
  | Oleal addr, _ => eval_addressing64 genv sp addr vl
  | Onegf, v1::nil => Some(Val.negf v1)
  | Oabsf, v1::nil => Some(Val.absf v1)
  | Oaddf, v1::v2::nil => Some(Val.addf v1 v2)
  | Osubf, v1::v2::nil => Some(Val.subf v1 v2)
  | Omulf, v1::v2::nil => Some(Val.mulf v1 v2)
  | Odivf, v1::v2::nil => Some(Val.divf v1 v2)
  | Onegfs, v1::nil => Some(Val.negfs v1)
  | Oabsfs, v1::nil => Some(Val.absfs v1)
  | Oaddfs, v1::v2::nil => Some(Val.addfs v1 v2)
  | Osubfs, v1::v2::nil => Some(Val.subfs v1 v2)
  | Omulfs, v1::v2::nil => Some(Val.mulfs v1 v2)
  | Odivfs, v1::v2::nil => Some(Val.divfs v1 v2)
  | Osingleoffloat, v1::nil => Some(Val.singleoffloat v1)
  | Ofloatofsingle, v1::nil => Some(Val.floatofsingle v1)
  | Ointoffloat, v1::nil => Val.intoffloat v1
  | Ofloatofint, v1::nil => Val.floatofint v1
  | Ointofsingle, v1::nil => Val.intofsingle v1
  | Osingleofint, v1::nil => Val.singleofint v1
  | Olongoffloat, v1::nil => Val.longoffloat v1
  | Ofloatoflong, v1::nil => Val.floatoflong v1
  | Olongofsingle, v1::nil => Val.longofsingle v1
  | Osingleoflong, v1::nil => Val.singleoflong v1
  | Ocmp c, _ => Some(Val.of_optbool (eval_condition c vl m))
  | _, _ => None
  end.

Remark eval_addressing_Aglobal:
  forall (F V: Type) (genv: Genv.t F V) sp id ofs,

Remark eval_addressing_Ainstack:
  forall (F V: Type) (genv: Genv.t F V) sp ofs,

Remark eval_addressing_Ainstack_inv:
  forall (F V: Type) (genv: Genv.t F V) sp ofs vl v,

Ltac FuncInv :=
  match goal with
  | H: (match ?x with nil => _ | _ :: _ => _ end = Some _) |- _ =>
      destruct x; simpl in H; FuncInv
  | H: (match ?v with Vundef => _ | Vint _ => _ | Vfloat _ => _ | Vptr _ _ => _ end = Some _) |- _ =>
      destruct v; simpl in H; FuncInv
  | H: (if Archi.ptr64 then _ else _) = Some _ |- _ =>
      destruct Archi.ptr64 eqn:?; FuncInv
  | H: (Some _ = Some _) |- _ =>
      injection H; intros; clear H; FuncInv
  | H: (None = Some _) |- _ =>
      discriminate H
  | _ =>
      idtac
  end.

Definition type_of_condition (c: condition) : list typ :=
  match c with
  | Ccomp _ => Tint :: Tint :: nil
  | Ccompu _ => Tint :: Tint :: nil
  | Ccompimm _ _ => Tint :: nil
  | Ccompuimm _ _ => Tint :: nil
  | Ccompl _ => Tlong :: Tlong :: nil
  | Ccomplu _ => Tlong :: Tlong :: nil
  | Ccomplimm _ _ => Tlong :: nil
  | Ccompluimm _ _ => Tlong :: nil
  | Ccompf _ => Tfloat :: Tfloat :: nil
  | Cnotcompf _ => Tfloat :: Tfloat :: nil
  | Ccompfs _ => Tsingle :: Tsingle :: nil
  | Cnotcompfs _ => Tsingle :: Tsingle :: nil
  | Cmaskzero _ => Tint :: nil
  | Cmasknotzero _ => Tint :: nil
  end.

Definition type_of_addressing_gen (tyA: typ) (addr: addressing): list typ :=
  match addr with
  | Aindexed _ => tyA :: nil
  | Aindexed2 _ => tyA :: tyA :: nil
  | Ascaled _ _ => tyA :: nil
  | Aindexed2scaled _ _ => tyA :: tyA :: nil
  | Aglobal _ _ => nil
  | Abased _ _ => tyA :: nil
  | Abasedscaled _ _ _ => tyA :: nil
  | Ainstack _ => nil
  end.

Definition type_of_addressing := type_of_addressing_gen Tptr.
Definition type_of_addressing32 := type_of_addressing_gen Tint.
Definition type_of_addressing64 := type_of_addressing_gen Tlong.

Definition type_of_operation (op: operation) : list typ * typ :=
  match op with
  | Omove => (nil, Tint)   
  | Ointconst _ => (nil, Tint)
  | Olongconst _ => (nil, Tlong)
  | Ofloatconst f => (nil, Tfloat)
  | Osingleconst f => (nil, Tsingle)
  | Oindirectsymbol _ => (nil, Tptr)
  | Ocast8signed => (Tint :: nil, Tint)
  | Ocast8unsigned => (Tint :: nil, Tint)
  | Ocast16signed => (Tint :: nil, Tint)
  | Ocast16unsigned => (Tint :: nil, Tint)
  | Oneg => (Tint :: nil, Tint)
  | Osub => (Tint :: Tint :: nil, Tint)
  | Omul => (Tint :: Tint :: nil, Tint)
  | Omulimm _ => (Tint :: nil, Tint)
  | Omulhs => (Tint :: Tint :: nil, Tint)
  | Omulhu => (Tint :: Tint :: nil, Tint)
  | Odiv => (Tint :: Tint :: nil, Tint)
  | Odivu => (Tint :: Tint :: nil, Tint)
  | Omod => (Tint :: Tint :: nil, Tint)
  | Omodu => (Tint :: Tint :: nil, Tint)
  | Oand => (Tint :: Tint :: nil, Tint)
  | Oandimm _ => (Tint :: nil, Tint)
  | Oor => (Tint :: Tint :: nil, Tint)
  | Oorimm _ => (Tint :: nil, Tint)
  | Oxor => (Tint :: Tint :: nil, Tint)
  | Oxorimm _ => (Tint :: nil, Tint)
  | Onot => (Tint :: nil, Tint)
  | Oshl => (Tint :: Tint :: nil, Tint)
  | Oshlimm _ => (Tint :: nil, Tint)
  | Oshr => (Tint :: Tint :: nil, Tint)
  | Oshrimm _ => (Tint :: nil, Tint)
  | Oshrximm _ => (Tint :: nil, Tint)
  | Oshru => (Tint :: Tint :: nil, Tint)
  | Oshruimm _ => (Tint :: nil, Tint)
  | Ororimm _ => (Tint :: nil, Tint)
  | Oshldimm _ => (Tint :: Tint :: nil, Tint)
  | Olea addr => (type_of_addressing32 addr, Tint)
  | Omakelong => (Tint :: Tint :: nil, Tlong)
  | Olowlong => (Tlong :: nil, Tint)
  | Ohighlong => (Tlong :: nil, Tint)
  | Ocast32signed => (Tint :: nil, Tlong)
  | Ocast32unsigned => (Tint :: nil, Tlong)
  | Onegl => (Tlong :: nil, Tlong)
  | Oaddlimm _ => (Tlong :: nil, Tlong)
  | Osubl => (Tlong :: Tlong :: nil, Tlong)
  | Omull => (Tlong :: Tlong :: nil, Tlong)
  | Omullimm _ => (Tlong :: nil, Tlong)
  | Omullhs => (Tlong :: Tlong :: nil, Tlong)
  | Omullhu => (Tlong :: Tlong :: nil, Tlong)
  | Odivl => (Tlong :: Tlong :: nil, Tlong)
  | Odivlu => (Tlong :: Tlong :: nil, Tlong)
  | Omodl => (Tlong :: Tlong :: nil, Tlong)
  | Omodlu => (Tlong :: Tlong :: nil, Tlong)
  | Oandl => (Tlong :: Tlong :: nil, Tlong)
  | Oandlimm _ => (Tlong :: nil, Tlong)
  | Oorl => (Tlong :: Tlong :: nil, Tlong)
  | Oorlimm _ => (Tlong :: nil, Tlong)
  | Oxorl => (Tlong :: Tlong :: nil, Tlong)
  | Oxorlimm _ => (Tlong :: nil, Tlong)
  | Onotl => (Tlong :: nil, Tlong)
  | Oshll => (Tlong :: Tint :: nil, Tlong)
  | Oshllimm _ => (Tlong :: nil, Tlong)
  | Oshrl => (Tlong :: Tint :: nil, Tlong)
  | Oshrlimm _ => (Tlong :: nil, Tlong)
  | Oshrxlimm _ => (Tlong :: nil, Tlong)
  | Oshrlu => (Tlong :: Tint :: nil, Tlong)
  | Oshrluimm _ => (Tlong :: nil, Tlong)
  | Ororlimm _ => (Tlong :: nil, Tlong)
  | Oleal addr => (type_of_addressing64 addr, Tlong)
  | Onegf => (Tfloat :: nil, Tfloat)
  | Oabsf => (Tfloat :: nil, Tfloat)
  | Oaddf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Osubf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Omulf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Odivf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Onegfs => (Tsingle :: nil, Tsingle)
  | Oabsfs => (Tsingle :: nil, Tsingle)
  | Oaddfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osubfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Omulfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Odivfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osingleoffloat => (Tfloat :: nil, Tsingle)
  | Ofloatofsingle => (Tsingle :: nil, Tfloat)
  | Ointoffloat => (Tfloat :: nil, Tint)
  | Ofloatofint => (Tint :: nil, Tfloat)
  | Ointofsingle => (Tsingle :: nil, Tint)
  | Osingleofint => (Tint :: nil, Tsingle)
  | Olongoffloat => (Tfloat :: nil, Tlong)
  | Ofloatoflong => (Tlong :: nil, Tfloat)
  | Olongofsingle => (Tsingle :: nil, Tlong)
  | Osingleoflong => (Tlong :: nil, Tsingle)
  | Ocmp c => (type_of_condition c, Tint)
  end.

Section SOUNDNESS.

Variable A V: Type.
Variable genv: Genv.t A V.

Remark type_add:
  forall v1 v2, Val.has_type (Val.add v1 v2) Tint.

Remark type_addl:
  forall v1 v2, Val.has_type (Val.addl v1 v2) Tlong.

Lemma type_of_addressing64_sound:
  forall addr vl sp v,
  eval_addressing64 genv sp addr vl = Some v ->
  Val.has_type v Tlong.

Lemma type_of_addressing32_sound:
  forall addr vl sp v,
  eval_addressing32 genv sp addr vl = Some v ->
  Val.has_type v Tint.

Corollary type_of_addressing_sound:
  forall addr vl sp v,
  eval_addressing genv sp addr vl = Some v ->
  Val.has_type v Tptr.

Lemma type_of_operation_sound:
  forall op vl sp v m,
  op <> Omove ->
  eval_operation genv sp op vl m = Some v ->
  Val.has_type v (snd (type_of_operation op)).

End SOUNDNESS.

Definition is_move_operation
    (A: Type) (op: operation) (args: list A) : option A :=
  match op, args with
  | Omove, arg :: nil => Some arg
  | _, _ => None
  end.

Lemma is_move_operation_correct:
  forall (A: Type) (op: operation) (args: list A) (a: A),
  is_move_operation op args = Some a ->
  op = Omove /\ args = a :: nil.

Definition negate_condition (cond: condition): condition :=
  match cond with
  | Ccomp c => Ccomp(negate_comparison c)
  | Ccompu c => Ccompu(negate_comparison c)
  | Ccompimm c n => Ccompimm (negate_comparison c) n
  | Ccompuimm c n => Ccompuimm (negate_comparison c) n
  | Ccompl c => Ccompl(negate_comparison c)
  | Ccomplu c => Ccomplu(negate_comparison c)
  | Ccomplimm c n => Ccomplimm (negate_comparison c) n
  | Ccompluimm c n => Ccompluimm (negate_comparison c) n
  | Ccompf c => Cnotcompf c
  | Cnotcompf c => Ccompf c
  | Ccompfs c => Cnotcompfs c
  | Cnotcompfs c => Ccompfs c
  | Cmaskzero n => Cmasknotzero n
  | Cmasknotzero n => Cmaskzero n
  end.

Lemma eval_negate_condition:
  forall cond vl m,
  eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m).

Definition shift_stack_addressing (delta: Z) (addr: addressing) :=
  match addr with
  | Ainstack ofs => Ainstack (Ptrofs.add ofs (Ptrofs.repr delta))
  | _ => addr
  end.

Definition shift_stack_operation (delta: Z) (op: operation) :=
  match op with
  | Olea  addr => Olea  (shift_stack_addressing delta addr)
  | Oleal addr => Oleal (shift_stack_addressing delta addr)
  | _ => op
  end.

Lemma type_shift_stack_addressing:
  forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr.

Lemma type_shift_stack_operation:
  forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op.

Lemma eval_shift_stack_addressing32:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing64:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_operation:
  forall F V (ge: Genv.t F V) sp op vl m delta,

Definition offset_addressing_total (addr: addressing) (delta: Z) : addressing :=
  match addr with
  | Aindexed n => Aindexed (n + delta)
  | Aindexed2 n => Aindexed2 (n + delta)
  | Ascaled sc n => Ascaled sc (n + delta)
  | Aindexed2scaled sc n => Aindexed2scaled sc (n + delta)
  | Aglobal s n => Aglobal s (Ptrofs.add n (Ptrofs.repr delta))
  | Abased s n => Abased s (Ptrofs.add n (Ptrofs.repr delta))
  | Abasedscaled sc s n => Abasedscaled sc s (Ptrofs.add n (Ptrofs.repr delta))
  | Ainstack n => Ainstack (Ptrofs.add n (Ptrofs.repr delta))
  end.

Definition offset_addressing (addr: addressing) (delta: Z) : option addressing :=
  let addr' := offset_addressing_total addr delta in
  if addressing_valid addr' then Some addr' else None.

Lemma eval_offset_addressing_total_32:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing_total_64:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta addr' v,

Definition is_trivial_op (op: operation) : bool :=
  match op with
  | Omove => true
  | Ointconst _ => true
  | Olongconst _ => true
  | Olea (Aglobal _ _) => true
  | Olea (Ainstack _) => true
  | Oleal (Aglobal _ _) => true
  | Oleal (Ainstack _) => true
  | _ => false
  end.

Definition op_depends_on_memory (op: operation) : bool :=
  match op with
  | Ocmp (Ccompu _) => negb Archi.ptr64
  | Ocmp (Ccompuimm _ _) => negb Archi.ptr64
  | Ocmp (Ccomplu _) => Archi.ptr64
  | Ocmp (Ccompluimm _ _) => Archi.ptr64
  | _ => false
  end.

Lemma op_depends_on_memory_correct:
  forall (F V: Type) (ge: Genv.t F V) sp op args m1 m2,

Definition globals_addressing (addr: addressing) : list ident :=
  match addr with
  | Aglobal s n => s :: nil
  | Abased s n => s :: nil
  | Abasedscaled sc s n => s :: nil
  | _ => nil
  end.

Definition globals_operation (op: operation) : list ident :=
  match op with
  | Oindirectsymbol s => s :: nil
  | Olea addr => globals_addressing addr
  | Oleal addr => globals_addressing addr
  | _ => nil
  end.

Section GENV_TRANSF.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Hypothesis agree_on_symbols:
  forall (s: ident), Genv.find_symbol ge2 s = Genv.find_symbol ge1 s.

Lemma eval_addressing32_preserved:
  forall sp addr vl,
  eval_addressing32 ge2 sp addr vl = eval_addressing32 ge1 sp addr vl.

Lemma eval_addressing64_preserved:
  forall sp addr vl,
  eval_addressing64 ge2 sp addr vl = eval_addressing64 ge1 sp addr vl.

Lemma eval_addressing_preserved:
  forall sp addr vl,
  eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.

Lemma eval_operation_preserved:
  forall sp op vl m,
  eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.

End GENV_TRANSF.

Section EVAL_COMPAT.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Variable f: meminj.

Variable m1: mem.
Variable m2: mem.

Hypothesis valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_pointers_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->
  Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Ltac InvInject :=
  match goal with
  | [ H: Val.inject _ (Vint _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vfloat _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vptr _ _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ nil _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ (_ :: _) _ |- _ ] =>
      inv H; InvInject
  | _ => idtac
  end.

Lemma eval_condition_inj:
  forall cond vl1 vl2 b,
  Val.inject_list f vl1 vl2 ->

Ltac TrivialExists :=
  match goal with
  | [ |- exists v2, Some ?v1 = Some v2 /\ Val.inject _ _ v2 ] =>
      exists v1; split; auto
  | _ => idtac
  end.

Lemma eval_addressing32_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing64_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_operation_inj:
  forall op sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_operation op) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

End EVAL_COMPAT.

Section EVAL_LESSDEF.

Variable F V: Type.
Variable genv: Genv.t F V.

Remark valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_no_overflow_extends:
  forall m1 b1 ofs b2 delta,
  Some(b1, 0) = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->

Remark valid_different_pointers_extends:
  forall m1 b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->

Lemma eval_condition_lessdef:
  forall cond vl1 vl2 b m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_operation_lessdef:
  forall sp op vl1 vl2 v1 m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_addressing_lessdef:
  forall sp addr vl1 vl2 v1,
  Val.lessdef_list vl1 vl2 ->

End EVAL_LESSDEF.

Section EVAL_INJECT.

Variable F V: Type.
Variable genv: Genv.t F V.
Variable f: meminj.
Hypothesis globals: meminj_preserves_globals genv f.
Variable sp1: block.
Variable sp2: block.
Variable delta: Z.
Hypothesis sp_inj: f sp1 = Some(sp2, delta).

Remark symbol_address_inject:
  forall id ofs, Val.inject f (Genv.symbol_address genv id ofs) (Genv.symbol_address genv id ofs).

Lemma eval_condition_inject:
  forall cond vl1 vl2 b m1 m2,
  Val.inject_list f vl1 vl2 ->

Lemma eval_addressing_inject:
  forall addr vl1 vl2 v1,
  Val.inject_list f vl1 vl2 ->

Lemma eval_operation_inject:
  forall op vl1 vl2 v1 m1 m2,
  Val.inject_list f vl1 vl2 ->

End EVAL_INJECT.

Definition builtin_arg_ok_1
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match c, ba with
  | OK_all, _ => true
  | OK_const, (BA_int _ | BA_long _ | BA_float _ | BA_single _) => true
  | OK_addrstack, BA_addrstack _ => true
  | OK_addressing, BA_addrstack _ => true
  | OK_addressing, BA_addrglobal _ _ => true
  | OK_addressing, BA_addptr (BA _) (BA_int _ | BA_long _) => true
  | _, _ => false
  end.

Definition builtin_arg_ok
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match ba with
  | (BA _ | BA_splitlong (BA _) (BA _)) => true
  | _ => builtin_arg_ok_1 ba c
  end. *)

Require Import Registers.

Require Import CminorSel.

Require Import RTL.



Open Local Scope string_scope.



Record mapping: Type := mkmapping {

  map_vars: PTree.t reg;

  map_letvars: list reg

}.



Record state: Type := mkstate {

  st_nextreg: positive;

  st_nextnode: positive;

  st_code: code;

  st_wf: forall (pc: positive), Plt pc st_nextnode \/ st_code!pc = None

}.



Inductive state_incr: state -> state -> Prop :=

  state_incr_intro:

    forall (s1 s2: state),

    Ple s1.(st_nextnode) s2.(st_nextnode) ->

    Ple s1.(st_nextreg) s2.(st_nextreg) ->

    (forall pc,

      s1.(st_code)!pc = None \/ s2.(st_code)!pc = s1.(st_code)!pc) ->

    state_incr s1 s2.



Lemma state_incr_refl:

  forall s, state_incr s s.

Proof.

  intros. apply state_incr_intro.

  apply Ple_refl. apply Ple_refl. intros; auto.

Qed.



Lemma state_incr_trans:

  forall s1 s2 s3, state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3.

Proof.

  intros. inv H; inv H0. apply state_incr_intro.

  apply Ple_trans with (st_nextnode s2); assumption.

  apply Ple_trans with (st_nextreg s2); assumption.

  intros. generalize (H3 pc) (H5 pc). intuition congruence.

Qed.



Inductive res (A: Type) (s: state): Type :=

  | Error: Errors.errmsg -> res A s

  | OK: A -> forall (s': state), state_incr s s' -> res A s.



Implicit Arguments OK [A s].

Implicit Arguments Error [A s].



Definition mon (A: Type) : Type := forall (s: state), res A s.



Definition ret (A: Type) (x: A) : mon A :=

  fun (s: state) => OK x s (state_incr_refl s).



Implicit Arguments ret [A].



Definition error (A: Type) (msg: Errors.errmsg) : mon A := fun (s: state) => Error msg.



Implicit Arguments error [A].



Definition bind (A B: Type) (f: mon A) (g: A -> mon B) : mon B :=

  fun (s: state) =>

    match f s with

    | Error msg => Error msg

    | OK a s' i =>

        match g a s' with

        | Error msg => Error msg

        | OK b s'' i' => OK b s'' (state_incr_trans s s' s'' i i')

        end

    end.



Implicit Arguments bind [A B].



Definition bind2 (A B C: Type) (f: mon (A * B)) (g: A -> B -> mon C) : mon C :=

  bind f (fun xy => g (fst xy) (snd xy)).



Implicit Arguments bind2 [A B C].



Notation "'do' X <- A ; B" := (bind A (fun X => B))

   (at level 200, X ident, A at level 100, B at level 200).

Notation "'do' ( X , Y ) <- A ; B" := (bind2 A (fun X Y => B))

   (at level 200, X ident, Y ident, A at level 100, B at level 200).



Definition handle_error (A: Type) (f g: mon A) : mon A :=

  fun (s: state) =>

    match f s with

    | OK a s' i => OK a s' i

    | Error _ => g s

    end.



Implicit Arguments handle_error [A].



Remark init_state_wf:

  forall pc, Plt pc 1%positive \/ (PTree.empty instruction)!pc = None.

Proof. intros; right; apply PTree.gempty. Qed.



Definition init_state : state :=

  mkstate 1%positive 1%positive (PTree.empty instruction) init_state_wf.



Remark add_instr_wf:

  forall s i pc,

  let n := s.(st_nextnode) in

  Plt pc (Psucc n) \/ (PTree.set n i s.(st_code))!pc = None.

Proof.

  intros. case (peq pc n); intro.

  subst pc; left; apply Plt_succ.

  rewrite PTree.gso; auto.

  elim (st_wf s pc); intro.

  left. apply Plt_trans_succ. exact H.

  right; assumption.

Qed.



Remark add_instr_incr:

  forall s i,

  let n := s.(st_nextnode) in

  state_incr s (mkstate s.(st_nextreg)

                (Psucc n)

                (PTree.set n i s.(st_code))

                (add_instr_wf s i)).

Proof.

  constructor; simpl.

  apply Ple_succ.

  apply Ple_refl.

  intros. destruct (st_wf s pc). right. apply PTree.gso. apply Plt_ne; auto. auto.

Qed.



Definition add_instr (i: instruction) : mon node :=

  fun s =>

    let n := s.(st_nextnode) in

    OK n

       (mkstate s.(st_nextreg) (Psucc n) (PTree.set n i s.(st_code))

                (add_instr_wf s i))

       (add_instr_incr s i).



Remark reserve_instr_wf:

  forall s pc,

  Plt pc (Psucc s.(st_nextnode)) \/ s.(st_code)!pc = None.

Proof.

  intros. elim (st_wf s pc); intro.

  left; apply Plt_trans_succ; auto.

  right; auto.

Qed.



Remark reserve_instr_incr:

  forall s,

  let n := s.(st_nextnode) in

  state_incr s (mkstate s.(st_nextreg)

                (Psucc n)

                s.(st_code)

                (reserve_instr_wf s)).

Proof.

  intros; constructor; simpl.

  apply Ple_succ.

  apply Ple_refl.

  auto.

Qed.



Definition reserve_instr: mon node :=

  fun (s: state) =>

  let n := s.(st_nextnode) in

  OK n

     (mkstate s.(st_nextreg) (Psucc n) s.(st_code) (reserve_instr_wf s))

     (reserve_instr_incr s).



Remark update_instr_wf:

  forall s n i,

  Plt n s.(st_nextnode) ->

  forall pc,

  Plt pc s.(st_nextnode) \/ (PTree.set n i s.(st_code))!pc = None.

Proof.

  intros.

  case (peq pc n); intro.

  subst pc; left; assumption.

  rewrite PTree.gso; auto. exact (st_wf s pc).

Qed.



Remark update_instr_incr:

  forall s n i (LT: Plt n s.(st_nextnode)),

  s.(st_code)!n = None ->

  state_incr s

             (mkstate s.(st_nextreg) s.(st_nextnode) (PTree.set n i s.(st_code))

                     (update_instr_wf s n i LT)).

Proof.

  intros.

  constructor; simpl; intros.

  apply Ple_refl.

  apply Ple_refl.

  rewrite PTree.gsspec. destruct (peq pc n). left; congruence. right; auto.

Qed.



Definition check_empty_node:

  forall (s: state) (n: node), { s.(st_code)!n = None } + { True }.

Proof.

  intros. case (s.(st_code)!n); intros. right; auto. left; auto.

Defined.



Definition update_instr (n: node) (i: instruction) : mon unit :=

  fun s =>

    match plt n s.(st_nextnode), check_empty_node s n with

    | left LT, left EMPTY =>

        OK tt

           (mkstate s.(st_nextreg) s.(st_nextnode) (PTree.set n i s.(st_code))

                    (update_instr_wf s n i LT))

           (update_instr_incr s n i LT EMPTY)

    | _, _ =>

        Error (Errors.msg "RTLgen.update_instr")

    end.



Remark new_reg_incr:

  forall s,

  state_incr s (mkstate (Psucc s.(st_nextreg))

                        s.(st_nextnode) s.(st_code) s.(st_wf)).

Proof.

  constructor; simpl. apply Ple_refl. apply Ple_succ. auto.

Qed.



Definition new_reg : mon reg :=

  fun s =>

    OK s.(st_nextreg)

       (mkstate (Psucc s.(st_nextreg)) s.(st_nextnode) s.(st_code) s.(st_wf))

       (new_reg_incr s).



Definition init_mapping : mapping :=

  mkmapping (PTree.empty reg) nil.



Definition add_var (map: mapping) (name: ident) : mon (reg * mapping) :=

  do r <- new_reg;

     ret (r, mkmapping (PTree.set name r map.(map_vars))

                       map.(map_letvars)).



Fixpoint add_vars (map: mapping) (names: list ident)

                  {struct names} : mon (list reg * mapping) :=

  match names with

  | nil => ret (nil, map)

  | n1 :: nl =>

      do (rl, map1) <- add_vars map nl;

      do (r1, map2) <- add_var map1 n1;

      ret (r1 :: rl, map2)

  end.



Definition find_var (map: mapping) (name: ident) : mon reg :=

  match PTree.get name map.(map_vars) with

  | None => error (Errors.MSG "RTLgen: unbound variable " :: Errors.CTX name :: nil)

  | Some r => ret r

  end.



Definition add_letvar (map: mapping) (r: reg) : mapping :=

  mkmapping map.(map_vars) (r :: map.(map_letvars)).



Definition find_letvar (map: mapping) (idx: nat) : mon reg :=

  match List.nth_error map.(map_letvars) idx with

  | None => error (Errors.msg "RTLgen: unbound let variable")

  | Some r => ret r

  end.



Definition alloc_reg (map: mapping) (a: expr) : mon reg :=

  match a with

  | Evar id   => find_var map id

  | Eletvar n => find_letvar map n

  | _         => new_reg

  end.



Fixpoint alloc_regs (map: mapping) (al: exprlist)

                    {struct al}: mon (list reg) :=

  match al with

  | Enil =>

      ret nil

  | Econs a bl =>

      do r  <- alloc_reg map a;

      do rl <- alloc_regs map bl;

      ret (r :: rl)

  end.



Definition alloc_optreg (map: mapping) (dest: option ident) : mon reg :=

  match dest with

  | Some id => find_var map id

  | None => new_reg

  end.



Definition add_move (rs rd: reg) (nd: node) : mon node :=

  if Reg.eq rs rd

  then ret nd

  else add_instr (Iop Omove (rs::nil) rd nd).



Fixpoint transl_expr (map: mapping) (a: expr) (rd: reg) (nd: node)

                     {struct a}: mon node :=

  match a with

  | Evar v =>

      do r <- find_var map v; add_move r rd nd

  | Eop op al =>

      do rl <- alloc_regs map al;

      do no <- add_instr (Iop op rl rd nd);

      transl_exprlist map al rl no

  | Eload chunk addr al =>

      do rl <- alloc_regs map al;

      do no <- add_instr (Iload chunk addr rl rd nd);

         transl_exprlist map al rl no

  | Econdition a b c =>

      do nfalse <- transl_expr map c rd nd;

      do ntrue  <- transl_expr map b rd nd;

         transl_condexpr map a ntrue nfalse

  | Elet b c =>

      do r  <- new_reg;

      do nc <- transl_expr (add_letvar map r) c rd nd;

         transl_expr map b r nc

  | Eletvar n =>

      do r <- find_letvar map n; add_move r rd nd

  | Ebuiltin ef al =>

      do rl <- alloc_regs map al;

      do no <- add_instr (Ibuiltin ef rl rd nd);

      transl_exprlist map al rl no

  | Eexternal id sg al =>

      do rl <- alloc_regs map al;

      do no <- add_instr (Icall sg (inr id) rl rd nd);

      transl_exprlist map al rl no

  end



with transl_exprlist (map: mapping) (al: exprlist) (rl: list reg) (nd: node)

                     {struct al} : mon node :=

  match al, rl with

  | Enil, nil =>

      ret nd

  | Econs b bs, r :: rs =>

      do no <- transl_exprlist map bs rs nd; transl_expr map b r no

  | _, _ =>

      error (Errors.msg "RTLgen.transl_exprlist")

  end



with transl_condexpr (map: mapping) (a: condexpr) (ntrue nfalse: node)

                     {struct a} : mon node :=

  match a with

  | CEcond c al =>

      do rl <- alloc_regs map al;

      do nt <- add_instr (Icond c rl ntrue nfalse);

         transl_exprlist map al rl nt

  | CEcondition a b c =>

      do nc <- transl_condexpr map c ntrue nfalse;

      do nb <- transl_condexpr map b ntrue nfalse;

         transl_condexpr map a nb nc

  | CElet b c =>

      do r  <- new_reg;

      do nc <- transl_condexpr (add_letvar map r) c ntrue nfalse;

         transl_expr map b r nc

  end.



Parameter more_likely: condexpr -> stmt -> stmt -> bool.



Parameter compile_switch: nat -> table -> comptree.



Definition transl_exit (nexits: list node) (n: nat) : mon node :=

  match nth_error nexits n with

  | None => error (Errors.msg "RTLgen: wrong exit")

  | Some ne => ret ne

  end.



Fixpoint transl_jumptable (nexits: list node) (tbl: list nat) : mon (list node) :=

  match tbl with

  | nil => ret nil

  | t1 :: tl =>

      do n1 <- transl_exit nexits t1;

      do nl <- transl_jumptable nexits tl;

      ret (n1 :: nl)

  end.



Fixpoint transl_switch (r: reg) (nexits: list node) (t: comptree)

                       {struct t} : mon node :=

  match t with

  | CTaction act =>

      transl_exit nexits act

  | CTifeq key act t' =>

      do ncont <- transl_switch r nexits t';

      do nfound <- transl_exit nexits act;

      add_instr (Icond (Ccompimm Ceq key) (r :: nil) nfound ncont)

  | CTiflt key t1 t2 =>

      do n2 <- transl_switch r nexits t2;

      do n1 <- transl_switch r nexits t1;

      add_instr (Icond (Ccompuimm Clt key) (r :: nil) n1 n2)

  | CTjumptable ofs sz tbl t' =>

      do rt <- new_reg;

      do ttbl <- transl_jumptable nexits tbl;

      do n1 <- add_instr (Ijumptable rt ttbl);

      do n2 <- transl_switch r nexits t';

      do n3 <- add_instr (Icond (Ccompuimm Clt sz) (rt :: nil) n1 n2);

      let op := if Int.eq ofs Int.zero then Omove else Oaddimm (Int.neg ofs) in

      add_instr (Iop op (r :: nil) rt n3)

  end.



Definition labelmap : Type := PTree.t node.



Fixpoint transl_stmt (map: mapping) (s: stmt) (nd: node)

                     (nexits: list node) (ngoto: labelmap) (nret: node) (rret: option reg)

                     {struct s} : mon node :=

  match s with

  | Sskip =>

      ret nd

  | Sassign v b =>

      do r <- find_var map v;

      transl_expr map b r nd

  | Sstore chunk addr al b =>

      do rl <- alloc_regs map al;

      do r <- alloc_reg map b;

      do no <- add_instr (Istore chunk addr rl r nd);

      do ns <- transl_expr map b r no;

         transl_exprlist map al rl ns

  | Scall optid sig (inl b) cl =>

      do rf <- alloc_reg map b;

      do rargs <- alloc_regs map cl;

      do r <- alloc_optreg map optid;

      do n1 <- add_instr (Icall sig (inl _ rf) rargs r nd);

      do n2 <- transl_exprlist map cl rargs n1;

         transl_expr map b rf n2

  | Scall optid sig (inr id) cl =>

      do rargs <- alloc_regs map cl;

      do r <- alloc_optreg map optid;

      do n1 <- add_instr (Icall sig (inr _ id) rargs r nd);

      transl_exprlist map cl rargs n1

  | Stailcall sig (inl b) cl =>

      do rf <- alloc_reg map b;

      do rargs <- alloc_regs map cl;

      do n1 <- add_instr (Itailcall sig (inl _ rf) rargs);

      do n2 <- transl_exprlist map cl rargs n1;

         transl_expr map b rf n2

  | Stailcall sig (inr id) cl =>

      do rargs <- alloc_regs map cl;

      do n1 <- add_instr (Itailcall sig (inr _ id) rargs);

      transl_exprlist map cl rargs n1

  | Sbuiltin optid ef al =>

      do rargs <- alloc_regs map al;

      do r <- alloc_optreg map optid;

      do n1 <- add_instr (Ibuiltin ef rargs r nd);

         transl_exprlist map al rargs n1

  | Sseq s1 s2 =>

      do ns <- transl_stmt map s2 nd nexits ngoto nret rret;

      transl_stmt map s1 ns nexits ngoto nret rret

  | Sifthenelse c strue sfalse =>

      if more_likely c strue sfalse then

        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;

        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;

           transl_condexpr map c ntrue nfalse

      else

        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;

        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;

           transl_condexpr map c ntrue nfalse

  | Sloop sbody =>

      do n1 <- reserve_instr;

      do n2 <- transl_stmt map sbody n1 nexits ngoto nret rret;

      do xx <- update_instr n1 (Inop n2);

      add_instr (Inop n2)

  | Sblock sbody =>

      transl_stmt map sbody nd (nd :: nexits) ngoto nret rret

  | Sexit n =>

      transl_exit nexits n

  | Sswitch a cases default =>

      let t := compile_switch default cases in

      if validate_switch default cases t then

        (do r <- alloc_reg map a;

         do ns <- transl_switch r nexits t;

         transl_expr map a r ns)

      else

        error (Errors.msg "RTLgen: wrong switch")

  | Sreturn opt_a =>

      match opt_a, rret with

      | None, _ => ret nret

      | Some a, Some r => transl_expr map a r nret

      | _, _ => error (Errors.msg "RTLgen: type mismatch on return")

      end

  | Slabel lbl s' =>

      do ns <- transl_stmt map s' nd nexits ngoto nret rret;

      match ngoto!lbl with

      | None => error (Errors.msg "RTLgen: unbound label")

      | Some n =>

          do xx <-

            (handle_error (update_instr n (Inop ns))

                          (error (Errors.MSG "Multiply-defined label " ::

                                  Errors.CTX lbl :: nil)));

          ret ns

      end

  | Sgoto lbl =>

      match ngoto!lbl with

      | None => error (Errors.MSG "Undefined defined label " ::

                       Errors.CTX lbl :: nil)

      | Some n => ret n

      end

  end.



Definition alloc_label (lbl: Cminor.label) (maps: labelmap * state) : labelmap * state :=

  let (map, s) := maps in

  let n := s.(st_nextnode) in

  (PTree.set lbl n map,

   mkstate s.(st_nextreg) (Psucc s.(st_nextnode)) s.(st_code) (reserve_instr_wf s)).



Fixpoint reserve_labels (s: stmt) (ms: labelmap * state)

                        {struct s} : labelmap * state :=

  match s with

  | Sseq s1 s2 => reserve_labels s1 (reserve_labels s2 ms)

  | Sifthenelse c s1 s2 => reserve_labels s1 (reserve_labels s2 ms)

  | Sloop s1 => reserve_labels s1 ms

  | Sblock s1 => reserve_labels s1 ms

  | Slabel lbl s1 => alloc_label lbl (reserve_labels s1 ms)

  | _ => ms

  end.



Definition ret_reg (sig: signature) (rd: reg) : option reg :=

  match sig.(sig_res) with

  | None => None

  | Some ty => Some rd

  end.



Definition transl_fun (f: CminorSel.function) (ngoto: labelmap): mon (node * list reg) :=

  do (rparams, map1) <- add_vars init_mapping f.(CminorSel.fn_params);

  do (rvars, map2) <- add_vars map1 f.(CminorSel.fn_vars);

  do rret <- new_reg;

  let orret := ret_reg f.(CminorSel.fn_sig) rret in

  do nret <- add_instr (Ireturn orret);

  do nentry <- transl_stmt map2 f.(CminorSel.fn_body) nret nil ngoto nret orret;

  ret (nentry, rparams).



Definition transl_function (f: CminorSel.function) : Errors.res RTL.function :=

  let (ngoto, s0) := reserve_labels f.(fn_body) (PTree.empty node, init_state) in

  match transl_fun f ngoto s0 with

  | Error msg => Errors.Error msg

  | OK (nentry, rparams) s i =>

      Errors.OK (RTL.mkfunction

                   f.(CminorSel.fn_sig)

                   rparams

                   f.(CminorSel.fn_stackspace)

                   s.(st_code)

                   nentry)

  end.



Definition transl_fundef := transf_partial_fundef transl_function.



Definition transl_program (p: CminorSel.program) : Errors.res RTL.program :=

  transform_partial_program transl_fundef p.

