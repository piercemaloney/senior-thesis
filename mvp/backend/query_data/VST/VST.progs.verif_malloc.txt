Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VST.floyd.library.
(* VST.floyd.library:
Require Import VST.floyd.base2.
Require Import VST.floyd.sublist.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.closed_lemmas.
Require Import VST.floyd.compare_lemmas.
Require Import VST.floyd.semax_tactics.
Require Import VST.floyd.forward.
Require Import VST.floyd.call_lemmas.
Require Import VST.floyd.forward_lemmas.
Require Import VST.floyd.for_lemmas.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.nested_field_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import VST.floyd.mapsto_memory_block.
Require Import VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.data_at_rec_lemmas.
Require Import VST.floyd.field_at.
Require Import VST.floyd.field_compat.
Require Import VST.floyd.stronger.
Require Import VST.floyd.loadstore_mapsto.
Require Import VST.floyd.loadstore_field_at.
Require Import VST.floyd.nested_loadstore.
Require Import VST.floyd.local2ptree_denote.
Require Import VST.floyd.local2ptree_eval.
Require Import VST.floyd.proj_reptype_lemmas.
Require Import VST.floyd.replace_refill_reptype_lemmas.
Require Import VST.floyd.sc_set_load_store.

Require Import VST.floyd.entailer.
Require Import VST.floyd.globals_lemmas.
Require Import VST.floyd.diagnosis.
Require Import VST.floyd.freezer.
Import ListNotations.
Import String.

Definition body_lemma_of_funspec  {Espec: OracleKind} (ef: external_function) (f: funspec) :=
  match f with mk_funspec sig _ A P Q _ _ =>
    semax_external (map fst (fst sig)) ef A P Q
  end.

Definition try_spec  (name: string) (spec: funspec) : 
   list (ident * globdef Clight.fundef type) -> list (ident*funspec) :=
fun defs => 
 match ext_link_prog' defs name with
 | Some id => [(id,spec)]
 | None => nil
 end.
Arguments try_spec name spec defs / .

Definition exit_spec' :=
 WITH u: unit
 PRE [1%positive OF tint]
   PROP () LOCAL() SEP()
 POST [ tvoid ]
   PROP(False) LOCAL() SEP().

Definition exit_spec := try_spec "exit" exit_spec'.

Parameter body_exit:
 forall {Espec: OracleKind},
  body_lemma_of_funspec
    (EF_external "exit"
       {| sig_args := AST.Tint :: nil; sig_res := None; sig_cc := cc_default |})
   exit_spec'.

Parameter mem_mgr: globals -> mpred.
Axiom create_mem_mgr: forall gv, emp |-- mem_mgr gv.

Parameter malloc_token : forall {cs: compspecs}, share -> type -> val -> mpred.
Parameter malloc_token_valid_pointer:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- valid_pointer p.
Hint Resolve malloc_token_valid_pointer : valid_pointer.

Parameter malloc_token_local_facts:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- !! malloc_compatible (sizeof t) p.
Hint Resolve malloc_token_local_facts : saturate_local.
Parameter malloc_token_change_composite: forall {cs_from cs_to} {CCE : change_composite_env cs_from cs_to} sh t,
  cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->
  @malloc_token cs_from sh t = @malloc_token cs_to sh t.
Ltac change_compspecs' cs cs' ::=
  match goal with
  | |- context [@data_at cs' ?sh ?t ?v1] => erewrite (@data_at_change_composite cs' cs _ sh t); [| apply JMeq_refl | reflexivity]
  | |- context [@field_at cs' ?sh ?t ?gfs ?v1] => erewrite (@field_at_change_composite cs' cs _ sh t gfs); [| apply JMeq_refl | reflexivity]
  | |- context [@data_at_ cs' ?sh ?t] => erewrite (@data_at__change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [@field_at_ cs' ?sh ?t ?gfs] => erewrite (@field_at__change_composite cs' cs _ sh t gfs); [| reflexivity]
  | |- context [@malloc_token cs' ?sh ?t] => erewrite (@malloc_token_change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [?A cs'] => change (A cs') with (A cs)
  | |- context [?A cs' ?B] => change (A cs' B) with (A cs B)
  | |- context [?A cs' ?B ?C] => change (A cs' B C) with (A cs B C)
  | |- context [?A cs' ?B ?C ?D] => change (A cs' B C D) with (A cs B C D)
  | |- context [?A cs' ?B ?C ?D ?E] => change (A cs' B C D E) with (A cs B C D E)
  | |- context [?A cs' ?B ?C ?D ?E ?F] => change (A cs' B C D E F) with (A cs B C D E F)
 end.

Definition malloc_spec'  {cs: compspecs} :=
   WITH t:type, gv: globals
   PRE [ 1%positive OF size_t ]
       PROP (0 <= sizeof t <= Ptrofs.max_unsigned;
                complete_legal_cosu_type t = true;
                natural_aligned natural_alignment t = true)
       LOCAL (temp 1%positive (Vptrofs (Ptrofs.repr (sizeof t))); gvars gv)
       SEP (mem_mgr gv)
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (mem_mgr gv;
             if eq_dec p nullval then emp
            else (malloc_token Ews t p * data_at_ Ews t p)).

Parameter body_malloc:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_malloc malloc_spec'.

Definition free_spec'  {cs: compspecs} :=
   WITH t: type, p:val, gv: globals
   PRE [ 1%positive OF tptr tvoid ]
       PROP ()
       LOCAL (temp 1%positive p; gvars gv)
       SEP (mem_mgr gv;
              if eq_dec p nullval then emp
              else (malloc_token Ews t p * data_at_ Ews t p))
    POST [ Tvoid ]
       PROP ()
       LOCAL ()
       SEP (mem_mgr gv).

Parameter body_free:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_free free_spec'.

Definition library_G  {cs: compspecs} prog :=
 let defs := prog_defs prog in 
  try_spec "exit" exit_spec' defs ++
  try_spec "_malloc" malloc_spec' defs ++
  try_spec "_free" free_spec' defs.

Ltac with_library prog G :=
  let pr := eval unfold prog in prog in  
 let x := constr:(library_G pr ++ G) in
  let x := eval cbv beta delta [app library_G] in x in
  let x := simpl_prog_defs x in 
  let x := eval cbv beta iota zeta delta [try_spec] in x in 
  let x := eval simpl in x in 
    with_library' pr x.

Lemma semax_func_cons_malloc_aux:
  forall {cs: compspecs} (gv: globals) (gx : genviron) (t :type) (ret : option val),
(EX p : val,
 PROP ( )
 LOCAL (temp ret_temp p)
 SEP (mem_mgr gv;
      if eq_dec p nullval
      then emp
      else malloc_token Ews t p * data_at_ Ews t p))%assert
  (make_ext_rval gx ret) |-- !! is_pointer_or_null (force_val ret). *)



Require Import VST.progs.malloc.
(* VST.progs.malloc:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition ___builtin_annot : ident := 3%positive.
Definition ___builtin_annot_intval : ident := 4%positive.
Definition ___builtin_bswap : ident := 29%positive.
Definition ___builtin_bswap16 : ident := 32%positive.
Definition ___builtin_bswap32 : ident := 31%positive.
Definition ___builtin_bswap64 : ident := 30%positive.
Definition ___builtin_clz : ident := 33%positive.
Definition ___builtin_clzl : ident := 34%positive.
Definition ___builtin_clzll : ident := 35%positive.
Definition ___builtin_ctz : ident := 36%positive.
Definition ___builtin_ctzl : ident := 37%positive.
Definition ___builtin_ctzll : ident := 38%positive.
Definition ___builtin_debug : ident := 51%positive.
Definition ___builtin_fabs : ident := 1%positive.
Definition ___builtin_fmadd : ident := 42%positive.
Definition ___builtin_fmax : ident := 40%positive.
Definition ___builtin_fmin : ident := 41%positive.
Definition ___builtin_fmsub : ident := 43%positive.
Definition ___builtin_fnmadd : ident := 44%positive.
Definition ___builtin_fnmsub : ident := 45%positive.
Definition ___builtin_fsqrt : ident := 39%positive.
Definition ___builtin_membar : ident := 5%positive.
Definition ___builtin_memcpy_aligned : ident := 2%positive.
Definition ___builtin_nop : ident := 50%positive.
Definition ___builtin_read16_reversed : ident := 46%positive.
Definition ___builtin_read32_reversed : ident := 47%positive.
Definition ___builtin_va_arg : ident := 7%positive.
Definition ___builtin_va_copy : ident := 8%positive.
Definition ___builtin_va_end : ident := 9%positive.
Definition ___builtin_va_start : ident := 6%positive.
Definition ___builtin_write16_reversed : ident := 48%positive.
Definition ___builtin_write32_reversed : ident := 49%positive.
Definition ___compcert_va_composite : ident := 13%positive.
Definition ___compcert_va_float64 : ident := 12%positive.
Definition ___compcert_va_int32 : ident := 10%positive.
Definition ___compcert_va_int64 : ident := 11%positive.
Definition ___i64_dtos : ident := 14%positive.
Definition ___i64_dtou : ident := 15%positive.
Definition ___i64_sar : ident := 26%positive.
Definition ___i64_sdiv : ident := 20%positive.
Definition ___i64_shl : ident := 24%positive.
Definition ___i64_shr : ident := 25%positive.
Definition ___i64_smod : ident := 22%positive.
Definition ___i64_smulh : ident := 27%positive.
Definition ___i64_stod : ident := 16%positive.
Definition ___i64_stof : ident := 18%positive.
Definition ___i64_udiv : ident := 21%positive.
Definition ___i64_umod : ident := 23%positive.
Definition ___i64_umulh : ident := 28%positive.
Definition ___i64_utod : ident := 17%positive.
Definition ___i64_utof : ident := 19%positive.
Definition ___stringlit_1 : ident := 59%positive.
Definition ___stringlit_2 : ident := 60%positive.
Definition ___stringlit_3 : ident := 61%positive.
Definition ___stringlit_4 : ident := 62%positive.
Definition ___stringlit_5 : ident := 73%positive.
Definition _abort : ident := 52%positive.
Definition _b : ident := 55%positive.
Definition _bin : ident := 64%positive.
Definition _bin2size : ident := 56%positive.
Definition _fill_bin : ident := 67%positive.
Definition _free : ident := 71%positive.
Definition _free_small : ident := 70%positive.
Definition _main : ident := 75%positive.
Definition _malloc : ident := 74%positive.
Definition _malloc_small : ident := 69%positive.
Definition _nbytes : ident := 68%positive.
Definition _p : ident := 65%positive.
Definition _printf : ident := 53%positive.
Definition _q : ident := 66%positive.
Definition _result : ident := 72%positive.
Definition _s : ident := 57%positive.
Definition _sbrk : ident := 54%positive.
Definition _size2bin : ident := 58%positive.
Definition _testclaim : ident := 63%positive.
Definition _t'1 : ident := 76%positive.
Definition _t'10 : ident := 85%positive.
Definition _t'11 : ident := 86%positive.
Definition _t'12 : ident := 87%positive.
Definition _t'13 : ident := 88%positive.
Definition _t'14 : ident := 89%positive.
Definition _t'15 : ident := 90%positive.
Definition _t'16 : ident := 91%positive.
Definition _t'17 : ident := 92%positive.
Definition _t'18 : ident := 93%positive.
Definition _t'2 : ident := 77%positive.
Definition _t'3 : ident := 78%positive.
Definition _t'4 : ident := 79%positive.
Definition _t'5 : ident := 80%positive.
Definition _t'6 : ident := 81%positive.
Definition _t'7 : ident := 82%positive.
Definition _t'8 : ident := 83%positive.
Definition _t'9 : ident := 84%positive.

Definition v___stringlit_2 := {|
  gvar_info := (tarray tschar 177);
  gvar_init := (Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 60) :: Init_int8 (Int.repr 61) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 122) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 66) :: Init_int8 (Int.repr 73) ::
                Init_int8 (Int.repr 78) :: Init_int8 (Int.repr 83) ::
                Init_int8 (Int.repr 45) :: Init_int8 (Int.repr 49) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 63) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 60) :: Init_int8 (Int.repr 61) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 122) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 38) ::
                Init_int8 (Int.repr 38) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 60) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 66) :: Init_int8 (Int.repr 73) ::
                Init_int8 (Int.repr 78) :: Init_int8 (Int.repr 83) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 38) ::
                Init_int8 (Int.repr 38) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 122) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 61) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 122) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 50) ::
                Init_int8 (Int.repr 98) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 110) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 38) ::
                Init_int8 (Int.repr 38) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 122) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 50) :: Init_int8 (Int.repr 98) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 43) :: Init_int8 (Int.repr 87) ::
                Init_int8 (Int.repr 79) :: Init_int8 (Int.repr 82) ::
                Init_int8 (Int.repr 68) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 37) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 40) ::
                Init_int8 (Int.repr 87) :: Init_int8 (Int.repr 79) ::
                Init_int8 (Int.repr 82) :: Init_int8 (Int.repr 68) ::
                Init_int8 (Int.repr 42) :: Init_int8 (Int.repr 65) ::
                Init_int8 (Int.repr 76) :: Init_int8 (Int.repr 73) ::
                Init_int8 (Int.repr 71) :: Init_int8 (Int.repr 78) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 61) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 48) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 58) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 49) ::
                Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_4 := {|
  gvar_info := (tarray tschar 30);
  gvar_init := (Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 58) :: Init_int8 (Int.repr 37) ::
                Init_int8 (Int.repr 117) :: Init_int8 (Int.repr 58) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 102) ::
                Init_int8 (Int.repr 97) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 108) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 100) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 97) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 114) :: Init_int8 (Int.repr 116) ::
                Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 111) ::
                Init_int8 (Int.repr 110) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 96) :: Init_int8 (Int.repr 37) ::
                Init_int8 (Int.repr 115) :: Init_int8 (Int.repr 39) ::
                Init_int8 (Int.repr 10) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_3 := {|
  gvar_info := (tarray tschar 9);
  gvar_init := (Init_int8 (Int.repr 109) :: Init_int8 (Int.repr 97) ::
                Init_int8 (Int.repr 108) :: Init_int8 (Int.repr 108) ::
                Init_int8 (Int.repr 111) :: Init_int8 (Int.repr 99) ::
                Init_int8 (Int.repr 46) :: Init_int8 (Int.repr 99) ::
                Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_5 := {|
  gvar_info := (tarray tschar 32);
  gvar_init := (Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 105) ::
                Init_int8 (Int.repr 110) :: Init_int8 (Int.repr 116) ::
                Init_int8 (Int.repr 41) :: Init_int8 (Int.repr 114) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 115) ::
                Init_int8 (Int.repr 117) :: Init_int8 (Int.repr 108) ::
                Init_int8 (Int.repr 116) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 40) :: Init_int8 (Int.repr 87) ::
                Init_int8 (Int.repr 79) :: Init_int8 (Int.repr 82) ::
                Init_int8 (Int.repr 68) :: Init_int8 (Int.repr 42) ::
                Init_int8 (Int.repr 65) :: Init_int8 (Int.repr 76) ::
                Init_int8 (Int.repr 73) :: Init_int8 (Int.repr 71) ::
                Init_int8 (Int.repr 78) :: Init_int8 (Int.repr 41) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 61) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 48) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_1 := {|
  gvar_info := (tarray tschar 16);
  gvar_init := (Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 51) ::
                Init_int8 (Int.repr 100) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 37) ::
                Init_int8 (Int.repr 51) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 32) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 51) ::
                Init_int8 (Int.repr 122) :: Init_int8 (Int.repr 117) ::
                Init_int8 (Int.repr 10) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition f_bin2size := {|
  fn_return := tuint;
  fn_callconv := cc_default;
  fn_params := ((_b, tint) :: nil);
  fn_vars := nil;
  fn_temps := nil;
  fn_body :=
(Sreturn (Some (Ebinop Omul
                 (Ebinop Osub
                   (Ebinop Omul
                     (Ebinop Oadd (Etempvar _b tint)
                       (Econst_int (Int.repr 1) tint) tint)
                     (Econst_int (Int.repr 2) tint) tint)
                   (Econst_int (Int.repr 1) tint) tint) (Esizeof tuint tuint)
                 tuint)))
|}.

Definition f_size2bin := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_s, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_t'1, tuint) :: nil);
  fn_body :=
(Ssequence
  (Scall (Some _t'1)
    (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint cc_default))
    ((Ebinop Osub (Econst_int (Int.repr 8) tint)
       (Econst_int (Int.repr 1) tint) tint) :: nil))
  (Sifthenelse (Ebinop Ogt (Etempvar _s tuint) (Etempvar _t'1 tuint) tint)
    (Sreturn (Some (Eunop Oneg (Econst_int (Int.repr 1) tint) tint)))
    (Sreturn (Some (Ebinop Odiv
                     (Ebinop Oadd (Etempvar _s tuint)
                       (Ebinop Osub
                         (Ebinop Omul (Esizeof tuint tuint)
                           (Ebinop Osub (Econst_int (Int.repr 2) tint)
                             (Econst_int (Int.repr 1) tint) tint) tuint)
                         (Econst_int (Int.repr 1) tint) tuint) tuint)
                     (Ebinop Omul (Esizeof tuint tuint)
                       (Econst_int (Int.repr 2) tint) tuint) tuint)))))
|}.

Definition f_testclaim := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_s, tint) :: (_b, tint) :: (_t'18, tvoid) :: (_t'17, tint) ::
               (_t'16, tvoid) :: (_t'15, tuint) :: (_t'14, tint) ::
               (_t'13, tint) :: (_t'12, tint) :: (_t'11, tuint) ::
               (_t'10, tint) :: (_t'9, tint) :: (_t'8, tint) ::
               (_t'7, tint) :: (_t'6, tuint) :: (_t'5, tint) ::
               (_t'4, tint) :: (_t'3, tuint) :: (_t'2, tuint) ::
               (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _s (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      (Sifthenelse (Ebinop Olt (Etempvar _s tint)
                     (Econst_int (Int.repr 122) tint) tint)
        Sskip
        Sbreak)
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _size2bin (Tfunction (Tcons tuint Tnil) tint cc_default))
            ((Etempvar _s tint) :: nil))
          (Sset _b (Etempvar _t'1 tint)))
        (Ssequence
          (Ssequence
            (Scall (Some _t'2)
              (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint cc_default))
              ((Etempvar _b tint) :: nil))
            (Scall None
              (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                              {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
              ((Evar ___stringlit_1 (tarray tschar 16)) ::
               (Etempvar _s tint) :: (Etempvar _b tint) ::
               (Etempvar _t'2 tuint) :: nil)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'3)
                (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint
                                  cc_default))
                ((Ebinop Osub (Econst_int (Int.repr 8) tint)
                   (Econst_int (Int.repr 1) tint) tint) :: nil))
              (Sifthenelse (Ebinop Ole (Etempvar _s tint)
                             (Etempvar _t'3 tuint) tint)
                (Ssequence
                  (Ssequence
                    (Ssequence
                      (Ssequence
                        (Scall (Some _t'5)
                          (Evar _size2bin (Tfunction (Tcons tuint Tnil) tint
                                            cc_default))
                          ((Etempvar _s tint) :: nil))
                        (Scall (Some _t'6)
                          (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint
                                            cc_default))
                          ((Etempvar _t'5 tint) :: nil)))
                      (Sifthenelse (Ebinop Ole (Etempvar _s tint)
                                     (Etempvar _t'6 tuint) tint)
                        (Ssequence
                          (Scall (Some _t'8)
                            (Evar _size2bin (Tfunction (Tcons tuint Tnil)
                                              tint cc_default))
                            ((Etempvar _s tint) :: nil))
                          (Sset _t'7
                            (Ecast
                              (Ebinop Olt (Etempvar _t'8 tint)
                                (Econst_int (Int.repr 8) tint) tint) tbool)))
                        (Sset _t'7 (Econst_int (Int.repr 0) tint))))
                    (Sifthenelse (Etempvar _t'7 tint)
                      (Ssequence
                        (Ssequence
                          (Ssequence
                            (Ssequence
                              (Scall (Some _t'10)
                                (Evar _size2bin (Tfunction (Tcons tuint Tnil)
                                                  tint cc_default))
                                ((Etempvar _s tint) :: nil))
                              (Scall (Some _t'11)
                                (Evar _bin2size (Tfunction (Tcons tint Tnil)
                                                  tuint cc_default))
                                ((Etempvar _t'10 tint) :: nil)))
                            (Scall (Some _t'12)
                              (Evar _size2bin (Tfunction (Tcons tuint Tnil)
                                                tint cc_default))
                              ((Etempvar _t'11 tuint) :: nil)))
                          (Scall (Some _t'13)
                            (Evar _size2bin (Tfunction (Tcons tuint Tnil)
                                              tint cc_default))
                            ((Etempvar _s tint) :: nil)))
                        (Sset _t'9
                          (Ecast
                            (Ebinop Oeq (Etempvar _t'12 tint)
                              (Etempvar _t'13 tint) tint) tbool)))
                      (Sset _t'9 (Econst_int (Int.repr 0) tint))))
                  (Sifthenelse (Etempvar _t'9 tint)
                    (Ssequence
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'14)
                            (Evar _size2bin (Tfunction (Tcons tuint Tnil)
                                              tint cc_default))
                            ((Etempvar _s tint) :: nil))
                          (Scall (Some _t'15)
                            (Evar _bin2size (Tfunction (Tcons tint Tnil)
                                              tuint cc_default))
                            ((Etempvar _t'14 tint) :: nil)))
                        (Sset _t'4
                          (Ecast
                            (Ebinop Oeq
                              (Ebinop Omod
                                (Ebinop Oadd (Etempvar _t'15 tuint)
                                  (Esizeof tuint tuint) tuint)
                                (Ebinop Omul (Esizeof tuint tuint)
                                  (Econst_int (Int.repr 2) tint) tuint)
                                tuint) (Econst_int (Int.repr 0) tint) tint)
                            tbool)))
                      (Sset _t'4 (Ecast (Etempvar _t'4 tint) tint)))
                    (Sset _t'4 (Ecast (Econst_int (Int.repr 0) tint) tint))))
                (Sset _t'4 (Ecast (Econst_int (Int.repr 1) tint) tint))))
            (Sifthenelse (Etempvar _t'4 tint)
              (Sset _t'16
                (Ecast (Ecast (Econst_int (Int.repr 0) tint) tvoid) tvoid))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'17)
                    (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                                    {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
                    ((Evar ___stringlit_4 (tarray tschar 30)) ::
                     (Evar ___stringlit_3 (tarray tschar 9)) ::
                     (Econst_int (Int.repr 48) tint) ::
                     (Evar ___stringlit_2 (tarray tschar 177)) :: nil))
                  (Scall (Some _t'18)
                    (Evar _abort (Tfunction Tnil tvoid cc_default)) nil))
                (Sset _t'16 (Ecast (Etempvar _t'18 tvoid) tvoid))))))))
    (Sset _s
      (Ebinop Oadd (Etempvar _s tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition v_bin := {|
  gvar_info := (tarray (tptr tvoid) 8);
  gvar_init := (Init_space 32 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_fill_bin := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_b, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_s, tuint) :: (_p, (tptr tschar)) :: (_q, (tptr tschar)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, tuint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint cc_default))
      ((Etempvar _b tint) :: nil))
    (Sset _s (Etempvar _t'1 tuint)))
  (Ssequence
    (Ssequence
      (Scall (Some _t'2)
        (Evar _sbrk (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
        ((Ebinop Omul
           (Ebinop Oshl (Econst_int (Int.repr 2) tint)
             (Econst_int (Int.repr 16) tint) tint) (Esizeof tuint tuint)
           tuint) :: nil))
      (Sset _p (Ecast (Etempvar _t'2 (tptr tvoid)) (tptr tschar))))
    (Ssequence
      (Ssequence
        (Sset _q
          (Ebinop Oadd (Etempvar _p (tptr tschar)) (Etempvar _s tuint)
            (tptr tschar)))
        (Sloop
          (Ssequence
            (Sifthenelse (Ebinop Olt
                           (Ebinop Oadd
                             (Ebinop Oadd (Etempvar _q (tptr tschar))
                               (Etempvar _s tuint) (tptr tschar))
                             (Esizeof tuint tuint) (tptr tschar))
                           (Ebinop Oadd (Etempvar _p (tptr tschar))
                             (Ebinop Omul
                               (Ebinop Oshl (Econst_int (Int.repr 2) tint)
                                 (Econst_int (Int.repr 16) tint) tint)
                               (Esizeof tuint tuint) tuint) (tptr tschar))
                           tint)
              Sskip
              Sbreak)
            (Ssequence
              (Sassign
                (Ederef
                  (Ebinop Oadd
                    (Ecast (Etempvar _q (tptr tschar)) (tptr tuint))
                    (Econst_int (Int.repr 0) tint) (tptr tuint)) tuint)
                (Etempvar _s tuint))
              (Sassign
                (Ederef
                  (Ecast
                    (Ebinop Oadd
                      (Ecast (Etempvar _q (tptr tschar)) (tptr tuint))
                      (Econst_int (Int.repr 1) tint) (tptr tuint))
                    (tptr (tptr tvoid))) (tptr tvoid))
                (Ebinop Oadd (Etempvar _q (tptr tschar))
                  (Ebinop Oadd (Etempvar _s tuint) (Esizeof tuint tuint)
                    tuint) (tptr tschar)))))
          (Sset _q
            (Ebinop Oadd (Etempvar _q (tptr tschar))
              (Ebinop Oadd (Etempvar _s tuint) (Esizeof tuint tuint) tuint)
              (tptr tschar)))))
      (Ssequence
        (Sset _q
          (Ebinop Osub (Etempvar _q (tptr tschar))
            (Ebinop Oadd (Etempvar _s tuint) (Esizeof tuint tuint) tuint)
            (tptr tschar)))
        (Ssequence
          (Sassign
            (Ederef
              (Ebinop Oadd (Ecast (Etempvar _q (tptr tschar)) (tptr tuint))
                (Econst_int (Int.repr 0) tint) (tptr tuint)) tuint)
            (Etempvar _s tuint))
          (Ssequence
            (Sassign
              (Ederef
                (Ecast
                  (Ebinop Oadd
                    (Ecast (Etempvar _q (tptr tschar)) (tptr tuint))
                    (Econst_int (Int.repr 1) tint) (tptr tuint))
                  (tptr (tptr tvoid))) (tptr tvoid))
              (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
            (Sreturn (Some (Ecast
                             (Ebinop Oadd
                               (Ebinop Oadd (Etempvar _p (tptr tschar))
                                 (Etempvar _s tuint) (tptr tschar))
                               (Esizeof tuint tuint) (tptr tschar))
                             (tptr tvoid))))))))))
|}.

Definition f_malloc_small := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_nbytes, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_b, tint) :: (_q, (tptr tvoid)) :: (_p, (tptr tvoid)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _size2bin (Tfunction (Tcons tuint Tnil) tint cc_default))
      ((Etempvar _nbytes tuint) :: nil))
    (Sset _b (Etempvar _t'1 tint)))
  (Ssequence
    (Sset _p
      (Ederef
        (Ebinop Oadd (Evar _bin (tarray (tptr tvoid) 8)) (Etempvar _b tint)
          (tptr (tptr tvoid))) (tptr tvoid)))
    (Ssequence
      (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
        (Ssequence
          (Ssequence
            (Scall (Some _t'2)
              (Evar _fill_bin (Tfunction (Tcons tint Tnil) (tptr tvoid)
                                cc_default)) ((Etempvar _b tint) :: nil))
            (Sset _p (Etempvar _t'2 (tptr tvoid))))
          (Sassign
            (Ederef
              (Ebinop Oadd (Evar _bin (tarray (tptr tvoid) 8))
                (Etempvar _b tint) (tptr (tptr tvoid))) (tptr tvoid))
            (Etempvar _p (tptr tvoid))))
        Sskip)
      (Ssequence
        (Sset _q
          (Ederef (Ecast (Etempvar _p (tptr tvoid)) (tptr (tptr tvoid)))
            (tptr tvoid)))
        (Ssequence
          (Sassign
            (Ederef
              (Ebinop Oadd (Evar _bin (tarray (tptr tvoid) 8))
                (Etempvar _b tint) (tptr (tptr tvoid))) (tptr tvoid))
            (Etempvar _q (tptr tvoid)))
          (Sreturn (Some (Etempvar _p (tptr tvoid)))))))))
|}.

Definition f_free_small := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr tvoid)) :: (_s, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_b, tint) :: (_q, (tptr tvoid)) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _size2bin (Tfunction (Tcons tuint Tnil) tint cc_default))
      ((Etempvar _s tuint) :: nil))
    (Sset _b (Etempvar _t'1 tint)))
  (Ssequence
    (Sset _q
      (Ederef
        (Ebinop Oadd (Evar _bin (tarray (tptr tvoid) 8)) (Etempvar _b tint)
          (tptr (tptr tvoid))) (tptr tvoid)))
    (Ssequence
      (Sassign
        (Ederef (Ecast (Etempvar _p (tptr tvoid)) (tptr (tptr tvoid)))
          (tptr tvoid)) (Etempvar _q (tptr tvoid)))
      (Sassign
        (Ederef
          (Ebinop Oadd (Evar _bin (tarray (tptr tvoid) 8)) (Etempvar _b tint)
            (tptr (tptr tvoid))) (tptr tvoid)) (Etempvar _p (tptr tvoid))))))
|}.

Definition f_free := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_s, tuint) :: (_t'1, tuint) :: nil);
  fn_body :=
(Ssequence
  (Sset _s
    (Ecast
      (Ederef
        (Ebinop Oadd (Ecast (Etempvar _p (tptr tvoid)) (tptr (tptr tvoid)))
          (Eunop Oneg (Econst_int (Int.repr 1) tint) tint)
          (tptr (tptr tvoid))) (tptr tvoid)) tuint))
  (Ssequence
    (Scall (Some _t'1)
      (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint cc_default))
      ((Ebinop Osub (Econst_int (Int.repr 8) tint)
         (Econst_int (Int.repr 1) tint) tint) :: nil))
    (Sifthenelse (Ebinop Ole (Etempvar _s tuint) (Etempvar _t'1 tuint) tint)
      (Scall None
        (Evar _free_small (Tfunction (Tcons (tptr tvoid) (Tcons tuint Tnil))
                            tvoid cc_default))
        ((Etempvar _p (tptr tvoid)) :: (Etempvar _s tuint) :: nil))
      Sskip)))
|}.

Definition f_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_s, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_result, (tptr tvoid)) :: (_t'5, tvoid) :: (_t'4, tint) ::
               (_t'3, tvoid) :: (_t'2, tuint) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'2)
      (Evar _bin2size (Tfunction (Tcons tint Tnil) tuint cc_default))
      ((Ebinop Osub (Econst_int (Int.repr 8) tint)
         (Econst_int (Int.repr 1) tint) tint) :: nil))
    (Sifthenelse (Ebinop Ogt (Etempvar _s tuint) (Etempvar _t'2 tuint) tint)
      (Sset _result (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
      (Ssequence
        (Scall (Some _t'1)
          (Evar _malloc_small (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                cc_default)) ((Etempvar _s tuint) :: nil))
        (Sset _result (Etempvar _t'1 (tptr tvoid))))))
  (Ssequence
    (Sifthenelse (Ebinop Oeq
                   (Ebinop Omod (Ecast (Etempvar _result (tptr tvoid)) tint)
                     (Ebinop Omul (Esizeof tuint tuint)
                       (Econst_int (Int.repr 2) tint) tuint) tuint)
                   (Econst_int (Int.repr 0) tint) tint)
      (Sset _t'3 (Ecast (Ecast (Econst_int (Int.repr 0) tint) tvoid) tvoid))
      (Ssequence
        (Ssequence
          (Scall (Some _t'4)
            (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                            {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
            ((Evar ___stringlit_4 (tarray tschar 30)) ::
             (Evar ___stringlit_3 (tarray tschar 9)) ::
             (Econst_int (Int.repr 110) tint) ::
             (Evar ___stringlit_5 (tarray tschar 32)) :: nil))
          (Scall (Some _t'5) (Evar _abort (Tfunction Tnil tvoid cc_default))
            nil))
        (Sset _t'3 (Ecast (Etempvar _t'5 tvoid) tvoid))))
    (Sreturn (Some (Etempvar _result (tptr tvoid))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_q, (tptr tvoid)) ::
               (_t'4, (tptr tvoid)) :: (_t'3, (tptr tvoid)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall None (Evar _testclaim (Tfunction Tnil tvoid cc_default)) nil)
    (Ssequence
      (Ssequence
        (Scall (Some _t'1)
          (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                          cc_default))
          ((Econst_int (Int.repr 100) tint) :: nil))
        (Sset _p (Etempvar _t'1 (tptr tvoid))))
      (Ssequence
        (Ssequence
          (Scall (Some _t'2)
            (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                            cc_default))
            ((Econst_int (Int.repr 10) tint) :: nil))
          (Sset _q (Etempvar _t'2 (tptr tvoid))))
        (Ssequence
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default)) ((Etempvar _p (tptr tvoid)) :: nil))
          (Ssequence
            (Scall None
              (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                            cc_default)) ((Etempvar _q (tptr tvoid)) :: nil))
            (Ssequence
              (Ssequence
                (Scall (Some _t'3)
                  (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                  cc_default))
                  ((Econst_int (Int.repr 100) tint) :: nil))
                (Sset _p (Etempvar _t'3 (tptr tvoid))))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'4)
                    (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                    cc_default))
                    ((Econst_int (Int.repr 10) tint) :: nil))
                  (Sset _q (Etempvar _t'4 (tptr tvoid))))
                (Ssequence
                  (Scall None
                    (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                  cc_default))
                    ((Etempvar _p (tptr tvoid)) :: nil))
                  (Ssequence
                    (Scall None
                      (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                    cc_default))
                      ((Etempvar _q (tptr tvoid)) :: nil))
                    (Sreturn (Some (Econst_int (Int.repr 0) tint))))))))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
nil.

Definition prog : Clight.program := {|
prog_defs :=
((___stringlit_2, Gvar v___stringlit_2) ::
 (___stringlit_4, Gvar v___stringlit_4) ::
 (___stringlit_3, Gvar v___stringlit_3) ::
 (___stringlit_5, Gvar v___stringlit_5) ::
 (___stringlit_1, Gvar v___stringlit_1) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_smulh,
   Gfun(External (EF_runtime "__i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umulh,
   Gfun(External (EF_runtime "__i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_abort,
   Gfun(External (EF_external "abort" (mksignature nil None cc_default)) Tnil
     tvoid cc_default)) ::
 (_printf,
   Gfun(External (EF_external "printf"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint)
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tint
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_sbrk,
   Gfun(External (EF_external "sbrk"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_bin2size, Gfun(Internal f_bin2size)) ::
 (_size2bin, Gfun(Internal f_size2bin)) ::
 (_testclaim, Gfun(Internal f_testclaim)) :: (_bin, Gvar v_bin) ::
 (_fill_bin, Gfun(Internal f_fill_bin)) ::
 (_malloc_small, Gfun(Internal f_malloc_small)) ::
 (_free_small, Gfun(Internal f_free_small)) ::
 (_free, Gfun(Internal f_free)) :: (_malloc, Gfun(Internal f_malloc)) ::
 (_main, Gfun(Internal f_main)) :: nil);
prog_public :=
(_main :: _malloc :: _free :: _free_small :: _malloc_small :: _fill_bin ::
 _size2bin :: _sbrk :: _printf :: _abort :: ___builtin_debug ::
 ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_fsqrt :: ___builtin_ctzll ::
 ___builtin_ctzl :: ___builtin_ctz :: ___builtin_clzll :: ___builtin_clzl ::
 ___builtin_clz :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap64 :: ___builtin_bswap :: ___i64_umulh :: ___i64_smulh ::
 ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod :: ___i64_smod ::
 ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof :: ___i64_utod ::
 ___i64_stod :: ___i64_dtou :: ___i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)

Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.

Local Open Scope Z.

Local Open Scope logic.  



Definition WORD: Z := 4. 

Definition ALIGN: Z := 2.

Definition BINS: Z := 8. 

Parameter BIGBLOCK: Z.

Parameter BIGBLOCK_def: 

  Int.repr BIGBLOCK = Int.mul (Int.shl (Int.repr 2) (Int.repr 16)) (Int.repr WORD).



Definition bin2sizeZ := fun b: Z => (Z.mul ((Z.mul (b+1) ALIGN)-1) WORD).



Definition size2binZ : Z -> Z := fun s => 

   if zlt (bin2sizeZ(BINS-1)) s then -1 

   else (s+(Z.mul WORD (ALIGN-1))-1) / (Z.mul WORD ALIGN).



Eval compute in bin2sizeZ (BINS-1).

Example bin2sizeBINS: bin2sizeZ (BINS-1) = 60. Proof. reflexivity. Qed.



Lemma claim1: forall s,

0 <= s <= bin2sizeZ(BINS-1) -> s <= bin2sizeZ(size2binZ s).

Proof. intros. 

unfold bin2sizeZ in *.

unfold size2binZ in *.

simpl in *.

assert (H1: bin2sizeZ 7 = 60). { apply bin2sizeBINS. }

rewrite H1.

unfold ALIGN, WORD.

destruct (zlt 60 s).

- simpl. omega.

- simpl.  auto with arith.



admit.

Admitted.



Lemma claim2: forall s, 

0 <= s <= bin2sizeZ(BINS-1) -> 0 <= size2binZ s < BINS.



Lemma claim3: forall s, 0 <= s <= bin2sizeZ(BINS-1) 

    -> size2binZ(bin2sizeZ(size2binZ(s))) = size2binZ(s).



Lemma claim4: forall b,

0 <= b < BINS -> Z.rem (bin2sizeZ b + WORD) (Z.mul WORD ALIGN) = 0.



Lemma claim5: forall b, 

0 <= b < BINS -> size2binZ(bin2sizeZ(b)) = b.

Proof.

  intros. 

  unfold size2binZ.

  assert (H1: (bin2sizeZ (BINS - 1) >= (bin2sizeZ b))) 

    by ( unfold bin2sizeZ; unfold WORD, ALIGN, BINS in *; omega).

  destruct (zlt (bin2sizeZ (BINS - 1)) (bin2sizeZ b)) as [H2|H2]. contradiction.

  unfold bin2sizeZ. 

  clear H H1 H2.

  assert (H3: 

     (((b + 1) * ALIGN - 1) * WORD + WORD * (ALIGN - 1) - 1) / (WORD * ALIGN)

     = (b*ALIGN*WORD + 2*ALIGN*WORD - 2*WORD -1)/(WORD*ALIGN)).

     { admit.  }

  rewrite H3; clear H3. unfold WORD, ALIGN, BINS. simpl.

  admit. 

Admitted.



Definition sbrk_spec := 



   DECLARE _sbrk

   WITH n:Z

   PRE [ 1%positive OF tuint ]

       PROP (0 <= n <= Int.max_unsigned)

       LOCAL (temp 1%positive (Vint (Int.repr n)))

       SEP ()

    POST [ tptr tvoid ] EX p:_,

       PROP ()

       LOCAL (temp ret_temp p)

       SEP ( 

             memory_block Tsh n p).



Definition bin2size_spec :=

 DECLARE _bin2size

  WITH b: Z

  PRE [ _b OF tint ] 

     PROP( 0 <= b <= Int.max_signed ) 

     LOCAL (temp _b (Vint (Int.repr b))) SEP ()

  POST [ tuint ] 

     PROP() LOCAL(temp ret_temp (Vint (Int.repr (bin2sizeZ b)))) SEP ().



Definition size2bin_spec :=

 DECLARE _size2bin

  WITH s: Z

  PRE [ _s OF tuint ]    

     PROP( 0 <= s <= Int.max_unsigned ) 

     LOCAL (temp _s (Vint (Int.repr s))) SEP ()

  POST [ tint ]

     PROP() LOCAL(temp ret_temp (Vint (Int.repr (size2binZ s)))) SEP ().



Definition malloc_token' (sh: share) (n: Z) (p: val): mpred := 

   data_at Tsh tuint (offset_val (- WORD) p) (Vint (Int.repr n)) 

 * memory_block Tsh ((bin2sizeZ(size2binZ(n)) - n)) (offset_val n p).



Lemma malloc_token'_valid_pointer:

  forall sh n p, malloc_token' sh n p |-- valid_pointer p.



Lemma malloc_token'_precise:

  forall sh n p, predicates_sl.precise (malloc_token' sh n p).



Fixpoint mmlist (sz: Z) (len: nat) (p: val) (r: val): mpred :=

 match len with

 | O => !! (ptr_eq p r) && emp

 | (S n) => EX q:val, !! is_pointer_or_null q && 

            data_at Tsh tuint (offset_val (-WORD) p) (Vint(Int.repr sz))

          * data_at Tsh (tptr tvoid) p q

          * memory_block Tsh (sz - WORD) (offset_val WORD p)

          * mmlist sz n q r

 end.



Definition mm_inv (arr: val): mpred := 

  EX bins: list val, EX lens: list nat,

  !! (Zlength bins = BINS /\ Zlength lens = BINS)  &&

  data_at Tsh (tarray (tptr tvoid) BINS) bins arr

  * fold_right (fun (i: nat) => fun (mp: mpred) => 

     (mmlist (bin2sizeZ (Z.of_nat i)) (nth i lens O) (nth i bins nullval) nullval) * mp )

    emp 

    (seq 0 (Z.to_nat BINS)).



Definition malloc_spec'' := 

   DECLARE _malloc

   WITH n:Z, bin:val

   PRE [ 1%positive OF tuint ]

       PROP (0 <= n <= Int.max_unsigned)

       LOCAL (temp 1%positive (Vint (Int.repr n)); gvar _bin bin)

       SEP ( mm_inv bin )

    POST [ tptr tvoid ] EX p:_,

       PROP ()

       LOCAL (temp ret_temp p)

       SEP ( mm_inv bin;

             if eq_dec p nullval then emp

             else (malloc_token Tsh n p * memory_block Tsh n p)).



Definition free_spec'' := 

   DECLARE _free

   WITH p:_, n:_, bin:_

   PRE [ 1%positive OF tptr tvoid ]

       PROP ()

       LOCAL (temp 1%positive p; gvar _bin bin)

       SEP (malloc_token Tsh n p; memory_block Tsh n p; mm_inv bin)

    POST [ Tvoid ]

       PROP ()

       LOCAL ()

       SEP (mm_inv bin).



Definition malloc_small_spec :=

   DECLARE _malloc_small

   WITH n:Z, bin:_

   PRE [ 1%positive OF tuint ]

       PROP (0 <= n <= bin2sizeZ(BINS-1))

       LOCAL (temp 1%positive (Vint (Int.repr n)); gvar _bin bin)

       SEP ( mm_inv bin )

    POST [ tptr tvoid ] EX p:_,

       PROP ()

       LOCAL (temp ret_temp p)

       SEP ( mm_inv bin; 

            if eq_dec p nullval then emp

            else (malloc_token' Tsh n p * memory_block Tsh n p)).



Definition free_small_spec :=

   DECLARE _free_small

   WITH p:_, n:_, s:_

   PRE [ 1%positive OF tptr tvoid, 2%positive OF tint ]

       PROP ( n = s )

       LOCAL (temp 1%positive p; temp 2%positive (Vint (Int.repr s)))

       SEP (malloc_token' Tsh n p; memory_block Tsh n p)

    POST [ tvoid ]

       PROP ()

       LOCAL ()

       SEP ().



Definition fill_bin_spec :=

 DECLARE _fill_bin

  WITH b: _

  PRE [ _b OF tint ]

     PROP(0 <= b < BINS) LOCAL (temp _b (Vint (Int.repr b))) SEP ()

  POST [ (tptr tvoid) ] EX p:_, EX len:Z,

     PROP( len > 0 ) 

     LOCAL(temp ret_temp p)

     SEP ( mmlist (bin2sizeZ b) (Z.to_nat len) p nullval ).



Definition main_spec :=

 DECLARE _main

  WITH u : unit

  PRE  [] main_pre prog nil u

  POST [ tint ]  main_post prog nil u.



Definition Gprog : funspecs := 

 ltac:(with_library prog [ 

   sbrk_spec; bin2size_spec; size2bin_spec; fill_bin_spec;

   malloc_small_spec; free_small_spec; malloc_spec''; free_spec'';

   main_spec]).



Lemma body_bin2size: semax_body Vprog Gprog f_bin2size bin2size_spec.

Proof. start_function. forward. Qed.



Lemma body_size2bin: semax_body Vprog Gprog f_size2bin size2bin_spec.

Proof. start_function. 

forward_call (BINS-1). 

assert (BINS - 1 <= Int.max_signed ). {  admit.  } 

split. unfold BINS. omega.  assumption.

forward_if(PROP() LOCAL() SEP (FF)). 

-  

forward. entailer!.  f_equal. rewrite Int.neg_repr.

assert (H1: size2binZ s = -1). {  

  unfold size2binZ; simpl. destruct (zlt (bin2sizeZ 7)). reflexivity. contradiction. }

rewrite -> H1. reflexivity.

- 

forward.  entailer!. f_equal.

assert (H1: Int.divu (Int.repr (s + (4 - 1))) (Int.repr (4 * 2)) = Int.repr (size2binZ s) ).

   { admit. } 

rewrite -> H1. reflexivity.

- 

intros.  unfold overridePost. if_tac.

go_lowerx.

entailer.

apply ENTAIL_refl.



Admitted.



Definition fill_bin_dummy (b:Z) (p:val) (qNs:val*Z*Z) := 

  PROP(True)LOCAL(temp _q (let '(q, _, _) := qNs in q);

         temp _p p; 

         temp _s (Vint (Int.repr (let '(_,_,s) := qNs in s))); 

         temp _b (Vint (Int.repr b)))

  SEP().



Definition fill_bin_Inv (b:Z) (p:val) (qNs:val*Z*Z) := 



  PROPx (let '(q,N,s) := qNs in 

        [s = bin2sizeZ b; 0 <= N; s + N*(WORD+s) <= BIGBLOCK])

  (LOCALx ([temp _q (let '(q,N,s):=qNs in q);

         temp _p p; 

         temp _s (Vint (Int.repr (let '(q,N,s):=qNs in s))); 

         temp _b (Vint (Int.repr b))])

  (SEPx ( let '(q,N,s):=qNs in

         [mmlist s (Z.to_nat N) (offset_val s p) q;

          memory_block Tsh (BIGBLOCK-(s+N*(WORD+s))) q] ))).



Definition fill_bin_preIncr (b:Z) (p:val) (qNs:val*Z*Z) :=



  PROP ( let '(q,N,s) := qNs in 

         s = bin2sizeZ b /\ 0 <= N /\ s + N*(WORD+s) <= BIGBLOCK )

  LOCAL (temp _q (let '(q,_,_) := qNs in q);

         temp _p p; 

         temp _s (Vint (Int.repr (let '(_,_,s) := qNs in s))); 

         temp _b (Vint (Int.repr b)))

  SEP (  let '(q,N,s) := qNs in 

         mmlist s (Z.to_nat N) (offset_val s p) q 

         * memory_block Tsh (BIGBLOCK - (s+N*(WORD+s)) - (WORD+s)) (offset_val (WORD+s) q) 

         * data_at Tsh tuint (Vint (Int.repr s)) q 

         * data_at Tsh (tptr tvoid) (offset_val (WORD+s) q) (offset_val WORD q) 

         * memory_block Tsh (s-WORD-WORD) (offset_val (WORD+WORD) q)  ).



Lemma body_fill_bin: semax_body Vprog Gprog f_fill_bin fill_bin_spec.

Proof. 

start_function. 

forward_call (b). 

- unfold BINS in H.  admit.

- forward_call (BIGBLOCK).

  * entailer!. repeat f_equal. rewrite -> BIGBLOCK_def. auto.

  *  admit.

  * Intros p.

  

  check_Delta;

  repeat simple apply seq_assoc1;

  lazymatch type of (fill_bin_Inv b p) with

  | _ -> environ -> mpred => idtac

  | _ => fail "Invariant (first argument to forward_for) must have type (_ -> environ -> mpred)"

  end;

  lazymatch type of (fill_bin_preIncr b p) with

  | _ -> environ -> mpred => idtac

  | _ => fail "PreInc (second argument to forward_for) must have type (_ -> environ -> mpred)"

  end.

apply -> seq_assoc;

      apply semax_seq' with (exp (fill_bin_Inv b p)); abbreviate_semax.

      Focus 2.

      eapply semax_seq.



repeat  match goal with P := @abbreviate ret_assert _ |- semax _ _ _ ?P' =>

                         constr_eq P P'; unfold abbreviate in P; subst P

           end.

 match goal with |- semax _ _ (Sloop (Ssequence (Sifthenelse _ Sskip Sbreak) ?body) _) _ =>

   (tryif unify (no_breaks body) true 

          then idtac

      else fail "Since there is a break in the loop body, you need to supply an explicit postcondition using the 3-argument form of forward_for.");

   eapply semax_for_3g2 with (PQR:=(fill_bin_preIncr b p)) 


  end.

  reflexivity.

  intro.

  admit.

  intro.

  match goal with |- ENTAIL ?Delta, ?Pre |-- local (`(eq _) (eval_expr ?e)) =>

            do_compute_expr1 Delta Pre e end.

            match goal with v := _ : val , H: ENTAIL _ , _ |-- _ |- _ => subst v; apply H end

          end.

        forward_for2 (fill_bin_Inv b p) (fill_bin_preIncr b p) .

      

      [  | eapply semax_seq; 

         [ forward_for2 (fill_bin_Inv b p) (fill_bin_preIncr b p) 

          | abbreviate_semax;

            apply extract_exists_pre; intro;

            let HRE := fresh in 

            apply semax_extract_PROP; intro HRE; 

            repeat (apply semax_extract_PROP; fancy_intro true);

            do_repr_inj HRE]

   ].

     lazymatch goal with

  | |- semax _ _ (Ssequence (Sfor _ _ _ _) _) _ =>

      apply -> seq_assoc;

      apply semax_seq' with (exp (fill_bin_Inv b p)); abbreviate_semax;

      [  | eapply semax_seq; 

         [ forward_for2 (fill_bin_Inv b p) (fill_bin_preIncr b p) 

          | abbreviate_semax;

            apply extract_exists_pre; intro;

            let HRE := fresh in 

            apply semax_extract_PROP; intro HRE; 

            repeat (apply semax_extract_PROP; fancy_intro true);

            do_repr_inj HRE]

   ]

  | |- semax _ _ (Sfor _ _ _ _) ?Post =>

      apply semax_seq' with (exp (fill_bin_Inv b p)); abbreviate_semax; idtac "Hi"



  | |- semax _ _ (Sloop (Ssequence (Sifthenelse _ Sskip Sbreak) _) _) ?Post =>

     apply semax_pre with (exp (fill_bin_Inv b p));

      [  | forward_for3 (fill_bin_Inv b p) (fill_bin_preIncr b p) Post]

  | |- semax _ _ (Sloop (Ssequence (Sifthenelse _ Sskip Sbreak) _) _) _ =>

     apply semax_pre with (exp (fill_bin_Inv b p));

      [ unfold_function_derives_right | forward_for2 (fill_bin_Inv b p) (fill_bin_preIncr b p) ]

  | |- _ => fail "forward_for2x cannot recognize the loop"

  end.

  

    forward_for (fill_bin_Inv b p) (fill_bin_preIncr b p).  

    + 

      forward.

      Exists (p, 0, (bin2sizeZ b)).

      entailer!.  unfold fill_bin_Inv. unfold mmlist. simpl.   admit.

    +  entailer!.  ++ admit. ++ admit.

    + 

      Intros. 

      

admit.

    +  admit.

    + 

      Intros.

      forward.



Admitted.



Lemma body_malloc_small:  semax_body Vprog Gprog f_malloc_small malloc_small_spec.

Proof. 

start_function. 

freeze [0] MMinv.

forward_call (n).



Lemma body_free_small:  semax_body Vprog Gprog f_free_small free_small_spec.



Lemma body_main:  semax_body Vprog Gprog f_main main_spec.



Lemma prog_correct:

  semax_prog prog Vprog Gprog.

Proof.

prove_semax_prog.

semax_func_cons body_size2bin.

semax_func_cons body_bin2size.

semax_func_cons body_fill_bin.

semax_func_cons body_malloc_small.

semax_func_cons body_free_small.

semax_func_cons body_malloc.

semax_func_cons body_free.

semax_func_cons body_main.

Qed.



