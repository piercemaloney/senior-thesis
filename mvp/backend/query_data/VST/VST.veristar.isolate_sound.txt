Load loadpath.

Require Import Coq.Lists.List.

Require Import veristar.variables veristar.datatypes veristar.list_denote.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.list_denote:
Load loadpath.
Require Import Coq.Lists.List Permutation veric.Coqlib2.
Require Import VST.msl.Axioms msl.sepalg VST.msl.predicates_sa msl.base
               veristar.variables veristar.datatypes
               veristar.clauses veristar.basic veristar.compare.

Section ListDenote.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Fixpoint list_denote l : T :=
  match l with nil => b | x :: l' => g (f x) (list_denote l')
  end.

Local Notation "'listd'" := (list_denote).

Lemma listd_fold_right l :
  listd l = fold_right (fun x y  => g (f x) y) b l.

End ListDenote.

Notation "'listd'" := (list_denote).

Lemma listd_app {A T} f g (b : T) (l l' : list A) :
  listd f g b (l ++ l') =
  listd f g (listd f g b l') l.

Section ListDenoteLems.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Lemma listd_nil : listd f g b nil = b.

Lemma listd_cons a l :
  listd f g b (a :: l) = g (f a) (listd f g b l).

Lemma listd_map h l (Hgh_eq : forall a b', g (f (h a)) b' = g (f a) b') :
  listd f g b (map h l) = listd f g b l.

Lemma listd_filter h l (H : forall a b', false=h a -> g (f a) b' = b') :
  listd f g b (filter h l) = listd f g b l.

Lemma listd_flat_map h l (H : forall a b', g (f a) b' = listd f g b' (h a)) :
  listd f g b l = listd f g b (flat_map h l).

Lemma listd_compose h1 h2 l
  (Hh1 : forall l, listd f g b l = listd f g b (h1 l))
  (Hh2 : forall l, listd f g b l = listd f g b (h2 l)) :
  listd f g b l = listd f g b ((h1 oo h2) l).

End ListDenoteLems.

Section ListDenoteAS.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma fgAS b' (t t' : T) : g t (g t' b') = g t' (g t b').

Lemma listdAS a l : listd f g (g (f a) b) l = g (f a) (listd f g b l).

Lemma listd_AS_unit un l (un_unit : forall x, g x un = x) :
  listd f g b l = g b (listd f g un l).

Lemma listd_perm l l' (Hperm : Permutation l l') :
  listd f g b l = listd f g b l'.

End ListDenoteAS.

Section ListDenoteConj.
Context {A : Type}.
Variables (f : A -> Prop) (g : Prop -> Prop -> Prop) (b : Prop).
Variable (gconj : forall x y, g x y -> y).

Lemma listd_conj a l : listd f g b (a :: l) -> listd f g b l.

Context {B : Type}.
Variables (h : A -> pred B) (k : pred B -> pred B -> pred B) (b0 : pred B).
Variable (hconj : forall x y b, k x y b -> y b).

Lemma listd_conjP a l : forall b, listd h k b0 (a :: l) b -> listd h k b0 l b.

End ListDenoteConj.

Section ListDenoteProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).

Lemma andS (x y : Prop) : and x y = and y x.

Lemma andA x y z : and x (and y z) = and (and x y) z.

Lemma orS (x y : Prop) : or x y = or y x.

Lemma orA x y z : or x (or y z) = or (or x y) z.

Lemma listd_conj_and a l : listd f and True (a :: l) -> listd f and True l.

Lemma listd_unfold_and l : listd f and b l = (listd f and True l /\ b).

Lemma listd_unfold_or l : listd f or b l = (listd f or False l \/ b).

Lemma listd_flat_map_and h l
  (H : forall a b', and (f a) b' -> listd f and b' (h a)) :
  listd f and b l -> listd f and b (flat_map h l).

Lemma listd_In_prop l : (forall a, In a l -> f a) -> listd f and True l.

Lemma listd_In_inv_prop a l : listd f and True l -> In a l -> f a.

End ListDenoteProp.

Section ListDenoteProp1.
Context {A : Type}.
Variables (f : A -> Prop).

Lemma listd_unfold_app_and b l l' :
  listd f and b (l ++ l') = (listd f and True l /\ listd f and b l').

Lemma listd_unfold_app_or b l l' :
  listd f or b (l ++ l') = (listd f or False l \/ listd f or b l').

End ListDenoteProp1.

Lemma union_com {A} : forall (P Q: pred A), ((P || Q) = (Q || P))%pred.

Lemma union_assoc {A} : forall (P Q R: pred A),
  ((P || Q) || R = P || (Q || R))%pred.

Notation "'inter'" := (@andp _).
Notation "'un'" := (@orp _).

Section ListDenotePred.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).

Lemma listd_conj_inter a l :
  forall b', listd f inter TT (a :: l) b' -> listd f inter TT l b'.

Lemma listd_unfold_inter l : listd f inter b l = (listd f inter TT l && b)%pred.

Lemma listd_unfold_un l : listd f un b l = (listd f un FF l || b)%pred.

Lemma listd_flat_map_inter h l s
  (H : forall a b', inter (f a) b' s -> listd f inter b' (h a) s) :
  listd f inter b l s -> listd f inter b (flat_map h l) s.

Lemma listd_In_pred l s :
  (forall a, In a l -> f a s) -> b s -> listd f inter b l s.

Lemma listd_In_inv_pred a l s : listd f inter TT l s -> In a l -> f a s.

Lemma listd_In_pred_un l s :
  (exists a, In a l /\ f a s) \/ b s -> listd f un b l s.

Lemma listd_In_inv_pred_un l s :
  listd f un b l s -> (exists a, In a l /\ f a s) \/ b s.

Lemma listd_map_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> g (h a) s) :
  listd f inter TT l s -> listd g inter TT (map h l) s.

Lemma listd_omapl_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> match h a with Some a' => g a' s | None => True end) :
  listd f inter TT l s -> listd g inter TT (omapl h l) s.

Lemma listd_foldr_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h a x) s) :
  f c0 s -> listd f inter TT l s -> f (fold_right h c0 l) s.

Lemma listd_foldl_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h x a) s) :
  f c0 s -> listd f inter TT l s -> f (fold_left h l c0) s.

Lemma listd_filter_pred h l s :
  listd f inter TT l s -> listd f inter TT (filter h l) s.

Lemma listd_partition_pred h l xs ys s (H : partition h l = (xs, ys)) :
  listd f inter TT l s ->
    listd f inter TT xs s /\ listd f inter TT ys s.

End ListDenotePred.

Section ListDenotePred1.
Context {A B : Type}.
Variables (f : A -> pred B).

Lemma listd_unfold_app_inter b l l' :
  listd f inter b (l ++ l') = (listd f inter TT l && listd f inter b l')%pred.

Lemma listd_unfold_app_un b l l' :
  listd f un b (l ++ l') = (listd f un FF l || listd f un b l')%pred.

End ListDenotePred1.

Section ListDenoteInsert.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma listd_insert cmp a l :
  listd f g b (insert cmp a l) = g (f a) (listd f g b l).

Lemma listd_sort cmp l : listd f g b (rsort cmp l) = listd f g b l.

End ListDenoteInsert.

Section ListDenoteInsertUniq.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y ->
  forall b, g (f x) (g (f y) b) = g (f y) b).

Lemma listd_insert_uniq a l :
  listd f g b (insert_uniq cmp a l) = g (f a) (list_denote f g b l).

Lemma listd_sort_uniq l : listd f g b (rsort_uniq cmp l) = listd f g b l.

End ListDenoteInsertUniq.

Section ListDenoteSortProp.
Context {A : Type}.
Variable (f : A -> Prop) (b : Prop).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_and cmp a l :
  listd f and b (insert cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_and cmp l :
  listd f and b (rsort cmp l) = listd f and b l.

Lemma listd_insert_or cmp a l :
  listd f or b (insert cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_or cmp l :
  listd f or b (rsort cmp l) = listd f or b l.

End ListDenoteSortProp.

Section ListDenoteInsertPred.

Context {A B : Type}.
Variable (f : A -> pred B) (b : pred B).

Lemma interS (x y : pred B) : inter x y = inter y x.

Lemma interA (x y z : pred B) : inter x (inter y z) = inter (inter x y) z.

Lemma unS (x y : pred B) : un x y = un y x.

Lemma unA (x y z : pred B) : un x (un y z) = un (un x y) z.

Variables (JB: Join B) (PB: Perm_alg B)(SB: Sep_alg B).

Lemma sepconS (x y : pred B) : sepcon x y = sepcon y x.

Lemma sepconA (x y z : pred B) :
  sepcon x (sepcon y z) = sepcon (sepcon x y) z.

Local Hint Resolve interS interA unS unA sepconS sepconA.

Lemma listd_insert_inter cmp a l :
  listd f inter b (insert cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_inter cmp l :
  listd f inter b (rsort cmp l) = listd f inter b l.

Lemma listd_insert_un cmp a l :
  listd f un b (insert cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_un cmp l : listd f un b (rsort cmp l) = listd f un b l.

Lemma listd_insert_sepcon cmp a l :
  listd f sepcon b (insert cmp a l) = sepcon (f a) (listd f sepcon b l).

Lemma listd_sort_sepcon cmp l :
  listd f sepcon b (rsort cmp l) = listd f sepcon b l.

End ListDenoteInsertPred.

Section ListDenoteSortUniqProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_uniq_and a l :
  listd f and b (insert_uniq cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_uniq_and l :
  listd f and b (rsort_uniq cmp l) = listd f and b l.

Lemma listd_insert_uniq_or a l :
  listd f or b (insert_uniq cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_uniq_or l :
  listd f or b (rsort_uniq cmp l) = listd f or b l.

End ListDenoteSortUniqProp.

Section ListDenoteSortUniqPreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve (@interS B) (@interA B) (@unS B) (@unA B).

Lemma listd_insert_uniq_inter a l :
  listd f inter b (insert_uniq cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_uniq_inter l :
  listd f inter b (rsort_uniq cmp l) = listd f inter b l.

Lemma listd_insert_uniq_un a l :
  listd f un b (insert_uniq cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_uniq_un l :
  listd f un b (rsort_uniq cmp l) = listd f un b l.

End ListDenoteSortUniqPreds.

Section ListDenoteMergePreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Lemma listd_merge_inter l1 l2 s :
  listd f inter TT l1 s -> listd f inter TT l2 s ->
  listd f inter TT (merge cmp l1 l2) s.

Lemma merge_nil l : merge cmp l nil = l.

Lemma merge_nil' l : merge cmp nil l = l.

Lemma merge_cons_unfold a1 a2 l1 l2 :
  merge cmp (a1 :: l1) (a2 :: l2) = match cmp a1 a2 with
                                      | Eq => a1 :: merge cmp l1 l2
                                      | Gt => a1 :: merge cmp l1 (a2 :: l2)
                                      | Lt => a2 :: merge cmp (a1 :: l1) l2
                                    end.

Lemma merge_elems a l1 l2 : In a l1 \/ In a l2 <-> In a (merge cmp l1 l2).

Lemma listd_merge_inter' l1 l2 s :
  listd f inter TT (merge cmp l1 l2) s ->
  listd f inter TT l1 s /\ listd f inter TT l2 s.

Lemma listd_merge_un1 l1 l2 s :
  listd f un FF l1 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un2 l1 l2 s :
  listd f un FF l2 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un' l1 l2 s :
  listd f un FF (merge cmp l1 l2) s ->
  listd f un FF l1 s \/ listd f un FF l2 s.

End ListDenoteMergePreds.

Section ListDenoteSeparate.
Context {X Y B : Type}.
Variables (f : X -> pred B) (g : Y -> pred B) (b : pred B) (l1 : list X)
          (l2 : list Y).

Lemma listd_separate :
  listd f inter (listd g inter b l2) l1 =
  andp (listd f inter TT l1) (andp (listd g inter TT l2) b).

Lemma listd_prop:
listd f inter b l1 =
(andp (listd f inter TT l1) b).

End ListDenoteSeparate.

Section SetDenote.

Definition setd {T} (f : M.elt -> T) (g : T -> T -> T) (b : T) (s : M.t) :=
  listd f g b (M.elements s).

End SetDenote.

Section SetLems.
Variables (s : M.t) (x y : clause).

Lemma setd_add_In_refl : M.In x (M.add x s).

Lemma setd_add_In_refl_elems : In x (M.elements (M.add x s)).

Lemma setd_add_In : x = y \/ M.In y s -> M.In y (M.add x s).

Lemma setd_add_In_inv : M.In y (M.add x s) -> x = y \/ M.In y s.

Lemma elements_In {s0} : In y (M.elements s0) = M.In y s0.

Lemma empty_set_elems : M.elements M.empty = nil. 

Lemma setd_add_In_inv_elems :
  In y (M.elements (M.add x s)) -> x = y \/ M.In y s.

Lemma setd_rem_In_inv : M.In y (M.remove x s) -> M.In y s.

Lemma setd_rem_In_inv_elems :
  In y (M.elements (M.remove x s)) -> In y (M.elements s).

End SetLems.

Section SetDenoteLems.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : M.t -> clause -> M.t).
Variable (H : forall c cls s, setd f inter b cls s -> f c s ->
                              setd f inter b (h cls c) s).

Lemma setd_fold_left cls0 l s :
  listd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (fold_left h l cls0) s.

Lemma setd_fold cls0 l s :
  setd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (M.fold (Basics.flip h) cls0 l) s.

Lemma setd_un cls1 cls2 s :
  setd f inter TT cls1 s -> setd f inter TT cls2 s ->
  setd f inter TT (M.union cls1 cls2) s.

Lemma setd_base_separate:
   forall {A} f (b: pred A) cls,
    setd f inter b cls = andp b (setd f inter (@TT A) cls).

Lemma setd_add c cls s :
  setd f inter b cls s -> f c s -> setd f inter b (M.add c cls) s.

Lemma setd_remove c cls s :
  setd f inter TT cls s -> setd f inter TT (M.remove c cls) s.

Lemma setd_empty_set s : setd f inter TT M.empty s.

Require Import MSetFacts Logic.

Lemma setd_filter bf cls s :
  setd f inter TT cls s -> setd f inter TT (M.filter bf cls) s.

End SetDenoteLems.

Section FoldLem.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).

Lemma listd_fold_left cls0 l s
  (H : forall c cls, listd f inter b cls s -> f c s ->
                     listd f inter b (h cls c) s) :
  listd f inter b l s -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLem.

Section FoldLemWeak.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).
Variable (H : forall c cls s, listd f inter b cls s -> (forall s, f c s) ->
                              listd f inter b (h cls c) s).

Lemma listd_fold_left_wk cls0 l s :
  listd (fun c => forall s, f c s) and True l -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLemWeak.

Lemma listd_inter_map: forall {A B C} (l:list A) (f:B -> C -> Prop) h s,
(forall x, In x l -> f (h x) s) ->
inter
  (listd f inter TT (map h l)) TT s.

Lemma listd_inter_rev: forall {A B} (f: A -> B -> Prop) l,
  listd f inter TT (rev  l) = listd f inter TT l.

Lemma orp_FF {A} (p : pred A) : orp p FF = p.

Lemma listd_un_rev:
  forall {A B} (f: A -> B -> Prop) l, listd f un FF (rev  l) = listd f un FF l.

Lemma setd_filter_pred:
  forall {B: Type} (f: M.elt -> pred B) (h: M.elt -> bool) (s: M.t), *)

Require Import compcert.Coqlib.

Require Import VST.veric.Coqlib2.

Require Import VST.msl.predicates_sa.
(* VST.msl.predicates_sa:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.

Require Import Coq.funind.Recdef.
Require Coq.Wellfounded.Wellfounded. 
Delimit Scope pred with pred.
Local Open Scope pred.

Definition pred (A:Type) := A -> Prop.
Bind Scope pred with pred.

Definition derives (A:Type) (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] _ _.

Lemma pred_ext : forall A (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma derives_cut {A}  : forall Q P R : pred A,
  derives P Q ->
  derives Q R ->
  derives P R.

Definition prop {A: Type}  (P: Prop) : pred A := (fun _  => P).
Hint Unfold prop.

Definition TT {A}: pred A := prop True.
Definition FF  {A}: pred A := prop False.

Set Implicit Arguments.

Definition imp {A}  (P Q:pred A) :=
   fun a:A => P a -> Q a.
Definition orp {A} (P Q:pred A) :=
   fun a:A => P a \/ Q a.
Definition andp {A} (P Q:pred A) :=
   fun a:A => P a /\ Q a.

Definition allp {A B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.
Definition exp {A B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Notation "'emp'" := identity.

Definition sepcon {A} {JA: Join A}(p q:pred A) := fun z:A =>
  exists x:A, exists y:A, join x y z /\ p x /\ q y.
Definition wand {A}  {JA: Join A}  (p q:pred A) := fun y =>
  forall x z, join x y z -> p x -> q z.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.
Notation "P '*' Q" := (sepcon P Q) : pred.
Notation "P '-*' Q" := (wand P Q) (at level 60, right associativity) : pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Definition precise {A}  {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall w w1 w2, P w1 -> P w2 -> join_sub w1 w -> join_sub w2 w -> w1=w2.

Definition precise2  {A} {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma precise_eq {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     precise =
                 fun P : pred A => forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma derives_precise {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q, (P |-- Q) -> precise Q -> precise P.

Lemma prop_true_and:
  forall (P: Prop) A (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_andp_e {A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A}:  forall P Q (w:A), P /\ Q w -> (!! P && Q) w.

Lemma derives_trans {A}:  forall (P Q R: pred A), P |-- Q -> Q |-- R -> P |-- R.

Lemma and_i {A}: forall (P Q R: pred A),
    P |-- Q -> P |-- R -> P |-- Q && R.

Lemma andp_derives {A}  :
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q r, (((p * q) * r) = (p * (q * r))).

Lemma sepcon_comm {A} {JA: Join A}{PA: Perm_alg A}:  forall (P Q: pred A) , P * Q = Q * P.

Lemma sepcon_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall P, (P * emp) = P.

Lemma emp_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, (emp*P) = P.

Lemma precise_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     precise emp.

Definition exactly {A} (x: A) : pred A := fun w => w=x.

Lemma join_exactly {A} {JA: Join A}{PA: Perm_alg A}:
  forall w1 w2 w3, join w1 w2 w3 -> exactly w1 * exactly w2 = exactly w3.

Lemma exists_and1 {A: Type} : forall {T: Type} (P: T -> pred A) (Q: pred A),
                   exp P && Q = EX x:T, P x && Q.

Lemma andp_comm {A: Type}: forall (P Q: pred A), P && Q = Q && P.

Lemma andp_assoc {A}: forall (P Q R: pred A),
                 ((P && Q) && R = P && (Q && R)).

Lemma True_andp_eq {A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma TT_i  {A} : forall w: A,  TT w.

Hint Resolve @TT_i.

Lemma TT_and {A}: forall (Q: pred A), TT && Q = Q.

Lemma andp_TT {A}: forall (P: pred A), P && TT = P.

Lemma emp_wand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, emp -* P = P.

Lemma wand_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall P P' Q Q',  P' |-- P -> Q |-- Q' -> P -* Q |-- P' -* Q'.

Lemma TT_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: TT * TT = TT.

Definition ewand {A} {JA: Join A} (P Q: pred A) : pred A :=
  fun w => exists w1, exists w2, join w1 w w2 /\ P w1 /\ Q w2.

Lemma emp_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:  forall P, ewand emp P = P.

Lemma exists_sepcon1 {A} {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  exp P * Q = exp (fun x => P x * Q).

Lemma derives_refl {A: Type}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma derives_TT {A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma sepcon_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q p' q', (p |-- p') -> (q |-- q') -> (p * q |-- p' * q').

Lemma derives_e {A: Type}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Lemma exp_derives {A} :
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma unmodus_wand {A}  {JA: Join A}{PA: Perm_alg A}:
 forall P Q R, Q = P * R ->  Q |-- P * (P -* Q).

Definition superprecise {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} (P: pred A) :=
   forall w1 w2, P w1 -> P w2 -> comparable w1 w2 -> w1=w2.

Lemma modus_ewand {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} :  forall P Q, superprecise P -> P * (ewand P Q) |-- Q.

Lemma exists_expand_sepcon {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B (p: B -> pred A) q, (exp p * q)%pred = (exp (fun x => p x * q))%pred.

Lemma exists_expand_sepcon' {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B p (q: B -> pred A), (p * exp q)%pred = (exp (fun x => p * q x))%pred.

Lemma exists_expand_and {A}  {JA: Join A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exists_expand_and' {A} {JA: Join A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma allp_derives_right {A} : forall B p (q: B -> pred A),
  ((p |-- allp q) <-> (forall x, p |-- q x)).

Lemma wand_exists {A} {JA: Join A}{PA: Perm_alg A}:
   forall B P Q,  (EX x: B, P -* Q x) |-- (P -* EX x : B, Q x).

Lemma modus_wand {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q,  P * (P -* Q) |-- Q.

Lemma distrib_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q R, P * (Q && R) |-- (P * Q) && (P * R).

Lemma andp_r {A: Type} : forall (P Q R: pred A), P |-- Q -> P |-- R -> P |-- Q && R.

Definition list_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : list (pred A) -> pred A := fold_right sepcon emp.

Lemma sepcon_andp_prop {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R, P * (!!Q && R) = !!Q && (P * R).

Require Import VST.msl.cross_split.

Lemma exactly_i {A} : forall x: A, exactly x x.
Hint Resolve @exactly_i.

Lemma superprecise_exactly {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x, superprecise (exactly x).
Hint Resolve @superprecise_exactly.

Lemma find_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     Cross_alg A ->
     forall S P Q R, (S * P) && (Q * R) |--
                          EX SQ:_, EX SR:_, EX PQ:_, EX PR:_,
                            (((SQ* SR) && S)*((PQ* PR) && P)) &&
                            (((SQ* PQ) && Q)*((SR* PR) && R)) &&
                            !! (superprecise SQ /\ superprecise SR /\ superprecise PQ /\ superprecise PR).

Lemma modus_ponens {A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma and_intro {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma and1 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A}  : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A}  : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A}  : forall X (P: pred A),
  X |-- P --> TT.

Lemma FFrule {A}  : forall X (P: pred A),
  X |-- FF --> P.

Lemma distribution {A}  : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma wand_sepcon_adjoint {A} {JA: Join A}{PA: Perm_alg A} : forall (P Q R:pred A),
  ((P * Q) |-- R) = (P |-- (Q -* R)).

Lemma ewand_sepcon {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R,
      (ewand (P * Q) R = ewand P (ewand Q R))%pred.

Lemma andp_right {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma andp_left1{A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma exp_right:
  forall {B A: Type}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma allp_right {B A: Type}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma imp_andp_adjoint {A}  : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma exp_andp1 {A} :
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_sepcon1 {A}  {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  (exp P * Q = exp (fun x => P x * Q))%pred.

Definition pure {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}
     (P: pred A) : Prop :=
   P |-- emp.

Lemma sepcon_pure_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall P Q, pure P -> pure Q -> ((P * Q) = (P && Q)).

Lemma pure_sepcon_TT_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall P Q, pure P -> (P * TT) && Q = (P*Q).

Lemma ewand_conflict {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
       forall P Q R, sepcon P Q |-- FF -> andp P (ewand Q R) |-- FF.

Lemma ewand_TT_sepcon {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
      forall P Q R,
(P * Q && ewand R (!!True))%pred |-- (P && ewand R (!!True) * (Q && ewand R (!!True)))%pred. *)

Require Import ZArith.

Require Import veristar.veristar_sound.
(* veristar.veristar_sound:
Load loadpath.
Require Import veristar.compare.

Require Import ZArith Coq.Lists.List Permutation Classical.

Require Import VST.msl.Axioms VST.msl.predicates_sa VST.veric.Coqlib2.

Require Import veristar.datatypes veristar.clauses.

Require Import veristar.heapresolve veristar.veristar.

Require Import veristar.superpose_modelsat.

Require Import veristar.model_type veristar.model.

Require Import veristar.clausify_sound veristar.norm_sound
               veristar.wellformed_sound veristar.unfold_sound.

Require Import veristar.superpose_modelsat_sound.

Require Import veristar.list_denote veristar.clause_lemmas.

Module Type VERISTAR_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM.

Axiom check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.

End VERISTAR_SOUND.

Module VeriStarSound (VSM: VERISTAR_MODEL) : VERISTAR_SOUND
  with Module VSM := VSM.

Module VSM := VSM.  Import VSM. Import VeriStarLogic.
Module CS  := Clausify_Sound VSM. Import CS.
Module SPS := SP_Sound VSM.       Import SPS.
Module NS  := Norm_Sound VSM.     Import NS.
Module WFS := WF_Sound VSM.       Import WFS.
Module UFS := UF_Sound VSM.       Import UFS.
Module CL  := CL_Sound VSM.       Import CL.

Import HeapResolve.
Import VeriStar.

Lemma relim1_sound c s st :
  clause_denote c st -> setd clause_denote inter TT s st ->
  setd clause_denote inter TT (relim1 c s) st.

Lemma incorp_sound s t st :
  setd clause_denote inter TT s st -> setd clause_denote inter TT t st ->
  setd clause_denote inter TT (incorp s t) st.

Local Open Scope nat_scope.

Lemma positive_base_case : forall n: positive,
  O = nat_of_P n - 1 -> n=1%positive.

Local Coercion bool2Prop (b: bool) := b = true.

Lemma loop_sound n sigma nc s cl st :
  clause_denote nc st -> space_denote sigma st ->
  setd clause_denote inter TT s st -> the_loop n sigma nc s cl = Valid ->
  clause_denote empty_clause st.

Theorem check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.

End VeriStarSound. *)

Require Import veristar.model_type veristar.model.
(* veristar.model_type:
Load loadpath.
Require Import VST.msl.base VST.msl.sepalg.
Require Import veristar.variables.

Module Type VERISTAR_LOGIC.

Parameters loc val : Type.
Declare Instance Join_val: Join val.
Declare Instance Perm_val: Perm_alg val.
Declare Instance Sep_val: Sep_alg val.
Declare Instance Canc_val: Canc_alg val.
Parameter val2loc : val -> option loc.
Parameter nil_val : val.
Axiom nil_not_loc : val2loc nil_val = None.

Parameter empty_val : val.
Axiom emp_empty_val : forall v, identity v <-> v = empty_val.
Definition full (v : val) := forall v2, joins v v2 -> identity v2.
Axiom val2loc_full : forall v l, val2loc v = Some l -> full v.
Axiom nil_full : full nil_val.
Axiom empty_not_full : ~full empty_val.
Axiom val2loc_inj : forall v1 v2 l,
  val2loc v1 = Some l ->  val2loc v2 = Some l -> v1=v2.
Axiom loc_eq_dec : forall l1 l2 : loc, Decidable.decidable (l1=l2).
Axiom nil_dec : forall v, Decidable.decidable (v=nil_val).

Definition var : Type := Ident.t.
Parameter env : Type.
Parameter env_get : env -> var -> val.
Parameter env_set : var -> val -> env -> env.
Axiom gss_env : forall (x : var) (v : val) (s : env),
  v<>empty_val -> env_get (env_set x v s) x = v.
Axiom gso_env : forall (x y : var) (v : val) (s : env),
  x<>y -> env_get (env_set x v s) y = env_get s y.

Axiom env_reset : forall s x, env_set x (env_get s x) s = s.
Axiom env_reset2 : forall s x z, env_set x (env_get s x) (env_set x z s) = s.

Parameter heap : Type.
Declare Instance Join_heap: Join heap.
Declare Instance Perm_heap: Perm_alg heap.
Declare Instance Sep_heap: Sep_alg heap.
Declare Instance Canc_heap: Canc_alg heap.
Parameter rawnext: forall (x: loc) (y : val) (s : heap), Prop.
Parameter emp_at : forall (l: loc) (h: heap), Prop.
Axiom heap_gempty : forall h l, identity h -> emp_at l h.
Definition nil_or_loc (v: val) := v=nil_val \/ exists l, val2loc v = Some l.
Axiom mk_heap_rawnext : forall h x0 x y, val2loc (x0) = Some x ->
  nil_or_loc y -> exists h', rawnext x y h' /\ comparable h h'.
Axiom rawnext_out : forall {x x0 x' y h},
  rawnext x y h -> val2loc x0 = Some x' -> x'<>x -> emp_at x' h.

Definition rawnext' x y h := exists h0, join_sub h0 h /\ rawnext x y h0.

Axiom rawnext_at1 : forall {x y h1 h2 h},
  rawnext' x y h1 -> join h1 h2 h -> emp_at x h2 /\ rawnext' x y h.

Axiom rawnext_at2 : forall {x y h1 h2 h},
  join h1 h2 h -> rawnext' x y h -> emp_at x h2 -> rawnext' x y h1.

Axiom  rawnext_not_emp : forall {x y h}, rawnext' x y h -> ~emp_at x h.

Axiom emp_at_join: forall {h1 h2 h},
  join h1 h2 h -> forall l, (emp_at l h1 /\ emp_at l h2) <-> emp_at l h.

Axiom rawnext_unique : forall x z z' s s' t t' r,
  rawnext x z s -> rawnext x z' s' -> join s t r -> join s' t' r ->
  z' = z /\ s'=s.

Axiom vars_defined_locs : forall z (e : env),
  exists v, env_get e z = v /\ nil_or_loc v.

End VERISTAR_LOGIC. *)
(* veristar.model:
Load loadpath.
Require Import Coq.ZArith.ZArith Coq.Lists.List.
Require Import VST.msl.base msl.sepalg VST.msl.sepalg_generators msl.Axioms
               VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.model_type veristar.list_denote.

Module Type VERISTAR_MODEL.
Declare Module VeriStarLogic : VERISTAR_LOGIC.
Import VeriStarLogic.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Axiom rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s : stack) (x : option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
 env_set x v s.

Axiom stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Axiom join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Declare Instance Perm_state: Perm_alg state.
Declare Instance Sep_state: Sep_alg state.
Declare Instance Canc_state: Canc_alg state.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.
Infix "===" := var_eq (at level 35, no associativity).

Axiom var_eq_refl : forall x s, (x === x) s.

Axiom var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Axiom var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Axiom var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Axiom empstate_empheap: forall (s:state), emp s <-> emp (hp s).

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

Axiom var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

End VERISTAR_MODEL.

Module VeriStarModel (VSLog : VERISTAR_LOGIC) : VERISTAR_MODEL
  with Module VeriStarLogic := VSLog.

Module VeriStarLogic := VSLog. Import VSLog.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Lemma rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Lemma var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s: stack) (x: option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
  env_set x v s.

Lemma stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Lemma join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.

Infix "===" := var_eq (at level 35, no associativity).

Lemma var_eq_refl : forall x s, (x === x) s.

Lemma var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Lemma var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Lemma var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Lemma empstate_empheap : forall (s:state), emp s <-> emp (hp s).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

End VeriStarModel. *)

Require Import Permutation.

Require Import veristar.veristar.
(* veristar.veristar:
Load loadpath.
Require Import ZArith Znumtheory Coq.Lists.List.
Require Import veristar.variables veristar.datatypes veristar.clauses
               veristar.heapresolve.

Require Import veristar.superpose_modelsat.

Import Superposition. Import HeapResolve.
Require Recdef.

Inductive veristar_result :=
| Valid : veristar_result
| C_example : model -> veristar_result
| Aborted : list clause -> clause -> veristar_result.

Module Type VERISTAR.

Parameter check_entailment : entailment -> veristar_result.

End VERISTAR.

Module VeriStar.

Inductive veristar_result :=
| Valid : veristar_result
| C_example : model -> veristar_result
| Aborted : list clause -> clause -> veristar_result.

Definition pureb c := match c with PureClause _ _ _ _ => true | _ => false end.

Definition pure_clauses := filter pureb.

Definition is_empty_clause (c : clause) :=
  match c with PureClause nil nil _ _ => true | _ => false end.

Definition pures := M.filter pureb.

Lemma Ppred_decrease n :
  (n<>1)%positive -> (nat_of_P (Ppred n)<nat_of_P n)%nat.

Section RedundancyElim.
Context {A: Type}.
Variable (cmp: A -> A->comparison).

Definition naive_sublist (l1 l2: list A) :=
  forallb (fun a => existsb (fun b => isEq (cmp a b)) l2) l1.

Fixpoint sublistg (l1 l2: list A) :=
  match l1, l2 with
  | a::l1', b::l2' => andb (isEq (cmp a b)) (sublistg l1' l2')
  | nil, _ => true
  | _::_, nil => false
  end.

Fixpoint sublist (l1 l2: list A) :=
  match l1, l2 with
  | a::l1', b::l2' =>
    if isEq (cmp a b) then sublistg l1' l2' else sublist l1 l2'
  | nil, _ => true
  | _::_, nil => false
  end.

End RedundancyElim.

Definition impl_pure_clause (c d: clause) :=
  match c, d with PureClause gamma delta _ _, PureClause gamma' delta' _ _ =>
    andb (sublist pure_atom_cmp gamma gamma')
             (sublist pure_atom_cmp delta delta')
  | _, _ => false
  end.

Definition relim1 (c: clause) (s: M.t) :=
  M.filter (fun d => negb (impl_pure_clause c d)) s.

Definition incorp (s t : M.t) :=

Implicit Arguments eq_sym.

Definition check_entailment (ent: entailment) : veristar_result :=
  let s := clause_list2set (pure_clauses (map order_eqv_clause (cnf ent)))
  in match ent with
     | Entailment (Assertion pi sigma) (Assertion pi' sigma') =>
       match mk_pureR pi, mk_pureR pi' with
       | (piplus, piminus), (pi'plus, pi'minus) =>
           the_loop 1000000 sigma (NegSpaceClause pi'plus sigma' pi'minus)
             (print_new_pures_set s) empty_clause
       end
     end.

End VeriStar. *)

Require Import veristar.isolate.
(* veristar.isolate:
Require Import Coq.Lists.List.
Require Import veristar.variables veristar.datatypes.
Require Import compcert.Coqlib.
Require Import VST.veric.Coqlib2.
Require Import ZArith.

Require Import veristar.fresh.
Require Import veristar.veristar.
Require Import veristar.basic.

Definition oracle (ent: entailment) : bool :=
 match VeriStar.check_entailment ent with
 | VeriStar.Valid => true
 | VeriStar.C_example _ => false
 | VeriStar.Aborted _ _ => false
 end.

Bind Scope entail_scope with entailment.
Local Open Scope entail_scope.

Definition incon (a: assertion) : bool :=
   oracle (Entailment a
               (Assertion (Nequ Nil Nil :: nil)
                              match a with (Assertion _ sigma) => sigma end)).

Lemma eq_expr (e1 e2: expr) : {e1=e2}+{e1<>e2}.

Fixpoint exorcize (e: expr) (pi: list pn_atom) (sigma0 sigma: list space_atom) (nextv: var)
         : option (list assertion) :=
 match sigma with
 | nil => if incon (Assertion pi (rev sigma0)) then Some nil else None
 | Lseg f f' :: sigma1 =>
          if oracle (Entailment
                         (Assertion pi (rev sigma0 ++ (Lseg f f') :: sigma1))
                         (Assertion (Equ e f :: nil) (rev sigma0 ++ Lseg f f' :: sigma1)))
          then match exorcize e (Equ f f' :: pi)  (Lseg f f' :: sigma0) sigma1 nextv with
                   | Some l => Some (Assertion pi (Next e (Var nextv) :: Lseg (Var nextv) f' :: rev sigma0 ++ sigma1) ::l)
                   | None => None
                  end
          else exorcize e pi (Lseg f f' :: sigma0) sigma1 nextv
 | a :: sigma1 =>
          exorcize e pi (a :: sigma0) sigma1 nextv
 end.

Fixpoint isolate' (e: expr) (pi: list pn_atom) (sigma0 sigma: list space_atom) (nextv: var) (count: nat)
         : option (list assertion) :=
 match sigma with
 | nil => if  lt_dec count 2
              then None
              else if incon (Assertion (Equ e Nil :: pi) (rev sigma0))
                     then exorcize e pi nil (rev sigma0) nextv
                     else None
 | Next e1 e2 :: sigma1 =>
          if eq_expr e e1
          then Some [Assertion pi (Next e e2 :: rev sigma0 ++ sigma1)]
          else if oracle (Entailment
                         (Assertion pi (rev sigma0 ++ (Next e1 e2) :: sigma1))
                         (Assertion (Equ e e1 :: nil) (rev sigma0 ++ (Next e1 e2) :: sigma1)))
          then Some [Assertion pi (Next e e2 :: rev sigma0 ++ sigma1)]
          else isolate' e pi (Next e1 e2 :: sigma0) sigma1 nextv count
 | Lseg f f' :: sigma1 =>
          if oracle (Entailment
                         (Assertion pi (rev sigma0 ++ (Lseg f f') :: sigma1))
                         (Assertion (Equ e f :: Nequ f f' :: nil ) (rev sigma0 ++ (Lseg f f') :: sigma1)))
          then Some [Assertion pi (Next e (Var nextv) :: Lseg (Var nextv) f' :: rev sigma0 ++ sigma1)]
          else if oracle (Entailment
                         (Assertion pi (rev sigma0 ++ (Lseg f f') :: sigma1))
                         (Assertion (Equ e f :: nil) (rev sigma0 ++ (Lseg f f') :: sigma1)))
                 then isolate' e pi (Lseg f f' :: sigma0) sigma1 nextv (S count)
          else isolate' e pi (Lseg f f' :: sigma0) sigma1 nextv count
 end.

Definition isolate (e: expr) (P: assertion) (nextv: var) : option (list assertion) :=
 match P with Assertion pi sigma =>
  isolate' e pi nil sigma nextv 0
 end. *)

Require Import veristar.fresh.
(* veristar.fresh:
Load loadpath.
Require Import Coq.Lists.List.
Require Import veristar.variables veristar.datatypes.
Require Import Coqlib.
Require Import VST.msl.Coqlib2.
Require Import ZArith.
Require Import veristar.compare.
Require Import veristar.clauses.

Fixpoint freshmax_expr (e: expr) : var :=
  match e with
  | Nil => minid
  | Var v => v
  end.

Definition var_max (x y : var) : var :=
 match Ident.compare x y with Lt => y | _ => x end.

Definition freshmax_pn_atom (a: pn_atom) : var :=
  match a with
  | Equ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  | Nequ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_space_atom (a: space_atom) : var :=
  match a with
  | Next e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
  | Lseg e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
 end.

Definition freshmax_list {A} (f: A -> var) (l: list A) : var :=
  fold_right (fun a i => var_max (f a) i) minid l.

Definition freshmax_assertion (a: assertion) : var :=
  match a with
  | Assertion pi sigma =>
     var_max (freshmax_list freshmax_pn_atom pi)
            (freshmax_list freshmax_space_atom sigma)
  end.

Definition freshmax_pure_atom (a: pure_atom) : var :=
  match a with
  | Eqv e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_clause (c : clause) : var :=
 match c with
 | PureClause pi pi' _ _ =>  var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi')
 | PosSpaceClause pi pi' sigma =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 | NegSpaceClause pi sigma pi' =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 end.

Lemma varmax_minid: forall x, var_max minid x = x.

Lemma varmax_minid': forall x, var_max x minid = x.

Lemma var_max_intro:
  forall a b c, Ident.lt a c -> Ident.lt b c -> Ident.lt (var_max a b) c.

Lemma Ile_var_max1:  forall a b, Ile a (var_max a b).

Lemma Ile_var_max2:  forall a b, Ile b (var_max a b).

Lemma Ile_trans: forall a b c, Ile a b -> Ile b c -> Ile a c.

Lemma Ile_minid: forall m, Ile minid m.

Lemma var_max_intro':
  forall a b c, Ile a c -> Ile b c -> Ile (var_max a b) c.

Lemma var_max_split': forall a b c, Ile (var_max a b) c -> Ile a c /\ Ile b c.

Lemma id_compare_refl: forall z, Ident.compare z z = Eq.

Lemma id_compare_lt: forall x y, Ident.lt x y -> Ident.compare x y = Lt.

Lemma id_compare_gt: forall x y, Ident.lt y x -> Ident.compare x y = Gt.

Lemma var_max_assoc: forall x y z, var_max x (var_max y z) = var_max (var_max x y) z.

Lemma var_max_com: forall x y, var_max x y = var_max y x.

Lemma var_max_split: forall a b c, Ident.lt (var_max a b) c -> Ident.lt a c /\ Ident.lt b c.

Lemma freshmax_list_app:
 forall {A} (f: A -> var) l1 l2,
    freshmax_list f (l1++l2) = var_max (freshmax_list f l1) (freshmax_list f l2).

Lemma freshmax_list_rev:
 forall {A} (f: A -> var) l,
    freshmax_list f (rev l) = freshmax_list f l.

Lemma Ile_freshmax_i3:
  forall s m,
    (forall x, M.In x s -> Ile (freshmax_clause x) m) ->

Lemma merge_nil1:
  forall {A} (f: A -> A -> comparison) l, merge f nil l = l.

Lemma freshmax_list_merge:
  forall m al bl,
     Ile (freshmax_list freshmax_pure_atom al) m ->
     Ile (freshmax_list freshmax_pure_atom bl) m ->
     Ile (freshmax_list freshmax_pure_atom (merge pure_atom_cmp al bl)) m.

Lemma Ile_freshmax_list:
  forall A (f: A -> var) m (s: list A),
    Ile (freshmax_list f s) m <-> (forall x, List.In x s -> Ile (f x) m).

Lemma freshmax_list_insu:
   forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      a s,
      freshmax_list f (insert_uniq cmp a s) = var_max (f a) (freshmax_list f s).

Lemma freshmax_list_sort:
  forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      (s: list A),
    freshmax_list f (rsort_uniq cmp s) = freshmax_list f s.

Lemma freshmax_insu:
  forall m a pi,
       Ile (freshmax_pure_atom a) m ->
       Ile (freshmax_list freshmax_pure_atom pi) m ->
       Ile (freshmax_list freshmax_pure_atom
              (insert_uniq pure_atom_cmp a pi)) m. *)

Require Import veristar.basic.
(* veristar.basic:
Load loadpath.
Require Import Coq.Lists.List Coq.Arith.EqNat Coq.Arith.Compare_dec
               Coq.ZArith.ZArith.
Require Import veristar.tactics.

Set Implicit Arguments.
Unset Strict Implicit.

Section option.
Variables (A B : Type) (h : A -> B) (f : A -> option B) (o : option A).

Definition omap := match o with Some a => Some (h a) | None => None end.

Definition obnd := match o with Some a => f a | None => None end.

End option.
Implicit Arguments omap [A B].
Implicit Arguments obnd [A B].

Definition isSome {A : Type} (o : option A) :=
  match o with Some _ => true | _ => false end.

Section comp.
Variables (A B C : Type) (g : B -> C) (f : A -> B) (a : A).

Definition compose := g (f a).

End comp.
Implicit Arguments compose [A B C].

Infix "oo" := compose (at level 54, right associativity).

Notation "[ ]" := nil.
Notation "[ x , .. , y ]" := (cons x .. (cons y []) ..).

Fixpoint zip_with_acc {A B : Type} acc (l1 : list A) (l2 : list B) :=
  match l1, l2 with
    | a :: l1', b :: l2' => (a, b) :: zip_with_acc acc l1' l2'
    | _, _ => acc
  end.

Definition zip {A B : Type} := @zip_with_acc A B [].

Section iter.
Variables (A : Type) (f : nat -> A -> A).

Fixpoint iter (n : nat) (a : A) :=
  match n with
    | O => a
    | S n' => iter n' (f n' a)
  end.

End iter.
Implicit Arguments iter [A].

Section tryfind.
Variables (A E B : Type) (f : A -> E + B).

Fixpoint tryfind (err : E) (l : list A) :=
  match l with
    | nil => inl _ err
    | a :: l' => match f a with
                   | inl err' => tryfind err' l'
                   | inr success as r => r
                 end
  end.

End tryfind.

Definition max (n m : nat) := if leb n m then m else n.

Definition maxs (l : list nat) := fold_left (fun m n => max m n) l 0.

Definition elemb (n : nat) := existsb (fun m => beq_nat n m).

Require Import ZArith.

Lemma Ppred_decrease n : (n<>1)%positive -> (nat_of_P (Ppred n)<nat_of_P n)%nat.

Ltac Ppred_tac n :=
  apply Ppred_decrease; destruct n;
  let H := fresh "H" in intro H; try (inversion H||inversion H1); congruence.

Definition Pleb (x y : positive) :=
  match Pcompare x y Eq with
    | Lt => true
    | Eq => true
    | Gt => false
  end.

Lemma Pleb_Ple (x y : positive) : Pleb x y = true <-> Ple x y.

Require Import NArith NOrderedType.

Definition Nleb (x y : N) :=
  match Ncompare x y with
    | Lt => true
    | Eq => true
    | Gt => false
  end.

Lemma Nleb_Nle (x y : N) : Nleb x y = true <-> Nle x y.

Section revc.
Variables (A : Type) (c : A -> A -> comparison).

Definition revc a1 a2 :=
  match c a1 a2 with
    | Gt => Lt
    | Eq => Eq
    | Lt => Gt
  end.

End revc.

Inductive ret_kind (val : Type) : Type :=
| Success : val -> ret_kind val
| Failure : ret_kind val.

Implicit Arguments Success [val].
Implicit Arguments Failure [val]. *)

Require Import Classical.



Module Type ISO_SOUND.

Declare Module VeriStarSound : VERISTAR_SOUND.

Import VeriStarSound VSM VeriStarLogic.



Axiom expr_denote_heap_ind : forall x s h h',

  expr_denote x (State s h)=expr_denote x (State s h').



Axiom oracle_sound: forall (e: entailment),

    oracle e = true -> entailment_denote e.



Definition existsv (nextv: var) (P: spred) : spred :=

   fun s => exists y,  P (State (env_set nextv y (stk s)) (hp s)).



Axiom existsv_refl:  forall P x, P |-- existsv x P.



Definition fresh {A} (f: A -> var) (a: A) (x: var) : Prop :=  Ident.lt (f a) x.



Ltac do_fresh1 :=

  repeat match goal with H: Ile _ _ |- _ => revert H

                                     | H: Ident.lt _ _ |- _ => revert H

                                     | H: fresh _ _ _ |- _ => revert H end;

  clear;

  unfold fresh; simpl;

  repeat ((rewrite freshmax_list_app || rewrite freshmax_list_rev

                || rewrite varmax_minid || rewrite varmax_minid'); simpl).



Ltac do_fresh :=

  do_fresh1; intros;

  repeat match goal with

             |  H: Ident.lt (var_max _ _) _ |- _ => apply var_max_split in H; destruct H

             end;

  repeat apply var_max_intro; auto;

  try solve [etransitivity; eauto].



Definition set_in_state nextv z s := State (env_set nextv z (stk s)) (hp s).



Axiom expr_denote_agree:

  forall e s nextv z,

  fresh freshmax_expr e nextv ->

  expr_denote e s = expr_denote e (set_in_state nextv z s).



Axiom pn_atom_denote_agree:

 forall a s nextv z,

  fresh freshmax_pn_atom a nextv ->

  pn_atom_denote a s ->

  pn_atom_denote a (set_in_state nextv z s).



Axiom space_atom_denote_agree:

 forall a s nextv z,

  fresh freshmax_space_atom a nextv ->

  space_atom_denote a s ->

  space_atom_denote a (set_in_state nextv z s).



Axiom list_denote__pn_atom_agree:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_pn_atom) pos nextv ->

  list_denote pn_atom_denote (@andp _) TT pos s ->

  list_denote pn_atom_denote (@andp _) TT pos (set_in_state nextv z s).



Axiom list_denote_space_agree:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_space_atom) pos nextv ->

  list_denote space_atom_denote (@sepcon _ _) emp pos s ->

  list_denote space_atom_denote (@sepcon _ _) emp pos (set_in_state nextv z s).



Axiom list_denote_agree_pn_atom_neg:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_pn_atom) pos nextv ->

  list_denote (neg oo pn_atom_denote) (@andp _) TT pos s ->

  list_denote (neg oo pn_atom_denote) (@andp _) TT pos (set_in_state nextv z s).



Axiom fresh_lt:

  forall {A} (f: A -> var) a x y, fresh f a x -> Ident.lt x y -> fresh f a y.



Axiom space_denote_permute: forall l l',

  Permutation l l' ->  space_denote l = space_denote l'.



Axiom assertion_denote_permute: forall pi l l',

  Permutation l l' ->

   assertion_denote (Assertion pi l) = assertion_denote (Assertion pi l').



Axiom incon_e: forall P, incon P = true -> assertion_denote P |-- FF.



Axiom isolate_sound:

  forall e P nextv nextv2 results

      (LT: Ident.lt nextv nextv2),

      isolate e P nextv = Some results ->

       fresh freshmax_expr e nextv ->

       fresh freshmax_assertion P nextv ->

      assertion_denote P |--

        fold_right (fun P => orp (existsv nextv (assertion_denote P))) FF results /\

      forall Q, In Q results ->

            match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end /\

           fresh freshmax_assertion Q nextv2.

End ISO_SOUND.



Module Iso_Sound (VSS: VERISTAR_SOUND) : ISO_SOUND with Module VeriStarSound := VSS.

Module VeriStarSound := VSS.

Import VeriStarSound VSM VeriStarLogic.



Lemma expr_denote_heap_ind : forall x s h h',

  expr_denote x (State s h)=expr_denote x (State s h').

Proof.

intros. destruct x; auto.

Qed.



Lemma oracle_sound: forall (e: entailment),

    oracle e = true -> entailment_denote e.

Proof.

unfold oracle;

intros.

apply check_entailment_sound.

destruct (VeriStar.check_entailment e); congruence.

Qed.



Definition existsv (nextv: var) (P: spred) : spred :=

   fun s => exists y,  P (State (env_set nextv y (stk s)) (hp s)).



Lemma existsv_refl:

  forall P x, P |-- existsv x P.

Proof.

intros; intros s ?. exists (env_get (stk s) x).

destruct s; simpl. replace (env_set x (env_get s x) s) with s; auto.

rewrite env_reset; auto.

Qed.



Definition fresh {A} (f: A -> var) (a: A) (x: var) : Prop :=  Ident.lt (f a) x.



Lemma list_denote_separate':

  forall (X Y: Type) (f: X -> spred) (g: Y -> spred) (base: spred) l1 l2,

  list_denote f (@sepcon _ _) (list_denote g (@sepcon _ _) base l2) l1 =

  sepcon (list_denote f (@sepcon _ _) emp l1)

   (sepcon (list_denote g (@sepcon _ _) emp l2)

     base).

Proof.

induction l1; simpl; intros.

rewrite emp_sepcon.

induction l2; simpl. rewrite emp_sepcon; auto.

rewrite IHl2. rewrite sepcon_assoc; auto.

rewrite sepcon_assoc.

f_equal.

auto.

Qed.



Ltac do_fresh1 :=

  repeat match goal with H: Ile _ _ |- _ => revert H

                                     | H: Ident.lt _ _ |- _ => revert H

                                     | H: fresh _ _ _ |- _ => revert H end;

  clear;

  unfold fresh; simpl;

  repeat ((rewrite freshmax_list_app || rewrite freshmax_list_rev

                || rewrite varmax_minid || rewrite varmax_minid'); simpl).



Ltac do_fresh :=

  do_fresh1; intros;

  repeat match goal with

             |  H: Ident.lt (var_max _ _) _ |- _ => apply var_max_split in H; destruct H

             end;

  repeat apply var_max_intro; auto;

  try solve [etransitivity; eauto].



Lemma freshmax_pn_atom_Equ_Destruct: forall e e' nextv,

fresh freshmax_pn_atom (Equ e e') nextv ->

fresh freshmax_expr e nextv /\ fresh freshmax_expr e' nextv.

Proof.

intros.

split; do_fresh.

Qed.



Lemma freshmax_pn_atom_Nequ_Destruct: forall e e' nextv,

fresh freshmax_pn_atom (Nequ e e') nextv ->

fresh freshmax_expr e nextv /\ fresh freshmax_expr e' nextv.

Proof.

intros.

do_fresh.

Qed.



Definition set_in_state nextv z s := State (env_set nextv z (stk s)) (hp s).



Lemma expr_denote_agree:

  forall e s nextv z,

  fresh freshmax_expr e nextv ->

  expr_denote e s = expr_denote e (set_in_state nextv z s).

Proof.

intros.

destruct e; simpl; auto.

rewrite gso_env; auto.

do_fresh. intro; subst.

eapply Ilt_irrefl; eauto.

Qed.



Lemma pn_atom_denote_agree:

 forall a s nextv z,

  fresh freshmax_pn_atom a nextv ->

  pn_atom_denote a s ->

  pn_atom_denote a (set_in_state nextv z s).

Proof.

intros.

destruct a.

  destruct (freshmax_pn_atom_Equ_Destruct _ _ _ H) as [Fe Fe0].

  simpl in *.

  unfold var_eq in *.

  repeat rewrite <- expr_denote_agree; auto.



  destruct (freshmax_pn_atom_Nequ_Destruct _ _ _ H) as [Fe Fe0].

  simpl in *. unfold neg in *.

  contradict H0.

  unfold var_eq in *.

  rewrite <- expr_denote_agree in H0; auto.

  rewrite <- expr_denote_agree in H0; auto.

Qed.



Lemma space_atom_denote_agree:

 forall a s nextv z,

  fresh freshmax_space_atom a nextv ->

  space_atom_denote a s ->

  space_atom_denote a (set_in_state nextv z s).

Proof.

intros.

destruct a.

simpl in *.

rewrite <- (expr_denote_agree e s nextv z) by do_fresh.

rewrite <- (expr_denote_agree e0 s nextv z) by do_fresh.

auto.

simpl in *.

rewrite <- (expr_denote_agree e s nextv z) by do_fresh.

rewrite <- (expr_denote_agree e0 s nextv z) by do_fresh.

auto.

Qed.



Lemma list_denote__pn_atom_agree:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_pn_atom) pos nextv ->

  list_denote pn_atom_denote (@andp _) TT pos s ->

  list_denote pn_atom_denote (@andp _) TT pos (set_in_state nextv z s).

Proof.

intros.

revert H H0; induction pos; simpl; intros; auto.

destruct H0; split.

eapply pn_atom_denote_agree; eauto. do_fresh.

apply IHpos; auto.

do_fresh.

Qed.



Lemma list_denote_space_agree:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_space_atom) pos nextv ->

  list_denote space_atom_denote (@sepcon _ _) emp pos s ->

  list_denote space_atom_denote (@sepcon _ _) emp pos (set_in_state nextv z s).

Proof.

intros.

revert s H H0; induction pos; simpl; intros; auto.

rewrite empstate_empheap in *. simpl; auto.

destruct H0 as [s1 [s2 [ ? [? ?]]]].

exists (set_in_state nextv z s1); exists (set_in_state nextv z s2); split3.

destruct s1; destruct s2; destruct s; destruct H0; destruct H0; simpl in *; subst; unfold set_in_state; split; simpl; auto.

apply msl.sepalg_generators.join_equiv_refl.

apply space_atom_denote_agree; auto; do_fresh.

apply IHpos; auto.

do_fresh.

Qed.



Axiom env_reset2: forall s x z, env_set x (env_get s x) (env_set x z s) = s.



Lemma list_denote_agree_pn_atom_neg:

 forall pos s nextv z,

  fresh (freshmax_list freshmax_pn_atom) pos nextv ->

  list_denote (neg oo pn_atom_denote) (@andp _) TT pos s ->

  list_denote (neg oo pn_atom_denote) (@andp _) TT pos (set_in_state nextv z s).

Proof.

intros.

revert H H0; induction pos; simpl; intros; auto.

destruct H0; split.

unfold compose, neg in H0|-*.

contradict H0.

replace s with (set_in_state nextv (env_get (stk s) nextv) (set_in_state nextv z s)).

apply pn_atom_denote_agree; auto.

do_fresh.

clear. unfold set_in_state; destruct s; simpl. f_equal.

apply env_reset2.

apply IHpos; auto.

do_fresh.

Qed.



Lemma fresh_lt:

  forall {A} (f: A -> var) a x y, fresh f a x -> Ident.lt x y -> fresh f a y.

Proof.

intros.

unfold fresh in *. transitivity x; auto.

Qed.



Lemma or_FF: forall {A} (P: pred A), (orp P FF) = P.

Proof. unfold orp; intros; extensionality z; apply prop_ext; intuition.

Qed.



Lemma permute_sigma0:

 forall sigma0 (a: space_atom) sigma, Permutation (sigma0 ++ a :: sigma) (a :: sigma0 ++ sigma).

Proof.

intros; eapply perm_trans; [apply Permutation_app_comm | apply Permutation_cons; apply Permutation_app_comm].

Qed.



Lemma space_denote_permute: forall l l',

  Permutation l l' ->

   space_denote l = space_denote l'.

intros.

unfold space_denote.

apply (listd_perm space_atom_denote _ emp (sepconS _ _) (@sepconA state _ _) l l' H) .

Qed.



Lemma assertion_denote_permute: forall pi l l',

  Permutation l l' ->

   assertion_denote (Assertion pi l) = assertion_denote (Assertion pi l').

intros.

simpl.

rewrite (space_denote_permute _ _ H).

trivial.

Qed.



Lemma Lseg_unfold_neq:

  forall e nextv pi sigma0 e0 e1 sigma s,

    fresh freshmax_expr e nextv ->

    fresh freshmax_assertion (Assertion pi (sigma0 ++ Lseg e0 e1 :: sigma)) nextv ->

    (e === e0) s ->

    list_denote pn_atom_denote (@andp _)

         (space_denote (sigma0 ++ Lseg e0 e1 :: sigma)) pi s ->

    ~ (e0 === e1) s ->

    existsv nextv

      (assertion_denote (Assertion pi (Next e (Var nextv) :: Lseg (Var nextv) e1 :: sigma0 ++ sigma))) s.

Proof.

intros.

rewrite (@listd_prop pn_atom state pn_atom_denote) in H2.

destruct H2 as [HypP HypSig].

rewrite (space_denote_permute _ _  (permute_sigma0 _ _ _ )) in HypSig.

unfold space_denote in HypSig.

rewrite listd_cons in HypSig.

destruct HypSig as [s1 [s2 [? [? ?]]]].

inv H4.

contradiction H3.

unfold var_eq.

clear - H6 H2.

 destruct s1; destruct s2; destruct s; destruct H2; destruct H; simpl in *; auto.

subst; rewrite (expr_denote_heap_ind e0 s h1 h). rewrite (expr_denote_heap_ind e1 s h1 h).

auto.

exists z.

change (State (env_set nextv z (stk s)) (hp s)) with (set_in_state nextv z s).

simpl.

rewrite (@listd_prop pn_atom state pn_atom_denote).

rewrite sepconA; auto with typeclass_instances.

split.

apply list_denote__pn_atom_agree; trivial. do_fresh.

clear HypP.

exists (set_in_state nextv z s1).

exists (set_in_state nextv z s2).

split3.

clear - H2. destruct H2; destruct H;

unfold set_in_state; repeat split; simpl; try congruence.

exists (set_in_state nextv z (State (stk s1) h0)).

exists (set_in_state nextv z (State (stk s1) h1)).

split3; simpl; auto.

split; auto.

apply msl.sepalg_generators.join_equiv_refl.

unfold var_eq in *.

repeat rewrite <- expr_denote_agree by do_fresh.

destruct s as [s h]. destruct s1 as [s1 h1']; destruct s2 as [s2 h2'].

destruct H2. destruct H2. simpl in H11. subst.

simpl in *. subst.

repeat rewrite expr_denote_heap_ind with (h:=h0)(h':=h) in *.

repeat rewrite expr_denote_heap_ind with (h:=h1')(h':=h) in *.

rewrite H1. rewrite H7.

rewrite gss_env.

split; auto.

inv H9; auto.

unfold nil_or_loc. right; eauto.

rewrite gss_env. rewrite <- expr_denote_agree by do_fresh.

destruct s1 as [s' h']; simpl in *.

rewrite expr_denote_heap_ind with (h:=h1)(h':=h'); auto.

apply list_denote_space_agree; auto; do_fresh.

Qed.



Lemma exorcize_sound_Lseg:

 forall (e : expr) (pnatoms : list pn_atom) (e0 e1 : expr)

  (sigma : list space_atom) (nextv : var) (nextv2 : var)

  (sigma0 : list space_atom) (l : list assertion),

  fresh freshmax_expr e nextv ->

  Ident.lt nextv nextv2 ->

  fresh freshmax_assertion

    (Assertion pnatoms (rev (Lseg e0 e1 :: sigma0) ++ sigma)) nextv ->

  entailment_denote

    (Entailment (Assertion pnatoms (rev (Lseg e0 e1 :: sigma0) ++ sigma))

       (Assertion [Equ e e0] (rev (Lseg e0 e1 :: sigma0) ++ sigma))) ->

  (assertion_denote

     (Assertion (Equ e0 e1 :: pnatoms) (rev (Lseg e0 e1 :: sigma0) ++ sigma))

    |-- fold_right

         (fun P => orp (existsv nextv (assertion_denote P))) FF l) /\

   (forall (Q : assertion),

     In Q l ->

          match Q with

          |Assertion _ (Next e0 _ :: _) => e=e0

          | _ => False

          end /\

          fresh freshmax_assertion Q nextv2) ->

        (assertion_denote (Assertion pnatoms (rev (Lseg e0 e1 :: sigma0) ++ sigma))

      |-- fold_right

          (fun P => orp (existsv nextv (assertion_denote P))) FF

          (Assertion pnatoms (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma) :: l)) /\

   (forall Q,

    In Q (Assertion pnatoms (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma) :: l) ->

          match Q with

          |Assertion _ (Next e0 _ :: _) => e=e0

          | _ => False

          end /\

    fresh freshmax_assertion Q nextv2).

Proof.

intros e pnatoms e0 e1 sigma nextv nextv2 sigma0 l FRESHe H1 H H0 IHsigma.

destruct IHsigma.

split.

simpl in H0,H2.

intros s ?.

simpl in H0, H4.

generalize (H0 _ H4); clear H0; intros [? _].

rewrite (@listd_prop pn_atom state pn_atom_denote) in H4.

destruct H4 as [HypP HypSig].

destruct (classic ((e0===e1) s)).

right.

apply H2.

split; auto.

rewrite (@listd_prop pn_atom state pn_atom_denote).

split; auto.

left.

eapply Lseg_unfold_neq with e0; auto.

simpl in H.

rewrite app_ass in H; apply H.



rewrite (@listd_prop pn_atom state pn_atom_denote).

split; auto.

rewrite app_ass in HypSig; apply HypSig.

intros.

simpl in H4.

destruct H4.

inv H4.

split; auto.

do_fresh.

apply H3; auto.

Qed.



Lemma incon_e: forall P, incon P = true -> assertion_denote P |-- FF.

Proof.

unfold incon; intros.

forget match P with Assertion _ sigma => sigma end as Q.

apply oracle_sound in H.

simpl in H.

eapply derives_trans; [apply H | clear H].

intros w [H ?]; apply H; reflexivity.

Qed.



Lemma exorcize_sound_nil:

 forall e pnatoms nextv nextv2 sigma0 cl,

    Ident.lt nextv nextv2 ->

    exorcize e pnatoms sigma0 [ ] nextv = Some cl ->

    (assertion_denote (Assertion pnatoms (rev sigma0 ++ [ ]))

     |-- fold_right

       (fun P => orp (existsv nextv (assertion_denote P))) FF cl) /\

       (forall (Q : assertion),

         In Q cl ->

          (match Q with

          |Assertion  _ (Next e0 _ :: _) => e=e0

          | _ => False

          end /\

          fresh freshmax_assertion Q nextv2)).

Proof.

simpl; intros.

revert H0; case_eq (incon (Assertion pnatoms (rev sigma0))); intros; inv H1.

apply incon_e in H0.

split.

rewrite <- app_nil_end.

eapply derives_trans; [apply H0 | auto].

simpl; intros; contradiction.

Qed.



Lemma exorcize_e:

 forall e pnatoms sigma0 e0 e1 sigma nextv cl,

  exorcize e pnatoms sigma0 (Lseg e0 e1 :: sigma) nextv = Some cl ->

  (entailment_denote

       (Entailment (Assertion pnatoms (rev (Lseg e0 e1 :: sigma0) ++ sigma))

          (Assertion [Equ e e0] (rev (Lseg e0 e1 :: sigma0) ++ sigma)))

    /\ (exists cl',

          exorcize e (Equ e0 e1 :: pnatoms) (Lseg e0 e1 :: sigma0) sigma nextv = Some cl' /\

           cl = (Assertion pnatoms

                       (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma)) :: cl'))

  \/ exorcize e pnatoms (Lseg e0 e1 :: sigma0) sigma nextv = Some cl.

Proof.

simpl; intros until cl.

case_eq (oracle

      (Entailment (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

         (Assertion [Equ e e0] (rev sigma0 ++ Lseg e0 e1 :: sigma)))); intros.

revert H0; case_eq (exorcize e (Equ e0 e1 :: pnatoms) (Lseg e0 e1 :: sigma0) sigma nextv);

  intros; inv H1.

left; split; auto.

apply oracle_sound in H; simpl in H.

rewrite app_ass. auto.

exists l; split; auto.

right. auto.

Qed.



Lemma exorcize_sound:

  forall e pnatoms sigma nextv nextv2

      (FRESHe: fresh freshmax_expr e nextv)

      (LT: Ident.lt nextv nextv2),

      (fresh freshmax_assertion (Assertion pnatoms sigma) nextv) ->

      forall cl,

      (exorcize e pnatoms nil sigma nextv) = Some cl ->

 (assertion_denote (Assertion pnatoms sigma)

 |-- fold_right (fun P => orp (existsv nextv (assertion_denote P))) FF cl) /\

       (forall Q,

          In Q cl ->

           match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end /\

          fresh freshmax_assertion Q nextv2).

Proof.

intros.

replace sigma with (rev nil++sigma) in H by auto.

pattern sigma at 1; replace sigma with (rev nil++sigma) by auto.

remember (@nil space_atom) as sigma0.

clear Heqsigma0.

revert pnatoms sigma0 cl H0 H; induction sigma; intros.

apply exorcize_sound_nil; auto.

replace (rev sigma0 ++ a :: sigma) with (rev (a::sigma0) ++ sigma)  in * by apply app_ass.



destruct a.



apply (IHsigma _ _ _ H0 H).



apply exorcize_e in H0.

destruct H0 as [[? [cl' [? ?]]] | ?].

subst cl.

specialize (IHsigma _ _ _ H1).

spec IHsigma; [do_fresh | ].

apply exorcize_sound_Lseg; auto.

apply (IHsigma _ _ _ H0 H).

Qed.



Lemma isolate_e:

 forall e pnatoms sigma0 e0 e1 sigma nextv N results,

  isolate' e pnatoms sigma0 (Lseg e0 e1 :: sigma) nextv N = Some results ->

  (entailment_denote

       (Entailment (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

          (Assertion [Equ e e0, Nequ e0 e1] (rev sigma0 ++ Lseg e0 e1 :: sigma)))

          /\ results = [Assertion pnatoms (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma)]

    \/ (entailment_denote

           (Entailment (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

              (Assertion [Equ e e0] (rev sigma0 ++ Lseg e0 e1 :: sigma)))

          /\ isolate' e pnatoms (Lseg e0 e1 :: sigma0) sigma nextv (S N) =Some results)

    \/ isolate' e pnatoms (Lseg e0 e1 :: sigma0) sigma nextv N = Some results).

Proof.

simpl; intros; revert H.

case_eq (oracle

      (Entailment (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

         (Assertion [Equ e e0, Nequ e0 e1] (rev sigma0 ++ Lseg e0 e1 :: sigma)))); intros.

apply oracle_sound in H.

inv H0.

left; auto.

revert H0;

 case_eq (oracle

           (Entailment

              (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

              (Assertion [Equ e e0] (rev sigma0 ++ Lseg e0 e1 :: sigma)))); simpl; intros.

apply oracle_sound in H0.

right; left; auto.

right; right; auto.

Qed.



Lemma if_bool_e:

  forall {A: Type} (b: bool) (c d e: A),

     (if b then c else d) = e ->

     b=true /\ c=e \/ b=false /\ d=e.

Proof.

destruct b; auto.

Qed.



Lemma isolate_Next1:

 forall e e1 sigma nextv nextv2 pnatoms sigma0

    (LT: Ident.lt nextv nextv2),

    fresh freshmax_assertion

       (Assertion pnatoms (rev sigma0 ++ Next e e1 :: sigma)) nextv ->

  (assertion_denote (Assertion pnatoms (rev sigma0 ++ Next e e1 :: sigma))

     |-- fold_right (fun P : assertion => orp (existsv nextv (assertion_denote P))) FF

       [Assertion pnatoms (Next e e1 :: rev sigma0 ++ sigma)]) /\

   (forall Q : assertion,

      In Q [(Assertion pnatoms (Next e e1 :: rev sigma0 ++ sigma))] ->

         match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end  /\

      fresh freshmax_assertion Q nextv2).

Proof.

intros. rename H into H0.

split.

unfold fold_right, snd.

rewrite or_FF.

eapply derives_trans ; [ | apply existsv_refl].

rewrite (assertion_denote_permute pnatoms _ _ (permute_sigma0 _ _ _ )). trivial.

intros.

simpl in H.

destruct H; try contradiction.

inv H.

split; auto.

do_fresh.

Qed.



Lemma isolate_Next2:

  forall e e0 e1 sigma nextv nextv2 pnatoms sigma0

  (FRESHe:  fresh freshmax_expr e nextv)

  (LT: Ident.lt nextv nextv2),

  entailment_denote

     (Entailment (Assertion pnatoms (rev sigma0 ++ Next e0 e1 :: sigma))

        (Assertion [Equ e e0] (rev sigma0 ++ Next e0 e1 :: sigma))) ->

  fresh freshmax_assertion

     (Assertion pnatoms (rev sigma0 ++ Next e0 e1 :: sigma)) nextv ->

  (assertion_denote (Assertion pnatoms (rev sigma0 ++ Next e0 e1 :: sigma))

   |-- fold_right (fun P : assertion => orp (existsv nextv (assertion_denote P))) FF

         [Assertion pnatoms (Next e e1 :: rev sigma0 ++ sigma)]) /\

  (forall (Q : assertion),

   In Q [Assertion pnatoms (Next e e1 :: rev sigma0 ++ sigma)] ->

           match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end/\

   fresh freshmax_assertion Q nextv2).

Proof.

intros.

unfold fold_right, snd. rewrite or_FF.

split.

clear - H.

eapply derives_trans; [ | apply existsv_refl ].

apply derives_trans with (assertion_denote (Assertion (Equ e e0::pnatoms) (rev sigma0 ++ Next e e1 :: sigma))).

intros s H1; generalize (H _ H1); intro.

clear H; simpl  in *. destruct H0. split; auto.

repeat rewrite list_denote_separate in *.

rewrite (@listd_prop pn_atom state pn_atom_denote).

rewrite (@listd_prop pn_atom state pn_atom_denote) in H1.

destruct H1 as [? ?]; split; auto.

rewrite (space_denote_permute _ _ (permute_sigma0 _ _ _)) in H0.

rewrite (space_denote_permute _ _ (permute_sigma0 _ _ _)).

forget (rev sigma0 ++ sigma) as sig.

clear - H0 H.

unfold space_denote in *.

simpl in *.

destruct H0 as [s1 [s2 [? [? ?]]]]; exists s1; exists s2; split3; auto.

destruct s,s1,s2; destruct H0 as [[? ?] ?]; simpl in *; subst.

unfold var_eq in H.

repeat rewrite expr_denote_heap_ind with (h:=h0)(h':=h) in *.

rewrite <- H in *.

apply H1.

simpl in H. unfold assertion_denote.

intros s [_ ?].

rewrite space_denote_permute with (l':= rev sigma0 ++ Next e e1 :: sigma); auto.

apply Permutation_sym; apply permute_sigma0.

intros.

destruct H1; try contradiction.

subst Q.

split; auto.

do_fresh.

Qed.



Lemma isolate_Lseg1: forall e e0 e1 sigma nextv nextv2 pnatoms sigma0

  (FRESHe : fresh freshmax_expr e nextv)

  (LT: Ident.lt nextv nextv2),

   entailment_denote

     (Entailment (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

        (Assertion [Equ e e0, Nequ e0 e1] (rev sigma0 ++ Lseg e0 e1 :: sigma))) ->

   fresh freshmax_assertion

     (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma)) nextv ->

   (assertion_denote (Assertion pnatoms (rev sigma0 ++ Lseg e0 e1 :: sigma))

    |-- fold_right (fun P => orp (existsv nextv (assertion_denote P))) FF

          [Assertion pnatoms (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma)]) /\

   (forall Q : assertion,

    In Q

      [Assertion pnatoms (Next e (Var nextv) :: Lseg (Var nextv) e1 :: rev sigma0 ++ sigma)] ->

        match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end /\

    fresh freshmax_assertion Q nextv2).

Proof.

intros.

split.

assert (list_denote pn_atom_denote (@andp _ )

         (space_denote (rev sigma0 ++ Lseg e0 e1 :: sigma)) pnatoms |--

         e===e0 && neg (pn_atom_denote (Equ e0 e1))).

eapply derives_trans; try apply H. intros w [? [? ?]]; split; auto.

clear H.

intros s ?.

generalize (H1 _ H); intros [? ?].

unfold fold_right. unfold orp. left.

eapply Lseg_unfold_neq with e0; auto.

intros.

simpl in H1. destruct H1; try contradiction.

subst.

split; auto.

do_fresh.

Qed.



Lemma isolate'_sound:

  forall e pnatoms sigma nextv nextv2 results

  (LT: Ident.lt nextv nextv2),

      isolate' e pnatoms nil sigma nextv 0 = Some results ->

      fresh freshmax_expr e nextv ->

      fresh freshmax_assertion (Assertion pnatoms sigma) nextv ->

      assertion_denote (Assertion pnatoms sigma) |--

        fold_right (fun P => orp (existsv nextv (assertion_denote P))) FF results /\

      (forall Q, In Q results ->

            match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end /\

           fresh freshmax_assertion Q nextv2).

Proof.

intros until 2. intro FRESHe; intros.

assert (rev nil ++ sigma = sigma) by auto.

remember (@nil space_atom) as sigma0.

rewrite <- H1 in H0|-*.

clear Heqsigma0 H1.

remember O as N. clear HeqN.

revert pnatoms sigma0 results N H H0; induction sigma; intros.



rewrite <- app_nil_end in *;

unfold isolate' in H.

apply exorcize_sound; auto.

destruct (lt_dec N 2) as [? | _];  [ inversion H | ].

destruct (incon (Assertion (Equ e Nil :: pnatoms) (rev sigma0))); inversion H; auto.



specialize (IHsigma pnatoms (a::sigma0) results).

destruct a.



simpl in H.

if_tac in H.

clear IHsigma.

subst e0.

inv H.

apply isolate_Next1; auto.



revert H; case_eq (oracle

          (Entailment

             (Assertion pnatoms (rev sigma0 ++ Next e0 e1 :: sigma))

             (Assertion [Equ e e0] (rev sigma0 ++ Next e0 e1 :: sigma))));

     intros; inv H2; [|clear H].

apply isolate_Next2; auto; apply oracle_sound; auto.



specialize (IHsigma _ H4); clear H4.

destruct IHsigma.

change (rev (Next e0 e1 :: sigma0)) with (rev sigma0 ++ [Next e0 e1]).

rewrite app_ass. apply H0.

split; auto.

eapply derives_trans; try apply H.

simpl.

rewrite app_ass. auto.



apply isolate_e in H.

destruct H as [[? ?] | [[? ?] | ?]].

clear IHsigma.

subst.

apply isolate_Lseg1; auto.



change (rev (Lseg e0 e1 :: sigma0)) with (rev sigma0 ++ [Lseg e0 e1]) in *.

rewrite app_ass in *.

simpl in *.

apply (IHsigma _ H1); auto.



change (rev (Lseg e0 e1 :: sigma0)) with (rev sigma0 ++ [Lseg e0 e1]) in *.

rewrite app_ass in IHsigma.

apply (IHsigma _ H); auto.

Qed.



Lemma isolate_sound:

  forall e P nextv nextv2 results

      (LT: Ident.lt nextv nextv2),

      isolate e P nextv = Some results ->

       fresh freshmax_expr e nextv ->

       fresh freshmax_assertion P nextv ->

      assertion_denote P |--

        fold_right (fun P => orp (existsv nextv (assertion_denote P))) FF results /\

      forall Q, In Q results ->

            match Q with

           |Assertion _ (Next e0 _ :: _) => e=e0

           | _ => False

           end /\

           fresh freshmax_assertion Q nextv2.

Proof.

unfold isolate; destruct P; intros.

apply isolate'_sound with (nextv2:=nextv2) in H; auto.

Qed.



End Iso_Sound.
