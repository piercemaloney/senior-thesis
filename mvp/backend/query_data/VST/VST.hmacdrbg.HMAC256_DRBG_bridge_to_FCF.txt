Require Import hmacdrbg.spec_hmac_drbg.
(* hmacdrbg.spec_hmac_drbg:
Require Import VST.floyd.proofauto.
Import ListNotations.
Local Open Scope logic.

Require Import hmacdrbg.hmac_drbg.
Require Import hmacdrbg.HMAC256_DRBG_functional_prog.
Require Import hmacdrbg.DRBG_functions.
Require Import hmacdrbg.HMAC_DRBG_algorithms.
Require Import hmacdrbg.entropy.
Require Import sha.protocol_spec_hmac. 
Require Import sha.vst_lemmas.
Require Import sha.HMAC256_functional_prog.

Require Import sha.spec_sha.
Require Import VST.floyd.library.

Require Export hmacdrbg.hmac_drbg_compspecs.

Ltac fix_hmacdrbg_compspecs :=
  rewrite (@data_at__change_composite spec_hmac.CompSpecs hmac_drbg_compspecs.CompSpecs
            hmac_drbg_compspecs.CompSpecs_Preserve) by reflexivity.

Declare Module UNDER_SPEC : HMAC_ABSTRACT_SPEC.
Definition mdstate: Type := (val * (val * val))%type.

Definition md_info_state: Type := val%type.

Definition t_struct_md_ctx_st := Tstruct _mbedtls_md_context_t noattr.

Definition md_relate (key data : list byte) (r:mdstate) :=
  malloc_token Ews (Tstruct _hmac_ctx_st noattr) (snd (snd r)) *
  UNDER_SPEC.REP Ews (UNDER_SPEC.hABS key data) (snd (snd r)).

Definition md_full (key: list byte) (r:mdstate) :=
  malloc_token Ews (Tstruct _hmac_ctx_st noattr) (snd (snd r)) *
  UNDER_SPEC.FULL Ews key (snd (snd r)).

Definition md_empty (r:mdstate) := 
  malloc_token Ews (Tstruct _hmac_ctx_st noattr) (snd (snd r)) *
  UNDER_SPEC.EMPTY Ews (snd (snd r)).

Lemma md_relate_full: forall key data r, md_relate key data r |-- md_full key r.

Lemma md_full_empty: forall key r, md_full key r |-- md_empty r.

Lemma md_empty_unfold: forall (r: mdstate), 
       md_empty r = 
       malloc_token Ews (Tstruct _hmac_ctx_st noattr) (snd (snd r)) *
       data_at_ Ews (Tstruct _hmac_ctx_st noattr) (snd (snd r)).

Hint Resolve UNDER_SPEC.FULL_isptr : saturate_local.
Hint Resolve UNDER_SPEC.EMPTY_isptr : saturate_local.
Hint Resolve UNDER_SPEC.REP_isptr : saturate_local.

Definition md_free_spec :=
 DECLARE _mbedtls_md_free
  WITH ctx:val, r:mdstate, sh: share, gv: globals
  PRE  [ _ctx OF tptr t_struct_md_ctx_st ]
       PROP(writable_share sh) 
       LOCAL(temp _ctx ctx; gvars gv) 
       SEP (data_at sh t_struct_md_ctx_st r ctx;
            md_empty r;
             mem_mgr gv)
  POST [ tvoid ] 
       PROP () LOCAL () SEP (data_at sh t_struct_md_ctx_st r ctx; mem_mgr gv).

Definition mbedtls_zeroize_spec :=
  DECLARE _mbedtls_zeroize
   WITH n: Z, v:val, sh: share
    PRE [_v OF tptr tvoid, _n OF tuint ] 
       PROP (writable_share sh; 0<=n<= Ptrofs.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)); temp _v v)
       SEP (data_at_ sh (tarray tuchar n ) v)
    POST [ tvoid ]
       PROP () LOCAL () SEP (data_block sh (list_repeat (Z.to_nat n) Byte.zero) v).

Definition drbg_memcpy_spec :=
  DECLARE _memcpy
   WITH qsh : share, psh: share, p: val, q: val, n: Z, contents: list int
   PRE [ 1%positive OF tptr tvoid, 2%positive OF tptr tvoid, 3%positive OF tuint ]
       PROP (readable_share qsh; writable_share psh; 0 <= n <= Int.max_unsigned)
       LOCAL (temp 1%positive p; temp 2%positive q; temp 3%positive (Vint (Int.repr n)))
       SEP (data_at qsh (tarray tuchar n) (map Vint contents) q;
              memory_block psh n p)
    POST [ tptr tvoid ]
       PROP() LOCAL(temp ret_temp p)
       SEP(data_at qsh (tarray tuchar n) (map Vint contents) q;
             data_at psh (tarray tuchar n) (map Vint contents) p).

Definition drbg_memset_spec :=
  DECLARE _memset
   WITH sh : share, p: val, n: Z, c: int 
   PRE [ 1%positive OF tptr tvoid, 2%positive OF tint, 3%positive OF tuint ]
       PROP (writable_share sh; 0 <= n <= Ptrofs.max_unsigned)
       LOCAL (temp 1%positive p; temp 2%positive (Vint c);
                   temp 3%positive (Vint (Int.repr n)))
       SEP (memory_block sh n p)
    POST [ tptr tvoid ]
       PROP() LOCAL(temp ret_temp p)
       SEP(data_at sh (tarray tuchar n) (list_repeat (Z.to_nat n) (Vint c)) p).

Definition md_get_size_spec :=
  DECLARE _mbedtls_md_get_size
   WITH u:unit
   PRE [ _md_info OF tptr (Tstruct _mbedtls_md_info_t noattr)]
         PROP ()
         LOCAL ()
         SEP ()
  POST [ tuchar ] 
     PROP ()
     LOCAL (temp ret_temp (Vint (Int.repr (32 ))))
     SEP ().

Definition md_reset_spec :=
  DECLARE _mbedtls_md_hmac_reset
   WITH c : val, r: mdstate, sh: share, key:list byte, gv:globals
   PRE [ _ctx OF tptr (Tstruct _mbedtls_md_context_t noattr)]
         PROP (writable_share sh)
         LOCAL (temp _ctx c; gvars gv)
         SEP (md_full key r; 
              data_at sh (Tstruct _mbedtls_md_context_t noattr) r c; K_vector gv)
  POST [ tint ] 
     PROP ()
     LOCAL (temp ret_temp (Vint (Int.zero)))
     SEP (md_relate key nil r;
          data_at sh (Tstruct _mbedtls_md_context_t noattr) r c;
          K_vector gv).

Definition md_starts_spec :=
  DECLARE _mbedtls_md_hmac_starts
   WITH c : val, shc: share, r: mdstate, l:Z, key:list byte, b:block, i:ptrofs, shk: share, gv: globals
   PRE [ _ctx OF tptr t_struct_md_ctx_st,
         _key OF tptr tuchar,
         _keylen OF tuint ]
         PROP (writable_share shc; readable_share shk;
                   sha.spec_hmac.has_lengthK l key)
         LOCAL (temp _ctx c; temp _key (Vptr b i); temp _keylen (Vint (Int.repr l));
                gvars gv)
         SEP (md_empty r;
              data_at shc t_struct_md_ctx_st r c;
              data_at shk (tarray tuchar (Zlength key)) (map Vubyte key) (Vptr b i); K_vector gv)
  POST [ tint ] 
     PROP ()
     LOCAL (temp ret_temp (Vint (Int.zero)))
     SEP (md_relate key nil r;
          data_at shc t_struct_md_ctx_st r c;
          data_at shk (tarray tuchar (Zlength key)) (map Vubyte key) (Vptr b i);
          K_vector gv).

Definition md_update_spec :=
  DECLARE _mbedtls_md_hmac_update
   WITH key: list byte, c : val, r:mdstate, wsh: share, d:val, sh: share, data:list byte, data1:list byte, gv: globals
   PRE [ _ctx OF tptr t_struct_md_ctx_st, 
         _input OF tptr tuchar, 
         _ilen OF tuint]
         PROP (writable_share wsh; readable_share sh;
               Zlength data1 + Zlength data + 64 < two_power_pos 61)
         LOCAL (temp _ctx c; temp _input d; temp  _ilen (Vint (Int.repr (Zlength data1)));
                gvars gv)
         SEP(md_relate key data r;
             data_at wsh t_struct_md_ctx_st r c;
             data_at sh (tarray tuchar (Zlength data1)) (map Vubyte data1) d; K_vector gv)
  POST [ tint ] 
          PROP () 
          LOCAL (temp ret_temp (Vint (Int.zero)))
          SEP(md_relate key (data ++ data1) r;
              data_at wsh t_struct_md_ctx_st r c; 
              data_at sh (tarray tuchar (Zlength data1)) (map Vubyte data1) d; K_vector gv).

Definition md_final_spec :=
  DECLARE _mbedtls_md_hmac_finish
   WITH data:list byte, key:list byte, c : val, r:mdstate, wsh: share, md:val, shmd: share, gv: globals
   PRE [ _ctx OF tptr t_struct_md_ctx_st,
         _output OF tptr tuchar ]
       PROP (writable_share wsh; writable_share shmd) 
       LOCAL (temp _output md; temp _ctx c; gvars gv)
       SEP(md_relate key data r;
             data_at wsh t_struct_md_ctx_st r c;
             K_vector gv;
             data_at_ shmd (tarray tuchar 32) md)
  POST [ tint ] 
          PROP () 
          LOCAL (temp ret_temp (Vint (Int.zero)))
          SEP(K_vector gv;
              md_full key r;
              data_at wsh t_struct_md_ctx_st r c;
              data_at shmd (tarray tuchar 32) (map Vubyte (HMAC256 data key)) md).

Definition md_setup_spec :=
  DECLARE _mbedtls_md_setup
   WITH md_ctx : mdstate, c:val, wsh: share, h:val, info:val, gv: globals
   PRE [ _ctx OF tptr (Tstruct _mbedtls_md_context_t noattr),
         _md_info OF tptr (Tstruct _mbedtls_md_info_t noattr),
         _hmac OF tint]
       PROP (writable_share wsh) 
       LOCAL (temp _md_info info; temp _ctx c; temp _hmac h; gvars gv)
       SEP(data_at wsh (Tstruct _mbedtls_md_context_t noattr) md_ctx c;
             mem_mgr gv)
  POST [ tint ] EX r:_,
          PROP (r=0 \/ r=-20864) 
          LOCAL (temp ret_temp (Vint (Int.repr r)))
          SEP(if zeq r 0
              then (EX p: val, 
                         md_empty (info, (fst(snd md_ctx), p)) *
                         data_at wsh (Tstruct _mbedtls_md_context_t noattr) (info, (fst(snd md_ctx), p)) c)
             else data_at wsh (Tstruct _mbedtls_md_context_t noattr) md_ctx c;
              mem_mgr gv).

Inductive hmac256drbgabs :=
  HMAC256DRBGabs: forall (key: list byte) (V: list byte) (reseed_counter entropy_len: Z) (prediction_resistance: bool) (reseed_interval: Z), hmac256drbgabs.

Definition hmac256drbgstate: Type := (mdstate * (list val * (val * (val * (val * val)))))%type.

Definition hmac256drbg_relate (a: hmac256drbgabs) (r: hmac256drbgstate) : mpred :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               match r with (md_ctx', (V', (reseed_counter', (entropy_len', (prediction_resistance', reseed_interval'))))) =>
                            md_full key md_ctx'
                           && !! (
                                map Vubyte V = V'
                              /\ Zlength V = 32 
                              /\ Vint (Int.repr reseed_counter) = reseed_counter'
                              /\ Vint (Int.repr entropy_len) = entropy_len'
                              /\ Vint (Int.repr reseed_interval) = reseed_interval'
                              /\ Val.of_bool prediction_resistance = prediction_resistance'
                             )
               end
  end.

Definition hmac256drbgabs_entropy_len (a: hmac256drbgabs): Z :=
  match a with HMAC256DRBGabs _ _ _ entropy_len _ _ => entropy_len end.

Definition hmac256drbgabs_value (a: hmac256drbgabs): list byte :=
  match a with HMAC256DRBGabs _ V _ _ _ _ => V end.

Definition hmac256drbgabs_key (a: hmac256drbgabs): list byte :=
  match a with HMAC256DRBGabs key _ _ _ _ _ => key end.

Definition hmac256drbgabs_prediction_resistance (a: hmac256drbgabs): bool :=
  match a with HMAC256DRBGabs _ _ _ _ pr _ => pr end.

Definition hmac256drbgabs_reseed_counter (a: hmac256drbgabs): Z :=
  match a with HMAC256DRBGabs _ _ reseed_counter _ _ _ => reseed_counter end.

Definition hmac256drbgabs_reseed_interval (a: hmac256drbgabs): Z :=
  match a with HMAC256DRBGabs _ _ _ _ _ reseed_interval => reseed_interval end.

Definition hmac256drbgabs_increment_reseed_counter (a: hmac256drbgabs): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval => HMAC256DRBGabs key V (reseed_counter + 1) entropy_len prediction_resistance reseed_interval end.

Definition hmac256drbgabs_update_value (a: hmac256drbgabs) (new_value: list byte): hmac256drbgabs :=
  match a with HMAC256DRBGabs key _ reseed_counter entropy_len prediction_resistance reseed_interval => HMAC256DRBGabs key new_value reseed_counter entropy_len prediction_resistance reseed_interval end.

Definition hmac256drbgabs_update_key (a: hmac256drbgabs) (new_key: list byte): hmac256drbgabs :=
  match a with HMAC256DRBGabs _ V reseed_counter entropy_len prediction_resistance reseed_interval => HMAC256DRBGabs new_key V reseed_counter entropy_len prediction_resistance reseed_interval end.

Definition hmac256drbgabs_update_reseed_counter (a: hmac256drbgabs) (new_counter: Z): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V _ entropy_len prediction_resistance reseed_interval => HMAC256DRBGabs key V new_counter entropy_len prediction_resistance reseed_interval end.

Definition hmac256drbgabs_metadata_same (a: hmac256drbgabs) (b: hmac256drbgabs): Prop :=
  match a with HMAC256DRBGabs _ _ reseed_counter entropy_len prediction_resistance reseed_interval =>
               match b with HMAC256DRBGabs _ _ reseed_counter' entropy_len' prediction_resistance' reseed_interval' =>
                            reseed_counter = reseed_counter'
                            /\ entropy_len = entropy_len'
                            /\ prediction_resistance = prediction_resistance'
                            /\ reseed_interval = reseed_interval'
               end
  end.

Definition hmac256drbgabs_of_state_handle (a: DRBG_state_handle) entropy_len reseed_interval: hmac256drbgabs :=
  match a with ((V, key, reseed_counter),_, prediction_resistance) =>
               HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval
  end.

Definition hmac256drbgabs_to_state_handle (a: hmac256drbgabs): DRBG_state_handle :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               ((V, key, reseed_counter), 32 , prediction_resistance)
  end.

Definition hmac256drbgstate_md_info_pointer (a: hmac256drbgstate): val := fst (fst a).

Definition t_struct_mbedtls_md_info := Tstruct _mbedtls_md_info_t noattr.

Definition t_struct_hmac256drbg_context_st := Tstruct _mbedtls_hmac_drbg_context noattr.

Definition hmac256drbgabs_to_state (a: hmac256drbgabs) (old: hmac256drbgstate):hmac256drbgstate :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               match old with (md_ctx', _) =>
                            (md_ctx', (map Vubyte V, (Vint (Int.repr reseed_counter), (Vint (Int.repr entropy_len), (Val.of_bool prediction_resistance, Vint (Int.repr reseed_interval))))))
               end
  end.

Definition hmac256drbgabs_common_mpreds sh (final_state_abs: hmac256drbgabs) (old_state: hmac256drbgstate) (ctx: val) (info_contents: reptype t_struct_mbedtls_md_info): mpred :=
                  let st := hmac256drbgabs_to_state final_state_abs old_state in
                  (data_at sh t_struct_hmac256drbg_context_st st ctx) *
                  (data_at sh t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer st)) *
                  (hmac256drbg_relate final_state_abs st).

Definition hmac256drbgabs_hmac_drbg_update (a:hmac256drbgabs) (additional_data: list byte): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               let (key', V') := HMAC256_DRBG_update additional_data key V in
               HMAC256DRBGabs key' V' reseed_counter entropy_len prediction_resistance reseed_interval
  end.

Definition da_emp sh t v p := !! (p = nullval) && emp || 
                              !!(sizeof t > 0) && data_at sh t v p. 

Definition contents_with_add additional add_len contents:list byte := 
  if (andb (negb (eq_dec additional nullval)) (negb (eq_dec add_len 0))) then contents else [].

Definition hmac_drbg_update_spec :=
  DECLARE _mbedtls_hmac_drbg_update
   WITH contents: list byte,
        additional: val, sha: share, add_len: Z,
        ctx: val, shc: share, initial_state: hmac256drbgstate,
        I: hmac256drbgabs,
        info_contents: md_info_state, gv: globals
     PRE [ _ctx OF (tptr t_struct_hmac256drbg_context_st),
           _additional OF (tptr tuchar), _add_len OF tuint ]
       PROP (readable_share sha; writable_share shc;
         0 <= add_len <= Ptrofs.max_unsigned;
         Zlength (hmac256drbgabs_value I) = 32 ;
         add_len = Zlength contents \/ add_len = 0
       )
       LOCAL (temp _ctx ctx;
              temp _additional additional;
              temp _add_len (Vint (Int.repr add_len));
              gvars gv)
       SEP (
         da_emp sha (tarray tuchar (Zlength contents)) (map Vubyte contents) additional;
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx;
         hmac256drbg_relate I initial_state;
         data_at shc t_struct_mbedtls_md_info
                  info_contents (hmac256drbgstate_md_info_pointer initial_state);
         K_vector gv)
    POST [ tvoid ]
       PROP (
         )
       LOCAL ()
       SEP (
         hmac256drbgabs_common_mpreds shc
            (hmac256drbgabs_hmac_drbg_update I 
               (contents_with_add additional add_len contents))
            initial_state ctx info_contents;
         da_emp sha (tarray tuchar (Zlength contents)) (map Vubyte contents) additional;
         K_vector gv).

Definition mbedtls_HMAC256_DRBG_reseed_function (entropy_stream: ENTROPY.stream) (a:hmac256drbgabs)
           (additional_input: list byte): ENTROPY.result DRBG_state_handle :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               let sec_strength:Z := 32  in
               let state_handle: DRBG_state_handle := ((V, key, reseed_counter), sec_strength, prediction_resistance) in
               let max_additional_input_length := 256 
               in HMAC256_DRBG_reseed_function entropy_len entropy_len max_additional_input_length 
                     entropy_stream state_handle prediction_resistance additional_input
  end.

Definition hmac256drbgabs_reseed (a: hmac256drbgabs) (s: ENTROPY.stream) (additional_data: list byte) : hmac256drbgabs :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               match (mbedtls_HMAC256_DRBG_reseed_function s a additional_data) with
                 | ENTROPY.success ((V', key', reseed_counter'), _, pr') _ =>
                   HMAC256DRBGabs key' V' reseed_counter' entropy_len pr' reseed_interval
                 | ENTROPY.error _ _ => a
               end
  end.

Definition get_stream_result {X} (result: ENTROPY.result X): ENTROPY.stream :=
  match result with
    | ENTROPY.success _ s => s
    | ENTROPY.error _ s => s
  end.

Definition result_success {X} (result: ENTROPY.result X): Prop :=
  match result with
    | ENTROPY.success _ _ => True
    | ENTROPY.error _ _ => False
  end.

Parameter ENT_GenErr: Z.
Parameter ENT_GenErrAx: Vzero <> Vint (Int.repr ENT_GenErr)  /\ Int.repr ENT_GenErr <> Int.repr (-20864).

Definition return_value_relate_result {X} (result: ENTROPY.result X) (ret_value: val): Prop :=
  match result with
    | ENTROPY.error e _ => match e with
                             | ENTROPY.generic_error => ret_value = Vint (Int.repr ENT_GenErr) 
                             | ENTROPY.catastrophic_error => ret_value = Vint (Int.repr (-9))
                           end
    | ENTROPY.success _ _ => ret_value = Vzero
  end.

Parameter Stream: ENTROPY.stream -> mpred.

Definition reseedPOST rv (contents : list byte) additional sha add_len s
          I ctx shc
          info_contents gv (initial_state: reptype t_struct_hmac256drbg_context_st):=
  if ((zlt 256 add_len) || (zlt 384 (hmac256drbgabs_entropy_len I + add_len)))%bool
  then (!!(rv = Vint (Int.neg (Int.repr 5))) &&
       (da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional *
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx *
         hmac256drbg_relate I initial_state *
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state) *
         Stream s * K_vector gv))
  else (!!(return_value_relate_result (mbedtls_HMAC256_DRBG_reseed_function s I 
            (contents_with_add additional add_len contents)) rv)
        && (hmac256drbgabs_common_mpreds shc (hmac256drbgabs_reseed I s 
             (contents_with_add additional add_len contents)) initial_state ctx info_contents *
         da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional *
         Stream (get_stream_result (mbedtls_HMAC256_DRBG_reseed_function s I (contents_with_add additional add_len contents))) *
         spec_sha.K_vector gv)).

Definition hmac_drbg_reseed_spec :=
  DECLARE _mbedtls_hmac_drbg_reseed
   WITH contents: list byte,
        additional: val, sha: share, add_len: Z,
        ctx: val, shc: share, initial_state: hmac256drbgstate,
        I: hmac256drbgabs,
        info_contents: md_info_state,
        s: ENTROPY.stream, gv: globals
    PRE [ _ctx OF (tptr t_struct_hmac256drbg_context_st), _additional OF (tptr tuchar), _len OF tuint ]
       PROP (readable_share sha; writable_share shc;
         0 <= add_len <= Ptrofs.max_unsigned;
         Zlength (hmac256drbgabs_value I) = 32 ;
         add_len = Zlength contents;
         0 <= hmac256drbgabs_entropy_len I; 
         hmac256drbgabs_entropy_len I+ Zlength contents < Ptrofs.modulus;
         0 < hmac256drbgabs_entropy_len I + Zlength (contents_with_add additional add_len contents) < Ptrofs.modulus
       )
       LOCAL (temp _ctx ctx; temp _additional additional; temp _len (Vint (Int.repr add_len)); gvars gv)
       SEP (
         da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional;
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx;
         hmac256drbg_relate I initial_state;
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state);
         Stream s;
         K_vector gv)
    POST [ tint ]
       EX ret_value:_,
       PROP ()
       LOCAL (temp ret_temp ret_value)
       SEP (reseedPOST ret_value contents additional sha add_len s
          I ctx shc
          info_contents gv initial_state).

Definition mbedtls_HMAC256_DRBG_generate_function (entropy_stream: ENTROPY.stream) (a:hmac256drbgabs) 
            (requested_number_of_bytes: Z) (additional_input: list byte): ENTROPY.result (list byte * DRBG_state_handle) :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               HMAC256_DRBG_generate_function (HMAC256_DRBG_reseed_function entropy_len entropy_len 256) 
                       reseed_interval 
                      1024 
                      256  
                      entropy_stream
                      ((V, key, reseed_counter), 
                        32 , 
                        prediction_resistance) 
                      requested_number_of_bytes 
                      32 
                      prediction_resistance additional_input
  end.

Definition hmac256drbgabs_generate (a: hmac256drbgabs) (s: ENTROPY.stream) (bytes: Z) (additional_data: list byte) : hmac256drbgabs :=
  match a with HMAC256DRBGabs key V reseed_counter entropy_len prediction_resistance reseed_interval =>
               match (mbedtls_HMAC256_DRBG_generate_function s a bytes additional_data) with
                 | ENTROPY.success (_, ((V', key', reseed_counter'), _, pr')) _ =>
                   HMAC256DRBGabs key' V' reseed_counter' entropy_len pr' reseed_interval
                 | ENTROPY.error _ _ => a
               end
  end.

Definition generatePOST ret_value (contents: list byte) additional sha add_len output sho out_len ctx shc initial_state I gv info_contents s :=
if out_len >? 1024
then (!!(ret_value = Vint (Int.neg (Int.repr 3))) &&
       (data_at_ sho (tarray tuchar out_len) output *
         da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional *
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx *
         hmac256drbg_relate I initial_state *
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state) *
         Stream s *
         K_vector gv))
else
  if (add_len >? 256)
  then (!!(ret_value = Vint (Int.neg (Int.repr 5))) &&
       (data_at_ sho (tarray tuchar out_len) output *
         da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional *
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx *
         hmac256drbg_relate I initial_state *
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state) *
         Stream s *
         K_vector gv))
  else let g := (mbedtls_HMAC256_DRBG_generate_function s I out_len (contents_with_add additional add_len contents))
       in (!!(return_value_relate_result g ret_value)) &&
          (match g with
            | ENTROPY.error _ _ => (data_at_ sho (tarray tuchar out_len) output)
            | ENTROPY.success (bytes, _) _ => (data_at sho (tarray tuchar out_len) (map Vubyte bytes) output)
          end *
          hmac256drbgabs_common_mpreds shc (hmac256drbgabs_generate I s out_len (contents_with_add additional add_len contents)) initial_state ctx info_contents *
          da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional *
          Stream (get_stream_result g) *
          K_vector gv).

Definition  RI_range (z:Z): Prop:= 0 < z /\ z+1 < Int.max_signed. 

Definition hmac_drbg_generate_spec :=
  DECLARE _mbedtls_hmac_drbg_random_with_add
   WITH contents: list byte,
        additional: val, sha: share, add_len: Z,
        output: val, sho: share, out_len: Z,
        ctx: val, shc: share, initial_state: hmac256drbgstate,
        I: hmac256drbgabs,
        info_contents: md_info_state,
        s: ENTROPY.stream, gv: globals
    PRE [ _p_rng OF (tptr tvoid), _output OF (tptr tuchar), _out_len OF tuint, _additional OF (tptr tuchar), _add_len OF tuint ]
       PROP (readable_share sha; writable_share shc; writable_share sho;
         0 <= add_len <= Ptrofs.max_unsigned;
         0 <= out_len <= Ptrofs.max_unsigned;
         Zlength (hmac256drbgabs_value I) = 32 ;
         add_len = Zlength contents;
         0 < hmac256drbgabs_entropy_len I; 
         hmac256drbgabs_entropy_len I + Zlength contents <= 384;

         RI_range (hmac256drbgabs_reseed_interval I) /\
         0 <= hmac256drbgabs_reseed_counter I < Int.max_signed
       )
       LOCAL (temp _p_rng ctx; temp _output output; temp _out_len (Vint (Int.repr out_len)); 
              temp _additional additional; temp _add_len (Vint (Int.repr add_len)); gvars gv)
       SEP (
         data_at_ sho (tarray tuchar out_len) output;
         da_emp sha (tarray tuchar add_len) (map Vubyte contents) additional;
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx;
         hmac256drbg_relate I initial_state;
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state);
         Stream s;
         K_vector gv)
    POST [ tint ]
       EX ret_value:_,
       PROP ()
       LOCAL (temp ret_temp ret_value)
       SEP (generatePOST ret_value contents additional sha add_len output sho out_len ctx shc initial_state I gv info_contents s).

Definition hmac_drbg_seed_buf_spec :=
  DECLARE _mbedtls_hmac_drbg_seed_buf
   WITH ctx: val, shc: share, info:val, d_len: Z, data:val, shd: share, Data: list byte,
        Ctx: hmac256drbgstate,
        CTX: hmac256drbgabs,
        Info: md_info_state, gv: globals
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr),
         _md_info OF (tptr (Tstruct _mbedtls_md_info_t noattr)),
         _data OF tptr tuchar, _data_len OF tuint ]
       PROP (writable_share shc; readable_share shd;
                 (d_len = Zlength Data \/ d_len=0) /\
              0 <= d_len <= Ptrofs.max_unsigned)
       LOCAL (temp _ctx ctx; temp _md_info info;
              temp _data_len (Vint (Int.repr d_len)); temp _data data; gvars gv)
       SEP (data_at shc t_struct_hmac256drbg_context_st Ctx ctx;
         hmac256drbg_relate CTX Ctx;
         data_at shc t_struct_mbedtls_md_info Info info;
         da_emp shd (tarray tuchar (Zlength Data)) (map Vubyte Data) data;
         K_vector gv; mem_mgr gv)
    POST [ tint ]
       EX ret_value:_,
       PROP ()
       LOCAL (temp ret_temp ret_value)
       SEP (data_at shc t_struct_mbedtls_md_info Info info *
            da_emp shd (tarray tuchar (Zlength Data)) (map Vubyte Data) data *
            K_vector gv;
            if Val.eq ret_value (Vint (Int.repr (-20864)))
            then data_at shc t_struct_hmac256drbg_context_st Ctx ctx *
                 hmac256drbg_relate CTX Ctx
            else match Ctx, CTX
                         with (mds, (V', (RC', (EL', (PR', RI'))))),
                              HMAC256DRBGabs key V RC EL PR RI
                         => EX KEY:list byte, EX VAL:list byte, EX p:val,
                          !!(HMAC256_DRBG_update (contents_with_add data d_len Data) V (list_repeat 32 Byte.one) = (KEY, VAL))
                             && md_full key mds *
                                data_at shc t_struct_hmac256drbg_context_st ((info, (fst(snd mds), p)), (map Vubyte VAL, (RC', (EL', (PR', RI'))))) ctx *
                                hmac256drbg_relate (HMAC256DRBGabs KEY VAL RC EL PR RI) ((info, (fst(snd mds), p)), (map Vubyte VAL, (RC', (EL', (PR', RI')))))
                        end;
            mem_mgr gv).

Definition GetEntropy_PostSep sh len s buf :=
  match ENTROPY.get_bytes (Z.to_nat len) s with
            | ENTROPY.error _ _ => memory_block sh len buf
            | ENTROPY.success bytes _ =>
              data_at sh (tarray tuchar len) (map Vubyte bytes) buf
                 end.

Definition get_entropy_spec :=
  DECLARE _get_entropy
   WITH
        sh: share,
        s: ENTROPY.stream,
        buf: val, len: Z
    PRE [ 1%positive OF (tptr tuchar), 2%positive OF tuint ]
       PROP (
         0 <= len <= Ptrofs.max_unsigned;
         writable_share sh
       )
       LOCAL (temp 1%positive buf; temp 2%positive (Vint (Int.repr len)))
       SEP (
         memory_block sh len buf;
         (Stream s)
           )
    POST [ tint ]
       EX ret_value:_,
       PROP (
           return_value_relate_result (get_entropy 0 len len false s) ret_value
         )
       LOCAL (temp ret_temp ret_value)
       SEP (
         Stream (get_stream_result (get_entropy 0 len len false s));
         GetEntropy_PostSep sh len s buf
                ).

Definition size_of_HMACDRBGCTX:Z:= sizeof (Tstruct _mbedtls_hmac_drbg_context noattr).

Definition hmac_drbg_init_spec :=
  DECLARE _mbedtls_hmac_drbg_init
   WITH c : val, shc: share
   PRE [ _ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr) ]
         PROP (writable_share shc) 
         LOCAL (temp _ctx c)
         SEP(memory_block shc size_of_HMACDRBGCTX c)
  POST [ tvoid ]  
          PROP () 
          LOCAL ()
          SEP(data_at shc (tarray tuchar size_of_HMACDRBGCTX)
                (list_repeat (Z.to_nat size_of_HMACDRBGCTX) (Vint Int.zero)) c).

Definition hmac_drbg_random_spec :=
  DECLARE _mbedtls_hmac_drbg_random
   WITH output: val, sho: share, out_len: Z,
        ctx: val, shc: share, initial_state: hmac256drbgstate,
        I: hmac256drbgabs,
        info_contents: md_info_state,
        s: ENTROPY.stream, gv: globals
    PRE [_p_rng OF tptr tvoid, _output OF tptr tuchar, _out_len OF tuint ]
       PROP (writable_share sho; writable_share shc;
         0 <= out_len <= Ptrofs.max_unsigned;
         Zlength (hmac256drbgabs_value I) = 32 ;
         0 < hmac256drbgabs_entropy_len I <= 384;
         RI_range (hmac256drbgabs_reseed_interval I);
         0 <= hmac256drbgabs_reseed_counter I < Int.max_signed)
       LOCAL (temp _p_rng ctx; temp _output output;
              temp _out_len (Vint (Int.repr out_len)); gvars gv)
       SEP (
         data_at_ sho (tarray tuchar out_len) output;
         data_at shc t_struct_hmac256drbg_context_st initial_state ctx;
         hmac256drbg_relate I initial_state;
         data_at shc t_struct_mbedtls_md_info info_contents (hmac256drbgstate_md_info_pointer initial_state);
         Stream s;
         K_vector gv)
    POST [ tint ]
       EX ret_value:_,
       PROP ()
       LOCAL (temp ret_temp ret_value)
       SEP (generatePOST ret_value nil nullval Tsh 0 output sho out_len ctx shc initial_state I gv info_contents s).

Definition max_personalization_string_length: Z := 336.  

Definition max_elength: Z:= 2^32. 

Definition instantiate_function_256  (es: ENTROPY.stream) (prflag: bool)
            (pers_string: list byte): ENTROPY.result DRBG_state_handle :=
   if (Zlength pers_string) >? max_personalization_string_length 
   then ENTROPY.error ENTROPY.generic_error es
   else let secStrength := 32
        in  match get_entropy (secStrength+secStrength/2) (secStrength+secStrength/2) max_elength prflag es
            with ENTROPY.error e s' => ENTROPY.error ENTROPY.catastrophic_error s'
               | ENTROPY.success entropy s' =>
                   let initial_working_state := HMAC256_DRBG_instantiate_algorithm entropy nil pers_string secStrength
                   in ENTROPY.success (initial_working_state, secStrength, prflag) s'                    
            end.

Inductive hmac_any:=
  hmac_any_empty: hmac_any
| hmac_any_rep: forall key data : list byte, hmac_any
| hmac_any_full: forall k:list byte, hmac_any.

Definition hmac_interp (d:hmac_any) (r: mdstate):mpred :=
  match d with
    hmac_any_empty => md_empty r
  | hmac_any_rep key data => md_relate key data r
  | hmac_any_full k => md_full k r
  end.

Definition preseed_relate d rc pr ri (r : hmac256drbgstate):mpred:=
    match r with
     (md_ctx', (V', (reseed_counter', (entropy_len', (prediction_resistance', reseed_interval'))))) =>
    hmac_interp d md_ctx' &&
    !! (map Vubyte initial_key = V' /\
        (Vint (Int.repr rc) = reseed_counter')  
         /\
        Vint (Int.repr ri) = reseed_interval' /\
        Val.of_bool pr = prediction_resistance')
   end.

Definition hmac_drbg_seed_inst256_spec :=
  DECLARE _mbedtls_hmac_drbg_seed
   WITH dp:_, ctx: val, shc: share, info:val, len: Z, data:val, shd: share, Data: list byte,
        Ctx: hmac256drbgstate,
        Info: md_info_state, s:ENTROPY.stream, rc:Z, pr_flag:bool, ri:Z,
        handle_ss: DRBG_state_handle * ENTROPY.stream, gv: globals
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr),
         _md_info OF tptr (Tstruct _mbedtls_md_info_t noattr),
         _custom OF tptr tuchar, _len OF tuint ]
       PROP (writable_share shc; readable_share shd;
             len = Zlength Data /\ 0 <= len <=256 /\ 
             instantiate_function_256 s pr_flag (contents_with_add data (Zlength Data) Data)
               = ENTROPY.success (fst handle_ss) (snd handle_ss))
       LOCAL (temp _ctx ctx; temp _md_info info;
              temp _len (Vint (Int.repr len)); temp _custom data; gvars gv)
       SEP (
         data_at shc t_struct_hmac256drbg_context_st Ctx ctx;
         preseed_relate dp rc pr_flag ri Ctx;
         data_at shc t_struct_mbedtls_md_info Info info;
         da_emp shd (tarray tuchar (Zlength Data)) (map Vubyte Data) data;
         K_vector gv; Stream s; mem_mgr gv)
    POST [ tint ]
       EX ret_value:_,
       PROP ()
       LOCAL (temp ret_temp (Vint ret_value))
       SEP (data_at shc t_struct_mbedtls_md_info Info info;
            da_emp shd (tarray tuchar (Zlength Data)) (map Vubyte Data) data;
            K_vector gv;
            if Int.eq ret_value (Int.repr (-20864))
            then data_at shc t_struct_hmac256drbg_context_st Ctx ctx *
                 preseed_relate dp rc pr_flag ri Ctx * Stream s
            else !!(ret_value = Int.zero) && 
                 md_empty (fst Ctx) *
                 EX p:val, 
                 match (fst Ctx, fst handle_ss) with
                     ((M1, (M2, M3)), ((((newV, newK), newRC), newEL), newPR)) =>
                   let CtxFinal := ((info, (M2, p)),
                                            (map Vubyte newV, (Vint (Int.repr newRC), (Vint (Int.repr 32), (Val.of_bool newPR, Vint (Int.repr 10000)))))) 
                   in data_at shc t_struct_hmac256drbg_context_st CtxFinal ctx *
                      hmac256drbg_relate (HMAC256DRBGabs newK newV newRC 32 newPR 10000) CtxFinal *
                      Stream (snd handle_ss) 
                end;
             mem_mgr gv).

Definition setPR_ABS res (a: hmac256drbgabs): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V x el r reseed_interval => 
               HMAC256DRBGabs key V x el res reseed_interval
  end.

Definition setPR_CTX res (r: hmac256drbgstate): hmac256drbgstate :=
  match r with (md_ctx, (V, (rc, (el, (r, ri))))) => 
               (md_ctx, (V, (rc, (el, (res, ri))))) 
  end.

Definition hmac_drbg_setPredictionResistance_spec :=
  DECLARE _mbedtls_hmac_drbg_set_prediction_resistance 
   WITH ctx:val, shc: share, CTX:hmac256drbgstate, ABS:_, r:bool
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr),
         _resistance OF tint ]
       PROP ( writable_share shc)
       LOCAL (temp _ctx ctx; temp _resistance (Val.of_bool r))
       SEP (data_at shc t_struct_hmac256drbg_context_st CTX ctx;
            hmac256drbg_relate ABS CTX)
    POST [ tvoid ]
       PROP () 
       LOCAL ()
       SEP (data_at shc t_struct_hmac256drbg_context_st (setPR_CTX (Val.of_bool r) CTX) ctx;
            hmac256drbg_relate (setPR_ABS r ABS) (setPR_CTX (Val.of_bool r) CTX)).

Definition setEL_ABS el (a: hmac256drbgabs): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V x _ pr reseed_interval => 
               HMAC256DRBGabs key V x el pr reseed_interval
  end.

Definition setEL_CTX el (r: hmac256drbgstate): hmac256drbgstate :=
  match r with (md_ctx, (V, (rc, (_, (pr, ri))))) => 
               (md_ctx, (V, (rc, (el, (pr, ri))))) 
  end.

Definition hmac_drbg_setEntropyLen_spec :=
  DECLARE _mbedtls_hmac_drbg_set_entropy_len
   WITH ctx:val, shc: share, CTX:hmac256drbgstate, ABS:_, l:_
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr),
         _len OF tuint ]
       PROP (writable_share shc )
       LOCAL (temp _ctx ctx; temp _len (Vint (Int.repr l)))
       SEP (data_at shc t_struct_hmac256drbg_context_st CTX ctx;
            hmac256drbg_relate ABS CTX)
    POST [ tvoid ]
       PROP () 
       LOCAL ()
       SEP (data_at shc t_struct_hmac256drbg_context_st (setEL_CTX (Vint (Int.repr l)) CTX) ctx;
            hmac256drbg_relate (setEL_ABS l ABS) (setEL_CTX (Vint (Int.repr l)) CTX)).

Definition setRI_ABS ri (a: hmac256drbgabs): hmac256drbgabs :=
  match a with HMAC256DRBGabs key V x el pr _ => 
               HMAC256DRBGabs key V x el pr ri
  end.

Definition setRI_CTX ri (r: hmac256drbgstate): hmac256drbgstate :=
  match r with (md_ctx, (V, (rc, (el, (pr, _))))) => 
               (md_ctx, (V, (rc, (el, (pr, ri))))) 
  end.

Definition hmac_drbg_setReseedInterval_spec :=
  DECLARE _mbedtls_hmac_drbg_set_reseed_interval
   WITH ctx:val, shc: share, CTX:hmac256drbgstate, ABS:_, l:_
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr),
         _interval OF tint ]
       PROP (writable_share shc )
       LOCAL (temp _ctx ctx; temp _interval (Vint (Int.repr l)))
       SEP (data_at shc t_struct_hmac256drbg_context_st CTX ctx;
            hmac256drbg_relate ABS CTX)
    POST [ tvoid ]
       PROP () 
       LOCAL ()
       SEP (data_at shc t_struct_hmac256drbg_context_st (setRI_CTX (Vint (Int.repr l)) CTX) ctx;
            hmac256drbg_relate (setRI_ABS l ABS) (setRI_CTX (Vint (Int.repr l)) CTX)).

Definition hmac_drbg_free_spec :=
  DECLARE _mbedtls_hmac_drbg_free
   WITH ctx:val, shc: share, CTX:hmac256drbgstate, ABS:_, gv: globals
    PRE [_ctx OF tptr (Tstruct _mbedtls_hmac_drbg_context noattr) ]
       PROP (writable_share shc )
       LOCAL (temp _ctx ctx; gvars gv)
       SEP (da_emp shc t_struct_hmac256drbg_context_st CTX ctx;
            if Val.eq ctx nullval then emp else
                 hmac256drbg_relate ABS CTX;
             mem_mgr gv)
    POST [ tvoid ] 
      EX vret:unit, PROP ()
       LOCAL ()
       SEP (if Val.eq ctx nullval then emp else data_block shc (list_repeat (Z.to_nat size_of_HMACDRBGCTX) Byte.zero) ctx;
              mem_mgr gv).

Definition HmacDrbgVarSpecs : varspecs := (sha._K256, tarray tuint 64)::nil.

Definition ndfs_merge fA cA A PA QA FSA (HFSA: FSA = NDmk_funspec fA cA A PA QA) 
                    fB cB B PB QB FSB (HFSB: FSB = NDmk_funspec fB cB B PB QB): option funspec.

Definition hmac_init_funspec:=
    (WITH x : val * share * Z * list byte * globals + val * share * Z * list byte * block * ptrofs * share * globals
     PRE
     [(hmac._ctx, tptr spec_hmac.t_struct_hmac_ctx_st), (hmac._key, tptr tuchar),
     (hmac._len, tint)] match x with
                        | inl (c, sh, l, key, gv) =>
                            PROP (writable_share sh)
                            LOCAL (temp hmac._ctx c; temp hmac._key nullval;
                            temp hmac._len (Vint (Int.repr l)); 
                            gvars gv)
                            SEP (UNDER_SPEC.FULL sh key c;
                            spec_sha.K_vector gv)
                        | inr (c, sh, l, key, b0, i, shk, gv) =>
                            PROP (writable_share sh; readable_share shk; spec_hmac.has_lengthK l key)
                            LOCAL (temp hmac._ctx c; temp hmac._key (Vptr b0 i);
                            temp hmac._len (Vint (Int.repr l)); 
                            gvars gv)
                            SEP (UNDER_SPEC.EMPTY sh c;
                            data_block shk key (Vptr b0 i); 
                            spec_sha.K_vector gv)
                        end
     POST [tvoid] match x with
                  | inl (c, sh, _, key, gv) =>
                      PROP ( )
                      LOCAL ()
                      SEP (UNDER_SPEC.REP sh
                             (UNDER_SPEC.hABS key []) c;
                      spec_sha.K_vector gv)
                  | inr (c, sh, _, key, b0, i, shk, gv) =>
                      PROP ( )
                      LOCAL ()
                      SEP (UNDER_SPEC.REP sh
                             (UNDER_SPEC.hABS key []) c;
                      data_block shk key (Vptr b0 i); 
                      spec_sha.K_vector gv)
                  end).

Lemma hmac_init_merge: 
  ndfs_merge _ _ _ _ _ (snd UNDER_SPEC.hmac_reset_spec) (eq_refl _)

Definition HmacDrbgFunSpecs : funspecs :=  ltac:(with_library prog (
  md_free_spec ::hmac_drbg_free_spec::mbedtls_zeroize_spec::
  hmac_drbg_setReseedInterval_spec::hmac_drbg_setEntropyLen_spec::
  hmac_drbg_setPredictionResistance_spec::hmac_drbg_random_spec::hmac_drbg_init_spec::
  hmac_drbg_seed_inst256_spec::
  hmac_drbg_update_spec::
  hmac_drbg_reseed_spec::
  hmac_drbg_generate_spec::hmac_drbg_seed_buf_spec ::
  get_entropy_spec::
  md_reset_spec::md_final_spec::md_update_spec::
  md_starts_spec::md_setup_spec::md_get_size_spec::

  UNDER_SPEC.hmac_update_spec::
  UNDER_SPEC.hmac_final_spec:: 
  (hmac._HMAC_Init,hmac_init_funspec)::

  drbg_memcpy_spec:: drbg_memset_spec::
  sha.spec_hmac.sha256init_spec::sha.spec_hmac.sha256update_spec::sha.spec_hmac.sha256final_spec::nil)). *)
Require Import VST.floyd.functional_base.

Require Import FCF.HMAC_DRBG_nonadaptive.
Require Import sha.ByteBitRelations.
(* sha.ByteBitRelations:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.ZArith.BinInt. 
Require Import Coq.ZArith.Zcomplements. 
Require Import compcert.lib.Integers.          
Require Import Coq.Numbers.Natural.Peano.NPeano.

Require Import Coq.Strings.Ascii.
Require Import Coq.Program.Tactics.
Require Import sha.XorCorrespondence. 
Require Import sha.Bruteforce.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.

Definition Blist := list bool.
Open Scope Z_scope.

Inductive InBlocks {A : Type} (n : nat) : list A -> Prop :=
  | InBlocks_nil : InBlocks n []
  | InBlocks_block : forall (front back full : list A),
                   length front = n ->
                   full = front ++ back ->
                   InBlocks n back ->
                   InBlocks n full.

Lemma InBlocks_len : forall {A : Type} (l : list A) (n : nat),
                       PeanoNat.Nat.divide (n) (length l) -> InBlocks n l.

Inductive bytes_bits_lists : Blist -> list byte -> Prop :=
  | eq_empty : bytes_bits_lists nil nil
  | eq_cons : forall (bits : Blist) (bytes : list byte)
                     (b0 b1 b2 b3 b4 b5 b6 b7 : bool) (b : byte),
                bytes_bits_lists bits bytes ->
                convertByteBits [b0; b1; b2; b3; b4; b5; b6; b7] b ->
                bytes_bits_lists (b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: bits)
                                 (b :: bytes).

Definition div_mod (num : Z) (denom : Z) : bool * Z :=
  (Z.gtb (num / denom) 0, num mod denom).

Definition byteToBits (byte : byte) : Blist :=
  let (b7, rem7) := div_mod (Byte.unsigned byte) 128 in
  let (b6, rem6) := div_mod rem7 64 in
  let (b5, rem5) := div_mod rem6 32 in
  let (b4, rem4) := div_mod rem5 16 in
  let (b3, rem3) := div_mod rem4 8 in
  let (b2, rem2) := div_mod rem3 4 in
  let (b1, rem1) := div_mod rem2 2 in
  let (b0, rem0) := div_mod rem1 1 in
  [b0; b1; b2; b3; b4; b5; b6; b7].

Fixpoint bytesToBits (bytes : list byte) : Blist :=
  match bytes with
    | [] => []
    | byte :: xs => byteToBits byte ++ bytesToBits xs
  end.

Definition bitsToByte (bits : Blist) : byte :=
  Byte.repr 
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: nil =>
      (1 * (asZ b0) + 2 * (asZ b1) + 4 * (asZ b2) + 8 * (asZ b3)
      + 16 * (asZ b4) + 32 * (asZ b5) + 64 * (asZ b6) + 128 * (asZ b7))
    | _ => -1                  
  end.

Fixpoint bitsToBytes (bits : Blist) : list byte :=
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs =>
      bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] :: bitsToBytes xs
    | _ => []
  end.

Lemma byteToBits_length bt: length (byteToBits bt) = 8%nat.

Lemma bytes_bits_length : forall (bits : Blist) (bytes : list byte),
  bytes_bits_lists bits bytes -> length bits = (length bytes * 8)%nat.

Lemma bytesToBits_app : forall (l1 l2 : list byte),
                          bytesToBits (l1 ++ l2) = bytesToBits l1 ++ bytesToBits l2.

Lemma bytesToBits_len : forall (l : list byte),
                          length (bytesToBits l) = (length l * 8)%nat.

Theorem byte_bit_byte_id : forall (b : byte),
                                bitsToByte (byteToBits b) = b.

Theorem bits_byte_bits_id : forall (b0 b1 b2 b3 b4 b5 b6 b7 : bool),
                              [b0; b1; b2; b3; b4; b5; b6; b7] =
                              byteToBits (bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7]).

Theorem bytes_bits_bytes_id : forall (bytes : list byte),
                                bitsToBytes (bytesToBits bytes) = bytes.

Theorem bytes_bits_def_eq : forall (bytes : list byte),
                              bytes_bits_lists (bytesToBits bytes) bytes.

Theorem bytes_bits_comp_ind : forall (bits : Blist) (bytes : list byte),
                               bits = bytesToBits bytes ->
                               bytes_bits_lists bits bytes.

Theorem bytes_bits_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bytes = bitsToBytes bits.

Theorem bits_bytes_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bits = bytesToBits bytes.

Lemma bitsToBytes_app : forall (l m : Blist),
                          InBlocks 8 l ->
                          bitsToBytes (l ++ m) = bitsToBytes l ++ bitsToBytes m.

Lemma bitsToBytes_len_gen : forall (l : Blist) (n : nat),
                          length l = (n * 8)%nat ->
                          length (bitsToBytes l) = n.

Lemma bitsToBytes_len : forall (l : Blist),
                          length l = 512%nat ->
                          Zlength (bitsToBytes l) = 64%Z.

Lemma bits_bytes_bits_id : forall (l : Blist),
                             InBlocks 8 l ->
                             bytesToBits (bitsToBytes l) = l.

Lemma bytes_bits_lists_append:
  forall (l1 : Blist) (l2 : list byte) (m1 : Blist) (m2 : list byte),
    bytes_bits_lists l1 l2
    -> bytes_bits_lists m1 m2
    -> bytes_bits_lists (l1 ++ m1) (l2 ++ m2).

Lemma bytesToBits_nil_inv l: nil = bytesToBits l -> l = nil.

Lemma bytesToBits_cons b l:
      bytesToBits (b::l) = byteToBits b ++ bytesToBits l.

Lemma byteToBits_injective: forall a b,
      byteToBits a = byteToBits b ->
      a = b.

Lemma bytesToBits_injective: forall b1 b2, bytesToBits b1 = bytesToBits b2 ->
       b1=b2.

Lemma bitsToBytes_injective8 b1 b2 (B: bitsToBytes b1 = bitsToBytes b2)
       (L1: PeanoNat.Nat.divide 8 (length b1))

Lemma bitsToByte_cons: forall bits h t, (h::t) = bitsToBytes bits ->
      exists b0, exists b1, exists b2, exists b3,
      exists b4, exists b5, exists b6, exists b7, exists xs,
      bits = b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs /\
      h = bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] /\
      t = bitsToBytes xs.

Definition intsToBits (l : list Int.int) : list bool :=
  bytesToBits (intlist_to_bytelist l).

Definition bitsToInts (l : Blist) : list Int.int :=
  bytelist_to_intlist (bitsToBytes l). *)
Require Import BinInt.
Require Import hmacdrbg.DRBG_functions.
(* hmacdrbg.DRBG_functions:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import hmacdrbg.entropy.
Require Import VST.floyd.functional_base.

Definition DRBG_working_state: Type := (list byte * list byte * Z)%type. 
Definition DRBG_state_handle: Type := (DRBG_working_state * Z * bool)%type. 

Definition DRBG_instantiate_function
            (instantiate_algorithm: list byte -> list byte -> list byte -> Z -> DRBG_working_state)
            (min_entropy_length max_entropy_length: Z) (provided_nonce: option (list byte))
            (highest_supported_security_strength: Z) (max_personalization_string_length: Z)
            (prediction_resistance_supported: bool) (entropy_stream: ENTROPY.stream)
            (requested_instantiation_security_strength: Z) (prediction_resistance_flag: bool)
            (personalization_string: list byte): ENTROPY.result DRBG_state_handle :=
  if requested_instantiation_security_strength >? highest_supported_security_strength then ENTROPY.error ENTROPY.generic_error entropy_stream
  else match prediction_resistance_flag, prediction_resistance_supported with
         | true, false => ENTROPY.error ENTROPY.generic_error entropy_stream
         | _,_ =>
           if (Zlength personalization_string) >? max_personalization_string_length then ENTROPY.error ENTROPY.generic_error entropy_stream
           else
             let security_strength := if requested_instantiation_security_strength <=? 14 then Some 14
                                      else if requested_instantiation_security_strength <=? 16 then Some 16
                                      else if requested_instantiation_security_strength <=? 24 then Some 24
                                      else if requested_instantiation_security_strength <=? 32 then Some 32
                                      else None in
             match security_strength with
               | None => ENTROPY.error ENTROPY.generic_error entropy_stream
               | Some security_strength =>
               match get_entropy security_strength min_entropy_length max_entropy_length prediction_resistance_flag entropy_stream with
                 | ENTROPY.error e s' => ENTROPY.error ENTROPY.catastrophic_error s'
                 | ENTROPY.success entropy_input entropy_stream =>
                   let nonce_result := match provided_nonce with
                                         | Some n => ENTROPY.success n entropy_stream
                                         | None => get_entropy (security_strength/2) (min_entropy_length/2) (max_entropy_length/2)
                                                               prediction_resistance_flag entropy_stream
                                       end in
                   match nonce_result with
                     | ENTROPY.error e s' => ENTROPY.error ENTROPY.catastrophic_error s'
                     | ENTROPY.success nonce entropy_stream =>
                       let initial_working_state := instantiate_algorithm entropy_input nonce personalization_string security_strength in
                       ENTROPY.success (initial_working_state, security_strength, prediction_resistance_flag) entropy_stream
                   end
               end
             end
       end.

Definition DRBG_reseed_function (reseed_algorithm: DRBG_working_state -> list byte -> list byte -> DRBG_working_state)
            (min_entropy_length max_entropy_length: Z) (max_additional_input_length: Z)
            (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle)
            (prediction_resistance_request: bool) (additional_input: list byte): ENTROPY.result DRBG_state_handle :=
  match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
  if prediction_resistance_request && (negb prediction_resistance_flag) then ENTROPY.error ENTROPY.generic_error entropy_stream
  else
    if Zlength additional_input >? max_additional_input_length then ENTROPY.error ENTROPY.generic_error entropy_stream
    else
      match get_entropy security_strength min_entropy_length max_entropy_length prediction_resistance_request entropy_stream with
        | ENTROPY.error _ s => ENTROPY.error ENTROPY.catastrophic_error s
        | ENTROPY.success entropy_input entropy_stream =>
          let new_working_state := reseed_algorithm working_state entropy_input additional_input in
          ENTROPY.success (new_working_state, security_strength, prediction_resistance_flag) entropy_stream
      end
  end.

Inductive DRBG_generate_algorithm_result :=
| generate_algorithm_reseed_required: DRBG_generate_algorithm_result
| generate_algorithm_success: list byte -> DRBG_working_state -> DRBG_generate_algorithm_result.

Fixpoint DRBG_generate_function_helper (generate_algorithm: DRBG_working_state -> Z -> list byte -> DRBG_generate_algorithm_result)
          (reseed_function: ENTROPY.stream -> DRBG_state_handle -> bool -> list byte -> ENTROPY.result DRBG_state_handle)
          (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle) (requested_number_of_bytes: Z)
          (prediction_resistance_request: bool) (additional_input: list byte) (should_reseed: bool) (count: nat): ENTROPY.result (list byte * DRBG_working_state) :=
  let result := if should_reseed then
                        match reseed_function entropy_stream state_handle prediction_resistance_request additional_input with
                          | ENTROPY.success x entropy_stream => ENTROPY.success (x, []) entropy_stream
                          | ENTROPY.error e entropy_stream => ENTROPY.error e entropy_stream
                        end
                      else ENTROPY.success (state_handle, additional_input) entropy_stream in
  match result with
    | ENTROPY.error e s => ENTROPY.error e s
    | ENTROPY.success (state_handle, additional_input) entropy_stream =>
      match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
        match generate_algorithm working_state requested_number_of_bytes additional_input with
          | generate_algorithm_reseed_required =>
            match count with
              | O => ENTROPY.error ENTROPY.generic_error entropy_stream 
              | S count' => DRBG_generate_function_helper generate_algorithm reseed_function
                                entropy_stream state_handle requested_number_of_bytes
                                prediction_resistance_request additional_input true count'
            end
          | generate_algorithm_success x y => ENTROPY.success (x, y) entropy_stream
        end
      end
    end.

Definition DRBG_generate_function (generate_algorithm: Z -> DRBG_working_state -> Z -> list byte -> DRBG_generate_algorithm_result)
             (reseed_function: ENTROPY.stream -> DRBG_state_handle -> bool -> list byte -> ENTROPY.result DRBG_state_handle)
             (reseed_interval: Z) (max_number_of_bytes_per_request: Z) (max_additional_input_length: Z)
             (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle)
             (requested_number_of_bytes requested_security_strength: Z)
             (prediction_resistance_request: bool) (additional_input: list byte): ENTROPY.result (list byte * DRBG_state_handle) :=
  match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
    if requested_number_of_bytes >? max_number_of_bytes_per_request then ENTROPY.error ENTROPY.generic_error entropy_stream
    else
      if requested_security_strength >? security_strength then ENTROPY.error ENTROPY.generic_error entropy_stream
      else
        if (Zlength additional_input) >? max_additional_input_length then ENTROPY.error ENTROPY.generic_error entropy_stream
        else
          if prediction_resistance_request && (negb prediction_resistance_flag) then ENTROPY.error ENTROPY.generic_error entropy_stream
          else
            match DRBG_generate_function_helper (generate_algorithm reseed_interval) reseed_function
                       entropy_stream state_handle requested_number_of_bytes prediction_resistance_request
                       additional_input prediction_resistance_request 1%nat with
              | ENTROPY.error e s => ENTROPY.error e s
              | ENTROPY.success (output, new_working_state) entropy_stream =>
                  ENTROPY.success (output, (new_working_state, security_strength, prediction_resistance_flag)) entropy_stream
            end
  end. *)
Require Import hmacdrbg.HMAC_DRBG_algorithms.
(* hmacdrbg.HMAC_DRBG_algorithms:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import VST.floyd.functional_base.

Require Import hmacdrbg.DRBG_functions.

Definition HMAC_DRBG_update (HMAC: list byte -> list byte -> list byte) (provided_data K V: list byte): (list byte * list byte) :=
  let K := HMAC (V ++ [Byte.zero] ++ provided_data) K in
  let V := HMAC V K in
  match provided_data with
    | [] => (K, V)
    | _::_ =>
      let K := HMAC (V ++ [Byte.one] ++ provided_data) K in
      let V := HMAC V K in
      (K, V)
  end.

Definition initial_key: list byte := list_repeat 32 Byte.zero.

Definition initial_value: list byte := list_repeat 32 Byte.one.

Definition HMAC_DRBG_instantiate_algorithm (HMAC: list byte -> list byte -> list byte)
           (entropy_input nonce personalization_string: list byte) (security_strength: Z): DRBG_working_state :=
  let seed_material := entropy_input ++ nonce ++ personalization_string in
  let key := initial_key in
  let value := initial_value in
  let (key, value) := HMAC_DRBG_update HMAC seed_material key value in
  let reseed_counter := 1 in
  (value, key, reseed_counter).

Definition HMAC_DRBG_reseed_algorithm (HMAC: list byte -> list byte -> list byte)
           (working_state: DRBG_working_state) (entropy_input additional_input: list byte): DRBG_working_state :=
  match working_state with (v, key, _) =>
                           let seed_material := entropy_input ++ additional_input in
                           let (key, v) := HMAC_DRBG_update HMAC seed_material key v in
                           let reseed_counter := 1 in
                           (v, key, reseed_counter)
  end.

Definition HMAC_DRBG_generate_algorithm (HMAC: list byte -> list byte -> list byte) (reseed_interval: Z)
           (working_state: DRBG_working_state) (requested_number_of_bytes: Z)
           (additional_input: list byte): DRBG_generate_algorithm_result :=
  match working_state with (v, key, reseed_counter) =>
    if reseed_counter >? reseed_interval then generate_algorithm_reseed_required
    else
      let (key, v) := match additional_input with
                        | [] => (key, v)
                        | _::_ => HMAC_DRBG_update HMAC additional_input key v
                      end in
      let (v, temp) := HMAC_DRBG_generate_helper_Z HMAC key v requested_number_of_bytes in
      let returned_bits := firstn (Z.to_nat requested_number_of_bytes) temp in
      let (key, v) := HMAC_DRBG_update HMAC additional_input key v in
      let reseed_counter := reseed_counter + 1 in
      generate_algorithm_success returned_bits (v, key, reseed_counter)
  end. *)
Require Import hmacdrbg.HMAC256_DRBG_functional_prog.
(* hmacdrbg.HMAC256_DRBG_functional_prog:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import sha.HMAC256_functional_prog.
Require Import hmacdrbg.DRBG_functions.
Require Import hmacdrbg.HMAC_DRBG_algorithms.

Definition HMAC256_DRBG_update := HMAC_DRBG_update HMAC256.

Definition HMAC256_DRBG_instantiate_algorithm := HMAC_DRBG_instantiate_algorithm HMAC256.

Definition HMAC256_DRBG_instantiate_function := DRBG_instantiate_function HMAC256_DRBG_instantiate_algorithm.

Definition HMAC256_DRBG_generate_algorithm := HMAC_DRBG_generate_algorithm HMAC256.

Definition HMAC256_DRBG_generate_function := DRBG_generate_function HMAC256_DRBG_generate_algorithm.

Definition HMAC256_DRBG_reseed_algorithm := HMAC_DRBG_reseed_algorithm HMAC256.

Definition HMAC256_DRBG_reseed_function := DRBG_reseed_function HMAC256_DRBG_reseed_algorithm. *)
Require Import sha.HMAC256_functional_prog.
(* sha.HMAC256_functional_prog:
Require Import compcert.lib.Integers.
Require Import compcert.lib.Coqlib.
Require Import Coq.Strings.String.
Require Import Coq.Strings.Ascii.
Require Import List. Import ListNotations.
Require Import sha.general_lemmas.
Require Import sha.SHA256.
Require Import sha.functional_prog.
Require Import sha.HMAC_functional_prog.

Module SHA256 <: HP.HASH_FUNCTION.
  Definition BlockSize:= 64%nat.
  Definition DigestLength:= 32%nat.
  Definition Hash : list byte -> list byte := SHA_256'.
End SHA256.

Module HMAC_SHA256 := HP.HMAC_FUN SHA256.

Definition Ipad := Byte.repr 54. 
Definition Opad := Byte.repr 92. 

Definition HMAC256 := HMAC_SHA256.HMAC Ipad Opad.

Definition HMACString (txt passwd:string): list byte :=
  HMAC256 (str_to_bytes txt) (str_to_bytes passwd).

Definition HMACHex (text password:string): list byte :=
  HMAC256 (hexstring_to_bytelist text) (hexstring_to_bytelist password).

Definition check password text digest :=
  bytelist_eq (HMACString text password) (hexstring_to_bytelist digest) = true.

Goal check "bb" "aa"
      "c1201d3dccfb84c069771d07b3eda4dc26e5b34a4d8634b2bba84fb54d11e265".

Lemma RFC4231_Section4_3: 
  check "Jefe" "what do ya want for nothing?" 
      "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843".

Definition checkHex password text digest :=
  bytelist_eq (HMACHex text password) (hexstring_to_bytelist digest) = true.

Lemma RFC4231_Section4_2_hex: 
  checkHex "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
        "4869205468657265"
        "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7".

Lemma RFC4231_Section4_3_hex: 
  checkHex "4a656665"
        "7768617420646f2079612077616e7420666f72206e6f7468696e673f"
        "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843".

Lemma RFC4231_Section4_4_hex: 
  checkHex "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        "dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"
        "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe".

Lemma RFC4231_Section4_5_hex: 
  checkHex "0102030405060708090a0b0c0d0e0f10111213141516171819"
        "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
        "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b".

Definition checkHexTrunc password text digest := 
  bytelist_eq (firstn 16 (HMACHex text password)) (hexstring_to_bytelist digest) = true.

Lemma RFC4231_Section4_6_hex:
  checkHexTrunc "0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c"
        "546573742057697468205472756e636174696f6e"
        "a3b6167473100ee06e0c796c2955552b".

Lemma RFC4231_Section4_7_hex: 
  checkHex "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        "54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a65204b6579202d2048617368204b6579204669727374"
        "60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54".

Lemma RFC4231_Section4_8_hex: 
  checkHex "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        "5468697320697320612074657374207573696e672061206c6172676572207468616e20626c6f636b2d73697a65206b657920616e642061206c6172676572207468616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565647320746f20626520686173686564206265666f7265206265696e6720757365642062792074686520484d414320616c676f726974686d2e"
        "9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2".

Lemma RFC6868_example4_2hex: 
  checkHex "4a656665" 
           "7768617420646f2079612077616e7420666f72206e6f7468696e673f"
           "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843".

Lemma RFC6868_example4_5hex:
  checkHex
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    "54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a65204b6579202d2048617368204b6579204669727374"
    "60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54".

Lemma RFC6868_exampleAUTH256_2:
  checkHex
  "4a6566654a6566654a6566654a6566654a6566654a6566654a6566654a656665"
  "7768617420646f2079612077616e7420666f72206e6f7468696e673f"
  "167f928588c5cc2eef8e3093caa0e87c9ff566a14794aa61648d81621a2a40c6". *)
Require Import FCF.DetSem.
(* FCF.DetSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Import FCF.Blist.
Require Import FCF.Fold.
Require Import Permutation.
Require Import Omega.

Local Open Scope list_scope. 
Local Open Scope comp_scope.

Inductive comp_state(A : Set) :=
  | cs_done : A -> Blist -> comp_state A
  | cs_eof : comp_state A
  | cs_more : Comp A -> Blist -> comp_state A.

Inductive comp_answer(A : Set) :=
  | ca_done : A -> comp_answer A
  | ca_eof : comp_answer A.

Lemma comp_answer_eq_dec : forall (A : Set),
      eq_dec A ->
      eq_dec (comp_answer A).

Fixpoint evalDet_step(A : Set)(c : Comp A)(s : Blist) : comp_state A :=
  match c in Comp A return comp_state A with
    | Ret pf a => cs_done a s
    | Rnd n  => 
      match (shiftOut s n) with
        | Some (v, s') => cs_more (Ret (@Bvector_eq_dec n) v) s'
        | None => (@cs_eof (Bvector n))
      end
    | Bind c1 c2 =>     
      match (evalDet_step c1 s) with
        | cs_eof _ => (@cs_eof _)
        | cs_done b s' => cs_more (c2 b) s'
        | cs_more c1' s' => cs_more (Bind c1' c2) s'
      end
    | Repeat c P =>
      cs_more (Bind c (fun a => if (P a) then (Ret (comp_eq_dec c) a) else (Repeat c P))) s
   end.

Inductive evalDet_steps(A : Set) : comp_state A -> comp_state A -> Prop :=
  | evalDet_steps_refl : forall ans,
    evalDet_steps ans ans
  | evalDet_steps_step : 
    forall c s ans ans',
      (evalDet_step c s) = ans ->
      evalDet_steps ans ans' ->
      evalDet_steps (cs_more c s) ans'.

Hint Constructors evalDet_steps : evalDet.

Inductive evalDet(A : Set)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_done : forall a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    evalDet c s (ca_done a)
  | evalDet_eof :
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet c s (@ca_eof A).
    
Theorem evalDet_steps_trans : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall z, 
  evalDet_steps y z ->
  evalDet_steps x z.

Theorem evalDet_steps_bind_more_h : forall(A B : Set) x y,
  evalDet_steps x y ->
  forall (c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  x = (cs_more c1 s) ->
  y =  (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Theorem evalDet_steps_bind_more : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  evalDet_steps (cs_more c1 s) (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Lemma evalDet_steps_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a : A) s s',
  x = (cs_more c s) -> 
  y = (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_done_inv : forall (A : Set)(c : Comp A)(a : A) s s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s,
  x = (cs_more c s) -> 
  y = (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Lemma evalDet_steps_eof_inv : forall (A : Set)(c : Comp A) s,
  evalDet_steps (cs_more c s) (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Theorem evalDet_steps_bind_done : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a s s',
  evalDet_steps (cs_more c1 s) (cs_done a s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (c2 a) s').

Theorem evalDet_bind_eof : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more c1 s) (@cs_eof B) ->
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A).

Inductive comp_state_eq(A : Set) : comp_state A -> comp_state A -> Prop :=
  | cse_done : 
    forall a s, 
      comp_state_eq (cs_done a s) (cs_done a s)
  | cse_eof : 
    comp_state_eq (@cs_eof A) (@cs_eof A)
  | cse_more : 
    forall c1 c2 s,
      Comp_eq c1 c2 ->
      comp_state_eq (cs_more c1 s) (cs_more c2 s).

Theorem comp_state_eq_refl : forall (A : Set)(c : comp_state A),
  comp_state_eq c c.

Lemma evalDet_steps_done_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a a' s s',
  y1 = (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Theorem evalDet_steps_done_func : forall (A : Set) x (a a' : A) s s',
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Lemma evalDet_steps_done_eof_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a s,
  y1 = (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_steps_done_eof_func : forall (A : Set) x (a : A) s,
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_func : forall (A : Set)(c : Comp A)(s : Blist)(y1 y2 : comp_answer A),
  evalDet c s y1 ->
  evalDet c s y2 ->
  y1 = y2.

Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) :=
  (forall s y, evalDet c1 s y <-> evalDet c2 s y).

Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A),
  evalDet_equiv c1 c2 ->
  evalDet_equiv c2 c1.

Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
    x = (cs_more (Bind c1 c2) s) ->
    y = (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_eof_inv_h : 
  forall (A : Set)(x y : comp_state A),
    evalDet_steps x y ->
    forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
      x = (cs_more (Bind c1 c2) s) ->
      y = (@cs_eof A) ->
      evalDet_steps (cs_more c1 s) (@cs_eof B) \/
      exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
        evalDet_steps (cs_more (c2 b) s') (@cs_eof A).
  
Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) ->
  evalDet_steps (cs_more c1 s) (@cs_eof B) \/
  exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
    evalDet_steps (cs_more (c2 b) s') (@cs_eof A).

Theorem evalDet_bind_assoc : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),
  evalDet_equiv (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).

Theorem evalDet_done_eof_func:
  forall (A : Set) (c : Comp A) (a : A) (s : Blist),
    evalDet c s (ca_done a) -> evalDet c s (@ca_eof A) -> False.

Lemma getSupport_In_evalDet_step_done : forall (A : Set)(c : Comp A) a s s',
  evalDet_step c s = cs_done a s' ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_step_more : forall (A : Set)(c c' : Comp A) s s' a,
  evalDet_step c s = cs_more c' s' ->
  In a (getSupport c') ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_steps_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a s s',
    x = (cs_more c s)  ->
    y = (cs_done a s') -> 
    In a (getSupport c).

Lemma getSupport_In_evalDet_steps : forall (A : Set)(c : Comp A) a s s',
  evalDet_steps (cs_more c s) (cs_done a s') -> 
  In a (getSupport c).

Theorem getSupport_In_evalDet : forall (A : Set)(c : Comp A) a s,
  evalDet c s (ca_done a) -> 
  In a (getSupport c).

Inductive evalDet_repeat_steps (A : Set)(P : A -> bool) : comp_state A -> comp_state A -> Prop :=
| evalDet_repeat_steps_done : 
  forall c s a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = true ->
    evalDet_repeat_steps P (cs_more c s) (cs_done a s')
| evalDet_repeat_steps_eof :
  forall c s,
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A)
| evalDet_repeat_steps_step :
  forall c s a s' y,
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = false ->
    evalDet_repeat_steps P (cs_more c s') y ->
    evalDet_repeat_steps P (cs_more c s) y.

Inductive evalDet_repeat(A : Set)(P : A -> bool)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_repeat_done : forall a s',
    evalDet_repeat_steps P (cs_more c s) (cs_done a s') ->
    evalDet_repeat P c s (ca_done a)
  | evalDet_repeat_eof :
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A) ->
    evalDet_repeat P c s (@ca_eof A).

Lemma list_skipn_strong_ind_h : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  (forall n, P (skipn n l)).

Lemma list_skipn_strong_ind : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  P l.

Lemma evalDet_step_nil_inv : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_step c nil = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_step c nil = (cs_done a ls) ->
  ls = nil.

Lemma evalDet_step_more_nil_inv : forall (A : Set)(c c' : Comp A) ls,
  evalDet_step c nil = (cs_more c' ls) ->
  ls = nil.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) s a,
  evalDet_step c s = cs_done a s ->
  getSupport c = (a :: nil).

Lemma getUnique_NoDup_eq : forall (A : Set)(eqd : eq_dec A)(ls : list A),
  NoDup ls ->
  getUnique ls eqd = ls.

Lemma getUnique_Permutation : forall (A : Set)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  Permutation (getUnique ls1 eqd1) (getUnique ls2 eqd2).

Lemma flatten_Permutation : forall (A : Type)(ls1 ls2 : list (list A)),
  Permutation ls1 ls2 ->
  Permutation (flatten ls1) (flatten ls2).

Lemma to_list_nil_inv : forall (A : Type)(n : nat)(v : Vector.t A n),

Lemma app_second_eq :
  forall (A : Type) (ls2 ls1 ls3 : list A),
    ls1 = ls2 ++ ls3 -> length ls1 = length ls3 -> ls1 = ls3 /\ ls2 = nil.

Lemma shiftOut_same_inv : forall s n v,
  shiftOut s n = Some (v, s) ->
  n = O.

Lemma filter_Permutation : forall (A : Set)(ls1 ls2 : list A)(P : A -> bool),
  Permutation ls1 ls2 ->
  Permutation (filter P ls1) (filter P ls2).

Lemma evalDet_step_more_support_preserved : forall (A : Set)(c c' : Comp A) s,
  evalDet_step c s = (cs_more c' s) ->
  Permutation (getSupport c) (getSupport c').

Lemma evalDet_steps_nil_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a1 a2 : A) s2,
  x = (cs_more c nil) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_steps_nil_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_steps (cs_more c nil) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_val_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_ls_eq : forall (A : Set)(c : Comp A)(a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  s1 = s2.

Lemma shiftOut_skipn : forall n (v : Bvector n) s s',
  shiftOut s n = Some (v, s') ->
  s' = skipn n s.

Lemma evalDet_step_more_skipn_eq : forall (A : Set)(c c' : Comp A)(a1 : A) s1 s2,
  evalDet_step c s1 = (cs_more c' s2) ->
  In a1 (getSupport c) ->
  (s1 = s2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_step_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_step  c s = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma skipn_sum : forall (A : Type)(n2 n1 : nat)(ls : list A),
  skipn n1 (skipn n2 ls) = skipn (n2 + n1) ls.

Lemma evalDet_step_more_skipn : forall (A : Set)(c c' : Comp A) s s',
  evalDet_step  c s = (cs_more c' s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s a s', 
    x = (cs_more c s) ->
    y = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_skipn_h : forall (A : Set) a1 (x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a2 : A) s1 s2,
  x = (cs_more c s1) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_steps_skipn : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_steps (cs_more c s1) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_repeat_steps_dec : forall (s : Blist)(A : Set)(c : Comp A)(P : A -> bool),
  (exists a, In a (getSupport c) /\ P a = true) ->
  (forall s', (exists a s'', evalDet_steps (cs_more c s') (cs_done a s'')) \/ evalDet_steps (cs_more c s') (@cs_eof A)) ->
  exists y, evalDet_repeat_steps P (cs_more c s) y.

Lemma evalDet_repeat_steps_done_inv_h : forall (A : Set)(P : A -> bool) x y,
  evalDet_repeat_steps P x y ->
  forall c s,
  x = (cs_more c s) -> 
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_done_inv : forall (A : Set)(c : Comp A)(P : A -> bool) s y,
  evalDet_repeat_steps P (cs_more c s) y ->
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_more_inv_h : forall (A : Set)(x y : comp_state A) P,
  evalDet_repeat_steps P x y ->
  forall (c: Comp A)(P : A -> bool) s,
  y = (cs_more c s) ->
  False.

Lemma evalDet_repeat_steps_more_inv : forall (A : Set) x (c : Comp A)(P : A -> bool) s,
  evalDet_repeat_steps P x (cs_more c s) ->
  False.

Lemma evalDet_steps_dec : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall s, 
  (exists a s', evalDet_steps (cs_more c s) (cs_done a s')) \/ 
  (evalDet_steps (cs_more c s) (@cs_eof A)).

Lemma evalDet_dec : forall (A : Set)(c : Comp A)(s : Blist),
  well_formed_comp c ->
  (exists a, evalDet c s (ca_done a)) \/ (evalDet c s (@ca_eof A)).

Lemma evalDet_step_app_done_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_step c s = (cs_done a s'') ->
  evalDet_step c (s ++ s') = (cs_done a (s'' ++ s')).

Lemma evalDet_step_app_more_eq : forall (A : Set)(c c': Comp A) s s' s'',
  evalDet_step c s = (cs_more c' s'') ->
  evalDet_step c (s ++ s') = (cs_more c' (s'' ++ s')).

Lemma evalDet_steps_app_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s s' s'' a,
    x = (cs_more c s) ->
    y = (cs_done a s'') ->
    evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_steps_app_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_steps (cs_more c s) (cs_done a s'') ->
  evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_app_eq : forall (A : Set)(c : Comp A) s s' a,
  evalDet c s (ca_done a) ->
  evalDet c (s ++ s') (ca_done a).

Lemma evalDet_steps_done_nil_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls,
    x = (cs_more c nil) ->
    y = (cs_done a ls) ->
    ls = nil.

Lemma evalDet_steps_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma app_eq_nil_inv : forall (A : Set)(ls2 ls1 ls3 : list A),
  ls1 = ls2 ++ ls3 ->
  length ls1 = length ls2 ->
  ls3 = nil.

Lemma evalDet_steps_repeat_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s a s',
  evalDet_steps x (cs_more (Repeat c P) s) ->
  y = (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_done_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s a s',
  evalDet_steps (cs_more (Repeat c P) s) (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s,
    evalDet_steps x (cs_more (Repeat c P) s) ->
    y = (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_steps_repeat_eof_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s,
  evalDet_steps (cs_more (Repeat c P) s) (cs_eof A)->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_repeat_steps_nil_inv_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall (P : A -> bool) c a ls',
  x = (cs_more c nil) ->
  y = (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_nil_inv : forall (A : Set)(P : A -> bool) c a ls',
  evalDet_repeat_steps P (cs_more c nil) (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_app_nil_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall c ls1 ls2 b a,
    x = (cs_more c ls1) ->
    y = (cs_eof A) ->
    evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2)->
    (forall s s' b a,
      evalDet_steps (cs_more c s) (cs_eof A) ->
      evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
      s' = nil) ->
    ls2 = nil.

Lemma evalDet_repeat_steps_app_nil : forall (A : Set)(c : Comp A) P ls1 ls2 b a,
  evalDet_repeat_steps P (cs_more c ls1) (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  (forall s s' b a,
    evalDet_steps (cs_more c s) (cs_eof A) ->
    evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
    s' = nil) ->
  ls2 = nil.

Lemma evalDet_app_nil : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall ls1 ls2 b a,
  evalDet c ls1 (ca_eof A) ->
  evalDet_steps (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  ls2 = nil.

Lemma evalDet_step_done_inv : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_step c ls = cs_done a ls' ->
  exists eqd, 
    c = Ret eqd a.

Lemma evalDet_step_more_sublist : forall (A : Set)(c : Comp A) c' ls ls',
  evalDet_step c ls = (cs_more c' ls') ->
  exists ls'', ls = ls'' ++ ls'.
    
Lemma evalDet_sublist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls ls' ,
    x = (cs_more c ls) ->
    y = (cs_done a ls') ->
    exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_sublist : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_steps (cs_more c ls) (cs_done a ls') ->
  exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_nil : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma evalDet_left_total : forall (A : Set)(c : Comp A) s,
  well_formed_comp c ->
  exists ans, evalDet c s ans.
  
Lemma evalDet_steps_done_support_singleton_h : forall (A : Set)(x1 x2 : comp_state A),
  evalDet_steps x1 x2 ->
  forall (c : Comp A) a s,
    x1 = (cs_more c nil) ->
    x2 = (cs_done a s) ->
    getSupport c = a :: nil.

Lemma evalDet_steps_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  getSupport c = a :: nil.

Lemma evalDet_step_well_formed_comp_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' s s',
    evalDet_step c s = (cs_more c' s') ->
    well_formed_comp c'. *)
Require Import sha.general_lemmas.
(* sha.general_lemmas:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import compcert.lib.Integers.
Require Import VST.msl.Coqlib2.
Require Import VST.floyd.coqlib3.
Require Import VST.floyd.sublist.
Require Import VST.floyd.functional_base.

Local Open Scope nat.

Fixpoint map2 {A B C: Type} (f: A -> B -> C) (al: list A) (bl: list B) : list C :=
 match al, bl with
  | a::al', b::bl' => f a b :: map2 f al' bl'
  | _, _ => nil
  end.

Lemma length_map2:
 forall A B C (f: A -> B -> C) al bl n,
  length al = n -> length bl = n ->
  length (map2 f al bl) = n.

Lemma list_repeat_injective {A} (a a':A) n: (0<n)%nat ->
      list_repeat n a = list_repeat n a' -> a=a'.

Local Open Scope Z.

Definition roundup (a b : Z) := (a + (b-1))/b*b.

Lemma roundup_minus:
   forall a b,  b > 0 -> roundup a b - a = (- a) mod b.

Definition Shr b x := Int.shru x (Int.repr b).

Lemma byte_testbit:
  forall i j, j >= 8 -> Z.testbit (Byte.unsigned i) j = false.

Fixpoint intlist_to_bytelist (l: list int) : list byte :=
 match l with
 | nil => nil
 | i::r =>
     Byte.repr (Int.unsigned (Shr 24 i)) ::
     Byte.repr (Int.unsigned (Shr 16 i)) ::
     Byte.repr (Int.unsigned (Shr 8 i)) ::
     Byte.repr (Int.unsigned i) ::
     intlist_to_bytelist r
 end.

Definition bytes_to_Int (a b c d : byte) : Int.int :=
  Int.or (Int.or (Int.or 
       (Int.shl (Int.repr (Byte.unsigned a)) (Int.repr 24))
      (Int.shl (Int.repr (Byte.unsigned b)) (Int.repr 16)))
       (Int.shl (Int.repr (Byte.unsigned c)) (Int.repr 8)))
         (Int.repr (Byte.unsigned d)).

Fixpoint bytelist_to_intlist (nl: list byte) : list int :=
  match nl with
  | h1::h2::h3::h4::t => bytes_to_Int h1 h2 h3 h4 :: bytelist_to_intlist t
  | _ => nil
  end.

Hint Rewrite Int.bits_or using omega : testbit.
Hint Rewrite Int.bits_shl using omega : testbit.
Hint Rewrite Int.bits_and using omega : testbit.
Hint Rewrite Int.bits_shru using omega : testbit.
Hint Rewrite Int.unsigned_repr using omega : testbit.
Hint Rewrite Int.testbit_repr using omega : testbit.
Hint Rewrite if_false using omega : testbit.
Hint Rewrite if_true using omega : testbit.
Hint Rewrite Z.ones_spec_low using omega : testbit.
Hint Rewrite Z.ones_spec_high using omega : testbit.
Hint Rewrite orb_false_r orb_true_r andb_false_r andb_true_r : testbit.
Hint Rewrite orb_false_l orb_true_l andb_false_l andb_true_l : testbit.
Hint Rewrite Z.add_simpl_r : testbit.
Hint Rewrite Int.unsigned_repr using rep_omega : testbit.
Hint Rewrite Byte.testbit_repr using rep_omega : testbit.
Hint Rewrite Byte.bits_above using rep_omega : testbit.

Lemma Ztest_Inttest:
 forall a, Z.testbit (Int.unsigned a) = Int.testbit a.
Hint Rewrite Ztest_Inttest : testbit.

Lemma Ztest_Bytetest:
 forall a, Z.testbit (Byte.unsigned a) = Byte.testbit a.
Hint Rewrite Ztest_Bytetest : testbit.

Definition swap (i: int) : int :=
 Int.or (Int.shl (Int.and i (Int.repr 255)) (Int.repr 24))
   (Int.or (Int.shl (Int.and (Shr 8 i) (Int.repr 255)) (Int.repr 16))
      (Int.or (Int.shl (Int.and (Shr 16 i) (Int.repr 255)) (Int.repr 8))
         (Shr 24 i))).

Lemma swap_swap: forall w, swap (swap w) = w.

Lemma map_swap_involutive:
 forall l, map swap (map swap l)  = l.

Lemma length_intlist_to_bytelist:
  forall l, length (intlist_to_bytelist l) = (4 * length l)%nat.

Lemma intlist_to_bytelist_bytes_to_int_cons:
  forall a b c d l,
     intlist_to_bytelist (bytes_to_Int a b c d :: l) =
     a::b::c::d:: intlist_to_bytelist l.

Lemma intlist_to_bytelist_to_intlist:
  forall il: list int,
   bytelist_to_intlist (intlist_to_bytelist il) = il.

Lemma intlist_to_bytelist_app:
 forall al bl, intlist_to_bytelist (al++bl) = intlist_to_bytelist al ++ intlist_to_bytelist bl.
Local Open Scope nat.

Local Open Scope Z.

Lemma int_unsigned_inj: forall a b, Int.unsigned a = Int.unsigned b -> a=b.

Lemma intlist_to_bytelist_inj: forall al bl, intlist_to_bytelist al = intlist_to_bytelist bl -> al=bl.

Lemma Zlength_intlist_to_bytelist_app:
 forall al bl,  Zlength (intlist_to_bytelist (al++bl)) =
    (Zlength (intlist_to_bytelist al) + Zlength (intlist_to_bytelist bl))%Z.

Local Open Scope Z.

Lemma divide_length_app:
 forall {A} n (al bl: list A),
      (n | Zlength al) ->
      (n | Zlength bl) ->
      (n | Zlength (al++bl)).

Lemma nth_list_repeat: forall A i n (x :A),
    nth i (list_repeat n x) x = x.

Lemma map_list_repeat:
  forall A B (f: A -> B) n x,
     map f (list_repeat n x) = list_repeat n (f x). *)
Require Import hmacdrbg.spec_hmac_drbg_pure_lemmas.
(* hmacdrbg.spec_hmac_drbg_pure_lemmas:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import VST.floyd.functional_base.

Require Import sha.general_lemmas.
Require Import sha.HMAC256_functional_prog.

Require Import hmacdrbg.entropy.
Require Import hmacdrbg.DRBG_functions.
Require Import hmacdrbg.HMAC_DRBG_algorithms.
Require Import hmacdrbg.HMAC256_DRBG_functional_prog.
Require Import hmacdrbg.spec_hmac_drbg.

Lemma hmac256drbgabs_hmac_drbg_update_any_prop_key:
  forall (P: list byte -> Prop) a additional_data,
    (forall x y, P (HMAC256 x y)) ->
    P (hmac256drbgabs_key (hmac256drbgabs_hmac_drbg_update a additional_data)).

Lemma hmac256drbgabs_hmac_drbg_update_any_prop_V:
  forall (P: list byte -> Prop) a additional_data,
    (forall x y, P (HMAC256 x y)) ->
    P (hmac256drbgabs_value (hmac256drbgabs_hmac_drbg_update a additional_data)).

Lemma hmac256drbgabs_hmac_drbg_update_Zlength_key:
  forall a additional_data,
    Zlength (hmac256drbgabs_key (hmac256drbgabs_hmac_drbg_update a additional_data)) = Z.of_nat SHA256.DigestLength.

Lemma hmac256drbgabs_hmac_drbg_update_Zlength_V:
  forall a additional_data,
    Zlength (hmac256drbgabs_value (hmac256drbgabs_hmac_drbg_update a additional_data)) = Z.of_nat SHA256.DigestLength.

Lemma hmac256drbgabs_reseed_any_prop_key:
  forall (P: list byte -> Prop) a s additional_data,
    P (hmac256drbgabs_key a) ->
    (forall x y, P (HMAC256 x y)) ->
    P (hmac256drbgabs_key (hmac256drbgabs_reseed a s additional_data)).

Lemma hmac256drbgabs_reseed_any_prop_V:
  forall (P: list byte -> Prop) a s additional_data,
    P (hmac256drbgabs_value a) ->
    (forall x y, P (HMAC256 x y)) ->
    P (hmac256drbgabs_value (hmac256drbgabs_reseed a s additional_data)).

Lemma hmac256drbgabs_reseed_Zlength_key:
  forall a s additional_data,
    Zlength (hmac256drbgabs_key a) = Z.of_nat SHA256.DigestLength ->

Lemma hmac256drbgabs_reseed_Zlength_V:
  forall a s additional_data,
    Zlength (hmac256drbgabs_value a) = Z.of_nat SHA256.DigestLength ->

Lemma hmac256drbgabs_update_key_ident:
  forall a key, key = hmac256drbgabs_key a -> hmac256drbgabs_update_key a key = a.

Lemma hmac256drbgabs_update_value_ident:
  forall a value, value = hmac256drbgabs_value a -> hmac256drbgabs_update_value a value = a.

Lemma hmac256drbgabs_update_key_update_value_commute:
  forall a key value, hmac256drbgabs_update_value (hmac256drbgabs_update_key a key) value = hmac256drbgabs_update_key (hmac256drbgabs_update_value a value) key.

Lemma HMAC_DRBG_update_value l key V key' V'
  (P:(key', V') = HMAC_DRBG_update HMAC256 l key V):
  Zlength V' = 32.

Lemma Zlength_hmac256drbgabs_reseed_value abs s c
  (HC: Zlength c >? 256 = false) (HV: Zlength (hmac256drbgabs_value abs)=32):
  Zlength (hmac256drbgabs_value (hmac256drbgabs_reseed abs s c)) = 32.

Lemma Zlength_hmac256drbgabs_update_value abs c:
  Zlength (hmac256drbgabs_value (hmac256drbgabs_hmac_drbg_update abs c)) = 32. *)
Require Import compcert.lib.Coqlib.
(* compcert.lib.Coqlib:
Require Export String.
Require Export ZArith.
Require Export Znumtheory.
Require Export List.
Require Export Bool.

Global Set Asymmetric Patterns.

Ltac inv H := inversion H; clear H; subst.

Ltac predSpec pred predspec x y :=
  generalize (predspec x y); case (pred x y); intro.

Ltac caseEq name :=
  generalize (eq_refl name); pattern name at -1 in |- *; case name.

Ltac destructEq name :=
  destruct name eqn:?.

Ltac decEq :=
  match goal with
  | [ |- _ = _ ] => f_equal
  | [ |- (?X ?A <> ?X ?B) ] =>
      cut (A <> B); [intro; congruence | try discriminate]
  end.

Ltac byContradiction :=
  cut False; [contradiction|idtac].

Ltac omegaContradiction :=
  cut False; [contradiction|omega].

Lemma modusponens: forall (P Q: Prop), P -> (P -> Q) -> Q.

Ltac exploit x :=
    refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _) _)
 || refine (modusponens _ _ (x _ _) _)
 || refine (modusponens _ _ (x _) _).

Definition peq: forall (x y: positive), {x = y} + {x <> y} := Pos.eq_dec.
Global Opaque peq.

Lemma peq_true:
  forall (A: Type) (x: positive) (a b: A), (if peq x x then a else b) = a.

Lemma peq_false:
  forall (A: Type) (x y: positive) (a b: A), x <> y -> (if peq x y then a else b) = b.

Definition Plt: positive -> positive -> Prop := Pos.lt.

Lemma Plt_ne:
  forall (x y: positive), Plt x y -> x <> y.
Hint Resolve Plt_ne: coqlib.

Lemma Plt_trans:
  forall (x y z: positive), Plt x y -> Plt y z -> Plt x z.
Proof (Pos.lt_trans).

Lemma Plt_succ:
  forall (x: positive), Plt x (Pos.succ x).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_trans_succ:
  forall (x y: positive), Plt x y -> Plt x (Pos.succ y).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_succ_inv:
  forall (x y: positive), Plt x (Pos.succ y) -> Plt x y \/ x = y.

Definition plt (x y: positive) : {Plt x y} + {~ Plt x y}.
Global Opaque plt.

Definition Ple: positive -> positive -> Prop := Pos.le.

Lemma Ple_refl: forall (p: positive), Ple p p.
Proof (Pos.le_refl).

Lemma Ple_trans: forall (p q r: positive), Ple p q -> Ple q r -> Ple p r.
Proof (Pos.le_trans).

Lemma Plt_Ple: forall (p q: positive), Plt p q -> Ple p q.
Proof (Pos.lt_le_incl).

Lemma Ple_succ: forall (p: positive), Ple p (Pos.succ p).

Lemma Plt_Ple_trans:
  forall (p q r: positive), Plt p q -> Ple q r -> Plt p r.
Proof (Pos.lt_le_trans).

Lemma Plt_strict: forall p, ~ Plt p p.
Proof (Pos.lt_irrefl).

Hint Resolve Ple_refl Plt_Ple Ple_succ Plt_strict: coqlib.

Ltac xomega := unfold Plt, Ple in *; zify; omega.
Ltac xomegaContradiction := exfalso; xomega.

Section POSITIVE_ITERATION.

Lemma Plt_wf: well_founded Plt.

Variable A: Type.
Variable v1: A.
Variable f: positive -> A -> A.

Lemma Ppred_Plt:
  forall x, x <> xH -> Plt (Pos.pred x) x.

Let iter (x: positive) (P: forall y, Plt y x -> A) : A :=
  match peq x xH with
  | left EQ => v1
  | right NOTEQ => f (Pos.pred x) (P (Pos.pred x) (Ppred_Plt x NOTEQ))
  end.

Definition positive_rec : positive -> A :=
  Fix Plt_wf (fun _ => A) iter.

Lemma unroll_positive_rec:
  forall x,
  positive_rec x = iter x (fun y _ => positive_rec y).

Lemma positive_rec_base:
  positive_rec 1%positive = v1.

Lemma positive_rec_succ:
  forall x, positive_rec (Pos.succ x) = f x (positive_rec x).

Lemma positive_Peano_ind:
  forall (P: positive -> Prop),
  P xH ->
  (forall x, P x -> P (Pos.succ x)) ->

End POSITIVE_ITERATION.

Definition zeq: forall (x y: Z), {x = y} + {x <> y} := Z.eq_dec.

Lemma zeq_true:
  forall (A: Type) (x: Z) (a b: A), (if zeq x x then a else b) = a.

Lemma zeq_false:
  forall (A: Type) (x y: Z) (a b: A), x <> y -> (if zeq x y then a else b) = b.

Open Scope Z_scope.

Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_dec.

Lemma zlt_true:
  forall (A: Type) (x y: Z) (a b: A),
  x < y -> (if zlt x y then a else b) = a.

Lemma zlt_false:
  forall (A: Type) (x y: Z) (a b: A),
  x >= y -> (if zlt x y then a else b) = b.

Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.

Lemma zle_true:
  forall (A: Type) (x y: Z) (a b: A),
  x <= y -> (if zle x y then a else b) = a.

Lemma zle_false:
  forall (A: Type) (x y: Z) (a b: A),
  x > y -> (if zle x y then a else b) = b.

Lemma two_power_nat_O : two_power_nat O = 1.

Lemma two_power_nat_pos : forall n : nat, two_power_nat n > 0.

Lemma two_power_nat_two_p:
  forall x, two_power_nat x = two_p (Z.of_nat x).

Lemma two_p_monotone:
  forall x y, 0 <= x <= y -> two_p x <= two_p y.

Lemma two_p_monotone_strict:
  forall x y, 0 <= x < y -> two_p x < two_p y.

Lemma two_p_strict:
  forall x, x >= 0 -> x < two_p x.

Lemma two_p_strict_2:
  forall x, x >= 0 -> 2 * x - 1 < two_p x.

Lemma Zmin_spec:
  forall x y, Z.min x y = if zlt x y then x else y.

Lemma Zmax_spec:
  forall x y, Z.max x y = if zlt y x then x else y.

Lemma Zmax_bound_l:
  forall x y z, x <= y -> x <= Z.max y z.
Lemma Zmax_bound_r:
  forall x y z, x <= z -> x <= Z.max y z.

Lemma Zdiv_small:
  forall x y, 0 <= x < y -> x / y = 0.

Lemma Zmod_small:
  forall x y, 0 <= x < y -> x mod y = x.

Lemma Zmod_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x mod y = b.

Lemma Zdiv_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x / y = a.

Lemma Zdiv_Zdiv:
  forall a b c,
  b > 0 -> c > 0 -> (a / b) / c = a / (b * c).

Lemma Zmult_le_compat_l_neg :
  forall n m p:Z, n >= m -> p <= 0 -> p * n <= p * m.

Lemma Zdiv_interval_1:
  forall lo hi a b,
  lo <= 0 -> hi > 0 -> b > 0 ->
  lo * b <= a < hi * b ->
  lo <= a/b < hi.

Lemma Zdiv_interval_2:
  forall lo hi a b,
  lo <= a <= hi -> lo <= 0 -> hi >= 0 -> b > 0 ->
  lo <= a/b <= hi.

Lemma Zmod_recombine:
  forall x a b,
  a > 0 -> b > 0 ->
  x mod (a * b) = ((x/b) mod a) * b + (x mod b).

Lemma Zdivides_trans:
  forall x y z, (x | y) -> (y | z) -> (x | z).

Definition Zdivide_dec:
  forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
Global Opaque Zdivide_dec.

Lemma Zdivide_interval:
  forall a b c,
  0 < c -> 0 <= a < b -> (c | a) -> (c | b) -> 0 <= a <= b - c.

Definition nat_of_Z: Z -> nat := Z.to_nat.

Lemma nat_of_Z_of_nat:
  forall n, nat_of_Z (Z.of_nat n) = n.

Lemma nat_of_Z_max:
  forall z, Z.of_nat (nat_of_Z z) = Z.max z 0.

Lemma nat_of_Z_eq:
  forall z, z >= 0 -> Z.of_nat (nat_of_Z z) = z.

Lemma nat_of_Z_neg:
  forall n, n <= 0 -> nat_of_Z n = O.

Lemma nat_of_Z_plus:
  forall p q,
  p >= 0 -> q >= 0 ->
  nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.

Definition align (n: Z) (amount: Z) :=
  ((n + amount - 1) / amount) * amount.

Lemma align_le: forall x y, y > 0 -> x <= align x y.

Lemma align_divides: forall x y, y > 0 -> (y | align x y).

Set Implicit Arguments.

Definition option_eq (A: Type) (eqA: forall (x y: A), {x=y} + {x<>y}):
  forall (x y: option A), {x=y} + {x<>y}.
Global Opaque option_eq.

Inductive option_rel (A B: Type) (R: A -> B -> Prop) : option A -> option B -> Prop :=
  | option_rel_none: option_rel R None None
  | option_rel_some: forall x y, R x y -> option_rel R (Some x) (Some y).

Definition option_map (A B: Type) (f: A -> B) (x: option A) : option B :=
  match x with
  | None => None
  | Some y => Some (f y)
  end.

Definition sum_left_map (A B C: Type) (f: A -> B) (x: A + C) : B + C :=
  match x with
  | inl y => inl C (f y)
  | inr z => inr B z
  end.

Hint Resolve in_eq in_cons: coqlib.

Lemma nth_error_in:
  forall (A: Type) (n: nat) (l: list A) (x: A),
  List.nth_error l n = Some x -> In x l.
Hint Resolve nth_error_in: coqlib.

Lemma nth_error_nil:
  forall (A: Type) (idx: nat), nth_error (@nil A) idx = None.
Hint Resolve nth_error_nil: coqlib.

Fixpoint list_length_z_aux (A: Type) (l: list A) (acc: Z) {struct l}: Z :=
  match l with
  | nil => acc
  | hd :: tl => list_length_z_aux tl (Z.succ acc)
  end.

Remark list_length_z_aux_shift:
  forall (A: Type) (l: list A) n m,
  list_length_z_aux l n = list_length_z_aux l m + (n - m).

Definition list_length_z (A: Type) (l: list A) : Z :=
  list_length_z_aux l 0.

Lemma list_length_z_cons:
  forall (A: Type) (hd: A) (tl: list A),
  list_length_z (hd :: tl) = list_length_z tl + 1.

Lemma list_length_z_pos:
  forall (A: Type) (l: list A),
  list_length_z l >= 0.

Lemma list_length_z_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_length_z (map f l) = list_length_z l.

Fixpoint list_nth_z (A: Type) (l: list A) (n: Z) {struct l}: option A :=
  match l with
  | nil => None
  | hd :: tl => if zeq n 0 then Some hd else list_nth_z tl (Z.pred n)
  end.

Lemma list_nth_z_in:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> In x l.

Lemma list_nth_z_map:
  forall (A B: Type) (f: A -> B) (l: list A) n,
  list_nth_z (List.map f l) n = option_map f (list_nth_z l n).

Lemma list_nth_z_range:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> 0 <= n < list_length_z l.

Lemma incl_cons_inv:
  forall (A: Type) (a: A) (b c: list A),
  incl (a :: b) c -> incl b c.
Hint Resolve incl_cons_inv: coqlib.

Lemma incl_app_inv_l:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l1 m.

Lemma incl_app_inv_r:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l2 m.

Hint Resolve  incl_tl incl_refl incl_app_inv_l incl_app_inv_r: coqlib.

Lemma incl_same_head:
  forall (A: Type) (x: A) (l1 l2: list A),
  incl l1 l2 -> incl (x::l1) (x::l2).

Lemma list_map_exten:
  forall (A B: Type) (f f': A -> B) (l: list A),
  (forall x, In x l -> f x = f' x) ->
  List.map f' l = List.map f l.

Lemma list_map_compose:
  forall (A B C: Type) (f: A -> B) (g: B -> C) (l: list A),
  List.map g (List.map f l) = List.map (fun x => g(f x)) l.

Lemma list_map_identity:
  forall (A: Type) (l: list A),
  List.map (fun (x:A) => x) l = l.

Lemma list_map_nth:
  forall (A B: Type) (f: A -> B) (l: list A) (n: nat),
  nth_error (List.map f l) n = option_map f (nth_error l n).

Lemma list_length_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  List.length (List.map f l) = List.length l.

Lemma list_in_map_inv:
  forall (A B: Type) (f: A -> B) (l: list A) (y: B),
  In y (List.map f l) -> exists x:A, y = f x /\ In x l.

Lemma list_append_map:
  forall (A B: Type) (f: A -> B) (l1 l2: list A),
  List.map f (l1 ++ l2) = List.map f l1 ++ List.map f l2.

Lemma list_append_map_inv:
  forall (A B: Type) (f: A -> B) (m1 m2: list B) (l: list A),
  List.map f l = m1 ++ m2 ->

Section LIST_FOLD.

Variables A B: Type.
Variable f: A -> B -> B.

Fixpoint list_fold_left (accu: B) (l: list A) : B :=
  match l with nil => accu | x :: l' => list_fold_left (f x accu) l' end.

Definition list_fold_right (l: list A) (base: B) : B :=
  list_fold_left base (List.rev' l).

Remark list_fold_left_app:
  forall l1 l2 accu,
  list_fold_left accu (l1 ++ l2) = list_fold_left (list_fold_left accu l1) l2.

Lemma list_fold_right_eq:
  forall l base,
  list_fold_right l base =
  match l with nil => base | x :: l' => f x (list_fold_right l' base) end.

Lemma list_fold_right_spec:
  forall l base, list_fold_right l base = List.fold_right f base l.

End LIST_FOLD.

Lemma in_cns:
  forall (A: Type) (x y: A) (l: list A), In x (y :: l) <-> y = x \/ In x l.

Lemma in_app:
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Lemma list_in_insert:
  forall (A: Type) (x: A) (l1 l2: list A) (y: A),
  In x (l1 ++ l2) -> In x (l1 ++ y :: l2).

Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Lemma list_disjoint_cons_l:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l2 -> list_disjoint (a :: l1) l2.

Lemma list_disjoint_cons_r:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l1 -> list_disjoint l1 (a :: l2).

Lemma list_disjoint_cons_left:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.

Lemma list_disjoint_cons_right:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.

Lemma list_disjoint_notin:
  forall (A: Type) (l1 l2: list A) (a: A),
  list_disjoint l1 l2 -> In a l1 -> ~(In a l2).

Lemma list_disjoint_sym:
  forall (A: Type) (l1 l2: list A),
  list_disjoint l1 l2 -> list_disjoint l2 l1.

Lemma list_disjoint_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l1 l2: list A),
  {list_disjoint l1 l2} + {~list_disjoint l1 l2}.

Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
  forall x, In x l1 <-> In x l2.

Inductive list_norepet (A: Type) : list A -> Prop :=
  | list_norepet_nil:
      list_norepet nil
  | list_norepet_cons:
      forall hd tl,
      ~(In hd tl) -> list_norepet tl -> list_norepet (hd :: tl).

Lemma list_norepet_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l: list A),
  {list_norepet l} + {~list_norepet l}.

Lemma list_map_norepet:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_norepet l ->
  (forall x y, In x l -> In y l -> x <> y -> f x <> f y) ->
  list_norepet (List.map f l).

Remark list_norepet_append_commut:
  forall (A: Type) (a b: list A),
  list_norepet (a ++ b) -> list_norepet (b ++ a).

Lemma list_norepet_app:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) <->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Lemma list_norepet_append:
  forall (A: Type) (l1 l2: list A),
  list_norepet l1 -> list_norepet l2 -> list_disjoint l1 l2 ->
  list_norepet (l1 ++ l2).

Lemma list_norepet_append_right:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l2.

Lemma list_norepet_append_left:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l1.

Inductive is_tail (A: Type): list A -> list A -> Prop :=
  | is_tail_refl:
      forall c, is_tail c c
  | is_tail_cons:
      forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).

Lemma is_tail_in:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.

Lemma is_tail_cons_left:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.

Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.

Lemma is_tail_incl:
  forall (A: Type) (l1 l2: list A), is_tail l1 l2 -> incl l1 l2.

Lemma is_tail_trans:
  forall (A: Type) (l1 l2: list A),
  is_tail l1 l2 -> forall (l3: list A), is_tail l2 l3 -> is_tail l1 l3.

Section FORALL2.

Variable A: Type.
Variable B: Type.
Variable P: A -> B -> Prop.

Inductive list_forall2: list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 al bl ->
      list_forall2 (a1 :: al) (b1 :: bl).

Lemma list_forall2_app:
  forall a2 b2 a1 b1,
  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
  list_forall2 (a1 ++ a2) (b1 ++ b2).

Lemma list_forall2_length:
  forall l1 l2,
  list_forall2 l1 l2 -> length l1 = length l2.

Lemma list_forall2_in_left:
  forall x1 l1 l2,
  list_forall2 l1 l2 -> In x1 l1 -> exists x2, In x2 l2 /\ P x1 x2.

Lemma list_forall2_in_right:
  forall x2 l1 l2,
  list_forall2 l1 l2 -> In x2 l2 -> exists x1, In x1 l1 /\ P x1 x2.

End FORALL2.

Lemma list_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
  list_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, In v1 l1 -> In v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  list_forall2 P2 l1 l2.

Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
  match n with
  | O => x
  | S n' => match x with nil => nil | hd :: tl => list_drop n' tl end
  end.

Lemma list_drop_incl:
  forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.

Lemma list_drop_norepet:
  forall (A: Type) n (l: list A), list_norepet l -> list_norepet (list_drop n l).

Lemma list_map_drop:
  forall (A B: Type) (f: A -> B) n (l: list A),
  list_drop n (map f l) = map f (list_drop n l).

Fixpoint list_repeat {A: Type} (n: nat) (x: A) {struct n} :=
  match n with
  | O => nil
  | S m => x :: list_repeat m x
  end.

Lemma length_list_repeat:
  forall (A: Type) n (x: A), length (list_repeat n x) = n.

Lemma in_list_repeat:
  forall (A: Type) n (x: A) y, In y (list_repeat n x) -> y = x.

Definition proj_sumbool {P Q: Prop} (a: {P} + {Q}) : bool :=
  if a then true else false.

Coercion proj_sumbool: sumbool >-> bool.

Lemma proj_sumbool_true:
  forall (P Q: Prop) (a: {P}+{Q}), proj_sumbool a = true -> P.

Lemma proj_sumbool_is_true:
  forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.

Ltac InvBooleans :=
  match goal with
  | [ H: _ && _ = true |- _ ] =>
      destruct (andb_prop _ _ H); clear H; InvBooleans
  | [ H: _ || _ = false |- _ ] =>
      destruct (orb_false_elim _ _ H); clear H; InvBooleans
  | [ H: proj_sumbool ?x = true |- _ ] =>
      generalize (proj_sumbool_true _ H); clear H; intro; InvBooleans
  | _ => idtac
  end.

Section DECIDABLE_EQUALITY.

Variable A: Type.
Variable dec_eq: forall (x y: A), {x=y} + {x<>y}.
Variable B: Type.

Lemma dec_eq_true:
  forall (x: A) (ifso ifnot: B),
  (if dec_eq x x then ifso else ifnot) = ifso.

Lemma dec_eq_false:
  forall (x y: A) (ifso ifnot: B),
  x <> y -> (if dec_eq x y then ifso else ifnot) = ifnot.

Lemma dec_eq_sym:
  forall (x y: A) (ifso ifnot: B),
  (if dec_eq x y then ifso else ifnot) =
  (if dec_eq y x then ifso else ifnot).

End DECIDABLE_EQUALITY.

Section DECIDABLE_PREDICATE.

Variable P: Prop.
Variable dec: {P} + {~P}.
Variable A: Type.

Lemma pred_dec_true:
  forall (a b: A), P -> (if dec then a else b) = a.

Lemma pred_dec_false:
  forall (a b: A), ~P -> (if dec then a else b) = b.

End DECIDABLE_PREDICATE.

Require Import Relations.

Section LEX_ORDER.

Variable A: Type.
Variable B: Type.
Variable ordA: A -> A -> Prop.
Variable ordB: B -> B -> Prop.

Inductive lex_ord: A*B -> A*B -> Prop :=
  | lex_ord_left: forall a1 b1 a2 b2,
      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
  | lex_ord_right: forall a b1 b2,
      ordB b1 b2 -> lex_ord (a,b1) (a,b2).

Lemma wf_lex_ord:
  well_founded ordA -> well_founded ordB -> well_founded lex_ord.

Lemma transitive_lex_ord:
  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.

End LEX_ORDER.

Inductive nlist (A: Type) : Type :=
  | nbase: A -> nlist A
  | ncons: A -> nlist A -> nlist A.

Definition nfirst {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => a end.

Fixpoint nlast {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => nlast l' end.

Fixpoint nIn {A: Type} (x: A) (l: nlist A) : Prop :=
  match l with
  | nbase a => a = x
  | ncons a l => a = x \/ nIn x l
  end.

Inductive nlist_forall2 {A B: Type} (R: A -> B -> Prop) : nlist A -> nlist B -> Prop :=
  | nbase_forall2: forall a b, R a b -> nlist_forall2 R (nbase a) (nbase b)
  | ncons_forall2: forall a l b m, R a b -> nlist_forall2 R l m -> nlist_forall2 R (ncons a l) (ncons b m).

Lemma nlist_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: nlist A) (l2: nlist B),
  nlist_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, nIn v1 l1 -> nIn v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  nlist_forall2 P2 l1 l2. *)
Require Import FCF.Fold.
(* FCF.Fold:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import List.
Require Import Permutation.
Require Import Arith.
Require Import FCF.EqDec.
Require Import FCF.StdNat.
Require Import Bool.

Local Open Scope rat_scope.

Definition unzip(A B : Set)(ls : list (A * B)) :=
  (map (@fst _ _) ls, map (@snd _ _) ls).

Fixpoint zip(A B : Set)(lsa : list A)(lsb : list B) :=
  match lsa with
    | nil => nil
    | a :: lsa' =>
      match lsb with
        | nil => nil
        | b :: lsb' =>
          (a, b) :: (zip lsa' lsb')
      end
  end.

Ltac pairInv := 
  match goal with
    | [H : (_, _) = (_, _) |- _] => 
      inversion H; clear H; subst
  end.

Section RemoveDups.

  Variable A : Set.
  Variable eqd : EqDec A.

  Fixpoint removeDups(ls : list A) :=
    match ls with
      | nil => nil
      | a' :: ls' =>
        if (in_dec (EqDec_dec _) a' ls') then (removeDups ls') else (a' :: (removeDups ls'))
    end.

  Theorem removeDups_in : 
    forall (ls : list A) a,
      In a (removeDups ls) ->
      In a ls.
  
  Theorem removeDups_NoDup :
    forall (ls : list A),
      NoDup (removeDups ls).

  Lemma in_removeDups : 
    forall (ls : list A) a,
      In a ls -> 
      In a (removeDups ls).
     
End RemoveDups.

Section ListReplace.

  Variable A : Set.

  Fixpoint listReplace (ls : list A)(i : nat)(a def : A) :=
    match i with
      | O => 
        match ls with
        | nil => a :: nil
        | a' :: ls' => a :: ls'
        end
      | S i' => 
        match ls with
        | nil => def :: (listReplace nil i' a def)
        | a' :: ls' =>
          a' :: (listReplace ls' i' a def)
        end
    end.

End ListReplace.

Section SumList.

  Variable A : Set.

  Definition sumList(ls : list A)(f : A -> Rat) := fold_left (fun a b => a + (f b)) ls 0.

  Theorem sumList_ne_0 : forall (ls : list A)(f : A -> Rat),
    ~ (sumList ls f) == 0 ->
    exists b : _,
      In b ls /\
      ~ ((f b) == 0).
  Abort.

  Theorem sumList_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    (forall b, (f1 b) == (f2 b)) ->
    (sumList ls1 f1) == (sumList ls2 f2).
  Abort.

  Lemma fold_add_init : forall (ls : list A)(f : A -> Rat) init1 init2,
    fold_left (fun (r : Rat) (a : A) => r + (f a)) ls (init1 + init2) == 
    init1 + (fold_left (fun (r : Rat) (a : A) => r + (f a)) ls init2).

  Lemma fold_add_body_eq : forall (ls : list A)(f1 f2 : A -> Rat) init1 init2,
    init1 == init2 ->
    (forall a, In a ls -> f1 a == f2 a) ->
    fold_left (fun r a => r + (f1 a)) ls init1 == fold_left (fun r a => r + (f2 a)) ls init2.

  Lemma fold_add_rat_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    forall init1 init2, 
      init1 == init2 ->
      (forall (a : A), In a ls1 -> (f1 a) == (f2 a)) ->
      fold_left (fun r a => r + (f1 a)) ls1 init1 == fold_left (fun r a => r + (f2 a)) ls2 init2.

  Lemma fold_add_f_inverse : forall (B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A) fa init1 init2,
    (init1 == init2) ->
    (forall a, In a ls -> f_inv (f a) = a) ->
    fold_left (fun r b => r + fa (f_inv b)) (map f ls) init1 ==
    fold_left (fun r a => r + (fa a)) ls init2.

   Lemma sumList_0 : forall (ls : list A) f,
    (sumList ls f == 0) <-> (forall a, In a ls -> (f a) == 0).

  Lemma sumList_nz : forall (ls : list A) f,
    (~sumList ls f == 0) <-> exists a : _, In a ls /\ (~f a == 0).

End SumList.

Lemma fold_add_init_0 : forall (A : Set)(ls : list A) f init,
  fold_left (fun r a => r + (f a)) ls init == init + fold_left (fun r a => r + (f a)) ls 0.

Lemma fold_add_eq_init : forall (A : Set)(ls : list A) init,
  fold_left (fun r a => r + 0) ls init == init.

Lemma fold_add_eq_init_f : forall (A : Set)(ls : list A) f init,
  (forall a, In a ls -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls init == init.

Lemma fold_add_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat) init1 init2,
  fold_left (fun r a => r + (f1 a)) ls init1 + 
  fold_left (fun r a => r + (f2 a)) ls init2 ==
  fold_left (fun r a => r + (f1 a + f2 a)) ls (init1 + init2).

Lemma fold_add_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  fold_left (fun r1 a => r1 + (fold_left (fun r2 b => r2 + (f a b)) lsb 0)) lsa 0  == 
  fold_left (fun r1 b => r1 + (fold_left (fun r2 a => r2 + (f a b)) lsa 0)) lsb 0.

Lemma sumList_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) == 
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma sumList_body_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a == f2 a) ->
  sumList ls f1 == sumList ls f2.

Lemma fold_add_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) init c,
  fold_left (fun r a => r + (f a) * c) ls (init * c) == 
  (fold_left (fun r a => r + (f a)) ls init) * c.
    
Lemma sumList_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) c,
  sumList ls (fun a => (f a) * c) == (sumList ls f) * c.
    
Lemma sumList_factor_constant_l:
  forall (A : Set) (ls : list A) (f : A -> Rat) (c : Rat),
    sumList ls (fun a : A => c * f a) == c * sumList ls f.

Lemma fold_add_body_const : forall (A : Set)(ls : list A) c init,
  fold_left (fun r a => r + c) ls init == c * (length ls / 1) + init.

Lemma sumList_body_const : forall (A : Set)(ls : list A) c,
  sumList ls (fun a => c) == c * (length ls / 1).

Lemma fold_add_iter_le : forall (A : Set)(ls : list A) f r init,
  fold_left (fun r a => r + (f a)) ls init <= r ->
  init <= r /\ 
  (forall a, In a ls -> f a <= r).

Lemma sumList_iter_le : forall (A : Set)(ls : list A) f r a,
  sumList ls f <= r ->
  In a ls ->
  f a <= r.

Fixpoint removeFirst(A : Set)(eqd : eq_dec A)(ls : list A) a :=
  match ls with
    | nil => nil
    | a' :: ls' =>
      if (eqd a a') then ls' else a' :: (removeFirst eqd ls' a)
  end.

Lemma removeFirst_permutation : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  In a ls ->
  Permutation ls (a :: (removeFirst eqd ls a)).

Lemma removeFirst_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  ~In a1 ls ->
  ~In a1 (removeFirst eqd ls a2).

Lemma removeFirst_NoDup_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a : A),
  NoDup ls ->
  ~In a (removeFirst eqd ls a).

Lemma removeFirst_NoDup : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  NoDup ls ->
  NoDup (removeFirst eqd ls a).

Lemma removeFirst_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a1 a2 : A),
  In a1 ls ->
  a1 <> a2 ->
  In a1 (removeFirst eqd ls a2).

Lemma removeFirst_in_iff : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  In a1 (removeFirst eqd ls a2) ->
  In a1 ls.

Fixpoint matchOrder (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) :=
  match ls1 with
    | nil => ls2
    | a :: ls1' => 
      a :: (matchOrder eqd ls1' (removeFirst eqd ls2 a))
  end.

Lemma matchOrder_In : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 <-> In a (matchOrder eqd ls1 ls2)).

Lemma matchOrder_not_in_h : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  ~In a ls1 -> 
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_not_in : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  (forall a, In a ls1 -> In a ls2) ->
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_NoDup : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  (forall a, In a ls1 -> In a ls2) ->
  NoDup ls2 ->
  NoDup ls1 ->
  NoDup (matchOrder eqd ls1 ls2).

Require Import Permutation.

Lemma matchOrder_permutation : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  Permutation ls2 (matchOrder eqd ls1 ls2).

Lemma matchOrder_firstn : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  firstn (length ls1) (matchOrder eqd ls1 ls2) = ls1.

Lemma fold_add_matchOrder : forall (A : Set)(ls : list A)(f : A -> Rat) n init1 init2,
  init1 == init2 ->
  NoDup ls ->
  (forall a, In a ls -> (~In a (firstn n ls)) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) (firstn n ls) init1 == fold_left (fun r a => r + (f a)) ls init2.

Lemma permutation_NoDup : forall (A : Type)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  NoDup ls1 ->
  NoDup ls2.

Lemma fold_add_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  sumList ls1 f == sumList ls2 f.

Fixpoint flatten(A : Type)(ls : list (list A)) :=
  match ls with
    | nil => nil
    | a :: ls' => a ++ (flatten ls')
  end.

Theorem in_flatten : forall (A : Set)(ls : list (list A)) a,
  In a (flatten ls) <->
  exists x : _, In x ls /\ In a x.

Theorem length_flatten_nz : forall (A : Type)(ls : list (list A)) ls',
  In ls' ls ->
  length ls' > 0 ->
  length (flatten ls) > 0.

Fixpoint getUnique(A : Set)(ls : list A)(pf : eq_dec A) : list A :=
  match ls with
    | nil => nil
    | a :: ls' => 
      let ls'' := (getUnique ls' pf) in
        if (in_dec pf a ls'') 
          then ls''
          else a :: ls''
  end.

Theorem in_getUnique_if : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a (getUnique ls eqd) ->
  In a ls.

Theorem in_getUnique : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a ls ->
  In a (getUnique ls eqd).

Lemma getUnique_NoDup : forall (A : Set)(ls : list A)(eqd: eq_dec A),
  NoDup (getUnique ls eqd).

Theorem length_getUnique_nz : forall (A :Set)(eqd : eq_dec A)(ls : list A),
  length ls > 0 ->
  length (getUnique ls eqd) > 0.

Definition maxList(ls : list nat) : nat :=
  fold_left max ls O.

Lemma fold_left_max_ge_init : forall (ls : list nat)(n : nat),
  fold_left max ls n >= n.

Lemma maxList_correct_h : forall (ls : list nat)(n init : nat),
  In n ls ->
  fold_left max ls init >= n.

Theorem maxList_correct : forall (ls : list nat) n,
  In n ls ->
  maxList ls >= n.

Inductive pred_count(A : Type)(p : A -> Prop) : list A -> nat -> Prop :=
  | pc_nil : 
    pred_count p nil 0
  | pc_yes : 
    forall ls n a,
    pred_count p ls n ->
    p a ->
    pred_count p (a :: ls) (S n)
  | pc_no : forall ls n a,
    pred_count p ls n ->
    ~p a ->
    pred_count p (a :: ls) n.

Lemma pred_count_le_length : forall (A : Type)(P : A -> Prop) ls c,
  pred_count P ls c ->
  (c <= length ls)%nat.

Fixpoint listRepeat(A : Type)(a : A) n :=
  match n with
    | 0 => nil
    | S n' => a :: (listRepeat a n')
  end.

Lemma listRepeat_length : forall n (A : Type) (a : A),
  length (listRepeat a n) = n.

Lemma pred_count_listRepeat_eq_inv : forall n (A : Type)(a : A) count,
  pred_count (eq a) (listRepeat a n) count ->
  count = n.

Lemma pred_count_listRepeat_ne_inv : forall n (A : Type)(a1 a2 : A) count,
  a1 <> a2 ->
  pred_count (eq a1) (listRepeat a2 n) count ->
  count = O.

Lemma pred_count_func : forall (A : Type)(P : A -> Prop)(ls : list A) n1 n2,
  pred_count P ls n1 ->
  pred_count P ls n2 ->
  n1 = n2.

Lemma pred_count_eq_all_inv : forall (A : Type)(ls : list A)(P : A -> Prop) c,
  pred_count P ls c ->
  (forall a, In a ls -> P a) ->
  c = length ls.

Lemma pred_count_first_skip : forall (A : Type)(P : A -> Prop)(ls : list A)(c : nat),
  pred_count P ls c ->
  forall n,
    exists c1 c2,
      pred_count P (firstn n ls) c1 /\
      pred_count P (skipn n ls) c2 /\
      (c1 + c2 = c)%nat.

Lemma pred_count_eq_all : forall (A : Type)(P : A -> Prop)(ls : list A) n,
  (forall a, In a ls -> P a) ->
  n = length ls ->
  pred_count P ls n.

Lemma pred_count_eq_none : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, In a ls -> ~P a) ->
  pred_count P ls 0.

Lemma in_listRepeat_inv : forall n (A : Type)(a1 a2 : A),
  In a1 (listRepeat a2 n) ->
  a1 = a2.

Lemma pred_count_app : forall (A : Type)(P : A -> Prop)(ls1 ls2 : list A) n1 n2,
  pred_count P ls1 n1 ->
  pred_count P ls2 n2 ->
  pred_count P (ls1 ++ ls2) (n1 + n2).

Lemma pred_count_permutation : forall (A : Set)(P : A -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall c, 
    pred_count P ls1 c ->
    pred_count P ls2 c.

Lemma pred_count_eq_none_inv : forall (A : Set)(P : A -> Prop)(ls : list A) c,
  pred_count P ls c ->
  (forall a, In a ls -> ~P a) ->
  c = O.

Lemma pred_count_eq_1_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> Prop)(ls : list A) c a,
  pred_count P ls c ->
  NoDup ls ->
  P a ->
  In a ls ->
  (forall a', In a' ls -> a <> a' -> ~P a') ->
  c = (S O).

Lemma pred_count_left_total : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, P a \/ ~P a) ->
  exists c, pred_count P ls c.

Inductive rel_map(A B : Type)(r : A -> B -> Prop) : list A -> list B -> Prop :=
| rm_nil : 
  rel_map r nil nil
| rm_step : 
  forall lsa lsb a b,
    rel_map r lsa lsb ->
    r a b ->
    rel_map r (a :: lsa) (b :: lsb).

Theorem rel_map_map2 : forall (A B C D : Type)(ls_c : list C)(ls_d: list D)(P : A -> B -> Prop)(f1 : C -> A)(f2 : D -> B),
  rel_map (fun a b => P (f1 a) (f2 b)) ls_c ls_d ->
  rel_map P (map f1 ls_c) (map f2 ls_d).

Lemma rel_map_length : forall (A B : Type)(lsa : list A)(P : A -> B -> Prop)(lsb : list B),
  rel_map P lsa lsb ->
  length lsa = length lsb.

Lemma rel_map_unary_pred : forall (A B : Type)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(P' : B -> Prop),
  rel_map P lsa lsb ->
  (forall a b, P a b -> P' b) ->
  forall b, In b lsb -> P' b.

Lemma rel_map_eq_inv : forall (A B : Type)(ls1 ls2 : list A)(rel1 rel2 : A -> B -> Prop) ls1' ls2',
  ls1 = ls2 ->
  (forall a b1 b2, rel1 a b1 -> rel2 a b2 -> b1 = b2) ->
  rel_map rel1 ls1 ls1' ->
  rel_map rel2 ls2 ls2' ->
  ls1' = ls2'.

Lemma rel_map_eq : forall (A B : Type)(ls1 : list A)(rel1 : A -> B -> Prop) ls',
  rel_map rel1 ls1 ls' ->
  forall ls2 (rel2 : A -> B -> Prop), 
    ls1 = ls2 ->
    (forall a b, In a ls1 -> In b ls' -> rel1 a b -> rel2 a b) ->
    rel_map rel2 ls2 ls'.

Theorem pred_count_eq_0 : forall (A B : Set)(ls : list B)(ls' : list A)(f : B -> A -> Prop)(P : A -> Prop) v,
  (forall a b, In b ls -> f b a -> ~ P a) ->
  rel_map f ls ls' ->
  pred_count P ls' v ->
  v = O.

Lemma rel_map_app_inv : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb : list B),
  rel_map rel (lsa1 ++ lsa2) lsb ->
  (rel_map rel lsa1 (firstn (length lsa1) lsb) /\ rel_map rel lsa2 (skipn (length lsa1) lsb)).

Lemma rel_map_map_inv : forall (A B C : Type)(rel : B -> C -> Prop)(f : A -> B)(lsa : list A)(lsc : list C),
  rel_map rel (map f lsa) lsc ->
  rel_map (fun a c => rel (f a) c) lsa lsc.

Lemma rel_map_listRepeat : forall (A B : Set)(lsa : list A)(rel : A -> B -> Prop) b,
  (forall a, In a lsa -> rel a b) ->
  rel_map rel lsa (listRepeat b (length lsa)).

Lemma rel_map_app : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
  rel_map rel lsa1 lsb1 ->
  rel_map rel lsa2 lsb2 ->
  rel_map rel (lsa1 ++ lsa2) (lsb1 ++ lsb2).

Lemma rel_map_map : forall (A B C : Type)(f : A -> B)(rel : B -> C -> Prop) lsa lsc,
  rel_map (fun a c => rel (f a) c) lsa lsc ->
  rel_map rel (map f lsa) lsc.

Lemma rel_map_inverse : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb -> 
  forall b, 
    In b lsb ->
    exists a, In a lsa /\ rel a b.

Lemma ne_all_not_in : forall (A : Type)(ls : list A) a,
  (forall a', In a' ls -> a <> a') ->
  ~In a ls.

Lemma rel_map_NoDup : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  NoDup lsa ->
  (forall a1 a2 b1 b2, In a1 lsa -> In a2 lsa -> a1 <> a2 -> rel a1 b1 -> rel a2 b2 -> b1 <> b2) ->
  NoDup lsb.

Lemma rel_map_in : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
  forall b a,
    In a lsa ->
    rel a b ->
    In b lsb.

Lemma rel_map_left_total : forall (A B : Type)(rel : A -> B -> Prop)(lsa : list A),
  (forall a, exists b, rel a b) ->
  exists lsb, rel_map rel lsa lsb.

Lemma rel_map_func : forall (A B : Type) (rel : A -> B -> Prop) lsa lsb1,
  rel_map rel lsa lsb1 ->
  forall lsb2,
    rel_map rel lsa lsb2 ->
    (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
    lsb1 = lsb2.

Lemma rel_map_permutation : forall (A B : Type) lsa1 lsa2,
  Permutation lsa1 lsa2 ->
  forall (rel : A -> B -> Prop),
    (forall a b1 b2, rel a b1 -> rel a b2 -> b1 = b2) ->
    (forall a, exists b, rel a b) ->
    forall lsb1 lsb2,
      rel_map rel lsa1 lsb1 ->
      rel_map rel lsa2 lsb2 ->     
      Permutation lsb1 lsb2.

Lemma rel_map_impl : forall (A B : Type)(rel1 rel2 : A -> B -> Prop) lsa lsb,
  rel_map rel1 lsa lsb ->
  (forall a b, In a lsa -> rel1 a b -> rel2 a b) ->
  rel_map rel2 lsa lsb.

Lemma rel_map_in_inv : forall (A B : Type)(rel : A -> B -> Prop) lsa lsb,
  rel_map rel lsa lsb ->
  forall a, In a lsa -> exists b, In b lsb /\ rel a b.

Inductive sumList_rel(A : Type)(rel : A -> Rat -> Prop) : list A -> Rat -> Prop :=
| slr_nil :
  forall r, 
    r == rat0 ->
    sumList_rel rel nil r
| slr_cons : 
  forall (ls : list A)(a : A) r1 r2 r3,
    sumList_rel rel ls r1 ->
    rel a r2 ->
    r3 == r2 + r1 ->
    sumList_rel rel (a :: ls) r3.

Lemma sumList_rel_distance : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r r1 r2,
  (forall a r1 r2, In a ls -> f1 a r1 -> f2 a r2 -> (ratDistance r1 r2) <= r) ->
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  ratDistance r1 r2 <= (r * (length ls / 1)).

Lemma sumList_rel_all_0_inv : forall (A : Set)(ls : list A)(r  : Rat)(rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a' v, In a' ls -> rel a' v -> v == 0) ->
  r == 0.

Lemma sumList_rel_only_one_inv : forall (A : Set)(rel : A -> Rat -> Prop)(ls : list A)(a : A) r r',
  sumList_rel rel ls r' ->
  In a ls ->
  NoDup ls -> 
  (forall a', In a' ls -> a <> a' -> forall v, rel a' v -> v == 0) ->
  (forall v, rel a v -> v == r) ->
  r' == r.

Lemma sumList_rel_body_eq : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma sumList_rel_plus_inv : forall (A : Type)(ls : list A) r (rel1 rel2 rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a r, In a ls -> rel a r -> forall r1 r2, rel1 a r1 -> rel2 a r2 -> r == r1 + r2) ->
  forall r1 r2, sumList_rel rel1 ls r1 -> sumList_rel rel2 ls r2 -> r == r1 + r2.

Lemma sumList_rel_left_total : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> exists r, rel a r) ->
  exists r, sumList_rel rel ls r.

Lemma sumList_rel_factor_constant : forall (p1 p2 : posnat) (A : Type)(rel : A -> Rat -> Prop)(ls : list A) r,
  sumList_rel (fun a r' => rel a (r' * (RatIntro p1 p2))) ls (r * (RatIntro p2 p1)) ->
  sumList_rel rel ls r.

Lemma sumList_rel_permutation : forall (A : Type)(rel : A -> Rat -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall r, 
    sumList_rel rel ls1 r ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_all_0 : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> rel a 0) ->
  sumList_rel rel ls 0.

Lemma sumList_rel_ls_intersect: forall (A : Set)(rel : A -> Rat -> Prop)(ls1 : list A) r,
  sumList_rel rel ls1 r ->
  forall ls2, 
    NoDup ls1 ->
    NoDup ls2 ->
    eq_dec A ->
    (forall a r1 r2, In a ls1 -> rel a r1 -> rel a r2 -> r1 == r2) -> 
    (forall a, In a ls1 -> ~In a ls2 -> rel a 0) ->
    (forall a, In a ls2 -> ~In a ls1 -> rel a 0) ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_sumList : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a = r) ls
  (sumList ls f).

Lemma sumList_cons : forall (A : Set)(ls : list A) a f,
  sumList (a :: ls) f == f a + (sumList ls f).

Lemma sumList_sum : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  sumList ls (fun a => f1 a + f2 a) ==
  sumList ls f1 + sumList ls f2.

Lemma sumList_summation : forall (A B : Set) f (lsa : list A)(lsb : list B),
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) ==
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma fold_add_subset' : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 -> (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset'
  : forall A : Set,
    eq_dec A ->
    forall (ls1 ls2 : list A) (f : A -> Rat),
      NoDup ls1 ->
      NoDup ls2 ->
      (forall a : A, In a ls1 -> In a ls2) ->
      (forall a : A, In a ls2 -> ~ In a ls1 -> f a == 0) ->
      sumList ls1 f == sumList ls2 f.

Lemma sumList_exactly_one : forall (A : Set) a (ls : list A) f,
  NoDup ls ->
  In a ls ->
  (forall b, In b ls -> a <> b -> f b == 0) ->
  sumList ls f == f a.

Lemma fold_add_permutation : forall (A : Set) ls1 ls2,
  Permutation ls1 ls2 ->
  forall (f : A -> Rat) init1 init2,
    init1 == init2 ->
    fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_permutation : forall (A : Set)(f : A -> Rat) ls1 ls2,
  Permutation ls1 ls2 ->
  sumList ls1 f == sumList ls2 f.

Lemma sumList_rel_body_eq_strong : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', In a ls1 -> rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma rel_map_left_total_strong' : forall (A B : Type)(lsa : list A)(P : A -> Prop)(rel : A -> B -> Prop),
  (forall a, P a -> exists b, rel a b) ->
  (forall a, In a lsa -> P a) ->
  exists lsb, rel_map rel lsa lsb.

Lemma firstn_eq_all_gen : forall (A : Type)(ls : list A) n,
  n = length ls ->
  firstn n ls = ls.

Fixpoint getNats s n :=
  match n with 
    | O => nil
    | S n' => (s + n')%nat :: (getNats s n')
  end.

Lemma ratMult_sumList_rel_distrib : forall (A : Set)(ls : list A) f (x : Rat -> Prop) x' a,
  sumList_rel f ls a ->
  (forall i v1 v2, f i v1 -> f i v2 -> v1 == v2) ->
  (forall x1 x2, x x1 -> x x2 -> x1 == x2) ->
  x x' -> 
  sumList_rel (fun i => ratMult_rel x (f i)) ls (x' * a).

Lemma series_le : forall n (f1 f2 : nat -> Rat -> Prop) r1 r2,
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->
  sumList_rel f1 (getNats O n) r1 ->
  sumList_rel f2 (getNats O n) r2 ->
  r2 <= r1.

Lemma ratSubtract_series_map : forall n f1 f2 a1 a2,
  n > 0 ->
  sumList_rel f1 (getNats O n) a1 ->
  sumList_rel f2 (getNats O n) a2 ->
  (forall i x1 x2, f1 (S i) x1 -> f2 i x2 -> x1 == x2) ->
  (forall i v1 v2, f1 i v1 -> f1 i v2 -> v1 == v2) ->
  (forall i v1 v2, f2 i v1 -> f2 i v2 -> v1 == v2) ->
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->  
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f1 i1 v1 -> f1 i2 v2 -> v2 <= v1) ->
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f2 i1 v1 -> f2 i2 v2 -> v2 <= v1) ->
  forall x1 x2,
    f1 O x1 -> f2 (pred n) x2 ->
    ratSubtract a1 a2 == ratSubtract x1 x2.

Lemma sum_power_series : forall n (f : Rat -> Prop) a a',
  n > 0 ->
  (exists v, f v) ->
  (forall v1 v2, f v1 -> f v2 -> v1 == v2) ->
  (forall v, f v -> ~1 <= v) ->
  sumList_rel (fun i : nat => expRat_rel f i) (getNats 0 n) a ->
  ratMult_rel (ratSubtract_rel (eqRat 1) (expRat_rel f n))
         (ratInverse_rel (ratSubtract_rel (eqRat 1) f)) a' ->
         a == a'.

Lemma sumList_rel_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r1 r2,
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  (forall a v1 v2, In a ls -> f1 a v1 -> f2 a v2 -> v1 <= v2) ->
  r1 <= r2.

Lemma sumList_filter_le : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool),
  sumList (filter P ls) f <= sumList ls f.

Lemma sumList_filter_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f == (sumList (filter P ls) f + (sumList (filter (fun a => negb (P a)) ls) f)).

Lemma sumList_rel_sumList_eqRat : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a == r) ls
  (sumList ls f).

Lemma sumList_series_incr : forall n2 n1 (f f' : nat -> Rat),
  (forall n, (f n) == (f' (S n))) ->
  sumList (getNats n1 n2) f == sumList (getNats (S n1) n2) f'.

Lemma sumList_series_split_first : forall n f, 
  sumList (n :: getNats O n) f == f O + (sumList (getNats 1 n) f).

Lemma firstn_nil : forall (A : Set) n, 
  firstn n nil = (@nil A).

Lemma firstn_ge_all : forall n (A : Set) (ls : list A),
  n >= length ls ->
  firstn n ls = ls.

Lemma firstn_app : forall n (A : Set) (ls1 ls2 : list A),
  (n <= length ls1)%nat ->
  firstn n (ls1 ++ ls2) = firstn n ls1.

Lemma sumList_rel_func : forall (A : Set)(f : A -> Rat -> Prop) ls r1,
  sumList_rel f ls r1 ->
  forall r2,
  sumList_rel f ls r2 ->
  (forall a v1 v2, f a v1 -> f a v2 -> v1 == v2) ->
  r1 == r2.

Lemma sumList_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f ==
  sumList ls (fun a => (f a) * (if (P a) then 1 else 0)) + 
  sumList ls (fun a => (f a) * (if (P a) then 0 else 1)).

Lemma sumList_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a <= f2 a) ->
  sumList ls f1 <= sumList ls f2.

Lemma sumList_distance_prod : forall (A : Set)(ls : list A)(f f1 f2 : A -> Rat),
  | (sumList ls (fun a => (f a) * (f1 a))) - (sumList ls (fun a => (f a) * (f2 a))) | <= sumList ls (fun a => (f a) * | (f1 a) - (f2 a) |).

Theorem sumList_all : 
  forall (A : Set)(ls : list A)(f : A -> Rat) c,
    (forall a, In a ls -> (f a) == c) ->
    sumList ls f == (length ls)/1 * c.

Theorem filter_app : 
  forall (A : Set)(ls1 ls2 : list A)(f : A -> bool),
    filter f (ls1 ++ ls2) = filter f ls1 ++ filter f ls2.

Theorem filter_true : 
  forall (A : Set)(ls : list A)(f : A -> bool),
    (forall a, In a ls -> (f a) = true) ->
    filter f ls = ls.

Theorem sumList_subset_le : 
  forall (A : Set){eqd: EqDec A}(ls1 ls2 : list A)(f : A -> Rat),
    NoDup ls1 ->
    NoDup ls2 ->
    (forall a, In a ls1 -> In a ls2) ->
    sumList ls1 f <= sumList ls2 f.

Fixpoint allNatsLt (n : nat) :=
  match n with
    | 0 => nil
    | S n' => allNatsLt n' ++ (n' :: nil)
  end.

Lemma allNatsLt_length : 
  forall n, 
    length (allNatsLt n) = n.

Lemma allNatsLt_lt : 
  forall n v,
    In v (allNatsLt n) ->
    v < n.

Lemma app_NoDup : forall(A : Set)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> ~In a ls2) ->
  (forall a, In a ls2 -> ~In a ls1) ->
  NoDup (ls1 ++ ls2).

Lemma allNatsLt_NoDup : 
  forall (n : nat),
    NoDup (allNatsLt n).

Lemma allNatsLt_lt_if : 
  forall (n i : nat), 
    i < n ->
    In i (allNatsLt n).

Lemma nth_allNatsLt_lt : 
  forall k n,
    n < k ->
    nth n (allNatsLt k) n = n.

Lemma nth_allNatsLt : 
  forall k n,
    nth n (allNatsLt k) n = n.

Theorem allNatsLt_filter_lt : 
  forall (p n : nat),
    (n <= p)%nat->
    filter (fun z => if (lt_dec z n) then true else false) (allNatsLt p) = 
    allNatsLt n.

Theorem map_eq_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    map f1 ls = map f2 ls ->
    (forall a, In a ls -> f1 a = f2 a).

Theorem map_eq_if_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    (forall a, In a ls -> f1 a = f2 a) ->
    map f1 ls = map f2 ls.

Theorem map_eq_subset : 
  forall (A B : Type)(ls2 ls1 : list A)(f1 f2 : A -> B),
    map f1 ls1 = map f2 ls1 ->
    (forall a, In a ls2 -> In a ls1) ->
    map f1 ls2 = map f2 ls2.

Fixpoint getSomes(A : Type)(ls : list (option A)) :=
  match ls with
    | nil => nil
    | o :: ls' =>
      match o with
        | None => getSomes ls'
        | Some x => x :: (getSomes ls')
      end
  end.

Lemma nth_nil:
  forall (A : Set)(i : nat)(def : A),
    nth i nil def = def.

Theorem listReplace_None_Permutation : 
  forall (A : Set) n ls (y : A),
    nth n ls None = None ->
    Permutation (getSomes (listReplace ls n (Some y) None)) (y :: (getSomes ls)).

Theorem listReplace_getSomes_Permutation_h : 
  forall (A : Set) l1' l2,
    Permutation l1' l2 ->
    forall l1 n2 (y : A),
      l1' = getSomes l1 ->
      nth n2 l1 None = None ->
      Permutation
        (getSomes
           (listReplace l1 n2
                        (Some y) None))
        (y :: l2).

Theorem listReplace_getSomes_Permutation : 
  forall (A : Set) l1 l2 n2 (y : A),
    nth n2 l1 None = None ->
    Permutation (getSomes l1) l2 ->
    Permutation
      (getSomes
         (listReplace l1 n2
                      (Some y) None))
      (y :: l2).

Lemma nth_listReplace_ne : 
  forall (i1 i2 : nat)(A : Set)(ls : list A)(a def : A),
    i1 <> i2 ->
    nth i1 (listReplace ls i2 a def) def = 
    nth i1 ls def.

Theorem listReplace_length :
  forall (A : Set)(ls : list A)(i : nat)(a def : A),
    i < length ls ->
    length (listReplace ls i a def) = length ls.

Lemma listReplace_in_nil : 
  forall (A : Set)(i : nat)(a1 a2 def : A),
    In a1 (listReplace nil i a2 def) ->
    a1 = a2 \/ a1 = def.

Lemma listReplace_in : 
  forall (A : Set)(ls : list A)(a1 a2 def : A)(i : nat),
    In a1 (listReplace ls i a2 def) ->
    (In a1 ls \/ a1 = a2 \/ a1 = def).

Theorem firstn_map : 
  forall (A B : Set)(f : A -> B)(ls : list A) n,
    firstn n (map f ls) = map f (firstn n ls).

Lemma firstn_app_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    firstn (length ls1) (ls1 ++ ls2) = ls1.

Theorem map_nth_in : 
  forall (A B : Set)(ls : list A)(f : A -> B) i defa defb,
    i < length ls ->
    nth i (map f ls) defb = f (nth i ls defa).

Lemma flatten_app : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    flatten (ls1 ++ ls2) = flatten ls1 ++ flatten ls2.

Inductive list_pred(A B : Set)(pred : A -> B -> Prop) : list A -> list B -> Prop :=
| list_pred_nil : 
    list_pred pred nil nil
| list_pred_cons : 
    forall a1 a2 ls1 ls2,
      pred a1 a2 ->
      list_pred pred ls1 ls2 ->
      list_pred pred (a1 :: ls1) (a2 :: ls2).

Lemma list_pred_eq_impl_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    list_pred eq ls1 ls2 ->
    ls1 = ls2.

Lemma flatten_eq : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred eq ls1 ls2 ->
    flatten ls1 = flatten ls2.

Theorem app_cons_eq : 
  forall (A : Type) ls2 ls1 (a : A),
    ls2 ++ (a :: ls1) = (ls2 ++ (a :: nil)) ++ ls1.

Theorem skipn_nil : 
  forall (A : Type) n,
    skipn n (@nil A) = nil.

Theorem nth_In_exists : 
  forall (A : Type)(ls : list A) a def,
    In a ls ->
    exists n, nth n ls def = a.

Theorem nth_skipn_eq : 
  forall (A : Set)(y x: nat)(ls : list A)(def : A),
    nth x (skipn y ls) def = nth (x + y) ls def.

Theorem perm_flatten_listReplace_nil : 
  forall b (A : Set)(a : A),
    Permutation (flatten (listReplace nil b (a :: nil) nil)) (a :: nil).

Theorem perm_flatten_listReplace : 
  forall b (A : Set)(ls1 : list (list A))(ls2 : list A) (a : A),
    Permutation (flatten ls1) ls2 ->
    Permutation (flatten (listReplace ls1 b (nth b ls1 nil ++ (a :: nil)) nil))
                (a :: ls2).

Theorem map_cons : 
  forall (A B : Type)(f : A -> B)(ls : list A)(a : A),
    map f (a :: ls) = (f a) :: map f ls.

Theorem app_eq_inv : 
  forall (A : Type)(ls1 ls2 ls3 ls4 : list A),
    length ls1 = length ls3 ->
    (ls1 ++ ls2) = (ls3 ++ ls4) ->
    ls1 = ls3 /\ ls2 = ls4.

Theorem NoDup_app : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1 /\
    NoDup ls2 /\
    (forall a1 a2,
       In a1 ls1 ->
       In a2 ls2 ->
       a1 <> a2).

Theorem firstn_In : 
  forall (A : Type) n (ls : list A)(a : A),
             In a (firstn n ls) ->
             In a ls.

Theorem pred_firstn_In :
  forall (A : Set) ls1 ls2,
    list_pred (fun x0 y : list A => exists n : nat, y = firstn n x0) ls1 ls2 ->
    forall a,
      In a (flatten ls2) -> In a (flatten ls1).

Theorem firstn_NoDup : 
  forall (A : Type) n (ls : list A),
    NoDup ls ->
    NoDup (firstn n ls).
 
Theorem NoDup_flatten_subset : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred (fun x y => exists n, y = firstn n x) ls1 ls2 ->
    NoDup (flatten ls1) ->
    NoDup (flatten ls2).

Theorem allNatsLt_nil_inv :
  forall n,
    allNatsLt n = nil ->
    n = O.
  
Theorem firstn_allNatsLt_h : 
  forall ls n1 n2,
    n2 >= n1 ->
    ls = (allNatsLt n2) ->
    firstn n1 ls = allNatsLt n1.

Theorem firstn_allNatsLt : 
  forall n1 n2,
    n2 >= n1 ->
    firstn n1 (allNatsLt n2) = allNatsLt n1.

Theorem NoDup_app_l : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1.

Theorem NoDup_map : 
  forall (A B : Type)(f : A -> B)(ls : list A),
    NoDup (map f ls) ->
    (NoDup ls /\ (forall b1 b2, In b1 ls -> In b2 ls -> f b1 = f b2 -> b1 = b2)).

Theorem map_fst_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (fst x)) (combine ls lsc).

Theorem map_snd_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (snd x)) (combine lsc ls).

Theorem In_combine_NoDup_eq_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a1 a2 b,
    NoDup lsb ->
    In (a1, b) (combine lsa lsb) ->
    In (a2, b) (combine lsa lsb) ->
    a1 = a2.

Theorem In_combine_NoDup_eq_r : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a b1 b2,
    NoDup lsa ->
    In (a, b1) (combine lsa lsb) ->
    In (a, b2) (combine lsa lsb) ->
    b1 = b2.

Theorem zip_eq_nil_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = nil ->
    length lsa = length lsb ->
    lsa = nil.

Theorem fst_split_app_eq : 
  forall (A B : Type)(ls1 ls2 : list (A * B)),
    fst (split (ls1 ++ ls2)) = 
    fst (split ls1) ++ fst (split ls2).

Theorem fst_split_flatten_eq : 
  forall (A B : Type)(ls : list (list (A * B))),
    fst (split (flatten ls)) = 
    flatten (map (fun x => fst (split x)) ls).

Theorem fst_split_map_eq : 
  forall (A B C : Type)(ls : list A)(f : A -> B * C),
    fst (split (map f ls)) = 
    map (fun a => fst (f a)) ls.

Theorem in_split_l_if : 
  forall (A B : Type)(ls : list (A * B)) a,  
    In a (fst (split ls)) -> 
    exists b,
      In (a, b) ls.

Theorem in_fst_split_if : 
  forall (A B : Type)(ls : list (A * B)) a b,
    In (a, b) ls ->
    In a (fst (split ls)).

Theorem map_pair_fst_eq : 
  forall (A B C D: Type)(f1 : B -> D)(f2 : C -> D)(ls1 : list B)(ls2 : list C)(a1 a2 : A),
    map (fun x => (a1, f1 x)) ls1 = map (fun x => (a2, f2 x)) ls2 ->
    ls1 <> nil ->
    a1 = a2.

Theorem In_zip_strong : 
  forall (A B : Set)(ls : list A) f a (b : B),
    In (a, b) (zip ls (map f ls)) ->
    (In a ls /\ b = f a).

Lemma list_pred_impl : 
  forall (A B : Set)(lsa : list A)(lsb : list B) (P1 : A -> B -> Prop),
       list_pred P1 lsa lsb ->
       forall (P2 : A -> B -> Prop), 
         (forall a b, P1 a b -> P2 a b) ->
         list_pred P2 lsa lsb.

Theorem list_pred_eq_in : 
  forall (A : Set)(ls : list A),
    list_pred (fun a b => a = b /\ In a ls /\ In b ls) ls ls.

Theorem zip_combine_eq : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = combine lsa lsb.

Theorem list_pred_fst_split_eq : 
  forall (A B C : Set)(ls1 : list (A * B))(ls2 : list (A * C)),
    list_pred (fun a b => fst a = fst b) ls1 ls2 ->
    fst (split ls1)  = fst (split ls2).

Theorem unzip_eq_split : 
  forall (A B : Set)(ls : list (A * B)),
    unzip ls = split ls.

Theorem in_split_r_if:
  forall (A B : Type) (ls : list (A * B)) (b : B),
    In b (snd (split ls)) -> exists a : A, In (a, b) ls.

Fixpoint nth_option(A : Set)(ls : list A)(i : nat) :=
  match ls with 
    | nil => None
    | a :: ls' =>
      match i with
        | O => Some a
        | S i' =>
          nth_option ls' i'
          end
  end.

Theorem nth_option_app_Some : 
  forall (A : Set)(ls1 ls2 : list A) i a,
    nth_option ls1 i = Some a ->
    nth_option (ls1 ++ ls2) i = Some a.

Theorem nth_option_Some_lt : 
  forall (A : Set)(ls : list A) i a,
    nth_option ls i = Some a ->
    i < length ls.

Theorem nth_option_app_None : 
  forall (A : Set)(ls1 ls2 : list A) i,
    nth_option ls1 i = None ->
    nth_option (ls1 ++ ls2) i = nth_option ls2 (i - length ls1).

Theorem nth_option_None_ge : 
  forall (A : Set)(ls : list A) i,
    nth_option ls i = None ->
    i >= length ls.

Theorem skipn_S_eq : 
  forall (A : Set)(ls : list A) n a,
    nth_option ls n = Some a -> 
    skipn n ls = a :: (skipn (S n) ls).

Theorem nth_option_snd_split : 
  forall (A B : Set)(ls : list (A * B)) n a b,
    nth_option ls n = Some (a, b) ->
    nth_option (snd (split ls)) n = Some b.

Theorem snd_split_map_eq :
  forall (A B C : Set)(ls : list A)(f : A -> B * C),
    snd (split (map f ls)) =
    map (fun p => snd (f p)) ls.

Theorem cons_ne : 
  forall (A : Set)(eqda : eq_dec A)(a1 a2 : A)(ls1 ls2 : list A),
    ((a1 :: ls1) = (a2 :: ls2) -> False) ->
    (a1 <> a2) \/ (ls1 <> ls2).

Theorem map_ne_same_ex : 
  forall (A B : Set)(f1 f2 : A -> B)(ls : list A),
    eq_dec B ->
    map f1 ls <> map f2 ls ->
    exists a, In a ls /\ f1 a <> f2 a.

Theorem list_pred_I_in : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    list_pred (fun a b => In a lsa /\ In b lsb) lsa lsb.

Theorem list_pred_fst_split_eq_l : 
  forall (A B : Set)(a : list (A * B))(b : list A),
    list_pred (fun a0 b0 => fst a0 = b0) a b ->
    b = fst (split a).

Theorem list_pred_fst_split_flatten_eq_l : 
  forall (A B : Set)(a : list (list (A * B)))(b : list (list A)),
    list_pred
      (list_pred
         (fun a0 b0 => fst a0 = b0)) a b ->
    flatten b = fst (split (flatten a)).

Theorem fold_add_const_mult : 
  forall (A : Type)(ls : list A)(c : nat) init,
    (fold_left (fun acc _ => acc + c) ls init = 
     (length ls) * c + init)%nat.

Theorem list_pred_snd_split_eq_l:
  forall (A B : Set) (a : list (B * A)) (b : list A),
    list_pred (fun (a0 : B * A) (b0 : A) => snd a0 = b0) a b ->
    b = snd (split a).

Theorem NoDup_snd_split_if : 
  forall (A B : Type)(ls : list (A * B)),
    NoDup (snd (split ls)) ->
    NoDup ls.

Fixpoint forNats(n : nat) :=
  match n with
      | 0 => nil
      | S n' =>
        cons n' (forNats n')
  end.

Lemma forNats_In : 
  forall n i,
    i < n <->
    In i (forNats n).

Lemma forNats_NoDup : 
  forall n,
    NoDup (forNats n).

Lemma forNats_length : 
  forall n,
    length (forNats n) = n.

Lemma sumList_forNats_first_ls : 
  forall (n : nat)(f : nat -> Rat),
    n <> O ->
    f O <= sumList (forNats n) f.

Lemma sumList_forNats_distance : 
  forall (n : nat)(f : nat -> Rat), 
    (| sumList (forNats n) f - sumList (forNats n) (fun i => f (S i)) |) == (| (f O) - (f n) |).

Lemma flatten_map_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    flatten (map (fun a => (f a) :: nil) ls) =
    map f ls.

Lemma app_NoDup_inv : 
    forall (A : Set)(ls1 ls2 : list A), 
      NoDup (ls1 ++ ls2) ->
      (forall a, In a ls1 -> In a ls2 -> False).

Lemma flatten_NoDup : 
  forall (A : Set)(ls : list (list A)),
    NoDup ls ->
    (forall x, In x ls -> NoDup x) ->
    (forall x1 x2, In x1 ls -> In x2 ls -> x1 <> x2 -> NoDup (x1 ++ x2)) ->
    NoDup (flatten ls).

Lemma map_NoDup'
: forall (A B : Set) (ls : list A) (f : A -> B),
    NoDup ls ->
    (forall a1 a2 : A, In a1 ls -> In a2 ls ->a1 <> a2 -> f a1 <> f a2) -> 
    NoDup (map f ls).

Lemma getUnique_cons : 
  forall (A : Set)(eqd : eq_dec A)(ls2 ls1 : list A) a,
    a :: ls1 = (getUnique ls2 eqd) ->
    exists ls3 ls4, 
      ls2 = ls3 ++ (a :: ls4) /\
      ls1 = (getUnique ls4 eqd).

Lemma getUnique_eq_inv : 
  forall (A : Set)(a : A)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
    getUnique ls1 eqd1 = getUnique ls2 eqd2 ->
    In a ls1 -> 
    In a ls2.

Lemma sumList_app :
  forall (A : Set)(ls1 ls2 : list A)(f : A -> Rat),
    sumList (ls1 ++ ls2) f == (sumList ls1 f) + (sumList ls2 f).

Lemma filter_all_true : 
  forall (A : Set)(ls : list A)(P : A -> bool), 
    (forall a, In a ls -> P a = true) ->
    filter P ls = ls.

Lemma sumList_map : 
  forall (A B : Set)(ls : list A)(f1 : A -> B)(f : B -> Rat),
    sumList (map f1 ls) f == 
    sumList ls (fun a => f (f1 a)).

Lemma sumList_filter_twice : 
  forall (A B : Set)(P : A -> bool)(ls : list A)(lsf : A -> list B)(f : A * B -> Rat),
    sumList (filter (fun p => P (fst p)) (flatten (map (fun a => map (fun b => (a, b)) (lsf a)) ls))) f ==  
    sumList (filter P ls) (fun a => sumList (lsf a) (fun b => f (a, b))).

Lemma filter_cons : 
  forall (A : Set)(P : A -> bool)(ls : list A) a,
    filter P (a :: ls) = 
    if (P a) then (a :: (filter P ls)) else (filter P ls).

Theorem sumList_1_mult : 
  forall (A : Set)(ls : list A),
    sumList ls (fun _ => 1) == length ls / 1.

Theorem fold_left_orb_true_init : 
  forall (A : Type)(f : A -> bool)(ls : list A),
    fold_left (fun b x => orb b (f x)) ls true = true.

Theorem fold_left_orb_true_in : 
  forall (A : Type)(f : A -> bool)(ls : list A) a init,
    In a ls ->
    f a = true ->
    fold_left (fun b x => orb b (f x)) ls init = true.

Theorem hd_error_Some_In : 
  forall (A : Type)(ls : list A) a,
    hd_error ls = Some a ->
    In a ls.

Theorem fold_and_false_init :
  forall (A : Type)(ls : list A) P,
    fold_left (fun b z => b && negb (P z)) ls false = false.

Theorem hd_filter_false_eq_and_false : 
  forall (A : Type)(ls : list A)(P : A -> bool),
    (if hd_error (filter P ls) then false else true) =
    fold_left (fun (b : bool) (z : A) => b && negb (P z)) ls true.

Theorem fst_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (A * B))(ls2 : list A),
    list_pred (fun a b => fst a = b) ls1 ls2 ->
    fst (split ls1) = ls2.

Theorem snd_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (B * A))(ls2 : list A),
    list_pred (fun a b => snd a = b) ls1 ls2 ->
    snd (split ls1) = ls2.

Theorem combine_map_eq : 
  forall (A B C : Type)(lsa : list A)(lsb : list B)(f : B -> C),
    combine lsa (map f lsb) = map (fun p => (fst p, f (snd p))) (combine lsa lsb).

Theorem map_ext_pred : 
  forall (A B C : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> C),
    list_pred P lsa lsb ->
    (forall a b, P a b -> (f1 a) = (f2 b)) ->
    map f1 lsa = map f2 lsb.

Theorem list_pred_combine_l_h : 
  forall (A C : Set)(lsa : list A)(lsc : list C) P1,
    list_pred P1 lsa lsc ->
    forall (B : Set)(lsb : list B) P2, 
      list_pred P2 lsb lsc ->
      list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Theorem list_pred_combine_l : 
  forall (A B C : Set)P1 P2 (lsa : list A)(lsb : list B)(lsc : list C),
    list_pred P1 lsa lsc -> 
    list_pred P2 lsb lsc ->
    list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Lemma list_pred_symm : 
  forall (A B : Set)(P : A -> B -> Prop) lsa lsb,
    list_pred (fun b a => P a b) lsb lsa ->
    list_pred P lsa lsb.

Theorem list_pred_combine_r
: forall (A B C : Set) (P1 : A -> B -> Prop) (P2 : A -> C -> Prop)
         (lsa : list A) (lsb : list B) (lsc : list C),
    list_pred P1 lsa lsb ->
    list_pred P2 lsa lsc ->
    list_pred (fun a p => P1 a (fst p) /\ P2 a (snd p))
              lsa (combine lsb lsc). *)
Import ListNotations.

Lemma false_zgt z a: false = (z >? a) -> z<=a. 
Proof. unfold Z.gtb.
  remember (z ?= a). destruct c. symmetry in Heqc; apply Z.compare_eq in Heqc. subst; intros. omega.
  symmetry in Heqc. destruct (Z.compare_lt_iff z a); intros. apply H in Heqc. omega.
  discriminate.
Qed. 
Lemma false_zge z a: false = (z >=? a) -> z<a. 
Proof. unfold Z.geb.
  remember (z ?= a). destruct c; intros; try discriminate.
  symmetry in Heqc. destruct (Z.compare_lt_iff z a); intros. apply H0 in Heqc. omega.
Qed.
Lemma false_zge' z a (A:z<a): false = (z >=? a). 
Proof.
  remember ((z >=? a)). destruct b; trivial. symmetry in Heqb. apply Z.geb_le in Heqb. omega.
Qed.

Lemma bytesToBits_InBlocks l: InBlocks 8 (bytesToBits l).
Proof.
  apply InBlocks_len; rewrite bytesToBits_len. exists (Datatypes.length l); omega.
Qed.

Lemma flatten_bytes_bits: forall m, 
      flatten m = bitsToBytes (flatten (map bytesToBits m)).
Proof.
  induction m; simpl; trivial; intros.
  rewrite IHm; clear IHm; trivial. 
  rewrite bitsToBytes_app, bytes_bits_bytes_id; trivial.
  apply bytesToBits_InBlocks. 
Qed.

Lemma Forall_rev {A} P: forall (l:list A), Forall P l -> Forall P (rev l).
Proof.
  induction l; intros; simpl; trivial. inv H.
  rewrite hmac_pure_lemmas.Forall_app; auto.
Qed. 

Lemma to_list_eq (A : Type) (n : nat) l: to_list l = @Vector.to_list A n l.
Proof. reflexivity. Qed.

Definition HMAC_Blist (k: Blist)(data: Blist): Blist :=
  bytesToBits (HMAC256 (bitsToBytes data) (bitsToBytes k)).

Definition HMAC_Bvec (k: Bvector.Bvector 256)(data: Blist): Bvector.Bvector 256.
  apply (of_list_length (bytesToBits (HMAC256 (bitsToBytes data) (bitsToBytes (to_list k)) ))).
  rewrite bytesToBits_len, hmac_common_lemmas.HMAC_length. reflexivity.
Defined.

Lemma HMAC_Blist_Bvec v k: HMAC_Blist (to_list k) v = to_list (HMAC_Bvec k v).
Proof. unfold HMAC_Blist, HMAC_Bvec. rewrite HMAC_equivalence.of_length_proof_irrel; trivial. Qed.

Goal forall k' v, bitsToBytes (to_list (HMAC_Bvec k' v)) = HMAC256  (bitsToBytes v) (bitsToBytes (to_list k')).
Proof. unfold HMAC_Bvec; intros.
  rewrite to_list_eq, HMAC_equivalence.of_length_proof_irrel, bytes_bits_bytes_id; trivial.
Qed.

Lemma HMAC_DRBG_generate_helper_Z_equation':
  forall (HMAC : list byte -> list byte -> list byte) (key v : list byte) (requested_number_of_bytes : Z),
  0 < requested_number_of_bytes ->
  HMAC_DRBG_generate_helper_Z HMAC key v requested_number_of_bytes =
    let (v0, rest) := HMAC_DRBG_generate_helper_Z HMAC key v (requested_number_of_bytes - Z.of_nat 32) in
    (HMAC v0 key, rest ++ HMAC v0 key).
Proof. intros. rewrite HMAC_DRBG_generate_helper_Z_equation.
  remember (0 >=? requested_number_of_bytes). destruct b; trivial.
  symmetry in Heqb;  apply Z.geb_le in Heqb. omega.
Qed. 
Lemma HMAC_DRBG_generate_helper_Z_equation0:
  forall (HMAC : list byte -> list byte -> list byte) (key v : list byte),
  HMAC_DRBG_generate_helper_Z HMAC key v 0 = (v, nil).
Proof. intros. rewrite HMAC_DRBG_generate_helper_Z_equation. trivial. Qed.

Lemma Genloop_Zlength_blocks : forall n eta k f v blocks u,
  @Gen_loop eta f k v n = (blocks,u) -> 
  Zlength blocks = Z.of_nat n.
Proof. 
  induction n.
+ simpl; intros. inv H. apply Zlength_nil. 
+ intros. simpl in H. unfold to_list in *. remember (Gen_loop f k (f k (Vector.to_list v)) n).
  destruct p. inversion H; clear H. subst.
  symmetry in Heqp. apply IHn in Heqp. 
  replace (Z.of_nat (S n)) with (1 + Z.of_nat n)%Z. 
  2: symmetry; apply (Nat2Z.inj_add 1 n).
  rewrite <- Heqp. rewrite Zlength_cons. omega. 
Qed. 

Fixpoint Gen_loop_Bvec (k : Bvector 256) (v : Bvector 256) (n : nat)
  : list (Bvector 256) * Bvector 256 :=
  match n with
  | O => (nil, v)
  | S n' =>
    let v' := HMAC_Bvec k (to_list v) in
    let (bits, v'') := Gen_loop_Bvec k v' n' in
    (List.app bits (List.cons v' List.nil), v'')     
  end.

Lemma eqDecState : EqDec (HMAC_DRBG_nonadaptive.KV 256).
Proof. unfold KV, Bvector. specialize (@Vector_EqDec _ bool_EqDec 256); intros.
  apply pair_EqDec; trivial.
Qed.

Lemma GenloopBvec_ZlengthBlocks k: forall n v blocks u,
  Gen_loop_Bvec k v n = (blocks,u) -> Zlength blocks = Z.of_nat n.
Proof. 
  induction n.
+ simpl; intros. inv H. apply Zlength_nil.
+ intros. simpl in H. remember (Gen_loop_Bvec k (HMAC_Bvec k (to_list v)) n).
  destruct p. inv H. 
  symmetry in Heqp. apply IHn in Heqp. 
  replace (Z.of_nat (S n)) with (1+Z.of_nat n)%Z. 
  2: symmetry; apply (Nat2Z.inj_add 1 n).
  rewrite sublist.Zlength_app, Zlength_cons, Zlength_nil, Heqp. omega. 
Qed.

Lemma GenloopBvec_Gen_loop k: forall n v blocks u,
  Gen_loop_Bvec k v n = (blocks,u) ->
  Gen_loop HMAC_Bvec k v n = (rev blocks, u).
Proof. 
  induction n; simpl; intros.
+ inv H; trivial.
+ 
  remember (Gen_loop_Bvec k (HMAC_Bvec k (to_list v)) n) as p.
  destruct p; inv H. 
  symmetry in Heqp. apply IHn in Heqp. rewrite Heqp; clear Heqp IHn.
  rewrite rev_app_distr; trivial.
Qed.

Fixpoint Gen_loop_Blist (k : Blist) (v : Blist) (n : nat)
  : list Blist * Blist :=
  match n with
  | O => (nil, v)
  | S n' =>
    let v' := HMAC_Blist k v in
    let (bits, v'') := Gen_loop_Blist k v' n' in
    (List.app bits (List.cons v' List.nil), v'')     
  end.

Lemma Gen_loop_Blist_Bvec k: forall n v blocks u,
  Gen_loop_Blist (to_list k) (to_list v) n = (blocks, u) ->
  forall blocks' u', Gen_loop_Bvec k v n = (blocks', u') ->
  u = to_list u' /\ blocks = map (@Vector.to_list _ 256) blocks'.
Proof. 
induction n; simpl; intros; subst.
+ inv H; inv H0. split; trivial.
+ remember (Gen_loop_Blist (to_list k) (HMAC_Blist (to_list k) (to_list v)) n) as p; destruct p.
  inv H; symmetry in Heqp.
  remember (Gen_loop_Bvec k (HMAC_Bvec k (to_list v)) n) as q; destruct q.
  inv H0; symmetry in Heqq. rewrite HMAC_Blist_Bvec in Heqp.
  destruct (IHn _ _ _ Heqp _ _ Heqq) as [A B]; subst.
  rewrite HMAC_Blist_Bvec, to_list_eq, list_append_map. split; trivial.
Qed.

Fixpoint Gen_loop_Zlist (k : list byte) (v : list byte) (n : nat)
  : list (list byte) * (list byte) :=
  match n with
  | O => (nil, v)
  | S n' =>
    let v' := HMAC256 v k in
    let (bits, v'') := Gen_loop_Zlist k v' n' in
    (List.app bits (List.cons v' List.nil), v'')     
  end.

Lemma Gen_loop_Zlist_ZlengthBlocks k: forall n v blocks u,
  Gen_loop_Zlist k v n = (blocks,u) -> Zlength blocks = Z.of_nat n.
Proof. induction n; intros.
+ inv H; simpl. apply Zlength_nil.
+ rewrite Nat2Z.inj_succ; simpl in H.
  remember (Gen_loop_Zlist k (HMAC256 v k) n) as p; destruct p; inv H.
  specialize (IHn (HMAC256 v k)). rewrite <- Heqp in IHn; clear Heqp.
  rewrite sublist.Zlength_app, Zlength_cons, (IHn _ _ (eq_refl _)). simpl; omega.
Qed. 

Lemma Gen_loop_Zlist_Blist k:
  forall n v,
  match Gen_loop_Zlist k v n with (blocks,u) =>
        Gen_loop_Blist (bytesToBits k) (bytesToBits v) n
        = (map bytesToBits blocks, bytesToBits u)
  end.
Proof. induction n; intros.
+ simpl; trivial.
+ simpl. remember (Gen_loop_Zlist k (HMAC256 v k) n). 
  destruct p. specialize (IHn (HMAC256 v k)).
  rewrite <- Heqp in IHn; clear Heqp.
  remember (Gen_loop_Blist (bytesToBits k)
     (HMAC_Blist (bytesToBits k) (bytesToBits v)) n) as q.
  destruct q. unfold HMAC_Blist in *.
  rewrite ! bytes_bits_bytes_id in *; trivial.
  rewrite IHn in Heqq; clear IHn. inv Heqq. f_equal.
  rewrite map_app; trivial.
Qed.

Lemma Gen_loop_Zlist_nestedV k: forall n v blocks u blocks' u',
  Gen_loop_Zlist k (HMAC256 v k) n = (blocks, u) ->
  Gen_loop_Zlist k v n = (blocks', u') ->
  u = HMAC256 u' k /\
  blocks = map (fun z => HMAC256 z k) blocks'.
Proof. induction n; simpl; intros.
+ inv H; inv H0. split; trivial.
+ remember (Gen_loop_Zlist k (HMAC256 v k) n) as p.
  remember (Gen_loop_Zlist k (HMAC256 (HMAC256 v k) k) n) as q.
  destruct p; destruct q. inv H. symmetry in Heqp, Heqq.
  specialize (IHn (HMAC256 v k)).
  rewrite Heqq, Heqp in IHn; clear Heqq Heqp. inv H0.
  specialize (IHn _ _ _ _ (eq_refl _) (eq_refl _)). 
  destruct IHn as [? ?]; subst.  rewrite map_app. split; trivial.
Qed.

Lemma Gen_loop_Zlist_nestedV' k: forall n v blocks u,
  Gen_loop_Zlist k (HMAC256 v k) n = (blocks, u) ->
  exists blocks' u',
  Gen_loop_Zlist k v n = (blocks', u') /\
  u = HMAC256 u' k /\
  blocks = map (fun z => HMAC256 z k) blocks'.
Proof. induction n; simpl; intros.
+ inv H. exists nil, v. split; trivial. split; trivial.
+ remember (Gen_loop_Zlist k (HMAC256 v k) n) as p.
  remember (Gen_loop_Zlist k (HMAC256 (HMAC256 v k) k) n) as q.
  destruct p; destruct q. inv H. symmetry in Heqp, Heqq.
  specialize (IHn (HMAC256 v k) _ _ Heqq).
  rewrite Heqp in IHn; clear Heqq Heqp. 
  destruct IHn as [aa [bb [AB [? ?]]]]; subst. 
  inv AB. eexists; eexists; split. reflexivity. rewrite map_app.
  split; trivial. 
Qed.

Definition Equiv n:= forall k v blocks u 
   (G: Gen_loop_Zlist k v n = (blocks, u)) m
   (M: 32*(Z.of_nat n-1) < m <=32*(Z.of_nat n)),
   HMAC_DRBG_generate_helper_Z HMAC256 k v m = (u,flatten (rev blocks)).

Lemma E1: Equiv 1.
Proof. unfold Equiv. simpl; intros. inv G. simpl. rewrite app_nil_r.
 rewrite HMAC_DRBG_generate_helper_Z_equation'; try omega. simpl.
 rewrite HMAC_DRBG_generate_helper_Z_equation.
 assert (0 >=? m - 32 = true). apply Z.geb_le; omega.
 rewrite H; trivial.
Qed.

Lemma E2: Equiv 2.
Proof. unfold Equiv; simpl; intros.
  inv G; simpl.
 rewrite HMAC_DRBG_generate_helper_Z_equation'; try omega. simpl.
 rewrite HMAC_DRBG_generate_helper_Z_equation.
 assert (false = (0 >=? m - 32)) by (apply false_zge'; omega).
 rewrite <- H. simpl.
 rewrite HMAC_DRBG_generate_helper_Z_equation.
 assert ((0 >=? m - 32 - 32)= true) by (apply Z.geb_le; omega).
 rewrite H0. rewrite app_nil_r; trivial. 
Qed. 
Lemma E_aux k: forall n v blocks u,
               Gen_loop_Zlist k (HMAC256 v k) n = (blocks, u) ->
      flatten (rev blocks) ++ HMAC256 u k =
      HMAC256 (HMAC256 v k) k ++ flatten (rev (map (fun z : list byte => HMAC256 z k) blocks)).
Proof. induction n; intros.
+ inv H; simpl. rewrite app_nil_r; trivial.
+ simpl in H.
  remember (Gen_loop_Zlist k (HMAC256 (HMAC256 v k) k) n). 
  destruct p. inv H. specialize (IHn (HMAC256 v k)).
  rewrite <- Heqp in IHn; clear Heqp. 
  specialize (IHn _ _ (eq_refl _)).
  rewrite rev_app_distr in *. rewrite flatten_app, <- app_assoc, IHn; clear IHn.
  simpl. rewrite app_nil_r. f_equal. rewrite map_app, rev_app_distr.
  simpl; trivial.
Qed.

Lemma E: forall n, Equiv (S n).
Proof. induction n.
+ apply E1. 
+ unfold Equiv in *; intros. remember (S n) as N. 
  simpl in G.
  remember (Gen_loop_Zlist k (HMAC256 v k) N) as p.
  destruct p; symmetry in Heqp. inversion G; clear G. subst blocks l0. 
  rewrite HMAC_DRBG_generate_helper_Z_equation'.
  2:{ rewrite Zmult_minus_distr_l in M.
    assert (64 <= 32 * Z.of_nat (S N)).
    { subst. replace 64 with (32*2) by omega. apply Z.mul_le_mono_nonneg_l. omega.
      clear. apply (Nat2Z.inj_le 2). omega. }
    omega.
  }
  simpl.
  apply Gen_loop_Zlist_nestedV' in Heqp. 
  destruct Heqp as [aa [bb [G [X L]]]]. subst u l.
  rewrite (IHn _ _ _ _ G); clear IHn.
  2:{  clear - M. 
           rewrite Zmult_minus_distr_l in *. rewrite Nat2Z.inj_succ in M. simpl in *.
           omega.
  }
  f_equal. rewrite rev_app_distr. 

  subst N; simpl in G. remember (Gen_loop_Zlist k (HMAC256 v k) n).
  destruct p. inv G. rewrite map_app, ! rev_app_distr, ! flatten_app.
  simpl. rewrite ! app_nil_r, <- app_assoc. f_equal.
  symmetry in Heqp. apply (E_aux k n); trivial.
Qed.

Lemma EE n (N:(0<n)%nat): Equiv n.
Proof. destruct n. omega. apply E; trivial. Qed.

Definition GenUpdate_original_core (state : KV 256) (n : nat) :
  (list (Bvector 256) * KV 256) :=
  match state with (k, v) =>
    match Gen_loop HMAC_Bvec k v n with (bits, v') => 
        let k' := HMAC_Bvec k (to_list v' ++ zeroes) in
        let v'' := HMAC_Bvec k' (to_list v') in (bits, (k', v''))
    end
  end.

Definition GenUpdate_original_Bvec (state : KV 256) (n : nat) :
  (list (Bvector 256) * KV 256) :=
  match state with (k, v) =>
    match Gen_loop_Bvec k v n with (bits, v') => 
        let k' := HMAC_Bvec k (to_list v' ++ zeroes) in
        let v'' := HMAC_Bvec k' (to_list v') in (bits, (k', v''))
    end
  end.

Lemma GenUpdate_original_Bvec_correct state n:
  match GenUpdate_original_Bvec state n with (blocks, u) => 
     GenUpdate_original_core state n = (rev blocks, u) end.
Proof. unfold GenUpdate_original_Bvec, GenUpdate_original_core.
  destruct state as [k v].
  remember (Gen_loop_Bvec k v n) as p; destruct p; symmetry in Heqp.
  apply GenloopBvec_Gen_loop in Heqp. rewrite Heqp; trivial.
Qed.

Definition GenUpdate_original_Blist (state : Blist * Blist) (n : nat) :
  (list Blist * (Blist * Blist)) :=
  match state with (k, v) =>
    match Gen_loop_Blist k v n with (bits, v') => 
        let k' := HMAC_Blist k (v' ++ zeroes) in
        let v'' := HMAC_Blist k' v' in (bits, (k', v''))
    end
  end.

Lemma GenUpdate_original_Blist_Bvec k v n:
  match GenUpdate_original_Bvec (k,v) n with (blocks,(kk,u)) =>
    GenUpdate_original_Blist (@Vector.to_list _ 256 k, @Vector.to_list _ 256 v) n =
      (map (@Vector.to_list _ 256) blocks, (@Vector.to_list _ 256 kk, @Vector.to_list _ 256 u))
  end.
Proof. unfold GenUpdate_original_Bvec, GenUpdate_original_Blist.
  remember (Gen_loop_Bvec k v n) as p; symmetry in Heqp. destruct p as [bits v'].
  remember (Gen_loop_Blist (Vector.to_list k) (Vector.to_list v) n) as q; symmetry in Heqq.
  destruct q as [Bits V].
  destruct (Gen_loop_Blist_Bvec k n v Bits V Heqq _ _ Heqp); subst.
  rewrite ! HMAC_Blist_Bvec; trivial.
Qed.

Definition GenUpdate_original_Zlist (state : list byte * list byte) (n : nat) :
  (list (list byte) * (list byte * list byte)) :=
  match state with (k, v) =>
    match Gen_loop_Zlist k v n with (blocks, v') => 
        let k' := HMAC256 (v' ++ [Byte.zero]) k in
        let v'' := HMAC256 v' k' in (blocks, (k', v''))
    end
  end.

Lemma GenUpdate_original_Zlist_ZlengthBlocks state n blocks state':
  GenUpdate_original_Zlist state n = (blocks,state') -> 
  Zlength blocks = Z.of_nat n.
Proof. destruct state; simpl; intros.
  remember (Gen_loop_Zlist l l0 n) as p; destruct p; symmetry in Heqp.
  inv H. apply Gen_loop_Zlist_ZlengthBlocks in Heqp; rewrite Heqp; trivial.
Qed.

Lemma GenUpdate_original_Zlist_Blist k v n:
  match GenUpdate_original_Zlist (k,v) n with (blocks,(k',v')) =>
    GenUpdate_original_Blist (bytesToBits k, bytesToBits v) n =
         (map bytesToBits blocks,(bytesToBits k', bytesToBits v'))
  end.
Proof. unfold GenUpdate_original_Zlist, GenUpdate_original_Blist. 
  remember (Gen_loop_Zlist k v n) as p; symmetry in Heqp. destruct p as [bits v'].
  specialize (Gen_loop_Zlist_Blist k n v). rewrite Heqp; intros Q. simpl in Q. 
  remember (Gen_loop_Blist (bytesToBits k) (bytesToBits v) n) as q; destruct q.
  assert (W: (l, b) =(@map (list byte) ByteBitRelations.Blist bytesToBits bits, bytesToBits v')) by (rewrite <- Q, Heqq; trivial). 
  clear Q Heqq; inv W. f_equal. unfold HMAC_Blist.
  rewrite ! bitsToBytes_app, ! bytes_bits_bytes_id; trivial.
  f_equal. unfold zeroes. simpl.
  apply bytesToBits_InBlocks. 
Qed. 

Definition FunGenerate RI (WS: DRBG_functions.DRBG_working_state) n: DRBG_functions.DRBG_generate_algorithm_result :=
           HMAC256_DRBG_functional_prog.HMAC256_DRBG_generate_algorithm RI
                                           WS
                                           n
                                           nil.
Opaque mult. 

Lemma GenerateCorrect RI k v z n (Z: (z<=RI)%Z) (N:(0<n)%nat):
  match GenUpdate_original_Zlist (k,v) n with (blocks,(k',v')) => 
    FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) = 
    generate_algorithm_success (firstn ((32 * n)%nat) (FCF.Fold.flatten (rev blocks))) (v',k',(z+1)%Z) 
  end.
Proof. remember (GenUpdate_original_Zlist (k, v) n) as p; destruct p as [kk [vv zz]]; symmetry in Heqp. 
  unfold GenUpdate_original_Zlist in Heqp.
  remember (Gen_loop_Zlist k v n) as q; destruct q as [blocks v']; symmetry in Heqq; inv Heqp.
  apply EE in Heqq; trivial. remember (Z.of_nat (32 * n)) as a.  
  simpl. remember (z >? RI) as d. destruct d; symmetry in Heqd. 
  + apply Zgt_is_gt_bool in Heqd; omega.
  + rewrite Z.mul_sub_distr_l in Heqq. 
    rewrite Heqq. subst a; rewrite Nat2Z.id; trivial.
    subst a; clear -N. simpl. rewrite Nat2Z.inj_mul. simpl; omega.
Qed.
Opaque FunGenerate.

Lemma Generate_Blist_ok RI k v z n (Z: (z<=RI)%Z) l kk vv zz 
    (N:(0<n)%nat):
    FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) = generate_algorithm_success l (kk,vv, zz) ->
    exists y,
    GenUpdate_original_Blist (bytesToBits k, bytesToBits v) n = 
    (map bytesToBits y,(bytesToBits vv, bytesToBits kk)) /\ zz=z+1 /\ 
    l = firstn (32 * n) (flatten (rev y)).
Proof.
  remember (GenUpdate_original_Zlist (k,v) n) as g. symmetry in Heqg; destruct g as [a [b c]].
  specialize (GenerateCorrect RI k v z n Z N). rewrite Heqg; intros HH1 HH2.
  rewrite HH1 in HH2. exists a. inv HH2. repeat split; trivial. 
  specialize (GenUpdate_original_Zlist_Blist k v n).
  rewrite Heqg; intros HH; rewrite HH; trivial.
Qed. 

Lemma Generate_Bvec_ok' RI (k: list byte) v z n (Z: (z<=RI)%Z) l kk vv zz (N:(0<n)%nat)
    (KL: Datatypes.length (bytesToBits k) = 256%nat) (VL:Datatypes.length (bytesToBits v) = 256%nat):
    FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) = generate_algorithm_success l (kk,vv, zz) ->
    match GenUpdate_original_Bvec (of_list_length _ KL, of_list_length _ VL) n with (blocks, kv) =>
    zz=z+1 /\ 
    bitsToBytes (@Vector.to_list _ 256 (fst kv)) = vv /\ 
    bitsToBytes (@Vector.to_list _ 256 (snd kv)) = kk /\
          l = firstn (32 * n) (bitsToBytes (flatten (rev (map (@Vector.to_list _ 256) blocks))))
    end.
Proof.
  remember (GenUpdate_original_Zlist (k,v) n) as g. symmetry in Heqg; destruct g as [a [b c]].
  specialize (GenerateCorrect RI k v z n Z N). rewrite Heqg; intros HH1 HH2.
  rewrite HH1 in HH2. inv HH2. 
  specialize (GenUpdate_original_Zlist_Blist k v n).
  rewrite Heqg. intros HH.
  specialize (GenUpdate_original_Blist_Bvec (of_list_length (bytesToBits k) KL)
                (of_list_length (bytesToBits v) VL) n); intros X. 
  remember (GenUpdate_original_Bvec
    (of_list_length (bytesToBits k) KL, of_list_length (bytesToBits v) VL) n) as w.
  destruct w; symmetry in Heqw.
  simpl in X. simpl in Heqw. rewrite Heqw in X; clear Heqw.
  destruct k0 as [w u]. rewrite ! HMAC_equivalence.of_length_proof_irrel in X.
  simpl in HH. rewrite HH in X; clear HH. inv X. split. trivial. simpl.
  rewrite <- H1, <- H2, ! bytes_bits_bytes_id; trivial.
  repeat split; trivial.
  rewrite <- map_rev. f_equal. apply flatten_bytes_bits.
Qed.

Lemma Generate_Bvec_ok RI k v z n (Z: (z<=RI)%Z) (N:(0<n)%nat)
              (KL: Datatypes.length (bytesToBits k) = 256%nat)
              (VL:Datatypes.length (bytesToBits v) = 256%nat):
    match GenUpdate_original_Bvec (of_list_length _ KL, of_list_length _ VL) n with (blocks, (kk,vv)) =>
          FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) 
          = generate_algorithm_success (firstn (32 * n) (bitsToBytes (flatten (rev (map (@Vector.to_list _ 256) blocks)))))
                                       (bitsToBytes (@Vector.to_list _ 256 vv), bitsToBytes (@Vector.to_list _ 256 kk), z+1)
    end.
Proof.
  remember (GenUpdate_original_Zlist (k,v) n) as g. symmetry in Heqg; destruct g as [a [b c]].
  specialize (GenerateCorrect RI k v z n Z N). rewrite Heqg; intros HH; rewrite HH.
  specialize (GenUpdate_original_Zlist_Blist k v n); rewrite Heqg; intros.
  remember ( GenUpdate_original_Bvec
    (of_list_length (bytesToBits k) KL, of_list_length (bytesToBits v) VL) n) as p.
  destruct p as [blocks [kk vv]]; symmetry in Heqp. 
  specialize (GenUpdate_original_Blist_Bvec (of_list_length (bytesToBits k) KL)
                 (of_list_length (bytesToBits v) VL) n).
  simpl. simpl in Heqp. rewrite Heqp; clear Heqp. simpl in H.
  rewrite ! HMAC_equivalence.of_length_proof_irrel. rewrite H; clear H. intros. inv H.
  f_equal.
  - f_equal. rewrite <- map_rev. apply flatten_bytes_bits.
  - rewrite ! bytes_bits_bytes_id; trivial.
Qed.

Lemma Generate_ok' RI k v z n (Z: (z<=RI)%Z) l kk vv zz (N:(0<n)%nat)
    (KL: Datatypes.length (bytesToBits k) = 256%nat) (VL:Datatypes.length (bytesToBits v) = 256%nat):
    FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) = generate_algorithm_success l (kk,vv, zz) ->
    match GenUpdate_original_core (of_list_length _ KL, of_list_length _ VL) n with (blocks, kv) =>
    zz=z+1 /\ 
    bitsToBytes (@Vector.to_list _ 256 (fst kv)) = vv /\ 
    bitsToBytes (@Vector.to_list _ 256 (snd kv)) = kk /\
          l = firstn (32 * n) (bitsToBytes (flatten (map (@Vector.to_list _ 256) blocks)))
    end.
Proof. intros.
  specialize (Generate_Bvec_ok' RI k v z n Z l kk vv zz N KL VL H); clear H; intros.
  remember (GenUpdate_original_Bvec
        (of_list_length (bytesToBits k) KL,
        of_list_length (bytesToBits v) VL) n) as p; symmetry in Heqp; destruct p as [blocks state]. 
  specialize (GenUpdate_original_Bvec_correct
               (of_list_length (bytesToBits k) KL,
                of_list_length (bytesToBits v) VL) n). 
  rewrite Heqp; clear Heqp; intros Q; rewrite Q, map_rev; apply H.
Qed.

Lemma Generate_ok RI k v z n (Z: (z<=RI)%Z) (N:(0<n)%nat)
              (KL: Datatypes.length (bytesToBits k) = 256%nat)
              (VL:Datatypes.length (bytesToBits v) = 256%nat):
    match GenUpdate_original_core (of_list_length _ KL, of_list_length _ VL) n with (blocks, (kk,vv)) =>
          FunGenerate RI (v, k, z) (Z.of_nat ((32 * n)%nat)) 
          = generate_algorithm_success (firstn (32 * n) (bitsToBytes (flatten (map (@Vector.to_list _ 256) blocks))))
                                       (bitsToBytes (@Vector.to_list _ 256 vv), bitsToBytes (@Vector.to_list _ 256 kk), z+1)
    end.
Proof.
  remember (GenUpdate_original_Bvec
        (of_list_length (bytesToBits k) KL,
        of_list_length (bytesToBits v) VL) n) as p; destruct p as [blocks [kk vv]]; symmetry in Heqp.
  
  specialize (GenUpdate_original_Bvec_correct (of_list_length (bytesToBits k) KL,
         of_list_length (bytesToBits v) VL) n). rewrite Heqp. 
  intros Q; rewrite Q; clear Q.
  specialize (Generate_Bvec_ok RI k v z n Z N KL VL). rewrite Heqp; clear Heqp.
  intros W; rewrite W, map_rev; trivial. 
Qed.

Require Import hmacdrbg.entropy.
(* hmacdrbg.entropy:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import VST.floyd.functional_base.

Require Import sha.ByteBitRelations. 

Module Type ABSTRACT_ENTROPY.

Parameter stream: Type.

Inductive error_code: Type :=
| catastrophic_error
| generic_error
.

Inductive result X: Type: Type :=
| success: X -> stream -> @result X
| error : error_code -> stream -> @result X
.

Arguments success {X} _ _.
Arguments error {X} _ _.

Parameter get_bytes: nat -> stream -> result (list byte).
Parameter get_bits: nat -> stream -> result (list bool).

End ABSTRACT_ENTROPY.

Module OPTIONAL_ENTROPY <: ABSTRACT_ENTROPY.

Definition stream: Type := nat -> option bool.

Inductive error_code: Type :=
| catastrophic_error
| generic_error
.

Inductive result X: Type: Type :=
| success: X -> stream -> @result X
| error : error_code -> stream -> @result X
.

Arguments success {X} _ _.
Arguments error {X} _ _.

Fixpoint get_bits (k: nat) (s: stream): result (list bool) :=
  match k with
    | O => success [] s
    | S k' => match get_bits k' s with
                | error e s' => error  e s'
                | success b s' =>
                  match s' O with
                    | None => error catastrophic_error (fun i => match Nat.compare i k' with

Definition get_bytes (k: nat) (s: stream): result (list byte) :=
  match get_bits (8 * k)%nat s with
    | success bits s' => success (bitsToBytes bits) s'
    | error e s' => error e s'
  end
.

End OPTIONAL_ENTROPY.

Module ENTROPY := OPTIONAL_ENTROPY.

Definition get_entropy (security_strength min_length max_length: Z) (prediction_resistance: bool) s :=
           ENTROPY.get_bytes (Z.to_nat min_length) s. *)
Require Import hmacdrbg.HMAC_DRBG_common_lemmas.
(* hmacdrbg.HMAC_DRBG_common_lemmas:
Require Import VST.floyd.proofauto.
Import ListNotations.
Local Open Scope logic.

Require Import hmacdrbg.hmac_drbg.
Require Import hmacdrbg.spec_hmac_drbg.
Require Import sha.general_lemmas.

Lemma Zgt_is_gt_bool_f: forall n m : Z, n <= m <-> (n >? m) = false.

Lemma da_emp_isptrornull sh t v p :
   da_emp sh t v p = (!!is_pointer_or_null p) &&  da_emp sh t v p.

Lemma da_emp_null sh t v p: p=nullval -> da_emp sh t v p = emp.
Lemma da_emp_ptr sh t v b i: da_emp sh t v (Vptr b i) = !! (sizeof t > 0) && data_at sh t v (Vptr b i).

Lemma false_zgt z a: false = (z >? a) -> z<=a. 
Lemma false_zge z a: false = (z >=? a) -> z<=a. 

Lemma Tarray_0_emp sh v c: data_at sh (Tarray tuchar 0 noattr) v c |--  emp.

Lemma Tarray_0_emp' sh c: field_compatible (Tarray tuchar 0 noattr) nil c ->
  emp |-- data_at sh (Tarray tuchar 0 noattr) nil c.

Lemma data_at_weak_valid_ptr: forall (sh : Share.t) (t : type) (v : reptype t) (p : val),

Lemma sublist_app_exact1:
  forall X (A B: list X), sublist 0 (Zlength A) (A ++ B) = A.

Lemma sublist_app_exact2:
  forall X (A B: list X), sublist (Zlength A) (Zlength A + Zlength B) (A ++ B) = B.

Lemma data_at_complete_split:
  forall (A B: list val) lengthA lengthB AB length p offset sh,
    field_compatible (tarray tuchar (Zlength A + Zlength B)) [] p ->
    lengthA = Zlength A ->
    lengthB = Zlength B ->
    length = lengthA + lengthB ->
    offset = lengthA ->
    AB = A ++ B ->
    (data_at sh (tarray tuchar length) (AB) p) = (data_at sh (tarray tuchar lengthA) A p) * (data_at sh (tarray tuchar lengthB) B (offset_val offset p)). *)

Lemma Bridge s I n bytes J ss (M: mbedtls_HMAC256_DRBG_generate_function s I n [] = ENTROPY.success (bytes, J) ss):
  match I with HMAC256DRBGabs K V reseed_counter entropy_len prediction_resistance reseed_interval =>
  reseed_counter <= reseed_interval -> prediction_resistance = false ->
  match J with (ws,sstrength,prflag) =>
  s=ss /\ FunGenerate reseed_interval (V,K,reseed_counter) n = DRBG_functions.generate_algorithm_success bytes ws
  end end.
Proof. destruct I. destruct J as [[ws sstrength] prf].
Transparent FunGenerate. simpl. Opaque FunGenerate. simpl in M.
remember (n >? 1024) as d; destruct d; try discriminate.
rewrite andb_negb_r in M. intros; subst.
apply Zgt_is_gt_bool_f in H. rewrite H.
remember (HMAC_DRBG_algorithms.HMAC_DRBG_generate_helper_Z HMAC256 key V n) as p; destruct p.
unfold HMAC256_DRBG_functional_prog.HMAC256_DRBG_generate_algorithm in M; simpl in M.
rewrite H, <- Heqp in M. inv M; split; trivial.
Qed.

Definition mbedtls_generate s I n :=
   match mbedtls_HMAC256_DRBG_generate_function s I n [] 
   with ENTROPY.success (bytes, J) ss =>
          match J with ((((VV, KK), RC), _), PR) =>
            Some (bytes, ss, HMAC256DRBGabs KK VV RC (hmac256drbgabs_entropy_len I) PR 
                                 (hmac256drbgabs_reseed_interval I))
          end
      | _ => None  
   end.

Lemma Bridge' s I n bytes F ss (M: mbedtls_generate s I n = Some(bytes, ss, F)):
  match I with HMAC256DRBGabs K V reseed_counter entropy_len prediction_resistance reseed_interval =>
  reseed_counter <= reseed_interval -> prediction_resistance = false ->
  match F with HMAC256DRBGabs KK VV rc _ _ _ =>
  s=ss /\ rc=reseed_counter+1 /\
  FunGenerate reseed_interval (V,K,reseed_counter) n = DRBG_functions.generate_algorithm_success bytes ((VV,KK), rc)
  end end.
Proof. destruct I. destruct F. Transparent FunGenerate. simpl. Opaque FunGenerate.
unfold mbedtls_generate in M. simpl in M.
remember (n >? 1024) as d; destruct d; try discriminate.
rewrite andb_negb_r in M. intros; subst.
apply Zgt_is_gt_bool_f in H.  rewrite H.
remember (HMAC_DRBG_algorithms.HMAC_DRBG_generate_helper_Z HMAC256 key V n) as p; destruct p.
unfold HMAC256_DRBG_functional_prog.HMAC256_DRBG_generate_algorithm in M; simpl in M.
rewrite H, <- Heqp in M. inv M; auto. 
Qed.

Lemma Bridge_ok' s I (n:nat) bytes F ss (M: mbedtls_generate s I (32 * Z.of_nat n) = Some(bytes, ss, F)) (N:(0 < n)%nat):
  match I with HMAC256DRBGabs k v reseed_counter entropy_len prediction_resistance reseed_interval =>
  reseed_counter <= reseed_interval -> prediction_resistance = false ->
  forall (KL: Datatypes.length (bytesToBits k) = 256%nat) (VL:Datatypes.length (bytesToBits v) = 256%nat),
  match F with HMAC256DRBGabs KK VV rc _ _ _ =>
  s=ss /\ rc=reseed_counter+1 /\
    match GenUpdate_original_core (Blist.of_list_length _ KL, Blist.of_list_length _ VL) n with (blocks, kv) =>
    bitsToBytes (@Vector.to_list _ 256 (fst kv)) = KK /\ 
    bitsToBytes (@Vector.to_list _ 256 (snd kv)) = VV /\
          bytes = firstn (32 * n) (bitsToBytes (Fold.flatten (map (@Vector.to_list _ 256) blocks)))
    end
  end end.
Proof.
 specialize (Bridge' _ _ _ _ _ _ M); destruct I; intros.
 specialize (H H0 H1). destruct F. destruct H as [HH1 [HH2 HH3]].
 split; trivial. split; trivial.
 specialize (Generate_ok' reseed_interval key V reseed_counter n H0 bytes V0 key0 reseed_counter0).
 rewrite Nat2Z.inj_mul. simpl. rewrite HH3.
 clear HH3 M.
 intros ZZ. specialize (ZZ N KL VL (eq_refl _)).
 remember (HMAC_DRBG_nonadaptive.Gen_loop HMAC_Bvec
           (Blist.of_list_length (bytesToBits key) KL)
           (Blist.of_list_length (bytesToBits V) VL) n) as q.
 destruct q. destruct ZZ as [_ ZZ].   apply ZZ.
Qed.

Lemma GenUpdate_original_core_length: forall n state l m
  (G: GenUpdate_original_core state n = (l,m)),
   Datatypes.length l = n%nat.
Proof. induction n; destruct state; simpl; intros. 
+ inv G. simpl; omega.
+ remember (HMAC_DRBG_nonadaptive.Gen_loop HMAC_Bvec b
           (HMAC_Bvec b (HMAC_DRBG_nonadaptive.to_list b0)) n) as q.
  destruct q.  inv G. simpl. symmetry in Heqq. apply Genloop_Zlength_blocks in Heqq. 
  rewrite (Zlength_correct l0) in Heqq. apply Nat2Z.inj in Heqq. subst; trivial.
Qed.

Lemma fold_vector_length: forall l m,
fold_left
  (fun (acc : nat) (a : Vector.t bool 256) =>
   (acc + Datatypes.length (Vector.to_list a))%nat) l m =
  (m + Datatypes.length l * 256)%nat.
Proof. induction l; simpl; intros. + omega.
+ rewrite IHl, Blist.to_list_length; clear IHl. omega.
Qed. 

Lemma mbedtls_generate_Bridge s I (n:nat) bytes F ss (M: mbedtls_generate s I (32 * Z.of_nat n) = Some(bytes, ss, F)) (N:(0 < n)%nat):
  match I with HMAC256DRBGabs k v reseed_counter entropy_len prediction_resistance reseed_interval =>
  reseed_counter <= reseed_interval -> prediction_resistance = false ->
  forall (KL: Datatypes.length (bytesToBits k) = 256%nat) (VL:Datatypes.length (bytesToBits v) = 256%nat),
  match F with HMAC256DRBGabs KK VV rc _ _ _ =>
  s=ss /\ rc=reseed_counter+1 /\
    match GenUpdate_original_core (Blist.of_list_length _ KL, Blist.of_list_length _ VL) n with (blocks, kv) =>
    bitsToBytes (@Vector.to_list _ 256 (fst kv)) = KK /\ 
    bitsToBytes (@Vector.to_list _ 256 (snd kv)) = VV /\
          bytes = (bitsToBytes (Fold.flatten (map (@Vector.to_list _ 256) blocks)))
    end
  end end.
Proof.
 specialize (Bridge_ok' _ _ _ _ _ _ M N); destruct I; intros.
 specialize (H H0 H1 KL VL). destruct F. destruct H as [HH1 [HH2 HH3]].
 split; trivial. split; trivial.
 remember (GenUpdate_original_core
          (Blist.of_list_length (bytesToBits key) KL,
          Blist.of_list_length (bytesToBits V) VL) n) as q. destruct q.
 rewrite sublist.firstn_same in HH3. trivial.
 symmetry in Heqq. apply GenUpdate_original_core_length in Heqq.
 assert (Datatypes.length (bitsToBytes (Fold.flatten (map Vector.to_list l))) = (32*n)%nat).
 apply bitsToBytes_len_gen. rewrite CompFold.length_flatten. simpl. rewrite CompFold.fold_left_map_eq.
 subst n. rewrite fold_vector_length. simpl. rewrite (mult_comm 32). rewrite <- mult_assoc.
 replace (32*8)%nat with 256%nat. trivial. omega.
 rewrite H. omega.
Qed.  

Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Definition AsGame {A} f (a:A) : Comp (list (Bvector 256) * KV 256) := ret(f a).
Definition Generate_refactored state := AsGame (GenUpdate_original_core state). 

Lemma Refactored kv n: 
     comp_spec (fun x y => x=y)
               (@Generate _ HMAC_Bvec eqDecState kv n)
                (ret (GenUpdate_original_core kv n)).
Proof.
  unfold AsGame, Generate, GenUpdate_original_core.
  destruct kv as [k v]. prog_simp. apply comp_spec_ret; trivial. 
Qed.

Lemma OK256: (256 <> 0)%nat. Proof. omega. Qed.

Definition Instantiated_G1_G2_close := G1_G2_close OK256 HMAC_Bvec eqDecState.

