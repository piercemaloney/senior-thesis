

Require Export VST.veric.Cop2.

Require Import VST.veric.Clight_base.
(* VST.veric.Clight_base:
Require Export compcert.exportclight.Clightdefs.

Require Export VST.veric.base.
Require Export compcert.cfrontend.Ctypes.
Require Export compcert.cfrontend.Cop. 
Require Export compcert.cfrontend.Clight. 

Require Export EqNat.  

Require Export VST.veric.Memory. *)

Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)



Definition sem_cast_pointer (v : val) : option val := Some v.



Definition sem_cast_i2i sz2 si2 (v : val) : option val :=

match v with

      | Vint i => Some (Vint (Cop.cast_int_int sz2 si2 i))

      | _ => None

      end.



Definition sem_cast_i2bool (v: val) : option val := 

      match v with

      | Vint n =>

          Some(Vint(if Int.eq n Int.zero then Int.zero else Int.one))

      | Vptr b ofs =>

          if Archi.ptr64 then None else Some Vone

      | _ => None

      end.



Definition sem_cast_l2bool (v: val) : option val :=

      match v with

      | Vlong n =>

          Some(Vint(if Int64.eq n Int64.zero then Int.zero else Int.one))

      | Vptr b ofs =>

          if negb Archi.ptr64 then None else Some Vone

      | _ => None

      end.



Definition sem_cast_l2l (v : val) : option val :=

 match v with

      | Vlong n => Some (Vlong n)

      | _ => None

      end.



Definition sem_cast_i2l si (v : val) : option val :=

 match v with

      | Vint n => Some(Vlong (Cop.cast_int_long si n))

      | _ => None

      end.



Definition sem_cast_l2i sz si (v : val) : option val :=

match v with

      | Vlong n => Some(Vint (Cop.cast_int_int sz si (Int.repr (Int64.unsigned n))))

      | _ => None

      end.



Definition sem_cast_struct id1 id2 (v : val) : option val :=

match v with

      | Vptr b ofs =>

          if ident_eq id1 id2 then Some v else None

      | _ => None

      end.



Definition sem_cast_union id1 id2 (v : val) : option val :=

match v with

      | Vptr b ofs =>

          if ident_eq id1 id2 then Some v else None

      | _ => None

      end.



Definition sem_cast_f2f (v: val) : option val :=

      match v with

      | Vfloat f => Some (Vfloat f)

      | _ => None

      end.



Definition sem_cast_s2s (v: val) : option val :=

      match v with

      | Vsingle f => Some (Vsingle f)

      | _ => None

      end.



Definition sem_cast_s2f (v: val) : option val :=

      match v with

      | Vsingle f => Some (Vfloat (Float.of_single f))

      | _ => None

      end.



 Definition sem_cast_f2s (v: val) : option val :=

      match v with

      | Vfloat f => Some (Vsingle (Float.to_single f))

      | _ => None

      end.



 Definition sem_cast_i2f si1 (v: val) : option val :=

      match v with

      | Vint i => Some (Vfloat (Cop.cast_int_float si1 i))

      | _ => None

      end.



 Definition sem_cast_i2s si1 (v: val) : option val :=

      match v with

      | Vint i => Some (Vsingle (Cop.cast_int_single si1 i))

      | _ => None

      end.



 Definition sem_cast_f2i sz2 si2 (v: val) : option val :=

      match v with

      | Vfloat f =>

          match Cop.cast_float_int si2 f with

          | Some i => Some (Vint (Cop.cast_int_int sz2 si2 i))

          | None => None

          end

      | _ => None

      end.



Definition sem_cast_s2i sz2 si2 (v: val) : option val :=

      match v with

      | Vsingle f =>

          match Cop.cast_single_int si2 f with

          | Some i => Some (Vint (Cop.cast_int_int sz2 si2 i))

          | None => None

          end

      | _ => None

      end.



Definition sem_cast_f2bool (v: val) : option val :=

      match v with

      | Vfloat f =>

          Some(Vint(if Float.cmp Ceq f Float.zero then Int.zero else Int.one))

      | _ => None

      end.



Definition sem_cast_s2bool (v: val) : option val :=

      match v with

      | Vsingle f =>

          Some(Vint(if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))

      | _ => None

      end.



 Definition sem_cast_l2f si1 (v: val) : option val :=

      match v with

      | Vlong i => Some (Vfloat (Cop.cast_long_float si1 i))

      | _ => None

      end.



 Definition sem_cast_l2s si1 (v: val) : option val :=

      match v with

      | Vlong i => Some (Vsingle (Cop.cast_long_single si1 i))

      | _ => None

      end.



 Definition sem_cast_f2l si2 (v: val) : option val :=

      match v with

      | Vfloat f =>

          match Cop.cast_float_long si2 f with

          | Some i => Some (Vlong i)

          | None => None

          end

      | _ => None

      end.



Definition sem_cast_s2l si2 (v: val) : option val :=

      match v with

      | Vsingle f =>

          match Cop.cast_single_long si2 f with

          | Some i => Some (Vlong i)

          | None => None

          end

      | _ => None

      end.



Definition classify_cast (tfrom tto: type) : classify_cast_cases :=

  match tto, tfrom with

  

  | Tvoid, _ => cast_case_void

  

  | Tint IBool _ _, Tint _ _ _ => cast_case_i2bool

  | Tint IBool _ _, Tlong _ _ => cast_case_l2bool

  | Tint IBool _ _, Tfloat F64 _ => cast_case_f2bool

  | Tint IBool _ _, Tfloat F32 _ => cast_case_s2bool

  | Tint IBool _ _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) => 

      if eqb_type tfrom int_or_ptr_type

      then cast_case_default

      else if Archi.ptr64 then cast_case_l2bool else cast_case_i2bool

  

  | Tint sz2 si2 _, Tint _ _ _ =>

      if Archi.ptr64 then cast_case_i2i sz2 si2

      else if intsize_eq sz2 I32 then cast_case_pointer

      else cast_case_i2i sz2 si2

  | Tint sz2 si2 _, Tlong _ _ => cast_case_l2i sz2 si2

  | Tint sz2 si2 _, Tfloat F64 _ => cast_case_f2i sz2 si2

  | Tint sz2 si2 _, Tfloat F32 _ => cast_case_s2i sz2 si2

  | Tint sz2 si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>

      if Archi.ptr64 then cast_case_l2i sz2 si2

      else if intsize_eq sz2 I32 then cast_case_pointer

      else cast_case_i2i sz2 si2

  

  | Tlong _ _, Tlong _ _ =>

      if Archi.ptr64 then cast_case_pointer else cast_case_l2l

  | Tlong _ _, Tint sz1 si1 _ => cast_case_i2l si1

  | Tlong si2 _, Tfloat F64 _ => cast_case_f2l si2

  | Tlong si2 _, Tfloat F32 _ => cast_case_s2l si2

  | Tlong si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>

      if Archi.ptr64 

      then cast_case_pointer 

      else cast_case_i2l si2

  

  | Tfloat F64 _, Tint sz1 si1 _ => cast_case_i2f si1

  | Tfloat F32 _, Tint sz1 si1 _ => cast_case_i2s si1

  | Tfloat F64 _, Tlong si1 _ => cast_case_l2f si1

  | Tfloat F32 _, Tlong si1 _ => cast_case_l2s si1

  | Tfloat F64 _, Tfloat F64 _ => cast_case_f2f

  | Tfloat F32 _, Tfloat F32 _ => cast_case_s2s

  | Tfloat F64 _, Tfloat F32 _ => cast_case_s2f

  | Tfloat F32 _, Tfloat F64 _ => cast_case_f2s

  

  | Tpointer _ _, Tint _ _ _ =>

      if eqb_type tto int_or_ptr_type 

      then if Archi.ptr64

           then cast_case_default

           else cast_case_pointer

      else if Archi.ptr64

           then cast_case_i2l Unsigned 

           else cast_case_pointer

  | Tpointer _ _, Tlong _ _ =>

      if eqb_type tto int_or_ptr_type 

      then if Archi.ptr64

           then cast_case_pointer

           else cast_case_default

      else if Archi.ptr64

           then cast_case_pointer

           else cast_case_l2i I32 Unsigned

  | Tpointer _ _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) => 

       cast_case_pointer

  

  | Tstruct id2 _, Tstruct id1 _ => cast_case_struct id1 id2

  | Tunion id2 _, Tunion id1 _ => cast_case_union id1 id2

  

  | _, _ => cast_case_default

  end.



Arguments classify_cast tfrom tto / .



Definition sem_cast (t1 t2: type): val -> option val := 

  match classify_cast t1 t2 with

  | cast_case_pointer => sem_cast_pointer

  | Cop.cast_case_i2i sz2 si2 => sem_cast_i2i sz2 si2

  | Cop.cast_case_f2f => sem_cast_f2f

  | Cop.cast_case_s2s => sem_cast_s2s

  | Cop.cast_case_s2f => sem_cast_s2f

  | Cop.cast_case_f2s => sem_cast_f2s

  | Cop.cast_case_i2f si1 => sem_cast_i2f si1

  | Cop.cast_case_i2s si1 => sem_cast_i2s si1

  | Cop.cast_case_f2i sz2 si2 => sem_cast_f2i sz2 si2

  | Cop.cast_case_s2i sz2 si2 => sem_cast_s2i sz2 si2

  | Cop.cast_case_i2bool => sem_cast_i2bool

  | Cop.cast_case_l2bool => sem_cast_l2bool

  | Cop.cast_case_f2bool => sem_cast_f2bool

  | Cop.cast_case_s2bool => sem_cast_s2bool

  | Cop.cast_case_l2l => sem_cast_l2l

  | Cop.cast_case_i2l si => sem_cast_i2l si

  | Cop.cast_case_l2i sz si => sem_cast_l2i sz si

  | Cop.cast_case_l2f si1 => sem_cast_l2f si1

  | Cop.cast_case_l2s si1 => sem_cast_l2s si1

  | Cop.cast_case_f2l si2 => sem_cast_f2l si2

  | Cop.cast_case_s2l si2 => sem_cast_s2l si2

  | Cop.cast_case_struct id1 id2 => sem_cast_struct id1 id2

  | Cop.cast_case_union id1 id2 => sem_cast_union id1 id2

  | Cop.cast_case_void =>

      fun v => Some v

  | Cop.cast_case_default =>

      fun v => None

 end.



Definition sem_notbool (t: type) (v: val) : option val :=

  option_map (fun b => Val.of_bool (negb b)) (Cop2.bool_val t v).



Definition sem_neg_i (v: val) : option val :=

      match v with

      | Vint n => Some (Vint (Int.neg n))

      | _ => None

      end.



Definition sem_neg_f (v: val) : option val :=

       match v with

      | Vfloat f => Some (Vfloat (Float.neg f))

      | _ => None

      end.



Definition sem_neg_s (v: val) : option val :=

       match v with

      | Vsingle f => Some (Vsingle (Float32.neg f))

      | _ => None

      end.



Definition sem_neg_l (v: val) : option val :=

      match v with

      | Vlong n => Some (Vlong (Int64.neg n))

      | _ => None

      end.



Definition sem_neg (t: type) : val -> option val :=

  match Cop.classify_neg t with

  | Cop.neg_case_i sg => sem_neg_i

  | Cop.neg_case_f => sem_neg_f

  | Cop.neg_case_s => sem_neg_s

  | Cop.neg_case_l sg => sem_neg_l

  | neg_default => fun v => None

  end.



Definition sem_absfloat_i sg (v: val) : option val :=

  match v with

      | Vint n => Some (Vfloat (Float.abs (Cop.cast_int_float sg n)))

      | _ => None

      end.



Definition sem_absfloat_f (v: val) :=

     match v with

      | Vfloat f => Some (Vfloat (Float.abs f))

      | _ => None

      end.



Definition sem_absfloat_s (v: val) :=

      match v with

      | Vsingle f => Some (Vfloat (Float.abs (Float.of_single f)))

      | _ => None

      end.



Definition sem_absfloat_l sg v :=

      match v with

      | Vlong n => Some (Vfloat (Float.abs (Cop.cast_long_float sg n)))

      | _ => None

      end.



Definition sem_absfloat (ty: type)  : val -> option val :=

  match Cop.classify_neg ty with

  | Cop.neg_case_i sg => sem_absfloat_i sg

  | Cop.neg_case_f => sem_absfloat_f

  | Cop.neg_case_s => sem_absfloat_s

   | Cop.neg_case_l sg => sem_absfloat_l sg

  | neg_default => fun v => None

  end.



Definition sem_notint_i (v:val) : option val :=

      match v with

      | Vint n => Some (Vint (Int.not n))

      | _ => None

      end.



Definition sem_notint_l (v:val) : option val :=

      match v with

      | Vlong n => Some (Vlong (Int64.not n))

      | _ => None

      end.



Definition sem_notint (t: type)  : val -> option val :=

  match Cop.classify_notint t with

  | Cop.notint_case_i sg => sem_notint_i

  | Cop.notint_case_l sg => sem_notint_l

  | notint_default => fun v => None

  end.



Definition both_int (f: int -> int -> option val) (cast1 cast2: val -> option val) (v1 v2: val) :=

 match cast1 v1, cast2 v2 with Some (Vint v1'), Some (Vint v2') => f v1' v2' | _, _ => None end.



Definition both_long (f: int64 -> int64 -> option val) (cast1 cast2: val -> option val) (v1 v2: val) :=

 match cast1 v1, cast2 v2 with Some (Vlong v1'), Some (Vlong v2') => f v1' v2' | _, _ => None end.



Definition both_float (f: float -> float -> option val) (cast1 cast2: val -> option val) (v1 v2: val) :=

 match cast1 v1, cast2 v2 with Some (Vfloat v1'), Some (Vfloat v2') => f v1' v2' | _, _ => None end.



Definition both_single (f: float32 -> float32 -> option val) (cast1 cast2: val -> option val) (v1 v2: val) :=

 match cast1 v1, cast2 v2 with Some (Vsingle v1'), Some (Vsingle v2') => f v1' v2' | _, _ => None end.



Definition sem_binarith

    (sem_int: signedness -> int -> int -> option val)

    (sem_long: signedness -> int64 -> int64 -> option val)

    (sem_float: float -> float -> option val)

    (sem_single: float32 -> float32 -> option val)

    (t1: type) (t2: type)

   : forall (v1: val) (v2: val), option val := 

  let c := Cop.classify_binarith t1 t2 in

  let t := Cop.binarith_type c in

  match c with

  | Cop.bin_case_i sg => both_int (sem_int sg) (sem_cast t1 t) (sem_cast t2 t)

  | Cop.bin_case_f => both_float (sem_float) (sem_cast t1 t) (sem_cast t2 t)

  | Cop.bin_case_s => both_single (sem_single) (sem_cast t1 t) (sem_cast t2 t)

  | Cop.bin_case_l sg => both_long (sem_long sg) (sem_cast t1 t) (sem_cast t2 t)

  | bin_default => fun _ _ => None

  end.



Definition sem_add_ptr_int {CS: compspecs} ty si v1 v2 :=

 Cop.sem_add_ptr_int cenv_cs ty si v1 v2.



Definition sem_add_int_ptr {CS: compspecs} ty si v1 v2 :=

 Cop.sem_add_ptr_int cenv_cs ty si v2 v1.



Definition sem_add_ptr_long {CS: compspecs} ty v1 v2 :=

 Cop.sem_add_ptr_long cenv_cs ty v1 v2.



Definition sem_add_long_ptr {CS: compspecs} ty v1 v2 :=

 Cop.sem_add_ptr_long cenv_cs ty v2 v1.



Definition sem_add {CS: compspecs} (t1:type) (t2:type):  val->val->option val :=

  match classify_add t1 t2 with

  | add_case_pi ty si =>             

      sem_add_ptr_int ty si

  | add_case_pl ty =>                

      sem_add_ptr_long ty

  | add_case_ip si ty =>             

      sem_add_int_ptr ty si

  | add_case_lp ty =>                

      sem_add_long_ptr ty

  | add_default =>

      sem_binarith

        (fun sg n1 n2 => Some(Vint(Int.add n1 n2)))

        (fun sg n1 n2 => Some(Vlong(Int64.add n1 n2)))

        (fun n1 n2 => Some(Vfloat(Float.add n1 n2)))

        (fun n1 n2 => Some(Vsingle(Float32.add n1 n2)))

        t1 t2

  end.



Definition sem_sub_pi {CS: compspecs} (ty:type) (si: signedness) (v1 v2 : val) : option val :=

      match v1, v2 with

      | Vptr b1 ofs1, Vint n2 =>

          let n2 := ptrofs_of_int si n2 in

          Some (Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.mul (Ptrofs.repr (sizeof ty)) n2)))

      | Vint n1, Vint n2 =>

          if Archi.ptr64 then None else Some (Vint (Int.sub n1 (Int.mul (Int.repr (sizeof ty)) n2)))

      | Vlong n1, Vint n2 =>

          let n2 := cast_int_long si n2 in

          if Archi.ptr64 then Some (Vlong (Int64.sub n1 (Int64.mul (Int64.repr (sizeof ty)) n2))) else None

      | _,  _ => None

      end.



Definition sem_sub_pl {CS: compspecs} (ty:type) (v1 v2 : val) : option val := 

      match v1, v2 with

      | Vptr b1 ofs1, Vlong n2 =>

          let n2 := Ptrofs.of_int64 n2 in

          Some (Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.mul (Ptrofs.repr (sizeof ty)) n2)))

      | Vint n1, Vlong n2 =>

          let n2 := Int.repr (Int64.unsigned n2) in

          if Archi.ptr64 then None else Some (Vint (Int.sub n1 (Int.mul (Int.repr (sizeof ty)) n2)))

      | Vlong n1, Vlong n2 =>

          if Archi.ptr64 then Some (Vlong (Int64.sub n1 (Int64.mul (Int64.repr (sizeof ty)) n2))) else None

      | _,  _ => None

      end.



Definition sem_sub_pp {CS: compspecs} (ty:type) (v1 v2 : val) : option val :=

      match v1,v2 with

      | Vptr b1 ofs1, Vptr b2 ofs2 =>

          if eq_block b1 b2 then

            let sz := sizeof ty in

            if zlt 0 sz && zle sz Ptrofs.max_signed

            then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub ofs1 ofs2) (Ptrofs.repr sz)))

            else None

          else None

      | _, _ => None

      end.



Definition sem_sub_default (t1 t2:type) (v1 v2 : val) : option val :=

 sem_binarith

        (fun sg n1 n2 => Some(Vint(Int.sub n1 n2)))

        (fun sg n1 n2 => Some(Vlong(Int64.sub n1 n2)))

        (fun n1 n2 => Some(Vfloat(Float.sub n1 n2)))

        (fun n1 n2 => Some(Vsingle(Float32.sub n1 n2)))

        t1 t2 v1 v2.



Definition sem_sub {CS: compspecs} (t1:type) (t2:type) : val -> val -> option val :=

  match Cop.classify_sub t1 t2 with

  | Cop.sub_case_pi ty si=> sem_sub_pi  ty si  

  | Cop.sub_case_pl ty => sem_sub_pl  ty  

  | Cop.sub_case_pp ty => sem_sub_pp ty       

  | sub_default => sem_sub_default t1 t2

  end.



Definition sem_mul (t1:type) (t2:type) (v1:val)  (v2: val)  : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint(Int.mul n1 n2)))

    (fun sg n1 n2 => Some(Vlong(Int64.mul n1 n2)))

    (fun n1 n2 => Some(Vfloat(Float.mul n1 n2)))

    (fun n1 n2 => Some(Vsingle(Float32.mul n1 n2)))

    t1 t2 v1 v2.



Definition sem_div (t1:type) (t2:type) (v1:val)  (v2: val) : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint (match sg with | Signed => Int.divs | Unsigned => Int.divu end n1 n2)))

    (fun sg n1 n2 => Some(Vlong (match sg with | Signed => Int64.divs | Unsigned => Int64.divu end n1 n2)))

    (fun n1 n2 => Some(Vfloat(Float.div n1 n2)))

    (fun n1 n2 => Some(Vsingle(Float32.div n1 n2)))

    t1 t2 v1 v2.



Definition sem_mod (t1:type) (t2:type) (v1:val)  (v2: val) : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint (match sg with | Signed => Int.mods | Unsigned => Int.modu end n1 n2)))

    (fun sg n1 n2 => Some(Vlong (match sg with | Signed => Int64.mods | Unsigned => Int64.modu end n1 n2)))

    (fun n1 n2 => None)

    (fun n1 n2 => None)

    t1 t2 v1 v2.



Definition sem_and (t1:type) (t2:type) (v1:val) (v2: val) : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint(Int.and n1 n2)))

    (fun sg n1 n2 => Some(Vlong(Int64.and n1 n2)))

    (fun n1 n2 => None)

    (fun n1 n2 => None)

    t1 t2 v1 v2.



Definition sem_or (t1:type) (t2:type) (v1:val)  (v2: val) : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint(Int.or n1 n2)))

    (fun sg n1 n2 => Some(Vlong(Int64.or n1 n2)))

    (fun n1 n2 => None)

    (fun n1 n2 => None)

    t1 t2 v1 v2.



Definition sem_xor (t1:type) (t2:type) (v1:val)  (v2: val) : option val :=

  sem_binarith

    (fun sg n1 n2 => Some(Vint(Int.xor n1 n2)))

    (fun sg n1 n2 => Some(Vlong(Int64.xor n1 n2)))

    (fun n1 n2 => None)

    (fun n1 n2 => None)

    t1 t2 v1 v2.



Definition sem_shift_ii sem_int (sg:signedness) v1 v2 : option val :=

      match v1, v2 with

      | Vint n1, Vint n2 =>

          
 Some(Vint(sem_int sg n1 n2)) 

      | _, _ => None

      end.



Definition sem_shift_il sem_int (sg:signedness) v1 v2 : option val :=

match v1, v2 with

      | Vint n1, Vlong n2 =>

          
 Some(Vint(sem_int sg n1 (Int64.loword n2))) 

      | _, _ => None

      end.



Definition sem_shift_li sem_long (sg:signedness) v1 v2 : option val :=

match v1, v2 with

      | Vlong n1, Vint n2 =>

          
 Some(Vlong(sem_long sg n1 (Int64.repr (Int.unsigned n2)))) 

      | _, _ => None

      end.



Definition sem_shift_ll sem_long (sg:signedness) v1 v2 : option val :=

 match v1, v2 with

      | Vlong n1, Vlong n2 =>

          
 Some(Vlong(sem_long sg n1 n2)) 

      | _, _ => None

      end.



Definition sem_shift

    (t1: type) (t2: type) (sem_int: signedness -> int -> int -> int)

    (sem_long: signedness -> int64 -> int64 -> int64) : val -> val -> option val :=

  match Cop.classify_shift t1 t2 with

  | Cop.shift_case_ii sg => sem_shift_ii sem_int sg

  | Cop.shift_case_il sg => sem_shift_il sem_int sg

  | Cop.shift_case_li sg => sem_shift_li sem_long sg

  | Cop.shift_case_ll sg => sem_shift_ll sem_long sg

  | shift_default => fun v1 v2 => None

  end.



Definition sem_shl (t1:type) (t2:type) (v1:val) (v2: val)  : option val :=

  sem_shift  t1 t2

    (fun sg n1 n2 => Int.shl n1 n2)

    (fun sg n1 n2 => Int64.shl n1 n2)

    v1 v2.



Definition sem_shr (t1:type) (t2:type) (v1:val) (v2: val)  : option val :=

  sem_shift  t1 t2

    (fun sg n1 n2 => match sg with Signed => Int.shr n1 n2 | Unsigned => Int.shru n1 n2 end)

    (fun sg n1 n2 => match sg with Signed => Int64.shr n1 n2 | Unsigned => Int64.shru n1 n2 end)

    v1 v2.



Definition true2 (b : block) (i : Z) := true.



Definition sem_cmp_pp c v1 v2 :=

  option_map Val.of_bool

   (if Archi.ptr64

    then Val.cmplu_bool true2 c v1 v2

    else Val.cmpu_bool true2 c v1 v2).



Definition sem_cmp_pi si c v1 v2 :=

      match v2 with

      | Vint n2 => sem_cmp_pp c v1 (Vptrofs (ptrofs_of_int si n2))

      | Vptr _ _ => if Archi.ptr64 then None else sem_cmp_pp c v1 v2

      | _ => None

      end.



Definition sem_cmp_ip si c v1 v2 :=

      match v1 with

      | Vint n1 => sem_cmp_pp c (Vptrofs (ptrofs_of_int si n1)) v2

      | Vptr _ _ => if Archi.ptr64 then None else sem_cmp_pp c v1 v2

      | _ => None

      end.



Definition sem_cmp_pl c v1 v2 :=

      match v2 with

      | Vlong n2 => sem_cmp_pp c v1 (Vptrofs (Ptrofs.of_int64 n2))

      | Vptr _ _ => if Archi.ptr64 then sem_cmp_pp c v1 v2 else None

      | _ => None

      end.



Definition sem_cmp_lp c v1 v2 := 

      match v1 with

      | Vlong n1 => sem_cmp_pp c (Vptrofs (Ptrofs.of_int64 n1)) v2

      | Vptr _ _ => if Archi.ptr64 then sem_cmp_pp c v1 v2 else None

      | _ => None

      end.



Definition sem_cmp_default c t1 t2 :=

 sem_binarith

        (fun sg n1 n2 =>

            Some(Val.of_bool(match sg with Signed => Int.cmp c n1 n2 | Unsigned => Int.cmpu c n1 n2 end)))

        (fun sg n1 n2 =>

            Some(Val.of_bool(match sg with Signed => Int64.cmp c n1 n2 | Unsigned => Int64.cmpu c n1 n2 end)))

        (fun n1 n2 =>

            Some(Val.of_bool(Float.cmp c n1 n2)))

        (fun n1 n2 =>

            Some(Val.of_bool(Float32.cmp c n1 n2)))

        t1 t2 .



Definition sem_cmp (c:comparison) (t1: type) (t2: type) : val -> val ->  option val :=

  match Cop.classify_cmp t1 t2 with

  | Cop.cmp_case_pp => 

     if orb (eqb_type t1 int_or_ptr_type) (eqb_type t2 int_or_ptr_type) 

            then (fun _ _ => None)

     else sem_cmp_pp c

  | Cop.cmp_case_pi si => 

     if eqb_type t1 int_or_ptr_type

            then (fun _ _ => None)

     else sem_cmp_pi si c

  | Cop.cmp_case_ip si => 

     if eqb_type t2 int_or_ptr_type

            then (fun _ _ => None)

     else sem_cmp_ip si c

  | Cop.cmp_case_pl => 

     if eqb_type t1 int_or_ptr_type

            then (fun _ _ => None)

     else sem_cmp_pl c

  | Cop.cmp_case_lp => 

     if eqb_type t2 int_or_ptr_type

            then (fun _ _ => None)

     else sem_cmp_lp c

  | Cop.cmp_default => sem_cmp_default c t1 t2

  end.



Definition sem_unary_operation

            (op: Cop.unary_operation) (ty: type) (v: val): option val :=

  match op with

  | Cop.Onotbool => sem_notbool ty v

  | Cop.Onotint => sem_notint ty v

  | Cop.Oneg => sem_neg ty v

  | Cop.Oabsfloat => sem_absfloat ty v

  end.



Definition sem_binary_operation'

    {CS: compspecs} (op: Cop.binary_operation)

    (t1:type) (t2: type) : val -> val -> option val :=

  match op with

  | Cop.Oadd => sem_add t1 t2

  | Cop.Osub => sem_sub t1 t2

  | Cop.Omul => sem_mul t1 t2

  | Cop.Omod => sem_mod t1 t2

  | Cop.Odiv => sem_div t1 t2

  | Cop.Oand => sem_and t1 t2

  | Cop.Oor  => sem_or t1 t2

  | Cop.Oxor  => sem_xor t1 t2

  | Cop.Oshl => sem_shl t1 t2

  | Cop.Oshr  => sem_shr t1 t2

  | Cop.Oeq => sem_cmp Ceq t1 t2

  | Cop.One => sem_cmp Cne t1 t2

  | Cop.Olt => sem_cmp Clt t1 t2

  | Cop.Ogt => sem_cmp Cgt t1 t2

  | Cop.Ole => sem_cmp Cle t1 t2

  | Cop.Oge => sem_cmp Cge t1 t2

  end.



Definition sem_incrdecr {CS: compspecs} (id: Cop.incr_or_decr) (ty: type)  (valid_pointer : block -> Z -> bool)  (v: val)  :=

  match id with

  | Cop.Incr => sem_add ty type_int32s v (Vint Int.one)

  | Decr => sem_sub ty type_int32s v (Vint Int.one)

  end.



Arguments Cop.classify_cast tfrom tto / .

Arguments Cop.classify_bool ty / .

Arguments Cop.classify_neg ty / .

Arguments Cop.classify_notint ty / .

Arguments Cop.classify_binarith ty1 ty2 / .

Arguments Cop.classify_add ty1 ty2 / .

Arguments Cop.classify_sub ty1 ty2 / .

Arguments Cop.classify_shift ty1 ty2 / .

Arguments Cop.classify_cmp ty1 ty2 / .

Arguments Cop.classify_fun ty / .

Arguments sem_cast t1 t2 / v : simpl nomatch.



Arguments sem_notbool t / v  : simpl nomatch.

Arguments sem_neg t / v : simpl nomatch.

Arguments sem_notint t / v : simpl nomatch.

Arguments sem_add CS t1 t2 / v1 v2 : simpl nomatch.

Arguments sem_sub CS t1 t2 / v1 v2 : simpl nomatch.

Arguments sem_shift t1 t2 _ _  / v1 v2 : simpl nomatch.

Arguments sem_shl t1 t2  / v1 v2 : simpl nomatch.

Arguments sem_shr t1 t2  / v1 v2 : simpl nomatch.

Arguments sem_cmp c t1 t2 / v1 v2 : simpl nomatch.

Arguments sem_unary_operation op ty / v : simpl nomatch.

Arguments sem_binary_operation' CS op t1 t2 / v1 v2 : simpl nomatch.



Arguments sem_cmp_default c t1 t2 / v1 v2 : simpl nomatch.

Arguments sem_binarith sem_int sem_long sem_float sem_single t1 t2 / v1 v2 : simpl nomatch.

Arguments Cop.sem_cast v !t1 !t2 m / .
