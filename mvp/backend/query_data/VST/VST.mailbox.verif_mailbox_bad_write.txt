Require Import mailbox.general_atomics.
Require Import VST.progs.conclib.
Require Import VST.progs.ghost.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.mailbox_bad.
(* mailbox.mailbox_bad:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition ___builtin_annot : ident := 5%positive.
Definition ___builtin_annot_intval : ident := 6%positive.
Definition ___builtin_bswap : ident := 31%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_bswap64 : ident := 32%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 3%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 7%positive.
Definition ___builtin_memcpy_aligned : ident := 4%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 9%positive.
Definition ___builtin_va_copy : ident := 10%positive.
Definition ___builtin_va_end : ident := 11%positive.
Definition ___builtin_va_start : ident := 8%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 15%positive.
Definition ___compcert_va_float64 : ident := 14%positive.
Definition ___compcert_va_int32 : ident := 12%positive.
Definition ___compcert_va_int64 : ident := 13%positive.
Definition ___i64_dtos : ident := 16%positive.
Definition ___i64_dtou : ident := 17%positive.
Definition ___i64_sar : ident := 28%positive.
Definition ___i64_sdiv : ident := 22%positive.
Definition ___i64_shl : ident := 26%positive.
Definition ___i64_shr : ident := 27%positive.
Definition ___i64_smod : ident := 24%positive.
Definition ___i64_smulh : ident := 29%positive.
Definition ___i64_stod : ident := 18%positive.
Definition ___i64_stof : ident := 20%positive.
Definition ___i64_udiv : ident := 23%positive.
Definition ___i64_umod : ident := 25%positive.
Definition ___i64_umulh : ident := 30%positive.
Definition ___i64_utod : ident := 19%positive.
Definition ___i64_utof : ident := 21%positive.
Definition _arg : ident := 90%positive.
Definition _atomic_exchange_SC : ident := 59%positive.
Definition _avail : ident := 86%positive.
Definition _available : ident := 83%positive.
Definition _b : ident := 71%positive.
Definition _buf : ident := 91%positive.
Definition _buffer : ident := 2%positive.
Definition _bufs : ident := 67%positive.
Definition _c : ident := 64%positive.
Definition _comm : ident := 68%positive.
Definition _d : ident := 95%positive.
Definition _data : ident := 1%positive.
Definition _exit : ident := 54%positive.
Definition _finish_read : ident := 78%positive.
Definition _finish_write : ident := 89%positive.
Definition _i : ident := 65%positive.
Definition _i__1 : ident := 85%positive.
Definition _initialize_channels : ident := 73%positive.
Definition _initialize_reader : ident := 76%positive.
Definition _initialize_writer : ident := 82%positive.
Definition _last : ident := 84%positive.
Definition _last_given : ident := 81%positive.
Definition _last_read : ident := 70%positive.
Definition _last_taken : ident := 79%positive.
Definition _load_SC : ident := 57%positive.
Definition _lr : ident := 75%positive.
Definition _main : ident := 96%positive.
Definition _malloc : ident := 55%positive.
Definition _memset : ident := 66%positive.
Definition _n : ident := 60%positive.
Definition _p : ident := 61%positive.
Definition _r : ident := 72%positive.
Definition _reader : ident := 93%positive.
Definition _reading : ident := 69%positive.
Definition _rr : ident := 74%positive.
Definition _s : ident := 63%positive.
Definition _spawn : ident := 56%positive.
Definition _start_read : ident := 77%positive.
Definition _start_write : ident := 87%positive.
Definition _store_SC : ident := 58%positive.
Definition _surely_malloc : ident := 62%positive.
Definition _v : ident := 92%positive.
Definition _w : ident := 88%positive.
Definition _writer : ident := 94%positive.
Definition _writing : ident := 80%positive.
Definition _t'1 : ident := 97%positive.
Definition _t'2 : ident := 98%positive.
Definition _t'3 : ident := 99%positive.
Definition _t'4 : ident := 100%positive.

Definition f_surely_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
      ((Etempvar _n tuint) :: nil))
    (Sset _p (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
      (Scall None (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
        ((Econst_int (Int.repr 1) tint) :: nil))
      Sskip)
    (Sreturn (Some (Etempvar _p (tptr tvoid))))))
|}.

Definition f_memset := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_s, (tptr tvoid)) :: (_c, tint) :: (_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tint)) :: (_i, tuint) :: nil);
  fn_body :=
(Ssequence
  (Sset _p (Ecast (Etempvar _s (tptr tvoid)) (tptr tint)))
  (Ssequence
    (Ssequence
      (Sset _i (Econst_int (Int.repr 0) tint))
      (Sloop
        (Ssequence
          (Sifthenelse (Ebinop Olt (Etempvar _i tuint)
                         (Ebinop Odiv (Etempvar _n tuint)
                           (Econst_int (Int.repr 4) tint) tuint) tint)
            Sskip
            Sbreak)
          (Sassign
            (Ederef
              (Ebinop Oadd (Etempvar _p (tptr tint)) (Etempvar _i tuint)
                (tptr tint)) tint) (Etempvar _c tint)))
        (Sset _i
          (Ebinop Oadd (Etempvar _i tuint) (Econst_int (Int.repr 1) tint)
            tuint))))
    (Sreturn (Some (Etempvar _s (tptr tvoid))))))
|}.

Definition v_bufs := {|
  gvar_info := (tarray (tptr (Tstruct _buffer noattr)) 5);
  gvar_init := (Init_space 20 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_comm := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_reading := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_last_read := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_initialize_channels := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_b, (tptr (Tstruct _buffer noattr))) ::
               (_r, tint) :: (_c, (tptr tint)) :: (_t'4, (tptr tvoid)) ::
               (_t'3, (tptr tvoid)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                       (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                         (Econst_int (Int.repr 2) tint) tint) tint)
          Sskip
          Sbreak)
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                     cc_default))
              ((Esizeof (Tstruct _buffer noattr) tuint) :: nil))
            (Sset _b (Etempvar _t'1 (tptr tvoid))))
          (Ssequence
            (Scall None
              (Evar _memset (Tfunction
                              (Tcons (tptr tvoid)
                                (Tcons tint (Tcons tuint Tnil))) (tptr tvoid)
                              cc_default))
              ((Etempvar _b (tptr (Tstruct _buffer noattr))) ::
               (Econst_int (Int.repr 0) tint) ::
               (Esizeof (Tstruct _buffer noattr) tuint) :: nil))
            (Sassign
              (Ederef
                (Ebinop Oadd
                  (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                  (Etempvar _i tint) (tptr (tptr (Tstruct _buffer noattr))))
                (tptr (Tstruct _buffer noattr)))
              (Etempvar _b (tptr (Tstruct _buffer noattr)))))))
      (Sset _i
        (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
  (Ssequence
    (Sset _r (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                       (Econst_int (Int.repr 3) tint) tint)
          Sskip
          Sbreak)
        (Ssequence
          (Ssequence
            (Scall (Some _t'2)
              (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                     cc_default))
              ((Esizeof tint tuint) :: nil))
            (Sset _c (Etempvar _t'2 (tptr tvoid))))
          (Ssequence
            (Sassign (Ederef (Etempvar _c (tptr tint)) tint)
              (Econst_int (Int.repr 0) tint))
            (Ssequence
              (Sassign
                (Ederef
                  (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3))
                    (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                (Etempvar _c (tptr tint)))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'3)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof tint tuint) :: nil))
                  (Sset _c (Etempvar _t'3 (tptr tvoid))))
                (Ssequence
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3))
                        (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                    (Etempvar _c (tptr tint)))
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'4)
                        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                               (tptr tvoid) cc_default))
                        ((Esizeof tint tuint) :: nil))
                      (Sset _c (Etempvar _t'4 (tptr tvoid))))
                    (Sassign
                      (Ederef
                        (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
                          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                      (Etempvar _c (tptr tint))))))))))
      (Sset _r
        (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint) tint)))))
|}.

Definition f_initialize_reader := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_rr, (tptr tint)) :: (_lr, (tptr tint)) :: nil);
  fn_body :=
(Ssequence
  (Sset _rr
    (Ederef
      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Ssequence
    (Sset _lr
      (Ederef
        (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
    (Ssequence
      (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
        (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))
      (Sassign (Ederef (Etempvar _lr (tptr tint)) tint)
        (Econst_int (Int.repr 1) tint)))))
|}.

Definition f_start_read := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_b, tint) :: (_c, (tptr tint)) :: (_rr, (tptr tint)) ::
               (_lr, (tptr tint)) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _c
    (Ederef
      (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Ssequence
    (Sset _rr
      (Ederef
        (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3))
          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
    (Ssequence
      (Sset _lr
        (Ederef
          (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
            (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _atomic_exchange_SC (Tfunction
                                        (Tcons (tptr tint) (Tcons tint Tnil))
                                        tint cc_default))
            ((Etempvar _c (tptr tint)) ::
             (Eunop Oneg (Econst_int (Int.repr 1) tint) tint) :: nil))
          (Sset _b (Etempvar _t'1 tint)))
        (Ssequence
          (Ssequence
            (Sifthenelse (Ebinop Oge (Etempvar _b tint)
                           (Econst_int (Int.repr 0) tint) tint)
              (Sset _t'2
                (Ecast
                  (Ebinop Olt (Etempvar _b tint)
                    (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                      (Econst_int (Int.repr 2) tint) tint) tint) tbool))
              (Sset _t'2 (Econst_int (Int.repr 0) tint)))
            (Sifthenelse (Etempvar _t'2 tint)
              (Sassign (Ederef (Etempvar _lr (tptr tint)) tint)
                (Etempvar _b tint))
              (Sset _b (Ederef (Etempvar _lr (tptr tint)) tint))))
          (Ssequence
            (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
              (Etempvar _b tint))
            (Sreturn (Some (Etempvar _b tint)))))))))
|}.

Definition f_finish_read := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_rr, (tptr tint)) :: nil);
  fn_body :=
(Ssequence
  (Sset _rr
    (Ederef
      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
    (Eunop Oneg (Econst_int (Int.repr 1) tint) tint)))
|}.

Definition v_last_taken := {|
  gvar_info := (tarray tint 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_writing := {|
  gvar_info := tint;
  gvar_init := (Init_space 4 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_last_given := {|
  gvar_info := tint;
  gvar_init := (Init_space 4 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_initialize_writer := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: nil);
  fn_body :=
(Ssequence
  (Sassign (Evar _last_given tint) (Econst_int (Int.repr 0) tint))
  (Ssequence
    (Sassign (Evar _writing tint)
      (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))
    (Ssequence
      (Sset _i (Econst_int (Int.repr 0) tint))
      (Sloop
        (Ssequence
          (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                         (Econst_int (Int.repr 3) tint) tint)
            Sskip
            Sbreak)
          (Sassign
            (Ederef
              (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                (Etempvar _i tint) (tptr tint)) tint)
            (Econst_int (Int.repr 1) tint)))
        (Sset _i
          (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
            tint))))))
|}.

Definition f_start_write := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_available, (tarray tint 5)) :: nil);
  fn_temps := ((_i, tint) :: (_last, tint) :: (_r, tint) :: (_i__1, tint) ::
               (_avail, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                       (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                         (Econst_int (Int.repr 2) tint) tint) tint)
          Sskip
          Sbreak)
        (Sassign
          (Ederef
            (Ebinop Oadd (Evar _available (tarray tint 5)) (Etempvar _i tint)
              (tptr tint)) tint) (Econst_int (Int.repr 1) tint)))
      (Sset _i
        (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
  (Ssequence
    (Sset _last (Evar _last_given tint))
    (Ssequence
      (Sassign
        (Ederef
          (Ebinop Oadd (Evar _available (tarray tint 5))
            (Etempvar _last tint) (tptr tint)) tint)
        (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Ssequence
          (Sset _r (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Sset _last
                  (Ederef
                    (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                      (Etempvar _r tint) (tptr tint)) tint))
                (Sifthenelse (Ebinop One (Etempvar _last tint)
                               (Eunop Oneg (Econst_int (Int.repr 1) tint)
                                 tint) tint)
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _available (tarray tint 5))
                        (Etempvar _last tint) (tptr tint)) tint)
                    (Econst_int (Int.repr 0) tint))
                  Sskip)))
            (Sset _r
              (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Ssequence
          (Ssequence
            (Sset _i__1 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__1 tint)
                               (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                                 (Econst_int (Int.repr 2) tint) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Sset _avail
                    (Ederef
                      (Ebinop Oadd (Evar _available (tarray tint 5))
                        (Etempvar _i__1 tint) (tptr tint)) tint))
                  (Sifthenelse (Etempvar _avail tint)
                    (Ssequence
                      (Sassign (Evar _writing tint) (Etempvar _i__1 tint))
                      (Sreturn (Some (Etempvar _i__1 tint))))
                    Sskip)))
              (Sset _i__1
                (Ebinop Oadd (Etempvar _i__1 tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Scall None
            (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
            ((Econst_int (Int.repr 1) tint) :: nil)))))))
|}.

Definition f_finish_write := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_last, tint) :: (_w, tint) :: (_r, tint) ::
               (_c, (tptr tint)) :: (_b, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _last (Evar _last_given tint))
  (Ssequence
    (Sset _w (Evar _writing tint))
    (Ssequence
      (Ssequence
        (Sset _r (Econst_int (Int.repr 0) tint))
        (Sloop
          (Ssequence
            (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                           (Econst_int (Int.repr 3) tint) tint)
              Sskip
              Sbreak)
            (Ssequence
              (Sset _c
                (Ederef
                  (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3))
                    (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _atomic_exchange_SC (Tfunction
                                                (Tcons (tptr tint)
                                                  (Tcons tint Tnil)) tint
                                                cc_default))
                    ((Etempvar _c (tptr tint)) :: (Etempvar _w tint) :: nil))
                  (Sset _b (Etempvar _t'1 tint)))
                (Sifthenelse (Ebinop Oeq (Etempvar _b tint)
                               (Eunop Oneg (Econst_int (Int.repr 1) tint)
                                 tint) tint)
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                        (Etempvar _r tint) (tptr tint)) tint)
                    (Etempvar _last tint))
                  Sskip))))
          (Sset _r
            (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint)
              tint))))
      (Ssequence
        (Sassign (Evar _last_given tint) (Etempvar _w tint))
        (Sassign (Evar _writing tint)
          (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))))))
|}.

Definition f_reader := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_r, tint) :: (_b, tint) ::
               (_buf, (tptr (Tstruct _buffer noattr))) :: (_v, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _r (Ederef (Ecast (Etempvar _arg (tptr tvoid)) (tptr tint)) tint))
  (Ssequence
    (Scall None
      (Evar _initialize_reader (Tfunction (Tcons tint Tnil) tvoid cc_default))
      ((Etempvar _r tint) :: nil))
    (Ssequence
      (Sloop
        (Ssequence
          Sskip
          (Ssequence
            (Ssequence
              (Scall (Some _t'1)
                (Evar _start_read (Tfunction (Tcons tint Tnil) tint
                                    cc_default)) ((Etempvar _r tint) :: nil))
              (Sset _b (Etempvar _t'1 tint)))
            (Ssequence
              (Sset _buf
                (Ederef
                  (Ebinop Oadd
                    (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                    (Etempvar _b tint)
                    (tptr (tptr (Tstruct _buffer noattr))))
                  (tptr (Tstruct _buffer noattr))))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'2)
                    (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                     cc_default))
                    ((Eaddrof
                       (Efield
                         (Ederef
                           (Etempvar _buf (tptr (Tstruct _buffer noattr)))
                           (Tstruct _buffer noattr)) _data tint) (tptr tint)) ::
                     nil))
                  (Sset _v (Etempvar _t'2 tint)))
                (Scall None
                  (Evar _finish_read (Tfunction (Tcons tint Tnil) tvoid
                                       cc_default))
                  ((Etempvar _r tint) :: nil))))))
        Sskip)
      (Sreturn (Some (Econst_int (Int.repr 0) tint))))))
|}.

Definition f_writer := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_v, tint) :: (_b, tint) ::
               (_buf, (tptr (Tstruct _buffer noattr))) :: (_t'1, tint) ::
               nil);
  fn_body :=
(Ssequence
  (Scall None (Evar _initialize_writer (Tfunction Tnil tvoid cc_default))
    nil)
  (Ssequence
    (Sset _v (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Sloop
        (Ssequence
          Sskip
          (Ssequence
            (Ssequence
              (Scall (Some _t'1)
                (Evar _start_write (Tfunction Tnil tint cc_default)) nil)
              (Sset _b (Etempvar _t'1 tint)))
            (Ssequence
              (Sset _buf
                (Ederef
                  (Ebinop Oadd
                    (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                    (Etempvar _b tint)
                    (tptr (tptr (Tstruct _buffer noattr))))
                  (tptr (Tstruct _buffer noattr))))
              (Ssequence
                (Scall None
                  (Evar _store_SC (Tfunction
                                    (Tcons (tptr tint) (Tcons tint Tnil))
                                    tvoid cc_default))
                  ((Eaddrof
                     (Efield
                       (Ederef
                         (Etempvar _buf (tptr (Tstruct _buffer noattr)))
                         (Tstruct _buffer noattr)) _data tint) (tptr tint)) ::
                   (Etempvar _v tint) :: nil))
                (Ssequence
                  (Scall None
                    (Evar _finish_write (Tfunction Tnil tvoid cc_default))
                    nil)
                  (Sset _v
                    (Ebinop Oadd (Etempvar _v tint)
                      (Econst_int (Int.repr 1) tint) tint)))))))
        Sskip)
      (Sreturn (Some (Econst_int (Int.repr 0) tint))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_d, (tptr tint)) :: (_t'1, (tptr tvoid)) ::
               nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall None (Evar _initialize_channels (Tfunction Tnil tvoid cc_default))
      nil)
    (Ssequence
      (Scall None
        (Evar _spawn (Tfunction
                       (Tcons
                         (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                 (tptr tvoid) cc_default))
                         (Tcons (tptr tvoid) Tnil)) tvoid cc_default))
        ((Ecast
           (Eaddrof
             (Evar _writer (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid)
                             cc_default))
             (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid)
                     cc_default))) (tptr tvoid)) ::
         (Econst_int (Int.repr 0) tint) :: nil))
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof tint tuint) :: nil))
                  (Sset _d (Etempvar _t'1 (tptr tvoid))))
                (Ssequence
                  (Sassign (Ederef (Etempvar _d (tptr tint)) tint)
                    (Etempvar _i tint))
                  (Scall None
                    (Evar _spawn (Tfunction
                                   (Tcons
                                     (tptr (Tfunction
                                             (Tcons (tptr tvoid) Tnil)
                                             (tptr tvoid) cc_default))
                                     (Tcons (tptr tvoid) Tnil)) tvoid
                                   cc_default))
                    ((Ecast
                       (Eaddrof
                         (Evar _reader (Tfunction (Tcons (tptr tvoid) Tnil)
                                         (tptr tvoid) cc_default))
                         (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                 (tptr tvoid) cc_default))) (tptr tvoid)) ::
                     (Ecast (Etempvar _d (tptr tint)) (tptr tvoid)) :: nil)))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Sloop Sskip Sskip))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _buffer Struct ((_data, tint) :: nil) noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_smulh,
   Gfun(External (EF_runtime "__i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umulh,
   Gfun(External (EF_runtime "__i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_exit,
   Gfun(External (EF_external "exit"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons tint Tnil) tvoid cc_default)) ::
 (_malloc,
   Gfun(External EF_malloc (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_spawn,
   Gfun(External (EF_external "spawn"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons
       (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default))
       (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_atomic_exchange_SC,
   Gfun(External (EF_external "atomic_exchange_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tint
     cc_default)) :: (_surely_malloc, Gfun(Internal f_surely_malloc)) ::
 (_memset, Gfun(Internal f_memset)) :: (_bufs, Gvar v_bufs) ::
 (_comm, Gvar v_comm) :: (_reading, Gvar v_reading) ::
 (_last_read, Gvar v_last_read) ::
 (_initialize_channels, Gfun(Internal f_initialize_channels)) ::
 (_initialize_reader, Gfun(Internal f_initialize_reader)) ::
 (_start_read, Gfun(Internal f_start_read)) ::
 (_finish_read, Gfun(Internal f_finish_read)) ::
 (_last_taken, Gvar v_last_taken) :: (_writing, Gvar v_writing) ::
 (_last_given, Gvar v_last_given) ::
 (_initialize_writer, Gfun(Internal f_initialize_writer)) ::
 (_start_write, Gfun(Internal f_start_write)) ::
 (_finish_write, Gfun(Internal f_finish_write)) ::
 (_reader, Gfun(Internal f_reader)) :: (_writer, Gfun(Internal f_writer)) ::
 (_main, Gfun(Internal f_main)) :: nil);
prog_public :=
(_main :: _writer :: _reader :: _finish_write :: _start_write ::
 _initialize_writer :: _last_given :: _writing :: _last_taken ::
 _finish_read :: _start_read :: _initialize_reader :: _initialize_channels ::
 _last_read :: _reading :: _comm :: _bufs :: _memset :: _surely_malloc ::
 _atomic_exchange_SC :: _store_SC :: _load_SC :: _spawn :: _malloc ::
 _exit :: ___builtin_debug :: ___builtin_nop ::
 ___builtin_write32_reversed :: ___builtin_write16_reversed ::
 ___builtin_read32_reversed :: ___builtin_read16_reversed ::
 ___builtin_fnmsub :: ___builtin_fnmadd :: ___builtin_fmsub ::
 ___builtin_fmadd :: ___builtin_fmin :: ___builtin_fmax ::
 ___builtin_fsqrt :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap16 :: ___builtin_bswap32 :: ___builtin_bswap64 ::
 ___builtin_bswap :: ___i64_umulh :: ___i64_smulh :: ___i64_sar ::
 ___i64_shr :: ___i64_shl :: ___i64_umod :: ___i64_smod :: ___i64_udiv ::
 ___i64_sdiv :: ___i64_utof :: ___i64_stof :: ___i64_utod :: ___i64_stod ::
 ___i64_dtou :: ___i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)
Require Import mailbox.verif_mailbox_bad_specs.
(* mailbox.verif_mailbox_bad_specs:
Definition spawn_spec := DECLARE _spawn spawn_spec.
Definition load_SC_spec := DECLARE _load_SC load_SC_spec.
Definition store_SC_spec := DECLARE _store_SC store_SC_spec.
Definition AEX_SC_spec := DECLARE _atomic_exchange_SC AEX_SC_spec.

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH n:Z
   PRE [ _n OF tuint ]
       PROP (0 <= n <= Int.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh n p * memory_block Tsh n p).

Definition memset_spec :=
 DECLARE _memset
  WITH sh : share, t : type, p : val, c : Z, n : Z
  PRE [ _s OF tptr tvoid, _c OF tint, _n OF tuint ]
   PROP (writable_share sh; sizeof t = (4 * n)%Z; 4 * n <= Int.max_unsigned; (4 | alignof t))
   LOCAL (temp _s p; temp _c (vint c); temp _n (vint (4 * n)%Z))
   SEP (data_at_ sh t p)
  POST [ tptr tvoid ]
   PROP ()
   LOCAL (temp ret_temp p)
   SEP (data_at sh (tarray tint n) (repeat (vint c) (Z.to_nat n)) p).

Definition N := 3.
Definition B := N + 2.

Definition tbuffer := Tstruct _buffer noattr.

Definition Empty := vint (-1).

Fixpoint find_read h d :=
  match h with
  | [] => (d, [])
  | AE r w :: rest => if eq_dec w Empty then if eq_dec r Empty then find_read rest d
                      else (r, rest) else find_read rest d
  end.

Definition last_two_reads h := let '(b1, rest) := find_read h (vint 1) in (b1, fst (find_read rest (vint 1))).

Fixpoint find_write h d :=
  match h with
  | [] => (d, [])
  | AE r w :: rest => if eq_dec w Empty then find_write rest d else (w, rest)
  end.

Definition prev_taken h := fst (find_read (snd (find_write h (vint 0))) (vint 1)).

Definition last_write h := fst (find_write h (vint 0)).

Definition comm_R bufs sh gsh g g0 g1 g2 h b := EX b1 : Z, EX b2 : Z,
  !!(-1 <= b < B /\ Forall (fun a => match a with AE v1 v2 =>
       exists r w, v1 = vint r /\ v2 = vint w /\ -1 <= r < B /\ -1 <= w < B end) h /\
     apply_hist (vint 0) h = Some (vint b) /\
     last_two_reads (rev h) = (vint b1, vint b2) /\ repable_signed b1 /\ repable_signed b2) &&
  ghost_ref h g * ghost_var gsh (vint b1) g0 * ghost_var gsh (last_write (rev h)) g1 *
  ghost_var gsh (prev_taken (rev h)) g2 *
  if eq_dec b (-1) then EX v : _, data_at sh tbuffer (Vint v) (Znth b2 bufs Vundef)
  else EX v : _, data_at sh tbuffer (Vint v) (Znth b bufs Vundef).

Definition comm_inv (good : bool) comm bufs sh g g0 g1 g2 gsh :=
  EX v : Z, data_at Tsh tint (vint v) comm *
    if good then EX h : _, comm_R bufs sh gsh g g0 g1 g2 h v
        else (EX h : list AE_hist_el, ghost_ref h g) * (EX v : val, ghost_var gsh v g0) *
      (EX v : val, ghost_var gsh v g1) * (EX v : val, ghost_var gsh v g2) *
      fold_right sepcon emp (map (fun p => EX v : _, data_at sh tbuffer (Vint v) p) bufs).

Notation hist := (list (nat * AE_hist_el)).

Definition comm_loc good lsh comm g g0 g1 g2 bufs sh gsh h :=
  invariant (comm_inv good comm bufs sh g g0 g1 g2 gsh) * ghost_hist lsh (h : hist) g.

Definition initialize_channels_spec :=
 DECLARE _initialize_channels
  WITH lgood : list bool, comm : val, buf : val, reading : val, last_read : val,
       sh1 : share, shs : list share, shg : share
  PRE [ ]
   PROP (Zlength lgood = N; Zlength shs = N; sepalg_list.list_join sh1 shs Tsh;
         
         sepalg_list.list_join sh1 (map snd (filter fst (combine lgood shs))) shg)
   LOCAL (gvar _comm comm; gvar _bufs buf; gvar _reading reading; gvar _last_read last_read)
   SEP (data_at_ Ews (tarray (tptr tint) N) comm; data_at_ Ews (tarray (tptr tbuffer) B) buf;
        data_at_ Ews (tarray (tptr tint) N) reading; data_at_ Ews (tarray (tptr tint) N) last_read)
  POST [ tvoid ]
   EX comms : list val, EX bufs : list val, EX reads : list val, EX lasts : list val,
     EX g : list val, EX g0 : list val, EX g1 : list val, EX g2 : list val,
   PROP (Forall isptr comms; Forall isptr bufs;
         Zlength g = N; Zlength g0 = N; Zlength g1 = N; Zlength g2 = N)
   LOCAL ()
   SEP (data_at Ews (tarray (tptr tint) N) comms comm;
        data_at Ews (tarray (tptr tbuffer) B) bufs buf;
        data_at Ews (tarray (tptr tint) N) reads reading;
        data_at Ews (tarray (tptr tint) N) lasts last_read;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) Tsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 ([] : hist)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g0);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) comms);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tbuffer)) bufs);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) reads);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) lasts);
        
        data_at sh1 tbuffer (vint 0) (Znth 0 bufs Vundef);
        fold_right sepcon emp (map (data_at shg tbuffer (vint 0)) (sublist 1 (Zlength bufs) bufs));
        fold_right sepcon emp (map (data_at_ Tsh tint) reads);
        fold_right sepcon emp (map (data_at_ Tsh tint) lasts)).

Definition initialize_reader_spec :=
 DECLARE _initialize_reader
  WITH r : Z, reading : val, last_read : val, reads : list val, lasts : list val, sh : share
  PRE [ _r OF tint ]
   PROP (readable_share sh)
   LOCAL (temp _r (vint r); gvar _reading reading; gvar _last_read last_read)
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at sh (tarray (tptr tint) N) lasts last_read;
        data_at_ Tsh tint (Znth r reads Vundef); data_at_ Tsh tint (Znth r lasts Vundef))
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at sh (tarray (tptr tint) N) lasts last_read;
        data_at Tsh tint Empty (Znth r reads Vundef); data_at Tsh tint (vint 1) (Znth r lasts Vundef)).

Definition latest_read (h : hist) v :=
  
  (Forall (fun x => let '(_, AE r w) := x in w = Empty ->
    match r with Vint i => Int.signed i < 0 \/ Int.signed i >= B | _ => True end) h /\ v = 1) \/
  0 <= v < B /\ exists n, In (n, AE (vint v) Empty) h /\
  Forall (fun x => let '(m, AE r w) := x in w = Empty -> forall v', r = vint v' -> 0 <= v' < B ->
    (m <= n)%nat) h.

Definition start_read_spec :=
 DECLARE _start_read
  WITH r : Z, reading : val, last_read : val, comm : val, reads : list val, lasts : list val,
    good : bool, comms : list val, bufs : list val, sh : share, sh1 : share, sh2 : share, b0 : Z,
    g : val, g0 : val, g1 : val, g2 : val, h : hist
  PRE [ _r OF tint ]
   PROP (0 <= b0 < B; readable_share sh; readable_share sh1; readable_share sh2; isptr (Znth r comms Vundef);
        latest_read h b0)
   LOCAL (temp _r (vint r); gvar _reading reading; gvar _last_read last_read; gvar _comm comm)
   SEP (data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at_ Tsh tint (Znth r reads Vundef); data_at Tsh tint (vint b0) (Znth r lasts Vundef);
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 h;
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth b0 bufs Vundef) else emp;
        ghost_var gsh1 (vint b0) g0)
  POST [ tint ]
   EX b : Z, EX t : nat, EX v0 : Z,
   PROP (0 <= b < B; b = if (Z.leb 0 v0 && Z.ltb v0 B)%bool then v0 else b0;
         latest_read (h ++ [(t, AE (vint v0) Empty)]) b)
   LOCAL (temp ret_temp (vint b))
   SEP (data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at Tsh tint (vint b) (Znth r reads Vundef); data_at Tsh tint (vint b) (Znth r lasts Vundef);
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 (h ++ [(t, AE (vint v0) Empty)]);
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth b bufs Vundef) else emp;
        ghost_var gsh1 (vint b) g0).

Definition finish_read_spec :=
 DECLARE _finish_read
  WITH r : Z, reading : val, reads : list val, sh : share
  PRE [ _r OF tint ]
   PROP (readable_share sh)
   LOCAL (temp _r (vint r); gvar _reading reading)
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at_ Tsh tint (Znth r reads Vundef))
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at Tsh tint Empty (Znth r reads Vundef)).

Definition initialize_writer_spec :=
 DECLARE _initialize_writer
  WITH writing : val, last_given : val, last_taken : val
  PRE [ ]
   PROP ()
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (data_at_ Ews tint writing; data_at_ Ews tint last_given;
        data_at_ Ews (tarray tint N) last_taken)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at Ews tint Empty writing; data_at Ews tint (vint 0) last_given;
        data_at Ews (tarray tint N) (repeat (vint 1) (Z.to_nat N)) last_taken).

Definition start_write_spec :=
 DECLARE _start_write
  WITH writing : val, last_given : val, last_taken : val, b0 : Z, lasts : list Z
  PRE [ ]
   PROP (0 <= b0 < B; Forall (fun x => 0 <= x < B) lasts)
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (data_at_ Ews tint writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken)
  POST [ tint ]
   EX b : Z,
   PROP (0 <= b < B; b <> b0; ~In b lasts)
   LOCAL (temp ret_temp (vint b))
   SEP (data_at Ews tint (vint b) writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken).

Fixpoint make_shares shs lasts i : list share :=
  match lasts with
  | [] => []
  | (g, b) :: rest => if (negb g || Z.eqb b i)%bool then make_shares (tl shs) rest i
                 else hd Share.bot shs :: make_shares (tl shs) rest i
  end.

Definition finish_write_spec :=
 DECLARE _finish_write
  WITH writing : val, last_given : val, last_taken : val, comm : val, comms : list val, bufs : list val,
    lgood : list bool, b : Z, b0 : Z, lasts : list Z,
    sh1 : share, lsh : share, shs : list share, g : list val, g0 : list val, g1 : list val, g2 : list val,
    h : list hist, sh0 : share
  PRE [ ]
   PROP (0 <= b < B; 0 <= b0 < B; Forall (fun x => 0 <= x < B) lasts; Zlength h = N;
         Zlength lgood = N; Zlength shs = N;
         readable_share sh1; readable_share lsh; Forall readable_share shs;
         sepalg_list.list_join sh0 shs Tsh; Forall isptr comms; b <> b0; ~In b lasts; ~In b0 lasts)
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken; gvar _comm comm)
   SEP (data_at Ews tint (vint b) writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 (Znth r h [])) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun r => ghost_var gsh1 (vint b0) (Znth r g1 Vundef) *
          ghost_var gsh1 (vint (Znth r lasts (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i b0 then sh = sh0 else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts) i) sh) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B))))
  POST [ tvoid ]
   EX lasts' : list Z, EX h' : list hist,
   PROP (Forall (fun x => 0 <= x < B) lasts';
         Forall2 (fun h1 h2 => exists t v, h2 = h1 ++ [(t, AE v (vint b))]) h h';
         ~In b lasts')
   LOCAL ()
   SEP (data_at Ews tint Empty writing; data_at Ews tint (vint b) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts') last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 (Znth r h' [])) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun r => ghost_var gsh1 (vint b) (Znth r g1 Vundef) *
          ghost_var gsh1 (vint (Znth r lasts' (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i b then sh = sh0 else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts') i) sh) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B)))).

Definition reader_spec :=
 DECLARE _reader
  WITH arg : val, x : Z * bool * val * val * val * val * list val * list val * list val * list val *
                      share * share * share * val * val * val * val
  PRE [ _arg OF tptr tvoid ]
   let '(r, good, reading, last_read, comm, buf, reads, lasts, comms, bufs, sh1, sh2, sh, g, g0, g1, g2) := x in
   PROP (readable_share sh; readable_share sh1; readable_share sh2; isptr (Znth r comms Vundef);
         Forall isptr bufs)
   LOCAL (temp _arg arg; gvar _reading reading; gvar _last_read last_read;
          gvar _comm comm; gvar _bufs buf)
   SEP (data_at Tsh tint (vint r) arg; malloc_token Tsh (sizeof tint) arg;
        data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at_ Tsh tint (Znth r reads Vundef); data_at_ Tsh tint (Znth r lasts Vundef);
        data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 [];
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth 1 bufs Vundef) else emp;
        ghost_var gsh1 (vint 1) g0)
  POST [ tptr tvoid ] PROP () LOCAL () SEP ().

Definition writer_spec :=
 DECLARE _writer
  WITH arg : val, x : list bool * val * val * val * val * val * list val * list val * share * share *
                      share * list share * share * list val * list val * list val * list val
  PRE [ _arg OF tptr tvoid ]
   let '(lgood, writing, last_given, last_taken, comm, buf, comms, bufs, sh1, lsh, sh0, shs, shg, g, g0, g1, g2) := x in
   PROP (Zlength lgood = N; Zlength shs = N; readable_share sh1; readable_share lsh;
         readable_share sh0; Forall readable_share shs;
         sepalg_list.list_join sh0 shs Tsh;
         sepalg_list.list_join sh0 (map snd (filter fst (combine lgood shs))) shg;
         Zlength g1 = N; Zlength g2 = N; Forall isptr comms)
   LOCAL (temp _arg arg; gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken;
          gvar _comm comm; gvar _bufs buf)
   SEP (data_at_ Ews tint writing; data_at_ Ews tint last_given; data_at_ Ews (tarray tint N) last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 []) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2);
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i 0 then sh = sh0 else if eq_dec i 1 then sh = sh0 else sh = shg) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B))))
  POST [ tptr tvoid ] PROP () LOCAL () SEP ().

Definition main_spec :=
 DECLARE _main
  WITH u : unit
  PRE  [] main_pre prog [] u
  POST [ tint ] main_post prog [] u.

Definition Gprog : funspecs := ltac:(with_library prog [spawn_spec;
  surely_malloc_spec; memset_spec; AEX_SC_spec; load_SC_spec; store_SC_spec;
  initialize_channels_spec; initialize_reader_spec;
  start_read_spec; finish_read_spec; initialize_writer_spec; start_write_spec; finish_write_spec;
  reader_spec; writer_spec; main_spec]).

Lemma Empty_inj : forall i, vint i = Empty -> repable_signed i -> i = -1.

Lemma repable_buf : forall a, -1 <= a < B -> repable_signed a.

Opaque upto.

Lemma list_join_minus : forall l (sh : share) shs sh1 sh2 (Hl : Zlength l = Zlength shs)
  (Hall : sepalg_list.list_join sh shs sh1)

Lemma fold_right_emp : forall l (Hemp : Forall (eq emp) l), fold_right sepcon emp l = emp.

Lemma last_two_reads_cons : forall r w h, last_two_reads (AE r w :: h) =
  if eq_dec w Empty then if eq_dec r Empty then last_two_reads h else (r, fst (last_two_reads h))
  else last_two_reads h.

Lemma prev_taken_cons : forall r w h, prev_taken (AE r w :: h) =
  if eq_dec w Empty then prev_taken h else fst (find_read h (vint 1)).

Lemma find_read_pos : forall d h, d <> Empty -> fst (find_read h d) <> Empty.

Corollary last_two_reads_fst : forall h, fst (last_two_reads h) <> Empty.

Lemma find_read_In : forall d h, In (AE (fst (find_read h d)) Empty) (AE d Empty :: h).

Corollary last_two_reads_In1 : forall h, In (AE (fst (last_two_reads h)) Empty) (AE (vint 1) Empty :: h).

Lemma find_read_incl : forall a d h, In a (snd (find_read h d)) -> In a h.

Corollary last_two_reads_In2 : forall h, In (AE (snd (last_two_reads h)) Empty) (AE (vint 1) Empty :: h).

Lemma latest_read_bad : forall h n r v, repable_signed r -> r < 0 \/ r >= B ->
  latest_read (h ++ [(n, AE (vint r) Empty)]) v <-> latest_read h v.

Corollary latest_read_Empty : forall h n v,
  latest_read (h ++ [(n, AE Empty Empty)]) v <-> latest_read h v.

Lemma latest_read_new : forall h n v, newer h n -> 0 <= v < B ->
  latest_read (h ++ [(n, AE (vint v) Empty)]) v. *)

Set Bullet Behavior "Strict Subproofs".

Opaque upto.

Lemma body_initialize_writer : semax_body Vprog Gprog f_initialize_writer initialize_writer_spec.
Proof.
  start_function.
  forward.
  forward.
  forward_for_simple_bound N (EX i : Z, PROP ( )
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (field_at Ews tint [] (eval_unop Oneg tint (vint 1)) writing; field_at Ews tint [] (vint 0) last_given;
        data_at Ews (tarray tint N) (repeat (vint 1) (Z.to_nat i) ++ repeat Vundef (Z.to_nat (N - i))) last_taken)).
  { unfold N; computable. }
  { unfold N; computable. }
  { entailer!. }
  - forward.
    rewrite upd_init_const; auto.
    entailer!.
  - forward.
Qed.

Lemma body_start_write : semax_body Vprog Gprog f_start_write start_write_spec.
Proof.
  start_function.
  rewrite <- seq_assoc.
  forward_for_simple_bound B (EX i : Z, PROP ( )
   LOCAL (lvar _available (tarray tint B) v_available; gvar _writing writing; gvar _last_given last_given;
   gvar _last_taken last_taken)
   SEP (data_at Tsh (tarray tint B) (repeat (vint 1) (Z.to_nat i) ++ repeat Vundef (Z.to_nat (B - i))) v_available;
        data_at_ Ews tint writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
  { unfold B, N; computable. }
  { entailer!. }
  { forward.
    rewrite upd_init_const; auto; entailer!. }
  rewrite Zminus_diag, app_nil_r.
  forward.
  forward.
  rewrite <- seq_assoc.
  assert_PROP (Zlength lasts = N).
  { gather_SEP 3.
    go_lowerx.
    apply sepcon_derives_prop.
    eapply derives_trans; [apply data_array_at_local_facts'; unfold N; omega|].
    apply prop_left; intros (? & ? & ?).
    unfold unfold_reptype in *; simpl in *.
    rewrite Zlength_map in *; apply prop_right; auto. }
  forward_for_simple_bound N (EX i : Z, PROP ( )
   LOCAL (temp _i (vint B); lvar _available (tarray tint B) v_available;
   gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (field_at Tsh (tarray tint B) [] (map (fun x => vint (if eq_dec x b0 then 0
     else if in_dec eq_dec x (sublist 0 i lasts) then 0 else 1)) (upto (Z.to_nat B))) v_available;
   data_at_ Ews tint writing; data_at Ews tint (vint b0) last_given;
   data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
  { unfold N; computable. }
  { unfold N; computable. }
  { entailer!.
    rewrite upd_Znth_eq with (d := Vundef); simpl; [|rewrite !Zlength_cons, Zlength_nil; unfold B, N in *; omega].
    unfold Znth; simpl.
    apply derives_refl'; f_equal.
    apply map_ext_in; intros ? Hin.
    rewrite In_upto in Hin.
    destruct (eq_dec a b0); auto.
    destruct (zlt a 0); [omega|].
    destruct Hin as (? & Hin); apply Z2Nat.inj_lt in Hin; auto; try omega.
    simpl in *; destruct (Z.to_nat a); auto.
    repeat (destruct n0; [solve [auto]|]).
    omega. }
  { assert (0 <= i < Zlength lasts) by omega.
    forward.
    forward_if (PROP ( )
      LOCAL (temp _last (vint (Znth i lasts 0)); temp _r (vint i); temp _i (vint B); lvar _available (tarray tint 5) v_available; 
             gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
      SEP (field_at Tsh (tarray tint B) [] (map (fun x => vint (if eq_dec x b0 then 0
             else if in_dec eq_dec x (sublist 0 (i + 1) lasts) then 0 else 1)) (upto (Z.to_nat B))) v_available;
           data_at_ Ews tint writing; data_at Ews tint (vint b0) last_given;
           data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
    - assert (0 <= Znth i lasts 0 < B) by (apply Forall_Znth; auto).
      forward.
      entailer!.
      rewrite upd_Znth_eq with (d := Vundef); [|auto].
      apply derives_refl'; erewrite map_ext_in; [reflexivity|].
      intros; rewrite In_upto, map_length, upto_length in *; simpl in *.
      erewrite Znth_map, Znth_upto; simpl; auto; try omega.
      erewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1 with (d := 0); auto; try omega.
      destruct (in_dec eq_dec a (sublist 0 i lasts ++ [Znth i lasts 0])); rewrite in_app in *.
      + destruct (eq_dec a (Znth i lasts 0)); destruct (eq_dec a b0); auto.
        destruct (in_dec eq_dec a (sublist 0 i lasts)); auto.
        destruct i0 as [? | [? | ?]]; subst; try contradiction.
      + destruct (eq_dec a (Znth i lasts 0)).
        { subst; contradiction n; simpl; auto. }
        destruct (eq_dec a b0); auto.
        destruct (in_dec eq_dec a (sublist 0 i lasts)); auto; contradiction n; auto.
    - forward.
      entailer!.
      apply derives_refl'; erewrite map_ext_in; [reflexivity|].
      intros; rewrite In_upto in *; simpl in *.
      destruct (eq_dec a b0); auto.
      erewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1 with (d := 0); auto; try omega.
      match goal with H : Int.repr _ = Int.neg _ |- _ => apply repr_inj_signed in H end.
      destruct (in_dec eq_dec a (sublist 0 i lasts ++ [Znth i lasts 0])); rewrite in_app in *.
      + destruct (in_dec eq_dec a (sublist 0 i lasts)); auto.
        destruct i0 as [? | [? | ?]]; subst; try contradiction.
        rewrite Int.unsigned_repr in *; try computable; omega.
      + destruct (in_dec eq_dec a (sublist 0 i lasts)); auto.
        contradiction n0; auto.
      + apply Forall_Znth; auto.
        eapply Forall_impl; [|eauto]; unfold repable_signed; intros.
        split; [transitivity 0 | transitivity B]; unfold B, N in *; try computable; try omega.
      + unfold repable_signed; computable.
    - intros.
      unfold exit_tycon, overridePost.
      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
      Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert; entailer!. }
  rewrite sublist_same; auto.
  set (available := map (fun x => vint (if eq_dec x b0 then 0 else if in_dec eq_dec x lasts then 0 else 1))
         (upto (Z.to_nat B))).
  rewrite <- seq_assoc.
  unfold Sfor.
  forward.
  eapply semax_seq, semax_ff.
  eapply semax_pre with (P' := EX i : Z, PROP (0 <= i <= B; forall j, j < i -> Znth j available (vint 0) = vint 0)
    LOCAL (temp _i__1 (vint i); lvar _available (tarray tint 5) v_available; gvar _writing writing;
           gvar _last_given last_given; gvar _last_taken last_taken)
    SEP (field_at Tsh (tarray tint 5) [] available v_available; data_at_ Ews tint writing;
         data_at Ews tint (vint b0) last_given; data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken)).
  { Exists 0; entailer!.
    intros; apply Znth_underflow; auto. }
  eapply semax_loop.
  + Intros i.
    assert (repable_signed i).
    { split; [transitivity 0 | transitivity B]; unfold B, N in *; try computable; try omega. }
    forward_if (PROP (i < B)
      LOCAL (temp _i__1 (vint i); lvar _available (tarray tint 5) v_available; gvar _writing writing;
             gvar _last_given last_given; gvar _last_taken last_taken)
      SEP (field_at Tsh (tarray tint 5) [] available v_available; data_at_ Ews tint writing;
           data_at Ews tint (vint b0) last_given;
           data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
    { forward.
      entailer!. }
    { forward.
      exploit (list_pigeonhole (b0 :: lasts) B).
      { rewrite Zlength_cons; unfold B; omega. }
      intros (j & ? & Hout); exploit (H3 j); [unfold B, N in *; omega|].
      subst available.
      rewrite Znth_map with (d' := B); [|rewrite Zlength_upto; auto].
      rewrite Znth_upto; [|rewrite Z2Nat.id; omega].
      destruct (eq_dec j b0); [contradiction Hout; simpl; auto|].
      destruct (in_dec eq_dec j lasts); [contradiction Hout; simpl; auto|].
      discriminate. }
    Intros.
    forward.
    { unfold B, N in *; apply prop_right; omega. }
    { entailer!.
      subst available; apply Forall_Znth; [rewrite Zlength_map, Zlength_upto; unfold B, N in *; simpl; omega|].
      rewrite Forall_forall; intros ? Hin.
      rewrite in_map_iff in Hin; destruct Hin as (? & ? & ?); subst; simpl; auto. }
    forward_if (PROP (Znth i available (vint 0) = vint 0)
      LOCAL (temp _i__1 (vint i); lvar _available (tarray tint B) v_available; gvar _writing writing;
             gvar _last_given last_given; gvar _last_taken last_taken)
      SEP (field_at Tsh (tarray tint B) [] available v_available; data_at_ Ews tint writing;
           data_at Ews tint (vint b0) last_given; data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
    { forward.
      forward.
      Exists i; entailer!.
      { subst available.
        match goal with H : typed_true _ _ |- _ => setoid_rewrite Znth_map in H; [rewrite Znth_upto in H|];
          try assumption; rewrite ?Zlength_upto, ?Z2Nat.id; try omega; unfold typed_true in H; simpl in H; inv H end.
        destruct (eq_dec i b0); [|destruct (in_dec eq_dec i lasts)]; auto; discriminate. }
      unfold data_at_, field_at_; entailer!. }
    { forward.
      entailer!.
      subst available.
      erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto, ?Z2Nat.id; try assumption; try omega.
      match goal with H : typed_false _ _ |- _ => setoid_rewrite Znth_map in H; [rewrite Znth_upto in H|];
        try assumption; rewrite ?Zlength_upto, ?Z2Nat.id; try omega; unfold typed_true in H; simpl in H; inv H end.
      destruct (eq_dec _ _); auto.
      destruct (in_dec _ _ _); auto; discriminate. }
    intros.
    unfold exit_tycon, overridePost.
    destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
    Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert.
    instantiate (1 := EX i : Z, PROP (0 <= i < B; Znth i available (vint 0) = vint 0;
      forall j : Z, j < i -> Znth j available (vint 0) = vint 0)
      LOCAL (temp _i__1 (vint i); lvar _available (tarray tint B) v_available; gvar _writing writing;
             gvar _last_given last_given; gvar _last_taken last_taken)
      SEP (field_at Tsh (tarray tint B) [] available v_available; data_at_ Ews tint writing;
           data_at Ews tint (vint b0) last_given; data_at Ews (tarray tint N) (map (fun x : Z => vint x) lasts) last_taken)).
    Exists i; entailer!.
  + Intros i.
    forward.
    unfold loop2_ret_assert.
    Exists (i + 1); entailer!.
    intros; destruct (eq_dec j i); subst; auto.
    assert (j < i) by omega; auto.
Qed.

Lemma find_write_rest : forall d h, exists n, snd (find_write h d) = skipn n h.
Proof.
  induction h; simpl; intros; try discriminate.
  { exists O; auto. }
  destruct a.
  destruct (eq_dec w Empty).
  - destruct IHh as (n & ?); subst.
    exists (S n); auto.
  - exists 1%nat; auto.
Qed.

Corollary prev_taken_In : forall h, prev_taken h = vint 1 \/ In (AE (prev_taken h) Empty) h.
Proof.
  intros; unfold prev_taken.
  destruct (find_read_In (vint 1) (snd (find_write h (vint 0)))).
  - inv H; auto.
  - destruct (find_write_rest (vint 0) h) as (? & Hrest); rewrite Hrest in *.
    right; eapply skipn_In; eauto.
Qed.

Lemma write_val : forall h i v (Hh : apply_hist i (rev h) = Some v), v = Empty \/ v = fst (find_write h i).
Proof.
  induction h; simpl; intros.
  { inv Hh; auto. }
  destruct a.
  rewrite apply_hist_app in Hh; simpl in Hh.
  destruct (apply_hist i (rev h)) eqn: Hh'; [|discriminate].
  destruct (eq_dec r v0); inv Hh.
  destruct (eq_dec v Empty); auto.
Qed.

Lemma find_write_read : forall i d h (Hread : apply_hist i (rev h) = Some Empty) (Hi : i <> Empty),
  fst (find_read h d) = fst (find_write h i).
Proof.
  induction h; auto; simpl; intros.
  { inv Hread; contradiction Hi; auto. }
  destruct a.
  rewrite apply_hist_app in Hread; simpl in Hread.
  destruct (apply_hist i (rev h)) eqn: Hh; [|discriminate].
  destruct (eq_dec r v); [subst | discriminate].
  inv Hread.
  rewrite !eq_dec_refl.
  destruct (eq_dec v Empty); eauto.
  exploit write_val; eauto; intros [? | ?]; subst; eauto; contradiction n; auto.
Qed.

Lemma take_read : forall h v, apply_hist (vint 0) (rev h) = Some v ->
  prev_taken h = if eq_dec v Empty then snd (last_two_reads h)
                 else fst (last_two_reads h).
Proof.
  induction h; simpl; intros.
  - inv H.
    destruct (eq_dec (vint 0) Empty); auto.
  - destruct a; rewrite prev_taken_cons, last_two_reads_cons.
    rewrite apply_hist_app in H; simpl in H.
    destruct (apply_hist (vint 0) (rev h)) eqn: Hh; [|discriminate].
    destruct (eq_dec r v0); [subst | discriminate].
    inv H.
    erewrite IHh; eauto.
    destruct (eq_dec v Empty).
    + destruct (eq_dec v0 Empty); auto.
    + unfold last_two_reads.
      destruct (find_read h (vint 1)); auto.
Qed.

Lemma find_write_In : forall d h, fst (find_write h d) = d \/ exists r, In (AE r (fst (find_write h d))) h.
Proof.
  induction h; auto; simpl; intros.
  destruct a.
  destruct (eq_dec w Empty); [destruct IHh as [|(? & ?)]|]; eauto.
Qed.

Lemma make_shares_app : forall i l1 l2 shs, Zlength l1 + Zlength l2 <= Zlength shs ->
  make_shares shs (l1 ++ l2) i =
  make_shares shs l1 i ++ make_shares (sublist (Zlength l1) (Zlength shs) shs) l2 i.
Proof.
  induction l1; simpl; intros.
  - rewrite sublist_same; auto.
  - rewrite Zlength_cons in *.
    destruct a, shs.
    { rewrite Zlength_nil, !Zlength_correct in *; omega. }
    rewrite Zlength_cons in *; simpl; rewrite IHl1; [|omega].
    rewrite sublist_S_cons with (i0 := Z.succ _); [|rewrite Zlength_correct; omega].
    unfold Z.succ; rewrite !Z.add_simpl_r.
    if_tac; auto.
Qed.

Lemma make_shares_out : forall b lgood lasts shs (Hb : ~In b lasts)
  (Hlen1 : Zlength lgood = Zlength shs) (Hlen2 : Zlength lasts = Zlength shs),
  make_shares shs (combine lgood lasts) b = map snd (filter fst (combine lgood shs)).
Proof.
  induction lgood; auto; intros.
  destruct lasts; simpl.
  { symmetry in Hlen2; apply Zlength_nil_inv in Hlen2; subst.
    apply Zlength_nil_inv in Hlen1; discriminate. }
  destruct shs; simpl.
  { apply Zlength_nil_inv in Hlen1; discriminate. }
  destruct (z =? b) eqn: Heq; [rewrite Z.eqb_eq in Heq; subst; contradiction Hb; simpl; auto|].
  rewrite !Zlength_cons in *; rewrite IHlgood; try omega; simpl in *; [|tauto].
  destruct a; auto.
Qed.

Lemma make_shares_ext : forall i d l l' lgood shs (Hlen : Zlength l = Zlength l')
  (Hi : forall j, 0 <= j < Zlength l -> Znth j l d = i <-> Znth j l' d = i),
  make_shares shs (combine lgood l) i = make_shares shs (combine lgood l') i.
Proof.
  induction l; destruct l'; simpl; intros; rewrite ?Zlength_cons, ?Zlength_nil in *; auto;
    try (rewrite Zlength_correct in *; omega).
  exploit (Hi 0); [rewrite Zlength_correct; omega|].
  rewrite !Znth_0_cons; intro Hiff.
  destruct lgood; auto; simpl.
  rewrite (IHl l'); try omega.
  destruct (negb b); auto.
  destruct (a =? i) eqn: Ha, (z =? i) eqn: Hz; auto; rewrite ?Z.eqb_eq, Z.eqb_neq in *; tauto.
  { intros; exploit (Hi (j + 1)); [omega|].
    rewrite !Znth_pos_cons, !Z.add_simpl_r; auto; omega. }
Qed.

Lemma make_shares_add : forall i i' d lasts lgood j shs (Hj : 0 <= j < Zlength lasts)
  (Hi : Znth j lasts d = i) (Hgood : Znth j lgood false = true) (Hi' : i' <> i)
  (Hlen : Zlength shs >= Zlength lasts),
  exists shs1 shs2, make_shares shs (combine lgood lasts) i = shs1 ++ shs2 /\
    make_shares shs (combine lgood (upd_Znth j lasts i')) i = shs1 ++ Znth j shs Tsh :: shs2.
Proof.
  induction lasts; destruct shs; simpl; intros; rewrite ?Zlength_cons, ?Zlength_nil in *; try omega.
  destruct lgood; [rewrite Znth_nil in Hgood; discriminate|].
  destruct (eq_dec j 0).
  - subst; rewrite Znth_0_cons in Hi', IHlasts; rewrite !Znth_0_cons; simpl.
    rewrite Znth_0_cons in Hgood; subst; simpl.
    rewrite Z.eqb_refl, Zlength_cons, sublist_1_cons, sublist_same; auto; try omega; simpl.
    rewrite <- Z.eqb_neq in Hi'; rewrite Hi'.
    eexists [], _; simpl; split; eauto.
  - rewrite Znth_pos_cons in Hi; [|omega].
    rewrite Znth_pos_cons in Hgood; [|omega].
    rewrite Znth_pos_cons; [|omega].
    exploit (IHlasts lgood (j - 1) shs); auto; try omega.
    intros (shs1 & shs2 & Heq1 & Heq2).
    rewrite upd_Znth_cons; [simpl | omega].
    exists (if (negb b || (a =? i))%bool then shs1 else t :: shs1), shs2; rewrite Heq1, Heq2;
      if_tac; auto.
Qed.

Lemma make_shares_In : forall i lasts lgood x shs (Hx : 0 <= x < Zlength lasts)
  (Hi : Znth x lasts 0 <> i) (Hgood : Znth x lgood false = true)
  (Hlen : Zlength shs >= Zlength lasts),
  In (Znth x shs Tsh) (make_shares shs (combine lgood lasts) i).
Proof.
  induction lasts; simpl; intros.
  - rewrite Zlength_nil in *; omega.
  - destruct shs; rewrite !Zlength_cons in *; [rewrite Zlength_nil, Zlength_correct in *; omega|].
    destruct lgood; [rewrite Znth_nil in Hgood; discriminate|].
    destruct (eq_dec x 0); simpl.
    + subst; rewrite Znth_0_cons in Hi; rewrite Znth_0_cons in Hgood; rewrite Znth_0_cons.
      rewrite <- Z.eqb_neq in Hi; rewrite Hi; subst; simpl; auto.
    + rewrite Znth_pos_cons in Hi; [|omega].
      rewrite Znth_pos_cons in Hgood; [|omega].
      rewrite Znth_pos_cons; [|omega].
      exploit (IHlasts lgood (x - 1) shs); eauto; try omega.
      if_tac; simpl; auto.
Qed.

Lemma make_shares_sub : forall i lasts shs sh0 sh1 sh2 (Hlen : Zlength shs >= Zlength lasts)
  (Hsh1 : sepalg_list.list_join sh0 shs sh1) (Hsh2 : sepalg_list.list_join sh0 (make_shares shs lasts i) sh2),
  sepalg.join_sub sh2 sh1.
Proof.
  induction lasts; destruct shs; simpl; intros; rewrite ?Zlength_nil, ?Zlength_cons in *;
    try (rewrite Zlength_correct in *; omega).
  - inv Hsh1; inv Hsh2; apply sepalg.join_sub_refl.
  - inversion Hsh1 as [|????? Hj1 Hj2]; inv Hsh2.
    destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?); eexists; eauto.
  - inversion Hsh1 as [|????? Hj1 Hj2]; subst.
    destruct a.
    destruct (_ || _)%bool.
    + apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
      exploit IHlasts; eauto; [omega|].
      intro; eapply sepalg.join_sub_trans; eauto; eexists; eauto.
    + inversion Hsh2 as [|????? Hj1']; subst.
      pose proof (sepalg.join_eq Hj1 Hj1'); subst.
      eapply IHlasts; eauto; omega.
Qed.

Lemma combine_nil : forall {A B} (l : list A), combine l (@nil B) = [].
Proof.
  destruct l; auto.
Qed.

Lemma make_shares_join : forall i d lasts lgood shs sh0 j sh1 sh2
  (Hlen : Zlength shs >= Zlength lasts)
  (Hsh1 : sepalg_list.list_join sh0 shs sh1)
  (Hsh2 : sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts) i) sh2)
  (Hin : 0 <= j < Zlength shs) (Hj : Znth j lasts d = i),
  exists sh', sepalg.join sh2 (Znth j shs Tsh) sh'.
Proof.
  induction lasts; destruct shs; simpl; intros; rewrite ?Zlength_nil, ?Zlength_cons in *;
    try (rewrite Zlength_correct in *; omega); try omega.
  { rewrite Znth_nil in Hj.
    rewrite combine_nil in Hsh2; inv Hsh2.
    exploit (Znth_In j (t :: shs) Tsh); [rewrite Zlength_cons; auto|].
    intro Hin'; apply in_split in Hin'.
    destruct Hin' as (? & ? & Heq); rewrite Heq in Hsh1.
    apply list_join_comm in Hsh1; inv Hsh1; eauto. }
  destruct (eq_dec j 0).
  - subst j; rewrite Znth_0_cons in Hj; rewrite Znth_0_cons; subst.
    destruct lgood; simpl in Hsh2; [inv Hsh2; inv Hsh1; eauto|].
    rewrite Z.eqb_refl in Hsh2.
    inversion Hsh1 as [|????? Hj1 Hj2]; subst.
    apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
    exploit (make_shares_sub i (combine lgood lasts)); eauto.
    { rewrite Zlength_combine, Z.ge_le_iff, Z.min_le_iff; omega. }
    { destruct b; eauto. }
    intro; eapply sepalg.join_sub_joins_trans; eauto.
  - rewrite Znth_pos_cons in Hj; [|omega].
    rewrite Znth_pos_cons; [|omega].
    inversion Hsh1 as [|????? Hj1 Hj2]; subst.
    destruct lgood; simpl in Hsh2.
    { inv Hsh2.
      apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
      eapply (IHlasts []); eauto; try constructor; omega. }
    destruct (_ || _)%bool.
    + apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
      eapply IHlasts; eauto; omega.
    + inversion Hsh2 as [|????? Hj1']; subst.
      pose proof (sepalg.join_eq Hj1 Hj1'); subst.
      eapply IHlasts; eauto; omega.
Qed.

Lemma data_at_buffer_cohere : forall sh1 sh2 v1 v2 p, readable_share sh1 ->
  data_at sh1 tbuffer v1 p * data_at sh2 tbuffer v2 p |--
  data_at sh1 tbuffer v1 p * data_at sh2 tbuffer v1 p.
Proof.
  intros.
  repeat unfold_data_at 1%nat.
  rewrite !field_at_data_at'; simpl; entailer.
  apply data_at_value_cohere; auto.
Qed.

Lemma make_shares_add' : forall i i' d lasts lgood j shs (Hj : 0 <= j < Zlength lasts)
  (Hi : Znth j lasts d = i) (Hgood : Znth j lgood false = false)
  (Hlen : Zlength shs >= Zlength lasts),
  make_shares shs (combine lgood (upd_Znth j lasts i')) i = make_shares shs (combine lgood lasts) i.
Proof.
  induction lasts; destruct shs; simpl; intros; rewrite ?Zlength_cons, ?Zlength_nil in *; try omega.
  destruct lgood; auto; simpl.
  destruct (eq_dec j 0).
  - subst; rewrite Znth_0_cons in IHlasts; rewrite Znth_0_cons in Hgood; rewrite !Znth_0_cons; subst; simpl.
    rewrite Zlength_cons, sublist_1_cons, sublist_same; auto; omega.
  - rewrite Znth_pos_cons in Hi by omega.
    rewrite Znth_pos_cons in Hgood by omega.
    rewrite upd_Znth_cons by omega; simpl.
    rewrite IHlasts by (auto; omega); auto.
Qed.

Lemma make_shares_ext' : forall i d l l' lgood shs (Hlen : Zlength l = Zlength l')
  (Hi : forall j, 0 <= j < Zlength l -> Znth j lgood false = true -> Znth j l d = i <-> Znth j l' d = i),
  make_shares shs (combine lgood l) i = make_shares shs (combine lgood l') i.
Proof.
  induction l; destruct l'; simpl; intros; rewrite ?Zlength_cons, ?Zlength_nil in *; auto;
    try (rewrite Zlength_correct in *; omega).
  destruct lgood; auto; simpl.
  rewrite (IHl l'); try omega.
  destruct b; auto; simpl.
  exploit (Hi 0); [rewrite Zlength_correct; omega | apply Znth_0_cons|].
  rewrite !Znth_0_cons; intro Hiff.
  destruct (a =? i) eqn: Ha, (z =? i) eqn: Hz; auto; rewrite ?Z.eqb_eq, Z.eqb_neq in *; tauto.
  { intros; exploit (Hi (j + 1)); rewrite ?Znth_pos_cons, ?Z.add_simpl_r; auto; omega. }
Qed.

Lemma upd_write_shares : forall bufs b b0 lgood lasts shs sh0 (Hb : 0 <= b < B) (Hb0 : 0 <= b0 < B)
  (Hlasts : Forall (fun x : Z => 0 <= x < B) lasts) (Hshs : Zlength shs = N)
  (Hread : Forall readable_share shs) (Hsh0 : sepalg_list.list_join sh0 shs Tsh)
  (Hdiff : b <> b0) (Hout : ~ In b lasts) (Hout0 : ~ In b0 lasts) (Hlasts : Zlength lasts = N)
  (Hlgood : Zlength lgood = N) i (Hh' : 0 <= i < N) good (Hgood : good = Znth i lgood false)
  b' (Hb' : good = true -> -1 <= b' < B) sh (Hsh : sh = Znth i shs Tsh)
  shi (Hshi : sepalg_list.list_join sh0
         (map snd (filter fst (sublist (i + 1) N (combine lgood shs)))) shi)
  bsh (Hbsh : sepalg_list.list_join shi
    (map snd (if good then [(good, sh)] else [])) bsh)
  h' (Hh' : Zlength h' = i) lasts' (Hlasts' : lasts' = map (fun i =>
    if eq_dec (Znth i h' Vundef) Empty then b0 else Znth i lasts 0) (upto 3))
  lasts'' (Hlasts'' : lasts'' = map (fun i =>
    if eq_dec (Znth i (h' ++ [vint b']) Vundef) Empty then b0 else Znth i lasts 0) (upto 3)) vb,
(if good then EX v : _, data_at sh tbuffer (Vint v)
     (Znth (if eq_dec b' (-1) then Znth i lasts 0 else b0) bufs Vundef)
 else emp) *
(data_at shi tbuffer (Vint vb) (Znth b bufs Vundef) *
 fold_right sepcon emp (upd_Znth b (map (fun a => EX sh2 : share,
   !! (if eq_dec a b0 then sepalg_list.list_join sh0
         (make_shares shs (combine lgood (sublist 0 i lasts')) a) sh2
       else if eq_dec a b then sepalg_list.list_join sh0
         (map snd (filter fst (sublist i N (combine lgood shs)))) sh2
       else sepalg_list.list_join sh0
         (make_shares shs (combine lgood lasts') a) sh2) &&
      (EX v : _, data_at sh2 tbuffer (Vint v) (Znth a bufs Vundef))) (upto 5)) emp))
|-- fold_right sepcon emp (map (fun a => EX sh2 : share,
   !! (if eq_dec a b0 then sepalg_list.list_join sh0
        (make_shares shs (combine lgood (sublist 0 (i + 1) lasts'')) a) sh2
      else if eq_dec a b then sepalg_list.list_join sh0
        (map snd (filter fst (sublist (i + 1) N (combine lgood shs)))) sh2
      else sepalg_list.list_join sh0
        (make_shares shs (combine lgood lasts'') a) sh2) &&
    (EX v : _, data_at sh2 tbuffer (Vint v) (Znth a bufs Vundef))) (upto 5)).
Proof.
  intros.
  assert (readable_share sh).
  { subst sh; apply Forall_Znth; auto; omega. }
  set (lasti := Znth i lasts 0).
  exploit (Znth_In i lasts 0); [omega | intro Hini].
  assert (lasti <> b) as Hneq.
  { intro; match goal with H : ~In b lasts |- _ => contradiction H end; subst b lasti; auto. }
  assert (lasti <> b0) as Hneq0.
  { intro; match goal with H : ~In b0 lasts |- _ => contradiction H end; subst b0 lasti; auto. }
  match goal with |- _ * (_ * fold_right sepcon emp (upd_Znth b ?l _)) |-- _ =>
    set (l0 := upd_Znth b l (EX v : _, @data_at CompSpecs shi tbuffer (Vint v) (Znth b bufs Vundef))) end.
  assert (Zlength l0 = B).
  { subst l0; rewrite upd_Znth_Zlength; rewrite Zlength_map, Zlength_upto; auto. }
  assert (0 <= lasti < B).
  { apply Forall_Znth; auto; omega. }
  apply derives_trans with (fold_right sepcon emp (
    if eq_dec b' (-1) then upd_Znth lasti l0
            (EX sh1 : share, !!(exists sh', sepalg_list.list_join sh0 (make_shares shs
             (combine lgood lasts') lasti) sh' /\ if good then sepalg.join sh' sh sh1 else sh1 = sh') &&
            (EX v1 : _, @data_at CompSpecs sh1 tbuffer (Vint v1) (Znth lasti bufs Vundef)))
          else upd_Znth b0 l0 (EX sh1 : share, !!(exists sh', sepalg_list.list_join sh0 (make_shares shs
            (combine lgood (sublist 0 i lasts')) b0) sh' /\ if good then sepalg.join sh' sh sh1 else sh1 = sh') &&
            (EX v1 : _, @data_at CompSpecs sh1 tbuffer (Vint v1) (Znth b0 bufs Vundef))))).
  { eapply derives_trans; [apply sepcon_derives; [apply derives_refl | apply sepcon_derives, derives_refl]|].
    { instantiate (1 := EX v : _, data_at shi tbuffer (Vint v) (Znth b bufs Vundef)).
      Exists vb; auto. }
    rewrite replace_nth_sepcon.
    destruct (eq_dec b' (-1)).
    - rewrite extract_nth_sepcon with (i := lasti) by (subst l0; omega).
      erewrite upd_Znth_diff', Znth_map, Znth_upto; rewrite ?Z2Nat.id; auto; simpl; try (unfold B, N in *; omega).
      destruct (eq_dec lasti b0); [contradiction Hneq0; auto|].
      destruct (eq_dec lasti b); [contradiction Hneq; auto|].
      Intros ish v2.
      assert (exists sh', sepalg.join ish sh sh') as (sh' & ?).
      { subst sh; eapply make_shares_join; eauto.
        + subst lasts'; setoid_rewrite Hshs; rewrite Zlength_map, Zlength_upto, ?Z2Nat.id; unfold N; simpl; omega.
        + setoid_rewrite Hshs; auto.
        + subst lasts'; rewrite Znth_map', Znth_upto by (unfold N in *; simpl; omega).
          rewrite Znth_overflow; auto; omega. }
      rewrite (extract_nth_sepcon (upd_Znth lasti l0 (EX sh : share, _)) lasti) by (rewrite upd_Znth_Zlength; omega).
      rewrite upd_Znth_twice, upd_Znth_same by omega.
      rewrite <- sepcon_assoc; apply sepcon_derives; auto.
      if_tac.
      + Intros v1.
        eapply derives_trans; [apply data_at_buffer_cohere; auto|].
        erewrite data_at_share_join by eauto.
        Exists sh' v1; entailer!; eauto.
      + Exists ish v2; entailer!; eauto.
    - Intros.
      rewrite extract_nth_sepcon with (i := b0) by (subst l0; omega).
      erewrite upd_Znth_diff, Znth_map, Znth_upto; rewrite ?Z2Nat.id; auto; try (unfold B, N in *; simpl; omega).
      destruct (eq_dec b0 b0); [|contradiction].
      Intros ish v2.
      assert (exists sh', sepalg.join ish sh sh') as (sh' & ?).
      { subst sh; eapply make_shares_join; eauto.
        + subst lasts'; setoid_rewrite Hshs; rewrite Zlength_sublist; rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; unfold N in *; simpl; omega.
        + setoid_rewrite Hshs; auto.
        + rewrite Znth_overflow; auto.
          subst lasts'; rewrite Zlength_sublist; rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; unfold N in *; simpl; omega. }
      rewrite (extract_nth_sepcon (upd_Znth b0 l0 (EX sh : share, _)) b0) by (rewrite upd_Znth_Zlength; omega).
      rewrite upd_Znth_twice, upd_Znth_same by omega.
      rewrite <- sepcon_assoc; apply sepcon_derives; auto.
      if_tac.
      + Intros v1.
        eapply derives_trans; [apply data_at_buffer_cohere; auto|].
        erewrite data_at_share_join by eauto.
        Exists sh' v1; entailer!; eauto.
      + Exists ish v2; entailer!; eauto. }
  apply derives_refl'; f_equal.
  match goal with |- ?l = _ => assert (Zlength l = B) as Hlen end.
  { destruct (eq_dec b' (-1)); auto; rewrite upd_Znth_Zlength; auto; omega. }
  apply list_Znth_eq' with (d := FF).
  { rewrite Hlen, Zlength_map, Zlength_upto; auto. }
  rewrite Hlen; intros.
  assert (0 <= j <= B) by omega.
  erewrite Znth_map, Znth_upto by auto.
  assert (forall j, j <> Zlength h' \/ vint b' <> Empty -> (if eq_dec (Znth j h' Vundef) Empty then b0 else Znth j lasts 0) =
    if eq_dec (Znth j (h' ++ [vint b']) Vundef) Empty then b0 else Znth j lasts 0) as Heq.
  { intros ? Hcase.
    destruct (zlt j0 (Zlength h')); [rewrite app_Znth1; auto|].
    rewrite Znth_overflow, app_Znth2 by auto.
    destruct (eq_dec j0 (Zlength h')).
    - if_tac; [discriminate|].
      destruct (eq_dec (Znth _ _ _) _); auto.
      subst; rewrite Zminus_diag, Znth_0_cons in e0; destruct Hcase; try contradiction.
    - rewrite (Znth_overflow _ [_]); auto.
      rewrite Zlength_cons, Zlength_nil; omega. }
  destruct (eq_dec j lasti); [|destruct (eq_dec j b0)]; subst.
  - destruct (eq_dec b' (-1)).
    + rewrite upd_Znth_same by omega.
      destruct (eq_dec lasti b0); [contradiction|].
      destruct (eq_dec lasti b); [contradiction|].
      f_equal; extensionality; f_equal; f_equal.
      destruct (Znth _ lgood _) eqn: Hgood.
      * exploit (make_shares_add lasti b0 0 (map (fun i => if eq_dec (Znth i h' Vundef) Empty then b0
          else Znth i lasts 0) (upto (Z.to_nat N))) lgood (Zlength h') shs); auto.
        { erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto, ?Z2Nat.id; try omega.
          rewrite Znth_overflow by omega.
          destruct (eq_dec Vundef Empty); [discriminate | auto]. }
        { setoid_rewrite Hshs; rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega. }
        simpl; intros (shsa & shsb & Hshs1 & Hshs2).
        rewrite Hshs1.
        erewrite make_shares_ext, Hshs2.
        apply prop_ext; split.
        -- intros (? & Hj1 & Hj2).
           apply list_join_comm.
           apply sepalg.join_comm in Hj2; destruct (sepalg_list.list_join_assoc2 Hj1 Hj2) as (? & ? & ?).
           econstructor; eauto.
           apply list_join_comm; auto.
        -- intro Hj; apply list_join_comm in Hj.
           inversion Hj as [|????? Hj1 Hj2]; subst.
           apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
           do 2 eexists; eauto; apply list_join_comm; auto.
        -- rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto.
        -- rewrite Zlength_map, Zlength_upto; intros.
           rewrite Znth_map', Znth_upto by omega.
           destruct (zlt j (Zlength h')); [|destruct (eq_dec j (Zlength h'))].
           ++ rewrite app_Znth1, upd_Znth_diff; auto; try omega.
              erewrite Znth_map, Znth_upto; auto; [reflexivity | omega].
           ++ subst; rewrite Znth_app1, eq_dec_refl, upd_Znth_same; auto; reflexivity.
           ++ rewrite Znth_overflow, upd_Znth_diff; auto; [|rewrite Zlength_app, Zlength_cons, Zlength_nil; omega].
              erewrite Znth_map, Znth_upto; auto; [|omega].
              rewrite Znth_overflow with (al := h'); [reflexivity | omega].
      * erewrite make_shares_ext'.
        apply prop_ext; split; [intros [? []]; subst|]; eauto.
        { rewrite !Zlength_map; auto. }
        { rewrite Zlength_map; intros.
          erewrite !Znth_map with (b1 := 0), !Znth_upto by (auto; rewrite ?Zlength_upto in *; omega).
          rewrite Heq; [reflexivity|].
          left; intro; subst; destruct (Znth (Zlength h') lgood false); discriminate. }
    + subst l0; rewrite 2upd_Znth_diff; auto; try omega.
      erewrite Znth_map, Znth_upto; try assumption.
      destruct (eq_dec lasti b0); [contradiction|].
      destruct (eq_dec lasti b); [contradiction|].
      erewrite make_shares_ext'; eauto.
      rewrite Zlength_map, Zlength_upto; intros.
      erewrite Znth_map', Znth_map, !Znth_upto; auto; try omega.
      rewrite Heq; [reflexivity|].
      destruct (eq_dec j (Zlength h')); auto.
      subst; right; intros ?%Empty_inj; auto; apply repable_buf; auto.
  - assert (Zlength (sublist 0 (Zlength h') (map (fun i : Z => if eq_dec (Znth i h' Vundef) Empty then b0
      else Znth i lasts 0) (upto (Z.to_nat N)))) = Zlength h') as Hlenh.
    { rewrite Zlength_sublist; try omega.
      rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega. }
    assert (Zlength (sublist 0 (Zlength h') (map (fun i : Z => if eq_dec (Znth i (h' ++ [vint b']) Vundef) Empty
      then b0 else Znth i lasts 0) (upto (Z.to_nat N)))) = Zlength h') as Hlenh'.
    { rewrite Zlength_sublist; try omega.
      rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega. }
    simpl in *.
    destruct (eq_dec b' (-1)).
    + assert (EX sh : share, !! sepalg_list.list_join sh0 (make_shares shs (combine lgood (sublist 0 (Zlength h')
          (map (fun i : Z => if eq_dec (Znth i h' Vundef) Empty then b0 else Znth i lasts 0) (upto (Z.to_nat N))))) b0)
          sh && (EX v1 : _, data_at sh tbuffer (Vint v1) (Znth b0 bufs Vundef)) =
        EX sh : share, !! sepalg_list.list_join sh0 (make_shares shs (combine lgood (sublist 0 (Zlength h' + 1)
          (map (fun i : Z => if eq_dec (Znth i (h' ++ [vint b']) Vundef) Empty then b0 else Znth i lasts 0)
          (upto (Z.to_nat N))))) b0) sh && (EX v0 : _, data_at sh tbuffer (Vint v0) (Znth b0 bufs Vundef))).
      { erewrite sublist_split with (mid := Zlength h')(hi := Zlength h' + 1), sublist_len_1, Znth_map', Znth_upto;
          auto; rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; try omega.
        rewrite Znth_app1; auto.
        rewrite <- (app_nil_r (sublist 0 (Zlength h') _)).
        replace lgood with (sublist 0 (Zlength h') lgood ++ sublist (Zlength h') (Zlength lgood) lgood).
        assert (Zlength (sublist 0 (Zlength h') lgood) = Zlength h').
        { rewrite Zlength_sublist; omega. }
        rewrite !combine_app', combine_nil; try omega.
        subst; rewrite eq_dec_refl, app_nil_r, make_shares_app; simpl.
        replace (make_shares (sublist _ _ _) _ _) with (@nil share).
        erewrite app_nil_r, make_shares_ext; eauto; try omega.
        rewrite Hlenh; intros; erewrite !Znth_sublist, Znth_map', Znth_map, !Znth_upto; auto;
          rewrite ?Zlength_upto; simpl; try (unfold N in *; omega).
        rewrite app_Znth1; [reflexivity | omega].
        { destruct (sublist (Zlength h') (Zlength lgood) lgood); auto; simpl.
          rewrite Z.eqb_refl, orb_true_r, combine_nil; auto. }
        { rewrite !Zlength_combine, !Z.min_r; rewrite ?Zlength_cons, ?Zlength_nil; try omega.
          - setoid_rewrite Hshs; omega.
          - rewrite Zlength_sublist; omega. }
        { unfold N; simpl; omega. }
        { unfold N; simpl; omega. }
        { rewrite sublist_rejoin, sublist_same; auto; omega. } }
      destruct (eq_dec lasti (-1)); subst l0; [rewrite upd_Znth_diff | rewrite 2upd_Znth_diff]; auto; try omega.
      erewrite Znth_map, Znth_upto; auto; destruct (eq_dec b0 b0); [eauto | contradiction].
    + rewrite upd_Znth_same by omega.
      erewrite sublist_split with (mid := Zlength h')(hi := Zlength h' + 1), sublist_len_1, Znth_map', Znth_upto;
        auto; rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; simpl; try (unfold N in *; omega).
      rewrite Znth_app1; auto.
      rewrite <- (app_nil_r (sublist 0 (Zlength h') _)).
      set (good := Znth (Zlength h') lgood false).
      replace lgood with (sublist 0 (Zlength h') lgood ++ sublist (Zlength h') (Zlength lgood) lgood).
      assert (Zlength (sublist 0 (Zlength h') lgood) = Zlength h').
      { rewrite Zlength_sublist; omega. }
      rewrite !combine_app', combine_nil; try omega.
      replace (combine (sublist (Zlength h') _ _) _) with [(good,
        if eq_dec (vint b') Empty then b0 else Znth (Zlength h') lasts 0)]; simpl.
      rewrite app_nil_r, make_shares_app; simpl.
      destruct good eqn: Hgood; simpl.
      * destruct (eq_dec (vint b') Empty).
        { apply Empty_inj in e; [contradiction|].
          apply repable_buf; auto. }
        fold lasti; destruct (lasti =? b0) eqn: Heq'; [rewrite Z.eqb_eq in Heq'; contradiction|].
        rewrite hd_Znth, Znth_sublist; rewrite ?Hlenh'; try setoid_rewrite Hshs; rewrite ?Zlength_combine, ?Z.min_l; try omega.
        f_equal; extensionality; f_equal; f_equal.
        replace (Zlength (sublist _ _ lgood)) with (Zlength h').
        erewrite make_shares_ext.
        apply prop_ext; split.
        -- intros (? & Hj1 & Hj2).
           apply sepalg.join_comm in Hj2; destruct (sepalg_list.list_join_assoc2 Hj1 Hj2) as (? & ? & ?).
           apply list_join_comm; econstructor; eauto.
           erewrite Znth_indep; eauto.
           setoid_rewrite Hshs; auto.
        -- intro Hj; apply list_join_comm in Hj; inversion Hj as [|????? Hj1 Hj2]; subst.
           apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (? & ? & ?).
           do 2 eexists; eauto.
           erewrite Znth_indep; eauto.
           setoid_rewrite Hshs; auto.
        -- omega.
        -- rewrite Hlenh; intros; erewrite !Znth_sublist, Znth_map', Znth_map, !Znth_upto;
             rewrite ?Zlength_upto; simpl; try (unfold N in *; omega).
           rewrite app_Znth1; [reflexivity | omega].
      * f_equal; extensionality; f_equal; f_equal.
        erewrite app_nil_r, make_shares_ext'.
        apply prop_ext; split; [intros (? & ? & ?); subst|]; eauto.
        { omega. }
        { rewrite Hlenh; intros ??; erewrite !Znth_sublist, !Znth_map with (b1 := 0), !Znth_upto; rewrite ?Zlength_upto; try (unfold N in *; simpl; omega).
          rewrite Z.add_0_r; intro; rewrite Heq; [reflexivity|].
          left; intro; subst; destruct (Znth (Zlength h') lgood false); discriminate. }
      * rewrite Zlength_combine, Z.min_l, Zlength_cons, Zlength_nil by omega.
        setoid_rewrite Hshs; omega.
      * erewrite sublist_next by omega; simpl.
        rewrite combine_nil; subst good; auto.
      * rewrite sublist_rejoin, sublist_same by omega; auto.
  - transitivity (Znth j l0 FF).
    { destruct (eq_dec b' (-1)); rewrite upd_Znth_diff; auto; omega. }
    subst l0.
    destruct (eq_dec j b).
    + subst; rewrite upd_Znth_same; auto.
      apply mpred_ext.
      * Exists shi; entailer!.
      * Intros sh1.
        assert (sh1 = shi) by (eapply list_join_eq; eauto; apply HshP).
        subst; auto.
    + rewrite upd_Znth_diff' by auto.
      erewrite Znth_map, Znth_upto by auto.
      destruct (eq_dec j b0); [contradiction|].
      destruct (eq_dec j b); [contradiction|].
      simpl; erewrite make_shares_ext'; eauto.
      rewrite Zlength_map, Zlength_upto; intros.
      erewrite Znth_map', Znth_map, !Znth_upto; auto; try omega.
      destruct (zlt j0 (Zlength h')); [rewrite app_Znth1 by auto; reflexivity|].
      rewrite Znth_overflow, app_Znth2 by auto.
      destruct (eq_dec Vundef Empty); [discriminate|].
      destruct (eq_dec _ Empty); [|reflexivity].
      destruct (eq_dec j0 (Zlength h')); [|rewrite Znth_overflow in e; try discriminate].
      split; intro; subst; tauto.
      { rewrite Zlength_cons, Zlength_nil; omega. }
Qed.

Lemma body_finish_write : semax_body Vprog Gprog f_finish_write finish_write_spec.
Proof.
  start_function.
  rewrite sepcon_map; Intros.
  forward.
  forward.
  assert_PROP (Zlength (map (fun i => vint i) lasts) = N) by entailer!.
  rewrite Zlength_map in *.
  assert (Zlength (combine lgood lasts) = N).
  { rewrite Zlength_combine, Z.min_l; omega. }
  assert (Zlength (combine lgood shs) = N).
  { rewrite Zlength_combine, Z.min_l; omega. }
  rewrite <- seq_assoc.
  forward_for_simple_bound N (EX i : Z, PROP ( )
   LOCAL (temp _w (vint b); temp _last (vint b0); gvar _writing writing; gvar _last_given last_given;
          gvar _last_taken last_taken; gvar _comm comm)
   SEP (data_at Ews tint (vint b) writing; data_at Ews tint (vint b0) last_given;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        EX t' : list nat, EX h' : list val, !!(Zlength t' = i /\ Zlength h' = i) &&
          fold_right sepcon emp (map (fun r => comm_loc (Znth r lgood false) lsh (Znth r comms Vundef)
            (Znth r g Vundef) (Znth r g0 Vundef) (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh)
            gsh2 (Znth r h [] ++ if zlt r i then [(Znth r t' O, AE (Znth r h' Vundef) (vint b))] else []))
            (upto (Z.to_nat N))) *
          let lasts' := map (fun i => if eq_dec (Znth i h' Vundef) Empty then b0 else Znth i lasts 0)
                            (upto (Z.to_nat N)) in
            data_at Ews (tarray tint N) (map (fun i => vint i) lasts') last_taken *
            fold_right sepcon emp (map (fun r =>
              ghost_var gsh1 (vint (if zlt r i then b else b0)) (Znth r g1 Vundef)) (upto (Z.to_nat N))) *
            fold_right sepcon emp (map (fun r =>
              ghost_var gsh1 (vint (Znth r lasts' (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N))) *
            fold_right sepcon emp (map (fun a => EX sh : share,
              !!(if eq_dec a b0 then sepalg_list.list_join sh0 (make_shares shs (combine lgood (sublist 0 i lasts')) a) sh
                 else if eq_dec a b then sepalg_list.list_join sh0 (map snd (filter fst (sublist i N (combine lgood shs)))) sh
                 else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts') a) sh) &&
              EX v : _, @data_at CompSpecs sh tbuffer (Vint v) (Znth a bufs Vundef)) (upto (Z.to_nat B))))).
  { unfold N; computable. }
  { unfold N; computable. }
  { Exists (@nil nat) (@nil val).
    replace (map (fun i => if eq_dec (Znth i [] Vundef) Empty then b0 else Znth i lasts 0) (upto (Z.to_nat N)))
      with lasts.
    entailer!.
    apply derives_refl'; f_equal; f_equal.
    { f_equal.
      apply map_ext_in.
      intros; rewrite In_upto in *.
      destruct (zlt a 0); [omega | rewrite app_nil_r; auto]. }
    apply map_ext; intro.
    f_equal; extensionality; f_equal; f_equal.
    rewrite sublist_nil, combine_nil; simpl.
    apply prop_ext.
    destruct (eq_dec a b0); [|destruct (eq_dec a b); [|reflexivity]].
    - split; intro Hx; [subst; constructor | inv Hx; auto].
    - subst; rewrite sublist_same, make_shares_out; unfold share in *; auto; try reflexivity; omega.
    - rewrite (list_Znth_eq 0 lasts) at 1.
      replace (length lasts) with (Z.to_nat N).
      apply map_ext.
      intro; rewrite Znth_nil; destruct (eq_dec Vundef Empty); auto; discriminate.
      { rewrite Zlength_correct in *; Omega0. } }
  - assert_PROP (Zlength comms = N) as Hcomms by entailer!.
    Intros t' h'.
    forward.
    { entailer!.
      apply Forall_Znth.
      { rewrite Hcomms; auto. }
      apply Forall_impl with (P := isptr); auto. }
    rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat N))) i);
      [|rewrite Zlength_map; auto].
    erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
    destruct (zlt i i); [omega | rewrite app_nil_r].
    rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat B))) b) by (rewrite Zlength_map, Zlength_upto; auto).
    erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, ?Z2Nat.id; auto; omega).
    Intros bsh.
    destruct (eq_dec b b0); [contradiction|].
    match goal with H : if eq_dec b b then _ else _ |- _ => rewrite eq_dec_refl in H end.
    match goal with H : sepalg_list.list_join _ (map _ _) _ |- _ =>
      rewrite sublist_split with (mid := i + 1), sublist_len_1 with (d := (false, Tsh)), filter_app,
        map_app, Znth_combine in H by omega; simpl in H;
        apply list_join_comm, sepalg_list.list_join_unapp in H;
        destruct H as (shi & Hshi & Hbsh) end.
    rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat N))) i); [|rewrite Zlength_map; auto].
    rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat N))) i); [|rewrite Zlength_map; auto].
    erewrite !Znth_map; rewrite ?Znth_upto; rewrite ?Znth_upto, ?Zlength_upto; rewrite ?Z2Nat.id; auto; try omega.
    rewrite Znth_overflow with (al := h'); [simpl | omega].
    destruct (zlt i i); [clear - l; omega|].
    set (gi := Znth i g Vundef).
    set (g0i := Znth i g0 Vundef).
    set (g1i := Znth i g1 Vundef).
    set (g2i := Znth i g2 Vundef).
    set (c := Znth i comms Vundef).
    set (sh := Znth i shs Tsh) in *.
    set (hi := Znth i h []).
    set (good := Znth i lgood false) in *.
    Intro vb.
    forward_call (AEX_SC_witness c b
      ((if good then data_at sh tbuffer (Vint vb) (Znth b bufs Vundef) else emp) *
      ghost_var gsh1 (vint b0) g1i * ghost_var gsh1 (vint (Znth i lasts 0)) g2i * ghost_hist lsh hi gi)
      (fun _ : Z => comm_inv good c bufs sh gi g0i g1i g2i gsh2) [0]
      (fun b' => !!(good = true -> b' = -1 \/ b' = b0) &&
        (if good then EX v : _, data_at sh tbuffer (Vint v)
          (Znth (if eq_dec b' (-1) then Znth i lasts 0 else b0) bufs Vundef) else emp) *
        ghost_var gsh1 (vint b) g1i *
        ghost_var gsh1 (vint (if eq_dec b' (-1) then b0 else Znth i lasts 0)) g2i *
        EX t : _, !!(newer hi t) && ghost_hist lsh (hi ++ [(t, AE (vint b') (vint b))]) gi)).
    { unfold comm_loc at 1; simpl; cancel.
      destruct good; simpl in *.
      + rewrite <- sepalg_list.list_join_1 in Hbsh.
        rewrite <- (data_at_share_join _ _ _ _ _ _ Hbsh); cancel.
      + inv Hbsh; subst Frame; simpl; cancel. }
    { lapply (repable_buf b); [|omega].
      split; auto.
      apply wand_view_shifts2.
      assert (lsh <> Share.bot) by (intro; subst; contradiction unreadable_bot).
      if_tac; unfold comm_inv; simpl.
      + view_shift_intro v0; view_shift_intro l.
        unfold comm_R at 1.
        view_shift_intro b1; view_shift_intro b2; view_shift_intro v'; view_shift_intros.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_ref _ _)).
        rewrite (sepcon_comm _ (ghost_hist _ _ _)).
        rewrite !sepcon_emp, <- !sepcon_assoc, 7sepcon_assoc.
        apply view_shift_assert with (PP := hist_incl hi l).
        { apply sepcon_derives_prop, hist_ref_incl; auto. }
        intros ?%hist_incl_lt.
        etransitivity; [apply view_shift_sepcon1, hist_add'; auto|].
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh2 _ g1i)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh1 _ g1i)).
        erewrite <- !sepcon_assoc, ghost_var_share_join' by eauto.
        view_shift_intros.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1,
          ghost_var_update with (v' := vint b)|].
        erewrite <- ghost_var_share_join by eauto.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh2 _ g2i)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh1 _ g2i)).
        erewrite <- !sepcon_assoc, ghost_var_share_join' by eauto.
        view_shift_intros.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1,
          ghost_var_update with (v' := vint (if eq_dec v0 (-1) then b0 else Znth i lasts 0))|].
        erewrite <- ghost_var_share_join by eauto.
        apply derives_view_shift; Exists Tsh v0.
        rewrite sepcon_andp_prop'; apply andp_right.
        { entailer!.
          apply repable_buf; auto. }
        cancel.
        rewrite <- wand_sepcon_adjoint.
        Exists (length l); cancel.
        Exists b; entailer!.
        rewrite <- exp_sepcon1, <- exp_sepcon2.
        Exists (l ++ [AE (vint v0) (vint b)]); unfold comm_R.
        rewrite !rev_app_distr; unfold last_write in *; simpl;
          rewrite last_two_reads_cons, prev_taken_cons.
        destruct (eq_dec (vint b) Empty).
        { apply Empty_inj in e; auto; subst; omega. }
        destruct (eq_dec b (-1)); [omega|].
        assert (Forall (fun a => match a with AE v1 v2 => exists r w,
          v1 = vint r /\ v2 = vint w /\ -1 <= r < B /\ -1 <= w < B end)
          (l ++ [AE (vint v0) (vint b)])).
        { rewrite Forall_app; repeat constructor; auto.
          exists v0, b; repeat (split; auto; try omega). }
        assert (apply_hist (vint 0) (l ++ [AE (vint v0) (vint b)]) = Some (vint b)).
        { rewrite apply_hist_app; replace (apply_hist _ _) with (Some (vint v0)); simpl.
          apply eq_dec_refl. }
        match goal with H : _ = prev_taken _ |- _ =>
          erewrite take_read in H by (rewrite rev_involutive; eauto) end.
        match goal with H : last_two_reads _ = _ |- _ => rewrite H in * end.
        if_tac; Intro v; Exists b1 b2 v vb.
        * subst; match goal with H : vint _ = _ |- _ => rewrite eq_dec_refl in H end.
          exploit (repr_inj_signed b2 (Znth (Zlength t') lasts 0)); auto.
          { apply Forall_Znth; [omega|].
            eapply Forall_impl; [|eauto]; simpl; intros; apply repable_buf; omega. }
          { simpl in *; congruence. }
          intro; rewrite !sepcon_andp_prop'; apply andp_right.
          { entailer!. }
          erewrite find_write_read by (rewrite ?rev_involutive; eauto; discriminate); simpl.
          replace (fst _) with (vint b0).
          rewrite (sepcon_comm _ (ghost_ref _ _)), !sepcon_assoc; apply sepcon_derives; auto; cancel.
          apply andp_right; [apply prop_right; auto | subst; cancel].
        * destruct (eq_dec (vint v0) Empty); [apply Empty_inj in e; auto; contradiction|].
          exploit (write_val (rev l)); [rewrite rev_involutive; eauto|].
          intros [|]; [contradiction|].
          exploit (repr_inj_signed v0 b0); auto.
          { apply repable_buf; omega. }
          { congruence. }
          exploit (repr_inj_signed (Znth (Zlength t') lasts 0) b1); auto.
          { apply Forall_Znth; [omega|].
            eapply Forall_impl; [|eauto]; simpl; intros; apply repable_buf; omega. }
          { simpl in *; congruence. }
          entailer!.
          rewrite sepcon_comm; apply derives_refl'; f_equal; f_equal.
          unfold last_two_reads in *.
          destruct (find_read _ _); match goal with H : (_, _) = (_, _) |- _ => inv H; auto end.
      + view_shift_intro v0; view_shift_intro l.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_ref _ _)).
        rewrite (sepcon_comm _ (ghost_hist _ _ _)).
        rewrite !sepcon_emp, <- !sepcon_assoc, 6sepcon_assoc.
        apply view_shift_assert with (PP := hist_incl hi l).
        { apply sepcon_derives_prop, hist_ref_incl; auto. }
        intros ?%hist_incl_lt.
        etransitivity; [apply view_shift_sepcon1, hist_add'; auto|].
        view_shift_intro b0'; view_shift_intro b1'; view_shift_intro b2'.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh2 _ g1i)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh1 _ g1i)).
        erewrite <- !sepcon_assoc, ghost_var_share_join' by eauto.
        view_shift_intros.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1,
          ghost_var_update with (v' := vint b)|].
        erewrite <- ghost_var_share_join by eauto.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh2 _ g2i)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var gsh1 _ g2i)).
        erewrite <- !sepcon_assoc, ghost_var_share_join' by eauto.
        view_shift_intros.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1,
          ghost_var_update with (v' := vint (if eq_dec (Int.signed (Int.repr v0)) (-1) then b0
          else Znth i lasts 0))|].
        erewrite <- ghost_var_share_join by eauto.
        apply derives_view_shift.
        Exists Tsh (Int.signed (Int.repr v0)); rewrite Int.repr_signed; entailer!.
        { apply Int.signed_range. }
        rewrite <- wand_sepcon_adjoint.
        Exists (length l) b (l ++ [AE (vint v0) (vint b)])
          (vint (if eq_dec (Int.signed (Int.repr v0)) (-1) then b0 else Znth (Zlength t') lasts 0))
          (vint b) b0'; entailer!.
        { discriminate. }
        rewrite sepcon_comm; auto. }
    Intros b' t.
    gather_SEP 0 4 8; replace_SEP 0 (fold_right sepcon emp (map (fun r =>
      comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
        (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 (Znth r h [] ++
        (if zlt r (i + 1) then [(Znth r (t' ++ [t]) 0%nat, AE (Znth r (h' ++ [vint b']) Vundef) (vint b))] else [])))
      (upto (Z.to_nat N)))).
    { go_lower.
      rewrite <- sepcon_assoc, replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength;
        rewrite !Zlength_map, Zlength_upto; auto.
      intros j ?; destruct (eq_dec j i).
      + subst; rewrite upd_Znth_same by (rewrite Zlength_map, Zlength_upto; auto).
        rewrite Znth_map with (d' := N), Znth_upto by (auto; omega).
        destruct (zlt (Zlength t') (Zlength t' + 1)); [|omega].
        rewrite !app_Znth2 by omega.
        subst hi c gi g0i g1i g2i good sh.
        rewrite Zminus_diag; replace (Zlength t') with (Zlength h'); rewrite Zminus_diag, !Znth_0_cons; auto.
      + rewrite upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto; auto).
        rewrite !Znth_map with (d' := N), !Znth_upto by (auto; omega).
        if_tac; if_tac; auto; try omega.
        rewrite !app_Znth1; auto; omega. }
    gather_SEP 2 8; replace_SEP 0 (fold_right sepcon emp (map (fun r =>
      ghost_var gsh1 (vint (if zlt r (i + 1) then b else b0)) (Znth r g1 Vundef)) (upto (Z.to_nat N)))).
    { go_lowerx.
      rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat N))) i);
        [|rewrite Zlength_map, Zlength_upto; auto].
      erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto, ?Z2Nat.id; simpl; auto;
        try (unfold N in *; auto; omega).
      destruct (zlt i (i + 1)); [subst g1i; fast_cancel | omega].
      apply sepcon_list_derives; rewrite !upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.
      destruct (eq_dec i0 i); [subst; rewrite !upd_Znth_same by (rewrite ?Zlength_map; auto); auto|].
      rewrite !upd_Znth_diff' by (rewrite ?Zlength_map; auto).
      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      destruct (zlt i0 i), (zlt i0 (i + 1)); auto; omega. }
    gather_SEP 3 8; replace_SEP 0 (fold_right sepcon emp (map (fun r =>
      ghost_var gsh1 (vint (Znth r (map (fun i0 => if eq_dec (Znth i0 (h' ++ [vint b']) Vundef) Empty then b0
        else Znth i0 lasts 0) (upto (Z.to_nat N))) (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N)))).
    { go_lowerx.
      rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat N))) i);
        [|rewrite Zlength_map, Zlength_upto; auto].
      erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto, ?Z2Nat.id; simpl; auto;
        try (unfold N in *; auto; omega).
      erewrite Znth_map, Znth_upto by (auto; unfold N in *; simpl; omega).
      replace i with (Zlength h'); rewrite app_Znth2, Zminus_diag, Znth_0_cons; [fast_cancel | omega].
      apply sepcon_derives.
      { replace (Zlength h') with i; subst g2i; destruct (eq_dec b' (-1)), (eq_dec (vint b') Empty);
          auto; subst; [contradiction|].
        contradiction n0; apply Empty_inj; auto; apply repable_buf; auto. }
      apply sepcon_list_derives; rewrite !upd_Znth_Zlength; rewrite !Zlength_map;
        try (rewrite !Zlength_upto; simpl; unfold N in *; omega); intros.
      destruct (eq_dec i0 (Zlength h')); [subst; rewrite !upd_Znth_same by (rewrite ?Zlength_map; auto); auto|].
      rewrite !upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto; unfold N in *; simpl; auto; omega).
      erewrite !Znth_map; rewrite ?Znth_upto; rewrite ?Znth_upto; auto; rewrite Zlength_upto in *; try omega.
      destruct (zlt i0 (Zlength h')).
      + rewrite app_Znth1; auto.
      + rewrite Znth_overflow with (al := h'), Znth_overflow with (al := (h' ++ [vint b'])); auto.
        rewrite Zlength_app, Zlength_cons, Zlength_nil; omega. }
    focus_SEP 7.
    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx (data_at _ _ ?l last_taken :: ?R)))) _ _ =>
      forward_if (PROP () (LOCALx Q (SEPx (data_at Ews (tarray tint N)
        (upd_Znth i l (vint (if eq_dec (vint b') Empty then b0 else Znth i lasts 0))) last_taken :: R)))) end.
    + forward.
      match goal with H : Int.repr b' = _ |- _ => rewrite Int.neg_repr in H; apply repr_inj_signed in H end; subst;
        auto.
      destruct (eq_dec (- (1)) (-1)); [|absurd (-1 = -1); auto].
      apply ENTAIL_refl.
    + forward.
      destruct (eq_dec b' (-1)); [subst; contradiction|].
      erewrite upd_Znth_triv with (i0 := i).
      apply ENTAIL_refl.
      * rewrite !Zlength_map, Zlength_upto; auto.
      * rewrite !Znth_map', Znth_upto; [|simpl; unfold N in *; omega].
        rewrite Znth_overflow; [|omega].
        destruct (eq_dec Vundef Empty); [discriminate|].
        destruct (eq_dec (vint b') Empty); auto.
        contradiction n0; apply Empty_inj; auto.
    + intros.
      unfold exit_tycon, overridePost.
      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
      Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert.
      do 2 (apply andp_right; [apply prop_right; auto|]).
      Exists (t' ++ [t]) (h' ++ [vint b']).
      rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; entailer!.
      rewrite !sepcon_assoc; apply sepcon_derives.
      * apply derives_refl'; f_equal.
        erewrite upd_Znth_eq, !map_length, upto_length, !map_map;
          [|rewrite !Zlength_map, Zlength_upto; unfold N in *; auto].
        apply map_ext_in; intros; rewrite In_upto in *.
        replace (Zlength t') with (Zlength h').
        destruct (eq_dec a (Zlength h')).
        -- subst; rewrite app_Znth2, Zminus_diag, Znth_0_cons; auto; clear; omega.
        -- rewrite Znth_map', Znth_upto; [|omega].
           destruct (zlt a (Zlength t')); [rewrite app_Znth1 | rewrite Znth_overflow]; auto; try omega.
           rewrite Znth_overflow with (al := _ ++ _); auto.
           rewrite Zlength_app, Zlength_cons, Zlength_nil; omega.
      * fast_cancel.
        subst good sh; replace (Zlength t') with (Zlength h') in *; eapply upd_write_shares; eauto.
        intro; match goal with H : _ -> _ \/ _ |- _ => destruct H; subst; auto; omega end.
  - Intros t' h'.
    forward.
    forward.
    forward.
    Exists (map (fun i => if eq_dec (Znth i h' Vundef) Empty then b0 else Znth i lasts 0) (upto (Z.to_nat N)))
      (extendr (map (fun x : nat * val => let '(t, v) := x in (t, AE v (vint b))) (combine t' h')) h); entailer!.
    + repeat split.
      * rewrite Forall_map, Forall_forall; intros; simpl.
        destruct (eq_dec (Znth x h' Vundef) Empty); [omega|].
        rewrite In_upto, Z2Nat.id in *; unfold N; try omega.
        apply Forall_Znth; [omega | auto].
      * assert (Zlength h' = Zlength h) as Hlen by omega; assert (Zlength t' = Zlength h') as Hlen' by omega;
        clear - Hlen Hlen'; revert dependent h; revert dependent t'; induction h';
          destruct h, t'; rewrite ?Zlength_nil, ?Zlength_cons in *; simpl; intros; auto;
          try (rewrite Zlength_correct in *; omega).
        constructor; eauto.
        apply IHh'; omega.
      * rewrite in_map_iff; intros (i & ? & ?); subst.
        rewrite In_upto, Z2Nat.id in *; try (unfold N; omega).
        destruct (eq_dec (Znth i h' Vundef) Empty); [absurd (b0 = b0); auto|].
        match goal with H : ~In _ lasts |- _ => contradiction H; apply Znth_In; omega end.
    + rewrite sepcon_map, <- !sepcon_assoc.
      apply derives_refl'; f_equal; f_equal; [f_equal|].
      { erewrite map_ext_in; eauto; intros; simpl.
        rewrite In_upto in *.
        destruct (zlt a N); [|unfold N in *; simpl in *; omega].
        erewrite Znth_extendr_in, Znth_map', Znth_combine; eauto;
          rewrite ?Zlength_map, ?Zlength_combine, ?Z.min_l; omega. }
      apply map_ext; intro.
      f_equal; extensionality; f_equal; f_equal; apply prop_ext.
      destruct (eq_dec a b).
      * destruct (eq_dec a b0); [absurd (b = b0); subst; auto|].
        split; intro Hx; [inv Hx; auto | subst; constructor].
      * destruct (eq_dec a b0); reflexivity.
Qed.
