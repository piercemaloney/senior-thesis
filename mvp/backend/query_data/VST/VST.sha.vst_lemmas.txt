

Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Export sha.general_lemmas.



Definition data_block {cs: compspecs} (sh: share) (contents: list byte) :=

  @data_at cs sh (tarray tuchar (Zlength contents)) (map Vubyte contents).



Lemma data_block_local_facts:

 forall {cs: compspecs} sh f data,

  data_block sh f data |--

   prop (field_compatible (tarray tuchar (Zlength f)) [] data).

Proof.

intros. unfold data_block, array_at.

simpl.

entailer!.

Qed.

Hint Resolve @data_block_local_facts : saturate_local.



Lemma data_block_valid_pointer {cs: compspecs} sh l p: sepalg.nonidentity sh -> Zlength l > 0 ->

      data_block sh l p |-- valid_pointer p.

Proof. unfold data_block. simpl; intros.

  apply data_at_valid_ptr; auto; simpl.

  rewrite Z.max_r, Z.mul_1_l; omega.

Qed.



Lemma split2_data_block:

  forall  {cs: compspecs}  n sh data d,

  (0 <= n <= Zlength data)%Z ->

  data_block sh data d =

  (data_block sh (sublist 0 n data) d *

   data_block sh (sublist n (Zlength data) data)

   (field_address0 (tarray tuchar (Zlength data)) [ArraySubsc n] d))%logic.

Proof.

  intros.

  unfold data_block. simpl. normalize.

  rewrite <- !sublist_map.

  unfold tarray.

  rewrite split2_data_at_Tarray_tuchar with (n1:=n) by (autorewrite with sublist; auto).

  autorewrite with sublist.

  reflexivity.

Qed.



Lemma split3_data_block:

  forall  {cs: compspecs} lo hi sh data d,

  0 <= lo <= hi ->

  hi <= Zlength data  ->

  data_block sh data d =

  (data_block sh (sublist 0 lo data) d *

   data_block sh (sublist lo hi data)

   (field_address0 (tarray tuchar (Zlength data)) [ArraySubsc lo] d) *

   data_block sh (sublist hi (Zlength data) data)

   (field_address0 (tarray tuchar (Zlength data)) [ArraySubsc hi] d))%logic.

Proof.

  intros.

  unfold data_block. 

  rewrite <- !sublist_map.

  unfold tarray.

  rewrite split3_data_at_Tarray_tuchar with (n1:=lo)(n2:=hi) by (autorewrite with sublist; auto).

  autorewrite with sublist.

  reflexivity.

Qed.



Lemma force_lengthn_long {A}: forall n (l:list A) d, (n <= length l)%nat -> force_lengthn n l d = firstn n l.

Proof. induction n; simpl; intros. trivial.

  destruct l; simpl in H. omega.

  rewrite IHn; trivial. omega.

Qed.



Lemma skipn_force_lengthn_app {A} n (l m:list A) a:

        skipn n (force_lengthn n l a ++ m) = m.

  intros. rewrite skipn_app1.

  specialize (skipn_exact_length (force_lengthn n l a)).

           rewrite force_lengthn_length_n. intros X; rewrite X; trivial.

  rewrite force_lengthn_length_n; omega.

Qed.



Lemma data_at_triv {cs} sh t v v': v=v' -> @data_at cs sh t v |-- @data_at cs sh t v'.

Proof. intros; subst. auto. Qed.



Lemma sizeof_Tarray {cs: composite_env} k: Z.max 0 k = k -> sizeof (Tarray tuchar k noattr) = k.

Proof. intros K; simpl; rewrite K. destruct k; trivial. Qed.



Lemma sepcon_fold: forall Frame P rho,

Frame = cons `(P) nil ->

P |-- fold_right

      (fun (P Q : environ -> mpred) (rho0 : environ) => P rho0 * Q rho0)

      `(emp) Frame rho.

Proof. intros. subst. simpl. entailer. Qed.



Lemma nth_mapVint: forall i (l:list Z) (Hi: (0 <= i < length l)%nat),

  exists n, nth i (map Vint (map Int.repr l)) Vundef = Vint n.

Proof. intros i.

  induction i; simpl; intros.

    destruct l; simpl in *. omega. eexists; reflexivity.

    destruct l; simpl in *. omega.

      destruct (IHi l). omega. rewrite H. eexists; reflexivity.

Qed.



Lemma nth_mapVint' {z}: forall i (l:list Z)

  (Hi: (0 <= i < length l)%nat),

  nth i (map Vint (map Int.repr l)) Vundef =

  Vint (Int.repr (nth i l z)).

Proof. intros i.

  induction i; simpl; intros.

    destruct l; simpl in *. omega. trivial.

    destruct l; simpl in *. omega.

      rewrite (IHi l). trivial. omega.

Qed.



Lemma nth_mapVintZ: forall i (l:list Z) (Hi: 0 <= i < Zlength l),

  exists n, nth (Z.to_nat i) (map Vint (map Int.repr l)) Vundef = Vint n.

Proof. intros.

  eapply nth_mapVint. rewrite Zlength_correct in Hi.

  destruct Hi; split.   omega.

unfold Z.of_nat in H0. unfold Z.to_nat.

destruct l; simpl in *. omega.

destruct i; try omega.

rewrite <- SuccNat2Pos.id_succ.

apply Pos2Nat.inj_lt.

apply H0.

Qed.



Lemma isptrD v: isptr v -> exists b ofs, v = Vptr b ofs.

Proof. intros. destruct v; try contradiction. exists b, i; trivial. Qed.



Ltac myframe_SEP'' L :=  

 grab_indexes_SEP L;

 match goal with

 | |- @semax _ _ (PROPx _ (LOCALx ?Q (SEPx ?R))) _ _ =>

  rewrite <- (firstn_skipn (length L) R);

  rewrite <- (firstn_skipn (length Q) Q);

    simpl length; unfold firstn, skipn;

    eapply (semax_frame_PQR nil);

      [ unfold closed_wrt_modvars;  auto 50 with closed

     | ]

 | |- (PROPx _ (LOCALx _ (SEPx ?R))) |-- _ =>

  rewrite <- (firstn_skipn (length L) R);

    simpl length; unfold firstn, skipn;

    apply derives_frame_PQR

end.

