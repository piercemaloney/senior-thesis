Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VST.progs.evenodd.

Local Open Scope logic.



Inductive repr : Z -> val -> Prop :=

| mk_repr : forall z, z >= 0 -> repr z (Vint (Int.repr z)).



Lemma repr0_not_odd z n :

  repr z (Vint n) -> Int.eq n (Int.repr 0) = true -> Z.odd z = false.

Proof.

inversion 1; subst; intros A.

symmetry in A; apply binop_lemmas.int_eq_true in A.

rewrite A in H; inv H.

rewrite Int.Z_mod_modulus_eq, Zmod_divides in H0.

destruct H0 as [c H0]; rewrite H0, Z.odd_mul; auto.

unfold Int.modulus; simpl; intro Contra; inv Contra.

Qed.



Lemma repr0_even z n :

  repr z (Vint n) -> Int.eq n (Int.repr 0) = true -> Z.even z = true.

Proof.

inversion 1; subst; intros A.

symmetry in A; apply binop_lemmas.int_eq_true in A.

rewrite A in H; inv H.

rewrite Int.Z_mod_modulus_eq, Zmod_divides in H0.

destruct H0 as [c H0]; rewrite H0, Z.even_mul; auto.

unfold Int.modulus; simpl; intro Contra; inv Contra.

Qed.



Lemma repr_eq0_not0 z :

  Int.eq (Int.repr z) (Int.repr 0) = false -> z <> 0.

Proof.

intros H; generalize (Int.eq_spec (Int.repr z) (Int.repr 0)); rewrite H.

intros H2 H3; rewrite H3 in H2; apply H2; auto.

Qed.



Definition odd_spec :=

 DECLARE _odd

  WITH sh : share, z : Z, v : val

  PRE [ _n OF tuint] PROP(repr z v) LOCAL (`(eq v) (eval_id _n)) SEP ()

  POST [ tint ] local (`(eq (Vint (if Z.odd z then Int.one else Int.zero))) retval).



Definition even_spec :=

 DECLARE _even

  WITH z : Z, v : val

  PRE [ _n OF tuint] PROP(repr z v) LOCAL (`(eq v) (eval_id _n)) SEP ()

  POST [ tint ] local (`(eq (Vint (if Z.even z then Int.one else Int.zero))) retval).



Definition main_spec :=

 DECLARE _main

  WITH z : Z, v : val

  PRE [ ] PROP(repr 42 v) LOCAL () SEP ()

  POST [ tint ] local (`(eq (Vint (if Z.even 42 then Int.one else Int.zero))) retval).



Definition Vprog : varspecs := nil.



Definition Gprog : funspecs :=

     ltac:(with_library prog [ odd_spec; even_spec; main_spec]).



Lemma body_odd : semax_body Vprog Gprog f_odd odd_spec.

Proof.

start_function.

name n _n.

forward_if (PROP (repr z v /\ z > 0) LOCAL (`(eq v) (eval_id _n)) SEP ()).

* forward; eapply repr0_not_odd in H0; eauto; rewrite H0; entailer.

* forward; entailer; inv H.

  assert (z <> 0) by (apply repr_eq0_not0; auto); entailer.

* forward_call (z-1,Vint (Int.sub (Int.repr z) (Int.repr 1))).

  entailer; inversion H; subst z0; rewrite <-H5 in H2; inversion H2; subst n.

  entailer.

  assert (repr (z - 1) (Vint (Int.repr (z - 1)))).

  { clear -H H1. inv H. constructor. omega. }

  entailer!.

  after_call; forward.

  rewrite Z.even_sub; simpl.

  case_eq (Z.odd z); rewrite Zodd_even_bool;

   destruct (Z.even z); simpl; congruence.

Qed.



Lemma body_even : semax_body Vprog Gprog f_even even_spec.

Proof.

start_function.

name n _n.

forward_if (PROP (repr z v /\ z > 0) LOCAL (`(eq v) (eval_id _n)) SEP ()).

* forward. eapply repr0_even in H0; eauto; rewrite H0; entailer.

* forward; entailer; inv H.

  assert (z <> 0) by (apply repr_eq0_not0; auto); entailer.

* forward_call (Share.top,z-1,Vint (Int.sub (Int.repr z) (Int.repr 1))).

  entailer; inversion H; subst z0; rewrite <-H5 in H2; inversion H2; subst n.

  entailer.

  assert (repr (z - 1) (Vint (Int.repr (z - 1)))).

  { clear -H H1. inv H. constructor. omega. }

  entailer!.

  after_call; forward.

  rewrite Z.odd_sub; simpl.

  case_eq (Z.odd z); rewrite Zodd_even_bool;

   destruct (Z.even z); simpl; congruence.

Qed.



Lemma body_main : semax_body Vprog Gprog f_main main_spec.

Proof with (try solve[entailer!|entailer!; constructor; omega]).

start_function.

forward_call (42,Vint (Int.repr 42))... after_call.

forward.

Qed.



Existing Instance NullExtension.Espec.



Lemma prog_correct:

  semax_prog prog Vprog Gprog.

Proof.

prove_semax_prog.

semax_func_cons body_odd.

semax_func_cons body_even.

semax_func_cons body_main.

Qed.



