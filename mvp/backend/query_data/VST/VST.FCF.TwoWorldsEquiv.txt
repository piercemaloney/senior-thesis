

Set Implicit Arguments.



Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)

Require Import FCF.Crypto.
(* FCF.Crypto:
Require Export FCF.DistRules.
Require Export FCF.Comp.
Require Export Arith.
Require Export FCF.Fold.
Require Export FCF.Rat.
Require Export FCF.DistSem.
Require Export FCF.StdNat.
Require Export FCF.DistTacs.

Open Scope comp_scope.
Open Scope rat_scope. *)

Require Import FCF.Asymptotic.
(* FCF.Asymptotic:
Set Implicit Arguments.

Require Import FCF.StdNat.

Definition polynomial (f : nat -> nat) :=
    exists x c1 c2, forall n,
      (f n <= c1 * expnat n x + c2)%nat.

Definition polynomial_nz(f : nat -> nat) :=
  exists x c1 c2, 
    x > 0 /\ c1 > 0 /\ c2 > 0 /\
    forall n, 
      (f n <= c1 * expnat n x + c2)%nat.

Theorem polynomial_nz_equiv : 
  forall f, 
    polynomial f ->
    polynomial_nz f.

Theorem polynomial_plus : 
  forall f1 f2 ,
    polynomial f1 ->
    polynomial f2 ->
    polynomial (fun n => f1 n + f2 n).

Theorem polynomial_const : 
  forall c, 
    polynomial (fun n => c).

Theorem polynomial_ident :
  polynomial (fun n => n).

Theorem polynomial_mult : 
  forall f1 f2 ,
    polynomial f1 ->
    polynomial f2 ->
    polynomial (fun n => f1 n * f2 n).
      
Require Import FCF.Rat.
Local Open Scope rat_scope.

Definition negligible(f : nat -> Rat) :=
  forall c, exists n, forall x (pf_nz : nz x),
    x > n ->
    ~ ((1 / expnat x c) <= f x)%rat.

Theorem negligible_eq : 
  forall (f1 f2 : nat -> Rat),
    negligible f1 ->
    (forall n, f1 n == f2 n) ->
    negligible f2.

Lemma negligible_le : 
  forall f1 f2,
    (forall n, f2 n <= f1 n)%rat ->
    negligible f1 ->
    negligible f2.

Lemma negligible_plus : 
  forall f1 f2,
    negligible f1 ->
    negligible f2 ->
    negligible (fun n => f1 n + f2 n)%rat.

Local Open Scope nat_scope.
Theorem double_log_plus_3_le_h : 
  forall y x,
    y = Nat.log2 x ->

Theorem S_log_square_lt_h : 
  forall y x,
    y = Nat.log2 x ->

Theorem S_log_square_lt : 
  forall x, 
    Nat.pow 2 6 <= x->

Theorem log_square_lt : 
  forall x, 
    Nat.pow 2 6 <= x->

Theorem poly_lt_exp_ge_6 : 
  forall c x, 
    x >= (Nat.pow 2 c) ->

Theorem poly_lt_exp : 
  forall c, 
    exists x, 
      forall y, y >= x ->
        expnat y c < expnat 2 y.
    
Theorem negligible_exp_den : 
  negligible (fun n => 1 / expnat 2 n)%rat.

Theorem negligible_const_mult : 
  forall (n : nat) d f,
    negligible f -> 
    negligible (fun x => (RatIntro n d) * (f x))%rat.

Theorem negligible_mult_ident : 
  forall f,
    negligible f -> 
    negligible (fun x => (x / 1) * (f x))%rat.

Theorem negligible_exp : 
  forall z, 
    negligible (fun n => expnat n z / expnat 2 n)%rat.

Theorem negligible_const_num : 
  forall k,
    negligible (fun n => k / expnat 2 n)%rat.

Theorem negligible_poly_num : 
  forall f,
    polynomial f ->
    negligible (fun n => f n / expnat 2 n)%rat. *)



Theorem evalDist_bool_support : 

  forall (c : Comp bool)(ls : list bool),

    well_formed_comp c ->

    ls = getSupport c ->

    sumList ls (evalDist c) == evalDist c false + evalDist c true.

  

  intuition.

  specialize (support_NoDup c); intuition.

  rewrite <- H0 in H1.

  

  destruct ls; intuition.

  specialize (getSupport_length_nz H); intuition.

  rewrite <- H0 in H2.

  simpl in *.

  omega.

  

  destruct b.

  

  destruct ls.

  unfold sumList; simpl.

  

  eapply ratAdd_eqRat_compat.

  symmetry.

  eapply getSupport_not_In_evalDist.

  intuition.

  rewrite <- H0 in H2.

  simpl in *.

  intuition.

  intuition.

  

  destruct b.

  inversion H1; clear H1; subst.

  simpl in *.

  intuition.

  

  destruct ls.

  

  unfold sumList.

  simpl.

  rewrite <- ratAdd_0_l.

  eapply ratAdd_comm.

  

  destruct b.

  inversion H1; clear H1; subst.

  simpl in *.

  intuition.

  inversion H1; clear H1; subst.

  simpl in *.

  intuition.

  inversion H5; clear H5; subst.

  simpl in *; intuition.

  

  destruct ls.

  unfold sumList; simpl.

  

  rewrite ratAdd_comm.

  eapply ratAdd_eqRat_compat.

  intuition.

  symmetry.

  eapply getSupport_not_In_evalDist.

  intuition.

  rewrite <- H0 in H2.

  simpl in *.

  intuition.



  destruct b.

  

  destruct ls.

  

  unfold sumList.

  simpl.

  rewrite <- ratAdd_0_l.

  intuition.

  

  destruct b.

  inversion H1; clear H1; subst.

  simpl in *.

  intuition.

  inversion H5; clear H5; subst.

  simpl in *; intuition.

  inversion H1; clear H1; subst.

  simpl in *; intuition.

  inversion H1; clear H1; subst.

  simpl in *; intuition.      

  

Qed.

    

Theorem evalDist_bool_complement : 

  forall (c : Comp bool),

    well_formed_comp c ->

    evalDist c false == ratSubtract 1 (evalDist c true).

  

  intuition.

  eapply (eqRat_ratAdd_same_r (evalDist c true)).

  symmetry.

  rewrite ratAdd_comm.

  rewrite ratSubtract_ratAdd_inverse_2.

  

  specialize (@evalDist_lossless _ c); intuition.

  rewrite <- H1.

  clear H1.

  eapply evalDist_bool_support.

  intuition.

  intuition.

  

  eapply evalDist_le_1.

Qed.



Theorem rndBool_bind : 

  forall 

    (f : bool -> Comp bool),

    Pr[b <-$ {0, 1}; f b] == (1 / 2) * Pr[f true] + (1 / 2) * Pr[f false].

  

  intuition.

  simpl.

  destruct (bind_eq_dec ({ 0 , 1 }^1) (fun m : Bvector 1 => ret Vector.hd m)

    false true).

  discriminate.

  

  unfold sumList.

  simpl.

  destruct (EqDec_dec bool_EqDec true false).

  discriminate.

  destruct (EqDec_dec bool_EqDec false true).

  discriminate.

  destruct (EqDec_dec bool_EqDec true true).

  destruct (EqDec_dec bool_EqDec false false).

  

  repeat rewrite <- ratAdd_0_l.

  repeat rewrite ratMult_0_r.

  repeat rewrite <- ratAdd_0_r.

  repeat rewrite <- ratAdd_0_l.

  repeat rewrite ratMult_1_r.

  eapply ratAdd_eqRat_compat;

    eapply ratMult_eqRat_compat; intuition.

  

  intuition.

  intuition.

Qed.



Section TwoWorldsEquiv.



  Variable f : nat -> bool -> Comp bool.



  Hypothesis f_wf : forall n b, well_formed_comp (f n b).



  Section TwoWorldsEquiv_eta.

    Variable eta : nat.

  

    Definition StandardDef_G :=

      b <-$ {0, 1};

      b' <-$ f eta b;

      ret (eqb b b').



    Theorem StandardDef_equiv_2W_h : 

      | Pr[StandardDef_G] - 1 / 2 | == (1 / 2) * | Pr[f eta true] - Pr[f eta false] |.

      

      unfold StandardDef_G.

      

      rewrite rndBool_bind.

      

      assert ( Pr[b' <-$ f eta true; ret eqb true b'] == Pr[f eta true]).

      symmetry.

      rewrite <- evalDist_right_ident.

      comp_skip.

      fcf_compute.

      rewrite H.

      clear H.

      

      assert ( Pr  [b' <-$ f eta false; ret eqb false b' ] == (ratSubtract 1 (Pr[f eta false]))).

      assert (Pr  [b' <-$ f eta false; ret eqb false b' ]  == evalDist (f eta false) false).

      symmetry.

      rewrite <- evalDist_right_ident.

      comp_skip.

      fcf_compute.

      rewrite H.

      clear H.

      

      eapply evalDist_bool_complement.

      wftac.

      

      rewrite H.

      clear H.

      

      rewrite <- ratMult_distrib.

      rewrite <- (ratMult_1_r (1/2)) at 2.

      

      rewrite ratMult_ratDistance_factor_l.

      eapply ratMult_eqRat_compat; intuition.

      

      assert ((Pr  [f eta false])  + ratSubtract 1 (Pr  [f eta false]) == 1).

      rewrite <- ratSubtract_ratAdd_assoc.

      eapply ratSubtract_ratAdd_inverse.

      

      eapply evalDist_le_1.

      unfold eq_dec.

      

      rewrite <- H at 2.

      

      rewrite ratDistance_add_same_r.

      reflexivity.



      Grab Existential Variables.

      exact _.

      exact _.

    Qed.

    

    Theorem Def_equiv_2W : 

      | Pr[StandardDef_G] - 1 / 2 | == (1 / 2) * | Pr[f eta false] - Pr[f eta true] |.

      

      rewrite StandardDef_equiv_2W_h.

      rewrite ratDistance_comm.

      intuition.

      

    Qed.



    End TwoWorldsEquiv_eta.

  

    Theorem TwoWorlds_equiv_f : 

      negligible (fun eta => (| Pr[f eta false] - Pr[f eta true] |)) -> 

      negligible (fun eta => | Pr[StandardDef_G eta] - 1 / 2 |).



      unfold negligible.

      intuition.

      destruct (H c).

      exists x.

      intuition.

      eapply H0.

      intuition.

      rewrite H2.

      rewrite Def_equiv_2W.



      rewrite ratMult_comm.

      eapply ratMult_small_le.

      

      eapply rat_le_1.

      simpl.

      omega.

      

    Qed.



    Theorem TwoWorlds_equiv_b : 

      negligible (fun eta => | Pr[StandardDef_G eta] - 1 / 2 |) ->

      negligible (fun eta => (| Pr[f eta false] - Pr[f eta true] |)).



      unfold negligible.

      intuition.

      edestruct (H (1 + c)%nat).

      exists (S x)%nat.

      intuition.

      eapply H0.

      omega.



      assert ((RatIntro (S O)

        (@natToPosnat (expnat x0 (plus (S O) c))

           (@expnat_nz (plus (S O) c) x0 pf_nz))) == (1 / x0) * (1 / (expnat x0 c))).



      simpl.

      rewrite <- ratMult_denom.

      eapply eqRat_terms; intuition.



      rewrite H3.

      clear H3.

      rewrite H2.



      eapply leRat_trans.

      2:{

        eapply eqRat_impl_leRat.

        symmetry.

        eapply Def_equiv_2W.

      }



      eapply ratMult_leRat_compat; intuition.

      unfold leRat.

      eapply leRat_terms; intuition.

      unfold natToPosnat, posnatToNat.

      omega.



    Qed.



    Theorem TwoWorlds_equiv : 

      negligible (fun eta => (| Pr[f eta false] - Pr[f eta true] |)) <->

      negligible (fun eta => | Pr[StandardDef_G eta] - 1 / 2 |).



      intuition.

      eapply TwoWorlds_equiv_f; intuition.

      eapply TwoWorlds_equiv_b; intuition.



    Qed.

      

End TwoWorldsEquiv.
