Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import WandDemo.wand_frame.

Require Import WandDemo.wand_frame_tactic.

Require Import WandDemo.wandQ_frame.

Require Import WandDemo.list.

Require Import WandDemo.list_lemmas.



Lemma Tsh_split: forall sh, exists sh', sepalg.join sh sh' Tsh.

Proof.

  intros.

  exists (Share.comp sh).

  split.

  + apply Share.comp2.

  + apply Share.comp1.

Qed.



Module VerifHeadSwitch.



Import ListHead.

  

Definition head_pointer_switch_spec :=

 DECLARE _head_pointer_switch

  WITH sh : share, l: val, p: val, x: int, s: list int, y: int

  PRE [ _l OF (tptr t_struct_list) , _p OF (tptr tint)]

     PROP  (writable_share sh)

     LOCAL (temp _l l; temp _p p)

     SEP   (listrep sh (x :: s) l; data_at sh tint (Vint y) p)

  POST [ tvoid ]

     PROP  ()

     LOCAL ()

     SEP   (listrep sh (y :: s) l; data_at sh tint (Vint x) p).



Definition head_head_switch_spec :=

 DECLARE _head_head_switch

  WITH sh : share, l1: val, l2: val, h1: int, t1: list int, h2: int, t2: list int

  PRE [ _l1 OF (tptr t_struct_list) , _l OF (tptr t_struct_list)]

     PROP  (writable_share sh)

     LOCAL (temp _l1 l1; temp _l2 l2)

     SEP   (listrep sh (h1 :: t1) l1; listrep sh (h2 :: t2) l2)

  POST [ tvoid ]

     PROP  ()

     LOCAL ()

     SEP   (listrep sh (h2 :: t1) l1; listrep sh (h1 :: t2) l2).



Definition Gprog : funspecs :=

  ltac:(with_library prog [ head_pointer_switch_spec; head_head_switch_spec]).



Lemma body_head_pointer_switch: semax_body Vprog Gprog f_head_pointer_switch head_pointer_switch_spec.

Proof.

  start_function.

  replace_SEP 0

    (field_at sh t_struct_list [StructField _head] (Vint x) l *

      (field_at sh t_struct_list [StructField _head] (Vint y) l -* listrep sh (y :: s) l)).

    {

      entailer!.

      apply wand_frame_intro_list_head.

    }

  Intros. freeze [1] Fr.  

    forward. 

    forward. 

    forward. 

    forward. 

  thaw Fr.

  forward. 

  apply_wand_frame_elim; cancel.

Qed.



Lemma body_head_head_switch: semax_body Vprog Gprog f_head_head_switch head_head_switch_spec.

Proof.

  start_function.

  replace_SEP 0

    (field_at sh t_struct_list [StructField _head] (Vint h1) l1 *

      (field_at sh t_struct_list [StructField _head] (Vint h2) l1 -* listrep sh (h2 :: t1) l1)).

    {

      entailer!.

      apply wand_frame_intro_list_head.

    }

  replace_SEP 1

    (field_at sh t_struct_list [StructField _head] (Vint h2) l2 *

      (field_at sh t_struct_list [StructField _head] (Vint h1) l2 -* listrep sh (h1 :: t2) l2)).

    {

      entailer!.

      apply wand_frame_intro_list_head.

    }

  Intros. freeze [1; 3] Fr.  

    forward. 

    forward. 

    forward. 

    forward. 

  thaw Fr.

  forward. 

  apply_wand_frame_elim; cancel.

Qed.



End VerifHeadSwitch.



Module VerifAppend.



Definition append_spec (_append: ident) :=

 DECLARE _append

  WITH sh : share, x: val, y: val, s1: list int, s2: list int

  PRE [ _x OF (tptr t_struct_list) , _y OF (tptr t_struct_list)]

     PROP(writable_share sh)

     LOCAL (temp _x x; temp _y y)

     SEP (listrep sh s1 x; listrep sh s2 y)

  POST [ tptr t_struct_list ]

    EX r: val,

     PROP()

     LOCAL(temp ret_temp r)

     SEP (listrep sh (s1++s2) r).



Module VerifAppend1.



Import ListLib.



Definition append1_spec := append_spec _append1.



Definition Gprog : funspecs :=

  ltac:(with_library prog [ append1_spec ]).



Module ProofByNoWandBad.



Import LsegRecursiveLoopFree.



Lemma body_append1: semax_body Vprog Gprog f_append1 append1_spec.

Proof.

  start_function.

  forward_if. 

  * rewrite (listrep_null _ _ x) by auto. normalize.

    forward. 

    Exists y.

    entailer!.

  * forward. 

    rewrite (listrep_nonnull _ _ x) by auto.

    Intros v s1' u.

    forward. 

    forward_while

      ( EX s1a: list int, EX b: int, EX s1c: list int, EX t: val, EX u: val,

            PROP (s1 = s1a ++ b :: s1c)

            LOCAL (temp _x x; temp _t t; temp _u u; temp _y y)

            SEP (lseg sh s1a x t;

                 field_at sh t_struct_list [StructField _head] (Vint b) t;

                 field_at sh t_struct_list [StructField _tail] u t;

                 listrep sh s1c u;

                 listrep sh s2 y))%assert.

+ 

   Exists (@nil int) v s1' x u.

   subst s1. entailer!. unfold lseg; simpl; entailer!.

+ 

   entailer!.

+ 

  clear v H0.

  rewrite (listrep_nonnull _ _ u0) by auto.

  Intros c s1d z.

  forward. 

   forward. 

   Exists ((s1a ++ b :: nil),c,s1d,u0,z). unfold fst, snd.

   simpl app.

   entailer.

   apply andp_right; [apply prop_right; apply (app_assoc s1a [b] (c :: s1d)) |].

   sep_apply (singleton_lseg' sh b c t u0); auto.

   sep_apply (lseg_lseg sh s1a [b] c x t u0); auto.

   cancel.

+ 

   clear v s1' H0.

   forward. 

   forward. 

   Exists x.

   rewrite (listrep_null _ s1c) by auto.

   entailer.

   simpl app.

   sep_apply (singleton_lseg sh s2 b t y); auto.

   sep_apply (list_lseg sh [b] s2 t y).

   rewrite <- app_assoc.

   sep_apply (list_lseg sh s1a ([b] ++ s2) x t).

   auto.

Qed.



End ProofByNoWandBad.



Module ProofByNoWandGood.



Import LsegRecursiveMaybeLoop.



Lemma body_append1: semax_body Vprog Gprog f_append1 append1_spec.

Proof.

  start_function.

  forward_if. 

  * rewrite (listrep_null _ _ x) by auto. normalize.

    forward. 

    Exists y.

    entailer!.

  * forward. 

    rewrite (listrep_nonnull _ _ x) by auto.

    Intros v s1' u.

    forward. 

    forward_while

      ( EX s1a: list int, EX b: int, EX s1c: list int, EX t: val, EX u: val,

            PROP (s1 = s1a ++ b :: s1c)

            LOCAL (temp _x x; temp _t t; temp _u u; temp _y y)

            SEP (lseg sh s1a x t;

                 field_at sh t_struct_list [StructField _head] (Vint b) t;

                 field_at sh t_struct_list [StructField _tail] u t;

                 listrep sh s1c u;

                 listrep sh s2 y))%assert.

+ 

   Exists (@nil int) v s1' x u.

   subst s1. entailer!. unfold lseg; entailer!.

+ 

   entailer!.

+ 

  clear v H0.

  rewrite (listrep_nonnull _ _ u0) by auto.

  Intros c s1d z.

  forward. 

   forward. 

   Exists ((s1a ++ b :: nil),c,s1d,u0,z). unfold fst, snd.

   simpl app.

   entailer!.

     1: apply (app_assoc s1a [b] (c :: s1d)).

   sep_apply (singleton_lseg sh b t u0).

   apply lseg_lseg.

+ 

   clear v s1' H0.

   forward. 

   forward. 

   Exists x.

   rewrite (listrep_null _ s1c) by auto.

   entailer!.

   simpl app.

   sep_apply (singleton_lseg sh b t y).

   sep_apply (lseg_lseg sh s1a [b] x t y).

   sep_apply (list_lseg sh (s1a ++ [b]) s2 x y).

   auto.

Qed.



End ProofByNoWandGood.



Module ProofByWandFrame1.



Import LsegWandFrame.

  

Lemma body_append1: semax_body Vprog Gprog f_append1 append1_spec.

Proof.

  start_function.

  forward_if. 

  * rewrite (listrep_null _ _ x) by auto. normalize.

    forward. 

    Exists y.

    entailer!.

  * forward. 

    rewrite (listrep_nonnull _ _ x) by auto.

    Intros v s1' u.

    forward. 

    forward_while

      ( EX a: int, EX s1b: list int, EX t: val, EX u: val,

            PROP ()

            LOCAL (temp _x x; temp _t t; temp _u u; temp _y y)

            SEP (listrep sh (a::s1b++s2) t -* listrep sh (s1++s2) x;

                   field_at sh t_struct_list [StructField _head] (Vint a) t;

                   field_at sh t_struct_list [StructField _tail] u t;

                   listrep sh s1b u;

                   listrep sh s2 y))%assert.

+ 

   Exists v s1' x u.

   subst s1. entailer!. cancel_wand.

+ 

   entailer!.

+ 

  clear v H0.

  rewrite (listrep_nonnull _ _ u0) by auto.

   Intros b s1c z.

   forward. 

   forward. 

   Exists (b,s1c,u0,z). unfold fst, snd.

   simpl app.

   entailer!.

   sep_apply (singleton_lseg sh (b :: s1c ++ s2) a t u0).

   apply wand_frame_ver.

+ 

   clear v s1' H0.

   forward. 

   forward. 

   Exists x.

   rewrite (listrep_null _ s1b) by auto.

   entailer!.

   simpl app.

   sep_apply (singleton_lseg sh s2 a t y).

   unfold lseg; simpl app; apply_wand_frame_elim; cancel.

Qed.



End ProofByWandFrame1.



Module ProofByWandFrame2.



Import LsegWandFrame.

  

Lemma body_append1: semax_body Vprog Gprog f_append1 append1_spec.

Proof.

  start_function.

  forward_if. 

  * rewrite (listrep_null _ _ x) by auto. normalize.

    forward. 

    Exists y.

    entailer!.

  * forward. 

    rewrite (listrep_nonnull _ _ x) by auto.

    Intros v s1' u.

    forward. 

    forward_while

      ( EX s1a: list int, EX b: int, EX s1c: list int, EX t: val, EX u: val,

            PROP (s1 = s1a ++ b :: s1c)

            LOCAL (temp _x x; temp _t t; temp _u u; temp _y y)

            SEP (lseg sh (b::s1c++s2) s1a x t;

                 field_at sh t_struct_list [StructField _head] (Vint b) t;

                 field_at sh t_struct_list [StructField _tail] u t;

                 listrep sh s1c u;

                 listrep sh s2 y))%assert.

+ 

   Exists (@nil int) v s1' x u.

   subst s1. entailer!. unfold lseg; simpl; cancel_wand.

+ 

   entailer!.

+ 

  clear v H0.

  rewrite (listrep_nonnull _ _ u0) by auto.

  Intros c s1d z.

  forward. 

   forward. 

   Exists ((s1a ++ b :: nil),c,s1d,u0,z). unfold fst, snd.

   simpl app.

   entailer!.

     1: apply (app_assoc s1a [b] (c :: s1d)).

   sep_apply (singleton_lseg sh (c :: s1d ++ s2) b t u0).

   apply lseg_lseg.

+ 

   clear v s1' H0.

   forward. 

   forward. 

   Exists x.

   rewrite (listrep_null _ s1c) by auto.

   entailer!.

   simpl app.

   sep_apply (singleton_lseg sh s2 b t y).

   change (b :: s2) with ([b] ++ s2).

   sep_apply (lseg_lseg sh s1a [b] s2 x t y).

   sep_apply (list_lseg sh (s1a ++ [b]) s2 x y).

   auto.

Qed.



End ProofByWandFrame2.



Module ProofByWandQFrame.



Import LsegWandQFrame.



Lemma body_append1: semax_body Vprog Gprog f_append1 append1_spec.

Proof.

  start_function.

  forward_if. 

  * rewrite (listrep_null _ _ x) by auto. normalize.

    forward. 

    Exists y.

    entailer!.

  * forward. 

    rewrite (listrep_nonnull _ _ x) by auto.

    Intros v s1' u.

    forward. 

    forward_while

      ( EX s1a: list int, EX b: int, EX s1c: list int, EX t: val, EX u: val,

            PROP (s1 = s1a ++ b :: s1c)

            LOCAL (temp _x x; temp _t t; temp _u u; temp _y y)

            SEP (lseg sh s1a x t;

                 field_at sh t_struct_list [StructField _head] (Vint b) t;

                 field_at sh t_struct_list [StructField _tail] u t;

                 listrep sh s1c u;

                 listrep sh s2 y))%assert.

+ 

   Exists (@nil int) v s1' x u.

   subst s1. entailer!. unfold lseg; simpl; apply allp_right; intros; cancel_wand.

+ 

   entailer!.

+ 

  clear v H0.

  rewrite (listrep_nonnull _ _ u0) by auto.

  Intros c s1d z.

  forward. 

   forward. 

   Exists ((s1a ++ b :: nil),c,s1d,u0,z). unfold fst, snd.

   simpl app.

   entailer!.

     1: apply (app_assoc s1a [b] (c :: s1d)).

   sep_apply (singleton_lseg sh b t u0).

   apply lseg_lseg.

+ 

   clear v s1' H0.

   forward. 

   forward. 

   Exists x.

   rewrite (listrep_null _ s1c) by auto.

   entailer!.

   simpl app.

   sep_apply (singleton_lseg sh b t y).

   sep_apply (lseg_lseg sh s1a [b] x t y).

   sep_apply (list_lseg sh (s1a ++ [b]) s2 x y).

   auto.

Qed.



End ProofByWandQFrame.



End VerifAppend1.



Module VerifAppend2.



Import ListLib.

Import LBsegWandQFrame.



Definition append2_spec := append_spec _append2.



Definition Gprog : funspecs :=

  ltac:(with_library prog [ append2_spec ]).



Lemma data_at__Tsh_wand_frame_intro: forall {CS: compspecs} sh t p,

  writable_share sh ->

  data_at_ Tsh t p |-- data_at_ sh t p *

    ALL v: reptype t, data_at sh t v p -* data_at Tsh t v p.

Proof.

  intros.

  destruct (Tsh_split sh) as [sh' ?].

  unfold data_at_ at 1, field_at_.

  simpl nested_field_type.

  fold (data_at Tsh t (default_val t) p).

  rewrite <- (data_at_share_join  _ _ _ t _ p H0).

  cancel.

  apply allp_right; intros v.

  apply wand_sepcon_adjoint.

  rewrite sepcon_comm.

  apply (data_at_share_join_W _ _ Tsh t _ _ p); auto.

Qed.



Lemma body_append2: semax_body Vprog Gprog f_append2 append2_spec.

Proof.

  start_function.

  rename v_head into retp.

  rename x into head.

  replace_SEP 0

    (data_at_ sh (tptr t_struct_list) retp * ALL v: val, data_at sh (tptr t_struct_list) v retp -* data_at Tsh (tptr t_struct_list) v retp).

    {

      entailer!.

      apply data_at__Tsh_wand_frame_intro; auto.

    }

  Intros. freeze [1] Fr.

  forward. 

  forward. 

  forward. 

  forward. 

  forward_while

      ( EX s1a: list int, EX s1b: list int, EX curp: val, EX cur: val,

            PROP (s1 = s1a ++ s1b)

            LOCAL (temp _retp retp; temp _cur cur; temp _y y; temp _curp curp; lvar _head (tptr t_struct_list) retp)

            SEP (lbseg sh s1a retp curp;

                 listrep sh s1b cur;

                 listrep sh s2 y;

                 data_at sh (tptr t_struct_list) cur curp;

                 FRZL Fr))%assert.

  + 

    Exists (@nil int) s1 retp head.

    entailer!. unfold lbseg; simpl; apply allp_right; intros; cancel_wand.

  + 

    entailer!.

  + 

    forward. 

    assert_PROP (offset_val

              (align (align 0 (alignof tint) + sizeof tint)

                (alignof (tptr (Tstruct _list noattr)))) cur =

                 field_address t_struct_list [StructField _tail] cur).

    Focus 1. {

      entailer!.

      symmetry; apply field_address_eq_offset'; auto.

      auto with field_compatible.

    } Unfocus.

    rewrite H0; clear H0.

    rewrite (listrep_nonnull _ _ cur) by auto.

    Intros b s1c next.

    subst s1b.

    forward. 

    Exists (s1a ++ [b], s1c, (field_address t_struct_list [StructField _tail] cur), next).

    simpl snd; simpl fst.

    entailer!.

      1: rewrite <- app_assoc; auto.

    sep_apply (singleton_lbseg sh b curp cur).

    sep_apply (lbseg_lbseg sh s1a [b] retp curp (field_address t_struct_list [StructField _tail] cur)).

    rewrite field_at_data_at.

    cancel.

  + 

    rewrite (listrep_null _ _ cur) by auto.

    Intros.

    forward. 

    gather_SEP 1 2 3.

    replace_SEP 0 (listboxrep sh s2 curp).

    Focus 1. {

      entailer!.

      unfold listboxrep; Exists y.

      cancel.

    } Unfocus.

    gather_SEP 0 1.

    replace_SEP 0 (listboxrep sh (s1a ++ s2) retp).

    Focus 1. {

      entailer!.

      sep_apply (listbox_lbseg sh s1a s2 retp curp).

      cancel.

    } Unfocus.

    unfold listboxrep; Intros head'.

    thaw Fr.

    gather_SEP 0 2.

    replace_SEP 0 (data_at Tsh (tptr t_struct_list) head' retp).

    Focus 1. {

      entailer!.

      rewrite sepcon_comm; apply wand_sepcon_adjoint.

      apply (allp_left _ head').

      auto.

    } Unfocus.

    forward. 

    forward. 

    Exists head'.

    entailer!.

    rewrite app_nil_r.

    auto.

Qed.



End VerifAppend2.



Module VerifAppend3.



Import ListLib.

Import LsegWandQFrame.



Definition append3_spec := append_spec _append3.



Definition Gprog : funspecs :=

  ltac:(with_library prog [ append3_spec ]).



Lemma body_append3: semax_body Vprog Gprog f_append3 append3_spec.

Proof.

  start_function.

  forward_if. 

  + forward. 

    rewrite (listrep_null _ _ nullval) by auto.

    Exists y; entailer!. simpl app; auto.

  + rewrite (listrep_nonnull _ _ x) by auto.

    Intros a s1b x'.

    subst s1.

    forward. 

    forward_call (sh, x', y, s1b, s2). 

    Intros x''.

    forward. 

    forward. 

    Exists x.

    entailer!.

    unfold listrep at 2; fold listrep.

    Exists x''.

    entailer!.

Qed.



End VerifAppend3.



End VerifAppend.

