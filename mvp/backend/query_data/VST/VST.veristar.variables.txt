Add LoadPath "..".

Require Import ZArith List Orders POrderedType.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import veristar.tactics.
(* veristar.tactics:
Require Export LibTactics LibTactics2. *)



Module Ident : UsualOrderedType.

  Parameter t: Type.

  Definition eq := @Logic.eq t.

  Definition eq_equiv := @eq_equivalence t.

  Parameter lt : t -> t -> Prop.

  Parameter lt_strorder : StrictOrder lt.

  Parameter lt_compat : Proper (eq==>eq==>iff) lt.

  Parameter compare : forall x y : t, comparison.

  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').

  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.

End Ident.



Parameter minid : Ident.t.

Parameter id2pos: Ident.t -> positive.

Parameter pos2id: positive -> Ident.t.

Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.

Axiom minid_eq: id2pos minid = 1%positive.

Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).

Parameter another_id: Ident.t -> Ident.t.



Parameter Z2id: Z -> Ident.t.

Parameter add_id: Ident.t -> Ident.t -> Ident.t.

Parameter mult_id: Ident.t -> Ident.t -> Ident.t.



Lemma minid_min x : Ident.lt x minid -> False.

tapp Ilt_morphism; rewrite minid_eq; case (id2pos x); tinv0.

Qed.



Ltac id_compare x y :=

  destruct (CompSpec2Type (Ident.compare_spec x y)).



Ltac id_comp x y H1 H2 H3 :=

  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].



Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

introv H; id_comp x y H1 H2 H3; [auto|elimtype False; gen H2|gen H3];

done (tapp Ilt_morphism; rewrite H; tapp Pos.lt_irrefl).

Qed.



Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Proof. done (case Ident.lt_strorder). Qed.



Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Proof. done (case Ident.lt_strorder). Qed.



Definition Ile x y := Ident.lt x y \/ Ident.eq x y.



Lemma Ile_refl x : Ile x x.

Proof. done (introv; right). Qed.



Hint Resolve Ile_refl.



Lemma Ilt_Zpos i j :

  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Proof.

split; [tapp Ilt_morphism|tinv H].

generalize (Pcompare_spec (id2pos i) (id2pos j)); rewrite H; tinv H1.

id_comp i j H2 H3 H4; auto; subst.

contradiction (Pos.lt_irrefl _ H1).

gen H4; tapp Ilt_morphism; introv H4.

contradiction (Pos.lt_irrefl _ (Plt_trans _ _ _ H1 H4)).

Qed.



Lemma nat_of_P_id2pos_le x y :

  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y).

Proof.

cases (Ident.eq_dec x y) as E; subst; auto; cases E.

introv H1; inverts H1 as H1; [|inverts H1; auto].

gen H1; tapp Ilt_morphism; unfold Plt.

done(rewrite nat_of_P_compare_morphism, <-nat_compare_lt; omega).

Qed.

