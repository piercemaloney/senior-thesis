Load loadpath.

Require Import ZArith Coq.Lists.List Permutation.

Require Import VST.msl.Axioms VST.msl.predicates_sa VST.veric.Coqlib2.
(* VST.msl.Axioms:
Require Coq.Logic.ClassicalFacts.

Require Export Coq.Logic.FunctionalExtensionality.

Lemma extensionality:
  forall (A B: Type) (f g : A -> B),  (forall x, f x = g x) -> f = g.

Arguments extensionality [A B] _ _ _.

Axiom prop_ext: ClassicalFacts.prop_extensionality.
Arguments prop_ext [A B] _.

Lemma proof_irr: ClassicalFacts.proof_irrelevance.
Proof.
  exact (ClassicalFacts.ext_prop_dep_proof_irrel_cic prop_ext).
Arguments proof_irr [A] _ _. *)
(* VST.msl.predicates_sa:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.

Require Import Coq.funind.Recdef.
Require Coq.Wellfounded.Wellfounded. 
Delimit Scope pred with pred.
Local Open Scope pred.

Definition pred (A:Type) := A -> Prop.
Bind Scope pred with pred.

Definition derives (A:Type) (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] _ _.

Lemma pred_ext : forall A (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma derives_cut {A}  : forall Q P R : pred A,
  derives P Q ->
  derives Q R ->
  derives P R.

Definition prop {A: Type}  (P: Prop) : pred A := (fun _  => P).
Hint Unfold prop.

Definition TT {A}: pred A := prop True.
Definition FF  {A}: pred A := prop False.

Set Implicit Arguments.

Definition imp {A}  (P Q:pred A) :=
   fun a:A => P a -> Q a.
Definition orp {A} (P Q:pred A) :=
   fun a:A => P a \/ Q a.
Definition andp {A} (P Q:pred A) :=
   fun a:A => P a /\ Q a.

Definition allp {A B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.
Definition exp {A B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Notation "'emp'" := identity.

Definition sepcon {A} {JA: Join A}(p q:pred A) := fun z:A =>
  exists x:A, exists y:A, join x y z /\ p x /\ q y.
Definition wand {A}  {JA: Join A}  (p q:pred A) := fun y =>
  forall x z, join x y z -> p x -> q z.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.
Notation "P '*' Q" := (sepcon P Q) : pred.
Notation "P '-*' Q" := (wand P Q) (at level 60, right associativity) : pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Definition precise {A}  {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall w w1 w2, P w1 -> P w2 -> join_sub w1 w -> join_sub w2 w -> w1=w2.

Definition precise2  {A} {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma precise_eq {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     precise =
                 fun P : pred A => forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma derives_precise {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q, (P |-- Q) -> precise Q -> precise P.

Lemma prop_true_and:
  forall (P: Prop) A (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_andp_e {A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A}:  forall P Q (w:A), P /\ Q w -> (!! P && Q) w.

Lemma derives_trans {A}:  forall (P Q R: pred A), P |-- Q -> Q |-- R -> P |-- R.

Lemma and_i {A}: forall (P Q R: pred A),
    P |-- Q -> P |-- R -> P |-- Q && R.

Lemma andp_derives {A}  :
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q r, (((p * q) * r) = (p * (q * r))).

Lemma sepcon_comm {A} {JA: Join A}{PA: Perm_alg A}:  forall (P Q: pred A) , P * Q = Q * P.

Lemma sepcon_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall P, (P * emp) = P.

Lemma emp_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, (emp*P) = P.

Lemma precise_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     precise emp.

Definition exactly {A} (x: A) : pred A := fun w => w=x.

Lemma join_exactly {A} {JA: Join A}{PA: Perm_alg A}:
  forall w1 w2 w3, join w1 w2 w3 -> exactly w1 * exactly w2 = exactly w3.

Lemma exists_and1 {A: Type} : forall {T: Type} (P: T -> pred A) (Q: pred A),
                   exp P && Q = EX x:T, P x && Q.

Lemma andp_comm {A: Type}: forall (P Q: pred A), P && Q = Q && P.

Lemma andp_assoc {A}: forall (P Q R: pred A),
                 ((P && Q) && R = P && (Q && R)).

Lemma True_andp_eq {A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma TT_i  {A} : forall w: A,  TT w.

Hint Resolve @TT_i.

Lemma TT_and {A}: forall (Q: pred A), TT && Q = Q.

Lemma andp_TT {A}: forall (P: pred A), P && TT = P.

Lemma emp_wand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, emp -* P = P.

Lemma wand_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall P P' Q Q',  P' |-- P -> Q |-- Q' -> P -* Q |-- P' -* Q'.

Lemma TT_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: TT * TT = TT.

Definition ewand {A} {JA: Join A} (P Q: pred A) : pred A :=
  fun w => exists w1, exists w2, join w1 w w2 /\ P w1 /\ Q w2.

Lemma emp_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:  forall P, ewand emp P = P.

Lemma exists_sepcon1 {A} {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  exp P * Q = exp (fun x => P x * Q).

Lemma derives_refl {A: Type}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma derives_TT {A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma sepcon_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q p' q', (p |-- p') -> (q |-- q') -> (p * q |-- p' * q').

Lemma derives_e {A: Type}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Lemma exp_derives {A} :
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma unmodus_wand {A}  {JA: Join A}{PA: Perm_alg A}:
 forall P Q R, Q = P * R ->  Q |-- P * (P -* Q).

Definition superprecise {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} (P: pred A) :=
   forall w1 w2, P w1 -> P w2 -> comparable w1 w2 -> w1=w2.

Lemma modus_ewand {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} :  forall P Q, superprecise P -> P * (ewand P Q) |-- Q.

Lemma exists_expand_sepcon {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B (p: B -> pred A) q, (exp p * q)%pred = (exp (fun x => p x * q))%pred.

Lemma exists_expand_sepcon' {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B p (q: B -> pred A), (p * exp q)%pred = (exp (fun x => p * q x))%pred.

Lemma exists_expand_and {A}  {JA: Join A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exists_expand_and' {A} {JA: Join A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma allp_derives_right {A} : forall B p (q: B -> pred A),
  ((p |-- allp q) <-> (forall x, p |-- q x)).

Lemma wand_exists {A} {JA: Join A}{PA: Perm_alg A}:
   forall B P Q,  (EX x: B, P -* Q x) |-- (P -* EX x : B, Q x).

Lemma modus_wand {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q,  P * (P -* Q) |-- Q.

Lemma distrib_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q R, P * (Q && R) |-- (P * Q) && (P * R).

Lemma andp_r {A: Type} : forall (P Q R: pred A), P |-- Q -> P |-- R -> P |-- Q && R.

Definition list_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : list (pred A) -> pred A := fold_right sepcon emp.

Lemma sepcon_andp_prop {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R, P * (!!Q && R) = !!Q && (P * R).

Require Import VST.msl.cross_split.

Lemma exactly_i {A} : forall x: A, exactly x x.
Hint Resolve @exactly_i.

Lemma superprecise_exactly {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x, superprecise (exactly x).
Hint Resolve @superprecise_exactly.

Lemma find_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     Cross_alg A ->
     forall S P Q R, (S * P) && (Q * R) |--
                          EX SQ:_, EX SR:_, EX PQ:_, EX PR:_,
                            (((SQ* SR) && S)*((PQ* PR) && P)) &&
                            (((SQ* PQ) && Q)*((SR* PR) && R)) &&
                            !! (superprecise SQ /\ superprecise SR /\ superprecise PQ /\ superprecise PR).

Lemma modus_ponens {A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma and_intro {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma and1 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A}  : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A}  : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A}  : forall X (P: pred A),
  X |-- P --> TT.

Lemma FFrule {A}  : forall X (P: pred A),
  X |-- FF --> P.

Lemma distribution {A}  : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma wand_sepcon_adjoint {A} {JA: Join A}{PA: Perm_alg A} : forall (P Q R:pred A),
  ((P * Q) |-- R) = (P |-- (Q -* R)).

Lemma ewand_sepcon {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R,
      (ewand (P * Q) R = ewand P (ewand Q R))%pred.

Lemma andp_right {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma andp_left1{A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma exp_right:
  forall {B A: Type}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma allp_right {B A: Type}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma imp_andp_adjoint {A}  : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma exp_andp1 {A} :
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_sepcon1 {A}  {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  (exp P * Q = exp (fun x => P x * Q))%pred.

Definition pure {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}
     (P: pred A) : Prop :=
   P |-- emp.

Lemma sepcon_pure_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall P Q, pure P -> pure Q -> ((P * Q) = (P && Q)).

Lemma pure_sepcon_TT_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall P Q, pure P -> (P * TT) && Q = (P*Q).

Lemma ewand_conflict {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
       forall P Q R, sepcon P Q |-- FF -> andp P (ewand Q R) |-- FF.

Lemma ewand_TT_sepcon {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
      forall P Q R,
(P * Q && ewand R (!!True))%pred |-- (P && ewand R (!!True) * (Q && ewand R (!!True)))%pred. *)

Require Import veristar.variables veristar.datatypes veristar.clauses
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)

               veristar.list_denote veristar.heapresolve

               veristar.model_type veristar.model

               veristar.clause_lemmas veristar.basic.



Import HeapResolve.



Module Type WF_SOUND.

Declare Module VSM : VERISTAR_MODEL.

Import VSM VeriStarLogic.



Import sepalg.



Axiom do_wellformed_sound : forall cl,

  clause_denote cl |-- setd clause_denote inter TT (do_wellformed cl).



End WF_SOUND.



Module WF_Sound (VSM : VERISTAR_MODEL) : WF_SOUND with Module VSM := VSM.

Module VSM := VSM.

Import VSM VeriStarLogic.



Module CL := CL_Sound VSM. Import CL.



Import sepalg.



Lemma state_join_var_eq : forall (s0 s1 s : state) x y,

  join s0 s1 s -> (x === y) s0 -> (x === y) s.

Proof.

intros; destruct s, s0, s1, H. simpl in *. destruct H.

unfold var_eq in *; subst; auto.

Qed.



Lemma state_join_var_eq' : forall (s0 s1 s : state) x y,

  join s0 s1 s -> (x === y) s -> (x === y) s0.

Proof.

intros; destruct s; destruct s0; destruct s1. destruct H. simpl in *.

destruct H; unfold var_eq in *; subst; auto.

Qed.



Lemma lseg_nil_or_loc : forall x y h, lseg x y h -> nil_or_loc y.

Proof. induction 1; auto. Qed.



Lemma w_next_nil : forall y Sigma s,

  clause_denote (NegSpaceClause nil (Next Nil y :: Sigma) nil) s.

Proof.

intros. intros [s0 [s1 [Hjoin [H1 _]]]]. simpl in *.

simpl in H1.

rewrite nil_not_loc in H1. contradiction.

Qed.



Lemma w_lseg_nil : forall y Sigma s,

  clause_denote (NegSpaceClause nil (Lseg Nil y :: Sigma) [Eqv y Nil]) s.

Proof.

intros. intros [s0 [s1 [Hjoin [H1 _]]]].

simpl in H1. simpl in H1. left.

inversion  H1; clear H1; subst.

simpl. eapply state_join_var_eq; eauto.

symmetry; auto. apply var_eq_sym; auto.

exfalso. simpl in H0. rewrite nil_not_loc in H0. inversion H0.

Qed.



Ltac dsepcon :=

match goal with

  [ H : sepcon _ _ _ |- _ ] =>

  let s1 := fresh "s" in

    let s2 := fresh "s" in

      let JOIN := fresh "JOIN" in

        let H1 := fresh "H" in

          let H2 := fresh "H" in

      destruct H as [s1 [s2 [JOIN [H1 H2]]]]

end.



Lemma nil_or_loc_full v : nil_or_loc v -> full v.

Proof.

intros. destruct H.

subst. apply nil_full.

destruct H as [l ?].

apply val2loc_full with l; auto.

Qed.



Hint Resolve nil_or_loc_full.



Lemma expr_denote_heap_ind : forall x s h h',

  expr_denote x (State s h) = expr_denote x (State s h').

Proof. intros. destruct x; auto. Qed.



Lemma next_next_join_False : forall s0 s0' s1 s2 x z1 z2,

  rawnext x z1 s0 -> join_sub s0 s0' ->

  rawnext x z2 s2 -> join_sub s2 s1 ->

  joins s0' s1 -> False.

Proof.

intros s0 s0' s1 s2 x z1 z2 H0 [s3' H9] H2 [s3 H1] [s H] .

destruct (rawnext_at1 (rawnext2rawnext' H0) H9).

destruct (rawnext_at1 (rawnext2rawnext' H2) H1).

destruct (rawnext_at1 H4 H).

apply (rawnext_not_emp H6 H7).

Qed.



Lemma next_in_dom_rawnext sigma x s :

  next_in_dom x sigma = true -> space_denote sigma s ->

  exists s0, exists z, space_atom_denote (Next (Var x) z) s0 /\ join_sub s0 s.

Proof with auto; try congruence; try solve [

  destruct B as [x' [y' [C [D E]]]]; destruct (IHsigma A y' E) as [s0 [z [F G]]];

    subst; exists s0; exists z; split; simpl; auto;

      apply join_sub_trans with (b := y'); simpl; auto;

        eapply join_join_sub'; eauto].

intros A B; revert s B; induction sigma; intros s B. simpl in A...

simpl in A. remember a as b; destruct b... remember e as b'; destruct b'...

destruct (Ident.eq_dec x v)... destruct B as [x' [y' [C [D E]]]].

subst; exists x'; exists e0; split... solve [eapply join_join_sub'; eauto].

Qed.



Lemma nn_njoin sigma x z s1 s2 :

  next_in_dom x sigma = true -> space_denote sigma s1 ->

  space_atom_denote (Next (Var x) z) s2 -> joins s1 s2 ->

  False.

Proof with try congruence.

intros A B C D; destruct (next_in_dom_rawnext _ _ _ A B) as [s' [z' [F G]]].

simpl in F, C. cut (stk s2 = stk s'). intro Heq; rewrite Heq in *; clear Heq.

destruct (val2loc (env_get (stk s') x))...

destruct F as [H I]; destruct C as [J K].

assert (L : join_sub (hp s') (hp s1)).

  destruct G as [x0 [G1 G2]]; exists (hp x0)...

assert (M : joins (hp s1) (hp s2)).

  destruct D as [x0 [D1 D2]]; exists (hp x0)...

generalize (next_next_join_False _ _ (hp s2) _ _ _ _ H L J)... intro N.

apply N... apply join_sub_refl.

destruct G as [? [[G0 G1] G']]; destruct D as [? [[D0 D1] D']].

solve [rewrite G0, G1, D0; auto].

Qed.



Lemma join_stacks_eq : forall s0 s1 s : state,

  join s0 s1 s -> stk s0=stk s1 /\ stk s0=stk s.

Proof.

intros.

destruct H. destruct H.

subst; split; auto.

transitivity (stk s1); auto.

Qed.



Local Notation "'inter'" := (@andp _).



Local Notation "'un'" := (@orp _).



Lemma pure_atomd_pure atm s0 s :

  pure_atom_denote atm s0 -> join_sub s0 s -> pure_atom_denote atm s.

Proof with try solve [simpl; auto | congruence].

intros A B. destruct atm as [e e0]... destruct B as [s1 B]. simpl.

solve [eapply state_join_var_eq; eauto].

Qed.



Lemma listd_pure_atomdi atms s0 s :

  listd pure_atom_denote inter TT atms s0 -> join_sub s0 s ->

  listd pure_atom_denote inter TT atms s.

Proof with simpl; auto.

induction atms... intros [A B] C. split... solve [eapply pure_atomd_pure; eauto].

Qed.



Lemma listd_pure_atomdu atms s0 s :

  listd pure_atom_denote un FF atms s0 -> join_sub s0 s ->

  listd pure_atom_denote un FF atms s.

Proof with simpl; auto.

induction atms... intros [A | A] B.

left; eapply pure_atomd_pure; eauto. right...

Qed.



Lemma listd_pure_atomd_purei atms s0 s :

  listd (fun atms : list pure_atom => listd pure_atom_denote inter TT atms)

      inter TT atms s0 ->

  join_sub s0 s ->

  listd (fun atms : list pure_atom => listd pure_atom_denote inter TT atms)

      inter TT atms s.

Proof with simpl; auto.

induction atms... intros [A B] C. split... eapply listd_pure_atomdi; eauto.

Qed.



Lemma listd_pure_atomd_pureu atms s0 s :

  listd (fun atms : list pure_atom => listd pure_atom_denote un FF atms)

      inter TT atms s0 ->

  join_sub s0 s ->

  listd (fun atms : list pure_atom => listd pure_atom_denote un FF atms)

      inter TT atms s.

Proof with simpl; auto.

induction atms... intros [A B] C. split... eapply listd_pure_atomdu; eauto.

Qed.



Lemma do_well1_2_sound sigma s :

  space_denote sigma s ->

  listd (fun atms => listd pure_atom_denote un FF atms) inter TT

    (do_well1_2 sigma) s.

Proof with try solve [simpl; auto | congruence | inversion 1

  | apply listd_pure_atomd_pureu with (s0 := y);

    [ | exists x; apply join_comm; auto ]; solve [apply IHsigma; auto]].

revert s; induction sigma... intros s H.

remember a as b; destruct b as [e e0 | ]; simpl.

remember e as b1; destruct b1.

generalize (w_next_nil e0 sigma s H)... generalize H; intros [x [y [A [B C]]]]...

remember e as b; destruct b... generalize (w_lseg_nil e0 sigma s H) as A...

intro. inversion A as [B | B]; [ | inversion B ]. split...

generalize H; intros [x [y [C [D E]]]]...

generalize H; intros [x [y [C [D E]]]]...

Qed.



Lemma do_well3_sound sigma s :

  space_denote sigma s ->

  listd (fun atms => listd pure_atom_denote un FF atms) inter TT

    (do_well3 sigma) s.

Proof with try solve [simpl; auto | congruence | inversion 1

  | apply listd_pure_atomd_pureu with (s0 := y);

    [ | exists x; apply join_comm; auto ]; solve [apply IHsigma; auto] ].

revert s; induction sigma... simpl; intros s [x [y [A [B C]]]].

remember a as b; destruct b... remember e as c; destruct c...

remember (next_in_dom v sigma) as d. if_tac... split...

exfalso. symmetry in Heqd. eapply nn_njoin; eauto.

Qed.



Lemma nl_lseg_in_sound x y sigma s1 s2 s :

  space_atom_denote (Next (Var x) y) s1 ->

  space_denote sigma s2 ->

  join s1 s2 s ->

  listd pure_atom_denote inter TT (lseg_in_dom_atoms x sigma) s.

Proof with try solve [simpl; auto; try congruence; try inversion A

  | destruct (join_assoc B (join_comm C)) as [q1 [q2 Q]];

      apply listd_pure_atomdi with (s0 := q1); [ | eexists; eauto ];

        solve [apply IHsigma with (s2 := w2); auto] ].

intros A B C. revert s s2 B C; induction sigma... intros s s2 B C.

simpl in B; destruct B as [w1 [w2 [B [D E]]]]. destruct a...

destruct e... unfold lseg_in_dom_atoms. if_tac...

try unfold Ident.eq in H.

subst x. split...

rewrite <- order_eqv_sound. simpl in A, D.

inversion D; subst. simpl. destruct (join_assoc B (join_comm C)) as [q [Q1 Q2]].

solve [eapply state_join_var_eq; eauto].

cut (stk w1 = stk s1); [ intro Heq; rewrite Heq in * | ].

rewrite H0 in A; destruct A as [A _].

exfalso. destruct B as [_ B]. destruct (join_assoc H3 B) as [q [Q1 Q2]].

eapply next_next_join_False with

  (s0 := h0) (s0' := hp s2) (s2 := hp s1) (s1 := hp s1); eauto.

econstructor; eauto.

apply join_sub_refl.

destruct (join_assoc (join_comm B) (join_comm C)) as [q [Q1 Q2]].

destruct (join_stacks_eq _ _ _ Q1)...

Qed.



Lemma ll_spooky x y z s1 s2 s1' s2' s :

  lseg (env_get (stk s1) x) (expr_denote y s1) (hp s1) ->

  lseg (env_get (stk s1') x) (expr_denote z s1') (hp s1') ->

  join_sub s1 s2 -> join_sub s1' s2' -> join s2 s2' s ->

  (pure_atom_denote (Eqv (Var x) y) || pure_atom_denote (Eqv (Var x) z))%pred s.

Proof with simpl; auto; try solve [congruence

  | left; simpl; unfold var_eq, expr_denote, stack_get; rewrite H;

      solve [unfold expr_denote, stack_get; rewrite Heq, Heq'; auto]].

intros A1 A2 B1 B2 C.

cut (stk s1 = stk s1'); [ intro Heq; rewrite Heq in * | ].

cut (stk s = stk s1'); [ intro Heq'; rewrite <- Heq' in * | ].

inversion A1; inversion A2; subst...

right; simpl; unfold var_eq, expr_denote, stack_get; rewrite H7.

solve [unfold expr_denote, stack_get; rewrite <- Heq'; auto].

cut (x' = x'0); [ intro Heqx; rewrite <- Heqx in *; clear Heqx | ].

exfalso. clear - H1 H3 H9 H11 B1 B2 C.

assert (D : joins s2 s2') by (apply (join_joins C)).

assert (E : join_sub h2 (hp s2')).

  destruct B2 as [sx1 [_ B2]]; destruct (join_assoc H11 B2) as [q [Q1 Q2]].

  solve [exists q; auto].

assert (F : join_sub h0 (hp s2)).

  destruct B1 as [sx1 [_ B1]]; destruct (join_assoc H3 B1) as [q [Q1 Q2]].

  solve [exists q; auto].

apply (next_next_join_False _ _ _ _ _ _ _ H1 F H9 E).

solve [destruct C as [_ C]; exists (hp s); auto].

solve [rewrite H8 in H0; inversion H0; auto].

destruct B2 as [sx B2]; destruct (join_assoc B2 (join_comm C)) as [q [Q1 Q2]].

destruct (join_stacks_eq _ _ _ Q2)...

destruct B1 as [sx1 B1]; destruct B2 as [sx2 B2].

destruct (join_assoc B1 C) as [q [Q1 Q2]].

destruct (join_assoc B2 (join_comm C)) as [q' [Q1' Q2']].

inversion Q2 as [[H1 H2] _]; inversion Q2' as [[H3 H4] _]...

Qed.



Lemma ll_lseg_in_sound x y sigma s1 s2 s :

  space_atom_denote (Lseg (Var x) y) s1 ->

  space_denote sigma s2 ->

  join s1 s2 s ->

  listd (listd pure_atom_denote un FF) inter TT (map (fun a0 =>

    [Eqv (Var x) y, a0]) (lseg_in_dom_atoms x sigma)) s.

Proof with try solve [simpl; auto; try congruence

  | destruct (join_assoc B (join_comm C)) as [q1 [q2 Q]];

      apply listd_pure_atomd_pureu with (s0 := q1); [ | eexists; eauto ];

        solve [apply IHsigma with (s2 := w2); auto]].

intros A B C. revert s s2 B C; induction sigma... intros s s2 B C.

simpl in B; destruct B as [w1 [w2 [B [D E]]]]. destruct a...

destruct e... unfold lseg_in_dom_atoms. if_tac...

try unfold Ident.eq in *. subst x. split...

simpl in A, D. inversion D; subst.

unfold list_denote; rewrite <- union_assoc; left; rewrite <- order_eqv_sound.

eapply (ll_spooky _ _ _ s1 s1 w1 s2 s A D); eauto.

apply join_sub_refl.  econstructor; eauto.

unfold list_denote; rewrite <- union_assoc; left; rewrite <- order_eqv_sound.

eapply (ll_spooky _ _ _ s1 s1 w1 s2 s A D); eauto.

apply join_sub_refl.  econstructor; eauto.

Qed.



Lemma do_well4_5_sound sigma s :

  space_denote sigma s ->

  listd (fun atms => listd pure_atom_denote un FF atms) inter TT

    (do_well4_5 sigma) s.

Proof with simpl; auto; try congruence; try solve [

  apply listd_pure_atomd_pureu with (s0 := y);

    [ | exists x; apply join_comm; auto ]; apply IHsigma; auto].

revert s; induction sigma... intros s [x [y [A [B C]]]].

remember a as b; destruct b. destruct e...

rewrite listd_app, (@listd_unfold_inter _ state); split...

generalize (nl_lseg_in_sound _ _ _ _ _ _ B C A); intro D.

clear - D. set (l := lseg_in_dom_atoms v sigma) in D |- *. induction l...

solve [destruct D as [D E]; split; [ left; auto | ]; apply IHl; auto].

destruct e... remember (lseg_in_dom_atoms v sigma) as l. destruct l...

rewrite listd_app; split... unfold normalize_atoms.

rewrite (@listd_sort_uniq_un _ state) with (cmp := pure_atom_cmp).

2: apply pure_atom_cmp_eq.

generalize (ll_lseg_in_sound _ _ _ _ _ _ B C A); rewrite <- Heql.

intro D. simpl in D. destruct D as [D E]. destruct D as [D | D].

left. rewrite <- order_eqv_sound...

destruct D. right; left. rewrite <- order_eqv_sound... inversion H.

rewrite (@listd_unfold_inter _ state); split...

generalize (ll_lseg_in_sound _ _ _ _ _ _ B C A); rewrite <- Heql.

simpl; intros [D E]. clear - E.

induction l... simpl in E; destruct E as [E F].

split... unfold normalize_atoms. rewrite (@listd_sort_uniq_un _ state).

2: apply pure_atom_cmp_eq.

destruct E as [E | E]. left; rewrite <- order_eqv_sound...

destruct E; [ right; left; rewrite <- order_eqv_sound; auto | inversion H].

Qed.



Lemma do_well_sound sigma s :

  space_denote sigma s ->

  listd (fun atms => listd pure_atom_denote un FF atms) inter TT

    (do_well sigma) s.

Proof with auto.

intro A. unfold do_well. do 2 (rewrite listd_app, (@listd_unfold_inter _ state)).

split. split... apply do_well1_2_sound... rewrite (@listd_unfold_inter _ state).

split. apply do_well3_sound... apply do_well4_5_sound...

Qed.



Lemma factor_hyp_lem gamma delta l s :

  (listd pure_atom_denote inter TT gamma s ->

    listd (fun atms s => listd pure_atom_denote un FF (atms ++ delta) s)

    inter TT l s) ->

  listd

     (fun (atms : list pure_atom) (s' : state) =>

      listd pure_atom_denote inter TT gamma s' ->

      listd pure_atom_denote un FF (atms ++ delta) s') inter TT l s.

Proof with simpl; auto.

intro A; induction l... split. intro B; specialize (A B); simpl in A; destruct A as [A C]...

apply IHl... intro B. specialize (A B). simpl in A; destruct A as [A C]...

Qed.



Lemma factor_hyp_lem_aux delta l s :

  (listd (listd pure_atom_denote un FF) inter TT l ||

    listd pure_atom_denote un FF delta)%pred s ->

  listd (fun atms s' => listd pure_atom_denote un FF (atms ++ delta) s')

    inter TT l s.

Proof with simpl; auto.

intro A. induction l... split. simpl in A; destruct A as [[A B] | ].

rewrite listd_app, (@listd_unfold_un _ state); left...

rewrite listd_app, (@listd_unfold_un _ state); right...

apply IHl... simpl in A; destruct A as [[? ?] | ]. left... right...

Qed.



Lemma do_wellformed_sound cl :

  clause_denote cl |-- setd clause_denote inter TT (do_wellformed cl).

Proof with simpl; auto with typeclass_instances; try congruence.

intros s A. unfold do_wellformed. destruct cl...

apply setd_empty_set.

apply clause_setd_listd.

apply listd_map_pred

  with (f := fun atms s => listd pure_atom_denote inter TT gamma s ->

    listd pure_atom_denote un FF (atms ++ delta) s).

intros l B C. specialize (B C). unfold normalize_atoms.

rewrite (@listd_sort_uniq_un _ state). 2: apply pure_atom_cmp_eq.

rewrite listd_map, listd_app; [ | intros a b'; rewrite <- order_eqv_sound; auto ].

rewrite (@listd_unfold_un _ state).

rewrite listd_app in B; rewrite (@listd_unfold_un _ state) in B...

apply factor_hyp_lem... intro B; specialize (A B)... apply factor_hyp_lem_aux...

rewrite (@listd_unfold_un _ state) in A. destruct A as [A | A].

right... left. apply do_well_sound...

unfold space_denote; rewrite (@listd_sort_sepcon _ state)...

apply setd_empty_set.

Qed.



End WF_Sound.



