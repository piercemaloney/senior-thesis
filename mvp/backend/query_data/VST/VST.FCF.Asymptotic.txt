
Set Implicit Arguments.

Require Import FCF.StdNat.
(* FCF.StdNat:
Set Implicit Arguments.

Require Export Arith.
Require Export Omega.
Require Export Arith.Div2.
Require Export Coq.Numbers.Natural.Peano.NPeano. 
Require Import Coq.NArith.BinNat.

Lemma mult_same_r : forall n1 n2 n3,
  n3 > 0 ->
  n1 * n3 = n2 * n3 ->
  n1 = n2.

Lemma mult_same_l : forall n3 n1 n2,
  n3 > 0 ->
  n3 * n1 = n3 * n2 ->
  n1 = n2.

Lemma mult_gt_0 : forall n1 n2,
  n1 > 0 ->
  n2 > 0 ->
  n1 * n2 > 0.

Lemma minus_eq_compat : forall n1 n2 n3 n4,
  n1 = n2 ->
  n3 = n4 ->
  n1 - n3 = n2 - n4.

Lemma plus_eq_compat : forall n1 n2 n3 n4,
  n1 = n2 ->
  n3 = n4 ->
  n1 + n3 = n2 + n4.

Lemma minus_diag_eq : forall n1 n2,
  n1 = n2 ->
  n1 - n2 = 0.

Lemma le_eq : forall n1 n2,
  n1 = n2 ->
  n1 <= n2.

Lemma minus_add_assoc : forall n1 n2 n3,
  (n3 <= n2)%nat ->
  (n1 + (n2 - n3) = n1 + n2 - n3)%nat.

Definition posnat := {n : nat | n > 0}.

Definition posnatToNat(p : posnat) :=
  match p with
    | exist _ n _ => n
  end.

Inductive posnatEq : posnat -> posnat -> Prop :=
  | posnatEq_intro : 
    forall (n1 n2 : nat) pf1 pf2,
      n1 = n2 ->
      posnatEq (exist _ n1 pf1) (exist _ n2 pf2).

Definition posnatMult(p1 p2 : posnat) : posnat :=
    match (p1, p2) with
      | (exist _ n1 pf1, exist _ n2 pf2) =>
        (exist (fun n => n > 0) (n1 * n2) (mult_gt_0 pf1 pf2))
    end.

Lemma posnatMult_comm : forall p1 p2,
  (posnatEq (posnatMult p1 p2) (posnatMult p2 p1)).

Coercion posnatToNat : posnat >-> nat.

Lemma posnat_pos : forall (p : posnat),
  p > 0.

Definition natToPosnat(n : nat)(pf : nz n) :=
  (exist (fun x => x > 0) n agz).

Notation "'pos' x" := (@natToPosnat x _) (at level 40).

Fixpoint expnat n1 n2 :=
  match n2 with
    | 0 => 1
    | S n2' =>
      n1 * (expnat n1 n2')
  end.

Theorem expnat_pos : forall x n,
  x > 0 ->
  expnat x n > 0.

Lemma div2_le : forall n,
  le (div2 n) n.

Lemma div2_ge_double : forall n, 
  n >= (div2 n) + (div2 n).

Local Open Scope N_scope.
Definition modNat (n : nat)(p : posnat) : nat :=
  N.to_nat ((N.of_nat n) mod (N.of_nat p)).

Lemma Npos_nz : forall p, 
  Npos p <> N0.

Lemma modNat_plus : forall n1 n2 p,
    (modNat (n1 + n2) p = modNat ((modNat n1 p) + n2) p)%nat.

Lemma modNat_arg_eq : forall (p : posnat),
  modNat p p = O.

Lemma of_nat_ge_0 : forall n,
  0 <= N.of_nat n.

Lemma of_posnat_gt_0 : forall (p : posnat),
  0 < N.of_nat p.

Lemma modNat_lt : forall x p, (modNat x p < p)%nat.

Lemma modNat_eq : forall (n : posnat) x, (x < n -> modNat x n = x)%nat.

Definition modNatAddInverse (n : nat)(p : posnat) :=
  (p - (modNat n p))%nat.

Lemma modNatAddInverse_correct_gen : forall x y p,
  modNat x p = modNat y p ->
  modNat (x + modNatAddInverse y p) p = O.

Lemma modNatAddInverse_correct : forall n p,
    modNat (n + modNatAddInverse n p) p = O.

Lemma modNat_correct : forall x (p : posnat),
  exists k, (x = k * p + modNat x p)%nat.

Lemma modNat_divides : forall x p,
  modNat x p = O ->
  exists k, (x = k * p)%nat.

Local Open Scope nat_scope.
Lemma modNatAddInverse_sum_0 : forall x y p,
  modNat (x + (modNatAddInverse y p)) p = O ->
  modNat x p = modNat y p.

Lemma modNat_correct_if : forall x y z (p : posnat),
  x * p + y = z ->
  modNat z p = modNat y p.

Lemma modNat_mult : forall x (p : posnat),
  modNat (x * p) p = 0.

Lemma modNat_add_same_l : forall x y z p,
  modNat (x + y) p = modNat (x + z) p ->
  modNat y p = modNat z p.

Lemma modNat_add_same_r : forall x y z p,
  modNat (y + x) p = modNat (z + x) p ->
  modNat y p = modNat z p.

Lemma expnat_base_S : forall n k,
  ((expnat k n) + n * (expnat k (pred n)) <= expnat (S k) n)%nat.

Lemma expnat_base_S_same : forall n,
  n > 0 ->
  (2 * (expnat n n) <= expnat (S n) n)%nat.

Lemma sqrt_le_lin_gen : forall a b,
  (a <= b ->
    Nat.sqrt a <= b)%nat.

Lemma div2_le_mono : forall n1 n2,
  (n1 <= n2 -> 
    div2 n1 <= div2 n2)%nat.

Lemma div2_ge : forall n n',
  n >= n' ->
  forall x,
    (n' = 2 * x)%nat ->
    div2 n >= x.
  
Lemma expnat_2_ge_1 : forall n,
  (1 <= expnat 2 n)%nat.

Lemma le_expnat_2 : forall n,
  (n <= expnat 2 n)%nat.

Lemma expnat_1 : forall k,
  expnat 1%nat k = 1%nat.

Theorem expnat_base_le : 
  forall k n1 n2,
    n1 <= n2 ->
    expnat n1 k <=
    expnat n2 k.

Theorem expnat_double_le : 
  forall k n,
    n >= 2 ->
    expnat n (S k) >= 2 * expnat n k.

Theorem nat_half_plus : 
  forall x, 
    x > 1 ->
    exists a b,
      a > 0 /\ b <= 1 /\ x = 2 * a + b.

Theorem log2_div2 : 
  forall x y,
    S y = Nat.log2 x ->

Lemma log2_0 : 
  Nat.log2 0 = 0.

Theorem expnat_0 : 
  forall k,
    k > 0 ->
    expnat 0 k = 0.

Theorem expnat_plus : 
  forall k1 k2 n,
    expnat n (k1 + k2) = expnat n k1 * expnat n k2.

Theorem expnat_ge_1 :
  forall k n,
    n > 0 ->
    1 <= expnat n k.

Theorem expnat_exp_le : 
  forall n2 n4 n,
    (n2 > 0 \/ n > 0) ->
    n2 <= n4 ->
    expnat n n2 <= expnat n n4.

Lemma mult_lt_compat : 
  forall a b c d,
    a < b ->
    c < d ->
    a * c < b * d.

Theorem orb_same_eq_if : 
  forall a b c,
    (a = false -> b = c) ->
    orb a b = orb a c. *)

Definition polynomial (f : nat -> nat) :=
    exists x c1 c2, forall n,
      (f n <= c1 * expnat n x + c2)%nat.

Definition polynomial_nz(f : nat -> nat) :=
  exists x c1 c2, 
    x > 0 /\ c1 > 0 /\ c2 > 0 /\
    forall n, 
      (f n <= c1 * expnat n x + c2)%nat.

Theorem polynomial_nz_equiv : 
  forall f, 
    polynomial f ->
    polynomial_nz f.
  
  intuition.
  unfold polynomial, polynomial_nz in *.
  do 3 (destruct H).
  exists (S x).
  exists (S x0).
  exists (x0 + S x1).
  intuition.
  rewrite H.
  rewrite plus_assoc.
  eapply plus_le_compat; intuition.
  simpl.
  destruct (eq_nat_dec x 0).
  subst.
  simpl.
  repeat rewrite mult_1_r.
  rewrite <- plus_0_l at 1.
  eapply plus_le_compat; intuition.
  
  rewrite <- plus_0_l at 1.
  rewrite <- plus_0_r at 1.
  
  eapply plus_le_compat; intuition.
  eapply plus_le_compat; intuition.
  eapply mult_le_compat; intuition.
  destruct (eq_nat_dec n 0); subst.
  
  rewrite expnat_0;
    omega.
  
  rewrite <- mult_1_l at 1.
  eapply mult_le_compat; intuition.
Qed.        

Theorem polynomial_plus : 
  forall f1 f2 ,
    polynomial f1 ->
    polynomial f2 ->
    polynomial (fun n => f1 n + f2 n).
  
  intuition.
  
  apply polynomial_nz_equiv in H.
  apply polynomial_nz_equiv in H0.
  
  unfold polynomial, polynomial_nz in *.
  
  Ltac des := 
    match goal with
      | [H : exists _, _ |- _] => destruct H
    end.
  repeat des.
  intuition.
  exists (max x2 x).
  exists (x3 + x0).
  exists (x4 + x1).
  intuition.
  
  eapply le_trans.
  eapply plus_le_compat.
  eapply H6; trivial.
  eapply H7; trivial.
  rewrite mult_plus_distr_r.
  repeat rewrite plus_assoc.
  eapply plus_le_compat; trivial.
  rewrite plus_comm.
  rewrite plus_assoc.
  eapply plus_le_compat; trivial.
  rewrite plus_comm.
  eapply plus_le_compat;
    eapply mult_le_compat; intuition.
  
  eapply expnat_exp_le; intuition.
  eapply expnat_exp_le; intuition.
Qed.

Theorem polynomial_const : 
  forall c, 
    polynomial (fun n => c).
  
  intuition.
  unfold polynomial.
  exists 0.
  exists 0.
  exists c.
  intuition.
Qed.

Theorem polynomial_ident :
  polynomial (fun n => n).
  
  unfold polynomial.
  intuition.
  exists 1.
  exists 1.
  exists 0.
  intuition.
  simpl.
  omega.
  
Qed.

Theorem polynomial_mult : 
  forall f1 f2 ,
    polynomial f1 ->
    polynomial f2 ->
    polynomial (fun n => f1 n * f2 n).
  
  intuition.
  apply polynomial_nz_equiv in H.
  apply polynomial_nz_equiv in H0.
  
  unfold polynomial, polynomial_nz in *.
  repeat des.
  intuition.
  exists (x + x2).
  exists (3 * (x3 * x0 * x4 * x1)).
  exists (x4 * x1).
  intuition.
  eapply le_trans.
  eapply mult_le_compat.
  eapply H6; intuition.
  eapply H7; intuition.
  repeat rewrite mult_plus_distr_l.
  repeat rewrite mult_plus_distr_r.
  
  rewrite plus_assoc.
  eapply plus_le_compat; trivial.
  
  rewrite expnat_plus.
  simpl.
  rewrite plus_0_r.
  repeat rewrite mult_plus_distr_r.
  rewrite plus_assoc.
  eapply plus_le_compat.
  eapply plus_le_compat.
  rewrite (mult_comm (expnat n x)).
  repeat rewrite mult_assoc.
  eapply mult_le_compat; intuition.
  rewrite mult_comm.
  rewrite mult_assoc.
  eapply mult_le_compat; intuition.
  rewrite <- mult_1_r at 1.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; intuition.
  eapply mult_le_compat; intuition.
  rewrite mult_comm.
  intuition.
  
  destruct (eq_nat_dec n 0); subst.
  repeat rewrite expnat_0.
  simpl.
  repeat rewrite mult_0_r.
  intuition.
  trivial.
  trivial.
  rewrite (mult_comm (expnat n x)).
  repeat rewrite mult_assoc.
  eapply mult_le_compat; trivial.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; trivial.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; trivial.
  rewrite mult_comm.
  eapply mult_le_compat; trivial.
  rewrite <- mult_1_l at 1.
  eapply mult_le_compat; trivial.
  eapply expnat_ge_1.
  omega.
  
  destruct (eq_nat_dec n 0); subst.
  repeat rewrite expnat_0.
  simpl.
  repeat rewrite mult_0_r.
  intuition.
  trivial.
  trivial.
  rewrite (mult_comm (expnat n x)).
  repeat rewrite mult_assoc.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; trivial.
  rewrite <- mult_assoc.
  rewrite (mult_comm (expnat n x2)).
  rewrite mult_assoc.
  eapply mult_le_compat; trivial.
  eapply mult_le_compat; trivial.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; trivial.
  rewrite <- mult_1_r at 1.
  eapply mult_le_compat; trivial.
  eapply expnat_ge_1.
  omega.
Qed.     
      
Require Import FCF.Rat.
(* FCF.Rat:
Set Implicit Arguments.

Require Import Omega.
Require Import List.
Require Import FCF.StdNat.
Require Import Arith.
Require Import Lia.

Inductive Rat :=
    RatIntro : nat -> posnat -> Rat.

Definition ratCD(r1 r2 : Rat) : (nat * nat * posnat) :=
  match (r1, r2) with
    | (RatIntro n1 d1, RatIntro n2 d2) =>
      ((n1 * d2), (n2 * d1), (posnatMult d1 d2))
  end.

Definition ratMult(r1 r2 : Rat) : Rat :=
  match (r1, r2) with
    | (RatIntro n1 d1, RatIntro n2 d2) =>
      RatIntro (n1 * n2) (posnatMult d1 d2)
  end.

Definition rat1 := (RatIntro 1 (pos 1)).
Definition rat0 := (RatIntro 0 (pos 1)).

Definition ratAdd(r1 r2 : Rat) : Rat :=
  match ratCD r1 r2 with
    | (n1, n2, d) => 
      RatIntro (n1 + n2) d
  end.

Definition ratSubtract(r1 r2: Rat) : Rat :=
  match ratCD r1 r2 with
    | (n1, n2, d) =>
      RatIntro (n1 - n2) d
  end.

Definition beqRat(r1 r2 : Rat) :=
  match (ratCD r1 r2) with
    | (n1, n2, _) => 
      if (eq_nat_dec n1 n2) then true else false
  end.

Definition bleRat(r1 r2 : Rat) :=
  match (ratCD r1 r2) with
    | (n1, n2, _) => 
      if (le_gt_dec n1 n2) then true else false
  end.

Definition eqRat(r1 r2 : Rat) :=
  beqRat r1 r2 = true.

Definition leRat(r1 r2 : Rat) := 
  bleRat r1 r2 = true.

Definition maxRat(r1 r2 : Rat) :=
  if (bleRat r1 r2) then r2 else r1.

Definition minRat(r1 r2 : Rat) :=
  if (bleRat r1 r2) then r1 else r2.

Definition ratDistance(r1 r2 : Rat) :=
  ratSubtract (maxRat r1 r2) (minRat r1 r2).

Ltac rattac_one := 
  match goal with 
    
    | [|- posnatMult ?x1 ?x2 = posnatMult ?x2 ?x1] => apply posnatMult_comm
    | [|- posnatToNat (posnatMult ?x1 ?x2) = posnatToNat (posnatMult ?x2 ?x1)] => rewrite posnatMult_comm; trivial
    | [|- ?x1 * ?x2 = ?x2 * ?x1 ] => apply mult_comm
    | [|- (mult (?x1 + ?x2) _)  = (mult (?x2 + ?x1) _ )] => f_equal
    | [|- ?x1 * ?x2 * _ = ?x2 * ?x1 * _ ] => f_equal
    | [ |- posnatToNat ?p > 0 ] => destruct p; unfold posnatToNat; omega
      
    | [H1 : ?n * ?x = ?n0 * ?x1, H2: ?n1 * ?x1 = ?n * ?x0 |- ?n1 * ?x = ?n0 * ?x0 ] => eapply (@mult_same_l x1) 
    | [H : ?x = ?n * (posnatToNat ?p) |- ?x = (posnatToNat ?p) * ?n ] => rewrite H
    | [H : RatIntro _ _ = RatIntro _ _ |- _ ] => inversion H; clear H; subst
    | [H : (eqRat _ _) |- _ ] => unfold eqRat, beqRat in H
    | [H : (leRat _ _) |- _ ] => unfold leRat, bleRat in H
    | [H : ?r = RatIntro _ _ |- context[match ?r with | RatIntro _ _ => _ end] ] => rewrite r
    
    | [|- context[match ?r with | RatIntro _ _ => _ end] ] => case_eq r; intuition
    | [H : (_ , _) = (_ , _) |- _ ] => inversion H; clear H; subst
    | [|- (_, _) = (_, _) ] => f_equal
    | [H: context[ratCD _ _] |- _ ] => unfold ratCD in *
    | [H : context[match rat0 with | RatIntro _ _ => _ end ] |- _ ] => unfold rat0 in H
    | [H1 : context[match ?r with | RatIntro _ _ => _ end], H2 : ?r = RatIntro _ _ |- _ ] => rewrite H2 in H1
    | [H : context[match ?r with | RatIntro _ _ => _ end ] |- _ ] => case_eq r; intuition
    | [|- context[let (_, _) := ?x in _] ] => case_eq x; intuition
    | [H : context[ratAdd _ _] |- _ ] => unfold ratAdd in H    
    | [H : context[ratMult _ _] |- _ ] => unfold ratMult in H   
    | [H: context [eq_nat_dec ?x ?y] |- _] => destruct (eq_nat_dec x y)
    | [H: context [le_gt_dec ?x ?y] |- _] => destruct (le_gt_dec x y)
    | [|- (if (eq_nat_dec ?x ?y) then true else false) = true ] => assert (x = y); destruct (eq_nat_dec x y); trivial
     | [|- (if (le_gt_dec ?x ?y) then true else false) = true ] => assert (x <= y); [idtac | destruct (le_gt_dec x y); trivial]
    | [|- context[posnatMult _ _ ] ] => unfold posnatMult
    | [|- (eqRat _ _) ] => unfold eqRat, beqRat
    | [|- (leRat _ _) ] => unfold leRat, bleRat
    | [|- (posnatEq _ _ ) ] => econstructor
    | [|- context[(posnatToNat _)] ] => unfold posnatToNat in *
    | [H : context[let (_, _) := ?p in _] |- _] => destruct p
    end.
Ltac rattac :=
  intuition; unfold ratCD in *; 
    repeat (rattac_one; subst); repeat rewrite mult_1_r; repeat rewrite plus_0_r; trivial; try congruence; try omega.

Lemma ratCD_comm : forall r1 r2 n1 n2 d n1' n2' d',
  ratCD r1 r2 = (n1, n2, d) ->
  ratCD r2 r1 = (n1', n2', d') ->
  n1 = n2' /\ n1' = n2 /\ (posnatEq d d').

Infix "*" := ratMult : rat_scope.
Local Open Scope rat_scope.

Notation "n / d" := (RatIntro n (pos d)) : rat_scope.

Notation "0" := rat0 : rat_scope.
Notation "1" := rat1 : rat_scope.

Infix "+" := ratAdd : rat_scope.

Delimit Scope rat_scope with rat.

Notation " |  a - b |" := (ratDistance a%rat b%rat) (at level 30, a at next level, b at next level) : rat_scope.

Infix "<=" := leRat : rat_scope.
Infix "==" := eqRat (at level 70) : rat_scope.

Theorem le_Rat_dec : forall r1 r2,
  {r1 <= r2} + {~r1 <= r2}.

Theorem eq_Rat_dec : forall r1 r2,
  {r1 == r2} + {~r1 == r2}.

Theorem eqRat_refl : forall r,
  eqRat r r.

Theorem eqRat_symm : forall r1 r2,
  eqRat r1 r2 ->
  eqRat r2 r1.

Theorem eqRat_trans : forall r1 r2 r3,
  eqRat r1 r2 ->
  eqRat r2 r3 ->
  eqRat r1 r3.

Theorem leRat_refl : forall r,
  leRat r r.

Lemma mult_le_compat_r_iff_h : forall n2 n3 n1,
    n1 > O ->
    (n2 * n1 <= n3 * n1)%nat ->
    (n2 <= n3)%nat.

Lemma mult_le_compat_r_iff : forall n1 n2 n3,
    n1 > O ->
    (n2 * n1 <= n3 * n1)%nat ->
    (n2 <= n3)%nat.

Theorem leRat_trans : forall r1 r2 r3,
  leRat r1 r2 ->
  leRat r2 r3 ->
  leRat r1 r3.

Theorem eqRat_impl_leRat : forall r1 r2,
  eqRat r1 r2 ->
  leRat r1 r2.

Theorem leRat_impl_eqRat : forall r1 r2,
  leRat r1 r2 ->
  leRat r2 r1 ->
  eqRat r1 r2.

Require Import Setoid.

Add Parametric Relation : Rat leRat
  reflexivity proved by leRat_refl
  transitivity proved by leRat_trans
    as leRat_rel.

Add Parametric Relation : Rat eqRat 
  reflexivity proved by eqRat_refl
  symmetry proved by eqRat_symm
  transitivity proved by eqRat_trans
  as eqRat_rel.

Require Import RelationClasses.
Require Import Coq.Classes.Morphisms.

Global Instance Subrelation_eq_le : subrelation eqRat leRat.

Global Instance eqRat_resp_leRat : 
  forall x,
    Proper (eqRat ==> Basics.flip Basics.impl)

Local Open Scope rat_scope.
Theorem rat0_le_all : forall r,
  0 <= r.

Theorem rat1_ne_rat0 : ~ (eqRat 1 0).

Theorem rat0_ne_rat1 : ~ (eqRat 0 1).

Theorem ratAdd_comm : forall r1 r2,
  r1 + r2 == r2 + r1.

Theorem ratAdd_0_r : forall r,
  r == r + 0.

Theorem ratAdd_0_l : forall r,
  r == 0 + r.

Theorem ratMult_comm : forall (r1 r2 : Rat),
  eqRat (ratMult r1 r2) (ratMult r2 r1).

Theorem ratAdd_assoc : forall r1 r2 r3,
  r1 + r2 + r3 == r1 + (r2 + r3).

Local Open Scope rat_scope.
Theorem ratMult_assoc : forall r1 r2 r3,
  r1 * r2 * r3 == r1 * (r2 * r3).

Lemma ratAdd_eqRat_compat_l : forall r1 r2 r3,
  eqRat r1 r2 ->
  r1 + r3 == r2 + r3.

Theorem ratAdd_eqRat_compat : forall r1 r2 r3 r4,
  eqRat r1 r2 ->
  eqRat r3 r4 ->
  r1 + r3 == r2 + r4.

Lemma ratAdd_leRat_compat_l : forall r1 r2 r3,
  leRat r1 r2 ->
  r1 + r3 <= r2 + r3.

Theorem ratAdd_leRat_compat : forall r1 r2 r3 r4,
  leRat r1 r2 ->
  leRat r3 r4 ->
  r1 + r3 <= r2 + r4.

Theorem ratMult_leRat_compat : forall (r1 r2 r3 r4 : Rat),
  leRat r1 r2 ->
  leRat r3 r4 ->
  leRat (ratMult r1 r3) (ratMult r2 r4).

Theorem ratMult_eqRat_compat : forall (r1 r2 r3 r4 : Rat),
  eqRat r1 r2 ->
  eqRat r3 r4 ->
  eqRat (ratMult r1 r3) (ratMult r2 r4).

Theorem ratAdd_0 : forall r1 r2,
  r1 + r2 == 0 <->
  r1 == 0 /\ r2 == 0.

Theorem ratAdd_nz : forall r1 r2,
  ~(r1 + r2 == 0) <->
  (~r1 == 0) \/ (~r2 == 0).

Theorem rat_num_0 : forall d,
  (RatIntro O d) == 0.

Lemma ratMult_0_l : forall r,
  0 * r == 0.

Lemma ratMult_0_r : forall r,
  r * 0 == 0.

Lemma ratMult_1_l : forall r,
  1 * r == r.

Theorem ratMult_0 : forall r1 r2,
  r1 * r2 == 0 <-> 
  r1 == 0 \/ r2 == 0.

Theorem ratMult_nz : forall r1 r2,
  (~r1 * r2 == 0) <->
  (~r1 == 0) /\ (~r2 == 0).

Theorem leRat_num : forall n1 n2 d,
  le n1 n2 ->
  leRat (RatIntro n1 d) (RatIntro n2 d).

Theorem eqRat_terms : forall n1 d1 n2 d2,
  n1 = n2 ->
  posnatToNat d1 = posnatToNat d2 ->
  eqRat (RatIntro n1 d1) (RatIntro n2 d2).

Lemma leRat_mult : forall n1 n2 d1 d2 (pf1 : d1 > 0) (pf2 : d2 > 0),
                     RatIntro n1 (exist (fun d => d > 0) _ pf1) <= RatIntro n2 (exist (fun d => d > 0) _ pf2) ->
                     (n1 * d2 <= n2 * d1)%nat.

Lemma nat_minus_eq : forall (n1 n2 : nat),
                       (n1 <= n2)%nat ->
                       n2 - n1 = O ->
                       n1 = n2.

Lemma bleRat_total : forall r1 r2,
                       bleRat r1 r2 = false -> bleRat r2 r1 = true.

Theorem ratIdentityIndiscernables : forall r1 r2,
  r1 == r2 <->
  ratDistance r1 r2 == rat0.

Lemma ratSubtract_partition : forall r1 r2 r3,
  r1 <= r2 ->
  r2 <= r3 ->
  (ratSubtract r3 r1) == (ratSubtract r2 r1) + (ratSubtract r3 r2).

Lemma ratAdd_any_leRat_l : forall r1 r2 r3,
  r1 <= r3 ->
  r1 <= r3 + r2.

Lemma ratAdd_any_leRat_r : forall r1 r2 r3,
  r1 <= r2 ->
  r1 <= r3 + r2.

Lemma ratAdd_eq_impl_leRat_l : forall r1 r2 r3,
  r1 == r2 + r3 ->
  r2 <= r1.

Lemma ratAdd_eq_impl_leRat_r : forall r1 r2 r3,
  r1 == r2 + r3 ->
  r3 <= r1.

Lemma ratSubtract_leRat_r : forall r1 r2 r3,
  r1 <= r2 ->
  ratSubtract r3 r2 <= ratSubtract r3 r1.

Lemma ratSubtract_leRat_l:
  forall r1 r2 r3 : Rat, r1 <= r2 -> ratSubtract r1 r3 <= ratSubtract r2 r3.

Lemma ratSubtract_leRat : forall r1 r2 r3 r4,
  r1 <= r2 ->
  r3 <= r4 ->
  ratSubtract r1 r4 <= ratSubtract r2 r3.

Lemma ratSubtract_0 : forall r1 r2,
  r1 <= r2 ->
  ratSubtract r1 r2 == 0.

Lemma ratSubtract_partition_leRat : forall r3 r1 r2 d1 d2,
  ratSubtract r1 r3 <= d1 ->
  ratSubtract r3 r2 <= d2 -> 
  ratSubtract r1 r2 <= d1 + d2.

Theorem ratTriangleInequality : forall r1 r2 r3,
  (ratDistance r1 r2) <= (ratDistance r1 r3) + (ratDistance r3 r2).

Theorem ratMult_1_r : forall r,
  r * 1 == r.

Lemma minus_le : forall n1 n2 n3,
    (n1 <= n3 ->
     n1 - n2 <= n3)%nat.

Theorem ratSubtract_le : forall r1 r2 d,
  r1 <= d ->
  ratSubtract r1 r2 <= d.

Theorem ratDistance_le_trans : forall r1 r2 r3 d1 d2,
  ratDistance r1 r2 <= d1 ->
  ratDistance r2 r3 <= d2 ->
  ratDistance r1 r3 <= d1 + d2.

Theorem ratDistance_le : forall r1 r2 d,
  r1 <= d ->
  r2 <= d ->
  (ratDistance r1 r2) <= d.

Lemma ratSubtract_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  ratSubtract r1 r2 == ratSubtract r3 r4.

Theorem leRat_antisymm : forall r1 r2,
  r1 <= r2 ->
  r2 <= r1 ->
  r1 == r2.

Lemma maxRat_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  maxRat r1 r2 == maxRat r3 r4.

Lemma minRat_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  minRat r1 r2 == minRat r3 r4.

Theorem ratDistance_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  ratDistance r1 r2 == ratDistance r3 r4.

Lemma ratSubtract_add_same_r : forall r1 r2 r3,
  r1 <= r3 ->
  ratSubtract (r3 + r2) (r1 + r2) == ratSubtract r3 r1.

Lemma ratSubtract_add_same_l : forall r1 r2 r3,
  r1 <= r3 ->
  ratSubtract (r2 + r3) (r2 + r1) == ratSubtract r3 r1.

Lemma minus_plus_assoc : forall n1 n2 n3,
  (n3 <= n2 ->
    (n1 + n2) - n3 = n1 + (n2 - n3))%nat.

Lemma ratSubtract_ratAdd_assoc: forall r1 r2 r3,
  r3 <= r2 ->
  ratSubtract (r1 + r2) r3 == r1 + (ratSubtract r2 r3).

Lemma ratAdd_add_same_r : forall r1 r2 r3,
  r1 + r2 == r3 + r2 ->
  r1 == r3.

Lemma ratAdd_add_same_l : forall r1 r2 r3,
  r2 + r1 == r2 + r3 ->
  r1 == r3.

Lemma ratDistance_add_same_r : forall r1 r2 r3,
  (ratDistance (r1 + r2) (r3 + r2)) == (ratDistance r1 r3).

Lemma ratDistance_add_same_l : forall r1 r2 r3,
  (ratDistance (r2 + r3) (r2 + r1)) == (ratDistance r3 r1).

Theorem rat_distance_of_sum : forall r1 r2 r3 r4,
  ratDistance (r1 + r2) (r3 + r4) <= (ratDistance r1 r3) + (ratDistance r2 r4).

Theorem ratMult_distrib : forall r1 r2 r3,
  r1 * (r2 + r3) == r1 * r2 + r1 * r3.

Theorem num_dem_same_rat1 : forall n d,
  n = posnatToNat d ->
  RatIntro n  d == rat1.

Lemma ratAdd_num : forall n1 n2 d,
  RatIntro (n1 + n2) d == (ratAdd (RatIntro n1 d) (RatIntro n2 d)).

Lemma ratMult_denom : forall n d1 d2,
  (RatIntro n (posnatMult d1 d2)) == (ratMult (RatIntro 1 d1) (RatIntro n d2)).

Lemma ratMult_num_den : forall n1 n2 d1 d2,
  (RatIntro (n1 * n2)%nat (posnatMult d1 d2)) == (RatIntro n1 d1) * (RatIntro n2 d2).

Theorem ratAdd_den_same : forall n1 n2 d,
  RatIntro (n1 + n2)%nat d == (RatIntro n1 d) + (RatIntro n2 d).

Lemma rat_mult_den : forall n d1 d2,
  (RatIntro n (posnatMult d1 d2)) == (RatIntro 1 d1) * (RatIntro n d2).

Lemma ratOneHalf_add: 
  1 / 2 + 1 / 2 == 1.

Theorem ratS_num : forall n,
  (S n) / (S O) == 1 + (n / (S O)).

Theorem ratDistance_comm : forall r1 r2,
  eqRat (ratDistance r1 r2) (ratDistance r2 r1).

Theorem ratMult_distrib_r : forall r1 r2 r3,
  ratMult (ratAdd r2 r3) r1  == ratAdd (ratMult r2 r1) (ratMult r3 r1).

Lemma ratSubtract_ratAdd_inverse : forall r1 r2,
  ratSubtract (r1 + r2) r1 == r2.

Lemma ratSubtract_ratAdd_inverse_2 : forall r1 r2,
  r2 <= r1 ->
  r2 + ratSubtract r1 r2 == r1.

Lemma leRat_difference_exists : forall r1 r2,
  r2 <= r1 ->
  exists r3, r1 == r2 + r3.

Lemma ratSubtract_ratMult_le : forall r1 r2 r3 r4,
  r1 <= r2 ->
  r3 <= r4 ->
  ratSubtract (r2 * r4) (r1 * r3) == (ratSubtract r2 r1) * r3 + (ratSubtract r4 r3) * r1 + (ratSubtract r2 r1) * (ratSubtract r4 r3).

Lemma ratSubtract_eq_r : forall r1 r2 r3,
  r2 <= r1 ->
  r3 <= r1 ->
  (ratSubtract r1 r2) == (ratSubtract r1 r3) ->
  r2 == r3.

Lemma ratDistance_le_max : forall r1 r2 r3 v,
  r1 <= r2 ->
  r2 <= r3 ->
  (ratDistance r2 v) <= (maxRat (ratDistance r1 v) (ratDistance r3 v)).

Lemma maxRat_leRat_same : forall r1 r2 r3,
  r1 <= r3 ->
  r2 <= r3 ->
  maxRat r1 r2 <= r3.

Lemma ratMult_3_ratAdd : forall r,
  (3 / 1) * r == r + r + r.

Lemma ratMult_small_le : forall r1 r2,
  r2 <= 1 ->
  r1 * r2 <= r1.

Lemma ratDistance_ratMult_le : forall r1 r2 r3 r4 d,
  (ratDistance r1 r3) <= d ->
  (ratDistance r2 r4) <= d ->
  r1 <= 1 ->
  r2 <= 1 ->
  r3 <= 1 ->
  r4 <= 1 ->
  (ratDistance (r1 * r2) (r3 * r4)) <= (3 / 1) * d.

Lemma ratAdd_any_le : forall r1 r2 r3,
  r1 + r2 <= r3 ->
  r1 <= r3.

Lemma posnatMult_1_r : forall p,
  posnatToNat (posnatMult p (pos 1)) = posnatToNat p.

Lemma rat_num_nz : forall n d,
  n > 0 ->
  RatIntro n d == 0 ->
  False.

Lemma ratMult_inverse : forall r1 r2 (p1 p2 : posnat),
  r1 == r2 * (RatIntro p1 p2) ->
  r1 * (RatIntro p2 p1) == r2.

Lemma ratMult_inverse_nat : forall r1 r2 n d (nzn : nz n), 
  r1 == r2 * (RatIntro n d) ->
  r1 * (RatIntro d (natToPosnat nzn)) == r2.

Lemma ratMult_same_r_inv : forall r1 r2 r3,
  r1 * r2 == r3 * r2 ->
  ~ r2 == 0 ->
  r1 == r3.

Lemma rat_le_1 : forall n (d : posnat),
  (n <= d)%nat -> (RatIntro n d) <= 1.

Lemma rat_remove_common_factor : forall (n num : nat)(nzn : nz n) den,
  RatIntro (n * num) (posnatMult (natToPosnat nzn) den) == RatIntro num den.

Lemma ratMult_2 : forall r,
  r + r == r * (2/1).

Definition ratInverse (r : Rat) :=
  match r with
    | RatIntro n d =>
      match n with
        | O => RatIntro d (pos (S O))
        | S n' => RatIntro d (pos (S n'))
      end
  end.

Lemma ratInverse_prod_1 : forall r,
  ~ r == 0 ->
  (ratInverse r) * r == 1.

Fixpoint expRat r n :=
  match n with
    | O => rat1 
    | S n' => r * (expRat r n')
  end.

Lemma ratInverse_nz : forall (r : Rat),
  ratInverse r == 0 ->
  False.

Lemma ratInverse_1_swap : forall r,
  ~ r == 0 ->
  r <= 1 ->
  1 <= ratInverse r.

Lemma ratInverse_1 : 
  ratInverse 1 == 1.

Lemma ratInverse_leRat : forall r1 r2,
  ~ r2 == 0 ->
  r2 <= r1 ->
  ratInverse r1 <= ratInverse r2.

Lemma ratAdd_not_leRat : forall r1 r2,
  r1 + r2 <= r1 ->
  (~r2 == 0) ->
  False.

Definition ratSubtract_rel (r1 r2 : Rat -> Prop) d :=
  forall r1' r2', r1 r1' -> r2 r2' -> d == ratSubtract r1' r2'.
  
Definition ratAdd_rel(r1 r2 : Rat -> Prop) r :=
  forall r1' r2', r1 r1' -> r2 r2' -> r == r1' + r2'.

Definition ratMult_rel (r1 r2 : Rat -> Prop)(r : Rat) :=
  forall r1' r2', r1 r1' -> r2 r2' -> r == r1' * r2'.

Definition expRat_rel (r1 : Rat -> Prop) n r :=
  forall r1', r1 r1' -> r == expRat r1' n.

Definition ratInverse_rel (r : Rat -> Prop) v :=
  forall r',
    r r' -> v == ratInverse r'.

Lemma eqRat_flip : forall (p1 p2 p3 p4 : posnat),
  RatIntro p1 p2 == RatIntro p3 p4 ->
  RatIntro p2 p1 == RatIntro p4 p3.

Lemma ratInverse_eqRat_compat : forall r1 r2,
  ~ r1 == 0 ->
  r1 == r2 ->
  ratInverse r1 == ratInverse r2.

Lemma ratSubtract_ratAdd_distr : forall r1 r2 r3,
  ratSubtract r1 (r2 + r3) == ratSubtract (ratSubtract r1 r2) r3.

Lemma ratSubtract_ratAdd_assoc_1 : forall r1 r2 r3,
  r3 <= r2 ->
  ratSubtract (r1 + r2) r3 == r1 + (ratSubtract r2 r3).

Lemma eqRat_ratMult_same_r : forall r1 r2 r3,
  ~r1 == 0 ->
  r2 * r1 == r3 * r1 ->
  r2 == r3.

Lemma expRat_le_1 : forall n x,
  x <= 1 ->
  expRat x n <= 1.

Lemma expRat_le : forall n1 n2 x,
  x <= 1 ->
  n2 >= n1 ->
  expRat x n2 <= expRat x n1.

Lemma expRat_leRat_compat : forall n r1 r2,
  r1 <= r2 ->
  expRat r1 n <= expRat r2 n.

Lemma expRat_le' : forall n1 n2 r v,
  expRat r n1 <= v ->
  ~ (1 <= r) ->
  n2 >= n1 ->
  expRat r n2 <= v.

Lemma ratSubtract_sum_1 : forall r1 r2,
  ~ r1 <= r2 ->
  r2 + (ratSubtract r1 r2) == r1.

Lemma rat_ge_1 : forall n (d : posnat),
  n >= d ->
  1 <= RatIntro n d.

Lemma leRat_ratAdd_same_r : forall r1 r2 r3,
  r2 + r1 <= r3 + r1 ->
  r2 <= r3.

Lemma leRat_ratMult_same_r : forall r1 r2 r3,
  (~r1 == 0) ->
  r2 * r1 <= r3 * r1 ->
  r2 <= r3.

Lemma ratMult_eq_rat1 : forall n1 n2 (nz1 : nz n1)(nz2 : nz n2),
  (n1 / n2) * (n2 / n1) == 1.

Lemma half_distance_1_le : forall r,
  ~ 1 <= r ->
  ~ 1 <= r + (1 / 2) * (ratSubtract 1 r).

Lemma leRat_terms : forall n1 n2 (d1 d2 : posnat),
  (n1 <= n2)%nat ->
  (d2 <= d1)%nat ->
  RatIntro n1 d1 <= RatIntro n2 d2.

Lemma posnatMult_eq : forall p1 p2,
  posnatToNat (posnatMult p1 p2) = (p1 * p2)%nat.

Theorem mult_gt_zero_if : 
  forall (a b : nat),
    a * b > 0 -> (a > 0  /\ b > 0).

Lemma expRat_terms : forall k n (d : posnat)(p : nz (expnat d k)),
  expRat (RatIntro n d) k == (expnat n k) / (expnat d k).
  
Lemma expRat_le_half_exists : forall r,
  ~ 1 <= r ->
  exists n, expRat r n <= (1/2).

Lemma expRat_half_le_exp_exists : forall d,
  ~ d == 0 ->
  exists n,
    expRat (1/2) n <= d.

Lemma expRat_1 : forall n,
  expRat 1 n == 1.

Lemma expRat_exp_sum  : forall n1 n2 r,
  expRat r (n1 + n2)%nat == (expRat r n1) * (expRat r n2).

Lemma expRat_base_prod : forall n r1 r2,
  expRat (r1 * r2) n == (expRat r1 n) * (expRat r2 n).

Lemma expRat_exp_prod : forall n1 n2 r,
  expRat r (n1 * n2)%nat == expRat (expRat r n1) n2.

Lemma expRat_le_exp_exists : forall r d, 
  ~ 1 <= r ->
  ~ d == 0 ->
  exists n,
    expRat r n <= d.

Lemma eqRat_ratAdd_same_r : forall r1 r2 r3,
  r2 + r1 == r3 + r1 ->
  r2 == r3.

Lemma ratAdd_arg_0 : forall a b,
  a + b == a ->
  b == 0.

Definition ratHalf(r : Rat) :=
  r * (1 / 2).

Theorem ratHalf_ne_0 : forall r,
  ~ r == 0 ->
  ~ (ratHalf r) == 0.

Theorem ratHalf_add : forall r,
  ratHalf r + ratHalf r == r.

Theorem le_ratHalf_0 : forall r,
  r <= (ratHalf r) -> r == 0.

Lemma ratSubtract_0_r : forall r,
  ratSubtract r 0 == r.

Lemma ratDistance_0_r_le : forall r d,
  r <= d ->
  ratDistance r 0 <= d.

Lemma ratSubtract_0_inv : forall r1 r2,
  ratSubtract r1 r2 == 0 ->
  r1 <= r2.

Lemma ratSubtract_le_sum : forall r1 r2 d,
  r2 <= r1 ->
  ratSubtract r1 r2 <= d ->
  r1 <= r2 + d.

Lemma ratDistance_le_sum : forall r1 r2 d,
  ratDistance r1 r2 <= d ->
  r1 <= r2 + d.

Lemma ratSubtract_ratDistance_le : forall r1 r2,
  ratSubtract r1 r2 <= ratDistance r1 r2.

Lemma minRat_le_r : forall r1 r2,
  minRat r1 r2 <= r2.

Lemma minRat_le_l : forall r1 r2,
  minRat r1 r2 <= r1.

Lemma ratDistance_ge_difference: forall r1 r2 d,
  ratDistance r1 r2 <= d ->
  ratSubtract r1 d <= r2.

Lemma ratSubtract_ratAdd_assoc_le : forall r1 r2 r3,
  ratSubtract (r1 + r2) r3 <= r1 + (ratSubtract r2 r3).

Lemma ratSubtract_assoc_le : forall r1 r2 r3,
  ratSubtract r1 (ratSubtract r2 r3) <= (ratSubtract r1 r2) + r3.

Lemma ratDistance_leRat_both : forall r1 r2 d,
  ratSubtract r1 r2 <= d ->
  ratSubtract r2 r1 <= d ->
  ratDistance r1 r2 <= d.

Lemma rat_distance_of_difference : forall r1 r2 r3 r4 d1 d2,
  r2 <= r1 ->
  r4 <= r3 ->
  ratDistance r1 r3 <= d1 ->
  ratDistance r2 r4 <= d2 ->
  ratDistance (ratSubtract r1 r2) (ratSubtract r3 r4) <= (d1 + d2).

Lemma ratMult_ratSubtract_distrib_r : forall f r1 r2,
  (ratSubtract r1 r2) * f  == ratSubtract (r1 * f) (r2 * f).

Lemma ratMult_ratDistance_factor_r : forall r1 r2 r3,
  ratDistance (r1 * r3) (r2 * r3) == (ratDistance r1 r2) * r3.

Lemma ratMult_ratDistance_factor_l : forall r1 r2 r3,
  ratDistance (r3 * r1) (r3 * r2) == r3 * (ratDistance r1 r2).

Lemma ratAdd_rel_left_total : forall (r1 r2: Rat -> Prop),
  (exists r1', r1 r1') ->
  (exists r2', r2 r2') ->
  (forall x1 x2, r1 x1 -> r1 x2 -> x1 == x2) ->
  (forall x1 x2, r2 x1 -> r2 x2 -> x1 == x2) ->
  exists r3, ratAdd_rel r1 r2 r3.

Lemma expRat_eqRat_compat : forall n r1 r2,
  r1 == r2 ->
  expRat r1 n == expRat r2 n.

Lemma expRat_rel_left_total : forall (r1 : Rat -> Prop) n,
  (exists r1', r1 r1') ->
  (forall x1 x2, r1 x1 -> r1 x2 -> x1 == x2) ->
  exists r3, expRat_rel r1 n r3.

Lemma expRat_rel_func : forall (r : Rat -> Prop) v1 v2 n,
  expRat_rel r n v1 ->
  expRat_rel r n v2 ->
  (forall x1 x2, r x1 -> r x2 -> x1 == x2) ->
  (exists r', r r') ->
  v1 == v2.

Lemma ratInverse_involutive : forall r,
  ~ r == 0 ->
  ratInverse (ratInverse r) == r.

Lemma ratInverse_ratMult : forall r1 r2,
  ~ r1 == 0 ->
  ~ r2 == 0 ->
  ratInverse (r1 * r2) == ratInverse r1 * ratInverse r2.

Lemma ratDistance_ratInverse : forall r1 r2,
  ~ r1 == 0 ->
  ~ r2 == 0 -> 
  ratDistance (ratInverse r1) (ratInverse r2) == (ratDistance r1 r2) * ratInverse (r1 * r2).

Lemma ratSubtract_half : forall x,
  ratSubtract x (x * (1/2)) == x * (1/2).

Lemma ratMult_ratAdd_cd : forall r n (d : posnat),
  r + r * (RatIntro n d) == r * (RatIntro (d + n)%nat d).

Definition numerator r :=
  match r with
    | RatIntro n d => n
  end.

Lemma ratDistance_add_same_l_gen : forall r1 r2 r3 r4,
  r1 == r3 ->
  ratDistance (r1 + r2) (r3 + r4) == ratDistance r2 r4.

Lemma ratDistance_add_same_r_gen : forall r1 r2 r3 r4,
  r2 == r4 ->
  ratDistance (r1 + r2) (r3 + r4) == ratDistance r1 r3.

Lemma ratDistance_from_0 : forall r,
  ratDistance 0 r == r.

Lemma maxRat_comm : forall r1 r2,
  maxRat r1 r2 == maxRat r2 r1.

Lemma ratDistance_le_max_triv : forall r1 r2,
  ratDistance r1 r2 <= maxRat r1 r2.

Lemma ratAdd_2_ratMax : 
  forall r1 r2,
    (r1 + r2 <= 2 / 1 * (maxRat r1 r2))%rat.

Theorem rat_num_not_le : 
  forall (d1 d2 : posnat),
    (RatIntro 1 d1 <= RatIntro 1 d2)%rat ->
    d1 < d2 ->
    False.

Lemma leRat_0_eq : 
  forall r, 
    (r <= 0 ->
      r == 0)%rat.

Lemma rat_le_1_if : 
  forall n d,
    RatIntro n d <= 1 ->
    (n <= d)%nat.

Theorem ratFraction_le_1 : 
  forall r1 r2,
    r1 <= r2 ->
    r1 * (ratInverse r2) <= 1.

Theorem ratFraction_ge_1_inv : 
  forall r1 r2,
    1 <= r1 * (ratInverse r2) ->
    r2 <= r1.

Theorem eqRat_refl_eq : 
  forall x y,
    x = y ->
    x == y.

Theorem rat_num_S : 
  forall n d,
    (RatIntro (S n) d == (RatIntro 1 d) + RatIntro n d)%rat.

Theorem distance_le_prod_f :
  forall (f : nat -> Rat) k,
    (forall i, | (f i) - (f (S i)) | <= k) ->
    forall q0,
| (f 0%nat) - (f q0) | <= q0/1 * k. *)
Local Open Scope rat_scope.

Definition negligible(f : nat -> Rat) :=
  forall c, exists n, forall x (pf_nz : nz x),
    x > n ->
    ~ ((1 / expnat x c) <= f x)%rat.

Theorem negligible_eq : 
  forall (f1 f2 : nat -> Rat),
    negligible f1 ->
    (forall n, f1 n == f2 n) ->
    negligible f2.

  intuition.
  unfold negligible in *.
  intuition.
  edestruct H.
  econstructor.
  intuition.
  eapply H1.
  eauto.
  rewrite H3.
  rewrite <- H0.
  intuition.

Qed.

Lemma negligible_le : 
  forall f1 f2,
    (forall n, f2 n <= f1 n)%rat ->
    negligible f1 ->
    negligible f2.
  
  intuition.
  unfold negligible in *.
  intuition.
  edestruct H0.
  econstructor.
  intuition.
  eapply H1.
  eauto.
  rewrite H3.
  eauto.
  
Qed.

Lemma negligible_plus : 
  forall f1 f2,
    negligible f1 ->
    negligible f2 ->
    negligible (fun n => f1 n + f2 n)%rat.
  
  unfold negligible in *.
  intuition.
  
  destruct (H (S c)).
  destruct (H0 (S c)).
  exists (max 1 (max x x0)).
  intuition.
  
  apply Nat.max_lub_lt_iff in H3.
  intuition.
  
  assert (1 / expnat x1 c <= 2/1 * (maxRat (f1 x1) (f2 x1)))%rat.
  eapply leRat_trans.
  eapply H4.
  
  eapply ratAdd_2_ratMax.
  
  assert (1 / expnat x1 (S c) <= RatIntro 1 (posnatMult (pos 2) (pos (expnat x1 c))))%rat.
  eapply leRat_terms; intuition.
  unfold natToPosnat, posnatToNat, posnatMult.
  eapply expnat_double_le.
  omega.
  
  unfold maxRat in *.
  case_eq (bleRat (f1 x1) (f2 x1)); intuition.
  rewrite H8 in H3.
  
  eapply H2.
  eapply le_lt_trans.
  eapply Max.le_max_r.
  eauto.

  rewrite H7.
  rewrite rat_mult_den.
  rewrite H3.
  rewrite <- ratMult_assoc.
  
  rewrite <- ratMult_num_den.
  rewrite num_dem_same_rat1.
  rewrite ratMult_1_l.
  intuition.
  unfold posnatMult, natToPosnat, posnatToNat.
  omega.
  
  rewrite H8 in H3.
  eapply H1.
  eapply le_lt_trans.
  eapply Max.le_max_l.
  eauto.
  
  rewrite H7.
  rewrite rat_mult_den.
  rewrite H3.
  rewrite <- ratMult_assoc.
  
  rewrite <- ratMult_num_den.
  rewrite num_dem_same_rat1.
  rewrite ratMult_1_l.
  intuition.
  unfold posnatMult, natToPosnat, posnatToNat.
  omega.
Qed.

Local Open Scope nat_scope.
Theorem double_log_plus_3_le_h : 
  forall y x,
    y = Nat.log2 x ->
    y >= 4 ->
    2 * y + 3 <= x.
  
  induction y; intuition; simpl in *.
  rewrite plus_0_r in *.
  
  assert (S (y + S y + 3)  = 
    (y + y + 3) + 2).
  omega.
  rewrite H1.
  
  destruct (eq_nat_dec y 3).
  subst.
  assert (x >= Nat.pow 2 4).
  rewrite H.
  eapply Nat.log2_spec.
  destruct (eq_nat_dec x 0).
  subst.
  rewrite log2_0 in H.
  omega.
  omega.
  
  eapply le_trans.
  2:{
    eapply H2.
  }
  simpl.
  omega.
  
  assert ( y + y + 3 <= div2 x).
  eapply IHy.
  
  symmetry.
  apply log2_div2.
  trivial.
  omega.
  
  assert (2 <= div2 x).
  assert (2 = div2 4).
  trivial.
  rewrite H3.
  eapply div2_le_mono.
  eapply le_trans.
  2:{
    eapply Nat.log2_le_lin.
    destruct (eq_nat_dec 0 x); subst.
    rewrite log2_0 in H.
    omega.
    omega.
  }
  omega.
  
  eapply le_trans.
  eapply plus_le_compat.
  eapply H2.
  
  eapply H3.
  
  eapply div2_ge_double.
  
Qed.

Theorem S_log_square_lt_h : 
  forall y x,
    y = Nat.log2 x ->
    6 <= Nat.log2 x->
    S y * S y <= x.
  
  induction y; intuition; simpl in *.
  assert (y = Nat.log2 (div2 x)).
  symmetry.
  eapply log2_div2.
  trivial.

  rewrite (mult_comm _ (S (S y))).
  simpl.
  rewrite (mult_comm _ (S y)) in IHy.
  simpl in *.
  
  assert ( S (S (y + S (S (y + (y + (y + y * y)))))) = 
    (S (y + (y + y * y))) + (2 * y + 3)).
  omega.
  rewrite H2.
  clear H2.
  
  destruct (eq_nat_dec (Nat.log2 x) 6).
  
  assert (y = 5).
  assert (S y = 6).
  rewrite H.
  trivial.
  omega.
  rewrite H2.
  simpl.
  assert (x >= Nat.pow 2 6).
  rewrite <- e.
  
  eapply Nat.log2_spec.
  
  destruct (eq_nat_dec x 0).
  subst.
  rewrite log2_0 in H.
  omega.
  omega.
  
  eapply le_trans.
  2:{
    eapply H3.
  }
  simpl.
  omega.
  
  assert ( S (y + (y + y * y)) <= div2 x).
  eapply IHy.
  trivial.
  omega.
  
  assert (2 * y + 3 <= div2 x).
  eapply double_log_plus_3_le_h; trivial.
  omega.
  eapply le_trans.
  eapply plus_le_compat.
  eapply H2.
  eapply H3.
  
  eapply div2_ge_double.
  
Qed.

Theorem S_log_square_lt : 
  forall x, 
    Nat.pow 2 6 <= x->
    S (Nat.log2 x) * S (Nat.log2 x) <= x.
  
  intuition.
  eapply S_log_square_lt_h; trivial.
  eapply le_trans.
  2:{
    eapply Nat.log2_le_mono.
    eapply H.
  }
  rewrite Nat.log2_pow2; omega.
Qed.

Theorem log_square_lt : 
  forall x, 
    Nat.pow 2 6 <= x->
    Nat.log2 x * Nat.log2 x < x.
  
  intuition.
  
  assert (Nat.log2 x < S (Nat.log2 x)).
  omega.
  eapply lt_le_trans.
  
  eapply mult_lt_compat.
  eapply H0.
  eapply H0.
  eapply S_log_square_lt.
  trivial.
Qed.

Theorem poly_lt_exp_ge_6 : 
  forall c x, 
    x >= (Nat.pow 2 c) ->
    x >= (Nat.pow 2 6) ->
    Nat.pow x c < Nat.pow 2 x.
  
  intuition.
  
  specialize (Nat.log2_spec_alt); intuition.
  destruct (H1 x).
  eapply lt_le_trans.
  2:{
    eapply H.
  }
  eapply (expnat_2_ge_1 c).
  
  intuition.
  
  destruct (eq_nat_dec x0 0).
  rewrite e in H3.
  rewrite plus_0_r in *.
  rewrite H3.
  rewrite <- Nat.pow_mul_r.
  
  eapply Nat.pow_lt_mono_r.
  omega.
  rewrite <- H3.

  assert (c <= Nat.log2 x).
  eapply (@Nat.pow_le_mono_r_iff 2).
  omega.
  rewrite <- H3.
  trivial.
  eapply le_lt_trans.
  eapply mult_le_compat.
  eapply le_refl.
  eapply H4.
  
  eapply log_square_lt.
  eapply le_trans.
  2:{
    eapply H0.
  }
  eapply Nat.pow_le_mono_r.
  omega.
  omega.
  
  destruct (eq_nat_dec c 0).
  rewrite e.
  simpl.
  eapply le_lt_trans.
  assert (1 <= expnat 2 0).
  trivial.
  eapply H4.
  eapply Nat.pow_lt_mono_r.
  omega.
  omega.
  
  assert (expnat x c < expnat (2 ^ S (Nat.log2 x)) c).
  eapply Nat.pow_lt_mono_l.
  omega.
  eapply Nat.log2_spec.
  omega.
  eapply lt_le_trans.
  eapply H4.
      
  rewrite <- Nat.pow_mul_r.
  eapply Nat.pow_le_mono_r.
  omega.
  assert (c <= S (Nat.log2 x)).
  eapply (@Nat.pow_le_mono_r_iff 2).
  omega.
  eapply le_trans.
  eapply H.
  
  eapply lt_le_weak.
  eapply Nat.log2_spec.
  omega.
  
  eapply le_trans.
  eapply mult_le_compat.
  eapply le_refl.
  eapply H6.
  
  eapply S_log_square_lt.
  eapply le_trans.
  2:{
    eapply H0.
  }
  eapply Nat.pow_le_mono_r.
  omega.
  omega.
Qed.

Theorem poly_lt_exp : 
  forall c, 
    exists x, 
      forall y, y >= x ->
        expnat y c < expnat 2 y.
  
  intuition.
  exists (expnat 2 (max c 6)).
  intuition.
  eapply poly_lt_exp_ge_6.
  eapply le_trans.
  2:{
    eapply H.
  }
  eapply Nat.pow_le_mono_r.
  omega.
  eapply Max.le_max_l.
  
  eapply le_trans.
  2:{
    eapply H.
  }
  eapply Nat.pow_le_mono_r.
  omega.
  eapply Max.le_max_r.
Qed.
    
Theorem negligible_exp_den : 
  negligible (fun n => 1 / expnat 2 n)%rat.
  
  unfold negligible in *.
  
  intuition.
  destruct (poly_lt_exp c).
  exists x.
  intuition.
  
  eapply (rat_num_not_le).
  eapply H1.
  
  unfold posnatToNat, natToPosnat.
  eapply H.
  omega.
Qed.

Theorem negligible_const_mult : 
  forall (n : nat) d f,
    negligible f -> 
    negligible (fun x => (RatIntro n d) * (f x))%rat.
  
  unfold negligible in *.
  intuition.
  
  destruct (eq_nat_dec n 0).
  subst.
  exists 1.
  intuition.
  
  assert ((1 / expnat x c) == 0)%rat.
  
  eapply leRat_0_eq.
  rewrite H1.
  rewrite rat_num_0.
  rewrite ratMult_0_l.
  intuition.
  
  eapply rat_num_nz; [idtac | eauto].
  omega.
  
  destruct (H (c + n)).
  exists (x + n)%nat.
  intuition.
  eapply H0.
  omega.
  
  assert (1 / expnat x0 (c + n) == RatIntro 1 (pos  (expnat x0 c)) * RatIntro 1 (pos (expnat x0 n)))%rat.
  rewrite <- ratMult_num_den.
  eapply eqRat_terms.
  symmetry.
  eapply mult_1_r.
  unfold natToPosnat, posnatToNat, posnatMult.
  rewrite expnat_plus.
  trivial.
  
  rewrite H3.
  rewrite H2.
  rewrite ratMult_comm.
  rewrite <- ratMult_assoc.
  
  eapply leRat_trans.
  2:{
    eapply eqRat_impl_leRat.
    rewrite <- ratMult_1_l.
    eapply eqRat_refl.
  }
  eapply ratMult_leRat_compat; intuition.
  
  eapply rat_le_1.
  destruct d.
  unfold natToPosnat, posnatToNat, posnatMult.
  rewrite mult_comm.
  eapply mult_le_compat.
      
  eapply le_trans.
  eapply le_expnat_2.
  eapply expnat_base_le.
  omega.
  omega.

Qed.

Theorem negligible_mult_ident : 
  forall f,
    negligible f -> 
    negligible (fun x => (x / 1) * (f x))%rat.
  
  unfold negligible in *.
  intuition.
  
  destruct (H (S c)).
  exists x.
  intuition.
  eapply H0.
  omega.
  simpl.
  
  assert ( (RatIntro 1 (natToPosnat (expnat_nz (S c) pf_nz)))  == 
    RatIntro 1 (posnatMult (pos x0) (pos expnat x0 c)) )%rat.
  eapply eqRat_terms; trivial.
  
  simpl in *.
  rewrite H3.
  rewrite ratMult_denom.
  rewrite H2.
  rewrite <- ratMult_assoc.
  rewrite <- ratMult_num_den.
  rewrite num_dem_same_rat1.
  rewrite ratMult_1_l.
  intuition.
  unfold natToPosnat, posnatToNat, posnatMult.
  omega.
Qed.

Theorem negligible_exp : 
  forall z, 
    negligible (fun n => expnat n z / expnat 2 n)%rat.
  
  induction z; simpl in *; intuition.
  
  eapply negligible_exp_den.
  
  eapply negligible_eq.
  eapply negligible_mult_ident.
  eauto.
  intuition.
  rewrite <- ratMult_num_den.
  eapply eqRat_terms; trivial.
  unfold posnatToNat, natToPosnat, posnatMult.
  eapply mult_1_l.
  
Qed.

Theorem negligible_const_num : 
  forall k,
    negligible (fun n => k / expnat 2 n)%rat.
  
  intuition.
  eapply negligible_eq.
  eapply (@negligible_const_mult k (pos 1)).
  eapply negligible_exp_den.
  intuition.
  rewrite <- ratMult_num_den.
  eapply eqRat_terms.
  eapply mult_1_r.
  unfold natToPosnat, posnatToNat, posnatMult.
  eapply mult_1_l.
Qed.

Theorem negligible_poly_num : 
  forall f,
    polynomial f ->
    negligible (fun n => f n / expnat 2 n)%rat.
  
  intuition.
  unfold polynomial in *.
  do 3 destruct H.
  eapply negligible_le.
  intuition.
  eapply leRat_terms.
  eapply H.
  eapply le_refl.
  
  eapply negligible_eq. 
  eapply negligible_plus.
  eapply negligible_const_mult.
  eapply negligible_exp.
  eapply negligible_const_num.
  
  intuition.
  symmetry.
  
  rewrite ratAdd_num.
  eapply ratAdd_eqRat_compat.
  rewrite <- ratMult_num_den.
  eapply eqRat_terms.
  eauto.
  assert (posnatToNat (pos expnat 2 n) = posnatToNat (posnatMult (pos 1) (pos expnat 2 n))).
  unfold natToPosnat, posnatToNat, posnatMult.
  symmetry.
  eapply mult_1_l.
  eapply H0.
  eapply eqRat_refl.
Qed.