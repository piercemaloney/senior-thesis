

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.functors.
(* VST.msl.functors:
Require Import VST.msl.base.

Set Implicit Arguments.

Module CovariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : A -> B), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : B -> C) (g : A -> B),
fmap _ _ f oo fmap _ _ g = fmap _ _ (f oo g)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : A -> B), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End CovariantFunctor.

Module ContraVariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : C -> B) (g : B -> A),
fmap _ _ f oo fmap _ _ g = fmap _ _ (g oo f)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End ContraVariantFunctor.

Module MixVariantFunctor.

Record functorFacts (PS : Type -> Type)
 (fmap : forall A B (f1 : A -> B) (f2 : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) (id A) = id (PS A);
  ff_comp : forall A B C (f1 : B -> C) (f2 : C -> B) (g1 : A -> B)
(g2 : B -> A), fmap _ _ f1 f2 oo fmap _ _ g1 g2 = fmap _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f1 : A -> B) (f2 : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End MixVariantFunctor.

Module CovariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : B2 -> C2)
(g1 : A1 -> B1) (g2 : A2 -> B2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (f2 oo g2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CovariantBiFunctor.

Module CoContraVariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : C2 -> B2)
(g1 : A1 -> B1) (g2 : B2 -> A2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CoContraVariantBiFunctor.

Coercion CovariantFunctor._functor:
  CovariantFunctor.functor >-> Funclass.
Coercion ContraVariantFunctor._functor:
  ContraVariantFunctor.functor >-> Funclass.
Coercion MixVariantFunctor._functor:
  MixVariantFunctor.functor >-> Funclass.
Coercion CovariantBiFunctor._functor:
  CovariantBiFunctor.functor >-> Funclass.
Coercion CoContraVariantBiFunctor._functor:
  CoContraVariantBiFunctor.functor >-> Funclass.

Module CovariantFunctorLemmas.

Import CovariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : B -> C) (g : A -> B),
  fmap F f oo fmap F g = fmap F (f oo g).

Lemma fmap_app {F: functor} : forall A B C (f : B -> C) (g : A -> B) x,
  fmap F f (fmap F g x) = fmap F (f oo g) x.

End CovariantFunctorLemmas.

Module ContraVariantFunctorLemmas.

Import ContraVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : C -> B) (g : B -> A),
  fmap F f oo fmap F g = fmap F (g oo f).

Lemma fmap_app {F: functor} : forall A B C (f : C -> B) (g : B -> A) x,
  fmap F f (fmap F g x) = fmap F (g oo f) x.

End ContraVariantFunctorLemmas.

Module MixVariantFunctorLemmas.

Import MixVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End MixVariantFunctorLemmas.

Module CovariantBiFunctorLemmas.

Import CovariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (f2 oo g2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (f2 oo g2) x.

End CovariantBiFunctorLemmas.

Module CoContraVariantBiFunctorLemmas.

Import CoContraVariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End CoContraVariantBiFunctorLemmas.

Module GeneralFunctorGenerator.

Definition CovariantFunctor_MixVariantFunctor (F: CovariantFunctor.functor):

Definition ContraVariantFunctor_MixVariantFunctor
 (F: ContraVariantFunctor.functor):

Definition CovariantFunctor_CoContraVariantBiFunctor
 (F: CovariantFunctor.functor):

Definition CoContraVariantBiFunctor_MixVariantFunctor
 (F: CoContraVariantBiFunctor.functor):

Definition CovariantFunctor_CovariantFunctor_compose
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f => CovariantFunctor.fmap F1 (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantFunctor_MixVariantFunctor_compose
(F1: CovariantFunctor.functor) (F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f g => CovariantFunctor.fmap F1 (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite MixVariantFunctorLemmas.fmap_id, CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp, MixVariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_CovariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CovariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_MixVariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CovariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_CoContraVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1: CovariantFunctor.functor)
(F2: ContraVariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CoContraVariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (ContraVariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite CovariantFunctorLemmas.fmap_id, ContraVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, CovariantFunctorLemmas.fmap_comp, ContraVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_MixVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CoContraVariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 g f)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

End GeneralFunctorGenerator.

Module CovariantBiFunctorGenerator.

Import CovariantBiFunctor.
Import CovariantBiFunctorLemmas.

Definition Fpair: functor.

Definition Fchoice: functor.

End CovariantBiFunctorGenerator.

Module CoContraVariantBiFunctorGenerator.

Import CoContraVariantBiFunctor.
Import CoContraVariantBiFunctorLemmas.

Definition Ffunc: functor.

End CoContraVariantBiFunctorGenerator.

Module CovariantFunctorGenerator.

Import CovariantFunctor.
Import CovariantFunctorLemmas.

Definition fconst (T : Type): functor.

Definition fidentity: functor.

Definition Foption: functor.

Definition Flist: functor.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Goal forall (F1 F2: functor) (T: Type), fpair F1 F2 T = prod (F1 T) (F2 T).

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Flist
  F.

Goal forall (F : functor) (T: Type), foption F T = option (F T).

Definition ffunc (F1: ContraVariantFunctor.functor) (F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_CoContraVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Goal forall (F1 : ContraVariantFunctor.functor) (F2: functor) (T: Type),

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B (f: A -> B) x, P A x -> P B (fmap F f x)): functor.

End CovariantFunctorGenerator.

Module MixVariantFunctorGenerator.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.

Definition fconst (T : Type): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  (CovariantFunctorGenerator.fconst T).

Definition fidentity: functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  CovariantFunctorGenerator.fidentity.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Flist
  F.

Definition ffunc (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_MixVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fpi {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B f g x, P A x -> P B (fmap F f g x)): functor.

End MixVariantFunctorGenerator.

Unset Implicit Arguments. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)

Require Import VST.msl.sepalg_functors.
(* VST.msl.sepalg_functors:
Require Import VST.msl.base.
Require Import VST.msl.functors.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Set Implicit Arguments.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.
Import MixVariantFunctorGenerator.

Section unmaps.
  Variables (A: Type)(J_A: Join A).
  Variables (B: Type)(J_B: Join B).

  Definition unmap_left (f:A -> B) :=
    forall x' y z,
      join x' (f y) (f z) ->
      { x:A & { y0:A | join x y0 z /\ f x = x' /\ f y0 = f y }}.

  Definition unmap_right (f:A -> B) :=
    forall x y z',
      join (f x) (f y) z' ->
      { y0: A & { z:A | join x y0 z /\ f y0 = f y /\ f z = z' }}.
End unmaps.

Record pafunctor (F: functor) (paf_join: forall A, Join (F A)): Type := Pafunctor
{
  paf_join_hom : forall A B (f : A -> B) (g: B -> A), join_hom (fmap F f g);
  paf_preserves_unmap_left : forall A B (f : A -> B) (g: B -> A),
    unmap_left (paf_join A) (paf_join B) (fmap F f g);
  paf_preserves_unmap_right : forall A B (f : A -> B) (g: B -> A),
    unmap_right (paf_join A) (paf_join B) (fmap F f g)
}.

Section ConstPAFunctor.

  Variables (T : Type)(J_T: Join T).

  Lemma paf_const : pafunctor (fconst T) (fun _ => J_T).
End ConstPAFunctor.

Section EquivPAFunctor.
  Variables (F : functor).

  Lemma paf_equiv : @pafunctor F (fun A => @Join_equiv (F A)).

End EquivPAFunctor.

Section PairSAFunctor.
  Variables (F1 F2: functor).
  Variables (J_F1: forall A, Join (F1 A)) (pafF1: pafunctor F1 J_F1).
  Variables (J_F2: forall A, Join (F2 A)) (pafF2: pafunctor F2 J_F2).

  Lemma paf_pair : @pafunctor (fpair F1 F2) (fun A : Type => Join_prod (F1 A) (J_F1 A) (F2 A) (J_F2 A)).
End PairSAFunctor.

Section CoFunSAFunctor.
  Variables (dom: Type) (rng : functor).
  Variables (Join_rng: forall A, Join (rng A)) (pss_rng : pafunctor rng Join_rng).

  Definition paf_fun : @pafunctor (ffunc (fconst dom) rng)
                         (fun A => Join_fun dom _ (Join_rng A)).
End CoFunSAFunctor.

Section SepAlgSubset_Functor.
  Variables (F: functor).
  Variables (JOIN: forall A, Join (F A))
            (fSA : @pafunctor F JOIN).

  Variable P : forall A, F A -> Prop.
  Arguments P {A} _.
  Hypothesis HPfmap1 : forall A B (f: A -> B) (g: B -> A) x,
    P x -> P (fmap F f g x).
  Hypothesis HPfmap2 : forall A B (f: A -> B) (g: B -> A) x,
    P (fmap F f g x) -> P x.

  Definition paf_subset :
    @pafunctor (fsubset F (@P) HPfmap1) (fun A => Join_prop _ _ P).

End SepAlgSubset_Functor. *)



Import MixVariantFunctor.

Import MixVariantFunctorLemmas.

Import MixVariantFunctorGenerator.



Definition midObj {A} {JA: Join A} (a : A) : Prop := ~identity a /\ ~ full a.



Definition ijoinable A {JA: Join A} : Type := {sh : A & midObj sh}.



Definition ijoin {A} {JA: Join A} (j1 j2 j3 : ijoinable A) : Prop :=

  match (j1, j2, j3) with

  (existT _ t1 _, existT _ t2 _, existT _ t3 _) => join t1 t2 t3

  end.



Lemma ijoin_eq {A} {JA: Join A}{PA: Perm_alg A} : forall j1 j2 j3 j3',

  ijoin j1 j2 j3 ->

  ijoin j1 j2 j3' ->

  j3 = j3'.

Proof.

  intros.

  icase j1; icase j2; icase j3; icase j3'.

  unfold ijoin in *.

  apply existT_ext.

  eapply join_eq; eauto.

Qed.



Lemma ijoin_com {A} {JA: Join A}{PA: Perm_alg A} : forall j1 j2 j3,

  ijoin j1 j2 j3 -> ijoin j2 j1 j3.

Proof with auto.

  intros.

  icase j1; icase j2; icase j3.

  red in H; red.

  apply join_comm...

Qed.



Lemma ijoin_assoc {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} : forall a b c d e,

  ijoin a b d ->

  ijoin d c e ->

  {f : ijoinable A | ijoin b c f /\ ijoin a f e}.

Proof with auto.

  intros.

  icase a; icase b; icase c; icase d; icase e.

  unfold ijoin in *.

  destruct (join_assoc H H0) as [f [? ?]].

  assert ((~identity f) /\ (~full f)).

    unfold midObj in *.

    split.

    intro.

    generalize (split_identity _ _ H1 H3); intro.

    tauto.

    intro.

    specialize ( H3 x). spec H3. exists x3...

    specialize ( H3 f x3 H2). subst x3.

    apply unit_identity in H2.

    tauto.

  exists (existT midObj f H3).

  split...

Qed.



Lemma ijoin_canc {A}  {JA: Join A}{SA: Sep_alg A}{CA: Canc_alg A}: forall a a' b c,

  ijoin a b c ->

  ijoin a' b c ->

  a = a'.

Proof with auto.

  intros.

  icase a; icase a'; icase b; icase c.

  unfold ijoin in *.

  apply existT_ext.

  eapply join_canc; eauto.

Qed.



Lemma ijoin_identity1 {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}: forall a b,

  ijoin a b b ->

  False.

Proof with auto.

  intros.

  icase a; icase b.

  destruct m. apply n.

  apply (unit_identity x0).

  apply H.

Qed.



Lemma ijoin_identity2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DA: Disj_alg A}: forall a b,

  ijoin a a b ->

  False.

Proof with auto.

  intros.

  icase a. icase b.

  destruct m; destruct m0.

  red in H; apply join_self in H; contradiction.

Qed.



Section CombineJoin.



Variable A : Type.

Variable JA: Join A.

Variable pa_A : Perm_alg A.

Variable sa_A : Sep_alg A.

Variable ca_A : Canc_alg A.

Variable da_A : Disj_alg A.



Variable A_top : A.

Variable A_top_full : full A_top.



Variable T1 : Type.

Variable T2 : Type.

Variable J1: Join T1.

Variable pa_T1: Perm_alg T1.

Variable sa_T1: Sep_alg T1.



Variable combjoin : T1 -> T1 -> T2 -> Prop.



Variable combjoin_eq : forall v1 v1' v2 v2',

  combjoin v1 v1' v2 ->

  combjoin v1 v1' v2' ->

  v2 = v2'.



Variable combjoin_assoc : forall v1 v2 v3 v4 v5,

   join v1 v2 v3 ->

   combjoin v3 v4 v5 ->

   {v' : T1 & join v2 v4 v' /\ combjoin v1 v' v5}.



Variable combjoin_com : forall v1 v2 v3,

   combjoin v1 v2 v3 ->

   combjoin v2 v1 v3.



Variable combjoin_canc : forall v1 v1' v2 v3,

    combjoin v1 v2 v3 ->

    combjoin v1' v2 v3 ->

    v1 = v1'.



Definition covers (j1 j2 : ijoinable A) : Prop :=

  join (projT1 j1) (projT1 j2) A_top.



Inductive combiner : Type :=

  | CEmpty

  | CPart : forall (sh : ijoinable A) (v : T1), combiner

  | CFull : forall (v : T2), combiner.



Instance Join_combiner : Join combiner :=

  fun c1 c2 c3 =>

  match (c1,c2,c3) with

  | (CEmpty, CEmpty, CEmpty) => True

  | (CEmpty, CPart a v, CPart a' v') => a = a' /\ v = v'

  | (CPart a v, CEmpty, CPart a' v')  => a = a' /\ v = v'

  | (CEmpty, CFull v, CFull v') => v = v'

  | (CFull v, CEmpty, CFull v') => v = v'

  | (CPart a v, CPart a' v', CPart a'' v'') => ijoin a a' a'' /\ join v v' v''

  | (CPart a v, CPart a' v', CFull v'') => combjoin v v' v'' /\ covers a a'

  | _ => False

 end.



Lemma combineJ_eq: forall x y z z' : combiner,

  join x y z -> join x y z' -> z = z'.

Proof with auto.

  intros.

  icase x;icase y;icase z;icase z';try inversion H;try inversion H0;try congruence.



  f_equal.

  eapply ijoin_eq; eauto.

  eapply join_eq; eauto.



  elimtype False; clear - pa_A sa_A H1 H4 A_top_full.

  destruct sh; destruct sh0; destruct sh1.

  red in H1; red in H4; simpl in H4.

  generalize (join_eq H1 H4); intro; subst x1.

  unfold midObj in *.

  tauto.



  elimtype False; clear - pa_A sa_A H2 H3 A_top_full.

  destruct sh;destruct sh0;destruct sh1.

  red in H3; red in H2; simpl in H2.

  generalize (join_eq H2 H3);intro;subst x1.

  unfold midObj in *.

  tauto.



  rewrite (combjoin_eq _ _ _ _ H1 H3)...

Qed.



Lemma combineJ_assoc: forall a b c d e : combiner,

  join a b d -> join d c e ->

                    {f : combiner & join b c f /\ join a f e}.

Proof with auto.

   intros. red in H, H0. unfold join.

   icase a;icase b;icase c;icase d;icase e;inv H;inv H0.



   exists CEmpty;split;red...

   exists (CPart sh0 v0);split;red...

   exists (CFull v0);split;red...

   exists (CPart sh1 v1);split;red...

   exists (CPart sh2 v2);split;red...

   exists (CFull v2);split;red...

   exists (CFull v1);split;red...

   exists CEmpty;split;red...

   exists (CPart sh0 v0);split;red...

   exists (CPart sh0 v0);split;red...

   exists (CPart sh0 v0);split;red...

   exists (CPart sh0 v0);split;red...

   3: exists (CEmpty);split;red...



   destruct (ijoin_assoc _ _ _ _ _ H1 H) as [sh' [? ?]].

   destruct (join_assoc H2 H3) as [fv [? ?]].

   exists (CPart sh' fv); split; red...



   icase sh; icase sh0; icase sh1; icase sh2.

   red in H1, H3. simpl in H1, H3.

   destruct (join_assoc H1 H3) as [sh' [? ?]].

   assert ((~identity sh') /\ (~full sh')).

     split; intro.

     generalize (split_identity _ _ H0 H5); intro.

     unfold midObj in *.

     tauto.

     specialize ( H5 x).

     spec H5. exists A_top...

     specialize ( H5 sh' A_top H4).

     subst sh'.

     apply unit_identity in H4.

     unfold midObj in *.

     tauto.

  destruct (combjoin_assoc _ _ _ _ _ H2 H) as [v' [? ?]].

  exists (CPart (existT _ sh' H5) v').

  split; split...

Qed.



Lemma combineJ_com: forall a b c : combiner,

    join a b c -> join b a c.

Proof with auto.

  intros. unfold join in H|-*.

  icase a; icase b.

  icase c; red in H; red; destruct H;

  split...

  apply ijoin_com...

  apply join_comm...

Qed.



Lemma combineJ_canc {C1: Canc_alg T1}: forall a1 a2 b c : combiner,

       join a1 b c -> join a2 b c -> a1=a2.

Proof with auto.

   intros. unfold join in H,H0.

   icase c;icase b;icase a1;icase a2;inv H;inv H0;auto.



   destruct (ijoin_identity1 _ _ H).

   destruct (ijoin_identity1 _ _ H1).



   generalize (ijoin_canc _ _ _ _ H1 H).

   generalize (join_canc H2 H3); intros.

   subst sh2 v2...



   generalize (join_canc H2 H3).

   generalize (combjoin_canc _ _ _ _ H1 H); intros.

   f_equal...

   icase sh0; icase sh1.

   apply existT_ext...

Qed.



Lemma combineJ_ex_identities: forall a , {e : combiner &  join e a a}.

Proof with auto.

   intros.

   icase a;

   exists CEmpty;

   constructor...

Qed.



Lemma combineJ_self' {DA: Disj_alg A}:

  forall a b : combiner, join a a b -> identity a.

Proof.

  repeat intro.

  icase a; icase b; inv H.

  - icase a0; icase b0; inv H0; auto.

  - apply ijoin_identity2 in H1; contradiction.

  - clear - DA H2 A_top_full.

    icase sh. red in H2. simpl in H2.

    apply join_self in H2; destruct m; contradiction.

Qed.



Lemma combineJ_self {DA: Disj_alg A}:

        forall a b : combiner, join a a b -> a = b.

Proof.

  intros; eapply combineJ_self'; eauto.

Qed.



Instance Perm_combiner : Perm_alg combiner.

Proof. constructor.

  apply combineJ_eq.

  apply combineJ_assoc.

  apply combineJ_com.

   

  intros.

  hnf in H, H0.

  destruct a, a'; try contradiction; destruct b,b'; try contradiction; auto;

  try solve [destruct H; destruct H0; congruence].

  destruct H; destruct H0.

  f_equal.

  destruct sh as [sh i]; destruct sh0 as [sh0 i0];

  destruct sh1 as [sh1 i1]; destruct sh2 as [sh2 i2].

  apply existT_ext. unfold ijoin in H,H0.

  eapply join_positivity; eauto.

  eapply join_positivity; eauto.

Qed.



Instance Sep_combiner: Sep_alg combiner.

Proof.

  apply mkSep with (fun _ => CEmpty).

  intros. hnf.  destruct t; auto.

  auto.

Defined.



Instance Sing_combiner: Sing_alg combiner.

Proof.

  apply (mkSing CEmpty).

  auto.

Defined.



Instance Canc_combiner {C1: Canc_alg T1}: Canc_alg combiner.

Proof.

 repeat intro. eapply combineJ_canc; eauto.

Qed.



Instance Disj_combiner {D1: Disj_alg A}: Disj_alg combiner.

Proof.

 intro; apply combineJ_self'.

Qed.



Lemma identity_combiner {C1: Canc_alg T1}: forall d : combiner,

  identity d ->

  d = CEmpty.

Proof.

  intros.

  rewrite identity_unit_equiv in H.

  icase d.

  destruct H.

  destruct (ijoin_identity1 _ _ H).

Qed.



Lemma combiner_identity {C1: Canc_alg T1}:

  identity CEmpty.

Proof.

  intros.

  rewrite identity_unit_equiv.

  compute.

  trivial.

Qed.



Lemma combiner_full {C1: Canc_alg T1}: forall t2,

  full (CFull t2).

Proof.

  unfold full.  intros.

  destruct H as [sigma'' ?].

  icase sigma'.

  apply combiner_identity.

Qed.



End CombineJoin.



Arguments combiner [A] _ _ _.

Arguments Join_combiner [A] [JA] _ [T1 T2] _ _ _ _ _.

Arguments CEmpty [A JA T1 T2].

Arguments CPart [A JA T1 T2] _ _.

Arguments CFull [A JA T1 T2] _.



Section ParameterizedCombiner.



  Existing Instance Join_combiner.



  Variable S : Type.

  Variable JS : Join S.

  Variable pa_S : Perm_alg S.

  Variable sa_S : Sep_alg S.

  Variable ca_S : Canc_alg S.

  Variable da_S : Disj_alg S.



  Variable T1 : functor.

  Variable J1: forall A, Join (T1 A).

  Variable Perm1: forall A, Perm_alg (T1 A).

  Variable Sep1: forall A, Sep_alg (T1 A).

  Variable T2 : functor.



  Definition fcombiner (A : Type) : Type :=

    @combiner S JS (T1 A) (T2 A).



  Definition fcombiner_fmap (A B : Type) (f: A -> B) (g: B -> A)

    (fa : fcombiner A) : fcombiner B :=

      match fa with

        | CEmpty => CEmpty

        | CPart sh rs => CPart sh (fmap T1 f g rs)

        | CFull trs => CFull (fmap T2 f g trs)

      end.

  Arguments fcombiner_fmap [A B] _ _ _.



  Lemma ff_combiner : functorFacts fcombiner fcombiner_fmap.

  Proof with auto.

    constructor; intros;

    extensionality pd; unfold fcombiner_fmap.

    icase pd; rewrite fmap_id...

    icase pd; rewrite <- fmap_comp...

  Qed.



  Definition f_combiner : functor := Functor ff_combiner.



  Variable top_S : S.

  Variable topS_full : full top_S.

  Variable combjoin : forall A, (T1 A) -> (T1 A) -> (T2 A) -> Prop.

  Variable combjoin_eq : forall A v1 v1' v2 v2',

    combjoin A v1 v1' v2 ->

    combjoin A v1 v1' v2' ->

    v2 = v2'.

  Variable combjoin_assoc : forall A (v1 v2 v3 v4: T1 A) (v5: T2 A),

    join v1 v2 v3 ->

    combjoin A v3 v4 v5 ->

    {v' : (T1 A) & join v2 v4 v' /\ combjoin A v1 v' v5}.

  Variable combjoin_com : forall A v1 v2 v3,

    combjoin A v1 v2 v3 ->

    combjoin A v2 v1 v3.

  Variable combjoin_canc : forall A v1 v1' v2 v3,

    combjoin A v1 v2 v3 ->

    combjoin A v1' v2 v3 ->

    v1 = v1'.

  Variable saf_T1 : pafunctor T1 J1.



  Instance Join_fcombiner (A: Type) : Join (fcombiner A) :=

    Join_combiner top_S (J1 A) (combjoin A).



  Instance Perm_fcombiner (A: Type): Perm_alg (fcombiner A).

  Proof. apply Perm_combiner; auto.

     apply combjoin_eq. apply combjoin_assoc.

  Defined.



  Instance Sep_fcombiner (A: Type): Sep_alg (fcombiner A).

  Proof. apply Sep_combiner; auto.

  Defined.



  Instance Canc_fcombiner (A: Type) (CA: Canc_alg (T1 A)): Canc_alg (fcombiner A).

  Proof.  apply Canc_combiner; auto. apply combjoin_canc.

  Qed.



  Definition combjoin_hom (A : Type) (B : Type)

    (f : T1 A -> T1 B) (g : T2 A -> T2 B) : Prop :=

      forall x y z,

        combjoin A x y z ->

        combjoin B (f x) (f y) (g z).

  Arguments combjoin_hom [A B] _ _.



  Variable fmaps_combjoin_hom: forall A B (f : A -> B) (g: B -> A),

    combjoin_hom (fmap T1 f g) (fmap T2 f g).



  Lemma fmap_fcombiner_hom: forall A B (f : A -> B) (g: B -> A),

    join_hom (JA := Join_fcombiner A) (JB := Join_fcombiner B) (fmap f_combiner f g).

  Proof with auto.

    repeat intro. hnf in H|-*.

    icase x; icase y; icase z.

    destruct H.

    split; congruence.

    simpl in H. subst v0. simpl...

    destruct H.

    split; congruence.

    destruct H.

    split...

    apply paf_join_hom...

    destruct H.

    split...

    apply fmaps_combjoin_hom...

    simpl in H. subst v0. simpl...

  Qed.



  Definition combjoin_unmap_left (A B : Type)

    (f : T1 A -> T1 B) (g : T2 A -> T2 B) : Type :=

      forall (x' : T1 B) (y :T1 A) (z : T2 A),

        combjoin B x' (f y) (g z) ->

        {x : T1 A &  {y0 : T1 A | combjoin A x y0 z /\ f x = x' /\ f y0 = f y}}.

  Arguments combjoin_unmap_left [A B] _ _.



  Variable combjoin_preserves_unmap_left : forall A B (f : A -> B) (g: B -> A),

    combjoin_unmap_left (fmap T1 f g) (fmap T2 f g).



  Definition combjoin_unmap_right (A B : Type)

    (f : T1 A -> T1 B) (g : T2 A -> T2 B) : Type :=

      forall (x y :T1 A) (z' : T2 B),

        combjoin B (f x) (f y) z' ->

        {y0 : T1 A &  {z : T2 A | combjoin A x y0 z /\ f y0 = f y /\ g z = z'}}.

  Arguments combjoin_unmap_right [A B] _ _.



  Variable combjoin_preserves_unmap_right : forall A B (f : A -> B) (g: B -> A),

    combjoin_unmap_right (fmap T1 f g) (fmap T2 f g).



  Lemma fmap_fcombiner_preserves_unmap_left: forall A B (f : A -> B) (g: B -> A),

    unmap_left (Join_fcombiner A) (Join_fcombiner B) (fmap f_combiner f g).

  Proof with auto.

    repeat intro. simpl in H|-*. unfold join in H|-*. simpl in H|-*.

    icase x'; icase y; icase z.

    exists (CEmpty). exists (CEmpty). firstorder.

    exists (CEmpty). exists (CPart sh0 v0).

    destruct H. simpl.

    repeat split; congruence.

    exists (CEmpty). exists (CFull v0).

    simpl in H. simpl.

    repeat split; congruence.

    exists (CPart sh v0). exists (CEmpty).

    destruct H. simpl.

    repeat split; congruence.

    destruct H.

    generalize (paf_preserves_unmap_left saf_T1 f g v v0 v1 H0); intro X.

    destruct X as [x [y0 [? [? ?]]]].

    exists (CPart sh x). exists (CPart sh0 y0).

    split. split...

    simpl. split; congruence.

    

    destruct H.

    specialize ( combjoin_preserves_unmap_left A B f g v v0 v1 H).

    destruct combjoin_preserves_unmap_left as [x [y0 [? [? ?]]]].

    exists (CPart sh x). exists (CPart sh0 y0).

    split. split...

    simpl. split; congruence.

    

    exists (CFull v0). exists (CEmpty).

    simpl in H. simpl.

    repeat split; congruence.

  Qed.



  Lemma fmap_fcombiner_preserves_unmap_right: forall A B (f : A -> B) (g: B -> A),

    unmap_right (Join_fcombiner A) (Join_fcombiner B) (fmap f_combiner f g).

  Proof with auto.

    repeat intro. simpl in H|-*. unfold join in H|-*. simpl in H|-*.

    icase x; icase y; icase z'.

    exists (CEmpty). exists (CEmpty). firstorder.

    exists (CPart sh v). exists (CPart sh v).

    destruct H. simpl.

    repeat split; congruence.

    exists (CFull v). exists (CFull v).

    simpl in H. simpl.

    repeat split; congruence.

    exists (CEmpty). exists (CPart sh v).

    destruct H. simpl.

    repeat split; congruence.

    destruct H.

    generalize (paf_preserves_unmap_right saf_T1 f g v v0 v1 H0); intro X.

    destruct X as [y0 [z [? [? ?]]]].

    exists (CPart sh0 y0). exists (CPart sh1 z).

    split. split...

    simpl. split; congruence.

    

    destruct H.

    specialize ( combjoin_preserves_unmap_right A B f g v v0 v1 H).

    destruct combjoin_preserves_unmap_right as [y0 [z [? [? ?]]]].

    exists (CPart sh0 y0). exists (CFull z).

    split. split...

    simpl. split; congruence.

    

    exists (CEmpty). exists (CFull v).

    simpl in H. simpl.

    repeat split; congruence.

  Qed.



 Definition paf_combiner: @pafunctor f_combiner Join_fcombiner.

 Proof.

    constructor.

    apply fmap_fcombiner_hom.

    apply fmap_fcombiner_preserves_unmap_left.

    apply fmap_fcombiner_preserves_unmap_right.

 Qed.



End ParameterizedCombiner.



Arguments fcombiner [S] _ _ _ _.

Arguments combjoin_hom [T1 T2] _ [A B] _ _.

Arguments combjoin_unmap_left [T1 T2] _ [A B] _ _.

Arguments combjoin_unmap_right [T1 T2] _ [A B] _ _.

Arguments f_combiner [S JS T1 T2].



