

Require Import Coq.omega.Omega.

Require Import VST.msl.ageable.
(* VST.msl.ageable:
Require Import VST.msl.base.
  Require Coq.funind.Recdef.

Local Open Scope nat_scope.

Record ageable_facts (A:Type) (level: A -> nat) (age1:A -> option A)  :=
{ af_unage : forall x':A, exists x, age1 x = Some x'
; af_level1 : forall x, age1 x = None <-> level x = 0
; af_level2 : forall x y, age1 x = Some y -> level x = S (level y)
}.

Arguments af_unage [A] [level] [age1] _ _.
Arguments af_level1 [A] [level] [age1] _ _.
Arguments af_level2 [A] [level] [age1] _ _ _ _.

Class ageable (A:Type) := mkAgeable
{ level : A -> nat
; age1 : A -> option A
; age_facts : ageable_facts A level age1
}.

Definition age {A} `{ageable A} (x y:A) := age1 x = Some y.

Lemma af_wf {A} `{ageable A} :
 well_founded (fun x y => age y x).
Arguments af_wf [A] _ _.

Definition age_induction {A} `{ageable A} :=
  well_founded_induction (af_wf _).

Definition fashionR {A1} `{ageable A1} {A2}`{ageable A2} (x:A1) (y: A2) : Prop :=
  level x = level y.

Lemma fashionR_refl {A} `{ageable A} : reflexive _ fashionR.

Lemma fashionR_trans {A} `{ageable A} {B} `{ageable B} {C} `{ageable C} :
    forall (x: A) (y: B) (z: C), fashionR x y -> fashionR y z -> fashionR x z.

Lemma fashionR_sym {A} `{ageable A} {B} `{ageable B}:
   forall (x: A) (y: B), fashionR x y -> fashionR y x.

Lemma age_level {A} `{ageable A} : forall (x y:A),
  age x y -> level x = S (level y).

Lemma age1_level0 {A} `{ageable A} : forall (x:A),
  age1 x = None <-> level x = 0.

  Theorem level_level' : forall x:A, level x = level' x.
End level'.

Lemma levelS_age1 {A} `{ageable A} : forall (x:A) n,
  level x = S n ->
  exists y, age1 x = Some y.

Lemma age1_levelS {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  exists n, level x = S n.

Lemma age1_level0_absurd {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  level x = 0 ->
  False.

Lemma age1None_levelS_absurd {A} `{ageable A} : forall (x:A) n,
  age1 x = None ->
  level x = S n ->
  False.

Section RtRft.
  Variable A:Type.
  Variable R:relation A.

  Let Rt := clos_trans A R.
  Let Rft := clos_refl_trans A R.

  Lemma Rt_Rft : forall x y, Rt x y -> Rft x y.

  Lemma Rt_Rft_trans : forall x y z, Rt x y -> Rft y z -> Rt x z.

  Lemma Rft_Rt_trans : forall x y z, Rft x y -> Rt y z -> Rt x z.

  Lemma transpose_clos_trans : forall A R x y,
    clos_trans A (transp A R) x y <-> transp A (clos_trans A R) x y.
End RtRft.

Hint Resolve rt_refl.

Definition laterR {A} `{ageable A} : relation A := clos_trans A age.
Definition necR   {A} `{ageable A} : relation A := clos_refl_trans A age.

Require Coq.Wellfounded.Wellfounded.
Lemma laterR_wf {A} `{ageable A} :
  well_founded (transp _ laterR).

Definition laterR_induction {A} `{ageable A} :=
  @well_founded_induction A (transp A laterR) laterR_wf.

Lemma age_irreflexive {A}  `{ageable A}: forall x, age x x -> False.

Lemma laterR_irreflexive {A} `{HA: ageable A} : forall x, laterR x x -> False.

Lemma nec_refl_or_later {A} `{ageable A} : forall x y,
  necR x y -> x = y \/ laterR x y.

Lemma necR_antisym {A} `{ageable A} : forall x y,
  necR x y -> necR y x -> x = y.

Lemma age_later_nec {A} `{HA: ageable A} : forall x y z,
  age x y ->
  laterR x z ->
  necR y z.

Lemma necR_level {A} `{X: ageable A} : forall (x y:A),
  necR x y ->
  level x >= level y.

Lemma laterR_level {A} `{X: ageable A} : forall (x y:A),
  laterR x y ->
  level x > level y.

Section NAT_AGEABLE.

  Definition natLevel (x:nat) : nat := x.
  Definition natAge1 (x:nat) : option nat :=
    match x with
    | 0 => None
    | S n => Some n
    end.
  Definition natUnage (x:nat) : nat := S x.

  Lemma ag_nat_facts :
    ageable_facts nat natLevel natAge1.

  Definition ag_nat : ageable nat :=
    mkAgeable nat natLevel natAge1 ag_nat_facts.

  Lemma nec_nat : forall (n n':nat),
    @necR _ ag_nat n n' <-> n' <= n.

  Lemma later_nat : forall (n n':nat),
    @laterR _ ag_nat n n' <-> n' < n.

End NAT_AGEABLE.

Lemma laterR_level' {A} `{H : ageable A}: forall {w1 w2: A}, laterR w1 w2 -> @laterR _ ag_nat (level w1) (level w2).

Lemma necR_nat {A} `{H : ageable A}:
    forall {x y: A}, necR x y -> @necR nat ag_nat (level x) (level y).

Section BIJECTION.
  Variable A B : Type.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.

  Let levelB (x:B) : nat :=
    level (bij_g _ _ bijAB x).

  Let age1B  (x: B) : option B :=
     match age1 (bij_g _ _ bijAB x) with
     | Some y => Some (bij_f _ _ bijAB y)
     | None => None
     end.

  Let ageB (x y: B) :=age1B x = Some y.

  Lemma age_bij_unage :
    forall x', exists x, age1B x = Some x'.

  Lemma age_bij_level1 :
    forall x, age1B x = None <-> levelB x = 0.

  Lemma age_bij_level2 :
    forall x y, age1B x = Some y -> levelB x = S (levelB y).

  Lemma ag_bij_facts : ageable_facts B levelB age1B.

  Definition ag_bij : ageable B :=
    mkAgeable B levelB age1B ag_bij_facts.
End BIJECTION.

Section PROD.
  Variable A B : Type.
  Variable agA: ageable A.

  Let levelAB (x:prod A B) := level (fst x).
  Let age1AB (x:prod A B) :=
    match age1 (fst x) with
    | None => None
    | Some a' => Some (a',snd x)
    end.

  Lemma ag_prod_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod :=
    mkAgeable (prod A B) levelAB age1AB ag_prod_facts.

  Lemma prod_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod (n,x) (n',x') <-> necR n n' /\ x = x'.

  Lemma prod_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod (n,x) (n',x') <-> laterR n n' /\ x = x'.

End PROD.

Section PROD'.
  Variable A B : Type.
  Variable agB: ageable B.

  Let levelAB (x:prod A B) := level (snd x).
  Let age1AB (x:prod A B) :=
    match age1 (snd x) with
    | None => None
    | Some a' => Some (fst x, a')
    end.

  Lemma ag_prod'_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod' :=
    mkAgeable (prod A B) levelAB age1AB ag_prod'_facts.

  Lemma prod'_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod' (x,n) (x',n') <-> necR n n' /\ x = x'.

  Lemma prod'_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod' (x,n) (x',n') <-> laterR n n' /\ x = x'.

End PROD'.

Fixpoint composeOptN (A: Type) (f: A -> option A)
         (n: nat) (w: A) {struct n} : option A :=
 match n  with
 | S n' => match f w with Some w' => composeOptN A f n' w' | None => None end
 | O => Some w
 end.
Arguments composeOptN [A] _ _ _.

Definition ageN {A} `{ageable A}: nat -> A -> option A := composeOptN age1.

Lemma ageN1  {A} `{ageable A}: ageN 1 = age1.

Lemma ageN_compose {A} `{agA : ageable A}:
 forall a b c phi1 phi2 phi3,ageN a phi1 = Some phi2 ->
       ageN b phi2 = Some phi3 ->  (a+b=c)%nat ->  ageN c phi1 = Some phi3.

Lemma ageN_compose' {A} `{agA : ageable A}:
  forall a b phi1 phi3,
   ageN (a+b)%nat phi1 = Some phi3 -> exists phi2, ageN a phi1 = Some phi2 /\ ageN b phi2 = Some phi3.

Lemma necR_evolve {A} `{agA : ageable A}:
    necR = fun (phi phi': A) => exists n, ageN n phi = Some phi'.

Lemma age_noetherian  {A} `{ageable A}: forall phi, exists n, ageN n phi = None.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma age_noetherian'  {A} `{agA : ageable A}:
       forall phi, exists! n, exists phi', ageN n phi = Some phi' /\ age1 phi' = None.

Lemma ageable_ext:
   forall A (B C: ageable A),
      @age1 _ B = @age1 _ C -> @level _ B = @level _ C -> B=C.

Lemma necR_linear {A} `{H : ageable A}:
  forall {a b c}, necR a b -> necR a c -> necR b c \/ necR c b.

Lemma necR_linear' {A} `{H : ageable A}:
   forall {a b c}, necR a b -> necR a c -> level b = level c -> b=c.

Lemma laterR_necR {A} `{agA : ageable A}:
  forall {x y}, laterR x y -> necR x y.

Lemma necR_refl {A} `{H : ageable A}:
  forall phi, necR phi phi.

Hint Resolve @necR_refl.

Lemma necR_trans  {A} `{H : ageable A}:
  forall phi1 phi2 phi3, necR phi1 phi2 -> necR phi2 phi3 -> necR phi1 phi3.

Lemma necR_laterR {A} `{agA : ageable A}:
  forall w1 w2 w3, necR w1 w2 -> laterR w2 w3 -> laterR w1 w3. *)

Require Import VST.msl.predicates_hered.
(* VST.msl.predicates_hered:
Require Import VST.msl.base.
Require Import VST.msl.ageable.

Delimit Scope pred with pred.
Local Open Scope pred.

Definition hereditary {A} (R:A->A->Prop) (p:A->Prop) :=
  forall a a':A, R a a' -> p a -> p a'.

Definition pred (A:Type) {AG:ageable A} :=
  { p:A -> Prop | hereditary age p }.

Bind Scope pred with pred.

Definition app_pred {A} `{ageable A} (p:pred A) : A -> Prop := proj1_sig p.
Definition pred_hereditary `{ageable} (p:pred A) := proj2_sig p.
Coercion app_pred : pred >-> Funclass.
Global Opaque pred.

Hint Resolve @pred_hereditary.

Lemma nec_hereditary {A} `{ageable A} (p: A -> Prop) : hereditary age p ->
  forall a a':A, necR a a' -> p a -> p a'.

Lemma pred_nec_hereditary {A} `{ageable A} (p:pred A) :
  forall a a':A, necR a a' -> p a -> p a'.

Program Definition mkPred {A} `{ageable A} (p:A -> Prop) : pred A :=
  fun x => forall x', necR x x' -> p x'.

Definition derives {A} `{ageable A} (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] [H] _ _.

Definition valid_rel {A} `{ageable A} (R:relation A) : Prop :=
  commut A age R /\ commut A R age.

Definition modality {A} `{ageable A} := { R:relation A | valid_rel R }.

Definition app_mode {A} `{ageable A} (m:modality) : A -> A -> Prop := proj1_sig m.
Definition mode_valid {A} `{ageable A} (m:modality) := proj2_sig m.
Global Opaque modality.
Coercion app_mode : modality >-> Funclass.

Lemma valid_rel_commut_later1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A laterR R.

Lemma valid_rel_commut_later2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R laterR.

Lemma valid_rel_commut_nec1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A necR R.

Lemma valid_rel_commut_nec2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R necR.

Lemma valid_rel_age {A} `{ageable A} : valid_rel age.

Lemma valid_rel_later {A} `{ageable A} : valid_rel laterR.

Lemma valid_rel_nec {A} `{ageable A} : valid_rel necR.

Definition ageM {A} `{ageable A} : modality
  := exist _ age valid_rel_age.
Definition laterM {A} `{ageable A} : modality
  := exist _ laterR valid_rel_later.

Hint Resolve rt_refl rt_trans t_trans.
Hint Unfold necR.
Obligation Tactic := unfold hereditary; intuition;
    first [eapply pred_hereditary; eauto; fail | eauto ].

Program Definition prop {A} `{ageable A}  (P: Prop) : pred A := (fun _  => P).

Definition TT {A} `{ageable A}: pred A := prop True.
Definition FF  {A} `{ageable A}: pred A := prop False.

Program Definition imp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => forall a':A, necR a a' -> P a' -> Q a'.
Program Definition orp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a \/ Q a.

Program Definition andp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a /\ Q a.

Program Definition allp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.

Program Definition exp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Program Definition box {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => forall a', M a a' -> P a'.

Program Definition diamond {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => exists a', M a' a /\ P a'.

Definition boxy {A} `{ageable A} (m: modality) (p: pred A): Prop :=  box m p = p.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.

Notation "'|>' e" := (box laterM e) (at level 30, right associativity): pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Lemma modus_ponens {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma andp_right {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

  Lemma pred_ext' {A} `{ageable A}: forall (p1 p2:pred A),
    app_pred p1 = app_pred p2 ->
    p1 = p2.

Lemma pred_ext : forall A `{ageable A} (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma andp_dup {A}{agA: ageable A}: forall P: pred A, P && P = P.

Lemma andp_left1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}{agA: ageable A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma derives_trans {A}`{ageable A}:
    forall P Q R: pred A, P |-- Q -> Q |-- R -> P |-- R.

Lemma exp_right:
  forall {B A: Type}{agA: ageable A}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}{agA: ageable A}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma and1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A} `{ageable A} : forall X P,
  X |-- P --> TT.

Lemma FFrule {A} `{ageable A} : forall X P,
  X |-- FF --> P.

Lemma distribution {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma imp_andp_adjoint {A} `{ageable A} : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma box_e0 {A} `{ageable A}: forall (M: modality) Q,
            reflexive _ M -> box M Q  |-- Q.
Arguments box_e0 [A] _ _ _ _ _ _.

Lemma boxy_i {A} `{ageable A}:
  forall (Q: pred A) (M: modality),
    reflexive _ M ->
    (forall w w', M w w' -> Q w -> Q w') ->
    boxy M Q.

Lemma box_diamond {A} `{ageable A} : forall M (P Q:pred A),
  (diamond M P) |-- Q <-> P |-- (box M Q).

Lemma ruleNec {A} `{ageable A} : forall M (P:pred A),
  derives TT P ->
  derives TT (box M P).

Lemma axiomK {A} `{ageable A}: forall M (P Q:pred A),
  (box M (P --> Q)) |-- (box M P --> box M Q).

Lemma box_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  box M P |-- box M Q.

Lemma diamond_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  diamond M P |-- diamond M Q.

Lemma box_refl_trans {A} `{ageable A}: forall (m:modality) p,
  reflexive _ m ->
  transitive _ m ->
  box m (box m p) = box m p.

Lemma box_and {A} `{ageable A}: forall R (P Q:pred A),
  box R (P && Q) = box R P && box R Q.

Lemma box_all {A} `{ageable A} : forall B R (F:B -> pred A),
  box R (allp F) = ALL x:B, box R (F x).

Lemma box_ex {A} `{ageable A} : forall B R (F:B->pred A),
  EX x:B, box R (F x) |-- box R (exp F).

Lemma box_or {A} `{ageable A} : forall R (P Q:pred A),
   box R P || box R Q |-- box R (P || Q).

Lemma diamond_or {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P || Q) = diamond R P || diamond R Q.

Lemma diamond_ex {A} `{ageable A} : forall B R (F:B -> pred A),
  diamond R (exp F) = EX x:B, diamond R (F x).

Lemma diamond_and {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P && Q) |-- diamond R P && diamond R Q.

Lemma diamond_all {A} `{ageable A} : forall B R (F:B->pred A),
  diamond R (allp F) |-- ALL x:B, diamond R (F x).

Lemma later_age {A} `{ageable A} : forall P,
  |>P = box ageM P.

Lemma now_later {A} `{ageable A} : forall P,
  P |-- |>P.

Lemma now_later2 {A} `{ageable A} : forall G P,
  G |-- P ->
  G |-- |>P.

Lemma goedel_loeb {A} `{ageable A} : forall (P Q:pred A),
  Q && |>P |-- P ->
  Q |-- P.

Lemma loeb {A} `{ageable A} : forall (P:pred A),
     |>P |-- P    ->     TT |-- P.

Lemma later_commute_dia {A} `{ageable A} : forall M (P:pred A),
  diamond M (|> P) |-- |> (diamond M P).

Lemma later_commute {A} `{ageable A} : forall M (P:pred A),
  box M (|>P) = |>(box M P).

Lemma later_and {A} `{ageable A} : forall P Q,
  |>(P && Q) = |>P && |> Q.

Lemma later_or {A} `{ageable A} : forall (P Q:pred A),
  |>(P || Q) = |>P || |>Q.

Lemma later_ex {A} `{ageable A} : forall B (F:B->pred A),
  B ->
  |>(exp F) = EX x:B, |>(F x).

Lemma later_ex'' {A} `{ageable A} : forall B (F:B->pred A),
  |>(exp F) |-- (EX x:B, |>(F x)) || |> FF.

Lemma later_imp {A} `{ageable A} : forall P Q,
  |>(P --> Q) = |>P --> |>Q.

Lemma TT_boxy {A} `{ageable A} : forall M,
  boxy M TT.

Lemma positive_boxy {A} `{ageable A} : forall P Q M,
  boxy M P ->
  P |-- Q ->
  P |-- box M Q.

Lemma forallI {A} `{ageable A} : forall A G X,
  (forall x:A, G |-- X x) ->
  G |-- allp X.

Lemma TT_and {A} `{ageable A} : forall P,
  TT && P = P.

Lemma andp_comm {A} `{ageable A} : forall P Q,
  P && Q = Q && P.

Lemma andp_assoc {A} `{ageable A} : forall P Q R,
  (P && Q) && R = P && (Q && R).

Lemma ex_and : forall {A} `{ageable A} B (P:B->pred A) Q,
  (exp P) && Q = EX x:B, P x && Q.

Lemma FF_and : forall {A} `{ageable A} (P:pred A),
  FF && P = FF.

Lemma boxy_e {A} `{H : ageable A}: forall (M: modality) P,  boxy M P ->
           forall w w', app_mode M w w' -> P w -> P w'.

Lemma boxy_andp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P && Q).

Hint Resolve @boxy_andp.

Lemma boxy_disjunction {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Hint Resolve @boxy_disjunction.

Lemma boxy_exp {A} `{agA : ageable A}:
    forall (M: modality) T (P: T -> pred A),
     reflexive _ (app_mode M) ->
     (forall x, boxy M (P x)) -> boxy M (exp P).

Hint Resolve @boxy_exp.

Lemma boxy_prop {A} `{H : ageable A}:  forall (M: modality) P, reflexive _ (app_mode M) -> boxy M (prop P).

Lemma boxy_TT {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M TT.

Lemma boxy_FF {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M FF.

Hint Resolve @boxy_TT.
Hint Resolve @boxy_FF.

Lemma TT_i  {A} `{ageable A}: forall w: A,  app_pred TT w.

Hint Resolve @TT_i.

Lemma prop_andp_left {A}{agA: ageable A}: forall (P: Prop) Q R, (P -> Q |-- R) -> !!P && Q |-- R.

Lemma prop_andp_right {A}{agA: ageable A}: forall (P: Prop) Q R, P -> Q |-- R -> Q |-- !!P && R.

Lemma prop_true_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_false_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A),
   ~P -> !! P && Q = FF.

Lemma prop_andp_e {A} `{ageable A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A} `{ageable A}:  forall P Q (w:A), P /\ app_pred Q w -> (!! P && Q) w.

Lemma later_derives {A} `{agA : ageable A}: forall {P Q}, (P |-- Q) -> (|> P |-- |> Q).

Lemma boxy_allp {A} `{agA : ageable A}:
  forall (M: modality) (B: Type) F,
     reflexive _ (app_mode M) ->
     (forall (x:B), boxy M (F x)) -> boxy M (allp F).
Hint Resolve @boxy_allp.

Lemma later_allp {A} `{agA : ageable A}:
       forall B P, |> (allp P) = allp (fun x:B => |> (P x)).

Lemma later_prop {A} `{agA : ageable A}:
       forall P: Prop, |> (prop P) |-- prop P || |> FF.

Lemma box_derives {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->  box M P |-- box M Q.

Lemma allp_derives:
       forall {A: Type} `{agA: ageable A} (B: Type) (P Q: B -> pred A),
               (forall x:B, P x |-- Q x) -> (allp P |-- allp Q).

Lemma forall_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (ALL x : B, P x) <--> (ALL x: B, Q x) .

Lemma exists_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (EX x : B, P x) <--> (EX x: B, Q x) .

Lemma imp_pred_ext  {A} `{agA : ageable A}: forall B B' P Q,
       (B <--> B') && (B --> (P <--> Q))
 |-- (B --> P) <-->  (B' --> Q).

Lemma derives_refl {A: Type} `{ageable A}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma andp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma orp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P || Q |-- P' || Q'.

Lemma exp_derives {A} `{HA : ageable A}:
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma box_ext {A} `{agA : ageable A}: forall (M: modality) P Q,
    box M (P <--> Q) |--  box M P <--> box M Q.

Lemma andp_pred_ext {A} `{agA : ageable A}: forall P Q P' Q',
       (P <--> P') && (Q <--> Q') |--  (P && Q) <--> (P' && Q').

Program Definition exactly {A} `{ageable A} (x: A) : pred A := necR x.

Lemma derives_TT {A} `{ageable A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma FF_derives {A} `{ageable A}: forall P, FF |-- P.
Hint Immediate @FF_derives.

Lemma necR_level' {A} `{H : ageable A}: forall {w w': A}, necR w w' ->
       @necR _ ag_nat (level w) (level w').

Lemma derives_imp {A} `{agA : ageable A}:
  forall P Q w, (P |-- Q) -> (P --> Q) w.

Lemma exp_andp1 {A} `{ageable A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_andp2 {A} `{HA: ageable A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma exp_imp_left {A} `{agA : ageable A}:  forall B (p: B -> pred A) q,
     (exp p --> q)%pred = allp (fun x => p x --> q)%pred.

Lemma app_ext  {A: Type} `{ageable A} : forall (F G: A -> Prop) p1 p2 w,
         (F w = G w) ->
         app_pred (exist (hereditary age) F p1) w = app_pred (exist (hereditary age) G p2) w.

Lemma imp_derives {A} `{agA : ageable A}:
  forall P P' Q Q',
    P' |-- P ->
    Q |-- Q' ->
    P --> Q |-- P' --> Q'.

Lemma imp_lem0  {A} `{agA : ageable A}:  forall P st, (TT --> P) st -> P st.

Lemma conjoin_hyp0  {A} `{H : ageable A}:
      forall (P Q: pred A) w,  P w -> (P --> Q) w -> (TT --> Q) w.

Lemma conjoin_hyp1 {A} `{agA : ageable A}: forall (P Q R: pred A)  w,
            P w -> (P&&Q --> R) w -> (Q --> R) w.

Lemma derives_e {A: Type} `{agA : ageable A}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Ltac slurp :=
 apply imp_lem0;
  match goal with |-  app_pred (_ --> _)  ?st =>
        repeat match goal with
                   | H: app_pred ?P st |- app_pred (?b --> ?c) st =>
                       (apply (@conjoin_hyp0 _ _ P c st H) ||
                        (apply (@conjoin_hyp1 _ _ P b c st H)));
                       clear H
                   end;
        try (revert st; apply derives_e)
  end.

Lemma test_slurp {A} `{agA : ageable A} :  forall  (P Q R S : pred A) w ,
        (P && (Q && R) --> S) w -> P w -> Q w -> R w -> S w.

Lemma later_andp {A} `{H : ageable A}:
  forall P Q, |> (P && Q) = |>P && |>Q.

Lemma True_andp_eq {A}`{ageable A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma distrib_orp_andp {A}{agA: ageable A}:
   forall P Q R, (P||Q)&&R = (P&&R)||(Q&&R).

Lemma allp_right {B A: Type}{agA: ageable A}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}{agA: ageable A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma later_imp2 {A}{agA: ageable A}: forall P Q: pred A,
                 |> (P <--> Q) = |> P <--> |> Q. *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.age_sepalg.
(* VST.msl.age_sepalg:
Require Import VST.msl.base.
Require Import VST.msl.ageable.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Class Age_alg (A:Type) {JOIN: Join A}{as_age : ageable A} :=
mkAge {
  age1_join : forall x {y z x'}, join x y z -> age x x' ->
    exists y':A, exists z':A, join x' y' z' /\ age y y' /\ age z z'
; age1_join2 : forall x {y z z'}, join x y z -> age z z' ->
    exists x':A, exists y':A, join x' y' z' /\ age x x' /\ age y y'
; unage_join : forall x {x' y' z'}, join x' y' z' -> age x x' ->
    exists y:A, exists z:A, join x y z /\ age y y' /\ age z z'
; unage_join2 : forall z {x' y' z'}, join x' y' z' -> age z z' ->
    exists x:A, exists y:A, join x y z /\ age x x' /\ age y y'
}.

Lemma age1_None_joins {A}{JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2, joins phi1 phi2 -> age1 phi1 = None -> age1 phi2 = None.

Lemma age1_joins_eq {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2,
        joins phi1 phi2 ->
        forall phi1', age1 phi1 = Some phi1' ->
        forall phi2', age1 phi2 = Some phi2' ->
        joins phi1' phi2'.

Section BIJECTION.
  Variables A B : Type.
  Variable JA: Join A.
  Variable PA: Perm_alg A.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.
  Variable asa : Age_alg A.

  Existing Instance PA.

  Instance agB : ageable B := (ag_bij _ _ ag bijAB).

  Theorem asa_bijection : @Age_alg B (Join_bij _ _ _ bijAB) agB.
End BIJECTION.

Section PROD.
  Variable A : Type.
  Variable J_A: Join A.
  Variable saA : Perm_alg A.
  Variable agA : ageable A.
  Variable B: Type.
  Variable J_B: Join B.
  Variable saB : Perm_alg B.
  Variable asa : Age_alg A.

  Theorem asa_prod : @Age_alg (prod A B) _ (ag_prod A B agA).
End PROD.

Section PROD'.
  Variable A : Type.
  Variable J_A: Join A.
  Variable saA : Perm_alg A.
  Variable B: Type.
  Variable J_B: Join B.
  Variable saB : Perm_alg B.
  Variable agB : ageable B.
  Variable asb : Age_alg B.

  Theorem asa_prod' : @Age_alg (prod A B) _ (ag_prod' A B agB).
End PROD'.

Lemma joins_fashionR {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A} : forall x y,
  joins x y -> fashionR x y.

Lemma comparable_fashionR {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A} {XA: Age_alg A} : forall x y,
  comparable x y -> fashionR x y.

Lemma age_identity {A} `{asaA: Age_alg A}: forall phi phi', age phi phi'->
    identity phi -> identity phi'.

Lemma age_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A}{asaA: Age_alg A}:
    forall phi1 phi2 phi1' phi2', age phi1 phi1' -> age phi2 phi2' ->
      comparable phi1 phi2 -> comparable phi1' phi2'.

  Lemma asa_nat : @Age_alg nat (Join_equiv nat) ag_nat.

Lemma nec_identity {A} `{asaA: Age_alg A}: forall phi phi', necR phi phi'->
    identity phi -> identity phi'.

Lemma nec_join2 {A} `{asaA : Age_alg A}: forall {x y z z' : A},
       join x y z ->
       necR z z' ->
       exists x',
         exists y',
           join x' y' z' /\ necR x x' /\ necR y y'.

Lemma nec_join {A} `{asaA : Age_alg A}: forall {x y z x' : A},
       join x y z ->
       necR x x' ->
       exists y' ,
         exists z' ,
           join x' y' z' /\ necR y y' /\ necR z z'.

Lemma nec_join4 {A} `{asaA : Age_alg A}: forall z x' y' z' : A,
       join x' y' z' ->
       necR z z' ->
       exists x,
         exists y,
           join x y z /\ necR x x' /\ necR y y'.

Lemma join_level {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{AgeA: Age_alg A}:
  forall x y z, join x y z -> level x = level z /\ level y = level z.

 Lemma level_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
     forall m:A, level (core m) = level m.

Lemma age_core_eq {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y x' y', age x x' -> age y y' -> core x = core y -> core x' = core y'.

Lemma age_twin {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:
  forall phi1 phi2 n phi1',
  level phi1 = level phi2 ->
  ageN n phi1 = Some phi1' ->
  exists phi2', ageN n phi2 = Some phi2' /\ level phi1' = level phi2'.

Lemma age1_join_eq {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3,
        join phi1 phi2 phi3 ->
        forall phi1', age1 phi1 = Some phi1' ->
        forall phi2', age1 phi2 = Some phi2' ->
        forall phi3', age1 phi3 = Some phi3' ->
        join phi1' phi2' phi3'.

Lemma strong_nat_ind (P : nat -> Prop) (IH : forall n, (forall i, lt i n -> P i) -> P n) n : P n.

Lemma age_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y : A, age x y -> age (core x) (core y).

Lemma necR_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y : A, necR x y -> necR (core x) (core y).

Definition relation_mul {A: Type} (R0 R1: relation A) (x y: A) := exists z, R0 x z /\ R1 z y.

Fixpoint relation_power {A: Type} (n: nat) (R: relation A) :=
  match n with
  | O => eq
  | S n0 => relation_mul R (relation_power n0 R)
  end.

Fixpoint partial_fun_power {A: Type} (n: nat) (f: A -> option A) (x: A) :=
  match n with
  | O => Some x
  | S n0 => match f x with
            | Some fx => partial_fun_power n0 f fx
            | None => None
            end
  end.

Lemma laterR_power_age: forall {A:Type} {agA:ageable A} (x y: A),
  laterR x y <-> (exists n, relation_power (S n) age x y).

Lemma necR_power_age: forall {A:Type} {agA:ageable A} (x y: A),
  necR x y <-> (exists n, relation_power n age x y).

Lemma power_age_age1: forall {A:Type} {agA:ageable A} n x y,
  relation_power n age x y <-> partial_fun_power n age1 x = Some y.

Lemma power_age1_level_small: forall {A:Type} {agA:ageable A} n x,
  partial_fun_power n age1 x = None <-> level x < n.

Lemma power_age_core: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x y: A) n,
  relation_power n age x y -> relation_power n age (core x) (core y).

Lemma power_age_core_eq: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y y': A) n,
  relation_power n age x x' -> relation_power n age y y' -> core x = core y -> core x' = core y'.

Lemma levelS_age {A: Type} {agA: ageable A} : forall (x:A) n,
  S n = level x ->
  exists y, age x y /\ n = level y.

Lemma clos_refl_trans_addone: forall (A : Type) (R : relation A) (x y z: A), R x y -> clos_refl_trans A R y z -> clos_refl_trans A R x z.

Lemma necR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), necR x x' -> level x = level y -> exists y', (necR y y' /\ level x' = level y').

Lemma laterR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), laterR x x' -> level x = level y -> exists y', (laterR y y' /\ level x' = level y').

Lemma power_age_parallel: forall {A:Type} {agA:ageable A} (x x' y: A) n,
  level x = level y ->
  relation_power n age x x' ->
  exists y', relation_power n age y y'.

Lemma power_age_parallel': forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y: A) n,
  core x = core y ->
  relation_power n age x x' ->
  exists y', relation_power n age y y' /\ core x' = core y'. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)



Definition age1' {A} `{agA : ageable A} : A -> A :=

  fun x => match age1 x with Some y => y | None => x end.



Definition age_by n {A} `{agA : ageable A} : A -> A := Nat.iter n age1'.



Lemma level_age1' {A} `{agA : ageable A} x : level (age1' x) = level x - 1.

Proof.

  unfold age1'. destruct (age1 x) eqn:E.

  - apply age_level in E. omega.

  - apply age1_level0 in E. omega.

Qed.



Lemma level_age_by n {A} `{agA : ageable A} x : level (age_by n x) = level x - n.

Proof.

  revert x; induction n; intros x; simpl.

  - omega.

  - simpl. rewrite level_age1'. rewrite IHn. omega.

Qed.



Lemma age_age_by n {A} `{agA : ageable A} (x y : A) : age x y -> age_by (S n) x = age_by n y.

Proof.

  intros E.

  induction n.

  - simpl.

    unfold age1' in *.

    rewrite E. auto.

  - change (age1' (age_by (S n) x) = age_by (S n) y).

    rewrite IHn.

    reflexivity.

Qed.



Definition age_to k {A} `{agA : ageable A} (x : A) : A := age_by (level x - k) x.



Lemma level_age_to k {A} `{agA : ageable A} x : k <= level x -> level (age_to k x) = k.

Proof.

  intros L. unfold age_to.

  rewrite level_age_by; omega.

Qed.



Lemma age_to_lt k {A} `{agA : ageable A} (x : A) : k < level x -> exists y, age x y /\ age_to k x = age_to k y.

Proof.

  intros L.

  destruct (age1 x) as [y|] eqn:Ex; swap 1 2.

  - rewrite age1_level0 in Ex. omega.

  - exists y; split; auto.

    unfold age_to.

    pose proof age_level _ _ Ex as E.

    replace (level x - k) with (S (level y - k)) by omega.

    generalize (level y - k).

    clear E L.

    intros.

    apply age_age_by, Ex.

Qed.



Lemma age_to_ge k {A} `{agA : ageable A} (x : A) : k >= level x -> age_to k x = x.

Proof.

  intros E. unfold age_to.

  replace (level x - k) with 0 by auto with *.

  reflexivity.

Qed.



Lemma age_to_eq k {A} `{agA : ageable A} (x : A) : k = level x -> age_to k x = x.

Proof.

  intros ->; apply age_to_ge, le_refl.

Qed.



Lemma age_age_to n {A} `{agA : ageable A} x y : level x = S n -> age x y -> age_to n x = y.

Proof.

  intros E Y.

  assert (L : (n < level x)%nat) by omega.

  unfold age_to. rewrite E. replace (S n - n) with 1 by omega.

  simpl. unfold age1'. rewrite Y. reflexivity.

Qed.



Lemma age_by_ind {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> P x -> P y) ->

  forall x n, P x -> P (age_by n x).

Proof.

  intros IH x n.

  unfold age_by.

  induction n; intros Px.

  - auto.

  - simpl. unfold age1' at 1.

    destruct (age1 (Nat.iter n age1' x)) as [y|] eqn:Ey; auto.

    eapply IH; eauto.

Qed.



Lemma age_to_ind {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> P x -> P y) ->

  forall x n, P x -> P (age_to n x).

Proof.

  intros IH x n.

  apply age_by_ind, IH.

Qed.



Lemma age_to_ind_refined n {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> n <= level y -> P x -> P y) ->

  forall x, P x -> P (age_to n x).

Proof.

  intros IH x Px.

  assert (dec : n >= level x \/ n <= level x) by omega.

  destruct dec as [Ge|Le].

  - rewrite age_to_ge; auto.

  - eapply (age_to_ind (fun x => n <= level x -> P x)); auto.

    + intros x0 y H H0 H1.

      eapply IH; eauto.

      apply age_level in H.

      apply H0.

      omega.

    + rewrite level_age_to; auto.

Qed.



Lemma iter_iter n m {A} f (x : A) : Nat.iter n f (Nat.iter m f x) = Nat.iter (n + m) f x.

Proof.

  induction n; auto; simpl. rewrite IHn; auto.

Qed.



Lemma age_by_age_by n m  {A} `{agA : ageable A} (x : A) : age_by n (age_by m x) = age_by (n + m) x.

Proof.

  apply iter_iter.

Qed.



Lemma age_by_ind_opp {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> P y -> P x) ->

  forall x n, P (age_by n x) -> P x.

Proof.

  intros IH x n.

  unfold age_by.

  induction n; intros Px.

  - auto.

  - simpl in Px. unfold age1' at 1 in Px.

    destruct (age1 (Nat.iter n age1' x)) as [y|] eqn:Ey; auto.

    eapply IH in Ey; eauto.

Qed.



Lemma age_to_ind_opp {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> P y -> P x) ->

  forall x n, P (age_to n x) -> P x.

Proof.

  intros IH x n.

  apply age_by_ind_opp, IH.

Qed.



Lemma rewrite_age_to {A} `{agA : ageable A} (P : A -> Prop) :

  (forall x y, age x y -> P x <-> P y) ->

  forall x n, P x <-> P (age_to n x).

Proof.

  intros IH x n; split.

  - apply age_to_ind. intros; rewrite <-IH; eauto.

  - apply age_to_ind_opp. intros; rewrite IH; eauto.

Qed.



Lemma level_age_to_le k {A} `{agA : ageable A} x : level (age_to k x) <= level x.

Proof.

  destruct (le_lt_dec k (level x)) as [l|l]. rewrite level_age_to; auto.

  rewrite age_to_ge; omega.

Qed.



Lemma level_age_to_le' k {A} `{agA : ageable A} x : level (age_to k x) <= k.

Proof.

  destruct (le_lt_dec k (level x)) as [l|l]. rewrite level_age_to; auto.

  rewrite age_to_ge; omega.

Qed.



Lemma age_by_necR {A} `{agA : ageable A} n x : necR x (age_by n x).

Proof.

  generalize (necR_refl x).

  generalize x at 1 3; intros u.

  apply age_by_ind; clear x.

  intros x y a N.

  constructor 3 with x; auto.

  constructor; auto.

Qed.



Lemma age_to_necR {A} `{agA : ageable A} n x : necR x (age_to n x).

Proof.

  apply age_by_necR.

Qed.



Lemma necR_age_by {A} `{agA : ageable A} x x' : necR x x' -> x' = age_by (level x - level x') x.

Proof.

  intros N; induction N.

  - rewrite (age_level _ _ H).

    replace (S _ - _) with 1. 2:omega.

    simpl. unfold age1'. rewrite H; auto.

  - replace (_ - _) with 0. 2:omega. reflexivity.

  - rewrite IHN2, IHN1.

    rewrite age_by_age_by.

    repeat rewrite level_age_by.

    f_equal.

    apply necR_level in N1.

    apply necR_level in N2.

    replace (_ x - (_ x - _ y)) with (level y) by omega.

    replace (_ y - _ z + (_ x - _ y)) with (level x - level z) by omega.

    omega.

Qed.



Lemma necR_age_to {A} `{agA : ageable A} x x' : necR x x' -> x' = age_to (level x') x.

Proof.

  apply necR_age_by.

Qed.



Lemma necR_age_by_iff {A} `{agA : ageable A} x x' : necR x x' <-> x' = age_by (level x - level x') x.

Proof.

  split. apply necR_age_by. intros ->. apply age_by_necR.

Qed.



Lemma necR_age_to_iff {A} `{agA : ageable A} x x' : necR x x' <-> x' = age_to (level x') x.

Proof.

  apply necR_age_by_iff.

Qed.



Lemma age_to_pred {A} `{agA : ageable A} (P : pred A) x n :

  app_pred P x ->

  app_pred P (age_to n x).

Proof.

  apply age_to_ind. clear x n.

  destruct P as [x h]. apply h.

Qed.



Lemma age_by_pred {A} `{agA : ageable A} (P : pred A) x n :

  app_pred P x ->

  app_pred P (age_by n x).

Proof.

  apply age_by_ind. clear x n.

  destruct P as [x h]. apply h.

Qed.



Lemma pred_age1' {A} `{agA : ageable A} (R : pred A) x : app_pred R x -> app_pred R (age1' x).

Proof.

  unfold age1'. destruct (age1 x) as [phi' | ] eqn:Ephi'; auto.

  destruct R as [R h]. apply h. apply Ephi'.

Qed.



Lemma age_by_age_by_pred {A} `{agA : ageable A} (P : pred A) x n1 n2 :

  le n1 n2 ->

  app_pred P (age_by n1 x) ->

  app_pred P (age_by n2 x).

Proof.

  intros l. replace n2 with ((n2 - n1) + n1) by auto with *.

  rewrite <-age_by_age_by.

  apply age_by_pred.

Qed.



Fixpoint composeOptN' {A} (f : A -> option A) n x :=

  match n with

  | 0 => Some x

  | S n =>

    match composeOptN' f n x with

    | Some y => f y

    | None => None

    end

  end.



Lemma composeOptN_assoc_aux_None {A} (f : A -> option A) n x :

  f x = None ->

  match composeOptN f n x with

  | Some x => f x

  | None => None

  end = None.

Proof.

  revert x; induction n; intros x E; simpl; auto.

  destruct (f x); congruence.

Qed.



Lemma composeOptN_assoc_aux_Some {A} (f : A -> option A) n x y :

  f x = Some y ->

  match composeOptN f n x with

  | Some x => f x

  | None => None

  end = composeOptN f n y.

Proof.

  revert x y; induction n; intros x y Ey; simpl. auto.

  rewrite Ey.

  destruct (f y) as [z|] eqn:Ez.

  - eauto.

  - apply composeOptN_assoc_aux_None, Ez.

Qed.



Lemma composeOptN_assoc {A} (f : A -> option A) n x :

  composeOptN f n x = composeOptN' f n x.

Proof.

  revert x; induction n; intros x; simpl. auto.

  destruct (f x) as [y|] eqn:Ey; rewrite <-IHn.

  - erewrite composeOptN_assoc_aux_Some; eauto.

  - rewrite composeOptN_assoc_aux_None; eauto.

Qed.



Lemma age_by_ageN {A} `{agA : ageable A} n (x : A) :

  n <= level x ->

  ageN n x = Some (age_by n x).

Proof.

  revert x; induction n; intros x l. reflexivity.

  unfold ageN.

  rewrite composeOptN_assoc; simpl; rewrite <-composeOptN_assoc.

  change (composeOptN age1 n x) with (ageN n x).

  rewrite IHn. 2:omega.

  unfold age1' in *.

  destruct (age1 (age_by n x)) as [y|] eqn:Ey. auto.

  exfalso. rewrite age1_level0 in Ey.

  rewrite level_age_by in Ey. omega.

Qed.



Lemma age_to_ageN {A} `{agA : ageable A} n (x : A) :

  ageN (level x - n) x = Some (age_to n x).

Proof.

  apply age_by_ageN. auto with *.

Qed.



Lemma age_by_1 {A} {_ : ageable A} x : 0 < level x -> age x (age_by 1 x).

Proof.

  intros l.

  unfold age_by, age1'; simpl.

  destruct (age1 x) eqn:E; eauto.

  apply age1_level0 in E.

  omega.

Qed.



Lemma age_to_1 {A} {_ : ageable A} n x : level x = S n -> age x (age_to n x).

Proof.

  unfold age_to; intros E; rewrite E.

  replace (S n - n) with 1 by auto with *.

  apply age_by_1. auto with *.

Qed.



Lemma age_to_identy {A} `{asaA: Age_alg A}: forall k phi,

    identity phi -> identity (age_to k phi).

Proof.

  intros k phi. unfold age_to. generalize (level phi - k); intros n; revert phi.

  induction n; intros phi id; simpl; auto. unfold age1'.

  destruct (age1 (age_by n phi)) eqn:E; auto.

  eapply age_identity. apply E. auto.

Qed.



Lemma age_to_join_eq {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} :

  forall k x1 x2 x3,

    join x1 x2 x3 ->

    k <= level x3 ->

    join (age_to k x1) (age_to k x2) (age_to k x3).

Proof.

  intros k x1 x2 x3 J.

  remember (level x3) as l3 eqn:e3; symmetry in e3.

  pose proof join_level _ _ _ J as [e1 e2]; rewrite e3 in e1, e2.

  revert l3 x1 x2 x3 e1 e2 e3 J.

  intros n; induction n as [ n IHn ] using strong_nat_ind. intros x1 x2 x3 e1 e2 e3 J L.

  destruct (le_lt_eq_dec _ _ L) as [Lt | ->]; swap 1 2.

  now do 3 (rewrite age_to_eq at 1; auto).

  assert (l1 : k < level x1) by auto with *.

  assert (l2 : k < level x2) by auto with *.

  assert (l3 : k < level x3) by auto with *.

  destruct (age_to_lt _ x1 l1) as [x1' [E1 ->]].

  destruct (age_to_lt _ x2 l2) as [x2' [E2 ->]].

  destruct (age_to_lt _ x3 l3) as [x3' [E3 ->]].

  pose proof @age1_join_eq A _ _ _ _ _ _ _ J _ E1 _ E2 _ E3.

  pose proof @af_level2 A level age1 (@age_facts _ agA) _ _ E1.

  pose proof @af_level2 A level age1 (@age_facts _ agA) _ _ E2.

  pose proof @af_level2 A level age1 (@age_facts _ agA) _ _ E3.

  apply IHn with (level x1'); omega || auto.

Qed.

