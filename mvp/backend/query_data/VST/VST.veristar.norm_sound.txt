Load loadpath.
Require Import ZArith Coq.Lists.List Permutation.
Require Import VST.msl.Axioms veric.Coqlib2.
Require Import VST.msl.predicates_sa.
Require Import veristar.variables veristar.datatypes veristar.list_denote
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.list_denote:
Load loadpath.
Require Import Coq.Lists.List Permutation veric.Coqlib2.
Require Import VST.msl.Axioms msl.sepalg VST.msl.predicates_sa msl.base
               veristar.variables veristar.datatypes
               veristar.clauses veristar.basic veristar.compare.

Section ListDenote.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Fixpoint list_denote l : T :=
  match l with nil => b | x :: l' => g (f x) (list_denote l')
  end.

Local Notation "'listd'" := (list_denote).

Lemma listd_fold_right l :
  listd l = fold_right (fun x y  => g (f x) y) b l.

End ListDenote.

Notation "'listd'" := (list_denote).

Lemma listd_app {A T} f g (b : T) (l l' : list A) :
  listd f g b (l ++ l') =
  listd f g (listd f g b l') l.

Section ListDenoteLems.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Lemma listd_nil : listd f g b nil = b.

Lemma listd_cons a l :
  listd f g b (a :: l) = g (f a) (listd f g b l).

Lemma listd_map h l (Hgh_eq : forall a b', g (f (h a)) b' = g (f a) b') :
  listd f g b (map h l) = listd f g b l.

Lemma listd_filter h l (H : forall a b', false=h a -> g (f a) b' = b') :
  listd f g b (filter h l) = listd f g b l.

Lemma listd_flat_map h l (H : forall a b', g (f a) b' = listd f g b' (h a)) :
  listd f g b l = listd f g b (flat_map h l).

Lemma listd_compose h1 h2 l
  (Hh1 : forall l, listd f g b l = listd f g b (h1 l))
  (Hh2 : forall l, listd f g b l = listd f g b (h2 l)) :
  listd f g b l = listd f g b ((h1 oo h2) l).

End ListDenoteLems.

Section ListDenoteAS.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma fgAS b' (t t' : T) : g t (g t' b') = g t' (g t b').

Lemma listdAS a l : listd f g (g (f a) b) l = g (f a) (listd f g b l).

Lemma listd_AS_unit un l (un_unit : forall x, g x un = x) :
  listd f g b l = g b (listd f g un l).

Lemma listd_perm l l' (Hperm : Permutation l l') :
  listd f g b l = listd f g b l'.

End ListDenoteAS.

Section ListDenoteConj.
Context {A : Type}.
Variables (f : A -> Prop) (g : Prop -> Prop -> Prop) (b : Prop).
Variable (gconj : forall x y, g x y -> y).

Lemma listd_conj a l : listd f g b (a :: l) -> listd f g b l.

Context {B : Type}.
Variables (h : A -> pred B) (k : pred B -> pred B -> pred B) (b0 : pred B).
Variable (hconj : forall x y b, k x y b -> y b).

Lemma listd_conjP a l : forall b, listd h k b0 (a :: l) b -> listd h k b0 l b.

End ListDenoteConj.

Section ListDenoteProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).

Lemma andS (x y : Prop) : and x y = and y x.

Lemma andA x y z : and x (and y z) = and (and x y) z.

Lemma orS (x y : Prop) : or x y = or y x.

Lemma orA x y z : or x (or y z) = or (or x y) z.

Lemma listd_conj_and a l : listd f and True (a :: l) -> listd f and True l.

Lemma listd_unfold_and l : listd f and b l = (listd f and True l /\ b).

Lemma listd_unfold_or l : listd f or b l = (listd f or False l \/ b).

Lemma listd_flat_map_and h l
  (H : forall a b', and (f a) b' -> listd f and b' (h a)) :
  listd f and b l -> listd f and b (flat_map h l).

Lemma listd_In_prop l : (forall a, In a l -> f a) -> listd f and True l.

Lemma listd_In_inv_prop a l : listd f and True l -> In a l -> f a.

End ListDenoteProp.

Section ListDenoteProp1.
Context {A : Type}.
Variables (f : A -> Prop).

Lemma listd_unfold_app_and b l l' :
  listd f and b (l ++ l') = (listd f and True l /\ listd f and b l').

Lemma listd_unfold_app_or b l l' :
  listd f or b (l ++ l') = (listd f or False l \/ listd f or b l').

End ListDenoteProp1.

Lemma union_com {A} : forall (P Q: pred A), ((P || Q) = (Q || P))%pred.

Lemma union_assoc {A} : forall (P Q R: pred A),
  ((P || Q) || R = P || (Q || R))%pred.

Notation "'inter'" := (@andp _).
Notation "'un'" := (@orp _).

Section ListDenotePred.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).

Lemma listd_conj_inter a l :
  forall b', listd f inter TT (a :: l) b' -> listd f inter TT l b'.

Lemma listd_unfold_inter l : listd f inter b l = (listd f inter TT l && b)%pred.

Lemma listd_unfold_un l : listd f un b l = (listd f un FF l || b)%pred.

Lemma listd_flat_map_inter h l s
  (H : forall a b', inter (f a) b' s -> listd f inter b' (h a) s) :
  listd f inter b l s -> listd f inter b (flat_map h l) s.

Lemma listd_In_pred l s :
  (forall a, In a l -> f a s) -> b s -> listd f inter b l s.

Lemma listd_In_inv_pred a l s : listd f inter TT l s -> In a l -> f a s.

Lemma listd_In_pred_un l s :
  (exists a, In a l /\ f a s) \/ b s -> listd f un b l s.

Lemma listd_In_inv_pred_un l s :
  listd f un b l s -> (exists a, In a l /\ f a s) \/ b s.

Lemma listd_map_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> g (h a) s) :
  listd f inter TT l s -> listd g inter TT (map h l) s.

Lemma listd_omapl_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> match h a with Some a' => g a' s | None => True end) :
  listd f inter TT l s -> listd g inter TT (omapl h l) s.

Lemma listd_foldr_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h a x) s) :
  f c0 s -> listd f inter TT l s -> f (fold_right h c0 l) s.

Lemma listd_foldl_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h x a) s) :
  f c0 s -> listd f inter TT l s -> f (fold_left h l c0) s.

Lemma listd_filter_pred h l s :
  listd f inter TT l s -> listd f inter TT (filter h l) s.

Lemma listd_partition_pred h l xs ys s (H : partition h l = (xs, ys)) :
  listd f inter TT l s ->
    listd f inter TT xs s /\ listd f inter TT ys s.

End ListDenotePred.

Section ListDenotePred1.
Context {A B : Type}.
Variables (f : A -> pred B).

Lemma listd_unfold_app_inter b l l' :
  listd f inter b (l ++ l') = (listd f inter TT l && listd f inter b l')%pred.

Lemma listd_unfold_app_un b l l' :
  listd f un b (l ++ l') = (listd f un FF l || listd f un b l')%pred.

End ListDenotePred1.

Section ListDenoteInsert.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma listd_insert cmp a l :
  listd f g b (insert cmp a l) = g (f a) (listd f g b l).

Lemma listd_sort cmp l : listd f g b (rsort cmp l) = listd f g b l.

End ListDenoteInsert.

Section ListDenoteInsertUniq.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y ->
  forall b, g (f x) (g (f y) b) = g (f y) b).

Lemma listd_insert_uniq a l :
  listd f g b (insert_uniq cmp a l) = g (f a) (list_denote f g b l).

Lemma listd_sort_uniq l : listd f g b (rsort_uniq cmp l) = listd f g b l.

End ListDenoteInsertUniq.

Section ListDenoteSortProp.
Context {A : Type}.
Variable (f : A -> Prop) (b : Prop).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_and cmp a l :
  listd f and b (insert cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_and cmp l :
  listd f and b (rsort cmp l) = listd f and b l.

Lemma listd_insert_or cmp a l :
  listd f or b (insert cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_or cmp l :
  listd f or b (rsort cmp l) = listd f or b l.

End ListDenoteSortProp.

Section ListDenoteInsertPred.

Context {A B : Type}.
Variable (f : A -> pred B) (b : pred B).

Lemma interS (x y : pred B) : inter x y = inter y x.

Lemma interA (x y z : pred B) : inter x (inter y z) = inter (inter x y) z.

Lemma unS (x y : pred B) : un x y = un y x.

Lemma unA (x y z : pred B) : un x (un y z) = un (un x y) z.

Variables (JB: Join B) (PB: Perm_alg B)(SB: Sep_alg B).

Lemma sepconS (x y : pred B) : sepcon x y = sepcon y x.

Lemma sepconA (x y z : pred B) :
  sepcon x (sepcon y z) = sepcon (sepcon x y) z.

Local Hint Resolve interS interA unS unA sepconS sepconA.

Lemma listd_insert_inter cmp a l :
  listd f inter b (insert cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_inter cmp l :
  listd f inter b (rsort cmp l) = listd f inter b l.

Lemma listd_insert_un cmp a l :
  listd f un b (insert cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_un cmp l : listd f un b (rsort cmp l) = listd f un b l.

Lemma listd_insert_sepcon cmp a l :
  listd f sepcon b (insert cmp a l) = sepcon (f a) (listd f sepcon b l).

Lemma listd_sort_sepcon cmp l :
  listd f sepcon b (rsort cmp l) = listd f sepcon b l.

End ListDenoteInsertPred.

Section ListDenoteSortUniqProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_uniq_and a l :
  listd f and b (insert_uniq cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_uniq_and l :
  listd f and b (rsort_uniq cmp l) = listd f and b l.

Lemma listd_insert_uniq_or a l :
  listd f or b (insert_uniq cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_uniq_or l :
  listd f or b (rsort_uniq cmp l) = listd f or b l.

End ListDenoteSortUniqProp.

Section ListDenoteSortUniqPreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve (@interS B) (@interA B) (@unS B) (@unA B).

Lemma listd_insert_uniq_inter a l :
  listd f inter b (insert_uniq cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_uniq_inter l :
  listd f inter b (rsort_uniq cmp l) = listd f inter b l.

Lemma listd_insert_uniq_un a l :
  listd f un b (insert_uniq cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_uniq_un l :
  listd f un b (rsort_uniq cmp l) = listd f un b l.

End ListDenoteSortUniqPreds.

Section ListDenoteMergePreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Lemma listd_merge_inter l1 l2 s :
  listd f inter TT l1 s -> listd f inter TT l2 s ->
  listd f inter TT (merge cmp l1 l2) s.

Lemma merge_nil l : merge cmp l nil = l.

Lemma merge_nil' l : merge cmp nil l = l.

Lemma merge_cons_unfold a1 a2 l1 l2 :
  merge cmp (a1 :: l1) (a2 :: l2) = match cmp a1 a2 with
                                      | Eq => a1 :: merge cmp l1 l2
                                      | Gt => a1 :: merge cmp l1 (a2 :: l2)
                                      | Lt => a2 :: merge cmp (a1 :: l1) l2
                                    end.

Lemma merge_elems a l1 l2 : In a l1 \/ In a l2 <-> In a (merge cmp l1 l2).

Lemma listd_merge_inter' l1 l2 s :
  listd f inter TT (merge cmp l1 l2) s ->
  listd f inter TT l1 s /\ listd f inter TT l2 s.

Lemma listd_merge_un1 l1 l2 s :
  listd f un FF l1 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un2 l1 l2 s :
  listd f un FF l2 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un' l1 l2 s :
  listd f un FF (merge cmp l1 l2) s ->
  listd f un FF l1 s \/ listd f un FF l2 s.

End ListDenoteMergePreds.

Section ListDenoteSeparate.
Context {X Y B : Type}.
Variables (f : X -> pred B) (g : Y -> pred B) (b : pred B) (l1 : list X)
          (l2 : list Y).

Lemma listd_separate :
  listd f inter (listd g inter b l2) l1 =
  andp (listd f inter TT l1) (andp (listd g inter TT l2) b).

Lemma listd_prop:
listd f inter b l1 =
(andp (listd f inter TT l1) b).

End ListDenoteSeparate.

Section SetDenote.

Definition setd {T} (f : M.elt -> T) (g : T -> T -> T) (b : T) (s : M.t) :=
  listd f g b (M.elements s).

End SetDenote.

Section SetLems.
Variables (s : M.t) (x y : clause).

Lemma setd_add_In_refl : M.In x (M.add x s).

Lemma setd_add_In_refl_elems : In x (M.elements (M.add x s)).

Lemma setd_add_In : x = y \/ M.In y s -> M.In y (M.add x s).

Lemma setd_add_In_inv : M.In y (M.add x s) -> x = y \/ M.In y s.

Lemma elements_In {s0} : In y (M.elements s0) = M.In y s0.

Lemma empty_set_elems : M.elements M.empty = nil. 

Lemma setd_add_In_inv_elems :
  In y (M.elements (M.add x s)) -> x = y \/ M.In y s.

Lemma setd_rem_In_inv : M.In y (M.remove x s) -> M.In y s.

Lemma setd_rem_In_inv_elems :
  In y (M.elements (M.remove x s)) -> In y (M.elements s).

End SetLems.

Section SetDenoteLems.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : M.t -> clause -> M.t).
Variable (H : forall c cls s, setd f inter b cls s -> f c s ->
                              setd f inter b (h cls c) s).

Lemma setd_fold_left cls0 l s :
  listd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (fold_left h l cls0) s.

Lemma setd_fold cls0 l s :
  setd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (M.fold (Basics.flip h) cls0 l) s.

Lemma setd_un cls1 cls2 s :
  setd f inter TT cls1 s -> setd f inter TT cls2 s ->
  setd f inter TT (M.union cls1 cls2) s.

Lemma setd_base_separate:
   forall {A} f (b: pred A) cls,
    setd f inter b cls = andp b (setd f inter (@TT A) cls).

Lemma setd_add c cls s :
  setd f inter b cls s -> f c s -> setd f inter b (M.add c cls) s.

Lemma setd_remove c cls s :
  setd f inter TT cls s -> setd f inter TT (M.remove c cls) s.

Lemma setd_empty_set s : setd f inter TT M.empty s.

Require Import MSetFacts Logic.

Lemma setd_filter bf cls s :
  setd f inter TT cls s -> setd f inter TT (M.filter bf cls) s.

End SetDenoteLems.

Section FoldLem.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).

Lemma listd_fold_left cls0 l s
  (H : forall c cls, listd f inter b cls s -> f c s ->
                     listd f inter b (h cls c) s) :
  listd f inter b l s -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLem.

Section FoldLemWeak.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).
Variable (H : forall c cls s, listd f inter b cls s -> (forall s, f c s) ->
                              listd f inter b (h cls c) s).

Lemma listd_fold_left_wk cls0 l s :
  listd (fun c => forall s, f c s) and True l -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLemWeak.

Lemma listd_inter_map: forall {A B C} (l:list A) (f:B -> C -> Prop) h s,
(forall x, In x l -> f (h x) s) ->
inter
  (listd f inter TT (map h l)) TT s.

Lemma listd_inter_rev: forall {A B} (f: A -> B -> Prop) l,
  listd f inter TT (rev  l) = listd f inter TT l.

Lemma orp_FF {A} (p : pred A) : orp p FF = p.

Lemma listd_un_rev:
  forall {A B} (f: A -> B -> Prop) l, listd f un FF (rev  l) = listd f un FF l.

Lemma setd_filter_pred:
  forall {B: Type} (f: M.elt -> pred B) (h: M.elt -> bool) (s: M.t), *)
               veristar.heapresolve veristar.model_type veristar.model
               veristar.superpose veristar.clauses.

Import HeapResolve.

Module Type NORM_SOUND.
Declare Module VSM: VERISTAR_MODEL.
Import VSM VeriStarLogic Superposition.

Axiom norm_sound : forall sigma sc s,
  clause_denote sc s -> setd clause_denote (@andp _) TT sigma s ->
  clause_denote (HeapResolve.norm sigma sc) s.

End NORM_SOUND.

Module Norm_Sound (VSM: VERISTAR_MODEL) : NORM_SOUND with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic Superposition.

Import sepalg.

Lemma subst_expr_sound v e e' s :
  (Var v === e) s -> (expr_denote e' s = expr_denote (subst_expr v e e') s).
Proof with simpl in *; auto.
unfold var_eq. intro A. destruct e'... if_tac... rewrite <- H...
Qed.

Lemma join_var_eq : forall (s0 s1 s : state) x y,
  join s0 s1 s -> (x === y) s0 -> (x === y) s.
Proof.
intros.
destruct s; destruct s0; destruct s1. destruct H. simpl in *. destruct H.
unfold var_eq in *; subst; auto.
Qed.

Lemma join_var_eq' : forall (s0 s1 s : state) x y,
  join s0 s1 s -> (x === y) s -> (x === y) s0.
Proof.
intros.
destruct s; destruct s0; destruct s1. destruct H. simpl in *. destruct H.
unfold var_eq in *; subst; auto.
Qed.

Lemma subst_space_atom_sound:
   forall (v : datatypes.var) (e : expr) (s : state) (Heq : (Var v === e) s) sa,
  space_atom_denote sa s = space_atom_denote (subst_space v e sa) s.
Proof with simpl in *; auto.
destruct sa... rewrite <- subst_expr_sound...
destruct (val2loc (expr_denote e0 s))... rewrite <- subst_expr_sound...
rewrite <- subst_expr_sound... rewrite <- subst_expr_sound...
Qed.

Lemma subst_space_atoms_sound v e sigma s :
  (Var v === e) s ->
  space_denote sigma s = space_denote (map (subst_space v e) sigma) s.
Proof with simpl; auto.
intro A; revert s A; induction sigma... simpl; intros s A.
apply prop_ext. split; intro B. destruct B as [x [y [B [C D]]]].
exists x; exists y. rewrite (subst_space_atom_sound v e) in C.
split; auto. split; auto. rewrite <- IHsigma; auto.
eapply join_var_eq'; eauto. eapply join_var_eq'; eauto.
destruct B as [x [y [B [C D]]]]. exists x; exists y. split; auto.
rewrite <- subst_space_atom_sound in C; auto. split; auto.
rewrite IHsigma; auto. eapply join_var_eq'; eauto. eapply join_var_eq'; eauto.
Qed.

Lemma normalize1_3_sound pc sc s :
  clause_denote pc s -> clause_denote sc s ->
  clause_denote (normalize1_3 pc sc) s.
Proof with destruct delta; try destruct p; try destruct e; simpl; auto.
intros A B; unfold normalize1_3; destruct pc...
simpl in A. destruct sc; auto; intro C; rewrite (@listd_sort_uniq_un _ state);
try solve [apply pure_atom_cmp_eq]. rewrite listd_app, listd_unfold_un.
rewrite (@listd_sort_uniq_inter _ state) in C. 2: apply pure_atom_cmp_eq.
rewrite listd_app, listd_unfold_inter in C; destruct C as [C D].
specialize (A C). specialize (B D). rewrite (@listd_unfold_un _ state) in B.
destruct A as [A | A]; [ destruct B as [B | B]; right | left; auto].
rewrite listd_unfold_un; left... rewrite listd_unfold_un. right.
unfold space_denote in B; unfold subst_spaces.
solve[rewrite <- subst_space_atoms_sound; auto].
rewrite listd_app, listd_unfold_un.
rewrite (@listd_sort_uniq_inter _ state) in C. 2: apply pure_atom_cmp_eq.
rewrite listd_app, listd_unfold_inter in C; destruct C as [C D].
specialize (A C). destruct A as [A | A]; [ | left; auto].
rewrite listd_unfold_inter in D. destruct D as [D E].
unfold subst_spaces in E. rewrite <- subst_space_atoms_sound in E; auto.
simpl in B. rewrite (@listd_unfold_inter _ state) in B. right; apply B.
split; auto.
Qed.

Require Import Bool.

Lemma empty_state (s : state) : exists s0, emp s0 /\ join s0 s s.
Proof with auto.
generalize (join_ex_identities s); intros [s0 [A [s' B]]].
exists s0; split... assert (s = s'). apply (A _ _ B). subst s...
Qed.

Lemma lseg_nilnil sigma s :
  space_denote sigma s =
  (space_atom_denote (Lseg Nil Nil) * space_denote sigma)%pred s.
Proof with simpl; auto; try congruence.
apply prop_ext; split; intro A. destruct (empty_state s) as [s0 [B C]].
exists s0; exists s. split... split... simpl. rewrite empstate_empheap in B.
constructor... constructor...
destruct A as [x [y [A [B C]]]]. simpl in B. inversion B; subst...
cut (y = s); [ intro X; rewrite <- X; auto | ].
inversion A; subst. destruct y as [y1 y2], s as [s1 s2]; f_equal...
apply A.
Qed.

Lemma lseg_vv sigma v s :
  space_denote sigma s =
  (space_atom_denote (Lseg (Var v) (Var v)) * space_denote sigma)%pred s.
Proof with simpl; auto; try congruence.
apply prop_ext; split; intro A. destruct (empty_state s) as [s0 [B C]].
exists s0; exists s. split... split... simpl.
constructor... apply empstate_empheap...
apply var_nil_or_loc.
destruct A as [x [y [A [B C]]]]. simpl in B. inversion B; subst...
cut (y = s); [ intro X; rewrite <- X; auto | ].
inversion A; subst. destruct y as [y1 y2], s as [s1 s2]; f_equal...
apply A.
Qed.

Lemma drop_reflex_lseg_sound sigma s :
  space_denote sigma s = space_denote (drop_reflex_lseg sigma) s.
Proof with simpl; auto; try congruence.
apply prop_ext; split; intro A.
revert s A; induction sigma... intros s [x [y [A [B C]]]].
generalize A; intros [[A0 A1] A2].
destruct a; [exists x; exists y; split; auto | ].
destruct e; destruct e0. inversion B; simpl; auto; try congruence; subst. apply IHsigma.
cut (y = s); [ intro X; rewrite <- X; auto | ].
destruct y as [y1 y2], s as [s1 s2]; f_equal...
exists x; exists y; split...
exists x; exists y; split...
rewrite if_negb; remember (eq_var v v0) as b; destruct b.
2: exists x; exists y; split...
unfold eq_var in Heqb. apply eq_pos_var_eqZ in Heqb. inversion Heqb; subst.
inversion B; subst.
cut (y = s); [ intro X; rewrite <- X; auto | ].
destruct y as [y1 y2], s as [s1 s2]; f_equal... apply IHsigma...

revert s A; induction sigma... intros s A. destruct a in A |- *.
destruct A as [x [y [A [B C]]]]. exists x; exists y; split...
remember e as b1; remember  e0 as b2. destruct b1, b2 in A |- *.
rewrite <- lseg_nilnil...
destruct A as [x [y [A [B C]]]]; exists x; exists y; split...
destruct A as [x [y [A [B C]]]]; exists x; exists y; split...
rewrite if_negb in A; remember (eq_var v v0) as b; destruct b.
apply eq_pos_var_eqZ in Heqb; inversion Heqb; subst. rewrite <- lseg_vv...
destruct A as [x [y [A [B C]]]]; exists x; exists y; split...
Qed.

Lemma normalize2_4_sound sc s :
  clause_denote sc s -> clause_denote (normalize2_4 sc) s.
Proof with try solve [simpl; auto; congruence].
intro A; destruct sc... intro B. specialize (A B). clear B.
rewrite (@listd_unfold_un _ state) in A |- *. destruct A; [ left; auto | ].
right; rewrite <- drop_reflex_lseg_sound...
intro B. rewrite (@listd_unfold_inter _ state) in B. destruct B as [B C].
rewrite <- drop_reflex_lseg_sound in C. apply A.
rewrite (@listd_unfold_inter _ state); split...
Qed.

Lemma norm_sound sigma sc s :
  clause_denote sc s -> setd clause_denote (@andp _) TT sigma s ->
  clause_denote (norm sigma sc) s.
Proof with simpl; auto; try congruence.
unfold norm. intros A B. apply normalize2_4_sound. apply listd_foldr_pred...
intros x a C. apply normalize1_3_sound...
rewrite (@listd_sort_inter _ state) with (cmp := (rev_cmp compare_clause2)); auto.
Qed.

End Norm_Sound.

