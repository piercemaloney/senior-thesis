Require Import Coq.omega.Omega.
Require Import Coq.Setoids.Setoid.
Require Import Coq.Classes.Morphisms.
Require Import Coq.Lists.List.
Require Import Coq.Sorting.Permutation.

Require Import compcert.lib.Coqlib.
(* compcert.lib.Coqlib:
Require Export String.
Require Export ZArith.
Require Export Znumtheory.
Require Export List.
Require Export Bool.

Global Set Asymmetric Patterns.

Ltac inv H := inversion H; clear H; subst.

Ltac predSpec pred predspec x y :=
  generalize (predspec x y); case (pred x y); intro.

Ltac caseEq name :=
  generalize (eq_refl name); pattern name at -1 in |- *; case name.

Ltac destructEq name :=
  destruct name eqn:?.

Ltac decEq :=
  match goal with
  | [ |- _ = _ ] => f_equal
  | [ |- (?X ?A <> ?X ?B) ] =>
      cut (A <> B); [intro; congruence | try discriminate]
  end.

Ltac byContradiction :=
  cut False; [contradiction|idtac].

Ltac omegaContradiction :=
  cut False; [contradiction|omega].

Lemma modusponens: forall (P Q: Prop), P -> (P -> Q) -> Q.

Ltac exploit x :=
    refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _) _)
 || refine (modusponens _ _ (x _ _) _)
 || refine (modusponens _ _ (x _) _).

Definition peq: forall (x y: positive), {x = y} + {x <> y} := Pos.eq_dec.
Global Opaque peq.

Lemma peq_true:
  forall (A: Type) (x: positive) (a b: A), (if peq x x then a else b) = a.

Lemma peq_false:
  forall (A: Type) (x y: positive) (a b: A), x <> y -> (if peq x y then a else b) = b.

Definition Plt: positive -> positive -> Prop := Pos.lt.

Lemma Plt_ne:
  forall (x y: positive), Plt x y -> x <> y.
Hint Resolve Plt_ne: coqlib.

Lemma Plt_trans:
  forall (x y z: positive), Plt x y -> Plt y z -> Plt x z.
Proof (Pos.lt_trans).

Lemma Plt_succ:
  forall (x: positive), Plt x (Pos.succ x).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_trans_succ:
  forall (x y: positive), Plt x y -> Plt x (Pos.succ y).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_succ_inv:
  forall (x y: positive), Plt x (Pos.succ y) -> Plt x y \/ x = y.

Definition plt (x y: positive) : {Plt x y} + {~ Plt x y}.
Global Opaque plt.

Definition Ple: positive -> positive -> Prop := Pos.le.

Lemma Ple_refl: forall (p: positive), Ple p p.
Proof (Pos.le_refl).

Lemma Ple_trans: forall (p q r: positive), Ple p q -> Ple q r -> Ple p r.
Proof (Pos.le_trans).

Lemma Plt_Ple: forall (p q: positive), Plt p q -> Ple p q.
Proof (Pos.lt_le_incl).

Lemma Ple_succ: forall (p: positive), Ple p (Pos.succ p).

Lemma Plt_Ple_trans:
  forall (p q r: positive), Plt p q -> Ple q r -> Plt p r.
Proof (Pos.lt_le_trans).

Lemma Plt_strict: forall p, ~ Plt p p.
Proof (Pos.lt_irrefl).

Hint Resolve Ple_refl Plt_Ple Ple_succ Plt_strict: coqlib.

Ltac xomega := unfold Plt, Ple in *; zify; omega.
Ltac xomegaContradiction := exfalso; xomega.

Section POSITIVE_ITERATION.

Lemma Plt_wf: well_founded Plt.

Variable A: Type.
Variable v1: A.
Variable f: positive -> A -> A.

Lemma Ppred_Plt:
  forall x, x <> xH -> Plt (Pos.pred x) x.

Let iter (x: positive) (P: forall y, Plt y x -> A) : A :=
  match peq x xH with
  | left EQ => v1
  | right NOTEQ => f (Pos.pred x) (P (Pos.pred x) (Ppred_Plt x NOTEQ))
  end.

Definition positive_rec : positive -> A :=
  Fix Plt_wf (fun _ => A) iter.

Lemma unroll_positive_rec:
  forall x,
  positive_rec x = iter x (fun y _ => positive_rec y).

Lemma positive_rec_base:
  positive_rec 1%positive = v1.

Lemma positive_rec_succ:
  forall x, positive_rec (Pos.succ x) = f x (positive_rec x).

Lemma positive_Peano_ind:
  forall (P: positive -> Prop),
  P xH ->
  (forall x, P x -> P (Pos.succ x)) ->

End POSITIVE_ITERATION.

Definition zeq: forall (x y: Z), {x = y} + {x <> y} := Z.eq_dec.

Lemma zeq_true:
  forall (A: Type) (x: Z) (a b: A), (if zeq x x then a else b) = a.

Lemma zeq_false:
  forall (A: Type) (x y: Z) (a b: A), x <> y -> (if zeq x y then a else b) = b.

Open Scope Z_scope.

Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_dec.

Lemma zlt_true:
  forall (A: Type) (x y: Z) (a b: A),
  x < y -> (if zlt x y then a else b) = a.

Lemma zlt_false:
  forall (A: Type) (x y: Z) (a b: A),
  x >= y -> (if zlt x y then a else b) = b.

Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.

Lemma zle_true:
  forall (A: Type) (x y: Z) (a b: A),
  x <= y -> (if zle x y then a else b) = a.

Lemma zle_false:
  forall (A: Type) (x y: Z) (a b: A),
  x > y -> (if zle x y then a else b) = b.

Lemma two_power_nat_O : two_power_nat O = 1.

Lemma two_power_nat_pos : forall n : nat, two_power_nat n > 0.

Lemma two_power_nat_two_p:
  forall x, two_power_nat x = two_p (Z.of_nat x).

Lemma two_p_monotone:
  forall x y, 0 <= x <= y -> two_p x <= two_p y.

Lemma two_p_monotone_strict:
  forall x y, 0 <= x < y -> two_p x < two_p y.

Lemma two_p_strict:
  forall x, x >= 0 -> x < two_p x.

Lemma two_p_strict_2:
  forall x, x >= 0 -> 2 * x - 1 < two_p x.

Lemma Zmin_spec:
  forall x y, Z.min x y = if zlt x y then x else y.

Lemma Zmax_spec:
  forall x y, Z.max x y = if zlt y x then x else y.

Lemma Zmax_bound_l:
  forall x y z, x <= y -> x <= Z.max y z.
Lemma Zmax_bound_r:
  forall x y z, x <= z -> x <= Z.max y z.

Lemma Zdiv_small:
  forall x y, 0 <= x < y -> x / y = 0.

Lemma Zmod_small:
  forall x y, 0 <= x < y -> x mod y = x.

Lemma Zmod_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x mod y = b.

Lemma Zdiv_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x / y = a.

Lemma Zdiv_Zdiv:
  forall a b c,
  b > 0 -> c > 0 -> (a / b) / c = a / (b * c).

Lemma Zmult_le_compat_l_neg :
  forall n m p:Z, n >= m -> p <= 0 -> p * n <= p * m.

Lemma Zdiv_interval_1:
  forall lo hi a b,
  lo <= 0 -> hi > 0 -> b > 0 ->
  lo * b <= a < hi * b ->
  lo <= a/b < hi.

Lemma Zdiv_interval_2:
  forall lo hi a b,
  lo <= a <= hi -> lo <= 0 -> hi >= 0 -> b > 0 ->
  lo <= a/b <= hi.

Lemma Zmod_recombine:
  forall x a b,
  a > 0 -> b > 0 ->
  x mod (a * b) = ((x/b) mod a) * b + (x mod b).

Lemma Zdivides_trans:
  forall x y z, (x | y) -> (y | z) -> (x | z).

Definition Zdivide_dec:
  forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
Global Opaque Zdivide_dec.

Lemma Zdivide_interval:
  forall a b c,
  0 < c -> 0 <= a < b -> (c | a) -> (c | b) -> 0 <= a <= b - c.

Definition nat_of_Z: Z -> nat := Z.to_nat.

Lemma nat_of_Z_of_nat:
  forall n, nat_of_Z (Z.of_nat n) = n.

Lemma nat_of_Z_max:
  forall z, Z.of_nat (nat_of_Z z) = Z.max z 0.

Lemma nat_of_Z_eq:
  forall z, z >= 0 -> Z.of_nat (nat_of_Z z) = z.

Lemma nat_of_Z_neg:
  forall n, n <= 0 -> nat_of_Z n = O.

Lemma nat_of_Z_plus:
  forall p q,
  p >= 0 -> q >= 0 ->
  nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.

Definition align (n: Z) (amount: Z) :=
  ((n + amount - 1) / amount) * amount.

Lemma align_le: forall x y, y > 0 -> x <= align x y.

Lemma align_divides: forall x y, y > 0 -> (y | align x y).

Set Implicit Arguments.

Definition option_eq (A: Type) (eqA: forall (x y: A), {x=y} + {x<>y}):
  forall (x y: option A), {x=y} + {x<>y}.
Global Opaque option_eq.

Inductive option_rel (A B: Type) (R: A -> B -> Prop) : option A -> option B -> Prop :=
  | option_rel_none: option_rel R None None
  | option_rel_some: forall x y, R x y -> option_rel R (Some x) (Some y).

Definition option_map (A B: Type) (f: A -> B) (x: option A) : option B :=
  match x with
  | None => None
  | Some y => Some (f y)
  end.

Definition sum_left_map (A B C: Type) (f: A -> B) (x: A + C) : B + C :=
  match x with
  | inl y => inl C (f y)
  | inr z => inr B z
  end.

Hint Resolve in_eq in_cons: coqlib.

Lemma nth_error_in:
  forall (A: Type) (n: nat) (l: list A) (x: A),
  List.nth_error l n = Some x -> In x l.
Hint Resolve nth_error_in: coqlib.

Lemma nth_error_nil:
  forall (A: Type) (idx: nat), nth_error (@nil A) idx = None.
Hint Resolve nth_error_nil: coqlib.

Fixpoint list_length_z_aux (A: Type) (l: list A) (acc: Z) {struct l}: Z :=
  match l with
  | nil => acc
  | hd :: tl => list_length_z_aux tl (Z.succ acc)
  end.

Remark list_length_z_aux_shift:
  forall (A: Type) (l: list A) n m,
  list_length_z_aux l n = list_length_z_aux l m + (n - m).

Definition list_length_z (A: Type) (l: list A) : Z :=
  list_length_z_aux l 0.

Lemma list_length_z_cons:
  forall (A: Type) (hd: A) (tl: list A),
  list_length_z (hd :: tl) = list_length_z tl + 1.

Lemma list_length_z_pos:
  forall (A: Type) (l: list A),
  list_length_z l >= 0.

Lemma list_length_z_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_length_z (map f l) = list_length_z l.

Fixpoint list_nth_z (A: Type) (l: list A) (n: Z) {struct l}: option A :=
  match l with
  | nil => None
  | hd :: tl => if zeq n 0 then Some hd else list_nth_z tl (Z.pred n)
  end.

Lemma list_nth_z_in:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> In x l.

Lemma list_nth_z_map:
  forall (A B: Type) (f: A -> B) (l: list A) n,
  list_nth_z (List.map f l) n = option_map f (list_nth_z l n).

Lemma list_nth_z_range:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> 0 <= n < list_length_z l.

Lemma incl_cons_inv:
  forall (A: Type) (a: A) (b c: list A),
  incl (a :: b) c -> incl b c.
Hint Resolve incl_cons_inv: coqlib.

Lemma incl_app_inv_l:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l1 m.

Lemma incl_app_inv_r:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l2 m.

Hint Resolve  incl_tl incl_refl incl_app_inv_l incl_app_inv_r: coqlib.

Lemma incl_same_head:
  forall (A: Type) (x: A) (l1 l2: list A),
  incl l1 l2 -> incl (x::l1) (x::l2).

Lemma list_map_exten:
  forall (A B: Type) (f f': A -> B) (l: list A),
  (forall x, In x l -> f x = f' x) ->
  List.map f' l = List.map f l.

Lemma list_map_compose:
  forall (A B C: Type) (f: A -> B) (g: B -> C) (l: list A),
  List.map g (List.map f l) = List.map (fun x => g(f x)) l.

Lemma list_map_identity:
  forall (A: Type) (l: list A),
  List.map (fun (x:A) => x) l = l.

Lemma list_map_nth:
  forall (A B: Type) (f: A -> B) (l: list A) (n: nat),
  nth_error (List.map f l) n = option_map f (nth_error l n).

Lemma list_length_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  List.length (List.map f l) = List.length l.

Lemma list_in_map_inv:
  forall (A B: Type) (f: A -> B) (l: list A) (y: B),
  In y (List.map f l) -> exists x:A, y = f x /\ In x l.

Lemma list_append_map:
  forall (A B: Type) (f: A -> B) (l1 l2: list A),
  List.map f (l1 ++ l2) = List.map f l1 ++ List.map f l2.

Lemma list_append_map_inv:
  forall (A B: Type) (f: A -> B) (m1 m2: list B) (l: list A),
  List.map f l = m1 ++ m2 ->

Section LIST_FOLD.

Variables A B: Type.
Variable f: A -> B -> B.

Fixpoint list_fold_left (accu: B) (l: list A) : B :=
  match l with nil => accu | x :: l' => list_fold_left (f x accu) l' end.

Definition list_fold_right (l: list A) (base: B) : B :=
  list_fold_left base (List.rev' l).

Remark list_fold_left_app:
  forall l1 l2 accu,
  list_fold_left accu (l1 ++ l2) = list_fold_left (list_fold_left accu l1) l2.

Lemma list_fold_right_eq:
  forall l base,
  list_fold_right l base =
  match l with nil => base | x :: l' => f x (list_fold_right l' base) end.

Lemma list_fold_right_spec:
  forall l base, list_fold_right l base = List.fold_right f base l.

End LIST_FOLD.

Lemma in_cns:
  forall (A: Type) (x y: A) (l: list A), In x (y :: l) <-> y = x \/ In x l.

Lemma in_app:
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Lemma list_in_insert:
  forall (A: Type) (x: A) (l1 l2: list A) (y: A),
  In x (l1 ++ l2) -> In x (l1 ++ y :: l2).

Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Lemma list_disjoint_cons_l:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l2 -> list_disjoint (a :: l1) l2.

Lemma list_disjoint_cons_r:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l1 -> list_disjoint l1 (a :: l2).

Lemma list_disjoint_cons_left:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.

Lemma list_disjoint_cons_right:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.

Lemma list_disjoint_notin:
  forall (A: Type) (l1 l2: list A) (a: A),
  list_disjoint l1 l2 -> In a l1 -> ~(In a l2).

Lemma list_disjoint_sym:
  forall (A: Type) (l1 l2: list A),
  list_disjoint l1 l2 -> list_disjoint l2 l1.

Lemma list_disjoint_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l1 l2: list A),
  {list_disjoint l1 l2} + {~list_disjoint l1 l2}.

Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
  forall x, In x l1 <-> In x l2.

Inductive list_norepet (A: Type) : list A -> Prop :=
  | list_norepet_nil:
      list_norepet nil
  | list_norepet_cons:
      forall hd tl,
      ~(In hd tl) -> list_norepet tl -> list_norepet (hd :: tl).

Lemma list_norepet_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l: list A),
  {list_norepet l} + {~list_norepet l}.

Lemma list_map_norepet:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_norepet l ->
  (forall x y, In x l -> In y l -> x <> y -> f x <> f y) ->
  list_norepet (List.map f l).

Remark list_norepet_append_commut:
  forall (A: Type) (a b: list A),
  list_norepet (a ++ b) -> list_norepet (b ++ a).

Lemma list_norepet_app:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) <->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Lemma list_norepet_append:
  forall (A: Type) (l1 l2: list A),
  list_norepet l1 -> list_norepet l2 -> list_disjoint l1 l2 ->
  list_norepet (l1 ++ l2).

Lemma list_norepet_append_right:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l2.

Lemma list_norepet_append_left:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l1.

Inductive is_tail (A: Type): list A -> list A -> Prop :=
  | is_tail_refl:
      forall c, is_tail c c
  | is_tail_cons:
      forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).

Lemma is_tail_in:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.

Lemma is_tail_cons_left:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.

Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.

Lemma is_tail_incl:
  forall (A: Type) (l1 l2: list A), is_tail l1 l2 -> incl l1 l2.

Lemma is_tail_trans:
  forall (A: Type) (l1 l2: list A),
  is_tail l1 l2 -> forall (l3: list A), is_tail l2 l3 -> is_tail l1 l3.

Section FORALL2.

Variable A: Type.
Variable B: Type.
Variable P: A -> B -> Prop.

Inductive list_forall2: list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 al bl ->
      list_forall2 (a1 :: al) (b1 :: bl).

Lemma list_forall2_app:
  forall a2 b2 a1 b1,
  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
  list_forall2 (a1 ++ a2) (b1 ++ b2).

Lemma list_forall2_length:
  forall l1 l2,
  list_forall2 l1 l2 -> length l1 = length l2.

Lemma list_forall2_in_left:
  forall x1 l1 l2,
  list_forall2 l1 l2 -> In x1 l1 -> exists x2, In x2 l2 /\ P x1 x2.

Lemma list_forall2_in_right:
  forall x2 l1 l2,
  list_forall2 l1 l2 -> In x2 l2 -> exists x1, In x1 l1 /\ P x1 x2.

End FORALL2.

Lemma list_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
  list_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, In v1 l1 -> In v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  list_forall2 P2 l1 l2.

Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
  match n with
  | O => x
  | S n' => match x with nil => nil | hd :: tl => list_drop n' tl end
  end.

Lemma list_drop_incl:
  forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.

Lemma list_drop_norepet:
  forall (A: Type) n (l: list A), list_norepet l -> list_norepet (list_drop n l).

Lemma list_map_drop:
  forall (A B: Type) (f: A -> B) n (l: list A),
  list_drop n (map f l) = map f (list_drop n l).

Fixpoint list_repeat {A: Type} (n: nat) (x: A) {struct n} :=
  match n with
  | O => nil
  | S m => x :: list_repeat m x
  end.

Lemma length_list_repeat:
  forall (A: Type) n (x: A), length (list_repeat n x) = n.

Lemma in_list_repeat:
  forall (A: Type) n (x: A) y, In y (list_repeat n x) -> y = x.

Definition proj_sumbool {P Q: Prop} (a: {P} + {Q}) : bool :=
  if a then true else false.

Coercion proj_sumbool: sumbool >-> bool.

Lemma proj_sumbool_true:
  forall (P Q: Prop) (a: {P}+{Q}), proj_sumbool a = true -> P.

Lemma proj_sumbool_is_true:
  forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.

Ltac InvBooleans :=
  match goal with
  | [ H: _ && _ = true |- _ ] =>
      destruct (andb_prop _ _ H); clear H; InvBooleans
  | [ H: _ || _ = false |- _ ] =>
      destruct (orb_false_elim _ _ H); clear H; InvBooleans
  | [ H: proj_sumbool ?x = true |- _ ] =>
      generalize (proj_sumbool_true _ H); clear H; intro; InvBooleans
  | _ => idtac
  end.

Section DECIDABLE_EQUALITY.

Variable A: Type.
Variable dec_eq: forall (x y: A), {x=y} + {x<>y}.
Variable B: Type.

Lemma dec_eq_true:
  forall (x: A) (ifso ifnot: B),
  (if dec_eq x x then ifso else ifnot) = ifso.

Lemma dec_eq_false:
  forall (x y: A) (ifso ifnot: B),
  x <> y -> (if dec_eq x y then ifso else ifnot) = ifnot.

Lemma dec_eq_sym:
  forall (x y: A) (ifso ifnot: B),
  (if dec_eq x y then ifso else ifnot) =
  (if dec_eq y x then ifso else ifnot).

End DECIDABLE_EQUALITY.

Section DECIDABLE_PREDICATE.

Variable P: Prop.
Variable dec: {P} + {~P}.
Variable A: Type.

Lemma pred_dec_true:
  forall (a b: A), P -> (if dec then a else b) = a.

Lemma pred_dec_false:
  forall (a b: A), ~P -> (if dec then a else b) = b.

End DECIDABLE_PREDICATE.

Require Import Relations.

Section LEX_ORDER.

Variable A: Type.
Variable B: Type.
Variable ordA: A -> A -> Prop.
Variable ordB: B -> B -> Prop.

Inductive lex_ord: A*B -> A*B -> Prop :=
  | lex_ord_left: forall a1 b1 a2 b2,
      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
  | lex_ord_right: forall a b1 b2,
      ordB b1 b2 -> lex_ord (a,b1) (a,b2).

Lemma wf_lex_ord:
  well_founded ordA -> well_founded ordB -> well_founded lex_ord.

Lemma transitive_lex_ord:
  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.

End LEX_ORDER.

Inductive nlist (A: Type) : Type :=
  | nbase: A -> nlist A
  | ncons: A -> nlist A -> nlist A.

Definition nfirst {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => a end.

Fixpoint nlast {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => nlast l' end.

Fixpoint nIn {A: Type} (x: A) (l: nlist A) : Prop :=
  match l with
  | nbase a => a = x
  | ncons a l => a = x \/ nIn x l
  end.

Inductive nlist_forall2 {A B: Type} (R: A -> B -> Prop) : nlist A -> nlist B -> Prop :=
  | nbase_forall2: forall a b, R a b -> nlist_forall2 R (nbase a) (nbase b)
  | ncons_forall2: forall a l b m, R a b -> nlist_forall2 R l m -> nlist_forall2 R (ncons a l) (ncons b m).

Lemma nlist_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: nlist A) (l2: nlist B),
  nlist_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, nIn v1 l1 -> nIn v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  nlist_forall2 P2 l1 l2. *)

Require Import VST.msl.Coqlib2.
Require Import VST.msl.seplog.
Require Import VST.msl.sepalg.
Require Import VST.msl.age_to.
Require Import VST.veric.coqlib4.
Require Import VST.concurrency.common.threadPool.

Set Bullet Behavior "Strict Subproofs".

Fixpoint joinlist {A} {JA : Join A} (l : list A) (x : A) :=
  match l with
  | nil => identity x
  | h :: l => exists y, joinlist l y /\ join h y x
  end.

Lemma joinlist_inj {A} {JA : Join A} {PA : Perm_alg A} l r1 r2 :
  l <> nil ->
  joinlist l r1 ->
  joinlist l r2 ->
  r1 = r2.
Proof.
  revert r1 r2; induction l; intros r1 r2 n j1 j2. tauto. clear n.
  destruct j1 as (r1' & j1 & h1).
  destruct j2 as (r2' & j2 & h2).
  destruct l; simpl in *.
  - apply join_comm in h1; apply join_comm in h2.
    pose proof join_unit1_e _ _ j1 h1.
    pose proof join_unit1_e _ _ j2 h2.
    congruence.
  - cut (r1' = r2').
    + intros <-.
      eapply join_eq; eauto.
    + eapply IHl; eauto.
      congruence.
Qed.

Lemma joinlist_permutation {A} {JA : Join A} {PA : Perm_alg A} l1 l2 r :
  Permutation l1 l2 ->
  joinlist l1 r ->
  joinlist l2 r.
Proof.
  intros p; revert r; induction p; intros r; auto.
  - intros (r' & jl & j).
    exists r'; split; auto.
  - simpl.
    intros (a & (b & jb & ja) & jr).
    apply join_comm in jr.
    destruct (join_assoc ja jr) as (d & jd & jr').
    eauto.
Qed.

Instance Permutation_length' A {JA : Join A} {PA : Perm_alg A} :
  Proper (@Permutation A ==> @eq A ==> Logic.iff) joinlist | 10.
Proof.
  intros l1 l2 p x y <-; split; apply joinlist_permutation; auto.
  apply Permutation_sym, p.
Qed.

Lemma joinlist_app {A} {JA : Join A} {PA : Perm_alg A} l1 l2 x1 x2 x :
  joinlist l1 x1 ->
  joinlist l2 x2 ->
  join x1 x2 x ->
  joinlist (l1 ++ l2) x.
Proof.
  revert l2 x1 x2 x; induction l1; intros l2 x1 x2 x j1 j2 j; simpl in *.
  - erewrite <-join_unit1_e; eauto.
  - destruct j1 as (x1' & jl & jx1).
    destruct (join_assoc jx1 j) as (r & ? & ?).
    exists r; split; eauto.
Qed.

Lemma app_joinlist {A} {JA : Join A} {SA : Sep_alg A} {PA : Perm_alg A} l1 l2 x :
  joinlist (l1 ++ l2) x ->
  exists x1 x2,
    joinlist l1 x1 /\
    joinlist l2 x2 /\
    join x1 x2 x.
Proof.
  revert l2 x; induction l1; intros l2 x j; simpl in *.
  - exists (core x), x; split.
    + apply core_identity.
    + split; auto. apply core_unit.
  - destruct j as (y & h & ayx).
    destruct (IHl1 _ _ h) as (x1 & x2 & h1 & h2 & j).
    apply join_comm in j.
    apply join_comm in ayx.
    destruct (join_assoc j ayx) as (r & ? & ?).
    exists r, x2. eauto.
Qed.

Lemma joinlist_merge {A} {JA : Join A} {PA : Perm_alg A} (a b c x : A) l :
  join a b c -> joinlist (a :: b :: l) x <-> joinlist (c :: l) x.
Proof.
  intros j; split; intros h; swap 1 2.
  - destruct h as (rl & hl & jx).
    destruct (join_assoc j jx) as (bl & jbl & jabx).
    simpl. eauto.
  - rename c into ab, x into abc, j into a_b.
    destruct h as (bc & hl & a_bc).
    destruct hl as (c & hl & b_c).
    exists c; split; auto.
    clear hl l.
    apply join_comm in b_c.
    apply join_comm in a_bc.
    destruct (join_assoc b_c a_bc) as (ab' & a_b' & ab_c).
    apply join_comm in ab_c.
    exact_eq ab_c; f_equal.
    eapply join_eq; eauto.
Qed.

Lemma joinlist_swap {A} {JA : Join A} {PA : Perm_alg A} (a b x : A) l :
  joinlist (a :: b :: l) x =
  joinlist (b :: a :: l) x.
Proof.
  apply prop_ext; split; apply joinlist_permutation; constructor.
Qed.

Lemma joinlist_join_sub {A} {JA : Join A} {PA : Perm_alg A} (x phi : A) l :
  joinlist l phi ->
  In x l -> join_sub x phi.
Proof.
  revert x phi; induction l; simpl. tauto.
  intros x phi (b & jb & ab) [-> | i].
  - exists b; auto.
  - specialize (IHl _ _ jb i); auto.
    destruct IHl as (c, xc).
    apply sepalg.join_comm in ab.
    destruct (sepalg.join_assoc xc ab) as (d, H).
    exists d; intuition.
Qed.

Fixpoint listoption_inv {A} (l : list (option A)) : list A :=
  match l with
  | Some x :: l => x :: listoption_inv l
  | None :: l => listoption_inv l
  | nil => nil
  end.

Lemma map_listoption_inv {A B} (f : A -> B) (l : list (option A)) :
  map f (listoption_inv l) = listoption_inv (map (option_map f) l).
Proof.
  induction l as [ | [a|] l]; simpl; f_equal; auto.
Qed.

Fixpoint all_but (i : nat) {A} (l : list A) : list A :=
  match i with
    O => tl l
  | S i =>
    match l with
      nil => nil
    | x :: l => x :: all_but i l
    end
  end.

Lemma all_but_app {A} i (l l' : list A) :
  lt i (List.length l) ->
  all_but i (l ++ l') = all_but i l ++ l'.
Proof.
  revert l l'; induction i; intros [ | x l ] l' len; simpl; auto.
  all: try solve [inversion len].
  f_equal. apply IHi. simpl in *; omega.
Qed.

Lemma all_but_map {A B} (f : A -> B) i l :
  all_but i (map f l) = map f (all_but i l).
Proof.
  revert l; induction i; simpl.
  - destruct l; auto.
  - intros [|x l]; simpl; f_equal; auto.
Qed.

Lemma permutation_all_but {A} i (l : list A) x :
  nth_error l i = Some x ->
  Permutation l (x :: all_but i l).
Proof.
  revert l; induction i; simpl; intros [ | y l] E; try discriminate.
  - injection E as ->; simpl. constructor. auto with *.
  - specialize (IHi _ E).
    transitivity (y :: x :: all_but i l); auto.
    constructor.
Qed.

Fixpoint upd (i : nat) {A} new (l : list A) : option (list A) :=
  match i, l with
  | O, _ :: l => Some (new :: l)
  | _, nil => None
  | S i, x :: l =>
    match upd i new l with
    | Some l' => Some (x :: l')
    | None => None
    end
  end.

Lemma permutation_upd {A} i (l l' : list A) x :
  upd i x l = Some l' ->
  Permutation l' (x :: all_but i l).
Proof.
  revert l l'; induction i; simpl; intros [|y l] l' E;
    try discriminate.
  - injection E as <-; simpl. auto.
  - destruct (upd i x l) eqn:F'; try discriminate.
    injection E as <-.
    transitivity (y :: x :: all_but i l); auto.
    constructor.
Qed.

Lemma upd_lt {A} i x l : @upd i A x l <> None <-> lt i (length l).
Proof.
  revert i; induction l; intros i.
  - split.
    + destruct i; tauto.
    + inversion 1.
  - destruct i.
    + simpl; split.
      * auto with *.
      * congruence.
    + specialize (IHl i).
      transitivity (lt i (length l)).
      * rewrite <- IHl; clear IHl.
        simpl. destruct (upd i x l); split; congruence.
      * simpl; split; omega.
Qed.

Lemma upd_app_Some {A} i x (l1 l1' l2 : list A) :
  upd i x l1 = Some l1' ->
  upd i x (l1 ++ l2) = Some (l1' ++ l2).
Proof.
  revert i l1'; induction l1; intros i l1'.
  - destruct i; simpl; congruence.
  - destruct i; simpl.
    + injection 1 as <-. reflexivity.
    + destruct (upd i x l1) eqn:E. 2:congruence.
      injection 1 as <-.
      rewrite (IHl1 _ _ E).
      reflexivity.
Qed.

Lemma upd_app_None {A} i x (l1 l2 : list A) :
  upd i x l1 = None ->
  upd i x (l1 ++ l2) =
  option_map (app l1) (upd (i - length l1) x l2).
Proof.
  revert i; induction l1; intros i.
  - simpl. intros _. replace (i - 0)%nat with i by omega.
    destruct (upd i x l2); auto.
  - destruct i; simpl; intros E. discriminate.
    destruct (upd i x l1) as [o|] eqn:Eo. discriminate.
    rewrite (IHl1 _ Eo).
    destruct (upd (i - length l1) x l2); reflexivity.
Qed.

Lemma upd_last {A} i l (a x : A) :
  i = length l ->
  upd i x (l ++ a :: nil) = Some (l ++ x :: nil).
Proof.
  revert l a x; induction i; intros l a x.
  - destruct l. reflexivity. simpl. omega.
  - destruct l. simpl; omega. simpl.
    injection 1 as ->. rewrite IHi; auto.
Qed.

Lemma upd_rev {A} i x (l : list A) :
  (i < length l)%nat ->
  upd i x (rev l) = option_map (@rev A) (upd (length l - 1 - i) x l).
Proof.
  revert i; induction l; intros i li.
  - destruct i; auto.
  - simpl rev; simpl length.
    destruct (eq_dec i (length l)).
    + subst i. simpl. replace (length l - 0 - length l)%nat with O by omega.
      simpl.
      apply upd_last. symmetry. apply rev_length.
    + simpl in li.
      assert (U : (i < length l)%nat) by omega.
      pose proof U as Hi.
      rewrite <-rev_length in U.
      rewrite <-(upd_lt _ x) in U.
      destruct (upd i x (rev l)) as [o|] eqn:Eo. 2:tauto. clear U.
      specialize (IHl i Hi).
      rewrite Eo in IHl.
      replace (S (length l) - 1 - i)%nat with (S (length l - 1 - i)) by omega.
      simpl.
      destruct (upd (length l - 1 - i) x l) as [o'|] eqn:Eo'. 2: discriminate.
      simpl in *.
      apply upd_app_Some. congruence.
Qed.

Require Import VST.msl.ageable.
Require Import VST.msl.age_sepalg.

Lemma age_by_overflow {A} {_ : ageable A} {JA: Join A} (x : A) n : le (level x) n -> age_by n x = age_by (level x) x.
Proof.
  intros l.
  replace n with ((n - level x) + level x)%nat by omega.
  generalize (n - level x)%nat; intros k. clear n l.
  revert x; induction k; intros x. reflexivity.
  simpl. rewrite IHk.
  unfold age1' in *.
  destruct (age1 (age_by (level x) x)) eqn:E. 2:reflexivity. exfalso.
  eapply age1_level0_absurd. eauto.
  rewrite level_age_by. omega.
Qed.

Lemma age_by_minusminus {A} {_ : ageable A} {JA: Join A} (x : A) n : age_by (level x - (level x - n)) x = age_by n x.
Proof.
  assert (D : le (level x) n \/ lt n (level x)). omega.
  destruct D as [D|D].
  - replace (level x - (level x - n))%nat with (level x) by omega.
    symmetry; apply age_by_overflow, D.
  - f_equal; omega.
Qed.

Lemma age_by_join {A} {JA: Join A} {PA: Perm_alg A} {agA: ageable A} {AgeA: Age_alg A} :
  forall k x1 x2 x3,
    join x1 x2 x3 ->
    join (age_by k x1) (age_by k x2) (age_by k x3).
Proof.
  intros k x1 x2 x3 H.
  pose proof age_to_join_eq (level x3 - k) x1 x2 x3 H ltac:(omega) as G.
  pose proof join_level _ _ _ H as [e1 e2].
  exact_eq G; f_equal; unfold age_to.
  - rewrite <-e1; apply age_by_minusminus.
  - rewrite <-e2; apply age_by_minusminus.
  - apply age_by_minusminus.
Qed.

Lemma age_to_join {A} {JA: Join A} {PA: Perm_alg A} {agA: ageable A} {AgeA: Age_alg A} :
  forall k x1 x2 x3,
    join x1 x2 x3 ->
    join (age_to k x1) (age_to k x2) (age_to k x3).
Proof.
  intros k x1 x2 x3 J.
  unfold age_to in *.
  pose proof age_by_join ((level x1 - k)%nat) _ _ _ J as G.
  exact_eq G; do 3 f_equal.
  all: apply join_level in J; destruct J; congruence.
Qed.

Lemma age_by_joins {A} {JA: Join A} {PA: Perm_alg A} {agA: ageable A} {AgeA: Age_alg A} :
  forall k x1 x2,
    joins x1 x2 ->
    joins (age_by k x1) (age_by k x2).
Proof.
  intros k x1 x2 [].
  eexists; apply age_by_join; eauto.
Qed.

Lemma age_to_joins {A} {JA: Join A} {PA: Perm_alg A} {agA: ageable A} {AgeA: Age_alg A} :
  forall k x1 x2,
    joins x1 x2 ->
    joins (age_to k x1) (age_to k x2).
Proof.
  intros k x1 x2 [].
  eexists; apply age_to_join; eauto.
Qed.

Lemma age_to_join_sub {A} {JA: Join A} {PA: Perm_alg A} {agA: ageable A} {AgeA: Age_alg A} :
  forall k x1 x2,
    join_sub x1 x2 ->
    join_sub (age_to k x1) (age_to k x2).
Proof.
  intros k x1 x3 [].
  eexists; apply age_to_join; eauto.
Qed.

Lemma joinlist_level {A} `{agA : ageable A} {J : Join A} {_ : Perm_alg A} {_ : Age_alg A} (x : A) l Phi :
  joinlist l Phi ->
  In x l -> level x = level Phi.
Proof.
  intros j i.
  destruct (joinlist_join_sub x Phi l j i) as (y, Hy).
  apply join_level in Hy. apply Hy.
Qed.

Lemma joinlist_age1' {A} `{agA : ageable A} {J : Join A} {_ : Age_alg A} {_ : Perm_alg A} (l : list A) (x : A) :
  joinlist l x ->
  joinlist (map age1' l) (age1' x).
Proof.
  revert x; induction l; intros x h.
  - simpl in *. unfold age1'.
    destruct (age1 x) eqn:E; auto.
    eapply age_identity. apply E. apply h.
  - destruct h as (y & h & j).
    exists (age1' y); split. auto.
    unfold age1'.
    destruct (age1 a) eqn:Ea.
    + destruct (age1_join _ j Ea) as (y' & z' & j' & -> & ->). auto.
    + rewrite age1_level0 in Ea.
      pose proof (join_level _ _ _ j).
      assert (Ex : age1 x = None). apply age1_level0. intuition; congruence.
      assert (Ey : age1 y = None). apply age1_level0. intuition; congruence.
      rewrite Ex, Ey. auto.
Qed.

Lemma joinlist_age_to {A} `{agA : ageable A} {J : Join A} {_ : Age_alg A} {_ : Perm_alg A} n (l : list A) (x : A) :
  joinlist l x ->
  joinlist (map (age_to n) l) (age_to n x).
Proof.
  intros h.
  unfold age_to at 2.
  replace (map (age_to n) l) with (map (age_by (level x - n)) l).
  - generalize (level x - n)%nat; clear n; intros n; induction n.
    + exact_eq h; f_equal.
      induction l; auto. rewrite IHl at 1. reflexivity.
    + apply joinlist_age1' in IHn.
      exact_eq IHn; f_equal. clear.
      induction l; simpl; auto. f_equal; auto.
  - revert x h; induction l; auto; intros y (x & h & j); simpl.
    apply join_level in j.
    f_equal.
    + unfold age_to. do 2 f_equal. intuition.
    + rewrite <-IHl with x; auto. do 3 f_equal. intuition.
Qed.

Require Import VST.veric.compcert_rmaps.
Require Import VST.concurrency.common.enums_equality.
Require Import VST.concurrency.juicy.juicy_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.juicy.JuicyMachineModule.

Import THE_JUICY_MACHINE.
Import Concur.
Import OrdinalPool threadPool.ThreadPool.

Set Bullet Behavior "Strict Subproofs".

Section Machine.

Context {ge : Clight.genv}.

Definition getLocksR (tp : jstate ge) := listoption_inv (map snd (AMap.elements (lset tp))).

Definition maps tp := (getThreadsR tp ++ getLocksR tp)%list.

Lemma all_but_maps i tp (cnti : containsThread tp i) :
  all_but i (maps tp) = all_but i (getThreadsR tp) ++ getLocksR tp.
Proof.
  unfold maps. generalize (getLocksR tp); intros l.
  apply all_but_app.
  destruct tp as [[n] th ph lset]; simpl in *.
  unfold getThreadsR in *.
  unfold containsThread in *.
  simpl in *.
  rewrite map_length.
  clear -cnti.
  rewrite length_enum.
  pose proof @ssrnat.ltP i n.
  rewrite cnti in H.
  inversion H; auto.
Qed.

Lemma join_list_joinlist : join_list = joinlist.
Proof.
  extensionality l; induction l; extensionality phi; simpl; auto.
  f_equal. extensionality r. apply prop_ext.
  split; intros []; split; auto; simpl in *; congruence.
Qed.

Lemma join_list'_None l : join_list' l None <-> listoption_inv l = nil.
Proof.
  induction l. simpl. split; auto.
  simpl.
  split; destruct a as [r|].
  - intros (r' & j & h). inversion j.
  - intros (r' & j & h). inversion j; subst; tauto.
  - congruence.
  - rewrite <-IHl. intro. exists None; split; auto. constructor.
Qed.

Lemma join_list'_Some l phi : join_list' l (Some phi) -> joinlist (listoption_inv l) phi.
Proof.
  revert phi; induction l; intros phi. simpl. congruence.
  intros (r & j & h).
  simpl.
  destruct a.
  - inversion j; subst.
    + apply join_list'_None in h.
      simpl in *; rewrite h.
      simpl.
      exists (core phi).
      split.
      * apply core_identity.
      * apply join_comm, core_unit.
    + inversion j; subst; simpl; eauto.
  - inversion j; subst; simpl; eauto.
Qed.

Lemma join_list'_Some' l phi : listoption_inv l <> nil -> joinlist (listoption_inv l) phi -> join_list' l (Some phi).
Proof.
  revert phi; induction l; intros phi. simpl; congruence.
  destruct a as [r|]; simpl.
  - intros _ (y & h & j).
    simpl in *.
    assert (D:forall l:list rmap, l = nil \/ l <> nil)
      by (intros []; [left|right]; congruence).
    destruct (D (listoption_inv l)) as [E|E].
    + rewrite E in *.
      rewrite <-join_list'_None in E.
      exists None; split; auto.
      simpl in h.
      pose proof join_unit2_e _ _ h j. subst.
      constructor.
    + exists (Some y). split; auto.
      constructor; auto.
  - intros n j; specialize (IHl _ n j).
    exists (Some phi); split; eauto. constructor.
Qed.

Lemma join_all_joinlist tp : join_all tp = joinlist (maps tp).
Proof.
  extensionality phi. apply prop_ext. split.
  - intros J. inversion J as [? rt rl ? jt jl j]; subst.
    destruct rl as [rl|].
    + inversion j; subst.
      apply joinlist_app with (x1 := rt) (x2 := rl); auto.
      * rewrite <-join_list_joinlist.
        apply jt.
      * apply join_list'_Some.
        apply jl.
    + inversion j; subst.
      rewrite <-join_list_joinlist.
      apply join_list'_None in jl.
      unfold maps.
      cut (join_list (getThreadsR tp ++ nil) phi).
      { intro H; exact_eq H. f_equal. f_equal. symmetry. apply jl. }
      rewrite app_nil_r.
      apply jt.
  - intros j.
    unfold maps in j.
    apply app_joinlist in j.
    destruct j as (rt & rl & jt & jl & j).
    set (l' := getLocksR tp).
    assert (D:l' = nil \/ l' <> nil)
      by (destruct l'; [left|right]; congruence).
    destruct D as [D|D].
    + exists rt None; unfold l' in *; simpl in *.
      * hnf. rewrite join_list_joinlist. apply jt.
      * hnf. unfold l' in D.
        rewrite join_list'_None.
        simpl in *.
        rewrite <-D.
        reflexivity.
      * rewrite D in jl.
        simpl in jl.
        pose proof join_unit2_e _ _ jl j. subst.
        constructor.
    + exists rt (Some rl).
      * hnf. rewrite join_list_joinlist. apply jt.
      * hnf. apply join_list'_Some'; auto.
      * constructor; auto.
Qed.

Lemma seq_pmap_decent {A B} (f : A -> option B) l :
  seq.pmap f l = listoption_inv (map f l).
Proof.
  induction l; simpl. reflexivity.
  destruct (f a); rewrite IHl; reflexivity.
Qed.

Lemma minus_plus a b c : a - (b + c) = a - b - c.
Proof.
  omega.
Qed.

Lemma nth_error_enum_from n m i Hn Hi :
  (i < n)%nat ->
  nth_error (@enum_from n m Hn) i = Some (@fintype.Ordinal m (n - 1 - i) Hi).
Proof.
  revert i Hi;  induction n; intros i Hi Hin.
  - simpl. inv Hin.
  - destruct i.
    + f_equal.
      simpl minus in *.
      revert Hi.
      rewrite <-minus_n_O in *.
      rewrite <-minus_n_O in *.
      intros Hi.
      simpl.
      f_equal.
      f_equal.
      apply proof_irr.
    + simpl minus in *.
      revert Hi.
      rewrite <-minus_n_O in *.
      intros Hi.
      simpl.
      unshelve erewrite IHn.
      * exact_eq Hi.
        f_equal.
        f_equal.
        f_equal.
        rewrite <- Nat.sub_add_distr.
        reflexivity.
      * f_equal.
        rewrite <- Nat.sub_add_distr.
        reflexivity.
      * omega.
Qed.

Lemma nth_error_enum n i pr :
  nth_error (enum n) i = Some (@fintype.Ordinal n i pr).
Proof.
  unfold enum.
  rewrite initial_world.nth_error_rev; swap 1 2.
  - rewrite length_enum_from.
    apply (ssrbool.elimT ssrnat.leP pr).
  - rewrite length_enum_from.
    unshelve erewrite nth_error_enum_from.
    + pose proof pr as H.
      exact_eq H. do 2 f_equal.
      pose proof (ssrbool.elimT ssrnat.leP pr).
      omega.
    + match goal with
        |- Some (fintype.Ordinal (n:=n) (m:=n - 1 - (n - i - 1)) ?H) = _ =>
        generalize H
      end.
      pose proof (ssrbool.elimT ssrnat.leP pr).
      assert (R : (n - 1 - (n - i - 1) = i)%nat) by omega.
      rewrite R in *.
      intros pr'.
      do 2 f_equal.
      apply proof_irr.
    + pose proof (ssrbool.elimT ssrnat.leP pr).
      omega.
Qed.

Instance JSem : Semantics := ClightSemanticsForMachines.Clight_newSem ge.

Lemma getThreadR_nth i tp cnti :
  nth_error (getThreadsR tp) i = Some (@getThreadR _ _ _ i tp cnti).
Proof.
  simpl.
  unfold OrdinalPool.getThreadR in *.
  unfold getThreadsR in *.
  rewrite list_map_nth.
  match goal with
    |- option_map ?f ?x = Some (?f ?y) =>
    cut (x = Some y)
  end.
  intros ->; reflexivity.
  unfold containsThread in *.
  revert cnti.
  destruct tp as [n]; simpl. clear.
  apply nth_error_enum.
Qed.

Lemma getThreadsR_but i tp cnti :
  Permutation
    (getThreadsR tp)
    (@getThreadR _ _ _ i tp cnti :: all_but i (getThreadsR tp)).
Proof.
  apply permutation_all_but, getThreadR_nth.
Qed.

Lemma eqtype_refl n i cnti cntj :
  @eqtype.eq_op
    (fintype.ordinal_eqType n)
    (@fintype.Ordinal n i cnti)
    (@fintype.Ordinal n i cntj)
  = true.
Proof.
  compute; induction i; auto.
Qed.

Lemma eqtype_refl' n i j cnti cntj :
  i = j ->
  @eqtype.eq_op
    (fintype.ordinal_eqType n)
    (@fintype.Ordinal n i cnti)
    (@fintype.Ordinal n j cntj)
  = true.
Proof.
  intros <-; apply eqtype_refl.
Qed.

Lemma eqtype_neq n i j cnti cntj :
  i <> j ->
  @eqtype.eq_op
    (fintype.ordinal_eqType n)
    (@fintype.Ordinal n i cnti)
    (@fintype.Ordinal n j cntj)
  = false.
Proof.
  revert j cntj.
  induction i; intros [|j] cntj d.
  all:try tauto.
  unshelve eapply IHi; auto with *.
Qed.

Lemma updThreadR_but i tp cnti phi :
  Permutation
    (getThreadsR (@updThreadR _ _ _ i tp cnti phi))
    (phi :: all_but i (getThreadsR tp)).
Proof.
  apply permutation_upd.
  simpl.
  unfold OrdinalPool.updThreadR, getThreadsR.
  simpl in *.
  unfold OrdinalPool.containsThread in *.
  destruct tp as [[n] thds phis lset]; simpl in *.
  unfold enum.
  clear thds lset.
  rewrite map_rev.
  rewrite map_rev.
  assert (li : lt i n). {
    apply (ssrbool.elimT ssrnat.leP cnti).
  }
  rewrite upd_rev; auto.
  2:now rewrite map_length, length_enum_from; auto.
  rewrite map_length, length_enum_from.
  match goal with
    |- _ = Some (?a ?x) =>
    change (Some (a x)) with (option_map a (Some x))
  end.
  f_equal.
  Set Printing Implicit.
  generalize (Nat.le_refl n) as pr.
  rename n into m.
  assert (Ei : (i = (m - 1 - (m - 1 - i)))%nat). {
    pose proof (ssrbool.elimT ssrnat.leP cnti).
    rewrite <- !Nat.sub_add_distr, Nat.add_comm, Nat.sub_add_distr.
    replace (m - (m - (1 + i)))%nat with (S i); omega.
  }
  assert (cnti' : is_true (ssrnat.leq (S (m - 1 - (m - 1 - i))) m))
    by congruence.
  replace (@fintype.Ordinal m i cnti)
  with (@fintype.Ordinal m (m - 1 - (m - 1 - i)) cnti')
    by (revert cnti'; rewrite <-Ei; intros; f_equal; apply proof_irr).
  assert (li' : (m - 1 - i < m)%nat) by (clear -li; omega).
  clear cnti Ei. revert li' cnti'.
  generalize (m - 1 - i)%nat; clear i li; intros i.
  generalize m at 1 2 4 7 13 14; intros n; revert i.
  induction n; intros i li cnti Hnm. now inversion li.
  match goal with |- _ = Some (map ?F _) => set (f := F) end.
  Unset Printing Implicit.
  destruct i.
  - simpl.
    f_equal.
    f_equal.
    + unfold f; simpl.
      rewrite eqtype_refl'. reflexivity. omega.
    + clear.
      unfold f; clear f. simpl in cnti.
      simpl.
      revert cnti; replace (n - 0 - 0)%nat with n by omega; intros cnti.
      revert cnti; assert (H : le n n) by auto; revert H.
      generalize n at 2 3 9; intros a la cnta.
      induction n. auto.
      simpl; f_equal.
      * rewrite eqtype_neq. 2:omega.
        auto.
      * unshelve erewrite IHn. 2:omega.
        auto.
  - simpl.
    erewrite IHn.
    2:omega.
    f_equal.
    f_equal.
    + unfold f.
      simpl.
      rewrite eqtype_neq. 2:omega.
      reflexivity.
    + unfold f.
      f_equal.
      extensionality x.
      destruct x as [j lj].
      destruct (eq_dec j (n - 1 - i)%nat).
      * rewrite eqtype_refl'; auto.
        rewrite eqtype_refl'; auto.
        omega.
      * rewrite eqtype_neq; auto.
        rewrite eqtype_neq; auto.
        omega.
  Unshelve. 
  clear -cnti. exact_eq cnti; do 3 f_equal. omega.
Qed.

Lemma updThread_but i tp cnti c phi :
  Permutation
    (getThreadsR (@updThread _ _ _ i tp cnti c phi))
    (phi :: all_but i (getThreadsR tp)).
Proof.
  pose proof (updThreadR_but i tp cnti phi) as H; revert H.
  unfold updThreadR, updThread, getThreadsR; simpl.
  auto.
Qed.

Lemma getLocksR_updLockSet_Some tp addr phi :
  Permutation
    (getLocksR (updLockSet(resources:=LocksAndResources) tp addr (Some phi)))
    (phi :: getLocksR (remLockSet tp addr)).
Proof.
  unfold lockRes, getLocksR, remLockSet, lset.
  destruct tp as [n th ph lset]; simpl. clear.
  destruct lset as [l S].
  unfold AMap.Raw.t, AMap.find in *; simpl. clear S.
  induction l as [|[addr' x] l]; simpl. reflexivity.
  destruct (AddressOrdered.compare addr addr'); simpl; try reflexivity.
  destruct x; simpl; rewrite IHl; auto.
  apply perm_swap.
Qed.

Lemma getLocksR_updLockSet_None (tp : jstate ge) addr :
  getLocksR (updLockSet tp addr None) = getLocksR (remLockSet tp addr).
Proof.
  unfold lockRes, getLocksR, remLockSet, lset.
  destruct tp as [n th ph lset]; simpl. clear.
  destruct lset as [l S].
  unfold AMap.Raw.t, AMap.find in *; simpl. clear S.
  induction l as [|[addr' x] l]; simpl. reflexivity.
  destruct (AddressOrdered.compare addr addr'); simpl; try reflexivity.
  destruct x; simpl; rewrite IHl; auto.
Qed.

Lemma getLocksR_SSome (tp : jstate ge) addr phi :
  lockRes tp addr = Some (Some phi) ->
  Permutation
    (getLocksR tp)
    (phi :: getLocksR (remLockSet tp addr)).
Proof.
  simpl.
  unfold OrdinalPool.lockRes, getLocksR, remLockSet, lset.
  destruct tp as [n th ph lset]; simpl. clear.
  destruct lset as [l S].
  unfold AMap.Raw.t, AMap.find in *; simpl. clear S.
  induction l as [|[addr' x] l]; simpl; intros F. inversion F.
  destruct (AddressOrdered.compare addr addr'); inversion F; auto.
  destruct x; simpl; rewrite IHl; auto.
  apply perm_swap.
Qed.

Lemma getLocksR_SNone (tp : jstate ge) addr :
  lockRes tp addr = Some None ->
  getLocksR (remLockSet tp addr) = getLocksR tp.
Proof.
  simpl.
  unfold OrdinalPool.lockRes, getLocksR, remLockSet, lset.
  destruct tp as [n th ph lset]; simpl. clear.
  destruct lset as [l S].
  unfold AMap.Raw.t, AMap.find in *; simpl. clear S.
  induction l as [|[addr' x] l]; simpl; intros F; auto.
  destruct (AddressOrdered.compare addr addr'); try inversion F; auto.
  destruct x; simpl; rewrite IHl; auto.
Qed.

Lemma getLocksR_None (tp : jstate ge) addr :
  lockRes tp addr = None ->
  getLocksR (remLockSet tp addr) = getLocksR tp.
Proof.
  simpl.
  unfold OrdinalPool.lockRes, getLocksR, remLockSet, lset.
  destruct tp as [n th ph lset]; simpl. clear.
  destruct lset as [l S].
  unfold AMap.Raw.t, AMap.find in *; simpl. clear S.
  induction l as [|[addr' x] l]; simpl; intros F; auto.
  destruct (AddressOrdered.compare addr addr'); try inversion F; auto.
  destruct x; simpl; rewrite IHl; auto.
Qed.

Lemma maps_getthread i tp cnti :
  Permutation (maps tp)
              (@getThreadR _ _ _ i tp cnti :: all_but i (maps tp)).
Proof.
  rewrite all_but_maps; auto.
  transitivity
    ((getThreadR cnti :: all_but i (getThreadsR tp)) ++ getLocksR tp); auto.
  rewrite <-getThreadsR_but. reflexivity.
Qed.

Lemma maps_updthread i tp cnti c phi :
  Permutation (maps (@updThread _ _ _ i tp cnti c phi))
              (phi :: all_but i (maps tp)).
Proof.
  rewrite all_but_maps; auto.
  unfold maps. rewrite updThread_but.
  apply Permutation_refl.
Qed.

Lemma maps_updthreadR i tp cnti phi :
  Permutation (maps (@updThreadR _ _ _ i tp cnti phi))
              (phi :: all_but i (maps tp)).
Proof.
  rewrite all_but_maps; auto.
  unfold maps. rewrite updThreadR_but.
  apply Permutation_refl.
Qed.

Lemma maps_updlock1 (tp : jstate ge) addr :
  maps (updLockSet tp addr None) = maps (remLockSet tp addr).
Proof.
  unfold maps; f_equal.
  apply getLocksR_updLockSet_None.
Qed.

Lemma maps_updlock2 (tp : jstate ge) addr phi :
  Permutation (maps (updLockSet tp addr (Some phi)))
              (phi :: maps (remLockSet tp addr)).
Proof.
  unfold maps.
  rewrite getLocksR_updLockSet_Some.
  symmetry.
  apply Permutation_cons_app; auto.
Qed.

Lemma maps_getlock1 tp addr :
  lockRes tp addr = None ->
  maps (remLockSet tp addr) = maps tp.
Proof.
  unfold maps; f_equal; intro.
  rewrite getLocksR_None; auto.
Qed.

Lemma maps_getlock2 (tp : jstate ge) addr :
  lockRes tp addr = Some None ->
  maps (remLockSet tp addr) = maps tp.
Proof.
  unfold maps; f_equal; intro.
  rewrite getLocksR_SNone; auto.
Qed.

Lemma maps_getlock3 (tp : jstate ge) addr phi :
  lockRes tp addr = Some (Some phi) ->
  Permutation (maps tp) (phi :: maps (remLockSet tp addr)).
Proof.
  unfold maps; f_equal; intro.
  rewrite getLocksR_SSome; eauto.
  symmetry.
  apply Permutation_cons_app; auto.
Qed.

Lemma maps_addthread tp v1 v2 phi :
  Permutation (maps (addThread tp v1 v2 phi))
              (phi :: maps tp).
Proof.
  unfold maps.
  change (phi :: getThreadsR tp ++ getLocksR tp)
  with ((phi :: getThreadsR tp) ++ getLocksR tp).
  apply Permutation_app_tail.
  rewrite Permutation_cons_append.
  rewrite getThreadsR_addThread.
  apply Permutation_refl.
Qed.

Lemma maps_age_to i tp :
  maps (age_tp_to i tp) = map (age_to i) (maps tp).
Proof.
  destruct tp as [n th ph ls]; simpl.
  unfold maps, getThreadsR, getLocksR in *.
  rewrite map_app.
  f_equal.
  - apply map_compose.
  - unfold lset.
    rewrite AMap_map.
    rewrite map_listoption_inv.
    reflexivity.
Qed.

Lemma maps_remLockSet_updThread i tp addr cnti c phi :
  maps (remLockSet (@updThread _ _ _ i tp cnti c phi) addr) =
  maps (@updThread _ _ _ i (remLockSet tp addr) cnti c phi).
Proof.
  reflexivity.
Qed.

Lemma getThread_level i tp cnti Phi :
  join_all tp Phi ->
  level (@getThreadR _ _ _ i tp cnti) = level Phi.
Proof.
  intros j.
  apply juicy_mem.rmap_join_sub_eq_level, compatible_threadRes_sub, j.
Qed.

Lemma join_sub_level {A} `{JA : sepalg.Join A} `{_ : ageable A} {_ : Perm_alg A} {_ : Age_alg A} :
  forall x y : A, join_sub x y -> level x = level y.
Proof.
  intros x y (z, j).
  apply (join_level _ _ _ j).
Qed.

Lemma joins_level {A} `{JA : sepalg.Join A} `{_ : ageable A} {_ : Perm_alg A} {_ : Age_alg A} :
  forall x y : A, joins x y -> level x = level y.
Proof.
  intros x y (z, j).
  destruct (join_level _ _ _ j); congruence.
Qed.

End Machine.
