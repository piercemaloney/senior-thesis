Require Import VST.veric.juicy_base.
(* VST.veric.juicy_base:
Require Export VST.veric.base.
Require Export VST.msl.msl_standard.
Require Export VST.veric.rmaps.

Require Export VST.veric.rmaps_lemmas.

Require Export VST.veric.compcert_rmaps.

Export Mem.
Open Scope Z. *)

Require Import VST.veric.shares.
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)

Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
(* VST.veric.juicy_mem:
Require Import VST.veric.base.
Require Import VST.veric.Memory.
Require Import VST.veric.juicy_base.
Require Import VST.veric.shares.
Import cjoins.

Definition dec_share_nonidentity (sh: Share.t) : {~identity sh}+{identity sh} :=
   (Sumbool.sumbool_not _ _ (dec_share_identity sh)).

Definition perm_of_sh (sh: Share.t): option permission :=
  if writable0_share_dec sh
  then if eq_dec sh Share.top
            then Some Freeable
            else Some Writable
    else if readable_share_dec sh
         then Some Readable
         else if eq_dec sh Share.bot
                   then None
              else Some Nonempty.
Functional Scheme perm_of_sh_ind := Induction for perm_of_sh Sort Prop.

Definition contents_at (m: mem) (loc: address) : memval :=
  ZMap.get (snd loc) (PMap.get (fst loc) (mem_contents m)).

Definition contents_cohere (m: mem) (phi: rmap) :=
  forall rsh sh v loc pp, phi @ loc = YES rsh sh (VAL v) pp -> contents_at m loc = v /\ pp=NoneP.

Definition valshare (r: resource) : share :=
    match r with
      | YES sh rsh _ _ => Share.glb Share.Rsh sh
      | _ => Share.bot
    end.

Definition res_retain' (r: resource) : Share.t :=
 match r with
  | NO sh _ => sh
  | YES sh _ _ _ => Share.glb Share.Lsh sh
  | PURE _ _ => Share.top
 end.

Definition perm_of_res (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh rsh (VAL _) _ => perm_of_sh sh
 | YES sh rsh _ _ => Some Nonempty
 end.

Definition perm_of_res_lock_explicit
             (r : compcert_rmaps.RML.R.resource):=
    match r with
    | compcert_rmaps.RML.R.NO _ _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ =>
      if writable0_share_dec (Share.glb Share.Rsh sh)
      then if eq_dec (Share.glb Share.Rsh sh) Share.top then Some Freeable else Some Writable
      else if readable_share_dec (Share.glb Share.Rsh sh) then Some Readable else
             if eq_dec  (Share.glb Share.Rsh sh) Share.bot then None else Some Nonempty
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => None
    | compcert_rmaps.RML.R.PURE _ _ => None
    end.
      
  Functional Scheme perm_of_res_lock_expl_ind := Induction for perm_of_res_lock_explicit Sort Prop.

Definition perm_of_res' (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh _ _ _ => perm_of_sh sh
 end.

Definition perm_of_res_lock (r: resource) := 
  
 match r with
 | YES sh rsh (LK _ _) _ => perm_of_sh (Share.glb Share.Rsh sh)
 | _ => None 
 end.

Definition perm_of_res_explicit
               (r : compcert_rmaps.RML.R.resource):=
        match r with
        | compcert_rmaps.RML.R.NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ =>
             if writable0_share_dec sh
             then if eq_dec sh Share.top then Some Freeable else Some Writable
             else
               if readable_share_dec sh
               then Some Readable
               else if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.PURE _ _ => Some Nonempty
        end.
      
Functional Scheme perm_of_res_expl_ind := Induction for perm_of_res_explicit Sort Prop.

Lemma Rsh_not_top: Share.Rsh <> Share.top.

Lemma nonidentity_Rsh: ~identity Share.Rsh.

Lemma perm_of_sh_fullshare: perm_of_sh fullshare = Some Freeable.

Lemma nonreadable_extern_retainer: ~readable_share extern_retainer.

Lemma Lsh_nonreadable: ~readable_share Share.Lsh.

Lemma perm_of_res_op1:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res r).

Lemma perm_of_res_op2:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res_lock r).

Definition access_cohere (m: mem)  (phi: rmap) :=
  forall loc,  access_at m loc Cur = perm_of_res (phi @ loc).

Definition max_access_at m loc := access_at m loc Max.

Definition max_access_cohere (m: mem) (phi: rmap)  :=
  forall loc,
    perm_order'' (max_access_at m loc) (perm_of_res' (phi @ loc)).

Definition alloc_cohere (m: mem) (phi: rmap) :=
 forall loc,  (fst loc >= nextblock m)%positive -> phi @ loc = NO Share.bot bot_unreadable.

Inductive juicy_mem: Type :=
  mkJuicyMem: forall (m: mem) (phi: rmap)
    (JMcontents: contents_cohere m phi)
    (JMaccess: access_cohere m phi)
    (JMmax_access: max_access_cohere m phi)
    (JMalloc: alloc_cohere m phi),
       juicy_mem.

Section selectors.
Variable (j: juicy_mem).
Definition m_dry := match j with mkJuicyMem m _ _ _ _ _ => m end.
Definition m_phi := match j with mkJuicyMem _ phi _ _ _ _ => phi end.
Lemma juicy_mem_contents: contents_cohere m_dry m_phi.
Lemma juicy_mem_access: access_cohere m_dry m_phi.
Lemma juicy_mem_max_access: max_access_cohere m_dry m_phi.
Lemma juicy_mem_alloc_cohere: alloc_cohere m_dry m_phi.
End selectors.

Definition juicy_mem_resource: forall jm m', resource_at m' = resource_at (m_phi jm) ->
  {jm' | m_phi jm' = m' /\ m_dry jm' = m_dry jm}.

Lemma perm_of_empty_inv {s} : perm_of_sh s = None -> s = Share.bot.

Lemma writable_join_sub: forall loc phi1 phi2,
  join_sub phi1 phi2 -> writable loc phi1 -> writable loc phi2.

Lemma writable_inv: forall phi loc, writable loc phi ->
  exists sh, exists rsh, exists k, exists pp, 
       phi @ loc = YES sh rsh k pp /\ 
       writable0_share sh /\
       isVAL k.

Lemma nreadable_inv: forall phi loc, ~readable loc phi 
  -> (exists sh, exists nsh, phi @ loc = NO sh nsh)
   \/ (exists sh, exists rsh, exists k, exists pp, phi @ loc = YES sh rsh k pp /\ ~isVAL k)
   \/ (exists k, exists pp, phi @ loc = PURE k pp).

Lemma age1_joinx {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3 phi1' phi2' phi3',
             age phi1 phi1' -> age phi2 phi2' -> age phi3 phi3' ->
             join phi1 phi2 phi3 -> join phi1' phi2' phi3'.

Lemma constructive_age1_join  {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall x y z x' : A,
       join x y z ->
       age x x' ->
       { yz' : A*A | join x' (fst yz') (snd yz') /\ age y (fst yz') /\ age z (snd yz')}.

Lemma age1_constructive_joins_eq : forall {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}  {phi1 phi2},
  constructive_joins phi1 phi2
  -> forall {phi1'}, age1 phi1 = Some phi1'
  -> forall {phi2'}, age1 phi2 = Some phi2'
  -> constructive_joins phi1' phi2'.

Program Definition age1_juicy_mem (j: juicy_mem): option juicy_mem :=
      match age1 (m_phi j) with
        | Some phi' => Some (mkJuicyMem (m_dry j) phi' _ _ _ _)
        | None => None
      end.

Lemma age1_juicy_mem_unpack: forall j j',
  age1_juicy_mem j = Some j' ->
  age (m_phi j)  (m_phi j')
  /\ m_dry j = m_dry j'.

Lemma age1_juicy_mem_unpack': forall j j',
  age (m_phi j)  (m_phi j')  /\ m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma age1_juicy_mem_unpack'': forall j j',
  age (m_phi j)  (m_phi j')  -> m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma rmap_join_eq_level: forall phi1 phi2: rmap, joins phi1 phi2 -> level phi1 = level phi2.

Lemma rmap_join_sub_eq_level: forall phi1 phi2: rmap,
          join_sub phi1 phi2 -> level phi1 = level phi2.

Lemma age1_juicy_mem_None1:
  forall j, age1_juicy_mem j = None -> age1 (m_phi j) = None.

Lemma age1_juicy_mem_None2:
  forall j, age1 (m_phi j) = None -> age1_juicy_mem j = None.

Lemma age1_juicy_mem_Some:
  forall j j', age1_juicy_mem j = Some j' -> age1 (m_phi j) = Some (m_phi j').

Lemma unage_juicy_mem: forall j' : juicy_mem,
   exists j : juicy_mem, age1_juicy_mem j = Some j'.

Lemma level1_juicy_mem: forall j: juicy_mem,
  age1_juicy_mem j = None <-> level (m_phi j) = 0%nat.

Lemma level2_juicy_mem: forall j1 j2: juicy_mem,
   age1_juicy_mem j1 = Some j2 -> level (m_phi j1) = S (level (m_phi j2)).

Lemma juicy_mem_ageable_facts: ageable_facts juicy_mem (fun j => level (m_phi j)) age1_juicy_mem.

Instance juicy_mem_ageable: ageable juicy_mem :=
  mkAgeable _ (fun j => level (m_phi j)) age1_juicy_mem juicy_mem_ageable_facts.

Lemma level_juice_level_phi: forall (j: juicy_mem), level j = level (m_phi j).

Lemma juicy_mem_ext: forall j1 j2,
       m_dry j1 = m_dry j2  ->
       m_phi j1 = m_phi j2 ->
       j1=j2.

Lemma unage_writable: forall (phi phi': rmap) loc,
  age phi phi' -> writable loc phi' -> writable loc phi.

Lemma unage_readable: forall (phi phi': rmap) loc,
  age phi phi' -> readable loc phi' -> readable loc phi.

Lemma readable_inv: forall phi loc, readable loc phi ->
  exists rsh, exists sh, exists v, exists pp, phi @ loc = YES rsh sh (VAL v) pp.

Definition fmap_option {A B} (v: option A) (m: B) (f: A -> B): B :=
  match v with
    | None => m
    | Some v' => f v'
  end.

Lemma resource_at_make_rmap: forall f g lev H Hg, resource_at (proj1_sig (make_rmap f g lev H Hg)) = f.

Lemma resource_at_remake_rmap: forall f g lev H Hg, resource_at (proj1_sig (remake_rmap f g lev H Hg)) = f.

Lemma ghost_of_make_rmap: forall f g lev H Hg, ghost_of (proj1_sig (make_rmap f g lev H Hg)) = g.

Lemma ghost_of_remake_rmap: forall f g lev H Hg, ghost_of (proj1_sig (remake_rmap f g lev H Hg)) = g.

Lemma level_make_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (make_rmap f g lev H Hg)) = lev.

Lemma level_remake_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (remake_rmap f g lev H Hg)) = lev.

Section inflate.
Variables (m: mem) (phi: rmap).

Definition inflate_initial_mem' (w: rmap) (loc: address) :=
   match access_at m loc Cur with
           | Some Freeable => YES Share.top readable_share_top (VAL (contents_at m loc)) NoneP
           | Some Writable => YES Ews (writable_readable writable_Ews) (VAL (contents_at m loc)) NoneP
           | Some Readable => YES Ers readable_Ers (VAL (contents_at m loc)) NoneP
           | Some Nonempty => 
                         match w @ loc with PURE _ _ => w @ loc | _ => NO _ nonreadable_extern_retainer end
           | None =>  NO Share.bot bot_unreadable
         end.

Lemma inflate_initial_mem'_fmap:
 forall w, resource_fmap (approx (level w)) (approx (level w)) oo inflate_initial_mem' w =
                inflate_initial_mem' w.

Definition inflate_initial_mem (w: rmap): rmap :=
    proj1_sig (make_rmap (inflate_initial_mem' w) (ghost_of w) _
            (inflate_initial_mem'_fmap w) (ghost_of_approx w)).

Lemma inflate_initial_mem_level: forall w, level (inflate_initial_mem w) = level w.

Definition all_VALs (phi: rmap) :=
  forall l, match phi @ l with
              | YES _ _ k _ => isVAL k
              | _ => True
            end.

Lemma inflate_initial_mem_all_VALs: forall lev, all_VALs (inflate_initial_mem lev).

Definition inflate_alloc: rmap.

Lemma approx_map_idem: forall n (lp: preds),
  preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) lp) =
  preds_fmap (approx n) (approx n) lp.

Definition inflate_store: rmap. refine (

End inflate.

Lemma adr_inv0: forall (b b': block) (ofs ofs': Z) (sz: Z),
  ~ adr_range (b, ofs) sz (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + sz.

Lemma adr_inv: forall (b b': block) (ofs ofs': Z) ch,
  ~ adr_range (b, ofs) (size_chunk ch) (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + size_chunk ch.

Lemma range_inv0: forall ofs ofs' sz,
  ~ ofs <= ofs' < ofs + sz ->
  ofs' < ofs \/ ofs' >= ofs + sz.

Lemma range_inv: forall ofs ofs' ch,
  ~ ofs <= ofs' < ofs + size_chunk ch ->
  ofs' < ofs \/ ofs' >= ofs + size_chunk ch.

Lemma perm_of_sh_Freeable_top: forall sh, perm_of_sh sh = Some Freeable -> 
     sh = Share.top.

Lemma nextblock_access_empty: forall m b ofs k, (b >= nextblock m)%positive
  -> access_at m (b, ofs) k = None.

Section initial_mem.
Variables (m: mem) (w: rmap).

Definition initial_rmap_ok := 
   forall loc, ((fst loc >= nextblock m)%positive -> core w @ loc = NO Share.bot bot_unreadable) /\
                   (match w @ loc with 
                    | PURE _ _ => (fst loc < nextblock m)%positive /\ 
                                           access_at m loc Cur = Some Nonempty /\  
                                            max_access_at m loc = Some Nonempty 
                    | _ => True end).
Hypothesis IOK: initial_rmap_ok.
End initial_mem.

Definition empty_retainer (loc: address) := Share.bot.

Lemma perm_of_freeable: perm_of_sh Share.top = Some Freeable.

Lemma perm_of_writable: 
   forall sh, writable_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

Lemma perm_of_readable:
  forall sh (rsh: readable_share sh), ~writable0_share sh -> perm_of_sh sh = Some Readable.

Lemma perm_of_nonempty:
  forall sh, sh <> Share.bot -> ~readable_share sh -> perm_of_sh sh = Some Nonempty.

Lemma perm_of_empty:
    perm_of_sh Share.bot = None.

Lemma perm_of_Ews: perm_of_sh Ews = Some Writable.

Lemma perm_of_Ers: perm_of_sh Ers = Some Readable.

Lemma extern_retainer_neq_bot: extern_retainer <> Share.bot.

Lemma perm_order''_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Definition initial_mem (m: mem) lev (IOK: initial_rmap_ok m lev) : juicy_mem.

Definition juicy_mem_level (j: juicy_mem) (lev: nat) :=
  level (m_phi j) = lev.

Lemma initial_mem_level: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_level j (level lev).

Lemma initial_mem_all_VALs: forall lev m j IOK, j = initial_mem m lev IOK
  -> all_VALs (m_phi j).

Lemma perm_mem_access: forall m b ofs p,
  perm m b ofs Cur p ->
  exists p', (perm_order p' p /\ access_at m (b, ofs) Cur = Some p').

Section store.
Variables (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m').

Lemma store_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (size_chunk ch) loc'
  -> (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP -> contents_at m' loc' = mv.

Definition store_juicy_mem: juicy_mem.

End store.

Section storebytes.
Variables (jm: juicy_mem) (m': mem) (b: block) (ofs: Z) (bytes: list memval)
  (STOREBYTES: storebytes (m_dry jm) b ofs bytes = Some m').

Lemma storebytes_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (Zlength bytes) loc' ->
  (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP ->
  contents_at m' loc' = mv.

Definition storebytes_juicy_mem: juicy_mem.

End storebytes.

Lemma free_smaller_None : forall m b b' ofs lo hi m',
  access_at m (b, ofs) Cur = None
  -> free m b' lo hi = Some m'
  -> access_at m' (b, ofs) Cur = None.

Lemma free_nadr_range_eq : forall m b b' ofs' lo hi m',
  ~ adr_range (b, lo) (hi - lo) (b', ofs')
  -> free m b lo hi = Some m'
  -> access_at m (b', ofs') = access_at m' (b', ofs')
  /\  contents_at m (b', ofs') = contents_at m' (b', ofs').

Section free.
Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable).

Definition inflate_free: rmap. refine (

Definition free_juicy_mem: juicy_mem.

End free.

Lemma free_not_freeable_eq : forall m b lo hi m' b' ofs',
  free m b lo hi = Some m'
  -> access_at m (b', ofs') Cur <> Some Freeable
  -> access_at m (b', ofs') Cur = access_at m' (b', ofs') Cur.

Definition after_alloc' 
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else phi @ loc.

Lemma adr_range_eq_block : forall b ofs n b' ofs',
  adr_range (b,ofs) n (b',ofs') ->
  b=b'.

Lemma after_alloc'_ok : forall lo hi b phi H,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (after_alloc' lo hi b phi H)
  = after_alloc' lo hi b phi H.

Definition after_alloc
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable) : rmap :=
  proj1_sig (make_rmap (after_alloc' lo hi b phi H) (ghost_of phi)
    (level phi)
    (after_alloc'_ok lo hi b phi H) (ghost_of_approx phi)).

Definition mod_after_alloc' (phi: rmap) (lo hi: Z) (b: block)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else core phi @ loc.

Lemma mod_after_alloc'_ok : forall phi lo hi b,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (mod_after_alloc'  phi lo hi b)
  = mod_after_alloc' phi lo hi b.

Definition mod_after_alloc (phi: rmap) (lo hi: Z) (b: block) :=
  proj1_sig (make_rmap (mod_after_alloc' phi lo hi b) (ghost_of phi)
    _
    (mod_after_alloc'_ok phi lo hi b) (ghost_of_approx phi)).

Transparent alloc.

Lemma adr_range_inv: forall loc loc' n,
  ~ adr_range loc n loc' ->
  fst loc <> fst loc' \/ (fst loc=fst loc' /\ ~snd loc <= snd loc' < snd loc + n).

Lemma dry_noperm_juicy_nonreadable : forall m loc,
  access_at (m_dry m) loc Cur = None ->   ~readable loc (m_phi m).

Lemma fullempty_after_alloc : forall m1 m2 lo n b ofs,
  alloc m1 lo n = (m2, b) ->
  access_at m2 (b, ofs) Cur = None \/ access_at m2 (b, ofs) Cur = Some Freeable.

Lemma alloc_dry_unchanged_on : forall m1 m2 loc lo hi b0,
  alloc m1 lo hi = (m2, b0) ->
  ~adr_range (b0,lo) (hi-lo) loc ->
  access_at m1 loc = access_at m2 loc /\
  (access_at m1 loc Cur <> None -> contents_at m1 loc= contents_at m2 loc).

Lemma adr_range_zle_fact : forall b lo hi loc,
  adr_range (b,lo) (hi-lo) loc ->
  zle lo (snd loc) && zlt (snd loc) hi = true.

Lemma alloc_dry_updated_on : forall m1 m2 lo hi b loc,
  alloc m1 lo hi = (m2, b) ->
  adr_range (b, lo) (hi - lo) loc ->
  access_at m2 loc Cur=Some Freeable /\
  contents_at m2 loc=Undef.

Definition resource_decay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
 forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = 
                       YES sh (writable0_readable wsh) (VAL v) NoneP /\ 
       phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)
  \/ ((fst l >= nextb)%positive /\ exists v, phi2 @ l = YES Share.top readable_share_top (VAL v) NoneP)
  \/ (exists v, exists pp, phi1 @ l = YES Share.top readable_share_top (VAL v) pp 
                        /\ phi2 @ l = NO Share.bot bot_unreadable)).

Definition resource_nodecay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
  forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = YES sh (writable0_readable wsh) (VAL v) NoneP
      /\ phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)).

Lemma resource_nodecay_decay:
   forall b phi1 phi2, resource_nodecay b phi1 phi2 -> resource_decay b phi1 phi2.

Lemma resource_decay_refl: forall b phi, 
  (forall l, (fst l >= b)%positive -> phi @ l = NO Share.bot bot_unreadable) ->

Lemma resource_decay_trans: forall b b' m1 m2 m3,
  (b <= b')%positive ->
  resource_decay b m1 m2 -> resource_decay b' m2 m3 -> resource_decay b m1 m3.

Lemma level_store_juicy_mem:
 forall jm m ch b i v H, level (store_juicy_mem jm m ch b i v H) = level jm.

Lemma level_storebytes_juicy_mem:
 forall jm m b i bytes H, level (storebytes_juicy_mem jm m b i bytes H) = level jm.

Lemma inflate_store_resource_nodecay:
  forall (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable))
          phi',
  inflate_store m' (m_phi jm) = phi' -> resource_nodecay (nextblock (m_dry jm)) (m_phi jm) phi'.

Lemma inflate_free_resource_decay:
 forall (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs : Z,
             lo <= ofs < hi -> perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),
   resource_decay (nextblock (m_dry jm)) (m_phi jm) (inflate_free jm b lo hi).

Lemma juicy_store_nodecay:
  forall jm m' ch b ofs v
       (H: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable)),
       resource_nodecay (nextblock (m_dry jm)) (m_phi jm) (m_phi (store_juicy_mem jm _ _ _ _ _ H)).

Lemma can_age1_juicy_mem: forall j r,
  age (m_phi j) r -> exists j', age1 j = Some j'.

Lemma can_age_jm:
  forall jm, age1 (m_phi jm) <> None -> exists jm', age jm jm'.

Lemma age_jm_dry: forall {jm jm'}, age jm jm' -> m_dry jm = m_dry jm'.

Lemma age_jm_phi: forall {jm jm'}, age jm jm' -> age (m_phi jm) (m_phi jm').

Lemma age1_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma age1_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma age1_PURE_2 {phi phi' l k P} :
  age1 phi = Some phi' ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma perm_of_res_age x y loc :
  age x y -> perm_of_res (x @ loc) = perm_of_res (y @ loc).

Lemma contents_cohere_age m : hereditary age (contents_cohere m).

Lemma access_cohere_age m : hereditary age (access_cohere m).

Lemma max_access_cohere_age m : hereditary age (max_access_cohere m).

Lemma alloc_cohere_age m : hereditary age (alloc_cohere m).

Definition unage {A} {_:ageable A} x y := age y x.

Lemma unage_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma unage_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma unage_PURE_2 {phi phi' l k P} :
  age1 phi' = Some phi ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma contents_cohere_unage m : hereditary unage (contents_cohere m).

Lemma access_cohere_unage m : hereditary unage (access_cohere m).

Lemma max_access_cohere_unage m : hereditary unage (max_access_cohere m).

Lemma alloc_cohere_unage m : hereditary unage (alloc_cohere m).

Lemma juicy_mem_unage jm' : { jm | age jm jm' }. *)
(* VST.veric.juicy_mem_lemmas:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.
Require Import VST.veric.shares.

Definition juicy_mem_core (j: juicy_mem) : rmap := core (m_phi j).

Definition no_VALs (phi: rmap) := forall loc,
  match phi @ loc with
    | YES _ _ (VAL _) _ => False | _ => True
  end.

Lemma components_join_joins {A} {JA: Join A}{PA: Perm_alg A}{TA: Trip_alg A}: forall a b c d,
   join a b c -> joins a d -> joins b d -> joins c d.

Lemma contents_cohere_join_sub: forall m phi phi',
  contents_cohere m phi -> join_sub phi' phi -> contents_cohere m phi'.

Lemma perm_of_sh_join_sub: forall (sh1 sh2: Share.t) p,

Lemma perm_order'_trans: forall p1 p2 p3,
  perm_order' (Some p1) p2 -> perm_order' (Some p2) p3 -> perm_order' (Some p1) p3.

Lemma rmap_unage_YES: forall phi phi' sh rsh k pp loc, 
  age phi phi' 
  -> phi' @ loc = YES sh rsh k pp 
  -> exists pp', phi @ loc = YES sh rsh k pp'.

Lemma preds_fmap_NoneP_approx: forall pp lev1 lev2,
  preds_fmap (approx lev1) (approx lev1) pp = NoneP ->
  preds_fmap (approx lev2) (approx lev2) pp = NoneP.
Proof.
intros.
destruct pp.
unfold NoneP, approx, compose in *.
simpl in *. unfold compose in *.
inv H. simpl in *.
apply EqdepFacts.eq_sigT_eq_dep in H2.

Lemma oracle_unage:
  forall (jm': juicy_mem) (w: rmap), age w (m_phi jm') ->
       exists jm, age jm jm' /\ m_phi jm = w.

Lemma writable_perm:
  forall b i jm, writable (b,i) (m_phi jm) -> Mem.perm (m_dry jm) b i Cur Writable.

Lemma valid_access_None: forall m ch b b' ofs ofs' p,
  Mem.valid_access m ch b ofs p

Lemma core_load_getN: forall ch v b ofs bl phi m,
  contents_cohere m phi
  -> (core_load' ch (b, ofs) v bl)%pred phi
  -> bl = Mem.getN (size_chunk_nat ch) ofs (PMap.get b (Mem.mem_contents m)).

Lemma core_load_valid: forall ch v b ofs m phi,
  (core_load ch (b, ofs) v)%pred phi
  -> access_cohere m phi
  -> Mem.valid_access m ch b ofs Readable.

Lemma core_load_load': forall ch b ofs v m,
  core_load ch (b, ofs) v (m_phi m) -> Mem.load ch (m_dry m) b ofs = Some v.

Lemma Zminus_lem: forall z1 z2, z1 <= z2 -> nat_of_Z (z2 - z1) = O -> z1=z2.

Lemma nat_of_Z_lem1: forall n z, S n = nat_of_Z z -> n = nat_of_Z (z - 1).

Lemma nat_of_Z_lem2: forall n z1 z2, S n = nat_of_Z (z1 - z2) -> n = nat_of_Z (z1 - z2 - 1).

Lemma nth_getN: forall m b ofs ofs' z,
  ofs <= ofs' < ofs + z
  -> z >= 0
  -> contents_at m (b, ofs')
  = nth (nat_of_Z (ofs' - ofs)) (Mem.getN (nat_of_Z z) ofs (PMap.get b (Mem.mem_contents m))) Undef.

Lemma load_core_load: forall ch b ofs v m,
  Mem.load ch (m_dry m) b ofs = Some v ->

Lemma core_load_load: forall ch b ofs v m,
  (forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi m @ (b,z))) (Some Readable)) ->
  (core_load ch (b, ofs) v (m_phi m) <-> Mem.load ch (m_dry m) b ofs = Some v).

Lemma mapsto_valid_access: forall ch v sh b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Readable.

Lemma mapsto_valid_access_wr: forall ch v sh (wsh: writable0_share sh) b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Writable.

Program Definition mapsto_can_store_definition ch v sh (wsh: writable0_share sh) b ofs jm (v':val)
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)):
  Memory.mem. 

Lemma mapsto_can_store_property: forall (ch:memory_chunk) v sh (wsh: writable0_share sh) b ofs jm v'
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)),
  Mem.store ch (m_dry jm) b ofs v' = 

Lemma mapsto_can_store: forall ch v sh (wsh: writable0_share sh) b ofs jm v',
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> exists m', Mem.store ch (m_dry jm) b ofs v' = Some m'.

Lemma store_outside':
   forall ch m b z v m',
          Mem.store ch m b z v = Some m' ->

Lemma adr_range_zle_zlt : forall  b lo hi ofs,
  adr_range (b,lo) (hi-lo) (b,ofs)
  -> zle lo ofs && zlt ofs hi = true.

Lemma join_top: forall sh2 sh, join Share.top sh2 sh -> sh = Share.top.

Lemma juicy_free_aux_lemma:
 forall phi b lo hi F,
 app_pred (VALspec_range (hi-lo) Share.top (b,lo) * F) phi ->

Lemma juicy_free_lemma:
  forall {j b lo hi m' m1 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Section free.

Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable)
          (phi1 phi2 : rmap) (Hphi1: VALspec_range (hi-lo) Share.top (b,lo) phi1)
          (Hjoin : join phi1 phi2 (m_phi jm)).

Lemma phi2_eq : m_phi (free_juicy_mem _ _ _ _ _ FREE) = phi2.

End free.

Lemma juicy_free_lemma':
  forall {j b lo hi m' m1 m2 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Lemma initial_mem_core: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_core j = core lev.

Lemma writable_writable_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  writable loc (m_phi (initial_mem m1 lev IOK1)) ->
  writable loc (m_phi (initial_mem m2 lev IOK2)).

Lemma readable_eq_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  readable loc (m_phi (initial_mem m1 lev IOK1)) ->
  m_phi (initial_mem m1 lev IOK1) @ loc=m_phi (initial_mem m2 lev IOK2) @ loc.

Lemma necR_m_dry:
  forall jm jm', necR jm jm' -> m_dry jm = m_dry jm'.

Lemma perm_order''_trans p1 p2 p3 :
  perm_order'' p1 p2 ->
  perm_order'' p2 p3 ->
  perm_order'' p1 p3.

Lemma po_join_sub_sh sh1 sh2 :
  join_sub sh2 sh1 ->
  Mem.perm_order'' (perm_of_sh sh1) (perm_of_sh sh2).

Lemma po_join_sub r1 r2 :
  join_sub r2 r1 ->
  Mem.perm_order'' (perm_of_res r1) (perm_of_res r2).

Lemma perm_of_res_lock_not_Freeable:
  forall r,
    perm_order'' (Some Writable) (perm_of_res_lock r).

Definition readable_perm (p: option permission) :
  {perm_order'' p (Some Readable)}+{~perm_order'' p (Some Readable)}.

Definition rebuild_juicy_mem_fmap (jm: juicy_mem) (m': mem) : (AV.address -> resource) :=
 fun loc =>
   match m_phi jm @ loc with
    PURE k pp => PURE k pp
   | NO sh rsh => if readable_perm (access_at m' loc Cur)
                            then YES Tsh (writable_readable writable_share_top)
                                        (VAL (contents_at m' loc)) NoneP
                            else NO sh rsh 
   | YES sh rsh (VAL _) _ => 
                 if readable_perm (access_at m' loc Cur)
                 then YES sh rsh (VAL (contents_at m' loc)) NoneP
                 else NO _ bot_unreadable
   | YES sh rsh _ _ => m_phi jm @ loc
end.

Definition rebuild_juicy_mem_rmap (jm: juicy_mem) (m': mem) :
  {phi : rmap |
  level phi = level jm /\
  resource_at phi = rebuild_juicy_mem_fmap jm m' /\
  ghost_of phi = ghost_of (m_phi jm)}. *)
(* VST.veric.juicy_mem_ops:
Require Import VST.veric.juicy_base.
Import cjoins.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.shares.

Module Type JUICY_MEM_OPS.
Parameter juicy_mem_store
  : juicy_mem -> memory_chunk -> block -> Z -> val -> option juicy_mem.

Parameter juicy_mem_storebytes
  : juicy_mem -> block -> Z -> list memval -> option juicy_mem.

Parameter juicy_mem_alloc
  : juicy_mem -> Z -> Z -> juicy_mem * block.

Axiom juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.
Axiom juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JUICY_MEM_OPS.

Obligation Tactic := Tactics.program_simpl.

Module JuicyMemOps <: JUICY_MEM_OPS.
Program Definition juicy_mem_store j ch b ofs v: option juicy_mem :=
  if valid_access_dec (m_dry j) ch b ofs Writable
    then Some (store_juicy_mem j _ ch b ofs v _)
    else None.

Lemma juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.

Program Definition juicy_mem_storebytes j b ofs bytes: option juicy_mem :=
  if range_perm_dec (m_dry j) b ofs (ofs + Z_of_nat (length bytes)) Cur Writable
    then Some (storebytes_juicy_mem j _ b ofs bytes _)
    else None.

Lemma juicy_mem_storebytes_succeeds: forall j j' b ofs bytes,
  juicy_mem_storebytes j b ofs bytes = Some j' ->
  exists m', storebytes (m_dry j) b ofs bytes = Some m' /\ m' = m_dry j'.

Lemma pshare_sh_bot: forall p, pshare_sh p = Share.bot -> False.

Lemma juicy_mem_alloc_aux1:
  forall jm lo hi m' b, alloc (m_dry jm) lo hi = (m',b) ->
        forall ofs, m_phi jm @ (b,ofs) = NO Share.bot bot_unreadable.

Lemma after_alloc_contents_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
  contents_cohere m'
    (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_max_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 max_access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_alloc_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 alloc_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Definition juicy_mem_alloc (jm: juicy_mem) (lo hi: Z) : juicy_mem * block :=
         (mkJuicyMem (fst (alloc (m_dry jm) lo hi))
                     (after_alloc lo hi (snd (alloc (m_dry jm) lo hi)) (m_phi jm)
                            (juicy_mem_alloc_aux1 _ _ _ _ _ (eq_refl _)))
                     (after_alloc_contents_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_max_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_alloc_cohere _ _ _ _ _ (eq_refl _)),
           snd (alloc (m_dry jm) lo hi)).

Lemma juicy_mem_alloc_at:
  forall jm lo hi jm' b,
     juicy_mem_alloc jm lo hi = (jm',b) ->
     forall loc, m_phi jm' @ loc =
       if adr_range_dec (b, lo) (hi - lo) loc
       then YES Share.top readable_share_top (VAL Undef) NoneP

Lemma juicy_mem_alloc_level:
 forall jm lo hi jm' b,
   juicy_mem_alloc jm lo hi = (jm', b) -> level jm = level jm'.

Lemma juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JuicyMemOps.

Module Abs := JuicyMemOps.
Require Import VST.veric.local.

Inductive AbsPrimcom : relation juicy_mem -> Prop :=
| AbsPrimcom_store : forall ch b ofs v,
  AbsPrimcom (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
| AbsPrimcom_alloc : forall lo hi,
  AbsPrimcom (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
.
Inductive AbsPrimexpr : pfunc juicy_mem val -> Prop :=.

Instance abstract : GenericSemantics juicy_mem AbsPrimcom AbsPrimexpr := {}.

Inductive ConcPrimcom : relation mem -> Prop :=
| ConcPrimcom_store : forall ch b ofs v,
  ConcPrimcom (fun m m' => store ch m b ofs v = Some m')
| ConcPrimcom_alloc : forall lo hi,
  ConcPrimcom (fun m m' => fst (alloc m lo hi) = m')
| ConcPrimcom_free : forall b ofs n,
  ConcPrimcom (fun m m' => free m b ofs n = Some m').

Inductive ConcPrimexpr : pfunc mem val -> Prop :=.

Instance concrete : GenericSemantics mem ConcPrimcom ConcPrimexpr := {}.

Inductive VU : relation juicy_mem -> relation mem -> Prop :=
| VU_store : forall ch b ofs v,
  VU (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
     (fun m m' => store ch m b ofs v = Some m')
| VU_alloc : forall lo hi,
  VU (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
     (fun m m' => fst (alloc m lo hi) = m')
.

Inductive GF : pfunc juicy_mem val -> pfunc mem val -> Prop :=.

Lemma PrimexprErasure : forall g f, GF g f -> False. Proof. inversion 1. Qed.

Lemma PrimcomErasure : forall v u j j' m m',
  VU v u -> m_dry j = m -> v j j' -> u m m' -> m_dry j' = m'.

Lemma PrimcomSafety : forall v u j j' m,
  VU v u -> m_dry j = m -> v j j' -> exists m', u m m'. *)

Require Import VST.veric.res_predicates.
(* VST.veric.res_predicates:
Require Import VST.msl.log_normalize.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.  
Require Import VST.veric.shares. 
Require Import VST.veric.address_conflict.

Import RML. Import R.
Local Open Scope pred.

Program Definition kind_at (k: kind) (l: address) : pred rmap :=
   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.

Program Definition yesat_raw (pp: preds) (k: kind) 
                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=
   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

Obligation Tactic := idtac.

Program Definition yesat (pp: preds) (k: kind) : spec :=
 fun (sh: share) (l: AV.address) (m: rmap) =>

Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

Ltac do_map_arg :=
match goal with |- ?a = ?b =>
  match a with context [map ?x _] =>
    match b with context [map ?y _] => replace y with x; auto end end end.

Lemma yesat_raw_eq_aux:
  forall pp k rsh sh l,
    hereditary age
    (fun phi : rmap =>
     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Lemma yesat_raw_eq: yesat_raw =
  fun pp k rsh sh l =>
  ((exist (hereditary age)
   (fun phi =>
   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))
   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Lemma yesat_eq_aux: 
  forall pp k sh l, 
    hereditary age
    (fun m : rmap =>
      exists rsh, 
     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =
     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Lemma yesat_eq: yesat = fun pp k sh l =>
 exist (hereditary age)
  (fun m => 
  exists rsh, 
   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 
   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))
   (yesat_eq_aux pp k sh l).

Lemma map_compose_approx_succ_e:
  forall A n pp pp',
       map (compose (A:=A) (approx (S n))) pp =
    map (compose (A:=A) (approx (S n))) pp' ->
  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Program Definition noat (l: AV.address) : pred rmap :=

Definition resource_share (r: resource) : option share :=
 match r with
 | YES sh _ _ _ => Some sh
 | NO sh _ => Some sh
 | PURE _ _ => None
 end.

Definition nonlock (r: resource) : Prop :=
 match r with
 | YES _ _ k _ => isVAL k \/ isFUN k
 | NO _ _ => True
 | PURE _ _ => False
 end.

Lemma age1_nonlock: forall phi phi' l,
  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Lemma age1_resource_share: forall phi phi' l,
  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  join sh1 sh2 sh ->
  resource_share r = Some sh.

Lemma resource_share_joins: forall r1 r2 sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  joins r1 r2 ->
  joins sh1 sh2.

Lemma nonlock_join: forall r1 r2 r,
  nonlock r1 ->
  nonlock r2 ->
  join r1 r2 r ->
  nonlock r.

Program Definition nonlockat (l: AV.address): pred rmap :=

Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=
  fun (l: B) m => if S l then P l m else Q l m.

Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,
      (forall (x: A), boxy m (P x)) ->
      (forall x, boxy m (Q x)) ->
      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),
      (forall (x: A), boxy extendM (P x)) ->
      (forall x, boxy extendM (Q x)) ->
      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Definition jam_vacuous:
  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),
  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  {w' | level w' = level w /\ resource_at w' =
       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=
  forall l w, (p l) w = q (w @ l) l (level w).

Definition resource_stable (p: address -> pred rmap) :=
  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.

Lemma is_resource_pred_resource_stable: forall {p},
  (exists q, is_resource_pred p q) -> resource_stable p.

Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l})
  (R_DEC: forall l, {R l} + {~ R l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (exists resp, is_resource_pred r resp) ->
  Ensemble_join Q R P ->
  (forall l, Q l -> p l = q l) ->
  (forall l, R l -> p l = r l) ->
  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  allp (jam P_DEC p noat) && noghost =
  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->
  (exists l, P l /\ Q l) ->
  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Lemma yesat_join_diff:
  forall pp pp' k k' sh sh' l w, k <> k' -> 
                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Lemma yesat_raw_join:
  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),
  nonunit x -> join x y z -> nonunit z.

Lemma yesat_join:
  forall pp k sh1 sh2 sh3 l m1 m2 m3,
   join sh1 sh2 sh3 ->   
   yesat pp k sh1 l m1 ->
   yesat pp k sh2 l m2 ->
   join m1 m2 m3 ->
   yesat pp k sh3 l m3.

Definition spec_parametric (Q: address -> spec) : Prop :=
   forall l l', exists pp, exists ok,
             forall sh m,
           Q l sh l' m = 
            (exists p, exists k, ok k /\ m @ l' = 
                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).

Lemma YES_ext:
  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Definition VALspec : spec :=
       fun (sh: Share.t) (l: address) =>
          allp (jam (eq_dec l)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat) && noghost.

Definition VALspec_range (n: Z) : spec :=
     fun (sh: Share.t) (l: address) =>
          andp (allp (jam (adr_range_dec l n)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat)) noghost.

Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=
  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.

Definition nthbyte (n: Z) (l: list memval) : memval :=
     nth (nat_of_Z n) l Undef.

Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address)  => 
             allp (jam (adr_range_dec l (size_chunk ch)) 
                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')
                           noat).

Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address) =>
           EX bl: list memval, 
               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&
                (allp (jam (adr_range_dec l (size_chunk ch))
                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)
                                    noat)) && noghost.

Lemma address_mapsto_align: forall ch v sh l,
  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Lemma address_mapsto_fun:
  forall ch sh sh' l v v',
          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Definition LKspec lock_size (R: pred rmap) : spec :=
   fun (sh: Share.t) (l: AV.address)  =>
    allp (jam (adr_range_dec l lock_size)
               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')
               noat) && noghost.

Definition TTat (l: address) : pred rmap := TT.

Lemma address_mapsto_old_parametric: forall ch v, 
   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Lemma VALspec_parametric: 
  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Lemma LKspec_parametric lock_size: forall R: pred rmap,
  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Definition val2address (v: val) : option AV.address := 
  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.

Lemma VALspec_readable:
  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.

Lemma address_mapsto_VALspec:
  forall ch v sh l i, 0 <= i < size_chunk ch ->
        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Lemma address_mapsto_exists:
  forall ch v sh (rsh: readable_share sh) loc w0
      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

Lemma VALspec1: VALspec_range 1 = VALspec.

Lemma VALspec_range_exp_address_mapsto:
  forall ch sh l,
    (align_chunk ch | snd l) ->
    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Lemma address_mapsto_VALspec_range:
  forall ch v sh l,
        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Lemma approx_eq_i:
  forall (P Q: pred rmap) (w: rmap),
      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},
         laterR (level w) n' ->
       exists w', laterR w w' /\ n' = level w'.

Lemma VALspec_range_bytes_readable:
  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Lemma VALspec_range_bytes_writable:
  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Lemma yesat_join_sub:
  forall pp k l sh m m',
          join_sub m m' ->
          yesat pp k sh l m ->
         exists sh', yesat pp k sh' l m'.

Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Lemma nonlock_permission_bytes_precise: forall sh p n,
  precise (nonlock_permission_bytes sh p n).

Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=
  EX bl: list memval,
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)
  : pred rmap :=
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.
Hint Resolve VALspec_range_0: normalize.

Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,
  ~ nonunit sh ->
  nonlock_permission_bytes sh p n |-- emp.

Lemma is_resource_pred_YES_VAL sh:
  is_resource_pred
    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')
    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_YES_VAL' sh v:
  is_resource_pred
    (fun l' => yesat NoneP (VAL (v l')) sh l')
    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_nonlock_shareat sh:
  is_resource_pred
    (fun i : address => shareat i sh && nonlockat i)
    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Lemma VALspec_range_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma nonlock_permission_bytes_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma VALspec_range_VALspec:
  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,
  adr_range p1 n1 p2 ->
  n2 > 0 ->
  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Lemma address_mapsto_overlap':
  forall sh ch1 v1 ch2 v2 a1 a2,
     adr_range a1 (size_chunk ch1) a2 ->
     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,
  range_overlap l1 n1 l2 n2 ->
  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,
  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->
  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Lemma nonlock_permission_bytes_overlap:
  forall sh n1 n2 p1 p2,
  nonunit sh ->
  range_overlap p1 n1 p2 n2 ->
  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Lemma address_mapsto_value_cohere':
  forall ch v1 v2 sh1 sh2 a r
 (Hmaps1 : address_mapsto ch v1 sh1 a r)
 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Lemma address_mapsto_value_cohere:
  forall ch v1 v2 sh1 sh2 a,
 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Definition almost_empty rm: Prop:=
  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.

Definition no_locks phi :=
  forall addr sh sh' z z' P,
phi @ addr <> YES sh sh' (LK z z') P. *)

Require Import VST.veric.extend_tc.
(* VST.veric.extend_tc:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.

Local Open Scope pred.

Definition tc_expr {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred:=
  fun rho => denote_tc_assert (typecheck_expr Delta e) rho.

Definition tc_exprlist {CS: compspecs} (Delta: tycontext) (t : list type) (e: list expr) : environ -> mpred :=
      fun rho => denote_tc_assert (typecheck_exprlist Delta t e) rho.

Definition tc_lvalue {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred :=
     fun rho => denote_tc_assert (typecheck_lvalue Delta e) rho.

Definition tc_temp_id {CS: compspecs} (id : positive) (ty : type)
  (Delta : tycontext) (e : expr) : environ -> mpred  :=
     fun rho => denote_tc_assert (typecheck_temp_id id ty Delta e) rho.

Definition tc_expropt {CS: compspecs} Delta (e: option expr) (t: type) : environ -> mpred :=
   match e with None => `!!(t=Tvoid)
                     | Some e' => tc_expr Delta (Ecast e' t)
   end.

Definition tc_temp_id_load id tfrom Delta v : environ -> mpred  :=
fun rho => !! (exists tto, (temp_types Delta) ! id = Some tto
                      /\ tc_val tto (eval_cast tfrom tto (v rho))).

Lemma extend_prop: forall P, boxy extendM (prop P).

Hint Resolve extend_prop.

Lemma extend_tc_temp_id_load :  forall id tfrom Delta v rho, boxy extendM (tc_temp_id_load id tfrom Delta v rho).

Lemma extend_tc_andp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp A B) rho).

Lemma extend_tc_bool:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert (tc_bool A B) rho).

Lemma extend_tc_int_or_ptr_type:
 forall {CS: compspecs} A rho,
   boxy extendM (denote_tc_assert (tc_int_or_ptr_type A) rho).

Lemma extend_tc_Zge:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zge v i) rho).

Lemma extend_tc_Zle:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zle v i) rho).

Lemma extend_tc_iszero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_iszero v) rho).

Lemma extend_valid_pointer':
  forall a b, boxy extendM (valid_pointer' a b).

Lemma extend_andp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (andp P Q).

Lemma extend_orp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (orp P Q).

Lemma extend_tc_test_eq:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_eq e1 e2) rho).

Lemma extend_tc_test_order:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_order e1 e2) rho).

Lemma extend_isCastResultType:
 forall {CS: compspecs} t t' v rho,
   boxy extendM (denote_tc_assert (isCastResultType t t' v) rho).

Lemma extend_tc_temp_id: forall {CS: compspecs} id ty Delta e rho, boxy extendM (tc_temp_id id ty Delta e rho).

Lemma extend_tc_samebase:
  forall {CS: compspecs} e1 e2 rho,
boxy extendM (denote_tc_assert (tc_samebase e1 e2) rho).

Lemma extend_tc_nonzero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_nonzero v) rho).

Lemma extend_tc_nodivover:
 forall {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nodivover e1 e2) rho).

Lemma extend_tc_nosignedover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nosignedover op e1 e2) rho).

Lemma extend_tc_nobinover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nobinover op e1 e2) rho).

Lemma boxy_orp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Lemma extend_tc_orp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_orp A B) rho).

Lemma extend_tc_ilt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_ilt e i) rho).

Lemma extend_tc_llt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_llt e i) rho).

Lemma extend_tc_andp':
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp' A B) rho).

Ltac extend_tc_prover := 
  match goal with
  | |- _ => solve [immediate]
  | |- _ => apply extend_prop
  | |- _ => first
              [ simple apply extend_tc_bool
              | simple apply extend_tc_int_or_ptr_type
              | simple apply extend_tc_andp
              | simple apply extend_tc_andp'
              | simple apply extend_tc_Zge
              | simple apply extend_tc_Zle
              | simple apply extend_tc_iszero
              | simple apply extend_tc_nonzero
              | simple apply extend_tc_nodivover
              | simple apply extend_tc_nobinover
              | simple apply extend_tc_samebase
              | simple apply extend_tc_ilt
              | simple apply extend_tc_llt
              | simple apply extend_isCastResultType
              | simple apply extend_tc_test_eq
              | simple apply extend_tc_test_order]
  | |- boxy _ (denote_tc_assert (if ?A then _ else _) _) => destruct A
  | |- boxy _ (denote_tc_assert match tc_bool ?A _ with _ => _ end _) =>
             destruct A
  | |- boxy _ (denote_tc_assert match ?A with Some _ => _ | None => _ end _) =>
          destruct A
  end.

Lemma extend_tc_binop: forall {CS: compspecs} Delta e1 e2 b t rho, 
  boxy extendM (denote_tc_assert (typecheck_expr Delta e1) rho) ->
  boxy extendM (denote_tc_assert (typecheck_expr Delta e2) rho) ->
  boxy extendM (denote_tc_assert (isBinOpResultType b e1 e2 t) rho).

Lemma extend_tc_expr: forall {CS: compspecs} Delta e rho, boxy extendM (tc_expr Delta e rho)
 with extend_tc_lvalue: forall {CS: compspecs} Delta e rho, boxy extendM (tc_lvalue Delta e rho).

Lemma extend_tc_exprlist: forall {CS: compspecs} Delta t e rho, boxy extendM (tc_exprlist Delta t e rho).

Lemma extend_tc_expropt: forall {CS: compspecs} Delta e t rho, boxy extendM (tc_expropt Delta e t rho).

Hint Resolve extend_tc_expr extend_tc_temp_id extend_tc_temp_id_load extend_tc_exprlist extend_tc_expropt extend_tc_lvalue.
Hint Resolve (@extendM_refl rmap _ _ _ _ _). *)

Require Import VST.veric.Clight_seplog.
(* VST.veric.Clight_seplog:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.res_predicates.

Require Import VST.veric.mpred.
Require Import VST.veric.address_conflict.
Require Export VST.veric.shares.

Require Export VST.veric.seplog.

Require Export VST.veric.mapsto_memory_block.

Local Open Scope pred.

Require Import compcert.cfrontend.Clight. 
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.
Require Export VST.veric.Clight_mapsto_memory_block.

Local Open Scope pred.

Definition expr_true {CS: compspecs} e := lift1 (typed_true (typeof e)) (eval_expr e).

Definition expr_false {CS: compspecs} e := lift1 (typed_false (typeof e)) (eval_expr e).

Definition eval_lvar (id: ident) (ty: type) (rho: environ) :=
 match Map.get (ve_of rho) id with
| Some (b, ty') => if eqb_type ty ty' then Vptr b Ptrofs.zero else Vundef
| None => Vundef
end.

Definition var_block (sh: Share.t) {cs: compspecs} (idt: ident * type) (rho: environ): mpred :=
  !! (sizeof (snd idt) <= Ptrofs.max_unsigned) &&
  (memory_block sh (sizeof (snd idt))) (eval_lvar (fst idt) (snd idt) rho).

Definition stackframe_of {cs: compspecs} (f: Clight.function) : assert :=
  fold_right (fun P Q rho => P rho * Q rho) (fun rho => emp) (map (fun idt => var_block Share.top idt) (Clight.fn_vars f)).

Lemma stackframe_of_eq : forall {cs: compspecs}, stackframe_of =
        fun f rho => fold_right sepcon emp (map (fun idt => var_block Share.top idt rho) (Clight.fn_vars f)).

Lemma  subst_derives:
 forall a v P Q, (forall rho, P rho |-- Q rho) -> forall rho, subst a v P rho |-- subst a v Q rho.

Definition tc_formals (formals: list (ident * type)) : environ -> Prop :=
     fun rho => tc_vals (map (@snd _ _) formals) (map (fun xt => (eval_id (fst xt) rho)) formals).

Program Definition close_precondition (params vars: list (ident * type)) (P: environ -> pred rmap) (rho: environ) : pred rmap :=
 fun phi =>
   exists ve', exists te',
   (forall i, In i (map (@fst _ _) params) -> Map.get te' i = Map.get (te_of rho) i) /\

Lemma close_precondition_i:
  forall params vars P rho,
  P rho |-- close_precondition params vars P rho.

Definition precondition_closed (f: function) {A: TypeTree}
  (P: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred) : Prop :=
 forall ts x,
  closed_wrt_vars (not_a_param (fn_params f)) (P ts x) /\
  closed_wrt_lvars (is_a_local (fn_vars f)) (P ts x).

Lemma close_precondition_e:
   forall f (A: TypeTree) (P:  forall ts, dependent_type_functor_rec ts (AssertTT A) mpred),
    precondition_closed f P ->
  forall ts x rho,
   close_precondition (fn_params f) (fn_vars f) (P ts x) rho |-- P ts x rho.

Definition bind_args (formals vars: list (ident * type)) (P: environ -> pred rmap) : assert :=
          fun rho => !! tc_formals formals rho && close_precondition formals vars P rho.

Definition ret_temp : ident := 1%positive.

Definition get_result1 (ret: ident) (rho: environ) : environ :=
   make_args (ret_temp::nil) (eval_id ret rho :: nil) rho.

Definition get_result (ret: option ident) : environ -> environ :=
 match ret with
 | None => make_args nil nil
 | Some x => get_result1 x
 end.

Definition bind_ret (vl: option val) (t: type) (Q: assert) : assert :=
     match vl, t with
     | None, Tvoid => fun rho => Q (make_args nil nil rho)
     | Some v, _ => fun rho => !! (tc_val t v) &&
                               Q (make_args (ret_temp::nil) (v::nil) rho)
     | _, _ => fun rho => FF
     end.

Definition funassert (Delta: tycontext): assert := funspecs_assert (glob_specs Delta).

Definition proj_ret_assert (Q: ret_assert) (ek: exitkind) (vl: option val) : assert :=
 match ek with
 | EK_normal => RA_normal Q
 | EK_break => RA_break Q
 | EK_continue => RA_continue Q
 | EK_return => RA_return Q vl
 end.

Definition overridePost  (Q: assert)  (R: ret_assert) :=
 match R with 
  {| RA_normal := _; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Q; RA_break := b; RA_continue := c; RA_return := r |}
 end.

Definition existential_ret_assert {A: Type} (R: A -> ret_assert) :=
  {| RA_normal := fun rho => EX x:A, (R x).(RA_normal) rho;
     RA_break := fun rho => EX x:A, (R x).(RA_break) rho;
     RA_continue := fun rho => EX x:A, (R x).(RA_continue) rho;
     RA_return := fun vl rho => EX x:A, (R x).(RA_return) vl rho
   |}.

Definition normal_ret_assert (Q: assert) : ret_assert :=
  {| RA_normal := Q; RA_break := seplog.FF; RA_continue := seplog.FF; RA_return := fun _ => seplog.FF |}.

Definition frame_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho * F rho; 
     RA_break := fun rho => b rho * F rho; 
     RA_continue := fun rho => c rho * F rho;
     RA_return := fun vl rho => r vl rho * F rho |}
 end.

Definition conj_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho && F rho; 
     RA_break := fun rho => b rho && F rho; 
     RA_continue := fun rho => c rho && F rho;
     RA_return := fun vl rho => r vl rho && F rho |}
 end.

Definition switch_ret_assert (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := seplog.FF; 
     RA_break := n; 
     RA_continue := c;
     RA_return := r |}
 end.

Require Import VST.msl.normalize.

Lemma normal_ret_assert_derives:
 forall P Q rho,
  P rho |-- Q rho ->
  forall ek vl, proj_ret_assert (normal_ret_assert P) ek vl rho 
            |-- proj_ret_assert (normal_ret_assert Q) ek vl rho.
Hint Resolve normal_ret_assert_derives.

Lemma normal_ret_assert_FF:
  forall ek vl rho, proj_ret_assert (normal_ret_assert (fun rho => FF)) ek vl rho = FF.

Lemma frame_normal:
  forall P F,
   frame_ret_assert (normal_ret_assert P) F = normal_ret_assert (fun rho => P rho * F rho).

Lemma proj_frame:
  forall P F ek vl,
    proj_ret_assert (frame_ret_assert P F) ek vl = fun rho => F rho * proj_ret_assert P ek vl rho.

Lemma proj_conj:
  forall P F ek vl,
    proj_ret_assert (conj_ret_assert P F) ek vl = fun rho => F rho && proj_ret_assert P ek vl rho.

Definition loop1_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n; 
     RA_continue := Inv;
     RA_return := r |}
 end.

Definition loop2_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n;
     RA_continue := seplog.FF;
     RA_return := r |}
 end.

Lemma frame_for1:
  forall Q R F,
   frame_ret_assert (loop1_ret_assert Q R) F =
   loop1_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma frame_loop1:
  forall Q R F,
   frame_ret_assert (loop2_ret_assert Q R) F =
   loop2_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma overridePost_normal:
  forall P Q, overridePost P (normal_ret_assert Q) = normal_ret_assert P.

Hint Rewrite normal_ret_assert_FF frame_normal frame_for1 frame_loop1
                 overridePost_normal: normalize.

Definition function_body_ret_assert (ret: type) (Q: assert) : ret_assert :=
 {| RA_normal := seplog.FF;
    RA_break := seplog.FF; 
    RA_continue := seplog.FF;
    RA_return := fun vl => bind_ret vl ret Q |}.

Lemma same_glob_funassert:
  forall Delta1 Delta2,
     (forall id, (glob_specs Delta1) ! id = (glob_specs Delta2) ! id) ->
              funassert Delta1 = funassert Delta2. *)

Require Import VST.veric.Clight_assert_lemmas.
(* VST.veric.Clight_assert_lemmas:
Require Export VST.veric.base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_seplog.
Require Export VST.veric.assert_lemmas.

Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.extend_tc.

Local Open Scope pred.

Lemma corable_funassert:
  forall G rho, corable (funassert G rho).

Hint Resolve corable_funassert.

Definition allp_fun_id (Delta : tycontext) (rho : environ): pred rmap :=
(ALL id : ident ,
 (ALL fs : funspec ,
  !! ((glob_specs Delta) ! id = Some fs) -->
  (EX b : block, !! (Map.get (ge_of rho) id = Some b) && func_at fs (b, 0)))).

Lemma corable_allp_fun_id: forall Delta rho,
  corable (allp_fun_id Delta rho).
  
Lemma allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  allp_fun_id Delta' rho |-- allp_fun_id Delta rho.

Lemma funassert_allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  funassert Delta' rho |-- allp_fun_id Delta rho.

Lemma prop_derives {A}{H: ageable A}:
 forall (P Q: Prop), (P -> Q) -> prop P |-- prop Q.

Section STABILITY.
Variable CS: compspecs.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma tc_bool_e_sub: forall b b' err rho phi,
  (b = true -> b' = true) ->
  denote_tc_assert (tc_bool b err) rho phi ->
  denote_tc_assert (tc_bool b' err) rho phi.

Lemma tc_bool_e_i:
  forall b c rho phi,
   b = true ->
  app_pred (denote_tc_assert (tc_bool b c) rho) phi.

Lemma tc_expr_lvalue_sub: forall rho,
  typecheck_environ Delta rho ->
  forall e,
    tc_expr Delta e rho |-- tc_expr Delta' e rho /\
    tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_expr_sub:
    forall e rho, typecheck_environ Delta rho -> tc_expr Delta e rho |-- tc_expr Delta' e rho.

Lemma tc_lvalue_sub:
    forall e rho, typecheck_environ Delta rho -> tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_temp_id_sub:
    forall id t e rho,
   tc_temp_id id t Delta e rho |-- tc_temp_id id t Delta' e rho.

Lemma tc_temp_id_load_sub:
   forall id t v rho,
   tc_temp_id_load id t Delta v rho |--    tc_temp_id_load id t Delta' v rho.

Lemma tc_exprlist_sub:
  forall e t rho, typecheck_environ Delta rho -> tc_exprlist Delta e t rho |-- tc_exprlist Delta' e t rho.

Definition typeof_temp (Delta: tycontext) (id: ident) : option type :=
 match (temp_types Delta) ! id with
 | Some t => Some t
 | None => None
 end.

Lemma typeof_temp_sub:
   forall i t,
    typeof_temp Delta i = Some t ->
    typeof_temp Delta' i = Some t.

End STABILITY. *)

Require Import VST.veric.Clight_new.
(* VST.veric.Clight_new:
Require Import VST.sepcomp.semantics.
Require Import VST.veric.Clight_base.
Require Import VST.veric.Clight_lemmas.
Require compcert.common.Globalenvs.

Inductive cont': Type :=
  | Kseq: statement -> cont'       
  | Kloop1: statement -> statement -> cont'
  | Kloop2: statement -> statement  -> cont'
  | Kswitch: cont'       
  | Kcall: forall (l: option ident),                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont'.

Definition cont := list cont'.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k => call_cont k
  | Kloop1 _ _ :: k => call_cont k
  | Kloop2 _ _ :: k => call_cont k
  | Kswitch :: k => call_cont k
  | _ => k
  end.

Fixpoint current_function (k: cont) : option function :=
 match k with
  | Kseq s :: k => current_function k
  | Kloop1 _ _ :: k => current_function k
  | Kloop2 _ _:: k =>current_function k
  | Kswitch :: k => current_function k
  | Kcall _ f _ _ :: _ => Some f
  | _ => None
  end.

Fixpoint continue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => continue_cont k'
  | Kloop1 s1 s2 :: k' => Kseq s2 :: Kloop2 s1 s2 :: k'
  | Kswitch :: k' => continue_cont k'
  | _ => nil 
  end.

Lemma call_cont_nonnil: forall k f, current_function k = Some f -> call_cont k <> nil.

Fixpoint precontinue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => precontinue_cont k'
  | Kloop1 _ _ :: _ => k
  | Kswitch :: k' => precontinue_cont k'
  | _ => nil 
  end.

Fixpoint break_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => break_cont k'
  | Kloop1 _ _ :: k' => k'
  | Kloop2 _ _ :: k' => k'
  | Kswitch :: k' => k'
  | _ =>  nil 
  end.

Inductive corestate :=
 | State: forall (ve: env) (te: temp_env) (k: cont), corestate
 | ExtCall: forall (ef: external_function) (args: list val)
                   (lid: option ident) (ve: env) (te: temp_env) (k: cont),
                corestate.

Fixpoint strip_skip (k: cont) : cont :=
 match k with Kseq Sskip :: k' => strip_skip k' | _ => k end.

Definition cl_at_external (c: corestate) : option (external_function * list val) :=
  match c with
  | State _ _ k => None
  | ExtCall ef args lid ve te k => Some (ef, args)
 end.

Definition cl_after_external (vret: option val) (c: corestate) : option corestate :=
  match vret, c with
  | Some v, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id v te) k)
  | None, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id Vundef te) k)
  | Some v, ExtCall ef args None ve te k => Some (State ve te k)
  | None, ExtCall ef args None ve te k => Some (State ve te k)
  | _, _ => None
  end.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option cont :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 :: k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 a3 =>
      match find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 a3 :: k) with
      | Some sk => Some sk
      | None => find_label lbl a3 (Kloop2 s1 a3 :: k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch :: k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(Kseq s' :: k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option cont :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') :: k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Inductive cl_step (ge: Clight.genv): forall (q: corestate) (m: mem) (q': corestate) (m': mem), Prop :=

  | step_assign: forall ve te k m a1 a2 loc ofs v2 v m',
     type_is_volatile (typeof a1) = false ->
      Clight.eval_lvalue ge ve te m a1 loc ofs ->
      Clight.eval_expr ge ve te m a2 v2 ->
      Cop.sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      Clight.assign_loc ge (typeof a1) m loc ofs v m' ->
      cl_step ge (State ve te (Kseq (Sassign a1 a2):: k)) m (State ve te k) m'

  | step_set:   forall ve te k m id a v,
      Clight.eval_expr ge ve te m a v ->
      cl_step ge (State ve te (Kseq (Sset id a) :: k)) m (State ve (PTree.set id v te) k) m

  | step_call_internal:   forall ve te k m optid a al tyargs tyres cc vf vargs f m1 ve' le',
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (Internal f) ->
      type_of_function f = Tfunction tyargs tyres cc ->
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_temps)) ->
      forall (NRV: list_norepet (var_names f.(fn_vars))),
      Clight.alloc_variables ge empty_env m (f.(fn_vars)) ve' m1 ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some
le' ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m
                   (State ve' le' (Kseq f.(fn_body) :: Kseq (Sreturn None) :: Kcall optid f ve te :: k)) m1

  | step_call_external:   forall ve te k m optid a al tyargs tyres cc vf vargs ef,
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (External ef tyargs tyres cc) ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m (ExtCall ef vargs optid ve te k) m

  | step_seq: forall ve te k m s1 s2 st' m',
          cl_step ge (State ve te (Kseq s1 :: Kseq s2 :: k)) m st' m' ->
          cl_step ge (State ve te (Kseq (Ssequence s1 s2) :: k)) m st' m'

  | step_skip: forall ve te k m st' m',
          cl_step ge (State ve te k) m st' m' ->
          cl_step ge (State ve te (Kseq Sskip :: k)) m st' m'

  | step_continue: forall ve te k m st' m',
           cl_step ge (State ve te (continue_cont k)) m st' m' ->
           cl_step ge (State ve te (Kseq Scontinue :: k)) m st' m'

  | step_break: forall ve te k m st' m',
                   cl_step ge (State ve te (break_cont k)) m st' m' ->
                   cl_step ge (State ve te (Kseq Sbreak :: k)) m st' m'

  | step_ifthenelse:  forall ve te k m a s1 s2 v1 b,
      Clight.eval_expr ge ve te m a v1 ->
      Cop.bool_val v1 (typeof a) m = Some b ->
      cl_step ge (State ve te (Kseq (Sifthenelse a s1 s2) :: k)) m (State ve te  (Kseq (if b then s1 else s2) :: k)) m

  | step_for: forall ve te k m s1 s2,
      cl_step ge (State ve te (Kseq (Sloop s1 s2) :: k)) m
              (State ve te (Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: k)) m

  | step_loop2: forall ve te k m a3 s,
      cl_step ge (State ve te (Kloop2 s a3 :: k)) m
             (State ve te (Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: k)) m

  | step_return: forall f ve te optexp optid k m v' m' ve' te' te'' k',
      call_cont k = Kcall optid f ve' te' :: k' ->
      Mem.free_list m (Clight.blocks_of_env ge ve) = Some m' ->
      match optexp with None => v' = Vundef
                                  | Some a => exists v, Clight.eval_expr ge ve te m a v
                                     /\ Cop.sem_cast v (typeof a) f.(fn_return) m = Some v'
                            end ->
      match optid with None => True /\ te''=te'
                                | Some id => True /\ te'' = PTree.set id v' te'
      end ->
      cl_step ge (State ve te (Kseq (Sreturn optexp) :: k)) m (State ve' te'' k') m'

  | step_switch: forall ve te k m a sl v n,
      Clight.eval_expr ge ve te m a v ->
      Cop.sem_switch_arg v (typeof a) = Some n ->
      cl_step ge (State ve te (Kseq (Sswitch a sl) :: k)) m
              (State ve te (Kseq (seq_of_labeled_statement (select_switch n sl)) :: Kswitch :: k)) m

  | step_label: forall ve te k m lbl s st' m',
       cl_step ge (State ve te (Kseq s :: k)) m st' m' ->
       cl_step ge (State ve te (Kseq (Slabel lbl s) :: k)) m st' m'

  | step_goto: forall f ve te k m lbl k'
                     
      (CUR: current_function k = Some f),
      find_label lbl f.(fn_body) (Kseq (Sreturn None) :: (call_cont k)) = Some k' ->
      cl_step ge (State ve te (Kseq (Sgoto lbl) :: k)) m (State ve te k') m.

Definition vret2v (vret: list val) : val :=
  match vret with v::nil => v | _ => Vundef end.

Definition cl_halted (c: corestate) : option val := None.

Definition empty_function : function := mkfunction Tvoid cc_default nil nil nil Sskip.

Fixpoint temp_bindings (i: positive) (vl: list val) :=
 match vl with
 | nil => PTree.empty val
 | v::vl' => PTree.set i v (temp_bindings (i+1)%positive vl')
 end.

Definition Tint32s := Tint I32 Signed noattr.
Definition true_expr : Clight.expr := Clight.Econst_int Int.one Tint32s.

Fixpoint typed_params (i: positive) (n: nat) : list (ident * type) :=
  match n with
  | O => nil
  | S n' => (i, Tint32s) :: typed_params (i+1)%positive n'
  end.

Fixpoint params_of_types (i: positive) (l : list type) : list (ident * type) :=
  match l with
  | nil => nil
  | t :: l => (i, t) :: params_of_types (i+1)%positive l
  end.

Fixpoint typelist2list (tl: typelist) : list type :=
  match tl with
  | Tcons t r => t::typelist2list r
  | Tnil => nil
  end.

Definition params_of_fundef (f: fundef) : list type :=
  match f with
  | Internal {| fn_params := fn_params |} => map snd fn_params
  | External _ t _ _ => typelist2list t
  end.

Inductive val_casted_list: list val -> typelist -> Prop :=
  | vcl_nil:
      val_casted_list nil Tnil
  | vcl_cons: forall v1 vl ty1 tyl,
      val_casted v1 ty1 -> val_casted_list vl tyl ->
      val_casted_list (v1 :: vl) (Tcons  ty1 tyl).

Definition cl_initial_core (ge: genv) (v: val) (args: list val) (q: corestate) : Prop :=
  match v with
    Vptr b i =>
    if Ptrofs.eq_dec i Ptrofs.zero then
      match Genv.find_funct_ptr ge b with
        Some f =>
        match type_of_fundef f with Tfunction targs _ c =>
        c = cc_default /\
        val_casted_list args targs /\
        Val.has_type_list args (Ctypes.typlist_of_typelist targs) /\
        q = State empty_env (temp_bindings 1%positive (v::args))
                    (Kseq (Scall None
                                 (Etempvar 1%positive (type_of_fundef f))
                                 (map (fun x => Etempvar (fst x) (snd x))
                                      (params_of_types 2%positive
                                                       (params_of_fundef f)))) ::
                          Kseq (Sloop Sskip Sskip) :: nil)
        | _ => False end
      | _ => False end
    else False
  | _ => False
end.

Lemma cl_corestep_not_at_external:
  forall ge m q m' q', cl_step ge q m q' m' -> cl_at_external q = None.

Lemma cl_corestep_not_halted :
  forall ge m q m' q', cl_step ge q m q' m' -> cl_halted q = None.

Lemma cl_after_at_external_excl :
  forall retv q q', cl_after_external retv q = Some q' -> cl_at_external q' = None.

Definition arg_well_formed args m0:=
  Val.inject_list (Mem.flat_inj (Mem.nextblock m0)) args args.

Program Definition cl_core_sem  (ge: genv):
  @CoreSemantics corestate mem :=
  @Build_CoreSemantics _ _
    
    (fun _ m c m' v args => cl_initial_core ge v args c /\ arg_well_formed args m /\ m' = m)
    (fun c _ => cl_at_external c)
    (fun ret c _ => cl_after_external ret c)
    (fun c _ =>  False )
    (cl_step ge)
    _
    (cl_corestep_not_at_external ge).

Lemma cl_corestep_fun: forall ge m q m1 q1 m2 q2,
    cl_step ge q m q1 m1 ->
    cl_step ge q m q2 m2 ->
    (q1,m1)=(q2,m2). *)

Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)

Require Import VST.veric.expr2.
(* VST.veric.expr2:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_lemmas.
Require Export VST.veric.expr.

Require Import VST.veric.mpred.

Lemma neutral_cast_lemma: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> eval_cast t1 t2 v = v.

Lemma neutral_cast_subsumption: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Lemma neutral_cast_subsumption': forall t1 t2 v,
  is_neutral_cast (implicit_deref t1) t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Definition denote_tc_iszero v : mpred :=
         match v with
         | Vint i => prop (is_true (Int.eq i Int.zero))
         | Vlong i => prop (is_true (Int64.eq i Int64.zero))
         | _ => FF
         end.

Definition denote_tc_nonzero v : mpred :=
         match v with
         | Vint i => prop (i <> Int.zero)
         | Vlong i =>prop (i <> Int64.zero)
         | _ => FF end.

Definition denote_tc_igt i v : mpred :=
     match v with
     | Vint i1 => prop (Int.unsigned i1 < Int.unsigned i)
     | _ => FF
     end.

Definition denote_tc_lgt l v : mpred :=
     match v with
     | Vlong l1 => prop (Int64.unsigned l1 < Int64.unsigned l)
     | _ => FF
     end.

Definition Zoffloat (f:float): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition Zofsingle (f: float32): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition denote_tc_Zge z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition denote_tc_Zle z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition sameblock v1 v2 : bool :=
         match v1, v2 with
          | Vptr b1 _, Vptr b2 _ => peq b1 b2
          | _, _ => false
         end.

Definition denote_tc_samebase v1 v2 : mpred :=
       prop (is_true (sameblock v1 v2)).

Definition denote_tc_nodivover v1 v2 : mpred :=
match v1, v2 with
          | Vint n1, Vint n2 => prop (~(n1 = Int.repr Int.min_signed /\ n2 = Int.mone))
          | Vlong n1, Vlong n2 => prop (~(n1 = Int64.repr Int64.min_signed /\ n2 = Int64.mone))
          | Vint n1, Vlong n2 => TT
          | Vlong n1, Vint n2 => prop (~ (n1 = Int64.repr Int64.min_signed  /\ n2 = Int.mone))
          | _ , _ => FF
        end.

Definition denote_tc_nosignedover (op: Z->Z->Z) v1 v2 : mpred :=
 match v1,v2 with
 | Vint n1, Vint n2 => 
   prop (Int.min_signed <= op (Int.signed n1) (Int.signed n2) <= Int.max_signed)
 | Vlong n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vint n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vlong n1, Vint n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int.signed n2) <= Int64.max_signed)
 | _, _ => FF
 end.

Definition denote_tc_initialized id ty rho : mpred :=
    prop (exists v, Map.get (te_of rho) id = Some v
               /\ tc_val ty v).

Definition denote_tc_isptr v : mpred :=
  prop (isptr v).

Definition denote_tc_isint v : mpred :=
  prop (is_int I32 Signed v).

Definition denote_tc_islong v : mpred :=
  prop (is_long v).

Definition test_eq_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else (andp (valid_pointer v1) (valid_pointer v2)).

Definition test_order_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else FF.

Definition denote_tc_test_eq v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => 
     if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => 
     if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vint i, Vptr _ _ =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v2)
 | Vlong i, Vptr _ _ =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v2) else FF
 | Vptr _ _, Vint i =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v1)
 | Vptr _ _, Vlong i =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v1) else FF
 | Vptr _ _, Vptr _ _ =>
      test_eq_ptrs v1 v2
 | _, _ => FF
 end.

Definition denote_tc_test_order v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vptr _ _, Vptr _ _ =>
      test_order_ptrs v1 v2
 | _, _ => FF
 end.

Definition typecheck_error (e: tc_error) : Prop := False.

Fixpoint denote_tc_assert {CS: compspecs}(a: tc_assert) : environ -> mpred :=
  match a with
  | tc_FF msg => `(prop (typecheck_error msg))
  | tc_TT => `TT
  | tc_andp' b c => `andp (denote_tc_assert b) (denote_tc_assert c)
  | tc_orp' b c => `orp (denote_tc_assert b) (denote_tc_assert c)
  | tc_nonzero' e => `denote_tc_nonzero (eval_expr e)
  | tc_isptr e => `denote_tc_isptr (eval_expr e)
  | tc_isint e => `denote_tc_isint (eval_expr e)
  | tc_islong e => `denote_tc_islong (eval_expr e)
  | tc_test_eq' e1 e2 => `denote_tc_test_eq (eval_expr e1) (eval_expr e2)
  | tc_test_order' e1 e2 => `denote_tc_test_order (eval_expr e1) (eval_expr e2)
  | tc_ilt' e i => `(denote_tc_igt i) (eval_expr e)
  | tc_llt' e l => `(denote_tc_lgt l) (eval_expr e)
  | tc_Zle e z => `(denote_tc_Zge z) (eval_expr e)
  | tc_Zge e z => `(denote_tc_Zle z) (eval_expr e)
  | tc_samebase e1 e2 => `denote_tc_samebase (eval_expr e1) (eval_expr e2)
  | tc_nodivover' v1 v2 => `denote_tc_nodivover (eval_expr v1) (eval_expr v2)
  | tc_initialized id ty => denote_tc_initialized id ty
  | tc_iszero' e => `denote_tc_iszero (eval_expr e)
  | tc_nosignedover op e1 e2 => `(denote_tc_nosignedover op) (eval_expr e1) (eval_expr e2)
 end.

Lemma and_False: forall x, (x /\ False) = False.

Lemma and_True: forall x, (x /\ True) = x.

Lemma True_and: forall x, (True /\ x) = x.

Lemma False_and: forall x, (False /\ x) = False.

Lemma tc_andp_sound : forall {CS: compspecs} a1 a2 rho m,
    denote_tc_assert  (tc_andp a1 a2) rho m <->
    denote_tc_assert  (tc_andp' a1 a2) rho m.

Lemma denote_tc_assert_andp:
  forall {CS: compspecs} a b rho, denote_tc_assert (tc_andp a b) rho =
             andp (denote_tc_assert a rho) (denote_tc_assert b rho).

Lemma neutral_isCastResultType:
  forall {CS: compspecs} t t' v rho,
   is_neutral_cast t' t = true ->
   forall m, denote_tc_assert (isCastResultType t' t v) rho m.

Lemma is_true_e: forall b, is_true b -> b=true.

Lemma tc_bool_e: forall {CS: compspecs} b a rho m,
  app_pred (denote_tc_assert (tc_bool b a) rho) m ->
  b = true. *)

Require Import VST.veric.expr_lemmas.
(* VST.veric.expr_lemmas:
Require Import VST.veric.Clight_base.
Require Import VST.msl.msl_standard.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Export VST.veric.environ_lemmas.
Require Import VST.veric.binop_lemmas2.
Require Import VST.veric.binop_lemmas3.
Require Import VST.veric.binop_lemmas.
Require Import VST.veric.binop_lemmas4.
Require Import VST.veric.expr_lemmas2.
Require Export VST.veric.expr_lemmas3.
Require Export VST.veric.expr_lemmas4.
Require Import VST.veric.juicy_mem.
Import Cop.
Import Cop2.
Import Clight_Cop2.

Lemma tc_bool_val:
  forall v t,
       tc_val t v ->
       bool_type t = true ->
      exists b, strict_bool_val v t = Some b.

Lemma bool_val_strict: forall t v b, tc_val t v -> bool_type t = true -> bool_val t v = Some b ->
  strict_bool_val v t = Some b.

Lemma bool_val_Cop: forall t v m b b', bool_val t v = Some b -> Cop.bool_val v t m = Some b' ->

Lemma map_ptree_rel : forall id v te, Map.set id v (make_tenv te) = make_tenv (PTree.set id v te).

Lemma cast_exists : forall {CS: compspecs} Delta e2 t rho phi
(TC: typecheck_environ Delta rho),
denote_tc_assert (typecheck_expr Delta e2) rho phi ->
denote_tc_assert (isCastResultType (typeof e2) t e2)
  rho phi ->
sem_cast (typeof e2) t (eval_expr e2 rho)  =
Some (force_val (sem_cast (typeof e2) t (eval_expr e2 rho))).

Definition func_tycontext_t_denote :=
forall p t id ty ,  list_norepet (map fst p ++ map fst t ) ->
((make_tycontext_t p t) ! id = Some ty <-> (In (id,ty) p \/ In (id,ty) t)).

Definition func_tycontext_v_denote :=
forall v id ty, list_norepet (map fst v) ->
((make_tycontext_v v) ! id = Some ty <-> In (id,ty) v).

Lemma func_tycontext_v_sound : func_tycontext_v_denote.

Lemma set_inside : forall i0 t1 t p id,
list_disjoint (map fst p) (i0 :: map fst t) ->
(fold_right
          (fun param : ident * type =>
           PTree.set (fst param) (snd param, true))

Lemma func_tycontext_t_sound : func_tycontext_t_denote.

Definition cast_no_val_change (from: type)(to:type) : bool :=
match from, to with
| Tint _ _ _, Tint I32 _ _ => true
| Tpointer _ _, Tpointer _ _ => 
    eqb_type from to || 
    negb (eqb_type from int_or_ptr_type) && 
    negb (eqb_type to int_or_ptr_type)
| Tfloat F64 _ , Tfloat F64 _ => true
| Tfloat F32 _ , Tfloat F32 _ => true
| _, _ => false
end.

Lemma cast_no_change : forall v from to m,
tc_val from v ->
is_true (cast_no_val_change from to) ->
Cop.sem_cast v from to m = Some v.

Lemma tc_exprlist_length : forall {CS: compspecs} Delta tl el rho phi,
denote_tc_assert (typecheck_exprlist Delta tl el) rho phi ->
length tl = length el.

Lemma neutral_cast_tc_val : forall {CS: compspecs} e t rho phi Delta,
true = is_neutral_cast (implicit_deref (typeof e)) t ->
denote_tc_assert (isCastResultType (implicit_deref (typeof e)) t  e) rho phi ->
denote_tc_assert (typecheck_expr Delta e) rho phi ->
typecheck_environ Delta rho ->
tc_val t (eval_expr e rho).

Opaque Int.repr.

Definition typecheck_tid_ptr_compare
Delta id :=
match (temp_types Delta) ! id with
| Some t => is_int_type t
| None => false
end.

Lemma typecheck_tid_ptr_compare_sub:
   forall Delta Delta',
    tycontext_sub Delta Delta' ->
    forall id, typecheck_tid_ptr_compare Delta id = true ->
                typecheck_tid_ptr_compare Delta' id = true.

Lemma int64_eq_e:
 forall i j, Int64.eq i j = true -> i=j.

Lemma tc_val_sem_cast:
  forall {CS: compspecs} t2 e2 rho phi Delta,
      typecheck_environ Delta rho ->
      denote_tc_assert (typecheck_expr Delta e2) rho phi ->
      denote_tc_assert (isCastResultType (typeof e2) t2  e2) rho phi ->
      tc_val t2 (force_val (sem_cast (typeof e2) t2 (eval_expr e2 rho))). *)

Require Import VST.veric.Clight_lemmas.
(* VST.veric.Clight_lemmas:
Require Import VST.veric.Clight_base.
Require Import compcert.cfrontend.Clight.

Definition var_name (V: Type) (bdec: ident * globvar V) : ident :=
   fst bdec.

Definition no_dups (F V: Type) (fdecs: list (ident * F)) (bdecs: list (ident * globvar V)) : Prop :=
  list_norepet (map (@fst ident F) fdecs ++ map (@var_name V) bdecs).
Arguments no_dups [F V] _ _.

Lemma no_dups_inv:
  forall  (A V: Type) id f fdecs bdecs,
    no_dups ((id,f)::fdecs) bdecs ->
    no_dups fdecs bdecs /\
     ~ In id (map (@fst ident A) fdecs) /\
     ~ In id (map (@var_name V) bdecs).
Arguments no_dups_inv [A V] _ _ _ _ _.

Lemma of_bool_Int_eq_e:
  forall i j, Val.of_bool (Int.eq i j) = Vtrue -> i = j.

Lemma eq_block_lem:
    forall (A: Set) a (b: A) c, (if eq_block a a then b else c) = b.

Lemma signed_zero: Int.signed Int.zero = 0.

Lemma equiv_e1 : forall A B: Prop, A=B -> A -> B.
Arguments equiv_e1 [A B] _ _.

Lemma deref_loc_fun: forall {ty m b z v v'},
   Clight.deref_loc ty m b z v -> Clight.deref_loc ty m b z v' -> v=v'.

Lemma eval_expr_lvalue_fun:
  forall ge e le m,
    (forall a v v', Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v') /\

Lemma eval_expr_fun:   forall {ge e le m a v v'},
    Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v'.

Lemma eval_exprlist_fun:   forall {ge e le m a ty v v'},
    Clight.eval_exprlist ge e le m a ty v -> Clight.eval_exprlist ge e le m a ty v' -> v=v'.

Lemma eval_lvalue_fun:   forall {ge e le m a b b' z z'},
    Clight.eval_lvalue ge e le m a b z -> Clight.eval_lvalue ge e le m a b' z' -> (b,z)=(b',z').

Lemma inv_find_symbol_fun:
  forall {ge id id' b},
    Senv.find_symbol ge id = Some b ->

Lemma assign_loc_fun:
  forall {cenv ty m b ofs v m1 m2},
   assign_loc cenv ty m b ofs v m1 ->
   assign_loc cenv ty m b ofs v m2 ->
   m1=m2.

Lemma alloc_variables_fun:
  forall {ge e m vl e1 m1 e2 m2},
     Clight.alloc_variables ge e m vl e1 m1 ->

Lemma bind_parameters_fun:
  forall {ge e m p v m1 m2},
    Clight.bind_parameters ge e m p v m1 ->

Lemma eventval_list_match_fun:
  forall {se a a' t v},
    Events.eventval_list_match se a t v ->

Ltac fun_tac :=
  match goal with
  | H: ?A = Some _, H': ?A = Some _ |- _ => inversion2 H H'
  | H: Clight.eval_expr ?ge ?e ?le ?m ?A _,
    H': Clight.eval_expr ?ge ?e ?le ?m ?A _ |- _ =>
        apply (eval_expr_fun H) in H'; subst
  | H: Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _,
    H': Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _ |- _ =>
        apply (eval_exprlist_fun H) in H'; subst
  | H: Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _,
    H': Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _ |- _ =>
        apply (eval_lvalue_fun H) in H'; inv H'
  | H: Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _,
    H': Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _ |- _ =>
        apply (assign_loc_fun H) in H'; inv H'
  | H: Clight.deref_loc ?ty ?m ?b ?ofs _,
    H': Clight.deref_loc ?ty ?m ?b ?ofs _ |- _ =>
        apply (deref_loc_fun H) in H'; inv H'
  | H: Clight.alloc_variables ?ge ?e ?m ?vl _ _,
    H': Clight.alloc_variables ?ge ?e ?m ?vl _ _ |- _ =>
        apply (alloc_variables_fun H) in H'; inv H'
  | H: Clight.bind_parameters ?ge ?e ?m ?p ?vl _,
    H': Clight.bind_parameters ?ge ?e ?m ?p ?vl _ |- _ =>
        apply (bind_parameters_fun H) in H'; inv H'
  | H: Senv.find_symbol ?ge _ = Some ?b,
    H': Senv.find_symbol ?ge _ = Some ?b |- _ =>
       apply (inv_find_symbol_fun H) in H'; inv H'
  | H: Events.eventval_list_match ?ge _ ?t ?v,
    H': Events.eventval_list_match ?ge _ ?t ?v |- _ =>
       apply (eventval_list_match_fun H) in H'; inv H'
 end. *)

Require Import VST.veric.Clight_initial_world.
(* VST.veric.Clight_initial_world:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.

Require Import VST.veric.extend_tc.
Require Import VST.veric.Clight_seplog.
Require Import VST.veric.Clight_assert_lemmas.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.

Require Export VST.veric.initial_world.

Local Open Scope pred.

Obligation Tactic := idtac.

Notation initial_core' := (initial_core' function).

Notation initial_core := (@initial_core function).

Notation initial_core_ext := (@initial_core_ext  function).

Notation prog_funct := (@prog_funct function).

Inductive match_fdecs: list  (ident * fundef) -> funspecs -> Prop :=
| match_fdecs_nil: match_fdecs nil nil
| match_fdecs_cons: forall i fd fspec fs G,
                  type_of_fundef fd = type_of_funspec fspec ->
                  match_fdecs fs G ->
                  match_fdecs ((i,fd)::fs) ((i,fspec)::G)

.

Lemma match_fdecs_exists_Gfun:
  forall prog G i f,
    find_id i G = Some f ->
    match_fdecs (prog_funct prog) G ->
    exists fd,   In (i, Gfun fd) (prog_defs prog) /\
                     type_of_fundef fd = type_of_funspec f.

Lemma initial_core_ok: forall (prog: program) G n m,
      list_norepet (prog_defs_names prog) ->
      match_fdecs (prog_funct prog) G ->
      Genv.init_mem prog = Some m ->

Definition initial_jm (prog: program) m (G: funspecs) (n: nat)
        (H: Genv.init_mem prog = Some m)
        (H1: list_norepet (prog_defs_names prog))
        (H2: match_fdecs (prog_funct prog) G) : juicy_mem :=
  initial_mem m (initial_core (Genv.globalenv prog) G n)
           (initial_core_ok _ _ _ m H1 H2 H).

Lemma initial_jm_age (prog: program) m (G: funspecs) (n : nat)
        (H: Genv.init_mem prog = Some m)

Lemma initial_core_ext_ok: forall {Z} (ora : Z) (prog: program) G n m,
      list_norepet (prog_defs_names prog) ->
      match_fdecs (prog_funct prog) G ->
      Genv.init_mem prog = Some m ->

Definition initial_jm_ext {Z} (ora : Z) (prog: program) m (G: funspecs) (n: nat)
        (H: Genv.init_mem prog = Some m)
        (H1: list_norepet (prog_defs_names prog))
        (H2: match_fdecs (prog_funct prog) G) : juicy_mem :=
  initial_mem m (initial_core_ext ora (Genv.globalenv prog) G n)
           (initial_core_ext_ok _ _ _ _ m H1 H2 H).

Require Import VST.veric.ghost_PCM.
Lemma initial_jm_ext_eq : forall {Z} (ora : Z) (prog: program) m (G: funspecs) (n: nat)
        (H: Genv.init_mem prog = Some m)

Notation prog_vars := (@prog_vars function).

Lemma initial_jm_without_locks prog m G n H H1 H2:
  no_locks (m_phi (initial_jm prog m G n H H1 H2)).

Lemma initial_jm_ext_without_locks {Z} (ora : Z) prog m G n H H1 H2:
  no_locks (m_phi (initial_jm_ext ora prog m G n H H1 H2)).

Definition matchfunspecs (ge : genv) (G : funspecs) (Phi : rmap) : Prop :=
  forall (b : block) fsig cc A P Q,
    func_at'' fsig cc A P Q (b, 0%Z) Phi ->
    exists id P' Q' P'_ne Q'_ne,
      Genv.find_symbol ge id = Some b /\
      find_id id G = Some (mk_funspec fsig cc A P' Q' P'_ne Q'_ne) /\
      cond_approx_eq (level Phi) A P P' /\
      cond_approx_eq (level Phi) A Q Q'.

Lemma initial_jm_matchfunspecs prog m G n H H1 H2:
  matchfunspecs (globalenv prog) G (m_phi (initial_jm prog m G n H H1 H2)).

Lemma initial_jm_ext_matchfunspecs {Z} (ora : Z) prog m G n H H1 H2:
  matchfunspecs (globalenv prog) G (m_phi (initial_jm_ext ora prog m G n H H1 H2)). *)



Definition only_blocks {S: block -> Prop} (S_dec: forall b, {S b}+{~S b}) (w: rmap) : rmap.

 refine (proj1_sig (make_rmap (fun loc => if S_dec (fst loc) then w @ loc else core (w @ loc))

                              _ (level w) _ (ghost_of_approx w))).

Proof.

  hnf; auto.

 extensionality loc;  unfold compose.

 if_tac; try apply resource_at_approx.

 repeat  rewrite core_resource_at. rewrite <- level_core.

apply resource_at_approx.

Defined.



Definition not_dec: forall {S: block -> Prop} (f: forall b, {S b}+{~S b}),

                            forall b, {~S b}+{~ ~ S b}.

Proof. intros. destruct (f b). right; intuition. left; auto.

Qed.



Lemma join_only_blocks:

  forall {S} S_dec phi, identity (ghost_of phi) -> join (@only_blocks S S_dec phi)

                        (only_blocks (not_dec S_dec) phi) phi.

Proof. intros.

  unfold only_blocks.

  apply resource_at_join2.

  repeat rewrite level_make_rmap. auto.

  repeat rewrite level_make_rmap. auto.

 intro;   repeat rewrite resource_at_make_rmap. unfold compose.

 destruct (S_dec (fst loc)); simpl.

  try rewrite if_false by intuition. apply join_comm; apply core_unit.

  rewrite if_true by intuition; apply core_unit.

  rewrite !ghost_of_make_rmap.

  apply identity_unit'; auto.

Qed.



Lemma Exists_dec: forall {T} (f: T -> Prop)(f_dec: forall x, {f x}+{~f x}) (l: list T),

                   {Exists f l}+{~Exists f l}.

  Proof. intros. induction l; simpl. right; intro. inv H.

         destruct IHl. left; constructor 2; auto. destruct (f_dec a). left; constructor 1; auto.

        right; intro Hx; inv Hx; auto.

  Qed.



Lemma only_blocks_at: forall {S} S_dec phi loc,

   @only_blocks S S_dec phi @ loc =

    if S_dec (fst loc) then phi @ loc else core (phi @ loc).

Proof.

   unfold only_blocks; intros.

 rewrite resource_at_make_rmap. auto.

Qed.



Lemma level_only_blocks: forall {S} S_dec phi,

   level (@only_blocks S S_dec phi) = level phi.

Proof. intros. apply level_make_rmap.

Qed.



Definition upto_block (b: block) (w: rmap) : rmap :=  only_blocks (fun b' => plt b' b) w.



Definition beyond_block (b: block) (w: rmap) : rmap := only_blocks (not_dec (fun b' => plt b' b)) w.



Lemma join_upto_beyond_block:

  forall b phi, identity (ghost_of phi) -> join  (upto_block b phi)  (beyond_block b phi) phi.

Proof.  intros; apply join_only_blocks; auto.

Qed.



Lemma split_range:

  forall phi base n,

    (forall loc, adr_range base n loc ->

       match phi @ loc with YES _ _ k _ => isVAL k | _ => True end) ->

    noghost phi ->

   exists phi1, exists phi2,

      join phi1 phi2 phi /\

      forall loc, if adr_range_dec base n loc then identity (phi2 @ loc)

                                                      else identity (phi1 @ loc).

Proof.

  intros ???? Hg.

  pose proof I.

  destruct (make_rmap (fun loc => if adr_range_dec base n loc then phi @ loc else core (phi @ loc)) (ghost_of phi) (level phi)) as [phi1 [J1 J2]].

  extensionality loc;   unfold compose.

  if_tac.  apply resource_at_approx.

  repeat rewrite core_resource_at. rewrite <- level_core. apply resource_at_approx.

  { apply ghost_of_approx. }

  clear H0.

  pose proof I.

 destruct (make_rmap (fun loc => if adr_range_dec base n loc then core (phi @ loc) else phi @ loc) (ghost_of phi) (level phi)) as [phi2 [J3 J4]].

  extensionality loc;   unfold compose.

  if_tac.

  repeat rewrite core_resource_at. rewrite <- level_core. apply resource_at_approx.

  apply resource_at_approx.

  { apply ghost_of_approx. }

 clear H0.

  destruct J2 as [J2 Hg1], J4 as [J4 Hg2].

  exists phi1; exists phi2; split; auto.

  apply resource_at_join2; [congruence | congruence | | ].

  intros; rewrite J2; rewrite J4.

  if_tac.

    apply join_unit2. apply core_unit. auto.

    apply join_unit1. apply core_unit. auto.

  rewrite Hg1, Hg2; apply identity_unit'; auto.

  intros. rewrite J2; rewrite J4. if_tac; apply core_identity.

Qed.



Definition blockslice_rmap (S: block -> Prop) (phi: rmap) :=

    forall loc: address, ~S (fst loc) -> identity (phi @ loc).



Definition eq_mod_blockslice (S: block -> Prop) (phi phi': rmap) :=

 forall loc, (S (fst loc) -> phi @ loc = phi' @ loc) .



Definition blockslice_mpred (S: block -> Prop) (P: mpred) :=

  (forall phi, P phi -> forall loc, ~S (fst loc) -> identity (phi @ loc)) /\

  (forall phi phi', blockslice_rmap S phi -> blockslice_rmap S phi' ->

                        eq_mod_blockslice S phi phi' ->

         P phi -> P phi').



Definition blockslice_mpred_rmap:

  forall S (Sdec: forall b, {S b}+{~S b}) P phi,

   blockslice_mpred S P -> P phi -> blockslice_rmap S phi.

Proof.

 unfold blockslice_mpred, blockslice_rmap; intros.

 destruct H.

 eapply H; eauto.

Qed.



Lemma rev_prog_vars': forall {F V} vl, rev (@prog_vars' F V vl) = prog_vars' (rev vl).

Proof.

   intros.

   induction vl. simpl; auto.

   destruct a. destruct g.

   simpl. rewrite IHvl.

   clear. induction (rev vl); simpl; intros; auto. destruct a; destruct g; simpl; auto.

    rewrite IHl. auto.

   simpl.

   transitivity (prog_vars' (rev vl) ++ (@prog_vars' F V ((i,Gvar v)::nil))).

    rewrite IHvl. f_equal.

    simpl.

    clear.

    induction (rev vl); simpl; intros; auto.

    destruct a. destruct g.

    auto.

    rewrite <- IHl.

    simpl. auto.

Qed.



Definition init_data2pred (d: init_data)  (sh: share) (a: val) (rho: environ) : mpred :=

 match d with

  | Init_int8 i => mapsto sh (Tint I8 Unsigned noattr) a (Vint (Int.zero_ext 8 i))

  | Init_int16 i => mapsto sh (Tint I16 Unsigned noattr) a (Vint (Int.zero_ext 16 i))

  | Init_int32 i => mapsto sh (Tint I32 Unsigned noattr) a (Vint i)

  | Init_int64 i => mapsto sh (Tlong Unsigned noattr) a (Vlong i)

  | Init_float32 r =>  mapsto sh (Tfloat F32 noattr) a (Vsingle r)

  | Init_float64 r =>  mapsto sh (Tfloat F64 noattr) a (Vfloat r)

  | Init_space n => mapsto_zeros n sh a

  | Init_addrof symb ofs =>

       match Map.get (ge_of rho) symb with

       | Some b => mapsto sh (Tpointer Tvoid noattr) a (Vptr b ofs)

       | _ => mapsto_ sh (Tpointer Tvoid noattr) a

       end

 end.



Fixpoint init_data_list2pred  (dl: list init_data)

                           (sh: share) (v: val)  : environ -> pred rmap :=

  match dl with

  | d::dl' => 

      lift2 sepcon (init_data2pred d sh v) 

                  (init_data_list2pred dl' sh (offset_val (init_data_size d) v))

  | nil => lift0 emp

 end.



Definition readonly2share (rdonly: bool) : share :=

  if rdonly then Ers else Ews.



Definition globals_of_env (rho: environ) (i: ident) : val := 

  match Map.get (ge_of rho) i with Some b => Vptr b Ptrofs.zero | None => Vundef end.



Definition globvar2pred (gv: ident->val) (idv: ident * globvar type) : assert :=

   if (gvar_volatile (snd idv))

                       then  lift0 TT

                       else    init_data_list2pred (gvar_init (snd idv))

                                   (readonly2share (gvar_readonly (snd idv))) (gv (fst idv)).



Definition globvars2pred (gv: ident->val) (vl: list (ident * globvar type)) : assert :=

  (lift2 andp) (fun rho => prop (gv = globals_of_env rho))

  (fold_right (lift2 sepcon) (lift0 emp) (map (globvar2pred gv) vl)).



Lemma globvars2pred_rev:

  forall gv l, globvars2pred gv (rev l) = globvars2pred gv l.

Proof.

 intros. unfold globvars2pred.

 rewrite map_rev.

  rewrite fold_left_rev_right.

 rewrite fold_symmetric.

 f_equal.

 f_equal. extensionality x y rho; apply sepcon_comm.

 intros; extensionality rho; apply sepcon_assoc.

 intros; extensionality rho; apply sepcon_comm.

Qed.



Lemma writable_blocks_rev:

  forall rho l, writable_blocks l rho = writable_blocks (rev l) rho.

Proof.

induction l; simpl; auto.

destruct a.

rewrite writable_blocks_app.

rewrite <- IHl.

simpl.

rewrite sepcon_emp.

apply sepcon_comm.

Qed.



Lemma add_variables_nextblock:

  forall F V vl (ge: Genv.t F V) i g ul, list_norepet (map (@fst _ _) (vl++(i,g)::ul)) ->

   Genv.find_symbol (Genv.add_globals ge (vl++(i,g)::ul)) i =

          Some (Genv.advance_next vl (Genv.genv_next ge)).

Proof.

 induction vl; intros.

 inv H. clear H3. simpl.

 change positive with block.

 replace (Some (Genv.genv_next ge)) with (Genv.find_symbol (Genv.add_global ge (i,g)) i).

 2:{

  unfold Genv.add_global, Genv.find_symbol; simpl. rewrite PTree.gss. f_equal; unfold block; omega.

  }

  forget (Genv.add_global ge (i, g)) as ge1.

  revert H2 ge1; induction ul; simpl; intros; auto.

  spec IHul; [intuition |].

  rewrite IHul.

  unfold Genv.find_symbol, Genv.add_global. simpl.

  rewrite PTree.gso; auto.

  simpl length. simpl Genv.advance_next.

  simpl.

  rewrite (IHvl  (Genv.add_global ge a) i g ul).

  f_equal.

  simpl in H. inv H; auto.

Qed.



Definition load_store_init_data1 (ge: Genv.t fundef type) (m: mem) (b: block) (p: Z) (d: init_data) : Prop :=

  match d with

  | Init_int8 n =>

      Mem.load Mint8unsigned m b p = Some(Vint(Int.zero_ext 8 n))

  | Init_int16 n =>

      Mem.load Mint16unsigned m b p = Some(Vint(Int.zero_ext 16 n))

  | Init_int32 n =>

      Mem.load Mint32 m b p = Some(Vint n)

  | Init_int64 n =>

      Mem.load Mint64 m b p = Some(Vlong n)

  | Init_float32 n =>

      Mem.load Mfloat32 m b p = Some(Vsingle n)

  | Init_float64 n =>

      Mem.load Mfloat64 m b p = Some(Vfloat n)

  | Init_addrof symb ofs =>

      Mem.load Mptr m b p = Some

             match Genv.find_symbol ge symb with

                | Some b' => Vptr b' ofs

                | None => Vint Int.zero

              end

  | Init_space n =>

      forall z, 0 <= z < Z.max n 0 ->

           Mem.load Mint8unsigned m b (p+z) = Some (Vint Int.zero)

  end.



Definition initializer_aligned (z: Z) (d: init_data) : bool :=

  match d with

  | Init_int16 n => Zeq_bool (z mod 2) 0

  | Init_int32 n => Zeq_bool (z mod 4) 0

  | Init_int64 n => Zeq_bool (z mod 8) 0

  | Init_float32 n =>  Zeq_bool (z mod 4) 0

  | Init_float64 n =>  Zeq_bool (z mod 8) 0

  | Init_addrof symb ofs =>  Zeq_bool (z mod (size_chunk Mptr)) 0

  | _ => true

  end.



Fixpoint initializers_aligned (z: Z) (dl: list init_data) : bool :=

  match dl with

  | nil => true

  | d::dl' => andb (initializer_aligned z d) (initializers_aligned (z + init_data_size d) dl')

  end.



Lemma init_data_list_size_pos: forall dl, init_data_list_size dl >= 0.

Proof. induction dl; simpl; intros. omega.

 pose proof (init_data_size_pos a); omega.

Qed.



Require Import FunInd.



Remark store_zeros_load_outside:

  forall m b p n m',

  store_zeros m b p n = Some m' ->

  forall chunk b' p',

  b' <> b \/ p' + size_chunk chunk <= p \/ p + n <= p' ->

  Mem.load chunk m' b' p' = Mem.load chunk m b' p'.

Proof.

  intros until n.  functional induction (store_zeros m b p n); intros.

  inv H; auto.

  transitivity (Mem.load chunk m' b' p').

  apply IHo. auto. intuition omega.

  eapply Mem.load_store_other; eauto. simpl. intuition omega.

  discriminate.

Qed.



Lemma load_store_zeros:

  forall m b z N m', store_zeros m b z N = Some m' ->

         forall z', z <= z' < z + N -> load Mint8unsigned m' b z' = Some (Vint Int.zero).

Proof.

 intros.

 symmetry in H; apply R_store_zeros_correct in H.

  remember (Some m') as m1.

  revert z'  m' Heqm1 H0; induction H; intros. omegaContradiction.

  subst _res.

 destruct (Z.eq_dec z' p).

 2:{ apply IHR_store_zeros; auto.

   clear - H0 n0.  destruct H0. omega.

  }

  subst z'.

  destruct (load_store_similar _ _ _ _ _ _ e0) with Mint8unsigned; simpl; auto.

  omega.

  destruct H1.

 simpl in H2. subst x.

  replace (Int.zero_ext 8 Int.zero) with (Int.zero) in H1 by reflexivity.

  rewrite <- H1.

  clear - H. apply R_store_zeros_complete in H.

 symmetry.

 symmetry in H; symmetry; eapply store_zeros_load_outside; eauto.

 right. simpl; omega.

  inv Heqm1.

Qed.



Lemma read_as_zero_lem1:

 forall m b z len,

  (forall i, z <= i < z+len ->

     load Mint8unsigned m b i = Some (Vint Int.zero)) ->

  Genv.read_as_zero m b z len.

Proof.

intros; hnf; intros.

transitivity

  (Some (decode_val chunk (list_repeat (size_chunk_nat chunk) (Byte Byte.zero)))).

2: destruct chunk; reflexivity.

apply loadbytes_load; auto.

clear H2.

rewrite size_chunk_conv in *.



forget (size_chunk_nat chunk) as n.

assert (forall i, p <= i < p + (Z.of_nat n) ->

                     loadbytes m b i 1 = Some (Byte Byte.zero::nil)).

intros.

specialize (H i).

spec H; [ omega |].

apply load_loadbytes in H.

destruct H as [j [? ?]].

destruct j; inv H3;

 try solve [apply loadbytes_length in H;inv H].

destruct j; inv H5;

 try solve [apply loadbytes_length in H;inv H].

destruct m0; try solve [inv H4].

rewrite (decode_byte_val i0) in H4.

simpl in H.

rewrite H. repeat f_equal.

clear - H4.

rewrite zero_ext_inrange in H4.

assert (Int.unsigned Int.zero = Int.unsigned (Int.repr (Byte.unsigned i0))) by congruence.

rewrite Int.unsigned_zero in H.

rewrite Int.unsigned_repr in H.

assert (Byte.repr 0 = Byte.repr (Byte.unsigned i0)) by congruence.

rewrite Byte.repr_unsigned in H0.

rewrite <- H0. reflexivity.

clear.

pose proof (Byte.unsigned_range i0).

destruct H;

 split; auto.

apply Z.le_trans with Byte.modulus.

omega.

compute; congruence.

rewrite Int.unsigned_repr.

pose proof (Byte.unsigned_range i0).

change (two_p 8) with Byte.modulus; omega.

pose proof (Byte.unsigned_range i0).

assert (Byte.modulus < Int.max_unsigned) by (compute; congruence).

omega.

clear - H2.

revert p H2; induction n; intros.

simpl.

apply loadbytes_empty. omega.

rewrite inj_S. unfold Z.succ.

rewrite Z.add_comm.

change (list_repeat (S n) (Byte Byte.zero)) with

 (list_repeat 1 (Byte Byte.zero) ++ list_repeat n (Byte Byte.zero)).

apply loadbytes_concat.

apply H2. rewrite inj_S; omega.

apply IHn.

intros.

apply H2.  rewrite inj_S; omega.

omega. omega.

Qed.



Remark store_init_data_outside:

  forall {F V} genv b i m p m',

  @Genv.store_init_data F V genv m b p i = Some m' ->

  forall chunk b' q,

  b' <> b \/ q + size_chunk chunk <= p \/ p + init_data_size i <= q ->

  Mem.load chunk m' b' q = Mem.load chunk m b' q.

Proof.

  intros. destruct i; simpl in *;

  try (eapply Mem.load_store_other; eauto; fail).

  inv H; auto.

  destruct (Genv.find_symbol genv i); try congruence.

  eapply Mem.load_store_other; eauto; intuition.

Qed.



Remark store_init_data_list_outside:

  forall {F V} genv b il m p m',

  @Genv.store_init_data_list F V genv m b p il = Some m' ->

  forall chunk b' q,

  b' <> b \/ q + size_chunk chunk <= p ->

  Mem.load chunk m' b' q = Mem.load chunk m b' q.

Proof.

  induction il; simpl.

  intros; congruence.

  intros. destruct (Genv.store_init_data genv m b p a) as [m1|] eqn:?; try congruence.

  transitivity (Mem.load chunk m1 b' q).

  eapply IHil; eauto. generalize (init_data_size_pos a). intuition omega.

  eapply store_init_data_outside; eauto. tauto.

Qed.



Lemma load_store_init_data_lem1:

  forall {ge m1 b D m2 m3},

   store_zeros m1 b 0 (init_data_list_size D) = Some m2 ->

   Genv.store_init_data_list ge m2 b 0 D = Some m3 ->

   forall dl' a dl, dl' ++ a :: dl = D ->

   load_store_init_data1 ge m3 b (init_data_list_size dl') a.

Proof.

  intros.

  pose proof (Genv.store_init_data_list_charact _ _ H0).

  subst D.

  change (init_data_list_size dl') with (0 + init_data_list_size dl').

  forget 0 as z.

  assert (forall z', z <= z' < z + init_data_list_size (dl' ++ a :: dl) ->

               Mem.load Mint8unsigned m2 b z' = Some (Vint Int.zero))

    by (eapply load_store_zeros; eauto).

  clear H m1.

  revert z m2 H0 H1 H2; induction dl'; intros.

  simpl app in *. simpl init_data_list_size in *.

  replace (z+0) with z by omega.

  simpl in H0.

  invSome.

  spec H2. {

    clear - H1.

    apply read_as_zero_lem1; intros; apply H1.

    omega.

  }

  destruct a; simpl in H2|-*; try solve [destruct H2; auto]; intros.

  rewrite (store_init_data_list_outside _ _ _ _ _ _ H4) by (right; simpl; omega).

  simpl in H0. inv H0. apply H1.

  simpl.

  pose proof (init_data_list_size_pos dl).

  omega.

  destruct H2 as [[b' [? ?]] ?].

  rewrite H. auto.

  simpl.

  simpl in H0. invSome.

  rewrite Zplus_assoc. apply IHdl' with m; auto.

  intros.

  rewrite <- (H1 z').

  destruct (store_init_data_list_outside' _ _ ge b (a0::nil) m2 z m).

  simpl. rewrite H0; auto.

  destruct (H3 b z').

  destruct H6. simpl in H7. omegaContradiction.

  destruct H5. clear - H6 H5; unfold access_at,contents_at in *.

  Transparent load. unfold load. Opaque load.

  simpl in *. rewrite H6.

  destruct (valid_access_dec m Mint8unsigned b z' Readable);

   destruct (valid_access_dec m2 Mint8unsigned b z' Readable);

  unfold valid_access in *; try congruence.

  contradiction n. clear - v H5.

  unfold range_perm, perm in *.

  destruct v; split; auto; intros.

  apply (equal_f ) with (b,ofs) in H5. apply equal_f with Cur in H5. simpl in H5.

  rewrite H5; auto.

  contradiction n. clear - v H5.

  unfold range_perm, perm in *.

  destruct v; split; auto; intros.

  apply (equal_f ) with (b,ofs) in H5.  apply equal_f with Cur in H5. simpl in H5. rewrite <- H5; auto.

  simpl.

  pose proof (init_data_size_pos a0).

  omega.

  simpl app in H2.

  spec H2. {

     clear - H1.

     apply read_as_zero_lem1; intros.

     apply H1. simpl; auto.

  }

  clear - H2.

  forget (dl'++a::dl) as D.

  simpl in H2. destruct a0; simpl in *; try solve [destruct H2; auto]; intros.

Qed.



Lemma zero_ext_inj: forall i,

   Int.zero_ext 8 (Int.repr (Byte.unsigned i)) = Int.zero ->

   i = Byte.zero.

Proof.

intros.

assert (MU: 256 < Int.max_unsigned).

 unfold Int.max_unsigned, Int.modulus, Int.wordsize, Wordsize_32.wordsize in *.

  unfold two_power_nat, shift_nat in *; simpl in *.

 replace (Zpos (4294967296 - 1)) with (4294967295). omega. reflexivity.

rewrite Int.zero_ext_and in H by omega.



pose proof (Int.modu_and (Int.repr (Byte.unsigned i)) (Int.repr (two_p 8)) (Int.repr 8)).

 spec H0.

 apply Int.is_power2_two_p; simpl.  unfold Int.zwordsize; simpl. omega.

 replace (Int.sub (Int.repr (two_p 8)) Int.one) with (Int.repr (two_p 8 - 1)) in H0.

 rewrite <- H0 in H. clear H0.

 rewrite Int.modu_divu in H.

 replace (Int.divu (Int.repr (Byte.unsigned i)) (Int.repr (two_p 8))) with Int.zero in H.

 rewrite Int.sub_zero_l in H.

 pose proof (Int.unsigned_repr (Byte.unsigned i)).

 assert (Int.unsigned (Int.repr (Byte.unsigned i)) = Int.unsigned Int.zero).

 rewrite H; auto.

 rewrite H0 in H1.

 clear - MU H1. rewrite Int.unsigned_zero in H1.

rewrite <- (Byte.repr_unsigned i). unfold Byte.zero. f_equal. auto.

 clear - MU. pose proof (Byte.unsigned_range i).

 unfold Byte.modulus, Byte.wordsize, Wordsize_8.wordsize in *.

  unfold two_power_nat, shift_nat in *; simpl in *. omega.

 clear - MU.

 unfold Int.divu. unfold Int.zero. f_equal.

 symmetry. apply Zdiv_small.

 split.

 destruct (Int.unsigned_range (Int.repr (Byte.unsigned i))); auto.

 repeat rewrite Int.unsigned_repr.

 destruct (Byte.unsigned_range i).

 apply H0. simpl.  unfold two_power_pos, shift_pos; simpl. omega.

 destruct (Byte.unsigned_range i).

 split; auto. replace Byte.modulus with 256 in H0 by reflexivity. omega.

 clear - MU. replace (two_p 8) with 256 by reflexivity.

 unfold Int.zero. intro.

 pose proof (Int.unsigned_repr 256).

 spec H0. split; omega.

 rewrite H in H0. rewrite Int.unsigned_repr in H0 by omega. inv H0.

 replace (two_p 8) with 256 by reflexivity.

 unfold Int.one.

 rewrite Int.sub_signed.

 pose proof (Int.min_signed_neg).

 assert (Int.max_signed = 2147483647).

 clear.  unfold Int.max_signed, Int.half_modulus, Int.modulus, Int.wordsize, two_power_nat; simpl.

 reflexivity.

  repeat rewrite Int.signed_repr; auto;  split; try omega.

Qed.



Lemma max_unsigned_eq: Int.max_unsigned = 4294967295.

Proof.

 unfold Int.max_unsigned, Int.modulus, Int.wordsize, Wordsize_32.wordsize in *.

  simpl. unfold shift_nat. simpl. reflexivity.

Qed.



Lemma decode_val_getN_lem1:

  forall j i b,

          decode_val Mint32 (getN 4 i b) = Vint Int.zero ->

          0 <= j-i < 4 ->

          nth (nat_of_Z (j-i)) (getN 4 i b) Undef = Byte Byte.zero.

Proof.

 intros.

 unfold decode_val in H.

 revert H; case_eq (getN 4 i b); intros. inv H.

 unfold getN in H. destruct l; inv H.

 destruct (proj_bytes

         (ZMap.get i b

          :: ZMap.get (i + 1) b

             :: ZMap.get (i + 1 + 1) b :: ZMap.get (i + 1 + 1 + 1) b :: nil))

    eqn:PB.

*

 simpl proj_bytes in PB.

 destruct (ZMap.get i b); inv PB.

 destruct (ZMap.get (i+1) b); inv H2.

 destruct (ZMap.get (i+1+1) b); inv H3.

 destruct (ZMap.get (i+1+1+1) b); inv H2.

 unfold decode_int in H1.

 assert (Int.repr (int_of_bytes (rev_if_be (i0 :: i1 :: i2 :: i3 :: nil))) = Int.repr 0) by

    (forget (Int.repr (int_of_bytes (rev_if_be (i0 :: i1 :: i2 :: i3 :: nil)))) as foo; inv H1; auto).

 clear H1.

 assert (forall b0 b1 b2 b3, Int.repr (int_of_bytes (b0::b1::b2::b3::nil)) = Int.repr 0 ->

      (Byte.unsigned b0=0/\Byte.unsigned b1=0/\Byte.unsigned b2=0/\Byte.unsigned b3=0)).

 clear. intros.

   simpl in H.

  pose proof (Byte.unsigned_range b0).

  pose proof (Byte.unsigned_range b1).

  pose proof (Byte.unsigned_range b2).

  pose proof (Byte.unsigned_range b3).

  replace (Byte.modulus) with 256 in * by reflexivity.

  pose proof (Int.unsigned_repr  (Byte.unsigned b0 +

       (Byte.unsigned b1 +

        (Byte.unsigned b2 + (Byte.unsigned b3 + 0) * 256) * 256) * 256)).

  spec H4.

  clear H. rewrite max_unsigned_eq; omega.

  rewrite H in H4.

 rewrite Int.unsigned_repr in H4 by (rewrite max_unsigned_eq; omega).

  omega.

 assert (Byte.unsigned i0=0/\Byte.unsigned i1=0/\Byte.unsigned i2=0/\Byte.unsigned i3=0).

 unfold rev_if_be in H. destruct Archi.big_endian; simpl in H; apply H1 in H; intuition.

 clear H1 H.

  assert (forall i, Byte.unsigned i = 0 -> i = Byte.zero).

  clear. intros. pose proof (Byte.repr_unsigned i). rewrite H in H0. symmetry; auto.

 destruct H2 as [? [? [? ?]]]. apply H in H1; apply H in H2; apply H in H3; apply H in H4.

 subst.

 assert (j-i=0 \/ j-i=1 \/ j-i=2 \/ j-i=3) by omega.

 destruct H1 as [? | [?|[?|?]]]; rewrite H1; simpl; auto.

*

 unfold proj_value in H1.

 unfold Val.load_result in H1.

 clear PB.

 destruct (ZMap.get i b); inv H1.



Abort.



Lemma Zmax_Z_of_nat:

 forall n, Z.max (Z_of_nat n) 0 = Z_of_nat n.

Proof.

intros.

apply Z.max_l.

omega.

Qed.



Lemma snd_split_fullshare_not_bot: snd (Share.split fullshare) <> Share.bot.

Proof.

intro.

case_eq (Share.split fullshare); intros.

rewrite H0 in H. simpl in H. subst.

apply Share.split_nontrivial in H0; auto.

apply Share.nontrivial in H0. contradiction.

Qed.



Lemma readable_readonly2share: forall ro, readable_share (readonly2share ro).

Proof.

  intros.

  unfold readable_share. intro.

  apply identity_share_bot in H.

  assert (H9: Share.Rsh <> Share.bot). {

    unfold Share.Rsh. intro.

    destruct (Share.split Share.top) eqn:?.

    pose proof (Share.split_nontrivial _ _ _ Heqp). spec H1; auto. contradiction Share.nontrivial.

  }

  clear H9.

  destruct ro; simpl in *.

  unfold Ers in H.

  rewrite Share.distrib1 in H.

  apply lub_bot_e in H. destruct H as [_ ?].

  rewrite glb_split_x in H.

  destruct (Share.split Share.Rsh) eqn:H0. simpl in *.

  subst.

  pose proof (Share.split_nontrivial _ _ _ H0). spec H; auto.

  apply snd_split_fullshare_not_bot in H. auto.

  unfold Ews in H.

  rewrite Share.distrib1 in H.

  apply lub_bot_e in H. destruct H as [_ ?].

  rewrite Share.glb_idem in H.

  apply snd_split_fullshare_not_bot in H. auto.

Qed.



Lemma init_data_lem:

forall (ge: genv) (v : globvar type) (b : block) (m1 : mem')

  (m3 m4 : Memory.mem) (phi0 : rmap) (a : init_data) (z : Z) (rho: environ)

  (w1 wf : rmap),

   load_store_init_data1 ge m3 b z a ->

   contents_at m4 = contents_at m3 ->

   join w1 wf (beyond_block b (inflate_initial_mem m4 phi0)) ->

   (forall loc : address,

     if adr_range_dec (b, z) (init_data_size a) loc

     then identity (wf @ loc) /\ access_at m4 loc Cur = Some (Genv.perm_globvar v)

     else identity (w1 @ loc)) ->

   forall (Hg: noghost w1) (VOL:  gvar_volatile v = false)

          (AL: initializer_aligned z a = true)

           (LO:   0 <= z) (HI: z + init_data_size a < Ptrofs.modulus)

         (RHO: ge_of rho = filter_genv ge),

  (init_data2pred a  (readonly2share (gvar_readonly v))

       (Vptr b (Ptrofs.repr z))) rho w1.

Proof.

  intros.

  assert (APOS:= init_data_size_pos a).

  assert (READABLE:= readable_readonly2share (gvar_readonly v)).

  Transparent load.

  unfold init_data2pred, mapsto.

  unfold mapsto_zeros, address_mapsto, res_predicates.address_mapsto,

    fst,snd.

  rewrite Ptrofs.unsigned_repr by (unfold Ptrofs.max_unsigned; omega).

  simpl.

  unfold mapsto, tc_val, is_int, is_long, is_float.

  destruct (readable_share_dec

            (readonly2share (gvar_readonly v))); [clear r | tauto].

  destruct a; 

  repeat rewrite prop_true_andp by 

    first [apply I

            | apply sign_ext_range'; compute; split; congruence

            | apply zero_ext_range'; compute; split; congruence

            ];

  try left; simpl in H; unfold load in H;

  try (if_tac in H; [ | discriminate H]);

  repeat rewrite prop_true_andp by apply I;

  try match type of H with Some (decode_val ?ch ?B) = Some (?V) =>

            exists B; replace V with (decode_val ch B) by (inversion H; auto);

            clear H; repeat split; auto

       end.

* 

  apply Zone_divide.

* 

  intro loc; specialize (H2 loc).

  simpl in H2. hnf. if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf. rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

  unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

* 

  intro loc; specialize (H2 loc).

  simpl in H2. simpl size_chunk. hnf; if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

* 

  intro loc; specialize (H2 loc).

  simpl in H2. simpl size_chunk. hnf; if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

* 

  intro loc; specialize (H2 loc).

  simpl in H2. simpl size_chunk. hnf; if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

* 

  intro loc; specialize (H2 loc).

  simpl in H2. simpl size_chunk. hnf; if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

   clear - AL.

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

  rewrite <- Zeq_is_eq_bool in *.

  apply Zmod_divides; [ omega | ].

  apply Zmod_divides in AL; [ | omega].

  destruct AL as [c ?]. exists (2 * c). rewrite Z.mul_assoc. apply H.

*  intro loc; specialize (H2 loc).

  simpl in H2. simpl size_chunk. hnf; if_tac; auto.

  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H; subst b0.

  apply nth_getN; simpl; omega.

* 

 rewrite address_mapsto_zeros_eq.

 split; auto. 

  split; auto. simpl in HI. clear - HI. destruct (Z.max_spec z0 0); destruct H; omega.

 split; auto.

  intro loc. hnf. specialize (H2 loc); simpl in H2.

rewrite Zmax_Z_of_nat.

rewrite nat_of_Z_max.

if_tac; auto.



  exists READABLE.

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true by (  destruct loc; destruct H3; subst; simpl; unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H4.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct loc; destruct H3; subst b0.

  specialize (H (z1-z)).  spec H; [omega |].

  if_tac in H; [ | discriminate].

  replace (z+(z1-z)) with z1 in * by omega.

  rewrite H0.

  inv H.

  assert (contents_at m3 (b,z1) = Byte Byte.zero).

    unfold contents_at.

    simpl. forget (ZMap.get z1 (PMap.get b (mem_contents m3))) as byt.

    clear - H7.

    unfold decode_val in H7.

    revert H7; case_eq (proj_bytes (byt::nil)); intros; try discriminate.

    simpl in  H. destruct byt; inv H.

    unfold decode_int in H7.

    replace (rev_if_be (i::nil)) with (i::nil) in H7 by (unfold rev_if_be; destruct Archi.big_endian; auto).

    simpl int_of_bytes in H7.

    replace (Byte.unsigned i + 0) with (Byte.unsigned i) in H7 by omega.

    f_equal.

   apply zero_ext_inj. forget (Int.zero_ext 8 (Int.repr (Byte.unsigned i))) as j; inv H7; auto.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.



* 

 rewrite RHO.

  case_eq (Map.get (filter_genv ge) i); try destruct p0; auto; intros.

+

  unfold filter_genv, Map.get in H4.

  revert H4; case_eq (Genv.find_symbol ge i); intros; try discriminate.

  inv H5.

  left. split; [apply I | ].

  rewrite H4 in H.

 exists  (getN (size_chunk_nat Mptr) z (mem_contents m3) !! b).

 repeat split; auto.

 clear - H. 

 cbv iota. congruence.

  simpl in AL. apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

  intro loc; specialize (H2 loc). hnf. simpl init_data_size in H2.

 replace (if Archi.ptr64 then 8 else 4) with (size_chunk Mptr) in H2

   by (unfold Mptr; destruct Archi.ptr64; reflexivity).

 if_tac; [ | apply H2].

  exists READABLE. hnf. 

  destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1. hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true

   by (destruct loc, H,H5; subst; simpl;

        unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H6.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

  rewrite H0.

  destruct loc; destruct H5.  subst b1.

  apply nth_getN; simpl; omega.

  rewrite H0.

  destruct loc; destruct H5; subst b1.

  apply nth_getN; simpl; omega.

+

  erewrite mapsto__exp_address_mapsto by (auto; reflexivity).

  rewrite exp_address_mapsto_VALspec_range_eq.

  rewrite Ptrofs.unsigned_repr by (change Ptrofs.max_unsigned with (Ptrofs.modulus-1); omega).

  split.

  simpl in AL|-*.

  apply Zmod_divide.  intro Hx; inv Hx. apply Zeq_bool_eq; auto.

  hnf. split; auto. intro loc; specialize (H2 loc). hnf.

  simpl init_data_size in H2.

 replace (if Archi.ptr64 then 8 else 4) with (size_chunk Mptr) in H2

   by (unfold Mptr; destruct Archi.ptr64; reflexivity).

 if_tac; [ | apply H2].

 destruct H2.

  apply join_comm in H1.

  apply (resource_at_join _ _ _ loc) in H1.

  apply H2 in H1.

  eexists.

  hnf. exists READABLE.

  hnf; rewrite H1.

  unfold beyond_block. rewrite only_blocks_at.

  rewrite if_true

   by (destruct loc, H,H5; subst; simpl;

        unfold block; xomega).

  unfold inflate_initial_mem. rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. rewrite H6.

 unfold Genv.perm_globvar. rewrite VOL. rewrite preds_fmap_NoneP.

  destruct (gvar_readonly v);  repeat f_equal; auto with extensionality.

Qed.



Lemma init_data_list_size_app:

  forall dl1 dl2, init_data_list_size (dl1++dl2) =

                   init_data_list_size dl1 + init_data_list_size dl2.

Proof. induction dl1; intros; simpl; auto. rewrite IHdl1; omega.

Qed.



Lemma max_unsigned_modulus:

  Ptrofs.max_unsigned + 1 = Ptrofs.modulus.

Proof.

 unfold Ptrofs.max_unsigned. omega.

Qed.



Lemma init_data_list_lem:

  forall (ge: genv) m0 (v: globvar type) m1 b m2 m3 m4  phi0 rho,

     alloc m0 0 (init_data_list_size (gvar_init v)) = (m1,b) ->

     store_zeros m1 b 0 (init_data_list_size (gvar_init v)) = Some m2 ->

     Genv.store_init_data_list ge m2 b 0 (gvar_init v) = Some m3 ->

     drop_perm m3 b 0 (init_data_list_size (gvar_init v))

               (Genv.perm_globvar v) = Some m4 ->

  forall

   (Hg: noghost phi0) (SANITY: init_data_list_size (gvar_init v) < Ptrofs.modulus)

   (VOL:  gvar_volatile v = false)

   (AL: initializers_aligned 0 (gvar_init v) = true)

   (RHO: ge_of rho = filter_genv ge),

     init_data_list2pred (gvar_init v) (readonly2share (gvar_readonly v)) (Vptr b Ptrofs.zero)

            rho (beyond_block b (inflate_initial_mem m4 phi0)).

Proof.

intros.

set (phi := beyond_block b (inflate_initial_mem m4 phi0)).

assert (forall loc, fst loc <> b -> identity (phi @ loc)).

  unfold phi; intros.

  unfold beyond_block. rewrite only_blocks_at.

  if_tac; [ |  apply core_identity].

  unfold inflate_initial_mem.  rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'.

  unfold access_at.

  rewrite nextblock_noaccess. apply NO_identity.

  rewrite (nextblock_drop _ _ _ _ _ _ H2).

  rewrite (Genv.store_init_data_list_nextblock _ _ _ _ _ H1).

  rewrite (Genv.store_zeros_nextblock _ _ _ _ H0).

  assert (nextblock m1 = Pos.succ b /\ b = nextblock m0).

   clear - H. Transparent alloc. inv H.  simpl. auto. Opaque alloc.

 destruct H5; unfold block in *; xomega.

 assert (forall loc, if adr_range_dec (b,0)  (init_data_list_size (gvar_init v)) loc

                             then access_at m4 loc Cur = Some (Genv.perm_globvar v)

                             else identity (phi @ loc)).

  intro. if_tac.

     destruct loc; destruct H4; subst b0.

     unfold access_at. simpl. forget (Genv.perm_globvar v) as p.

      forget (init_data_list_size (gvar_init v)) as n.

     clear - H2 H5. unfold drop_perm in H2.

      destruct (range_perm_dec m3 b 0 n Cur Freeable); inv H2.

      simpl.  rewrite PMap.gss.

       destruct (zle 0 z); try omegaContradiction. destruct (zlt z n); try omegaContradiction.

       simpl; auto.

    destruct loc.

  destruct (eq_dec b b0). subst b0.

  unfold phi. unfold beyond_block. rewrite only_blocks_at.

   simpl. rewrite if_true by (unfold block; xomega).

  unfold inflate_initial_mem.  rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'.

  replace (access_at m4 (b,z) Cur) with (@None permission).

  apply NO_identity.

  symmetry.  transitivity (access_at m3 (b,z) Cur).

  clear - H4 H2. unfold access_at; unfold drop_perm in H2.

   destruct (range_perm_dec m3 b 0 (init_data_list_size (gvar_init v)) Cur

         Freeable); inv H2. simpl. rewrite PMap.gss.

  unfold adr_range in H4. destruct (zle 0 z); auto.

   destruct (zlt z (init_data_list_size (gvar_init v)) ); auto.

  contradiction H4. split; auto.

  transitivity (access_at m2 (b,z) Cur).

  apply store_init_data_list_outside' in H1.

  destruct H1 as [? [? ?]]; congruence.

  transitivity (access_at m1 (b,z) Cur).

  clear - H0. erewrite store_zeros_access; eauto.

  clear - H H4. Transparent alloc. inv H. Opaque alloc. unfold access_at; simpl.

  rewrite PMap.gss. destruct (zle 0 z); auto.

   destruct (zlt z (init_data_list_size (gvar_init v)) ); auto.

  contradiction H4. split; auto.

   apply H3. auto.

  clear H3.

  assert (contents_at m4 = contents_at m3).

  clear - H2; unfold contents_at, drop_perm in *.

   destruct (range_perm_dec m3 b 0 (init_data_list_size (gvar_init v)) Cur

         Freeable); inv H2. simpl. auto.

   clear H2.

   forget (gvar_init v) as dl.

   remember dl as D.

   rewrite HeqD in AL,H4|-*.

   assert (nil++dl=D) by (subst; auto).

   remember (@nil init_data) as dl'.

   remember (core phi) as w'.

   remember phi as w.

   assert (join w' w phi). subst. apply core_unit.

   unfold Ptrofs.zero.

   remember 0 as z. rewrite Heqz in H,H0,H1.

   replace z with (init_data_list_size dl') in AL,H4|-* by (subst; auto).

   clear z Heqz.

   assert (forall loc, if adr_range_dec (b,init_data_list_size dl') (init_data_list_size dl) loc

                               then identity (w' @ loc)  else identity (w @ loc)).

  intro. subst. if_tac. rewrite <- core_resource_at. apply core_identity.

  specialize (H4 loc). rewrite if_false in H4 by auto; auto.

  assert (noghost w) as Hgw.

  { subst w phi.

    unfold beyond_block, only_blocks, inflate_initial_mem; simpl.

    rewrite !ghost_of_make_rmap; auto. }

   clear Heqw' Heqw Heqdl' HeqD.

   revert dl' w' w AL H2 H4 H5 H6 Hgw; induction dl; simpl; intros.

   apply all_resource_at_identity; auto; intro loc.

   specialize (H6 loc); if_tac in H6; auto. destruct loc; destruct H7.

   omegaContradiction.

  assert (SANITY': init_data_list_size dl' + init_data_size a + init_data_list_size dl < Ptrofs.modulus).

  clear - H2 SANITY.

  subst D.

 rewrite init_data_list_size_app in SANITY. simpl in SANITY. omega.

  destruct (split_range w (b,init_data_list_size dl') (init_data_size a)) as [w1 [w2 [? ?]]]; auto.

  intros. apply (resource_at_join _ _ _ loc) in H5.

  specialize (H6 loc). rewrite if_true in H6. apply H6 in H5.

  rewrite H5.

    unfold phi; clear. unfold beyond_block. rewrite only_blocks_at.

   if_tac; [ |   destruct (inflate_initial_mem m4 phi0 @ loc);

                [rewrite core_NO | rewrite core_YES | rewrite core_PURE]; auto].

  unfold inflate_initial_mem; rewrite resource_at_make_rmap.

  unfold inflate_initial_mem'. destruct (access_at m4 loc); try destruct p; simpl; auto.

  destruct (phi0 @ loc); auto.

  destruct loc. destruct H7; split; auto.

  pose proof (init_data_list_size_pos dl).

  omega.

  exists w1; exists w2; split3; auto.

  clear IHdl.

  destruct (join_assoc H7 (join_comm H5)) as [wf [? ?]].

  assert (forall loc, if adr_range_dec (b,init_data_list_size dl') (init_data_size a) loc

                                 then identity (wf @ loc) /\

                                         access_at m4 loc Cur = Some (Genv.perm_globvar v)

                                 else identity (w1 @ loc)).

     intro. specialize (H8 loc); specialize (H6 loc); specialize (H4 loc).

       apply (resource_at_join _ _ _ loc) in H9;

       apply (resource_at_join _ _ _ loc) in H10.

 if_tac.  rewrite if_true in H6,H4. apply H8 in H9. rewrite <- H9; auto.

   destruct loc; destruct H11; subst b0. split; auto.

   pose proof (init_data_list_size_pos dl); omega.

   destruct loc; destruct H11; subst b0. split; auto.

   pose proof (init_data_list_size_pos dl); omega.

 auto.

  pose proof (load_store_init_data_lem1 H0 H1 _ _ _ H2).

  unfold phi in *; clear phi.

  eapply init_data_lem; try eassumption.

  apply ghost_of_join in H7.

  simpl; eapply split_identity; eauto.

  clear - AL. apply andb_true_iff in AL. destruct AL; auto.

  pose proof (init_data_list_size_pos dl'); omega.

  pose proof (init_data_list_size_pos dl); omega.

  destruct (join_assoc (join_comm H7) (join_comm H5)) as [wg [? ?]].

  specialize (IHdl  (dl' ++ (a::nil))  wg w2).

  replace (init_data_list_size (dl' ++ a :: nil)) with

             (init_data_list_size dl' + init_data_size a) in IHdl.

  rewrite Ptrofs.add_unsigned.

  repeat rewrite Ptrofs.unsigned_repr

       by (pose proof (init_data_list_size_pos dl'); pose proof (init_data_list_size_pos dl);

      pose proof (init_data_size_pos a); pose proof max_unsigned_modulus; omega).

  apply IHdl; auto.

  apply andb_true_iff in AL; destruct AL; auto.

  rewrite app_ass; auto.

  intro loc; specialize (H6 loc); specialize (H8 loc); specialize (H4 loc).

  if_tac. rewrite if_true in H4; auto.

  destruct loc; destruct H11; auto.

  split; auto.

  pose proof (init_data_size_pos a); omega.

  if_tac in H8; auto.

  rewrite if_false in H6.

  apply join_comm in H5.

  apply (resource_at_join _ _ _ loc) in H7.

  apply H8 in H7. rewrite H7; auto.

  destruct loc.

  intros [? ?]. subst b0.

  forget (init_data_list_size dl') as u.

 destruct (zlt z (u + init_data_size a)).

 apply H12.  split; auto. omega.

 apply H11.  split; auto. omega.

  intro loc. specialize (H4 loc); specialize (H6 loc); specialize (H8 loc).

  apply (resource_at_join _ _ _ loc) in H7.

  apply (resource_at_join _ _ _ loc) in H9.

  apply (resource_at_join _ _ _ loc) in H10.

  apply (resource_at_join _ _ _ loc) in H5.

 destruct loc.

  if_tac in H8.

  rewrite if_false; auto.

 clear - H11; destruct H11; intros [? ?]. omega.

  if_tac in H4.

  rewrite if_true.

  apply H8 in H9. rewrite <- H9 in *. auto.

  destruct H12; subst b0. split; auto.

  forget (init_data_list_size dl') as u.

  assert (~ (u <= z < u + init_data_size a)) by (contradict H11; destruct H11; split; auto; omega).

  omega.

 rewrite if_false. apply H8 in H7. rewrite H7; auto.

 contradict H12. destruct H12; split; auto.

  pose proof (init_data_size_pos a); omega.

  apply ghost_of_join, join_comm in H7.

  simpl; eapply split_identity; eauto.

 clear.

  induction dl'; simpl; intros; try omega.

Qed.



Definition all_initializers_aligned (prog: program) :=

  forallb (fun idv => andb (initializers_aligned 0 (gvar_init (snd idv)))

                                 (Zlt_bool (init_data_list_size (gvar_init (snd idv))) Ptrofs.modulus))

                      (prog_vars prog) = true.



Lemma forallb_rev: forall {A} f (vl: list A), forallb f (rev vl) = forallb f vl.

Proof. induction vl; simpl; auto.

  rewrite forallb_app. rewrite IHvl. simpl. rewrite andb_comm.

  rewrite <- andb_assoc. f_equal; auto.

Qed.



Lemma store_init_data_list_access:

  forall  {F V} (ge: Genv.t F V) m b z dl m',

     Genv.store_init_data_list ge m b z dl = Some m' ->

     access_at m = access_at m'.

Proof.

  intros. revert z m m' H; induction dl; simpl; intros.

  inv H; auto.

 invSome.

  transitivity (access_at m0).

  clear - H.

  destruct a; simpl in H;

   try solve [unfold access_at; extensionality loc; rewrite (store_access _ _ _ _ _ _ H); auto].

  inv H; auto. invSome.

  unfold access_at; extensionality loc; rewrite (store_access _ _ _ _ _ _ H2); auto.

  eapply IHdl; eauto.

Qed.



Lemma rev_prog_funct': forall {F V} vl, rev (@prog_funct' F V vl) = prog_funct' (rev vl).

Proof.

   intros.

   induction vl. simpl; auto.

   destruct a. destruct g.

   simpl.

   transitivity (prog_funct' (rev vl) ++ (@prog_funct' F V ((i,Gfun f)::nil))).

    rewrite IHvl. f_equal.

    simpl.

    clear.

    induction (rev vl); simpl; intros; auto.

    destruct a. destruct g.

    auto.

    rewrite <- IHl.

    simpl. auto.

    simpl; auto.

    simpl. rewrite IHvl.

    clear.

    induction (rev vl); simpl; intros; auto. destruct a. destruct g.

    f_equal; auto. auto.

Qed.



Lemma alloc_global_beyond2:

  forall {F V} (ge: Genv.t F V) m iv m', Genv.alloc_global ge m iv = Some m' ->

       forall loc, (fst loc > nextblock m)%positive ->

        access_at m' loc Cur = None.

Proof.

 intros.

 destruct loc as [b ofs]; simpl in *.

 unfold access_at, Genv.alloc_global in *.

Transparent alloc.

 destruct iv; destruct g; simpl @fst; simpl @ snd;

 [forget 1 as N |  forget  (init_data_list_size (gvar_init v)) as N];

 revert H; case_eq (alloc m 0 N); intros; repeat invSome;

 match goal with H: drop_perm ?m _ _ _ _ = _ |- _ =>

   unfold drop_perm in H;

  destruct (range_perm_dec m b0 0 N Cur Freeable); inv H

 end;

  inv H; simpl in *;

 repeat rewrite PMap.gss;

 repeat rewrite PMap.gso by (intro Hx; inv Hx; xomega);

 try (apply nextblock_noaccess; xomega).

 apply store_zeros_access in H1.

 apply store_init_data_list_outside' in H4.

 destruct H4 as [? [? ?]]. rewrite H2 in H1.

 change (access_at m2 (b,ofs) Cur = None).

 rewrite H1. unfold access_at; simpl.

 repeat rewrite PMap.gso by (intro Hx; inv Hx; xomega).

 apply nextblock_noaccess; xomega.

Qed.



Lemma alloc_global_access:

 forall {F V} (ge: Genv.t F V) m i v m', Genv.alloc_global ge m (i, Gvar v) = Some m' ->

  forall z, access_at m' (nextblock m, z) Cur =

                    if range_dec 0 z (init_data_list_size (gvar_init v))

                    then Some (Genv.perm_globvar v) else None.

Proof.

intros.

unfold Genv.alloc_global in H.

forget (init_data_list_size (gvar_init v)) as N.

revert H; case_eq (alloc m 0 N); intros.

invSome. invSome.

unfold drop_perm in H4.

destruct (range_perm_dec m2 b 0 N Cur Freeable); inv H4.

unfold access_at. simpl.

apply store_zeros_access in H0.

apply store_init_data_list_access in H3.

rewrite H0 in H3. clear m1 H0.

inv H. unfold access_at in H3. simpl in *.

apply equal_f with (nextblock m, z) in H3. apply equal_f with Cur in H3.

simpl in H3. rewrite PMap.gss in *.

destruct (zle 0 z). simpl. destruct (zlt z N).

simpl in *.

rewrite if_true; auto. rewrite if_false; auto.

 intros [? ?]. xomega.

simpl. rewrite if_false by omega.

simpl in H3; auto.

Qed.



Lemma alloc_global_inflate_same:

  forall n i v gev m G m0,

  Genv.alloc_global gev m0 (i, Gvar v) = Some m ->

   (forall z : Z, initial_core gev G n @ (nextblock m0, z) = NO Share.bot bot_unreadable) ->

   inflate_initial_mem m0 (initial_core gev G n) =

   upto_block (nextblock m0) (inflate_initial_mem m (initial_core gev G n)).

Proof.

 intros.

 apply rmap_ext.

  unfold upto_block, inflate_initial_mem;

  rewrite level_only_blocks; repeat rewrite level_make_rmap. auto.

 intro loc.

 unfold upto_block. rewrite only_blocks_at.

 unfold inflate_initial_mem.

 repeat rewrite resource_at_make_rmap.

 if_tac.

 destruct (alloc_global_old _ _ _ _ H _ H1) as [? ?];

 unfold inflate_initial_mem'; rewrite H2; rewrite H3; auto.

 destruct (eq_dec (fst loc) (nextblock m0)).

 2:{

 assert (access_at m loc Cur = None).

  eapply alloc_global_beyond2; try eassumption. unfold block in *; xomega.

 assert (access_at m0 loc Cur = None).

  unfold access_at. apply nextblock_noaccess. auto.

 unfold inflate_initial_mem'; rewrite H2; rewrite H3; auto.

 rewrite core_NO; auto.

 }

 clear H1.

 specialize (H0 (snd loc)).

 assert (access_at m0 loc Cur = None).

  unfold access_at. apply nextblock_noaccess. rewrite <- e; xomega.

 unfold inflate_initial_mem' at 1. rewrite H1.

  unfold inflate_initial_mem'.

 destruct loc; simpl in e; subst.

 rewrite (alloc_global_access _ _ _ _ _ H).

 if_tac. unfold Genv.perm_globvar. simple_if_tac. simpl in H0. rewrite H0. rewrite core_NO; auto.

  simple_if_tac; rewrite core_YES; auto.

 rewrite core_NO; auto.

 unfold upto_block, only_blocks, inflate_initial_mem; rewrite !ghost_of_make_rmap; auto.

Qed.



Lemma find_id_rev: forall i G,

 list_norepet (map fst G) -> find_id i (rev G) = find_id i G.

Proof.

intros.

induction G; simpl; intros; auto.

inv H. destruct a. simpl in *. specialize (IHG H3).

if_tac. subst.

clear - H2.

rewrite In_rev in H2. rewrite <- map_rev in H2.

 induction (rev G); simpl; auto. rewrite if_true; auto.

 destruct a;  simpl in *.

 if_tac. subst. intuition. apply IHl; intuition.

 rewrite <- IHG. clear IHG.

 clear - H.

 induction (rev G); simpl; auto. rewrite if_false; auto.

 destruct a; simpl in *. if_tac; auto.

Qed.



Definition prog_var_block (rho: environ) (il: list ident) (b: block) : Prop :=

  Exists (fun id => match ge_of rho id with Some b' => b'=b | _ => False end) il.



Lemma match_fdecs_in:

  forall i vl G,

     In i (map (@fst _ _) G) ->

     match_fdecs vl G ->

     In i (map (@fst _ _) vl).

Proof.

 induction vl; simpl; intros; auto.

 inv H0. inv H.

 inv H0.

 destruct H. inv H. simpl; auto.

 right. apply (IHvl G0); auto.



Qed.



Lemma match_fdecs_norepet:

  forall vl G,

     list_norepet (map (@fst _ _) vl) ->

     match_fdecs vl G ->

     list_norepet (map (@fst _ _) G).

Proof.

 induction vl; simpl; intros.

 inv H0. constructor.

 inv H0. inv H.

 simpl.

 constructor; auto.

 contradict H2. eapply match_fdecs_in; eauto.



Qed.



Lemma list_norepet_prog_funct':

  forall A B (vl: list (ident * globdef A B)),

        list_norepet (map (@fst _ _) vl) ->

       list_norepet (map (@fst _ _) (prog_funct' vl)).

Proof.

 induction vl; simpl; intros.

 constructor.

 inv H. destruct a as [i [?|?]].

 simpl. constructor; auto.

 simpl in H2. contradict H2.

 clear - H2; induction vl; simpl in *; auto. destruct a.

 destruct g; simpl in *; auto. destruct H2; auto.

 apply IHvl; auto.

Qed.



Lemma match_fdecs_rev':

  forall vl G vl' G',

   list_norepet (map (@fst _ _) (rev vl ++ vl')) ->

   match_fdecs vl G ->

   match_fdecs vl' G' ->

   match_fdecs (rev vl ++ vl') (rev G ++ G').

Proof.

induction vl; intros.

simpl in *.

destruct G; inv H0. apply H1.

destruct a.

inv H0.

simpl. do 2 rewrite app_ass.

simpl.

apply IHvl.

clear - H.

simpl rev in *.

repeat rewrite map_app in H.

repeat rewrite map_app.

simpl in H|-*.

repeat rewrite map_app in H.

simpl in H.

rewrite list_norepet_app.

repeat rewrite list_norepet_app in H.

decompose [and] H; clear H.

clear H0.

repeat split; auto.

constructor; auto.

intro.

apply (H5 i i); auto.

apply in_app. right; left; auto.

intros j k ? ? ?; subst k.

apply (H5 j j).

rewrite in_app.

destruct H0. right; left; auto.

left; rewrite map_rev, <- in_rev; auto.

rewrite map_rev, <- in_rev in H; auto.

destruct H0; auto.

subst j. specialize (H4 i i). contradiction H4; auto.

left; auto.

auto.

auto.

constructor 2; auto.



Qed.



Lemma match_fdecs_rev:

  forall vl G,

   list_norepet (map (@fst _ _) vl) ->

   match_fdecs (rev vl) (rev G) = match_fdecs vl G.

Proof.

  intros; apply prop_ext; split; intros.

*

  rewrite (app_nil_end vl).

  rewrite (app_nil_end G).

  rewrite <- (rev_involutive vl), <- (rev_involutive G).

  apply match_fdecs_rev'; auto.

  rewrite rev_involutive, <- app_nil_end; auto.

  constructor.

*

  rewrite (app_nil_end (rev vl)).

  rewrite (app_nil_end (rev G)).

  apply match_fdecs_rev'; auto.

  rewrite <- app_nil_end.

  rewrite map_rev. rewrite list_norepet_rev; auto.

  constructor.

Qed.



Lemma initial_core_rev:

  forall (gev: Genv.t fundef type) G n (vl: list (ident * globdef fundef type))

    (H: list_norepet (map fst (rev vl)))

    (SAME_IDS : match_fdecs (prog_funct' vl) (rev G)),

    initial_core gev G n = initial_core gev (rev G) n.

Proof.

  intros.

     unfold initial_core;  apply rmap_ext.

+   repeat rewrite level_make_rmap; auto.

+   intro loc; repeat rewrite resource_at_make_rmap; unfold initial_core'.

    if_tac; auto. case_eq (@Genv.invert_symbol (Ctypes.fundef function) type gev (@fst block Z loc)); intros; auto.

    replace (find_id i G) with (find_id i (rev G)); auto.

    clear - H SAME_IDS.

    assert (list_norepet (map (@fst _ _) (rev G))).

     eapply match_fdecs_norepet; eauto.

   clear - H; induction vl; simpl in *; auto.

   destruct a; destruct g; simpl in *; auto.

   rewrite map_app in H. rewrite list_norepet_app in H.

   destruct H as [? [? ?]]. constructor; auto.

   simpl in H1.

   apply list_disjoint_sym in H1.

   pose proof (list_disjoint_notin i H1).

   inv H0. spec H2. left; auto. contradict H2.

   rewrite map_rev. rewrite <- in_rev.

   clear - H2.

   induction vl; simpl in *; auto. destruct a. destruct g.

   destruct H2. simpl in *; left; auto. right; auto. right; auto. 

   rewrite map_app, list_norepet_app in H.   destruct H as [? [? ?]]; auto. 

    apply find_id_rev; auto.

    rewrite <- list_norepet_rev, <- map_rev. auto.

+ rewrite !ghost_of_make_rmap; auto.

Qed.



Definition hackfun phi0 phi :=

  level phi0 = level phi /\ ghost_of phi0 = ghost_of phi /\

  forall loc, (identity (phi0 @ loc) <-> identity (phi @ loc)) /\

                  (~identity (phi0 @ loc) -> (phi0 @ loc = phi @ loc)).



Lemma alloc_Gfun_inflate:

  forall n rho i f fs gv vl gev m0 m G0 G,

   Genv.alloc_global gev m0 (i, Gfun f) = Some m ->

   (forall phi : rmap,

    hackfun (inflate_initial_mem m0 (initial_core gev (G0 ++ (i, fs) :: G) n))

      phi ->

  (globvars2pred gv vl rho) phi) ->

  Genv.find_symbol gev i = Some (nextblock m0) ->

  ~ In i (map fst vl) ->

  forall phi : rmap,

  hackfun (inflate_initial_mem m (initial_core gev (G0 ++ (i, fs) :: G) n)) phi ->

      (globvars2pred gv vl rho) phi.

Proof.

 intros.

 apply H0.

 destruct H3 as [H3' [Hg H3]]; split. rewrite inflate_initial_mem_level in H3'|-*; auto.

 split.

 { unfold inflate_initial_mem in *; rewrite ghost_of_make_rmap in *; auto. }

 intro loc; specialize (H3 loc).

 clear - H3 H2 H1 H.

 assert (exists fs', find_id i (G0 ++ (i,fs)::G) = Some fs').

 clear. induction G0; simpl. exists fs; rewrite if_true; eauto.

 destruct IHG0 as [fs' ?]. destruct a. if_tac. subst i0; exists f; auto.

 eauto.

 forget (G0++(i,fs)::G) as GG.  clear G0 fs G.

 destruct H0 as [fs H0].

 destruct H3.

 destruct (eq_dec loc (nextblock m0, 0)).

 subst loc.

 unfold inflate_initial_mem in *.

 rewrite resource_at_make_rmap in *.

 unfold inflate_initial_mem' in *.

 replace (access_at m0 (nextblock m0, 0) Cur) with (@None permission) in *.

 replace (access_at m (nextblock m0, 0) Cur) with (Some Nonempty) in *.

 unfold initial_core in *. rewrite resource_at_make_rmap in *.

 unfold initial_core' in *.

 simpl in *.

 rewrite (Genv.find_invert_symbol gev i H1) in H3,H4. rewrite H0 in *. destruct fs.

 rewrite <- H3.

 split.

 split; intro. apply PURE_identity. apply NO_identity. intro. contradiction H5.

 apply NO_identity.

 symmetry. clear - H.

  unfold Genv.alloc_global in H.

  revert H; case_eq (alloc m0 0 1); intros. unfold drop_perm in H0.

  destruct (range_perm_dec m1 b 0 1 Cur Freeable); inv H0.

  unfold access_at; simpl. apply alloc_result in H; subst b. rewrite PMap.gss.

 destruct (zle 0 0); try omegaContradiction. destruct (zlt 0 1); try omegaContradiction; simpl. auto.

 symmetry. apply nextblock_noaccess. simpl; unfold block; clear; xomega.

 replace (inflate_initial_mem m0 (initial_core gev GG n) @ loc)

   with (inflate_initial_mem m (initial_core gev GG n) @ loc); auto.

 clear - n0 H.

 unfold inflate_initial_mem; repeat rewrite resource_at_make_rmap.

 unfold inflate_initial_mem'.

 assert (H8: access_at m0 loc = access_at m loc); [ | rewrite H8; auto].

  unfold Genv.alloc_global in H.

  revert H; case_eq (alloc m0 0 1); intros. unfold drop_perm in H0.

  destruct (range_perm_dec m1 b 0 1 Cur Freeable); inv H0.

  unfold alloc; inv H. unfold access_at; simpl.

  destruct loc as [b z]; simpl in *.

  destruct (eq_dec b (nextblock m0)).

  subst. repeat rewrite PMap.gss. assert (z<>0) by congruence.

  destruct (zle 0 z). simpl. destruct (zlt z 1); try omegaContradiction. simpl.

  extensionality k.

  apply nextblock_noaccess. xomega.

   destruct (zlt z 1); try omegaContradiction. simpl.

  extensionality k.

  apply nextblock_noaccess. xomega.

 rewrite PMap.gss. rewrite PMap.gso by auto. rewrite PMap.gso by auto. auto.

 case_eq (access_at m loc Cur); auto.

  unfold Genv.alloc_global in H.

  revert H; case_eq (alloc m0 0 1); intros. unfold drop_perm in H0.

  destruct (range_perm_dec m1 b 0 1 Cur Freeable); inv H0.

  unfold contents_at; simpl. unfold access_at in H1; simpl in H1.

  destruct (eq_dec b (fst loc)). subst. rewrite PMap.gss in H1.

  destruct (zle 0 (snd loc)); simpl in H1; auto.

  destruct (zlt (snd loc) 1); simpl in H1; auto. assert (snd loc = 0) by omega.

  destruct loc; apply alloc_result in H; simpl in *; congruence.

 clear r H8. inv H. simpl in *. rewrite H3 in *; rewrite PMap.gss in *.

  destruct (zle 0 (snd loc)); try omegaContradiction.

  destruct (zlt (snd loc) 1); try omegaContradiction. inv H1; auto.

  clear H8 r. inv H. simpl in H1; rewrite <- H3 in H1; rewrite PMap.gss in H1.

  destruct (zle 0 (snd loc)); try omegaContradiction.

  destruct (zlt (snd loc) 1); try omegaContradiction. inv H1; auto.

  rewrite PMap.gso in H1 by auto.

  replace (PMap.get (fst loc) (mem_contents m1)) with (PMap.get (fst loc) (mem_contents m0)); auto.

  inv H; simpl. rewrite PMap.gso; auto.

Qed.



Lemma resource_identity_dec:

 forall (r: resource), {identity r}+{~identity r}.

Proof.

intros. destruct r.

destruct (eq_dec sh Share.bot).

subst; left; apply NO_identity.

right. intro. apply identity_NO in H.

destruct H. inv H. contradiction n0; auto.

destruct H as [? [? ?]]. inv H.

 right; apply YES_not_identity.

left; apply PURE_identity.

Qed.



Lemma hackfun_sep:

 forall w1 w2 w w', hackfun w w' -> join w1 w2 w ->

   exists w1', exists w2', join w1' w2' w' /\ hackfun w1 w1' /\ hackfun w2 w2'.

Proof.

intros.

 pose proof I.

 destruct (make_rmap (fun loc => if resource_identity_dec (w1 @ loc) then core (w' @ loc) else w1 @ loc) (ghost_of w1) (level w))  as [w1' [? ?]]; clear H1.

 extensionality loc.

 unfold compose. if_tac. rewrite core_resource_at.

 replace (level w) with (level w') by (destruct H; auto).

 rewrite <- level_core. apply resource_at_approx.

 replace (level w) with (level w1) by (apply join_level in H0; destruct H0; auto).

 apply resource_at_approx.

 destruct (join_level _ _ _ H0) as [<- _].

 apply ghost_of_approx.

 pose proof I.

 destruct (make_rmap (fun loc => if resource_identity_dec (w2 @ loc) then core (w' @ loc) else w2 @ loc) (ghost_of w2) (level w))  as [w2' [? ?]]; clear H1.

 extensionality loc.

 unfold compose. if_tac. rewrite core_resource_at.

 replace (level w) with (level w') by (destruct H; auto).

 rewrite <- level_core. apply resource_at_approx.

 replace (level w) with (level w2) by (apply join_level in H0; destruct H0; auto).

 apply resource_at_approx.

 destruct (join_level _ _ _ H0) as [_ <-]; apply ghost_of_approx.

 exists w1'; exists w2'; split3.

 apply resource_at_join2. destruct H; congruence. destruct H; congruence.

 intro loc; apply (resource_at_join _ _ _ loc) in H0. destruct H3 as [-> _], H5 as [-> _].

 destruct H. destruct H1 as [Hg H1], (H1 loc).

 if_tac. apply H6 in H0. rewrite H0.

 if_tac.  apply H3 in H7. apply identity_core in H7.

 rewrite <- H7 at 2. apply core_unit.

 rewrite H5 by auto. apply core_unit.

 spec H5. contradict H6; apply split_identity in H0; auto. rewrite <- H5.

 if_tac. apply join_comm in H0. apply H7 in H0. rewrite H0. apply join_comm; apply core_unit.

 auto.

 destruct H3 as [_ ->], H5 as [_ ->].

 destruct H as (? & <- & _).

 apply ghost_of_join; auto.

 destruct H; split. apply join_level in H0; destruct H0; congruence.

 destruct H3 as [H3 ->]; split; auto.

 intro loc. rewrite H3. clear - H1. if_tac. pose (core_identity (w' @ loc)). intuition.

 intuition.

 destruct H; split. apply join_level in H0; destruct H0; congruence.

 destruct H5 as [H5 ->]; split; auto.

 intro loc. rewrite H5. clear - H1. if_tac. pose (core_identity (w' @ loc)). intuition.

 intuition.

Qed.



Lemma init_datalist_hack:

  forall b sh rho dl phi0 z,

   (init_data_list2pred dl sh (Vptr b z) rho) phi0 ->

  forall phi,

     hackfun phi0 phi ->

   readable_share sh ->

   (init_data_list2pred dl sh (Vptr b z) rho) phi.

Proof.

  induction dl; intros. destruct H0 as [H0' [Hg H0]]. simpl in *.

  apply all_resource_at_identity. intro loc; destruct (H0 loc).

  apply (resource_at_identity _ loc) in H. apply H2; auto.

  rewrite <- Hg; apply ghost_of_identity; auto.



  rename H1 into H_READABLE.

 simpl init_data_list2pred in H|-*.

 destruct H as [w1 [w2 [? [? ?]]]].

 destruct (hackfun_sep _ _ _ _ H0 H) as [w1' [w2' [? [? ?]]]].

 exists w1'; exists w2'; split3; auto.

 2: eapply IHdl; eauto.

 clear - H_READABLE H1 H4. destruct H4 as [H4' [Hg H4]].



  unfold init_data2pred in *;

  unfold mapsto, address_mapsto in *;

  destruct a; simpl in *;

  (destruct (readable_share_dec sh); [| tauto]);

  try

  (destruct H1 as [[H1' H1]|[H1x _]]; [|solve[inv H1x]];

        left; split;

    [ first [ apply I

           | apply sign_ext_range'; compute; split; congruence

           | apply zero_ext_range'; compute; split; congruence ]

    | simpl in H1 |- *;

      destruct H1 as [bl [[? H8] Hg']]; exists bl; split; [|rewrite <- Hg; auto]; split; [assumption | ]; intro loc; specialize (H8 loc);

      if_tac; [ destruct H8 as [p H8]; exists p; destruct (H4 loc) as [_ H5];

                rewrite <- H5; [rewrite H8; auto| rewrite H8; apply YES_not_identity]

              | destruct (H4 loc) as [HH _]; clear - H8 HH; intuition]]).

 rewrite address_mapsto_zeros_eq in H1|-*.

 rewrite nat_of_Z_max in *.

 split.  destruct H1; omega.

 destruct H1 as [H1' [H1 Hg1]]; split; [|simpl; rewrite <- Hg; auto].

 intro loc; specialize (H1 loc).

 assert (H99:  Z.max (Z.max z0 0) 0 = Z.max z0 0).

   apply Z.max_l. apply Zmax_bound_r. omega.

 rewrite H99 in *.

 hnf in H1|-*.

 if_tac; [destruct H1 as [p H1]; exists p; hnf in H1|-*; rewrite <- H4'; destruct (H4 loc) as [_ H5]

          | destruct (H4 loc) as [HH _]; intuition].

 rewrite <- H5; auto. rewrite H1; apply YES_not_identity.



 destruct (Map.get (ge_of rho) i); try destruct p; auto.

 destruct H1 as [[H1' H1]|[H1' H1]];  [left|right]; split; auto.

 destruct H1 as [bl [[? H8] Hg1]].

 exists bl; split; [|simpl; rewrite <- Hg; auto]; split; [assumption | ]; intro loc; specialize (H8 loc).

 destruct (H4 loc).

 hnf in H8|-*; if_tac. destruct H8 as [p H8]; exists p; hnf in H8|-*.

  rewrite <- H4'; rewrite <- H1; auto. rewrite H8; apply YES_not_identity.

 intuition.

 destruct H1 as [bl [? H8]].

 exists bl,x. destruct H8 as [[H8' H8] Hg1].

 split; [|simpl; rewrite <- Hg; auto].

 split; [assumption | ]; intro loc; specialize (H8 loc).

 destruct (H4 loc).

 hnf in H8|-*; if_tac. destruct H8 as [p H8]; exists p; hnf in H8|-*.

  rewrite <- H4'. rewrite <- H0. rewrite H8. reflexivity.

 rewrite H8.

 apply YES_not_identity.

 intuition.

 unfold mapsto_ in *.

 unfold mapsto in *.

  simpl in *.

 rewrite if_true in H1|-* by auto.

 destruct H1. destruct H. contradiction. destruct H as [ _ ?].

 right. split. hnf; auto.

 destruct H as [v2' ?]; exists v2'.

 destruct H as [x ?]; exists x.

 destruct H; split; auto.

 destruct H; split; auto.

 intros loc; specialize (H1 loc).

 destruct (H4 loc).

 rename H1 into H8.

 hnf in H8|-*; if_tac. destruct H8 as [p H8]; exists p; hnf in H8|-*.

  rewrite <- H4'; rewrite <- H3; auto. rewrite H8; apply YES_not_identity.

 intuition.

 hnf in H0|-*. rewrite <- Hg; auto.

Qed.



Lemma another_hackfun_lemma:

 forall n i v gev m G phi m0,

    hackfun (inflate_initial_mem m (initial_core gev G n)) phi ->

    Genv.alloc_global gev m0 (i, Gvar v) = Some m ->

    hackfun (inflate_initial_mem m0 (initial_core gev G n))

      (upto_block (nextblock m0) phi).

Proof.

 intros. destruct H; split.

 rewrite inflate_initial_mem_level in H|-*.

 unfold upto_block. rewrite level_only_blocks. auto.

 clear H; rename H1 into H.

 destruct H as [Hg H]; split.

 { unfold upto_block, only_blocks, inflate_initial_mem in *; rewrite !ghost_of_make_rmap in *; auto. }

 intro loc; specialize (H loc).

 destruct (plt (fst loc) (nextblock m0)).

 unfold upto_block. rewrite only_blocks_at. rewrite if_true by auto.

 replace (inflate_initial_mem m0 (initial_core gev G n) @ loc)

   with (inflate_initial_mem m (initial_core gev G n) @ loc); auto.

 try rename p into z.   

 clear - z H0.

 unfold inflate_initial_mem; repeat rewrite resource_at_make_rmap.

 unfold inflate_initial_mem'.

 destruct (alloc_global_old _ _ _ _ H0 _ z) as [? ?]. rewrite H; rewrite H1; auto.

 unfold upto_block. rewrite only_blocks_at. rewrite if_false by auto.

 unfold inflate_initial_mem; repeat rewrite resource_at_make_rmap;

   unfold inflate_initial_mem'.

 replace (access_at m0 loc Cur) with (@None permission).

 clear.

 pose proof (core_identity (phi @ loc)).

 assert (identity (NO Share.bot bot_unreadable)) by apply NO_identity.

 intuition.

 symmetry; apply nextblock_noaccess. auto.

Qed.



Lemma hackfun_beyond_block:

  forall b w w', hackfun w w' -> hackfun (beyond_block b w) (beyond_block b w').

Proof.

 intros. destruct H.

 split. unfold beyond_block. repeat rewrite level_only_blocks. auto.

 clear H. destruct H0 as [Hg H0]; split.

 { unfold beyond_block, only_blocks; rewrite !ghost_of_make_rmap; auto. }

 intro loc; specialize (H0 loc).

 unfold beyond_block. repeat  rewrite only_blocks_at. if_tac. auto.

 clear. pose proof (core_identity (w @ loc)); pose proof (core_identity (w' @ loc)); intuition.

Qed.



Lemma Pos_to_nat_eq_S:

  forall b, Pos.to_nat b = S (nat_of_Z (Z.pos b) - 1).

Proof. intros. simpl; pose proof (Pos2Nat.is_pos b); omega.

Qed.



Lemma alloc_global_inflate_initial_eq:

  forall gev m0 i f m G n loc,

      Genv.alloc_global gev m0 (i, Gfun f) = Some m ->

   ~ identity (inflate_initial_mem m0 (initial_core gev G n) @ loc) ->

     inflate_initial_mem m0 (initial_core gev G n) @ loc =

      inflate_initial_mem m (initial_core gev G n) @ loc.

Proof.

intros. rename H0 into H9.

unfold inflate_initial_mem. simpl. rewrite !resource_at_make_rmap.

unfold inflate_initial_mem'.

destruct loc.

destruct (plt b (nextblock m0)).

*

destruct (alloc_global_old gev _ _ _ H (b,z) p) as [? ?].

rewrite H0,H1. auto.

*

contradiction H9; clear H9.

unfold inflate_initial_mem. simpl. rewrite !resource_at_make_rmap.

unfold inflate_initial_mem'.

unfold access_at; rewrite nextblock_noaccess.

apply NO_identity.

apply n0.

Qed.



 Lemma alloc_global_identity_lemma3:

   forall gev m0 i f m G n loc,

    Genv.alloc_global gev m0 (i, Gfun f) = Some m ->

    identity (inflate_initial_mem m (initial_core gev G n) @ loc) ->

    identity (inflate_initial_mem m0 (initial_core gev G n) @ loc).

Proof.

intros until 1.

unfold inflate_initial_mem. simpl. rewrite !resource_at_make_rmap.

unfold inflate_initial_mem'.

 intros.

  destruct (adr_range_dec (nextblock m0, 0) 1 loc).

  destruct loc; destruct a. subst b. assert (z=0) by omega. subst z.

  unfold access_at; rewrite nextblock_noaccess. apply NO_identity.

  simpl. apply Plt_strict.

  destruct (plt (fst loc) (nextblock m0)).

  destruct (alloc_global_old _ _ _ _ H _ p) as [? ?].

  rewrite H1,H2. auto.

  unfold access_at. rewrite nextblock_noaccess by auto.

  apply NO_identity.

Qed.



Lemma identity_inflate_at_Gfun:

  forall n i f gev m G0 G loc m0,

 list_norepet (map fst (G0 ++ G)) ->

 Genv.find_symbol gev i = Some (nextblock m0) ->

 Genv.alloc_global gev m0 (i, Gfun f) = Some m ->

 In i (map fst G) ->

 (identity (inflate_initial_mem m0 (initial_core gev (G0 ++ G) n) @ loc) <->

 identity (inflate_initial_mem m (initial_core gev (G0 ++ G) n) @ loc)).

Proof.

intros until m0. intros NR H8 ? ?.

destruct (eq_dec loc (nextblock m0, 0)).

*

subst loc.

unfold initial_core.

unfold inflate_initial_mem.

rewrite !resource_at_make_rmap.

unfold inflate_initial_mem'.

rewrite !resource_at_make_rmap.

rewrite nextblock_access_empty

  by (apply Pos2Nat.inj_ge; omega).

split; intros _; [ |apply NO_identity].

unfold Genv.alloc_global in H.

destruct (alloc m0 0 1) eqn:?.

assert (H9: 0 <= 0 < 1) by (clear; omega).

assert (H6 := alloc_result _ _ _ _ _ Heqp); subst b.

assert (H1 := perm_drop_1 _ _ _ _ _ _ H 0 Cur H9).

destruct (perm_mem_access _ _ _ _ H1) as [p [H4 H5]].

assert (H2 := perm_drop_2 _ _ _ _ _ _ H 0 Cur p H9).

rewrite H5.

unfold perm in *.

unfold access_at in H5. simpl in H5. destruct ((mem_access m) !! (nextblock m0) 0 Cur); inv H5.

spec H2; [constructor | ].

destruct p; try solve [inv H2].

unfold initial_core'. simpl.

rewrite Genv.find_invert_symbol with (id:=i) by auto.

destruct (list_in_map_inv _ _ _ H0) as [[i' fd] [H10 H11]]; simpl in H10, H11.

subst i'.

rewrite find_id_i with (fs:=fd); auto.

destruct fd.

apply PURE_identity.

apply in_app. right; auto.

*

clear NR.

unfold initial_core.

unfold inflate_initial_mem.

rewrite !resource_at_make_rmap.

unfold inflate_initial_mem'.

rewrite !resource_at_make_rmap.

pose proof (Pos.ltb_spec (fst loc) (nextblock m0)).

destruct ((fst loc <? nextblock m0)%positive); inv H1.

destruct (alloc_global_old _ _ _ _ H loc H2) as [? ?].

rewrite H3.

rewrite H1; split; intro; auto.

destruct loc as [b ofs]. simpl fst in *; simpl snd in *.

rewrite (nextblock_access_empty m0) by (apply Pos.le_ge; auto).

split; intros _; [ |apply NO_identity].

replace (access_at m (b,ofs) Cur) with (@None permission).

apply NO_identity.

symmetry.

unfold Genv.alloc_global in H.

destruct (alloc m0 0 1) eqn:?.

assert (H6 := alloc_result _ _ _ _ _ Heqp); subst b0.

clear - n0 H2 Heqp H.

assert (b <> nextblock m0 \/ ofs <> 0). {

  destruct (eq_block b (nextblock m0)). subst. right. congruence. left; auto.

}

rewrite <- (access_drop_3 _ _ _ _ _ _ H) by (destruct H0; auto; right; omega).

rewrite <- (alloc_access_other _ _ _ _ _ Heqp)by (destruct H0; auto; right; omega).

apply nextblock_access_empty. zify; omega.

Qed.



Lemma global_initializers:

  forall (prog: program) G m n rho,

     list_norepet (prog_defs_names prog) ->

     all_initializers_aligned prog ->

    match_fdecs (prog_funct prog) G ->

    ge_of rho = filter_genv (globalenv prog) ->

    Genv.init_mem prog = Some m ->

     app_pred (globvars2pred (globals_of_env rho) (prog_vars prog) rho)

  (inflate_initial_mem m (initial_core (Genv.globalenv prog) G n)).

Proof.

  intros until rho. intros ? AL SAME_IDS RHO ?.

  unfold all_initializers_aligned in AL.

  unfold Genv.init_mem in H0.

  unfold globalenv, Genv.globalenv in *.

  unfold prog_vars, prog_funct in *.

  change (prog_defs prog) with (AST.prog_defs prog) in AL, SAME_IDS |- *.

  destruct (program_of_program prog) as [fl prog_pub main].

  forget (prog_comp_env prog) as cenv.

  clear prog.

  simpl in *|-. simpl prog_vars'. simpl initial_core.

  match goal with |- context [initial_core ?A] =>

     remember A as gev end.

  rewrite <- (rev_involutive fl) in *.

  rewrite alloc_globals_rev_eq in H0.

  forget (rev fl) as vl'. clear fl; rename vl' into vl.

  unfold prog_defs_names in H. simpl in  H.



  rewrite <- rev_prog_vars' in AL|-*.

  rewrite <- rev_prog_funct' in SAME_IDS.

  rewrite globvars2pred_rev.

  rewrite forallb_rev in AL.

  rewrite <- (rev_involutive G) in  SAME_IDS.

  rewrite match_fdecs_rev in SAME_IDS.

  2:{

    apply list_norepet_prog_funct'.

    rewrite <- list_norepet_rev, <- map_rev; auto.

  }

  rewrite initial_core_rev with (vl:=vl) by auto.

  rewrite map_rev in H. rewrite list_norepet_rev in H.

  forget (rev G) as G'; clear G; rename G' into G.

  rename H into H2.

  assert (H :=add_globals_hack _ _ prog_pub H2 Heqgev).

  assert (H1: forall j, In j (map (@fst _ _) G) -> ~ In j (map (@fst _ _) (prog_vars' vl))). {

    intros.

    pose proof (match_fdecs_in j _ _ H1 SAME_IDS).

    clear - H3 H2.

    intro.

    induction vl. inv H.

    inv H2. specialize (IHvl H5).

    destruct a as [i [a|a]]; simpl in *.

    destruct H3. subst j.

    clear - H H4.

    apply H4; clear H4. induction vl; simpl in *; auto.

    destruct a as [i' [a|a]]; auto .

    destruct H. simpl in *; subst; auto.

    right; auto.

    apply IHvl; auto.

    destruct H; subst.

    apply H4; clear - H3. induction vl; simpl in *; auto.

    destruct a as [i' [a|a]]; auto .

    destruct H3. simpl in *; subst; auto.

    right; auto.

    apply IHvl; auto.

  }

  assert (H1': forall j, In j (map fst (prog_funct' vl)) -> In j (map fst G)). {

   clear - SAME_IDS.

   forget (prog_funct' vl) as fs. intro.

   induction SAME_IDS. auto. simpl. intuition.

  }

  assert (NRG: list_norepet (map fst G)). {

     clear - SAME_IDS H2.

     eapply match_fdecs_norepet; eauto.

     apply list_norepet_prog_funct'; auto.

  }

  clear SAME_IDS Heqgev.

  change (map fst vl) with (map fst (@nil (ident*funspec)) ++ map fst vl) in H2.

  change G with (nil++G).

  set (G0 := @nil (ident*funspec)) in *.

  change G with (G0++G) in NRG.

  clearbody G0.

  move H2 after H. move H1 after H.



  assert (H3: forall phi, hackfun (inflate_initial_mem m (initial_core gev (G0++G) n)) phi ->

           (globvars2pred (globals_of_env rho) (prog_vars' vl) rho) phi).

  2:{

    apply H3. clear.

    split. auto.

    split; auto.

    intro loc. intuition.

  }

  intros. rename H3 into HACK; revert phi HACK.

                     

  revert H m G0 G NRG H2 H0 H1 H1'; induction vl; intros.

  + split. hnf; auto. apply resource_at_empty2.

    intro l. do 2 apply proj2 in HACK; specialize (HACK l).

    unfold inflate_initial_mem in HACK|-*.

    rewrite resource_at_make_rmap in *.

    unfold inflate_initial_mem' in HACK|-*.

    inversion H0; clear H0; subst m.

    unfold access_at, empty in HACK; simpl in HACK; rewrite PMap.gi in HACK.

      destruct HACK as [HACK _]. rewrite <- HACK. apply NO_identity.

    destruct HACK as (? & <- & _).

    unfold inflate_initial_mem, initial_core; rewrite !ghost_of_make_rmap.

    rewrite <- (ghost_core nil); apply core_identity.

  + simpl in H0.

    revert H0; case_eq (alloc_globals_rev gev empty vl); intros; try congruence.

    spec IHvl. clear - AL. simpl in AL. destruct a. destruct g; auto. simpl in AL.

      apply andb_true_iff in AL; destruct AL; auto.

     spec IHvl; [ intros | ].

    assert (H4': (Pos.to_nat b <= length vl)%nat). {

    clear - H4. rewrite Zlength_correct in H4.

      rewrite <- Z2Nat.inj_pos.

       rewrite <- Nat2Z.id .

       apply Z2Nat.inj_le. specialize (Pos2Z.is_pos b). omega.

       omega.

       omega.

     }

 fold fundef in *.

 assert (POS := Pos2Z.is_pos b). {

 rewrite H.

 rewrite Pos_to_nat_eq_S.

 replace (length vl - (nat_of_Z (Z.pos b) - 1))%nat with (S (length vl - S (nat_of_Z (Z.pos b) - 1)))%nat

  by (simpl;  pose proof (Pos2Nat.is_pos b); omega).

 simpl.

  replace (Datatypes.length vl - (Pos.to_nat b - 1))%nat with

             (S (Datatypes.length vl - S (Pos.to_nat b - 1)))%nat.

 apply iff_refl.

 clear - H4'; pose proof (Pos2Nat.is_pos b); omega.

 rewrite Zlength_cons. omega.

 }

 destruct a.

 assert (FS: Genv.find_symbol gev i = Some (nextblock m0)).

  assert (Genv.find_symbol gev i = Some (nextblock m0)).

    apply H. apply alloc_globals_rev_nextblock in H0. rewrite H0 .

      rewrite Zlength_cons.

 rewrite Z2Pos.id.

 rewrite Zlength_correct. omega.

 rewrite Zlength_correct. omega.

 simpl.

   apply alloc_globals_rev_nextblock in H0. rewrite H0 .

  replace (Pos.to_nat (Z.to_pos (Z.succ (Zlength vl))))

    with (S (length vl)).

2:{

rewrite Pos_to_nat_eq_S.

 rewrite Zlength_correct.

  rewrite Z2Pos.id by omega.

 unfold nat_of_Z.

 rewrite Z2Nat.inj_succ by omega.

 rewrite Nat2Z.id. omega.

}

 rewrite Nat.sub_diag. reflexivity.

  auto.

  destruct g.

* 

  simpl.

  specialize (IHvl m0 (G0) G).

  apply IHvl; auto.

 - clear - H2. apply list_norepet_app in H2. destruct H2 as [? [? ?]].

    inv H0.

    apply list_norepet_app; split3; auto.

    apply list_disjoint_cons_right in H1; auto.

 - clear - H1'; intros; apply H1'. right; auto.

 -

  clear - NRG H2 FS HACK H3 H1'.

  specialize (H1' i). simpl in H1'. spec H1'; [auto | ].

  destruct HACK as [? ? ].

  split. rewrite <- H.

  unfold inflate_initial_mem. repeat rewrite level_make_rmap. auto.

  destruct H0 as [Hg H0]; split.

  unfold inflate_initial_mem in *; rewrite ghost_of_make_rmap in *; auto.

  intro; specialize (H0 loc).

  destruct H0.

  clear - NRG H2 FS H0 H1 H3 H1'.

  split.

  rewrite <- H0.

  clear - NRG H2 FS H3 H1'.

  apply (identity_inflate_at_Gfun n i f); auto.

  intro.

  rewrite <- H1.

  eapply alloc_global_inflate_initial_eq; eauto.

  clear - H3 H.

  contradict H.

  eapply alloc_global_identity_lemma3; eauto.

* 

  specialize (IHvl m0 G0 G NRG).

  spec IHvl. { clear - H2. apply list_norepet_app.  apply list_norepet_app in H2.

      destruct H2 as [? [? ?]].  inv H0.  split3; auto. simpl in H1.

    apply list_disjoint_cons_right in H1; auto.

  }

  specialize (IHvl H0).

 spec IHvl. intros. clear - H1 H4. specialize (H1 _ H4). contradict H1.

  right; auto.

  assert (FI: find_id i (G0++G) = None). {

  change (list_norepet (map fst G0 ++ (i::nil) ++ (map fst vl))) in H2.

  apply list_norepet_append_commut in H2. rewrite app_ass in H2.

 inv H2. specialize (H1 i).

 case_eq (find_id i (G0++G)); intros; auto. apply find_id_e in H2.

 contradiction H6. apply in_app. apply in_app_or in H2.

 destruct H2; [right|left].  change i with (fst (i,f)); apply in_map; auto.

 contradiction H1. apply in_map_fst in H2. auto.

 left; auto.

 }

  split. hnf; auto.

  simpl map.  simpl fold_right.

  assert (identity (ghost_of phi)) as Hg.

  { destruct HACK as (? & <- & _).

    unfold inflate_initial_mem, initial_core; rewrite !ghost_of_make_rmap.

    rewrite <- (ghost_core nil); apply core_identity. }

  pose proof (join_comm (join_upto_beyond_block (nextblock m0) phi Hg)).

  do 2 econstructor; split3; [ eassumption | |].

  unfold globvar2pred.

  unfold globals_of_env.

  rewrite RHO. unfold filter_genv, Map.get. simpl @fst; simpl @snd.

  assert (JJ:= alloc_global_inflate_same n i v _ _ (G0++G) _ H3).

 spec JJ.

 intro. unfold initial_core. rewrite resource_at_make_rmap. unfold initial_core'.

  simpl. if_tac; auto.

 rewrite Genv.find_invert_symbol with (id:=i); auto. rewrite FI; auto.

 simpl genv_genv.

 fold fundef in *. simpl.

 rewrite FS.

 assert (H99: exists t, match type_of_global {| genv_genv := gev; genv_cenv := cenv |} (nextblock m0) with

  | Some t => Some (Vptr (nextblock m0) Ptrofs.zero, t)

  | None => Some (Vptr (nextblock m0) Ptrofs.zero, Tvoid)

  end = Some (Vptr (nextblock m0) Ptrofs.zero, t)) by (destruct (type_of_global {| genv_genv := gev; genv_cenv := cenv |} (nextblock m0)); eauto).



 case_eq (gvar_volatile v); intros; auto. rename H5 into H10.

  hnf; auto.



  unfold Genv.alloc_global in H3.

  revert H3; case_eq (alloc m0 0 (init_data_list_size (gvar_init v))); intros.

  invSome. invSome.

  assert (H90: Z.pos (nextblock m0) -1 = Zlength vl).

    clear - H0 H3.



  apply alloc_globals_rev_nextblock in H0. apply alloc_result in H3.

  subst.  rewrite H0.

  rewrite Zlength_correct.

  rewrite Z2Pos.id by omega. omega.

 destruct (H i (nextblock m0)) as [_ ?].

  rewrite Zlength_cons. rewrite H90.

  split; try omega.

  rewrite Zlength_correct. omega.

  spec H7. 

  simpl length.

  replace (Pos.to_nat (nextblock m0)) with (S (length vl)).

  rewrite minus_diag. reflexivity.

  clear - H90. rewrite Zlength_correct in H90. apply inj_eq_rev.

  rewrite inj_S. rewrite <- H90. clear.

  rewrite Pos_to_nat_eq_S.

  replace (Z.succ (Z.pos (nextblock m0) - 1)) with (Z.pos (nextblock m0)) by omega.

  unfold nat_of_Z.

  replace (S (Z.to_nat (Z.pos (nextblock m0)) - 1))

    with (Z.to_nat (Z.pos (nextblock m0)))

  by (rewrite Z2Nat.inj_pos; pose proof (Pos2Nat.is_pos (nextblock m0)); omega).

 rewrite Z2Nat.id by (pose proof (Pos2Z.is_pos (nextblock m0)); omega).

 auto.



pose proof (init_data_list_lem {| genv_genv := gev; genv_cenv := cenv |} m0 v m1 b m2 m3 m (initial_core gev (G0 ++ G) n) rho

     H3 H6 H9 H10) .

 spec H8.

 { unfold initial_core; simpl; rewrite ghost_of_make_rmap, <- (ghost_core nil); apply core_identity. }

 spec H8.

 clear - AL. simpl in AL. apply andb_true_iff in AL; destruct AL; auto.

 apply andb_true_iff in H. destruct H. apply Zlt_is_lt_bool; auto.

 specialize (H8 H5).

 spec H8.

 clear - AL. simpl in AL. apply andb_true_iff in AL; destruct AL; auto.

 apply andb_true_iff in H. destruct H; auto.

 specialize (H8 RHO). 

 eapply init_datalist_hack; eauto.

  apply alloc_result in H3; subst b.

  eassumption.

 apply hackfun_beyond_block; auto.

 apply readable_readonly2share.

 apply IHvl; auto.

 eapply another_hackfun_lemma; eauto.

Qed.

