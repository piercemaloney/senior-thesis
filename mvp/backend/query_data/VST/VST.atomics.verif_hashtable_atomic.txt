Require Import VST.veric.rmaps.
Require Import VST.progs.ghosts.
Require Import atomics.general_atomics.
(* atomics.general_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Import VST.progs.invariants.
Require Import VST.progs.fupd.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Export Ensembles.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs} {inv_names : invG}.

Section atomicity.

Lemma approx_mono: forall n P Q, (P >=> Q) (Nat.pred n) -> approx n P |-- approx n Q.

Lemma subp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P' >=> P -> G |-- Q >=> Q' ->
    G |-- ((P -* Q) >=> (P' -* Q'))%pred.

Lemma eqp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P <=> P' -> G |-- Q <=> Q' ->
    G |-- ((P -* Q) <=> (P' -* Q')).

Lemma subp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P >=> P' ->
    G |-- ((|={E1,E2}=> P) >=> |={E1,E2}=> P').

Lemma eqp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P <=> P' ->
    G |-- ((|={E1,E2}=> P) <=> |={E1,E2}=> P').

Lemma eqp_imp: forall (G : Triv) (P P' Q Q' : mpred),
       G |-- P <=> P' -> G |-- Q <=> Q' -> G |-- (P --> Q) <=> P' --> Q'.

Lemma fview_shift_nonexpansive: forall E1 E2 P Q n,
  approx n (P -* |={E1,E2}=> Q) = approx n (approx n P -* |={E1,E2}=> (approx n Q)).

Lemma emp_dup: forall P, P && emp = (P && emp) * (P && emp).

Definition atomic_shift {A B} (a : A -> mpred) Ei Eo (b : A -> B -> mpred) (Q : B -> mpred) :=
  EX P : mpred, |> P * ((|> P -* |={Eo,Ei}=> (EX x : A, a x *
    ((a x -* |={Ei,Eo}=> |> P) &&
     ALL y : B, b x y -* |={Ei,Eo}=> Q y))) && cored).

End atomicity.

End atomics.

Definition atomic_spec_type W T := ProdType (ProdType W (ArrowType (ConstType T) Mpred)) (ConstType invG).

Definition super_non_expansive_a {A W} (a : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> predicates_hered.pred rmap) :=
  forall n ts w x, approx n (a ts w x) =
  approx n (a ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x).

Definition super_non_expansive_b {A B W} (b : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> B -> predicates_hered.pred rmap) :=
  forall n ts w x y, approx n (b ts w x y) =
  approx n (b ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x y).

Definition super_non_expansive_la {W} la := forall n ts w rho,
  Forall (fun l => approx n (!! locald_denote (l ts w) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w)) rho)) la.

Definition super_non_expansive_lb {B W} lb := forall n ts w (v : B) rho,
  Forall (fun l => approx n (!! locald_denote (l ts w v) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) v) rho)) lb.

Program Definition atomic_spec {A T} W args tz la P a (t : T) lb b Ei Eo
  (Hla : super_non_expansive_la la) (HP : super_non_expansive' P) (Ha : super_non_expansive_a(A := A) a)
  (Hlb : super_non_expansive_lb lb) (Hb : super_non_expansive_b b) :=
  mk_funspec (pair args tz) cc_default (atomic_spec_type W T)
  (fun (ts: list Type) '(w, Q, inv_names) =>
    PROP ()
    (LOCALx (map (fun l => l ts w) la)
    (SEP (atomic_shift(inv_names := inv_names) (a ts w) Ei Eo (b ts w) Q; P ts w))))
  (fun (ts: list Type) '(w, Q, inv_names) => EX v : T,
    PROP () (LOCALx (map (fun l => l ts w v) lb)
    (SEP (Q v)))) _ _.

Ltac start_atomic_function :=
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH u : unit
               PRE  [] main_pre _ nil u
               POST [ tint ] main_post _ nil u) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end; unfold atomic_spec;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match x with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList (x, Q)
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax; simpl. *)
Require Import atomics.SC_atomics.
(* atomics.SC_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Export VST.progs.invariants.
Require Export VST.progs.fupd.
Require Import atomics.general_atomics.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.

Set Bullet Behavior "Strict Subproofs".

Section SC_atomics.

Context {CS : compspecs} .

Definition AL_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType val) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition load_SC_spec := TYPE AL_type
  WITH p : val, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint ]
   PROP (Included Ei Eo)
   LOCAL (temp 1%positive p)
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v : Z, !!(readable_share sh /\ repable_signed v) &&
              data_at sh tint (vint v) p * P' sh v;
         ALL sh : _, ALL v : _, (!!(readable_share sh /\ repable_signed v) &&
           data_at sh tint (vint v) p * P' sh v) -* |={Ei,Eo}=> Q v;
         P)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (Q v).

Definition AS_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) Mpred)) Mpred)
  (ConstType invG).

Program Definition store_SC_spec := TYPE AS_type
  WITH p : val, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> mpred, Q : mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint ]
   PROP (repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, !!(writable_share sh) && data_at_ sh tint p * P' sh;
        ALL sh : _, (!!(writable_share sh) && data_at sh tint (vint v) p * P' sh) -* |={Ei,Eo}=> Q; P)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (Q).

Definition ACAS_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition CAS_SC_spec := TYPE ACAS_type
  WITH p : val, c : Z, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint, 3%positive OF tint ]
   PROP (repable_signed c; repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint c); temp 3%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v0 : Z, !!(writable_share sh /\ repable_signed v0) &&
              data_at sh tint (vint v0) p * P' sh v0;
         ALL sh : _, ALL v0 : _, (!!(writable_share sh /\ repable_signed v0) &&
           data_at sh tint (vint (if eq_dec v0 c then v else v0)) p * P' sh v0) -* |={Ei,Eo}=> Q v0; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (vint (if eq_dec v' c then 1 else 0)))
   SEP (Q v').

Definition AEX_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ConstType (val * Z)) Mpred)
  (ArrowType (ConstType iname) (ConstType Prop))) (ArrowType (ConstType iname) (ConstType Prop)))
  (ArrowType (ConstType share) (ArrowType (ConstType Z) Mpred))) (ArrowType (ConstType Z) Mpred))
  (ConstType invG).

Program Definition AEX_SC_spec := TYPE AEX_type
  WITH p : val, v : Z, P : mpred, Eo : Ensemble iname, Ei : Ensemble iname,
       P' : share -> Z -> mpred, Q : Z -> mpred, inv_names : invG
  PRE [ 1%positive OF tptr tint, 2%positive OF tint ]
   PROP (repable_signed v)
   LOCAL (temp 1%positive p; temp 2%positive (vint v))
   SEP (P -* |={Eo,Ei}=> EX sh : share, EX v0 : Z, !!(writable_share sh /\ repable_signed v0) &&
              data_at sh tint (vint v0) p * P' sh v0;
        ALL sh : _, ALL v0 : _, (!!(writable_share sh /\ repable_signed v0) &&
           data_at sh tint (vint v) p * P' sh v0) -* |={Ei,Eo}=> Q v0; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (vint v'))
   SEP (Q v').

End SC_atomics.

Notation store_SC_witness p v P Eo Ei Q invG := (p, v%Z, P, Eo, Ei,
  fun sh => !!(writable_share sh) && data_at sh tint (vint v) p -* Q, Q, invG).

Notation AEX_SC_witness p v P Eo Ei Q invG := (p, v%Z, P, Eo, Ei,
  fun sh v0 => !!(writable_share sh /\ repable_signed v0) && data_at sh tint (vint v) p -* Q v0, Q, invG).

Notation load_SC_witness p P Eo Ei Q invG := (p, P, Eo, Ei,
  fun sh v => !!(readable_share sh /\ repable_signed v) && data_at sh tint (vint v) p -* Q v, Q, invG).

Notation CAS_SC_witness p c v P Eo Ei Q invG := (p, c, v%Z, P, Eo, Ei,
  fun sh v0 => !!(writable_share sh /\ repable_signed v0) &&
    data_at sh tint (vint (if eq_dec v0 c then v else v0)) p -* Q v0, Q, invG). *)
Require Import VST.progs.conclib.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import atomics.hashtable_atomic.
(* atomics.hashtable_atomic:
From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats AST Ctypes Cop Clight Clightdefs.
Local Open Scope Z_scope.

Definition _CAS_SC : ident := 68%positive.
Definition ___builtin_ais_annot : ident := 6%positive.
Definition ___builtin_annot : ident := 13%positive.
Definition ___builtin_annot_intval : ident := 14%positive.
Definition ___builtin_bswap : ident := 7%positive.
Definition ___builtin_bswap16 : ident := 9%positive.
Definition ___builtin_bswap32 : ident := 8%positive.
Definition ___builtin_bswap64 : ident := 39%positive.
Definition ___builtin_clz : ident := 40%positive.
Definition ___builtin_clzl : ident := 41%positive.
Definition ___builtin_clzll : ident := 42%positive.
Definition ___builtin_ctz : ident := 43%positive.
Definition ___builtin_ctzl : ident := 44%positive.
Definition ___builtin_ctzll : ident := 45%positive.
Definition ___builtin_debug : ident := 57%positive.
Definition ___builtin_fabs : ident := 10%positive.
Definition ___builtin_fmadd : ident := 48%positive.
Definition ___builtin_fmax : ident := 46%positive.
Definition ___builtin_fmin : ident := 47%positive.
Definition ___builtin_fmsub : ident := 49%positive.
Definition ___builtin_fnmadd : ident := 50%positive.
Definition ___builtin_fnmsub : ident := 51%positive.
Definition ___builtin_fsqrt : ident := 11%positive.
Definition ___builtin_membar : ident := 15%positive.
Definition ___builtin_memcpy_aligned : ident := 12%positive.
Definition ___builtin_nop : ident := 56%positive.
Definition ___builtin_read16_reversed : ident := 52%positive.
Definition ___builtin_read32_reversed : ident := 53%positive.
Definition ___builtin_va_arg : ident := 17%positive.
Definition ___builtin_va_copy : ident := 18%positive.
Definition ___builtin_va_end : ident := 19%positive.
Definition ___builtin_va_start : ident := 16%positive.
Definition ___builtin_write16_reversed : ident := 54%positive.
Definition ___builtin_write32_reversed : ident := 55%positive.
Definition ___compcert_i64_dtos : ident := 24%positive.
Definition ___compcert_i64_dtou : ident := 25%positive.
Definition ___compcert_i64_sar : ident := 36%positive.
Definition ___compcert_i64_sdiv : ident := 30%positive.
Definition ___compcert_i64_shl : ident := 34%positive.
Definition ___compcert_i64_shr : ident := 35%positive.
Definition ___compcert_i64_smod : ident := 32%positive.
Definition ___compcert_i64_smulh : ident := 37%positive.
Definition ___compcert_i64_stod : ident := 26%positive.
Definition ___compcert_i64_stof : ident := 28%positive.
Definition ___compcert_i64_udiv : ident := 31%positive.
Definition ___compcert_i64_umod : ident := 33%positive.
Definition ___compcert_i64_umulh : ident := 38%positive.
Definition ___compcert_i64_utod : ident := 27%positive.
Definition ___compcert_i64_utof : ident := 29%positive.
Definition ___compcert_va_composite : ident := 23%positive.
Definition ___compcert_va_float64 : ident := 22%positive.
Definition ___compcert_va_int32 : ident := 20%positive.
Definition ___compcert_va_int64 : ident := 21%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 62%positive.
Definition _add_item : ident := 82%positive.
Definition _arg : ident := 84%positive.
Definition _entry : ident := 5%positive.
Definition _exit : ident := 58%positive.
Definition _f : ident := 90%positive.
Definition _free : ident := 59%positive.
Definition _freelock2 : ident := 63%positive.
Definition _get_item : ident := 81%positive.
Definition _i : ident := 75%positive.
Definition _i__1 : ident := 91%positive.
Definition _i__2 : ident := 92%positive.
Definition _i__3 : ident := 94%positive.
Definition _idx : ident := 77%positive.
Definition _init_table : ident := 83%positive.
Definition _integer_hash : ident := 76%positive.
Definition _key : ident := 3%positive.
Definition _l : ident := 86%positive.
Definition _l__1 : ident := 93%positive.
Definition _load_SC : ident := 66%positive.
Definition _lock_t : ident := 2%positive.
Definition _m_entries : ident := 69%positive.
Definition _main : ident := 95%positive.
Definition _makelock : ident := 61%positive.
Definition _malloc : ident := 60%positive.
Definition _n : ident := 72%positive.
Definition _p : ident := 73%positive.
Definition _probed_key : ident := 78%positive.
Definition _r : ident := 89%positive.
Definition _release2 : ident := 64%positive.
Definition _res : ident := 87%positive.
Definition _result : ident := 79%positive.
Definition _results : ident := 71%positive.
Definition _set_item : ident := 80%positive.
Definition _spawn : ident := 65%positive.
Definition _store_SC : ident := 67%positive.
Definition _surely_malloc : ident := 74%positive.
Definition _t : ident := 85%positive.
Definition _thread_locks : ident := 70%positive.
Definition _total : ident := 88%positive.
Definition _value : ident := 4%positive.
Definition _t'1 : ident := 96%positive.
Definition _t'2 : ident := 97%positive.
Definition _t'3 : ident := 98%positive.
Definition _t'4 : ident := 99%positive.
Definition _t'5 : ident := 100%positive.

Definition v_m_entries := {|
  gvar_info := (tarray (Tstruct _entry noattr) 16384);
  gvar_init := (Init_space 131072 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_thread_locks := {|
  gvar_info := (tarray (tptr (Tstruct _lock_t noattr)) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_results := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_surely_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
      ((Etempvar _n tuint) :: nil))
    (Sset _p (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
      (Scall None (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
        ((Econst_int (Int.repr 1) tint) :: nil))
      Sskip)
    (Sreturn (Some (Etempvar _p (tptr tvoid))))))
|}.

Definition f_integer_hash := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_i, tint) :: nil);
  fn_vars := nil;
  fn_temps := nil;
  fn_body :=
(Sreturn (Some (Ebinop Omul (Ecast (Etempvar _i tint) tuint)
                 (Ecast (Econst_int (Int.repr 654435761) tint) tuint) tuint)))
|}.

Definition f_set_item := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_result, tint) :: (_t'4, tint) :: (_t'3, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                 cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                 (Econst_int (Int.repr 0) tint) tint)
                    Scontinue
                    Sskip)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'3)
                        (Evar _CAS_SC (Tfunction
                                        (Tcons (tptr tint)
                                          (Tcons tint (Tcons tint Tnil)))
                                        tint cc_default))
                        ((Etempvar _i (tptr tint)) ::
                         (Econst_int (Int.repr 0) tint) ::
                         (Etempvar _key tint) :: nil))
                      (Sset _result (Etempvar _t'3 tint)))
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_SC (Tfunction
                                             (Tcons (tptr tint) Tnil) tint
                                             cc_default))
                            ((Etempvar _i (tptr tint)) :: nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          Scontinue
                          Sskip))
                      Sskip)))
                Sskip)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint)))
                (Ssequence
                  (Scall None
                    (Evar _store_SC (Tfunction
                                      (Tcons (tptr tint) (Tcons tint Tnil))
                                      tvoid cc_default))
                    ((Etempvar _i (tptr tint)) :: (Etempvar _value tint) ::
                     nil))
                  (Sreturn None))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_get_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                 cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sset _i
                    (Efield
                      (Ederef
                        (Ebinop Oadd
                          (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                          (Etempvar _idx tint)
                          (tptr (Tstruct _entry noattr)))
                        (Tstruct _entry noattr)) _value (tptr tint)))
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                       cc_default))
                      ((Etempvar _i (tptr tint)) :: nil))
                    (Sreturn (Some (Etempvar _t'3 tint)))))
                Sskip)
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Econst_int (Int.repr 0) tint) tint)
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))
                Sskip))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_add_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr tint)) :: (_probed_key, tint) ::
               (_result, tint) :: (_t'5, tint) :: (_t'4, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key (tptr tint)))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                 cc_default))
                ((Etempvar _i (tptr tint)) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                 (Econst_int (Int.repr 0) tint) tint)
                    Scontinue
                    Sskip)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'3)
                        (Evar _CAS_SC (Tfunction
                                        (Tcons (tptr tint)
                                          (Tcons tint (Tcons tint Tnil)))
                                        tint cc_default))
                        ((Etempvar _i (tptr tint)) ::
                         (Econst_int (Int.repr 0) tint) ::
                         (Etempvar _key tint) :: nil))
                      (Sset _result (Etempvar _t'3 tint)))
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_SC (Tfunction
                                             (Tcons (tptr tint) Tnil) tint
                                             cc_default))
                            ((Etempvar _i (tptr tint)) :: nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          Scontinue
                          Sskip))
                      Sskip)))
                Sskip)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint)))
                (Ssequence
                  (Scall (Some _t'5)
                    (Evar _CAS_SC (Tfunction
                                    (Tcons (tptr tint)
                                      (Tcons tint (Tcons tint Tnil))) tint
                                    cc_default))
                    ((Etempvar _i (tptr tint)) ::
                     (Econst_int (Int.repr 0) tint) ::
                     (Etempvar _value tint) :: nil))
                  (Sreturn (Some (Etempvar _t'5 tint))))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_init_table := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_p, (tptr tint)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Sset _i (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                     (Econst_int (Int.repr 16384) tint) tint)
        Sskip
        Sbreak)
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                   cc_default))
            ((Esizeof tint tuint) :: nil))
          (Sset _p (Etempvar _t'1 (tptr tvoid))))
        (Ssequence
          (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
            (Econst_int (Int.repr 0) tint))
          (Ssequence
            (Sassign
              (Efield
                (Ederef
                  (Ebinop Oadd
                    (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                    (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                  (Tstruct _entry noattr)) _key (tptr tint))
              (Etempvar _p (tptr tint)))
            (Ssequence
              (Ssequence
                (Scall (Some _t'2)
                  (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                         (tptr tvoid) cc_default))
                  ((Esizeof tint tuint) :: nil))
                (Sset _p (Etempvar _t'2 (tptr tvoid))))
              (Ssequence
                (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
                  (Econst_int (Int.repr 0) tint))
                (Sassign
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value (tptr tint))
                  (Etempvar _p (tptr tint)))))))))
    (Sset _i
      (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_f := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_t, tint) :: (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_res, (tptr tint)) :: (_total, tint) :: (_i, tint) ::
               (_r, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _t (Ederef (Ecast (Etempvar _arg (tptr tvoid)) (tptr tint)) tint))
  (Ssequence
    (Sset _l
      (Ederef
        (Ebinop Oadd
          (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
          (Etempvar _t tint) (tptr (tptr (Tstruct _lock_t noattr))))
        (tptr (Tstruct _lock_t noattr))))
    (Ssequence
      (Sset _res
        (Ederef
          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
            (Etempvar _t tint) (tptr (tptr tint))) (tptr tint)))
      (Ssequence
        (Sset _total (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default)) ((Etempvar _arg (tptr tvoid)) :: nil))
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 3) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'1)
                        (Evar _add_item (Tfunction
                                          (Tcons tint (Tcons tint Tnil)) tint
                                          cc_default))
                        ((Ebinop Oadd (Etempvar _i tint)
                           (Econst_int (Int.repr 1) tint) tint) ::
                         (Econst_int (Int.repr 1) tint) :: nil))
                      (Sset _r (Etempvar _t'1 tint)))
                    (Sifthenelse (Etempvar _r tint)
                      (Sset _total
                        (Ebinop Oadd (Etempvar _total tint)
                          (Econst_int (Int.repr 1) tint) tint))
                      Sskip)))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Sassign (Ederef (Etempvar _res (tptr tint)) tint)
                (Etempvar _total tint))
              (Ssequence
                (Scall None
                  (Evar _release2 (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                    cc_default))
                  ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                (Sreturn (Some (Ecast (Econst_int (Int.repr 0) tint)
                                 (tptr tvoid))))))))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_total, tint) :: (_i, tint) ::
               (_l, (tptr (Tstruct _lock_t noattr))) :: (_i__1, tint) ::
               (_t, (tptr tint)) :: (_i__2, tint) ::
               (_l__1, (tptr (Tstruct _lock_t noattr))) ::
               (_r, (tptr tint)) :: (_i__3, tint) :: (_t'3, (tptr tvoid)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _total (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Scall None (Evar _init_table (Tfunction Tnil tvoid cc_default)) nil)
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof (Tstruct _lock_t noattr) tuint) :: nil))
                  (Sset _l
                    (Ecast (Etempvar _t'1 (tptr tvoid))
                      (tptr (Tstruct _lock_t noattr)))))
                (Ssequence
                  (Sassign
                    (Ederef
                      (Ebinop Oadd
                        (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                        (Etempvar _i tint)
                        (tptr (tptr (Tstruct _lock_t noattr))))
                      (tptr (Tstruct _lock_t noattr)))
                    (Etempvar _l (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                               (tptr tvoid) cc_default))
                        ((Esizeof tint tuint) :: nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
                            (Etempvar _i tint) (tptr (tptr tint)))
                          (tptr tint))
                        (Ecast (Etempvar _t'2 (tptr tvoid)) (tptr tint))))
                    (Scall None
                      (Evar _makelock (Tfunction (Tcons (tptr tvoid) Tnil)
                                        tvoid cc_default))
                      ((Ecast (Etempvar _l (tptr (Tstruct _lock_t noattr)))
                         (tptr tvoid)) :: nil))))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Ssequence
          (Ssequence
            (Sset _i__1 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__1 tint)
                               (Econst_int (Int.repr 3) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                             (tptr tvoid) cc_default))
                      ((Esizeof tint tuint) :: nil))
                    (Sset _t
                      (Ecast (Etempvar _t'3 (tptr tvoid)) (tptr tint))))
                  (Ssequence
                    (Sassign (Ederef (Etempvar _t (tptr tint)) tint)
                      (Etempvar _i__1 tint))
                    (Scall None
                      (Evar _spawn (Tfunction
                                     (Tcons
                                       (tptr (Tfunction
                                               (Tcons (tptr tvoid) Tnil)
                                               (tptr tvoid) cc_default))
                                       (Tcons (tptr tvoid) Tnil)) tvoid
                                     cc_default))
                      ((Ecast
                         (Eaddrof
                           (Evar _f (Tfunction (Tcons (tptr tvoid) Tnil)
                                      (tptr tvoid) cc_default))
                           (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                   (tptr tvoid) cc_default))) (tptr tvoid)) ::
                       (Ecast (Etempvar _t (tptr tint)) (tptr tvoid)) :: nil)))))
              (Sset _i__1
                (Ebinop Oadd (Etempvar _i__1 tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Ssequence
            (Sset _i__2 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__2 tint)
                               (Econst_int (Int.repr 3) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Sset _l__1
                    (Ederef
                      (Ebinop Oadd
                        (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                        (Etempvar _i__2 tint)
                        (tptr (tptr (Tstruct _lock_t noattr))))
                      (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _acquire (Tfunction (Tcons (tptr tvoid) Tnil)
                                       tvoid cc_default))
                      ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                       nil))
                    (Ssequence
                      (Scall None
                        (Evar _freelock2 (Tfunction (Tcons (tptr tvoid) Tnil)
                                           tvoid cc_default))
                        ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                         nil))
                      (Ssequence
                        (Scall None
                          (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil)
                                        tvoid cc_default))
                          ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                           nil))
                        (Ssequence
                          (Sset _r
                            (Ederef
                              (Ebinop Oadd
                                (Evar _results (tarray (tptr tint) 3))
                                (Etempvar _i__2 tint) (tptr (tptr tint)))
                              (tptr tint)))
                          (Ssequence
                            (Sset _i__3
                              (Ederef (Etempvar _r (tptr tint)) tint))
                            (Ssequence
                              (Scall None
                                (Evar _free (Tfunction
                                              (Tcons (tptr tvoid) Tnil) tvoid
                                              cc_default))
                                ((Etempvar _r (tptr tint)) :: nil))
                              (Sset _total
                                (Ebinop Oadd (Etempvar _total tint)
                                  (Etempvar _i__3 tint) tint))))))))))
              (Sset _i__2
                (Ebinop Oadd (Etempvar _i__2 tint)
                  (Econst_int (Int.repr 1) tint) tint))))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _lock_t Struct ((_a, (tarray (tptr tvoid) 2)) :: nil) noattr ::
 Composite _entry Struct
   ((_key, (tptr tint)) :: (_value, (tptr tint)) :: nil)
   noattr :: nil).

Definition global_definitions : list (ident * globdef fundef type) :=
((___builtin_ais_annot,
   Gfun(External (EF_builtin "__builtin_ais_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___compcert_i64_dtos,
   Gfun(External (EF_runtime "__compcert_i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___compcert_i64_dtou,
   Gfun(External (EF_runtime "__compcert_i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___compcert_i64_stod,
   Gfun(External (EF_runtime "__compcert_i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___compcert_i64_utod,
   Gfun(External (EF_runtime "__compcert_i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___compcert_i64_stof,
   Gfun(External (EF_runtime "__compcert_i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___compcert_i64_utof,
   Gfun(External (EF_runtime "__compcert_i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___compcert_i64_sdiv,
   Gfun(External (EF_runtime "__compcert_i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_udiv,
   Gfun(External (EF_runtime "__compcert_i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_smod,
   Gfun(External (EF_runtime "__compcert_i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umod,
   Gfun(External (EF_runtime "__compcert_i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_shl,
   Gfun(External (EF_runtime "__compcert_i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_shr,
   Gfun(External (EF_runtime "__compcert_i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___compcert_i64_sar,
   Gfun(External (EF_runtime "__compcert_i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_smulh,
   Gfun(External (EF_runtime "__compcert_i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umulh,
   Gfun(External (EF_runtime "__compcert_i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_exit,
   Gfun(External (EF_external "exit"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons tint Tnil) tvoid cc_default)) ::
 (_free, Gfun(External EF_free (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_malloc,
   Gfun(External EF_malloc (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_makelock,
   Gfun(External (EF_external "makelock"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_acquire,
   Gfun(External (EF_external "acquire"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_freelock2,
   Gfun(External (EF_external "freelock2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_release2,
   Gfun(External (EF_external "release2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_spawn,
   Gfun(External (EF_external "spawn"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons
       (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default))
       (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_CAS_SC,
   Gfun(External (EF_external "CAS_SC"
                   (mksignature (AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     (Some AST.Tint) cc_default))
     (Tcons (tptr tint) (Tcons tint (Tcons tint Tnil))) tint cc_default)) ::
 (_m_entries, Gvar v_m_entries) :: (_thread_locks, Gvar v_thread_locks) ::
 (_results, Gvar v_results) ::
 (_surely_malloc, Gfun(Internal f_surely_malloc)) ::
 (_integer_hash, Gfun(Internal f_integer_hash)) ::
 (_set_item, Gfun(Internal f_set_item)) ::
 (_get_item, Gfun(Internal f_get_item)) ::
 (_add_item, Gfun(Internal f_add_item)) ::
 (_init_table, Gfun(Internal f_init_table)) :: (_f, Gfun(Internal f_f)) ::
 (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _f :: _init_table :: _add_item :: _get_item :: _set_item ::
 _integer_hash :: _surely_malloc :: _results :: _thread_locks ::
 _m_entries :: _CAS_SC :: _store_SC :: _load_SC :: _spawn :: _release2 ::
 _freelock2 :: _acquire :: _makelock :: _malloc :: _free :: _exit ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap64 :: ___compcert_i64_umulh :: ___compcert_i64_smulh ::
 ___compcert_i64_sar :: ___compcert_i64_shr :: ___compcert_i64_shl ::
 ___compcert_i64_umod :: ___compcert_i64_smod :: ___compcert_i64_udiv ::
 ___compcert_i64_sdiv :: ___compcert_i64_utof :: ___compcert_i64_stof ::
 ___compcert_i64_utod :: ___compcert_i64_stod :: ___compcert_i64_dtou ::
 ___compcert_i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fsqrt ::
 ___builtin_fabs :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___builtin_ais_annot :: nil).

Definition prog : Clight.program := 
  mkprogram composites global_definitions public_idents _main Logic.I. *)
Require Import atomics.hashtable.
(* atomics.hashtable:
Require Import VST.progs.conclib.
Require Import VST.floyd.sublist.

Set Bullet Behavior "Strict Subproofs".

Fixpoint index_of (m : list (Z * Z)) (k : Z) :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of rest k)
  end.

Lemma index_of_spec : forall k m, match index_of m k with
  | Some i => 0 <= i < Zlength m /\ fst (Znth i m) = k /\ Forall (fun x => fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) end.

Class hash_fun := { size : Z; hash : Z -> Z; size_pos : size > 0; hash_range : forall i, 0 <= hash i < size }.

Section Hashtable.

Context {hf : hash_fun}.
Hint Resolve size_pos hash_range.

Definition rebase {A} (m : list A) i := rotate m (Zlength m - i) (Zlength m).

Definition well_chained (m : list (Z * Z)) := forall k i, index_of (rebase m (hash k)) k = Some i ->
  Forall (fun x => fst x <> 0) (sublist 0 i (rebase m (hash k))).

Definition wf_map (m : list (Z * Z)) := NoDup (map fst m).

Definition indices i j := (map (fun x => (i + x) mod size) (upto (Z.to_nat ((j - i) mod size)))).

Fixpoint index_of' (m : list (Z * Z)) k :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 0 then Some 0 else
                        if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of' rest k)
  end.

Definition lookup (m : list (Z * Z)) (k : Z) :=
  option_map (fun i => (i + hash k) mod size) (index_of' (rebase m (hash k)) k).

Definition set m k v := option_map (fun i => upd_Znth i m (k, v)) (lookup m k).

Definition get m k := match lookup m k with Some i => let '(k', v') := Znth i m in
  if eq_dec k' 0 then None else Some v' | None => None end.

Lemma rebase_0 : forall {A} {d : Inhabitant A} (m : list A) i, 0 <= i < Zlength m -> Znth 0 (rebase m i) = Znth i m.

Lemma index_of'_spec : forall k m, match index_of' m k with
  | Some i => 0 <= i < Zlength m /\ (fst (Znth i m) = k \/ fst (Znth i m) = 0) /\
              Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) /\ ~In 0 (map fst m)
  end.

Lemma Znth_rebase : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth i (rebase m j) = Znth ((i + j) mod Zlength m) m.

Corollary Znth_rebase' : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth ((i - j) mod Zlength m) (rebase m j) = Znth i m.

Lemma index_of'_upd : forall m k v i (Hrange : 0 <= i < Zlength m)
  (Hi : fst (Znth i m) = k \/ fst (Znth i m) = 0),
  index_of' (upd_Znth i m (k, v)) k = index_of' m k.

Lemma Zlength_rebase : forall {A} (m : list A) i, 0 <= i < Zlength m -> Zlength (rebase m i) = Zlength m.

Lemma rebase_upd : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth i m x) j = upd_Znth ((i - j) mod Zlength m) (rebase m j) x.

Corollary rebase_upd' : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth ((i + j) mod Zlength m) m x) j = upd_Znth i (rebase m j) x.

Lemma lookup_set : forall m k v m', set m k v = Some m' -> Zlength m = size -> lookup m' k = lookup m k.

Lemma lookup_range : forall m k i, lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m.

Lemma index_of'_upd2 : forall m k i k' v' (Hrange : 0 <= i < Zlength m)
  (Hi : index_of' m k <> Some i) (Hdiff : k' <> k /\ k' <> 0),
  index_of' (upd_Znth i m (k', v')) k = index_of' m k.

Lemma lookup_upd_same : forall m k i v', lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  lookup (upd_Znth i m (k, v')) k = lookup m k.

Lemma lookup_upd_diff : forall m k i k' v', lookup m k <> Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  k' <> k /\ k' <> 0 ->
  lookup (upd_Znth i m (k', v')) k = lookup m k.

Lemma Zlength_set : forall m k v m', set m k v = Some m' -> Zlength m = size ->
  Zlength m' = size.

Lemma get_set_same : forall m k v m', set m k v = Some m' -> Zlength m = size -> k <> 0 ->
  get m' k = Some v.

Lemma get_override : forall m k v m' v', set m k v = Some m' -> Zlength m = size -> set m' k v' = set m k v'.

Lemma index_of_app : forall k m1 m2, index_of (m1 ++ m2) k =
  match index_of m1 k with Some i => Some i | None => option_map (Z.add (Zlength m1)) (index_of m2 k) end.

Lemma index_of_out : forall k m, Forall (fun x => fst x <> k) m -> index_of m k = None.

Lemma index_of_sublist : forall m a b i k (HNoDup : NoDup (map fst m))
  (Hi : index_of (sublist a b m) k = Some i) (Ha : 0 <= a) (Hb : b <= Zlength m),
  index_of m k = Some (i + a).

Lemma index_of_rotate : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rotate m n (Zlength m)) k = option_map (fun i => (i + n) mod Zlength m) (index_of m k).

Corollary index_of_rebase : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rebase m n) k = option_map (fun i => (i - n) mod Zlength m) (index_of m k).

Lemma index_of'_succeeds : forall k m i (Hi : 0 <= i < Zlength m)
  (Hnz : Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m))
  (Hk : fst (Znth i m) = k \/ fst (Znth i m) = 0), index_of' m k = Some i.

Lemma lookup_spec : forall m k (Hwf : wf_map m) (Hchain : well_chained m) (Hlen : Zlength m = size)
  (Hnz : k <> 0) (Hin : In k (map fst m)), lookup m k = index_of m k.

End Hashtable.

Lemma sepcon_rebase : forall l m, 0 <= m <= Zlength l ->
  fold_right sepcon emp l = fold_right sepcon emp (rebase l m).

Lemma rebase_map : forall {A B} (f : A -> B) l m, rebase (map f l) m = map f (rebase l m). *)

Set Bullet Behavior "Strict Subproofs".

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Section Proofs.

Definition makelock_spec := DECLARE _makelock (makelock_spec _).
Definition freelock2_spec := DECLARE _freelock2 (freelock2_spec _).
Definition acquire_spec := DECLARE _acquire acquire_spec.
Definition release2_spec := DECLARE _release2 release2_spec.
Definition spawn_spec := DECLARE _spawn spawn_spec.
Definition load_SC_spec := DECLARE _load_SC load_SC_spec.
Definition store_SC_spec := DECLARE _store_SC store_SC_spec.
Definition CAS_SC_spec := DECLARE _CAS_SC CAS_SC_spec.

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH t : type
   PRE [ _n OF tuint ]
       PROP (0 <= sizeof t <= Int.max_unsigned; complete_legal_cosu_type t = true;
             natural_aligned natural_alignment t = true)
       LOCAL (temp _n (Vint (Int.repr (sizeof t))))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh t p * data_at_ Tsh t p).

Definition integer_hash_spec :=
 DECLARE _integer_hash
  WITH i : Z
  PRE [ _i OF tint ]
   PROP () LOCAL (temp _i (vint i)) SEP ()
  POST [ tint ]
   PROP () LOCAL (temp ret_temp (vint (i * 654435761))) SEP ().

Definition tentry := Tstruct _entry noattr.

Definition has_size : {x : Z | x = 16384}.
Proof.
  eexists; eauto.
Qed.

Instance hf1 : hash_fun := { size := proj1_sig has_size; hash i := (i * 654435761) mod (proj1_sig has_size) }.
Proof.
  - rewrite (proj2_sig has_size); computable.
  - intro; apply Z_mod_lt; rewrite (proj2_sig has_size); computable.
Defined.

Instance zero_PCM : Ghost := { valid a := True;
  Join_G a b c := if eq_dec a 0 then c = b else c = a /\ (b = 0 \/ a = b) }.
Proof.
  - exists (fun _ => 0); auto.
    intro; hnf; auto.
  - constructor.
    + intros; hnf in *.
      if_tac in H; subst; auto.
      destruct H, H0; subst; auto.
    + intros; hnf in *.
      exists (if eq_dec b 0 then c else b); split; hnf.
      * if_tac; auto; split; auto.
        if_tac in H; subst.
        { rewrite if_false in H0 by auto; tauto. }
        destruct H as [? [|]]; try contradiction; subst.
        rewrite if_false in H0 by auto; tauto.
      * if_tac; subst.
        { if_tac in H0; tauto. }
        destruct H; subst.
        if_tac; subst.
        { if_tac in H0; subst; auto; contradiction. }
        destruct H2; try contradiction; subst.
        rewrite if_false in H0 by auto; tauto.
    + intros; hnf in *.
      if_tac; if_tac in H; subst; auto; try tauto.
      destruct H as [? [|]]; subst; auto; contradiction.
    + intros; hnf in *.
      if_tac in H; if_tac in H0; subst; auto; try tauto.
      destruct H; subst; contradiction.
  - auto.
Defined.

Instance zero_order : PCM_order (fun a b => a = 0 \/ a = b).
Proof.
  constructor; simpl; intros.
  - intro; auto.
  - intros ???[|][|]; subst; auto.
  - exists (if eq_dec a 0 then b else a).
    unfold sepalg.join; simpl.
    if_tac; auto.
    destruct H; [contradiction|].
    subst; repeat split; auto.
    destruct H0; auto.
  - hnf in H.
    if_tac in H; auto.
    destruct H; subst; split; auto.
    destruct H1; auto.
  - hnf.
    if_tac; subst.
    + destruct H; auto.
    + split; auto; destruct H; auto.
Defined.

Definition hashtable_entry T lg entries i :=
  let '(pk, pv) := Znth i entries in let '(ki, vi) := Znth i T in
  !!(repable_signed ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) &&
  ghost_master1(ORD := zero_order) ki (Znth i lg) *
  data_at Tsh tint (vint ki) pk * data_at Tsh tint (vint vi) pv.

Definition wf_table T := forall k i, k <> 0 -> fst (Znth i T) = k -> lookup T k = Some i.

Definition hashtable H g lg entries := EX T : list (Z * Z),
  !!(Zlength T = size /\ wf_table T /\ forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) &&
  excl g H * fold_right sepcon emp (map (hashtable_entry T lg entries) (upto (Z.to_nat size))).

Program Definition set_item_spec := DECLARE _set_item atomic_spec
  (ConstType (Z * Z * globals * share * list (val * val) * gname * list gname))
  [(_key, tint); (_value, tint)] tvoid
  [fun _ '(k, v, gv, sh, entries, g, lg) => temp _key (vint k);
   fun _ '(k, v, gv, sh, entries, g, lg) => temp _value (vint v);
   fun _ '(k, v, gv, sh, entries, g, lg) => gvars gv]
  (fun _ '(k, v, gv, sh, entries, g, lg) => !!(readable_share sh /\ repable_signed k /\ repable_signed v /\
   k <> 0 /\ v <> 0 /\ Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lg = size) &&
   data_at sh (tarray tentry size) entries (gv _m_entries))
  (fun _ '(k, v, gv, sh, entries, g, lg) H => hashtable H g lg entries)
  tt []
  (fun _ '(k, v, gv, sh, entries, g, lg) H _ =>
   data_at sh (tarray tentry size) entries (gv _m_entries) * hashtable (map_upd H k v) g lg entries)
  (Empty_set _) (Full_set _) _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.

Program Definition get_item_spec := DECLARE _get_item atomic_spec
  (ConstType (Z * globals * share * list (val * val) * gname * list gname))
  [(_key, tint)] tint
  [fun _ '(k, p, sh, entries, g, lg) => temp _key (vint k);
   fun _ '(k, gv, sh, entries, g, lg) => gvars gv]
  (fun _ '(k, gv, sh, entries, g, lg) => !!(readable_share sh /\ repable_signed k /\ k <> 0 /\
   Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lg = size) &&
   data_at sh (tarray tentry size) entries (gv _m_entries))
  (fun _ '(k, p, sh, entries, g, lg) H => hashtable H g lg entries)
  0 [fun _ _ v => temp ret_temp (vint v)]
  (fun _ '(k, gv, sh, entries, g, lg) H v => data_at sh (tarray tentry size) entries (gv _m_entries) *
   (!!(if eq_dec v 0 then H k = None else H k = Some v) && hashtable H g lg entries))
  (Empty_set _) (Full_set _) _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? (((((k, p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? (((((k, p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? (((((k, p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? (((((k, p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? (((((k, p), sh), entries), g), lg); auto.
Qed.

Program Definition add_item_spec := DECLARE _add_item atomic_spec
  (ConstType (Z * Z * globals * share * list (val * val) * gname * list gname))
  [(_key, tint); (_value, tint)] tint
  [fun _ '(k, v, p, sh, entries, g, lg) => temp _key (vint k);
   fun _ '(k, v, p, sh, entries, g, lg) => temp _value (vint v);
   fun _ '(k, v, gv, sh, entries, g, lg) => gvars gv]
  (fun _ '(k, v, gv, sh, entries, g, lg) => !!(readable_share sh /\ repable_signed k /\ repable_signed v /\
   k <> 0 /\ v <> 0 /\ Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries /\ Zlength lg = size) &&
   data_at sh (tarray tentry size) entries (gv _m_entries))
  (fun _ '(k, v, p, sh, entries, g, lg) H => hashtable H g lg entries)
  true [fun _ _ b => temp ret_temp (Val.of_bool b)]
  (fun _ '(k, v, gv, sh, entries, g, lg) H b => data_at sh (tarray tentry size) entries (gv _m_entries) *
   (!!(H k = None <-> b = true) && hashtable (if b then map_upd H k v else H) g lg entries))
  (Empty_set _) (Full_set _) _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.
Next Obligation.
Proof.
  intros ?? ((((((k, v), p), sh), entries), g), lg); auto.
Qed.

Definition init_table_spec :=
 DECLARE _init_table
  WITH gv : globals
  PRE [ ]
   PROP ()
   LOCAL (gvars gv)
   SEP (data_at_ Ews (tarray tentry size) (gv _m_entries))
  POST [ tvoid ]
   EX entries : list (val * val), EX g : gname, EX lg : list gname,
   PROP (Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength lg = size)
   LOCAL ()
   SEP (data_at Ews (tarray tentry size) entries (gv _m_entries); fold_right sepcon emp (map (fun '(pk, pv) =>
          malloc_token Tsh tint pk * malloc_token Tsh tint pv) entries);
        hashtable empty_map g lg entries).

Inductive hashtable_hist_el :=
  | HSet (k : Z) (v : Z) | HGet (k : Z) (v : Z) | HAdd (k : Z) (v : Z) (r : bool).

Notation hist := (nat -> option hashtable_hist_el).

Fixpoint apply_hist H h :=
  match h with
  | [] => Some H
  | HSet k v :: h' => apply_hist (map_upd H k v) h'
  | HGet k v :: h' => match H k with Some v' => if eq_dec v' v then apply_hist H h' else None
                      | None => if eq_dec v 0 then apply_hist H h' else None end
  | HAdd k v r :: h' => match H k with None => if r then apply_hist (map_upd H k v) h' else None
                        | Some _ => if r then None else apply_hist H h' end
  end.

Definition hashtable_inv gh g lg entries := EX H : _, hashtable H g lg entries *
  EX hr : _, !!(apply_hist empty_map hr = Some H) && ghost_ref hr gh.

Definition f_lock_inv sh gsh entries gh p t locksp lockt resultsp res :=
  EX b1 : bool, EX b2 : bool, EX b3 : bool, EX h : _,
    !!(add_events empty_map [HAdd 1 1 b1; HAdd 2 1 b2; HAdd 3 1 b3] h) && ghost_hist gsh h gh *
    data_at sh (tarray tentry size) entries p *
    data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp *
    data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp *
    data_at Tsh tint (vint (Zlength (filter id [b1; b2; b3]))) res.

Definition f_lock_pred tsh sh gsh entries gh p t locksp lockt resultsp res :=
  selflock (f_lock_inv sh gsh entries gh p t locksp lockt resultsp res) tsh lockt.

Definition f_spec :=
 DECLARE _f
  WITH tid : val, x : share * share * share * list (val * val) * iname * gname * gname * list gname * globals * Z * val *
                      val * val * val * invG
  PRE [ _arg OF (tptr tvoid) ]
   let '(sh, gsh, tsh, entries, i, gh, g, lg, gv, t, locksp, lockt, resultsp, res, inv_names) := x in
   PROP (0 <= t < 3; isptr lockt; readable_share sh; readable_share tsh; gsh <> Share.bot;
         Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength lg = size)
   LOCAL (temp _arg tid; gvars gv)
   SEP (data_at sh (tarray tentry size) entries (gv _m_entries);
        invariant i (hashtable_inv gh g lg entries);
        ghost_hist(hist_el := hashtable_hist_el) gsh empty_map gh;
        data_at Tsh tint (vint t) tid; malloc_token Tsh tint tid;
        data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) (gv _thread_locks);
        data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) (gv _results);
        data_at_ Tsh tint res;
        lock_inv tsh lockt (f_lock_pred tsh sh gsh entries gh (gv _m_entries) t
                                        (gv _thread_locks) lockt (gv _results) res))
  POST [ tptr tvoid ] PROP () LOCAL () SEP ().

Definition main_spec :=
 DECLARE _main
  WITH gv : globals
  PRE  [] main_pre prog [] gv
  POST [ tint ] main_post prog [] gv.

Definition Gprog : funspecs := ltac:(with_library prog [makelock_spec; freelock2_spec; acquire_spec;
  release2_spec; spawn_spec; surely_malloc_spec; load_SC_spec; store_SC_spec; CAS_SC_spec;
  integer_hash_spec; set_item_spec; get_item_spec; add_item_spec; init_table_spec; f_spec; main_spec]).

Lemma body_integer_hash: semax_body Vprog Gprog f_integer_hash integer_hash_spec.
Proof.
  start_function.
  forward.
Qed.

Opaque upto.

Lemma hash_size : forall k, (k * 654435761) mod size = hash k mod size.
Proof.
  intro; simpl.
  rewrite Zmod_mod; split; auto; omega.
Qed.

Arguments size : simpl never.
Arguments hash : simpl never.

Lemma failed_entries : forall k i i1 keys lg T entries (Hk : k <> 0) (Hi : 0 <= i < size)
  (Hi1 : (i + hash k) mod size = i1 mod size) (HT : Zlength T = size) (Hlg : Zlength lg = size)
  (Hkeys: Zlength keys = size)
  (Hfail : Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k)))),
  fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
  fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
    (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))
  |-- !! Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i (rebase T (hash k))).
Proof.
  intros.
  rewrite Forall_forall, prop_forall; apply allp_right; intros (k', v').
  rewrite prop_forall; apply allp_right; intro Hin.
  apply In_Znth in Hin; destruct Hin as (j & Hj & Hjth).
  pose proof (hash_range k).
  rewrite Zlength_sublist in Hj by (rewrite ?Zlength_rebase; omega).
  rewrite Znth_sublist, Znth_rebase in Hjth by omega.
  assert (0 <= (j + hash k) mod size < size) by (apply Z_mod_lt, size_pos).
  pose proof (Z_mod_lt i1 _ size_pos).
  rewrite extract_nth_sepcon with (i := (j + hash k) mod size), extract_nth_sepcon with (i := j)(l := map _ _)
    by (rewrite ?upd_Znth_Zlength; rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
  assert ((j + hash k) mod size <> i1 mod size).
  { rewrite <- Hi1; intro Heq.
    apply Zmod_plus_inv in Heq; [|apply size_pos].
    rewrite !Zmod_small in Heq; omega. }
  erewrite !upd_Znth_diff', !Znth_map, !Znth_upto by
    (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; omega).
  unfold hashtable_entry.
  rewrite Z.add_0_r in Hjth; replace (Zlength T) with size in Hjth; rewrite Hjth.
  destruct (Znth _ entries).
  Intros; rewrite <- !sepcon_assoc.
  rewrite (sepcon_comm _ (ghost_snap(P := zero_PCM) _ _)).
  rewrite <- !sepcon_assoc, snap_master_join1 by auto.
  Intros; apply prop_right; simpl.
  eapply Forall_Znth in Hfail.
  rewrite Znth_sublist, Z.add_0_r, Znth_rebase with (i0 := j) in Hfail; auto; try omega.
  replace (Zlength keys) with size in Hfail; intuition.
  { rewrite Zlength_sublist; auto; try omega.
    rewrite Zlength_rebase; omega. }
Qed.

Corollary entries_lookup : forall k i i1 keys lg T entries (Hk : k <> 0) (Hi : 0 <= i < size)
  (Hi1 : (i + hash k) mod size = i1 mod size) (HT : Zlength T = size) (Hlg : Zlength lg = size)
  (Hkeys: Zlength keys = size)
  (Hfail : Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k))))
  (Hhit : fst (Znth (i1 mod size) T) = k \/ fst (Znth (i1 mod size) T) = 0),
  fold_right sepcon emp (upd_Znth (i1 mod size) (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
  fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
    (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))
  |-- !! (lookup T k = Some (i1 mod size)).
Proof.
  intros.
  eapply derives_trans; [apply failed_entries; eauto | apply prop_left; intro; apply prop_right].
  pose proof (hash_range k).
  unfold lookup; erewrite index_of'_succeeds.
  simpl; eauto.
  - rewrite Zlength_rebase; omega.
  - auto.
  - rewrite Znth_rebase by omega.
    rewrite HT, Hi1; auto.
Qed.

Lemma wf_table_upd : forall T k v i (Hwf : wf_table T) (HT : Zlength T = size) (Hi : lookup T k = Some i)
  (Hk : k <> 0), wf_table (upd_Znth i T (k, v)).
Proof.
  intros; intros ?? Hj ?.
  exploit lookup_range; eauto; intro.
  destruct (eq_dec i0 i); subst.
  - rewrite upd_Znth_same, lookup_upd_same; auto.
  - rewrite upd_Znth_diff' in Hj |- * by auto.
    assert (lookup T (fst (Znth i0 T)) <> Some i).
    { erewrite Hwf by eauto; congruence. }
    rewrite lookup_upd_diff; auto.
    split; auto.
    intro; erewrite Hwf in Hi by eauto; congruence.
Qed.

Corollary wf_table_upd_same : forall T k v i (Hwf : wf_table T) (HT : Zlength T = size)
  (Hi : fst (Znth i T) = k) (Hk : k <> 0), wf_table (upd_Znth i T (k, v)).
Proof.
  intros; apply wf_table_upd; auto.
Qed.

Lemma snaps_dealloc : forall {A} (l : list A) f g, fold_right sepcon emp (map (fun i => ghost_snap (f i) (g i)) l) |-- |==> emp.
Proof.
  induction l; simpl; intros.
  - apply bupd_intro.
  - eapply derives_trans; [apply sepcon_derives; [apply own_dealloc | apply IHl]|].
    setoid_rewrite <- emp_sepcon at 7; apply bupd_sepcon.
Qed.

Lemma body_set_item : semax_body Vprog Gprog f_set_item set_item_spec.
Proof.
  start_atomic_function.
  destruct x as ((((((k, v), gv), sh), entries), g), lg); Intros.
  forward_call k.
  pose proof size_pos.
  unfold atomic_shift; Intros P.
  set (AS := _ -* _).
  forward_loop (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvars gv)
    SEP (|> P; AS && cored;
         @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))))%assert
    continue: (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (Int.min_signed <= Int.signed (Int.repr i1) < Int.max_signed; i1 mod size = (i + hash k) mod size;
          0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 (i + 1) (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvars gv)
    SEP (|> P; AS && cored; @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat (i + 1))))))%assert.
  { Exists 0 (k * 654435761)%Z (repeat 0 (Z.to_nat size)); rewrite sublist_nil; entailer!.
    split; [apply hash_size|].
    rewrite Zlength_repeat, Z2Nat.id; auto; omega.
    { simpl; auto. } }
  - Intros i i1 keys; forward.
    rewrite sub_repr, and_repr; simpl.
    rewrite Zland_two_p with (n := 14) by omega.
    replace (2 ^ 14) with size by (setoid_rewrite (proj2_sig has_size); auto).
    exploit (Z_mod_lt i1 size); [omega | intro Hi1].
    assert_PROP (Zlength entries = size) as Hentries by entailer!.
    assert (0 <= i1 mod size < Zlength entries) as Hi1' by omega.
    match goal with H : Forall _ _ |- _ => pose proof (Forall_Znth _ _ _ Hi1' H) as Hptr end.
    destruct (Znth (i1 mod size) entries) as (pki, pvi) eqn: Hpi; destruct Hptr.
    forward; setoid_rewrite Hpi.
    { entailer!. }
    assert (Zlength (rebase keys (hash k)) = size) as Hrebase.
    { rewrite Zlength_rebase; replace (Zlength keys) with size; auto; apply hash_range. }
    replace_SEP 1 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
    forward_call (pki, AS && cored * |> P, Full_set iname, Empty_set iname,
      fun sh v => !!(sh = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
      forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
      !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) && ghost_master1 ki (Znth (i1 mod size) lg) *
      data_at Tsh tint (vint vi) pvi * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
          (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
      (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
      fun v : Z => |> P * ghost_snap v (Znth (i1 mod size) lg)).
    { cancel.
      rewrite <- emp_sepcon at 1; apply sepcon_derives; [|cancel].
      rewrite <- emp_sepcon at 1; apply sepcon_derives.
      + rewrite <- wand_sepcon_adjoint, emp_sepcon.
        unfold AS.
        rewrite sepcon_comm.
        eapply derives_trans; [apply sepcon_derives, andp_left1; apply derives_refl|].
        eapply derives_trans; [apply modus_ponens_wand | apply fupd_mono].
        Intros HT.
        eapply derives_trans; [apply sepcon_derives, andp_left1; apply derives_refl|].
        unfold hashtable at 1; Intros T.
        rewrite extract_nth_sepcon with (i := i1 mod size)
          by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
        unfold hashtable_entry.
        rewrite Hpi.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi.
        Intros; Exists Tsh ki HT T; rewrite HHi; entailer!.
        apply derives_refl.
      + apply allp_right; intro sh0.
        apply allp_right; intro v0.
        rewrite <- wand_sepcon_adjoint, emp_sepcon.
        Intros HT T.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
        rewrite !sepcon_assoc; eapply derives_trans.
        { apply sepcon_derives, derives_refl.
          apply (make_snap(ORD := zero_order)). }
        eapply derives_trans; [apply bupd_frame_r|].
        apply fupd_bupd, bupd_mono.
        eapply derives_trans, fupd_frame_r.
        subst v0; cancel.
        apply modus_ponens_wand'.
        unfold hashtable; Exists T.
        rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ _)
          by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
        unfold hashtable_entry.
        rewrite Hpi, HHi; entailer!.
        apply derives_refl. }
    Intros k1.
    focus_SEP 1.
    match goal with |- semax _ (PROP () (LOCALx (_ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>
      forward_if (PROP () (LOCALx Q (SEPx (ghost_snap k (Znth (i1 mod size) lg) :: R)))) end.
    + assert (forall k1, (k1 <> k /\ k1 <> 0) ->
        Zlength (upd_Znth (i1 mod size) keys k1) = size /\
        Forall (fun z => z <> 0 /\ z <> k)
          (sublist 0 (i + 1) (rebase (upd_Znth (i1 mod size) keys k1) (hash k)))).
      { split; [rewrite upd_Znth_Zlength; auto; omega|].
        replace (i1 mod size) with ((i + hash k) mod size); replace size with (Zlength keys);
          rewrite !rebase_upd' by (try omega; replace (Zlength keys) with size; apply Z_mod_lt; omega).
        rewrite sublist_upd_Znth_lr by (try omega; setoid_rewrite Hrebase; omega).
        rewrite sublist_split with (mid := i), sublist_len_1 by (try omega; setoid_rewrite Hrebase; omega).
        rewrite Z.sub_0_r, upd_Znth_app2, Forall_app; rewrite Zlength_sublist;
          rewrite ?Zlength_cons, ?Zlength_nil; try omega; try (setoid_rewrite Hrebase; omega).
        split; auto.
        rewrite Z.sub_0_r, Zminus_diag, upd_Znth0, Zlength_cons, sublist_1_cons, sublist_same
          by (auto; omega).
        repeat constructor; auto; tauto. }
      forward_if (k1 = 0).
      { eapply semax_pre; [|apply semax_continue].
        unfold POSTCONDITION, abbreviate, overridePost, loop1_ret_assert, frame_ret_assert,
          function_body_ret_assert, RA_continue.
        Exists i (i1 mod size) (upd_Znth (i1 mod size) keys k1).
        rewrite Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.
        change (upto (Z.to_nat 1)) with [0]; simpl fold_right; rewrite Z2Nat.id, Z.add_0_r by omega.
        replace ((i + hash k) mod size) with (i1 mod size); rewrite Zmod_mod, upd_Znth_same by omega; entailer!.
        { assert (Int.min_signed <= i1 mod size < Int.max_signed).
          { split; etransitivity; try apply Z_mod_lt; auto; try computable.
            setoid_rewrite (proj2_sig has_size); computable. }
          rewrite Int.signed_repr by omega; auto. }
        erewrite map_ext_in; [apply derives_refl|]; simpl; intros.
        rewrite upd_Znth_diff'; auto; try omega.
        replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.
        rewrite In_upto, Z2Nat.id in * by omega.
        rewrite !Zmod_small in X; omega. }
      { forward.
        entailer!. }
      Intros; subst.
      replace_SEP 2 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
      forward_call (pki, 0, k, |> P * (AS && cored) * ghost_snap 0 (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
             (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))),
        Full_set iname, Empty_set iname, fun sh v => !!(sh = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
          forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
          !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) &&
          ghost_master1 ki (Znth (i1 mod size) lg) * data_at Tsh tint (vint vi) pvi *
          excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
            (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
          ghost_snap 0 (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
             (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))) *
          (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
        fun v : Z => |> P * ghost_snap (if eq_dec v 0 then k else v) (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
             (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))).
      { cancel.
        rewrite sepcon_comm, <- emp_sepcon at 1.
        rewrite <- sepcon_assoc.
        apply sepcon_derives; [|cancel]; apply sepcon_derives, derives_refl.
        rewrite <- emp_sepcon at 1; apply sepcon_derives.
        * rewrite <- wand_sepcon_adjoint, emp_sepcon.
          rewrite sepcon_assoc, (sepcon_comm _ (AS && cored)); unfold AS.
          eapply derives_trans.
          { apply sepcon_derives, derives_refl.
            eapply derives_trans; [apply sepcon_derives; [apply andp_left1|]; apply derives_refl|].
            rewrite sepcon_comm; apply modus_ponens_wand. }
          eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
          Intros HT.
          rewrite (sepcon_comm _ (_ && _)), !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives; [apply andp_left1|]; apply derives_refl|].
          unfold hashtable at 2; Intros T.
          rewrite extract_nth_sepcon with (i := i1 mod size) by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi.
          Exists Tsh ki HT T; rewrite HHi; entailer!.
          apply derives_refl.
        * apply allp_right; intro sh0.
          apply allp_right; intro v0.
          rewrite <- wand_sepcon_adjoint, emp_sepcon.
          Intros HT T.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          assert (0 <= i1 mod size < Zlength T) by omega.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
          rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
          rewrite 5sepcon_assoc; eapply derives_trans; [apply sepcon_derives, derives_refl|].
          { apply snap_master_update1 with (v' := if eq_dec ki 0 then k else ki).
            if_tac; auto. }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd, bupd_mono].
          assert (0 <= hash k < Zlength T) by (replace (Zlength T) with size; apply hash_range).
          assert (0 <= i < Zlength (rebase T (hash k))) by (rewrite Zlength_rebase; auto; omega).
          assert (fst (Znth i (rebase T (hash k))) = ki).
          { rewrite Znth_rebase by (auto; omega).
            replace (Zlength T) with size; replace ((i + hash k) mod size) with (i1 mod size); rewrite HHi; auto. }
          assert_PROP ((ki = k \/ ki = 0) -> lookup T k = Some (i1 mod size)) as Hindex.
          { rewrite prop_forall; apply allp_right; intro Hki.
            rewrite <- 3sepcon_assoc, sepcon_comm.
            rewrite <- !sepcon_assoc, 5sepcon_assoc.
            apply sepcon_derives_prop, entries_lookup; auto.
            rewrite HHi; destruct Hki; subst; auto. }
          rewrite !sepcon_assoc; eapply derives_trans, fupd_frame_r; subst v0; cancel.
          rewrite !sepcon_assoc, sepcon_comm; apply sepcon_derives, derives_refl.
          rewrite <- !sepcon_assoc, sepcon_comm.
          rewrite sepcon_comm; apply modus_ponens_wand'.
          unfold hashtable; Exists (upd_Znth (i1 mod size) T (if eq_dec ki 0 then k else ki, vi)).
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi, upd_Znth_same by omega; entailer!.
          { split; [rewrite upd_Znth_Zlength; auto|].
            split; [|if_tac; auto].
            if_tac; [subst | erewrite upd_Znth_triv; eauto].
            split; [apply wf_table_upd; auto|].
            intros.
            etransitivity; eauto; split; intros (Hin & ?); split; auto.
            - eapply In_upd_Znth_old; auto; try omega.
              rewrite HHi; intro X; inv X; tauto.
            - apply In_upd_Znth in Hin; destruct Hin as [X|]; [inv X; tauto | auto]. }
          apply sepcon_derives; [apply derives_refl|].
          apply sepcon_list_derives; rewrite !upd_Znth_Zlength;
            rewrite !Zlength_map, !Zlength_upto, !Z2Nat.id; auto; try omega.
          intros; destruct (eq_dec i0 (i1 mod size)).
          { subst; rewrite !upd_Znth_same by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; auto; omega); auto. }
          rewrite !upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; auto; omega).
          erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
          rewrite upd_Znth_diff'; auto. }
      Intros k1.
      focus_SEP 1.
      match goal with |- semax _ (PROP () (LOCALx (_ :: _ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>
        forward_if (PROP () ((LOCALx Q) (SEPx (ghost_snap k (Znth (i1 mod size) lg) :: R)))) end.
      * if_tac; [discriminate|].
        replace_SEP 3 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
        forward_call (pki, |> P * (AS && cored) * ghost_snap k1 (Znth (i1 mod size) lg), Full_set iname, Empty_set iname,
          fun sh v => !!(sh = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
            forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
            !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) &&
            ghost_master1 ki (Znth (i1 mod size) lg) * data_at Tsh tint (vint vi) pvi *
            excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
              (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
            ghost_snap k1 (Znth (i1 mod size) lg) *
            (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
          fun v : Z => |> P * (!!(v = k1) && ghost_snap k1 (Znth (i1 mod size) lg))).
        { cancel.
          rewrite <- emp_sepcon at 1; apply sepcon_derives; [|cancel].
          rewrite <- emp_sepcon at 1; apply sepcon_derives.
          + rewrite <- wand_sepcon_adjoint, emp_sepcon.
            eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left1|]; apply derives_refl|].
            unfold AS.
            eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
            eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
            Intros HT.
            eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left1|]; apply derives_refl|].
            unfold hashtable at 1; Intros T.
            rewrite extract_nth_sepcon with (i := i1 mod size)
              by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
            erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
            unfold hashtable_entry.
            rewrite Hpi.
            destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi.
            Exists Tsh ki HT T; rewrite HHi; entailer!.
            apply derives_refl.
          + apply allp_right; intro sh0.
            apply allp_right; intro v0.
            rewrite <- wand_sepcon_adjoint, emp_sepcon.
            Intros HT T.
            destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
            rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
            rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
            rewrite snap_master_join1; Intros.
            rewrite <- (prop_true_andp _ (ghost_master1 _ _) H28).
            rewrite <- (@snap_master_join1 _ _ zero_order).
            destruct H28; [contradiction | subst].
            rewrite prop_true_andp by auto.
            eapply derives_trans, fupd_frame_r; cancel.
            apply modus_ponens_wand'.
            unfold hashtable; Exists T.
            rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ _)
              by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
            erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
            unfold hashtable_entry.
            rewrite Hpi, HHi; entailer!.
            apply derives_refl. }
        Intros k2; subst.
        forward_if (k1 = k).
        { eapply semax_pre; [|apply semax_continue].
          unfold POSTCONDITION, abbreviate, overridePost, loop1_ret_assert, frame_ret_assert,
            function_body_ret_assert, RA_continue.
          Exists i (i1 mod size) (upd_Znth (i1 mod size) keys k1).
          rewrite Zmod_mod, Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.
          change (upto (Z.to_nat 1)) with [0]; simpl fold_right; rewrite Z2Nat.id, Z.add_0_r by omega.
          replace ((i + hash k) mod size) with (i1 mod size); rewrite upd_Znth_same by omega; entailer!.
          { assert (Int.min_signed <= i1 mod size < Int.max_signed).
            { split; etransitivity; try apply Z_mod_lt; auto; try computable.
              setoid_rewrite (proj2_sig has_size); computable. }
            rewrite Int.signed_repr by omega; auto. }
          erewrite map_ext_in; [apply derives_refl|]; simpl; intros.
          rewrite upd_Znth_diff'; auto; try omega.
          replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.
          rewrite In_upto, Z2Nat.id in * by omega.
          rewrite !Zmod_small in X; omega. }
        { forward.
          entailer!. }
        entailer!.
      * forward.
        if_tac; [|contradiction].
        subst; entailer!.
      * entailer!.
    + forward.
      subst; entailer!.
    + forward; setoid_rewrite Hpi.
      { entailer!. }
      forward_call (pvi, v, |> P * (AS && cored) * ghost_snap k (Znth (i1 mod size) lg) *
          data_at sh (tarray tentry size) entries (gv _m_entries) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
             (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))),
        Full_set iname, Empty_set iname,
        fun sh1 => !!(sh1 = Tsh) && data_at sh (tarray tentry size) entries (gv _m_entries) *
        EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
            forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
        !!(ki = k /\ repable_signed vi) && ghost_master1 k (Znth (i1 mod size) lg) *
        data_at Tsh tint (vint k) pki * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
            (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
          ghost_snap k (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
             (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))) *
          (ALL y : unit, (data_at sh (tarray tentry size) entries (gv _m_entries) *
              hashtable (map_upd H k v) g lg entries) -* |={Empty_set iname,Full_set iname}=> Q y),
        Q tt).
      { cancel.
        rewrite <- emp_sepcon, <- sepcon_emp at 1.
        apply sepcon_derives; [|cancel].
        apply sepcon_derives, derives_refl.
        rewrite <- emp_sepcon at 1; apply sepcon_derives.
        + rewrite <- wand_sepcon_adjoint, emp_sepcon.
          rewrite !sepcon_assoc; eapply derives_trans.
          { apply sepcon_derives, sepcon_derives; [|apply andp_left1|]; apply derives_refl. }
          rewrite <- sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
          eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
          Intros HT.
          eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left2|]; apply derives_refl|].
          unfold hashtable at 1; Intros T.
          rewrite extract_nth_sepcon with (i := i1 mod size)
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
          rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
          rewrite snap_master_join1, !sepcon_andp_prop'; Intros.
          rewrite <- (prop_true_andp _ (ghost_master1 _ _) H20).
          rewrite <- (@snap_master_join1 _ _ zero_order).
          destruct H20; [contradiction | subst].
          Exists Tsh HT T; rewrite HHi; entailer!.
          rewrite sepcon_comm; apply derives_refl.
        + apply allp_right; intro sh0.
          rewrite <- wand_sepcon_adjoint, emp_sepcon.
          Intros HT T.
          destruct (Znth (i1 mod size) T) eqn: HHi; Intros.
          rewrite <- !sepcon_assoc.
          rewrite (sepcon_comm _(excl g HT)), !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives, derives_refl|].
          { apply exclusive_update with (v' := map_upd HT k v). }
          eapply derives_trans; [apply bupd_frame_r|].
          apply fupd_bupd_elim.
          rewrite <- !sepcon_assoc, sepcon_comm.
          rewrite <- !sepcon_assoc, sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives; [apply derives_refl|]|].
          { eapply derives_trans, bupd_sepcon.
            apply sepcon_derives; [apply own_dealloc|].
            apply snaps_dealloc. }
          eapply derives_trans; [apply bupd_frame_l | apply fupd_bupd_elim].
          rewrite !sepcon_assoc, sepcon_comm.
          eapply derives_trans; [eapply sepcon_derives, allp_left; apply derives_refl|].
          apply modus_ponens_wand'.
          unfold hashtable.
          Exists (upd_Znth (i1 mod size) T (k, v)).
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite upd_Znth_same by omega.
          assert (0 <= hash k < Zlength T) by (replace (Zlength T) with size; apply hash_range).
          rewrite Hpi; entailer!.
          { split; [rewrite upd_Znth_Zlength; omega|].
            split; [apply wf_table_upd_same; rewrite ?HHi; auto|].
            intros; unfold map_upd; if_tac.
            * split; [intro X; inv X; split; auto; apply upd_Znth_In|].
              subst; intros (Hin & ?).
              apply In_Znth in Hin; destruct Hin as (j & Hj & Hjth).
              destruct (eq_dec j (i1 mod size)).
              { subst; rewrite upd_Znth_same in Hjth by omega; inv Hjth; auto. }
              rewrite upd_Znth_diff' in Hjth by (auto; omega).
              match goal with H : wf_table T |- _ => exploit (H k j); rewrite ?Hjth; auto;
                exploit (H k (i1 mod size)); rewrite ?HHi; auto end.
              congruence.
            * etransitivity; eauto; split; intros (Hin & ?); split; auto.
              -- eapply In_upd_Znth_old; auto; try omega.
                 rewrite HHi; intro X; inv X; contradiction.
              -- apply In_upd_Znth in Hin; destruct Hin as [X|]; [inv X; tauto | auto]. }
          apply sepcon_derives; [apply derives_refl|].
          apply sepcon_list_derives; rewrite !upd_Znth_Zlength;
            rewrite !Zlength_map, !Zlength_upto, !Z2Nat.id; auto; try omega.
          intros; destruct (eq_dec i0 (i1 mod size)).
          { subst; rewrite !upd_Znth_same by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; auto; omega); auto. }
          rewrite !upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; auto; omega).
          erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
          rewrite upd_Znth_diff'; auto; omega. }
      forward.
      Exists tt; entailer!.
  - Intros i i1 keys.
    forward.
    { entailer!.
      rewrite (Int.signed_repr 1) by computable; omega. }
    Exists (i + 1) (i1 + 1) keys; entailer!.
    split.
    { rewrite <- Zplus_mod_idemp_l.
      replace (i1 mod _) with ((i + hash k) mod size); simpl.
      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }
    admit. 
Admitted.

Lemma body_get_item : semax_body Vprog Gprog f_get_item get_item_spec.
Proof.
  start_atomic_function.
  destruct x as (((((k, gv), sh), entries), g), lg); Intros.
  forward_call k.
  pose proof size_pos.
  unfold atomic_shift; Intros P.
  set (AS := _ -* _).
  forward_loop (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); gvars gv)
    SEP (|> P; AS && cored; @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))))%assert
    continue: (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (Int.min_signed <= Int.signed (Int.repr i1) < Int.max_signed;
          i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 (i + 1) (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); gvars gv)
    SEP (|> P; AS && cored; @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat (i + 1))))))%assert.
  { Exists 0 (k * 654435761)%Z (repeat 0 (Z.to_nat size)); rewrite sublist_nil; entailer!.
    split; [apply hash_size|].
    rewrite Zlength_repeat, Z2Nat.id; auto; omega.
    { simpl; auto. } }
  - Intros i i1 keys; forward.
    rewrite sub_repr, and_repr; simpl.
    rewrite Zland_two_p with (n := 14) by omega.
    replace (2 ^ 14) with size by (setoid_rewrite (proj2_sig has_size); auto).
    exploit (Z_mod_lt i1 size); [omega | intro Hi1].
    assert_PROP (Zlength entries = size) as Hentries by entailer!.
    assert (0 <= i1 mod size < Zlength entries) as Hi1' by omega.
    match goal with H : Forall _ _ |- _ => pose proof (Forall_Znth _ _ _ Hi1' H) as Hptr end.
    destruct (Znth (i1 mod size) entries) as (pki, pvi) eqn: Hpi; destruct Hptr.
    forward; setoid_rewrite Hpi.
    { entailer!. }
    assert (Zlength (rebase keys (hash k)) = size) as Hrebase.
    { rewrite Zlength_rebase; replace (Zlength keys) with size; auto; apply hash_range. }
    replace_SEP 1 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
    forward_call (pki, |> P * (AS && cored) * fold_right sepcon emp (map (fun i0 : Z =>
        ghost_snap (Znth ((i0 + hash k) mod size) keys) (Znth ((i0 + hash k) mod size) lg))
        (upto (Z.to_nat i))) * data_at sh (tarray tentry size) entries (gv _m_entries), Full_set iname, Empty_set iname,
      fun sh1 v => !!(sh1 = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
      forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
      !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) && ghost_master1 ki (Znth (i1 mod size) lg) *
      data_at Tsh tint (vint vi) pvi * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
          (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
        fold_right sepcon emp (map (fun i0 : Z => ghost_snap (Znth ((i0 + hash k) mod size) keys)
          (Znth ((i0 + hash k) mod size) lg)) (upto (Z.to_nat i))) *
        data_at sh (tarray tentry size) entries (gv _m_entries) *
      ((hashtable H g lg entries -*
              (|={ Empty_set iname, Full_set iname }=> |> P)) &&
             (ALL y : Z ,
              data_at sh (tarray tentry size) entries (gv _m_entries) *
              (!! (if eq_dec y 0 then H k = None else H k = Some y) &&
               hashtable H g lg entries) -*
              (|={ Empty_set iname, Full_set iname }=> Q y))),
      fun v => if eq_dec v 0 then Q v else |> P * ghost_snap v (Znth (i1 mod size) lg) *
        fold_right sepcon emp (map (fun i0 : Z => ghost_snap (Znth ((i0 + hash k) mod size) keys)
          (Znth ((i0 + hash k) mod size) lg)) (upto (Z.to_nat i))) *
        data_at sh (tarray tentry size) entries (gv _m_entries)).
    { cancel.
      rewrite sepcon_comm, <- emp_sepcon at 1.
      rewrite <- sepcon_assoc; apply sepcon_derives; [|cancel].
      apply sepcon_derives, derives_refl.
      rewrite <- emp_sepcon at 1; apply sepcon_derives.
      + rewrite <- wand_sepcon_adjoint, emp_sepcon.
        unfold AS.
        rewrite sepcon_assoc.
        eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left1|]; apply derives_refl|].
        eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand |].
        eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
        Intros HT.
        unfold hashtable at 1; Intros T.
        rewrite extract_nth_sepcon with (i := i1 mod size)
          by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
        unfold hashtable_entry.
        rewrite Hpi.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi.
        Intros; Exists Tsh ki HT T; rewrite HHi; entailer!.
        apply derives_refl.
      + apply allp_right; intro sh0.
        apply allp_right; intro v0.
        rewrite <- wand_sepcon_adjoint, emp_sepcon.
        Intros HT T.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
        if_tac.
        * subst v0 ki.
          rewrite <- !sepcon_assoc, 3sepcon_assoc, sepcon_comm.
          assert_PROP (lookup T k = Some (i1 mod size)) as Hindex.
          { rewrite <- !sepcon_assoc, 5sepcon_assoc.
            apply sepcon_derives_prop, (entries_lookup k); auto.
            rewrite HHi; auto. }
          eapply derives_trans.
          { rewrite !sepcon_assoc, sepcon_comm, !sepcon_assoc.
          apply sepcon_derives, derives_refl; apply snaps_dealloc. }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          rewrite emp_sepcon, sepcon_comm, sepcon_assoc.
          eapply derives_trans.
          { eapply sepcon_derives; [eapply andp_left2, allp_left|]; apply derives_refl. }
          rewrite sepcon_comm; apply modus_ponens_wand'.
          unfold hashtable; Exists T.
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi, HHi, if_true by auto; entailer!.
          destruct (HT k) eqn: Hk; auto.
          match goal with H : forall k v, _ <-> _ |- _ => rewrite H in Hk end.
          destruct Hk as (Hk & ?); apply In_Znth in Hk.
          destruct Hk as (j & ? & Hjth).
          match goal with H : wf_table T |- _ => exploit (H k j); rewrite ?Hjth; auto end.
          rewrite Hindex; congruence.
          { apply derives_refl. }
        * rewrite sepcon_comm, !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply (make_snap(ORD := zero_order))|].
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          rewrite !sepcon_assoc; eapply derives_trans, fupd_frame_r.
          subst v0; cancel.
          rewrite (sepcon_comm _ (_ && _)), !sepcon_assoc.
          eapply derives_trans, modus_ponens_wand'.
          { rewrite sepcon_comm; apply sepcon_derives, andp_left1; apply derives_refl. }
          unfold hashtable; Exists T.
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi, HHi; entailer!.
          apply derives_refl. }
    Intros k1.
    forward_if (k1 <> k).
    + subst; if_tac; [contradiction | Intros].
      forward; setoid_rewrite Hpi.
      { entailer!. }
      forward_call (pvi, |> P * (AS && cored) * ghost_snap k (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i0 : Z => ghost_snap (Znth ((i0 + hash k) mod size) keys) (Znth ((i0 + hash k) mod size) lg))
          (upto (Z.to_nat i))) * data_at sh (tarray tentry size) entries (gv _m_entries),
        Full_set iname, Empty_set iname,
        fun sh1 v => !!(sh1 = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
            forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
        !!(ki = k /\ vi = v /\ repable_signed vi) && ghost_master1 k (Znth (i1 mod size) lg) *
        data_at Tsh tint (vint k) pki * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
            (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
          ghost_snap k (Znth (i1 mod size) lg) * fold_right sepcon emp (map (fun i0 : Z =>
            ghost_snap (Znth ((i0 + hash k) mod size) keys) (Znth ((i0 + hash k) mod size) lg))
            (upto (Z.to_nat i))) * data_at sh (tarray tentry size) entries (gv _m_entries) *
        (ALL y : Z ,
              data_at sh (tarray tentry size) entries (gv _m_entries) *
              (!! (if eq_dec y 0 then H k = None else H k = Some y) &&
               hashtable H g lg entries) -*
              (|={ Empty_set iname, Full_set iname }=> Q y)),
        Q).
      { cancel.
        rewrite <- emp_sepcon at 1; apply sepcon_derives; [|cancel].
        rewrite <- emp_sepcon at 1; apply sepcon_derives.
        + rewrite <- wand_sepcon_adjoint, emp_sepcon.
          unfold AS.
          rewrite 2sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left1|]; apply derives_refl|].
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
          eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
          Intros HT.
          eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives, andp_left2|]; apply derives_refl|].
          unfold hashtable at 1; Intros T.
          rewrite extract_nth_sepcon with (i := i1 mod size)
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
          rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
          rewrite snap_master_join1, !sepcon_andp_prop'; Intros.
          rewrite <- (prop_true_andp _ (ghost_master1 _ _) H19).
          rewrite <- (@snap_master_join1 _ _ zero_order).
          destruct H19; [contradiction | subst].
          Exists Tsh vi HT T; rewrite HHi; entailer!.
          rewrite sepcon_comm; apply derives_refl.
        + apply allp_right; intro sh0.
          apply allp_right; intro v0.
          rewrite <- wand_sepcon_adjoint, emp_sepcon.
          Intros HT T.
          destruct (Znth (i1 mod size) T) eqn: HHi; Intros.
          subst; assert_PROP (lookup T k = Some (i1 mod size)) as Hindex.
          { rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right _ _ _)), <- !sepcon_assoc,
              (sepcon_comm _ (fold_right _ _ _)), <- !sepcon_assoc, 6sepcon_assoc.
            apply sepcon_derives_prop, entries_lookup; auto.
            rewrite HHi; auto. }
          rewrite <- !sepcon_assoc, 3sepcon_assoc, sepcon_comm.
          rewrite <- !sepcon_assoc, 6sepcon_assoc.
          eapply derives_trans.
          { apply sepcon_derives, derives_refl.
            eapply derives_trans, bupd_sepcon.
            apply sepcon_derives; [apply own_dealloc | apply snaps_dealloc]. }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          rewrite !emp_sepcon, sepcon_comm, sepcon_assoc.
          eapply derives_trans, modus_ponens_wand'.
          { rewrite sepcon_comm; apply sepcon_derives; [apply derives_refl|].
            eapply allp_left, derives_refl. }
          unfold hashtable; Exists T.
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi, HHi; entailer!.
          if_tac.
          * destruct (HT k) eqn: Hk; auto.
            match goal with H : forall k v, _ <-> _ |- _ => rewrite H in Hk end.
            destruct Hk as (Hk & ?); apply In_Znth in Hk.
            destruct Hk as (j & ? & Hjth).
            match goal with H : wf_table T |- _ => exploit (H k j); rewrite ?Hjth; auto end.
            rewrite Hindex; congruence.
          * match goal with H : forall k v, ?P <-> _ |- _ => rewrite H end.
            split; auto.
            exploit (Znth_In (i1 mod size) T); [omega|].
            rewrite HHi; auto.
          * apply derives_refl. }
      unfold POSTCONDITION, abbreviate; simpl map.
      Intros v'; forward.
      Exists v'; entailer!.
    + forward.
      entailer!.
    + Intros; forward_if (k1 <> 0).
      * subst; rewrite eq_dec_refl.
        viewshift_SEP 1 emp.
        { go_lower.
          apply andp_left2, cored_emp. }
        unfold POSTCONDITION, abbreviate; simpl map.
        forward.
        Exists 0; entailer!.
      * if_tac; [contradiction|].
        forward.
        entailer!.
      * intros.
        Exists i (i1 mod size) (upd_Znth (i1 mod size) keys k1).
        rewrite Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.
        change (upto (Z.to_nat 1)) with [0]; simpl fold_right.
        rewrite Z2Nat.id, Z.add_0_r by omega.
        Intros; rewrite if_false by auto.
        replace ((i + hash k) mod size) with (i1 mod size); rewrite upd_Znth_same by omega; entailer!.
        { split.
          { assert (Int.min_signed <= i1 mod size < Int.max_signed).
            { split; etransitivity; try apply Z_mod_lt; auto; try computable.
              setoid_rewrite (proj2_sig has_size); computable. }
            rewrite Int.signed_repr by omega; auto. }
          split; [rewrite Zmod_mod; auto|].
          split; [rewrite upd_Znth_Zlength; auto; omega|].
          replace (i1 mod size) with ((i + hash k) mod size); replace size with (Zlength keys);
            rewrite !rebase_upd' by (try omega; replace (Zlength keys) with size; apply Z_mod_lt; omega).
          rewrite sublist_upd_Znth_lr by (try omega; setoid_rewrite Hrebase; omega).
          rewrite sublist_split with (mid := i), sublist_len_1 by (try omega; setoid_rewrite Hrebase; omega).
          rewrite Z.sub_0_r, upd_Znth_app2, Forall_app; rewrite Zlength_sublist;
            rewrite ?Zlength_cons, ?Zlength_nil; try omega; try (setoid_rewrite Hrebase; omega).
          split; auto.
          rewrite Z.sub_0_r, Zminus_diag, upd_Znth0, Zlength_cons, sublist_1_cons, sublist_same
            by (auto; omega).
          repeat constructor; auto; tauto. }
        erewrite map_ext_in; [apply derives_refl|]; intros; simpl.
        rewrite upd_Znth_diff'; auto; try omega.
        replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.
        rewrite In_upto, Z2Nat.id in * by omega.
        rewrite !Zmod_small in X; omega.
  - Intros i i1 keys.
    forward.
    { entailer!.
      rewrite (Int.signed_repr 1) by computable; omega. }
    Exists (i + 1) (i1 + 1) keys; entailer!.
    split.
    { rewrite <- Zplus_mod_idemp_l.
      replace (i1 mod _) with ((i + hash k) mod size); simpl.
      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }
    admit. 
Admitted.

Lemma body_add_item : semax_body Vprog Gprog f_add_item add_item_spec.
Proof.
  start_atomic_function.
  destruct x as ((((((k, v), gv), sh), entries), g), lg); Intros.
  unfold atomic_shift; Intros P.
  set (AS := _ -* _).
  forward_call k.
  pose proof size_pos.
  forward_loop (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 i (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvars gv)
    SEP (|> P; AS && cored; @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))))%assert
    continue: (EX i : Z, EX i1 : Z, EX keys : list Z,
    PROP (Int.min_signed <= Int.signed (Int.repr i1) < Int.max_signed;
          i1 mod size = (i + hash k) mod size; 0 <= i < size; Zlength keys = size;
          Forall (fun z => z <> 0 /\ z <> k) (sublist 0 (i + 1) (rebase keys (hash k))))
    LOCAL (temp _idx (vint i1); temp _key (vint k); temp _value (vint v); gvars gv)
    SEP (|> P; AS && cored; @data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat (i + 1))))))%assert.
  { Exists 0 (k * 654435761)%Z (repeat 0 (Z.to_nat size)); rewrite sublist_nil; entailer!.
    split; [apply hash_size|].
    rewrite Zlength_repeat, Z2Nat.id; auto; omega.
    { simpl; auto. } }
  - Intros i i1 keys; forward.
    rewrite sub_repr, and_repr; simpl.
    rewrite Zland_two_p with (n := 14) by omega.
    replace (2 ^ 14) with size by (setoid_rewrite (proj2_sig has_size); auto).
    exploit (Z_mod_lt i1 size); [omega | intro Hi1].
    assert_PROP (Zlength entries = size) as Hentries by entailer!.
    assert (0 <= i1 mod size < Zlength entries) as Hi1' by omega.
    match goal with H : Forall _ _ |- _ => pose proof (Forall_Znth _ _ _ Hi1' H) as Hptr end.
    destruct (Znth (i1 mod size) entries) as (pki, pvi) eqn: Hpi; destruct Hptr.
    forward; setoid_rewrite Hpi.
    { entailer!. }
    assert (Zlength (rebase keys (hash k)) = size) as Hrebase.
    { rewrite Zlength_rebase; replace (Zlength keys) with size; auto; apply hash_range. }
    replace_SEP 1 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
    forward_call (pki, |> P * (AS && cored), Full_set iname, Empty_set iname,
      fun sh v => !!(sh = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
      forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
      !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) && ghost_master1 ki (Znth (i1 mod size) lg) *
      data_at Tsh tint (vint vi) pvi * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
          (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
      (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
      fun v : Z => |> P * ghost_snap v (Znth (i1 mod size) lg)).
    { cancel.
      rewrite <- emp_sepcon at 1; apply sepcon_derives; [|cancel].
      rewrite <- emp_sepcon at 1; apply sepcon_derives.
      + rewrite <- wand_sepcon_adjoint, emp_sepcon.
        unfold AS.
        eapply derives_trans; [apply sepcon_derives, andp_left1; apply derives_refl|].
        eapply derives_trans; [apply modus_ponens_wand|].
        apply fupd_mono.
        Intros HT.
        unfold hashtable at 1; Intros T.
        rewrite extract_nth_sepcon with (i := i1 mod size)
          by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
        unfold hashtable_entry.
        rewrite Hpi.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi.
        rewrite <- !sepcon_assoc.
        eapply derives_trans; [apply sepcon_derives, andp_left1; apply derives_refl|].
        Intros; Exists Tsh ki HT T; rewrite HHi; entailer!.
        apply derives_refl.
      + apply allp_right; intro sh0.
        apply allp_right; intro v0.
        rewrite <- wand_sepcon_adjoint, emp_sepcon.
        Intros HT T.
        destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
        rewrite !sepcon_assoc; eapply derives_trans.
        { apply sepcon_derives, derives_refl.
          apply (make_snap(ORD := zero_order)). }
        eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
        eapply derives_trans, fupd_frame_r.
        subst v0; cancel.
        apply modus_ponens_wand'.
        unfold hashtable; Exists T.
        rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ _)
          by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
        unfold hashtable_entry.
        rewrite Hpi, HHi; entailer!.
        apply derives_refl. }
    Intros k1.
    focus_SEP 1.
    match goal with |- semax _ (PROP () (LOCALx (_ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>
      forward_if (PROP () (LOCALx Q (SEPx (ghost_snap k (Znth (i1 mod size) lg) :: R)))) end.
    + assert (forall k1, (k1 <> k /\ k1 <> 0) ->
        Zlength (upd_Znth (i1 mod size) keys k1) = size /\
        Forall (fun z => z <> 0 /\ z <> k)
          (sublist 0 (i + 1) (rebase (upd_Znth (i1 mod size) keys k1) (hash k)))).
      { split; [rewrite upd_Znth_Zlength; auto; omega|].
        replace (i1 mod size) with ((i + hash k) mod size); replace size with (Zlength keys);
          rewrite !rebase_upd' by (try omega; replace (Zlength keys) with size; apply Z_mod_lt; omega).
        rewrite sublist_upd_Znth_lr by (try omega; setoid_rewrite Hrebase; omega).
        rewrite sublist_split with (mid := i), sublist_len_1 by (try omega; setoid_rewrite Hrebase; omega).
        rewrite Z.sub_0_r, upd_Znth_app2, Forall_app; rewrite Zlength_sublist;
          rewrite ?Zlength_cons, ?Zlength_nil; try omega; try (setoid_rewrite Hrebase; omega).
        split; auto.
        rewrite Z.sub_0_r, Zminus_diag, upd_Znth0, Zlength_cons, sublist_1_cons, sublist_same
          by (auto; omega).
        repeat constructor; auto; tauto. }
      forward_if (k1 = 0).
      { eapply semax_pre; [|apply semax_continue].
        unfold POSTCONDITION, abbreviate, overridePost, loop1_ret_assert, frame_ret_assert,
          function_body_ret_assert, RA_continue.
        Exists i (i1 mod size) (upd_Znth (i1 mod size) keys k1).
        rewrite Zmod_mod, Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.
        change (upto (Z.to_nat 1)) with [0]; simpl fold_right.
        rewrite Z2Nat.id, Z.add_0_r by omega.
        replace ((i + hash k) mod size) with (i1 mod size); rewrite upd_Znth_same by omega; entailer!.
        { assert (Int.min_signed <= i1 mod size < Int.max_signed).
          { split; etransitivity; try apply Z_mod_lt; auto; try computable.
            setoid_rewrite (proj2_sig has_size); computable. }
          rewrite Int.signed_repr by omega; auto. }
        erewrite map_ext_in; [apply derives_refl|]; intros; simpl.
        rewrite upd_Znth_diff'; auto; try omega.
        replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.
        rewrite In_upto, Z2Nat.id in * by omega.
        rewrite !Zmod_small in X; omega. }
      { forward.
        entailer!. }
      Intros; subst.
      replace_SEP 2 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
      forward_call (pki, 0, k, |> P * (AS && cored) * ghost_snap 0 (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
            (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))),
        Full_set iname, Empty_set iname, fun sh v => !!(sh = Tsh) && EX H : _, EX T : _,
          !!(Zlength T = size /\ wf_table T /\
          forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
          !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) &&
          ghost_master1 ki (Znth (i1 mod size) lg) * data_at Tsh tint (vint vi) pvi *
          excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
            (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
          ghost_snap 0 (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
           (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))) *
         (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
        fun v : Z => |> P * ghost_snap (if eq_dec v 0 then k else v) (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
            (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i)))).
      { cancel.
        rewrite sepcon_comm, <- emp_sepcon at 1.
        rewrite <- sepcon_assoc.
        apply sepcon_derives; [|cancel]; apply sepcon_derives, derives_refl.
        rewrite <- emp_sepcon at 1; apply sepcon_derives.
        * rewrite <- wand_sepcon_adjoint, emp_sepcon.
          rewrite sepcon_assoc; unfold AS.
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply sepcon_derives, andp_left1; apply derives_refl|].
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
          eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
          Intros HT.
          unfold hashtable at 1; Intros T.
          rewrite extract_nth_sepcon with (i := i1 mod size) by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          rewrite (sepcon_comm _ (_ && _)), !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives; [apply andp_left1|]; apply derives_refl|].
          Exists Tsh ki HT T; rewrite HHi; entailer!.
          apply derives_refl.
        * apply allp_right; intro sh0.
          apply allp_right; intro v0.
          rewrite <- wand_sepcon_adjoint, emp_sepcon.
          Intros HT T.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          assert (0 <= i1 mod size < Zlength T) by omega.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
          rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
          rewrite 5sepcon_assoc; eapply derives_trans; [apply sepcon_derives, derives_refl|].
          { apply snap_master_update1 with (v' := if eq_dec ki 0 then k else ki).
            if_tac; auto. }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          assert (0 <= hash k < Zlength T) by (replace (Zlength T) with size; apply hash_range).
          assert (0 <= i < Zlength (rebase T (hash k))) by (rewrite Zlength_rebase; auto; omega).
          assert (fst (Znth i (rebase T (hash k))) = ki).
          { rewrite Znth_rebase by (auto; omega).
            replace (Zlength T) with size; replace ((i + hash k) mod size) with (i1 mod size); rewrite HHi; auto. }
          assert_PROP ((ki = k \/ ki = 0) -> lookup T k = Some (i1 mod size)) as Hindex.
          { rewrite prop_forall; apply allp_right; intro Hki.
            rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right sepcon emp _)),
              <- !sepcon_assoc, (sepcon_comm _ (fold_right sepcon emp _)).
            rewrite <- !sepcon_assoc, 5sepcon_assoc.
            apply sepcon_derives_prop, entries_lookup; auto.
            rewrite HHi; auto. }
          rewrite !sepcon_assoc; eapply derives_trans, fupd_frame_r.
          subst v0; cancel.
          rewrite (sepcon_comm _ (ghost_snap _ _)), !sepcon_assoc; apply sepcon_derives; [apply derives_refl|].
          rewrite <- !sepcon_assoc; apply modus_ponens_wand'.
          unfold hashtable; Exists (upd_Znth (i1 mod size) T (if eq_dec ki 0 then k else ki, vi)).
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi, upd_Znth_same by omega; entailer!.
          { split; [rewrite upd_Znth_Zlength; auto|].
            split; [|if_tac; auto].
            if_tac; [subst | erewrite upd_Znth_triv; eauto].
            split; [apply wf_table_upd; auto|].
            intros.
            etransitivity; eauto; split; intros (Hin & ?); split; auto.
            - eapply In_upd_Znth_old; auto; try omega.
              rewrite HHi; intro X; inv X; tauto.
            - apply In_upd_Znth in Hin; destruct Hin as [X|]; [inv X; tauto | auto]. }
          apply sepcon_derives; [apply derives_refl|].
          apply sepcon_list_derives; rewrite !upd_Znth_Zlength;
            rewrite !Zlength_map, !Zlength_upto, !Z2Nat.id; auto; try omega.
          intros; destruct (eq_dec i0 (i1 mod size)).
          { subst; rewrite !upd_Znth_same by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; auto; omega); auto. }
          rewrite !upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; auto; omega).
          erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
          rewrite upd_Znth_diff'; auto. }
      Intros k1.
      focus_SEP 1.
      match goal with |- semax _ (PROP () (LOCALx (_ :: _ :: ?Q) (SEPx (_ :: ?R)))) _ _ =>
        forward_if (PROP () ((LOCALx Q) (SEPx (ghost_snap k (Znth (i1 mod size) lg) :: R)))) end.
      * if_tac; [discriminate|].
        replace_SEP 3 ((AS && cored) * (AS && cored)) by (go_lower; apply cored_dup).
        forward_call (pki, |> P * (AS && cored) * ghost_snap k1 (Znth (i1 mod size) lg), Full_set iname, Empty_set iname,
          fun sh v => !!(sh = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
            forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
            !!(v = ki /\ repable_signed vi /\ (ki = 0 -> vi = 0)) &&
            ghost_master1 ki (Znth (i1 mod size) lg) * data_at Tsh tint (vint vi) pvi *
            excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
              (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
            ghost_snap k1 (Znth (i1 mod size) lg) *
            (hashtable H g lg entries -* |={Empty_set iname,Full_set iname}=> |> P),
          fun v : Z => |> P * (!!(v = k1) && ghost_snap k1 (Znth (i1 mod size) lg))).
        { cancel.
          rewrite <- emp_sepcon at 1; apply sepcon_derives; [|cancel].
          rewrite <- emp_sepcon at 1; apply sepcon_derives.
          * rewrite <- wand_sepcon_adjoint, emp_sepcon.
            unfold AS.
            eapply derives_trans; [apply sepcon_derives, derives_refl; apply sepcon_derives, andp_left1; apply derives_refl|].
            eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
            eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
            Intros HT.
            unfold hashtable at 1; Intros T.
            rewrite extract_nth_sepcon with (i := i1 mod size)
              by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
            erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
            unfold hashtable_entry.
            rewrite Hpi.
            destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
            rewrite (sepcon_comm _ (_ && _)), !sepcon_assoc.
            eapply derives_trans; [apply sepcon_derives; [apply andp_left1|]; apply derives_refl|].
            Exists Tsh ki HT T; rewrite HHi; entailer!.
            apply derives_refl.
          * apply allp_right; intro sh0.
            apply allp_right; intro v0.
            rewrite <- wand_sepcon_adjoint, emp_sepcon.
            Intros HT T.
            destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
            rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
            rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
            rewrite snap_master_join1, !sepcon_andp_prop'; Intros.
            rewrite <- (prop_true_andp _ (ghost_master1 _ _) H28).
            rewrite <- (@snap_master_join1 _ _ zero_order).
            destruct H28; [contradiction | subst].
            rewrite prop_true_andp by auto.
            eapply derives_trans, fupd_frame_r; cancel.
            apply modus_ponens_wand'.
            unfold hashtable; Exists T.
            rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ _)
              by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
            erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
            unfold hashtable_entry.
            rewrite Hpi, HHi; entailer!.
            apply derives_refl. }
        Intros k2; subst.
        forward_if (k1 = k).
        { eapply semax_pre; [|apply semax_continue].
          unfold POSTCONDITION, abbreviate, overridePost, loop1_ret_assert, frame_ret_assert,
            function_body_ret_assert, RA_continue.
          Exists i (i1 mod size) (upd_Znth (i1 mod size) keys k1).
          rewrite Zmod_mod, Z2Nat.inj_add, upto_app, map_app, sepcon_app by omega.
          change (upto (Z.to_nat 1)) with [0]; simpl fold_right.
          rewrite Z2Nat.id, Z.add_0_r by omega.
          replace ((i + hash k) mod size) with (i1 mod size); rewrite upd_Znth_same by omega; entailer!.
          { assert (Int.min_signed <= i1 mod size < Int.max_signed).
          { split; etransitivity; try apply Z_mod_lt; auto; try computable.
            setoid_rewrite (proj2_sig has_size); computable. }
          rewrite Int.signed_repr by omega; auto. }
          erewrite map_ext_in; [apply derives_refl|]; intros; simpl.
          rewrite upd_Znth_diff'; auto; try omega.
          replace (i1 mod size) with ((i + hash k) mod size); intro X; apply Zmod_plus_inv in X; auto.
          rewrite In_upto, Z2Nat.id in * by omega.
          rewrite !Zmod_small in X; omega. }
        { forward.
          entailer!. }
        entailer!.
      * forward.
        if_tac; [|contradiction].
        subst; entailer!.
      * entailer!.
    + forward.
      subst; entailer!.
    + forward; setoid_rewrite Hpi.
      { entailer!. }
      forward_call (pvi, 0, v, |> P * (AS && cored) * ghost_snap k (Znth (i1 mod size) lg) *
          fold_right sepcon emp (map (fun i => ghost_snap (Znth ((i + hash k) mod size) keys)
            (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))) *
          data_at sh (tarray tentry size) entries (gv _m_entries),
        Full_set iname, Empty_set iname, fun sh1 (v1 : Z) => !!(sh1 = Tsh) && EX H : _, EX T : _, !!(Zlength T = size /\ wf_table T /\
          forall k v, H k = Some v <-> In (k, v) T /\ v <> 0) && let '(ki, vi) := Znth (i1 mod size) T in
          !!(ki = k /\ vi = v1 /\ repable_signed vi) && ghost_master1 k (Znth (i1 mod size) lg) *
          data_at Tsh tint (vint k) pki * excl g H * fold_right sepcon emp (upd_Znth (i1 mod size)
            (map (hashtable_entry T lg entries) (upto (Z.to_nat size))) emp) *
          ghost_snap k (Znth (i1 mod size) lg) * fold_right sepcon emp (map (fun i =>
            ghost_snap (Znth ((i + hash k) mod size) keys) (Znth ((i + hash k) mod size) lg)) (upto (Z.to_nat i))) *
          data_at sh (tarray tentry size) entries (gv _m_entries) *
          (ALL y : bool, (data_at sh (tarray tentry size) entries (gv _m_entries) *
              (!! (H k = None <-> y = true) &&
               hashtable (if y then map_upd H k v else H) g lg entries)) -* |={Empty_set iname,Full_set iname}=> Q y),
        fun v => Q (if eq_dec v 0 then true else false)).
      { cancel.
        rewrite <- emp_sepcon, <- sepcon_emp at 1.
        apply sepcon_derives; [|cancel].
        apply sepcon_derives, derives_refl.
        rewrite <- emp_sepcon at 1; apply sepcon_derives.
        + rewrite <- wand_sepcon_adjoint, emp_sepcon.
          rewrite 2sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply sepcon_derives, andp_left1; apply derives_refl|].
          eapply derives_trans; [apply sepcon_derives, derives_refl; apply modus_ponens_wand|].
          eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
          Intros HT.
          unfold hashtable at 1; Intros T.
          rewrite extract_nth_sepcon with (i := i1 mod size)
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          rewrite Hpi.
          destruct (Znth (i1 mod size) T) as (ki, vi) eqn: HHi; Intros.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_master1 _ _)).
          rewrite (sepcon_comm _ (ghost_snap _ _)), <- !sepcon_assoc.
          rewrite snap_master_join1, !sepcon_andp_prop'; Intros.
          rewrite <- (prop_true_andp _ (ghost_master1 _ _) H20).
          rewrite <- (@snap_master_join1 _ _ zero_order).
          destruct H20; [contradiction | subst].
          rewrite (sepcon_comm _ (_ && _)), !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives; [apply andp_left2|]; apply derives_refl|].
          Exists Tsh vi HT T; rewrite HHi; entailer!.
          rewrite sepcon_comm; apply derives_refl.
        + apply allp_right; intro sh0.
          apply allp_right; intro v0.
          rewrite <- wand_sepcon_adjoint, emp_sepcon.
          Intros HT T.
          destruct (Znth (i1 mod size) T) eqn: HHi; Intros.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (excl g HT)), !sepcon_assoc.
          eapply derives_trans; [apply sepcon_derives, derives_refl|].
          { apply exclusive_update with (v' := if eq_dec v0 0 then map_upd HT k v else HT). }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          assert_PROP (lookup T k = Some (i1 mod size)) as Hindex.
          { rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right _ _ _)), <- !sepcon_assoc,
              (sepcon_comm _ (fold_right _ _ _)), <- !sepcon_assoc, 6sepcon_assoc.
            apply sepcon_derives_prop, entries_lookup; auto.
            rewrite HHi; auto. }
          rewrite <- 4sepcon_assoc, sepcon_comm, <- !sepcon_assoc, 6sepcon_assoc.
          eapply derives_trans.
          { apply sepcon_derives, derives_refl.
            eapply derives_trans, bupd_sepcon.
            apply sepcon_derives; [apply own_dealloc | apply snaps_dealloc]. }
          eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
          rewrite !emp_sepcon, sepcon_comm, sepcon_assoc, sepcon_comm.
          eapply derives_trans; [eapply sepcon_derives, allp_left; apply derives_refl|].
          rewrite <- sepcon_assoc; apply modus_ponens_wand'.
          unfold hashtable.
          Exists (if eq_dec v0 0 then upd_Znth (i1 mod size) T (k, v) else T).
          rewrite extract_nth_sepcon with (i := i1 mod size)(l := map _ (upto (Z.to_nat size)))
            by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; omega).
          erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; omega).
          unfold hashtable_entry.
          if_tac; subst.
          * rewrite upd_Znth_same by omega.
            assert (0 <= hash k < Zlength T) by (replace (Zlength T) with size; apply hash_range).
            rewrite Hpi; entailer!.
            { assert (forall v', In (k, v') T -> v' = 0) as Hv'.
              { intros ? Hin.
                eapply In_Znth in Hin; destruct Hin as (j & ? & Hjth).
                match goal with H : wf_table T |- _ => exploit (H k j); rewrite ?Hjth; auto end.
                rewrite Hindex; intro X; inv X.
                rewrite HHi in Hjth; inv Hjth; auto. }
              split.
              { split; auto.
                destruct (HT k) eqn: Hk; auto.
                match goal with H : forall k v, _ <-> _ |- _ => rewrite H in Hk end.
                destruct Hk as (Hin & ?); specialize (Hv' _ Hin); contradiction. }
              split; [rewrite upd_Znth_Zlength; omega|].
              split; [apply wf_table_upd_same; rewrite ?HHi; auto|].
              intros; unfold map_upd; if_tac.
              * split; [intro X; inv X; split; auto; apply upd_Znth_In|].
                subst; intros (Hin & ?).
                apply In_upd_Znth in Hin; destruct Hin as [Hin | Hin]; [inv Hin; auto|].
                specialize (Hv' _ Hin); contradiction.
              * etransitivity; eauto; split; intros (Hin & ?); split; auto.
                -- eapply In_upd_Znth_old; auto; try omega.
                   rewrite HHi; intro X; inv X; contradiction.
                -- apply In_upd_Znth in Hin; destruct Hin as [X|]; [inv X; tauto | auto]. }
            apply sepcon_derives; [apply derives_refl|].
            apply sepcon_list_derives; rewrite !upd_Znth_Zlength;
              rewrite !Zlength_map, !Zlength_upto, !Z2Nat.id; auto; try omega.
            intros; destruct (eq_dec i0 (i1 mod size)).
            { subst; rewrite !upd_Znth_same by (rewrite Zlength_map, Zlength_upto, Z2Nat.id; auto; omega); auto. }
            rewrite !upd_Znth_diff' by (rewrite ?Zlength_map, ?Zlength_upto, ?Z2Nat.id; auto; omega).
            erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
            rewrite upd_Znth_diff'; auto; omega.
          * rewrite Hpi, HHi; entailer!.
            split; [|discriminate].
            assert (HT k = Some v0) as X; [|rewrite X; discriminate].
            match goal with H : forall k v, _ <-> _ |- _ => rewrite H end.
            split; auto; rewrite <- HHi; apply Znth_In; omega.
            apply derives_refl. }
      unfold POSTCONDITION, abbreviate; simpl map.
      Intros v'; forward.
      Exists (if eq_dec v' 0 then true else false); entailer!.
      if_tac; auto.
  - Intros i i1 keys.
    forward.
    { entailer!.
      rewrite (Int.signed_repr 1) by computable; omega. }
    Exists (i + 1) (i1 + 1) keys; entailer!.
    split.
    { rewrite <- Zplus_mod_idemp_l.
      replace (i1 mod _) with ((i + hash k) mod size); simpl.
      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }
    admit. 
Admitted.

Opaque Znth.

Lemma body_init_table : semax_body Vprog Gprog f_init_table init_table_spec.
Proof.
  start_function.
  forward_for_simple_bound size (EX i : Z, EX entries : list (val * val),
    PROP (Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries; Zlength entries = i)
    LOCAL (gvars gv)
    SEP (@data_at CompSpecs Ews (tarray tentry size) (entries ++ repeat (Vundef, Vundef) (Z.to_nat (size - i))) (gv _m_entries);
         fold_right sepcon emp (map (fun x =>
           malloc_token Tsh tint (fst x) * malloc_token Tsh tint (snd x)) entries);
         EX lg : list gname, !!(Zlength lg = i) && fold_right sepcon emp (map (fun j =>
           hashtable_entry (repeat (0, 0) (Z.to_nat size)) lg entries j) (upto (Z.to_nat i))))).
  { setoid_rewrite (proj2_sig has_size); reflexivity. }
  { pose proof size_pos; omega. }
  { setoid_rewrite (proj2_sig has_size); computable. }
  - Exists (@nil (val * val)) (@nil gname); entailer!.
    rewrite data_at__eq; unfold default_val; simpl.
    rewrite repeat_list_repeat, Z.sub_0_r; apply derives_refl.
  - Intros lg.
    ghost_alloc (ghost_master1 0).
    Intros gk.
    forward_call tint.
    { split; auto; simpl; computable. }
    Intros pk.
    rewrite sepcon_map; Intros.
    repeat forward.
    forward_call tint.
    { split; auto; simpl; computable. }
    Intros pv.
    repeat forward.
    assert (0 <= i < Zlength (entries ++ repeat (Vundef, Vundef) (Z.to_nat (size - i)))).
    { rewrite Zlength_app, Zlength_repeat, Z2Nat.id; omega. }
    rewrite upd_Znth_twice, upd_Znth_same by auto.
    go_lower; Exists (entries ++ [(pk, pv)]) (lg ++ [gk]).
    rewrite !Z2Nat.inj_add, !upto_app, !map_app, !sepcon_app, !Z2Nat.id by omega.
    change (upto (Z.to_nat 1)) with [0]; unfold hashtable_entry at 3; simpl.
    rewrite Z.add_0_r, !app_Znth2 by omega.
    replace (Zlength entries) with i; replace (Zlength lg) with i; rewrite Zminus_diag, !Znth_0_cons.
    rewrite Znth_repeat', !Zlength_app, !Zlength_cons, !Zlength_nil by (rewrite Z2Nat.id; omega).
    entailer!.
    { rewrite Forall_app; repeat constructor; auto. }
    rewrite upd_init, <- app_assoc by (auto; omega); cancel.
    rewrite <- sepcon_map; cancel.
    apply sepcon_list_derives; rewrite !Zlength_map, !Zlength_upto; auto.
    rewrite <- Zlength_correct; intros.
    erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, <- Zlength_correct; auto; omega).
    unfold hashtable_entry; rewrite !app_Znth1 by omega; apply derives_refl.
  - Intros entries lg.
    rewrite Zminus_diag, app_nil_r.
    ghost_alloc (fun g => excl g (@empty_map Z Z)).
    Intro g.
    forward.
    unfold hashtable; Exists entries g lg (repeat (0, 0) (Z.to_nat size)); entailer!.
    split; [rewrite Zlength_repeat, Z2Nat.id; auto; pose proof size_pos; omega|].
    split.
    + intros ??? Hj.
      setoid_rewrite Znth_repeat in Hj; simpl in Hj; subst; contradiction.
    + split; [discriminate|].
      intros (Hin & ?); apply repeat_spec in Hin; inv Hin; contradiction.
    + apply sepcon_derives; erewrite map_ext; try apply derives_refl; auto.
      intros (?, ?); auto.
Qed.

Lemma lock_struct_array : forall sh z (v : list val) p,
  data_at sh (tarray (tptr (Tstruct _lock_t noattr)) z) v p =
  data_at sh (tarray (tptr tlock) z) v p.
Proof.
  intros.
  unfold data_at, field_at, at_offset; rewrite !data_at_rec_eq; simpl; f_equal.
  f_equal.
  apply prop_ext; split; intros (? & ? & ? & Halign & ?); repeat split; auto.
  - destruct p; try contradiction; simpl in *.
    inv Halign; try discriminate.
    constructor; auto.
    intros ? Hi; specialize (H7 _ Hi).
    inv H7; econstructor; eauto.
  - destruct p; try contradiction; simpl in *.
    inv Halign; try discriminate.
    constructor; auto.
    intros ? Hi; specialize (H7 _ Hi).
    inv H7; econstructor; eauto.
Qed.

Lemma f_pred_exclusive : forall tsh sh gsh (entries : list (val * val)) gh p t locksp lockt resultsp res,
  readable_share sh ->
  exclusive_mpred (f_lock_pred tsh sh gsh entries gh p t locksp lockt resultsp res).
Proof.
  intros; unfold f_lock_pred.
  apply selflock_exclusive.
  unfold f_lock_inv.
  eapply derives_exclusive, exclusive_sepcon1 with
    (P := @data_at CompSpecs sh (tarray tentry size) entries p)(Q := EX b1 : bool, EX b2 : bool,
    EX b3 : bool, EX h : nat -> option hashtable_hist_el, _), data_at_exclusive; auto.
  - Intros b1 b2 b3 h; Exists b1 b2 b3 h.
    rewrite (sepcon_comm (ghost_hist _ _ _)), !sepcon_assoc.
    apply sepcon_derives; auto.
  - simpl.
    pose proof size_pos.
    rewrite Z.max_r; omega.
Qed.
Hint Resolve f_pred_exclusive.

Lemma apply_hist_app : forall h1 h2 H, apply_hist H (h1 ++ h2) =
  match apply_hist H h1 with Some H' => apply_hist H' h2 | None => None end.
Proof.
  induction h1; auto; simpl; intros.
  destruct a; rewrite IHh1; auto.
  - destruct (H k); if_tac; auto.
  - destruct (H k); simple_if_tac; auto.
Qed.

Lemma hashtable_entry_timeless : forall T lg entries i, timeless (hashtable_entry T lg entries i).
Proof.
  intros; unfold hashtable_entry.
  destruct (Znth i entries), (Znth i T).
  apply timeless_sepcon, data_at_timeless.
  apply timeless_sepcon, data_at_timeless.
  apply timeless_andp; [apply timeless_prop | apply own_timeless].
Qed.

Lemma hashtable_timeless : forall H g lg entries, timeless (hashtable H g lg entries).
Proof.
  intros; unfold hashtable.
  apply (timeless_exp nil); intro.
  apply timeless_sepcon; [apply timeless_andp; [apply timeless_prop | apply own_timeless]|].
  forget (upto (Z.to_nat size)) as l; clear; induction l; simpl.
  * apply timeless_emp.
  * apply timeless_sepcon; auto.
    apply hashtable_entry_timeless.
Qed.

Lemma hashtable_inv_timeless : forall gh g lg entries, timeless (hashtable_inv gh g lg entries).
Proof.
  intros; unfold hashtable_inv.
  apply (timeless_exp empty_map); intro.
  apply timeless_sepcon; [apply hashtable_timeless|].
  apply (timeless_exp nil); intro.
  apply timeless_andp; [apply timeless_prop|].
  unfold ghost_ref.
  apply (timeless_exp empty_map); intro.
  apply timeless_andp; [apply timeless_prop | apply own_timeless].
Qed.

Lemma body_f : semax_body Vprog Gprog f_f f_spec.
Proof.
  start_function.
  rewrite (data_at_isptr Tsh); Intros.
  forward.
  rewrite <- lock_struct_array.
  forward.
  { entailer!.
    rewrite upd_Znth_same; auto. }
  forward.
  { entailer!.
    rewrite upd_Znth_same; auto. }
  rewrite !upd_Znth_same by auto.
  forward.
  forward_call (tint, tid).
  forward_for_simple_bound 3 (EX j : Z, EX ls : list bool, EX h : _,
    PROP (Zlength ls = j; add_events empty_map (map (fun j => HAdd (j + 1) 1 (Znth j ls)) (upto (Z.to_nat j))) h)
    LOCAL (temp _total (vint (Zlength (filter id ls))); temp _res res; temp _l lockt; temp _t (vint t);
           temp _arg tid; gvars gv)
    SEP (@data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         invariant i (hashtable_inv gh g lg entries);
         ghost_hist gsh h gh;
         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) (upd_Znth t (repeat Vundef 3) lockt) (gv _thread_locks);
         data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) (gv _results);
         data_at_ Tsh tint res;
         lock_inv tsh lockt (f_lock_pred tsh sh gsh entries gh (gv _m_entries) t
                                         (gv _thread_locks) lockt (gv _results) res))).
  - Exists (@nil bool) (@empty_map nat hashtable_hist_el); entailer!.
  - forward_call (i0 + 1, 1, gv, sh, entries, g, lg,
      fun b => EX h' : _, !!(add_events h [HAdd (i0 + 1) 1 b] h') && ghost_hist gsh h' gh *
        data_at sh (tarray tentry size) entries (gv _m_entries), inv_names).
    { simpl; entailer!.
      { match goal with H : Forall (fun '(pk, pv) => isptr pk /\ isptr pv) entries |- _ =>
          eapply Forall_impl, H end; intros (?, ?); auto. }
      unfold atomic_shift.
      Exists (ghost_hist gsh h gh).
      rewrite invariant_dup.
      rewrite !sepcon_assoc; eapply derives_trans, sepcon_derives, derives_refl; [|apply now_later].
      cancel.
      rewrite !sepcon_assoc; apply sepcon_derives; [|cancel].
      apply andp_right, invariant_cored.
      eapply derives_trans; [apply fupd_intro|].
      rewrite <- wand_sepcon_adjoint.
      eapply derives_trans.
      { apply sepcon_derives; [apply derives_refl|].
        apply except0_timeless; [apply except0_intro|].
        apply own_timeless. }
      eapply derives_trans; [apply except0_frame_l | apply fupd_except0_elim].
      eapply derives_trans; [apply fupd_frame_r|].
      eapply derives_trans, fupd_trans; apply fupd_mono.
      eapply derives_trans; [apply sepcon_derives, derives_refl; apply inv_open with (E := Full_set _); constructor|].
      eapply derives_trans; [apply fupd_frame_r|].
      eapply derives_trans, fupd_trans; apply fupd_mono.
      rewrite !sepcon_assoc; eapply derives_trans.
      { apply sepcon_derives, derives_refl.
        apply except0_timeless; [apply except0_intro|].
        apply hashtable_inv_timeless. }
      eapply derives_trans; [apply except0_frame_r | apply fupd_except0_elim].
      unfold hashtable_inv; Intros HT hr.
      rewrite <- emp_sepcon at 1.
      eapply derives_trans; [apply sepcon_derives, derives_refl; apply fupd_intro_mask with (E2 := Empty_set _)|].
      { intro; right; intro X; inv X. }
      { intros ? X; inv X. }
      eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
      Exists HT; cancel.
      apply andp_right.
      + rewrite <- wand_sepcon_adjoint.
        rewrite !sepcon_assoc; eapply derives_trans; [apply fupd_frame_r|].
        eapply derives_trans, fupd_trans; apply fupd_mono.
        rewrite emp_sepcon, <- !sepcon_assoc, sepcon_comm.
        rewrite <- !sepcon_assoc.
        eapply derives_trans.
        { apply sepcon_derives, derives_refl.
          apply modus_ponens_wand'.
          eapply derives_trans, now_later.
          Exists HT hr; entailer!. }
        eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
        eapply derives_trans, now_later; cancel.
      + apply allp_right; intro b.
        rewrite <- wand_sepcon_adjoint; Intros.
        rewrite !sepcon_assoc; eapply derives_trans; [apply fupd_frame_r|].
        eapply derives_trans, fupd_trans; apply fupd_mono.
        rewrite emp_sepcon, <- !sepcon_assoc, (sepcon_comm _ (ghost_hist _ _ _)).
        rewrite !sepcon_assoc, <- sepcon_assoc.
        assert_PROP (hist_incl h hr).
        { apply sepcon_derives_prop, hist_ref_incl; auto. }
        eapply derives_trans.
        { apply sepcon_derives, derives_refl.
          apply hist_add' with (e := HAdd (i0 + 1) 1 b); auto. }
        eapply derives_trans; [apply bupd_frame_r | apply fupd_bupd_elim].
        rewrite !sepcon_assoc, sepcon_comm.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (hashtable _ _ _ _)).
        rewrite <- !sepcon_assoc, sepcon_assoc.
        eapply derives_trans.
        { apply sepcon_derives, derives_refl.
          apply modus_ponens_wand'.
          eapply derives_trans, now_later.
          Exists (if b then map_upd HT (i0 + 1) 1 else HT) (hr ++ [HAdd (i0 + 1) 1 b]); entailer!.
          rewrite apply_hist_app, H15; simpl.
          destruct (HT (i0 + 1)), b; try congruence.
          * destruct H16 as [_ X]; specialize (X eq_refl); discriminate.
          * destruct H16 as [X _]; specialize (X eq_refl); discriminate. }
        eapply derives_trans; [apply fupd_frame_r | apply fupd_mono].
        Exists (map_upd h (length hr) (HAdd (i0 + 1) 1 b)); entailer!.
        apply (add_events_snoc _ nil); [constructor|].
        apply hist_incl_lt; auto. }
    Intros b h'.
    forward_if (temp _total (vint (Zlength (filter id (ls ++ [b]))))).
    + pose proof (Zlength_filter id ls).
      forward.
      entailer!.
      rewrite filter_app; simpl.
      rewrite Zlength_app, Zlength_cons, Zlength_nil; auto.
    + forward.
      entailer!.
      rewrite filter_app; simpl.
      rewrite Zlength_app, Zlength_nil, Z.add_0_r; auto.
    + Exists (ls ++ [b]) h'; rewrite filter_app, ?Zlength_app, ?Zlength_cons, ?Zlength_nil; entailer!.
      rewrite Z2Nat.inj_add, upto_app, map_app, Z2Nat.id by omega; change (upto (Z.to_nat 1)) with [0]; simpl.
      rewrite Z.add_0_r, app_Znth2, Zminus_diag, Znth_0_cons by omega.
      eapply add_events_trans; eauto.
      erewrite map_ext_in; eauto.
      intros j Hj; rewrite app_Znth1; auto.
      rewrite In_upto, Z2Nat.id in Hj; omega.
  - Intros ls h.
    viewshift_SEP 1 emp.
    { go_lower; apply invariant_dealloc. }
    forward.
    forward_call (lockt, tsh, f_lock_inv sh gsh entries gh (gv _m_entries) t
      (gv _thread_locks) lockt (gv _results) res,
                  f_lock_pred tsh sh gsh entries gh (gv _m_entries) t
      (gv _thread_locks) lockt (gv _results) res).
    { assert_PROP (Zlength entries = Zlength lg) by (pose proof size_pos; entailer!).
      lock_props.
      unfold f_lock_pred at 2.
      rewrite selflock_eq.
      unfold f_lock_inv at 1.
      rewrite lock_struct_array.
      Exists (Znth 0 ls) (Znth 1 ls) (Znth 2 ls) h; entailer!.
      rewrite (list_Znth_eq ls) at 1.
      replace (length ls) with (Z.to_nat 3) by (symmetry; rewrite <- Zlength_length by computable; auto).
      cancel.
      subst Frame; instantiate (1 := []); simpl; rewrite sepcon_emp; apply now_later. }
    forward.
Qed.

Lemma lock_struct : forall p, data_at_ Tsh (Tstruct _lock_t noattr) p = data_at_ Tsh tlock p.
Proof.
  intros.
  rewrite !data_at__eq.
  unfold_data_at 1%nat.
  rewrite field_at_data_at; simpl.
  apply pred_ext.
  - assert_PROP (field_compatible (Tstruct _lock_t noattr) [StructField _a] p) by entailer!.
    rewrite field_compatible_field_address by auto; simpl.
    entailer!.
  - assert_PROP (field_compatible (Tstruct _lock_t noattr) [StructField _a] p).
    { entailer!.
      rewrite field_compatible_cons; simpl; split; hnf; auto.
      destruct H as (? & ? & ? & Halign & ?); repeat split; auto.
      destruct p; try contradiction; simpl in *.
      eapply align_compatible_rec_Tstruct; simpl; eauto; simpl.
      intros ???.
      if_tac; inversion 1; subst; simpl.
      inversion 1; subst; simpl.
      rewrite Z.add_0_r; auto. }
    rewrite field_compatible_field_address by auto; simpl.
    entailer!.
Qed.

Lemma add_fails : forall k v b l H H' (HH : apply_hist H l = Some H') (Hadd : In (HAdd k v b) l)
  (Hk : H k <> None), b = false.
Proof.
  induction l; simpl; intros; [contradiction|].
  destruct a; try (destruct Hadd as [X|]; [inv X|]).
  - eapply IHl; eauto.
    unfold map_upd; if_tac; auto; discriminate.
  - destruct (H k0); destruct (eq_dec _ _); try discriminate; eapply IHl; eauto.
  - destruct b; auto.
    destruct (H k); [discriminate | contradiction].
  - destruct (H k0), r; try discriminate; eapply IHl; eauto.
    unfold map_upd; if_tac; auto; discriminate.
Qed.

Instance Inhabitant_hist_el : Inhabitant hashtable_hist_el := HGet 0 0.

Lemma only_one_add_succeeds : forall k v1 v2 l i1 i2 H0 H (HH : apply_hist H0 l = Some H)
  (Hin1 : Znth i1 l = HAdd k v1 true) (Hin2 : Znth i2 l = HAdd k v2 true),
  i2 = i1 /\ v2 = v1.
Proof.
  induction l; simpl; intros.
  { rewrite Znth_nil in Hin1; discriminate. }
  assert (i2 = i1); [|subst; rewrite Hin2 in Hin1; inv Hin1; auto].
  exploit (Znth_inbounds i1 (a :: l)); [rewrite Hin1; discriminate|].
  exploit (Znth_inbounds i2 (a :: l)); [rewrite Hin2; discriminate|].
  rewrite !Zlength_cons; intros.
  destruct (eq_dec i1 0), (eq_dec i2 0); subst; auto.
  - rewrite Znth_0_cons in Hin1; subst.
    rewrite Znth_pos_cons in Hin2 by omega.
    destruct (H0 k); [discriminate|].
    eapply add_fails in HH; [|rewrite <- Hin2; apply Znth_In; omega|]; [discriminate|].
    unfold map_upd; rewrite eq_dec_refl; discriminate.
  - rewrite Znth_0_cons in Hin2; subst.
    rewrite Znth_pos_cons in Hin1 by omega.
    destruct (H0 k); [discriminate|].
    eapply add_fails in HH; [|rewrite <- Hin1; apply Znth_In; omega|]; [discriminate|].
    unfold map_upd; rewrite eq_dec_refl; discriminate.
  - rewrite Znth_pos_cons in Hin1, Hin2 by omega.
    assert (i2 - 1 = i1 - 1); [|omega].
    destruct a.
    + eapply IHl; eauto.
    + destruct (H0 k0); destruct (eq_dec _ _); try discriminate; eapply IHl; eauto.
    + destruct (H0 k0), r; try discriminate; eapply IHl; eauto.
Qed.

Lemma one_add_succeeds : forall k v b l H0 H (HH : apply_hist H0 l = Some H) (Hk : H0 k = None)
  (Hin : In (HAdd k v b) l) (Hout : forall v, ~In (HSet k v) l), exists v', In (HAdd k v' true) l.
Proof.
  induction l; simpl; intros; [contradiction|].
  assert (forall v, ~In (HSet k v) l).
  { intros v0 ?; contradiction (Hout v0); auto. }
  destruct a; try (destruct Hin as [X|]; [discriminate|]).
  - destruct (eq_dec k0 k); [contradiction (Hout v0); subst; auto|].
    exploit IHl; eauto.
    { unfold map_upd; if_tac; auto; subst; contradiction. }
    intros (? & ?); eauto.
  - destruct (H0 k0), (eq_dec _ _); try discriminate; exploit IHl; eauto; intros (? & ?); eauto.
  - destruct (eq_dec k0 k).
    + subst; rewrite Hk in HH.
      destruct r; [eauto | discriminate].
    + destruct Hin as [X|]; [inv X; contradiction|].
      destruct (H0 k0), r; try discriminate; exploit IHl; eauto; try (intros (? & ?); eauto).
      unfold map_upd; if_tac; auto; subst; contradiction.
Qed.

Lemma filter_find_count : forall {A} {d : Inhabitant A} (f : A -> bool) l li (Hunique : NoDup li)
  (Hli : forall i, In i li -> f (Znth i l) = true) (Hrest : forall i, ~In i li -> f (Znth i l) = false),
  Zlength (filter f l) = Zlength li.
Proof.
  induction l; simpl; intros.
  - exploit (list_pigeonhole li (Zlength li + 1)); [omega|].
    intros (i' & ? & ?).
    destruct li; auto.
    exploit (Hli z); simpl; auto.
    exploit Hrest; eauto.
    rewrite !Znth_nil; intros ->; discriminate.
  - assert (f d = false) as Hd.
    { exploit (list_pigeonhole (upto (Z.to_nat (Zlength (a :: l))) ++ li)
       (Zlength (upto (Z.to_nat (Zlength (a :: l))) ++ li) + 1)); [omega|].
      intros (j' & ? & Hout); exploit (Hrest j').
      { intro X; contradiction Hout; rewrite in_app; auto. }
      rewrite Znth_overflow; auto.
      { destruct (zlt j' (Zlength (a :: l))); auto.
        contradiction Hout; rewrite in_app; left.
        rewrite In_upto, Z2Nat.id; omega. } }
    destruct (in_dec Z.eq_dec 0 li).
    + exploit Hli; eauto.
      rewrite Znth_0_cons; intros ->.
      rewrite Zlength_cons.
      exploit in_split; eauto; intros (li1 & li2 & ?); subst.
      apply NoDup_remove in Hunique; destruct Hunique.
      rewrite Zlength_app, Zlength_cons.
      erewrite (IHl (map (fun i => i - 1) (li1 ++ li2))), Zlength_map, Zlength_app; auto; try omega.
      * apply FinFun.Injective_map_NoDup; auto.
        intros ??; omega.
      * intros ? Hj; rewrite in_map_iff in Hj; destruct Hj as (j & ? & Hj); subst.
        exploit (Hli j).
        { rewrite in_insert_iff; auto. }
        destruct (eq_dec j 0); [subst; contradiction|].
        destruct (zlt j 0).
        { rewrite Znth_underflow, Hd by auto; discriminate. }
        rewrite Znth_pos_cons by omega; auto.
      * intros j Hj.
        destruct (zlt j 0); [rewrite Znth_underflow; auto|].
        specialize (Hrest (j + 1)); specialize (Hli (j + 1));
          rewrite Znth_pos_cons, Z.add_simpl_r in Hrest, Hli by omega.
        destruct (in_dec Z.eq_dec (j + 1) (li1 ++ 0 :: li2)); auto.
        rewrite in_insert_iff in i0; destruct i0; [omega|].
        contradiction Hj; rewrite in_map_iff; do 2 eexists; eauto; omega.
    + exploit Hrest; eauto.
      rewrite Znth_0_cons; intros ->.
      erewrite (IHl (map (fun i => i - 1) li)), Zlength_map; try omega.
      * apply FinFun.Injective_map_NoDup; auto.
        intros ??; omega.
      * intros ? Hj; rewrite in_map_iff in Hj; destruct Hj as (j & ? & Hj); subst.
        specialize (Hli _ Hj).
        destruct (eq_dec j 0); [subst; contradiction|].
        destruct (zlt j 0).
        { rewrite Znth_underflow, Hd in Hli by auto; discriminate. }
        rewrite Znth_pos_cons in Hli by omega; auto.
      * intros j Hj.
        destruct (zlt j 0); [rewrite Znth_underflow; auto|].
        specialize (Hrest (j + 1)); specialize (Hli (j + 1));
          rewrite Znth_pos_cons, Z.add_simpl_r in Hrest, Hli by omega.
        destruct (in_dec Z.eq_dec (j + 1) li); auto.
        contradiction Hj; rewrite in_map_iff; do 2 eexists; eauto; omega.
Qed.

Lemma hists_eq : forall lr l (Hlr : Forall (fun '(h, ls) => add_events empty_map
  [HAdd 1 1 (Znth 0 ls); HAdd 2 1 (Znth 1 ls); HAdd 3 1 (Znth 2 ls)] h) lr)
  (Hlens : Forall (fun '(_, ls) => Zlength ls = 3) lr)
  (Hl : hist_list' (maps_add (map fst lr)) l) (Hdisj : all_disjoint (map fst lr)),
  Permutation (concat (map snd lr)) (map (fun e => match e with HAdd _ _ b => b | _ => false end) l).
Proof.
  induction lr; simpl; intros.
  - inv Hl; [constructor|].
    unfold map_upd in H0.
    apply equal_f with (x := t) in H0.
    rewrite if_true in H0 by auto; discriminate.
  - inv Hlr; inv Hlens.
    apply all_disjoint_cons in Hdisj as [].
    destruct a as (?, h); simpl in *.
    apply hist_list'_add in Hl as (l1 & l2 & ? & ? & ?); auto.
    etransitivity; [|apply Permutation_map; symmetry; eauto].
    rewrite map_app.
    apply Permutation_app; auto.
    match goal with |- Permutation ?a ?b => assert (a = b); [|subst; reflexivity] end.
    clear - H6 H1 H3.
    inv H1.
    apply (app_inj_tail _ [_; _] _ _) in H0 as []; subst.
    inv Hh'.
    apply (app_inj_tail _ [_] _ _) in H0 as []; subst.
    inv Hh'0.
    apply (app_inj_tail _ [] _ _) in H0 as []; subst.
    inv Hh'; [|destruct le; discriminate].
    inv H6.
    { apply equal_f with t in H0; unfold map_upd in H0.
      rewrite eq_dec_refl in H0; discriminate. }
    apply add_new_inj in H0 as (? & ? & ?); auto; subst.
    inv Hrest.
    { apply equal_f with t0 in H0; unfold map_upd in H0.
      rewrite eq_dec_refl in H0; discriminate. }
    apply add_new_inj in H0 as (? & ? & ?); auto; subst.
    inv Hrest0.
    { apply equal_f with t1 in H0; unfold map_upd in H0.
      rewrite eq_dec_refl in H0; discriminate. }
    apply add_new_inj in H0 as (? & ? & ?); auto; subst.
    inv Hrest; simpl.
    rewrite list_Znth_eq at 1.
    rewrite Zlength_correct in *.
    replace (length h) with 3%nat by (apply Nat2Z.inj; auto); reflexivity.
    { apply equal_f with t2 in H0; unfold map_upd in H0.
      rewrite eq_dec_refl in H0; discriminate. }
Qed.

Lemma add_three : forall lr HT l (Hlr : Zlength lr = 3)
  (Hhists : Forall (fun '(h, ls) => add_events empty_map [HAdd 1 1 (Znth 0 ls); HAdd 2 1 (Znth 1 ls);
     HAdd 3 1 (Znth 2 ls)] h) lr) (Hlens : Forall (fun '(_, ls) => Zlength ls = 3) lr)
  (Hl : hist_list (maps_add (map fst lr)) l) (HHT : apply_hist empty_map l = Some HT)
  (Hdisj : all_disjoint (map fst lr)),
  Zlength (filter id (concat (map snd lr))) = 3.
Proof.
  intros.
  assert (Permutation.Permutation (filter id (concat (map snd lr)))
    (filter id (map (fun e => match e with HAdd _ _ b => b | _ => false end) l))) as Hperm.
  { apply Permutation_filter, hists_eq; auto.
    apply hist_list_weak; auto. }
  rewrite (Permutation_Zlength _ _ Hperm).
  assert (forall k v, ~ In (HSet k v) l).
  { repeat intro.
    apply In_nth_error in H; destruct H as (? & H).
    apply Hl in H.
    apply in_maps_add in H as (m & Hin & Hm).
    apply in_map_iff in Hin as ((?, h) & ? & Hin); simpl in *; subst.
    rewrite Forall_forall in Hhists; specialize (Hhists _ Hin); simpl in Hhists.
    eapply add_events_dom in Hm; eauto; simpl in Hm.
    decompose [or] Hm; try discriminate; contradiction. }
  assert (forall i, 0 <= i < 3 -> In (HAdd (i + 1) 1 (Znth i (snd (Znth 0 lr)))) l) as Hins.
  { intros.
    assert (exists t, maps_add (map fst lr) t = Some (HAdd (i + 1) 1 (Znth i (snd (Znth 0 lr)))))
      as (t & Hin).
    { exploit (Znth_In 0 lr); [omega | intro Hin].
      rewrite Forall_forall in Hhists; specialize (Hhists _ Hin).
      destruct (Znth 0 lr) as (h, ?); simpl in *.
      apply add_events_in with (e := HAdd (i + 1) 1 (Znth i l0)) in Hhists as (t & _ & Hh).
      exists t; eapply maps_add_in; eauto.
      { apply all_disjoint_compatible; auto. }
      rewrite in_map_iff; eexists (_, _); simpl; eauto.
      { destruct (eq_dec i 0); [subst; simpl; auto|].
        destruct (eq_dec i 1); [subst; simpl; auto|].
        destruct (eq_dec i 2); [subst; simpl; auto | omega]. } }
    apply Hl in Hin; eapply nth_error_in; eauto. }
  exploit (one_add_succeeds 1 1 (Znth 0 (snd (Znth 0 lr))) l); eauto.
  { eapply (Hins 0); auto; omega. }
  exploit (one_add_succeeds 2 1 (Znth 1 (snd (Znth 0 lr))) l); eauto.
  { eapply (Hins 1); auto; omega. }
  exploit (one_add_succeeds 3 1 (Znth 2 (snd (Znth 0 lr))) l); eauto.
  { eapply (Hins 2); auto; omega. }
  intros (v3 & Hin3) (v2 & Hin2) (v1 & Hin1).
  apply In_Znth in Hin1; destruct Hin1 as (t1 & ? & Ht1).
  apply In_Znth in Hin2; destruct Hin2 as (t2 & ? & Ht2).
  apply In_Znth in Hin3; destruct Hin3 as (t3 & ? & Ht3).
  rewrite filter_find_count with (li := [t1; t2; t3]); auto; simpl.
  - repeat constructor; auto; simpl.
    + intros [|[|]]; try contradiction; subst.
      * rewrite Ht1 in Ht2; inv Ht2.
      * rewrite Ht1 in Ht3; inv Ht3.
    + intros [|]; try contradiction; subst.
      rewrite Ht2 in Ht3; inv Ht3.
  - intros ? [|[|[|]]]; try contradiction; subst; rewrite Znth_map by omega.
    + rewrite Ht1; auto.
    + rewrite Ht2; auto.
    + rewrite Ht3; auto.
  - intros i Hi.
    destruct (zlt i 0); [rewrite Znth_underflow; auto|].
    destruct (zlt i (Zlength l)); [|rewrite Znth_overflow by (rewrite Zlength_map; omega); auto].
    rewrite Znth_map by omega.
    destruct (Znth i l) eqn: Hith; auto.
    destruct r; auto.
    contradiction Hi.
    assert (k = 1 \/ k = 2 \/ k = 3) as Hk.
    { rewrite <- nth_Znth in Hith by omega.
      exploit nth_error_nth; [apply Nat2Z.inj_lt; rewrite Z2Nat.id, <- Zlength_correct; eauto; omega|].
      rewrite Hith; intro Hin.
      apply Hl in Hin.
      apply in_maps_add in Hin as (? & Hin & Hm); subst.
      rewrite in_map_iff in Hin; destruct Hin as ((h, ?) & ? & Hin); subst; simpl in *.
      rewrite Forall_forall in Hhists; specialize (Hhists _ Hin); simpl in Hhists.
      eapply add_events_dom in Hhists; eauto; simpl in Hhists.
      destruct Hhists as [X | [X | [X | [X | X]]]]; inv X; auto. }
    destruct Hk as [|[|]]; [left | right; left | right; right; left];
      match goal with |-?P => assert (P /\ Znth (k - 1) [v1; v2; v3] = v); [|tauto] end;
      subst; eapply only_one_add_succeeds; eauto.
Qed.

Lemma body_main : semax_body Vprog Gprog f_main main_spec.
Proof.
  name m_entries _m_entries.
  name locksp _thread_locks.
  name resp _results.
  start_function.
  replace 16384 with size by (setoid_rewrite (proj2_sig has_size); auto).
  forward.
  forward_call gv.
  { unfold tentry; cancel. }
  Intros x; destruct x as ((entries, g), lg).
  ghost_alloc (ghost_hist_ref(hist_el := hashtable_hist_el) Tsh empty_map empty_map).
  { split; auto; apply self_completable. }
  Intro gh.
  rewrite <- hist_ref_join_nil by (apply Share.nontrivial); Intros.
  rewrite <- (emp_sepcon (ghost_hist _ _ _)); Intros.
  viewshift_SEP 0 (EX inv_names : invG, wsat).
  { go_lower; apply make_wsat. }
  Intro inv_names.
  gather_SEP 0 5 2; viewshift_SEP 0 (except0 (wsat * EX i : _, invariant i (hashtable_inv gh g lg entries))).
  { go_lower.
    eapply derives_trans, wsat_fupd_elim.
    apply sepcon_derives; [apply derives_refl|].
    apply (make_inv (Empty_set _) _ (hashtable_inv gh g lg entries)).
    unfold hashtable_inv.
    Exists (@empty_map Z Z) (@nil hashtable_hist_el); entailer!. }
  erewrite except0_sepcon, except0_exp by apply O; Intros i1.
  destruct (split_shares 3 Ews) as (sh0 & shs & ? & ? & ? & Hshs); auto.
  destruct (split_shares 3 Tsh) as (sh0' & shs' & ? & ? & ? & Hshs'); auto.
  destruct (split_readable_share Tsh) as (sh1 & sh2 & ? & ? & ?); auto.
  rewrite <- seq_assoc.
  set (f_lock j l r := f_lock_pred sh2 (Znth j shs) (Znth j shs') entries gh (gv _m_entries)
                                         j (gv _thread_locks) l (gv _results) r).
  forward_for_simple_bound 3 (EX i : Z, EX res : list val, EX locks : list val,
    PROP (Zlength res = i; Zlength locks = i)
    LOCAL (temp _total (vint 0); gvars gv)
    SEP (@data_at CompSpecs Ews (tarray tentry size) entries (gv _m_entries);
         except0 wsat; except0 (invariant i1 (hashtable_inv gh g lg entries));
         ghost_hist(hist_el := hashtable_hist_el) Tsh empty_map gh;
         fold_right sepcon emp (map (fun x => malloc_token Tsh tint (fst x) * malloc_token Tsh tint (snd x))
           entries);
         data_at Ews (tarray (tptr tint) 3) (res ++ repeat Vundef (Z.to_nat (3 - i))) (gv _results) *
         fold_right sepcon emp (map (data_at_ Tsh tint) res) *
         fold_right sepcon emp (map (malloc_token Tsh tint) res) *
         data_at Ews (tarray (tptr (Tstruct _lock_t noattr)) 3)
           (locks ++ repeat Vundef (Z.to_nat (3 - i))) (gv _thread_locks) *
         fold_right sepcon emp (map (malloc_token Tsh (Tstruct _lock_t noattr)) locks) *
         fold_right sepcon emp (map (fun j => lock_inv Tsh (Znth j locks)
           (f_lock j (Znth j locks) (Znth j res))) (upto (Z.to_nat i))))).
  { Exists (@nil val) (@nil val); rewrite !data_at__eq; entailer!.
    erewrite map_ext; [apply derives_refl|]; intros (?, ?); auto. }
  { 
    forward_call (Tstruct _lock_t noattr).
    { repeat split; auto; simpl; computable. }
    rewrite sepcon_map; Intros l.
    forward.
    forward_call tint.
    { repeat split; auto; simpl; computable. }
    Intros r.
    forward.
    focus_SEP 3.
    forward_call (l, Tsh, f_lock i l r).
    { rewrite lock_struct; cancel. }
    Exists (res ++ [r]) (locks ++ [l]); rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; entailer!.
    rewrite lock_inv_isptr, data_at__isptr; Intros.
    rewrite Z2Nat.inj_add, upto_app, !map_app, !sepcon_app by omega.
    simpl; change (upto 1) with [0]; simpl.
    rewrite Z2Nat.id, Z.add_0_r by omega.
    replace (Zlength res + 1) with (Zlength (res ++ [r]))
      by (rewrite Zlength_app, Zlength_cons, Zlength_nil; auto).
    rewrite <- upd_complete_gen by omega.
    replace (Zlength (res ++ [r])) with (Zlength (locks ++ [l]))
      by (rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; auto; omega).
    rewrite <- upd_complete_gen by omega.
    rewrite !app_Znth2 by omega.
    replace (Zlength locks) with (Zlength res); rewrite Zminus_diag, !Znth_0_cons.
    destruct r; try contradiction.
    destruct l; try contradiction.
    rewrite sepcon_map; cancel.
    apply sepcon_list_derives; rewrite !Zlength_map, !Zlength_upto, <- Zlength_correct.
    { rewrite Z2Nat.id; auto; omega. }
    intros.
    erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, <- ?Zlength_correct, ?Z2Nat.id; auto; omega).
    rewrite !app_Znth1 by omega; auto. }
  Intros res locks.
  rewrite !app_nil_r.
  assert_PROP (Zlength entries = size) by (pose proof size_pos; entailer!).
  rewrite <- seq_assoc.
  forward_for_simple_bound 3 (EX i : Z, EX sh : share, EX sh' : share,
    PROP (sepalg_list.list_join sh0 (sublist i 3 shs) sh; sepalg_list.list_join sh0' (sublist i 3 shs') sh')
    LOCAL (temp _total (vint 0); gvars gv)
    SEP (@data_at CompSpecs sh (tarray tentry size) entries (gv _m_entries);
         except0 wsat; except0 (invariant i1 (hashtable_inv gh g lg entries));
         ghost_hist(hist_el := hashtable_hist_el) sh' empty_map gh;
         fold_right sepcon emp (map (fun x => malloc_token Tsh tint (fst x) * malloc_token Tsh tint (snd x))
           entries);
         data_at sh (tarray (tptr tint) 3) res (gv _results);
         fold_right sepcon emp (map (data_at_ Tsh tint) (sublist i 3 res));
         fold_right sepcon emp (map (malloc_token Tsh tint) res);
         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) locks (gv _thread_locks);
         fold_right sepcon emp (map (malloc_token Tsh (Tstruct _lock_t noattr)) locks);
         fold_right sepcon emp (map (fun j => lock_inv (if zlt j i then sh1 else Tsh) (Znth j locks)
           (f_lock j (Znth j locks) (Znth j res))) (upto 3)))).
  { rewrite !sublist_same by auto; unfold f_lock; Exists Ews Tsh; entailer!.
    erewrite map_ext_in; [apply derives_refl|].
    intros ??%In_upto.
    simpl; if_tac; auto; omega. }
  { 
    replace_SEP 2 (|> (invariant i1 (hashtable_inv gh g lg entries) || FF)).
    { go_lower; unfold except0.
      rewrite later_orp.
      apply orp_left; [apply orp_right1, now_later | apply orp_right2; auto]. }
    forward_call tint.
    { repeat split; auto; simpl; computable. }
    Intros t.
    rewrite sepcon_map; Intros.
    forward.
    simpl in *; assert (3 <= Zlength shs) by omega.
    match goal with H : sepalg_list.list_join sh0 _ _ |- _ => rewrite sublist_next in H by auto;
      inversion H as [|????? Hj1 Hj2]; subst end.
    apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (sh3 & ? & Hj3).
    assert (3 <= Zlength shs') by omega.
    match goal with H : sepalg_list.list_join sh0' _ _ |- _ => rewrite sublist_next in H by auto;
      inversion H as [|????? Hj1' Hj2']; subst end.
    apply sepalg.join_comm in Hj1'; destruct (sepalg_list.list_join_assoc1 Hj1' Hj2') as (sh3' & ? & Hj3').
    rewrite invariant_dup, orp_FF.
    assert_PROP (isptr t) by entailer!.
    forward_spawn _f t (Znth i shs, Znth i shs', sh2, entries, i1, gh, g, lg, gv, i, gv _thread_locks, Znth i locks, gv _results,
               Znth i res, inv_names).
    { assert (0 <= i < Zlength shs) by omega.
      assert (Znth i shs' <> Share.bot).
      { intro X; contradiction unreadable_bot; rewrite <- X.
        apply Forall_Znth; auto; omega. }
      rewrite (extract_nth_sepcon (map _ (upto 3)) i) by (rewrite Zlength_map; auto).
      erewrite Znth_map, Znth_upto by (auto; simpl; omega).
      rewrite if_false by omega.
      rewrite lock_inv_isptr; Intros.
      entailer!.
      { apply Forall_Znth; auto. }
      rewrite <- !(data_at_share_join _ _ _ _ _ _ Hj3).
      replace empty_map with (@map_add nat hashtable_hist_el empty_map empty_map) by apply map_add_empty.
      pose proof (@empty_map_disjoint nat hashtable_hist_el empty_map) as Hdisj.
      erewrite (add_andp (ghost_hist _ _ _) (!!_)) by (apply prop_right, Hdisj).
      rewrite andp_comm, <- (ghost_hist_join _ _ _ _ _ _ Hj3'); auto.
      rewrite <- (lock_inv_share_join sh1 sh2) by auto.
      fast_cancel; cancel.
      rewrite (sepcon_comm _ (data_at (Znth i shs) _ _ (gv _thread_locks))), !sepcon_assoc; apply sepcon_derives.
      { rewrite lock_struct_array; apply stronger_array_ext.
        - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.
        - intros j ???; unfold unfold_reptype; simpl.
          destruct (eq_dec j i).
          + subst; rewrite upd_Znth_same by auto; apply derives_refl.
          + rewrite upd_Znth_diff by auto.
            setoid_rewrite Znth_repeat with (n0 := 3%nat); apply stronger_default_val. }
      rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at (Znth i shs) _ _ (gv _results))),
        !sepcon_assoc; apply sepcon_derives.
      { apply stronger_array_ext.
        - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.
        - intros j ???; unfold unfold_reptype; simpl.
          destruct (eq_dec j i).
          + subst; rewrite upd_Znth_same by auto; apply derives_refl.
          + rewrite upd_Znth_diff' by auto.
            setoid_rewrite Znth_repeat with (n0 := 3%nat); apply stronger_default_val. }
      erewrite sublist_next by (auto; omega); simpl; fast_cancel.
      { intro; subst; contradiction unreadable_bot.
        eapply join_readable1, readable_share_list_join; eauto. } }
    { simpl; auto. }
    go_lower.
    Exists sh3 sh3'; rewrite sepcon_map; entailer!.
    rewrite sepcon_assoc; apply sepcon_derives; [apply except0_intro|].
    rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; rewrite !Zlength_map;
      auto.
    intros j ?; destruct (eq_dec j i).
    - subst; rewrite upd_Znth_same by auto.
      erewrite Znth_map, Znth_upto by (auto; simpl; omega).
      if_tac; [auto | omega].
    - rewrite upd_Znth_diff' by auto.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      if_tac; if_tac; auto; omega. }
  Intros sh sh'.
  rewrite sublist_nil.
  repeat match goal with H : sepalg_list.list_join _ (sublist 3 3 _) _ |- _ =>
    rewrite sublist_nil in H; inv H end.
  forward_for_simple_bound 3 (EX i : Z, EX x : (share * (list (hist * list bool))), EX sh' : share,
    PROP (readable_share (fst x); sepalg_list.list_join (fst x) (sublist i 3 shs) Ews; Zlength (snd x) = i;
          Forall (fun p => let '(h, ls) := p in add_events empty_map
            [HAdd 1 1 (Znth 0 ls); HAdd 2 1 (Znth 1 ls); HAdd 3 1 (Znth 2 ls)] h) (snd x);
          Forall (fun '(h, ls) => Zlength ls = 3) (snd x); all_disjoint (map fst (snd x));
          readable_share sh'; sepalg_list.list_join sh' (sublist i 3 shs') Tsh)
    LOCAL (let ls := map snd (snd x) in temp _total (vint (Zlength (filter id (concat ls)))); gvars gv)
    SEP (@data_at CompSpecs (fst x) (tarray tentry size) entries (gv _m_entries);
         except0 wsat; except0 (invariant i1 (hashtable_inv gh g lg entries));
         let h := map fst (snd x) in ghost_hist sh' (fold_right map_add empty_map h) gh;
         fold_right sepcon emp (map (fun x => malloc_token Tsh tint (fst x) * malloc_token Tsh tint (snd x))
           entries);
         data_at (fst x) (tarray (tptr tint) 3) res (gv _results);
         fold_right sepcon emp (map (malloc_token Tsh tint) (sublist i 3 res));
         data_at (fst x) (tarray (tptr (Tstruct _lock_t noattr)) 3) locks (gv _thread_locks);
         fold_right sepcon emp (map (malloc_token Tsh (Tstruct _lock_t noattr)) (sublist i 3 locks));
         fold_right sepcon emp (map (fun j => lock_inv sh1 (Znth j locks)
           (f_lock j (Znth j locks) (Znth j res))) (sublist i 3 (upto 3))))).
  { rewrite !(sublist_same 0 3) by auto.
    Exists (sh, @nil (hist * list bool)) sh'; entailer!.
    erewrite map_ext_in; [apply derives_refl|].
    intros ??%In_upto; simpl in *.
    if_tac; auto; omega. }
  { 
    destruct x as (sh3, lr); simpl in *.
    erewrite sublist_next with (l := upto 3), Znth_upto by (auto; rewrite ?Zlength_upto; simpl; omega); simpl.
    rewrite lock_inv_isptr, sepcon_map; Intros.
    forward.
    forward_call (Znth i locks, sh1, f_lock i (Znth i locks) (Znth i res)).
    unfold f_lock at 2; unfold f_lock_pred.
    rewrite selflock_eq; Intros.
    forward_call (Znth i locks, Tsh, sh2,
      f_lock_inv (Znth i shs) (Znth i shs') entries gh (gv _m_entries) i (gv _thread_locks) (Znth i locks) (gv _results) (Znth i res),
      f_lock i (Znth i locks) (Znth i res)).
    { lock_props.
      { subst f_lock; simpl.
        apply f_pred_exclusive; auto.
        apply Forall_Znth; auto; omega. }
      rewrite (sepcon_comm _ (lock_inv _ _ _)), !sepcon_assoc, <- sepcon_assoc;
        apply sepcon_derives; [|cancel_frame].
      rewrite <- (lock_inv_share_join sh1 sh2 Tsh) by auto; unfold f_lock, f_lock_pred; cancel. }
    erewrite sublist_next with (l := locks) by (auto; omega); simpl.
    forward_call (Tstruct _lock_t noattr, Znth i locks).
    { rewrite lock_struct; cancel. }
    unfold f_lock_inv at 1; Intros b1 b2 b3 hi.
    assert (0 <= i < Zlength shs) by omega.
    assert (readable_share (Znth i shs)) by (apply Forall_Znth; auto).
    forward.
    { assert (0 <= i < 3) as Hi by auto; clear - Hi; entailer!.
      rewrite upd_Znth_same; auto. }
    rewrite upd_Znth_same by auto.
    forward.
    Opaque filter.
    erewrite sublist_next with (l := res) by (auto; omega); simpl.
    forward_call (tint, Znth i res).
    { cancel. }
    assert (3 <= Zlength shs) by omega.
    match goal with H : sepalg_list.list_join sh3 _ _ |- _ => rewrite sublist_next in H by auto;
      inversion H as [|??? w1 ? Hj1]; subst end.
    match goal with H : sepalg_list.list_join sh'0 _ _ |- _ => rewrite sublist_next in H by (auto; omega);
      inversion H as [|??? w1' ? Hj1']; subst end.
    gather_SEP 12 2.
    replace_SEP 0 (data_at w1 (tarray (tptr (Tstruct _lock_t noattr)) 3) locks (gv _thread_locks)).
    { go_lower.
      rewrite <- lock_struct_array.
      eapply derives_trans; [apply data_at_array_value_cohere; auto|].
      erewrite data_at_share_join by eauto; apply derives_refl. }
    gather_SEP 10 3.
    replace_SEP 0 (data_at w1 (tarray (tptr tint) 3) res (gv _results)).
    { go_lower.
      eapply derives_trans; [apply data_at_array_value_cohere; auto|].
      erewrite data_at_share_join by eauto; apply derives_refl. }
    gather_SEP 7 2; erewrite ghost_hist_join; eauto.
    gather_SEP 4 3; erewrite data_at_share_join by eauto.
    assert (0 <= Zlength (filter id [b1; b2; b3]) <= 3).
    { split; [apply Zlength_nonneg|].
      etransitivity; [apply Zlength_filter|].
      rewrite !Zlength_cons, Zlength_nil in *; omega. }
    assert (0 <= Zlength (filter id (concat (map snd lr))) <= 3 * Zlength shs).
    { split; [apply Zlength_nonneg|].
      etransitivity; [apply Zlength_filter|].
      etransitivity; [apply Zlength_concat_le with (n := 3)|].
      * rewrite Forall_map.
        eapply Forall_impl; [|eauto].
        intros []; simpl; omega.
      * rewrite Zlength_map; omega. }
    forward.
    go_lower; Exists (w1, lr ++ [(hi, [b1; b2; b3])]) w1'; rewrite sepcon_map; entailer!.
    rewrite !map_app, concat_app, filter_app, !Zlength_app, Zlength_cons, Zlength_nil; simpl;
      repeat (split; auto).
    - eapply join_readable1; eauto.
    - rewrite Forall_app; repeat constructor; auto.
    - rewrite Forall_app; repeat constructor; auto.
    - apply all_disjoint_snoc; split; auto.
      symmetry; auto.
    - eapply join_readable1; eauto.
    - rewrite map_app, fold_right_app; simpl.
      rewrite map_add_empty, <- fold_right_maps_add; auto.
    - intro; subst; contradiction unreadable_bot.
    - intro X; contradiction unreadable_bot; rewrite <- X.
      apply Forall_Znth; auto; omega. }
  Intros x sh''; destruct x as (?, lr); simpl fst in *; simpl snd in *.
  repeat match goal with H : sepalg_list.list_join _ (sublist 3 3 _) _ |- _ =>
    rewrite sublist_nil in H; inv H end.
  gather_SEP 3 2.
  replace_SEP 0 (|={Ensembles.Singleton i1,Empty_set _}=> !!(Zlength (filter id (concat (map snd lr))) = 3)).
  { go_lower.
    eapply derives_trans; [apply except0_frame_l | apply fupd_except0_elim].
    eapply derives_trans; [apply sepcon_derives; [apply derives_refl | apply inv_open with (E := Ensembles.Singleton i1); constructor]|].
    eapply derives_trans; [apply fupd_frame_l|].
    eapply derives_trans, fupd_trans; apply fupd_mono.
    rewrite <- sepcon_assoc.
    eapply derives_trans.
    { apply sepcon_derives, derives_refl.
      eapply derives_trans.
      { apply sepcon_derives; [apply derives_refl|].
        apply except0_timeless, hashtable_inv_timeless; apply except0_intro. }
      eapply derives_trans; [apply except0_frame_l | apply except0_mono].
      unfold hashtable_inv.
      Intros HT hr.
      instantiate (1 := !!(exists l HT, hist_list (fold_right map_add empty_map (map fst lr)) l /\
        apply_hist empty_map l = Some HT) && TT).
      apply andp_right; auto.
      rewrite <- sepcon_assoc, sepcon_comm, <- !sepcon_assoc.
      rewrite (sepcon_comm (ghost_ref _ _)), hist_ref_join by auto.
      Intros l; apply prop_right.
      match goal with H : hist_sub _ _ _ |- _ => apply hist_sub_Tsh in H; subst end.
      exists hr, HT; split; auto. }
    eapply derives_trans; [apply except0_frame_r | apply fupd_except0_elim].
    rewrite sepcon_andp_prop'; Intros.
    replace (Subtract (Ensembles.Singleton i1) i1) with (Empty_set iname).
    eapply derives_trans, fupd_intro.
    apply prop_right.
    destruct H14 as (l & HT & ? & ?).
    eapply add_three; eauto.
    { apply Extensionality_Ensembles; split; intros ? Hin; inv Hin; contradiction. } }
    forward.
Qed.

End Proofs.