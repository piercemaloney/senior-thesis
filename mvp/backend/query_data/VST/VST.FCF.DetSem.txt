

Set Implicit Arguments.



Require Export FCF.Comp.

Require Import FCF.Blist.
(* FCF.Blist:
Set Implicit Arguments.

Require Import FCF.StdNat.
Require Export List.
Require Export Bvector.
Require Import Omega.
Require Import FCF.EqDec.
Require Import FCF.Fold.
Require Import Coq.NArith.Ndigits.
Require Import ZArith.
Local Open Scope list_scope.

Definition Blist := list bool.

Definition Blist_eq_dec := (list_eq_dec bool_dec).

Definition Bvector_eq_dec(n : nat)(v1 v2 : Bvector n) : {v1 = v2} + {v1 <> v2}.

Fixpoint shiftOut(s : Blist)(n : nat) : option (Bvector n * Blist) :=
  match n with
    | 0 => Some ((@Vector.nil bool), s)
    | S n' => 
      match s with
        | nil => None
        | b :: s' => 
          match (shiftOut s' n') with
            | Some (v', s'') => Some (Vector.cons _ b _ v', s'')
            | None => None
          end
      end
  end.

Theorem shiftOut_app : forall (n : nat)(s1 s1' s2 : Blist) v,
  shiftOut s1 n = Some (v, s1') ->
  shiftOut (s1 ++ s2) n = Some (v, s1' ++ s2).

Lemma shiftOut_lt : forall ls n,
  length ls < n ->
  shiftOut ls n = None.

Lemma shiftOut_Some : forall (ls : Blist) n,
  length ls >= n ->
  exists p, shiftOut ls n = Some p.

Theorem shiftOut_None_inv : forall n ls,
  shiftOut ls n = None ->
  n > length ls.

Theorem shiftOut_Some_inv : forall n ls v ls',
  shiftOut ls n = Some (v, ls') ->
  (n <= length ls)%nat.

Theorem shiftOut_correct_inv : forall n ls ls' v,
  shiftOut ls n = Some (v, ls') ->
  ls = (Vector.to_list v) ++ ls'.

Lemma to_list_length : forall (A : Set)(m : nat)(v : Vector.t A m),

Definition of_list_length (A : Set)(m : nat)(ls : list A)(pf : length ls = m) : Vector.t A m :=
  match pf with
    | eq_refl => Vector.of_list ls
  end.

Definition of_sig_list (A : Set)(m : nat)(l : {ls : list A | length ls = m}) : Vector.t A m :=
  match l with
    | exist _ ls pf => (of_list_length ls pf)
  end.

Lemma vector_hd_cons_eq : forall(A : Set)(v : Vector.t A 1),

Lemma shiftOut_0 : forall (s : Blist),
  shiftOut s 0 = Some ([], s).

Theorem shiftOut_S_None : forall (n : nat)(s s1 : Blist)(v1 : Bvector 1),
  shiftOut s 1 = Some (v1, s1) ->
  shiftOut s1 n = None ->
  shiftOut s (S n) = None.
Abort.

Theorem shiftOut_1_None : forall (n1 n2 : nat)(s : Blist),
  shiftOut s n1 = None ->
  n2 >= n1 ->
  shiftOut s n2 = None.
Abort.

Theorem shiftOut_S : forall (n : nat)(s s1 s2 : Blist)(v1 : Bvector 1)(v2 : Bvector n),
  shiftOut s 1 = Some (v1, s1) ->
  shiftOut s1 n = Some (v2, s2) ->
  shiftOut s (S n) = Some (Vector.cons _ (Vector.hd v1) _  v2, s2). 

Fixpoint oneList(n : nat) : Blist :=
  match n with
    | 0 => nil
    | S n' => true :: (oneList n')
  end.

Theorem oneList_length : forall n,
  length (oneList n) = n.

Fixpoint oneVector(n : nat) : Bvector n :=
  match n with
    | 0 => Vector.nil bool
    | S n' => Vector.cons _ true _ (oneVector n')
  end.

Theorem shiftOut_oneList : forall (n : nat),
  shiftOut (oneList n) n = Some (oneVector n, nil).

Fixpoint getAllBlists(n : nat) : (list Blist) :=
  match n with
    | 0 => nil :: nil
    | S n' => (map (cons true) (getAllBlists n')) ++
      (map (cons false) (getAllBlists n'))
  end.

Fixpoint getAllBlists_app(n : nat) : list Blist :=
  match n with
    | 0 => nil :: nil
    | S n' => (map (fun ls => ls ++ (true :: nil)) (getAllBlists_app n')) ++
      (map (fun ls => ls ++ (false :: nil)) (getAllBlists_app n'))
  end.

Fixpoint getAllBvectors(n : nat) : (list (Bvector n)) :=
  match n with
    | 0 => (Vector.nil bool) :: nil
    | S n' => (map (Vector.cons _ true _) (getAllBvectors n')) ++
      (map (Vector.cons _ false _) (getAllBvectors n'))
  end.

Lemma getAllBvectors_length : forall n,
  length (getAllBvectors n) = (expnat 2 n).

Lemma getAllBvectors_length_nz : forall n,
  length (getAllBvectors n) > 0.

Theorem in_getAllBvectors : forall (n : nat)(v : Bvector n),
  In v (getAllBvectors n).

Lemma vector_tl_eq : forall (A : Set)(n : nat)(v1 v2 : Vector.t A (S n)),

Lemma vector_cons_eq : forall (A : Set)(n : nat)(v1 v2 : Vector.t A n)(a1 a2 : A),

Lemma vector_cons_ne : forall (A : Set)(n : nat)(a1 a2 : Vector.t A n)(a : A),

Lemma map_NoDup : forall (A B : Set)(ls : list A)(f : A -> B),
  NoDup ls ->
  (forall a1 a2, a1 <> a2 -> (f a1) <> (f a2)) ->
  NoDup ((map f) ls).

Lemma getAllBvectors_NoDup : forall (n : nat),
  NoDup (getAllBvectors n).

Require Import Permutation.

Lemma getAllBlists_NoDup : forall n,
  NoDup (getAllBlists n).

Lemma getAllBlists_app_NoDup : forall n,
  NoDup (getAllBlists_app n).
    Lemma ls_last_exists : forall (A : Type)(ls : list A) n,
      length ls = (S n) ->
      exists a ls', (length ls' = n /\ ls = ls' ++ (a :: nil)).

Lemma getAllBlists_app_rel_map : forall n,
  rel_map (fun ls1 ls2 => ls1 = (rev ls2)) (getAllBlists_app n) (getAllBlists n).

Lemma getAllBlists_rel_map : forall n,
  rel_map (fun ls1 ls2 => ls1 = (rev ls2)) (getAllBlists n) (getAllBlists_app n).

Lemma getAllBlists_app_In_length : forall n ls,
  In ls (getAllBlists_app n) ->
  length ls = n.

Lemma getAllBlists_app_length_In : forall n ls,
  length ls = n ->
  In ls (getAllBlists_app n).

Lemma getAllBlists_In_length : forall n ls,
  In ls (getAllBlists n) ->
  length ls = n.

Lemma getAllBlists_length_In : forall n ls,
  length ls = n ->
  In ls (getAllBlists n).

Lemma getAllBlists_perm : forall n,
  Permutation (getAllBlists n) (getAllBlists_app n).

Theorem getAllBlists_length : forall n,
  length (getAllBlists n) = (expnat 2 n).

Fixpoint tailOpt(A : Set)(n : nat)(v : Vector.t A n) : option (Vector.t A (pred n)):=
  match v with
    | [] => None
    | Vector.cons _ _ _ v => Some v
  end.

Lemma tailOpt_eq : forall (A : Set)(n : nat)(v1 v2 : Vector.t A n),

Lemma vector_cons_eq_inv : forall (A : Set)(n : nat)(a1 a2 : A)(v1 v2 : Vector.t A n),

Lemma pair_eq_inv : forall (A B : Type)(a1 a2 : A)(b1 b2 : B),
  (a1, b1) = (a2, b2) ->
  a1 = a2 /\ b1 = b2.

Lemma opt_eq_inv : forall (A : Type)(a1 a2 : A),
  Some a1 = Some a2 ->
  a1 = a2.

Lemma shiftOut_ls_eq : forall n ls1 ls2 v ls1' ls2',
  shiftOut ls1 n = Some (v, ls1') ->
  shiftOut ls2 n = Some (v, ls2') ->
  (firstn n ls1) = (firstn n ls2).

Lemma le_refl_gen : forall n1 n2,
  (n1 = n2 ->
    n1 <= n2)%nat.

Lemma app_first_eq : forall (A : Type)(ls2 ls1 ls3 : list A),
  ls1 = ls2 ++ ls3 ->
  length ls1 = length ls2 ->
  ls1 = ls2 /\ ls3 = nil.

Lemma to_list_eq_inv : forall (A : Set) n (v1 v2 : Vector.t A n),

Lemma shiftOut_to_list : forall n (v : Bvector n),
  shiftOut (VectorDef.to_list v) n = Some (v, nil).

Lemma shiftOut_app_None : forall ls1 ls2 n,
  shiftOut (ls1 ++ ls2) n = None ->
  shiftOut ls1 n = None.

Lemma BVxor_same_id : forall n (v : Bvector n),
  BVxor n v v = Bvect_false n.

Lemma BVxor_comm : forall n (v1 v2 : Bvector n),
  BVxor n v1 v2 = BVxor n v2 v1.

Lemma BVxor_id_r : forall n (v : Bvector n),
  BVxor n v (Bvect_false n) = v.

Lemma BVxor_id_l : forall n (v : Bvector n),
  BVxor n (Bvect_false n) v = v.

Lemma BVxor_assoc : forall n (v1 v2 v3 : Bvector n),
  BVxor n (BVxor n v1 v2) v3 = BVxor n v1 (BVxor n v2 v3).

Lemma BVxor_id_r_inv : forall n (v1 v2 : Bvector n),
  BVxor n v1 v2 = v1 ->
  v2 = (Bvect_false n).

Lemma BVxor_id_inv : forall n (v1 v2 : Bvector n),
  BVxor n v1 v2 = Bvect_false n ->
  v1 = v2.

Definition lognat(n : nat) : nat := 
  N.size_nat (N.of_nat n).

Definition bvToNat(k : nat)(v : Bvector k) :=
  N.to_nat (Bv2N k v).

Lemma Bv2N_zero : forall (n : nat),
  Bv2N n (Bvect_false n) = N0.

Lemma bvNat_zero : forall n, 
  bvToNat (Bvect_false n) = O.

Definition natToBv(k : nat)(v : nat) : Bvector k :=
  N2Bv_gen k (N.of_nat v).

Lemma Bv2N_app_false : forall n1 n2 (v1 : Bvector n1),
  Bv2N (n1 + n2) (Vector.append v1 (Bvect_false n2)) = Bv2N n1 v1.

Lemma Bv2N_N2Bv_gen : forall n0 k,
  n0 >= N.size_nat k ->
  
Lemma bvToNat_natToBv_inverse : forall n k,
  n >= lognat k ->
  bvToNat (natToBv n k) = k.

Lemma Nat_size_nat_monotonic : forall n1 n2,
  (n1 < n2)%N ->
  (N.size_nat n1 <= N.size_nat n2)%nat.
  
Lemma lognat_monotonic : forall n1 n2,
  (n1 < n2 ->
    lognat n1 <= lognat n2)%nat.

Lemma natToBv_bvToNat_inverse : forall n k,
  (natToBv n (bvToNat k)) = k.

Lemma bvToNat_natToBv_eq : forall n (v : Bvector n) k,
  bvToNat v = k ->
  v = natToBv n k. *)

Require Import FCF.Fold.
(* FCF.Fold:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import List.
Require Import Permutation.
Require Import Arith.
Require Import FCF.EqDec.
Require Import FCF.StdNat.
Require Import Bool.

Local Open Scope rat_scope.

Definition unzip(A B : Set)(ls : list (A * B)) :=
  (map (@fst _ _) ls, map (@snd _ _) ls).

Fixpoint zip(A B : Set)(lsa : list A)(lsb : list B) :=
  match lsa with
    | nil => nil
    | a :: lsa' =>
      match lsb with
        | nil => nil
        | b :: lsb' =>
          (a, b) :: (zip lsa' lsb')
      end
  end.

Ltac pairInv := 
  match goal with
    | [H : (_, _) = (_, _) |- _] => 
      inversion H; clear H; subst
  end.

Section RemoveDups.

  Variable A : Set.
  Variable eqd : EqDec A.

  Fixpoint removeDups(ls : list A) :=
    match ls with
      | nil => nil
      | a' :: ls' =>
        if (in_dec (EqDec_dec _) a' ls') then (removeDups ls') else (a' :: (removeDups ls'))
    end.

  Theorem removeDups_in : 
    forall (ls : list A) a,
      In a (removeDups ls) ->
      In a ls.
  
  Theorem removeDups_NoDup :
    forall (ls : list A),
      NoDup (removeDups ls).

  Lemma in_removeDups : 
    forall (ls : list A) a,
      In a ls -> 
      In a (removeDups ls).
     
End RemoveDups.

Section ListReplace.

  Variable A : Set.

  Fixpoint listReplace (ls : list A)(i : nat)(a def : A) :=
    match i with
      | O => 
        match ls with
        | nil => a :: nil
        | a' :: ls' => a :: ls'
        end
      | S i' => 
        match ls with
        | nil => def :: (listReplace nil i' a def)
        | a' :: ls' =>
          a' :: (listReplace ls' i' a def)
        end
    end.

End ListReplace.

Section SumList.

  Variable A : Set.

  Definition sumList(ls : list A)(f : A -> Rat) := fold_left (fun a b => a + (f b)) ls 0.

  Theorem sumList_ne_0 : forall (ls : list A)(f : A -> Rat),
    ~ (sumList ls f) == 0 ->
    exists b : _,
      In b ls /\
      ~ ((f b) == 0).
  Abort.

  Theorem sumList_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    (forall b, (f1 b) == (f2 b)) ->
    (sumList ls1 f1) == (sumList ls2 f2).
  Abort.

  Lemma fold_add_init : forall (ls : list A)(f : A -> Rat) init1 init2,
    fold_left (fun (r : Rat) (a : A) => r + (f a)) ls (init1 + init2) == 
    init1 + (fold_left (fun (r : Rat) (a : A) => r + (f a)) ls init2).

  Lemma fold_add_body_eq : forall (ls : list A)(f1 f2 : A -> Rat) init1 init2,
    init1 == init2 ->
    (forall a, In a ls -> f1 a == f2 a) ->
    fold_left (fun r a => r + (f1 a)) ls init1 == fold_left (fun r a => r + (f2 a)) ls init2.

  Lemma fold_add_rat_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    forall init1 init2, 
      init1 == init2 ->
      (forall (a : A), In a ls1 -> (f1 a) == (f2 a)) ->
      fold_left (fun r a => r + (f1 a)) ls1 init1 == fold_left (fun r a => r + (f2 a)) ls2 init2.

  Lemma fold_add_f_inverse : forall (B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A) fa init1 init2,
    (init1 == init2) ->
    (forall a, In a ls -> f_inv (f a) = a) ->
    fold_left (fun r b => r + fa (f_inv b)) (map f ls) init1 ==
    fold_left (fun r a => r + (fa a)) ls init2.

   Lemma sumList_0 : forall (ls : list A) f,
    (sumList ls f == 0) <-> (forall a, In a ls -> (f a) == 0).

  Lemma sumList_nz : forall (ls : list A) f,
    (~sumList ls f == 0) <-> exists a : _, In a ls /\ (~f a == 0).

End SumList.

Lemma fold_add_init_0 : forall (A : Set)(ls : list A) f init,
  fold_left (fun r a => r + (f a)) ls init == init + fold_left (fun r a => r + (f a)) ls 0.

Lemma fold_add_eq_init : forall (A : Set)(ls : list A) init,
  fold_left (fun r a => r + 0) ls init == init.

Lemma fold_add_eq_init_f : forall (A : Set)(ls : list A) f init,
  (forall a, In a ls -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls init == init.

Lemma fold_add_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat) init1 init2,
  fold_left (fun r a => r + (f1 a)) ls init1 + 
  fold_left (fun r a => r + (f2 a)) ls init2 ==
  fold_left (fun r a => r + (f1 a + f2 a)) ls (init1 + init2).

Lemma fold_add_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  fold_left (fun r1 a => r1 + (fold_left (fun r2 b => r2 + (f a b)) lsb 0)) lsa 0  == 
  fold_left (fun r1 b => r1 + (fold_left (fun r2 a => r2 + (f a b)) lsa 0)) lsb 0.

Lemma sumList_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) == 
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma sumList_body_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a == f2 a) ->
  sumList ls f1 == sumList ls f2.

Lemma fold_add_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) init c,
  fold_left (fun r a => r + (f a) * c) ls (init * c) == 
  (fold_left (fun r a => r + (f a)) ls init) * c.
    
Lemma sumList_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) c,
  sumList ls (fun a => (f a) * c) == (sumList ls f) * c.
    
Lemma sumList_factor_constant_l:
  forall (A : Set) (ls : list A) (f : A -> Rat) (c : Rat),
    sumList ls (fun a : A => c * f a) == c * sumList ls f.

Lemma fold_add_body_const : forall (A : Set)(ls : list A) c init,
  fold_left (fun r a => r + c) ls init == c * (length ls / 1) + init.

Lemma sumList_body_const : forall (A : Set)(ls : list A) c,
  sumList ls (fun a => c) == c * (length ls / 1).

Lemma fold_add_iter_le : forall (A : Set)(ls : list A) f r init,
  fold_left (fun r a => r + (f a)) ls init <= r ->
  init <= r /\ 
  (forall a, In a ls -> f a <= r).

Lemma sumList_iter_le : forall (A : Set)(ls : list A) f r a,
  sumList ls f <= r ->
  In a ls ->
  f a <= r.

Fixpoint removeFirst(A : Set)(eqd : eq_dec A)(ls : list A) a :=
  match ls with
    | nil => nil
    | a' :: ls' =>
      if (eqd a a') then ls' else a' :: (removeFirst eqd ls' a)
  end.

Lemma removeFirst_permutation : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  In a ls ->
  Permutation ls (a :: (removeFirst eqd ls a)).

Lemma removeFirst_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  ~In a1 ls ->
  ~In a1 (removeFirst eqd ls a2).

Lemma removeFirst_NoDup_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a : A),
  NoDup ls ->
  ~In a (removeFirst eqd ls a).

Lemma removeFirst_NoDup : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  NoDup ls ->
  NoDup (removeFirst eqd ls a).

Lemma removeFirst_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a1 a2 : A),
  In a1 ls ->
  a1 <> a2 ->
  In a1 (removeFirst eqd ls a2).

Lemma removeFirst_in_iff : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  In a1 (removeFirst eqd ls a2) ->
  In a1 ls.

Fixpoint matchOrder (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) :=
  match ls1 with
    | nil => ls2
    | a :: ls1' => 
      a :: (matchOrder eqd ls1' (removeFirst eqd ls2 a))
  end.

Lemma matchOrder_In : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 <-> In a (matchOrder eqd ls1 ls2)).

Lemma matchOrder_not_in_h : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  ~In a ls1 -> 
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_not_in : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  (forall a, In a ls1 -> In a ls2) ->
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_NoDup : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  (forall a, In a ls1 -> In a ls2) ->
  NoDup ls2 ->
  NoDup ls1 ->
  NoDup (matchOrder eqd ls1 ls2).

Require Import Permutation.

Lemma matchOrder_permutation : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  Permutation ls2 (matchOrder eqd ls1 ls2).

Lemma matchOrder_firstn : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  firstn (length ls1) (matchOrder eqd ls1 ls2) = ls1.

Lemma fold_add_matchOrder : forall (A : Set)(ls : list A)(f : A -> Rat) n init1 init2,
  init1 == init2 ->
  NoDup ls ->
  (forall a, In a ls -> (~In a (firstn n ls)) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) (firstn n ls) init1 == fold_left (fun r a => r + (f a)) ls init2.

Lemma permutation_NoDup : forall (A : Type)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  NoDup ls1 ->
  NoDup ls2.

Lemma fold_add_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  sumList ls1 f == sumList ls2 f.

Fixpoint flatten(A : Type)(ls : list (list A)) :=
  match ls with
    | nil => nil
    | a :: ls' => a ++ (flatten ls')
  end.

Theorem in_flatten : forall (A : Set)(ls : list (list A)) a,
  In a (flatten ls) <->
  exists x : _, In x ls /\ In a x.

Theorem length_flatten_nz : forall (A : Type)(ls : list (list A)) ls',
  In ls' ls ->
  length ls' > 0 ->
  length (flatten ls) > 0.

Fixpoint getUnique(A : Set)(ls : list A)(pf : eq_dec A) : list A :=
  match ls with
    | nil => nil
    | a :: ls' => 
      let ls'' := (getUnique ls' pf) in
        if (in_dec pf a ls'') 
          then ls''
          else a :: ls''
  end.

Theorem in_getUnique_if : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a (getUnique ls eqd) ->
  In a ls.

Theorem in_getUnique : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a ls ->
  In a (getUnique ls eqd).

Lemma getUnique_NoDup : forall (A : Set)(ls : list A)(eqd: eq_dec A),
  NoDup (getUnique ls eqd).

Theorem length_getUnique_nz : forall (A :Set)(eqd : eq_dec A)(ls : list A),
  length ls > 0 ->
  length (getUnique ls eqd) > 0.

Definition maxList(ls : list nat) : nat :=
  fold_left max ls O.

Lemma fold_left_max_ge_init : forall (ls : list nat)(n : nat),
  fold_left max ls n >= n.

Lemma maxList_correct_h : forall (ls : list nat)(n init : nat),
  In n ls ->
  fold_left max ls init >= n.

Theorem maxList_correct : forall (ls : list nat) n,
  In n ls ->
  maxList ls >= n.

Inductive pred_count(A : Type)(p : A -> Prop) : list A -> nat -> Prop :=
  | pc_nil : 
    pred_count p nil 0
  | pc_yes : 
    forall ls n a,
    pred_count p ls n ->
    p a ->
    pred_count p (a :: ls) (S n)
  | pc_no : forall ls n a,
    pred_count p ls n ->
    ~p a ->
    pred_count p (a :: ls) n.

Lemma pred_count_le_length : forall (A : Type)(P : A -> Prop) ls c,
  pred_count P ls c ->
  (c <= length ls)%nat.

Fixpoint listRepeat(A : Type)(a : A) n :=
  match n with
    | 0 => nil
    | S n' => a :: (listRepeat a n')
  end.

Lemma listRepeat_length : forall n (A : Type) (a : A),
  length (listRepeat a n) = n.

Lemma pred_count_listRepeat_eq_inv : forall n (A : Type)(a : A) count,
  pred_count (eq a) (listRepeat a n) count ->
  count = n.

Lemma pred_count_listRepeat_ne_inv : forall n (A : Type)(a1 a2 : A) count,
  a1 <> a2 ->
  pred_count (eq a1) (listRepeat a2 n) count ->
  count = O.

Lemma pred_count_func : forall (A : Type)(P : A -> Prop)(ls : list A) n1 n2,
  pred_count P ls n1 ->
  pred_count P ls n2 ->
  n1 = n2.

Lemma pred_count_eq_all_inv : forall (A : Type)(ls : list A)(P : A -> Prop) c,
  pred_count P ls c ->
  (forall a, In a ls -> P a) ->
  c = length ls.

Lemma pred_count_first_skip : forall (A : Type)(P : A -> Prop)(ls : list A)(c : nat),
  pred_count P ls c ->
  forall n,
    exists c1 c2,
      pred_count P (firstn n ls) c1 /\
      pred_count P (skipn n ls) c2 /\
      (c1 + c2 = c)%nat.

Lemma pred_count_eq_all : forall (A : Type)(P : A -> Prop)(ls : list A) n,
  (forall a, In a ls -> P a) ->
  n = length ls ->
  pred_count P ls n.

Lemma pred_count_eq_none : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, In a ls -> ~P a) ->
  pred_count P ls 0.

Lemma in_listRepeat_inv : forall n (A : Type)(a1 a2 : A),
  In a1 (listRepeat a2 n) ->
  a1 = a2.

Lemma pred_count_app : forall (A : Type)(P : A -> Prop)(ls1 ls2 : list A) n1 n2,
  pred_count P ls1 n1 ->
  pred_count P ls2 n2 ->
  pred_count P (ls1 ++ ls2) (n1 + n2).

Lemma pred_count_permutation : forall (A : Set)(P : A -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall c, 
    pred_count P ls1 c ->
    pred_count P ls2 c.

Lemma pred_count_eq_none_inv : forall (A : Set)(P : A -> Prop)(ls : list A) c,
  pred_count P ls c ->
  (forall a, In a ls -> ~P a) ->
  c = O.

Lemma pred_count_eq_1_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> Prop)(ls : list A) c a,
  pred_count P ls c ->
  NoDup ls ->
  P a ->
  In a ls ->
  (forall a', In a' ls -> a <> a' -> ~P a') ->
  c = (S O).

Lemma pred_count_left_total : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, P a \/ ~P a) ->
  exists c, pred_count P ls c.

Inductive rel_map(A B : Type)(r : A -> B -> Prop) : list A -> list B -> Prop :=
| rm_nil : 
  rel_map r nil nil
| rm_step : 
  forall lsa lsb a b,
    rel_map r lsa lsb ->
    r a b ->
    rel_map r (a :: lsa) (b :: lsb).

Theorem rel_map_map2 : forall (A B C D : Type)(ls_c : list C)(ls_d: list D)(P : A -> B -> Prop)(f1 : C -> A)(f2 : D -> B),
  rel_map (fun a b => P (f1 a) (f2 b)) ls_c ls_d ->
  rel_map P (map f1 ls_c) (map f2 ls_d).

Lemma rel_map_length : forall (A B : Type)(lsa : list A)(P : A -> B -> Prop)(lsb : list B),
  rel_map P lsa lsb ->
  length lsa = length lsb.

Lemma rel_map_unary_pred : forall (A B : Type)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(P' : B -> Prop),
  rel_map P lsa lsb ->
  (forall a b, P a b -> P' b) ->
  forall b, In b lsb -> P' b.

Lemma rel_map_eq_inv : forall (A B : Type)(ls1 ls2 : list A)(rel1 rel2 : A -> B -> Prop) ls1' ls2',
  ls1 = ls2 ->
  (forall a b1 b2, rel1 a b1 -> rel2 a b2 -> b1 = b2) ->
  rel_map rel1 ls1 ls1' ->
  rel_map rel2 ls2 ls2' ->
  ls1' = ls2'.

Lemma rel_map_eq : forall (A B : Type)(ls1 : list A)(rel1 : A -> B -> Prop) ls',
  rel_map rel1 ls1 ls' ->
  forall ls2 (rel2 : A -> B -> Prop), 
    ls1 = ls2 ->
    (forall a b, In a ls1 -> In b ls' -> rel1 a b -> rel2 a b) ->
    rel_map rel2 ls2 ls'.

Theorem pred_count_eq_0 : forall (A B : Set)(ls : list B)(ls' : list A)(f : B -> A -> Prop)(P : A -> Prop) v,
  (forall a b, In b ls -> f b a -> ~ P a) ->
  rel_map f ls ls' ->
  pred_count P ls' v ->
  v = O.

Lemma rel_map_app_inv : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb : list B),
  rel_map rel (lsa1 ++ lsa2) lsb ->
  (rel_map rel lsa1 (firstn (length lsa1) lsb) /\ rel_map rel lsa2 (skipn (length lsa1) lsb)).

Lemma rel_map_map_inv : forall (A B C : Type)(rel : B -> C -> Prop)(f : A -> B)(lsa : list A)(lsc : list C),
  rel_map rel (map f lsa) lsc ->
  rel_map (fun a c => rel (f a) c) lsa lsc.

Lemma rel_map_listRepeat : forall (A B : Set)(lsa : list A)(rel : A -> B -> Prop) b,
  (forall a, In a lsa -> rel a b) ->
  rel_map rel lsa (listRepeat b (length lsa)).

Lemma rel_map_app : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
  rel_map rel lsa1 lsb1 ->
  rel_map rel lsa2 lsb2 ->
  rel_map rel (lsa1 ++ lsa2) (lsb1 ++ lsb2).

Lemma rel_map_map : forall (A B C : Type)(f : A -> B)(rel : B -> C -> Prop) lsa lsc,
  rel_map (fun a c => rel (f a) c) lsa lsc ->
  rel_map rel (map f lsa) lsc.

Lemma rel_map_inverse : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb -> 
  forall b, 
    In b lsb ->
    exists a, In a lsa /\ rel a b.

Lemma ne_all_not_in : forall (A : Type)(ls : list A) a,
  (forall a', In a' ls -> a <> a') ->
  ~In a ls.

Lemma rel_map_NoDup : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  NoDup lsa ->
  (forall a1 a2 b1 b2, In a1 lsa -> In a2 lsa -> a1 <> a2 -> rel a1 b1 -> rel a2 b2 -> b1 <> b2) ->
  NoDup lsb.

Lemma rel_map_in : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
  forall b a,
    In a lsa ->
    rel a b ->
    In b lsb.

Lemma rel_map_left_total : forall (A B : Type)(rel : A -> B -> Prop)(lsa : list A),
  (forall a, exists b, rel a b) ->
  exists lsb, rel_map rel lsa lsb.

Lemma rel_map_func : forall (A B : Type) (rel : A -> B -> Prop) lsa lsb1,
  rel_map rel lsa lsb1 ->
  forall lsb2,
    rel_map rel lsa lsb2 ->
    (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
    lsb1 = lsb2.

Lemma rel_map_permutation : forall (A B : Type) lsa1 lsa2,
  Permutation lsa1 lsa2 ->
  forall (rel : A -> B -> Prop),
    (forall a b1 b2, rel a b1 -> rel a b2 -> b1 = b2) ->
    (forall a, exists b, rel a b) ->
    forall lsb1 lsb2,
      rel_map rel lsa1 lsb1 ->
      rel_map rel lsa2 lsb2 ->     
      Permutation lsb1 lsb2.

Lemma rel_map_impl : forall (A B : Type)(rel1 rel2 : A -> B -> Prop) lsa lsb,
  rel_map rel1 lsa lsb ->
  (forall a b, In a lsa -> rel1 a b -> rel2 a b) ->
  rel_map rel2 lsa lsb.

Lemma rel_map_in_inv : forall (A B : Type)(rel : A -> B -> Prop) lsa lsb,
  rel_map rel lsa lsb ->
  forall a, In a lsa -> exists b, In b lsb /\ rel a b.

Inductive sumList_rel(A : Type)(rel : A -> Rat -> Prop) : list A -> Rat -> Prop :=
| slr_nil :
  forall r, 
    r == rat0 ->
    sumList_rel rel nil r
| slr_cons : 
  forall (ls : list A)(a : A) r1 r2 r3,
    sumList_rel rel ls r1 ->
    rel a r2 ->
    r3 == r2 + r1 ->
    sumList_rel rel (a :: ls) r3.

Lemma sumList_rel_distance : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r r1 r2,
  (forall a r1 r2, In a ls -> f1 a r1 -> f2 a r2 -> (ratDistance r1 r2) <= r) ->
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  ratDistance r1 r2 <= (r * (length ls / 1)).

Lemma sumList_rel_all_0_inv : forall (A : Set)(ls : list A)(r  : Rat)(rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a' v, In a' ls -> rel a' v -> v == 0) ->
  r == 0.

Lemma sumList_rel_only_one_inv : forall (A : Set)(rel : A -> Rat -> Prop)(ls : list A)(a : A) r r',
  sumList_rel rel ls r' ->
  In a ls ->
  NoDup ls -> 
  (forall a', In a' ls -> a <> a' -> forall v, rel a' v -> v == 0) ->
  (forall v, rel a v -> v == r) ->
  r' == r.

Lemma sumList_rel_body_eq : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma sumList_rel_plus_inv : forall (A : Type)(ls : list A) r (rel1 rel2 rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a r, In a ls -> rel a r -> forall r1 r2, rel1 a r1 -> rel2 a r2 -> r == r1 + r2) ->
  forall r1 r2, sumList_rel rel1 ls r1 -> sumList_rel rel2 ls r2 -> r == r1 + r2.

Lemma sumList_rel_left_total : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> exists r, rel a r) ->
  exists r, sumList_rel rel ls r.

Lemma sumList_rel_factor_constant : forall (p1 p2 : posnat) (A : Type)(rel : A -> Rat -> Prop)(ls : list A) r,
  sumList_rel (fun a r' => rel a (r' * (RatIntro p1 p2))) ls (r * (RatIntro p2 p1)) ->
  sumList_rel rel ls r.

Lemma sumList_rel_permutation : forall (A : Type)(rel : A -> Rat -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall r, 
    sumList_rel rel ls1 r ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_all_0 : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> rel a 0) ->
  sumList_rel rel ls 0.

Lemma sumList_rel_ls_intersect: forall (A : Set)(rel : A -> Rat -> Prop)(ls1 : list A) r,
  sumList_rel rel ls1 r ->
  forall ls2, 
    NoDup ls1 ->
    NoDup ls2 ->
    eq_dec A ->
    (forall a r1 r2, In a ls1 -> rel a r1 -> rel a r2 -> r1 == r2) -> 
    (forall a, In a ls1 -> ~In a ls2 -> rel a 0) ->
    (forall a, In a ls2 -> ~In a ls1 -> rel a 0) ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_sumList : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a = r) ls
  (sumList ls f).

Lemma sumList_cons : forall (A : Set)(ls : list A) a f,
  sumList (a :: ls) f == f a + (sumList ls f).

Lemma sumList_sum : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  sumList ls (fun a => f1 a + f2 a) ==
  sumList ls f1 + sumList ls f2.

Lemma sumList_summation : forall (A B : Set) f (lsa : list A)(lsb : list B),
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) ==
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma fold_add_subset' : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 -> (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset'
  : forall A : Set,
    eq_dec A ->
    forall (ls1 ls2 : list A) (f : A -> Rat),
      NoDup ls1 ->
      NoDup ls2 ->
      (forall a : A, In a ls1 -> In a ls2) ->
      (forall a : A, In a ls2 -> ~ In a ls1 -> f a == 0) ->
      sumList ls1 f == sumList ls2 f.

Lemma sumList_exactly_one : forall (A : Set) a (ls : list A) f,
  NoDup ls ->
  In a ls ->
  (forall b, In b ls -> a <> b -> f b == 0) ->
  sumList ls f == f a.

Lemma fold_add_permutation : forall (A : Set) ls1 ls2,
  Permutation ls1 ls2 ->
  forall (f : A -> Rat) init1 init2,
    init1 == init2 ->
    fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_permutation : forall (A : Set)(f : A -> Rat) ls1 ls2,
  Permutation ls1 ls2 ->
  sumList ls1 f == sumList ls2 f.

Lemma sumList_rel_body_eq_strong : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', In a ls1 -> rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma rel_map_left_total_strong' : forall (A B : Type)(lsa : list A)(P : A -> Prop)(rel : A -> B -> Prop),
  (forall a, P a -> exists b, rel a b) ->
  (forall a, In a lsa -> P a) ->
  exists lsb, rel_map rel lsa lsb.

Lemma firstn_eq_all_gen : forall (A : Type)(ls : list A) n,
  n = length ls ->
  firstn n ls = ls.

Fixpoint getNats s n :=
  match n with 
    | O => nil
    | S n' => (s + n')%nat :: (getNats s n')
  end.

Lemma ratMult_sumList_rel_distrib : forall (A : Set)(ls : list A) f (x : Rat -> Prop) x' a,
  sumList_rel f ls a ->
  (forall i v1 v2, f i v1 -> f i v2 -> v1 == v2) ->
  (forall x1 x2, x x1 -> x x2 -> x1 == x2) ->
  x x' -> 
  sumList_rel (fun i => ratMult_rel x (f i)) ls (x' * a).

Lemma series_le : forall n (f1 f2 : nat -> Rat -> Prop) r1 r2,
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->
  sumList_rel f1 (getNats O n) r1 ->
  sumList_rel f2 (getNats O n) r2 ->
  r2 <= r1.

Lemma ratSubtract_series_map : forall n f1 f2 a1 a2,
  n > 0 ->
  sumList_rel f1 (getNats O n) a1 ->
  sumList_rel f2 (getNats O n) a2 ->
  (forall i x1 x2, f1 (S i) x1 -> f2 i x2 -> x1 == x2) ->
  (forall i v1 v2, f1 i v1 -> f1 i v2 -> v1 == v2) ->
  (forall i v1 v2, f2 i v1 -> f2 i v2 -> v1 == v2) ->
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->  
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f1 i1 v1 -> f1 i2 v2 -> v2 <= v1) ->
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f2 i1 v1 -> f2 i2 v2 -> v2 <= v1) ->
  forall x1 x2,
    f1 O x1 -> f2 (pred n) x2 ->
    ratSubtract a1 a2 == ratSubtract x1 x2.

Lemma sum_power_series : forall n (f : Rat -> Prop) a a',
  n > 0 ->
  (exists v, f v) ->
  (forall v1 v2, f v1 -> f v2 -> v1 == v2) ->
  (forall v, f v -> ~1 <= v) ->
  sumList_rel (fun i : nat => expRat_rel f i) (getNats 0 n) a ->
  ratMult_rel (ratSubtract_rel (eqRat 1) (expRat_rel f n))
         (ratInverse_rel (ratSubtract_rel (eqRat 1) f)) a' ->
         a == a'.

Lemma sumList_rel_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r1 r2,
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  (forall a v1 v2, In a ls -> f1 a v1 -> f2 a v2 -> v1 <= v2) ->
  r1 <= r2.

Lemma sumList_filter_le : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool),
  sumList (filter P ls) f <= sumList ls f.

Lemma sumList_filter_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f == (sumList (filter P ls) f + (sumList (filter (fun a => negb (P a)) ls) f)).

Lemma sumList_rel_sumList_eqRat : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a == r) ls
  (sumList ls f).

Lemma sumList_series_incr : forall n2 n1 (f f' : nat -> Rat),
  (forall n, (f n) == (f' (S n))) ->
  sumList (getNats n1 n2) f == sumList (getNats (S n1) n2) f'.

Lemma sumList_series_split_first : forall n f, 
  sumList (n :: getNats O n) f == f O + (sumList (getNats 1 n) f).

Lemma firstn_nil : forall (A : Set) n, 
  firstn n nil = (@nil A).

Lemma firstn_ge_all : forall n (A : Set) (ls : list A),
  n >= length ls ->
  firstn n ls = ls.

Lemma firstn_app : forall n (A : Set) (ls1 ls2 : list A),
  (n <= length ls1)%nat ->
  firstn n (ls1 ++ ls2) = firstn n ls1.

Lemma sumList_rel_func : forall (A : Set)(f : A -> Rat -> Prop) ls r1,
  sumList_rel f ls r1 ->
  forall r2,
  sumList_rel f ls r2 ->
  (forall a v1 v2, f a v1 -> f a v2 -> v1 == v2) ->
  r1 == r2.

Lemma sumList_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f ==
  sumList ls (fun a => (f a) * (if (P a) then 1 else 0)) + 
  sumList ls (fun a => (f a) * (if (P a) then 0 else 1)).

Lemma sumList_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a <= f2 a) ->
  sumList ls f1 <= sumList ls f2.

Lemma sumList_distance_prod : forall (A : Set)(ls : list A)(f f1 f2 : A -> Rat),
  | (sumList ls (fun a => (f a) * (f1 a))) - (sumList ls (fun a => (f a) * (f2 a))) | <= sumList ls (fun a => (f a) * | (f1 a) - (f2 a) |).

Theorem sumList_all : 
  forall (A : Set)(ls : list A)(f : A -> Rat) c,
    (forall a, In a ls -> (f a) == c) ->
    sumList ls f == (length ls)/1 * c.

Theorem filter_app : 
  forall (A : Set)(ls1 ls2 : list A)(f : A -> bool),
    filter f (ls1 ++ ls2) = filter f ls1 ++ filter f ls2.

Theorem filter_true : 
  forall (A : Set)(ls : list A)(f : A -> bool),
    (forall a, In a ls -> (f a) = true) ->
    filter f ls = ls.

Theorem sumList_subset_le : 
  forall (A : Set){eqd: EqDec A}(ls1 ls2 : list A)(f : A -> Rat),
    NoDup ls1 ->
    NoDup ls2 ->
    (forall a, In a ls1 -> In a ls2) ->
    sumList ls1 f <= sumList ls2 f.

Fixpoint allNatsLt (n : nat) :=
  match n with
    | 0 => nil
    | S n' => allNatsLt n' ++ (n' :: nil)
  end.

Lemma allNatsLt_length : 
  forall n, 
    length (allNatsLt n) = n.

Lemma allNatsLt_lt : 
  forall n v,
    In v (allNatsLt n) ->
    v < n.

Lemma app_NoDup : forall(A : Set)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> ~In a ls2) ->
  (forall a, In a ls2 -> ~In a ls1) ->
  NoDup (ls1 ++ ls2).

Lemma allNatsLt_NoDup : 
  forall (n : nat),
    NoDup (allNatsLt n).

Lemma allNatsLt_lt_if : 
  forall (n i : nat), 
    i < n ->
    In i (allNatsLt n).

Lemma nth_allNatsLt_lt : 
  forall k n,
    n < k ->
    nth n (allNatsLt k) n = n.

Lemma nth_allNatsLt : 
  forall k n,
    nth n (allNatsLt k) n = n.

Theorem allNatsLt_filter_lt : 
  forall (p n : nat),
    (n <= p)%nat->
    filter (fun z => if (lt_dec z n) then true else false) (allNatsLt p) = 
    allNatsLt n.

Theorem map_eq_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    map f1 ls = map f2 ls ->
    (forall a, In a ls -> f1 a = f2 a).

Theorem map_eq_if_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    (forall a, In a ls -> f1 a = f2 a) ->
    map f1 ls = map f2 ls.

Theorem map_eq_subset : 
  forall (A B : Type)(ls2 ls1 : list A)(f1 f2 : A -> B),
    map f1 ls1 = map f2 ls1 ->
    (forall a, In a ls2 -> In a ls1) ->
    map f1 ls2 = map f2 ls2.

Fixpoint getSomes(A : Type)(ls : list (option A)) :=
  match ls with
    | nil => nil
    | o :: ls' =>
      match o with
        | None => getSomes ls'
        | Some x => x :: (getSomes ls')
      end
  end.

Lemma nth_nil:
  forall (A : Set)(i : nat)(def : A),
    nth i nil def = def.

Theorem listReplace_None_Permutation : 
  forall (A : Set) n ls (y : A),
    nth n ls None = None ->
    Permutation (getSomes (listReplace ls n (Some y) None)) (y :: (getSomes ls)).

Theorem listReplace_getSomes_Permutation_h : 
  forall (A : Set) l1' l2,
    Permutation l1' l2 ->
    forall l1 n2 (y : A),
      l1' = getSomes l1 ->
      nth n2 l1 None = None ->
      Permutation
        (getSomes
           (listReplace l1 n2
                        (Some y) None))
        (y :: l2).

Theorem listReplace_getSomes_Permutation : 
  forall (A : Set) l1 l2 n2 (y : A),
    nth n2 l1 None = None ->
    Permutation (getSomes l1) l2 ->
    Permutation
      (getSomes
         (listReplace l1 n2
                      (Some y) None))
      (y :: l2).

Lemma nth_listReplace_ne : 
  forall (i1 i2 : nat)(A : Set)(ls : list A)(a def : A),
    i1 <> i2 ->
    nth i1 (listReplace ls i2 a def) def = 
    nth i1 ls def.

Theorem listReplace_length :
  forall (A : Set)(ls : list A)(i : nat)(a def : A),
    i < length ls ->
    length (listReplace ls i a def) = length ls.

Lemma listReplace_in_nil : 
  forall (A : Set)(i : nat)(a1 a2 def : A),
    In a1 (listReplace nil i a2 def) ->
    a1 = a2 \/ a1 = def.

Lemma listReplace_in : 
  forall (A : Set)(ls : list A)(a1 a2 def : A)(i : nat),
    In a1 (listReplace ls i a2 def) ->
    (In a1 ls \/ a1 = a2 \/ a1 = def).

Theorem firstn_map : 
  forall (A B : Set)(f : A -> B)(ls : list A) n,
    firstn n (map f ls) = map f (firstn n ls).

Lemma firstn_app_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    firstn (length ls1) (ls1 ++ ls2) = ls1.

Theorem map_nth_in : 
  forall (A B : Set)(ls : list A)(f : A -> B) i defa defb,
    i < length ls ->
    nth i (map f ls) defb = f (nth i ls defa).

Lemma flatten_app : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    flatten (ls1 ++ ls2) = flatten ls1 ++ flatten ls2.

Inductive list_pred(A B : Set)(pred : A -> B -> Prop) : list A -> list B -> Prop :=
| list_pred_nil : 
    list_pred pred nil nil
| list_pred_cons : 
    forall a1 a2 ls1 ls2,
      pred a1 a2 ->
      list_pred pred ls1 ls2 ->
      list_pred pred (a1 :: ls1) (a2 :: ls2).

Lemma list_pred_eq_impl_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    list_pred eq ls1 ls2 ->
    ls1 = ls2.

Lemma flatten_eq : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred eq ls1 ls2 ->
    flatten ls1 = flatten ls2.

Theorem app_cons_eq : 
  forall (A : Type) ls2 ls1 (a : A),
    ls2 ++ (a :: ls1) = (ls2 ++ (a :: nil)) ++ ls1.

Theorem skipn_nil : 
  forall (A : Type) n,
    skipn n (@nil A) = nil.

Theorem nth_In_exists : 
  forall (A : Type)(ls : list A) a def,
    In a ls ->
    exists n, nth n ls def = a.

Theorem nth_skipn_eq : 
  forall (A : Set)(y x: nat)(ls : list A)(def : A),
    nth x (skipn y ls) def = nth (x + y) ls def.

Theorem perm_flatten_listReplace_nil : 
  forall b (A : Set)(a : A),
    Permutation (flatten (listReplace nil b (a :: nil) nil)) (a :: nil).

Theorem perm_flatten_listReplace : 
  forall b (A : Set)(ls1 : list (list A))(ls2 : list A) (a : A),
    Permutation (flatten ls1) ls2 ->
    Permutation (flatten (listReplace ls1 b (nth b ls1 nil ++ (a :: nil)) nil))
                (a :: ls2).

Theorem map_cons : 
  forall (A B : Type)(f : A -> B)(ls : list A)(a : A),
    map f (a :: ls) = (f a) :: map f ls.

Theorem app_eq_inv : 
  forall (A : Type)(ls1 ls2 ls3 ls4 : list A),
    length ls1 = length ls3 ->
    (ls1 ++ ls2) = (ls3 ++ ls4) ->
    ls1 = ls3 /\ ls2 = ls4.

Theorem NoDup_app : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1 /\
    NoDup ls2 /\
    (forall a1 a2,
       In a1 ls1 ->
       In a2 ls2 ->
       a1 <> a2).

Theorem firstn_In : 
  forall (A : Type) n (ls : list A)(a : A),
             In a (firstn n ls) ->
             In a ls.

Theorem pred_firstn_In :
  forall (A : Set) ls1 ls2,
    list_pred (fun x0 y : list A => exists n : nat, y = firstn n x0) ls1 ls2 ->
    forall a,
      In a (flatten ls2) -> In a (flatten ls1).

Theorem firstn_NoDup : 
  forall (A : Type) n (ls : list A),
    NoDup ls ->
    NoDup (firstn n ls).
 
Theorem NoDup_flatten_subset : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred (fun x y => exists n, y = firstn n x) ls1 ls2 ->
    NoDup (flatten ls1) ->
    NoDup (flatten ls2).

Theorem allNatsLt_nil_inv :
  forall n,
    allNatsLt n = nil ->
    n = O.
  
Theorem firstn_allNatsLt_h : 
  forall ls n1 n2,
    n2 >= n1 ->
    ls = (allNatsLt n2) ->
    firstn n1 ls = allNatsLt n1.

Theorem firstn_allNatsLt : 
  forall n1 n2,
    n2 >= n1 ->
    firstn n1 (allNatsLt n2) = allNatsLt n1.

Theorem NoDup_app_l : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1.

Theorem NoDup_map : 
  forall (A B : Type)(f : A -> B)(ls : list A),
    NoDup (map f ls) ->
    (NoDup ls /\ (forall b1 b2, In b1 ls -> In b2 ls -> f b1 = f b2 -> b1 = b2)).

Theorem map_fst_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (fst x)) (combine ls lsc).

Theorem map_snd_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (snd x)) (combine lsc ls).

Theorem In_combine_NoDup_eq_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a1 a2 b,
    NoDup lsb ->
    In (a1, b) (combine lsa lsb) ->
    In (a2, b) (combine lsa lsb) ->
    a1 = a2.

Theorem In_combine_NoDup_eq_r : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a b1 b2,
    NoDup lsa ->
    In (a, b1) (combine lsa lsb) ->
    In (a, b2) (combine lsa lsb) ->
    b1 = b2.

Theorem zip_eq_nil_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = nil ->
    length lsa = length lsb ->
    lsa = nil.

Theorem fst_split_app_eq : 
  forall (A B : Type)(ls1 ls2 : list (A * B)),
    fst (split (ls1 ++ ls2)) = 
    fst (split ls1) ++ fst (split ls2).

Theorem fst_split_flatten_eq : 
  forall (A B : Type)(ls : list (list (A * B))),
    fst (split (flatten ls)) = 
    flatten (map (fun x => fst (split x)) ls).

Theorem fst_split_map_eq : 
  forall (A B C : Type)(ls : list A)(f : A -> B * C),
    fst (split (map f ls)) = 
    map (fun a => fst (f a)) ls.

Theorem in_split_l_if : 
  forall (A B : Type)(ls : list (A * B)) a,  
    In a (fst (split ls)) -> 
    exists b,
      In (a, b) ls.

Theorem in_fst_split_if : 
  forall (A B : Type)(ls : list (A * B)) a b,
    In (a, b) ls ->
    In a (fst (split ls)).

Theorem map_pair_fst_eq : 
  forall (A B C D: Type)(f1 : B -> D)(f2 : C -> D)(ls1 : list B)(ls2 : list C)(a1 a2 : A),
    map (fun x => (a1, f1 x)) ls1 = map (fun x => (a2, f2 x)) ls2 ->
    ls1 <> nil ->
    a1 = a2.

Theorem In_zip_strong : 
  forall (A B : Set)(ls : list A) f a (b : B),
    In (a, b) (zip ls (map f ls)) ->
    (In a ls /\ b = f a).

Lemma list_pred_impl : 
  forall (A B : Set)(lsa : list A)(lsb : list B) (P1 : A -> B -> Prop),
       list_pred P1 lsa lsb ->
       forall (P2 : A -> B -> Prop), 
         (forall a b, P1 a b -> P2 a b) ->
         list_pred P2 lsa lsb.

Theorem list_pred_eq_in : 
  forall (A : Set)(ls : list A),
    list_pred (fun a b => a = b /\ In a ls /\ In b ls) ls ls.

Theorem zip_combine_eq : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = combine lsa lsb.

Theorem list_pred_fst_split_eq : 
  forall (A B C : Set)(ls1 : list (A * B))(ls2 : list (A * C)),
    list_pred (fun a b => fst a = fst b) ls1 ls2 ->
    fst (split ls1)  = fst (split ls2).

Theorem unzip_eq_split : 
  forall (A B : Set)(ls : list (A * B)),
    unzip ls = split ls.

Theorem in_split_r_if:
  forall (A B : Type) (ls : list (A * B)) (b : B),
    In b (snd (split ls)) -> exists a : A, In (a, b) ls.

Fixpoint nth_option(A : Set)(ls : list A)(i : nat) :=
  match ls with 
    | nil => None
    | a :: ls' =>
      match i with
        | O => Some a
        | S i' =>
          nth_option ls' i'
          end
  end.

Theorem nth_option_app_Some : 
  forall (A : Set)(ls1 ls2 : list A) i a,
    nth_option ls1 i = Some a ->
    nth_option (ls1 ++ ls2) i = Some a.

Theorem nth_option_Some_lt : 
  forall (A : Set)(ls : list A) i a,
    nth_option ls i = Some a ->
    i < length ls.

Theorem nth_option_app_None : 
  forall (A : Set)(ls1 ls2 : list A) i,
    nth_option ls1 i = None ->
    nth_option (ls1 ++ ls2) i = nth_option ls2 (i - length ls1).

Theorem nth_option_None_ge : 
  forall (A : Set)(ls : list A) i,
    nth_option ls i = None ->
    i >= length ls.

Theorem skipn_S_eq : 
  forall (A : Set)(ls : list A) n a,
    nth_option ls n = Some a -> 
    skipn n ls = a :: (skipn (S n) ls).

Theorem nth_option_snd_split : 
  forall (A B : Set)(ls : list (A * B)) n a b,
    nth_option ls n = Some (a, b) ->
    nth_option (snd (split ls)) n = Some b.

Theorem snd_split_map_eq :
  forall (A B C : Set)(ls : list A)(f : A -> B * C),
    snd (split (map f ls)) =
    map (fun p => snd (f p)) ls.

Theorem cons_ne : 
  forall (A : Set)(eqda : eq_dec A)(a1 a2 : A)(ls1 ls2 : list A),
    ((a1 :: ls1) = (a2 :: ls2) -> False) ->
    (a1 <> a2) \/ (ls1 <> ls2).

Theorem map_ne_same_ex : 
  forall (A B : Set)(f1 f2 : A -> B)(ls : list A),
    eq_dec B ->
    map f1 ls <> map f2 ls ->
    exists a, In a ls /\ f1 a <> f2 a.

Theorem list_pred_I_in : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    list_pred (fun a b => In a lsa /\ In b lsb) lsa lsb.

Theorem list_pred_fst_split_eq_l : 
  forall (A B : Set)(a : list (A * B))(b : list A),
    list_pred (fun a0 b0 => fst a0 = b0) a b ->
    b = fst (split a).

Theorem list_pred_fst_split_flatten_eq_l : 
  forall (A B : Set)(a : list (list (A * B)))(b : list (list A)),
    list_pred
      (list_pred
         (fun a0 b0 => fst a0 = b0)) a b ->
    flatten b = fst (split (flatten a)).

Theorem fold_add_const_mult : 
  forall (A : Type)(ls : list A)(c : nat) init,
    (fold_left (fun acc _ => acc + c) ls init = 
     (length ls) * c + init)%nat.

Theorem list_pred_snd_split_eq_l:
  forall (A B : Set) (a : list (B * A)) (b : list A),
    list_pred (fun (a0 : B * A) (b0 : A) => snd a0 = b0) a b ->
    b = snd (split a).

Theorem NoDup_snd_split_if : 
  forall (A B : Type)(ls : list (A * B)),
    NoDup (snd (split ls)) ->
    NoDup ls.

Fixpoint forNats(n : nat) :=
  match n with
      | 0 => nil
      | S n' =>
        cons n' (forNats n')
  end.

Lemma forNats_In : 
  forall n i,
    i < n <->
    In i (forNats n).

Lemma forNats_NoDup : 
  forall n,
    NoDup (forNats n).

Lemma forNats_length : 
  forall n,
    length (forNats n) = n.

Lemma sumList_forNats_first_ls : 
  forall (n : nat)(f : nat -> Rat),
    n <> O ->
    f O <= sumList (forNats n) f.

Lemma sumList_forNats_distance : 
  forall (n : nat)(f : nat -> Rat), 
    (| sumList (forNats n) f - sumList (forNats n) (fun i => f (S i)) |) == (| (f O) - (f n) |).

Lemma flatten_map_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    flatten (map (fun a => (f a) :: nil) ls) =
    map f ls.

Lemma app_NoDup_inv : 
    forall (A : Set)(ls1 ls2 : list A), 
      NoDup (ls1 ++ ls2) ->
      (forall a, In a ls1 -> In a ls2 -> False).

Lemma flatten_NoDup : 
  forall (A : Set)(ls : list (list A)),
    NoDup ls ->
    (forall x, In x ls -> NoDup x) ->
    (forall x1 x2, In x1 ls -> In x2 ls -> x1 <> x2 -> NoDup (x1 ++ x2)) ->
    NoDup (flatten ls).

Lemma map_NoDup'
: forall (A B : Set) (ls : list A) (f : A -> B),
    NoDup ls ->
    (forall a1 a2 : A, In a1 ls -> In a2 ls ->a1 <> a2 -> f a1 <> f a2) -> 
    NoDup (map f ls).

Lemma getUnique_cons : 
  forall (A : Set)(eqd : eq_dec A)(ls2 ls1 : list A) a,
    a :: ls1 = (getUnique ls2 eqd) ->
    exists ls3 ls4, 
      ls2 = ls3 ++ (a :: ls4) /\
      ls1 = (getUnique ls4 eqd).

Lemma getUnique_eq_inv : 
  forall (A : Set)(a : A)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
    getUnique ls1 eqd1 = getUnique ls2 eqd2 ->
    In a ls1 -> 
    In a ls2.

Lemma sumList_app :
  forall (A : Set)(ls1 ls2 : list A)(f : A -> Rat),
    sumList (ls1 ++ ls2) f == (sumList ls1 f) + (sumList ls2 f).

Lemma filter_all_true : 
  forall (A : Set)(ls : list A)(P : A -> bool), 
    (forall a, In a ls -> P a = true) ->
    filter P ls = ls.

Lemma sumList_map : 
  forall (A B : Set)(ls : list A)(f1 : A -> B)(f : B -> Rat),
    sumList (map f1 ls) f == 
    sumList ls (fun a => f (f1 a)).

Lemma sumList_filter_twice : 
  forall (A B : Set)(P : A -> bool)(ls : list A)(lsf : A -> list B)(f : A * B -> Rat),
    sumList (filter (fun p => P (fst p)) (flatten (map (fun a => map (fun b => (a, b)) (lsf a)) ls))) f ==  
    sumList (filter P ls) (fun a => sumList (lsf a) (fun b => f (a, b))).

Lemma filter_cons : 
  forall (A : Set)(P : A -> bool)(ls : list A) a,
    filter P (a :: ls) = 
    if (P a) then (a :: (filter P ls)) else (filter P ls).

Theorem sumList_1_mult : 
  forall (A : Set)(ls : list A),
    sumList ls (fun _ => 1) == length ls / 1.

Theorem fold_left_orb_true_init : 
  forall (A : Type)(f : A -> bool)(ls : list A),
    fold_left (fun b x => orb b (f x)) ls true = true.

Theorem fold_left_orb_true_in : 
  forall (A : Type)(f : A -> bool)(ls : list A) a init,
    In a ls ->
    f a = true ->
    fold_left (fun b x => orb b (f x)) ls init = true.

Theorem hd_error_Some_In : 
  forall (A : Type)(ls : list A) a,
    hd_error ls = Some a ->
    In a ls.

Theorem fold_and_false_init :
  forall (A : Type)(ls : list A) P,
    fold_left (fun b z => b && negb (P z)) ls false = false.

Theorem hd_filter_false_eq_and_false : 
  forall (A : Type)(ls : list A)(P : A -> bool),
    (if hd_error (filter P ls) then false else true) =
    fold_left (fun (b : bool) (z : A) => b && negb (P z)) ls true.

Theorem fst_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (A * B))(ls2 : list A),
    list_pred (fun a b => fst a = b) ls1 ls2 ->
    fst (split ls1) = ls2.

Theorem snd_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (B * A))(ls2 : list A),
    list_pred (fun a b => snd a = b) ls1 ls2 ->
    snd (split ls1) = ls2.

Theorem combine_map_eq : 
  forall (A B C : Type)(lsa : list A)(lsb : list B)(f : B -> C),
    combine lsa (map f lsb) = map (fun p => (fst p, f (snd p))) (combine lsa lsb).

Theorem map_ext_pred : 
  forall (A B C : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> C),
    list_pred P lsa lsb ->
    (forall a b, P a b -> (f1 a) = (f2 b)) ->
    map f1 lsa = map f2 lsb.

Theorem list_pred_combine_l_h : 
  forall (A C : Set)(lsa : list A)(lsc : list C) P1,
    list_pred P1 lsa lsc ->
    forall (B : Set)(lsb : list B) P2, 
      list_pred P2 lsb lsc ->
      list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Theorem list_pred_combine_l : 
  forall (A B C : Set)P1 P2 (lsa : list A)(lsb : list B)(lsc : list C),
    list_pred P1 lsa lsc -> 
    list_pred P2 lsb lsc ->
    list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Lemma list_pred_symm : 
  forall (A B : Set)(P : A -> B -> Prop) lsa lsb,
    list_pred (fun b a => P a b) lsb lsa ->
    list_pred P lsa lsb.

Theorem list_pred_combine_r
: forall (A B C : Set) (P1 : A -> B -> Prop) (P2 : A -> C -> Prop)
         (lsa : list A) (lsb : list B) (lsc : list C),
    list_pred P1 lsa lsb ->
    list_pred P2 lsa lsc ->
    list_pred (fun a p => P1 a (fst p) /\ P2 a (snd p))
              lsa (combine lsb lsc). *)

Require Import Permutation.

Require Import Omega.



Local Open Scope list_scope. 

Local Open Scope comp_scope.



Inductive comp_state(A : Set) :=

  | cs_done : A -> Blist -> comp_state A

  | cs_eof : comp_state A

  | cs_more : Comp A -> Blist -> comp_state A.



Inductive comp_answer(A : Set) :=

  | ca_done : A -> comp_answer A

  | ca_eof : comp_answer A.



Lemma comp_answer_eq_dec : forall (A : Set),

      eq_dec A ->

      eq_dec (comp_answer A).



  intuition.

  unfold eq_dec in *.

  intuition.

  destruct a1; destruct a2.

  destruct (H a a0); subst.

  left.

  trivial.

  right.

  intuition.

  inversion H0; clear H0; subst.

  intuition.

  right; intuition; discriminate.

  right; intuition; discriminate.

  left.

  trivial.

Qed.



Fixpoint evalDet_step(A : Set)(c : Comp A)(s : Blist) : comp_state A :=

  match c in Comp A return comp_state A with

    | Ret pf a => cs_done a s

    | Rnd n  => 

      match (shiftOut s n) with

        | Some (v, s') => cs_more (Ret (@Bvector_eq_dec n) v) s'

        | None => (@cs_eof (Bvector n))

      end

    | Bind c1 c2 =>     

      match (evalDet_step c1 s) with

        | cs_eof _ => (@cs_eof _)

        | cs_done b s' => cs_more (c2 b) s'

        | cs_more c1' s' => cs_more (Bind c1' c2) s'

      end

    | Repeat c P =>

      cs_more (Bind c (fun a => if (P a) then (Ret (comp_eq_dec c) a) else (Repeat c P))) s

   end.



Inductive evalDet_steps(A : Set) : comp_state A -> comp_state A -> Prop :=

  | evalDet_steps_refl : forall ans,

    evalDet_steps ans ans

  | evalDet_steps_step : 

    forall c s ans ans',

      (evalDet_step c s) = ans ->

      evalDet_steps ans ans' ->

      evalDet_steps (cs_more c s) ans'.



Hint Constructors evalDet_steps : evalDet.



Inductive evalDet(A : Set)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=

  | evalDet_done : forall a s',

    evalDet_steps (cs_more c s) (cs_done a s') ->

    evalDet c s (ca_done a)

  | evalDet_eof :

    evalDet_steps (cs_more c s) (@cs_eof A) ->

    evalDet c s (@ca_eof A).

    

Theorem evalDet_steps_trans : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall z, 

  evalDet_steps y z ->

  evalDet_steps x z.



  induction 1; intuition; subst.

  econstructor.

  trivial.

  eapply IHevalDet_steps.

  trivial.



Qed.



Theorem evalDet_steps_bind_more_h : forall(A B : Set) x y,

  evalDet_steps x y ->

  forall (c1 : Comp B)(c2 : B -> Comp A) s c1' s',

  x = (cs_more c1 s) ->

  y =  (cs_more c1' s') ->

  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').



  induction 1; intuition; subst.



  Ltac evalDet_tac1 :=

    match goal with

      | [H : cs_more _ _ = cs_more _ _ |- _ ] => inversion H; clear H; subst

      | [|- evalDet_steps ?c ?c ] => econstructor

      | [H : evalDet_steps (evalDet_step ?c ?s) _ |- evalDet_steps (cs_more (Bind ?c _) ?s) _ ] => inversion H; clear H; subst

      | [H : (evalDet_step ?c ?s) = _ |- evalDet_steps (cs_more (Bind ?c _) ?s) _ ] => econstructor; simpl

      | [|- context[match ?x with | cs_done _ _ => _ | cs_eof _ => _ | cs_more _ _ => _ end] ] => case_eq x; intuition



    end.



  repeat evalDet_tac1.



  inversion H0; clear H0; subst.

  inversion H1; clear H1; subst.

  econstructor.

  eauto.

  simpl.

  rewrite H3.

  econstructor.



  inversion H1; clear H1; subst.

  econstructor.

  eauto.

  simpl.

  rewrite <- H.

  eapply IHevalDet_steps.

  auto.

  trivial.



Qed.



Theorem evalDet_steps_bind_more : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s c1' s',

  evalDet_steps (cs_more c1 s) (cs_more c1' s') ->

  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').



  intuition.

  eapply evalDet_steps_bind_more_h; eauto.

Qed.



Lemma evalDet_steps_done_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A)(a : A) s s',

  x = (cs_more c s) -> 

  y = (cs_done a s') ->

  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').



  induction 1; intuition; subst.

  discriminate.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor. econstructor.

  intuition.

  

  destruct (IHevalDet_steps c a s s'); eauto.

  destruct H0; intuition.

  exists x.

  exists x0.

  intuition.

  symmetry in H.

  econstructor.

  eapply H.

  trivial.

Qed.



Lemma evalDet_steps_done_inv : forall (A : Set)(c : Comp A)(a : A) s s',

  evalDet_steps (cs_more c s) (cs_done a s') ->

  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').



  intuition.

  eapply evalDet_steps_done_inv_h; eauto.

Qed.



Lemma evalDet_steps_eof_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) s,

  x = (cs_more c s) -> 

  y = (@cs_eof A) ->

  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).



  induction 1; intuition; subst.

  discriminate.

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor. econstructor.

  intuition.

  

  destruct (IHevalDet_steps c s); eauto.

  destruct H0; intuition.

  exists x.

  exists x0.

  intuition.

  econstructor.

  rewrite <- H.

  eauto.

  rewrite <- H.

  trivial.

Qed.



Lemma evalDet_steps_eof_inv : forall (A : Set)(c : Comp A) s,

  evalDet_steps (cs_more c s) (@cs_eof A) ->

  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).



  intuition.

  eapply evalDet_steps_eof_inv_h; eauto.

Qed.



Theorem evalDet_steps_bind_done : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a s s',

  evalDet_steps (cs_more c1 s) (cs_done a s') ->

  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (c2 a) s').



  intuition.

  apply evalDet_steps_done_inv in H.

  destruct H.

  destruct H.

  intuition.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_more.

  eauto.

  econstructor.

  simpl.

  rewrite H1.

  eauto.

  econstructor.

Qed.



Theorem evalDet_bind_eof : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,

  evalDet_steps (cs_more c1 s) (@cs_eof B) ->

  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A).



  intuition.

  apply evalDet_steps_eof_inv in H.

  destruct H.

  destruct H.

  intuition.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_more.

  eauto.

  econstructor.

  simpl.

  rewrite H1.

  eauto.

  econstructor.

Qed.



Inductive comp_state_eq(A : Set) : comp_state A -> comp_state A -> Prop :=

  | cse_done : 

    forall a s, 

      comp_state_eq (cs_done a s) (cs_done a s)

  | cse_eof : 

    comp_state_eq (@cs_eof A) (@cs_eof A)

  | cse_more : 

    forall c1 c2 s,

      Comp_eq c1 c2 ->

      comp_state_eq (cs_more c1 s) (cs_more c2 s).



Theorem comp_state_eq_refl : forall (A : Set)(c : comp_state A),

  comp_state_eq c c.



  destruct c; intuition;

  econstructor.

  eapply Comp_eq_refl.

Qed.



Lemma evalDet_steps_done_func_h : forall (A : Set)(x : comp_state A) y1,

  evalDet_steps x y1 ->

  forall a a' s s',

  y1 = (cs_done a s) ->

  evalDet_steps x (cs_done a' s') ->

  (a = a' /\ s = s').



  induction 1; intros; subst.

  inversion H0; clear H0; subst.

  intuition.



  inversion H2; clear H2; subst.

  eapply IHevalDet_steps;

  trivial.

Qed.



Theorem evalDet_steps_done_func : forall (A : Set) x (a a' : A) s s',

  evalDet_steps x (cs_done a s) ->

  evalDet_steps x (cs_done a' s') ->

  (a = a' /\ s = s').



  intros.

  eapply evalDet_steps_done_func_h.

  eapply H.

  eauto.

  eauto.

Qed.



Lemma evalDet_steps_done_eof_func_h : forall (A : Set)(x : comp_state A) y1,

  evalDet_steps x y1 ->

  forall a s,

  y1 = (cs_done a s) ->

  evalDet_steps x (@cs_eof A) ->

  False.



  induction 1; intros; subst.

  inversion H0.



  inversion H2; clear H2; subst.

  eapply IHevalDet_steps;

  trivial.

Qed.



Theorem evalDet_steps_done_eof_func : forall (A : Set) x (a : A) s,

  evalDet_steps x (cs_done a s) ->

  evalDet_steps x (@cs_eof A) ->

  False.



  intros.

  eapply evalDet_steps_done_eof_func_h.

  eapply H.

  eauto.

  eauto.

Qed.



Theorem evalDet_func : forall (A : Set)(c : Comp A)(s : Blist)(y1 y2 : comp_answer A),

  evalDet c s y1 ->

  evalDet c s y2 ->

  y1 = y2.



  intuition.

  inversion H; subst; clear H.

  inversion H0; subst; clear H0.

  f_equal.

  eapply evalDet_steps_done_func; eauto.



  exfalso.

  eapply evalDet_steps_done_eof_func; eauto.



  inversion H0; clear H0; subst.

  exfalso.

  eapply evalDet_steps_done_eof_func; eauto.



  trivial.

Qed.



Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) :=

  (forall s y, evalDet c1 s y <-> evalDet c2 s y).



Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A),

  evalDet_equiv c1 c2 ->

  evalDet_equiv c2 c1.

  

  unfold evalDet_equiv. intuition.

  eapply H; trivial.

  eapply H; trivial.

Qed.



Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,

    x = (cs_more (Bind c1 c2) s) ->

    y = (cs_done a s') ->

  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\

    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').



  induction 1; intuition; subst.

  discriminate.

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  case_eq (evalDet_step c1 s0); intuition;

  rewrite H in H2; discriminate.



  case_eq (evalDet_step c1 s0); intuition;

  rewrite H0 in H.

  inversion H; clear H; subst.

  econstructor. econstructor. intuition.

  econstructor.

  eapply H0.

  econstructor.

  econstructor; eauto.



  discriminate.



  inversion H; clear H; subst.

  edestruct IHevalDet_steps.

  simpl.

  rewrite H0.

  eauto.

  eauto.

  destruct H.

  intuition.

  

  econstructor. econstructor. intuition.

  econstructor.

  eapply H0.

  eauto.

  trivial.

Qed.



Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,

  evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') ->

  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\

    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').



  intuition.

  eapply evalDet_steps_bind_done_inv_h; eauto.



Qed.



Theorem evalDet_steps_bind_eof_inv_h : 

  forall (A : Set)(x y : comp_state A),

    evalDet_steps x y ->

    forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,

      x = (cs_more (Bind c1 c2) s) ->

      y = (@cs_eof A) ->

      evalDet_steps (cs_more c1 s) (@cs_eof B) \/

      exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 

        evalDet_steps (cs_more (c2 b) s') (@cs_eof A).



  induction 1; intuition; subst.

  discriminate.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  case_eq (evalDet_step c1 s0); intuition;

  rewrite H in H2.

  discriminate.

  left.

  econstructor.

  rewrite H.

  eauto.

  econstructor.

  discriminate.



  case_eq (evalDet_step c1 s0); intuition;

  rewrite H0 in H.

  inversion H; clear H; subst.

  right.

  econstructor. econstructor. intuition.

  econstructor.

  eauto.

  econstructor.

  econstructor.

  eauto.

  trivial.

  

  discriminate.

  

  inversion H; clear H; subst.

  edestruct (IHevalDet_steps).

  simpl.

  rewrite H0.

  eauto.

  trivial.

  left.

  econstructor; eauto.

  destruct H. destruct H. intuition.

  right.

  econstructor. econstructor. intuition.

  econstructor; eauto.

  trivial.



Qed.

  

Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,

  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) ->

  evalDet_steps (cs_more c1 s) (@cs_eof B) \/

  exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 

    evalDet_steps (cs_more (c2 b) s') (@cs_eof A).



  intuition.

  eapply evalDet_steps_bind_eof_inv_h; eauto.

Qed.



Theorem evalDet_bind_assoc : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),

  evalDet_equiv (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).



  intuition.

  unfold evalDet_equiv.

  intuition.

  inversion H; clear H; subst.



  Ltac evalDet_tac :=

    match goal with

      | [H1 : evalDet_steps ?x (cs_done ?a1 ?s1), H2 : evalDet_steps ?x (@cs_eof _) |- _ ] => exfalso; eauto using evalDet_steps_done_eof_func; intuition

      | [H : evalDet_steps (cs_more (Bind _ _) _) (cs_done _ _) |- _ ] => apply evalDet_steps_bind_done_inv in H

      | [H : evalDet_steps (cs_more (Bind _ _) _) (@cs_eof _) |- _ ] => apply evalDet_steps_bind_eof_inv in H; intuition

      | [H : exists _ : _, _ |- _ ] => destruct H; intuition

      | [H1 : evalDet_steps ?x (cs_done ?a1 ?s1), H2 : evalDet_steps ?x (cs_done ?a2 ?s2) |- _ ] => assert (a1 = a2 /\ s1 = s2); eauto using evalDet_steps_done_func; intuition; subst; clear H1; eauto

    end.

  repeat evalDet_tac.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.



  repeat evalDet_tac.

  econstructor.

  eapply evalDet_bind_eof; eauto.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eapply evalDet_bind_eof; eauto.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.



  inversion H; clear H; subst.

  repeat evalDet_tac.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.

  eauto.



  repeat evalDet_tac.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_bind_eof; eauto.

  eapply evalDet_bind_eof; eauto.

  econstructor.

  econstructor.

  eapply evalDet_bind_eof.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.

  eauto.



Qed.



Theorem evalDet_done_eof_func:

  forall (A : Set) (c : Comp A) (a : A) (s : Blist),

    evalDet c s (ca_done a) -> evalDet c s (@ca_eof A) -> False.

  

  intuition.

  inversion H; clear H; subst.

  inversion H0; clear H0; subst.

  eapply evalDet_steps_done_eof_func; eauto.

Qed.



Lemma getSupport_In_evalDet_step_done : forall (A : Set)(c : Comp A) a s s',

  evalDet_step c s = cs_done a s' ->

  In a (getSupport c).

  

  induction c; intuition; simpl in *.

  

  inversion H; clear H; subst.

  intuition.

  

  destruct (evalDet_step c s); try discriminate.

  

  eapply in_getAllBvectors.



  discriminate.

Qed.



Lemma getSupport_In_evalDet_step_more : forall (A : Set)(c c' : Comp A) s s' a,

  evalDet_step c s = cs_more c' s' ->

  In a (getSupport c') ->

  In a (getSupport c).

  

  induction c; intuition; simpl in *.

  discriminate.

  

  case_eq (evalDet_step c s); intuition;

    rewrite H2 in H0.

  inversion H0; clear H0; subst.

  eapply in_getUnique.

  eapply in_flatten.

  exists (getSupport (c0 b)).

  intuition.

  eapply in_map_iff.

  exists b. 

  intuition.

  eapply getSupport_In_evalDet_step_done; eauto.

  

  discriminate.

  

  inversion H0; clear H0; subst.

  simpl in *.

  apply in_getUnique_if in H1.

  apply in_flatten in H1.

  destruct H1; intuition.

  eapply in_getUnique.

  eapply in_flatten.

  exists x.

  intuition.

  apply in_map_iff in H1.

  destruct H1; intuition.

  subst.

  eapply in_map_iff.

  exists x0.

  intuition.

  eapply IHc; eauto.

  

  eapply in_getAllBvectors.



  inversion H; clear H; subst.

  simpl in *.

  eapply in_getUnique_if in H0.

  eapply in_flatten in H0.

  destruct H0.

  intuition.

  eapply in_map_iff in H0.

  destruct H0.

  intuition.

  subst.

  case_eq (b x0); intuition;

  rewrite H in H1; simpl in *.

  intuition; subst.

  eapply filter_In; eauto.

  trivial.

  

Qed.



Lemma getSupport_In_evalDet_steps_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) a s s',

    x = (cs_more c s)  ->

    y = (cs_done a s') -> 

    In a (getSupport c).

  

  induction 1; intuition; subst.

  discriminate.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  

  eapply getSupport_In_evalDet_step_done; eauto.

  

  eapply getSupport_In_evalDet_step_more.

  eauto.

  eapply IHevalDet_steps.

  eauto.

  eauto.

Qed.



Lemma getSupport_In_evalDet_steps : forall (A : Set)(c : Comp A) a s s',

  evalDet_steps (cs_more c s) (cs_done a s') -> 

  In a (getSupport c).

  

  intuition.

  eapply getSupport_In_evalDet_steps_h; eauto.

Qed.



Theorem getSupport_In_evalDet : forall (A : Set)(c : Comp A) a s,

  evalDet c s (ca_done a) -> 

  In a (getSupport c).

  

  intuition.

  inversion H; clear H; subst.

  

  eapply getSupport_In_evalDet_steps; eauto.

  

Qed.



Inductive evalDet_repeat_steps (A : Set)(P : A -> bool) : comp_state A -> comp_state A -> Prop :=

| evalDet_repeat_steps_done : 

  forall c s a s',

    evalDet_steps (cs_more c s) (cs_done a s') ->

    P a = true ->

    evalDet_repeat_steps P (cs_more c s) (cs_done a s')

| evalDet_repeat_steps_eof :

  forall c s,

    evalDet_steps (cs_more c s) (@cs_eof A) ->

    evalDet_repeat_steps P (cs_more c s) (@cs_eof A)

| evalDet_repeat_steps_step :

  forall c s a s' y,

    evalDet_steps (cs_more c s) (cs_done a s') ->

    P a = false ->

    evalDet_repeat_steps P (cs_more c s') y ->

    evalDet_repeat_steps P (cs_more c s) y.



Inductive evalDet_repeat(A : Set)(P : A -> bool)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=

  | evalDet_repeat_done : forall a s',

    evalDet_repeat_steps P (cs_more c s) (cs_done a s') ->

    evalDet_repeat P c s (ca_done a)

  | evalDet_repeat_eof :

    evalDet_repeat_steps P (cs_more c s) (@cs_eof A) ->

    evalDet_repeat P c s (@ca_eof A).



Lemma list_skipn_strong_ind_h : forall (A : Type) l (P : list A -> Prop) ,

  P nil -> 

  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->

  (forall n, P (skipn n l)).



  induction l;

  intuition; simpl in *.



  destruct n; simpl in *; trivial.

  

  destruct n; simpl in *.

  eapply H0.

  intuition.

  destruct n; try omega; simpl in *.

  eapply IHl; intuition.



  eapply IHl; intuition.

Qed.



Lemma list_skipn_strong_ind : forall (A : Type) l (P : list A -> Prop) ,

  P nil -> 

  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->

  P l.



  intuition.

  assert (l = skipn 0 l).

  simpl.

  trivial.

  rewrite H1.

  eapply list_skipn_strong_ind_h; trivial.



Qed.



Lemma evalDet_step_nil_inv : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,

  evalDet_step c nil = (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  a1 = a2.



  induction c; intuition; simpl in *; intuition; subst.



  inversion H; clear H; subst.

  trivial.



  destruct (evalDet_step c nil); discriminate.



  destruct n; try discriminate.

  

  discriminate.

  

Qed.



Lemma evalDet_step_done_nil_inv : forall (A : Set)(c : Comp A) a ls,

  evalDet_step c nil = (cs_done a ls) ->

  ls = nil.

  

  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  trivial.

  

  case_eq (evalDet_step c nil); intuition;

    rewrite H1 in H0;

      discriminate.

  

  destruct n;

    discriminate.



  discriminate.

Qed.



Lemma evalDet_step_more_nil_inv : forall (A : Set)(c c' : Comp A) ls,

  evalDet_step c nil = (cs_more c' ls) ->

  ls = nil.

  

  induction c; intuition; simpl in *.

  discriminate.

  

  case_eq (evalDet_step c nil); intuition;

    rewrite H1 in H0.

  inversion H0; clear H0; subst.

  eapply evalDet_step_done_nil_inv; eauto.

  discriminate.

  inversion H0; clear H0; subst.

  eauto.

  

  destruct n.

  inversion H; clear H; subst.

  trivial.

  discriminate.



  inversion H; clear H; subst.

  trivial.



Qed.



Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) s a,

  evalDet_step c s = cs_done a s ->

  getSupport c = (a :: nil).

  

  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  trivial.

  

  destruct (evalDet_step c s); discriminate.

  

  destruct (shiftOut s n).

  destruct p.

  discriminate.

  discriminate.



  discriminate.

Qed.



Lemma getUnique_NoDup_eq : forall (A : Set)(eqd : eq_dec A)(ls : list A),

  NoDup ls ->

  getUnique ls eqd = ls.



  induction ls; intuition; simpl in *.

  inversion H; clear H; subst.

  destruct (in_dec eqd a (getUnique ls eqd)).

  exfalso.

  apply H2.

  eapply in_getUnique_if.

  eauto.



  f_equal.

  eauto.



Qed.



Lemma getUnique_Permutation : forall (A : Set)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),

  Permutation ls1 ls2 ->

  Permutation (getUnique ls1 eqd1) (getUnique ls2 eqd2).



  induction 1; intuition; simpl in *.

  destruct (in_dec eqd1 x (getUnique l eqd1)).

  destruct (in_dec eqd2 x (getUnique l' eqd2)).

  eauto.

  exfalso.

  eapply n.

  eapply Permutation_in; eauto.



  destruct (in_dec eqd2 x (getUnique l' eqd2)).

  exfalso.

  eapply n.

  eapply Permutation_in.

  eapply Permutation_sym.

  eauto.

  eauto.

  eapply perm_skip.

  trivial.



  destruct (in_dec eqd1 x (getUnique l eqd1)).

  destruct (in_dec eqd1 y (getUnique l eqd1)).

  destruct (in_dec eqd2 y (getUnique l eqd2)).

  destruct (in_dec eqd2 x (getUnique l eqd2)).



  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.

  

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.



  destruct (in_dec eqd2 y (getUnique l eqd2)).

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  destruct (in_dec eqd2 x (y :: getUnique l eqd2)).

  eapply perm_skip.

  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.

  simpl in *. intuition.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  

  destruct (in_dec eqd1 y (x :: getUnique l eqd1)).

  destruct (in_dec eqd2 y (getUnique l eqd2)).

  destruct (in_dec eqd2 x (getUnique l eqd2)).

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  eapply perm_skip.

  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.

  destruct (in_dec eqd2 x (y :: getUnique l eqd2)).

  simpl in *; intuition.

  clear H.

  subst.

  eapply perm_skip.

  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.

  subst.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  subst.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.



  simpl in *; intuition; subst.

  intuition.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.



  destruct (in_dec eqd2 y (getUnique l eqd2)).

  destruct (in_dec eqd2 x (getUnique l eqd2)).

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  simpl in n0; intuition.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.

  destruct (in_dec eqd2 x (y :: getUnique l eqd2)).

  simpl in *; intuition; subst.

  intuition.

  exfalso.

  eauto using in_getUnique, in_getUnique_if.



  eapply perm_trans.

  eapply perm_swap.

  eapply perm_skip.

  eapply perm_skip.

  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.



  eapply perm_trans.

  eapply IHPermutation1.

  eapply (@perm_trans _ _ (getUnique l' eqd1)).

  eapply NoDup_Permutation; eauto using getUnique_NoDup; intuition;

    eauto using in_getUnique, in_getUnique_if.

  trivial.



Qed.



Lemma flatten_Permutation : forall (A : Type)(ls1 ls2 : list (list A)),

  Permutation ls1 ls2 ->

  Permutation (flatten ls1) (flatten ls2).



  induction 1; intuition; simpl in *.



  eapply Permutation_app.

  eapply Permutation_refl.

  trivial.



  repeat rewrite app_assoc.

  eapply Permutation_app.

  eapply Permutation_app_comm.

  eapply Permutation_refl.



  eapply perm_trans.

  eapply IHPermutation1.

  trivial.



Qed.



Lemma to_list_nil_inv : forall (A : Type)(n : nat)(v : Vector.t A n),

  Vector.to_list v = nil ->

  n = O.

  

  intuition.

  destruct v; simpl in *.

  trivial.

  unfold Vector.to_list in *.

  discriminate.

Qed.



Lemma app_second_eq :

  forall (A : Type) (ls2 ls1 ls3 : list A),

    ls1 = ls2 ++ ls3 -> length ls1 = length ls3 -> ls1 = ls3 /\ ls2 = nil.



  induction ls2; simpl in *; intuition;

  

  subst;

  simpl in *;

  rewrite app_length in H0;

  omega.



Qed.



Lemma shiftOut_same_inv : forall s n v,

  shiftOut s n = Some (v, s) ->

  n = O.

  

  intuition.

  eapply to_list_nil_inv.

  eapply app_second_eq.

  eapply shiftOut_correct_inv.

  eauto.

  trivial.

Qed.



Lemma filter_Permutation : forall (A : Set)(ls1 ls2 : list A)(P : A -> bool),

  Permutation ls1 ls2 ->

  Permutation (filter P ls1) (filter P ls2).

  

  induction 1; intuition; simpl in *.

  destruct (P x).

  eapply perm_skip.

  trivial.

  trivial.

  

  destruct (P x).

  destruct (P y).

  eapply perm_swap.

  eapply Permutation_refl.

  destruct (P y).

  eapply Permutation_refl.

  eapply Permutation_refl.

  

  eapply perm_trans;

    eauto.

Qed.



Lemma evalDet_step_more_support_preserved : forall (A : Set)(c c' : Comp A) s,

  evalDet_step c s = (cs_more c' s) ->

  Permutation (getSupport c) (getSupport c').



  induction c; intuition; simpl in *; try discriminate.

  subst.

  case_eq (evalDet_step c s); intuition;

  rewrite H1 in H0.

  inversion H0; clear H0; subst.



  erewrite evalDet_step_done_support_singleton; eauto.

  simpl.

  rewrite app_nil_r.



  rewrite getUnique_NoDup_eq.

  eapply Permutation_refl.

  eapply getSupport_NoDup.

  discriminate.

  inversion H0; clear H0; subst.

  simpl.



  eapply getUnique_Permutation.



  eapply flatten_Permutation.

  eapply Permutation_map.

  eauto.



  case_eq (shiftOut s n); intuition;

  rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.



  assert (n = O).

  eapply shiftOut_same_inv; eauto.

  subst.

  simpl.

  rewrite shiftOut_0 in H0.

  inversion H0; clear H0; subst.

  eapply Permutation_refl.

  discriminate.



  inversion H; clear H; subst.

  simpl.



  eapply NoDup_Permutation.

  eapply filter_NoDup.

  eapply getSupport_NoDup.

  eapply getUnique_NoDup.

  intuition.

  eapply in_getUnique.

  eapply in_flatten.

  econstructor.

  split.

  eapply in_map_iff.

  econstructor.

  split.

  2:{

    eapply filter_In; eauto.

  }

  assert (b x = true).

  eapply filter_In; eauto.

  rewrite H0.

  eauto.

  simpl.

  intuition.



  apply in_getUnique_if in H.

  eapply in_flatten in H.

  destruct H.

  intuition.

  eapply in_map_iff in H0.

  destruct H0.

  intuition.

  subst.

  case_eq (b x1); intuition;

  rewrite H in H1.

  simpl in *.

  intuition; subst.

  eapply filter_In; eauto.

  simpl in *.

  trivial.

  

Qed.



Lemma evalDet_steps_nil_eq_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A)(a1 a2 : A) s2,

  x = (cs_more c nil) -> 

  y = (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  a1 = a2.



  induction 1; intuition; simpl in *; subst.

  discriminate.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  eapply evalDet_step_nil_inv; eauto.



  symmetry in H.

  specialize (evalDet_step_more_nil_inv _ H); intuition.

  subst.

  eapply IHevalDet_steps.

  eauto.

  eauto.

  eapply Permutation_in.

  eapply evalDet_step_more_support_preserved.

  eauto.

  trivial.

Qed.



Lemma evalDet_steps_nil_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,

  evalDet_steps (cs_more c nil) (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  a1 = a2.



  intuition.

  eapply evalDet_steps_nil_eq_h; eauto.

Qed.



Lemma evalDet_step_done_val_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,

  evalDet_step c s1 = (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  a1 = a2.



  induction c; intuition; simpl in *.

  intuition; subst.

  inversion H; clear H; subst.

  trivial.



  destruct (evalDet_step c s1); discriminate.



  destruct (shiftOut s1 n); [ destruct p ; discriminate | discriminate ].

  

  discriminate.

Qed.



Lemma evalDet_step_done_ls_eq : forall (A : Set)(c : Comp A)(a2 : A) s1 s2,

  evalDet_step c s1 = (cs_done a2 s2) ->

  s1 = s2.



  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  trivial.



  destruct (evalDet_step c s1); discriminate.



  destruct (shiftOut s1 n); [ destruct p ; discriminate | discriminate ].

  

  discriminate.



Qed.



Lemma shiftOut_skipn : forall n (v : Bvector n) s s',

  shiftOut s n = Some (v, s') ->

  s' = skipn n s.

  

  induction n; intuition; simpl in *.

  rewrite shiftOut_0 in H.

  inversion H; clear H; subst.

  trivial.

  

  destruct s;

    simpl in *.

  discriminate.

  

  case_eq (shiftOut s n); intuition;

    rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  eauto.

  discriminate.

Qed.



Lemma evalDet_step_more_skipn_eq : forall (A : Set)(c c' : Comp A)(a1 : A) s1 s2,

  evalDet_step c s1 = (cs_more c' s2) ->

  In a1 (getSupport c) ->

  (s1 = s2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).



  induction c; intuition; simpl in *; try discriminate.



  case_eq (evalDet_step c s1); intuition;

  rewrite H2 in H0.

  inversion H0; clear H0; subst.

  left.

  eapply evalDet_step_done_ls_eq.

  eauto.

  discriminate.

  inversion H0; clear H0; subst.

  

  eapply in_getUnique_if in H1.

  apply in_flatten in H1.

  destruct H1.

  intuition.

  apply in_map_iff in H1.

  destruct H1; intuition.

  eapply (IHc).

  eauto.

  eauto.

 

  case_eq (shiftOut s1 n); intuition;

  rewrite H1 in H.

  destruct p.

  inversion H; clear H; subst.

  destruct n.

  left.

  rewrite shiftOut_0 in H1.

  inversion H1; clear H1; subst.

  trivial.

  right.

  exists (S n).

  intuition.



  eapply shiftOut_skipn.

  eauto.

  

  discriminate.



  inversion H; clear H; subst.

  intuition.  

Qed.



Lemma evalDet_step_done_skipn : forall (A : Set)(c : Comp A) s a s',

  evalDet_step  c s = (cs_done a s') ->

  exists n, s' = skipn n s.

  

  induction c; intuition; simpl in *.

  

  inversion H; clear H; subst.

  exists O.

  simpl.

  trivial.



  destruct (evalDet_step c s); discriminate.



  destruct (shiftOut s n).

  destruct p.

  discriminate.

  discriminate.



  discriminate.

 

Qed.



Lemma skipn_sum : forall (A : Type)(n2 n1 : nat)(ls : list A),

  skipn n1 (skipn n2 ls) = skipn (n2 + n1) ls.

  

  induction n2; intuition; simpl in *.

  

  destruct ls.

  destruct n1; trivial.

  trivial.

Qed.



Lemma evalDet_step_more_skipn : forall (A : Set)(c c' : Comp A) s s',

  evalDet_step  c s = (cs_more c' s') ->

  exists n, s' = skipn n s.



  induction c; intuition; simpl in *.

  discriminate.



  case_eq (evalDet_step c s); intuition;

  rewrite H1 in H0.

  inversion H0; clear H0; subst.

  eapply evalDet_step_done_skipn.

  eauto.

  discriminate.

  inversion H0; clear H0; subst.

  eauto.



  case_eq (shiftOut s n); intuition;

  rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  exists n.



  eauto using shiftOut_skipn.

  discriminate.



  inversion H; clear H; subst.

  exists O.

  simpl.

  trivial.



Qed.



Lemma evalDet_steps_done_skipn_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) s a s', 

    x = (cs_more c s) ->

    y = (cs_done a s') ->

  exists n, s' = skipn n s.



  induction 1; intuition; simpl in *; subst.

  discriminate.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  eapply evalDet_step_done_skipn; eauto.

  

  symmetry in H.

  specialize (evalDet_step_more_skipn _  _ H); intuition.

  destruct H0.

  subst.



  edestruct IHevalDet_steps.

  eauto.

  eauto.

  subst.

  exists (x + x0).

  apply skipn_sum.



Qed.



Lemma evalDet_steps_done_skipn : forall (A : Set)(c : Comp A) s a s',

  evalDet_steps (cs_more c s) (cs_done a s') ->

  exists n, s' = skipn n s.



  intuition.

  eapply evalDet_steps_done_skipn_h; eauto.

  

Qed.



Lemma evalDet_steps_skipn_h : forall (A : Set) a1 (x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A)(a2 : A) s1 s2,

  x = (cs_more c s1) -> 

  y = (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).



  induction 1; subst; intuition; subst.

  discriminate.



  inversion H; clear H; subst.

  

  inversion H0; clear H0; subst.

  left.

  eapply evalDet_step_done_val_eq; eauto.



  symmetry in H.

  edestruct (evalDet_step_more_skipn_eq c0).

  eauto.

  eauto.

  subst.

  edestruct (IHevalDet_steps).

  eauto.

  eauto.

  eapply Permutation_in.

  eapply evalDet_step_more_support_preserved.

  eauto.

  eauto.

  intuition.

  intuition.



  destruct H0.

  intuition.

  subst.

  right.

  

  case_eq (evalDet_step c (skipn x s1)); intuition;

  rewrite H0 in H3.

  edestruct (evalDet_step_done_skipn).

  eauto.

  subst.

  

  inversion H3; clear H3; subst.



  exists (x + x0).

  intuition.

  eapply skipn_sum.



  inversion H3.



  edestruct (evalDet_step_more_skipn).

  eauto.

  subst.

  edestruct (evalDet_steps_done_skipn).

  eauto.

  subst.

  exists (x + (x0 + x1)).

  intuition.

  rewrite skipn_sum.

  rewrite skipn_sum.

  trivial.



Qed.



Lemma evalDet_steps_skipn : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,

  evalDet_steps (cs_more c s1) (cs_done a2 s2) ->

  In a1 (getSupport c) ->

  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).



  intuition.

  eapply evalDet_steps_skipn_h; eauto.



Qed.



Lemma evalDet_repeat_steps_dec : forall (s : Blist)(A : Set)(c : Comp A)(P : A -> bool),

  (exists a, In a (getSupport c) /\ P a = true) ->

  (forall s', (exists a s'', evalDet_steps (cs_more c s') (cs_done a s'')) \/ evalDet_steps (cs_more c s') (@cs_eof A)) ->

  exists y, evalDet_repeat_steps P (cs_more c s) y.



  intro.

  eapply (list_skipn_strong_ind s); intuition.

  destruct (H0 nil).

  destruct H1.

  destruct H1.

  destruct H.

  intuition.

  exists (cs_done x x0).

  econstructor.

  trivial.



  assert (x1 = x).

  eapply evalDet_steps_nil_eq; eauto.

  subst.

  trivial.



  exists (@cs_eof A).

  econstructor.

  trivial.



  destruct (H1 x).

  destruct H2. destruct H2.

  destruct H0; intuition.



  destruct (evalDet_steps_skipn _ H2 H3); subst.

  econstructor.

  econstructor; eauto.

  destruct H0; intuition; subst.



  case_eq (P x0); intuition.

  econstructor.

  econstructor; eauto.



  edestruct H; eauto.

  econstructor.

  eapply evalDet_repeat_steps_step.

  eapply H2.

  trivial.

  eauto.



  econstructor.

  eapply evalDet_repeat_steps_eof; eauto.

Qed.   



Lemma evalDet_repeat_steps_done_inv_h : forall (A : Set)(P : A -> bool) x y,

  evalDet_repeat_steps P x y ->

  forall c s,

  x = (cs_more c s) -> 

  evalDet_steps (cs_more (Repeat c P) s) y.



  induction 1; intuition; subst.



  inversion H1; clear H1; subst.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H0.

  econstructor.

  eauto.

  simpl.

  econstructor.



  inversion H0; clear H0; subst.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_bind_eof.

  trivial.

  

  inversion H2; clear H2; subst.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H0.

  eauto.

  

Qed.



Lemma evalDet_repeat_steps_done_inv : forall (A : Set)(c : Comp A)(P : A -> bool) s y,

  evalDet_repeat_steps P (cs_more c s) y ->

  evalDet_steps (cs_more (Repeat c P) s) y.



  intuition.

  eapply evalDet_repeat_steps_done_inv_h; eauto.

Qed.



Lemma evalDet_repeat_steps_more_inv_h : forall (A : Set)(x y : comp_state A) P,

  evalDet_repeat_steps P x y ->

  forall (c: Comp A)(P : A -> bool) s,

  y = (cs_more c s) ->

  False.



  induction 1; intuition; subst; try discriminate.

Qed.



Lemma evalDet_repeat_steps_more_inv : forall (A : Set) x (c : Comp A)(P : A -> bool) s,

  evalDet_repeat_steps P x (cs_more c s) ->

  False.



  intuition.

  eapply evalDet_repeat_steps_more_inv_h; eauto.

Qed.



Lemma evalDet_steps_dec : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  forall s, 

  (exists a s', evalDet_steps (cs_more c s) (cs_done a s')) \/ 

  (evalDet_steps (cs_more c s) (@cs_eof A)).

  

  induction 1; intros.

  

  left.

  exists a. exists s.

  econstructor.

  simpl.

  eauto.

  econstructor.

  

  destruct (IHwell_formed_comp s).

  destruct H2. destruct H2.

  edestruct (H1 x).

  eapply getSupport_In_evalDet_steps.

  eauto.



  destruct H3. destruct H3.

  left.

  exists x1.

  exists x2.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.

  

  right.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  trivial.

  

  right.

  eapply evalDet_bind_eof; eauto.

  

  case_eq (shiftOut s n); intuition.

  left.

  destruct p.

  exists b.

  exists b0.

  econstructor.

  simpl.

  rewrite H.

  eauto.

  econstructor.

  simpl.

  eauto.

  econstructor.

  

  right.

  econstructor.

  simpl.

  rewrite H.

  eauto.

  econstructor.



  edestruct (evalDet_repeat_steps_dec).

  exists b.

  eapply filter_In; eauto.

  eauto.

  destruct x.

  left.

  econstructor.

  econstructor.

  eapply evalDet_repeat_steps_done_inv.

  eauto.



  right.

  eapply evalDet_repeat_steps_done_inv.

  eauto.



  exfalso.

  eauto using evalDet_repeat_steps_more_inv.

    

Qed.



Lemma evalDet_dec : forall (A : Set)(c : Comp A)(s : Blist),

  well_formed_comp c ->

  (exists a, evalDet c s (ca_done a)) \/ (evalDet c s (@ca_eof A)).

  

  intuition.

  edestruct (@evalDet_steps_dec _ c).

  trivial.

  destruct H0.

  destruct H0.

  left.

  econstructor.

  econstructor.

  eauto.



  right.

  econstructor.

  eauto.

  

Qed.



Lemma evalDet_step_app_done_eq : forall (A : Set)(c : Comp A) s s' s'' a,

  evalDet_step c s = (cs_done a s'') ->

  evalDet_step c (s ++ s') = (cs_done a (s'' ++ s')).

  

  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  trivial.

  

  case_eq (evalDet_step c s); intuition;

    rewrite H1 in H0; try discriminate.

  

  case_eq (shiftOut s n); intuition;

    rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  discriminate.



  discriminate.



Qed.



Lemma evalDet_step_app_more_eq : forall (A : Set)(c c': Comp A) s s' s'',

  evalDet_step c s = (cs_more c' s'') ->

  evalDet_step c (s ++ s') = (cs_more c' (s'' ++ s')).

  

  induction c; intuition; simpl in *.

  discriminate.

  

  case_eq (evalDet_step c s); intuition; 

    rewrite H1 in H0; try discriminate.

  inversion H0; clear H0; subst.

  erewrite evalDet_step_app_done_eq;

  eauto.

  inversion H0; clear H0; subst.

  erewrite IHc.

  eauto.

  trivial.

  

  case_eq (shiftOut s n); intuition;

    rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  erewrite shiftOut_app; eauto.

  discriminate.



  inversion H; clear H; subst.

  trivial.

Qed.



Lemma evalDet_steps_app_eq_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) s s' s'' a,

    x = (cs_more c s) ->

    y = (cs_done a s'') ->

    evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

  

  induction 1; intuition; subst.

  discriminate.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  

  econstructor.

  eapply evalDet_step_app_done_eq.

  eauto.

  econstructor.

  

  econstructor.

  

  eauto.

  erewrite evalDet_step_app_more_eq.

  eapply IHevalDet_steps.

  eauto.

  trivial.

  auto.

Qed.



Lemma evalDet_steps_app_eq : forall (A : Set)(c : Comp A) s s' s'' a,

  evalDet_steps (cs_more c s) (cs_done a s'') ->

  evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

  

  intuition.

  eapply evalDet_steps_app_eq_h; eauto.

  

Qed.



Lemma evalDet_app_eq : forall (A : Set)(c : Comp A) s s' a,

  evalDet c s (ca_done a) ->

  evalDet c (s ++ s') (ca_done a).

  

  intuition.

  inversion H; clear H; subst.

  econstructor.

  eapply evalDet_steps_app_eq.

  eauto.

Qed.



Lemma evalDet_steps_done_nil_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) a ls,

    x = (cs_more c nil) ->

    y = (cs_done a ls) ->

    ls = nil.

  

  induction 1; intuition; subst.

  discriminate.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  eapply evalDet_step_done_nil_inv; eauto.

  assert (s = nil).

  eapply evalDet_step_more_nil_inv; eauto. subst.

  eauto.



Qed.



Lemma evalDet_steps_done_nil_inv : forall (A : Set)(c : Comp A) a ls,

  evalDet_steps (cs_more c nil) (cs_done a ls) ->

  ls = nil.

  

  intuition.

  eapply evalDet_steps_done_nil_inv_h; eauto.

Qed.



Lemma app_eq_nil_inv : forall (A : Set)(ls2 ls1 ls3 : list A),

  ls1 = ls2 ++ ls3 ->

  length ls1 = length ls2 ->

  ls3 = nil.

  

  induction ls2; intuition; simpl in *; subst.

  destruct ls3; simpl in *; trivial. omega.

  

  simpl in *.

  eapply IHls2.

  eauto.

  omega.

Qed.



Lemma evalDet_steps_repeat_done_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (P : A -> bool)(c : Comp A) s a s',

  evalDet_steps x (cs_more (Repeat c P) s) ->

  y = (cs_done a s') ->

  evalDet_repeat_steps P (cs_more c s) (cs_done a s').



  induction 1; intuition; subst.

  inversion H.



  inversion H1; clear H1; subst.

  simpl in *.

  eapply evalDet_steps_bind_done_inv in H0.

  destruct H0. destruct H.

  intuition.

  case_eq (P x); intuition;

  rewrite H in H1.

  inversion H1; clear H1; subst.

  simpl in *.

  inversion H6; clear H6; subst.

  econstructor;

  eauto.

  eapply evalDet_repeat_steps_step.

  eauto.

  trivial.

  eapply IHevalDet_steps.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H.

  econstructor.

  trivial.



  case_eq (P a); intuition.



Qed.



Lemma evalDet_steps_repeat_done_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s a s',

  evalDet_steps (cs_more (Repeat c P) s) (cs_done a s') ->

  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

  

  intuition.

  eapply evalDet_steps_repeat_done_inv_h.

  eapply H.

  econstructor.

  trivial.

  

Qed.



Lemma evalDet_steps_repeat_eof_inv_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (P : A -> bool)(c : Comp A) s,

    evalDet_steps x (cs_more (Repeat c P) s) ->

    y = (cs_eof A) ->

  evalDet_repeat_steps P (cs_more c s) (cs_eof A).



  induction 1; intuition; subst.

  inversion H.



  inversion H1; clear H1; subst.

  simpl in *.

  eapply evalDet_steps_bind_eof_inv in H0.

  intuition.

  econstructor.

  trivial.

  destruct H. destruct H.

  intuition.

  case_eq (P x); intuition;

  rewrite H in H1.

  inversion H1; clear H1; subst.

  simpl in *.

  inversion H6.

  eapply evalDet_repeat_steps_step.

  eauto.

  trivial.

  eapply IHevalDet_steps.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H.

  econstructor.

  trivial.

  

  eauto.



Qed.



Lemma evalDet_steps_repeat_eof_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s,

  evalDet_steps (cs_more (Repeat c P) s) (cs_eof A)->

  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

  

  intuition.

  eapply evalDet_steps_repeat_eof_inv_h.

  eauto.

  econstructor.

  trivial.

Qed.



Lemma evalDet_repeat_steps_nil_inv_h : forall (A : Set) P (x y : comp_state A),

  evalDet_repeat_steps P x y ->

  forall (P : A -> bool) c a ls',

  x = (cs_more c nil) ->

  y = (cs_done a ls') ->

  ls' = nil.



  induction 1; intuition; subst.

  

  inversion H2; clear H2; subst.

  inversion H3; clear H3; subst.

  eapply evalDet_steps_done_nil_inv.

  eauto.



  discriminate.



  inversion H4; clear H4; subst.

  assert (s' = nil).

  eapply evalDet_steps_done_nil_inv.

  eauto.

  subst.

  eauto.



Qed.



Lemma evalDet_repeat_steps_nil_inv : forall (A : Set)(P : A -> bool) c a ls',

  evalDet_repeat_steps P (cs_more c nil) (cs_done a ls') ->

  ls' = nil.



  intuition.

  eapply evalDet_repeat_steps_nil_inv_h; eauto.



Qed.



Lemma evalDet_repeat_steps_app_nil_h : forall (A : Set) P (x y : comp_state A),

  evalDet_repeat_steps P x y ->

  forall c ls1 ls2 b a,

    x = (cs_more c ls1) ->

    y = (cs_eof A) ->

    evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2)->

    (forall s s' b a,

      evalDet_steps (cs_more c s) (cs_eof A) ->

      evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->

      s' = nil) ->

    ls2 = nil.

  

  induction 1; intuition; subst.



  discriminate.



  inversion H0; clear H0; subst.

  inversion H2; clear H2; subst.

  eapply H3; eauto.



  assert (s' = nil).

  eapply H3; eauto.

  subst.  



  eapply evalDet_repeat_steps_nil_inv.

  eauto.



  inversion H2; clear H2; subst.

  inversion H4; clear H4; subst.

  assert (evalDet_steps (cs_more c0 (ls1 ++ b :: nil)) (cs_done a (s' ++ b :: nil))).

  eapply evalDet_steps_app_eq.

  trivial.

  specialize (evalDet_steps_done_func H7 H2); intuition; subst.

  congruence.



  assert (evalDet_steps (cs_more c0 (ls1 ++ b :: nil)) (cs_done a (s' ++ b :: nil))).

  eapply evalDet_steps_app_eq.

  trivial.

  specialize (evalDet_steps_done_func H6 H2); intuition; subst.

  clear H6.

  eapply IHevalDet_repeat_steps.

  eauto.

  eauto.

  eauto.

  trivial.



Qed.



Lemma evalDet_repeat_steps_app_nil : forall (A : Set)(c : Comp A) P ls1 ls2 b a,

  evalDet_repeat_steps P (cs_more c ls1) (cs_eof A) ->

  evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->

  (forall s s' b a,

    evalDet_steps (cs_more c s) (cs_eof A) ->

    evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->

    s' = nil) ->

  ls2 = nil.



  intuition.

  eapply evalDet_repeat_steps_app_nil_h.

  eapply H.

  eauto.

  trivial.

  eauto.

  trivial.

  

Qed.



Lemma evalDet_app_nil : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  forall ls1 ls2 b a,

  evalDet c ls1 (ca_eof A) ->

  evalDet_steps (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->

  ls2 = nil.

  

  induction 1; intuition; simpl in *.

  

  exfalso.

  eapply evalDet_done_eof_func; eauto.

  econstructor.

  econstructor.

  eauto.

  simpl.

  econstructor.



  apply evalDet_steps_bind_done_inv in H3.

  destruct H3. destruct H3. intuition.

  

  edestruct (@evalDet_dec _ c1 ls1).

  trivial.

  destruct H3.

  inversion H3; clear H3; subst.

  assert (evalDet_steps (cs_more c1 (ls1 ++ b :: nil)) (cs_done x1 (s' ++ b :: nil))).

  eapply evalDet_steps_app_eq.

  eauto.

  specialize (evalDet_steps_done_func H4 H3); intuition. subst.

  clear H3.

  

  edestruct (@evalDet_dec _ (c2 x1) s').

  eapply H0.

  eapply getSupport_In_evalDet_steps.

  eauto.

  destruct H3;

  inversion H3; clear H3; subst.

  exfalso.

  eapply evalDet_done_eof_func; [idtac | eapply H2].

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done; eauto.

  eauto.

 

  eapply H1; eauto.

  eapply getSupport_In_evalDet_steps.

  eauto.

  

  assert (x0 = nil).

  eapply IHwell_formed_comp.

  eauto.

  eauto.

  subst.

  

  eapply evalDet_steps_done_nil_inv; eauto.

  

  case_eq (shiftOut ls1 n); intuition.

  destruct p.

  exfalso.

  eapply evalDet_done_eof_func; [idtac | eapply H].

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H1.

  econstructor.

  eauto.

  simpl.

  econstructor.

  

  inversion H0; clear H0; subst.

  simpl in *.

  apply shiftOut_None_inv in H1.

  case_eq (shiftOut (ls1 ++ b :: nil) n); intuition.

  destruct p.

  rewrite H0 in H6.

  inversion H6; clear H6; subst.

  simpl in *.

  inversion H7; clear H7; subst.

  specialize (shiftOut_Some_inv _ H0); intuition.

  apply shiftOut_correct_inv in H0.

  

  eapply app_eq_nil_inv.

  eapply H0.

  rewrite to_list_length.

  rewrite app_length in *; simpl in *.

  omega.

  

  rewrite H0 in H6.

  inversion H6.



  inversion H1; clear H1; subst.

  eapply evalDet_repeat_steps_app_nil.

  eapply evalDet_steps_repeat_eof_inv.

  eauto.

  eapply evalDet_steps_repeat_done_inv; eauto.

  intuition.

  eapply IHwell_formed_comp.

  econstructor.

  eauto.

  eauto.



Qed.



Lemma evalDet_step_done_inv : forall (A : Set)(c : Comp A) a ls ls',

  evalDet_step c ls = cs_done a ls' ->

  exists eqd, 

    c = Ret eqd a.

  

  intuition.

  destruct c; simpl in *.

  inversion H; clear H; subst.

  econstructor; eauto.

  

  case_eq (evalDet_step c ls); intuition; rewrite H0 in H; discriminate.

  

  destruct (shiftOut ls n). destruct p. discriminate.

  discriminate.



  discriminate.

  

Qed.



Lemma evalDet_step_more_sublist : forall (A : Set)(c : Comp A) c' ls ls',

  evalDet_step c ls = (cs_more c' ls') ->

  exists ls'', ls = ls'' ++ ls'.

  

  induction c; intuition; simpl in *; try discriminate.

  

  case_eq (evalDet_step c ls); intuition; rewrite H1 in H0.

  inversion H0; clear H0; subst.

  destruct (evalDet_step_done_inv _ _ H1); subst; simpl in *.

  inversion H1; clear H1; subst.

  exists nil. trivial.

  

  discriminate.

  

  inversion H0; clear H0; subst.

  eapply IHc.

  eauto.

  

  case_eq (shiftOut ls n); intuition; rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  exists (Vector.to_list b).

  eapply shiftOut_correct_inv.

  trivial.

  discriminate.



  inversion H; clear H; subst.

  exists nil.

  simpl.

  trivial.

      

Qed.

    

Lemma evalDet_sublist_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (c : Comp A) a ls ls' ,

    x = (cs_more c ls) ->

    y = (cs_done a ls') ->

    exists ls'', ls = ls'' ++ ls'.

  

  induction 1; intuition; subst; try discriminate.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  

  destruct (evalDet_step_done_inv _ _ H2). subst.

  simpl in *.

  inversion H2; clear H2; subst.

  exists nil. trivial.

  

  edestruct (IHevalDet_steps).

  symmetry. eauto.

  eauto.

  subst.

  

  symmetry in H.

  apply evalDet_step_more_sublist in H.

  destruct H.

  subst.

  exists (x0 ++ x).

  apply app_assoc.

  

Qed.



Lemma evalDet_sublist : forall (A : Set)(c : Comp A) a ls ls',

  evalDet_steps (cs_more c ls) (cs_done a ls') ->

  exists ls'', ls = ls'' ++ ls'.

  

  intuition. 

  eapply evalDet_sublist_h; eauto.

  

Qed.



Lemma evalDet_nil : forall (A : Set)(c : Comp A) a ls,

  evalDet_steps (cs_more c nil) (cs_done a ls) ->

  ls = nil.

  

  intuition.

  apply evalDet_sublist in H.

  destruct H.

  symmetry in H.

  apply app_eq_nil in H.

  intuition.

Qed.



Lemma evalDet_left_total : forall (A : Set)(c : Comp A) s,

  well_formed_comp c ->

  exists ans, evalDet c s ans.



  intuition.

  edestruct (evalDet_dec).

  eauto.

  destruct H0.

  econstructor.

  eauto.

  econstructor. 

  eauto.

Qed.

  

Lemma evalDet_steps_done_support_singleton_h : forall (A : Set)(x1 x2 : comp_state A),

  evalDet_steps x1 x2 ->

  forall (c : Comp A) a s,

    x1 = (cs_more c nil) ->

    x2 = (cs_done a s) ->

    getSupport c = a :: nil.

  

  induction 1; intuition; subst.

  discriminate.

  inversion H1; clear H1; subst.

  

  inversion H0; clear H0; subst.

  assert (s0 = nil).

  eapply evalDet_step_done_nil_inv.

  eauto.

  subst.

  eapply evalDet_step_done_support_singleton.

  eauto. 

  assert (s = nil).

  eapply evalDet_step_more_nil_inv.

  eauto.

  subst.

  

  assert (Permutation (getSupport c0) (getSupport c)).

  eapply evalDet_step_more_support_preserved.

  symmetry.

  eauto.

  assert (getSupport c = a :: nil).

  eapply IHevalDet_steps.

  eauto.

  eauto.

  rewrite H1 in H0.

  apply Permutation_sym in H0.

  apply Permutation_length_1_inv in H0.

  trivial.

  

Qed.



Lemma evalDet_steps_done_support_singleton : forall (A : Set)(c : Comp A) a s,

  evalDet_steps (cs_more c nil) (cs_done a s) ->

  getSupport c = a :: nil.

  

  intuition.

  eapply evalDet_steps_done_support_singleton_h; eauto.

  

Qed.



Lemma evalDet_step_well_formed_comp_preserved : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  forall c' s s',

    evalDet_step c s = (cs_more c' s') ->

    well_formed_comp c'.

  

  induction 1; intuition; simpl in *.

  

  discriminate.

  

  case_eq (evalDet_step c1 s); intuition;

    rewrite H3 in H2; try discriminate.

  inversion H2; clear H2; subst.

  eapply H0.

  eapply getSupport_In_evalDet_step_done; eauto.

  inversion H2; clear H2; subst.

  eapply well_formed_Bind.

  eapply IHwell_formed_comp.

  eauto.

  intuition.

  eapply H0.

  eapply getSupport_In_evalDet_step_more; eauto.

  

  case_eq (shiftOut s n); intuition;

      rewrite H0 in H; try discriminate.

  destruct p.

  inversion H; clear H; subst.

  econstructor.

  

  inversion H1; clear H1; subst.

  econstructor.

  trivial.

  intuition.

  case_eq (P b0); intuition.

  econstructor.

  econstructor.

  trivial.

  trivial.

  eauto.

  

Qed.



