Require Import VST.msl.log_normalize.
(* VST.msl.log_normalize:
Require Import VST.msl.simple_CCC.
Require Import VST.msl.seplog.

Require Import VST.msl.Extensionality.
Require Import Coq.Setoids.Setoid.

Local Open Scope logic.

Hint Extern 0 (_ |-- _) => match goal with |- ?A |-- ?B => constr_eq A B; simple apply derives_refl end.

Ltac solve_andp' :=
  first [ apply derives_refl
        | apply andp_left1; solve_andp'
        | apply andp_left2; solve_andp'].

Ltac solve_andp := repeat apply andp_right; solve_andp'.

Lemma TT_right {A}{NA: NatDed A}: forall P:A, P |-- TT.

Lemma FF_left {A}{NA: NatDed A}: forall P, FF |-- P.

Hint Resolve @TT_right: norm.
Hint Resolve @FF_left : norm.

Ltac norm := auto with norm.

Lemma add_andp: forall {A: Type} `{NatDed A} (P Q: A), P |-- Q -> P = P && Q.

Lemma andp_comm  {A}{NA: NatDed A}:
  forall P Q: A,  P && Q = Q && P.

Lemma andp_assoc {A} {NA: NatDed A} : forall P Q R : A,
  (P && Q) && R = P && (Q && R).

Lemma andp_derives {A} {NA: NatDed A}:
  forall P Q P' Q': A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma orp_derives {A} {NA: NatDed A}:
  forall P Q P' Q': A, P |-- P' -> Q |-- Q' -> P || Q |-- P' || Q'.

Class CCCviaNatDed (A: Type) (prod expo: A -> A -> A) {ND: NatDed A}: Prop :=
  isCCC: CartesianClosedCat.CCC A derives eq prod expo.

Lemma CCC_expo_derives: forall A prod expo {ND: NatDed A} {CCC: CCCviaNatDed A prod expo},
  forall P P' Q Q', P' |-- P -> Q |-- Q' -> expo P Q |-- expo P' Q'.

Lemma CCC_exp_prod1:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} B (P: B -> A) Q,
  prod (exp P) Q = exp (fun x => prod (P x) Q).

Lemma CCC_exp_prod2:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} B P (Q: B -> A),
  prod P (exp Q) = exp (fun x => prod P (Q x)).

Lemma CCC_distrib_orp_prod:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P Q R,
    prod (orp P Q) R = orp (prod P R) (prod Q R).

Lemma CCC_FF_prod:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P,
    prod FF P = FF.

Lemma CCC_prod_FF:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P,
    prod P FF = FF.

Lemma exp_unit: forall {A} `{NatDed A} (P: unit -> A),
  exp P = P tt.

Lemma allp_unit: forall {A} `{NatDed A} (P: unit -> A),
  allp P = P tt.

Lemma andp_is_allp {A}{ND: NatDed A}:
   forall P Q, andp P Q = allp (fun x : bool => if x then P else Q).

Lemma orp_is_exp {A}{ND: NatDed A}:
   forall P Q, orp P Q = exp (fun x : bool => if x then P else Q).

Lemma exp_prop: forall {B} {ND: NatDed B} A P, exp (fun x: A => prop (P x)) = prop (exists x: A, P x).

Lemma modus_ponens {A}{ND: NatDed A}: forall P Q: A, derives (andp P (imp P Q)) Q.

Lemma modus_ponens_wand {A}{ND: NatDed A}{SL: SepLog A}:
                      forall P Q: A, derives (sepcon P (wand P Q)) Q.

Lemma wand_sepcon_wand: forall {A} {NA: NatDed A} {SA: SepLog A} (P1 P2 Q1 Q2: A),
  (P1 -* Q1) * (P2 -* Q2) |-- P1 * P2 -* Q1 * Q2.

Lemma sepcon_FF {A}{ND: NatDed A}{SL: SepLog A} :
           forall P: A, sepcon P FF = FF.

Lemma FF_sepcon {A} {NA: NatDed A}{SA: SepLog A}: forall P: A, FF * P = FF.

Hint Rewrite @FF_sepcon @sepcon_FF : norm.

Lemma FF_andp {A}{NA: NatDed A}:  forall P: A, FF && P = FF.

Lemma andp_FF {A}{NA: NatDed A}:  forall P: A, P && FF = FF.
Hint Rewrite @FF_andp @andp_FF : norm.

Lemma FF_orp: forall {A: Type} `{NatDed A} (P: A), FF || P = P.

Lemma orp_FF {A}{NA: NatDed A}:
  forall Q, Q || FF = Q.

Lemma orp_TT {A}{NA: NatDed A}:
 forall Q, Q || TT = TT.

Lemma TT_orp {A}{NA: NatDed A}:
 forall Q, TT || Q = TT.

Lemma allp_forall: forall {A B: Type} `{NatDed A} P Q (x:B), (forall x:B, (P x = Q)) -> (allp P = Q).

Lemma allp_derives:
       forall {A: Type}  {NA: NatDed A} (B: Type) (P Q: B -> A),
               (forall x:B, P x |-- Q x) -> (allp P |-- allp Q).

Lemma allp_congr:
       forall {A: Type}  {NA: NatDed A} (B: Type) (P Q: B -> A),
               (forall x:B, P x = Q x) -> (allp P = allp Q).

Lemma allp_uncurry: forall {A} `{NatDed A} (S T: Type) (P: S -> T -> A),
  allp (allp P) = allp (fun st => P (fst st) (snd st)).

Lemma allp_depended_uncurry': forall {A} `{NatDed A} {S: Type} {T: S -> Type} (P: forall s: S, T s -> A),
  ALL s: S, (ALL t: T s, P s t) = ALL st: sigT T, P (projT1 st) (projT2 st).

Lemma allp_uncurry': forall {A} `{NatDed A} (S T: Type) (P: S -> T -> A),
  ALL s: S, (ALL t: T, P s t) = ALL st: prod S T, P (fst st) (snd st).

Lemma allp_curry: forall {A} `{NatDed A} (S T: Type) (P: S * T -> A),
  allp P = allp (fun s => allp (fun t => P (s, t))).

Lemma exp_derives {A}{NA: NatDed A}{B}:
   forall F G: B -> A, (forall x, F x |-- G x) -> exp F |-- exp G.

Lemma exp_congr:
 forall A NA T X Y,
    (forall v, X v = Y v) -> @exp A NA T X = @exp A NA T Y.

Lemma exp_uncurry:
  forall {T} {ND: NatDed T} A B F, (@exp T ND A (fun a => @exp T ND B (fun b => F a b)))
   = @exp T ND (A*B) (fun ab => F (fst ab) (snd ab)).

Lemma exp_trivial {A}{NA: NatDed A}:
  forall {T: Type} (any: T) (P: A), exp (fun x:T => P) = P.

Lemma allp_andp: forall {A B: Type} `{NatDed A} (P Q: B -> A), allp (P && Q) = allp P && allp Q.

Lemma distrib_andp_orp: forall {A : Type} {ND : NatDed A} (P Q R : A),
  (P && Q) || R = (P || R) && (Q || R).
    
Lemma prop_derives {A}{ND: NatDed A}:
 forall (P Q: Prop), (P -> Q) -> prop P |-- prop Q.

Lemma ND_prop_ext {A}{ND: NatDed A}: forall P Q, (P <-> Q) -> !! P = !! Q.

Lemma prop_True_right {A}{NA: NatDed A}: forall P:A, P |-- !! True.

Lemma derives_refl' {A}{NA: NatDed A}: forall P Q: A, P=Q -> P |-- Q.

Lemma derives_refl'' {A}{NA: NatDed A}: forall P Q: A, Q=P -> P |-- Q.

Lemma wand_derives {A}{ND: NatDed A}{SL: SepLog A}:
    forall P P' Q Q': A , P' |-- P -> Q |-- Q' ->  P -* Q |-- P' -* Q'.

Lemma distrib_orp_andp {A}{ND: NatDed A}:
   forall (P Q R : A), andp (orp P Q) R = orp (andp P R) (andp Q R).

Lemma exp_andp1 {A}{ND: NatDed A}:  forall B (p: B -> A) q, andp (exp p) q = (exp (fun x => andp (p x) q)).

Lemma exp_sepcon1 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T (P: T ->  A) Q, sepcon (exp P) Q = exp (fun x => sepcon (P x) Q).

Lemma distrib_orp_sepcon {A}{ND: NatDed A}{SL: SepLog A}:
      forall (P Q R : A), sepcon (P || Q) R = sepcon P R || sepcon Q R.

Lemma distrib_orp_sepcon2 {A}{ND: NatDed A}{SL: SepLog A}:
  forall P Q R: A,
     R * (P || Q) = R * P || R * Q.

Lemma exp_sepcon2 {A}{NA: NatDed A}{SA: SepLog A}:
  forall T (P: A) (Q: T -> A),  P * exp Q = exp (fun x => P * Q x).

Lemma allp_sepcon1 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T (P: T ->  A) Q, sepcon (allp P) Q |-- allp (fun x => sepcon (P x) Q).

Lemma allp_sepcon2 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T P (Q: T ->  A), sepcon P (allp Q) |-- allp (fun x => sepcon P (Q x)).

Lemma exp_andp2  {A}{NA: NatDed A}:
  forall B (p: A) (q: B -> A) , (p && exp q) = exp (fun x => p && q x).

Lemma imp_derives {A} {NA: NatDed A}:
  forall P P' Q Q' : A,
    P' |-- P ->
    Q |-- Q' ->
    P --> Q |-- P' --> Q'.

Lemma imp_right2: forall {A} {NA: NatDed A} (P Q : A), P |-- Q --> P.

Lemma  distrib_sepcon_andp {A}{ND: NatDed A}{SL: SepLog A}:
     forall P Q R, sepcon P (andp Q R) |-- andp (sepcon P Q) (sepcon P R).

Lemma later_derives {A}{ND: NatDed A}{IA: Indir A}:
   forall P Q: A, P |-- Q -> later P |-- later Q.

Lemma later_andp  {A}{ND: NatDed A}{IA: Indir A}:
       forall P Q: A, later (P && Q) = later P && later Q.

Lemma later_orp  {A}{ND: NatDed A}{IA: Indir A}:
       forall P Q: A, later (P || Q) = later P || later Q.

Lemma later_left2 {T}{ND: NatDed T}{IT: Indir T}:
 forall A B C : T, A && B |-- C -> A && |> B |-- |>C.

Lemma andp_dup {A}{ND: NatDed A}: forall P: A, P && P = P.

Lemma andp_TT {A}{NA: NatDed A}: forall (P: A), P && TT = P.

Lemma TT_prop_right {A}{ND: NatDed A}: forall P: Prop,
   P -> @derives A ND TT (prop P).

Lemma sepcon_andp_prop'  {A}{NA: NatDed A}{SA: SepLog A}:
     forall (P:A)  (Q:Prop) (R: A), (!!Q && P)*R = !!Q&&(P*R).

Lemma emp_sepcon  {A}{NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A} : forall (P:A),
   emp * P = P.

Lemma emp_wand {A}{NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall P: A, emp -* P = P.

Lemma TT_andp {A}{NA: NatDed A}: forall P: A,  TT && P = P.

Lemma prop_true_andp {A} {NA: NatDed A}:
  forall (P: Prop) (Q: A),  P -> (!! P && Q = Q).

Lemma prop_true_andp' (P: Prop) {A} {NA: NatDed A}:
  forall (Q: A),  P -> (!! P && Q = Q).

Lemma TT_andp_right {A}{NA: NatDed A}:
 forall P Q, TT |-- P -> TT |-- Q -> TT |-- P && Q.

Ltac immediate := (assumption || reflexivity).

Hint Rewrite @prop_true_andp using (solve [immediate]) : norm.

Lemma true_eq {A} {NA: NatDed A}:  forall P: Prop, P -> (!! P) = (TT: A).
Hint Rewrite @true_eq using (solve [immediate]) : norm.

Hint Rewrite @andp_dup : norm.

Lemma sepcon_TT {A} {NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall (P: A), P |-- (P * TT).
Hint Resolve @sepcon_TT.

Lemma TT_sepcon {A} {NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall (P: A), P |-- (TT * P).

Lemma imp_extract_exp_left {B A: Type} {NA: NatDed A}:
    forall    (p : B -> A) (q: A),
  (forall x, p x |-- q) ->
   exp p |-- q.

Hint Rewrite @sepcon_emp @emp_sepcon @TT_andp @andp_TT
             @exp_sepcon1 @exp_sepcon2
               @exp_andp1 @exp_andp2
         @sepcon_andp_prop @sepcon_andp_prop'
     using (solve [auto with typeclass_instances])
        : norm.

Lemma forall_pred_ext  {A}  {NA: NatDed A}: forall B (P Q: B -> A),
 (ALL x : B, (P x <--> Q x)) |-- (ALL x : B, P x) <--> (ALL x: B, Q x) .

Lemma exists_pred_ext  {A} {NA: NatDed A}: forall B (P Q: B -> A),
 (ALL x : B, (P x <--> Q x)) |-- (EX x : B, P x) <--> (EX x: B, Q x) .

Lemma imp_pred_ext  {A}  {NA: NatDed A}: forall B B' P Q,
       (B <--> B') && (B --> (P <--> Q))
 |-- (B --> P) <-->  (B' --> Q).

Lemma pull_right {A} {NA: NatDed A}{SA: SepLog A}:
 forall P Q R : A,
   (Q * P * R) = (Q * R * P).

Lemma pull_right0 {A} {NA: NatDed A}{SA: SepLog A}:
  forall P Q : A,   (P * Q) = (Q * P).

Ltac pull_left A := repeat (rewrite <- (pull_right A) || rewrite <- (pull_right0 A)).

Ltac pull_right A := repeat (rewrite (pull_right A) || rewrite (pull_right0 A)).

Lemma derives_extract_prop {A} {NA: NatDed A}:
  forall (P: Prop) (Q R: A), (P -> Q |-- R) ->  !!P && Q |-- R.

Lemma derives_extract_prop0 {A}{NA: NatDed A}:
    forall (P: Prop) (R: A), (P -> TT |-- R)  -> !!P |-- R.

Lemma derives_extract_prop' {A} {NA: NatDed A}:
  forall (P: Prop) (Q R: A), (P -> Q |-- R) ->  Q && !!P|-- R.

Lemma prop_imp {A} {ND: NatDed A}: forall (P: Prop) (Q: A), P -> !! P --> Q = Q.

Lemma andp_assoc' {A}{NA: NatDed A}:
  forall P Q R : A, Q && (P && R) = P && (Q && R).

Lemma corable_andp_sepcon2{A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  (Q && P) * R = P && (Q * R).

Lemma corable_sepcon_andp1 {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  Q  * (P && R) = P && (Q * R).

Lemma corable_sepcon_andp2 {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  Q  * (R && P) = P && (Q * R).

Hint Resolve @corable_andp @corable_orp @corable_allp @corable_exp
                    @corable_imp @corable_prop @corable_sepcon @corable_wand @corable_later.
Hint Resolve @corable_prop : norm.

Lemma sepcon_left_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A} (P Q: A), corable P -> (P * Q = (P && Q) * TT).

Lemma andp_left_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P Q: A), corable P -> P && Q = (P && emp) * Q.

Lemma TT_sepcon_TT: forall {A} `{ClassicalSep A}, TT * TT = TT.

Lemma not_prop_right: forall {A} {NA: NatDed A} (P: A) (Q: Prop), (Q -> derives P FF) -> derives P (prop (not Q)).

Lemma prop_and {A} {NA: NatDed A}:
    forall P Q: Prop, prop (P /\ Q) = (prop P && prop Q).

Lemma prop_impl {A} {NA: NatDed A}:
  forall P Q: Prop, prop (P -> Q) = (prop P --> prop Q).

Lemma prop_forall {A B} {NA: NatDed A}:
  forall P: B -> Prop, prop (forall b, P b) = ALL b: B, !! P b.

Lemma sepcon_prop_prop:
  forall {A} `{ClassicalSep A} P Q, !! P * !! Q = !! (P /\ Q).

Lemma corable_sepcon_TT: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P : A), corable P -> P * TT = P.

Lemma derives_left_sepcon_right_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P Q R: A), corable P -> (Q |-- P) -> Q * R |-- P.

Lemma later_prop_andp_sepcon: forall {A: Type} {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{IA: Indir A}{CSL: CorableSepLog A} {CI: CorableIndir A} (P: Prop) (Q R: A),
((|> !! P) && Q) * R = (|> !! P) && (Q * R).

Lemma sepcon_corable_corable:
  forall {A} `{CorableSepLog A} {ClS: ClassicalSep A} P Q, corable P -> corable Q -> P * Q = P && Q.

Lemma prop_false_andp {A}{NA :NatDed A}:
 forall P Q, ~P -> !! P && Q = FF.

Lemma andp_prop_derives: forall {A} {NA: NatDed A} (P P': Prop) (Q Q': A),
  (P <-> P') ->
  (P -> Q |-- Q') ->
  !! P && Q |-- !! P' && Q'.

Lemma andp_prop_ext:
 forall {A}{NA: NatDed A} (P P': Prop) (Q Q': A),
  (P<->P') ->
  (P -> (Q=Q')) ->
  !! P && Q = !! P' && Q'.

Lemma prop_and_same_derives {A}{NA: NatDed A}:
  forall P Q, Q |-- !! P   ->   Q |-- !!P && Q.

Ltac normalize1 :=
         match goal with
            | |- _ => contradiction
            | |- context [@andp ?A (@LiftNatDed ?T ?B ?C) ?D ?E ?F] =>
                      change (@andp A (@LiftNatDed T B C) D E F) with (D F && E F)
            | |- context [@later ?A  (@LiftNatDed ?T ?B ?C) (@LiftIndir ?X1 ?X2 ?X3 ?X4 ?X5) ?D ?F] =>
                   change (@later A  (@LiftNatDed T B C) (@LiftIndir X1 X2 X3 X4 X5) D F)
                     with (@later B C X5 (D F))
            | |- context [@sepcon ?A (@LiftNatDed ?B ?C ?D)
                                                         (@LiftSepLog ?E ?F ?G ?H) ?J ?K ?L] =>
                   change (@sepcon A (@LiftNatDed B C D) (@LiftSepLog E F G H) J K L)
                      with (@sepcon C D H (J L) (K L))
            | |- context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) by (auto with norm)
            | |- context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) by (auto with norm)
            | |- context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) by (auto with norm)
            | |- context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) by (auto with norm)
                        | |- context [andp (exp (fun y => _)) _] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [andp _ (exp (fun y => _))] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [sepcon (exp (fun y => _)) _] =>
               autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [sepcon _ (exp (fun y => _))] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y

           | |-  derives ?A   _ => match A with
                          | context [ ((!! ?P) && ?Q) && ?R ] => rewrite (andp_assoc (!!P) Q R)
                          | context [ ?Q && (!! ?P && ?R)] =>
                                         match Q with !! _ => fail 2 | _ => rewrite (andp_assoc' (!!P) Q R) end
                         end
            | |- _ => progress  (autorewrite with norm); auto with typeclass_instances
            | |- _ = ?x -> _ => intro; subst x
            | |- ?x = _ -> _ => intro; subst x
            |  |- ?ZZ -> _ => match type of ZZ with
                                               | Prop =>
                                                    let H := fresh in
                                                       ((assert (H:ZZ) by auto; clear H; intros _) || intro H)
                                               | _ => intros _
                                              end
            | |- forall _, _ => let x := fresh "x" in (intro x; normalize1; try generalize dependent x)
            | |- exp _ |-- _ => apply imp_extract_exp_left
            | |- !! _ |-- _ => apply derives_extract_prop0
            | |- !! _ && _ |-- _ => apply derives_extract_prop
            | |- _ && !! _ |-- _ => apply derives_extract_prop'
            | |- _ |-- !! (?x = ?y) && _ =>
                            (rewrite prop_true_andp with (P:= (x=y))
                                            by (unfold y; reflexivity); unfold y in *; clear y) ||
                            (rewrite prop_true_andp with (P:=(x=y))
                                            by (unfold x; reflexivity); unfold x in *; clear x)
            | |- TT |-- !! _ => apply TT_prop_right
            | |- _ => solve [auto with typeclass_instances]
            end.

Ltac normalize1_in Hx :=
             match type of Hx with
                 | context [@andp ?A (@LiftNatDed ?T ?B ?C) ?D ?E ?F] =>
                         change (@andp A (@LiftNatDed T B C) D E F) with (D F && E F)
                 | context [@later ?A  (@LiftNatDed ?T ?B ?C) (@LiftIndir ?X1 ?X2 ?X3 ?X4 ?X5) ?D ?F] =>
                    change (@later A  (@LiftNatDed T B C) (@LiftIndir X1 X2 X3 X4 X5) D F)
                     with (@later B C X5 (D F))
                 | context [@sepcon ?A (@LiftNatDed ?B ?C ?D)
                                                         (@LiftSepLog ?E ?F ?G ?H) ?J ?K ?L] =>
                   change (@sepcon A (@LiftNatDed B C D) (@LiftSepLog E F G H) J K L)
                      with (@sepcon C D H (J L) (K L))
                | context [ !! ?P ] =>
                                    rewrite (true_eq P) in Hx by auto with typeclass_instances
                | context [ !! ?P && ?Q ] =>
                                    rewrite (prop_true_andp P Q) in Hx by auto with typeclass_instances
                | context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) in Hx by (auto with norm)
                | context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) in Hx by (auto with norm)
                | context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) in Hx by (auto with norm)
                | context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) in Hx by (auto with norm)
                | _ => progress  (autorewrite with norm in Hx); auto with typeclass_instances
                end.

Ltac normalize := repeat (auto with norm; normalize1).

Tactic Notation "normalize" "in" hyp(H) := repeat (normalize1_in H).

Lemma guarded_sepcon_orp_distr {A}{ND: NatDed A}{SL: SepLog A}: forall (P1 P2: Prop) p1 p2 q1 q2,
  (P1 -> P2 -> False) ->
  (!! P1 && p1 || !! P2 && p2) * (!! P1 && q1 || !! P2 && q2) = !! P1 && (p1 * q1) || !! P2 && (p2 * q2).

Definition mark {A: Type} (i: nat) (j: A) := j.

Lemma swap_mark1 {A} {NA: NatDed A}{SA: SepLog A}:
  forall i j (Pi Pj B : A), (i<j)%nat -> B * mark i Pi * mark j Pj = B * mark j Pj * mark i Pi.

Lemma swap_mark0 {A} {NA: NatDed A}{SA: SepLog A}:
  forall i j (Pi Pj: A),  (i<j)%nat -> mark i Pi * mark j Pj = mark j Pj * mark i Pi.

Ltac select_left n :=
  repeat match goal with
 | |- context [(_ * mark ?i _ * mark n _)] =>
      rewrite (swap_mark1 i n); [ | solve [simpl; auto]]
 | |- context [(mark ?i _ * mark n _)] =>
      rewrite (swap_mark0 i n); [ | solve [simpl; auto]]
end.
Ltac select_all n := match n with
                                | O => idtac
                                | S ?n' => select_left n; select_all n'
                              end.
Ltac markem n P :=
   match P with
   | (?Y * ?Z) =>
        (match goal with H: mark _ Z = Z |- _ => idtac end
        || assert (mark n Z = Z) by auto); markem (S n) Y
   | ?Z =>  match goal with H: mark _ Z = Z |- _ => idtac end
                || assert (mark n Z = Z) by auto
  end.

Ltac prove_assoc_commut :=
 clear;
 try (match goal with |- ?F _ -> ?G _ => replace G with F; auto end);
  (repeat rewrite <- sepcon_assoc;
   match goal with |- ?P = _ => markem O P end;
   let LEFT := fresh "LEFT" in match goal with |- ?P = _ => set (LEFT := P) end;
  match goal with H: mark ?n _ = _ |- _ =>
     repeat  match goal with H: mark ?n _ = ?P |- _ => rewrite <- H; clear H end;
     select_all n;
     reflexivity
   end).

Lemma test_prove_assoc_commut {T}{NA: NatDed T}{SA: SepLog T} : forall A B C D E : T,
   D * E * A * C * B = A * B * C * D * E.

Require Import VST.msl.alg_seplog.

Lemma later_fash1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall P : A, |> # P |-- # |> P.

Lemma subp_later1 {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P >=> Q)  |--   |>P >=> |>Q.

Lemma subp_later {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P >=> Q) = |>P >=> |>Q.

Lemma eqp_later1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P <=> Q)  |--   |>P <=> |>Q.

Lemma eqp_later {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall P Q: A,
    (|>(P <=> Q) = |>P <=> |>Q).

Lemma subp_refl {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P : A),
  G |-- P >=> P.

Lemma subp_trans {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P Q R: A),
  G |-- P >=> Q ->
  G |-- Q >=> R ->
  G |-- P >=> R.

Lemma subp_top {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P: A),
  G |-- P >=> TT.

Lemma subp_bot {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P: A),
  G |-- FF >=> P.

Lemma subp_andp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G {P P' Q Q': A},
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- P && Q >=> (P' && Q').

Lemma subp_imp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P P' Q Q' : A),
  G |-- P' >=> P ->
  G |-- Q >=> Q' ->
  G |-- (P --> Q) >=> (P' --> Q').

Lemma subp_orp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P P' Q Q' : A),
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- (P || Q) >=> (P' || Q').

Lemma subp_subp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
  forall G (P Q R S: A),
   G |-- (R >=> P) ->
   G |-- (Q >=> S) ->
   G |-- (P >=> Q) >=> (R >=> S).

Lemma allp_imp2_later_e2 {B}{A}{NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall (P Q: B -> A) (y: B) ,
      (ALL x:B, |> P x <=> |> Q x) |-- |> Q y >=> |> P y.

Lemma allp_imp2_later_e1 {B}{A}{NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall (P Q: B -> A) (y: B) ,
      (ALL x:B, |> P x <=> |> Q x) |-- |> P y >=> |> Q y.

Lemma prove_HOcontractive1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall X F,
  (forall P Q: X -> A,
    (ALL x:X, |>(P x >=> Q x) |--
        ALL x:X, F P x >=> F Q x)) ->
   HOcontractive F.

Lemma prove_HOcontractive {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall X F,
  (forall (P Q: X -> A) (x: X),
    (ALL x:X, (|> P x <=> |> Q x) |-- F P x >=> F Q x)) ->
   HOcontractive F.

Lemma sub_sepcon' {A}{NA: NatDed A}{SL: SepLog A}{IA: Indir A}{RA: RecIndir A}{SRA: SepRec A}:
  forall P P' Q Q': A, (P >=> P') && (Q >=> Q') |-- (P * Q) >=> (P' * Q').

Lemma subp_sepcon {A} {NA: NatDed A}{IA: Indir A}{SA: SepLog A}{SI: SepIndir A}{RA: RecIndir A}{SRA: SepRec A} :
    forall G (P P' Q Q' : A),
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- P * Q >=> P' * Q'.

Ltac sub_unfold :=
   match goal with
    | |- _ |-- ?A _ >=> ?A _ => unfold A
    | |- _ |-- ?A _ _ >=> ?A _ _ => unfold A
    | |- _ |-- ?A _ _ _ >=> ?A _ _ _ => unfold A
    | |- _ |-- ?A _ _ _ _ >=> ?A _ _ _ _ => unfold A
    | |- _ |-- ?A _ _ _ _ _ >=> ?A _ _ _ _ _ => unfold A
    | v: _ |- _ => destruct v
   end.

Hint Extern 2 (_ |-- _ >=> _) => sub_unfold : contractive.

Hint Resolve @prove_HOcontractive
  @subp_allp @subp_imp @subp_refl @subp_exp @subp_andp @subp_orp @subp_subp
  @subp_sepcon 
  @allp_imp2_later_e1 @allp_imp2_later_e2 : contractive.

Lemma  goedel_loeb {A}  {NA: NatDed A}{IA: Indir A}:
    forall P Q : A ,   Q && later P |-- P ->  Q |-- P.

Lemma HORec_sub {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall G B
  (F : A -> (B -> A) -> B -> A)
  (HF1 : forall X, HOcontractive (F X))
  (HF2 : forall R a (P Q: A), P >=> Q |-- F P R a >=> F Q R a)
  (HF3 : forall (P Q: B -> A) X, ALL b:B, |>(P b >=> Q b) |-- ALL b:B, F X P b >=> F X Q b),
  forall P Q : A,
    G |-- P >=> Q ->
    G |-- ALL b:B, HORec (F P) b >=> HORec (F Q) b.

Require Import VST.msl.ghost_seplog.

Lemma bupd_andp2_corable: forall {A N D: Type} {ND : NatDed A} {SL : SepLog A} {CSL: ClassicalSep A} {BS : BupdSepLog A N D} {CoSL: CorableSepLog A},
  forall P Q, corable Q -> (|==> P) && Q |-- |==> (P && Q). *)

Require Export VST.veric.base.

Require Import VST.veric.rmaps.
(* VST.veric.rmaps:
Require Import VST.msl.msl_standard.
Require Import VST.msl.ghost.
Require Import VST.msl.Coqlib2.
Require Import VST.veric.shares.

Module Type ADR_VAL.
Parameter address : Type.
Parameter some_address:address.

Parameter kind: Type.
End ADR_VAL.

Inductive TypeTree: Type :=
  | ConstType: Type -> TypeTree
  | Mpred: TypeTree
  | DependentType: nat -> TypeTree
  | ProdType: TypeTree -> TypeTree -> TypeTree
  | ArrowType: TypeTree -> TypeTree -> TypeTree
  | PiType: forall (I : Type), (I -> TypeTree) -> TypeTree
  | ListType: TypeTree -> TypeTree.

Definition dependent_type_functor_rec (ts: list Type): TypeTree -> functor :=
  fix dtfr (T: TypeTree): functor :=
  match T with
  | ConstType A => fconst A
  | Mpred => fidentity
  | DependentType n => fconst (nth n ts unit)
  | ProdType T1 T2 => fpair (dtfr T1) (dtfr T2)
  | ArrowType T1 T2 => ffunc (dtfr T1) (dtfr T2)
  | PiType _ f => fpi (fun i => dtfr (f i))
  | ListType T => flist (dtfr T)
  end.
Opaque dependent_type_functor_rec.

Definition dependent_type_function_rec (ts: list Type) (mpred': Type): TypeTree -> Type :=
  fix dtfr (T: TypeTree): Type :=
  match T with
  | ConstType A => A
  | Mpred => mpred'
  | DependentType n => nth n ts unit
  | ProdType T1 T2 => (dtfr T1 * dtfr T2)%type
  | ArrowType T1 T2 => dtfr T1 -> dtfr T2
  | PiType A f => forall a, dtfr (f a)
  | ListType T => list (dtfr T)
  end.

Definition fpreds: functor :=
  fsig (fun T: TypeTree =>
    fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

Lemma realize_eq: forall {A} (a b: A) P, (exists H: a = b, P H) -> {H: a = b & P H}.

Lemma lower_join_inv : forall {A} {J: Join A} a b c, lower_join J a b c <->
  match a, b, c with
  | Some a, Some b, Some c => join a b c
  | Some a, None, Some c | None, Some a, Some c => a = c
  | None, None, None => True
  | _, _, _ => False
  end.

Module Type STRAT_MODEL.
  Declare Module AV : ADR_VAL.
  Import AV.

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> fpreds PRED -> res PRED
    | PURE': kind -> fpreds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap fpreds f g pds)
      | PURE' k pds => PURE' B k (fmap fpreds f g pds)
    end.
  Axiom ff_res : functorFacts res res_fmap.
  Definition f_res : functor := Functor ff_res.

  Axiom paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Axiom ff_ghost : functorFacts ghost ghost_fmap.
  Definition f_ghost : functor := Functor ff_ghost.
  Axiom paf_ghost : @pafunctor f_ghost ghost_join.

  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Instance Join_pre_rmap (A: Type) : Join (f_pre_rmap A) :=
            Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A).

  Declare Instance Perm_pre_rmap: forall (A: Type), Perm_alg (f_pre_rmap A).
  Declare Instance Sep_pre_rmap: forall (A: Type), Sep_alg (f_pre_rmap A).
  Parameter paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap.

  Existing Instance ghost_join.
  Instance Join_res A : Join (f_res A) := res_join A.

Axiom pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End STRAT_MODEL.

Module StratModel (AV' : ADR_VAL) : STRAT_MODEL with Module AV:=AV'.
  Module AV := AV'.
  Import AV.

  Definition preds: functor :=
    fsig (fun T: TypeTree =>
      fpi (fun ts: list Type => dependent_type_functor_rec ts T)).

  Inductive res (PRED : Type) : Type :=
    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED
    | YES': forall sh: Share.t, readable_share sh -> kind -> preds PRED -> res PRED
    | PURE': kind -> preds PRED -> res PRED.

  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=
    match x with
      | NO' rsh nsh => NO' B rsh nsh
      | YES' sh rsh k pds => YES' B sh rsh k (fmap preds f g pds)
      | PURE' k pds => PURE' B k (fmap preds f g pds)
    end.

  Lemma ff_res : functorFacts res res_fmap.

  Definition f_res : functor := Functor ff_res.

  Definition paf_res : @pafunctor f_res res_join.

  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=
    match r with
      | NO' _ _ => None
      | YES' sh rsh k _ => Some (readable_part rsh,k)
      | PURE' _ _ => None 
    end.

  Definition ghost (PRED : Type) : Type :=
    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).

  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=
    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.

  Lemma ff_ghost : functorFacts ghost ghost_fmap.

  Definition f_ghost : functor := Functor ff_ghost.

  Instance preds_join PRED : Join _ := Join_equiv (fpreds PRED).

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join PRED : Join (ghost PRED) :=
  | ghost_join_nil_l m: ghost_join PRED nil m m
  | ghost_join_nil_r m: ghost_join PRED m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join PRED m1 m2 m3 ->
      ghost_join PRED (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Hint Constructors ghost_join.
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall PRED m1 m2 m3, ghost_join PRED m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join PRED m1 m2 m3 end
  end.

  Opaque fpreds.

  Definition paf_ghost : @pafunctor f_ghost ghost_join.

  Definition pre_rmap (A:Type) := ((address -> res A) * ghost A)%type.
  Definition f_pre_rmap : functor :=
    fpair (ffunc (fconst address) f_res) f_ghost.

  Notation Join_obj A := (Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A)).

  Instance Join_pre_rmap (A: Type) : Join (pre_rmap A) :=
    Join_obj A.

  Definition paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap :=
    paf_pair (paf_fun address paf_res) paf_ghost.

  Definition Perm_pre_rmap (A: Type): Perm_alg (pre_rmap A) :=
    Perm_prod (Perm_fun address _ _ _) (pa_gj A).

  Definition Sep_pre_rmap (A: Type): Sep_alg (pre_rmap A) :=
    Sep_prod (Sep_fun address _ _ _) (sa_gj A).

Lemma pre_rmap_core:
forall (A : Type) (m : f_pre_rmap A),
  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =
 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)
           (Join_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A))
           (@Sep_prod ((ffunc (fconst address) f_res) A)
              (Join_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A))
              (f_ghost A) (ghost_join A)
              (Sep_pi ((fconst address) A)
                 (fun _ : (fconst address) A => f_res A)
                 (fun _ : (fconst address) A => Join_res A)
                 (fun _ : (fconst address) A => sa_rj A)) 
              (sa_gj A)) m).

End StratModel.

Local Open Scope nat_scope.

Module Type RMAPS.
  Declare Module AV:ADR_VAL.
  Import AV.

  Parameter rmap : Type.
  Axiom Join_rmap: Join rmap. Existing Instance Join_rmap.
  Axiom Perm_rmap: Perm_alg rmap. Existing Instance Perm_rmap.
  Axiom Sep_rmap: Sep_alg rmap. Existing Instance Sep_rmap.
  Axiom ag_rmap: ageable rmap.  Existing Instance ag_rmap.
  Axiom Age_rmap: Age_alg rmap.  Existing Instance Age_rmap.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
      (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~(readable_share sh) -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Inductive res_join : resource -> resource -> resource -> Prop :=
   | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (NO sh2 nsh2) (NO sh3 nsh3)
   | res_join_NO2 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3), 
                 res_join (YES sh1 rsh1 k p) (NO sh2 nsh2) (YES sh3 rsh3 k p) 
   | res_join_NO3 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
                 res_join (NO sh1 nsh1) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p) 
   | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p
                 (RJ: join sh1 sh2 sh3),
        res_join (YES sh1 rsh1 k p) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p)
   | res_join_PURE : forall k p, res_join (PURE k p) (PURE k p) (PURE k p). 

  Instance Join_resource: Join resource := res_join.
  Axiom Perm_resource: Perm_alg resource. Existing Instance Perm_resource.
  Axiom Sep_resource: Sep_alg resource. Existing Instance Sep_resource.

  Definition preds_fmap (f g: pred rmap -> pred rmap) (x:preds) : preds :=
    match x with SomeP A Q => SomeP A (fmap (fpi _) f g Q)
    end.
  
  Axiom preds_fmap_id : preds_fmap (id _) (id _) = id preds.
  Axiom preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.
  Axiom resource_fmap_id : resource_fmap (id _) (id _) = id resource.
  Axiom resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Axiom Perm_ghost: Perm_alg ghost. Existing Instance Perm_ghost.
  Axiom Sep_ghost: Sep_alg ghost. Existing Instance Sep_ghost.
  Axiom ghost_core: forall (g: ghost), core g = nil.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Axiom ghost_fmap_id : ghost_fmap (id _) (id _) = id ghost.
  Axiom ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap' := ((address -> resource) * ghost)%type.

  Definition rmap_fmap (f g: pred rmap -> pred rmap) (x:rmap') : rmap' :=
    (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Axiom rmap_fmap_id : rmap_fmap (id _) (id _) = id rmap'.
  Axiom rmap_fmap_comp : forall f1 f2 g1 g2,
   rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Parameter squash : (nat * rmap') -> rmap.
  Parameter unsquash : rmap -> (nat * rmap').

  Axiom rmap_level_eq: @level rmap _ = fun x => fst (unsquash x).
  Axiom rmap_age1_eq: @age1 _ _ =
     fun k => match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Axiom join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Program Definition approx (n:nat) (p: pred rmap) : pred rmap :=
    fun w => level w < n /\ p w.

  Axiom squash_unsquash : forall phi, squash (unsquash phi) = phi.
  Axiom unsquash_squash : forall n rm, unsquash (squash (n,rm)) = (n,rmap_fmap (approx n) (approx n) rm).
  Axiom ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

End RMAPS.

Module Rmaps (AV':ADR_VAL): RMAPS with Module AV:=AV'.
  Module AV:=AV'.
  Import AV.

  Module SM := StratModel(AV).
  Import SM.

  Module TyF. 
    Definition F := f_pre_rmap.
  End TyF.

  Module TyFSA <: KNOT_FULL_SA_INPUT with Module KI:=TyF.
    Module KI := TyF.
    Import KI.

    Instance Join_F: forall A, Join (F A) := _.
    Definition Perm_F : forall A, Perm_alg (F A) := Perm_pre_rmap.
    Definition Sep_F := Sep_pre_rmap.
    Definition paf_F := paf_pre_rmap.
  End TyFSA.

  Module K := Knot_MixVariantHeredProp(TyF).
  Module KL := KnotLemmas_MixVariantHeredProp(K).
  Module KSa := KnotFullSa(TyFSA)(K)(KL).

  Definition rmap := K.knot.
  Instance Join_rmap: Join rmap := KSa.Join_knot.
  Instance Perm_rmap : Perm_alg rmap:= KSa.Perm_knot.
  Instance Sep_rmap : Sep_alg rmap:= KSa.Sep_knot.
  Instance ag_rmap : ageable rmap := K.ageable_knot.
  Instance Age_rmap: Age_alg rmap := KSa.asa_knot.

  Inductive preds : Type :=
    SomeP : forall A : TypeTree,
    (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.

  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).

  Inductive resource : Type :=
    | NO: forall sh: Share.t, ~ readable_share sh -> resource
    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource
    | PURE: kind -> preds -> resource.

  Definition resource2res (r: resource): res (pred rmap) :=
    match r with
      | NO sh nsh => NO' (pred rmap) sh nsh
      | YES sh rsh k (SomeP A l) => YES' (pred rmap) sh rsh k (existT _ A l)
      | PURE k (SomeP A l) => PURE' (pred rmap) k (existT _ A l)
    end.

  Definition res2resource (r: res (pred rmap)) : resource :=
    match r with
      | NO' sh nsh => NO sh nsh
      | YES' sh rsh k (existT A l) => YES sh rsh k (SomeP A l)
      | PURE' k (existT A l) => PURE k (SomeP A l)
    end.

  Lemma res2resource2res: forall x, resource2res (res2resource x) = x.

  Lemma resource2res2resource: forall x, res2resource (resource2res x) = x.

  Definition res_option (r:resource) : option (rshare * kind) :=
    match r with
      | NO _ _ => None
      | YES sh rsh k _ => Some (readable_part rsh,k)
      | PURE k _ => None
    end.

  Lemma res_option_rewrite: res_option = SM.res_option (pred rmap) oo resource2res.

  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).

  Definition pred2p (p: preds) : fpreds (pred rmap) :=
    match p with SomeP A P => existT _ A P end.

  Definition p2pred (p: fpreds (pred rmap)) : preds :=
    match p with existT A P => SomeP A P end.

  Definition ghost2g (r: ghost): SM.ghost (pred rmap) :=
    map (option_map (fun '(a, b) => (a, pred2p b))) r.

  Definition g2ghost (r: SM.ghost (pred rmap)) : ghost :=
    map (option_map (fun '(a, b) => (a, p2pred b))) r.

  Lemma g2ghost2g: forall x, ghost2g (g2ghost x) = x.

  Lemma ghost2g2ghost: forall x, g2ghost (ghost2g x) = x.

  Instance preds_join : Join _ := Join_equiv preds.

  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=
  | elem_join_I g a b c va vb vc: join a b c ->
    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))
                    (existT _ g (exist _ c vc)).
  Existing Instance ghost_elem_join.

  Inductive ghost_join : Join ghost :=
  | ghost_join_nil_l m: ghost_join nil m m
  | ghost_join_nil_r m: ghost_join m nil m
  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->
      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).
  Existing Instance ghost_join.

  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->
  match a1, a2, a3 with
  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>
      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')
  end.

  Lemma ghost_join_inv: forall m1 m2 m3, ghost_join m1 m2 m3 ->
  match m1, m2 with
  | nil, _ => m3 = m2
  | _, nil => m3 = m1
  | a1 :: m1, a2 :: m2 => match m3 with nil => False
                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join m1 m2 m3 end
  end.

  Lemma ghost_core : forall (g: ghost), core g = nil.

  Definition rmap' := ((address->resource) * ghost)%type.
  Definition preds_fmap (f g:(pred rmap)->(pred rmap)) (x:preds) : preds :=
    match x with SomeP A ls => SomeP A (fmap (fpi _) f g ls) end.

  Lemma preds_fmap_id : preds_fmap (id (pred rmap)) (id (pred rmap)) = id preds.

  Lemma preds_fmap_comp : forall f1 f2 g1 g2,
    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=
    match x with
    | NO sh nsh => NO sh nsh
    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)
    | PURE k p => PURE k (preds_fmap f g p)
    end.

  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=
    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.

  Lemma resource_fmap_id :
    resource_fmap (id (pred rmap)) (id (pred rmap)) = id resource.

  Lemma ghost_fmap_id : ghost_fmap (id (pred rmap)) (id (pred rmap)) = id ghost.

  Lemma resource_fmap_comp : forall f1 f2 g1 g2,
    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Lemma ghost_fmap_comp : forall f1 f2 g1 g2,
    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap_fmap (f g:(pred rmap)->(pred rmap)) (x:rmap') : rmap' :=
              (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).

  Lemma rmap_fmap_id : rmap_fmap (id (pred rmap)) (id (pred rmap)) = id rmap'.

  Lemma rmap_fmap_comp : forall f1 f2 g1 g2,
    rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Definition rmap'2pre_rmap (f: rmap') : f_pre_rmap (pred rmap) :=
      (fun x : address => resource2res (fst f x), ghost2g (snd f)).

  Definition pre_rmap2rmap' (f: f_pre_rmap (pred rmap)) : rmap' :=
      (fun l : address => res2resource (fst f l), g2ghost (snd f)).

  Lemma rmap'2pre_rmap2rmap' :
    forall x, rmap'2pre_rmap (pre_rmap2rmap' x) = x.

  Lemma pre_rmap2rmap'2pre_rmap :
    forall x,  pre_rmap2rmap' (rmap'2pre_rmap x) = x.

  Definition squash (n_rm:nat * rmap') : rmap :=
    match n_rm with (n,rm) => K.squash (n, rmap'2pre_rmap rm) end.

  Definition unsquash (phi:rmap) : (nat * rmap') :=
    match K.unsquash phi with (n,rm) => (n, pre_rmap2rmap' rm) end.

  Definition rmap_level (phi:rmap) : nat := fst (unsquash phi).
  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).
  Infix "@" := resource_at (at level 50, no associativity).
  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).

  Lemma pred_ext': forall {A} `{agA: ageable A} P Q,
                (forall x, app_pred P x <-> app_pred Q x) -> P = Q.

  Lemma squash_unsquash : forall phi, squash (unsquash phi) = phi.

  Program Definition approx (n:nat) (p: (pred rmap)) : (pred rmap) :=
    fun w => level w < n /\ p w.

  Lemma approx_K_approx: approx = K.approx.

  Lemma unsquash_squash : forall n rm, (unsquash (squash (n,rm))) = (n,rmap_fmap (approx n) (approx n) rm).

  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.

  Lemma g2ghost_inv: forall g1 g2, g2ghost g1 = g2ghost g2 -> g1 = g2.

  Lemma join_unsquash : forall phi1 phi2 phi3,
    join phi1 phi2 phi3 <->
    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Lemma ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

  Definition rmap_age1 (k:rmap) : option rmap :=
    match unsquash k with
    | (O,_) => None
    | (S n,x) => Some (squash (n,x))
    end.

  Definition rmap_unage (k:rmap) : rmap :=
    match unsquash k with
    | (n,x) => squash (S n, x)
    end.

  Lemma rmap_age1_knot_age1 :
    rmap_age1 = @age1 _ K.ageable_knot.

  Lemma rmap_age1_eq: @age1 _ ag_rmap = rmap_age1.

  Lemma rmap_level_eq: @level rmap ag_rmap = fun x => fst (unsquash x).

End Rmaps.
Local Close Scope nat_scope. *)

Require Import VST.veric.compcert_rmaps.  
(* VST.veric.compcert_rmaps:
Require Export VST.msl.msl_standard.
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes.
Require Import VST.veric.shares.
Require Import VST.veric.rmaps.
Require Import VST.veric.rmaps_lemmas.
Require Export VST.veric.Memory. 

Instance EqDec_type: EqDec type := type_eq.

Definition funsig := (list (ident*type) * type)%type. 

Inductive kind : Type := VAL : memval -> kind
                                   | LK : forall n i : Z, kind
                                   | FUN: funsig -> calling_convention -> kind.

Definition isVAL (k: kind) := match k with | VAL _ => True | _ => False end.
Definition isFUN (k: kind) := match k with | FUN _ _ => True | _ => False end.

Lemma isVAL_i: forall v, isVAL (VAL v).
Hint Resolve isVAL_i.

Lemma isVAL_dec: forall k, {isVAL k}+{~isVAL k}.

Module CompCert_AV <: ADR_VAL.

Definition address := address.
Definition some_address : address := (xH,0).
Definition kind := kind.

End CompCert_AV.

Lemma getVAL: forall k, {v : memval & k = VAL v}  + {~isVAL k}.

Lemma VAL_inj: forall v v', VAL v = VAL v' -> v = v'.

Module R := Rmaps (CompCert_AV).
Module RML := Rmaps_Lemmas(R).

Export RML.
Export R.

Definition mk_rshare: forall p: Share.t, pure_readable_share p -> rshare := exist pure_readable_share.
Definition rshare_sh (p: rshare) : Share.t := proj1_sig p.

Lemma mk_rshare_sh: forall (p:rshare) (H: pure_readable_share (rshare_sh p)),
  mk_rshare (rshare_sh p) H = p.

Definition fixup_splitting
  (a:address -> Share.t) (z: address -> option (rshare * kind)) : address -> option (rshare * kind) :=
  fun l => 
    match z l with
    | Some (sh, k) =>
       match dec_readable (a l) with
       | left p => Some (readable_part p,  k)
       | right _ => None
       end
    | None => None
    end.

Definition share_of (x: option (rshare * kind)) : Share.t :=
  match x with Some (p,_) => proj1_sig p | None => Share.bot end.

Definition Join_pk := (Join_lower (Join_prod rshare _ kind (Join_equiv _))).

Lemma share_of_Some: forall p: rshare * AV.kind, readable_share (share_of (Some p)).

Lemma join_sub_same_k:
 forall {a a' : rshare} {k k': AV.kind},

Lemma pure_readable_glb_Rsh:
 forall sh, pure_readable_share sh -> Share.glb Share.Rsh sh = sh.

Lemma join_glb_Rsh:  
  forall a b c : Share.t,

Lemma pure_readable_share_glb:
  forall a, pure_readable_share a -> Share.glb Share.Rsh a = a.

Lemma glb_Rsh_bot_unreadable:
  forall a, Share.glb Share.Rsh a = Share.bot -> ~readable_share a.

Lemma fixup_join : forall a (ac ad: address -> Share.t)  z,

Lemma join_share_of: forall a b c,
     @join _ Join_pk a b c -> join (share_of a) (share_of b) (share_of c).

Lemma pure_readable_share_i:
  forall sh, readable_share sh -> (pure_readable_share (Share.glb Share.Rsh sh)).

Obligation Tactic := Tactics.program_simpl.

Lemma pure_readable_Rsh: pure_readable_share Share.Rsh.

Definition rfullshare : rshare := mk_rshare _ pure_readable_Rsh.

Program Definition writable (l: address): pred rmap :=
 fun phi =>
  match phi @ l with
    | YES sh _ k lp => writable0_share sh /\ isVAL k
    | _ => False
  end.

Program Definition readable (loc: address) : pred rmap :=
   fun phi => match phi @ loc with YES _ _ k _ => isVAL k | _ => False end.

Lemma readable_join:
  forall phi1 phi2 phi3 loc, join phi1 phi2 phi3 ->
            readable loc phi1 -> readable loc phi3.

Lemma readable_writable_join:
forall phi1 phi2 l, readable l phi1 -> writable l phi2 -> joins phi1 phi2 -> False.

Lemma writable0_join_sub:
  forall sh sh', join_sub sh sh' -> writable0_share sh -> writable0_share sh'.

Lemma writable_join: forall loc phi1 phi2, join_sub phi1 phi2 ->
            writable loc phi1 -> writable loc phi2.

Lemma writable_readable: forall loc m, writable loc m -> readable loc m.

Lemma writable_e: forall loc m, 
   writable loc m -> 
   exists sh, exists rsh, exists v, exists p, 
     m @ loc = YES sh rsh (VAL v) p /\ writable0_share sh.
Arguments writable_e [loc] [m] _.

Lemma readable_e: forall loc m, 
   readable loc m -> 
  exists sh, exists rsh, exists v, exists p, m @ loc = YES sh rsh (VAL v) p.
Arguments readable_e [loc] [m] _.

Definition bytes_writable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> writable (adr_add loc i) phi.

Definition bytes_readable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> readable (adr_add loc i) phi.

Lemma readable_dec (loc: address) (phi: rmap) : {readable loc phi} + {~readable loc phi}.

Lemma writable_dec: forall loc phi, {writable loc phi}+{~writable loc phi}.

Lemma bytes_writable_dec:
   forall loc n m, {bytes_writable loc n m}+{~bytes_writable loc n m}.

Lemma bytes_readable_dec:
   forall loc n m, {bytes_readable loc n m}+{~bytes_readable loc n m}.

Lemma bytes_writable_readable:
  forall m loc n, bytes_writable m loc n -> bytes_readable m loc n.

Hint Resolve bytes_writable_readable : mem.

Lemma rmap_age_i:
 forall w w' : rmap,
    level w = S (level w') ->
   (forall l, resource_fmap (approx (level w')) (approx (level w')) (w @ l) = w' @ l) ->
    ghost_fmap (approx (level w')) (approx (level w')) (ghost_of w) = ghost_of w' ->
    age w w'. *)

Require Import VST.veric.shares. 
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)

Require Import VST.veric.address_conflict.
(* VST.veric.address_conflict:
Require Import VST.veric.base.
Require Import VST.veric.val_lemmas.
Require Import VST.veric.Memory.

Lemma range_overlap_spec: forall l1 n1 l2 n2,
  n1 > 0 ->
  n2 > 0 ->
  (range_overlap l1 n1 l2 n2 <-> adr_range l1 n1 l2 \/ adr_range l2 n2 l1).

Lemma range_overlap_comm: forall l1 n1 l2 n2, range_overlap l1 n1 l2 n2 -> range_overlap l2 n2 l1 n1.

Lemma range_overlap_non_zero: forall l1 n1 l2 n2, range_overlap l1 n1 l2 n2 -> n1 > 0 /\ n2 > 0.

Definition pointer_range_overlap p n p' n' :=
  exists l l', val2adr p l /\ val2adr p' l' /\ range_overlap l n l' n'.

Lemma pointer_range_overlap_dec: forall p1 n1 p2 n2, {pointer_range_overlap p1 n1 p2 n2} + {~ pointer_range_overlap p1 n1 p2 n2}.

Lemma pointer_range_overlap_refl: forall p n1 n2,
  isptr p ->
  n1 > 0 ->
  n2 > 0 ->
  pointer_range_overlap p n1 p n2.

Lemma pointer_range_overlap_comm: forall p1 n1 p2 n2,
  pointer_range_overlap p1 n1 p2 n2 <->
  pointer_range_overlap p2 n2 p1 n1.

Lemma pointer_range_overlap_non_zero: forall p1 n1 p2 n2,
  pointer_range_overlap p1 n1 p2 n2 -> n1 > 0 /\ n2 > 0.

Lemma pointer_range_overlap_isptr: forall p1 n1 p2 n2,
  pointer_range_overlap p1 n1 p2 n2 -> isptr p1 /\ isptr p2. *)



Import RML. Import R.

Local Open Scope pred.



Program Definition kind_at (k: kind) (l: address) : pred rmap :=

   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

 Next Obligation.

   try intro; intros.

   destruct H0 as [rsh [sh [pp ?]]].

   generalize (eq_sym (resource_at_approx a l)); intro.

   generalize (age1_resource_at a a'  H l (a@l) H1); intro.

   rewrite H0 in H2. simpl in H2. eauto.

 Qed.



Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.



Program Definition yesat_raw (pp: preds) (k: kind) 

                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=

   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

  Next Obligation.

   try intro; intros.

   apply (age1_resource_at a a' H l (YES sh rsh k pp) H0).

  Qed.



Obligation Tactic := idtac.



Program Definition yesat (pp: preds) (k: kind) : spec :=

 fun (sh: share) (l: AV.address) (m: rmap) =>

  exists rsh, yesat_raw pp k sh rsh l m.

  Next Obligation.

    intros; intro; intros.

    destruct H0 as [p ?]; exists p.

    apply pred_hereditary with a; auto.

  Qed.



Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

       fun phi => phi @ l = PURE k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

  Next Obligation.

    intros; intro; intros.

   apply (age1_resource_at a a' H l (PURE k pp) H0).

  Qed.



Ltac do_map_arg :=

match goal with |- ?a = ?b =>

  match a with context [map ?x _] =>

    match b with context [map ?y _] => replace y with x; auto end end end.



Lemma yesat_raw_eq_aux:

  forall pp k rsh sh l,

    hereditary age

    (fun phi : rmap =>

     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =

     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Proof.

 intros.

  intro; intros.

  generalize (resource_at_approx a l); intro.

  generalize (resource_at_approx a' l); intro.

  rewrite H2.

  rewrite H1 in H0.

  apply (age1_resource_at a a'  H); auto.

Qed.



Lemma yesat_raw_eq: yesat_raw =

  fun pp k rsh sh l =>

  ((exist (hereditary age)

   (fun phi =>

   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =

   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))

   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Proof.

unfold yesat_raw.

extensionality pp k rsh sh l.

apply exist_ext.

extensionality phi.

apply prop_ext; split; intros.

rewrite H.

simpl.

f_equal.

rewrite preds_fmap_fmap.

rewrite approx_oo_approx.

auto.

simpl in H.

revert H; case_eq (phi @ l); simpl; intros; inv H0.

f_equal; try apply proof_irr.

revert H4; destruct p as [?A ?p]; destruct pp as [?A ?p]; simpl; intros; auto; inv H4.

clear - H.

repeat f_equal.

revert H; unfold resource_at.  rewrite rmap_level_eq.

case_eq (unsquash phi); simpl; intros.

rename r0 into f.

pose proof I.

set (phi' := ((fun l' => if eq_dec l' l 

       then YES rsh r k (SomeP A0 (fun i => fmap _ (approx n) (approx n) (p i))) else fst f l', snd f)): rmap').

assert (phi = squash (n,phi')).

apply unsquash_inj.

replace (unsquash phi) with (unsquash (squash (unsquash phi))).

2: rewrite squash_unsquash; auto.

rewrite H.

do 2 rewrite unsquash_squash.

f_equal.

unfold phi'.

clear - H0.

simpl.

unfold rmap_fmap.

unfold compose.

f_equal.

extensionality x.

simpl.

if_tac; auto.

subst.

rewrite H0.

simpl.

do 2 apply f_equal.

extensionality.

rewrite fmap_app.

rewrite approx_oo_approx; auto.

subst phi.

unfold phi' in H.

rewrite unsquash_squash in H.

injection H; clear H; intros.

destruct f; simpl in *; inv H.

generalize (equal_f H3 l); intro.

rewrite H0 in H.

clear - H.

unfold compose in H. rewrite if_true in H; auto.

simpl in H.

revert H; generalize p at 2 3.

intros q ?H.

apply YES_inj in H.

match goal with

| H: ?A = ?B |- _ =>

  assert (snd A = snd B)

end.

rewrite H; auto.

simpl in H0.

apply SomeP_inj2 in H0.

subst q.

extensionality i.

rewrite fmap_app.

rewrite approx_oo_approx. auto.

Qed.



Lemma yesat_eq_aux: 

  forall pp k sh l, 

    hereditary age

    (fun m : rmap =>

      exists rsh, 

     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =

     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Proof.

 intros.

  intro; intros.

  destruct H0 as [p ?]; exists p.

  rewrite resource_at_approx.

  rewrite resource_at_approx in H0.

  apply (age1_resource_at a a' H); auto.

Qed.



Lemma yesat_eq: yesat = fun pp k sh l =>

 exist (hereditary age)

  (fun m => 

  exists rsh, 

   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 

   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))

   (yesat_eq_aux pp k sh l).

Proof.

unfold yesat.

extensionality pp k sh l.

apply exist_ext. extensionality w.

apply exists_ext; intro p.

rewrite yesat_raw_eq.

auto.

Qed.



Lemma map_compose_approx_succ_e:

  forall A n pp pp',

       map (compose (A:=A) (approx (S n))) pp =

    map (compose (A:=A) (approx (S n))) pp' ->

  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Proof.

induction pp; intros.

destruct pp'; inv H; auto.

destruct pp'; inv H; auto.

simpl.

rewrite <- (IHpp pp'); auto.

replace (approx n oo a) with (approx n oo p); auto.

clear - H1.

extensionality x.

apply pred_ext'. extensionality w.

generalize (equal_f H1 x); clear H1; intro.

unfold compose in *.

assert (approx (S n) (a x) w <-> approx (S n) (p x) w).

rewrite H; intuition.

simpl.

apply and_ext'; auto; intros.

apply prop_ext.

intuition.

destruct H3; auto.

split; auto.

destruct H2; auto.

split; auto.

Qed.



Program Definition noat (l: AV.address) : pred rmap :=

    fun m => identity (m @ l).

 Next Obligation.

    intros; intro; intros.

    apply (age1_resource_at_identity _ _ l H); auto.

 Qed.



Definition resource_share (r: resource) : option share :=

 match r with

 | YES sh _ _ _ => Some sh

 | NO sh _ => Some sh

 | PURE _ _ => None

 end.



Definition nonlock (r: resource) : Prop :=

 match r with

 | YES _ _ k _ => isVAL k \/ isFUN k

 | NO _ _ => True

 | PURE _ _ => False

 end.



Lemma age1_nonlock: forall phi phi' l,

  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Proof.

  intros.

  destruct (phi @ l) as [rsh | rsh sh k P |] eqn:?H.

  + pose proof (age1_NO phi phi' l rsh n H).

    rewrite H1 in H0.

    rewrite H0.

    reflexivity.

  + pose proof (age1_YES' phi phi' l rsh sh k H).

    destruct H1 as [? _].

    spec H1; [eauto |].

    destruct H1 as [P' ?].

    rewrite H1.

    reflexivity.

  + pose proof (age1_PURE phi phi' l k H).

    destruct H1 as [? _].

    spec H1; [eauto |].

    destruct H1 as [P' ?].

    rewrite H1.

    reflexivity.

Qed.



Lemma age1_resource_share: forall phi phi' l,

  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Proof.

  intros.

  destruct (phi @ l) as [rsh | rsh sh k P |] eqn:?H.

  + pose proof (age1_NO phi phi' l rsh n H).

    rewrite H1 in H0.

    rewrite H0.

    reflexivity.

  + pose proof (age1_YES' phi phi' l rsh sh k H).

    destruct H1 as [? _].

    spec H1; [eauto |].

    destruct H1 as [P' ?].

    rewrite H1.

    reflexivity.

  + pose proof (age1_PURE phi phi' l k H).

    destruct H1 as [? _].

    spec H1; [eauto |].

    destruct H1 as [P' ?].

    rewrite H1.

    reflexivity.

Qed.



Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,

  resource_share r1 = Some sh1 ->

  resource_share r2 = Some sh2 ->

  join r1 r2 r ->

  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Proof.

  intros.

  destruct r1, r2; try solve [inversion H | inversion H0];

  inv H; inv H0; inv H1;

  eexists; split; eauto.

Qed.



Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,

  resource_share r1 = Some sh1 ->

  resource_share r2 = Some sh2 ->

  join r1 r2 r ->

  join sh1 sh2 sh ->

  resource_share r = Some sh.

Proof.

  intros.

  destruct (resource_share_join_exists _ _ _ _ _ H H0 H1) as [sh' [? ?]].

  rewrite H4.

  f_equal.

  eapply join_eq; eauto.

Qed.



Lemma resource_share_joins: forall r1 r2 sh1 sh2,

  resource_share r1 = Some sh1 ->

  resource_share r2 = Some sh2 ->

  joins r1 r2 ->

  joins sh1 sh2.

Proof.

  intros.

  destruct H1 as [r ?].

  destruct (resource_share_join_exists _ _ _ _ _ H H0 H1) as [sh [? ?]].

  exists sh.

  auto.

Qed.



Lemma nonlock_join: forall r1 r2 r,

  nonlock r1 ->

  nonlock r2 ->

  join r1 r2 r ->

  nonlock r.

Proof.

  intros.

  destruct r1, r2; inv H1; auto.

Qed.



Program Definition nonlockat (l: AV.address): pred rmap :=

  fun m => nonlock (m @ l).

 Next Obligation.

    intros; intro; intros.

    unfold resource_share in *.

    destruct (a @ l) eqn:?H.

    + rewrite (necR_NO a a' l _ n) in H1 by (constructor; auto).

      rewrite H1; assumption.

    + eapply necR_YES in H1; [ | constructor; eassumption].

      rewrite H1; assumption.

    + eapply necR_PURE in H1; [ | constructor; eassumption].

      rewrite H1; assumption.

 Qed.



Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

  fun m => resource_share (m @ l) = Some sh.

 Next Obligation.

    intros; intro; intros.

    unfold resource_share in *.

    destruct (a @ l) eqn:?H.

    + rewrite (necR_NO a a' l _ n) in H1 by (constructor; auto).

      rewrite H1; assumption.

    + eapply necR_YES in H1; [ | constructor; eassumption].

      rewrite H1; assumption.

    + inv H0.

 Qed.



Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=

  fun (l: B) m => if S l then P l m else Q l m.

 Next Obligation.

    intros; intro; intros.

  if_tac; try (eapply pred_hereditary; eauto).

 Qed.



Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Proof.

intros.

apply pred_ext'.

extensionality m; unfold jam.

simpl. rewrite if_true; auto.

Qed.



Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Proof.

intros.

apply pred_ext'.

extensionality m; unfold jam.

simpl; rewrite if_false; auto.

Qed.



Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,

      (forall (x: A), boxy m (P x)) ->

      (forall x, boxy m (Q x)) ->

      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Proof.

  intros.

   unfold boxy in *.

   apply pred_ext; intros w ?.

   unfold jam in *.

   simpl in *; if_tac. rewrite <- H . simpl. apply H1.

   rewrite <- H0; simpl; apply H1.

   simpl in *; if_tac.

    rewrite <- H in H1; auto.

   rewrite <- H0 in H1; auto.

Qed.



Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),

      (forall (x: A), boxy extendM (P x)) ->

      (forall x, boxy extendM (Q x)) ->

      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Proof.

  apply boxy_jam; auto.

Qed.



Definition jam_vacuous:

  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Proof.

intros.

extensionality l; apply pred_ext'; extensionality w.

unfold jam.

simpl; rewrite if_false; auto.

Qed.



Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),

  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->

  {w' | level w' = level w /\ resource_at w' =

       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Proof.

  intros.

  apply remake_rmap.

  intros.

    if_tac; [left; eauto |].

    destruct (w @ l) eqn:?H; rewrite ?core_NO, ?core_YES, ?core_PURE; simpl; auto.

    left.

    exists w; split; auto.

    apply ghost_of_approx.

Qed.



Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=

  forall l w, (p l) w = q (w @ l) l (level w).



Definition resource_stable (p: address -> pred rmap) :=

  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.



Lemma is_resource_pred_resource_stable: forall {p},

  (exists q, is_resource_pred p q) -> resource_stable p.

Proof.

  unfold is_resource_pred, resource_stable.

  intros.

  destruct H as [q ?]; rewrite !H.

  rewrite H0; auto.

Qed.



Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Next Obligation.

Proof.

  intros ????.

  rewrite (age1_ghost_of _ _ H), (identity_core H0), ghost_core; simpl.

  rewrite <- (ghost_core nil); apply core_identity.

Defined.



Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)

  (P_DEC: forall l, {P l} + {~ P l})

  (Q_DEC: forall l, {Q l} + {~ Q l})

  (R_DEC: forall l, {R l} + {~ R l}),

  (exists resp, is_resource_pred p resp) ->

  (exists resp, is_resource_pred q resp) ->

  (exists resp, is_resource_pred r resp) ->

  Ensemble_join Q R P ->

  (forall l, Q l -> p l = q l) ->

  (forall l, R l -> p l = r l) ->

  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->

  allp (jam P_DEC p noat) && noghost =

  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Proof.

  intros until R_DEC.

  intros ST_P ST_Q ST_R.

  intros [? ?] ? ? ?.

  apply pred_ext; intros w; simpl; intros.

  + destruct (make_sub_rmap w Q Q_DEC) as [w1 [? ?]].

    {

      intros. eapply H3; [| | eauto].

      + firstorder.

      + destruct H4; specialize (H4 l); if_tac in H4; [auto | firstorder].

    }

    destruct (make_sub_rmap w R R_DEC) as [w2 [? ?]].

    {

      intros. eapply H3; [| | eauto].

      + firstorder.

      + destruct H4; specialize (H4 l); if_tac in H4; [auto | firstorder].

    }

    exists w1, w2.

    split3; auto.

    - apply resource_at_join2; try congruence.

      intro l.

      destruct H6, H8.

      rewrite H6, H8.

      pose proof core_unit (w @ l).

      destruct (Q_DEC l), (R_DEC l).

      * firstorder.

      * apply join_comm; auto.

      * auto.

      * destruct H4; specialize (H4 l).

        rewrite if_false in H4 by firstorder.

        rewrite identity_core by auto.

        apply core_duplicable.

      * destruct H6 as [_ ->], H8 as [_ ->].

        destruct H4; apply identity_unit'; auto.

    - split.

      intros l.

      destruct H4; specialize (H4 l).

      if_tac.

      * rewrite <- H1 by auto.

        rewrite if_true in H4 by firstorder.

        erewrite <- (is_resource_pred_resource_stable ST_P); [eauto | | auto].

        destruct H6; rewrite H6, if_true by auto; auto.

      * destruct H6; rewrite H6, if_false by auto.

        apply core_identity.

      * destruct H4, H6 as [_ ->]; auto.

    - split.

      intros l.

      destruct H4; specialize (H4 l).

      if_tac.

      * rewrite <- H2 by auto.

        rewrite if_true in H4 by firstorder.

        erewrite <- (is_resource_pred_resource_stable ST_P); [eauto | | auto].

        destruct H8; rewrite H8, if_true by auto; auto.

      * destruct H8; rewrite H8, if_false by auto.

        apply core_identity.

      * destruct H4, H8 as [_ ->]; auto.

  + destruct H4 as [y [z [? [[? Hg1] [? Hg2]]]]].

    split; intros.

    specialize (H5 b); specialize (H6 b).

    if_tac.

    - if_tac in H5; if_tac in H6.

      * firstorder.

      * rewrite H1 by auto.

        erewrite (is_resource_pred_resource_stable ST_Q); [eauto | | apply join_level in H4; symmetry; tauto].

        apply resource_at_join with (loc := b) in H4.

        apply join_comm, H6 in H4.

        auto.

      * rewrite H2 by auto; auto.

        erewrite (is_resource_pred_resource_stable ST_R); [eauto | | apply join_level in H4; symmetry; tauto].

        apply resource_at_join with (loc := b) in H4.

        apply H5 in H4.

        auto.

      * firstorder.

    - rewrite if_false in H5 by firstorder.

      rewrite if_false in H6 by firstorder.

      apply resource_at_join with (loc := b) in H4.

      apply H5 in H4; rewrite <- H4; auto.

    - apply ghost_of_join in H4.

      rewrite <- (Hg1 _ _ H4); auto.

Qed.



Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)

  (P_DEC: forall l, {P l} + {~ P l})

  (Q_DEC: forall l, {Q l} + {~ Q l}),

  (exists resp, is_resource_pred p resp) ->

  (exists resp, is_resource_pred q resp) ->

  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->

  (exists l, P l /\ Q l) ->

  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Proof.

  intros.

  intro w; simpl; intros.

  destruct H3 as [w1 [w2 [? [? ?]]]].

  destruct H2 as [l ?].

  specialize (H4 l).

  specialize (H5 l).

  rewrite if_true in H4, H5 by tauto.

  apply (H1 l w1 w2); auto.

  eauto.

Qed.



Lemma yesat_join_diff:

  forall pp pp' k k' sh sh' l w, k <> k' -> 

                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Proof.

unfold yesat, yesat_raw; intros.

destruct H0 as [p ?]. destruct H1 as [p' ?].

simpl in *; inversion2 H0 H1.

contradiction H; auto.

Qed.



Lemma yesat_raw_join:

  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

   join sh1 sh2 sh3 ->

   yesat_raw pp k sh1 rsh1 l phi1 ->

   yesat_raw pp k sh2 rsh2 l phi2 ->

   join phi1 phi2 phi3 ->

   yesat_raw pp k sh3 rsh3 l phi3.

Proof.

unfold yesat_raw;

intros until 1; rename H into HR; intros.

simpl in H,H0|-*.

assert (level phi2 = level phi3) by (apply join_level in H1; intuition).

rewrite H2 in *; clear H2.

assert (level phi1 = level phi3) by  (apply join_level in H1; intuition).

rewrite H2 in *; clear H2.

generalize (resource_at_join _ _ _ l H1); clear H1.

revert H H0.

case_eq (phi1 @ l); intros; try discriminate.

inv H0.

revert H1 H2; case_eq (phi2 @ l); intros; try discriminate.

inv H1.

inv H2.

inv H0.

pose proof (join_eq HR RJ). subst sh5. clear RJ.

repeat proof_irr. auto.

Qed.



Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),

  nonunit x -> join x y z -> nonunit z.

Proof.

intros.

intro; intro.

apply unit_identity in H1.

apply split_identity in H0; auto.

apply nonunit_nonidentity in H.

contradiction.

Qed.



Lemma yesat_join:

  forall pp k sh1 sh2 sh3 l m1 m2 m3,

   join sh1 sh2 sh3 ->   

   yesat pp k sh1 l m1 ->

   yesat pp k sh2 l m2 ->

   join m1 m2 m3 ->

   yesat pp k sh3 l m3.

Proof.

intros.

destruct H0 as [p1 ?].

destruct H1 as [p2 ?].

assert (p3: readable_share sh3).

eapply join_readable1; eauto.

exists p3.

eapply yesat_raw_join with (phi1 := m1); eauto.

Qed.



Definition spec_parametric (Q: address -> spec) : Prop :=

   forall l l', exists pp, exists ok,

             forall sh m,

           Q l sh l' m = 

            (exists p, exists k, ok k /\ m @ l' = 

                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).



Lemma YES_ext:

  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Proof.

intros. subst. f_equal. apply proof_irr.

Qed.



Definition VALspec : spec :=

       fun (sh: Share.t) (l: address) =>

          allp (jam (eq_dec l)

                                  (fun l' => EX v: memval, 

                                                yesat NoneP (VAL v) sh l')

                                  noat) && noghost.



Definition VALspec_range (n: Z) : spec :=

     fun (sh: Share.t) (l: address) =>

          andp (allp (jam (adr_range_dec l n)

                                  (fun l' => EX v: memval, 

                                                yesat NoneP (VAL v) sh l')

                                  noat)) noghost.



Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=

  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.



Definition nthbyte (n: Z) (l: list memval) : memval :=

     nth (nat_of_Z n) l Undef.



Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=

        fun (sh: Share.t) (l: AV.address)  => 

             allp (jam (adr_range_dec l (size_chunk ch)) 

                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')

                           noat).



Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=

        fun (sh: Share.t) (l: AV.address) =>

           EX bl: list memval, 

               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&

                (allp (jam (adr_range_dec l (size_chunk ch))

                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)

                                    noat)) && noghost.



Lemma address_mapsto_align: forall ch v sh l,

  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Proof.

  intros.

  pose proof (@add_andp (pred rmap) _); simpl in H. apply H; clear H.

  unfold address_mapsto.

  apply exp_left; intro.

  do 2 apply andp_left1.

  intros ? [? [? ?]].

  auto.

Qed.



Lemma address_mapsto_fun:

  forall ch sh sh' l v v',

          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Proof.

intros.

intros m [? ?]. unfold prop.

destruct H as [m1 [m2 [J [[bl [[[Hlen [? _]] ?] Hg]] _]]]].

destruct H0 as [m1' [m2' [J' [[bl' [[[Hlen' [? _]] ?] Hg']] _]]]].

subst.

assert (forall i, nth_error bl i = nth_error bl' i).

intro i; specialize( H1 (fst l, snd l + Z_of_nat i)); specialize( H2 (fst l, snd l + Z_of_nat i)).

unfold jam in *.

destruct l as [b z].

simpl in *.

if_tac in H1.

destruct H as [_ ?].

replace (z + Z_of_nat i - z) with (Z_of_nat i) in * by omega.

assert ((i < length bl)%nat).

rewrite Hlen.

rewrite size_chunk_conv in H.

omega.

rewrite <- Hlen' in Hlen.

rewrite nat_of_Z_eq in *.

destruct H1; destruct H2.

unfold yesat_raw in *.

repeat rewrite preds_fmap_NoneP in *.

assert (H5: nth i bl Undef = nth i bl' Undef).

apply (resource_at_join _ _ _ (b,z + Z_of_nat i)) in J.

apply (resource_at_join _ _ _ (b,z + Z_of_nat i)) in J'.

rewrite H1 in J; rewrite H2 in J'; clear H1 H2.

inv J; inv J'; try congruence.

clear - Hlen H0 H5.

revert bl bl' Hlen H0 H5; induction i; destruct bl; destruct bl'; simpl; intros; auto; try omegaContradiction.

apply IHi; auto.

omega.

assert (~ (i < length bl)%nat).

contradict H.

split; auto.

rewrite Hlen in H.

rewrite size_chunk_conv.

omega.

assert (i >= length bl)%nat by omega.

destruct (nth_error_length i bl).

rewrite H5; auto.

destruct (nth_error_length i bl').

rewrite H7; auto.

omega.

clear - H.

assert (bl=bl'); [| subst; auto].

revert bl' H; induction bl; destruct bl'; intros; auto.

specialize (H 0%nat); simpl in H. inv H.

specialize (H 0%nat); simpl in H. inv H.

f_equal.

specialize (H 0%nat); simpl in H. inv H. auto.

apply IHbl.

intro.

specialize( H (S i)).

simpl in H.

auto.

simpl; auto.

Qed.



Definition LKspec lock_size (R: pred rmap) : spec :=

   fun (sh: Share.t) (l: AV.address)  =>

    allp (jam (adr_range_dec l lock_size)

               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')

               noat) && noghost.



Definition TTat (l: address) : pred rmap := TT.



Lemma address_mapsto_old_parametric: forall ch v, 

   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Proof.

intros.

exists NoneP. exists (fun k => k= VAL (nthbyte (snd l' - snd l) (encode_val ch v))).

intros.

unfold yesat.

apply exists_ext; intro p.

unfold yesat_raw.

simpl.

apply prop_ext; split; intros.

econstructor; split; [reflexivity | ].

rewrite H; f_equal.



simpl.

eauto.

destruct H as [k [? ?]].

subst; auto.

Qed.



Lemma VALspec_parametric: 

  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Proof.

intros.

exists NoneP.

exists (fun k => exists v, k=VAL v).

intros.

unfold yesat.

apply prop_ext; split; intros.

destruct H as [v [p ?]].

exists p.

exists (VAL v).

split; eauto.

destruct H as [p [k [[v ?] ?]]].

subst.

exists v.

exists p.

auto.

Qed.



Lemma LKspec_parametric lock_size: forall R: pred rmap,

  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Proof.

intros.

unfold jam.

intro; intros.

simpl.

exists (SomeP Mpred (fun _ => R)).

exists (fun k => k = LK lock_size (snd l' - snd l)).

intros.

apply exists_ext; intro p.

apply prop_ext; split; intros.

rewrite H.

econstructor.  split; eauto.



destruct H as [k [? ?]].

subst; auto.

Qed.



Definition val2address (v: val) : option AV.address := 

  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.



Lemma VALspec_readable:

  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.



Proof.

unfold VALspec, readable;

intros.

destruct H as [w1 [w2 [? [[? ?] _]]]].

specialize ( H0 l).

unfold jam in H0.

hnf in H0|-*; rewrite if_true in H0 by auto.

destruct H0 as [v [p ?]].

unfold yesat_raw in H0.

generalize (resource_at_join _ _ _ l H); rewrite H0; intro Hx.

inv Hx; auto.

Qed.



Lemma address_mapsto_VALspec:

  forall ch v sh l i, 0 <= i < size_chunk ch ->

        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Proof.

intros. intros w ?.

pose (f l' := if eq_dec (adr_add l i) l' then w @ l' 

                   else if adr_range_dec l (size_chunk ch) l' then NO Share.bot bot_unreadable else w @ l').

pose (g l' := if eq_dec (adr_add l i) l' then NO Share.bot bot_unreadable else w @ l').

exploit (deallocate (w) f g); intros.

*

unfold f,g; clear f g.

destruct H0 as [b [[? ?] Hg]]. specialize (H1 l0).  hnf in H1.

if_tac in H1. destruct H1.  hnf in H1. if_tac; rewrite H1; constructor.

apply join_unit2; auto.

apply join_unit1; auto.

if_tac.

contradiction H2. unfold adr_add in H3; destruct l; destruct l0; simpl in H3. inv H3.

split; auto. omega.

do 3 red in H1. apply identity_unit' in H1. auto.

*

apply join_comm, core_unit.

*

destruct H1 as [phi1 [phi2 [? ?]]].

destruct (join_ex_identities w) as [e [? ?]].

exists phi1; exists phi2.

split; auto.

split; auto.

unfold VALspec; split.

intro l'.

unfold jam in *.

destruct H0 as [bl [[H0' ?] Hg]].

specialize ( H0 l').

unfold jam in H0.

hnf in H0|-*; if_tac.

subst l'.

rewrite if_true in H0.

destruct H0.

unfold yesat_raw in H0.

destruct H2 as [H2 _].

pose proof (equal_f H2 (adr_add l i)).

unfold f in H5.

rewrite if_true in H5.

rewrite H0 in H5.

exists (nth (nat_of_Z (snd (adr_add l i) - snd l)) bl Undef).

exists x.

unfold yesat_raw.

hnf in H0|-*.

repeat rewrite preds_fmap_NoneP in *.

auto.

destruct l; unfold adr_range, adr_add. split; auto.

destruct l; unfold adr_range, adr_add. split; auto.

simpl; omega.

do 3 red.

destruct H2 as [-> _]. unfold f.

rewrite if_false; auto.

if_tac. apply NO_identity. apply H0.

simpl; destruct H2 as [_ ->].

destruct H0 as [bl [[H0' ?] Hg]]; auto.

Qed.



Lemma address_mapsto_exists:

  forall ch v sh (rsh: readable_share sh) loc w0

      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

      (Hg: identity (ghost_of w0)),

      (align_chunk ch | snd loc) ->

      exists w, address_mapsto ch (decode_val ch (encode_val ch v)) sh loc w 

                    /\ core w = core w0.

Proof.

intros. rename H into Halign.

unfold address_mapsto.

pose (f l' := if adr_range_dec loc (size_chunk ch) l'

                     then YES sh rsh (VAL (nthbyte (snd l' - snd loc) (encode_val ch v))) NoneP

                     else core w0 @ l').

pose proof I.

destruct (make_rmap f (ghost_of w0) (level w0)) as [phi [? ?]].

extensionality l; unfold f, compose; simpl.

if_tac; simpl; auto.

rewrite <- level_core.

apply resource_at_approx.

{ apply ghost_of_approx. }

exists phi.

split.

+ exists (encode_val ch v).

  split; [split|].

  split; auto.

  apply encode_val_length.

  intro l'.

  unfold jam.

  hnf.

  unfold yesat, yesat_raw, noat.

  unfold app_pred, proj1_sig. destruct H1; rewrite H1; clear H H1.

  unfold f; clear f.

  if_tac.

  exists rsh.

  f_equal.

  rewrite <- core_resource_at.

  apply core_identity.

  simpl.

  destruct H1 as [_ ->]; auto.

+ apply rmap_ext. do 2 rewrite level_core. auto.

  intro l; specialize (RESERVE l).

  rewrite <- core_resource_at. destruct H1. rewrite H1. unfold f.

  if_tac.

  rewrite core_YES.

  rewrite <- core_resource_at. rewrite RESERVE; auto.

  rewrite core_NO; auto.

  rewrite <- core_resource_at; rewrite core_idem; auto.

  { rewrite <- core_ghost_of.

    destruct H1 as [_ ->].

    rewrite core_ghost_of; auto. }

Qed.



Lemma VALspec1: VALspec_range 1 = VALspec.

Proof.

unfold VALspec, VALspec_range.

extensionality sh l.

f_equal; f_equal.

unfold jam.

extensionality l'.

apply exist_ext; extensionality m.

symmetry.

if_tac.

 subst l'. rewrite if_true; auto.

destruct l; split; auto; omega.

rewrite if_false; auto.

destruct l; destruct l'; unfold block in *; intros [? ?]; try omega.

subst.

contradict H. f_equal; omega.

Qed.



Lemma VALspec_range_exp_address_mapsto:

  forall ch sh l,

    (align_chunk ch | snd l) ->

    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Proof.

  intros.

  intros w ?.

  destruct H0 as [H0 Hg].

  simpl in H0 |- *.

  cut (exists (b0 : list memval),

     length b0 = size_chunk_nat ch /\

     (forall b1 : address,

      if adr_range_dec l (size_chunk ch) b1

      then

       exists rsh: readable_share sh,

         w @ b1 =

         YES sh rsh

           (VAL (nth (nat_of_Z (snd b1 - snd l)) b0 Undef))

           (SomeP (ConstType unit) (fun _ => tt))

      else identity (w @ b1))).

  {

    intros.

    destruct H1 as [b0 [? ?]].

    exists (decode_val ch b0), b0.

    tauto.

  }

  rewrite !size_chunk_conv in *.

  forget (size_chunk_nat ch) as n; clear - H0.



  cut (exists b0 : list memval,

     length b0 = n /\

     (forall b1 : address,

        adr_range l (Z.of_nat n) b1 ->

       exists rsh: readable_share sh,

         w @ b1 =

         YES sh rsh

           (VAL (nth (nat_of_Z (snd b1 - snd l)) b0 Undef))

           (SomeP (ConstType unit) (fun _ => tt)))).

  {

    intros.

    destruct H as [b0 H].

    exists b0.

    split; [tauto |].

    intros b; specialize (H0 b).

    if_tac; [apply (proj2 H) |]; auto.

  }



  assert (forall b : address,

    adr_range l (Z.of_nat n) b ->

        exists (b0 : memval) (rsh : readable_share sh),

          w @ b =

          YES sh rsh (VAL b0)

            (SomeP (ConstType unit) (fun _ => tt))).

  {

    intros.

    specialize (H0 b).

    if_tac in H0; tauto.

  }

  clear H0.



  destruct l as [bl ofs].

  revert ofs H; induction n; intros.

  + exists nil.

    split; auto.

    intros b.

    specialize (H b).

    auto.

    intros.

    apply adr_range_non_zero in H0.

    simpl in H0; omega.

  + specialize (IHn (ofs + 1)).

    spec IHn.

    - clear - H; intros b; specialize (H b).

      intros; spec H; auto.

      apply adr_range_shift_1; auto.

    - assert (adr_range (bl, ofs) (Z.of_nat (S n)) (bl, ofs))

        by (rewrite Nat2Z.inj_succ; repeat split; auto; omega).

      destruct (H _ H0) as [b_hd ?H]; clear H0.

      destruct IHn as [b_tl ?H].

      exists (b_hd :: b_tl).

      split; [simpl; omega |]; destruct H0 as [_ ?].

      intros.

      apply adr_range_S_split in H2.

      destruct H2.

      * destruct (H0 b1 H2) as [p ?H].

        destruct b1; destruct H2 as [_ ?].

        exists p; clear - H2 H3.

        unfold snd in *.

        replace (nat_of_Z (z - ofs)) with (S (nat_of_Z (z - (ofs + 1)))); [exact H3 |].

        unfold nat_of_Z.

        replace (z - ofs) with (Z.succ (z - (ofs + 1))) by omega.

        rewrite Z2Nat.inj_succ; auto.

        omega.

      * subst. rewrite Z.sub_diag. simpl nth.

        exact H1.

Qed.



Lemma address_mapsto_VALspec_range:

  forall ch v sh l,

        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Proof.

intros.

intros w ?. unfold VALspec_range.

destruct H as [bl [[Hbl ?] Hg]].

split; auto.

intro l'.

specialize ( H l').

unfold jam in *.

hnf in H|-*. if_tac; auto.

exists (nth (nat_of_Z (snd l' - snd l)) bl Undef).

destruct H as [p ?].

exists p.

auto.

Qed.



Lemma approx_eq_i:

  forall (P Q: pred rmap) (w: rmap),

      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Proof.

intros.

apply pred_ext'; extensionality m'.

unfold approx.

apply and_ext'; auto; intros.

destruct (level_later_fash _ _ H0) as [m1 [? ?]].

specialize (H _ H1).

specialize (H m').

spec H.

rewrite H2; auto.

destruct H; apply prop_ext. intuition.

Qed.



Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},

         laterR (level w) n' ->

       exists w', laterR w w' /\ n' = level w'.

Proof.

intros.

remember (level w) as n.

revert w Heqn; induction H0; intros; subst.

case_eq (age1 w); intros.

exists a; split. constructor; auto.

symmetry; unfold age in H0; simpl in H0.

  unfold natAge1 in H0; simpl in H0. revert H0; case_eq (level w); intros; inv H2.

  apply age_level in H1. congruence. rewrite age1_level0 in H1.

   rewrite H1 in H0. inv H0.

 specialize (IHclos_trans1 _ (refl_equal _)).

  destruct IHclos_trans1 as [w2 [? ?]].

  subst.

  specialize (IHclos_trans2 _ (refl_equal _)).

  destruct IHclos_trans2 as [w3 [? ?]].

  subst.

  exists w3; split; auto. econstructor 2; eauto.

Qed.



Lemma VALspec_range_bytes_readable:

  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Proof.

intros; intro; intros.

destruct H.

specialize ( H (adr_add loc i)).

hnf in H.

rewrite if_true in H.

destruct H as [v [p ?]].

hnf in H.

red. red. red.

rewrite H; auto.

destruct loc; split; unfold adr_add; auto.

simpl. omega.

Qed.



Lemma VALspec_range_bytes_writable:

  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Proof.

intros; intro; intros.

destruct H0.

specialize ( H0 (adr_add loc i)).

hnf in H0.

rewrite if_true in H0.

destruct H0 as [v [p ?]].

hnf in H0.

do 3 red.

rewrite H0; auto with extensionality.

destruct loc; split; unfold adr_add; auto.

simpl. omega.

Qed.



Lemma yesat_join_sub:

  forall pp k l sh m m',

          join_sub m m' ->

          yesat pp k sh l m ->

         exists sh', yesat pp k sh' l m'.

Proof.

intros.

destruct H0.

unfold yesat_raw in H0.

generalize (resource_at_join_sub _ _ l H); rewrite H0; intro.

assert (level m = level m').

destruct H; apply join_level in H; intuition.

destruct H1.

destruct x0; case_eq (m' @ l); intros; rewrite H3 in H1; inv H1.

do 2 econstructor. unfold yesat_raw. simpl. rewrite <- H2.  eapply H3.

exists sh1.

unfold yesat. simpl.

exists r0.

rewrite <- H2. rewrite H3.

subst; f_equal; auto.

Qed.



Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Proof.

intros.

intro; intros.

apply rmap_ext; auto.

1: destruct H1,H2; apply join_level in H1; apply join_level in H2; intuition.

intro.

destruct H as [H Hg], H0 as [H0 Hg0].

specialize (H l0); specialize (H0 l0).

unfold jam in *.

hnf in H, H0. if_tac in H.

+ destruct H as [v [p ?]].

  destruct H0 as [v' [p' ?]].

  unfold yesat_raw in *.

  generalize (resource_at_join_sub _ _ l0 H1); rewrite H; clear H1; intro.

  generalize (resource_at_join_sub _ _ l0 H2); rewrite H0; clear H2; intro.

  f_equal. auto with extensionality.

  clear - H1 H2.

  destruct H1; destruct H2.

  simpl in *.

  f_equal.

  inv H0; inv H; congruence.

+ do 3 red in H,H0.

  apply (resource_at_join_sub _ _ l0) in H1.

  eapply join_sub_same_identity; eauto.

  * apply identity_unit'; auto.

  * apply (resource_at_join_sub _ _ l0) in H2.

    eapply join_sub_unit_for; eauto.

    apply identity_unit'; auto.

+ destruct H as [H Hg], H0 as [H0 Hg0].

  eapply same_identity; auto.

  * destruct H1 as [? H1%ghost_of_join].

    rewrite (Hg _ _ H1) in H1; eauto.

  * destruct H2 as [? H2%ghost_of_join].

    rewrite (Hg0 _ _ H2) in H2; eauto.

Qed.



Lemma nonlock_permission_bytes_precise: forall sh p n,

  precise (nonlock_permission_bytes sh p n).

Proof.

  intros.

  intro; intros.

  destruct H as [H Hg], H0 as [H0 Hg0].

  apply rmap_ext; auto.

  1: destruct H1,H2; apply join_level in H1; apply join_level in H2; intuition.

  intro.

  specialize (H l); specialize (H0 l).

  unfold jam in *.

  hnf in H, H0. if_tac in H.

  + unfold shareat, nonlockat in H, H0; simpl in H, H0.

    apply (resource_at_join_sub _ _ l) in H1.

    apply (resource_at_join_sub _ _ l) in H2.

    destruct H as [? _], H0 as [? _].

    clear - H H0 H1 H2.

    destruct H1 as [b1 H1], H2 as [b2 H2].

    destruct (w1 @ l), (w2 @ l); inv H1; inv H2; simpl in *;

    repeat match goal with H: Some _ = Some _ |- _ => inv H end;

    repeat f_equal; try apply proof_irr; try congruence;

    try contradiction.

  + do 3 red in H,H0.

    apply (resource_at_join_sub _ _ l) in H1.

    eapply join_sub_same_identity; eauto.

    * apply identity_unit'; auto.

    * apply (resource_at_join_sub _ _ l) in H2.

      eapply join_sub_unit_for; eauto.

      apply identity_unit'; auto.

  + eapply same_identity; auto.

    * destruct H1 as [? H1%ghost_of_join].

      rewrite (Hg _ _ H1) in H1; eauto.

    * destruct H2 as [? H2%ghost_of_join].

      rewrite (Hg0 _ _ H2) in H2; eauto.

Qed.



Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Proof.

intros.

apply (derives_precise _ _ (address_mapsto_VALspec_range ch v sh l)).

apply VALspec_range_precise.

Qed.



Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Proof.

intros.

intro; intros.

assert (level w1 = level w2) as Hlevel.

{ destruct H1,H2; apply join_level in H1; apply join_level in H2; intuition. }

destruct H as [H Hg], H0 as [H0 Hg0].

apply rmap_ext; auto; intros.

-

specialize (H l0); specialize (H0 l0).

simpl in *.

if_tac in H0.

destruct H. destruct H0. rewrite H,H0.

f_equal. proof_irr. auto.

rewrite Hlevel; auto.

apply (resource_at_join_sub _ _ l0) in H1.

  eapply join_sub_same_identity; eauto.

  * apply identity_unit'; auto.

  * apply (resource_at_join_sub _ _ l0) in H2.

    eapply join_sub_unit_for; eauto.

    apply identity_unit'; auto.

-

 eapply same_identity; auto.

    * destruct H1 as [? H1%ghost_of_join].

      rewrite (Hg _ _ H1) in H1; eauto.

    * destruct H2 as [? H2%ghost_of_join].

      rewrite (Hg0 _ _ H2) in H2; eauto.

Qed.



Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=

  EX bl: list memval,

  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&

    allp (jam (adr_range_dec l (size_chunk ch))

      (fun l' phi => exists sh, exists rsh, phi @ l' 

        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)

      (fun _ _ => True)).

 Next Obligation.

    intros; intro; intros.

  destruct H0 as [sh [rsh ?]]; exists sh, rsh.

    apply (age1_YES a a'); auto.

  Qed.

  Next Obligation.     intros; intro; intros. auto.

  Qed.



Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)

  : pred rmap :=

  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&

    allp (jam (adr_range_dec l (size_chunk ch))

      (fun l' phi => exists sh, exists rsh, phi @ l' 

        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)

      (fun _ _ => True)).

 Next Obligation.

    intros; intro; intros.

  destruct H0 as [sh [rsh ?]]; exists sh, rsh.

    apply (age1_YES a a'); auto.

  Qed.

  Next Obligation.     intros; intro; intros. auto.

  Qed.



Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.

Proof.

 intros.

 apply pred_ext.

 - intros ? [? ?]. simpl in H.

   do 3 red.

   apply all_resource_at_identity; auto.

   intro l. specialize (H l).

   rewrite if_false in H; auto.

   destruct loc, l; intros [? ?]; simpl in *; omega.

 - intros ? ?. split. intro b. rewrite jam_false.

   do 3 red. apply resource_at_identity; auto.

   destruct loc, b; intros [? ?]; simpl in *; omega.

   apply ghost_of_identity; auto.

Qed.

Hint Resolve VALspec_range_0: normalize.



Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Proof.

  intros.

  apply pred_ext.

  + intros ? [? ?]. simpl in H.

    do 3 red.

    apply all_resource_at_identity; auto.

    intro l. specialize (H l).

    rewrite if_false in H; auto.

    destruct a, l; intros [? ?]; simpl in *; omega.

  + intros ? ?. split. intro b. rewrite jam_false.

    do 3 red. apply resource_at_identity; auto.

    destruct a, b; intros [? ?]; simpl in *; omega.

    apply ghost_of_identity; auto.

Qed.



Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,

  ~ nonunit sh ->

  nonlock_permission_bytes sh p n |-- emp.

Proof.

  intros.

  assert (sh = Share.bot).

  {

    destruct (dec_share_identity sh).

    + apply identity_share_bot; auto.

    + apply nonidentity_nonunit in n0; tauto.

  }

  subst.

  intros ? ?. simpl in H.

  do 3 red.

  destruct H0.

  apply all_resource_at_identity; auto.

  intro l.

  specialize (H0 l); simpl in H0.

  if_tac in H0; [| auto].

  destruct H0.

  destruct (a @ l); inv H0.

  + apply NO_identity. 

  + contradiction (bot_unreadable r).

Qed.



Lemma is_resource_pred_YES_VAL sh:

  is_resource_pred

    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')

    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)

        (SomeP (ConstType unit) (fun _ => tt)))).

Proof. hnf; intros. reflexivity. Qed.



Lemma is_resource_pred_YES_VAL' sh v:

  is_resource_pred

    (fun l' => yesat NoneP (VAL (v l')) sh l')

    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))

        (SomeP (ConstType unit) (fun _ => tt)))).

Proof. hnf; intros. reflexivity. Qed.



Lemma is_resource_pred_nonlock_shareat sh:

  is_resource_pred

    (fun i : address => shareat i sh && nonlockat i)

    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Proof. hnf; intros. reflexivity. Qed.



Lemma VALspec_range_split2:

  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

    r = n + m -> n >= 0 -> m >= 0 ->

    VALspec_range r sh (b, ofs) = 

    VALspec_range n sh (b, ofs) * VALspec_range m sh (b, ofs + n).

Proof.

  intros.

  assert (exists resp, is_resource_pred (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l') resp) by (eexists; apply is_resource_pred_YES_VAL).

  apply allp_jam_split2; auto.

  + split; intros [? ?]; unfold adr_range.

    - assert (ofs <= z < ofs + r <-> ofs <= z < ofs + n \/ ofs + n <= z < ofs + n + m) by omega.

      tauto.

    - omega.

  + intros.

    simpl in H4.

    destruct (m0 @ l); try solve [inversion H5; simpl; auto].

    destruct H4 as [? [? ?]].

    inversion H4; subst.

    inversion H5; subst.

    auto.

Qed.



Lemma nonlock_permission_bytes_split2:

  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

    r = n + m -> n >= 0 -> m >= 0 ->

    nonlock_permission_bytes sh (b, ofs) r =

    nonlock_permission_bytes sh (b, ofs) n *

    nonlock_permission_bytes sh (b, ofs + n) m.

Proof.

  intros.

  assert (exists resp, is_resource_pred (fun i : address => shareat i sh && nonlockat i) resp) by (eexists; apply is_resource_pred_nonlock_shareat).

  apply allp_jam_split2; auto.

  + split; intros [? ?]; unfold adr_range.

    - assert (ofs <= z < ofs + r <-> ofs <= z < ofs + n \/ ofs + n <= z < ofs + n + m) by omega.

      tauto.

    - omega.

  + intros.

    destruct H4 as [_ ?].

    simpl in H4.

    destruct (m0 @ l); inv H5.

    simpl in H4; auto.

Qed.



Lemma VALspec_range_VALspec:

  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

       0 <= i < n ->

       VALspec_range n sh l

       |-- VALspec sh (adr_add l i) * TT.

Proof.

 intros.

  destruct l as [b ofs].

  rewrite (VALspec_range_split2 i (n-i) n sh b ofs); try omega.

  rewrite (VALspec_range_split2 1 (n-i-1) (n-i) sh b (ofs+i)); try omega.

  change (VALspec_range 1) with (VALspec_range 1).

  rewrite VALspec1.

  rewrite <- sepcon_assoc.

  rewrite (sepcon_comm (VALspec_range i sh (b, ofs))).

  rewrite sepcon_assoc.

  apply sepcon_derives; auto.

Qed.



Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,

  adr_range p1 n1 p2 ->

  n2 > 0 ->

  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Proof.

  intros.

  intros w [w1 [w2 [? [[? Hg1] [? Hg2]]]]].

  specialize ( H2 p2).

  specialize ( H3 p2).

  rewrite jam_true in H2 by auto.

  rewrite jam_true in H3 by (destruct p2; simpl; split; auto; omega).

  destruct H2; destruct H3. hnf in H2,H3.

  apply (resource_at_join _ _ _ p2) in H1.

  destruct H2, H3.

  rewrite H2, H3 in H1.

  clear - x1 H1; simpl in H1.

  inv H1.

  clear - x1 RJ.

  generalize (join_self' RJ); intro. subst sh3.

  apply readable_nonidentity in x1.

  apply x1. apply identity_unit_equiv. apply RJ.

Qed.



Lemma address_mapsto_overlap':

  forall sh ch1 v1 ch2 v2 a1 a2,

     adr_range a1 (size_chunk ch1) a2 ->

     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Proof.

  intros.

  eapply derives_trans; [eapply sepcon_derives | apply VALspec_range_overlap'].

  + apply address_mapsto_VALspec_range.

  + apply address_mapsto_VALspec_range.

  + auto.

  + apply size_chunk_pos.

Qed.



Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,

  range_overlap l1 n1 l2 n2 ->

  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Proof.

  intros.

  pose proof range_overlap_non_zero _ _ _ _ H.

  apply range_overlap_spec in H; try tauto.

  destruct H.

  + apply VALspec_range_overlap'; tauto.

  + rewrite sepcon_comm.

    apply VALspec_range_overlap'; tauto.

Qed.



Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,

  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->

  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Proof.

  intros.

  apply range_overlap_spec in H; try apply size_chunk_pos.

  destruct H.

  + apply address_mapsto_overlap'; auto.

  + rewrite sepcon_comm.

    apply address_mapsto_overlap'; auto.

Qed.



Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Proof.

  intros.

  destruct H as [sh' ?].

  apply nonunit_nonidentity in H0; contradiction H0.

  eapply join_self; eauto.

Qed.



Lemma nonlock_permission_bytes_overlap:

  forall sh n1 n2 p1 p2,

  nonunit sh ->

  range_overlap p1 n1 p2 n2 ->

  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Proof.

  intros.

  eapply derives_trans; [apply sepcon_derives; apply andp_left1, derives_refl|].

  apply allp_jam_overlap.

  + eexists. apply is_resource_pred_nonlock_shareat.

  + eexists. apply is_resource_pred_nonlock_shareat.

  + unfold shareat; simpl; intros.

    destruct H3 as [w ?].

    apply (resource_at_join _ _ _ l) in H3.

    pose proof resource_share_joins (w1 @ l) (w2 @ l) sh sh.

    do 2 (spec H4; [tauto |]).

    spec H4; [firstorder |].

    apply (share_joins_self sh); auto.

  + auto.

Qed.



Lemma address_mapsto_value_cohere':

  forall ch v1 v2 sh1 sh2 a r

 (Hmaps1 : address_mapsto ch v1 sh1 a r)

 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Proof.

 intros.

 destruct Hmaps1 as [b1 [[[Hlen1 [? ?]] Hall1] Hg1]].

 destruct Hmaps2 as [b2 [[[Hlen2 [? ?]] Hall2] Hg2]].

 assert (b1 = b2); [ | subst; auto].

 clear - Hlen1 Hlen2 Hall1 Hall2.

 rewrite size_chunk_conv in *.

 forget (size_chunk_nat ch) as n. clear ch.

 assert (forall i, nth_error b1 i = nth_error b2 i).

 intro.

 destruct a as [b z].

 specialize (Hall1 (b, (z+Z.of_nat i))).

 specialize (Hall2 (b, (z+Z.of_nat i))).

 hnf in Hall1,Hall2. if_tac in Hall1. destruct H as [_ [_ ?]].

 destruct Hall1 as (? & Hall1), Hall2 as (? & Hall2). simpl in Hall1, Hall2.

 rewrite Hall1 in Hall2; inversion Hall2.

 replace (z + Z.of_nat i - z) with (Z.of_nat i) in H2 by omega.

 rewrite Nat2Z.id in H2.

 rewrite nth_error_nth with (z:=Undef) by omega.

 rewrite nth_error_nth with (z:=Undef) by omega.

 f_equal; auto.

 assert (~(i<n)%nat).

 contradict H. split; auto. omega.

 transitivity (@None memval); [ | symmetry];

 apply nth_error_length; omega.

 clear - H Hlen1 Hlen2.

 revert b1 b2 Hlen1 Hlen2 H.

 induction n; destruct b1,b2; intros; auto; inv Hlen1; inv Hlen2.

 f_equal.

 specialize (H O). simpl in H. inv H; auto.

 apply IHn; auto.

 intro i; specialize (H (S i)); apply H.

Qed.



Lemma address_mapsto_value_cohere:

  forall ch v1 v2 sh1 sh2 a,

 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Proof.

 intros.

 intros w [w1 [w2 [? [? ?]]]]. hnf.

 destruct H0 as [b1 [[[? [? ?]] ?] Hg1]].

 destruct H1 as [b2 [[[? [? ?]] ?] Hg2]].

 assert (b1 = b2); [ | subst; auto].

 clear - H H0 H4 H1 H7.

 rewrite size_chunk_conv in *.

 forget (size_chunk_nat ch) as n. clear ch.

 assert (forall i, nth_error b1 i = nth_error b2 i).

 intro.

 destruct a as [b z].

 specialize (H4 (b, (z+Z.of_nat i))).

 specialize (H7 (b, (z+Z.of_nat i))).

 hnf in H4,H7. if_tac in H4. destruct H2 as [_ [_ ?]].

 destruct H4, H7. hnf in H3,H4.

 apply (resource_at_join _ _ _ (b, z + Z.of_nat i)) in H.

 rewrite H3,H4 in H. inv  H.

 clear - H2 H10 H1.

 replace (z + Z.of_nat i - z) with (Z.of_nat i) in H10 by omega.

 rewrite Nat2Z.id in H10.

 rewrite nth_error_nth with (z:=Undef) by omega.

 rewrite nth_error_nth with (z:=Undef) by omega.

 f_equal; auto.

 assert (~(i<n)%nat).

 contradict H2. split; auto. omega.

 transitivity (@None memval); [ | symmetry];

 apply nth_error_length; omega.

 clear - H2 H0 H1.

 revert b1 b2 H0 H1 H2.

 induction n; destruct b1,b2; intros; auto; inv H0; inv H1.

 f_equal.

 specialize (H2 O). simpl in H2. inv H2; auto.

 apply IHn; auto.

 intro i; specialize (H2 (S i)); apply H2.

Qed.



Definition almost_empty rm: Prop:=

  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.



Definition no_locks phi :=

  forall addr sh sh' z z' P,

phi @ addr <> YES sh sh' (LK z z') P.



