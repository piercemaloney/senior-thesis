

Require Import Coqlib.

Require Import Maps.

Require Import AST.

Require Import Integers.

Require Import Values.

Require Import Memory.

Require Import Events.

Require Import Smallstep.

Require Import Globalenvs.

Require Import Switch.

Require Import Registers.

Require Import Cminor.
(* Cminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Events.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Switch.

Inductive constant : Type :=
  | Ointconst: int -> constant     
  | Ofloatconst: float -> constant 
  | Olongconst: int64 -> constant  
  | Oaddrsymbol: ident -> int -> constant 
  | Oaddrstack: int -> constant.   

Inductive unary_operation : Type :=
  | Ocast8unsigned: unary_operation        
  | Ocast8signed: unary_operation          
  | Ocast16unsigned: unary_operation       
  | Ocast16signed: unary_operation         
  | Onegint: unary_operation               
  | Onotint: unary_operation               
  | Onegf: unary_operation                 
  | Oabsf: unary_operation                 
  | Osingleoffloat: unary_operation        
  | Ointoffloat: unary_operation           
  | Ointuoffloat: unary_operation          
  | Ofloatofint: unary_operation           
  | Ofloatofintu: unary_operation          
  | Onegl: unary_operation                 
  | Onotl: unary_operation                 
  | Ointoflong: unary_operation            
  | Olongofint: unary_operation            
  | Olongofintu: unary_operation           
  | Olongoffloat: unary_operation          
  | Olonguoffloat: unary_operation         
  | Ofloatoflong: unary_operation          
  | Ofloatoflongu: unary_operation         
  | Osingleoflong: unary_operation         
  | Osingleoflongu: unary_operation.       

Inductive binary_operation : Type :=
  | Oadd: binary_operation                 
  | Osub: binary_operation                 
  | Omul: binary_operation                 
  | Odiv: binary_operation                 
  | Odivu: binary_operation                
  | Omod: binary_operation                 
  | Omodu: binary_operation                
  | Oand: binary_operation                 
  | Oor: binary_operation                  
  | Oxor: binary_operation                 
  | Oshl: binary_operation                 
  | Oshr: binary_operation                 
  | Oshru: binary_operation                
  | Oaddf: binary_operation                
  | Osubf: binary_operation                
  | Omulf: binary_operation                
  | Odivf: binary_operation                
  | Oaddl: binary_operation                
  | Osubl: binary_operation                
  | Omull: binary_operation                
  | Odivl: binary_operation                
  | Odivlu: binary_operation               
  | Omodl: binary_operation                
  | Omodlu: binary_operation               
  | Oandl: binary_operation                
  | Oorl: binary_operation                 
  | Oxorl: binary_operation                
  | Oshll: binary_operation                
  | Oshrl: binary_operation                
  | Oshrlu: binary_operation               
  | Ocmp: comparison -> binary_operation   
  | Ocmpu: comparison -> binary_operation  
  | Ocmpf: comparison -> binary_operation  
  | Ocmpl: comparison -> binary_operation  
  | Ocmplu: comparison -> binary_operation. 

Inductive expr : Type :=
  | Evar : ident -> expr
  | Econst : constant -> expr
  | Eunop : unary_operation -> expr -> expr
  | Ebinop : binary_operation -> expr -> expr -> expr
  | Eload : memory_chunk -> expr -> expr.

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sassign : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Stailcall: signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> list (int * nat) -> nat -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list ident;
  fn_stackspace: Z;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.
Definition program := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t val.

Fixpoint set_params (vl: list val) (il: list ident) {struct il} : env :=
  match il, vl with
  | i1 :: is, v1 :: vs => PTree.set i1 v1 (set_params vs is)
  | i1 :: is, nil => PTree.set i1 Vundef (set_params nil is)
  | _, _ => PTree.empty val
  end.

Fixpoint set_locals (il: list ident) (e: env) {struct il} : env :=
  match il with
  | nil => e
  | i1 :: is => PTree.set i1 Vundef (set_locals is e)
  end.

Definition set_optvar (optid: option ident) (v: val) (e: env) : env :=
  match optid with
  | None => e
  | Some id => PTree.set id v e
  end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> val -> env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (sp: val)                  
             (e: env)                   
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Section RELSEM.

Variable ge: genv.

Definition eval_constant (sp: val) (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  | Oaddrsymbol s ofs =>
      Some(match Genv.find_symbol ge s with
           | None => Vundef
           | Some b => Vptr b ofs end)
  | Oaddrstack ofs => Some (Val.add sp (Vint ofs))
  end.

Definition eval_unop (op: unary_operation) (arg: val) : option val :=
  match op with
  | Ocast8unsigned => Some (Val.zero_ext 8 arg)
  | Ocast8signed => Some (Val.sign_ext 8 arg)
  | Ocast16unsigned => Some (Val.zero_ext 16 arg)
  | Ocast16signed => Some (Val.sign_ext 16 arg)
  | Onegint => Some (Val.negint arg)
  | Onotint => Some (Val.notint arg)
  | Onegf => Some (Val.negf arg)
  | Oabsf => Some (Val.absf arg)
  | Osingleoffloat => Some (Val.singleoffloat arg)
  | Ointoffloat => Val.intoffloat arg
  | Ointuoffloat => Val.intuoffloat arg
  | Ofloatofint => Val.floatofint arg
  | Ofloatofintu => Val.floatofintu arg
  | Onegl => Some (Val.negl arg)
  | Onotl => Some (Val.notl arg)
  | Ointoflong => Some (Val.loword arg)
  | Olongofint => Some (Val.longofint arg)
  | Olongofintu => Some (Val.longofintu arg)
  | Olongoffloat => Val.longoffloat arg
  | Olonguoffloat => Val.longuoffloat arg
  | Ofloatoflong => Val.floatoflong arg
  | Ofloatoflongu => Val.floatoflongu arg
  | Osingleoflong => Val.singleoflong arg
  | Osingleoflongu => Val.singleoflongu arg
  end.

Definition eval_binop
            (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
  match op with
  | Oadd => Some (Val.add arg1 arg2)
  | Osub => Some (Val.sub arg1 arg2)
  | Omul => Some (Val.mul arg1 arg2)
  | Odiv => Val.divs arg1 arg2
  | Odivu => Val.divu arg1 arg2
  | Omod => Val.mods arg1 arg2
  | Omodu => Val.modu arg1 arg2
  | Oand => Some (Val.and arg1 arg2)
  | Oor => Some (Val.or arg1 arg2)
  | Oxor => Some (Val.xor arg1 arg2)
  | Oshl => Some (Val.shl arg1 arg2)
  | Oshr => Some (Val.shr arg1 arg2)
  | Oshru => Some (Val.shru arg1 arg2)
  | Oaddf => Some (Val.addf arg1 arg2)
  | Osubf => Some (Val.subf arg1 arg2)
  | Omulf => Some (Val.mulf arg1 arg2)
  | Odivf => Some (Val.divf arg1 arg2)
  | Oaddl => Some (Val.addl arg1 arg2)
  | Osubl => Some (Val.subl arg1 arg2)
  | Omull => Some (Val.mull arg1 arg2)
  | Odivl => Val.divls arg1 arg2
  | Odivlu => Val.divlu arg1 arg2
  | Omodl => Val.modls arg1 arg2
  | Omodlu => Val.modlu arg1 arg2
  | Oandl => Some (Val.andl arg1 arg2)
  | Oorl => Some (Val.orl arg1 arg2)
  | Oxorl => Some (Val.xorl arg1 arg2)
  | Oshll => Some (Val.shll arg1 arg2)
  | Oshrl => Some (Val.shrl arg1 arg2)
  | Oshrlu => Some (Val.shrlu arg1 arg2)
  | Ocmp c => Some (Val.cmp c arg1 arg2)
  | Ocmpu c => Some (Val.cmpu (Mem.valid_pointer m) c arg1 arg2)
  | Ocmpf c => Some (Val.cmpf c arg1 arg2)
  | Ocmpl c => Val.cmpl c arg1 arg2
  | Ocmplu c => Val.cmplu c arg1 arg2
  end.

Section EVAL_EXPR.

Variable sp: val.
Variable e: env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      PTree.get id e = Some v ->
      eval_expr (Evar id) v
  | eval_Econst: forall cst v,
      eval_constant sp cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk addr vaddr v,
      eval_expr addr vaddr ->
      Mem.loadv chunk m vaddr = Some v ->
      eval_expr (Eload chunk addr) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k sp e m,
      step (State f Sskip (Kseq s k) sp e m)
        E0 (State f s k sp e m)
  | step_skip_block: forall f k sp e m,
      step (State f Sskip (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f Sskip k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef k m')

  | step_assign: forall f id a k sp e m v,
      eval_expr sp e m a v ->
      step (State f (Sassign id a) k sp e m)
        E0 (State f Sskip k sp (PTree.set id v e) m)

  | step_store: forall f chunk addr a k sp e m vaddr v m',
      eval_expr sp e m addr vaddr ->
      eval_expr sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k sp e m)
        E0 (State f Sskip k sp e m')

  | step_call: forall f optid sig a bl k sp e m vf vargs fd,
      eval_expr sp e m a vf ->
      eval_exprlist sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k sp e m)
        E0 (Callstate fd vargs (Kcall optid f sp e k) m)

  | step_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      eval_expr (Vptr sp Int.zero) e m a vf ->
      eval_exprlist (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Stailcall sig a bl) k (Vptr sp Int.zero) e m)
        E0 (Callstate fd vargs (call_cont k) m')

  | step_builtin: forall f optid ef bl k sp e m vargs t vres m',
      eval_exprlist sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k sp e m)
         t (State f Sskip k sp (set_optvar optid vres e) m')

  | step_seq: forall f s1 s2 k sp e m,
      step (State f (Sseq s1 s2) k sp e m)
        E0 (State f s1 (Kseq s2 k) sp e m)

  | step_ifthenelse: forall f a s1 s2 k sp e m v b,
      eval_expr sp e m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k sp e m)
        E0 (State f (if b then s1 else s2) k sp e m)

  | step_loop: forall f s k sp e m,
      step (State f (Sloop s) k sp e m)
        E0 (State f s (Kseq (Sloop s) k) sp e m)

  | step_block: forall f s k sp e m,
      step (State f (Sblock s) k sp e m)
        E0 (State f s (Kblock k) sp e m)

  | step_exit_seq: forall f n s k sp e m,
      step (State f (Sexit n) (Kseq s k) sp e m)
        E0 (State f (Sexit n) k sp e m)
  | step_exit_block_0: forall f k sp e m,
      step (State f (Sexit O) (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_exit_block_S: forall f n k sp e m,
      step (State f (Sexit (S n)) (Kblock k) sp e m)
        E0 (State f (Sexit n) k sp e m)

  | step_switch: forall f a cases default k sp e m n,
      eval_expr sp e m a (Vint n) ->
      step (State f (Sswitch a cases default) k sp e m)
        E0 (State f (Sexit (switch_target n default cases)) k sp e m)

  | step_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn None) k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k sp e m v m',
      eval_expr (Vptr sp Int.zero) e m a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn (Some a)) k (Vptr sp Int.zero) e m)
        E0 (Returnstate v (call_cont k) m')

  | step_label: forall f lbl s k sp e m,
      step (State f (Slabel lbl s) k sp e m)
        E0 (State f s k sp e m)

  | step_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k sp e m)
        E0 (State f s' k' sp e m)

  | step_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k (Vptr sp Int.zero) e m')
  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f sp e k m,
      step (Returnstate v (Kcall optid f sp e k) m)
        E0 (State f Sskip k sp (set_optvar optid v e) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p).

Lemma semantics_receptive:
  forall (p: program), receptive (semantics p).

Inductive outcome: Type :=
  | Out_normal: outcome                
  | Out_exit: nat -> outcome           
  | Out_return: option val -> outcome  
  | Out_tailcall_return: val -> outcome. 

Definition outcome_block (out: outcome) : outcome :=
  match out with
  | Out_exit O => Out_normal
  | Out_exit (S n) => Out_exit n
  | out => out
  end.

Definition outcome_result_value
    (out: outcome) (retsig: option typ) (vres: val) : Prop :=
  match out with
  | Out_normal => vres = Vundef
  | Out_return None => vres = Vundef
  | Out_return (Some v) => retsig <> None /\ vres = v
  | Out_tailcall_return v => vres = v
  | _ => False
  end.

Definition outcome_free_mem
    (out: outcome) (m: mem) (sp: block) (sz: Z) (m': mem) :=
  match out with
  | Out_tailcall_return _ => m' = m
  | _ => Mem.free m sp 0 sz = Some m'
  end.

Section NATURALSEM.

Variable ge: genv.

Inductive eval_funcall:
        mem -> fundef -> list val -> trace ->
        mem -> val -> Prop :=
  | eval_funcall_internal:
      forall m f vargs m1 sp e t e2 m2 out vres m3,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      exec_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t e2 m2 out ->
      outcome_result_value out f.(fn_sig).(sig_res) vres ->
      outcome_free_mem out m2 sp f.(fn_stackspace) m3 ->
      eval_funcall m (Internal f) vargs t m3 vres
  | eval_funcall_external:
      forall ef m args t res m',
      external_call ef ge args m t res m' ->
      eval_funcall m (External ef) args t m' res

with exec_stmt:
         function -> val ->
         env -> mem -> stmt -> trace ->
         env -> mem -> outcome -> Prop :=
  | exec_Sskip:
      forall f sp e m,
      exec_stmt f sp e m Sskip E0 e m Out_normal
  | exec_Sassign:
      forall f sp e m id a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sassign id a) E0 (PTree.set id v e) m Out_normal
  | exec_Sstore:
      forall f sp e m chunk addr a vaddr v m',
      eval_expr ge sp e m addr vaddr ->
      eval_expr ge sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      exec_stmt f sp e m (Sstore chunk addr a) E0 e m' Out_normal
  | exec_Scall:
      forall f sp e m optid sig a bl vf vargs fd t m' vres e',
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      eval_funcall m fd vargs t m' vres ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Scall optid sig a bl) t e' m' Out_normal
  | exec_Sbuiltin:
      forall f sp e m optid ef bl t m' vargs vres e',
      eval_exprlist ge sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Sbuiltin optid ef bl) t e' m' Out_normal
  | exec_Sifthenelse:
      forall f sp e m a s1 s2 v b t e' m' out,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      exec_stmt f sp e m (if b then s1 else s2) t e' m' out ->
      exec_stmt f sp e m (Sifthenelse a s1 s2) t e' m' out
  | exec_Sseq_continue:
      forall f sp e m t s1 t1 e1 m1 s2 t2 e2 m2 out,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 s2 t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sseq s1 s2) t e2 m2 out
  | exec_Sseq_stop:
      forall f sp e m t s1 s2 e1 m1 out,
      exec_stmt f sp e m s1 t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sseq s1 s2) t e1 m1 out
  | exec_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2 e2 m2 out,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 (Sloop s) t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sloop s) t e2 m2 out
  | exec_Sloop_stop:
      forall f sp e m t s e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sloop s) t e1 m1 out
  | exec_Sblock:
      forall f sp e m s t e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      exec_stmt f sp e m (Sblock s) t e1 m1 (outcome_block out)
  | exec_Sexit:
      forall f sp e m n,
      exec_stmt f sp e m (Sexit n) E0 e m (Out_exit n)
  | exec_Sswitch:
      forall f sp e m a cases default n,
      eval_expr ge sp e m a (Vint n) ->
      exec_stmt f sp e m (Sswitch a cases default)
                E0 e m (Out_exit (switch_target n default cases))
  | exec_Sreturn_none:
      forall f sp e m,
      exec_stmt f sp e m (Sreturn None) E0 e m (Out_return None)
  | exec_Sreturn_some:
      forall f sp e m a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sreturn (Some a)) E0 e m (Out_return (Some v))
  | exec_Stailcall:
      forall f sp e m sig a bl vf vargs fd t m' m'' vres,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      eval_funcall m' fd vargs t m'' vres ->
      exec_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t e m'' (Out_tailcall_return vres).

Scheme eval_funcall_ind2 := Minimality for eval_funcall Sort Prop
  with exec_stmt_ind2 := Minimality for exec_stmt Sort Prop.
Combined Scheme eval_funcall_exec_stmt_ind2
  from eval_funcall_ind2, exec_stmt_ind2.

CoInductive evalinf_funcall:
        mem -> fundef -> list val -> traceinf -> Prop :=
  | evalinf_funcall_internal:
      forall m f vargs m1 sp e t,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      execinf_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t ->
      evalinf_funcall m (Internal f) vargs t

with execinf_stmt:
         function -> val -> env -> mem -> stmt -> traceinf -> Prop :=
  | execinf_Scall:
      forall f sp e m optid sig a bl vf vargs fd t,
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      evalinf_funcall m fd vargs t ->
      execinf_stmt f sp e m (Scall optid sig a bl) t
  | execinf_Sifthenelse:
      forall f sp e m a s1 s2 v b t,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      execinf_stmt f sp e m (if b then s1 else s2) t ->
      execinf_stmt f sp e m (Sifthenelse a s1 s2) t
  | execinf_Sseq_1:
      forall f sp e m t s1 s2,
      execinf_stmt f sp e m s1 t ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sseq_2:
      forall f sp e m t s1 t1 e1 m1 s2 t2,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 s2 t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sloop_body:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 (Sloop s) t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sblock:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sblock s) t
  | execinf_Stailcall:
      forall f sp e m sig a bl vf vargs fd m' t,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      evalinf_funcall m' fd vargs t ->
      execinf_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t.

End NATURALSEM.

Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
  | bigstep_program_terminates_intro:
      forall b f m0 t m r,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      eval_funcall ge m0 f nil t m (Vint r) ->
      bigstep_program_terminates p t r.

Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
  | bigstep_program_diverges_intro:
      forall b f m0 t,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      evalinf_funcall ge m0 f nil t ->
      bigstep_program_diverges p t.

Definition bigstep_semantics (p: program) :=
  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).

Section BIGSTEP_TO_TRANSITION.

Variable prog: program.
Let ge := Genv.globalenv prog.

Inductive outcome_state_match
        (sp: val) (e: env) (m: mem) (f: function) (k: cont):
        outcome -> state -> Prop :=
  | osm_normal:
      outcome_state_match sp e m f k
                          Out_normal
                          (State f Sskip k sp e m)
  | osm_exit: forall n,
      outcome_state_match sp e m f k
                          (Out_exit n)
                          (State f (Sexit n) k sp e m)
  | osm_return_none: forall k',
      call_cont k' = call_cont k ->
      outcome_state_match sp e m f k
                          (Out_return None)
                          (State f (Sreturn None) k' sp e m)
  | osm_return_some: forall k' a v,
      call_cont k' = call_cont k ->
      eval_expr ge sp e m a v ->
      outcome_state_match sp e m f k
                          (Out_return (Some v))
                          (State f (Sreturn (Some a)) k' sp e m)
  | osm_tail: forall v,
      outcome_state_match sp e m f k
                          (Out_tailcall_return v)
                          (Returnstate v (call_cont k) m).

Remark is_call_cont_call_cont:
  forall k, is_call_cont (call_cont k).

Remark call_cont_is_call_cont:
  forall k, is_call_cont k -> call_cont k = k.

Lemma eval_funcall_exec_stmt_steps:
  (forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m'))
/\(forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S).

Lemma eval_funcall_steps:
   forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m').
Proof (proj1 eval_funcall_exec_stmt_steps).

Lemma exec_stmt_steps:
   forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S.
Proof (proj2 eval_funcall_exec_stmt_steps).

Lemma evalinf_funcall_forever:
  forall m fd args T k,
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.

Theorem bigstep_semantics_sound:
  bigstep_sound (bigstep_semantics prog) (semantics prog).

End BIGSTEP_TO_TRANSITION. *)

Require Import Op.
(* Op:
Require Import BoolEqual.
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Events.

Set Implicit Arguments.

Inductive condition : Type :=
  | Ccomp (c: comparison)      
  | Ccompu (c: comparison)     
  | Ccompimm (c: comparison) (n: int) 
  | Ccompuimm (c: comparison) (n: int)  
  | Ccompl (c: comparison)      
  | Ccomplu (c: comparison)     
  | Ccomplimm (c: comparison) (n: int64) 
  | Ccompluimm (c: comparison) (n: int64)  
  | Ccompf (c: comparison)     
  | Cnotcompf (c: comparison)  
  | Ccompfs (c: comparison)    
  | Cnotcompfs (c: comparison) 
  | Cmaskzero (n: int)         
  | Cmasknotzero (n: int).     

Inductive addressing: Type :=
  | Aindexed: Z -> addressing       
  | Aindexed2: Z -> addressing      
  | Ascaled: Z -> Z -> addressing   
  | Aindexed2scaled: Z -> Z -> addressing
                                    
  | Aglobal: ident -> ptrofs -> addressing 
  | Abased: ident -> ptrofs -> addressing  
  | Abasedscaled: Z -> ident -> ptrofs -> addressing  
  | Ainstack: ptrofs -> addressing. 

Inductive operation : Type :=
  | Omove                    
  | Ointconst (n: int)       
  | Olongconst (n: int64)    
  | Ofloatconst (n: float)   
  | Osingleconst (n: float32)
  | Oindirectsymbol (id: ident) 

  | Ocast8signed             
  | Ocast8unsigned           
  | Ocast16signed            
  | Ocast16unsigned          
  | Oneg                     
  | Osub                     
  | Omul                     
  | Omulimm (n: int)         
  | Omulhs                   
  | Omulhu                   
  | Odiv                     
  | Odivu                    
  | Omod                     
  | Omodu                    
  | Oand                     
  | Oandimm (n: int)         
  | Oor                      
  | Oorimm (n: int)          
  | Oxor                     
  | Oxorimm (n: int)         
  | Onot                     
  | Oshl                     
  | Oshlimm (n: int)         
  | Oshr                     
  | Oshrimm (n: int)         
  | Oshrximm (n: int)        
  | Oshru                    
  | Oshruimm (n: int)        
  | Ororimm (n: int)         
  | Oshldimm (n: int)        
  | Olea (a: addressing)     

  | Omakelong                
  | Olowlong                 
  | Ohighlong                
  | Ocast32signed            
  | Ocast32unsigned          
  | Onegl                    
  | Oaddlimm (n: int64)      
  | Osubl                    
  | Omull                    
  | Omullimm (n: int64)      
  | Omullhs                  
  | Omullhu                  
  | Odivl                    
  | Odivlu                   
  | Omodl                    
  | Omodlu                   
  | Oandl                    
  | Oandlimm (n: int64)      
  | Oorl                     
  | Oorlimm (n: int64)       
  | Oxorl                    
  | Oxorlimm (n: int64)      
  | Onotl                    
  | Oshll                    
  | Oshllimm (n: int)        
  | Oshrl                    
  | Oshrlimm (n: int)        
  | Oshrxlimm (n: int)       
  | Oshrlu                   
  | Oshrluimm (n: int)       
  | Ororlimm (n: int)        
  | Oleal (a: addressing)    

  | Onegf                    
  | Oabsf                    
  | Oaddf                    
  | Osubf                    
  | Omulf                    
  | Odivf                    
  | Onegfs                   
  | Oabsfs                   
  | Oaddfs                   
  | Osubfs                   
  | Omulfs                   
  | Odivfs                   
  | Osingleoffloat           
  | Ofloatofsingle           

  | Ointoffloat              
  | Ofloatofint              
  | Ointofsingle             
  | Osingleofint             
  | Olongoffloat             
  | Ofloatoflong             
  | Olongofsingle            
  | Osingleoflong            

  | Ocmp (cond: condition).  

Definition eq_condition (x y: condition) : {x=y} + {x<>y}.

Definition eq_addressing (x y: addressing) : {x=y} + {x<>y}.

Definition beq_operation: forall (x y: operation), bool.

Definition eq_operation: forall (x y: operation), {x=y} + {x<>y}.

Global Opaque eq_condition eq_addressing eq_operation.

Definition offset_in_range (n: Z) : bool := zle Int.min_signed n && zle n Int.max_signed.

Definition addressing_valid (a: addressing) : bool :=
  if Archi.ptr64 then
    match a with
    | Aindexed n => offset_in_range n
    | Aindexed2 n => offset_in_range n
    | Ascaled sc ofs => offset_in_range ofs
    | Aindexed2scaled sc ofs => offset_in_range ofs
    | Aglobal s ofs => true
    | Abased s ofs => true
    | Abasedscaled sc s ofs => true
    | Ainstack ofs => offset_in_range (Ptrofs.signed ofs)
    end
  else true.
  
Definition eval_condition (cond: condition) (vl: list val) (m: mem): option bool :=
  match cond, vl with
  | Ccomp c, v1 :: v2 :: nil => Val.cmp_bool c v1 v2
  | Ccompu c, v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2
  | Ccompimm c n, v1 :: nil => Val.cmp_bool c v1 (Vint n)
  | Ccompuimm c n, v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)
  | Ccompl c, v1 :: v2 :: nil => Val.cmpl_bool c v1 v2
  | Ccomplu c, v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
  | Ccomplimm c n, v1 :: nil => Val.cmpl_bool c v1 (Vlong n)
  | Ccompluimm c n, v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)
  | Ccompf c, v1 :: v2 :: nil => Val.cmpf_bool c v1 v2
  | Cnotcompf c, v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)
  | Ccompfs c, v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2
  | Cnotcompfs c, v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)
  | Cmaskzero n, v1 :: nil => Val.maskzero_bool v1 n
  | Cmasknotzero n, v1 :: nil => option_map negb (Val.maskzero_bool v1 n)
  | _, _ => None
  end.

Definition eval_addressing32
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.add v1 (Vint (Int.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.add (Val.add v1 v2) (Vint (Int.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.add (Val.mul v1 (Vint (Int.repr sc))) (Vint (Int.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.add v1 (Val.add (Val.mul v2 (Vint (Int.repr sc))) (Vint (Int.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then None else Some (Genv.symbol_address genv s ofs)
  | Abased s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) v1)
  | Abasedscaled sc s ofs, v1::nil =>
      if Archi.ptr64 then None else Some (Val.add (Genv.symbol_address genv s ofs) (Val.mul v1 (Vint (Int.repr sc))))
  | Ainstack ofs, nil =>
      if Archi.ptr64 then None else Some(Val.offset_ptr sp ofs)
  | _, _ => None
  end.

Definition eval_addressing64
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  match addr, vl with
  | Aindexed n, v1::nil =>
      Some (Val.addl v1 (Vlong (Int64.repr n)))
  | Aindexed2 n, v1::v2::nil =>
      Some (Val.addl (Val.addl v1 v2) (Vlong (Int64.repr n)))
  | Ascaled sc ofs, v1::nil =>
      Some (Val.addl (Val.mull v1 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs)))
  | Aindexed2scaled sc ofs, v1::v2::nil =>
      Some(Val.addl v1 (Val.addl (Val.mull v2 (Vlong (Int64.repr sc))) (Vlong (Int64.repr ofs))))
  | Aglobal s ofs, nil =>
      if Archi.ptr64 then Some (Genv.symbol_address genv s ofs) else None
  | Ainstack ofs, nil =>
      if Archi.ptr64 then Some(Val.offset_ptr sp ofs) else None
  | _, _ => None
  end.

Definition eval_addressing
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (addr: addressing) (vl: list val) : option val :=
  if Archi.ptr64
  then eval_addressing64 genv sp addr vl
  else eval_addressing32 genv sp addr vl.

Definition eval_operation
    (F V: Type) (genv: Genv.t F V) (sp: val)
    (op: operation) (vl: list val) (m: mem): option val :=
  match op, vl with
  | Omove, v1::nil => Some v1
  | Ointconst n, nil => Some (Vint n)
  | Olongconst n, nil => Some (Vlong n)
  | Ofloatconst n, nil => Some (Vfloat n)
  | Osingleconst n, nil => Some (Vsingle n)
  | Oindirectsymbol id, nil => Some (Genv.symbol_address genv id Ptrofs.zero)
  | Ocast8signed, v1 :: nil => Some (Val.sign_ext 8 v1)
  | Ocast8unsigned, v1 :: nil => Some (Val.zero_ext 8 v1)
  | Ocast16signed, v1 :: nil => Some (Val.sign_ext 16 v1)
  | Ocast16unsigned, v1 :: nil => Some (Val.zero_ext 16 v1)
  | Oneg, v1::nil => Some (Val.neg v1)
  | Osub, v1::v2::nil => Some (Val.sub v1 v2)
  | Omul, v1::v2::nil => Some (Val.mul v1 v2)
  | Omulimm n, v1::nil => Some (Val.mul v1 (Vint n))
  | Omulhs, v1::v2::nil => Some (Val.mulhs v1 v2)
  | Omulhu, v1::v2::nil => Some (Val.mulhu v1 v2)
  | Odiv, v1::v2::nil => Val.divs v1 v2
  | Odivu, v1::v2::nil => Val.divu v1 v2
  | Omod, v1::v2::nil => Val.mods v1 v2
  | Omodu, v1::v2::nil => Val.modu v1 v2
  | Oand, v1::v2::nil => Some(Val.and v1 v2)
  | Oandimm n, v1::nil => Some (Val.and v1 (Vint n))
  | Oor, v1::v2::nil => Some(Val.or v1 v2)
  | Oorimm n, v1::nil => Some (Val.or v1 (Vint n))
  | Oxor, v1::v2::nil => Some(Val.xor v1 v2)
  | Oxorimm n, v1::nil => Some (Val.xor v1 (Vint n))
  | Onot, v1::nil => Some(Val.notint v1)
  | Oshl, v1::v2::nil => Some (Val.shl v1 v2)
  | Oshlimm n, v1::nil => Some (Val.shl v1 (Vint n))
  | Oshr, v1::v2::nil => Some (Val.shr v1 v2)
  | Oshrimm n, v1::nil => Some (Val.shr v1 (Vint n))
  | Oshrximm n, v1::nil => Val.shrx v1 (Vint n)
  | Oshru, v1::v2::nil => Some (Val.shru v1 v2)
  | Oshruimm n, v1::nil => Some (Val.shru v1 (Vint n))
  | Ororimm n, v1::nil => Some (Val.ror v1 (Vint n))
  | Oshldimm n, v1::v2::nil => Some (Val.or (Val.shl v1 (Vint n))
                                            (Val.shru v2 (Vint (Int.sub Int.iwordsize n))))
  | Olea addr, _ => eval_addressing32 genv sp addr vl
  | Omakelong, v1::v2::nil => Some(Val.longofwords v1 v2)
  | Olowlong, v1::nil => Some(Val.loword v1)
  | Ohighlong, v1::nil => Some(Val.hiword v1)
  | Ocast32signed, v1 :: nil => Some (Val.longofint v1)
  | Ocast32unsigned, v1 :: nil => Some (Val.longofintu v1)
  | Onegl, v1::nil => Some (Val.negl v1)
  | Oaddlimm n, v1::nil => Some (Val.addl v1 (Vlong n))
  | Osubl, v1::v2::nil => Some (Val.subl v1 v2)
  | Omull, v1::v2::nil => Some (Val.mull v1 v2)
  | Omullimm n, v1::nil => Some (Val.mull v1 (Vlong n))
  | Omullhs, v1::v2::nil => Some (Val.mullhs v1 v2)
  | Omullhu, v1::v2::nil => Some (Val.mullhu v1 v2)
  | Odivl, v1::v2::nil => Val.divls v1 v2
  | Odivlu, v1::v2::nil => Val.divlu v1 v2
  | Omodl, v1::v2::nil => Val.modls v1 v2
  | Omodlu, v1::v2::nil => Val.modlu v1 v2
  | Oandl, v1::v2::nil => Some(Val.andl v1 v2)
  | Oandlimm n, v1::nil => Some (Val.andl v1 (Vlong n))
  | Oorl, v1::v2::nil => Some(Val.orl v1 v2)
  | Oorlimm n, v1::nil => Some (Val.orl v1 (Vlong n))
  | Oxorl, v1::v2::nil => Some(Val.xorl v1 v2)
  | Oxorlimm n, v1::nil => Some (Val.xorl v1 (Vlong n))
  | Onotl, v1::nil => Some(Val.notl v1)
  | Oshll, v1::v2::nil => Some (Val.shll v1 v2)
  | Oshllimm n, v1::nil => Some (Val.shll v1 (Vint n))
  | Oshrl, v1::v2::nil => Some (Val.shrl v1 v2)
  | Oshrlimm n, v1::nil => Some (Val.shrl v1 (Vint n))
  | Oshrxlimm n, v1::nil => Val.shrxl v1 (Vint n)
  | Oshrlu, v1::v2::nil => Some (Val.shrlu v1 v2)
  | Oshrluimm n, v1::nil => Some (Val.shrlu v1 (Vint n))
  | Ororlimm n, v1::nil => Some (Val.rorl v1 (Vint n))
  | Oleal addr, _ => eval_addressing64 genv sp addr vl
  | Onegf, v1::nil => Some(Val.negf v1)
  | Oabsf, v1::nil => Some(Val.absf v1)
  | Oaddf, v1::v2::nil => Some(Val.addf v1 v2)
  | Osubf, v1::v2::nil => Some(Val.subf v1 v2)
  | Omulf, v1::v2::nil => Some(Val.mulf v1 v2)
  | Odivf, v1::v2::nil => Some(Val.divf v1 v2)
  | Onegfs, v1::nil => Some(Val.negfs v1)
  | Oabsfs, v1::nil => Some(Val.absfs v1)
  | Oaddfs, v1::v2::nil => Some(Val.addfs v1 v2)
  | Osubfs, v1::v2::nil => Some(Val.subfs v1 v2)
  | Omulfs, v1::v2::nil => Some(Val.mulfs v1 v2)
  | Odivfs, v1::v2::nil => Some(Val.divfs v1 v2)
  | Osingleoffloat, v1::nil => Some(Val.singleoffloat v1)
  | Ofloatofsingle, v1::nil => Some(Val.floatofsingle v1)
  | Ointoffloat, v1::nil => Val.intoffloat v1
  | Ofloatofint, v1::nil => Val.floatofint v1
  | Ointofsingle, v1::nil => Val.intofsingle v1
  | Osingleofint, v1::nil => Val.singleofint v1
  | Olongoffloat, v1::nil => Val.longoffloat v1
  | Ofloatoflong, v1::nil => Val.floatoflong v1
  | Olongofsingle, v1::nil => Val.longofsingle v1
  | Osingleoflong, v1::nil => Val.singleoflong v1
  | Ocmp c, _ => Some(Val.of_optbool (eval_condition c vl m))
  | _, _ => None
  end.

Remark eval_addressing_Aglobal:
  forall (F V: Type) (genv: Genv.t F V) sp id ofs,

Remark eval_addressing_Ainstack:
  forall (F V: Type) (genv: Genv.t F V) sp ofs,

Remark eval_addressing_Ainstack_inv:
  forall (F V: Type) (genv: Genv.t F V) sp ofs vl v,

Ltac FuncInv :=
  match goal with
  | H: (match ?x with nil => _ | _ :: _ => _ end = Some _) |- _ =>
      destruct x; simpl in H; FuncInv
  | H: (match ?v with Vundef => _ | Vint _ => _ | Vfloat _ => _ | Vptr _ _ => _ end = Some _) |- _ =>
      destruct v; simpl in H; FuncInv
  | H: (if Archi.ptr64 then _ else _) = Some _ |- _ =>
      destruct Archi.ptr64 eqn:?; FuncInv
  | H: (Some _ = Some _) |- _ =>
      injection H; intros; clear H; FuncInv
  | H: (None = Some _) |- _ =>
      discriminate H
  | _ =>
      idtac
  end.

Definition type_of_condition (c: condition) : list typ :=
  match c with
  | Ccomp _ => Tint :: Tint :: nil
  | Ccompu _ => Tint :: Tint :: nil
  | Ccompimm _ _ => Tint :: nil
  | Ccompuimm _ _ => Tint :: nil
  | Ccompl _ => Tlong :: Tlong :: nil
  | Ccomplu _ => Tlong :: Tlong :: nil
  | Ccomplimm _ _ => Tlong :: nil
  | Ccompluimm _ _ => Tlong :: nil
  | Ccompf _ => Tfloat :: Tfloat :: nil
  | Cnotcompf _ => Tfloat :: Tfloat :: nil
  | Ccompfs _ => Tsingle :: Tsingle :: nil
  | Cnotcompfs _ => Tsingle :: Tsingle :: nil
  | Cmaskzero _ => Tint :: nil
  | Cmasknotzero _ => Tint :: nil
  end.

Definition type_of_addressing_gen (tyA: typ) (addr: addressing): list typ :=
  match addr with
  | Aindexed _ => tyA :: nil
  | Aindexed2 _ => tyA :: tyA :: nil
  | Ascaled _ _ => tyA :: nil
  | Aindexed2scaled _ _ => tyA :: tyA :: nil
  | Aglobal _ _ => nil
  | Abased _ _ => tyA :: nil
  | Abasedscaled _ _ _ => tyA :: nil
  | Ainstack _ => nil
  end.

Definition type_of_addressing := type_of_addressing_gen Tptr.
Definition type_of_addressing32 := type_of_addressing_gen Tint.
Definition type_of_addressing64 := type_of_addressing_gen Tlong.

Definition type_of_operation (op: operation) : list typ * typ :=
  match op with
  | Omove => (nil, Tint)   
  | Ointconst _ => (nil, Tint)
  | Olongconst _ => (nil, Tlong)
  | Ofloatconst f => (nil, Tfloat)
  | Osingleconst f => (nil, Tsingle)
  | Oindirectsymbol _ => (nil, Tptr)
  | Ocast8signed => (Tint :: nil, Tint)
  | Ocast8unsigned => (Tint :: nil, Tint)
  | Ocast16signed => (Tint :: nil, Tint)
  | Ocast16unsigned => (Tint :: nil, Tint)
  | Oneg => (Tint :: nil, Tint)
  | Osub => (Tint :: Tint :: nil, Tint)
  | Omul => (Tint :: Tint :: nil, Tint)
  | Omulimm _ => (Tint :: nil, Tint)
  | Omulhs => (Tint :: Tint :: nil, Tint)
  | Omulhu => (Tint :: Tint :: nil, Tint)
  | Odiv => (Tint :: Tint :: nil, Tint)
  | Odivu => (Tint :: Tint :: nil, Tint)
  | Omod => (Tint :: Tint :: nil, Tint)
  | Omodu => (Tint :: Tint :: nil, Tint)
  | Oand => (Tint :: Tint :: nil, Tint)
  | Oandimm _ => (Tint :: nil, Tint)
  | Oor => (Tint :: Tint :: nil, Tint)
  | Oorimm _ => (Tint :: nil, Tint)
  | Oxor => (Tint :: Tint :: nil, Tint)
  | Oxorimm _ => (Tint :: nil, Tint)
  | Onot => (Tint :: nil, Tint)
  | Oshl => (Tint :: Tint :: nil, Tint)
  | Oshlimm _ => (Tint :: nil, Tint)
  | Oshr => (Tint :: Tint :: nil, Tint)
  | Oshrimm _ => (Tint :: nil, Tint)
  | Oshrximm _ => (Tint :: nil, Tint)
  | Oshru => (Tint :: Tint :: nil, Tint)
  | Oshruimm _ => (Tint :: nil, Tint)
  | Ororimm _ => (Tint :: nil, Tint)
  | Oshldimm _ => (Tint :: Tint :: nil, Tint)
  | Olea addr => (type_of_addressing32 addr, Tint)
  | Omakelong => (Tint :: Tint :: nil, Tlong)
  | Olowlong => (Tlong :: nil, Tint)
  | Ohighlong => (Tlong :: nil, Tint)
  | Ocast32signed => (Tint :: nil, Tlong)
  | Ocast32unsigned => (Tint :: nil, Tlong)
  | Onegl => (Tlong :: nil, Tlong)
  | Oaddlimm _ => (Tlong :: nil, Tlong)
  | Osubl => (Tlong :: Tlong :: nil, Tlong)
  | Omull => (Tlong :: Tlong :: nil, Tlong)
  | Omullimm _ => (Tlong :: nil, Tlong)
  | Omullhs => (Tlong :: Tlong :: nil, Tlong)
  | Omullhu => (Tlong :: Tlong :: nil, Tlong)
  | Odivl => (Tlong :: Tlong :: nil, Tlong)
  | Odivlu => (Tlong :: Tlong :: nil, Tlong)
  | Omodl => (Tlong :: Tlong :: nil, Tlong)
  | Omodlu => (Tlong :: Tlong :: nil, Tlong)
  | Oandl => (Tlong :: Tlong :: nil, Tlong)
  | Oandlimm _ => (Tlong :: nil, Tlong)
  | Oorl => (Tlong :: Tlong :: nil, Tlong)
  | Oorlimm _ => (Tlong :: nil, Tlong)
  | Oxorl => (Tlong :: Tlong :: nil, Tlong)
  | Oxorlimm _ => (Tlong :: nil, Tlong)
  | Onotl => (Tlong :: nil, Tlong)
  | Oshll => (Tlong :: Tint :: nil, Tlong)
  | Oshllimm _ => (Tlong :: nil, Tlong)
  | Oshrl => (Tlong :: Tint :: nil, Tlong)
  | Oshrlimm _ => (Tlong :: nil, Tlong)
  | Oshrxlimm _ => (Tlong :: nil, Tlong)
  | Oshrlu => (Tlong :: Tint :: nil, Tlong)
  | Oshrluimm _ => (Tlong :: nil, Tlong)
  | Ororlimm _ => (Tlong :: nil, Tlong)
  | Oleal addr => (type_of_addressing64 addr, Tlong)
  | Onegf => (Tfloat :: nil, Tfloat)
  | Oabsf => (Tfloat :: nil, Tfloat)
  | Oaddf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Osubf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Omulf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Odivf => (Tfloat :: Tfloat :: nil, Tfloat)
  | Onegfs => (Tsingle :: nil, Tsingle)
  | Oabsfs => (Tsingle :: nil, Tsingle)
  | Oaddfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osubfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Omulfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Odivfs => (Tsingle :: Tsingle :: nil, Tsingle)
  | Osingleoffloat => (Tfloat :: nil, Tsingle)
  | Ofloatofsingle => (Tsingle :: nil, Tfloat)
  | Ointoffloat => (Tfloat :: nil, Tint)
  | Ofloatofint => (Tint :: nil, Tfloat)
  | Ointofsingle => (Tsingle :: nil, Tint)
  | Osingleofint => (Tint :: nil, Tsingle)
  | Olongoffloat => (Tfloat :: nil, Tlong)
  | Ofloatoflong => (Tlong :: nil, Tfloat)
  | Olongofsingle => (Tsingle :: nil, Tlong)
  | Osingleoflong => (Tlong :: nil, Tsingle)
  | Ocmp c => (type_of_condition c, Tint)
  end.

Section SOUNDNESS.

Variable A V: Type.
Variable genv: Genv.t A V.

Remark type_add:
  forall v1 v2, Val.has_type (Val.add v1 v2) Tint.

Remark type_addl:
  forall v1 v2, Val.has_type (Val.addl v1 v2) Tlong.

Lemma type_of_addressing64_sound:
  forall addr vl sp v,
  eval_addressing64 genv sp addr vl = Some v ->
  Val.has_type v Tlong.

Lemma type_of_addressing32_sound:
  forall addr vl sp v,
  eval_addressing32 genv sp addr vl = Some v ->
  Val.has_type v Tint.

Corollary type_of_addressing_sound:
  forall addr vl sp v,
  eval_addressing genv sp addr vl = Some v ->
  Val.has_type v Tptr.

Lemma type_of_operation_sound:
  forall op vl sp v m,
  op <> Omove ->
  eval_operation genv sp op vl m = Some v ->
  Val.has_type v (snd (type_of_operation op)).

End SOUNDNESS.

Definition is_move_operation
    (A: Type) (op: operation) (args: list A) : option A :=
  match op, args with
  | Omove, arg :: nil => Some arg
  | _, _ => None
  end.

Lemma is_move_operation_correct:
  forall (A: Type) (op: operation) (args: list A) (a: A),
  is_move_operation op args = Some a ->
  op = Omove /\ args = a :: nil.

Definition negate_condition (cond: condition): condition :=
  match cond with
  | Ccomp c => Ccomp(negate_comparison c)
  | Ccompu c => Ccompu(negate_comparison c)
  | Ccompimm c n => Ccompimm (negate_comparison c) n
  | Ccompuimm c n => Ccompuimm (negate_comparison c) n
  | Ccompl c => Ccompl(negate_comparison c)
  | Ccomplu c => Ccomplu(negate_comparison c)
  | Ccomplimm c n => Ccomplimm (negate_comparison c) n
  | Ccompluimm c n => Ccompluimm (negate_comparison c) n
  | Ccompf c => Cnotcompf c
  | Cnotcompf c => Ccompf c
  | Ccompfs c => Cnotcompfs c
  | Cnotcompfs c => Ccompfs c
  | Cmaskzero n => Cmasknotzero n
  | Cmasknotzero n => Cmaskzero n
  end.

Lemma eval_negate_condition:
  forall cond vl m,
  eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m).

Definition shift_stack_addressing (delta: Z) (addr: addressing) :=
  match addr with
  | Ainstack ofs => Ainstack (Ptrofs.add ofs (Ptrofs.repr delta))
  | _ => addr
  end.

Definition shift_stack_operation (delta: Z) (op: operation) :=
  match op with
  | Olea  addr => Olea  (shift_stack_addressing delta addr)
  | Oleal addr => Oleal (shift_stack_addressing delta addr)
  | _ => op
  end.

Lemma type_shift_stack_addressing:
  forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr.

Lemma type_shift_stack_operation:
  forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op.

Lemma eval_shift_stack_addressing32:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing64:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_addressing:
  forall F V (ge: Genv.t F V) sp addr vl delta,

Lemma eval_shift_stack_operation:
  forall F V (ge: Genv.t F V) sp op vl m delta,

Definition offset_addressing_total (addr: addressing) (delta: Z) : addressing :=
  match addr with
  | Aindexed n => Aindexed (n + delta)
  | Aindexed2 n => Aindexed2 (n + delta)
  | Ascaled sc n => Ascaled sc (n + delta)
  | Aindexed2scaled sc n => Aindexed2scaled sc (n + delta)
  | Aglobal s n => Aglobal s (Ptrofs.add n (Ptrofs.repr delta))
  | Abased s n => Abased s (Ptrofs.add n (Ptrofs.repr delta))
  | Abasedscaled sc s n => Abasedscaled sc s (Ptrofs.add n (Ptrofs.repr delta))
  | Ainstack n => Ainstack (Ptrofs.add n (Ptrofs.repr delta))
  end.

Definition offset_addressing (addr: addressing) (delta: Z) : option addressing :=
  let addr' := offset_addressing_total addr delta in
  if addressing_valid addr' then Some addr' else None.

Lemma eval_offset_addressing_total_32:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing_total_64:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta v,

Lemma eval_offset_addressing:
  forall (F V: Type) (ge: Genv.t F V) sp addr args delta addr' v,

Definition is_trivial_op (op: operation) : bool :=
  match op with
  | Omove => true
  | Ointconst _ => true
  | Olongconst _ => true
  | Olea (Aglobal _ _) => true
  | Olea (Ainstack _) => true
  | Oleal (Aglobal _ _) => true
  | Oleal (Ainstack _) => true
  | _ => false
  end.

Definition op_depends_on_memory (op: operation) : bool :=
  match op with
  | Ocmp (Ccompu _) => negb Archi.ptr64
  | Ocmp (Ccompuimm _ _) => negb Archi.ptr64
  | Ocmp (Ccomplu _) => Archi.ptr64
  | Ocmp (Ccompluimm _ _) => Archi.ptr64
  | _ => false
  end.

Lemma op_depends_on_memory_correct:
  forall (F V: Type) (ge: Genv.t F V) sp op args m1 m2,

Definition globals_addressing (addr: addressing) : list ident :=
  match addr with
  | Aglobal s n => s :: nil
  | Abased s n => s :: nil
  | Abasedscaled sc s n => s :: nil
  | _ => nil
  end.

Definition globals_operation (op: operation) : list ident :=
  match op with
  | Oindirectsymbol s => s :: nil
  | Olea addr => globals_addressing addr
  | Oleal addr => globals_addressing addr
  | _ => nil
  end.

Section GENV_TRANSF.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Hypothesis agree_on_symbols:
  forall (s: ident), Genv.find_symbol ge2 s = Genv.find_symbol ge1 s.

Lemma eval_addressing32_preserved:
  forall sp addr vl,
  eval_addressing32 ge2 sp addr vl = eval_addressing32 ge1 sp addr vl.

Lemma eval_addressing64_preserved:
  forall sp addr vl,
  eval_addressing64 ge2 sp addr vl = eval_addressing64 ge1 sp addr vl.

Lemma eval_addressing_preserved:
  forall sp addr vl,
  eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.

Lemma eval_operation_preserved:
  forall sp op vl m,
  eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.

End GENV_TRANSF.

Section EVAL_COMPAT.

Variable F1 F2 V1 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Variable f: meminj.

Variable m1: mem.
Variable m2: mem.

Hypothesis valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_pointer_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_pointers_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->
  Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Ltac InvInject :=
  match goal with
  | [ H: Val.inject _ (Vint _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vfloat _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject _ (Vptr _ _) _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ nil _ |- _ ] =>
      inv H; InvInject
  | [ H: Val.inject_list _ (_ :: _) _ |- _ ] =>
      inv H; InvInject
  | _ => idtac
  end.

Lemma eval_condition_inj:
  forall cond vl1 vl2 b,
  Val.inject_list f vl1 vl2 ->

Ltac TrivialExists :=
  match goal with
  | [ |- exists v2, Some ?v1 = Some v2 /\ Val.inject _ _ v2 ] =>
      exists v1; split; auto
  | _ => idtac
  end.

Lemma eval_addressing32_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing64_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_addressing_inj:
  forall addr sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_addressing addr) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

Lemma eval_operation_inj:
  forall op sp1 vl1 sp2 vl2 v1,
  (forall id ofs,
      In id (globals_operation op) ->
      Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs)) ->

End EVAL_COMPAT.

Section EVAL_LESSDEF.

Variable F V: Type.
Variable genv: Genv.t F V.

Remark valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_extends:
  forall m1 m2, Mem.extends m1 m2 ->

Remark weak_valid_pointer_no_overflow_extends:
  forall m1 b1 ofs b2 delta,
  Some(b1, 0) = Some(b2, delta) ->
  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->

Remark valid_different_pointers_extends:
  forall m1 b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->

Lemma eval_condition_lessdef:
  forall cond vl1 vl2 b m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_operation_lessdef:
  forall sp op vl1 vl2 v1 m1 m2,
  Val.lessdef_list vl1 vl2 ->

Lemma eval_addressing_lessdef:
  forall sp addr vl1 vl2 v1,
  Val.lessdef_list vl1 vl2 ->

End EVAL_LESSDEF.

Section EVAL_INJECT.

Variable F V: Type.
Variable genv: Genv.t F V.
Variable f: meminj.
Hypothesis globals: meminj_preserves_globals genv f.
Variable sp1: block.
Variable sp2: block.
Variable delta: Z.
Hypothesis sp_inj: f sp1 = Some(sp2, delta).

Remark symbol_address_inject:
  forall id ofs, Val.inject f (Genv.symbol_address genv id ofs) (Genv.symbol_address genv id ofs).

Lemma eval_condition_inject:
  forall cond vl1 vl2 b m1 m2,
  Val.inject_list f vl1 vl2 ->

Lemma eval_addressing_inject:
  forall addr vl1 vl2 v1,
  Val.inject_list f vl1 vl2 ->

Lemma eval_operation_inject:
  forall op vl1 vl2 v1 m1 m2,
  Val.inject_list f vl1 vl2 ->

End EVAL_INJECT.

Definition builtin_arg_ok_1
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match c, ba with
  | OK_all, _ => true
  | OK_const, (BA_int _ | BA_long _ | BA_float _ | BA_single _) => true
  | OK_addrstack, BA_addrstack _ => true
  | OK_addressing, BA_addrstack _ => true
  | OK_addressing, BA_addrglobal _ _ => true
  | OK_addressing, BA_addptr (BA _) (BA_int _ | BA_long _) => true
  | _, _ => false
  end.

Definition builtin_arg_ok
       (A: Type) (ba: builtin_arg A) (c: builtin_arg_constraint) :=
  match ba with
  | (BA _ | BA_splitlong (BA _) (BA _)) => true
  | _ => builtin_arg_ok_1 ba c
  end. *)

Require Import CminorSel.

Require Import RTL.

Require Import RTLgen.
(* RTLgen:
Require Import Coqlib.
Require Errors.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Switch.
Require Import Op.
Require Import Registers.
Require Import CminorSel.
Require Import RTL.

Open Local Scope string_scope.

Record mapping: Type := mkmapping {
  map_vars: PTree.t reg;
  map_letvars: list reg
}.

Record state: Type := mkstate {
  st_nextreg: positive;
  st_nextnode: positive;
  st_code: code;
  st_wf: forall (pc: positive), Plt pc st_nextnode \/ st_code!pc = None
}.

Inductive state_incr: state -> state -> Prop :=
  state_incr_intro:
    forall (s1 s2: state),
    Ple s1.(st_nextnode) s2.(st_nextnode) ->
    Ple s1.(st_nextreg) s2.(st_nextreg) ->
    (forall pc,
      s1.(st_code)!pc = None \/ s2.(st_code)!pc = s1.(st_code)!pc) ->
    state_incr s1 s2.

Lemma state_incr_refl:
  forall s, state_incr s s.

Lemma state_incr_trans:
  forall s1 s2 s3, state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3.

Inductive res (A: Type) (s: state): Type :=
  | Error: Errors.errmsg -> res A s
  | OK: A -> forall (s': state), state_incr s s' -> res A s.

Implicit Arguments OK [A s].
Implicit Arguments Error [A s].

Definition mon (A: Type) : Type := forall (s: state), res A s.

Definition ret (A: Type) (x: A) : mon A :=
  fun (s: state) => OK x s (state_incr_refl s).

Implicit Arguments ret [A].

Definition error (A: Type) (msg: Errors.errmsg) : mon A := fun (s: state) => Error msg.

Implicit Arguments error [A].

Definition bind (A B: Type) (f: mon A) (g: A -> mon B) : mon B :=
  fun (s: state) =>
    match f s with
    | Error msg => Error msg
    | OK a s' i =>
        match g a s' with
        | Error msg => Error msg
        | OK b s'' i' => OK b s'' (state_incr_trans s s' s'' i i')
        end
    end.

Implicit Arguments bind [A B].

Definition bind2 (A B C: Type) (f: mon (A * B)) (g: A -> B -> mon C) : mon C :=
  bind f (fun xy => g (fst xy) (snd xy)).

Implicit Arguments bind2 [A B C].

Notation "'do' X <- A ; B" := (bind A (fun X => B))
   (at level 200, X ident, A at level 100, B at level 200).
Notation "'do' ( X , Y ) <- A ; B" := (bind2 A (fun X Y => B))
   (at level 200, X ident, Y ident, A at level 100, B at level 200).

Definition handle_error (A: Type) (f g: mon A) : mon A :=
  fun (s: state) =>
    match f s with
    | OK a s' i => OK a s' i
    | Error _ => g s
    end.

Implicit Arguments handle_error [A].

Remark init_state_wf:
  forall pc, Plt pc 1%positive \/ (PTree.empty instruction)!pc = None.

Definition init_state : state :=
  mkstate 1%positive 1%positive (PTree.empty instruction) init_state_wf.

Remark add_instr_wf:
  forall s i pc,
  let n := s.(st_nextnode) in

Remark add_instr_incr:
  forall s i,
  let n := s.(st_nextnode) in

Definition add_instr (i: instruction) : mon node :=
  fun s =>
    let n := s.(st_nextnode) in
    OK n
       (mkstate s.(st_nextreg) (Psucc n) (PTree.set n i s.(st_code))
                (add_instr_wf s i))
       (add_instr_incr s i).

Remark reserve_instr_wf:
  forall s pc,
  Plt pc (Psucc s.(st_nextnode)) \/ s.(st_code)!pc = None.

Remark reserve_instr_incr:
  forall s,
  let n := s.(st_nextnode) in

Definition reserve_instr: mon node :=
  fun (s: state) =>
  let n := s.(st_nextnode) in
  OK n
     (mkstate s.(st_nextreg) (Psucc n) s.(st_code) (reserve_instr_wf s))
     (reserve_instr_incr s).

Remark update_instr_wf:
  forall s n i,
  Plt n s.(st_nextnode) ->

Remark update_instr_incr:
  forall s n i (LT: Plt n s.(st_nextnode)),

Definition check_empty_node:
  forall (s: state) (n: node), { s.(st_code)!n = None } + { True }.

Definition update_instr (n: node) (i: instruction) : mon unit :=
  fun s =>
    match plt n s.(st_nextnode), check_empty_node s n with
    | left LT, left EMPTY =>
        OK tt
           (mkstate s.(st_nextreg) s.(st_nextnode) (PTree.set n i s.(st_code))
                    (update_instr_wf s n i LT))
           (update_instr_incr s n i LT EMPTY)
    | _, _ =>
        Error (Errors.msg "RTLgen.update_instr")
    end.

Remark new_reg_incr:
  forall s,
  state_incr s (mkstate (Psucc s.(st_nextreg))

Definition new_reg : mon reg :=
  fun s =>
    OK s.(st_nextreg)
       (mkstate (Psucc s.(st_nextreg)) s.(st_nextnode) s.(st_code) s.(st_wf))
       (new_reg_incr s).

Definition init_mapping : mapping :=
  mkmapping (PTree.empty reg) nil.

Definition add_var (map: mapping) (name: ident) : mon (reg * mapping) :=
  do r <- new_reg;
     ret (r, mkmapping (PTree.set name r map.(map_vars))
                       map.(map_letvars)).

Fixpoint add_vars (map: mapping) (names: list ident)
                  {struct names} : mon (list reg * mapping) :=
  match names with
  | nil => ret (nil, map)
  | n1 :: nl =>
      do (rl, map1) <- add_vars map nl;
      do (r1, map2) <- add_var map1 n1;
      ret (r1 :: rl, map2)
  end.

Definition find_var (map: mapping) (name: ident) : mon reg :=
  match PTree.get name map.(map_vars) with
  | None => error (Errors.MSG "RTLgen: unbound variable " :: Errors.CTX name :: nil)
  | Some r => ret r
  end.

Definition add_letvar (map: mapping) (r: reg) : mapping :=
  mkmapping map.(map_vars) (r :: map.(map_letvars)).

Definition find_letvar (map: mapping) (idx: nat) : mon reg :=
  match List.nth_error map.(map_letvars) idx with
  | None => error (Errors.msg "RTLgen: unbound let variable")
  | Some r => ret r
  end.

Definition alloc_reg (map: mapping) (a: expr) : mon reg :=
  match a with
  | Evar id   => find_var map id
  | Eletvar n => find_letvar map n
  | _         => new_reg
  end.

Fixpoint alloc_regs (map: mapping) (al: exprlist)
                    {struct al}: mon (list reg) :=
  match al with
  | Enil =>
      ret nil
  | Econs a bl =>
      do r  <- alloc_reg map a;
      do rl <- alloc_regs map bl;
      ret (r :: rl)
  end.

Definition alloc_optreg (map: mapping) (dest: option ident) : mon reg :=
  match dest with
  | Some id => find_var map id
  | None => new_reg
  end.

Definition add_move (rs rd: reg) (nd: node) : mon node :=
  if Reg.eq rs rd
  then ret nd
  else add_instr (Iop Omove (rs::nil) rd nd).

Fixpoint transl_expr (map: mapping) (a: expr) (rd: reg) (nd: node)
                     {struct a}: mon node :=
  match a with
  | Evar v =>
      do r <- find_var map v; add_move r rd nd
  | Eop op al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Iop op rl rd nd);
      transl_exprlist map al rl no
  | Eload chunk addr al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Iload chunk addr rl rd nd);
         transl_exprlist map al rl no
  | Econdition a b c =>
      do nfalse <- transl_expr map c rd nd;
      do ntrue  <- transl_expr map b rd nd;
         transl_condexpr map a ntrue nfalse
  | Elet b c =>
      do r  <- new_reg;
      do nc <- transl_expr (add_letvar map r) c rd nd;
         transl_expr map b r nc
  | Eletvar n =>
      do r <- find_letvar map n; add_move r rd nd
  | Ebuiltin ef al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Ibuiltin ef rl rd nd);
      transl_exprlist map al rl no
  | Eexternal id sg al =>
      do rl <- alloc_regs map al;
      do no <- add_instr (Icall sg (inr id) rl rd nd);
      transl_exprlist map al rl no
  end

with transl_exprlist (map: mapping) (al: exprlist) (rl: list reg) (nd: node)
                     {struct al} : mon node :=
  match al, rl with
  | Enil, nil =>
      ret nd
  | Econs b bs, r :: rs =>
      do no <- transl_exprlist map bs rs nd; transl_expr map b r no
  | _, _ =>
      error (Errors.msg "RTLgen.transl_exprlist")
  end

with transl_condexpr (map: mapping) (a: condexpr) (ntrue nfalse: node)
                     {struct a} : mon node :=
  match a with
  | CEcond c al =>
      do rl <- alloc_regs map al;
      do nt <- add_instr (Icond c rl ntrue nfalse);
         transl_exprlist map al rl nt
  | CEcondition a b c =>
      do nc <- transl_condexpr map c ntrue nfalse;
      do nb <- transl_condexpr map b ntrue nfalse;
         transl_condexpr map a nb nc
  | CElet b c =>
      do r  <- new_reg;
      do nc <- transl_condexpr (add_letvar map r) c ntrue nfalse;
         transl_expr map b r nc
  end.

Parameter more_likely: condexpr -> stmt -> stmt -> bool.

Parameter compile_switch: nat -> table -> comptree.

Definition transl_exit (nexits: list node) (n: nat) : mon node :=
  match nth_error nexits n with
  | None => error (Errors.msg "RTLgen: wrong exit")
  | Some ne => ret ne
  end.

Fixpoint transl_jumptable (nexits: list node) (tbl: list nat) : mon (list node) :=
  match tbl with
  | nil => ret nil
  | t1 :: tl =>
      do n1 <- transl_exit nexits t1;
      do nl <- transl_jumptable nexits tl;
      ret (n1 :: nl)
  end.

Fixpoint transl_switch (r: reg) (nexits: list node) (t: comptree)
                       {struct t} : mon node :=
  match t with
  | CTaction act =>
      transl_exit nexits act
  | CTifeq key act t' =>
      do ncont <- transl_switch r nexits t';
      do nfound <- transl_exit nexits act;
      add_instr (Icond (Ccompimm Ceq key) (r :: nil) nfound ncont)
  | CTiflt key t1 t2 =>
      do n2 <- transl_switch r nexits t2;
      do n1 <- transl_switch r nexits t1;
      add_instr (Icond (Ccompuimm Clt key) (r :: nil) n1 n2)
  | CTjumptable ofs sz tbl t' =>
      do rt <- new_reg;
      do ttbl <- transl_jumptable nexits tbl;
      do n1 <- add_instr (Ijumptable rt ttbl);
      do n2 <- transl_switch r nexits t';
      do n3 <- add_instr (Icond (Ccompuimm Clt sz) (rt :: nil) n1 n2);
      let op := if Int.eq ofs Int.zero then Omove else Oaddimm (Int.neg ofs) in
      add_instr (Iop op (r :: nil) rt n3)
  end.

Definition labelmap : Type := PTree.t node.

Fixpoint transl_stmt (map: mapping) (s: stmt) (nd: node)
                     (nexits: list node) (ngoto: labelmap) (nret: node) (rret: option reg)
                     {struct s} : mon node :=
  match s with
  | Sskip =>
      ret nd
  | Sassign v b =>
      do r <- find_var map v;
      transl_expr map b r nd
  | Sstore chunk addr al b =>
      do rl <- alloc_regs map al;
      do r <- alloc_reg map b;
      do no <- add_instr (Istore chunk addr rl r nd);
      do ns <- transl_expr map b r no;
         transl_exprlist map al rl ns
  | Scall optid sig (inl b) cl =>
      do rf <- alloc_reg map b;
      do rargs <- alloc_regs map cl;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Icall sig (inl _ rf) rargs r nd);
      do n2 <- transl_exprlist map cl rargs n1;
         transl_expr map b rf n2
  | Scall optid sig (inr id) cl =>
      do rargs <- alloc_regs map cl;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Icall sig (inr _ id) rargs r nd);
      transl_exprlist map cl rargs n1
  | Stailcall sig (inl b) cl =>
      do rf <- alloc_reg map b;
      do rargs <- alloc_regs map cl;
      do n1 <- add_instr (Itailcall sig (inl _ rf) rargs);
      do n2 <- transl_exprlist map cl rargs n1;
         transl_expr map b rf n2
  | Stailcall sig (inr id) cl =>
      do rargs <- alloc_regs map cl;
      do n1 <- add_instr (Itailcall sig (inr _ id) rargs);
      transl_exprlist map cl rargs n1
  | Sbuiltin optid ef al =>
      do rargs <- alloc_regs map al;
      do r <- alloc_optreg map optid;
      do n1 <- add_instr (Ibuiltin ef rargs r nd);
         transl_exprlist map al rargs n1
  | Sseq s1 s2 =>
      do ns <- transl_stmt map s2 nd nexits ngoto nret rret;
      transl_stmt map s1 ns nexits ngoto nret rret
  | Sifthenelse c strue sfalse =>
      if more_likely c strue sfalse then
        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
           transl_condexpr map c ntrue nfalse
      else
        do ntrue  <- transl_stmt map strue  nd nexits ngoto nret rret;
        do nfalse <- transl_stmt map sfalse nd nexits ngoto nret rret;
           transl_condexpr map c ntrue nfalse
  | Sloop sbody =>
      do n1 <- reserve_instr;
      do n2 <- transl_stmt map sbody n1 nexits ngoto nret rret;
      do xx <- update_instr n1 (Inop n2);
      add_instr (Inop n2)
  | Sblock sbody =>
      transl_stmt map sbody nd (nd :: nexits) ngoto nret rret
  | Sexit n =>
      transl_exit nexits n
  | Sswitch a cases default =>
      let t := compile_switch default cases in
      if validate_switch default cases t then
        (do r <- alloc_reg map a;
         do ns <- transl_switch r nexits t;
         transl_expr map a r ns)
      else
        error (Errors.msg "RTLgen: wrong switch")
  | Sreturn opt_a =>
      match opt_a, rret with
      | None, _ => ret nret
      | Some a, Some r => transl_expr map a r nret
      | _, _ => error (Errors.msg "RTLgen: type mismatch on return")
      end
  | Slabel lbl s' =>
      do ns <- transl_stmt map s' nd nexits ngoto nret rret;
      match ngoto!lbl with
      | None => error (Errors.msg "RTLgen: unbound label")
      | Some n =>
          do xx <-
            (handle_error (update_instr n (Inop ns))
                          (error (Errors.MSG "Multiply-defined label " ::
                                  Errors.CTX lbl :: nil)));
          ret ns
      end
  | Sgoto lbl =>
      match ngoto!lbl with
      | None => error (Errors.MSG "Undefined defined label " ::
                       Errors.CTX lbl :: nil)
      | Some n => ret n
      end
  end.

Definition alloc_label (lbl: Cminor.label) (maps: labelmap * state) : labelmap * state :=
  let (map, s) := maps in
  let n := s.(st_nextnode) in
  (PTree.set lbl n map,
   mkstate s.(st_nextreg) (Psucc s.(st_nextnode)) s.(st_code) (reserve_instr_wf s)).

Fixpoint reserve_labels (s: stmt) (ms: labelmap * state)
                        {struct s} : labelmap * state :=
  match s with
  | Sseq s1 s2 => reserve_labels s1 (reserve_labels s2 ms)
  | Sifthenelse c s1 s2 => reserve_labels s1 (reserve_labels s2 ms)
  | Sloop s1 => reserve_labels s1 ms
  | Sblock s1 => reserve_labels s1 ms
  | Slabel lbl s1 => alloc_label lbl (reserve_labels s1 ms)
  | _ => ms
  end.

Definition ret_reg (sig: signature) (rd: reg) : option reg :=
  match sig.(sig_res) with
  | None => None
  | Some ty => Some rd
  end.

Definition transl_fun (f: CminorSel.function) (ngoto: labelmap): mon (node * list reg) :=
  do (rparams, map1) <- add_vars init_mapping f.(CminorSel.fn_params);
  do (rvars, map2) <- add_vars map1 f.(CminorSel.fn_vars);
  do rret <- new_reg;
  let orret := ret_reg f.(CminorSel.fn_sig) rret in
  do nret <- add_instr (Ireturn orret);
  do nentry <- transl_stmt map2 f.(CminorSel.fn_body) nret nil ngoto nret orret;
  ret (nentry, rparams).

Definition transl_function (f: CminorSel.function) : Errors.res RTL.function :=
  let (ngoto, s0) := reserve_labels f.(fn_body) (PTree.empty node, init_state) in
  match transl_fun f ngoto s0 with
  | Error msg => Errors.Error msg
  | OK (nentry, rparams) s i =>
      Errors.OK (RTL.mkfunction
                   f.(CminorSel.fn_sig)
                   rparams
                   f.(CminorSel.fn_stackspace)
                   s.(st_code)
                   nentry)
  end.

Definition transl_fundef := transf_partial_fundef transl_function.

Definition transl_program (p: CminorSel.program) : Errors.res RTL.program :=
  transform_partial_program transl_fundef p. *)

Require Import RTLgenspec.
(* RTLgenspec:
Require Import Coqlib.
Require Errors.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Switch.
Require Import Op.
Require Import Registers.
Require Import CminorSel.
Require Import RTL.
Require Import RTLgen.

Remark bind_inversion:
  forall (A B: Type) (f: mon A) (g: A -> mon B)
         (y: B) (s1 s3: state) (i: state_incr s1 s3),
  bind f g s1 = OK y s3 i ->
  exists x, exists s2, exists i1, exists i2,
  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2.

Remark bind2_inversion:
  forall (A B C: Type) (f: mon (A*B)) (g: A -> B -> mon C)
         (z: C) (s1 s3: state) (i: state_incr s1 s3),
  bind2 f g s1 = OK z s3 i ->
  exists x, exists y, exists s2, exists i1, exists i2,
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2.

Ltac monadInv1 H :=
  match type of H with
  | (OK _ _ _ = OK _ _ _) =>
      inversion H; clear H; try subst
  | (Error _ _ = OK _ _ _) =>
      discriminate
  | (ret _ _ = OK _ _ _) =>
      inversion H; clear H; try subst
  | (error _ _ = OK _ _ _) =>
      discriminate
  | (bind ?F ?G ?S = OK ?X ?S' ?I) =>
      let x := fresh "x" in (
      let s := fresh "s" in (
      let i1 := fresh "INCR" in (
      let i2 := fresh "INCR" in (
      let EQ1 := fresh "EQ" in (
      let EQ2 := fresh "EQ" in (
      destruct (bind_inversion _ _ F G X S S' I H) as [x [s [i1 [i2 [EQ1 EQ2]]]]];
      clear H;
      try (monadInv1 EQ2)))))))
  | (bind2 ?F ?G ?S = OK ?X ?S' ?I) =>
      let x1 := fresh "x" in (
      let x2 := fresh "x" in (
      let s := fresh "s" in (
      let i1 := fresh "INCR" in (
      let i2 := fresh "INCR" in (
      let EQ1 := fresh "EQ" in (
      let EQ2 := fresh "EQ" in (
      destruct (bind2_inversion _ _ _ F G X S S' I H) as [x1 [x2 [s [i1 [i2 [EQ1 EQ2]]]]]];
      clear H;
      try (monadInv1 EQ2))))))))
  end.

Ltac monadInv H :=
  match type of H with
  | (ret _ _ = OK _ _ _) => monadInv1 H
  | (error _ _ = OK _ _ _) => monadInv1 H
  | (bind ?F ?G ?S = OK ?X ?S' ?I) => monadInv1 H
  | (bind2 ?F ?G ?S = OK ?X ?S' ?I) => monadInv1 H
  | (?F _ _ _ _ _ _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ = OK _ _ _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  end.

Hint Resolve state_incr_refl: rtlg.

Lemma instr_at_incr:
  forall s1 s2 n i,
  state_incr s1 s2 -> s1.(st_code)!n = Some i -> s2.(st_code)!n = Some i.
Hint Resolve instr_at_incr: rtlg.

Ltac saturateTrans :=
  match goal with
  | H1: state_incr ?x ?y, H2: state_incr ?y ?z |- _ =>
      match goal with
      | H: state_incr x z |- _  =>
         fail 1
      | _ =>
         let i := fresh "INCR" in
         (generalize (state_incr_trans x y z H1 H2); intro i;
          saturateTrans)
      end
  | _ => idtac
  end.

Definition reg_valid (r: reg) (s: state) : Prop :=
  Plt r s.(st_nextreg).

Definition reg_fresh (r: reg) (s: state) : Prop :=
  ~(Plt r s.(st_nextreg)).

Lemma valid_fresh_absurd:
  forall r s, reg_valid r s -> reg_fresh r s -> False.
Hint Resolve valid_fresh_absurd: rtlg.

Lemma valid_fresh_different:
  forall r1 r2 s, reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2.
Hint Resolve valid_fresh_different: rtlg.

Lemma reg_valid_incr:
  forall r s1 s2, state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2.
Hint Resolve reg_valid_incr: rtlg.

Lemma reg_fresh_decr:
  forall r s1 s2, state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1.
Hint Resolve reg_fresh_decr: rtlg.

Definition regs_valid (rl: list reg) (s: state) : Prop :=
  forall r, In r rl -> reg_valid r s.

Lemma regs_valid_nil:
  forall s, regs_valid nil s.
Hint Resolve regs_valid_nil: rtlg.

Lemma regs_valid_cons:
  forall r1 rl s,
  reg_valid r1 s -> regs_valid rl s -> regs_valid (r1 :: rl) s.

Lemma regs_valid_incr:
  forall s1 s2 rl, state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2.
Hint Resolve regs_valid_incr: rtlg.

Definition reg_in_map (m: mapping) (r: reg) : Prop :=
  (exists id, m.(map_vars)!id = Some r) \/ In r m.(map_letvars).

Definition map_valid (m: mapping) (s: state) : Prop :=
  forall r, reg_in_map m r -> reg_valid r s.

Lemma map_valid_incr:
  forall s1 s2 m,
  state_incr s1 s2 -> map_valid m s1 -> map_valid m s2.
Hint Resolve map_valid_incr: rtlg.

Lemma add_instr_at:
  forall s1 s2 incr i n,
  add_instr i s1 = OK n s2 incr -> s2.(st_code)!n = Some i.
Hint Resolve add_instr_at: rtlg.

Lemma update_instr_at:
  forall n i s1 s2 incr u,
  update_instr n i s1 = OK u s2 incr -> s2.(st_code)!n = Some i.
Hint Resolve update_instr_at: rtlg.

Lemma new_reg_valid:
  forall s1 s2 r i,
  new_reg s1 = OK r s2 i -> reg_valid r s2.
Hint Resolve new_reg_valid: rtlg.

Lemma new_reg_fresh:
  forall s1 s2 r i,
  new_reg s1 = OK r s2 i -> reg_fresh r s1.
Hint Resolve new_reg_fresh: rtlg.

Lemma new_reg_not_in_map:
  forall s1 s2 m r i,
  new_reg s1 = OK r s2 i -> map_valid m s1 -> ~(reg_in_map m r).
Hint Resolve new_reg_not_in_map: rtlg.

Lemma init_mapping_valid:
  forall s, map_valid init_mapping s.

Lemma find_var_in_map:
  forall s1 s2 map name r i,
  find_var map name s1 = OK r s2 i -> reg_in_map map r.
Hint Resolve find_var_in_map: rtlg.

Lemma find_var_valid:
  forall s1 s2 map name r i,
  find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.
Hint Resolve find_var_valid: rtlg.

Lemma find_letvar_in_map:
  forall s1 s2 map idx r i,
  find_letvar map idx s1 = OK r s2 i -> reg_in_map map r.
Hint Resolve find_letvar_in_map: rtlg.

Lemma find_letvar_valid:
  forall s1 s2 map idx r i,
  find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.
Hint Resolve find_letvar_valid: rtlg.

Lemma add_var_valid:
  forall s1 s2 map1 map2 name r i,
  add_var map1 name s1 = OK (r, map2) s2 i ->
  map_valid map1 s1 ->
  reg_valid r s2 /\ map_valid map2 s2.

Lemma add_var_find:
  forall s1 s2 map name r map' i,
  add_var map name s1 = OK (r,map') s2 i -> map'.(map_vars)!name = Some r.

Lemma add_vars_valid:
  forall namel s1 s2 map1 map2 rl i,
  add_vars map1 namel s1 = OK (rl, map2) s2 i ->
  map_valid map1 s1 ->
  regs_valid rl s2 /\ map_valid map2 s2.

Lemma add_var_letenv:
  forall map1 id s1 r map2 s2 i,
  add_var map1 id s1 = OK (r, map2) s2 i ->
  map2.(map_letvars) = map1.(map_letvars).

Lemma add_vars_letenv:
  forall il map1 s1 rl map2 s2 i,
  add_vars map1 il s1 = OK (rl, map2) s2 i ->
  map2.(map_letvars) = map1.(map_letvars).

Lemma add_letvar_valid:
  forall map s r,
  map_valid map s ->
  reg_valid r s ->
  map_valid (add_letvar map r) s.

Lemma alloc_reg_valid:
  forall a s1 s2 map r i,
  map_valid map s1 ->
  alloc_reg map a s1 = OK r s2 i -> reg_valid r s2.
Hint Resolve alloc_reg_valid: rtlg.

Lemma alloc_reg_fresh_or_in_map:
  forall map a s r s' i,
  map_valid map s ->
  alloc_reg map a s = OK r s' i ->
  reg_in_map map r \/ reg_fresh r s.

Lemma alloc_regs_valid:
  forall al s1 s2 map rl i,
  map_valid map s1 ->
  alloc_regs map al s1 = OK rl s2 i ->
  regs_valid rl s2.
Hint Resolve alloc_regs_valid: rtlg.

Lemma alloc_regs_fresh_or_in_map:
  forall map al s rl s' i,
  map_valid map s ->
  alloc_regs map al s = OK rl s' i ->
  forall r, In r rl -> reg_in_map map r \/ reg_fresh r s.

Lemma alloc_optreg_valid:
  forall dest s1 s2 map r i,
  map_valid map s1 ->
  alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.
Hint Resolve alloc_optreg_valid: rtlg.

Lemma alloc_optreg_fresh_or_in_map:
  forall map dest s r s' i,
  map_valid map s ->
  alloc_optreg map dest s = OK r s' i ->
  reg_in_map map r \/ reg_fresh r s.

Inductive target_reg_ok (map: mapping) (pr: list reg): expr -> reg -> Prop :=
  | target_reg_var:
      forall id r,
      map.(map_vars)!id = Some r ->
      target_reg_ok map pr (Evar id) r
  | target_reg_letvar:
      forall idx r,
      nth_error map.(map_letvars) idx = Some r ->
      target_reg_ok map pr (Eletvar idx) r
  | target_reg_other:
      forall a r,
      ~(reg_in_map map r) -> ~In r pr ->
      target_reg_ok map pr a r.

Inductive target_regs_ok (map: mapping) (pr: list reg): exprlist -> list reg -> Prop :=
  | target_regs_nil:
      target_regs_ok map pr Enil nil
  | target_regs_cons: forall a1 al r1 rl,
      target_reg_ok map pr a1 r1 ->
      target_regs_ok map (r1 :: pr) al rl ->
      target_regs_ok map pr (Econs a1 al) (r1 :: rl).

Lemma target_reg_ok_append:
  forall map pr a r,
  target_reg_ok map pr a r ->
  forall pr',
  (forall r', In r' pr' -> reg_in_map map r' \/ r' <> r) ->
  target_reg_ok map (pr' ++ pr) a r.

Lemma target_reg_ok_cons:
  forall map pr a r,
  target_reg_ok map pr a r ->
  forall r',
  reg_in_map map r' \/ r' <> r ->
  target_reg_ok map (r' :: pr) a r.

Lemma new_reg_target_ok:
  forall map pr s1 a r s2 i,
  map_valid map s1 ->
  regs_valid pr s1 ->
  new_reg s1 = OK r s2 i ->
  target_reg_ok map pr a r.

Lemma alloc_reg_target_ok:
  forall map pr s1 a r s2 i,
  map_valid map s1 ->
  regs_valid pr s1 ->
  alloc_reg map a s1 = OK r s2 i ->
  target_reg_ok map pr a r.

Lemma alloc_regs_target_ok:
  forall map al pr s1 rl s2 i,
  map_valid map s1 ->
  regs_valid pr s1 ->
  alloc_regs map al s1 = OK rl s2 i ->
  target_regs_ok map pr al rl.

Hint Resolve new_reg_target_ok alloc_reg_target_ok
             alloc_regs_target_ok: rtlg.

Inductive return_reg_ok: state -> mapping -> option reg -> Prop :=
  | return_reg_ok_none:
      forall s map,
      return_reg_ok s map None
  | return_reg_ok_some:
      forall s map r,
      ~(reg_in_map map r) -> reg_valid r s ->
      return_reg_ok s map (Some r).

Lemma return_reg_ok_incr:
  forall s map rret, return_reg_ok s map rret ->
  forall s', state_incr s s' -> return_reg_ok s' map rret.
Hint Resolve return_reg_ok_incr: rtlg.

Lemma new_reg_return_ok:
  forall s1 r s2 map sig i,
  new_reg s1 = OK r s2 i ->
  map_valid map s1 ->
  return_reg_ok s2 map (ret_reg sig r).

Inductive tr_move (c: code):
       node -> reg -> node -> reg -> Prop :=
  | tr_move_0: forall n r,
      tr_move c n r n r
  | tr_move_1: forall ns rs nd rd,
      c!ns = Some (Iop Omove (rs :: nil) rd nd) ->
      tr_move c ns rs nd rd.

Inductive reg_map_ok: mapping -> reg -> option ident -> Prop :=
  | reg_map_ok_novar: forall map rd,
      ~reg_in_map map rd ->
      reg_map_ok map rd None
  | reg_map_ok_somevar: forall map rd id,
      map.(map_vars)!id = Some rd ->
      reg_map_ok map rd (Some id).

Hint Resolve reg_map_ok_novar: rtlg.

Inductive tr_expr (c: code):
       mapping -> list reg -> expr -> node -> node -> reg -> option ident -> Prop :=
  | tr_Evar: forall map pr id ns nd r rd dst,
      map.(map_vars)!id = Some r ->
      ((rd = r /\ dst = None) \/ (reg_map_ok map rd dst /\ ~In rd pr)) ->
      tr_move c ns r nd rd ->
      tr_expr c map pr (Evar id) ns nd rd dst
  | tr_Eop: forall map pr op al ns nd rd n1 rl dst,
      tr_exprlist c map pr al ns n1 rl ->
      c!n1 = Some (Iop op rl rd nd) ->
      reg_map_ok map rd dst -> ~In rd pr ->
      tr_expr c map pr (Eop op al) ns nd rd dst
  | tr_Eload: forall map pr chunk addr al ns nd rd n1 rl dst,
      tr_exprlist c map pr al ns n1 rl ->
      c!n1 = Some (Iload chunk addr rl rd nd) ->
      reg_map_ok map rd dst -> ~In rd pr ->
      tr_expr c map pr (Eload chunk addr al) ns nd rd dst
  | tr_Econdition: forall map pr a ifso ifnot ns nd rd ntrue nfalse dst,
      tr_condition c map pr a ns ntrue nfalse ->
      tr_expr c map pr ifso ntrue nd rd dst ->
      tr_expr c map pr ifnot nfalse nd rd dst ->
      tr_expr c map pr (Econdition a ifso ifnot) ns nd rd dst
  | tr_Elet: forall map pr b1 b2 ns nd rd n1 r dst,
      ~reg_in_map map r ->
      tr_expr c map pr b1 ns n1 r None ->
      tr_expr c (add_letvar map r) pr b2 n1 nd rd dst ->
      tr_expr c map pr (Elet b1 b2) ns nd rd dst
  | tr_Eletvar: forall map pr n ns nd rd r dst,
      List.nth_error map.(map_letvars) n = Some r ->
      ((rd = r /\ dst = None) \/ (reg_map_ok map rd dst /\ ~In rd pr)) ->
      tr_move c ns r nd rd ->
      tr_expr c map pr (Eletvar n) ns nd rd dst
  | tr_Ebuiltin: forall map pr ef al ns nd rd dst n1 rl,
      tr_exprlist c map pr al ns n1 rl ->
      c!n1 = Some (Ibuiltin ef rl rd nd) ->
      reg_map_ok map rd dst -> ~In rd pr ->
      tr_expr c map pr (Ebuiltin ef al) ns nd rd dst
  | tr_Eexternal: forall map pr id sg al ns nd rd dst n1 rl,
      tr_exprlist c map pr al ns n1 rl ->
      c!n1 = Some (Icall sg (inr _ id) rl rd nd) ->
      reg_map_ok map rd dst -> ~In rd pr ->
      tr_expr c map pr (Eexternal id sg al) ns nd rd dst

with tr_condition (c: code):
       mapping -> list reg -> condexpr -> node -> node -> node -> Prop :=
  | tr_CEcond: forall map pr cond bl ns ntrue nfalse n1 rl,
      tr_exprlist c map pr bl ns n1 rl ->
      c!n1 = Some (Icond cond rl ntrue nfalse) ->
      tr_condition c map pr (CEcond cond bl) ns ntrue nfalse
  | tr_CEcondition: forall map pr a1 a2 a3 ns ntrue nfalse n2 n3,
      tr_condition c map pr a1 ns n2 n3 ->
      tr_condition c map pr a2 n2 ntrue nfalse ->
      tr_condition c map pr a3 n3 ntrue nfalse ->
      tr_condition c map pr (CEcondition a1 a2 a3) ns ntrue nfalse
  | tr_CElet: forall map pr a b ns ntrue nfalse r n1,
      ~reg_in_map map r ->
      tr_expr c map pr a ns n1 r None ->
      tr_condition c (add_letvar map r) pr b n1 ntrue nfalse ->
      tr_condition c map pr (CElet a b) ns ntrue nfalse

with tr_exprlist (c: code):
       mapping -> list reg -> exprlist -> node -> node -> list reg -> Prop :=
  | tr_Enil: forall map pr n,
      tr_exprlist c map pr Enil n n nil
  | tr_Econs: forall map pr a1 al ns nd r1 rl n1,
      tr_expr c map pr a1 ns n1 r1 None ->
      tr_exprlist c map (r1 :: pr) al n1 nd rl ->
      tr_exprlist c map pr (Econs a1 al) ns nd (r1 :: rl).

Definition tr_jumptable (nexits: list node) (tbl: list nat) (ttbl: list node) : Prop :=
  forall v act,
  list_nth_z tbl v = Some act ->
  exists n, list_nth_z ttbl v = Some n /\ nth_error nexits act = Some n.

Inductive tr_switch
     (c: code) (map: mapping) (r: reg) (nexits: list node):
     comptree -> node -> Prop :=
  | tr_switch_action: forall act n,
      nth_error nexits act = Some n ->
      tr_switch c map r nexits (CTaction act) n
  | tr_switch_ifeq: forall key act t' n ncont nfound,
      tr_switch c map r nexits t' ncont ->
      nth_error nexits act = Some nfound ->
      c!n = Some(Icond (Ccompimm Ceq key) (r :: nil) nfound ncont) ->
      tr_switch c map r nexits (CTifeq key act t') n
  | tr_switch_iflt: forall key t1 t2 n n1 n2,
      tr_switch c map r nexits t1 n1 ->
      tr_switch c map r nexits t2 n2 ->
      c!n = Some(Icond (Ccompuimm Clt key) (r :: nil) n1 n2) ->
      tr_switch c map r nexits (CTiflt key t1 t2) n
  | tr_switch_jumptable: forall ofs sz tbl t n n1 n2 n3 rt ttbl,
      ~reg_in_map map rt -> rt <> r ->
      c!n = Some(Iop (if Int.eq ofs Int.zero then Omove else Oaddimm (Int.neg ofs))
                     (r ::nil) rt n1) ->
      c!n1 = Some(Icond (Ccompuimm Clt sz) (rt :: nil) n2 n3) ->
      c!n2 = Some(Ijumptable rt ttbl) ->
      tr_switch c map r nexits t n3 ->
      tr_jumptable nexits tbl ttbl ->
      tr_switch c map r nexits (CTjumptable ofs sz tbl t) n.

Inductive tr_stmt (c: code) (map: mapping):
     stmt -> node -> node -> list node -> labelmap -> node -> option reg -> Prop :=
  | tr_Sskip: forall ns nexits ngoto nret rret,
     tr_stmt c map Sskip ns ns nexits ngoto nret rret
  | tr_Sassign: forall id a ns nd nexits ngoto nret rret r,
     map.(map_vars)!id = Some r ->
     tr_expr c map nil a ns nd r (Some id) ->
     tr_stmt c map (Sassign id a) ns nd nexits ngoto nret rret
  | tr_Sstore: forall chunk addr al b ns nd nexits ngoto nret rret rd n1 rl n2,
     tr_exprlist c map nil al ns n1 rl ->
     tr_expr c map rl b n1 n2 rd None ->
     c!n2 = Some (Istore chunk addr rl rd nd) ->
     tr_stmt c map (Sstore chunk addr al b) ns nd nexits ngoto nret rret
  | tr_Scall: forall optid sig b cl ns nd nexits ngoto nret rret rd n1 rf n2 rargs,
     tr_expr c map nil b ns n1 rf None ->
     tr_exprlist c map (rf :: nil) cl n1 n2 rargs ->
     c!n2 = Some (Icall sig (inl _ rf) rargs rd nd) ->
     reg_map_ok map rd optid ->
     tr_stmt c map (Scall optid sig (inl _ b) cl) ns nd nexits ngoto nret rret
  | tr_Scall_imm: forall optid sig id cl ns nd nexits ngoto nret rret rd n2 rargs,
     tr_exprlist c map nil cl ns n2 rargs ->
     c!n2 = Some (Icall sig (inr _ id) rargs rd nd) ->
     reg_map_ok map rd optid ->
     tr_stmt c map (Scall optid sig (inr _ id) cl) ns nd nexits ngoto nret rret
  | tr_Stailcall: forall sig b cl ns nd nexits ngoto nret rret n1 rf n2 rargs,
     tr_expr c map nil b ns n1 rf None ->
     tr_exprlist c map (rf :: nil) cl n1 n2 rargs ->
     c!n2 = Some (Itailcall sig (inl _ rf) rargs) ->
     tr_stmt c map (Stailcall sig (inl _ b) cl) ns nd nexits ngoto nret rret
  | tr_Stailcall_imm: forall sig id cl ns nd nexits ngoto nret rret n2 rargs,
     tr_exprlist c map nil cl ns n2 rargs ->
     c!n2 = Some (Itailcall sig (inr _ id) rargs) ->
     tr_stmt c map (Stailcall sig (inr _ id) cl) ns nd nexits ngoto nret rret
  | tr_Sbuiltin: forall optid ef al ns nd nexits ngoto nret rret rd n1 rargs,
     tr_exprlist c map nil al ns n1 rargs ->
     c!n1 = Some (Ibuiltin ef rargs rd nd) ->
     reg_map_ok map rd optid ->
     tr_stmt c map (Sbuiltin optid ef al) ns nd nexits ngoto nret rret
  | tr_Sseq: forall s1 s2 ns nd nexits ngoto nret rret n,
     tr_stmt c map s2 n nd nexits ngoto nret rret ->
     tr_stmt c map s1 ns n nexits ngoto nret rret ->
     tr_stmt c map (Sseq s1 s2) ns nd nexits ngoto nret rret
  | tr_Sifthenelse: forall a strue sfalse ns nd nexits ngoto nret rret ntrue nfalse,
     tr_stmt c map strue ntrue nd nexits ngoto nret rret ->
     tr_stmt c map sfalse nfalse nd nexits ngoto nret rret ->
     tr_condition c map nil a ns ntrue nfalse ->
     tr_stmt c map (Sifthenelse a strue sfalse) ns nd nexits ngoto nret rret
  | tr_Sloop: forall sbody ns nd nexits ngoto nret rret nloop nend,
     tr_stmt c map sbody nloop nend nexits ngoto nret rret ->
     c!ns = Some(Inop nloop) ->
     c!nend = Some(Inop nloop) ->
     tr_stmt c map (Sloop sbody) ns nd nexits ngoto nret rret
  | tr_Sblock: forall sbody ns nd nexits ngoto nret rret,
     tr_stmt c map sbody ns nd (nd :: nexits) ngoto nret rret ->
     tr_stmt c map (Sblock sbody) ns nd nexits ngoto nret rret
  | tr_Sexit: forall n ns nd nexits ngoto nret rret,
     nth_error nexits n = Some ns ->
     tr_stmt c map (Sexit n) ns nd nexits ngoto nret rret
  | tr_Sswitch: forall a cases default ns nd nexits ngoto nret rret n r t,
     validate_switch default cases t = true ->
     tr_expr c map nil a ns n r None ->
     tr_switch c map r nexits t n ->
     tr_stmt c map (Sswitch a cases default) ns nd nexits ngoto nret rret
  | tr_Sreturn_none: forall nret nd nexits ngoto rret,
     tr_stmt c map (Sreturn None) nret nd nexits ngoto nret rret
  | tr_Sreturn_some: forall a ns nd nexits ngoto nret rret,
     tr_expr c map nil a ns nret rret None ->
     tr_stmt c map (Sreturn (Some a)) ns nd nexits ngoto nret (Some rret)
  | tr_Slabel: forall lbl s ns nd nexits ngoto nret rret n,
     ngoto!lbl = Some n ->
     c!n = Some (Inop ns) ->
     tr_stmt c map s ns nd nexits ngoto nret rret ->
     tr_stmt c map (Slabel lbl s) ns nd nexits ngoto nret rret
  | tr_Sgoto: forall lbl ns nd nexits ngoto nret rret,
     ngoto!lbl = Some ns ->
     tr_stmt c map (Sgoto lbl) ns nd nexits ngoto nret rret.

Inductive tr_function: CminorSel.function -> RTL.function -> Prop :=
  | tr_function_intro:
      forall f code rparams map1 s0 s1 i1 rvars map2 s2 i2 nentry ngoto nret rret orret,
      add_vars init_mapping f.(CminorSel.fn_params) s0 = OK (rparams, map1) s1 i1 ->
      add_vars map1 f.(CminorSel.fn_vars) s1 = OK (rvars, map2) s2 i2 ->
      orret = ret_reg f.(CminorSel.fn_sig) rret ->
      tr_stmt code map2 f.(CminorSel.fn_body) nentry nret nil ngoto nret orret ->
      code!nret = Some(Ireturn orret) ->
      tr_function f (RTL.mkfunction
                       f.(CminorSel.fn_sig)
                       rparams
                       f.(CminorSel.fn_stackspace)
                       code
                       nentry).

Lemma tr_move_incr:
  forall s1 s2, state_incr s1 s2 ->
  forall ns rs nd rd,
  tr_move s1.(st_code) ns rs nd rd ->

Lemma tr_expr_incr:
  forall s1 s2, state_incr s1 s2 ->
  forall map pr a ns nd rd dst,
  tr_expr s1.(st_code) map pr a ns nd rd dst ->

Lemma add_move_charact:
  forall s ns rs nd rd s' i,
  add_move rs rd nd s = OK ns s' i ->
  tr_move s'.(st_code) ns rs nd rd.

Lemma transl_expr_charact:
  forall a map rd nd s ns s' pr INCR
     (TR: transl_expr map a rd nd s = OK ns s' INCR)
     (WF: map_valid map s)
     (OK: target_reg_ok map pr a rd)
     (VALID: regs_valid pr s)
     (VALID2: reg_valid rd s),
   tr_expr s'.(st_code) map pr a ns nd rd None

Lemma transl_expr_assign_charact:
  forall id a map rd nd s ns s' INCR
     (TR: transl_expr map a rd nd s = OK ns s' INCR)
     (WF: map_valid map s)
     (OK: reg_map_ok map rd (Some id)),
   tr_expr s'.(st_code) map nil a ns nd rd (Some id).

Lemma alloc_optreg_map_ok:
  forall map optid s1 r s2 i,
  map_valid map s1 ->
  alloc_optreg map optid s1 = OK r s2 i ->
  reg_map_ok map r optid.

Lemma tr_switch_incr:
  forall s1 s2, state_incr s1 s2 ->
  forall map r nexits t ns,
  tr_switch s1.(st_code) map r nexits t ns ->

Lemma tr_stmt_incr:
  forall s1 s2, state_incr s1 s2 ->
  forall map s ns nd nexits ngoto nret rret,
  tr_stmt s1.(st_code) map s ns nd nexits ngoto nret rret ->

Lemma transl_exit_charact:
  forall nexits n s ne s' incr,
  transl_exit nexits n s = OK ne s' incr ->
  nth_error nexits n = Some ne /\ s' = s.

Lemma transl_jumptable_charact:
  forall nexits tbl s nl s' incr,
  transl_jumptable nexits tbl s = OK nl s' incr ->
  tr_jumptable nexits tbl nl /\ s' = s.

Lemma transl_switch_charact:
  forall map r nexits t s ns s' incr,
  map_valid map s -> reg_valid r s ->
  transl_switch r nexits t s = OK ns s' incr ->
  tr_switch s'.(st_code) map r nexits t ns.

Lemma transl_stmt_charact:
  forall map stmt nd nexits ngoto nret rret s ns s' INCR
    (TR: transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR)
    (WF: map_valid map s)
    (OK: return_reg_ok s map rret),
  tr_stmt s'.(st_code) map stmt ns nd nexits ngoto nret rret.

Lemma transl_function_charact:
  forall f tf,
  transl_function f = Errors.OK tf -> *)



Require Import sepcomp.mem_lemmas.
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.core_semantics.

Require Import sepcomp.effect_semantics.
(* sepcomp.effect_semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Record EffectSem {C} :=
  { 
    sem :> @MemSem C

  ; effstep: (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop

  ; effax1: forall M c m c' m',
       effstep M c m c' m' ->
            corestep sem c m c' m'
         /\ Mem.unchanged_on (fun b ofs => M b ofs = false) m m'
  ; effax2: forall c m c' m',
       corestep sem c m c' m' ->
       exists M, effstep M c m c' m'
  ; effstep_perm: forall M c m c' m',
       effstep M c m c' m' ->
       forall b z, M b z = true -> Mem.perm m b z Cur Writable
  }.

Section effsemlemmas.
  Context {C:Type} (Sem: @EffectSem C).

  Lemma effstep_valid: forall M c m c' m',
       effstep Sem M c m c' m' ->
       forall b z, M b z = true -> Mem.valid_block m b.

  Lemma effstep_corestep: forall M c m c' m',
      effstep Sem M c m c' m' -> corestep Sem c m c' m'.

  Lemma effstep_unchanged: forall M c m c' m',
        effstep Sem M c m c' m' ->
        Mem.unchanged_on (fun b ofs => M b ofs = false) m m'.

  Lemma effstep_mem U c m c' m' (EF: effstep Sem U c m c' m'): mem_step m m'.

  Lemma effstep_fwd U c m c' m' (EF: effstep Sem U c m c' m'): mem_forward m m'.

  Fixpoint effstepN (n:nat) : (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop :=
    match n with
      | O => fun U c m c' m' => (c,m) = (c',m') /\ U = (fun b z => false)
      | S k => fun U c1 m1 c3 m3 => exists c2, exists m2, exists U1, exists U2,
        effstep Sem U1 c1 m1 c2 m2 /\
        effstepN k U2 c2 m2 c3 m3 /\
        U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b))
    end.

  Lemma effstepN_perm: forall n U c1 m1 c2 m2, effstepN n U c1 m1 c2 m2 ->
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.
  Lemma effstepN_valid n U c1 m1 c2 m2  (Step:effstepN n U c1 m1 c2 m2)
        b z (EFF:U b z = true): Mem.valid_block m1 b.

  Lemma effstepN_mem: forall n U c m c' m' (EF: effstepN n U c m c' m'), mem_step m m'.

  Lemma effstepN_fwd n U c m c' m' (EF:effstepN n U c m c' m'): mem_forward m m'.

  Lemma effstepN_corestepN: forall n E c m c' m',
      effstepN n E c m c' m' -> corestepN Sem n c m c' m'.

  Lemma effstepN_unchanged: forall n U c1 m1 c2 m2,
        effstepN n U c1 m1 c2 m2 ->
        Mem.unchanged_on (fun b z => U b z = false) m1 m2.

Lemma effstepN_trans: forall n1 n2 U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
   effstepN (n1+n2)
        (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) st1 m1 st3 m3.

Lemma effstepN_trans': forall n1 n2 U U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
   effstepN (n1+n2) U st1 m1 st3 m3.

  Definition effstep_plus U c m c' m' :=
    exists n, effstepN (S n) U c m c' m'.

  Definition effstep_star U c m c' m' :=
    exists n, effstepN n U c m c' m'.

  Lemma effstep_plus_corestep_plus U c m c' m' (EFF: effstep_plus U c m c' m'):
        corestep_plus Sem c m c' m'.

  Lemma effstep_star_corestep_star U c m c' m' (EFF: effstep_star U c m c' m'):
        corestep_star Sem c m c' m'.

  Lemma effstep_plus_star : forall U c1 c2 m1 m2,
    effstep_plus U c1 m1 c2 m2 -> effstep_star U c1 m1 c2 m2.

  Lemma effstep_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_plus_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_star (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_star U c1 m1 c3 m3.

  Lemma effstep_plus_one: forall U c m c' m',
    effstep Sem U c m c' m' -> effstep_plus U c m c' m'.

  Lemma effstep_plus_two: forall U1 c m c' m' U2 c'' m'',
    effstep  Sem U1 c m c' m' -> effstep Sem U2 c' m' c'' m'' ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m b)) c m c'' m''.

  Lemma effstep_star_zero: forall c m, effstep_star (fun b z =>false) c m c m.

  Lemma effstep_star_one: forall U c m c' m',
    effstep  Sem U c m c' m' -> effstep_star U c m c' m'.

  Lemma effstep_plus_split: forall U c m c' m',
    effstep_plus U c m c' m' ->
    exists c'', exists m'', exists U1, exists U2,
      effstep Sem U1 c m c'' m'' /\
      effstep_star U2 c'' m'' c' m' /\
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m b)).

  Lemma effstep_plus_perm U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_star_perm U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_plus_valid U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_valid U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_mem U c m c' m' (EF: effstep_star U c m c' m'): mem_step m m'.

  Lemma effstep_plus_mem U c m c' m' (EF: effstep_plus U c m c' m'): mem_step m m'.

  Lemma effstep_plus_fwd U c m c' m' (EF: effstep_plus U c m c' m'): mem_forward m m'.
  Lemma effstep_star_fwd U c m c' m' (EF: effstep_star U c m c' m'): mem_forward m m'.

End effsemlemmas.

Definition EmptyEffect: Values.block -> Z -> bool := fun b z => false.

Lemma EmptyEffect_alloc: forall m lo hi m' b (ALLOC: Mem.alloc m lo hi = (m', b)),

Definition FreeEffect m lo hi (sp b:Values.block) (ofs:Z): bool :=
   if valid_block_dec m b
   then eq_block b sp && zle lo ofs && zlt ofs hi
   else false.

Lemma FreeEffectD: forall m lo hi sp b z
   (FREE:FreeEffect m lo hi sp b z = true),
   b = sp /\ Mem.valid_block m b /\ lo <= z /\ z < hi.

Lemma FreeEffect_free: forall m sp lo hi m'
             (FREE: Mem.free m sp lo hi = Some m'),

Definition FreelistEffect
  m (L: list (Values.block * Z * Z)) (b:Values.block) (ofs:Z): bool :=
  List.fold_right (fun X E b z => match X with (bb,lo,hi) =>
                                   E b z || FreeEffect m lo hi bb b z
                                 end)
                  EmptyEffect L b ofs.

Lemma FreelistEffect_Dfalse: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = false),
      FreelistEffect m L b ofs = false /\
      FreeEffect m lo hi bb b ofs = false.

Lemma FreelistEffect_Dtrue: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = true),
      FreelistEffect m L b ofs = true \/
      FreeEffect m lo hi bb b ofs = true.

Lemma FreelistEffect_same: forall m bb lo hi mm L
          (F:Mem.free m bb lo hi = Some mm)

Lemma FreelistEffect_freelist: forall L m m' (FL: Mem.free_list m L = Some m'),

Lemma FreeEffect_validblock: forall m lo hi sp b ofs
        (EFF: FreeEffect m lo hi sp b ofs = true),
      Mem.valid_block m b.

Lemma FreelistEffect_validblock: forall l m b ofs
        (EFF: FreelistEffect m l b ofs = true),
      Mem.valid_block m b.

Definition StoreEffect (tv:val)(vl : list memval) (b:Values.block) (z:Z):bool :=
  match tv with Vptr bb ofs => eq_block bb b &&
             zle (Ptrofs.unsigned ofs) z && zlt z (Ptrofs.unsigned ofs + Z.of_nat (length vl))
         | _ => false
  end.

Lemma StoreEffect_Storev: forall m chunk tv tv' m'
         (STORE : Mem.storev chunk m tv tv' = Some m'),

Lemma StoreEffectD: forall vaddr v b ofs
      (STE: StoreEffect vaddr v b ofs = true),
      exists i, vaddr = Vptr b i /\
        (Ptrofs.unsigned i) <= ofs < (Ptrofs.unsigned i + Z.of_nat (length v)).

Lemma free_curWR m sp lo hi m' (FR: Mem.free m sp lo hi = Some m')

Lemma storev_curWR ch m vaddr v m' (ST:Mem.storev ch m vaddr v = Some m')

Lemma freelist_curWR l: forall m m' (FR: Mem.free_list m l = Some m') *)

Require Import StructuredInjections.
(* StructuredInjections:
Require Import Events.
Require Import Memory.
Require Import Coqlib.
Require Import compcert.common.Values.
Require Import Axioms.

Require Import sepcomp.mem_lemmas.

Lemma compose_meminjI_Some: forall j k b1 b2 d1 b3 d2
          (J:j b1 = Some(b2,d1)) (K:k b2 = Some(b3,d2)),
          compose_meminj j k b1 = Some(b3, d1+d2).

Lemma compose_meminjI_None: forall j k b1
          (H: (j b1 = None) \/
              (exists b2 d1, j b1 =Some(b2,d1) /\ k b2=None)),
          compose_meminj j k b1 = None.

Lemma inject_incr_coincide: forall f g (INC: inject_incr f g) b p
          (G:g b = Some p) q (F:f b = Some q),p=q.

Lemma inject_incr_inv: forall f g (INC: inject_incr f g) b
                       (G: g b =None), f b = None.

Lemma forall2_val_inject_D: forall vals1 vals2 j (ValInjMu : Forall2 (val_inject j) vals1 vals2)
          v1 (IN: In v1 vals1), exists v2, val_inject j v1 v2 /\ In v2 vals2.

Definition join (j k:meminj):meminj := fun b =>
  match j b with
     Some (b1, delta) => Some (b1,delta)
   | None => k b
  end.

Definition disjoint (j k:meminj):Prop :=
    forall b, j b = None \/ k b = None.

Lemma join_assoc: forall f g h, join f (join g h) = join (join f g) h.

Lemma join_com: forall f g, disjoint f g -> join f g = join g f.

Lemma disjoint_com: forall f g, disjoint f g <-> disjoint g f.

Lemma disjoint_sub: forall j k (D: disjoint j k) j' k'
              (J: inject_incr j' j) (K:inject_incr k' k),
              disjoint j' k'.

Lemma joinI: forall f g b p
             (Hp: f b = Some p \/ (f b = None /\ g b = Some p)),
      join f g b = Some p.

Lemma joinD: forall j k (D: disjoint j k) b,
   match join j k b with
     Some(b1,delta) => (j b = Some(b1,delta) /\ k b = None) \/
                       (k b = Some(b1,delta) /\ j b = None)
   | None => j b = None /\ k b = None
  end.

Lemma joinD_Some:
      forall j k b b' delta (J: join j k b = Some(b',delta)),
      j b = Some(b',delta) \/ (j b = None /\ k b = Some(b',delta)).

Lemma joinD_None:
      forall j k b (J: join j k b = None),
      j b = None /\ k b = None.

Lemma joinI_None: forall j k b (J:j b = None) (K:k b = None),
                  join j k b = None.

Lemma inject_incr_join: forall j j' k k'
  (J: inject_incr j j') (K: inject_incr k k')
  (D: disjoint j' k'),
  inject_incr (join j k) (join j' k').

Lemma join_incr_left: forall j k, inject_incr j (join j k).

Lemma join_incr_right: forall j k (D:disjoint j k),
                       inject_incr k (join j k).

Lemma disjointD_left:
      forall j k b b' delta (J: j b = Some (b',delta))
             (D:disjoint j k), k b = None.

Lemma disjointD_right:
      forall j k b b' delta (K: k b = Some (b',delta))
             (D:disjoint j k), j b = None.

Lemma join_left_agree:
      forall j k b b1 d1 (JK: join j k b = Some(b1,d1))
             b2 d2 (J: j b = Some(b2,d2)),
      b1=b2 /\ d1=d2.

Lemma join_right_agree:
      forall j k b b1 d1 (JK: join j k b = Some(b1,d1))
             b2 d2 (K: k b = Some(b2,d2)) (D:disjoint j k),
      b1=b2 /\ d1=d2.

Lemma join_disjoint: forall f g h (FH: disjoint f h) (GH: disjoint g h),
                     disjoint (join f g) h.

Lemma join_None_rightneutral: forall j, join j (fun b => None) = j.
Lemma join_None_leftneutral: forall j, join (fun b => None) j = j.

Record SM_Injection :=
  { locBlocksSrc : block -> bool;
                         locBlocksTgt : block -> bool;
                         pubBlocksSrc : block -> bool; 
    pubBlocksTgt : block -> bool; 
    local_of: meminj; 
    extBlocksSrc: block -> bool; 
    extBlocksTgt: block -> bool; 

    frgnBlocksSrc : block -> bool; 
    frgnBlocksTgt : block -> bool; 
    extern_of: meminj 
}.

Definition unknown_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if locBSrc b then None else if fSrc b then None else extern b
  end.

Definition foreign_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if fSrc b then extern b else None
  end.

Definition pub_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if pSrc b then local b else None
  end.

Definition priv_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if pSrc b then None else local b
  end.

Lemma local_pubpriv: forall mu,
      local_of mu = join (pub_of mu) (priv_of mu).

Definition shared_of (mu: SM_Injection) : meminj :=
  join (foreign_of mu) (pub_of mu).

Lemma unknown_in_extern: forall mu,
      inject_incr (unknown_of mu) (extern_of mu).

Lemma foreign_in_extern: forall mu,
      inject_incr (foreign_of mu) (extern_of mu).

Lemma foreign_in_shared: forall mu,
      inject_incr (foreign_of mu) (shared_of mu).

Lemma pub_in_local: forall mu,
      inject_incr (pub_of mu) (local_of mu).

Lemma priv_in_local: forall mu,
      inject_incr (priv_of mu) (local_of mu).

Lemma disjoint_pub_priv: forall mu, disjoint (pub_of mu) (priv_of mu).

Lemma disjoint_frgn_unknown: forall mu, disjoint (foreign_of mu) (unknown_of mu).

Record SM_wd (mu:SM_Injection):Prop := {
  disjoint_extern_local_Src: forall b, locBlocksSrc mu b = false \/ extBlocksSrc mu b = false;
  disjoint_extern_local_Tgt: forall b, locBlocksTgt mu b = false \/ extBlocksTgt mu b = false;

  local_DomRng: forall b1 b2 z, local_of mu b1 = Some(b2,z) ->
               (locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true);
  extern_DomRng: forall b1 b2 z, extern_of mu b1 = Some(b2,z) ->
               (extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true);

  pubSrcAx: forall b1, pubBlocksSrc mu b1 = true ->
              exists b2 z, local_of mu b1 = Some(b2,z) /\
                           pubBlocksTgt mu b2 = true;
  frgnSrcAx: forall b1, frgnBlocksSrc mu b1 = true ->
              exists b2 z, extern_of mu b1 = Some(b2,z) /\
                           frgnBlocksTgt mu b2 = true;

  pubBlocksLocalTgt: forall b, pubBlocksTgt mu b = true ->
                               locBlocksTgt mu b = true;
  frgnBlocksExternTgt: forall b, frgnBlocksTgt mu b = true ->
                              extBlocksTgt mu b = true
}.

Lemma pubSrc: forall mu (WD: SM_wd mu) b1, pubBlocksSrc mu b1 = true ->
              exists b2 z, pub_of mu b1 = Some(b2,z) /\
                           pubBlocksTgt mu b2 = true.

Lemma frgnSrc: forall mu (WD: SM_wd mu) b1, frgnBlocksSrc mu b1 = true ->
              exists b2 z, foreign_of mu b1 = Some(b2,z) /\
                           frgnBlocksTgt mu b2 = true.

Lemma extBlocksSrc_locBlocksSrc: forall mu (WD: SM_wd mu) b,
      extBlocksSrc mu b = true -> locBlocksSrc mu b = false.

Lemma extBlocksTgt_locBlocksTgt: forall mu (WD: SM_wd mu) b,
      extBlocksTgt mu b = true -> locBlocksTgt mu b = false.

Lemma locBlocksSrc_extBlocksSrc: forall mu (WD: SM_wd mu) b,
      locBlocksSrc mu b = true -> extBlocksSrc mu b = false.

Lemma locBlocksTgt_extBlocksTgt: forall mu (WD: SM_wd mu) b,
      locBlocksTgt mu b = true -> extBlocksTgt mu b = false.

Lemma pubBlocksLocalSrc: forall mu (WD: SM_wd mu) b,
      pubBlocksSrc mu b = true -> locBlocksSrc mu b = true.

Lemma frgnBlocksSrc_extBlocksSrc: forall mu (WD: SM_wd mu) b,
      frgnBlocksSrc mu b = true -> extBlocksSrc mu b = true.

Lemma locBlocksSrc_externNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), extern_of mu b = None.

Lemma locBlocksSrc_foreignNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), foreign_of mu b = None.

Lemma frgnBlocksSrc_locBlocksSrc: forall mu (WD:SM_wd mu) b
      (FB: frgnBlocksSrc mu b = true), locBlocksSrc mu b = false.

Lemma locBlocksSrc_frgnBlocksSrc: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), frgnBlocksSrc mu b = false.

Lemma locBlocksTgt_frgnBlocksTgt: forall mu (WD:SM_wd mu) b
      (MB: locBlocksTgt mu b = true), frgnBlocksTgt mu b = false.

Lemma frgnBlocksTgt_locBlocksTgt: forall mu (WD:SM_wd mu) b
      (FB: frgnBlocksTgt mu b = true), locBlocksTgt mu b = false.

Lemma locBlocksTgt_frgnBlocksTgt_D: forall mu (WD:SM_wd mu) b
            (MB: locBlocksTgt mu b = true) (FB: frgnBlocksTgt mu b = true),
      False.

Lemma locBlocksSrc_unknownNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), unknown_of mu b = None.

Lemma extern_foreignunknown: forall mu (WD: SM_wd mu),
      extern_of mu = join (foreign_of mu) (unknown_of mu).

Lemma pubChar: forall mu (WD: SM_wd mu) b1 b2 z, pub_of mu b1 = Some(b2,z) ->
               pubBlocksSrc mu b1 = true /\ pubBlocksTgt mu b2 = true.

Lemma privChar: forall mu b1 b2 z, priv_of mu b1 = Some(b2,z) ->
                pubBlocksSrc mu b1 = false.

Lemma pubSrcContra: forall mu b1,
         pubBlocksSrc mu b1 = false -> pub_of mu b1 = None.

Lemma pubTgtContra: forall mu (WD: SM_wd mu) b2, pubBlocksTgt mu b2 = false ->
            ~ exists b1 d, pub_of mu b1 = Some(b2,d).

Lemma disjoint_extern_local: forall mu (WD: SM_wd mu),
     disjoint (extern_of mu) (local_of mu).

Lemma disjoint_foreign_pub: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (pub_of mu).

Lemma pub_in_shared: forall mu (WD: SM_wd mu),
      inject_incr (pub_of mu) (shared_of mu).

Definition DomSrc (mu: SM_Injection) (b1: block): bool :=
     locBlocksSrc mu b1 || extBlocksSrc mu b1.
Definition DOM (mu: SM_Injection) (b1: block): Prop := DomSrc mu b1 = true.

Definition DomTgt (mu: SM_Injection) (b2: block): bool :=
     locBlocksTgt mu b2 || extBlocksTgt mu b2.
Definition RNG (mu: SM_Injection) (b2:block): Prop := DomTgt mu b2 = true.

Definition intern_incr (mu mu': SM_Injection): Prop :=
   inject_incr (local_of mu) (local_of mu') /\
   (extern_of mu = extern_of mu') /\
   (forall b, locBlocksSrc mu b = true -> locBlocksSrc mu' b = true) /\
   (forall b, locBlocksTgt mu b = true -> locBlocksTgt mu' b = true) /\
   (pubBlocksSrc mu = pubBlocksSrc mu') /\
   (pubBlocksTgt mu = pubBlocksTgt mu') /\
   (frgnBlocksSrc mu = frgnBlocksSrc mu') /\
   (frgnBlocksTgt mu = frgnBlocksTgt mu') /\
   (extBlocksSrc mu = extBlocksSrc mu') /\
   (extBlocksTgt mu = extBlocksTgt mu').

Lemma intern_incr_DomSrc:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DomSrc mu b = true -> DomSrc mu' b = true.
Lemma intern_incr_DOM:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DOM mu b -> DOM mu' b.

Lemma intern_incr_DomTgt:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DomTgt mu b = true -> DomTgt mu' b = true.

Lemma intern_incr_RNG:
      forall mu mu' (Inc: intern_incr mu mu') b,
      RNG mu b -> RNG mu' b.

Lemma intern_incr_DomSrc_inv: forall mu mu' (INC: intern_incr mu mu') b,
      DomSrc mu' b = false -> DomSrc mu b = false.

Lemma intern_incr_DomTgt_inv: forall mu mu' (INC: intern_incr mu mu') b,
      DomTgt mu' b = false -> DomTgt mu b = false.

Lemma intern_incr_locBlocksSrc_inv: forall mu mu' (INC: intern_incr mu mu') b,
      locBlocksSrc mu' b = false -> locBlocksSrc mu b = false.

Lemma intern_incr_locBlocksTgt_inv: forall mu mu' (INC: intern_incr mu mu') b,
      locBlocksTgt mu' b = false -> locBlocksTgt mu b = false.

Lemma intern_incr_priv: forall mu mu' (INC: intern_incr mu mu'),
      inject_incr (priv_of mu) (priv_of mu').

Lemma intern_incr_pub: forall mu mu' (INC: intern_incr mu mu')
       (WD: SM_wd mu), pub_of mu = pub_of mu'.

Lemma intern_incr_foreign: forall mu mu' (INC: intern_incr mu mu'),
      foreign_of mu = foreign_of mu'.

Lemma intern_incr_unknown: forall mu mu' (INC: intern_incr mu mu')
       (WD': SM_wd mu'), unknown_of mu = unknown_of mu'.

Definition extern_incr (mu mu': SM_Injection): Prop :=
   inject_incr (extern_of mu) (extern_of mu') /\
   (local_of mu = local_of mu') /\
   (forall b, extBlocksSrc mu b = true -> extBlocksSrc mu' b = true) /\
   (forall b, extBlocksTgt mu b = true -> extBlocksTgt mu' b = true) /\
   (locBlocksSrc mu = locBlocksSrc mu') /\
   (locBlocksTgt mu = locBlocksTgt mu') /\
   (pubBlocksSrc mu = pubBlocksSrc mu') /\
   (pubBlocksTgt mu = pubBlocksTgt mu') /\
   (frgnBlocksSrc mu = frgnBlocksSrc mu') /\
   (frgnBlocksTgt mu = frgnBlocksTgt mu').

Lemma extern_incr_DomSrc:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DomSrc mu b = true -> DomSrc mu' b = true.
Lemma extern_incr_DOM:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DOM mu b -> DOM mu' b.

Lemma extern_incr_DomTgt:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DomTgt mu b = true -> DomTgt mu' b = true.

Lemma extern_incr_RNG:
      forall mu mu' (Inc: extern_incr mu mu') b,
      RNG mu b -> RNG mu' b.

Lemma extern_incr_unknown: forall mu mu' (INC: extern_incr mu mu'),
   inject_incr (unknown_of mu) (unknown_of mu').

Lemma extern_incr_frgnBlocksSrc: forall
          mu nu (INC: extern_incr mu nu),
       frgnBlocksSrc mu = frgnBlocksSrc nu.

Lemma extern_incr_frgnBlocksTgt: forall
          mu nu (INC: extern_incr mu nu),
       frgnBlocksTgt mu = frgnBlocksTgt nu.

Lemma extern_incr_foreign_inc: forall mu mu' (INC: extern_incr mu mu'),
   inject_incr (foreign_of mu) (foreign_of mu').

Lemma extern_incr_foreign: forall mu mu' (INC: extern_incr mu mu') (WDmu: SM_wd mu),
   foreign_of mu = foreign_of mu'.

Lemma extern_incr_pub: forall mu mu' (INC: extern_incr mu mu'),
   pub_of mu = pub_of mu'.

Lemma extern_incr_priv: forall mu mu' (INC: extern_incr mu mu'),
   priv_of mu = priv_of mu'.

Definition as_inj (mu: SM_Injection) : meminj :=
  join (extern_of mu) (local_of mu).

Lemma local_in_all: forall j (PR:SM_wd j), inject_incr (local_of j) (as_inj j).

Lemma pub_in_all: forall j (PR:SM_wd j), inject_incr (pub_of j) (as_inj j).

Lemma priv_in_all: forall j (PR:SM_wd j), inject_incr (priv_of j) (as_inj j).

Lemma extern_in_all: forall mu, inject_incr (extern_of mu) (as_inj mu).

Lemma foreign_in_all: forall mu, inject_incr (foreign_of mu) (as_inj mu).

Lemma unknown_in_all: forall mu, inject_incr (unknown_of mu) (as_inj mu).

Lemma shared_in_all: forall j (PR:SM_wd j), inject_incr (shared_of j) (as_inj j).

Lemma as_injD_None: forall mu b1, as_inj mu b1 = None ->
   extern_of mu b1 = None /\
   local_of mu b1 = None.

Lemma local_ofD_None: forall mu b1, local_of mu b1 = None ->
   pub_of mu b1 = None /\
   priv_of mu b1 = None.

Lemma extern_ofD_None: forall mu b1, extern_of mu b1 = None ->
   foreign_of mu b1 = None /\
   unknown_of mu b1 = None.

Lemma disjoint_foreign_priv: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (priv_of mu).

Lemma disjoint_foreign_local: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (local_of mu).

Lemma disjoint_unknown_local: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (local_of mu).

Lemma disjoint_unknown_pub: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (pub_of mu).

Lemma disjoint_unknown_priv: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (priv_of mu).

Lemma disjoint_shared_priv: forall mu (WD: SM_wd mu),
      disjoint (shared_of mu) (priv_of mu).

Lemma disjoint_shared_unknown: forall mu (WD: SM_wd mu),
      disjoint (shared_of mu) (unknown_of mu).

Lemma as_inj_DomRng: forall mu b1 b2 d, as_inj mu b1 = Some(b2, d) -> SM_wd mu ->
                DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma local_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: local_of mu b1 = Some(b2,z)),
      locBlocksSrc mu b1  = true /\ locBlocksTgt mu b2  = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma pub_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: pub_of mu b1 = Some(b2,z)),
      pubBlocksSrc mu b1 = true /\ pubBlocksTgt mu b2 = true /\
      locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma priv_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: priv_of mu b1 = Some(b2,z)),
      pubBlocksSrc mu b1 = false /\
      locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma extern_DomRng': forall mu (WD:SM_wd mu) b1 b2 d
                      (L:extern_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma foreign_DomRng: forall mu (WD:SM_wd mu) b1 b2 d
                      (L:foreign_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = true /\ frgnBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma unknown_DomRng: forall mu (WD:SM_wd mu) b1 b2 d
                      (L: unknown_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      frgnBlocksSrc mu b1 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Definition locvisible_of mu := join (foreign_of mu) (local_of mu) .
Definition extvisible_of mu := join (extern_of mu) (pub_of mu).

Lemma locvisible_sharedprivate: forall mu,
      locvisible_of mu = join (shared_of mu) (priv_of mu).

Lemma shared_in_locvisible: forall mu,
      inject_incr (shared_of mu) (locvisible_of mu).

Lemma local_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (local_of mu) (locvisible_of mu).

Lemma private_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (priv_of mu) (locvisible_of mu).

Lemma pub_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (pub_of mu) (locvisible_of mu).

Lemma extvisible_sharedunknown: forall mu (WD: SM_wd mu),
      extvisible_of mu = join (shared_of mu) (unknown_of mu).

Lemma shared_in_extvisible: forall mu( WD: SM_wd mu),
      inject_incr (shared_of mu) (extvisible_of mu).

Lemma unknown_in_extvisible: forall mu (WD: SM_wd mu),
      inject_incr (unknown_of mu) (extvisible_of mu).

Definition sm_inject_separated (mu mu' : SM_Injection) (m1 m2:mem):Prop :=
  (forall b1 b2 d, as_inj mu b1 = None -> as_inj mu' b1 = Some(b2,d) ->
                   (DomSrc mu b1 = false /\ DomTgt mu b2 = false)) /\
  (forall b1, DomSrc mu b1 = false -> DomSrc mu' b1 = true -> ~Mem.valid_block m1 b1) /\
  (forall b2, DomTgt mu b2 = false -> DomTgt mu' b2 = true -> ~Mem.valid_block m2 b2).

Lemma sm_inject_separated_mem: forall mu mu' m1 m2
        (SEP: sm_inject_separated mu mu' m1 m2) (WD': SM_wd mu'),
      inject_separated (as_inj mu) (as_inj mu') m1 m2.

Lemma sm_inject_separated_asinj_same: forall mu nu m1 m2
         (SEP: sm_inject_separated mu nu m1 m2)
          nu' (Hnu: as_inj nu = as_inj nu')
          (HSrc: DomSrc nu = DomSrc nu')
          (HTgt: DomTgt nu = DomTgt nu'),
      sm_inject_separated mu nu' m1 m2.

Definition freshloc m m' b := andb (valid_block_dec m' b) (negb (valid_block_dec m b)).
Lemma freshloc_charT: forall m m' b,
      (freshloc m m' b = true) <-> (Mem.valid_block m' b /\ ~Mem.valid_block m b).
Lemma freshloc_charF: forall m m' b,
      (freshloc m m' b = false) <-> (Mem.valid_block m b \/ ~Mem.valid_block m' b).
Lemma freshloc_irrefl: forall m b, freshloc m m b = false.
Lemma freshloc_trans: forall m m'' m' b
     (FWD: mem_forward m m'') (FWD': mem_forward m'' m'),
     (orb (freshloc m m'' b) (freshloc m'' m' b)) = freshloc m m' b.

Definition sm_locally_allocated (mu mu' : SM_Injection) (m1 m2 m1' m2':mem):Prop :=
  match mu, mu' with
     Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern,
     Build_SM_Injection locBSrc' locBTgt' pSrc' pTgt' local' extBSrc' extBTgt' fSrc' fTgt' extern'
  =>    locBSrc' = (fun b => orb (locBSrc b) (freshloc m1 m1' b))
     /\ locBTgt' = (fun b => orb (locBTgt b) (freshloc m2 m2' b))
     /\ extBSrc' = extBSrc
     /\ extBTgt' = extBTgt
  end.

Lemma sm_locally_allocatedChar: forall mu mu' m1 m2 m1' m2',
  sm_locally_allocated mu mu' m1 m2 m1' m2' <->
  (    DomSrc mu' = (fun b => orb (DomSrc mu b) (freshloc m1 m1' b))
    /\ DomTgt mu' = (fun b => orb (DomTgt mu b) (freshloc m2 m2' b))
    /\ locBlocksSrc mu' = (fun b => orb (locBlocksSrc mu b) (freshloc m1 m1' b))
    /\ locBlocksTgt mu' = (fun b => orb (locBlocksTgt mu b) (freshloc m2 m2' b))
    /\ extBlocksSrc mu' = extBlocksSrc mu
    /\ extBlocksTgt mu' = extBlocksTgt mu).

Lemma sm_inject_separated_intern_MYB: forall mu mu' m1 m2 m1' m2'
        (SEP: sm_inject_separated mu mu' m1 m2)
        (LAL: sm_locally_allocated mu mu' m1 m2 m1' m2'),
      (forall b, locBlocksSrc mu b = false -> locBlocksSrc mu' b = true -> ~ Mem.valid_block m1 b) /\

Definition sm_valid (mu : SM_Injection) (m1 m2: mem) :=
       (forall b1, DOM mu b1 -> Mem.valid_block m1 b1)
    /\ (forall b2, RNG mu b2 -> Mem.valid_block m2 b2).

Lemma intern_incr_refl: forall mu, intern_incr mu mu.

Definition smvalid_src (mu : SM_Injection) m1 :=
  forall b1, DOM mu b1 -> Memory.Mem.valid_block m1 b1.

Lemma sm_valid_smvalid_src mu m1 m2 :
  sm_valid mu m1 m2 -> smvalid_src mu m1.

Lemma extern_incr_refl: forall mu, extern_incr mu mu.

Lemma intern_incr_local: forall mu mu' (INC: intern_incr mu mu'),
      inject_incr (local_of mu) (local_of mu').

Lemma intern_incr_extern: forall mu mu' (INC: intern_incr mu mu'),
      extern_of mu = extern_of mu'.

Lemma extern_incr_extern: forall mu mu' (INC: extern_incr mu mu'),
      inject_incr (extern_of mu) (extern_of mu').

Lemma extern_incr_local: forall mu mu' (INC: extern_incr mu mu'),
      local_of mu = local_of mu'.

Lemma intern_incr_trans: forall mu mu' mu''
      (Inc: intern_incr mu mu') (Inc': intern_incr mu' mu''),
      intern_incr mu mu''.

Lemma extern_incr_trans: forall mu mu' mu''
      (Inc: extern_incr mu mu') (Inc': extern_incr mu' mu''),
      extern_incr mu mu''.

Lemma sm_inject_separated_same_sminj: forall mu m m',
   sm_inject_separated mu mu m m'.

Lemma intern_incr_as_inj: forall mu mu'
      (INC: intern_incr mu mu') (WD': SM_wd mu'),
      inject_incr (as_inj mu) (as_inj mu').

Lemma extern_incr_as_inj: forall mu mu'
     (INC: extern_incr mu mu') (WD': SM_wd mu'),
     inject_incr (as_inj mu) (as_inj mu').

Lemma inject_separated_intern_incr_fwd:
  forall mu mu' m1 m2 mu'' m2'
  (SEP: sm_inject_separated mu mu' m1 m2)
  (SEP': sm_inject_separated mu' mu'' m1 m2')
  (INC: intern_incr mu mu') (INC': intern_incr mu' mu'')
  (FWD: mem_forward m2 m2')
  (WD': SM_wd mu') (WD'': SM_wd mu''),
  sm_inject_separated mu mu'' m1 m2.

Lemma intern_separated_incr_fwd2:
  forall mu0 mu mu' m10 m20 m1 m2,
  intern_incr mu mu' ->
  sm_inject_separated mu mu' m1 m2 ->
  intern_incr mu0 mu ->
  mem_forward m10 m1 ->
  sm_inject_separated mu0 mu m10 m20 ->
  mem_forward m20 m2 ->
  SM_wd mu' ->
  sm_inject_separated mu0 mu' m10 m20.

Lemma sm_locally_allocated_trans: forall mu mu' mu'' m2 m3 m2' m3' m2'' m3''
(LocAlloc23 : sm_locally_allocated mu mu' m2 m3 m2'' m3')
(LocAlloc23' : sm_locally_allocated mu' mu'' m2'' m3' m2' m3'')
(Fwd2 : mem_forward m2 m2'')
(Fwd2' : mem_forward m2'' m2')
(Fwd3 : mem_forward m3 m3')
(Fwd3' : mem_forward m3' m3''),
sm_locally_allocated mu mu'' m2 m3 m2' m3''.

Definition sharedSrc mu b :=
    match shared_of mu b
    with Some _ => true | None => false
    end.

Lemma sharedSrc_iff: forall mu b, sharedSrc mu b = true <->
                     exists b2 d, shared_of mu b = Some(b2,d).

Lemma pubSrc_shared: forall mu (WD: SM_wd mu) b,
                     pubBlocksSrc mu b = true ->
                     sharedSrc mu b = true.

Lemma frgnSrc_shared: forall mu (WD: SM_wd mu) b,
                     frgnBlocksSrc mu b = true ->
                     sharedSrc mu b = true.

Lemma sharedSrc_iff_frgnpub: forall mu (WD: SM_wd mu),
      sharedSrc mu = fun b => orb (frgnBlocksSrc mu b) (pubBlocksSrc mu b).

Definition sharedTgt mu b := orb (frgnBlocksTgt mu b) (pubBlocksTgt mu b).

Lemma shared_SrcTgt: forall mu (WD: SM_wd mu) b
                    (SH: sharedSrc mu b = true),
      exists jb d, shared_of mu b = Some (jb, d) /\ sharedTgt mu jb = true.

Definition initial_SM (extS extT frgnS frgnT: block->bool)
                     (extern:meminj): SM_Injection :=
  Build_SM_Injection
       (fun b => false) (fun b => false)
      (fun b => false) (fun b => false)
      (fun b => None)
       extS extT
       frgnS frgnT
      extern.

Lemma initial_SM_wd: forall extS extT frgnS frgnT extern
                       (EXT: forall b1 b2 d, extern b1 =Some(b2,d) ->
                            extS b1 = true /\ extT b2 = true)
                       (F: forall b1, frgnS b1 = true ->
                           exists b2 z, extern b1 = Some (b2, z) /\ frgnT b2 = true)
                       (FS: forall b, frgnS b = true -> extS b = true)
                       (FT: forall b, frgnT b = true -> extT b = true),
                       SM_wd (initial_SM extS extT frgnS frgnT extern).

Lemma initial_SM_as_inj: forall extS extT frgnS frgnT j,
      as_inj (initial_SM extS extT frgnS frgnT j) = j.

Definition restrict (j: meminj) (X:block -> bool) : meminj :=
  fun b => if X b then j b else None.

Lemma restrictD_Some: forall j X b1 b2 d (R:restrict j X b1 = Some(b2,d)),
                      j b1 = Some(b2,d) /\ X b1 = true.
Lemma restrictI_Some: forall j X b b2 d (J:j b = Some(b2,d))
                            (Hb: X b = true),
                      restrict j X b = Some(b2,d).
Lemma restrictD_None: forall j X b1 b2 d (R:restrict j X b1 = None)
                      (J: j b1 = Some(b2,d)), X b1 = false.
Lemma restrictD_None': forall j X b1 (R:restrict j X b1 = None),
                         j b1 = None \/
                        (exists b2 d, j b1 =Some(b2,d) /\ X b1 = false).
Lemma restrictI_None: forall j X b (Hb: j b = None \/ X b = false),
                      restrict j X b = None.

Lemma join_restrict: forall j k X,
      join (restrict j X) (restrict k X) = restrict (join j k) X.

Lemma restrict_outside: forall j X
        (HX: forall b1 b2 d, j b1 = Some(b2, d) -> X b1 = true),
      restrict j X = j.

Lemma restrict_incr: forall j X, inject_incr (restrict j X) j.

Lemma restrict_com: forall j X Y,
      restrict (restrict j X) Y = restrict (restrict j Y) X.

Lemma restrict_nest: forall j X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict (restrict j X) Y = restrict j Y.
Lemma restrict_nest': forall j X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict (restrict j Y) X = restrict j Y.

Lemma val_inject_restrictD: forall j v v' X
       (V: val_inject (restrict j X) v v'),
     val_inject j v v'.

Lemma forall_vals_inject_restrictD: forall j vals1 vals2 X
     (Inj : Forall2 (val_inject (restrict j X)) vals1 vals2),
 Forall2 (val_inject j) vals1 vals2.

Definition reestablish (mu0 mu: SM_Injection): SM_Injection :=
  match mu0, mu with
    Build_SM_Injection locBSrc0 locBTgt0 pSrc0 pTgt0 local0
                       extBSrc0 extBTgt0 fSrc0 fTgt0 extern0,
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local
                       extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc0 locBTgt0 pSrc0 pTgt0 local0
                       (fun b => if locBSrc0 b then false else locBSrc b || extBSrc b)
                       (fun b => if locBTgt0 b then false else locBTgt b || extBTgt b)
                       fSrc0 fTgt0 
                       (fun b => if locBSrc0 b then None else join extern local b)
  end.

Lemma reestablish_DomSrc: forall mu0 mu
      (D: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true),
      DomSrc (reestablish mu0 mu) = DomSrc mu.

Lemma reestablish_DomTgt: forall mu0 mu
      (D: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true),
      DomTgt (reestablish mu0 mu) = DomTgt mu.

Lemma reestablish_wd: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (SEP: forall b1 b2 d, as_inj mu0 b1 = None -> as_inj mu b1 = Some(b2,d) ->
                                (DomSrc mu0 b1 = false /\ DomTgt mu0 b2 = false))
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      SM_wd (reestablish mu0 mu).

Lemma reestablish_wd': forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
                      (INC: inject_incr (as_inj mu0) (as_inj mu))
                      (Hmu: forall b1 b2 z (A:as_inj mu b1 = Some(b2,z)),
                            locBlocksSrc mu0 b1 = locBlocksTgt mu0 b2 /\
                            extBlocksSrc mu0 b1 = extBlocksTgt mu0 b2)
                      (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
                      SM_wd (reestablish mu0 mu).

Lemma reestablish_extern_incr': forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (INC: inject_incr (as_inj mu0) (as_inj mu))
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      extern_incr mu0 (reestablish mu0 mu).

Lemma reestablish_extern_incr: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      extern_incr mu0 (reestablish mu0 mu).

Lemma reestablish_internstep': forall mu0 mu mu' (WD0:SM_wd mu0) (WD:SM_wd mu) (WD:SM_wd mu')
          (INC: inject_incr (as_inj mu0) (as_inj mu))
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true)
          (II: intern_incr mu mu'),
      extern_incr mu0 (reestablish mu0 mu').

Lemma reestablish_internstep: forall mu0 mu mu' (WD0:SM_wd mu0) (WD:SM_wd mu) (WD:SM_wd mu')
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true)
          (II: intern_incr mu mu'),
      extern_incr mu0 (reestablish mu0 mu').

Lemma reestablish_as_inj: forall mu0 mu (WD0:SM_wd mu0)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0),
      as_inj (reestablish mu0 mu) = as_inj mu.

Lemma reestablish_as_inj': forall mu0 mu (WD0:SM_wd mu0)
           (HINC: inject_incr (as_inj mu0) (as_inj mu))
           (H: forall b, locBlocksSrc mu0 b = true -> local_of mu0 b = None ->
                         as_inj mu b = None),
      as_inj (reestablish mu0 mu) = as_inj mu.

Lemma reestablish_sm_injsep: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (LocSrc: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (LocTgt: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true)
          m1 m2 (SEP: sm_inject_separated mu0 mu m1 m2),
      sm_inject_separated mu0 (reestablish mu0 mu) m1 m2.

Lemma reestablish_sm_valid: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (LocSrc: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (DomTgt: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true)
          m1 m2 (VAL: sm_valid mu m1 m2),
      sm_valid (reestablish mu0 mu) m1 m2. *)

Require Import effect_simulations.
(* effect_simulations:
Require Import compcert.common.Events.
Require Import compcert.common.Memory.
Require Import compcert.lib.Coqlib.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.AST.

Require Import compcert.common.Globalenvs.

Require Import compcert.lib.Axioms.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Definition vis mu := fun b => locBlocksSrc mu b || frgnBlocksSrc mu b.

Inductive reach (m:mem) (B:block -> Prop): list (block * Z) -> block -> Prop :=
  reach_nil: forall b, B b -> reach m B nil b
| reach_cons: forall b L b' z off n,
                     reach m B L b' ->
                     Mem.perm m b' z Cur Readable ->
                     ZMap.get z (PMap.get b' (Mem.mem_contents m)) =
                        Pointer b off n ->
              reach m B ((b',z)::L) b.

Fixpoint reach' (m:mem) (B:block -> Prop) (L:list (block * Z)): block -> Prop:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => bb = b /\
                                               Mem.perm m b' z Cur Readable /\
                                               reach' m B L b'
                           | _ => fun bb => False
                       end
            end
  end.

Lemma reach_reach': forall m B L b1, reach m B L b1 <-> reach' m B L b1.

Fixpoint reach'' (m:mem) (B:block -> bool) (L:list (block * Z)): block -> bool:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => eq_block bb b &&
                                               Mem.perm_dec m b' z Cur Readable  &&
                                               reach'' m B L b'
                           | _ => fun bb => false
                       end
            end
  end.

Lemma reach_reach'' m B L b1 :
  reach m (fun b => B b=true) L b1 <-> reach'' m B L b1=true.

Lemma reach_inject: forall m1 m2 j (J: Mem.inject j m1 m2)

Lemma reach_mono: forall B1 B2 (HB : forall b, B1 b = true -> B2 b = true)
                         m b L1 (R : reach m (fun bb : block => B1 bb = true) L1 b),
                  exists L, reach m (fun bb : block => B2 bb = true) L b.

Parameter REACH : mem -> (block -> bool) -> block -> bool.
Axiom REACHAX : 
  forall m B b, REACH m B b = true
  <-> exists L, reach m (fun bb => B bb = true) L b.

Lemma REACH_nil: forall m B b, B b = true -> REACH m B b = true.

Lemma REACH_cons: forall m B b b' z off n,
                     REACH m B b' = true ->
                     Mem.perm m b' z Cur Readable ->

Lemma REACH_inject: forall m1 m2 j (J: Mem.inject j m1 m2) B1 B2

Lemma REACH_mono: forall B1 B2 (HB: forall b, B1 b = true -> B2 b = true) m b
                  (R: REACH m B1 b = true), REACH m B2 b = true.

Definition replace_locals (mu:SM_Injection) pSrc' pTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc' pTgt' local extBSrc extBTgt fSrc fTgt extern
  end.

Lemma replace_locals_wd: forall mu (WD: SM_wd mu) pSrc' pTgt'
         (SRC: forall b1, pSrc' b1 = true ->
               exists b2 d, local_of mu b1 = Some(b2,d) /\ pTgt' b2=true)
         (TGT: forall b, pTgt' b = true -> locBlocksTgt mu b = true),
      SM_wd (replace_locals mu pSrc' pTgt').

Lemma replace_locals_extern: forall mu pubSrc' pubTgt',
      extern_of (replace_locals mu pubSrc' pubTgt') = extern_of mu.

Lemma replace_locals_local: forall mu pubSrc' pubTgt',
      local_of (replace_locals mu pubSrc' pubTgt') = local_of mu.

Lemma replace_locals_unknown: forall mu pubSrc' pubTgt',
      unknown_of (replace_locals mu pubSrc' pubTgt') = unknown_of mu.

Lemma replace_locals_foreign: forall mu pubSrc' pubTgt',
      foreign_of (replace_locals mu pubSrc' pubTgt') = foreign_of mu.

Lemma replace_locals_pub: forall mu pubSrc' pubTgt',
      pub_of (replace_locals mu pubSrc' pubTgt') =
          (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_pub': forall mu pubSrc' pubTgt'
      (P: forall b, pubBlocksSrc mu b = true -> pubSrc' b = true)
      b (B: pubBlocksSrc mu b = true),
      pub_of (replace_locals mu pubSrc' pubTgt') b = pub_of mu b.

Lemma replace_locals_as_inj: forall mu pubSrc' pubTgt',
      as_inj (replace_locals mu pubSrc' pubTgt') = as_inj mu.

Lemma replace_locals_shared: forall mu pubSrc' pubTgt',
      shared_of (replace_locals mu pubSrc' pubTgt') =
      join (foreign_of mu) (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_DOM: forall mu pubSrc' pubTgt',
      DOM (replace_locals mu pubSrc' pubTgt') = DOM mu.

Lemma replace_locals_RNG: forall mu pubSrc' pubTgt',
      RNG (replace_locals mu pubSrc' pubTgt') = RNG mu.

Lemma replace_locals_DomSrc: forall mu pubSrc' pubTgt',
      DomSrc (replace_locals mu pubSrc' pubTgt') = DomSrc mu.

Lemma replace_locals_DomTgt: forall mu pubSrc' pubTgt',
      DomTgt (replace_locals mu pubSrc' pubTgt') = DomTgt mu.

Lemma replace_locals_locBlocksSrc: forall mu pubSrc' pubTgt',
      locBlocksSrc (replace_locals mu pubSrc' pubTgt') = locBlocksSrc mu.

Lemma replace_locals_extBlocksTgt: forall mu pubSrc' pubTgt',
      extBlocksTgt (replace_locals mu pubSrc' pubTgt') = extBlocksTgt mu.

Lemma replace_locals_extBlocksSrc: forall mu pubSrc' pubTgt',
      extBlocksSrc (replace_locals mu pubSrc' pubTgt') = extBlocksSrc mu.

Lemma replace_locals_locBlocksTgt: forall mu pubSrc' pubTgt',
      locBlocksTgt (replace_locals mu pubSrc' pubTgt') = locBlocksTgt mu.

Lemma replace_locals_frgnBlocksSrc: forall mu pubSrc' pubTgt',
      frgnBlocksSrc (replace_locals mu pubSrc' pubTgt') = frgnBlocksSrc mu.

Lemma replace_locals_frgnBlocksTgt: forall mu pubSrc' pubTgt',
      frgnBlocksTgt (replace_locals mu pubSrc' pubTgt') = frgnBlocksTgt mu.

Lemma replace_locals_pubBlocksSrc: forall mu pubSrc' pubTgt',
      pubBlocksSrc (replace_locals mu pubSrc' pubTgt') = pubSrc'.

Lemma replace_locals_pubBlocksTgt: forall mu pubSrc' pubTgt',
      pubBlocksTgt (replace_locals mu pubSrc' pubTgt') = pubTgt'.

Definition replace_externs (mu:SM_Injection) fSrc' fTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc' fTgt' extern
  end.

Lemma replace_externs_wd: forall mu (WD: SM_wd mu) fSrc' fTgt'
         (SRC: forall b1, fSrc' b1 = true ->
               exists b2 d, extern_of mu b1 = Some(b2,d) /\ fTgt' b2=true)
         (TGT: forall b, fTgt' b = true -> extBlocksTgt mu b = true),
      SM_wd (replace_externs mu fSrc' fTgt').

Lemma replace_externs_extern: forall mu frgSrc' frgTgt',
      extern_of (replace_externs mu frgSrc' frgTgt') = extern_of mu.

Lemma replace_externs_foreign: forall mu frgSrc' frgTgt',
      foreign_of (replace_externs mu frgSrc' frgTgt') =
      fun b : block => if frgSrc' b then extern_of mu b else None.

Lemma replace_externs_local: forall mu frgSrc' frgTgt',
      local_of (replace_externs mu frgSrc' frgTgt') = local_of mu.

Lemma replace_externs_priv: forall mu frgSrc' frgTgt',
      priv_of (replace_externs mu frgSrc' frgTgt') = priv_of mu.

Lemma replace_externs_pub: forall mu frgSrc' frgTgt',
      pub_of (replace_externs mu frgSrc' frgTgt') = pub_of mu.

Lemma replace_externs_as_inj: forall mu frgSrc' frgTgt',
      as_inj (replace_externs mu frgSrc' frgTgt') = as_inj mu.

Lemma replace_externs_DOM: forall mu frgSrc' frgTgt',
      DOM (replace_externs mu frgSrc' frgTgt') = DOM mu.

Lemma replace_externs_RNG: forall mu frgSrc' frgTgt',
      RNG (replace_externs mu frgSrc' frgTgt') = RNG mu.

Lemma replace_externs_DomSrc: forall mu frgSrc' frgTgt',
      DomSrc (replace_externs mu frgSrc' frgTgt') = DomSrc mu.

Lemma replace_externs_DomTgt: forall mu frgSrc' frgTgt',
      DomTgt (replace_externs mu frgSrc' frgTgt') = DomTgt mu.

Lemma replace_externs_locBlocksSrc: forall mu frgSrc' frgTgt',
      locBlocksSrc (replace_externs mu frgSrc' frgTgt') = locBlocksSrc mu.

Lemma replace_externs_locBlocksTgt: forall mu frgSrc' frgTgt',
      locBlocksTgt (replace_externs mu frgSrc' frgTgt') = locBlocksTgt mu.

Lemma replace_externs_extBlocksSrc: forall mu frgSrc' frgTgt',
      extBlocksSrc (replace_externs mu frgSrc' frgTgt') = extBlocksSrc mu.

Lemma replace_externs_extBlocksTgt: forall mu frgSrc' frgTgt',
      extBlocksTgt (replace_externs mu frgSrc' frgTgt') = extBlocksTgt mu.

Lemma replace_externs_frgnBlocksSrc: forall mu fSrc' fTgt',
      frgnBlocksSrc (replace_externs mu fSrc' fTgt') = fSrc'.

Lemma replace_externs_frgnBlocksTgt: forall mu fSrc' fTgt',
      frgnBlocksTgt (replace_externs mu fSrc' fTgt') = fTgt'.

Lemma replace_externs_pubBlocksSrc: forall mu frgSrc' frgTgt',
      pubBlocksSrc (replace_externs mu frgSrc' frgTgt') = pubBlocksSrc mu.

Lemma replace_externs_pubBlocksTgt: forall mu frgSrc' frgTgt',
      pubBlocksTgt (replace_externs mu frgSrc' frgTgt') = pubBlocksTgt mu.

Definition getBlocks (V:list val) (b: block): bool :=
   in_dec eq_block b
    (fold_right (fun v L => match v with Vptr b' z => b'::L | _ => L end) nil V).

Lemma getBlocksD: forall v V b,
  getBlocks (v:: V) b =
    match v with
      Vptr b' _  => orb (eq_block b' b) (getBlocks V b)
    | _ => getBlocks V b
   end.

Lemma getBlocksD_nil: forall b,
  getBlocks nil b = false.

Lemma getBlocks_char: forall V b, getBlocks V b = true <->
   exists off, In (Vptr b off) V.

Lemma getBlocks_inject: forall j vals1 vals2
                       (ValInjMu : Forall2 (val_inject j) vals1 vals2)
                       b (B: getBlocks vals1 b = true),
      exists jb d, j b = Some (jb, d) /\ getBlocks vals2 jb = true.

Definition REACH_closed m (X: Values.block -> bool) : Prop :=
  (forall b, REACH m X b = true -> X b = true).

Definition mapped (j:meminj) b : bool :=
  match j b with None => false | Some _ => true end.

Lemma mappedD_true : forall j b (M: mapped j b = true),
                     exists p, j b = Some p.
Lemma mappedD_false : forall j b (M: mapped j b = false),
                      j b = None.
Lemma mappedI_true : forall j b p (J: j b = Some p),
                      mapped j b = true.
Lemma mappedI_false : forall j b (J:j b = None),
                       mapped j b = false.
Lemma mapped_charT: forall j b, (mapped j b = true) <-> (exists p, j b = Some p).
Lemma mapped_charF: forall j b, (mapped j b = false) <-> (j b = None).

Lemma inject_mapped: forall j m1 m2 (Inj12: Mem.inject j m1 m2) k

Lemma restrict_val_inject: forall j val1 val2
     (Inj : val_inject j val1 val2)
     X (HR: forall b, getBlocks (val1::nil) b = true -> X b = true),
   val_inject (restrict j X) val1 val2.

Lemma restrict_forall_vals_inject: forall j vals1 vals2
     (Inj : Forall2 (val_inject j) vals1 vals2)
     X (HR: forall b, getBlocks vals1 b = true -> X b = true),
 Forall2 (val_inject (restrict j X)) vals1 vals2.

Lemma restrict_mapped_closed: forall j m X
      (RC: REACH_closed m (mapped j))
      (RX: REACH_closed m X),
      REACH_closed m (mapped (restrict j X)).

Lemma restrict_mapped_closed_triv: forall j m X,
      REACH_closed m (fun b => mapped j b && X b) =
      REACH_closed m (mapped (restrict j X)).

Lemma REACH_closed_intersection: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b && Y b).

Lemma REACH_closed_union: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b || Y b).

Lemma inject_REACH_closed: forall j m1 m2 (Inj: Mem.inject j m1 m2),

Lemma inject_restrict: forall j m1 m2 X
        (INJ : Mem.inject j m1 m2)

Definition exportedSrc mu vals b := orb (getBlocks vals b) (sharedSrc mu b).
Definition exportedTgt mu vals b := orb (getBlocks vals b) (sharedTgt mu b).

Lemma exported_inject: forall mu (WD: SM_wd mu) vals1 vals2
          (ValInjMu : Forall2 (val_inject (as_inj mu)) vals1 vals2) b
          (SRC: exportedSrc mu vals1 b = true ),
        exists jb d, as_inj mu b = Some (jb, d)
                  /\ exportedTgt mu vals2 jb = true.

Lemma REACH_shared_of: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (shared_of mu) m1 m2)

Lemma REACH_as_inj: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_as_inj_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH': forall mu m1 vals1  b1
        (R : REACH m1 (exportedSrc mu vals1) b1 = true)
        (WD: SM_wd mu) m2 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Goal forall m1 mu (WD: SM_wd mu) vals b, pubBlocksSrc mu b = true ->
           REACH m1 (exportedSrc mu vals) b = true.

Definition local_out_of_reach mu (m : mem) (b : block) (ofs : Z): Prop :=
  locBlocksTgt mu b = true /\
  forall b0 delta, local_of mu b0 = Some (b, delta) ->
                  (~ Mem.perm m b0 (ofs - delta) Max Nonempty \/
                   pubBlocksSrc mu b0 = false).

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Lemma genvs_domain_eq_match_genvsB: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genv2blocksBool_char1: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char1': forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2': forall F V (ge : Genv.t F V) b,

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma restrict_preserves_globals: forall {F V} (ge:Genv.t F V) j X

Lemma genvs_domain_eq_isGlobal: forall {F1 V1 F2 V2} ge1 ge2
                       (DomainEQ: @genvs_domain_eq F1 V1 F2 V2 ge1 ge2),
       isGlobalBlock ge1 = isGlobalBlock ge2.

Lemma meminj_preserves_globals_isGlobalBlock: forall {F V} (g: Genv.t F V)

Lemma meminj_preserves_globals_initSM: forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma meminj_preserves_globals_init_REACH_frgn:
      forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma REACH_is_closed: forall R m1,
  REACH_closed m1 (fun b : block => REACH m1 R b).

Lemma core_initial_wd : forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma intern_incr_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu

Lemma replace_externs_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) nu

Lemma after_external_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu (WDmu : SM_wd mu)

Definition restrict_sm mu (X:block -> bool) :=
match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection locBSrc locBTgt pSrc pTgt (restrict local X)
                     extBSrc extBTgt fSrc fTgt (restrict extern X)
end.

Lemma restrict_sm_com: forall mu X Y,
      restrict_sm (restrict_sm mu X) Y = restrict_sm (restrict_sm mu Y) X.

Lemma restrict_sm_nest: forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu X) Y = restrict_sm mu Y.

Lemma restrict_sm_nest': forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu Y) X = restrict_sm mu Y.

Lemma restrict_sm_local: forall mu X,
      local_of (restrict_sm mu X) = restrict (local_of mu) X.
Lemma restrict_sm_pub: forall mu X,
      pub_of (restrict_sm mu X) = restrict (pub_of mu) X.

Lemma restrict_sm_extern: forall mu X,
      extern_of (restrict_sm mu X) = restrict (extern_of mu) X.
Lemma restrict_sm_foreign: forall mu X,
      foreign_of (restrict_sm mu X) = restrict (foreign_of mu) X.

Lemma restrict_sm_all: forall mu X,
       as_inj (restrict_sm mu X) = restrict (as_inj mu) X.

Lemma restrict_sm_local': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      local_of (restrict_sm mu X) = local_of mu.

Lemma restrict_sm_pub': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true ->
                     X b = true),
      pub_of (restrict_sm mu X) = pub_of mu.

Lemma restrict_sm_foreign': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      foreign_of (restrict_sm mu X) = foreign_of mu.

Lemma restrict_sm_locBlocksSrc: forall mu X,
      locBlocksSrc (restrict_sm mu X) = locBlocksSrc mu.
Lemma restrict_sm_extBlocksSrc: forall mu X,
      extBlocksSrc (restrict_sm mu X) = extBlocksSrc mu.
Lemma restrict_sm_pubBlocksSrc: forall mu X,
      pubBlocksSrc (restrict_sm mu X) = pubBlocksSrc mu.
Lemma restrict_sm_frgnBlocksSrc: forall mu X,
      frgnBlocksSrc (restrict_sm mu X) = frgnBlocksSrc mu.
Lemma restrict_sm_DomSrc: forall mu X,
      DomSrc (restrict_sm mu X) = DomSrc mu.
Lemma restrict_sm_DOM: forall mu X,
      DOM (restrict_sm mu X) = DOM mu.

Lemma restrict_sm_locBlocksTgt: forall mu X,
      locBlocksTgt (restrict_sm mu X) = locBlocksTgt mu.
Lemma restrict_sm_extBlocksTgt: forall mu X,
      extBlocksTgt (restrict_sm mu X) = extBlocksTgt mu.
Lemma restrict_sm_pubBlocksTgt: forall mu X,
      pubBlocksTgt (restrict_sm mu X) = pubBlocksTgt mu.
Lemma restrict_sm_frgnBlocksTgt: forall mu X,
      frgnBlocksTgt (restrict_sm mu X) = frgnBlocksTgt mu.
Lemma restrict_sm_DomTgt: forall mu X,
      DomTgt (restrict_sm mu X) = DomTgt mu.
Lemma restrict_sm_RNG: forall mu X,
      RNG (restrict_sm mu X) = RNG mu.

Lemma restrict_sm_WD:
      forall mu (WD: SM_wd mu) X
          (HX: forall b, vis mu b = true -> X b = true),
      SM_wd (restrict_sm mu X).

Lemma restrict_sm_preserves_globals: forall {F V} (ge:Genv.t F V) mu X

Definition mkinitial_SM (mu: SM_Injection) frgnS frgnT :=
  match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection (fun b => false) (fun b => false) (fun b => false) (fun b => false) (fun b => None)
                     (DomSrc mu) (DomTgt mu) frgnS frgnT (as_inj mu)
  end.

Lemma mkinitial_SM_as_inj: forall mu S T,
  as_inj (mkinitial_SM mu S T) = as_inj mu.
Lemma mkinitial_SM_local: forall mu S T,
  local_of (mkinitial_SM mu S T) = fun b => None.
Lemma mkinitial_SM_extern: forall mu S T,
  extern_of (mkinitial_SM mu S T) = as_inj mu.

Lemma mkinitial_SM_foreign: forall mu S T b1,
  foreign_of (mkinitial_SM mu S T) b1 =
  if S b1 then as_inj mu b1 else None.

Lemma mkinitial_SM_DomSrc: forall mu S T,
  DomSrc (mkinitial_SM mu S T) = DomSrc mu.
Lemma mkinitial_SM_DOM: forall mu S T,
  DOM (mkinitial_SM mu S T) = DOM mu.
Lemma mkinitial_SM_DomTgt: forall mu S T,
  DomTgt (mkinitial_SM mu S T) = DomTgt mu.
Lemma mkinitial_SM_RBG: forall mu S T,
  RNG (mkinitial_SM mu S T) = RNG mu.

Lemma mkinitial_SM_equals_initial_SM: forall mu S T,
  mkinitial_SM mu S T = initial_SM (DomSrc mu) (DomTgt mu) S T (as_inj mu).

Lemma mkinitial_SM_ok: forall {F1 V1 F2 V2:Type}
        (g1: Genv.t F1 V1) (g2: Genv.t F2 V2) (G:genvs_domain_eq g1 g2)

Module SM_simulation. Section SharedMemory_simulation_inject.
  Context {F1 V1 C1 F2 V2 C2:Type}
          (Sem1 : @EffectSem (Genv.t F1 V1) C1)
          (Sem2 : @EffectSem (Genv.t F2 V2) C2)
          (ge1: Genv.t F1 V1)
          (ge2: Genv.t F2 V2)
          (entry_points : list (val * val * signature)).

  Record SM_simulation_inject :=
  { core_data : Type;
    match_state : core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop;
    core_ord : core_data -> core_data -> Prop;
    core_ord_wf : well_founded core_ord;

    match_sm_wd: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          SM_wd mu;

    genvs_dom_eq: genvs_domain_eq ge1 ge2;

    match_genv: forall d mu c1 m1 c2 m2 (MC:match_state d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true);

    match_visible: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu);

    match_restrict: forall d mu c1 m1 c2 m2 X,
          match_state d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_state d (restrict_sm mu X) c1 m1 c2 m2;

    match_validblocks: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2;

    core_initial : forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists cd, exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_state cd (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2;

    core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall cd st2 mu m2,
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_state cd' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            core_ord cd' cd);

      effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall cd st2 mu m2
        (UHyp: forall b1 z, U1 b1 z = true -> Mem.valid_block m1 b1 ->
                            vis mu b1 = true),
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_state cd' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               core_ord cd' cd)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)));

    core_halted : forall cd mu c1 m1 c2 m2 v1,
      match_state cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2;

    core_at_external :
      forall cd mu c1 m1 c2 m2 e vals1 ef_sig,
        match_state cd mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\

         exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2));

    eff_after_external:
      forall cd mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_state cd mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

         (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

         (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
        exists cd', exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_state cd' mu' st1' m1' st2' m2'
}.

End SharedMemory_simulation_inject.

End SM_simulation. *)

Require Import sepcomp.effect_properties.

Require Import effect_simulations_lemmas.
(* effect_simulations_lemmas:
Require Import Events.
Require Import Memory.
Require Import Coqlib.
Require Import compcert.common.Values.
Require Import Maps.
Require Import Integers.
Require Import AST.
Require Import Globalenvs.

Require Import Axioms.
Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Require Import effect_simulations.

Section Eff_INJ_SIMU_DIAGRAMS.
  Context {F1 V1 C1 F2 V2 C2:Type}
          {Sem1 : @EffectSem (Genv.t F1 V1) C1}
          {Sem2 : @EffectSem (Genv.t F2 V2) C2}

          {ge1: Genv.t F1 V1}
          {ge2: Genv.t F2 V2}
          {entry_points : list (val * val * signature)}.

  Let core_data := C1.

  Variable match_states: core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop.

   Hypothesis genvs_dom_eq: genvs_domain_eq ge1 ge2.

   Hypothesis match_sm_wd: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          SM_wd mu.

    Hypothesis match_visible: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu).

    Hypothesis match_restrict: forall d mu c1 m1 c2 m2 X,
          match_states d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_states d (restrict_sm mu X) c1 m1 c2 m2.

   Hypothesis match_validblocks: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2.

    Hypothesis match_genv: forall d mu c1 m1 c2 m2 (MC:match_states d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true).

   Hypothesis inj_initial_cores: forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_states c1 (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2.

  Hypothesis inj_halted : forall cd mu c1 m1 c2 m2 v1,
      match_states cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2.

  Hypothesis inj_at_external :
      forall mu c1 m1 c2 m2 e vals1 ef_sig,
        match_states c1 mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\
          exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2)).

  Hypothesis inj_after_external:
      forall mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_states st1 mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

        (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

        (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
       exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_states st1' mu' st1' m1' st2' m2'.

Section EFF_INJ_SIMULATION_STAR_WF.
Variable order: C1 -> C1 -> Prop.
Hypothesis order_wf: well_founded order.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            order st1' st1).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b z, U1 b z = true -> Mem.valid_block m1 b ->
                           vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               order st1' st1)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty))).

Lemma  inj_simulation_star_wf:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR_WF.

Section EFF_INJ_SIMULATION_STAR.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                  vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_star:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR.

Section EFF_INJ_SIMULATION_PLUS.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                             vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_plus:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_PLUS.

End Eff_INJ_SIMU_DIAGRAMS.

Definition compose_sm (mu1 mu2 : SM_Injection) : SM_Injection :=
 Build_SM_Injection
   (locBlocksSrc mu1) (locBlocksTgt mu2)
   (pubBlocksSrc mu1) (pubBlocksTgt mu2)
   (compose_meminj (local_of mu1) (local_of mu2))
   (extBlocksSrc mu1) (extBlocksTgt mu2)
   (frgnBlocksSrc mu1) (frgnBlocksTgt mu2)
   (compose_meminj (extern_of mu1) (extern_of mu2)).

Lemma compose_sm_valid: forall mu1 mu2 m1 m2 m2' m3
          (SMV1: sm_valid mu1 m1 m2) (SMV2: sm_valid mu2 m2' m3),
       sm_valid (compose_sm mu1 mu2) m1 m3.

Lemma compose_sm_pub: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      pub_of (compose_sm mu12 mu23) =
      compose_meminj (pub_of mu12) (pub_of mu23).

Lemma compose_sm_DomSrc: forall mu12 mu23,
  DomSrc (compose_sm mu12 mu23) = DomSrc mu12.

Lemma compose_sm_DomTgt: forall mu12 mu23,
  DomTgt (compose_sm mu12 mu23) = DomTgt mu23.

Lemma compose_sm_foreign: forall mu12 mu23
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      foreign_of (compose_sm mu12 mu23) =
      compose_meminj (foreign_of mu12) (foreign_of mu23).

Lemma compose_sm_priv: forall mu12 mu23,
   priv_of (compose_sm mu12 mu23) =
   compose_meminj (priv_of mu12) (local_of mu23).

Lemma compose_sm_unknown: forall mu12 mu23,
   unknown_of (compose_sm mu12 mu23) =
   compose_meminj (unknown_of mu12) (extern_of mu23).

Lemma compose_sm_local: forall mu12 mu23,
   local_of (compose_sm mu12 mu23) =
   compose_meminj (local_of mu12) (local_of mu23).

Lemma compose_sm_extern: forall mu12 mu23,
   extern_of (compose_sm mu12 mu23) =
   compose_meminj (extern_of mu12) (extern_of mu23).

Lemma compose_sm_shared: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12) (WD2:SM_wd mu23),
      shared_of (compose_sm mu12 mu23) =
      compose_meminj (shared_of mu12) (shared_of mu23).

Lemma compose_sm_wd: forall mu1 mu2 (WD1: SM_wd mu1) (WD2:SM_wd mu2)
         (HypPub: forall b, pubBlocksTgt mu1 b = true ->
                            pubBlocksSrc mu2 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu1 b = true ->
                            frgnBlocksSrc mu2 b = true),
      SM_wd (compose_sm mu1 mu2).

Lemma compose_sm_as_inj: forall mu12 mu23 (WD1: SM_wd mu12) (WD2: SM_wd mu23)
   (SrcTgtLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
   (SrcTgtExt: extBlocksTgt mu12 = extBlocksSrc mu23),
   as_inj (compose_sm mu12 mu23) =
   compose_meminj (as_inj mu12) (as_inj mu23).

Lemma compose_sm_intern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: intern_incr mu12 mu12')
            (inc23: intern_incr mu23 mu23'),
      intern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma compose_sm_extern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: extern_incr mu12 mu12')
            (inc23: extern_incr mu23 mu23')
  (FRG': forall b1 b2 d1, foreign_of mu12' b1 = Some(b2,d1) ->
         exists b3 d2, foreign_of mu23' b2 = Some(b3,d2))
  (WD12': SM_wd mu12') (WD23': SM_wd mu23'),
  extern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma extern_incr_inject_incr:
      forall nu12 nu23 nu' (WDnu' : SM_wd nu')
          (EXT: extern_incr (compose_sm nu12 nu23) nu')
          (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\
                      locBlocksTgt nu12 = locBlocksSrc nu23 /\
                      extBlocksTgt nu12 = extBlocksSrc nu23 /\
                      (forall b, pubBlocksTgt nu12 b = true ->
                                 pubBlocksSrc nu23 b = true) /\
                      (forall b, frgnBlocksTgt nu12 b = true ->
                                 frgnBlocksSrc nu23 b = true)),
      inject_incr (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu').

Lemma compose_sm_as_injD: forall mu1 mu2 b1 b3 d
      (I: as_inj (compose_sm mu1 mu2) b1 = Some (b3, d))
      (WD1: SM_wd mu1) (WD2: SM_wd mu2),
      exists b2 d1 d2, as_inj mu1 b1 = Some(b2,d1) /\
                       as_inj mu2 b2 = Some(b3,d2) /\
                       d=d1+d2.

Lemma compose_sm_intern_separated:
      forall mu12 mu12' mu23 mu23' m1 m2 m3
        (inc12: intern_incr mu12 mu12')
        (inc23: intern_incr mu23 mu23')
        (InjSep12 : sm_inject_separated mu12 mu12' m1 m2)
        (InjSep23 : sm_inject_separated mu23 mu23' m2 m3)
        (WD12: SM_wd mu12) (WD12': SM_wd mu12') (WD23: SM_wd mu23) (WD23': SM_wd mu23')
        (BlocksLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
        (BlocksExt: extBlocksTgt mu12 = extBlocksSrc mu23),
      sm_inject_separated (compose_sm mu12 mu23)
                          (compose_sm mu12' mu23') m1 m3.

Lemma vis_compose_sm: forall mu nu, vis (compose_sm mu nu) = vis mu.

Lemma restrict_compose: forall j k X,
  restrict (compose_meminj j k) X = compose_meminj (restrict j X) k. *)



Require Export Axioms.

Require Import CminorSel_coop.
(* CminorSel_coop:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import compcert.common.Values.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Import Op.
Require Import Maps.
Require Import Switch.

Require Import sepcomp.CminorSel.
Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.

Inductive CMinSel_core: Type :=
  | CMinSel_State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (sp: val)                  
             (e: Cminor.env),           
      CMinSel_core
  | CMinSel_Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont),                 
      CMinSel_core
  | CMinSel_Returnstate:
      forall (v: val)                   
             (k: cont),                 
      CMinSel_core.

Definition ToState (q:CMinSel_core) (m:mem): CminorSel.state :=
  match q with
     CMinSel_State f s k sp e => State f s k sp e m
   | CMinSel_Callstate f args k => Callstate f args k m
   | CMinSel_Returnstate v k => Returnstate v k m
  end.

Definition FromState (c: CminorSel.state) : CMinSel_core * mem :=
  match c with
     State f s k sp e m => (CMinSel_State f s k sp e, m)
   | Callstate f args k m => (CMinSel_Callstate f args k, m)
   | Returnstate v k m => (CMinSel_Returnstate v k, m)
  end.

Definition CMinSel_at_external (c: CMinSel_core) : option (external_function * signature * list val) :=
  match c with
  | CMinSel_State _ _ _ _ _ => None
  | CMinSel_Callstate fd args k => match fd with
                                  Internal f => None
                                | External ef => Some (ef, ef_sig ef, args)
                              end
  | CMinSel_Returnstate v k => None
 end.

Definition CMinSel_after_external (vret: option val) (c: CMinSel_core) : option CMinSel_core :=
  match c with
    CMinSel_Callstate fd args k =>
         match fd with
            Internal f => None
          | External ef => match vret with
                             None => Some (CMinSel_Returnstate Vundef k)
                           | Some v => Some (CMinSel_Returnstate v k)
                           end
         end
  | _ => None
  end.

Inductive CMinSel_corestep (ge : genv) : CMinSel_core -> mem ->
                           CMinSel_core -> mem -> Prop:=

  | cminsel_corestep_skip_seq: forall f s k sp e m,
      CMinSel_corestep ge (CMinSel_State f Sskip (Kseq s k) sp e) m
        (CMinSel_State f s k sp e) m
  | cminsel_corestep_skip_block: forall f k sp e m,
      CMinSel_corestep ge (CMinSel_State f Sskip (Kblock k) sp e) m
        (CMinSel_State f Sskip k sp e) m
  | cminsel_corestep_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      CMinSel_corestep ge (CMinSel_State f Sskip k (Vptr sp Int.zero) e) m
        (CMinSel_Returnstate Vundef k) m'

  | cminsel_corestep_assign: forall f id a k sp e m v,
      eval_expr ge sp e m nil a v ->
      CMinSel_corestep ge (CMinSel_State f (Sassign id a) k sp e) m
        (CMinSel_State f Sskip k sp (PTree.set id v e)) m

  | cminsel_corestep_store: forall f chunk addr al b k sp e m vl v vaddr m',
      eval_exprlist ge sp e m nil al vl ->
      eval_expr ge sp e m nil b v ->
      eval_addressing ge sp addr vl = Some vaddr ->
      Mem.storev chunk m vaddr v = Some m' ->
      CMinSel_corestep ge (CMinSel_State f (Sstore chunk addr al b) k sp e) m
        (CMinSel_State f Sskip k sp e) m'

  | cminsel_corestep_call: forall f optid sig a bl k sp e m vf vargs fd,
      eval_expr_or_symbol ge sp e m nil a vf ->
      eval_exprlist ge sp e m nil bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      CMinSel_corestep ge (CMinSel_State f (Scall optid sig a bl) k sp e) m
        (CMinSel_Callstate fd vargs (Kcall optid f sp e k)) m

  | cminsel_corestep_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      eval_expr_or_symbol ge (Vptr sp Int.zero) e m nil a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m nil bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      CMinSel_corestep ge (CMinSel_State f (Stailcall sig a bl) k (Vptr sp Int.zero) e) m
        (CMinSel_Callstate fd vargs (call_cont k)) m'

  | cminsel_corestep_seq: forall f s1 s2 k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sseq s1 s2) k sp e) m
        (CMinSel_State f s1 (Kseq s2 k) sp e) m

  | cminsel_corestep_ifthenelse: forall f c s1 s2 k sp e m b,
      eval_condexpr ge sp e m nil c b ->
      CMinSel_corestep ge (CMinSel_State f (Sifthenelse c s1 s2) k sp e) m
        (CMinSel_State f (if b then s1 else s2) k sp e) m

  | cminsel_corestep_loop: forall f s k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sloop s) k sp e) m
        (CMinSel_State f s (Kseq (Sloop s) k) sp e) m

  | cminsel_corestep_block: forall f s k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sblock s) k sp e) m
        (CMinSel_State f s (Kblock k) sp e) m

  | cminsel_corestep_exit_seq: forall f n s k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sexit n) (Kseq s k) sp e) m
        (CMinSel_State f (Sexit n) k sp e) m
  | cminsel_corestep_exit_block_0: forall f k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sexit O) (Kblock k) sp e) m
        (CMinSel_State f Sskip k sp e) m
  | cminsel_corestep_exit_block_S: forall f n k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Sexit (S n)) (Kblock k) sp e) m
        (CMinSel_State f (Sexit n) k sp e) m

  | cminsel_corestep_switch: forall f a cases default k sp e m n,
      eval_expr ge sp e m nil a (Vint n) ->
      CMinSel_corestep ge (CMinSel_State f (Sswitch a cases default) k sp e) m
        (CMinSel_State f (Sexit (switch_target n default cases)) k sp e) m

  | cminsel_corestep_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      CMinSel_corestep ge (CMinSel_State f (Sreturn None) k (Vptr sp Int.zero) e) m
        (CMinSel_Returnstate Vundef (call_cont k)) m'
  | cminsel_corestep_return_1: forall f a k sp e m v m',
      eval_expr ge (Vptr sp Int.zero) e m nil a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      CMinSel_corestep ge (CMinSel_State f (Sreturn (Some a)) k (Vptr sp Int.zero) e) m
        (CMinSel_Returnstate v (call_cont k)) m'

  | cminsel_corestep_label: forall f lbl s k sp e m,
      CMinSel_corestep ge (CMinSel_State f (Slabel lbl s) k sp e) m
        (CMinSel_State f s k sp e) m

  | cminsel_corestep_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      CMinSel_corestep ge (CMinSel_State f (Sgoto lbl) k sp e) m
        (CMinSel_State f s' k' sp e) m

  | cminsel_corestep_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      Cminor.set_locals f.(fn_vars) (Cminor.set_params vargs f.(fn_params)) = e ->
      CMinSel_corestep ge (CMinSel_Callstate (Internal f) vargs k) m
        (CMinSel_State f f.(fn_body) k (Vptr sp Int.zero) e) m'

  | cminsel_corestep_return: forall v optid f sp e k m,
      CMinSel_corestep ge (CMinSel_Returnstate v (Kcall optid f sp e k)) m
        (CMinSel_State f Sskip k sp (Cminor.set_optvar optid v e)) m.

Lemma CMinSel_corestep_not_at_external:
       forall ge m q m' q', CMinSel_corestep ge q m q' m' -> CMinSel_at_external q = None.

Definition CMinSel_halted (q : CMinSel_core): option val :=
    match q with
       CMinSel_Returnstate v Kstop => Some v
     | _ => None
    end.

Lemma CMinSel_corestep_not_halted : forall ge m q m' q',
       CMinSel_corestep ge q m q' m' -> CMinSel_halted q = None.

Lemma CMinSel_at_external_halted_excl :
       forall q, CMinSel_at_external q = None \/ CMinSel_halted q = None.

Lemma CMinSel_after_at_external_excl : forall retv q q',
      CMinSel_after_external retv q = Some q' -> CMinSel_at_external q' = None.

Definition CMinSel_initial_core (ge:genv) (v: val) (args:list val): option CMinSel_core :=
   match v with
     | Vptr b i =>
          if Int.eq_dec i Int.zero
          then match Genv.find_funct_ptr ge b with
                 | None => None
                 | Some f => Some (CMinSel_Callstate f args Kstop)
               end
          else None
     | _ => None
    end.

Definition CMinSel_core_sem : CoreSemantics genv CMinSel_core mem.

Lemma CMinSel_forward : forall g c m c' m' (CS: CMinSel_corestep g c m c' m'),
      mem_forward m m'.

Program Definition cminsel_coop_sem :
  CoopCoreSem genv CMinSel_core. *)

Require Import CminorSel_eff.
(* CminorSel_eff:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import compcert.common.Values.
Require Import Memory.
Require Export Maps.
Require Import Events.
Require Import Globalenvs.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.

Require Import sepcomp.CminorSel.
Require Import sepcomp.CminorSel_coop.

Inductive cminsel_effstep (g:genv):  (block -> Z -> bool) ->
            CMinSel_core -> mem -> CMinSel_core -> mem -> Prop :=

  | cminsel_effstep_skip_seq: forall f s k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f Sskip (Kseq s k) sp e) m
         (CMinSel_State f s k sp e) m

  | cminsel_effstep_skip_block: forall f k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f Sskip (Kblock k) sp e) m
         (CMinSel_State f Sskip k sp e) m

  | cminsel_effstep_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      cminsel_effstep g (FreeEffect m 0 (f.(fn_stackspace)) sp)
         (CMinSel_State f Sskip k (Vptr sp Int.zero) e) m
         (CMinSel_Returnstate Vundef k) m'

  | cminsel_effstep_assign: forall f id a k sp e m v,
      CminorSel.eval_expr g sp e m nil a v ->
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sassign id a) k sp e) m
         (CMinSel_State f Sskip k sp (PTree.set id v e)) m

  | cminsel_effstep_store: forall f chunk addr al b k sp e m vl v vaddr m',
      CminorSel.eval_exprlist g sp e m nil al vl ->
      CminorSel.eval_expr g sp e m nil b v ->
      Op.eval_addressing g sp addr vl = Some vaddr ->
      Mem.storev chunk m vaddr v = Some m' ->
      cminsel_effstep g (StoreEffect vaddr (encode_val chunk v))
        (CMinSel_State f (Sstore chunk addr al b) k sp e) m
        (CMinSel_State f Sskip k sp e) m'

  | cminsel_effstep_call:forall f optid sig a bl k sp e m vf vargs fd,
      CminorSel.eval_expr_or_symbol g sp e m nil a vf ->
      CminorSel.eval_exprlist g sp e m nil bl vargs ->
      Genv.find_funct g vf = Some fd ->
      funsig fd = sig ->
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Scall optid sig a bl) k sp e) m
         (CMinSel_Callstate fd vargs (Kcall optid f sp e k)) m

  | cminsel_effstep_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      CminorSel.eval_expr_or_symbol g (Vptr sp Int.zero) e m nil a vf ->
      CminorSel.eval_exprlist g (Vptr sp Int.zero) e m nil bl vargs ->
      Genv.find_funct g vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      cminsel_effstep g (FreeEffect m 0 (f.(fn_stackspace)) sp)
        (CMinSel_State f (Stailcall sig a bl) k (Vptr sp Int.zero) e) m
        (CMinSel_Callstate fd vargs (call_cont k)) m'

  | cminsel_effstep_seq: forall f s1 s2 k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sseq s1 s2) k sp e) m
         (CMinSel_State f s1 (Kseq s2 k) sp e) m

  | cminsel_effstep_ifthenelse:  forall f c s1 s2 k sp e m b,
      CminorSel.eval_condexpr g sp e m nil c b ->
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Sifthenelse c s1 s2) k sp e) m
         (CMinSel_State f (if b then s1 else s2) k sp e) m

  | cminsel_effstep_loop: forall f s k sp e m,
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Sloop s) k sp e) m
         (CMinSel_State f s (Kseq (Sloop s) k) sp e) m

  | cminsel_effstep_block: forall f s k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sblock s) k sp e) m
         (CMinSel_State f s (Kblock k) sp e) m

  | cminsel_effstep_exit_seq: forall f n s k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sexit n) (Kseq s k) sp e) m
         (CMinSel_State f (Sexit n) k sp e) m

  | cminsel_effstep_exit_block_0: forall f k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sexit O) (Kblock k) sp e) m
         (CMinSel_State f Sskip k sp e) m
  | cminsel_effstep_exit_block_S: forall f n k sp e m,
      cminsel_effstep g EmptyEffect (CMinSel_State f (Sexit (S n)) (Kblock k) sp e) m
         (CMinSel_State f (Sexit n) k sp e) m

  | cminsel_effstep_switch: forall f a cases default k sp e m n,
      CminorSel.eval_expr g sp e m nil a (Vint n) ->
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Sswitch a cases default) k sp e) m
         (CMinSel_State f (Sexit (Switch.switch_target n default cases)) k sp e) m

  | cminsel_effstep_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      cminsel_effstep g (FreeEffect m 0 (f.(fn_stackspace)) sp) (CMinSel_State f (Sreturn None) k (Vptr sp Int.zero) e) m
         (CMinSel_Returnstate Vundef (call_cont k)) m'
  | cminsel_effstep_return_1: forall f a k sp e m v m',
      CminorSel.eval_expr g (Vptr sp Int.zero) e m nil a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      cminsel_effstep g (FreeEffect m 0 (f.(fn_stackspace)) sp)
         (CMinSel_State f (Sreturn (Some a)) k (Vptr sp Int.zero) e) m
         (CMinSel_Returnstate v (call_cont k)) m'

  | cminsel_effstep_label: forall f lbl s k sp e m,
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Slabel lbl s) k sp e) m
         (CMinSel_State f s k sp e) m

  | cminsel_effstep_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      cminsel_effstep g EmptyEffect
         (CMinSel_State f (Sgoto lbl) k sp e) m
         (CMinSel_State f s' k' sp e) m

  | cminsel_effstep_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      Cminor.set_locals f.(fn_vars) (Cminor.set_params vargs f.(fn_params)) = e ->
      cminsel_effstep g EmptyEffect
         (CMinSel_Callstate (Internal f) vargs k) m
         (CMinSel_State f f.(fn_body) k (Vptr sp Int.zero) e) m'

  | cminsel_effstep_return: forall v optid f sp e k m,
      cminsel_effstep g EmptyEffect
        (CMinSel_Returnstate v (Kcall optid f sp e k)) m
        (CMinSel_State f Sskip k sp (Cminor.set_optvar optid v e)) m

  | cminsel_effstep_sub_val: forall E EE c m c' m',
      (forall b ofs, Mem.valid_block m b ->
                     E b ofs = true -> EE b ofs = true) ->
      cminsel_effstep g E c m c' m' ->
      cminsel_effstep g EE c m c' m'.

Lemma cminselstep_effax1: forall (M : block -> Z -> bool) g c m c' m',
      cminsel_effstep g M c m c' m' ->
      (corestep cminsel_coop_sem g c m c' m' /\
       Mem.unchanged_on (fun (b : block) (ofs : Z) => M b ofs = false) m m').

Lemma cminselstep_effax2: forall  g c m c' m',
      corestep cminsel_coop_sem g c m c' m' ->
      exists M, cminsel_effstep g M c m c' m'.

Program Definition cminsel_eff_sem :
  @EffectSem genv CMinSel_core. *)

Require Import RTL_coop.
(* RTL_coop:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Values.
Require Import Events.
Require Import Memory.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Op.
Require Import Registers.

Require Import RTL.

Inductive RTL_core : Type :=
  | RTL_State:
      forall (stack: list stackframe) 
             (f: function)            
             (sp: val)                
             (pc: node)               
             (rs: regset),             
      RTL_core
  | RTL_Callstate:
      forall (stack: list stackframe) 
             (f: fundef)              
             (args: list val),         
      RTL_core
  | RTL_Returnstate:
      forall (stack: list stackframe) 
             (v: val),                 
      RTL_core.

Definition core2state (q:RTL_core)(m:mem): state:=
  match q with
      RTL_State stack f sp pc rs => State stack f sp pc rs m
    | RTL_Callstate stack f args => Callstate stack f args m
    | RTL_Returnstate stack v => Returnstate stack v m
  end.

Definition state2core (s:state): RTL_core * mem :=
  match s with
      State stack f sp pc rs m => (RTL_State stack f sp pc rs, m)
    | Callstate stack f args m => (RTL_Callstate stack f args, m)
    | Returnstate stack v m => (RTL_Returnstate stack v, m)
  end.

Section RELSEM.

Inductive RTL_corestep (ge:genv): RTL_core -> mem -> RTL_core -> mem -> Prop :=
  | rtl_corestep_exec_Inop:
      forall s f sp pc rs m pc',
      (fn_code f)!pc = Some(Inop pc') ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_corestep_exec_Iop:
      forall s f sp pc rs m op args res pc' v,
      (fn_code f)!pc = Some(Iop op args res pc') ->
      eval_operation ge sp op rs##args m = Some v ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' (rs#res <- v)) m
  | rtl_corestep_exec_Iload:
      forall s f sp pc rs m chunk addr args dst pc' a v,
      (fn_code f)!pc = Some(Iload chunk addr args dst pc') ->
      eval_addressing ge sp addr rs##args = Some a ->
      Mem.loadv chunk m a = Some v ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' (rs#dst <- v)) m
  | rtl_corestep_exec_Istore:
      forall s f sp pc rs m chunk addr args src pc' a m',
      (fn_code f)!pc = Some(Istore chunk addr args src pc') ->
      eval_addressing ge sp addr rs##args = Some a ->
      Mem.storev chunk m a rs#src = Some m' ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m'
  | rtl_corestep_exec_Icall:
      forall s f sp pc rs m sig ros args res pc' fd,
      (fn_code f)!pc = Some(Icall sig ros args res pc') ->
      find_function ge ros rs = Some fd ->
      funsig fd = sig ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_Callstate (Stackframe res f sp pc' rs :: s) fd rs##args) m
  | rtl_corestep_exec_Itailcall:
      forall s f stk pc rs m sig ros args fd m',
      (fn_code f)!pc = Some(Itailcall sig ros args) ->
      find_function ge ros rs = Some fd ->
      funsig fd = sig ->
      Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
      RTL_corestep ge (RTL_State s f (Vptr stk Int.zero) pc rs) m
        (RTL_Callstate s fd rs##args) m'

  | rtl_corestep_exec_Icond:
      forall s f sp pc rs m cond args ifso ifnot b pc',
      (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
      eval_condition cond rs##args m = Some b ->
      pc' = (if b then ifso else ifnot) ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_corestep_exec_Ijumptable:
      forall s f sp pc rs m arg tbl n pc',
      (fn_code f)!pc = Some(Ijumptable arg tbl) ->
      rs#arg = Vint n ->
      list_nth_z tbl (Int.unsigned n) = Some pc' ->
      RTL_corestep ge (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_corestep_exec_Ireturn:
      forall s f stk pc rs m or m',
      (fn_code f)!pc = Some(Ireturn or) ->
      Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
      RTL_corestep ge (RTL_State s f (Vptr stk Int.zero) pc rs) m
        (RTL_Returnstate s (regmap_optget or Vundef rs)) m'
  | rtl_corestep_exec_function_internal:
      forall s f args m m' stk,
      Mem.alloc m 0 f.(fn_stacksize) = (m', stk) ->
      RTL_corestep ge (RTL_Callstate s (Internal f) args) m
        (RTL_State s
                  f
                  (Vptr stk Int.zero)
                  f.(fn_entrypoint)
                  (init_regs args f.(fn_params)))
        m'

  | rtl_corestep_exec_return:
      forall res f sp pc rs s vres m,
      RTL_corestep ge (RTL_Returnstate (Stackframe res f sp pc rs :: s) vres) m
        (RTL_State s f sp pc (rs#res <- vres)) m.
End RELSEM.

Require Import sepcomp.core_semantics.

Definition RTL_initial_core (ge: genv) (v:val)(args: list val): option RTL_core:=
  match v with
      Vptr b i =>
      if Int.eq_dec i Int.zero
      then match Genv.find_funct_ptr ge b with
               None => None
             | Some f => Some (RTL_Callstate nil f args)
           end
      else None
    | _ => None
  end.

Definition RTL_halted (c: RTL_core ): option val :=
  match c with

      RTL_Returnstate nil v => Some v
    | _ => None
  end.

Definition RTL_at_external (c: RTL_core): option (external_function * signature * list val) :=
  match c with
    | RTL_State stack f sp pc rs => None
    | RTL_Callstate stack f args =>  match f with
                                        Internal _ => None
                                      | External f' => Some( f', ef_sig f', args)
                                    end
    | RTL_Returnstate stack v => None
  end.

Definition RTL_after_external (vret: option val)(c: RTL_core): option RTL_core :=
  match c with
    | RTL_State stack f sp pc rs => None
    | RTL_Callstate stack f args =>
      match f with
          Internal _ => None
        | External f' => match vret with
                             None => Some (RTL_Returnstate stack Vundef)
                           | Some v => Some (RTL_Returnstate stack v)
                         end
      end
    | RTL_Returnstate stack v => None
  end.

Lemma corestep_not_external: forall (ge : genv) (m : mem) (q : RTL_core) (m' : mem) (q' : RTL_core),
                               RTL_corestep ge q m q' m' -> RTL_at_external q = None.

Lemma corestep_not_halted: forall (ge : genv) (m : mem) (q : RTL_core) (m' : mem) (q' : RTL_core),
                             RTL_corestep ge q m q' m' -> RTL_halted q = None.

Lemma external_xor_halted: forall q : RTL_core, RTL_at_external q = None \/ RTL_halted q = None.

Lemma after_xor_at_external: forall (retv : option val) (q q' : RTL_core),
                               RTL_after_external retv q = Some q' -> RTL_at_external q' = None.

Definition RTL_core_sem : CoreSemantics genv RTL_core mem.

Require Import sepcomp.mem_lemmas. 

Lemma rtl_coop_forward : forall g c m c' m' (CS: RTL_corestep g c m c' m'),
      mem_forward m m'.

Program Definition rtl_coop_sem :
  CoopCoreSem genv RTL_core. *)

Require Import RTL_eff.
(* RTL_eff:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import compcert.common.Values.
Require Import Memory.
Require Export Maps.
Require Import Events.
Require Import Globalenvs.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import Op.
Require Import Registers.

Require Import sepcomp.RTL.
Require Import sepcomp.RTL_coop.

Inductive RTL_effstep (ge:genv):  (block -> Z -> bool) ->
            RTL_core -> mem -> RTL_core -> mem -> Prop :=
  | rtl_effstep_exec_Inop:
      forall s f sp pc rs m pc',
      (fn_code f)!pc = Some(Inop pc') ->
      RTL_effstep ge EmptyEffect (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_effstep_exec_Iop:
      forall s f sp pc rs m op args res pc' v,
      (fn_code f)!pc = Some(Iop op args res pc') ->
      eval_operation ge sp op rs##args m = Some v ->
      RTL_effstep ge EmptyEffect (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' (rs#res <- v)) m
  | rtl_effstep_exec_Iload:
      forall s f sp pc rs m chunk addr args dst pc' a v,
      (fn_code f)!pc = Some(Iload chunk addr args dst pc') ->
      eval_addressing ge sp addr rs##args = Some a ->
      Mem.loadv chunk m a = Some v ->
      RTL_effstep ge EmptyEffect (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' (rs#dst <- v)) m
  | rtl_effstep_exec_Istore:
      forall s f sp pc rs m chunk addr args src pc' a m',
      (fn_code f)!pc = Some(Istore chunk addr args src pc') ->
      eval_addressing ge sp addr rs##args = Some a ->
      Mem.storev chunk m a rs#src = Some m' ->
      RTL_effstep ge (StoreEffect a (encode_val chunk (rs#src)))
        (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m'
  | rtl_effstep_exec_Icall:
      forall s f sp pc rs m sig ros args res pc' fd,
      (fn_code f)!pc = Some(Icall sig ros args res pc') ->
      find_function ge ros rs = Some fd ->
      funsig fd = sig ->
      RTL_effstep ge EmptyEffect
        (RTL_State s f sp pc rs) m
        (RTL_Callstate (Stackframe res f sp pc' rs :: s) fd rs##args) m
  | rtl_effstep_exec_Itailcall:
      forall s f stk pc rs m sig ros args fd m',
      (fn_code f)!pc = Some(Itailcall sig ros args) ->
      find_function ge ros rs = Some fd ->
      funsig fd = sig ->
      Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
      RTL_effstep ge (FreeEffect m 0 (f.(fn_stacksize)) stk)
        (RTL_State s f (Vptr stk Int.zero) pc rs) m
        (RTL_Callstate s fd rs##args) m'

  | rtl_effstep_exec_Icond:
      forall s f sp pc rs m cond args ifso ifnot b pc',
      (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
      eval_condition cond rs##args m = Some b ->
      pc' = (if b then ifso else ifnot) ->
      RTL_effstep ge EmptyEffect
        (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_effstep_exec_Ijumptable:
      forall s f sp pc rs m arg tbl n pc',
      (fn_code f)!pc = Some(Ijumptable arg tbl) ->
      rs#arg = Vint n ->
      list_nth_z tbl (Int.unsigned n) = Some pc' ->
      RTL_effstep ge EmptyEffect
        (RTL_State s f sp pc rs) m
        (RTL_State s f sp pc' rs) m
  | rtl_effstep_exec_Ireturn:
      forall s f stk pc rs m or m',
      (fn_code f)!pc = Some(Ireturn or) ->
      Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
      RTL_effstep ge (FreeEffect m 0 (f.(fn_stacksize)) stk)
        (RTL_State s f (Vptr stk Int.zero) pc rs) m
        (RTL_Returnstate s (regmap_optget or Vundef rs)) m'
  | rtl_effstep_exec_function_internal:
      forall s f args m m' stk,
      Mem.alloc m 0 f.(fn_stacksize) = (m', stk) ->
      RTL_effstep ge EmptyEffect
        (RTL_Callstate s (Internal f) args) m
        (RTL_State s
                  f
                  (Vptr stk Int.zero)
                  f.(fn_entrypoint)
                  (init_regs args f.(fn_params)))
        m'

  | rtl_effstep_exec_return:
      forall res f sp pc rs s vres m,
      RTL_effstep ge EmptyEffect
        (RTL_Returnstate (Stackframe res f sp pc rs :: s) vres) m
        (RTL_State s f sp pc (rs#res <- vres)) m

  | rtl_effstep_sub_val: forall E EE c m c' m',
      (forall b ofs, Mem.valid_block m b ->
                     E b ofs = true -> EE b ofs = true) ->
      RTL_effstep ge E c m c' m' ->
      RTL_effstep ge EE c m c' m'.

Lemma rtl_eff_exec_Iload':
  forall ge s f sp pc rs m chunk addr args dst pc' rs' a v,
  (fn_code f)!pc = Some(Iload chunk addr args dst pc') ->
  Op.eval_addressing ge sp addr rs##args = Some a ->

Lemma rtl_eff_exec_Iop':
  forall g s f sp pc rs m op args res pc' rs' v,
  (fn_code f)!pc = Some(Iop op args res pc') ->
  Op.eval_operation g sp op rs##args m = Some v ->

Lemma rtl_effax1: forall (M : block -> Z -> bool) g c m c' m',
      RTL_effstep g M c m c' m' ->
      (corestep rtl_coop_sem g c m c' m' /\
       Mem.unchanged_on (fun (b : block) (ofs : Z) => M b ofs = false) m m').

Lemma rtl_effax2: forall  g c m c' m',
      corestep rtl_coop_sem g c m c' m' ->
      exists M, RTL_effstep g M c m c' m'.

Program Definition rtl_eff_sem :
  @EffectSem genv RTL_core. *)



Record map_wf (m: mapping) : Prop :=

  mk_map_wf {

    map_wf_inj:

      (forall id1 id2 r,

         m.(map_vars)!id1 = Some r -> m.(map_vars)!id2 = Some r -> id1 = id2);

     map_wf_disj:

      (forall id r,

         m.(map_vars)!id = Some r -> In r m.(map_letvars) -> False)

  }.



Lemma init_mapping_wf:

  map_wf init_mapping.

Proof.

  unfold init_mapping; split; simpl.

  intros until r. rewrite PTree.gempty. congruence.

  tauto.

Qed.



Lemma add_var_wf:

  forall s1 s2 map name r map' i,

  add_var map name s1 = OK (r,map') s2 i ->

  map_wf map -> map_valid map s1 -> map_wf map'.

Proof.

  intros. monadInv H.

  apply mk_map_wf; simpl.

  intros until r0. repeat rewrite PTree.gsspec.

  destruct (peq id1 name); destruct (peq id2 name).

  congruence.

  intros. inv H. elimtype False.

  apply valid_fresh_absurd with r0 s1.

  apply H1. left; exists id2; auto.

  eauto with rtlg.

  intros. inv H2. elimtype False.

  apply valid_fresh_absurd with r0 s1.

  apply H1. left; exists id1; auto.

  eauto with rtlg.

  inv H0. eauto.

  intros until r0. rewrite PTree.gsspec.

  destruct (peq id name).

  intros. inv H.

  apply valid_fresh_absurd with r0 s1.

  apply H1. right; auto.

  eauto with rtlg.

  inv H0; eauto.

Qed.



Lemma add_vars_wf:

  forall names s1 s2 map map' rl i,

  add_vars map names s1 = OK (rl,map') s2 i ->

  map_wf map -> map_valid map s1 -> map_wf map'.

Proof.

  induction names; simpl; intros; monadInv H.

  auto.

  exploit add_vars_valid; eauto. intros [A B].

  eapply add_var_wf; eauto.

Qed.



Lemma add_letvar_wf:

  forall map r,

  map_wf map -> ~reg_in_map map r -> map_wf (add_letvar map r).

Proof.

  intros. inv H. unfold add_letvar; constructor; simpl.

  auto.

  intros. elim H1; intro. subst r0. elim H0. left; exists id; auto.

  eauto.

Qed.



Record match_env (j:meminj)

      (map: mapping) (e: env) (le: letenv) (rs: regset) : Prop :=

  mk_match_env {

    me_vars:

      (forall id v,

         e!id = Some v -> exists r, map.(map_vars)!id = Some r

          /\ val_inject j v rs#r);

    me_letvars:

      val_list_inject j le rs##(map.(map_letvars))

  }.



Lemma match_env_find_var:

  forall j map e le rs id v r,

  match_env j map e le rs ->

  e!id = Some v ->

  map.(map_vars)!id = Some r ->

  val_inject j v rs#r.

Proof.

  intros. exploit me_vars; eauto. intros [r' [EQ' RS]].

  replace r with r'. auto. congruence.

Qed.



Lemma match_env_inject_incr: forall j map e le rs

        (MENV: match_env j map e le rs) j'

        (INC: inject_incr j j'),

      match_env j' map e le rs.

Proof.

  intros.

  destruct MENV as [MENVa MENVb].

  constructor; intros.

    destruct (MENVa _ _ H) as [r [MAP INJ]].

    apply (val_inject_incr _ _ _ _ INC) in INJ.

    exists r; split; trivial.

  apply (val_list_inject_incr _ _ _ _ INC) in MENVb; trivial.

Qed.



Lemma match_env_restrictD: forall j X map e le rs

        (MENV: match_env (restrict j X) map e le rs),

      match_env j map e le rs.

Proof. intros.

  eapply match_env_inject_incr; try eassumption.

  eapply restrict_incr.

Qed.



Lemma match_env_find_letvar:

  forall j map e le rs idx v r,

  match_env j map e le rs ->

  List.nth_error le idx = Some v ->

  List.nth_error map.(map_letvars) idx = Some r ->

  val_inject j v rs#r.

Proof.

  intros. exploit me_letvars; eauto.

  clear H. revert le H0 H1. generalize (map_letvars map). clear map.

  induction idx; simpl; intros.

  inversion H; subst le; inversion H0. subst v0.

  destruct l; inversion H1. subst r0.

  inversion H2. subst v'. auto.

  destruct l; destruct le; try discriminate.

  eapply IHidx; eauto.

  inversion H. auto.

Qed.



Lemma match_env_invariant:

  forall j map e le rs rs',

  match_env j map e le rs ->

  (forall r, (reg_in_map map r) -> rs'#r = rs#r) ->

  match_env j map e le rs'.

Proof.

  intros. inversion H. apply mk_match_env.

  intros. exploit me_vars0; eauto. intros [r [A B]].

  exists r; split. auto. rewrite H0; auto. left; exists id; auto.

  replace (rs'##(map_letvars map)) with (rs ## (map_letvars map)). auto.

  apply list_map_exten. intros. apply H0. right; auto.

Qed.



Lemma match_env_update_temp:

  forall j map e le rs r v,

  match_env j map e le rs ->

  ~(reg_in_map map r) ->

  match_env j map e le (rs#r <- v).

Proof.

  intros. apply match_env_invariant with rs; auto.

  intros. case (Reg.eq r r0); intro.

  subst r0; contradiction.

  apply Regmap.gso; auto.

Qed.

Hint Resolve match_env_update_temp: rtlg.



Lemma match_env_update_var:

  forall j map e le rs id r v tv,

  val_inject j v tv ->

  map_wf map ->

  map.(map_vars)!id = Some r ->

  match_env j map e le rs ->

  match_env j map (PTree.set id v e) le (rs#r <- tv).

Proof.

  intros. inversion H0. inversion H2. apply mk_match_env.

  intros id' v'. rewrite PTree.gsspec. destruct (peq id' id); intros.

  subst id'. inv H3. exists r; split. auto. rewrite PMap.gss. auto.

  exploit me_vars0; eauto. intros [r' [A B]].

  exists r'; split. auto. rewrite PMap.gso; auto.

  red; intros. subst r'. elim n. eauto.

  erewrite list_map_exten. eauto.

  intros. symmetry. apply PMap.gso. red; intros. subst x. eauto.

Qed.



Lemma match_env_update_dest:

  forall j map e le rs dst r v tv,

  val_inject j v tv ->

  map_wf map ->

  reg_map_ok map r dst ->

  match_env j map e le rs ->

  match_env j map (set_optvar dst v e) le (rs#r <- tv).

Proof.

  intros. inv H1; simpl.

  eapply match_env_update_temp; eauto.

  eapply match_env_update_var; eauto.

Qed.

Hint Resolve match_env_update_dest: rtlg.



Lemma match_env_bind_letvar:

  forall j map e le rs r v,

  match_env j map e le rs ->

  val_inject j v rs#r ->

  match_env j (add_letvar map r) e (v :: le) rs.

Proof.

  intros. inv H. unfold add_letvar. apply mk_match_env; simpl; auto.

Qed.



Lemma match_env_unbind_letvar:

  forall j map e le rs r v,

  match_env j (add_letvar map r) e (v :: le) rs ->

  match_env j map e le rs.

Proof.

  unfold add_letvar; intros. inv H. simpl in *.

  constructor. auto. inversion me_letvars0. auto.

Qed.



Lemma match_env_empty:

  forall j map,

  map.(map_letvars) = nil ->

  match_env j map (PTree.empty val) nil (Regmap.init Vundef).

Proof.

  intros. apply mk_match_env.

  intros. rewrite PTree.gempty in H0. discriminate.

  rewrite H. constructor.

Qed.



Lemma match_set_params_init_regs:

  forall j il rl s1 map2 s2 vl tvl i,

  add_vars init_mapping il s1 = OK (rl, map2) s2 i ->

  val_list_inject j vl tvl ->

  match_env j map2 (set_params vl il) nil (init_regs tvl rl)

  /\ (forall r, reg_fresh r s2 -> (init_regs tvl rl)#r = Vundef).

Proof.

  induction il; intros.



  inv H. split. apply match_env_empty. auto. intros.

  simpl. apply Regmap.gi.



  monadInv H. simpl.

  exploit add_vars_valid; eauto. apply init_mapping_valid. intros [A B].

  exploit add_var_valid; eauto. intros [A' B']. clear B'.

  monadInv EQ1.

  destruct H0 as [ | v1 tv1 vs tvs].

  

  destruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF]. constructor. inv ME. split.

  replace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.

  constructor; simpl.

  intros id v. repeat rewrite PTree.gsspec. destruct (peq id a); intros.

  subst a. inv H. exists x1; split. auto. constructor.

  eauto.

  eauto.

  destruct x; reflexivity.

  intros. apply Regmap.gi.

  

  destruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF]. inv ME. split.

  constructor; simpl.

  intros id v. repeat rewrite PTree.gsspec. destruct (peq id a); intros.

  subst a.  inv H1. exists x1; split. auto. rewrite Regmap.gss. assumption.

  exploit me_vars0; eauto. intros [r' [C D]].

  exists r'; split. auto. rewrite Regmap.gso. auto.

  apply valid_fresh_different with s.

  apply B. left; exists id; auto.

  eauto with rtlg.

  destruct (map_letvars x0). auto. simpl in me_letvars0. inversion me_letvars0.

  intros. rewrite Regmap.gso. apply UNDEF.

  apply reg_fresh_decr with s2; eauto with rtlg.

  apply sym_not_equal. apply valid_fresh_different with s2; auto.

Qed.



Lemma match_set_locals:

  forall j map1 s1,

  map_wf map1 ->

  forall il rl map2 s2 e le rs i,

  match_env j map1 e le rs ->

  (forall r, reg_fresh r s1 -> rs#r = Vundef) ->

  add_vars map1 il s1 = OK (rl, map2) s2 i ->

  match_env j map2 (set_locals il e) le rs.

Proof.

  induction il; simpl in *; intros.



  inv H2. auto.



  monadInv H2.

  exploit IHil; eauto. intro.

  monadInv EQ1.

  constructor.

  intros id v. simpl. repeat rewrite PTree.gsspec.

  destruct (peq id a). subst a. intro.

  exists x1. split. auto. inv H3. constructor.

  eauto with rtlg.

  intros. eapply me_vars; eauto.

  simpl. eapply me_letvars; eauto.

Qed.



Lemma match_init_env_init_reg:

  forall j params s0 rparams map1 s1 i1 vars rvars map2 s2 i2 vparams tvparams,

  add_vars init_mapping params s0 = OK (rparams, map1) s1 i1 ->

  add_vars map1 vars s1 = OK (rvars, map2) s2 i2 ->

  val_list_inject j vparams tvparams ->

  match_env j map2 (set_locals vars (set_params vparams params))

            nil (init_regs tvparams rparams).

Proof.

  intros.

  exploit match_set_params_init_regs; eauto. intros [A B].

  eapply match_set_locals; eauto.

  eapply add_vars_wf; eauto. apply init_mapping_wf.

  apply init_mapping_valid.

Qed.



Require Import Errors.



Section CORRECTNESS.



Variable prog: CminorSel.program.

Variable tprog: RTL.program.

Hypothesis TRANSL: transl_program prog = OK tprog.



Let ge : CminorSel.genv := Genv.globalenv prog.

Let tge : RTL.genv := Genv.globalenv tprog.



Lemma symbols_preserved:

  forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.

Proof

  (Genv.find_symbol_transf_partial transl_fundef _ TRANSL).



Lemma function_ptr_translated:

  forall (b: block) (f: CminorSel.fundef),

  Genv.find_funct_ptr ge b = Some f ->

  exists tf,

  Genv.find_funct_ptr tge b = Some tf /\ transl_fundef f = OK tf.

Proof

  (Genv.find_funct_ptr_transf_partial transl_fundef _ TRANSL).



Lemma functions_translated:

  forall (v: val) (f: CminorSel.fundef),

  Genv.find_funct ge v = Some f ->

  exists tf,

  Genv.find_funct tge v = Some tf /\ transl_fundef f = OK tf.

Proof

  (Genv.find_funct_transf_partial transl_fundef _ TRANSL).



Lemma sig_transl_function:

  forall (f: CminorSel.fundef) (tf: RTL.fundef),

  transl_fundef f = OK tf ->

  RTL.funsig tf = CminorSel.funsig f.

Proof.

  intros until tf. unfold transl_fundef, transf_partial_fundef.

  case f; intro.

  unfold transl_function.

  destruct (reserve_labels (fn_body f0) (PTree.empty node, init_state)) as [ngoto s0].

  case (transl_fun f0 ngoto s0); simpl; intros.

  discriminate.

  destruct p. simpl in H. inversion H. reflexivity.

  intro. inversion H. reflexivity.

Qed.



Lemma varinfo_preserved:

  forall b, Genv.find_var_info tge b = Genv.find_var_info ge b.

Proof

  (Genv.find_var_info_transf_partial transl_fundef _ TRANSL).



Definition globalfunction_ptr_inject (j:meminj):=

  forall b f, Genv.find_funct_ptr ge b = Some f ->

              j b = Some(b,0) /\ isGlobalBlock ge b = true.



Lemma restrict_preserves_globalfun_ptr: forall j X

  (PG : globalfunction_ptr_inject j)

  (Glob : forall b, isGlobalBlock ge b = true -> X b = true),

globalfunction_ptr_inject (restrict j X).

Proof. intros.

  red; intros.

  destruct (PG _ _ H). split; trivial.

  apply restrictI_Some; try eassumption.

  apply (Glob _ H1).

Qed.



Lemma restrict_GFP_vis: forall mu

  (GFP : globalfunction_ptr_inject (as_inj mu))

  (Glob : forall b, isGlobalBlock ge b = true ->

                    frgnBlocksSrc mu b = true),

  globalfunction_ptr_inject (restrict (as_inj mu) (vis mu)).

Proof. intros.

  unfold vis.

  eapply restrict_preserves_globalfun_ptr. eassumption.

  intuition.

Qed.



Remark val_inject_function_pointer:

  forall v fd j tv,

  Genv.find_funct ge v = Some fd ->

  globalfunction_ptr_inject j ->

  val_inject j v tv ->

  tv = v.

Proof.

  intros. exploit Genv.find_funct_inv; eauto. intros [b EQ]. subst v.

  inv H1.

  rewrite Genv.find_funct_find_funct_ptr in H.

  destruct (H0 _ _ H).

  rewrite H1 in H4; inv H4.

  rewrite Int.add_zero. trivial.

Qed.



Lemma tr_move_correct:

  forall r1 ns r2 nd cs f sp rs m,

  tr_move f.(fn_code) ns r1 nd r2 ->

  exists rs',

  corestep_star rtl_eff_sem tge

     (RTL_State cs f sp ns rs) m

     (RTL_State cs f sp nd rs') m /\

  rs'#r2 = rs#r1 /\

  (forall r, r <> r2 -> rs'#r = rs#r).

Proof.

  intros. inv H.

  exists rs; split. eapply corestep_star_zero. auto.

  exists (rs#r2 <- (rs#r1)); split.

  apply corestep_star_one. eapply rtl_corestep_exec_Iop. eauto. auto.

  split. apply Regmap.gss. intros; apply Regmap.gso; auto.

Qed.



Lemma transl_switch_correct:

  forall j cs sp e m f map r nexits t ns,

  tr_switch f.(fn_code) map r nexits t ns ->

  forall rs i act,

  rs#r = Vint i ->

  map_wf map ->

  match_env j map e nil rs ->

  comptree_match i t = Some act ->

  exists nd, exists rs',

  corestep_star rtl_eff_sem  tge (RTL_State cs f sp ns rs) m (RTL_State cs f sp nd rs') m /\

  nth_error nexits act = Some nd /\

  match_env j map e nil rs'.

Proof.

  Opaque Int.sub.

  induction 1; simpl; intros.



  inv H3. exists n; exists rs; intuition.

  apply corestep_star_zero.



  caseEq (Int.eq i key); intro EQ; rewrite EQ in H5.

  inv H5. exists nfound; exists rs; intuition.

  apply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := true); eauto.

  simpl. rewrite H2. simpl. congruence.

  exploit IHtr_switch; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply corestep_star_trans.

    eapply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := false); eauto.

      simpl. rewrite H2. simpl. congruence. eexact EX.



  caseEq (Int.ltu i key); intro EQ; rewrite EQ in H5.

  exploit IHtr_switch1; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply corestep_star_trans.

    eapply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := true); eauto.

    simpl. rewrite H2. simpl. congruence. eexact EX.

  exploit IHtr_switch2; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply corestep_star_trans.

    eapply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := false); eauto.

    simpl. rewrite H2. simpl. congruence. eexact EX.



  set (rs1 := rs#rt <- (Vint(Int.sub i ofs))).

  assert (ME1: match_env j map e nil rs1).

    unfold rs1. eauto with rtlg.

  assert (EX1: RTL_corestep tge (RTL_State cs f sp n rs) m (RTL_State cs f sp n1 rs1) m).

    eapply rtl_corestep_exec_Iop; eauto.

    predSpec Int.eq Int.eq_spec ofs Int.zero; simpl.

    rewrite H10. rewrite Int.sub_zero_l. congruence.

    rewrite H6. simpl. rewrite <- Int.sub_add_opp. auto.

  caseEq (Int.ltu (Int.sub i ofs) sz); intro EQ; rewrite EQ in H9.

  exploit H5; eauto. intros [nd [A B]].

  exists nd; exists rs1; intuition.

  eapply corestep_star_trans.

    eapply corestep_star_one. eexact EX1.

  eapply corestep_star_trans.

    eapply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := true); eauto.

    simpl. unfold rs1. rewrite Regmap.gss. simpl. congruence.

  apply corestep_star_one. eapply rtl_corestep_exec_Ijumptable; eauto. unfold rs1. apply Regmap.gss.

  exploit (IHtr_switch rs1); eauto. unfold rs1. rewrite Regmap.gso; auto.

  intros [nd [rs' [EX [NTH ME]]]].

  exists nd; exists rs'; intuition.

  eapply corestep_star_trans.

    eapply corestep_star_one. eexact EX1.

  eapply corestep_star_trans.

    eapply corestep_star_one. eapply rtl_corestep_exec_Icond with (b := false); eauto.

    simpl. unfold rs1. rewrite Regmap.gss. simpl. congruence.

  eexact EX.

Qed.



Definition sp_preserved (j:meminj) (sp sp':val) :=

    exists b b', sp = Vptr b Int.zero /\ sp' = Vptr b' Int.zero /\

                j b = Some(b',0).



Lemma shift_stack_addressing_zero: forall addr,

 shift_stack_addressing (Int.repr 0) addr = addr.

Proof. intros.

  destruct addr; try reflexivity.

  simpl. rewrite Int.add_zero_l. trivial.

Qed.



Section CORRECTNESS_EXPR.



Variable sp: val.

Variable e: env.

Variable m: mem.



Definition transl_expr_prop

     (le: letenv) (a: expr) (v: val) : Prop :=

  forall j tm cs f map pr ns nd rd rs dst

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_expr f.(fn_code) map pr a ns nd rd dst)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     corestep_star rtl_eff_sem tge

        (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' nd rs') tm'

  /\ match_env j map (set_optvar dst v e) le rs'

  /\ val_inject j v rs'#rd

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Definition transl_exprlist_prop

     (le: letenv) (al: exprlist) (vl: list val) : Prop :=

  forall j tm cs f map pr ns nd rl rs

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_exprlist f.(fn_code) map pr al ns nd rl)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     corestep_star rtl_eff_sem tge

       (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' nd rs') tm'

  /\ match_env j map e le rs'

  /\ val_list_inject j vl rs'##rl

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Definition transl_condexpr_prop

     (le: letenv) (a: condexpr) (v: bool) : Prop :=

  forall j tm cs f map pr ns ntrue nfalse rs

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_condition f.(fn_code) map pr a ns ntrue nfalse)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     corestep_plus rtl_eff_sem tge

       (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' (if v then ntrue else nfalse) rs') tm'

  /\ match_env j map e le rs'

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Lemma transl_expr_Evar_correct:

  forall (le : letenv) (id : positive) (v: val),

  e ! id = Some v ->

  transl_expr_prop le (Evar id) v.

Proof.

  intros; red; intros. inv TE.

  exploit match_env_find_var; eauto. intro EQ.

  exploit tr_move_correct; eauto. intros [rs' [A [B C]]].

  exists rs'; exists tm; split. eauto.

  destruct H2 as [[D E] | [D E]].

  

  subst r dst. simpl.

  assert (forall r, rs'#r = rs#r).

    intros. destruct (Reg.eq r rd). subst r. auto. auto.

  split. eapply match_env_invariant; eauto.

  split. congruence.

  split; auto.

  

  split.

  apply match_env_invariant with (rs#rd <- (rs#r)).

  apply match_env_update_dest; auto.

  intros. rewrite Regmap.gsspec. destruct (peq r0 rd). congruence. auto.

  split. congruence.

  split. intros. apply C. intuition congruence.

  auto.

Qed.



Lemma transl_expr_Eop_correct:

  forall (le : letenv) (op : operation) (args : exprlist)

         (vargs : list val) (v : val),

  eval_exprlist ge sp e m le args vargs ->

  transl_exprlist_prop le args vargs ->

  eval_operation ge sp op vargs m = Some v ->

  transl_expr_prop le (Eop op args) v.

Proof.

  intros; red; intros. inv TE.



  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 [EXT1 X]]]]]]]; subst tm.

  

  destruct SP as [spb [spb' [SP [SP' Jsp]]]]. subst sp sp'.

  edestruct eval_operation_inject as [v' []]; eauto.

  rewrite eval_shift_stack_operation in H2. simpl in H2. rewrite Int.add_zero in H2.



  exists (rs1#rd <- v'); exists tm1.



  split. eapply corestep_star_trans. eexact EX1.

  eapply corestep_star_one. eapply rtl_corestep_exec_Iop; eauto.

  rewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge). eauto.

  exact symbols_preserved.



  split. eauto with rtlg.



  split. rewrite Regmap.gss. auto.



  split. intros. rewrite Regmap.gso. auto. intuition congruence.



  auto.

Qed.



Lemma transl_expr_Eload_correct:

  forall (le : letenv) (chunk : memory_chunk) (addr : Op.addressing)

         (args : exprlist) (vargs : list val) (vaddr v : val),

  eval_exprlist ge sp e m le args vargs ->

  transl_exprlist_prop le args vargs ->

  Op.eval_addressing ge sp addr vargs = Some vaddr ->

  Mem.loadv chunk m vaddr = Some v ->

  transl_expr_prop le (Eload chunk addr args) v.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst tm.

  

  destruct SP as [spb [spb' [SP [SP' Jsp]]]]. subst sp sp'.

  edestruct eval_addressing_inject as [vaddr' [? ?]]; eauto.

  rewrite shift_stack_addressing_zero in H3; simpl in H3.

  edestruct Mem.loadv_inject as [v' []]; eauto.

  exists (rs1#rd <- v'); exists tm1.



  split. eapply corestep_star_trans. eexact EX1.

    eapply corestep_star_one.

      eapply rtl_corestep_exec_Iload; try eassumption.

    rewrite (eval_addressing_preserved ge). assumption.

       exact symbols_preserved.



  split. eauto with rtlg.



  split. rewrite Regmap.gss. auto.



  split. intros. rewrite Regmap.gso. auto. intuition congruence.



  auto.

Qed.



Lemma transl_expr_Econdition_correct:

  forall (le : letenv) (a: condexpr) (ifso ifnot : expr)

         (va : bool) (v : val),

  eval_condexpr ge sp e m le a va ->

  transl_condexpr_prop le a va ->

  eval_expr ge sp e m le (if va then ifso else ifnot) v ->

  transl_expr_prop le (if va then ifso else ifnot) v ->

  transl_expr_prop le (Econdition a ifso ifnot) v.

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [OTHER1 [EXT1 X]]]]]]; subst tm.

  assert (tr_expr f.(fn_code) map pr (if va then ifso else ifnot) (if va then ntrue else nfalse) nd rd dst).

    destruct va; auto.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 EXT2]]]]]].

  exists rs2; exists tm2.



  split. eapply corestep_star_trans.

           apply corestep_plus_star. eexact EX1. eexact EX2.



  split. assumption.



  split. assumption.



  split. intros. transitivity (rs1#r); auto.



  auto.

Qed.



Lemma transl_expr_Elet_correct:

  forall (le : letenv) (a1 a2 : expr) (v1 v2 : val),

  eval_expr ge sp e m le a1 v1 ->

  transl_expr_prop le a1 v1 ->

  eval_expr ge sp e m (v1 :: le) a2 v2 ->

  transl_expr_prop (v1 :: le) a2 v2 ->

  transl_expr_prop le (Elet a1 a2) v2.

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst tm.

  assert (map_wf (add_letvar map r)).

    eapply add_letvar_wf; eauto.

  exploit H2; eauto. eapply match_env_bind_letvar; eauto.

  intros [rs2 [tm2 [EX2 [ME3 [RES2 [OTHER2 EXT2]]]]]].

  exists rs2; exists tm2.



  split. eapply corestep_star_trans. eexact EX1. eexact EX2. auto.



  split. eapply match_env_unbind_letvar; eauto.



  split. assumption.



  split. intros. transitivity (rs1#r0); auto.



  auto.

Qed.



Lemma transl_expr_Eletvar_correct:

  forall (le : list val) (n : nat) (v : val),

  nth_error le n = Some v ->

  transl_expr_prop le (Eletvar n) v.

Proof.

  intros; red; intros; inv TE.

  exploit tr_move_correct; eauto. intros [rs1 [EX1 [RES1 OTHER1]]].

  exists rs1; exists tm.



  split. eexact EX1.



  split.

  destruct H2 as [[A B] | [A B]].

  subst r dst; simpl.

  apply match_env_invariant with rs. auto.

  intros. destruct (Reg.eq r rd). subst r. auto. auto.

  apply match_env_invariant with (rs#rd <- (rs#r)).

  apply match_env_update_dest; auto.

  eapply match_env_find_letvar; eauto.

  intros. rewrite Regmap.gsspec. destruct (peq r0 rd); auto.

  congruence.



  split. rewrite RES1. eapply match_env_find_letvar; eauto.



  split. intros.

  destruct H2 as [[A B] | [A B]].

  destruct (Reg.eq r0 rd); subst; auto.

  apply OTHER1. intuition congruence.



  auto.

Qed.



Lemma transl_expr_Ebuiltin_correct:

  forall le ef al vl v,

  eval_exprlist ge sp e m le al vl ->

  transl_exprlist_prop le al vl ->

  external_call ef ge vl m E0 v m ->

  transl_expr_prop le (Ebuiltin ef al) v.

Proof.

  admit. 

Qed.



Lemma transl_expr_Eexternal_correct:

  forall le id sg al b ef vl v,

  Genv.find_symbol ge id = Some b ->

  Genv.find_funct_ptr ge b = Some (External ef) ->

  ef_sig ef = sg ->

  eval_exprlist ge sp e m le al vl ->

  transl_exprlist_prop le al vl ->

  external_call ef ge vl m E0 v m ->

  transl_expr_prop le (Eexternal id sg al) v.

Proof.

  admit. 

Qed.



Lemma transl_exprlist_Enil_correct:

  forall (le : letenv),

  transl_exprlist_prop le Enil nil.

Proof.

  intros; red; intros; inv TE.

  exists rs; exists tm.

  split. apply corestep_star_zero.

  split. assumption.

  split. constructor.

  auto.

Qed.



Lemma transl_exprlist_Econs_correct:

  forall (le : letenv) (a1 : expr) (al : exprlist) (v1 : val)

         (vl : list val),

  eval_expr ge sp e m le a1 v1 ->

  transl_expr_prop le a1 v1 ->

  eval_exprlist ge sp e m le al vl ->

  transl_exprlist_prop le al vl ->

  transl_exprlist_prop le (Econs a1 al) (v1 :: vl).

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X1]]]]]]]; subst.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 [EXT2 X2]]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply corestep_star_trans. eexact EX1. eexact EX2. auto.



  split. assumption.



  split. simpl. constructor. rewrite OTHER2. auto.

  simpl; tauto.

  auto.



  split. intros. transitivity (rs1#r).

  apply OTHER2; auto. simpl; tauto.

  apply OTHER1; auto.



  auto.

Qed.



Lemma transl_condexpr_CEcond_correct:

  forall le cond al vl vb,

  eval_exprlist ge sp e m le al vl ->

  transl_exprlist_prop le al vl ->

  eval_condition cond vl m = Some vb ->

  transl_condexpr_prop le (CEcond cond al) vb.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst.

  exists rs1; exists tm1.



  split. eapply corestep_star_plus_trans. eexact EX1.

      eapply corestep_plus_one. eapply rtl_corestep_exec_Icond. eauto.

      

    eapply eval_condition_inject; eauto. auto.



  split. assumption.



  split. assumption.



  auto.

Qed.



Lemma transl_condexpr_CEcondition_correct:

  forall le a b c va v,

  eval_condexpr ge sp e m le a va ->

  transl_condexpr_prop le a va ->

  eval_condexpr ge sp e m le (if va then b else c) v ->

  transl_condexpr_prop le (if va then b else c) v ->

  transl_condexpr_prop le (CEcondition a b c) v.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [OTHER1 [EXT1 X]]]]]]; subst.

  assert (tr_condition (fn_code f) map pr (if va then b else c) (if va then n2 else n3) ntrue nfalse).

    destruct va; auto.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [OTHER2 [EXT2 X]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply corestep_plus_trans. eexact EX1. eexact EX2.



  split. assumption.



  split. intros. rewrite OTHER2; auto.



  auto.

Qed.



Lemma transl_condexpr_CElet_correct:

  forall le a b v1 v2,

  eval_expr ge sp e m le a v1 ->

  transl_expr_prop le a v1 ->

  eval_condexpr ge sp e m (v1 :: le) b v2 ->

  transl_condexpr_prop (v1 :: le) b v2 ->

  transl_condexpr_prop le (CElet a b) v2.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst.

  assert (map_wf (add_letvar map r)).

    eapply add_letvar_wf; eauto.

  exploit H2; eauto. eapply match_env_bind_letvar; eauto.

  intros [rs2 [tm2 [EX2 [ME3 [OTHER2 [EXT2 X]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply corestep_star_plus_trans. eexact EX1. eexact EX2.



  split. eapply match_env_unbind_letvar; eauto.



  split. intros. rewrite OTHER2; auto.



  auto.

Qed.



Theorem transl_expr_correct:

  forall le a v,

  eval_expr ge sp e m le a v ->

  transl_expr_prop le a v.

Proof

  (eval_expr_ind3 ge sp e m

     transl_expr_prop

     transl_exprlist_prop

     transl_condexpr_prop

     transl_expr_Evar_correct

     transl_expr_Eop_correct

     transl_expr_Eload_correct

     transl_expr_Econdition_correct

     transl_expr_Elet_correct

     transl_expr_Eletvar_correct

     transl_expr_Ebuiltin_correct

     transl_expr_Eexternal_correct

     transl_exprlist_Enil_correct

     transl_exprlist_Econs_correct

     transl_condexpr_CEcond_correct

     transl_condexpr_CEcondition_correct

     transl_condexpr_CElet_correct).



Theorem transl_exprlist_correct:

  forall le a v,

  eval_exprlist ge sp e m le a v ->

  transl_exprlist_prop le a v.

Proof

  (eval_exprlist_ind3 ge sp e m

     transl_expr_prop

     transl_exprlist_prop

     transl_condexpr_prop

     transl_expr_Evar_correct

     transl_expr_Eop_correct

     transl_expr_Eload_correct

     transl_expr_Econdition_correct

     transl_expr_Elet_correct

     transl_expr_Eletvar_correct

     transl_expr_Ebuiltin_correct

     transl_expr_Eexternal_correct

     transl_exprlist_Enil_correct

     transl_exprlist_Econs_correct

     transl_condexpr_CEcond_correct

     transl_condexpr_CEcondition_correct

     transl_condexpr_CElet_correct).



Theorem transl_condexpr_correct:

  forall le a v,

  eval_condexpr ge sp e m le a v ->

  transl_condexpr_prop le a v.

Proof

  (eval_condexpr_ind3 ge sp e m

     transl_expr_prop

     transl_exprlist_prop

     transl_condexpr_prop

     transl_expr_Evar_correct

     transl_expr_Eop_correct

     transl_expr_Eload_correct

     transl_expr_Econdition_correct

     transl_expr_Elet_correct

     transl_expr_Eletvar_correct

     transl_expr_Ebuiltin_correct

     transl_expr_Eexternal_correct

     transl_exprlist_Enil_correct

     transl_exprlist_Econs_correct

     transl_condexpr_CEcond_correct

     transl_condexpr_CEcondition_correct

     transl_condexpr_CElet_correct).



End CORRECTNESS_EXPR.



Section CORRECTNESS_EXPR_EFF.



Lemma Efftr_move_correct:

  forall r1 ns r2 nd cs f sp rs m,

  tr_move f.(fn_code) ns r1 nd r2 ->

  exists rs',

  effstep_star rtl_eff_sem tge EmptyEffect

     (RTL_State cs f sp ns rs) m

     (RTL_State cs f sp nd rs') m /\

  rs'#r2 = rs#r1 /\

  (forall r, r <> r2 -> rs'#r = rs#r).

Proof.

  intros. inv H.

  exists rs; split. eapply effstep_star_zero. auto.

  exists (rs#r2 <- (rs#r1)); split.

  apply effstep_star_one. eapply rtl_effstep_exec_Iop. eauto. auto.

  split. apply Regmap.gss. intros; apply Regmap.gso; auto.

Qed.



Lemma Efftransl_switch_correct:

  forall j cs sp e m f map r nexits t ns,

  tr_switch f.(fn_code) map r nexits t ns ->

  forall rs i act,

  rs#r = Vint i ->

  map_wf map ->

  match_env j map e nil rs ->

  comptree_match i t = Some act ->

  exists nd, exists rs',

  effstep_star rtl_eff_sem  tge EmptyEffect

        (RTL_State cs f sp ns rs) m (RTL_State cs f sp nd rs') m /\

  nth_error nexits act = Some nd /\

  match_env j map e nil rs'.

Proof.

  Opaque Int.sub.

  induction 1; simpl; intros.



  inv H3. exists n; exists rs; intuition.

  apply effstep_star_zero.



  caseEq (Int.eq i key); intro EQ; rewrite EQ in H5.

  inv H5. exists nfound; exists rs; intuition.

  apply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := true); eauto.

  simpl. rewrite H2. simpl. congruence.

  exploit IHtr_switch; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply effstep_star_trans.

    eapply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := false); eauto.

      simpl. rewrite H2. simpl. congruence. eexact EX.



  caseEq (Int.ltu i key); intro EQ; rewrite EQ in H5.

  exploit IHtr_switch1; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply effstep_star_trans.

    eapply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := true); eauto.

    simpl. rewrite H2. simpl. congruence. eexact EX.

  exploit IHtr_switch2; eauto. intros [nd1 [rs1 [EX [NTH ME]]]].

  exists nd1; exists rs1; intuition.

  eapply effstep_star_trans.

    eapply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := false); eauto.

    simpl. rewrite H2. simpl. congruence. eexact EX.



  set (rs1 := rs#rt <- (Vint(Int.sub i ofs))).

  assert (ME1: match_env j map e nil rs1).

    unfold rs1. eauto with rtlg.

  assert (EX1: RTL_effstep tge EmptyEffect (RTL_State cs f sp n rs) m (RTL_State cs f sp n1 rs1) m).

    eapply rtl_effstep_exec_Iop; eauto.

    predSpec Int.eq Int.eq_spec ofs Int.zero; simpl.

    rewrite H10. rewrite Int.sub_zero_l. congruence.

    rewrite H6. simpl. rewrite <- Int.sub_add_opp. auto.

  caseEq (Int.ltu (Int.sub i ofs) sz); intro EQ; rewrite EQ in H9.

  exploit H5; eauto. intros [nd [A B]].

  exists nd; exists rs1; intuition.

  eapply effstep_star_trans.

    eapply effstep_star_one. eexact EX1.

  eapply effstep_star_trans.

    eapply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := true); eauto.

    simpl. unfold rs1. rewrite Regmap.gss. simpl. congruence.

  apply effstep_star_one. eapply rtl_effstep_exec_Ijumptable; eauto. unfold rs1. apply Regmap.gss.

  exploit (IHtr_switch rs1); eauto. unfold rs1. rewrite Regmap.gso; auto.

  intros [nd [rs' [EX [NTH ME]]]].

  exists nd; exists rs'; intuition.

  eapply effstep_star_trans.

    eapply effstep_star_one. eexact EX1.

  eapply effstep_star_trans.

    eapply effstep_star_one. eapply rtl_effstep_exec_Icond with (b := false); eauto.

    simpl. unfold rs1. rewrite Regmap.gss. simpl. congruence.

  eexact EX.

Qed.



Variable sp: val.

Variable e: env.

Variable m: mem.



Definition Efftransl_expr_prop

     (le: letenv) (a: expr) (v: val) : Prop :=

  forall j tm cs f map pr ns nd rd rs dst

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_expr f.(fn_code) map pr a ns nd rd dst)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     effstep_star rtl_eff_sem tge EmptyEffect

        (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' nd rs') tm'

  /\ match_env j map (set_optvar dst v e) le rs'

  /\ val_inject j v rs'#rd

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Definition Efftransl_exprlist_prop

     (le: letenv) (al: exprlist) (vl: list val) : Prop :=

  forall j tm cs f map pr ns nd rl rs

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_exprlist f.(fn_code) map pr al ns nd rl)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     effstep_star rtl_eff_sem tge EmptyEffect

       (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' nd rs') tm'

  /\ match_env j map e le rs'

  /\ val_list_inject j vl rs'##rl

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Definition Efftransl_condexpr_prop

     (le: letenv) (a: condexpr) (v: bool) : Prop :=

  forall j tm cs f map pr ns ntrue nfalse rs

 (PG: meminj_preserves_globals ge j)

         sp' (SP: sp_preserved j sp sp')



    (MWF: map_wf map)

    (TE: tr_condition f.(fn_code) map pr a ns ntrue nfalse)

    (ME: match_env j map e le rs)

    (EXT: Mem.inject j m tm),

  exists rs', exists tm',

     effstep_plus rtl_eff_sem tge EmptyEffect

       (RTL_State cs f sp' ns rs) tm (RTL_State cs f sp' (if v then ntrue else nfalse) rs') tm'

  /\ match_env j map e le rs'

  /\ (forall r, In r pr -> rs'#r = rs#r)

  /\ Mem.inject j m tm' /\ tm=tm'.



Lemma Efftransl_expr_Evar_correct:

  forall (le : letenv) (id : positive) (v: val),

  e ! id = Some v ->

  Efftransl_expr_prop le (Evar id) v.

Proof.

  intros; red; intros. inv TE.

  exploit match_env_find_var; eauto. intro EQ.

  exploit Efftr_move_correct; eauto. intros [rs' [A [B C]]].

  exists rs'; exists tm; split. eauto.

  destruct H2 as [[D E] | [D E]].

  

  subst r dst. simpl.

  assert (forall r, rs'#r = rs#r).

    intros. destruct (Reg.eq r rd). subst r. auto. auto.

  split. eapply match_env_invariant; eauto.

  split. congruence.

  split; auto.

  

  split.

  apply match_env_invariant with (rs#rd <- (rs#r)).

  apply match_env_update_dest; auto.

  intros. rewrite Regmap.gsspec. destruct (peq r0 rd). congruence. auto.

  split. congruence.

  split. intros. apply C. intuition congruence.

  auto.

Qed.



Lemma Efftransl_expr_Eop_correct:

  forall (le : letenv) (op : operation) (args : exprlist)

         (vargs : list val) (v : val),

  eval_exprlist ge sp e m le args vargs ->

  Efftransl_exprlist_prop le args vargs ->

  eval_operation ge sp op vargs m = Some v ->

  Efftransl_expr_prop le (Eop op args) v.

Proof.

  intros; red; intros. inv TE.



  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 [EXT1 X]]]]]]]; subst tm.

  

  destruct SP as [spb [spb' [SP [SP' Jsp]]]]. subst sp sp'.

  edestruct eval_operation_inject as [v' []]; eauto.

  rewrite eval_shift_stack_operation in H2. simpl in H2. rewrite Int.add_zero in H2.



  exists (rs1#rd <- v'); exists tm1.



  split. eapply effstep_star_trans. eexact EX1.

  eapply effstep_star_one. eapply rtl_effstep_exec_Iop; eauto.

  rewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge). eauto.

  exact symbols_preserved.



  split. eauto with rtlg.



  split. rewrite Regmap.gss. auto.



  split. intros. rewrite Regmap.gso. auto. intuition congruence.



  auto.

Qed.



Lemma Efftransl_expr_Eload_correct:

  forall (le : letenv) (chunk : memory_chunk) (addr : Op.addressing)

         (args : exprlist) (vargs : list val) (vaddr v : val),

  eval_exprlist ge sp e m le args vargs ->

  Efftransl_exprlist_prop le args vargs ->

  Op.eval_addressing ge sp addr vargs = Some vaddr ->

  Mem.loadv chunk m vaddr = Some v ->

  Efftransl_expr_prop le (Eload chunk addr args) v.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst tm.

  

  destruct SP as [spb [spb' [SP [SP' Jsp]]]]. subst sp sp'.

  edestruct eval_addressing_inject as [vaddr' [? ?]]; eauto.

  rewrite shift_stack_addressing_zero in H3; simpl in H3.

  edestruct Mem.loadv_inject as [v' []]; eauto.

  exists (rs1#rd <- v'); exists tm1.



  split. eapply effstep_star_trans. eexact EX1.

    eapply effstep_star_one.

      eapply rtl_effstep_exec_Iload; try eassumption.

    rewrite (eval_addressing_preserved ge). assumption.

       exact symbols_preserved.



  split. eauto with rtlg.



  split. rewrite Regmap.gss. auto.



  split. intros. rewrite Regmap.gso. auto. intuition congruence.



  auto.

Qed.



Lemma Efftransl_expr_Econdition_correct:

  forall (le : letenv) (a: condexpr) (ifso ifnot : expr)

         (va : bool) (v : val),

  eval_condexpr ge sp e m le a va ->

  Efftransl_condexpr_prop le a va ->

  eval_expr ge sp e m le (if va then ifso else ifnot) v ->

  Efftransl_expr_prop le (if va then ifso else ifnot) v ->

  Efftransl_expr_prop le (Econdition a ifso ifnot) v.

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [OTHER1 [EXT1 X]]]]]]; subst tm.

  assert (tr_expr f.(fn_code) map pr (if va then ifso else ifnot) (if va then ntrue else nfalse) nd rd dst).

    destruct va; auto.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 EXT2]]]]]].

  exists rs2; exists tm2.



  split. eapply effstep_star_trans.

           apply effstep_plus_star. eexact EX1. eexact EX2.



  split. assumption.



  split. assumption.



  split. intros. transitivity (rs1#r); auto.



  auto.

Qed.



Lemma Efftransl_expr_Elet_correct:

  forall (le : letenv) (a1 a2 : expr) (v1 v2 : val),

  eval_expr ge sp e m le a1 v1 ->

  Efftransl_expr_prop le a1 v1 ->

  eval_expr ge sp e m (v1 :: le) a2 v2 ->

  Efftransl_expr_prop (v1 :: le) a2 v2 ->

  Efftransl_expr_prop le (Elet a1 a2) v2.

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst tm.

  assert (map_wf (add_letvar map r)).

    eapply add_letvar_wf; eauto.

  exploit H2; eauto. eapply match_env_bind_letvar; eauto.

  intros [rs2 [tm2 [EX2 [ME3 [RES2 [OTHER2 EXT2]]]]]].

  exists rs2; exists tm2.



  split. eapply effstep_star_trans. eexact EX1. eexact EX2. auto.



  split. eapply match_env_unbind_letvar; eauto.



  split. assumption.



  split. intros. transitivity (rs1#r0); auto.



  auto.

Qed.



Lemma Efftransl_expr_Eletvar_correct:

  forall (le : list val) (n : nat) (v : val),

  nth_error le n = Some v ->

  Efftransl_expr_prop le (Eletvar n) v.

Proof.

  intros; red; intros; inv TE.

  exploit Efftr_move_correct; eauto. intros [rs1 [EX1 [RES1 OTHER1]]].

  exists rs1; exists tm.



  split. eexact EX1.



  split.

  destruct H2 as [[A B] | [A B]].

  subst r dst; simpl.

  apply match_env_invariant with rs. auto.

  intros. destruct (Reg.eq r rd). subst r. auto. auto.

  apply match_env_invariant with (rs#rd <- (rs#r)).

  apply match_env_update_dest; auto.

  eapply match_env_find_letvar; eauto.

  intros. rewrite Regmap.gsspec. destruct (peq r0 rd); auto.

  congruence.



  split. rewrite RES1. eapply match_env_find_letvar; eauto.



  split. intros.

  destruct H2 as [[A B] | [A B]].

  destruct (Reg.eq r0 rd); subst; auto.

  apply OTHER1. intuition congruence.



  auto.

Qed.



Lemma Efftransl_expr_Ebuiltin_correct:

  forall le ef al vl v,

  eval_exprlist ge sp e m le al vl ->

  Efftransl_exprlist_prop le al vl ->

  external_call ef ge vl m E0 v m ->

  Efftransl_expr_prop le (Ebuiltin ef al) v.

Proof.

  admit. 

Qed.



Lemma Efftransl_expr_Eexternal_correct:

  forall le id sg al b ef vl v,

  Genv.find_symbol ge id = Some b ->

  Genv.find_funct_ptr ge b = Some (External ef) ->

  ef_sig ef = sg ->

  eval_exprlist ge sp e m le al vl ->

  Efftransl_exprlist_prop le al vl ->

  external_call ef ge vl m E0 v m ->

  Efftransl_expr_prop le (Eexternal id sg al) v.

Proof.

  admit. 

Qed.



Lemma Efftransl_exprlist_Enil_correct:

  forall (le : letenv),

  Efftransl_exprlist_prop le Enil nil.

Proof.

  intros; red; intros; inv TE.

  exists rs; exists tm.

  split. apply effstep_star_zero.

  split. assumption.

  split. constructor.

  auto.

Qed.



Lemma Efftransl_exprlist_Econs_correct:

  forall (le : letenv) (a1 : expr) (al : exprlist) (v1 : val)

         (vl : list val),

  eval_expr ge sp e m le a1 v1 ->

  Efftransl_expr_prop le a1 v1 ->

  eval_exprlist ge sp e m le al vl ->

  Efftransl_exprlist_prop le al vl ->

  Efftransl_exprlist_prop le (Econs a1 al) (v1 :: vl).

Proof.

  intros; red; intros; inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X1]]]]]]]; subst.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 [EXT2 X2]]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply effstep_star_trans. eexact EX1. eexact EX2. auto.



  split. assumption.



  split. simpl. constructor. rewrite OTHER2. auto.

  simpl; tauto.

  auto.



  split. intros. transitivity (rs1#r).

  apply OTHER2; auto. simpl; tauto.

  apply OTHER1; auto.



  auto.

Qed.



Lemma Efftransl_condexpr_CEcond_correct:

  forall le cond al vl vb,

  eval_exprlist ge sp e m le al vl ->

  Efftransl_exprlist_prop le al vl ->

  eval_condition cond vl m = Some vb ->

  Efftransl_condexpr_prop le (CEcond cond al) vb.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst.

  exists rs1; exists tm1.



  split. eapply effstep_star_plus_trans. eexact EX1.

      eapply effstep_plus_one. eapply rtl_effstep_exec_Icond. eauto.

      

    eapply eval_condition_inject; eauto. auto.



  split. assumption.



  split. assumption.



  auto.

Qed.



Lemma Efftransl_condexpr_CEcondition_correct:

  forall le a b c va v,

  eval_condexpr ge sp e m le a va ->

  Efftransl_condexpr_prop le a va ->

  eval_condexpr ge sp e m le (if va then b else c) v ->

  Efftransl_condexpr_prop le (if va then b else c) v ->

  Efftransl_condexpr_prop le (CEcondition a b c) v.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [OTHER1 [EXT1 X]]]]]]; subst.

  assert (tr_condition (fn_code f) map pr (if va then b else c) (if va then n2 else n3) ntrue nfalse).

    destruct va; auto.

  exploit H2; eauto. intros [rs2 [tm2 [EX2 [ME2 [OTHER2 [EXT2 X]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply effstep_plus_trans. eexact EX1. eexact EX2.



  split. assumption.



  split. intros. rewrite OTHER2; auto.



  auto.

Qed.



Lemma Efftransl_condexpr_CElet_correct:

  forall le a b v1 v2,

  eval_expr ge sp e m le a v1 ->

  Efftransl_expr_prop le a v1 ->

  eval_condexpr ge sp e m (v1 :: le) b v2 ->

  Efftransl_condexpr_prop (v1 :: le) b v2 ->

  Efftransl_condexpr_prop le (CElet a b) v2.

Proof.

  intros; red; intros. inv TE.

  exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 [EXT1 X]]]]]]]; subst.

  assert (map_wf (add_letvar map r)).

    eapply add_letvar_wf; eauto.

  exploit H2; eauto. eapply match_env_bind_letvar; eauto.

  intros [rs2 [tm2 [EX2 [ME3 [OTHER2 [EXT2 X]]]]]]; subst.

  exists rs2; exists tm2.



  split. eapply effstep_star_plus_trans. eexact EX1. eexact EX2.



  split. eapply match_env_unbind_letvar; eauto.



  split. intros. rewrite OTHER2; auto.



  auto.

Qed.



Theorem Efftransl_expr_correct:

  forall le a v,

  eval_expr ge sp e m le a v ->

  Efftransl_expr_prop le a v.

Proof

  (eval_expr_ind3 ge sp e m

     Efftransl_expr_prop

     Efftransl_exprlist_prop

     Efftransl_condexpr_prop

     Efftransl_expr_Evar_correct

     Efftransl_expr_Eop_correct

     Efftransl_expr_Eload_correct

     Efftransl_expr_Econdition_correct

     Efftransl_expr_Elet_correct

     Efftransl_expr_Eletvar_correct

     Efftransl_expr_Ebuiltin_correct

     Efftransl_expr_Eexternal_correct

     Efftransl_exprlist_Enil_correct

     Efftransl_exprlist_Econs_correct

     Efftransl_condexpr_CEcond_correct

     Efftransl_condexpr_CEcondition_correct

     Efftransl_condexpr_CElet_correct).



Theorem Efftransl_exprlist_correct:

  forall le a v,

  eval_exprlist ge sp e m le a v ->

  Efftransl_exprlist_prop le a v.

Proof

  (eval_exprlist_ind3 ge sp e m

     Efftransl_expr_prop

     Efftransl_exprlist_prop

     Efftransl_condexpr_prop

     Efftransl_expr_Evar_correct

     Efftransl_expr_Eop_correct

     Efftransl_expr_Eload_correct

     Efftransl_expr_Econdition_correct

     Efftransl_expr_Elet_correct

     Efftransl_expr_Eletvar_correct

     Efftransl_expr_Ebuiltin_correct

     Efftransl_expr_Eexternal_correct

     Efftransl_exprlist_Enil_correct

     Efftransl_exprlist_Econs_correct

     Efftransl_condexpr_CEcond_correct

     Efftransl_condexpr_CEcondition_correct

     Efftransl_condexpr_CElet_correct).



Theorem Efftransl_condexpr_correct:

  forall le a v,

  eval_condexpr ge sp e m le a v ->

  Efftransl_condexpr_prop le a v.

Proof

  (eval_condexpr_ind3 ge sp e m

     Efftransl_expr_prop

     Efftransl_exprlist_prop

     Efftransl_condexpr_prop

     Efftransl_expr_Evar_correct

     Efftransl_expr_Eop_correct

     Efftransl_expr_Eload_correct

     Efftransl_expr_Econdition_correct

     Efftransl_expr_Elet_correct

     Efftransl_expr_Eletvar_correct

     Efftransl_expr_Ebuiltin_correct

     Efftransl_expr_Eexternal_correct

     Efftransl_exprlist_Enil_correct

     Efftransl_exprlist_Econs_correct

     Efftransl_condexpr_CEcond_correct

     Efftransl_condexpr_CEcondition_correct

     Efftransl_condexpr_CElet_correct).



End CORRECTNESS_EXPR_EFF.



Open Local Scope nat_scope.



Fixpoint size_stmt (s: stmt) : nat :=

  match s with

  | Sskip => 0

  | Sseq s1 s2 => (size_stmt s1 + size_stmt s2 + 1)

  | Sifthenelse c s1 s2 => (size_stmt s1 + size_stmt s2 + 1)

  | Sloop s1 => (size_stmt s1 + 1)

  | Sblock s1 => (size_stmt s1 + 1)

  | Sexit n => 0

  | Slabel lbl s1 => (size_stmt s1 + 1)

  | _ => 1

  end.



Fixpoint size_cont (k: cont) : nat :=

  match k with

  | Kseq s k1 => (size_stmt s + size_cont k1 + 1)

  | Kblock k1 => (size_cont k1 + 1)

  | _ => 0%nat

  end.



Definition measure_state (S: CMinSel_core) :=

  match S with

  | CMinSel_State _ s k _ _ => (size_stmt s + size_cont k, size_stmt s)

  | _                           => (0, 0)

  end.



Definition lt_state (S1 S2: CMinSel_core) :=

  lex_ord lt lt (measure_state S1) (measure_state S2).



Lemma lt_state_intro:

  forall f1 s1 k1 sp1 e1 f2 s2 k2 sp2 e2,

  size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2

  \/ (size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2

      /\ size_stmt s1 < size_stmt s2) ->

  lt_state (CMinSel_State f1 s1 k1 sp1 e1)

           (CMinSel_State f2 s2 k2 sp2 e2).

Proof.

  intros. unfold lt_state. simpl. destruct H as [A | [A B]].

  left. auto.

  rewrite A. right. auto.

Qed.



Ltac Lt_state :=

  apply lt_state_intro; simpl; try omega.



Require Import Wellfounded.



Lemma lt_state_wf:

  well_founded lt_state.

Proof.

  unfold lt_state. apply wf_inverse_image with (f := measure_state).

  apply wf_lex_ord. apply lt_wf. apply lt_wf.

Qed.



Inductive tr_fun (tf: function) (map: mapping) (f: CminorSel.function)

                     (ngoto: labelmap) (nret: node) (rret: option reg) : Prop :=

  | tr_fun_intro: forall nentry r,

      rret = ret_reg f.(CminorSel.fn_sig) r ->

      tr_stmt tf.(fn_code) map f.(fn_body) nentry nret nil ngoto nret rret ->

      tf.(fn_stacksize) = f.(fn_stackspace) ->

      tr_fun tf map f ngoto nret rret.



Inductive tr_cont (j:meminj): RTL.code -> mapping ->

                   CminorSel.cont -> node -> list node -> labelmap -> node -> option reg ->

                   list RTL.stackframe -> Prop :=

  | tr_Kseq: forall c map s k nd nexits ngoto nret rret cs n,

      tr_stmt c map s nd n nexits ngoto nret rret ->

      tr_cont j c map k n nexits ngoto nret rret cs ->

      tr_cont j c map (Kseq s k) nd nexits ngoto nret rret cs

  | tr_Kblock: forall c map k nd nexits ngoto nret rret cs,

      tr_cont j c map k nd nexits ngoto nret rret cs ->

      tr_cont j c map (Kblock k) nd (nd :: nexits) ngoto nret rret cs

  | tr_Kstop: forall c map ngoto nret rret cs,

      c!nret = Some(Ireturn rret) ->

      match_stacks j Kstop cs ->

      tr_cont j c map Kstop nret nil ngoto nret rret cs

  | tr_Kcall: forall c map optid f sp e k ngoto nret rret cs,

      c!nret = Some(Ireturn rret) ->

      match_stacks j (Kcall optid f sp e k) cs ->

      tr_cont j c map (Kcall optid f sp e k) nret nil ngoto nret rret cs



with match_stacks (j:meminj) : CminorSel.cont -> list RTL.stackframe -> Prop :=

  | match_stacks_stop:

      match_stacks j Kstop nil

  | match_stacks_call: forall optid f sp e k r tf n rs cs map nexits ngoto nret rret sp',

      map_wf map ->

      tr_fun tf map f ngoto nret rret ->

      match_env j map e nil rs ->

      reg_map_ok map r optid ->

      tr_cont j tf.(fn_code) map k n nexits ngoto nret rret cs ->

       sp_preserved j sp sp' ->

      match_stacks j (Kcall optid f sp e k) (Stackframe r tf sp' n rs :: cs).



Scheme tr_cont_ind_2 := Induction for tr_cont Sort Prop

  with match_stacks_ind_2 := Induction for match_stacks Sort Prop.

Combined Scheme tr_cont_match_stacks_mutual_ind

  from tr_cont_ind_2, match_stacks_ind_2.



Lemma tr_cont_match_stacks_inject_incr:

      forall j j' (INC: inject_incr j j'),

      (forall c map k ncont nexits ngoto nret rret cs,

         tr_cont j c map k ncont nexits ngoto nret rret cs ->

         tr_cont j' c map k ncont nexits ngoto nret rret cs) /\

       (forall k cs, match_stacks j k cs -> match_stacks j' k cs).

Proof. intros. apply tr_cont_match_stacks_mutual_ind; intros.

  econstructor; eassumption.

  econstructor; eassumption.

  econstructor; eassumption.

  econstructor; eassumption.

  econstructor; eassumption.

  econstructor; try eassumption.

     eapply match_env_inject_incr; eassumption.

     destruct s as [b [b' [B [B' SP]]]].

       apply INC in SP. exists b, b'; eauto.

Qed.

Lemma tr_cont_inject_incr:

      forall j c map k ncont nexits ngoto nret rret cs

        (TR: tr_cont j c map k ncont nexits ngoto nret rret cs)

        j' (INC: inject_incr j j'),

      tr_cont j' c map k ncont nexits ngoto nret rret cs.

Proof. intros.

       eapply tr_cont_match_stacks_inject_incr; try eassumption.

Qed.

Lemma match_stacks_inject_incr:

      forall j  k cs (MS:match_stacks j k cs)

             j' (INC: inject_incr j j'),

      match_stacks j' k cs.

Proof. intros.

       eapply tr_cont_match_stacks_inject_incr; try eassumption.

Qed.



Inductive match_states (j:meminj): CMinSel_core -> mem -> RTL_core -> mem -> Prop :=

  | match_state:

      forall f s k sp e m tm cs tf ns rs map ncont nexits ngoto nret rret sp'

        (MWF: map_wf map)

        (TS: tr_stmt tf.(fn_code) map s ns ncont nexits ngoto nret rret)

        (TF: tr_fun tf map f ngoto nret rret)

        (TK: tr_cont j tf.(fn_code) map k ncont nexits ngoto nret rret cs)

        (ME: match_env j map e nil rs)

        

        (MINJ: Mem.inject j m tm)

         (SP: sp_preserved j sp sp'),

      match_states j (CMinSel_State f s k sp e) m

                     (RTL_State cs tf sp' ns rs) tm

  | match_callstate:

      forall f args targs k m tm cs tf

        (TF: transl_fundef f = OK tf)

        (MS: match_stacks j k cs)

        

        (AINJ: val_list_inject j args targs)

        

        (MINJ: Mem.inject j m tm),

      match_states j (CMinSel_Callstate f args k) m

                     (RTL_Callstate cs tf targs) tm

  | match_returnstate:

      forall v tv k m tm cs

        (MS: match_stacks j k cs)

        

         (VINJ: val_inject j v tv)

        

        (MINJ: Mem.inject j m tm),

      match_states j (CMinSel_Returnstate v k) m

                     (RTL_Returnstate cs tv) tm.



Lemma match_stacks_call_cont:

  forall j c map k ncont nexits ngoto nret rret cs,

  tr_cont j c map k ncont nexits ngoto nret rret cs ->

  match_stacks j (call_cont k) cs /\ c!nret = Some(Ireturn rret).

Proof.

  induction 1; simpl; auto.

Qed.



Lemma tr_cont_call_cont:

  forall j c map k ncont nexits ngoto nret rret cs,

  tr_cont j c map k ncont nexits ngoto nret rret cs ->

  tr_cont j c map (call_cont k) nret nil ngoto nret rret cs.

Proof.

  induction 1; simpl; auto; econstructor; eauto.

Qed.



Lemma tr_find_label:

  forall j c map lbl n (ngoto: labelmap) nret rret s' k' cs,

  ngoto!lbl = Some n ->

  forall s k ns1 nd1 nexits1,

  find_label lbl s k = Some (s', k') ->

  tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret ->

  tr_cont j c map k nd1 nexits1 ngoto nret rret cs ->

  exists ns2, exists nd2, exists nexits2,

     c!n = Some(Inop ns2)

  /\ tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret

  /\ tr_cont j c map k' nd2 nexits2 ngoto nret rret cs.

Proof.

  induction s; intros until nexits1; simpl; try congruence.

  

  caseEq (find_label lbl s1 (Kseq s2 k)); intros.

  inv H1. inv H2. eapply IHs1; eauto. econstructor; eauto.

  inv H2. eapply IHs2; eauto.

  

  caseEq (find_label lbl s1 k); intros.

  inv H1. inv H2. eapply IHs1; eauto.

  inv H2. eapply IHs2; eauto.

  

  intros. inversion H1; subst.

  eapply IHs; eauto. econstructor; eauto. econstructor; eauto.

  

  intros. inv H1.

  eapply IHs; eauto. econstructor; eauto.

  

  destruct (ident_eq lbl l); intros.

  inv H0. inv H1.

  assert (n0 = n). change positive with node in H4. congruence. subst n0.

  exists ns1; exists nd1; exists nexits1; auto.

  inv H1. eapply IHs; eauto.

Qed.



Definition MATCH (d:CMinSel_core) mu c1 m1 c2 m2:Prop :=

  match_states (restrict (as_inj mu) (vis mu)) c1 m1 c2 m2 /\

  REACH_closed m1 (vis mu) /\

  meminj_preserves_globals ge (as_inj mu) /\

  globalfunction_ptr_inject (as_inj mu) /\

  (forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true) /\

  sm_valid mu m1 m2 /\ SM_wd mu /\ Mem.inject (as_inj mu) m1 m2.



Lemma MATCH_wd: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), SM_wd mu.

Proof. intros. eapply MC. Qed.



Lemma MATCH_RC: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), REACH_closed m1 (vis mu).

Proof. intros. eapply MC. Qed.



Lemma MATCH_restrict: forall d mu c1 m1 c2 m2 X

  (MC: MATCH d mu c1 m1 c2 m2)

  (HX: forall b : block, vis mu b = true -> X b = true)

  (RX: REACH_closed m1 X),

  MATCH d (restrict_sm mu X) c1 m1 c2 m2.

Proof. intros.

  destruct MC as [MS [RC [PG [GFP [Glob [SMV [WD INJ]]]]]]].

assert (WDR: SM_wd (restrict_sm mu X)).

   apply restrict_sm_WD; assumption.

split.

  rewrite vis_restrict_sm.

  rewrite restrict_sm_all.

  rewrite restrict_nest; intuition.

split. unfold vis.

  rewrite restrict_sm_locBlocksSrc, restrict_sm_frgnBlocksSrc.

  apply RC.

split. clear -PG Glob HX.

  eapply restrict_sm_preserves_globals; try eassumption.

  unfold vis in HX. intuition.

split. rewrite restrict_sm_all.

  eapply restrict_preserves_globalfun_ptr; try eassumption.

  unfold vis in HX. intuition.

split.

  rewrite restrict_sm_frgnBlocksSrc. apply Glob.

split.

  destruct SMV.

  split; intros.

    rewrite restrict_sm_DOM in H1.

    apply (H _ H1).

  rewrite restrict_sm_RNG in H1.

    apply (H0 _ H1).

split. assumption.

  rewrite restrict_sm_all.

  eapply inject_restrict; eassumption.

Qed.



Lemma MATCH_valid: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), sm_valid mu m1 m2.

Proof. intros. eapply MC. Qed.



Lemma MATCH_PG: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2),

  meminj_preserves_globals ge (extern_of mu) /\

  (forall b : block, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true).

Proof.

  intros.

  assert (GF: forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true).

    apply MC.

  split; trivial.

  rewrite <- match_genv_meminj_preserves_extern_iff_all; trivial.

    apply MC. apply MC.

Qed.



Lemma MATCH_initial: forall v1 v2 sig entrypoints

      (EP: In (v1, v2, sig) entrypoints)

      (entry_points_ok : forall (v1 v2 : val) (sig : signature),

                  In (v1, v2, sig) entrypoints ->

                  exists b f1 f2,

                    v1 = Vptr b Int.zero /\

                    v2 = Vptr b Int.zero /\

                    Genv.find_funct_ptr ge b = Some f1 /\

                    Genv.find_funct_ptr tge b = Some f2)

      vals1 c1 m1 j vals2 m2 (DomS DomT : block -> bool)

      (Ini: initial_core cminsel_eff_sem ge v1 vals1 = Some c1)

      (Inj: Mem.inject j m1 m2)

      (VInj: Forall2 (val_inject j) vals1 vals2)

      (PG:meminj_preserves_globals ge j)

      (R : list_norepet (map fst (prog_defs prog)))

      (J: forall b1 b2 delta, j b1 = Some (b2, delta) ->

            (DomS b1 = true /\ DomT b2 = true))

      (RCH: forall b, REACH m2

          (fun b' : block => isGlobalBlock tge b' || getBlocks vals2 b') b = true ->

          DomT b = true)

      (InitMem : exists m0 : mem, Genv.init_mem prog = Some m0

               /\ Ple (Mem.nextblock m0) (Mem.nextblock m1)

               /\ Ple (Mem.nextblock m0) (Mem.nextblock m2))

      (GDE: genvs_domain_eq ge tge)

      (HDomS: forall b : block, DomS b = true -> Mem.valid_block m1 b)

      (HDomT: forall b : block, DomT b = true -> Mem.valid_block m2 b),

exists c2,

  initial_core rtl_eff_sem tge v2 vals2 = Some c2 /\

  MATCH c1

    (initial_SM DomS DomT

       (REACH m1 (fun b : block => isGlobalBlock ge b || getBlocks vals1 b))

       (REACH m2 (fun b : block => isGlobalBlock tge b || getBlocks vals2 b))

       j) c1 m1 c2 m2.

Proof. intros.

  inversion Ini.

  unfold CMinSel_initial_core in H0. unfold ge in *. unfold tge in *.

  destruct v1; inv H0.

  remember (Int.eq_dec i Int.zero) as z; destruct z; inv H1. clear Heqz.

  remember (Genv.find_funct_ptr (Genv.globalenv prog) b) as zz; destruct zz; inv H0.

    apply eq_sym in Heqzz.

  exploit function_ptr_translated; eauto. intros [tf [FP TF]].

  exists (RTL_Callstate nil tf vals2).

  split.

    destruct (entry_points_ok _ _ _ EP) as [b0 [f1 [f2 [A [B [C D]]]]]].

    subst. inv A. rewrite C in Heqzz. inv Heqzz.

    unfold tge in FP. rewrite D in FP. inv FP.

    unfold cminsel_eff_sem, cminsel_coop_sem. simpl.

    case_eq (Int.eq_dec Int.zero Int.zero). intros ? e.

    solve[rewrite D; auto].



    intros CONTRA.

    solve[elimtype False; auto].



  destruct (core_initial_wd ge tge _ _ _ _ _ _ _  Inj

     VInj J RCH PG GDE HDomS HDomT _ (eq_refl _))

    as [AA [BB [CC [DD [EE [FF GG]]]]]].

  split.

    eapply match_callstate; try eassumption.

      constructor.

      rewrite initial_SM_as_inj.

        unfold vis, initial_SM; simpl.

        apply forall_inject_val_list_inject.

        eapply restrict_forall_vals_inject; try eassumption.

          intros. apply REACH_nil. rewrite H; intuition.

    rewrite initial_SM_as_inj.

      unfold vis, initial_SM; simpl.

      eapply inject_restrict; eassumption.

  intuition.

    rewrite match_genv_meminj_preserves_extern_iff_all.

      assumption.

      apply BB.

      apply EE.

    

    rewrite initial_SM_as_inj.

      red; intros. specialize (Genv.find_funct_ptr_not_fresh prog). intros.

         destruct InitMem as [m0 [INIT_MEM [? ?]]].

         specialize (H0 _ _ _ INIT_MEM H).

         destruct (valid_init_is_global _ R _ INIT_MEM _ H0) as [id Hid].

           destruct PG as [PGa [PGb PGc]]. split. eapply PGa; eassumption.

         unfold isGlobalBlock.

          apply orb_true_iff. left. apply genv2blocksBool_char1.

            simpl. exists id; eassumption.

    rewrite initial_SM_as_inj; assumption.

Qed.



Lemma MATCH_afterExternal: forall

      (GDE : genvs_domain_eq ge tge)

      mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'

      (MemInjMu : Mem.inject (as_inj mu) m1 m2)

      (MatchMu: MATCH st1 mu st1 m1 st2 m2)

      (AtExtSrc : at_external cminsel_eff_sem st1 = Some (e, ef_sig, vals1))

      (AtExtTgt : at_external rtl_eff_sem st2 = Some (e', ef_sig', vals2))

      (ValInjMu : Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

      (pubSrc' : block -> bool)

      (pubSrcHyp : pubSrc' =

                 (fun b : block =>

                 locBlocksSrc mu b && REACH m1 (exportedSrc mu vals1) b))

      (pubTgt' : block -> bool)

      (pubTgtHyp: pubTgt' =

                 (fun b : block =>

                 locBlocksTgt mu b && REACH m2 (exportedTgt mu vals2) b))

       nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt')

       nu' ret1 m1' ret2 m2'

       (INC: extern_incr nu nu')

       (SEP: sm_inject_separated nu nu' m1 m2)

       (WDnu': SM_wd nu')

       (SMvalNu': sm_valid nu' m1' m2')

       (MemInjNu': Mem.inject (as_inj nu') m1' m2')

       (RValInjNu': val_inject (as_inj nu') ret1 ret2)

       (FwdSrc: mem_forward m1 m1')

       (FwdTgt: mem_forward m2 m2')

       (frgnSrc' : block -> bool)

       (frgnSrcHyp: frgnSrc' =

             (fun b : block => DomSrc nu' b &&

            (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b)))

       (frgnTgt' : block -> bool)

       (frgnTgtHyp: frgnTgt' =

            (fun b : block => DomTgt nu' b &&

             (negb (locBlocksTgt nu' b) && REACH m2' (exportedTgt nu' (ret2 :: nil)) b)))

       mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

       (UnchPrivSrc: Mem.unchanged_on

               (fun b z => locBlocksSrc nu b = true /\ pubBlocksSrc nu b = false) m1 m1')

       (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),

  exists st1' st2',

  after_external cminsel_eff_sem (Some ret1) st1 =Some st1' /\

  after_external rtl_eff_sem (Some ret2) st2 = Some st2' /\

  MATCH st1' mu' st1' m1' st2' m2'.

Proof. intros.

simpl.

 destruct MatchMu as [MC [RC [PG [GFP [Glob [VAL [WDmu INJ]]]]]]].

 simpl in *. inv MC; simpl in *; inv AtExtSrc.

 destruct f; inv H0.

 destruct tf; inv AtExtTgt.

 eexists. eexists.

    split. reflexivity.

    split. reflexivity.

 simpl in *.

 inv TF.

 assert (INCvisNu': inject_incr

  (restrict (as_inj nu')

     (vis

        (replace_externs nu'

           (fun b : Values.block =>

            DomSrc nu' b &&

            (negb (locBlocksSrc nu' b) &&

             REACH m1' (exportedSrc nu' (ret1 :: nil)) b))

           (fun b : Values.block =>

            DomTgt nu' b &&

            (negb (locBlocksTgt nu' b) &&

             REACH m2' (exportedTgt nu' (ret2 :: nil)) b))))) (as_inj nu')).

      unfold vis. rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc.

      apply restrict_incr.

assert (RC': REACH_closed m1' (mapped (as_inj nu'))).

        eapply inject_REACH_closed; eassumption.

assert (PHnu': meminj_preserves_globals (Genv.globalenv prog) (as_inj nu')).

    subst. clear - INC SEP PG Glob WDmu WDnu'.

    apply meminj_preserves_genv2blocks in PG.

    destruct PG as [PGa [PGb PGc]].

    apply meminj_preserves_genv2blocks.

    split; intros.

      specialize (PGa _ H).

      apply joinI; left. apply INC.

      rewrite replace_locals_extern.

      assert (GG: isGlobalBlock ge b = true).

          unfold isGlobalBlock, ge. apply genv2blocksBool_char1 in H.

          rewrite H. trivial.

      destruct (frgnSrc _ WDmu _ (Glob _ GG)) as [bb2 [dd [FF FT2]]].

      rewrite (foreign_in_all _ _ _ _ FF) in PGa. inv PGa.

      apply foreign_in_extern; eassumption.

    split; intros. specialize (PGb _ H).

      apply joinI; left. apply INC.

      rewrite replace_locals_extern.

      assert (GG: isGlobalBlock ge b = true).

          unfold isGlobalBlock, ge. apply genv2blocksBool_char2 in H.

          rewrite H. intuition.

      destruct (frgnSrc _ WDmu _ (Glob _ GG)) as [bb2 [dd [FF FT2]]].

      rewrite (foreign_in_all _ _ _ _ FF) in PGb. inv PGb.

      apply foreign_in_extern; eassumption.

    eapply (PGc _ _ delta H). specialize (PGb _ H). clear PGa PGc.

      remember (as_inj mu b1) as d.

      destruct d; apply eq_sym in Heqd.

        destruct p.

        apply extern_incr_as_inj in INC; trivial.

        rewrite replace_locals_as_inj in INC.

        rewrite (INC _ _ _ Heqd) in H0. trivial.

      destruct SEP as [SEPa _].

        rewrite replace_locals_as_inj, replace_locals_DomSrc, replace_locals_DomTgt in SEPa.

        destruct (SEPa _ _ _ Heqd H0).

        destruct (as_inj_DomRng _ _ _ _ PGb WDmu).

        congruence.

assert (RR1: REACH_closed m1'

  (fun b : Values.block =>

   locBlocksSrc nu' b

   || DomSrc nu' b &&

      (negb (locBlocksSrc nu' b) &&

       REACH m1' (exportedSrc nu' (ret1 :: nil)) b))).

  intros b Hb. rewrite REACHAX in Hb. destruct Hb as [L HL].

  generalize dependent b.

  induction L; simpl; intros; inv HL.

     assumption.

  specialize (IHL _ H1); clear H1.

  apply orb_true_iff in IHL.

  remember (locBlocksSrc nu' b') as l.

  destruct l; apply eq_sym in Heql.

  

    clear IHL.

    remember (pubBlocksSrc nu' b') as p.

    destruct p; apply eq_sym in Heqp.

      assert (Rb': REACH m1' (mapped (as_inj nu')) b' = true).

        apply REACH_nil.

        destruct (pubSrc _ WDnu' _ Heqp) as [bb2 [dd1 [PUB PT]]].

        eapply mappedI_true.

         apply (pub_in_all _ WDnu' _ _ _ PUB).

      assert (Rb:  REACH m1' (mapped (as_inj nu')) b = true).

        eapply REACH_cons; try eassumption.

      specialize (RC' _ Rb).

      destruct (mappedD_true _ _ RC') as [[b2 d1] AI'].

      remember (locBlocksSrc nu' b) as d.

      destruct d; simpl; trivial.

      apply andb_true_iff.

      split. eapply as_inj_DomRng; try eassumption.

      eapply REACH_cons; try eassumption.

        apply REACH_nil. unfold exportedSrc.

        rewrite (pubSrc_shared _ WDnu' _ Heqp). intuition.

      destruct (UnchPrivSrc) as [UP UV]; clear UnchLOOR.

        specialize (UP b' z Cur Readable).

        specialize (UV b' z).

        destruct INC as [_ [_ [_ [_ [LCnu' [_ [PBnu' [_ [FRGnu' _]]]]]]]]].

        rewrite <- LCnu'. rewrite replace_locals_locBlocksSrc.

        rewrite <- LCnu' in Heql. rewrite replace_locals_locBlocksSrc in *.

        rewrite <- PBnu' in Heqp. rewrite replace_locals_pubBlocksSrc in *.

        clear INCvisNu'.

        rewrite Heql in *. simpl in *. intuition.

        assert (VB: Mem.valid_block m1 b').

          eapply VAL. unfold DOM, DomSrc. rewrite Heql. intuition.

        apply (H VB) in H2.

        rewrite (H0 H2) in H4. clear H H0.

        remember (locBlocksSrc mu b) as q.

        destruct q; simpl; trivial; apply eq_sym in Heqq.

        assert (Rb : REACH m1 (vis mu) b = true).

           eapply REACH_cons; try eassumption.

           apply REACH_nil. unfold vis. rewrite Heql; trivial.

        specialize (RC _ Rb). unfold vis in RC.

           rewrite Heqq in RC; simpl in *.

        rewrite replace_locals_frgnBlocksSrc in FRGnu'.

        rewrite FRGnu' in RC.

        apply andb_true_iff.

        split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ RC). intuition.

        apply REACH_nil. unfold exportedSrc.

          rewrite (frgnSrc_shared _ WDnu' _ RC). intuition.

  
    destruct IHL. congruence.

    apply andb_true_iff in H. simpl in H.

    destruct H as [DomNu' Rb'].

    clear INC SEP INCvisNu' UnchLOOR UnchPrivSrc.

    remember (locBlocksSrc nu' b) as d.

    destruct d; simpl; trivial. apply eq_sym in Heqd.

    apply andb_true_iff.

    split. assert (RET: Forall2 (val_inject (as_inj nu')) (ret1::nil) (ret2::nil)).

              constructor. assumption. constructor.

           destruct (REACH_as_inj _ WDnu' _ _ _ _ MemInjNu' RET

               _ Rb' (fun b => true)) as [b2 [d1 [AI' _]]]; trivial.

           assert (REACH m1' (mapped (as_inj nu')) b = true).

             eapply REACH_cons; try eassumption.

             apply REACH_nil. eapply mappedI_true; eassumption.

           specialize (RC' _ H).

           destruct (mappedD_true _ _ RC') as [[? ?] ?].

           eapply as_inj_DomRng; eassumption.

    eapply REACH_cons; try eassumption.



assert (RRC: REACH_closed m1' (fun b : Values.block =>

                         mapped (as_inj nu') b &&

                           (locBlocksSrc nu' b

                            || DomSrc nu' b &&

                               (negb (locBlocksSrc nu' b) &&

                           REACH m1' (exportedSrc nu' (ret1 :: nil)) b)))).

  eapply REACH_closed_intersection; eassumption.

assert (GFnu': forall b, isGlobalBlock (Genv.globalenv prog) b = true ->

               DomSrc nu' b &&

               (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b) = true).

     intros. specialize (Glob _ H).

       assert (FSRC:= extern_incr_frgnBlocksSrc _ _ INC).

          rewrite replace_locals_frgnBlocksSrc in FSRC.

       rewrite FSRC in Glob.

       rewrite (frgnBlocksSrc_locBlocksSrc _ WDnu' _ Glob).

       apply andb_true_iff; simpl.

        split.

          unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ Glob). intuition.

          apply REACH_nil. unfold exportedSrc.

          rewrite (frgnSrc_shared _ WDnu' _ Glob). intuition.

split.

  econstructor; try eassumption.

    eapply match_stacks_inject_incr; try eassumption.

    unfold vis in *.

      rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc in *.

      rewrite replace_externs_as_inj.

      clear RRC RR1 RC' PHnu' INCvisNu' UnchLOOR UnchPrivSrc.

      destruct INC. rewrite replace_locals_extern in H.

        rewrite replace_locals_frgnBlocksTgt, replace_locals_frgnBlocksSrc,

                replace_locals_pubBlocksTgt, replace_locals_pubBlocksSrc,

                replace_locals_locBlocksTgt, replace_locals_locBlocksSrc,

                replace_locals_extBlocksTgt, replace_locals_extBlocksSrc,

                replace_locals_local in H0.

        destruct H0 as [? [? [? [? [? [? [? [? ?]]]]]]]].

        red; intros. destruct (restrictD_Some _ _ _ _ _ H9); clear H9.

          apply restrictI_Some.

            apply joinI.

            destruct (joinD_Some _ _ _ _ _ H10).

              apply H in H9. left; trivial.

            destruct H9. right. rewrite H0 in H12.

              split; trivial.

              destruct (disjoint_extern_local _ WDnu' b); trivial. congruence.

          

          rewrite H3, H7 in H11.

            remember (locBlocksSrc nu' b) as d.

            destruct d; trivial; simpl in *.

            apply andb_true_iff.

            split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ H11). intuition.

               apply REACH_nil. unfold exportedSrc.

                 apply frgnSrc_shared in H11; trivial. rewrite H11; intuition.

      unfold vis. rewrite replace_externs_as_inj.

       rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc.

       eapply restrict_val_inject; try eassumption.

       intros.

        destruct (getBlocks_inject (as_inj nu') (ret1::nil) (ret2::nil))

           with (b:=b) as [bb [dd [JJ' GBbb]]]; try eassumption.

          constructor. assumption. constructor.

        remember (locBlocksSrc nu' b) as d.

        destruct d; simpl; trivial. apply andb_true_iff.

        split. eapply as_inj_DomRng; eassumption.

        apply REACH_nil. unfold exportedSrc.

           rewrite H. trivial.

unfold vis in *.

rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc,

        replace_externs_as_inj in *.

  eapply inject_mapped; try eassumption.

  eapply restrict_mapped_closed; try eassumption.



destruct (eff_after_check2 _ _ _ _ _ MemInjNu' RValInjNu'

      _ (eq_refl _) _ (eq_refl _) _ (eq_refl _) WDnu' SMvalNu').

unfold vis in *.

  rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc,

  replace_externs_as_inj in *.

intuition.



  red; intros. destruct (GFP _ _ H1). split; trivial.

  eapply extern_incr_as_inj; try eassumption.

  rewrite replace_locals_as_inj. assumption.

Qed.



Lemma MATCH_corestep: forall

       st1 m1 st1' m1'

       (CS: corestep cminsel_eff_sem ge st1 m1 st1' m1')

       st2 mu m2 (MTCH: MATCH st1 mu st1 m1 st2 m2),

exists st2' m2' mu',

  (corestep_plus rtl_eff_sem tge st2 m2 st2' m2' \/

   (corestep_star rtl_eff_sem tge st2 m2 st2' m2' /\ lt_state st1' st1))

  /\ intern_incr mu mu'

  /\ sm_inject_separated mu mu' m1 m2

  /\ sm_locally_allocated mu mu' m1 m2 m1' m2'

  /\ MATCH st1' mu' st1' m1' st2' m2'

  /\ SM_wd mu' /\ sm_valid mu' m1' m2'.

Proof. intros.

   destruct CS; intros; destruct MTCH as [MSTATE PRE]; inv MSTATE.



  inv TS. inv TK.

  eexists; exists m2, mu; split.

     right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.



  inv TS. inv TK.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. constructor.

      intuition.



  inv TS.

  assert ((fn_code tf)!ncont = Some(Ireturn rret)

          /\ match_stacks (restrict (as_inj mu) (vis mu)) k cs).

    inv TK; simpl in H; try contradiction; auto.

  destruct H1.

  assert (fn_stacksize tf = fn_stackspace f).

    inv TF. auto.

  destruct SP as [spb [spb' [X [Y Rsp]]]]; subst sp'; inv X.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  edestruct free_parallel_inject as [tm' []]; eauto.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  eexists; exists tm', mu; split.

    simpl in *; rewrite Zplus_0_r in H4. rewrite <- H3 in H4.

    left; apply corestep_plus_one.

      eapply rtl_corestep_exec_Ireturn; try eassumption.

  assert (SMV': sm_valid mu m' tm').

    split; intros;

      eapply free_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free _ _ _ _ _ H4);

          try rewrite (freshloc_free _ _ _ _ _ H0); intuition.

  econstructor. econstructor; eauto.

      intuition.

      eapply REACH_closed_free; try eassumption.

      eapply (free_free_inject _ m m' m2); try eassumption.



  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E F]]]]]]]; subst.

  eexists; eexists; exists mu; split.

    right; split. eauto. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. constructor.

      intuition.



  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_exprlist_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E F]]]]]]]; subst.

  exploit transl_expr_correct; eauto.

  intros [rs'' [tm'' [F [G [J [K [L M]]]]]]]; subst.

  destruct SP as [spb [spb' [X [Y Rsp]]]]; subst sp'; inv X.

  assert (val_list_inject (restrict (as_inj mu) (vis mu)) vl rs''##rl).

    replace (rs'' ## rl) with (rs' ## rl). auto.

    apply list_map_exten. intros. apply K. auto.

  edestruct eval_addressing_inject as [vaddr' []]; eauto.

  edestruct Mem.storev_mapped_inject as [tm''' []]; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros.

      eapply storev_valid_block_1; try eassumption.

        eapply SMV; assumption.

      eapply storev_valid_block_1; try eassumption.

        eapply SMV; assumption.

  eexists; exists tm''', mu; split.

    left; eapply corestep_star_plus_trans.

      eapply corestep_star_trans. eexact A. eexact F.

      eapply corestep_plus_one.

        eapply rtl_corestep_exec_Istore with (a := vaddr'). eauto.

        rewrite <- H4. rewrite shift_stack_addressing_zero.

        eapply eval_addressing_preserved. exact symbols_preserved.

      eassumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

        try rewrite (store_freshloc _ _ _ _ _ H2);

        try rewrite (store_freshloc _ _ _ _ _ H6); intuition.

      econstructor. econstructor; eauto. constructor.

        exists spb, spb'. split; trivial. split; trivial.

      intuition.

      

      destruct vaddr; inv H2.

        eapply REACH_Store; try eassumption.

          inv H5. destruct (restrictD_Some _ _ _ _ _ H10); trivial.

          intros b' Hb'. rewrite getBlocks_char in Hb'. destruct Hb' as [off Hoff].

                  destruct Hoff; try contradiction. subst.

                  inv J. destruct (restrictD_Some _ _ _ _ _ H11); trivial.

      assert (VaddrMu: val_inject (as_inj mu) vaddr vaddr').

        eapply val_inject_incr; try eassumption.

        apply restrict_incr.

      assert (VMu: val_inject (as_inj mu) v (rs'' # rd)).

        eapply val_inject_incr; try eassumption.

        apply restrict_incr.

      destruct (Mem.storev_mapped_inject _ _ _ _ _ _ _ _ _

          MInj H2 VaddrMu VMu) as [mm [Hmm1 Hmm2]].

      rewrite Hmm1 in H6. inv H6. assumption.



  inv TS; inv H.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit transl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst tm'.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  destruct (Genv.find_funct_inv _ _ H1) as [bb XX]; subst vf.

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  inv C. destruct (restrictD_Some _ _ _ _ _ H5). rewrite H in muBB. inv muBB.

  rewrite Int.add_zero in H3.

  eexists; eexists; exists mu; split.

    left; eapply corestep_star_plus_trans.

            eapply corestep_star_trans. eexact A. eexact E.

          eapply corestep_plus_one.

            eapply rtl_corestep_exec_Icall; eauto.

               simpl. rewrite J. rewrite <- H3. eassumption. simpl; eauto.

               apply sig_transl_function; auto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; try eassumption.

      intuition.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst m2.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  eexists; eexists; exists mu; split.

    left. eapply corestep_star_plus_trans. eexact E.

          eapply corestep_plus_one. eapply rtl_corestep_exec_Icall; eauto. simpl. rewrite symbols_preserved. rewrite H4.

             rewrite Genv.find_funct_find_funct_ptr in P. eauto.

             apply sig_transl_function; auto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; try eassumption.

      intuition.



  inv TS; inv H.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit transl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst tm'.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  exploit match_stacks_call_cont; eauto. intros [U V].

  assert (fn_stacksize tf = fn_stackspace f). inv TF; auto.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  destruct (Genv.find_funct_inv _ _ H1) as [bb XX]; subst vf.

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  inv C. destruct (restrictD_Some _ _ _ _ _ H10). rewrite H7 in muBB. inv muBB.

  rewrite Int.add_zero in H9.

  eexists; exists tm'''; exists mu; split.

    left; eapply corestep_star_plus_trans.

           eapply corestep_star_trans. eexact A. eexact E.

           eapply corestep_plus_one.

             eapply rtl_corestep_exec_Itailcall; eauto.

             simpl. rewrite J. rewrite <- H9. eassumption.

             simpl; eauto.

             apply sig_transl_function; auto.

  simpl in H2; rewrite Zplus_0_r in H2. rewrite H; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H2);

          try rewrite (freshloc_free _ _ _ _ _ H3); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst m2.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  exploit match_stacks_call_cont; eauto. intros [U V].

  assert (fn_stacksize tf = fn_stackspace f). inv TF; auto.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  eexists; exists tm''', mu; split.

    left; eapply corestep_star_plus_trans. eexact E.

          eapply corestep_plus_one.

            eapply rtl_corestep_exec_Itailcall; eauto.

             simpl. rewrite symbols_preserved. rewrite H5.

             rewrite Genv.find_funct_find_funct_ptr in P. eauto.

             apply sig_transl_function; auto.

  simpl in H2; rewrite Zplus_0_r in H2; rewrite H; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H2);

          try rewrite (freshloc_free _ _ _ _ _ H3); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.



  inv TS.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; eauto.

      intuition.



  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_condexpr_correct; eauto.

  intros [rs' [tm' [A [B [C [D ?]]]]]]; subst m2.

  eexists; exists tm', mu; split.

    left. eexact A.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

       destruct b; econstructor; eauto.

      intuition.



  inversion TS; subst.

  eexists; exists m2, mu; split.

    left. apply corestep_plus_one. eapply rtl_corestep_exec_Inop; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

       econstructor; eauto.

       econstructor; eauto.

       econstructor; eauto.

      intuition.

  

  inv TS.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  inv TS. inv TK.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  inv TS. inv TK. simpl in H0. inv H0.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  inv TS. inv TK. simpl in H0.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit validate_switch_correct; eauto. intro CTM.

  exploit transl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit transl_switch_correct; eauto. inv C. auto.

  intros [nd [rs'' [E [F G]]]].

  eexists; eexists; exists mu; split.

    right; split. eapply corestep_star_trans. eexact A. eexact E. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. constructor; eassumption.

      intuition.



  inv TS.

  exploit match_stacks_call_cont; eauto. intros [U V].

  inversion TF.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  eexists; exists tm''', mu; split.

    simpl in H0; rewrite Zplus_0_r in H0. rewrite <- H2 in H0.

    left; eapply corestep_plus_one.

            eapply rtl_corestep_exec_Ireturn; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H0);

          try rewrite (freshloc_free _ _ _ _ _ H); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.



  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit transl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E ?]]]]]]]; subst m2.

  exploit match_stacks_call_cont; eauto. intros [U V].

  inversion TF.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm'' []]; eauto.

  eexists; exists tm'', mu; split.

    simpl in H5; rewrite Zplus_0_r in H5. rewrite <- H4 in H5.

    left; eapply corestep_star_plus_trans. eexact A.

          eapply corestep_plus_one.

            eapply rtl_corestep_exec_Ireturn; eauto.

  assert (SMV': sm_valid mu m' tm'').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H0);

          try rewrite (freshloc_free _ _ _ _ _ H5); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.

  

  inv TS.

  eexists; exists m2, mu; split.

    right; split. apply corestep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.

  

  inv TS. inversion TF; subst.

  exploit tr_find_label; eauto. eapply tr_cont_call_cont; eauto.

  intros [ns2 [nd2 [nexits2 [A [B C]]]]].

  eexists; exists m2, mu; split.

    left; apply corestep_plus_one. eapply rtl_corestep_exec_Inop; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.

  

  monadInv TF. exploit transl_function_charact; eauto. intro TRF.

  inversion TRF. subst f0.

  pose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).

  pose (rs := init_regs targs rparams).

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  assert (ME: match_env (restrict (as_inj mu) (vis mu)) map2 e nil rs).

    unfold rs, e. eapply match_init_env_init_reg; eauto.

  assert (MWF: map_wf map2).

    assert (map_valid init_mapping s0) by apply init_mapping_valid.

    exploit (add_vars_valid (CminorSel.fn_params f)); eauto. intros [A B].

    eapply add_vars_wf; eauto. eapply add_vars_wf; eauto. apply init_mapping_wf.

  edestruct alloc_parallel_intern as [mu' [tm' [b' [Alloc' [MInj' [IntInc [mu'SP mu'MuR]]]]]]]; eauto; try apply Zle_refl.

  destruct mu'MuR as [A [B [C [D [E F]]]]].

  eexists. exists tm', mu'; split.

    left; apply corestep_plus_one. eapply rtl_corestep_exec_function_internal; simpl; eauto.

  assert (DomSP:= alloc_DomSrc _ _ _ SMV _ _ _ _ H).

      assert (TgtB2: DomTgt mu b' = false).

        remember (DomTgt mu b') as d.

        destruct d; trivial; apply eq_sym in Heqd.

        elim (Mem.fresh_block_alloc _ _ _ _ _ Alloc').

          apply SMV. assumption.

  assert (IncVis: inject_incr (restrict (as_inj mu) (vis mu)) (restrict (as_inj mu') (vis mu'))).

    red; intros. destruct (restrictD_Some _ _ _ _ _ H5).

         eapply restrictI_Some.

           eapply intern_incr_as_inj; try eassumption.

         eapply intern_incr_vis; eassumption.

  intuition.

  split. econstructor; try eassumption.

           econstructor; eauto.

           simpl. inversion MS; subst; econstructor; eauto.

           econstructor.

           inv MS. econstructor; try eassumption.

                     eapply match_env_inject_incr; try eassumption.

                     eapply tr_cont_inject_incr; eassumption.

                       destruct H27 as [spb [spb' [SP [SP' XX]]]].

                       exists spb, spb'; split; trivial. split; trivial.

                       eapply IncVis; eassumption.

                     eapply match_env_inject_incr; try eassumption.

           eapply inject_restrict; eassumption.

           exists sp, b'. split; trivial. split; trivial.

             eapply restrictI_Some; try eassumption.

           destruct (as_inj_DomRng _ _ _ _ mu'SP); trivial.

              unfold DomSrc in H7; unfold vis.

              remember (locBlocksSrc mu' sp) as d.

              destruct d; trivial; simpl in *; apply eq_sym in Heqd.

              assert (extBlocksSrc mu = extBlocksSrc mu') by eapply IntInc.

              rewrite <- H9 in H7. unfold DomSrc in DomSP. rewrite H7 in DomSP. apply orb_false_iff in DomSP. destruct DomSP; discriminate.

  

    intuition.

    apply meminj_preserves_incr_sep_vb with (j:=as_inj mu)(m0:=m)(tm:=m2); try eassumption.

      intros. apply as_inj_DomRng in H7.

              split; eapply SMV; eapply H7.

      assumption.

      apply intern_incr_as_inj; eassumption.

      apply sm_inject_separated_mem. assumption.

      assumption.

    red; intros. destruct (GFP _ _ H7). split; trivial.

         eapply intern_incr_as_inj; eassumption.

    assert (FF: frgnBlocksSrc mu = frgnBlocksSrc mu') by eapply IntInc.

      apply Glob in H7. rewrite <-FF; trivial.



  inv MS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  eexists; exists m2, mu; split.

    left; apply corestep_plus_one; constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      split. econstructor; eauto. constructor.

             eapply match_env_update_dest; eauto.

      intuition.

Qed.



Lemma MATCH_effcore_diagram: forall

         st1 m1 st1' m1' (U1 : block -> Z -> bool)

         (CS: effstep cminsel_eff_sem ge U1 st1 m1 st1' m1')

         st2 mu m2

         (UHyp: forall b z, U1 b z = true ->

                Mem.valid_block m1 b -> vis mu b = true)

         (MTCH: MATCH st1 mu st1 m1 st2 m2),

exists st2' m2' mu', exists U2 : block -> Z -> bool,

  (effstep_plus rtl_eff_sem tge U2 st2 m2 st2' m2' \/

      effstep_star rtl_eff_sem tge U2 st2 m2 st2' m2' /\ lt_state st1' st1)

 /\ intern_incr mu mu' /\

  sm_inject_separated mu mu' m1 m2 /\

  sm_locally_allocated mu mu' m1 m2 m1' m2' /\

  MATCH st1' mu' st1' m1' st2' m2' /\

     (forall (b : block) (ofs : Z),

      U2 b ofs = true ->

      Mem.valid_block m2 b /\

      (locBlocksTgt mu b = false ->

       exists (b1 : block) (delta1 : Z),

         foreign_of mu b1 = Some (b, delta1) /\

         U1 b1 (ofs - delta1)%Z = true /\

         Mem.perm m1 b1 (ofs - delta1) Max Nonempty)).

Proof. intros st1 m1 st1' m1' U1 CS.

   induction CS; intros.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inv TK.

  eexists; exists m2, mu; exists EmptyEffect; split.

     right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inv TK.

  eexists; exists m2, mu; exists EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. constructor.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  assert ((fn_code tf)!ncont = Some(Ireturn rret)

          /\ match_stacks (restrict (as_inj mu) (vis mu)) k cs).

    inv TK; simpl in H; try contradiction; auto.

  destruct H1.

  assert (fn_stacksize tf = fn_stackspace f).

    inv TF. auto.

  destruct SP as [spb [spb' [X [Y Rsp]]]]; subst sp'; inv X.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  edestruct free_parallel_inject as [tm' []]; eauto.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  eexists; exists tm', mu, (FreeEffect m2 0 (fn_stacksize tf) spb'); split.

    simpl in *; rewrite Zplus_0_r in H4. rewrite <- H3 in H4.

    left; eapply effstep_plus_one.

        eapply rtl_effstep_exec_Ireturn; try eassumption.

  assert (SMV': sm_valid mu m' tm').

    split; intros;

      eapply free_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free _ _ _ _ _ H4);

          try rewrite (freshloc_free _ _ _ _ _ H0); intuition.

  econstructor. econstructor; eauto.

      intuition.

      eapply REACH_closed_free; try eassumption.

      eapply (free_free_inject _ m m' m2); try eassumption.

  eapply FreeEffect_validblock; eassumption.

  rewrite H3 in H8. eapply FreeEffect_PropagateLeft; eassumption.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E F]]]]]]]; subst.

  eexists; eexists; exists mu, EmptyEffect; split.

    right; split. eassumption. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_exprlist_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E F]]]]]]]; subst.

  exploit Efftransl_expr_correct; eauto.

  intros [rs'' [tm'' [F [G [J [K [L M]]]]]]]; subst.

  destruct SP as [spb [spb' [X [Y Rsp]]]]; subst sp'; inv X.

  assert (val_list_inject (restrict (as_inj mu) (vis mu)) vl rs''##rl).

    replace (rs'' ## rl) with (rs' ## rl). auto.

    apply list_map_exten. intros. apply K. auto.

  edestruct eval_addressing_inject as [vaddr' []]; eauto.

  edestruct Mem.storev_mapped_inject as [tm''' []]; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros.

      eapply storev_valid_block_1; try eassumption.

        eapply SMV; assumption.

      eapply storev_valid_block_1; try eassumption.

        eapply SMV; assumption.

  eexists; exists tm''', mu.

    exists (StoreEffect vaddr' (encode_val chunk (rs'' # rd))).

    split. left; eapply effstep_star_plus_trans.

      eapply effstep_star_trans.

         eapply effstep_star_sub. eexact A. intuition.

         eapply effstep_star_sub. eexact F. intuition.

      eapply effstep_plus_one.

        eapply rtl_effstep_exec_Istore with (a := vaddr'). eauto.

        rewrite <- H4. rewrite shift_stack_addressing_zero.

        eapply eval_addressing_preserved. exact symbols_preserved.

      eassumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

        try rewrite (store_freshloc _ _ _ _ _ H2);

        try rewrite (store_freshloc _ _ _ _ _ H6); intuition.

      econstructor. econstructor; eauto. constructor.

        exists spb, spb'. split; trivial. split; trivial.

      intuition.

      

      destruct vaddr; inv H2.

        eapply REACH_Store; try eassumption.

          inv H5. destruct (restrictD_Some _ _ _ _ _ H10); trivial.

          intros b' Hb'. rewrite getBlocks_char in Hb'. destruct Hb' as [off Hoff].

                  destruct Hoff; try contradiction. subst.

                  inv J. destruct (restrictD_Some _ _ _ _ _ H11); trivial.

      assert (VaddrMu: val_inject (as_inj mu) vaddr vaddr').

        eapply val_inject_incr; try eassumption.

        apply restrict_incr.

      assert (VMu: val_inject (as_inj mu) v (rs'' # rd)).

        eapply val_inject_incr; try eassumption.

        apply restrict_incr.

      destruct (Mem.storev_mapped_inject _ _ _ _ _ _ _ _ _

          MInj H2 VaddrMu VMu) as [mm [Hmm1 Hmm2]].

      rewrite Hmm1 in H6. inv H6. assumption.

      destruct (StoreEffectD _ _ _ _ H8) as [i [HI OFF]]. subst.

        simpl in H6. inv H5; inv H2.

          destruct (restrictD_Some _ _ _ _ _ H12).

          destruct (as_inj_DomRng _ _ _ _ H2); trivial.

          eapply SMV. apply H11.

      eapply StoreEffect_PropagateLeft; eassumption.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS; inv H.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit Efftransl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst tm'.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  destruct (Genv.find_funct_inv _ _ H1) as [bb XX]; subst vf.

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  inv C. destruct (restrictD_Some _ _ _ _ _ H5). rewrite H in muBB. inv muBB.

  rewrite Int.add_zero in H3.

  eexists; eexists; exists mu, EmptyEffect; split.

    left; eapply effstep_star_plus_trans.

            eapply effstep_star_trans. eexact A. eexact E.

          eapply effstep_plus_one.

            eapply rtl_effstep_exec_Icall; eauto.

               simpl. rewrite J. rewrite <- H3. eassumption. simpl; eauto.

               apply sig_transl_function; auto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; try eassumption.

      intuition.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst m2.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  eexists; eexists; exists mu, EmptyEffect; split.

    left. eapply effstep_star_plus_trans. eexact E.

          eapply effstep_plus_one. eapply rtl_effstep_exec_Icall; eauto. simpl. rewrite symbols_preserved. rewrite H4.

             rewrite Genv.find_funct_find_funct_ptr in P. eauto.

             apply sig_transl_function; auto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; try eassumption.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS; inv H.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit Efftransl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst tm'.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  exploit match_stacks_call_cont; eauto. intros [U V].

  assert (fn_stacksize tf = fn_stackspace f). inv TF; auto.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  destruct (Genv.find_funct_inv _ _ H1) as [bb XX]; subst vf.

  rewrite Genv.find_funct_find_funct_ptr in H1.

  destruct (GFP _ _ H1) as [muBB isGlobalBB].

  inv C. destruct (restrictD_Some _ _ _ _ _ H10). rewrite H7 in muBB. inv muBB.

  rewrite Int.add_zero in H9.

  eexists; exists tm'''; exists mu.

    exists (FreeEffect tm'' 0 (fn_stacksize tf) spb').

    split.

    left; eapply effstep_star_plus_trans.

           eapply effstep_star_trans.

              eapply effstep_star_sub. eexact A. intuition.

              eapply effstep_star_sub. eexact E. intuition.

           eapply effstep_plus_one.

             eapply rtl_effstep_exec_Itailcall; eauto.

             simpl. rewrite J. rewrite <- H9. eassumption.

             simpl; eauto.

             apply sig_transl_function; auto.

  simpl in H2; rewrite Zplus_0_r in H2. rewrite H; eauto.

  rewrite H in *.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H2);

          try rewrite (freshloc_free _ _ _ _ _ H3); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

           eapply free_free_inject; try eassumption.

         eapply FreeEffect_validblock; eassumption.

         eapply FreeEffect_PropagateLeft; try eassumption.

  

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_exprlist_correct; eauto.

  intros [rs'' [tm'' [E [F [G [J [Y ?]]]]]]]; subst m2.

  exploit functions_translated; eauto. intros [tf' [P Q]].

  exploit match_stacks_call_cont; eauto. intros [U V].

  assert (fn_stacksize tf = fn_stackspace f). inv TF; auto.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  eexists; exists tm''', mu.

    exists (FreeEffect tm'' 0 (fn_stacksize tf) spb').

    split.

    left; eapply effstep_star_plus_trans.

            eapply effstep_star_sub. eexact E. intuition.

          eapply effstep_plus_one.

            eapply rtl_effstep_exec_Itailcall; eauto.

             simpl. rewrite symbols_preserved. rewrite H5.

             rewrite Genv.find_funct_find_funct_ptr in P. eauto.

             apply sig_transl_function; auto.

  simpl in H2; rewrite Zplus_0_r in H2; rewrite H; eauto.

  rewrite H in *.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H2);

          try rewrite (freshloc_free _ _ _ _ _ H3); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.

         eapply FreeEffect_validblock; eassumption.

         eapply FreeEffect_PropagateLeft; try eassumption.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_condexpr_correct; eauto.

  intros [rs' [tm' [A [B [C [D ?]]]]]]; subst m2.

  eexists; exists tm', mu, EmptyEffect; split.

    left. eexact A.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

       destruct b; econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inversion TS; subst.

  eexists; exists m2, mu, EmptyEffect; split.

    left. apply effstep_plus_one. eapply rtl_effstep_exec_Inop; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

       econstructor; eauto.

       econstructor; eauto.

       econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inv TK.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inv TK. simpl in H0. inv H0.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inv TK. simpl in H0.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit validate_switch_correct; eauto. intro CTM.

  exploit Efftransl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [X ?]]]]]]]; subst m2.

  exploit Efftransl_switch_correct; eauto. inv C. auto.

  intros [nd [rs'' [E [F G]]]].

  eexists; eexists; exists mu, EmptyEffect; split.

    right; split. eapply effstep_star_trans. eexact A. eexact E. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto. constructor; eassumption.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  exploit match_stacks_call_cont; eauto. intros [U V].

  inversion TF.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm''' []]; eauto.

  eexists; exists tm''', mu.

  exists (FreeEffect m2 0 (fn_stacksize tf) spb').

  split.

    simpl in H0; rewrite Zplus_0_r in H0. rewrite <- H2 in H0.

    left; eapply effstep_plus_one.

            eapply rtl_effstep_exec_Ireturn; eauto.

  assert (SMV': sm_valid mu m' tm''').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  rewrite H2 in *.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H0);

          try rewrite (freshloc_free _ _ _ _ _ H); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.

         eapply FreeEffect_validblock; eassumption.

         eapply FreeEffect_PropagateLeft; try eassumption.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit Efftransl_expr_correct; eauto.

  intros [rs' [tm' [A [B [C [D [E ?]]]]]]]; subst m2.

  exploit match_stacks_call_cont; eauto. intros [U V].

  inversion TF.

  destruct SP as [spb [spb' [SPB [SPB' Rsp]]]]; subst sp'; inv SPB.

  edestruct free_parallel_inject as [tm'' []]; eauto.

  eexists; exists tm'', mu.

  exists (FreeEffect tm' 0 (fn_stacksize tf) spb').

  split.

    simpl in H5; rewrite Zplus_0_r in H5. rewrite <- H4 in H5.

    left; eapply effstep_star_plus_trans.

             eapply effstep_star_sub. eexact A. intuition.

          eapply effstep_plus_one.

            eapply rtl_effstep_exec_Ireturn; eauto.

  assert (SMV': sm_valid mu m' tm'').

    split; intros;

      eapply Mem.valid_block_free_1; try eassumption;

      eapply SMV; assumption.

  rewrite H4 in *.

  destruct (restrictD_Some _ _ _ _ _ Rsp).

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b';

          try rewrite (freshloc_free _ _ _ _ _ H0);

          try rewrite (freshloc_free _ _ _ _ _ H5); intuition.

      econstructor. econstructor; eauto.

      intuition.

         eapply REACH_closed_free; eassumption.

         destruct (restrictD_Some _ _ _ _ _ Rsp).

           eapply free_free_inject; try eassumption.

         eapply FreeEffect_validblock; eassumption.

         eapply FreeEffect_PropagateLeft; try eassumption.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS.

  eexists; exists m2, mu, EmptyEffect; split.

    right; split. apply effstep_star_zero. Lt_state.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv TS. inversion TF; subst.

  exploit tr_find_label; eauto. eapply tr_cont_call_cont; eauto.

  intros [ns2 [nd2 [nexits2 [A [B C]]]]].

  eexists; exists m2, mu, EmptyEffect; split.

    left; apply effstep_plus_one. eapply rtl_effstep_exec_Inop; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor. econstructor; eauto.

      intuition.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  monadInv TF. exploit transl_function_charact; eauto. intro TRF.

  inversion TRF. subst f0.

  pose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).

  pose (rs := init_regs targs rparams).

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  assert (ME: match_env (restrict (as_inj mu) (vis mu)) map2 e nil rs).

    unfold rs, e. eapply match_init_env_init_reg; eauto.

  assert (MWF: map_wf map2).

    assert (map_valid init_mapping s0) by apply init_mapping_valid.

    exploit (add_vars_valid (CminorSel.fn_params f)); eauto. intros [A B].

    eapply add_vars_wf; eauto. eapply add_vars_wf; eauto. apply init_mapping_wf.

  edestruct alloc_parallel_intern as [mu' [tm' [b' [Alloc' [MInj' [IntInc [mu'SP mu'MuR]]]]]]]; eauto; try apply Zle_refl.

  destruct mu'MuR as [A [B [C [D [E F]]]]].

  eexists. exists tm', mu', EmptyEffect; split.

    left; apply effstep_plus_one. eapply rtl_effstep_exec_function_internal; simpl; eauto.

  assert (DomSP:= alloc_DomSrc _ _ _ SMV _ _ _ _ H).

      assert (TgtB2: DomTgt mu b' = false).

        remember (DomTgt mu b') as d.

        destruct d; trivial; apply eq_sym in Heqd.

        elim (Mem.fresh_block_alloc _ _ _ _ _ Alloc').

          apply SMV. assumption.

  assert (IncVis: inject_incr (restrict (as_inj mu) (vis mu)) (restrict (as_inj mu') (vis mu'))).

    red; intros. destruct (restrictD_Some _ _ _ _ _ H5).

         eapply restrictI_Some.

           eapply intern_incr_as_inj; try eassumption.

         eapply intern_incr_vis; eassumption.

  intuition.

  split. econstructor; try eassumption.

           econstructor; eauto.

           simpl. inversion MS; subst; econstructor; eauto.

           econstructor.

           inv MS. econstructor; try eassumption.

                     eapply match_env_inject_incr; try eassumption.

                     eapply tr_cont_inject_incr; eassumption.

                       destruct H27 as [spb [spb' [SP [SP' XX]]]].

                       exists spb, spb'; split; trivial. split; trivial.

                       eapply IncVis; eassumption.

                     eapply match_env_inject_incr; try eassumption.

           eapply inject_restrict; eassumption.

           exists sp, b'. split; trivial. split; trivial.

             eapply restrictI_Some; try eassumption.

           destruct (as_inj_DomRng _ _ _ _ mu'SP); trivial.

              unfold DomSrc in H7; unfold vis.

              remember (locBlocksSrc mu' sp) as d.

              destruct d; trivial; simpl in *; apply eq_sym in Heqd.

              assert (extBlocksSrc mu = extBlocksSrc mu') by eapply IntInc.

              rewrite <- H9 in H7. unfold DomSrc in DomSP. rewrite H7 in DomSP. apply orb_false_iff in DomSP. destruct DomSP; discriminate.

  

    intuition.

    apply meminj_preserves_incr_sep_vb with (j:=as_inj mu)(m0:=m)(tm:=m2); try eassumption.

      intros. apply as_inj_DomRng in H7.

              split; eapply SMV; eapply H7.

      assumption.

      apply intern_incr_as_inj; eassumption.

      apply sm_inject_separated_mem. assumption.

      assumption.

    red; intros. destruct (GFP _ _ H7). split; trivial.

         eapply intern_incr_as_inj; eassumption.

    assert (FF: frgnBlocksSrc mu = frgnBlocksSrc mu') by eapply IntInc.

      apply Glob in H7. rewrite <-FF; trivial.



  destruct MTCH as [MSTATE PRE]. inv MSTATE.

  inv MS.

  destruct PRE as [RC [PG [GFP [Glob [SMV [WD MInj]]]]]].

  eexists; exists m2, mu, EmptyEffect; split.

    left; apply effstep_plus_one; constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      split. econstructor; eauto. constructor.

             eapply match_env_update_dest; eauto.

      intuition.



  assert (EHyp: forall b z, E b z = true ->

           Mem.valid_block m b -> vis mu b = true).

     intros. eapply UHyp; eauto.

  destruct (IHCS _ _ _ EHyp MTCH) as [c2' [m2' [mu' [U2 [HH1 HH2]]]]].

  exists c2', m2', mu', U2. split; trivial.

  destruct HH2 as [? [? [? [? ?]]]].

  repeat (split; trivial).

    eapply (H4 _ _ H5).

  intros. destruct (H4 _ _ H5).

    destruct (H8 H6) as [b1 [delta [Frg [HE HP]]]]; clear H8.

    exists b1, delta. split; trivial. split; trivial.

    apply Mem.perm_valid_block in HP.

    apply H; assumption.

Qed.



Theorem transl_program_correct:

  forall (R: list_norepet (map fst (prog_defs prog)))

         entrypoints

         (entry_points_ok :

            forall v1 v2 sig,

              In (v1, v2, sig) entrypoints ->

              exists b f1 f2,

                v1 = Vptr b Int.zero

                /\ v2 = Vptr b Int.zero

                /\ Genv.find_funct_ptr ge b = Some f1

                /\ Genv.find_funct_ptr tge b = Some f2)

         (init_mem: exists m0, Genv.init_mem prog = Some m0),

SM_simulation.SM_simulation_inject cminsel_eff_sem

   rtl_eff_sem ge tge entrypoints.

Proof.

intros.

assert (GDE: genvs_domain_eq ge tge).

    unfold genvs_domain_eq, genv2blocks.

    simpl; split; intros.

     split; intros; destruct H as [id Hid].

       rewrite <- symbols_preserved in Hid.

       exists id; trivial.

     rewrite symbols_preserved in Hid.

       exists id; trivial.

    rewrite varinfo_preserved. intuition.

 apply sepcomp.effect_simulations_lemmas.inj_simulation_star_wf with

  (match_states:=MATCH) (order :=lt_state).



  assumption.



  apply MATCH_wd.



  apply MATCH_RC.



  apply MATCH_restrict.



  apply MATCH_valid.



  apply MATCH_PG.



  { intros.

    eapply (MATCH_initial _ _ _ entrypoints); eauto.

    destruct init_mem as [m0 INIT].

    exists m0; split; auto.

    unfold meminj_preserves_globals in H3.

    destruct H3 as [A [B C]].



    assert (P: forall p q, {Ple p q} + {Plt q p}).

      intros p q.

      case_eq (Pos.leb p q).

      intros TRUE.

      apply Pos.leb_le in TRUE.

      left; auto.

      intros FALSE.

      apply Pos.leb_gt in FALSE.

      right; auto.



    cut (forall b, Plt b (Mem.nextblock m0) ->

           exists id, Genv.find_symbol ge id = Some b). intro D.



    split.

    destruct (P (Mem.nextblock m0) (Mem.nextblock m1)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m1 (Mem.nextblock m1)).

      eapply Mem.valid_block_inject_1; eauto.

    clear - H8; unfold Mem.valid_block in H8.

    xomega.



    destruct (P (Mem.nextblock m0) (Mem.nextblock m2)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m2 (Mem.nextblock m2)).

      eapply Mem.valid_block_inject_2; eauto.

    clear - H8; unfold Mem.valid_block in H8.

    xomega.



    intros b LT.

    unfold ge.

    apply valid_init_is_global with (b0 := b) in INIT.

    eapply INIT; auto.

    apply R.

    apply LT. }



  { intros. destruct H as [MC [RC [PG [GFP [Glob [VAL [WD INJ]]]]]]].

    destruct c1; inv H0. destruct k; inv H1.

    inv MC. exists tv.

    split. assumption.

    split. eassumption.

    simpl. inv MS. trivial. }



  { intros. destruct H as [MC [RC [PG [GFP [Glob [VAL [WD INJ]]]]]]].

    split; trivial.

    destruct c1; inv H0. destruct f; inv H1.

    inv MC. simpl. exists targs; intuition.

      apply val_list_inject_forall_inject; eassumption.

    inv TF. trivial. }



  { apply MATCH_afterExternal. assumption. }



  { apply lt_state_wf. }



  { intros. exploit MATCH_corestep; try eassumption.

     intros [st2' [m2' [mu' [CS' X]]]].

     exists st2', m2', mu'. intuition. }



 { intros. exploit MATCH_effcore_diagram; try eassumption.

    intros [st2' [m2' [mu' [U2 [CS2 [? [? [? [? ?]]]]]]]]].

    exists st2', m2', mu'.

    repeat (split; trivial).

    exists U2. split; assumption. }

Qed.



End CORRECTNESS.

