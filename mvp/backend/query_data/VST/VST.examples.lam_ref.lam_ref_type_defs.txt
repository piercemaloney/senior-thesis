
Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)
Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)
Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Export lam_ref_type_prelim.
(* lam_ref_type_prelim:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.

Module TFP <: TY_FUNCTOR_PROP.

  Definition F : Type -> Type := fun K => addr -> option K.

  Definition f_F := f_fun addr (f_option f_identity).

  Definition other : Type := value.
End TFP.

Export TFP.

Module K := KnotHered(TFP). 
Module KL := KnotHered_Lemmas(K).

Export K.
Export KL.

Definition mtype : Type := knot.
Definition world : Type := (mtype * value)%type.

Definition world_ag : ageable world :=
  ag_prod mtype value ag_knot.
Existing Instance world_ag.

Definition knot_extends (k1 k2 : knot) : Prop :=
  match (unsquash k1, unsquash k2) with
    ((n, psi), (n', psi')) => n = n' /\ forall a, (psi a = None) \/ (psi' a = psi a)
  end.

Definition R_extends (w1 w2 : world) : Prop :=
  match (w1, w2) with
    ((k1, v1), (k2, v2)) => knot_extends k1 k2 /\ v1 = v2
  end.

Lemma knot_extends_refl : forall k, knot_extends k k.

Lemma knot_extends_trans : forall k1 k2 k3,
  knot_extends k1 k2 ->
  knot_extends k2 k3 ->
  knot_extends k1 k3.

Lemma knot_extends_age_commute1 : forall x y z,
  age x y /\ knot_extends y z -> exists y',
  knot_extends x y' /\ age y' z.

Lemma knot_extends_age_commute2 : forall x y z,
  knot_extends x y /\ age y z -> exists y',
  age x y' /\ knot_extends y' z.

Lemma R_extends_valid_rel :
  valid_rel R_extends.

Lemma R_extends_refl : reflexive _ R_extends.

Lemma R_extends_trans : transitive _ R_extends.

Definition knot_contracts := transp _ knot_extends.

Lemma knot_contracts_age_commute1 : forall x y z,
  age x y /\ knot_contracts y z -> exists y',
  knot_contracts x y' /\ age y' z.

Lemma knot_contracts_age_commute2 : forall x y z,
  knot_contracts x y /\ age y z -> exists y',
  age x y' /\ knot_contracts y' z.

Definition R_contracts := transp _ R_extends.

Lemma R_contracts_valid_rel :
  valid_rel R_contracts.

Definition extendM : modality :=
  exist _ R_extends R_extends_valid_rel.
Definition contractsM : modality :=
  exist _ R_contracts R_contracts_valid_rel.

Notation "'%' e"  := (box extendM e)(at level 30, right associativity): pred.

Lemma value_knot_laterR : forall k k' v v',
  laterR (A:=world) (k,v) (k',v') <-> clos_trans _ age k k' /\ v = v'.

Lemma value_knot_necR : forall k k' v v',
  necR (A:=world) (k,v) (k',v') <-> clos_refl_trans _ age k k' /\ v = v'.

Open Scope pred.

Definition approx_eq (n : nat) (tau1 tau2 : predicate) : Prop :=
  approx n tau1 = approx n tau2.

Lemma approx_eq_downward : forall n m p q,
  m <= n ->
  approx_eq n p q ->
  approx_eq m p q.

Lemma approx_eq_sub n P Q :
    ((|> (P <=> Q)) n -> approx_eq n P Q).

Hint Resolve R_extends_refl R_extends_trans. *)

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.
Next Obligation.
  destruct a; destruct a'.
  replace v0 with v; auto.
  assert (necR (m,v) (m0,v0)).
  apply rt_step; auto.
  rewrite value_knot_necR in H1.
  intuition.
Qed.

Lemma ty_nat_extends :
  boxy extendM ty_nat.
Proof.
  apply boxy_i.
  apply R_extends_refl.
  simpl; intros.
  destruct w; destruct w'; destruct H; subst.
  auto.
Qed.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.
Next Obligation.
  unfold age, age1 in H.
  destruct a; destruct a'.
  simpl in *.
  rewrite knot_age1 in H.
  case_eq (unsquash m); intros; rewrite H1 in H, H0.
  destruct n; try discriminate.
  inv H.
  rewrite unsquash_squash.
  simpl.
  case_eq (f l); simpl; intros; rewrite H in H0.
  unfold approx_eq in *.
  unfold fidentity_fmap.
  change (approx n (approx n p)) with
    ((approx n oo approx n) p).
  rewrite <- (approx_approx1 0).
  rewrite (approx_approx1 1).
  unfold compose; simpl.
  rewrite H0; auto.
  auto.
Qed.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.
Proof.
  intros; apply boxy_i.
  apply R_extends_refl.
  intros; simpl in *.
  destruct w; destruct w'.
  destruct H; subst; simpl in *.
  case_eq (unsquash m); intros; rewrite H1 in H0.
  case_eq (unsquash m0); intros.
  hnf in H.
  rewrite H1 in H; rewrite H2 in H.
  destruct H; subst.
  destruct (H3 l).
  rewrite H in H0; elim H0.
  rewrite H.
  auto.
Qed.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.
Next Obligation.
  destruct a; destruct a'; simpl in *.
  hnf in H; simpl in H.
  rewrite knot_age1 in H.
  case_eq (unsquash m); intros; rewrite H1 in H.
  destruct n; inv H; auto.
Qed.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).
Next Obligation.
  apply pred_hereditary with (fst a,v).
  unfold age, age1 in *; simpl in *.
  rewrite knot_age1 in *.
  destruct a; destruct a'; simpl in *.
  case_eq (unsquash m); intros; rewrite H1 in H; auto.
  destruct n; inv H; auto.
  auto.
Qed.

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.
Next Obligation.
  unfold age, age1 in H.
  simpl in H.
  rewrite knot_age1 in H.
  destruct a; destruct a'.
  simpl in *.
  case_eq (unsquash m0); intros; rewrite H1 in H.
  destruct n; try discriminate.
  inv H.
  rewrite H1 in H0.
  rewrite unsquash_squash; simpl; intros.
  spec H0 a.
  case_eq (f a); simpl; intros.
  rewrite H in H0.
  intuition.
  unfold fidentity_fmap. red.
  rewrite approx_spec. split; auto.
  apply lt_le_trans with (level (fst a')).
  apply laterR_level in H4. auto.
  destruct a'. simpl.
  hnf in H0.
  destruct H0.  hnf in H0.
  rewrite unsquash_squash in H0.
  simpl; rewrite knot_level.
  case_eq (unsquash m1); intros; rewrite H6 in H0.
  destruct H0; subst.
  simpl; auto.
  eapply pred_nec_hereditary.
  apply Rt_Rft; auto.  apply H4.
  assert ((%|> p) (m0,deref m a)); auto.
  rewrite later_commute in H5.
  eapply H5.
  hnf; apply t_step.
  unfold age, age1; simpl.
  rewrite knot_age1.
  rewrite H1; auto.
  auto.
  rewrite H in H0. auto.
Qed.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.
Proof.
  intros.
  apply derives_trans with (P >=> P'); auto.
  clear; repeat intro.
  rewrite <- fash_fash in H.
  spec H (level a').
  spec H.
  red. apply le_trans with (level y); auto.
  apply necR_level in H1. auto.
  destruct a'. simpl in *.
  eapply H; eauto.
  simpl; auto.
Qed.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.
Proof.
  intros. hnf in H.
  destruct w1. destruct w2.
  destruct H. simpl.
  hnf in H.
  do 2 rewrite knot_level.
  destruct (unsquash m). destruct (unsquash m0).
  simpl; intuition.
Qed.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.
Proof.
  intros.
  hnf; intros.
  spec H a H0.
  repeat intro.
  spec H a'0.
  eapply H; eauto.
  red. apply le_trans with (level y); auto.
  apply le_trans with (level a'); auto.
  2: apply necR_level in H2; auto.
  rewrite (extend_level _ _ H4).
  auto.
Qed.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>
          predicates_hered.diamond contractsM Q.
Proof.
  intros.
  repeat intro.
  destruct H3 as [w' [??]].
  exists w'; split; auto.
  spec H a H0.
  spec H w'.
  eapply H; eauto.
  red.
  apply le_trans with (level y); auto.
  apply le_trans with (level a'); auto.
  2: apply necR_level in H2; auto.
  simpl in H3.
  rewrite (extend_level _ _ H3).
  auto.
Qed.

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.
Proof.
  intros.
  intros w H e.
  revert w H.
  unfold expr_typeF.
  apply sub_extend.
  apply subp_allp. intro m.
  apply subp_imp.
  apply subp_refl.
  apply subp_andp.
  apply subp_allp. intro m'.
  apply subp_allp. intro e'.
  apply subp_imp.
  apply subp_refl.
  rewrite <- box_all.
  rewrite <- subp_later.
  apply box_positive.
  apply sub_contract.
  apply subp_andp.
  apply subp_refl.
  hnf; intuition.
  apply subp_refl.
Qed.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).
Proof.
  intros.
  apply prove_HOcontractive1.
  apply expr_type_sub1.
Qed.

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))
    &&
    (!!(stopped m e) --> EX H:isValue e, with_val (exp_to_val e H) (%tau)).
Proof.
  intros.
  change (expr_type e tau = expr_typeF tau (fun e => expr_type e tau) e).
  unfold expr_type at 1.
  rewrite HORec_fold_unfold.
  unfold expr_type.
  auto.
  apply expr_type_cont.
Qed.

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.
Proof.
  intros.
  unfold expr_typeF.
  apply sub_extend.
  apply subp_allp. intro m.
  apply subp_imp.
  apply subp_refl.
  apply subp_andp.
  apply subp_allp. intro m'.
  apply subp_allp. intro e'.
  apply subp_imp.
  apply subp_refl.
  apply subp_refl.
  apply subp_imp.
  apply subp_refl.
  apply subp_exp. intro H.
  apply sub_with_val.
  apply sub_extend.
  hnf; auto.
Qed.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.
Proof.
  intros.
  unfold expr_type.
  apply HORec_sub; auto.
  intros. apply expr_type_cont.
  apply expr_type_sub2.
  intros; apply expr_type_sub1.
Qed.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').
Proof.
  unfold ty_lam; intros.
  apply subp_exp; intro e.
  apply subp_exp; intro He.
  apply subp_andp.
  apply subp_refl.
  rewrite <- subp_later.
  apply derives_trans with (|>( (P' >=> P) && (Q >=> Q'))).
  rewrite box_and.
  do 2 intro; split; auto.
  apply box_positive.
  apply sub_extend.
  apply subp_allp; intro v'.
  apply subp_imp.
  apply sub_with_val.
  apply sub_extend.
  intros a H1; destruct H1; auto.
  intros a H1; destruct H1; auto.
  eapply subp_expr_type; eauto.
Qed.

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.
Proof.
  intros.
  apply derives_trans with (|>(P <=> Q)); auto.
  clear; repeat intro; destruct a'.
  simpl in H2; simpl.
  case_eq (unsquash m); intros; rewrite H3 in H2.
  generalize (refl_equal (f l)).
  case_eq (f l); intros.
  2: rewrite H4 in H2; auto.
  rewrite H4 in H2.
  unfold approx_eq in *.
  rewrite H2.
  apply approx_eq_sub.
  hnf; intros.
  spec H (level a').
  apply H.
  simpl.
  rewrite later_nat.
  apply lt_le_trans with n.
  simpl in H5.
  apply later_nat in H5. auto.
  replace n with (level m).
  apply le_trans with (level y); auto.
  apply necR_level in H1.
  auto.
  rewrite knot_level.
  rewrite H3. auto.
Qed.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.
Proof.
  intros.
  unfold ty_ref.
  apply subp_exp; intro l.
  apply subp_andp.
  apply subp_refl.
  apply subp_type_at.
  auto.
Qed.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).
Proof.
  intros. hnf; simpl.
  intros.
  spec H P Q.
  apply subp_eqp.
  apply sub_extend.
  apply eqp_subp.
  auto.
  apply sub_extend.
  apply eqp_subp2.
  auto.
Qed.

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).
Proof.
  intros.
  hnf; intros; cbv beta.
  apply subp_eqp.
  apply sub_with_val.
  apply eqp_subp.
  apply H.
  apply sub_with_val.
  apply eqp_subp2.
  apply H.
Qed.

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).
Proof.
  intros; hnf; intros; cbv beta.
  apply subp_eqp.
  do 2 intro; eapply subp_expr_type; eauto.
  eapply eqp_subp; eauto.
  do 2 intro; eapply subp_expr_type; eauto.
  eapply eqp_subp2; eauto.
Qed.

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).
Proof.
  intros; hnf; intros.
  apply subp_eqp.
  apply ty_lam_sub.
  apply box_positive.
  apply eqp_subp2; apply H.
  apply box_positive.
  apply eqp_subp; apply H0.
  apply ty_lam_sub.
  apply box_positive.
  apply eqp_subp; apply H.
  apply box_positive.
  apply eqp_subp2; apply H0.
Qed.

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).
Proof.
  intros; hnf; intros.
  cbv beta.
  apply subp_eqp; apply subp_type_at; apply box_positive.
  apply H.
  apply subp_eqp; [ apply eqp_subp2 | apply eqp_subp ]; apply H.
Qed.

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).
Proof.
  intros; unfold ty_ref.
  apply exists_contractive; intros.
  apply conj_contractive.
  repeat intro; split; repeat intro; eauto.
  apply type_at_contractive; auto.
Qed.

Lemma just_extends : forall v,
  %just v = just v.
Proof.
  intros.
  eapply boxy_i.
  apply R_extends_refl.
  intros.
  destruct w; destruct w'.
  destruct H; subst.
  auto.
Qed.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.
Proof.
  intros.
  unfold ty_ref.
  apply boxy_i.
  simpl; apply R_extends_refl.
  intros.
  revert w' H.
  apply (box_ex addr extendM).
  destruct H0 as [a [? ?]]; exists a.
  rewrite box_and; split.
  rewrite just_extends; auto.
  rewrite type_at_extends; auto.
Qed.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).
Proof.
  intros; apply pred_ext; repeat intro.
  destruct a; destruct a'.
  simpl in H0; destruct H0; subst.
  spec H (m0,v0).
  apply H.
  split; auto.
  destruct a; destruct a'.
  simpl in H0; destruct H0; subst.
  simpl in *.
  apply H; split; auto.
Qed.

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.
Proof.
  intros e tau.
  rewrite expr_type_eqn.
  rewrite box_refl_trans; auto.
Qed.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.
Proof.
  intros.
  apply boxy_i.
  simpl; apply R_extends_refl.
  revert env; induction G; destruct env; simpl; intuition.
  apply H1; auto.
  destruct w; destruct w'.
  destruct H; subst.
  destruct a'.
  destruct H0; subst.
  simpl; split; auto.
  apply knot_extends_trans with m0; auto.
  eapply IHG; eauto.
Qed.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau.
Proof.
  intros.
  apply boxy_i.
  simpl; apply R_extends_refl.
  unfold ty_lam; intros.
  destruct H0 as [e [He [? ?]]].
  exists e; exists He.
  split.
  destruct w; destruct w'; destruct H; subst.
  auto.
  rewrite <- (box_refl_trans extendM) in H1; auto.
  rewrite <- later_commute in H1.
  apply H1; auto.
Qed.
