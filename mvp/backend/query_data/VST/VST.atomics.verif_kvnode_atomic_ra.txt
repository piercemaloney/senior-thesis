Require Import VST.veric.rmaps.
Require Import VST.progs.ghosts.
From atomics Require Import general_atomics acq_rel_atomics acq_rel_SW.
(* atomics.general_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Import VST.progs.invariants.
Require Import VST.progs.fupd.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Export Ensembles.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs} {inv_names : invG}.

Section atomicity.

Lemma approx_mono: forall n P Q, (P >=> Q) (Nat.pred n) -> approx n P |-- approx n Q.

Lemma subp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P' >=> P -> G |-- Q >=> Q' ->
    G |-- ((P -* Q) >=> (P' -* Q'))%pred.

Lemma eqp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P <=> P' -> G |-- Q <=> Q' ->
    G |-- ((P -* Q) <=> (P' -* Q')).

Lemma subp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P >=> P' ->
    G |-- ((|={E1,E2}=> P) >=> |={E1,E2}=> P').

Lemma eqp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P <=> P' ->
    G |-- ((|={E1,E2}=> P) <=> |={E1,E2}=> P').

Lemma eqp_imp: forall (G : Triv) (P P' Q Q' : mpred),
       G |-- P <=> P' -> G |-- Q <=> Q' -> G |-- (P --> Q) <=> P' --> Q'.

Lemma fview_shift_nonexpansive: forall E1 E2 P Q n,
  approx n (P -* |={E1,E2}=> Q) = approx n (approx n P -* |={E1,E2}=> (approx n Q)).

Lemma emp_dup: forall P, P && emp = (P && emp) * (P && emp).

Definition atomic_shift {A B} (a : A -> mpred) Ei Eo (b : A -> B -> mpred) (Q : B -> mpred) :=
  EX P : mpred, |> P * ((|> P -* |={Eo,Ei}=> (EX x : A, a x *
    ((a x -* |={Ei,Eo}=> |> P) &&
     ALL y : B, b x y -* |={Ei,Eo}=> Q y))) && cored).

End atomicity.

End atomics.

Definition atomic_spec_type W T := ProdType (ProdType W (ArrowType (ConstType T) Mpred)) (ConstType invG).

Definition super_non_expansive_a {A W} (a : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> predicates_hered.pred rmap) :=
  forall n ts w x, approx n (a ts w x) =
  approx n (a ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x).

Definition super_non_expansive_b {A B W} (b : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> B -> predicates_hered.pred rmap) :=
  forall n ts w x y, approx n (b ts w x y) =
  approx n (b ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x y).

Definition super_non_expansive_la {W} la := forall n ts w rho,
  Forall (fun l => approx n (!! locald_denote (l ts w) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w)) rho)) la.

Definition super_non_expansive_lb {B W} lb := forall n ts w (v : B) rho,
  Forall (fun l => approx n (!! locald_denote (l ts w v) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) v) rho)) lb.

Program Definition atomic_spec {A T} W args tz la P a (t : T) lb b Ei Eo
  (Hla : super_non_expansive_la la) (HP : super_non_expansive' P) (Ha : super_non_expansive_a(A := A) a)
  (Hlb : super_non_expansive_lb lb) (Hb : super_non_expansive_b b) :=
  mk_funspec (pair args tz) cc_default (atomic_spec_type W T)
  (fun (ts: list Type) '(w, Q, inv_names) =>
    PROP ()
    (LOCALx (map (fun l => l ts w) la)
    (SEP (atomic_shift(inv_names := inv_names) (a ts w) Ei Eo (b ts w) Q; P ts w))))
  (fun (ts: list Type) '(w, Q, inv_names) => EX v : T,
    PROP () (LOCALx (map (fun l => l ts w v) lb)
    (SEP (Q v)))) _ _.

Ltac start_atomic_function :=
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH u : unit
               PRE  [] main_pre _ nil u
               POST [ tint ] main_post _ nil u) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end; unfold atomic_spec;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match x with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList (x, Q)
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax; simpl. *)
(* atomics.acq_rel_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.general_atomics.

Set Bullet Behavior "Strict Subproofs".

Parameter objective : mpred -> Prop.
Axiom emp_objective : objective emp.
Axiom data_at_objective : forall {cs : compspecs} sh t v p, objective (data_at sh t v p).
Axiom own_objective : forall {RA : Ghost} g (a : G) pp, objective (own g a pp).
Axiom prop_objective : forall P, objective (!!P).
Axiom andp_objective : forall P Q, objective P -> objective Q -> objective (P && Q).
Axiom exp_objective : forall {A} P, (forall x, objective (P x)) -> objective (EX x : A, P x).
Axiom sepcon_objective : forall P Q, objective P -> objective Q -> objective (P * Q).
Lemma sepcon_list_objective : forall P, Forall objective P -> objective (fold_right sepcon emp P).

Axiom inv_alloc : forall N E P, objective P -> |> P |-- |={E}=> invariant N P.

Corollary make_inv : forall N E P Q, P |-- Q -> objective Q -> P |-- |={E}=> invariant N Q.

Ltac prove_objective := repeat
  match goal with
  | |-objective(if _ then _ else _) => if_tac
  | |-objective(exp _) => apply exp_objective; intro
  | |-objective(ghost_ref _ _) => apply exp_objective; intro
  | |-objective(_ * _) => apply sepcon_objective
  | |-objective(_ && _) => apply andp_objective
  | |-objective(!!_) => apply prop_objective
  | |-objective(own _ _ _) => apply own_objective
  | |-objective(data_at _ _ _ _) => apply data_at_objective
  | |-objective(data_at_ _ _ _) => rewrite data_at__eq; apply data_at_objective
  | |-objective(fold_right sepcon emp _) => apply sepcon_list_objective;
        rewrite ?Forall_map, Forall_forall; intros; simpl
  | _ => try apply own_objective
  end.

Hint Resolve emp_objective data_at_objective own_objective prop_objective andp_objective exp_objective
  sepcon_objective sepcon_list_objective : objective.

Section dup.

Definition duplicable P := P |-- |==> P * P.

Lemma emp_duplicable : duplicable emp.
Hint Resolve emp_duplicable : dup.

Lemma sepcon_duplicable : forall P Q, duplicable P -> duplicable Q -> duplicable (P * Q).
Hint Resolve sepcon_duplicable : dup.

Lemma sepcon_list_duplicable : forall lP, Forall duplicable lP -> duplicable (fold_right sepcon emp lP).

Lemma list_duplicate : forall Q lP, duplicable Q ->
  fold_right sepcon emp lP * Q |-- |==> fold_right sepcon emp (map (sepcon Q) lP) * Q.

Lemma invariant_duplicable' : forall N P, duplicable (invariant N P).
Hint Resolve invariant_duplicable' : dup.

Lemma ghost_snap_duplicable : forall `{_ : PCM_order} (s : G) p, duplicable (ghost_snap s p).
Hint Resolve ghost_snap_duplicable : dup.

Lemma prop_duplicable : forall P Q, duplicable Q -> duplicable (!!P && Q).
Hint Resolve prop_duplicable : dup.

Lemma exp_duplicable : forall {A} (P : A -> mpred), (forall x, duplicable (P x)) -> duplicable (exp P).

Definition weak_dup P := weak_view_shift P (P * P).

Lemma duplicable_super_non_expansive : forall n P,
  approx n (weak_dup P) = approx n (weak_dup (approx n P)).

Lemma dup_weak_dup : forall P, duplicable P -> TT |-- weak_dup P.

End dup.

Hint Resolve emp_duplicable sepcon_duplicable invariant_duplicable' ghost_snap_duplicable prop_duplicable : dup.Section atomics.

Context {CS : compspecs}.

Section protocols.

Class protocol {state : Type} (Iread Ifull : state -> Z -> mpred) :=
  { full_read s v : Ifull s v |-- |==> Ifull s v * Iread s v; read_dup s v : duplicable (Iread s v) }.

Global Instance dup_protocol {state} (T : state -> Z -> mpred) (Ht : forall s v, duplicable (T s v)) :
  protocol T T.

Context {state : Type}.

Parameter protocol_A : val -> state -> (state -> state -> Prop) ->
  ((state -> Z -> mpred) * (state -> Z -> mpred)) -> mpred.

Context (ord : state -> state -> Prop) `{RelationClasses.PreOrder _ ord}
  (Tread Tfull : state -> Z -> mpred).

Axiom ex_protocol_A_precise : forall l ord Tread Tfull, precise (EX s : _, protocol_A l s ord (Tread, Tfull))%logic.

Corollary protocol_A_precise : forall l s ord Tread Tfull, precise (protocol_A l s ord (Tread, Tfull)).

Axiom protocol_A_nonexpansive : forall l s ord Tread1 Tfull1 Tread2 Tfull2,
  (ALL s : state, ALL v : Z, (Tread1 s v <=> Tread2 s v) && (Tfull1 s v <=> Tfull2 s v)) |--
  protocol_A l s ord (Tread1, Tfull1) <=> protocol_A l s ord (Tread2, Tfull2).

Lemma protocol_A_super_non_expansive : forall n l s ord Tread Tfull,
  approx n (protocol_A l s ord (Tread, Tfull)) =
  approx n (protocol_A l s ord (fun s v => approx n (Tread s v), fun s v => approx n (Tfull s v))).

Notation T := (Tread, Tfull).

Axiom protocol_A_duplicable : forall l s, duplicable (protocol_A l s ord T).

Axiom protocol_A_join' : forall l s1 s2,
  protocol_A l s1 ord T * protocol_A l s2 ord T |--
  EX s : _, !!(ord s1 s /\ ord s2 s) && protocol_A l s ord T.

Axiom make_protocol : forall {P : protocol Tread Tfull} l v s, repable_signed v ->
  data_at Tsh tint (vint v) l * |> Tfull s v |-- |==> protocol_A l s ord T.

Axiom protocol_A_later : forall l s,
  protocol_A l s ord (|>Tread, |>Tfull) |-- |>protocol_A l s ord T.

Axiom protocol_A_delay : forall l s,
  protocol_A l s ord T |-- protocol_A l s ord (|>Tread, |>Tfull).

End protocols.

Lemma approx_later : forall n P, approx (S n) (|> P) = |> approx n P.

Lemma approx_0 : forall P, approx 0 P = FF.

Definition OrdType s := ArrowType s (ArrowType s (ConstType Prop)).
Definition PredType s := ArrowType s (ArrowType (ConstType Z) Mpred).

Definition LA_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType
  (ConstType val) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0))))
  Mpred) (ConstType (namespace -> Prop))) (PredType (DependentType 0)).

Program Definition load_acq_spec := TYPE LA_type
  WITH l : val, s : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : Ensemble namespace, Q : _ -> Z -> mpred
  PRE [ 1%positive OF tptr tint ]
   PROP ()
   LOCAL (temp 1%positive l)
   SEP (ALL s' : _, !!(st_ord s s') --> ALL v : _,
          weak_fview_shift E E (fst T s' v * P * protocol_A l s' st_ord T) (Q s' v) && emp;
        P; protocol_A l s st_ord T)
  POST [ tint ]
   EX v : Z, EX s' : _,
   PROP (repable_signed v; st_ord s s')
   LOCAL (temp ret_temp (vint v))
   SEP (Q s' v).

Definition SR_type := ProdType (ProdType (ProdType (ProdType (ProdType (ProdType (ProdType
  (ConstType (val * Z)) (DependentType 0)) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0))))
  Mpred) (ConstType (namespace -> Prop))) Mpred.

Definition CRA_type := ProdType (ProdType (ProdType (ProdType (ProdType
  (ProdType (ProdType (ConstType (val * Z * Z)) (DependentType 0)) (OrdType (DependentType 0)))
  (ProdType (PredType (DependentType 0)) (PredType (DependentType 0)))) Mpred)
  (ConstType (namespace -> Prop))) (ArrowType (DependentType 0) Mpred))
  (PredType (DependentType 0)).

Program Definition CAS_RA_spec := TYPE CRA_type
  WITH l : val, c : Z, v : Z, s : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : _, Q : _ -> mpred, R : _ -> Z -> mpred
  PRE [ 1%positive OF tptr tint, 2%positive OF tint, 3%positive OF tint ]
   PROP (repable_signed c; repable_signed v)
   LOCAL (temp 1%positive l; temp 2%positive (vint c); temp 3%positive (vint v))
   SEP (ALL s' : _, !!(st_ord s s') --> weak_fview_shift E E (snd T s' c * P)
          (EX s'' : _, !!(st_ord s' s'') && |> snd T s'' v *
           weak_fview_shift E E (protocol_A l s'' st_ord T) (Q s'')) && emp;
        ALL s' : _, ALL v' : _, !!(st_ord s s' /\ repable_signed v' /\ v <> c) -->
          weak_fview_shift E E (|> fst T s' v' * protocol_A l s' st_ord T * P) (R s' v') && emp;
        protocol_A l s st_ord T; P)
  POST [ tint ]
   EX v' : Z, EX s' : _,
   PROP (repable_signed v'; st_ord s s')
   LOCAL (temp ret_temp (Val.of_bool (if eq_dec v' c then true else false)))

End atomics. *)
(* atomics.acq_rel_SW:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import atomics.general_atomics.
Require Import atomics.acq_rel_atomics.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs}.

Section protocols.

Context {state : Type}.

Parameter protocol_piece : share -> val -> state -> (state -> state -> Prop) ->
  ((state -> Z -> mpred) * (state -> Z -> mpred)) -> mpred.

Definition protocol_R := protocol_piece Share.bot.
Definition protocol_W := protocol_piece gsh2.

Context (ord : state -> state -> Prop) `{RelationClasses.PreOrder _ ord}
  (Tread Tfull : state -> Z -> mpred).

Axiom protocol_piece_nonexpansive : forall sh l s ord Tread1 Tfull1 Tread2 Tfull2,
  (ALL s : state, ALL v : Z, (Tread1 s v <=> Tread2 s v) && (Tfull1 s v <=> Tfull2 s v)) |--
  protocol_piece sh l s ord (Tread1, Tfull1) <=> protocol_piece sh l s ord (Tread2, Tfull2).

Lemma protocol_piece_super_non_expansive : forall n sh l s ord Tread Tfull,
  approx n (protocol_piece sh l s ord (Tread, Tfull)) =
  approx n (protocol_piece sh l s ord (fun s v => approx n (Tread s v), fun s v => approx n (Tfull s v))).

Notation T := (Tread, Tfull).

Axiom make_protocol_R : forall sh l s,
  protocol_piece sh l s ord T |-- |==> protocol_piece sh l s ord T * protocol_R l s ord T.

Corollary protocol_R_duplicable : forall l s, duplicable (protocol_R l s ord T).

Corollary protocol_W_R : forall l s,
  protocol_W l s ord T |-- |==> protocol_W l s ord T * protocol_R l s ord T.

Axiom protocol_R_absorb : forall sh l s s', sh <> Share.bot ->
  protocol_piece sh l s ord T * protocol_R l s' ord T |-- |==> !!(ord s' s) && protocol_piece sh l s ord T.

Corollary protocol_R_W : forall l s s',
  protocol_W l s ord T * protocol_R l s' ord T |-- |==> !!(ord s' s) && protocol_W l s ord T.

Axiom protocol_R_join' : forall l s1 s2,
  protocol_R l s1 ord T * protocol_R l s2 ord T |--
  EX s : _, !!(ord s1 s /\ ord s2 s) && protocol_R l s ord T.

Axiom make_protocol : forall {P : protocol Tread Tfull} l v s, repable_signed v ->
  data_at Tsh tint (vint v) l * |> Tfull s v |-- |==> protocol_W l s ord T.

Axiom protocol_piece_share_join : forall sh1 sh2 sh l s1 s2 (Hsh : sepalg.join sh1 sh2 sh)
  (Hsh1 : sh1 <> Share.bot) (Hsh2 : sh2 <> Share.bot),
  protocol_piece sh1 l s1 ord T * protocol_piece sh2 l s2 ord T =
  !!(s1 = s2) && protocol_piece sh l s1 ord T.

Axiom protocol_later : forall sh l s,
  protocol_piece sh l s ord (|>Tread, |>Tfull) |-- |>protocol_piece sh l s ord T.

Axiom protocol_delay : forall sh l s,
  protocol_piece sh l s ord T |-- protocol_piece sh l s ord (|>Tread, |>Tfull).

End protocols.

Definition OrdType s := ArrowType s (ArrowType s (ConstType Prop)).
Definition PredType s := ArrowType s (ArrowType (ConstType Z) Mpred).

Program Definition load_acq_spec := TYPE LA_type
  WITH l : val, s : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : _, Q : _ -> Z -> mpred
  PRE [ 1%positive OF tptr tint ]
   PROP ()
   LOCAL (temp 1%positive l)
   SEP (ALL s' : _, !!(st_ord s s') --> ALL v : _,
          weak_fview_shift E E (fst T s' v * P * protocol_R l s' st_ord T) (Q s' v) && emp;
        P; protocol_R l s st_ord T)
  POST [ tint ]
   EX v : Z, EX s' : _,
   PROP (repable_signed v; st_ord s s')
   LOCAL (temp ret_temp (vint v))
   SEP (Q s' v).

Program Definition store_rel_spec := TYPE SR_type
  WITH l : val, v : Z, s : _, s'' : _, st_ord : _ -> _ -> Prop, T : ((_ -> Z -> mpred) * (_ -> Z -> mpred)),
       P : mpred, E : _, Q : mpred
  PRE [ 1%positive OF tptr tint, 2%positive OF tint ]
   PROP (repable_signed v; st_ord s s'')
   LOCAL (temp 1%positive l; temp 2%positive (vint v))
   SEP (ALL v0 : Z, weak_fview_shift E E
          (P * snd T s v0 * protocol_W l s'' st_ord T) (Q * |> snd T s'' v) && emp;
        P; protocol_W l s st_ord T)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (protocol_W l s'' st_ord T; Q).

End atomics. *)
Require Import VST.progs.conclib.
Require Import atomics.maps.
(* atomics.maps:
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import RelationClasses.

Section ListMaps.

Context {A B : Type} {A_eq : EqDec A} {d : Inhabitant B}.

Definition map_Znth i (L : A -> option (list B)) k := option_map (fun v => Znth i v) (L k).

Lemma map_Znth_single : forall i (k : A) (v : list B),
  map_Znth i (singleton k v) = singleton k (Znth i v).

Lemma map_Znth_add : forall (m1 m2 : A -> option (list B)) i,
  map_Znth i (map_add m1 m2) = map_add (map_Znth i m1) (map_Znth i m2).

Lemma map_Znth_eq : forall (L : A -> option (list B)) k vs (Hlength : forall vs', L k = Some vs' -> Zlength vs' = Zlength vs)
  (Hnz : vs <> []) (Hall : forall i, 0 <= i < Zlength vs -> map_Znth i L k = Some (Znth i vs)),
  L k = Some vs.

Lemma map_Znth_upd : forall (m : A -> option (list B)) k v i,
  map_Znth i (map_upd m k v) = map_upd (map_Znth i m) k (Znth i v).

Lemma map_incl_Znth : forall (m1 m2 : A -> option (list B)) i, map_incl m1 m2 ->
  map_incl (map_Znth i m1) (map_Znth i m2).

End ListMaps.

Section Logs.

Context {B : Type}.

Definition log_latest s (v1 : Z) (v2 : B) := s v1 = Some v2 /\ forall v', v1 < v' -> s v' = None.

Lemma log_latest_singleton : forall v1 v2, log_latest (singleton v1 v2) v1 v2.

Lemma log_incl_latest : forall k1 k2 v1 v2 log1 log2 (Hincl : map_incl log1 log2)
  (Hv1 : log1 k1 = Some v1) (Hlatest : log_latest log2 k2 v2), k1 <= k2.

Lemma log_latest_upd : forall log v1 v2 v1' v2', log_latest log v1 v2 -> v1 < v1' ->
  map_incl log (map_upd log v1' v2') /\ log_latest (map_upd log v1' v2') v1' v2'.

Lemma log_latest_inj : forall log v1 v2 v1' v2' (H1 : log_latest log v1 v2) (H1' : log_latest log v1' v2'),
  v1 = v1' /\ v2 = v2'.

Lemma log_latest_add : forall m1 m2 k1 k2 (v1 v2 : B)
  (Hlatest1 : log_latest m1 k1 v1) (Hlatest2 : log_latest m2 k2 v2),
  log_latest (map_add m1 m2) (Z.max k1 k2) (if zlt k1 k2 then v2 else v1).

Lemma log_latest_upd_list : forall l (m : Z -> option B) k v k' v' (Hm : log_latest m k v)
  (Hlast : last l (k, v) = (k', v')) (Hlt : k <= k') (Hordered : Forall (fun '(k, v) => k <= k') l),
  log_latest (map_upd_list m l) k' v'.

End Logs.

Lemma map_Znth_log_latest : forall {B} {d : Inhabitant B} m k (v : list B) i, log_latest m k v ->
  log_latest (map_Znth i m) k (Znth i v). *)
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import atomics.kvnode_atomic_ra.
(* atomics.kvnode_atomic_ra:
From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats AST Ctypes Cop Clight Clightdefs.
Local Open Scope Z_scope.

Definition ___builtin_annot : ident := 10%positive.
Definition ___builtin_annot_intval : ident := 11%positive.
Definition ___builtin_bswap : ident := 4%positive.
Definition ___builtin_bswap16 : ident := 6%positive.
Definition ___builtin_bswap32 : ident := 5%positive.
Definition ___builtin_bswap64 : ident := 36%positive.
Definition ___builtin_clz : ident := 37%positive.
Definition ___builtin_clzl : ident := 38%positive.
Definition ___builtin_clzll : ident := 39%positive.
Definition ___builtin_ctz : ident := 40%positive.
Definition ___builtin_ctzl : ident := 41%positive.
Definition ___builtin_ctzll : ident := 42%positive.
Definition ___builtin_debug : ident := 54%positive.
Definition ___builtin_fabs : ident := 7%positive.
Definition ___builtin_fmadd : ident := 45%positive.
Definition ___builtin_fmax : ident := 43%positive.
Definition ___builtin_fmin : ident := 44%positive.
Definition ___builtin_fmsub : ident := 46%positive.
Definition ___builtin_fnmadd : ident := 47%positive.
Definition ___builtin_fnmsub : ident := 48%positive.
Definition ___builtin_fsqrt : ident := 8%positive.
Definition ___builtin_membar : ident := 12%positive.
Definition ___builtin_memcpy_aligned : ident := 9%positive.
Definition ___builtin_nop : ident := 53%positive.
Definition ___builtin_read16_reversed : ident := 49%positive.
Definition ___builtin_read32_reversed : ident := 50%positive.
Definition ___builtin_va_arg : ident := 14%positive.
Definition ___builtin_va_copy : ident := 15%positive.
Definition ___builtin_va_end : ident := 16%positive.
Definition ___builtin_va_start : ident := 13%positive.
Definition ___builtin_write16_reversed : ident := 51%positive.
Definition ___builtin_write32_reversed : ident := 52%positive.
Definition ___compcert_i64_dtos : ident := 21%positive.
Definition ___compcert_i64_dtou : ident := 22%positive.
Definition ___compcert_i64_sar : ident := 33%positive.
Definition ___compcert_i64_sdiv : ident := 27%positive.
Definition ___compcert_i64_shl : ident := 31%positive.
Definition ___compcert_i64_shr : ident := 32%positive.
Definition ___compcert_i64_smod : ident := 29%positive.
Definition ___compcert_i64_smulh : ident := 34%positive.
Definition ___compcert_i64_stod : ident := 23%positive.
Definition ___compcert_i64_stof : ident := 25%positive.
Definition ___compcert_i64_udiv : ident := 28%positive.
Definition ___compcert_i64_umod : ident := 30%positive.
Definition ___compcert_i64_umulh : ident := 35%positive.
Definition ___compcert_i64_utod : ident := 24%positive.
Definition ___compcert_i64_utof : ident := 26%positive.
Definition ___compcert_va_composite : ident := 20%positive.
Definition ___compcert_va_float64 : ident := 19%positive.
Definition ___compcert_va_int32 : ident := 17%positive.
Definition ___compcert_va_int64 : ident := 18%positive.
Definition _d : ident := 70%positive.
Definition _data : ident := 2%positive.
Definition _exit : ident := 55%positive.
Definition _i : ident := 65%positive.
Definition _in : ident := 69%positive.
Definition _j : ident := 73%positive.
Definition _l : ident := 66%positive.
Definition _load_acq : ident := 57%positive.
Definition _main : ident := 76%positive.
Definition _make_node : ident := 72%positive.
Definition _malloc : ident := 56%positive.
Definition _n : ident := 59%positive.
Definition _node : ident := 3%positive.
Definition _out : ident := 62%positive.
Definition _p : ident := 60%positive.
Definition _read : ident := 68%positive.
Definition _reader : ident := 75%positive.
Definition _snap : ident := 64%positive.
Definition _store_rel : ident := 58%positive.
Definition _surely_malloc : ident := 61%positive.
Definition _v : ident := 67%positive.
Definition _ver : ident := 63%positive.
Definition _version : ident := 1%positive.
Definition _write : ident := 71%positive.
Definition _writer : ident := 74%positive.
Definition _t'1 : ident := 77%positive.
Definition _t'2 : ident := 78%positive.
Definition _t'3 : ident := 79%positive.

Definition f_surely_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
      ((Etempvar _n tuint) :: nil))
    (Sset _p (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
      (Scall None (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
        ((Econst_int (Int.repr 1) tint) :: nil))
      Sskip)
    (Sreturn (Some (Etempvar _p (tptr tvoid))))))
|}.

Definition f_read := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_out, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr tint)) :: (_snap, tint) :: (_i, tint) ::
               (_l, (tptr tint)) :: (_v, tint) :: (_t'3, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _ver
        (Efield
          (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
            (Tstruct _node noattr)) _version (tptr tint)))
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint
                              cc_default))
            ((Etempvar _ver (tptr tint)) :: nil))
          (Sset _snap (Etempvar _t'1 tint)))
        (Ssequence
          (Sifthenelse (Ebinop Oand (Etempvar _snap tint)
                         (Ebinop Oeq (Econst_int (Int.repr 1) tint)
                           (Econst_int (Int.repr 1) tint) tint) tint)
            Scontinue
            Sskip)
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 8) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Sset _l
                      (Ederef
                        (Ebinop Oadd
                          (Efield
                            (Ederef
                              (Etempvar _n (tptr (Tstruct _node noattr)))
                              (Tstruct _node noattr)) _data
                            (tarray (tptr tint) 8)) (Etempvar _i tint)
                          (tptr (tptr tint))) (tptr tint)))
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil)
                                          tint cc_default))
                        ((Etempvar _l (tptr tint)) :: nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Etempvar _out (tptr tint))
                            (Etempvar _i tint) (tptr tint)) tint)
                        (Etempvar _t'2 tint)))))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Ssequence
                (Scall (Some _t'3)
                  (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint
                                    cc_default))
                  ((Etempvar _ver (tptr tint)) :: nil))
                (Sset _v (Etempvar _t'3 tint)))
              (Sifthenelse (Ebinop Oeq (Etempvar _v tint)
                             (Etempvar _snap tint) tint)
                (Sreturn None)
                Sskip)))))))
  Sskip)
|}.

Definition f_write := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_in, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr tint)) :: (_v, tint) :: (_i, tint) ::
               (_l, (tptr tint)) :: (_d, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _ver
    (Efield
      (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
        (Tstruct _node noattr)) _version (tptr tint)))
  (Ssequence
    (Ssequence
      (Scall (Some _t'1)
        (Evar _load_acq (Tfunction (Tcons (tptr tint) Tnil) tint cc_default))
        ((Etempvar _ver (tptr tint)) :: nil))
      (Sset _v (Etempvar _t'1 tint)))
    (Ssequence
      (Scall None
        (Evar _store_rel (Tfunction (Tcons (tptr tint) (Tcons tint Tnil))
                           tvoid cc_default))
        ((Etempvar _ver (tptr tint)) ::
         (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 1) tint) tint) ::
         nil))
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 8) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Sset _l
                  (Ederef
                    (Ebinop Oadd
                      (Efield
                        (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
                          (Tstruct _node noattr)) _data
                        (tarray (tptr tint) 8)) (Etempvar _i tint)
                      (tptr (tptr tint))) (tptr tint)))
                (Ssequence
                  (Sset _d
                    (Ederef
                      (Ebinop Oadd (Etempvar _in (tptr tint))
                        (Etempvar _i tint) (tptr tint)) tint))
                  (Scall None
                    (Evar _store_rel (Tfunction
                                       (Tcons (tptr tint) (Tcons tint Tnil))
                                       tvoid cc_default))
                    ((Etempvar _l (tptr tint)) :: (Etempvar _d tint) :: nil)))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Scall None
          (Evar _store_rel (Tfunction (Tcons (tptr tint) (Tcons tint Tnil))
                             tvoid cc_default))
          ((Etempvar _ver (tptr tint)) ::
           (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 2) tint)
             tint) :: nil))))))
|}.

Definition f_make_node := {|
  fn_return := (tptr (Tstruct _node noattr));
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_n, (tptr (Tstruct _node noattr))) :: (_p, (tptr tint)) ::
               (_i, tint) :: (_t'3, (tptr tvoid)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                             cc_default))
      ((Esizeof (Tstruct _node noattr) tuint) :: nil))
    (Sset _n (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Ssequence
      (Scall (Some _t'2)
        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                               cc_default)) ((Esizeof tint tuint) :: nil))
      (Sset _p (Etempvar _t'2 (tptr tvoid))))
    (Ssequence
      (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
        (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Sassign
          (Efield
            (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
              (Tstruct _node noattr)) _version (tptr tint))
          (Etempvar _p (tptr tint)))
        (Ssequence
          (Ssequence
            (Sset _i (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                               (Econst_int (Int.repr 8) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                             (tptr tvoid) cc_default))
                      ((Esizeof tint tuint) :: nil))
                    (Sset _p (Etempvar _t'3 (tptr tvoid))))
                  (Ssequence
                    (Sassign (Ederef (Etempvar _p (tptr tint)) tint)
                      (Econst_int (Int.repr 0) tint))
                    (Sassign
                      (Ederef
                        (Ebinop Oadd
                          (Efield
                            (Ederef
                              (Etempvar _n (tptr (Tstruct _node noattr)))
                              (Tstruct _node noattr)) _data
                            (tarray (tptr tint) 8)) (Etempvar _i tint)
                          (tptr (tptr tint))) (tptr tint))
                      (Etempvar _p (tptr tint))))))
              (Sset _i
                (Ebinop Oadd (Etempvar _i tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Sreturn (Some (Etempvar _n (tptr (Tstruct _node noattr))))))))))
|}.

Definition f_writer := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr tvoid)) :: nil);
  fn_vars := ((_data, (tarray tint 8)) :: nil);
  fn_temps := ((_i, tint) :: (_j, tint) :: (_v, tint) :: nil);
  fn_body :=
(Ssequence
  (Sassign
    (Ederef
      (Ebinop Oadd (Evar _data (tarray tint 8))
        (Econst_int (Int.repr 0) tint) (tptr tint)) tint)
    (Econst_int (Int.repr 0) tint))
  (Ssequence
    (Sassign
      (Ederef
        (Ebinop Oadd (Evar _data (tarray tint 8))
          (Econst_int (Int.repr 1) tint) (tptr tint)) tint)
      (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Sassign
        (Ederef
          (Ebinop Oadd (Evar _data (tarray tint 8))
            (Econst_int (Int.repr 2) tint) (tptr tint)) tint)
        (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Sassign
          (Ederef
            (Ebinop Oadd (Evar _data (tarray tint 8))
              (Econst_int (Int.repr 3) tint) (tptr tint)) tint)
          (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Sassign
            (Ederef
              (Ebinop Oadd (Evar _data (tarray tint 8))
                (Econst_int (Int.repr 4) tint) (tptr tint)) tint)
            (Econst_int (Int.repr 0) tint))
          (Ssequence
            (Sassign
              (Ederef
                (Ebinop Oadd (Evar _data (tarray tint 8))
                  (Econst_int (Int.repr 5) tint) (tptr tint)) tint)
              (Econst_int (Int.repr 0) tint))
            (Ssequence
              (Sassign
                (Ederef
                  (Ebinop Oadd (Evar _data (tarray tint 8))
                    (Econst_int (Int.repr 6) tint) (tptr tint)) tint)
                (Econst_int (Int.repr 0) tint))
              (Ssequence
                (Sassign
                  (Ederef
                    (Ebinop Oadd (Evar _data (tarray tint 8))
                      (Econst_int (Int.repr 7) tint) (tptr tint)) tint)
                  (Econst_int (Int.repr 0) tint))
                (Ssequence
                  (Ssequence
                    (Sset _i (Econst_int (Int.repr 0) tint))
                    (Sloop
                      (Ssequence
                        (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                       (Econst_int (Int.repr 3) tint) tint)
                          Sskip
                          Sbreak)
                        (Ssequence
                          (Ssequence
                            (Sset _j (Econst_int (Int.repr 0) tint))
                            (Sloop
                              (Ssequence
                                (Sifthenelse (Ebinop Olt (Etempvar _j tint)
                                               (Econst_int (Int.repr 8) tint)
                                               tint)
                                  Sskip
                                  Sbreak)
                                (Ssequence
                                  (Sset _v
                                    (Ederef
                                      (Ebinop Oadd
                                        (Evar _data (tarray tint 8))
                                        (Etempvar _j tint) (tptr tint)) tint))
                                  (Sassign
                                    (Ederef
                                      (Ebinop Oadd
                                        (Evar _data (tarray tint 8))
                                        (Etempvar _j tint) (tptr tint)) tint)
                                    (Ebinop Oadd (Etempvar _v tint)
                                      (Econst_int (Int.repr 1) tint) tint))))
                              (Sset _j
                                (Ebinop Oadd (Etempvar _j tint)
                                  (Econst_int (Int.repr 1) tint) tint))))
                          (Scall None
                            (Evar _write (Tfunction
                                           (Tcons
                                             (tptr (Tstruct _node noattr))
                                             (Tcons (tptr tint) Tnil)) tvoid
                                           cc_default))
                            ((Etempvar _n (tptr tvoid)) ::
                             (Evar _data (tarray tint 8)) :: nil))))
                      (Sset _i
                        (Ebinop Oadd (Etempvar _i tint)
                          (Econst_int (Int.repr 1) tint) tint))))
                  (Sreturn (Some (Econst_int (Int.repr 0) tint))))))))))))
|}.

Definition f_reader := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr tvoid)) :: nil);
  fn_vars := ((_data, (tarray tint 8)) :: nil);
  fn_temps := nil;
  fn_body :=
(Ssequence
  (Scall None
    (Evar _read (Tfunction
                  (Tcons (tptr (Tstruct _node noattr))
                    (Tcons (tptr tint) Tnil)) tvoid cc_default))
    ((Etempvar _n (tptr tvoid)) :: (Evar _data (tarray tint 8)) :: nil))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _node Struct
   ((_version, (tptr tint)) :: (_data, (tarray (tptr tint) 8)) :: nil)
   noattr :: nil).

Definition global_definitions : list (ident * globdef fundef type) :=
((___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___compcert_i64_dtos,
   Gfun(External (EF_runtime "__compcert_i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___compcert_i64_dtou,
   Gfun(External (EF_runtime "__compcert_i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___compcert_i64_stod,
   Gfun(External (EF_runtime "__compcert_i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___compcert_i64_utod,
   Gfun(External (EF_runtime "__compcert_i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___compcert_i64_stof,
   Gfun(External (EF_runtime "__compcert_i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___compcert_i64_utof,
   Gfun(External (EF_runtime "__compcert_i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___compcert_i64_sdiv,
   Gfun(External (EF_runtime "__compcert_i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_udiv,
   Gfun(External (EF_runtime "__compcert_i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_smod,
   Gfun(External (EF_runtime "__compcert_i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umod,
   Gfun(External (EF_runtime "__compcert_i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_shl,
   Gfun(External (EF_runtime "__compcert_i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_shr,
   Gfun(External (EF_runtime "__compcert_i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___compcert_i64_sar,
   Gfun(External (EF_runtime "__compcert_i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_smulh,
   Gfun(External (EF_runtime "__compcert_i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umulh,
   Gfun(External (EF_runtime "__compcert_i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_exit,
   Gfun(External (EF_external "exit"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons tint Tnil) tvoid cc_default)) ::
 (_malloc,
   Gfun(External EF_malloc (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_load_acq,
   Gfun(External (EF_external "load_acq"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_rel,
   Gfun(External (EF_external "store_rel"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) :: (_surely_malloc, Gfun(Internal f_surely_malloc)) ::
 (_read, Gfun(Internal f_read)) :: (_write, Gfun(Internal f_write)) ::
 (_make_node, Gfun(Internal f_make_node)) ::
 (_writer, Gfun(Internal f_writer)) :: (_reader, Gfun(Internal f_reader)) ::
 nil).

Definition public_idents : list ident :=
(_reader :: _writer :: _make_node :: _write :: _read :: _surely_malloc ::
 _store_rel :: _load_acq :: _malloc :: _exit :: ___builtin_debug ::
 ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap64 :: ___compcert_i64_umulh :: ___compcert_i64_smulh ::
 ___compcert_i64_sar :: ___compcert_i64_shr :: ___compcert_i64_shl ::
 ___compcert_i64_umod :: ___compcert_i64_smod :: ___compcert_i64_udiv ::
 ___compcert_i64_sdiv :: ___compcert_i64_utof :: ___compcert_i64_stof ::
 ___compcert_i64_utod :: ___compcert_i64_stod :: ___compcert_i64_dtou ::
 ___compcert_i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fsqrt ::
 ___builtin_fabs :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: nil).

Definition prog : Clight.program := 
  mkprogram composites global_definitions public_idents _main Logic.I. *)

Set Bullet Behavior "Strict Subproofs".

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Definition load_acq_spec := DECLARE _load_acq load_acq_spec.
Definition store_rel_spec := DECLARE _store_rel store_rel_spec.

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH n:Z
   PRE [ _n OF tuint ]
       PROP (0 <= n <= Int.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh n p * memory_block Tsh n p).

Definition tnode := Tstruct _node noattr.

Definition has_size : {x : Z | x = 8}.
Proof.
  eexists; eauto.
Qed.

Definition size := proj1_sig has_size.
Lemma size_def : size = 8.
Proof.
  apply (proj2_sig has_size).
Qed.

Definition data_T' version version_T s (v : Z) := EX ver : Z, !!(Z.even ver = true /\ log_latest s ver v) &&
  protocol_R version (ver - 1) Z.le (version_T, version_T).

Definition version_T_fun version locs g : (Z * Z -> mpred) -> (Z * Z -> mpred) :=
  fun R '(s, v) => !!(v = s) && EX L : _,
  !!(exists vs, Zlength vs = size /\ log_latest L (if Z.even v then v else v - 1) vs) &&
  (if eq_dec v 0 then emp
   else fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef) (map_Znth i L 0) map_incl
     (data_T' version (fun s v => |>R (s, v)), data_T' version (fun s v => |>R (s, v)))) (upto (Z.to_nat size)))) *
  ghost_snap L g.

Definition version_T' version locs g := HORec (version_T_fun version locs g).
Definition version_T version locs g s v := version_T' version locs g (s, v).

Definition data_T version locs g := data_T' version (|>version_T version locs g).

Lemma version_T'_eq version locs g : version_T' version locs g =
  version_T_fun version locs g (version_T' version locs g).
Proof.
  apply HORec_fold_unfold, prove_HOcontractive.
  intros P1 P2 (s, v).
  unfold version_T_fun.
  apply subp_andp; [apply subp_refl|].
  apply subp_exp; intro L.
  apply subp_sepcon; [|apply subp_refl].
  apply subp_andp; [apply subp_refl|].
  if_tac; [apply subp_refl|].
  pose proof (fold_right_sepcon_nonexpansive
    (map (fun i => protocol_R (Znth i locs Vundef) (map_Znth i L 0) map_incl
      (data_T' version (fun s v => |>P1 (s, v)), data_T' version (fun s v => |>P1 (s, v)))) (upto (Z.to_nat size)))
    (map (fun i => protocol_R (Znth i locs Vundef) (map_Znth i L 0) map_incl
      (data_T' version (fun s v => |>P2 (s, v)), data_T' version (fun s v => |>P2 (s, v)))) (upto (Z.to_nat size)))) as Hnon.
  rewrite fash_andp in Hnon.
  eapply derives_trans; [eapply derives_trans, Hnon; [|rewrite !Zlength_map; auto] | apply andp_left1; auto].
  apply allp_right; intro i.
  destruct (zlt i 0); [rewrite !Znth_underflow by auto; apply eqp_refl|].
  destruct (zlt i (Zlength (upto (Z.to_nat size))));
    [|rewrite !Znth_overflow by (rewrite Zlength_map; auto); apply eqp_refl].
  erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
  eapply derives_trans, protocol_piece_nonexpansive.
  apply allp_right; intro s1.
  apply allp_right; intro v1.
  unfold data_T'.
  eapply derives_trans, andp_right, derives_refl; auto.
  apply eqp_exp; intro ver.
  apply eqp_andp; [apply eqp_refl|].
  eapply derives_trans, protocol_piece_nonexpansive.
  apply allp_right; intro s2.
  apply allp_right; intro v2.
  apply allp_left with (s2, v2), andp_right; apply derives_refl.
Qed.

Lemma version_T_eq version locs g s v : version_T version locs g s v = !!(v = s) && EX L : _,
  !!(exists vs, Zlength vs = size /\ log_latest L (if Z.even v then v else v - 1) vs) &&
  (if eq_dec v 0 then emp
   else fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef) (map_Znth i L 0) map_incl
     (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size)))) * ghost_snap L g.
Proof.
  intros; unfold version_T.
  etransitivity; [rewrite version_T'_eq; reflexivity | auto].
Qed.

Lemma data_T_eq version locs g s v : data_T version locs g s v =
  EX ver : Z, !!(Z.even ver = true /\ log_latest s ver v) &&
    protocol_R version (ver - 1) Z.le (|>version_T version locs g, |>version_T version locs g).
Proof. auto. Qed.

Lemma data_T_duplicable : forall version locs g s v, duplicable (data_T version locs g s v).
Proof.
  intros; rewrite data_T_eq.
  apply exp_duplicable; intro.
  apply prop_duplicable, protocol_R_duplicable.
Qed.

Instance data_prot version locs g : protocol (data_T version locs g) (data_T version locs g).
Proof.
  apply dup_protocol, data_T_duplicable.
Qed.

Lemma version_T_duplicable : forall version locs g s v, duplicable (version_T version locs g s v).
Proof.
  intros; rewrite version_T_eq.
  apply prop_duplicable, exp_duplicable; intro.
  apply sepcon_duplicable, ghost_snap_duplicable.
  apply prop_duplicable.
  if_tac; auto with dup.
  apply sepcon_list_duplicable.
  rewrite Forall_map, Forall_forall; intros.
  apply protocol_R_duplicable.
Qed.

Instance version_prot version locs g : protocol (version_T version locs g) (version_T version locs g).
Proof.
  apply dup_protocol, version_T_duplicable.
Qed.

Definition node_state (sh : share) (L : Z -> option (list Z)) v version locs g :=
  !!(Z.even v = true /\ 0 <= v /\ exists vs, Zlength vs = size /\ log_latest L v vs) &&
  protocol_piece sh version v Z.le (version_T version locs g, version_T version locs g) *
  fold_right sepcon emp (map (fun i => protocol_piece sh (Znth i locs Vundef) (map_Znth i L 0) map_incl
    (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size))) * ghost (sh, L) g.

Program Definition read_spec := DECLARE _read atomic_spec
  (ConstType (val * val * share * share * val * list val * val * (Z -> option (list Z)) * Z))
  empty_map [(_n, tptr tnode); (_out, tptr tint)] tvoid
  [fun _ '(n, out, sh, shi, version, locs, g, L0, v0) => temp _n n;
   fun _ '(n, out, sh, shi, version, locs, g, L0, v0) => temp _out out]
  (fun _ '(n, out, sh, shi, version, locs, g, L0, v0) => !!(readable_share sh /\
     writable_share shi /\ isptr version /\ Forall isptr locs /\ Zlength locs = size) &&
   data_at sh tnode (version, locs) n * data_at_ shi (tarray tint size) out *
   node_state Share.bot L0 v0 version locs g)
  (fun _ '(n, out, sh, shi, version, locs, g, L0, v0) L => ghost (gsh1, L) g)
  (0, []) []
  (fun _ '(n, out, sh, shi, version, locs, g, L0, v0) L '(v, vals) =>
   !!(v0 <= v /\ Zlength vals = size) &&
   data_at sh tnode (version, locs) n * data_at shi (tarray tint size) (map (fun x => vint x) vals) out *
   node_state Share.bot (map_upd L0 v vals) v version locs g)
  (fun _ '(n, out, sh, shi, version, locs, g, L0, v0) L '(v, vals) => !!(map_incl L0 L /\ L v = Some vals) &&
   ghost (gsh1, L) g)
  _ _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.

Program Definition write_spec := DECLARE _write atomic_spec
  (ConstType (val * val * share * share * val * list val * list Z * val * (Z -> option (list Z)) * Z))
  (@empty_map Z (list Z)) [(_n, tptr tnode); (_in, tptr tint)] tvoid
  [fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) => temp _n n;
   fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) => temp _in input]
  (fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) => !!(readable_share sh /\
     readable_share shi /\ isptr version /\ Forall isptr locs /\ Zlength locs = size /\
     Forall repable_signed vals /\ repable_signed (v0 + 2)) &&
   data_at sh tnode (version, locs) n * data_at shi (tarray tint size) (map (fun x => vint x) vals) input *
   node_state gsh2 L v0 version locs g)
  (fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) L' => ghost (gsh1, L') g)
  tt []
  (fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) _ _ =>
   data_at sh tnode (version, locs) n * data_at shi (tarray tint size) (map (fun x => vint x) vals) input *
   node_state gsh2 (map_upd L (v0 + 2) vals) (v0 + 2) version locs g)
  (fun _ '(n, input, sh, shi, version, locs, vals, g, L, v0) _ _ => ghost (gsh1, map_upd L (v0 + 2) vals) g)
  _ _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.

Definition make_node_spec := DECLARE _make_node
  WITH u : unit
  PRE [ ]
    PROP ()
    LOCAL ()
    SEP ()
  POST [ tptr tnode ]
   EX n : val, EX version : val, EX locs : list val, EX g : val,
    PROP (isptr version; Forall isptr locs; Zlength locs = size)
    LOCAL (temp ret_temp n)
    SEP (data_at Tsh tnode (version, locs) n; malloc_token Tsh (sizeof tnode) n;
         malloc_token Tsh (sizeof tint) version; fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) locs);
         node_state gsh2 (singleton 0 (repeat 0 (Z.to_nat size))) 0 version locs g;
         ghost (gsh1, singleton 0 (repeat 0 (Z.to_nat size))) g).

Definition writer_spec := DECLARE _writer
  WITH n : val, sh : share, v : Z, L : Z -> option (list Z), version : val, locs : list val, g : val
  PRE [ _n OF tptr tvoid ]
    PROP (readable_share sh; isptr version; Forall isptr locs; Zlength locs = size; repable_signed (v + 6))
    LOCAL (temp _n n)
    SEP (data_at sh tnode (version, locs) n; node_state gsh2 L v version locs g;
         invariant (EX L : Z -> option (list Z), ghost (gsh1, L) g))
  POST [ tptr tvoid ]
   EX L' : _,
    PROP (L' = map_upd_list L (map (fun i => (v + (2 * (i + 1)), repeat (i + 1) (Z.to_nat size)))%Z (upto 3)))
    LOCAL ()
    SEP (data_at sh tnode (version, locs) n; node_state gsh2 L' (v + 6) version locs g;
         invariant (EX L : Z -> option (list Z), ghost (gsh1, L) g)).

Definition reader_spec := DECLARE _reader
  WITH n : val, sh : share, v : Z, L : Z -> option (list Z), version : val, locs : list val, g : val
  PRE [ _n OF tptr tvoid ]
    PROP (readable_share sh; isptr version; Forall isptr locs; Zlength locs = size)
    LOCAL (temp _n n)
    SEP (data_at sh tnode (version, locs) n; node_state Share.bot L v version locs g;
         invariant (EX L : Z -> option (list Z), ghost (gsh1, L) g))
  POST [ tptr tvoid ]
   EX v' : Z, EX vs' : list Z,
    PROP (v <= v'; v' = v -> Z.even v = true /\ L v = Some vs')
    LOCAL ()
    SEP (data_at sh tnode (version, locs) n; node_state Share.bot (map_upd L v' vs') v' version locs g;
         invariant (EX L : Z -> option (list Z), ghost (gsh1, L) g)).

Definition Gprog : funspecs := ltac:(with_library prog [surely_malloc_spec; load_acq_spec; store_rel_spec;
  read_spec; write_spec; make_node_spec; writer_spec; reader_spec]).

Lemma body_surely_malloc: semax_body Vprog Gprog f_surely_malloc surely_malloc_spec.
Proof.
  start_function.
  forward_call n.
  Intros p.
  forward_if
  (PROP ( )
   LOCAL (temp _p p)
   SEP (malloc_token Tsh n p * memory_block Tsh n p)).
  - if_tac; entailer!.
  - forward_call tt.
    contradiction.
  - if_tac.
    + forward. subst p. discriminate.
    + Intros. forward. entailer!.
  - forward. Exists p; entailer!.
Qed.

Lemma land_1 : forall i, Z.land i 1 = i mod 2.
Proof.
  intros; apply Z.land_ones with (n := 1); omega.
Qed.

Definition list_max v l := fold_right Z.max v l.

Lemma list_max_app : forall v l1 l2, list_max v (l1 ++ l2) = list_max (list_max v l2) l1.
Proof.
  intros; apply fold_right_app.
Qed.

Lemma list_max_max : forall l v1 v2, Z.max v1 (list_max v2 l) = list_max (Z.max v1 v2) l.
Proof.
  induction l; auto; simpl; intros.
  rewrite Z.max_assoc, !IHl.
  rewrite Z.max_assoc, (Z.max_comm a); auto.
Qed.

Lemma list_max_spec : forall l v, v <= list_max v l /\ Forall (fun v' => v' <= list_max v l) l.
Proof.
  induction l; simpl; intros.
  - split; auto; omega.
  - rewrite list_max_max.
    destruct (IHl (Z.max a v)) as [H]; split; [|repeat constructor; auto].
    + etransitivity; eauto; apply Zle_max_r.
    + etransitivity; eauto; apply Zle_max_l.
Qed.

Lemma node_state_snap : forall sh L v version locs g,
  view_shift (node_state sh L v version locs g)
             (node_state sh L v version locs g * node_state Share.bot L v version locs g).
Proof.
  intros; unfold node_state; view_shift_intros.
  rewrite !sepcon_assoc.
  etransitivity; [apply view_shift_sepcon1, make_protocol_R|].
  etransitivity; [apply view_shift_sepcon2|].
  - apply view_shift_sepcon, make_snap.
    apply view_shift_sepcon_list.
    { rewrite 2Zlength_map; reflexivity. }
    rewrite Zlength_map; intros.
    erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
    apply make_protocol_R.
  - rewrite sepcon_map.
    apply derives_view_shift; entailer!.
Qed.

Lemma body_read : semax_body Vprog Gprog f_read read_spec.
Proof.
  start_atomic_function.
  destruct x as ((((((((n, out), sh), shi), version), locs), g), L0), v0); Intros.
  destruct H as (HP & HQ).
  assert (0 <= size) by (rewrite size_def; computable).
  unfold node_state; Intros.
  match goal with H : exists vs, _ |- _ => destruct H as [vs0 [? [HL0 ?]]] end.
  apply semax_pre with (P' := PROP () LOCAL (temp _n n; temp _out out)
    SEP (@data_at CompSpecs sh tnode (version, locs) n; data_at_ shi (tarray tint size) out;
         EX v : Z, !!(v0 <= v) && protocol_R version v Z.le (version_T version locs g, version_T version locs g);
         EX ll : _, !!(forall i, 0 <= i < size -> map_incl (map_Znth i L0 0) (Znth i ll empty_map)) && fold_right sepcon emp (map (fun i =>
           protocol_R (Znth i locs Vundef) (Znth i ll empty_map) map_incl (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size)));
         EX L' : _, ghost_snap (map_add L0 L') g;
         fold_right sepcon emp (map (fun p : Z => invariant (II p)) lI); P)).
  { unfold node_state; Intros.
    Exists v0 (map (fun i => map_Znth i L0 0) (upto (Z.to_nat size))) (@empty_map Z (list Z));
      rewrite map_add_empty; entailer!.
    { intros.
      erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega); reflexivity. }
    erewrite map_ext_in; eauto; intros; simpl.
    rewrite In_upto in *; erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto; auto; omega. }
  eapply semax_loop; [|forward; unfold loop2_ret_assert; apply ENTAIL_refl].
  Intros v ll L'.
  repeat forward.
  forward_call_dep [Z : Type] (load_acq_witness version v Z.le
    (version_T version locs g, version_T version locs g) emp (version_T version locs g)).
  { simpl; cancel. }
  { simpl; split; intros; rewrite ?emp_sepcon, ?sepcon_emp; try reflexivity.
    rewrite sepcon_comm; reflexivity. }
  Intro x; rewrite version_T_eq; Intros L1; destruct x as (v1', v1); simpl fst in *; simpl snd in *; subst.
  gather_SEP 7 3; rewrite map_snap_join; Intros.
  match goal with H : exists vs, _ |- _ => destruct H as (vs1 & ? & HL1) end.
  assert (forall i, compatible (map_Znth i L0 0) (singleton (if Z.even v1 then v1 else v1 - 1) (Znth i vs1 0)))
    as Hcompat.
  { intros ????; unfold map_Znth.
    destruct (L0 k) eqn: Hk0; [|discriminate].
    unfold singleton; if_tac; [|discriminate].
    destruct HL1 as [Hk1].
    match goal with H : compatible _ _ |- _ => specialize (H k); unfold map_add in H; subst; rewrite Hk0, Hk1 in H;
      specialize (H _ _ eq_refl eq_refl); inv H end.
    intros X Y; inv X; inv Y; auto. }
  gather_SEP 3 6; eapply view_shift_trans; [|reflexivity|].
  { instantiate (1 := fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
      (map_upd (map_Znth i L0 0) (if Z.even v1 then v1 else v1 - 1) (Znth i vs1 0)) map_incl _)
      (upto (Z.to_nat size)))).
    if_tac.
    - assert (v0 = 0) by omega.
      rewrite emp_sepcon; subst; simpl in *.
      apply view_shift_sepcon_list; rewrite ?Zlength_map; auto; intros.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite ?Zlength_upto in *; omega).
      rewrite map_upd_triv.
      apply protocol_R_forget.
      rewrite Zlength_upto, Z2Nat.id in *; auto.
      { specialize (Hcompat i 0); unfold map_Znth, singleton in Hcompat.
        rewrite HL0, eq_dec_refl in Hcompat; specialize (Hcompat _ _ eq_refl eq_refl).
        unfold map_Znth; rewrite HL0; simpl; auto. }
    - rewrite <- sepcon_map; apply view_shift_sepcon_list; rewrite ?Zlength_map; auto; intros ? Hi.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite ?Zlength_upto in *; omega).
      assert (map_incl (singleton (if Z.even v1 then v1 else v1 - 1) vs1) L1) as Hv1.
      { intros ??; unfold singleton; if_tac; [subst | discriminate].
        destruct HL1; intro X; inv X; auto. }
      eapply map_incl_Znth in Hv1.
      rewrite sepcon_comm.
      erewrite <- protocol_R_join with (s := map_upd _ _ _)(s1 := map_Znth i L0 0).
      apply view_shift_sepcon; apply protocol_R_forget; eauto.
      rewrite Zlength_upto, Z2Nat.id in *; auto.
      { rewrite map_join_spec.
        rewrite map_Znth_single; split; auto.
        rewrite map_add_comm, map_add_single; auto. } }
  match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
    forward_if (PROP (Z.even v1 = true) (LOCALx Q (SEPx R))) end.
  { eapply semax_pre; [|apply semax_continue].
    unfold POSTCONDITION, abbreviate, overridePost.
    destruct (eq_dec EK_continue EK_normal); [discriminate|].
    unfold loop1_ret_assert.
    go_lower.
    unfold Int.one in *; rewrite and_repr, land_1, Zmod_even in *.
    destruct (Z.even v1) eqn: Hodd; try contradiction.
    Exists v1 (map (fun i => map_upd (map_Znth i L0 0) (v1 - 1) (Znth i vs1 0)) (upto (Z.to_nat size)))
      (map_add L' L1); rewrite map_add_assoc; entailer!.
    { intros.
      erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
      rewrite <- map_add_single, <- map_add_comm by auto; apply map_incl_add. }
    erewrite map_ext_in; eauto; intros; simpl.
    rewrite In_upto in *; erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto; auto; omega. }
  { forward.
    entailer!.
    unfold Int.one in *; rewrite and_repr, land_1, Zmod_even in *.
    destruct (Z.even v1); auto; discriminate. }
  Intros.
  destruct (Z.even v1) eqn: Hv1; try discriminate.
  forward_for_simple_bound 8 (EX i : Z, EX vals : list Z, PROP (Zlength vals = i)
    LOCAL (temp _snap (vint v1); temp _ver version; temp _n n; temp _out out)
    SEP (@data_at CompSpecs sh tnode (version, locs) n;
         data_at shi (tarray tint size) (map (fun x => vint x) vals ++ repeat Vundef (Z.to_nat (size - i))) out;
         EX vers' : list Z, !!(Zlength vers' = i /\ Forall (fun v => Z.even v = true /\ v1 <= v) vers' /\
           forall j, 0 <= j < i -> Znth j vers' 0 = v1 -> Znth j vals 0 = Znth j vs1 0) &&
           protocol_R version (list_max v1 (map (fun x => x - 1) vers')) Z.le (version_T version locs g, version_T version locs g) *
           fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
             (map_upd (map_Znth i L0 0) (Znth i vers' 0) (Znth i vals 0)) map_incl
             (data_T version locs g, data_T version locs g)) (sublist 0 i (upto (Z.to_nat size))));
         fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
           (map_upd (map_Znth i L0 0) v1 (Znth i vs1 0)) map_incl
           (data_T version locs g, data_T version locs g)) (sublist i size (upto (Z.to_nat size))));
         ghost_snap (map_add (map_add L0 L') L1) g;
         fold_right sepcon emp (map (fun p : Z => invariant (II p)) lI); P)).
  { Exists (@nil Z) (@nil Z).
    rewrite data_at__eq; unfold default_val; simpl data_at.
    rewrite repeat_list_repeat, Z.sub_0_r; entailer!.
    { intros; omega. }
    rewrite sublist_same by (auto; rewrite Zlength_upto, Z2Nat.id; auto); auto. }
  - Intros vers'.
    match goal with H : 0 <= i < _ |- _ => rewrite <- size_def in H end.
    forward.
    { entailer!.
      rewrite size_def in *; auto. }
    { entailer!.
      apply Forall_Znth; [omega|].
      eapply Forall_impl; [|eauto]; auto. }
    erewrite sublist_next with (i0 := i), Znth_upto by (rewrite ?Zlength_upto, ?Z2Nat.id; auto; omega); simpl.
    forward_call_dep [Z -> option Z : Type] (load_acq_witness (Znth i locs Vundef)
      (map_upd (map_Znth i L0 0) v1 (Znth i vs1 0)) map_incl (data_T version locs g, data_T version locs g)
      (protocol_R version (list_max v1 (map (fun x0 : Z => x0 - 1) vers')) Z.le
        (version_T version locs g, version_T version locs g))
      (fun s (v : Z) => EX v' : Z, !!(Z.even v' = true /\ log_latest s v' v) &&
        |>protocol_R version (list_max v1 (map (fun x => x - 1) (vers' ++ [v']))) Z.le (version_T version locs g, version_T version locs g))).
    { simpl; cancel. }
    { split; simpl; intros; rewrite !emp_sepcon; [reflexivity|].
      rewrite data_T_eq.
      view_shift_intro ver; view_shift_intros.
      rewrite sepcon_comm, <- sepcon_assoc.
      etransitivity; [apply view_shift_sepcon1, view_shift_sepcon;
        apply derives_view_shift; [apply now_later | apply protocol_later]|].
      rewrite <- later_sepcon; setoid_rewrite protocol_R_join; [|rewrite join_max; eauto].
      apply derives_view_shift; Exists ver; entailer!.
      rewrite map_app, list_max_app; simpl.
      rewrite Z.max_comm, list_max_max; auto. }
    Intros y v'; destruct y as (d, log'); simpl fst in *; simpl snd in *.
    focus_SEP 1; apply protocol_R_forget with (s1 := map_upd (map_Znth i L0 0) v' d).
    { match goal with H : log_latest _ _ _ |- _ => destruct H end.
      apply map_upd_incl; auto.
      etransitivity; [|eauto].
      rewrite <- map_add_single, <- map_add_comm by auto; apply map_incl_add. }
    forward.
    go_lower; Exists (x ++ [d]) (vers' ++ [v']); rewrite !Zlength_app, !Zlength_cons, !Zlength_nil.
    rewrite <- size_def, upd_init, !map_app, <- app_assoc by (rewrite ?Zlength_map; omega).
    entailer!.
    { split.
      + rewrite Forall_app; repeat constructor; auto.
        eapply log_incl_latest; eauto.
        unfold map_upd; rewrite eq_dec_refl; eauto.
      + intros ?? Hv.
        destruct (eq_dec j (Zlength x)).
        * subst j; rewrite app_Znth2 in Hv |- * by omega.
          replace (Zlength vers') with (Zlength x) in Hv; rewrite Zminus_diag, Znth_0_cons in Hv |- *; subst.
          match goal with H : map_incl _ log' |- _ => specialize (H v1); unfold map_upd in H; rewrite eq_dec_refl in H;
            specialize (H _ eq_refl) end.
          match goal with H : log_latest log' _ _ |- _ => destruct H as [Hv']; rewrite Hv' in *; congruence end.
        * rewrite app_Znth1 in Hv |- * by omega; match goal with H : forall j, _ |- _ => apply H; auto; omega end. }
    rewrite sublist_split with (mid := Zlength x)(hi := Zlength x + 1)
      by (rewrite ?Zlength_upto, ?Z2Nat.id; simpl; omega).
    erewrite sublist_len_1, Znth_upto by (rewrite ?Zlength_upto, ?Z2Nat.id; simpl; omega).
    rewrite map_app, sepcon_app; simpl.
    rewrite !app_Znth2 by omega.
    replace (Zlength vers') with (Zlength x); rewrite Zminus_diag, !Znth_0_cons; simpl; cancel.
    apply sepcon_list_derives; rewrite !Zlength_map; auto.
    intros ? Hi; erewrite !Znth_map by auto.
    rewrite Zlength_sublist in Hi by (rewrite ?Zlength_upto, ?Z2Nat.id; simpl; omega).
    rewrite !Znth_sublist, !Znth_upto by (rewrite ?Z2Nat.id; simpl; omega).
    rewrite !app_Znth1 by omega; auto.
  - Intros vals' vers'; rewrite <- size_def in *.
    rewrite Zminus_diag, app_nil_r, sublist_nil, sublist_same by (rewrite ?Zlength_upto, ?Z2Nat.id; auto).
    forward_call_dep [Z : Type] (version, list_max v1 (map (fun x => x - 1) vers'), Z.le,
      (version_T version locs g, version_T version locs g), P *
        protocol_R version (list_max v1 (map (fun x : Z => x - 1) vers')) Z.le (version_T version locs g, version_T version locs g) *
        fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
          (map_upd (map_Znth i L0 0) (Znth i vers' 0) (Znth i vals' 0)) map_incl (data_T version locs g, data_T version locs g))
          (upto (Z.to_nat size))) * ghost_snap (map_add (map_add L0 L') L1) g, II, lI,
      fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
          (map_upd (map_Znth i L0 0) (Znth i vers' 0) (Znth i vals' 0)) map_incl (data_T version locs g, data_T version locs g))
          (upto (Z.to_nat size))) * ghost_snap (map_add (map_add L0 L') L1) g * EX L : _, ghost (gsh1, L) g * R L,
      fun s v => !!(v = s) && protocol_R version v Z.le (version_T version locs g, version_T version locs g) *
        fold_right sepcon emp (map (fun i => protocol_R (Znth i locs Vundef)
          (map_upd (map_Znth i L0 0) (Znth i vers' 0) (Znth i vals' 0)) map_incl (data_T version locs g, data_T version locs g))
          (upto (Z.to_nat size))) * (if eq_dec v v1 then EX L : _, Q L (v1, vals') * (!!(L v = Some vals' /\
           forall j, 0 <= j < size -> Znth j vers' 0 = v1) && ghost_snap (map_upd L0 v vals') g)
         else P * ghost_snap (map_add (map_add L0 L') L1) g)).
    { split; intros.
      + rewrite <- !sepcon_assoc, 2sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
        apply derives_view_shift; cancel.
      + simpl; rewrite version_T_eq.
        view_shift_intro L; view_shift_intro L2; view_shift_intros; subst.
        rewrite prop_true_andp by auto.
        rewrite (sepcon_comm _ (protocol_R _ _ _ _)), (sepcon_comm (fold_right _ _ (map II lI))), !sepcon_assoc.
        apply view_shift_sepcon2.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right _ _ _)).
        rewrite <- !sepcon_assoc, 3sepcon_assoc; etransitivity; [apply view_shift_sepcon1|].
        { if_tac; [rewrite sepcon_emp; reflexivity|].
          rewrite <- sepcon_map; apply view_shift_sepcon_list.
          { rewrite 2Zlength_map; auto. }
          rewrite Zlength_map; intros.
          erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
          apply protocol_R_choose. }
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ _)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap L2 _)).
        rewrite <- sepcon_assoc, snap_master_join by auto; view_shift_intros.
        if_tac.
        * subst.
          rewrite (sepcon_comm _ (exp _)), (sepcon_comm _ (fold_right _ _ (map II lI))).
          etransitivity; [|etransitivity; [apply view_shift_sepcon1, HQ |
            apply derives_view_shift; Exists L; rewrite 2sepcon_assoc; eauto]]; simpl.
          assert (forall j, 0 <= j < size -> Znth j vers' 0 = v1) as Hvers.
          { intros; match goal with H : Forall _ vers' |- _ => apply Forall_Znth with (i := j)(d := 0) in H;
              [destruct H as [Heven] | omega] end.
            destruct (list_max_spec (map (fun x => x - 1) vers') v1) as [_ Hmax].
            rewrite Forall_map in Hmax.
            apply Forall_Znth with (i := j)(d := 0) in Hmax; [simpl in Hmax | omega].
            destruct (eq_dec (Znth j vers' 0) v1); subst; auto.
            assert (Znth j vers' 0 = v1 + 1) as Heq by omega.
            rewrite Heq, Z.even_add in Heven; replace (Z.even v1) with true in Heven; discriminate. }
          destruct HL1 as [HL1].
          assert (L1 v1 = Some vals') as Hvals'.
          { eapply map_Znth_eq.
            * intro; rewrite HL1; intro X; inv X; omega.
            * intro; subst; rewrite size_def in *; discriminate.
            * intros; unfold map_Znth in *; rewrite HL1; simpl.
              assert (0 <= i < size) by omega.
              match goal with H : forall j, _ |- _ => symmetry; apply f_equal, H; auto end. }
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)).
          rewrite <- sepcon_assoc, snap_master_join by auto; view_shift_intros.
          match goal with H : map_incl _ L |- _ => exploit (H v1 vals') end.
          { rewrite map_add_comm by auto.
            unfold map_add; rewrite Hvals'; auto. }
          assert (map_incl L0 L) by (etransitivity; eauto; etransitivity; apply map_incl_add).
          intro; rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, make_snap|].
          rewrite sepcon_assoc; etransitivity; [apply view_shift_sepcon1,
            ghost_snap_forget with (v2 := map_upd L0 v1 vals'), map_upd_incl; auto|].
          apply derives_view_shift; unfold share; entailer!.
                    admit.
        * rewrite (sepcon_comm (P * _)), <- !sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
          apply derives_view_shift; Exists L; entailer!.
          admit. }
    Intros x; destruct x as (v2', v2); simpl fst in *; simpl snd in *; subst.
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
      forward_if (PROP (v2 <> v1) (LOCALx Q (SEPx R))) end.
    + subst; rewrite eq_dec_refl.
      Intros L2.
      forward.
      Exists (v1, vals') L2; unfold node_state, protocol_R, ghost_snap, share; entailer!.
      { exists vals'; split; auto.
        split.
        * unfold map_upd; rewrite eq_dec_refl; auto.
        * intros; unfold map_upd; if_tac; [omega|].
          assert (v0 < v') by omega; auto. }
      erewrite sepcon_comm, map_ext_in; eauto; intros; simpl.
      rewrite map_Znth_upd; replace v1 with (Znth a vers' 0); auto.
      rewrite In_upto, Z2Nat.id in *; auto.
    + forward.
      entailer!.
    + intros; unfold overridePost.
      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
      unfold POSTCONDITION, abbreviate, loop1_ret_assert.
      Intros; go_lower.
      if_tac; [contradiction|].
      Exists v2 (map (fun i => map_upd (map_Znth i L0 0) (Znth i vers' 0) (Znth i vals' 0))
        (upto (Z.to_nat size))) (map_add L' L1); rewrite map_add_assoc; entailer!.
      { destruct (list_max_spec (map (fun x => x - 1) vers') v1); split; [omega|].
        intros.
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, Z2Nat.id; auto; omega).
        intros ?? Hk; unfold map_upd; if_tac; auto; subst.
        match goal with H : Forall _ vers' |- _ => apply Forall_Znth with (i0 := i)(d := 0) in H;
          [simpl in H; destruct H | omega] end.
        destruct (eq_dec (Znth i vers' 0) v1).
        * match goal with H : forall i, _ |- _ => exploit H; eauto; intro Heq end.
          destruct HL1 as [HL1].
          match goal with H : forall i, compatible _ _ |- _ => exploit H end.
          { eauto. }
          { unfold singleton; rewrite <- Heq, e, eq_dec_refl; eauto. }
          intros ->; auto.
        * unfold map_Znth in Hk.
          match goal with H : forall v', _ -> L0 v' = None |- _ => rewrite H in Hk; [discriminate | omega] end. }
      erewrite map_ext_in; eauto; intros; simpl.
      rewrite In_upto in *; erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto; auto; omega.
Qed.

Lemma body_write : semax_body Vprog Gprog f_write write_spec.
Proof.
  start_atomic_function.
  destruct x as (((((((((n, input), sh), shi), version), locs), vals), g), L), v0); Intros.
  destruct H as (HP & HQ).
  forward.
  unfold node_state; Intros.
  forward_call_dep [Z : Type] (load_acq_W_witness version v0 Z.le (version_T version locs g, version_T version locs g)
    (fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef) (map_Znth i L 0) map_incl
       (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size))) * ghost (gsh2, L) g)
    (fun s v : Z => !!(v = s) && fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef) (map_Znth i L 0) map_incl
       (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size))) * ghost (gsh2, L) g)).
  { simpl; unfold protocol_W, share; cancel. }
  { simpl; split; intros; rewrite !emp_sepcon.
    { etransitivity; [apply view_shift_sepcon1, make_protocol_R|].
      apply derives_view_shift; cancel. }
    rewrite !sepcon_assoc, sepcon_comm, <- !sepcon_assoc, 2sepcon_assoc.
    etransitivity; [apply view_shift_sepcon1; rewrite sepcon_comm; apply protocol_R_absorb; auto|].
    view_shift_intros; assert (s' = v0) by omega.
    apply derives_view_shift; rewrite version_T_eq; unfold protocol_W; entailer!.
    admit.  }
  Intros x; destruct x as (?, v); simpl fst in *; simpl snd in *; subst.
  assert (repable_signed (v0 + 1)) by admit. 
  forward_call_dep [Z : Type] (store_rel_witness version (v0 + 1) v0 (v0 + 1) Z.le
    (version_T version locs g, version_T version locs g) emp emp).
  { split; auto; split; [|split; [|omega]]; intros; simpl; rewrite !sepcon_emp, ?emp_sepcon; [reflexivity|].
    rewrite !version_T_eq.
    view_shift_intro L1; view_shift_intros; subst.
    rewrite Z.even_add, Z.add_simpl_r, H in *; simpl.
    destruct (eq_dec (v0 + 1) 0); [omega|].
    if_tac; [|apply derives_view_shift; Exists L1; entailer!].
    etransitivity; [apply view_shift_sepcon2, view_shift_sepcon1, view_shift_sepcon_list;
      [rewrite 2Zlength_map; auto|]|].
    { rewrite Zlength_map; intros.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      apply make_protocol_R. }
    rewrite <- !sepcon_assoc, sepcon_comm, <- !sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)).
    rewrite <- !sepcon_assoc, snap_master_join by auto; view_shift_intros.
    rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, make_snap|].
    rewrite sepcon_map; apply derives_view_shift; Exists L; unfold protocol_W; entailer!. }
  assert (0 <= size) by (rewrite size_def; computable).
  assert_PROP (Zlength (map (fun x => vint x) vals) = size) by entailer!.
  assert (Z.even (v0 + 2) = true) by (rewrite Z.even_add; replace (Z.even v0) with true; auto).
  rewrite <- seq_assoc; Intros.
  focus_SEP 2.
  match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx (_ :: ?R)))) _ _ =>
  forward_for_simple_bound 8 (EX i : Z, PROP () (LOCALx Q
    (SEPx (fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef)
             (map_Znth i (map_upd L (v0 + 2) vals) 0) map_incl (data_T version locs g, data_T version locs g))
             (sublist 0 i (upto (Z.to_nat size)))) ::
           fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef)
             (map_Znth i L 0) map_incl (data_T version locs g, data_T version locs g))
             (sublist i size (upto (Z.to_nat size)))) :: R)))) end.
  { rewrite sublist_nil, sublist_same by (rewrite ?Zlength_upto, ?Z2Nat.id; auto).
    replace (Z.even v0) with true; entailer!. }
  - 
    Intros; forward; rewrite <- size_def in *.
    { entailer!.
      apply Forall_Znth; [omega|].
      eapply Forall_impl; [|eauto]; auto. }
    forward.
    erewrite sublist_next with (i0 := i), Znth_upto by (rewrite ?Zlength_upto, ?Z2Nat.id; auto; omega); simpl.
    rewrite Zlength_map in *.
    match goal with H : exists vs, _ |- _ => destruct H as [vs0 [? ?]] end.
    destruct (log_latest_upd (map_Znth i L 0) v0 (Znth i vs0 0) (v0 + 2) (Znth i vals 0)); auto; try omega.
    { apply map_Znth_log_latest; auto. }
    forward_call_dep [Z -> option Z : Type] (store_rel_witness (Znth i locs Vundef) (Znth i vals 0)
      (map_Znth i L 0) (map_upd (map_Znth i L 0) (v0 + 2) (Znth i vals 0)) map_incl (data_T version locs g, data_T version locs g)
      (protocol_W version (v0 + 1) Z.le (version_T version locs g, version_T version locs g))
      (protocol_W version (v0 + 1) Z.le (version_T version locs g, version_T version locs g))).
    { simpl; cancel. }
    { split; [apply Forall_Znth; auto; omega|].
      assert (0 <= i < Zlength (upto (Z.to_nat size))) by (rewrite Zlength_upto, Z2Nat.id; auto; omega).
      split; [|split; auto]; intros; simpl; rewrite ?emp_sepcon, ?sepcon_emp; [reflexivity|].
      rewrite !data_T_eq; view_shift_intro ver; view_shift_intros.
      rewrite sepcon_comm; etransitivity; [apply view_shift_sepcon1, make_protocol_R|].
      apply derives_view_shift; Exists (v0 + 2).
      rewrite <- Z.add_sub_assoc; simpl; unfold protocol_W; entailer!.
      eapply derives_trans; [apply sepcon_derives, derives_refl; apply protocol_delay|].
      setoid_rewrite protocol_R_join; [|rewrite join_max; eauto].
      rewrite Z.max_l; auto.
      match goal with H : log_latest L _ _ |- _ => eapply map_Znth_log_latest, (log_latest_inj _ _ _ ver) in H;
        eauto; destruct H; subst; omega end. }
    erewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1, Znth_upto, map_app, sepcon_app
      by (rewrite ?Zlength_upto, ?Z2Nat.id; auto; omega); simpl fold_right.
    rewrite <- size_def, map_Znth_upd; entailer!.
  - rewrite <- size_def, sublist_nil, sublist_same by (rewrite ?Zlength_upto, ?Z2Nat.id; auto; omega).
    match goal with H : exists vs, _ |- _ => destruct H as [vs0 [? ?]] end.
    destruct (log_latest_upd L v0 vs0 (v0 + 2) vals); auto; try omega.
    forward_call_dep [Z : Type] (version, v0 + 2, v0 + 1, v0 + 2, Z.le, (version_T version locs g, version_T version locs g),
      P * protocol_W version (v0 + 1) Z.le (version_T version locs g, version_T version locs g) *
        fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef) (map_Znth i (map_upd L (v0 + 2) vals) 0)
          map_incl (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size))) * ghost (gsh2, L) g, II, lI,
      fold_right sepcon emp (map (fun i => protocol_W (Znth i locs Vundef) (map_Znth i (map_upd L (v0 + 2) vals) 0)
          map_incl (data_T version locs g, data_T version locs g)) (upto (Z.to_nat size))) * ghost (Tsh, L) g * R L,
      Q L tt * node_state gsh2 (map_upd L (v0 + 2) vals) (v0 + 2) version locs g).
    { split; [auto | split; [| split; [|omega]]].
      + rewrite <- !sepcon_assoc, 2sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
        view_shift_intro L1.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ _)), <- !sepcon_assoc.
        erewrite (sepcon_comm (ghost _ _)), master_share_join' by eauto.
        apply derives_view_shift; entailer!.
      + intros; simpl.
        rewrite !sepcon_assoc, (sepcon_comm (version_T _ _ _ (v0 + 2) _)).
        rewrite <- !sepcon_assoc, 4sepcon_assoc.
        etransitivity; [|apply view_shift_sepcon1, HQ].
        rewrite !version_T_eq; view_shift_intro L'; view_shift_intros.
        if_tac; [omega|].
        rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right _ _ _)).
        rewrite <- !sepcon_assoc, <- sepcon_map.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, view_shift_sepcon_list|].
        { rewrite 2Zlength_map; reflexivity. }
        { rewrite Zlength_map; intros.
          erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
          etransitivity; [apply protocol_R_absorb; auto|].
          apply view_shift_prop; intro; apply make_protocol_R. }
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ _)).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)).
        rewrite <- !sepcon_assoc, snap_master_join by apply Share.nontrivial; view_shift_intros.
        rewrite !sepcon_assoc; etransitivity.
        { apply view_shift_sepcon1; etransitivity.
          * apply master_update with (v' := map_upd L (v0 + 2) vals); auto.
          * apply make_snap. }
        erewrite <- master_share_join by eauto.
        apply derives_view_shift; Exists (map_upd L (v0 + 2) vals).
        rewrite Zlength_map in *; rewrite sepcon_map.
        rewrite Z.even_add; replace (Z.even v0) with true; simpl.
        if_tac; [omega|].
        unfold node_state, protocol_W; entailer!.
        split; eauto. }
    forward.
    Exists tt L.
    rewrite Zlength_map in *; entailer!.
Qed.

Lemma body_make_node : semax_body Vprog Gprog f_make_node make_node_spec.
Proof.
  start_function.
  forward_malloc tnode n.
  forward_malloc tint p.
  repeat forward.
  forward_for_simple_bound 8 (EX i : Z, EX ld : list val, PROP (Zlength ld = i; Forall isptr ld)
    LOCAL (temp _n n)
    SEP (malloc_token Tsh (sizeof tint) p; data_at Tsh tint (vint 0) p; malloc_token Tsh (sizeof tnode) n;
         @data_at CompSpecs Tsh tnode (p, ld ++ repeat Vundef (Z.to_nat (8 - i))) n;
         fold_right sepcon emp (map (data_at Tsh tint (vint 0)) ld);
         fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) ld))).
  { Exists (@nil val); entailer!; auto. }
  - forward_malloc tint d.
    rewrite data_at__isptr; Intros.
    repeat forward.
    Exists (x ++ [d]); rewrite upd_init, <- app_assoc, !Zlength_app, !Zlength_cons, !Zlength_nil by (auto; tauto).
    rewrite !map_app, !sepcon_app; simpl fold_right; entailer!.
    { rewrite Forall_app; repeat constructor; auto. }
    auto.
  - Intros ld.
    
    apply ghost_alloc with (g := (Tsh, singleton 0 (repeat 0 (Z.to_nat size))));
      [apply master_init | Intros g].
    apply make_snap; Intros.
    assert (exists vs, Zlength vs = size /\ log_latest (singleton 0 (repeat 0 (Z.to_nat size))) 0 vs).
    { do 2 eexists; [|apply log_latest_singleton].
      rewrite Zlength_repeat, Z2Nat.id; auto; rewrite size_def; computable. }
    gather_SEP 3 0; eapply view_shift_trans;
      [|apply (@make_protocol _ _ Z.le _ _ (version_prot p ld g) p 0 0); auto|].
    { rewrite version_T_eq; apply derives_view_shift.
      Exists (singleton 0 (repeat 0 (Z.to_nat size))); simpl; entailer!. }
    apply make_protocol_R; Intros.
    focus_SEP 1; apply protocol_R_forget with (s1 := -1); [omega|].
    rewrite app_nil_r; gather_SEP 6 0; apply list_duplicate.
    { apply protocol_R_duplicable. }
    Intros; apply view_shift_sepcon_list with (l2 := map (fun l =>
      protocol_W l (singleton 0 0) map_incl (data_T p ld g, data_T p ld g)) ld); rewrite ?Zlength_map; auto.
    { intros.
      erewrite Znth_map, Znth_map', Znth_map with (d' := Vundef) by (rewrite ?Zlength_map; auto).
      rewrite sepcon_comm; etransitivity; [|apply make_protocol with (v := 0); auto; apply data_prot].
      rewrite data_T_eq.
      apply derives_view_shift; Exists 0; entailer!.
      { apply log_latest_singleton. }
      simpl; apply protocol_delay. }
    gather_SEP 2 1; apply protocol_R_absorb; auto; Intros.
    forward.
    erewrite <- master_share_join by eauto.
    unfold node_state.
    rewrite <- size_def in *.
    Exists n p ld g; unfold protocol_W, share; simpl; entailer!.
    setoid_rewrite (list_Znth_eq Vundef ld) at 3.
    rewrite map_map, <- ZtoNat_Zlength; replace (Zlength ld) with size.
    erewrite map_ext_in; eauto; intros; simpl.
    rewrite map_Znth_single, Znth_repeat; auto.
Qed.

Lemma body_writer : semax_body Vprog Gprog f_writer writer_spec.
Proof.
  name data _data.
  start_function.
  rewrite data_at__eq; unfold default_val; simpl.
  repeat forward.
  assert_PROP (0 <= v) by (unfold node_state; entailer!).
  forward_for_simple_bound 3 (EX i : Z, EX L' : _,
    PROP (L' = map_upd_list L (map (fun i => (v + 2 * (i + 1), repeat (i + 1) 8)%Z) (upto (Z.to_nat i))))
    LOCAL (lvar _data (tarray tint 8) data; temp _n n)
    SEP (data_at Tsh (tarray tint 8) (repeat (vint i) 8) data; @data_at CompSpecs sh tnode (version, locs) n;
         node_state gsh2 L' (v + 2 * i) version locs g;
         invariant (EX L : Z -> option (list Z), ghost (gsh1, L) g))).
  { Exists L; entailer!; auto. }
  - Intros.
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx (_ :: ?R)))) _ _ =>
    forward_for_simple_bound 8 (EX j : Z, PROP () (LOCALx Q
      (SEPx (data_at Tsh (tarray tint 8) (repeat (vint (i + 1)) (Z.to_nat j) ++
             repeat (vint i) (Z.to_nat (8 - j))) data :: R)))) end.
    { entailer!. }
    + forward.
      { entailer!.
        rewrite app_Znth2; rewrite Zlength_repeat, Z2Nat.id; try omega.
        rewrite Zminus_diag, Znth_repeat' by (rewrite Z2Nat.id; omega); auto. }
      rewrite app_Znth2; rewrite Zlength_repeat, Z2Nat.id; try omega.
      rewrite Zminus_diag, Znth_repeat' by (rewrite Z2Nat.id; omega).
      forward.
      rewrite add_repr, upd_init_const by auto; entailer!.
    + 
    
Ltac lookup_spec_and_change_compspecs CS id ::=
 tryif apply f_equal_Some
 then
   (match goal with |- ?A = ?B =>
      let x := fresh "x" in set (x := A);
      let y := fresh "y" in set (y := B);
      hnf in x; subst x; subst y
   end;
   match goal with
   | |- ?fs = _ => check_canonical_funspec (id,fs);
      first [reflexivity |
      match goal with
       | |- mk_funspec _ _ ?t1 _ _ = mk_funspec _ _ ?t2 _ _ =>
         first [unify t1 t2
           | elimtype False; elimtype (Witness_type_of_forward_call_does_not_match_witness_type_of_funspec
      t2 t1)]
      end]
   end)
 else elimtype  (Cannot_find_function_spec_in_Delta id).

      forward_call (n, data, sh, Tsh, version, locs, repeat (i + 1) 8, g, x, v + 2 * i, emp,
        fun (_ : Z -> option (list Z)) (_ : unit) => emp, fun _ : Z -> option (list Z) => emp,
        fun _ : Z => EX L : Z -> option (list Z), ghost (gsh1, L) g, [0]).
      { entailer!.
        { split; [|unfold repable_signed in *; pose proof Int.min_signed_neg; omega].
          apply Forall_repeat.
          split; [pose proof Int.min_signed_neg; omega|].
          transitivity 3; [omega | computable]. }
        rewrite size_def, Zminus_diag, app_nil_r, map_repeat; simpl; cancel. }
      { split; simpl; rewrite <- ?exp_sepcon1, !sepcon_emp.
        * split; reflexivity.
        * intros _ _.
          apply derives_view_shift; Exists (map_upd x (v + 2 * i + 2) (repeat (i + 1) 8)); cancel. }
      Exists (map_upd x (v + 2 * i + 2) (repeat (i + 1) 8)).
      rewrite Z2Nat.inj_add, upto_app, map_app, map_upd_list_app by omega.
      change (upto 1) with [0]; simpl map_upd_list.
      rewrite Z2Nat.id, Z.add_0_r, Z.mul_add_distr_l, Z.add_assoc by omega.
      rewrite <- size_def; entailer!.
  - Intros L'; forward.
    Exists (map_upd_list L (map (fun i => (v + 2 * (i + 1), repeat (i + 1) 8)) (upto (Z.to_nat 3))));
      rewrite size_def; simpl; entailer!.
Admitted.

>>>>>>> refs/remotes/origin/master

Lemma body_reader : semax_body Vprog Gprog f_reader reader_spec.
Proof.
  name data _data.
  start_function.
  assert_PROP (Z.even v = true /\ exists vs, Zlength vs = size /\ log_latest L v vs) as Hv.
  { unfold node_state; entailer!. }
  destruct Hv as [Heven [? [? [HL ?]]]].
  forward_call (n, data, sh, Tsh, version, locs, g, L, v, emp,
    fun (L' : Z -> option (list Z)) '(v', vs') => !!(v' = v -> x = vs') && emp,
    fun _ : Z -> option (list Z) => emp,
    fun _ : Z => EX L : Z -> option (list Z), ghost (gsh1, L) g, [0]).
  { rewrite <- size_def; simpl; entailer!. }
  { split; simpl; rewrite <- ?exp_sepcon1, !sepcon_emp.
    * split; reflexivity.
    * intros L' (v1, vs1); simpl.
      apply derives_view_shift; Exists L'; entailer!.
      apply andp_right; auto; apply prop_right.
      intro; subst.
      assert (L' v = Some x) as Hv by auto; rewrite Hv in *; congruence. }
  Intro X; destruct X as ((v', vs'), L'); simpl; Intros.
  forward.
  Exists v' vs'; rewrite size_def; entailer!.
  split; auto.
  match goal with H : _ -> _ |- _ => specialize (H eq_refl); subst; auto end.
Qed.
