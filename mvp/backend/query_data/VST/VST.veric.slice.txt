Require Import VST.veric.base.
(* VST.veric.base:
Require Export Coq.Arith.EqNat.
Require Export Coq.Relations.Relations.

Require Export compcert.lib.Axioms.
Require Export compcert.lib.Coqlib.
Require Export compcert.lib.Integers.
Require Export compcert.lib.Floats.
Require Export compcert.lib.Maps.
Require Export compcert.common.AST.
Require Export compcert.common.Values.
Require Export compcert.common.Memdata.
Require Export compcert.common.Memtype.
Require Export compcert.common.Memory.
Require Export compcert.common.Globalenvs.

Require Export VST.msl.Coqlib2. 
Require Export VST.veric.coqlib4.

Fixpoint id_in_list (id: ident) (ids: list ident) : bool :=
 match ids with i::ids' => orb (Pos.eqb id i) (id_in_list id ids') | _ => false end.

Fixpoint compute_list_norepet (ids: list ident) : bool :=
 match ids with
 | id :: ids' => if id_in_list id ids' then false else compute_list_norepet ids'
 | nil => true
 end.

Lemma id_in_list_true: forall i ids, id_in_list i ids = true -> In i ids.

Lemma id_in_list_false: forall i ids, id_in_list i ids = false -> ~In i ids.

Lemma compute_list_norepet_e: forall ids,
     compute_list_norepet ids = true -> list_norepet ids.

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Lemma block_eq_dec: forall b1 b2: block, {b1 = b2} + {b1 <> b2}.

Lemma rev_if_be_singleton:
  forall x, rev_if_be (x::nil) = (x::nil).

Lemma rev_if_be_1: forall i, rev_if_be (i::nil) = (i::nil).

Lemma decode_byte_val:
  forall m, decode_val Mint8unsigned (Byte m :: nil) =
              Vint (Int.zero_ext 8 (Int.repr (Byte.unsigned m))).

Lemma Vint_inj: forall x y, Vint x = Vint y -> x=y.

Definition nullval : val := 
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition val_to_bool (v: val) : option bool :=
  match v with
    | Vint n => Some (negb (Int.eq n Int.zero))
    | Vptr _ _ => Some true
    | _ => None
  end.

Definition bool_of_valf (v: val): option bool :=
match v with
  | Vint i => Some (negb (Int.eq i Int.zero))
  | Vlong i => Some (negb (Int64.eq i Int64.zero))
  | Vfloat _ => None
  | Vsingle _ => None
  | Vptr _ _ => Some true
  | Vundef => None
end. *)

Require Import VST.msl.msl_standard.
(* VST.msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import VST.veric.shares.
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)

Require Import VST.veric.compcert_rmaps.
(* VST.veric.compcert_rmaps:
Require Export VST.msl.msl_standard.
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes.
Require Import VST.veric.shares.
Require Import VST.veric.rmaps.
Require Import VST.veric.rmaps_lemmas.
Require Export VST.veric.Memory. 

Instance EqDec_type: EqDec type := type_eq.

Definition funsig := (list (ident*type) * type)%type. 

Inductive kind : Type := VAL : memval -> kind
                                   | LK : forall n i : Z, kind
                                   | FUN: funsig -> calling_convention -> kind.

Definition isVAL (k: kind) := match k with | VAL _ => True | _ => False end.
Definition isFUN (k: kind) := match k with | FUN _ _ => True | _ => False end.

Lemma isVAL_i: forall v, isVAL (VAL v).
Hint Resolve isVAL_i.

Lemma isVAL_dec: forall k, {isVAL k}+{~isVAL k}.

Module CompCert_AV <: ADR_VAL.

Definition address := address.
Definition some_address : address := (xH,0).
Definition kind := kind.

End CompCert_AV.

Lemma getVAL: forall k, {v : memval & k = VAL v}  + {~isVAL k}.

Lemma VAL_inj: forall v v', VAL v = VAL v' -> v = v'.

Module R := Rmaps (CompCert_AV).
Module RML := Rmaps_Lemmas(R).

Export RML.
Export R.

Definition mk_rshare: forall p: Share.t, pure_readable_share p -> rshare := exist pure_readable_share.
Definition rshare_sh (p: rshare) : Share.t := proj1_sig p.

Lemma mk_rshare_sh: forall (p:rshare) (H: pure_readable_share (rshare_sh p)),
  mk_rshare (rshare_sh p) H = p.

Definition fixup_splitting
  (a:address -> Share.t) (z: address -> option (rshare * kind)) : address -> option (rshare * kind) :=
  fun l => 
    match z l with
    | Some (sh, k) =>
       match dec_readable (a l) with
       | left p => Some (readable_part p,  k)
       | right _ => None
       end
    | None => None
    end.

Definition share_of (x: option (rshare * kind)) : Share.t :=
  match x with Some (p,_) => proj1_sig p | None => Share.bot end.

Definition Join_pk := (Join_lower (Join_prod rshare _ kind (Join_equiv _))).

Lemma share_of_Some: forall p: rshare * AV.kind, readable_share (share_of (Some p)).

Lemma join_sub_same_k:
 forall {a a' : rshare} {k k': AV.kind},

Lemma pure_readable_glb_Rsh:
 forall sh, pure_readable_share sh -> Share.glb Share.Rsh sh = sh.

Lemma join_glb_Rsh:  
  forall a b c : Share.t,

Lemma pure_readable_share_glb:
  forall a, pure_readable_share a -> Share.glb Share.Rsh a = a.

Lemma glb_Rsh_bot_unreadable:
  forall a, Share.glb Share.Rsh a = Share.bot -> ~readable_share a.

Lemma fixup_join : forall a (ac ad: address -> Share.t)  z,

Lemma join_share_of: forall a b c,
     @join _ Join_pk a b c -> join (share_of a) (share_of b) (share_of c).

Lemma pure_readable_share_i:
  forall sh, readable_share sh -> (pure_readable_share (Share.glb Share.Rsh sh)).

Obligation Tactic := Tactics.program_simpl.

Lemma pure_readable_Rsh: pure_readable_share Share.Rsh.

Definition rfullshare : rshare := mk_rshare _ pure_readable_Rsh.

Program Definition writable (l: address): pred rmap :=
 fun phi =>
  match phi @ l with
    | YES sh _ k lp => writable0_share sh /\ isVAL k
    | _ => False
  end.

Program Definition readable (loc: address) : pred rmap :=
   fun phi => match phi @ loc with YES _ _ k _ => isVAL k | _ => False end.

Lemma readable_join:
  forall phi1 phi2 phi3 loc, join phi1 phi2 phi3 ->
            readable loc phi1 -> readable loc phi3.

Lemma readable_writable_join:
forall phi1 phi2 l, readable l phi1 -> writable l phi2 -> joins phi1 phi2 -> False.

Lemma writable0_join_sub:
  forall sh sh', join_sub sh sh' -> writable0_share sh -> writable0_share sh'.

Lemma writable_join: forall loc phi1 phi2, join_sub phi1 phi2 ->
            writable loc phi1 -> writable loc phi2.

Lemma writable_readable: forall loc m, writable loc m -> readable loc m.

Lemma writable_e: forall loc m, 
   writable loc m -> 
   exists sh, exists rsh, exists v, exists p, 
     m @ loc = YES sh rsh (VAL v) p /\ writable0_share sh.
Arguments writable_e [loc] [m] _.

Lemma readable_e: forall loc m, 
   readable loc m -> 
  exists sh, exists rsh, exists v, exists p, m @ loc = YES sh rsh (VAL v) p.
Arguments readable_e [loc] [m] _.

Definition bytes_writable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> writable (adr_add loc i) phi.

Definition bytes_readable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> readable (adr_add loc i) phi.

Lemma readable_dec (loc: address) (phi: rmap) : {readable loc phi} + {~readable loc phi}.

Lemma writable_dec: forall loc phi, {writable loc phi}+{~writable loc phi}.

Lemma bytes_writable_dec:
   forall loc n m, {bytes_writable loc n m}+{~bytes_writable loc n m}.

Lemma bytes_readable_dec:
   forall loc n m, {bytes_readable loc n m}+{~bytes_readable loc n m}.

Lemma bytes_writable_readable:
  forall m loc n, bytes_writable m loc n -> bytes_readable m loc n.

Hint Resolve bytes_writable_readable : mem.

Lemma rmap_age_i:
 forall w w' : rmap,
    level w = S (level w') ->
   (forall l, resource_fmap (approx (level w')) (approx (level w')) (w @ l) = w' @ l) ->
    ghost_fmap (approx (level w')) (approx (level w')) (ghost_of w) = ghost_of w' ->
    age w w'. *)

Require Import VST.veric.res_predicates.
(* VST.veric.res_predicates:
Require Import VST.msl.log_normalize.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.  
Require Import VST.veric.shares. 
Require Import VST.veric.address_conflict.

Import RML. Import R.
Local Open Scope pred.

Program Definition kind_at (k: kind) (l: address) : pred rmap :=
   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.

Program Definition yesat_raw (pp: preds) (k: kind) 
                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=
   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

Obligation Tactic := idtac.

Program Definition yesat (pp: preds) (k: kind) : spec :=
 fun (sh: share) (l: AV.address) (m: rmap) =>

Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

Ltac do_map_arg :=
match goal with |- ?a = ?b =>
  match a with context [map ?x _] =>
    match b with context [map ?y _] => replace y with x; auto end end end.

Lemma yesat_raw_eq_aux:
  forall pp k rsh sh l,
    hereditary age
    (fun phi : rmap =>
     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Lemma yesat_raw_eq: yesat_raw =
  fun pp k rsh sh l =>
  ((exist (hereditary age)
   (fun phi =>
   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))
   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Lemma yesat_eq_aux: 
  forall pp k sh l, 
    hereditary age
    (fun m : rmap =>
      exists rsh, 
     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =
     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Lemma yesat_eq: yesat = fun pp k sh l =>
 exist (hereditary age)
  (fun m => 
  exists rsh, 
   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 
   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))
   (yesat_eq_aux pp k sh l).

Lemma map_compose_approx_succ_e:
  forall A n pp pp',
       map (compose (A:=A) (approx (S n))) pp =
    map (compose (A:=A) (approx (S n))) pp' ->
  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Program Definition noat (l: AV.address) : pred rmap :=

Definition resource_share (r: resource) : option share :=
 match r with
 | YES sh _ _ _ => Some sh
 | NO sh _ => Some sh
 | PURE _ _ => None
 end.

Definition nonlock (r: resource) : Prop :=
 match r with
 | YES _ _ k _ => isVAL k \/ isFUN k
 | NO _ _ => True
 | PURE _ _ => False
 end.

Lemma age1_nonlock: forall phi phi' l,
  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Lemma age1_resource_share: forall phi phi' l,
  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  join sh1 sh2 sh ->
  resource_share r = Some sh.

Lemma resource_share_joins: forall r1 r2 sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  joins r1 r2 ->
  joins sh1 sh2.

Lemma nonlock_join: forall r1 r2 r,
  nonlock r1 ->
  nonlock r2 ->
  join r1 r2 r ->
  nonlock r.

Program Definition nonlockat (l: AV.address): pred rmap :=

Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=
  fun (l: B) m => if S l then P l m else Q l m.

Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,
      (forall (x: A), boxy m (P x)) ->
      (forall x, boxy m (Q x)) ->
      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),
      (forall (x: A), boxy extendM (P x)) ->
      (forall x, boxy extendM (Q x)) ->
      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Definition jam_vacuous:
  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),
  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  {w' | level w' = level w /\ resource_at w' =
       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=
  forall l w, (p l) w = q (w @ l) l (level w).

Definition resource_stable (p: address -> pred rmap) :=
  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.

Lemma is_resource_pred_resource_stable: forall {p},
  (exists q, is_resource_pred p q) -> resource_stable p.

Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l})
  (R_DEC: forall l, {R l} + {~ R l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (exists resp, is_resource_pred r resp) ->
  Ensemble_join Q R P ->
  (forall l, Q l -> p l = q l) ->
  (forall l, R l -> p l = r l) ->
  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  allp (jam P_DEC p noat) && noghost =
  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->
  (exists l, P l /\ Q l) ->
  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Lemma yesat_join_diff:
  forall pp pp' k k' sh sh' l w, k <> k' -> 
                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Lemma yesat_raw_join:
  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),
  nonunit x -> join x y z -> nonunit z.

Lemma yesat_join:
  forall pp k sh1 sh2 sh3 l m1 m2 m3,
   join sh1 sh2 sh3 ->   
   yesat pp k sh1 l m1 ->
   yesat pp k sh2 l m2 ->
   join m1 m2 m3 ->
   yesat pp k sh3 l m3.

Definition spec_parametric (Q: address -> spec) : Prop :=
   forall l l', exists pp, exists ok,
             forall sh m,
           Q l sh l' m = 
            (exists p, exists k, ok k /\ m @ l' = 
                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).

Lemma YES_ext:
  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Definition VALspec : spec :=
       fun (sh: Share.t) (l: address) =>
          allp (jam (eq_dec l)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat) && noghost.

Definition VALspec_range (n: Z) : spec :=
     fun (sh: Share.t) (l: address) =>
          andp (allp (jam (adr_range_dec l n)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat)) noghost.

Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=
  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.

Definition nthbyte (n: Z) (l: list memval) : memval :=
     nth (nat_of_Z n) l Undef.

Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address)  => 
             allp (jam (adr_range_dec l (size_chunk ch)) 
                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')
                           noat).

Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address) =>
           EX bl: list memval, 
               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&
                (allp (jam (adr_range_dec l (size_chunk ch))
                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)
                                    noat)) && noghost.

Lemma address_mapsto_align: forall ch v sh l,
  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Lemma address_mapsto_fun:
  forall ch sh sh' l v v',
          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Definition LKspec lock_size (R: pred rmap) : spec :=
   fun (sh: Share.t) (l: AV.address)  =>
    allp (jam (adr_range_dec l lock_size)
               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')
               noat) && noghost.

Definition TTat (l: address) : pred rmap := TT.

Lemma address_mapsto_old_parametric: forall ch v, 
   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Lemma VALspec_parametric: 
  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Lemma LKspec_parametric lock_size: forall R: pred rmap,
  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Definition val2address (v: val) : option AV.address := 
  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.

Lemma VALspec_readable:
  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.

Lemma address_mapsto_VALspec:
  forall ch v sh l i, 0 <= i < size_chunk ch ->
        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Lemma address_mapsto_exists:
  forall ch v sh (rsh: readable_share sh) loc w0
      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

Lemma VALspec1: VALspec_range 1 = VALspec.

Lemma VALspec_range_exp_address_mapsto:
  forall ch sh l,
    (align_chunk ch | snd l) ->
    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Lemma address_mapsto_VALspec_range:
  forall ch v sh l,
        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Lemma approx_eq_i:
  forall (P Q: pred rmap) (w: rmap),
      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},
         laterR (level w) n' ->
       exists w', laterR w w' /\ n' = level w'.

Lemma VALspec_range_bytes_readable:
  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Lemma VALspec_range_bytes_writable:
  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Lemma yesat_join_sub:
  forall pp k l sh m m',
          join_sub m m' ->
          yesat pp k sh l m ->
         exists sh', yesat pp k sh' l m'.

Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Lemma nonlock_permission_bytes_precise: forall sh p n,
  precise (nonlock_permission_bytes sh p n).

Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=
  EX bl: list memval,
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)
  : pred rmap :=
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.
Hint Resolve VALspec_range_0: normalize.

Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,
  ~ nonunit sh ->
  nonlock_permission_bytes sh p n |-- emp.

Lemma is_resource_pred_YES_VAL sh:
  is_resource_pred
    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')
    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_YES_VAL' sh v:
  is_resource_pred
    (fun l' => yesat NoneP (VAL (v l')) sh l')
    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_nonlock_shareat sh:
  is_resource_pred
    (fun i : address => shareat i sh && nonlockat i)
    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Lemma VALspec_range_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma nonlock_permission_bytes_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma VALspec_range_VALspec:
  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,
  adr_range p1 n1 p2 ->
  n2 > 0 ->
  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Lemma address_mapsto_overlap':
  forall sh ch1 v1 ch2 v2 a1 a2,
     adr_range a1 (size_chunk ch1) a2 ->
     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,
  range_overlap l1 n1 l2 n2 ->
  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,
  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->
  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Lemma nonlock_permission_bytes_overlap:
  forall sh n1 n2 p1 p2,
  nonunit sh ->
  range_overlap p1 n1 p2 n2 ->
  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Lemma address_mapsto_value_cohere':
  forall ch v1 v2 sh1 sh2 a r
 (Hmaps1 : address_mapsto ch v1 sh1 a r)
 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Lemma address_mapsto_value_cohere:
  forall ch v1 v2 sh1 sh2 a,
 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Definition almost_empty rm: Prop:=
  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.

Definition no_locks phi :=
  forall addr sh sh' z z' P,
phi @ addr <> YES sh sh' (LK z z') P. *)



Local Open Scope pred.



Definition cleave (sh: share) :=

  (Share.lub (fst (Share.split (Share.glb Share.Lsh sh))) (fst (Share.split (Share.glb Share.Rsh sh))),

   Share.lub (snd (Share.split (Share.glb Share.Lsh sh))) (snd (Share.split (Share.glb Share.Rsh sh)))).



Lemma cleave_join:

 forall sh: share, sepalg.join (fst (cleave sh)) (snd (cleave sh)) sh.

Proof.

intros.

unfold cleave.

destruct (Share.split (Share.glb Share.Lsh sh)) as [a b] eqn:?H.

apply split_join in H.

destruct (Share.split (Share.glb Share.Rsh sh)) as [e f] eqn:?H.

apply split_join in H0.

destruct (Share.split sh) as [c g] eqn:?H.

apply split_join in H1.

simpl.

destruct H1.

subst sh.

destruct H.

destruct H0.

split.

*

rewrite !Share.distrib1.

rewrite !(Share.glb_commute (Share.lub _ _)).

rewrite !Share.distrib1.

rewrite (Share.glb_commute b a), (Share.glb_commute f e).

rewrite H,H0.

rewrite (Share.lub_commute Share.bot).

rewrite !Share.lub_bot.

rewrite Share.distrib2.

rewrite !(Share.lub_commute (Share.glb _ _)).

rewrite !Share.distrib2.

rewrite (Share.lub_commute f e), H3, H2.

rewrite (Share.glb_commute (Share.lub _ _)).

rewrite (Share.glb_assoc Share.Lsh).

rewrite !(Share.glb_assoc Share.Rsh).

rewrite (Share.glb_commute _ (Share.glb Share.Lsh _)).

rewrite (Share.glb_assoc Share.Lsh).

rewrite <- (Share.glb_assoc Share.Rsh).

rewrite (Share.glb_commute Share.Rsh).

rewrite glb_Lsh_Rsh.

rewrite Share.glb_commute. apply Share.glb_bot.

*

rewrite Share.lub_assoc.

rewrite (Share.lub_commute e).

rewrite (Share.lub_assoc b).

rewrite <- Share.lub_assoc.

rewrite H2.

rewrite (Share.lub_commute f e), H3.

clear.

do 2 rewrite (Share.glb_commute _ (Share.lub _ _)).

rewrite <- Share.distrib1.

rewrite lub_Lsh_Rsh.

apply Share.glb_top.

Qed.



Lemma cleave_readable1:

 forall sh, readable_share sh -> readable_share (fst (cleave sh)).

Proof.

intros.

hnf in H|-*. contradict H.

apply identity_share_bot in H.

unfold cleave in H.

simpl in H.

rewrite Share.distrib1 in H.

apply lub_bot_e in H. destruct H as [_ ?].

destruct (Share.split (Share.glb Share.Rsh sh)) as [c d] eqn:H1.

apply (split_nontrivial' _ _ _ H1).

left.

apply split_join in H1.

simpl in *.

destruct (join_parts1 comp_Rsh_Lsh H1).

rewrite <- H0, H.

apply bot_identity.

Qed.



Lemma cleave_readable2:

 forall sh, readable_share sh -> readable_share (snd (cleave sh)).

Proof.

intros.

hnf in H|-*. contradict H.

apply identity_share_bot in H.

unfold cleave in H.

simpl in H.

rewrite Share.distrib1 in H.

apply lub_bot_e in H. destruct H as [_ ?].

destruct (Share.split (Share.glb Share.Rsh sh)) as [c d] eqn:H1.

apply (split_nontrivial' _ _ _ H1).

simpl in *.

right.

apply split_join in H1.

apply join_comm in H1.

simpl in *.

destruct (join_parts1 comp_Rsh_Lsh H1).

rewrite <- H0, H.

apply bot_identity.

Qed.



Lemma rshare_sh_readable:

 forall r, readable_share (rshare_sh r).

Proof.

destruct r; simpl.

destruct p;

auto.

Qed.



Lemma cleave_nonreadable1:

  forall sh, ~readable_share sh -> ~ readable_share (fst (cleave sh)).

Proof.

intros.

contradict H.

do 3 red in H|-*.

contradict H.

unfold cleave. simpl.

apply identity_share_bot in H.

rewrite H. clear H.

destruct (Share.split Share.bot) as [a b] eqn:?H.

apply split_join in H.

simpl.

apply split_identity in H; [ | apply bot_identity].

apply identity_share_bot in H. subst.

rewrite Share.lub_bot.

clear.

destruct (Share.split (Share.glb Share.Lsh sh)) as [a b] eqn:H.

apply split_join in H.

simpl.

replace (Share.glb Share.Rsh a) with Share.bot.

apply bot_identity.

symmetry.

destruct H.

apply (f_equal (Share.glb Share.Rsh)) in H0.

rewrite <- Share.glb_assoc in H0.

rewrite (Share.glb_commute _ Share.Lsh) in H0.

rewrite glb_Lsh_Rsh in H0.

rewrite (Share.glb_commute Share.bot) in H0.

rewrite Share.glb_bot in H0.

rewrite Share.distrib1 in H0.

apply lub_bot_e in H0. destruct H0 as [? _].

auto.

Qed.



Lemma cleave_nonreadable2:

  forall sh, ~readable_share sh -> ~ readable_share (snd (cleave sh)).

Proof.

intros.

contradict H.

do 3 red in H|-*.

contradict H.

unfold cleave. simpl.

apply identity_share_bot in H.

rewrite H. clear H.

destruct (Share.split Share.bot) as [a b] eqn:?H.

apply split_join in H.

simpl.

apply join_comm in H.

apply split_identity in H; [ | apply bot_identity].

apply identity_share_bot in H. subst.

rewrite Share.lub_bot.

clear.

destruct (Share.split (Share.glb Share.Lsh sh)) as [a b] eqn:H.

apply split_join in H.

simpl.

replace (Share.glb Share.Rsh b) with Share.bot.

apply bot_identity.

symmetry.

destruct H.

apply (f_equal (Share.glb Share.Rsh)) in H0.

rewrite <- Share.glb_assoc in H0.

rewrite (Share.glb_commute _ Share.Lsh) in H0.

rewrite glb_Lsh_Rsh in H0.

rewrite (Share.glb_commute Share.bot) in H0.

rewrite Share.glb_bot in H0.

rewrite Share.lub_commute in H0.

rewrite Share.distrib1 in H0.

apply lub_bot_e in H0. destruct H0 as [? _].

auto.

Qed.



Definition split_resource r :=

  match r with YES sh rsh k pp => 

               (YES (fst (cleave sh)) (cleave_readable1 _ rsh) k pp , 

                YES (snd (cleave sh)) (cleave_readable2 _ rsh) k pp)

             | PURE k pp => (PURE k pp, PURE k pp)

             | NO sh nsh => (NO (fst (cleave sh)) (cleave_nonreadable1 _ nsh),

                             NO (snd (cleave sh)) (cleave_nonreadable2 _ nsh))

  end.



Lemma glb_cleave_lemma1: forall sh0 sh,

  Share.glb Share.Rsh sh0 = Share.glb Share.Rsh sh ->

 Share.glb Share.Rsh (fst (cleave sh0)) =

 Share.glb Share.Rsh (fst (cleave sh)).

Proof.

intros.

unfold cleave; simpl.

destruct (Share.split (Share.glb Share.Lsh sh0)) as [a0 b0]  eqn:H0.

apply split_join in H0.

destruct (Share.split (Share.glb Share.Lsh sh)) as [a b]  eqn:H1.

apply split_join in H1.

destruct (Share.split (Share.glb Share.Rsh sh0)) as [c0 d0]  eqn:H2.

rewrite H in H2. rewrite H2.

simpl.

apply split_join in H2.

rewrite !Share.distrib1.

apply (join_parts1 comp_Lsh_Rsh) in H1.

destruct H1 as [_ ?]. rewrite H1.

apply (join_parts1 comp_Lsh_Rsh) in H0.

destruct H0 as [_ ?]. rewrite H0.

auto.

Qed.



Lemma glb_cleave_lemma2: forall sh0 sh,

  Share.glb Share.Rsh sh0 = Share.glb Share.Rsh sh ->

 Share.glb Share.Rsh (snd (cleave sh0)) =

 Share.glb Share.Rsh (snd (cleave sh)).

Proof.

intros.

unfold cleave; simpl.

destruct (Share.split (Share.glb Share.Lsh sh0)) as [a0 b0]  eqn:H0.

apply split_join in H0.

destruct (Share.split (Share.glb Share.Lsh sh)) as [a b]  eqn:H1.

apply split_join in H1.

apply join_comm in H0.

apply join_comm in H1.

destruct (Share.split (Share.glb Share.Rsh sh0)) as [c0 d0]  eqn:H2.

rewrite H in H2. rewrite H2.

simpl.

apply split_join in H2.

rewrite !Share.distrib1.

apply (join_parts1 comp_Lsh_Rsh) in H1.

destruct H1 as [_ ?]. rewrite H1.

apply (join_parts1 comp_Lsh_Rsh) in H0.

destruct H0 as [_ ?]. rewrite H0.

auto.

Qed.



Lemma split_rmap_ok1: forall m,

  resource_fmap (approx (level m)) (approx (level m)) oo (fun l => fst (split_resource (m @ l))) =

       (fun l => fst (split_resource (m @ l))).

Proof.

intros.

extensionality l; unfold compose; simpl.

case_eq (m@l); simpl; intros; auto.

generalize (eq_sym (resource_at_approx m l)); intro.

pattern (m@l) at 2 in H0; rewrite H in H0.

simpl in H0.

rewrite H in H0.

inversion H0.

rewrite <- H2.

rewrite <- H2.

auto.

generalize (eq_sym (resource_at_approx m l)); intro.

pattern (m@l) at 2 in H0; rewrite H in H0.

simpl in H0.

rewrite H in H0.

inversion H0.

rewrite <- H2.

rewrite <- H2.

auto.

Qed.



Lemma split_rmap_ok2: forall m,

  resource_fmap (approx (level m)) (approx (level m)) oo (fun l => snd (split_resource (m @ l))) =

       (fun l => snd (split_resource (m @ l))).

Proof.

intros.

extensionality l; unfold compose; simpl.

case_eq (m@l); simpl; intros; auto.

generalize (eq_sym (resource_at_approx m l)); intro.

pattern (m@l) at 2 in H0; rewrite H in H0.

simpl in H0.

rewrite H in H0.

inversion H0.

rewrite <- H2.

rewrite <- H2.

auto.

generalize (eq_sym (resource_at_approx m l)); intro.

pattern (m@l) at 2 in H0; rewrite H in H0.

simpl in H0.

rewrite H in H0.

inversion H0.

rewrite <- H2.

rewrite <- H2.

auto.

Qed.



Lemma split_resource_join: 

  forall r, join (fst (split_resource r)) (snd (split_resource r)) r.

Proof.

intro.

destruct r; simpl; constructor; auto; try (apply cleave_join; apply surjective_pairing).

Qed.



Definition split_shareval (shv: Share.t * val) : ((Share.t * val) * (Share.t * val)) :=

  ((fst (Share.split (fst shv)), snd shv), (snd (Share.split (fst shv)), snd shv)).



Definition slice_resource (sh: share) (r: resource) : resource :=

  match r with

   | NO _ _ => NO (retainer_part sh) (retainer_part_nonreadable sh)

   | YES _ _ k pp =>

    match readable_share_dec sh with

    | left r1 => YES sh r1 k pp

    | right n => NO sh n

    end

   | PURE k pp => PURE k pp

  end.



Lemma make_slice_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}) sh,

  (forall l : AV.address, ~ P l -> identity (w @ l)) ->

  {w' | level w' = level w /\ resource_at w' =

       (fun l => if P_DEC l then slice_resource sh (w @ l) else w @ l) /\

       ghost_of w' = ghost_of w}.

Proof.

  intros.

  pose (f l := if P_DEC l then slice_resource sh (w @ l) else w @ l).

  apply (make_rmap _ (ghost_of w) (level w)).

  extensionality loc; unfold compose, f.

  destruct (P_DEC loc).

  + pose proof resource_at_approx w loc.

    destruct (w @ loc); auto.

    simpl.

    destruct (readable_share_dec sh); auto.

    inversion H0.

    simpl; f_equal; f_equal; auto.

  + apply resource_at_approx.

  + apply ghost_of_approx.

Qed.



Lemma jam_noat_splittable_aux:

  forall S' S Q (PARAMETRIC: spec_parametric Q)

           (sh1 sh2 sh3: share)

           (rsh1: readable_share sh1) (rsh2: readable_share sh2)

           l

           (H: join sh1 sh2 sh3)

           w (H0: allp (@jam _ _ _ _ _ _ (S' l) (S l) (Q l sh3) noat) w)

           f (Hf: resource_at f = fun loc => slice_resource (if S l loc then sh1 else Share.bot) (w @ loc))

           g (Hg: resource_at g = fun loc => slice_resource (if S l loc then sh2 else Share.bot) (w @ loc))

           (H1: join f g w),

           allp (jam (S l) (Q l sh1) noat) f.

Proof.

intros.



intro l'.

specialize ( H0 l').

unfold jam in H0 |- *.

simpl in H0|-*.

if_tac.

destruct (PARAMETRIC l l') as [pp [ok ?]]; clear PARAMETRIC.

rewrite H3 in H0 |- *; clear H3.

destruct H0 as [rsh3 [k [? ?]]].

exists rsh1, k; split; auto.

clear H0.

case_eq (w @ l'); intros.

inversion2 H0 H3. 

destruct p.

inversion2 H0 H3.

generalize (resource_at_join _ _ _ l' H1); intro.

generalize (f_equal (resource_at f) (refl_equal l')); intro.

pattern f at 1 in H4; rewrite Hf in H4.

rewrite H0 in H4.

rewrite H4.

rewrite if_true in H4|-* by auto.

simpl.

destruct (readable_share_dec sh1); [ | contradiction].

replace (level f) with (level w). 

rewrite H7.

f_equal. apply proof_irr.

apply join_level in H1; intuition.

congruence.



generalize (resource_at_join _ _ _ l' H1); intro.

apply split_identity in H3; auto.

Qed.



Lemma slice_resource_identity:

  forall r, identity r -> slice_resource Share.bot r = r.

Proof.

 intros.

 destruct r; simpl in *; auto.

 assert (sh = retainer_part Share.bot).

   unfold retainer_part. rewrite Share.glb_bot.

   apply identity_NO in H.

   destruct H as [|]. inv H. auto. destruct H as [? [? ?]]. inv H.

   subst; f_equal. apply proof_irr.

   apply YES_not_identity in H. contradiction.

Qed.



Definition splittable {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} (Q: Share.t -> pred A) := 

  forall (sh1 sh2 sh3: Share.t) (rsh1: readable_share sh1) (rsh2: readable_share sh2),

    join sh1 sh2 sh3 ->

    Q sh1 * Q sh2 = Q sh3.



Definition share_oblivious (P: pred rmap) :=

  forall w w',

   (forall l, match w' @ l , w @ l with

                 | NO _ _, NO _ _ => True

                 | YES _ sh1 k1 p1 , YES _ sh2 k2 p2 => k1=k2 /\ p1=p2

                 | PURE k1 p1, PURE k2 p2 => k1=k2 /\ p1=p2

                 | _ , _ => False

                 end) ->

     P w' -> P w.



Lemma not_readable_share_retainer_part_eq:

  forall sh, ~ readable_share sh -> retainer_part sh = sh.

   intros.

    apply not_not_share_identity in H.

    unfold retainer_part.

    rewrite (comp_parts comp_Lsh_Rsh sh) at 2.

    apply identity_share_bot in H; rewrite H.

    rewrite Share.lub_bot. auto.

Qed.



Lemma slice_resource_resource_share: forall r sh sh',

  resource_share r = Some sh ->

  join_sub sh' sh ->

  resource_share (slice_resource sh' r) = Some sh'.

Proof.

  intros.

  destruct r; inv H; unfold slice_resource; simpl.

  + f_equal.

    assert (~readable_share sh'). contradict n. destruct H0.

    eapply join_readable1; eauto.

    apply not_readable_share_retainer_part_eq; auto.

  + destruct (readable_share_dec sh'); simpl; auto.

Qed.



Lemma slice_resource_nonlock: forall r sh sh',

  resource_share r = Some sh ->

  join_sub sh' sh ->

  nonlock r ->

  nonlock (slice_resource sh' r).

Proof.

  intros.

  destruct r; inv H; unfold slice_resource; simpl; auto.

  destruct (readable_share_dec sh'); simpl; auto.

Qed.



Lemma NO_ext: forall sh1 sh2 rsh1 rsh2, sh1=sh2 -> NO sh1 rsh1 = NO sh2 rsh2.

Proof. intros. subst sh1. f_equal. apply proof_irr. Qed.



Lemma join_sub_is_slice_resource: forall r r' sh',

  join_sub r' r ->

  resource_share r' = Some sh' ->

  r' = slice_resource sh' r.

Proof.

  intros.

  destruct H as [r'' ?].

  destruct r, r'; inv H; inv H0; simpl.

  + f_equal.

    clear - n0.

    apply NO_ext. symmetry.

    rewrite not_readable_share_retainer_part_eq; auto.

  + destruct (readable_share_dec sh'); [ contradiction |].

    apply NO_ext; auto.

  + destruct (readable_share_dec sh'); [| contradiction ].

    f_equal. apply proof_irr.

  + destruct (readable_share_dec sh'); [| contradiction ].

    f_equal. apply proof_irr.

Qed.



Lemma slice_resource_share_join: forall sh1 sh2 sh r,

  join sh1 sh2 sh ->

  resource_share r = Some sh ->

  join (slice_resource sh1 r) (slice_resource sh2 r) r.

Proof.

  intros.

  destruct r; simpl in *.

*

  constructor. inv H0.

  assert (~readable_share sh1) by (contradict n; eapply join_readable1; eauto).

  assert (~readable_share sh2) by (contradict n; eapply join_readable2; eauto).

  rewrite !(not_readable_share_retainer_part_eq); auto.

*

  inv H0.

  destruct (readable_share_dec sh1), (readable_share_dec sh2);

  try (constructor; auto).

  contradiction (join_unreadable_shares H n n0).

*

  constructor.

Qed.



Definition resource_share_split (p q r: address -> pred rmap): Prop :=

  exists p' q' r' p_sh q_sh r_sh,

    is_resource_pred p p' /\

    is_resource_pred q q' /\

    is_resource_pred r r' /\

    join q_sh r_sh p_sh /\

    (forall res l n, p' res l n ->

      resource_share res = Some p_sh /\

      q' (slice_resource q_sh res) l n /\

      r' (slice_resource r_sh res) l n) /\

    (forall p_res q_res r_res l n,

      join q_res r_res p_res ->

      q' q_res l n ->

      r' r_res l n ->

      p' p_res l n).



Lemma allp_jam_share_split: forall (P: address -> Prop) (p q r: address -> pred rmap)

  (P_DEC: forall l, {P l} + {~ P l}),

  resource_share_split p q r ->

  allp (jam P_DEC p noat) && noghost =

  (allp (jam P_DEC q noat) && noghost) * (allp (jam P_DEC r noat) && noghost).

Proof.

  intros.

  destruct H as [p' [q' [r' [p_sh [q_sh [r_sh [? [? [? [? [? ?]]]]]]]]]]].

  apply pred_ext; intros w; simpl; intros.

  + destruct H5 as [H5 Hg].

    destruct (make_slice_rmap w P P_DEC q_sh) as [w1 [? ?]].

    {

      intros; specialize (H5 l).

      rewrite if_false in H5 by auto.

      auto.

    }

    destruct (make_slice_rmap w P P_DEC r_sh) as [w2 [? ?]].

    {

      intros; specialize (H5 l).

      rewrite if_false in H5 by auto.

      auto.

    }

    exists w1, w2.

    split3.

    - apply resource_at_join2; try congruence.

      intro l.

      destruct H7, H9; rewrite H7, H9; clear H7 H9.

      specialize (H5 l); destruct (P_DEC l).

      * eapply slice_resource_share_join; eauto.

        rewrite H in H5.

        apply H3 in H5.

        tauto.

      * apply identity_unit' in H5.

        exact H5.

      * destruct H7 as [? ->], H9 as [? ->].

        apply identity_unit'; auto.

    - destruct H7 as [H7 ->]; split; auto.

      intros l.

      rewrite H0, H7, H6.

      specialize (H5 l).

      rewrite H in H5.

      if_tac.

      * apply H3 in H5.

        tauto.

      * auto.

    - destruct H9 as [H9 ->]; split; auto.

      intros l.

      rewrite H1, H9, H8.

      specialize (H5 l).

      rewrite H in H5.

      if_tac.

      * apply H3 in H5.

        tauto.

      * auto.

  + destruct H5 as [y [z [? [? ?]]]].

    destruct H6 as [? Hg1], H7 as [? Hg2]; split.

    intro b; specialize (H6 b); specialize (H7 b).

    if_tac.

    - rewrite H; rewrite H0 in H6; rewrite H1 in H7.

      destruct (join_level _ _ _ H5).

      rewrite H9 in H6; rewrite H10 in H7.

      eapply H4; eauto.

      apply resource_at_join; auto.

    - apply resource_at_join with (loc := b) in H5.

      apply H6 in H5; rewrite <- H5; auto.

    - rewrite <- (Hg1 _ _ (ghost_of_join _ _ _ H5)); auto.

Qed.



Lemma address_mapsto_share_join:

 forall (sh1 sh2 sh : share) ch v a,

   join sh1 sh2 sh ->

   readable_share sh1 -> readable_share sh2 ->

   address_mapsto ch v sh1 a * address_mapsto ch v sh2 a 

    = address_mapsto ch v sh a.

Proof.

  intros ? ? ? ? ? ? H rsh1 rsh2.



  symmetry.

  unfold address_mapsto.

  transitivity

   (EX  bl : list memval,

    !!(length bl = size_chunk_nat ch /\

       decode_val ch bl = v /\ (align_chunk ch | snd a)) &&

   ((allp

      (jam (adr_range_dec a (size_chunk ch))

         (fun loc : address =>

          yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd a)) bl Undef)) sh1

            loc) noat) && noghost) *

    (allp

      (jam (adr_range_dec a (size_chunk ch))

         (fun loc : address =>

          yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd a)) bl Undef)) sh2

            loc) noat) && noghost))).

  + pose proof log_normalize.exp_congr (pred rmap) _ (list memval).

    simpl in H0.

    apply H0; clear H0.

    intros b.

    rewrite !andp_assoc; f_equal.

    apply allp_jam_share_split.

    do 3 eexists.

    exists sh, sh1, sh2.

    split; [| split; [| split; [| split; [| split]]]].

    - apply is_resource_pred_YES_VAL'.

    - apply is_resource_pred_YES_VAL'.

    - apply is_resource_pred_YES_VAL'.

    - auto.

    - simpl; intros.

      destruct H0.

      split; [subst; auto |].

      split.

      * exists rsh1.

        subst; simpl.

        destruct (readable_share_dec sh1); [| contradiction].

        f_equal.

        auto with extensionality.

      * exists rsh2.

        subst; simpl.

        destruct (readable_share_dec sh); [| contradiction].

        destruct (readable_share_dec sh2); [| contradiction].

        f_equal.

        auto with extensionality. 

    - simpl; intros.

      destruct H1,H2. repeat proof_irr.

      exists (join_readable1 H rsh1).

      subst.

      inv H0.

      apply YES_ext.

      eapply join_eq; eauto.

  + apply pred_ext.

    - apply exp_left; intro bl.

      apply prop_andp_left; intro.

      rewrite exp_sepcon1.

      apply (exp_right bl).

      rewrite exp_sepcon2.

      apply (exp_right bl).

      rewrite andp_assoc, sepcon_andp_prop1.

      apply andp_right; [intros w _; simpl; auto |].

      rewrite andp_assoc, sepcon_andp_prop.

      apply andp_right; [intros w _; simpl; auto |].

      auto.

    - rewrite exp_sepcon1.

      apply exp_left; intro bl1.

      rewrite exp_sepcon2.

      apply exp_left; intro bl2.

      rewrite andp_assoc, sepcon_andp_prop1.

      apply prop_andp_left; intro.

      rewrite andp_assoc, sepcon_andp_prop.

      apply prop_andp_left; intro.

      apply (exp_right bl1).

      apply andp_right; [intros w _; simpl; auto |].

      intros w ?.

      destruct H2 as [w1 [w2 [? [? ?]]]].

      exists w1, w2.

      split; [| split]; auto.

      destruct H4 as [H4 Hg]; split; auto.

      intro l; destruct H3; specialize (H3 l); specialize (H4 l).

      simpl in H3, H4 |- *.

      if_tac; auto.

      destruct H3, H4. exists rsh2.

      apply resource_at_join with (loc := l) in H2.

      rewrite H3, H4 in H2; inv H2.

      rewrite H12. rewrite H4. apply YES_ext. auto.

Qed.



Lemma nonlock_permission_bytes_address_mapsto_join:

 forall (sh1 sh2 sh : share) ch v a,

   join sh1 sh2 sh ->

   readable_share sh2 ->

   nonlock_permission_bytes sh1 a (Memdata.size_chunk ch)

     * address_mapsto ch v sh2 a 

    = address_mapsto ch v sh a.

Proof.

intros. rename H0 into rsh2.

unfold nonlock_permission_bytes, address_mapsto.

rewrite exp_sepcon2.

f_equal. extensionality bl.

rewrite !andp_assoc, sepcon_andp_prop.

f_equal.

apply pred_ext.

*

 intros z [x [y [? [? ?]]]].

 destruct H1 as [H1 Hg1], H2 as [H2 Hg2]; split.

 intro b; specialize (H1 b); specialize (H2 b).

 pose proof (resource_at_join _ _ _ b H0).

 hnf in H1,H2|-*.

 if_tac.

 +

  destruct H2 as [p ?].

  hnf in H2. rewrite H2 in *. clear H2.

  destruct H1 as [H1 H1'].

  hnf in H1, H1'. unfold resource_share in H1.

  assert (p8 := join_readable2 H p).

  exists p8.

  destruct (x @ b); inv H1.

  -

    inv H3.

    pose proof (join_eq H RJ); subst sh4. clear RJ.

    hnf. rewrite <- H8; clear H8.

    f_equal. apply proof_irr.

  -

   clear H1'.  inv H3. 

   hnf. rewrite <- H10. clear H10. simpl.

    pose proof (join_eq H RJ); subst sh4. clear RJ.

   f_equal. apply proof_irr.

 +

   do 3 red in H1,H2|-*. 

   apply join_unit1_e in H3; auto.

   rewrite <- H3; auto.

 + simpl; rewrite <- (Hg1 _ _ (ghost_of_join _ _ _ H0)); auto.

*

  assert (rsh := join_readable2 H rsh2).

  intros w ?.

  destruct H0 as [H0 Hg]; hnf in H0.

  destruct (make_slice_rmap w _ (adr_range_dec a (size_chunk ch)) sh1)

   as [w1 [? ?]].

  intros. specialize (H0 l). simpl in H0. rewrite if_false in H0; auto. 

  destruct (make_slice_rmap w _ (adr_range_dec a (size_chunk ch)) sh2)

   as [w2 [? ?]].

  intros. specialize (H0 l). simpl in H0. rewrite if_false in H0; auto. 

  exists w1, w2.

  destruct H2 as [H2 Hg1], H4 as [H4 Hg2].

  split3.

 +

   eapply resource_at_join2; try omega.

  intro . rewrite H2,H4. clear dependent w1. clear dependent w2.

  specialize (H0 loc). hnf in H0.  

  if_tac in H0. destruct H0 as [rsh' H0]. proof_irr. rewrite H0.

  unfold slice_resource.

  destruct (readable_share_dec sh2); [ | contradiction]. proof_irr.

  destruct (readable_share_dec sh1).

  constructor; auto.

  constructor; auto.

  do 3 red in H0.

  apply identity_unit' in H0. apply H0.

  rewrite Hg1, Hg2; apply identity_unit'; auto.

 +

   split.

   intro loc; hnf. simpl. rewrite H2.

  clear dependent w1. clear dependent w2.

  specialize (H0 loc). hnf in H0.  

  if_tac in H0.

  -

   destruct H0. proof_irr. rewrite H0.

   unfold slice_resource.

   destruct (readable_share_dec sh1).

   simpl. split; auto.

   split; simpl; auto.

  -

   apply H0.

  - simpl; rewrite Hg1; auto.

 + split.

   intro loc; hnf. simpl. rewrite H4.  simpl.

  clear dependent w1. clear dependent w2.

  specialize (H0 loc). hnf in H0.  

  if_tac in H0.

  -

   exists rsh2.

   destruct H0 as [p0 H0]. proof_irr. simpl in H0.

   rewrite H0. clear H0. simpl.

   destruct (readable_share_dec sh2); [ | contradiction]. proof_irr.

   reflexivity.

 - apply H0.

 - simpl; rewrite Hg2; auto.

Qed.



Lemma VALspec_range_share_join:

 forall sh1 sh2 sh n p,

  readable_share sh1 ->

  readable_share sh2 ->

  join sh1 sh2 sh ->

  VALspec_range n sh1 p *

  VALspec_range n sh2 p =

  VALspec_range n sh p.

Proof.

  intros.

  symmetry.

  apply allp_jam_share_split.

  do 3 eexists.

  exists sh, sh1, sh2. 

  split; [| split; [| split; [| split; [| split]]]].

  + apply is_resource_pred_YES_VAL.

  + apply is_resource_pred_YES_VAL.

  + apply is_resource_pred_YES_VAL.

  + auto.

  + simpl; intros.

    destruct H2 as [x [rsh ?]].

    split; [subst; simpl; auto |].

    split; [exists x, H | exists x, H0].

    - subst. simpl.

      destruct (readable_share_dec sh1); [ | contradiction].

      f_equal. apply proof_irr.

    - subst. simpl.

      destruct (readable_share_dec sh2); [ | contradiction].

      f_equal. apply proof_irr.

  + simpl; intros.

    destruct H3 as [? [? ?]], H4 as [? [? ?]].

    exists x. exists (join_readable1 H1 H).

    subst.

    inv H2. apply YES_ext. eapply join_eq; eauto.

Qed.



Lemma nonlock_permission_bytes_share_join:

 forall sh1 sh2 sh a n,

  join sh1 sh2 sh ->

  nonlock_permission_bytes sh1 a n *

  nonlock_permission_bytes sh2 a n =

  nonlock_permission_bytes sh a n.

Proof.

  intros.

  symmetry.

  apply allp_jam_share_split.

  do 3 eexists.

  exists sh, sh1, sh2.

  split; [| split; [| split; [| split; [| split]]]].

  + apply is_resource_pred_nonlock_shareat.

  + apply is_resource_pred_nonlock_shareat.

  + apply is_resource_pred_nonlock_shareat.

  + auto.

  + simpl; intros.

    destruct H0.

    split; [auto |].

    split; split.

    - eapply slice_resource_resource_share; [eauto | eexists; eauto ].

    - eapply slice_resource_nonlock; [eauto | eexists; eauto | auto].

    - eapply slice_resource_resource_share; [eauto | eexists; eapply join_comm; eauto].

    - eapply slice_resource_nonlock; [eauto | eexists; eapply join_comm; eauto | auto].

  + simpl; intros.

    destruct H1, H2.

    split.

    - eapply (resource_share_join q_res r_res); eauto.

    - eapply (nonlock_join q_res r_res); eauto.

Qed.



Lemma nonlock_permission_bytes_VALspec_range_join:

 forall sh1 sh2 (rsh2: readable_share sh2) sh p n,

  join sh1 sh2 sh ->

  nonlock_permission_bytes sh1 p n *

  VALspec_range n sh2 p =

  VALspec_range n sh p.

Proof.

  intros.

  symmetry.

  apply allp_jam_share_split.

  do 3 eexists.

  exists sh, sh1, sh2.

  split; [| split; [| split; [| split; [| split]]]].

  + apply is_resource_pred_YES_VAL.

  + apply is_resource_pred_nonlock_shareat.

  + apply is_resource_pred_YES_VAL.

  + auto.

  + simpl; intros.

    destruct H0 as [? [? ?]]; subst; split; [| split; [split |]].

    - simpl; auto.

    - simpl.

      destruct (readable_share_dec sh1); reflexivity.

    - simpl.

      destruct (readable_share_dec sh1); simpl; auto.

    - simpl.

      exists x, rsh2.

      destruct (readable_share_dec sh2); [ | contradiction].

      apply YES_ext. auto.

  + simpl; intros.

    destruct H2 as [? [? ?]].

    subst. proof_irr.

    exists x, (join_readable2 H rsh2).

    destruct H1.

    destruct q_res; simpl in H1.

    - inversion H0; subst. inv H1.

      apply YES_ext.

      eapply join_eq; eauto.

    - inv H1. inv H0. apply YES_ext. eapply join_eq; eauto.

    - inv H1.

Qed.



Lemma is_resource_pred_YES_LK lock_size (l: address) (R: pred rmap) sh:

  is_resource_pred

    (fun l' => yesat (SomeP rmaps.Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')

    (fun r (l': address) n => exists p, r = YES sh p (LK lock_size (snd l' - snd l))

        (SomeP rmaps.Mpred (fun _ => approx n R))).

Proof. hnf; intros. reflexivity. Qed.



Lemma LKspec_share_join lock_size:

 forall sh1 sh2 (rsh1: readable_share sh1) (rsh2: readable_share sh2) sh R p,

  join sh1 sh2 sh ->

  LKspec lock_size R sh1 p *

  LKspec lock_size R sh2 p =

  LKspec lock_size R sh p.

Proof.

  intros.

  symmetry.

  unfold LKspec.

  apply allp_jam_share_split.

  do 3 eexists.

  exists sh, sh1, sh2.

  split; [| split; [| split; [| split; [| split]]]].

  + apply is_resource_pred_YES_LK.

  + apply is_resource_pred_YES_LK.

  + apply is_resource_pred_YES_LK.

  + auto.

  + simpl; intros.

    destruct (eq_dec p l); subst; destruct H0; split; try solve [subst; simpl; auto];

    split.

    - exists rsh1. subst. simpl.

      destruct (readable_share_dec sh1); [ | contradiction].

      apply YES_ext; auto.

    - exists rsh2. subst. simpl.

      destruct (readable_share_dec sh2); [ | contradiction].

      apply YES_ext; auto.

    - exists rsh1. subst. simpl.

      destruct (readable_share_dec sh1); [ | contradiction].

      apply YES_ext; auto.

    - exists rsh2. subst. simpl.

      destruct (readable_share_dec sh2); [ | contradiction].

      apply YES_ext; auto.

  + simpl; intros.

    destruct (eq_dec p l); subst; destruct H1, H2. repeat proof_irr.

    - exists (join_readable1 H rsh1). subst. inv H0. apply YES_ext.

      eapply join_eq; eauto.

    - exists (join_readable1 H rsh1). subst. inv H0. apply YES_ext.

      eapply join_eq; eauto.

Qed.
