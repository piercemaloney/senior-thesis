Require Import AggregateType.demo2.expr.
Require Import AggregateType.demo2.computable_theorems.

Module TypeTree.
Section TypeTree.

Context {cs: compspecs}.

Definition typeR (t1: type) (t2: type): Prop :=
  match t2 with
  | Tstruct sid => exists i1, In (i1, t1) (co_members (get_co sid))
  | _ => False
  end.

Lemma wf_typeR: well_founded typeR.
Proof.
  hnf; intro t.
  remember (rank_type cenv_cs t) eqn:?H.
  pose proof le_n n.
  rewrite H in H0 at 1; clear H.
  revert t H0; induction n; intros.
  + constructor; intros.
    destruct t.
    - inversion H.
    - destruct H as [yid ?].
      unfold get_co in H.
      cbv [rank_type] in H0; simpl in H0.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [inversion H0 |].
      simpl in H; inversion H.
  + constructor; intros.
    destruct t.
    - inversion H.
    - destruct H as [yid ?].
      unfold get_co in H.
      cbv [rank_type] in H0; simpl in H0.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [| inversion H].
      apply rank_type_members with (ce := cenv_cs) in H.
      pose proof co_consistent_rank _ _ (cenv_consistent id c Heqo).
      rewrite <- H1 in H.
      apply le_S_n in H0.
      apply IHn.
      apply le_trans with (co_rank c); assumption.
Defined.

End TypeTree.
End TypeTree.

Module RankLt.
Section RankLt.

Context {cs: compspecs}.

Definition typeR (t1: type) (t2: type): Prop := (rank_type cenv_cs t1 < rank_type cenv_cs t2)%nat.

Lemma wf_typeR: well_founded typeR.
Proof.
  hnf; intro t.
  remember (rank_type cenv_cs t) eqn:?H.
  pose proof le_n n.
  rewrite H in H0 at 1; clear H.
  revert t H0; induction n; intros.
  + constructor; intros.
    unfold typeR in H.
    pose proof le_trans _ _ _ H H0.
    inversion H1.
  + constructor; intros.
    destruct t.
    - inversion H.
    - unfold typeR in H.
      simpl in *.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [| inversion H].
      pose proof le_trans _ _ _ H H0.
      apply le_S_n in H1.
      apply IHn; auto.
Defined.

End RankLt.
End RankLt.

Module RankInd.
Section RankInd.

Context {cs: compspecs}.

Lemma type_ind: forall P : type -> Prop,
  (forall t,
  match t with
  | Tstruct id => let m := co_members (get_co id) in Forall (fun it => P (snd it)) m
  | _ => True
  end -> P t) ->
  forall t, P t.
Proof.
  intros P IH_TYPE.
  intros.
  remember (rank_type cenv_cs t) as n eqn: RANK'.
  assert (rank_type cenv_cs t <= n)%nat as RANK.
  subst. apply le_n.
  clear RANK'.
  revert t RANK.
  induction n;
  intros;
  specialize (IH_TYPE t); destruct t;
  try solve [specialize (IH_TYPE I); auto].
  + 
    simpl in RANK.
    unfold get_co in IH_TYPE.
    destruct (Maps.PTree.get id cenv_cs); [inv RANK | apply IH_TYPE; simpl; constructor].
  + 
    simpl in RANK.
    pose proof I. 
    unfold get_co in *.
    destruct (Maps.PTree.get id cenv_cs) as [co |] eqn:CO; [| apply IH_TYPE; simpl; constructor].
    apply IH_TYPE; clear IH_TYPE.
    apply Forall_forall.
    intros [i0 t0] ?; simpl.
    apply IHn.
    pose proof rank_type_members _ _ _ _ H0.
    eapply le_trans; [eassumption |].
    apply le_S_n; auto.
    rewrite <- co_consistent_rank; auto.
    exact (cenv_consistent id co CO).
Defined.

End RankInd.

Ltac type_induction t :=
  pattern t;
  match goal with
  | |- ?P t =>
    apply type_ind; clear t;
    let t := fresh "t" in
    intros t IH;
    let id := fresh "id" in
    destruct t as [ | id]
  end.

End RankInd.

Module Fix_TypeTree.
Section Fix_TypeTree.

Context {cs: compspecs}.

Lemma typeR_spec_members_aux: forall (m : members),
  Forall (fun p : ident * type => exists i1 : ident, In (i1, snd p) m) m.
Proof.
  intros.
  induction m.
  + constructor.
  + destruct a.
    constructor.
    - exists i; left; auto.
    - revert IHm; apply Forall_impl.
      intros.
      destruct H as [i1 ?].
      exists i1.
      right; auto.
Defined.

Definition typeR_spec_members sid: Forall (fun p => TypeTree.typeR (snd p) (Tstruct sid)) (co_members (get_co sid)) :=
  typeR_spec_members_aux (co_members (get_co sid)).

Definition typeR_spec (t: type):
  match t with
  | Tint => True
  | Tstruct sid => Forall (fun p => TypeTree.typeR (snd p) t) (co_members (get_co sid))
  end :=
  match t with
  | Tint => I
  | Tstruct sid => typeR_spec_members sid
  end.

Definition reptype_fix_aux (y: type): (forall x, TypeTree.typeR x y -> Type) -> Type.
Proof.
  refine
  ((match y as y_PAT
      return match y_PAT with
             | Tint => True
             | Tstruct sid => Forall (fun p => TypeTree.typeR (snd p) y_PAT) (co_members (get_co sid))
             end ->
             (forall x : type, TypeTree.typeR x y_PAT -> Type) ->
             Type
    with
    | Tint => fun _ _ => val
    | Tstruct sid => fun H f =>
       (fix reptype_fix_aux_members (m: members): Forall (fun p => TypeTree.typeR (snd p) (Tstruct sid)) m -> Type :=
          match m as m_PAT
            return Forall (fun p => TypeTree.typeR (snd p) (Tstruct sid)) m_PAT -> Type
          with
          | nil => fun _ => unit
          | (i, t) :: m0 => fun H => prod (f t _) (reptype_fix_aux_members m0 _)
          end) _ H
    end) (typeR_spec y)).
  + apply Forall_inv in H; exact H.
  + apply Forall_inv2 in H; exact H.
Defined.

Definition reptype : type -> Type := Fix TypeTree.wf_typeR (fun _ => Type) reptype_fix_aux.

Lemma reptype_eq: forall t: type, reptype t =
  match t with
  | Tint => val
  | Tstruct id =>
      (fix reptype_members (m: members): Type :=
        match m with
        | nil => unit
        | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
        end) (co_members (get_co id))
  end.
Proof.
  intros.
  unfold reptype.
  rewrite Fix_eq.
  Focus 2. {
    intros.
    unfold reptype_fix_aux.
    destruct x; auto.
    simpl in *.
    unfold typeR_spec_members.
    generalize (typeR_spec_members_aux (co_members (get_co id))).
    revert f g H.
    
    set (m := co_members (get_co id)) at 5 13 21. clearbody m.
    set (M := co_members (get_co id)). clearbody M.
    intros.
    induction m as [| [i0 t0] m]; auto.
    intros.
    f_equal; auto.
  } Unfocus.
  destruct t; auto.
  unfold reptype_fix_aux at 1; simpl.
  unfold typeR_spec_members.
  generalize (typeR_spec_members_aux (co_members (get_co id))).
  
  set (m := co_members (get_co id)) at 2 9 10; clearbody m.
  set (M := co_members (get_co id)); clearbody M.
  induction m as [| [i0 t0] m]; auto.
  intros.
  f_equal; auto.
Qed.

Definition default_val_fix_aux (y: type): (forall x, TypeTree.typeR x y -> reptype x) -> reptype y.
Proof.
  intros.
  
  refine
   (eq_rect_r (fun T => T)
    ((match y as y_PAT
        return match y_PAT with
               | Tint => True
               | Tstruct sid => Forall (fun p => TypeTree.typeR (snd p) y_PAT) (co_members (get_co sid))
               end ->
               (forall x : type, TypeTree.typeR x y_PAT -> reptype x) ->
               match y_PAT with
               | Tint => val
               | Tstruct id =>
                   (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) (co_members (get_co id))
               end
      with
      | Tint => fun _ _ => Vundef
      | Tstruct sid => fun H f =>
         (fix default_val_fix_aux_members (m: members):
            Forall (fun p => TypeTree.typeR (snd p) (Tstruct sid)) m ->
            (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) m :=
            match m as m_PAT
              return Forall (fun p => TypeTree.typeR (snd p) (Tstruct sid)) m_PAT ->
                     (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) m_PAT
            with
            | nil => fun _ => tt
            | (i, t) :: m0 => fun H => (f t _, default_val_fix_aux_members m0 _)
            end) _ H
      end) (typeR_spec y) X)
    (reptype_eq y)).
  + apply Forall_inv in H; exact H.
  + apply Forall_inv2 in H; exact H.
Defined.

Definition default_val: forall (t: type), reptype t := Fix TypeTree.wf_typeR reptype default_val_fix_aux.

End Fix_TypeTree.
End Fix_TypeTree.

Module Function_TypeTree.
Section Function_TypeTree.

Variable env: composite_env.
Hypothesis consist_env: composite_env_consistent env.

End Function_TypeTree.
End Function_TypeTree.

Module ManualWf_TypeTree.

Section ManualWf_TypeTree.

Context {cs: compspecs}.

Inductive ForallT {A : Type} (P : A -> Type) : list A -> Type :=
    ForallT_nil : ForallT P nil
  | ForallT_cons : forall (x : A) (l : list A),
                  P x -> ForallT P l -> ForallT P (x :: l).

Inductive acc_type: type -> Type :=
  | acc_Tint: acc_type Tint
  | acc_Tstruct: forall id, ForallT (fun p => acc_type (snd p)) (co_members (get_co id)) -> acc_type (Tstruct id).

Section AccTypeInd.

Variable P: forall t, acc_type t -> Prop.

Fixpoint P_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m): Prop :=
  match wit_m with
  | ForallT_nil => True
  | ForallT_cons (i, t) m0 wit_t wit_m0 => P t wit_t /\ P_members m0 wit_m0
  end.

Hypothesis P_Tint: P Tint acc_Tint.

Hypothesis P_Tstruct: forall sid (wit: ForallT (fun p => acc_type (snd p)) (co_members (get_co sid))), P_members (co_members (get_co sid)) wit -> P (Tstruct sid) (acc_Tstruct sid wit).

Fixpoint acc_type__ind (t: type) (wit_t: acc_type t): P t wit_t :=
  match wit_t as wit_t_PAT in acc_type t_PAT
    return P t_PAT wit_t_PAT
  with
  | acc_Tint => P_Tint
  | acc_Tstruct sid wit =>
      P_Tstruct sid wit
      ((fix acc_type_ind_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m): P_members m wit_m :=
        match wit_m as wit_m_PAT in ForallT _ m_PAT
          return P_members m_PAT wit_m_PAT
        with
        | ForallT_nil => I
        | ForallT_cons (i0, t0) m0 wit_t0 wit_m0 => conj (acc_type__ind t0 wit_t0) (acc_type_ind_members m0 wit_m0)
        end) (co_members (get_co sid)) wit)
  end.

End AccTypeInd.

Definition acc_type_gen (t: type): acc_type t.
  remember (rank_type cenv_cs t) eqn:?H.
  pose proof le_n n.
  rewrite H in H0 at 1; clear H.
  revert t H0; induction n; intros.
  + destruct t.
    - constructor.
    - constructor.
      unfold get_co.
      cbv [rank_type] in H0; simpl in H0.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [apply le_Sn_0 in H0; inversion H0 |].
      simpl; constructor.
  + destruct t.
    - constructor.
    - constructor; intros.
      unfold get_co.
      cbv [rank_type] in H0; simpl in H0.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [| simpl; constructor].
      pose proof co_consistent_rank _ _ (cenv_consistent id c Heqo).
      rewrite H in H0.
      apply le_S_n in H0.
      remember (co_members c) as m.
      clear c Heqo Heqm H.
      induction m; constructor.
      * destruct a; simpl in H0 |- *.
        apply IHn.
        pose proof le_max_l (rank_type cenv_cs t) (rank_members cenv_cs m).
        eapply le_trans; eassumption.
      * apply IHm.
        destruct a; simpl in H0.
        pose proof le_max_r (rank_type cenv_cs t) (rank_members cenv_cs m).
        eapply le_trans; eassumption.
Defined.

Fixpoint reptype_aux (t: type) (wit_t: acc_type t): Type :=
  match wit_t in acc_type t_PAT with
  | acc_Tint => val
  | acc_Tstruct id wit_id =>
     (fix reptype_aux_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m): Type :=
        match wit_m with
        | ForallT_nil => unit
        | ForallT_cons (_, t0) m0 wit_t0 wit_m0 => (reptype_aux t0 wit_t0 * reptype_aux_members m0 wit_m0)%type
        end) (co_members (get_co id)) wit_id
  end.

Definition reptype (t: type) := reptype_aux t (acc_type_gen t).

Lemma reptype_eq: forall t: type, reptype t =
  match t with
  | Tint => val
  | Tstruct id =>
      (fix reptype_members (m: members): Type :=
        match m with
        | nil => unit
        | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
        end) (co_members (get_co id))
  end.
Proof.
  intros.
  unfold reptype at 1.
  
Abort.

Fixpoint default_val_aux (t: type) (wit_t: acc_type t): reptype_aux t wit_t :=
  match wit_t as wit_t_PAT in acc_type t_PAT return reptype_aux t_PAT wit_t_PAT with
  | acc_Tint => Vundef
  | acc_Tstruct id wit_id =>
     (fix default_val_aux_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m):
        (fix reptype_aux_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m): Type :=
        match wit_m with
        | ForallT_nil => unit
        | ForallT_cons (_, t0) m0 wit_t0 wit_m0 => (reptype_aux t0 wit_t0 * reptype_aux_members m0 wit_m0)%type
        end) m wit_m :=
        match wit_m  as wit_m_PAT in (ForallT _ m_PAT) return (fix reptype_aux_members (m: members) (wit_m: ForallT (fun p => acc_type (snd p)) m): Type :=
        match wit_m with
        | ForallT_nil => unit
        | ForallT_cons (_, t0) m0 wit_t0 wit_m0 => (reptype_aux t0 wit_t0 * reptype_aux_members m0 wit_m0)%type
        end) m_PAT wit_m_PAT with
        | ForallT_nil => tt
        | ForallT_cons (_, t0) m0 wit_t0 wit_m0 => (default_val_aux t0 wit_t0, default_val_aux_members m0 wit_m0)%type
        end) (co_members (get_co id)) wit_id
  end.

Definition default_val (t: type): reptype t := default_val_aux t (acc_type_gen t).

End ManualWf_TypeTree.

End ManualWf_TypeTree.

Module Fix_RankLt.

Section Fix_RankLt.

Context {cs: compspecs}.

Definition typeR (t1: type) (t2: type): Prop := (rank_type cenv_cs t1 < rank_type cenv_cs t2)%nat.

Lemma wf_typeR: well_founded typeR.
Proof.
  hnf; intro t.
  remember (rank_type cenv_cs t) eqn:?H.
  pose proof le_n n.
  rewrite H in H0 at 1; clear H.
  revert t H0; induction n; intros.
  + constructor; intros.
    unfold typeR in H.
    pose proof le_trans _ _ _ H H0.
    inversion H1.
  + constructor; intros.
    destruct t.
    - inversion H.
    - unfold typeR in H.
      simpl in *.
      destruct (Maps.PTree.get id cenv_cs) eqn:?; [| inversion H].
      pose proof le_trans _ _ _ H H0.
      apply le_S_n in H1.
      apply IHn; auto.
Defined.

Lemma typeR_spec_members_aux: forall (m : members),
  Forall (fun p : ident * type => rank_type cenv_cs (snd p) < S (rank_members cenv_cs m))%nat m.
Proof.
  intros.
  induction m.
  + constructor.
  + destruct a.
    constructor.
    - simpl.
      apply le_n_S.
      apply le_max_l.
    - revert IHm; apply Forall_impl.
      intros.
      apply (le_trans _ _ _ H).
      simpl.
      apply le_n_S.
      apply le_max_r.
Defined.

Lemma typeR_spec_members sid: Forall (fun p => typeR (snd p) (Tstruct sid)) (co_members (get_co sid)).
Proof.
  unfold typeR.
  simpl.
  unfold get_co.
  destruct (Maps.PTree.get sid cenv_cs) eqn:?.
  + erewrite co_consistent_rank by (eapply (cenv_consistent _ _ Heqo)).
    apply typeR_spec_members_aux.
  + constructor.
Defined.

Definition typeR_spec (t: type):
  match t with
  | Tint => True
  | Tstruct sid => Forall (fun p => typeR (snd p) t) (co_members (get_co sid))
  end :=
  match t with
  | Tint => I
  | Tstruct sid => typeR_spec_members sid
  end.

Definition reptype_fix_aux (y: type): (forall x, typeR x y -> Type) -> Type.
Proof.
  refine
  ((match y as y_PAT
      return match y_PAT with
             | Tint => True
             | Tstruct sid => Forall (fun p => typeR (snd p) y_PAT) (co_members (get_co sid))
             end ->
             (forall x : type, typeR x y_PAT -> Type) ->
             Type
    with
    | Tint => fun _ _ => val
    | Tstruct sid => fun H f =>
       (fix reptype_fix_aux_members (m: members): Forall (fun p => typeR (snd p) (Tstruct sid)) m -> Type :=
          match m as m_PAT
            return Forall (fun p => typeR (snd p) (Tstruct sid)) m_PAT -> Type
          with
          | nil => fun _ => unit
          | (i, t) :: m0 => fun H => prod (f t _) (reptype_fix_aux_members m0 _)
          end) _ H
    end) (typeR_spec y)).
  + apply Forall_inv in H; exact H.
  + apply Forall_inv2 in H; exact H.
Defined.

Definition reptype : type -> Type := Fix wf_typeR (fun _ => Type) reptype_fix_aux.

Lemma reptype_eq: forall t: type, reptype t =
  match t with
  | Tint => val
  | Tstruct id =>
      (fix reptype_members (m: members): Type :=
        match m with
        | nil => unit
        | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
        end) (co_members (get_co id))
  end.
Proof.
  intros.
  unfold reptype.
  rewrite Fix_eq.
  Focus 2. {
    intros.
    unfold reptype_fix_aux.
    destruct x; auto.
    simpl in *.
    
    generalize (typeR_spec_members id).
    revert f g H.
    unfold typeR, get_co; simpl.
    destruct (Maps.PTree.get id cenv_cs) eqn:?; [| auto].
    set (m := (co_members c)). clearbody m.
    intros.
    induction m as [| [i0 t0] m]; auto.
    intros.
    f_equal; auto.
  } Unfocus.
  destruct t; auto.
  unfold reptype_fix_aux at 1; simpl.
  
  generalize (typeR_spec_members id).
  unfold typeR, get_co; simpl.
  destruct (Maps.PTree.get id cenv_cs) eqn:?; [| auto].
  set (m := (co_members c)). clearbody m.
  intros.
  induction m as [| [i0 t0] m]; auto.
  intros.
  f_equal; auto.
Qed.

Definition default_val_fix_aux (y: type): (forall x, typeR x y -> reptype x) -> reptype y.
Proof.
  intros.
  
  refine
   (eq_rect_r (fun T => T)
    ((match y as y_PAT
        return match y_PAT with
               | Tint => True
               | Tstruct sid => Forall (fun p => typeR (snd p) y_PAT) (co_members (get_co sid))
               end ->
               (forall x : type, typeR x y_PAT -> reptype x) ->
               match y_PAT with
               | Tint => val
               | Tstruct id =>
                   (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) (co_members (get_co id))
               end
      with
      | Tint => fun _ _ => Vundef
      | Tstruct sid => fun H f =>
         (fix default_val_fix_aux_members (m: members):
            Forall (fun p => typeR (snd p) (Tstruct sid)) m ->
            (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) m :=
            match m as m_PAT
              return Forall (fun p => typeR (snd p) (Tstruct sid)) m_PAT ->
                     (fix reptype_members (m: members): Type :=
                     match m with
                     | nil => unit
                     | cons (_, t0) m0 => (reptype t0 * reptype_members m0)%type
                     end) m_PAT
            with
            | nil => fun _ => tt
            | (i, t) :: m0 => fun H => (f t _, default_val_fix_aux_members m0 _)
            end) _ H
      end) (typeR_spec y) X)
    (reptype_eq y)).
  + apply Forall_inv in H; exact H.
  + apply Forall_inv2 in H; exact H.
Defined.

Definition default_val: forall (t: type), reptype t := Fix wf_typeR reptype default_val_fix_aux.

End Fix_RankLt.

End Fix_RankLt.

Module RankRec.

Require Import AggregateType.demo2.type_induction.
Open Scope nat.

Section RankRec.

Context {cs: compspecs}.

Fixpoint reptype_aux (n: nat) (t: type): Type :=
  match t with
  | Tint => val
  | Tstruct id =>
     match n with
     | O => unit
     | S n' => fold_right prod unit (map (reptype_aux n') (map snd (co_members (get_co id))))
     end
  end.

Definition reptype t := reptype_aux (rank_type cenv_cs t) t.

Lemma reptype_aux_rank_irrelevent: forall t n n0,
  n >= rank_type cenv_cs t ->
  n0 >= rank_type cenv_cs t ->
  reptype_aux n t = reptype_aux n0 t.
Proof.
  intros t.
  RankInd.type_induction t;
  intros;
  try solve [destruct n; simpl; auto; destruct n0; simpl; auto].
  + 
    unfold get_co in IH.
    destruct (Maps.PTree.get id cenv_cs) as [co |] eqn: CO.
    - erewrite rank_type_Tstruct in H by eauto.
      erewrite rank_type_Tstruct in H0 by eauto.
      destruct n; simpl in H; try solve [inv H].
      destruct n0; simpl in H; try solve [inv H0].
      simpl.
      f_equal.
      rewrite !map_map.
      apply list_map_exten.

      intros [i t] Hin.
      unfold get_co in H, H0, Hin. rewrite CO in H, H0, Hin.
      simpl in IH.
      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.
      specialize (IH (i, t) Hin n n0).
      apply le_S_n in H; apply le_S_n in H0.
      assert (H3 := rank_type_members cenv_cs i t _ Hin).
      symmetry; apply IH.
      * simpl.
        eapply le_trans; [ | eassumption].
        erewrite co_consistent_rank; [eapply rank_type_members; eassumption |].
        exact (cenv_consistent id co CO).
      * simpl.
        eapply le_trans; [ | eassumption].
        erewrite co_consistent_rank; [eapply rank_type_members; eassumption |].
        exact (cenv_consistent id co CO).
    - destruct n, n0; simpl;
      unfold get_co;
      rewrite ?CO; intros; auto.
Defined.

Lemma reptype_eq: forall t: type, reptype t =
  match t with
  | Tint => val
  | Tstruct id => fold_right prod unit (map reptype (map snd (co_members (get_co id))))
  end.
Proof.
  intros.
  RankInd.type_induction t; try reflexivity.
  + 
    unfold reptype in *.
    simpl reptype_aux.
    destruct (Maps.PTree.get id cenv_cs) as [co |] eqn:CO; simpl.
    - f_equal.
      rewrite !map_map.
      apply list_map_exten.
      intros [i t].
      unfold get_co; rewrite CO.
      intro Hin.
      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.
      apply reptype_aux_rank_irrelevent.
      * apply le_n.
      * simpl.
        erewrite co_consistent_rank; [eapply rank_type_members; eassumption |].
        exact (cenv_consistent id co CO).
    - unfold FTI_aux, get_co; rewrite CO.
      reflexivity.
Defined.

End RankRec.
End RankRec.

Module Test.

Require Import compcert.lib.Maps.
(* compcert.lib.Maps:
Require Import Equivalence EquivDec.
Require Import Coqlib.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Set Implicit Arguments.

Module Type TREE.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter empty: forall (A: Type), t A.
  Parameter get: forall (A: Type), elt -> t A -> option A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Parameter remove: forall (A: Type), elt -> t A -> t A.

  Axiom gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
    Axiom grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Axiom gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Axiom grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Parameter beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool.
  Axiom beq_correct:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true <->
    (forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end).

  Parameter map:
    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Parameter map1:
    forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Parameter combine:
    forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C.
  Axiom gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).

  Parameter elements:
    forall (A: Type), t A -> list (elt * A).
  Axiom elements_correct:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    get i m = Some v -> In (i, v) (elements m).
  Axiom elements_complete:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    In (i, v) (elements m) -> get i m = Some v.
  Axiom elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).
  Axiom elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.
  Axiom elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Parameter fold:
    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
  Axiom fold_spec:
    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
  
  Parameter fold1:
    forall (A B: Type), (B -> A -> B) -> t A -> B -> B.
  Axiom fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.
End TREE.

Module Type MAP.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter init: forall (A: Type), A -> t A.
  Parameter get: forall (A: Type), elt -> t A -> A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Axiom gi:
    forall (A: Type) (i: elt) (x: A), get i (init x) = x.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Axiom gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Parameter map: forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End MAP.

Module PTree <: TREE.
  Definition elt := positive.
  Definition elt_eq := peq.

  Inductive tree (A : Type) : Type :=
    | Leaf : tree A
    | Node : tree A -> option A -> tree A -> tree A.

  Arguments Leaf [A].
  Arguments Node [A].
  Scheme tree_ind := Induction for tree Sort Prop.

  Definition t := tree.

  Definition empty (A : Type) := (Leaf : t A).

  Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A :=
    match m with
    | Leaf => None
    | Node l o r =>
        match i with
        | xH => o
        | xO ii => get ii l
        | xI ii => get ii r
        end
    end.

  Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A :=
    match m with
    | Leaf =>
        match i with
        | xH => Node Leaf (Some v) Leaf
        | xO ii => Node (set ii v Leaf) None Leaf
        | xI ii => Node Leaf None (set ii v Leaf)
        end
    | Node l o r =>
        match i with
        | xH => Node l (Some v) r
        | xO ii => Node (set ii v l) o r
        | xI ii => Node l o (set ii v r)
        end
    end.

  Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A :=
    match i with
    | xH =>
        match m with
        | Leaf => Leaf
        | Node Leaf o Leaf => Leaf
        | Node l o r => Node l None r
        end
    | xO ii =>
        match m with
        | Leaf => Leaf
        | Node l None Leaf =>
            match remove ii l with
            | Leaf => Leaf
            | mm => Node mm None Leaf
            end
        | Node l o r => Node (remove ii l) o r
        end
    | xI ii =>
        match m with
        | Leaf => Leaf
        | Node Leaf None r =>
            match remove ii r with
            | Leaf => Leaf
            | mm => Node Leaf None mm
            end
        | Node l o r => Node l o (remove ii r)
        end
    end.

  Theorem gempty:
    forall (A: Type) (i: positive), get i (empty A) = None.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x.

    Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then Some x else get i m.

  Theorem gsident:
    forall (A: Type) (i: positive) (m: t A) (v: A),
    get i m = Some v -> set i v m = m.

  Theorem set2:
    forall (A: Type) (i: elt) (m: t A) (v1 v2: A),
    set i v2 (set i v1 m) = set i v2 m.

  Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf.

  Theorem grs:
    forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None.

  Theorem gro:
    forall (A: Type) (i j: positive) (m: t A),
    i <> j -> get i (remove j m) = get i m.

  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Section BOOLEAN_EQUALITY.

    Variable A: Type.
    Variable beqA: A -> A -> bool.

    Fixpoint bempty (m: t A) : bool :=
      match m with
      | Leaf => true
      | Node l None r => bempty l && bempty r
      | Node l (Some _) r => false
      end.

    Fixpoint beq (m1 m2: t A) {struct m1} : bool :=
      match m1, m2 with
      | Leaf, _ => bempty m2
      | _, Leaf => bempty m1
      | Node l1 o1 r1, Node l2 o2 r2 =>
          match o1, o2 with
          | None, None => true
          | Some y1, Some y2 => beqA y1 y2
          | _, _ => false
          end
          && beq l1 l2 && beq r1 r2
      end.

    Lemma bempty_correct:
      forall m, bempty m = true <-> (forall x, get x m = None).

    Lemma beq_correct:
      forall m1 m2,
      beq m1 m2 = true <->
      (forall (x: elt),
       match get x m1, get x m2 with
       | None, None => True
       | Some y1, Some y2 => beqA y1 y2 = true
       | _, _ => False
       end).

  End BOOLEAN_EQUALITY.

  Fixpoint prev_append (i j: positive) {struct i} : positive :=
    match i with
      | xH => j
      | xI i' => prev_append i' (xI j)
      | xO i' => prev_append i' (xO j)
    end.

  Definition prev (i: positive) : positive :=
    prev_append i xH.

  Lemma prev_append_prev i j:
    prev (prev_append i j) = prev_append j i.

  Lemma prev_involutive i :
    prev (prev i) = i.
  Proof (prev_append_prev i xH).

  Lemma prev_append_inj i j j' :
    prev_append i j = prev_append i j' -> j = j'.

    Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive)
             {struct m} : t B :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node (xmap f l (xO i))
                           (match o with None => None | Some x => Some (f (prev i) x) end)
                           (xmap f r (xI i))
      end.

  Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH.

    Lemma xgmap:
      forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A),
      get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m).

  Theorem gmap:
    forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B :=
    match m with
    | Leaf => Leaf
    | Node l o r => Node (map1 f l) (option_map f o) (map1 f r)
    end.

  Theorem gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A :=
    match l, x, r with
    | Leaf, None, Leaf => Leaf
    | _, _, _ => Node l x r
    end.

  Lemma gnode':
    forall (A: Type) (l r: t A) (x: option A) (i: positive),
    get i (Node' l x r) = get i (Node l x r).

  Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A :=
    match m with
    | Leaf => Leaf
    | Node l o r =>
        let o' := match o with None => None | Some x => if pred x then o else None end in
        Node' (filter1 pred l) o' (filter1 pred r)
    end.

  Theorem gfilter1:
    forall (A: Type) (pred: A -> bool) (i: elt) (m: t A),
    get i (filter1 pred m) =
    match get i m with None => None | Some x => if pred x then Some x else None end.

  Section COMBINE.

  Variables A B C: Type.
  Variable f: option A -> option B -> option C.
  Hypothesis f_none_none: f None None = None.

  Fixpoint xcombine_l (m : t A) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_l l) (f o None) (xcombine_l r)
      end.

  Lemma xgcombine_l :
          forall (m: t A) (i : positive),
          get i (xcombine_l m) = f (get i m) None.

  Fixpoint xcombine_r (m : t B) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_r l) (f None o) (xcombine_r r)
      end.

  Lemma xgcombine_r :
          forall (m: t B) (i : positive),
          get i (xcombine_r m) = f None (get i m).

  Fixpoint combine (m1: t A) (m2: t B) {struct m1} : t C :=
    match m1 with
    | Leaf => xcombine_r m2
    | Node l1 o1 r1 =>
        match m2 with
        | Leaf => xcombine_l m1
        | Node l2 o2 r2 => Node' (combine l1 l2) (f o1 o2) (combine r1 r2)
        end
    end.

  Theorem gcombine:
      forall (m1: t A) (m2: t B) (i: positive),
      get i (combine m1 m2) = f (get i m1) (get i m2).

  End COMBINE.

  Lemma xcombine_lr :
    forall (A B: Type) (f g : option A -> option A -> option B) (m : t A),
    (forall (i j : option A), f i j = g j i) ->
    xcombine_l f m = xcombine_r g m.

  Theorem combine_commut:
    forall (A B: Type) (f g: option A -> option A -> option B),
    (forall (i j: option A), f i j = g j i) ->
    forall (m1 m2: t A),
    combine f m1 m2 = combine g m2 m1.

    Fixpoint xelements (A : Type) (m : t A) (i : positive)
                       (k: list (positive * A)) {struct m}
                       : list (positive * A) :=
      match m with
      | Leaf => k
      | Node l None r =>
          xelements l (xO i) (xelements r (xI i) k)
      | Node l (Some x) r =>
          xelements l (xO i)
            ((prev i, x) :: xelements r (xI i) k)
      end.

  Definition elements (A: Type) (m : t A) := xelements m xH nil.

  Remark xelements_append:
    forall A (m: t A) i k1 k2,
    xelements m i (k1 ++ k2) = xelements m i k1 ++ k2.

  Remark xelements_leaf:
    forall A i, xelements (@Leaf A) i nil = nil.

  Remark xelements_node:
    forall A (m1: t A) o (m2: t A) i,
    xelements (Node m1 o m2) i nil =
       xelements m1 (xO i) nil
    ++ match o with None => nil | Some v => (prev i, v) :: nil end
    ++ xelements m2 (xI i) nil.

    Lemma xelements_incl:
      forall (A: Type) (m: t A) (i : positive) k x,
      In x k -> In x (xelements m i k).

    Lemma xelements_correct:
      forall (A: Type) (m: t A) (i j : positive) (v: A) k,
      get i m = Some v -> In (prev (prev_append i j), v) (xelements m j k).

  Theorem elements_correct:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    get i m = Some v -> In (i, v) (elements m).

  Lemma in_xelements:
    forall (A: Type) (m: t A) (i k: positive) (v: A) ,
    In (k, v) (xelements m i nil) ->
    exists j, k = prev (prev_append j i) /\ get j m = Some v.

  Theorem elements_complete:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    In (i, v) (elements m) -> get i m = Some v.

  Definition xkeys (A: Type) (m: t A) (i: positive) :=
    List.map (@fst positive A) (xelements m i nil).

  Remark xkeys_leaf:
    forall A i, xkeys (@Leaf A) i = nil.

  Remark xkeys_node:
    forall A (m1: t A) o (m2: t A) i,
    xkeys (Node m1 o m2) i =
       xkeys m1 (xO i)
    ++ match o with None => nil | Some v => prev i :: nil end
    ++ xkeys m2 (xI i).

  Lemma in_xkeys:
    forall (A: Type) (m: t A) (i k: positive),
    In k (xkeys m i) ->
    (exists j, k = prev (prev_append j i)).

  Lemma xelements_keys_norepet:
    forall (A: Type) (m: t A) (i: positive),
    list_norepet (xkeys m i).

  Theorem elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).

  Remark xelements_empty:
    forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil.

  Theorem elements_canonical_order':
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i, option_rel R (get i m) (get i n)) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_canonical_order:
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
    (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.

  Lemma xelements_remove:
    forall (A: Type) v (m: t A) i j,
    get i m = Some v ->
    exists l1 l2,
    xelements m j nil = l1 ++ (prev (prev_append i j), v) :: l2
    /\ xelements (remove i m) j nil = l1 ++ l2.

  Theorem elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B)
                 (i: positive) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := xfold f (xO i) l v in
        xfold f (xI i) r v1
    | Node l (Some x) r =>
        let v1 := xfold f (xO i) l v in
        let v2 := f v1 (prev i) x in
        xfold f (xI i) r v2
    end.

  Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) :=
    xfold f xH m v.

  Lemma xfold_xelements:
    forall (A B: Type) (f: B -> positive -> A -> B) m i v l,
    List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) =

  Theorem fold_spec:
    forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.

  Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := fold1 f l v in
        fold1 f r v1
    | Node l (Some x) r =>
        let v1 := fold1 f l v in
        let v2 := f v1 x in
        fold1 f r v2
    end.

  Lemma fold1_xelements:
    forall (A B: Type) (f: B -> A -> B) m i v l,
    List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) =

  Theorem fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.

End PTree.

Module PMap <: MAP.
  Definition elt := positive.
  Definition elt_eq := peq.

  Definition t (A : Type) : Type := (A * PTree.t A)%type.

  Definition init (A : Type) (x : A) :=
    (x, PTree.empty A).

  Definition get (A : Type) (i : positive) (m : t A) :=
    match PTree.get i (snd m) with
    | Some x => x
    | None => fst m
    end.

  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
    (fst m, PTree.set i x (snd m)).

  Theorem gi:
    forall (A: Type) (i: positive) (x: A), get i (init x) = x.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then x else get i m.

  Theorem gsident:
    forall (A: Type) (i j: positive) (m: t A),
    get j (set i (get i m) m) = get j m.

  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
    (f (fst m), PTree.map1 f (snd m)).

  Theorem gmap:
    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
    get i (map f m) = f(get i m).

  Theorem set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End PMap.

Module Type INDEXED_TYPE.
  Parameter t: Type.
  Parameter index: t -> positive.
  Axiom index_inj: forall (x y: t), index x = index y -> x = y.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End INDEXED_TYPE.

Module IMap(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PMap.t.
  Definition init (A: Type) (x: A) := PMap.init x.
  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.

  Lemma gi:
    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.

  Lemma gss:
    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.

  Lemma gso:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gsspec:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),

  Lemma set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End IMap.

Module ZIndexed.
  Definition t := Z.
  Definition index (z: Z): positive :=
    match z with
    | Z0 => xH
    | Zpos p => xO p
    | Zneg p => xI p
    end.
  Lemma index_inj: forall (x y: Z), index x = index y -> x = y.
  Definition eq := zeq.
End ZIndexed.

Module ZMap := IMap(ZIndexed).

Module NIndexed.
  Definition t := N.
  Definition index (n: N): positive :=
    match n with
    | N0 => xH
    | Npos p => xO p
    end.
  Lemma index_inj: forall (x y: N), index x = index y -> x = y.
  Lemma eq: forall (x y: N), {x = y} + {x <> y}.
End NIndexed.

Module NMap := IMap(NIndexed).

Module Type EQUALITY_TYPE.
  Parameter t: Type.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End EQUALITY_TYPE.

Module EMap(X: EQUALITY_TYPE) <: MAP.

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t (A: Type) := X.t -> A.
  Definition init (A: Type) (v: A) := fun (_: X.t) => v.
  Definition get (A: Type) (x: X.t) (m: t A) := m x.
  Definition set (A: Type) (x: X.t) (v: A) (m: t A) :=
    fun (y: X.t) => if X.eq y x then v else m y.
  Lemma gi:
    forall (A: Type) (i: elt) (x: A), init x i = x.
  Lemma gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x.
  Lemma gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> (set j x m) i = m i.
  Lemma gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Lemma gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Definition map (A B: Type) (f: A -> B) (m: t A) :=
    fun (x: X.t) => f(m x).
  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End EMap.

Module ITree(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PTree.t.

  Definition empty (A: Type): t A := PTree.empty A.
  Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m.
  Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m.
  Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m.

  Theorem gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Theorem gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Theorem gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Theorem gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
  Theorem grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Theorem gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq.
  Theorem beq_sound:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true ->
    forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end.

  Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine.
  Theorem gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).
End ITree.

Module ZTree := ITree(ZIndexed).

Module Tree_Properties(T: TREE).

Section TREE_FOLD_IND.

Variables V A: Type.
Variable f: A -> T.elt -> V -> A.
Variable P: T.t V -> A -> Prop.
Variable init: A.
Variable m_final: T.t V.

Hypothesis P_compat:
  forall m m' a,
  (forall x, T.get x m = T.get x m') ->
  P m a -> P m' a.

Hypothesis H_base:
  P (T.empty _) init.

Hypothesis H_rec:
  forall m a k v,
  T.get k m = None -> T.get k m_final = Some v -> P m a -> P (T.set k v m) (f a k v).

Let f' (a: A) (p : T.elt * V) := f a (fst p) (snd p).

Let P' (l: list (T.elt * V)) (a: A) : Prop :=
  forall m, list_equiv l (T.elements m) -> P m a.

Remark H_base':
  P' nil init.

Remark H_rec':
  forall k v l a,
  ~In k (List.map (@fst T.elt V) l) ->

Lemma fold_rec_aux:
  forall l1 l2 a,
  list_equiv (l2 ++ l1) (T.elements m_final) ->

Theorem fold_rec:
  P m_final (T.fold f m_final init).

End TREE_FOLD_IND.

Section MEASURE.

Variable V: Type.

Definition cardinal (x: T.t V) : nat := List.length (T.elements x).

Theorem cardinal_remove:
  forall x m y, T.get x m = Some y -> (cardinal (T.remove x m) < cardinal m)%nat.

Theorem cardinal_set:
  forall x m y, T.get x m = None -> (cardinal m < cardinal (T.set x y m))%nat.

End MEASURE.

Section FORALL_EXISTS.

Variable A: Type.

Definition for_all (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b && f x a) m true.

Lemma for_all_correct:
  forall m f,
  for_all m f = true <-> (forall x a, T.get x m = Some a -> f x a = true).

Definition exists_ (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b || f x a) m false.

Lemma exists_correct:
  forall m f,
  exists_ m f = true <-> (exists x a, T.get x m = Some a /\ f x a = true).

Remark exists_for_all:
  forall m f,
  exists_ m f = negb (for_all m (fun x a => negb (f x a))).

Remark for_all_exists:
  forall m f,
  for_all m f = negb (exists_ m (fun x a => negb (f x a))).

Lemma for_all_false:
  forall m f,
  for_all m f = false <-> (exists x a, T.get x m = Some a /\ f x a = false).

Lemma exists_false:
  forall m f,
  exists_ m f = false <-> (forall x a, T.get x m = Some a -> f x a = false).

End FORALL_EXISTS.

Section BOOLEAN_EQUALITY.

Variable A: Type.
Variable beqA: A -> A -> bool.

Theorem beq_false:
  forall m1 m2,
  T.beq beqA m1 m2 = false <->

End BOOLEAN_EQUALITY.

Section EXTENSIONAL_EQUALITY.

Variable A: Type.
Variable eqA: A -> A -> Prop.
Hypothesis eqAeq: Equivalence eqA.

Definition Equal (m1 m2: T.t A) : Prop :=
  forall x, match T.get x m1, T.get x m2 with
                | None, None => True
                | Some a1, Some a2 => a1 === a2
                | _, _ => False
            end.

Lemma Equal_refl: forall m, Equal m m.

Lemma Equal_sym: forall m1 m2, Equal m1 m2 -> Equal m2 m1.

Lemma Equal_trans: forall m1 m2 m3, Equal m1 m2 -> Equal m2 m3 -> Equal m1 m3.

Instance Equal_Equivalence : Equivalence Equal := {
  Equivalence_Reflexive := Equal_refl;
  Equivalence_Symmetric := Equal_sym;
  Equivalence_Transitive := Equal_trans
}.

Hypothesis eqAdec: EqDec A eqA.

Program Definition Equal_dec (m1 m2: T.t A) : { m1 === m2 } + { m1 =/= m2 } :=

Instance Equal_EqDec : EqDec (T.t A) Equal := Equal_dec.

End EXTENSIONAL_EQUALITY.

Section OF_LIST.

Variable A: Type.

Let f := fun (m: T.t A) (k_v: T.elt * A) => T.set (fst k_v) (snd k_v) m.

Definition of_list (l: list (T.elt * A)) : T.t A :=
  List.fold_left f l (T.empty _).

Lemma in_of_list:
  forall l k v, T.get k (of_list l) = Some v -> In (k, v) l.

Lemma of_list_dom:
  forall l k, In k (map fst l) -> exists v, T.get k (of_list l) = Some v.

Remark of_list_unchanged:
  forall k l m, ~In k (map fst l) -> T.get k (List.fold_left f l m) = T.get k m.

Lemma of_list_unique:
  forall k v l1 l2,
  ~In k (map fst l2) -> T.get k (of_list (l1 ++ (k, v) :: l2)) = Some v.

Lemma of_list_norepet:
  forall l k v, list_norepet (map fst l) -> In (k, v) l -> T.get k (of_list l) = Some v.

Lemma of_list_elements:
  forall m k, T.get k (of_list (T.elements m)) = T.get k m.

End OF_LIST.

Lemma of_list_related:
  forall (A B: Type) (R: A -> B -> Prop) k l1 l2,
  list_forall2 (fun ka kb => fst ka = fst kb /\ R (snd ka) (snd kb)) l1 l2 ->
  option_rel R (T.get k (of_list l1)) (T.get k (of_list l2)).

End Tree_Properties.

Module PTree_Properties := Tree_Properties(PTree).

Notation "a ! b" := (PTree.get b a) (at level 1).
Notation "a !! b" := (PMap.get b a) (at level 1). *)

Definition _f1 := 1%positive.
Definition _f2 := 2%positive.
Definition _f3 := 3%positive.
Definition _f4 := 4%positive.
Definition _f5 := 5%positive.
Definition cd1 := Build_composite ((_f1, Tint) :: (_f2%positive, Tint) :: nil) 0.
Definition cd2 := Build_composite ((_f3, Tstruct 101%positive) ::
                                   (_f4, Tstruct 101%positive) ::
                                   (_f5, Tint) :: nil) 1.

Definition cenv : composite_env.
  pose (PTree.set 102%positive cd2 (PTree.set 101%positive cd1 (PTree.empty _))).
  cbv - [cd1 cd2] in t.
  match goal with
  | _ := ?t |- _ => clear; exact t
  end.
Defined.

Definition cenv_cons: composite_env_consistent cenv.
  hnf.
  intros.
  apply PTree.elements_correct in H.
  simpl in H.
  destruct H as [| [|[]]]; inversion H; subst.
  + split; reflexivity.
  + split; reflexivity.
Defined.

Instance test_cs: compspecs := mkcompspecs cenv cenv_cons.

Goal Fix_TypeTree.reptype (Tstruct 101%positive) = (val * (val * unit))%type.
  reflexivity.
Qed.

Goal Fix_TypeTree.reptype (Tstruct 102%positive) = ((val * (val * unit)) * ((val * (val * unit)) * (val * unit)))%type.
  reflexivity.
Qed.

Goal ManualWf_TypeTree.reptype (Tstruct 101%positive) = (val * (val * unit))%type.
  reflexivity.
Qed.

Goal ManualWf_TypeTree.reptype (Tstruct 102%positive) = ((val * (val * unit)) * ((val * (val * unit)) * (val * unit)))%type.
  reflexivity.
Qed.

Goal Fix_RankLt.reptype (Tstruct 101%positive) = (val * (val * unit))%type.
  reflexivity.
Qed.

Goal Fix_RankLt.reptype (Tstruct 102%positive) = ((val * (val * unit)) * ((val * (val * unit)) * (val * unit)))%type.
  reflexivity.
Qed.

Goal RankRec.reptype (Tstruct 101%positive) = (val * (val * unit))%type.
  reflexivity.
Qed.

Goal RankRec.reptype (Tstruct 102%positive) = ((val * (val * unit)) * ((val * (val * unit)) * (val * unit)))%type.
  reflexivity.
Qed.

End Test.

