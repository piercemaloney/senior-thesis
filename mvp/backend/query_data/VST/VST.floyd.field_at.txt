Require Import VST.floyd.base2.
(* VST.floyd.base2:
Require Export VST.floyd.base.
Require Export VST.floyd.typecheck_lemmas.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.seplog_tactics.
Require Export VST.floyd.const_only_eval.
Require Export VST.floyd.computable_functions.

Fixpoint delete_id {A: Type} i (al: list (ident*A)) : option (A * list (ident*A)) :=
 match al with
 | (j,x)::bl => if ident_eq i j then Some (x,bl)
                else match delete_id i bl with
                        | None => None
                        | Some (y,cl) => Some (y, (j,x)::cl)
                        end
  | nil => None
 end.

Inductive NOTE__Perhaps_you_need_to_Import_floyd_library___See_reference_manual_chapter___with_library : Type := .

Definition cc_of_fundef (fd: Clight.fundef) : calling_convention :=
 match fd with
 | Internal f => fn_callconv f
 | External _ _ _ c => c
 end.

Definition funsig_of_fundef (fd: Clight.fundef) : funsig :=
 match fd with
 | Internal {| fn_return := fn_return; fn_params := fn_params |} =>
    (fn_params, fn_return)
 | External _ t t0 _ => (arglist 1 t, t0)
 end.

Definition vacuous_funspec (fd: Clight.fundef): funspec :=
   mk_funspec (funsig_of_fundef fd) (cc_of_fundef fd) (rmaps.ConstType NOTE__Perhaps_you_need_to_Import_floyd_library___See_reference_manual_chapter___with_library) (fun _ _ => FF) (fun _ _ => FF) (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Fixpoint augment_funspecs' (fds: list (ident * Clight.fundef)) (G:funspecs) : option funspecs :=
 match fds with
 | (i,fd)::fds' => match delete_id i G with
                       | Some (f, G') =>
                              match augment_funspecs' fds' G' with
                               | Some G2 => Some ((i,f)::G2)
                               | None => None
                              end
                       | None =>
                              match augment_funspecs' fds' G with
                               | Some G2 => Some ((i, vacuous_funspec fd)::G2)
                               | None => None
                              end
                        end
 | nil => match G with nil => Some nil | _::_ => None end
 end.

Definition augment_funspecs prog G : funspecs :=
 match augment_funspecs' (prog_funct prog) G with
 | Some G' => G'
 | None => nil
 end. *)

Require Import VST.floyd.client_lemmas.
(* VST.floyd.client_lemmas:
Require Import VST.floyd.base2.
Require Export VST.floyd.canon.
Local Open Scope logic.

Lemma SEP_entail:
 forall R' Delta P Q R, 
   fold_right_sepcon R |-- fold_right_sepcon R' -> 
   ENTAIL Delta, PROPx P (LOCALx Q (SEPx R)) |-- PROPx P (LOCALx Q (SEPx R')).

Ltac refold_right_sepcon R :=
 match R with
 | @sepcon mpred _ _ ?R1 ?R' => let S := refold_right_sepcon R' in constr: (R1 :: S )
 | _ => constr:(R :: nil)
 end.

Lemma SEP_entail':
 forall R' Delta P Q R, 
   ENTAIL Delta, PROPx P (LOCALx Q (SEPx R)) |-- ` (fold_right_sepcon R') -> 
   ENTAIL Delta, PROPx P (LOCALx Q (SEPx R)) |-- PROPx P (LOCALx Q (SEPx R')).

Arguments sem_cmp c !t1 !t2 / v1 v2.

Hint Resolve (@LiftClassicalSep environ) : typeclass_instances.

Definition func_ptr' f v := func_ptr f v && emp.

Hint Resolve func_ptr_isptr: saturate_local.

Lemma func_ptr'_isptr: forall f v, func_ptr' f v |-- !! isptr v.
Hint Resolve func_ptr'_isptr: saturate_local.

Lemma split_func_ptr': 
 forall fs p, func_ptr' fs p = func_ptr' fs p * func_ptr' fs p.

Lemma approx_func_ptr': forall (A: Type) fsig0 cc (P Q: A -> environ -> mpred) (v: val) (n: nat),
  compcert_rmaps.RML.R.approx n (func_ptr' (NDmk_funspec fsig0 cc A P Q) v) = compcert_rmaps.RML.R.approx n (func_ptr' (NDmk_funspec fsig0 cc A (fun a rho => compcert_rmaps.RML.R.approx n (P a rho)) (fun a rho => compcert_rmaps.RML.R.approx n (Q a rho))) v).

Lemma lift0_unfold: forall {A} (f: A)  rho,  lift0 f rho = f.

Lemma lift0_unfoldC: forall {A} (f: A) (rho: environ),  `f rho = f.

Lemma lift1_unfold: forall {A1 B} (f: A1 -> B) a1 rho,
        lift1 f a1 rho = f (a1 rho).

Lemma lift1_unfoldC: forall {A1 B} (f: A1 -> B) a1 (rho: environ),
        `f a1 rho = f (a1 rho).

Lemma lift2_unfold: forall {A1 A2 B} (f: A1 -> A2 -> B) a1 a2 (rho: environ),
        lift2 f a1 a2 rho = f (a1 rho) (a2 rho).

Lemma lift2_unfoldC: forall {A1 A2 B} (f: A1 -> A2 -> B) a1 a2 (rho: environ),
        `f a1 a2 rho = f (a1 rho) (a2 rho).

Lemma lift3_unfold: forall {A1 A2 A3 B} (f: A1 -> A2 -> A3 -> B) a1 a2 a3 (rho: environ),
        lift3 f a1 a2 a3 rho = f (a1 rho) (a2 rho) (a3 rho).

Lemma lift3_unfoldC: forall {A1 A2 A3 B} (f: A1 -> A2 -> A3 -> B) a1 a2 a3 (rho: environ),
        `f a1 a2 a3 rho = f (a1 rho) (a2 rho) (a3 rho).

Lemma lift4_unfold: forall {A1 A2 A3 A4 B} (f: A1 -> A2 -> A3 -> A4 -> B) a1 a2 a3 a4 (rho: environ),
        lift4 f a1 a2 a3 a4 rho = f (a1 rho) (a2 rho) (a3 rho) (a4 rho).

Lemma lift4_unfoldC: forall {A1 A2 A3 A4 B} (f: A1 -> A2 -> A3 -> A4 -> B) a1 a2 a3 a4 (rho: environ),
        `f a1 a2 a3 a4 rho = f (a1 rho) (a2 rho) (a3 rho) (a4 rho).

Hint Rewrite @lift0_unfold @lift1_unfold @lift2_unfold @lift3_unfold @lift4_unfold : norm2.
Hint Rewrite @lift0_unfoldC @lift1_unfoldC @lift2_unfoldC @lift3_unfoldC @lift4_unfoldC : norm2.

Lemma subst_lift0: forall {A} id v (f: A),
        subst id v (lift0 f) = lift0 f.

Lemma subst_lift0': forall {A} id v (f: A),
        subst id v (fun _ => f) = (fun _ => f).

Hint Rewrite @subst_lift0' : subst.

Lemma subst_lift0C:
  forall {B} id (v: environ -> val) (f: B) ,
          subst id v (`f) = `f.

Hint Rewrite @subst_lift0  @subst_lift0C : subst.

Lemma subst_lift1:
  forall {A1 B} id v (f: A1 -> B) a,
          subst id v (lift1 f a) = lift1 f (subst id v a).

Lemma subst_lift1':
  forall {A1 B} id v (f: A1 -> B) a,
          subst id v (fun rho => f (a rho)) = fun rho => f (subst id v a rho).

Lemma subst_lift1C:
  forall {A1 B} id (v: environ -> val) (f: A1 -> B) (a: environ -> A1),
          subst id v (`f a)  = `f (subst id v a).

Hint Rewrite @subst_lift1  @subst_lift1C  : subst.

Lemma subst_lift2:
  forall {A1 A2 B} id v (f: A1 -> A2 -> B) a b,
          subst id v (lift2 f a b) = lift2 f (subst id v a) (subst id v b).

Lemma subst_lift2':
  forall {A1 A2 B} id v (f: A1 -> A2 -> B) a b,
          subst id v (fun rho => f (a rho) (b rho)) = fun rho => f (subst id v a rho) (subst id v b rho).

Lemma subst_lift2C:
  forall {A1 A2 B} id (v: environ -> val) (f: A1 -> A2 -> B) (a: environ -> A1) (b: environ -> A2),
          subst id v (`f a b) = `f (subst id v a) (subst id v b).

Hint Rewrite @subst_lift2  @subst_lift2C : subst.

Lemma subst_lift3:
  forall {A1 A2 A3 B} id v (f: A1 -> A2 -> A3 -> B) a1 a2 a3,
          subst id v (lift3 f a1 a2 a3) = lift3 f (subst id v a1) (subst id v a2) (subst id v a3).

Lemma subst_lift3':
  forall {A1 A2 A3 B} id v (f: A1 -> A2 -> A3 -> B) a1 a2 a3,
          subst id v (fun rho => f (a1 rho) (a2 rho) (a3 rho)) =
          fun rho => f (subst id v a1 rho) (subst id v a2 rho) (subst id v a3 rho).

Lemma subst_lift3C:
  forall {A1 A2 A3 B} id (v: environ -> val) (f: A1 -> A2 -> A3 -> B)
                  (a1: environ -> A1) (a2: environ -> A2) (a3: environ -> A3),
          subst id v (`f a1 a2 a3) = `f (subst id v a1) (subst id v a2) (subst id v a3).

Hint Rewrite @subst_lift3  @subst_lift3C : subst.

Lemma subst_lift4:
  forall {A1 A2 A3 A4 B} id v (f: A1 -> A2 -> A3 -> A4 -> B) a1 a2 a3 a4,
          subst id v (lift4 f a1 a2 a3 a4) = lift4 f (subst id v a1) (subst id v a2) (subst id v a3) (subst id v a4).

Lemma subst_lift4':
  forall {A1 A2 A3 A4 B} id v (f: A1 -> A2 -> A3 -> A4 -> B) a1 a2 a3 a4,
          subst id v (fun rho => f (a1 rho) (a2 rho) (a3 rho) (a4 rho)) =
          fun rho => f (subst id v a1 rho) (subst id v a2 rho) (subst id v a3 rho) (subst id v a4 rho).

Lemma subst_lift4C:
  forall {A1 A2 A3 A4 B} id (v: environ -> val) (f: A1 -> A2 -> A3 -> A4 -> B)
                  (a1: environ -> A1) (a2: environ -> A2) (a3: environ -> A3) (a4: environ -> A4),
          subst id v (`f a1 a2 a3 a4) = `f (subst id v a1) (subst id v a2) (subst id v a3) (subst id v a4).

Hint Rewrite @subst_lift4  @subst_lift4C : subst.

Lemma bool_val_int_eq_e:
  forall i j m, Cop.bool_val (Val.of_bool (Int.eq i j)) type_bool m = Some true ->

Lemma bool_val_notbool_ptr:
    forall v t m,
   match t with Tpointer _ _ => True | _ => False end ->
   (Cop.bool_val (force_val (Cop.sem_notbool v t m)) type_bool m = Some true) 

Definition retval : environ -> val := eval_id ret_temp.

Hint Rewrite eval_id_same : norm.
Hint Rewrite eval_id_other using solve [clear; intro Hx; inversion Hx] : norm.

Lemma simpl_get_result1:
 forall (f: val -> Prop) i, @liftx (Tarrow environ (LiftEnviron Prop)) (@liftx (Tarrow val (LiftEnviron Prop))f retval) (get_result1 i) = `f (eval_id i).
Hint Rewrite simpl_get_result1: norm.

Lemma retval_get_result1:
   forall i rho, retval (get_result1 i rho) = (eval_id i rho).
Hint Rewrite retval_get_result1 : norm.

Lemma retval_ext_rval:
  forall ge v, retval (make_ext_rval ge v) = force_val v.
Hint Rewrite retval_ext_rval : norm.

Lemma retval_lemma1:
  forall rho v,     retval (env_set rho ret_temp v) = v.
Hint Rewrite retval_lemma1 : norm.

Lemma retval_make_args:
  forall v rho, retval (make_args (ret_temp::nil) (v::nil) rho) = v.
Hint Rewrite retval_make_args: norm2.

Lemma andp_makeargs:
   forall (a b: environ -> mpred) d e,
   `(a && b) (make_args d e) = `a (make_args d e) && `b (make_args d e).
Hint Rewrite andp_makeargs: norm2.

Lemma local_makeargs:
   forall (f: val -> Prop) v,
   `(local (`(f) retval)) (make_args (cons ret_temp nil) (cons v nil))
    = (local (`(f) `(v))).
Hint Rewrite local_makeargs: norm2.

Lemma simpl_and_get_result1:
  forall (Q R: environ->mpred) i,
    `(Q && R) (get_result1 i) = `Q (get_result1 i) && `R (get_result1 i).
Hint Rewrite simpl_and_get_result1 : norm2.

Lemma liftx_local_retval:
  forall (P: val -> Prop) i,
   `(local (`P retval)) (get_result1 i) = local (`P (eval_id i)).
Hint Rewrite liftx_local_retval : norm2.

Hint Rewrite bool_val_notbool_ptr using apply Coq.Init.Logic.I : norm.

Lemma Vint_inj': forall i j,  (Vint i = Vint j) =  (i=j).

Lemma overridePost_normal_right:
  forall P Q R,
   P |-- Q ->
   P |-- RA_normal (overridePost Q R).

Fixpoint fold_right_and P0 (l: list Prop) : Prop :=
 match l with
 | nil => P0
 | b::r => b  /\ fold_right_and P0 r
 end.

Fixpoint fold_right_and_True (l: list Prop) : Prop :=
 match l with
 | nil => True
 | b :: nil => b
 | b::r => b /\ fold_right_and_True r
 end.

Definition fold_right_PROP_SEP (l1: list Prop) (l2: list mpred) : mpred :=
 match l1 with
 | nil => fold_right_sepcon l2
 | l => !! (fold_right_and_True l) && fold_right_sepcon l2
 end.

Lemma fold_right_PROP_SEP_spec: forall l1 l2,
  fold_right_PROP_SEP l1 l2 = !! (fold_right and True l1) && fold_right_sepcon l2.

Lemma typed_true_isptr:
 forall t, match t with Tpointer _ _ => True | Tarray _ _ _ => True | Tfunction _ _ _ => True | _ => False end ->
          typed_true t = isptr.

Hint Rewrite typed_true_isptr using apply Coq.Init.Logic.I : norm.

Ltac super_unfold_lift_in H :=
   cbv delta [liftx LiftEnviron Tarrow Tend lift_S lift_T
    lift_prod lift_last lifted lift_uncurry_open lift_curry lift lift0
    lift1 lift2 lift3] beta iota in H.

Ltac super_unfold_lift' :=
  cbv delta [liftx LiftEnviron Tarrow Tend lift_S lift_T
    lift_prod lift_last lifted lift_uncurry_open lift_curry lift lift0
    lift1 lift2 lift3] beta iota.

Lemma tc_eval'_id_i:
  forall Delta t i rho,
               tc_environ Delta rho ->
              (temp_types Delta)!i = Some t ->
              tc_val' t (eval_id i rho).

Lemma is_int_e:
 forall v i s , is_int i s v -> exists n, v = Vint n /\ is_int i s v.

Definition name (id: ident) := True.

Tactic Notation "name" ident(s) constr(id) :=
    assert (s: name id) by apply Coq.Init.Logic.I.

Definition reflect_temps_f (rho: environ) (b: Prop) (i: ident) (t: type) : Prop :=
  tc_val' t (eval_id i rho) /\ b.

Definition reflect_temps (Delta: tycontext) (rho: environ) : Prop :=
    PTree.fold (reflect_temps_f rho) (temp_types Delta) True.

Lemma reflect_temps_valid:
  forall Delta rho,
    tc_environ Delta rho -> reflect_temps Delta rho.

Definition abbreviate {A:Type} (x:A) := x.
Arguments abbreviate [A] [x].

Ltac clear_Delta :=
match goal with
| Delta := @abbreviate tycontext _ |- _ =>
   first [clear Delta | clearbody Delta]
| _ => idtac
end;
match goal with
 |  DS := @abbreviate (PTree.t funspec) _  |- _ =>
   first [clear DS | clearbody DS]
 | |- _ => idtac
 end.

Ltac clear_Delta_specs :=
 lazymatch goal with
 |  DS := @abbreviate (PTree.t funspec) _  |- _ => clearbody DS
 | |- _ => idtac
 end.

Ltac findvars :=
 match goal with DD: tc_environ ?Delta ?rho |- _ =>
  let H := fresh in
    assert (H := reflect_temps_valid _ _ DD);
    try (unfold Delta in H);
   cbv beta iota zeta delta [abbreviate PTree.fold PTree.prev PTree.prev_append PTree.xfold temp_types fst snd
             reflect_temps reflect_temps_f] in H;
   simpl in H;
   repeat match goal with

    | Name: name ?J |- context [eval_id ?J rho] =>
            fold J in H;
            clear Name;
           forget (eval_id J rho) as Name
    | |- context [eval_id ?J rho] =>
           try fold J in H;
           let Name := fresh "_id" in forget (eval_id J rho) as Name
    | Name: name _ |- _ =>
          clear Name
     end;
    repeat match type of H with
                | _ (eval_id _ _) /\ _ =>  destruct H as [_ H]
                | is_int _ _ ?i /\ _ => let TC := fresh "TC" in destruct H as [TC H];
                                let i' := fresh "id" in rename i into i';
                               apply is_int_e in TC; destruct TC as [i [? TC]]; subst i';
                                simpl in TC;
                               match type of TC with True => clear TC | _ => idtac end
                | _ /\ _ => destruct H as [?TC H]
                end;
    clear H
 end.

Lemma is_true_negb:
 forall a, is_true (negb a) -> a=false.

Lemma sem_cast_pointer2':
  forall (v : val) (t1 t2: type),
  match t1 with
  | Tpointer _ _ => is_true (negb (eqb_type t1 int_or_ptr_type))
  | Tint I32 _ _ => if Archi.ptr64 then False else True 

Hint Rewrite sem_cast_pointer2' using (try apply Coq.Init.Logic.I; try assumption; reflexivity) : norm.

Lemma sem_cast_pointer2:
  forall v t1 t2 t3 t1' t2',
   t1' = Tpointer t1 noattr ->
   t2' = Tpointer t2 noattr ->
   tc_val (Tpointer t3 noattr) v ->
   force_val (sem_cast t1' t2' v) = v.

Lemma force_eval_var_int_ptr :
forall  {cs: compspecs}  Delta rho i t,
tc_environ Delta rho ->
tc_lvalue Delta (Evar i t) rho |--
        !! (force_val
            match eval_var i t rho with

            | Vptr _ _ => Some (eval_var i t rho)
            | _ => None
            end = eval_var i t rho).

Lemma is_pointer_or_null_force_int_ptr:
   forall v, is_pointer_or_null v -> (force_val
        match v with
        | Vint _ => if Archi.ptr64 then None else Some v
Hint Rewrite is_pointer_or_null_force_int_ptr using assumption : norm1.

Lemma is_pointer_force_int_ptr:
   forall v, isptr v -> (force_val
        match v with
        | Vint _ => if Archi.ptr64 then None else Some v
Hint Rewrite is_pointer_force_int_ptr using assumption : norm1.

Lemma is_pointer_or_null_match :
   forall v, is_pointer_or_null v ->
        (match v with
        | Vint _ => if Archi.ptr64 then None else Some v
Hint Rewrite is_pointer_or_null_match using assumption : norm1.

Lemma is_pointer_force_int_ptr2:
   forall v, isptr v ->
        match v with
        | Vint _ => if Archi.ptr64 then None else Some v
Hint Rewrite is_pointer_force_int_ptr2 using assumption : norm1.

Lemma is_pointer_or_null_force_int_ptr2:
   forall v, is_pointer_or_null (force_val
        match v with
        | Vint _ => Some v
        | Vptr _ _ => Some v
        | _ => None
         end) -> (force_val
        match v with
        | Vint _ => Some v
        | Vptr _ _ => Some v
        | _ => None
         end) = v.

Hint Rewrite is_pointer_or_null_force_int_ptr2 using assumption : norm1.

Lemma isptr_match : forall w0,
is_pointer_or_null
         match
           match w0 with
          | Vint _ => if Archi.ptr64 then None else Some w0

Hint Rewrite isptr_match : norm1.

Lemma eval_cast_neutral_tc_val:
   forall v, (exists t, tc_val t v /\ is_pointer_type t = true) ->
       sem_cast_pointer v = Some v.

Hint Rewrite eval_cast_neutral_tc_val using solve [eauto] : norm.

Lemma eval_cast_neutral_is_pointer_or_null:
   forall v, is_pointer_or_null v -> sem_cast_pointer v = Some v.
Hint Rewrite eval_cast_neutral_is_pointer_or_null using assumption : norm.

Lemma is_pointer_or_null_eval_cast_neutral:
  forall v, is_pointer_or_null (force_val (sem_cast_pointer v)) = is_pointer_or_null v.
Hint Rewrite is_pointer_or_null_eval_cast_neutral : norm.

Lemma eval_cast_neutral_isptr:
   forall v, isptr v -> sem_cast_pointer v = Some v.
Hint Rewrite eval_cast_neutral_isptr using assumption : norm.

Arguments ret_type !Delta /.

Arguments Datatypes.id {A} x / .

Lemma raise_sepcon:
 forall A B : environ -> mpred ,
    (fun rho: environ => A rho * B rho) = (A * B).
Hint Rewrite raise_sepcon : norm1.

Lemma lift1_lift1_retval {A}: forall i (P: val -> A),
lift1 (lift1 P retval) (get_result1 i) = lift1 P (eval_id i).

Lemma lift_lift_retval:
  forall (i: ident) P,
   @liftx (Tarrow environ (LiftEnviron mpred))
     (@liftx (Tarrow val (LiftEnviron mpred)) P retval) (get_result1 i) = `P (eval_id i).
Hint Rewrite lift_lift_retval: norm2.

Lemma lift_lift_x:  
  forall t t' P (v: t),
  (@liftx (Tarrow t (LiftEnviron t')) P (@liftx (LiftEnviron t) v)) =
  (@liftx (LiftEnviron t') (P v)).
Hint Rewrite lift_lift_x : norm2.

Lemma lift0_exp {A}{NA: NatDed A}:
  forall (B: Type) (f: B -> A), lift0 (exp f) = EX x:B, lift0 (f x).

Lemma lift0C_exp {A}{NA: NatDed A}:
  forall (B: Type) (f: B -> A), `(exp f) = EX x:B, `(f x).
Hint Rewrite @lift0_exp : norm2.
Hint Rewrite @lift0C_exp : norm2.

Lemma lift0_andp {A}{NA: NatDed A}:
 forall P Q,
   lift0 (@andp A NA P Q) = andp (lift0 P) (lift0 Q).

Lemma lift0C_andp {A}{NA: NatDed A}:
 forall P Q: A,
  `(@andp A NA P Q) =
  andp (`P) (`Q).

Lemma lift0_prop {A}{NA: NatDed A}:
 forall P, lift0 (!! P) = !!P.

Lemma lift0C_prop {A}{NA: NatDed A}:
 forall P, @liftx (LiftEnviron A) (@prop A NA P) =
                  @prop (environ -> A) _ P.

Lemma lift0_sepcon {A}{NA: NatDed A}{SA: SepLog A}:
 forall P Q,
  lift0 (@sepcon A NA SA P Q) = sepcon (lift0 P) (lift0 Q).

Lemma lift0C_sepcon {A}{NA: NatDed A}{SA: SepLog A}:
 forall P Q N2 S2,
  (@liftx (LiftEnviron A) (@sepcon A N2 S2 P Q)) =
  (@sepcon (environ->A) _ _
     (@liftx (LiftEnviron A) P)
     (@liftx (LiftEnviron A) Q)).

Lemma lift0_later {A}{NA: NatDed A}{IA: Indir A}:
  forall P:A,
   lift0 (@later A NA IA P) = later  (lift0 P).

Lemma lift0C_later {A}{NA: NatDed A}{IA: Indir A}:
  forall P:A,
   `(@later A NA IA P) = @later (environ->A) _ _ (`P).

Hint Rewrite (@lift0C_sepcon mpred _ _) : norm.
Hint Rewrite (@lift0C_andp mpred _) : norm.
Hint Rewrite (@lift0C_exp mpred _) : norm.
Hint Rewrite (@lift0C_later mpred _ _) : norm.
Hint Rewrite (@lift0C_prop mpred _) : norm.

Hint Rewrite
    @lift1_lift1_retval
    @lift0_exp
    @lift0_sepcon
    @lift0_prop
    @lift0_later
    : norm2.

Lemma fst_unfold: forall {A B} (x: A) (y: B), fst (x,y) = x.
Lemma snd_unfold: forall {A B} (x: A) (y: B), snd (x,y) = y.
Hint Rewrite @fst_unfold @snd_unfold : norm.

Lemma eq_True:
   forall (A: Prop), A -> (A=True).

Lemma derives_extract_PROP :
  forall (P1: Prop) A P QR S,
     (P1 -> A && PROPx P QR |-- S) ->
     A && PROPx (P1::P) QR |-- S.

Lemma local_andp_prop:  forall P Q, local P && prop Q = prop Q && local P.
Lemma local_andp_prop1: forall P Q R, local P && (prop Q && R) = prop Q && (local P && R).
Hint Rewrite local_andp_prop local_andp_prop1 : norm2.

Lemma local_sepcon_assoc1:
   forall P Q R, (local P && Q) * R = local P && (Q * R).
Lemma local_sepcon_assoc2:
   forall P Q R, R * (local P && Q) = local P && (R * Q).
Hint Rewrite local_sepcon_assoc1 local_sepcon_assoc2 : norm2.

Definition do_canon (x y : environ->mpred) := (sepcon x y).

Ltac strip1_later P :=
 match P with
 | do_canon ?L ?R => let L' := strip1_later L in let R' := strip1_later R in constr:(do_canon L' R')
 | PROPx ?P ?QR => let QR' := strip1_later QR in constr:(PROPx P QR')
 | LOCALx ?Q ?R => let R' := strip1_later R in constr:(LOCALx Q R')
 | SEPx ?R => let R' := strip1_later R in constr:(SEPx R')
 | ?L::?R => let L' := strip1_later L in let R' := strip1_later R in constr:(L'::R')
 | nil => constr:(nil)
 | ?L && ?R => let L' := strip1_later L in let R' := strip1_later R in constr:(L' && R')
 | ?L * ?R => let L' := strip1_later L in let R' := strip1_later R in constr:(L'*R')
 | |> ?L => constr:(L)
 | ?L => constr:(L)
end.

Lemma andp_later_derives {A} {NA: NatDed A}{IA: Indir A}:
  forall P Q P' Q': A, P |-- |> P' -> Q |-- |> Q' -> P && Q |-- |> (P' && Q').

Lemma sepcon_later_derives {A} {NA: NatDed A}{SL: SepLog A}{IA: Indir A}{SI: SepIndir A}:
  forall P Q P' Q': A, P |-- |> P' -> Q |-- |> Q' -> P * Q |-- |> (P' * Q').

Hint Resolve @andp_later_derives @sepcon_later_derives @sepcon_derives
              @andp_derives @imp_derives @now_later @derives_refl: derives.

Notation "'DECLARE' x s" := (x: ident, s: funspec)
   (at level 160, x at level 0, s at level 150, only parsing).

Notation " a 'OF' ta " := (a%positive,ta%type) (at level 100, only parsing): formals.
Delimit Scope formals with formals.

Definition NDsemax_external {Hspec: OracleKind} (ids: list ident) (ef: external_function)
  (A: Type) (P Q: A -> environ -> mpred): Prop :=
  @semax_external Hspec ids ef (rmaps.ConstType A) (fun _ => P) (fun _ => Q).

Notation "'WITH' x : tx 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default tx (fun x => P%assert) (fun x => Q%assert))
            (at level 200, x at level 0, P at level 100, Q at level 100).

Notation "'WITH' x : tx 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default tx (fun x => P%assert) (fun x => Q%assert))
            (at level 200, x at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2)
           (fun x => match x with (x1,x2) => P%assert end)
           (fun x => match x with (x1,x2) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2)
           (fun x => match x with (x1,x2) => P%assert end)
           (fun x => match x with (x1,x2) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3)
           (fun x => match x with (x1,x2,x3) => P%assert end)
           (fun x => match x with (x1,x2,x3) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3)
           (fun x => match x with (x1,x2,x3) => P%assert end)
           (fun x => match x with (x1,x2,x3) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4)
           (fun x => match x with (x1,x2,x3,x4) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4)
           (fun x => match x with (x1,x2,x3,x4) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5)
           (fun x => match x with (x1,x2,x3,x4,x5) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, x5 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5)
           (fun x => match x with (x1,x2,x3,x4,x5) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, x5 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6)
           (fun x => match x with (x1,x2,x3,x4,x5,x6) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6)
           (fun x => match x with (x1,x2,x3,x4,x5,x6) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,  x13 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,  x13 at level 0, x14 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
              x20 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
             x20 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 , x21 : t21 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20*t21)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
              x20 at level 0, x21 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 , x21 : t21 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20*t21)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
             x20 at level 0, x21 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 , x21 : t21 , x22 : t22 'PRE'  [ ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec (nil, tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20*t21*t22)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
              x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
              x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
              x20 at level 0, x21 at level 0, x22 at level 0,
             P at level 100, Q at level 100).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 , x18 : t18 , x19 : t19 , x20 : t20 , x21 : t21 , x22 : t22 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17*t18*t19*t20*t21*t22)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             x15 at level 0, x16 at level 0, x17 at level 0, x18 at level 0, x19 at level 0,
             x20 at level 0, x21 at level 0, x22 at level 0,
             P at level 100, Q at level 100).

Lemma prop_true_andp1 {A}{NA: NatDed A} :
  forall (P1 P2: Prop) Q ,
    P1 -> (!! (P1 /\ P2) && Q = !!P2 && Q).
Hint Rewrite prop_true_andp1 using solve [auto 3 with typeclass_instances]: norm1.
Hint Rewrite prop_true_andp1 using assumption : norm.

Lemma and_assoc': forall A B C: Prop,
  ((A /\ B) /\ C) = (A /\ (B /\ C)).

Ltac splittablex_tac A :=
 match A with
 | _ <= _ < _ => fail 1
 | _ < _ <= _ => fail 1
 | _ <= _ <= _ => fail 1
 | _ < _ < _ => fail 1
 | _ <-> _ => fail 1
 | _ /\ _ => apply Logic.I
 end.

Definition splittablex (A: Prop) := True.

Lemma and_assoc_splittablex {T}{NT: NatDed T}: forall A B C: Prop,
    splittablex (A /\ B) ->
  !! ((A /\ B) /\ C) = !! (A /\ (B /\ C)).

Lemma and_assoc'' {T}{NT: NatDed T}: forall A B C: Prop,
  !! ((A /\ B) /\ C) = !! (A /\ (B /\ C)).

Hint Rewrite and_assoc_splittablex using 
    match goal with |- splittablex ?A => splittablex_tac A end : normalize.
Hint Rewrite and_assoc_splittablex using 
    match goal with |- splittablex ?A => splittablex_tac A end : gather_prop.

Ltac hoist_later_left :=
   match goal with
  | |- (?P |-- _) =>
        let P' := strip1_later P in
        apply derives_trans with (|>P');
         [ solve [ auto 50 with derives ] | ]
  end.

Lemma semax_later_trivial: forall Espec  {cs: compspecs} Delta P c Q,
  @semax cs Espec Delta (|> P) c Q ->
  @semax cs Espec Delta P c Q.

Ltac hoist_later_in_pre :=
     match goal with |- semax _ ?P _ _ =>
       match P with
       | context[@later] =>
            let P' := strip1_later P in apply semax_pre0 with (|> P'); [solve [auto 50 with derives] | ]
       | _ => apply semax_later_trivial
       end
     end.

Ltac type_of_field_tac :=
 simpl;
  repeat first [rewrite if_true by auto
                    | rewrite if_false by (let H:=fresh in intro H; inversion H)
                    | simpl; reflexivity].

Ltac simpl_tc_expr :=
    match goal with |- context [tc_expr ?A ?B] =>
        change (tc_expr A B) with (denote_tc_assert (typecheck_expr A B));
        simpl typecheck_expr; simpl denote_tc_assert
    end.

Lemma prop_and1 {A}{NA: NatDed A}:
  forall P Q : Prop, P -> !!(P /\ Q) = !!Q.
Hint Rewrite prop_and1 using solve [auto 3 with typeclass_instances] : norm2.

Lemma subst_make_args':
  forall  {cs: compspecs}  id v (P: environ->mpred) fsig tl el,
  length tl = length el ->
  length (fst fsig) = length el ->
  subst id v (`P (make_args' fsig (eval_exprlist tl el))) =
           (`P (make_args' fsig (subst id v (eval_exprlist tl el)))).
Hint Rewrite @subst_make_args' using (solve[reflexivity]) : subst.

Lemma map_cons: forall {A B} (f: A -> B) x y,
   map f (x::y) = f x :: map f y.

Hint Rewrite @map_cons : norm.
Hint Rewrite @map_cons : subst.

Lemma map_nil: forall {A B} (f: A -> B), map f nil = nil.

Hint Rewrite @map_nil : norm.
Hint Rewrite @map_nil : subst.

Fixpoint remove_localdef_temp (i: ident) (l: list localdef) : list localdef :=
  match l with
  | nil => nil
  | d :: l0 =>
     match d with
     | temp j v =>
       if ident_eq i j
       then remove_localdef_temp i l0
       else d :: remove_localdef_temp i l0
     | _ => d :: remove_localdef_temp i l0
     end
  end.

Lemma subst_stackframe_of:
  forall {cs: compspecs} i v f, subst i v (stackframe_of f) = stackframe_of f.
Hint Rewrite @subst_stackframe_of : subst.

Lemma remove_localdef_temp_PROP: forall (i: ident) P Q R,
  EX old: val, subst i `(old) (PROPx P (LOCALx Q (SEPx R))) |--
  PROPx P (LOCALx (remove_localdef_temp i Q) (SEPx R)).

Lemma eval_id_denote_tc_initialized: forall Delta i t v,
  (temp_types Delta) ! i = Some t ->
  local (tc_environ Delta) && local (`and (`(eq v) (eval_id i)) `(v <> Vundef)) |-- denote_tc_initialized i t.

Lemma PQR_denote_tc_initialized: forall Delta i t v P Q R,
  (temp_types Delta) ! i = Some t ->
  local (tc_environ Delta) && PROPx P (LOCALx (temp i v :: Q) R) |-- denote_tc_initialized i t.

Lemma derives_remove_localdef_PQR: forall P Q R i,
  PROPx P (LOCALx Q (SEPx R)) |-- PROPx P (LOCALx (remove_localdef_temp i Q) (SEPx R)).

Lemma subst_remove_localdef_PQR: forall P Q R i v,
  subst i v (PROPx P (LOCALx (remove_localdef_temp i Q) (SEPx R))) |-- PROPx P (LOCALx (remove_localdef_temp i Q) (SEPx R)).

Fixpoint iota_formals (i: ident) (tl: typelist) :=
 match tl with
 | Tcons t tl' => (i,t) :: iota_formals (i+1)%positive tl'
 | Tnil => nil
 end.

Ltac make_sequential :=
  match goal with
  | |- @semax _ _ _ _ _ (normal_ret_assert _) => idtac
  | |- _ => apply sequential
  end.

Lemma isptr_force_ptr'' : forall p Q,
    (isptr p -> Q) ->
    (isptr (force_ptr p) -> Q).

Lemma isptr_offset_val'': forall i p Q,
    (isptr p -> Q) ->
    (isptr (offset_val i p) -> Q).

Lemma ptr_eq_e': forall v1 v2 B,
   (v1=v2 -> B) ->
   (ptr_eq v1 v2 -> B).

Lemma typed_false_of_bool':
 forall x (P: Prop),
    ((x=false) -> P) ->
    (typed_false tint (Val.of_bool x) -> P).

Lemma typed_true_of_bool':
 forall x (P: Prop),
    ((x=true) -> P) ->
    (typed_true tint (Val.of_bool x) -> P).

Ltac intro_if_new :=
 repeat match goal with
  | |- ?A -> _ => ((assert A by auto; fail 1) || fail 1) || intros _
  | |- (_ <-> _) -> _ =>
         intro
  | |- (?A /\ ?B) -> ?C =>
         apply (@and_ind A B C)
  | |- isptr (force_ptr ?P) -> ?Q =>
         apply (isptr_force_ptr'' P Q)
  | |- isptr (offset_val ?i ?P) -> ?Q =>
         apply (isptr_offset_val'' i P Q)
  | H: is_pointer_or_null ?P |- isptr ?P -> _ =>
         clear H
  | |- ?x = ?y -> _ =>
          let H := fresh in intro H;
                     first [subst x | subst y
                             | is_var x; rewrite H
                             | is_var y; rewrite <- H
                             | solve [discriminate H]
                             | idtac]
  | |- isptr ?x -> _ =>
          let H := fresh "P" x in intro H
  | |- is_pointer_or_null ?x =>
          let H := fresh "PN" x in intro H
  | |- typed_false _ (Val.of_bool _) -> _ =>
          simple apply typed_false_of_bool'
  | |- typed_true _ (Val.of_bool _) -> _ =>
          simple apply typed_true_of_bool'
  | |- ptr_eq _ _ -> _ =>
          apply ptr_eq_e'
  | |- _ -> _ =>
          intro
  end.

Lemma saturate_aux20:
 forall (P Q: mpred) P' Q' ,
    P |-- !! P' ->
    Q |-- !! Q' ->
    P * Q |-- !! (P' /\ Q').

Lemma saturate_aux21:  
  forall (P Q: mpred) S (S': Prop),
   P |-- S ->
   S = !!S' ->
   !! S' && P |-- Q -> P |-- Q.

Lemma saturate_aux21x:
  forall (P Q S: mpred),
   P |-- S ->
   S && P |-- Q -> P |-- Q.

Ltac already_saturated :=
(match goal with |- ?P |-- ?Q =>
    let H := fresh in
     assert (H: P |-- Q) by auto with nocore saturate_local;
     cbv beta in H;
     match type of H with _ |-- !! ?Q' =>
     assert (Q') by (repeat simple apply conj; auto);
     fail 3
     end
end || auto with nocore saturate_local)
 || simple apply prop_True_right.

Ltac saturate_local :=
simple eapply saturate_aux21x;
 [repeat simple apply saturate_aux20;
       auto with nocore saturate_local;
    simple apply prop_True_right

 | simple apply derives_extract_prop;
   match goal with |- _ -> ?A =>
       let P := fresh "P" in set (P := A);
       fancy_intros true;
       subst P
      end
 ].

Lemma prop_right_emp {A} {NA: NatDed A}:
 forall P: Prop, P -> emp |-- !! P.

Ltac prop_right_cautious :=
 try solve [simple apply prop_right; auto].

Ltac subst_any :=
 repeat match goal with
  | H: ?x = ?y |- _ => first [ subst x | subst y ]
 end.

Lemma prop_and_right {A}{NA: NatDed A}:
 forall (U: A) (X Y: Prop),
    X ->
    U |-- !! Y ->
    U |-- !! (X /\ Y).

Lemma fold_right_sepcon_subst:
 forall i e R, fold_right sepcon emp (map (subst i e) R) = subst i e (fold_right sepcon emp R).

Lemma unsigned_eq_eq: forall i j, Int.unsigned i = Int.unsigned j -> i = j.

Ltac solve_mod_eq :=
  unfold Int.add, Int.mul;
  repeat rewrite Int.unsigned_repr_eq;
  repeat
  (repeat rewrite Zmod_mod;
  repeat rewrite Zmult_mod_idemp_l;
  repeat rewrite Zmult_mod_idemp_r;
  repeat rewrite Zplus_mod_idemp_l;
  repeat rewrite Zplus_mod_idemp_r).

Lemma prop_false_andp {A}{NA :NatDed A}:
 forall P Q, ~P -> !! P && Q = FF.

Lemma wand_join {A}{NA: NatDed A}{SA: SepLog A}:
  forall x1 x2 y1 y2: A,
    (x1 -* y1) * (x2 -* y2) |-- ((x1 * x2) -* (y1 * y2)).

Lemma wand_sepcon:
 forall {A} {NA: NatDed A}{SA: SepLog A} P Q,
   (P -* Q * P) * P = Q * P.

Lemma wand_sepcon':
 forall {A} {NA: NatDed A}{SA: SepLog A} P Q,
   P * (P -* Q * P) = P * Q.

Hint Rewrite wand_sepcon wand_sepcon' : norm.

Lemma extract_nth_exists_in_SEP:
  forall n P Q (R: list mpred)
              {A} (S: A -> mpred),
   nth n R emp = (exp S) ->
   PROPx P (LOCALx Q (SEPx R)) =
   exp (fun x => PROPx P (LOCALx Q (SEPx (replace_nth n R (S x))))).

Ltac extract_exists_in_SEP' PQR :=
 match PQR with
 | PROPx ?P (LOCALx ?Q (SEPx (?R))) =>
   match R with context [(@exp _ _ ?A ?S) :: ?R'] =>
      let n := constr:((length R - Datatypes.S (length R'))%nat) in
      let n' := eval lazy beta zeta iota delta in n in
      rewrite (@extract_nth_exists_in_SEP n' P Q R A S (eq_refl _));
      unfold replace_nth at 1;
      rewrite ?exp_andp2
   end
 end.

Ltac extract_exists_from_SEP :=
match goal with
  | |- semax _ ?Pre _ _ =>
    extract_exists_in_SEP' Pre; apply extract_exists_pre
  | |- _ && ?Pre |-- ?Post =>
     let P := fresh "POST" in set (P := Post);
    extract_exists_in_SEP' Pre; subst P; apply exp_left
  | |- ?Pre |-- ?Post => 
     let P := fresh "POST" in set (P := Post);
    extract_exists_in_SEP' Pre; subst P; apply exp_left
end.

Ltac move_from_SEP' PQR :=
 match PQR with
 | PROPx ?P (LOCALx ?Q (SEPx (?R))) =>
   match R with context [(prop ?P1 && ?S) :: ?R'] =>
      let n := constr:((length R - Datatypes.S (length R'))%nat) in
      let n' := eval lazy beta zeta iota delta in n in
      rewrite(@extract_prop_in_SEP n' P1 S P Q R (eq_refl _));
      unfold replace_nth at 1
   end
 end.

Lemma derives_extract_PROP' :
  forall (P1: Prop) P QR S,
     (P1 -> PROPx P QR |-- S) ->
     PROPx (P1::P) QR |-- S.

Ltac Intro_prop :=
autorewrite with gather_prop;
match goal with
 | |- semax _ ?PQR _ _ =>
     first [ is_evar PQR; fail 1
            | simple apply semax_extract_PROP; fancy_intros false
            | move_from_SEP' PQR;
              simple apply semax_extract_PROP; fancy_intros false
            | flatten_in_SEP PQR
            ]
 | |- _ && ?PQR |-- _ =>
     first [ is_evar PQR; fail 1
            | simple apply derives_extract_prop; fancy_intros false
            | simple apply derives_extract_PROP; fancy_intros false
            | move_from_SEP' PQR;
               simple apply derives_extract_PROP; fancy_intros false
            | flatten_in_SEP PQR
             ]
 | |- ?PQR |-- _ =>  
     first [ is_evar PQR; fail 1
            | simple apply derives_extract_prop; fancy_intros false
            | simple apply derives_extract_PROP; fancy_intros false
            | move_from_SEP' PQR;
               simple apply derives_extract_PROP; fancy_intros false
            | flatten_in_SEP PQR
             ]
end.

Ltac Intro'' a :=
  first [ simple apply extract_exists_pre; intro a
         | simple apply exp_left; intro a
         | rewrite exp_andp1; Intro'' a
         | rewrite exp_andp2; Intro'' a
         | rewrite exp_sepcon1; Intro'' a
         | rewrite exp_sepcon2; Intro'' a
         | extract_exists_from_SEP; intro a
         ].

Ltac Intro a :=
  repeat Intro_prop;
  match goal with
  | |- ?A |-- ?B =>
     let z := fresh "z" in pose (z:=B); change (A|--z); Intro'' a; subst z
  | |- semax _ _ _ _ =>
     Intro'' a
  end.

Tactic Notation "Intros" := repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0) :=
 Intro x0; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) :=
 Intro x0; Intro x1; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2) :=
 Intro x0; Intro x1; Intro x2; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) :=
 Intro x0; Intro x1; Intro x2; Intro x3; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6)
 simple_intropattern(x7) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; Intro x7; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6)
 simple_intropattern(x7) simple_intropattern(x8) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; Intro x7; Intro x8; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6)
 simple_intropattern(x7) simple_intropattern(x8)
 simple_intropattern(x9) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; Intro x7; Intro x8; Intro x9; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6)
 simple_intropattern(x7) simple_intropattern(x8)
 simple_intropattern(x9) simple_intropattern(x10) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; Intro x7; Intro x8; Intro x9;
 Intro x10; repeat Intro_prop.

Tactic Notation "Intros" simple_intropattern(x0)
 simple_intropattern(x1) simple_intropattern(x2)
 simple_intropattern(x3) simple_intropattern(x4)
 simple_intropattern(x5) simple_intropattern(x6)
 simple_intropattern(x7) simple_intropattern(x8)
 simple_intropattern(x9) simple_intropattern(x10)
 simple_intropattern(x11) :=
 Intro x0; Intro x1; Intro x2; Intro x3; Intro x4;
 Intro x5; Intro x6; Intro x7; Intro x8; Intro x9;
 Intro x10; Intro x11; repeat Intro_prop.

Ltac extract_exists_from_SEP_right :=
match goal with
  | |- ?Pre |-- ?Post =>
     let P := fresh "PRE" in set (P := Pre);
    extract_exists_in_SEP' Post; subst P
end.

Ltac Exists'' a :=
  first [apply exp_right with a
         | rewrite exp_andp1; Exists'' a
         | rewrite exp_andp2; Exists'' a
         | rewrite exp_sepcon1; Exists'' a
         | rewrite exp_sepcon2; Exists'' a
         | extract_exists_from_SEP_right; apply exp_right with a
         ].

Ltac Exists' a :=
  match goal with |- ?A |-- ?B =>
     let z := fresh "z" in pose (z:=A); change (z|--B); Exists'' a; subst z
  end.

Tactic Notation "Exists" constr(x0) :=
 Exists' x0.

Tactic Notation "Exists" constr(x0) constr(x1) :=
 Exists' x0; Exists x1.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) :=
 Exists' x0; Exists' x1; Exists' x2.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) constr(x8) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7; Exists' x8.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) constr(x8) constr(x9) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7; Exists' x8; Exists' x9.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) constr(x8) constr(x9)
 constr(x10) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7; Exists' x8; Exists' x9;
 Exists' x10.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) constr(x8) constr(x9)
 constr(x10) constr(x11) :=
 Exists' x0; Exists' x1; Exists' x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7; Exists' x8; Exists' x9;
 Exists' x10; Exists' x11.

Tactic Notation "Exists" constr(x0) constr(x1) constr(x2) constr(x3)
 constr(x4) constr(x5) constr(x6) constr(x7) constr(x8) constr(x9)
 constr(x10) constr(x11) constr(x12) :=
 Exists' x0; Exists' x1; Exists x2; Exists' x3; Exists' x4;
 Exists' x5; Exists' x6; Exists' x7; Exists' x8; Exists' x9;
 Exists' x10; Exists' x11; Exists' x12.

Ltac my_evar name T cb :=
  let x := fresh name
  in
  evar (x : T);
    let x' := eval unfold x in x
    in
    clear x; cb x'.

Ltac tuple_evar name T cb :=
  lazymatch T with
  | prod ?A ?B => tuple_evar name A
    ltac: (fun xA =>
      tuple_evar name B ltac: (fun xB =>
        cb (xA, xB)))
  | _ => my_evar name T cb
  end; idtac.

Ltac EExists'' :=
  let EExists_core :=
    match goal with [ |- _ |-- EX x:?T, _ ] =>
      tuple_evar x T ltac: (fun x => apply exp_right with x)
    end; idtac
  in
  first [ EExists_core
         | rewrite exp_andp1; EExists''
         | rewrite exp_andp2; EExists''
         | rewrite exp_sepcon1; EExists''
         | rewrite exp_sepcon2; EExists''
         | extract_exists_from_SEP_right; EExists_core
         ].

Ltac EExists' :=
  match goal with |- ?A |-- ?B =>
     let z := fresh "z" in pose (z:=A); change (z|--B); EExists''; unfold z at 1; clear z
  end.

Ltac EExists := EExists'.

Ltac EExists_alt :=
  let T := fresh "T"
  in
  let x := fresh "x"
  in
  evar (T:Type); evar (x:T); subst T; Exists x; subst x.

Tactic Notation "freeze1" uconstr(a) :=
    let x := fresh "x" in set (x:=a);
    let fr := fresh "freeze" in pose (fr := @abbreviate mpred x);
    change x with fr; subst x. *)

Require Import VST.floyd.type_induction.
(* VST.floyd.type_induction:
Require Import VST.floyd.base2.
Require Import VST.floyd.fieldlist.
Require Import VST.floyd.computable_theorems.
Open Scope nat.

Inductive ListType: list Type -> Type :=
  | Nil: ListType nil
  | Cons: forall {A B} (a: A) (b: ListType B), ListType (A :: B).

Fixpoint ListTypeGen {A} (F: A -> Type) (f: forall A, F A) (l: list A) : ListType (map F l) :=
  match l with
  | nil => Nil
  | cons h t => Cons (f h) (ListTypeGen F f t)
  end.

Lemma ListTypeGen_preserve: forall A F f1 f2 (l: list A),
  (forall a, In a l -> f1 a = f2 a) ->
  ListTypeGen F f1 l = ListTypeGen F f2 l.

Definition decay' {X} {F: Type} {l: list X} (v: ListType (map (fun _ => F) l)): list F.

Fixpoint decay'' {X} {F: Type} (l0 : list Type) (v: ListType l0) :
  forall (l: list X), l0 = map (fun _ => F) l -> list F :=
  match v in ListType l1
    return forall l2, l1 = map (fun _ => F) l2 -> list F
  with
  | Nil => fun _ _ => nil
  | Cons A B a b =>
    fun (l1 : list X) (E0 : A :: B = map (fun _ : X => F) l1) =>
    match l1 as l2 return (A :: B = map (fun _ : X => F) l2 -> list F) with
    | nil => fun _ => nil 
    | x :: l2 =>
       fun E1 : A :: B = map (fun _ : X => F) (x :: l2) =>
       (fun
          X0 : map (fun _ : X => F) (x :: l2) =
               map (fun _ : X => F) (x :: l2) -> list F =>
        X0 eq_refl)
         match
           E1 in (_ = y)
           return (y = map (fun _ : X => F) (x :: l2) -> list F)
         with
         | eq_refl =>
             fun H0 : A :: B = map (fun _ : X => F) (x :: l2) =>
              (fun (H3 : A = F) (H4 : B = map (fun _ : X => F) l2) =>
                  (eq_rect A (fun A0 : Type => A0) a F H3) :: (decay'' B b l2 H4))
                 (f_equal
                    (fun e : list Type =>
                     match e with
                     | nil => A
                     | T :: _ => T
                     end) H0)
                (f_equal
                   (fun e : list Type =>
                    match e with
                    | nil => B
                    | _ :: l3 => l3
                    end) H0)
         end
    end E0
  end.

Definition decay {X} {F: Type} {l: list X} (v: ListType (map (fun _ => F) l)): list F :=
  let l0 := map (fun _ => F) l in
  let E := @eq_refl _ (map (fun _ => F) l) : l0 = map (fun _ => F) l in
  decay'' l0 v l E.

Lemma decay_spec: forall A F f l,
  decay (ListTypeGen (fun _: A => F) f l) = map f l.

Section COMPOSITE_ENV.
Context {cs: compspecs}.

Lemma type_ind: forall P : type -> Prop,
  (forall t,
  match t with
  | Tarray t0 _ _ => P t0
  | Tstruct id _ => let m := co_members (get_co id) in Forall (fun it => P (field_type (fst it) m)) m
  | Tunion id _ => let m := co_members (get_co id) in Forall (fun it => P (field_type (fst it) m)) m
  | _ => True
  end -> P t) ->
  forall t, P t.

Ltac type_induction t :=
  pattern t;
  match goal with
  | |- ?P t =>
    apply type_ind; clear t;
    let t := fresh "t" in
    intros t IH;
    let id := fresh "id" in
    let a := fresh "a" in
    destruct t as [| | | | | | | id a | id a]
  end.

Variable A: type -> Type.

Definition FT_aux id :=
    let m := co_members (get_co id) in
    ListType (map (fun it => A (field_type (fst it) m)) m).

Variable F_ByValue: forall t: type, A t.
Variable F_Tarray: forall t n a, A t -> A (Tarray t n a).
Variable F_Tstruct: forall id a, FT_aux id -> A (Tstruct id a).
Variable F_Tunion: forall id a, FT_aux id -> A (Tunion id a).

Fixpoint type_func_rec (n: nat) (t: type): A t :=
  match n with
  | 0 =>
    match t as t0 return A t0 with
    | Tstruct id a =>
       match cenv_cs ! id with
       | None => let m := co_members (get_co id) in
                       F_Tstruct id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => F_ByValue (field_type (fst it) m)) m)
       | _ => F_ByValue (Tstruct id a)
       end
    | Tunion id a =>
       match cenv_cs ! id with
       | None => let m := co_members (get_co id) in
                      F_Tunion id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => F_ByValue (field_type (fst it) m)) m)
       | _ => F_ByValue (Tunion id a)
       end
    | t' => F_ByValue t'
    end
  | S n' =>
    match t as t0 return A t0 with
    | Tarray t0 n a => F_Tarray t0 n a (type_func_rec n' t0)
    | Tstruct id a =>  let m := co_members (get_co id) in
                            F_Tstruct id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func_rec n' (field_type (fst it) m)) m)
    | Tunion id a =>  let m := co_members (get_co id) in
                            F_Tunion id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func_rec n' (field_type (fst it) m)) m)
    | t' => F_ByValue t'
    end
  end.

Definition type_func t := type_func_rec (rank_type cenv_cs t) t.

Lemma rank_type_Tstruct: forall id a co, cenv_cs ! id = Some co ->
  rank_type cenv_cs (Tstruct id a) = S (co_rank (get_co id)).

Lemma rank_type_Tunion: forall id a co, cenv_cs ! id = Some co ->
  rank_type cenv_cs (Tunion id a) = S (co_rank (get_co id)).

Lemma type_func_rec_rank_irrelevent: forall t n n0,
  n >= rank_type cenv_cs t ->
  n0 >= rank_type cenv_cs t ->
  type_func_rec n t = type_func_rec n0 t.

Definition FTI_aux id :=
    let m := co_members (get_co id) in
    (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func (field_type (fst it) m)) m).

Lemma type_func_eq: forall t,
  type_func t =
  match t as t0 return A t0 with
  | Tarray t0 n a => F_Tarray t0 n a (type_func t0)
  | Tstruct id a => F_Tstruct id a (FTI_aux id)
  | Tunion id a => F_Tunion id a (FTI_aux id)
  | t' => F_ByValue t'
  end.

End COMPOSITE_ENV.

Arguments type_func {cs} A F_ByValue F_Tarray F_Tstruct F_Tunion t / .

Ltac type_induction t :=
  pattern t;
  match goal with
  | |- ?P t =>
    apply type_ind; clear t;
    let t := fresh "t" in
    intros t IH;
    let id := fresh "id" in
    let a := fresh "a" in
    destruct t as [| | | | | | | id a | id a]
  end. *)

Require Import VST.floyd.nested_pred_lemmas.
(* VST.floyd.nested_pred_lemmas:
Require Import VST.floyd.base2.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.type_induction.
Require Import VST.floyd.fieldlist.
Open Scope Z.

Lemma fold_right_map: forall {A B C} (f: B -> A -> A) (g: C -> B) (e: A) (l: list C),
  fold_right f e (map g l) = fold_right (fun c a => f (g c) a) e l.

Section NESTED_PRED.
Context {cs: compspecs}.

Definition nested_pred (atom_pred: type -> bool): type -> bool :=
  type_func
    (fun _ => bool)
    (fun t => atom_pred t)
    (fun t n a b => (atom_pred (Tarray t n a) && b)%bool)
    (fun id a bl => (atom_pred (Tstruct id a) && fold_right andb true (decay bl))%bool)
    (fun id a bl => (atom_pred (Tunion id a) && fold_right andb true (decay bl))%bool).

Definition nested_fields_pred (atom_pred: type -> bool) (m: members) : bool :=
  fold_right (fun it b => (nested_pred atom_pred (field_type (fst it) m) && b)%bool) true m.

Lemma nested_pred_eq: forall atom_pred t,
  nested_pred atom_pred t =
  match t with
  | Tarray t0 _ _ => (atom_pred t && nested_pred atom_pred t0)%bool
  | Tstruct id _
  | Tunion id _ => (atom_pred t && nested_fields_pred atom_pred (co_members (get_co id)))%bool
  | _ => atom_pred t
  end.

Lemma nested_pred_atom_pred: forall (atom_pred: type -> bool) (t: type),
  nested_pred atom_pred t = true -> atom_pred t = true.

Lemma nested_fields_pred_nested_pred: forall (atom_pred: type -> bool) i m, in_members i m -> nested_fields_pred atom_pred m = true -> nested_pred atom_pred (field_type i m) = true.

Lemma nested_pred_Tarray: forall (atom_pred: type -> bool) t n a,
  nested_pred atom_pred (Tarray t n a) = true -> nested_pred atom_pred t = true.

Lemma nested_pred_Tstruct: forall (atom_pred: type -> bool) id a,
  nested_pred atom_pred (Tstruct id a) = true -> nested_fields_pred atom_pred (co_members (get_co id)) = true.

Lemma nested_pred_Tstruct2: forall (atom_pred: type -> bool) id a i,
  nested_pred atom_pred (Tstruct id a) = true ->
  in_members i (co_members (get_co id)) ->
  nested_pred atom_pred (field_type i (co_members (get_co id))) = true.

Lemma nested_pred_Tunion: forall (atom_pred: type -> bool) id a,
  nested_pred atom_pred (Tunion id a) = true -> nested_fields_pred atom_pred (co_members (get_co id)) = true.

Lemma nested_pred_Tunion2: forall (atom_pred: type -> bool) id a i,
  nested_pred atom_pred (Tunion id a) = true ->
  in_members i (co_members (get_co id)) ->
  nested_pred atom_pred (field_type i (co_members (get_co id))) = true.

Lemma complete_legal_cosu_type_Tstruct: forall id a,
  complete_legal_cosu_type (Tstruct id a) = true ->
  co_su (get_co id) = Struct.

Lemma complete_legal_cosu_type_Tunion: forall id a,
  complete_legal_cosu_type (Tunion id a) = true ->
  co_su (get_co id) = Union.

Lemma Tarray_sizeof_0: forall t n a,
  sizeof (Tarray t n a) = 0 ->
  sizeof t = 0 \/ n <= 0.

Lemma Tstruct_sizeof_0: forall id a,
  complete_legal_cosu_type (Tstruct id a) = true ->
  sizeof (Tstruct id a) = 0 ->
  forall i, in_members i (co_members (get_co id)) ->
  sizeof (field_type i (co_members (get_co id))) = 0 /\
  field_offset_next cenv_cs i (co_members (get_co id)) (co_sizeof (get_co id)) -
   (field_offset cenv_cs i (co_members (get_co id)) +
      sizeof (field_type i (co_members (get_co id)))) = 0.

Lemma Tunion_sizeof_0: forall id a,
  complete_legal_cosu_type (Tunion id a) = true ->
  sizeof (Tunion id a) = 0 ->
  forall i, in_members i (co_members (get_co id)) ->
  sizeof (field_type i (co_members (get_co id))) = 0.

End NESTED_PRED.

Ltac pose_mod_le A :=
  let H := fresh "H" in
  pose proof Z.mod_le A Ptrofs.modulus;
  spec H; [try omega | spec H; [pose Ptrofs.modulus_pos; omega |]].

Ltac pose_mul_distr_l l r :=
  match r with
  | (?A + ?B)%Z => pose proof Z.mul_add_distr_l l A B;
                   pose_mul_distr_l l A;
                   pose_mul_distr_l l B
  | Z.succ ?A => let H := fresh "H" in
                 pose proof Z.mul_add_distr_l l A 1 as H;
                 replace (A + 1) with (Z.succ A) in H by omega;
                 pose_mul_distr_l l A
  | (?A - ?B)%Z => pose proof Z.mul_sub_distr_l l A B;
                   pose_mul_distr_l l A;
                   pose_mul_distr_l l B
  | _ => idtac
  end.

Ltac pose_size_mult' env t l :=
  match l with
  | nil => idtac
  | ?z :: ?l0 =>
    match l0 with
    | nil => pose_mul_distr_l (@sizeof env t) z
    | ?z0 :: _ => pose_mul_distr_l (@sizeof env t) z;
                  assert (@sizeof env t * z <= @sizeof env t * z0) by
                    (pose proof @sizeof_pos env t; apply Zmult_le_compat_l; omega);
                  pose_size_mult' env t l0
    end
  end.

Ltac pose_size_mult env t l :=
  pose_size_mult' env t l;
  try rewrite !Z.mul_0_r in *;
  try rewrite !Z.mul_1_r in *.

Definition align_alignof a b := align a b.

Definition sizeof_struct_le := sizeof_struct.

Ltac pose_align_le :=
  repeat
  match goal with
  | |- context [align ?A (@alignof ?env ?t)] =>
         assert (A <= align A (@alignof env t)) by (apply align_le, @alignof_pos);
         change (align A (@alignof env t)) with (align_alignof A (@alignof env t))
  | |- context [align ?A (co_alignof ?co)] =>
         let x := fresh "x" in
         assert (A <= align A (co_alignof co)) by (apply align_le; destruct (co_alignof_two_p co) as [x ?];
           pose proof two_power_nat_pos x; omega);
         change (align A (co_alignof co)) with (align_alignof A (co_alignof co))
  | |- context [sizeof_struct ?env ?A ?m] =>
         pose proof sizeof_struct_incr env m A;
         change (sizeof_struct env A m) with (sizeof_struct_le env A m)
  end;
  try unfold align_alignof in *;
  try unfold sizeof_struct_le in *.

Definition sizeofp := @sizeof.

Ltac pose_sizeof_pos :=
  repeat
  match goal with
  | |- context [@sizeof ?env ?t] =>
         pose proof @sizeof_pos env t;
         change (@sizeof env t) with (sizeofp env t)
  end;
  unfold sizeofp in *.

Ltac pose_sizeof_co t :=
  match t with
  | Tstruct ?id ?a =>
    pose proof sizeof_Tstruct id a;
    assert (sizeof_struct cenv_cs 0 (co_members (get_co id)) <= co_sizeof (get_co id)); [
      rewrite co_consistent_sizeof with (env := cenv_cs) by (apply get_co_consistent);
      rewrite complete_legal_cosu_type_Tstruct with (a0 := a) by auto;
      apply align_le, co_alignof_pos
       |]
  | Tunion ?id ?a =>
    pose proof sizeof_Tunion id a;
    assert (sizeof_union cenv_cs (co_members (get_co id)) <= co_sizeof (get_co id)); [
      rewrite co_consistent_sizeof with (env := cenv_cs) by (apply get_co_consistent);
      rewrite complete_legal_cosu_type_Tunion with (a0 := a) by auto;
      apply align_le, co_alignof_pos
       |]
  end.

Ltac pose_field :=
  match goal with
  | _ : complete_legal_cosu_type (Tstruct ?id ?a) = true |-
    context [@sizeof cenv_cs (field_type ?i (co_members (get_co ?id)))] =>
      pose_sizeof_co (Tstruct id a);
      let H := fresh "H" in
      pose proof field_offset_in_range i (co_members (get_co id)) as H;
      spec H; [solve [auto] |];
      pose proof @sizeof_pos cenv_cs (field_type i (co_members (get_co id)))
  | _ : complete_legal_cosu_type (Tunion ?id ?a) = true |-
    context [@sizeof cenv_cs (field_type ?i (co_members (get_co ?id)))] =>
      pose_sizeof_co (Tunion id a);
      let H := fresh "H" in
      pose proof sizeof_union_in_members i (co_members (get_co id)) as H;
      spec H; [solve [auto] |];
      pose proof @sizeof_pos cenv_cs (field_type i (co_members (get_co id)))
  | _ => idtac
  end;
  match goal with
  | _ : complete_legal_cosu_type (Tstruct ?id ?a) = true |-
    context [field_offset_next cenv_cs ?i (co_members (get_co ?id)) (co_sizeof (get_co ?id))] =>
      let H := fresh "H" in
      pose proof field_offset_next_in_range i (co_members (get_co id)) (co_sizeof (get_co id));
      spec H; [solve [auto] |];
      spec H; [solve [auto | pose_sizeof_co (Tstruct id a); auto] |]
  | _ => idtac
  end
. *)

Require Import VST.floyd.nested_field_lemmas.
(* VST.floyd.nested_field_lemmas:
Require Import VST.floyd.base2.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.fieldlist.
Require Import VST.floyd.type_induction.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.align_compatible_dec.
Open Scope Z.

Inductive gfield : Type :=
  | ArraySubsc : forall i: Z, gfield
  | StructField : forall i: ident, gfield
  | UnionField : forall i: ident, gfield.

Delimit Scope gfield_scope with gfield.
Bind Scope gfield_scope with list gfield.
Notation "x 'DOT' y " := (@cons gfield (StructField y) x%gfield) (at level 40, left associativity): gfield_scope.
Notation "x 'UDOT' y " := (@cons gfield (UnionField y) x%gfield) (at level 40, left associativity): gfield_scope.
Notation "x 'SUB' y " := (@cons gfield (ArraySubsc y) x%gfield) (at level 40, left associativity): gfield_scope.
Notation "'DOT' y " := (@cons gfield (StructField y) nil) (at level 40): gfield_scope.
Notation "'UDOT' y " := (@cons gfield (UnionField y) nil) (at level 40): gfield_scope.
Notation "'SUB' y " := (@cons gfield (ArraySubsc y) nil) (at level 40): gfield_scope.

Section COMPOSITE_ENV.

Context {cs: compspecs}.
Definition gfield_type t gf :=
  match t, gf with
  | Tarray t0 _ _, ArraySubsc _ => t0
  | Tstruct id _, StructField i
  | Tunion id _, UnionField i => field_type i (co_members (get_co id))
  | _, _ => Tvoid
  end.

Definition gfield_offset t gf :=
  match t, gf with
  | Tarray t0 _ _, ArraySubsc i => sizeof t0 * i
  | Tstruct id _, StructField i => field_offset cenv_cs i (co_members (get_co id))
  | Tunion id _, UnionField i => 0
  | _, _ => 0
  end.

Definition no_alignas_attr (a: attr): attr := mk_attr (attr_volatile a) None.

Lemma no_alignas_attr_spec: forall a d,
  align_attr (no_alignas_attr a) d = d.

Definition gfield_array_type t lo hi :=
  match t with
  | Tarray t0 _ a => Tarray t0 (hi - lo) (no_alignas_attr a)
  | _ => Tarray Tvoid (hi - lo) (no_alignas_attr (attr_of_type t))
  end.

Fixpoint nested_field_rec (t: type) (gfs: list gfield) : option (prod Z type) :=
  match gfs with
  | nil => Some (0, t)
  | hd :: tl =>
    match nested_field_rec t tl with
    | Some (pos, t') =>
      match t', hd with
      | Tarray t'' n _, ArraySubsc i => Some(pos + sizeof t'' * i, t'')
      | Tstruct id _, StructField i =>
        let m := co_members (get_co id) in
        if compute_in_members i m then
          Some (pos + field_offset cenv_cs i m, field_type i m)
        else
          None
      | Tunion id _, UnionField i =>
        let m := co_members (get_co id) in
        if compute_in_members i m then
          Some (pos, field_type i m)
        else
          None
      | _, _ => None
      end
    | None => None
    end
  end%Z.

Definition nested_field_offset (t: type) (gfs: list gfield) : Z :=
  match nested_field_rec t gfs with
  | Some (pos, _) => pos
  | _ => 0
  end.

Definition nested_field_type (t: type) (gfs: list gfield) : type :=
  match nested_field_rec t gfs with
  | Some (_, t0) => t0
  | _ => Tvoid
  end.

Definition nested_field_array_type t gfs lo hi :=
  Tarray (nested_field_type t (ArraySubsc 0 :: gfs)) (hi - lo) (no_alignas_attr (attr_of_type (nested_field_type t gfs))).

Definition legal_field t gf :=
  match t, gf with
  | Tarray _ n _, ArraySubsc i => 0 <= i < n
  | Tstruct id _, StructField i => in_members i (co_members (get_co id))
  | Tunion id _, UnionField i => in_members i (co_members (get_co id))
  | _, _ => False
  end.

Definition legal_field0 t gf :=
  match t, gf with
  | Tarray _ n _, ArraySubsc i => 0 <= i <= n
  | Tstruct id _, StructField i => in_members i (co_members (get_co id))
  | Tunion id _, UnionField i => in_members i (co_members (get_co id))
  | _, _ => False
  end.

Fixpoint legal_nested_field (t: type) (gfs: list gfield) : Prop :=
  match gfs with
  | nil => True
  | gf :: gfs0 => legal_nested_field t gfs0 /\ legal_field (nested_field_type t gfs0) gf
  end.

Definition legal_nested_field0 t gfs :=
  match gfs with
  | nil => True
  | gf :: gfs0 => legal_nested_field t gfs0 /\ legal_field0 (nested_field_type t gfs0) gf
  end.

Fixpoint compute_legal_nested_field (t: type) (gfs: list gfield) : list Prop :=
  match gfs with
  | nil => nil
  | gf :: gfs0 =>
    match (nested_field_type t gfs0), gf with
    | Tarray _ n _, ArraySubsc i =>
       (0 <= i < n) :: compute_legal_nested_field t gfs0
    | Tstruct id _, StructField i =>
       if compute_in_members i (co_members (get_co id)) then compute_legal_nested_field t gfs0 else False :: nil
    | Tunion id _, UnionField i =>
       if compute_in_members i (co_members (get_co id)) then compute_legal_nested_field t gfs0 else False :: nil
    | _, _ => False :: nil
    end
  end.

Lemma nested_field_type_ind: forall t gfs,
  nested_field_type t gfs =
  match gfs with
  | nil => t
  | gf :: gfs0 => gfield_type (nested_field_type t gfs0) gf
  end.

Lemma nested_field_offset_ind: forall t gfs,
  legal_nested_field0 t gfs ->
  nested_field_offset t gfs =
  match gfs with
  | nil => 0
  | gf :: gfs0 => nested_field_offset t gfs0 + gfield_offset (nested_field_type t gfs0) gf
  end.

Lemma nested_field_offset_ind': forall t gfs,
  legal_nested_field t gfs ->
  nested_field_offset t gfs =
  match gfs with
  | nil => 0
  | gf :: gfs0 => nested_field_offset t gfs0 + gfield_offset (nested_field_type t gfs0) gf
  end.

Lemma offset_val_nested_field_offset_ind: forall t gfs p,
  legal_nested_field0 t gfs ->
  offset_val (nested_field_offset t gfs) p =
  match gfs with
  | nil => force_ptr p
  | gf :: gfs0 => offset_val (gfield_offset (nested_field_type t gfs0) gf)
                    (offset_val (nested_field_offset t gfs0) p)
  end.

Lemma nested_field_array_type_ind: forall t gfs lo hi,
  nested_field_array_type t gfs lo hi =
  gfield_array_type (nested_field_type t gfs) lo hi.

Lemma nested_field0_offset_ind: forall t gfs,
  legal_nested_field0 t gfs ->
  nested_field_offset t gfs =
  match gfs with
  | nil => 0
  | gf :: gfs0 => nested_field_offset t gfs0 + gfield_offset (nested_field_type t gfs0) gf
  end.

Ltac valid_nested_field_rec f a T :=
  let H := fresh "H" in
  let t := fresh "t" in
  let ofs := fresh "ofs" in
  simpl in T; destruct (nested_field_rec f a) as [[ofs t]|] eqn:H; [|inversion T].

Ltac auto_destruct_above_line :=
repeat (
  let H1 := fresh "H" in
  let H2 := fresh "H" in
  let x := fresh "x" in
  match goal with
  | H: _ /\ _ |- _ => destruct H as [H1 H2]
  | H: prod _ _ |- _ => destruct H as [H1 H2]
  | H: @ex _ _ |- _ => destruct H as [x H1]
  | H: sigT _ |- _ => destruct H as [x H1]
  end).

Definition legal_nested_field_dec: forall t gfs,
  {legal_nested_field t gfs} + {~ legal_nested_field t gfs}.

Definition legal_nested_field0_dec: forall t gfs,
  {legal_nested_field0 t gfs} + {~ legal_nested_field0 t gfs}.

Definition field_compatible t gfs p :=
  isptr p /\
  complete_legal_cosu_type t = true /\
  size_compatible t p /\
  align_compatible t p /\
  legal_nested_field t gfs.

Definition field_compatible0 t gfs p :=
  isptr p /\
  complete_legal_cosu_type t = true /\
  size_compatible t p /\
  align_compatible t p /\
  legal_nested_field0 t gfs.

Lemma field_compatible_dec: forall t gfs p,
  {field_compatible t gfs p} + {~ field_compatible t gfs p}.

Lemma field_compatible0_dec: forall t gfs p,
  {field_compatible0 t gfs p} + {~ field_compatible0 t gfs p}.

Lemma field_compatible_cons: forall t gf gfs p,
  field_compatible t (gf :: gfs) p <->
  match nested_field_type t gfs, gf with
  | Tstruct id _, StructField i => in_members i (co_members (get_co id)) /\ field_compatible t gfs p
  | Tunion id _, UnionField i => in_members i (co_members (get_co id)) /\ field_compatible t gfs p
  | Tarray _ n _, ArraySubsc i => 0 <= i < n /\ field_compatible t gfs p
  | _, _ => False
  end.

Lemma field_compatible0_cons: forall t gf gfs p,
  field_compatible0 t (gf :: gfs) p <->
  match nested_field_type t gfs, gf with
  | Tstruct id _, StructField i => in_members i (co_members (get_co id)) /\ field_compatible t gfs p
  | Tunion id _, UnionField i => in_members i (co_members (get_co id)) /\ field_compatible t gfs p
  | Tarray _ n _, ArraySubsc i => 0 <= i <= n /\ field_compatible t gfs p
  | _, _ => False
  end.

Lemma field_compatible_cons_Tarray:
  forall i t t0 n a gfs p,
  nested_field_type t gfs = Tarray t0 n a ->
  field_compatible t gfs p ->
  (0 <= i < n)%Z ->
  field_compatible t (ArraySubsc i :: gfs) p.

Lemma field_compatible0_cons_Tarray:
  forall k t n a gfs p t',
  nested_field_type t gfs = Tarray t' n a ->
  field_compatible t gfs p ->
  (0 <= k <= n)%Z ->
  field_compatible0 t (ArraySubsc k :: gfs) p.

Definition field_address t gfs p :=
  if (field_compatible_dec t gfs p)
  then offset_val (nested_field_offset t gfs) p
  else Vundef.

Definition field_address0 t gfs p :=
  if (field_compatible0_dec t gfs p)
  then offset_val (nested_field_offset t gfs) p
  else Vundef.

Lemma field_address_isptr:
  forall t path c, field_compatible t path c -> isptr (field_address t path c).

Lemma field_address0_isptr:
  forall t path c, field_compatible0 t path c -> isptr (field_address0 t path c).

Lemma field_address_clarify:
 forall t path c,
   is_pointer_or_null (field_address t path c) ->
   field_address t path c = offset_val (nested_field_offset t path) c.

Lemma field_address0_clarify:
 forall t path c,
   is_pointer_or_null (field_address0 t path c) ->
   field_address0 t path c = offset_val (nested_field_offset t path) c.

Lemma field_compatible_field_compatible0:
  forall (t : type) (gfs : list gfield) (p : val),
  field_compatible t gfs p -> field_compatible0 t gfs p.

Lemma field_compatible_field_compatible0':
  forall (t : type) (i : Z) (gfs : list gfield) (p : val),
  field_compatible t (ArraySubsc i :: gfs) p <->
  field_compatible0 t (ArraySubsc i :: gfs) p /\
  field_compatible0 t (ArraySubsc (i + 1) :: gfs) p.

Lemma field_compatible0_range:
 forall i lo hi t gfs p,
   lo <= i <= hi ->
   field_compatible0 t (ArraySubsc lo :: gfs) p ->
   field_compatible0 t (ArraySubsc hi :: gfs) p ->
   field_compatible0 t (ArraySubsc i :: gfs) p.

Lemma field_compatible_range:
 forall i lo hi t gfs p,
   lo <= i < hi ->
   field_compatible0 t (ArraySubsc lo :: gfs) p ->
   field_compatible0 t (ArraySubsc hi :: gfs) p ->
   field_compatible t (ArraySubsc i :: gfs) p.

Lemma is_pointer_or_null_field_compatible:
  forall t path c,
     is_pointer_or_null (field_address t path c) ->
      field_compatible t path c.

Lemma nested_field_type_ArraySubsc: forall t i gfs,
  nested_field_type t (ArraySubsc i :: gfs) = nested_field_type t (ArraySubsc 0 :: gfs).

Lemma gfield_type_nested_pred: forall {atom_pred: type -> bool}, atom_pred Tvoid = true -> forall (t: type) (gf: gfield),
  nested_pred atom_pred t = true -> nested_pred atom_pred (gfield_type t gf) = true.

Lemma gfield_array_type_nested_pred: forall {atom_pred: type -> bool},
  (forall t n m a,
    0 <= m ->
    atom_pred (Tarray t n a) = true ->
    atom_pred (Tarray t m (no_alignas_attr a)) = true) ->
  forall (t: type) lo hi,
  lo <= hi ->
  legal_field0 t (ArraySubsc lo) ->
  nested_pred atom_pred t = true -> nested_pred atom_pred (gfield_array_type t lo hi) = true.

Lemma gfield_type_complete_legal_cosu_type: forall (t: type) (gf: gfield),
  legal_field t gf ->
  complete_legal_cosu_type t = true -> complete_legal_cosu_type (gfield_type t gf) = true.

Lemma gfield_array_type_complete_legal_cosu_type: forall (t: type) lo hi,
  legal_field0 t (ArraySubsc lo) ->
  complete_legal_cosu_type t = true ->
  complete_legal_cosu_type (gfield_array_type t lo hi) = true.

Lemma nested_field_type_complete_legal_cosu_type: forall (t: type) (gfs: list gfield), complete_legal_cosu_type t = true -> legal_nested_field t gfs -> complete_legal_cosu_type (nested_field_type t gfs) = true.

Lemma nested_field_array_type_complete_legal_cosu_type: forall (t: type) (gfs: list gfield) lo hi, complete_legal_cosu_type t = true -> legal_nested_field0 t (ArraySubsc lo :: gfs) -> complete_legal_cosu_type (nested_field_array_type t gfs lo hi) = true.

Lemma nested_field_type_nest_pred: forall {atom_pred: type -> bool}, atom_pred Tvoid = true -> forall (t: type) (gfs: list gfield),
  nested_pred atom_pred t = true -> nested_pred atom_pred (nested_field_type t gfs) = true.

Lemma nested_field_array_type_nest_pred: forall {atom_pred: type -> bool},
  atom_pred Tvoid = true ->
  (forall t n m a,
     0 <= m ->
     atom_pred (Tarray t n a) = true ->
     atom_pred (Tarray t m (no_alignas_attr a)) = true) ->
  forall (t: type) gfs lo hi,
  lo <= hi ->
  legal_nested_field0 t (ArraySubsc lo :: gfs) ->
  nested_pred atom_pred t = true ->
  nested_pred atom_pred (nested_field_array_type t gfs lo hi) = true.

Lemma legal_nested_field0_field:
  forall t gfs, legal_nested_field t gfs -> legal_nested_field0 t gfs.

Hint Resolve legal_nested_field0_field.

Lemma gfield_offset_in_range: forall t gf,
  legal_field t gf ->
  complete_legal_cosu_type t = true ->
  0 <= gfield_offset t gf /\ gfield_offset t gf + sizeof (gfield_type t gf) <= sizeof t.

Lemma gfield_array_offset_in_range: forall t lo hi,
  legal_field0 t (ArraySubsc lo) ->
  legal_field0 t (ArraySubsc hi) ->
  complete_legal_cosu_type t = true ->
  0 <= gfield_offset t (ArraySubsc lo) /\
  gfield_offset t (ArraySubsc lo) + sizeof (gfield_array_type t lo hi) <= sizeof t.

Lemma gfield0_offset_in_range: forall t gf,
  legal_field0 t gf ->
  complete_legal_cosu_type t = true ->
  0 <= gfield_offset t gf /\ gfield_offset t gf <= sizeof t.

Lemma nested_field_offset_in_range: forall t gfs,
  legal_nested_field t gfs ->
  complete_legal_cosu_type t = true ->
  0 <= nested_field_offset t gfs /\
  (nested_field_offset t gfs) + sizeof (nested_field_type t gfs) <= sizeof t.

Lemma nested_field_array_offset_in_range: forall t gfs lo hi,
  legal_nested_field0 t (ArraySubsc lo :: gfs) ->
  legal_nested_field0 t (ArraySubsc hi :: gfs) ->
  complete_legal_cosu_type t = true ->
  0 <= nested_field_offset t (ArraySubsc lo :: gfs) /\
  nested_field_offset t (ArraySubsc lo :: gfs) + sizeof (nested_field_array_type t gfs lo hi) <= sizeof t.

Lemma nested_field0_offset_in_range: forall (t : type) (gfs : list gfield),
  legal_nested_field0 t gfs ->
  complete_legal_cosu_type t = true ->
  0 <= nested_field_offset t gfs <= sizeof t.

Lemma nested_field_type_nested_field_type: forall t gfs0 gfs1,
  nested_field_type (nested_field_type t gfs0) gfs1 = nested_field_type t (gfs1 ++ gfs0).

Lemma legal_nested_field_shrink: forall t gfs0 gfs1,
  legal_nested_field t (gfs1 ++ gfs0) -> legal_nested_field t gfs0.

Lemma legal_nested_field0_shrink: forall t gfs0 gfs1,
  legal_nested_field0 t (gfs1 ++ gfs0) -> legal_nested_field0 t gfs0.

Lemma legal_nested_field0_shrink1: forall t gfs0 gfs1,
  gfs1 <> nil ->
  legal_nested_field0 t (gfs1 ++ gfs0) -> legal_nested_field t gfs0.

Lemma legal_nested_field_app: forall t gfs0 gfs1,
  legal_nested_field t (gfs1 ++ gfs0) -> legal_nested_field (nested_field_type t gfs0) gfs1.

Lemma legal_nested_field0_app: forall t gfs0 gfs1,
  legal_nested_field0 t (gfs1 ++ gfs0) -> legal_nested_field0 (nested_field_type t gfs0) gfs1.

Lemma legal_nested_field_app_inv: forall t gfs0 gfs1,
  legal_nested_field t gfs0 ->
  legal_nested_field (nested_field_type t gfs0) gfs1 ->
  legal_nested_field t (gfs1 ++ gfs0).

Lemma legal_nested_field0_app_inv: forall t gfs0 gfs1,
  legal_nested_field t gfs0 ->
  legal_nested_field0 (nested_field_type t gfs0) gfs1 ->
  legal_nested_field0 t (gfs1 ++ gfs0).

Lemma nested_field_offset_app: forall t gfs0 gfs1,
  legal_nested_field t (gfs1 ++ gfs0) ->
  nested_field_offset t (gfs1 ++ gfs0) = nested_field_offset t gfs0 +
    nested_field_offset (nested_field_type t gfs0) gfs1.

Lemma nested_field_offset0_app: forall t gfs0 gfs1,
  legal_nested_field0 t (gfs1 ++ gfs0) ->
  nested_field_offset t (gfs1 ++ gfs0) = nested_field_offset t gfs0 +
    nested_field_offset (nested_field_type t gfs0) gfs1.

Lemma size_0_compatible: forall t, sizeof t = 0 -> forall p, size_compatible t p.

Lemma size_compatible_nested_field: forall t gfs p,
  legal_nested_field t gfs ->
  complete_legal_cosu_type t = true ->
  size_compatible t p ->
  size_compatible (nested_field_type t gfs) (offset_val (nested_field_offset t gfs) p).

Lemma size_compatible_nested_field_array: forall t gfs lo hi p,
  legal_nested_field0 t (ArraySubsc lo :: gfs) ->
  legal_nested_field0 t (ArraySubsc hi :: gfs) ->
  complete_legal_cosu_type t = true ->
  size_compatible t p ->
  size_compatible (nested_field_array_type t gfs lo hi)
   (offset_val (nested_field_offset t (ArraySubsc lo :: gfs)) p).

Lemma align_compatible_nested_field: forall t gfs p,
  legal_nested_field t gfs ->
  size_compatible t p ->
  align_compatible t p ->
  complete_legal_cosu_type t = true ->
  align_compatible (nested_field_type t gfs) (offset_val (nested_field_offset t gfs) p).

Lemma align_compatible_nested_field_array: forall t gfs lo hi p,
  legal_nested_field0 t (ArraySubsc lo :: gfs) ->
  legal_nested_field0 t (ArraySubsc hi :: gfs) ->
  size_compatible t p ->
  align_compatible t p ->
  complete_legal_cosu_type t = true ->
  align_compatible (nested_field_array_type t gfs lo hi)
   (offset_val (nested_field_offset t (ArraySubsc lo :: gfs)) p).

Lemma field_compatible_nested_field: forall t gfs p,
  field_compatible t gfs p ->
  field_compatible (nested_field_type t gfs) nil (offset_val (nested_field_offset t gfs) p).

Lemma field_compatible0_nested_field_array: forall t gfs lo hi p,
  field_compatible0 t (ArraySubsc lo :: gfs) p ->
  field_compatible0 t (ArraySubsc hi :: gfs) p ->
  lo <= hi ->
  field_compatible (nested_field_array_type t gfs lo hi) nil (offset_val (nested_field_offset t (ArraySubsc lo :: gfs)) p).

Lemma field_compatible_isptr :
  forall t path p, field_compatible t path p -> isptr p.

Lemma field_compatible0_isptr :
  forall t path p, field_compatible0 t path p -> isptr p.

Lemma field_compatible_legal_nested_field:
  forall (t : type) (path : list gfield) (p : val),
  field_compatible t path p -> legal_nested_field t path.

Lemma field_compatible_legal_nested_field0:
  forall (t : type) (path : list gfield) (p : val),
  field_compatible t path p -> legal_nested_field0 t path.

Lemma field_compatible0_legal_nested_field0:
  forall (t : type) (path : list gfield) (p : val),
  field_compatible0 t path p -> legal_nested_field0 t path.

Lemma field_compatible_field_address: forall t gfs p, field_compatible t gfs p -> field_address t gfs p = offset_val (nested_field_offset t gfs) p.

Lemma field_compatible0_field_address0: forall t gfs p, field_compatible0 t gfs p -> field_address0 t gfs p = offset_val (nested_field_offset t gfs) p.

Lemma field_compatible_shrink: forall t_root gfsB gfsA a,
  field_compatible t_root (gfsB ++ gfsA) a ->
  field_compatible t_root gfsA a.

Lemma field_compatible0_shrink: forall t_root gfsB gfsA a,
  field_compatible0 t_root (gfsB ++ gfsA) a ->
  field_compatible0 t_root gfsA a.

Lemma field_compatible0_shrink1: forall t_root gfsB gfsA a,
  gfsB <> nil ->
  field_compatible0 t_root (gfsB ++ gfsA) a ->
  field_compatible t_root gfsA a.

Lemma field_compatible_app: forall gfsB t_root gfsA a,
  field_compatible t_root (gfsB ++ gfsA) a ->
  field_compatible (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a).

Lemma field_compatible0_app1: forall gfsB t_root gfsA a
  (NEQ: gfsB <> nil),
  field_compatible0 t_root (gfsB ++ gfsA) a ->
  field_compatible0 (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a).

Lemma field_compatible_app_inv': forall gfsB t_root gfsA a,
  field_compatible t_root gfsA a ->
  legal_nested_field (nested_field_type t_root gfsA) gfsB ->
  field_compatible t_root (gfsB ++ gfsA) a.

Lemma field_compatible0_app_inv': forall gfsB t_root gfsA a,
  field_compatible t_root gfsA a ->
  legal_nested_field0 (nested_field_type t_root gfsA) gfsB ->
  field_compatible0 t_root (gfsB ++ gfsA) a.

Lemma field_compatible_app_inv: forall gfsB t_root gfsA a,
  field_compatible t_root gfsA a ->
  field_compatible (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a) ->
  field_compatible t_root (gfsB ++ gfsA) a.

Lemma field_compatible0_app_inv: forall gfsB t_root gfsA a,
  field_compatible t_root gfsA a ->
  field_compatible0 (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a) ->
  field_compatible0 t_root (gfsB ++ gfsA) a.

Lemma field_address_app: forall t_root gfsA gfsB a,
  field_address t_root (gfsB ++ gfsA) a =
  field_address (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a).

Lemma field_address0_app: forall t_root gfsA gfsB a
  (NEQ: gfsB <> nil),
  field_address0 t_root (gfsB ++ gfsA) a =
  field_address0 (nested_field_type t_root gfsA) gfsB (field_address t_root gfsA a).

End COMPOSITE_ENV.

Hint Resolve is_pointer_or_null_field_compatible.

Hint Extern 1 (isptr _) => (eapply field_compatible_isptr; eassumption).
Hint Extern 1 (isptr _) => (eapply field_compatible0_isptr; eassumption).
Hint Extern 1 (legal_nested_field _ _) => (eapply field_compatible_legal_nested_field; eassumption).
Hint Extern 1 (legal_nested_field0 _ _) => (eapply field_compatible_legal_nested_field0; eassumption).
Hint Extern 1 (legal_nested_field0 _ _) => (eapply field_compatible0_legal_nested_field0; eassumption).

Lemma nested_field_type_preserves_change_composite: forall {cs_from cs_to} {CCE: change_composite_env cs_from cs_to} (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  forall gfs, cs_preserve_type cs_from cs_to (coeq cs_from cs_to) (@nested_field_type cs_to t gfs) = true.

Lemma nested_field_type_change_composite: forall {cs_from cs_to} {CCE: change_composite_env cs_from cs_to} (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  forall gfs, @nested_field_type cs_from t gfs = @nested_field_type cs_to t gfs.

Lemma legal_nested_field_change_composite: forall {cs_from cs_to} {CCE: change_composite_env cs_from cs_to} (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  forall gfs, @legal_nested_field cs_from t gfs <-> @legal_nested_field cs_to t gfs.

Lemma field_compatible_change_composite: forall {cs_from cs_to} {CCE: change_composite_env cs_from cs_to} (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  forall gfs p, @field_compatible cs_from t gfs p <-> @field_compatible cs_to t gfs p.

Lemma nested_field_offset_change_composite: forall {cs_from cs_to} {CCE: change_composite_env cs_from cs_to} (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  forall gfs,
    @legal_nested_field cs_from t gfs ->
    @legal_nested_field cs_to t gfs ->
    @nested_field_offset cs_from t gfs = @nested_field_offset cs_to t gfs.

Lemma lvar_size_compatible:
  forall  {cs: compspecs} id t v rho,
  locald_denote (lvar id t v) rho ->
  sizeof t < Ptrofs.modulus ->

Lemma lvar_field_compatible:
  forall {cs: compspecs} id t v rho,
    locald_denote (lvar id t v) rho ->
    complete_legal_cosu_type t = true ->
    is_aligned cenv_cs ha_env_cs la_env_cs t 0 = true ->
    sizeof t < Ptrofs.modulus ->

Lemma compute_in_members_e:
 forall i al, compute_in_members i al = true -> in_members i al.

Hint Extern 2 (field_compatible _ (StructField _ :: _) _) =>
  (apply field_compatible_cons; split; [ apply compute_in_members_e; reflexivity | ])
      : field_compatible.

Lemma field_compatible_nullval: forall CS t f P,
  @field_compatible CS t f nullval -> P.

Lemma field_compatible_nullval1:
 forall (CS: compspecs) t fld p,
  @field_compatible CS t fld p -> p <> nullval.

Lemma field_compatible_nullval2:
 forall (CS: compspecs) t fld p,
  @field_compatible CS t fld p -> nullval <> p. *)

Require Import VST.floyd.mapsto_memory_block.
(* VST.floyd.mapsto_memory_block:
Require Import VST.floyd.base2.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.nested_pred_lemmas.

Local Open Scope logic.

Lemma local_facts_isptr: forall P Q (p: val), P p |-- !! Q -> (Q -> isptr p) -> P p = !! (isptr p) && P p.

Lemma local_facts_offset_zero: forall P, (forall p, P p |-- !! isptr p) -> (forall p, P p = P (offset_val 0 p)).

Lemma mapsto_local_facts:
  forall sh t v1 v2,  mapsto sh t v1 v2 |-- !! (isptr v1 /\ tc_val' t v2).

Lemma mapsto__local_facts:
  forall sh t v1, mapsto_ sh t v1 |-- !! isptr v1.
Hint Resolve mapsto_local_facts mapsto__local_facts : saturate_local.

Lemma mapsto_offset_zero:
  forall sh t v1 v2, mapsto sh t v1 v2 = mapsto sh t (offset_val 0 v1) v2.

Lemma mapsto__offset_zero:
  forall sh t v1, mapsto_ sh t v1 = mapsto_ sh t (offset_val 0 v1).

Lemma mapsto_isptr: forall sh t v1 v2, mapsto sh t v1 v2 = !! (isptr v1) && mapsto sh t v1 v2.

Lemma mapsto__isptr: forall sh t v1, mapsto_ sh t v1 = !! (isptr v1) && mapsto_ sh t v1.

Hint Rewrite memory_block_zero_Vptr: norm.

Definition size_compatible' (n: Z) (p: val) :=
match p with
| Vundef => True
| Vint _ => True
| Vlong _ => True
| Vfloat _ => True
| Vsingle _ => True
| Vptr _ i_ofs => Ptrofs.unsigned i_ofs + n < Ptrofs.modulus
end.

Lemma memory_block_local_facts: forall sh n p, 
  memory_block sh n p |-- !! (isptr p /\ size_compatible' n p).

Hint Resolve memory_block_local_facts : saturate_local.

Lemma memory_block_offset_zero:
  forall sh n v, memory_block sh n v = memory_block sh n (offset_val 0 v).

Lemma memory_block_isptr: forall sh n p, memory_block sh n p = !!(isptr p) && memory_block sh n p.

Lemma memory_block_zero: forall sh p, memory_block sh 0 p = !! isptr p && emp.

Lemma access_mode_by_value: forall t, type_is_by_value t = true -> exists ch, access_mode t = By_value ch.

Lemma mapsto_by_value: forall sh t p v, mapsto sh t p v = !! (type_is_by_value t = true) && mapsto sh t p v.

Section COMPSPECS.

Context {cs: compspecs}.

Lemma memory_block_mapsto_:
  forall sh t p,
   type_is_by_value t = true ->
   type_is_volatile t = false ->
   size_compatible t p ->
   align_compatible t p ->
   memory_block sh (sizeof t) p = mapsto_ sh t p.

Lemma nonreadable_memory_block_mapsto: forall sh p t v,
  ~ readable_share sh ->
  type_is_by_value t = true ->
  type_is_volatile t = false ->
  size_compatible t p ->
  align_compatible t p ->
  tc_val' t v ->
  memory_block sh (sizeof t) p = mapsto sh t p v.

Lemma memory_block_size_compatible:
  forall sh t p,
  memory_block sh (sizeof t) p = 
  !! (size_compatible t p) && memory_block sh (sizeof t) p.

Global Opaque memory_block.

End COMPSPECS.

Hint Extern 1 (mapsto _ _ _ _ |-- mapsto _ _ _ _) =>
   (simple apply mapsto_mapsto_int32; apply Coq.Init.Logic.I)  : cancel.

Hint Extern 1 (mapsto _ _ _ _ |-- mapsto_ _ _ _) =>
   (simple apply mapsto_mapsto__int32; apply Coq.Init.Logic.I)  : cancel.

Hint Extern 1 (mapsto _ _ _ _ |-- mapsto_ _ _ _) =>
    (apply mapsto_mapsto_) : cancel.

Hint Extern 1 (mapsto _ _ _ _ |-- mapsto_ _ _ _) =>
   (apply mapsto_mapsto__int32)  : cancel.

Hint Extern 1 (mapsto _ _ _ _ |-- mapsto _ _ _ _) =>
   (apply mapsto_mapsto_int32)  : cancel.

Hint Extern 0 (legal_alignas_type _ = true) => reflexivity : cancel.

Lemma mapsto_force_ptr: forall sh t v v',
  mapsto sh t (force_ptr v) v' = mapsto sh t v v'.

Hint Rewrite mapsto_force_ptr: norm.

Definition at_offset (P: val -> mpred) (z: Z): val -> mpred :=
 fun v => P (offset_val z v).

Arguments at_offset P z v : simpl never.

Lemma at_offset_eq: forall P z v,
  at_offset P z v = P (offset_val z v).

Lemma lifted_at_offset_eq: forall (P: val -> mpred) z v,
  `(at_offset P z) v = `P (`(offset_val z) v).

Lemma at_offset_eq2: forall pos pos' P,
  forall p, at_offset P (pos + pos') p = at_offset P pos' (offset_val pos p).

Lemma at_offset_eq3: forall P z b ofs,
  at_offset P z (Vptr b (Ptrofs.repr ofs)) = P (Vptr b (Ptrofs.repr (ofs + z))).

Lemma at_offset_derives: forall P Q p , (forall p, P p |-- Q p) -> forall pos, at_offset P pos p |-- at_offset Q pos p.

Definition spacer (sh: share) (be: Z) (ed: Z) : val -> mpred :=
  if Z.eq_dec (ed - be) 0
  then fun _ => emp
  else
    at_offset (memory_block sh (ed - be)) be.

Definition withspacer sh (be: Z) (ed: Z) P (p: val): mpred :=
   if Z.eq_dec (ed - be) 0
   then P p
   else P p * spacer sh be ed p.

Lemma withspacer_spacer: forall sh be ed P p,
   withspacer sh be ed P p = spacer sh be ed p * P p.

Lemma withspacer_ramif_Q: forall sh be ed P p,
  withspacer sh be ed P p |-- P p *
    allp ((fun Q => Q p) -* (fun Q => withspacer sh be ed Q p)).

Lemma spacer_offset_zero:
  forall sh be ed v, spacer sh be ed v = spacer sh be ed (offset_val 0 v).

Lemma withspacer_add:
  forall sh pos be ed P p,
  withspacer sh (pos + be) (pos + ed) (fun p0 => P (offset_val pos p)) p =
  withspacer sh be ed P (offset_val pos p).

Lemma offset_val_preserve_isptr: forall p pos, !! (isptr (offset_val pos p)) |-- !! (isptr p).

Lemma at_offset_preserve_local_facts: forall P pos, (forall p, P p |-- !!(isptr p)) -> (forall p, at_offset P pos p |-- !!(isptr p)).

Lemma withspacer_preserve_local_facts: forall sh be ed P, (forall p, P p |-- !! (isptr p)) -> (forall p, withspacer sh be ed P p |-- !! (isptr p)).

Transparent memory_block.

Lemma spacer_memory_block:
  forall sh be ed v, isptr v ->
 spacer sh be ed v = memory_block sh (ed - be) (offset_val be v).

Lemma spacer_sepcon_memory_block: forall sh ofs lo hi b i,
  0 <= lo ->
  0 <= ofs ->
  lo <= hi < Ptrofs.modulus ->

Hint Rewrite at_offset_eq3 : at_offset_db.
Hint Rewrite withspacer_spacer : at_offset_db.
Hint Rewrite spacer_memory_block using (simpl; auto): at_offset_db.

Opaque memory_block. *)

Require Import VST.floyd.reptype_lemmas.
(* VST.floyd.reptype_lemmas:
Require Import VST.floyd.base2.
Require Import VST.floyd.type_induction.
Require Export VST.floyd.compact_prod_sum.
Require Import VST.floyd.fieldlist.
Require Import VST.floyd.sublist.

Definition
map_map: forall {A B C : Type} (f : A -> B) (g : B -> C) (l : list A),
       map g (map f l) = map (fun x : A => g (f x)) l :=
fun (A B C : Type) (f : A -> B) (g : B -> C) (l : list A) =>
list_ind
  (fun l0 : list A => map g (map f l0) = map (fun x : A => g (f x)) l0)
  eq_refl
  (fun (a : A) (l0 : list A)
     (IHl : map g (map f l0) = map (fun x : A => g (f x)) l0) =>
   eq_ind_r
     (fun l1 : list C =>
      g (f a) :: l1 = g (f a) :: map (fun x : A => g (f x)) l0) eq_refl IHl)
  l.

Notation sigTT P := (fun tv => match tv with existT t v => P t end).

Definition compact_prod_sigT_type {A} {P: A -> Type} (l: list (sigT P)): Type :=
  compact_prod (map (sigTT P) l).

Definition compact_prod_sigT_value: forall {A} {P: A -> Type} (l: list (sigT P)), compact_prod (map (sigTT P) l).

Definition compact_sum_sigT_type {A} {P: A -> Type} (l: list (sigT P)): Type :=
  compact_sum (map (sigTT P) l).

Definition compact_sum_sigT_value: forall {A} {P: A -> Type} (l: list (sigT P)), compact_sum (map (sigTT P) l).

Definition compact_prod_map {X: Type} {F F0: X -> Type} (l: list X)
  (f: ListType (map (fun x => F x -> F0 x) l)): compact_prod (map F l) -> compact_prod (map F0 l).

Lemma compact_prod_map_nil: forall {X: Type} {F F0: X -> Type},
  @compact_prod_map X F F0 nil Nil tt = tt.

Lemma compact_prod_map_single: forall {X: Type} {F F0: X -> Type} (x: X)
  (f: F x -> F0 x) (v: F x),
  compact_prod_map (x :: nil) (Cons f Nil) v = f v.

Lemma compact_prod_map_cons: forall {X: Type} {F F0: X -> Type} (x x0: X) (l: list X)
  (f: F x -> F0 x) (fl: ListType (map (fun x => F x -> F0 x) (x0 :: l)))
  (v: F x) (vl: compact_prod (map F (x0 :: l))),
  compact_prod_map (x :: x0 :: l) (Cons f fl) (v, vl) = (f v, compact_prod_map _ fl vl).

Definition compact_sum_map {X: Type} {F F0: X -> Type} (l: list X)
  (f: ListType (map (fun x => F x -> F0 x) l)): compact_sum (map F l) -> compact_sum (map F0 l).

Lemma compact_sum_map_nil: forall {X: Type} {F F0: X -> Type},
  @compact_sum_map X F F0 nil Nil tt = tt.

Lemma compact_sum_map_single: forall {X: Type} {F F0: X -> Type} (x: X)
  (f: F x -> F0 x) (v: F x),
  compact_sum_map (x :: nil) (Cons f Nil) v = f v.

Lemma compact_sum_map_cons_inl: forall {X: Type} {F F0: X -> Type} (x x0: X) (l: list X)
  (f: F x -> F0 x) (fl: ListType (map (fun x => F x -> F0 x) (x0 :: l)))
  (v: F x),
  compact_sum_map (x :: x0 :: l) (Cons f fl) (inl v) = inl (f v).

Lemma compact_sum_map_cons_inr: forall {X: Type} {F F0: X -> Type} (x x0: X) (l: list X)
  (f: F x -> F0 x) (fl: ListType (map (fun x => F x -> F0 x) (x0 :: l)))
  (vl: compact_sum (map F (x0 :: l))),
  compact_sum_map (x :: x0 :: l) (Cons f fl) (inr vl) = inr (compact_sum_map _ fl vl).

Definition reptype_gen {cs: compspecs} : type -> (sigT (fun x => x)) :=
  type_func (fun _ => (sigT (fun x => x)))
  (fun t =>
     if (type_is_by_value t)
     then existT (fun x => x) val Vundef
     else existT (fun x => x) unit tt)
  (fun t n a TV => existT (fun x => x) (list (projT1 TV)) (list_repeat (Z.to_nat n) (projT2 TV)))
  (fun id a TVs => existT (fun x => x) (compact_prod_sigT_type (decay TVs)) (compact_prod_sigT_value (decay TVs)))
  (fun id a TVs => existT (fun x => x) (compact_sum_sigT_type (decay TVs)) (compact_sum_sigT_value (decay TVs))).

Definition reptype {cs: compspecs} t: Type := match reptype_gen t with existT t _ => t end.

Definition default_val {cs: compspecs} t: reptype t :=
  match reptype_gen t as tv
    return match tv with existT t _ => t end
  with existT t v => v end.

Instance Inhabitant_reptype {cs: compspecs} (t: type) : Inhabitant (reptype t) := default_val t.

Section CENV.
Context {cs: compspecs}.

Lemma reptype_gen_eq: forall t,
  reptype_gen t =
  match t with
  | Tarray t0 n _ => existT (fun x => x) (list (projT1 (reptype_gen t0))) (list_repeat (Z.to_nat n) (projT2 (reptype_gen t0)))

Definition reptype_structlist (m: members) := compact_prod (map (fun it => reptype (field_type (fst it) m)) m).
Definition reptype_unionlist (m: members) := compact_sum (map (fun it => reptype (field_type (fst it) m)) m).

Notation REPTYPE t :=
  match t return Type with
  | Tvoid
  | Tfunction _ _ _ => unit
  | Tint _ _ _
  | Tlong _ _
  | Tfloat _ _
  | Tpointer _ _ => val
  | Tarray t0 _ _ => list (reptype t0)
  | Tstruct id _ => reptype_structlist (co_members (get_co id))
  | Tunion id _ => reptype_unionlist (co_members (get_co id))
  end.

Lemma reptype_eq: forall t,
  reptype t = REPTYPE t.

Definition unfold_reptype {t} (v: reptype t): REPTYPE t :=
  @eq_rect Type (reptype t) (fun x: Type => x) v (REPTYPE t) (reptype_eq t).

Definition fold_reptype {t} (v: REPTYPE t): reptype t :=
  @eq_rect_r Type (REPTYPE t) (fun x: Type => x) v (reptype t) (reptype_eq t).

Lemma fold_unfold_reptype: forall t (v: reptype t),
  fold_reptype (unfold_reptype v) = v.

Lemma unfold_fold_reptype: forall t (v: REPTYPE t),
  unfold_reptype (fold_reptype v) = v.

Lemma unfold_reptype_JMeq: forall t (v: reptype t),
  JMeq (unfold_reptype v) v.

Lemma fold_reptype_JMeq: forall t v,
  JMeq (fold_reptype v : reptype t) v.

Definition union_default_filter m :=
  match m with
  | nil => fun _ => false
  | hd :: _ => fun m => if member_dec hd m then true else false
  end.

Definition is_default_filter {A} f (l: list A) :=
  match l with
  | nil => True
  | hd :: _ => f hd = true
  end.

Lemma union_default_filter_is_default_filter: forall m, is_default_filter (union_default_filter m) m.

Lemma const_true_is_default_filter: forall m, is_default_filter (fun _: ident * type => true) m.

Definition struct_default_val (m : members) := compact_prod_gen (fun it => default_val (field_type (fst it) m)) m.
Definition union_default_val (m : members) := compact_sum_gen (fun it => true) (fun it => default_val (field_type (fst it) m)) m.

Lemma compact_prod_sigT_compact_prod_gen:
  forall {A B} {P: A -> Type} (genT: B -> A) (genV: forall b: B, P (genT b)) (gen: B -> sigT P) (l: list B),
    (forall b, gen b = existT P (genT b) (genV b)) ->
    JMeq (compact_prod_sigT_value (map gen l)) (compact_prod_gen genV l).

Lemma compact_sum_sigT_compact_sum_gen:
  forall {A B} {P: A -> Type} (genT: B -> A) (genV: forall b: B, P (genT b)) (filter: B -> bool) (gen: B -> sigT P) (l: list B),
    (forall b, gen b = existT P (genT b) (genV b)) ->
    is_default_filter filter l ->
    JMeq (compact_sum_sigT_value (map gen l)) (compact_sum_gen filter genV l).

Lemma default_val_eq: forall t,
  default_val t =
  fold_reptype
  match t as t' return REPTYPE t'
  with
  | Tvoid
  | Tfunction _ _ _ => tt
  | Tint _ _ _
  | Tlong _ _
  | Tfloat _ _
  | Tpointer _ _ => Vundef
  | Tarray t0 n _ => list_repeat (Z.to_nat n) (default_val t0)

Inductive pointer_val : Type :=
  | ValidPointer: block -> Ptrofs.int -> pointer_val
  | NullPointer.

Lemma PV_eq_dec: forall x y: pointer_val, {x = y} + {x <> y}.

Lemma zero_in_range : (-1 < 0 < Int.modulus)%Z.
Definition Int_zero := Int.mkint 0 zero_in_range.

Definition pointer_val_val (pv: pointer_val): val :=
  match pv with
  | ValidPointer b i => Vptr b i
  | NullPointer => Vint Int.zero 
  end.

Definition reptype': type -> Type :=
  type_func (fun _ => Type)
  (fun t =>
     if (type_is_by_value t)
     then match t with
          | Tint _ _ _ => int
          | Tlong _ _ => Int64.int
          | Tfloat _ _ => float
          | Tpointer _ _ => pointer_val
          | _ => val
          end
     else unit)
  (fun t n a T => list T)
  (fun id a T => compact_prod (decay T))
  (fun id a T => compact_sum (decay T)).

Notation REPTYPE' t :=
  match t return Type with
  | Tvoid
  | Tfunction _ _ _ => unit
  | Tint _ _ a => int
  | Tlong _ a => Int64.int
  | Tfloat _ a => float
  | Tpointer _ a => pointer_val
  | Tarray t0 _ _ => list (reptype' t0)
  | Tstruct id _ => compact_prod (map (fun it => reptype' (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))
  | Tunion id _ => compact_sum (map (fun it => reptype' (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))
  end.

Lemma reptype'_eq: forall t,
  reptype' t = REPTYPE' t.

Definition unfold_reptype' {t} (v: reptype' t): REPTYPE' t :=
  @eq_rect Type (reptype' t) (fun x: Type => x) v (REPTYPE' t) (reptype'_eq t).

Definition fold_reptype' {t} (v: REPTYPE' t): reptype' t :=
  @eq_rect_r Type (REPTYPE' t) (fun x: Type => x) v (reptype' t) (reptype'_eq t).

Lemma fold_unfold_reptype': forall t (v: reptype' t),
  fold_reptype' (unfold_reptype' v) = v.

Lemma unfold_fold_reptype': forall t (v: REPTYPE' t),
  unfold_reptype' (fold_reptype' v) = v.

Definition repinj_bv (t: type): reptype' t -> reptype t :=
  fun v =>
  fold_reptype
  (match t as t' return (REPTYPE' t' -> REPTYPE t': Type)
   with
   | Tvoid
   | Tfunction _ _ _ => @id unit
   | Tint _ _ a => Vint
   | Tlong _ a => Vlong
   | Tfloat _ a => Vfloat
   | Tpointer _ a => pointer_val_val
   | Tarray t0 n a => fun _ => nil
   | Tstruct id a => fun _ => struct_default_val _
   | Tunion id a => fun _ => union_default_val _
   end (unfold_reptype' v)).

Definition repinj_aux_s (id: ident) (a: attr) (F: ListType (map (fun it => reptype' (field_type (fst it) (co_members (get_co id))) -> reptype (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))): reptype' (Tstruct id a) -> reptype (Tstruct id a) :=
  fun v => @fold_reptype (Tstruct id a) (compact_prod_map _ F (unfold_reptype' v)).

Definition repinj_aux_u (id: ident) (a: attr) (F: ListType (map (fun it => reptype' (field_type (fst it) (co_members (get_co id))) -> reptype (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))): reptype' (Tunion id a) -> reptype (Tunion id a) :=
  fun v => @fold_reptype (Tunion id a) (compact_sum_map _ F (unfold_reptype' v)).

Definition repinj: forall t: type, reptype' t -> reptype t :=
  type_func (fun t => reptype' t -> reptype t)
  repinj_bv
  (fun t n a f v => @fold_reptype (Tarray t n a) (map f (unfold_reptype' v)))
  repinj_aux_s
  repinj_aux_u.

Lemma repinj_eq: forall t v,
  repinj t v =
  fold_reptype
  (match t as t' return REPTYPE' t' -> REPTYPE t' with
   | Tvoid
   | Tfunction _ _ _ => @id unit
   | Tint _ _ a => Vint
   | Tlong _ a => Vlong
   | Tfloat _ a => Vfloat
   | Tpointer _ a => pointer_val_val
   | Tarray t0 _ _ => map (repinj t0)
   | Tstruct id a => compact_prod_map _ (ListTypeGen (fun it => reptype' (field_type (fst it) (co_members (get_co id))) -> reptype (field_type (fst it) (co_members (get_co id)))) (fun it => repinj (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))
   | Tunion id a => compact_sum_map _ (ListTypeGen (fun it => reptype' (field_type (fst it) (co_members (get_co id))) -> reptype (field_type (fst it) (co_members (get_co id)))) (fun it => repinj (field_type (fst it) (co_members (get_co id)))) (co_members (get_co id)))
   end (unfold_reptype' v)).

Lemma int_add_repr_0_l: forall i, Int.add (Int.repr 0) i = i.
Lemma int_add_repr_0_r: forall i, Int.add i (Int.repr 0) = i.
Hint Rewrite int_add_repr_0_l int_add_repr_0_r : norm.

Lemma ptrofs_add_repr_0_l: forall i, Ptrofs.add (Ptrofs.repr 0) i = i.
Lemma ptrofs_add_repr_0_r: forall i, Ptrofs.add i (Ptrofs.repr 0) = i.
Hint Rewrite ptrofs_add_repr_0_l ptrofs_add_repr_0_r : norm.

Definition repinject (t: type) : reptype t -> val :=
  match t as t0 return reptype t0 -> val with
  | Tint _ _ _ => fun v => v
  | Tlong _ _ => fun v => v
  | Tfloat _ _ => fun v => v
  | Tpointer _ _ => fun v => v
  | _ => fun _ => Vundef
 end.

Definition valinject (t: type) : val -> reptype t :=
  match t as t0 return val -> reptype t0 with
  | Tint _ _ _ => fun v => v
  | Tlong _ _ => fun v => v
  | Tfloat _ _ => fun v => v
  | Tpointer _ _ => fun v => v
  | t => fun _ => default_val t
 end.

Lemma valinject_JMeq: forall t v, type_is_by_value t = true -> JMeq (valinject t v) v.

Lemma repinject_JMeq: forall t v, type_is_by_value t = true -> JMeq (repinject t v) v.

Lemma repinject_unfold_reptype: forall t v,
  match t as t' return REPTYPE t' -> Prop with
  | Tint _ _ _
  | Tfloat _ _
  | Tlong _ _
  | Tpointer _ _ => fun vv => repinject t v = vv
  | _ => fun _ => True
  end (unfold_reptype v).

Lemma repinject_valinject:
  forall t v,
    type_is_by_value t = true -> repinject t (valinject t v) = v.

Lemma valinject_repinject: forall t v,
  type_is_by_value t = true ->
  (valinject t (repinject t v)) = v.

Lemma repinject_default_val:
 forall t, repinject t (default_val t) = Vundef.

End CENV.

Arguments reptype' {cs} t / .

Global Notation REPTYPE t :=
  match t return Type with
  | Tvoid
  | Tfunction _ _ _ => unit
  | Tint _ _ _
  | Tlong _ _
  | Tfloat _ _
  | Tpointer _ _ => val
  | Tarray t0 _ _ => list (reptype t0)
  | Tstruct id _ => reptype_structlist (co_members (get_co id))
  | Tunion id _ => reptype_unionlist (co_members (get_co id))
  end.

Tactic Notation "unfold_repinj" :=
repeat match goal with |- context [repinj ?T] =>
 let x := fresh "x" in set (x := repinj T);
    lazy beta iota zeta delta in x; subst x; lazy beta
end.

Tactic Notation "unfold_repinj" constr(T) :=
match goal with |- context [repinj T] =>
 let x := fresh "x" in set (x := repinj T);
    lazy beta iota zeta delta in x; subst x; lazy beta
end.

Lemma reptype_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  @reptype cs_from t = @reptype cs_to t.

Lemma default_val_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),
  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->
  JMeq (@default_val cs_from t) (@default_val cs_to t).

Fixpoint force_lengthn {A} n (xs: list A) (default: A) :=
  match n, xs with
  | O, _ => nil
  | S n0, nil => default :: force_lengthn n0 nil default
  | S n0, hd :: tl => hd :: force_lengthn n0 tl default
  end.

Lemma force_lengthn_length_n: forall {A} n (xs : list A) (default: A),
  length (force_lengthn n xs default) = n.

Lemma nth_force_lengthn_nil: forall {A} n i (default: A),
  nth i (force_lengthn n nil default) default = default.

Lemma nth_force_lengthn: forall {A} n i (xs : list A) (default: A),
  (0 <= i < n) %nat ->
  nth i (force_lengthn n xs default) default = nth i xs default.

Lemma force_lengthn_id: forall {A} n ct (d: A), length ct = n -> force_lengthn n ct d = ct.

Open Scope Z.

Fixpoint replist' {A: Type} {d: Inhabitant A} (lo: Z) (n: nat) (al: list A) :=
 match n with
 | O => nil
 | S n' =>  Znth lo al :: replist' (Z.succ lo) n' al
 end.

Definition replist {cs: compspecs} (t: type)  (lo hi: Z) (al: list (reptype t)) :=
  replist'  lo (Z.to_nat (hi-lo)) al.

Lemma replist_replist {cs: compspecs}:
 forall t (lo hi lo' hi': Z) al,
   0 <= lo <= hi ->
   0 <= lo' <= hi' ->
   lo'+hi <= hi'  ->
 replist t lo hi (replist t lo' hi' al) =
   replist t (lo+lo') (hi+lo') al.

Lemma replist'_succ:
 forall {A} {d:Inhabitant A} lo n r al,
   (lo>=0) -> replist' (Z.succ lo) n (r::al) = replist' lo n al.

Lemma replist_firstn_skipn {cs: compspecs}:
 forall t lo hi al,
  (lo <= hi <= length al)%nat ->
  replist t (Z.of_nat lo) (Z.of_nat hi) al = firstn (hi-lo) (skipn lo al).

Lemma skipn_0:
 forall A (al: list A) n,
  (n=0)%nat -> skipn n al = al.

Lemma replist_elim {cs: compspecs}:
  forall t lo hi al,
    lo = 0 -> hi = Zlength al ->
    replist t lo hi al = al.

Lemma replist_Zlength {cs: compspecs}:
  forall t lo hi al,
    lo <= hi ->
   Zlength (replist t lo hi al) = hi-lo.

Lemma replist_length {cs: compspecs}:
  forall t lo hi al,
    lo <= hi ->
   length (replist t lo hi al) = Z.to_nat (hi-lo).

Lemma unfold_reptype_elim:
  forall cs t v v',
    JMeq v v' ->
   @unfold_reptype cs t v = v'.

Lemma Zlength_default_val_Tarray_tuchar {cs} n a (N:0<=n): Zlength (@default_val cs (Tarray tuchar n a)) = n. *)

Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.

Require Import VST.floyd.data_at_rec_lemmas.
(* VST.floyd.data_at_rec_lemmas:
Require Import VST.floyd.base2.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.type_induction.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.mapsto_memory_block.
Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.
Import VST.floyd.aggregate_pred.auxiliary_pred.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.jmeq_lemmas.
Require Import VST.floyd.sublist.
Require Export VST.floyd.fieldlist.
Require Export VST.floyd.aggregate_type.

Opaque alignof.

Local Open Scope logic.

Arguments align !n !amount / .
Arguments Z.max !n !m / .

Definition offset_in_range ofs p :=
  match p with
  | Vptr b iofs => 0 <= Ptrofs.unsigned iofs + ofs <= Ptrofs.modulus
  | _ => True
  end.

Definition offset_strict_in_range ofs p :=
  match p with
  | Vptr b iofs => 0 <= Ptrofs.unsigned iofs + ofs < Ptrofs.modulus
  | _ => True
  end.

Section CENV.

Context {cs: compspecs}.

Section WITH_SHARE.

Variable sh: share.

Definition data_at_rec: forall t, reptype t -> val -> mpred :=
  type_func (fun t => reptype t -> val -> mpred)
    (fun t v p =>
       if type_is_volatile t
       then memory_block sh (sizeof t) p
       else mapsto sh t p (repinject t v))
    (fun t n a P v => array_pred 0 (Z.max 0 n) (fun i v => at_offset (P v) (sizeof t * i)) (unfold_reptype v))
    (fun id a P v => struct_data_at_rec_aux sh (co_members (get_co id)) (co_members (get_co id)) (co_sizeof (get_co id)) P (unfold_reptype v))
    (fun id a P v => union_data_at_rec_aux sh (co_members (get_co id)) (co_members (get_co id)) (co_sizeof (get_co id)) P (unfold_reptype v)).

Lemma data_at_rec_eq: forall t v,
  data_at_rec t v =
  match t return REPTYPE t -> val -> mpred with
  | Tvoid
  | Tfunction _ _ _ => fun _ _ => FF
  | Tint _ _ _
  | Tfloat _ _
  | Tlong _ _
  | Tpointer _ _ => fun v p =>
                      if type_is_volatile t
                      then memory_block sh (sizeof t) p
                      else mapsto sh t p v
  | Tarray t0 n a => array_pred 0 (Z.max 0 n) (fun i v => at_offset (data_at_rec t0 v) (sizeof t0 * i))

End WITH_SHARE.

Lemma data_at_rec_type_changable: forall (sh: Share.t) (t1 t2: type) v1 v2,

Lemma by_value_default_val: forall t:type,
  type_is_by_value t = true -> JMeq (default_val t) Vundef.

Lemma by_value_reptype: forall t, type_is_by_value t = true -> reptype t = val.

Lemma by_value_data_at_rec_volatile: forall sh t v p,
  type_is_by_value t = true ->
  type_is_volatile t = true ->
  data_at_rec sh t v p = memory_block sh (sizeof t) p.

Lemma by_value_data_at_rec_nonvolatile: forall sh t v p,
  type_is_by_value t = true ->
  type_is_volatile t = false ->
  data_at_rec sh t v p = mapsto sh t p (repinject t v).

Lemma by_value_data_at_rec_default_val: forall sh t p,
  type_is_by_value t = true ->
  size_compatible t p ->
  align_compatible t p ->
  data_at_rec sh t (default_val t) p = memory_block sh (sizeof t) p.

Lemma by_value_data_at_rec_nonreachable: forall sh t p v,
  type_is_by_value t = true ->
  size_compatible t p ->
  align_compatible t p ->
  ~ readable_share sh ->
  tc_val' t (repinject t v) ->
  data_at_rec sh t v p = memory_block sh (sizeof t) p.

Lemma by_value_data_at_rec_default_val2: forall sh t b ofs,
  type_is_by_value t = true ->
  0 <= ofs /\ ofs + sizeof t < Ptrofs.modulus ->

Lemma by_value_data_at_rec_nonreachable2: forall sh t b ofs v,
  type_is_by_value t = true ->
  0 <= ofs /\ ofs + sizeof t < Ptrofs.modulus ->

Lemma lower_sepcon_val':
  forall (P Q: val->mpred) v,
  ((P*Q) v) = (P v * Q v).

Lemma Znth_nil: forall {A}{d: Inhabitant A} n, Znth n nil = default.

Lemma offset_val_zero_Vptr: forall b i, offset_val 0 (Vptr b i) = Vptr b i.

Lemma nth_list_repeat: forall A i n (x :A),
    nth i (list_repeat n x) x = x.

Lemma nth_list_repeat': forall A i n (x y :A),
    (i < n)%nat ->
    nth i (list_repeat n x) y = x.

 Lemma Z2Nat_max0: forall z, Z.to_nat (Z.max 0 z) = Z.to_nat z.

Lemma range_max0: forall x z, 0 <= x < Z.max 0 z <-> 0 <= x < z.
  
Lemma memory_block_data_at_rec_default_val: forall sh t b ofs
  (LEGAL_COSU: complete_legal_cosu_type t = true),
  0 <= ofs /\ ofs + sizeof t < Ptrofs.modulus ->

Lemma data_at_rec_data_at_rec_ : forall sh t v b ofs
  (LEGAL_COSU: complete_legal_cosu_type t = true),
  0 <= ofs /\ ofs + sizeof t < Ptrofs.modulus ->

Definition value_fits: forall t, reptype t -> Prop :=
  type_func (fun t => reptype t -> Prop)
    (fun t v =>
       if type_is_volatile t then True else tc_val' t (repinject t v))
    (fun t n a P v => Zlength (unfold_reptype v) =  Z.max 0 n /\ Forall P (unfold_reptype v))
    (fun id a P v => struct_value_fits_aux (co_members (get_co id)) (co_members (get_co id)) P (unfold_reptype v))
    (fun id a P v => union_value_fits_aux (co_members (get_co id)) (co_members (get_co id)) P (unfold_reptype v)).

Lemma value_fits_eq:
  forall t v,
  value_fits t v =
  match t as t0 return (reptype t0 -> Prop)  with
  | Tarray t' n a => fun v0 : reptype (Tarray t' n a) =>
    (fun v1 : list (reptype t') =>
     Zlength v1 = Z.max 0 n /\ Forall (value_fits t') v1)

Lemma value_fits_type_changable: forall (t1 t2: type) v1 v2,
  t1 = t2 ->
  JMeq v1 v2 ->
  value_fits t1 v1 = value_fits t2 v2.

Lemma default_value_fits:
  forall t, value_fits t (default_val t).

Lemma data_at_rec_value_fits: forall sh t v p,
  data_at_rec sh t v p |-- !! value_fits t v.

Lemma data_at_rec_share_join:
  forall sh1 sh2 sh t v b ofs,
    sepalg.join sh1 sh2 sh ->

Lemma nonreadable_memory_block_data_at_rec:
  forall sh t v b ofs
  (LEGAL_COSU: complete_legal_cosu_type t = true),
  0 <= ofs /\ ofs + sizeof t < Ptrofs.modulus ->

End CENV.

Lemma data_at_rec_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (sh: Share.t) (t: type) v1 v2,

Lemma value_fits_Tstruct:
  forall {cs: compspecs} t (v: reptype t) i a m v2 r,
  t = Tstruct i a ->
  m = co_members (get_co i)  ->
  JMeq (@unfold_reptype cs t v) v2 ->
  r =struct_Prop m
          (fun it => value_fits (field_type (fst it) m))  v2 ->
  value_fits t v = r.

Lemma value_fits_Tunion:
  forall {cs: compspecs} t (v: reptype t) i a m v2 r,
  t = Tunion i a ->
  m = co_members (get_co i)  ->
  JMeq (@unfold_reptype cs t v) v2 ->
  r =union_Prop m
          (fun it => value_fits (field_type (fst it) m))  v2 ->
  value_fits t v = r.

Lemma value_fits_by_value_defined:
  forall {cs: compspecs} t t' v r,
   type_is_by_value t = true ->
   repinject t v <> Vundef  ->
   t = t' ->
   (r = if type_is_volatile t' then True
       else tc_val t' (repinject t v)) ->
   value_fits t v = r.

Lemma value_fits_by_value_Vundef:
  forall {cs: compspecs} t v,
   type_is_by_value t = true ->
   repinject t v = Vundef  ->
   value_fits t v = True.

Lemma value_fits_by_value:
  forall {cs: compspecs} t t' v r,
   type_is_by_value t = true ->
   t = t' ->
   (r = if type_is_volatile t then True
       else tc_val' t' (repinject t v)) ->
   value_fits t v = r.

Lemma value_fits_Tarray:
  forall {cs: compspecs} t (v: reptype t) t' n a
    (v' : list (reptype t')) r,
  t = (Tarray t' n a) ->
  JMeq (unfold_reptype v) v' ->
  n >= 0 ->
  r = (Zlength v' = n /\ Forall (value_fits t') v') ->
  value_fits t v =r.

Ltac cleanup_unfold_reptype :=
    match goal with |- JMeq (unfold_reptype ?A) _ =>
                 instantiate (1:=A); apply JMeq_refl
    end.

Ltac simplify_value_fits' :=
first
 [erewrite value_fits_Tstruct;
    [ | reflexivity
    | simpl; reflexivity
    | cleanup_unfold_reptype
    | simpl; reflexivity]
 |erewrite value_fits_Tarray;
    [ | reflexivity
    | cleanup_unfold_reptype
    | repeat subst_any; try computable; omega
    | simpl; reflexivity
    ]
 | erewrite value_fits_by_value_defined;
   [ | reflexivity
   | repeat subst_any; clear; simpl; intro; discriminate
   | simpl; lazy beta iota zeta delta [field_type]; simpl; reflexivity
   | simpl; reflexivity
   ]
 | rewrite value_fits_by_value_Vundef;
   [ | reflexivity | reflexivity
   ]
 | erewrite value_fits_by_value;
   [ | reflexivity
   | simpl; lazy beta iota zeta delta [field_type]; simpl; reflexivity
   | simpl; reflexivity
   ]
 ];
 cbv beta;
 repeat match goal with |- context [@reptype ?cs ?t] =>
   change (@reptype cs t) with val
 end.

Tactic Notation "simplify_value_fits" :=
  simplify_value_fits'.

Tactic Notation "simplify_value_fits" "in" hyp(H) :=
  match type of H with ?A =>
  let a := fresh "a" in set (a:=A) in H;
   let H1 := fresh in assert (H1: a = A) by (apply eq_refl);
   clearbody a;
   match goal with |- ?B =>
    let BB := fresh "BB" in set (BB:=B);
   revert H1; simplify_value_fits'; intro H1; subst a; subst BB
  end
 end.

Tactic Notation "simplify_value_fits" "in" "*" :=
repeat match goal with
 | H: context [value_fits _ _ _] |- _ =>
  simplify_value_fits in H
end;
 repeat simplify_value_fits'. *)

Require Import VST.floyd.jmeq_lemmas.
(* VST.floyd.jmeq_lemmas:
Require Import Coq.Setoids.Setoid.
Require Import VST.msl.Extensionality.

Definition JMeq {A:Type} (x:A) {B:Type} (y: B): Prop :=
  {H: @eq Type A B | @eq_rect Type A (fun T: Type => T) x B H = y}.

Lemma JMeq_refl: forall {A: Type} (x: A), JMeq x x.
Hint Resolve JMeq_refl.

Lemma JMeq_sym : forall {A: Type} {B:Type} {x:A} {y:B}, JMeq x y -> JMeq y x.
Hint Immediate JMeq_sym.

Lemma JMeq_trans :
 forall {A: Type} {B: Type} {C:Type} {x:A} {y:B} {z:C}, JMeq x y -> JMeq y z -> JMeq x z.

Lemma JMeq_eq : forall (A:Type) (x y:A), JMeq x y -> x = y.

Lemma JMeq_ind : forall (A:Type) (x:A) (P:A -> Prop),
  P x -> forall y, JMeq x y -> P y.

Lemma JMeq_rec : forall (A:Type) (x:A) (P:A -> Set),
  P x -> forall y, JMeq x y -> P y.

Lemma JMeq_rect : forall (A:Type) (x:A) (P:A->Type),
  P x -> forall y, JMeq x y -> P y.

Lemma JMeq_ind_r : forall (A:Type) (x:A) (P:A -> Prop),
   P x -> forall y, JMeq y x -> P y.

Lemma JMeq_rec_r : forall (A:Type) (x:A) (P:A -> Set),
   P x -> forall y, JMeq y x -> P y.

Lemma JMeq_rect_r : forall (A:Type) (x:A) (P:A -> Type),
   P x -> forall y, JMeq y x -> P y.

Lemma JMeq_congr :
 forall (A:Type) (x:A) (B:Type) (f:A->B) (y:A), JMeq x y -> f x = f y.

Require Import Coq.Logic.Eqdep.

Lemma JMeq_eq_dep_id :
 forall (A:Type) (B:Type) (x:A) (y:B), JMeq x y -> eq_dep Type (fun X:Type => X) A x B y.

Lemma eq_dep_id_JMeq :
 forall (A: Type) (B:Type) (x:A) (y:B), eq_dep Type (fun X:Type => X) A x B y -> JMeq x y.

Lemma eq_dep_JMeq :
 forall (U: Type) (P: U -> Type) p x q y, eq_dep U P p x q y -> JMeq x y.

Lemma eq_dep_strictly_stronger_JMeq :
 exists (U: Type) (P: U -> Type) p q x y, JMeq x y /\ ~ eq_dep U P p x q y.

Lemma JMeq_eq_dep :
  forall (U:Type) (P:U->Prop) p q (x:P p) (y:P q),
  p = q -> JMeq x y -> eq_dep U P p x q y.

Notation sym_JMeq := JMeq_sym (only parsing).
Notation trans_JMeq := JMeq_trans (only parsing).

Lemma eq_rect_JMeq: forall (A:Type) (x y: A) (F: A -> Type) (v: F x) (H: x = y), JMeq (eq_rect x F v y H) v.

Lemma eq_rect_r_JMeq: forall (A:Type) (x y: A) (F: A -> Type) (v: F x) (H: y = x), JMeq (eq_rect_r F v H) v.

Lemma JMeq_sumtype_ll: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: A) (y: C), @eq Type A C -> @eq Type B D -> 
  (@JMeq (A + B) (inl x) (C + D) (inl y)) ->
  JMeq x y.

Lemma JMeq_sumtype_rr: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: B) (y: D), @eq Type A C -> @eq Type B D -> 
  (@JMeq (A + B) (inr x) (C + D) (inr y)) ->
  JMeq x y.

Lemma JMeq_sumtype_lr: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: A) (y: D), @eq Type A C -> @eq Type B D -> ~ (@JMeq (A + B) (inl x) (C + D) (inr y)).

Lemma JMeq_sumtype_rl: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: B) (y: C), @eq Type A C -> @eq Type B D -> ~ (@JMeq (A + B) (inr x) (C + D) (inl y)).

Ltac solve_JMeq_sumtype H :=
  match type of H with
  | JMeq ?x ?y =>
    destruct x; destruct y;
     [apply JMeq_sumtype_ll in H; auto
     |apply JMeq_sumtype_lr in H; auto; inversion H
     |apply JMeq_sumtype_rl in H; auto; inversion H
     |apply JMeq_sumtype_rr in H; auto]
  end.

Lemma JMeq_inl: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: A) (y: C), @eq Type B D -> JMeq x y -> @JMeq (A + B) (inl x) (C + D) (inl y).

Lemma JMeq_inr: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: B) (y: D), @eq Type A C -> JMeq x y -> @JMeq (A + B) (inr x) (C + D) (inr y).

Lemma JMeq_fst: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: A*B) (y: C*D), @eq Type A C -> @eq Type B D -> JMeq x y -> JMeq (fst x) (fst y).

Lemma JMeq_snd: forall (A: Type) (B: Type) (C: Type) (D: Type) (x: A*B) (y: C*D), @eq Type A C -> @eq Type B D -> JMeq x y -> JMeq (snd x) (snd y).

Lemma JMeq_pair: forall (A: Type) (B: Type) (C: Type) (D: Type) (a: A) (b: B) (c: C) (d: D), JMeq a b -> JMeq c d -> JMeq (a, c) (b, d).

Lemma eq_rect_r_eq_rect_r_eq_sym: forall {T} {A B: T} F x (H: A = B),
  eq_rect_r F (eq_rect_r F x H) (eq_sym H) = x.

Lemma eq_rect_r_eq_rect_r_eq_sym': forall {T} {A B: T} F x (H: B = A),
  eq_rect_r F (eq_rect_r F x (eq_sym H)) H = x.

Lemma JMeq_func: forall (A: Type) (B: Type) (C: Type) (D: Type) (f: A -> B) (g: C -> D) x y,
  @eq Type B D ->
  JMeq x y -> JMeq f g -> JMeq (f x) (g y).

Lemma eq_JMeq: forall A (x y: A), x=y -> JMeq x y.

Lemma list_func_JMeq: forall {A: Type} {B: Type} {C: Type} (a: list A) (b: list B) (f: forall X, list X -> C), @eq Type A B -> JMeq a b -> f A a = f B b.

Lemma list_func_JMeq': forall {A: Type} {B: Type} (a: list A) (b: list B) (a': A) (b': B) (f: forall X, list X -> X -> X), JMeq a b -> JMeq a' b' -> JMeq (f A a a') (f B b b').

Lemma JMeq_sigT: forall {A: Type} {B: Type} (a: A), @eq Type A B -> {b: B | JMeq a b}.

Arguments JMeq_eq {A} {x y} _. *)

Require Import VST.floyd.sublist.
(* VST.floyd.sublist:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Require Import Coq.Lists.List.
Import ListNotations.

Class Inhabitant (A: Type) := default : A.

Instance Inhabitant_Z : Inhabitant Z := 0.
Instance Inhabitant_nat : Inhabitant nat := O.
Instance Inhabitant_positive : Inhabitant positive := 1%positive.
Instance Inhabitant_list {T: Type} : Inhabitant (list T) := @nil T.
Instance Inhabitant_fun {T1 T2: Type} {H: Inhabitant T2} : Inhabitant (T1->T2) := fun _ => H.
Instance Inhabitant_Prop : Inhabitant Prop := False.
Instance Inhabitant_bool : Inhabitant bool := false.
Instance Inhabitant_pair {T1 T2 : Type} {x1: Inhabitant T1} {x2: Inhabitant T2} : Inhabitant (T1*T2)%type := (x1,x2).

Lemma Zlength_length:
  forall A (al: list A) (n: Z),
    0 <= n ->
    (Zlength al = n <-> length al = Z.to_nat n).

Lemma firstn_app1: forall {A} n (p l: list A),
  (n <= Datatypes.length p)%nat ->

Lemma firstn_app2: forall {A} (n: nat) (al bl: list A),
 (n >= length al)%nat ->
 firstn n (al++bl) = al ++ firstn (n - length al) bl.

Lemma firstn_list_repeat {A} (v:A): forall i k, (i<=k)%nat ->
      firstn i (list_repeat k v) = list_repeat i v.

Lemma firstn_app:
 forall {A} n m (al: list A), firstn n al ++ firstn m (skipn n al) =
  firstn (n+m) al.

Lemma nth_skipn:
  forall {A} i n data (d:A),
       nth i (skipn n data) d = nth (i+n) data d.

Lemma skipn_skipn: forall {A} n m (xs: list A),
  skipn n (skipn m xs) = skipn (m + n) xs.

Lemma firstn_exact_length: forall {A} (xs: list A), firstn (length xs) xs = xs.

Lemma skipn_exact_length: forall {A} (xs: list A), skipn (length xs) xs = nil.

Lemma len_le_1_rev: forall {A} (contents: list A),
  (length contents <= 1)%nat ->
  contents = rev contents.

Lemma firstn_firstn: forall {A} (contents: list A) n m,
  (n <= m)%nat ->
  firstn n (firstn m contents) = firstn n contents.

Lemma firstn_1_skipn: forall {A} n (ct: list A) d,
  (n < length ct)%nat ->
  nth n ct d :: nil = firstn 1 (skipn n ct).

Lemma skipn_length: forall {A} (contents: list A) n,
  length (skipn n contents) = (length contents - n)%nat.

Lemma nth_firstn: forall {A} (contents: list A) n m d,
  (n < m)%nat ->
  nth n (firstn m contents) d = nth n contents d.

Lemma skipn_length_short:
  forall {A} n (al: list A),
    (length al <= n)%nat ->
    (length (skipn n al) = 0)%nat.

Lemma skipn_short:
   forall {A} n (al: list A), (n >= length al)%nat -> skipn n al = nil.

Lemma nth_map':
  forall {A B} (f: A -> B) d d' i al,
  (i < length al)%nat ->
   nth i (map f al) d = f (nth i al d').

Lemma skipn_nil: forall A n, skipn n (@nil A) = nil.

Lemma skipn_drop:
 forall A n m (al: list A), skipn n (skipn m al) = skipn (n+m) al.

Lemma skipn_app1:
 forall A n (al bl: list A),
  (n <= length al)%nat ->
  skipn n (al++bl) = skipn n al ++ bl.

Lemma skipn_app2:
 forall A n (al bl: list A),
  (n >= length al)%nat ->
  skipn n (al++bl) = skipn (n-length al) bl.

Lemma list_repeat_app: forall A a b (x:A),
  list_repeat a x ++ list_repeat b x = list_repeat (a+b) x.

Lemma firstn_same:
  forall A n (b: list A), (n >= length b)%nat -> firstn n b = b.

Lemma nth_firstn_low:
 forall A i n al (d: A),
  (i < n <= length al)%nat -> nth i (firstn n al) d = nth i al d.

Lemma nth_error_nth:
  forall A (d: A) i al, (i < length al)%nat -> nth_error al i = Some (nth i al d).

Lemma skipn_rev:
  forall {A} n (vl: list A),
   skipn n (rev vl) = rev (firstn (length vl - n) vl).

Lemma Forall_list_repeat:
  forall {A} (P: A -> Prop) (n: nat) (a: A),
    P a -> Forall P (list_repeat n a).

Lemma skipn_firstn: forall {A} n m (xs: list A),
  skipn n (firstn m xs) = firstn (m-n) (skipn n xs).

Lemma rev_skipn:
 forall {A} n (vl: list A),
  rev (skipn n vl) = firstn (length vl -n) (rev vl).

Lemma firstn_skipn_rev:
  forall {A} lo n (vl: list A),
  (n+lo <= length vl)%nat ->
  firstn n (skipn lo (rev vl)) =
  rev (firstn n (skipn (length vl - (lo+n))%nat vl)).

Lemma map_firstn:
  forall A B (F: A -> B) n (al: list A),
  map F (firstn n al) = firstn n (map F al).

Lemma map_skipn:
  forall A B (F: A -> B) n (al: list A),
  map F (skipn n al) = skipn n (map F al).

Lemma Zlength_app: forall T (al bl: list T),
    Zlength (al++bl) = Zlength al + Zlength bl.

Lemma Zlength_rev: forall T (vl: list T), Zlength (rev vl) = Zlength vl.

Lemma Zlength_map: forall A B (f: A -> B) l, Zlength (map f l) = Zlength l.

Lemma ZtoNat_Zlength:
 forall {A} (l: list A), Z.to_nat (Zlength l) = length l.
Hint Rewrite @ZtoNat_Zlength : norm.

Lemma Zlength_nonneg:
 forall {A} (l: list A), 0 <= Zlength l.

Definition Zlength' := @Zlength.

Ltac pose_Zlength_nonneg1 T A :=
     lazymatch goal with
      | H:  0 <= @Zlength T A |- _ => idtac
      | H:  0 <= @Zlength T A /\ _ |- _ => idtac
      | |- _ => pose proof (@Zlength_nonneg T A)
     end;
     
     let x := fresh "x" in set (x:= @Zlength T A) in *;
     let y := fresh "y" in set (y := @Zlength) in x;
     fold @Zlength' in y; subst y; subst x.

Ltac pose_Zlength_nonneg :=
 repeat
  match goal with
  | |- context [@Zlength ?T ?A] => pose_Zlength_nonneg1 T A
  | H: context [@Zlength ?T ?A] |- _ => pose_Zlength_nonneg1 T A
 end;
  unfold Zlength' in *.

Ltac list_solve := autorewrite with sublist; pose_Zlength_nonneg; omega.

Definition Znth {X}{d: Inhabitant X} n (xs: list X) :=
  if (zlt n 0) then default else nth (Z.to_nat n) xs d.

Lemma Znth_map:
  forall {A:Type} {da: Inhabitant A}{B:Type}{db: Inhabitant B} i (f: A -> B) (al: list A),
  0 <= i < Zlength al ->
  Znth i (map f al)  = f (Znth i al).

Hint Rewrite 
   (@Znth_map Z _) (@Znth_map nat _) (@Znth_map positive _)
    using (auto; rewrite ?Zlength_map in *; omega) : sublist.

Lemma Znth_succ: forall {A}{a: Inhabitant A} i lo (v: list A), Z.succ lo <= i -> Znth (i - lo) v = Znth (i - (Z.succ lo)) (skipn 1 v).

Lemma Znth_0_cons {A}{a: Inhabitant A} l (v:A): Znth 0 (v::l) = v.
Hint Rewrite @Znth_0_cons : sublist.

Lemma Znth_pos_cons {A}{a: Inhabitant A} i l (v:A): 0<i -> Znth i (v::l) = Znth (i-1) l.

Lemma Znth_In : forall {A}{a: Inhabitant A} i l, 0 <= i < Zlength l -> In (Znth i l) l.

Lemma split3_full_length_list: forall {A}{a: Inhabitant A} lo mid hi (ct: list A),
  lo <= mid < hi ->
  Zlength ct = hi - lo ->
  ct = firstn (Z.to_nat (mid - lo)) ct ++

Lemma Forall_Znth:
 forall {A}{a: Inhabitant A} (F: A -> Prop) (al: list A) i,
   0 <= i < Zlength al ->
   Forall F al ->
   F (Znth i al).

Hint Rewrite @app_nil_l @app_nil_r : sublist.

Lemma app_Znth1:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i < Zlength l -> Znth i (l++l') = Znth i l.

Lemma app_Znth2:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i >= Zlength l -> Znth i (l++l') = Znth (i-Zlength l) l'.

Lemma Znth_firstn:
  forall {A}{a: Inhabitant A} (al: list A) (n m : Z),
  n<m -> Znth n (firstn (Z.to_nat m) al) = Znth n al.

Lemma Znth_skipn: forall {A}{a: Inhabitant A}  i n xs,
  0 <= i ->
  0 <= n ->
  Znth i (skipn (nat_of_Z n) xs) = Znth (i+n) xs.

Lemma Z2Nat_neg: forall i, i < 0 -> Z.to_nat i = 0%nat.

Lemma Zlength_firstn:
  forall {A} n (v: list A), Zlength (firstn (Z.to_nat n) v) = Z.min (Z.max 0 n) (Zlength v).

Lemma Zlength_skipn:
  forall {A} n (v: list A),
  Zlength (skipn (Z.to_nat n) v) = Z.max 0 (Zlength v - (Z.max 0n)).

Lemma Znth_cons:
 forall {A}(a: Inhabitant A)  i (al: list A) bl,
  0 <= i < Zlength al  ->
  Znth i al :: bl = firstn (Z.to_nat 1) (skipn (Z.to_nat i) al) ++ bl.

Lemma Zfirstn_app1:
 forall A n (al bl: list A),
  n <= Zlength al -> firstn (Z.to_nat n) (al++bl) = firstn (Z.to_nat n) al.

Lemma Zfirstn_same:
  forall A n (b: list A), n >= Zlength b -> firstn (Z.to_nat n) b = b.

Lemma Zfirstn_app2: forall {A} n (al bl: list A),
 n >= Zlength al ->
 firstn (Z.to_nat n) (al++bl) = al ++ firstn (Z.to_nat (n - Zlength al)) bl.

Lemma Zfirstn_firstn: forall {A} (contents: list A) n m,
  n <= m ->
  firstn (Z.to_nat n) (firstn (Z.to_nat m) contents) = firstn (Z.to_nat n) contents.
Lemma Zskipn_app1:
 forall A n (al bl: list A),
  n <= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat n) al ++ bl.

Lemma Zskipn_app2:
 forall A n (al bl: list A),
  n >= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat (n-Zlength al)) bl.

Lemma Znth_rev:
  forall {A}{d: Inhabitant A} i (al:list A),
  0 <= i < Zlength al ->
  Znth i (rev al) = Znth (Zlength al - i - 1) al.

Lemma Zskipn_firstn: forall {A} n m (xs: list A),
 0 <= n ->
 skipn (Z.to_nat n) (firstn (Z.to_nat m) xs) =

Lemma Zskipn_skipn: forall {A} n m (xs: list A),
  0 <= n -> 0 <= m ->
  skipn (Z.to_nat n) (skipn (Z.to_nat m) xs) = skipn (Z.to_nat (m + n)) xs.

Lemma Zfirstn_app:
 forall {A} n m (al: list A),
  0 <= n -> 0 <= m ->
  firstn (Z.to_nat n) al ++ firstn (Z.to_nat m) (skipn (Z.to_nat n) al) =

Lemma Zfirstn_exact_length:
  forall {A} n (al: list A),
  n = Zlength al ->
  firstn (Z.to_nat n) al = al.

Definition sublist {A} (lo hi: Z) (al: list A) : list A :=
  firstn (Z.to_nat (hi-lo)) (skipn (Z.to_nat lo) al).

Definition upd_Znth {A} (i: Z) (al: list A) (x: A): list A :=
   sublist 0 i al ++ x :: sublist (i+1) (Zlength al) al.

Lemma sublist_sublist {A} i j k m (l:list A): 0<=m -> 0<=k <=i -> i <= j-m ->
  sublist k i (sublist m j l) = sublist (k+m) (i+m) l.

Lemma sublist_rejoin:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid hi al = sublist lo hi al.

Lemma sublist_map:
  forall {A B} (F: A -> B) lo hi (al: list A),
  sublist lo hi (map F al) = map F (sublist lo hi al).

Lemma map_sublist:
  forall {A B} (F: A -> B) lo hi (al: list A),
  map F (sublist lo hi al) = sublist lo hi (map F al).

Lemma sublist_len_1:
  forall {A}{d: Inhabitant A} i (al: list A),
  0 <= i < Zlength al ->
  sublist i (i+1) al = Znth i al :: nil.

Lemma Znth_cons_sublist:
  forall {A}{d: Inhabitant A} i (al: list A) bl,
  0 <= i < Zlength al ->
  Znth i al :: bl = sublist i (i+1) al ++ bl.

Lemma Zlength_sublist:
  forall {A} lo hi (al: list A),
 0 <= lo <= hi -> hi <= Zlength al ->
 Zlength (sublist lo hi al) = hi-lo.

Lemma sublist_same_gen:
forall {A} lo hi (al: list A),
  lo = 0 -> hi >= Zlength al ->
  sublist lo hi al = al.

Lemma sublist_same:
forall {A} lo hi (al: list A),
  lo = 0 -> hi = Zlength al ->
  sublist lo hi al = al.

Lemma Znth_sublist:
  forall {A}{d: Inhabitant A} lo i hi (al: list A),
 0 <= lo ->
 0 <= i < hi-lo ->
 Znth i (sublist lo hi al) = Znth (i+lo) al.

Lemma rev_sublist:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  rev (sublist lo hi al) = sublist (Zlength al - hi) (Zlength al - lo) (rev al).

Lemma sublist_nil:
  forall {A} lo (al: list A),
  sublist lo lo al = nil.

Lemma sublist_nil_gen : forall {A} (l : list A) i j, j <= i -> sublist i j l = [].

Lemma sublist_rev:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  sublist lo hi (rev al) = rev (sublist (Zlength al - hi) (Zlength al - lo) al).

Lemma sublist_app:
  forall {A} lo hi (al bl: list A),
  0 <= lo <= hi -> hi <= Zlength al + Zlength bl ->
  sublist lo hi (al++bl) =
  sublist (Z.min lo (Zlength al)) (Z.min hi (Zlength al)) al ++

Lemma sublist_split:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo hi al = sublist lo mid al ++ sublist mid hi al.

Lemma sublist_last_1 : forall {A}{d: Inhabitant A} lo hi (al : list A), 0 <= lo <= hi -> hi + 1 <= Zlength al ->
  sublist lo (hi + 1) al = sublist lo hi al ++ [Znth hi al].

Lemma Zlen_le_1_rev:
 forall {A} (al: list A),
  Zlength al <= 1 -> rev al = al.

Lemma skipn_0:
  forall A (l: list A), skipn 0 l = l.

Lemma sublist_1_cons {A} l (v:A) n: sublist 1 n (v::l) = sublist 0 (n-1) l.

Lemma sublist_nil': forall (A : Type) (lo lo': Z) (al : list A), lo=lo' -> sublist lo lo' al = [].

Lemma sublist_skip {A} (l:list A) i : 0<=i ->  sublist i (Zlength l) l = skipn (Z.to_nat i) l.

Lemma sublist_firstn {A} (l:list A) i: sublist 0 i l = firstn (Z.to_nat i) l.

Lemma sublist_app1:
  forall (A : Type) (k i : Z) (al bl : list A),
  0 <= k <= i -> i <= Zlength al -> sublist k i (al ++ bl) = sublist k i al.

Lemma sublist0_app1 {A} i (al bl:list A): 0<= i <= Zlength al ->
  sublist 0 i (al ++ bl) = sublist 0 i al.

Lemma sublist_app2 {A} i j (al bl:list A): 0<=Zlength al <= i->
  sublist i j (al ++ bl) = sublist (i-Zlength al) (j-Zlength al) bl.

Lemma sublist_sublist0 {A} i j k (l:list A): 0<=k -> k<=i<=j ->
  sublist k i (sublist 0 j l) = sublist k i l.

Lemma sublist_sublist00 {A} i j (l:list A): 0<=i<=j ->
  sublist 0 i (sublist 0 j l) = sublist 0 i l.

Lemma skipn_list_repeat:
   forall A k n (a: A),
     (k <= n)%nat -> skipn k (list_repeat n a) = list_repeat (n-k) a.

Lemma sublist_list_repeat {A} i j k (v:A) (I: 0<=i)
          (IJK: i <= j <= k):
      sublist i j (list_repeat (Z.to_nat k) v) = list_repeat (Z.to_nat (j-i)) v.

Lemma Zlength_list_repeat:
  forall {A} n (x: A),
  0 <= n ->
  Zlength (list_repeat (Z.to_nat n) x) = n.

Lemma list_repeat_0:
  forall {A} (x:A), list_repeat (Z.to_nat 0) x = nil.

Lemma Znth_list_repeat_inrange:
  forall {A}{d: Inhabitant A} i n (a: A),
   (0 <= i < n)%Z ->
   Znth i (list_repeat (Z.to_nat n) a) = a.

Lemma firstn_nil {A} n: firstn n (nil:list A) = nil.

Lemma firstn_In {A} (x:A): forall l n, In x (firstn n l) -> In x l.
Lemma skipn_In {A} (x:A): forall l n, In x (skipn n l) -> In x l.

Lemma sublist_In {A} lo hi data (x:A) (I:In x (sublist lo hi data)): In x data.

Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Lemma sublist0_app2 {A : Type} i (al bl : list A):
  Zlength al <= i <= Zlength al + Zlength bl ->
  sublist 0 i (al ++ bl) = al ++ sublist 0 (i - Zlength al) bl.

Lemma sublist_rejoin':
  forall {A} lo mid mid' hi (al: list A),
  mid=mid' ->
  0 <= lo <= mid ->
  mid' <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid' hi al = sublist lo hi al.

Hint Rewrite @sublist_nil' using list_solve: sublist.
Hint Rewrite @app_nil_l : sublist.
Hint Rewrite @Zlength_rev : sublist.
Hint Rewrite @sublist_rejoin' using list_solve : sublist.

Lemma subsub1:
 forall a b : Z, (a-(a-b)) = b.
Hint Rewrite subsub1 : sublist.

Lemma sublist_app':
  forall {A} lo hi (al bl: list A),
  0 <= lo <= Zlength al ->
  0 <= hi-Zlength al <= Zlength bl ->
  sublist lo hi (al++bl) =
  sublist lo (Zlength al) al ++
  sublist 0 (hi-Zlength al) bl.

Lemma upd_Znth_Zlength {A} i (l:list A) v: 0<=i < Zlength l ->
      Zlength (upd_Znth i l v) = Zlength l.

Lemma upd_Znth_map {A B} (f:A -> B) i l v:
      upd_Znth i (map f l) (f v) =
      map f (upd_Znth i l v).

Lemma upd_Znth_lookup K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i j (v:A) (I: 0<=i<K) (J: 0<=j<K),
   (i=j /\ Znth i (upd_Znth j l v) = v) \/
   (i<>j /\ Znth i (upd_Znth j l v) = Znth i l).

Lemma upd_Znth_lookup' K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i (I: 0<=i<K) j (J: 0<=j<K) (v:A),
    Znth i (upd_Znth j l v) = if zeq i j then v else Znth i l.

Lemma upd_Znth_char {A} n l1 (v:A) l2 w: Zlength l1=n ->
      upd_Znth n (l1 ++ v :: l2) w = l1 ++ w :: l2.

Lemma upd_Znth_same {A}{d: Inhabitant A}: forall i l u, 0<= i< Zlength l -> Znth i (upd_Znth i l u) = u.

Lemma upd_Znth_diff {A}{d: Inhabitant A}: forall i j l u, 0<= i< Zlength l -> 0<= j< Zlength l -> i<>j ->
      Znth i (upd_Znth j l u) = Znth i l.

Lemma upd_Znth_app1 {A} i l1 l2 (I: 0 <= i < Zlength l1) (v:A):
      upd_Znth i (l1++l2) v = upd_Znth i l1 v ++ l2.

Lemma upd_Znth_app2 {A} (l1 l2:list A) i v:
  Zlength l1 <= i <= Zlength l1 + Zlength l2 ->
  upd_Znth i (l1 ++ l2) v = l1 ++ upd_Znth (i-Zlength l1) l2 v.

Lemma upd_Znth0 {A} (l:list A) v:
upd_Znth 0 l v = v :: sublist 1 (Zlength l) l.

Lemma sublist_upd_Znth_l: forall {A} (l: list A) i lo hi v,
  0 <= lo <= hi ->
  hi <= i < Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_r: forall {A} (l: list A) i lo hi v,
  0 <= i < lo ->
  lo <= hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_lr: forall {A} (l: list A) i lo hi v,
  0 <= lo <= i->
  i < hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = upd_Znth (i - lo) (sublist lo hi l) v.

Hint Rewrite @Znth_list_repeat_inrange : sublist.
Hint Rewrite @Zlength_cons @Zlength_nil: sublist.
Hint Rewrite @list_repeat_0: sublist.
Hint Rewrite <- @app_nil_end : sublist.
Hint Rewrite @Zlength_app: sublist.
Hint Rewrite @Zlength_map: sublist.
Hint Rewrite @Zlength_list_repeat using list_solve: sublist.
Hint Rewrite Z.sub_0_r Z.add_0_l Z.add_0_r : sublist.
Hint Rewrite @Zlength_sublist using list_solve: sublist.
Hint Rewrite Z.max_r Z.max_l using omega : sublist.
Hint Rewrite Z.min_r Z.min_l using omega : sublist.
Hint Rewrite Z.add_simpl_r Z.sub_add Z.sub_diag : sublist.
Hint Rewrite @sublist_sublist using list_solve : sublist.
Hint Rewrite @sublist_app1 using list_solve : sublist.
Hint Rewrite @sublist_app2 using list_solve : sublist.
Hint Rewrite @sublist_list_repeat  using list_solve : sublist.
Hint Rewrite @sublist_same using list_solve : sublist.
Hint Rewrite Z.add_simpl_l : sublist.
Hint Rewrite Z.add_add_simpl_l_l Z.add_add_simpl_l_r
     Z.add_add_simpl_r_l Z.add_add_simpl_r_r : sublist.
Hint Rewrite Z.add_0_r : sublist.
Hint Rewrite @app_Znth1 using list_solve : sublist.
Hint Rewrite @app_Znth2 using list_solve : sublist.
Hint Rewrite @Znth_sublist using list_solve : sublist.
Hint Rewrite @upd_Znth_Zlength using list_solve : sublist.

Hint Rewrite @sublist_nil : sublist.

Lemma list_repeat_app':
 forall {A: Type} a b (x:A), 
    0 <= a -> 0 <= b ->
    list_repeat (Z.to_nat a) x ++ list_repeat (Z.to_nat b) x = list_repeat (Z.to_nat (a+b)) x.

Lemma Znth_overflow:
  forall {A}{d: Inhabitant A} i (al: list A), i >= Zlength al -> Znth i al = d.

Lemma Znth_underflow:
  forall {A}{d: Inhabitant A} i (al: list A),  i < 0 -> Znth i al = d.

Lemma Znth_outofbounds:
  forall {A}{d: Inhabitant A} i (al: list A),  (i < 0 \/ i >= Zlength al) -> Znth i al = d.

Lemma sublist_one:
  forall {A}{d: Inhabitant A} lo hi (al: list A),
    0 <= lo -> hi <= Zlength al ->
    lo+1=hi -> sublist lo hi al = Znth lo al :: nil.

Lemma Forall_app :
forall {A} P (l1 l2 :list A),
Forall P (l1 ++ l2) <->
Forall P l1 /\ Forall P l2.

Lemma Forall_firstn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (firstn n l).

Lemma Forall_skipn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (skipn n l).

Lemma Forall_map:
  forall {A B} (f: B -> Prop) (g: A -> B) al,
   Forall f (map g al) <-> Forall (Basics.compose f g) al.

Lemma Forall_sublist:
  forall {A} (f: A -> Prop) lo hi al,
   Forall f al -> Forall f (sublist lo hi al).

Hint Rewrite @upd_Znth_app1 using list_solve : sublist.
Hint Rewrite @upd_Znth_app2 using list_solve : sublist.

Lemma map_list_repeat: forall {A B} (f: A->B) n (x:A), map f (list_repeat n x) = list_repeat n (f x).
Hint Rewrite @map_list_repeat : sublist.

Lemma Zlength_sublist_correct: forall {A} (l: list A) (lo hi: Z),
  0 <= lo <= hi ->
  hi <= Zlength l ->
  Zlength (sublist lo hi l) = hi - lo.

Lemma Zlength_sublist_incorrect: forall {A} (l: list A) (lo hi: Z),
  0 <= lo < hi ->
  hi > Zlength l ->
  Zlength (sublist lo hi l) < hi - lo.

Lemma nth_Znth {A} {d: Inhabitant A}:
forall n (xs:list A), 0 <= n < Zlength xs -> (nth (Z.to_nat n) xs d) = (Znth n xs). *)



Local Open Scope logic.



Section CENV.



Context {cs: compspecs}.



Lemma struct_Prop_cons2:

  forall it it' m (A: ident*type -> Type)

   (P: forall it, A it -> Prop)

   (v: compact_prod (map A (it::it'::m))),

 struct_Prop (it :: it' :: m) P v =

    (P _ (fst v) /\ struct_Prop (it'::m) P (snd v)).

Proof.

intros.

destruct v. destruct it, it'.

reflexivity.

Qed.



Lemma struct_Prop_ext_derives: forall m {A0 A1} (P0: forall it, A0 it -> Prop) (P1: forall it, A1 it -> Prop) v0 v1,

  members_no_replicate m = true ->

  (forall i d0 d1, in_members i m ->

     P0 _ (proj_struct i m v0 d0) -> P1 _ (proj_struct i m v1 d1)) ->

  struct_Prop m P0 v0 -> struct_Prop m P1 v1.

Proof.



  intros. revert H1.

  destruct m as [| (i0, t0) m]; [simpl; auto |].

  revert i0 t0 v0 v1 H H0; induction m as [| (i1, t1) m]; intros.

  + specialize (H0 i0).

    simpl in H0.

    unfold field_type, Ctypes.field_type in H0.

    simpl in H0.

    destruct (ident_eq i0 i0); [ | congruence].

    specialize (H0 v0 v1).

    spec H0; [left; reflexivity |].

    destruct (type_eq t0 t0); [ | congruence].

    unfold eq_rect_r in H0; rewrite <- !eq_rect_eq in H0.

    simpl. auto.

  +

    revert H1.

    change (struct_Prop ((i0, t0) :: (i1, t1) :: m) P0 v0) with

      (P0 (i0, t0) (fst v0) /\ struct_Prop ((i1, t1) :: m) P0 (snd v0)).

    change (struct_Prop ((i0, t0) :: (i1, t1) :: m) P1 v1) with

      (P1 (i0, t0) (fst v1) /\ struct_Prop ((i1, t1) :: m) P1 (snd v1)).

     intro.

      rewrite fieldlist.members_no_replicate_ind in H.

      destruct H as [H H'].

       specialize (IHm i1 t1 (snd v0) (snd v1) H').

      split.

    - destruct H1 as [H1 _]; revert H1.

      specialize (H0 i0).

      unfold proj_struct in H0.

      revert H0; unfold field_type; simpl.

      destruct (ident_eq i0 i0); [ | congruence].

    destruct (type_eq t0 t0); [ | congruence].

      unfold eq_rect_r; rewrite <- !eq_rect_eq.

      intros. apply (H0 (fst v0) (fst v1)); auto.

      hnf. left; reflexivity.

    -  destruct H1 as [_ H1]; revert H1.

      apply IHm; clear IHm.

      assert (i0<>i1) by (contradict H; left; auto).

      intros.

      specialize (H0 i).

      assert (i<>i0). contradict H1. subst i0. contradiction.

      clear H H'.

      assert (field_type i ((i0, t0) :: (i1, t1) :: m) = field_type i ((i1,t1)::m))

         by (unfold field_type; simpl; rewrite if_false; auto).

      unfold proj_struct in *.

      rewrite H in H0.

      specialize (H0 d0 d1).

      spec H0; [unfold in_members; right; auto | ].

      assert (proj_compact_prod (i, field_type i ((i1, t1) :: m))

                  ((i0, t0) :: (i1, t1) :: m) v0 d0 member_dec =

                proj_compact_prod (i, field_type i ((i1, t1) :: m)) ((i1, t1) :: m)

                 (snd v0) d0 member_dec).

         clear - H1 H4.

         unfold proj_compact_prod. unfold list_rect; cbv beta iota.

         destruct (member_dec (i, field_type i ((i1, t1) :: m)) (i0,t0)); [congruence | ].

         reflexivity.

      rewrite H5 in H0; clear H5.

      assert (proj_compact_prod (i, field_type i ((i1, t1) :: m))

                  ((i0, t0) :: (i1, t1) :: m) v1 d1 member_dec =

                proj_compact_prod (i, field_type i ((i1, t1) :: m)) ((i1, t1) :: m)

                 (snd v1) d1 member_dec).

         clear - H1 H4.

         unfold proj_compact_prod. unfold list_rect; cbv beta iota.

         destruct (member_dec (i, field_type i ((i1, t1) :: m)) (i0,t0)); [congruence | ].

         reflexivity.

      rewrite H5 in H0; clear H5.

     apply H0; auto.

Qed.



Lemma struct_Prop_ext: forall m {A0 A1} (P0: forall it, A0 it -> Prop) (P1: forall it, A1 it -> Prop) v0 v1,

  members_no_replicate m = true ->

  (forall i d0 d1, in_members i m ->

     P0 _ (proj_struct i m v0 d0) = P1 _ (proj_struct i m v1 d1)) ->

  struct_Prop m P0 v0 = struct_Prop m P1 v1.

Proof.

  intros.

  apply prop_ext; split; eapply struct_Prop_ext_derives; eauto; intros; revert H2;

  erewrite H0 by auto; eauto.

Qed.



Definition field_at (sh: Share.t) (t: type) (gfs: list gfield) (v: reptype (nested_field_type t gfs)) (p: val): mpred :=

 !! (field_compatible t gfs p) &&

 at_offset (data_at_rec sh (nested_field_type t gfs) v) (nested_field_offset t gfs) p.

Arguments field_at sh t gfs v p : simpl never.



Definition field_at_ (sh: Share.t) (t: type) (gfs: list gfield) (p: val): mpred :=

  field_at sh t gfs (default_val (nested_field_type t gfs)) p.



Arguments field_at_ sh t gfs p : simpl never.



Definition data_at (sh: Share.t) (t: type) (v: reptype t) := field_at sh t nil v.



Definition data_at_ (sh: Share.t) (t: type) := field_at_ sh t nil.



Definition nested_reptype_structlist t gfs (m: members) :=

  compact_prod (map (fun it => reptype (nested_field_type t (StructField (fst it) :: gfs))) m).



Definition nested_reptype_unionlist t gfs (m: members) :=

  compact_sum (map (fun it => reptype (nested_field_type t (UnionField (fst it) :: gfs))) m).



Lemma nested_reptype_structlist_lemma: forall t gfs id a,

  nested_field_type t gfs = Tstruct id a ->

  reptype (nested_field_type t gfs) = nested_reptype_structlist t gfs (co_members (get_co id)).

Proof.

  intros.

  rewrite H, reptype_eq.

  unfold reptype_structlist, nested_reptype_structlist.

  f_equal.

  apply map_members_ext; [apply get_co_members_no_replicate |].

  intros.

  rewrite nested_field_type_ind, H.

  simpl.

  auto.

Defined.



Lemma nested_reptype_unionlist_lemma: forall t gfs id a,

  nested_field_type t gfs = Tunion id a ->

  reptype (nested_field_type t gfs) = nested_reptype_unionlist t gfs (co_members (get_co id)).

Proof.

  intros.

  rewrite H, reptype_eq.

  unfold reptype_unionlist, nested_reptype_unionlist.

  f_equal.

  apply map_members_ext; [apply get_co_members_no_replicate |].

  intros.

  rewrite nested_field_type_ind, H.

  simpl.

  auto.

Defined.



Definition nested_sfieldlist_at sh t gfs m (v: nested_reptype_structlist t gfs m) p: mpred :=

  match m with

  | nil => (!! field_compatible t gfs p) && emp

  | _ => struct_pred m (fun it v p =>

           withspacer sh

            (nested_field_offset t gfs +

              (field_offset cenv_cs (fst it) m + sizeof (field_type (fst it) m)))

            (nested_field_offset t gfs +

              field_offset_next cenv_cs (fst it) m (sizeof (nested_field_type t gfs)))

            (field_at sh t (StructField (fst it) :: gfs) v) p) v p

  end.



Definition nested_ufieldlist_at sh t gfs m (v: nested_reptype_unionlist t gfs m) (p: val): mpred :=

  match m with

  | nil => (!! field_compatible t gfs p) && emp

  | _ => union_pred m (fun it v p =>

           withspacer sh

            (nested_field_offset t gfs + sizeof (field_type (fst it) m))

            (nested_field_offset t gfs + sizeof (nested_field_type t gfs))

            (field_at sh t (UnionField (fst it) :: gfs) v) p) v p

  end.



Definition array_at (sh: Share.t) (t: type) (gfs: list gfield) (lo hi: Z)

  (v: list (reptype (nested_field_type t (ArraySubsc 0 :: gfs)))) (p: val) : mpred :=

  !! (field_compatible0 t (ArraySubsc lo :: gfs) p /\

      field_compatible0 t (ArraySubsc hi :: gfs) p) &&

  array_pred lo hi

    (fun i v => at_offset (data_at_rec sh (nested_field_type t (ArraySubsc 0 :: gfs)) v)

       (nested_field_offset t (ArraySubsc i :: gfs))) v p.



Definition array_at_ (sh: Share.t) (t: type) (gfs: list gfield) (lo hi: Z) : val -> mpred :=

 array_at sh t gfs lo hi (list_repeat (Z.to_nat (hi-lo)) (default_val _)).



Lemma field_at_local_facts:

  forall sh t path v c,

     field_at sh t path v c |-- !! (field_compatible t path c /\ value_fits (nested_field_type t path) v).

Proof.

  intros.

  unfold field_at.

  rewrite prop_and; apply andp_derives; auto.

  unfold at_offset.

  apply data_at_rec_value_fits.

Qed.



Lemma field_at_compatible':

 forall sh t path v c,

     field_at sh t path v c =

     !! field_compatible t path c && field_at sh t path v c.

Proof.

intros.

apply pred_ext.

apply andp_right; auto.

eapply derives_trans; [apply field_at_local_facts | normalize].

normalize.

Qed.



Lemma field_at__local_facts: forall sh t gfs p,

  field_at_ sh t gfs p |-- !! field_compatible t gfs p.

Proof.

  intros.

  unfold field_at_, field_at.

 normalize.

Qed.



Lemma data_at_local_facts:

   forall sh t v p, data_at sh t v p |-- !! (field_compatible t nil p /\ value_fits t v).

Proof. intros. apply field_at_local_facts. Qed.



Lemma data_at__local_facts: forall sh t p, data_at_ sh t p |-- !! field_compatible t nil p.

Proof. intros.

  apply field_at__local_facts.

Qed.



Lemma array_at_local_facts: forall sh t gfs lo hi v p,

  array_at sh t gfs lo hi v p |--

    !! (field_compatible0 t (ArraySubsc lo :: gfs) p

        /\ field_compatible0 t (ArraySubsc hi :: gfs) p

        /\ Zlength v = hi - lo

        /\ Forall (value_fits (nested_field_type t (ArraySubsc 0 :: gfs))) v).

Proof.

  intros.

  unfold array_at.

  rewrite !prop_and.

  rewrite <- andp_assoc.

  apply andp_derives; auto.

  eapply derives_trans; [apply array_pred_local_facts |].

  + intros.

    unfold at_offset.

    instantiate (1 := fun x => value_fits _ x).

    apply data_at_rec_value_fits.

 + normalize.

Qed.



Lemma array_at__local_facts: forall sh t gfs lo hi p,

  array_at_ sh t gfs lo hi p |--

    !! (field_compatible0 t (ArraySubsc lo :: gfs) p

        /\ field_compatible0 t (ArraySubsc hi :: gfs) p).

Proof.

  intros.

  unfold array_at_.

  eapply derives_trans; [apply array_at_local_facts; eauto | ].

  apply prop_derives; intuition.

Qed.



Lemma field_at_isptr: forall sh t gfs v p,

  field_at sh t gfs v p = (!! isptr p) && field_at sh t gfs v p.

Proof. intros. eapply local_facts_isptr; [apply field_at_local_facts | intros [? ?]; auto]. Qed.



Lemma field_at_offset_zero: forall sh t gfs v p,

  field_at sh t gfs v p = field_at sh t gfs v (offset_val 0 p).

Proof. intros. apply local_facts_offset_zero.

 intros. rewrite field_at_isptr; normalize.

Qed.



Lemma field_at__isptr: forall sh t gfs p,

  field_at_ sh t gfs p = (!! isptr p) && field_at_ sh t gfs p.

Proof. intros.

 intros. eapply local_facts_isptr; [apply field_at__local_facts | intros [? ?]; auto].

Qed.



Lemma field_at__offset_zero: forall sh t gfs p,

  field_at_ sh t gfs p = field_at_ sh t gfs (offset_val 0 p).

Proof. intros. apply local_facts_offset_zero.

 intros. rewrite field_at__isptr; normalize.

Qed.



Lemma data_at_isptr: forall sh t v p, data_at sh t v p = !!(isptr p) && data_at sh t v p.

Proof. intros. eapply local_facts_isptr; [apply data_at_local_facts | intros [? ?]; auto].

Qed.



Lemma data_at_offset_zero: forall sh t v p, data_at sh t v p = data_at sh t v (offset_val 0 p).

Proof. intros. rewrite <- local_facts_offset_zero. reflexivity.

    intros; rewrite data_at_isptr; normalize.

Qed.



Lemma data_at__isptr: forall sh t p, data_at_ sh t p = !!(isptr p) && data_at_ sh t p.

Proof. intros. eapply local_facts_isptr; [apply data_at__local_facts | intros [? ?]; auto].

Qed.



Lemma data_at__offset_zero: forall sh t p, data_at_ sh t p = data_at_ sh t (offset_val 0 p).

Proof. intros. apply field_at__offset_zero. Qed.



Lemma array_at_ext_derives: forall sh t gfs lo hi v0 v1 p,

  Zlength v0 = Zlength v1 ->

  (forall i u0 u1,

     lo <= i < hi ->

     JMeq u0 (Znth (i-lo) v0) ->

     JMeq u1 (Znth (i-lo) v1) ->

     field_at sh t (ArraySubsc i :: gfs) u0 p |--

     field_at sh t (ArraySubsc i :: gfs) u1 p) ->

  array_at sh t gfs lo hi v0 p |-- array_at sh t gfs lo hi v1 p.

Proof.

  intros until p. intro ZL; intros.

  unfold array_at, field_at.

  normalize.

  eapply array_pred_ext_derives.

  1: intro; omega.

  intros.

  specialize (H i).

  clear ZL.

  revert v0 v1 H.

  unfold field_at.

  rewrite nested_field_type_ArraySubsc with (i0 := i).

  intros.

  specialize (H (Znth (i - lo) v0) (Znth (i - lo) v1)).

  do 3 (spec H; [auto |]).

  rewrite !prop_true_andp in H by (apply (field_compatible_range _ lo hi); auto).

  auto.

Qed.



Lemma array_at_ext: forall sh t gfs lo hi v0 v1 p,

  Zlength v0 = Zlength v1 ->

  (forall i u0 u1,

     lo <= i < hi ->

     JMeq u0 (Znth (i-lo) v0) ->

     JMeq u1 (Znth (i-lo) v1) ->

     field_at sh t (ArraySubsc i :: gfs) u0 p =

     field_at sh t (ArraySubsc i :: gfs) u1 p) ->

  array_at sh t gfs lo hi v0 p = array_at sh t gfs lo hi v1 p.

Proof.

  intros.

  apply pred_ext; apply array_at_ext_derives; intros; auto.

  erewrite H0 by eauto; auto.

  erewrite <- H0 by eauto; auto.

Qed.



Lemma field_at_Tarray: forall sh t gfs t0 n a v1 v2 p,

  legal_nested_field t gfs ->

  nested_field_type t gfs = Tarray t0 n a ->

  0 <= n ->

  JMeq v1 v2 ->

  field_at sh t gfs v1 p = array_at sh t gfs 0 n v2 p.

Proof.

  intros.

  unfold field_at, array_at.

  revert v1 v2 H2;

  rewrite (nested_field_type_ind t (ArraySubsc 0 :: gfs)).

  rewrite H0; unfold gfield_type.

  intros.

  rewrite data_at_rec_eq.

  rewrite at_offset_array_pred.

  f_equal.

  + apply ND_prop_ext.

    rewrite !field_compatible0_cons, H0.

    assert (0 <= 0 <= n) by omega.

    assert (0 <= n <= n) by omega.

    tauto.

  + apply (JMeq_trans (unfold_reptype_JMeq _ v1)) in H2.

    forget (unfold_reptype v1) as v1'.

    clear v1.

    cbv iota beta in v1'.

    apply JMeq_eq in H2.

    rewrite Z.max_r by omega.

    apply array_pred_ext.

    - subst; auto.

    - intros.

      rewrite at_offset_eq.

      rewrite <- at_offset_eq2.

      rewrite !at_offset_eq.

      rewrite (nested_field_offset_ind t (ArraySubsc i :: gfs))

        by (apply legal_nested_field0_field; simpl; unfold legal_field; rewrite H0; auto).

      rewrite H0.

      f_equal.

      subst; auto.

Qed.



Lemma not_ptr_FF: forall A p, (A |-- !! isptr p) <-> (~ isptr p -> A = FF).

Proof.

  intros.

  split; intros.

  + apply pred_ext; [| apply FF_left].

    eapply derives_trans; [eauto |].

    apply prop_derives.

    auto.

  + destruct p; try solve [rewrite H by (simpl; congruence); apply FF_left].

    simpl.

    apply TT_right.

Qed.



Ltac solve_ptr_derives :=

  repeat rewrite isptr_offset_val;

  apply derives_refl.



Lemma field_at_isptr':

  forall sh t path v c, field_at sh t path v c |-- !! isptr c.

Proof.

intros.

eapply derives_trans; [apply field_at_local_facts | ].

apply prop_derives; intros [? _]; auto.

Qed.



Ltac solve_nptr p A :=

  let H := fresh "H" in

  match A with

  | (?B * ?C) % logic =>

     try solve [assert (~ isptr p -> B = FF) as H by solve_nptr p B;

                intro; rewrite H by auto ; apply FF_sepcon];

     try solve [assert (~ isptr p -> C = FF) as H by solve_nptr p C;

                intro; rewrite H by auto; apply sepcon_FF]

  | (?B && ?C) % logic =>

     try solve [assert (~ isptr p -> B = FF) as H by solve_nptr p B;

                intro; rewrite H by auto ; apply FF_andp];

     try solve [assert (~ isptr p -> C = FF) as H by solve_nptr p C;

                intro; rewrite H by auto; apply andp_FF]

  | _ => apply (proj1 (not_ptr_FF A p)); solve_ptr p A

  end

with solve_ptr p A :=

  let p0 := fresh "p" in

  match A with

  | (_ * _) % logic => apply (proj2 (not_ptr_FF A p)); solve_nptr p A

  | (_ && _) % logic => apply (proj2 (not_ptr_FF A p)); solve_nptr p A

  | (!! _ /\ _)%logic => destruct A as [_ A]; solve_ptr p A

  | (!! field_compatible _ _ ?q) => apply (derives_trans _ _ _ (prop_derives _ _ (field_compatible_isptr _ _ _))); solve_ptr_derives

  | (!! field_compatible0 _ _ ?q) => apply (derives_trans _ _ _ (prop_derives _ _ (field_compatible0_isptr _ _ _))); solve_ptr_derives

  | (memory_block _ _ ?q) => apply (derives_trans _ _ _ (memory_block_local_facts _ _ _)); solve_ptr_derives

  | (withspacer _ _ _ ?P p) => apply withspacer_preserve_local_facts;

                                     intro p0; solve_ptr p0 (P p0)

  | (at_offset ?P _ ?q) => apply (derives_trans _ (!! isptr q));

                           [apply at_offset_preserve_local_facts; intro p0; solve_ptr p0 (P p0) |

                            solve_ptr_derives]

  | (field_at _ _ _ _ p) => apply field_at_isptr'

  end.



Ltac destruct_ptr p :=

  let b := fresh "b" in

  let ofs := fresh "OFS" in

  match goal with

  | |- (@eq mpred) ?A ?B =>

       let H := fresh "H" in

       let H0 := fresh "H" in

       assert (~ isptr p -> A = FF) as H by solve_nptr p A;

       assert (~ isptr p -> B = FF) as H0 by solve_nptr p B;

       destruct p as [| | | | | b ofs]; try (rewrite H, H0 by (simpl; congruence); reflexivity);

       clear H H0;

       inv_int ofs

  | |- (?A |-- _) =>

       let H := fresh "H" in

       assert (~ isptr p -> A = FF) as H by solve_nptr p A;

       destruct p as [| | | | | b ofs]; try (rewrite H by (simpl; congruence); apply FF_left);

       clear H;

       inv_int ofs

  end.



Lemma field_at_Tstruct: forall sh t gfs id a v1 v2 p,

  nested_field_type t gfs = Tstruct id a ->

  JMeq v1 v2 ->

  field_at sh t gfs v1 p = nested_sfieldlist_at sh t gfs (co_members (get_co id)) v2 p.

Proof.

  intros.

  unfold field_at, nested_sfieldlist_at.

  revert v1 H0; rewrite H; intros.

  rewrite data_at_rec_eq.

  rewrite at_offset_struct_pred.

  rewrite andp_struct_pred by apply corable_prop.

  generalize (co_members (get_co id)) at 1 10; intro m; destruct m; [auto |].

  apply struct_pred_ext; [apply get_co_members_no_replicate |].



  intros.

  destruct_ptr p.

  unfold field_at, fst, snd.

  autorewrite with at_offset_db.

  unfold offset_val.

  solve_mod_modulus.

  normalize.

  destruct (legal_nested_field_dec t (StructField i :: gfs)).

  2:{

    replace (!!field_compatible t (StructField i :: gfs) (Vptr b (Ptrofs.repr ofs)) : mpred) with (FF: mpred)

      by (apply ND_prop_ext; unfold field_compatible; tauto; apply ND_prop_ext; tauto).

    simpl in n.

    rewrite H in n.

    simpl in n.

    replace (!!field_compatible t gfs (Vptr b (Ptrofs.repr ofs)) : mpred) with (FF: mpred)

      by (apply ND_prop_ext; unfold field_compatible; tauto; apply ND_prop_ext; tauto).

    normalize.

  }

  rewrite nested_field_offset_ind with (gfs0 := StructField i :: gfs) by auto.

  unfold gfield_offset; rewrite H.

  f_equal; [| f_equal].

  + apply ND_prop_ext.

    rewrite field_compatible_cons, H; tauto.

  + rewrite sizeof_Tstruct.

    f_equal; [| f_equal; f_equal]; omega.

  + rewrite Z.add_assoc.

    erewrite data_at_rec_type_changable; [reflexivity | |].

    - simpl.

      rewrite nested_field_type_ind.

      simpl; rewrite H.

      auto.

    - apply (proj_compact_prod_JMeq _ (i, field_type i _) (co_members (get_co id)) _ _ (unfold_reptype v1) v2); auto.

      * intros.

        rewrite nested_field_type_ind, H.

        unfold gfield_type.

        rewrite In_field_type; auto.

        apply get_co_members_no_replicate.

      * apply in_members_field_type; auto.

      * clear - H0.

        eapply JMeq_trans; [apply (unfold_reptype_JMeq _ v1) | auto].

Qed.



Lemma field_at_Tunion: forall sh t gfs id a v1 v2 p,

  nested_field_type t gfs = Tunion id a ->

  JMeq v1 v2 ->

  field_at sh t gfs v1 p = nested_ufieldlist_at sh t gfs (co_members (get_co id)) v2 p.

Proof.

  intros.

  unfold field_at, nested_ufieldlist_at.

  revert v1 H0; rewrite H; intros.

  rewrite data_at_rec_eq.

  rewrite at_offset_union_pred.

  rewrite andp_union_pred by apply corable_prop.

  generalize (eq_refl (co_members (get_co id))).

  generalize (co_members (get_co id)) at 2 3 9; intro m; destruct m; [auto |].

  intro HH; assert (co_members (get_co id) <> nil) by congruence; clear HH.



  assert (

   forall i : ident,

   in_members i (co_members (get_co id)) ->

   reptype (snd (i, field_type i (co_members (get_co id)))) =

   reptype

     (nested_field_type t

        (UnionField (fst (i, field_type i (co_members (get_co id)))) :: gfs))).

  {

    clear - H.

    intros.

    unfold fst, snd.

    rewrite nested_field_type_ind, H.

    reflexivity.

  }

  apply union_pred_ext; [apply get_co_members_no_replicate | |].

  {

    apply compact_sum_inj_JMeq; auto.

    + intros.

      rewrite nested_field_type_ind, H.

      reflexivity.

    + eapply JMeq_trans; [apply (unfold_reptype_JMeq _ v1) | auto].

  }

  intros.

  destruct_ptr p.

  assert (in_members i (co_members (get_co id))).

  {

    change i with (fst (i, field_type i (co_members (get_co id)))).

    apply in_map with (f := fst).

    eapply compact_sum_inj_in; eauto.

  }

  unfold field_at, fst, snd.

  autorewrite with at_offset_db.

  unfold offset_val.

  solve_mod_modulus.

  normalize.

  destruct (legal_nested_field_dec t (UnionField i :: gfs)).

  2:{

    replace (!!field_compatible t (UnionField i :: gfs) (Vptr b (Ptrofs.repr ofs)) : mpred) with (FF: mpred)

      by (apply ND_prop_ext; unfold field_compatible; tauto).

    simpl in n.

    rewrite H in n.

    simpl in n.

    replace (!!field_compatible t gfs (Vptr b (Ptrofs.repr ofs)) : mpred) with (FF: mpred)

      by (apply ND_prop_ext; unfold field_compatible; tauto).

    normalize.

  }

  rewrite nested_field_offset_ind with (gfs0 := UnionField i :: gfs) by auto.

  unfold gfield_offset; rewrite H.

  f_equal; [| f_equal].

  + apply ND_prop_ext.

    rewrite field_compatible_cons, H; tauto.

  + rewrite sizeof_Tunion.

    f_equal; [| f_equal; f_equal]; omega.

  + rewrite Z.add_0_r.

    erewrite data_at_rec_type_changable; [reflexivity | |].

    - simpl.

      rewrite nested_field_type_ind.

      simpl; rewrite H.

      auto.

    - unfold proj_union.

      apply (proj_compact_sum_JMeq _ (i, field_type i (co_members (get_co id))) (co_members (get_co id)) d0 d1 (unfold_reptype v1) v2); auto.

      * intros (i0, t0) ?.

        rewrite nested_field_type_ind, H.

        simpl.

        auto.

      * eapply JMeq_trans; [apply (unfold_reptype_JMeq _ v1) | auto].

Qed.



Lemma array_at_len_0: forall sh t gfs i p,

  array_at sh t gfs i i nil p = !! (field_compatible0 t (ArraySubsc i :: gfs) p) && emp.

Proof.

  intros.

  unfold array_at.

  rewrite array_pred_len_0 by omega.

  apply pred_ext; normalize.

Qed.



Lemma array_at_len_1: forall sh t gfs i v v' p,

  JMeq v v' ->

  array_at sh t gfs i (i + 1) (v :: nil) p = field_at sh t (ArraySubsc i :: gfs) v' p.

Proof.

  intros.

  unfold array_at, field_at.

  rewrite array_pred_len_1 by omega.

  revert v' H.

  rewrite nested_field_type_ArraySubsc with (i0 := i).

  intros.

  apply JMeq_eq in H; rewrite H.

  f_equal.

  apply ND_prop_ext.

  rewrite field_compatible_field_compatible0'.

  reflexivity.

Qed.



Lemma split2_array_at: forall sh t gfs lo mid hi v p,

  lo <= mid <= hi ->

  Zlength v = hi - lo ->

  array_at sh t gfs lo hi v p =

  array_at sh t gfs lo mid (sublist 0 (mid-lo) v) p *

  array_at sh t gfs mid hi (sublist (mid-lo) (Zlength v) v) p.

Proof.

  intros.

  unfold array_at.

  normalize.

  apply andp_prop_ext.

  + split; [| tauto].

    intros [? ?].

    assert (field_compatible0 t (gfs SUB mid) p) by (apply (field_compatible0_range _ lo hi); auto).

    tauto.

  + intros [? ?].

    rewrite split_array_pred with (mid0 := mid) by auto.

    rewrite H0; auto.

Qed.



Lemma split3seg_array_at: forall sh t gfs lo ml mr hi v p,

  lo <= ml ->

  ml <= mr ->

  mr <= hi ->

  Zlength v = hi-lo ->

  array_at sh t gfs lo hi v p =

    array_at sh t gfs lo ml (sublist 0 (ml-lo) v) p*

    array_at sh t gfs ml mr (sublist (ml-lo) (mr-lo) v) p *

    array_at sh t gfs mr hi (sublist (mr-lo) (hi-lo) v) p.

Proof.

  intros.

  rewrite split2_array_at with (lo := lo) (mid := ml) (hi := hi) by omega.

  rewrite sepcon_assoc; f_equal.

  assert (Zlength (sublist (ml - lo) (hi - lo) v) = hi - ml).

  {

    replace (hi - ml) with (hi - lo - (ml - lo)) by omega.

    apply Zlength_sublist; omega.

  }

  rewrite H2.

  rewrite split2_array_at with (lo := ml) (mid := mr) (hi := hi) by omega.

  f_equal.

  rewrite sublist_sublist; try omega. f_equal.  f_equal; omega.

  rewrite Zlength_sublist by omega.

  rewrite sublist_sublist; try omega. f_equal.  f_equal; omega.

Qed.



Lemma split3_array_at: forall sh t gfs lo mid hi v v0 p,

  lo <= mid < hi ->

  Zlength v = hi-lo ->

  JMeq v0 (Znth (mid-lo) v) ->

  array_at sh t gfs lo hi v p =

    array_at sh t gfs lo mid (sublist 0 (mid-lo) v) p *

    field_at sh t (ArraySubsc mid :: gfs) v0 p *

    array_at sh t gfs (mid + 1) hi (sublist (mid+1-lo) (hi-lo) v) p.

Proof.

  intros.

  rename H0 into e; rename H1 into H0.

  rewrite split3seg_array_at with (ml := mid) (mr := mid + 1) by omega.

  f_equal.

  f_equal.

  replace (mid + 1 - lo) with (mid - lo + 1) by omega.

  rewrite sublist_len_1 by omega.

  rewrite array_at_len_1 with (v' :=v0); [auto |].

  apply JMeq_sym; auto.

Qed.



Lemma field_at_data_at: forall sh t gfs v (p: val),

  field_at sh t gfs v p =

  data_at sh (nested_field_type t gfs) v (field_address t gfs p).

Proof.

  intros.

  unfold data_at, field_at.

  rewrite (nested_field_offset_ind (nested_field_type t gfs) nil) by (simpl; tauto).

  unfold field_address.

  if_tac.

  + unfold at_offset; normalize.

    rewrite prop_true_andp; [auto |].

    destruct p; try (destruct H; contradiction).

    generalize (field_compatible_nested_field t gfs (Vptr b i));

    unfold at_offset; solve_mod_modulus; intros. auto.

  + apply pred_ext; normalize. destruct H0; contradiction.

Qed.



Lemma field_at_data_at' : forall sh t gfs v p, field_at sh t gfs v p =

  !!field_compatible t gfs p &&

  data_at sh (nested_field_type t gfs) v (offset_val (nested_field_offset t gfs) p).

Proof.

  intros.

  rewrite field_at_data_at.

  unfold field_address.

  if_tac.

  - rewrite prop_true_andp; auto.

  - rewrite prop_false_andp by auto.

    rewrite data_at_isptr, prop_false_andp; auto.

Qed.



Lemma field_at__data_at_: forall sh t gfs p,

  field_at_ sh t gfs p =

  data_at_ sh (nested_field_type t gfs) (field_address t gfs p).

Proof.

  intros.

  unfold data_at_, field_at_. apply field_at_data_at.

Qed.



Lemma lifted_field_at_data_at: forall sh t gfs v p,

  `(field_at sh t gfs) v p =

  `(data_at sh (nested_field_type t gfs)) v (`(field_address t gfs) p).

Proof.

  intros.

  extensionality rho.

  unfold liftx, lift; simpl.

  apply field_at_data_at.

Qed.



Lemma lifted_field_at__data_at_: forall sh t gfs p,

  `(field_at_ sh t gfs) p =

  `(data_at_ sh (nested_field_type t gfs)) (`(field_address t gfs) p).

Proof.

  intros.

  extensionality rho.

  unfold liftx, lift; simpl.

  apply field_at__data_at_.

Qed.



Lemma value_fits_JMeq:

  forall t t' v v',

   t=t' -> JMeq v v' -> value_fits t v -> value_fits t' v'.

Proof.

intros. subst. apply JMeq_eq in H0. subst.

auto.

Qed.



Lemma array_at_data_at: forall sh t gfs lo hi v p,

  lo <= hi ->

  array_at sh t gfs lo hi v p =

  (!! field_compatible0 t (ArraySubsc lo :: gfs) p) &&

  (!! field_compatible0 t (ArraySubsc hi :: gfs) p) &&

  at_offset (data_at sh (nested_field_array_type t gfs lo hi) v)

               (nested_field_offset t (ArraySubsc lo :: gfs)) p.

Proof.

  intros.

  unfold array_at.

  rewrite at_offset_eq.

  unfold data_at, field_at.

  change (nested_field_type (nested_field_array_type t gfs lo hi) nil)

    with (Tarray (nested_field_type t (gfs SUB 0))

           (hi - lo) (no_alignas_attr (attr_of_type (nested_field_type t gfs)))).

  rewrite data_at_rec_eq.

  rewrite <- at_offset_eq.

  normalize.

  apply andp_prop_ext.

  f_equal.

  + pose proof field_compatible0_nested_field_array t gfs lo hi p.

    tauto.

  + intros [? ?].

    rewrite at_offset_eq, <- at_offset_eq2.

    rewrite at_offset_array_pred.

    rewrite Z.max_r by omega.

    eapply array_pred_shift; [reflexivity | omega |].

    intros.

    rewrite at_offset_eq at 1.

    rewrite at_offset_eq, <- at_offset_eq2, at_offset_eq.

    f_equal.

    f_equal.

    f_equal.

    rewrite nested_field_offset_ind with (gfs0 := nil) by (apply (field_compatible0_nested_field_array t gfs lo hi p); auto).

    assert (field_compatible0 t (gfs SUB i') p)

      by (apply (field_compatible0_range _ lo hi); auto; omega).

    rewrite nested_field_offset_ind with (gfs0 := ArraySubsc i' :: _) by auto.

    rewrite nested_field_offset_ind with (gfs0 := ArraySubsc lo :: _) by auto.

    rewrite nested_field_type_ind with (gfs0 := ArraySubsc 0 :: _).

    rewrite field_compatible0_cons in H4.

    destruct (nested_field_type t gfs); try tauto.

    unfold gfield_offset, gfield_type.

    assert (sizeof t0 * i' = sizeof t0 * lo + sizeof t0 * i)%Z by (rewrite Zred_factor4; f_equal; omega).

    omega.

Qed.



Lemma array_at_data_at':

forall sh t gfs lo hi v p,

  lo <= hi ->

  field_compatible0 t (ArraySubsc lo :: gfs) p ->

  field_compatible0 t (ArraySubsc hi :: gfs) p ->

  array_at sh t gfs lo hi v p =

  data_at sh (nested_field_array_type t gfs lo hi) v

               (field_address0 t (ArraySubsc lo::gfs) p).

Proof.

  intros.

  rewrite array_at_data_at by auto.

  rewrite !prop_true_andp by auto.

  unfold at_offset.

  f_equal.

  unfold field_address0.

  rewrite if_true; auto.

Qed.



Lemma array_at_data_at'':

forall sh t gfs lo hi v p,

  lo <= hi ->

  field_compatible0 t (ArraySubsc hi :: gfs) p ->

  array_at sh t gfs lo hi v p =

  data_at sh (nested_field_array_type t gfs lo hi) v

               (field_address0 t (ArraySubsc lo::gfs) p).

Proof.

  intros.

  rewrite array_at_data_at by auto.

  unfold at_offset.

  unfold field_address0.

  if_tac.

  + rewrite !prop_true_andp by auto.

    auto.

  + apply pred_ext.

    - normalize.

    - rewrite data_at_isptr.

      normalize.

Qed.



Lemma array_at_data_at''':

  forall sh t gfs lo hi v p t0 n a,

  nested_field_type t gfs = Tarray t0 n a ->

  lo <= hi <= n ->

  array_at sh t gfs lo hi v p =

  data_at sh (nested_field_array_type t gfs lo hi) v

               (field_address0 t (ArraySubsc lo::gfs) p).

Proof.

  intros.

  destruct H0.

  rewrite array_at_data_at by auto.

  unfold at_offset.

  unfold field_address0.

  if_tac.

  + assert (field_compatible0 t (gfs SUB hi) p).

    - rewrite field_compatible0_cons in *.

      rewrite H in *.

      destruct H2 as [[? ?] ?].

      split; [split |]; auto.

      omega.

    - rewrite !prop_true_andp by auto.

      auto.

  + apply pred_ext.

    - normalize.

    - rewrite data_at_isptr.

      normalize.

Qed.

  

Lemma split3seg_array_at': forall sh t gfs lo ml mr hi v p,

  lo <= ml ->

  ml <= mr ->

  mr <= hi ->

  Zlength v = hi-lo ->

  array_at sh t gfs lo hi v p =

    array_at sh t gfs lo ml (sublist 0 (ml-lo) v) p*

    data_at sh (nested_field_array_type t gfs ml mr)

        (sublist (ml-lo) (mr-lo) v)

               (field_address0 t (ArraySubsc ml::gfs) p) *

    array_at sh t gfs mr hi (sublist (mr-lo) (hi-lo) v) p.

Proof.

  intros.

  rewrite (split3seg_array_at sh t gfs lo ml mr hi); auto.

  rewrite (add_andp _ _ (array_at_local_facts sh t gfs mr hi _ _)).

  normalize.

  apply andp_prop_ext; [tauto |].

  intros [? [? _]].

  rewrite (array_at_data_at'' sh t gfs ml mr); auto.

Qed.



Lemma field_at_field_at_: forall sh t gfs v p,

  field_at sh t gfs v p |-- field_at_ sh t gfs p.

Proof.

  intros.

  destruct (field_compatible_dec t gfs p).

  + destruct_ptr p.

    unfold field_at_, field_at.

    apply andp_derives; auto.

    pose proof field_compatible_nested_field _ _ _ f.

    unfold field_compatible in H, f.

    unfold offset_val in H.

    autorewrite with at_offset_db in *.

    unfold align_compatible, size_compatible in *.

    revert H f; solve_mod_modulus; intros.

    pose proof nested_field_offset_in_range t gfs.

    spec H1; [tauto |].

    spec H1; [tauto |].

    rewrite (Z.mod_small ofs) in * by omega.

    rewrite (Z.mod_small (ofs + nested_field_offset t gfs)) in H by (pose proof sizeof_pos (nested_field_type t gfs); omega).

    apply data_at_rec_data_at_rec_; try tauto.

    omega.

  + unfold field_at_, field_at.

    normalize.

Qed.



Lemma field_at_field_at_default : forall sh t gfs v v' p,

  v' = default_val (nested_field_type t gfs) ->

  field_at sh t gfs v p |-- field_at sh t gfs v' p.

Proof.

  intros; subst.

  apply field_at_field_at_.

Qed.



Lemma field_at__memory_block: forall sh t gfs p,

  field_at_ sh t gfs p =

  memory_block sh (sizeof (nested_field_type t gfs)) (field_address t gfs p).

Proof.

  intros.

  unfold field_address.

  destruct (field_compatible_dec t gfs p).

  + unfold field_at_, field_at.

    rewrite prop_true_andp by auto.

    assert (isptr p) by auto; destruct p; try contradiction; clear H. rename i into ofs.

    inv_int ofs. rename ofs0 into ofs.

    unfold at_offset, offset_val.

    solve_mod_modulus.

    pose proof field_compatible_nested_field _ _ _ f.

    revert H f;

    unfold field_compatible;

    unfold size_compatible, align_compatible, offset_val;

    solve_mod_modulus;

    intros.

    pose proof nested_field_offset_in_range t gfs.

    spec H1; [tauto |].

    spec H1; [tauto |].

    rewrite (Z.mod_small ofs) in * by omega.

    rewrite (Z.mod_small (ofs + nested_field_offset t gfs)) in H by (pose proof sizeof_pos (nested_field_type t gfs); omega).

    rewrite memory_block_data_at_rec_default_val; try tauto; try omega.

  + unfold field_at_, field_at.

    rewrite memory_block_isptr.

    apply pred_ext; normalize.

Qed.



Lemma data_at_data_at_ : forall sh t v p,

  data_at sh t v p |-- data_at_ sh t p.

Proof.

  intros.

  apply field_at_field_at_.

Qed.



Lemma data_at_data_at_default : forall sh t v v' p,

  v' = default_val (nested_field_type t nil) ->

  data_at sh t v p |-- data_at sh t v' p.

Proof.

  intros; subst.

  apply data_at_data_at_.

Qed.



Lemma data_at__memory_block: forall sh t p,

  data_at_ sh t p =

  (!! field_compatible t nil p) && memory_block sh (sizeof t) p.

Proof.

  intros.

  unfold data_at_, data_at.

  rewrite field_at__memory_block.

  unfold field_address.

  if_tac.

  + normalize.

  + unfold field_at_, field_at.

    rewrite memory_block_isptr.

    replace (!!field_compatible t nil p : mpred) with FF by (apply ND_prop_ext; tauto).

    replace (!!isptr Vundef : mpred) with FF by reflexivity.

    normalize.

Qed.



Lemma memory_block_data_at_: forall sh t p,

  field_compatible t nil p ->

  memory_block sh (sizeof t) p = data_at_ sh t p.

Proof.

  intros.

  rewrite data_at__memory_block.

  normalize.

Qed.



Lemma data_at__memory_block_cancel:

   forall sh t p,

       data_at_ sh t p |-- memory_block sh (sizeof t) p.

Proof.

  intros.

  rewrite data_at__memory_block.

  normalize.

Qed.



Lemma data_at_memory_block:

  forall sh t v p,

     data_at sh t v p |-- memory_block sh (sizeof t) p.

Proof.

  intros.

  eapply derives_trans; [apply data_at_data_at_; reflexivity |].

  rewrite data_at__memory_block by auto.

  apply andp_left2.

  auto.

Qed.



Lemma array_at_array_at_: forall sh t gfs lo hi v p,

  array_at sh t gfs lo hi v p |-- array_at_ sh t gfs lo hi p.

Proof.

  intros.

  eapply derives_trans; [apply andp_right; [apply array_at_local_facts | apply derives_refl] | ].

 normalize.

  unfold array_at_.

  apply array_at_ext_derives.

  1: rewrite Zlength_list_repeat by (rewrite Zlength_correct in H1; omega); omega.

  intros.

  destruct (field_compatible0_dec t (ArraySubsc i :: gfs) p).

  + revert u1 H5; erewrite <- nested_field_type_ArraySubsc with (i0 := i); intros.

    apply JMeq_eq in H5; rewrite H5. unfold Znth. rewrite if_false by omega.

    rewrite nth_list_repeat.

    apply field_at_field_at_; auto.

  + unfold field_at.

    normalize.

    contradiction (field_compatible_field_compatible0 t (ArraySubsc i :: gfs) p H6).

Qed.



Lemma withspacer_field_at__Tunion: forall sh t gfs i id a p,

  nested_field_type t gfs = Tunion id a ->

  in_members i (co_members (get_co id)) ->

  withspacer sh

   (nested_field_offset t gfs +

    sizeof (field_type i (co_members (get_co id))))

   (nested_field_offset t gfs + sizeof (nested_field_type t gfs))

   (field_at_ sh t (gfs UDOT i)) p =

  memory_block sh (sizeof (nested_field_type t gfs)) (field_address t gfs p).

Proof.

  intros.

  rewrite withspacer_spacer.

  destruct (field_compatible_dec t gfs p).

  2:{

    unfold field_at_.

    assert (~ field_compatible t (gfs UDOT i) p) by (rewrite field_compatible_cons, H; tauto).

    rewrite field_at_compatible'.

    rewrite memory_block_isptr.

    unfold field_address.

    rewrite if_false by auto.

    rewrite H.

    apply pred_ext; normalize.

  }

  rewrite field_at__memory_block.

  assert (field_compatible t (gfs UDOT i) p) by (rewrite field_compatible_cons, H; split; auto).

  rewrite !field_compatible_field_address by auto.

  rewrite !(nested_field_offset_ind _ (gfs UDOT _)) by auto.

  unfold gfield_offset; rewrite H, Z.add_0_r.

  rewrite !(nested_field_type_ind _ (gfs UDOT _)), H.

  unfold gfield_type.

  assert (isptr p) by auto.

  destruct p; try tauto.

  inv_int i0.

  pose proof nested_field_offset_in_range t gfs as HH.

  spec HH; [auto |].

  spec HH; [unfold field_compatible in *; tauto |].

  rewrite spacer_sepcon_memory_block.

  + reflexivity.

  + pose proof sizeof_pos (field_type i (co_members (get_co id))); omega.

  + omega.

  + split.

    - rewrite sizeof_Tunion.

      erewrite co_consistent_sizeof by apply get_co_consistent.

      rewrite complete_legal_cosu_type_Tunion with (a0 := a)

        by (rewrite <- H; apply nested_field_type_complete_legal_cosu_type;

            unfold field_compatible in *; tauto).

      pose proof align_le (sizeof_composite cenv_cs Union (co_members (get_co id)))

           (co_alignof (get_co id)) (co_alignof_pos _).

      unfold sizeof_composite in *.

      pose proof sizeof_union_in_members _ _ H0.

      omega.

    - rewrite <- H.

      unfold field_compatible in *.

      unfold size_compatible in *.

      revert H1; solve_mod_modulus; intros.

      rewrite Zmod_small in H1 by omega.

      omega.

  + rewrite <- H.

    unfold field_compatible, size_compatible in *.

    rewrite Ptrofs.unsigned_repr in * by (unfold Ptrofs.max_unsigned; omega).

    omega.

Qed.



Lemma array_at_ramif: forall sh t gfs t0 n a lo hi i v v0 p,



  nested_field_type t gfs = Tarray t0 n a ->

  lo <= i < hi ->

  JMeq v0 (Znth (i - lo) v) ->

  array_at sh t gfs lo hi v p |-- field_at sh t (ArraySubsc i :: gfs) v0 p *

   (ALL v0: _, ALL v0': _, !! JMeq v0 v0' -->

      (field_at sh t (ArraySubsc i :: gfs) v0 p -*

        array_at sh t gfs lo hi (upd_Znth (i - lo) v v0') p)).

Proof.

  intros.

  rewrite (add_andp _ _ (array_at_local_facts _ _ _ _ _ _ _)).

  normalize.

  rewrite allp_uncurry'.

  change (ALL  st: _,

    !!JMeq (fst st) (snd st) -->

     (field_at sh t (gfs SUB i) (fst st) p -*

      array_at sh t gfs lo hi (upd_Znth (i - lo) v (snd st)) p))

  with (allp ((fun st => !!JMeq (fst st) (snd st)) -->

               ((fun st => field_at sh t (gfs SUB i) (fst st) p) -*

                 fun st => array_at sh t gfs lo hi (upd_Znth (i - lo) v (snd st)) p))).

  eapply RAMIF_Q'.solve with

    (array_at sh t gfs lo i (sublist 0 (i - lo) v) p *

     array_at sh t gfs (i + 1) hi (sublist (i + 1 - lo) (hi - lo) v) p).

  + simpl; auto.

  + erewrite (split3_array_at sh t gfs lo i hi) by (eauto; omega).

    cancel.

  + clear v0 H1.

    intros [v0 v0'].

    normalize.

    erewrite (split3_array_at sh t gfs lo i hi).

    2: auto.

    2:{

      rewrite upd_Znth_Zlength by omega.

      auto.

    }

    2:{

      rewrite upd_Znth_same by omega.

      exact H1.

    }

    rewrite sublist_upd_Znth_l with (lo0 := 0) by omega.

    rewrite sublist_upd_Znth_r with (lo0 := (i + 1 - lo)) by omega.

    unfold fst; cancel.

Qed.



Lemma nested_sfieldlist_at_ramif: forall sh t gfs id a i v p,

  let d := default_val _ in

  nested_field_type t gfs = Tstruct id a ->

  in_members i (co_members (get_co id)) ->

  nested_sfieldlist_at sh t gfs (co_members (get_co id)) v p |--

  field_at sh t (StructField i :: gfs)

    (proj_struct i (co_members (get_co id)) v d) p *

      (ALL v0: _,

         field_at sh t (StructField i :: gfs) v0 p -*

           nested_sfieldlist_at sh t gfs (co_members (get_co id))

            (upd_struct i (co_members (get_co id)) v v0) p).

Proof.

  intros.

  destruct (co_members (get_co id)) eqn:?; [inv H0 |].

  revert v d H0; rewrite <- Heqm; intros.

  unfold nested_sfieldlist_at.

  pattern (co_members (get_co id)) at 1 7; rewrite Heqm.



  match goal with

  | |- _ |-- _ * (ALL v0: _, ?A1 v0 p -* ?A2 (?A3 v0) p) =>

      change (ALL v0: _, A1 v0 p -* A2 (A3 v0) p)

      with (allp (Basics.compose (fun P => P p) (fun v0 => A1 v0) -*

                  Basics.compose (fun v0 => A2 (A3 v0) p) (fun v0 => v0)))

  end.



  Opaque struct_pred. eapply @RAMIF_Q.trans. Transparent struct_pred.

  2:{

    apply (struct_pred_ramif (co_members (get_co id))

            (fun it v p =>

              withspacer sh

                (nested_field_offset t gfs +

                (field_offset cenv_cs (fst it) (co_members (get_co id)) +

                 sizeof (field_type (fst it) (co_members (get_co id)))))

                (nested_field_offset t gfs +

                 field_offset_next cenv_cs (fst it) (co_members (get_co id))

                   (sizeof (nested_field_type t gfs)))

                (field_at sh t (gfs DOT fst it) v) p)); auto.

    apply get_co_members_no_replicate.

  }

  2:{

    apply withspacer_ramif_Q.

  }

  intros.

  apply derives_refl.

Qed.



Lemma nested_ufieldlist_at_ramif: forall sh t gfs id a i v p,

  let d := default_val _ in

  nested_field_type t gfs = Tunion id a ->

  in_members i (co_members (get_co id)) ->

  nested_ufieldlist_at sh t gfs (co_members (get_co id)) v p |--

  field_at sh t (UnionField i :: gfs)

    (proj_union i (co_members (get_co id)) v d) p *

      (ALL v0: _,

         field_at sh t (UnionField i :: gfs) v0 p -*

           nested_ufieldlist_at sh t gfs (co_members (get_co id))

            (upd_union i (co_members (get_co id)) v v0) p).

Proof.

  intros.

  destruct (co_members (get_co id)) eqn:?; [inv H0 |].

  revert v d H0; rewrite <- Heqm; intros.

  unfold nested_ufieldlist_at.

  pattern (co_members (get_co id)) at 1 5; rewrite Heqm.



  match goal with

  | |- _ |-- _ * (ALL v0: _, ?A1 v0 p -* ?A2 (?A3 v0) p) =>

      change (ALL v0: _, A1 v0 p -* A2 (A3 v0) p)

      with (allp (Basics.compose (fun P => P p) (fun v0 => A1 v0) -*

                  Basics.compose (fun v0 => A2 (A3 v0) p) (fun v0 => v0)))

  end.



  Opaque union_pred. eapply @RAMIF_Q.trans. Transparent union_pred.

  2:{

    apply (union_pred_ramif (co_members (get_co id))

            (fun it v p =>

              withspacer sh

                (nested_field_offset t gfs +

                 sizeof

                   (field_type (fst it) (co_members (get_co id))))

                (nested_field_offset t gfs +

                 sizeof (nested_field_type t gfs))

                (field_at sh t (gfs UDOT fst it) v) p)); auto.

    2: apply get_co_members_no_replicate.

    instantiate (1 := default_val _).

    intros.

    rewrite !withspacer_spacer.

    unfold fst.

    fold (field_at_ sh t (gfs UDOT i) p).

    eapply derives_trans; [eapply sepcon_derives; [apply derives_refl | apply field_at_field_at_] |].

    rewrite <- !withspacer_spacer.

    erewrite !withspacer_field_at__Tunion by eauto.

    apply derives_refl.

  }

  2:{

    unfold fst.

    apply withspacer_ramif_Q.

  }

  intros.

  apply derives_refl.

Qed.



Lemma memory_block_valid_ptr:

  forall sh n p,

     sepalg.nonidentity sh ->

     n > 0 ->

     memory_block sh n p |-- valid_pointer p.

Proof.

  intros.

  rewrite memory_block_isptr.

  normalize.

  destruct p; try tauto.

  inv_int i.

  replace (Vptr b (Ptrofs.repr ofs)) with (offset_val 0 (Vptr b (Ptrofs.repr ofs))) at 2.

  + apply memory_block_valid_pointer with (i := 0); auto; omega.

  + simpl.

    rewrite ptrofs_add_repr, Z.add_0_r.

    auto.

Qed.



Lemma data_at_valid_ptr:

  forall sh t v p,

     sepalg.nonidentity sh ->

     sizeof t > 0 ->

     data_at sh t v p |-- valid_pointer p.

Proof.

  intros.

  eapply derives_trans; [apply data_at_data_at_ |].

  rewrite data_at__memory_block.

  normalize.

  apply memory_block_valid_ptr; auto.

Qed.



Lemma field_at_valid_ptr:

  forall sh t path v p,

     sepalg.nonidentity sh ->

     sizeof (nested_field_type t path) > 0 ->

     field_at sh t path v p |-- valid_pointer (field_address t path p).

Proof.

intros.

rewrite field_at_data_at.

apply data_at_valid_ptr; auto.

Qed.



Lemma field_at_valid_ptr0:

  forall sh t path v p,

     sepalg.nonidentity sh ->

     sizeof (nested_field_type t path) > 0 ->

     nested_field_offset t path = 0 ->

     field_at sh t path v p |-- valid_pointer p.

Proof.

intros.

assert_PROP (field_compatible t path p).

unfold field_at.

normalize.

pattern p at 2; replace p with (field_address t path p).

rewrite field_at_data_at.

apply data_at_valid_ptr; auto.

unfold field_address. rewrite if_true by auto.

rewrite H1.

normalize.

Qed.



Lemma lower_andp_val:

  forall (P Q: val->mpred) v,

  ((P && Q) v) = (P v && Q v).

Proof. reflexivity. Qed.



Lemma compute_legal_nested_field_spec: forall {A : Type} {ND : NatDed A} (P: A) t gfs,

  Forall (fun Q => P |-- !!Q) (compute_legal_nested_field t gfs) ->

  P |-- !! (legal_nested_field t gfs).

Proof.

  intros.

  induction gfs as [| gf gfs].

  + simpl.

    apply prop_right; auto.

  + simpl in H |- *.

    unfold legal_field.

    destruct (nested_field_type t gfs), gf; inversion H; subst;

    try

    match goal with

    | HH : P |-- (prop False) |-

           P |-- (prop (_)) => apply (derives_trans _ _ _ HH); apply prop_derives; tauto

    end.

    - apply IHgfs in H3.

      rewrite (add_andp _ _ H2).

      rewrite (add_andp _ _ H3).

      normalize.

      apply prop_right; tauto.

    - destruct_in_members i0 (co_members (get_co i)).

      * apply IHgfs in H.

        apply (derives_trans _ _ _ H), prop_derives; tauto.

      * inversion H1.

    - destruct_in_members i0 (co_members (get_co i)).

      * apply IHgfs in H.

        apply (derives_trans _ _ _ H), prop_derives; tauto.

      * inversion H.

        apply (derives_trans _ _ _ H6), prop_derives; tauto.

    - destruct_in_members i0 (co_members (get_co i)).

      * apply IHgfs in H.

        apply (derives_trans _ _ _ H), prop_derives; tauto.

      * inversion H1.

    - destruct_in_members i0 (co_members (get_co i)).

      * apply IHgfs in H.

        apply (derives_trans _ _ _ H), prop_derives; tauto.

      * inversion H.

        apply (derives_trans _ _ _ H6), prop_derives; tauto.

Qed.



Lemma compute_legal_nested_field_spec':

  forall t gfs,

  Forall Datatypes.id (compute_legal_nested_field t gfs) ->

  legal_nested_field t gfs.

Proof.

  intros.

  induction gfs as [| gf gfs].

  + simpl; auto.

  +  simpl in H|-*.

    unfold legal_field. unfold nested_field_type in *.

    destruct (nested_field_rec t gfs) as [[? ?] | ].

    destruct t0; try now inv H; contradiction.

    destruct gf; try now inv H; contradiction.

    inv H. split; auto.

    destruct gf; try now inv H; contradiction.

   destruct (compute_in_members i0 (co_members (get_co i))) eqn:?;

     try now inv H; contradiction.

   split; auto.

   rewrite <- compute_in_members_true_iff; auto.

    destruct gf; try now inv H; contradiction.

   destruct (compute_in_members i0 (co_members (get_co i))) eqn:?;

     try now inv H; contradiction.

   split; auto.

   rewrite <- compute_in_members_true_iff; auto.

   inv H. contradiction.

Qed.



Definition compute_legal_nested_field0 (t: type) (gfs: list gfield) : list Prop :=

  match gfs with

  | nil => nil

  | gf :: gfs0 =>

    match (nested_field_type t gfs0), gf with

    | Tarray _ n _, ArraySubsc i =>

       (0 <= i <= n) :: compute_legal_nested_field t gfs0

    | Tstruct id _, StructField i =>

       if compute_in_members i (co_members (get_co id)) then compute_legal_nested_field t gfs else False :: nil

    | Tunion id _, UnionField i =>

       if compute_in_members i (co_members (get_co id)) then compute_legal_nested_field t gfs else False :: nil

    | _, _ => False :: nil

    end

  end.



Lemma compute_legal_nested_field0_spec':

  forall t gfs,

  Forall Datatypes.id (compute_legal_nested_field0 t gfs) ->

  legal_nested_field0 t gfs.

Proof.

intros.

destruct gfs; simpl in *.

auto.

     unfold nested_field_type in *.

    destruct (nested_field_rec t gfs) as [[? ?] | ].

    destruct t0; try now inv H; contradiction.

    destruct g; try now inv H; contradiction.

    inv H. split.

    apply compute_legal_nested_field_spec'; auto.

    apply H2.

    destruct g; try now inv H; contradiction.

   destruct (compute_in_members i0 (co_members (get_co i))) eqn:?;

     try now inv H; contradiction.

   split.

    apply compute_legal_nested_field_spec'; auto.

   hnf.   rewrite compute_in_members_true_iff in Heqb. apply Heqb.

    destruct g; try now inv H; contradiction.

   destruct (compute_in_members i0 (co_members (get_co i))) eqn:?;

     try now inv H; contradiction.

   split.

    apply compute_legal_nested_field_spec'; auto.

   hnf.   rewrite compute_in_members_true_iff in Heqb. apply Heqb.

  inv H. contradiction.

Qed.



Lemma splice_top_top: Share.splice Tsh Tsh = Tsh.

Proof.

unfold Share.splice.

unfold Share.Lsh, Share.Rsh.

change Share.top with Tsh.

case_eq (Share.split Tsh); intros L R ?.

simpl.

do 2 rewrite Share.rel_top1.

erewrite Share.split_together; eauto.

Qed.



Lemma field_at_conflict: forall sh t fld p v v',

  sepalg.nonidentity sh ->

  0 < sizeof (nested_field_type t fld) ->

  field_at sh t fld v p * field_at sh t fld v' p|-- FF.

Proof.

  intros.

  rewrite field_at_compatible'. normalize.

  destruct H1 as [? [? [? [? ?]]]].

  destruct (nested_field_offset_in_range t fld H5 H2).

  assert (0 < sizeof (nested_field_type t fld) < Ptrofs.modulus).

  {

    destruct p; inv H1.

    simpl in H3.

    inv_int i.

    omega.

  }

  clear - H H1 H8.  

  eapply derives_trans.

  + apply sepcon_derives.

    apply field_at_field_at_; try assumption; auto.

    apply field_at_field_at_; try assumption; auto.

  + fold (field_at_ sh t fld p).

    rewrite field_at__memory_block by auto.

    normalize.

    apply memory_block_conflict; try  (unfold Ptrofs.max_unsigned; omega).

    apply sepalg.nonidentity_nonunit; auto.

Qed.



Lemma data_at_conflict: forall sh t v v' p,

  sepalg.nonidentity sh ->

  0 < sizeof t ->

  data_at sh t v p * data_at sh t v' p |-- FF.

Proof.

  intros. unfold data_at. apply field_at_conflict; auto.

Qed.



Lemma field_at__conflict:

  forall sh t fld p,

  sepalg.nonidentity sh ->

  0 < sizeof (nested_field_type t fld) ->

        field_at_ sh t fld p

        * field_at_ sh t fld p |-- FF.

Proof.

intros.

apply field_at_conflict; auto.

Qed.



Lemma sepcon_FF_derives':

  forall (P Q: mpred), Q |-- FF -> P * Q |-- FF.

Proof.

intros.

eapply derives_trans. apply sepcon_derives; try eassumption; eauto.

rewrite sepcon_FF. auto.

Qed.



Lemma field_compatible_offset_isptr:

forall t path n c, field_compatible t path (offset_val n c) ->

          isptr c.

Proof.

intros.

destruct H as [? _]. destruct c; try contradiction; auto.

Qed.



Lemma field_compatible0_offset_isptr:

forall t path n c, field_compatible t path (offset_val n c) ->

          isptr c.

Proof.

intros.

destruct H as [? _]. destruct c; try contradiction; auto.

Qed.



Lemma is_pointer_or_null_field_address_lemma:

 forall t path p,

   is_pointer_or_null (field_address t path p) <->

   field_compatible t path p.

Proof.

intros.

unfold field_address.

if_tac; intuition.

Qed.



Lemma isptr_field_address_lemma:

 forall t path p,

   isptr (field_address t path p) <->

   field_compatible t path p.

Proof.

intros.

unfold field_address.

if_tac; intuition.

Qed.



Lemma eval_lvar_spec: forall id t rho,

  match eval_lvar id t rho with

  | Vundef => True

  | Vptr b ofs => ofs = Ptrofs.zero

  | _ => False

  end.

Proof.

  intros.

  unfold eval_lvar.

  destruct (Map.get (ve_of rho) id); auto.

  destruct p.

  destruct (eqb_type _ _); auto.

Qed.



Lemma var_block_data_at_:

  forall  sh id t,

  complete_legal_cosu_type t = true ->

  Z.ltb (sizeof t) Ptrofs.modulus = true ->

  is_aligned cenv_cs ha_env_cs la_env_cs t 0 = true ->

  readable_share sh ->

  var_block sh (id, t) = `(data_at_ sh t) (eval_lvar id t).

Proof.

  intros; extensionality rho.

  unfold var_block.

  unfold_lift.

  simpl.

  apply Zlt_is_lt_bool in H0.

  rewrite data_at__memory_block; try auto.

  rewrite memory_block_isptr.

  unfold local, lift1; unfold_lift.

  pose proof eval_lvar_spec id t rho.

  destruct (eval_lvar id t rho); simpl in *; normalize.

  subst.

  f_equal.

  apply ND_prop_ext.

  unfold field_compatible.

  unfold isptr, legal_nested_field, size_compatible, align_compatible.

  change (Ptrofs.unsigned Ptrofs.zero) with 0.

  rewrite Z.add_0_l.

  assert (sizeof t <= Ptrofs.modulus) by omega.

  assert (sizeof t <= Ptrofs.max_unsigned) by (unfold Ptrofs.max_unsigned; omega).

  apply la_env_cs_sound in H1; tauto.

Qed.



End CENV.



Hint Extern 2 (memory_block _ _ _ |-- valid_pointer _) =>

  (apply memory_block_valid_ptr; [auto with valid_pointer | rep_omega]) : valid_pointer.



Lemma valid_pointer_weak:

 forall a, valid_pointer a |-- weak_valid_pointer a.

Proof.

intros.

unfold valid_pointer, weak_valid_pointer.

change predicates_hered.orp with orp. 

apply orp_right1.

auto.

Qed.



Lemma valid_pointer_weak':

  forall P q, P |-- valid_pointer q ->

                 P |-- weak_valid_pointer q.

Proof.

intros.

eapply derives_trans; try eassumption.

apply valid_pointer_weak.

Qed.



Hint Resolve valid_pointer_weak' : valid_pointer.



Lemma valid_pointer_offset_zero: forall P q, 

   P |-- valid_pointer (offset_val 0 q) ->

   P |-- valid_pointer q.

Proof.

intros.

destruct q; auto.

eapply derives_trans; try eassumption.

simpl valid_pointer.

match goal with

| |- context [Int64.zero] =>

    change (@predicates_hered.derives compcert_rmaps.R.rmap _ predicates_hered.FF (predicates_hered.prop (i = Int64.zero)))

| |- context [Int.zero] =>

    change (@predicates_hered.derives compcert_rmaps.R.rmap _ predicates_hered.FF (predicates_hered.prop (i = Int.zero)))

end.

intros ? ?. contradiction H0.

rewrite offset_val_zero_Vptr in H.

auto.

Qed.



Hint Extern 1 (_ |-- valid_pointer ?Q) =>

  lazymatch Q with

  | offset_val _ _ => fail 

  | _ => apply valid_pointer_offset_zero

  end.



Hint Extern 2 (memory_block _ _ _ |-- weak_valid_pointer _) =>

  (apply SeparationLogic.memory_block_weak_valid_pointer;

        [rep_omega | rep_omega | auto with valid_pointer]) : valid_pointer.



Ltac field_at_conflict z fld :=

eapply derives_trans with FF; [ | apply FF_left];

 rewrite <- ?sepcon_assoc;

 unfold data_at_, data_at, field_at_;

 let x := fresh "x" in set (x := field_at _ _ fld _ z); pull_right x;

 let y := fresh "y" in set (y := field_at _ _ fld _ z); pull_right y;

 try (rewrite sepcon_assoc; eapply sepcon_FF_derives');

 subst x y;

 apply field_at_conflict; auto;

 try solve [simpl; computable].



Ltac data_at_conflict z := field_at_conflict z (@nil gfield).



Ltac data_at_conflict_neq_aux1 A sh fld E x y :=

   match A with

   | context [data_at sh _ _ y] => unify fld (@nil gfield)

   | context [data_at_ sh _ y]  => unify fld (@nil gfield)

   | context [field_at sh _ fld _ y] => idtac

   | context [field_at_ sh _ fld y]  => idtac

   end;

   apply derives_trans with (!! (~ E) && A);

   [apply andp_right; [ | apply derives_refl];

    let H := fresh in

    apply not_prop_right; intro H; 

    (rewrite H || rewrite (ptr_eq_e _ _ H)); 

    field_at_conflict y fld 

   | apply derives_extract_prop;

     let H1 := fresh in intro H1;

     rewrite (eq_True _ H1)

    ].



Ltac data_at_conflict_neq_aux2 A E x y :=

   match A with

   | context [data_at ?sh _ _ x] => data_at_conflict_neq_aux1 A sh (@nil gfield) E x y

   | context [data_at_ ?sh _ x]  => data_at_conflict_neq_aux1 A sh (@nil gfield) E x y

   | context [field_at ?sh _ ?fld _ x] => data_at_conflict_neq_aux1 A sh fld E x y

   | context [field_at_ ?sh _ ?fld x]  => data_at_conflict_neq_aux1 A sh fld E x y

   end.



Ltac data_at_conflict_neq :=

  match goal with |- ?A |-- ?B =>

   match B with

   | context [?x <> ?y] => data_at_conflict_neq_aux2 A (x=y) x y

   | context [~ ptr_eq ?x ?y] => data_at_conflict_neq_aux2 A (ptr_eq x y) x y

   end

  end.



Definition natural_aligned {cs: compspecs} (na: Z) (t: type): bool := (na mod (hardware_alignof ha_env_cs t) =? 0) && is_aligned cenv_cs ha_env_cs la_env_cs t 0.



Definition natural_aligned_soundness {cs: compspecs}: Prop :=

    forall na ofs t,

      complete_legal_cosu_type t = true ->

      natural_aligned na t = true ->

      (na | ofs) ->

      align_compatible_rec cenv_cs t ofs.



Lemma natural_aligned_sound {cs: compspecs}:

  natural_aligned_soundness.

Proof.

  intros.

  hnf.

  intros.

  unfold natural_aligned in H0.

  autorewrite with align in H0.

    2: eapply hardware_alignof_two_p; [exact cenv_consistent | exact ha_env_cs_consistent | exact ha_env_cs_complete].

  destruct H0.

  apply la_env_cs_sound in H2; auto.

  replace ofs with (ofs - 0) in H1 by omega.

  eapply align_compatible_rec_hardware_alignof_divide; auto.

  + exact cenv_consistent.

  + exact cenv_legal_su.

  + exact ha_env_cs_consistent.

  + exact ha_env_cs_complete.

  + eapply Z.divide_trans; eassumption.

  + exact H2.

Qed.



Definition natural_alignment := 8.



Definition malloc_compatible (n: Z) (p: val) : Prop :=

  match p with

  | Vptr b ofs => (natural_alignment | Ptrofs.unsigned ofs) /\

                           Ptrofs.unsigned ofs + n < Ptrofs.modulus

  | _ => False

  end.



Lemma malloc_compatible_field_compatible:

  forall (cs: compspecs) t p,

     malloc_compatible (sizeof t) p ->

     complete_legal_cosu_type t = true ->

     natural_aligned natural_alignment t = true ->

     field_compatible t nil p.

Proof.

intros.

destruct p; simpl in *; try contradiction.

destruct H.

eapply natural_aligned_sound in H; eauto.

pose proof (Ptrofs.unsigned_range i).

repeat split; simpl; auto; try omega.

Qed.



Hint Extern 2 (field_compatible _ nil _) =>

 (apply malloc_compatible_field_compatible;

  [assumption | reflexivity | reflexivity]).



Lemma data_array_at_local_facts {cs: compspecs}:

 forall t' n a sh (v: list (reptype t')) p,

  data_at sh (Tarray t' n a) v p |--

  !! (field_compatible (Tarray t' n a) nil p

     /\ Zlength v = Z.max 0 n

     /\ Forall (value_fits t') v).

Proof.

intros.

eapply derives_trans; [apply data_at_local_facts |].

apply prop_derives.

intros [? ?]; split; auto.

Qed.



Lemma data_array_at_local_facts' {cs: compspecs}:

 forall t' n a sh (v: list (reptype t')) p,

  n >= 0 ->

  data_at sh (Tarray t' n a) v p |--

  !! (field_compatible (Tarray t' n a) nil p

     /\ Zlength v = n

     /\ Forall (value_fits t') v).

Proof.

intros.

eapply derives_trans; [apply data_array_at_local_facts |].

apply prop_derives.

intros [? [? ?]]; split3; auto.

rewrite Z.max_r in H1 by omega. auto.

Qed.



Lemma value_fits_by_value {cs: compspecs}:

  forall t v,

   type_is_volatile t = false ->

   type_is_by_value t = true ->

   value_fits t v = tc_val' t (repinject t v).

Proof.

intros.

rewrite value_fits_eq; destruct t; inv H; inv H0;

simpl; rewrite H2; auto.

Qed.



Ltac field_at_saturate_local :=

unfold data_at;

match goal with |- field_at ?sh ?t ?path ?v ?c |-- _ =>

eapply derives_trans; [apply field_at_local_facts |];

  cbv beta;

  try rewrite proj_sumbool_is_true by auto;

  try rewrite proj_sumbool_is_false by auto;

  let p := fresh "p" in set (p := nested_field_type t path);

  simpl in p; unfold field_type in p; simpl in p; subst p;

  try rewrite value_fits_by_value by reflexivity;

  try match goal with |- context [repinject ?t ?v] =>

    change (repinject t v) with v

  end;

  apply derives_refl

end.



Ltac data_at_valid_aux :=

 simpl sizeof; rewrite ?Z.max_r by rep_omega; rep_omega.



Hint Extern 1 (data_at _ _ _ _ |-- valid_pointer _) =>

    (simple apply data_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (field_at _ _ _ _ _ |-- valid_pointer _) =>

    (simple apply field_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (data_at_ _ _ _ |-- valid_pointer _) =>

    (unfold data_at_, field_at_; 

     simple apply field_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (field_at_ _ _ _ _ |-- valid_pointer _) =>

    (unfold field_at_; simple apply field_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (data_at_ _ _ _ |-- valid_pointer _) =>

    (simple apply data_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (field_at_ _ _ _ _ |-- valid_pointer _) =>

    (simple apply field_at_valid_ptr; [now auto | data_at_valid_aux]) : valid_pointer.



Hint Extern 1 (field_at _ _ _ _ _ |-- _) =>

 (field_at_saturate_local) : saturate_local.



Hint Extern 1 (data_at _ _ _ _ |-- _) =>

 (field_at_saturate_local) : saturate_local.



Hint Resolve @array_at_local_facts @array_at__local_facts : saturate_local.



Hint Resolve field_at__local_facts : saturate_local.

Hint Resolve data_at__local_facts : saturate_local.

Hint Extern 0 (data_at _ (Tarray _ _ _) _ _ |-- _) =>

  (apply data_array_at_local_facts'; omega) : saturate_local.

Hint Extern 0 (data_at _ (tarray _ _) _ _ |-- _) =>

  (apply data_array_at_local_facts'; omega) : saturate_local.

Hint Extern 1 (data_at _ (Tarray _ _ _) _ _ |-- _) =>

  (apply data_array_at_local_facts) : saturate_local.

Hint Extern 1 (data_at _ (tarray _ _) _ _ |-- _) =>

  (apply data_array_at_local_facts) : saturate_local.

Hint Rewrite <- @field_at_offset_zero: norm1.

Hint Rewrite <- @field_at__offset_zero: norm1.

Hint Rewrite <- @field_at_offset_zero: cancel.

Hint Rewrite <- @field_at__offset_zero: cancel.

Hint Rewrite <- @data_at__offset_zero: norm1.

Hint Rewrite <- @data_at_offset_zero: norm1.

Hint Rewrite <- @data_at__offset_zero: cancel.

Hint Rewrite <- @data_at_offset_zero: cancel.



Lemma data_at_cancel:

  forall {cs: compspecs} sh t v p,

    data_at sh t v p |-- data_at sh t v p.

Proof. intros. apply derives_refl. Qed.

Lemma field_at_cancel:

  forall {cs: compspecs} sh t gfs v p,

    field_at sh t gfs v p |-- field_at sh t gfs v p.

Proof. intros. apply derives_refl. Qed.



Lemma data_at_field_at_cancel:

  forall {cs: compspecs} sh t v p,

    data_at sh t v p |-- field_at sh t nil v p.

Proof. intros. apply derives_refl. Qed.

Lemma field_at_data_at_cancel:

  forall {cs: compspecs} sh t v p,

    field_at sh t nil v p |-- data_at sh t v p.

Proof. intros. apply derives_refl. Qed.



Hint Resolve data_at_cancel field_at_cancel

   data_at_field_at_cancel field_at_data_at_cancel : cancel.



Lemma field_at__data_at__cancel:

  forall {cs: compspecs} sh t p,

   field_at_ sh t nil p |-- data_at_ sh t p.

Proof. intros. apply derives_refl. Qed.



Lemma data_at__field_at__cancel:

  forall {cs: compspecs} sh t p,

   data_at_ sh t p |-- field_at_ sh t nil p.

Proof. intros. apply derives_refl. Qed.

Hint Resolve  field_at__data_at__cancel data_at__field_at__cancel : cancel.



Hint Extern 2 (field_at _ _ _ _ _ |-- field_at_ _ _ _ _) =>

   (simple apply field_at_field_at_) : cancel.



Hint Extern 2 (field_at _ _ _ _ _ |-- field_at _ _ _ _ _) =>

  (simple apply field_at_field_at_default;

   match goal with |- _ = default_val _ => reflexivity end) : cancel.



Hint Extern 1 (data_at _ _ _ _ |-- data_at_ _ _ _) =>

    (simple apply data_at_data_at_) : cancel.



Hint Extern 1 (data_at _ _ _ _ |-- memory_block _ _ _) =>

    (simple apply data_at__memory_block_cancel) : cancel.



Hint Extern 2 (data_at _ _ _ _ |-- data_at _ _ _ _) =>

  (simple apply data_at_data_at_default;

   match goal with |- _ = default_val _ => reflexivity end) : cancel.



Hint Extern 2 (array_at _ _ _ _ _ _ _ |-- array_at_ _ _ _ _ _ _) =>

  (simple apply array_at_array_at_) : cancel.

Hint Extern 1 (isptr _) => (eapply field_compatible_offset_isptr; eassumption).

Hint Extern 1 (isptr _) => (eapply field_compatible0_offset_isptr; eassumption).

Hint Rewrite @is_pointer_or_null_field_address_lemma : entailer_rewrite.

Hint Rewrite @isptr_field_address_lemma : entailer_rewrite.



Global Transparent alignof. 



Ltac simplify_project_default_val :=

match goal with

  | |- context [@fst ?A ?B (?x, ?y)] =>

         change (@fst A B (x,y)) with x

  | |- context [@snd ?A ?B (?x, ?y)] =>

         change (@snd A B (x,y)) with y

  | |- context [fst (@default_val ?cs ?t)] =>

  let E := fresh "E" in let D := fresh "D" in let H := fresh in

   set (E := fst (@default_val cs t));

   set (D := @default_val cs t) in E;

   unfold compact_prod_sigT_type in E; simpl in E;

   assert (H := @default_val_eq cs t);

   simpl in H;

   match type of H with

      @eq (@reptype cs t) _ (@fold_reptype _ _ (@pair ?A ?B ?x ?y)) =>

   change (@reptype cs t) with (@prod A B) in *;

   change (@default_val cs t) with (x,y) in *

   end;

   clear H; subst D; simpl in E; subst E

 | |- context [snd (@default_val ?cs ?t)] =>

  let E := fresh "E" in let D := fresh "D" in let H := fresh in

   set (E := snd (@default_val cs t));

   set (D := @default_val cs t) in E;

   unfold compact_prod_sigT_type in E; simpl in E;

   assert (H := @default_val_eq cs t);

   simpl in H;

   match type of H with

      @eq (@reptype cs t) _ (@fold_reptype _ _ (@pair ?A ?B ?x ?y)) =>

   change (@reptype cs t) with (@prod A B) in *;

   change (@default_val cs t) with (x,y) in *

   end;

   clear H; subst D; simpl in E; subst E

end.



Definition field_at_mark := @field_at.

Definition field_at_hide := @field_at.

Definition data_at_hide := @data_at.



Ltac find_field_at N :=

 match N with

 | S O =>  change @field_at with field_at_mark at 1;

              change field_at_hide with @field_at

 | S ?k => change @field_at with field_at_hide at 1;

                find_field_at k

 end.



Ltac find_data_at N :=

 match N with

 | S O =>  match goal with |- context[@data_at ?cs ?sh ?t] =>

                 change (@data_at cs sh t) with (field_at_mark cs sh t nil) at 1

                 end;

                 change data_at_hide with @data_at

 | S ?k => change @data_at with data_at_hide at 1;

                find_data_at k

 end.



Definition protect (T: Type) (x: T) := x.

Global Opaque protect.



Lemma field_at_ptr_neq{cs: compspecs} :

   forall sh t fld p1 p2 v1 v2,

  sepalg.nonidentity sh ->

   0 < sizeof (nested_field_type t (fld :: nil))  ->

   field_at sh t (fld::nil) v1 p1 *

   field_at sh t (fld::nil) v2 p2

   |--

   !! (~ ptr_eq p1 p2).

Proof.

   intros.

   apply not_prop_right; intros.

  rewrite -> (ptr_eq_e _ _ H1).   

   apply field_at_conflict; try assumption.

Qed.



Lemma field_at_ptr_neq_andp_emp{cs: compspecs} :

    forall sh t fld p1 p2 v1 v2,

  sepalg.nonidentity sh ->

 0 < sizeof (nested_field_type t (fld :: nil))  ->

   field_at sh t (fld::nil) v1 p1 *

   field_at sh t (fld::nil) v2 p2

   |--

   field_at sh t (fld::nil) v1 p1 *

   field_at sh t (fld::nil) v2 p2 *

   (!! (~ ptr_eq p1 p2) && emp).

Proof.

   intros.

   normalize.

   apply andp_right.

   apply field_at_ptr_neq; assumption.

   cancel.

Qed.



Lemma field_at_ptr_neq_null{cs: compspecs} :

   forall sh t fld v p,

   field_at sh t fld v p |-- !! (~ ptr_eq p nullval).

Proof.

   intros.

   rewrite -> field_at_isptr.

  normalize. apply prop_right.

   destruct p; unfold nullval; simpl in *; tauto.

Qed.



Lemma spacer_share_join:

  forall sh1 sh2 sh J K q,

   sepalg.join sh1 sh2 sh ->

   spacer sh1 J K q * spacer sh2 J K q = spacer sh J K q.

Proof.

 intros.

 unfold spacer.

  if_tac. normalize.

 unfold at_offset.

  apply memory_block_share_join; auto.

Qed.



Lemma struct_pred_cons2:

  forall it it' m (A: ident*type -> Type)

   (P: forall it, A it -> val -> mpred)

   (v: compact_prod (map A (it::it'::m)))

   (p: val),

 struct_pred (it :: it' :: m) P v p =

    P _ (fst v) p * struct_pred (it'::m) P (snd v) p.

Proof.

intros.

destruct v. destruct it, it'. reflexivity.

Qed.



Lemma union_pred_cons2:

  forall it it' m (A: ident*type -> Type)

   (P: forall it, A it -> val -> mpred)

   (v: compact_sum (map A (it::it'::m)))

   (p: val),

 union_pred (it :: it' :: m) P v p =

   match v with inl v => P _ v p | inr v => union_pred (it'::m) P v p end.

Proof.

intros.

destruct v, it, it'; reflexivity.

Qed.



Lemma data_at_rec_void:

  forall {cs: compspecs}

      sh t v q, t = Tvoid -> data_at_rec sh t v q = FF.

Proof.

 intros; subst; reflexivity.

Qed.



Lemma snd_reptype_structlist_aux  {cs: compspecs}:

  forall (p: ident * type) (m: list (ident * type)),

   members_no_replicate (p :: m) = true ->

  map (fun it : ident * type => reptype (field_type (fst it) (p :: m))) m =

  map (fun it : ident * type => reptype (field_type (fst it) m)) m.

  

Proof.

intros.

change (p::m) with ((p::nil) ++ m) in *.

forget (p::nil) as q.

clear p.

revert q H; induction m; intros.

reflexivity.

simpl; f_equal.

+

clear - H.

induction q. reflexivity.

simpl in H.

destruct a0.

rewrite fieldlist.members_no_replicate_ind in H.

destruct H.

rewrite <- IHq; auto.

unfold field_type. simpl.

rewrite if_false; auto.

clear - H.

contradict H. subst.

induction q. left; auto.

right. auto.

+

generalize (IHm (q++ a::nil)).

rewrite app_ass; simpl; intro.

rewrite H0.

symmetry; apply (IHm (a::nil)).

simpl.

clear - H.

induction q. auto. apply IHq.

rewrite fieldlist.members_no_replicate_ind in H.

destruct a0, H; auto.

auto.

Qed.



Lemma field_at_share_join{cs: compspecs}:

  forall sh1 sh2 sh t gfs v p,

    sepalg.join sh1 sh2 sh ->

   field_at sh1 t gfs v p * field_at sh2 t gfs v p = field_at sh t gfs v p.

Proof.

intros.

unfold field_at.

normalize.

apply andp_prop_ext; [tauto |].

intros.

unfold at_offset.

destruct H0 as [? _].

assert (isptr p) by (destruct H0; tauto).

destruct p; try inversion H1.

apply data_at_rec_share_join; auto.

Qed.



Lemma field_at__share_join{cs: compspecs}:

  forall sh1 sh2 sh t gfs p,

    sepalg.join sh1 sh2 sh ->

   field_at_ sh1 t gfs p * field_at_ sh2 t gfs p = field_at_ sh t gfs p.

Proof. intros. apply field_at_share_join. auto. Qed.



Lemma data_at_share_join{cs: compspecs}:

  forall sh1 sh2 sh t v p,

    sepalg.join sh1 sh2 sh ->

   data_at sh1 t v p * data_at sh2 t v p = data_at sh t v p.

Proof. intros. apply field_at_share_join; auto. Qed.



Lemma data_at__share_join{cs: compspecs}:

  forall sh1 sh2 sh t p,

    sepalg.join sh1 sh2 sh ->

   data_at_ sh1 t p * data_at_ sh2 t p = data_at_ sh t p.

Proof. intros. apply data_at_share_join; auto. Qed.



Lemma nonreadable_memory_block_field_at:

  forall  {cs: compspecs}

      sh t gfs v p,

  ~ readable_share sh ->

   value_fits _ v ->

   memory_block sh (sizeof (nested_field_type t gfs)) (field_address t gfs p) = field_at sh t gfs v p.

Proof.

  intros until p. intros NONREAD VF.

  unfold field_address.

  destruct (field_compatible_dec t gfs p).

  + unfold field_at_, field_at.

    rewrite prop_true_andp by auto.

    assert (isptr p) by auto; destruct p; try contradiction; clear H.

    inv_int i.

    unfold at_offset, offset_val.

    solve_mod_modulus.

    pose proof field_compatible_nested_field _ _ _ f.

    revert H f;

    unfold field_compatible;

    unfold size_compatible, align_compatible, offset_val;

    solve_mod_modulus;

    intros.

    pose proof nested_field_offset_in_range t gfs.

    spec H1; [tauto |].

    spec H1; [tauto |].

    rewrite (Z.mod_small ofs) in * by omega.

    pose proof Zmod_le (ofs + nested_field_offset t gfs) Ptrofs.modulus.

    spec H2; [pose proof Ptrofs.modulus_pos; omega |].

    revert H; solve_mod_modulus; intros.

    rewrite Zmod_small in H by (pose proof sizeof_pos (nested_field_type t gfs); omega).

    apply nonreadable_memory_block_data_at_rec; try tauto; try omega.

  + unfold field_at_, field_at.

    rewrite memory_block_isptr.

    apply pred_ext; normalize.

Qed.



Lemma nonreadable_memory_block_data_at: forall  {cs: compspecs} sh t v p,

  ~ readable_share sh ->

  field_compatible t nil p ->

  value_fits t v ->

  memory_block sh (sizeof t) p = data_at sh t v p.

Proof.

  intros.

  replace p with (field_address t nil p) at 1.

  change t with (nested_field_type t nil) at 1.

  apply nonreadable_memory_block_field_at; auto.

  rewrite field_compatible_field_address by auto.

  simpl.

  change (nested_field_offset t nil) with 0.

  apply isptr_offset_val_zero.

  auto with field_compatible.

Qed.



Lemma nonreadable_field_at_eq {cs: compspecs} :

  forall sh t gfs v v' p,

   ~ readable_share sh ->

   (value_fits (nested_field_type t gfs) v <-> value_fits (nested_field_type t gfs) v') ->

   field_at sh t gfs v p = field_at sh t gfs v' p.

Proof.

intros.

rewrite !field_at_data_at.

apply pred_ext; saturate_local.

rewrite <- !nonreadable_memory_block_data_at; auto.

apply H0; auto.

destruct (readable_share_dec sh); try contradiction.

rewrite <- !nonreadable_memory_block_data_at; auto.

apply H0; auto.

Qed.



Lemma nonreadable_readable_memory_block_data_at_join

    {cs: compspecs}:

  forall ash bsh psh t v p,

    sepalg.join ash bsh psh ->

    ~ readable_share ash ->

   memory_block ash (sizeof t) p * data_at bsh t v p = data_at psh t v p.

Proof.

intros.

apply pred_ext; saturate_local.

rewrite nonreadable_memory_block_data_at with (v0:=v); auto.

unfold data_at.

erewrite field_at_share_join; eauto. apply derives_refl.

rewrite nonreadable_memory_block_data_at with (v0:=v); auto.

unfold data_at.

erewrite field_at_share_join; eauto.

apply derives_refl.

Qed.



Lemma nonreadable_data_at_eq {cs: compspecs}:

  forall sh t v v' p, ~readable_share sh ->

   (value_fits t v <-> value_fits t v') ->

     data_at sh t v p = data_at sh t v' p.

Proof.

intros.

unfold data_at.

apply nonreadable_field_at_eq; auto.

Qed.



Lemma field_at_share_join_W {cs: compspecs}:

  forall sh1 sh2 sh t gfs v1 v2 p,

    sepalg.join sh1 sh2 sh ->

    writable_share sh1 ->

    field_at sh1 t gfs v1 p * field_at sh2 t gfs v2 p |-- field_at sh t gfs v1 p.

Proof.

  intros.

  pose proof join_writable_readable H H0.

  rewrite (add_andp _ _ (field_at_local_facts sh1 _ _ _ _)).

  rewrite (add_andp _ _ (field_at_local_facts sh2 _ _ _ _)).

  normalize.

  rewrite (nonreadable_field_at_eq sh2 _ _ v2 v1) by (auto; tauto).

  erewrite field_at_share_join by eauto.

  auto.

Qed.



Lemma data_at_share_join_W {cs: compspecs}:

  forall sh1 sh2 sh t v1 v2 p,

    sepalg.join sh1 sh2 sh ->

    writable_share sh1 ->

    data_at sh1 t v1 p * data_at sh2 t v2 p |-- data_at sh t v1 p.

Proof.

  intros.

  apply field_at_share_join_W; auto.

Qed.



Lemma value_fits_Tint_trivial {cs: compspecs} :

  forall s a  i, value_fits (Tint I32 s a) (Vint i).

Proof.

intros.

rewrite value_fits_eq; simpl.

destruct (attr_volatile a); auto.

hnf. intro. apply Coq.Init.Logic.I.

Qed.



Lemma data_at_tuint_tint {cs: compspecs}: forall sh v p, data_at sh tuint v p = data_at sh tint v p.

Proof.

  intros.

  unfold data_at, field_at.

  f_equal.

  unfold field_compatible.

  apply ND_prop_ext.

  assert (align_compatible tuint p <-> align_compatible tint p); [| tauto].

  destruct p; simpl; try tauto.

  split; intros.

  + eapply align_compatible_rec_by_value_inv in H; [| reflexivity].

    eapply align_compatible_rec_by_value; [reflexivity |].

    auto.

  + eapply align_compatible_rec_by_value_inv in H; [| reflexivity].

    eapply align_compatible_rec_by_value; [reflexivity |].

    auto.

Qed.



Lemma mapsto_field_at {cs: compspecs} sh t gfs v v' p:

  type_is_by_value (nested_field_type t gfs) = true ->

  type_is_volatile (nested_field_type t gfs) = false ->

  field_compatible t gfs p ->

  JMeq v v' ->

  mapsto sh (nested_field_type t gfs) (field_address t gfs p) v = field_at sh t gfs v' p.

Proof.

  intros.

  unfold field_at, at_offset.

  rewrite by_value_data_at_rec_nonvolatile by auto.

  apply (fun HH => JMeq_trans HH (JMeq_sym (repinject_JMeq _ v' H))) in H2.

  apply JMeq_eq in H2.

  rewrite prop_true_andp by auto.

  f_equal; auto.

  apply field_compatible_field_address; auto.

Qed.



Lemma mapsto_field_at_ramify {cs: compspecs} sh t gfs v v' w w' p:

  type_is_by_value (nested_field_type t gfs) = true ->

  type_is_volatile (nested_field_type t gfs) = false ->

  JMeq v v' ->

  JMeq w w' ->

  field_at sh t gfs v' p |--

    mapsto sh (nested_field_type t gfs) (field_address t gfs p) v *

     (mapsto sh (nested_field_type t gfs) (field_address t gfs p) w -*

        field_at sh t gfs w' p).

Proof.

  intros.

  unfold field_at, at_offset.

  rewrite !by_value_data_at_rec_nonvolatile by auto.

  apply (fun HH => JMeq_trans HH (JMeq_sym (repinject_JMeq _ v' H))) in H1; apply JMeq_eq in H1.

  apply (fun HH => JMeq_trans HH (JMeq_sym (repinject_JMeq _ w' H))) in H2; apply JMeq_eq in H2.

  normalize.

  rewrite field_compatible_field_address by auto.

  subst.

  apply RAMIF_PLAIN.solve with emp; [rewrite sepcon_emp | rewrite emp_sepcon]; auto.

Qed.



Lemma mapsto_data_at {cs: compspecs} sh t v v' p :  

  type_is_by_value t = true ->

  type_is_volatile t = false ->

  isptr p ->

  size_compatible t p ->

  align_compatible t p ->

  complete_legal_cosu_type t = true ->

  JMeq v v' ->

  mapsto sh t p v = data_at sh t v' p.

Proof.

  intros.

  unfold data_at, field_at, at_offset, offset_val.

  simpl.

  destruct p; inv H1.

  rewrite ptrofs_add_repr_0_r.

  rewrite by_value_data_at_rec_nonvolatile by auto.

  apply (fun HH => JMeq_trans HH (JMeq_sym (repinject_JMeq _ v' H))) in H5; apply JMeq_eq in H5.

  rewrite prop_true_andp; auto.

  f_equal. auto.

  repeat split; auto.

Qed.



Lemma mapsto_data_at' {cs: compspecs} sh t v v' p:

  type_is_by_value t = true ->

  type_is_volatile t = false ->

  field_compatible t nil p ->

  JMeq v v' ->

  mapsto sh t p v = data_at sh t v' p.

Proof.

  intros.

  unfold data_at, field_at, at_offset, offset_val.

  simpl.

  rewrite prop_true_andp by auto.

  rewrite by_value_data_at_rec_nonvolatile by auto.

  apply (fun HH => JMeq_trans HH (JMeq_sym (repinject_JMeq _ v' H))) in H2; apply JMeq_eq in H2.

  f_equal; auto.

  destruct H1. destruct p; try contradiction.

  rewrite ptrofs_add_repr_0_r. auto.

Qed.



Lemma headptr_field_compatible: forall {cs: compspecs} t path p, 

   headptr p ->

   complete_legal_cosu_type t = true ->

   legal_nested_field t path ->

   sizeof t < Ptrofs.modulus ->

   align_compatible_rec cenv_cs t 0 ->

   field_compatible t path p.

Proof.

 intros.

 destruct H as [b ?]; subst p.

 repeat split; auto.

Qed.



Lemma mapsto_data_at'' {cs: compspecs}: forall sh t v v' p,

  ((type_is_by_value t) && (complete_legal_cosu_type t) && (negb (type_is_volatile t)) && is_aligned cenv_cs ha_env_cs la_env_cs t 0 = true)%bool ->

  headptr p ->

  JMeq v v' ->

  mapsto sh t p v = data_at sh t v' p.

Proof.

  intros.

  rewrite !andb_true_iff in H.

  destruct H as [[[? ?] ?] ?].

  rewrite negb_true_iff in H3.

  apply mapsto_data_at'; auto.

  apply headptr_field_compatible; auto.

  + destruct t; inv H; simpl; auto.

  + destruct t as [| [ |  |  | ] ? | | [ | ] | | | | |]; inv H; reflexivity.

  + apply la_env_cs_sound in H4; auto.

Qed.



Lemma data_at_type_changable {cs}: forall (sh: Share.t) (t1 t2: type) v1 v2,

  t1 = t2 ->

  JMeq v1 v2 ->

  @data_at cs sh t1 v1 = data_at sh t2 v2.

Proof. intros. subst. apply JMeq_eq in H0. subst v2. reflexivity. Qed.



Lemma field_at_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (sh: Share.t) (t: type) gfs v1 v2,

  JMeq v1 v2 ->

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @field_at cs_from sh t gfs v1 = @field_at cs_to sh t gfs v2.

Proof.

  intros.

  unfold field_at.

  extensionality p.

  apply andp_prop_ext.

  + apply field_compatible_change_composite; auto.

  + intros.

    pose proof H1.

    rewrite field_compatible_change_composite in H2 by auto.

    f_equal.

    - revert v1 H;

      rewrite nested_field_type_change_composite by auto.

      intros.

      apply data_at_rec_change_composite; auto.

      apply nested_field_type_preserves_change_composite; auto.

    - apply nested_field_offset_change_composite; auto.

Qed.



Lemma field_at__change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (sh: Share.t) (t: type) gfs,

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @field_at_ cs_from sh t gfs = @field_at_ cs_to sh t gfs.

Proof.

  intros.

  apply field_at_change_composite; auto.

  rewrite nested_field_type_change_composite by auto.

  apply default_val_change_composite.

  apply nested_field_type_preserves_change_composite; auto.

Qed.



Lemma data_at_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (sh: Share.t) (t: type) v1 v2,

  JMeq v1 v2 ->

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @data_at cs_from sh t v1 = @data_at cs_to sh t v2.

Proof.

  intros.

  apply field_at_change_composite; auto.

Qed.



Lemma data_at__change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (sh: Share.t) (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @data_at_ cs_from sh t = @data_at_ cs_to sh t.

Proof.

  intros.

  apply field_at__change_composite; auto.

Qed.



Lemma array_at_data_at1 {cs} : forall sh t gfs lo hi v p,

   lo <= hi ->

   field_compatible0 t (gfs SUB lo) p ->

   field_compatible0 t (gfs SUB hi) p ->

  @array_at cs sh t gfs lo hi v p =

  at_offset (@data_at cs sh (nested_field_array_type t gfs lo hi) v)

               (nested_field_offset t (ArraySubsc lo :: gfs)) p.

Proof.

  intros. rewrite array_at_data_at by auto. unfold at_offset. apply pred_ext; normalize.

Qed.



Lemma data_at_ext_derives {cs} sh t v v' p q: v=v' -> p=q -> @data_at cs sh t v p |-- @data_at cs sh t v' q.

Proof. intros; subst. 

apply derives_refl.

Qed.



Lemma data_at_ext_eq {cs} sh t v v' p q: v=v' -> p=q -> @data_at cs sh t v p = @data_at cs sh t v' q.

Proof. intros; subst. trivial. Qed.



Ltac simpl_compute_legal_nested_field :=

  repeat match goal with

  | |- context [ compute_legal_nested_field ?T ?L ] =>

    let r := eval hnf in (compute_legal_nested_field T L) in

    change (compute_legal_nested_field T L) with r

  end.



Ltac solve_legal_nested_field_in_entailment :=

   match goal with

   | |- _ |-- !! legal_nested_field ?t_root ?gfs =>

     try unfold t_root;

     try unfold gfs;

     try match gfs with

     | (?gfs1 ++ ?gfs0) => try unfold gfs1; try unfold gfs0

     end

  end;

  first

  [ apply prop_right; apply compute_legal_nested_field_spec';

    simpl_compute_legal_nested_field;

    repeat constructor; omega

  |

  apply compute_legal_nested_field_spec;

  simpl_compute_legal_nested_field;

  repeat constructor;

  try solve [apply prop_right; auto; omega];

  try solve [normalize; apply prop_right; auto; omega]

  ].



Ltac headptr_field_compatible :=

  match goal with H: headptr ?P |- field_compatible _ _ ?P =>

  apply headptr_field_compatible;

        [ apply H | reflexivity | | simpl; computable | apply la_env_cs_sound; reflexivity];

    apply compute_legal_nested_field_spec';

    simpl_compute_legal_nested_field;

    repeat apply Forall_cons; try apply Forall_nil

  end.



Hint Extern 2 (field_compatible _ _ _) => headptr_field_compatible : field_compatible.



Lemma data_at_data_at_cancel  {cs: compspecs}: forall sh t v v' p,

  v = v' ->

  data_at sh t v p |-- data_at sh t v' p.

Proof. intros. subst. apply derives_refl. Qed.

 

Hint Resolve data_at_data_at_cancel : cancel.



Lemma field_at_field_at_cancel  {cs: compspecs}: forall sh t gfs v v' p,

  v = v' ->

  field_at sh t gfs v p |-- field_at sh t gfs v' p.

Proof. intros. subst. apply derives_refl. Qed.

 

Hint Resolve data_at_data_at_cancel : cancel.

Hint Resolve field_at_field_at_cancel : cancel.



Lemma data_at__data_at {cs: compspecs}:

   forall sh t v p, v = default_val t -> data_at_ sh t p |-- data_at sh t v p.

Proof.

intros; subst; unfold data_at_; apply derives_refl.

Qed.



Lemma field_at__field_at {cs: compspecs} :

   forall sh t gfs v p, v = default_val (nested_field_type t gfs) -> field_at_ sh t gfs p |-- field_at sh t gfs v p.

Proof.

intros; subst; unfold field_at_; apply derives_refl.

Qed.



Lemma data_at__field_at {cs: compspecs}:

   forall sh t v p, v = default_val t -> data_at_ sh t p |-- field_at sh t nil v p.

Proof.

intros; subst; unfold data_at_; apply derives_refl.

Qed.



Lemma field_at__data_at {cs: compspecs} :

   forall sh t v p, v = default_val (nested_field_type t nil) -> field_at_ sh t nil p |-- data_at sh t v p.

Proof.

intros; subst; unfold field_at_; apply derives_refl.

Qed.



Hint Resolve data_at__data_at : cancel.

Hint Resolve field_at__field_at : cancel.

Hint Resolve data_at__field_at : cancel.

Hint Resolve field_at__data_at : cancel.



Hint Extern 1 (_ = @default_val _ _) =>

 match goal with |- ?A = ?B => 

     let x := fresh "x" in set (x := B); hnf in x; subst x;

     match goal with |- ?A = ?B => constr_eq A B; reflexivity

  end end.



Hint Extern 1 (_ = _) => 

  match goal with |- ?A = ?B => constr_eq A B; reflexivity end : cancel.



Lemma field_at_data_at_cancel': forall {cs : compspecs} sh t v p,

  field_at sh t nil v p = data_at sh t v p.

Proof.

  intros. apply pred_ext.

  apply field_at_data_at_cancel.

  apply data_at_field_at_cancel.

Qed.



Hint Rewrite

  @field_at_data_at_cancel'

  @field_at_data_at

  @field_at__data_at_

  @data_at__data_at : cancel.



Lemma data_at__Tarray:

  forall {CS: compspecs} sh t n a,

  data_at_ sh (Tarray t n a) = 

  data_at sh (Tarray t n a) (list_repeat (Z.to_nat n) (default_val t)).

Proof.

intros.

unfold data_at_, field_at_, data_at.

extensionality p.

simpl.

f_equal.

Qed.



Lemma data_at__tarray:

  forall {CS: compspecs} sh t n,

  data_at_ sh (tarray t n) = 

  data_at sh (tarray t n) (list_repeat (Z.to_nat n) (default_val t)).

Proof. intros; apply data_at__Tarray; auto. Qed.



Lemma data_at__Tarray':

  forall {CS: compspecs} sh t n a v, 

  v = list_repeat (Z.to_nat n) (default_val t) ->

  data_at_ sh (Tarray t n a) = data_at sh (Tarray t n a) v.

Proof.

intros.

unfold data_at_, field_at_, data_at.

extensionality p.

simpl.

f_equal.

subst.

reflexivity.

Qed.



Lemma data_at__tarray':

  forall {CS: compspecs} sh t n v, 

  v = list_repeat (Z.to_nat n) (default_val t) ->

  data_at_ sh (tarray t n) = data_at sh (tarray t n) v.

Proof. intros; apply data_at__Tarray'; auto. Qed.



Ltac unfold_data_at_ p :=

 match goal with |- context [data_at_ ?sh ?t p] =>

  let d := fresh "d" in set (d := data_at_ sh t p);

  pattern d;

  let g := fresh "goal" in

   match goal with |- ?G d => set (g:=G) end;

  revert d;

  match t with

   | Tarray ?t1 ?n _ => 

          erewrite data_at__Tarray' by apply eq_refl;

          try change (default_val t1) with Vundef

   | tarray ?t1 ?n => 

          erewrite data_at__tarray' by apply eq_refl;

          try change (default_val t1) with Vundef

   | _ => change (data_at_ sh t p) with (data_at sh t (default_val t) p);

              try change (default_val t) with Vundef

  end;

  subst g; intro d; subst d; cbv beta

 end.



Lemma change_compspecs_field_at_cancel:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type) gfs

        (v1: @reptype cs1 (@nested_field_type cs1 t1 gfs))

        (v2: @reptype cs2 (@nested_field_type cs2 t2 gfs))

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   JMeq v1 v2 -> 

   @field_at cs1 sh t1 gfs v1 p |-- @field_at cs2 sh t2 gfs v2 p.

Proof.

intros.

subst t2.

apply derives_refl'.

apply equal_f.

apply @field_at_change_composite with CCE; auto.

Qed.



Lemma change_compspecs_data_at_cancel:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type)

        (v1: @reptype cs1 t1) (v2: @reptype cs2 t2)

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   JMeq v1 v2 -> 

   @data_at cs1 sh t1 v1 p |-- @data_at cs2 sh t2 v2 p.

Proof.

intros.

apply change_compspecs_field_at_cancel; auto.

Qed.



Lemma change_compspecs_field_at_cancel2:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type) gfs

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   @field_at_ cs1 sh t1 gfs p |-- @field_at_ cs2 sh t2 gfs p.

Proof.

intros.

subst t2.

apply @change_compspecs_field_at_cancel with CCE; auto.

pose proof (@nested_field_type_change_composite cs1 cs2 CCE t1 H0 gfs).

rewrite H.

apply @default_val_change_composite with CCE; auto.

apply nested_field_type_preserves_change_composite; auto.

Qed.



Lemma change_compspecs_data_at_cancel2:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type)

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   @data_at_ cs1 sh t1 p |-- @data_at_ cs2 sh t2 p.

Proof.

intros.

apply change_compspecs_field_at_cancel2; auto.

Qed.



Lemma change_compspecs_field_at_cancel3:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type) gfs

        (v1: @reptype cs1 (@nested_field_type cs1 t1 gfs))

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   @field_at cs1 sh t1 gfs v1 p |-- @field_at_ cs2 sh t2 gfs p.

Proof.

intros.

subst t2.

apply derives_trans with (@field_at_ cs1 sh t1 gfs p).

apply field_at_field_at_.

apply @change_compspecs_field_at_cancel2 with CCE; auto.

Qed.



Lemma change_compspecs_data_at_cancel3:

  forall {cs1 cs2: compspecs} {CCE : change_composite_env cs1 cs2}

        (sh: share) (t1 t2: type)

        (v1: @reptype cs1 t1)

        (p: val),

    t1 = t2 -> 

    cs_preserve_type cs1 cs2 (@coeq cs1 cs2 CCE) t1 = true ->

   @data_at cs1 sh t1 v1 p |-- @data_at_ cs2 sh t2 p.

Proof.

intros.

apply @change_compspecs_field_at_cancel3 with CCE; auto.

Qed.



Hint Extern 2 (@data_at_ ?cs1 ?sh _ ?p |-- @data_at_ ?cs2 ?sh _ ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_data_at_cancel2; reflexivity) : cancel.



Hint Extern 2 (@data_at ?cs1 ?sh _ _ ?p |-- @data_at_ ?cs2 ?sh _ ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_data_at_cancel3; reflexivity) : cancel.



Hint Extern 2 (@data_at ?cs1 ?sh _ _ ?p |-- @data_at ?cs2 ?sh _ _ ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_data_at_cancel; 

       [ reflexivity | reflexivity | apply JMeq_refl]) : cancel.



Hint Extern 2 (@field_at_ ?cs1 ?sh _ ?gfs ?p |-- @field_at_ ?cs2 ?sh _ ?gfs ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_field_at_cancel2; reflexivity) : cancel.



Hint Extern 2 (@field_at ?cs1 ?sh _ ?gfs _ ?p |-- @field_at_ ?cs2 ?sh _ ?gfs ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_field_at_cancel3; reflexivity) : cancel.



Hint Extern 2 (@field_at ?cs1 ?sh _ ?gfs _ ?p |-- @field_at ?cs2 ?sh _ ?gfs _ ?p) =>

    (tryif constr_eq cs1 cs2 then fail

     else simple apply change_compspecs_field_at_cancel; 

        [ reflexivity | reflexivity | apply JMeq_refl]) : cancel.



