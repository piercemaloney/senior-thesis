

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Require Import VST.msl.simple_CCC.
(* VST.msl.simple_CCC:
Module CartesianClosedCat.

Section CartesianClosedCat.

Variable A: Type.
Variable arrow: A -> A -> Prop.
Variable iso: A -> A -> Prop.

Class CCC (prod expo: A -> A -> A): Prop := mkCCC {
  comm: forall x y, iso (prod x y) (prod y x);
  assoc: forall x y z, iso (prod (prod x y) z) (prod x (prod y z));
  adjoint: forall x y z, arrow (prod x y) z <-> arrow x (expo y z);
  prod_UMP: forall x x' y y', arrow x x' -> arrow y y' -> arrow (prod x y) (prod x' y')
}.

Hypothesis transitivity: forall x y z, arrow x y -> arrow y z -> arrow x z.
Hypothesis identity: forall x, arrow x x.

Lemma expo_UMP: forall prod expo `{CCC prod expo},
  forall x x' y y', arrow x' x -> arrow y y' -> arrow (expo x y) (expo x' y').

End CartesianClosedCat.

End CartesianClosedCat. *)

Require Import VST.msl.seplog.
(* VST.msl.seplog:
Definition  extensible {A}{ND: NatDed A}{SL: SepLog A}(P:A) := sepcon P TT |-- P.

Lemma orp_comm: forall {A: Type} `{NatDed A} (P Q: A), P || Q = Q || P. *)

Require Import VST.msl.log_normalize.
(* VST.msl.log_normalize:
Require Import VST.msl.simple_CCC.
Require Import VST.msl.seplog.

Require Import VST.msl.Extensionality.
Require Import Coq.Setoids.Setoid.

Local Open Scope logic.

Hint Extern 0 (_ |-- _) => match goal with |- ?A |-- ?B => constr_eq A B; simple apply derives_refl end.

Ltac solve_andp' :=
  first [ apply derives_refl
        | apply andp_left1; solve_andp'
        | apply andp_left2; solve_andp'].

Ltac solve_andp := repeat apply andp_right; solve_andp'.

Lemma TT_right {A}{NA: NatDed A}: forall P:A, P |-- TT.

Lemma FF_left {A}{NA: NatDed A}: forall P, FF |-- P.

Hint Resolve @TT_right: norm.
Hint Resolve @FF_left : norm.

Ltac norm := auto with norm.

Lemma add_andp: forall {A: Type} `{NatDed A} (P Q: A), P |-- Q -> P = P && Q.

Lemma andp_comm  {A}{NA: NatDed A}:
  forall P Q: A,  P && Q = Q && P.

Lemma andp_assoc {A} {NA: NatDed A} : forall P Q R : A,
  (P && Q) && R = P && (Q && R).

Lemma andp_derives {A} {NA: NatDed A}:
  forall P Q P' Q': A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma orp_derives {A} {NA: NatDed A}:
  forall P Q P' Q': A, P |-- P' -> Q |-- Q' -> P || Q |-- P' || Q'.

Class CCCviaNatDed (A: Type) (prod expo: A -> A -> A) {ND: NatDed A}: Prop :=
  isCCC: CartesianClosedCat.CCC A derives eq prod expo.

Lemma CCC_expo_derives: forall A prod expo {ND: NatDed A} {CCC: CCCviaNatDed A prod expo},
  forall P P' Q Q', P' |-- P -> Q |-- Q' -> expo P Q |-- expo P' Q'.

Lemma CCC_exp_prod1:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} B (P: B -> A) Q,
  prod (exp P) Q = exp (fun x => prod (P x) Q).

Lemma CCC_exp_prod2:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} B P (Q: B -> A),
  prod P (exp Q) = exp (fun x => prod P (Q x)).

Lemma CCC_distrib_orp_prod:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P Q R,
    prod (orp P Q) R = orp (prod P R) (prod Q R).

Lemma CCC_FF_prod:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P,
    prod FF P = FF.

Lemma CCC_prod_FF:
  forall A prod expo {ND : NatDed A} {CCC: CCCviaNatDed A prod expo} P,
    prod P FF = FF.

Lemma exp_unit: forall {A} `{NatDed A} (P: unit -> A),
  exp P = P tt.

Lemma allp_unit: forall {A} `{NatDed A} (P: unit -> A),
  allp P = P tt.

Lemma andp_is_allp {A}{ND: NatDed A}:
   forall P Q, andp P Q = allp (fun x : bool => if x then P else Q).

Lemma orp_is_exp {A}{ND: NatDed A}:
   forall P Q, orp P Q = exp (fun x : bool => if x then P else Q).

Lemma exp_prop: forall {B} {ND: NatDed B} A P, exp (fun x: A => prop (P x)) = prop (exists x: A, P x).

Lemma modus_ponens {A}{ND: NatDed A}: forall P Q: A, derives (andp P (imp P Q)) Q.

Lemma modus_ponens_wand {A}{ND: NatDed A}{SL: SepLog A}:
                      forall P Q: A, derives (sepcon P (wand P Q)) Q.

Lemma wand_sepcon_wand: forall {A} {NA: NatDed A} {SA: SepLog A} (P1 P2 Q1 Q2: A),
  (P1 -* Q1) * (P2 -* Q2) |-- P1 * P2 -* Q1 * Q2.

Lemma sepcon_FF {A}{ND: NatDed A}{SL: SepLog A} :
           forall P: A, sepcon P FF = FF.

Lemma FF_sepcon {A} {NA: NatDed A}{SA: SepLog A}: forall P: A, FF * P = FF.

Hint Rewrite @FF_sepcon @sepcon_FF : norm.

Lemma FF_andp {A}{NA: NatDed A}:  forall P: A, FF && P = FF.

Lemma andp_FF {A}{NA: NatDed A}:  forall P: A, P && FF = FF.
Hint Rewrite @FF_andp @andp_FF : norm.

Lemma FF_orp: forall {A: Type} `{NatDed A} (P: A), FF || P = P.

Lemma orp_FF {A}{NA: NatDed A}:
  forall Q, Q || FF = Q.

Lemma orp_TT {A}{NA: NatDed A}:
 forall Q, Q || TT = TT.

Lemma TT_orp {A}{NA: NatDed A}:
 forall Q, TT || Q = TT.

Lemma allp_forall: forall {A B: Type} `{NatDed A} P Q (x:B), (forall x:B, (P x = Q)) -> (allp P = Q).

Lemma allp_derives:
       forall {A: Type}  {NA: NatDed A} (B: Type) (P Q: B -> A),
               (forall x:B, P x |-- Q x) -> (allp P |-- allp Q).

Lemma allp_congr:
       forall {A: Type}  {NA: NatDed A} (B: Type) (P Q: B -> A),
               (forall x:B, P x = Q x) -> (allp P = allp Q).

Lemma allp_uncurry: forall {A} `{NatDed A} (S T: Type) (P: S -> T -> A),
  allp (allp P) = allp (fun st => P (fst st) (snd st)).

Lemma allp_depended_uncurry': forall {A} `{NatDed A} {S: Type} {T: S -> Type} (P: forall s: S, T s -> A),
  ALL s: S, (ALL t: T s, P s t) = ALL st: sigT T, P (projT1 st) (projT2 st).

Lemma allp_uncurry': forall {A} `{NatDed A} (S T: Type) (P: S -> T -> A),
  ALL s: S, (ALL t: T, P s t) = ALL st: prod S T, P (fst st) (snd st).

Lemma allp_curry: forall {A} `{NatDed A} (S T: Type) (P: S * T -> A),
  allp P = allp (fun s => allp (fun t => P (s, t))).

Lemma exp_derives {A}{NA: NatDed A}{B}:
   forall F G: B -> A, (forall x, F x |-- G x) -> exp F |-- exp G.

Lemma exp_congr:
 forall A NA T X Y,
    (forall v, X v = Y v) -> @exp A NA T X = @exp A NA T Y.

Lemma exp_uncurry:
  forall {T} {ND: NatDed T} A B F, (@exp T ND A (fun a => @exp T ND B (fun b => F a b)))
   = @exp T ND (A*B) (fun ab => F (fst ab) (snd ab)).

Lemma exp_trivial {A}{NA: NatDed A}:
  forall {T: Type} (any: T) (P: A), exp (fun x:T => P) = P.

Lemma allp_andp: forall {A B: Type} `{NatDed A} (P Q: B -> A), allp (P && Q) = allp P && allp Q.

Lemma distrib_andp_orp: forall {A : Type} {ND : NatDed A} (P Q R : A),
  (P && Q) || R = (P || R) && (Q || R).
    
Lemma prop_derives {A}{ND: NatDed A}:
 forall (P Q: Prop), (P -> Q) -> prop P |-- prop Q.

Lemma ND_prop_ext {A}{ND: NatDed A}: forall P Q, (P <-> Q) -> !! P = !! Q.

Lemma prop_True_right {A}{NA: NatDed A}: forall P:A, P |-- !! True.

Lemma derives_refl' {A}{NA: NatDed A}: forall P Q: A, P=Q -> P |-- Q.

Lemma derives_refl'' {A}{NA: NatDed A}: forall P Q: A, Q=P -> P |-- Q.

Lemma wand_derives {A}{ND: NatDed A}{SL: SepLog A}:
    forall P P' Q Q': A , P' |-- P -> Q |-- Q' ->  P -* Q |-- P' -* Q'.

Lemma distrib_orp_andp {A}{ND: NatDed A}:
   forall (P Q R : A), andp (orp P Q) R = orp (andp P R) (andp Q R).

Lemma exp_andp1 {A}{ND: NatDed A}:  forall B (p: B -> A) q, andp (exp p) q = (exp (fun x => andp (p x) q)).

Lemma exp_sepcon1 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T (P: T ->  A) Q, sepcon (exp P) Q = exp (fun x => sepcon (P x) Q).

Lemma distrib_orp_sepcon {A}{ND: NatDed A}{SL: SepLog A}:
      forall (P Q R : A), sepcon (P || Q) R = sepcon P R || sepcon Q R.

Lemma distrib_orp_sepcon2 {A}{ND: NatDed A}{SL: SepLog A}:
  forall P Q R: A,
     R * (P || Q) = R * P || R * Q.

Lemma exp_sepcon2 {A}{NA: NatDed A}{SA: SepLog A}:
  forall T (P: A) (Q: T -> A),  P * exp Q = exp (fun x => P * Q x).

Lemma allp_sepcon1 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T (P: T ->  A) Q, sepcon (allp P) Q |-- allp (fun x => sepcon (P x) Q).

Lemma allp_sepcon2 {A}{ND: NatDed A} {SL: SepLog A}:
  forall T P (Q: T ->  A), sepcon P (allp Q) |-- allp (fun x => sepcon P (Q x)).

Lemma exp_andp2  {A}{NA: NatDed A}:
  forall B (p: A) (q: B -> A) , (p && exp q) = exp (fun x => p && q x).

Lemma imp_derives {A} {NA: NatDed A}:
  forall P P' Q Q' : A,
    P' |-- P ->
    Q |-- Q' ->
    P --> Q |-- P' --> Q'.

Lemma imp_right2: forall {A} {NA: NatDed A} (P Q : A), P |-- Q --> P.

Lemma  distrib_sepcon_andp {A}{ND: NatDed A}{SL: SepLog A}:
     forall P Q R, sepcon P (andp Q R) |-- andp (sepcon P Q) (sepcon P R).

Lemma later_derives {A}{ND: NatDed A}{IA: Indir A}:
   forall P Q: A, P |-- Q -> later P |-- later Q.

Lemma later_andp  {A}{ND: NatDed A}{IA: Indir A}:
       forall P Q: A, later (P && Q) = later P && later Q.

Lemma later_orp  {A}{ND: NatDed A}{IA: Indir A}:
       forall P Q: A, later (P || Q) = later P || later Q.

Lemma later_left2 {T}{ND: NatDed T}{IT: Indir T}:
 forall A B C : T, A && B |-- C -> A && |> B |-- |>C.

Lemma andp_dup {A}{ND: NatDed A}: forall P: A, P && P = P.

Lemma andp_TT {A}{NA: NatDed A}: forall (P: A), P && TT = P.

Lemma TT_prop_right {A}{ND: NatDed A}: forall P: Prop,
   P -> @derives A ND TT (prop P).

Lemma sepcon_andp_prop'  {A}{NA: NatDed A}{SA: SepLog A}:
     forall (P:A)  (Q:Prop) (R: A), (!!Q && P)*R = !!Q&&(P*R).

Lemma emp_sepcon  {A}{NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A} : forall (P:A),
   emp * P = P.

Lemma emp_wand {A}{NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall P: A, emp -* P = P.

Lemma TT_andp {A}{NA: NatDed A}: forall P: A,  TT && P = P.

Lemma prop_true_andp {A} {NA: NatDed A}:
  forall (P: Prop) (Q: A),  P -> (!! P && Q = Q).

Lemma prop_true_andp' (P: Prop) {A} {NA: NatDed A}:
  forall (Q: A),  P -> (!! P && Q = Q).

Lemma TT_andp_right {A}{NA: NatDed A}:
 forall P Q, TT |-- P -> TT |-- Q -> TT |-- P && Q.

Ltac immediate := (assumption || reflexivity).

Hint Rewrite @prop_true_andp using (solve [immediate]) : norm.

Lemma true_eq {A} {NA: NatDed A}:  forall P: Prop, P -> (!! P) = (TT: A).
Hint Rewrite @true_eq using (solve [immediate]) : norm.

Hint Rewrite @andp_dup : norm.

Lemma sepcon_TT {A} {NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall (P: A), P |-- (P * TT).
Hint Resolve @sepcon_TT.

Lemma TT_sepcon {A} {NA: NatDed A}{SA: SepLog A}{CA: ClassicalSep A}:
   forall (P: A), P |-- (TT * P).

Lemma imp_extract_exp_left {B A: Type} {NA: NatDed A}:
    forall    (p : B -> A) (q: A),
  (forall x, p x |-- q) ->
   exp p |-- q.

Hint Rewrite @sepcon_emp @emp_sepcon @TT_andp @andp_TT
             @exp_sepcon1 @exp_sepcon2
               @exp_andp1 @exp_andp2
         @sepcon_andp_prop @sepcon_andp_prop'
     using (solve [auto with typeclass_instances])
        : norm.

Lemma forall_pred_ext  {A}  {NA: NatDed A}: forall B (P Q: B -> A),
 (ALL x : B, (P x <--> Q x)) |-- (ALL x : B, P x) <--> (ALL x: B, Q x) .

Lemma exists_pred_ext  {A} {NA: NatDed A}: forall B (P Q: B -> A),
 (ALL x : B, (P x <--> Q x)) |-- (EX x : B, P x) <--> (EX x: B, Q x) .

Lemma imp_pred_ext  {A}  {NA: NatDed A}: forall B B' P Q,
       (B <--> B') && (B --> (P <--> Q))
 |-- (B --> P) <-->  (B' --> Q).

Lemma pull_right {A} {NA: NatDed A}{SA: SepLog A}:
 forall P Q R : A,
   (Q * P * R) = (Q * R * P).

Lemma pull_right0 {A} {NA: NatDed A}{SA: SepLog A}:
  forall P Q : A,   (P * Q) = (Q * P).

Ltac pull_left A := repeat (rewrite <- (pull_right A) || rewrite <- (pull_right0 A)).

Ltac pull_right A := repeat (rewrite (pull_right A) || rewrite (pull_right0 A)).

Lemma derives_extract_prop {A} {NA: NatDed A}:
  forall (P: Prop) (Q R: A), (P -> Q |-- R) ->  !!P && Q |-- R.

Lemma derives_extract_prop0 {A}{NA: NatDed A}:
    forall (P: Prop) (R: A), (P -> TT |-- R)  -> !!P |-- R.

Lemma derives_extract_prop' {A} {NA: NatDed A}:
  forall (P: Prop) (Q R: A), (P -> Q |-- R) ->  Q && !!P|-- R.

Lemma prop_imp {A} {ND: NatDed A}: forall (P: Prop) (Q: A), P -> !! P --> Q = Q.

Lemma andp_assoc' {A}{NA: NatDed A}:
  forall P Q R : A, Q && (P && R) = P && (Q && R).

Lemma corable_andp_sepcon2{A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  (Q && P) * R = P && (Q * R).

Lemma corable_sepcon_andp1 {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  Q  * (P && R) = P && (Q * R).

Lemma corable_sepcon_andp2 {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A}:
   forall P Q R : A, corable P ->  Q  * (R && P) = P && (Q * R).

Hint Resolve @corable_andp @corable_orp @corable_allp @corable_exp
                    @corable_imp @corable_prop @corable_sepcon @corable_wand @corable_later.
Hint Resolve @corable_prop : norm.

Lemma sepcon_left_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{CA: CorableSepLog A} (P Q: A), corable P -> (P * Q = (P && Q) * TT).

Lemma andp_left_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P Q: A), corable P -> P && Q = (P && emp) * Q.

Lemma TT_sepcon_TT: forall {A} `{ClassicalSep A}, TT * TT = TT.

Lemma not_prop_right: forall {A} {NA: NatDed A} (P: A) (Q: Prop), (Q -> derives P FF) -> derives P (prop (not Q)).

Lemma prop_and {A} {NA: NatDed A}:
    forall P Q: Prop, prop (P /\ Q) = (prop P && prop Q).

Lemma prop_impl {A} {NA: NatDed A}:
  forall P Q: Prop, prop (P -> Q) = (prop P --> prop Q).

Lemma prop_forall {A B} {NA: NatDed A}:
  forall P: B -> Prop, prop (forall b, P b) = ALL b: B, !! P b.

Lemma sepcon_prop_prop:
  forall {A} `{ClassicalSep A} P Q, !! P * !! Q = !! (P /\ Q).

Lemma corable_sepcon_TT: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P : A), corable P -> P * TT = P.

Lemma derives_left_sepcon_right_corable: forall {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{CA: CorableSepLog A} (P Q R: A), corable P -> (Q |-- P) -> Q * R |-- P.

Lemma later_prop_andp_sepcon: forall {A: Type} {A}{NA: NatDed A}{SA: SepLog A}{ClA: ClassicalSep A}{IA: Indir A}{CSL: CorableSepLog A} {CI: CorableIndir A} (P: Prop) (Q R: A),
((|> !! P) && Q) * R = (|> !! P) && (Q * R).

Lemma sepcon_corable_corable:
  forall {A} `{CorableSepLog A} {ClS: ClassicalSep A} P Q, corable P -> corable Q -> P * Q = P && Q.

Lemma prop_false_andp {A}{NA :NatDed A}:
 forall P Q, ~P -> !! P && Q = FF.

Lemma andp_prop_derives: forall {A} {NA: NatDed A} (P P': Prop) (Q Q': A),
  (P <-> P') ->
  (P -> Q |-- Q') ->
  !! P && Q |-- !! P' && Q'.

Lemma andp_prop_ext:
 forall {A}{NA: NatDed A} (P P': Prop) (Q Q': A),
  (P<->P') ->
  (P -> (Q=Q')) ->
  !! P && Q = !! P' && Q'.

Lemma prop_and_same_derives {A}{NA: NatDed A}:
  forall P Q, Q |-- !! P   ->   Q |-- !!P && Q.

Ltac normalize1 :=
         match goal with
            | |- _ => contradiction
            | |- context [@andp ?A (@LiftNatDed ?T ?B ?C) ?D ?E ?F] =>
                      change (@andp A (@LiftNatDed T B C) D E F) with (D F && E F)
            | |- context [@later ?A  (@LiftNatDed ?T ?B ?C) (@LiftIndir ?X1 ?X2 ?X3 ?X4 ?X5) ?D ?F] =>
                   change (@later A  (@LiftNatDed T B C) (@LiftIndir X1 X2 X3 X4 X5) D F)
                     with (@later B C X5 (D F))
            | |- context [@sepcon ?A (@LiftNatDed ?B ?C ?D)
                                                         (@LiftSepLog ?E ?F ?G ?H) ?J ?K ?L] =>
                   change (@sepcon A (@LiftNatDed B C D) (@LiftSepLog E F G H) J K L)
                      with (@sepcon C D H (J L) (K L))
            | |- context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) by (auto with norm)
            | |- context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) by (auto with norm)
            | |- context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) by (auto with norm)
            | |- context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) by (auto with norm)
                        | |- context [andp (exp (fun y => _)) _] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [andp _ (exp (fun y => _))] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [sepcon (exp (fun y => _)) _] =>
               autorewrite with norm; apply imp_extract_exp_left; intro y
            | |- context [sepcon _ (exp (fun y => _))] =>
                autorewrite with norm; apply imp_extract_exp_left; intro y

           | |-  derives ?A   _ => match A with
                          | context [ ((!! ?P) && ?Q) && ?R ] => rewrite (andp_assoc (!!P) Q R)
                          | context [ ?Q && (!! ?P && ?R)] =>
                                         match Q with !! _ => fail 2 | _ => rewrite (andp_assoc' (!!P) Q R) end
                         end
            | |- _ => progress  (autorewrite with norm); auto with typeclass_instances
            | |- _ = ?x -> _ => intro; subst x
            | |- ?x = _ -> _ => intro; subst x
            |  |- ?ZZ -> _ => match type of ZZ with
                                               | Prop =>
                                                    let H := fresh in
                                                       ((assert (H:ZZ) by auto; clear H; intros _) || intro H)
                                               | _ => intros _
                                              end
            | |- forall _, _ => let x := fresh "x" in (intro x; normalize1; try generalize dependent x)
            | |- exp _ |-- _ => apply imp_extract_exp_left
            | |- !! _ |-- _ => apply derives_extract_prop0
            | |- !! _ && _ |-- _ => apply derives_extract_prop
            | |- _ && !! _ |-- _ => apply derives_extract_prop'
            | |- _ |-- !! (?x = ?y) && _ =>
                            (rewrite prop_true_andp with (P:= (x=y))
                                            by (unfold y; reflexivity); unfold y in *; clear y) ||
                            (rewrite prop_true_andp with (P:=(x=y))
                                            by (unfold x; reflexivity); unfold x in *; clear x)
            | |- TT |-- !! _ => apply TT_prop_right
            | |- _ => solve [auto with typeclass_instances]
            end.

Ltac normalize1_in Hx :=
             match type of Hx with
                 | context [@andp ?A (@LiftNatDed ?T ?B ?C) ?D ?E ?F] =>
                         change (@andp A (@LiftNatDed T B C) D E F) with (D F && E F)
                 | context [@later ?A  (@LiftNatDed ?T ?B ?C) (@LiftIndir ?X1 ?X2 ?X3 ?X4 ?X5) ?D ?F] =>
                    change (@later A  (@LiftNatDed T B C) (@LiftIndir X1 X2 X3 X4 X5) D F)
                     with (@later B C X5 (D F))
                 | context [@sepcon ?A (@LiftNatDed ?B ?C ?D)
                                                         (@LiftSepLog ?E ?F ?G ?H) ?J ?K ?L] =>
                   change (@sepcon A (@LiftNatDed B C D) (@LiftSepLog E F G H) J K L)
                      with (@sepcon C D H (J L) (K L))
                | context [ !! ?P ] =>
                                    rewrite (true_eq P) in Hx by auto with typeclass_instances
                | context [ !! ?P && ?Q ] =>
                                    rewrite (prop_true_andp P Q) in Hx by auto with typeclass_instances
                | context [(?P && ?Q) * ?R] => rewrite (corable_andp_sepcon1 P Q R) in Hx by (auto with norm)
                | context [?Q * (?P && ?R)] => rewrite (corable_sepcon_andp1 P Q R) in Hx by (auto with norm)
                | context [(?Q && ?P) * ?R] => rewrite (corable_andp_sepcon2 P Q R) in Hx by (auto with norm)
                | context [?Q * (?R && ?P)] => rewrite (corable_sepcon_andp2 P Q R) in Hx by (auto with norm)
                | _ => progress  (autorewrite with norm in Hx); auto with typeclass_instances
                end.

Ltac normalize := repeat (auto with norm; normalize1).

Tactic Notation "normalize" "in" hyp(H) := repeat (normalize1_in H).

Lemma guarded_sepcon_orp_distr {A}{ND: NatDed A}{SL: SepLog A}: forall (P1 P2: Prop) p1 p2 q1 q2,
  (P1 -> P2 -> False) ->
  (!! P1 && p1 || !! P2 && p2) * (!! P1 && q1 || !! P2 && q2) = !! P1 && (p1 * q1) || !! P2 && (p2 * q2).

Definition mark {A: Type} (i: nat) (j: A) := j.

Lemma swap_mark1 {A} {NA: NatDed A}{SA: SepLog A}:
  forall i j (Pi Pj B : A), (i<j)%nat -> B * mark i Pi * mark j Pj = B * mark j Pj * mark i Pi.

Lemma swap_mark0 {A} {NA: NatDed A}{SA: SepLog A}:
  forall i j (Pi Pj: A),  (i<j)%nat -> mark i Pi * mark j Pj = mark j Pj * mark i Pi.

Ltac select_left n :=
  repeat match goal with
 | |- context [(_ * mark ?i _ * mark n _)] =>
      rewrite (swap_mark1 i n); [ | solve [simpl; auto]]
 | |- context [(mark ?i _ * mark n _)] =>
      rewrite (swap_mark0 i n); [ | solve [simpl; auto]]
end.
Ltac select_all n := match n with
                                | O => idtac
                                | S ?n' => select_left n; select_all n'
                              end.
Ltac markem n P :=
   match P with
   | (?Y * ?Z) =>
        (match goal with H: mark _ Z = Z |- _ => idtac end
        || assert (mark n Z = Z) by auto); markem (S n) Y
   | ?Z =>  match goal with H: mark _ Z = Z |- _ => idtac end
                || assert (mark n Z = Z) by auto
  end.

Ltac prove_assoc_commut :=
 clear;
 try (match goal with |- ?F _ -> ?G _ => replace G with F; auto end);
  (repeat rewrite <- sepcon_assoc;
   match goal with |- ?P = _ => markem O P end;
   let LEFT := fresh "LEFT" in match goal with |- ?P = _ => set (LEFT := P) end;
  match goal with H: mark ?n _ = _ |- _ =>
     repeat  match goal with H: mark ?n _ = ?P |- _ => rewrite <- H; clear H end;
     select_all n;
     reflexivity
   end).

Lemma test_prove_assoc_commut {T}{NA: NatDed T}{SA: SepLog T} : forall A B C D E : T,
   D * E * A * C * B = A * B * C * D * E.

Require Import VST.msl.alg_seplog.

Lemma later_fash1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall P : A, |> # P |-- # |> P.

Lemma subp_later1 {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P >=> Q)  |--   |>P >=> |>Q.

Lemma subp_later {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P >=> Q) = |>P >=> |>Q.

Lemma eqp_later1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall P Q : A,
   |>(P <=> Q)  |--   |>P <=> |>Q.

Lemma eqp_later {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall P Q: A,
    (|>(P <=> Q) = |>P <=> |>Q).

Lemma subp_refl {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P : A),
  G |-- P >=> P.

Lemma subp_trans {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P Q R: A),
  G |-- P >=> Q ->
  G |-- Q >=> R ->
  G |-- P >=> R.

Lemma subp_top {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P: A),
  G |-- P >=> TT.

Lemma subp_bot {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P: A),
  G |-- FF >=> P.

Lemma subp_andp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G {P P' Q Q': A},
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- P && Q >=> (P' && Q').

Lemma subp_imp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P P' Q Q' : A),
  G |-- P' >=> P ->
  G |-- Q >=> Q' ->
  G |-- (P --> Q) >=> (P' --> Q').

Lemma subp_orp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}  : forall G (P P' Q Q' : A),
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- (P || Q) >=> (P' || Q').

Lemma subp_subp {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
  forall G (P Q R S: A),
   G |-- (R >=> P) ->
   G |-- (Q >=> S) ->
   G |-- (P >=> Q) >=> (R >=> S).

Lemma allp_imp2_later_e2 {B}{A}{NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall (P Q: B -> A) (y: B) ,
      (ALL x:B, |> P x <=> |> Q x) |-- |> Q y >=> |> P y.

Lemma allp_imp2_later_e1 {B}{A}{NA: NatDed A}{IA: Indir A}{RA: RecIndir A}:
   forall (P Q: B -> A) (y: B) ,
      (ALL x:B, |> P x <=> |> Q x) |-- |> P y >=> |> Q y.

Lemma prove_HOcontractive1 {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall X F,
  (forall P Q: X -> A,
    (ALL x:X, |>(P x >=> Q x) |--
        ALL x:X, F P x >=> F Q x)) ->
   HOcontractive F.

Lemma prove_HOcontractive {A} {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall X F,
  (forall (P Q: X -> A) (x: X),
    (ALL x:X, (|> P x <=> |> Q x) |-- F P x >=> F Q x)) ->
   HOcontractive F.

Lemma sub_sepcon' {A}{NA: NatDed A}{SL: SepLog A}{IA: Indir A}{RA: RecIndir A}{SRA: SepRec A}:
  forall P P' Q Q': A, (P >=> P') && (Q >=> Q') |-- (P * Q) >=> (P' * Q').

Lemma subp_sepcon {A} {NA: NatDed A}{IA: Indir A}{SA: SepLog A}{SI: SepIndir A}{RA: RecIndir A}{SRA: SepRec A} :
    forall G (P P' Q Q' : A),
  G |-- P >=> P' ->
  G |-- Q >=> Q' ->
  G |-- P * Q >=> P' * Q'.

Ltac sub_unfold :=
   match goal with
    | |- _ |-- ?A _ >=> ?A _ => unfold A
    | |- _ |-- ?A _ _ >=> ?A _ _ => unfold A
    | |- _ |-- ?A _ _ _ >=> ?A _ _ _ => unfold A
    | |- _ |-- ?A _ _ _ _ >=> ?A _ _ _ _ => unfold A
    | |- _ |-- ?A _ _ _ _ _ >=> ?A _ _ _ _ _ => unfold A
    | v: _ |- _ => destruct v
   end.

Hint Extern 2 (_ |-- _ >=> _) => sub_unfold : contractive.

Hint Resolve @prove_HOcontractive
  @subp_allp @subp_imp @subp_refl @subp_exp @subp_andp @subp_orp @subp_subp
  @subp_sepcon 
  @allp_imp2_later_e1 @allp_imp2_later_e2 : contractive.

Lemma  goedel_loeb {A}  {NA: NatDed A}{IA: Indir A}:
    forall P Q : A ,   Q && later P |-- P ->  Q |-- P.

Lemma HORec_sub {A}  {NA: NatDed A}{IA: Indir A}{RA: RecIndir A} : forall G B
  (F : A -> (B -> A) -> B -> A)
  (HF1 : forall X, HOcontractive (F X))
  (HF2 : forall R a (P Q: A), P >=> Q |-- F P R a >=> F Q R a)
  (HF3 : forall (P Q: B -> A) X, ALL b:B, |>(P b >=> Q b) |-- ALL b:B, F X P b >=> F X Q b),
  forall P Q : A,
    G |-- P >=> Q ->
    G |-- ALL b:B, HORec (F P) b >=> HORec (F Q) b.

Require Import VST.msl.ghost_seplog.

Lemma bupd_andp2_corable: forall {A N D: Type} {ND : NatDed A} {SL : SepLog A} {CSL: ClassicalSep A} {BS : BupdSepLog A N D} {CoSL: CorableSepLog A},
  forall P Q, corable Q -> (|==> P) && Q |-- |==> (P && Q). *)



Local Open Scope logic.



Lemma modus_ponens_wand' {A}{ND: NatDed A}{SL: SepLog A}:

                      forall P P' Q: A, P |-- P' ->  derives (sepcon P (wand P' Q)) Q.

Proof.

intros.

   eapply derives_trans; [apply sepcon_derives; [ | apply derives_refl] | apply modus_ponens_wand ].

  auto.

Qed.



Module RAMIF_PLAIN.

Section RAMIF_PLAIN.



Context {A : Type}.

Context {ND : NatDed A}.

Context {SL : SepLog A}.



Lemma solve: forall g l g' l' F, g |-- l * F -> F * l' |-- g' -> g |-- l * (l' -* g').

Proof.

  intros.

  apply derives_trans with (l * F); auto.

  apply sepcon_derives; auto.

  apply wand_sepcon_adjoint.

  auto.

Qed.



Lemma weak_ramif_spec: forall g l g' l', g |-- l * (l' -* g') -> g |-- l * TT.

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply sepcon_derives; auto.

  apply TT_right.

Qed.



Lemma trans: forall g m l g' m' l',

      g |-- m * (m' -* g') ->

      m |-- l * (l' -* m') ->

      g |-- l * (l' -* g').

Proof.

  intros.

  apply solve with ((l' -* m') * (m' -* g')).

  + eapply derives_trans; [exact H |].

    eapply derives_trans; [apply sepcon_derives; [exact H0 | apply derives_refl] |].

    rewrite sepcon_assoc; auto.

  + rewrite (sepcon_comm _ l'), <- sepcon_assoc.

    eapply derives_trans; [| apply modus_ponens_wand].

    apply sepcon_derives; [| apply derives_refl].

    apply modus_ponens_wand.

Qed.



Lemma trans':

   forall (m l g' m' l': A),

       m |-- l * (l' -* m') ->

       m * (m' -* g') |-- l * (l' -* g').

Proof.

  intros. eapply trans. apply derives_refl. auto.

Qed.



Lemma trans'':

   forall (p g' m' l': A),

       p |-- l' -* m' ->

       p * (m' -* g') |-- (l' -* g').

Proof.

  intros.

  rewrite -> wand_sepcon_adjoint.

  eapply derives_trans; [apply H | ]. clear H.

  rewrite <- wand_sepcon_adjoint.

  rewrite <- wand_sepcon_adjoint.

  pull_left l'. apply modus_ponens_wand'. apply modus_ponens_wand.

Qed.



Lemma split: forall g1 g2 l1 l2 g1' g2' l1' l2',

  g1 |-- l1 * (l1' -* g1') ->

  g2 |-- l2 * (l2' -* g2') ->

  g1 * g2 |-- (l1 * l2) * (l1' * l2' -* g1' * g2').

Proof.

  intros.

  apply solve with ((l1' -* g1') * (l2' -* g2')).

  + rewrite (sepcon_assoc l1), <- (sepcon_assoc l2), (sepcon_comm l2), (sepcon_assoc _ l2), <- (sepcon_assoc l1).

    apply sepcon_derives; auto.

  + eapply derives_trans; [apply sepcon_derives; [apply wand_sepcon_wand | apply derives_refl] |].

    rewrite sepcon_comm; apply modus_ponens_wand.

Qed.



Lemma frame: forall g l g' l' F, g |-- l * (l' -* g') -> g * F |-- l * (l' -* g' * F).

Proof.

  intros.

  apply solve with ((l' -* g') * F).

  + rewrite <- sepcon_assoc.

    apply sepcon_derives; auto.

  + rewrite (sepcon_comm _ l'), <- sepcon_assoc.

    apply sepcon_derives; [apply modus_ponens_wand | auto].

Qed.



Lemma frame_post: forall g l g' l' F, g |-- l * (l' -* g') -> g |-- l * (l' * F -* g' * F).

Proof.

  intros.

  apply solve with (l' -* g').

  + auto.

  + rewrite <- sepcon_assoc.

    apply sepcon_derives; [rewrite sepcon_comm; apply modus_ponens_wand | auto].

Qed.



Lemma frame_pre: forall g l g' l' F, g |-- l * (l' -* g') -> g * F |-- (l * F) * (l' -* g').

Proof.

  intros.

  apply solve with (l' -* g').

  + rewrite (sepcon_comm l F), sepcon_assoc, (sepcon_comm F).

    apply sepcon_derives; auto.

  + rewrite sepcon_comm; apply modus_ponens_wand.

Qed.



Lemma exp_right: forall {T} (a: T) g l g' l',

  g |-- l * (l' -* g' a) ->

  g |-- l * (l' -* exp g').

Proof.

  intros.

  apply solve with (l' -* g' a); auto.

  apply wand_sepcon_adjoint.

  apply wand_derives; auto.

  apply (exp_right a); auto.

Qed.



End RAMIF_PLAIN.

End RAMIF_PLAIN.



Module RAMIF_Q.

Section RAMIF_Q.



Context {A : Type}.

Context {ND : NatDed A}.

Context {SL : SepLog A}.



Lemma reduce: forall {B} g l (g' l': B -> A),

  g |-- l * (allp (l' -* g')) ->

  g |-- l * (exp l' -* exp g').

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply sepcon_derives; [auto |].

  apply wand_sepcon_adjoint.

  rewrite exp_sepcon2.

  apply exp_left; intro x; apply (exp_right x).

  apply wand_sepcon_adjoint.

  apply (allp_left _ x).

  apply derives_refl.

Qed.



Lemma solve: forall {B} g l g' l' F,

  g |-- l * F ->

  (forall x: B, F * l' x |-- g' x) ->

  g |-- l * (allp (l' -* g')).

Proof.

  intros.

  apply derives_trans with (l * F); auto.

  apply sepcon_derives; auto.

  apply allp_right; intro x.

  simpl;

  apply wand_sepcon_adjoint.

  apply H0.

Qed.



Lemma weak_ramif_spec: forall {B} g l (g' l': B -> A),

  g |-- l * allp (l' -* g') -> g |-- l * TT.

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply sepcon_derives; auto.

  apply TT_right.

Qed.



Lemma plain_spec: forall {B} g l g' l' (x: B),

  g |-- l * (allp (l' -* g')) ->

  g |-- l *  (l' x -* g' x).

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply sepcon_derives; [auto |].

  apply (allp_left _ x). apply derives_refl.

Qed.



Lemma trans: forall {B BG BL} g m l g' mG' mL' l' (fG: B -> BG) (fL: B -> BL),

  (forall b, mL' (fL b) |-- mG' (fG b)) ->

  g |-- m * allp (mG' -* g') ->

  m |-- l * allp (l' -* mL') ->

  g |-- l * allp (Basics.compose l' fL -* Basics.compose g' fG).

Proof.

  intros.

  apply solve with (allp (l' -* mL') * allp (mG' -* g')); auto.

  + eapply derives_trans; [exact H0 |].

    eapply derives_trans; [apply sepcon_derives; [exact H1 | apply derives_refl] |].

    rewrite sepcon_assoc; auto.

  + intro b.

    rewrite sepcon_assoc.

    apply wand_sepcon_adjoint.

    apply (allp_left _ (fL b)).

    apply wand_sepcon_adjoint.

    rewrite sepcon_comm, sepcon_assoc, sepcon_comm.

    apply wand_sepcon_adjoint.

    apply derives_trans with (mG' (fG b)).

    - eapply derives_trans; [| apply H].

      simpl; apply modus_ponens_wand.

    - apply wand_sepcon_adjoint.

      rewrite sepcon_comm.

      apply wand_sepcon_adjoint.

      apply (allp_left _ (fG b)).

      apply derives_refl.

Qed.



Lemma simple_trans: forall {B} g m l (g' m' l': B -> A),

  g |-- m * allp (m' -* g') ->

  m |-- l * allp (l' -* m') ->

  g |-- l * allp (l' -* g').

Proof.

  intros.

  eapply trans with (mL' := m') (mG' := m') (fL := id B) (fG := id B); eauto.

Qed.



Lemma trans'':

  forall {CS: ClassicalSep A}

     {B C: Type} (f: B->C) p l m g1 g2,

     g2 = g1 oo f ->

     p |-- allp (l -* m oo f) ->

     p * allp (m -* g1) |-- allp (l -* g2).

Proof.

   intros.

   subst g2.

   apply allp_right; intro x.

   simpl. rewrite <- wand_sepcon_adjoint.

   rewrite sepcon_assoc.

   eapply derives_trans; [apply sepcon_derives; [apply H0 | apply derives_refl] | ].

    rewrite -> wand_sepcon_adjoint.

  apply allp_left with x.

   rewrite <- wand_sepcon_adjoint.

   simpl.

   rewrite <- !sepcon_assoc.

   pull_left (l x).

   eapply derives_trans; [apply sepcon_derives; [ | apply derives_refl] | ].

   apply modus_ponens_wand.

   rewrite sepcon_comm.

   rewrite -> wand_sepcon_adjoint.

   apply allp_left with (f x). apply derives_refl.

Qed.



Lemma split: forall {B} g1 g2 l1 l2 (g1' g2' l1' l2': B -> A),

  g1 |-- l1 * allp (l1' -* g1') ->

  g2 |-- l2 * allp (l2' -* g2') ->

  g1 * g2 |-- (l1 * l2) * allp (l1' * l2' -* g1' * g2').

Proof.

  intros.

  apply solve with (allp (l1' -* g1') * allp (l2' -* g2')).

  + rewrite (sepcon_assoc l1), <- (sepcon_assoc l2), (sepcon_comm l2), (sepcon_assoc _ l2), <- (sepcon_assoc l1).

    apply sepcon_derives; auto.

  + intros x.

    change ((l1' * l2') x) with (l1' x * l2' x).

    rewrite <- (sepcon_assoc _ (l1' x)), (sepcon_assoc _ _ (l1' x)), (sepcon_comm _ (l1' x)), <- (sepcon_assoc _ (l1' x)), (sepcon_assoc _ _ (l2' x)).

    apply sepcon_derives.

    - apply wand_sepcon_adjoint.

      apply (allp_left _ x); apply derives_refl.

    - apply wand_sepcon_adjoint.

      apply (allp_left _ x).

      apply derives_refl.

Qed.



Lemma frame: forall {B} g l (g' l': B -> A) F,

  g |-- l * allp (l' -* g') ->

  g * F |-- l * allp (l' -* g' * Basics.const F).

Proof.

  intros.

  apply solve with (allp (l' -* g') * F).

  + rewrite <- sepcon_assoc.

    apply sepcon_derives; auto.

  + intros x; unfold Basics.const; simpl.

    rewrite (sepcon_comm _ (l' x)), <- sepcon_assoc.

    apply sepcon_derives; [| auto].

    rewrite sepcon_comm; apply wand_sepcon_adjoint.

    apply (allp_left _ x); auto.

Qed.



Lemma frame_post: forall {B} g l (g' l' F: B -> A),

  g |-- l * allp (l' -* g') ->

  g |-- l * allp (l' * F -* g' * F).

Proof.

  intros.

  apply solve with (allp (l' -* g')).

  + auto.

  + intros x; simpl.

    rewrite <- sepcon_assoc.

    apply sepcon_derives; [rewrite sepcon_comm | auto].

    rewrite sepcon_comm; apply wand_sepcon_adjoint.

    apply (allp_left _ x); auto.

Qed.



Lemma frame_pre: forall {B} g l (g' l': B -> A) F,

  g |-- l * allp (l' -* g') ->

  g * F |-- (l * F) * allp (l' -* g').

Proof.

  intros.

  apply solve with (allp (l' -* g')).

  + rewrite (sepcon_comm l F), sepcon_assoc, (sepcon_comm F).

    apply sepcon_derives; auto.

  + intros x.

    apply wand_sepcon_adjoint.

    apply (allp_left _ x); apply derives_refl.

Qed.



Lemma exp_right: forall {T B} (a: B -> T) g l (g': T -> B -> A) (l': B -> A),

  g |-- l * allp (l' -* (fun b => g' (a b) b)) ->

  g |-- l * allp (l' -* exp g').

Proof.

  intros.

  apply solve with (allp (l' -* (fun b => g' (a b) b))); auto.

  intros.

  apply wand_sepcon_adjoint.

  apply (allp_left _ x).

  simpl.

  apply wand_derives; auto.

  apply (exp_right (a x)); auto.

Qed.



End RAMIF_Q.



Ltac formalize :=

  match goal with

  | |- @derives ?Pred _ ?g (?l * @allp ?Pred _ ?T ?Func) =>

      let g' := fresh "g'" in evar (g': T -> Pred);

      let l' := fresh "l'" in evar (l': T -> Pred);

      let x := fresh "x" in

      let H := fresh "H" in

      assert (Func = l' -* g') as H;

      [

        extensionality x; cbv beta;

        match goal with

        | |- ?L' -* exp ?G' = _ =>

             super_pattern L' x; super_pattern_in_func G' x

        | |- ?L' -* ?G' = _ =>

             super_pattern L' x; super_pattern G' x

        end;

        match goal with

        | |- ?L' _ -* exp (fun a => ?G' a _) = _ =>

             instantiate (1 := L') in (Value of l');

             instantiate (1 := exp G') in (Value of g')

        | |- ?L' _ -* ?G' _ = _ =>

             instantiate (1 := L') in (Value of l');

             instantiate (1 := G') in (Value of g')

        end;

        subst g' l';

        reflexivity

      | subst g' l'; rewrite H; clear H]

  end.



End RAMIF_Q.



Module RAMIF_Q'.

Section RAMIF_Q'.



Context {A : Type}.

Context {ND : NatDed A}.

Context {SL : SepLog A}.

Context {CoSL: CorableSepLog A}.



Lemma reduce: forall {B} g l p (g' l': B -> A),

  corable p ->

  g |-- l * (allp (p --> (l' -* g'))) ->

  g |-- l * (exp (p && l') -* exp (p && g')).

Proof.

  intros.

  eapply derives_trans; [exact H0 |].

  apply sepcon_derives; [auto |].

  apply wand_sepcon_adjoint.

  rewrite exp_sepcon2.

  apply exp_left; intro x; apply (exp_right x).

  apply wand_sepcon_adjoint.

  apply (allp_left _ x).

  simpl.

  apply wand_sepcon_adjoint.

  rewrite corable_sepcon_andp1 by auto.

  apply andp_right; [apply andp_left1; auto |].

  rewrite <- corable_andp_sepcon1 by auto.

  apply wand_sepcon_adjoint.

  apply modus_ponens.

Qed.



Lemma solve: forall {B} g l p g' l' F,

  corable p ->

  g |-- l * F ->

  (forall x: B, (p x) && (F * l' x) |-- g' x) ->

  g |-- l * (allp (p --> (l' -* g'))).

Proof.

  intros.

  apply derives_trans with (l * F); auto.

  apply sepcon_derives; auto.

  apply allp_right; intro x.

  simpl.

  apply imp_andp_adjoint.

  apply wand_sepcon_adjoint.

  rewrite corable_andp_sepcon2 by auto.

  auto.

Qed.



Lemma weak_ramif_spec: forall {B} g l p (g' l': B -> A),

  g |-- l * allp (p --> l' -* g') -> g |-- l * TT.

Proof.

  intros.

  eapply derives_trans; [exact H |].

  apply sepcon_derives; auto.

  apply TT_right.

Qed.



Lemma plain_spec: forall {B} g l p g' l' (x: B),

  corable p ->

  g |-- p x ->

  g |-- l * allp (p --> (l' -* g')) ->

  g |-- l * (l' x -* g' x).

Proof.

  intros.

  rewrite (add_andp _ _ H1).

  rewrite (add_andp _ _ H0).

  rewrite andp_assoc; apply andp_left2.

  rewrite <- corable_sepcon_andp1 by auto.

  apply sepcon_derives; [auto |].

  rewrite andp_comm; apply imp_andp_adjoint.

  apply (allp_left _ x); apply derives_refl.

Qed.



Lemma trans: forall {B BG BL} g m l p pG pL g' mG' mL' l' (fG: B -> BG) (fL: B -> BL),

  corable p ->

  corable pL ->

  corable pG ->

  g |-- m * allp (pG --> (mG' -* g')) ->

  m |-- l * allp (pL --> (l' -* mL')) ->

  (forall b, p b |-- pL (fL b)) ->

  (forall b, p b && mL' (fL b) |-- pG (fG b) && mG' (fG b)) ->

  g |-- l * allp (p --> (Basics.compose l' fL -* Basics.compose g' fG)).

Proof.

  intros.

  apply solve with (allp (pL --> (l' -* mL')) * allp (pG --> (mG' -* g'))).

  + simpl; unfold Basics.compose.

    auto.

  + eapply derives_trans; [exact H2 |].

    eapply derives_trans; [apply sepcon_derives; [exact H3 | apply derives_refl] |].

    rewrite sepcon_assoc; auto.

  + intro b.

    unfold Basics.compose.

    rewrite <- !corable_andp_sepcon1 by auto.

    rewrite sepcon_assoc.

    apply wand_sepcon_adjoint.

    rewrite andp_comm; apply imp_andp_adjoint.

    apply (allp_left _ (fL b)); apply imp_andp_adjoint.

    apply wand_sepcon_adjoint.

    rewrite sepcon_comm, sepcon_assoc, sepcon_comm.

    apply wand_sepcon_adjoint.

    apply derives_trans with (pG (fG b) && mG' (fG b)).

    - apply derives_trans with (p b && mL' (fL b)); [| apply H5].

      rewrite corable_sepcon_andp2 by auto.

      apply andp_right; [apply andp_left1; auto |].

      rewrite <- corable_sepcon_andp1 by auto.

      rewrite sepcon_comm.

      apply wand_sepcon_adjoint.

      simpl; eapply derives_trans; [| apply modus_ponens].

      apply andp_derives; [apply H4 | apply derives_refl].

    - apply wand_sepcon_adjoint.

      rewrite sepcon_comm.

      apply wand_sepcon_adjoint.

      apply (allp_left _ (fG b)); simpl.

      apply wand_sepcon_adjoint.

      rewrite corable_sepcon_andp1, <- corable_andp_sepcon1 by auto.

      apply wand_sepcon_adjoint.

      apply modus_ponens.

Qed.



Lemma split: forall {B} g1 g2 l1 l2 (p g1' g2' l1' l2': B -> A),

  (forall x: B, corable (p x)) ->

  g1 |-- l1 * allp (p --> (l1' -* g1')) ->

  g2 |-- l2 * allp (p --> (l2' -* g2')) ->

  g1 * g2 |-- (l1 * l2) * allp (p --> (l1' * l2' -* g1' * g2')).

Proof.

  intros.

  apply solve with (allp (p --> (l1' -* g1')) * allp (p --> (l2' -* g2'))).

  + auto.

  + rewrite (sepcon_assoc l1), <- (sepcon_assoc l2), (sepcon_comm l2), (sepcon_assoc _ l2), <- (sepcon_assoc l1).

    apply sepcon_derives; auto.

  + intros x.

    change ((l1' * l2') x) with (l1' x * l2' x).

    rewrite <- (sepcon_assoc _ (l1' x)), (sepcon_assoc _ _ (l1' x)), (sepcon_comm _ (l1' x)), <- (sepcon_assoc _ (l1' x)), (sepcon_assoc _ _ (l2' x)).

    rewrite <- (andp_dup (p x)), andp_assoc.

    rewrite <- corable_sepcon_andp1, <- corable_andp_sepcon1 by auto.

    rewrite <- !corable_sepcon_andp1 by auto.

    apply sepcon_derives.

    - apply wand_sepcon_adjoint.

      apply (allp_left _ x).

      apply wand_sepcon_adjoint.

      rewrite corable_sepcon_andp1, <- corable_andp_sepcon1 by auto.

      (eapply derives_trans; [apply sepcon_derives; [simpl; intros; apply modus_ponens | apply derives_refl] |]).

      apply wand_sepcon_adjoint; apply derives_refl.

    - apply wand_sepcon_adjoint.

      apply (allp_left _ x).

      apply wand_sepcon_adjoint.

      rewrite corable_sepcon_andp1, <- corable_andp_sepcon1 by auto.

      (eapply derives_trans; [apply sepcon_derives; [simpl; intros; apply modus_ponens | apply derives_refl] |]).

      apply wand_sepcon_adjoint; apply derives_refl.

Qed.



Lemma frame: forall {B} g l p g' l' F,

  (forall x: B, corable (p x)) ->

  g |-- l * allp (p --> (l' -* g')) ->

  g * F |-- l * allp (p --> (l' -* g' * Basics.const F)).

Proof.

  intros.

  apply solve with (allp (p --> (l' -* g')) * F).

  + auto.

  + rewrite <- sepcon_assoc.

    apply sepcon_derives; auto.

  + intros x; unfold Basics.const; simpl.

    rewrite <- !corable_andp_sepcon1 by auto.

    rewrite (sepcon_comm _ (l' x)), <- sepcon_assoc.

    apply sepcon_derives; [| auto].

    rewrite sepcon_comm; apply wand_sepcon_adjoint.

    rewrite andp_comm; apply imp_andp_adjoint; apply (allp_left _ x); apply imp_andp_adjoint.

    rewrite andp_comm; apply modus_ponens.

Qed.



Lemma frame_post: forall {B} g l (p g' l' F: B -> A),

  (forall x: B, corable (p x)) ->

  g |-- l * allp (p --> (l' -* g')) ->

  g |-- l * allp (p --> (l' * F -* g' * F)).

Proof.

  intros.

  apply solve with (allp (p --> (l' -* g'))).

  + auto.

  + auto.

  + intros x; simpl.

    rewrite <- !corable_andp_sepcon1 by auto.

    rewrite <- sepcon_assoc.

    apply sepcon_derives; [rewrite sepcon_comm | auto].

    rewrite sepcon_comm; apply wand_sepcon_adjoint.

    rewrite andp_comm; apply imp_andp_adjoint; apply (allp_left _ x); apply imp_andp_adjoint.

    rewrite andp_comm; apply modus_ponens.

Qed.



Lemma frame_pre: forall {B} g l (p g' l': B -> A) F,

  (forall x: B, corable (p x)) ->

  g |-- l * allp (p --> (l' -* g')) ->

  g * F |-- (l * F) * allp (p --> (l' -* g')).

Proof.

  intros.

  apply solve with (allp (p --> (l' -* g'))).

  + auto.

  + rewrite (sepcon_comm l F), sepcon_assoc, (sepcon_comm F).

    apply sepcon_derives; auto.

  + intros x; simpl.

    rewrite <- !corable_andp_sepcon1 by auto.

    apply wand_sepcon_adjoint.

    rewrite andp_comm; apply imp_andp_adjoint; apply (allp_left _ x); apply imp_andp_adjoint.

    rewrite andp_comm; apply modus_ponens.

Qed.



Lemma exp_right: forall {T B} (a: B -> T) p g l (g': T -> B -> A) (l': B -> A),

  corable p ->

  g |-- l * allp (p --> (l' -* (fun b => g' (a b) b))) ->

  g |-- l * allp (p --> (l' -* exp g')).

Proof.

  intros.

  apply solve with (allp (p --> (l' -* (fun b => g' (a b) b)))); auto.

  intros.

  rewrite <- corable_sepcon_andp1 by auto.

  apply wand_sepcon_adjoint.

  apply (allp_left _ x).

  simpl.

  apply wand_sepcon_adjoint.

  rewrite corable_sepcon_andp1 by auto.

  rewrite <- corable_andp_sepcon1 by auto.

  eapply derives_trans; [apply sepcon_derives; [apply modus_ponens | apply derives_refl] |].

  apply wand_sepcon_adjoint.

  apply wand_derives; auto.

  apply (exp_right (a x)); auto.

Qed.



End RAMIF_Q'.



Ltac formalize :=

  match goal with

  | |- @derives ?Pred _ ?g (?l * @allp ?Pred _ ?T ?Func) =>

      let p := fresh "p" in evar (p: T -> Pred);

      let g' := fresh "g'" in evar (g': T -> Pred);

      let l' := fresh "l'" in evar (l': T -> Pred);

      let x := fresh "x" in

      let H := fresh "H" in

      assert (Func = p --> (l' -* g'));

      [

        extensionality x; cbv beta;

        match goal with

        | |- ?P --> (?L' -* exp ?G') = _ =>

             super_pattern P x; super_pattern L' x; super_pattern_in_func G' x

        | |- ?P --> (?L' -* ?G') = _ =>

             super_pattern P x; super_pattern L' x; super_pattern G' x

        end;

        match goal with

        | |- ?P _ --> (?L' _ -* exp (fun a => ?G' a _)) = _ =>

             instantiate (1 := P) in (Value of p);

             instantiate (1 := L') in (Value of l');

             instantiate (1 := exp G') in (Value of g')

        | |- ?P _ --> (?L' _ -* ?G' _) = _ =>

             instantiate (1 := P) in (Value of p);

             instantiate (1 := L') in (Value of l');

             instantiate (1 := G') in (Value of g')

        end;

        subst p g' l';

        reflexivity

      | subst p g' l'; rewrite H; clear H]

  end.



End RAMIF_Q'.

