Require Import ZArith List.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import veristar.variables.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)



Definition var : Type := Ident.t.



Inductive expr := Nil | Var : var -> expr.



Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.



Inductive space_atom :=

| Next : expr -> expr -> space_atom

| Lseg : expr -> expr -> space_atom.



Inductive assertion : Type :=

  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.



Inductive entailment : Type :=

  Entailment : assertion -> assertion -> entailment.



Definition subst_var (i: var) (t: expr) (j: var) :=

  if Ident.eq_dec i j then t else Var j.



Definition subst_expr (i: var) (t: expr) (t': expr) :=

  match t' with

    | Nil => Nil

    | Var j => if Ident.eq_dec i j then t else t'

  end.



Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=

 match a with

   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)

   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)

 end.



Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)

  : list pn_atom := map (subst_pn i t) pa.



Definition subst_space (i: var) (t: expr) (a: space_atom) :=

  match a with

    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)

    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)

  end.



Definition subst_spaces (i: var) (t: expr)

  : list space_atom -> list space_atom := map (subst_space i t).



Definition subst_assertion (i: var) (e: expr) (a: assertion) :=

 match a with Assertion pi sigma =>

   Assertion (subst_pns i e pi) (subst_spaces i e sigma)

 end.

