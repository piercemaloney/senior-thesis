Require Import compcert.lib.Axioms.
(* compcert.lib.Axioms:
Require ClassicalFacts.
Require FunctionalExtensionality.

Lemma functional_extensionality_dep:
  forall {A: Type} {B : A -> Type} (f g : forall x : A, B x),
  (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality_dep.

Lemma functional_extensionality:
  forall {A B: Type} (f g : A -> B), (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality.

Lemma extensionality:
  forall {A B: Type} (f g : A -> B),  (forall x, f x = g x) -> f = g.
Proof @functional_extensionality.

Axiom proof_irr: ClassicalFacts.proof_irrelevance.

Arguments proof_irr [A]. *)

Require Import compcert.lib.Maps.
(* compcert.lib.Maps:
Require Import Equivalence EquivDec.
Require Import Coqlib.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Set Implicit Arguments.

Module Type TREE.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter empty: forall (A: Type), t A.
  Parameter get: forall (A: Type), elt -> t A -> option A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Parameter remove: forall (A: Type), elt -> t A -> t A.

  Axiom gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
    Axiom grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Axiom gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Axiom grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Parameter beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool.
  Axiom beq_correct:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true <->
    (forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end).

  Parameter map:
    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Parameter map1:
    forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Parameter combine:
    forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C.
  Axiom gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).

  Parameter elements:
    forall (A: Type), t A -> list (elt * A).
  Axiom elements_correct:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    get i m = Some v -> In (i, v) (elements m).
  Axiom elements_complete:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    In (i, v) (elements m) -> get i m = Some v.
  Axiom elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).
  Axiom elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.
  Axiom elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Parameter fold:
    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
  Axiom fold_spec:
    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
  
  Parameter fold1:
    forall (A B: Type), (B -> A -> B) -> t A -> B -> B.
  Axiom fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.
End TREE.

Module Type MAP.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter init: forall (A: Type), A -> t A.
  Parameter get: forall (A: Type), elt -> t A -> A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Axiom gi:
    forall (A: Type) (i: elt) (x: A), get i (init x) = x.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Axiom gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Parameter map: forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End MAP.

Module PTree <: TREE.
  Definition elt := positive.
  Definition elt_eq := peq.

  Inductive tree (A : Type) : Type :=
    | Leaf : tree A
    | Node : tree A -> option A -> tree A -> tree A.

  Arguments Leaf [A].
  Arguments Node [A].
  Scheme tree_ind := Induction for tree Sort Prop.

  Definition t := tree.

  Definition empty (A : Type) := (Leaf : t A).

  Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A :=
    match m with
    | Leaf => None
    | Node l o r =>
        match i with
        | xH => o
        | xO ii => get ii l
        | xI ii => get ii r
        end
    end.

  Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A :=
    match m with
    | Leaf =>
        match i with
        | xH => Node Leaf (Some v) Leaf
        | xO ii => Node (set ii v Leaf) None Leaf
        | xI ii => Node Leaf None (set ii v Leaf)
        end
    | Node l o r =>
        match i with
        | xH => Node l (Some v) r
        | xO ii => Node (set ii v l) o r
        | xI ii => Node l o (set ii v r)
        end
    end.

  Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A :=
    match i with
    | xH =>
        match m with
        | Leaf => Leaf
        | Node Leaf o Leaf => Leaf
        | Node l o r => Node l None r
        end
    | xO ii =>
        match m with
        | Leaf => Leaf
        | Node l None Leaf =>
            match remove ii l with
            | Leaf => Leaf
            | mm => Node mm None Leaf
            end
        | Node l o r => Node (remove ii l) o r
        end
    | xI ii =>
        match m with
        | Leaf => Leaf
        | Node Leaf None r =>
            match remove ii r with
            | Leaf => Leaf
            | mm => Node Leaf None mm
            end
        | Node l o r => Node l o (remove ii r)
        end
    end.

  Theorem gempty:
    forall (A: Type) (i: positive), get i (empty A) = None.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x.

    Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then Some x else get i m.

  Theorem gsident:
    forall (A: Type) (i: positive) (m: t A) (v: A),
    get i m = Some v -> set i v m = m.

  Theorem set2:
    forall (A: Type) (i: elt) (m: t A) (v1 v2: A),
    set i v2 (set i v1 m) = set i v2 m.

  Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf.

  Theorem grs:
    forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None.

  Theorem gro:
    forall (A: Type) (i j: positive) (m: t A),
    i <> j -> get i (remove j m) = get i m.

  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Section BOOLEAN_EQUALITY.

    Variable A: Type.
    Variable beqA: A -> A -> bool.

    Fixpoint bempty (m: t A) : bool :=
      match m with
      | Leaf => true
      | Node l None r => bempty l && bempty r
      | Node l (Some _) r => false
      end.

    Fixpoint beq (m1 m2: t A) {struct m1} : bool :=
      match m1, m2 with
      | Leaf, _ => bempty m2
      | _, Leaf => bempty m1
      | Node l1 o1 r1, Node l2 o2 r2 =>
          match o1, o2 with
          | None, None => true
          | Some y1, Some y2 => beqA y1 y2
          | _, _ => false
          end
          && beq l1 l2 && beq r1 r2
      end.

    Lemma bempty_correct:
      forall m, bempty m = true <-> (forall x, get x m = None).

    Lemma beq_correct:
      forall m1 m2,
      beq m1 m2 = true <->
      (forall (x: elt),
       match get x m1, get x m2 with
       | None, None => True
       | Some y1, Some y2 => beqA y1 y2 = true
       | _, _ => False
       end).

  End BOOLEAN_EQUALITY.

  Fixpoint prev_append (i j: positive) {struct i} : positive :=
    match i with
      | xH => j
      | xI i' => prev_append i' (xI j)
      | xO i' => prev_append i' (xO j)
    end.

  Definition prev (i: positive) : positive :=
    prev_append i xH.

  Lemma prev_append_prev i j:
    prev (prev_append i j) = prev_append j i.

  Lemma prev_involutive i :
    prev (prev i) = i.
  Proof (prev_append_prev i xH).

  Lemma prev_append_inj i j j' :
    prev_append i j = prev_append i j' -> j = j'.

    Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive)
             {struct m} : t B :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node (xmap f l (xO i))
                           (match o with None => None | Some x => Some (f (prev i) x) end)
                           (xmap f r (xI i))
      end.

  Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH.

    Lemma xgmap:
      forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A),
      get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m).

  Theorem gmap:
    forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B :=
    match m with
    | Leaf => Leaf
    | Node l o r => Node (map1 f l) (option_map f o) (map1 f r)
    end.

  Theorem gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A :=
    match l, x, r with
    | Leaf, None, Leaf => Leaf
    | _, _, _ => Node l x r
    end.

  Lemma gnode':
    forall (A: Type) (l r: t A) (x: option A) (i: positive),
    get i (Node' l x r) = get i (Node l x r).

  Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A :=
    match m with
    | Leaf => Leaf
    | Node l o r =>
        let o' := match o with None => None | Some x => if pred x then o else None end in
        Node' (filter1 pred l) o' (filter1 pred r)
    end.

  Theorem gfilter1:
    forall (A: Type) (pred: A -> bool) (i: elt) (m: t A),
    get i (filter1 pred m) =
    match get i m with None => None | Some x => if pred x then Some x else None end.

  Section COMBINE.

  Variables A B C: Type.
  Variable f: option A -> option B -> option C.
  Hypothesis f_none_none: f None None = None.

  Fixpoint xcombine_l (m : t A) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_l l) (f o None) (xcombine_l r)
      end.

  Lemma xgcombine_l :
          forall (m: t A) (i : positive),
          get i (xcombine_l m) = f (get i m) None.

  Fixpoint xcombine_r (m : t B) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_r l) (f None o) (xcombine_r r)
      end.

  Lemma xgcombine_r :
          forall (m: t B) (i : positive),
          get i (xcombine_r m) = f None (get i m).

  Fixpoint combine (m1: t A) (m2: t B) {struct m1} : t C :=
    match m1 with
    | Leaf => xcombine_r m2
    | Node l1 o1 r1 =>
        match m2 with
        | Leaf => xcombine_l m1
        | Node l2 o2 r2 => Node' (combine l1 l2) (f o1 o2) (combine r1 r2)
        end
    end.

  Theorem gcombine:
      forall (m1: t A) (m2: t B) (i: positive),
      get i (combine m1 m2) = f (get i m1) (get i m2).

  End COMBINE.

  Lemma xcombine_lr :
    forall (A B: Type) (f g : option A -> option A -> option B) (m : t A),
    (forall (i j : option A), f i j = g j i) ->
    xcombine_l f m = xcombine_r g m.

  Theorem combine_commut:
    forall (A B: Type) (f g: option A -> option A -> option B),
    (forall (i j: option A), f i j = g j i) ->
    forall (m1 m2: t A),
    combine f m1 m2 = combine g m2 m1.

    Fixpoint xelements (A : Type) (m : t A) (i : positive)
                       (k: list (positive * A)) {struct m}
                       : list (positive * A) :=
      match m with
      | Leaf => k
      | Node l None r =>
          xelements l (xO i) (xelements r (xI i) k)
      | Node l (Some x) r =>
          xelements l (xO i)
            ((prev i, x) :: xelements r (xI i) k)
      end.

  Definition elements (A: Type) (m : t A) := xelements m xH nil.

  Remark xelements_append:
    forall A (m: t A) i k1 k2,
    xelements m i (k1 ++ k2) = xelements m i k1 ++ k2.

  Remark xelements_leaf:
    forall A i, xelements (@Leaf A) i nil = nil.

  Remark xelements_node:
    forall A (m1: t A) o (m2: t A) i,
    xelements (Node m1 o m2) i nil =
       xelements m1 (xO i) nil
    ++ match o with None => nil | Some v => (prev i, v) :: nil end
    ++ xelements m2 (xI i) nil.

    Lemma xelements_incl:
      forall (A: Type) (m: t A) (i : positive) k x,
      In x k -> In x (xelements m i k).

    Lemma xelements_correct:
      forall (A: Type) (m: t A) (i j : positive) (v: A) k,
      get i m = Some v -> In (prev (prev_append i j), v) (xelements m j k).

  Theorem elements_correct:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    get i m = Some v -> In (i, v) (elements m).

  Lemma in_xelements:
    forall (A: Type) (m: t A) (i k: positive) (v: A) ,
    In (k, v) (xelements m i nil) ->
    exists j, k = prev (prev_append j i) /\ get j m = Some v.

  Theorem elements_complete:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    In (i, v) (elements m) -> get i m = Some v.

  Definition xkeys (A: Type) (m: t A) (i: positive) :=
    List.map (@fst positive A) (xelements m i nil).

  Remark xkeys_leaf:
    forall A i, xkeys (@Leaf A) i = nil.

  Remark xkeys_node:
    forall A (m1: t A) o (m2: t A) i,
    xkeys (Node m1 o m2) i =
       xkeys m1 (xO i)
    ++ match o with None => nil | Some v => prev i :: nil end
    ++ xkeys m2 (xI i).

  Lemma in_xkeys:
    forall (A: Type) (m: t A) (i k: positive),
    In k (xkeys m i) ->
    (exists j, k = prev (prev_append j i)).

  Lemma xelements_keys_norepet:
    forall (A: Type) (m: t A) (i: positive),
    list_norepet (xkeys m i).

  Theorem elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).

  Remark xelements_empty:
    forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil.

  Theorem elements_canonical_order':
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i, option_rel R (get i m) (get i n)) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_canonical_order:
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
    (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.

  Lemma xelements_remove:
    forall (A: Type) v (m: t A) i j,
    get i m = Some v ->
    exists l1 l2,
    xelements m j nil = l1 ++ (prev (prev_append i j), v) :: l2
    /\ xelements (remove i m) j nil = l1 ++ l2.

  Theorem elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B)
                 (i: positive) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := xfold f (xO i) l v in
        xfold f (xI i) r v1
    | Node l (Some x) r =>
        let v1 := xfold f (xO i) l v in
        let v2 := f v1 (prev i) x in
        xfold f (xI i) r v2
    end.

  Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) :=
    xfold f xH m v.

  Lemma xfold_xelements:
    forall (A B: Type) (f: B -> positive -> A -> B) m i v l,
    List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) =

  Theorem fold_spec:
    forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.

  Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := fold1 f l v in
        fold1 f r v1
    | Node l (Some x) r =>
        let v1 := fold1 f l v in
        let v2 := f v1 x in
        fold1 f r v2
    end.

  Lemma fold1_xelements:
    forall (A B: Type) (f: B -> A -> B) m i v l,
    List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) =

  Theorem fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.

End PTree.

Module PMap <: MAP.
  Definition elt := positive.
  Definition elt_eq := peq.

  Definition t (A : Type) : Type := (A * PTree.t A)%type.

  Definition init (A : Type) (x : A) :=
    (x, PTree.empty A).

  Definition get (A : Type) (i : positive) (m : t A) :=
    match PTree.get i (snd m) with
    | Some x => x
    | None => fst m
    end.

  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
    (fst m, PTree.set i x (snd m)).

  Theorem gi:
    forall (A: Type) (i: positive) (x: A), get i (init x) = x.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then x else get i m.

  Theorem gsident:
    forall (A: Type) (i j: positive) (m: t A),
    get j (set i (get i m) m) = get j m.

  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
    (f (fst m), PTree.map1 f (snd m)).

  Theorem gmap:
    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
    get i (map f m) = f(get i m).

  Theorem set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End PMap.

Module Type INDEXED_TYPE.
  Parameter t: Type.
  Parameter index: t -> positive.
  Axiom index_inj: forall (x y: t), index x = index y -> x = y.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End INDEXED_TYPE.

Module IMap(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PMap.t.
  Definition init (A: Type) (x: A) := PMap.init x.
  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.

  Lemma gi:
    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.

  Lemma gss:
    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.

  Lemma gso:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gsspec:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),

  Lemma set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End IMap.

Module ZIndexed.
  Definition t := Z.
  Definition index (z: Z): positive :=
    match z with
    | Z0 => xH
    | Zpos p => xO p
    | Zneg p => xI p
    end.
  Lemma index_inj: forall (x y: Z), index x = index y -> x = y.
  Definition eq := zeq.
End ZIndexed.

Module ZMap := IMap(ZIndexed).

Module NIndexed.
  Definition t := N.
  Definition index (n: N): positive :=
    match n with
    | N0 => xH
    | Npos p => xO p
    end.
  Lemma index_inj: forall (x y: N), index x = index y -> x = y.
  Lemma eq: forall (x y: N), {x = y} + {x <> y}.
End NIndexed.

Module NMap := IMap(NIndexed).

Module Type EQUALITY_TYPE.
  Parameter t: Type.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End EQUALITY_TYPE.

Module EMap(X: EQUALITY_TYPE) <: MAP.

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t (A: Type) := X.t -> A.
  Definition init (A: Type) (v: A) := fun (_: X.t) => v.
  Definition get (A: Type) (x: X.t) (m: t A) := m x.
  Definition set (A: Type) (x: X.t) (v: A) (m: t A) :=
    fun (y: X.t) => if X.eq y x then v else m y.
  Lemma gi:
    forall (A: Type) (i: elt) (x: A), init x i = x.
  Lemma gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x.
  Lemma gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> (set j x m) i = m i.
  Lemma gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Lemma gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Definition map (A B: Type) (f: A -> B) (m: t A) :=
    fun (x: X.t) => f(m x).
  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End EMap.

Module ITree(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PTree.t.

  Definition empty (A: Type): t A := PTree.empty A.
  Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m.
  Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m.
  Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m.

  Theorem gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Theorem gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Theorem gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Theorem gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
  Theorem grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Theorem gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq.
  Theorem beq_sound:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true ->
    forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end.

  Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine.
  Theorem gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).
End ITree.

Module ZTree := ITree(ZIndexed).

Module Tree_Properties(T: TREE).

Section TREE_FOLD_IND.

Variables V A: Type.
Variable f: A -> T.elt -> V -> A.
Variable P: T.t V -> A -> Prop.
Variable init: A.
Variable m_final: T.t V.

Hypothesis P_compat:
  forall m m' a,
  (forall x, T.get x m = T.get x m') ->
  P m a -> P m' a.

Hypothesis H_base:
  P (T.empty _) init.

Hypothesis H_rec:
  forall m a k v,
  T.get k m = None -> T.get k m_final = Some v -> P m a -> P (T.set k v m) (f a k v).

Let f' (a: A) (p : T.elt * V) := f a (fst p) (snd p).

Let P' (l: list (T.elt * V)) (a: A) : Prop :=
  forall m, list_equiv l (T.elements m) -> P m a.

Remark H_base':
  P' nil init.

Remark H_rec':
  forall k v l a,
  ~In k (List.map (@fst T.elt V) l) ->

Lemma fold_rec_aux:
  forall l1 l2 a,
  list_equiv (l2 ++ l1) (T.elements m_final) ->

Theorem fold_rec:
  P m_final (T.fold f m_final init).

End TREE_FOLD_IND.

Section MEASURE.

Variable V: Type.

Definition cardinal (x: T.t V) : nat := List.length (T.elements x).

Theorem cardinal_remove:
  forall x m y, T.get x m = Some y -> (cardinal (T.remove x m) < cardinal m)%nat.

Theorem cardinal_set:
  forall x m y, T.get x m = None -> (cardinal m < cardinal (T.set x y m))%nat.

End MEASURE.

Section FORALL_EXISTS.

Variable A: Type.

Definition for_all (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b && f x a) m true.

Lemma for_all_correct:
  forall m f,
  for_all m f = true <-> (forall x a, T.get x m = Some a -> f x a = true).

Definition exists_ (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b || f x a) m false.

Lemma exists_correct:
  forall m f,
  exists_ m f = true <-> (exists x a, T.get x m = Some a /\ f x a = true).

Remark exists_for_all:
  forall m f,
  exists_ m f = negb (for_all m (fun x a => negb (f x a))).

Remark for_all_exists:
  forall m f,
  for_all m f = negb (exists_ m (fun x a => negb (f x a))).

Lemma for_all_false:
  forall m f,
  for_all m f = false <-> (exists x a, T.get x m = Some a /\ f x a = false).

Lemma exists_false:
  forall m f,
  exists_ m f = false <-> (forall x a, T.get x m = Some a -> f x a = false).

End FORALL_EXISTS.

Section BOOLEAN_EQUALITY.

Variable A: Type.
Variable beqA: A -> A -> bool.

Theorem beq_false:
  forall m1 m2,
  T.beq beqA m1 m2 = false <->

End BOOLEAN_EQUALITY.

Section EXTENSIONAL_EQUALITY.

Variable A: Type.
Variable eqA: A -> A -> Prop.
Hypothesis eqAeq: Equivalence eqA.

Definition Equal (m1 m2: T.t A) : Prop :=
  forall x, match T.get x m1, T.get x m2 with
                | None, None => True
                | Some a1, Some a2 => a1 === a2
                | _, _ => False
            end.

Lemma Equal_refl: forall m, Equal m m.

Lemma Equal_sym: forall m1 m2, Equal m1 m2 -> Equal m2 m1.

Lemma Equal_trans: forall m1 m2 m3, Equal m1 m2 -> Equal m2 m3 -> Equal m1 m3.

Instance Equal_Equivalence : Equivalence Equal := {
  Equivalence_Reflexive := Equal_refl;
  Equivalence_Symmetric := Equal_sym;
  Equivalence_Transitive := Equal_trans
}.

Hypothesis eqAdec: EqDec A eqA.

Program Definition Equal_dec (m1 m2: T.t A) : { m1 === m2 } + { m1 =/= m2 } :=

Instance Equal_EqDec : EqDec (T.t A) Equal := Equal_dec.

End EXTENSIONAL_EQUALITY.

Section OF_LIST.

Variable A: Type.

Let f := fun (m: T.t A) (k_v: T.elt * A) => T.set (fst k_v) (snd k_v) m.

Definition of_list (l: list (T.elt * A)) : T.t A :=
  List.fold_left f l (T.empty _).

Lemma in_of_list:
  forall l k v, T.get k (of_list l) = Some v -> In (k, v) l.

Lemma of_list_dom:
  forall l k, In k (map fst l) -> exists v, T.get k (of_list l) = Some v.

Remark of_list_unchanged:
  forall k l m, ~In k (map fst l) -> T.get k (List.fold_left f l m) = T.get k m.

Lemma of_list_unique:
  forall k v l1 l2,
  ~In k (map fst l2) -> T.get k (of_list (l1 ++ (k, v) :: l2)) = Some v.

Lemma of_list_norepet:
  forall l k v, list_norepet (map fst l) -> In (k, v) l -> T.get k (of_list l) = Some v.

Lemma of_list_elements:
  forall m k, T.get k (of_list (T.elements m)) = T.get k m.

End OF_LIST.

Lemma of_list_related:
  forall (A B: Type) (R: A -> B -> Prop) k l1 l2,
  list_forall2 (fun ka kb => fst ka = fst kb /\ R (snd ka) (snd kb)) l1 l2 ->
  option_rel R (T.get k (of_list l1)) (T.get k (of_list l2)).

End Tree_Properties.

Module PTree_Properties := Tree_Properties(PTree).

Notation "a ! b" := (PTree.get b a) (at level 1).
Notation "a !! b" := (PMap.get b a) (at level 1). *)



Require Import VST.concurrency.common.sepcomp. Import SepComp.
(* VST.concurrency.common.sepcomp:
Module SepComp.
Require Export VST.concurrency.common.core_semantics.
Require Export VST.sepcomp.mem_lemmas.
Require Export VST.sepcomp.structured_injections.
Require Export VST.sepcomp.effect_semantics.
Require Export VST.sepcomp.extspec.
Require Export VST.sepcomp.Address.
End SepComp. *)



Require Import VST.concurrency.common.pos.
(* VST.concurrency.common.pos:
From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype fintype.
Set Implicit Arguments.

Require Import compcert.lib.Axioms.

Record pos := mkPos { n :> nat ; N_pos : (0 < n)%coq_nat }.

Lemma is_pos (p : pos) : 0 < p.

Definition i0 (p : pos) : 'I_p := Ordinal (is_pos p).

Require Import Omega.
Lemma is_pos_incr (n : nat) : (0 < n.+1)%coq_nat.

Definition pos_incr (p : pos) : pos := mkPos (is_pos_incr p).

Lemma pos_incr_lt (p : pos) : p < pos_incr p.

Definition ordinal_pos_incr (p : pos) : 'I_(pos_incr p) := Ordinal (pos_incr_lt p).

Section PosEqType.

Definition pos_eq := [rel u v : pos | n u == n v].

Lemma pos_eqP : Equality.axiom pos_eq.

Definition pos_eqMixin := EqMixin pos_eqP.

End PosEqType. *)

Require Import VST.concurrency.common.scheduler.
(* VST.concurrency.common.scheduler:
Require Import compcert.common.AST.

Module Type ThreadID.
  Parameter tid: Set.
  
  Parameter tid2nat: tid -> nat.
  Axiom eq_tid_dec: forall (i j: tid), {i=j} + {i<>j}.
End ThreadID.

Module NatTID <: ThreadID.
  Definition tid:= nat.
  Definition tid2nat: tid -> nat:= id.
  Lemma eq_tid_dec: forall (i j: tid), {i=j} + {i<>j}.
End NatTID. *)

Require Import VST.concurrency.common.konig.
(* VST.concurrency.common.konig:
Require Import Coq.Logic.ChoiceFacts.
Require Import Coq.omega.Omega.

Tactic Notation "assert_specialize" hyp(H) :=
  match type of H with
    forall x : ?P, _ =>
    let Htemp := fresh "Htemp" in
    assert P as Htemp; [ | specialize (H Htemp); try clear Htemp ]
  end.

Definition intersection {X} (A B : X -> Prop) := fun x => A x /\ B x.
Definition minus {X} (A B : X -> Prop) := fun x => A x /\ ~B x.
Definition subset {X} (A B : X -> Prop) := forall x, A x -> B x.
Definition finite {X} (A : X -> Prop) := exists n f, forall x, A x -> exists i, i < n /\ f i = x.
Definition infinite (A : nat -> Prop) := forall b, exists a, b <= a /\ A a.
Definition image {X Y} (f : X -> Y) (A : X -> Prop) : Y -> Prop := fun y => exists x, A x /\ y = f x.
Definition preimage {X Y} (f : X -> Y) (B : Y -> Prop) : X -> Prop := fun x => B (f x).

Lemma infinite_subset (A B : nat -> Prop) :
  subset A B -> infinite A -> infinite B.

Lemma infinite_minus A B :
  (forall P, ~~P -> P) ->
  infinite A ->
  ~ infinite (intersection A B) ->
  infinite (minus A B).

Lemma image_subset {X Y} A B (f : X -> Y) :
  subset A B ->
  subset (image f A) (image f B).

Lemma ramsey_preimage {X} (N : nat -> Prop) (f : nat -> X) :
  (forall P, P \/ ~P) ->
  finite (image f N) ->
  infinite N ->
  exists x, infinite (intersection N (preimage f (eq x))).

Lemma EM_ABS : (forall P, P \/ ~P) <-> (forall P, ~~P -> P).

Fixpoint zip {X} (f1 f2 : nat -> X) n :=
  match n with
  | O => f1 O
  | S O => f2 0
  | S (S n) => zip (fun n => f1 (S n)) (fun n => f2 (S n)) n
  end.

Lemma zip_ext {X} f1 f2 g1 g2 :
  (forall x, f1 x = g1 x) ->
  (forall x, f2 x = g2 x) ->
  forall k, @zip X f1 f2 k = @zip X g1 g2 k.

Lemma zip_1 {X} f1 f2 n : @zip X f1 f2 (2 * n) = f1 n.

Lemma zip_2 {X} f1 f2 n : @zip X f1 f2 (1 + 2 * n) = f2 n.

Lemma finite_union_intersection {X Y} (A1 A2 : X -> Prop) (P : Y -> X -> Prop) :
  finite (fun y => exists x, A1 x /\ P y x) ->
  finite (fun y => exists x, A2 x /\ P y x) ->
  finite (fun y => exists x, (A1 x \/ A2 x) /\ P y x).

Lemma finite_product:
  forall {A B}
    {PA : A -> Prop}
    {PB : B -> Prop},
    finite PA ->
    finite PB ->
    finite (fun ab => PA (fst ab) /\ PB (snd ab)).

Lemma finite_nat_bound A : @finite nat A <-> exists b, forall a, A a -> a < b.

Lemma finite_union_intersection_nat {X} (A1 A2 : X -> Prop) (P : nat -> X -> Prop) :
  finite (fun n => exists x, A1 x /\ P n x) ->
  finite (fun n => exists x, A2 x /\ P n x) ->
  finite (fun n => exists x, (A1 x \/ A2 x) /\ P n x).

Lemma not_infinite_finite A : (forall P, ~~P -> P) -> ~ infinite A <-> finite A.

Lemma ramsey_inf_bin {X} (A1 A2 : X -> Prop) (P : nat -> X -> Prop) :
  (forall P, P \/ ~P) ->
  infinite (fun n => exists x, (A1 x \/ A2 x) /\ P n x) ->
  infinite (fun n => exists x, A1 x /\ P n x) \/
  infinite (fun n => exists x, A2 x /\ P n x).

Lemma ramsey_inf {X} (A : X -> Prop) (P : nat -> X -> Prop) :
  (forall P, P \/ ~P) ->
  finite A ->
  infinite (fun n => exists x, A x /\ P n x) ->
  exists x, A x /\ infinite (fun n => P n x).

Section Safety.
  Definition rel X := X -> X -> Prop.

  Variable X : Type.
  Variable R : rel X.

  Inductive safeN : nat -> X -> Prop :=
  | safeO : forall x, safeN 0 x
  | safeS : forall n x x', R x x' -> safeN n x' -> safeN (S n) x.

  Definition safeN' n f : Prop := forall i, i < n -> R (f i) (f (1 + i)).

  Lemma safeN_safeN' n x : safeN n x <-> (exists f, f 0 = x /\ safeN' n f).

  CoInductive safe : X -> Prop :=
    safe_cons : forall x x', R x x' -> safe x' -> safe x.

  Definition stable (P : X -> Prop) := forall x, P x -> exists x', R x x' /\ P x'.
  Definition kt_safe x := exists P, P x /\ stable P.

  Lemma kt_safe_safe x : safe x <-> kt_safe x.

  Definition safe' f := forall i, R (f i) (f (1 + i)).

  Lemma safe'_safe x : (exists f, f 0 = x /\ safe' f) -> safe x.

  Lemma safe_safe' x :
    (forall P, P \/ ~P) ->
    FunctionalChoice ->
    safe x -> (exists f, f 0 = x /\ safe' f).

  Lemma not_ex_forall {A} (P : A -> Prop) : (~ex P) <-> (forall x, ~P x).

  Lemma safeN_S n x : safeN (S n) x -> safeN n x.

  Lemma safeN_le n n' x : n <= n' -> safeN n' x -> safeN n x.

  Lemma konigsafe x : (forall P, P \/ ~P) -> (forall x, finite (R x)) -> (forall n, safeN n x) -> safe x.

End Safety. *)

Require Import VST.concurrency.common.addressFiniteMap. 
(* VST.concurrency.common.addressFiniteMap:
Require Import Coq.ZArith.ZArith.
Require Import Coq.Structures.OrderedType.

Require Import compcert.lib.Axioms.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Coqlib.
Require Import compcert.common.Memtype.

Require Import VST.msl.eq_dec.
Require Import VST.msl.Coqlib2.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.lksize.
Set Bullet Behavior "Strict Subproofs".

  Module MiniAddressOrdered <: MiniOrderedType.

    Definition t:= address.
    Definition eq:= @eq t.
    Definition lt' (x y:t): bool :=
      (match x, y with (x1,x2),(y1,y2) =>
        if peq x1 y1 then zlt x2 y2 else plt x1 y1
      end).
    Definition lt x y:= is_true (lt' x y).
    Lemma eq_sym : forall x y : t, eq x y -> eq y x.
    Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
    Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
    Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
   Lemma compare : forall x y : t, Compare lt eq x y.
  End MiniAddressOrdered.

  Module AddressOrdered <: OrderedType.
     Include MiniAddressOrdered.

     Lemma eq_dec : forall x y, { eq x y } + { ~ eq x y }.
  End AddressOrdered.

  Require Import FMaps.
  Module AMap:= Make AddressOrdered.

  Section AMap2PMap.
    
    Context {lock_info: Type}.
    Variable am: AMap.t lock_info.

    Definition A2PMap  :=
      fold_left
        (fun (pmap:access_map) (a:address * lock_info)=>
           match a with
           | ((b, ofs), _) => setPermBlock (Some Memtype.Writable) b ofs pmap LKSIZE_nat
           end)
        (AMap.elements am)
        (PMap.init (fun _ => None)).
    End AMap2PMap.

Lemma AMap_find_map {A B} m (f : A -> B) k (x : A) :
  AMap.find k m = Some x ->

Lemma AMap_find_map_None {A B} m (f : A -> B) k :
  AMap.find k m = None ->

Lemma AMap_find_map_inv {A B} m (f : A -> B) k (y : B) :
  AMap.find k (AMap.map f m) = Some y ->

Lemma AMap_map {A B} (f : A -> B) m :
  map snd (AMap.elements (AMap.map f m)) =

Lemma AMap_find_map_option_map {A B} m (f : A -> B) k :
  AMap.find k (AMap.map f m) =

Lemma AMap_find_add {A} m x (y : A) x' :
  AMap.find x' (AMap.add x y m) =

Lemma AMap_find_remove {A} (m : AMap.t A) x x' :

Lemma AMap_Raw_map_app {A} (f : A -> A) l1 l2 :
  AMap.Raw.map (option_map f) (app l1 l2) =

Lemma AMap_Raw_map_rev {A} (f : A -> A) l :
  AMap.Raw.map (option_map f) (rev l) =

Lemma A2PMap_option_map {A} (m : AMap.t (option A)) (f : A -> A) :

Lemma AMap_map_add {A B} (f : A -> B) m x y :
  AMap.Equal

Lemma AMap_Raw_add_fold_left A (EQ : A -> A -> Prop) B f k (x : B) l (e : A) :
  (forall e, EQ e e) ->
  (forall e e', EQ e e' -> EQ e' e) ->
  (forall e e' e'', EQ e e' -> EQ e' e'' -> EQ e e'') ->
  (forall a e e', EQ e e' -> EQ (f e a) (f e' a)) ->
  (forall a b e, fst a = fst b -> EQ (f (f e a) b) (f e a)) ->
  (forall a b e, EQ (f (f e a) b) (f (f e b) a)) ->
  EQ
    (fold_left f (AMap.Raw.add k x l) e)

Require Import Coq.Sorting.Permutation.

Lemma AMap_Raw_add_fold_left_permut A (EQ : A -> A -> Prop) B f (l l' : list B) (e : A) :
  (forall e, EQ e e) ->
  (forall e e', EQ e e' -> EQ e' e) ->
  (forall e e' e'', EQ e e' -> EQ e' e'' -> EQ e e'') ->
  (forall a e e', EQ e e' -> EQ (f e a) (f e' a)) ->
  (forall a b e, EQ (f (f e a) b) (f (f e b) a)) ->
  Permutation l l' ->
  EQ
    (fold_left f l e)
    (fold_left f l' e).

Lemma AMap_Raw_add_fold_left_right A (EQ : A -> A -> Prop) B f (l : list B) (e : A) :
  (forall e, EQ e e) ->
  (forall e e', EQ e e' -> EQ e' e) ->
  (forall e e' e'', EQ e e' -> EQ e' e'' -> EQ e e'') ->
  (forall a e e', EQ e e' -> EQ (f e a) (f e' a)) ->
  (forall a b e, EQ (f (f e a) b) (f (f e b) a)) ->
  EQ
    (fold_left f l e)
    (fold_right (fun x y => f y x) e l).

Lemma setPerm_b_comm o b ofs1 ofs2 t :
  setPerm o b ofs1 (setPerm o b ofs2 t) =
  setPerm o b ofs2 (setPerm o b ofs1 t).

Lemma setPerm_b_idem o b ofs t :
  setPerm o b ofs (setPerm o b ofs t) =
  setPerm o b ofs t.

Definition PMap_eq {A} (m m' : PMap.t (Z -> A)) := forall b' ofs', m !! b' ofs' = m' !! b' ofs'.
Lemma PMap_eq_sym {A} : symmetric _ (@PMap_eq A). intros f g. unfold PMap_eq; symmetry; auto. Qed.

Definition A2P {A} :=
 (fun (pmap : access_map) (a : address * A) =>
      let (a0, _) := a in let (b0, ofs0) := a0 in setPermBlock (Some Writable) b0 ofs0 pmap LKSIZE_nat).

Lemma setPermBlock_lookup : forall p b o a n b' o', (setPermBlock p b o a n) !! b' o' =
  if adr_range_dec (b, o) (Z.of_nat n) (b', o') then p else a !! b' o'.

Lemma A2P_congr A e e' a : PMap_eq e e' -> PMap_eq (A2P e a) (@A2P A e' a).

Lemma A2P_overwrite A : forall a b e, fst a = fst b -> PMap_eq (@A2P A (A2P e a) b) (@A2P A e a).

Lemma setPerm_comm b1 o1 b2 o2 e:
  PMap_eq (setPerm (Some Writable) b1 o1 (setPerm (Some Writable) b2 o2 e))
          (setPerm (Some Writable) b2 o2 (setPerm (Some Writable) b1 o1 e)).

Lemma setPerm_congr b o e e':
  PMap_eq e e' ->
  PMap_eq (setPerm (Some Writable) b o e)
          (setPerm (Some Writable) b o e').

Lemma A2P_comm A e a b : PMap_eq (@A2P A (A2P e a) b) (@A2P A (A2P e b) a).

Lemma fold_right_cons : forall A B (f : A -> B -> B) (z : B) (x : A) (y : list A),
    fold_right f z (x :: y) = f x (fold_right f z y).

Lemma setPerm_spec perm m b ofs b' ofs' :
  (setPerm perm b ofs m) !! b' ofs' =
  if eq_dec (b, ofs) (b', ofs') then
    perm
  else
    m !! b' ofs'.

Lemma A2PMap_found A m b ofs ofs' o :
  AMap.find (elt:=A) (b, ofs) m = Some o ->

Lemma fold_right_rev_left:
  forall (A B: Type) (f: A -> B -> A) (l: list B) (i: A),
  fold_left f l i = fold_right (fun x y => f y x) i (rev l).

Lemma A2PMap_add_outside T b b' ofs ofs' set o :
  (@A2PMap T (AMap.add (b, ofs) o set)) !! b' ofs' =

Lemma find_too_small A y a x l :
  (AddressOrdered.lt y a \/ AddressOrdered.eq y a) ->

Lemma sorted_find A a x l l'
      (sorted : Sorted (AMap.Raw.PX.ltk (elt:=A)) ((a, x) :: l))

Lemma AMap_Equal_PMap_eq {A} m m' : AMap.Equal m m' -> @A2PMap A m = @A2PMap A m'.

Lemma AMap_remove_add {A} (m : AMap.t A) x y : *)

Require Import VST.concurrency.common.pos.
(* VST.concurrency.common.pos:
From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype fintype.
Set Implicit Arguments.

Require Import compcert.lib.Axioms.

Record pos := mkPos { n :> nat ; N_pos : (0 < n)%coq_nat }.

Lemma is_pos (p : pos) : 0 < p.

Definition i0 (p : pos) : 'I_p := Ordinal (is_pos p).

Require Import Omega.
Lemma is_pos_incr (n : nat) : (0 < n.+1)%coq_nat.

Definition pos_incr (p : pos) : pos := mkPos (is_pos_incr p).

Lemma pos_incr_lt (p : pos) : p < pos_incr p.

Definition ordinal_pos_incr (p : pos) : 'I_(pos_incr p) := Ordinal (pos_incr_lt p).

Section PosEqType.

Definition pos_eq := [rel u v : pos | n u == n v].

Lemma pos_eqP : Equality.axiom pos_eq.

Definition pos_eqMixin := EqMixin pos_eqP.

End PosEqType. *)

Require Import VST.concurrency.common.lksize.
(* VST.concurrency.common.lksize:
Require Import compcert.common.AST.
Require Import compcert.common.Memdata.
Require Import Coq.ZArith.ZArith.

Definition LKSIZE:= (2 * size_chunk Mptr)%Z.
Definition LKSIZE_nat:= Z.to_nat LKSIZE.

Lemma LKSIZE_pos : (0 < LKSIZE)%Z.

Lemma LKSIZE_int : (size_chunk Mint32 < LKSIZE)%Z.

Ltac lkomega := pose proof LKSIZE_pos; pose proof LKSIZE_int; simpl in *; try omega. *)

Require Import VST.concurrency.common.permjoin_def.
(* VST.concurrency.common.permjoin_def:
Require Import compcert.common.Memory.

Inductive permjoin : option permission -> option permission -> option permission -> Prop :=
  | permjoin_None_l x : permjoin None x x
  | permjoin_None_r x : permjoin x None x
  
  | permjoin_NNN : permjoin (Some Nonempty) (Some Nonempty) (Some Nonempty)
  
  | permjoin_NRR : permjoin (Some Nonempty) (Some Readable) (Some Readable)
  | permjoin_RNR : permjoin (Some Readable) (Some Nonempty) (Some Readable)
  
  | permjoin_NWW : permjoin (Some Nonempty) (Some Writable) (Some Writable)
  | permjoin_NWF : permjoin (Some Nonempty) (Some Writable) (Some Freeable)
  | permjoin_WNW : permjoin (Some Writable) (Some Nonempty) (Some Writable)
  | permjoin_WNF : permjoin (Some Writable) (Some Nonempty) (Some Freeable)
  
  | permjoin_RRR : permjoin (Some Readable) (Some Readable) (Some Readable)
  | permjoin_RRW : permjoin (Some Readable) (Some Readable) (Some Writable)
  | permjoin_RRF : permjoin (Some Readable) (Some Readable) (Some Freeable)
  
  | permjoin_RWW : permjoin (Some Readable) (Some Writable) (Some Writable)
  | permjoin_WRW : permjoin (Some Writable) (Some Readable) (Some Writable)
  | permjoin_RWF : permjoin (Some Readable) (Some Writable) (Some Freeable)
  | permjoin_WRF : permjoin (Some Writable) (Some Readable) (Some Freeable).

  Lemma permjoin_comm:
    forall p1 p2 p3,
      permjoin p1 p2 p3 <-> permjoin p2 p1 p3.

  Lemma permjoin_readable_if:
    forall p1 p2 p3
      (Hjoin: permjoin p1 p2 p3)
      (Hp1: Mem.perm_order' p1 Readable),

  Lemma permjoin_readable_iff:
    forall p1 p2 p3
      (Hjoin: permjoin p1 p2 p3),
      Mem.perm_order' p3 Readable <-> Mem.perm_order' p1 Readable \/ Mem.perm_order' p2 Readable.

   Lemma permjoin_order:
    forall p1 p2 p3
      (Hjoin: permjoin p1 p2 p3),
      Mem.perm_order'' p3 p1 /\ Mem.perm_order'' p3 p2. *)

Require Import Coq.Program.Program.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.



Require Import VST.concurrency.common.ssromega. 
(* VST.concurrency.common.ssromega:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Set Implicit Arguments.

Ltac arith_hypo_ssrnat2coqnat :=
  match goal with
    | H : context [andb _ _] |- _ => let H0 := fresh in case/andP: H => H H0
    | H : context [orb _ _] |- _ => case/orP: H => H
    | H : context [?L <= ?R] |- _ => move/leP: H => H
    | H : context [?L < ?R] |- _ => move/ltP : H => H
    | H : context [?L == ?R] |- _ => move/eqP : H => H
    | H : context [addn ?L ?R] |- _ => rewrite -plusE in H
    | H : context [muln ?L ?R] |- _ => rewrite -multE in H
    | H : context [subn ?L ?R] |- _ => rewrite -minusE in H
  end.

Ltac arith_goal_ssrnat2coqnat :=
  rewrite ?NatTrec.trecE -?plusE -?minusE -?multE -?leqNgt -?ltnNge;
  repeat match goal with
           | |- is_true (andb _ _) => apply/andP; split
           | |- is_true (orb _ _) => try apply/orP
           | |- is_true (_ <= _) => try apply/leP
           | |- is_true (_ < _) => try apply/ltP
         end.

Ltac ssromega :=
  repeat arith_hypo_ssrnat2coqnat;
  arith_goal_ssrnat2coqnat; simpl;
  omega. *)



Require Import Coq.ZArith.ZArith.



Require Import VST.concurrency.common.permissions.
(* VST.concurrency.common.permissions:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool
        ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.
Require Import VST.msl.Coqlib2.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permjoin_def.
Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import compcert.lib.Integers.
Require Export compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
From VST.veric Require Import shares juicy_mem juicy_mem_lemmas.
Require Import VST.msl.msl_standard.
Require Import FunInd.
Import cjoins.

Require Import ProofIrrelevance.

Lemma po_refl: forall p, Mem.perm_order'' p p.

Lemma perm_order_antisym :
  forall p p'
    (Hlt: Mem.perm_order'' p p')

Definition access_map := Maps.PMap.t (Z -> option permission).
Definition delta_map := Maps.PTree.t (Z -> option (option permission)).

Section permMapDefs.

  Definition empty_map : access_map :=
    (fun z => None, Maps.PTree.empty (Z -> option permission)).

  Lemma empty_map_spec: forall b ofs,
      Maps.PMap.get b empty_map ofs = None.

  Definition permission_at (m : mem) (b : block) (ofs : Z) (k : perm_kind) :=
    Maps.PMap.get b (Mem.mem_access m) ofs k.

  Definition perm_coh (p1 p2 : option permission) :=
    match p1 with
    | Some Freeable | Some Writable | Some Readable =>
                                      match p2 with
                                      | None => True
                                      | _ => False
                                      end
    | Some Nonempty | None =>
                      match p2 with
                      | Some Freeable => False
                      | _ => True
                      end
    end.

  Lemma perm_coh_lower:
    forall p1 p2 p3 p4
      (Hpu: perm_coh p1 p2)
      (Hperm2: Mem.perm_order'' p2 p4)

  Lemma perm_coh_not_freeable:
    forall p p',
      perm_coh p p' ->
      p' <> Some Freeable.

  Lemma perm_coh_empty_1:
    forall p,
      perm_coh p None.

  Lemma perm_coh_empty_2:
    forall p : option permission,
      Mem.perm_order'' (Some Writable) p ->

  Lemma perm_of_glb_not_Freeable: forall sh,
      ~ perm_of_sh (Share.glb Share.Rsh sh) = Some Freeable.

  Lemma perm_coh_self: forall res,
      perm_coh (perm_of_res res)
               (perm_of_res_lock res).

  Lemma perm_coh_joins:
    forall a b, joins a b ->
           perm_coh (perm_of_res a) (perm_of_res_lock b).

  Lemma po_join_sub_lock:
  forall r1 r2 ,
    join_sub r2 r1 ->
    Mem.perm_order'' (perm_of_res_lock r1) (perm_of_res_lock r2).

  Definition permMapCoherence (pmap1 pmap2 : access_map) :=
    forall b ofs, perm_coh (pmap1 !! b ofs) (pmap2 !! b ofs).

  Lemma permCoh_empty: forall r,
      (forall b ofs, Mem.perm_order'' (Some Writable) (r !! b ofs)) ->

  Lemma permCoh_empty': forall x,
      permMapCoherence x empty_map.

  Lemma perm_of_res_lock_not_Freeable:
    forall r,
      Mem.perm_order'' (Some Writable) (perm_of_res_lock r).

  Definition perm_union (p1 p2 : option permission) : option (option permission) :=
    match p1,p2 with
      | None, _ => Some p2
      | _, None => Some p1
      | Some p1', Some p2' =>
        match p1', p2' with
          | Freeable, _ => None
          | _, Freeable => None
          | Nonempty, _ => Some p2
          | _, Nonempty => Some p1
          | Writable, _ => None
          | _, Writable => None
          | Readable, Readable => Some (Some Readable)
        end
    end.

  Lemma perm_union_comm :
    forall p1 p2,
      perm_union p1 p2 = perm_union p2 p1.

  Lemma perm_union_result : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                              pu = p1 \/ pu = p2.

  Lemma perm_union_ord : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Lemma perm_union_lower:
    forall p1 p2 p3
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p2 p3),

  Lemma perm_union_lower_2:
    forall p1 p2 p3 p4
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p1 p3)

  Inductive not_racy : option permission -> Prop :=
  | empty : not_racy None.

  Inductive racy : option permission -> Prop :=
  | freeable : racy (Some Freeable).

  Lemma not_racy_union :
    forall p1 p2 (Hnot_racy: not_racy p1),
    exists pu, perm_union p1 p2 = Some pu.

  Lemma no_race_racy : forall p1 p2 (Hracy: racy p1)
                              (Hnorace: exists pu, perm_union p1 p2 = Some pu),
                         not_racy p2.

  Lemma perm_order_clash:
    forall p p'
      (Hreadable: Mem.perm_order' p Readable)

  Lemma perm_order_incompatible:
    forall p p'
      (Hreadable: Mem.perm_order'' p (Some Readable))

  Definition perm_max (p1 p2 : option permission) : option permission :=
    match p1,p2 with
      | Some Freeable, _ => p1
      | _, Some Freeable => p2
      | Some Writable, _ => p1
      | _, Some Writable => p2
      | Some Readable, _ => p1
      | _, Some Readable => p2
      | Some Nonempty, _ => p1
      | _, Some Nonempty => p2
      | None, None => None
    end.

  Lemma perm_max_comm :
    forall p1 p2,
      perm_max p1 p2 = perm_max p2 p1.

  Lemma perm_max_result : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                            pu = p1 \/ pu = p2.

  Lemma perm_max_ord : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Definition getMaxPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Max) (Mem.mem_access m).

  Definition getCurPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Cur) (Mem.mem_access m).

  Definition getPermMap (m : mem) : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    Mem.mem_access m.

  Lemma getCur_Max : forall m b ofs,
                       Mem.perm_order'' (Maps.PMap.get b (getMaxPerm m) ofs)

  Lemma getMaxPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getMaxPerm m) ofs = permission_at m b ofs Max.

  Lemma getCurPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getCurPerm m) ofs = permission_at m b ofs Cur.

  Definition permDisjoint p1 p2:=
    exists pu : option permission,
      perm_union p1 p2 = Some pu.

   Lemma permDisjoint_None: forall p,
      permDisjoint None p.

  Lemma permDisjoint_comm: forall p1 p2,
      permDisjoint p1 p2 -> permDisjoint p2 p1.

  Lemma permDisjointLT: forall a b c,
      permDisjoint a c ->
      Mem.perm_order'' a b ->

  Ltac if_simpl:=
    repeat match goal with
           | [ H: ?X = true |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = false |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = left _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: ?X = right _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: (@is_left _ _ ?X) = true |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           | [ H: (@is_left _ _ ?X) = false |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           end.

  Ltac permDisj_solve:= eexists; simpl; reflexivity.
  
  Lemma join_sh_permDisjoint:
        forall sh1 sh2,
          joins sh1 sh2 ->
          permDisjoint (perm_of_sh sh1) (perm_of_sh sh2).
  
  Lemma writable0_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ readable_share sh2.

  Lemma writable0_not_join_writable0 :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ writable0_share sh2.
 
  Lemma joins_permDisjoint: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res r1) (perm_of_res r2).
  
  Ltac glb_contradictions:=
    repeat match goal with
           | [ H: writable0_share_dec _ = _ |- _ ] => clear H
           end;
    match goal with
    | [ H:  Share.glb Share.Rsh ?sh = Share.top  |- _ ] =>
      exfalso; eapply glb_Rsh_not_top; eassumption
    | [ H: writable0_share (Share.glb Share.Rsh ?sh) |- _ ] =>
      eapply writable0_right in H
    end; join_sh_contradiction.
  
  Lemma joins_permDisjoint_lock: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res_lock r1) (perm_of_res_lock r2).
  
  Definition permMapsDisjoint (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs, exists pu,
      perm_union ((Maps.PMap.get b pmap1) ofs)
                 ((Maps.PMap.get b pmap2) ofs) = Some pu.

  Definition permMapsDisjoint2 (pmap pmap': access_map * access_map) :=
    permMapsDisjoint pmap.1 pmap'.1 /\
    permMapsDisjoint pmap.2 pmap'.2.

  Lemma permDisjoint_permMapsDisjoint: forall r1 r2,
      (forall b ofs, permDisjoint (r1 !! b ofs) (r2 !! b ofs))->
      permMapsDisjoint r1 r2.

  Lemma permMapsDisjoint_permDisjoint: forall r1 r2 b ofs,
      permMapsDisjoint r1 r2 ->
      permDisjoint (r1 !! b ofs) (r2 !! b ofs).

  Lemma empty_disjoint':
    forall pmap,
      permMapsDisjoint empty_map pmap.
  Lemma empty_disjoint:
    permMapsDisjoint empty_map
                     empty_map.

  Lemma permMapsDisjoint_comm :
    forall pmap1 pmap2
      (Hdis: permMapsDisjoint pmap1 pmap2),
      permMapsDisjoint pmap2 pmap1.

  Lemma permMapsDisjoint2_comm:
    forall pmaps pmaps',
      permMapsDisjoint2 pmaps pmaps' <-> permMapsDisjoint2 pmaps' pmaps.

  Lemma disjoint_norace:
    forall (mi mj : mem) (b : block) (ofs : Z)
      (Hdisjoint: permMapsDisjoint (getCurPerm mi) (getCurPerm mj))
      (Hpermj: Mem.perm mj b ofs Cur Readable)

  Definition isCanonical (pmap : access_map) := pmap.1 = fun _ => None.
  Import Maps.
  Definition TreeMaxIndex {A} (t:Maps.PTree.t A): positive:=
    compcert.lib.Coqlib.list_fold_left (fun a => [eta Pos.max a.1]) 1%positive (Maps.PTree.elements t) .
  Lemma fold_max_monoton: forall  {A} (ls: seq.seq (positive * A)), forall i,
  Lemma fold_max_monoton': forall  {A} (ls: seq.seq (positive * A)), forall i j,
  Lemma TreeMaxIndex_help: forall {A} (ls: seq.seq (positive * A)), forall i v,

  Lemma max_works: forall A (t:PTree.t A) m, (m > TreeMaxIndex t)%positive ->

  Lemma Cur_isCanonical: forall m, isCanonical (getCurPerm m).

  Lemma Max_isCanonical: forall m, isCanonical (getMaxPerm m).

  Definition permMapLt (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs,
      Mem.perm_order'' (Maps.PMap.get b pmap2 ofs)
                       (Maps.PMap.get b pmap1 ofs).

  Lemma empty_LT: forall pmap,
             permMapLt empty_map pmap.

  Lemma canonical_lt :
    forall p' m
      (Hlt: permMapLt p' (getMaxPerm m)),
      isCanonical p'.

   Lemma invalid_block_empty:
    forall pmap m
      (Hlt: permMapLt pmap (getMaxPerm m)),
    forall b, ~ Mem.valid_block m b ->

  Definition setPerm (p : option permission) (b : block)
             (ofs : Z) (pmap : access_map) : access_map :=
    Maps.PMap.set b (fun ofs' => if compcert.lib.Coqlib.zeq ofs ofs' then
                                p
                              else
                                Maps.PMap.get b pmap ofs')
                  pmap.

   Fixpoint setPermBlock (p : option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm p b (ofs + (Z_of_nat len))%Z (setPermBlock p b ofs pmap len)
    end.

  Lemma setPermBlock_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock p b ofs pmap sz)) ofs' =

  Lemma setPermBlock_or:
    forall p b ofs sz pmap b' ofs',
      (setPermBlock p b ofs pmap sz) !! b' ofs' = p \/
      (setPermBlock p b ofs pmap sz) !! b' ofs' = pmap !! b' ofs'.

  Fixpoint setPermBlock_var (fp : nat -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp length) b (ofs + (Z_of_nat len))%Z
              (setPermBlock_var fp b ofs pmap len)
    end.

  Lemma setPermBlock_var_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock_var p b ofs pmap sz)) ofs' =

   Lemma setPermBlock_var_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_var_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_setPermBlock_var:
    forall b ofs sz pmap p,
      setPermBlock p b ofs pmap sz =
      setPermBlock_var (fun _ => p) b ofs pmap sz.

  Lemma permMapCoherence_increase:
    forall pmap pmap' b ofs sz_nat sz
      (Hsz: sz = Z.of_nat (sz_nat))

  Fixpoint setPermBlockFunc (fp : Z -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp (ofs + (Z_of_nat len))%Z) b (ofs + (Z_of_nat len))%Z (setPermBlockFunc fp b ofs pmap len)
    end.

  Lemma setPermBlockFunc_same:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_1:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_2:
    forall fp b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock fp b ofs pmap sz)) ofs' =

  Lemma setPermBlock_coherent:
    forall pmap pmap' b ofs sz
      (Hcoh: permMapCoherence pmap pmap')
      (Hnonempty: forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat sz)%Z ->

  Definition computeMap (pmap : access_map) (delta : delta_map) : access_map :=
    (pmap.1,
     @Maps.PTree.combine (Z -> option permission) (Z -> option (option permission))
                         (Z -> option permission)
                         (fun p1 pd => match pd, p1 with
                                    | Some pd', Some p1' =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => p1' z
                                                  end)
                                    | Some pd', None =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => pmap.1 z
                                                  end)
                                    | None, _ => p1
                                    end)
                         pmap.2 delta).

  Lemma computeMap_1 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df (p : option permission),
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_2 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df,
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_3 :
    forall (pmap : access_map) (dmap : delta_map) b ofs,
      Maps.PTree.get b dmap = None ->

  Import Maps BlockList.

  Definition maxF (f : Z -> perm_kind -> option permission) :=
    fun ofs k => match k with
              | Max => Some Freeable
              | Cur => f ofs k
              end.

  Definition allF (f : Z -> perm_kind -> option permission) :=
    fun (_ : Z) (_ : perm_kind) => Some Freeable.

  Fixpoint PList (f : (Z -> perm_kind -> option permission) ->
                      Z -> perm_kind -> option permission)
           l m : list (positive * (Z -> perm_kind -> option permission)) :=
    match l with
      | nil => nil
      | x :: l =>
        (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m)
  end.

  Lemma PList_app :
    forall l m x f,
      (PList f l m) ++ ((Pos.of_nat x,

  Lemma PList_cons :
    forall f l m x,
      (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m) =

  Lemma PList_correct :
    forall f l m k v
           (HInl: List.In k l)

  Lemma PList_mkBlock_complete :
    forall f k v m n
           (Hk: k > 0)
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m)),

  Lemma PList_mkBlock_det :
    forall n f k v v' m
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m))

  Fixpoint canonicalPTree (l : list (positive * (Z -> perm_kind -> option permission))) :=
    match l with
      | nil => PTree.empty _
      | x :: l =>
        PTree.set (fst x) (snd x) (canonicalPTree l)
    end.

  Lemma canonicalPTree_elements :
    forall l x
           (Hin: List.In x (PTree.elements (canonicalPTree l))),

  Lemma canonicalPTree_get_complete :
    forall l m k f fn
           (HGet: (canonicalPTree (PList fn l m)) ! k = Some f),
      List.In (k, f) (PList fn l m).

  Lemma canonicalPTree_get_sound :
    forall n m k fn
           (Hk: k > 0)
           (Hn: n > 1)
           (HGet: (canonicalPTree (PList fn (mkBlockList n) m)) ! (Pos.of_nat k) = None),

  Definition canonicalPMap fn n m : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    let l := mkBlockList n in
    (fun _ _ => None, canonicalPTree (PList fn l m)).

  Lemma canonicalPMap_sound :
    forall k n m fn
           (Hk : k > 0)
           (Hkn : k < n),
      fn (m !! (Pos.of_nat k)) = (canonicalPMap fn n m) !! (Pos.of_nat k).

  Lemma canonicalPMap_default :
    forall n k m fn
           (Hkn : k >= n),
      (canonicalPMap fn n m) !! (Pos.of_nat k) = fun _ _ => None.

  Definition setMaxPerm (m : mem) : mem.

  Lemma setMaxPerm_Max :
    forall m b ofs,
      (Mem.valid_block m b ->

   Lemma setMaxPerm_MaxV :
    forall m b ofs,
      Mem.valid_block m b ->

  Lemma setMaxPerm_MaxI :
    forall m b ofs,
      ~ Mem.valid_block m b ->

  Lemma setMaxPerm_Cur :
    forall m b ofs,
      permission_at (setMaxPerm m) b ofs Cur = permission_at m b ofs Cur.

  Definition makeCurMax_map (mem_access:PMap.t (Z -> perm_kind -> option permission)):
    PMap.t (Z -> perm_kind -> option permission):=
    PMap.map (fun f => fun z k => f z Max) mem_access.

  Definition makeCurMax (m:mem): mem.

  Lemma makeCurMax_correct :
    forall m b ofs k,
      permission_at m b ofs Max = permission_at (makeCurMax m) b ofs k.

  Lemma makeCurMax_valid :
    forall m b,
      Mem.valid_block m b <-> Mem.valid_block (makeCurMax m) b.

  Definition restrPermMap p' m (Hlt: permMapLt p' (getMaxPerm m)) : mem.

Lemma restrPermMap_irr:
      forall p1 p2 m1 m2
        (P1: permMapLt p1 (getMaxPerm m1))
        (P2: permMapLt p2 (getMaxPerm m2)),
        p1 = p2 -> m1 = m2 ->
        restrPermMap P1 = restrPermMap P2.
    Lemma restrPermMap_ext:
      forall p1 p2 m
        (P1: permMapLt p1 (getMaxPerm m))
        (P2: permMapLt p2 (getMaxPerm m)),
        (forall b, (p1 !! b) = (p2 !! b)) ->
        restrPermMap P1 = restrPermMap P2.

  Lemma restrPermMap_nextblock :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      Mem.nextblock (restrPermMap Hlt) = Mem.nextblock m.

  Lemma restrPermMap_valid :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      Mem.valid_block (restrPermMap Hlt) b <-> Mem.valid_block m b.

  Lemma restrPermMap_contents :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      contents_at (restrPermMap Hlt) = contents_at m.

  Lemma restrPermMap_max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      max_access_at (restrPermMap Hlt) = max_access_at m.

  Lemma getMax_restr :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      (getMaxPerm (restrPermMap Hlt)) !!  b = (getMaxPerm m) !! b.

  Lemma restrPermMap_irr' : forall p' p'' m
                             (Hlt : permMapLt p' (getMaxPerm m))
                             (Hlt': permMapLt p'' (getMaxPerm m))
                             (Heq_new: p' = p''),
                             restrPermMap Hlt = restrPermMap Hlt'.

  Lemma restrPermMap_disjoint_inv:
    forall (mi mj m : mem) (pi pj : access_map)
      (Hltj: permMapLt pj (getMaxPerm m))
      (Hlti: permMapLt pi (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pi pj)
      (Hrestrj: restrPermMap Hltj = mj)
      (Hrestri: restrPermMap Hlti = mi),
      permMapsDisjoint (getCurPerm mi) (getCurPerm mj).

  Lemma restrPermMap_correct :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m))
      b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs /\

  Corollary restrPermMap_Cur :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Cur =
      Maps.PMap.get b p' ofs.

  Corollary restrPermMap_Max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs.

  Lemma restrPermMap_can : forall (p : access_map) (m m': mem)
                             (Hlt: permMapLt p (getMaxPerm m))
                             (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getCurPerm m').

  Lemma restrPermMap_can_max : forall (p : access_map) (m m': mem)
                                 (Hlt: permMapLt p (getMaxPerm m))
                                 (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getMaxPerm m').

  Definition erasePerm (m : mem) : mem.

  Lemma erasePerm_Perm :
    forall m b ofs k ,
      (Mem.valid_block m b ->

   Lemma erasePerm_V :
    forall m b ofs k,
      Mem.valid_block m b ->

  Lemma erasePerm_I :
    forall m b ofs k,
      ~ Mem.valid_block m b ->

   Definition decay m_before m_after := forall b ofs,
      (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k,
           (Maps.PMap.get b (Mem.mem_access m_before) ofs k = Some Freeable /\
            Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) \/
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Definition strong_decay m_before m_after := forall b ofs,
       (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Lemma strong_decay_implies_decay:
     forall m m',
       strong_decay m m' ->
       decay m m'.

  Lemma decay_refl:
    forall m,
      decay m m.

  Lemma decay_trans :
    forall m m' m'',
      (forall b, Mem.valid_block m b -> Mem.valid_block m' b) ->

  Definition permMapJoin (pmap1 pmap2 pmap3: access_map) :=
    forall b ofs,
      permjoin ((pmap1 !! b) ofs) ((pmap2 !! b) ofs) ((pmap3 !! b) ofs).

  Lemma permMapJoin_order:
    forall p1 p2 p3
      (Hjoin: permMapJoin p1 p2 p3),
    forall b ofs,
      Mem.perm_order'' (p3 !! b ofs) (p1 !! b ofs) /\

  Lemma permMapLt_invalid_block:
    forall pmap m b ofs
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma perm_order_valid_block:
    forall pmap m b ofs p
      (Hperm: Mem.perm_order'' (pmap !! b ofs) (Some p))

  Definition perm_order''_dec : forall (op op' : option permission),
      {Mem.perm_order'' op op'} + {~ Mem.perm_order'' op op'}.

  Definition perm_eq_dec: forall (op op' : option permission),
      {op = op'} + {~ op = op'}.

End permMapDefs.

Require Import VST.concurrency.common.core_semantics.
Require Import compcert.lib.Coqlib.

Lemma storebytes_decay:
  forall m loc p vl m', Mem.storebytes m loc p vl = Some m' -> decay m m'.

Lemma alloc_decay:
  forall m lo hi m1 b1, Mem.alloc m lo hi = (m1,b1) -> decay m m1.

Lemma free_decay: forall m b lo hi m', Mem.free m b lo hi = Some m' -> decay m m'.

Lemma msem_decay: 
  forall C (Sem: MemSem C) c m c' m',
   corestep (csem Sem)  c m c' m' ->
  decay m m'. *)

Require Import VST.concurrency.common.threadPool.
(* VST.concurrency.common.threadPool:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.

Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.threads_lemmas.
Require Import compcert.lib.Axioms.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
Require Import VST.msl.Coqlib2.

Require Import VST.concurrency.common.lksize.

Set Implicit Arguments.

Inductive ctl {cT:Type} : Type :=
| Krun : cT -> ctl
| Kblocked : cT -> ctl
| Kresume : cT -> val -> ctl 
| Kinit : val -> val -> ctl. 

Definition EqDec: Type -> Type :=
  fun A : Type => forall a a' : A, {a = a'} + {a <> a'}.

Module ThreadPool.
  Section ThreadPool.

    Context {resources: Resources}.
    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Class ThreadPool :=
      { t : Type;
        mkPool : ctl -> res -> t;
        containsThread : t -> tid -> Prop;
        getThreadC : forall {tid tp}, containsThread tp tid -> ctl;
        getThreadR : forall {tid tp}, containsThread tp tid -> res;
        resourceList : t -> seq.seq res;
        lockGuts : t -> AMap.t lock_info;  
        lockSet : t -> access_map;         
        lockRes : t -> address -> option lock_info;
        addThread : t -> val -> val -> res -> t;
        updThreadC : forall {tid tp}, containsThread tp tid -> ctl -> t;
        updThreadR : forall {tid tp}, containsThread tp tid -> res -> t;
        updThread : forall {tid tp}, containsThread tp tid -> ctl -> res -> t;
        updLockSet : t -> address -> lock_info -> t;
        remLockSet : t -> address -> t;
        latestThread : t -> tid;
        lr_valid : (address -> option lock_info) -> Prop;
                find_thread_: t -> (ctl -> bool) -> option tid
        ; resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti)          
        ;  containsThread_dec_:
             forall i tp, {containsThread tp i} + { ~ containsThread tp i}

        ;  cnt_irr: forall t tid
                      (cnt1 cnt2: containsThread t tid),
            cnt1 = cnt2

        ;  cntAdd:
             forall {j tp} vf arg p,
               containsThread tp j ->
               containsThread (addThread tp vf arg p) j

        ;  cntAddLatest:
             forall {tp} vf arg p,
               containsThread (addThread tp vf arg p) (latestThread tp)

        ;  cntAdd':
             forall {j tp} vf arg p,
               containsThread (addThread tp vf arg p) j ->
               (containsThread tp j /\ j <> latestThread tp) \/ j = latestThread tp

        ;  cntUpdateC:
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread tp tid0->
               containsThread (updThreadC cnt c) tid0
        ;  cntUpdateC':
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread (updThreadC cnt c) tid0 ->
               containsThread tp tid0

        ;  cntUpdateR:
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread tp j->
               containsThread (updThreadR cnti r) j
        ;  cntUpdateR':
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread (updThreadR cnti r) j ->
               containsThread tp j

        ;  cntUpdate:
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread tp j ->
               containsThread (updThread cnti c p) j
        ;  cntUpdate':
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread (updThread cnti c p) j ->
               containsThread tp j

        ;  cntUpdateL:
             forall {j tp} add lf,
               containsThread tp j ->
               containsThread (updLockSet tp add lf) j
        ;  cntRemoveL:
             forall {j tp} add,
               containsThread tp j ->
               containsThread (remLockSet tp add) j

        ;  cntUpdateL':
             forall {j tp} add lf,
               containsThread (updLockSet tp add lf) j ->
               containsThread tp j
        ;  cntRemoveL':
             forall {j tp} add,
               containsThread (remLockSet tp add) j ->
               containsThread tp j

        ;  gsoThreadLock:
             forall {i tp} c p (cnti: containsThread tp i),
               lockSet (updThread cnti c p) = lockSet tp

        ;  gsoThreadCLock :
             forall {i tp} c (cnti: containsThread tp i),
               lockSet (updThreadC cnti c) = lockSet tp

        ;  gsoThreadRLock :
             forall {i tp} p (cnti: containsThread tp i),
               lockSet (updThreadR cnti p) = lockSet tp

        ;  gsoAddLock :
             forall tp vf arg p,
               lockSet (addThread tp vf arg p) = lockSet tp

        ;  gssAddRes :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadR cnt' = pmap

        ;  gssThreadCode :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCode :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadC cntj' = getThreadC cntj

        ;  gssThreadRes :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRes :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) (Hneq: i <> j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadR cntj' = getThreadR cntj

        ;  gssThreadCC :
             forall {tid tp} (cnt: containsThread tp tid) c'
               (cnt': containsThread (updThreadC cnt c') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCC :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadC cntj = getThreadC cntj'

        ;  getThreadCC :
             forall {tp} i j
               (cnti : containsThread tp i) (cntj : containsThread tp j)
               c' (cntj' : containsThread (updThreadC cnti c') j),
               getThreadC cntj' = if Nat.eq_dec i j then c' else getThreadC cntj

        ;  gssThreadRR :
             forall {tid tp} (cnt: containsThread tp tid) p'
               (cnt': containsThread (updThreadR cnt p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRR :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) p'
               (cntj': containsThread (updThreadR cnti p') j),
               getThreadR cntj = getThreadR cntj'

        ;  gThreadCR :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadR cntj' = getThreadR cntj

        ;  gThreadRC :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) p
               (cntj': containsThread (updThreadR cnti p) j),
               getThreadC cntj' = getThreadC cntj

        ;  gsoThreadCLPool :
             forall {i tp} c (cnti: containsThread tp i) addr,
               lockRes (updThreadC cnti c) addr = lockRes tp addr

        ;  gsoThreadLPool :
             forall {i tp} c p (cnti: containsThread tp i) addr,
               lockRes (updThread cnti c p) addr = lockRes tp addr

        ;  gsoAddLPool :
             forall tp vf arg p (addr : address),
               lockRes (addThread tp vf arg p) addr = lockRes tp addr

        ;  gLockSetRes :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadR cnti' = getThreadR cnti

        ;  gLockSetCode :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadC cnti' = getThreadC cnti

        ;  gssLockRes :
             forall tp addr pmap,
               lockRes (updLockSet tp addr pmap) addr = Some pmap

        ;  gsoLockRes:
             forall tp addr addr' pmap
               (Hneq: addr <> addr'),
               lockRes (updLockSet tp addr pmap) addr' =
               lockRes tp addr'

        ;  gssLockSet :
             forall tp b ofs rmap ofs',
               (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               (Maps.PMap.get b (lockSet (updLockSet tp (b, ofs) rmap)) ofs') = Some Writable

        ;  gsoLockSet_1 :
             forall tp b ofs ofs'  pmap
               (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),
               (Maps.PMap.get b (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b (lockSet tp)) ofs'
        ;  gsoLockSet_2 :
             forall tp b b' ofs ofs' pmap,
               b <> b' ->
               (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b' (lockSet tp)) ofs'

        ;  lockSet__updLockSet:
             forall tp i (pf: containsThread tp i) c pmap addr rmap,
               lockSet (updLockSet tp addr rmap) =
               lockSet (updLockSet (updThread pf c pmap) addr rmap)

        ;  updThread_updThreadC__comm :
             forall tp i j c pmap' c'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThreadC cnti c) j),
               updThreadC cnti' c = updThread cntj' c' pmap'

        ;  updThread_comm :
             forall tp i j c pmap c' pmap'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThread cnti c pmap) j),
               updThread cnti' c pmap = updThread cntj' c' pmap'

        ;  add_updateC_comm :
             forall tp i vf arg pmap c'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThreadC cnti c') vf arg pmap =
               updThreadC cnti' c'

        ;  add_update_comm :
             forall tp i vf arg pmap c' pmap'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThread cnti c' pmap') vf arg pmap =
               updThread cnti' c' pmap'

        ;  updThread_lr_valid :
             forall tp i (cnti: containsThread tp i) c' m',
               lr_valid (lockRes tp) ->
               lr_valid (lockRes (updThread cnti c' m'))

        ; lockSet_spec_2 :
            forall (js : t) (b : block) (ofs ofs' : Z),
              Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->
              lockRes js (b, ofs) -> (lockSet js) !! b ofs' = Some Memtype.Writable

        ;  lockSet_spec_3 :
             forall ds b ofs,
               (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
               (lockSet ds) !! b ofs = None

        ;  gsslockSet_rem : forall ds b ofs ofs0,
            lr_valid (lockRes ds) ->
            Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->
            isSome ((lockRes ds) (b,ofs)) ->  
            (lockSet (remLockSet ds (b, ofs))) !! b ofs0 =
            None

        ;  gsolockSet_rem1 : forall ds b ofs b' ofs',
            b  <> b' ->
            (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
            (lockSet ds)  !! b' ofs'

        ;  gsolockSet_rem2 : forall ds b ofs ofs',
            lr_valid (lockRes ds) ->
            ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->
            (lockSet (remLockSet ds (b, ofs))) !! b ofs' =
            (lockSet ds)  !! b ofs'
        ;  gsslockResUpdLock: forall js a res,
            lockRes (updLockSet js a res) a =
            Some res
        ;  gsolockResUpdLock : forall js loc a res,
            loc <> a ->
            lockRes (updLockSet js loc res) a =
            lockRes js a

        ;  gsslockResRemLock : forall js a,
            lockRes (remLockSet js a) a =
            None
        ;  gsolockResRemLock : forall js loc a,
            loc <> a ->
            lockRes (remLockSet js loc) a =
            lockRes js a

        ;  gRemLockSetCode :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadC cnti' = getThreadC cnti

        ;  gRemLockSetRes :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadR cnti' = getThreadR cnti

        ;  gsoAddCode :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j)
               (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadC cntj' = getThreadC cntj

        ;  gssAddCode :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadC cnt' = Kinit vf arg

        ;  gsoAddRes :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadR cntj' = getThreadR cntj

        ;  updLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l lmap,
             forall (cnti': containsThread (updLockSet ds l lmap) i),
               updLockSet
                 (@updThread _ ds cnti c map) l lmap =
               @updThread  _ (updLockSet ds l lmap) cnti' c map

        ;  remLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet
                 (updThread cnti c map)
                 l =
               updThread cnti' c map
        ;  remLock_updThreadC_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet (updThreadC cnti c) l = updThreadC cnti' c
      }.

  End ThreadPool.
End ThreadPool.

Module OrdinalPool.

  Definition empty_lset {lock_info}:AMap.t lock_info:=
    AMap.empty lock_info.

  Lemma find_empty:
    forall a l,
      @AMap.find a l empty_lset = None.

  Section OrdinalThreadPool.

    Context {resources: Resources}.

    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Record t := mk
                  { num_threads : pos
                    ; pool :> 'I_num_threads -> ctl
                    ; perm_maps : 'I_num_threads -> res
                    ; lset : AMap.t lock_info
                  }.

    Definition one_pos : pos.pos := pos.mkPos NPeano.Nat.lt_0_1.
    
    Definition mkPool c res :=
      mk one_pos
        (fun _ =>  c)
        (fun _ => res) 
        empty_lset.
    
    Definition lockGuts := lset.
    Definition lockSet (tp:t) := A2PMap (lset tp).

    Definition lockRes t : address -> option lock_info:=
      AMap.find (elt:=lock_info)^~ (lockGuts t).

    Definition lr_valid (lr: address -> option lock_info):=
      forall b ofs,
        match lr (b,ofs) with
        | Some r => forall ofs0:Z, (ofs < ofs0 < ofs+LKSIZE)%Z -> lr (b, ofs0) = None
        | _ => True
        end.

    Lemma is_pos: forall n, (0 < S n)%coq_nat.
    Definition mk_pos_S (n:nat):= mkPos (is_pos n).
    Lemma lt_decr: forall n m: nat, S n < m -> n < m.
    Program Fixpoint find_thread' {st:t}{filter:ctl -> bool} n (P: n < num_threads st) {struct n}:=
      if filter (@pool st (@Ordinal (num_threads st) n P))
      then Some n
      else match n with
           | S n' =>  find_thread' n' (lt_decr  n' _ P)
           | O => None
           end.
    Definition pos_pred (n:pos): nat.

    Program Definition find_thread (st:t)(filter:ctl -> bool): option tid:=
      @find_thread' st filter (pos_pred (num_threads st)) _ .

    Import Coqlib.

    Lemma lockSet_WorNE: forall js b ofs,
        (lockSet js) !! b ofs = Some Memtype.Writable \/

    Lemma lockSet_spec_2 :
      forall (js : t) (b : block) (ofs ofs' : Z),
        Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->

    Lemma lockSet_spec_1: forall js b ofs,
        lockRes js (b,ofs) ->
        (lockSet js) !! b ofs = Some Memtype.Writable.

    Open Scope nat_scope.

    Definition containsThread (tp : t) (i : NatTID.tid) : Prop:=
      i < num_threads tp.

    Definition containsThread_dec:
      forall i tp, {containsThread tp i} + { ~ containsThread tp i}.

    Definition getThreadC {i tp} (cnt: containsThread tp i) : ctl :=
      tp (Ordinal cnt).

    Definition unique_Krun' tp i :=
      ( forall j cnti q,
          @getThreadC j tp cnti = Krun q ->
          eq_nat_dec i j ).

    Definition is_running tp i:=
      exists cnti q, @getThreadC i tp cnti = Krun q.

    Lemma unique_runing_not_running:
      forall tp i,
        unique_Krun' tp i ->
        ~ is_running tp i ->
        forall j, unique_Krun' tp j.

    Definition getThreadR {i tp} (cnt: containsThread tp i) : res :=
      (perm_maps tp) (Ordinal cnt).

    Definition latestThread tp := n (num_threads tp).

    Definition addThread (tp : t) (vf arg : val) (pmap : res) : t :=
      let: new_num_threads := pos_incr (num_threads tp) in
      let: new_tid := ordinal_pos_incr (num_threads tp) in
      mk new_num_threads
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => Kinit vf arg
            | Some n' => tp n'
            end)
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => pmap
            | Some n' => (perm_maps tp) n'
            end)
         (lset tp).

    Definition updLockSet tp (add:address) (lf:lock_info) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.add add lf (lockGuts tp)).

    Definition remLockSet tp  (add:address) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.remove add (lockGuts tp)).

    Definition updThreadC {tid tp} (cnt: containsThread tp tid) (c' : ctl) : t :=
      mk (num_threads tp)
         (fun n => if n == (Ordinal cnt) then c' else (pool tp)  n)
         (perm_maps tp)
         (lset tp).

    Definition updThreadR {tid tp} (cnt: containsThread tp tid)
               (pmap' : res) : t :=
      mk (num_threads tp) (pool tp)
         (fun n =>
            if n == (Ordinal cnt) then pmap' else (perm_maps tp) n)
         (lset tp).

    Definition updThread {tid tp} (cnt: containsThread tp tid) (c' : ctl)
               (pmap : res) : t :=
      mk (num_threads tp)
         (fun n =>
            if n == (Ordinal cnt) then c' else tp n)
         (fun n =>
            if n == (Ordinal cnt) then pmap else (perm_maps tp) n)
         (lset tp).

    Lemma cnt_irr: forall t tid
                     (cnt1 cnt2: containsThread t tid),
        cnt1 = cnt2.

    Lemma numUpdateC :
      forall {tid tp} (cnt: containsThread tp tid) c,
        num_threads tp =  num_threads (updThreadC cnt c).

    Lemma cntUpdateC :
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread tp tid0 ->
        containsThread (updThreadC cnt c) tid0.
    Lemma cntUpdateC':
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread (updThreadC cnt c) tid0 ->
        containsThread tp tid0.

    Lemma cntUpdateR:
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread tp j->
        containsThread (updThreadR cnti r) j.

    Lemma cntUpdateR':
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread (updThreadR cnti r) j ->
        containsThread tp j.

    Lemma cntUpdate :
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread tp j ->
        containsThread (updThread cnti c p) j.

    Lemma cntUpdate':
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread (updThread cnti c p) j ->
        containsThread tp j.

    Lemma cntUpdateL:
      forall {j tp} add lf,
        containsThread tp j ->
        containsThread (updLockSet tp add lf) j.
    Lemma cntRemoveL:
      forall {j tp} add,
        containsThread tp j ->
        containsThread (remLockSet tp add) j.

    Lemma cntUpdateL':
      forall {j tp} add lf,
        containsThread (updLockSet tp add lf) j ->
        containsThread tp j.
    Lemma cntRemoveL':
      forall {j tp} add,
        containsThread (remLockSet tp add) j ->
        containsThread tp j.

    Lemma cntAdd:
      forall {j tp} vf arg p,
        containsThread tp j ->
        containsThread (addThread tp vf arg p) j.

    Lemma cntAddLatest:
      forall {tp} vf arg p,
        containsThread (addThread tp vf arg p) (latestThread tp).

    Lemma cntAdd':
      forall {j tp} vf arg p,
        containsThread (addThread tp vf arg p) j ->
        (containsThread tp j /\ j <> num_threads tp) \/ j = num_threads tp.

    Lemma contains_add_latest: forall ds p a r,
        containsThread (addThread ds p a r)
                       (latestThread ds).

    Lemma updLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l lmap,
      forall (cnti': containsThread (updLockSet ds l lmap) i),
        updLockSet
          (@updThread _ ds cnti c map) l lmap =
        @updThread _ (updLockSet ds l lmap) cnti' c map.
    Lemma remLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l,
      forall (cnti': containsThread (remLockSet ds l) i),
        remLockSet
          (updThread cnti c map)
          l =
        updThread cnti' c map.

    Lemma remLock_updThreadC_comm :
      forall ds i (cnti: containsThread ds i) c l
        (cnti': containsThread (remLockSet ds l) i),
        remLockSet (updThreadC cnti c) l = updThreadC cnti' c.

    Set Bullet Behavior "None".
    Set Bullet Behavior "Strict Subproofs".

    Lemma gsslockResUpdLock: forall js a res,
        lockRes (updLockSet js a res) a =
        Some res.

    Ltac address_ordered_auto :=
      auto; repeat match goal with
                   | H: AddressOrdered.eq ?A ?A |- _ => clear H
                   | H: AddressOrdered.eq ?A ?B |- _ => hnf in H; subst A
                   | H: ?A <> ?A |- _ => contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?A |- _ =>
                     apply AddressOrdered.lt_not_eq in H; contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?B, H': AddressOrdered.lt ?B ?A |- _ =>
                     contradiction (AddressOrdered.lt_not_eq (AddressOrdered.lt_trans H H')); reflexivity
                   end.

    Lemma gsolockResUpdLock: forall js loc a res,
        loc <> a ->
        lockRes (updLockSet js loc res) a =
        lockRes js a.

    Lemma gsslockResRemLock: forall js a,
        lockRes (remLockSet js a) a =
        None.

    Lemma gsolockResRemLock: forall js loc a,
        loc <> a ->
        lockRes (remLockSet js loc) a =
        lockRes js a.

    Lemma gsoThreadLock:
      forall {i tp} c p (cnti: containsThread tp i),
        lockSet (updThread cnti c p) = lockSet tp.

    Lemma gsoThreadCLock:
      forall {i tp} c (cnti: containsThread tp i),
        lockSet (updThreadC cnti c) = lockSet tp.

    Lemma gsoThreadRLock:
      forall {i tp} p (cnti: containsThread tp i),
        lockSet (updThreadR cnti p) = lockSet tp.

    Lemma gsoAddLock:
      forall tp vf arg p,
        lockSet (addThread tp vf arg p) = lockSet tp.

    Lemma PX_in_rev:
      forall elt a m, AMap.Raw.PX.In (elt:=elt) a m <-> AMap.Raw.PX.In a (rev m).

    Import SetoidList.
    Arguments InA {A}{eqA} x _.
    Arguments AMap.In {elt} x m.

    Lemma lockRes_range_dec: forall tp b ofs,
        { (exists z, z <= ofs < z+LKSIZE /\ lockRes tp (b,z) )%Z  } + {(forall z, z <= ofs < z+LKSIZE -> lockRes tp (b,z) = None)%Z }.

    Lemma lockSet_spec_3:
      forall ds b ofs,
        (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
        (lockSet ds) !! b ofs = None.

    Lemma gsslockSet_rem: forall ds b ofs ofs0,
        lr_valid (lockRes ds) ->
        Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gsolockSet_rem1: forall ds b ofs b' ofs',
        b  <> b' ->
        (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
        (lockSet ds)  !! b' ofs'.

    Lemma gsolockSet_rem2: forall ds b ofs ofs',
        lr_valid (lockRes ds) ->
        ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gssThreadCode {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadC cnt' = c'.

    Lemma eq_op_false: forall A i j, i <>j -> @eq_op A i j = false.

    Lemma gsoThreadCode:
      forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
        (cntj: containsThread tp j) c' p'
        (cntj': containsThread (updThread cnti c' p') j),
        getThreadC cntj' = getThreadC cntj.

    Lemma gssThreadRes {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRes {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) (Hneq: i <> j) c' p'
          (cntj': containsThread (updThread cnti c' p') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gssThreadCC {tid tp} (cnt: containsThread tp tid) c'
          (cnt': containsThread (updThreadC cnt c') tid) :
      getThreadC cnt' = c'.

    Lemma gsoThreadCC {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadC cntj = getThreadC cntj'.

    Lemma getThreadCC
          {tp} i j
          (cnti : containsThread tp i) (cntj : containsThread tp j)
          c' (cntj' : containsThread (updThreadC cnti c') j):
      getThreadC cntj' = if eq_nat_dec i j then c' else getThreadC cntj.

    Lemma gssThreadRR {tid tp} (cnt: containsThread tp tid) p'
          (cnt': containsThread (updThreadR cnt p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRR {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) p'
          (cntj': containsThread (updThreadR cnti p') j) :
      getThreadR cntj = getThreadR cntj'.

    Lemma gThreadCR {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gThreadRC {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) p
          (cntj': containsThread (updThreadR cnti p) j) :
      getThreadC cntj' = getThreadC cntj.

    Lemma unlift_m_inv :
      forall tp i (Htid : i < (num_threads tp).+1) ord

    Lemma gssAddRes:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadR cnt' = pmap.

    Lemma gsoAddRes:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadR cntj' = getThreadR cntj.

    Lemma gssAddCode:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadC cnt' = Kinit vf arg.

    Lemma gsoAddCode:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j)
        (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadC cntj' = getThreadC cntj.

    Lemma add_update_comm:
      forall tp i vf arg pmap c' pmap'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThread cnti c' pmap') vf arg pmap =
        updThread cnti' c' pmap'.

    Lemma add_updateC_comm:
      forall tp i vf arg pmap c'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThreadC cnti c') vf arg pmap =
        updThreadC cnti' c'.

    Lemma updThread_comm :
      forall tp  i j c pmap c' pmap'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThread cnti c pmap) j),
        updThread cnti' c pmap = updThread cntj' c' pmap'.

    Lemma updThread_updThreadC_comm :
      forall tp i j c pmap' c'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThreadC cnti c) j),
        updThreadC cnti' c = updThread cntj' c' pmap'.

    Lemma updThread_same :
      forall tp i (cnti : containsThread tp i),
      updThread cnti (getThreadC cnti) (getThreadR cnti) = tp.

    Lemma updThread_twice :
      forall tp i (cnti : containsThread tp i) c c' r r'
        (cnti' : containsThread (updThread cnti c r) i),
      updThread cnti' c' r' = updThread cnti c' r'.

    Lemma updThreadRC : forall tp i (cnti : containsThread tp i) c,
      updThread cnti c (getThreadR cnti) = updThreadC cnti c.

    Lemma gsoThreadCLPool:
      forall {i tp} c (cnti: containsThread tp i) addr,
        lockRes (updThreadC cnti c) addr = lockRes tp addr.

    Lemma gsoThreadLPool:
      forall {i tp} c p (cnti: containsThread tp i) addr,
        lockRes (updThread cnti c p) addr = lockRes tp addr.

    Lemma gsoAddLPool:
      forall tp vf arg p (addr : address),
        lockRes (addThread tp vf arg p) addr = lockRes tp addr.

    Lemma gLockSetRes:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gLockSetCode:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetCode:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetRes:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gssLockRes:
      forall tp addr pmap,
        lockRes (updLockSet tp addr pmap) addr = Some pmap.

    Lemma gsoLockRes:
      forall tp addr addr' pmap
        (Hneq: addr <> addr'),
        lockRes (updLockSet tp addr pmap) addr' =
        lockRes tp addr'.

    Lemma gssLockSet:
      forall tp b ofs rmap ofs',
        (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->

    Lemma gsoLockSet_12 :
      forall tp b b' ofs ofs' pmap,
        ~ adr_range (b,ofs) LKSIZE (b',ofs') ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma gsoLockSet_1:
      forall tp b ofs ofs'  pmap
        (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),

    Lemma gsoLockSet_2 :
      forall tp b b' ofs ofs' pmap,
        b <> b' ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma lockSet_updLockSet:
      forall tp i (pf: containsThread tp i) c pmap addr rmap,
        lockSet (updLockSet tp addr rmap) =
        lockSet (updLockSet (updThread pf c pmap) addr rmap).

    Lemma updThread_lr_valid:
      forall tp i (cnti: containsThread tp i) c' m',
        lr_valid (lockRes tp) ->
        lr_valid (lockRes (updThread cnti c' m')).

    Lemma contains_iff_num:
      forall tp tp'
        (Hcnt: forall i, containsThread tp i <-> containsThread tp' i),
        num_threads tp = num_threads tp'.

    Lemma leq_stepdown:
      forall {m n},
        S n <= m -> n <= m.
    
    Lemma lt_sub:
      forall {m n},
        S n <= m ->
        m - (S n) <  m.

    Fixpoint containsList_upto_n (n m:nat): n <= m -> seq.seq (sigT (fun i => i < m)):=
      match n with
      | O => fun _ => nil
      | S n' => fun (H: S n' <= m) =>
                 (existT (fun i => i < m) (m-(S n')) (lt_sub H)) ::
                 (containsList_upto_n n' m) (leq_stepdown H)                                  
      end.

    Lemma containsList_upto_n_spec:
      forall m n (H: n <= m)
        i (cnti:  (fun i => i < m) (m - n + i)),
        i < n ->
        nth_error (containsList_upto_n n m H) i = Some (existT _ (m - n + i) (cnti)). 
    
    Definition containsList' (n:nat): seq.seq (sigT (fun i => i < n)):=
      containsList_upto_n n n (leq_refl n).

    Definition contains_from_ineq (tp:t):
        {i : tid & i < num_threads tp } -> {i : tid & containsThread tp i}:=
       fun (H : {i : tid & i < num_threads tp}) =>
         let (x, i) := H in existT (containsThread tp) x i.

    Definition containsList (tp:t): seq.seq (sigT (containsThread tp)):=
      map (contains_from_ineq tp) (containsList' (num_threads tp)).

    Lemma containsList'_spec: forall i n
            (cnti: (fun i => i < n) i),
            List.nth_error (containsList' n) i = Some (existT _ i (cnti)).

    Lemma containsList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (containsList tp) i = Some (existT _ i cnti).
      
    Definition indexed_contains tp:= (fun Ncontained: (sigT (containsThread tp)) =>
             let (i, cnti) := Ncontained in getThreadR cnti).
    
    Definition resourceList (tp:t): seq.seq res:=
      map (@indexed_contains tp)
          (containsList tp).

    Lemma resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti).
        
    Definition OrdinalThreadPool: ThreadPool.ThreadPool :=
      (@ThreadPool.Build_ThreadPool _ _
                                    t
                                    mkPool
                                    containsThread
                                    (@getThreadC) 
                                    (@getThreadR) 
                                    resourceList
                                    lockGuts
                                    lockSet
                                    (@lockRes) 
                                    addThread
                                    (@updThreadC) 
                                    (@updThreadR)
                                    (@updThread) 
                                    updLockSet 
                                    remLockSet 
                                    latestThread 
                                    lr_valid 
                                    
                                    find_thread
                                    resourceList_spec
                                    containsThread_dec
                                    
                                    cnt_irr
                                    (@cntAdd)
                                    (@cntAddLatest)
                                    (@cntAdd')
                                    (@cntUpdateC)
                                    (@cntUpdateC')
                                    (@cntUpdateR)
                                    (@cntUpdateR')
                                    (@cntUpdate)
                                    (@cntUpdate')
                                    (@cntUpdateL)
                                    (@cntRemoveL)
                                    (@cntUpdateL')
                                    (@cntRemoveL')
                                    (@gsoThreadLock)
                                    (@gsoThreadCLock)
                                    (@gsoThreadRLock)
                                    (@gsoAddLock)
                                    (@gssAddRes)
                                    (@gssThreadCode)
                                    (@gsoThreadCode)
                                    (@gssThreadRes)
                                    (@gsoThreadRes)
                                    (@gssThreadCC)
                                    (@gsoThreadCC)
                                    (@getThreadCC)
                                    (@gssThreadRR)
                                    (@gsoThreadRR)
                                    (@gThreadCR)
                                    (@gThreadRC)
                                    (@gsoThreadCLPool)
                                    (@gsoThreadLPool)
                                    (@gsoAddLPool)
                                    (@gLockSetRes)
                                    (@gLockSetCode)
                                    (@gssLockRes)
                                    (@gsoLockRes)
                                    (@gssLockSet)
                                    (@gsoLockSet_1)
                                    gsoLockSet_2
                                    lockSet_updLockSet
                                    updThread_updThreadC_comm
                                    updThread_comm
                                    add_updateC_comm
                                    add_update_comm
                                    updThread_lr_valid
                                    lockSet_spec_2
                                    lockSet_spec_3
                                    gsslockSet_rem
                                    gsolockSet_rem1
                                    gsolockSet_rem2
                                    gsslockResUpdLock
                                    gsolockResUpdLock
                                    gsslockResRemLock
                                    gsolockResRemLock
                                    (@ gRemLockSetCode)
                                    (@gRemLockSetRes)
                                    (@gsoAddCode)
                                    (@gssAddCode)
                                    (@gsoAddRes)
                                    updLock_updThread_comm
                                    remLock_updThread_comm
                                    remLock_updThreadC_comm
      ).

  End OrdinalThreadPool.
End OrdinalPool. *)



Require Import compcert.common.Memory. 
(* compcert.common.Memory:
Require Import Zwf.
Require Import Axioms.
Require Import Coqlib.
Require Intv.
Require Import Maps.
Require Archi.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Export Memdata.
Require Export Memtype.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Local Notation "a # b" := (PMap.get b a) (at level 1).

Module Mem <: MEM.

Definition perm_order' (po: option permission) (p: permission) :=
  match po with
  | Some p' => perm_order p' p
  | None => False
 end.

Definition perm_order'' (po1 po2: option permission) :=
  match po1, po2 with
  | Some p1, Some p2 => perm_order p1 p2
  | _, None => True
  | None, Some _ => False
 end.

Record mem' : Type := mkmem {
  mem_contents: PMap.t (ZMap.t memval);  
  mem_access: PMap.t (Z -> perm_kind -> option permission);
                                         
  nextblock: block;
  access_max:
    forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
  nextblock_noaccess:
    forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
  contents_default:
    forall b, fst mem_contents#b = Undef
}.

Definition mem := mem'.

Lemma mkmem_ext:
 forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.

Definition valid_block (m: mem) (b: block) := Plt b (nextblock m).

Theorem valid_not_valid_diff:
  forall m b b', valid_block m b -> ~(valid_block m b') -> b <> b'.

Local Hint Resolve valid_not_valid_diff: mem.

Definition perm (m: mem) (b: block) (ofs: Z) (k: perm_kind) (p: permission) : Prop :=
   perm_order' (m.(mem_access)#b ofs k) p.

Theorem perm_implies:
  forall m b ofs k p1 p2, perm m b ofs k p1 -> perm_order p1 p2 -> perm m b ofs k p2.

Local Hint Resolve perm_implies: mem.

Theorem perm_cur_max:
  forall m b ofs p, perm m b ofs Cur p -> perm m b ofs Max p.

Theorem perm_cur:
  forall m b ofs k p, perm m b ofs Cur p -> perm m b ofs k p.

Theorem perm_max:
  forall m b ofs k p, perm m b ofs k p -> perm m b ofs Max p.

Local Hint Resolve perm_cur perm_max: mem.

Theorem perm_valid_block:
  forall m b ofs k p, perm m b ofs k p -> valid_block m b.

Local Hint Resolve perm_valid_block: mem.

Remark perm_order_dec:
  forall p1 p2, {perm_order p1 p2} + {~perm_order p1 p2}.

Remark perm_order'_dec:
  forall op p, {perm_order' op p} + {~perm_order' op p}.

Theorem perm_dec:
  forall m b ofs k p, {perm m b ofs k p} + {~ perm m b ofs k p}.

Definition range_perm (m: mem) (b: block) (lo hi: Z) (k: perm_kind) (p: permission) : Prop :=
  forall ofs, lo <= ofs < hi -> perm m b ofs k p.

Theorem range_perm_implies:
  forall m b lo hi k p1 p2,
  range_perm m b lo hi k p1 -> perm_order p1 p2 -> range_perm m b lo hi k p2.

Theorem range_perm_cur:
  forall m b lo hi k p,
  range_perm m b lo hi Cur p -> range_perm m b lo hi k p.

Theorem range_perm_max:
  forall m b lo hi k p,
  range_perm m b lo hi k p -> range_perm m b lo hi Max p.

Local Hint Resolve range_perm_implies range_perm_cur range_perm_max: mem.

Lemma range_perm_dec:
  forall m b lo hi k p, {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.

Definition valid_access (m: mem) (chunk: memory_chunk) (b: block) (ofs: Z) (p: permission): Prop :=
  range_perm m b ofs (ofs + size_chunk chunk) Cur p
  /\ (align_chunk chunk | ofs).

Theorem valid_access_implies:
  forall m chunk b ofs p1 p2,
  valid_access m chunk b ofs p1 -> perm_order p1 p2 ->
  valid_access m chunk b ofs p2.

Theorem valid_access_freeable_any:
  forall m chunk b ofs p,
  valid_access m chunk b ofs Freeable ->
  valid_access m chunk b ofs p.

Local Hint Resolve valid_access_implies: mem.

Theorem valid_access_valid_block:
  forall m chunk b ofs,
  valid_access m chunk b ofs Nonempty ->
  valid_block m b.

Local Hint Resolve valid_access_valid_block: mem.

Lemma valid_access_perm:
  forall m chunk b ofs k p,
  valid_access m chunk b ofs p ->
  perm m b ofs k p.

Lemma valid_access_compat:
  forall m chunk1 chunk2 b ofs p,
  size_chunk chunk1 = size_chunk chunk2 ->
  align_chunk chunk2 <= align_chunk chunk1 ->
  valid_access m chunk1 b ofs p->
  valid_access m chunk2 b ofs p.

Lemma valid_access_dec:
  forall m chunk b ofs p,
  {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.

Definition valid_pointer (m: mem) (b: block) (ofs: Z): bool :=
  perm_dec m b ofs Cur Nonempty.

Theorem valid_pointer_nonempty_perm:
  forall m b ofs,
  valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.

Theorem valid_pointer_valid_access:
  forall m b ofs,
  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.

Definition weak_valid_pointer (m: mem) (b: block) (ofs: Z) :=
  valid_pointer m b ofs || valid_pointer m b (ofs - 1).

Lemma weak_valid_pointer_spec:
  forall m b ofs,
  weak_valid_pointer m b ofs = true <->
    valid_pointer m b ofs = true \/ valid_pointer m b (ofs - 1) = true.
Lemma valid_pointer_implies:
  forall m b ofs,
  valid_pointer m b ofs = true -> weak_valid_pointer m b ofs = true.

Program Definition empty: mem :=
  mkmem (PMap.init (ZMap.init Undef))

Program Definition alloc (m: mem) (lo hi: Z) :=
  (mkmem (PMap.set m.(nextblock)

Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
  mkmem m.(mem_contents)

Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
  if range_perm_dec m b lo hi Cur Freeable
  then Some(unchecked_free m b lo hi)
  else None.

Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
  match l with
  | nil => Some m
  | (b, lo, hi) :: l' =>
      match free m b lo hi with
      | None => None
      | Some m' => free_list m' l'
      end
  end.

Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
  match n with
  | O => nil
  | S n' => ZMap.get p c :: getN n' (p + 1) c
  end.

Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
  if valid_access_dec m chunk b ofs Readable
  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
  else None.

Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
  match addr with
  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
  | _ => None
  end.

Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
  if range_perm_dec m b ofs (ofs + n) Cur Readable
  then Some (getN (nat_of_Z n) ofs (m.(mem_contents)#b))
  else None.

Fixpoint setN (vl: list memval) (p: Z) (c: ZMap.t memval) {struct vl}: ZMap.t memval :=
  match vl with
  | nil => c
  | v :: vl' => setN vl' (p + 1) (ZMap.set p v c)
  end.

Remark setN_other:
  forall vl c p q,
  (forall r, p <= r < p + Z.of_nat (length vl) -> r <> q) ->

Remark setN_outside:
  forall vl c p q,
  q < p \/ q >= p + Z.of_nat (length vl) ->

Remark getN_setN_same:
  forall vl p c,
  getN (length vl) p (setN vl p c) = vl.

Remark getN_exten:
  forall c1 c2 n p,
  (forall i, p <= i < p + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->

Remark getN_setN_disjoint:
  forall vl q c n p,
  Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (length vl)) ->

Remark getN_setN_outside:
  forall vl q c n p,
  p + Z.of_nat n <= q \/ q + Z.of_nat (length vl) <= p ->

Remark setN_default:
  forall vl q c, fst (setN vl q c) = fst c.

Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val): option mem :=
  if valid_access_dec m chunk b ofs Writable then
    Some (mkmem (PMap.set b

Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
  match addr with
  | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
  | _ => None
  end.

Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
  if range_perm_dec m b ofs (ofs + Z.of_nat (length bytes)) Cur Writable then

Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
  if range_perm_dec m b lo hi Cur Freeable then
    Some (mkmem m.(mem_contents)

Theorem nextblock_empty: nextblock empty = 1%positive.

Theorem perm_empty: forall b ofs k p, ~perm empty b ofs k p.

Theorem valid_access_empty: forall chunk b ofs p, ~valid_access empty chunk b ofs p.

Theorem valid_access_load:
  forall m chunk b ofs,
  valid_access m chunk b ofs Readable ->
  exists v, load chunk m b ofs = Some v.

Theorem load_valid_access:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  valid_access m chunk b ofs Readable.

Lemma load_result:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).

Local Hint Resolve load_valid_access valid_access_load: mem.

Theorem load_type:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  Val.has_type v (type_of_chunk chunk).

Theorem load_cast:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v

Theorem load_int8_signed_unsigned:
  forall m b ofs,
  load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).

Theorem load_int16_signed_unsigned:
  forall m b ofs,
  load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).

Theorem range_perm_loadbytes:
  forall m b ofs len,
  range_perm m b ofs (ofs + len) Cur Readable ->
  exists bytes, loadbytes m b ofs len = Some bytes.

Theorem loadbytes_range_perm:
  forall m b ofs len bytes,
  loadbytes m b ofs len = Some bytes ->
  range_perm m b ofs (ofs + len) Cur Readable.

Theorem loadbytes_load:
  forall chunk m b ofs bytes,
  loadbytes m b ofs (size_chunk chunk) = Some bytes ->
  (align_chunk chunk | ofs) ->
  load chunk m b ofs = Some(decode_val chunk bytes).

Theorem load_loadbytes:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
             /\ v = decode_val chunk bytes.

Lemma getN_length:
  forall c n p, length (getN n p c) = n.

Theorem loadbytes_length:
  forall m b ofs n bytes,
  loadbytes m b ofs n = Some bytes ->
  length bytes = nat_of_Z n.

Theorem loadbytes_empty:
  forall m b ofs n,
  n <= 0 -> loadbytes m b ofs n = Some nil.

Lemma getN_concat:
  forall c n1 n2 p,
  getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z.of_nat n1) c.

Theorem loadbytes_concat:
  forall m b ofs n1 n2 bytes1 bytes2,
  loadbytes m b ofs n1 = Some bytes1 ->
  loadbytes m b (ofs + n1) n2 = Some bytes2 ->
  n1 >= 0 -> n2 >= 0 ->
  loadbytes m b ofs (n1 + n2) = Some(bytes1 ++ bytes2).

Theorem loadbytes_split:
  forall m b ofs n1 n2 bytes,
  loadbytes m b ofs (n1 + n2) = Some bytes ->
  n1 >= 0 -> n2 >= 0 ->
  exists bytes1, exists bytes2,
     loadbytes m b ofs n1 = Some bytes1
  /\ loadbytes m b (ofs + n1) n2 = Some bytes2
  /\ bytes = bytes1 ++ bytes2.

Theorem load_rep:
 forall ch m1 m2 b ofs v1 v2,
  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->

Theorem load_int64_split:
  forall m b ofs v,
  load Mint64 m b ofs = Some v -> Archi.ptr64 = false ->

Lemma addressing_int64_split:
  forall i,
  Archi.ptr64 = false ->

Theorem loadv_int64_split:
  forall m a v,
  loadv Mint64 m a = Some v -> Archi.ptr64 = false ->

Theorem valid_access_store:
  forall m1 chunk b ofs v,
  valid_access m1 chunk b ofs Writable ->
  { m2: mem | store chunk m1 b ofs v = Some m2 }.

Local Hint Resolve valid_access_store: mem.

Section STORE.
Variable chunk: memory_chunk.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable v: val.
Variable m2: mem.
Hypothesis STORE: store chunk m1 b ofs v = Some m2.

Lemma store_access: mem_access m2 = mem_access m1.

Lemma store_mem_contents:
  mem_contents m2 = PMap.set b (setN (encode_val chunk v) ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_store_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_store_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_store_1 perm_store_2: mem.

Theorem nextblock_store:
  nextblock m2 = nextblock m1.

Theorem store_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem store_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.

Theorem store_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem store_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Theorem store_valid_access_3:
  valid_access m1 chunk b ofs Writable.

Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.

Theorem load_store_similar:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  exists v', load chunk' m2 b ofs = Some v' /\ decode_encode_val v chunk chunk' v'.

Theorem load_store_similar_2:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  type_of_chunk chunk' = type_of_chunk chunk ->
  load chunk' m2 b ofs = Some (Val.load_result chunk' v).

Theorem load_store_same:
  load chunk m2 b ofs = Some (Val.load_result chunk v).

Theorem load_store_other:
  forall chunk' b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk' <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.

Theorem loadbytes_store_same:
  loadbytes m2 b ofs (size_chunk chunk) = Some(encode_val chunk v).

Theorem loadbytes_store_other:
  forall b' ofs' n,
  b' <> b
  \/ n <= 0
  \/ ofs' + n <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.

Lemma setN_in:
  forall vl p q c,
  p <= q < p + Z.of_nat (length vl) ->

Lemma getN_in:
  forall c q n p,
  p <= q < p + Z.of_nat n ->

End STORE.

Local Hint Resolve perm_store_1 perm_store_2: mem.
Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.
Local Hint Resolve store_valid_access_1 store_valid_access_2
             store_valid_access_3: mem.

Lemma load_store_overlap:
  forall chunk m1 b ofs v m2 chunk' ofs' v',
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b ofs' = Some v' ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  exists mv1 mvl mv1' mvl',
      shape_encoding chunk v (mv1 :: mvl)
  /\  shape_decoding chunk' (mv1' :: mvl') v'
  /\  (   (ofs' = ofs /\ mv1' = mv1)
       \/ (ofs' > ofs /\ In mv1' mvl)
       \/ (ofs' < ofs /\ In mv1 mvl')).

Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
  match chunk1, chunk2 with
  | (Mint32 | Many32), (Mint32 | Many32) => True
  | (Mint64 | Many64), (Mint64 | Many64) => True
  | _, _ => False
  end.

Lemma compat_pointer_chunks_true:
  forall chunk1 chunk2,
  (chunk1 = Mint32 \/ chunk1 = Many32 \/ chunk1 = Mint64 \/ chunk1 = Many64) ->
  (chunk2 = Mint32 \/ chunk2 = Many32 \/ chunk2 = Mint64 \/ chunk2 = Many64) ->
  quantity_chunk chunk1 = quantity_chunk chunk2 ->
  compat_pointer_chunks chunk1 chunk2.

Theorem load_pointer_store:
  forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b' ofs' = Some(Vptr v_b v_o) ->
  (v = Vptr v_b v_o /\ compat_pointer_chunks chunk chunk' /\ b' = b /\ ofs' = ofs)
  \/ (b' <> b \/ ofs' + size_chunk chunk' <= ofs \/ ofs + size_chunk chunk <= ofs').

Theorem load_store_pointer_overlap:
  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs' = Some v ->
  ofs' <> ofs ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  v = Vundef.

Theorem load_store_pointer_mismatch:
  forall chunk m1 b ofs v_b v_o m2 chunk' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs = Some v ->
  ~compat_pointer_chunks chunk chunk' ->
  v = Vundef.

Lemma store_similar_chunks:
  forall chunk1 chunk2 v1 v2 m b ofs,
  encode_val chunk1 v1 = encode_val chunk2 v2 ->
  align_chunk chunk1 = align_chunk chunk2 ->
  store chunk1 m b ofs v1 = store chunk2 m b ofs v2.

Theorem store_signed_unsigned_8:
  forall m b ofs v,
  store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.

Theorem store_signed_unsigned_16:
  forall m b ofs v,
  store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.

Theorem store_int8_zero_ext:
  forall m b ofs n,
  store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =

Theorem store_int8_sign_ext:
  forall m b ofs n,
  store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =

Theorem store_int16_zero_ext:
  forall m b ofs n,
  store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =

Theorem store_int16_sign_ext:
  forall m b ofs n,
  store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =

Theorem range_perm_storebytes:
  forall m1 b ofs bytes,
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable ->

Theorem storebytes_store:
  forall m1 b ofs chunk v m2,
  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
  (align_chunk chunk | ofs) ->
  store chunk m1 b ofs v = Some m2.

Theorem store_storebytes:
  forall m1 b ofs chunk v m2,
  store chunk m1 b ofs v = Some m2 ->
  storebytes m1 b ofs (encode_val chunk v) = Some m2.

Section STOREBYTES.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable bytes: list memval.
Variable m2: mem.
Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.

Lemma storebytes_access: mem_access m2 = mem_access m1.

Lemma storebytes_mem_contents:
   mem_contents m2 = PMap.set b (setN bytes ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_storebytes_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_storebytes_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.

Theorem storebytes_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem storebytes_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Local Hint Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.

Theorem nextblock_storebytes:
  nextblock m2 = nextblock m1.

Theorem storebytes_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem storebytes_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.

Theorem storebytes_range_perm:
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable.

Theorem loadbytes_storebytes_same:
  loadbytes m2 b ofs (Z.of_nat (length bytes)) = Some bytes.

Theorem loadbytes_storebytes_disjoint:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b \/ Intv.disjoint (ofs', ofs' + len) (ofs, ofs + Z.of_nat (length bytes)) ->

Theorem loadbytes_storebytes_other:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b
  \/ ofs' + len <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

Theorem load_storebytes_other:
  forall chunk b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

End STOREBYTES.

Lemma setN_concat:
  forall bytes1 bytes2 ofs c,
  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z.of_nat (length bytes1)) (setN bytes1 ofs c).

Theorem storebytes_concat:
  forall m b ofs bytes1 m1 bytes2 m2,
  storebytes m b ofs bytes1 = Some m1 ->
  storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2 ->

Theorem storebytes_split:
  forall m b ofs bytes1 bytes2 m2,
  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
  exists m1,
     storebytes m b ofs bytes1 = Some m1
  /\ storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2.

Theorem store_int64_split:
  forall m b ofs v m',
  store Mint64 m b ofs v = Some m' -> Archi.ptr64 = false ->

Theorem storev_int64_split:
  forall m a v m',
  storev Mint64 m a v = Some m' -> Archi.ptr64 = false ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: block.
Hypothesis ALLOC: alloc m1 lo hi = (m2, b).

Theorem nextblock_alloc:
  nextblock m2 = Pos.succ (nextblock m1).

Theorem alloc_result:
  b = nextblock m1.

Theorem valid_block_alloc:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem fresh_block_alloc:
  ~(valid_block m1 b).

Theorem valid_new_block:
  valid_block m2 b.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.

Theorem valid_block_alloc_inv:
  forall b', valid_block m2 b' -> b' = b \/ valid_block m1 b'.

Theorem perm_alloc_1:
  forall b' ofs k p, perm m1 b' ofs k p -> perm m2 b' ofs k p.

Theorem perm_alloc_2:
  forall ofs k, lo <= ofs < hi -> perm m2 b ofs k Freeable.

Theorem perm_alloc_inv:
  forall b' ofs k p,
  perm m2 b' ofs k p ->
  if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p.

Theorem perm_alloc_3:
  forall ofs k p, perm m2 b ofs k p -> lo <= ofs < hi.

Theorem perm_alloc_4:
  forall b' ofs k p, perm m2 b' ofs k p -> b' <> b -> perm m1 b' ofs k p.

Local Hint Resolve perm_alloc_1 perm_alloc_2 perm_alloc_3 perm_alloc_4: mem.

Theorem valid_access_alloc_other:
  forall chunk b' ofs p,
  valid_access m1 chunk b' ofs p ->
  valid_access m2 chunk b' ofs p.

Theorem valid_access_alloc_same:
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  valid_access m2 chunk b ofs Freeable.

Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem valid_access_alloc_inv:
  forall chunk b' ofs p,
  valid_access m2 chunk b' ofs p ->
  if eq_block b' b
  then lo <= ofs /\ ofs + size_chunk chunk <= hi /\ (align_chunk chunk | ofs)
  else valid_access m1 chunk b' ofs p.

Theorem load_alloc_unchanged:
  forall chunk b' ofs,
  valid_block m1 b' ->
  load chunk m2 b' ofs = load chunk m1 b' ofs.

Theorem load_alloc_other:
  forall chunk b' ofs v,
  load chunk m1 b' ofs = Some v ->
  load chunk m2 b' ofs = Some v.

Theorem load_alloc_same:
  forall chunk ofs v,
  load chunk m2 b ofs = Some v ->
  v = Vundef.

Theorem load_alloc_same':
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  load chunk m2 b ofs = Some Vundef.

Theorem loadbytes_alloc_unchanged:
  forall b' ofs n,
  valid_block m1 b' ->
  loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.

Theorem loadbytes_alloc_same:
  forall n ofs bytes byte,
  loadbytes m2 b ofs n = Some bytes ->
  In byte bytes -> byte = Undef.

End ALLOC.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem range_perm_free:
  forall m1 b lo hi,
  range_perm m1 b lo hi Cur Freeable ->
  { m2: mem | free m1 b lo hi = Some m2 }.

Section FREE.

Variable m1: mem.
Variable bf: block.
Variables lo hi: Z.
Variable m2: mem.
Hypothesis FREE: free m1 bf lo hi = Some m2.

Theorem free_range_perm:
  range_perm m1 bf lo hi Cur Freeable.

Lemma free_result:
  m2 = unchecked_free m1 bf lo hi.

Theorem nextblock_free:
  nextblock m2 = nextblock m1.

Theorem valid_block_free_1:
  forall b, valid_block m1 b -> valid_block m2 b.

Theorem valid_block_free_2:
  forall b, valid_block m2 b -> valid_block m1 b.

Local Hint Resolve valid_block_free_1 valid_block_free_2: mem.

Theorem perm_free_1:
  forall b ofs k p,
  b <> bf \/ ofs < lo \/ hi <= ofs ->
  perm m1 b ofs k p ->
  perm m2 b ofs k p.

Theorem perm_free_2:
  forall ofs k p, lo <= ofs < hi -> ~ perm m2 bf ofs k p.

Theorem perm_free_3:
  forall b ofs k p,
  perm m2 b ofs k p -> perm m1 b ofs k p.

Theorem perm_free_inv:
  forall b ofs k p,
  perm m1 b ofs k p ->
  (b = bf /\ lo <= ofs < hi) \/ perm m2 b ofs k p.

Theorem valid_access_free_1:
  forall chunk b ofs p,
  valid_access m1 chunk b ofs p ->
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  valid_access m2 chunk b ofs p.

Theorem valid_access_free_2:
  forall chunk ofs p,
  lo < hi -> ofs + size_chunk chunk > lo -> ofs < hi ->
  ~(valid_access m2 chunk bf ofs p).

Theorem valid_access_free_inv_1:
  forall chunk b ofs p,
  valid_access m2 chunk b ofs p ->
  valid_access m1 chunk b ofs p.

Theorem valid_access_free_inv_2:
  forall chunk ofs p,
  valid_access m2 chunk bf ofs p ->
  lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs.

Theorem load_free:
  forall chunk b ofs,
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  load chunk m2 b ofs = load chunk m1 b ofs.

Theorem load_free_2:
  forall chunk b ofs v,
  load chunk m2 b ofs = Some v -> load chunk m1 b ofs = Some v.

Theorem loadbytes_free:
  forall b ofs n,
  b <> bf \/ lo >= hi \/ ofs + n <= lo \/ hi <= ofs ->
  loadbytes m2 b ofs n = loadbytes m1 b ofs n.

Theorem loadbytes_free_2:
  forall b ofs n bytes,
  loadbytes m2 b ofs n = Some bytes -> loadbytes m1 b ofs n = Some bytes.

End FREE.

Local Hint Resolve valid_block_free_1 valid_block_free_2
             perm_free_1 perm_free_2 perm_free_3
             valid_access_free_1 valid_access_free_inv_1: mem.

Theorem range_perm_drop_1:
  forall m b lo hi p m', drop_perm m b lo hi p = Some m' -> range_perm m b lo hi Cur Freeable.

Theorem range_perm_drop_2:
  forall m b lo hi p,
  range_perm m b lo hi Cur Freeable -> {m' | drop_perm m b lo hi p = Some m' }.

Section DROP.

Variable m: mem.
Variable b: block.
Variable lo hi: Z.
Variable p: permission.
Variable m': mem.
Hypothesis DROP: drop_perm m b lo hi p = Some m'.

Theorem nextblock_drop:
  nextblock m' = nextblock m.

Theorem drop_perm_valid_block_1:
  forall b', valid_block m b' -> valid_block m' b'.

Theorem drop_perm_valid_block_2:
  forall b', valid_block m' b' -> valid_block m b'.

Theorem perm_drop_1:
  forall ofs k, lo <= ofs < hi -> perm m' b ofs k p.

Theorem perm_drop_2:
  forall ofs k p', lo <= ofs < hi -> perm m' b ofs k p' -> perm_order p p'.

Theorem perm_drop_3:
  forall b' ofs k p', b' <> b \/ ofs < lo \/ hi <= ofs -> perm m b' ofs k p' -> perm m' b' ofs k p'.

Theorem perm_drop_4:
  forall b' ofs k p', perm m' b' ofs k p' -> perm m b' ofs k p'.

Lemma valid_access_drop_1:
  forall chunk b' ofs p',
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p p' ->
  valid_access m chunk b' ofs p' -> valid_access m' chunk b' ofs p'.

Lemma valid_access_drop_2:
  forall chunk b' ofs p',
  valid_access m' chunk b' ofs p' -> valid_access m chunk b' ofs p'.

Theorem load_drop:
  forall chunk b' ofs,
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p Readable ->
  load chunk m' b' ofs = load chunk m b' ofs.

Theorem loadbytes_drop:
  forall b' ofs n,
  b' <> b \/ ofs + n <= lo \/ hi <= ofs \/ perm_order p Readable ->
  loadbytes m' b' ofs n = loadbytes m b' ofs n.

End DROP.

Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
  mk_mem_inj {
    mi_perm:
      forall b1 b2 delta ofs k p,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs k p ->
      perm m2 b2 (ofs + delta) k p;
    mi_align:
      forall b1 b2 delta chunk ofs p,
      f b1 = Some(b2, delta) ->
      range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->
      (align_chunk chunk | delta);
    mi_memval:
      forall b1 ofs b2 delta,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs Cur Readable ->
      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
  }.

Lemma perm_inj:
  forall f m1 m2 b1 ofs k p b2 delta,
  mem_inj f m1 m2 ->
  perm m1 b1 ofs k p ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p.

Lemma range_perm_inj:
  forall f m1 m2 b1 lo hi k p b2 delta,
  mem_inj f m1 m2 ->
  range_perm m1 b1 lo hi k p ->
  f b1 = Some(b2, delta) ->
  range_perm m2 b2 (lo + delta) (hi + delta) k p.

Lemma valid_access_inj:
  forall f m1 m2 b1 b2 delta chunk ofs p,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Lemma getN_inj:
  forall f m1 m2 b1 b2 delta,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  forall n ofs,
  range_perm m1 b1 ofs (ofs + Z.of_nat n) Cur Readable ->

Lemma load_inj:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  mem_inj f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Lemma loadbytes_inj:
  forall f m1 m2 len b1 ofs b2 delta bytes1,
  mem_inj f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Lemma setN_inj:
  forall (access: Z -> Prop) delta f vl1 vl2,
  list_forall2 (memval_inject f) vl1 vl2 ->
  forall p c1 c2,
  (forall q, access q -> memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2)) ->

Definition meminj_no_overlap (f: meminj) (m: mem) : Prop :=
  forall b1 b1' delta1 b2 b2' delta2 ofs1 ofs2,
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m b1 ofs1 Max Nonempty ->
  perm m b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Lemma store_mapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Lemma store_unmapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma store_outside_inj:
  forall f m1 m2 chunk b ofs v m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  mem_inj f m1 m2'.

Lemma storebytes_mapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ mem_inj f n1 n2.

Lemma storebytes_unmapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma storebytes_outside_inj:
  forall f m1 m2 b ofs bytes2 m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Lemma storebytes_empty_inj:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  mem_inj f m1' m2'.

Lemma alloc_right_inj:
  forall f m1 m2 lo hi b2 m2',
  mem_inj f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  mem_inj f m1 m2'.

Lemma alloc_left_unmapped_inj:
  forall f m1 m2 lo hi m1' b1,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  f b1 = None ->
  mem_inj f m1' m2.

Definition inj_offset_aligned (delta: Z) (size: Z) : Prop :=
  forall chunk, size_chunk chunk <= size -> (align_chunk chunk | delta).

Lemma alloc_left_mapped_inj:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  inj_offset_aligned delta (hi-lo) ->
  (forall ofs k p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) ->
  f b1 = Some(b2, delta) ->
  mem_inj f m1' m2.

Lemma free_left_inj:
  forall f m1 m2 b lo hi m1',
  mem_inj f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  mem_inj f m1' m2.

Lemma free_right_inj:
  forall f m1 m2 b lo hi m2',
  mem_inj f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  mem_inj f m1 m2'.

Lemma drop_unmapped_inj:
  forall f m1 m2 b lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b lo hi p = Some m1' ->
  f b = None ->
  mem_inj f m1' m2.

Lemma drop_mapped_inj:
  forall f m1 m2 b1 b2 delta lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b1 lo hi p = Some m1' ->
  meminj_no_overlap f m1 ->
  f b1 = Some(b2, delta) ->
  exists m2',
      drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'
   /\ mem_inj f m1' m2'.

Lemma drop_outside_inj: forall f m1 m2 b lo hi p m2',
  mem_inj f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs' k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs' k p ->
    lo <= ofs' + delta < hi -> False) ->
  mem_inj f m1 m2'.

Record extends' (m1 m2: mem) : Prop :=
  mk_extends {
    mext_next: nextblock m1 = nextblock m2;
    mext_inj:  mem_inj inject_id m1 m2;
    mext_perm_inv: forall b ofs k p,
      perm m2 b ofs k p ->
      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
  }.

Definition extends := extends'.

Theorem extends_refl:
  forall m, extends m m.

Theorem load_extends:
  forall chunk m1 m2 b ofs v1,
  extends m1 m2 ->
  load chunk m1 b ofs = Some v1 ->
  exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.

Theorem loadv_extends:
  forall chunk m1 m2 addr1 addr2 v1,
  extends m1 m2 ->
  loadv chunk m1 addr1 = Some v1 ->
  Val.lessdef addr1 addr2 ->

Theorem loadbytes_extends:
  forall m1 m2 b ofs len bytes1,
  extends m1 m2 ->
  loadbytes m1 b ofs len = Some bytes1 ->
  exists bytes2, loadbytes m2 b ofs len = Some bytes2
              /\ list_forall2 memval_lessdef bytes1 bytes2.

Theorem store_within_extends:
  forall chunk m1 m2 b ofs v1 m1' v2,
  extends m1 m2 ->
  store chunk m1 b ofs v1 = Some m1' ->
  Val.lessdef v1 v2 ->

Theorem store_outside_extends:
  forall chunk m1 m2 b ofs v m2',
  extends m1 m2 ->
  store chunk m2 b ofs v = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) ->
  extends m1 m2'.

Theorem storev_extends:
  forall chunk m1 m2 addr1 v1 m1' addr2 v2,
  extends m1 m2 ->
  storev chunk m1 addr1 v1 = Some m1' ->
  Val.lessdef addr1 addr2 ->

Theorem storebytes_within_extends:
  forall m1 m2 b ofs bytes1 m1' bytes2,
  extends m1 m2 ->
  storebytes m1 b ofs bytes1 = Some m1' ->
  list_forall2 memval_lessdef bytes1 bytes2 ->
  exists m2',
     storebytes m2 b ofs bytes2 = Some m2'
  /\ extends m1' m2'.

Theorem storebytes_outside_extends:
  forall m1 m2 b ofs bytes2 m2',
  extends m1 m2 ->
  storebytes m2 b ofs bytes2 = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem alloc_extends:
  forall m1 m2 lo1 hi1 b m1' lo2 hi2,
  extends m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists m2',
     alloc m2 lo2 hi2 = (m2', b)
  /\ extends m1' m2'.

Theorem free_left_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  extends m1' m2.

Theorem free_right_extends:
  forall m1 m2 b lo hi m2',
  extends m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall ofs k p, perm m1 b ofs k p -> lo <= ofs < hi -> False) ->
  extends m1 m2'.

Theorem free_parallel_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  exists m2',
     free m2 b lo hi = Some m2'
  /\ extends m1' m2'.

Theorem valid_block_extends:
  forall m1 m2 b,
  extends m1 m2 ->
  (valid_block m1 b <-> valid_block m2 b).

Theorem perm_extends:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m1 b ofs k p -> perm m2 b ofs k p.

Theorem perm_extends_inv:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m2 b ofs k p -> perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty.

Theorem valid_access_extends:
  forall m1 m2 chunk b ofs p,
  extends m1 m2 -> valid_access m1 chunk b ofs p -> valid_access m2 chunk b ofs p.

Theorem valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 -> valid_pointer m1 b ofs = true -> valid_pointer m2 b ofs = true.

Theorem weak_valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 ->
  weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.

Record inject' (f: meminj) (m1 m2: mem) : Prop :=
  mk_inject {
    mi_inj:
      mem_inj f m1 m2;
    mi_freeblocks:
      forall b, ~(valid_block m1 b) -> f b = None;
    mi_mappedblocks:
      forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
    mi_no_overlap:
      meminj_no_overlap f m1;
    mi_representable:
      forall b b' delta ofs,
      f b = Some(b', delta) ->
      perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/ perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
      delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
    mi_perm_inv:
      forall b1 ofs b2 delta k p,
      f b1 = Some(b2, delta) ->
      perm m2 b2 (ofs + delta) k p ->
      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
  }.
Definition inject := inject'.

Local Hint Resolve mi_mappedblocks: mem.

Theorem valid_block_inject_1:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m1 b1.

Theorem valid_block_inject_2:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m2 b2.

Local Hint Resolve valid_block_inject_1 valid_block_inject_2: mem.

Theorem perm_inject:
  forall f m1 m2 b1 b2 delta ofs k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.

Theorem perm_inject_inv:
  forall f m1 m2 b1 ofs b2 delta k p,
  inject f m1 m2 ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p ->
  perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty.

Theorem range_perm_inject:
  forall f m1 m2 b1 b2 delta lo hi k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  range_perm m1 b1 lo hi k p -> range_perm m2 b2 (lo + delta) (hi + delta) k p.

Theorem valid_access_inject:
  forall f m1 m2 chunk b1 ofs b2 delta p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Theorem valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_pointer m1 b1 ofs = true ->
  valid_pointer m2 b2 (ofs + delta) = true.

Theorem weak_valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  weak_valid_pointer m1 b1 ofs = true ->
  weak_valid_pointer m2 b2 (ofs + delta) = true.

Lemma address_inject:
  forall f m1 m2 b1 ofs1 b2 delta p,
  inject f m1 m2 ->
  perm m1 b1 (Ptrofs.unsigned ofs1) Cur p ->

Lemma address_inject':
  forall f m1 m2 chunk b1 ofs1 b2 delta,
  inject f m1 m2 ->
  valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty ->

Theorem weak_valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem weak_valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem inject_no_overlap:
  forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
  inject f m1 m2 ->
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m1 b1 ofs1 Max Nonempty ->
  perm m1 b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Theorem different_pointers_inject:
  forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  inject f m m' ->
  b1 <> b2 ->
  valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->

Theorem disjoint_or_equal_inject:
  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
  inject f m m' ->
  f b1 = Some(b1', delta1) ->
  f b2 = Some(b2', delta2) ->
  range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty ->
  range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty ->
  sz > 0 ->
  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
             \/ ofs1 + delta1 + sz <= ofs2 + delta2
             \/ ofs2 + delta2 + sz <= ofs1 + delta1.

Theorem aligned_area_inject:
  forall f m m' b ofs al sz b' delta,
  inject f m m' ->
  al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz > 0 ->
  (al | sz) ->
  range_perm m b ofs (ofs + sz) Cur Nonempty ->
  (al | ofs) ->
  f b = Some(b', delta) ->
  (al | ofs + delta).

Theorem load_inject:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  inject f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Theorem loadv_inject:
  forall f m1 m2 chunk a1 a2 v1,
  inject f m1 m2 ->
  loadv chunk m1 a1 = Some v1 ->
  Val.inject f a1 a2 ->

Theorem loadbytes_inject:
  forall f m1 m2 b1 ofs len b2 delta bytes1,
  inject f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Theorem store_mapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Theorem store_unmapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem store_outside_inject:
  forall f m1 m2 chunk b ofs v m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  inject f m1 m2'.

Theorem storev_mapped_inject:
  forall f chunk m1 a1 v1 n1 m2 a2 v2,
  inject f m1 m2 ->
  storev chunk m1 a1 v1 = Some n1 ->
  Val.inject f a1 a2 ->

Theorem storebytes_mapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ inject f n1 n2.

Theorem storebytes_unmapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem storebytes_outside_inject:
  forall f m1 m2 b ofs bytes2 m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem storebytes_empty_inject:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  inject f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  inject f m1' m2'.

Theorem alloc_right_inject:
  forall f m1 m2 lo hi b2 m2',
  inject f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  inject f m1 m2'.

Theorem alloc_left_unmapped_inject:
  forall f m1 m2 lo hi m1' b1,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  exists f',
     inject f' m1' m2
  /\ inject_incr f f'
  /\ f' b1 = None
  /\ (forall b, b <> b1 -> f' b = f b).

Theorem alloc_left_mapped_inject:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  0 <= delta <= Ptrofs.max_unsigned ->

Theorem alloc_parallel_inject:
  forall f m1 m2 lo1 hi1 m1' b1 lo2 hi2,
  inject f m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b1) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists f', exists m2', exists b2,
  alloc m2 lo2 hi2 = (m2', b2)
  /\ inject f' m1' m2'
  /\ inject_incr f f'
  /\ f' b1 = Some(b2, 0)
  /\ (forall b, b <> b1 -> f' b = f b).

Lemma free_left_inject:
  forall f m1 m2 b lo hi m1',
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  inject f m1' m2.

Lemma free_list_left_inject:
  forall f m2 l m1 m1',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  inject f m1' m2.

Lemma free_right_inject:
  forall f m1 m2 b lo hi m2',
  inject f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) -> perm m1 b1 ofs k p ->
    lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma perm_free_list:
  forall l m m' b ofs k p,
  free_list m l = Some m' ->
  perm m' b ofs k p ->
  perm m b ofs k p /\
  (forall lo hi, In (b, lo, hi) l -> lo <= ofs < hi -> False).

Theorem free_inject:
  forall f m1 l m1' m2 b lo hi m2',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) ->
    perm m1 b1 ofs k p -> lo <= ofs + delta < hi ->
    exists lo1, exists hi1, In (b1, lo1, hi1) l /\ lo1 <= ofs < hi1) ->
  inject f m1' m2'.

Theorem free_parallel_inject:
  forall f m1 m2 b lo hi m1' b' delta,
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  f b = Some(b', delta) ->
  exists m2',
     free m2 b' (lo + delta) (hi + delta) = Some m2'
  /\ inject f m1' m2'.

Lemma drop_outside_inject: forall f m1 m2 b lo hi p m2',
  inject f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma mem_inj_compose:
  forall f f' m1 m2 m3,
  mem_inj f m1 m2 -> mem_inj f' m2 m3 -> mem_inj (compose_meminj f f') m1 m3.

Theorem inject_compose:
  forall f f' m1 m2 m3,
  inject f m1 m2 -> inject f' m2 m3 ->
  inject (compose_meminj f f') m1 m3.

Lemma val_lessdef_inject_compose:
  forall f v1 v2 v3,
  Val.lessdef v1 v2 -> Val.inject f v2 v3 -> Val.inject f v1 v3.

Lemma val_inject_lessdef_compose:
  forall f v1 v2 v3,
  Val.inject f v1 v2 -> Val.lessdef v2 v3 -> Val.inject f v1 v3.

Lemma extends_inject_compose:
  forall f m1 m2 m3,
  extends m1 m2 -> inject f m2 m3 -> inject f m1 m3.

Lemma inject_extends_compose:
  forall f m1 m2 m3,
  inject f m1 m2 -> extends m2 m3 -> inject f m1 m3.

Lemma extends_extends_compose:
  forall m1 m2 m3,
  extends m1 m2 -> extends m2 m3 -> extends m1 m3.

Definition flat_inj (thr: block) : meminj :=
  fun (b: block) => if plt b thr then Some(b, 0) else None.

Definition inject_neutral (thr: block) (m: mem) :=
  mem_inj (flat_inj thr) m m.

Remark flat_inj_no_overlap:
  forall thr m, meminj_no_overlap (flat_inj thr) m.

Theorem neutral_inject:
  forall m, inject_neutral (nextblock m) m -> inject (flat_inj (nextblock m)) m m.

Theorem empty_inject_neutral:
  forall thr, inject_neutral thr empty.

Theorem alloc_inject_neutral:
  forall thr m lo hi b m',
  alloc m lo hi = (m', b) ->
  inject_neutral thr m ->
  Plt (nextblock m) thr ->
  inject_neutral thr m'.

Theorem store_inject_neutral:
  forall chunk m b ofs v m' thr,
  store chunk m b ofs v = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  Val.inject (flat_inj thr) v v ->

Theorem drop_inject_neutral:
  forall m b lo hi p m' thr,
  drop_perm m b lo hi p = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  inject_neutral thr m'.

Section UNCHANGED_ON.

Variable P: block -> Z -> Prop.

Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
  unchanged_on_nextblock:
    Ple (nextblock m_before) (nextblock m_after);
  unchanged_on_perm:
    forall b ofs k p,
    P b ofs -> valid_block m_before b ->
    (perm m_before b ofs k p <-> perm m_after b ofs k p);
  unchanged_on_contents:
    forall b ofs,
    P b ofs -> perm m_before b ofs Cur Readable ->
    ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
    ZMap.get ofs (PMap.get b m_before.(mem_contents))
}.

Lemma unchanged_on_refl:
  forall m, unchanged_on m m.

Lemma valid_block_unchanged_on:
  forall m m' b,
  unchanged_on m m' -> valid_block m b -> valid_block m' b.

Lemma perm_unchanged_on:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs ->
  perm m b ofs k p -> perm m' b ofs k p.

Lemma perm_unchanged_on_2:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs -> valid_block m b ->
  perm m' b ofs k p -> perm m b ofs k p.

Lemma unchanged_on_trans:
  forall m1 m2 m3, unchanged_on m1 m2 -> unchanged_on m2 m3 -> unchanged_on m1 m3.

Lemma loadbytes_unchanged_on_1:
  forall m m' b ofs n,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m' b ofs n = loadbytes m b ofs n.

Lemma loadbytes_unchanged_on:
  forall m m' b ofs n bytes,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m b ofs n = Some bytes ->
  loadbytes m' b ofs n = Some bytes.

Lemma load_unchanged_on_1:
  forall m m' chunk b ofs,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m' b ofs = load chunk m b ofs.

Lemma load_unchanged_on:
  forall m m' chunk b ofs v,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m b ofs = Some v ->
  load chunk m' b ofs = Some v.

Lemma store_unchanged_on:
  forall chunk m b ofs v m',
  store chunk m b ofs v = Some m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> ~ P b i) ->
  unchanged_on m m'.

Lemma storebytes_unchanged_on:
  forall m b ofs bytes m',
  storebytes m b ofs bytes = Some m' ->
  (forall i, ofs <= i < ofs + Z.of_nat (length bytes) -> ~ P b i) ->

Lemma alloc_unchanged_on:
  forall m lo hi m' b,
  alloc m lo hi = (m', b) ->
  unchanged_on m m'.

Lemma free_unchanged_on:
  forall m b lo hi m',
  free m b lo hi = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

Lemma drop_perm_unchanged_on:
  forall m b lo hi p m',
  drop_perm m b lo hi p = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

End UNCHANGED_ON.

Lemma unchanged_on_implies:
  forall (P Q: block -> Z -> Prop) m m',
  unchanged_on P m m' ->
  (forall b ofs, Q b ofs -> valid_block m b -> P b ofs) ->
  unchanged_on Q m m'.

End Mem.

Notation mem := Mem.mem.

Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.

Hint Resolve
  Mem.valid_not_valid_diff
  Mem.perm_implies
  Mem.perm_cur
  Mem.perm_max
  Mem.perm_valid_block
  Mem.range_perm_implies
  Mem.range_perm_cur
  Mem.range_perm_max
  Mem.valid_access_implies
  Mem.valid_access_valid_block
  Mem.valid_access_perm
  Mem.valid_access_load
  Mem.load_valid_access
  Mem.loadbytes_range_perm
  Mem.valid_access_store
  Mem.perm_store_1
  Mem.perm_store_2
  Mem.nextblock_store
  Mem.store_valid_block_1
  Mem.store_valid_block_2
  Mem.store_valid_access_1
  Mem.store_valid_access_2
  Mem.store_valid_access_3
  Mem.storebytes_range_perm
  Mem.perm_storebytes_1
  Mem.perm_storebytes_2
  Mem.storebytes_valid_access_1
  Mem.storebytes_valid_access_2
  Mem.nextblock_storebytes
  Mem.storebytes_valid_block_1
  Mem.storebytes_valid_block_2
  Mem.nextblock_alloc
  Mem.alloc_result
  Mem.valid_block_alloc
  Mem.fresh_block_alloc
  Mem.valid_new_block
  Mem.perm_alloc_1
  Mem.perm_alloc_2
  Mem.perm_alloc_3
  Mem.perm_alloc_4
  Mem.perm_alloc_inv
  Mem.valid_access_alloc_other
  Mem.valid_access_alloc_same
  Mem.valid_access_alloc_inv
  Mem.range_perm_free
  Mem.free_range_perm
  Mem.nextblock_free
  Mem.valid_block_free_1
  Mem.valid_block_free_2
  Mem.perm_free_1
  Mem.perm_free_2
  Mem.perm_free_3
  Mem.valid_access_free_1
  Mem.valid_access_free_2
  Mem.valid_access_free_inv_1
  Mem.valid_access_free_inv_2
  Mem.unchanged_on_refl
: mem. *)

Set Bullet Behavior "Strict Subproofs".



Definition map_leq {A B} (m1: PTree.t A)(m2: PTree.t B): Prop :=

  forall p, m1 ! p -> m2 ! p.



Lemma map_leq_apply:

  forall {A B} (m1: PTree.t A)(m2: PTree.t B) p f1,

    map_leq m1 m2 ->

    m1 ! p = Some f1 -> exists f2, m2 ! p = Some f2.

Proof.

  move => A B m1 m2 p f1.

  rewrite /map_leq => /(_ p) Mle AA.

  rewrite AA in Mle. specialize (Mle ltac:(auto)).

  destruct (m2 ! p) as [f2|]; try solve[inversion Mle].

  exists f2; auto.

Qed.



Lemma treemap_sub_map: forall {A B} (f: positive -> B -> A) m2,

    map_leq (PTree.map f m2) m2.

Proof.

  move => A B f m2 p.

  rewrite PTree.gmap.

  destruct (m2 ! p) eqn:m2p; auto; intros HH; inversion HH.

Qed.



Definition map_empty_def {A} (m1: PMap.t (Z -> option A)):=

  m1.1 = fun _ => None.



Definition fun_leq' {A B} (f1: Z -> option A) (f2: Z -> option B): Prop :=

  forall p, f1 p -> f2 p.



Definition fun_leq {A B} (o1: option (Z -> option A)) (o2: option (Z -> option B)): Prop :=

  match o1, o2 with

  | Some f1, Some f2 => fun_leq' f1 f2

  | None, None => True

  | _, _ => False

  end.



Definition option_eq {A B} (a:option A) (b: option B): Prop :=

  match a, b with

  | Some _ , Some _ => True

  | None, None => True

  | _, _ => False

  end.



Definition bounded_nat_func_aux {A} (f: nat -> option A) hi: Prop :=

  (forall p, (p >= hi )%nat -> f p = None).



Definition bounded_nat_func' {A} (f: nat -> option A) hi: Prop :=

  (forall p, (p > hi )%nat -> f p = None).



Definition bounded_func' {A} (f: Z -> option A) hi lo: Prop :=

  (forall p, (p > hi )%Z -> f p = None) /\

  (forall p, (p < lo)%Z -> f p = None).



Definition bounded_func_op {A} (f: option (Z -> option A)) hi lo: Prop :=

  match f with

  | Some f' => bounded_func' f' hi lo

  | None => True

  end.



Definition bounded_func {A} (f: Z -> option A): Prop :=

  exists hi lo,

  bounded_func' f hi lo.



Definition bounded_map {A} (m: PTree.t (Z -> option A)):=

  forall p f, m ! p = Some f -> bounded_func f.



Fixpoint strong_tree_leq {A B}

         (t1: PTree.t A) (t2: PTree.t B)

         (leq: option A -> option B -> Prop):=

  match t1, t2 with

  | PTree.Leaf, PTree.Leaf => True

  | PTree.Node l1 o1 r1, PTree.Node l2 o2 r2 =>

    leq o1 o2 /\

    strong_tree_leq l1 l2 leq /\

    strong_tree_leq r1 r2 leq

  | _, _ => False

  end.



Definition same_shape {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=

  strong_tree_leq m1 m2 option_eq.



Definition sub_map' {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=

  forall p f1, m1 ! p = Some f1 ->

          exists f2, m2 ! p = Some f2 /\ fun_leq' f1 f2.



Definition sub_map {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=

  strong_tree_leq m1 m2 fun_leq.



Lemma sub_map_and_shape:

  forall { A B} m1 m2,

  @same_shape A B m1 m2 ->

  sub_map' m1 m2 ->

  sub_map m1 m2.

Proof.

  induction m1.

  - intros.

    destruct m2; inversion H.

    auto.

  - intros.

    rewrite /sub_map /=.

    destruct m2; try inversion H.

    split; [|split].

    + destruct o as [o|].

      2: destruct o0; inversion H1; auto.

      specialize (H0 1%positive o ltac:(auto)).

      destruct o0; try solve [inversion H1].

      destruct H0 as [f [ISo LEQ]].

      inversion ISo.

      auto.

    + destruct H as [AA [BB CC]].

      eapply IHm1_1; eauto.

      move => b f HH.

      move: H0 => /(_  (b~0)%positive f HH) //.

    + destruct H as [AA [BB CC]].

      eapply IHm1_2; eauto.

      move => b f HH.

      move: H0 => /(_  (b~1)%positive f HH) //.

Qed.



Definition nat_to_perm (i:nat) :=

  (match i with

  | 0 => Some None

  | 1 => Some (Some Nonempty)

  | 2 => Some (Some Readable)

  | 3 => Some (Some Writable)

  | 4 => Some (Some Freeable)

  | _ => None

  end)%nat.



Definition perm_to_nat (p: option (option permission)) :=

  match p with

  | Some (None) => 0

  | Some (Some Nonempty) => 1

  | Some (Some Readable) => 2

  | Some (Some Writable) => 3

  | Some (Some Freeable) => 4

  | None => 5

  end.



Definition nat_to_perm_simpl (i:nat) :=

  (match i with

  | 0 => None

  | 1 => Some Nonempty

  | 2 => Some Readable

  | 3 => Some Writable

  | 4 => Some Freeable

  | _ => None

  end)%nat.



Definition perm_to_nat_simpl (p: option permission) :=

  match p with

  | None => 0

  | Some Nonempty => 1

  | Some Readable => 2

  | Some Writable => 3

  | Some Freeable => 4

  end.

Lemma perm_to_nat_bound:

  forall p,

    perm_to_nat p < 6.

Proof.

  intros p.

  destruct p as [p|];

    try destruct p as [p|]; try destruct p; compute; auto.

Qed.



Lemma perm_to_nat_bound_simpl:

  forall p,

    perm_to_nat_simpl p < 5.

Proof.

  intros p.

  destruct p as [p|];

    try destruct p; compute; auto.

Qed.



Lemma nat_to_perm_perm_to_nat:

  forall p,

    nat_to_perm (perm_to_nat p) = p.

Proof.

  intros p.

  destruct p as [p|];

    try destruct p as [p|];

    try destruct p;

    reflexivity.

Qed.



Lemma nat_to_perm_perm_to_nat_simpl:

  forall p,

    nat_to_perm_simpl (perm_to_nat_simpl p) = p.

Proof.

  intros p.

  destruct p as [p|];

    try destruct p;

    reflexivity.

Qed.



Lemma finite_bounded_nat_aux_func:

  forall hi ,

    konig.finite

      ( fun f:nat -> option (option permission) => bounded_nat_func_aux f hi).

Proof.



   intros hi.

   pose (K:= perm_to_nat).

   induction hi.

   - exists 1%nat.

     exists (fun x _ => None).

     intros.

     exists 0%nat.

     split; auto.



     extensionality b.

     symmetry.

     apply H.

     apply /leP. omega.



   - destruct IHhi as [N [FN H]].

     exists (6*N)%nat.

     exists (fun x i => if (Nat.eq_dec i hi) then

                       nat_to_perm (Nat.modulo x 6)

                else FN (Nat.div x 6) i).

     move=> f HH.

     specialize (H (fun n => if (Nat.eq_dec n hi) then

                            None

                          else f n) ).

     destruct H as [i [ineq f_spec]].

     + intros pp pphi.

       destruct (Nat.eq_dec pp hi).

       * auto.

       * simpl; eapply HH.

         move: pphi=> /leP pphi.

         apply /ltP.

         omega.



     + exists ((6 * i) + (perm_to_nat (f hi))).

       split.

       * replace (6 * N) with

         (6 * (N - 1) + 6 ).

         { eapply (NPeano.Nat.lt_le_trans _ (6 * i  + 6)).

           - apply /leP.

             rewrite ltn_add2l.

             destruct (f hi) as [p|];

               [destruct p; try destruct p|]; simpl; apply /leP; try omega.

           - apply /leP.

             rewrite leq_add2r.

             rewrite leq_pmul2l.

             + apply / leP. clear -ineq.

               replace N with (S (N - 1)) in ineq.

               apply /leP.

               by rewrite - ltnS; apply /leP.

               rewrite -addn1.

               apply subnK.

               destruct N; apply /ltP; try omega.

             + compute; auto.

         }

         rewrite - mulnSr.

         replace (N -1).+1 with N; auto.

         rewrite -addn1.

         symmetry; apply subnK.

         destruct N; apply /ltP; try omega.

       * { extensionality i0.

           destruct (Nat.eq_dec i0 hi).

           - subst.

             rewrite addnC.

             rewrite mulnC.

             rewrite NPeano.Nat.mod_add; try omega.

             rewrite NPeano.Nat.mod_small;

               try (apply /ltP; eapply perm_to_nat_bound).

             rewrite nat_to_perm_perm_to_nat.

             reflexivity.



           - replace ((6 * i + perm_to_nat (f hi)) / 6) with i.

             + rewrite f_spec.

               simpl.

               destruct (Nat.eq_dec i0 hi);

                 try solve [exfalso; apply n; auto].

               reflexivity.

             + eapply NPeano.Nat.div_unique;

               try (apply /ltP; eapply perm_to_nat_bound).

               reflexivity.

         }

Qed.



Lemma finite_bounded_nat_aux_func_simpl:

  forall hi ,

    konig.finite

      ( fun f:nat -> option permission => bounded_nat_func_aux f hi).

Proof.



   intros hi.

   pose (K:= perm_to_nat_simpl).

   induction hi.

   - exists 1%nat.

     exists (fun x _ => None).

     intros.

     exists 0%nat.

     split; auto.



     extensionality b.

     symmetry.

     apply H.

     apply /leP. omega.



   - destruct IHhi as [N [FN H]].

     exists (5*N)%nat.

     exists (fun x i => if (Nat.eq_dec i hi) then

                       nat_to_perm_simpl (Nat.modulo x 5)

                else FN (Nat.div x 5) i).

     move=> f HH.

     specialize (H (fun n => if (Nat.eq_dec n hi) then

                            None

                          else f n) ).

     destruct H as [i [ineq f_spec]].

     + intros pp pphi.

       destruct (Nat.eq_dec pp hi).

       * auto.

       * simpl; eapply HH.

         move: pphi=> /leP pphi.

         apply /ltP.

         omega.



     + exists ((5 * i) + (perm_to_nat_simpl (f hi))).

       split.

       * replace (5 * N) with

         (5 * (N - 1) + 5 ).

         { eapply (NPeano.Nat.lt_le_trans _ (5 * i  + 5)).

           - apply /leP.

             rewrite ltn_add2l.

             destruct (f hi) as [p|]; [destruct p|]; simpl; apply /leP; try omega.

           - apply /leP.

             rewrite leq_add2r.

             rewrite leq_pmul2l.

             + apply / leP. clear -ineq.

               replace N with (S (N - 1)) in ineq.

               apply /leP.

               by rewrite - ltnS; apply /leP.

               rewrite -addn1.

               apply subnK.

               destruct N; apply /ltP; try omega.

             + compute; auto.

         }

         rewrite - mulnSr.

         replace (N -1).+1 with N; auto.

         rewrite -addn1.

         symmetry; apply subnK.

         destruct N; apply /ltP; try omega.

       * { extensionality i0.

           destruct (Nat.eq_dec i0 hi).

           - subst.

             rewrite addnC.

             rewrite mulnC.

             rewrite NPeano.Nat.mod_add; try omega.

             rewrite NPeano.Nat.mod_small;

               try (apply /ltP; eapply perm_to_nat_bound_simpl).

             rewrite nat_to_perm_perm_to_nat_simpl.

             reflexivity.



           - replace ((5 * i + perm_to_nat_simpl (f hi)) / 5) with i.

             + rewrite f_spec.

               simpl.

               destruct (Nat.eq_dec i0 hi);

                 try solve [exfalso; apply n; auto].

               reflexivity.

             + eapply NPeano.Nat.div_unique;

               try (apply /ltP; eapply perm_to_nat_bound_simpl).

               reflexivity.

         }

Qed.



Lemma finite_bounded_nat_func:

  forall hi ,

    konig.finite

      ( fun f:nat -> option (option permission) => bounded_nat_func' f hi).

Proof.

  intros.

  destruct (finite_bounded_nat_aux_func (S hi)) as [x [f HH]].

  exists x, f.

  move=> x0 BND.

  cut (bounded_nat_func_aux x0 hi.+1).

  2:{ intros b ineq; eapply BND; auto. }

  move=> /HH [] i [] A B.

  exists i; split; eauto.

Qed.



Lemma finite_bounded_nat_func_simpl:

  forall hi ,

    konig.finite

      ( fun f:nat -> option permission => bounded_nat_func' f hi).

Proof.

  intros.

  destruct (finite_bounded_nat_aux_func_simpl (S hi)) as [x [f HH]].

  exists x, f.

  move=> x0 BND.

  cut (bounded_nat_func_aux x0 hi.+1).

  2:{ intros b ineq; eapply BND; auto. }

  move=> /HH [] i [] A B.

  exists i; split; eauto.

Qed.



Lemma finite_bounded_func:

  forall hi lo,

    konig.finite

      ( fun f:Z -> option (option permission) => bounded_func' f hi lo).

Proof.

  intros hi lo.

  destruct (Coqlib.zlt hi lo).

  - exists 1%N.

    exists (fun _ _ => None).

    intros.

    exists 0%nat; split; auto.

    extensionality b.

    destruct H as[H1 H2].

    symmetry.

    destruct (Coqlib.zle b hi).

    + eapply H2.

      eapply Z.le_lt_trans; eauto.

    + eapply H1; assumption.

  - assert (0 <= hi - lo)%Z by omega.

    pose (n:= Z.to_nat (hi - lo)).

    destruct (finite_bounded_nat_func n) as [N [FN HN]].

    exists N.

    exists (fun n z => (if (Z_lt_ge_dec z lo)

                then None

                else FN n (Z.to_nat (z-lo)))).

    intros f [BOUND1 BOUND2].

    pose (f':= fun n => f (Z.of_nat n + lo)%Z).

    assert (bounded_nat_func' f' n).

    { intros b ineq.

      unfold f'.

      eapply BOUND1.

      unfold n in ineq.

      cut (Z.of_nat b > hi - lo)%Z.

      omega.

      move: ineq => /ltP /inj_lt /Z.gt_lt_iff.

      rewrite Z2Nat.id => //.

    }

    apply HN in H0.

    destruct H0 as [i [ineq FN_spec]].

    exists i; split; auto.

    extensionality z.

    rewrite FN_spec.

    unfold f'.

    destruct (Z_lt_ge_dec z lo).

    + simpl.

      symmetry.

        by apply BOUND2.

    + simpl.

      rewrite Z2Nat.id.

      * f_equal; omega.

      * omega.

Qed.



Lemma finite_bounded_func_simpl:

  forall hi lo,

    konig.finite

      ( fun f:Z -> option permission => bounded_func' f hi lo).

Proof.

  intros hi lo.

  destruct (Coqlib.zlt hi lo).

  - exists 1%N.

    exists (fun _ _ => None).

    intros.

    exists 0%nat; split; auto.

    extensionality b.

    destruct H as[H1 H2].

    symmetry.

    destruct (Coqlib.zle b hi).

    + eapply H2.

      eapply Z.le_lt_trans; eauto.

    + eapply H1; assumption.

  - assert (0 <= hi - lo)%Z by omega.

    pose (n:= Z.to_nat (hi - lo)).

    destruct (finite_bounded_nat_func_simpl n) as [N [FN HN]].

    exists N.

    exists (fun n z => (if (Z_lt_ge_dec z lo)

                then None

                else FN n (Z.to_nat (z-lo)))).

    intros f [BOUND1 BOUND2].

    pose (f':= fun n => f (Z.of_nat n + lo)%Z).

    assert (bounded_nat_func' f' n).

    { intros b ineq.

      unfold f'.

      eapply BOUND1.

      unfold n in ineq.

      cut (Z.of_nat b > hi - lo)%Z.

      omega.

      move: ineq => /ltP /inj_lt /Z.gt_lt_iff.

      rewrite Z2Nat.id => //.

    }

    apply HN in H0.

    destruct H0 as [i [ineq FN_spec]].

    exists i; split; auto.

    extensionality z.

    rewrite FN_spec.

    unfold f'.

    destruct (Z_lt_ge_dec z lo).

    + simpl.

      symmetry.

        by apply BOUND2.

    + simpl.

      rewrite Z2Nat.id.

      * f_equal; omega.

      * omega.

Qed.



Lemma finite_bounded_op_func_simpl:

  forall hi lo,

    konig.finite

      ( fun f: option (Z -> option permission) => bounded_func_op f hi lo).

Proof.

  move => hi lo.

  move: (finite_bounded_func_simpl hi lo) => [] N [] FN FN_spec.



  exists (S N).

  exists (fun n => if n == 0 then None

           else Some (FN (n -1)) ).

  move => f H.

  destruct f.

  - move: FN_spec => /(_ _ H) [] i [] ineqi speci.

    exists (S i); split.

    + omega.

    + rewrite - speci.

      simpl; repeat f_equal.

      rewrite - addn1 - addnBA=> //.

  - exists 0; split; auto.

    + omega.

Qed.



Lemma finite_bounded_op_func:

  forall hi lo,

    konig.finite

      ( fun f: option (Z -> option (option permission)) => bounded_func_op f hi lo).

Proof.

  move => hi lo.

  move: (finite_bounded_func hi lo) => [] N [] FN FN_spec.



  exists (S N).

  exists (fun n => if n == 0 then None

           else Some (FN (n -1)) ).

  move => f H.

  destruct f.

  - move: FN_spec => /(_ _ H) [] i [] ineqi speci.

    exists (S i); split.

    + omega.

    + rewrite - speci.

      simpl; repeat f_equal.

      rewrite - addn1 - addnBA=> //.

  - exists 0; split; auto.

    + omega.

Qed.



Lemma finite_sub_maps:

  forall m2,

    @bounded_map permission m2 ->

    konig.finite

      (fun m1 => @sub_map (option permission) permission m1 m2).

Proof.

  induction m2.

  - move => _.

    exists 1%nat.

    exists (fun _ => PTree.Leaf).

    intros .

    exists 0%nat.

    split; auto.

    destruct x; auto.

    unfold strong_tree_leq in H;

      simpl in H.

    destruct o; inversion H.

  - move => H.

    assert (HH1:

              forall (p : positive) (f : Z -> option permission),

                m2_1 ! p = Some f ->

                exists hi lo : Z,

                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\

                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).

    { clear - H.

      move=> p f Hget.

      move : H => /(_ (p~0)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.

      exists hi, lo; assumption.

    }

    move: IHm2_1=> /(_ HH1) [] N1 [] F1 spec_F1.

    assert (HH2:

              forall (p : positive) (f : Z -> option permission),

                m2_2 ! p = Some f ->

                exists hi lo : Z,

                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\

                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).

    { clear - H.

      move=> p f Hget.

      move : H => /(_ (p~1)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.

      exists hi, lo; assumption.

    }

    move: IHm2_2=> /(_ HH2) [] N2 [] F2 spec_F2.

    destruct o as [f1|].

    + move : H => /(_ 1%positive f1 ltac:(reflexivity)) [] hi [] lo BNDD.

      move : (finite_bounded_op_func hi lo) => [] N [] F F_spec.

      exists (S( N * N1 * N2)).

      exists (fun n => if n == 0

               then PTree.Leaf

               else

                 PTree.Node

                   (F1 ( (n-1) mod N1))

                   (F ((n-1) / (N1 * N2)))

                   (F2 (((n-1) / N1 ) mod N2))).

      intros x spec.

      destruct x.

      * exists 0%nat; split; auto.

        omega.

      * move: spec .

        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.

        assert (bounded_func_op o hi lo).

        { Lemma fun_le_bounded_func_op:

            forall {A} o f hi lo,

              @bounded_func' A f hi lo ->

              fun_leq o (Some f) ->

              @bounded_func_op (option A) o hi lo.

          Proof.

            intros.

            destruct o; [|constructor].

            simpl.

            simpl in H0.

            split; intros p.

            - intros HH. apply H in HH.

              unfold fun_leq' in H0.

              specialize (H0 p).

              destruct (o p); try solve [auto].

              specialize (H0 ltac:(auto)).

              rewrite HH in H0; inversion H0.

            - intros HH. apply H in HH.

              unfold fun_leq' in H0.

              specialize (H0 p).

              destruct (o p); try solve [auto].

              specialize (H0 ltac:(auto)).

              rewrite HH in H0; inversion H0.

          Qed.

          eapply fun_le_bounded_func_op ; eauto.

          }

        move: F_spec => /(_ _ H) []i [] ineq fi.

        move : spec_F1 => /(_ _ tree1) [] i1 [] ineq1 fi1.

        move : spec_F2 => /(_ _ tree2) [] i2 [] ineq2 fi2.

        exists (S(i1 + (i2 * N1) + (i * N1 * N2))); split.

        { apply lt_n_S.

          replace (N * N1 * N2) with

          (N1 + N1 * (N2 * N -1)).

          - eapply (NPeano.Nat.lt_le_trans).

            + instantiate (1:= (N1 + i2 * N1 + i * N1 * N2)).

              apply /ltP.

              rewrite ltn_add2r;

                rewrite ltn_add2r;

                apply /ltP; auto.

            + apply /leP.

              rewrite -addnA.

              rewrite leq_add2l.

              apply /leP.

              replace (i * N1 * N2) with

              ((i * N2) * N1).

              *

                rewrite -mulnDl.

                rewrite mulnC.

                apply /leP.

                rewrite leq_pmul2l; try (apply /ltP; omega).

                apply /leP.

                eapply lt_n_Sm_le.

                rewrite - addn1.

                rewrite subnK.

                2:

                  rewrite muln_gt0;

                  apply /andP; split;

                  try (apply /ltP; omega).

                eapply (NPeano.Nat.lt_le_trans).

                -- instantiate (1:= N2 + i * N2).

                   apply /ltP.

                   rewrite ltn_add2r.

                   apply /leP; auto.

                -- replace (N2 + i * N2) with

                   (N2 * (1 + i)).

                   apply /leP.

                   rewrite leq_pmul2l.

                   rewrite add1n.

                   apply /ltP; auto.

                   apply /ltP; omega.

                   rewrite mulnDr.

                   rewrite mulnC.

                   f_equal.

                   compute; auto.

                   rewrite mulnC; auto.

              * do 2 rewrite - mulnA.

                f_equal. rewrite mulnC; auto.

          - replace (N1 + N1 * (N2 * N - 1))

            with (N1 * 1 + N1 * (N2 * N - 1)).

            + rewrite -mulnDr.

              rewrite addnC.

              rewrite subnK.



              2:

                rewrite muln_gt0;

                apply /andP; split;

                try (apply /ltP; omega).

              rewrite -mulnA.

              rewrite mulnA.

              rewrite mulnC; auto.

            + f_equal.

              rewrite mulnC.

              compute; auto. }

      -- simpl; f_equal.

         ++ rewrite - fi1.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2) with

            (i1 + (i2  + i *  N2) * N1).

            2:

            rewrite mulnDl addnA; f_equal;

            do 2 rewrite -mulnA; f_equal; rewrite mulnC; auto.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N1; omega.

         ++ rewrite - fi.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            assert (i1 + i2 * N1 + i * N1 * N2 =

                    ((N1 * N2) * i) + (i1 + i2 * N1)).

            { rewrite addnC. f_equal.

              rewrite - mulnA mulnC; auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            eapply (NPeano.Nat.lt_le_trans).

            ** instantiate (1:= N1 + i2 * N1).

               apply /ltP; rewrite ltn_add2r.

               apply /ltP; auto.

            ** replace (N1 + i2 * N1) with ( (1 + i2) * N1).

               rewrite add1n.

               rewrite mulnC.

               apply /leP; rewrite leq_pmul2l.

               apply /ltP; auto.

               destruct N1; ssromega.

               rewrite mulnDl; f_equal.

               ssromega.



         ++ rewrite - fi2.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            assert (i1 + i2 * N1 + i * N1 * N2 =

                    (N1 * (i2 + i * N2)) + i1).

            { rewrite -addnA.

              replace (i * N1 * N2) with

              (i  * N2 * N1).

              rewrite - mulnDl.

              rewrite mulnC addnC; auto.

              do 2 rewrite -mulnA; f_equal.

              rewrite mulnC. auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            rewrite - H0.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N2; omega.

    + exists (S( N1 * N2)).

      exists (fun n => if n == 0

               then PTree.Leaf

               else

                 PTree.Node

                   (F1 ( (n-1) mod N1))

                   (None )

                   (F2 (((n-1) / N1 ) mod N2))).

      intros x spec.

      destruct x.

      * exists 0%nat; split; auto.

        omega.

      * move: spec .

        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.

        move : spec_F1 => /(_ _ tree1) [] i1 [] ineq1 fi1.

        move : spec_F2 => /(_ _ tree2) [] i2 [] ineq2 fi2.

        exists (S(i1 + (i2 * N1))); split.

        { apply lt_n_S.

          replace (N1 * N2) with

          (N1 + N1 * (N2 -1)).

          - eapply (NPeano.Nat.lt_le_trans).

            + instantiate (1:= (N1 + i2 * N1)).

              apply /ltP.

              rewrite ltn_add2r;

                apply /ltP; auto.

            + apply /leP.

              rewrite leq_add2l.

              apply /leP.

              rewrite mulnC.

              apply /leP.

              rewrite leq_pmul2l; try (apply /ltP; omega).

              apply /leP.

              eapply lt_n_Sm_le.

              rewrite - addn1.

              rewrite subnK; auto.

              destruct N2; ssromega.



          - replace (N1 + N1 * (N2 - 1))

            with (N1 * 1 + N1 * (N2 - 1)).

            + rewrite -mulnDr.

              rewrite addnC.

              rewrite subnK.

              2: ssromega.

              rewrite mulnC; auto.

            + f_equal.

              rewrite mulnC.

              compute; auto. }

      -- simpl; f_equal.

         ++ rewrite - fi1.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + (1 - 1)) with

            (i1 + i2 * N1) by ssromega.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N1; omega.

         ++ destruct o; auto; inversion FUN_lq.

         ++ rewrite - fi2.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + (1 - 1)) with

            (i1 + i2 * N1 ) by ssromega.

            assert (i1 + i2 * N1 =

                    (N1 * (i2) + i1)).

            { rewrite mulnC addnC; auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            rewrite - H0.

            apply NPeano.Nat.mod_small; auto.

Qed.



Lemma finite_sub_maps_simpl:

  forall m2,

    @bounded_map permission m2 ->

    konig.finite

      (fun m1 => @sub_map permission permission m1 m2).

Proof.



  induction m2.

  - move => _.

    exists 1%nat.

    exists (fun _ => PTree.Leaf).

    intros .

    exists 0%nat.

    split; auto.

    destruct x; auto.

    unfold strong_tree_leq in H;

      simpl in H.

    destruct o; inversion H.

  - move => H.

    assert (HH1:

              forall (p : positive) (f : Z -> option permission),

                m2_1 ! p = Some f ->

                exists hi lo : Z,

                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\

                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).

    { clear - H.

      move=> p f Hget.

      move : H => /(_ (p~0)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.

      exists hi, lo; assumption.

    }

    move: IHm2_1=> /(_ HH1) [] N1 [] F1 spec_F1.

    assert (HH2:

              forall (p : positive) (f : Z -> option permission),

                m2_2 ! p = Some f ->

                exists hi lo : Z,

                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\

                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).

    { clear - H.

      move=> p f Hget.

      move : H => /(_ (p~1)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.

      exists hi, lo; assumption.

    }

    move: IHm2_2=> /(_ HH2) [] N2 [] F2 spec_F2.

    destruct o as [f1|].

    + move : H => /(_ 1%positive f1 ltac:(reflexivity)) [] hi [] lo BNDD.

      move : (finite_bounded_op_func_simpl hi lo) => [] N [] F F_spec.

      exists (S( N * N1 * N2)).

      exists (fun n => if n == 0

               then PTree.Leaf

               else

                 PTree.Node

                   (F1 ( (n-1) mod N1))

                   (F ((n-1) / (N1 * N2)))

                   (F2 (((n-1) / N1 ) mod N2))).

      intros x spec.

      destruct x.

      * exists 0%nat; split; auto.

        omega.

      * move: spec .

        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.

        assert (bounded_func_op o hi lo).

        { Lemma fun_le_bounded_func_op_simpl:

            forall {A} o f hi lo,

              @bounded_func' A f hi lo ->

              fun_leq o (Some f) ->

              @bounded_func_op A o hi lo.

          Proof.

            intros.

            destruct o; [|constructor].

            simpl.

            simpl in H0.

            split; intros p.

            - intros HH. apply H in HH.

              unfold fun_leq' in H0.

              specialize (H0 p).

              destruct (o p); try solve [auto].

              specialize (H0 ltac:(auto)).

              rewrite HH in H0; inversion H0.

            - intros HH. apply H in HH.

              unfold fun_leq' in H0.

              specialize (H0 p).

              destruct (o p); try solve [auto].

              specialize (H0 ltac:(auto)).

              rewrite HH in H0; inversion H0.

          Qed.

          eapply fun_le_bounded_func_op_simpl ; eauto.

          }

        move: F_spec => /(_ _ H) []i [] ineq fi.

        move : spec_F1 => /(_ _ tree1) [] i1 [] ineq1 fi1.

        move : spec_F2 => /(_ _ tree2) [] i2 [] ineq2 fi2.

        exists (S(i1 + (i2 * N1) + (i * N1 * N2))); split.

        { apply lt_n_S.

          replace (N * N1 * N2) with

          (N1 + N1 * (N2 * N -1)).

          - eapply (NPeano.Nat.lt_le_trans).

            + instantiate (1:= (N1 + i2 * N1 + i * N1 * N2)).

              apply /ltP.

              rewrite ltn_add2r;

                rewrite ltn_add2r;

                apply /ltP; auto.

            + apply /leP.

              rewrite -addnA.

              rewrite leq_add2l.

              apply /leP.

              replace (i * N1 * N2) with

              ((i * N2) * N1).

              *

                rewrite -mulnDl.

                rewrite mulnC.

                apply /leP.

                rewrite leq_pmul2l; try (apply /ltP; omega).

                apply /leP.

                eapply lt_n_Sm_le.

                rewrite - addn1.

                rewrite subnK.

                2:

                  rewrite muln_gt0;

                  apply /andP; split;

                  try (apply /ltP; omega).

                eapply (NPeano.Nat.lt_le_trans).

                -- instantiate (1:= N2 + i * N2).

                   apply /ltP.

                   rewrite ltn_add2r.

                   apply /leP; auto.

                -- replace (N2 + i * N2) with

                   (N2 * (1 + i)).

                   apply /leP.

                   rewrite leq_pmul2l.

                   rewrite add1n.

                   apply /ltP; auto.

                   apply /ltP; omega.

                   rewrite mulnDr.

                   rewrite mulnC.

                   f_equal.

                   compute; auto.

                   rewrite mulnC; auto.

              * do 2 rewrite - mulnA.

                f_equal. rewrite mulnC; auto.

          - replace (N1 + N1 * (N2 * N - 1))

            with (N1 * 1 + N1 * (N2 * N - 1)).

            + rewrite -mulnDr.

              rewrite addnC.

              rewrite subnK.



              2:

                rewrite muln_gt0;

                apply /andP; split;

                try (apply /ltP; omega).

              rewrite -mulnA.

              rewrite mulnA.

              rewrite mulnC; auto.

            + f_equal.

              rewrite mulnC.

              compute; auto. }

      -- simpl; f_equal.

         ++ rewrite - fi1.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2) with

            (i1 + (i2  + i *  N2) * N1).

            2:

            rewrite mulnDl addnA; f_equal;

            do 2 rewrite -mulnA; f_equal; rewrite mulnC; auto.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N1; omega.

         ++ rewrite - fi.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            assert (i1 + i2 * N1 + i * N1 * N2 =

                    ((N1 * N2) * i) + (i1 + i2 * N1)).

            { rewrite addnC. f_equal.

              rewrite - mulnA mulnC; auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            eapply (NPeano.Nat.lt_le_trans).

            ** instantiate (1:= N1 + i2 * N1).

               apply /ltP; rewrite ltn_add2r.

               apply /ltP; auto.

            ** replace (N1 + i2 * N1) with ( (1 + i2) * N1).

               rewrite add1n.

               rewrite mulnC.

               apply /leP; rewrite leq_pmul2l.

               apply /ltP; auto.

               destruct N1; ssromega.

               rewrite mulnDl; f_equal.

               ssromega.



         ++ rewrite - fi2.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + i * N1 * N2 + (1 - 1)) with

            (i1 + i2 * N1 + i * N1 * N2) by ssromega.

            assert (i1 + i2 * N1 + i * N1 * N2 =

                    (N1 * (i2 + i * N2)) + i1).

            { rewrite -addnA.

              replace (i * N1 * N2) with

              (i  * N2 * N1).

              rewrite - mulnDl.

              rewrite mulnC addnC; auto.

              do 2 rewrite -mulnA; f_equal.

              rewrite mulnC. auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            rewrite - H0.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N2; omega.

    + exists (S( N1 * N2)).

      exists (fun n => if n == 0

               then PTree.Leaf

               else

                 PTree.Node

                   (F1 ( (n-1) mod N1))

                   (None )

                   (F2 (((n-1) / N1 ) mod N2))).

      intros x spec.

      destruct x.

      * exists 0%nat; split; auto.

        omega.

      * move: spec .

        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.

        move : spec_F1 => /(_ _ tree1) [] i1 [] ineq1 fi1.

        move : spec_F2 => /(_ _ tree2) [] i2 [] ineq2 fi2.

        exists (S(i1 + (i2 * N1))); split.

        { apply lt_n_S.

          replace (N1 * N2) with

          (N1 + N1 * (N2 -1)).

          - eapply (NPeano.Nat.lt_le_trans).

            + instantiate (1:= (N1 + i2 * N1)).

              apply /ltP.

              rewrite ltn_add2r;

                apply /ltP; auto.

            + apply /leP.

              rewrite leq_add2l.

              apply /leP.

              rewrite mulnC.

              apply /leP.

              rewrite leq_pmul2l; try (apply /ltP; omega).

              apply /leP.

              eapply lt_n_Sm_le.

              rewrite - addn1.

              rewrite subnK; auto.

              destruct N2; ssromega.



          - replace (N1 + N1 * (N2 - 1))

            with (N1 * 1 + N1 * (N2 - 1)).

            + rewrite -mulnDr.

              rewrite addnC.

              rewrite subnK.

              2: ssromega.

              rewrite mulnC; auto.

            + f_equal.

              rewrite mulnC.

              compute; auto. }

      -- simpl; f_equal.

         ++ rewrite - fi1.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + (1 - 1)) with

            (i1 + i2 * N1) by ssromega.

            rewrite NPeano.Nat.mod_add.

            apply NPeano.Nat.mod_small; auto.

            destruct N1; omega.

         ++ destruct o; auto; inversion FUN_lq.

         ++ rewrite - fi2.

            f_equal.

            rewrite -addn1.

            rewrite -addnBA. 2: ssromega.

            replace (i1 + i2 * N1 + (1 - 1)) with

            (i1 + i2 * N1 ) by ssromega.

            assert (i1 + i2 * N1 =

                    (N1 * (i2) + i1)).

            { rewrite mulnC addnC; auto. }

            eapply NPeano.Nat.div_unique in H0; auto.

            rewrite - H0.

            apply NPeano.Nat.mod_small; auto.

Qed.



Lemma fun_leq_trans: forall {A B C} f1 f2 f3, @fun_leq A B f1 f2 -> @fun_leq B C f2 f3 ->

  @fun_leq A C f1 f3.

Proof.

  unfold fun_leq, fun_leq'; destruct f1, f2, f3; auto.

Qed.



Lemma sub_map_trans: forall {A B C} m1 m2 m3, @sub_map A B m1 m2 -> @sub_map B C m2 m3 ->

  @sub_map A C m1 m3.

Proof.

  unfold sub_map; induction m1; destruct m2; intros; inversion H; destruct m3; inversion H0;

    auto; simpl in *.

  repeat split.

  - eapply fun_leq_trans; eauto.

  - apply (IHm1_1 m2_1); tauto.

  - apply (IHm1_2 m2_2); tauto.

Qed.



Lemma same_shape_map:

  forall {A B} m f,

    @same_shape A B (PTree.map f m) m.

Proof.

  intros until m.

  unfold PTree.map.

  pose (i:=1%positive); fold i.

  generalize i; clear i.

  induction m.

  - intros;

      unfold same_shape;

      simpl; auto.

  - intros;

      unfold same_shape;

      split; [| split].

    + destruct o; simpl; auto.

    + eapply IHm1.

    + eapply IHm2.

Qed.

