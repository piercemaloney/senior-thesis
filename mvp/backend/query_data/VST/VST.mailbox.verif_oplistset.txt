Require Import VST.progs.ghost.
Require Import mailbox.verif_ptr_atomics.
Require Import VST.progs.conclib.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.oplistset.
(* mailbox.oplistset:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition _CAS_SC : ident := 74%positive.
Definition ___builtin_annot : ident := 8%positive.
Definition ___builtin_annot_intval : ident := 9%positive.
Definition ___builtin_bswap : ident := 32%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 6%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 10%positive.
Definition ___builtin_memcpy_aligned : ident := 7%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 12%positive.
Definition ___builtin_va_copy : ident := 13%positive.
Definition ___builtin_va_end : ident := 14%positive.
Definition ___builtin_va_start : ident := 11%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 18%positive.
Definition ___compcert_va_float64 : ident := 17%positive.
Definition ___compcert_va_int32 : ident := 15%positive.
Definition ___compcert_va_int64 : ident := 16%positive.
Definition ___i64_dtos : ident := 19%positive.
Definition ___i64_dtou : ident := 20%positive.
Definition ___i64_sar : ident := 31%positive.
Definition ___i64_sdiv : ident := 25%positive.
Definition ___i64_shl : ident := 29%positive.
Definition ___i64_shr : ident := 30%positive.
Definition ___i64_smod : ident := 27%positive.
Definition ___i64_stod : ident := 21%positive.
Definition ___i64_stof : ident := 23%positive.
Definition ___i64_udiv : ident := 26%positive.
Definition ___i64_umod : ident := 28%positive.
Definition ___i64_utod : ident := 22%positive.
Definition ___i64_utof : ident := 24%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 59%positive.
Definition _add : ident := 97%positive.
Definition _atomic_loc : ident := 5%positive.
Definition _c : ident := 72%positive.
Definition _curr : ident := 87%positive.
Definition _del_node : ident := 85%positive.
Definition _e : ident := 82%positive.
Definition _exit : ident := 54%positive.
Definition _first : ident := 78%positive.
Definition _free : ident := 55%positive.
Definition _free_atomic : ident := 68%positive.
Definition _freelock : ident := 58%positive.
Definition _head : ident := 81%positive.
Definition _l : ident := 65%positive.
Definition _l1 : ident := 90%positive.
Definition _l2 : ident := 91%positive.
Definition _load_SC : ident := 70%positive.
Definition _locate : ident := 92%positive.
Definition _lock : ident := 4%positive.
Definition _lock_t : ident := 2%positive.
Definition _main : ident := 75%positive.
Definition _make_atomic : ident := 66%positive.
Definition _makelock : ident := 57%positive.
Definition _malloc : ident := 56%positive.
Definition _n : ident := 61%positive.
Definition _n1 : ident := 93%positive.
Definition _n2 : ident := 96%positive.
Definition _n3 : ident := 94%positive.
Definition _new_node : ident := 84%positive.
Definition _next : ident := 76%positive.
Definition _nnext : ident := 83%positive.
Definition _node : ident := 77%positive.
Definition _node_pair : ident := 80%positive.
Definition _p : ident := 62%positive.
Definition _pred : ident := 86%positive.
Definition _r : ident := 73%positive.
Definition _release : ident := 60%positive.
Definition _remove : ident := 98%positive.
Definition _result : ident := 95%positive.
Definition _second : ident := 79%positive.
Definition _store_SC : ident := 71%positive.
Definition _succ : ident := 88%positive.
Definition _surely_malloc : ident := 63%positive.
Definition _tgt : ident := 67%positive.
Definition _v : ident := 64%positive.
Definition _val : ident := 3%positive.
Definition _validate : ident := 89%positive.
Definition _x : ident := 69%positive.
Definition _t'1 : ident := 99%positive.
Definition _t'2 : ident := 100%positive.
Definition _t'3 : ident := 101%positive.
Definition _t'4 : ident := 102%positive.

Definition v_head := {|
  gvar_info := (tptr (Tstruct _node noattr));
  gvar_init := (Init_space 4 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_new_node := {|
  fn_return := (tptr (Tstruct _node noattr));
  fn_callconv := cc_default;
  fn_params := ((_e, tint) :: (_nnext, (tptr (Tstruct _node noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_r, (tptr (Tstruct _node noattr))) ::
               (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_n, (tptr (Tstruct _atomic_loc noattr))) ::
               (_t'3, (tptr (Tstruct _atomic_loc noattr))) ::
               (_t'2, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                             cc_default))
      ((Esizeof (Tstruct _node noattr) tuint) :: nil))
    (Sset _r (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sassign
      (Efield
        (Ederef (Etempvar _r (tptr (Tstruct _node noattr)))
          (Tstruct _node noattr)) _val tint) (Etempvar _e tint))
    (Ssequence
      (Ssequence
        (Scall (Some _t'2)
          (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                 cc_default))
          ((Esizeof (Tstruct _lock_t noattr) tuint) :: nil))
        (Sset _l (Etempvar _t'2 (tptr tvoid))))
      (Ssequence
        (Scall None
          (Evar _makelock (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                            cc_default))
          ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
        (Ssequence
          (Sassign
            (Efield
              (Ederef (Etempvar _r (tptr (Tstruct _node noattr)))
                (Tstruct _node noattr)) _lock
              (tptr (Tstruct _lock_t noattr)))
            (Etempvar _l (tptr (Tstruct _lock_t noattr))))
          (Ssequence
            (Scall None
              (Evar _release (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                               cc_default))
              ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
            (Ssequence
              (Ssequence
                (Scall (Some _t'3)
                  (Evar _make_atomic (Tfunction (Tcons (tptr tvoid) Tnil)
                                       (tptr (Tstruct _atomic_loc noattr))
                                       cc_default))
                  ((Etempvar _nnext (tptr (Tstruct _node noattr))) :: nil))
                (Sset _n (Etempvar _t'3 (tptr (Tstruct _atomic_loc noattr)))))
              (Ssequence
                (Sassign
                  (Efield
                    (Ederef (Etempvar _r (tptr (Tstruct _node noattr)))
                      (Tstruct _node noattr)) _next
                    (tptr (Tstruct _atomic_loc noattr)))
                  (Etempvar _n (tptr (Tstruct _atomic_loc noattr))))
                (Sreturn (Some (Etempvar _r (tptr (Tstruct _node noattr)))))))))))))
|}.

Definition f_del_node := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr (Tstruct _atomic_loc noattr))) ::
               (_l, (tptr (Tstruct _lock_t noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sset _p
    (Efield
      (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
        (Tstruct _node noattr)) _next (tptr (Tstruct _atomic_loc noattr))))
  (Ssequence
    (Scall None
      (Evar _free_atomic (Tfunction
                           (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil)
                           (tptr tvoid) cc_default))
      ((Etempvar _p (tptr (Tstruct _atomic_loc noattr))) :: nil))
    (Ssequence
      (Sset _l
        (Efield
          (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
            (Tstruct _node noattr)) _lock (tptr (Tstruct _lock_t noattr))))
      (Ssequence
        (Scall None
          (Evar _freelock (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                            cc_default))
          ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
        (Ssequence
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default))
            ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default))
            ((Etempvar _n (tptr (Tstruct _node noattr))) :: nil)))))))
|}.

Definition f_validate := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_e, tint) :: (_pred, (tptr (Tstruct _node noattr))) ::
                (_curr, (tptr (Tstruct _node noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_succ, (tptr (Tstruct _node noattr))) :: (_v, tint) ::
               (_n, (tptr (Tstruct _atomic_loc noattr))) ::
               (_p, (tptr (Tstruct _node noattr))) :: (_r, tint) ::
               (_t'3, tint) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Sset _succ (Evar _head (tptr (Tstruct _node noattr))))
  (Ssequence
    (Sset _v
      (Efield
        (Ederef (Etempvar _succ (tptr (Tstruct _node noattr)))
          (Tstruct _node noattr)) _val tint))
    (Ssequence
      (Swhile
        (Ebinop Olt (Etempvar _v tint) (Etempvar _e tint) tint)
        (Ssequence
          (Sset _n
            (Efield
              (Ederef (Etempvar _succ (tptr (Tstruct _node noattr)))
                (Tstruct _node noattr)) _next
              (tptr (Tstruct _atomic_loc noattr))))
          (Ssequence
            (Ssequence
              (Scall (Some _t'1)
                (Evar _load_SC (Tfunction
                                 (Tcons (tptr (Tstruct _atomic_loc noattr))
                                   Tnil) (tptr tvoid) cc_default))
                ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) :: nil))
              (Sset _succ
                (Ecast (Etempvar _t'1 (tptr tvoid))
                  (tptr (Tstruct _node noattr)))))
            (Sset _v
              (Efield
                (Ederef (Etempvar _succ (tptr (Tstruct _node noattr)))
                  (Tstruct _node noattr)) _val tint)))))
      (Ssequence
        (Sset _n
          (Efield
            (Ederef (Etempvar _pred (tptr (Tstruct _node noattr)))
              (Tstruct _node noattr)) _next
            (tptr (Tstruct _atomic_loc noattr))))
        (Ssequence
          (Ssequence
            (Scall (Some _t'2)
              (Evar _load_SC (Tfunction
                               (Tcons (tptr (Tstruct _atomic_loc noattr))
                                 Tnil) (tptr tvoid) cc_default))
              ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) :: nil))
            (Sset _p (Etempvar _t'2 (tptr tvoid))))
          (Ssequence
            (Sset _r
              (Ebinop Oeq (Etempvar _succ (tptr (Tstruct _node noattr)))
                (Etempvar _curr (tptr (Tstruct _node noattr))) tint))
            (Ssequence
              (Ssequence
                (Sifthenelse (Etempvar _r tint)
                  (Sset _t'3
                    (Ecast
                      (Ebinop Oeq (Etempvar _p (tptr (Tstruct _node noattr)))
                        (Etempvar _curr (tptr (Tstruct _node noattr))) tint)
                      tbool))
                  (Sset _t'3 (Econst_int (Int.repr 0) tint)))
                (Sset _r (Etempvar _t'3 tint)))
              (Sreturn (Some (Etempvar _r tint))))))))))
|}.

Definition f_locate := {|
  fn_return := (tptr (Tstruct _node_pair noattr));
  fn_callconv := cc_default;
  fn_params := ((_e, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_pred, (tptr (Tstruct _node noattr))) ::
               (_n, (tptr (Tstruct _atomic_loc noattr))) ::
               (_curr, (tptr (Tstruct _node noattr))) :: (_v, tint) ::
               (_l1, (tptr (Tstruct _lock_t noattr))) ::
               (_l2, (tptr (Tstruct _lock_t noattr))) ::
               (_r, (tptr (Tstruct _node_pair noattr))) :: (_t'4, tint) ::
               (_t'3, (tptr tvoid)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _pred (Evar _head (tptr (Tstruct _node noattr))))
      (Ssequence
        (Sset _n
          (Efield
            (Ederef (Etempvar _pred (tptr (Tstruct _node noattr)))
              (Tstruct _node noattr)) _next
            (tptr (Tstruct _atomic_loc noattr))))
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _load_SC (Tfunction
                               (Tcons (tptr (Tstruct _atomic_loc noattr))
                                 Tnil) (tptr tvoid) cc_default))
              ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) :: nil))
            (Sset _curr
              (Ecast (Etempvar _t'1 (tptr tvoid))
                (tptr (Tstruct _node noattr)))))
          (Ssequence
            (Sset _v
              (Efield
                (Ederef (Etempvar _curr (tptr (Tstruct _node noattr)))
                  (Tstruct _node noattr)) _val tint))
            (Ssequence
              (Swhile
                (Ebinop Olt (Etempvar _v tint) (Etempvar _e tint) tint)
                (Ssequence
                  (Sset _pred (Etempvar _curr (tptr (Tstruct _node noattr))))
                  (Ssequence
                    (Sset _n
                      (Efield
                        (Ederef
                          (Etempvar _curr (tptr (Tstruct _node noattr)))
                          (Tstruct _node noattr)) _next
                        (tptr (Tstruct _atomic_loc noattr))))
                    (Ssequence
                      (Ssequence
                        (Scall (Some _t'2)
                          (Evar _load_SC (Tfunction
                                           (Tcons
                                             (tptr (Tstruct _atomic_loc noattr))
                                             Tnil) (tptr tvoid) cc_default))
                          ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) ::
                           nil))
                        (Sset _curr
                          (Ecast (Etempvar _t'2 (tptr tvoid))
                            (tptr (Tstruct _node noattr)))))
                      (Sset _v
                        (Efield
                          (Ederef
                            (Etempvar _curr (tptr (Tstruct _node noattr)))
                            (Tstruct _node noattr)) _val tint))))))
              (Ssequence
                (Sset _l1
                  (Efield
                    (Ederef (Etempvar _pred (tptr (Tstruct _node noattr)))
                      (Tstruct _node noattr)) _lock
                    (tptr (Tstruct _lock_t noattr))))
                (Ssequence
                  (Sset _l2
                    (Efield
                      (Ederef (Etempvar _curr (tptr (Tstruct _node noattr)))
                        (Tstruct _node noattr)) _lock
                      (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _acquire (Tfunction (Tcons (tptr tvoid) Tnil)
                                       tvoid cc_default))
                      ((Etempvar _l1 (tptr (Tstruct _lock_t noattr))) :: nil))
                    (Ssequence
                      (Scall None
                        (Evar _acquire (Tfunction (Tcons (tptr tvoid) Tnil)
                                         tvoid cc_default))
                        ((Etempvar _l2 (tptr (Tstruct _lock_t noattr))) ::
                         nil))
                      (Ssequence
                        (Scall (Some _t'4)
                          (Evar _validate (Tfunction
                                            (Tcons tint
                                              (Tcons
                                                (tptr (Tstruct _node noattr))
                                                (Tcons
                                                  (tptr (Tstruct _node noattr))
                                                  Tnil))) tint cc_default))
                          ((Etempvar _e tint) ::
                           (Etempvar _pred (tptr (Tstruct _node noattr))) ::
                           (Etempvar _curr (tptr (Tstruct _node noattr))) ::
                           nil))
                        (Sifthenelse (Etempvar _t'4 tint)
                          (Ssequence
                            (Ssequence
                              (Scall (Some _t'3)
                                (Evar _surely_malloc (Tfunction
                                                       (Tcons tuint Tnil)
                                                       (tptr tvoid)
                                                       cc_default))
                                ((Esizeof (Tstruct _node_pair noattr) tuint) ::
                                 nil))
                              (Sset _r (Etempvar _t'3 (tptr tvoid))))
                            (Ssequence
                              (Sassign
                                (Efield
                                  (Ederef
                                    (Etempvar _r (tptr (Tstruct _node_pair noattr)))
                                    (Tstruct _node_pair noattr)) _first
                                  (tptr (Tstruct _node noattr)))
                                (Etempvar _pred (tptr (Tstruct _node noattr))))
                              (Ssequence
                                (Sassign
                                  (Efield
                                    (Ederef
                                      (Etempvar _r (tptr (Tstruct _node_pair noattr)))
                                      (Tstruct _node_pair noattr)) _second
                                    (tptr (Tstruct _node noattr)))
                                  (Etempvar _curr (tptr (Tstruct _node noattr))))
                                (Sreturn (Some (Etempvar _r (tptr (Tstruct _node_pair noattr))))))))
                          (Ssequence
                            (Scall None
                              (Evar _release (Tfunction
                                               (Tcons (tptr tvoid) Tnil)
                                               tvoid cc_default))
                              ((Etempvar _l1 (tptr (Tstruct _lock_t noattr))) ::
                               nil))
                            (Scall None
                              (Evar _release (Tfunction
                                               (Tcons (tptr tvoid) Tnil)
                                               tvoid cc_default))
                              ((Etempvar _l2 (tptr (Tstruct _lock_t noattr))) ::
                               nil)))))))))))))))
  Sskip)
|}.

Definition f_add := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_e, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_r, (tptr (Tstruct _node_pair noattr))) ::
               (_n1, (tptr (Tstruct _node noattr))) ::
               (_n3, (tptr (Tstruct _node noattr))) :: (_v, tint) ::
               (_result, tint) :: (_n2, (tptr (Tstruct _node noattr))) ::
               (_n, (tptr (Tstruct _atomic_loc noattr))) ::
               (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_t'2, (tptr (Tstruct _node noattr))) ::
               (_t'1, (tptr (Tstruct _node_pair noattr))) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _locate (Tfunction (Tcons tint Tnil)
                      (tptr (Tstruct _node_pair noattr)) cc_default))
      ((Etempvar _e tint) :: nil))
    (Sset _r (Etempvar _t'1 (tptr (Tstruct _node_pair noattr)))))
  (Ssequence
    (Sset _n1
      (Efield
        (Ederef (Etempvar _r (tptr (Tstruct _node_pair noattr)))
          (Tstruct _node_pair noattr)) _first (tptr (Tstruct _node noattr))))
    (Ssequence
      (Sset _n3
        (Efield
          (Ederef (Etempvar _r (tptr (Tstruct _node_pair noattr)))
            (Tstruct _node_pair noattr)) _second
          (tptr (Tstruct _node noattr))))
      (Ssequence
        (Scall None
          (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid cc_default))
          ((Etempvar _r (tptr (Tstruct _node_pair noattr))) :: nil))
        (Ssequence
          (Sset _v
            (Efield
              (Ederef (Etempvar _n3 (tptr (Tstruct _node noattr)))
                (Tstruct _node noattr)) _val tint))
          (Ssequence
            (Sifthenelse (Ebinop One (Etempvar _v tint) (Etempvar _e tint)
                           tint)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'2)
                    (Evar _new_node (Tfunction
                                      (Tcons tint
                                        (Tcons (tptr (Tstruct _node noattr))
                                          Tnil))
                                      (tptr (Tstruct _node noattr))
                                      cc_default))
                    ((Etempvar _e tint) ::
                     (Etempvar _n3 (tptr (Tstruct _node noattr))) :: nil))
                  (Sset _n2 (Etempvar _t'2 (tptr (Tstruct _node noattr)))))
                (Ssequence
                  (Sset _n
                    (Efield
                      (Ederef (Etempvar _n1 (tptr (Tstruct _node noattr)))
                        (Tstruct _node noattr)) _next
                      (tptr (Tstruct _atomic_loc noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _store_SC (Tfunction
                                        (Tcons
                                          (tptr (Tstruct _atomic_loc noattr))
                                          (Tcons (tptr tvoid) Tnil)) tvoid
                                        cc_default))
                      ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) ::
                       (Etempvar _n2 (tptr (Tstruct _node noattr))) :: nil))
                    (Sset _result (Econst_int (Int.repr 1) tint)))))
              (Sset _result (Econst_int (Int.repr 0) tint)))
            (Ssequence
              (Sset _l
                (Efield
                  (Ederef (Etempvar _n1 (tptr (Tstruct _node noattr)))
                    (Tstruct _node noattr)) _lock
                  (tptr (Tstruct _lock_t noattr))))
              (Ssequence
                (Scall None
                  (Evar _release (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                   cc_default))
                  ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                (Ssequence
                  (Sset _l
                    (Efield
                      (Ederef (Etempvar _n3 (tptr (Tstruct _node noattr)))
                        (Tstruct _node noattr)) _lock
                      (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _release (Tfunction (Tcons (tptr tvoid) Tnil)
                                       tvoid cc_default))
                      ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                    (Sreturn (Some (Etempvar _result tint)))))))))))))
|}.

Definition f_remove := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_e, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_r, (tptr (Tstruct _node_pair noattr))) ::
               (_n1, (tptr (Tstruct _node noattr))) ::
               (_n2, (tptr (Tstruct _node noattr))) :: (_v, tint) ::
               (_result, tint) ::
               (_n, (tptr (Tstruct _atomic_loc noattr))) ::
               (_n3, (tptr (Tstruct _node noattr))) ::
               (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr (Tstruct _node_pair noattr))) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _locate (Tfunction (Tcons tint Tnil)
                      (tptr (Tstruct _node_pair noattr)) cc_default))
      ((Etempvar _e tint) :: nil))
    (Sset _r (Etempvar _t'1 (tptr (Tstruct _node_pair noattr)))))
  (Ssequence
    (Sset _n1
      (Efield
        (Ederef (Etempvar _r (tptr (Tstruct _node_pair noattr)))
          (Tstruct _node_pair noattr)) _first (tptr (Tstruct _node noattr))))
    (Ssequence
      (Sset _n2
        (Efield
          (Ederef (Etempvar _r (tptr (Tstruct _node_pair noattr)))
            (Tstruct _node_pair noattr)) _second
          (tptr (Tstruct _node noattr))))
      (Ssequence
        (Scall None
          (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid cc_default))
          ((Etempvar _r (tptr (Tstruct _node_pair noattr))) :: nil))
        (Ssequence
          (Sset _v
            (Efield
              (Ederef (Etempvar _n2 (tptr (Tstruct _node noattr)))
                (Tstruct _node noattr)) _val tint))
          (Ssequence
            (Sifthenelse (Ebinop Oeq (Etempvar _v tint) (Etempvar _e tint)
                           tint)
              (Ssequence
                (Sset _n
                  (Efield
                    (Ederef (Etempvar _n2 (tptr (Tstruct _node noattr)))
                      (Tstruct _node noattr)) _next
                    (tptr (Tstruct _atomic_loc noattr))))
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'2)
                      (Evar _load_SC (Tfunction
                                       (Tcons
                                         (tptr (Tstruct _atomic_loc noattr))
                                         Tnil) (tptr tvoid) cc_default))
                      ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) ::
                       nil))
                    (Sset _n3 (Etempvar _t'2 (tptr tvoid))))
                  (Ssequence
                    (Sset _n
                      (Efield
                        (Ederef (Etempvar _n1 (tptr (Tstruct _node noattr)))
                          (Tstruct _node noattr)) _next
                        (tptr (Tstruct _atomic_loc noattr))))
                    (Ssequence
                      (Scall None
                        (Evar _store_SC (Tfunction
                                          (Tcons
                                            (tptr (Tstruct _atomic_loc noattr))
                                            (Tcons (tptr tvoid) Tnil)) tvoid
                                          cc_default))
                        ((Etempvar _n (tptr (Tstruct _atomic_loc noattr))) ::
                         (Etempvar _n3 (tptr (Tstruct _node noattr))) :: nil))
                      (Sset _result (Econst_int (Int.repr 1) tint))))))
              (Sset _result (Econst_int (Int.repr 0) tint)))
            (Ssequence
              (Sset _l
                (Efield
                  (Ederef (Etempvar _n1 (tptr (Tstruct _node noattr)))
                    (Tstruct _node noattr)) _lock
                  (tptr (Tstruct _lock_t noattr))))
              (Ssequence
                (Scall None
                  (Evar _release (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                   cc_default))
                  ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                (Ssequence
                  (Sset _l
                    (Efield
                      (Ederef (Etempvar _n2 (tptr (Tstruct _node noattr)))
                        (Tstruct _node noattr)) _lock
                      (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Scall None
                      (Evar _release (Tfunction (Tcons (tptr tvoid) Tnil)
                                       tvoid cc_default))
                      ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                    (Sreturn (Some (Etempvar _result tint)))))))))))))
|}.

Definition composites : list composite_definition :=
(Composite _lock_t Struct ((_a, (tarray (tptr tvoid) 2)) :: nil) noattr ::
 Composite _node Struct
   ((_val, tint) :: (_next, (tptr (Tstruct _atomic_loc noattr))) ::
    (_lock, (tptr (Tstruct _lock_t noattr))) :: nil)
   noattr ::
 Composite _node_pair Struct
   ((_first, (tptr (Tstruct _node noattr))) ::
    (_second, (tptr (Tstruct _node noattr))) :: nil)
   noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_free, Gfun(External EF_free (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_makelock,
   Gfun(External (EF_external "makelock"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_freelock,
   Gfun(External (EF_external "freelock"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_acquire,
   Gfun(External (EF_external "acquire"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_release,
   Gfun(External (EF_external "release"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_surely_malloc,
   Gfun(External (EF_external "surely_malloc"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_make_atomic,
   Gfun(External (EF_external "make_atomic"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) (tptr (Tstruct _atomic_loc noattr))
     cc_default)) ::
 (_free_atomic,
   Gfun(External (EF_external "free_atomic"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) (tptr tvoid)
     cc_default)) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) (tptr tvoid)
     cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) (Tcons (tptr tvoid) Tnil))
     tvoid cc_default)) :: (_head, Gvar v_head) ::
 (_new_node, Gfun(Internal f_new_node)) ::
 (_del_node, Gfun(Internal f_del_node)) ::
 (_validate, Gfun(Internal f_validate)) ::
 (_locate, Gfun(Internal f_locate)) :: (_add, Gfun(Internal f_add)) ::
 (_remove, Gfun(Internal f_remove)) :: nil);
prog_public :=
(_remove :: _add :: _locate :: _validate :: _del_node :: _new_node ::
 _head :: _store_SC :: _load_SC :: _free_atomic :: _make_atomic ::
 _surely_malloc :: _release :: _acquire :: _freelock :: _makelock :: _free ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_fsqrt :: ___builtin_ctzll ::
 ___builtin_ctzl :: ___builtin_ctz :: ___builtin_clzll :: ___builtin_clzl ::
 ___builtin_clz :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod ::
 ___i64_smod :: ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof ::
 ___i64_utod :: ___i64_stod :: ___i64_dtou :: ___i64_dtos ::
 ___compcert_va_composite :: ___compcert_va_float64 ::
 ___compcert_va_int64 :: ___compcert_va_int32 :: ___builtin_va_end ::
 ___builtin_va_copy :: ___builtin_va_arg :: ___builtin_va_start ::
 ___builtin_membar :: ___builtin_annot_intval :: ___builtin_annot ::
 ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)

Set Bullet Behavior "Strict Subproofs".

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Definition tnode := Tstruct _node noattr.

Definition node_fun gsh1 gsh2 R a := let '(e0, g, p) := a in
  EX sh : share, EX e : Z, EX next : val, EX lock : val, !!(readable_share sh /\ repable_signed e /\ e0 < e /\
    if eq_dec e Int.max_signed then next = nullval else True) &&
    data_at sh tnode (vint e, (next, lock)) p * ghost_var gsh1 p g *
    EX g' : val, lock_inv sh lock (EX p : val, ghost_var gsh2 p g') *
    if eq_dec e Int.max_signed then emp else atomic_loc sh next (fun v => |>R (e, g', v)).

Definition node gsh1 gsh2 := HORec (node_fun gsh1 gsh2).

Lemma node_eq' : forall gsh1 gsh2,
  node gsh1 gsh2 = node_fun gsh1 gsh2 (node gsh1 gsh2).
Proof.
  intros; apply HORec_fold_unfold, prove_HOcontractive.
  intros P1 P2 ((e0, g), p).
  apply subp_exp; intro sh.
  apply subp_exp; intro e.
  apply subp_exp; intro next.
  apply subp_exp; intro lock.
  apply subp_sepcon; [apply subp_refl|].
  apply subp_exp; intro g'.
  apply subp_sepcon; [apply subp_refl|].
  if_tac; [apply subp_refl|].
  apply subp_andp; [apply subp_refl|].
  apply subp_exp; intro l.
  apply subp_sepcon; [apply subp_refl|].
  eapply derives_trans; [|simpl; apply subtypes.fash_derives, predicates_hered.andp_left1; auto].
  eapply derives_trans; [|apply (nonexpansive_lock_inv sh l)].
  eapply derives_trans; [|simpl; apply (A_inv_nonexpansive next l)].
  apply allp_right; intro v.
  apply allp_left with ((e, g'), v); auto.
Qed.

Corollary node_eq : forall gsh1 gsh2 e0 g p, node gsh1 gsh2 (e0, g, p) =
  EX sh : share, EX e : Z, EX next : val, EX lock : val, !!(readable_share sh /\ repable_signed e /\ e0 < e /\
    if eq_dec e Int.max_signed then next = nullval else True) &&
    data_at sh tnode (vint e, (next, lock)) p * ghost_var gsh1 p g *
    EX g' : val, lock_inv sh lock (EX p : val, ghost_var gsh2 p g') *
    if eq_dec e Int.max_signed then emp else atomic_loc sh next (fun v => |>node gsh1 gsh2 (e, g', v)).
Proof.
  intros.
  transitivity (node_fun gsh1 gsh2 (node gsh1 gsh2) (e0, g, p)); [|reflexivity].
  rewrite <- node_eq'; auto.
Qed.

Lemma node_isptr : forall gsh1 gsh2 e0 g p, node gsh1 gsh2 (e0, g, p) = !!isptr p && node gsh1 gsh2 (e0, g, p).
Proof.
  intros; eapply local_facts_isptr with (P := fun p => node gsh1 gsh2 (e0, g, p)); eauto.
  rewrite node_eq.
  Intros sh e next lock.
  rewrite data_at_isptr; entailer!.
Qed.
Hint Resolve node_isptr : saturate_local.

Definition acquire_spec := DECLARE _acquire acquire_spec.
Definition release_spec := DECLARE _release release_spec.
Definition makelock_spec := DECLARE _makelock (makelock_spec _).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,  x13 at level 0, x14 at level 0,
               x15 at level 0,
             P at level 100, Q at level 100).

Record node_rep := { data : Z; next : val; lock : val; gnext : val }.

Definition node_data gsh1 gsh2 sh rep p :=
  data_at sh tnode (vint (data rep), (next rep, lock rep)) p *
  lock_inv sh (lock rep) (EX p : val, ghost_var gsh2 p (gnext rep)) *
  if eq_dec (data rep) Int.max_signed then emp
  else atomic_loc sh (next rep) (fun v => |>node gsh1 gsh2 (data rep, gnext rep, v)).

Definition node' gsh1 gsh2 rep p := EX sh : share,
  !!(readable_share sh /\ repable_signed (data rep) /\
     if eq_dec (data rep) Int.max_signed then next rep = nullval else True) &&
  node_data gsh1 gsh2 sh rep p.

Definition known_nodes gsh1 gsh2 nodes :=
  fold_right sepcon emp (map (fun '(p, rep) => node' gsh1 gsh2 rep p) nodes).

Definition new_node_spec := DECLARE _new_node
  WITH e : Z, nnext : val, sh : share, rep : node_rep, gsh1 : share, gsh2 : share
  PRE [ _e OF tint, _nnext OF tptr tnode ]
    PROP (repable_signed e; readable_share sh; repable_signed (data rep); e < data rep;
          sepalg.join gsh1 gsh2 Tsh;
          if eq_dec (data rep) Int.max_signed then next rep = nullval else True)
    LOCAL (temp _e (vint e); temp _nnext nnext)
    SEP (node_data gsh1 gsh2 sh rep nnext)
  POST [ tptr tnode ]
   EX p : val, EX rep' : node_rep,
    PROP (data rep' = e)
    LOCAL (temp ret_temp p)
    SEP (node_data gsh1 gsh2 Tsh rep' p;
         malloc_token Tsh (sizeof tnode) p; malloc_token Tsh (sizeof tlock) (lock rep')).

Definition validate_spec := DECLARE _validate
  WITH hp : val, head : val, e : Z, pred : val, curr : val, sh : share, gsh1 : share, gsh2 : share,
    reph : node_rep, repp : node_rep, pn : val, repc : node_rep, nodes : _
  PRE [ _e OF tint, _pred OF tptr tnode, _curr OF tptr tnode ]
    PROP (Int.min_signed < e < Int.max_signed; Int.min_signed <= data repp < e;
          readable_share sh; readable_share gsh1; readable_share gsh2; sepalg.join gsh1 gsh2 Tsh;
          e <= data repc <= Int.max_signed; data reph = Int.min_signed;
          In (head, reph) nodes; In (pred, repp) nodes;
          In (curr, repc) nodes; curr <> pred; curr <> head)
    LOCAL (gvar _head hp; temp _e (vint e); temp _pred pred; temp _curr curr)
    SEP (data_at sh (tptr tnode) head hp; ghost_var gsh2 pn (gnext repp); known_nodes gsh1 gsh2 nodes)
  POST [ tint ]
   EX b : bool, EX nodes' : _,
    PROP (incl nodes nodes'; b = true -> pn = curr)
    LOCAL (temp ret_temp (Val.of_bool b))
    SEP (data_at sh (tptr tnode) head hp; ghost_var gsh2 pn (gnext repp); known_nodes gsh1 gsh2 nodes';
         valid_pointer pn).

Definition tnode_pair := Tstruct _node_pair noattr.

Definition locate_spec := DECLARE _locate
  WITH hp : val, head : val, e : Z, sh : share, gsh1 : share, gsh2 : share, reph : node_rep, nodes : _
  PRE [ _e OF tint ]
    PROP (Int.min_signed < e < Int.max_signed; readable_share sh; readable_share gsh1; readable_share gsh2;
          sepalg.join gsh1 gsh2 Tsh; data reph = Int.min_signed; In (head, reph) nodes)
    LOCAL (gvar _head hp; temp _e (vint e))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes)
  POST [ tptr tnode_pair ]
   EX r : val, EX pred : val, EX repp : node_rep, EX curr : val, EX repc : node_rep, EX cn : val, EX nodes' : _,
    PROP (data repp < e <= data repc; repable_signed (data repp); repable_signed (data repc);
          incl nodes nodes'; In (pred, repp) nodes'; In (curr, repc) nodes')
    LOCAL (temp ret_temp r)
    SEP (data_at Tsh tnode_pair (pred, curr) r; malloc_token Tsh (sizeof tnode_pair) r;
         data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes';
         ghost_var gsh2 curr (gnext repp); ghost_var gsh2 cn (gnext repc)).

Definition add_spec := DECLARE _add
  WITH hp : val, head : val, e : Z, sh : share, gsh1 : share, gsh2 : share, reph : node_rep, nodes : _
  PRE [ _e OF tint ]
    PROP (Int.min_signed < e < Int.max_signed; readable_share sh; readable_share gsh1; readable_share gsh2;
          sepalg.join gsh1 gsh2 Tsh; NoDup (map fst nodes); data reph = Int.min_signed; In (head, reph) nodes)
    LOCAL (gvar _head hp; temp _e (vint e))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes)
  POST [ tint ]
   EX b : bool, EX rep' : node_rep, EX n' : val, EX nodes' : _,
    PROP (data rep' = e; incl nodes nodes'; b = true -> ~In n' (map fst nodes); In (n', rep') nodes')
    LOCAL (temp ret_temp (Val.of_bool b))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes').

Definition remove_spec := DECLARE _remove
  WITH hp : val, head : val, e : Z, sh : share, gsh1 : share, gsh2 : share, reph : node_rep, nodes : _
  PRE [ _e OF tint ]
    PROP (Int.min_signed < e < Int.max_signed; readable_share sh; readable_share gsh1; readable_share gsh2;
          sepalg.join gsh1 gsh2 Tsh; data reph = Int.min_signed; In (head, reph) nodes)
    LOCAL (gvar _head hp; temp _e (vint e))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes)
  POST [ tint ]
   EX b : bool, EX n' : val, EX nodes' : _,
    PROP (incl nodes nodes'; b = true -> exists rep', In (n', rep') nodes' /\ data rep' = e)
    LOCAL (temp ret_temp (Val.of_bool b))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes').

Definition Gprog : funspecs := ltac:(with_library prog [surely_malloc_spec; acquire_spec; release_spec;
  makelock_spec; make_atomic_spec; load_SC_spec; store_SC_spec;
  validate_spec; locate_spec; new_node_spec; add_spec; remove_spec]).

Ltac cancel_for_forward_call ::= repeat (rewrite ?sepcon_andp_prop', ?sepcon_andp_prop);
  repeat (apply andp_right; [auto; apply prop_right; auto|]); fast_cancel.

Lemma node_lock_inv_positive : forall gsh2 g, positive_mpred (EX p : val, ghost_var gsh2 p g).
Admitted. 
Hint Resolve node_lock_inv_positive.

Lemma node_precise : forall gsh1 gsh2 e g v, precise (|> node gsh1 gsh2 (e, g, v)).
Admitted.
Hint Resolve node_precise.

Lemma body_new_node : semax_body Vprog Gprog f_new_node new_node_spec.
Proof.
  start_function.
  forward_call (sizeof tnode).
  { simpl; computable. }
  Intros r.
  rewrite malloc_compat; auto; Intros.
  rewrite memory_block_data_at_; auto.
  forward.
  forward_call (sizeof tlock).
  { simpl; computable. }
  Intros l.
  rewrite malloc_compat; auto; Intros.
  rewrite memory_block_data_at_; auto.
  apply ghost_alloc with (g := (Tsh, nnext)); auto with init; Intro g.
  forward_call (l, Tsh, EX p : val, ghost_var gsh2 p g).
  forward.
  forward_call (l, Tsh, EX p : val, ghost_var gsh2 p g).
  { lock_props.
    fold (ghost_var Tsh nnext g).
    rewrite <- (ghost_var_share_join _ _ _ _ _ SH0).
    Exists nnext; cancel. }
  forward_call (nnext, ghost_var gsh1 nnext g * node_data gsh1 gsh2 sh rep nnext,
    fun v => |>node gsh1 gsh2 (e, g, v), emp).
  { repeat intro.
    eapply semax_pre; [|eauto].
    go_lowerx; cancel.
    unfold node_data; rewrite node_eq.
    rewrite <- sepcon_emp at 1; apply sepcon_derives.
    apply andp_right.
    - eapply derives_trans, now_later.
      rewrite node_eq; Exists sh (data rep) (next rep) (lock rep) (gnext rep); entailer!.
    - eapply derives_trans, now_later; entailer!.
    - apply andp_right; auto.
      eapply derives_trans, precise_weak_precise; auto.
      rewrite <- node_eq; auto. }
  Intro n.
  repeat forward.
  Exists r {| data := e; next := n; lock := l; gnext := g |}; unfold node_data; simpl;
    destruct (eq_dec e Int.max_signed); [unfold repable_signed in *; omega|]; entailer!.
  { exists 2; auto. }
  { exists 2; auto. }
Qed.

Lemma node_contents_eq : forall sh1 sh2 e1 e2 n1 n2 l1 l2 p, readable_share sh1 -> readable_share sh2 ->
  repable_signed e1 -> repable_signed e2 -> n1 <> Vundef -> n2 <> Vundef -> l1 <> Vundef -> l2 <> Vundef ->
  data_at sh1 tnode (vint e1, (n1, l1)) p * data_at sh2 tnode (vint e2, (n2, l2)) p |--
  !!(e1 = e2 /\ n1 = n2 /\ l1 = l2).
Proof.
  intros; simpl in *; do 2 unfold_data_at 1%nat.
  rewrite <- !sepcon_assoc, (sepcon_comm _ (field_at _ _ [StructField _val] _ _)), <- !sepcon_assoc.
  unfold field_at, at_offset; rewrite !data_at_rec_eq; unfold unfold_reptype; simpl; Intros.
  rewrite 3sepcon_assoc; apply saturate_aux20.
  { eapply derives_trans; [apply mapsto_value_eq; auto; discriminate|].
    apply prop_left; intro; apply prop_right, repr_inj_signed; auto; congruence. }
  rewrite <- !sepcon_assoc, (sepcon_comm _ (mapsto _ _ _ n2)), <- sepcon_assoc.
  rewrite sepcon_assoc, (sepcon_comm (mapsto _ _ _ _)); apply saturate_aux20; apply mapsto_value_eq; auto.
Qed.

Lemma node_val_eq : forall sh1 sh2 e1 e2 n1 n2 l1 l2 p, readable_share sh1 -> readable_share sh2 ->
  repable_signed e1 -> repable_signed e2 ->
  data_at sh1 tnode (vint e1, (n1, l1)) p * data_at sh2 tnode (vint e2, (n2, l2)) p |-- !!(e1 = e2).
Proof.
  intros; simpl in *; do 2 unfold_data_at 1%nat.
  rewrite <- !sepcon_assoc, (sepcon_comm _ (field_at _ _ [StructField _val] _ _)), <- !sepcon_assoc.
  do 4 apply sepcon_derives_prop.
  unfold field_at, at_offset; rewrite !data_at_rec_eq; simpl; Intros.
  eapply derives_trans; [apply mapsto_value_eq; auto; discriminate|].
  unfold unfold_reptype; simpl; apply prop_left; intro; apply prop_right, repr_inj_signed; auto; congruence.
Qed.

Corollary node_data_eq : forall gsh1 gsh2 sh1 sh2 rep1 rep2 p, readable_share sh1 -> readable_share sh2 ->
  repable_signed (data rep1) -> repable_signed (data rep2) ->
  node_data gsh1 gsh2 sh1 rep1 p * node_data gsh1 gsh2 sh2 rep2 p |-- !!(data rep1 = data rep2).
Proof.
  intros; unfold node_data; Intros.
  rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at _ _ _ _)), <- !sepcon_assoc.
  do 4 apply sepcon_derives_prop; rewrite sepcon_comm; apply node_val_eq; auto.
Qed.

Lemma node_data_valid_pointer : forall gsh1 gsh2 sh rep p, readable_share sh ->
  node_data gsh1 gsh2 sh rep p |-- valid_pointer p.
Proof.
  intros; unfold node_data; Intros.
  rewrite sepcon_assoc; apply sepcon_valid_pointer1, data_at_valid_ptr; auto; simpl; computable.
Qed.

Lemma node_data_isptr : forall gsh1 gsh2 sh rep p,
  node_data gsh1 gsh2 sh rep p = !!isptr p && node_data gsh1 gsh2 sh rep p.
Proof.
  intros.
  eapply local_facts_isptr; [|eauto].
  unfold node_data; entailer!.
Qed.
Hint Resolve node_data_isptr : saturate_local.

Lemma node_data_share_join : forall gsh1 gsh2 sh1 sh2 sh rep p, readable_share sh1 -> readable_share sh2 ->
  sepalg.join sh1 sh2 sh ->
  node_data gsh1 gsh2 sh1 rep p * node_data gsh1 gsh2 sh2 rep p = node_data gsh1 gsh2 sh rep p.
Proof.
  intros; unfold node_data.
  rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at _ _ _ _)).
  erewrite <- !sepcon_assoc, (sepcon_comm (data_at _ _ _ _)), data_at_share_join by eauto.
  rewrite (sepcon_comm _ (lock_inv _ _ _)), <- !sepcon_assoc.
  erewrite (sepcon_comm _ (lock_inv _ _ _)), <- !sepcon_assoc, lock_inv_share_join by eauto.
  if_tac; [rewrite !sepcon_emp, sepcon_comm; auto|].
  rewrite (sepcon_comm _ (atomic_loc sh2 _ _)), <- !sepcon_assoc.
  erewrite (sepcon_comm _ (atomic_loc _ _ _)), <- !sepcon_assoc, atomic_loc_join by eauto.
  apply mpred_ext; cancel.
Qed.

Lemma known_nodes_cons : forall gsh1 gsh2 rep p nodes,
  known_nodes gsh1 gsh2 ((p, rep) :: nodes) = node' gsh1 gsh2 rep p * known_nodes gsh1 gsh2 nodes.
Proof.
  auto.
Qed.

Lemma known_nodes_join : forall gsh1 gsh2 nodes1 nodes2,
  known_nodes gsh1 gsh2 nodes1 * known_nodes gsh1 gsh2 nodes2 = known_nodes gsh1 gsh2 (nodes1 ++ nodes2).
Proof.
  intros; unfold known_nodes; rewrite map_app, sepcon_app; auto.
Qed.

Corollary known_node : forall gsh1 gsh2 nodes1 rep p nodes2,
  known_nodes gsh1 gsh2 (nodes1 ++ (p, rep) :: nodes2) =
  node' gsh1 gsh2 rep p * known_nodes gsh1 gsh2 (nodes1 ++ nodes2).
Proof.
  intros; rewrite <- !known_nodes_join, known_nodes_cons; apply mpred_ext; cancel.
Qed.

Instance EqDec_node_rep : EqDec node_rep.
Proof.
  repeat intro.
  decide equality; try apply EqDec_val.
  apply Z.eq_dec.
Qed.

Instance EqDec_node : EqDec (val * node_rep).
Proof.
  repeat intro.
  decide equality; [apply EqDec_node_rep | apply EqDec_val].
Qed.

Lemma in_nodes_eq : forall gsh1 gsh2 sh rep rep' p nodes (Hsh : readable_share sh)
  (Hin : In (p, rep') nodes) (Hrep : repable_signed (data rep)),
  node_data gsh1 gsh2 sh rep p * known_nodes gsh1 gsh2 nodes |-- !!(data rep = data rep').
Proof.
  intros.
  apply in_split in Hin; destruct Hin as (? & ? & ?); subst.
  rewrite <- known_nodes_join; unfold known_nodes; simpl.
  rewrite <- !sepcon_assoc, (sepcon_comm _ (node' _ _ _ _)), <- sepcon_assoc.
  unfold node'; Intros sh'.
  rewrite (sepcon_comm _ (node_data _ _ _ _ _)); do 2 apply sepcon_derives_prop.
  apply node_data_eq; auto.
Qed.

Corollary nodes_inj : forall gsh1 gsh2 rep1 rep2 p nodes
  (Hin1 : In (p, rep1) nodes) (Hin2 : In (p, rep2) nodes),
  known_nodes gsh1 gsh2 nodes |-- !!(data rep1 = data rep2).
Proof.
  intros.
  destruct (eq_dec (p, rep1) (p, rep2)); [inv e; entailer!|].
  apply in_split in Hin1; destruct Hin1 as (? & ? & ?); subst.
  unfold known_nodes; rewrite map_app, sepcon_app; simpl.
  unfold node' at 2; Intros sh.
  rewrite <- sepcon_assoc, (sepcon_comm _ (node_data _ _ _ _ _)).
  rewrite sepcon_assoc; setoid_rewrite known_nodes_join.
  apply in_nodes_eq; auto.
  rewrite in_app in *; destruct Hin2 as [|[|]]; auto; contradiction.
Qed.

Lemma node_valid : forall gsh1 gsh2 e g p, |> node gsh1 gsh2 (e, g, p) |-- |> valid_pointer p.
Proof.
  intros; apply later_derives.
  rewrite node_eq.
  Intros sh1 e1 next1 lock1; entailer!.
Qed.

Lemma body_validate : semax_body Vprog Gprog f_validate validate_spec.
Proof.
  start_function.
  unfold MORE_COMMANDS, abbreviate.
  assert (repable_signed (data repp)) by (split; omega).
  assert (repable_signed (data repc)) by (split; omega).
  assert (repable_signed (data reph)) by (replace (data reph) with Int.min_signed; split; computable).
  assert_PROP (pred = head -> data repp = data reph).
  { destruct (eq_dec pred head); [|apply prop_right; contradiction].
    subst; assert_PROP (data repp = data reph); [|apply prop_right; auto].
    focus_SEP 2; go_lower; eapply sepcon_derives_prop, nodes_inj; eauto. }
  match goal with H : In (head, _) nodes |- _ => apply in_split in H; destruct H as (nodes1 & nodes2 & ?); subst end.
  unfold known_nodes; rewrite map_app, sepcon_app; simpl; unfold node' at 2; unfold node_data; Intros shh.
  gather_SEP 2 6; replace_SEP 0 (known_nodes gsh1 gsh2 (nodes1 ++ nodes2)) by (rewrite <- known_nodes_join; entailer!).
  forward.
  forward.
  forward_while (EX succ : val, EX shs : share, EX reps : node_rep, EX nodes' : _,
    PROP (readable_share shs; repable_signed (data reps); incl (nodes1 ++ nodes2) nodes';
          succ = head /\ reps = reph \/ In (head, reph) nodes';
          if eq_dec (data reps) Int.max_signed then next reps = nullval else True)
    LOCAL (temp _v (vint (data reps)); temp _succ succ; gvar _head hp; temp _e (vint e); temp _pred pred;
           temp _curr curr)
    SEP (node_data gsh1 gsh2 shs reps succ; data_at sh (tptr tnode) head hp;
         ghost_var gsh2 pn (gnext repp); known_nodes gsh1 gsh2 nodes')).
  - Exists head shh reph (nodes1 ++ nodes2); entailer!.
    apply incl_refl.
  - entailer!.
  - unfold node_data; Intros.
    destruct (eq_dec (data reps) Int.max_signed); [omega|].
    rewrite atomic_loc_isptr; Intros.
    repeat forward.
    forward_call (shs, next reps, emp,
      fun v => |>node gsh1 gsh2 (data reps, gnext reps, v),
      fun v => |>(EX shs' : share, EX reps' : node_rep,
          !!(readable_share shs' /\ repable_signed (data reps') /\ data reps < data reps' /\
             if eq_dec (data reps') Int.max_signed then next reps' = nullval else True) &&
          node_data gsh1 gsh2 shs' reps' v)).
    { split; auto.
      intro.
      rewrite valid_same by (apply node_valid).
      rewrite sepcon_emp, <- later_sepcon; apply derives_view_shift, later_derives.
      rewrite node_eq; Intros sh' e' next' lock' g'.
      exploit split_readable_share; eauto; intros (sh1 & sh2 & ? & ? & Hsh).
      Exists sh1 e' next' lock' sh2 {| data := e'; next := next'; lock := lock'; gnext := g' |} g'.
      erewrite <- data_at_share_join, <- lock_inv_share_join; try apply Hsh; auto.
      unfold node_data; simpl; entailer!.
      if_tac; [entailer!|].
      erewrite atomic_loc_join; eauto. }
    Intros succ'.
    rewrite (later_exp' _ Share.bot); Intro shs'.
    rewrite (later_exp' _ {| data := 0; next := Vundef; lock := Vundef; gnext := Vundef|}); Intro reps'.
    hoist_later_in_pre.
    focus_SEP 1.
    erewrite extract_prop_in_SEP with (n := 0%nat); [|simpl; eauto].
    simpl replace_nth.
    unfold node_data at 1; rewrite !flatten_sepcon_in_SEP.
    apply assert_later_PROP with (P1 := readable_share shs'); [entailer!; tauto | intro].
    forward.
    Exists (succ', shs', reps', (succ, reps) :: nodes'); unfold node_data; entailer!.
    + split; [apply incl_tl; auto|].
      match goal with H : _ \/ _ |- _ => destruct H as [[]|]; auto end.
    + unfold known_nodes; simpl; cancel.
      unfold node', node_data; Exists shs; entailer!; if_tac; auto; omega.
  - eapply semax_pre with (P' := EX shp : share, EX nodes2 : _,
      PROP (readable_share shp; incl nodes' ((pred, repp) :: nodes2))
      LOCAL (temp _v (vint (data reps)); temp _succ succ; gvar _head hp;
             temp _e (vint e); temp _pred pred; temp _curr curr)
      SEP (node_data gsh1 gsh2 shp repp pred;
           if in_dec EqDec_node (pred, repp) nodes' then node_data gsh1 gsh2 shs reps succ
           else !!(pred = head /\ succ = head /\ reps = reph /\ repp = reph) && emp;
           data_at sh (tptr tnode) head hp; ghost_var gsh2 pn (gnext repp); known_nodes gsh1 gsh2 nodes2)).
    { destruct (in_dec EqDec_node (pred, repp) nodes').
      + apply in_split in i; destruct i as (nodes1' & nodes2' & ?); subst.
        rewrite known_node; unfold node'; Intros shp.
        Exists shp (nodes1' ++ nodes2'); entailer!.
        intros ? Hin; simpl; rewrite in_app in *; simpl in *; destruct Hin as [|[|]]; auto.
      + match goal with H : In (pred, repp) _ |- _ => rewrite in_app in H; destruct H as [|[X|]];
          try solve [match goal with H : incl _ nodes' |- _ =>
            specialize (H (pred, repp)); rewrite in_app in H; contradiction n; auto end] end.
        inv X.
        match goal with H : _ \/ _ |- _ => destruct H as [[]|]; [|contradiction] end.
        subst; Exists shs nodes'; entailer!.
        apply incl_tl, incl_refl. }
    unfold node_data at 1; Intros shp nodes''.
    destruct (eq_dec (data repp) Int.max_signed); [omega|].
    rewrite atomic_loc_isptr; Intros.
    forward.
    forward_call (shp, next repp, ghost_var gsh2 pn (gnext repp),
      fun v => |>node gsh1 gsh2 (data repp, gnext repp, v),
      fun v => |>(!!(v = pn /\ isptr pn) && ghost_var gsh2 pn (gnext repp) * valid_pointer pn)).
    { split; auto.
      intro.
      rewrite valid_same by (apply node_valid).
      etransitivity; [apply view_shift_sepcon, derives_view_shift, now_later; reflexivity|].
      rewrite <- !later_sepcon.
      apply view_shift_later.
      rewrite node_eq.
      rewrite exp_sepcon1; apply view_shift_exists; intro sh'.
      rewrite exp_sepcon1; apply view_shift_exists; intro e'.
      rewrite exp_sepcon1; apply view_shift_exists; intro next'.
      rewrite exp_sepcon1; apply view_shift_exists; intro lock'.
      rewrite !exp_sepcon1, !exp_sepcon2, exp_sepcon1; apply view_shift_exists; intro g'.
      rewrite !sepcon_andp_prop'; apply view_shift_prop; intros (? & ? & ? & ?).
      rewrite (sepcon_comm _ (ghost_var gsh2 _ _)).
      rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var _ _ _)), <- !sepcon_assoc.
      erewrite ghost_var_share_join' by eauto.
      rewrite !sepcon_andp_prop'; apply view_shift_prop; intro; subst.
      erewrite <- ghost_var_share_join by eauto.
      apply derives_view_shift.
      exploit split_readable_share; eauto; intros (sh1 & sh2 & ? & ? & Hsh).
      Exists sh1 e' next' lock' g'.
      erewrite <- data_at_share_join, <- lock_inv_share_join; try apply Hsh; auto.
      entailer!.
      rewrite !sepcon_assoc; eapply derives_trans; [apply sepcon_derives;
        [apply data_at_valid_ptr; auto; simpl; computable | apply derives_refl]|].
      if_tac.
      { rewrite sepcon_emp, emp_sepcon; apply sepcon_valid_pointer1; auto. }
      erewrite <- atomic_loc_join by eauto.
      rewrite <- !sepcon_assoc, (sepcon_comm _ (atomic_loc sh1 _ _)).
      rewrite !sepcon_assoc; apply sepcon_derives; auto; entailer!. }
    Intros n'.
    assert (In (curr, repc) nodes'') as Hcurr.
    { assert (In (curr, repc) nodes') as Hin.
      + match goal with H : incl _ nodes' |- _ => apply H end.
        match goal with H : In (curr, repc) _ |- _ =>
          rewrite in_app in *; destruct H as [|[X|]]; auto end.
        inv X; contradiction.
      + match goal with H : incl nodes' _ |- _ => specialize (H _ Hin); destruct H as [X|]; auto end.
        inv X; contradiction. }
    apply in_split in Hcurr; destruct Hcurr as (nodesa & nodesb & ?); subst.
    rewrite known_node; unfold node'; Intros shc.
    rewrite data_at_isptr, (node_data_isptr _ _ shc); Intros.
    assert_PROP (isptr succ).
    { if_tac; [|Intros; entailer!].
      rewrite node_data_isptr; entailer!. }
    hoist_later_in_pre; apply assert_later_PROP with (P1 := isptr pn).
    { entailer!. }
    intro; forward.
    { entailer!.
      apply denote_tc_test_eq_split.
      + destruct (in_dec EqDec_node (pred, repp) nodes').
        * rewrite (sepcon_comm _ (node_data _ _ _ _ succ)), !sepcon_assoc.
          apply sepcon_valid_pointer1, node_data_valid_pointer; auto.
        * Intros; subst.
          rewrite (sepcon_comm _ (data_at _ _ _ head)), !sepcon_assoc.
          apply sepcon_valid_pointer1, data_at_valid_ptr; auto; simpl; computable.
      + rewrite (sepcon_comm _ (node_data _ _ _ _ curr)), !sepcon_assoc.
        apply sepcon_valid_pointer1, node_data_valid_pointer; auto. }
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
      forward_if (PROP ()(LOCALx (temp _t'3 (Val.of_bool
        (if eq_dec succ curr then if eq_dec n' curr then true else false else false)) :: Q) (SEPx R))) end.
    { forward.
      { entailer!.
        apply denote_tc_test_eq_split; [entailer!|].
        rewrite (sepcon_comm _ (node_data _ _ _ _ curr)), !sepcon_assoc.
        apply sepcon_valid_pointer1, node_data_valid_pointer; auto. }
      entailer!; simpl.
      rewrite force_sem_cmp_pp in * by auto.
      if_tac; [|discriminate].
      if_tac; auto. }
    { forward.
      entailer!.
      rewrite force_sem_cmp_pp in * by auto.
      if_tac; [discriminate | auto]. }
    forward.
    forward.
    Exists (if eq_dec succ curr then if eq_dec pn curr then true else false else false)
      ((if in_dec EqDec_node (pred, repp) nodes' then [(succ, reps)] else []) ++
       (pred, repp) :: nodesa ++ (curr, repc) :: nodesb).
    rewrite <- !known_nodes_join, known_nodes_cons, known_node, <- !known_nodes_join.
    unfold node_data; entailer!.
    + split.
      * assert (In (pred, repp) nodes' \/ (pred, repp) = (head, reph)) as Hpred.
        { match goal with H : In (pred, repp) _ |- _ => rewrite in_app in H; destruct H as [|[|]]; auto end;
            match goal with H : incl _ nodes' |- _ => left; apply H; rewrite in_app; auto end. }
        intros a Hin; repeat match goal with H : incl _ _ |- _ => specialize (H a) end.
        rewrite in_app in *; simpl in *.
        destruct Hin as [|[X|]]; auto; inv X.
        destruct Hpred; auto.
        match goal with H : _ \/ _ |- _ => destruct H as [[]|]; auto; subst end.
        destruct (in_dec _ _ _); simpl; auto.
      * if_tac; [|discriminate].
        if_tac; [subst; auto | discriminate].
    + unfold node'.
      Exists shc shp; unfold node_data; destruct (eq_dec (data repp) Int.max_signed); [omega|].
      entailer!.
      unfold known_nodes; if_tac; simpl; entailer!.
      unfold node', node_data; Exists shs; entailer!.
Qed.

Lemma body_locate : semax_body Vprog Gprog f_locate locate_spec.
Proof.
  start_function.
  eapply semax_pre with (P' := EX nodes0 : _,
    PROP (incl nodes nodes0)
    LOCAL (gvar _head hp; temp _e (vint e))
    SEP (data_at sh (tptr tnode) head hp; known_nodes gsh1 gsh2 nodes0)).
  { Exists nodes; entailer!.
    apply incl_refl. }
  eapply semax_loop; [|forward; unfold loop2_ret_assert; apply ENTAIL_refl].
  Intros nodes0.
  forward.
  assert (In (head, reph) nodes0) as Hin by auto.
  apply in_split in Hin; destruct Hin as (nodes1 & nodes2 & ?); subst.
  rewrite known_node; unfold node', node_data; Intros shh.
  if_tac; [omega|].
  rewrite atomic_loc_isptr; Intros.
  repeat forward.
  forward_call (shh, next reph, emp,
    fun v => |>node gsh1 gsh2 (data reph, gnext reph, v),
    fun v => |>(EX shc : share, EX repc : node_rep,
      !!(readable_share shc /\ repable_signed (data repc) /\ data reph < data repc /\
         if eq_dec (data repc) Int.max_signed then next repc = nullval else True) &&
      node_data gsh1 gsh2 shc repc v)).
  { split; auto; intro.
    apply derives_view_shift.
    rewrite valid_same by (apply node_valid).
    rewrite <- later_sepcon.
    eapply derives_trans, later_derives; [rewrite later_sepcon; apply sepcon_derives, now_later; auto|].
    rewrite node_eq.
    Intros sh' e' next' lock' g'.
    exploit split_readable_share; eauto; intros (sh1 & sh2 & ? & ? & Hsh).
    Exists sh1 e' next' lock' sh2 {| data := e'; next := next'; lock := lock'; gnext := g' |} g'.
    erewrite <- data_at_share_join, <- lock_inv_share_join; try apply Hsh; auto.
    unfold node_data; simpl; entailer!.
    if_tac; [entailer!|].
    erewrite atomic_loc_join; eauto. }
  Intros curr0.
  rewrite (later_exp' _ Share.bot); Intro shc0.
  rewrite (later_exp' _ {| data := 0; next := Vundef; lock := Vundef; gnext := Vundef|}); Intro repc0.
  hoist_later_in_pre.
  focus_SEP 1.
  erewrite extract_prop_in_SEP with (n := O); [|simpl; eauto].
  simpl replace_nth.
  unfold node_data at 1; rewrite !flatten_sepcon_in_SEP.
  apply assert_later_PROP with (P1 := readable_share shc0); [entailer!; tauto | intro].
  forward.
  assert (repable_signed (data reph)) by (replace (data reph) with Int.min_signed; split; computable).
  destruct (eq_dec curr0 head).
  { subst; gather_SEP 0 5.
    assert_PROP (data repc0 = data reph); [|omega].
    go_lower; apply sepcon_derives_prop, node_val_eq; auto. }
  forward_while (EX pred : val, EX repp : node_rep, EX curr : val, EX shc : share, EX repc : node_rep, EX nodes' : _,
    PROP (readable_share shc; repable_signed (data repp); repable_signed (data repc);
          pred <> curr; curr <> head; data repp < e; data repp < data repc;
          incl (nodes1 ++ (head, reph) :: nodes2) nodes'; In (pred, repp) nodes';
          if eq_dec (data repc) Int.max_signed then next repc = nullval else True)
    LOCAL (temp _v (vint (data repc)); temp _curr curr; temp _pred pred;
           gvar _head hp; temp _e (vint e))
    SEP (node_data gsh1 gsh2 shc repc curr; known_nodes gsh1 gsh2 nodes';
         data_at sh (tptr tnode) head hp)).
  - Exists head reph curr0 shc0 repc0 (nodes1 ++ (head, reph) :: nodes2).
    rewrite known_node; unfold node', node_data.
    destruct (eq_dec (data reph) Int.max_signed); [omega|]; Exists shh; entailer!.
    split; [omega | apply incl_refl].
  - entailer!.
  - 
    unfold node_data; Intros.
    destruct (eq_dec (data repc) Int.max_signed); [omega|].
    rewrite atomic_loc_isptr; Intros.
    repeat forward.
    forward_call (shc, next repc, emp,
      fun v => |>node gsh1 gsh2 (data repc, gnext repc, v),
      fun v => |>(EX sh' : share, EX rep' : node_rep,
        !!(readable_share sh' /\ repable_signed (data rep') /\ data repc < data rep' /\
           if eq_dec (data rep') Int.max_signed then next rep' = nullval else True) &&
        node_data gsh1 gsh2 sh' rep' v)).
    { split; auto; intro.
      apply derives_view_shift.
      rewrite valid_same by (apply node_valid).
      rewrite <- later_sepcon.
      eapply derives_trans, later_derives; [rewrite later_sepcon; apply sepcon_derives, now_later; auto|].
      rewrite node_eq; unfold node'.
      Intros sh' e' next' lock' g'.
      exploit split_readable_share; eauto; intros (sh1 & sh2 & ? & ? & Hsh).
      Exists sh1 e' next' lock' sh2 {| data := e'; next := next'; lock := lock'; gnext := g' |} g'.
      erewrite <- data_at_share_join, <- lock_inv_share_join; try apply Hsh; auto.
      unfold node_data; simpl; entailer!.
      if_tac; [entailer!|].
      erewrite atomic_loc_join; eauto. }
    Intros curr'.
    rewrite (later_exp' _ Share.bot); Intro sh'.
    rewrite (later_exp' _ {| data := 0; next := Vundef; lock := Vundef; gnext := Vundef|}); Intro rep'.
    hoist_later_in_pre.
    focus_SEP 1.
    erewrite extract_prop_in_SEP with (n := 0%nat); [|simpl; eauto].
    simpl replace_nth.
    assert_PROP (curr' <> head).
    { destruct (eq_dec curr' head); [|apply prop_right; auto].
      Intros; assert_PROP (data rep' = data reph); [|unfold repable_signed in *; omega].
      gather_SEP 0 4.
      subst; go_lower; apply sepcon_derives_prop, in_nodes_eq; auto. }
    unfold node_data; rewrite !flatten_sepcon_in_SEP.
    apply assert_later_PROP with (P1 := readable_share sh'); [entailer!; tauto | intro].
    forward.
    destruct (eq_dec curr' curr).
    { gather_SEP 0 4; assert_PROP (data rep' = data repc); [|omega].
      subst; go_lower; apply sepcon_derives_prop, node_val_eq; auto. }
    Exists (curr, repc, curr', sh', rep', (curr, repc) :: nodes').
    simpl SEPx; rewrite known_nodes_cons; unfold node', node_data.
    Exists shc; destruct (eq_dec (data repc) Int.max_signed); [omega | entailer!].
    apply incl_tl; auto.
  - match goal with H : In (pred, repp) _ |- _ => apply in_split in H; destruct H as (nodesa & nodesb & ?); subst end.
    rewrite known_node; unfold node'; Intros shp.
    unfold node_data; rewrite (lock_inv_isptr shp), (lock_inv_isptr shc); Intros; repeat forward.
    forward_call (lock repp, shp, EX p : val, ghost_var gsh2 p (gnext repp)).
    forward_call (lock repc, shc, EX p : val, ghost_var gsh2 p (gnext repc)).
    Intros cn pn.
    forward_call (hp, head, e, pred, curr, sh, gsh1, gsh2, reph, repp, pn, repc,
      (curr, repc) :: nodesa ++ (pred, repp) :: nodesb).
    { rewrite known_nodes_cons, known_node; cancel.
      unfold node', node_data; Exists shc shp; entailer!. }
    { split; [auto|].
      split; [unfold repable_signed in *; tauto|].
      simpl; repeat (split; [auto|]); unfold repable_signed in *; try tauto; try omega.
      rewrite in_app; simpl; auto. }
    Intros x; destruct x as (b & nodes'').
    gather_SEP 1 4.
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx (_ :: ?R)))) _ _ =>
      forward_if (PROP () (LOCALx Q (SEPx R))) end.
    { subst; match goal with H : _ = _ -> _ |- _ => specialize (H eq_refl); subst end.
      forward_call (sizeof tnode_pair).
      { simpl; computable. }
      Intros r.
      rewrite malloc_compat; auto; Intros.
      rewrite memory_block_data_at_; auto.
      repeat forward.
      Exists r pred repp curr repc cn nodes''; entailer!.
      simpl in *.
      split; [eapply incl_tran | split]; try match goal with H : incl _ nodes'' |- _ => apply H end.
      + eapply incl_tl, incl_tran; eauto.
      + simpl; rewrite in_app; simpl; auto.
      + simpl; auto.
      + admit. 
      + exists 2; auto. }
    { simpl in *; assert (In (pred, repp) nodes'') as Hpred.
      { match goal with H : incl _ nodes'' |- _ => apply H end.
        simpl; rewrite in_app; simpl; auto. }
      apply in_split in Hpred; destruct Hpred as (nodesa' & nodesb' & ?); subst.
      rewrite known_node; unfold node', node_data; Intros shp'.
      forward_call (lock repp, shp', EX p : val, ghost_var gsh2 p (gnext repp)).
      { unfold node_data; lock_props.
        Exists pn; cancel. }
      assert (In (curr, repc) (nodesa' ++ nodesb')) as Hcurr.
      { match goal with H : incl _ _ |- _ => specialize (H _ (or_introl eq_refl)); rewrite in_app in *;
          destruct H as [|[X|]]; auto; inv X; contradiction end. }
      apply in_split in Hcurr; destruct Hcurr as (nodesa'' & nodesb'' & Heq).
      rewrite Heq, known_node; unfold node', node_data; Intros shc'.
      forward_call (lock repc, shc', EX p : val, ghost_var gsh2 p (gnext repc)).
      { unfold node_data; Intros; lock_props.
        Exists cn; cancel. }
      rewrite known_node, Heq, known_node.
      unfold node', node_data; Exists shp' shc'; entailer!. }
    intros; unfold overridePost.
    destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
    unfold POSTCONDITION, abbreviate, loop1_ret_assert; Intros.
    Exists nodes''; entailer!.
    eapply incl_tran, incl_tran, incl_cons_inv; eauto.
    { admit. }
Admitted.

Lemma body_add : semax_body Vprog Gprog f_add add_spec.
Proof.
  start_function.
  forward_call (hp, head, e, sh, gsh1, gsh2, reph, nodes).
  { unfold tnode; cancel. }
  { tauto. }
  Intros x; destruct x as ((((((r, pred), repp), curr), repc), cn), nodes1); simpl in *.
  match goal with H : In (pred, _) _ |- _ => apply in_split in H; destruct H as (nodesa & nodesb & ?); subst end.
  rewrite known_node.
  assert (In (curr, repc) (nodesa ++ nodesb)) as Hinc.
  { match goal with H : In (curr, _) _ |- _ => rewrite in_app in * ; destruct H as [|[X|]]; auto end.
    inv X; omega. }
  apply in_split in Hinc; destruct Hinc as (nodesa' & nodesb' & Heq); rewrite Heq, known_node.
  unfold node'; Intros shp shc.
  rewrite node_data_isptr with (p := pred), node_data_isptr with (p := curr).
  unfold node_data at 2; Intros.
  repeat forward.
  forward_call (r, sizeof (tnode_pair)).
  { apply sepcon_derives; [apply  data_at_memory_block | cancel_frame]. }
  forward.
  assert (incl nodes ((pred, repp) :: (curr, repc) :: nodesa' ++ nodesb')) as Hincl.
  { eapply incl_tran; eauto.
    intros a Hin; destruct (in_dec EqDec_node a (nodesa ++ nodesb)).
    + rewrite Heq in i.
      destruct (in_dec EqDec_node a (nodesa' ++ nodesb')); [simpl; auto|].
      rewrite in_app in *; simpl in *; destruct i as [|[|]]; auto; contradiction n; auto.
    + rewrite in_app in *; simpl in *; destruct Hin as [|[|]]; auto; contradiction n; auto. }
  gather_SEP 2 3 4 5 6; rewrite <- !sepcon_assoc; fold (node_data gsh1 gsh2 shc repc curr).
  match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx (_ :: ?R)))) _ _ =>
    forward_if (EX shc' : share, EX n' : val, EX rep' : node_rep, EX nodes' : _,
      PROP (data rep' = e; readable_share shc'; incl (nodesa' ++ nodesb') nodes';
            if eq_dec (data repc) e then n' = curr /\ rep' = repc
            else In (n', rep') nodes' /\ ~In n' (map fst nodes))
      (LOCALx (temp _result (Val.of_bool (if eq_dec (data repc) e then false else true)) :: Q)
      (SEPx (node_data gsh1 gsh2 shc' repc curr :: ghost_var gsh2 n' (gnext repp) ::
             known_nodes gsh1 gsh2 nodes' :: R)))) end.
  { destruct (split_readable_share shc) as (shc1 & shc2 & ? & ? & Hshc); auto.
    rewrite <- (node_data_share_join _ _ shc1 shc2 shc) by auto.
    forward_call (e, curr, shc2, repc, gsh1, gsh2).
    { split; [unfold repable_signed; omega|].
      split; [auto|].
      split; [auto|].
      split; [omega | auto]. }
    Intro x; destruct x as (n' & rep').
    destruct (in_dec EqDec_val n' (map fst nodes)).
    { rewrite in_map_iff in i; destruct i as ((n'', rep'') & ? & Hin); subst.
      apply Hincl in Hin; destruct Hin as [X|[X|Hin]]; try inv X; simpl.
      - unfold node_data at 1 3; Intros.
        gather_SEP 0 9.
        eapply semax_pre, semax_ff.
        go_lower; eapply derives_trans; [apply sepcon_derives, derives_refl | rewrite FF_sepcon; auto].
        apply data_at_Tsh_conflict; auto; simpl; computable.
      - unfold node_data at 1 2; Intros.
        gather_SEP 0 5.
        eapply semax_pre, semax_ff.
        go_lower; eapply derives_trans; [apply sepcon_derives, derives_refl | rewrite FF_sepcon; auto].
        apply data_at_Tsh_conflict; auto; simpl; computable.
      - apply in_split in Hin; destruct Hin as (? & ? & ->).
        rewrite known_node; unfold node'.
        unfold node_data at 1 3; Intros sh'.
        gather_SEP 0 6.
        eapply semax_pre, semax_ff.
        go_lower; eapply derives_trans; [apply sepcon_derives, derives_refl | rewrite FF_sepcon; auto].
        apply data_at_Tsh_conflict; auto; simpl; computable. }
    unfold node_data at 3; Intros.
    destruct (eq_dec (data repp) Int.max_signed); [omega|].
    rewrite node_data_isptr, atomic_loc_isptr; Intros.
    forward.
    rewrite <- (node_data_share_join _ _ gsh1 gsh2 Tsh) by auto.
    forward_call (shp, next repp, n',
      node_data gsh1 gsh2 gsh2 rep' n' * ghost_var gsh2 curr (gnext repp),
      fun v => |>node gsh1 gsh2 (data repp, gnext repp, v),
      |>(ghost_var gsh2 n' (gnext repp) *
         EX shc' : share, EX repc' : node_rep, !!(readable_share shc' /\ repable_signed (data repc') /\
           if eq_dec (data repc') Int.max_signed then next repc' = nullval else True) &&
           node_data gsh1 gsh2 shc' repc' curr)).
    { split; auto; intro.
      rewrite sepcon_comm; etransitivity;
        [apply view_shift_sepcon; [apply derives_view_shift, now_later | reflexivity]|].
      rewrite !valid_same by (apply node_valid).
      rewrite (sepcon_comm _ (|>(_ * _))), <- sepcon_assoc, <- !later_sepcon.
      rewrite <- sepcon_emp at 1; apply view_shift_sepcon.
      apply view_shift_later.
      rewrite node_eq.
      rewrite exp_sepcon2; apply view_shift_exists; intro sh'.
      rewrite exp_sepcon2; apply view_shift_exists; intro e'.
      rewrite exp_sepcon2; apply view_shift_exists; intro next'.
      rewrite exp_sepcon2; apply view_shift_exists; intro lock'.
      rewrite !exp_sepcon2; apply view_shift_exists; intro g'.
      rewrite !sepcon_andp_prop', sepcon_andp_prop; apply view_shift_prop; intros (? & ? & ? & ?).
      rewrite (sepcon_comm _ (ghost_var gsh2 _ _)).
      rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_var _ _ _)), <- !sepcon_assoc.
      erewrite ghost_var_share_join' by eauto.
      rewrite !sepcon_andp_prop'; apply view_shift_prop; intro; subst.
      rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon;
        [apply ghost_var_update with (v' := n') | reflexivity]|].
      erewrite <- ghost_var_share_join by eauto.
      apply derives_view_shift; rewrite node_eq.
      Exists sh' gsh2 (data rep') (next rep') (lock rep') (gnext rep')
        {| data := e'; next := next'; lock := lock'; gnext := g' |}.
      unfold node_data; simpl; entailer!.
      simpl in *; split; [unfold repable_signed; omega|].
      split; [omega|].
      if_tac; auto; omega.
      { apply derives_view_shift, andp_right; auto.
        eapply derives_trans, precise_weak_precise; auto. } }
    forward.
    Intros x; destruct x as (shc', repc').
    Exists shc1 n' rep' ((n', rep') :: (curr, repc') :: nodesa' ++ nodesb'); rewrite !known_nodes_cons.
    unfold node', node_data; Exists gsh1 shc'; entailer!.
    - simpl in *; if_tac; [contradiction|].
      split; split; auto; [do 2 apply incl_tl; apply incl_refl|].
      split; [unfold repable_signed; omega|].
      if_tac; auto; omega.
    - if_tac; [omega | cancel].
      admit.  }
  { forward.
    Exists shc curr repc (nodesa' ++ nodesb'); subst; rewrite !eq_dec_refl; entailer!.
    apply incl_refl. }
  unfold node_data at 2; rewrite lock_inv_isptr; Intros shc' n' rep' nodes'.
  forward.
  forward_call (lock repp, shp, EX p : val, ghost_var gsh2 p (gnext repp)).
  { lock_props.
    Exists n'; cancel. }
  unfold node_data; rewrite (lock_inv_isptr shc'); Intros.
  forward.
  forward_call (lock repc, shc', EX p : val, ghost_var gsh2 p (gnext repc)).
  { lock_props.
    Exists cn; cancel. }
  forward.
  Exists (if eq_dec (data repc) (data rep') then false else true) rep' n'
    ((pred, repp) :: (curr, repc) :: nodes'); rewrite !known_nodes_cons.
  unfold node', node_data; Exists shp shc'; entailer!.
  split.
  - eapply incl_tran; eauto.
    do 2 apply incl_same_head; auto.
  - if_tac; simpl.
    + split; [discriminate|].
      match goal with H : _ /\ _ |- _ => destruct H; subst; auto end.
    + split; tauto.
Admitted.
