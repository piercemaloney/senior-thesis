
Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)
Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)
Require Import lam_ref_mach_lemmas.
(* lam_ref_mach_lemmas:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Lemma isVal_val2exp : forall v, isValue (val_to_exp v).

Lemma closed_dec : forall e n,
  { closed' n e} + { ~closed' n e}.

Lemma value_dec : forall e,
  { isValue e } + { ~isValue e }.

Ltac show_stopped :=
  let m' := fresh "m'" in
  let e' := fresh "e'" in
  let H := fresh "H" in
  right; intros [m' [e' H]]; inv H.

Lemma stopped_dec : forall e m,
  { st | step (m,e) st} + { stopped m e }.

Lemma closed'_S : forall n e,
  closed' n e ->
  closed' (S n) e.

Lemma closed'_le : forall m n,
  m <= n ->
  forall e,
  closed' m e ->
  closed' n e.

Lemma closed'_subst: forall m e x v,
  closed' m e ->
  subst (x + m) v e = e.

Lemma closed_closed_subst: forall x v e,
  closed e ->
  closed (subst x v e).

Lemma closed_Lam_subst: forall e x v,
  closed (Lam e) ->
  subst x v (Lam e) = Lam e.

Lemma subst_env'_Nat: forall rho m n,
  subst_env' m rho (Nat n) = Nat n.

Lemma subst_env'_Loc: forall rho m l,
  subst_env' m rho (Loc l) = Loc l.

Lemma subst_env'_Var': forall n m rho,
  subst_env' (S (n + m)) rho (Var n) = Var n.

Lemma subst_env'_Var: forall rho n v m,
  nth_error rho n = Some v ->
  subst_env' m rho (Var (n + m)) = val_to_exp v.

Lemma subst_env'_New: forall rho m e,
  subst_env' m rho (New e) = New (subst_env' m rho e).

Lemma subst_env'_Deref: forall rho m e,
  subst_env' m rho (Deref e) = Deref (subst_env' m rho e).

Lemma subst_env'_Update: forall rho m e1 e2 e3,
  subst_env' m rho (Update e1 e2 e3) =
  Update (subst_env' m rho e1) (subst_env' m rho e2) (subst_env' m rho e3).

Lemma subst_env_New: forall rho e,
  subst_env rho (New e) = New (subst_env rho e).

Lemma subst_env_Deref: forall rho e,
  subst_env rho (Deref e) = Deref (subst_env rho e).

Lemma subst_env_Update: forall rho e1 e2 e3,
  subst_env rho (Update e1 e2 e3) =
  Update (subst_env rho e1) (subst_env rho e2) (subst_env rho e3).

Lemma subst_env_App : forall env e1 e2,
  subst_env env (App e1 e2) = App (subst_env env e1) (subst_env env e2).

Lemma subst_env_Prim : forall env f e,
  subst_env env (Prim f e) = Prim f (subst_env env e).

Lemma subst_subst_neq : forall e n m v1 v2,
  n <> m ->
  subst n v1 (subst m v2 e) =
  subst m v2 (subst n v1 e).

Lemma subst_env_split : forall env1 env2 n e,
  subst_env' n (env1 ++ env2) e =
  subst_env' n env1 (subst_env' (length env1 + n) env2 e).

Lemma subst_subst_env_lt : forall env n m v e,
  n < m ->
  subst n v (subst_env' m env e) =
  subst_env' m env (subst n v e).

Lemma subst_closed' :
  forall e n v,
    closed' (S n) e ->
    closed' n (subst n v e).

Lemma closed_subst_env : forall env e x n,
   closed' (length env + x) e ->
   closed' (x + n) (subst_env' (x + n) env e).

Lemma closed_step : forall x y ,
  step x y ->
  closed (snd x) ->
  closed (snd y).

Lemma values_stopped: forall e,
  isValue e ->
  forall m,
  stopped m e.

Lemma stopped_New: forall m e,
  stopped m (New e) ->
  stopped m e.

Lemma stopped_Deref: forall m e,
  stopped m (Deref e) ->
  stopped m e.

Lemma stopped_Update: forall m e1 e2 e3,
  stopped m (Update e1 e2 e3) ->
  stopped m e1 \/ (isValue e1 /\ stopped m e2).

Lemma step_deterministic: forall m e m1 e1 m2 e2,
  step (m,e) (m1,e1) ->
  step (m,e) (m2,e2) ->
  m1 = m2 /\ e1 = e2.

Lemma stepn_value: forall j m v st,
  isValue v ->
  stepn j (m, v) st ->
  st = (m, v).

Lemma stepstar_search : forall f m e m' e',
  (forall m e m' e',
    step (m,e) (m',e') -> step (m,f e) (m',f e')) ->
  stepstar (m,e) (m',e') ->
  stepstar (m,f e) (m', f e').

Lemma stepn_trans : forall n m st1 st2 st3,
  stepn n st1 st2 ->
  stepn m st2 st3 ->
  stepn (n+m) st1 st3.

Lemma stepstar_stepn : forall st st',
  stepstar st st' <-> exists n, stepn n st st'. *)
Require Import lam_ref_type_defs.
(* lam_ref_type_defs:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Require Export lam_ref_type_prelim.

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.

Lemma ty_nat_extends :
  boxy extendM ty_nat.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).

Lemma just_extends : forall v,
  %just v = just v.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau. *)

Lemma expr_type_safen: forall k v e tau,
  expr_type e tau (k,v) ->
    forall m, mtype_valid m (k,v) ->
      safen (level k) (m,e).
Proof.
  repeat intro.
  remember (level k) as n.
  revert e k v n' m H H0 Heqn st' H1 H2.
  pattern n; apply (well_founded_induction lt_wf); clear n.
  intros n Hind; intros.
  destruct st'.
  rewrite expr_type_eqn in H.
  spec H (k,v).
  detach H.
  spec H m.
  spec H (k,v) (rt_refl _ age (k,v)).
  spec H H0.
  destruct H.

  inv H2.
  destruct (stopped_dec e0 m0).
  destruct s.
  left; hnf; eauto.
  spec H3 (k,v) (rt_refl _ age (k,v)).
  destruct H3.
  simpl; auto.
  auto.

  destruct st'.
  spec H m1 e1.
  spec H (k,v) (rt_refl _ age (k,v)).
  detach H.
  case_eq (unsquash k); intros.
  rewrite knot_level in H1, Hind.
  rewrite H2 in H1, Hind.
  simpl in H1.
  destruct n.
  inv H1.
  simpl fst in *.
  spec H (squash (n,f),v).
  detach H.
  destruct H as [[k' v'] [? ?]].
  destruct H; subst v'.
  destruct H6.
  eapply Hind.
  instantiate (1:=n).
  omega.
  apply H7.
  apply H6.
  unfold knot_extends in H.
  rewrite unsquash_squash in H.
  case_eq (unsquash k'); intros; rewrite H8 in H.
  destruct H; subst n1.
  rewrite knot_level; auto.
  rewrite H8; simpl; auto.
  2: apply H5.
  auto with arith.
  simpl.
  apply t_step.
  hnf; simpl.
  rewrite knot_age1.
  rewrite H2; auto.
  simpl; auto.

  apply R_extends_refl.
Qed.

Theorem typing_implies_safety: forall e tau,
  Typ nil e tau ->
  safe_prog e.
Proof.
  unfold safe_prog, safe.
  intros.
  rewrite stepstar_stepn in H0.
  destruct H0 as [n H0].
  set (psi := fun l => if le_lt_dec (fst m) l then None else Some TT).
  set (mtype := squash (S n,psi)).
  eapply expr_type_safen.
  destruct H.
  apply (H1 nil (mtype,v_Nat 0) I).
  subst mtype.
  hnf.
  rewrite unsquash_squash.
  cbv beta zeta.
  simpl.
  intros.
  subst psi.
  simpl.
  destruct (le_lt_dec (fst m) a); simpl; auto.
  eauto.
  split; auto.
  intros.
  unfold fidentity_fmap.
  red. rewrite approx_spec.
  hnf; split; auto.
  apply lt_le_trans with (level (fst a')).
  apply laterR_level in H2. auto.
  destruct a'; simpl in H1.
  destruct H1; subst.
  hnf in H1.
  rewrite unsquash_squash in H1.
  simpl; rewrite knot_level.
  case_eq (unsquash m0); intros.
  rewrite H3 in H1.
  destruct H1; subst.
  simpl; eauto.
  hnf. auto.
  instantiate (1:=n).
  subst mtype.
  rewrite knot_level.
  rewrite unsquash_squash; auto.
  auto.
Qed.
