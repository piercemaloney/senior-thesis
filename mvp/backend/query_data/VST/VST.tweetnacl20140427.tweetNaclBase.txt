Require Import Recdef.

Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Local Open Scope logic.

Require Import List. Import ListNotations.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import sha.general_lemmas.
(* sha.general_lemmas:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import compcert.lib.Integers.
Require Import VST.msl.Coqlib2.
Require Import VST.floyd.coqlib3.
Require Import VST.floyd.sublist.
Require Import VST.floyd.functional_base.

Local Open Scope nat.

Fixpoint map2 {A B C: Type} (f: A -> B -> C) (al: list A) (bl: list B) : list C :=
 match al, bl with
  | a::al', b::bl' => f a b :: map2 f al' bl'
  | _, _ => nil
  end.

Lemma length_map2:
 forall A B C (f: A -> B -> C) al bl n,
  length al = n -> length bl = n ->
  length (map2 f al bl) = n.

Lemma list_repeat_injective {A} (a a':A) n: (0<n)%nat ->
      list_repeat n a = list_repeat n a' -> a=a'.

Local Open Scope Z.

Definition roundup (a b : Z) := (a + (b-1))/b*b.

Lemma roundup_minus:
   forall a b,  b > 0 -> roundup a b - a = (- a) mod b.

Definition Shr b x := Int.shru x (Int.repr b).

Lemma byte_testbit:
  forall i j, j >= 8 -> Z.testbit (Byte.unsigned i) j = false.

Fixpoint intlist_to_bytelist (l: list int) : list byte :=
 match l with
 | nil => nil
 | i::r =>
     Byte.repr (Int.unsigned (Shr 24 i)) ::
     Byte.repr (Int.unsigned (Shr 16 i)) ::
     Byte.repr (Int.unsigned (Shr 8 i)) ::
     Byte.repr (Int.unsigned i) ::
     intlist_to_bytelist r
 end.

Definition bytes_to_Int (a b c d : byte) : Int.int :=
  Int.or (Int.or (Int.or 
       (Int.shl (Int.repr (Byte.unsigned a)) (Int.repr 24))
      (Int.shl (Int.repr (Byte.unsigned b)) (Int.repr 16)))
       (Int.shl (Int.repr (Byte.unsigned c)) (Int.repr 8)))
         (Int.repr (Byte.unsigned d)).

Fixpoint bytelist_to_intlist (nl: list byte) : list int :=
  match nl with
  | h1::h2::h3::h4::t => bytes_to_Int h1 h2 h3 h4 :: bytelist_to_intlist t
  | _ => nil
  end.

Hint Rewrite Int.bits_or using omega : testbit.
Hint Rewrite Int.bits_shl using omega : testbit.
Hint Rewrite Int.bits_and using omega : testbit.
Hint Rewrite Int.bits_shru using omega : testbit.
Hint Rewrite Int.unsigned_repr using omega : testbit.
Hint Rewrite Int.testbit_repr using omega : testbit.
Hint Rewrite if_false using omega : testbit.
Hint Rewrite if_true using omega : testbit.
Hint Rewrite Z.ones_spec_low using omega : testbit.
Hint Rewrite Z.ones_spec_high using omega : testbit.
Hint Rewrite orb_false_r orb_true_r andb_false_r andb_true_r : testbit.
Hint Rewrite orb_false_l orb_true_l andb_false_l andb_true_l : testbit.
Hint Rewrite Z.add_simpl_r : testbit.
Hint Rewrite Int.unsigned_repr using rep_omega : testbit.
Hint Rewrite Byte.testbit_repr using rep_omega : testbit.
Hint Rewrite Byte.bits_above using rep_omega : testbit.

Lemma Ztest_Inttest:
 forall a, Z.testbit (Int.unsigned a) = Int.testbit a.
Hint Rewrite Ztest_Inttest : testbit.

Lemma Ztest_Bytetest:
 forall a, Z.testbit (Byte.unsigned a) = Byte.testbit a.
Hint Rewrite Ztest_Bytetest : testbit.

Definition swap (i: int) : int :=
 Int.or (Int.shl (Int.and i (Int.repr 255)) (Int.repr 24))
   (Int.or (Int.shl (Int.and (Shr 8 i) (Int.repr 255)) (Int.repr 16))
      (Int.or (Int.shl (Int.and (Shr 16 i) (Int.repr 255)) (Int.repr 8))
         (Shr 24 i))).

Lemma swap_swap: forall w, swap (swap w) = w.

Lemma map_swap_involutive:
 forall l, map swap (map swap l)  = l.

Lemma length_intlist_to_bytelist:
  forall l, length (intlist_to_bytelist l) = (4 * length l)%nat.

Lemma intlist_to_bytelist_bytes_to_int_cons:
  forall a b c d l,
     intlist_to_bytelist (bytes_to_Int a b c d :: l) =
     a::b::c::d:: intlist_to_bytelist l.

Lemma intlist_to_bytelist_to_intlist:
  forall il: list int,
   bytelist_to_intlist (intlist_to_bytelist il) = il.

Lemma intlist_to_bytelist_app:
 forall al bl, intlist_to_bytelist (al++bl) = intlist_to_bytelist al ++ intlist_to_bytelist bl.
Local Open Scope nat.

Local Open Scope Z.

Lemma int_unsigned_inj: forall a b, Int.unsigned a = Int.unsigned b -> a=b.

Lemma intlist_to_bytelist_inj: forall al bl, intlist_to_bytelist al = intlist_to_bytelist bl -> al=bl.

Lemma Zlength_intlist_to_bytelist_app:
 forall al bl,  Zlength (intlist_to_bytelist (al++bl)) =
    (Zlength (intlist_to_bytelist al) + Zlength (intlist_to_bytelist bl))%Z.

Local Open Scope Z.

Lemma divide_length_app:
 forall {A} n (al bl: list A),
      (n | Zlength al) ->
      (n | Zlength bl) ->
      (n | Zlength (al++bl)).

Lemma nth_list_repeat: forall A i n (x :A),
    nth i (list_repeat n x) x = x.

Lemma map_list_repeat:
  forall A B (f: A -> B) n x,
     map f (list_repeat n x) = list_repeat n (f x). *)



Require Import ZArith.



Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Proof. rewrite Zlength_correct, length_list_repeat; trivial. Qed.



Lemma Zlength_cons' {A} (a:A) l: Zlength (a::l) = 1 + Zlength l.

  do 2 rewrite Zlength_correct. simpl. rewrite Zpos_P_of_succ_nat,<- Z.add_1_l; trivial. Qed.



Lemma isptrD v: isptr v -> exists b ofs, v = Vptr b ofs.

Proof. intros. destruct v; try contradiction. exists b, i; trivial. Qed.



Lemma firstn_Zlength {A} (l:list A) n: (n <= length l)%nat -> Zlength (firstn n l) = Z.of_nat n.

Proof. intros. rewrite Zlength_correct, firstn_length, Min.min_l; trivial. Qed.



Lemma skipn_Zlength {A} (l:list A) n: (n <= length l)%nat -> Zlength (skipn n l) = Zlength l - (Z.of_nat n).

Proof. intros.

       rewrite Zlength_correct, skipn_length.

       rewrite Zlength_correct, Nat2Z.inj_sub; trivial.

Qed.



Lemma map_cons_inv {A B} (f:A -> B) a l fT:

 (f a:: fT) = map f l -> exists b T, l = b :: T /\ f a = f b /\ fT = map f T.

Proof. destruct l; simpl; intros; inv H.

  exists a0, l. auto. Qed.



Lemma inj_le':

  forall n m : nat, (Z.of_nat n <= Z.of_nat m <-> (n <= m)%nat).

Proof. intros. specialize (Z2Nat.inj_le (Z.of_nat n) (Z.of_nat m)). repeat rewrite Nat2Z.id.

  intros X; apply X; clear X. omega. omega.

Qed.

Lemma Byte_max_unsigned_Int_max_unsigned: Byte.max_unsigned < Int.max_unsigned.

  unfold Byte.max_unsigned, Int.max_unsigned. simpl. omega. Qed.



Lemma force_lengthn_map {A B} (f:A->B) n: forall l d fd,

      fd = f d ->

      force_lengthn n (map f l) fd =

      map f (force_lengthn n l d).

Proof.

  induction n; simpl; intros. trivial. subst.

  destruct l; simpl; f_equal. erewrite (IHn nil); reflexivity.

  apply IHn; trivial.

Qed.

Lemma force_lengthn_mapN {A B} (f:A->B) n: forall l d fd,

      (n < length l)%nat ->

      force_lengthn n (map f l) fd =

      map f (force_lengthn n l d).

Proof.

  induction n; simpl; intros. trivial.

  destruct l; simpl in *. omega.

  f_equal. apply IHn; trivial. omega.

Qed.



Lemma In_force_lengthn {A} d u: forall n l, @In A u (force_lengthn n l d) -> In u l \/ u=d.

  Proof. induction n; simpl; intros. contradiction.

    destruct l. destruct H. subst. right; trivial. apply IHn in H. trivial.

    destruct H. left; left; trivial. apply IHn in H. destruct H. left; right; trivial. right; trivial.

  Qed.

Lemma In_force_lengthn_n {A} d u: forall n l (L:(length l >=n)%nat), @In A u (force_lengthn n l d) -> In u l.

  Proof. induction n; simpl; intros. contradiction.

    destruct l; simpl in *. omega.

    destruct H. left; trivial. apply IHn in H. right; trivial. omega.

  Qed.

Lemma In_skipn {A} (u:A): forall n l, In u (skipn n l) -> In u l.

  Proof. Transparent skipn.

    induction n; simpl; intros. apply H.

    destruct l. trivial. apply IHn in H. right; trivial.

Qed.



Lemma nth_force_lengthn':

  forall (A : Type) (n i : nat) (xs : list A) (default d: A) (N: (n < length xs)%nat),

  (0 <= i < n)%nat ->

  @nth A i (@force_lengthn A n xs default) d = @nth A i xs d.

Proof. intros A.

  induction n; simpl; intros. omega.

  destruct xs; simpl in *. omega. destruct i. trivial.

  rewrite IHn. trivial. omega. omega.

Qed.



Lemma app_Znth1: forall (A : Type){d: Inhabitant A} (l l' : list A) (n :Z),

           (n < Zlength l) -> Znth n (l ++ l') = Znth n l.

Proof. intros. unfold Znth. destruct (zlt n 0). trivial.

       apply app_nth1. apply Z2Nat.inj_lt in H.

         rewrite ZtoNat_Zlength in H. trivial.

         omega.

         apply Zlength_nonneg.

Qed.



Lemma app_Znth2: forall (A : Type) {d: Inhabitant A}(l l' : list A) (n : Z),

               (Zlength l <= n) -> Znth n (l ++ l') = Znth (n - Zlength l) l'.

Proof. intros. specialize (Zlength_nonneg l); intros. unfold Znth.

       destruct (zlt n 0). omega.

       destruct (zlt (n - Zlength l) 0).

         destruct (Z.sub_le_mono_r (Zlength l) n (Zlength l)) as [? _].

         specialize (H1 H). rewrite Z.sub_diag in H1. remember (n - Zlength l). clear - l0 H1. omega.

       rewrite app_nth2.

        rewrite Z2Nat.inj_sub, ZtoNat_Zlength; trivial.

        apply Z2Nat.inj_le in H; trivial. rewrite ZtoNat_Zlength in H; trivial. clear - g; omega.

Qed.



Lemma nth_extensional {A}: forall l1 l2 (L:length l1 = length l2) (d:A)

         (N: forall i, (0<=i<length l1)%nat -> nth i l1 d = nth i l2 d), l1=l2.

induction l1; intros.

  destruct l2; simpl in L. trivial. omega.

  destruct l2; simpl in L. omega.

  rewrite (IHl1 l2) with (d:=d).

    specialize (N O). simpl in N. rewrite N; trivial. omega.

    omega.

    intros. apply (N (S i)). simpl; omega.

Qed.



Lemma Znth_extensional {A} {d: Inhabitant A}(l1 l2 : list A):

       Zlength l1 = Zlength l2 -> 

       (forall i,

        (0 <= i < Zlength l1) -> Znth i l1 = Znth i l2) -> l1 = l2.

Proof. intros.

  assert (HH: Z.to_nat (Zlength l1) = Z.to_nat (Zlength l2)).

    rewrite H; trivial.

  do 2 rewrite Zlength_correct, Nat2Z.id in HH.

  eapply nth_extensional with (d0:=d). trivial.

  intros.

  assert (I: 0 <= (Z.of_nat i) < Zlength l1).

    split. apply (Nat2Z.inj_le 0). apply H1. rewrite Zlength_correct. apply Nat2Z.inj_lt. apply H1.

  specialize (H0 _ I). unfold Znth in H0.

  destruct (zlt (Z.of_nat i) 0). omega.

  rewrite Nat2Z.id in H0. trivial.

Qed.



Lemma force_lengthn_app1 {A}{d: Inhabitant A}: forall n l1 l2, length l1 =n -> force_lengthn n (l1 ++ l2) d = l1.

Proof.

  induction n; simpl; intros. destruct l1; simpl in *; trivial. omega.

  destruct l1; simpl in *. omega. rewrite IHn; trivial. omega.

Qed.



Lemma listD16 {A} (l:list A): Zlength l = 16 ->

  exists v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15,

  l = [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12; v13; v14; v15].

Proof. intros.

destruct l. rewrite Zlength_nil in H; omega. exists a. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a0. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a1. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a2. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a3. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a4. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a5. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a6. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a7. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a8. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a9. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a10. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a11. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a12. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a13. rewrite Zlength_cons' in H.

destruct l. rewrite Zlength_nil in H; omega. exists a14. rewrite Zlength_cons' in H.

destruct l; trivial.

rewrite Zlength_cons' in H. specialize (Zlength_nonneg l); intros. omega.

Qed.



Lemma listGE16 {A} (l:list A): 16 <= Zlength l ->

  exists v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 t,

  l = [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12; v13; v14; v15] ++ t

  /\ Zlength t = Zlength l - 16.

Proof. intros.

destruct (listD16 (firstn 16 l)) as

  [v0 [v1 [v2 [v3 [v4 [v5 [v6 [v7 [v8 [v9 [v10 [v11 [v12 [v13 [v14 [v15 V]]]]]]]]]]]]]]]].

  rewrite (Zlength_firstn 16), Z.max_r, Z.min_l; omega.

  exists v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, (skipn 16 l).

  rewrite <- V, firstn_skipn, (Zlength_skipn 16), (Z.max_r 0 16), Z.max_r; try omega.

  split; trivial.

Qed.



Definition bind {A B} (aopt: option A) (f: A -> option B): option B :=

  match aopt with None => None | Some a => f a end.



Section CombineList.

Variable A: Type.

Variable f: A -> A -> A.



Fixpoint combinelist xs ys :=

  match xs, ys with

    nil, nil => Some nil

  | (u::us),(v::vs) => bind (combinelist us vs) (fun l => Some (f u v :: l))

  | _, _ => None

  end.



Lemma combinelist_Zlength: forall xs ys zs,

  combinelist xs ys = Some zs -> Zlength zs = Zlength xs /\ Zlength ys = Zlength xs.

Proof.

  induction xs; intros; destruct ys; simpl in H; inv H.

  split; trivial.

  unfold bind in *.

  remember (combinelist xs ys). symmetry in Heqo.

  destruct o; inv H1. destruct (IHxs _ _ Heqo). repeat rewrite Zlength_cons'.

  rewrite H, H0. split; trivial.

Qed.



Lemma combinelist_Some: forall xs ys, length xs = length ys ->

      exists l, combinelist xs ys = Some l.

Proof.

  induction xs; simpl; intros.

    destruct ys; simpl in *. exists nil; trivial. omega.

  destruct ys; simpl in *. omega.

   inversion H; clear H.

   destruct (IHxs _ H1). rewrite H. simpl. eexists; reflexivity.

Qed.



Lemma combinelist_SomeInv: forall xs ys l, combinelist xs ys = Some l ->

      Zlength xs = Zlength ys.

Proof.

  induction xs; simpl; intros.

    destruct ys; simpl in *. trivial. inversion H.

    destruct ys; simpl in *. inversion H.

    remember (combinelist xs ys). destruct o; symmetry in Heqo; simpl in H.

      inversion H; clear H. apply IHxs in Heqo. do 2 rewrite Zlength_cons'; rewrite Heqo. trivial.

    inversion H.

Qed.



Lemma combinelist_length:

  forall xs ys l, Some l = combinelist xs ys -> length l = length ys.

Proof. induction xs; intros; destruct ys; simpl in *.

  inv H; trivial. inv H. inv H.

  remember (combinelist xs ys) as q. destruct q; simpl in *. inv H. simpl. rewrite (IHxs _ _ Heqq). trivial.

  inv H.

Qed.



Lemma combinelist_symm (C: forall a b, f a b = f b a):

      forall xs ys, combinelist xs ys = combinelist ys xs.

Proof. induction xs; intros.

  destruct ys; simpl; trivial.

  destruct ys; simpl; trivial. rewrite C, IHxs. trivial.

Qed.



Lemma combinelist_char_nth: forall xs ys l, combinelist xs ys = Some l ->

  forall i d, (0 <= i < length l)%nat -> nth i l d = f (nth i xs d) (nth i ys d).

Proof.

  induction xs; simpl; intros.

  destruct ys; inv H; simpl in *. omega.

  destruct ys; inv H; simpl in *.

  remember (combinelist xs ys) as s. symmetry in Heqs.

  destruct s; inv H2. specialize (IHxs _ _ Heqs). simpl in *.

  destruct i; trivial.

  apply IHxs. omega.

Qed.



Lemma combinelist_char_Znth {d: Inhabitant A} xs ys l (C: combinelist xs ys = Some l)

      i (L:0 <= i < Zlength l): Znth i l = f (Znth i xs) (Znth i ys).

Proof.

  unfold Znth.

  destruct (zlt i 0). omega.

  rewrite (combinelist_char_nth _ _ _ C); trivial.

  split. omega. destruct (Z2Nat.inj_lt i (Zlength l)). omega. omega.

  rewrite ZtoNat_Zlength in H; apply H. omega.

Qed.

End CombineList.



Lemma shift_two_8 z:

 match z with

 | 0 => 0

 | Z.pos y' => Z.pos y'~0~0~0~0~0~0~0~0

 | Z.neg y' => Z.neg y'~0~0~0~0~0~0~0~0

 end = (z * two_p 8)%Z.

 destruct z; simpl; trivial. f_equal.

   simpl; xomega.

   simpl; xomega.

Qed.

Lemma shift_two_8_2 z:

  match z with

  | 0 => 0

  | Z.pos y' => Z.pos y'~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0

  | Z.neg y' => Z.neg y'~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0

  end = (z * two_p 8 * two_p 8)%Z.

 destruct z; simpl; trivial. f_equal.

   simpl; xomega.

   simpl; xomega.

Qed.

Lemma shift_two_8_3 z:

  match z with

  | 0 => 0

  | Z.pos y' => Z.pos y'~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0

  | Z.neg y' => Z.neg y'~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0~0

  end = (z * two_p 8 * two_p 8 * two_p 8)%Z.

 destruct z; simpl; trivial. f_equal.

   simpl; xomega.

   simpl; xomega.

Qed.



Fixpoint iterShr8 u n :=

  match n with O => u

   | S n' => Int.shru (iterShr8 u n') (Int.repr 8)

  end.



Lemma Znth_mapVint: forall {d: Inhabitant _} l i, 0<=i< Zlength l -> exists x, Znth i (map Vint l) = Vint x.

Proof. unfold Znth.

  induction l; simpl; intros.

  rewrite Zlength_correct in H; simpl in *. omega.

  destruct (zlt i 0); subst; simpl in *. omega. clear g.

  remember (Z.to_nat i). destruct n. exists a; trivial.

  rewrite Zlength_cons in H.

  destruct (zeq i 0); subst.  simpl in Heqn. omega.

  destruct (IHl (i-1)). omega.

  destruct (zlt (i - 1) 0). subst;  omega.

  rewrite Z2Nat.inj_sub in H0. rewrite <- Heqn in H0. simpl in H0. rewrite <- minus_n_O in H0.

     rewrite H0. exists x; trivial. omega.

Qed.



Lemma app_inj {A}: forall l l'

  (L:Zlength l = Zlength l') (m m':list A) (M: Zlength m = Zlength m'),

  l ++ m = l'++m' -> l=l' /\ m = m'.

Proof. induction l; simpl; intros.

+ destruct l'; simpl in *. subst; split; trivial. 

  rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg l'); omega.

+ destruct l'; simpl. rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg l); omega.

  simpl in *. inv H. 

  assert (LL': Zlength l = Zlength l') by (rewrite 2 Zlength_cons in L; omega).

  destruct (IHl _ LL' _ _ M H2); subst. split; trivial.

Qed.



Lemma list_eq_dec_app {A} (eq_dec: forall x y : A, {x = y} + {x <> y}):

  forall l m l' m'

  (L:Zlength l = Zlength l') (M: Zlength m = Zlength m'),

  ((if list_eq_dec eq_dec (l++m) (l'++m') then true else false) =

  ((if list_eq_dec eq_dec l l' then true else false) &&

   (if list_eq_dec eq_dec m m' then true else false)))%bool.

Proof. 

induction l; intros.

+ destruct l'; simpl; trivial. 

  rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg l'); omega.

+ destruct l'. rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg l); omega.

  assert (LL': Zlength l = Zlength l') by (rewrite 2 Zlength_cons in L; omega).

  specialize (IHl _ _ _ LL' M).

  destruct (eq_dec a a0); subst.

  - destruct (list_eq_dec eq_dec (l ++ m) (l' ++ m')); subst.

    * destruct (app_inj _ _ LL' _ _ M e); subst l' m'.

      rewrite 3 if_true; trivial.

    * if_tac; simpl in H. 

      ++ inv H. contradiction.

      ++ if_tac in IHl; simpl in IHl.

         -- subst l'. rewrite if_true; trivial.

         -- if_tac; trivial. inv H1; congruence.

  - destruct (list_eq_dec eq_dec (l ++ m) (l' ++ m')); subst.

    * destruct (app_inj _ _ LL' _ _ M e); subst l' m'.

      rewrite if_false. rewrite if_false; trivial. congruence.

      simpl; congruence.

    * rewrite if_false. 2: simpl; congruence.

      rewrite if_false; trivial. simpl; congruence.

Qed. 



Lemma combine_app {A B}: forall (l1:list A) (m1:list B) l2 m2 

  (L:Zlength l1 = Zlength m1) (M: Zlength l2 = Zlength m2),

  combine (l1 ++ l2) (m1 ++ m2) = combine l1 m1 ++ combine l2 m2.

Proof.

induction l1; intros.

+ destruct m1; simpl; trivial. 

  rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg m1); omega.

+ destruct m1. rewrite Zlength_nil, Zlength_cons in L. specialize (Zlength_nonneg l1); omega.

  assert (LL': Zlength l1 = Zlength m1) by (rewrite 2 Zlength_cons in L; omega).

  specialize (IHl1 _ _ _ LL' M). simpl. f_equal; trivial.

Qed.



Lemma Byte_zero_ext_8 b: Byte.zero_ext 8 b = b.

 apply Byte.same_bits_eq; intros.

 rewrite Byte.bits_zero_ext by omega. if_tac; trivial.

 replace Byte.zwordsize with 8 in H by reflexivity. omega.

Qed.



Lemma Byte_Int_max_unsigned: Byte.max_unsigned < Int.max_unsigned.

Proof. cbv; trivial. Qed.



Lemma byte_unsigned_range_int_unsigned_max x: 0 <= Byte.unsigned x <= Int.max_unsigned.

Proof. destruct (Byte.unsigned_range_2 x). specialize Byte_Int_max_unsigned; omega. Qed.



Lemma Zlxor_of_byte_range x y: 0 <= Z.lxor (Byte.unsigned x) (Byte.unsigned y) <= Byte.max_unsigned.

Proof.

 destruct (Byte.unsigned_range x).

 destruct (Byte.unsigned_range y).

 split; apply Byte.Ztestbit_le.

 + apply Z.lxor_nonneg. omega.

 + intros. destruct i; discriminate.

 + unfold Byte.max_unsigned. simpl; omega.

 + intros. unfold Byte.max_unsigned. simpl. rewrite Z.lxor_spec in H4.

   unfold xorb in H4.

   specialize (Byte.Ztestbit_two_p_m1 8 i); simpl. intros X; rewrite X; clear X; try omega.

   destruct (zlt i 8); trivial.

   rewrite 2 (Byte.Ztestbit_above 8) in H4. discriminate.

   apply Byte.unsigned_range. simpl; omega.

   apply Byte.unsigned_range. simpl; omega.

Qed.



Lemma unsigned_xor_Byte_Int xi yi: Byte.unsigned (Byte.xor xi yi) =

      Int.unsigned (Int.xor (Int.repr (Byte.unsigned xi)) (Int.repr (Byte.unsigned yi))).

Proof.

  unfold Int.xor, Byte.xor.

  rewrite (Int.unsigned_repr (Byte.unsigned xi)) by apply byte_unsigned_range_int_unsigned_max.

  rewrite (Int.unsigned_repr (Byte.unsigned yi)) by apply byte_unsigned_range_int_unsigned_max.

  rewrite Int.unsigned_repr, Byte.unsigned_repr; trivial. apply Zlxor_of_byte_range.

  destruct (Zlxor_of_byte_range xi yi). specialize Byte_Int_max_unsigned; omega.

Qed.



Lemma Z_lxor_byte_neq b1 b2 (B:b1 <> b2): exists b, 

      Z.lxor (Byte.unsigned b1) (Byte.unsigned b2) = Byte.unsigned b /\ b <> Byte.zero.

Proof.

  exists (Byte.xor b1 b2); split. 2: intros N; apply Byte.xor_zero_equal in N; contradiction.

  apply Byte.equal_same_bits; intros.

  destruct (zlt i 8).

  + unfold Byte.xor. rewrite Byte.unsigned_repr; trivial. apply Zlxor_of_byte_range. 

  + rewrite ! (Byte.Ztestbit_above 8); simpl; trivial; try omega. apply Byte.unsigned_range.

    specialize (Zlxor_of_byte_range b1 b2). 

    replace (two_power_nat 8) with 256 by reflexivity.

    replace Byte.max_unsigned with 255 by reflexivity. omega.

Qed.



Lemma Zlor_of_byte_range x y: 0 <= Z.lor (Byte.unsigned x) (Byte.unsigned y) <= Byte.max_unsigned.

Proof. 

 destruct (Byte.unsigned_range x).

 destruct (Byte.unsigned_range y).

 split.

+ apply Byte.Ztestbit_le.

  - apply Z.lor_nonneg. omega.

  - destruct i; discriminate.

+ unfold Byte.max_unsigned. simpl.

  apply Byte.Ztestbit_le. omega. intros.

  rewrite Z.lor_spec in H4. 

  destruct (zlt i 8 ).

  - destruct (zeq i 0). subst; reflexivity. 

    destruct (zeq i 1). subst; reflexivity. 

    destruct (zeq i 2). subst; reflexivity. 

    destruct (zeq i 3). subst; reflexivity. 

    destruct (zeq i 4). subst; reflexivity. 

    destruct (zeq i 5). subst; reflexivity. 

    destruct (zeq i 6). subst; reflexivity. 

    destruct (zeq i 7). subst; reflexivity. omega.  

  - rewrite 2 (Byte.Ztestbit_above 8) in H4; try discriminate; simpl; try omega; apply Byte.unsigned_range.

Qed. 



Lemma Zlor_Byteor b1 b2: Z.lor (Byte.unsigned b1) (Byte.unsigned b2) = Byte.unsigned (Byte.or b1 b2).

Proof. unfold Byte.or. rewrite Byte.unsigned_repr; trivial. apply Zlor_of_byte_range. Qed.



Lemma ByteOr_zero b1 b2 (B: Byte.or b1 b2 = Byte.zero): b1=Byte.zero /\ b2=Byte.zero.

Proof.

  specialize (Byte.bits_or b1 b2); intros. rewrite B in H; clear B.

  assert (forall i, 0 <= i < Byte.zwordsize -> (Byte.testbit b1 i = false /\ Byte.testbit b2 i = false)).

  + intros. specialize (H _ H0). rewrite Byte.bits_zero in H. symmetry in H. 

    apply orb_false_iff in H; trivial.

  + clear H. split; apply Byte.same_bits_eq; intros; rewrite Byte.bits_zero; apply (H0 _ H).

Qed.

