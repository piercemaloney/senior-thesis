Load loadpath.

Require Import Coq.Lists.List Permutation veric.Coqlib2.

Require Import VST.msl.Axioms msl.sepalg VST.msl.predicates_sa msl.base
(* VST.msl.Axioms:
Require Coq.Logic.ClassicalFacts.

Require Export Coq.Logic.FunctionalExtensionality.

Lemma extensionality:
  forall (A B: Type) (f g : A -> B),  (forall x, f x = g x) -> f = g.

Arguments extensionality [A B] _ _ _.

Axiom prop_ext: ClassicalFacts.prop_extensionality.
Arguments prop_ext [A B] _.

Lemma proof_irr: ClassicalFacts.proof_irrelevance.
Proof.
  exact (ClassicalFacts.ext_prop_dep_proof_irrel_cic prop_ext).
Arguments proof_irr [A] _ _. *)
(* msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)
(* VST.msl.predicates_sa:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.

Require Import Coq.funind.Recdef.
Require Coq.Wellfounded.Wellfounded. 
Delimit Scope pred with pred.
Local Open Scope pred.

Definition pred (A:Type) := A -> Prop.
Bind Scope pred with pred.

Definition derives (A:Type) (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] _ _.

Lemma pred_ext : forall A (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma derives_cut {A}  : forall Q P R : pred A,
  derives P Q ->
  derives Q R ->
  derives P R.

Definition prop {A: Type}  (P: Prop) : pred A := (fun _  => P).
Hint Unfold prop.

Definition TT {A}: pred A := prop True.
Definition FF  {A}: pred A := prop False.

Set Implicit Arguments.

Definition imp {A}  (P Q:pred A) :=
   fun a:A => P a -> Q a.
Definition orp {A} (P Q:pred A) :=
   fun a:A => P a \/ Q a.
Definition andp {A} (P Q:pred A) :=
   fun a:A => P a /\ Q a.

Definition allp {A B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.
Definition exp {A B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Notation "'emp'" := identity.

Definition sepcon {A} {JA: Join A}(p q:pred A) := fun z:A =>
  exists x:A, exists y:A, join x y z /\ p x /\ q y.
Definition wand {A}  {JA: Join A}  (p q:pred A) := fun y =>
  forall x z, join x y z -> p x -> q z.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.
Notation "P '*' Q" := (sepcon P Q) : pred.
Notation "P '-*' Q" := (wand P Q) (at level 60, right associativity) : pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Definition precise {A}  {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall w w1 w2, P w1 -> P w2 -> join_sub w1 w -> join_sub w2 w -> w1=w2.

Definition precise2  {A} {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=
     forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma precise_eq {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     precise =
                 fun P : pred A => forall Q R, P * (Q && R) = (P * Q) && (P * R).

Lemma derives_precise {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q, (P |-- Q) -> precise Q -> precise P.

Lemma prop_true_and:
  forall (P: Prop) A (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_andp_e {A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A}:  forall P Q (w:A), P /\ Q w -> (!! P && Q) w.

Lemma derives_trans {A}:  forall (P Q R: pred A), P |-- Q -> Q |-- R -> P |-- R.

Lemma and_i {A}: forall (P Q R: pred A),
    P |-- Q -> P |-- R -> P |-- Q && R.

Lemma andp_derives {A}  :
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q r, (((p * q) * r) = (p * (q * r))).

Lemma sepcon_comm {A} {JA: Join A}{PA: Perm_alg A}:  forall (P Q: pred A) , P * Q = Q * P.

Lemma sepcon_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall P, (P * emp) = P.

Lemma emp_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, (emp*P) = P.

Lemma precise_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     precise emp.

Definition exactly {A} (x: A) : pred A := fun w => w=x.

Lemma join_exactly {A} {JA: Join A}{PA: Perm_alg A}:
  forall w1 w2 w3, join w1 w2 w3 -> exactly w1 * exactly w2 = exactly w3.

Lemma exists_and1 {A: Type} : forall {T: Type} (P: T -> pred A) (Q: pred A),
                   exp P && Q = EX x:T, P x && Q.

Lemma andp_comm {A: Type}: forall (P Q: pred A), P && Q = Q && P.

Lemma andp_assoc {A}: forall (P Q R: pred A),
                 ((P && Q) && R = P && (Q && R)).

Lemma True_andp_eq {A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma TT_i  {A} : forall w: A,  TT w.

Hint Resolve @TT_i.

Lemma TT_and {A}: forall (Q: pred A), TT && Q = Q.

Lemma andp_TT {A}: forall (P: pred A), P && TT = P.

Lemma emp_wand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall P, emp -* P = P.

Lemma wand_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall P P' Q Q',  P' |-- P -> Q |-- Q' -> P -* Q |-- P' -* Q'.

Lemma TT_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: TT * TT = TT.

Definition ewand {A} {JA: Join A} (P Q: pred A) : pred A :=
  fun w => exists w1, exists w2, join w1 w w2 /\ P w1 /\ Q w2.

Lemma emp_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:  forall P, ewand emp P = P.

Lemma exists_sepcon1 {A} {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  exp P * Q = exp (fun x => P x * Q).

Lemma derives_refl {A: Type}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma derives_TT {A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma sepcon_derives {A} {JA: Join A}{PA: Perm_alg A}:
  forall p q p' q', (p |-- p') -> (q |-- q') -> (p * q |-- p' * q').

Lemma derives_e {A: Type}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Lemma exp_derives {A} :
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma unmodus_wand {A}  {JA: Join A}{PA: Perm_alg A}:
 forall P Q R, Q = P * R ->  Q |-- P * (P -* Q).

Definition superprecise {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} (P: pred A) :=
   forall w1 w2, P w1 -> P w2 -> comparable w1 w2 -> w1=w2.

Lemma modus_ewand {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} :  forall P Q, superprecise P -> P * (ewand P Q) |-- Q.

Lemma exists_expand_sepcon {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B (p: B -> pred A) q, (exp p * q)%pred = (exp (fun x => p x * q))%pred.

Lemma exists_expand_sepcon' {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall B p (q: B -> pred A), (p * exp q)%pred = (exp (fun x => p * q x))%pred.

Lemma exists_expand_and {A}  {JA: Join A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exists_expand_and' {A} {JA: Join A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma allp_derives_right {A} : forall B p (q: B -> pred A),
  ((p |-- allp q) <-> (forall x, p |-- q x)).

Lemma wand_exists {A} {JA: Join A}{PA: Perm_alg A}:
   forall B P Q,  (EX x: B, P -* Q x) |-- (P -* EX x : B, Q x).

Lemma modus_wand {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q,  P * (P -* Q) |-- Q.

Lemma distrib_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}:
  forall P Q R, P * (Q && R) |-- (P * Q) && (P * R).

Lemma andp_r {A: Type} : forall (P Q R: pred A), P |-- Q -> P |-- R -> P |-- Q && R.

Definition list_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : list (pred A) -> pred A := fold_right sepcon emp.

Lemma sepcon_andp_prop {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R, P * (!!Q && R) = !!Q && (P * R).

Require Import VST.msl.cross_split.

Lemma exactly_i {A} : forall x: A, exactly x x.
Hint Resolve @exactly_i.

Lemma superprecise_exactly {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x, superprecise (exactly x).
Hint Resolve @superprecise_exactly.

Lemma find_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     Cross_alg A ->
     forall S P Q R, (S * P) && (Q * R) |--
                          EX SQ:_, EX SR:_, EX PQ:_, EX PR:_,
                            (((SQ* SR) && S)*((PQ* PR) && P)) &&
                            (((SQ* PQ) && Q)*((SR* PR) && R)) &&
                            !! (superprecise SQ /\ superprecise SR /\ superprecise PQ /\ superprecise PR).

Lemma modus_ponens {A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma and_intro {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma and1 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A}  : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A}  : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A}  : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A}  : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A}  : forall X (P: pred A),
  X |-- P --> TT.

Lemma FFrule {A}  : forall X (P: pred A),
  X |-- FF --> P.

Lemma distribution {A}  : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma wand_sepcon_adjoint {A} {JA: Join A}{PA: Perm_alg A} : forall (P Q R:pred A),
  ((P * Q) |-- R) = (P |-- (Q -* R)).

Lemma ewand_sepcon {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R,
      (ewand (P * Q) R = ewand P (ewand Q R))%pred.

Lemma andp_right {A}  : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

Lemma andp_left1{A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma exp_right:
  forall {B A: Type}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma allp_right {B A: Type}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma imp_andp_adjoint {A}  : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma exp_andp1 {A} :
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_sepcon1 {A}  {JA: Join A}{PA: Perm_alg A}:
  forall T (P: T ->  pred A) Q,  (exp P * Q = exp (fun x => P x * Q))%pred.

Definition pure {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}
     (P: pred A) : Prop :=
   P |-- emp.

Lemma sepcon_pure_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall P Q, pure P -> pure Q -> ((P * Q) = (P && Q)).

Lemma pure_sepcon_TT_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall P Q, pure P -> (P * TT) && Q = (P*Q).

Lemma ewand_conflict {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
       forall P Q R, sepcon P Q |-- FF -> andp P (ewand Q R) |-- FF.

Lemma ewand_TT_sepcon {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:
      forall P Q R,
(P * Q && ewand R (!!True))%pred |-- (P && ewand R (!!True) * (Q && ewand R (!!True)))%pred. *)
(* msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

               veristar.variables veristar.datatypes

               veristar.clauses veristar.basic veristar.compare.



Section ListDenote.

Context {A T : Type}.

Variables (f : A -> T) (g : T -> T -> T) (b : T).



Fixpoint list_denote l : T :=

  match l with nil => b | x :: l' => g (f x) (list_denote l')

  end.



Local Notation "'listd'" := (list_denote).



Lemma listd_fold_right l :

  listd l = fold_right (fun x y  => g (f x) y) b l.

Proof. intros; induction l; simpl; intros; auto. Qed.



End ListDenote.



Notation "'listd'" := (list_denote).



Lemma listd_app {A T} f g (b : T) (l l' : list A) :

  listd f g b (l ++ l') =

  listd f g (listd f g b l') l.

Proof.

intros; do 3 rewrite listd_fold_right; apply fold_right_app.

Qed.



Section ListDenoteLems.

Context {A T : Type}.

Variables (f : A -> T) (g : T -> T -> T) (b : T).



Lemma listd_nil : listd f g b nil = b.

Proof. auto. Qed.



Lemma listd_cons a l :

  listd f g b (a :: l) = g (f a) (listd f g b l).

Proof. auto. Qed.



Lemma listd_map h l (Hgh_eq : forall a b', g (f (h a)) b' = g (f a) b') :

  listd f g b (map h l) = listd f g b l.

Proof with auto. induction l; simpl; intros... rewrite IHl, Hgh_eq... Qed.



Lemma listd_filter h l (H : forall a b', false=h a -> g (f a) b' = b') :

  listd f g b (filter h l) = listd f g b l.

Proof with auto.

induction l; simpl...

remember (h a) as b'; destruct b'; simpl. rewrite IHl... rewrite IHl, H...

Qed.



Lemma listd_flat_map h l (H : forall a b', g (f a) b' = listd f g b' (h a)) :

  listd f g b l = listd f g b (flat_map h l).

Proof with auto.

induction l; simpl... rewrite IHl, listd_app; apply H.

Qed.



Lemma listd_compose h1 h2 l

  (Hh1 : forall l, listd f g b l = listd f g b (h1 l))

  (Hh2 : forall l, listd f g b l = listd f g b (h2 l)) :

  listd f g b l = listd f g b ((h1 oo h2) l).

Proof. unfold compose; rewrite <- Hh1, Hh2; auto. Qed.



End ListDenoteLems.



Section ListDenoteAS.

Context {A T : Type}.

Variables (f : A -> T) (g : T -> T -> T) (b : T).

Variable (gS : forall x y, g x y = g y x).

Variable (gA : forall x y z, g x (g y z) = g (g x y) z).



Lemma fgAS b' (t t' : T) : g t (g t' b') = g t' (g t b').

Proof with auto. rewrite gA, gS; pattern (g t t'); rewrite gS, gS, gA... Qed.



Lemma listdAS a l : listd f g (g (f a) b) l = g (f a) (listd f g b l).

Proof with auto.

revert a; induction l; simpl; intro a'... rewrite IHl, fgAS...

Qed.



Lemma listd_AS_unit un l (un_unit : forall x, g x un = x) :

  listd f g b l = g b (listd f g un l).

Proof with auto. induction l; simpl... rewrite IHl, fgAS... Qed.



Lemma listd_perm l l' (Hperm : Permutation l l') :

  listd f g b l = listd f g b l'.

Proof with auto.

intros; induction Hperm; simpl... rewrite IHHperm...

do 2 rewrite gA; pattern (g (f y) (f x)); rewrite gS...

transitivity (listd f g b l')...

Qed.



End ListDenoteAS.



Section ListDenoteConj.

Context {A : Type}.

Variables (f : A -> Prop) (g : Prop -> Prop -> Prop) (b : Prop).

Variable (gconj : forall x y, g x y -> y).



Lemma listd_conj a l : listd f g b (a :: l) -> listd f g b l.

Proof. apply gconj. Qed.



Context {B : Type}.

Variables (h : A -> pred B) (k : pred B -> pred B -> pred B) (b0 : pred B).

Variable (hconj : forall x y b, k x y b -> y b).



Lemma listd_conjP a l : forall b, listd h k b0 (a :: l) b -> listd h k b0 l b.

Proof. apply hconj. Qed.



End ListDenoteConj.



Section ListDenoteProp.

Context {A : Type}.

Variables (f : A -> Prop) (b : Prop).



Lemma andS (x y : Prop) : and x y = and y x.

Proof. apply prop_ext; intuition. Qed.



Lemma andA x y z : and x (and y z) = and (and x y) z.

Proof. apply prop_ext; intuition.  Qed.



Lemma orS (x y : Prop) : or x y = or y x.

Proof. apply prop_ext; apply or_comm. Qed.



Lemma orA x y z : or x (or y z) = or (or x y) z.

Proof. apply prop_ext; rewrite <- or_assoc; split; auto. Qed.



Lemma listd_conj_and a l : listd f and True (a :: l) -> listd f and True l.

Proof. apply listd_conj; auto. intros x y [hx hy]; auto. Qed.



Lemma listd_unfold_and l : listd f and b l = (listd f and True l /\ b).

Proof with auto.

induction l; simpl... apply prop_ext; split; tauto.

apply prop_ext; split; simpl; rewrite IHl; tauto.

Qed.



Lemma listd_unfold_or l : listd f or b l = (listd f or False l \/ b).

Proof with auto.

induction l; simpl... apply prop_ext; split; tauto.

apply prop_ext; split; simpl; rewrite IHl; tauto.

Qed.



Lemma listd_flat_map_and h l

  (H : forall a b', and (f a) b' -> listd f and b' (h a)) :

  listd f and b l -> listd f and b (flat_map h l).

Proof with auto.

induction l; simpl... intros [B C]. specialize (H a _ (conj B (IHl C))).

solve [rewrite listd_app; auto].

Qed.



Lemma listd_In_prop l : (forall a, In a l -> f a) -> listd f and True l.

Proof with simpl; try solve[exfalso; auto]; auto. induction l... Qed.



Lemma listd_In_inv_prop a l : listd f and True l -> In a l -> f a.

Proof with try solve[exfalso; auto]; auto.

revert a; induction l; simpl; intros a' C D...

destruct D as [D|D]; [rewrite <- D|].

solve [destruct C as [C1 C2]; auto]. solve[destruct C; apply IHl; auto].

Qed.



End ListDenoteProp.



Section ListDenoteProp1.

Context {A : Type}.

Variables (f : A -> Prop).



Lemma listd_unfold_app_and b l l' :

  listd f and b (l ++ l') = (listd f and True l /\ listd f and b l').

Proof with auto. rewrite listd_app, listd_unfold_and... Qed.



Lemma listd_unfold_app_or b l l' :

  listd f or b (l ++ l') = (listd f or False l \/ listd f or b l').

Proof with auto. rewrite listd_app, listd_unfold_or... Qed.



End ListDenoteProp1.



Lemma union_com {A} : forall (P Q: pred A), ((P || Q) = (Q || P))%pred.

Proof.

intros; extensionality w.

unfold orp; apply prop_ext; intuition.

Qed.



Lemma union_assoc {A} : forall (P Q R: pred A),

  ((P || Q) || R = P || (Q || R))%pred.

Proof.

intros; extensionality w.

unfold orp; apply prop_ext; intuition.

Qed.



Notation "'inter'" := (@andp _).

Notation "'un'" := (@orp _).



Section ListDenotePred.

Context {A B : Type}.

Variables (f : A -> pred B) (b : pred B).



Lemma listd_conj_inter a l :

  forall b', listd f inter TT (a :: l) b' -> listd f inter TT l b'.

Proof. intro b'; apply listd_conjP. intros x y b0 [H1 H2]; auto. Qed.



Lemma listd_unfold_inter l : listd f inter b l = (listd f inter TT l && b)%pred.

Proof with auto.

induction l; simpl... apply extensionality; intro x.

apply prop_ext; split; intro H. split... destruct H...

rewrite IHl, andp_assoc...

Qed.



Lemma listd_unfold_un l : listd f un b l = (listd f un FF l || b)%pred.

Proof with auto.

induction l; simpl... apply extensionality; intro x.

apply prop_ext; split; intro H. right... destruct H... inversion H.

rewrite IHl, union_assoc...

Qed.



Lemma listd_flat_map_inter h l s

  (H : forall a b', inter (f a) b' s -> listd f inter b' (h a) s) :

  listd f inter b l s -> listd f inter b (flat_map h l) s.

Proof with auto.

induction l; simpl... intros [C D].

solve[rewrite listd_app; apply H; split; auto].

Qed.



Lemma listd_In_pred l s :

  (forall a, In a l -> f a s) -> b s -> listd f inter b l s.

Proof with simpl; try solve[exfalso; auto]; auto.

induction l... intro C; split; [ solve [apply (C a); left; auto] | ].

apply IHl...

Qed.



Lemma listd_In_inv_pred a l s : listd f inter TT l s -> In a l -> f a s.

Proof with try solve[exfalso; auto]; auto.

revert a; induction l; simpl; intros a' C D...

destruct D as [D|D]; [rewrite <- D|].

solve [destruct C as [C1 C2]; auto]. solve[destruct C; apply IHl; auto].

Qed.



Lemma listd_In_pred_un l s :

  (exists a, In a l /\ f a s) \/ b s -> listd f un b l s.

Proof with simpl; try solve[exfalso; auto|congruence]; auto.

induction l... intros [[a [C D]]|E]... intros [[a0 [C D]]|E]...

destruct C; subst. left... right; apply IHl; eauto.

right; eapply IHl...

Qed.



Lemma listd_In_inv_pred_un l s :

  listd f un b l s -> (exists a, In a l /\ f a s) \/ b s.

Proof with try solve[exfalso; auto|congruence]; auto.

induction l... destruct 1. left; exists a; split; simpl...

spec IHl H. destruct IHl as [[a0 [C D]]|E].

left; exists a0; split; simpl... right...

Qed.



Lemma listd_map_pred {C : Type} h (g : C -> pred B) l s

  (H : forall a, f a s -> g (h a) s) :

  listd f inter TT l s -> listd g inter TT (map h l) s.

Proof with try solve [exfalso; auto]; auto.

induction l... simpl; intros [? ?]; split...

Qed.



Lemma listd_omapl_pred {C : Type} h (g : C -> pred B) l s

  (H : forall a, f a s -> match h a with Some a' => g a' s | None => True end) :

  listd f inter TT l s -> listd g inter TT (omapl h l) s.

Proof with simpl; try solve [exfalso; auto]; auto.

induction l... simpl; intros [? ?]. spec H a. destruct (h a)... split...

Qed.



Lemma listd_foldr_pred h c0 l s

  (H : forall a x, f a s -> f x s -> f (h a x) s) :

  f c0 s -> listd f inter TT l s -> f (fold_right h c0 l) s.

Proof with try solve [exfalso; auto]; auto.

revert c0 H; induction l... simpl; intros c0 H C [D E]. apply H...

Qed.



Lemma listd_foldl_pred h c0 l s

  (H : forall a x, f a s -> f x s -> f (h x a) s) :

  f c0 s -> listd f inter TT l s -> f (fold_left h l c0) s.

Proof with try solve [exfalso; auto]; auto.

revert c0 H; induction l... simpl; intros c0 H C [D E]; apply IHl...

Qed.



Lemma listd_filter_pred h l s :

  listd f inter TT l s -> listd f inter TT (filter h l) s.

Proof with try solve [exfalso; auto]; auto.

induction l... simpl. intros [H1 H2]. if_tac... simpl... split...

Qed.



Lemma listd_partition_pred h l xs ys s (H : partition h l = (xs, ys)) :

  listd f inter TT l s ->

    listd f inter TT xs s /\ listd f inter TT ys s.

Proof with try solve [exfalso; auto]; auto.

revert xs ys H; induction l... simpl. inversion 1; auto.

intros xs ys; simpl; intros H1 [H2 H3].

remember (partition h l) as c. destruct c. destruct (h a); inversion H1; subst.

spec IHl l0 ys. destruct IHl... split; auto. split; auto.

spec IHl xs l1. destruct IHl... split; auto. split; auto.

Qed.



End ListDenotePred.



Section ListDenotePred1.

Context {A B : Type}.

Variables (f : A -> pred B).



Lemma listd_unfold_app_inter b l l' :

  listd f inter b (l ++ l') = (listd f inter TT l && listd f inter b l')%pred.

Proof with auto. rewrite listd_app, listd_unfold_inter... Qed.



Lemma listd_unfold_app_un b l l' :

  listd f un b (l ++ l') = (listd f un FF l || listd f un b l')%pred.

Proof with auto. rewrite listd_app, listd_unfold_un... Qed.



End ListDenotePred1.



Section ListDenoteInsert.

Context {A T : Type}.

Variables (f : A -> T) (g : T -> T -> T) (b : T).

Variable (gS : forall x y, g x y = g y x).

Variable (gA : forall x y z, g x (g y z) = g (g x y) z).



Lemma listd_insert cmp a l :

  listd f g b (insert cmp a l) = g (f a) (listd f g b l).

Proof with auto.

rewrite listd_perm with (l' := (a :: l))... apply perm_insert.

Qed.



Lemma listd_sort cmp l : listd f g b (rsort cmp l) = listd f g b l.

Proof with auto.



induction l... simpl. rewrite <- IHl. apply listd_insert.

Qed.



End ListDenoteInsert.



Section ListDenoteInsertUniq.

Context {A T : Type}.

Variables (f : A -> T) (g : T -> T -> T) (b : T).

Variable (gS : forall x y, g x y = g y x).

Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Variable (cmp : A -> A -> comparison).

Variable (Hcmp : forall x y, Eq = cmp x y ->

  forall b, g (f x) (g (f y) b) = g (f y) b).



Lemma listd_insert_uniq a l :

  listd f g b (insert_uniq cmp a l) = g (f a) (list_denote f g b l).

Proof with auto.

induction l; simpl...

remember (cmp a a0) as d; destruct d; simpl... rewrite Hcmp...

rewrite IHl... rewrite fgAS...

Qed.



Lemma listd_sort_uniq l : listd f g b (rsort_uniq cmp l) = listd f g b l.

Proof with auto.

induction l... simpl. rewrite <-IHl. rewrite listd_insert_uniq...

Qed.



End ListDenoteInsertUniq.



Section ListDenoteSortProp.

Context {A : Type}.

Variable (f : A -> Prop) (b : Prop).



Local Hint Resolve andS andA orS orA.



Lemma listd_insert_and cmp a l :

  listd f and b (insert cmp a l) = and (f a) (listd f and b l).

Proof. apply listd_insert; auto. Qed.



Lemma list_sort_and cmp l :

  listd f and b (rsort cmp l) = listd f and b l.

Proof. apply listd_sort; auto. Qed.



Lemma listd_insert_or cmp a l :

  listd f or b (insert cmp a l) = or (f a) (listd f or b l).

Proof. apply listd_insert; auto. Qed.



Lemma listd_sort_or cmp l :

  listd f or b (rsort cmp l) = listd f or b l.

Proof. apply listd_sort; auto. Qed.



End ListDenoteSortProp.



Section ListDenoteInsertPred.



Context {A B : Type}.

Variable (f : A -> pred B) (b : pred B).



Lemma interS (x y : pred B) : inter x y = inter y x.

Proof. apply andp_comm. Qed.



Lemma interA (x y z : pred B) : inter x (inter y z) = inter (inter x y) z.

Proof. rewrite andp_assoc; auto. Qed.



Lemma unS (x y : pred B) : un x y = un y x.

Proof. apply union_com. Qed.



Lemma unA (x y z : pred B) : un x (un y z) = un (un x y) z.

Proof. rewrite union_assoc; auto. Qed.



Variables (JB: Join B) (PB: Perm_alg B)(SB: Sep_alg B).



Lemma sepconS (x y : pred B) : sepcon x y = sepcon y x.

Proof. apply sepcon_comm. Qed.



Lemma sepconA (x y z : pred B) :

  sepcon x (sepcon y z) = sepcon (sepcon x y) z.

Proof. rewrite sepcon_assoc; auto. Qed.



Local Hint Resolve interS interA unS unA sepconS sepconA.



Lemma listd_insert_inter cmp a l :

  listd f inter b (insert cmp a l) = inter (f a) (listd f inter b l).

Proof. apply listd_insert; auto. Qed.



Lemma listd_sort_inter cmp l :

  listd f inter b (rsort cmp l) = listd f inter b l.

Proof. apply listd_sort; auto. Qed.



Lemma listd_insert_un cmp a l :

  listd f un b (insert cmp a l) = un (f a) (listd f un b l).

Proof. apply listd_insert; auto. Qed.



Lemma listd_sort_un cmp l : listd f un b (rsort cmp l) = listd f un b l.

Proof. apply listd_sort; auto. Qed.



Lemma listd_insert_sepcon cmp a l :

  listd f sepcon b (insert cmp a l) = sepcon (f a) (listd f sepcon b l).

Proof. apply listd_insert; auto. Qed.



Lemma listd_sort_sepcon cmp l :

  listd f sepcon b (rsort cmp l) = listd f sepcon b l.

Proof. apply listd_sort; auto. Qed.



End ListDenoteInsertPred.



Section ListDenoteSortUniqProp.

Context {A : Type}.

Variables (f : A -> Prop) (b : Prop).

Variable (cmp : A -> A -> comparison).

Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).



Local Hint Resolve andS andA orS orA.



Lemma listd_insert_uniq_and a l :

  listd f and b (insert_uniq cmp a l) = and (f a) (listd f and b l).

Proof.

apply listd_insert_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H); apply prop_ext; split; tauto.

Qed.



Lemma list_sort_uniq_and l :

  listd f and b (rsort_uniq cmp l) = listd f and b l.

Proof.

apply listd_sort_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H); apply prop_ext; split; tauto.

Qed.



Lemma listd_insert_uniq_or a l :

  listd f or b (insert_uniq cmp a l) = or (f a) (listd f or b l).

Proof.

apply listd_insert_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H); apply prop_ext; split; tauto.

Qed.



Lemma listd_sort_uniq_or l :

  listd f or b (rsort_uniq cmp l) = listd f or b l.

Proof.

apply listd_sort_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H); apply prop_ext; split; tauto.

Qed.



End ListDenoteSortUniqProp.



Section ListDenoteSortUniqPreds.

Context {A B : Type}.

Variables (f : A -> pred B) (b : pred B).

Variable (cmp : A -> A -> comparison).

Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).



Local Hint Resolve (@interS B) (@interA B) (@unS B) (@unA B).



Lemma listd_insert_uniq_inter a l :

  listd f inter b (insert_uniq cmp a l) = inter (f a) (listd f inter b l).

Proof.

apply listd_insert_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H).

apply extensionality; intros ?; apply prop_ext; split;

  unfold andp; tauto.

Qed.



Lemma listd_sort_uniq_inter l :

  listd f inter b (rsort_uniq cmp l) = listd f inter b l.

Proof.

apply listd_sort_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H).

apply extensionality; intros ?; apply prop_ext; split;

  unfold andp; tauto.

Qed.



Lemma listd_insert_uniq_un a l :

  listd f un b (insert_uniq cmp a l) = un (f a) (listd f un b l).

Proof.

apply listd_insert_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H).

apply extensionality; intros ?; apply prop_ext; split; unfold orp; tauto.

Qed.



Lemma listd_sort_uniq_un l :

  listd f un b (rsort_uniq cmp l) = listd f un b l.

Proof.

apply listd_sort_uniq; auto.

intros x y H b'; rewrite (Hcmp _ _ H).

apply extensionality; intros ?; apply prop_ext; split; unfold orp; tauto.

Qed.



End ListDenoteSortUniqPreds.



Section ListDenoteMergePreds.

Context {A B : Type}.

Variables (f : A -> pred B) (b : pred B).

Variable (cmp : A -> A -> comparison).

Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).



Lemma listd_merge_inter l1 l2 s :

  listd f inter TT l1 s -> listd f inter TT l2 s ->

  listd f inter TT (merge cmp l1 l2) s.

Proof with simpl; auto.

revert l2; induction l1... intros l2 _ H1.

assert (forall l, (fix merge_aux (l0 : list A) := l0) l = l)

  as -> by (destruct l; auto)...

intros l2 H1 H2. induction l2... remember (cmp a a0) as b0; destruct b0...

split; auto. rewrite (Hcmp a a0) in Heqb0; subst. destruct H1 as [H1 H3]...

destruct H1, H2... destruct H1, H2... destruct H2; split... destruct H1; split...

Qed.



Lemma merge_nil l : merge cmp l nil = l.

Proof. solve[induction l; simpl; auto]. Qed.



Lemma merge_nil' l : merge cmp nil l = l.

Proof. solve[induction l; simpl; auto]. Qed.



Lemma merge_cons_unfold a1 a2 l1 l2 :

  merge cmp (a1 :: l1) (a2 :: l2) = match cmp a1 a2 with

                                      | Eq => a1 :: merge cmp l1 l2

                                      | Gt => a1 :: merge cmp l1 (a2 :: l2)

                                      | Lt => a2 :: merge cmp (a1 :: l1) l2

                                    end.

Proof. simpl; remember (cmp a1 a2) as c; destruct c; auto. Qed.



Lemma merge_elems a l1 l2 : In a l1 \/ In a l2 <-> In a (merge cmp l1 l2).

Proof with try solve[simpl; auto].

split. intros [H1|H1].



revert l1 H1; induction l2; induction l1... inversion 1.

intros H2; simpl in H2; destruct H2; subst.

rewrite merge_cons_unfold. remember (cmp a a0) as c; destruct c...

right. apply IHl2...

rewrite merge_cons_unfold. remember (cmp a1 a0) as c; destruct c...

right. apply IHl2. right...



revert l2 H1; induction l1; induction l2... inversion 1.

intros H2; simpl in H2; destruct H2; subst.

rewrite merge_cons_unfold. remember (cmp a0 a) as c; destruct c...

right. apply IHl1...

rewrite merge_cons_unfold. remember (cmp a0 a1) as c; destruct c...

right. apply IHl1. right...



revert l1; induction l2; induction l1...

rewrite merge_cons_unfold. remember (cmp a1 a0) as c; destruct c...

simpl. destruct 1; subst... specialize (IHl2 _ H); firstorder.

intros H1. apply in_inv in H1. destruct H1; subst...

specialize (IHl2 _ H). destruct IHl2...

intros H1. apply in_inv in H1. destruct H1; subst...

specialize (IHl1 H). destruct IHl1...

Qed.



Lemma listd_merge_inter' l1 l2 s :

  listd f inter TT (merge cmp l1 l2) s ->

  listd f inter TT l1 s /\ listd f inter TT l2 s.

Proof with auto.

intros H1; split.

apply listd_In_pred. intros a H2.

apply (listd_In_inv_pred _ a) in H1...

rewrite <-merge_elems. left... auto.

apply listd_In_pred. intros a H2.

apply (listd_In_inv_pred _ a) in H1...

rewrite <-merge_elems. right... auto.

Qed.



Lemma listd_merge_un1 l1 l2 s :

  listd f un FF l1 s -> listd f un FF (merge cmp l1 l2) s.

Proof with simpl; auto.

revert l2; induction l1... intros l2; inversion 1. intros l2 H1.

induction l2... remember (cmp a a0) as b0; destruct b0...

apply (Hcmp a a0) in Heqb0; subst.

inversion H1; try solve[left; auto]. right...

right; apply IHl2... inversion H1; try solve[left; auto]. right; auto.

Qed.



Lemma listd_merge_un2 l1 l2 s :

  listd f un FF l2 s -> listd f un FF (merge cmp l1 l2) s.

Proof with simpl; auto.

revert l1; induction l2. intros ?; inversion 1. intros l1 H1.

induction l1; auto. simpl merge. simpl. remember (cmp a0 a) as b0; destruct b0...

apply (Hcmp a0 a) in Heqb0; subst.

inversion H1. left; auto. right; apply IHl2; auto.

inversion H1. left; auto.

spec IHl2 (a0 :: l1). simpl in IHl2. right; auto.

right; apply IHl1.

Qed.



Lemma listd_merge_un' l1 l2 s :

  listd f un FF (merge cmp l1 l2) s ->

  listd f un FF l1 s \/ listd f un FF l2 s.

Proof with auto.

intros H1.

cut (listd f un FF (l1 ++ l2) s).

  intros H2. rewrite listd_app, listd_unfold_un in H2.

  destruct H2; firstorder.

apply listd_In_inv_pred_un in H1. destruct H1 as [[a [C D]]|E].

apply listd_In_pred_un.

left. exists a. rewrite <-merge_elems in C. rewrite Coqlib.in_app. split...

inversion E.

Qed.



End ListDenoteMergePreds.



Section ListDenoteSeparate.

Context {X Y B : Type}.

Variables (f : X -> pred B) (g : Y -> pred B) (b : pred B) (l1 : list X)

          (l2 : list Y).



Lemma listd_separate :

  listd f inter (listd g inter b l2) l1 =

  andp (listd f inter TT l1) (andp (listd g inter TT l2) b).

Proof with auto.

rewrite listd_unfold_inter.

pattern (inter (listd g inter TT l2) b); rewrite <- listd_unfold_inter...

Qed.



Lemma listd_prop:

listd f inter b l1 =

(andp (listd f inter TT l1) b).

Proof.

induction l1; intros; simpl. rewrite TT_and. trivial.

apply extensionality. intros s.

apply prop_ext; split; simpl; intros.

  rewrite IHl in H.

  destruct H; destruct H0.

  split; trivial. split; trivial.



  rewrite IHl.

  destruct H. destruct H.

  split; trivial. split; trivial.

Qed.



End ListDenoteSeparate.



Section SetDenote.



Definition setd {T} (f : M.elt -> T) (g : T -> T -> T) (b : T) (s : M.t) :=

  listd f g b (M.elements s).



End SetDenote.



Section SetLems.

Variables (s : M.t) (x y : clause).



Lemma setd_add_In_refl : M.In x (M.add x s).

Proof. rewrite M.add_spec.  auto.  Qed.



Lemma setd_add_In_refl_elems : In x (M.elements (M.add x s)).

Proof.

cut (M.In x (M.add x s)); [ | apply setd_add_In_refl; auto]; intro A.

rewrite <- M.elements_spec1, SetoidList.InA_alt in A; destruct A as [z [A B]].

subst; auto.

Qed.



Lemma setd_add_In : x = y \/ M.In y s -> M.In y (M.add x s).

Proof with auto.

rewrite M.add_spec; intuition.

Qed.



Lemma setd_add_In_inv : M.In y (M.add x s) -> x = y \/ M.In y s.

Proof with auto.

rewrite M.add_spec; intuition.

Qed.



Lemma elements_In {s0} : In y (M.elements s0) = M.In y s0.

Proof with auto.

apply prop_ext; split.

intro A. assert (B : exists z, OrderedClause.eq y z /\ In z (M.elements s0)).

  unfold OrderedClause.eq. eauto.

 rewrite <- SetoidList.InA_alt, M.elements_spec1 in B. auto.

rewrite <- M.elements_spec1, SetoidList.InA_alt; intros [z [A B]].

 subst; auto.

Qed.



Lemma empty_set_elems : M.elements M.empty = nil. 

Proof with simpl; auto.

case_eq (M.elements M.empty); intros; auto.

destruct (M.elements_spec1 M.empty e) as [? _].

absurd (M.In e M.empty).

apply M.empty_spec.

apply H0.

rewrite H; constructor.

auto.

Qed.



Lemma setd_add_In_inv_elems :

  In y (M.elements (M.add x s)) -> x = y \/ M.In y s.

Proof with auto.

intro A; rewrite elements_In in A.

solve [apply setd_add_In_inv in A; exact A].

Qed.



Lemma setd_rem_In_inv : M.In y (M.remove x s) -> M.In y s.

Proof with auto. rewrite M.remove_spec; intros [A _]... Qed.



Lemma setd_rem_In_inv_elems :

  In y (M.elements (M.remove x s)) -> In y (M.elements s).

Proof.

intro A; rewrite elements_In in A.

solve [apply setd_rem_In_inv in A; rewrite <- elements_In in A; auto].

Qed.



End SetLems.



Section SetDenoteLems.

Context (B : Type). Variables (f : clause -> pred B) (b : pred B).

Variable (h : M.t -> clause -> M.t).

Variable (H : forall c cls s, setd f inter b cls s -> f c s ->

                              setd f inter b (h cls c) s).



Lemma setd_fold_left cls0 l s :

  listd f inter b l s -> setd f inter b cls0 s ->

  setd f inter b (fold_left h l cls0) s.

Proof with simpl; auto.

revert cls0; induction l... intros s0 [A C] D; apply IHl...

Qed.



Lemma setd_fold cls0 l s :

  setd f inter b l s -> setd f inter b cls0 s ->

  setd f inter b (M.fold (Basics.flip h) cls0 l) s.

Proof with simpl; auto.

rewrite M.fold_spec; intros; apply setd_fold_left; auto.

Qed.



Lemma setd_un cls1 cls2 s :

  setd f inter TT cls1 s -> setd f inter TT cls2 s ->

  setd f inter TT (M.union cls1 cls2) s.

Proof with auto.

intros H1 H2. unfold setd.

 apply listd_In_pred; [ | auto]; intros e H3.

assert (H4: M.In e cls1 \/ M.In e cls2) by

  (rewrite elements_In in H3; apply M.union_spec; auto).

do 2 rewrite <-elements_In in H4.

destruct H4 as [H4|H4];

[apply listd_In_inv_pred with (l := M.elements cls1)|

 apply listd_In_inv_pred with (l := M.elements cls2)]...

Qed.



Lemma setd_base_separate:

   forall {A} f (b: pred A) cls,

    setd f inter b cls = andp b (setd f inter (@TT A) cls).

Proof.

 intros. clear H.

 unfold setd in *.

 induction (M.elements cls); simpl.

 rewrite andp_TT. auto.

 rewrite IHl.

 rewrite <- andp_assoc. rewrite (andp_comm (f0 a)).

 rewrite andp_assoc; auto.

Qed.



Lemma setd_add c cls s :

  setd f inter b cls s -> f c s -> setd f inter b (M.add c cls) s.

Proof with auto.

intros A C.

 rewrite setd_base_separate.

 rewrite setd_base_separate in A.

 destruct A as [A' A]. split; auto.

 clear A'.

 apply listd_In_pred; [| auto].

 intros a D.

 generalize (setd_add_In_inv_elems cls _ _ D); intros [E | F].

rewrite <- E... rewrite <- M.elements_spec1, SetoidList.InA_alt in F.

destruct F as [y [F G]]; subst y.

solve [apply (listd_In_inv_pred f _ _ _ A G)].

Qed.



Lemma setd_remove c cls s :

  setd f inter TT cls s -> setd f inter TT (M.remove c cls) s.

Proof with auto.

intro A; apply listd_In_pred; [|auto]; intros a C.

apply listd_In_inv_pred with (l := M.elements cls)...

apply setd_rem_In_inv_elems with (x := c)...

Qed.



Lemma setd_empty_set s : setd f inter TT M.empty s.

Proof.

apply listd_In_pred; [|auto]; intros x A.

rewrite empty_set_elems in A; inversion A.

Qed.



Require Import MSetFacts Logic.



Lemma setd_filter bf cls s :

  setd f inter TT cls s -> setd f inter TT (M.filter bf cls) s.

Proof.

intros.

apply listd_In_pred; [|auto]. intros a H1. unfold setd in H0.

assert (H2: In a (M.elements cls)).

  rewrite elements_In, M.filter_spec in H1; auto.

  destruct H1 as [H1 _]. rewrite <-elements_In in H1; auto.

  unfold Proper, respectful. intros.

  subst x; auto.

apply (listd_In_inv_pred _ _ _ _ H0 H2).

Qed.



End SetDenoteLems.



Section FoldLem.

Context (B : Type). Variables (f : clause -> pred B) (b : pred B).

Variable (h : list clause -> clause -> list clause).



Lemma listd_fold_left cls0 l s

  (H : forall c cls, listd f inter b cls s -> f c s ->

                     listd f inter b (h cls c) s) :

  listd f inter b l s -> listd f inter b cls0 s ->

  listd f inter b (fold_left h l cls0) s.

Proof with simpl; auto.

revert cls0; induction l... intros s0 [A C] D; apply IHl...

Qed.



End FoldLem.



Section FoldLemWeak.

Context (B : Type). Variables (f : clause -> pred B) (b : pred B).

Variable (h : list clause -> clause -> list clause).

Variable (H : forall c cls s, listd f inter b cls s -> (forall s, f c s) ->

                              listd f inter b (h cls c) s).



Lemma listd_fold_left_wk cls0 l s :

  listd (fun c => forall s, f c s) and True l -> listd f inter b cls0 s ->

  listd f inter b (fold_left h l cls0) s.

Proof with simpl; auto.

revert cls0 s; induction l... intros s0 s H1.

assert (H2: forall s, f a s). intros s'. destruct H1 as [H1 H2]. spec H1 s'...

intros D; apply IHl... destruct H1...

Qed.



End FoldLemWeak.



Lemma listd_inter_map: forall {A B C} (l:list A) (f:B -> C -> Prop) h s,

(forall x, In x l -> f (h x) s) ->

inter

  (listd f inter TT (map h l)) TT s.

Proof.

intros A B C l.

induction l; intros; subst; simpl in *.

 split; trivial.

split; trivial.

  split. apply H. left. trivial.

  apply IHl. clear IHl. intros.

    apply H. right. assumption.

Qed.



Lemma listd_inter_rev: forall {A B} (f: A -> B -> Prop) l,

  listd f inter TT (rev  l) = listd f inter TT l.

Proof.

induction l; simpl; auto.

rewrite listd_app.

simpl.

rewrite <- IHl.

rewrite andp_TT.

rewrite andp_comm.

apply listd_unfold_inter.

Qed.



Lemma orp_FF {A} (p : pred A) : orp p FF = p.

Proof.

extensionality s. apply prop_ext. split; firstorder.

Qed.



Lemma listd_un_rev:

  forall {A B} (f: A -> B -> Prop) l, listd f un FF (rev  l) = listd f un FF l.

Proof.

induction l; simpl; auto.

rewrite listd_app; simpl; rewrite <-IHl, orp_FF.

generalize (listd_unfold_un f (f a) (rev l)). intros H1.

rewrite unS in H1; auto.

Qed.



Lemma setd_filter_pred:

  forall {B: Type} (f: M.elt -> pred B) (h: M.elt -> bool) (s: M.t),

     setd f inter TT s |-- setd f inter TT (M.filter h s).

Proof.

intros.

intros st ?.

unfold setd in *.

apply listd_In_pred; intros; auto.

eapply listd_In_inv_pred; eauto.

rewrite Melements_spec1 in *.

rewrite M.filter_spec in H0; intuition.

Qed.



