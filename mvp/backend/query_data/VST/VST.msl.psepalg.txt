

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.eq_dec.
(* VST.msl.eq_dec:
Require Import VST.msl.base.

Class EqDec (A : Type) : Type :=
  eq_dec : forall a a' : A, {a = a'} + {a <> a'}.

Instance EqDec_nat : EqDec nat := eq_nat_dec.

Definition upd {A} `{EqDec A} (B : Type) (f : A -> B) (a : A) (b : B) : A -> B :=
  fun a' => if eq_dec a a' then b else f a'.
Arguments upd [A H B] _ _ _ _.

Lemma upd_eq {A} `{EqDec A} : forall B (f : A -> B) a b,
  upd f a b a = b.
Arguments upd_eq [A H B] _ _ _.

Lemma upd_eq' {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a = a' ->
  upd f a b a' = b.
Arguments upd_eq' [A H B] _ _ _ _ _.

Lemma upd_neq {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a <> a' ->
  upd f a b a' = f a'. *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)



Lemma pjoin_unit {A} {JA: Join A}{PosA: Pos_alg A}: forall {a b : A},

  join a b b -> False.

Proof. exact no_units. Qed.



Definition cjoins {A} {JA: Join A} (a b : A) : Type := {c : A | join a b c}.



Definition cjoin_sub {A} {JA: Join A} (a c : A) : Type := {b : A | join a b c}.



Lemma joins_comm {A} {JA: Join A}{PA: Perm_alg A} : forall a b,

  joins a b -> joins b a.

Proof. apply joins_sym.

Qed.



Lemma pfull_pmaximal {A} {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A} : full = maximal.

Proof with eauto.

  extensionality a.  apply prop_ext. split; repeat intro.

  destruct H0 as [a' ?]. unfold full in H.

  specialize (H a'). spec H...

  destruct H0 as [c ?].

  specialize (H c). spec H... subst. apply join_comm in H0. 

  apply no_units in H0. contradiction.

Qed.



Lemma psub_joins {A}  {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A}{DA: Disj_alg A} : forall a b,

  join_sub a b -> joins a b -> False.

Proof.

  intros.

  destruct H.

  destruct H0.

  destruct (join_assoc (join_comm H) (join_comm H0)) as [? [? _]].

  rewrite (join_self H1) in H1 by auto.

  eapply no_units; eauto.

Qed.



Section DISCRETE.  



  Instance Join_discrete (A : Type): Join A := fun a1 a2 a3 : A => False.



  Instance Perm_discrete (A: Type)  : @Perm_alg A (Join_discrete A).

  Proof. constructor; intros; inv H.

  Qed.

  

  Instance psa_discrete (A: Type) :  @Pos_alg A  (Join_discrete A).

  Proof.

    repeat intro. inv H.

  Qed.  

End DISCRETE.



Set Implicit Arguments.



Section PSA_LIFT.

  Variable A : Type.

  Variable J_A: Join A.

  Variable PA_A : Perm_alg A.

  

  Definition lifted : Type := sig nonunit.

  

  Definition lifted_obj (la: lifted) : A := proj1_sig la.



  Coercion lifted_obj : lifted >-> A.

  Definition mk_lifted (a : A) (pf : nonunit a) : lifted :=

    exist nonunit a pf.



  Instance Join_lift: Join lifted := fun a1 a2 a3 : lifted => @join A J_A a1 a2 a3.



    Instance Perm_lift: Perm_alg lifted.

   Proof.

     constructor; intros.



    icase x; icase y; icase z; icase z'.

    do 2 red in H, H0.

    generalize (join_eq H H0); intro. simpl in H1. subst; auto. 

    apply exist_ext. auto.

    

    icase a; icase b; icase c; icase d; icase e; red in H, H0; simpl in *.

    red  in H, H0. simpl in *.

    destruct (join_assoc H H0) as [f [? ?]].

    assert (nonunit f).

    unfold nonunit, unit_for; intros ? ?.

    destruct (join_assoc H1 H3) as [g [? ?]].

    generalize (join_positivity (join_comm H4) (join_comm H5)); intro.

    rewrite <- H6 in *; clear dependent g.

    apply n0 in H5.  auto.

    unfold lifted.

    exists (exist _ f H3). simpl. split; auto.

    

    do 2 red in H|-*. icase a; icase b; icase c; simpl in *; apply join_comm; auto.



    do 2 red in H,H0.

    icase a; icase a'; icase b; icase b'. simpl in *.

    generalize (join_positivity H H0); intro. subst; f_equal; auto. apply proof_irr.

  Qed.



  Instance Pos_lift: Pos_alg lifted.

  Proof.

   repeat intro. destruct e; destruct a; simpl in *.

   hnf in H. simpl in H. apply n in H. auto.

  Qed.



  Instance Canc_lift {CA: Canc_alg A}: Canc_alg lifted.

  Proof.

    repeat intro. do 2 red in H,H0.

    destruct a1; destruct a2.    generalize (join_canc H H0); intro. simpl in H1.

    subst; f_equal; auto. apply proof_irr.

  Qed.



  Instance Disj_lift {DA: Disj_alg A}: Disj_alg lifted.

  Proof.

    repeat intro. destruct a, b; hnf in H.

    simpl in H; apply join_self in H.

    destruct a0, b0.

    hnf in H0; simpl in H0.

    specialize (H _ _ H0); subst.

    f_equal.  apply proof_irr.

  Qed.



  Lemma lifted_eq : forall a b, 

    lifted_obj a = lifted_obj b -> 

    a = b.

  Proof.

    intros.

    destruct a. destruct b. simpl in *. subst x0.

    f_equal. apply proof_irr.

  Qed.



  Lemma mk_lifted_refl1: forall (a:A)  (pf1 pf2: nonunit a),

    mk_lifted pf1 = mk_lifted pf2.

  Proof.

    intros; rewrite (proof_irr pf1 pf2); auto.

  Qed.



  Lemma lifted_pjoins : forall a b : lifted,

    joins a b = @joins A J_A a b.

  Proof.

    intros. apply prop_ext. split; intros.

    destruct H. exists x. apply H.

    destruct H.

    assert (nonunit x).

    destruct a as [a Ha]; destruct b as [b Hb]. simpl in H.

    intros ? ?. unfold unit_for in H0. destruct (join_assoc H H0) as [f [? ?]].

    destruct (join_assoc H0 (join_comm H1)) as [g [? ?]].

    generalize (join_eq H1 (join_comm H3)); intro.

    rewrite <- H5 in *; clear dependent g.

    generalize (join_positivity H3 (join_comm H2)); intro.

    rewrite <- H5 in *; clear dependent f.

    apply Hb in H1; auto.

    exists (exist _ x H0). trivial.

  Qed.

  

  Lemma lifted_psub : forall a b : lifted, 

    join_sub a b -> @join_sub A J_A a b.  

  Proof.

    intros.

    destruct H. exists x. apply H.

  Qed.



  Lemma lifted_full {CA: Canc_alg A} : forall a : lifted,

    @full A J_A a -> full a.    

  Proof with auto.

    intros. do 2 intro.

    destruct H0.

    destruct a as [a Ha]. destruct sigma' as [sigma' Hs]. destruct x as [x Hx].

    do 2 red in H0. simpl in H0.

    unfold full in H.

    simpl in H.

    specialize (H sigma'). spec H; eauto.

    intros ? ? ?. destruct a0, b. do 2 red in H1. simpl in H1. apply H in H1.

    subst; f_equal; auto.  apply proof_irr.

  Qed.



End PSA_LIFT.



Existing Instance Join_lift.  

Existing Instance Perm_lift.

Existing Instance Pos_lift.

Existing Instance Canc_lift.

Existing Instance Disj_lift.

Arguments mk_lifted [A J_A] _ _.



Section SA_LOWER.

  Variable A : Type.

  Variable Pj_A: Join A.

  Variable PA_A : Perm_alg A.  



  Inductive lower_join: option A -> option A -> option A -> Prop :=

  | lower_None1: forall a, lower_join None a a

  | lower_None2: forall a, lower_join a None a

  | lower_Some: forall a1 a2 a3,  join a1 a2 a3 -> 

        lower_join (Some a1) (Some a2) (Some a3).



  Instance Join_lower: Join (option A) := lower_join.



  Instance Perm_lower: @Perm_alg (option A) Join_lower.

  Proof.

   constructor; intros.



   inv H; inv H0; try constructor. f_equal.   apply (join_eq H1 H3).



    icase d; [ |  exists c; inv H; inv H0; split; constructor; auto].

    icase e; [ | exists a; inv H0; inv H; split; constructor; auto].

    icase c; [ | exists b; inv H; inv H0; split; constructor; auto].

    icase a; [ | exists (Some a1); inv H; inv H0; split; try constructor; auto].

    icase b; [ | exists (Some a2); inv H; inv H0; split; constructor; auto].

    assert (join a a3 a0) by (inv H; auto).

    assert (join a0 a2 a1) by (inv H0; auto).

    destruct (join_assoc H1 H2) as [f [? ?]]; exists (Some f); split; constructor; auto.



    inv H; constructor; auto.



    inv H; inv H0; auto. f_equal. apply (join_positivity H1 H4).

 Qed.



 Instance Sep_lower: @Sep_alg _ Join_lower.

 Proof. apply mkSep with (fun _ => None); intros.

   constructor. reflexivity.

 Defined.



  Instance Sing_lower: @Sing_alg _ Join_lower _.

  Proof.

     apply (mkSing None). intros. reflexivity. 

  Defined.



  Instance Canc_lower {psa_A: Pos_alg A}{CA: Canc_alg A}: @Canc_alg _ Join_lower.

  Proof. repeat intro.

    inv H; inv H0; auto. apply no_units in H3; contradiction.

    apply no_units in H1; contradiction.

   f_equal. apply (join_canc H1 H4). 

 Qed.



  Instance Disj_lower {psa_A: Pos_alg A}{DA: Disj_alg A}: @Disj_alg _ Join_lower.

  Proof. repeat intro. inv H0; inv H; auto.

    - contradiction (no_units a1 a1).

      apply identity_unit; [eapply join_self | eexists]; eauto.

    - eapply f_equal, join_self; eauto.

  Qed.



End SA_LOWER.

Arguments Perm_lower _ [Pj_A][PA_A].

Arguments Sep_lower _ [Pj_A].

Arguments Sing_lower _ [Pj_A].

Arguments Canc_lower _ [Pj_A][psa_A][CA] _ _ _ _ _ _.

Arguments Disj_lower _ [Pj_A][PA_A][psa_A][DA] _ _ _.



Existing Instance Join_lower.  

Existing Instance Perm_lower.

Existing Instance Sep_lower.

Existing Instance Sing_lower.

Existing Instance Canc_lower.

Existing Instance Disj_lower.



Lemma None_unit {A}{JOIN: Join A}: 

      forall x: option A, @unit_for (option A) (@Join_lower _ _) None x.

Proof.

intros. simpl. auto.

constructor.

Qed.



Hint Resolve @None_unit.



Lemma None_identity {A} {JA: Join A}{psaA: Pos_alg A}: 

     @identity (option A) (Join_lower _) None.

Proof.

intros.

intros x y ?. inv H; auto.

Qed.



Hint Resolve @None_identity.



  Lemma lower_inv: forall {A}{JA: Join A} {PA: Perm_alg A} {psa_A: Pos_alg A} (a b c : option A),

    join a b c ->

    (a = None /\ b = c) + (a = c /\ b = None) + 

    ({a' : A & {b' : A & {c' : A | a = Some a' /\ b = Some b' /\ c = Some c' /\

    join a' b' c'}}}).

  Proof.

    intros.

    icase a; icase b; icase c; 

    try solve [elimtype False; inv H];

    try solve [right; exists a; exists a0; exists a1; inv H; intuition].

    left; right; inv H; auto.

    left; left; inv H; auto.

  Qed.



Section SA_SMASH.

  Variable T : Type.

  Variable J_T: Join T.

  Variable PA_T : Perm_alg T. 



  Definition smashed : Type := option (lifted J_T).

  Definition Perm_smash :  Perm_alg smashed  := Perm_lower (lifted J_T). 

  Definition Sep_smash : Sep_alg smashed := Sep_lower (lifted J_T).



  Lemma smash_inv: forall a b c : smashed,

    join a b c ->

    (a = None /\ b = c) + (a = c /\ b = None) + 

    ({a' : lifted J_T & {b' : lifted J_T & {c' : lifted J_T | a = Some a' /\ b = Some b' /\ c = Some c' /\

    join (lifted_obj a') (lifted_obj b') (lifted_obj c')}}}).

  Proof.

    intros.

    apply lower_inv in H.

    intuition.

  Qed.

End SA_SMASH.



Arguments smashed _  [J_T].

Existing Instance Perm_smash. 

Existing Instance Sep_smash. 



Lemma smashed_lifted_None_identity {A}`{Perm_alg A}:

  @identity (smashed A) _ None.

Proof. intros; apply None_identity. Qed.

Hint Resolve @smashed_lifted_None_identity.



 Instance Perm_option (T : Type)  : @Perm_alg (option T) (@Join_lower T (@Join_discrete T)) :=

    @Perm_lower T  (@Join_discrete T) (Perm_discrete T).

 Instance Sep_option (T: Type) : @Sep_alg (option T) (@Join_lower T (@Join_discrete T)) :=

    @Sep_lower T  (@Join_discrete T) .



Instance Pos_prod

        (A: Type) {J_A: Join A} {Pos_A: Pos_alg A}

        (B: Type) {J_B: Join B}{PA_B: Perm_alg B}: 

        Pos_alg (A*B).

  Proof.

   auto with typeclass_instances.

   repeat intro. inv H. apply no_units in H0. auto.

  Qed.



Section FinitePartialMap.

  Variable A:Type.

  Variable dec_A : EqDec A.



  Variable B:Type.

  Variable PJ_B: Join B.

  Variable Perm_B : Perm_alg B.

  Variable Pos_B : Pos_alg B.



  Let Rng := option B.

  Let Join_Rng := Join_lower PJ_B.

  Let Sep_Rng := Sep_lower B.

  Let Perm_Rng := Perm_lower B. 



  Definition finMap (f:A -> Rng) : Prop :=

    exists l, forall a:A, ~In a l -> f a = None.



  Lemma finMap_unit : forall x e,

    finMap x -> @unit_for _ (Join_fun A _ Join_Rng) e x -> finMap e.

  Proof.

    intros.

    destruct H as [l Hl].

    exists l.

    intros a Hl'.

    specialize ( Hl a Hl').

    red in H0.

    specialize ( H0 a).

    rewrite Hl in H0. inv H0; auto.

  Qed.



  Lemma finMap_join : forall x y z,

    @join _ (Join_fun A _ Join_Rng) x y z -> finMap x -> finMap y -> finMap z.

  Proof.

    intros.

    destruct H0 as [l0 H0].

    destruct H1 as [l1 H1].

    exists (l0 ++ l1).

    intros.

    specialize ( H a). specialize ( H0 a). specialize ( H1 a).

    rewrite H0 in H. rewrite H1 in H. inv H; auto.

    intro contr. apply H2. apply in_or_app; auto.

    intro contr. apply H2. apply in_or_app; auto.

  Qed.



  Definition fpm := sig finMap.

  Instance Join_fpm : Join fpm := 

     Join_prop (A -> option B)  (Join_fun A (option B) Join_Rng) finMap.



  Definition PAF: (@Perm_alg (A -> Rng)  (Join_fun A Rng Join_Rng))

  := Perm_fun _ _ _ Perm_Rng.



  Instance Perm_fpm : @Perm_alg fpm Join_fpm :=

    Perm_prop (A -> Rng) _ _ finMap finMap_join.



  Lemma finMap_core  x: finMap x -> 

        finMap (@core _ _ (Sep_fun A (option B) Join_Rng _ ) x).

  Proof. intros. exists nil; intros; reflexivity. Qed.



  Definition empty_fpm : fpm.

    refine (exist (fun x => finMap x) (fun _ => None) _).

    exists nil; auto.

  Defined.



  Instance Sep_fpm : @Sep_alg fpm Join_fpm.

  Proof. 

    apply mkSep with (core := fun _ => empty_fpm).

     intros. intro a. simpl. constructor. auto.

   Defined.



  Instance Sing_fpm:  @Sing_alg fpm _ _.

  Proof.

  apply mkSing with (the_unit := empty_fpm).

  intros ?. simpl. auto.

  Defined.



  Instance Canc_fpm {CA_B: Canc_alg B}: Canc_alg fpm.

  Proof. repeat intro.

    apply (join_canc H H0).

  Qed.



  Instance Disj_fpm {DA_B: Disj_alg B}: Disj_alg fpm.

  Proof. repeat intro. apply (join_self H); auto. Qed.



  Definition lookup_fpm (f:fpm) : A -> Rng := proj1_sig f.



  Definition insert_fpm (a:A) (b: B) (f:fpm) : fpm.

    destruct f as [f Hf].

    set (f' := fun x => if eq_dec a x then Some b else f x).

    refine (exist _ f' _).

    destruct Hf as [l Hl].

    exists (a :: l); simpl; intros.

    unfold f'.

    destruct (eq_dec a a0); auto.

    subst a0.

    elim H; auto.

  Defined.



   Definition insert'_fpm (a:A)(b: option B) (f: fpm) : fpm.

    destruct f as [f Hf].

    set (f' := fun x => if eq_dec a x then b else f x).

    refine (exist _ f' _).

    destruct Hf as [l Hl].

    exists (a :: l); simpl; intros.

    unfold f'.

    destruct (eq_dec a a0); auto.

    subst a0.

    elim H; auto.

  Defined.



  Definition remove_fpm (a:A) (f:fpm) : fpm.

    destruct f as [f Hf].

    set (f' := fun x => if eq_dec a x then None else f x).

    refine (exist _ f' _).

    destruct Hf as [l Hl].

    exists l; intros.

    unfold f'.

    destruct (eq_dec a a0); auto.

  Defined.



  Lemma fpm_gss: forall  i v rho, 

        lookup_fpm (insert_fpm i v rho) i = Some v.

  Proof.

    unfold lookup_fpm, insert_fpm.

    destruct rho.

    simpl.

    destruct (eq_dec i i); auto. contradiction n; auto.

  Qed.



  Lemma fpm_gso: forall i j v rho, 

       i <> j -> lookup_fpm (insert_fpm j v rho) i =

                               lookup_fpm rho i.

  Proof.

    unfold lookup_fpm, insert_fpm; intros.

    destruct rho.

    simpl.

    destruct (eq_dec j i); auto. contradiction H; auto.

  Qed.



  Lemma empty_fpm_join : forall x,

    @join _ Join_fpm empty_fpm x x.

  Proof.

    repeat intro.

    simpl.

    constructor.

  Qed.



  Lemma insert_fpm_join : forall i v (x y z:fpm),

    lookup_fpm y i = None ->

    @join _ Join_fpm x y z ->

    @join _ Join_fpm (insert_fpm i v x) y (insert_fpm i v z).

  Proof.

    intros. 

    intro j.

    change (@join _ (Join_lower PJ_B)

      (lookup_fpm (insert_fpm i v x) j)

      (lookup_fpm y j)

      (lookup_fpm (insert_fpm i v z) j)).

    destruct (eq_dec i j). subst j.

    do 2 rewrite fpm_gss. 

    rewrite H.

    constructor.

    do 2 (rewrite fpm_gso; auto).

  Qed.

End FinitePartialMap.



Lemma fpm_bij_aux: forall A B B' (f: B -> B') (rho: A -> option B), 

       @finMap A B rho -> 

       @finMap A B' (fun i => match rho i with None => None | Some j => Some (f j) end).

Proof.

  intros. destruct H as [l ?]. exists l. intros. rewrite (H _ H0). auto.

Qed.

Definition fpm_bij (A B B': Type) (bij: bijection B B') : bijection (fpm A B) (fpm A B').

 destruct bij as [f g fg gf].

 unfold fpm.

 apply (Bijection _ _

     (fun x: sig (@finMap A B) => exist (@finMap A B') _ (fpm_bij_aux f (proj2_sig x)))

     (fun x: sig (@finMap A B') => exist (@finMap A B) _ (fpm_bij_aux g (proj2_sig x)))).

  intros [x Hx]. simpl in *. apply exist_ext. extensionality i. destruct (x i); auto.

  rewrite fg; auto.

  intros [x Hx]. simpl in *. apply exist_ext. extensionality i. destruct (x i); auto.

  rewrite gf; auto.

Defined.



Lemma lift_prod_aux1 {A}{JA: Join A}{B}:

  forall x,   @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x -> nonunit (fst x).

Proof.

intros. destruct x. simpl. intro.

intro.

specialize (H (x,b)).

apply H.

split; simpl; auto.

Qed.



Definition lift_prod1  {A}{JA: Join A}{B} : (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) -> (@lifted A _ * B).

intros [x Hx].

destruct x as [a b].

split; auto.

apply (mk_lifted a (lift_prod_aux1 Hx)).

Defined.



Lemma lift_prod_aux2 {A}{JA: Join A}{B}: 

  forall x,

    nonunit (fst x) -> @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x.

Proof.

  intros.

  intro; intro. destruct x0 as [a b].

  destruct H0.

  apply (H _ H0).

Qed.



Definition lift_prod2  {A}{JA: Join A}{B} :(@lifted A _ * B) -> (@lifted (A * B) (Join_prod A _ B (Join_equiv B))).

intros [[x Hx] y].

 apply (mk_lifted _ (@lift_prod_aux2 _ _ _ (x,y) Hx)).

Defined.



Definition lift_prod_bij: forall A (JA: Join A) B,

     bijection  (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) (@lifted A _ * B).

Proof.

  intros.

  apply (Bijection _ _ lift_prod1 lift_prod2).

  intros. destruct x; simpl. destruct l. simpl. unfold mk_lifted. f_equal. f_equal.

  apply proof_irr.

  intros. destruct x; simpl. destruct x. simpl. unfold mk_lifted. f_equal. apply proof_irr.

Defined.

