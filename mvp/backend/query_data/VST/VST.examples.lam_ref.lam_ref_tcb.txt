
Require Export EqNat.

Require Import msl.Extensionality.
(* msl.Extensionality:
Require Export VST.msl.Axioms.

Require Import Coq.Logic.EqdepFacts.

Module EqdepElim: EqdepElimination.
Lemma eq_rect_eq :
    forall (U:Type) (p:U) (Q:U -> Type) (x:Q p) (h:p = p),
      x = eq_rect p Q x p h.
End EqdepElim.

Module EqdepTh := EqdepTheory EqdepElim.
Export EqdepTh.

Tactic Notation "extensionality" :=
 let x := fresh "x" in extensionality x.

Tactic Notation "extensionality" ident(x0) ident(x1) :=
  extensionality x0; extensionality x1.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) :=
  extensionality x0; extensionality x1; extensionality x2.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) ident(x5) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4; extensionality x5.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) ident(x5) ident(x6) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4; extensionality x5; extensionality x6.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) ident(x5) ident(x6) ident(x7) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4; extensionality x5; extensionality x6; extensionality x7.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) ident(x5) ident(x6) ident(x7) ident(x8) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4; extensionality x5; extensionality x6; extensionality x7;
  extensionality x8.

Tactic Notation "extensionality" ident(x0) ident(x1) ident(x2) ident(x3)
  ident(x4) ident(x5) ident(x6) ident(x7) ident(x8) ident(x9) :=
  extensionality x0; extensionality x1; extensionality x2; extensionality x3;
  extensionality x4; extensionality x5; extensionality x6; extensionality x7;
  extensionality x8; extensionality x9.

Lemma imp_ext: forall (A A' B B' : Prop), (A=A') -> (A -> (B=B')) -> ((A->B)=(A'->B')).

Lemma exists_ext: forall (A: Type) F G, (forall x: A, F x = G x) -> (Logic.ex F = Logic.ex G).

Lemma and_ext: forall A B C D, A=B -> C=D -> (A /\ C) = (B /\ D).

Lemma and_ext': forall (A: Prop) B C D, A=B -> (A -> (C=D)) -> (A /\ C) = (B /\ D).

Lemma or_ext: forall A B C D, A=B -> C=D -> (A \/ C) = (B \/ D).

Lemma forall_ext: forall (A: Type) (F: A -> Prop) G, (forall x:A, F x = G x) -> (forall x, F x) = (forall x, G x).

Lemma existT_ext:
  forall (A: Type) (P: A -> Prop) (x y: A) (Hx: P x) (Hy: P y),
     x = y -> existT _ x Hx = existT _ y Hy.

Lemma exist_ext:
  forall (A: Type) (P: A -> Prop) (x y: A) (Hx: P x) (Hy: P y),
     x = y -> exist _ x Hx = exist _ y Hy.

Lemma exist_ext' : forall A F (x y:@sig A F),
  proj1_sig x = proj1_sig y -> x = y. *)

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e).

