
Set Implicit Arguments.

Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Require Import FCF.PRF.
(* FCF.PRF:
Set Implicit Arguments.
Require Import FCF.FCF.
Require Import FCF.CompFold. 
Require Export FCF.Array.
Require Export FCF.Hybrid.

Local Open Scope list_scope.
Local Open Scope array_scope.

Definition oracleMap(D R S: Set)(eqds : EqDec S)(eqdr : EqDec R)(oracle : S  -> D -> Comp (R * S))(s : S)(ds : list D) :=
  compFold _ 
  (fun acc d => [rs, s] <-2 acc; [r, s] <-$2 oracle s d; ret (rs ++ r :: nil, s)) 
  (nil, s) ds.

Theorem oracleMap_wf : 
  forall (D R S : Set)(eqds : EqDec S)(eqdr : EqDec R) (oracle : S -> D -> Comp (R * S))ds s,
  (forall s x, well_formed_comp (oracle s x)) ->
  well_formed_comp (@oracleMap D R S _ _ oracle s ds).

  Hypothesis RndR_wf : well_formed_comp RndR.
  
  Definition randomFunc (f : (list (D * R))) (d : D) : Comp (R * list (D * R)) :=
      match (arrayLookup _ f d) with
        | None => (r <-$ RndR; ret (r, (d, r) :: f))
        | Some r => ret (r, f)
      end.  
  
  Lemma randomFunc_wf : forall f d, 
    well_formed_comp (randomFunc f d).
  
  Hint Resolve randomFunc_wf : wftac.

  Definition RndFunc(lsd : list D) : Comp (list (D * R)) :=
    compFold _ (fun f d => r <-$ RndR; ret (d, r)::f) nil lsd. 
  
End RandomFunc.

Local Open Scope type_scope.
Local Open Scope comp_scope.

Section PRF_concrete.
  
  Variable D R Key : Set.
  Variable RndKey : Comp Key.
  Variable RndR : Comp R.
  Variable f : Key -> D -> R.

  Hypothesis D_EqDec : EqDec D.
  Hypothesis R_EqDec : EqDec R.

  Definition RndR_func : (list (D * R) -> D -> Comp (R * list (D * R))) :=
    (randomFunc RndR _).

  Section PRF_NA_concrete.
  
    Variable State : Set.
    Variable A1 : Comp (list D * State).
    Variable A2 : State -> list R -> Comp bool.

    Definition PRF_NA_G_A : Comp bool := 
      [lsD, s_A] <-$2 A1; 
      lsR <-$ (k <-$ RndKey; ret (map (f k) lsD));
      A2 s_A lsR.
    
    Definition PRF_NA_G_B : Comp bool := 
      [lsD, s_A] <-$2 A1;
      [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD;
      A2 s_A lsR.
    
    Definition PRF_NA_Advantage := 
    | Pr[PRF_NA_G_A] - Pr[PRF_NA_G_B] |.  

  End PRF_NA_concrete.

  Section PRF_NAI_concrete.

    Variable A_state : Set.
    Variable A1 : Comp ((list (list D)) * A_state).
    Variable A2 : A_state -> list (list R) -> Comp bool.

    Definition PRF_NAI_G0 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => k <-$ RndKey; ret (map (f k) lsD)) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_G1 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_Advantage := 
    | Pr[PRF_NAI_G0] - Pr[PRF_NAI_G1] |.   
                         
  Section PRF_NA_impl_NAI.

    Variable maxLists : nat.
    Hypothesis maxLists_correct : 
      forall ls s_A, 
        In (ls, s_A) (getSupport A1) ->
        (length ls <= maxLists)%nat.

    Hypothesis A_state_EqDec : EqDec A_state.
    Hypothesis RndR_wf : well_formed_comp RndR.
    Hypothesis RndKey_wf : well_formed_comp RndKey.

    Variable maxDistance : Rat.
    Hypothesis maxDistance_correct : 
      forall i, 
      PRF_NA_Advantage (B1 nil _ _ A1 i) (B2 (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
              (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
              _ A2) <= maxDistance.

    Theorem PRF_NAI_Advantage_eq_Hybrid:
      PRF_NAI_Advantage == ListHybrid_Advantage 
                             (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
                             (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
                             _ A1 A2.

    Theorem PRF_NA_impl_NAI : 
      PRF_NAI_Advantage <= (maxLists / 1 * maxDistance)%rat.

  End PRF_NA_impl_NAI.

  End PRF_NAI_concrete.

  Section PRF_Full_concrete.
    
    Variable A : OracleComp D R bool.
    
    Definition f_oracle(k : Key)(x : unit)(d : D) :=
      ret (f k d, tt).
    
    Definition PRF_G_A : Comp bool := 
      k <-$ RndKey;
      [b, _] <-$2 A _ _ (f_oracle k) tt;
      ret b.
    
    Definition PRF_G_B : Comp bool := 
      [b, _] <-$2 A _ _ (RndR_func) nil;
      ret b.
    
    Definition PRF_Advantage := 
    | Pr[PRF_G_A] - Pr[PRF_G_B] |.  
    
  End PRF_Full_concrete.

  Section PRF_Finite_concrete.

    Variable dom : list D.
    Variable def : R.
    Variable A : (D -> R) -> Comp bool.

    Definition PRF_Fin_G_A : Comp bool := 
      k <-$ RndKey;
      A (f k).
    
    Definition PRF_Fin_G_B : Comp bool := 
      f <-$ @RndFunc D R RndR _ dom;
      A (fun d => arrayLookupDef _ f d def).

    Definition PRF_Fin_Advantage := 
    | Pr[PRF_Fin_G_A] - Pr[PRF_Fin_G_B] |.

  End PRF_Finite_concrete.
  
End PRF_concrete.

Require Import FCF.Asymptotic.
Require Import FCF.Admissibility.

Section PRF.

  Variable D R Key : DataTypeFamily.
  Variable RndKey : forall n, Comp (Key n).
  Variable RndR : forall n, Comp (R n).
  Variable f : forall n, Key n -> D n -> R n.

  Hypothesis D_EqDec : forall n, EqDec (D n).
  Hypothesis R_EqDec : forall n, EqDec (R n).

  Section PRF_NA.
    Variable admissible_A1 : pred_comp_fam.
    Variable admissible_A2 : pred_comp_func_2_fam.
    
    Definition PRF_NA :=
      forall (State : DataTypeFamily) A1 A2,
        admissible_A1 _ A1 -> 
        admissible_A2 State _ _ A2 ->
        negligible (fun n => PRF_NA_Advantage (RndKey n) (RndR n) (@f n) _ _ (A1 n) (@A2 n)).
  End PRF_NA.

  Section PRF_Full.
    Variable admissible_A : pred_oc_fam.
    
    Definition PRF :=
      forall (A : forall n, OracleComp (D n) (R n) bool),
        admissible_A _ _ _ A -> 
        negligible (fun n => PRF_Advantage (RndKey n) (RndR n) (@f n) _ _ (A n)).
  End PRF_Full.
      
End PRF. *)
Require Import hmacfcf.splitVector.
(* hmacfcf.splitVector:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import FCF.SemEquiv.
Require Import FCF.DetSem.

Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
          | 0 =>
            fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
          | S n' =>
            fun (v : Vector.t A (S n' + m)) =>
              let (v1, v2) := splitVector _ _ (Vector.tl v) in
                (Vector.cons _ (Vector.hd v) _ v1, v2)
    end.

Theorem splitVector_append :
  forall (A : Set) n1 (v1 : Vector.t A n1) n2 (v2 : Vector.t A n2),

Theorem append_splitVector_h :
  forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)),

Theorem append_splitVector:
  forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)) x1 x2,

Theorem shiftOut_plus :
  forall (n1 n2 : nat) s b s',
    shiftOut s (n1 + n2) = Some (b, s') ->
    exists b1 b2 s'',
      shiftOut s n1 = Some (b1, s'') /\
      shiftOut s'' n2 = Some (b2, s') /\
      splitVector n1 n2 b = (b1, b2).

Theorem shiftOut_plus_None :
  forall n1 n2 s,
    shiftOut s (n1 + n2) = None ->
    shiftOut s n1 = None \/
    (exists x s', shiftOut s n1 = Some (x, s') /\
      shiftOut s' n2 = None).

Theorem Vector_cons_app_assoc :
  forall (A : Type)(a : A)(n1 n2 : nat)(v1 : Vector.t A n1)(v2 : Vector.t A n2),

Theorem shiftOut_plus_if :
  forall n1 n2 s s' s'' b1 b2,
    shiftOut s n1 = Some (b1, s') ->
    shiftOut s' n2 = Some (b2, s'') ->
    shiftOut s (n1 + n2) = Some (Vector.append b1 b2, s'').

Theorem shiftOut_plus_None_if :
  forall n1 n2 s,
    (shiftOut s n1 = None \/
      (exists b s', shiftOut s n1 = Some (b, s') /\
        shiftOut s' n2 = None)) ->
    shiftOut s (n1 + n2) = None.

Theorem Rnd_split_equiv :
  forall n1 n2 z ,
    evalDist
    (x <-$ {0, 1}^(n1 + n2);
      ret (splitVector n1 n2 x)) z ==
    evalDist
    (x1 <-$ {0, 1}^n1;
      x2 <-$ {0, 1}^n2;
      ret (x1, x2)) z. *)

Require Import hmacfcf.HMAC_spec.
(* hmacfcf.HMAC_spec:
Set Implicit Arguments.

Require Import Bvector.
Require Import List.
Require Import Arith.

Definition Blist := list bool.

Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
    | 0 =>
      fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
    | S n' =>
      fun (v : Vector.t A (S n' + m)) =>
        let (v1, v2) := splitVector _ _ (Vector.tl v) in
          (Vector.cons _ (Vector.hd v) _ v1, v2)
  end.

Section HMAC.

  Variable c p : nat.
  Definition b := c + p.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  
  Variable iv : Bvector c.
  
  Definition h_star k (m : list (Bvector b)) :=
    fold_left h m k.
  
  Definition hash_words := h_star iv.

  Variable Message : Set.
  Variable splitAndPad : Message -> list (Bvector b).
  Hypothesis splitAndPad_1_1 :
    forall b1 b2,
      splitAndPad b1 = splitAndPad b2 ->
      b1 = b2.

  Variable fpad : Bvector c -> Bvector p.
  Definition app_fpad (x : Bvector c) : Bvector b :=
    (Vector.append x (fpad x)).

  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GNMAC k m :=
    let (k_Out, k_In) := splitVector c c k in
    h k_Out (app_fpad (h_star k_In m)).

  Definition GHMAC_2K (k : Bvector (b + b)) m :=
    let (k_Out, k_In) := splitVector b b k in
      let h_in := (hash_words (k_In :: m)) in
        hash_words (k_Out :: (app_fpad h_in) :: nil).

  Definition HMAC_2K (k : Bvector (b + b)) (m : Message) :=
    GHMAC_2K k (splitAndPad m).

  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC (k : Bvector b) :=
    GHMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

  Definition HMAC (k : Bvector b) :=
    HMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

End HMAC. *)

Section RelatedKeyAttack.

  Variable K D R Phi_s : Set.
  Variable K_EqDec : EqDec K.
  Variable D_EqDec : EqDec D.
  Variable R_EqDec : EqDec R.
  Variable RndK : Comp K.
  Variable RndR : Comp R.
  Variable f : K -> D -> R.
  Variable Phi : Phi_s -> K -> K.

  Variable A : OracleComp (Phi_s * D) R bool.

  Definition RKA_F k (s : unit) p :=
    [phi_s, x] <-2 p; ret (f (Phi phi_s k) x, tt).

  Definition RKA_randomFunc := @randomFunc (K * D) R RndR _.

  Definition RKA_R k s p :=
    [phi_s, x] <-2 p; (RKA_randomFunc s (Phi phi_s k, x)).

  Definition RKA_G0 :=
    k <-$ RndK;
    [b, _] <-$2 A _ _ (RKA_F k) tt;
    ret b.

  Definition RKA_G1 :=
    k <-$ RndK;
    [b, _] <-$2 A _ _ (RKA_R k) nil;
    ret b.

  Definition RKA_Advantage :=
    | Pr[RKA_G0] - Pr[RKA_G1] |.

End RelatedKeyAttack.

Definition dual_f (A B C : Set)(f : A -> B -> C) : B -> A -> C :=
  fun b a => f a b.

Section NMAC_to_HMAC.

  Variable c p : nat.
  Definition b := @b c p.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  Variable iv : Bvector c.
  Variable fpad : Bvector c -> Bvector p.

  Definition GHMAC_2K := GHMAC_2K h iv fpad.
  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC := GHMAC h iv fpad opad ipad.

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.

  Definition app_fpad := @app_fpad c p fpad.
  Definition h_star := h_star p h.

  Definition GNMAC := GNMAC h fpad.

  Definition A_NMAC :=
    x <-$ {0, 1}^(c + c);
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ x) tt;
    ret b.

  Definition A_HMAC :=
    x <-$ {0, 1}^b;
    [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt;
    ret b.

  Theorem GHMAC_2K_GNMAC_equiv :
    forall k ls,
      let (k_Out, k_In) := splitVector b b k in
        let k' := Vector.append (h iv k_Out) (h iv k_In) in
      GHMAC_2K k ls = GNMAC k' ls.

    intuition.
    unfold GHMAC_2K, HMAC_spec.GHMAC_2K, GNMAC, HMAC_spec.GNMAC, b, HMAC_spec.b.
    remember (splitVector (c + p) (c + p) k) as z.
    destruct z.
    rewrite splitVector_append.
    unfold app_fpad, hash_words.
    simpl.
    trivial.

  Qed.

  Definition HMAC_RKA_A : OracleComp (Bvector b * Bvector c) (Bvector c) bool :=
    k_Out <--$ OC_Query _ (opad, iv);
    k_In <--$ OC_Query _ (ipad, iv);
    [b, _] <--$2 $ A _ _ (f_oracle GNMAC _ (Vector.append k_Out k_In)) tt;
    $ ret b.

  Local Opaque evalDist.

  Theorem A_HMAC_RKA_equiv :
    Pr[A_HMAC] == Pr[RKA_G0 _ (Rnd b) (dual_f h) (BVxor b) HMAC_RKA_A].

    unfold A_HMAC, RKA_G0, GHMAC,  HMAC_RKA_A, GNMAC, HMAC_spec.GHMAC.
    comp_skip.

    simpl.
    repeat ( inline_first; comp_simp).
    comp_skip.
    eapply comp_spec_eq_impl_eq.
    eapply comp_spec_consequence.
    eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = b)).
    trivial.
    intuition.
    unfold f_oracle.
    eapply comp_spec_ret; intuition.
    simpl.
    specialize (GHMAC_2K_GNMAC_equiv (Vector.append (x xor opad) (x xor ipad)) a0); intuition.
    rewrite splitVector_append in H1.
    unfold dual_f.
    eapply eq_trans.
    eapply H1.
    unfold GNMAC.
    f_equal.
    f_equal.
    f_equal.
    eapply BVxor_comm.
    f_equal.
    eapply BVxor_comm.

    intuition.
    destruct b2; simpl in *; subst; intuition.

    comp_simp.
    simpl.
    inline_first.
    comp_simp.
    intuition.
  Qed.

  Definition A_NMAC_G1 :=
    x1 <-$ {0, 1}^c;
    x2 <-$ {0, 1}^c;
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Definition A_NMAC_G1_0 :=
    [x1, x2] <-$2 (
    x <-$ {0, 1}^(c + c);
    ret (splitVector c c x));
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Definition A_NMAC_G1_1 :=
    [x1, x2] <-$2 (
    x1 <-$ {0, 1}^c;
    x2 <-$ {0, 1}^c;
    ret (x1, x2));
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Theorem A_NMAC_G1_0_equiv :
    Pr[A_NMAC] == Pr[A_NMAC_G1_0].

    unfold A_NMAC, A_NMAC_G1_0.
    inline_first.
    comp_skip.
    remember (splitVector c c x) as z.
    comp_simp.
    erewrite append_splitVector.
    reflexivity.
    trivial.
  Qed.

  Theorem A_NMAC_G1_0_1_equiv :
    Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1].

    unfold A_NMAC_G1_0, A_NMAC_G1_1.
    comp_skip.
    eapply Rnd_split_equiv.
    reflexivity.

  Qed.

  Theorem  A_NMAC_G1_1_equiv :
    Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1].

    unfold A_NMAC_G1_1, A_NMAC_G1.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.

  Qed.

  Theorem A_NMAC_G1_equiv :
    Pr[A_NMAC] == Pr[A_NMAC_G1].

    rewrite A_NMAC_G1_0_equiv.
    rewrite A_NMAC_G1_0_1_equiv.
    apply A_NMAC_G1_1_equiv.

  Qed.

    Theorem xor_1_1 :
      forall (n : nat)(x y z : Bvector n),
        BVxor _ y x = BVxor _ z x ->
        y = z.

      intuition.
      rewrite <- BVxor_id_r at 1.
      rewrite <- (BVxor_same_id x).
      rewrite <- BVxor_assoc.
      rewrite H.
      rewrite  BVxor_assoc.
      rewrite (BVxor_same_id x).
      rewrite BVxor_id_r.
      trivial.

    Qed.

  Theorem A_NMAC_RKA_equiv :
    Pr[A_NMAC] == Pr[RKA_G1 _ _ _ (Rnd b) (Rnd c) (BVxor b) HMAC_RKA_A].

    rewrite A_NMAC_G1_equiv .

    unfold A_NMAC_G1, RKA_G1, HMAC_RKA_A.
    comp_irr_r.
    wftac.
    simpl.
    inline_first.
    comp_skip.
    comp_simp.
    inline_first.
    unfold RKA_randomFunc, randomFunc.
    simpl.

    case_eq (
      @eqbPair (Bvector b) (Bvector c) (Bvector_EqDec b)
                 (Bvector_EqDec c)
                 (@pair (Bvector b) (Bvector c) (BVxor b ipad x) iv)
                 (@pair (Bvector b) (Bvector c) (BVxor b opad x) iv)
                 ); intuition.

    unfold eqbPair in *.
    simpl in *.
    apply andb_true_iff in H1.
    intuition.

    apply eqbBvector_sound in H2.

    exfalso.
    eapply opad_ne_ipad.
    eapply xor_1_1.
    eauto.

    inline_first.
    comp_skip.
    comp_simp.
    inline_first.
    comp_skip.
    comp_simp.
    simpl.
    inline_first.
    comp_simp.
    intuition.
  Qed.

  Theorem A_HMAC_NMAC_close :
    | Pr[A_HMAC] - Pr[A_NMAC] | <=
      RKA_Advantage _ _ _ (Rnd b) (Rnd c) (dual_f h) (BVxor b) HMAC_RKA_A.

    rewrite A_HMAC_RKA_equiv.
    rewrite A_NMAC_RKA_equiv.
    reflexivity.

  Qed.

End NMAC_to_HMAC.