Require Import VST.floyd.base.
(* VST.floyd.base:
From compcert Require Export Clightdefs.
Require Export VST.veric.base.
Require Export VST.veric.SeparationLogic.
Require Export VST.msl.Extensionality.
Require Export compcert.lib.Coqlib.
Require Export VST.msl.Coqlib2 VST.veric.coqlib4 VST.floyd.coqlib3.
Require Export VST.veric.juicy_extspec.
Require Import VST.veric.NullExtension.
Require Export VST.floyd.jmeq_lemmas.
Require Export VST.floyd.find_nth_tactic.
Require Export VST.floyd.val_lemmas.
Require Export VST.floyd.assert_lemmas.
Require VST.floyd.SeparationLogicAsLogicSoundness.
Export SeparationLogicAsLogicSoundness.MainTheorem.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def.
Export SeparationLogicAsLogicSoundness.MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Defs.

Local Open Scope logic.

Definition extract_exists_pre:
  forall {CS: compspecs} {Espec: OracleKind},
  forall (A : Type) (P : A -> environ->mpred) c (Delta: tycontext) (R: ret_assert),
  (forall x, @semax CS Espec Delta (P x) c R) ->
   @semax CS Espec Delta (EX x:A, P x) c R
  := @semax_extract_exists.

Arguments alignof_two_p {env} t.

Lemma co_alignof_pos: forall co, (co_alignof co > 0)%Z.

Section GET_CO.

Context {cs: compspecs}.

Open Scope Z.

Definition co_default (s: struct_or_union): composite.

Definition get_co id :=
  match cenv_cs ! id with
  | Some co => co
  | _ => co_default Struct
  end.

Lemma co_default_consistent: forall su, composite_consistent cenv_cs (co_default su).

Lemma get_co_consistent: forall id, composite_consistent cenv_cs (get_co id).

Lemma get_co_members_nil_sizeof_0: forall id,
  co_members (get_co id) = nil -> co_sizeof (get_co id) = 0%Z.

Lemma get_co_members_no_replicate: forall id,
  members_no_replicate (co_members (get_co id)) = true.

Lemma sizeof_Tstruct: forall id a,
  sizeof (Tstruct id a) = co_sizeof (get_co id).

Lemma sizeof_Tunion: forall id a,
  sizeof (Tunion id a) = co_sizeof (get_co id).

End GET_CO.

Lemma co_members_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_members (@get_co cs_from id) = co_members (@get_co cs_to id).

Lemma co_sizeof_get_co_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  co_sizeof (@get_co cs_from id) = co_sizeof (@get_co cs_to id).

Definition member_dec: forall (it0 it1: ident * type), {it0 = it1} + {it0 <> it1}.

Fixpoint fold_right_sepcon (l: list mpred) : mpred :=
 match l with
 | nil => emp
 | b::r => b * fold_right_sepcon r
 end.

Inductive LLRR : Type :=
  | LLLL : LLRR
  | RRRR : LLRR. *)



Ltac simpl_PTree_get :=

  repeat match goal with

         | |- context [PTree.get ?i' ?t] =>

           let i'' := eval hnf in i' in

               change (PTree.get i' t) with

               ((fix get (A : Type) (i : positive) (m : PTree.t A) {struct i} : option A :=

                 match m with

                 | PTree.Leaf => None

                 | PTree.Node l o r =>

                     match i with

                     | (ii~1)%positive => get A ii r

                     | (ii~0)%positive => get A ii l

                     | 1%positive => o

                     end

                 end) _ i'' t)

         end;

  cbv iota zeta beta.



Ltac simpl_eqb_type :=

  repeat

  match goal with

  | |- context [eqb_type ?t1 ?t2] =>

    let b := eval hnf in (eqb_type t1 t2) in

    change (eqb_type t1 t2) with b;

    cbv beta iota zeta

  end.



Ltac simpl_temp_types_get :=

  repeat

  match goal with

  | |- context [(temp_types ?Delta) ! ?i] =>

          let ret := eval hnf in ((temp_types Delta) ! i) in

          change ((temp_types Delta) ! i) with ret

  end.



Ltac pos_eqb_tac :=

  let H := fresh "H" in

  match goal with

  | |- context [Pos.eqb ?i ?j] => destruct (Pos.eqb i j) eqn:H; [apply Pos.eqb_eq in H | apply Pos.eqb_neq in H]

  end.



Definition VST_floyd_map {A B : Type} (f: A -> B): list A -> list B :=

  fix map (l : list A) : list B := match l with

                                   | nil => nil

                                   | a :: t => f a :: map t

                                   end.



Definition VST_floyd_app {A: Type}: list A -> list A -> list A :=

  fix app (l m : list A) {struct l} : list A :=

  match l with

  | nil => m

  | a :: l1 => a :: app l1 m

  end.



Definition VST_floyd_concat {A: Type}: list (list A) -> list A :=

  fix concat (l : list (list A)) : list A :=

  match l with

  | nil => nil

  | x :: l0 => VST_floyd_app x (concat l0)

  end.



