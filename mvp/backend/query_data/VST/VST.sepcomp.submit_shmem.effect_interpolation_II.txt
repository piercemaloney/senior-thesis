Require Import Events. 

Require Import Memory.

Require Import Coqlib.

Require Import Integers.

Require Import compcert.common.Values.
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)

Require Import Maps.

Require Import Axioms.



Require Import FiniteMaps.

Require Import sepcomp.StructuredInjections.

Require Import effect_simulations.
(* effect_simulations:
Require Import compcert.common.Events.
Require Import compcert.common.Memory.
Require Import compcert.lib.Coqlib.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.AST.

Require Import compcert.common.Globalenvs.

Require Import compcert.lib.Axioms.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Definition vis mu := fun b => locBlocksSrc mu b || frgnBlocksSrc mu b.

Inductive reach (m:mem) (B:block -> Prop): list (block * Z) -> block -> Prop :=
  reach_nil: forall b, B b -> reach m B nil b
| reach_cons: forall b L b' z off n,
                     reach m B L b' ->
                     Mem.perm m b' z Cur Readable ->
                     ZMap.get z (PMap.get b' (Mem.mem_contents m)) =
                        Pointer b off n ->
              reach m B ((b',z)::L) b.

Fixpoint reach' (m:mem) (B:block -> Prop) (L:list (block * Z)): block -> Prop:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => bb = b /\
                                               Mem.perm m b' z Cur Readable /\
                                               reach' m B L b'
                           | _ => fun bb => False
                       end
            end
  end.

Lemma reach_reach': forall m B L b1, reach m B L b1 <-> reach' m B L b1.

Fixpoint reach'' (m:mem) (B:block -> bool) (L:list (block * Z)): block -> bool:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => eq_block bb b &&
                                               Mem.perm_dec m b' z Cur Readable  &&
                                               reach'' m B L b'
                           | _ => fun bb => false
                       end
            end
  end.

Lemma reach_reach'' m B L b1 :
  reach m (fun b => B b=true) L b1 <-> reach'' m B L b1=true.

Lemma reach_inject: forall m1 m2 j (J: Mem.inject j m1 m2)

Lemma reach_mono: forall B1 B2 (HB : forall b, B1 b = true -> B2 b = true)
                         m b L1 (R : reach m (fun bb : block => B1 bb = true) L1 b),
                  exists L, reach m (fun bb : block => B2 bb = true) L b.

Parameter REACH : mem -> (block -> bool) -> block -> bool.
Axiom REACHAX : 
  forall m B b, REACH m B b = true
  <-> exists L, reach m (fun bb => B bb = true) L b.

Lemma REACH_nil: forall m B b, B b = true -> REACH m B b = true.

Lemma REACH_cons: forall m B b b' z off n,
                     REACH m B b' = true ->
                     Mem.perm m b' z Cur Readable ->

Lemma REACH_inject: forall m1 m2 j (J: Mem.inject j m1 m2) B1 B2

Lemma REACH_mono: forall B1 B2 (HB: forall b, B1 b = true -> B2 b = true) m b
                  (R: REACH m B1 b = true), REACH m B2 b = true.

Definition replace_locals (mu:SM_Injection) pSrc' pTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc' pTgt' local extBSrc extBTgt fSrc fTgt extern
  end.

Lemma replace_locals_wd: forall mu (WD: SM_wd mu) pSrc' pTgt'
         (SRC: forall b1, pSrc' b1 = true ->
               exists b2 d, local_of mu b1 = Some(b2,d) /\ pTgt' b2=true)
         (TGT: forall b, pTgt' b = true -> locBlocksTgt mu b = true),
      SM_wd (replace_locals mu pSrc' pTgt').

Lemma replace_locals_extern: forall mu pubSrc' pubTgt',
      extern_of (replace_locals mu pubSrc' pubTgt') = extern_of mu.

Lemma replace_locals_local: forall mu pubSrc' pubTgt',
      local_of (replace_locals mu pubSrc' pubTgt') = local_of mu.

Lemma replace_locals_unknown: forall mu pubSrc' pubTgt',
      unknown_of (replace_locals mu pubSrc' pubTgt') = unknown_of mu.

Lemma replace_locals_foreign: forall mu pubSrc' pubTgt',
      foreign_of (replace_locals mu pubSrc' pubTgt') = foreign_of mu.

Lemma replace_locals_pub: forall mu pubSrc' pubTgt',
      pub_of (replace_locals mu pubSrc' pubTgt') =
          (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_pub': forall mu pubSrc' pubTgt'
      (P: forall b, pubBlocksSrc mu b = true -> pubSrc' b = true)
      b (B: pubBlocksSrc mu b = true),
      pub_of (replace_locals mu pubSrc' pubTgt') b = pub_of mu b.

Lemma replace_locals_as_inj: forall mu pubSrc' pubTgt',
      as_inj (replace_locals mu pubSrc' pubTgt') = as_inj mu.

Lemma replace_locals_shared: forall mu pubSrc' pubTgt',
      shared_of (replace_locals mu pubSrc' pubTgt') =
      join (foreign_of mu) (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_DOM: forall mu pubSrc' pubTgt',
      DOM (replace_locals mu pubSrc' pubTgt') = DOM mu.

Lemma replace_locals_RNG: forall mu pubSrc' pubTgt',
      RNG (replace_locals mu pubSrc' pubTgt') = RNG mu.

Lemma replace_locals_DomSrc: forall mu pubSrc' pubTgt',
      DomSrc (replace_locals mu pubSrc' pubTgt') = DomSrc mu.

Lemma replace_locals_DomTgt: forall mu pubSrc' pubTgt',
      DomTgt (replace_locals mu pubSrc' pubTgt') = DomTgt mu.

Lemma replace_locals_locBlocksSrc: forall mu pubSrc' pubTgt',
      locBlocksSrc (replace_locals mu pubSrc' pubTgt') = locBlocksSrc mu.

Lemma replace_locals_extBlocksTgt: forall mu pubSrc' pubTgt',
      extBlocksTgt (replace_locals mu pubSrc' pubTgt') = extBlocksTgt mu.

Lemma replace_locals_extBlocksSrc: forall mu pubSrc' pubTgt',
      extBlocksSrc (replace_locals mu pubSrc' pubTgt') = extBlocksSrc mu.

Lemma replace_locals_locBlocksTgt: forall mu pubSrc' pubTgt',
      locBlocksTgt (replace_locals mu pubSrc' pubTgt') = locBlocksTgt mu.

Lemma replace_locals_frgnBlocksSrc: forall mu pubSrc' pubTgt',
      frgnBlocksSrc (replace_locals mu pubSrc' pubTgt') = frgnBlocksSrc mu.

Lemma replace_locals_frgnBlocksTgt: forall mu pubSrc' pubTgt',
      frgnBlocksTgt (replace_locals mu pubSrc' pubTgt') = frgnBlocksTgt mu.

Lemma replace_locals_pubBlocksSrc: forall mu pubSrc' pubTgt',
      pubBlocksSrc (replace_locals mu pubSrc' pubTgt') = pubSrc'.

Lemma replace_locals_pubBlocksTgt: forall mu pubSrc' pubTgt',
      pubBlocksTgt (replace_locals mu pubSrc' pubTgt') = pubTgt'.

Definition replace_externs (mu:SM_Injection) fSrc' fTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc' fTgt' extern
  end.

Lemma replace_externs_wd: forall mu (WD: SM_wd mu) fSrc' fTgt'
         (SRC: forall b1, fSrc' b1 = true ->
               exists b2 d, extern_of mu b1 = Some(b2,d) /\ fTgt' b2=true)
         (TGT: forall b, fTgt' b = true -> extBlocksTgt mu b = true),
      SM_wd (replace_externs mu fSrc' fTgt').

Lemma replace_externs_extern: forall mu frgSrc' frgTgt',
      extern_of (replace_externs mu frgSrc' frgTgt') = extern_of mu.

Lemma replace_externs_foreign: forall mu frgSrc' frgTgt',
      foreign_of (replace_externs mu frgSrc' frgTgt') =
      fun b : block => if frgSrc' b then extern_of mu b else None.

Lemma replace_externs_local: forall mu frgSrc' frgTgt',
      local_of (replace_externs mu frgSrc' frgTgt') = local_of mu.

Lemma replace_externs_priv: forall mu frgSrc' frgTgt',
      priv_of (replace_externs mu frgSrc' frgTgt') = priv_of mu.

Lemma replace_externs_pub: forall mu frgSrc' frgTgt',
      pub_of (replace_externs mu frgSrc' frgTgt') = pub_of mu.

Lemma replace_externs_as_inj: forall mu frgSrc' frgTgt',
      as_inj (replace_externs mu frgSrc' frgTgt') = as_inj mu.

Lemma replace_externs_DOM: forall mu frgSrc' frgTgt',
      DOM (replace_externs mu frgSrc' frgTgt') = DOM mu.

Lemma replace_externs_RNG: forall mu frgSrc' frgTgt',
      RNG (replace_externs mu frgSrc' frgTgt') = RNG mu.

Lemma replace_externs_DomSrc: forall mu frgSrc' frgTgt',
      DomSrc (replace_externs mu frgSrc' frgTgt') = DomSrc mu.

Lemma replace_externs_DomTgt: forall mu frgSrc' frgTgt',
      DomTgt (replace_externs mu frgSrc' frgTgt') = DomTgt mu.

Lemma replace_externs_locBlocksSrc: forall mu frgSrc' frgTgt',
      locBlocksSrc (replace_externs mu frgSrc' frgTgt') = locBlocksSrc mu.

Lemma replace_externs_locBlocksTgt: forall mu frgSrc' frgTgt',
      locBlocksTgt (replace_externs mu frgSrc' frgTgt') = locBlocksTgt mu.

Lemma replace_externs_extBlocksSrc: forall mu frgSrc' frgTgt',
      extBlocksSrc (replace_externs mu frgSrc' frgTgt') = extBlocksSrc mu.

Lemma replace_externs_extBlocksTgt: forall mu frgSrc' frgTgt',
      extBlocksTgt (replace_externs mu frgSrc' frgTgt') = extBlocksTgt mu.

Lemma replace_externs_frgnBlocksSrc: forall mu fSrc' fTgt',
      frgnBlocksSrc (replace_externs mu fSrc' fTgt') = fSrc'.

Lemma replace_externs_frgnBlocksTgt: forall mu fSrc' fTgt',
      frgnBlocksTgt (replace_externs mu fSrc' fTgt') = fTgt'.

Lemma replace_externs_pubBlocksSrc: forall mu frgSrc' frgTgt',
      pubBlocksSrc (replace_externs mu frgSrc' frgTgt') = pubBlocksSrc mu.

Lemma replace_externs_pubBlocksTgt: forall mu frgSrc' frgTgt',
      pubBlocksTgt (replace_externs mu frgSrc' frgTgt') = pubBlocksTgt mu.

Definition getBlocks (V:list val) (b: block): bool :=
   in_dec eq_block b
    (fold_right (fun v L => match v with Vptr b' z => b'::L | _ => L end) nil V).

Lemma getBlocksD: forall v V b,
  getBlocks (v:: V) b =
    match v with
      Vptr b' _  => orb (eq_block b' b) (getBlocks V b)
    | _ => getBlocks V b
   end.

Lemma getBlocksD_nil: forall b,
  getBlocks nil b = false.

Lemma getBlocks_char: forall V b, getBlocks V b = true <->
   exists off, In (Vptr b off) V.

Lemma getBlocks_inject: forall j vals1 vals2
                       (ValInjMu : Forall2 (val_inject j) vals1 vals2)
                       b (B: getBlocks vals1 b = true),
      exists jb d, j b = Some (jb, d) /\ getBlocks vals2 jb = true.

Definition REACH_closed m (X: Values.block -> bool) : Prop :=
  (forall b, REACH m X b = true -> X b = true).

Definition mapped (j:meminj) b : bool :=
  match j b with None => false | Some _ => true end.

Lemma mappedD_true : forall j b (M: mapped j b = true),
                     exists p, j b = Some p.
Lemma mappedD_false : forall j b (M: mapped j b = false),
                      j b = None.
Lemma mappedI_true : forall j b p (J: j b = Some p),
                      mapped j b = true.
Lemma mappedI_false : forall j b (J:j b = None),
                       mapped j b = false.
Lemma mapped_charT: forall j b, (mapped j b = true) <-> (exists p, j b = Some p).
Lemma mapped_charF: forall j b, (mapped j b = false) <-> (j b = None).

Lemma inject_mapped: forall j m1 m2 (Inj12: Mem.inject j m1 m2) k

Lemma restrict_val_inject: forall j val1 val2
     (Inj : val_inject j val1 val2)
     X (HR: forall b, getBlocks (val1::nil) b = true -> X b = true),
   val_inject (restrict j X) val1 val2.

Lemma restrict_forall_vals_inject: forall j vals1 vals2
     (Inj : Forall2 (val_inject j) vals1 vals2)
     X (HR: forall b, getBlocks vals1 b = true -> X b = true),
 Forall2 (val_inject (restrict j X)) vals1 vals2.

Lemma restrict_mapped_closed: forall j m X
      (RC: REACH_closed m (mapped j))
      (RX: REACH_closed m X),
      REACH_closed m (mapped (restrict j X)).

Lemma restrict_mapped_closed_triv: forall j m X,
      REACH_closed m (fun b => mapped j b && X b) =
      REACH_closed m (mapped (restrict j X)).

Lemma REACH_closed_intersection: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b && Y b).

Lemma REACH_closed_union: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b || Y b).

Lemma inject_REACH_closed: forall j m1 m2 (Inj: Mem.inject j m1 m2),

Lemma inject_restrict: forall j m1 m2 X
        (INJ : Mem.inject j m1 m2)

Definition exportedSrc mu vals b := orb (getBlocks vals b) (sharedSrc mu b).
Definition exportedTgt mu vals b := orb (getBlocks vals b) (sharedTgt mu b).

Lemma exported_inject: forall mu (WD: SM_wd mu) vals1 vals2
          (ValInjMu : Forall2 (val_inject (as_inj mu)) vals1 vals2) b
          (SRC: exportedSrc mu vals1 b = true ),
        exists jb d, as_inj mu b = Some (jb, d)
                  /\ exportedTgt mu vals2 jb = true.

Lemma REACH_shared_of: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (shared_of mu) m1 m2)

Lemma REACH_as_inj: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_as_inj_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH': forall mu m1 vals1  b1
        (R : REACH m1 (exportedSrc mu vals1) b1 = true)
        (WD: SM_wd mu) m2 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Goal forall m1 mu (WD: SM_wd mu) vals b, pubBlocksSrc mu b = true ->
           REACH m1 (exportedSrc mu vals) b = true.

Definition local_out_of_reach mu (m : mem) (b : block) (ofs : Z): Prop :=
  locBlocksTgt mu b = true /\
  forall b0 delta, local_of mu b0 = Some (b, delta) ->
                  (~ Mem.perm m b0 (ofs - delta) Max Nonempty \/
                   pubBlocksSrc mu b0 = false).

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Lemma genvs_domain_eq_match_genvsB: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genv2blocksBool_char1: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char1': forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2': forall F V (ge : Genv.t F V) b,

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma restrict_preserves_globals: forall {F V} (ge:Genv.t F V) j X

Lemma genvs_domain_eq_isGlobal: forall {F1 V1 F2 V2} ge1 ge2
                       (DomainEQ: @genvs_domain_eq F1 V1 F2 V2 ge1 ge2),
       isGlobalBlock ge1 = isGlobalBlock ge2.

Lemma meminj_preserves_globals_isGlobalBlock: forall {F V} (g: Genv.t F V)

Lemma meminj_preserves_globals_initSM: forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma meminj_preserves_globals_init_REACH_frgn:
      forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma REACH_is_closed: forall R m1,
  REACH_closed m1 (fun b : block => REACH m1 R b).

Lemma core_initial_wd : forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma intern_incr_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu

Lemma replace_externs_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) nu

Lemma after_external_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu (WDmu : SM_wd mu)

Definition restrict_sm mu (X:block -> bool) :=
match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection locBSrc locBTgt pSrc pTgt (restrict local X)
                     extBSrc extBTgt fSrc fTgt (restrict extern X)
end.

Lemma restrict_sm_com: forall mu X Y,
      restrict_sm (restrict_sm mu X) Y = restrict_sm (restrict_sm mu Y) X.

Lemma restrict_sm_nest: forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu X) Y = restrict_sm mu Y.

Lemma restrict_sm_nest': forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu Y) X = restrict_sm mu Y.

Lemma restrict_sm_local: forall mu X,
      local_of (restrict_sm mu X) = restrict (local_of mu) X.
Lemma restrict_sm_pub: forall mu X,
      pub_of (restrict_sm mu X) = restrict (pub_of mu) X.

Lemma restrict_sm_extern: forall mu X,
      extern_of (restrict_sm mu X) = restrict (extern_of mu) X.
Lemma restrict_sm_foreign: forall mu X,
      foreign_of (restrict_sm mu X) = restrict (foreign_of mu) X.

Lemma restrict_sm_all: forall mu X,
       as_inj (restrict_sm mu X) = restrict (as_inj mu) X.

Lemma restrict_sm_local': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      local_of (restrict_sm mu X) = local_of mu.

Lemma restrict_sm_pub': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true ->
                     X b = true),
      pub_of (restrict_sm mu X) = pub_of mu.

Lemma restrict_sm_foreign': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      foreign_of (restrict_sm mu X) = foreign_of mu.

Lemma restrict_sm_locBlocksSrc: forall mu X,
      locBlocksSrc (restrict_sm mu X) = locBlocksSrc mu.
Lemma restrict_sm_extBlocksSrc: forall mu X,
      extBlocksSrc (restrict_sm mu X) = extBlocksSrc mu.
Lemma restrict_sm_pubBlocksSrc: forall mu X,
      pubBlocksSrc (restrict_sm mu X) = pubBlocksSrc mu.
Lemma restrict_sm_frgnBlocksSrc: forall mu X,
      frgnBlocksSrc (restrict_sm mu X) = frgnBlocksSrc mu.
Lemma restrict_sm_DomSrc: forall mu X,
      DomSrc (restrict_sm mu X) = DomSrc mu.
Lemma restrict_sm_DOM: forall mu X,
      DOM (restrict_sm mu X) = DOM mu.

Lemma restrict_sm_locBlocksTgt: forall mu X,
      locBlocksTgt (restrict_sm mu X) = locBlocksTgt mu.
Lemma restrict_sm_extBlocksTgt: forall mu X,
      extBlocksTgt (restrict_sm mu X) = extBlocksTgt mu.
Lemma restrict_sm_pubBlocksTgt: forall mu X,
      pubBlocksTgt (restrict_sm mu X) = pubBlocksTgt mu.
Lemma restrict_sm_frgnBlocksTgt: forall mu X,
      frgnBlocksTgt (restrict_sm mu X) = frgnBlocksTgt mu.
Lemma restrict_sm_DomTgt: forall mu X,
      DomTgt (restrict_sm mu X) = DomTgt mu.
Lemma restrict_sm_RNG: forall mu X,
      RNG (restrict_sm mu X) = RNG mu.

Lemma restrict_sm_WD:
      forall mu (WD: SM_wd mu) X
          (HX: forall b, vis mu b = true -> X b = true),
      SM_wd (restrict_sm mu X).

Lemma restrict_sm_preserves_globals: forall {F V} (ge:Genv.t F V) mu X

Definition mkinitial_SM (mu: SM_Injection) frgnS frgnT :=
  match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection (fun b => false) (fun b => false) (fun b => false) (fun b => false) (fun b => None)
                     (DomSrc mu) (DomTgt mu) frgnS frgnT (as_inj mu)
  end.

Lemma mkinitial_SM_as_inj: forall mu S T,
  as_inj (mkinitial_SM mu S T) = as_inj mu.
Lemma mkinitial_SM_local: forall mu S T,
  local_of (mkinitial_SM mu S T) = fun b => None.
Lemma mkinitial_SM_extern: forall mu S T,
  extern_of (mkinitial_SM mu S T) = as_inj mu.

Lemma mkinitial_SM_foreign: forall mu S T b1,
  foreign_of (mkinitial_SM mu S T) b1 =
  if S b1 then as_inj mu b1 else None.

Lemma mkinitial_SM_DomSrc: forall mu S T,
  DomSrc (mkinitial_SM mu S T) = DomSrc mu.
Lemma mkinitial_SM_DOM: forall mu S T,
  DOM (mkinitial_SM mu S T) = DOM mu.
Lemma mkinitial_SM_DomTgt: forall mu S T,
  DomTgt (mkinitial_SM mu S T) = DomTgt mu.
Lemma mkinitial_SM_RBG: forall mu S T,
  RNG (mkinitial_SM mu S T) = RNG mu.

Lemma mkinitial_SM_equals_initial_SM: forall mu S T,
  mkinitial_SM mu S T = initial_SM (DomSrc mu) (DomTgt mu) S T (as_inj mu).

Lemma mkinitial_SM_ok: forall {F1 V1 F2 V2:Type}
        (g1: Genv.t F1 V1) (g2: Genv.t F2 V2) (G:genvs_domain_eq g1 g2)

Module SM_simulation. Section SharedMemory_simulation_inject.
  Context {F1 V1 C1 F2 V2 C2:Type}
          (Sem1 : @EffectSem (Genv.t F1 V1) C1)
          (Sem2 : @EffectSem (Genv.t F2 V2) C2)
          (ge1: Genv.t F1 V1)
          (ge2: Genv.t F2 V2)
          (entry_points : list (val * val * signature)).

  Record SM_simulation_inject :=
  { core_data : Type;
    match_state : core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop;
    core_ord : core_data -> core_data -> Prop;
    core_ord_wf : well_founded core_ord;

    match_sm_wd: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          SM_wd mu;

    genvs_dom_eq: genvs_domain_eq ge1 ge2;

    match_genv: forall d mu c1 m1 c2 m2 (MC:match_state d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true);

    match_visible: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu);

    match_restrict: forall d mu c1 m1 c2 m2 X,
          match_state d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_state d (restrict_sm mu X) c1 m1 c2 m2;

    match_validblocks: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2;

    core_initial : forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists cd, exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_state cd (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2;

    core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall cd st2 mu m2,
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_state cd' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            core_ord cd' cd);

      effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall cd st2 mu m2
        (UHyp: forall b1 z, U1 b1 z = true -> Mem.valid_block m1 b1 ->
                            vis mu b1 = true),
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_state cd' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               core_ord cd' cd)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)));

    core_halted : forall cd mu c1 m1 c2 m2 v1,
      match_state cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2;

    core_at_external :
      forall cd mu c1 m1 c2 m2 e vals1 ef_sig,
        match_state cd mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\

         exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2));

    eff_after_external:
      forall cd mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_state cd mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

         (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

         (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
        exists cd', exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_state cd' mu' st1' m1' st2' m2'
}.

End SharedMemory_simulation_inject.

End SM_simulation. *)

Require Import effect_simulations_lemmas.
(* effect_simulations_lemmas:
Require Import Events.
Require Import Memory.
Require Import Coqlib.
Require Import compcert.common.Values.
Require Import Maps.
Require Import Integers.
Require Import AST.
Require Import Globalenvs.

Require Import Axioms.
Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Require Import effect_simulations.

Section Eff_INJ_SIMU_DIAGRAMS.
  Context {F1 V1 C1 F2 V2 C2:Type}
          {Sem1 : @EffectSem (Genv.t F1 V1) C1}
          {Sem2 : @EffectSem (Genv.t F2 V2) C2}

          {ge1: Genv.t F1 V1}
          {ge2: Genv.t F2 V2}
          {entry_points : list (val * val * signature)}.

  Let core_data := C1.

  Variable match_states: core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop.

   Hypothesis genvs_dom_eq: genvs_domain_eq ge1 ge2.

   Hypothesis match_sm_wd: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          SM_wd mu.

    Hypothesis match_visible: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu).

    Hypothesis match_restrict: forall d mu c1 m1 c2 m2 X,
          match_states d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_states d (restrict_sm mu X) c1 m1 c2 m2.

   Hypothesis match_validblocks: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2.

    Hypothesis match_genv: forall d mu c1 m1 c2 m2 (MC:match_states d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true).

   Hypothesis inj_initial_cores: forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_states c1 (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2.

  Hypothesis inj_halted : forall cd mu c1 m1 c2 m2 v1,
      match_states cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2.

  Hypothesis inj_at_external :
      forall mu c1 m1 c2 m2 e vals1 ef_sig,
        match_states c1 mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\
          exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2)).

  Hypothesis inj_after_external:
      forall mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_states st1 mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

        (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

        (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
       exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_states st1' mu' st1' m1' st2' m2'.

Section EFF_INJ_SIMULATION_STAR_WF.
Variable order: C1 -> C1 -> Prop.
Hypothesis order_wf: well_founded order.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            order st1' st1).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b z, U1 b z = true -> Mem.valid_block m1 b ->
                           vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               order st1' st1)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty))).

Lemma  inj_simulation_star_wf:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR_WF.

Section EFF_INJ_SIMULATION_STAR.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                  vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_star:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR.

Section EFF_INJ_SIMULATION_PLUS.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                             vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_plus:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_PLUS.

End Eff_INJ_SIMU_DIAGRAMS.

Definition compose_sm (mu1 mu2 : SM_Injection) : SM_Injection :=
 Build_SM_Injection
   (locBlocksSrc mu1) (locBlocksTgt mu2)
   (pubBlocksSrc mu1) (pubBlocksTgt mu2)
   (compose_meminj (local_of mu1) (local_of mu2))
   (extBlocksSrc mu1) (extBlocksTgt mu2)
   (frgnBlocksSrc mu1) (frgnBlocksTgt mu2)
   (compose_meminj (extern_of mu1) (extern_of mu2)).

Lemma compose_sm_valid: forall mu1 mu2 m1 m2 m2' m3
          (SMV1: sm_valid mu1 m1 m2) (SMV2: sm_valid mu2 m2' m3),
       sm_valid (compose_sm mu1 mu2) m1 m3.

Lemma compose_sm_pub: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      pub_of (compose_sm mu12 mu23) =
      compose_meminj (pub_of mu12) (pub_of mu23).

Lemma compose_sm_DomSrc: forall mu12 mu23,
  DomSrc (compose_sm mu12 mu23) = DomSrc mu12.

Lemma compose_sm_DomTgt: forall mu12 mu23,
  DomTgt (compose_sm mu12 mu23) = DomTgt mu23.

Lemma compose_sm_foreign: forall mu12 mu23
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      foreign_of (compose_sm mu12 mu23) =
      compose_meminj (foreign_of mu12) (foreign_of mu23).

Lemma compose_sm_priv: forall mu12 mu23,
   priv_of (compose_sm mu12 mu23) =
   compose_meminj (priv_of mu12) (local_of mu23).

Lemma compose_sm_unknown: forall mu12 mu23,
   unknown_of (compose_sm mu12 mu23) =
   compose_meminj (unknown_of mu12) (extern_of mu23).

Lemma compose_sm_local: forall mu12 mu23,
   local_of (compose_sm mu12 mu23) =
   compose_meminj (local_of mu12) (local_of mu23).

Lemma compose_sm_extern: forall mu12 mu23,
   extern_of (compose_sm mu12 mu23) =
   compose_meminj (extern_of mu12) (extern_of mu23).

Lemma compose_sm_shared: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12) (WD2:SM_wd mu23),
      shared_of (compose_sm mu12 mu23) =
      compose_meminj (shared_of mu12) (shared_of mu23).

Lemma compose_sm_wd: forall mu1 mu2 (WD1: SM_wd mu1) (WD2:SM_wd mu2)
         (HypPub: forall b, pubBlocksTgt mu1 b = true ->
                            pubBlocksSrc mu2 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu1 b = true ->
                            frgnBlocksSrc mu2 b = true),
      SM_wd (compose_sm mu1 mu2).

Lemma compose_sm_as_inj: forall mu12 mu23 (WD1: SM_wd mu12) (WD2: SM_wd mu23)
   (SrcTgtLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
   (SrcTgtExt: extBlocksTgt mu12 = extBlocksSrc mu23),
   as_inj (compose_sm mu12 mu23) =
   compose_meminj (as_inj mu12) (as_inj mu23).

Lemma compose_sm_intern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: intern_incr mu12 mu12')
            (inc23: intern_incr mu23 mu23'),
      intern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma compose_sm_extern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: extern_incr mu12 mu12')
            (inc23: extern_incr mu23 mu23')
  (FRG': forall b1 b2 d1, foreign_of mu12' b1 = Some(b2,d1) ->
         exists b3 d2, foreign_of mu23' b2 = Some(b3,d2))
  (WD12': SM_wd mu12') (WD23': SM_wd mu23'),
  extern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma extern_incr_inject_incr:
      forall nu12 nu23 nu' (WDnu' : SM_wd nu')
          (EXT: extern_incr (compose_sm nu12 nu23) nu')
          (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\
                      locBlocksTgt nu12 = locBlocksSrc nu23 /\
                      extBlocksTgt nu12 = extBlocksSrc nu23 /\
                      (forall b, pubBlocksTgt nu12 b = true ->
                                 pubBlocksSrc nu23 b = true) /\
                      (forall b, frgnBlocksTgt nu12 b = true ->
                                 frgnBlocksSrc nu23 b = true)),
      inject_incr (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu').

Lemma compose_sm_as_injD: forall mu1 mu2 b1 b3 d
      (I: as_inj (compose_sm mu1 mu2) b1 = Some (b3, d))
      (WD1: SM_wd mu1) (WD2: SM_wd mu2),
      exists b2 d1 d2, as_inj mu1 b1 = Some(b2,d1) /\
                       as_inj mu2 b2 = Some(b3,d2) /\
                       d=d1+d2.

Lemma compose_sm_intern_separated:
      forall mu12 mu12' mu23 mu23' m1 m2 m3
        (inc12: intern_incr mu12 mu12')
        (inc23: intern_incr mu23 mu23')
        (InjSep12 : sm_inject_separated mu12 mu12' m1 m2)
        (InjSep23 : sm_inject_separated mu23 mu23' m2 m3)
        (WD12: SM_wd mu12) (WD12': SM_wd mu12') (WD23: SM_wd mu23) (WD23': SM_wd mu23')
        (BlocksLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
        (BlocksExt: extBlocksTgt mu12 = extBlocksSrc mu23),
      sm_inject_separated (compose_sm mu12 mu23)
                          (compose_sm mu12' mu23') m1 m3.

Lemma vis_compose_sm: forall mu nu, vis (compose_sm mu nu) = vis mu.

Lemma restrict_compose: forall j k X,
  restrict (compose_meminj j k) X = compose_meminj (restrict j X) k. *)

Require Import sepcomp.mem_lemmas.
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.mem_interpolation_defs.

Require Import sepcomp.mem_interpolation_II.



Definition insert_as_extern (mu: SM_Injection) (j: meminj) (DomJ TgtJ:block->bool)

          : SM_Injection:=

  match mu with

    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>

    Build_SM_Injection locBSrc locBTgt pSrc pTgt local

      (fun b => orb (extBSrc b) (DomJ b))

      (fun b => orb (extBTgt b) (TgtJ b))

      fSrc

      fTgt

      (join extern (fun b => match local b with Some _ => None

                                              | None => j b end))

  end.



Definition convertL (nu12: SM_Injection) (j12':meminj) FreshSrc FreshMid:=

  insert_as_extern nu12 j12' FreshSrc FreshMid.



Definition convertR (nu23: SM_Injection) (j23':meminj) FreshMid FreshTgt:=

  insert_as_extern nu23 j23' FreshMid FreshTgt.



Lemma convertL_local: forall nu12 j12' FreshSrc FreshMid,

            local_of (convertL nu12 j12' FreshSrc FreshMid) =

            local_of nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_pub: forall nu12 j12' FreshSrc FreshMid,

            pub_of (convertL nu12 j12' FreshSrc FreshMid) =

            pub_of nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_priv: forall nu12 j12' FreshSrc FreshMid,

            priv_of (convertL nu12 j12' FreshSrc FreshMid) =

            priv_of nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_extern: forall nu12 j12' FreshSrc FreshMid,

            extern_of (convertL nu12 j12' FreshSrc FreshMid) =

            join (extern_of nu12)

                 (fun b => match (local_of nu12) b with Some _ => None | None => j12' b end).

Proof. intros. destruct nu12; simpl. reflexivity. Qed.



Lemma convertL_locBlocksSrc: forall nu12 j12' FreshSrc FreshMid,

            locBlocksSrc (convertL nu12 j12' FreshSrc FreshMid) =

            locBlocksSrc nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_locBlocksTgt: forall nu12 j12' FreshSrc FreshMid,

            locBlocksTgt (convertL nu12 j12' FreshSrc FreshMid) =

            locBlocksTgt nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_extBlocksSrc: forall nu12 j12' FreshSrc FreshMid,

            extBlocksSrc (convertL nu12 j12' FreshSrc FreshMid) =

            fun b => orb (extBlocksSrc nu12 b) (FreshSrc b).

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_extBlocksTgt: forall nu12 j12' FreshSrc FreshMid,

            extBlocksTgt (convertL nu12 j12' FreshSrc FreshMid) =

            fun b => orb (extBlocksTgt nu12 b) (FreshMid b).

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_DomSrc: forall nu12 j12' FreshSrc FreshMid,

            DomSrc (convertL nu12 j12' FreshSrc FreshMid) =

            (fun b => orb (DomSrc nu12 b) (FreshSrc b)).

Proof. intros. destruct nu12. unfold DomSrc; simpl in *.

       extensionality b. rewrite orb_assoc. reflexivity. Qed.



Lemma convertL_DomTgt: forall nu12 j12' FreshSrc FreshMid,

            DomTgt (convertL nu12 j12' FreshSrc FreshMid) =

            (fun b => orb (DomTgt nu12 b) (FreshMid b)).

Proof. intros. destruct nu12. unfold DomTgt; simpl in *.

       extensionality b. rewrite orb_assoc. reflexivity. Qed.



Lemma convertL_pubBlocksSrc: forall nu12 j12' FreshSrc FreshMid,

            pubBlocksSrc (convertL nu12 j12' FreshSrc FreshMid) =

            pubBlocksSrc nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_pubBlocksTgt: forall nu12 j12' FreshSrc FreshMid,

            pubBlocksTgt (convertL nu12 j12' FreshSrc FreshMid) =

            pubBlocksTgt nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_frgnBlocksSrc: forall nu12 j12' FreshSrc FreshMid,

            frgnBlocksSrc (convertL nu12 j12' FreshSrc FreshMid) =

            frgnBlocksSrc nu12.

Proof. intros. destruct nu12. simpl. reflexivity. Qed.



Lemma convertL_frgnBlocksTgt: forall nu12 j12' FreshSrc FreshMid,

            frgnBlocksTgt (convertL nu12 j12' FreshSrc FreshMid) =

            frgnBlocksTgt nu12.

Proof. intros. destruct nu12. reflexivity. Qed.



Lemma convertL_foreign: forall nu12 j12' FreshSrc FreshMid (WD12:SM_wd nu12),

            foreign_of (convertL nu12 j12' FreshSrc FreshMid) =

            foreign_of nu12.

Proof. intros. destruct nu12; simpl in *. extensionality b.

  remember (frgnBlocksSrc b) as d.

  destruct d; trivial. apply eq_sym in Heqd.

  destruct (frgnSrc _ WD12 _ Heqd) as [b2 [z [Frg _]]]. simpl in Frg.

  rewrite Heqd in Frg; unfold join. rewrite Frg; trivial. Qed.



Lemma convertR_local: forall nu23 j23' FreshMid FreshTgt,

            local_of (convertR nu23 j23' FreshMid FreshTgt) =

            local_of nu23.

Proof. intros. destruct nu23; simpl. reflexivity. Qed.



Lemma convertR_pub: forall nu23 j23' FreshMid FreshTgt,

            pub_of (convertR nu23 j23' FreshMid FreshTgt) =

            pub_of nu23.

Proof. intros. destruct nu23; simpl. reflexivity. Qed.



Lemma convertR_priv: forall nu23 j23' FreshMid FreshTgt,

            priv_of (convertR nu23 j23' FreshMid FreshTgt) =

            priv_of nu23.

Proof. intros. destruct nu23; simpl. reflexivity. Qed.



Lemma convertR_extern: forall nu23 j23' FreshMid FreshTgt,

            extern_of (convertR nu23 j23' FreshMid FreshTgt) =

            join (extern_of nu23)

                 (fun b => match (local_of nu23) b with Some _ => None | None => j23' b end).

Proof. intros. destruct nu23; simpl. reflexivity. Qed.



Lemma convertR_foreign: forall nu23 j23' FreshMid FreshTgt (WD23:SM_wd nu23),

            foreign_of (convertR nu23 j23' FreshMid FreshTgt) =

            foreign_of nu23.

Proof. intros. destruct nu23; simpl in *. extensionality b.

  remember (frgnBlocksSrc b) as d.

  destruct d; trivial. apply eq_sym in Heqd.

  destruct (frgnSrc _ WD23 _ Heqd) as [b2 [z [Frg _]]]. simpl in Frg.

  rewrite Heqd in Frg; unfold join. rewrite Frg; trivial. Qed.



Lemma convertR_locBlocksSrc: forall nu23 j23' FreshMid FreshTgt,

            locBlocksSrc (convertR nu23 j23' FreshMid FreshTgt) =

            locBlocksSrc nu23.

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_locBlocksTgt: forall nu23 j23' FreshMid FreshTgt,

            locBlocksTgt (convertR nu23 j23' FreshMid FreshTgt) =

            locBlocksTgt nu23.

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_extBlocksSrc: forall nu23 j23' FreshMid FreshTgt,

            extBlocksSrc (convertR nu23 j23' FreshMid FreshTgt) =

            fun b => orb (extBlocksSrc nu23 b) (FreshMid b).

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_extBlocksTgt: forall nu23 j23' FreshMid FreshTgt,

            extBlocksTgt (convertR nu23 j23' FreshMid FreshTgt) =

            fun b => orb (extBlocksTgt nu23 b) (FreshTgt b).

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_DomSrc: forall nu23 j23' FreshMid FreshTgt,

            DomSrc (convertR nu23 j23' FreshMid FreshTgt) =

            (fun b => orb (DomSrc nu23 b) (FreshMid b)).

Proof. intros. destruct nu23; simpl. unfold DomSrc; simpl.

       extensionality b. rewrite orb_assoc. reflexivity. Qed.



Lemma convertR_DomTgt: forall nu23 j23' FreshMid FreshTgt,

            DomTgt (convertR nu23 j23' FreshMid FreshTgt) =

            (fun b => orb (DomTgt nu23 b) (FreshTgt b)).

Proof. intros. destruct nu23; simpl. unfold DomTgt; simpl.

       extensionality b. rewrite orb_assoc. reflexivity. Qed.



Lemma convertR_pubBlocksSrc: forall nu23 j23' FreshMid FreshTgt,

            pubBlocksSrc (convertR nu23 j23' FreshMid FreshTgt) =

            pubBlocksSrc nu23.

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_pubBlocksTgt: forall nu23 j23' FreshMid FreshTgt,

            pubBlocksTgt (convertR nu23 j23' FreshMid FreshTgt) =

            pubBlocksTgt nu23.

Proof. intros. destruct nu23. reflexivity. Qed.



Lemma convertR_frgnBlocksSrc: forall nu23 j23' FreshMid FreshTgt,

            frgnBlocksSrc (convertR nu23 j23' FreshMid FreshTgt) =

            frgnBlocksSrc nu23.

Proof. intros. destruct nu23. simpl. reflexivity. Qed.



Lemma convertR_frgnBlocksTgt: forall nu23 j23' FreshMid FreshTgt,

            frgnBlocksTgt (convertR nu23 j23' FreshMid FreshTgt) =

            frgnBlocksTgt nu23.

Proof. intros. destruct nu23; simpl. reflexivity. Qed.



Definition FreshDom (j j': meminj) b :=

  match j' b with

     None => false

   | Some(b',z) => match j b with

                     None => true

                   | Some _ => false

                   end

  end.



Goal forall mu (WD: SM_wd mu) M,

          (forall b ofs, locBlocksSrc mu b = true -> loc_unmapped (pub_of mu) b ofs -> ~M b ofs)

          <-> (forall b, locBlocksSrc mu b = true -> forall ofs, M b ofs -> pubBlocksSrc mu b = true).

intros. split; intros.

  remember (pubBlocksSrc mu b) as d.

  destruct d; trivial; apply eq_sym in Heqd.

  exfalso. apply (H _ _ H0 (pubSrcContra _ _ Heqd) H1).

intros N. specialize (H _ H0 _ N).

  unfold loc_unmapped in H1.

  destruct (pubSrc _ WD _ H) as [b2 [d [P _]]].

  rewrite P in H1. discriminate.

Qed.



Definition AccessEffProperty nu23 nu12 (j12' :meminj) (m1 m1' m2 : mem)

           (AM:ZMap.t (Z -> perm_kind -> option permission)):Prop :=

  forall b2,

    (Mem.valid_block m2 b2 -> forall k ofs2,

       if (locBlocksSrc nu23 b2)

       then if (pubBlocksSrc nu23 b2)

            then match source (local_of nu12) m1 b2 ofs2 with

                   Some(b1,ofs1) => if pubBlocksSrc nu12 b1

                                    then PMap.get b2 AM ofs2 k =

                                         PMap.get b1 m1'.(Mem.mem_access) ofs1 k

                                    else PMap.get b2 AM ofs2 k =

                                         PMap.get b2 m2.(Mem.mem_access) ofs2 k

                 | None =>  PMap.get b2 AM ofs2 k =

                            PMap.get b2 m2.(Mem.mem_access) ofs2 k

                 end

            else PMap.get b2 AM ofs2 k =

                 PMap.get b2 m2.(Mem.mem_access) ofs2 k

       else match source (as_inj nu12) m1 b2 ofs2 with

                   Some(b1,ofs1) =>  PMap.get b2 AM ofs2 k =

                                     PMap.get b1 m1'.(Mem.mem_access) ofs1 k

                 | None => match  (as_inj nu23) b2 with

                             None => PMap.get b2 AM ofs2 k  = PMap.get b2 m2.(Mem.mem_access) ofs2 k

                           | Some (b3,d3) =>  PMap.get b2 AM ofs2 k = None 


                           end



               end)

     /\ (~ Mem.valid_block m2 b2 -> forall k ofs2,

           match source j12' m1' b2 ofs2 with

              Some(b1,ofs1) => PMap.get b2 AM ofs2 k =

                               PMap.get b1 m1'.(Mem.mem_access) ofs1 k

            | None =>  PMap.get b2 AM ofs2 k = None

          end).



Definition ContentEffProperty nu23 nu12 (j12':meminj) (m1 m1' m2:Mem.mem)

                               (CM:ZMap.t (ZMap.t memval)):=

  forall b2,

  (Mem.valid_block m2 b2 -> forall ofs2,

    if locBlocksSrc nu23 b2

    then if (pubBlocksSrc nu23 b2)

         then match source (local_of nu12) m1 b2 ofs2 with

             Some(b1,ofs1) =>

                 if pubBlocksSrc nu12 b1

                 then ZMap.get ofs2 (PMap.get b2 CM) =

                            inject_memval j12'

                              (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

                 else ZMap.get ofs2 (PMap.get b2 CM) =

                           ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

           | None => ZMap.get ofs2 (PMap.get b2 CM) =

                     ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

            end

         else ZMap.get ofs2 (PMap.get b2 CM) =

              ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

    else match source (as_inj nu12) m1 b2 ofs2 with

             Some(b1,ofs1) => ZMap.get ofs2 (PMap.get b2 CM) =

                              inject_memval j12'

                                (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

           | None => ZMap.get ofs2 (PMap.get b2 CM) =

                     ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

         end)

  /\ (~ Mem.valid_block m2 b2 -> forall ofs2,

         match source j12' m1' b2 ofs2 with

                None => ZMap.get ofs2 (PMap.get b2 CM) = Undef

              | Some(b1,ofs1) =>

                   ZMap.get ofs2 (PMap.get b2 CM) =

                     inject_memval j12'

                       (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

         end)

   /\ fst CM !! b2 = Undef.



Lemma effect_interp_OK: forall m1 m2 nu12

                             (MInj12 : Mem.inject (as_inj nu12) m1 m2) m1'

                             (Fwd1: mem_forward m1 m1') nu23 m3

                             (MInj23 : Mem.inject (as_inj nu23) m2 m3) m3'

                             (Fwd3: mem_forward m3 m3')

                              nu' (WDnu' : SM_wd nu')

                             (SMvalNu' : sm_valid nu' m1' m3')

                             (MemInjNu' : Mem.inject (as_inj nu') m1' m3')



                             (ExtIncr: extern_incr (compose_sm nu12 nu23) nu')

                             (SMInjSep: sm_inject_separated (compose_sm nu12 nu23) nu' m1 m3)

                             (SMV12: sm_valid nu12 m1 m2)

                             (SMV23: sm_valid nu23 m2 m3)

                             (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc (compose_sm nu12 nu23) b = true /\

                                                      pubBlocksSrc (compose_sm nu12 nu23) b = false) m1 m1')



                             (UnchLOOR13: Mem.unchanged_on (local_out_of_reach (compose_sm nu12 nu23) m1) m3 m3')



                             (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\

                                         locBlocksTgt nu12 = locBlocksSrc nu23 /\

                                         extBlocksTgt nu12 = extBlocksSrc nu23 /\

                                         (forall b, pubBlocksTgt nu12 b = true ->

                                                    pubBlocksSrc nu23 b = true) /\

                                         (forall b, frgnBlocksTgt nu12 b = true ->

                                                    frgnBlocksSrc nu23 b = true))

                             (Norm12: forall b1 b2 d1, extern_of  nu12 b1 = Some(b2,d1) ->

                                             exists b3 d2, extern_of nu23 b2 = Some(b3, d2))

               prej12' j23' n1' n2'

               (HeqMKI: mkInjections m1 m1' m2 (as_inj nu12) (as_inj nu23) (as_inj nu') =

                            (prej12', j23', n1', n2'))

               j12' (Hj12': j12'= removeUndefs (as_inj nu12) (as_inj nu') prej12')

               m2'

               (NB: m2'.(Mem.nextblock)=n2')

               (CONT:  ContentEffProperty nu23 nu12 j12' m1 m1' m2

                                           (m2'.(Mem.mem_contents)))

               (ACCESS: AccessEffProperty nu23 nu12  j12' m1 m1' m2

                                               (m2'.(Mem.mem_access))),



     Mem.unchanged_on (fun b ofs => locBlocksSrc nu23 b = true /\

                                    pubBlocksSrc nu23 b = false) m2 m2' /\

     Mem.unchanged_on (local_out_of_reach nu12 m1) m2 m2' /\



     exists (nu12' nu23':SM_Injection),

           nu12'  = (convertL nu12 (removeUndefs (as_inj nu12) (as_inj nu') prej12')

                     (fun b => andb (DomSrc nu' b) (negb (DomSrc nu12 b)))

                     (FreshDom (as_inj nu23) j23'))

       /\ nu23' = (convertR nu23 j23'

                       (FreshDom (as_inj nu23) j23')

                       (fun b => andb (DomTgt nu' b) (negb (DomTgt nu23 b))))

                      /\ nu'=compose_sm nu12' nu23' /\

                             extern_incr nu12 nu12' /\ extern_incr nu23 nu23' /\

                             sm_inject_separated nu12 nu12' m1 m2 /\

                             sm_inject_separated nu23 nu23' m2 m3 /\

                             sm_valid nu12' m1' m2' /\ sm_valid nu23' m2' m3' /\

                             (SM_wd nu12' /\ SM_wd nu23' /\

                              locBlocksTgt nu12' = locBlocksSrc nu23' /\

                              extBlocksTgt nu12' = extBlocksSrc nu23' /\

                              (forall b, pubBlocksTgt nu12' b = true ->

                                         pubBlocksSrc nu23' b = true) /\

                              (forall b, frgnBlocksTgt nu12' b = true ->

                                         frgnBlocksSrc nu23' b = true)) /\

                             (forall b1 b2 d1, extern_of nu12' b1 = Some(b2,d1) ->

                                     exists b3 d2, extern_of nu23' b2 = Some(b3, d2)) /\

                             mem_forward m2 m2' /\

                             Mem.inject (as_inj nu12') m1' m2' /\

                             Mem.inject (as_inj nu23') m2' m3'.

Proof. intros.

  assert (VBj12_1: forall (b1 b2 : block) (ofs2 : Z),

                   (as_inj nu12) b1 = Some (b2, ofs2) -> Mem.valid_block m1 b1).

      intros. apply (Mem.valid_block_inject_1 _ _ _ _ _ _ H MInj12).

  assert (VBj12_2: forall (b1 b2 : block) (ofs2 : Z),

                   (as_inj nu12) b1 = Some (b2, ofs2) -> Mem.valid_block m2 b2).

      intros. apply (Mem.valid_block_inject_2 _ _ _ _ _ _ H MInj12).

  assert (VBj23_1: forall (b1 b2 : block) (ofs2 : Z),

                   (as_inj nu23) b1 = Some (b2, ofs2) -> Mem.valid_block m2 b1).

      intros. apply (Mem.valid_block_inject_1 _ _ _ _ _ _ H MInj23).

  assert (VBj23_2: forall (b1 b2 : block) (ofs2 : Z),

                   (as_inj nu23) b1 = Some (b2, ofs2) -> Mem.valid_block m3 b2).

      intros. apply (Mem.valid_block_inject_2 _ _ _ _ _ _ H MInj23).

  assert (VB12: forall (b3 b4 : block) (ofs3 : Z),

                 (as_inj nu12) b3 = Some (b4, ofs3) ->

                (b3 < Mem.nextblock m1 /\ b4 < Mem.nextblock m2)%positive).

      intros. split. apply (VBj12_1 _ _ _ H). apply (VBj12_2 _ _ _ H).

  assert (preinc12:= mkInjections_1_injinc _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12_1).

  assert (inc12:= inc_RU _ _ preinc12 (as_inj nu')).

  assert (presep12:= mkInjections_1_injsep _ _ _ _ _ _ _ _ _ _ HeqMKI).

  assert (sep12: inject_separated (as_inj nu12) (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1 m2).

       intros b; intros. eapply presep12. apply H.

       eapply RU_D. apply preinc12. apply H0.

  assert (InjIncr: inject_incr (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu')).

    subst. eapply extern_incr_inject_incr; eassumption.

  assert (InjSep: inject_separated (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu') m1 m3).

    subst. clear CONT ACCESS HeqMKI.

    apply sm_inject_separated_mem in SMInjSep.

    rewrite compose_sm_as_inj in SMInjSep.

      assumption.

      eapply GlueInvNu.

      eapply GlueInvNu.

      eapply GlueInvNu.

      eapply GlueInvNu.

      assumption.

  assert (inc23:= mkInjections_2_injinc _ _ _ _ _ _ _ _ _ _ HeqMKI VBj23_1).

  assert (sep23:= mkInjections_2_injsep _ _ _ _ _ _ _ _ _ _ HeqMKI

                  VBj12_1 _ InjSep).

  assert (NB1:= forward_nextblock _ _ Fwd1).

  assert (XX: n1' = Mem.nextblock m1').

    destruct (mkInjections_0  _ _ _ _ _ _ _ _ _ _ HeqMKI)

      as [[NN [N1 [N2 [JJ1 JJ2]]]] | [n [NN [N1 [N2 N3]]]]].

    subst. eapply Pos.le_antisym; assumption. assumption.

 subst.

  assert (VBj': forall b1 b3 ofs3, (as_inj nu') b1 = Some (b3, ofs3) ->

                (b1 < Mem.nextblock m1')%positive).

      intros. apply (Mem.valid_block_inject_1 _ _ _ _ _ _ H MemInjNu').

  assert (ID:= RU_composememinj _ _ _ _ _ _ _ _ _ _ HeqMKI

               InjIncr _ InjSep VBj12_1 VBj12_2 VBj23_1 VBj').

destruct GlueInvNu as [WDnu12 [WDnu23 [GlueLoc [GlueExt [GluePub GlueFrgn]]]]].

assert (Fwd2: mem_forward m2 m2').

  split; intros; rename b into b2.

  

     clear - H NB1 HeqMKI. unfold Mem.valid_block in *.

     destruct (mkInjections_0 _ _ _ _ _ _ _ _ _ _ HeqMKI)

     as [HH | HH].

       destruct HH as [_ [_ [XX _]]]. rewrite XX in H. assumption.

       destruct HH as [n [NN [_ [_ X]]]]. rewrite <- X.

        xomega.

  

     destruct (ACCESS b2) as [Val2 _].

     specialize (Val2 H Max ofs).

     remember (locBlocksSrc nu23 b2) as d.

     destruct d; apply eq_sym in Heqd.

     

       remember (pubBlocksSrc nu23 b2) as q.

       destruct q; apply eq_sym in Heqq.

         remember (source (local_of nu12) m1 b2 ofs) as src.

         destruct src.

           apply source_SomeE in Heqsrc.

           destruct Heqsrc as [b1 [delta [ofs1 [PBO [ValB1 [J1 [P1 Off2]]]]]]].

           subst.

           remember (pubBlocksSrc nu12 b1) as w.

           destruct w;

             rewrite (perm_subst _ _ _ _ _ _ _ Val2) in H0; clear Val2; trivial.

           eapply MInj12.

             apply local_in_all; eassumption.

             eapply Fwd1.

               apply ValB1.

               apply H0.

         rewrite (perm_subst _ _ _ _ _ _ _ Val2) in H0; apply H0.

       rewrite (perm_subst _ _ _ _ _ _ _ Val2) in H0; apply H0.

     

       remember (source (as_inj nu12) m1 b2 ofs) as src.

       destruct src.

         apply source_SomeE in Heqsrc.

         destruct Heqsrc as [b1 [delta [ofs1 [PBO [Bounds [J1 [P1 Off2]]]]]]].

         subst.

         rewrite (perm_subst _ _ _ _ _ _ _ Val2) in H0; clear Val2.

         eapply MInj12. apply J1.

           eapply Fwd1.

             apply Bounds.

             apply H0.

       remember (as_inj nu23 b2) as jb.

         destruct jb; apply eq_sym in Heqjb.

           destruct p0.

           unfold Mem.perm in H0. rewrite Val2 in H0. simpl in H0. contradiction.

         rewrite (perm_subst _ _ _ _ _ _ _ Val2) in H0; clear Val2. apply H0.



assert (UNCHA: Mem.unchanged_on

  (fun (b : block) (_ : Z) =>

   locBlocksSrc nu23 b = true /\ pubBlocksSrc nu23 b = false) m2 m2').

 split; intros. rename b into b2. rename H0 into ValB2.

        destruct H as [locBSrc pubBSrc].

        destruct (ACCESS b2) as [Val _].

        specialize (Val ValB2 k ofs).

        rewrite locBSrc, pubBSrc in Val.

        rewrite (perm_subst _ _ _ _ _ _ _ Val). split; auto.

  apply (cont_split _ _ _ _ _ (CONT b)); intros; clear CONT.

      

          specialize (H2 ofs).

          destruct H as [locBSrc pubBSrc].

          rewrite locBSrc, pubBSrc in H2. simpl in H2.

          apply H2.

      

          apply Mem.perm_valid_block in H0. contradiction.

split; trivial.

assert (UNCHB: Mem.unchanged_on (local_out_of_reach nu12 m1) m2 m2').

 

  split; intros. rename b into b2. rename H0 into ValB2.

     destruct H as [locTgt2 HP].

     destruct (ACCESS b2) as [Val _].

     specialize (Val ValB2 k ofs).

     remember (locBlocksSrc nu23 b2) as d.

     destruct d; apply eq_sym in Heqd.

     

       remember (pubBlocksSrc nu23 b2) as q.

       destruct q; apply eq_sym in Heqq.

       

          remember (source (local_of nu12) m1 b2 ofs) as ss.

          destruct ss.

            destruct p0.

            destruct (source_SomeE _ _ _ _ _ Heqss)

               as [b1 [d1 [ofs1 [PP [VB [JJ [PERM Off2]]]]]]]; clear Heqss.

            subst. apply eq_sym in PP. inv PP.

            remember (pubBlocksSrc nu12 b) as w.

            destruct w; apply eq_sym in Heqw;

              rewrite (perm_subst _ _ _ _ _ _ _ Val); clear Val.

              destruct (HP _ _ JJ).

                assert (Arith: z + d1 - d1 = z) by omega.

                rewrite Arith in H. contradiction.

              rewrite H in Heqw. discriminate.

            split; intros; trivial.

          rewrite (perm_subst _ _ _ _ _ _ _ Val); clear Val.

             split; intros; trivial.

       

          rewrite (perm_subst _ _ _ _ _ _ _ Val); clear Val.

             solve[split; intros; trivial].

     

        rewrite GlueLoc in locTgt2. rewrite locTgt2 in Heqd. discriminate.

  destruct H as [locTgt2 HP]. rename b into b2.

  apply (cont_split _ _ _ _ _ (CONT b2)); intros; clear CONT.

  

          specialize (H1 ofs).

          assert (locSrc2: locBlocksSrc nu23 b2 = true).

            rewrite GlueLoc in locTgt2. assumption.

          rewrite locSrc2 in *.

          remember (pubBlocksSrc nu23 b2) as d.

          destruct d; apply eq_sym in Heqd.

          

            remember (source (local_of nu12) m1 b2 ofs) as ss.

            destruct ss.

              destruct p.

              destruct (source_SomeE _ _ _ _ _ Heqss)

               as [b1 [d1 [ofs1 [PP [VB [JJ [PERM Off2]]]]]]]; clear Heqss.

              subst. inv PP.

              destruct (HP _ _ JJ); clear HP.

                 assert (Arith : ofs1 + d1 - d1 = ofs1) by omega.

                 rewrite Arith in H3. contradiction.

              rewrite H3 in H1. trivial.

            apply H1.

          

            apply H1.

       

          exfalso.

          apply Mem.perm_valid_block in H0. contradiction.

split; trivial.



assert (UNCHC: Mem.unchanged_on (local_out_of_reach nu23 m2) m3 m3').

  

   clear - UnchLOOR13 WDnu12 GluePub MInj12.

   unfold local_out_of_reach.

   split; intros; rename b into b3.

      destruct H as[locTgt3 LOOR23].

      eapply UnchLOOR13; trivial; simpl.

        split; trivial.

        intros b1; intros; simpl in *.

        remember (pubBlocksSrc nu12 b1) as d.

        destruct d; try (right; reflexivity).

        left. apply eq_sym in Heqd.

        destruct (compose_meminjD_Some _ _ _ _ _ H)

          as [b2 [d1 [d2 [LOC1 [LOC2 D]]]]]; subst; clear H.

        destruct (pubSrc _ WDnu12 _ Heqd) as [bb2 [dd1 [Pub12 PubTgt2]]].

        rewrite (pub_in_local _ _ _ _ Pub12) in LOC1. inv LOC1.

        apply GluePub in PubTgt2.

        destruct (LOOR23 _ _ LOC2); clear LOOR23.

          intros N. apply H.

          assert (Arith : ofs - (d1 + d2) + d1 = ofs - d2) by omega.

          rewrite <- Arith.

          eapply MInj12. eapply pub_in_all; try eassumption. apply N.

        rewrite H in PubTgt2. discriminate.

   destruct H as[locTgt3 LOOR23].

      eapply UnchLOOR13; trivial; simpl.

        split; trivial.

        intros b1; intros; simpl in *.

        remember (pubBlocksSrc nu12 b1) as d.

        destruct d; try (right; reflexivity).

        left. apply eq_sym in Heqd.

        destruct (compose_meminjD_Some _ _ _ _ _ H)

          as [b2 [d1 [d2 [LOC1 [LOC2 D]]]]]; subst; clear H.

        destruct (pubSrc _ WDnu12 _ Heqd) as [bb2 [dd1 [Pub12 PubTgt2]]].

        rewrite (pub_in_local _ _ _ _ Pub12) in LOC1. inv LOC1.

        apply GluePub in PubTgt2.

        destruct (LOOR23 _ _ LOC2); clear LOOR23.

          intros N. apply H.

          assert (Arith : ofs - (d1 + d2) + d1 = ofs - d2) by omega.

          rewrite <- Arith.

          eapply MInj12. eapply pub_in_all; try eassumption. apply N.

        rewrite H in PubTgt2. discriminate.



assert (VBj23': forall b2 b3 d2, j23' b2 = Some(b3,d2) -> Mem.valid_block m2' b2).

    assert (Val2: forall b2 b3 d2, as_inj nu23 b2 = Some(b3,d2) -> Mem.valid_block m2 b2).

       intros. eapply SMV23. eapply as_inj_DomRng; eassumption.

    intros.

    destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI Val2 _ _ _ H) as [MK | [MK | MK]].

       destruct MK. apply Fwd2. apply H1.

       destruct MK. subst. apply H1.

       destruct MK as [m Hm]; subst. apply Hm.

assert (Val12: (forall (b1 b2 : block) (ofs2 : Z),

  as_inj nu12 b1 = Some (b2, ofs2) ->

  (b1 < Mem.nextblock m1)%positive /\ (b2 < Mem.nextblock m2)%positive)).

   intros. split; eapply SMV12. eapply as_inj_DomRng; eassumption.

                eapply as_inj_DomRng; eassumption.

assert (Val23: (forall (b2 b3 : block) (ofs3 : Z),

  as_inj nu23 b2 = Some (b3, ofs3) -> (b2 < Mem.nextblock m2)%positive)).

   intros. eapply SMV23. eapply as_inj_DomRng; eassumption.

assert (NOVj12':= RU_no_overlap _ _ _ MInj12 _ Fwd1 _ _

                  MInj23 _ _ _ _ _ HeqMKI).

exists (convertL nu12 (removeUndefs (as_inj nu12) (as_inj nu') prej12')

           (fun b => andb (DomSrc nu' b) (negb (DomSrc nu12 b)))

           (FreshDom (as_inj nu23) j23')).

exists (convertR nu23 j23'

           (FreshDom (as_inj nu23) j23')

           (fun b => andb (DomTgt nu' b) (negb (DomTgt nu23 b)))).

split; trivial.

split; trivial.

remember (removeUndefs (as_inj nu12) (as_inj nu') prej12') as j12'.

assert (ConvertL_J12':

    as_inj

     (convertL nu12 j12'

        (fun b : block => DomSrc nu' b && negb (DomSrc nu12 b))

        (FreshDom (as_inj nu23) j23')) = j12').

    extensionality b.

    intros. unfold as_inj.

     rewrite convertL_extern, convertL_local.

     remember (j12' b) as d.

     destruct d; apply eq_sym in Heqd.

       destruct p. unfold join.

       remember (extern_of nu12 b) as q.

       destruct q; apply eq_sym in Heqq.

         destruct p. apply extern_in_all in Heqq.

            rewrite (inc12 _ _ _ Heqq) in Heqd. apply Heqd.

       remember (local_of nu12 b) as w.

       destruct w; apply eq_sym in Heqw.

         destruct p.

         apply local_in_all in Heqw.

            rewrite (inc12 _ _ _ Heqw) in Heqd. apply Heqd.

            assumption.

      rewrite Heqd. trivial.

     assert (A:= inject_incr_inv _ _ inc12 _ Heqd).

       destruct (joinD_None _ _ _ A).

       unfold join. rewrite H, H0, Heqd. trivial.

rewrite ConvertL_J12' in *.

 rewrite convertL_extern, convertL_frgnBlocksTgt,

         convertL_pubBlocksTgt, convertL_locBlocksTgt,

         convertL_extBlocksTgt.

assert (Inj12': Mem.inject j12' m1' m2').

    clear ConvertL_J12'.

    assert (Perm12': forall b1 b2 delta ofs k p,

             j12' b1 = Some (b2, delta) ->

             Mem.perm m1' b1 ofs k p -> Mem.perm m2' b2 (ofs + delta) k p).

        intros.

        apply (valid_split _ _ _ _ (ACCESS b2)); intros; clear ACCESS.

        

          specialize (H2 k (ofs+delta)).

          remember (as_inj nu12 b1) as AsInj1.

          destruct AsInj1; apply eq_sym in HeqAsInj1.

          Focus 2. clear H2. destruct (sep12 _ _ _ HeqAsInj1 H).

                   contradiction.

          destruct p0.

          rewrite (inc12 _ _ _ HeqAsInj1) in H.  inv H.

          assert (Val_b1:= VBj12_1 _ _ _ HeqAsInj1).

          assert (PMAX: Mem.perm m1 b1 ofs Max Nonempty).

                    apply Fwd1. assumption.

                    eapply Mem.perm_implies. eapply Mem.perm_max.

                               apply H0. apply perm_any_N.

          remember (locBlocksSrc nu23 b2) as Locb2.

          destruct Locb2; apply eq_sym in HeqLocb2.

          

            destruct (joinD_Some _ _ _ _ _ HeqAsInj1) as [EXT12 | [NoEXT12 LOC12]].

              destruct (extern_DomRng _ WDnu12 _ _ _ EXT12) as [? ?].

              rewrite GlueExt in H3.

              destruct (disjoint_extern_local_Src _ WDnu23 b2); congruence.

            destruct (local_DomRng _ WDnu12 _ _ _ LOC12) as [locBSrc1 locBTgt2].

            assert (NOV_LocNu12: Mem.meminj_no_overlap (local_of nu12) m1).

               eapply meminj_no_overlap_inject_incr.

                 apply MInj12. apply local_in_all; assumption.

            remember (pubBlocksSrc nu23 b2) as PubB2.

            destruct PubB2; apply eq_sym in HeqPubB2.

            

              remember (pubBlocksSrc nu12 b1) as PubSrcb1.

              destruct PubSrcb1; apply eq_sym in HeqPubSrcb1.

              

                destruct (pubSrc _ WDnu12 _  HeqPubSrcb1) as [bb2 [dd1 [PUB12 TGT2]]].

                rewrite (pub_in_local _ _ _ _ PUB12) in LOC12. inv LOC12.

                rewrite (source_SomeI (local_of nu12) _  _ b1) in H2; trivial.

                  rewrite HeqPubSrcb1 in *.

                  rewrite (perm_subst _ _ _ _ _ _ _ H2). apply H0.

                  apply pub_in_local; assumption.

              

                assert (PK: Mem.perm m1 b1 ofs k p).

                  eapply UnchPrivSrc.

                    simpl. split; assumption.

                    assumption.

                    assumption.

                rewrite (source_SomeI (local_of nu12) _  _ b1) in H2; trivial.

                rewrite HeqPubSrcb1 in H2.

                rewrite (perm_subst _ _ _ _ _ _ _ H2); clear H2.

                eapply MInj12; eassumption.

            

               rewrite (perm_subst _ _ _ _ _ _ _ H2); clear H2.

               eapply MInj12. apply local_in_all; eassumption.

               eapply UnchPrivSrc; simpl; trivial.

               split; trivial.

               remember (pubBlocksSrc nu12 b1) as q.

               destruct q; trivial.

               apply eq_sym in Heqq.

               destruct (pubSrc _ WDnu12 _ Heqq) as [bb2 [dd1 [PUB12 Pub2]]].

               apply pub_in_local in PUB12. rewrite PUB12 in LOC12. inv LOC12.

               apply GluePub in Pub2. rewrite Pub2 in HeqPubB2; discriminate.

          

             destruct (joinD_Some _ _ _ _ _ HeqAsInj1) as [EXT1 | [NoEXT1 LOC1]].

             Focus 2. destruct (local_DomRng _ WDnu12 _ _ _ LOC1).

                      rewrite GlueLoc in H3. congruence.

             destruct (extern_DomRng _ WDnu12 _ _ _ EXT1) as [HeqLocb1 HeqExtTgtb2].

             remember (source (as_inj nu12) m1 b2 (ofs + delta)) as ss.

             destruct ss.

             

               destruct (source_SomeE _ _ _ _ _ Heqss)

                 as [bb1 [dd1 [ofs11 [PP [VB [ JJ [PERM Off2]]]]]]].

               clear Heqss. subst.

               rewrite (perm_subst _ _ _ _ _ _ _ H2); clear H2.

               destruct (eq_block bb1 b1); subst.

                 rewrite JJ in HeqAsInj1. inv HeqAsInj1.

                 assert (Arith: ofs11 = ofs) by omega.

                 subst; assumption.

              destruct (Mem.mi_no_overlap _ _ _ MInj12

                           bb1 _ _ _ _ _ _ _ n JJ HeqAsInj1 PERM PMAX).

                exfalso. apply H; trivial.

                exfalso. apply H. rewrite Off2. trivial.

             

               remember (as_inj nu23 b2) as AsInj2.

               destruct AsInj2; apply eq_sym in HeqAsInj2.

               

                 destruct p0 as [b3 d2].

                 exfalso.

                 eapply (source_NoneE _ _ _ _ Heqss _

                        _ Val_b1 HeqAsInj1).

                 assert (Arith: ofs + delta - delta = ofs) by omega.

                 rewrite Arith. apply PMAX.

               

                  rewrite (perm_subst _ _ _ _ _ _ _ H2); clear H2.

                  remember (frgnBlocksSrc nu23 b2) as FrgnSrc2.

                  destruct FrgnSrc2; apply eq_sym in HeqFrgnSrc2.

                    destruct (frgnSrc _ WDnu23 _ HeqFrgnSrc2) as [b3 [d2 [FRG2 FrgTgt3]]].

                    rewrite (foreign_in_all _ _ _ _ FRG2) in HeqAsInj2. inv HeqAsInj2.

                  remember (frgnBlocksSrc nu12 b1) as FrgnSrc1.

                  destruct FrgnSrc1; apply eq_sym in HeqFrgnSrc1.

                    destruct (frgnSrc _ WDnu12 _ HeqFrgnSrc1) as [bb2 [dd1 [FRG1 FrgTgt2]]].

                    rewrite (foreign_in_extern _ _ _ _ FRG1) in EXT1. inv EXT1.

                    apply GlueFrgn in FrgTgt2. rewrite FrgTgt2 in HeqFrgnSrc2. inv HeqFrgnSrc2.

                 

                   exfalso.

                   eapply (source_NoneE _ _ _ _ Heqss _

                        _ Val_b1 HeqAsInj1).

                   assert (Arith: ofs + delta - delta = ofs) by omega.

                   rewrite Arith. apply PMAX.

        

            specialize (H2 k (ofs+delta)).

            rewrite (source_SomeI j12' _  _ b1) in H2.

              rewrite (perm_subst _ _ _ _ _ _ _ H2). apply H0.

              subst. apply (RU_no_overlap _ _ _ MInj12 _ Fwd1 _ _

                    MInj23 _ _ _ _ _ HeqMKI).

              assumption.

              eapply Mem.perm_implies. eapply Mem.perm_max.

                    apply H0. apply perm_any_N.

    assert (INJ:Mem.mem_inj j12' m1' m2').

      split. apply Perm12'.

      

          intros. rewrite Heqj12' in H.

          clear Heqj12'.

          unfold removeUndefs in H.

          remember (as_inj nu12 b1) as d.

          destruct d; apply eq_sym in Heqd.

            destruct p0 as [bb2 dd]. inv H.

            eapply MInj12. eassumption.

            assert (MR: Mem.range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p).

               intros z. intros. specialize (H0 _ H).

               eapply Fwd1. eapply VBj12_1. apply Heqd. apply H0.

               eassumption.

          remember (as_inj nu' b1) as q.

          destruct q; apply eq_sym in Heqq; try inv H.

          destruct p0.

            destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                      HeqMKI VB12 VBj23_1 _ _ _ H2)

            as [HX | [HX | HX]].

              destruct HX as [J12 [Val1 Val2]]. rewrite J12 in Heqd. inv Heqd.

              destruct HX as [? [? [? [? D]]]]. subst. apply Z.divide_0_r.

              destruct HX as [? [? [? [? [? D]]]]]. subst. apply Z.divide_0_r.

      

          intros.

          apply (cont_split _ _ _ _ _ (CONT b2)); intros; clear CONT.

         

            specialize (H2 (ofs + delta)).

            remember (as_inj nu12 b1) as AsInj1.

            destruct AsInj1; apply eq_sym in HeqAsInj1.

            Focus 2. clear H2. destruct (sep12 _ _ _ HeqAsInj1 H).

                     contradiction.

            destruct p.

            rewrite (inc12 _ _ _ HeqAsInj1) in H.  inv H.

            assert (Val_b1:= VBj12_1 _ _ _ HeqAsInj1).

            assert (PMAX: Mem.perm m1 b1 ofs Max Nonempty).

                    apply Fwd1. assumption.

                    eapply Mem.perm_implies. eapply Mem.perm_max.

                               apply H0. apply perm_any_N.

            remember (locBlocksSrc nu23 b2) as Myb2.

            destruct Myb2; apply eq_sym in HeqMyb2.

            

              destruct (joinD_Some _ _ _ _ _ HeqAsInj1) as [EXT12 | [NoEXT12 LOC12]].

                destruct (extern_DomRng _ WDnu12 _ _ _ EXT12) as [? ?].

                rewrite GlueExt in H4.

                destruct (disjoint_extern_local_Src _ WDnu23 b2); congruence.

              destruct (local_DomRng _ WDnu12 _ _ _ LOC12) as [locBSrc1 locBTgt2].

              remember (pubBlocksSrc nu23 b2) as PubB2.

              destruct PubB2; apply eq_sym in HeqPubB2.

              

                destruct (pubSrc _ WDnu23 _ HeqPubB2) as [b3 [d2 [Pub23 PubTgt3]]].

                assert (AsInj23: as_inj nu23 b2 = Some (b3, d2)) by (apply pub_in_all; assumption).

                assert (NOVlocal12: Mem.meminj_no_overlap (local_of nu12) m1).

                  eapply meminj_no_overlap_inject_incr.

                  apply MInj12. apply local_in_all; assumption.

                rewrite (source_SomeI (local_of nu12) _  _ b1) in H2; trivial.

                remember (pubBlocksSrc nu12 b1) as PubSrcb1.

                destruct PubSrcb1; apply eq_sym in HeqPubSrcb1; rewrite H2; clear H2.

                

                  destruct (pubSrc _ WDnu12 _  HeqPubSrcb1) as [bb2 [dd1 [PUB12 TGT2]]].

                  rewrite (pub_in_local _ _ _ _ PUB12) in LOC12. inv LOC12.

                  assert (Nu'b1: as_inj nu' b1 = Some (b3, delta+d2)).

                      rewrite ID. eapply compose_meminjI_Some; try eassumption.

                             apply inc12. eassumption. apply (inc23 _ _ _ AsInj23).

                  assert (MV:= Mem.mi_memval _ _ _

                                 (Mem.mi_inj _ _ _ MemInjNu') _ _ _ _ Nu'b1 H0).

                  inv MV; try constructor.

                           simpl.

                           rewrite ID in H4.

                           destruct (compose_meminjD_Some _ _ _ _ _ H4)

                              as [bb2 [dd1 [dd2 [JJ1 [JJ2 Delta]]]]].

                           rewrite JJ1. econstructor.

                             apply JJ1. reflexivity.

               

                  assert (PK: Mem.perm m1 b1 ofs Cur Readable).

                    solve[eapply UnchPrivSrc; eauto].

                  destruct UnchPrivSrc as [_ UPS].

                  rewrite UPS; try assumption; try (split; assumption).

                  eapply memval_inject_incr.

                    apply MInj12; assumption.

                    apply inc12.

              

                rewrite H2; clear H2.

                remember (pubBlocksSrc nu12 b1) as PubSrcb1.

                destruct PubSrcb1; apply eq_sym in HeqPubSrcb1.

                  destruct (pubSrc _ WDnu12 _  HeqPubSrcb1) as [bb2 [dd1 [PUB12 TGT2]]].

                  rewrite (pub_in_local _ _ _ _ PUB12) in LOC12. inv LOC12.

                  apply GluePub in TGT2. rewrite TGT2 in HeqPubB2. inv HeqPubB2.

                

                assert (PK: Mem.perm m1 b1 ofs Cur Readable).

                  solve [eapply UnchPrivSrc; eauto].

                destruct UnchPrivSrc as [_ UPS].

                  rewrite UPS; try assumption; try (split; assumption).

                  eapply memval_inject_incr.

                    apply MInj12; assumption.

                    apply inc12.

            

              rewrite (source_SomeI (as_inj nu12) _  _ b1) in H2; try eassumption.

                   Focus 2. eapply MInj12.

              rewrite H2; clear H2.

              assert (EXT1: extern_of nu12 b1 = Some (b2, delta)).

                destruct (joinD_Some _ _ _ _ _ HeqAsInj1); trivial.

                destruct H.

                destruct (local_DomRng _ WDnu12 _ _ _ H2).

                rewrite GlueLoc in H5. congruence.

              destruct (Norm12 _ _ _ EXT1) as [b3 [d2 EXT2]].

               assert (Nu'b1: as_inj nu' b1 = Some (b3, delta+d2)).

                      rewrite ID. eapply compose_meminjI_Some; try eassumption.

                             apply inc12. eassumption.

                             apply inc23. apply (extern_in_all _ _ _ _ EXT2).

                  assert (MV:= Mem.mi_memval _ _ _

                                 (Mem.mi_inj _ _ _ MemInjNu') _ _ _ _ Nu'b1 H0).

                  inv MV; try constructor.

                           simpl.

                           rewrite ID in H4.

                           destruct (compose_meminjD_Some _ _ _ _ _ H4)

                              as [bb2 [dd1 [dd2 [JJ1 [JJ2 Delta]]]]].

                           rewrite JJ1. econstructor.

                             apply JJ1. reflexivity.

         

            specialize (H2 (ofs + delta)).

            assert (J12: as_inj nu12 b1 = None).

               remember (as_inj nu12 b1) as d.

               destruct d; apply eq_sym in Heqd; trivial.

                     destruct p. rewrite (inc12 _ _ _ Heqd) in H. inv H.

                     exfalso. apply H1. apply (VBj12_2 _ _ _ Heqd).

            assert (MX: Mem.perm m1' b1 ofs Max Nonempty).

                  eapply Mem.perm_max. eapply Mem.perm_implies.

                  apply H0. apply perm_any_N.

            rewrite (source_SomeI _ _  _ b1) in H2; try eassumption.

            rewrite H2; clear H2.

            remember (ZMap.get ofs (PMap.get b1 (Mem.mem_contents m1'))) as v.

            remember (j23' b2) as j23'b2.

                   destruct j23'b2; apply eq_sym in Heqj23'b2.

                   

                       destruct p as [b3 delta3].

                       assert (COMP': as_inj nu' b1 = Some(b3, delta+delta3)).

                            rewrite ID. eapply compose_meminjI_Some; eassumption.

                       assert (MV:= Mem.mi_memval _ _ _

                           (Mem.mi_inj _ _ _ MemInjNu') _ _  _ _ COMP' H0).

                       subst.

                       inv MV; try constructor.

                       simpl. rewrite ID in H5.

                       apply compose_meminjD_Some in H5.

                       destruct H5 as [bb1 [off1 [off [JJ1 [JJ2 Delta]]]]].

                       subst.

                       rewrite JJ1. econstructor. apply JJ1. trivial.

                   

                       subst.

                       unfold removeUndefs in H. rewrite J12 in H.

                       remember (as_inj nu' b1) as d.

                       destruct d; try inv H.

                       destruct p.

                       assert (VB2: Mem.valid_block m2' b2).

                           destruct (mkInjections_0 _ _ _ _ _ _ _ _ _ _ HeqMKI) as [XX | XX].

                             destruct XX as [? [? [? [? ?]]]]. subst. rewrite J12 in H4. discriminate.

                             destruct XX as [nn [? [? [? ?]]]].

                               destruct (mkInjections_3 _ _ _ _ _ _ _ _ _ _ HeqMKI _ _ _ H4) as [XX | [XX | XX]].

                                 rewrite XX in J12; discriminate.

                                 destruct XX as [? [? ?]]; subst. unfold Mem.valid_block. rewrite <- H6. xomega.

                                 destruct XX as [mm [[? ?] ?]]; subst.

                                 assert (Mem.valid_block m1' (Mem.nextblock m1 + mm)%positive).

                                   eapply VBj'. rewrite <- Heqd. reflexivity.

                                 clear - H2 H6 H7. unfold Mem.valid_block in *.

                                     rewrite <- H6. rewrite <- H2 in H7. clear H2 H6. xomega.

                       destruct (mkInjections_5 _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12_1 VBj12_2 VBj23_1 VBj' _ VB2 Heqj23'b2) as [[XXa XXb] | [[XXa XXb] | [nn [XXa XXb]]]].

                         contradiction.

                         assert (b1 = Mem.nextblock m1).

                           destruct (mkInjections_0 _ _ _ _ _ _ _ _ _ _ HeqMKI) as [ZZ | ZZ].

                             destruct ZZ as [? [? [? [? ?]]]]. subst. rewrite J12 in H4. discriminate.

                             destruct ZZ as [nn [? [? [? ?]]]]. subst.

                               destruct (mkInjections_3 _ _ _ _ _ _ _ _ _ _ HeqMKI _ _ _ H4) as [AA | [AA | AA]].

                                 rewrite AA in J12; discriminate.

                                 destruct AA as [? [? ?]]; subst. trivial.

                                 destruct AA as [mm [[? ?] ?]]; subst. clear - H8. exfalso. rewrite Pos.add_comm in H8. apply eq_sym in H8. eapply Pos.add_no_neutral. apply H8.

                           subst. rewrite XXb in Heqd. discriminate.

                         assert (b1 = (Mem.nextblock m1 + nn)%positive). clear Heqd.

                           destruct (mkInjections_0 _ _ _ _ _ _ _ _ _ _ HeqMKI) as [ZZ | ZZ].

                             destruct ZZ as [? [? [? [? ?]]]]. subst. rewrite J12 in H4. discriminate.

                             destruct ZZ as [kk [? [? [? ?]]]]. subst.

                               destruct (mkInjections_3 _ _ _ _ _ _ _ _ _ _ HeqMKI _ _ _ H4) as [AA | [AA | AA]].

                                 rewrite AA in J12; discriminate.

                                 destruct AA as [? [? ?]]; subst. clear - H8. exfalso. rewrite Pos.add_comm in H8. eapply Pos.add_no_neutral. apply H8.

                                 destruct AA as [mm [[? ?] ?]]; subst.

                                    assert (nn=mm); subst; trivial. clear - H8. eapply Pos.add_reg_l. eassumption.

                           subst. rewrite XXb in Heqd. discriminate.

   split. apply INJ.

     intros b1 Hb1.

        remember (j12' b1) as d.

        destruct d; apply eq_sym in Heqd; trivial. destruct p.

        remember (as_inj nu12 b1) as dd.

        destruct dd; apply eq_sym in Heqdd.

            destruct p.

            exfalso. apply Hb1. apply Fwd1. apply (VBj12_1 _ _ _ Heqdd).

        remember (as_inj nu' b1) as ddd.

        destruct ddd; apply eq_sym in Heqddd.

            destruct p. exfalso. apply Hb1. apply (VBj' _ _ _ Heqddd).

        rewrite Heqj12' in Heqd.

        unfold removeUndefs in Heqd. rewrite Heqdd, Heqddd in Heqd.

        inv Heqd.

   intros.

     rewrite Heqj12' in H.

        unfold removeUndefs in H.

        remember (as_inj nu12 b) as dd.

        destruct dd; apply eq_sym in Heqdd.

            destruct p. inv H. apply Fwd2. apply (VBj12_2 _ _ _ Heqdd).

        remember (as_inj nu' b) as ddd.

        destruct ddd; apply eq_sym in Heqddd.

          destruct p.

          destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                      HeqMKI Val12 VBj23_1 _ _ _ H)

          as [MK | [MK | MK]].

            destruct MK as [J12 [Val1 Val2]]. apply Fwd2. apply Val2.

            destruct MK as [_ [_ [_ [_ D]]]]. apply D.

            destruct MK as [? [_ [_ [_ [_ D]]]]]. apply D.

        inv H.

  

       rewrite Heqj12'.

       apply (RU_no_overlap _ _ _ MInj12 _ Fwd1 _ _ MInj23 _ _ _ _ _ HeqMKI).

  

       intros.

       rewrite Heqj12' in H.

       unfold removeUndefs in H.

       remember (as_inj nu12 b) as d.

       destruct d; apply eq_sym in Heqd.

          destruct p. inv H.

          destruct H0.

          

            eapply MInj12. apply Heqd.

            left. apply Fwd1. apply (VBj12_1 _ _ _ Heqd). apply H.

          

            eapply MInj12. apply Heqd.

            right. apply Fwd1. apply (VBj12_1 _ _ _ Heqd). apply H.

       remember (as_inj nu' b) as dd.

       destruct dd; apply eq_sym in Heqdd.

          destruct p.

          destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                     HeqMKI VB12  VBj23_1 _ _ _ H).

              destruct H1. rewrite H1 in Heqd. discriminate.

              destruct H1 as [HH | HH].

              destruct HH as [A [B [C [D E]]]]; subst.

                 split. omega.

                        rewrite Zplus_0_r. apply Int.unsigned_range_2.

              destruct HH as [M [A [B [C [D E]]]]]; subst.

                 split. omega.

                        rewrite Zplus_0_r. apply Int.unsigned_range_2.

       inv H.

assert (ConvertR_J23': as_inj

     (convertR nu23 j23' (FreshDom (as_inj nu23) j23')

        (fun b : block => DomTgt nu' b && negb (DomTgt nu23 b))) = j23').

   clear ConvertL_J12'. unfold as_inj.

   rewrite convertR_extern, convertR_local.

   extensionality b. unfold join.

   remember (extern_of nu23 b) as d.

   destruct d; apply eq_sym in Heqd.

         destruct p. apply extern_in_all in Heqd.

         rewrite (inc23 _ _ _ Heqd). trivial.

   remember (local_of nu23 b) as q.

   destruct q; trivial; apply eq_sym in Heqq.

         destruct p.

         apply local_in_all in Heqq; trivial.

         rewrite (inc23 _ _ _ Heqq). trivial.

   destruct (j23' b); trivial. destruct p; trivial.

rewrite ConvertR_J23' in *.

  rewrite convertR_extern, convertR_frgnBlocksSrc,

          convertR_pubBlocksSrc, convertR_locBlocksSrc,

          convertR_extBlocksSrc.



assert (Inj23':Mem.inject j23' m2' m3').

  clear ConvertL_J12' ConvertR_J23'.

  assert (Perm23': forall b1 b2 delta ofs k p,

                j23' b1 = Some (b2, delta) ->

                Mem.perm m2' b1 ofs k p -> Mem.perm m3' b2 (ofs + delta) k p).

      intros b2 b3; intros.

      apply (valid_split _ _ _ _ (ACCESS b2)); intros; clear ACCESS.

      

        specialize (H2 k ofs).

        assert (FF: as_inj nu23 b2 = Some (b3, delta)).

           remember (as_inj nu23 b2) as dd.

           destruct dd; apply eq_sym in Heqdd.

             rewrite (inject_incr_coincide _ _ inc23 _ _ H _ Heqdd). trivial.

           destruct (sep23 _ _ _ Heqdd H). exfalso. apply (H3 H1).

        

        remember (locBlocksSrc nu23 b2) as LocB2.

        destruct LocB2; apply eq_sym in HeqLocB2.

        

          assert (extern_of nu23 b2 = None /\ local_of nu23 b2 = Some (b3, delta)).

            destruct (joinD_Some _ _ _ _ _ FF).

              destruct (extern_DomRng _ WDnu23 _ _ _ H3) as [? ?].

              destruct (disjoint_extern_local_Src _ WDnu23 b2); congruence.

            assumption.

          destruct H3 as [NoEXT23 LOC23].

          remember (pubBlocksSrc nu23 b2) as PubB2.

          destruct PubB2; apply eq_sym in HeqPubB2.

          

            destruct (pubSrc _ WDnu23 _ HeqPubB2) as [b33 [d33 [PUB23 pubTGT3]]].

            rewrite (pub_in_local _ _ _ _ PUB23) in LOC23. inv LOC23.

            remember (source (local_of nu12) m1 b2 ofs) as d.

            destruct d.

            

              destruct p0.

              destruct (source_SomeE _ _ _ _ _ Heqd)

                 as [b1 [d1 [ofs1 [PP [VB [ JJ [PERM Off2]]]]]]]. clear Heqd.

              subst. inv PP.

              rewrite <- Zplus_assoc.

                assert (J: as_inj nu' b1 = Some (b3, d1 + delta)).

                  rewrite ID.

                  eapply compose_meminjI_Some.

                     apply inc12. apply local_in_all; eassumption.

                     apply inc23. assumption.

              remember (pubBlocksSrc nu12 b1) as d.

              destruct d; apply eq_sym in Heqd;

                rewrite (perm_subst _ _ _ _ _ _ _ H2) in H0; clear H2.

                eapply MemInjNu'. apply J. apply H0.

              apply UnchLOOR13.

                 split. eapply (pub_locBlocks _ WDnu23). eassumption.

                 intros bb1; intros. simpl.

                 remember (pubBlocksSrc nu12 bb1) as d.

                 destruct d; try (right; reflexivity).

                 apply eq_sym in Heqd0. left. intros N.

                 destruct (eq_block bb1 b1); subst; simpl.

                   rewrite Heqd0 in Heqd. discriminate.

                 assert (compose_meminj (as_inj nu12) (as_inj nu23) b1 = Some (b3, d1+delta)).

                   eapply compose_meminjI_Some; try eassumption. apply local_in_all; eassumption.

                 destruct (compose_meminjD_Some _ _ _ _ _ H2) as [bb2 [dd1 [dd2 [LC1 [LC2 DD]]]]]; clear H2.

                   apply local_in_all in LC1; trivial.

                   apply local_in_all in LC2; trivial.  subst.

                   assert (compose_meminj (as_inj nu12) (as_inj nu23) bb1 = Some (b3, dd1 + dd2)).

                    eapply compose_meminjI_Some; try eassumption.

                 destruct (Mem.mi_no_overlap _ _ _ (Mem.inject_compose _ _ _ _ _ MInj12 MInj23) bb1 _ _ _ _ _ _ _ n H2 H3 N PERM).

                   apply H4; trivial.

                   apply H4; clear H4. omega.

                eapply VBj23_2; eassumption.

              rewrite Zplus_assoc. eapply MInj23; eassumption.

            

              rewrite (perm_subst _ _ _ _ _ _ _ H2) in H0; clear H2.

              assert (MX: Mem.perm m2 b2 ofs Max Nonempty).

                  eapply Mem.perm_max. eapply Mem.perm_implies.

                     apply H0. apply perm_any_N.

              assert (SRC:= source_NoneE _ _ _ _ Heqd); clear Heqd.

              apply UnchLOOR13.

                 split. eapply (pub_locBlocks _ WDnu23); eassumption.

                 intros bb1; intros. simpl.

                 remember (pubBlocksSrc nu12 bb1) as d.

                 destruct d; try (right; reflexivity).

                 apply eq_sym in Heqd. left.

                 simpl in H2.

                 destruct (compose_meminjD_Some _ _ _ _ _ H2) as [bb2 [dd1 [dd2 [LC1 [LC2 DD]]]]]; clear H2.

                 subst.

                 destruct (eq_block bb2 b2); subst.

                   rewrite (pub_in_local _ _ _ _ PUB23) in LC2. inv LC2.

                   assert (Mem.valid_block m1 bb1).

                     eapply VBj12_1. apply local_in_all; eassumption.

                   assert (Arith: ofs + dd2 - (dd1 + dd2) = ofs - dd1) by omega.

                   rewrite Arith. apply (SRC _ _ H2 LC1).

                 intros N. apply local_in_all in LC1; trivial.

                   apply (Mem.perm_inject (as_inj nu12) _ _ _ _ _ _ _ _ LC1 MInj12) in N.

                   apply local_in_all in LC2; trivial.

                   destruct (Mem.mi_no_overlap _ _ _ MInj23 bb2 _ _ _ _ _ _ _ n LC2 FF N MX).

                   apply H2; trivial.

                   apply H2; clear H2. omega.

                eapply VBj23_2; eassumption.

              eapply MInj23; eassumption.

          

            rewrite (perm_subst _ _ _ _ _ _ _ H2) in H0; clear H2.

              apply UNCHC.

                 split. eapply (local_locBlocks _ WDnu23). eassumption.

                 intros bb2; intros.

                 remember (pubBlocksSrc nu23 bb2) as d.

                 destruct d; try (right; reflexivity).

                 apply eq_sym in Heqd. left.

                 destruct (eq_block bb2 b2); subst.

                   rewrite Heqd in HeqPubB2; discriminate.

                 intros N. apply local_in_all in H2; trivial.

                   assert (MX: Mem.perm m2 b2 ofs Max Nonempty).

                     eapply Mem.perm_max. eapply Mem.perm_implies. eassumption. apply perm_any_N.

                   destruct (Mem.mi_no_overlap _ _ _ MInj23 bb2 _ _ _ _ _ _ _ n H2 FF N MX).

                   apply H3; trivial.

                   apply H3; clear H3. omega.

                eapply VBj23_2; eassumption.

              eapply MInj23; eassumption.

        

          remember (source (as_inj nu12) m1 b2 ofs) as ss.

          destruct ss.

            destruct (source_SomeE _ _ _ _ _ Heqss)

                 as [b1 [d1 [ofs1 [PP [VB [ JJ [PERM Off2]]]]]]]. clear Heqss.

            subst.

            rewrite (perm_subst _ _ _ _ _ _ _ H2) in H0. clear H2.

            rewrite <- Zplus_assoc.

            eapply MemInjNu'; try eassumption.

              rewrite ID. eapply compose_meminjI_Some.

                     apply inc12. apply JJ.

                     apply inc23. assumption.

          

            rewrite FF in H2.

            unfold Mem.perm in H0. rewrite H2 in H0. simpl in H0. contradiction.

            
          assert (MX: Mem.perm m2' b2 ofs Max Nonempty).

              eapply Mem.perm_max. eapply Mem.perm_implies.

                apply H0. apply perm_any_N.

          assert (Max2':= H2 Max ofs).

          specialize (H2 k ofs).

          assert (J23: as_inj nu23 b2 = None).

              remember (as_inj nu23 b2) as d.

              destruct d; trivial. apply eq_sym in Heqd. destruct p0.

              assert (X:= VBj23_1 _ _ _ Heqd).

              exfalso.  apply (H1 X).

          remember (source j12' m1' b2 ofs) as d.

          destruct d. destruct p0.

              rewrite (perm_subst _ _ _ _ _ _ _ H2) in *; clear H2.

              rewrite (perm_subst _ _ _ _ _ _ _ Max2') in *; clear Max2'.

              destruct (source_SomeE _ _ _ _ _ Heqd)

                as [b1 [d1 [ofs1 [PP [VB [ JJ' [PERM Off2]]]]]]]; clear Heqd.

              subst. apply eq_sym in PP. inv PP.

              rewrite <- Zplus_assoc.

              assert (Jb: as_inj nu' b= Some (b3, d1 + delta)).

                  rewrite ID.

                  eapply compose_meminjI_Some; eassumption.

              eapply MemInjNu'. apply Jb. apply H0.

          unfold Mem.perm in MX. rewrite Max2' in MX.  inv MX.

  assert (MI: Mem.mem_inj j23' m2' m3').

      split.

       apply Perm23'.

      

        intros b2 b3; intros.

          destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI VBj23_1 _ _ _ H)

            as [HH | [HH | HH]].

          destruct HH. eapply MInj23; try eassumption.

             intros z; intros. specialize (H0 _ H3).

              eapply Fwd2; try eassumption.

          destruct HH as [? [? ?]].

            assert (ZZ: compose_meminj j12' j23'  (Mem.nextblock m1) = Some (b3, delta)).

                   rewrite ID in H2; trivial.

            rewrite Heqj12' in ZZ. subst.

            destruct (compose_meminjD_Some _ _ _ _ _ ZZ) as

                  [b2 [dd1 [dd2 [JJ1 [JJ2 XX]]]]]; subst; clear ZZ.

            assert (J12': prej12' (Mem.nextblock m1) = Some(Mem.nextblock m2, 0)).

               remember (as_inj nu12 (Mem.nextblock m1)) as q.

               destruct q; apply eq_sym in Heqq.

                 destruct p0. rewrite (inc12 _ _ _ Heqq) in JJ1. inv JJ1.

                   apply VBj12_1 in Heqq. exfalso. unfold Mem.valid_block in Heqq. xomega.

                 unfold removeUndefs in JJ1. rewrite Heqq in JJ1. rewrite H2 in JJ1.

                 destruct (mkInjections_3V  _ _ _ _ _ _ _ _ _ _ HeqMKI VB12 VBj23_1 _ _ _ JJ1).

                   destruct H1. rewrite H1 in Heqq. discriminate.

                   destruct H1. destruct H1 as [_ [? [? [? ?]]]]. subst. assumption.

                   destruct H1 as [mm [? [? [? [? ?]]]]]; subst.

                     apply eq_sym in H1. rewrite Pos.add_comm in H1.

                     apply Pos.add_no_neutral in H1. intuition.

            assert (PRE: prej12' (Mem.nextblock m1) = Some (b2, dd1)).

              unfold removeUndefs in JJ1.

              remember (as_inj nu12 (Mem.nextblock m1)).

              destruct o; apply eq_sym in Heqo.

                destruct p0. apply VBj12_1 in Heqo. exfalso. unfold Mem.valid_block in Heqo. xomega.

              rewrite H2 in JJ1. assumption.

            rewrite J12' in PRE. inv PRE. simpl in *. clear JJ2.

            destruct (ACCESS (Mem.nextblock m2)) as [_ ZZ].

            assert (NVB2: ~ Mem.valid_block m2 (Mem.nextblock m2)).

                       unfold Mem.valid_block. xomega.

            assert (MR: Mem.range_perm m1' (Mem.nextblock m1) ofs (ofs + size_chunk chunk) Max p).

               intros z; intros.

               specialize (ZZ NVB2 Max z).

               remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1' (Mem.nextblock m2) z).

               destruct o.

               Focus 2. specialize (H0 _ H1). unfold Mem.perm in H0. rewrite ZZ in H0. simpl in H0. intuition.

               destruct (source_SomeE _ _ _ _ _ Heqo)

                        as [b1 [dd1 [ofs1 [PPP [VB [ JJ' [PERM Off2]]]]]]]; clear Heqo.

               subst. specialize (H0 _ H1).

               rewrite (perm_subst _ _ _ _ _ _ _ ZZ) in H0; clear ZZ.

               assert (prej12'  b1 = Some (Mem.nextblock m2, dd1)).

                 unfold removeUndefs in JJ'.

                 remember (as_inj nu12 b1).

                 destruct o; apply eq_sym in Heqo.

                   destruct p0. inv JJ'. apply VBj12_2 in Heqo. contradiction.

                 remember (as_inj nu' b1).

                 destruct o. destruct p0. assumption. inv JJ'.

               assert (b1 = Mem.nextblock m1).

                 destruct (mkInjections_3V  _ _ _ _ _ _ _ _ _ _ HeqMKI VB12 VBj23_1 _ _ _ H4).

                 destruct H5. apply VBj12_2 in H5. contradiction.

                 destruct H5. destruct H5; trivial.

                 destruct H5 as [mm1 [? [? [? [? ?]]]]]. subst.

                   apply eq_sym in H6. rewrite Pos.add_comm in H6.

                   apply Pos.add_no_neutral in H6. intuition.

               subst. rewrite J12' in H4. inv H4. rewrite Zplus_0_r. assumption.

             eapply MemInjNu'; eassumption.

          destruct HH as [mm [? [? ?]]]. subst. clear H3.

            assert (ZZ: compose_meminj (removeUndefs (as_inj nu12) (as_inj nu') prej12') j23' ((Mem.nextblock m1+ mm)%positive) = Some (b3, delta)).

                   rewrite <- ID; trivial.

               destruct (compose_meminjD_Some _ _ _ _ _ ZZ) as

                  [b2 [dd1 [dd2 [JJ1 [JJ2 XX]]]]]. subst; clear ZZ.

            assert (J12': prej12' ((Mem.nextblock m1+ mm)%positive) = Some((Mem.nextblock m2+ mm)%positive, 0)).

               remember (as_inj nu12 ((Mem.nextblock m1+ mm)%positive)) as q.

               destruct q; apply eq_sym in Heqq.

                 destruct p0. rewrite (inc12 _ _ _ Heqq) in JJ1. inv JJ1.

                   apply VBj12_1 in Heqq. exfalso. unfold Mem.valid_block in Heqq. xomega.

                 unfold removeUndefs in JJ1. rewrite Heqq in JJ1. rewrite H2 in JJ1.

                 destruct (mkInjections_3V  _ _ _ _ _ _ _ _ _ _ HeqMKI VB12 VBj23_1 _ _ _ JJ1).

                   destruct H1. rewrite H1 in Heqq. discriminate.

                   destruct H1. destruct H1 as [? [? [? [? ?]]]]. subst.

                     rewrite Pos.add_comm in H1.

                     apply Pos.add_no_neutral in H1. intuition.

                   destruct H1 as [mm2 [? [? [? [? ?]]]]]; subst.

                     apply Pos.add_reg_l in H1. subst.

                   assumption.

            assert (PRE: prej12' ((Mem.nextblock m1+ mm)%positive) = Some (b2, dd1)).

              unfold removeUndefs in JJ1.

              remember (as_inj nu12 ((Mem.nextblock m1+ mm)%positive)).

              destruct o; apply eq_sym in Heqo.

                destruct p0. apply VBj12_1 in Heqo. exfalso. unfold Mem.valid_block in Heqo. xomega.

              rewrite H2 in JJ1. assumption.

            rewrite J12' in PRE. inv PRE. simpl in *. clear JJ2.

            destruct (ACCESS ((Mem.nextblock m2+ mm)%positive)) as [_ ZZ].

            assert (NVB2: ~ Mem.valid_block m2 ((Mem.nextblock m2+ mm)%positive)).

                       unfold Mem.valid_block. xomega.

            assert (MR: Mem.range_perm m1' ((Mem.nextblock m1+ mm)%positive) ofs (ofs + size_chunk chunk) Max p).

               intros z; intros.

               specialize (ZZ NVB2 Max z).

               remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1'

                      (Mem.nextblock m2 + mm)%positive z).

               destruct o.

               Focus 2. specialize (H0 _ H1). unfold Mem.perm in H0. rewrite ZZ in H0. simpl in H0. intuition.

               destruct (source_SomeE _ _ _ _ _ Heqo)

                        as [bb1 [dd1 [ofs11 [PPP [VB [ JJ' [PERM Off2]]]]]]]. clear Heqo.

               subst. specialize (H0 _ H1).

               rewrite (perm_subst _ _ _ _ _ _ _ ZZ) in H0. clear ZZ.

               assert (prej12'  bb1 = Some ((Mem.nextblock m2+ mm)%positive, dd1)).

                 unfold removeUndefs in JJ'.

                 remember (as_inj nu12 bb1).

                 destruct o; apply eq_sym in Heqo.

                   destruct p0. inv JJ'. apply VBj12_2 in Heqo. contradiction.

                 remember (as_inj nu' bb1).

                 destruct o. destruct p0. assumption. inv JJ'.

               assert (bb1 = (Mem.nextblock m1+ mm)%positive).

                 destruct (mkInjections_3V  _ _ _ _ _ _ _ _ _ _ HeqMKI VB12 VBj23_1 _ _ _ H3).

                 destruct H4. apply VBj12_2 in H4. contradiction.

                 destruct H4. destruct H4 as [? [? ?]]; subst.

                   rewrite Pos.add_comm in H5.

                   apply Pos.add_no_neutral in H5. intuition.

                 destruct H4 as [mm1 [? [? [? [? ?]]]]]. subst.

                   apply Pos.add_reg_l in H5. subst. trivial.

               subst. rewrite J12' in H3. inv H3. rewrite Zplus_0_r. assumption.

             eapply MemInjNu'; eassumption.

       intros b2 ofs2 b3 delta3 Jb2 Perm2.

          assert (Perm2Max: Mem.perm m2' b2 ofs2  Max Nonempty).

             eapply Mem.perm_max. eapply Mem.perm_implies.

                        apply Perm2. constructor.

          destruct (ACCESS b2) as [Valid Invalid].

          apply (cont_split _ _ _ _ _ (CONT b2)); intros; clear CONT.

          

             assert (ValidMax := Valid H Max ofs2).

             specialize (Valid H Cur ofs2). clear Invalid.

             specialize (H0 ofs2).

             assert (J23: as_inj nu23 b2 = Some (b3, delta3)).

                 remember (as_inj nu23 b2) as d. destruct d; apply eq_sym in Heqd.

                    destruct p. rewrite (inc23 _ _ _ Heqd) in Jb2. apply Jb2.

                    destruct (sep23 _ _ _ Heqd Jb2). exfalso. apply (H2 H).

             rewrite J23 in Valid, ValidMax. 

             remember (locBlocksSrc nu23 b2) as LocB2.

             destruct LocB2; apply eq_sym in HeqLocB2.

               assert (LOC23: local_of nu23 b2 = Some (b3, delta3)).

                  destruct (joinD_Some _ _ _ _ _ J23) as [EXT | [EXT LOC]]; trivial.

                  destruct (extern_DomRng _ WDnu23 _ _ _ EXT).

                  destruct (disjoint_extern_local_Src _ WDnu23 b2); congruence.

               remember (pubBlocksSrc nu23 b2) as PubB2.

               destruct PubB2; apply eq_sym in HeqPubB2.

                 remember (source (local_of nu12) m1 b2 ofs2) as ss.

                 destruct ss.

                 

                   destruct (source_SomeE _ _ _ _ _ Heqss)

                     as [b1 [delta2 [ofs1 [PP [Valb1 [ Jb1 [Perm1 Off]]]]]]].

                   clear Heqss; subst.

                     assert (J': as_inj nu' b1 = Some (b3, delta2 + delta3)).

                       rewrite ID. eapply compose_meminjI_Some; try eassumption.

                        apply inc12. apply local_in_all; eassumption.

                   remember (pubBlocksSrc nu12 b1) as d.

                   destruct d; apply eq_sym in Heqd.

                   

                     rewrite (perm_subst _ _ _ _ _ _ _ Valid) in Perm2; clear Valid.

                     rewrite (perm_subst _ _ _ _ _ _ _ ValidMax) in Perm2Max; clear ValidMax.

                     rewrite H0 in *; clear H0. simpl in *.

                     assert (Perm1'Max: Mem.perm m1' b1 ofs1 Max Nonempty).

                       eapply Mem.perm_max; eassumption.

                     specialize (Mem.mi_memval _ _ _

                          (Mem.mi_inj _ _ _ MemInjNu') _ _  _ _ J' Perm2).

                     intros MemVal13'.

                     rewrite <- Zplus_assoc.

                     inv MemVal13'; simpl in *; try econstructor.

                        rewrite ID in H3.

                        destruct (compose_meminjD_Some _ _ _ _ _ H3)

                           as [bb2 [dd2 [dd3 [RR [JJ23  DD]]]]]; subst; clear H3.

                        rewrite RR. econstructor. eassumption.

                          rewrite Int.add_assoc. decEq. unfold Int.add.

                          apply Int.eqm_samerepr. auto with ints.

                   

                     rewrite (perm_subst _ _ _ _ _ _ _ Valid) in Perm2; clear Valid.

                     rewrite (perm_subst _ _ _ _ _ _ _ ValidMax) in Perm2Max; clear ValidMax.

                     rewrite H0 in *; clear H0. simpl in *.

                     destruct UnchLOOR13 as [UP3 UV3].

                     rewrite UV3.

                       eapply memval_inject_incr. eapply MInj23. assumption. assumption. assumption.

                     split; simpl. eapply local_locBlocks; eassumption.

                       intros. destruct (compose_meminjD_Some _ _ _ _ _ H0) as [bb2 [dd1 [dd2 [LC12 [LC23 DD]]]]]; clear H0.

                         subst.

                         destruct (eq_block b0 b1); subst.

                           right; assumption.

                         remember (pubBlocksSrc nu12 b0) as d.

                         destruct d; try (right; reflexivity).

                         left; apply eq_sym in Heqd.

                         intros N.

                         assert (compose_meminj (as_inj nu12) (as_inj nu23) b0 = Some(b3,dd1+dd2)).

                            apply local_in_all in LC12; trivial.

                            apply local_in_all in LC23; trivial.

                            eapply compose_meminjI_Some; eassumption.

                         assert (compose_meminj (as_inj nu12) (as_inj nu23) b1 = Some(b3,delta2+delta3)).

                            apply local_in_all in Jb1; trivial.

                            eapply compose_meminjI_Some; eassumption.

                         destruct (Mem.mi_no_overlap _ _ _ (Mem.inject_compose _ _ _ _ _ MInj12 MInj23)

                                  _ _ _ _ _ _ _ _ n H0 H2 N Perm1).

                           apply H3; trivial.

                           apply H3; clear H3. omega.

                     eapply MInj23; eassumption.

                 

                   rewrite H0. clear H0.

                   rewrite (perm_subst _ _ _ _ _ _ _ Valid) in Perm2. clear Valid.

                   rewrite (perm_subst _ _ _ _ _ _ _ ValidMax) in Perm2Max. clear ValidMax.

                   assert (LOOR: local_out_of_reach

                                (compose_sm nu12 nu23) m1 b3 (ofs2+delta3)).

                     split; simpl. eapply (local_DomRng _ WDnu23); eassumption.

                     intros.

                     destruct (compose_meminjD_Some _ _ _ _ _ H0) as [bb2 [dd1 [dd2 [LC12 [LC23 D]]]]]; clear H0.

                     rewrite D in *; clear delta D.

                     destruct (eq_block bb2 b2); subst.

                     

                         rewrite LC23 in LOC23. inv LOC23.

                         assert (Arith: ofs2 + delta3 - (dd1 + delta3) = ofs2 - dd1) by omega.

                         rewrite Arith. left.

                         apply (source_NoneE _ _ _ _ Heqss).

                             apply local_in_all in LC12; trivial. apply (VBj12_1 _ _ _ LC12).

                             assumption.

                     

                         remember (pubBlocksSrc nu12 b0) as d.

                         destruct d; try (right; reflexivity).

                         left; apply eq_sym in Heqd.

                         intros N.

                         assert (NN2: Mem.perm m2 bb2

                                     (ofs2 + (delta3 - dd2)) Max Nonempty).

                             assert (Arith: ofs2 + delta3 - (dd1 + dd2) + dd1 =

                                      ofs2 + (delta3 - dd2)) by omega.

                             rewrite <- Arith.

                             eapply MInj12; try eassumption.

                               apply local_in_all; assumption.

                         apply local_in_all in LC23; trivial.

                         destruct (Mem.mi_no_overlap _ _ _

                                 MInj23 _ _ _ _ _ _ _ _ n LC23 J23 NN2 Perm2Max).

                                     apply H0; trivial.

                                     apply H0. omega.

                   assert (Perm3: Mem.perm m3 b3 (ofs2+delta3) Cur Readable).

                     eapply MInj23. apply J23. apply Perm2.

                   destruct UnchLOOR13 as [Uperm UVal].

                   rewrite (UVal _ _ LOOR Perm3).

                   eapply memval_inject_incr.

                     apply (Mem.mi_memval _ _ _

                            (Mem.mi_inj _ _ _  MInj23) _ _ _ _ J23 Perm2).

                     apply inc23.

               

                 rewrite H0. clear H0.

                 rewrite (perm_subst _ _ _ _ _ _ _ Valid) in Perm2. clear Valid.

                 rewrite (perm_subst _ _ _ _ _ _ _ ValidMax) in Perm2Max. clear ValidMax.

                 assert (LOOR: local_out_of_reach nu23 m2 b3 (ofs2+delta3)).

                  split; simpl. eapply (local_DomRng _ WDnu23); eassumption.

                     intros bb2; intros.

                     destruct (eq_block bb2 b2); subst.

                      right; assumption.

                     

                         remember (pubBlocksSrc nu23 bb2) as d.

                         destruct d; try (right; reflexivity).

                         left; apply eq_sym in Heqd.

                         intros N.

                         apply local_in_all in H0; trivial.

                         destruct (Mem.mi_no_overlap _ _ _

                                 MInj23 _ _ _ _ _ _ _ _ n H0 J23 N Perm2Max).

                                     apply H2; trivial.

                                     apply H2. omega.

                   assert (Perm3: Mem.perm m3 b3 (ofs2+delta3) Cur Readable).

                     eapply MInj23. apply J23. apply Perm2.

                   destruct UNCHC as [Uperm UVal].

                   rewrite (UVal _ _ LOOR Perm3).

                   eapply memval_inject_incr.

                     apply (Mem.mi_memval _ _ _

                            (Mem.mi_inj _ _ _  MInj23) _ _ _ _ J23 Perm2).

                     apply inc23.

             

                 remember (source (as_inj nu12) m1 b2 ofs2) as ss.

                 destruct ss.

                 

                   destruct (source_SomeE _ _ _ _ _ Heqss)

                     as [b1 [delta2 [ofs1 [PP [Valb1 [ Jb1 [Perm1 Off]]]]]]].

                   clear Heqss; subst.

                   rewrite (perm_subst _ _ _ _ _ _ _ Valid) in Perm2; clear Valid.

                   rewrite (perm_subst _ _ _ _ _ _ _ ValidMax) in Perm2Max; clear ValidMax.

                   rewrite H0; clear H0; simpl in *.

                   assert (J': as_inj nu' b1 = Some (b3, delta2 + delta3)).

                       rewrite ID. eapply compose_meminjI_Some; try eassumption.

                        apply inc12. eassumption.

                   specialize (Mem.mi_memval _ _ _

                          (Mem.mi_inj _ _ _ MemInjNu') _ _  _ _ J' Perm2).

                   intros MemVal13'.

                   rewrite <- Zplus_assoc.

                   inv MemVal13'; simpl in *; try econstructor.

                      rewrite ID in H3.

                        destruct (compose_meminjD_Some _ _ _ _ _ H3)

                           as [bb2 [dd2 [dd3 [RR [JJ23  DD]]]]]; subst; clear H3.

                        rewrite RR. econstructor. eassumption.

                          rewrite Int.add_assoc. decEq. unfold Int.add.

                          apply Int.eqm_samerepr. auto with ints.

                 

                   rewrite H0; clear H0.

                   unfold Mem.perm in Perm2Max, Perm2.

                   rewrite Valid in Perm2; clear Valid.

                   simpl in Perm2. contradiction.

          

             specialize (H0 ofs2). clear Valid.

             assert (InvalidMax := Invalid H Max ofs2).

             specialize (Invalid H Cur ofs2).

             assert (J23: as_inj nu23 b2 = None).

                 remember (as_inj nu23 b2) as d.

                 destruct d; apply eq_sym in Heqd; trivial.

                    destruct p. rewrite (inc23 _ _ _ Heqd) in Jb2. inv Jb2.

                          exfalso. apply H. apply (VBj23_1 _ _ _ Heqd).

             remember (source j12' m1' b2 ofs2) as ss.

             destruct ss.

             

                 destruct p. rewrite H0 in *. clear H0.

                 rewrite (perm_subst _ _ _ _ _ _ _ Invalid) in Perm2; clear Invalid.

                 rewrite (perm_subst _ _ _ _ _ _ _ InvalidMax) in Perm2Max; clear InvalidMax.

                 destruct (source_SomeE _ _ _ _ _ Heqss)

                    as [b1 [delta2 [ofs1 [PP [VB [RR1 [Perm1' Off2]]]]]]].

                 clear Heqss.

                 inv PP.

                 assert (JB: as_inj nu' b1 = Some (b3, delta2 + delta3)).

                       rewrite ID. eapply compose_meminjI_Some; try eassumption.

                 specialize (Mem.mi_memval _ _ _

                       (Mem.mi_inj _ _ _  MemInjNu') _ _  _ _ JB Perm2).

                 intros MemVal13'.

                 rewrite <- Zplus_assoc.

                 inv MemVal13'; simpl in *; try econstructor.

                 rewrite ID in H3.

                 destruct (compose_meminjD_Some _ _ _ _ _ H3)

                       as [bb2 [dd2 [ddd3 [RRR [JJJ23  DD]]]]]; subst.

                    rewrite RRR. econstructor. apply JJJ23.

                    rewrite Int.add_assoc. decEq. unfold Int.add.

                       apply Int.eqm_samerepr. auto with ints.

             

                 unfold Mem.perm in Perm2. rewrite Invalid in Perm2. inv Perm2.

   split; trivial.

   

       intros. remember (j23' b) as d.

       destruct d; apply eq_sym in Heqd; trivial.

       destruct p. exfalso.



       destruct (mkInjections_0 _ _ _ _ _ _ _ _ _ _ HeqMKI)

        as [HH | HH].

       destruct HH as [? [? [? [?  ?]]]]; subst.

         apply H. apply Fwd2. apply (VBj23_1 _ _ _ Heqd).

       destruct HH as [N [? [? [? ?]]]].

         destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI VBj23_1 _ _ _ Heqd)

            as [HH | [HH | HH]].

         destruct HH. apply H. apply Fwd2. apply H5.

         destruct HH as [? [? ?]]; subst.

            apply (H H6).

         destruct HH as [M [BM [J' B]]]; subst.

            apply (H B).

   

      intros.

      destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI

        VBj23_1 _ _ _ H)as [HH | [HH | HH]].

      destruct HH. apply Fwd3. apply (VBj23_2 _ _ _  H0).

      destruct HH as [? [? ?]]; subst.

        eapply MemInjNu'. apply H1.

         destruct HH as [M [BM [J' B]]]; subst.

           eapply MemInjNu'. apply J'.

   

      intros b; intros.

      destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI

        VBj23_1 _ _ _ H0) as [HH | [HH | HH]].

      destruct HH as [j23b vbb].

         destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _

               HeqMKI VBj23_1 _ _ _ H1) as [KK | [KK | KK]].

            destruct KK as [j23b2 vbb2].

            eapply MInj23.

               apply H.

               apply j23b.

               apply j23b2.

               apply Fwd2. apply (VBj23_1 _ _ _ j23b). apply H2.

               apply Fwd2. apply (VBj23_1 _ _ _ j23b2). apply H3.

            destruct KK as [BM [J' B']]; subst.

              left. assert (as_inj nu23 (Mem.nextblock m2) = None).

                     remember (as_inj nu23 (Mem.nextblock m2)) as d.

                     destruct d; trivial.

                     destruct p. apply eq_sym in Heqd.

                     specialize (VBj23_1 _ _ _ Heqd).

                      clear - VBj23_1.

                      unfold Mem.valid_block in VBj23_1. xomega.

                   intros N; subst.

                    destruct (sep23 _ _ _ H4 H1). apply H6.

                    eapply MInj23. apply j23b.

            destruct KK as [M [BM [J' B']]].

            left. assert (as_inj nu23 b2 = None).

                     remember (as_inj nu23 b2) as d.

                     destruct d; trivial.

                     destruct p. apply eq_sym in Heqd.

                     specialize (VBj23_1 _ _ _ Heqd).

                     clear - VBj23_1 BM. subst.

                     unfold Mem.valid_block in VBj23_1. xomega.

                  intros N; subst.

                    destruct (sep23 _ _ _ H4 H1). apply H6.

                    eapply MInj23. apply j23b.

         destruct HH as [NBb [j'b NBb']]; subst.

           destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _

                HeqMKI VBj23_1 _ _ _ H1) as [KK | [KK | KK]].

            destruct KK as [j23b2 vbb2].

             left. assert (as_inj nu23 (Mem.nextblock m2) = None).

                      remember (as_inj nu23 (Mem.nextblock m2)) as d.

                      destruct d; trivial. destruct p.

                      apply eq_sym in Heqd.

                      specialize (VBj23_1 _ _ _ Heqd).

                      clear - VBj23_1.

                      unfold Mem.valid_block in VBj23_1. xomega.

                   intros N; subst.

                     destruct (sep23 _ _ _ H4 H0).

                     apply H6. eapply MInj23. apply j23b2.

            destruct KK as [BM [J' B']]; subst.

              exfalso. apply H; trivial.

            destruct KK as [M [BM [J' B']]]. subst.

          

              assert (j23_None1: as_inj nu23 (Mem.nextblock m2) = None).

                 remember (as_inj nu23 (Mem.nextblock m2)) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 unfold Mem.valid_block in VBj23_1. xomega.

              assert (j23_None2: as_inj nu23 ((Mem.nextblock m2 + M)%positive) = None).

                 remember (as_inj nu23 ((Mem.nextblock m2 + M)%positive)) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 exfalso. unfold Mem.valid_block in VBj23_1. xomega.

              destruct (sep23 _ _ _ j23_None1 H0) as [NV2_1 NV3_1].

              destruct (sep23 _ _ _ j23_None2 H1) as [NV2_2 NV3_2].

              assert (Max3_1:= Perm23' _ _ _ _ _ _ H0 H2).

              assert (Max3_2:= Perm23' _ _ _ _ _ _ H1 H3).

              assert (NEQ : Mem.nextblock m1 <> (Mem.nextblock m1 + M)%positive).

                 apply add_no_neutral2.

              destruct (ACCESS (Mem.nextblock m2)) as [_ Invalid1].

              specialize (Invalid1 NV2_1 Max ofs1).



              remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12')

                    m1' (Mem.nextblock m2) ofs1) as d.

              destruct d.

              

                 destruct p.

                 rewrite (perm_subst _ _ _ _ _ _ _ Invalid1) in H2.

                 clear Invalid1.

                 destruct (ACCESS  (Mem.nextblock m2 + M)%positive) as [_ Invalid2].

                 specialize (Invalid2 NV2_2 Max ofs2).



                 remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1'

                         (Mem.nextblock m2 + M)%positive ofs2) as d.

                 destruct d.

                 

                     destruct p.

                     rewrite (perm_subst _ _ _ _ _ _ _ Invalid2) in H3.

                     clear Invalid2.

                     rename b into b1. rename z into z1. rename b0 into b2.

                     rename z0 into z2.



                     destruct (source_SomeE _ _ _ _ _ Heqd)

                         as [bb1 [dd1 [ofs11 [PP [VB [ JJ' [PERM Off1]]]]]]].

                     clear Heqd. subst. apply eq_sym in PP. inv PP.

                     unfold removeUndefs in JJ'.

                     remember (as_inj nu12 b1) as q.

                     destruct q; apply eq_sym in Heqq.

                       destruct p. inv JJ'. exfalso. apply NV2_1.

                           apply (VBj12_2 _ _ _ Heqq).

                     remember (as_inj nu' b1) as qq.

                     destruct qq; inv JJ'. apply eq_sym in Heqqq.

                     destruct p.

                     destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                              HeqMKI VB12 VBj23_1 _ _ _ H5) as [HH | [HH |HH]].

                     destruct HH as [HH _]. rewrite HH in Heqq; discriminate.

                     destruct HH as [? [? [? [? ?]]]]; subst.

                       destruct (source_SomeE _ _ _ _ _ Heqd0) as

                           [bb2 [dd2 [ofs22 [PP2 [VB2 [ JJ2' [PERM2 Off2]]]]]]].

                       clear Heqd0. subst. apply eq_sym in PP2. inv PP2.

                       unfold removeUndefs in JJ2'.

                       remember (as_inj nu12 b2) as r.

                       destruct r; apply eq_sym in Heqr.

                           destruct p. inv JJ2'.

                           exfalso. apply NV2_2. apply (VBj12_2 _ _ _ Heqr).

                       remember (as_inj nu' b2) as rr.

                       destruct rr; inv JJ2'. apply eq_sym in Heqrr.

                       destruct p.

                       destruct (mkInjections_3V _ _ _ _ _ _ _ _

                                         _ _ HeqMKI VB12 VBj23_1 _ _ _ H7)

                           as [KK | [KK | KK]].

                         destruct KK as [KK _]. rewrite KK in Heqr; discriminate.

                         destruct KK as [? [? [? [? ?]]]]. subst.

                              exfalso. apply (Pos.add_no_neutral (Mem.nextblock m2) M).

                                 rewrite Pos.add_comm. apply H10.

                         destruct KK as [MM2 [BB2 [nbm

                                           [zz [X2 Y2]]]]]. subst.

                           apply Pos.add_reg_l in nbm. apply eq_sym in nbm.  subst.

                           eapply MemInjNu'.

                              apply NEQ.

                              assumption.

                              assumption.

                              rewrite Zplus_0_r. apply PERM.

                              rewrite Zplus_0_r. apply PERM2.

                     destruct HH as [MM1 [? [? [? [? ?]]]]]; subst.

                       exfalso. apply (add_no_neutral2 (Mem.nextblock m2) MM1).

                         apply H6.

                 

                    unfold Mem.perm in H3. rewrite Invalid2 in H3. inv H3.

                 

                    unfold Mem.perm in H2. rewrite Invalid1 in H2. inv H2.

         destruct HH as [M1 [? [j'b1 NBb1]]]; subst.

           destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _

                HeqMKI VBj23_1 _ _ _ H1) as [KK | [KK | KK]].

            destruct KK as [j23b2 vbb2].

             left. assert (as_inj nu23 (Mem.nextblock m2 + M1)%positive = None).

                      remember (as_inj nu23 (Mem.nextblock m2 + M1)%positive) as d.

                      destruct d; trivial. destruct p.

                      apply eq_sym in Heqd.

                      specialize (VBj23_1 _ _ _ Heqd).

                      clear - VBj23_1.

                      unfold Mem.valid_block in VBj23_1. xomega.

                   intros N; subst.

                     destruct (sep23 _ _ _ H4 H0).

                     apply H6. eapply MInj23. apply j23b2.

            destruct KK as [BM [J' B']]; subst.

          

              assert (j23_None1: as_inj nu23 (Mem.nextblock m2 + M1)%positive = None).

                 remember (as_inj nu23 (Mem.nextblock m2 + M1)%positive) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 unfold Mem.valid_block in VBj23_1. xomega.

              assert (j23_None2: as_inj nu23 (Mem.nextblock m2) = None).

                 remember (as_inj nu23 (Mem.nextblock m2)) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 exfalso. unfold Mem.valid_block in VBj23_1. xomega.

              destruct (sep23 _ _ _ j23_None1 H0) as [NV2_1 NV3_1].

              destruct (sep23 _ _ _ j23_None2 H1) as [NV2_2 NV3_2].

              assert (Max3_1:= Perm23' _ _ _ _ _ _ H0 H2).

              assert (Max3_2:= Perm23' _ _ _ _ _ _ H1 H3).

              assert (NEQ : (Mem.nextblock m1 + M1)%positive <> Mem.nextblock m1).

                rewrite Pos.add_comm. apply Pos.add_no_neutral.

              destruct (ACCESS (Mem.nextblock m2 + M1)%positive) as [_ Invalid1].

              specialize (Invalid1 NV2_1 Max ofs1).



              remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12')

                    m1' ((Mem.nextblock m2 +M1)%positive) ofs1) as d.

              destruct d.

              

                 destruct p.

                 rewrite (perm_subst _ _ _ _ _ _ _ Invalid1) in H2.

                 clear Invalid1.

                 destruct (ACCESS  (Mem.nextblock m2)) as [_ Invalid2].

                 specialize (Invalid2 NV2_2 Max ofs2).



                 remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1'

                         (Mem.nextblock m2) ofs2) as d.

                 destruct d.

                 

                     destruct p.

                     rewrite (perm_subst _ _ _ _ _ _ _ Invalid2) in H3.

                     clear Invalid2.

                     rename b into b1. rename z into z1. rename b0 into b2.

                     rename z0 into z2.



                     destruct (source_SomeE _ _ _ _ _ Heqd)

                         as [bb1 [dd1 [ofs11 [PP [VB [ JJ' [PERM Off1]]]]]]].

                     clear Heqd. subst. apply eq_sym in PP. inv PP.

                     unfold removeUndefs in JJ'.

                     remember (as_inj nu12 b1) as q.

                     destruct q; apply eq_sym in Heqq.

                       destruct p. inv JJ'. exfalso. apply NV2_1.

                           apply (VBj12_2 _ _ _ Heqq).

                     remember (as_inj nu' b1) as qq.

                     destruct qq; inv JJ'. apply eq_sym in Heqqq.

                     destruct p.

                     destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                              HeqMKI VB12 VBj23_1 _ _ _ H5) as [HH | [HH |HH]].

                     destruct HH as [HH _]. rewrite HH in Heqq; discriminate.

                     destruct HH as [? [? [? [? ?]]]]; subst.

                       exfalso. rewrite Pos.add_comm in H6.

                        apply Pos.add_no_neutral in H6. apply H6.

                     destruct HH as [MM1 [? [? [? [? ?]]]]]; subst.

                       apply Pos.add_reg_l in H6. apply eq_sym in H6. subst.

                       destruct (source_SomeE _ _ _ _ _ Heqd0) as

                           [bb2 [dd2 [ofs22 [PP2 [VB2 [ JJ2' [PERM2 Off2]]]]]]].

                       clear Heqd0. subst. apply eq_sym in PP2. inv PP2.

                       unfold removeUndefs in JJ2'.

                       remember (as_inj nu12 b2) as r.

                       destruct r; apply eq_sym in Heqr.

                           destruct p. inv JJ2'.

                           exfalso. apply NV2_2. apply (VBj12_2 _ _ _ Heqr).

                       remember (as_inj nu' b2) as rr.

                       destruct rr; inv JJ2'. apply eq_sym in Heqrr.

                       destruct p.

                       destruct (mkInjections_3V _ _ _ _ _ _ _ _

                                         _ _ HeqMKI VB12 VBj23_1 _ _ _ H6)

                           as [KK | [KK | KK]].

                         destruct KK as [KK _]. rewrite KK in Heqr; discriminate.

                         destruct KK as [? [? [? [? ?]]]]. subst.

                           eapply MemInjNu'.

                              apply NEQ.

                              assumption.

                              assumption.

                              rewrite Zplus_0_r. apply PERM.

                              rewrite Zplus_0_r. apply PERM2.



                         destruct KK as [MM2 [BB2 [nbm

                                           [zz [X2 Y2]]]]]. subst.

                           exfalso. apply (Pos.add_no_neutral (Mem.nextblock m2) MM2).

                                 rewrite Pos.add_comm. rewrite <- nbm. trivial.

                 

                    unfold Mem.perm in H3. rewrite Invalid2 in H3. inv H3.

                 

                    unfold Mem.perm in H2. rewrite Invalid1 in H2. inv H2.

            destruct KK as [M2 [BM [J2' B2']]]; subst.

          

              assert (j23_None1: as_inj nu23 (Mem.nextblock m2 + M1)%positive = None).

                 remember (as_inj nu23 (Mem.nextblock m2 + M1)%positive) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 unfold Mem.valid_block in VBj23_1. xomega.

              assert (j23_None2:  as_inj nu23 (Mem.nextblock m2 + M2)%positive = None).

                 remember (as_inj nu23 (Mem.nextblock m2 + M2)%positive) as d.

                 destruct d; trivial.

                 apply eq_sym in Heqd. destruct p.

                 specialize (VBj23_1 _ _ _ Heqd). clear - VBj23_1.

                 unfold Mem.valid_block in VBj23_1. xomega.

              destruct (sep23 _ _ _ j23_None1 H0) as [NV2_1 NV3_1].

              destruct (sep23 _ _ _ j23_None2 H1) as [NV2_2 NV3_2].

              assert (Max3_1:= Perm23' _ _ _ _ _ _ H0 H2).

              assert (Max3_2:= Perm23' _ _ _ _ _ _ H1 H3).

              assert (NEQ : (Mem.nextblock m1 + M1)%positive <> (Mem.nextblock m1 + M2)%positive).

                intros NN. apply Pos.add_cancel_l in NN. subst.

                apply H; trivial.

              destruct (ACCESS (Mem.nextblock m2 + M1)%positive) as [_ Invalid1].

              specialize (Invalid1 NV2_1 Max ofs1).



              remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12')

                    m1' ((Mem.nextblock m2 +M1)%positive) ofs1) as d.

              destruct d.

              

                 destruct p.

                 rewrite (perm_subst _ _ _ _ _ _ _ Invalid1) in H2.

                 clear Invalid1.

                 destruct (ACCESS  ((Mem.nextblock m2 + M2)%positive)) as [_ Invalid2].

                 specialize (Invalid2 NV2_2 Max ofs2).



                 remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12')  m1'

                         ((Mem.nextblock m2 + M2)%positive) ofs2) as d.

                 destruct d.

                 

                     destruct p.

                     rewrite (perm_subst _ _ _ _ _ _ _ Invalid2) in H3.

                     clear Invalid2.

                     rename b into b1. rename z into z1. rename b0 into b2.

                     rename z0 into z2.



                     destruct (source_SomeE _ _ _ _ _ Heqd)

                         as [bb1 [dd1 [ofs11 [PP [VB [ JJ' [PERM Off1]]]]]]].

                     clear Heqd. subst. apply eq_sym in PP. inv PP.

                     unfold removeUndefs in JJ'.

                     remember (as_inj nu12 b1) as q.

                     destruct q; apply eq_sym in Heqq.

                       destruct p. inv JJ'. exfalso. apply NV2_1.

                           apply (VBj12_2 _ _ _ Heqq).

                     remember (as_inj nu' b1) as qq.

                     destruct qq; inv JJ'. apply eq_sym in Heqqq.

                     destruct p.

                     destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _

                              HeqMKI VB12 VBj23_1 _ _ _ H5) as [HH | [HH |HH]].

                     destruct HH as [HH _]. rewrite HH in Heqq; discriminate.

                     destruct HH as [? [? [? [? ?]]]]; subst.

                       exfalso. rewrite Pos.add_comm in H6.

                        apply Pos.add_no_neutral in H6. apply H6.

                     destruct HH as [MM1 [? [? [? [? ?]]]]]; subst.

                       apply Pos.add_reg_l in H6. apply eq_sym in H6. subst.

                       destruct (source_SomeE _ _ _ _ _ Heqd0) as

                           [bb2 [dd2 [ofs22 [PP2 [VB2 [ JJ2' [PERM2 Off2]]]]]]].

                       clear Heqd0. subst. apply eq_sym in PP2. inv PP2.

                       unfold removeUndefs in JJ2'.

                       remember (as_inj nu12 b2) as r.

                       destruct r; apply eq_sym in Heqr.

                           destruct p. inv JJ2'.

                           exfalso. apply NV2_2. apply (VBj12_2 _ _ _ Heqr).

                       remember (as_inj nu' b2) as rr.

                       destruct rr; inv JJ2'. apply eq_sym in Heqrr.

                       destruct p.

                       destruct (mkInjections_3V _ _ _ _ _ _ _ _

                                         _ _ HeqMKI VB12 VBj23_1 _ _ _ H6)

                           as [KK | [KK | KK]].

                         destruct KK as [KK _]. rewrite KK in Heqr; discriminate.

                         destruct KK as [? [? [? [? ?]]]]. subst.

                           exfalso. apply (Pos.add_no_neutral (Mem.nextblock m2) M2).

                                 rewrite Pos.add_comm. trivial.



                         destruct KK as [MM2 [BB2 [nbm

                                           [zz [X2 Y2]]]]]. subst.

                           apply Pos.add_cancel_l in nbm. subst.

                           eapply MemInjNu'.

                              apply NEQ.

                              assumption.

                              assumption.

                              rewrite Zplus_0_r. apply PERM.

                              rewrite Zplus_0_r. apply PERM2.

                 

                    unfold Mem.perm in H3. rewrite Invalid2 in H3. inv H3.

                 

                    unfold Mem.perm in H2. rewrite Invalid1 in H2. inv H2.



    intros. rename b into b2.

       destruct (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI VBj23_1 _ _ _ H)

       as [HH | [ HH | HH]].

       

         destruct HH as [j23b2 Val2].

         destruct (ACCESS b2) as [Valid _].

         rewrite j23b2 in Valid.

         specialize (Valid Val2).

         remember (locBlocksSrc nu23 b2) as MyB2.

         destruct MyB2; apply eq_sym in HeqMyB2.

         

           remember (pubBlocksSrc nu23 b2) as PubB2.

           destruct PubB2; apply eq_sym in HeqPubB2.

           

             destruct H0.

             

               specialize (Valid Max (Int.unsigned ofs)).

               remember (source (local_of nu12) m1 b2 (Int.unsigned ofs)) as d.

               destruct d.

               

                 destruct p.

                 destruct (source_SomeE _ _ _ _ _ Heqd)

                   as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

                 clear Heqd. subst. apply eq_sym in PP. inv PP.

                 assert (PP2: Mem.perm m2 b2 (Int.unsigned ofs) Max Nonempty).

                   remember (pubBlocksSrc nu12 b) as PubB1.

                   destruct PubB1; apply eq_sym in HeqPubB1;

                   rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

                      rewrite Off1. eapply MInj12. apply local_in_all; eassumption. apply PERM.

                      assumption.

                 eapply MInj23. apply j23b2.

                   left. assumption.

               

                 rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

                 eapply MInj23. apply j23b2.

                 left. apply H0.

             

               specialize (Valid Max (Int.unsigned ofs -1)).

               remember (source (local_of nu12) m1 b2 (Int.unsigned ofs -1)) as d.

               destruct d.

               

                 destruct p.

                 destruct (source_SomeE _ _ _ _ _ Heqd)

                   as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

                 clear Heqd. subst. apply eq_sym in PP. inv PP.

                 assert (PP2: Mem.perm m2 b2 (Int.unsigned ofs -1) Max Nonempty).

                   remember (pubBlocksSrc nu12 b) as PubB1.

                   destruct PubB1; apply eq_sym in HeqPubB1;

                   rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

                      rewrite Off1. eapply MInj12. apply local_in_all; eassumption. apply PERM.

                      assumption.

                 eapply MInj23. apply j23b2.

                   right. assumption.

               

                 rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

                 eapply MInj23. apply j23b2.

                 right. apply H0.

           

             destruct H0.

             

               specialize (Valid Max (Int.unsigned ofs)).

               rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

               eapply MInj23. apply j23b2.

               left. apply H0.

             

               specialize (Valid Max (Int.unsigned ofs-1)).

               rewrite (perm_subst _ _ _ _ _ _ _ Valid) in H0; clear Valid.

               eapply MInj23. apply j23b2.

               right. apply H0.

         

             destruct H0.

             

               specialize (Valid Max (Int.unsigned ofs)).

               remember (source (as_inj nu12) m1 b2 (Int.unsigned ofs)) as d.

               destruct d.

               

                 destruct p.

                 destruct (source_SomeE _ _ _ _ _ Heqd)

                   as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

                 clear Heqd. subst. apply eq_sym in PP. inv PP.

                 assert (PP2: Mem.perm m2 b2 (Int.unsigned ofs) Max Nonempty).

                   rewrite Off1. eapply MInj12; eassumption.

                 eapply MInj23. apply j23b2.

                   left. assumption.

               

                 unfold Mem.perm in H0; rewrite Valid in H0; simpl in H0. contradiction.

             

               specialize (Valid Max (Int.unsigned ofs-1)).

               remember (source (as_inj nu12) m1 b2 (Int.unsigned ofs-1)) as d.

               destruct d.

               

                 destruct p.

                 destruct (source_SomeE _ _ _ _ _ Heqd)

                   as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

                 clear Heqd. subst. apply eq_sym in PP. inv PP.

                 assert (PP2: Mem.perm m2 b2 (Int.unsigned ofs-1) Max Nonempty).

                   rewrite Off1. eapply MInj12; eassumption.

                 eapply MInj23. apply j23b2.

                   right. assumption.

               

                 unfold Mem.perm in H0; rewrite Valid in H0; simpl in H0. contradiction.

       

         destruct HH as [? [j'b2 Val2']]. subst.

         destruct (ACCESS (Mem.nextblock m2)) as [_ InValid].

         assert (NVB2: ~Mem.valid_block m2 (Mem.nextblock m2)).

            unfold Mem.valid_block; xomega.

         specialize (InValid NVB2).

         destruct H0.

         

           specialize (InValid Max (Int.unsigned ofs)).

           remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1' (Mem.nextblock m2)

                            (Int.unsigned ofs)) as d.

           destruct d.

           

             destruct p.

             destruct (source_SomeE _ _ _ _ _ Heqd)

                 as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

             clear Heqd. subst. apply eq_sym in PP. inv PP.

             unfold removeUndefs in J12.

             case_eq (as_inj nu12 b); intros.

                destruct p; rewrite H1 in J12. inv J12.

                exfalso. apply NVB2. apply (VBj12_2 _ _ _ H1).

             rewrite H1 in J12.

             case_eq (as_inj nu' b); intros.

                destruct p; rewrite H2 in J12.

                destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI

                    VB12 VBj23_1 _ _ _ J12) as [KK | [KK |KK]].

                destruct KK as [KK _]; rewrite KK in H1; discriminate.

                destruct KK as [? [_ [? [? ?]]]]; subst.

                    rewrite Zplus_0_r in *. subst.

                    eapply MemInjNu'. apply j'b2. left; apply PERM.

                destruct KK as [m [_ [? _]]].

                    exfalso. clear -H3. apply (add_no_neutral2 _ _ H3).

             rewrite H2 in J12. inv J12.

           

             unfold Mem.perm in H0. rewrite InValid in H0.

             contradiction.

         

           specialize (InValid Max (Int.unsigned ofs-1)).

           remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1' (Mem.nextblock m2)

                            (Int.unsigned ofs-1)) as d.

           destruct d.

           

             destruct p.

             destruct (source_SomeE _ _ _ _ _ Heqd)

                 as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

             clear Heqd. subst. apply eq_sym in PP. inv PP.

             unfold removeUndefs in J12.

             case_eq (as_inj nu12 b); intros.

                destruct p; rewrite H1 in J12. inv J12.

                exfalso. apply NVB2. apply (VBj12_2 _ _ _ H1).

             rewrite H1 in J12.

             case_eq (as_inj nu' b); intros.

                destruct p; rewrite H2 in J12.

                destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI

                    VB12 VBj23_1 _ _ _ J12) as [KK | [KK |KK]].

                destruct KK as [KK _]; rewrite KK in H1; discriminate.

                destruct KK as [? [_ [? [? ?]]]]; subst.

                    rewrite Zplus_0_r in *. subst.

                    eapply MemInjNu'. apply j'b2. right; apply PERM.

                destruct KK as [m [_ [? _]]].

                    exfalso. clear -H3. apply (add_no_neutral2 _ _ H3).

             rewrite H2 in J12. inv J12.

           

             unfold Mem.perm in H0. rewrite InValid in H0.

             contradiction.

       

         destruct HH as [m [? [j'b2 Val2']]]; subst.

         destruct (ACCESS ((Mem.nextblock m2+m)%positive)) as [_ InValid].

         assert (NVB2: ~Mem.valid_block m2 ((Mem.nextblock m2+m)%positive)).

            unfold Mem.valid_block; xomega.

         destruct H0.

         

           specialize (InValid NVB2 Max (Int.unsigned ofs)).

           remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1'

                            ((Mem.nextblock m2+m)%positive)

                            (Int.unsigned ofs)) as d.

           destruct d.

           

             destruct p.

             destruct (source_SomeE _ _ _ _ _ Heqd)

                 as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

             clear Heqd. subst. apply eq_sym in PP. inv PP.

             unfold removeUndefs in J12.

             case_eq (as_inj nu12 b); intros.

                destruct p; rewrite H1 in J12. inv J12.

                exfalso. apply NVB2. apply (VBj12_2 _ _ _ H1).

             rewrite H1 in J12.

             case_eq (as_inj nu' b); intros.

                destruct p; rewrite H2 in J12.

                destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI

                    VB12 VBj23_1 _ _ _ J12) as [KK | [KK |KK]].

                destruct KK as [KK _]; rewrite KK in H1; discriminate.

                destruct KK as [? [? [? [? ?]]]]; subst.

                    exfalso. clear -H4. apply eq_sym in H4.

                    apply (add_no_neutral2 _ _ H4).

                destruct KK as [mm [? [? [? [? ?]]]]]. subst.

                   assert (mm = m).

                      clear -H4.

                      apply Pos.add_reg_l in H4.

                      subst; trivial.

                   rewrite Zplus_0_r in *. subst.

                   eapply MemInjNu'. apply j'b2. left. apply PERM.

             rewrite H2 in J12. inv J12.

           

             unfold Mem.perm in H0. rewrite InValid in H0.

             contradiction.

         

           specialize (InValid NVB2 Max (Int.unsigned ofs-1)).

           remember (source (removeUndefs (as_inj nu12) (as_inj nu') prej12') m1'

                            ((Mem.nextblock m2+m)%positive)

                            (Int.unsigned ofs-1)) as d.

           destruct d.

           

             destruct p.

             destruct (source_SomeE _ _ _ _ _ Heqd)

                 as [b1 [delta1 [ofs1 [PP [VB [ J12 [PERM Off1]]]]]]].

             clear Heqd. subst. apply eq_sym in PP. inv PP.

             unfold removeUndefs in J12.

             case_eq (as_inj nu12 b); intros.

                destruct p; rewrite H1 in J12. inv J12.

                exfalso. apply NVB2. apply (VBj12_2 _ _ _ H1).

             rewrite H1 in J12.

             case_eq (as_inj nu' b); intros.

                destruct p; rewrite H2 in J12.

                destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI

                    VB12 VBj23_1 _ _ _ J12) as [KK | [KK |KK]].

                destruct KK as [KK _]; rewrite KK in H1; discriminate.

                destruct KK as [? [? [? [? ?]]]]; subst.

                    exfalso. clear -H4. apply eq_sym in H4.

                    apply (add_no_neutral2 _ _ H4).

                destruct KK as [mm [? [? [? [? ?]]]]]. subst.

                   assert (mm = m).

                      clear -H4.

                      apply Pos.add_reg_l in H4.

                      subst; trivial.

                   rewrite Zplus_0_r in *. subst.

                   eapply MemInjNu'. apply j'b2. right. apply PERM.

             rewrite H2 in J12. inv J12.

           

             unfold Mem.perm in H0. rewrite InValid in H0.

             contradiction.



specialize (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI Val12 Val23).

intros mkiVal3.

specialize (mkInjections_4Val _ _ _ _ _ _ _ _ _ _ HeqMKI Val23). intros mkiVal4.

specialize (mkInjections_5 _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12_1 VBj12_2 VBj23_1 VBj'). intros mkiVal5.

clear CONT ACCESS HeqMKI.

assert (GOAL1: nu' =

compose_sm

  (convertL nu12 j12'

     (fun b : block => DomSrc nu' b && negb (DomSrc nu12 b))

     (FreshDom (as_inj nu23) j23'))

  (convertR nu23 j23' (FreshDom (as_inj nu23) j23')

     (fun b : block => DomTgt nu' b && negb (DomTgt nu23 b)))).

  destruct ExtIncr as [AA [BB [CC [DD [EE [FF [GG [HH [II JJ]]]]]]]]]; simpl in *.

  unfold compose_sm; simpl in *. clear ConvertL_J12'. clear ConvertR_J23'.

  rewrite convertL_extern, convertL_local, convertL_frgnBlocksSrc,

          convertL_pubBlocksSrc, convertL_locBlocksSrc, convertL_extBlocksSrc.

  rewrite convertR_extern, convertR_local, convertR_frgnBlocksTgt,

          convertR_pubBlocksTgt, convertR_locBlocksTgt, convertR_extBlocksTgt.

  destruct nu' as [locBSrc' locBTgt' pSrc' pTgt' local' extBSrc' extBTgt' fSrc' fTgt' extern'].

  simpl in *. unfold as_inj in *; simpl in *.

  f_equal; simpl; subst; simpl in *; trivial.

  

     extensionality b.

     specialize (disjoint_extern_local_Src _ WDnu' b). intros.

     unfold DomSrc, DomTgt in *; simpl in *.

     specialize (CC b).

     clear - CC H.

     remember (locBlocksSrc nu12 b) as q.

     remember (extBlocksSrc nu12 b) as t.

     destruct q; destruct t; simpl in *; intuition.

     rewrite andb_true_r. trivial.

     rewrite andb_true_r. trivial.

  

     extensionality b.

     specialize (disjoint_extern_local_Tgt _ WDnu' b). intros.

     unfold DomSrc, DomTgt in *; simpl in *.

     specialize (DD b).

     clear - DD H.

     remember (locBlocksTgt nu23 b) as q.

     remember (extBlocksTgt nu23 b) as t.

     destruct q; destruct t; simpl in *; intuition.

     rewrite andb_true_r. trivial.

     rewrite andb_true_r. trivial.

  

     clear Inj12' NOVj12' Inj23' UNCHC MemInjNu' Fwd2 MInj23 Fwd1 MInj12 UnchPrivSrc UnchLOOR13 VBj'

           Fwd1 Fwd3 SMV12 SMV23 SMvalNu' InjSep VBj23_2 sep23 NB1 SMInjSep

           VBj23' Val12 Val23 mkiVal3 m3 m1' m3'.

     extensionality b1.

     remember (extern' b1) as d.

     destruct d; apply eq_sym in Heqd.

     

       destruct p as [b3 delta].

       assert (J: join extern' (compose_meminj (local_of nu12) (local_of nu23)) b1 = Some (b3, delta)).

         apply join_incr_left. apply Heqd.

       rewrite ID in J; clear ID.

       destruct (compose_meminjD_Some _ _ _ _ _ J)

        as [b2 [d1 [d2 [J1 [J2 D]]]]]; subst; clear J.

       apply eq_sym.

       eapply compose_meminjI_Some with (b2:=b2).

       

         remember (extern_of nu12 b1) as q.

         destruct q; apply eq_sym in Heqq.

         

           destruct p as [bb2 dd1].

           unfold join. rewrite Heqq.

           apply extern_in_all in Heqq.

           apply inc12 in Heqq. unfold as_inj in Heqq. simpl in *.

             rewrite Heqq in J1. apply J1.

         

           unfold join. rewrite Heqq.

           remember (local_of nu12 b1) as w.

           destruct w; trivial; apply eq_sym in Heqw.

           destruct p as [bb dd].

           assert (locBlocksSrc nu12 b1 = true).

             eapply local_locBlocks; eassumption.

           assert (locBlocksSrc nu12 b1 = false).

             eapply (extern_DomRng' _ WDnu'). simpl. apply Heqd.

           rewrite H0 in H. inv H.

       

         unfold join.

         remember (extern_of nu23 b2) as q.

         destruct q; apply eq_sym in Heqq.

           destruct p.

           rewrite (inject_incr_coincide _ _ inc23 _ _ J2 _

               (extern_in_all _ _ _ _ Heqq)). trivial.

         remember (local_of nu23 b2) as w.

         destruct w; apply eq_sym in Heqw; trivial.

         destruct p.

         assert (E:= inject_incr_coincide _ _ inc23 _ _ J2 _

               (local_in_all _ WDnu23 _ _ _ Heqw)); inv E.

         assert (locBlocksTgt nu23 b = true).

           eapply local_locBlocks; eassumption.

         assert (locBlocksTgt nu23 b = false).

           eapply (extern_DomRng' _ WDnu'). simpl. apply Heqd.

         rewrite H0 in H. inv H.

     

        unfold as_inj in inc12. simpl in inc12.

        remember (compose_meminj (local_of nu12) (local_of nu23) b1) as q.

        destruct q; apply eq_sym in Heqq.

        

          destruct p as [b3 delta].

          destruct (compose_meminjD_Some _ _ _ _ _ Heqq)

            as [b2 [d1 [d2 [Loc12 [Loc23 D]]]]]; subst; clear Heqq.

          apply eq_sym.

          destruct (disjoint_extern_local _ WDnu12 b1).

            unfold compose_meminj, join. rewrite H, Loc12. trivial.

          rewrite H in Loc12. inv Loc12.

        

          assert (compose_meminj

            (removeUndefs (join (extern_of nu12) (local_of nu12))

               (join extern' (compose_meminj (local_of nu12) (local_of nu23))) prej12')

            j23' b1 = None).

              rewrite <- ID. unfold join. rewrite Heqd. trivial.

          clear ID.

          remember (extern_of nu12 b1) as w.

          destruct w; apply eq_sym in Heqw.

          

            destruct p as [b2 d1].

            assert (R: removeUndefs (join (extern_of nu12) (local_of nu12))

                        (join extern' (compose_meminj (local_of nu12) (local_of nu23)))

                         prej12' b1 = Some (b2, d1)).

                apply inc12. apply extern_in_all. apply Heqw.

            destruct (compose_meminjD_None _ _ _ H); clear H.

               rewrite H0 in R. inv R.

            destruct H0 as [bb2 [dd1 [XX J23']]].

            rewrite R in XX. apply eq_sym in XX. inv XX.

            apply eq_sym.

            apply compose_meminjI_None. right.

            exists b2, d1; split. apply join_incr_left. assumption.

            remember (extern_of nu23 b2) as t.

            destruct t; apply eq_sym in Heqt.

               destruct p as [b3 d2].

               apply extern_in_all in Heqt. apply inc23 in Heqt.

               rewrite Heqt in J23'. discriminate.

            unfold join. rewrite Heqt, J23'.

              destruct (local_of nu23 b2); trivial.

          

            destruct (compose_meminjD_None _ _ _ Heqq); clear Heqq.

            

              clear inc12.

              destruct (compose_meminjD_None _ _ _ H); clear H.

              

                apply eq_sym.

                apply compose_meminjI_None. left.

                apply joinI_None. assumption.

                rewrite H0. apply H1.

              

                destruct H1 as [b2 [d1 [R J23']]].

                apply eq_sym.

                apply compose_meminjI_None. right.

                exists b2, d1; split.

                  unfold join. rewrite Heqw. rewrite H0. apply R.

                assert (as_inj nu23 b2 = None).

                  apply (inject_incr_inv _ _ inc23 _ J23').

                destruct (joinD_None _ _ _ H).

                unfold join. rewrite H1, H2. apply J23'.

            

              destruct H0 as [b2 [d1 [Loc1 Loc2]]].

              apply eq_sym.

              apply compose_meminjI_None. left.

              destruct (disjoint_extern_local _ WDnu12 b1).

                unfold join. rewrite H0, Loc1. trivial.

              rewrite H0 in Loc1. inv Loc1.

split; trivial.

assert (GOAL2: extern_incr nu12

  (convertL nu12 (removeUndefs (as_inj nu12) (as_inj nu') prej12')

     (fun b : block => DomSrc nu' b && negb (DomSrc nu12 b))

     (FreshDom (as_inj nu23) j23'))).

  split. rewrite convertL_extern. apply join_incr_left.

  split. rewrite convertL_local. trivial.

  split. rewrite convertL_extBlocksSrc. intuition.

  split. rewrite convertL_extBlocksTgt. intuition.

  split. rewrite convertL_locBlocksSrc. trivial.

  split. rewrite convertL_locBlocksTgt. trivial.

  split. rewrite convertL_pubBlocksSrc. trivial.

  split. rewrite convertL_pubBlocksTgt. trivial.

  split. rewrite convertL_frgnBlocksSrc. trivial.

  rewrite convertL_frgnBlocksTgt. trivial.

split. rewrite <- Heqj12' in GOAL2. assumption.

assert (GOAL3: (extern_incr nu23

  (convertR nu23 j23' (FreshDom (as_inj nu23) j23')

     (fun b : block => DomTgt nu' b && negb (DomTgt nu23 b))))).

  clear GOAL1 GOAL2 ConvertL_J12' ConvertR_J23'.

  split. rewrite convertR_extern. apply join_incr_left.

  split. rewrite convertR_local. trivial.

  split. rewrite convertR_extBlocksSrc. intuition.

  split. rewrite convertR_extBlocksTgt. intuition.

  split. rewrite convertR_locBlocksSrc. trivial.

  split. rewrite convertR_locBlocksTgt. trivial.

  split. rewrite convertR_pubBlocksSrc. trivial.

  split. rewrite convertR_pubBlocksTgt. trivial.

  split. rewrite convertR_frgnBlocksSrc. trivial.

  rewrite convertR_frgnBlocksTgt. trivial.

split. assumption.

assert (GOAL4: sm_inject_separated nu12

  (convertL nu12 j12'

     (fun b : block => DomSrc nu' b && negb (DomSrc nu12 b))

     (FreshDom (as_inj nu23) j23')) m1 m2).

  split. rewrite ConvertL_J12'; clear ConvertL_J12' GOAL1 ConvertR_J23'.

         intros.

         destruct (sep12 _ _ _ H H0) as [NV1 NV2].

         split.

           remember (DomSrc nu12 b1) as q.

           destruct q; trivial; apply eq_sym in Heqq.

           apply SMV12 in Heqq. contradiction.

         remember (DomTgt nu12 b2) as q.

           destruct q; trivial; apply eq_sym in Heqq.

           apply SMV12 in Heqq. contradiction.

  rewrite convertL_DomSrc, convertL_DomTgt.

  split; intros; rewrite H in H0; simpl in *.

         rewrite andb_true_r in H0.

         eapply SMInjSep. apply H. apply H0.

       unfold FreshDom in H0.

           remember (j23' b2) as q.

           destruct q; apply eq_sym in Heqq.

              destruct p.

              remember (as_inj nu23 b2) as w.

              destruct w; apply eq_sym in Heqw. inv H0.

              eapply sep23; eassumption.

           inv H0.

split. assumption.

assert (GOAL5: sm_inject_separated nu23

  (convertR nu23 j23' (FreshDom (as_inj nu23) j23')

     (fun b : block => DomTgt nu' b && negb (DomTgt nu23 b))) m2 m3).

  split. rewrite ConvertR_J23'; clear ConvertL_J12' GOAL1 ConvertR_J23'.

         intros.

         destruct (sep23 _ _ _ H H0) as [NV1 NV2].

         split.

           remember (DomSrc nu23 b1) as q.

           destruct q; trivial; apply eq_sym in Heqq.

           apply SMV23 in Heqq. contradiction.

         remember (DomTgt nu23 b2) as q.

           destruct q; trivial; apply eq_sym in Heqq.

           apply SMV23 in Heqq. contradiction.

  rewrite convertR_DomSrc, convertR_DomTgt.

  split; intros; rewrite H in H0; simpl in H0.

         unfold FreshDom in H0.

           remember (j23' b1) as q.

           destruct q; apply eq_sym in Heqq.

              destruct p.

              remember (as_inj nu23 b1) as w.

              destruct w; apply eq_sym in Heqw. inv H0.

              eapply sep23; eassumption.

           inv H0.

           rewrite andb_true_r in H0.

           eapply SMInjSep. apply H. apply H0.

split. assumption.

assert (GOAL6: sm_valid

  (convertL nu12 j12'

     (fun b : block => DomSrc nu' b && negb (DomSrc nu12 b))

     (FreshDom (as_inj nu23) j23')) m1' m2').

  split. unfold DOM. rewrite convertL_DomSrc.

         clear ConvertL_J12' GOAL1 ConvertR_J23'.

         intros.

         remember (DomSrc nu12 b1) as d.

         destruct d; apply eq_sym in Heqd; simpl in H.

           apply Fwd1.

           eapply SMV12. apply Heqd.

         rewrite andb_true_r in H.

           eapply SMvalNu'. apply H.

  unfold RNG. rewrite convertL_DomTgt.

         intros.

         remember (DomTgt nu12 b2) as d.

         destruct d; apply eq_sym in Heqd; simpl in H.

           apply Fwd2.

           eapply SMV12. apply Heqd.

         unfold FreshDom in H.

           remember (j23' b2) as q.

           destruct q; apply eq_sym in Heqq.

              destruct p.

              remember (as_inj nu23 b2) as w.

              destruct w; apply eq_sym in Heqw. inv H.

              apply (VBj23' _ _ _ Heqq).

            inv H.

split. assumption.

split. 


  split. unfold DOM. rewrite convertR_DomSrc.

         clear ConvertL_J12' GOAL1 ConvertR_J23'.

         intros.

         remember (DomSrc nu23 b1) as d.

         destruct d; apply eq_sym in Heqd; simpl in H.

           apply Fwd2.

           eapply SMV23. apply Heqd.

         unfold FreshDom in H.

           remember (j23' b1) as q.

           destruct q; apply eq_sym in Heqq.

              destruct p.

              remember (as_inj nu23 b1) as w.

              destruct w; apply eq_sym in Heqw. inv H.

              apply (VBj23' _ _ _ Heqq).

            inv H.

  unfold RNG. rewrite convertR_DomTgt.

         intros.

         remember (DomTgt nu23 b2) as d.

         destruct d; apply eq_sym in Heqd; simpl in H.

           apply Fwd3.

           eapply SMV23. apply Heqd.

         rewrite andb_true_r in H.

           eapply SMvalNu'. apply H.

split. 

  split. 


   clear ConvertL_J12' ConvertR_J23'.

   split.

    rewrite convertL_locBlocksSrc, convertL_extBlocksSrc.

           intros. unfold DomSrc.

           specialize (disjoint_extern_local_Src _ WDnu12 b); intros.

           remember (locBlocksSrc nu12 b) as d.

           destruct d; apply eq_sym in Heqd.

             destruct H. inv H.

             rewrite H. right. simpl. rewrite andb_false_r. trivial.

           left; trivial.

    rewrite convertL_locBlocksTgt, convertL_extBlocksTgt.

           intros.

           specialize (disjoint_extern_local_Tgt _ WDnu12 b); intros.

           remember (locBlocksTgt nu12 b) as d.

           destruct d; apply eq_sym in Heqd.

             destruct H. inv H.

             rewrite H. right. rewrite orb_false_l.

             unfold FreshDom.

             remember (j23' b) as q.

             destruct q; trivial; apply eq_sym in Heqq.

             destruct p.

             remember (as_inj nu23 b) as t.

             destruct t; trivial; apply eq_sym in Heqt.

             assert (DomSrc nu23 b = false).

                eapply GOAL5. apply Heqt.

                destruct (joinD_None _ _ _ Heqt).

                apply joinI. rewrite convertR_extern, convertR_local.

                unfold join; simpl. rewrite H0, H1. left; eassumption.

             unfold DomSrc in H0. rewrite GlueLoc in Heqd. rewrite Heqd in H0.

               discriminate.

           left; trivial.

    rewrite convertL_local, convertL_locBlocksSrc, convertL_locBlocksTgt.

           apply WDnu12.

    rewrite convertL_extern, convertL_extBlocksSrc, convertL_extBlocksTgt.

           intros.

            destruct (joinD_Some _ _ _ _ _ H); clear H.

              destruct (extern_DomRng _ WDnu12 _ _ _ H0) as [? ?].

              intuition.

            destruct H0.

            remember (local_of nu12 b1) as d.

            destruct d; apply eq_sym in Heqd. inv H0.

              destruct (sep12 b1 b2 z); trivial.

                apply joinI_None; trivial.

            remember (DomSrc nu12 b1) as q.

            destruct q; apply eq_sym in Heqq.

              exfalso. apply H1. apply SMV12. apply Heqq.

            remember (DomTgt nu12 b2) as w.

            destruct w; apply eq_sym in Heqw.

              exfalso. apply H2. apply SMV12. apply Heqw.

            simpl.

            unfold DomSrc in Heqq. apply orb_false_iff in Heqq. destruct Heqq.

            unfold DomTgt in Heqw. apply orb_false_iff in Heqw. destruct Heqw.

            rewrite H4, H6; simpl.

            rewrite andb_true_r. clear GOAL1.

            rewrite GlueLoc, GlueExt in *.

            remember (as_inj nu23 b2) as ww.

            destruct ww; apply eq_sym in Heqww.

               destruct p.

               destruct (as_inj_DomRng _ _ _ _ Heqww WDnu23).

               unfold DomSrc in H7. rewrite H5, H6 in H7. discriminate.

            remember (as_inj nu' b1) as qq.

            destruct qq; apply eq_sym in Heqqq.

               destruct p.

               assert (DomSrc nu' b1 = true).

                  eapply as_inj_DomRng. eassumption.

                  assumption.

               rewrite H7. split; trivial.

               rewrite ID in Heqqq.

               destruct (compose_meminjD_Some _ _ _ _ _ Heqqq)

                  as [b22 [dd1 [dd2 [FF [JJ DD]]]]]; clear Heqqq.

               clear ID. rewrite FF in H0. inv H0.

               unfold FreshDom. rewrite JJ, Heqww. trivial.

            rewrite Heqj12' in H0.

            unfold removeUndefs in H0. rewrite Heqqq in H0.

               assert (AI: as_inj nu12 b1 = None). apply joinI_None; eassumption.

               rewrite AI in H0. inv H0.

    rewrite convertL_pubBlocksSrc, convertL_pubBlocksTgt, convertL_local.

            apply WDnu12.

    rewrite convertL_frgnBlocksSrc, convertL_frgnBlocksTgt.

            rewrite convertL_extern; trivial. intros.

            destruct (frgnSrcAx _ WDnu12 _ H) as [b2 [d [EXT FT]]].

             unfold join. rewrite EXT. exists b2, d. split; trivial.

    rewrite convertL_pubBlocksTgt, convertL_locBlocksTgt.

           apply WDnu12.

    rewrite convertL_frgnBlocksTgt, convertL_extBlocksTgt.

           intros. rewrite (frgnBlocksExternTgt _ WDnu12 _ H). trivial.

split. 


   clear ConvertL_J12' ConvertR_J23'.

   split.

    rewrite convertR_locBlocksSrc, convertR_extBlocksSrc.

          intros.

           specialize (disjoint_extern_local_Src _ WDnu23 b); intros.

           remember (locBlocksSrc nu23 b) as d.

           destruct d; apply eq_sym in Heqd.

             destruct H. inv H.

             rewrite H. right. rewrite orb_false_l.

             unfold FreshDom.

             remember (j23' b) as q.

             destruct q; trivial; apply eq_sym in Heqq.

             destruct p.

             remember (as_inj nu23 b) as t.

             destruct t; trivial; apply eq_sym in Heqt.

             assert (DomSrc nu23 b = false).

                eapply GOAL5. apply Heqt.

                destruct (joinD_None _ _ _ Heqt).

                apply joinI. rewrite convertR_extern, convertR_local.

                unfold join; simpl. rewrite H0, H1. left; eassumption.

             unfold DomSrc in H0. rewrite Heqd, H in H0.

               discriminate.

           left; trivial.

    rewrite convertR_locBlocksTgt, convertR_extBlocksTgt.

           intros. specialize (disjoint_extern_local_Tgt _ WDnu23 b). intros.

           remember (locBlocksTgt nu23 b) as d.

           destruct d; apply eq_sym in Heqd.

             destruct H. inv H.

             right; rewrite H. simpl.

             assert (DomTgt nu23 b = true).

               unfold DomTgt; rewrite Heqd. trivial.

             rewrite H0; simpl. rewrite andb_false_r. trivial.

           left; trivial.

    rewrite convertR_locBlocksTgt, convertR_locBlocksSrc, convertR_local.

           apply WDnu23.

    rewrite convertR_extBlocksTgt, convertR_extBlocksSrc, convertR_extern.

           intros.

           destruct (joinD_Some _ _ _ _ _ H) as [EXT23 | [EXT23 LOC23]]; clear H.

              destruct (extern_DomRng _ WDnu23 _ _ _ EXT23).

              rewrite H, H0; simpl. split; trivial.

           remember ( local_of nu23 b1) as q.

           destruct q; try inv LOC23; apply eq_sym in Heqq.

           assert (AI: as_inj nu23 b1 = None).

              apply joinI_None; assumption.

           destruct GOAL5 as [? _].

           destruct (H b1 b2 z AI); clear H.

              apply joinI. rewrite convertR_extern, convertR_local.

              unfold join. rewrite EXT23, Heqq. left; trivial.

           unfold FreshDom. rewrite LOC23, AI, H1; simpl.

           assert (DomTgt nu' b2 = true).

             destruct (mkiVal4 _ _ _ LOC23) as [[MK _] | [MK | MK]].

              congruence.

              destruct MK as [? [? ?]].

                   eapply as_inj_DomRng; eassumption.

              destruct MK as [mm [? [? ?]]].

                   eapply as_inj_DomRng; eassumption.

           rewrite H. intuition.

    rewrite convertR_pubBlocksTgt, convertR_pubBlocksSrc, convertR_local.

           apply WDnu23.

    rewrite convertR_frgnBlocksTgt, convertR_frgnBlocksSrc.

           rewrite convertR_extern; trivial. intros.

           destruct (frgnSrcAx _ WDnu23 _ H) as [b2 [d [EXT FT]]].

           exists b2, d; unfold join. rewrite EXT; split; trivial.

    rewrite convertR_locBlocksTgt, convertR_pubBlocksTgt.

            apply WDnu23.

    rewrite convertR_frgnBlocksTgt, convertR_extBlocksTgt.

            intros. rewrite (frgnBlocksExternTgt _ WDnu23 _ H); trivial.

  split. assumption.

  split. rewrite GlueExt. trivial.

  split. assumption.

  intros. apply GlueFrgn; trivial.

split. intros.  clear GOAL1 ConvertR_J23'.

   subst.

   destruct (joinD_Some _ _ _ _ _ H) as [EXT | [EXT LOC]]; clear H.

      destruct (Norm12 _ _ _ EXT) as [b3 [d2 EXT2]].

      exists b3, d2. apply joinI; left. assumption.

   remember (local_of nu12 b1) as q.

   destruct q; apply eq_sym in Heqq. inv LOC.

   assert (AsInj12: as_inj nu12 b1 = None).

     apply joinI_None; assumption.

   destruct (sep12 _ _ _ AsInj12 LOC).

   remember (extern_of nu23 b2) as d.

   destruct d; apply eq_sym in Heqd.

     destruct p. exfalso. apply H0. eapply VBj23_1. apply extern_in_all; eassumption.

   remember (local_of nu23 b2) as w.

   destruct w; apply eq_sym in Heqw.

     destruct p. exfalso. apply H0. eapply VBj23_1. apply local_in_all; eassumption.

   unfold join. rewrite Heqd, Heqw.

   unfold removeUndefs in LOC. rewrite AsInj12 in LOC.

   remember (as_inj nu' b1) as t.

   destruct t; try inv LOC. destruct p; apply eq_sym in Heqt.

   remember (j23' b2) as u.

   destruct u; apply eq_sym in Hequ.

     destruct p. exists b0, z0; trivial.

   destruct (mkiVal3 _ _ _ H2) as [[X _] | [X | X]]; clear mkiVal3.

      rewrite X in AsInj12. discriminate.

      destruct X as [B1 [B2 [D2 [VB1 VB2]]]].

      exfalso. destruct (mkiVal5 _ VB2 Hequ) as [[Ya Yb] | [[Ya Yb] | [mm [Ya Yb]]]].

        subst. clear - Ya. unfold Mem.valid_block in Ya. xomega.

        subst. rewrite Heqt in Yb. discriminate.

        subst. clear - Ya. rewrite Pos.add_comm in Ya. apply eq_sym in Ya.

                    eapply Pos.add_no_neutral. apply Ya.

      destruct X as [m [B1 [B2 [D1 [VB1 VB2]]]]].

      exfalso. destruct (mkiVal5 _ VB2 Hequ) as [[Ya Yb] | [[Ya Yb] | [mm [Ya Yb]]]].

        subst. clear - Ya. unfold Mem.valid_block in Ya. xomega.

        subst.  clear - Ya. rewrite Pos.add_comm in Ya.

                    eapply Pos.add_no_neutral. apply Ya.

        subst. assert (mm=m). clear - Ya. xomega. subst.

               rewrite Heqt in Yb. discriminate.

repeat (split; trivial).

Qed.



Section MEMORY_CONSTRUCTION_EFF.

Variable nu23 nu12 : SM_Injection.

Variable j23 j12':meminj.

Variable m1 m1' m2 : mem.



Definition AccessMap_EFF_FUN (b2:block):

           Z -> perm_kind -> option permission :=

  if plt b2 (Mem.nextblock m2)

  then fun ofs2 k =>

       if (locBlocksSrc nu23 b2)

       then if (pubBlocksSrc nu23 b2)

            then match source (local_of nu12) m1 b2 ofs2 with

                   Some(b1,ofs1) => if pubBlocksSrc nu12 b1

                                    then PMap.get b1 m1'.(Mem.mem_access) ofs1 k

                                    else PMap.get b2 m2.(Mem.mem_access) ofs2 k

                 | None => PMap.get b2 m2.(Mem.mem_access) ofs2 k

                 end

            else PMap.get b2 m2.(Mem.mem_access) ofs2 k

       else match source (as_inj nu12) m1 b2 ofs2 with

                   Some(b1,ofs1) => PMap.get b1 m1'.(Mem.mem_access) ofs1 k

                 | None => match j23 b2 with

                             None => PMap.get b2 m2.(Mem.mem_access) ofs2 k

                           | Some (b3,d3) => None

                           end



               end

     else fun ofs2 k =>

           match source j12' m1' b2 ofs2 with

              Some(b1,ofs1) => PMap.get b1 m1'.(Mem.mem_access) ofs1 k

            | None => None

          end.



Lemma mkAccessMap_EFF_existsT: forall N

       (VB : (Mem.nextblock m2 <= N)%positive)

       (VBJ12': forall b1 b2 delta, j12' b1 = Some (b2,delta) ->

                                   (b2 < N)%positive),

      { M : PMap.t (Z -> perm_kind -> option permission) |

          fst M = (fun k ofs => None) /\

          forall b, PMap.get b M = AccessMap_EFF_FUN b}.

Proof. intros.

  apply (pmap_construct_c _ AccessMap_EFF_FUN

              N (fun ofs k => None)).

    intros. unfold AccessMap_EFF_FUN.

    remember (plt n (Mem.nextblock m2)) as d.

    destruct d; clear Heqd; trivial.

       exfalso. xomega.

    extensionality ofs. extensionality k.

      remember (source j12' m1' n ofs) as src.

      destruct src; trivial.

        destruct p.

        destruct (source_SomeE _ _ _ _ _ Heqsrc)

          as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

        clear Heqsrc; subst. apply eq_sym in PP. inv PP.

        apply VBJ12' in JJ.

        exfalso. xomega.

Qed.



Definition ContentMap_EFF_ValidBlock_FUN b2 ofs2: memval :=

    if locBlocksSrc nu23 b2

    then if (pubBlocksSrc nu23 b2)

         then match source (local_of nu12) m1 b2 ofs2 with

             Some(b1,ofs1) =>

                 if pubBlocksSrc nu12 b1

                 then inject_memval j12'

                      (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

                 else ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

           | None => ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

            end

         else ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

    else match source (as_inj nu12) m1 b2 ofs2 with

             Some(b1,ofs1) => inject_memval j12'

                                (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

           | None => ZMap.get ofs2 (PMap.get b2 m2.(Mem.mem_contents))

         end.



Definition ContentMap_EFF_InvalidBlock_FUN b2 ofs2: memval :=

   match source j12' m1' b2 ofs2 with

                None => Undef

              | Some(b1,ofs1) => inject_memval j12'

                       (ZMap.get ofs1 (PMap.get b1 m1'.(Mem.mem_contents)))

   end.



Definition ContentMap_EFF_Block_FUN b ofs : memval:=

  if plt b (Mem.nextblock m2)

  then ContentMap_EFF_ValidBlock_FUN b ofs

  else ContentMap_EFF_InvalidBlock_FUN b ofs.



Variable MINMAX_Offset: block -> option (Z * Z).



Hypothesis MINMAX: forall b2 ,

                   match MINMAX_Offset b2 with

                    Some(mn,mx) =>

                      (forall ofs, ofs < mn \/ ofs > mx ->

                        Plt b2 (Mem.nextblock m2) ->

                        ZMap.get ofs (Mem.mem_contents m2)!!b2 = Undef) /\

                      forall b1 delta, as_inj nu12 b1 = Some(b2,delta) \/ j12' b1 = Some(b2,delta)->

                       forall z, z + delta < mn \/ z + delta > mx ->

                                 ZMap.get z (Mem.mem_contents m1')!!b1 = Undef

                   | None =>

                      (Plt b2 (Mem.nextblock m2) ->

                          forall ofs, ZMap.get ofs (Mem.mem_contents m2)!!b2 = Undef)

                      /\

                       forall b1 delta, as_inj nu12 b1 = Some(b2,delta) \/ j12' b1 = Some(b2,delta)->

                       forall z, ZMap.get z (Mem.mem_contents m1')!!b1 = Undef

                    end.



Variable WDnu12: SM_wd nu12.



Lemma CM_block_EFF_existsT: forall b,

      { M : ZMap.t memval |

          fst M = Undef /\

          forall ofs, ZMap.get ofs M =

                      ContentMap_EFF_Block_FUN b ofs}.

Proof. intros. clear j23.

  remember (zmap_finite_c _ (PMap.get b m2.(Mem.mem_contents))) as LH2.

  apply eq_sym in HeqLH2. destruct LH2 as [lo2 hi2].

  specialize (zmap_finite_sound_c _ _ _ _ HeqLH2).

  intros Bounds2; clear HeqLH2.

   assert (Undef2: fst (Mem.mem_contents m2) !! b = Undef). apply m2.

   rewrite Undef2 in *. clear Undef2.

  specialize (MINMAX b).

  remember (MINMAX_Offset b) as MM.

  destruct MM; apply eq_sym in HeqMM.

    destruct p as [mn mx].

    destruct MINMAX as [MINMAX_A MINMAX_B]; clear MINMAX.

    destruct (zmap_construct_c _

              (ContentMap_EFF_Block_FUN b)

              (Z.min mn lo2)

              (Z.max mx hi2)

            Undef) as [M PM].

    intros. unfold ContentMap_EFF_Block_FUN; simpl.

        unfold ContentMap_EFF_ValidBlock_FUN.

        unfold ContentMap_EFF_InvalidBlock_FUN.

   destruct (plt b (Mem.nextblock m2)).

   

      remember (locBlocksSrc nu23 b) as d.

      destruct d; apply eq_sym in Heqd.

       remember (pubBlocksSrc nu23 b) as q.

       destruct q; apply eq_sym in Heqq.

         remember (source (local_of nu12) m1 b n) as src.

         destruct src; trivial.

           destruct p0.

           destruct (source_SomeE _ _ _ _ _ Heqsrc)

             as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

            clear Heqsrc; subst. apply eq_sym in PP. inv PP.

            assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

              left; eapply local_in_all; try eassumption.

            remember (pubBlocksSrc nu12 b0) as w.

            destruct w; apply eq_sym in Heqw.

              rewrite (MINMAX_B _ _ H0 z). simpl. trivial.

              clear -H.

              destruct H.

              apply Z.min_glb_lt_iff in H. left. omega.

              assert (Z.max mx hi2 < z + dd1) by omega.

                apply Z.max_lub_lt_iff in H0. right; omega.

             

             eapply MINMAX_A.

               clear -H. xomega.

               apply p.

         

           eapply MINMAX_A.

             clear -H. xomega.

             apply p.

      

      eapply MINMAX_A.

        clear -H. xomega.

        apply p.

       
         remember (source (as_inj nu12) m1 b n) as src.

         destruct src; trivial.

           destruct p0.

           destruct (source_SomeE _ _ _ _ _ Heqsrc)

             as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

            clear Heqsrc; subst. apply eq_sym in PP. inv PP.

            assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

              left; eassumption.

            rewrite (MINMAX_B _ _ H0 z). simpl. trivial.

              clear -H.

              destruct H.

               apply Z.min_glb_lt_iff in H. left. omega.

               assert (Z.max mx hi2 < z + dd1) by omega.

                 apply Z.max_lub_lt_iff in H0. right; omega.

         

           eapply MINMAX_A.

               clear -H. xomega.

               apply p.

   

       remember (source j12' m1' b n) as src.

       destruct src; trivial.

       destruct p.

         destruct (source_SomeE _ _ _ _ _ Heqsrc)

           as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

          clear Heqsrc; subst. apply eq_sym in PP. inv PP.

         assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

            right; trivial.

         rewrite (MINMAX_B _ _ H0 z). simpl. trivial.



         clear -H.

         destruct H.

           apply Z.min_glb_lt_iff in H. left. omega.

           assert (Z.max mx hi2 < z + dd1) by omega.

             apply Z.max_lub_lt_iff in H0. right; omega.



  exists M. apply PM.



  exists (ZMap.init Undef).

    split. reflexivity.

    destruct MINMAX as [MINMAX_A MINMAX_B]; clear MINMAX.

    intros. rewrite ZMap.gi.

    unfold ContentMap_EFF_Block_FUN.

    destruct (plt b (Mem.nextblock m2)).

      unfold ContentMap_EFF_ValidBlock_FUN.

      rewrite (MINMAX_A p).

      remember (locBlocksSrc nu23 b) as d.

      destruct d; apply eq_sym in Heqd.

        remember (pubBlocksSrc nu23 b) as w.

        destruct w; trivial; apply eq_sym in Heqw.

        remember (source (local_of nu12) m1 b ofs) as src.

        destruct src; trivial.

          destruct p0.

          destruct (source_SomeE _ _ _ _ _ Heqsrc)

             as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

            clear Heqsrc; subst. apply eq_sym in PP. inv PP.

           assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

              left. apply local_in_all; eassumption.

        rewrite (MINMAX_B _ _ H z). simpl.

          destruct (pubBlocksSrc nu12 b0); trivial.

     

        remember (source (as_inj nu12) m1 b ofs) as src.

        destruct src; trivial.

          destruct p0.

          destruct (source_SomeE _ _ _ _ _ Heqsrc)

             as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

            clear Heqsrc; subst. apply eq_sym in PP. inv PP.

           assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

              left; assumption.

        rewrite (MINMAX_B _ _ H z). simpl. trivial.



    unfold ContentMap_EFF_InvalidBlock_FUN.

      remember (source j12' m1' b ofs) as src.

      destruct src; trivial.

        destruct p.

        destruct (source_SomeE _ _ _ _ _ Heqsrc)

           as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

          clear Heqsrc; subst. apply eq_sym in PP. inv PP.

         assert (as_inj nu12 b0 = Some (b, dd1) \/ j12' b0 = Some (b, dd1)).

            right; trivial.

        rewrite (MINMAX_B _ _ H z). simpl. trivial.

Qed.



Definition ContentsMap_EFF_FUN  (NB2' b:block) : ZMap.t memval.

destruct (plt b NB2').

  apply (CM_block_EFF_existsT b).

apply (ZMap.init Undef).

Defined.



Lemma ContentsMap_EFF_existsT:

      forall (NB2':block) ,

      { M : PMap.t (ZMap.t memval) |

        fst M = ZMap.init Undef /\

        forall b, PMap.get b M =

           ContentsMap_EFF_FUN NB2' b}.

Proof. intros.

  apply (pmap_construct_c _ (ContentsMap_EFF_FUN NB2')

              NB2' (ZMap.init Undef)).

    intros. unfold ContentsMap_EFF_FUN. simpl.

    remember (plt n NB2') as d.

    destruct d; clear Heqd; trivial.

      exfalso. xomega.

Qed.



Definition mkEFF

            (NB2':block)

            (Hyp1: (Mem.nextblock m2 <= NB2')%positive)

            (Hyp2: forall (b1 b2 : block) (delta : Z),

                       j12' b1 = Some (b2, delta) -> (b2 < NB2')%positive)

           : Mem.mem'.

destruct (mkAccessMap_EFF_existsT NB2' Hyp1 Hyp2) as [AM [ADefault PAM]].

destruct (ContentsMap_EFF_existsT NB2') as [CM [CDefault PCM]].

eapply Mem.mkmem with (nextblock:=NB2')

                      (mem_access:=AM)

                      (mem_contents:=CM).

  

  intros. rewrite PAM. unfold AccessMap_EFF_FUN.

     destruct (plt b (Mem.nextblock m2)).

     

        destruct (locBlocksSrc nu23 b).

          destruct (pubBlocksSrc nu23 b).

            destruct (source (local_of nu12) m1 b ofs).

              destruct p0.

              destruct (pubBlocksSrc nu12 b0). apply m1'. apply m2.

            apply m2.

          apply m2.

        destruct (source (as_inj nu12) m1 b ofs).

            destruct p0. apply m1'.

        destruct (j23 b). destruct p0. reflexivity. apply m2.

     

        destruct (source j12' m1' b ofs).

          destruct p. apply m1'.

        reflexivity.

  

    intros. rewrite PAM.

    unfold AccessMap_EFF_FUN.

    destruct (plt b (Mem.nextblock m2)).

      exfalso. apply H; clear - Hyp1 p. xomega.

    remember (source j12' m1' b ofs) as src.

    destruct src; trivial.

      destruct p.

      exfalso. apply H. clear - Heqsrc Hyp2.

      apply source_SomeE in Heqsrc.

      destruct Heqsrc as [b1 [delta [ofs1

          [PBO [Bounds [J1 [P1 Off2]]]]]]]; subst.

        apply (Hyp2 _ _ _ J1).

  

    intros.

    rewrite PCM; clear PCM.

    unfold ContentsMap_EFF_FUN.

    destruct (plt b NB2').

     remember (CM_block_EFF_existsT b).

     destruct s. apply a.

    reflexivity.

Defined.



Lemma mkEff_nextblock: forall N Hyp1 Hyp2,

         Mem.nextblock (mkEFF N Hyp1 Hyp2) = N.

Proof. intros. unfold mkEFF.

  remember (mkAccessMap_EFF_existsT N Hyp1 Hyp2).

  destruct s as [X1 X2].

  destruct X2. simpl in *.

  remember (ContentsMap_EFF_existsT N).

  destruct s as [Y1 Y2].

  destruct Y2; simpl in *. reflexivity.

Qed.



End MEMORY_CONSTRUCTION_EFF.



Section MINMAX_EFF.

Variable nu12: SM_Injection.

Variable j12' :meminj.

Variable m1' m2: mem.



Definition MINMAX_Offset (b2:block) : option (Z * Z) :=

  if plt b2 (Mem.nextblock m2)

  then match (zmap_finite_c _ (PMap.get b2 m2.(Mem.mem_contents)))

       with (min2, max2) =>

          match minmax m1' (as_inj nu12) b2 with

             Some(min1, max1) =>

                  Some(Z.min min1 min2, Z.max max1 max2)

           | None => Some(min2,max2)

          end

       end

  else minmax m1' j12' b2.



Hypothesis inc12: inject_incr (as_inj nu12) j12'.

Hypothesis VBj12'_1: forall b1 b2 delta,

                     j12' b1 = Some (b2, delta) ->

                     Mem.valid_block m1' b1.

Hypothesis JJ: forall b1 b2 delta,

                       j12' b1 = Some (b2, delta) ->

                       Mem.valid_block m2 b2 ->

                       as_inj nu12 b1 = Some (b2, delta).



Lemma MINMAX: forall b2 ,

        match MINMAX_Offset b2 with

          Some(mn,mx) =>

              (forall ofs, ofs < mn \/ ofs > mx ->

                  Plt b2 (Mem.nextblock m2) ->

                  ZMap.get ofs (Mem.mem_contents m2)!!b2 = Undef) /\

              forall b1 delta, as_inj nu12 b1 = Some(b2,delta) \/

                               j12' b1 = Some(b2,delta)->

                forall z, z + delta < mn \/ z + delta > mx ->

                       ZMap.get z (Mem.mem_contents m1')!!b1 = Undef

        | None =>

             (Plt b2 (Mem.nextblock m2) ->

                forall ofs, ZMap.get ofs (Mem.mem_contents m2)!!b2 = Undef)

             /\ forall b1 delta,

                     as_inj nu12 b1 = Some(b2,delta) \/ j12' b1 = Some(b2,delta)->

                 forall z, ZMap.get z (Mem.mem_contents m1')!!b1 = Undef

         end.

Proof. intros.

unfold MINMAX_Offset.

remember (zmap_finite_c memval (Mem.mem_contents m2) !! b2) as MM2.

destruct MM2 as [min2 max2]. apply eq_sym in HeqMM2.

destruct (plt b2 (Mem.nextblock m2)).

  specialize (minmax_sound m1' (as_inj nu12) b2).

  remember (minmax m1' (as_inj nu12) b2) as MM; intros.

  destruct MM.

    destruct p0 as [mn mx].

    split; intros.

       apply zmap_finite_sound_c with (n:=ofs) in HeqMM2.

       rewrite HeqMM2. apply m2.

       clear - H0. xomega.

    intros. assert (as_inj nu12 b1 = Some(b2,delta)).

              destruct H0. trivial. apply (JJ _ _ _ H0 p).

            apply (H b1 delta); trivial.

              apply inc12 in H2. apply (VBj12'_1 _ _ _ H2).

            clear - H1. xomega.

  split; intros.

       apply zmap_finite_sound_c with (n:=ofs) in HeqMM2.

       rewrite HeqMM2. apply m2.

       clear - H0. xomega.

     assert (as_inj nu12 b1 = Some(b2,delta)).

              destruct H0. trivial. apply (JJ _ _ _ H0 p).

     apply (H b1 delta); trivial.

       apply inc12 in H2. apply (VBj12'_1 _ _ _ H2).

specialize (minmax_sound m1' j12' b2).

  remember (minmax m1' j12' b2) as MM; intros.

  destruct MM.

    destruct p as [mn mx].

    split; intros. contradiction.

    assert (j12' b1 = Some(b2,delta)).

      destruct H0. apply inc12; assumption. assumption.

    apply (H b1 delta); trivial.

      apply (VBj12'_1 _ _ _ H2).

  split; intros. contradiction.

     assert (j12' b1 = Some(b2,delta)).

       destruct H0. apply inc12; assumption. assumption.

     apply (H b1 delta); trivial.

       apply (VBj12'_1 _ _ _ H1).

Qed.



End MINMAX_EFF.



Lemma EFF_interp_II_strong: forall m1 m2 nu12

                             (MInj12 : Mem.inject (as_inj nu12) m1 m2) m1'

                             (Fwd1: mem_forward m1 m1') nu23 m3

                             (MInj23 : Mem.inject (as_inj nu23) m2 m3) m3'

                             (Fwd3: mem_forward m3 m3')

                              nu' (WDnu' : SM_wd nu')

                             (SMvalNu' : sm_valid nu' m1' m3')

                             (MemInjNu' : Mem.inject (as_inj nu') m1' m3')



                             (ExtIncr: extern_incr (compose_sm nu12 nu23) nu')

                             (SMInjSep: sm_inject_separated (compose_sm nu12 nu23) nu' m1 m3)

                             (SMV12: sm_valid nu12 m1 m2)

                             (SMV23: sm_valid nu23 m2 m3)

                             (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc (compose_sm nu12 nu23) b = true /\

                                                      pubBlocksSrc (compose_sm nu12 nu23) b = false) m1 m1')

                             (UnchLOOR13: Mem.unchanged_on (local_out_of_reach (compose_sm nu12 nu23) m1) m3 m3')



                             (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\

                                         locBlocksTgt nu12 = locBlocksSrc nu23 /\

                                         extBlocksTgt nu12 = extBlocksSrc nu23 /\

                                         (forall b, pubBlocksTgt nu12 b = true ->

                                                    pubBlocksSrc nu23 b = true) /\

                                         (forall b, frgnBlocksTgt nu12 b = true ->

                                                    frgnBlocksSrc nu23 b = true))

                             (Norm12: forall b1 b2 d1, extern_of nu12 b1 = Some(b2,d1) ->

                                             exists b3 d2, extern_of nu23 b2 = Some(b3, d2)),

     exists m2', exists nu12', exists nu23', nu'=compose_sm nu12' nu23' /\

                             extern_incr nu12 nu12' /\ extern_incr nu23 nu23' /\

                             Mem.inject (as_inj nu12') m1' m2' /\ mem_forward m2 m2' /\

                             Mem.inject (as_inj nu23') m2' m3' /\

                             sm_inject_separated nu12 nu12' m1 m2 /\

                             sm_inject_separated nu23 nu23' m2 m3 /\

                             sm_valid nu12' m1' m2' /\ sm_valid nu23' m2' m3' /\

                             (SM_wd nu12' /\ SM_wd nu23' /\

                              locBlocksTgt nu12' = locBlocksSrc nu23' /\

                              extBlocksTgt nu12' = extBlocksSrc nu23' /\

                              (forall b, pubBlocksTgt nu12' b = true ->

                                         pubBlocksSrc nu23' b = true) /\

                              (forall b, frgnBlocksTgt nu12' b = true ->

                                         frgnBlocksSrc nu23' b = true)) /\

                             (forall b1 b2 d1, extern_of nu12' b1 = Some(b2,d1) ->

                                     exists b3 d2, extern_of nu23' b2 = Some(b3, d2)) /\

                              Mem.unchanged_on (fun b ofs => locBlocksSrc nu23 b = true /\

                                                             pubBlocksSrc nu23 b = false) m2 m2' /\

                              Mem.unchanged_on (local_out_of_reach nu12 m1) m2 m2' /\

                 

                   (forall b1 b2 d1, as_inj nu12' b1 = Some(b2,d1) ->

                       as_inj nu12 b1 = Some(b2,d1) \/

                       exists b3 d, as_inj nu' b1 = Some(b3,d)) /\

                   (forall b2 b3 d2, as_inj nu23' b2 = Some(b3,d2) ->

                       as_inj nu23 b2 = Some(b3,d2) \/

                       exists b1 d, as_inj nu' b1 = Some(b3,d)) /\

                   (forall b1 b2 ofs2, as_inj nu12' b1 = Some(b2,ofs2) ->

                     (as_inj nu12 b1 = Some (b2,ofs2)) \/

                     (b1 = Mem.nextblock m1 /\ b2 = Mem.nextblock m2 /\ ofs2 = 0) \/

                     (exists m, (b1 = Mem.nextblock m1 + m /\ b2=Mem.nextblock m2 + m)%positive /\ ofs2=0)) /\

                   (forall b2 b3 ofs3, as_inj nu23' b2 = Some(b3,ofs3) ->

                     (as_inj nu23 b2 = Some (b3,ofs3)) \/

                     (b2 = Mem.nextblock m2 /\ as_inj nu' (Mem.nextblock m1) = Some(b3,ofs3)) \/

                     (exists m, (b2 = Mem.nextblock m2 + m)%positive /\

                            as_inj nu' ((Mem.nextblock m1+m)%positive) = Some(b3,ofs3))).

Proof. intros.

  remember (mkInjections m1 m1' m2 (as_inj nu12) (as_inj nu23) (as_inj nu')) as MKI.

  apply eq_sym in HeqMKI. destruct MKI as [[[j12' j23'] n1'] n2'].

  assert (VBj12_1: forall (b1 b2 : block) (ofs2 : Z),

                as_inj nu12 b1 = Some (b2, ofs2) -> Mem.valid_block m1 b1).

      intros. eapply SMV12. eapply as_inj_DomRng. eassumption. apply GlueInvNu.

  assert (VBj12_2: forall (b1 b2 : block) (ofs2 : Z),

                as_inj nu12 b1 = Some (b2, ofs2) -> Mem.valid_block m2 b2).

      intros. eapply SMV12. eapply as_inj_DomRng. eassumption. apply GlueInvNu.

  assert (VBj23: forall (b1 b2 : block) (ofs2 : Z),

                as_inj nu23 b1 = Some (b2, ofs2) -> Mem.valid_block m2 b1).

      intros. eapply SMV23. eapply as_inj_DomRng. eassumption. apply GlueInvNu.

  assert (inc12:= mkInjections_1_injinc _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12_1).

  assert (sep12:= mkInjections_1_injsep _ _ _ _ _ _ _ _ _ _ HeqMKI).

  assert (inc23:= mkInjections_2_injinc _ _ _ _ _ _ _ _ _ _ HeqMKI VBj23).

  assert (InjSep: inject_separated (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu') m1 m3).

    specialize (sm_inject_separated_mem _ _ _ _ SMInjSep WDnu'). intros.

    rewrite compose_sm_as_inj in H. apply H.

    eapply GlueInvNu. eapply GlueInvNu. eapply GlueInvNu.  eapply GlueInvNu.

  assert (sep23:= mkInjections_2_injsep _ _ _ _ _ _ _ _ _ _

                   HeqMKI VBj12_1 _ InjSep).

  assert (VBj': forall b1 b3 ofs3, as_inj nu' b1 = Some (b3, ofs3) ->

             (b1 < Mem.nextblock m1')%positive).

      intros. eapply SMvalNu'. eapply as_inj_DomRng; eassumption.

  assert (WDnu12: SM_wd nu12). apply GlueInvNu.

  assert (WDnu23: SM_wd nu23). apply GlueInvNu.



destruct (mkInjections_0  _ _ _ _ _ _ _ _ _ _ HeqMKI)

   as [HH | HH].

destruct HH as [? [? [? [? ?]]]]. subst.

  assert (Mem.nextblock m1' = Mem.nextblock m1).

      apply forward_nextblock in Fwd1. eapply Pos.le_antisym; assumption.

  rewrite H0 in *.

  assert (VB1': forall (b1 b2 : block) (delta : Z),

             as_inj nu12 b1 = Some (b2, delta) -> Mem.valid_block m1' b1).

     intros. unfold Mem.valid_block. rewrite H0. apply (VBj12_1 _ _ _ H1).

  assert (JJ12: forall (b1 b2 : block) (delta : Z),

                as_inj nu12 b1 = Some (b2, delta) ->

                Mem.valid_block m2 b2 -> as_inj nu12 b1 = Some (b2, delta)).

     auto.



  assert (RU: (removeUndefs (as_inj nu12) (as_inj nu') (as_inj nu12)) = as_inj nu12).

      unfold removeUndefs. extensionality b.

      remember (as_inj nu12 b) as d.

      destruct d. destruct p; trivial.

      destruct (as_inj nu'); trivial. destruct p; trivial.

  exists (mkEFF nu23 nu12 (as_inj nu23) (as_inj nu12) m1 m1' m2

                  (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

               (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12) WDnu12 _ (Pos.le_refl _) VBj12_2).



  destruct (effect_interp_OK _ _ _ MInj12 _ Fwd1 _ _ MInj23

      _ Fwd3 _ WDnu' SMvalNu' MemInjNu' ExtIncr SMInjSep SMV12 SMV23

      UnchPrivSrc UnchLOOR13 GlueInvNu Norm12 _ _ _ _

      HeqMKI _ (eq_refl _)

      (mkEFF nu23 nu12 (as_inj nu23) (as_inj nu12) m1 m1' m2

                  (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

               (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12) WDnu12 _ (Pos.le_refl _) VBj12_2))

     as [unchA [unchB  [nu12' [nu23' [Hnu12' [Hnu23'

           [Hnu' [extInc12 [extInc23 [smSep12 [smSep23

             [smvNu12' [smvNu23' [Glue123 [Ext123 [Fwd2 [MInjNu12' InjNu23']]]]]]]]]]]]]]]]].

   

     unfold mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 (as_inj nu23) (as_inj nu12) m1 m1' m2 (Mem.nextblock m2)

         (Pos.le_refl (Mem.nextblock m2)) VBj12_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12 (as_inj nu12) m1 m1' m2

                (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

                (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12)

                WDnu12 (Mem.nextblock m2))

       as [CM [CDefault PCM]].

     simpl. reflexivity.

   

     unfold ContentEffProperty, mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 (as_inj nu23) (as_inj nu12) m1 m1' m2 (Mem.nextblock m2)

         (Pos.le_refl (Mem.nextblock m2)) VBj12_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12 (as_inj nu12) m1 m1' m2

                (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

                (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12)

                WDnu12 (Mem.nextblock m2))

       as [CM [CDefault PCM]].

     simpl.

     intros. rewrite PCM; clear PCM.

        unfold ContentsMap_EFF_FUN.

        destruct (CM_block_EFF_existsT nu23 nu12 (as_inj nu12) m1 m1' m2

                (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

                (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12)

                WDnu12 b2)

                 as [B [FB HB]].

        simpl in *. rewrite RU.

        destruct (plt b2 (Mem.nextblock m2)).

          split; intros.

          remember (locBlocksSrc nu23 b2) as d.

          destruct d; apply eq_sym in Heqd.

            remember (pubBlocksSrc nu23 b2) as q.

            destruct q; apply eq_sym in Heqq.

              destruct (pubSrc _ WDnu23 _ Heqq) as [b3 [d2 [Pub23 Tgt3]]].

              remember (source (local_of nu12) m1 b2 ofs2) as src.

              destruct src.

                destruct p0. rewrite HB.

                unfold ContentMap_EFF_Block_FUN.

                destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                unfold ContentMap_EFF_ValidBlock_FUN.

                rewrite Heqd, Heqq.

                rewrite <- Heqsrc.

                destruct (pubBlocksSrc nu12 b); trivial.

              rewrite HB.

                unfold ContentMap_EFF_Block_FUN.

                destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                unfold ContentMap_EFF_ValidBlock_FUN.

                rewrite <- Heqsrc. rewrite Heqd, Heqq. trivial.

            rewrite HB.

              unfold ContentMap_EFF_Block_FUN.

              destruct (plt b2 (Mem.nextblock m2)); try contradiction.

              unfold ContentMap_EFF_ValidBlock_FUN.

              rewrite Heqd, Heqq. trivial.

          

              remember (source (as_inj nu12) m1 b2 ofs2) as src.

              destruct src.

                destruct p0. rewrite HB.

                unfold ContentMap_EFF_Block_FUN.

                destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                unfold ContentMap_EFF_ValidBlock_FUN.

                rewrite Heqd.

                rewrite <- Heqsrc. trivial.

              rewrite HB.

                unfold ContentMap_EFF_Block_FUN.

                destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                unfold ContentMap_EFF_ValidBlock_FUN.

                rewrite Heqd. rewrite <- Heqsrc. trivial.

          split; intros. contradiction.

          apply FB.

        

          split; intros; try contradiction.

          split; intros.

             remember (source (as_inj nu12) m1' b2 ofs2) as src.

             destruct src.

               destruct p.

               apply source_SomeE in Heqsrc.

               destruct Heqsrc as [b1 [delta [ofs1

                  [PBO [Bounds [J1 [P1 Off2]]]]]]].

                inv PBO.

               exfalso. apply (H1 (VBj12_2 _ _ _ J1)).

             rewrite ZMap.gi. trivial.

           reflexivity.

   

     rewrite RU in *.

     unfold AccessEffProperty, mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 (as_inj nu23) (as_inj nu12) m1 m1' m2 (Mem.nextblock m2)

         (Pos.le_refl (Mem.nextblock m2)) VBj12_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12 (as_inj nu12) m1 m1' m2

                (MINMAX_Offset nu12 (as_inj nu12) m1' m2)

                (MINMAX nu12 (as_inj nu12) m1' m2 inc12 VB1' JJ12)

                WDnu12 (Mem.nextblock m2))

       as [CM [CDefault PCM]].

     simpl.

     intros. rewrite PAM; clear PAM.

       unfold AccessMap_EFF_FUN.

       simpl in *.

       destruct (plt b2 (Mem.nextblock m2)).

         split; intros; try contradiction.

           remember (locBlocksSrc nu23 b2) as d.

           destruct d.

             remember (pubBlocksSrc nu23 b2) as q.

             destruct q; apply eq_sym in Heqq.

               destruct (pubSrc _ WDnu23 _ Heqq) as [b3 [d2 [Pub23 T3]]].

               remember (source (local_of nu12) m1 b2 ofs2) as src.

               destruct src.

                 destruct p0.

                 destruct (pubBlocksSrc nu12 b); trivial.

               trivial.

             trivial.

           

              remember (source (as_inj nu12) m1 b2 ofs2) as src.

              destruct src.

                destruct p0. trivial.

              destruct (as_inj nu23 b2); trivial. destruct p0; trivial.

         split; intros; try contradiction.

           remember (source (as_inj nu12) m1' b2 ofs2) as src.

           destruct src; trivial.

             destruct p; trivial.

  exists nu12', nu23'.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.



  split; intros.

    clear - H1 extInc12 Hnu12' Glue123.

    remember (as_inj nu12 b1) as d.

    destruct d; apply eq_sym in Heqd.

      destruct p. apply extern_incr_as_inj in extInc12.

      rewrite (extInc12 _ _ _ Heqd) in H1.

      left; trivial.

      apply  Glue123.

    clear Glue123; subst.

      destruct (joinD_None _ _ _ Heqd).

      destruct (joinD_Some _ _ _ _ _ H1)

            as [EXT | [EXT LOC]]; clear H1;

         rewrite convertL_extern in EXT.

       unfold join, removeUndefs in EXT.

          rewrite H, H0, Heqd in EXT.

          destruct (as_inj nu' b1); try discriminate.

          destruct p; congruence.

      rewrite convertL_local in LOC. congruence.

  split; intros.

    clear - H1 extInc23 Hnu23' Glue123.

    remember (as_inj nu23 b2) as d.

    destruct d; apply eq_sym in Heqd.

      destruct p. apply extern_incr_as_inj in extInc23.

      rewrite (extInc23 _ _ _ Heqd) in H1.

      left; trivial.

      apply  Glue123.

    clear Glue123; subst.

      destruct (joinD_None _ _ _ Heqd).

      destruct (joinD_Some _ _ _ _ _ H1)

            as [EXT | [EXT LOC]]; clear H1;

         rewrite convertR_extern in EXT.

       unfold join, removeUndefs in EXT.

          rewrite H, H0, Heqd in EXT. inv EXT.

      rewrite convertR_local in LOC. congruence.

  destruct GlueInvNu as [WD12 [WD23 _]].

  split; intros.

    rewrite Hnu12' in H1. clear - WD12 H1.

    destruct (joinD_Some _ _ _ _ _ H1) as [EXT12' | [EXT12' LOC12']];

       clear H1; rewrite convertL_extern in EXT12'.

      destruct (joinD_Some _ _ _ _ _ EXT12') as

          [EXT12 | [EXT12 LOC12]]; clear EXT12'.

        left; apply joinI; left; assumption.

      remember (local_of nu12 b1) as d.

       destruct d; apply eq_sym in Heqd. inv LOC12.

        unfold removeUndefs in LOC12.

        remember (as_inj nu12 b1) as q.

        destruct q. destruct p. left; assumption.

        destruct (as_inj nu' b1); try congruence. destruct p; congruence.

    rewrite convertL_local in LOC12'.

      left; apply joinI; right.

      split; trivial.

      destruct (disjoint_extern_local _ WD12 b1); trivial. congruence.

  rewrite Hnu23' in H1. clear - WD23 H1.

    destruct (joinD_Some _ _ _ _ _ H1) as [EXT23' | [EXT23' LOC23']];

       clear H1; rewrite convertR_extern in EXT23'.

      destruct (joinD_Some _ _ _ _ _ EXT23') as

          [EXT23 | [EXT23 LOC23]]; clear EXT23'.

        left; apply joinI; left; assumption.

      remember (local_of nu23 b2) as d.

       destruct d; apply eq_sym in Heqd. inv LOC23.

        unfold removeUndefs in LOC23.

        remember (as_inj nu23 b2) as q.

        destruct q; try discriminate.

        destruct p. left; assumption.

    rewrite convertR_local in LOC23'.

      left; apply joinI; right.

      split; trivial.

      destruct (disjoint_extern_local _ WD23 b2); trivial. congruence.



destruct HH as [N [? [? [? ?]]]]. subst.

  rewrite <- H1 in *.



  assert (VB2: (Mem.nextblock m2 <= Mem.nextblock m2 + Pos.of_nat N)%positive).

    xomega.

  assert (VBj12: forall (b1 b2 : block) (ofs2 : Z),

                 as_inj nu12 b1 = Some (b2, ofs2) ->

                 (b1 < Mem.nextblock m1)%positive /\ (b2 < Mem.nextblock m2)%positive).

     intros. split; eapply SMV12; eapply as_inj_DomRng; eassumption.



  assert (RUD:= RU_D _ _ inc12 (as_inj nu')).

  assert (VBj12'_2: forall (b1 b2 : block) (delta : Z),

        (removeUndefs (as_inj nu12) (as_inj nu') j12') b1 = Some (b2, delta) ->

        (b2 < Mem.nextblock m2 + Pos.of_nat N)%positive).

    intros. apply RUD in H0.

    destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12 VBj23 _ _ _ H0)

      as [KK | [KK |KK]].

       destruct KK as [? [? ?]].  xomega.

       destruct KK as [? [? [? [? U]]]]; apply U.

       destruct KK as [M [? [? [? [? U]]]]]; apply U.

  assert (INC12RU: inject_incr (as_inj nu12) (removeUndefs (as_inj nu12) (as_inj nu') j12')).

     unfold removeUndefs. intros b; intros.

     rewrite H0. trivial.

  assert (VBj12'_1: forall (b1 b2 : block) (delta : Z),

        (removeUndefs (as_inj nu12) (as_inj nu') j12') b1 = Some (b2, delta) ->

        (b1 < Mem.nextblock m1 + Pos.of_nat N)%positive).

    intros. apply RUD in H0.

    destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12 VBj23 _ _ _ H0)

      as [KK | [KK |KK]].

       destruct KK as [? [? ?]].  xomega.

       destruct KK as [? [? [? [U ?]]]]; apply U.

       destruct KK as [M [? [? [? [U ?]]]]]; apply U.

  assert (VB1': forall (b1 b2 : block) (delta : Z),

               removeUndefs (as_inj nu12) (as_inj nu') j12' b1 = Some (b2, delta) ->

               Mem.valid_block m1' b1).

    intros. unfold Mem.valid_block. rewrite <- H1.

            eapply VBj12'_1; eassumption.

  assert (JJ12: forall (b1 b2 : block) (delta : Z),

                removeUndefs (as_inj nu12) (as_inj nu') j12' b1 = Some (b2, delta) ->

                Mem.valid_block m2 b2 -> as_inj nu12 b1 = Some (b2, delta)).

     intros. apply RUD in H0.

    destruct (mkInjections_3V _ _ _ _ _ _ _ _ _ _ HeqMKI VBj12 VBj23 _ _ _ H0)

      as [KK | [KK |KK]].

       destruct KK as [? [? ?]]. assumption.

       destruct KK as [? [? [? [U ?]]]]. subst.

         unfold Mem.valid_block in H2. xomega.

       destruct KK as [M [? [? [? [U ?]]]]]. subst.

         unfold Mem.valid_block in H2. xomega.

  exists (mkEFF nu23 nu12 j23' (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                  (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2)

               (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                    m1' m2 INC12RU VB1' JJ12)

                WDnu12 _ VB2 VBj12'_2).

  destruct (effect_interp_OK _ _ _ MInj12 _ Fwd1 _ _ MInj23

      _ Fwd3 _ WDnu' SMvalNu' MemInjNu' ExtIncr SMInjSep SMV12 SMV23

      UnchPrivSrc UnchLOOR13 GlueInvNu Norm12 _ _ _ _

      HeqMKI _ (eq_refl _)

      (mkEFF nu23 nu12 j23' (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                  (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2)

               (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                    m1' m2 INC12RU VB1' JJ12)

                WDnu12 _ VB2 VBj12'_2))

       as [unchA [unchB  [nu12' [nu23' [Hnu12' [Hnu23'

           [Hnu' [extInc12 [extInc23 [smSep12 [smSep23

             [smvNu12' [smvNu23' [Glue123 [Ext123 [Fwd2 [MInjNu12' InjNu23']]]]]]]]]]]]]]]]].

   

     unfold mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 j23'

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (Mem.nextblock m2 + Pos.of_nat N) VB2 VBj12'_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

            m1' m2)

         (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

            INC12RU VB1' JJ12) WDnu12

         (Mem.nextblock m2 + Pos.of_nat N)%positive)

       as [CM [CDefault PCM]].

     simpl. reflexivity.

   

     unfold ContentEffProperty, mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 j23'

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (Mem.nextblock m2 + Pos.of_nat N) VB2 VBj12'_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

            m1' m2)

         (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

            INC12RU VB1' JJ12) WDnu12

         (Mem.nextblock m2 + Pos.of_nat N)%positive)

       as [CM [CDefault PCM]].

     simpl.

     intros. rewrite PCM; clear PCM.

     

      split; intros.

          remember (locBlocksSrc nu23 b2) as d.

          destruct d; apply eq_sym in Heqd.

            remember (pubBlocksSrc nu23 b2) as q.

            destruct q; apply eq_sym in Heqq.

              destruct (pubSrc _ WDnu23 _ Heqq) as [b3 [d2 [Pub23 Tgt3]]].

              apply (pub_in_all _ WDnu23) in Pub23.

              remember (source (local_of nu12) m1 b2 ofs2) as src.

              destruct src.

                destruct p.

                remember (pubBlocksSrc nu12 b) as w.

                destruct w; apply eq_sym in Heqw.

                  unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_ValidBlock_FUN.

                  rewrite Heqd, Heqq. rewrite <- Heqsrc. rewrite Heqw. trivial.

                  exfalso. apply n. clear -H0. unfold Mem.valid_block in H0. xomega.

                unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                     (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_ValidBlock_FUN.

                  rewrite Heqd, Heqq. rewrite <- Heqsrc. rewrite Heqw. trivial.

                  exfalso. apply n. clear -H0. unfold Mem.valid_block in H0. xomega.

             unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_ValidBlock_FUN.

                  rewrite Heqd, Heqq. rewrite <- Heqsrc. trivial.

                  exfalso. apply n. clear -H0. unfold Mem.valid_block in H0. xomega.

            unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_ValidBlock_FUN.

                  rewrite Heqd, Heqq. trivial.

                  exfalso. apply n. clear -H0. unfold Mem.valid_block in H0. xomega.

          unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_ValidBlock_FUN.

                  rewrite Heqd.

                  remember (source (as_inj nu12) m1 b2 ofs2) as src.

                  destruct src; trivial. destruct p1; trivial.

                exfalso. apply n. clear -H0. unfold Mem.valid_block in H0. xomega.

    split; intros.

     

            unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s; clear Heqs. destruct a.

                  rewrite H3; clear H3.

                  unfold ContentMap_EFF_Block_FUN.

                  destruct (plt b2 (Mem.nextblock m2)); try contradiction.

                  unfold ContentMap_EFF_InvalidBlock_FUN.

                  remember (source (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' b2 ofs2) as src.

                  destruct src. destruct p0; trivial. trivial.

               remember (source (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' b2 ofs2) as src.

                  destruct src. destruct p.

                    destruct (source_SomeE _ _ _ _ _ Heqsrc)

                      as [bb1 [dd1 [ofs11 [PP [VBB [ JJ [PERM Off2]]]]]]].

                    clear Heqsrc; subst. apply eq_sym in PP. inv PP.

                    apply VBj12'_2 in JJ. contradiction.

                  rewrite ZMap.gi. trivial.

             unfold ContentsMap_EFF_FUN.

                  destruct (plt b2 (Mem.nextblock m2 + Pos.of_nat N)); try contradiction.

                  remember (CM_block_EFF_existsT nu23 nu12

                      (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

                      (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

                             m1' m2)

                      (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

                         INC12RU VB1' JJ12) WDnu12 b2).

                  destruct s. clear Heqs. apply a.

                reflexivity.

   

     unfold AccessEffProperty, mkEFF.

     destruct (mkAccessMap_EFF_existsT nu23 nu12 j23'

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (Mem.nextblock m2 + Pos.of_nat N) VB2 VBj12'_2) as [AM [ADefault PAM]].

     simpl.

     destruct (ContentsMap_EFF_existsT nu23 nu12

         (removeUndefs (as_inj nu12) (as_inj nu') j12') m1 m1' m2

         (MINMAX_Offset nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12')

            m1' m2)

         (MINMAX nu12 (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' m2

            INC12RU VB1' JJ12) WDnu12

         (Mem.nextblock m2 + Pos.of_nat N)%positive)

       as [CM [CDefault PCM]].

     simpl.

     intros. rewrite PAM; clear PAM.

       unfold AccessMap_EFF_FUN.

       simpl in *.

       destruct (plt b2 (Mem.nextblock m2)).

         split; intros; try contradiction.

           remember (locBlocksSrc nu23 b2) as d.

           destruct d.

             remember (pubBlocksSrc nu23 b2) as q.

             destruct q; apply eq_sym in Heqq.

               destruct (pubSrc _ WDnu23 _ Heqq) as [b3 [d2 [Pub23 T3]]].

               apply (pub_in_all _ WDnu23) in Pub23.

               remember (source (local_of nu12) m1 b2 ofs2) as src.

               destruct src; trivial.

                 destruct p0.

                 destruct (pubBlocksSrc nu12 b); trivial.

               trivial.

           

              remember (source (as_inj nu12) m1 b2 ofs2) as src.

              destruct src.

                destruct p0; trivial.

                remember (as_inj nu23 b2) as q.

                destruct q; apply eq_sym in Heqq.

                  destruct p0. rewrite (inc23 _ _ _ Heqq). trivial.

              remember (j23' b2) as w.

                destruct w; trivial; apply eq_sym in Heqw.

                destruct p0.

                destruct (sep23 _ _ _ Heqq Heqw). contradiction.

         split; intros; try contradiction.

           remember (source (removeUndefs (as_inj nu12) (as_inj nu') j12') m1' b2 ofs2) as d.

           destruct d; trivial. destruct p; trivial.

  exists nu12', nu23'.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.

  split; trivial.



  split; intros.

    clear - H0 extInc12 Hnu12' Glue123.

    remember (as_inj nu12 b1) as d.

    destruct d; apply eq_sym in Heqd.

      destruct p. apply extern_incr_as_inj in extInc12.

      rewrite (extInc12 _ _ _ Heqd) in H0.

      left; trivial.

      apply  Glue123.

    clear Glue123; subst.

      destruct (joinD_None _ _ _ Heqd).

      destruct (joinD_Some _ _ _ _ _ H0)

            as [EXT | [EXT LOC]]; clear H0;

         rewrite convertL_extern in EXT.

       unfold join, removeUndefs in EXT.

          rewrite H, H1, Heqd in EXT.

          destruct (as_inj nu' b1); try discriminate.

          destruct p. right. exists b, z; trivial.

      rewrite convertL_local in LOC. congruence.

  split; intros.

    remember (as_inj nu23 b2) as d.

    destruct d; apply eq_sym in Heqd.

      destruct p. apply extern_incr_as_inj in extInc23.

      rewrite (extInc23 _ _ _ Heqd) in H0.

      left; trivial.

      apply  Glue123.

    clear Glue123; rewrite Hnu12', Hnu23', Hnu' in *.

      clear Hnu12' Hnu23' Hnu'; subst.

      destruct (joinD_None _ _ _ Heqd).

      destruct (joinD_Some _ _ _ _ _ H0)

            as [EXT | [EXT LOC]]; clear H0;

         rewrite convertR_extern in EXT.

       unfold join, removeUndefs in EXT.

          rewrite H2, H3 in EXT.

          destruct (mkInjections_4 _ _ _ _ _ _ _ _ _ _ HeqMKI

             _ _ _ EXT) as [AA | [AA | AA]].

            congruence.

            destruct AA; right. exists (Mem.nextblock m1), d2. assumption.

            destruct AA as [mm [? ?]]; right.

              exists (Mem.nextblock m1 + mm)%positive, d2. assumption.

      rewrite convertR_local in LOC. congruence.

  destruct GlueInvNu as [WD12 [WD23 _]].

  split; intros.

    rewrite Hnu12' in H0. clear - HeqMKI WD12 H0.

    destruct (joinD_Some _ _ _ _ _ H0) as [EXT12' | [EXT12' LOC12']];

       clear H0; rewrite convertL_extern in EXT12'.

      destruct (joinD_Some _ _ _ _ _ EXT12') as

          [EXT12 | [EXT12 LOC12]]; clear EXT12'.

        left; apply joinI; left; assumption.

      remember (local_of nu12 b1) as d.

       destruct d; apply eq_sym in Heqd. inv LOC12.

        unfold removeUndefs in LOC12.

        remember (as_inj nu12 b1) as q.

        destruct q; apply eq_sym in Heqq.

        destruct p. left; assumption.

        destruct (as_inj nu' b1); try congruence.

        destruct p.

        destruct (mkInjections_3 _ _ _ _ _ _ _ _ _ _ HeqMKI

           _ _ _ LOC12) as [AA | AA].

          congruence.

          right. apply AA.

    rewrite convertL_local in LOC12'.

      left; apply joinI; right.

      split; trivial.

      destruct (disjoint_extern_local _ WD12 b1); trivial. congruence.

  rewrite Hnu23' in H0.

    destruct (joinD_Some _ _ _ _ _ H0) as [EXT23' | [EXT23' LOC23']];

       clear H0; rewrite convertR_extern in EXT23'.

      destruct (joinD_Some _ _ _ _ _ EXT23') as

          [EXT23 | [EXT23 LOC23]]; clear EXT23'.

        left; apply joinI; left; assumption.

      remember (local_of nu23 b2) as d.

       destruct d; apply eq_sym in Heqd. inv LOC23.

       apply (mkInjections_4 _ _ _ _ _ _ _ _ _ _ HeqMKI _ _ _ LOC23).

    rewrite convertR_local in LOC23'.

      left; apply joinI; right.

      split; trivial.

      destruct (disjoint_extern_local _ WD23 b2); trivial. congruence.

Qed.



Lemma EFF_interp_II: forall m1 m2 nu12

                             (MInj12 : Mem.inject (as_inj nu12) m1 m2) m1'

                             (Fwd1: mem_forward m1 m1') nu23 m3

                             (MInj23 : Mem.inject (as_inj nu23) m2 m3) m3'

                             (Fwd3: mem_forward m3 m3')

                              nu' (WDnu' : SM_wd nu')

                             (SMvalNu' : sm_valid nu' m1' m3')

                             (MemInjNu' : Mem.inject (as_inj nu') m1' m3')



                             (ExtIncr: extern_incr (compose_sm nu12 nu23) nu')

                             (SMInjSep: sm_inject_separated (compose_sm nu12 nu23) nu' m1 m3)

                             (SMV12: sm_valid nu12 m1 m2)

                             (SMV23: sm_valid nu23 m2 m3)

                             (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc (compose_sm nu12 nu23) b = true /\

                                                      pubBlocksSrc (compose_sm nu12 nu23) b = false) m1 m1')

                             (UnchLOOR13: Mem.unchanged_on (local_out_of_reach (compose_sm nu12 nu23) m1) m3 m3')



                             (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\

                                         locBlocksTgt nu12 = locBlocksSrc nu23 /\

                                         extBlocksTgt nu12 = extBlocksSrc nu23 /\

                                         (forall b, pubBlocksTgt nu12 b = true ->

                                                    pubBlocksSrc nu23 b = true) /\

                                         (forall b, frgnBlocksTgt nu12 b = true ->

                                                    frgnBlocksSrc nu23 b = true))

                             (Norm12: forall b1 b2 d1, extern_of nu12 b1 = Some(b2,d1) ->

                                             exists b3 d2, extern_of nu23 b2 = Some(b3, d2)),

     exists m2', exists nu12', exists nu23', nu'=compose_sm nu12' nu23' /\

                             extern_incr nu12 nu12' /\ extern_incr nu23 nu23' /\

                             Mem.inject (as_inj nu12') m1' m2' /\ mem_forward m2 m2' /\

                             Mem.inject (as_inj nu23') m2' m3' /\

                             sm_inject_separated nu12 nu12' m1 m2 /\

                             sm_inject_separated nu23 nu23' m2 m3 /\

                             sm_valid nu12' m1' m2' /\ sm_valid nu23' m2' m3' /\

                             (SM_wd nu12' /\ SM_wd nu23' /\

                              locBlocksTgt nu12' = locBlocksSrc nu23' /\

                              extBlocksTgt nu12' = extBlocksSrc nu23' /\

                              (forall b, pubBlocksTgt nu12' b = true ->

                                         pubBlocksSrc nu23' b = true) /\

                              (forall b, frgnBlocksTgt nu12' b = true ->

                                         frgnBlocksSrc nu23' b = true)) /\

                             (forall b1 b2 d1, extern_of nu12' b1 = Some(b2,d1) ->

                                     exists b3 d2, extern_of nu23' b2 = Some(b3, d2)) /\

                              Mem.unchanged_on (fun b ofs => locBlocksSrc nu23 b = true /\

                                                             pubBlocksSrc nu23 b = false) m2 m2' /\

                              Mem.unchanged_on (local_out_of_reach nu12 m1) m2 m2'

                          .

Proof. intros.

  destruct (EFF_interp_II_strong _ _ _ MInj12 _ Fwd1 _ _ MInj23 _

              Fwd3 _ WDnu' SMvalNu' MemInjNu' ExtIncr SMInjSep

              SMV12 SMV23 UnchPrivSrc UnchLOOR13 GlueInvNu Norm12)

  as [m2' [nu12' [nu23' [A [B [C [D [E [F [G [H [I [J [K [L [M [N P]]]]]]]]]]]]]]]]].

  exists m2', nu12', nu23'. intuition.

Qed.

