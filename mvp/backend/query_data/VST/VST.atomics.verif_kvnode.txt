Require Import VST.progs.ghost.
Require Import atomics.verif_atomics.
(* atomics.verif_atomics:
Definition acquire_spec := DECLARE _acquire acquire_spec.
Definition release_spec := DECLARE _release release_spec.
Definition makelock_spec := DECLARE _makelock (makelock_spec _).
Definition freelock_spec := DECLARE _freelock (freelock_spec _).

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH n:Z
   PRE [ _n OF tuint ]
       PROP (0 <= n <= Int.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh n p * memory_block Tsh n p).

Definition tatomic := Tstruct _atomic_loc noattr.

Definition A_inv p l R := EX v : Z, !!(repable_signed v) &&
  (field_at Tsh tatomic [StructField _val] (vint v) p * R v *
   (weak_precise_mpred (R v) && emp) * malloc_token Tsh (sizeof tatomic) p * malloc_token Tsh (sizeof tlock) l).

Definition atomic_loc sh p R := !!(field_compatible tatomic [] p) &&
  (EX lock : val, field_at sh tatomic [StructField _lock] lock p * lock_inv sh lock (A_inv p lock R)).

Lemma A_inv_super_non_expansive : forall n p l R,
  compcert_rmaps.RML.R.approx n (A_inv p l R) =

Lemma atomic_loc_super_non_expansive : forall n sh p R,
  compcert_rmaps.RML.R.approx n (atomic_loc sh p R) =

Definition MA_spec i P (R : Z -> mpred) Q := view_shift P (R i * (weak_precise_mpred (R i) && emp) * Q).

Definition MA_type := ProdType (ProdType (ProdType (ConstType Z) Mpred) (ArrowType (ConstType Z) Mpred)) Mpred.

Program Definition make_atomic_spec := DECLARE _make_atomic TYPE MA_type
  WITH i : Z, P : mpred, R : Z -> mpred, Q : mpred
  PRE [ _i OF tint ]
   PROP (MA_spec i P R Q; repable_signed i)
   LOCAL (temp _i (vint i))
   SEP (P)
  POST [ tptr tatomic ]
   EX p : val,
   PROP ()
   LOCAL (temp ret_temp p)
   SEP (atomic_loc Tsh p R; Q).

Program Definition free_atomic_spec := DECLARE _free_atomic
  TYPE ProdType (ConstType val) (ArrowType (ConstType Z) Mpred)
  WITH p : val, R : Z -> mpred
  PRE [ _tgt OF tptr tatomic ]
   PROP ()
   LOCAL (temp _tgt p)
   SEP (atomic_loc Tsh p R)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (R v).

Definition AL_spec P (R : Z -> mpred) Q := forall vx, repable_signed vx -> view_shift (R vx * P) (R vx * Q vx).

Definition AL_type := ProdType (ProdType (ProdType (ConstType (share * val))
  Mpred) (ArrowType (ConstType Z) Mpred)) (ArrowType (ConstType Z) Mpred).

Program Definition load_SC_spec := DECLARE _load_SC TYPE AL_type
  WITH sh : share, tgt : val, P : mpred, R : Z -> mpred, Q : Z -> mpred
  PRE [ _tgt OF tptr tatomic ]
   PROP (AL_spec P R Q; readable_share sh)
   LOCAL (temp _tgt tgt)
   SEP (atomic_loc sh tgt R; P)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (atomic_loc sh tgt R; Q v).

Definition AS_spec v P (R : Z -> mpred) Q := forall vx, repable_signed vx ->
  view_shift (R vx * P)
  (R v * (weak_precise_mpred (R v) && emp) * Q).

Definition AS_type := ProdType (ProdType (ProdType
  (ConstType (share * val * Z)) Mpred) (ArrowType (ConstType Z) Mpred)) Mpred.

Program Definition store_SC_spec := DECLARE _store_SC
  TYPE AS_type WITH sh : share, tgt : val, v : Z, P : mpred, R : Z -> mpred, Q : mpred
  PRE [ _tgt OF tptr tatomic, _v OF tint ]
   PROP (AS_spec v P R Q; readable_share sh; repable_signed v)
   LOCAL (temp _tgt tgt; temp _v (vint v))
   SEP (atomic_loc sh tgt R; P)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (atomic_loc sh tgt R; Q).

Definition ACAS_spec c v P (R Q : Z -> mpred) := forall vx, repable_signed vx ->
  view_shift (R vx * P)
  (R (if eq_dec c vx then v else vx) * (weak_precise_mpred (R (if eq_dec c vx then v else vx)) && emp) * Q vx).

Definition ACAS_type := ProdType (ProdType (ProdType
  (ConstType (share * val * Z * Z)) Mpred)
  (ArrowType (ConstType Z) Mpred))
  (ArrowType (ConstType Z) Mpred).

Program Definition CAS_SC_spec := DECLARE _CAS_SC
  TYPE ACAS_type WITH sh : share, tgt : val, c : Z, v : Z, P : mpred, R : Z -> mpred, Q : Z -> mpred
  PRE [ _tgt OF tptr tatomic, _c OF tint, _v OF tint ]
   PROP (ACAS_spec c v P R Q; readable_share sh; repable_signed c; repable_signed v)
   LOCAL (temp _tgt tgt; temp _c (vint c); temp _v (vint v))
   SEP (atomic_loc sh tgt R; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (if eq_dec c v' then vint 1 else vint 0))
   SEP (atomic_loc sh tgt R; Q v').

Definition Gprog : funspecs := ltac:(with_library prog [acquire_spec; release_spec; makelock_spec; freelock_spec;
  surely_malloc_spec; make_atomic_spec; free_atomic_spec; load_SC_spec; store_SC_spec; CAS_SC_spec]).

Lemma body_surely_malloc: semax_body Vprog Gprog f_surely_malloc surely_malloc_spec.

Lemma A_inv_positive : forall x l R, positive_mpred (A_inv x l R).
Hint Resolve A_inv_positive.

Lemma A_inv_precise : forall x l R,
  predicates_hered.derives TT (weak_precise_mpred (A_inv x l R)).

Lemma body_make_atomic : semax_body Vprog Gprog f_make_atomic make_atomic_spec.

Lemma body_free_atomic : semax_body Vprog Gprog f_free_atomic free_atomic_spec.

Lemma body_load_SC : semax_body Vprog Gprog f_load_SC load_SC_spec.

Lemma body_store_SC : semax_body Vprog Gprog f_store_SC store_SC_spec.

Lemma body_CAS_SC : semax_body Vprog Gprog f_CAS_SC CAS_SC_spec.

Lemma atomic_loc_isptr : forall sh p R, atomic_loc sh p R = !!isptr p && atomic_loc sh p R.
Hint Resolve atomic_loc_isptr : saturate_local.

Lemma atomic_loc_precise : forall sh p R, readable_share sh -> precise (atomic_loc sh p R).

Lemma atomic_loc_join : forall sh1 sh2 sh p R (Hjoin : sepalg.join sh1 sh2 sh)

Fixpoint apply_hist a h :=
  match h with
  | [] => Some a
  | Load v :: h' => if eq_dec v a then apply_hist a h' else None
  | Store v :: h' => apply_hist v h'
  | CAS r c w :: h' => if eq_dec r a then if eq_dec c a then apply_hist w h' else apply_hist a h' else None
  end.

Notation hist := (list (nat * hist_el)).

Lemma apply_hist_app : forall h1 i h2, apply_hist i (h1 ++ h2) =
  match apply_hist i h1 with Some v => apply_hist v h2 | None => None end.

Definition writes e v :=
  match e with
  | Load _ => False
  | Store v' => v' = v
  | CAS r c v' => r = c /\ v' = v
  end.

Lemma change_implies_write : forall v h i, apply_hist i h = Some v -> v <> i ->
  exists e, In e h /\ writes e v.

Definition value_of e :=
  match e with
  | Load v => v
  | Store v => v
  | CAS r c w => if eq_dec r c then w else r
  end.

Lemma apply_one_value : forall i a v, apply_hist i [a] = Some v -> value_of a = v.

Definition last_value (h : hist) v :=
  
  (h = [] /\ v = vint 0) \/
  exists n e, In (n, e) h /\ value_of e = v /\ Forall (fun x => let '(m, _) := x in m <= n)%nat h.

Lemma last_value_new : forall h n e, newer h n ->
  last_value (h ++ [(n, e)]) (value_of e).

Definition value_of_hist (h : hist) := value_of (snd (last h (O, Store (vint 0)))).

Lemma value_of_hist_snoc : forall h t e, value_of_hist (h ++ [(t, e)]) = value_of e.

Notation ordered_hist := (ordered_hist (Store (vint 0))).

Lemma ordered_last_value : forall h v (Hordered : ordered_hist h), last_value h v <-> value_of_hist h = v.

Lemma hist_list_value : forall h l v (Horder : ordered_hist h) (Hl : hist_list h l)
  (Hv : apply_hist (vint 0) l = Some v), value_of_hist h = v.

Definition full_hist h v := exists l, hist_list h l /\ apply_hist (vint 0) l = Some (vint v).

Definition full_hist' h v := exists l, hist_list' h l /\ apply_hist (vint 0) l = Some v.

Lemma full_hist_weak : forall h v (Hl : full_hist h v), full_hist' h (vint v).

Lemma full_hist'_drop : forall h h' v (Hh : full_hist' h v)
  (Hh' : incl h' h) (HNoDup : NoDup (map fst h'))
  (Hdiff : forall t e, In (t, e) h -> ~In (t, e) h' -> forall v, ~writes e v),
  full_hist' h' v.

Lemma full_hist'_nil : forall n l, Forall2 full_hist' (repeat [] n) l -> l = repeat (vint 0) n.

Corollary full_hist_nil' : forall n l (Hfull : Forall2 full_hist' (repeat [] n) (map (fun x => vint x) l))
  (Hrep : Forall repable_signed l), l = repeat 0 n.

Corollary full_hist_nil : forall n l (Hfull : Forall2 full_hist (repeat [] n) l)
  (Hrep : Forall repable_signed l), l = repeat 0 n.

Definition int_op e :=
  match e with
  | Load v | Store v => tc_val tint v
  | CAS r c w => tc_val tint r /\ tc_val tint c /\ tc_val tint w
  end.

Definition make_int v := match v with Vint i => Int.signed i | _ => 0 end.

Lemma make_int_spec : forall v, tc_val tint v -> vint (make_int v) = v.

Lemma make_int_repable : forall v, repable_signed (make_int v).

Lemma int_op_value : forall e, int_op e -> tc_val tint (value_of e).

Corollary int_op_value_of_hist : forall h, Forall int_op (map snd h) -> tc_val tint (value_of_hist h).

Lemma apply_int_ops : forall v h i (Hv : apply_hist (Vint i) h = Some v)
  (Hints : Forall int_op h), tc_val tint v.

Definition hist_R g i R v := EX h : _, !!(apply_hist (vint i) h = Some (vint v)) && ghost_ref h g * R h v.

Definition atomic_loc_hist sh p g i R (h : hist) := atomic_loc sh p (hist_R g i R) * ghost_hist sh h g.

Lemma atomic_loc_hist_isptr : forall sh p g i R h,
  atomic_loc_hist sh p g i R h = !!(isptr p) && atomic_loc_hist sh p g i R h.
Hint Resolve atomic_loc_hist_isptr : saturate_local.

Lemma hist_R_precise : forall p i R v, precise (EX h : _, R h v) -> precise (hist_R p i R v).
Hint Resolve hist_R_precise.

Lemma atomic_loc_hist_precise : forall sh p g i R, readable_share sh ->
  precise (EX h : _, atomic_loc_hist sh p g i R h).

Notation init_hist := (Some (Tsh, [] : hist), Some ([] : hist)).

Notation MA_witness g i R :=
  (i%Z, ghost init_hist g * R%function [] i%Z, hist_R g i R, ghost_hist Tsh ([] : hist) g).
Lemma MA_hist_spec : forall g i R, precise (EX h : _, R h i) ->
  MA_spec i (ghost init_hist g * R [] i) (hist_R g i R) (ghost_hist Tsh ([] : hist) g).

Inductive add_events h : list hist_el -> hist -> Prop :=
| add_events_nil : add_events h [] h
| add_events_snoc : forall le h' t e (Hh' : add_events h le h') (Ht : newer h' t),
    add_events h (le ++ [e]) (h' ++ [(t, e)]).
Hint Resolve add_events_nil.

Lemma add_events_1 : forall h t e (Ht : newer h t), add_events h [e] (h ++ [(t, e)]).

Lemma add_events_trans : forall h le h' le' h'' (H1 : add_events h le h') (H2 : add_events h' le' h''),
  add_events h (le ++ le') h''.

Lemma add_events_add : forall h le h', add_events h le h' -> exists h2, h' = h ++ h2 /\ map snd h2 = le.

Corollary add_events_snd : forall h le h', add_events h le h' -> map snd h' = map snd h ++ le.

Corollary add_events_incl : forall h le h', add_events h le h' -> incl h h'.

Corollary add_events_newer : forall h le h' t, add_events h le h' -> newer h' t -> newer h t.

Lemma add_events_in : forall h le h' e, add_events h le h' -> In e le -> exists t, newer h t /\ In (t, e) h'.

Lemma add_events_ordered : forall h le h', add_events h le h' -> ordered_hist h -> ordered_hist h'.

Lemma add_events_last : forall h le h', add_events h le h' -> le <> [] ->
  value_of_hist h' = value_of (last le (Store (vint 0))).

Lemma add_events_NoDup : forall h le h', add_events h le h' -> NoDup (map fst h) -> NoDup (map fst h').

Notation AL_witness sh p g i R h P Q :=
  (sh%logic, p%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   EX h' : hist, fun v => !!(add_events h [Load (vint v)] h') && ghost_hist sh h' g * Q v).
Lemma AL_hist_spec : forall sh g i R h P Q
  (HPQR : forall h' v (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v) -> repable_signed v ->
    view_shift (R h' v * P) (R (h' ++ [Load (vint v)]) v * Q v)) (Hsh : sh <> Share.bot),

Notation AS_witness sh p g i R h v P Q :=
  (sh%logic, p%logic, v%Z%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   EX h' : hist, !!(add_events h [Store (vint v)] h') && ghost_hist sh h' g * Q).
Lemma AS_hist_spec : forall sh g i R h v P Q
  (HPQR : forall h' v' (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v') -> repable_signed v' ->
     view_shift (R h' v' * P) (R (h' ++ [Store (vint v)]) v * Q)) (Hsh : sh <> Share.bot)

Notation ACAS_witness sh p g i R h c v P Q :=
  (sh%logic, p%logic, c%Z%logic, v%Z%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   fun v' => EX h' : hist, !!(add_events h [CAS (vint v') (vint c) (vint v)] h') &&
     ghost_hist sh h' g * Q v').
Lemma ACAS_hist_spec : forall sh g i R h v c P Q
  (HPQR : forall h' v' (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v') -> repable_signed v' ->
    view_shift (R h' v' * P) (R (h' ++ [CAS (vint v') (vint c) (vint v)]) (if eq_dec c v' then v else v') * Q v'))
  (Hsh : sh <> Share.bot) (Hc : repable_signed c) (Hprecise : forall v, precise (EX h : _, R h v)),

Lemma atomic_loc_hist_join : forall sh1 sh2 sh p g i R h1 h2 h (Hjoin : sepalg.join sh1 sh2 sh) *)
Require Import VST.progs.conclib.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import atomics.kvnode.
(* atomics.kvnode:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition _CAS_SC : ident := 74%positive.
Definition ___builtin_annot : ident := 8%positive.
Definition ___builtin_annot_intval : ident := 9%positive.
Definition ___builtin_bswap : ident := 32%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 6%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 10%positive.
Definition ___builtin_memcpy_aligned : ident := 7%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 12%positive.
Definition ___builtin_va_copy : ident := 13%positive.
Definition ___builtin_va_end : ident := 14%positive.
Definition ___builtin_va_start : ident := 11%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 18%positive.
Definition ___compcert_va_float64 : ident := 17%positive.
Definition ___compcert_va_int32 : ident := 15%positive.
Definition ___compcert_va_int64 : ident := 16%positive.
Definition ___i64_dtos : ident := 19%positive.
Definition ___i64_dtou : ident := 20%positive.
Definition ___i64_sar : ident := 31%positive.
Definition ___i64_sdiv : ident := 25%positive.
Definition ___i64_shl : ident := 29%positive.
Definition ___i64_shr : ident := 30%positive.
Definition ___i64_smod : ident := 27%positive.
Definition ___i64_stod : ident := 21%positive.
Definition ___i64_stof : ident := 23%positive.
Definition ___i64_udiv : ident := 26%positive.
Definition ___i64_umod : ident := 28%positive.
Definition ___i64_utod : ident := 22%positive.
Definition ___i64_utof : ident := 24%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 59%positive.
Definition _atomic_loc : ident := 5%positive.
Definition _c : ident := 73%positive.
Definition _d : ident := 85%positive.
Definition _data : ident := 78%positive.
Definition _exit : ident := 54%positive.
Definition _free : ident := 55%positive.
Definition _free_atomic : ident := 68%positive.
Definition _freelock : ident := 58%positive.
Definition _i : ident := 64%positive.
Definition _in : ident := 84%positive.
Definition _l : ident := 65%positive.
Definition _load_SC : ident := 70%positive.
Definition _load_relaxed : ident := 75%positive.
Definition _lock : ident := 4%positive.
Definition _lock_t : ident := 2%positive.
Definition _main : ident := 76%positive.
Definition _make_atomic : ident := 66%positive.
Definition _makelock : ident := 57%positive.
Definition _malloc : ident := 56%positive.
Definition _n : ident := 61%positive.
Definition _node : ident := 79%positive.
Definition _out : ident := 80%positive.
Definition _p : ident := 62%positive.
Definition _read : ident := 83%positive.
Definition _release : ident := 60%positive.
Definition _snap : ident := 82%positive.
Definition _store_SC : ident := 72%positive.
Definition _surely_malloc : ident := 63%positive.
Definition _tgt : ident := 67%positive.
Definition _v : ident := 71%positive.
Definition _val : ident := 3%positive.
Definition _ver : ident := 81%positive.
Definition _version : ident := 77%positive.
Definition _write : ident := 86%positive.
Definition _x : ident := 69%positive.
Definition _t'1 : ident := 87%positive.
Definition _t'2 : ident := 88%positive.
Definition _t'3 : ident := 89%positive.

Definition f_read := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_out, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr (Tstruct _atomic_loc noattr))) ::
               (_snap, tint) :: (_i, tint) ::
               (_l, (tptr (Tstruct _atomic_loc noattr))) :: (_v, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _ver
        (Efield
          (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
            (Tstruct _node noattr)) _version
          (tptr (Tstruct _atomic_loc noattr))))
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _load_SC (Tfunction
                             (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil)
                             tint cc_default))
            ((Etempvar _ver (tptr (Tstruct _atomic_loc noattr))) :: nil))
          (Sset _snap (Etempvar _t'1 tint)))
        (Ssequence
          (Sifthenelse (Ebinop Oand (Etempvar _snap tint)
                         (Ebinop Oeq (Econst_int (Int.repr 1) tint)
                           (Econst_int (Int.repr 1) tint) tint) tint)
            Scontinue
            Sskip)
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 8) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Sset _l
                      (Ederef
                        (Ebinop Oadd
                          (Efield
                            (Ederef
                              (Etempvar _n (tptr (Tstruct _node noattr)))
                              (Tstruct _node noattr)) _data
                            (tarray (tptr (Tstruct _atomic_loc noattr)) 8))
                          (Etempvar _i tint)
                          (tptr (tptr (Tstruct _atomic_loc noattr))))
                        (tptr (Tstruct _atomic_loc noattr))))
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _load_SC (Tfunction
                                         (Tcons
                                           (tptr (Tstruct _atomic_loc noattr))
                                           Tnil) tint cc_default))
                        ((Etempvar _l (tptr (Tstruct _atomic_loc noattr))) ::
                         nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Etempvar _out (tptr tint))
                            (Etempvar _i tint) (tptr tint)) tint)
                        (Etempvar _t'2 tint)))))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Ssequence
                (Scall (Some _t'3)
                  (Evar _load_SC (Tfunction
                                   (Tcons (tptr (Tstruct _atomic_loc noattr))
                                     Tnil) tint cc_default))
                  ((Etempvar _ver (tptr (Tstruct _atomic_loc noattr))) ::
                   nil))
                (Sset _v (Etempvar _t'3 tint)))
              (Sifthenelse (Ebinop Oeq (Etempvar _v tint)
                             (Etempvar _snap tint) tint)
                (Sreturn None)
                Sskip)))))))
  Sskip)
|}.

Definition f_write := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_in, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr (Tstruct _atomic_loc noattr))) :: (_v, tint) ::
               (_i, tint) :: (_l, (tptr (Tstruct _atomic_loc noattr))) ::
               (_d, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _ver
    (Efield
      (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
        (Tstruct _node noattr)) _version (tptr (Tstruct _atomic_loc noattr))))
  (Ssequence
    (Ssequence
      (Scall (Some _t'1)
        (Evar _load_SC (Tfunction
                         (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil)
                         tint cc_default))
        ((Etempvar _ver (tptr (Tstruct _atomic_loc noattr))) :: nil))
      (Sset _v (Etempvar _t'1 tint)))
    (Ssequence
      (Scall None
        (Evar _store_SC (Tfunction
                          (Tcons (tptr (Tstruct _atomic_loc noattr))
                            (Tcons tint Tnil)) tvoid cc_default))
        ((Etempvar _ver (tptr (Tstruct _atomic_loc noattr))) ::
         (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 1) tint) tint) ::
         nil))
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 8) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Sset _l
                  (Ederef
                    (Ebinop Oadd
                      (Efield
                        (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
                          (Tstruct _node noattr)) _data
                        (tarray (tptr (Tstruct _atomic_loc noattr)) 8))
                      (Etempvar _i tint)
                      (tptr (tptr (Tstruct _atomic_loc noattr))))
                    (tptr (Tstruct _atomic_loc noattr))))
                (Ssequence
                  (Sset _d
                    (Ederef
                      (Ebinop Oadd (Etempvar _in (tptr tint))
                        (Etempvar _i tint) (tptr tint)) tint))
                  (Scall None
                    (Evar _store_SC (Tfunction
                                      (Tcons
                                        (tptr (Tstruct _atomic_loc noattr))
                                        (Tcons tint Tnil)) tvoid cc_default))
                    ((Etempvar _l (tptr (Tstruct _atomic_loc noattr))) ::
                     (Etempvar _d tint) :: nil)))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Scall None
          (Evar _store_SC (Tfunction
                            (Tcons (tptr (Tstruct _atomic_loc noattr))
                              (Tcons tint Tnil)) tvoid cc_default))
          ((Etempvar _ver (tptr (Tstruct _atomic_loc noattr))) ::
           (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 2) tint)
             tint) :: nil))))))
|}.

Definition composites : list composite_definition :=
(Composite _node Struct
   ((_version, (tptr (Tstruct _atomic_loc noattr))) ::
    (_data, (tarray (tptr (Tstruct _atomic_loc noattr)) 8)) :: nil)
   noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) (Tcons tint Tnil)) tvoid
     cc_default)) :: (_read, Gfun(Internal f_read)) ::
 (_write, Gfun(Internal f_write)) :: nil);
prog_public :=
(_write :: _read :: _store_SC :: _load_SC :: ___builtin_debug ::
 ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_fsqrt :: ___builtin_ctzll ::
 ___builtin_ctzl :: ___builtin_ctz :: ___builtin_clzll :: ___builtin_clzl ::
 ___builtin_clz :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod ::
 ___i64_smod :: ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof ::
 ___i64_utod :: ___i64_stod :: ___i64_dtou :: ___i64_dtos ::
 ___compcert_va_composite :: ___compcert_va_float64 ::
 ___compcert_va_int64 :: ___compcert_va_int32 :: ___builtin_va_end ::
 ___builtin_va_copy :: ___builtin_va_arg :: ___builtin_va_start ::
 ___builtin_membar :: ___builtin_annot_intval :: ___builtin_annot ::
 ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)

Set Bullet Behavior "Strict Subproofs".

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Definition tnode := Tstruct _node noattr.

Opaque upto.

Definition make_loads lv := map (fun v => Load (vint v)) lv.

Definition round_up i := i + i mod 2.
Definition round_down i := i - i mod 2.

Definition ver_R g gsh gv lg (h : list hist_el) v := ghost_master v g * ghost_var gsh v gv *
  fold_right sepcon emp (map (ghost_snap (round_down v)) lg).
Definition loc_R g gsh gl gv (h : list hist_el) (v : Z) := EX ver : Z, EX ver' : Z,
  !!(repable_signed ver' /\ ver <= round_up ver') &&
  ghost_master ver g * ghost_var gsh ver gl * ghost_snap ver' gv.

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,  x13 at level 0, x14 at level 0,
               x15 at level 0,
             P at level 100, Q at level 100).

Definition read_spec :=
 DECLARE _read
 WITH n : val, out : val, sh : share, version : val, locs : list val, gv : val, gsh : share, gv' : val,
   gv2 : val, lg : list val, lgl : list val, hv : hist, ghosts : list val, hists : list hist, v0 : Z
 PRE [ _n OF tptr tnode, _out OF tptr tint ]
  PROP (readable_share sh; Zlength lg = 8; Zlength ghosts = 8; Zlength hists = 8; v0 mod 2 = 0)
  LOCAL (temp _n n; temp _out out)
  SEP (data_at sh tnode (version, locs) n; data_at_ Tsh (tarray tint 8) out;
       atomic_loc_hist sh version gv 0 (ver_R gv2 gsh gv' lg) hv; ghost_snap v0 gv2;
       fold_right sepcon emp (map (fun i => atomic_loc_hist sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
         (loc_R (Znth i lg Vundef) gsh (Znth i lgl Vundef) gv2) (Znth i hists [])) (upto 8));
       fold_right sepcon emp (map (ghost_snap v0) lg))
 POST [ tvoid ]
  EX failvs : list Z, EX loops : Z, EX v : Z, EX hv' : hist, EX vals : list Z, EX hists' : list hist,
  PROP (v mod 2 = 0; add_events hv (make_loads (failvs ++ [v; v])) hv'; Forall repable_signed failvs;
        Forall repable_signed vals; Zlength hists' = 8; loops <= Zlength failvs)
  LOCAL ()
  SEP (data_at sh tnode (version, locs) n; data_at Tsh (tarray tint 8) (map (fun x => vint x) vals) out;
       atomic_loc_hist sh version gv 0 (ver_R gv2 gsh gv' lg) hv'; ghost_snap v gv2;
       fold_right sepcon emp (map (fun i => EX fails : list Z,
         !!(add_events (Znth i hists []) (make_loads (fails ++ [Znth i vals 0])) (Znth i hists' []) /\
            Zlength fails = loops) &&
         atomic_loc_hist sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
           (loc_R (Znth i lg Vundef) gsh (Znth i lgl Vundef) gv2) (Znth i hists' [])) (upto 8));
       fold_right sepcon emp (map (ghost_snap v) lg)).

Notation "'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 , x15 : t15 , x16 : t16 , x17 : t17 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (NDmk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default (t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14*t15*t16*t17)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => P%assert end)
           (fun x => match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17) => Q%assert end))
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,  x13 at level 0, x14 at level 0,
               x15 at level 0, x16 at level 0, x17 at level 0,
             P at level 100, Q at level 100).

Definition write_spec :=
 DECLARE _write
 WITH n : val, input : val, sh : share, version : val, locs : list val, vals : list Z, gv : val, gv2 : val,
   gsh1 : share, gsh2 : share, gv' : val, lg : list val, lgl : list val, hv : hist, ghosts : list val,
   hists : list hist, v : Z
 PRE [ _n OF tptr tnode, _in OF tptr tint ]
  PROP (readable_share sh; Forall repable_signed vals; Zlength lg = 8; Zlength lgl = 8; Zlength ghosts = 8;
        Zlength hists = 8; v mod 2 = 0; readable_share gsh1; readable_share gsh2; sepalg.join gsh1 gsh2 Tsh)
  LOCAL (temp _n n; temp _in input)
  SEP (data_at sh tnode (version, locs) n; data_at Tsh (tarray tint 8) (map (fun x => vint x) vals) input;
       atomic_loc_hist sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv; ghost_snap v gv2; ghost_var gsh1 v gv';
       fold_right sepcon emp (map (fun i => atomic_loc_hist sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
         (loc_R (Znth i lg Vundef) gsh2 (Znth i lgl Vundef) gv2) (Znth i hists [])) (upto 8));
       fold_right sepcon emp (map (ghost_snap v) lg); fold_right sepcon emp (map (ghost_var gsh1 v) lgl))
 POST [ tvoid ]
  EX hv' : hist, EX hists' : list hist,
  PROP (add_events hv [Load (vint v); Store (vint (v + 1)); Store (vint (v + 2))] hv'; Zlength hists' = 8;
        (v + 2) mod 2 = 0)
  LOCAL ()
  SEP (data_at sh tnode (version, locs) n; data_at Tsh (tarray tint 8) (map (fun x => vint x) vals) input;
       atomic_loc_hist sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv'; ghost_snap (v + 2) gv2;
       ghost_var gsh1 (v + 2) gv';
       fold_right sepcon emp (map (fun i =>
       !!(add_events (Znth i hists []) [Store (vint (Znth i vals 0))] (Znth i hists' [])) &&
       atomic_loc_hist sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
         (loc_R (Znth i lg Vundef) gsh2 (Znth i lgl Vundef) gv2) (Znth i hists' [])) (upto 8));
       fold_right sepcon emp (map (ghost_snap (v + 2)) lg);
       fold_right sepcon emp (map (ghost_var gsh1 (v + 2)) lgl)).

Definition Gprog : funspecs := ltac:(with_library prog [load_SC_spec; store_SC_spec; read_spec; write_spec]).

Ltac cancel_for_forward_call ::= repeat (rewrite ?sepcon_andp_prop', ?sepcon_andp_prop);
  repeat (apply andp_right; [auto; apply prop_right; auto|]); fast_cancel.

Lemma snap_snap_max : forall v1 v2 p,
  ghost_snap v1 p * ghost_snap v2 p = ghost_snap v1 p * ghost_snap (Z.max v1 v2) p.
Proof.
  intros; rewrite ghost_snap_join'.
  replace (Z.max v1 v2) with (Z.max v1 (Z.max v1 v2)) at 1.
  rewrite <- ghost_snap_join'; auto.
  { rewrite Z.max_r, Z.max_comm; auto.
    apply Z.le_max_l. }
Qed.

Lemma snaps_snaps_max : forall {cs : compspecs} (v1 v2 : Z) lg,
  @view_shift cs
    (fold_right sepcon emp (map (ghost_snap v1) lg) * fold_right sepcon emp (map (ghost_snap v2) lg))
    (fold_right sepcon emp (map (ghost_snap v1) lg) * fold_right sepcon emp (map (ghost_snap (Z.max v1 v2)) lg)).
Proof.
  induction lg; simpl; repeat intro; auto.
  rewrite <- sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)), <- sepcon_assoc.
  rewrite (sepcon_comm (ghost_snap _ _)), snap_snap_max.
  rewrite sepcon_assoc, sepcon_comm, flatten_sepcon_in_SEP.
  eapply IHlg, semax_pre; [|eauto].
  go_lowerx; entailer!.
Qed.

Lemma snaps_snaps_le : forall {cs : compspecs} v lg (lv : list Z) (Hlen : Zlength lv = Zlength lg),
 @view_shift cs
    (fold_right sepcon emp (map (ghost_snap v) lg) *
     fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv lg)))
    (fold_right sepcon emp (map (ghost_snap v) lg) * EX lv : list Z, !!(Zlength lv = Zlength lg /\
       Forall (fun v' => v <= v') lv) &&
     fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv lg))).
Proof.
  induction lg; simpl; repeat intro.
  - apply Zlength_nil_inv in Hlen; subst; simpl.
    eapply semax_pre; [|eauto].
    go_lowerx.
    Exists (@nil Z); entailer!.
  - destruct lv; [symmetry in Hlen; apply Zlength_nil_inv in Hlen; discriminate | simpl].
    rewrite <- sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)), <- sepcon_assoc.
    rewrite (sepcon_comm _ (ghost_snap _ _)), snap_snap_max.
    rewrite sepcon_assoc, sepcon_comm, flatten_sepcon_in_SEP.
    apply IHlg; auto.
    { rewrite !Zlength_cons in *; omega. }
    eapply semax_pre; [|eauto]; go_lowerx.
    Intros lv'; Exists (Z.max v z :: lv'); simpl; entailer!.
    split; [rewrite !Zlength_cons; omega|].
    constructor; auto.
    apply Zmax_bound_l; omega.
Qed.

Lemma land_1 : forall i, Z.land i 1 = i mod 2.
Proof.
  intros; apply Z.land_ones with (n := 1); omega.
Qed.

Lemma round_down_mono : forall v1 v2, v1 <= v2 -> round_down v1 <= round_down v2.
Proof.
  intros; unfold round_down.
  destruct (eq_dec v1 v2); [subst; omega|].
  exploit (Z_mod_lt v1 2); [computable|].
  exploit (Z_mod_lt v2 2); [computable|].
  omega.
Qed.

Lemma round_up_max_distr : forall v1 v2, round_up (Z.max v1 v2) = Z.max (round_up v1) (round_up v2).
Proof.
  intros; unfold round_up.
  exploit (Z_mod_lt v1 2); [computable|].
  exploit (Z_mod_lt v2 2); [computable|].
  intros; destruct (Z.max_spec v1 v2) as [(? & ->) | (? & ->)]; [rewrite Z.max_r | rewrite Z.max_l]; auto;
    try omega.
  destruct (eq_dec v1 v2); subst; omega.
Qed.

Lemma body_read : semax_body Vprog Gprog f_read read_spec.
Proof.
  start_function.
  apply semax_pre with (P' := EX failvs : list Z, EX loops : Z, EX hv' : hist, EX hists' : list hist, EX v0 : Z,
    PROP (add_events hv (make_loads failvs) hv'; Forall repable_signed failvs; Zlength hists' = 8;
          loops <= Zlength failvs)
    LOCAL (temp _n n; temp _out out)
    SEP (@data_at CompSpecs sh tnode (version, locs) n; data_at_ Tsh (tarray tint 8) out;
         atomic_loc_hist sh version gv 0 (ver_R gv2 gsh gv' lg) hv'; ghost_snap v0 gv2;
         fold_right sepcon emp (map (fun i => EX fails : list Z,
           !!(add_events (Znth i hists []) (make_loads fails) (Znth i hists' []) /\ Zlength fails = loops) &&
           atomic_loc_hist sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
             (loc_R (Znth i lg Vundef) gsh (Znth i lgl Vundef) gv2) (Znth i hists' [])) (upto 8));
         EX lv : list Z, !!(Zlength lv = 8) &&
             fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv lg)))).
  { Exists (@nil Z) 0 hv hists v0 (repeat v0 8).
    rewrite combine_const2, map_map by (simpl; omega); entailer!.
    apply sepcon_derives; auto.
    apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
    erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
    Exists (@nil Z); entailer!. }
  eapply semax_loop; [|forward; unfold loop2_ret_assert; apply ENTAIL_refl].
  - Intros failvs loops hv' hists' v1 lv.
    forward.
    unfold atomic_loc_hist at 1; rewrite atomic_loc_isptr; Intros.
    forward.
    assert (sh <> Share.bot) by (intro; subst; contradiction unreadable_bot).
    forward_call (AL_witness sh version gv 0 (ver_R gv2 gsh gv' lg) hv'
      (ghost_snap v1 gv2 * fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv lg)))
      (fun v => !!(v1 <= v) && ghost_snap v gv2 *
        EX lv : list Z, !!(Zlength lv = 8 /\ Forall (fun v' => round_down v <= v') lv) &&
         fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv lg)))).
    { split; auto.
      apply AL_hist_spec; auto; repeat intro.
      unfold ver_R in *.
      rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost_snap _ _)), <- 2sepcon_assoc.
      rewrite sepcon_assoc, 2flatten_sepcon_in_SEP.
      assert_PROP (v1 <= v).
      { rewrite snap_master_join'; go_lowerx; entailer!. }
      eapply snap_master_update' with (v' := v); [omega|].
      focus_SEP 2; apply snaps_snaps_le; [omega|].
      eapply semax_pre; [|eauto].
      go_lowerx.
      Intros lv'; Exists lv'; entailer!. }
    Intros v; simpl; Intros hv1 lv1.
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
      forward_if (PROP (Z.testbit v 0 = false) (LOCALx Q (SEPx R))) end.
    { eapply semax_pre; [|apply semax_continue].
      unfold POSTCONDITION, abbreviate, overridePost.
      destruct (eq_dec EK_continue EK_normal); [discriminate|].
      unfold loop1_ret_assert.
      Exists (failvs ++ [v]) loops hv1 hists' v; entailer!.
      - split; [unfold make_loads; rewrite map_app; eapply add_events_trans; eauto|].
        split; [rewrite Forall_app; auto|].
        rewrite Zlength_app, Zlength_cons, Zlength_nil; omega.
      - Exists lv1; entailer!. }
    { forward.
      entailer!.
      unfold Int.one in *; rewrite and_repr, land_1, Zmod_odd in *.
      destruct (Z.odd v); auto; discriminate. }
    Intros.
    forward_for_simple_bound 8 (EX i : Z, EX vals : list Z, PROP (Zlength vals = i; Forall repable_signed vals)
      LOCAL (temp _snap (vint v); temp _ver version; temp _n n; temp _out out)
      SEP (atomic_loc_hist sh version gv 0 (ver_R gv2 gsh gv' lg) hv1;
           @data_at CompSpecs sh tnode (version, locs) n;
           data_at Tsh (tarray tint 8) (map (fun x : Z => vint x) vals ++ repeat Vundef (Z.to_nat (8 - i))) out;
           EX hists'' : list hist, !!(Zlength hists'' = 8 /\ sublist i 8 hists'' = sublist i 8 hists') &&
           fold_right sepcon emp (map (fun j => EX fails : list Z, !!(add_events (Znth j hists [])
             (if zlt j i then make_loads (fails ++ [Znth j vals 0]) else make_loads fails) (Znth j hists'' []) /\
             Zlength fails = loops) &&
             atomic_loc_hist sh (Znth j locs Vundef) (Znth j ghosts Vundef) 0
               (loc_R (Znth j lg Vundef) gsh (Znth j lgl Vundef) gv2) (Znth j hists'' [])) (upto 8));
           EX v' : Z, EX lv' : list Z, !!(repable_signed v' /\ Zlength lv' = 8 /\
             Forall (fun vl => round_down v <= vl) lv' /\
             Forall (fun vl => vl <= round_up v') (sublist 0 i lv')) && ghost_snap v' gv2 *
             fold_right sepcon emp (map (fun '(v, g) => ghost_snap v g) (combine lv' lg)))).
    { Exists (@nil Z) hists' v lv1; unfold atomic_loc_hist at 2; rewrite data_at__eq, sublist_nil; entailer!. }
    + 
      Intros hists'' v' lv'.
      rewrite extract_nth_sepcon with (i := i) by (rewrite Zlength_map; auto).
      erewrite Znth_map, Znth_upto by (auto; simpl; omega); Intros.
      destruct (zlt i i); [omega|].
      Intros fails.
      rewrite extract_nth_sepcon with (i := i)(l := map _ _) by (rewrite Zlength_map, Zlength_combine, Z.min_l;
        auto; omega).
      rewrite Znth_map with (d' := (0, Vundef)), Znth_combine by (rewrite ?Zlength_combine, ?Z.min_l; omega).
      unfold atomic_loc_hist at 2; rewrite (atomic_loc_isptr _ (Znth i locs Vundef)); Intros.
      forward.
      assert (round_down v <= Znth i lv' 0) by (apply Forall_Znth; auto; omega).
      forward_call (AL_witness sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
        (loc_R (Znth i lg Vundef) gsh (Znth i lgl Vundef) gv2) (Znth i hists'' [])
        (ghost_snap v' gv2 * ghost_snap (Znth i lv' 0) (Znth i lg Vundef))
        (fun _ => EX ver : Z, EX ver' : Z, !!(repable_signed ver' /\ round_down v <= ver <= round_up ver') &&
           ghost_snap (Z.max ver' v') gv2 * ghost_snap ver (Znth i lg Vundef))).
      { split; auto.
        apply AL_hist_spec; auto; repeat intro.
        unfold loc_R in *.
        erewrite exp_sepcon1, extract_nth_exists_in_SEP with (n := O); [|simpl; eauto].
        Intro ver; simpl.
        erewrite exp_sepcon1, extract_nth_exists_in_SEP with (n := O); [|simpl; eauto].
        Intro ver'; simpl.
        erewrite !sepcon_andp_prop', extract_prop_in_SEP with (n := O); [|simpl; eauto].
        Intros; simpl.
        rewrite <- !sepcon_assoc, sepcon_comm, <- !sepcon_assoc.
        rewrite sepcon_assoc, 2flatten_sepcon_in_SEP.
        assert_PROP (Znth i lv' 0 <= ver).
        { rewrite snap_master_join'; go_lowerx; entailer!. }
        eapply snap_master_update' with (v'0 := ver); [omega|].
        rewrite snap_snap_max.
        eapply semax_pre; [|eauto].
        go_lowerx.
        Exists ver ver' ver ver'; entailer!. }
      Intros vi; simpl; Intros hi vers; destruct vers as (ver, ver').
      gather_SEP 3 8; rewrite replace_nth_sepcon.
      forward.
      Exists (x ++ [vi]) (upd_Znth i hists'' hi) (Z.max ver' v') (upd_Znth i lv' ver).
      rewrite map_app.
      replace (8 - (i + 1)) with (8 - (Zlength (map (fun x => vint x) x ++ [vint vi])))
        by (rewrite Zlength_app, Zlength_cons, Zlength_nil, Zlength_map; subst; auto).
      simpl map; rewrite <- upd_complete_gen by (rewrite Zlength_map; omega).
      match goal with H : sublist _ _ hists'' = sublist _ _ hists' |- _ =>
        rewrite sublist_next with (i0 := i)(l := hists'')(d := []),
          sublist_next with (i0 := i)(l := hists')(d := []) in H by (auto; omega); inv H end.
      rewrite combine_upd_Znth1 with (d := Vundef), <- upd_Znth_map by omega.
      subst; rewrite Zlength_map, !Zlength_app, !Zlength_cons, !Zlength_nil; entailer!.
      { split; [rewrite Forall_app; auto|].
        rewrite !upd_Znth_Zlength by omega.
        split; [|split].
        * split; auto.
          rewrite sublist_upd_Znth_r by omega; auto.
        * destruct (Z.max_spec ver' v') as [(? & ->) | (? & ->)]; auto.
        * split; auto.
          rewrite sublist_upd_Znth_lr, Z.sub_0_r by omega.
          split; [apply Forall_upd_Znth; auto; tauto|].
          rewrite sublist_split with (mid := Zlength x) by omega.
          rewrite upd_Znth_app2; rewrite !Zlength_sublist; try omega.
          rewrite Z.sub_0_r, Zminus_diag, sublist_len_1 with (d := 0), upd_Znth0, sublist_1_cons by omega.
          rewrite Zlength_cons, sublist_nil, Forall_app; repeat constructor.
          -- eapply Forall_impl; [|eauto]; simpl; intros.
             rewrite round_up_max_distr; apply Zmax_bound_r; tauto.
          -- rewrite round_up_max_distr; apply Zmax_bound_l; tauto. }
      rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; rewrite !Zlength_map;
        auto; intros.
      erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      destruct (eq_dec i (Zlength x)).
      * subst; rewrite !upd_Znth_same by (rewrite ?Zlength_map; auto; omega).
        Exists fails.
        destruct (zlt (Zlength x) (Zlength x + 1)); [|omega].
        rewrite app_Znth2, Zminus_diag, Znth_0_cons by omega.
        entailer!.
        unfold make_loads; rewrite map_app; eapply add_events_trans; eauto.
      * rewrite !upd_Znth_diff' by (rewrite ?Zlength_map; auto; omega).
        erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).
        Intros fails'; Exists fails'; entailer!.
        destruct (zlt i (Zlength x)), (zlt i (Zlength x + 1)); try omega; auto.
        rewrite app_Znth1; auto.
    + Intros vals hists'' v' lv'.
      unfold atomic_loc_hist at 1; Intros.
      forward_call (AL_witness sh version gv 0 (ver_R gv2 gsh gv' lg) hv1 (ghost_snap v' gv2)
        (fun v => !!(v' <= v) && ghost_snap v gv2)).
      { split; auto.
        apply AL_hist_spec; auto; repeat intro.
        unfold ver_R in *.
        rewrite sepcon_comm, <- !sepcon_assoc.
        assert_PROP (v' <= v2).
        { rewrite snap_master_join'; go_lowerx; entailer!. }
        rewrite 2flatten_sepcon_in_SEP.
        eapply snap_master_update' with (v'0 := v2); [omega|].
        eapply semax_pre; [|eauto].
        go_lowerx; entailer!. }
      Intros v2; simpl; Intros hv2.
      rewrite app_nil_r.
      rewrite Z.testbit_false, Zdiv_1_r in * by omega.
      match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
        forward_if (PROP (v2 <> v) (LOCALx Q (SEPx R))) end.
      * forward.
        Exists failvs loops v hv2 vals hists''; unfold atomic_loc_hist at 2; entailer!.
        { unfold make_loads; rewrite map_app; eapply add_events_trans; eauto.
          eapply add_events_trans with (le := [_]); eauto. }
        apply sepcon_derives; [auto|].
        apply sepcon_list_derives; rewrite !Zlength_map, Zlength_combine, Z.min_l; try omega.
        intros; erewrite Znth_map with (d' := (0, Vundef)), Znth_map, Znth_combine
          by (rewrite ?Zlength_combine, ?Z.min_l; omega).
        replace (Znth i lv' 0) with v; auto.
        match goal with H : Forall _ lv' |- _ => apply Forall_Znth with (i0 := i)(d := 0) in H end; auto.
        match goal with H : Forall _ (sublist _ _ lv') |- _ =>
          rewrite sublist_same in H by (auto; omega); apply Forall_Znth with (i0 := i)(d := 0) in H end; auto.
        unfold round_down, round_up in *.
        exploit (Z_mod_lt v' 2); [computable|].
        destruct (eq_dec v' v); subst; omega.
      * forward.
        entailer!.
      * intros; unfold overridePost.
        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
        unfold POSTCONDITION, abbreviate, loop1_ret_assert.
        Intros; Exists (failvs ++ [v; v2]) (loops + 1) hv2 hists'' v2; unfold atomic_loc_hist at 2; entailer!.
        { rewrite Forall_app, Zlength_app, !Zlength_cons, Zlength_nil; repeat (constructor; auto); [|omega].
          unfold make_loads; rewrite map_app; eapply add_events_trans; eauto.
          eapply add_events_trans with (le := [_]); eauto. }
        Exists lv'; entailer!.
        apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
        erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
        Intros fails; Exists (fails ++ [Znth i vals 0]); entailer!.
        destruct (zlt i 8); [|rewrite Zlength_upto in *; simpl in *; omega].
        rewrite Zlength_app, Zlength_cons, Zlength_nil; split; auto.
Qed.

Lemma ver_R_precise : forall g gsh gv lg v, precise (EX h : _, ver_R g gsh gv lg h v).
Proof.
  intros; unfold ver_R.
  rewrite exp_trivial by (exact []).
  unfold ghost_snap, ghost_master; repeat apply precise_sepcon; auto.
  { apply ghost_precise. }
  apply precise_fold_right.
  rewrite Forall_map, Forall_forall; simpl; intros.
  apply ghost_precise.
Qed.
Hint Resolve ver_R_precise.

Lemma loc_R_precise : forall g gsh gl gv v, precise (EX h : _, loc_R g gsh gl gv h v).
Proof.
  intros; unfold loc_R.
  rewrite exp_trivial by (exact []).
  unfold ghost_master, ghost_snap.
  apply derives_precise' with (Q := (EX sm : (option Z * option Z), ghost sm g) *
    (EX v : Z, ghost_var gsh v gl) * (EX sm : (option Z * option Z), ghost sm gv));
    [|repeat apply precise_sepcon; try apply ex_ghost_precise; apply ghost_var_precise].
  Intros ver ver'; Exists (@None Z, Some ver) (Some ver', @None Z) ver; auto.
Qed.
Hint Resolve loc_R_precise.

Lemma body_write : semax_body Vprog Gprog f_write write_spec.
Proof.
  start_function.
  unfold atomic_loc_hist at 1; Intros.
  rewrite atomic_loc_isptr; Intros.
  forward.
  assert (sh <> Share.bot) by (intro; subst; contradiction unreadable_bot).
  
  forward_call (AL_witness sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv
    (ghost_var gsh1 v gv') (fun v' => !!(v' = v) && ghost_var gsh1 v gv')).
  { split; auto.
    apply AL_hist_spec; auto; repeat intro.
    unfold ver_R in *.
    rewrite !flatten_sepcon_in_SEP.
    gather_SEP 3 1.
    assert_PROP (v = v0).
    { go_lowerx; apply sepcon_derives_prop, ghost_var_inj; auto. }
    eapply semax_pre; [|eauto].
    go_lowerx; entailer!. }
  Intros v'; simpl; Intros hv1; subst.
  assert (repable_signed (v + 1)) by admit. 
  assert ((v + 1) mod 2 = 1) as Hdirty.
  { rewrite Zplus_mod; replace (v mod 2) with 0.
    rewrite !Zmod_small by (try apply Z_mod_lt; computable); auto. }
  forward_call (AS_witness sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv1 (v + 1)
    (ghost_snap v gv2 * ghost_var gsh1 v gv') (ghost_snap (v + 1) gv2 * ghost_var gsh1 (v + 1) gv')).
  { split; [|split; auto].
    apply AS_hist_spec; auto.
    repeat intro.
    unfold ver_R in *.
    rewrite <- !sepcon_assoc, !flatten_sepcon_in_SEP.
    gather_SEP 4 1.
    assert_PROP (v = v').
    { go_lowerx; apply sepcon_derives_prop, ghost_var_inj; auto. }
    subst v'; erewrite ghost_var_share_join by eauto.
    apply ghost_var_update with (v' := v + 1).
    erewrite <- (ghost_var_share_join _ _ _ _ _ SH2).
    gather_SEP 3 1.
    apply snap_master_update' with (v' := v + 1); [omega|].
    eapply semax_pre; [|eauto].
    unfold round_down.
    replace (v mod 2) with 0; rewrite Hdirty, Z.sub_0_r, Z.add_simpl_r.
    go_lowerx; entailer!. }
  Intros hv2.
  exploit (add_events_trans hv); eauto; intro.
  assert_PROP (Zlength vals = 8).
  { entailer!.
    rewrite Zlength_map in *; auto. }
  rewrite <- seq_assoc.
  forward_for_simple_bound 8 (EX i : Z, EX hists' : list hist, PROP (Zlength hists' = i)
    LOCAL (temp _v (vint v); temp _ver version; temp _n n; temp _in input)
    SEP (atomic_loc_hist sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv2;
         ghost_snap (v + 1) gv2; ghost_var gsh1 (v + 1) gv'; @data_at CompSpecs sh tnode (version, locs) n;
         data_at Tsh (tarray tint 8) (map (fun x : Z => vint x) vals) input;
         fold_right sepcon emp (map (fun j =>
           !!(j < i -> add_events (Znth j hists []) [Store (vint (Znth j vals 0))] (Znth j hists' [])) &&
           atomic_loc_hist sh (Znth j locs Vundef) (Znth j ghosts Vundef) 0
             (loc_R (Znth j lg Vundef) gsh2 (Znth j lgl Vundef) gv2)
             (if zlt j i then Znth j hists' [] else Znth j hists [])) (upto 8));
         fold_right sepcon emp (map (ghost_snap (v + 2)) (sublist 0 i lg));
         fold_right sepcon emp (map (ghost_var gsh1 (v + 2)) (sublist 0 i lgl));
         fold_right sepcon emp (map (ghost_snap v) (sublist i 8 lg));
         fold_right sepcon emp (map (ghost_var gsh1 v) (sublist i 8 lgl)))).
  { Exists (@nil hist); rewrite !sublist_nil, !sublist_same by auto; unfold atomic_loc_hist at 2; entailer!.
    apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
    erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
    apply andp_right; [apply prop_right; omega|].
    destruct (zlt i 0); [omega | auto]. }
  - 
    rewrite extract_nth_sepcon with (i := i) by (rewrite Zlength_map; auto).
    erewrite Znth_map, Znth_upto by (auto; simpl; omega); Intros.
    destruct (zlt i i); [omega|].
    rewrite sublist_next with (i0 := i)(d := Vundef) by (auto; omega); simpl.
    rewrite sublist_next with (i0 := i)(d := Vundef) by (auto; omega); simpl.
    unfold atomic_loc_hist at 2; rewrite (atomic_loc_isptr _ (Znth i locs Vundef)); Intros.
    forward.
    forward.
    forward_call (AS_witness sh (Znth i locs Vundef) (Znth i ghosts Vundef) 0
      (loc_R (Znth i lg Vundef) gsh2 (Znth i lgl Vundef) gv2) (Znth i hists []) (Znth i vals 0)
      (ghost_snap (v + 1) gv2 * ghost_snap v (Znth i lg Vundef) * ghost_var gsh1 v (Znth i lgl Vundef))
      (ghost_snap (v + 1) gv2 * ghost_snap (v + 2) (Znth i lg Vundef) * ghost_var gsh1 (v + 2) (Znth i lgl Vundef))).
    { split; [|split; auto; apply Forall_Znth; auto; omega].
      apply AS_hist_spec; auto.
      repeat intro.
      unfold loc_R in *.
      erewrite exp_sepcon1, extract_nth_exists_in_SEP with (n := O); [|simpl; eauto].
      Intro ver; simpl.
      erewrite exp_sepcon1, extract_nth_exists_in_SEP with (n := O); [|simpl; eauto].
      Intro ver'; simpl.
      erewrite !sepcon_andp_prop', extract_prop_in_SEP with (n := O); [|simpl; eauto].
      Intros; simpl.
      rewrite <- !sepcon_assoc, !flatten_sepcon_in_SEP.
      gather_SEP 1 5.
      assert_PROP (ver = v).
      { go_lowerx; apply sepcon_derives_prop, ghost_var_inj; auto. }
      subst; erewrite ghost_var_share_join by eauto.
      apply ghost_var_update with (v'0 := v + 2).
      erewrite <- (ghost_var_share_join _ _ _ _ _ SH2).
      gather_SEP 4 1.
      apply snap_master_update' with (v'0 := v + 2); [omega|].
      gather_SEP 3 2; rewrite snap_snap_max.
      eapply semax_pre; [|eauto].
      go_lowerx.
      Exists (v + 2) (Z.max (v + 1) ver'); entailer!.
      split; [destruct (Z.max_spec (v + 1) ver') as [(? & ->) | (? & ->)]; auto|].
      rewrite round_up_max_distr; apply Zmax_bound_l.
      unfold round_up; replace (v mod 2) with 0; rewrite Hdirty; omega. }
    rewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1 with (d := Vundef), map_app, sepcon_app
      by omega.
    rewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1 with (d := Vundef), map_app, sepcon_app
      by omega.
    Intros h'; Exists (x ++ [h']); rewrite Zlength_app, Zlength_cons, Zlength_nil; entailer!.
    rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto.
    intros.
    erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).
    destruct (eq_dec i (Zlength x)).
    + subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).
      destruct (zlt (Zlength x) (Zlength x + 1)); [|omega].
      rewrite app_Znth2, Zminus_diag, Znth_0_cons by omega.
      apply andp_right; auto.
      apply prop_right; auto.
    + rewrite upd_Znth_diff' by (rewrite ?Zlength_map; auto).
      erewrite Znth_map, Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      Intros.
      destruct (zlt i (Zlength x)), (zlt i (Zlength x + 1)); try omega.
      * rewrite app_Znth1 by auto.
        apply andp_right; auto.
        apply prop_right; auto.
      * apply andp_right; auto.
        apply prop_right; omega.
  - Intros hists'.
    unfold atomic_loc_hist at 1; Intros.
    rewrite !sublist_nil, !sublist_same by auto.
    assert ((v + 2) mod 2 = 0) as Hclean.
    { rewrite Zplus_mod.
      replace (v mod 2) with 0; rewrite Z_mod_same_full, Zmod_0_l; auto. }
    forward_call (AS_witness sh version gv 0 (ver_R gv2 gsh2 gv' lg) hv2 (v + 2)
      (ghost_snap (v + 1) gv2 * ghost_var gsh1 (v + 1) gv' * fold_right sepcon emp (map (ghost_snap (v + 2)) lg))
      (ghost_snap (v + 2) gv2 * ghost_var gsh1 (v + 2) gv' * fold_right sepcon emp (map (ghost_snap (v + 2)) lg))).
    { split; [|split; auto].
      apply AS_hist_spec; auto.
      repeat intro.
      unfold ver_R in *.
      rewrite <- !sepcon_assoc, !flatten_sepcon_in_SEP.
      gather_SEP 4 1.
      assert_PROP (v + 1 = v').
      { go_lowerx; apply sepcon_derives_prop, ghost_var_inj; auto. }
      subst v'; erewrite ghost_var_share_join by eauto.
      apply ghost_var_update with (v' := v + 2).
      erewrite <- (ghost_var_share_join _ _ _ _ _ SH2).
      gather_SEP 3 1.
      apply snap_master_update' with (v' := v + 2); [omega|].
      gather_SEP 3 2.
      apply snaps_snaps_max; rewrite Z.max_l by (unfold round_down; omega).
      eapply semax_pre; [|eauto].
      unfold round_down; rewrite Hclean, Z.sub_0_r.
      go_lowerx; entailer!.
      { admit.  } }
    Intros hv3.
    forward.
    Exists hv3 hists'; unfold atomic_loc_hist at 2; entailer!.
    + eapply add_events_trans with (le := [_; _]); eauto.
    + apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      Intros; destruct (zlt i 8); [|rewrite Zlength_upto in *; simpl in *; omega].
      apply andp_right; auto.
      apply prop_right; auto.
Admitted.

