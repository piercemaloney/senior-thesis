
Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Require Export FCF.GroupTheory.
(* FCF.GroupTheory:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import FCF.StdNat.

Class Group_op(A : Set) := groupOp : A -> A -> A.
Infix "*" := groupOp : group_scope.
Delimit Scope group_scope with group.
Local Open Scope group_scope.

Class Group
      (GroupElement : Set)
      (groupOp : Group_op GroupElement)
      (ident : GroupElement)
      (inverse : GroupElement -> GroupElement) 
  :={
      
      associativity : 
        forall (x y z : GroupElement),
          (x * y) * z = x * (y * z);
      
      left_identity : 
        forall (a : GroupElement),
          ident * a = a;
      
      right_identity : 
        forall (a : GroupElement),
          a * ident = a;
      
      left_inverse : 
        forall (a : GroupElement),
          (inverse a) * a = ident;
                                                   
      right_inverse : 
        forall (a : GroupElement),
          a * (inverse a) = ident
                                                                                               
    }.

Fixpoint groupExp`{G : Group}(a : GroupElement)(n : nat) : GroupElement :=
  match n with
    | 0 => ident
      | S n' => groupOp a (groupExp a n')
  end.

Infix "^" := groupExp : group_scope.

Section GroupProperties.

  Context `{G : Group}.

  Lemma groupExp_identity : forall n,
    ident^n = ident.

  Theorem groupExp_plus : forall n1 n2 x,
    x^(n1 + n2) = (x^n1) * (x^n2).

  Theorem groupExp_mult : forall n2 n1 x, 
    ((x^n1)^n2) = (x^(n1 * n2)).

End GroupProperties.

Class FiniteCyclicGroup `{G: Group}
      (g : GroupElement)(order : posnat)(groupLog : GroupElement -> GroupElement -> nat) := {
                                                                             
  generator : GroupElement -> Prop;
  g_generator : generator g;
  group_cyclic: forall (g a : GroupElement),
    generator g ->
    g^(groupLog g a) = a;
  groupLog_correct: forall g x,
    generator g ->
    modNat (groupLog g (g^x)) order = modNat x order;
  groupIdent : forall g,
    generator g -> 
    g^0 = ident;
  groupOrder : forall g,
    generator g ->
    g^order = g^0
    
}.

Section FiniteCyclicGroupProperties.

  Context`{FCG : FiniteCyclicGroup}.

  Lemma groupExp_eq_h : forall g c1 v,
    generator g -> 
    v < order ->
    g^(c1 * order + v) = g^v.

  Theorem groupExp_eq_if : forall g x y,
    generator g ->
    modNat x order = modNat y order ->
    g^x = g^y.

   Theorem commutativity : forall x y,
    x * y = y * x.

  Theorem groupExp_distrib : forall n x y,
    (x * y)^n = x^n * y^n.

  Theorem groupExp_eq : forall g x y,
    generator g ->
    g^x = g^y ->
    modNat x order = modNat y order.

  Theorem ident_l_unique : forall x y,
    x * y = y -> 
    x = ident.

  Theorem groupExp_mod : forall g n, 
    generator g ->
    g^n = g^(modNat n order).

End FiniteCyclicGroupProperties. *)

Local Open Scope group_scope.

Definition RndGrpElem`{FCG : FiniteCyclicGroup}{eqd : EqDec GroupElement} :=
    n <-$ [0 .. order);
    ret (g^n).

Section RndGrpElem.

  Context`{FCG : FiniteCyclicGroup}.
  Hypothesis GroupElement_EqDec : EqDec GroupElement. 

  Theorem RndGrpElem_wf : well_formed_comp RndGrpElem.

    unfold RndGrpElem.
    wftac.

  Qed.

  Theorem groupExp_closed : forall k,
    In (g^k) (getSupport RndGrpElem).

    intuition.
    erewrite groupExp_mod.
    simpl.
    eapply in_getUnique.
    eapply in_flatten.
    econstructor.
    split.
    eapply in_map_iff.
    econstructor.
    split.
    eauto.
    eapply filter_In.
    split.
    eapply in_getUnique.
    eapply in_flatten.
    econstructor.
    split.
    eapply in_map_iff.
    econstructor.
    split.
    eapply eq_refl.
    eapply in_getAllBvectors.
    simpl.
    left.
    eapply eq_refl.
    2:{
      rewrite bvToNat_natToBv_inverse.
      simpl.
      left.
      eapply eq_refl.
      eapply lognat_monotonic.
      eapply modNat_lt.
    }
    rewrite bvToNat_natToBv_inverse.
    unfold ltNatBool.
    destruct (lt_dec (modNat k order) order); trivial.
    exfalso.
    eapply n.
    eapply modNat_lt.
    eapply lognat_monotonic.
    eapply modNat_lt.

    apply g_generator.
  Qed.

  Theorem RndGrpElem_uniform : forall x y,
    evalDist RndGrpElem x == evalDist RndGrpElem y.

    intuition.
    unfold RndGrpElem.

    eapply (evalDist_iso 
              (fun z => (modNat (z + (modNatAddInverse (groupLog g y) order) + (groupLog g x))) order) 
              (fun z => (modNat (z + (groupLog g y) + (modNatAddInverse (groupLog g x) order)) order))); intuition.

    rewrite <- plus_assoc.
    rewrite <- modNat_plus.
    assert ((x0 + groupLog g y + modNatAddInverse (groupLog g x) order +
      (modNatAddInverse (groupLog g y) order + groupLog g x)) = 
    ((groupLog g y + modNatAddInverse (groupLog g y) order) + 
      (groupLog g x + modNatAddInverse (groupLog g x) order +
      x0)))%nat.
    omega.
    rewrite H0.
    rewrite modNat_plus.
    rewrite modNatAddInverse_correct.
    rewrite plus_0_l.
    rewrite modNat_plus.
    rewrite modNatAddInverse_correct.
    rewrite plus_0_l.
    eapply modNat_eq.
    eapply RndNat_support_lt.
    trivial.

    rewrite <- plus_assoc.
    rewrite <- modNat_plus.
    assert ((x0 + modNatAddInverse (groupLog g y) order + groupLog g x +
      (groupLog g y + modNatAddInverse (groupLog g x) order)) = 
    (groupLog g x + modNatAddInverse (groupLog g x) order + 
      (groupLog g y + modNatAddInverse (groupLog g y) order + x0)))%nat.
    omega.
    rewrite H0.
    rewrite modNat_plus.
    rewrite modNatAddInverse_correct.
    rewrite plus_0_l.
    rewrite modNat_plus.
    rewrite modNatAddInverse_correct.
    rewrite plus_0_l.
    eapply modNat_eq.
    eapply RndNat_support_lt.
    trivial.

    eapply in_getSupport_RndNat.
    eapply modNat_lt.

    eapply RndNat_uniform.
    eapply modNat_lt.

    eapply RndNat_support_lt.
    trivial.

    subst.
    rewrite <- groupExp_mod.
    simpl.
    destruct (EqDec_dec GroupElement_EqDec (groupExp g x0) y); subst.
    rewrite groupExp_mod.
    rewrite modNat_plus.
    rewrite modNatAddInverse_correct_gen.
    rewrite plus_0_l.
    rewrite <- groupExp_mod.
    rewrite group_cyclic.
    destruct (EqDec_dec GroupElement_EqDec x x).
    intuition.
    congruence.
    apply g_generator.
    apply g_generator.

    symmetry.
    eapply groupLog_correct.
    apply g_generator.
    apply g_generator.

    destruct (EqDec_dec GroupElement_EqDec
         (groupExp g (x0 + modNatAddInverse (groupLog g y) order + groupLog g x)) x); intuition.
    exfalso.
    eapply n.
    rewrite groupExp_plus in e.
    rewrite group_cyclic in e.
    eapply ident_l_unique in e.
    rewrite <- (@groupIdent _ _ _ _ _ _ _ _ FCG g) in e.
    eapply groupExp_eq in e.
    rewrite (@modNat_eq order 0) in e.
    eapply modNatAddInverse_sum_0 in e.
    rewrite groupExp_mod.
    rewrite e.
    rewrite <- groupExp_mod.
    rewrite group_cyclic.
    trivial.
    apply g_generator.
    apply g_generator.
    apply g_generator.

    eapply posnat_pos.

    apply g_generator.
    apply g_generator.
    apply g_generator.
    apply g_generator.
  Qed. 

  Theorem RndGrpElem_spec : 
    forall x y,
      comp_spec (fun a b => a = x <-> b = y) RndGrpElem RndGrpElem.

    intuition.
    eapply eq_impl_comp_spec; eauto using RndGrpElem_wf.
    eapply RndGrpElem_uniform.

  Qed.

End RndGrpElem.

Notation "'RndG'" := (RndGrpElem)
  (right associativity, at level 75) : comp_scope.