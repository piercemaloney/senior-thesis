Add LoadPath "../..".

Require Import Arith.

Require Import List.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import msl.eq_dec.
(* msl.eq_dec:
Require Import VST.msl.base.

Class EqDec (A : Type) : Type :=
  eq_dec : forall a a' : A, {a = a'} + {a <> a'}.

Instance EqDec_nat : EqDec nat := eq_nat_dec.

Definition upd {A} `{EqDec A} (B : Type) (f : A -> B) (a : A) (b : B) : A -> B :=
  fun a' => if eq_dec a a' then b else f a'.
Arguments upd [A H B] _ _ _ _.

Lemma upd_eq {A} `{EqDec A} : forall B (f : A -> B) a b,
  upd f a b a = b.
Arguments upd_eq [A H B] _ _ _.

Lemma upd_eq' {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a = a' ->
  upd f a b a' = b.
Arguments upd_eq' [A H B] _ _ _ _ _.

Lemma upd_neq {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a <> a' ->
  upd f a b a' = f a'. *)

Import Relations.



Definition table (A B : Type) := list (A*B).



Fixpoint table_get {A B}{H: EqDec A} (rho: table A B) (x: A) : option B :=

  match rho with

  | (y,v)::ys => if eq_dec x y then Some v else table_get ys x

  | nil => None

 end.



Definition table_set {A B}{H: EqDec A} (x: A) (v: B) (rho: table A B)  : table A B := (x,v)::rho.



Lemma table_gss {A B}{H: EqDec A}: forall rho x (v: B), table_get (table_set x v rho) x = Some v.

Proof.

intros.

simpl. destruct (eq_dec x x); auto. contradiction n; auto.

Qed.



Lemma table_gso {A B}{H: EqDec A}: forall rho x y (v:B), x<>y -> table_get (table_set x v rho) y = table_get rho y.

Proof.

intros.

simpl. destruct (eq_dec y x); auto.  contradiction H0; auto.

Qed.



Definition var := nat.

Definition adr := nat.

Definition stack := table var adr.

Definition heap := table adr adr.

Definition state := (stack * heap)%type.



Inductive command :=

| Skip : command

| Assign: var -> var -> command

| Load : var -> var -> command

| Store: var -> var -> command

| Seq: command -> command -> command.



Inductive step: relation (command * state) :=

| stepAssign:

        forall x y v stk hp,

        table_get stk y = Some v ->

        step (Assign x y, (stk,hp)) (Skip, (table_set x v stk, hp))

| stepLoad:

        forall x y v v' stk hp,

         table_get stk y = Some v ->

         table_get hp v = Some v' ->

         step (Load x y, (stk,hp)) (Skip, (table_set x v' stk, hp))

| stepStore:

         forall x y v p stk hp,

          table_get stk y = Some v ->

          table_get stk x = Some p ->

          step (Store x y, (stk,hp)) (Skip, (stk, table_set p v hp))

| stepSeq0:

         forall c2 s,

         step (Seq Skip c2, s) (c2, s)

| stepSeq1:

         forall c1 c1' c2 s s',

         step (c1,s) (c1',s') ->

         step (Seq c1 c2, s) (Seq c1' c2, s').



Inductive step': relation (list command * state)  :=

| step'Skip:

         forall k s,

         step' (Skip :: k, s) (k,s)

| step'Assign:

        forall x y v stk hp k,

        table_get stk y = Some v ->

        step' (Assign x y :: k, (stk,hp)) (k, (table_set x v stk, hp))

| step'Load:

        forall x y v v' stk hp k,

         table_get stk y = Some v ->

         table_get hp v = Some v' ->

         step' (Load x y :: k, (stk,hp)) (k, (table_set x v' stk, hp))

| step'Store:

         forall x y v p stk hp k,

          table_get stk y = Some v ->

          table_get stk x = Some p ->

          step' (Store x y :: k, (stk,hp)) (k, (stk, table_set p v hp))

| step'Seq:

         forall c1 c2 k s cs',

         step' (c1 :: c2 ::k, s) cs' ->

         step' (Seq c1 c2 :: k, s) cs'.



Fixpoint stackit (k: list command) (c: command) : command :=

 match k with

 | nil => c

 | c'::k' => stackit k' (Seq c c')

 end.



Definition stackit' (k: list command) : command :=

 match k with nil => Skip | c::k' => stackit k' c end.



Ltac inv H := inversion H; clear H; subst.



Lemma stackit_step:

  forall s s' k c c',

   step (c,s) (c',s') -> step (stackit k c, s) (stackit k c', s').

Proof.

 induction k; simpl; intros.

 auto.

 apply IHk.

 apply stepSeq1. auto.

Qed.



Lemma step'_equiv:

  forall k s k' s',

  clos_refl_trans _ step' (k,s) (k', s') ->

  clos_refl_trans _ step (stackit' k, s) (stackit' k', s').

Proof.

 intros.

 remember (k,s) as ks.

 remember (k',s') as ks'.

 apply clos_rt1n_rt; apply clos_rt_rt1n in H.

 revert k s Heqks k' s' Heqks'; induction H; intros; subst.

 inv Heqks'.

 apply rt1n_refl.

 destruct y as [k1 s1].

 rename IHclos_refl_trans_1n into IH.

 specialize (IH _ _ (eq_refl _) _ _ (eq_refl _)).

 destruct k; simpl.

 simpl. inv H.

 apply clos_rt_rt1n.

 eapply rt_trans.

 2: apply clos_rt1n_rt; apply IH.

 clear -H.

 revert k k1 H.

 induction c; intros; inv H.

 destruct k1; simpl. apply rt_refl.

 apply rt_step; apply stackit_step; constructor.

 destruct k1; simpl. apply rt_step; econstructor; eauto.

 eapply rt_trans; apply rt_step; apply stackit_step;

    repeat econstructor; eauto.

 destruct k1; simpl. apply rt_step; econstructor; eauto.

 eapply rt_trans; apply rt_step; apply stackit_step;

    repeat econstructor; eauto.

 destruct k1; simpl. apply rt_step; econstructor; eauto.

 eapply rt_trans; apply rt_step; apply stackit_step;

    repeat econstructor; eauto.

 apply IHc1 in H5.

 eapply rt_trans; [ | apply H5].

 replace (stackit k (Seq c1 c2)) with (stackit (c2::k) c1).

 apply rt_refl.

 clear. induction k; simpl; auto.

Qed.



