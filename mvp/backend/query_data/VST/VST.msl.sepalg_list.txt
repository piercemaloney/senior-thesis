Require Import VST.msl.msl_standard.
(* VST.msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Set Implicit Arguments.



Inductive fold_rel (A: Type) (f: A -> A -> A -> Prop):  A -> list A -> A -> Prop :=

| fold_rel_nil: forall w, fold_rel f w nil w

| fold_rel_cons: forall a l w w1 w2,

            f w a w1 ->

            fold_rel f w1 l w2 ->

            fold_rel f w (a::l) w2.



Inductive list_forall2 {A B} (P: A -> B -> Prop): list A -> list B -> Prop :=

  | list_forall2_nil:

      list_forall2 P nil nil

  | list_forall2_cons:

      forall a1 al b1 bl,

      P a1 b1 ->

      list_forall2 P al bl ->

      list_forall2 P (a1 :: al) (b1 :: bl).



Fixpoint replace (A: Type) (l: list A) (n:nat) (new: A) {struct n} : option (list A) :=

  match (l, n) with

    | (nil, n) => None

    | (x :: xs, O) => Some (new :: xs)

    | (x :: xs, S n) =>

      match (replace xs n new) with

        |  None => None

        |  Some xs => Some (x :: xs)

      end

  end.



Definition list_join {A} {JA: Join A}: A -> list A -> A -> Prop :=

   fold_rel join.



Lemma list_join_assoc1 {A} {JA: Join A}{PA: Perm_alg A}:

 forall {a b cl d e},

   join a b d -> list_join d cl e ->

  exists f, list_join b cl f /\ join a f e.

Proof.

intros.

revert a b H.

induction H0; intros.

exists b. split; auto. constructor.

destruct (join_assoc H1 H) as [ba [? ?]].

destruct (IHfold_rel _ _ H3) as [f [? ?]]; clear IHfold_rel.

exists f; split; auto.

econstructor; eauto.

Qed.



Lemma list_join_assoc2 {A}  {JA: Join A}{PA: Perm_alg A}:

  forall {a b: A} {cl e f},

   list_join b cl f -> join a f e ->

   exists d,  join a b d /\ list_join d cl e.

Proof.

do 3 intro; revert a b; induction cl; intros; inv H.

exists e; split; auto; constructor.

destruct (IHcl _ _ _ _ H6 H0) as [d [? ?]].

destruct (join_assoc (join_comm H4) (join_comm H)) as [g [? ?]].

exists g; split; auto.

constructor 2 with d; auto.

Qed.



Lemma list_join_app {A} {JA: Join A}:

  forall {a: A} {bl c dl e},

   list_join a bl c -> list_join c dl e -> list_join a (bl++dl) e.

Proof.

intros a bl; revert a; induction bl; intros.

inv H.

simpl.

auto.

inv H.

rewrite <- app_comm_cons.

econstructor 2.

apply H4.

eapply IHbl.

apply H6.

auto.

Qed.



Lemma list_join_unapp {A}  {JA: Join A}:

  forall {a:A}  {bl dl e},

  list_join a (bl++dl) e -> exists c, list_join a bl c /\ list_join c dl e.

Proof.

intros a bl; revert a; induction bl; intros.

simpl in H. exists a; split; auto. constructor.

rewrite <- app_comm_cons in H.

inv H.

destruct (IHbl _ _ _ H5) as [c [? ?]]. clear IHbl.

exists c.

split; auto.

econstructor 2; eauto.

Qed.



Lemma list_join_1 {A} {JA: Join A}:

  forall a b c: A, join a b c = list_join a (b::nil) c.

Proof.

intros; apply prop_ext; split; intros.

econstructor 2; eauto.

constructor.

inv H.

inv H5.

auto.

Qed.



Definition age1_list {A} `{ageable A} := list_forall2 age.



Lemma age1_list_join {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall l (phi phi' phi2: A),

        age phi phi' ->

        list_join phi l phi2 ->

        exists l', exists phi2', age1_list l l' /\ age phi2 phi2' /\ list_join phi' l' phi2'.

Proof.

induction l; intros; inv H0.

exists (@nil A).

exists phi'.

repeat split; auto; constructor.

rename w1 into phi1.

destruct (age1_join _ H4 H) as [a' [phi1' [? [? ?]]]].

specialize ( IHl phi1 phi1' phi2 H2 H6).

destruct IHl as [l' [phi2' [? [? ?]]]].

exists (a' :: l').

exists phi2'.

repeat split; auto; econstructor 2; eauto.

Qed.



Lemma age1_list_join2 {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall (l: list A) phi phi2 phi2',  age1 phi2 = Some phi2' -> list_join phi l phi2 ->

        exists l', exists phi',  age1 phi = Some phi' /\ age1_list l l' /\ list_join phi' l' phi2'.

Proof.

induction l; intros; inv H0.

exists (@nil A).

exists phi2'.

repeat split; auto; constructor.

rename w1 into phi1.

destruct (IHl phi1 phi2 phi2' H H6) as [l' [phi1' [? [? ?]]]].

destruct (age1_join2 _ H4 H0) as [phi' [a' [? [? ?]]]].

exists (a'::l'). exists phi'.

repeat split; auto; econstructor 2; eauto.

Qed.



Lemma list_join_split_nth {A}{JA: Join A}{PA: Perm_alg A}:

 forall n (l: list A) phin phi phia phib phi2,

  nth_error l n = Some phin -> list_join phi l phi2 -> join phib phia phin ->

           exists phic, exists l',

                 replace l n phib = Some l' /\ join phi phia phic /\ list_join phic l' phi2.

Proof.

induction n; intros.

inv H.

destruct l.

discriminate.

inv H3.

inv H0.

simpl.

destruct (join_assoc H1 (join_comm H4))

      as [f [? ?]].

exists f; exists (phib::l).

repeat split; auto.

econstructor 2; eauto.

simpl in H.

destruct l.

inv H.

inv H0.

destruct (IHn _ _ _ _ _ _ H H7 H1) as [phic [l' [? [? ?]]]].

simpl. rewrite H0.

destruct (join_assoc (join_comm H5) H2) as [f [? ?]].

exists f; exists (a::l'); repeat split; auto.

econstructor 2; eauto.

Qed.



Lemma list_join_join_nth {A} {JA: Join A}{PA: Perm_alg A}:

 forall n (l: list A) phin phi phia phib phi2,

  nth_error l n = Some phin -> list_join phi l phi2 -> join phi2 phia phib ->

           exists phic, exists l',

                 join phin phia phic /\ replace l n phic = Some l' /\ list_join phi l' phib.

Proof.

induction n; intros.

inv H.

destruct l; try discriminate.

inv H0.

inv H3.

simpl.

destruct (list_join_assoc2 H7 (join_comm H1)) as [f [? ?]].

destruct (join_assoc H5 (join_comm H)) as [g [? ?]].

exists g; exists (g::l); repeat split; auto.

econstructor 2; eauto.

destruct l; simpl in H.

inv H.

inv H0.

simpl.

destruct (IHn _ _ _ _ _ _ H H7 H1) as [phic  [l' [? [? ?]]]].

exists phic. rewrite H2. exists (a::l').

repeat split; auto.

econstructor 2; eauto.

Qed.



Lemma list_join_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall (phi1: A) l phi2, list_join phi1 l phi2 -> comparable phi1 phi2.

Proof.

  intros; revert phi1 phi2 H; induction l; simpl; intros; inv H.

  apply comparable_refl.

  rename w1 into phi0.

  apply comparable_trans with phi0.

  apply join_comparable with a; auto.

  auto.

Qed.



Lemma join_comparable'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi2 phi3.

Proof. intros; apply join_comparable with phi1; apply join_comm; auto. Qed.



Lemma join_comparable2'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi2 phi1.

Proof. intros; apply comparable_sym; eapply join_comparable2; eauto. Qed.



Lemma list_join_comparable'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall (phi1: A) l phi2, list_join phi1 l phi2 -> comparable phi2 phi1.

Proof. intros; apply comparable_sym; eapply list_join_comparable; eauto. Qed.



Lemma join_comparable''  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi3 phi2.

Proof. intros; apply comparable_sym; eapply join_comparable'; eauto. Qed.



Lemma join_comparable'''  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2 phi3: A, join phi1 phi2 phi3 -> comparable phi3 phi1.

Proof. intros; apply comparable_sym; eapply join_comparable; eauto. Qed.



Lemma joins_comparable  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2: A, joins phi1 phi2 -> comparable phi1 phi2.

Proof.

  unfold joins; intros.

  destruct H as [phi3 ?].

  eapply join_comparable2; eauto.

Qed.



Lemma joins_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

     forall phi1 phi2: A, joins phi2 phi1 -> comparable phi1 phi2.

Proof.

unfold joins; intros.

destruct H as [phi3 ?].

apply comparable_sym.

eapply join_comparable2; eauto.

Qed.



Lemma join_sub_comparable  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall phi1 phi2: A, join_sub phi1 phi2 -> comparable phi1 phi2.

Proof.

unfold joins; intros.

destruct H as [phi3 ?].

eapply join_comparable; eauto.

Qed.



Lemma join_sub_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

     forall phi1 phi2: A, join_sub phi2 phi1 -> comparable phi1 phi2.

Proof.

unfold joins; intros.

destruct H as [phi3 ?].

apply comparable_sym.

eapply join_comparable; eauto.

Qed.



Lemma eq_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

   forall phi1 phi2: A, phi1=phi2 -> comparable phi1 phi2.

Proof.

intros; subst; apply comparable_refl.

Qed.



Lemma eq_comparable2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

   forall phi1 phi2: A, phi2=phi1 -> comparable phi1 phi2.

Proof.

intros; subst; apply comparable_refl.

Qed.



Lemma ageN_join {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall n (w1 w2 w3 w1': A),

   join w1 w2 w3 ->

      ageN n w1 = Some w1' ->

      exists w2', exists w3',

        ageN n w2 = Some w2' /\ ageN n w3 = Some w3' /\ join w1' w2' w3'.

Proof.

unfold ageN in *.

induction n; intros; simpl in *.

exists w2; exists w3; repeat split; auto.

inv H0; auto.

case_eq (age1 w1); intros; rewrite H1 in H0; try discriminate.

destruct (age1_join _ H H1) as [w2' [w3' [? [? ?]]]].

destruct (IHn _ _ _ _ H2 H0) as [w2'' [w3'' [? [? ?]]]].

clear IHn.

exists w2''; exists w3''. rewrite H3; rewrite H4.

repeat split; auto.

Qed.



Lemma ageN_join2 {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall n (w1 w2 w3 w3': A),

   join w1 w2 w3 ->

      ageN n w3 = Some w3' ->

      exists w1', exists w2',

        ageN n w1 = Some w1' /\ ageN n w2 = Some w2' /\ join w1' w2' w3'.

Proof.

unfold ageN in *.

induction n; intros; simpl in *.

exists w1; exists w2; repeat split; auto.

inv H0; auto.

case_eq (age1 w3); intros; rewrite H1 in H0; try discriminate.

destruct (age1_join2 _ H H1) as [w1' [w2' [? [? ?]]]].

destruct (IHn _ _ _ _ H2 H0) as [w1'' [w2'' [? [? ?]]]].

clear IHn.

exists w1''; exists w2''. rewrite H3; rewrite H4.

repeat split; auto.

Qed.



Lemma ageN_comparable {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall n (w1 w2 w1' w2': A),

        ageN n w1 = Some w1' -> ageN n w2 = Some w2' -> comparable w1 w2 -> comparable w1' w2'.

Proof.

unfold ageN in *.

induction n; intros; simpl in *.

inv H; inv H0; auto.

revert H H0; case_eq (age1 w1); case_eq (age1 w2); intros; try discriminate.

eapply IHn; eauto.

eapply age_comparable; eauto.

Qed.



Lemma join_unage  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall (phi3 phi1' phi2' phi3': A),

    age1 phi3 = Some phi3' ->

    join phi1' phi2' phi3' ->

    exists phi1, exists phi2, join phi1 phi2 phi3 /\

      age1 phi1 = Some phi1' /\ age1 phi2 = Some phi2'.

Proof.

  intros.

  apply (unage_join2 _ H0 H).

Qed.



Lemma join_unage'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

    forall phi1 phi1' phi2' phi3' : A,

      age1 phi1 = Some phi1' ->

      join phi1' phi2' phi3' ->

      exists phi2, exists phi3, join phi1 phi2 phi3 /\

        age1 phi2 = Some phi2' /\ age1 phi3 = Some phi3'.

Proof.

   intros. apply (unage_join _ H0 H).

Qed.



Lemma unageN'  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall n (phi1 phi1' phi2' phi3' : A),

    ageN n phi1 = Some phi1' ->

    join phi1' phi2' phi3' ->

    exists phi2, exists phi3, join phi1 phi2 phi3 /\

      ageN n phi2 = Some phi2' /\ ageN n phi3 = Some phi3'.

Proof.

induction n; intros.

inv H. exists phi2'; exists phi3'; split; auto.

 unfold ageN in H. simpl in H.

 revert H; case_eq (age1 phi1); intros.

  specialize ( IHn a phi1' phi2' phi3' H1 H0).

  destruct IHn as [phi2 [phi3 [? [? ?]]]].

  destruct (join_unage' _ _ _ H H2) as [phi4 [phi5 [? [? ?]]]].

  exists phi4; exists phi5. split; auto.

 split; unfold ageN; simpl. rewrite H6; auto. rewrite H7; auto.

 inv H1.

Qed.



Hint Resolve @join_comparable @join_comparable'  @join_comparable'' @join_comparable'''

      @join_comparable2 @join_comparable2'  @list_join_comparable @list_join_comparable'

      @joins_comparable  @joins_comparable2  @join_sub_comparable  @join_sub_comparable2

      @eq_comparable  @eq_comparable2

  : comparable.



Hint Immediate @comparable_refl  @comparable_sym  : comparable.



Ltac Comp1 phi1 phi2 :=

   solve [ eauto 3 with comparable typeclass_instances |

  match goal with

  | H: comparable phi1 ?phi |- _ => Comp2 H phi1 phi phi2

  | H: comparable ?phi phi1 |- _ => Comp2 H phi1 phi phi2

  | H: join phi1 ?phia ?phib |- _ =>  Comp3 H phi1 phia phib phi2

  | H: join ?phia phi1 ?phib |- _ =>   Comp3 H phi1 phia phib phi2

  | H: join ?phia ?phib phi1 |- _ =>   Comp3 H phi1 phia phib phi2

  | H: joins phi1 ?phi |- _ =>  Comp2 H phi1 phi phi2

  | H: joins ?phi phi1 |- _ =>  Comp2 H phi1 phi phi2

  | H: join_sub phi1 ?phi |- _ => Comp2 H phi1 phi phi2

  | H: join_sub ?phi phi1 |- _ => Comp2 H phi1 phi phi2

  | H: list_join phi1 _ ?phi |- _ =>  Comp2 H phi1 phi phi2

  | H: list_join ?phi _ phi1 |- _ =>  Comp2 H phi1 phi phi2

  | H: phi1 = ?phi  |- _ => Comp2 H phi1 phi phi2

  | H: ?phi = phi1  |- _ => Comp2 H phi1 phi phi2

 end]

  with Comp2 H phi1 phi phi2 :=

            solve [apply comparable_trans with phi;

                         [eauto 3 with comparable  typeclass_instances |clear H; Comp1 phi phi2]

                   | clear H; Comp1 phi1 phi2]

  with Comp3 H phi1 phia phib phi2 :=

           solve [apply comparable_trans with phia;

                          [eauto 3 with comparable typeclass_instances |clear H; Comp1 phia phi2]

                  |apply comparable_trans with phib;

                          [eauto 3 with comparable  typeclass_instances | clear H; Comp1 phib phi2]

                   | clear H; Comp1 phi1 phi2].



Ltac Comp := match goal with

                | |- comparable ?phi1 ?phi2 => Comp1 phi1 phi2

                | |-  level ?phi1 = level ?phi2 => apply comparable_fashionR; Comp1 phi1 phi2



                end.



Definition not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A} (phi phi': A)  : Prop :=

     exists phi1, necR phi phi1 /\ comparable phi1 phi'.



Lemma comparable_not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A} :

    forall phi phi' : A , comparable phi phi' -> not_any_younger phi phi'.

Proof.

  intros.

  exists phi; split; auto; apply rt_refl.

Qed.



Lemma necR_not_any_younger {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall phi phi' : A, necR phi phi' -> not_any_younger phi phi'.

Proof. intros; exists phi'; split; auto. apply comparable_refl. Qed.



Lemma not_any_younger_refl {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

 forall phi : A, not_any_younger phi phi.

Proof. intros; exists phi; split; auto. apply comparable_refl. Qed.



Lemma not_any_younger_trans {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall phi1 phi2 phi3, not_any_younger phi1 phi2 -> not_any_younger phi2 phi3 ->

            not_any_younger phi1 phi3.

Proof.

intros.

destruct H as [phi1' [? ?]].

destruct H0 as [phi2' [? ?]].

generalize (comparable_common_unit H1); intros [e1 [? ?]].

generalize (nec_join2 H4 H0); intros [a [b [? [? _]]]].

generalize (nec_join H3 H6); intros [u [v [? [? _]]]].

exists u.

split.

econstructor 3; eauto.

Comp.

Qed.



Lemma not_any_younger_None {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:

  forall phi phi', age1 phi = None -> not_any_younger phi phi' -> age1 phi' = None.

Proof.

intros.

destruct H0 as [phi1 [? ?]].

revert phi' H1.

induction H0; intros.

unfold age in H0.

inversion2 H H0.

generalize (comparable_common_unit H1); intros [e1 [? ?]].

case_eq (age1 phi'); [intros w ? | intro]; auto.

elimtype False.

generalize (age1_join2 _ H2 H3); intros [a [b [? [? ?]]]].

generalize (age1_join _ H0 H5); intros [c [d [? [? ?]]]].

unfold age in H8; inversion2 H H8.

assert (x=y).

clear - H0_ H.

induction H0_.

 unfold age in *.

inversion2 H H0.

auto.

rewrite <- IHH0_2; auto.

rewrite <- IHH0_1; auto.

subst y.

auto.

Qed.



Lemma nec_join3 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall {x x' y' z' : A},

       join x' y' z' ->

       necR x x' ->

       exists y,

         exists z,

           join x y z /\ necR y y' /\ necR z z'.

Proof.

intros.

revert y' z' H.

induction H0; intros.

destruct (unage_join _ H0 H) as [y0 [z0 [? [? ?]]]].

exists y0; exists z0; split; auto.

split; constructor 1; auto.

exists y'; exists z'.

split; auto.

rename z into x'.

rename y into x1.

destruct (IHclos_refl_trans2 _ _ H) as [x'' [y'' [? [? ?]]]].

destruct (IHclos_refl_trans1 _ _ H0) as [x0 [y0 [? [? ?]]]].

exists x0; exists y0.

split; auto.

split; econstructor 3; eauto.

Qed.



