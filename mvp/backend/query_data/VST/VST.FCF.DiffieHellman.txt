
Set Implicit Arguments.

Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Require Import FCF.RndNat.
(* FCF.RndNat:
Set Implicit Arguments.

Require Import FCF.Crypto.
Require Import Permutation.
Require Import FCF.NotationV1.
  
Definition RndNat_unchecked(n : nat) :=
  v <-$ {0,1} ^ (lognat n);
  let n := (bvToNat v) in
    ret n.

Definition ltNatBool := fun x1 x2 => if (lt_dec x1 x2) then true else false.

Definition RndNat(n : nat) :=
    (Repeat (RndNat_unchecked n) (fun x => (ltNatBool x n))).

Notation "[ 0 '..' n )" := (RndNat n)
  (right associativity, at level 77) : comp_scope.

Lemma well_formed_RndNat : forall n,
  n > O ->
  well_formed_comp (RndNat n).

Lemma RndNat_support_lt : forall n x,
  In x (getSupport (RndNat n)) ->
  x < n.

Hint Resolve well_formed_RndNat : wftac.

Lemma RndNat_unchecked_lt_support : forall n v,
  v < n ->
  In v (getSupport (RndNat_unchecked n)).

Local Open Scope rat_scope.

Lemma RndNat_uniform : forall v1 v2 n,
  v1 < n ->
  v2 < n -> 
  evalDist (RndNat n) v1 == evalDist (RndNat n) v2.

Lemma in_getSupport_RndNat : forall x k,
  x < k ->
  In x (getSupport (RndNat k)).

Lemma RndNat_support_length : 
  forall n, 
    length (getSupport (RndNat n)) = n.

Theorem RndNat_prob : 
  forall n i (nzn : nz n),
    i < n ->
    evalDist (RndNat n) i == 1 / n.

Theorem RndNat_seq : 
  forall (n : posnat)(A : Set)(c : nat -> Comp A) a,
    evalDist (x <-$ RndNat n; c x) a ==
    (1 / n) * sumList (allNatsLt n) (fun z => evalDist (c z) a).

Lemma rndNat_sumList : 
  forall (A : Set)(f : nat -> Comp A) n (nzn : nz n) x,
    evalDist (i <-$ RndNat n; f i) x == 
    sumList (forNats n) (fun i => (1 / n) * (evalDist (f i) x)). *)
Require Export FCF.GroupTheory.
(* FCF.GroupTheory:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import FCF.StdNat.

Class Group_op(A : Set) := groupOp : A -> A -> A.
Infix "*" := groupOp : group_scope.
Delimit Scope group_scope with group.
Local Open Scope group_scope.

Class Group
      (GroupElement : Set)
      (groupOp : Group_op GroupElement)
      (ident : GroupElement)
      (inverse : GroupElement -> GroupElement) 
  :={
      
      associativity : 
        forall (x y z : GroupElement),
          (x * y) * z = x * (y * z);
      
      left_identity : 
        forall (a : GroupElement),
          ident * a = a;
      
      right_identity : 
        forall (a : GroupElement),
          a * ident = a;
      
      left_inverse : 
        forall (a : GroupElement),
          (inverse a) * a = ident;
                                                   
      right_inverse : 
        forall (a : GroupElement),
          a * (inverse a) = ident
                                                                                               
    }.

Fixpoint groupExp`{G : Group}(a : GroupElement)(n : nat) : GroupElement :=
  match n with
    | 0 => ident
      | S n' => groupOp a (groupExp a n')
  end.

Infix "^" := groupExp : group_scope.

Section GroupProperties.

  Context `{G : Group}.

  Lemma groupExp_identity : forall n,
    ident^n = ident.

  Theorem groupExp_plus : forall n1 n2 x,
    x^(n1 + n2) = (x^n1) * (x^n2).

  Theorem groupExp_mult : forall n2 n1 x, 
    ((x^n1)^n2) = (x^(n1 * n2)).

End GroupProperties.

Class FiniteCyclicGroup `{G: Group}
      (g : GroupElement)(order : posnat)(groupLog : GroupElement -> GroupElement -> nat) := {
                                                                             
  generator : GroupElement -> Prop;
  g_generator : generator g;
  group_cyclic: forall (g a : GroupElement),
    generator g ->
    g^(groupLog g a) = a;
  groupLog_correct: forall g x,
    generator g ->
    modNat (groupLog g (g^x)) order = modNat x order;
  groupIdent : forall g,
    generator g -> 
    g^0 = ident;
  groupOrder : forall g,
    generator g ->
    g^order = g^0
    
}.

Section FiniteCyclicGroupProperties.

  Context`{FCG : FiniteCyclicGroup}.

  Lemma groupExp_eq_h : forall g c1 v,
    generator g -> 
    v < order ->
    g^(c1 * order + v) = g^v.

  Theorem groupExp_eq_if : forall g x y,
    generator g ->
    modNat x order = modNat y order ->
    g^x = g^y.

   Theorem commutativity : forall x y,
    x * y = y * x.

  Theorem groupExp_distrib : forall n x y,
    (x * y)^n = x^n * y^n.

  Theorem groupExp_eq : forall g x y,
    generator g ->
    g^x = g^y ->
    modNat x order = modNat y order.

  Theorem ident_l_unique : forall x y,
    x * y = y -> 
    x = ident.

  Theorem groupExp_mod : forall g n, 
    generator g ->
    g^n = g^(modNat n order).

End FiniteCyclicGroupProperties. *)

Local Open Scope group_scope.

Section DDH.

  Section DDH_Concrete.

    Context`{FCG : FiniteCyclicGroup}.
    Variable A : (GroupElement * GroupElement * GroupElement) -> Comp bool. 

    Definition DDH0 :=
      x <-$ [0 .. order);
      y <-$ [0 .. order);
      b <-$ (A (g^x, g^y, g^(x * y)));
      ret b.
    
    Definition DDH1  :=
      x <-$ [0 .. order);
      y <-$ [0 .. order);
      z <-$ [0 .. order);
      b <-$ (A (g^x, g^y, g^z));
      ret b.

    Definition DDH_Advantage:= | Pr[DDH0] - Pr[DDH1] |.

  End DDH_Concrete. 
  
End DDH.
