Require Import List. Import ListNotations.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import ZArith.

Local Open Scope Z_scope.

Require Import Integers.

Require Import floyd.sublist.
(* floyd.sublist:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Require Import Coq.Lists.List.
Import ListNotations.

Class Inhabitant (A: Type) := default : A.

Instance Inhabitant_Z : Inhabitant Z := 0.
Instance Inhabitant_nat : Inhabitant nat := O.
Instance Inhabitant_positive : Inhabitant positive := 1%positive.
Instance Inhabitant_list {T: Type} : Inhabitant (list T) := @nil T.
Instance Inhabitant_fun {T1 T2: Type} {H: Inhabitant T2} : Inhabitant (T1->T2) := fun _ => H.
Instance Inhabitant_Prop : Inhabitant Prop := False.
Instance Inhabitant_bool : Inhabitant bool := false.
Instance Inhabitant_pair {T1 T2 : Type} {x1: Inhabitant T1} {x2: Inhabitant T2} : Inhabitant (T1*T2)%type := (x1,x2).

Lemma Zlength_length:
  forall A (al: list A) (n: Z),
    0 <= n ->
    (Zlength al = n <-> length al = Z.to_nat n).

Lemma firstn_app1: forall {A} n (p l: list A),
  (n <= Datatypes.length p)%nat ->

Lemma firstn_app2: forall {A} (n: nat) (al bl: list A),
 (n >= length al)%nat ->
 firstn n (al++bl) = al ++ firstn (n - length al) bl.

Lemma firstn_list_repeat {A} (v:A): forall i k, (i<=k)%nat ->
      firstn i (list_repeat k v) = list_repeat i v.

Lemma firstn_app:
 forall {A} n m (al: list A), firstn n al ++ firstn m (skipn n al) =
  firstn (n+m) al.

Lemma nth_skipn:
  forall {A} i n data (d:A),
       nth i (skipn n data) d = nth (i+n) data d.

Lemma skipn_skipn: forall {A} n m (xs: list A),
  skipn n (skipn m xs) = skipn (m + n) xs.

Lemma firstn_exact_length: forall {A} (xs: list A), firstn (length xs) xs = xs.

Lemma skipn_exact_length: forall {A} (xs: list A), skipn (length xs) xs = nil.

Lemma len_le_1_rev: forall {A} (contents: list A),
  (length contents <= 1)%nat ->
  contents = rev contents.

Lemma firstn_firstn: forall {A} (contents: list A) n m,
  (n <= m)%nat ->
  firstn n (firstn m contents) = firstn n contents.

Lemma firstn_1_skipn: forall {A} n (ct: list A) d,
  (n < length ct)%nat ->
  nth n ct d :: nil = firstn 1 (skipn n ct).

Lemma skipn_length: forall {A} (contents: list A) n,
  length (skipn n contents) = (length contents - n)%nat.

Lemma nth_firstn: forall {A} (contents: list A) n m d,
  (n < m)%nat ->
  nth n (firstn m contents) d = nth n contents d.

Lemma skipn_length_short:
  forall {A} n (al: list A),
    (length al <= n)%nat ->
    (length (skipn n al) = 0)%nat.

Lemma skipn_short:
   forall {A} n (al: list A), (n >= length al)%nat -> skipn n al = nil.

Lemma nth_map':
  forall {A B} (f: A -> B) d d' i al,
  (i < length al)%nat ->
   nth i (map f al) d = f (nth i al d').

Lemma skipn_nil: forall A n, skipn n (@nil A) = nil.

Lemma skipn_drop:
 forall A n m (al: list A), skipn n (skipn m al) = skipn (n+m) al.

Lemma skipn_app1:
 forall A n (al bl: list A),
  (n <= length al)%nat ->
  skipn n (al++bl) = skipn n al ++ bl.

Lemma skipn_app2:
 forall A n (al bl: list A),
  (n >= length al)%nat ->
  skipn n (al++bl) = skipn (n-length al) bl.

Lemma list_repeat_app: forall A a b (x:A),
  list_repeat a x ++ list_repeat b x = list_repeat (a+b) x.

Lemma firstn_same:
  forall A n (b: list A), (n >= length b)%nat -> firstn n b = b.

Lemma nth_firstn_low:
 forall A i n al (d: A),
  (i < n <= length al)%nat -> nth i (firstn n al) d = nth i al d.

Lemma nth_error_nth:
  forall A (d: A) i al, (i < length al)%nat -> nth_error al i = Some (nth i al d).

Lemma skipn_rev:
  forall {A} n (vl: list A),
   skipn n (rev vl) = rev (firstn (length vl - n) vl).

Lemma Forall_list_repeat:
  forall {A} (P: A -> Prop) (n: nat) (a: A),
    P a -> Forall P (list_repeat n a).

Lemma skipn_firstn: forall {A} n m (xs: list A),
  skipn n (firstn m xs) = firstn (m-n) (skipn n xs).

Lemma rev_skipn:
 forall {A} n (vl: list A),
  rev (skipn n vl) = firstn (length vl -n) (rev vl).

Lemma firstn_skipn_rev:
  forall {A} lo n (vl: list A),
  (n+lo <= length vl)%nat ->
  firstn n (skipn lo (rev vl)) =
  rev (firstn n (skipn (length vl - (lo+n))%nat vl)).

Lemma map_firstn:
  forall A B (F: A -> B) n (al: list A),
  map F (firstn n al) = firstn n (map F al).

Lemma map_skipn:
  forall A B (F: A -> B) n (al: list A),
  map F (skipn n al) = skipn n (map F al).

Lemma Zlength_app: forall T (al bl: list T),
    Zlength (al++bl) = Zlength al + Zlength bl.

Lemma Zlength_rev: forall T (vl: list T), Zlength (rev vl) = Zlength vl.

Lemma Zlength_map: forall A B (f: A -> B) l, Zlength (map f l) = Zlength l.

Lemma ZtoNat_Zlength:
 forall {A} (l: list A), Z.to_nat (Zlength l) = length l.
Hint Rewrite @ZtoNat_Zlength : norm.

Lemma Zlength_nonneg:
 forall {A} (l: list A), 0 <= Zlength l.

Definition Zlength' := @Zlength.

Ltac pose_Zlength_nonneg1 T A :=
     lazymatch goal with
      | H:  0 <= @Zlength T A |- _ => idtac
      | H:  0 <= @Zlength T A /\ _ |- _ => idtac
      | |- _ => pose proof (@Zlength_nonneg T A)
     end;
     
     let x := fresh "x" in set (x:= @Zlength T A) in *;
     let y := fresh "y" in set (y := @Zlength) in x;
     fold @Zlength' in y; subst y; subst x.

Ltac pose_Zlength_nonneg :=
 repeat
  match goal with
  | |- context [@Zlength ?T ?A] => pose_Zlength_nonneg1 T A
  | H: context [@Zlength ?T ?A] |- _ => pose_Zlength_nonneg1 T A
 end;
  unfold Zlength' in *.

Ltac list_solve := autorewrite with sublist; pose_Zlength_nonneg; omega.

Definition Znth {X}{d: Inhabitant X} n (xs: list X) :=
  if (zlt n 0) then default else nth (Z.to_nat n) xs d.

Lemma Znth_map:
  forall {A:Type} {da: Inhabitant A}{B:Type}{db: Inhabitant B} i (f: A -> B) (al: list A),
  0 <= i < Zlength al ->
  Znth i (map f al)  = f (Znth i al).

Hint Rewrite 
   (@Znth_map Z _) (@Znth_map nat _) (@Znth_map positive _)
    using (auto; rewrite ?Zlength_map in *; omega) : sublist.

Lemma Znth_succ: forall {A}{a: Inhabitant A} i lo (v: list A), Z.succ lo <= i -> Znth (i - lo) v = Znth (i - (Z.succ lo)) (skipn 1 v).

Lemma Znth_0_cons {A}{a: Inhabitant A} l (v:A): Znth 0 (v::l) = v.
Hint Rewrite @Znth_0_cons : sublist.

Lemma Znth_pos_cons {A}{a: Inhabitant A} i l (v:A): 0<i -> Znth i (v::l) = Znth (i-1) l.

Lemma Znth_In : forall {A}{a: Inhabitant A} i l, 0 <= i < Zlength l -> In (Znth i l) l.

Lemma split3_full_length_list: forall {A}{a: Inhabitant A} lo mid hi (ct: list A),
  lo <= mid < hi ->
  Zlength ct = hi - lo ->
  ct = firstn (Z.to_nat (mid - lo)) ct ++

Lemma Forall_Znth:
 forall {A}{a: Inhabitant A} (F: A -> Prop) (al: list A) i,
   0 <= i < Zlength al ->
   Forall F al ->
   F (Znth i al).

Hint Rewrite @app_nil_l @app_nil_r : sublist.

Lemma app_Znth1:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i < Zlength l -> Znth i (l++l') = Znth i l.

Lemma app_Znth2:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i >= Zlength l -> Znth i (l++l') = Znth (i-Zlength l) l'.

Lemma Znth_firstn:
  forall {A}{a: Inhabitant A} (al: list A) (n m : Z),
  n<m -> Znth n (firstn (Z.to_nat m) al) = Znth n al.

Lemma Znth_skipn: forall {A}{a: Inhabitant A}  i n xs,
  0 <= i ->
  0 <= n ->
  Znth i (skipn (nat_of_Z n) xs) = Znth (i+n) xs.

Lemma Z2Nat_neg: forall i, i < 0 -> Z.to_nat i = 0%nat.

Lemma Zlength_firstn:
  forall {A} n (v: list A), Zlength (firstn (Z.to_nat n) v) = Z.min (Z.max 0 n) (Zlength v).

Lemma Zlength_skipn:
  forall {A} n (v: list A),
  Zlength (skipn (Z.to_nat n) v) = Z.max 0 (Zlength v - (Z.max 0n)).

Lemma Znth_cons:
 forall {A}(a: Inhabitant A)  i (al: list A) bl,
  0 <= i < Zlength al  ->
  Znth i al :: bl = firstn (Z.to_nat 1) (skipn (Z.to_nat i) al) ++ bl.

Lemma Zfirstn_app1:
 forall A n (al bl: list A),
  n <= Zlength al -> firstn (Z.to_nat n) (al++bl) = firstn (Z.to_nat n) al.

Lemma Zfirstn_same:
  forall A n (b: list A), n >= Zlength b -> firstn (Z.to_nat n) b = b.

Lemma Zfirstn_app2: forall {A} n (al bl: list A),
 n >= Zlength al ->
 firstn (Z.to_nat n) (al++bl) = al ++ firstn (Z.to_nat (n - Zlength al)) bl.

Lemma Zfirstn_firstn: forall {A} (contents: list A) n m,
  n <= m ->
  firstn (Z.to_nat n) (firstn (Z.to_nat m) contents) = firstn (Z.to_nat n) contents.
Lemma Zskipn_app1:
 forall A n (al bl: list A),
  n <= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat n) al ++ bl.

Lemma Zskipn_app2:
 forall A n (al bl: list A),
  n >= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat (n-Zlength al)) bl.

Lemma Znth_rev:
  forall {A}{d: Inhabitant A} i (al:list A),
  0 <= i < Zlength al ->
  Znth i (rev al) = Znth (Zlength al - i - 1) al.

Lemma Zskipn_firstn: forall {A} n m (xs: list A),
 0 <= n ->
 skipn (Z.to_nat n) (firstn (Z.to_nat m) xs) =

Lemma Zskipn_skipn: forall {A} n m (xs: list A),
  0 <= n -> 0 <= m ->
  skipn (Z.to_nat n) (skipn (Z.to_nat m) xs) = skipn (Z.to_nat (m + n)) xs.

Lemma Zfirstn_app:
 forall {A} n m (al: list A),
  0 <= n -> 0 <= m ->
  firstn (Z.to_nat n) al ++ firstn (Z.to_nat m) (skipn (Z.to_nat n) al) =

Lemma Zfirstn_exact_length:
  forall {A} n (al: list A),
  n = Zlength al ->
  firstn (Z.to_nat n) al = al.

Definition sublist {A} (lo hi: Z) (al: list A) : list A :=
  firstn (Z.to_nat (hi-lo)) (skipn (Z.to_nat lo) al).

Definition upd_Znth {A} (i: Z) (al: list A) (x: A): list A :=
   sublist 0 i al ++ x :: sublist (i+1) (Zlength al) al.

Lemma sublist_sublist {A} i j k m (l:list A): 0<=m -> 0<=k <=i -> i <= j-m ->
  sublist k i (sublist m j l) = sublist (k+m) (i+m) l.

Lemma sublist_rejoin:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid hi al = sublist lo hi al.

Lemma sublist_map:
  forall {A B} (F: A -> B) lo hi (al: list A),
  sublist lo hi (map F al) = map F (sublist lo hi al).

Lemma map_sublist:
  forall {A B} (F: A -> B) lo hi (al: list A),
  map F (sublist lo hi al) = sublist lo hi (map F al).

Lemma sublist_len_1:
  forall {A}{d: Inhabitant A} i (al: list A),
  0 <= i < Zlength al ->
  sublist i (i+1) al = Znth i al :: nil.

Lemma Znth_cons_sublist:
  forall {A}{d: Inhabitant A} i (al: list A) bl,
  0 <= i < Zlength al ->
  Znth i al :: bl = sublist i (i+1) al ++ bl.

Lemma Zlength_sublist:
  forall {A} lo hi (al: list A),
 0 <= lo <= hi -> hi <= Zlength al ->
 Zlength (sublist lo hi al) = hi-lo.

Lemma sublist_same_gen:
forall {A} lo hi (al: list A),
  lo = 0 -> hi >= Zlength al ->
  sublist lo hi al = al.

Lemma sublist_same:
forall {A} lo hi (al: list A),
  lo = 0 -> hi = Zlength al ->
  sublist lo hi al = al.

Lemma Znth_sublist:
  forall {A}{d: Inhabitant A} lo i hi (al: list A),
 0 <= lo ->
 0 <= i < hi-lo ->
 Znth i (sublist lo hi al) = Znth (i+lo) al.

Lemma rev_sublist:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  rev (sublist lo hi al) = sublist (Zlength al - hi) (Zlength al - lo) (rev al).

Lemma sublist_nil:
  forall {A} lo (al: list A),
  sublist lo lo al = nil.

Lemma sublist_nil_gen : forall {A} (l : list A) i j, j <= i -> sublist i j l = [].

Lemma sublist_rev:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  sublist lo hi (rev al) = rev (sublist (Zlength al - hi) (Zlength al - lo) al).

Lemma sublist_app:
  forall {A} lo hi (al bl: list A),
  0 <= lo <= hi -> hi <= Zlength al + Zlength bl ->
  sublist lo hi (al++bl) =
  sublist (Z.min lo (Zlength al)) (Z.min hi (Zlength al)) al ++

Lemma sublist_split:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo hi al = sublist lo mid al ++ sublist mid hi al.

Lemma sublist_last_1 : forall {A}{d: Inhabitant A} lo hi (al : list A), 0 <= lo <= hi -> hi + 1 <= Zlength al ->
  sublist lo (hi + 1) al = sublist lo hi al ++ [Znth hi al].

Lemma Zlen_le_1_rev:
 forall {A} (al: list A),
  Zlength al <= 1 -> rev al = al.

Lemma skipn_0:
  forall A (l: list A), skipn 0 l = l.

Lemma sublist_1_cons {A} l (v:A) n: sublist 1 n (v::l) = sublist 0 (n-1) l.

Lemma sublist_nil': forall (A : Type) (lo lo': Z) (al : list A), lo=lo' -> sublist lo lo' al = [].

Lemma sublist_skip {A} (l:list A) i : 0<=i ->  sublist i (Zlength l) l = skipn (Z.to_nat i) l.

Lemma sublist_firstn {A} (l:list A) i: sublist 0 i l = firstn (Z.to_nat i) l.

Lemma sublist_app1:
  forall (A : Type) (k i : Z) (al bl : list A),
  0 <= k <= i -> i <= Zlength al -> sublist k i (al ++ bl) = sublist k i al.

Lemma sublist0_app1 {A} i (al bl:list A): 0<= i <= Zlength al ->
  sublist 0 i (al ++ bl) = sublist 0 i al.

Lemma sublist_app2 {A} i j (al bl:list A): 0<=Zlength al <= i->
  sublist i j (al ++ bl) = sublist (i-Zlength al) (j-Zlength al) bl.

Lemma sublist_sublist0 {A} i j k (l:list A): 0<=k -> k<=i<=j ->
  sublist k i (sublist 0 j l) = sublist k i l.

Lemma sublist_sublist00 {A} i j (l:list A): 0<=i<=j ->
  sublist 0 i (sublist 0 j l) = sublist 0 i l.

Lemma skipn_list_repeat:
   forall A k n (a: A),
     (k <= n)%nat -> skipn k (list_repeat n a) = list_repeat (n-k) a.

Lemma sublist_list_repeat {A} i j k (v:A) (I: 0<=i)
          (IJK: i <= j <= k):
      sublist i j (list_repeat (Z.to_nat k) v) = list_repeat (Z.to_nat (j-i)) v.

Lemma Zlength_list_repeat:
  forall {A} n (x: A),
  0 <= n ->
  Zlength (list_repeat (Z.to_nat n) x) = n.

Lemma list_repeat_0:
  forall {A} (x:A), list_repeat (Z.to_nat 0) x = nil.

Lemma Znth_list_repeat_inrange:
  forall {A}{d: Inhabitant A} i n (a: A),
   (0 <= i < n)%Z ->
   Znth i (list_repeat (Z.to_nat n) a) = a.

Lemma firstn_nil {A} n: firstn n (nil:list A) = nil.

Lemma firstn_In {A} (x:A): forall l n, In x (firstn n l) -> In x l.
Lemma skipn_In {A} (x:A): forall l n, In x (skipn n l) -> In x l.

Lemma sublist_In {A} lo hi data (x:A) (I:In x (sublist lo hi data)): In x data.

Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Lemma sublist0_app2 {A : Type} i (al bl : list A):
  Zlength al <= i <= Zlength al + Zlength bl ->
  sublist 0 i (al ++ bl) = al ++ sublist 0 (i - Zlength al) bl.

Lemma sublist_rejoin':
  forall {A} lo mid mid' hi (al: list A),
  mid=mid' ->
  0 <= lo <= mid ->
  mid' <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid' hi al = sublist lo hi al.

Hint Rewrite @sublist_nil' using list_solve: sublist.
Hint Rewrite @app_nil_l : sublist.
Hint Rewrite @Zlength_rev : sublist.
Hint Rewrite @sublist_rejoin' using list_solve : sublist.

Lemma subsub1:
 forall a b : Z, (a-(a-b)) = b.
Hint Rewrite subsub1 : sublist.

Lemma sublist_app':
  forall {A} lo hi (al bl: list A),
  0 <= lo <= Zlength al ->
  0 <= hi-Zlength al <= Zlength bl ->
  sublist lo hi (al++bl) =
  sublist lo (Zlength al) al ++
  sublist 0 (hi-Zlength al) bl.

Lemma upd_Znth_Zlength {A} i (l:list A) v: 0<=i < Zlength l ->
      Zlength (upd_Znth i l v) = Zlength l.

Lemma upd_Znth_map {A B} (f:A -> B) i l v:
      upd_Znth i (map f l) (f v) =
      map f (upd_Znth i l v).

Lemma upd_Znth_lookup K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i j (v:A) (I: 0<=i<K) (J: 0<=j<K),
   (i=j /\ Znth i (upd_Znth j l v) = v) \/
   (i<>j /\ Znth i (upd_Znth j l v) = Znth i l).

Lemma upd_Znth_lookup' K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i (I: 0<=i<K) j (J: 0<=j<K) (v:A),
    Znth i (upd_Znth j l v) = if zeq i j then v else Znth i l.

Lemma upd_Znth_char {A} n l1 (v:A) l2 w: Zlength l1=n ->
      upd_Znth n (l1 ++ v :: l2) w = l1 ++ w :: l2.

Lemma upd_Znth_same {A}{d: Inhabitant A}: forall i l u, 0<= i< Zlength l -> Znth i (upd_Znth i l u) = u.

Lemma upd_Znth_diff {A}{d: Inhabitant A}: forall i j l u, 0<= i< Zlength l -> 0<= j< Zlength l -> i<>j ->
      Znth i (upd_Znth j l u) = Znth i l.

Lemma upd_Znth_app1 {A} i l1 l2 (I: 0 <= i < Zlength l1) (v:A):
      upd_Znth i (l1++l2) v = upd_Znth i l1 v ++ l2.

Lemma upd_Znth_app2 {A} (l1 l2:list A) i v:
  Zlength l1 <= i <= Zlength l1 + Zlength l2 ->
  upd_Znth i (l1 ++ l2) v = l1 ++ upd_Znth (i-Zlength l1) l2 v.

Lemma upd_Znth0 {A} (l:list A) v:
upd_Znth 0 l v = v :: sublist 1 (Zlength l) l.

Lemma sublist_upd_Znth_l: forall {A} (l: list A) i lo hi v,
  0 <= lo <= hi ->
  hi <= i < Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_r: forall {A} (l: list A) i lo hi v,
  0 <= i < lo ->
  lo <= hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_lr: forall {A} (l: list A) i lo hi v,
  0 <= lo <= i->
  i < hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = upd_Znth (i - lo) (sublist lo hi l) v.

Hint Rewrite @Znth_list_repeat_inrange : sublist.
Hint Rewrite @Zlength_cons @Zlength_nil: sublist.
Hint Rewrite @list_repeat_0: sublist.
Hint Rewrite <- @app_nil_end : sublist.
Hint Rewrite @Zlength_app: sublist.
Hint Rewrite @Zlength_map: sublist.
Hint Rewrite @Zlength_list_repeat using list_solve: sublist.
Hint Rewrite Z.sub_0_r Z.add_0_l Z.add_0_r : sublist.
Hint Rewrite @Zlength_sublist using list_solve: sublist.
Hint Rewrite Z.max_r Z.max_l using omega : sublist.
Hint Rewrite Z.min_r Z.min_l using omega : sublist.
Hint Rewrite Z.add_simpl_r Z.sub_add Z.sub_diag : sublist.
Hint Rewrite @sublist_sublist using list_solve : sublist.
Hint Rewrite @sublist_app1 using list_solve : sublist.
Hint Rewrite @sublist_app2 using list_solve : sublist.
Hint Rewrite @sublist_list_repeat  using list_solve : sublist.
Hint Rewrite @sublist_same using list_solve : sublist.
Hint Rewrite Z.add_simpl_l : sublist.
Hint Rewrite Z.add_add_simpl_l_l Z.add_add_simpl_l_r
     Z.add_add_simpl_r_l Z.add_add_simpl_r_r : sublist.
Hint Rewrite Z.add_0_r : sublist.
Hint Rewrite @app_Znth1 using list_solve : sublist.
Hint Rewrite @app_Znth2 using list_solve : sublist.
Hint Rewrite @Znth_sublist using list_solve : sublist.
Hint Rewrite @upd_Znth_Zlength using list_solve : sublist.

Hint Rewrite @sublist_nil : sublist.

Lemma list_repeat_app':
 forall {A: Type} a b (x:A), 
    0 <= a -> 0 <= b ->
    list_repeat (Z.to_nat a) x ++ list_repeat (Z.to_nat b) x = list_repeat (Z.to_nat (a+b)) x.

Lemma Znth_overflow:
  forall {A}{d: Inhabitant A} i (al: list A), i >= Zlength al -> Znth i al = d.

Lemma Znth_underflow:
  forall {A}{d: Inhabitant A} i (al: list A),  i < 0 -> Znth i al = d.

Lemma Znth_outofbounds:
  forall {A}{d: Inhabitant A} i (al: list A),  (i < 0 \/ i >= Zlength al) -> Znth i al = d.

Lemma sublist_one:
  forall {A}{d: Inhabitant A} lo hi (al: list A),
    0 <= lo -> hi <= Zlength al ->
    lo+1=hi -> sublist lo hi al = Znth lo al :: nil.

Lemma Forall_app :
forall {A} P (l1 l2 :list A),
Forall P (l1 ++ l2) <->
Forall P l1 /\ Forall P l2.

Lemma Forall_firstn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (firstn n l).

Lemma Forall_skipn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (skipn n l).

Lemma Forall_map:
  forall {A B} (f: B -> Prop) (g: A -> B) al,
   Forall f (map g al) <-> Forall (Basics.compose f g) al.

Lemma Forall_sublist:
  forall {A} (f: A -> Prop) lo hi al,
   Forall f al -> Forall f (sublist lo hi al).

Hint Rewrite @upd_Znth_app1 using list_solve : sublist.
Hint Rewrite @upd_Znth_app2 using list_solve : sublist.

Lemma map_list_repeat: forall {A B} (f: A->B) n (x:A), map f (list_repeat n x) = list_repeat n (f x).
Hint Rewrite @map_list_repeat : sublist.

Lemma Zlength_sublist_correct: forall {A} (l: list A) (lo hi: Z),
  0 <= lo <= hi ->
  hi <= Zlength l ->
  Zlength (sublist lo hi l) = hi - lo.

Lemma Zlength_sublist_incorrect: forall {A} (l: list A) (lo hi: Z),
  0 <= lo < hi ->
  hi > Zlength l ->
  Zlength (sublist lo hi l) < hi - lo.

Lemma nth_Znth {A} {d: Inhabitant A}:
forall n (xs:list A), 0 <= n < Zlength xs -> (nth (Z.to_nat n) xs d) = (Znth n xs). *)

Require Import aes.tablesLL.
(* aes.tablesLL:
Require Import List. Import ListNotations.
Require Import ZArith.
Local Open Scope Z_scope.
Require Import Integers.
Require Import VST.floyd.proofauto.
Require Import aes.sbox.
Require Import aes.GF_ops_LL.
Require Import aes.list_utils.

Definition rot8(i: int): int := 
  Int.or (Int.and (Int.shl i (Int.repr 8)) (Int.repr (-1))) (Int.shru i (Int.repr 24)).

Definition rotl1(b: int): int :=
  Int.and (Int.or (Int.shl b (Int.repr 1)) (Int.shr b (Int.repr 7))) (Int.repr 255).

Definition FSb := map Int.repr sbox.
Definition RSb := map Int.repr inv_sbox.

Definition calc_FT0(i: Z): int :=
  (Int.xor (Int.xor (Int.xor 
     (times2 (Znth i FSb)) 
     (Int.shl (Znth i FSb) (Int.repr 8)))
     (Int.shl (Znth i FSb) (Int.repr 16)))
     (Int.shl (Int.and (Int.xor (times2 (Znth i FSb)) (Znth i FSb))
                       (Int.repr 255))
              (Int.repr 24))).
Definition calc_FT1(i: Z): int := rot8 (calc_FT0 i).
Definition calc_FT2(i: Z): int := rot8 (calc_FT1 i).
Definition calc_FT3(i: Z): int := rot8 (calc_FT2 i).
Definition calc_RT0(i: Z): int :=
  Int.xor (Int.xor (Int.xor
           (mul (Int.repr 14) (Int.repr (Int.unsigned (Znth i RSb))))
  (Int.shl (mul (Int.repr  9) (Int.repr (Int.unsigned (Znth i RSb)))) (Int.repr  8)))
  (Int.shl (mul (Int.repr 13) (Int.repr (Int.unsigned (Znth i RSb)))) (Int.repr 16)))
  (Int.shl (mul (Int.repr 11) (Int.repr (Int.unsigned (Znth i RSb)))) (Int.repr 24)).
Definition calc_RT1(i: Z): int := rot8 (calc_RT0 i).
Definition calc_RT2(i: Z): int := rot8 (calc_RT1 i).
Definition calc_RT3(i: Z): int := rot8 (calc_RT2 i).

Global Opaque calc_FT0 calc_FT1 calc_FT2 calc_FT2 calc_RT0 calc_RT1 calc_RT2 calc_RT3.

Definition FT0 := fill_list 256 calc_FT0.
Definition FT1 := fill_list 256 calc_FT1.
Definition FT2 := fill_list 256 calc_FT2.
Definition FT3 := fill_list 256 calc_FT3.
Definition RT0 := fill_list 256 calc_RT0.
Definition RT1 := fill_list 256 calc_RT1.
Definition RT2 := fill_list 256 calc_RT2.
Definition RT3 := fill_list 256 calc_RT3.
Definition RCON := repeat_op_table 10 Int.one times2.

Global Opaque FSb FT0 FT1 FT2 FT3 RSb RT0 RT1 RT2 RT3 RCON.

Definition calc_FSb_nonzero(i: Z): int :=
  let x := pow3 (255 - log3 (Int.repr i)) in
  (Int.xor (Int.xor (Int.xor (Int.xor        x 
                                      (rotl1 x))
                               (rotl1 (rotl1 x)))
                        (rotl1 (rotl1 (rotl1 x))))
        (Int.xor (rotl1 (rotl1 (rotl1 (rotl1 x)))) (Int.repr 99))).

Lemma FSb_equiv: forall i,
  1 <= i < 256 ->
  calc_FSb_nonzero i = Znth i FSb. *)



Definition four_ints := (int * (int * (int * int)))%type.



Definition col (i : Z) (s : four_ints) : int := match i with

| 0 => fst s

| 1 => fst (snd s)

| 2 => fst (snd (snd s))

| 3 => snd (snd (snd s))

| _ => Int.zero 

end.



Lemma split_four_ints: forall (S: four_ints),

  S = (col 0 S, (col 1 S, (col 2 S, col 3 S))).

Proof.

  intros. destruct S as [c1 [c2 [c3 c4]]]. reflexivity.

Qed.



Lemma split_four_ints_eq: forall S c0 c1 c2 c3,

  S = (c0, (c1, (c2, c3))) -> c0 = col 0 S /\ c1 = col 1 S /\ c2 = col 2 S /\ c3 = col 3 S.

Proof.

  intros. destruct S as [d0 [d1 [d2 d3]]]. inversion H. auto.

Qed.



Module Type AES_LL_Spec_Type.



Parameter get_uint32_le: list Z -> Z -> int.

Axiom get_uint32_le_def: get_uint32_le = fun (arr: list Z) (i: Z) =>

 (Int.or (Int.or (Int.or

            (Int.repr (Znth  i    arr 0))

   (Int.shl (Int.repr (Znth (i+1) arr 0)) (Int.repr  8)))

   (Int.shl (Int.repr (Znth (i+2) arr 0)) (Int.repr 16)))

   (Int.shl (Int.repr (Znth (i+3) arr 0)) (Int.repr 24))).



Parameter put_uint32_le: int -> list int.

Axiom put_uint32_le_def: put_uint32_le = fun (x : int) =>

  [ (Int.and           x                (Int.repr 255));

    (Int.and (Int.shru x (Int.repr  8)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 16)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 24)) (Int.repr 255)) ].



Parameter output_four_ints_as_bytes: four_ints -> list int.

Axiom output_four_ints_as_bytes_def: output_four_ints_as_bytes = fun (s : four_ints) =>

  (put_uint32_le (col 0 s)) ++

  (put_uint32_le (col 1 s)) ++

  (put_uint32_le (col 2 s)) ++

  (put_uint32_le (col 3 s)).



Parameter byte0: int -> Z.

Axiom byte0_def: byte0 = fun (x : int) =>

  (Z.land (Int.unsigned x) (Int.unsigned (Int.repr 255))).

Parameter byte1: int -> Z.

Axiom byte1_def: byte1 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 8))) (Int.unsigned (Int.repr 255))).

Parameter byte2: int -> Z.

Axiom byte2_def: byte2 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 16))) (Int.unsigned (Int.repr 255))).

Parameter byte3: int -> Z.

Axiom byte3_def: byte3 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 24))) (Int.unsigned (Int.repr 255))).



Parameter mbed_tls_fround_col: int -> int -> int -> int -> Z -> int.

Axiom mbed_tls_fround_col_def: mbed_tls_fround_col = fun (col0 col1 col2 col3 : int) (rk : Z) =>

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

    (Znth (byte0 col0) FT0 Int.zero))

    (Znth (byte1 col1) FT1 Int.zero))

    (Znth (byte2 col2) FT2 Int.zero))

    (Znth (byte3 col3) FT3 Int.zero)).



Parameter mbed_tls_final_fround_col: int -> int -> int -> int -> Z -> int.

Axiom mbed_tls_final_fround_col_def: mbed_tls_final_fround_col =

fun (col0 col1 col2 col3 : int) (rk : Z) =>

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

             (Znth (byte0 col0) FSb Int.zero)              )

    (Int.shl (Znth (byte1 col1) FSb Int.zero) (Int.repr 8)))

    (Int.shl (Znth (byte2 col2) FSb Int.zero) (Int.repr 16)))

    (Int.shl (Znth (byte3 col3) FSb Int.zero) (Int.repr 24))).



Parameter mbed_tls_initial_add_round_key_col: Z -> list Z -> list Z -> int.

Axiom mbed_tls_initial_add_round_key_col_def: mbed_tls_initial_add_round_key_col =

fun (col_id : Z) (plaintext : list Z) (rks : list Z) =>

  Int.xor (get_uint32_le plaintext (col_id * 4)) (Int.repr (Znth col_id rks 0)).



Parameter mbed_tls_fround: four_ints -> list Z -> Z -> four_ints.

Axiom mbed_tls_fround_def: mbed_tls_fround =

fun (cols : four_ints) (rks : list Z) (i : Z) =>

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.



Parameter mbed_tls_final_fround: four_ints -> list Z -> Z -> four_ints.

Axiom mbed_tls_final_fround_def: mbed_tls_final_fround =

fun (cols : four_ints) (rks : list Z) (i : Z) =>

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_final_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_final_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_final_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_final_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.



Parameter mbed_tls_enc_rounds: nat -> four_ints -> list Z -> Z -> four_ints.

Axiom mbed_tls_enc_rounds_def: mbed_tls_enc_rounds =

fix mbed_tls_enc_rounds (n : nat) (state : four_ints) (rks : list Z) (i : Z) :=

match n with

| O => state

| S m => mbed_tls_fround (mbed_tls_enc_rounds m state rks i) rks (i+4*Z.of_nat m)

end.



Parameter mbed_tls_initial_add_round_key: list Z -> list Z -> four_ints.

Axiom mbed_tls_initial_add_round_key_def: mbed_tls_initial_add_round_key =

fun (plaintext : list Z) (rks : list Z) =>

((mbed_tls_initial_add_round_key_col 0 plaintext rks),

((mbed_tls_initial_add_round_key_col 1 plaintext rks),

((mbed_tls_initial_add_round_key_col 2 plaintext rks),

((mbed_tls_initial_add_round_key_col 3 plaintext rks))))).



Parameter mbed_tls_aes_enc: list Z -> list Z -> list int.

Axiom mbed_tls_aes_enc_def: mbed_tls_aes_enc = fun (plaintext : list Z) (rks : list Z) =>

  let state0  := mbed_tls_initial_add_round_key plaintext rks in

  let state13 := mbed_tls_enc_rounds 13 state0 rks 4 in

  let state14 := mbed_tls_final_fround state13 rks 56 in

  output_four_ints_as_bytes state14.



End AES_LL_Spec_Type.



Module Export AES_LL_Spec : AES_LL_Spec_Type.



Definition get_uint32_le (arr: list Z) (i: Z) : int :=

 (Int.or (Int.or (Int.or

            (Int.repr (Znth  i    arr 0))

   (Int.shl (Int.repr (Znth (i+1) arr 0)) (Int.repr  8)))

   (Int.shl (Int.repr (Znth (i+2) arr 0)) (Int.repr 16)))

   (Int.shl (Int.repr (Znth (i+3) arr 0)) (Int.repr 24))).

Lemma get_uint32_le_def: get_uint32_le = fun (arr: list Z) (i: Z) =>

 (Int.or (Int.or (Int.or

            (Int.repr (Znth  i    arr 0))

   (Int.shl (Int.repr (Znth (i+1) arr 0)) (Int.repr  8)))

   (Int.shl (Int.repr (Znth (i+2) arr 0)) (Int.repr 16)))

   (Int.shl (Int.repr (Znth (i+3) arr 0)) (Int.repr 24))).

Proof. reflexivity. Qed.



Definition put_uint32_le (x : int) : list int :=

  [ (Int.and           x                (Int.repr 255));

    (Int.and (Int.shru x (Int.repr  8)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 16)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 24)) (Int.repr 255)) ].

Lemma put_uint32_le_def: put_uint32_le = fun (x : int) =>

  [ (Int.and           x                (Int.repr 255));

    (Int.and (Int.shru x (Int.repr  8)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 16)) (Int.repr 255));

    (Int.and (Int.shru x (Int.repr 24)) (Int.repr 255)) ].

Proof. reflexivity. Qed.



Definition output_four_ints_as_bytes (s : four_ints) :=

  (put_uint32_le (col 0 s)) ++

  (put_uint32_le (col 1 s)) ++

  (put_uint32_le (col 2 s)) ++

  (put_uint32_le (col 3 s)).

Lemma output_four_ints_as_bytes_def: output_four_ints_as_bytes = fun (s : four_ints) =>

  (put_uint32_le (col 0 s)) ++

  (put_uint32_le (col 1 s)) ++

  (put_uint32_le (col 2 s)) ++

  (put_uint32_le (col 3 s)).

Proof. reflexivity. Qed.



Definition byte0 (x : int) : Z :=

  (Z.land (Int.unsigned x) (Int.unsigned (Int.repr 255))).

Lemma byte0_def: byte0 = fun (x : int) =>

  (Z.land (Int.unsigned x) (Int.unsigned (Int.repr 255))).

Proof. reflexivity. Qed.



Definition byte1 (x : int) : Z :=

  (Z.land (Int.unsigned (Int.shru x (Int.repr 8))) (Int.unsigned (Int.repr 255))).

Lemma byte1_def: byte1 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 8))) (Int.unsigned (Int.repr 255))).

Proof. reflexivity. Qed.



Definition byte2 (x : int) : Z :=

  (Z.land (Int.unsigned (Int.shru x (Int.repr 16))) (Int.unsigned (Int.repr 255))).

Lemma byte2_def: byte2 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 16))) (Int.unsigned (Int.repr 255))).

Proof. reflexivity. Qed.



Definition byte3 (x : int) : Z :=

  (Z.land (Int.unsigned (Int.shru x (Int.repr 24))) (Int.unsigned (Int.repr 255))).

Lemma byte3_def: byte3 = fun (x : int) =>

  (Z.land (Int.unsigned (Int.shru x (Int.repr 24))) (Int.unsigned (Int.repr 255))).

Proof. reflexivity. Qed.



Definition mbed_tls_fround_col (col0 col1 col2 col3 : int) (rk : Z) : int :=

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

    (Znth (byte0 col0) FT0 Int.zero))

    (Znth (byte1 col1) FT1 Int.zero))

    (Znth (byte2 col2) FT2 Int.zero))

    (Znth (byte3 col3) FT3 Int.zero)).

Lemma mbed_tls_fround_col_def: mbed_tls_fround_col = fun (col0 col1 col2 col3 : int) (rk : Z) =>

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

    (Znth (byte0 col0) FT0 Int.zero))

    (Znth (byte1 col1) FT1 Int.zero))

    (Znth (byte2 col2) FT2 Int.zero))

    (Znth (byte3 col3) FT3 Int.zero)).

Proof. reflexivity. Qed.



Definition mbed_tls_final_fround_col (col0 col1 col2 col3 : int) (rk : Z) : int :=

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

             (Znth (byte0 col0) FSb Int.zero)              )

    (Int.shl (Znth (byte1 col1) FSb Int.zero) (Int.repr 8)))

    (Int.shl (Znth (byte2 col2) FSb Int.zero) (Int.repr 16)))

    (Int.shl (Znth (byte3 col3) FSb Int.zero) (Int.repr 24))).

Lemma mbed_tls_final_fround_col_def: mbed_tls_final_fround_col =

fun (col0 col1 col2 col3 : int) (rk : Z) =>

  (Int.xor (Int.xor (Int.xor (Int.xor (Int.repr rk)

             (Znth (byte0 col0) FSb Int.zero)              )

    (Int.shl (Znth (byte1 col1) FSb Int.zero) (Int.repr 8)))

    (Int.shl (Znth (byte2 col2) FSb Int.zero) (Int.repr 16)))

    (Int.shl (Znth (byte3 col3) FSb Int.zero) (Int.repr 24))).

Proof. reflexivity. Qed.



Definition mbed_tls_initial_add_round_key_col (col_id : Z) (plaintext : list Z) (rks : list Z) :=

  Int.xor (get_uint32_le plaintext (col_id * 4)) (Int.repr (Znth col_id rks 0)).

Lemma mbed_tls_initial_add_round_key_col_def: mbed_tls_initial_add_round_key_col =

fun (col_id : Z) (plaintext : list Z) (rks : list Z) =>

  Int.xor (get_uint32_le plaintext (col_id * 4)) (Int.repr (Znth col_id rks 0)).

Proof. reflexivity. Qed.



Definition mbed_tls_fround (cols : four_ints) (rks : list Z) (i : Z) : four_ints :=

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.

Lemma mbed_tls_fround_def: mbed_tls_fround =

fun (cols : four_ints) (rks : list Z) (i : Z) =>

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.

Proof. reflexivity. Qed.



Definition mbed_tls_final_fround (cols : four_ints) (rks : list Z) (i : Z) : four_ints :=

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_final_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_final_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_final_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_final_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.

Lemma mbed_tls_final_fround_def: mbed_tls_final_fround =

fun (cols : four_ints) (rks : list Z) (i : Z) =>

match cols with (col0, (col1, (col2, col3))) =>

  ((mbed_tls_final_fround_col col0 col1 col2 col3 (Znth  i    rks 0)),

  ((mbed_tls_final_fround_col col1 col2 col3 col0 (Znth (i+1) rks 0)),

  ((mbed_tls_final_fround_col col2 col3 col0 col1 (Znth (i+2) rks 0)),

   (mbed_tls_final_fround_col col3 col0 col1 col2 (Znth (i+3) rks 0)))))

end.

Proof. reflexivity. Qed.



Fixpoint mbed_tls_enc_rounds (n : nat) (state : four_ints) (rks : list Z) (i : Z) : four_ints :=

match n with

| O => state

| S m => mbed_tls_fround (mbed_tls_enc_rounds m state rks i) rks (i+4*Z.of_nat m)

end.

Lemma mbed_tls_enc_rounds_def: mbed_tls_enc_rounds =

fix mbed_tls_enc_rounds (n : nat) (state : four_ints) (rks : list Z) (i : Z) :=

match n with

| O => state

| S m => mbed_tls_fround (mbed_tls_enc_rounds m state rks i) rks (i+4*Z.of_nat m)

end.

Proof. reflexivity. Qed.



Definition mbed_tls_initial_add_round_key (plaintext : list Z) (rks : list Z) : four_ints :=

((mbed_tls_initial_add_round_key_col 0 plaintext rks),

((mbed_tls_initial_add_round_key_col 1 plaintext rks),

((mbed_tls_initial_add_round_key_col 2 plaintext rks),

((mbed_tls_initial_add_round_key_col 3 plaintext rks))))).

Lemma mbed_tls_initial_add_round_key_def: mbed_tls_initial_add_round_key =

fun (plaintext : list Z) (rks : list Z) =>

((mbed_tls_initial_add_round_key_col 0 plaintext rks),

((mbed_tls_initial_add_round_key_col 1 plaintext rks),

((mbed_tls_initial_add_round_key_col 2 plaintext rks),

((mbed_tls_initial_add_round_key_col 3 plaintext rks))))).

Proof. reflexivity. Qed.



Definition mbed_tls_aes_enc (plaintext : list Z) (rks : list Z) : list int :=

  let state0  := mbed_tls_initial_add_round_key plaintext rks in

  let state13 := mbed_tls_enc_rounds 13 state0 rks 4 in

  let state14 := mbed_tls_final_fround state13 rks 56 in

  (put_uint32_le (col 0 state14)) ++

  (put_uint32_le (col 1 state14)) ++

  (put_uint32_le (col 2 state14)) ++

  (put_uint32_le (col 3 state14)).

Lemma mbed_tls_aes_enc_def: mbed_tls_aes_enc = fun (plaintext : list Z) (rks : list Z) =>

  let state0  := mbed_tls_initial_add_round_key plaintext rks in

  let state13 := mbed_tls_enc_rounds 13 state0 rks 4 in

  let state14 := mbed_tls_final_fround state13 rks 56 in

  output_four_ints_as_bytes state14.

Proof. reflexivity. Qed.



End AES_LL_Spec.



