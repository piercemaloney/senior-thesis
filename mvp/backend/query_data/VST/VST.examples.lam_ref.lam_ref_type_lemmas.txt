

Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)



Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)

Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)

Require Import lam_ref_mach_lemmas.
(* lam_ref_mach_lemmas:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Lemma isVal_val2exp : forall v, isValue (val_to_exp v).

Lemma closed_dec : forall e n,
  { closed' n e} + { ~closed' n e}.

Lemma value_dec : forall e,
  { isValue e } + { ~isValue e }.

Ltac show_stopped :=
  let m' := fresh "m'" in
  let e' := fresh "e'" in
  let H := fresh "H" in
  right; intros [m' [e' H]]; inv H.

Lemma stopped_dec : forall e m,
  { st | step (m,e) st} + { stopped m e }.

Lemma closed'_S : forall n e,
  closed' n e ->
  closed' (S n) e.

Lemma closed'_le : forall m n,
  m <= n ->
  forall e,
  closed' m e ->
  closed' n e.

Lemma closed'_subst: forall m e x v,
  closed' m e ->
  subst (x + m) v e = e.

Lemma closed_closed_subst: forall x v e,
  closed e ->
  closed (subst x v e).

Lemma closed_Lam_subst: forall e x v,
  closed (Lam e) ->
  subst x v (Lam e) = Lam e.

Lemma subst_env'_Nat: forall rho m n,
  subst_env' m rho (Nat n) = Nat n.

Lemma subst_env'_Loc: forall rho m l,
  subst_env' m rho (Loc l) = Loc l.

Lemma subst_env'_Var': forall n m rho,
  subst_env' (S (n + m)) rho (Var n) = Var n.

Lemma subst_env'_Var: forall rho n v m,
  nth_error rho n = Some v ->
  subst_env' m rho (Var (n + m)) = val_to_exp v.

Lemma subst_env'_New: forall rho m e,
  subst_env' m rho (New e) = New (subst_env' m rho e).

Lemma subst_env'_Deref: forall rho m e,
  subst_env' m rho (Deref e) = Deref (subst_env' m rho e).

Lemma subst_env'_Update: forall rho m e1 e2 e3,
  subst_env' m rho (Update e1 e2 e3) =
  Update (subst_env' m rho e1) (subst_env' m rho e2) (subst_env' m rho e3).

Lemma subst_env_New: forall rho e,
  subst_env rho (New e) = New (subst_env rho e).

Lemma subst_env_Deref: forall rho e,
  subst_env rho (Deref e) = Deref (subst_env rho e).

Lemma subst_env_Update: forall rho e1 e2 e3,
  subst_env rho (Update e1 e2 e3) =
  Update (subst_env rho e1) (subst_env rho e2) (subst_env rho e3).

Lemma subst_env_App : forall env e1 e2,
  subst_env env (App e1 e2) = App (subst_env env e1) (subst_env env e2).

Lemma subst_env_Prim : forall env f e,
  subst_env env (Prim f e) = Prim f (subst_env env e).

Lemma subst_subst_neq : forall e n m v1 v2,
  n <> m ->
  subst n v1 (subst m v2 e) =
  subst m v2 (subst n v1 e).

Lemma subst_env_split : forall env1 env2 n e,
  subst_env' n (env1 ++ env2) e =
  subst_env' n env1 (subst_env' (length env1 + n) env2 e).

Lemma subst_subst_env_lt : forall env n m v e,
  n < m ->
  subst n v (subst_env' m env e) =
  subst_env' m env (subst n v e).

Lemma subst_closed' :
  forall e n v,
    closed' (S n) e ->
    closed' n (subst n v e).

Lemma closed_subst_env : forall env e x n,
   closed' (length env + x) e ->
   closed' (x + n) (subst_env' (x + n) env e).

Lemma closed_step : forall x y ,
  step x y ->
  closed (snd x) ->
  closed (snd y).

Lemma values_stopped: forall e,
  isValue e ->
  forall m,
  stopped m e.

Lemma stopped_New: forall m e,
  stopped m (New e) ->
  stopped m e.

Lemma stopped_Deref: forall m e,
  stopped m (Deref e) ->
  stopped m e.

Lemma stopped_Update: forall m e1 e2 e3,
  stopped m (Update e1 e2 e3) ->
  stopped m e1 \/ (isValue e1 /\ stopped m e2).

Lemma step_deterministic: forall m e m1 e1 m2 e2,
  step (m,e) (m1,e1) ->
  step (m,e) (m2,e2) ->
  m1 = m2 /\ e1 = e2.

Lemma stepn_value: forall j m v st,
  isValue v ->
  stepn j (m, v) st ->
  st = (m, v).

Lemma stepstar_search : forall f m e m' e',
  (forall m e m' e',
    step (m,e) (m',e') -> step (m,f e) (m',f e')) ->
  stepstar (m,e) (m',e') ->
  stepstar (m,f e) (m', f e').

Lemma stepn_trans : forall n m st1 st2 st3,
  stepn n st1 st2 ->
  stepn m st2 st3 ->
  stepn (n+m) st1 st3.

Lemma stepstar_stepn : forall st st',
  stepstar st st' <-> exists n, stepn n st st'. *)

Require Import lam_ref_type_prelim.
(* lam_ref_type_prelim:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.

Module TFP <: TY_FUNCTOR_PROP.

  Definition F : Type -> Type := fun K => addr -> option K.

  Definition f_F := f_fun addr (f_option f_identity).

  Definition other : Type := value.
End TFP.

Export TFP.

Module K := KnotHered(TFP). 
Module KL := KnotHered_Lemmas(K).

Export K.
Export KL.

Definition mtype : Type := knot.
Definition world : Type := (mtype * value)%type.

Definition world_ag : ageable world :=
  ag_prod mtype value ag_knot.
Existing Instance world_ag.

Definition knot_extends (k1 k2 : knot) : Prop :=
  match (unsquash k1, unsquash k2) with
    ((n, psi), (n', psi')) => n = n' /\ forall a, (psi a = None) \/ (psi' a = psi a)
  end.

Definition R_extends (w1 w2 : world) : Prop :=
  match (w1, w2) with
    ((k1, v1), (k2, v2)) => knot_extends k1 k2 /\ v1 = v2
  end.

Lemma knot_extends_refl : forall k, knot_extends k k.

Lemma knot_extends_trans : forall k1 k2 k3,
  knot_extends k1 k2 ->
  knot_extends k2 k3 ->
  knot_extends k1 k3.

Lemma knot_extends_age_commute1 : forall x y z,
  age x y /\ knot_extends y z -> exists y',
  knot_extends x y' /\ age y' z.

Lemma knot_extends_age_commute2 : forall x y z,
  knot_extends x y /\ age y z -> exists y',
  age x y' /\ knot_extends y' z.

Lemma R_extends_valid_rel :
  valid_rel R_extends.

Lemma R_extends_refl : reflexive _ R_extends.

Lemma R_extends_trans : transitive _ R_extends.

Definition knot_contracts := transp _ knot_extends.

Lemma knot_contracts_age_commute1 : forall x y z,
  age x y /\ knot_contracts y z -> exists y',
  knot_contracts x y' /\ age y' z.

Lemma knot_contracts_age_commute2 : forall x y z,
  knot_contracts x y /\ age y z -> exists y',
  age x y' /\ knot_contracts y' z.

Definition R_contracts := transp _ R_extends.

Lemma R_contracts_valid_rel :
  valid_rel R_contracts.

Definition extendM : modality :=
  exist _ R_extends R_extends_valid_rel.
Definition contractsM : modality :=
  exist _ R_contracts R_contracts_valid_rel.

Notation "'%' e"  := (box extendM e)(at level 30, right associativity): pred.

Lemma value_knot_laterR : forall k k' v v',
  laterR (A:=world) (k,v) (k',v') <-> clos_trans _ age k k' /\ v = v'.

Lemma value_knot_necR : forall k k' v v',
  necR (A:=world) (k,v) (k',v') <-> clos_refl_trans _ age k k' /\ v = v'.

Open Scope pred.

Definition approx_eq (n : nat) (tau1 tau2 : predicate) : Prop :=
  approx n tau1 = approx n tau2.

Lemma approx_eq_downward : forall n m p q,
  m <= n ->
  approx_eq n p q ->
  approx_eq m p q.

Lemma approx_eq_sub n P Q :
    ((|> (P <=> Q)) n -> approx_eq n P Q).

Hint Resolve R_extends_refl R_extends_trans. *)

Require Import lam_ref_type_defs.
(* lam_ref_type_defs:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Require Export lam_ref_type_prelim.

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.

Lemma ty_nat_extends :
  boxy extendM ty_nat.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).

Lemma just_extends : forall v,
  %just v = just v.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau. *)

Require Import lam_ref_type_safety.
(* lam_ref_type_safety:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.

Lemma expr_type_safen: forall k v e tau,
  expr_type e tau (k,v) ->
    forall m, mtype_valid m (k,v) ->
      safen (level k) (m,e).

Theorem typing_implies_safety: forall e tau,
  Typ nil e tau ->
  safe_prog e. *)



Lemma exp_to_val_to_exp : forall v H,

  exp_to_val (val_to_exp v) H = v.

Proof.

  unfold val_to_exp, exp_to_val.

  intros.

  destruct v as [v Hv]; simpl in *.

  destruct v; simpl in *;

    (replace Hv with H by (apply proof_irr); auto).

Qed.



Lemma forces2exprType: forall w v tau,

  forces w v (%tau) ->

  forall v', expr_type (val_to_exp v) tau (w,v').

Proof.

  intros.

  rewrite expr_type_eqn.

  repeat intro.

  split.

  repeat intro.

  simpl in H4.

  assert (stopped b (val_to_exp v)).

  apply values_stopped.

  unfold val_to_exp.

  destruct v; simpl; auto.

  elim H6; eauto.

  repeat intro.

  simpl in H4.

  exists (projT2 v).

  rewrite exp_to_val_to_exp.

  destruct a'.

  destruct H0.

  subst.

  rewrite <- (box_refl_trans extendM) in H; auto.

  assert (forces m v (%tau)).

  apply H.

  split; auto.

  assert (forces (fst a'1) v (%tau)).

  apply pred_nec_hereditary with (m,v).

  rewrite value_knot_necR; split; auto.

  assert (necR (m,v0) a'1).

  apply rt_trans with a'0; auto.

  destruct a'1.

  rewrite value_knot_necR in H6.

  intuition.

  auto.

  apply H6.

Qed.



Lemma exprType_value : forall w e tau m v

  (H:isValue e),

  forces w v (mtype_valid m) ->

  expr_type e tau (w,v) ->

  forces w (exp_to_val e H) (%tau).

Proof.

  intros.

  rewrite expr_type_eqn in H1.

  spec H1 (w,v).

  detach H1.

  spec H1 m.

  spec H1 (w,v) (rt_refl _ age (w,v)) H0.

  destruct H1.

  spec H2 (w,v) (rt_refl _ age (w,v)).

  detach H2.

  destruct H2.

  replace H with x by (apply proof_irr).

  auto.

  simpl; auto.

  apply values_stopped; auto.

  apply R_extends_refl.

Qed.



Lemma expr_type_search_rule : forall (G Q tau sigma:pred world) (f:expr -> expr),

  forall e a,

         closed (f e) ->

         expr_type e tau a ->

         (Q) a ->

         (|>G) a ->

  forall

  (HQ: boxy extendM Q)

  (HG: boxy extendM G)

  (Hstep : forall m m' x y, step (m,x) (m',y) -> step (m,f x) (m',f y))

  (Hredex:

     forall k v e m (H:isValue e),

         closed (f e) ->

         (|>G) (k,v) ->

         Q (k,v) ->

         mtype_valid m (k,v) ->

         (%tau) (k,exp_to_val e H) ->

         expr_type (f e) sigma (k,v))

  (Hsearch:

     forall e a,

         closed (f e) ->

         G a ->

         Q a ->

         expr_type e tau a ->

         expr_type (f e) sigma a),



  expr_type (f e) sigma a.

Proof.

  intros G Q tau sigma f e a Hcl H H0 H1; intros.

  rewrite expr_type_eqn; repeat intro.

  destruct (stopped_dec e b).

  destruct s as [[m' e'] Hst].

  split; repeat intro.

  simpl in H6.

  destruct a'2 as [k v].

  generalize (Hstep _ _ _ _ Hst); intros.

  assert (m' = b0 /\ f e' = b1).

  eapply step_deterministic; eauto.

  destruct H9; subst b0 b1.

  clear H8.

  rewrite expr_type_eqn in H.

  spec H a' H2.

  spec H b a'0 H3 H4.

  destruct H.

  spec H m' e' a'1 H5.

  detach H.

  spec H (k,v) H7.

  destruct H as [w [? ?]].

  exists w; split; auto.

  destruct H9.

  split; auto.

  apply Hsearch; auto.

  change (f e') with (snd (m',f e')).

  eapply closed_step; eauto.

  rewrite <- HG in H1.

  rewrite <- later_commute in H1.

  spec H1 a' H2.

  spec H1 (k,v).

  detach H1.

  rewrite <- HG in H1.

  apply H1; auto.

  simpl; apply Rft_Rt_trans with a'1; auto.

  apply rt_trans with a'0; auto.

  rewrite <- HQ in H0.

  spec H0 a' H2.

  eapply pred_nec_hereditary in H0.

  2: instantiate (1:=(k,v)).

  rewrite <- HQ in H0.

  apply H0; auto.

  apply rt_trans with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  simpl; auto.

  simpl in H6.

  elim H6.

  exists m'; exists (f e').

  apply Hstep; auto.



  rewrite expr_type_eqn in H.

  spec H a' H2.

  spec H b a'0 H3 H4.

  destruct H.

  spec H5 a'0 (rt_refl _ age a'0).

  spec H5.

  simpl; auto.

  destruct H5.

  destruct a'0 as [k v].

  assert (expr_type (f e) sigma (k,v)).

  spec Hredex k v e b x.

  apply Hredex; auto.

  rewrite <- HG in H1.

  rewrite <- later_commute in H1.

  spec H1 a' H2.

  apply pred_nec_hereditary with a'; auto.

  rewrite <- HQ in H0.

  spec H0 a' H2.

  apply pred_nec_hereditary with a'; auto.

  rewrite expr_type_eqn in H6.

  spec H6 (k,v).

  detach H6.

  eapply H6; eauto.

  apply R_extends_refl.

Qed.



Lemma subst_env_valid_closed :  forall env G e a,

  closed' (length G) e ->

  etype_valid env G a ->

  closed (subst_env env e).

Proof.

  intros.

  unfold closed, subst_env.

  change 0 with (0 + 0).

  apply closed_subst_env.

  replace (length env + 0) with (length G); auto.

  revert H0; clear.

  revert env a; induction G; destruct env; simpl; intuition.

  rewrite IHG with env a0; auto.

Qed.



Lemma etype_valid_lookup: forall G x tau w env v,

  nth_error G x = Some tau ->

  etype_valid env G (w,v) ->

  exists v,

    nth_error env x = Some v /\ forces w v (%tau).

Proof.

  induction G; intros.

  destruct x; inversion H.

  destruct x.

  simpl in H.

  inversion H; clear H.

  subst a.

  destruct env.

  inversion H0.

  simpl in H0.

  destruct H0.

  exists v0.

  simpl.

  auto.

  destruct env.

  inversion H0.

  simpl in H0.

  destruct H0.

  simpl in H.

  apply (IHG _ _ _ _ _ H H1).

Qed.



Lemma etype_valid_val : forall G env m v v',

  etype_valid env G (m,v) ->

  etype_valid env G (m,v').

Proof.

  induction G; destruct env; simpl; intuition.

  eapply IHG; eauto.

Qed.



Lemma expr_type_val' : forall tau,

  TT |-- ALL v:value, ALL e:expr, %(expr_type e tau --> with_val v (expr_type e tau)).

Proof.

  intros; apply goedel_loeb.

  hnf; intros.

  intro v.

  destruct H; destruct a.

  clear H.

  rename H0 into H.

  repeat intro.

  destruct a'; simpl.

  destruct H0; subst.

  destruct a'0.

  rewrite value_knot_necR in H1; destruct H1; subst.

  rewrite expr_type_eqn.

  rewrite expr_type_eqn in H2.

  repeat intro.

  destruct a'.

  destruct H3; subst.

  simpl in H3.

  destruct a'0.

  rewrite value_knot_necR in H4; destruct H4; subst.

  spec H2 (m2,v0).

  detach H2.

  spec H2 b0 (m3,v0).

  detach H2.

  spec H2 H5.

  split; destruct H2.

  repeat intro.

  spec H2 b1 b2.

  destruct a'.

  rewrite value_knot_necR in H7; destruct H7; subst.

  destruct a'0.

  simpl in H9.

  rewrite value_knot_laterR in H9; destruct H9; subst.

  spec H2 (m4,v0).

  detach H2.

  detach H2.

  spec H2 (m5,v0).

  detach H2.

  destruct H2 as [w [? ?]].

  destruct w.

  destruct H2.

  subst.

  exists (m6,v).

  split.

  simpl; split; auto.

  destruct H10.

  split.

  auto.

  rewrite box_all in H.

  spec H v.

  rewrite box_all in H.

  spec H b2.

  rewrite <- (box_refl_trans extendM) in H.

  rewrite <- later_commute in H.

  spec H (m0,v1).

  detach H.

  eapply pred_nec_hereditary in H.

  2: instantiate (1:=(m1,v1)).

  rewrite <- (box_refl_trans extendM) in H.

  rewrite <- later_commute in H.

  spec H (m2,v1); detach H.

  spec H (m5,v1).

  detach H.

  spec H (m6,v1).

  detach H.

  spec H (m6,v1) (rt_refl _ age (m6,v1)).

  apply H; auto.

  split; auto.

  simpl.

  rewrite value_knot_laterR; split; auto.

  apply Rft_Rt_trans with m4; auto.

  apply rt_trans with m3; auto.

  split; auto.

  simpl; apply R_extends_refl.

  simpl; apply R_extends_trans.

  rewrite value_knot_necR; split; auto.

  split; auto.

  simpl; apply R_extends_refl.

  simpl; apply R_extends_trans.

  simpl; rewrite value_knot_laterR; split; auto.

  simpl in H8.

  simpl; auto.

  rewrite value_knot_necR; split; auto.



  repeat intro.

  destruct a'; simpl in H8.

  spec H6 (m4,v0).

  detach H6.

  detach H6.

  auto.

  simpl; auto.

  rewrite value_knot_necR; split; auto.

  rewrite value_knot_necR in H7; intuition.

  rewrite value_knot_necR; split; auto.

  split; auto.

Qed.



Lemma expr_type_val : forall e tau k v v',

  expr_type e tau (k,v) ->

  expr_type e tau (k,v').

Proof.

  intros.

  generalize (expr_type_val' tau); intro H0.

  spec H0 (k,v) I v' e.

  spec H0 (k,v) (R_extends_refl (k,v)).

  spec H0 (k,v) (rt_refl _ age (k,v)).

  apply H0; auto.

Qed.



Lemma openValue_valid_value : forall env G a e,

  openValue e ->

  closed' (length G) e ->

  etype_valid env G a ->

  isValue (subst_env env e).

Proof.

  intros env; pattern env.

  apply rev_ind; clear env; simpl; intros.

  destruct G; auto.

  split; auto.

  elim H1.

  rewrite <- (rev_involutive G) in H2.

  case_eq (rev G); intros;

    rewrite H3 in H2; simpl in H2.

  destruct l; inv H2.

  unfold subst_env.

  rewrite subst_env_split.

  simpl.

  assert (etype_valid l (rev l0) a).

  revert H2; clear.

  generalize (rev l0); clear.

  induction l; simpl; intros; auto.

  destruct l; simpl in *; auto.

  destruct H2.

  destruct l; simpl in H0; auto.

  destruct l0; simpl in H2.

  destruct H2.

  destruct l; simpl in H0; auto.

  destruct H2.

  split.

  destruct a; simpl in *.

  auto.

  apply IHl; auto.



  eapply H with (rev l0) a.

  destruct e; simpl in *; auto.

  elim H0.

  replace (length l + 0) with (length l0).

  rewrite rev_length.

  apply subst_closed'.

  replace (S (length l0)) with (length G); auto.

  rewrite <- rev_length.

  rewrite H3; simpl.

  auto.

  rewrite <- (rev_length l0).

  revert H4; generalize (rev l0); clear.

  induction l; intros.

  destruct l; simpl in H4.

  auto.

  elim H4.

  simpl.

  destruct l0; simpl in H4.

  elim H4.

  simpl; f_equal; auto.

  apply IHl; auto.

  destruct H4; auto.

  auto.

Qed.



Lemma typ_beta: forall v1 v2 sigma tau w,

  forces w v1 (ty_lam sigma tau) ->

  forces w v2 (%sigma) ->

  forall v', expr_type (App (val_to_exp v1) (val_to_exp v2)) tau (w,v').

Proof.

  intros.

  rewrite expr_type_eqn.

  intros z Hz.

  destruct z as [z v].

  destruct Hz as [Hz ?]; subst.

  repeat intro; split; repeat intro.

  simpl in H4; inv H4.

  elim (values_stopped (val_to_exp v1)) with b; eauto.

  apply (projT2 v1).

  elim (values_stopped (val_to_exp v2)) with b; eauto.

  apply (projT2 v2).

  exists a'1; split.

  do 5 red; apply R_extends_refl.

  rewrite exp_to_val_to_exp.

  split.

  apply pred_nec_hereditary with a'; auto.

  apply rt_trans with a'0; auto.

  apply Rt_Rft; auto.

  destruct H as [e [He [Hjst ?]]].

  simpl in Hjst; subst v1.

  inv H9.

  rewrite <- later_commute in H.

  spec H (z,v_Lam e He).

  detach H.

  spec H (fst a'1,v_Lam e He).

  detach H.

  spec H v2 (fst a'1,v_Lam e He).

  spec H (rt_refl _ age (fst a'1,v_Lam e He)).

  detach H.

  destruct a'1; auto.

  revert H.

  apply expr_type_val.

  simpl; auto.

  simpl; intros.

  destruct a'2; destruct H; subst.

  assert (forces (fst a'1) v0 (%sigma)).

  apply pred_nec_hereditary with (z,v0).

  rewrite value_knot_necR; split; auto.

  assert (necR (z,v) a'1).

  apply rt_trans with a'; auto.

  apply rt_trans with a'0; auto.

  apply Rt_Rft; auto.

  destruct a'1.

  rewrite value_knot_necR in H4.

  intuition.

  rewrite <- (box_refl_trans extendM) in H0; auto.

  apply H0.

  split; auto.

  apply H4.

  split; auto.

  simpl; rewrite value_knot_laterR; split; auto.

  assert (laterR (z,v) a'1).

  apply Rft_Rt_trans with a'; auto.

  apply Rft_Rt_trans with a'0; auto.

  destruct a'1.

  rewrite value_knot_laterR in H.

  intuition.

  split; auto.



  elimtype False.

  simpl in H4.

  elim H4.

  destruct H as [e [He [? ?]]].

  simpl in H.

  subst v1.

  unfold v_Lam.

  unfold val_to_exp, v_Lam; simpl.

  exists b.

  exists (subst 0 (exp_to_val (projT1 v2) (projT2 v2)) e).

  apply st_App3.

Qed.



Lemma expr_ty_new: forall k v tau,

  forces k v (%tau) ->

  forall v', expr_type (New (val_to_exp v)) (ty_ref tau) (k,v').

Proof.

  intros.

  destruct v; unfold val_to_exp; simpl.

  rewrite expr_type_eqn.

  repeat intro.

  split; repeat intro.



  simpl in H4.

  inv H4.

  assert (stopped b x).

  apply values_stopped; auto.

  elim H4; eauto.

  unfold new in H8.

  destruct b; inv H8.

  destruct a'2.

  case_eq (unsquash m); intros.

  set (f' := fun a => if beq_nat a l then Some tau else f a).

  assert (R_extends (m,v0) (squash (n,f'),v0)).

  split; auto.

  hnf.

  rewrite H4.

  rewrite unsquash_squash.

  split; auto.

  intros.

  assert (mtype_valid (l,v) (m,v0)).

  apply pred_nec_hereditary with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  case_eq (f a); intros; auto.

  right.

  unfold fmap, option_map, compose, f'.

  hnf in H7.

  rewrite H4 in H7.

  case_eq (beq_nat a l); intros.

  apply beq_nat_true in H9.

  subst a.

  spec H7 l.

  cbv beta zeta in H7.

  rewrite H8 in H7.

  destruct H7.

  simpl in H7; omegac.

  cbv beta zeta in H7.

  spec H7 a.

  rewrite H8 in H7.

  simpl.

  rewrite H8.

  generalize H8.

  rewrite (unsquash_approx H4).

  simpl.

  rewrite H8.

  rewrite H9.

  auto.

  assert

    (mtype_valid

        (S l, fun a : nat => if beq_nat a l then exp_to_val x H6 else v a)

        (squash (n,f'),v0)).

  hnf. unfold f'.

  rewrite unsquash_squash.

  intro a.

  simpl fmap. simpl ffun_fmap.

  case_eq (beq_nat a l); intros.

  simpl option_map.

  unfold fidentity_fmap.

  apply beq_nat_true in H8.

  subst a.

  simpl fst.

  split; auto.



  unfold deref; simpl snd.

  case_eq (beq_nat l l); intros.

  replace H6 with i by apply proof_irr.

  rewrite later_commute.

  fold f'.

  unfold forces.

  unfold forces in H.

  cut ((%tau) (squash (n,f'),exp_to_val x i)).

  repeat intro.

  red. rewrite approx_spec.

  split; auto.

  replace (level a'3) with (level a'2).

  apply lt_le_trans with (level (fst (squash (n,f'),exp_to_val x i))).

  simpl in H10.

  destruct a'2.

  rewrite value_knot_laterR in H10.

  simpl.

  apply laterR_level; auto.

  destruct H10; auto.

  rewrite knot_level; simpl.

  rewrite unsquash_squash; auto.

  simpl in H11.

  apply extend_level; auto.

  eapply pred_nec_hereditary in H9.

  2: apply Rt_Rft; apply H10.

  spec H9 a'3 H11.

  apply pred_nec_hereditary with a'3; auto.

  destruct a'.

  assert ((%tau) (m0,exp_to_val x i)).

  rewrite <- box_refl_trans in H; auto.

  apply H.

  split; auto.

  destruct H0; auto.

  assert ((%tau) (m,exp_to_val x i)).

  apply pred_nec_hereditary with (m0,exp_to_val x i).

  rewrite value_knot_necR; split; auto.

  assert (necR (m0,v1) (m,v0)).

  apply rt_trans with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  rewrite value_knot_necR in H10.

  destruct H10; auto.

  auto.

  rewrite <- box_refl_trans in H10; auto.

  apply H10; auto.

  split; auto.

  destruct H7; auto.

  apply beq_nat_false in H8; elim H8; auto.

  case_eq (f a); intros.

  assert (mtype_valid (l,v) (m,v0)).

  apply pred_nec_hereditary with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  hnf in H10.

  rewrite H4 in H10.

  cbv beta zeta in H10.

  spec H10 a.

  rewrite H9 in H10.

  destruct H10.

  simpl in H10.

  split.

  simpl; omega.

  simpl deref.

  rewrite H8.

  unfold deref in H11.

  simpl snd in H11.

  rewrite <- box_refl_trans in H11; auto.

  fold f'.

  spec H11 (squash (n,f'),v a).

  spec H11.

  split; auto.

  destruct H7; auto.

  repeat intro.

  unfold fidentity_fmap. red. rewrite approx_spec.

  split.

  apply lt_le_trans with (level a'2).

  apply laterR_level; auto.

  destruct a'2; destruct H12; subst.

  simpl.

  rewrite knot_level.

  hnf in H12.

  rewrite unsquash_squash in H12.

  case_eq (unsquash m0); intros.

  rewrite H14 in H12; auto.

  destruct H12; simpl; subst; auto.

  eapply H11; eauto.

  simpl.

  assert (mtype_valid (l,v) (m,v0)).

  apply pred_nec_hereditary with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  hnf in H10.

  rewrite H4 in H10.

  spec H10 a.

  cbv beta zeta in H10.

  rewrite H9 in H10.

  simpl in H10.

  apply beq_nat_false in H8.

  omega.



  exists (squash (n,f'),v0).

  split; auto.

  split; auto.

  change (Loc l) with (val_to_exp (v_Loc l)).

  apply forces2exprType.

  rewrite ty_ref_extends.

  exists l; split.

  simpl; auto.

  simpl.

  rewrite unsquash_squash.

  unfold f'. simpl.

  case_eq (beq_nat l l); simpl; intros.

  hnf.

  unfold fidentity_fmap.

  change (approx n (approx n tau)) with ((approx n oo approx n) tau).

  rewrite <- (approx_approx1 0).

  auto.

  apply beq_nat_false in H9; elim H9; auto.



  simpl in H4.

  elim H4.

  case_eq (new b (exp_to_val x i)); intros.

  exists m; exists (Loc a).

  apply st_New2 with i; auto.

Qed.



Lemma expr_type_upd_Update: forall tau sigma w l v e3 v0,

  forces w (v_Loc l) (ty_ref tau) ->

  forces w v (%tau) ->

  expr_type e3 sigma (w,v0) ->

  expr_type (Update (Loc l) (val_to_exp v) e3) sigma (w,v0).

Proof.

  intros.

  rewrite expr_type_eqn; repeat intro.

  split; repeat intro.

  simpl in H6.

  inv H6.

  inv H9.

  assert (stopped b (val_to_exp v)).

  apply values_stopped.

  destruct v; auto.

  elim H6; eauto.

  exists a'2.

  split.

  simpl; apply R_extends_refl.

  split; auto.

  eapply pred_nec_hereditary in H4.

  2: instantiate (1:=a'2).

  2: apply rt_trans with a'1; auto.

  2: apply Rt_Rft; auto.

  destruct a'2.

  simpl in H4.

  simpl.

  case_eq (unsquash m); intros.

  rewrite H6 in H4.

  spec H4 a.

  revert H4.

  generalize (refl_equal (f a)).

  case_eq (f a); intros.

  rewrite exp_to_val_to_exp.

  unfold update.

  destruct b.

  simpl.

  simpl in H9.

  destruct H9; split; auto.

  case_eq (beq_nat l a); intro; auto.

  apply beq_nat_true in H11; subst a.

  hnf in H.

  destruct H.

  destruct H.

  simpl in H; inv H.

  cut (type_at x tau (m,v_Loc x)).

  intro.

  simpl in H.

  rewrite H6 in H.

  rewrite H4 in H.

  cut ((%tau) (m,v)); intros.

  spec H12 a'2 H13.

  eapply pred_nec_hereditary in H12.

  2: apply rt_trans with a'3; auto.

  2: apply Rt_Rft; auto.

  cut (approx n tau a'3).

  hnf in H.

  rewrite <- H.

  intros.

  red in H15. rewrite approx_spec in H15.

  destruct H15; auto.

  red. rewrite approx_spec.

  split; auto.

  apply lt_le_trans with (level a'2).

  apply laterR_level.

  apply Rt_Rft_trans with a'3; auto.

  destruct a'2.

  destruct H13; subst.

  simpl.

  rewrite knot_level.

  case_eq (unsquash m0); intros.

  hnf in H13.

  rewrite H6 in H13.

  rewrite H15 in H13.

  destruct H13; subst; simpl; auto.

  red in H0.

  assert ((%tau) (fst a',v)).

  rewrite <- box_refl_trans in H0; auto.

  spec H0 (fst a',v).

  spec H0.

  split; auto.

  destruct a'; destruct H2; auto.

  auto.

  apply pred_nec_hereditary with (fst a', v); auto.

  rewrite value_knot_necR; split; auto.

  assert (necR a' (m,v1)).

  apply rt_trans with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  destruct a'.

  rewrite value_knot_necR in H13.

  simpl; destruct H13; auto.

  rewrite <- type_at_extends in H11.

  spec H11 (fst a', v_Loc x).

  spec H11.

  split; auto.

  destruct a'; destruct H2; auto.

  eapply pred_nec_hereditary.

  2: apply H11.

  rewrite value_knot_necR; split; auto.

  assert (necR a' (m,v1)).

  apply rt_trans with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  destruct a'.

  rewrite value_knot_necR in H.

  destruct H; simpl; auto.

  unfold update; destruct b; simpl; auto.

  rewrite <- expr_type_extends in H1.

  spec H1 a' H2.

  eapply pred_nec_hereditary.

  2: apply H1.

  apply rt_trans with a'; auto.

  apply rt_trans with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  simpl in H6.

  elim H6.

  exists (update b l v).

  exists e3.

  destruct v.

  apply st_Upd3 with i; auto.

Qed.



Lemma expr_ty_deref_loc : forall l tau a,

  expr_type (Loc l) (ty_ref tau) a ->

  expr_type (Deref (Loc l)) tau a.

Proof.

  intros.

  rewrite expr_type_eqn; repeat intro.

  split; repeat intro.

  simpl in H4.

  inv H4.

  inv H7.

  exists a'2.

  split.

  simpl; apply R_extends_refl.

  split.

  apply pred_nec_hereditary with a'0; auto.

  apply rt_trans with a'1; auto.

  apply Rt_Rft; auto.

  rewrite <- expr_type_extends in H.

  spec H a' H0.

  eapply pred_nec_hereditary in H.

  2: instantiate (1:=a'1).

  2: apply rt_trans with a'0; auto.

  assert (forces (fst a'1) (exp_to_val (Loc l) (isvLoc l)) (%(ty_ref tau))).

  destruct a'1.

  eapply exprType_value.

  2: apply H.

  unfold fst.

  red.

  apply pred_nec_hereditary with a'0; auto.

  apply H2.

  rewrite ty_ref_extends in H4.

  destruct a'1.

  destruct H4 as [l' [? ?]].

  simpl in H4; inv H4.

  simpl fst in H6.

  assert (mtype_valid b0 (m,v)).

  apply pred_nec_hereditary with a'0; auto.

  simpl in H6.

  hnf in H4.

  cbv beta zeta in H4.

  case_eq (unsquash m); intros;

    rewrite H7 in H4, H6.

  spec H4 l'.

  case_eq (f l'); intros.

  rewrite H8 in H4, H6.

  destruct H4.

  destruct a'2.

  eapply forces2exprType.

  rewrite later_commute in H9.

  spec H9 (m0,deref b0 l').

  detach H9.

  repeat intro.

  spec H9 a'1 H10.

  cut (approx n p a'1); intros.

  hnf in H6.

  rewrite H6 in H11.

  red in H11. rewrite approx_spec in H11.

  destruct H11; auto.

  red. rewrite approx_spec.

  split; auto.

  change (level a'1 < n).

  apply le_lt_trans with (level (m0,v0)).

  destruct a'1; destruct H10.

  simpl.

  hnf in H10.

  repeat rewrite knot_level.

  destruct (unsquash m0); destruct (unsquash m1).

  destruct H10; subst; auto.

  apply lt_le_trans with (level (m,v)).

  apply laterR_level; auto.

  simpl.

  rewrite knot_level.

  rewrite H7; simpl; auto.

  simpl in H5; rewrite value_knot_laterR in H5.

  destruct H5; subst.



  simpl; rewrite value_knot_laterR; split; auto.

  rewrite H8 in H6, H4.

  elim H6.

  simpl in H4.

  elim H4.

  exists b.

  exists (val_to_exp (deref b l)).

  apply st_Deref2; auto.

Qed.

