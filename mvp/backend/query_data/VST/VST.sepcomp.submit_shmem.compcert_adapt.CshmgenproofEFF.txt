Require Import Coqlib.

Require Export Axioms.

Require Import Errors.

Require Import Maps.

Require Import Integers.

Require Import Floats.

Require Import AST.

Require Import Values.

Require Import Events.

Require Import Memory.

Require Import Globalenvs.

Require Import Smallstep.

Require Import Ctypes.

Require Import Cop.

Require Import Clight.

Require Import Cminor.
(* Cminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Events.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Switch.

Inductive constant : Type :=
  | Ointconst: int -> constant     
  | Ofloatconst: float -> constant 
  | Olongconst: int64 -> constant  
  | Oaddrsymbol: ident -> int -> constant 
  | Oaddrstack: int -> constant.   

Inductive unary_operation : Type :=
  | Ocast8unsigned: unary_operation        
  | Ocast8signed: unary_operation          
  | Ocast16unsigned: unary_operation       
  | Ocast16signed: unary_operation         
  | Onegint: unary_operation               
  | Onotint: unary_operation               
  | Onegf: unary_operation                 
  | Oabsf: unary_operation                 
  | Osingleoffloat: unary_operation        
  | Ointoffloat: unary_operation           
  | Ointuoffloat: unary_operation          
  | Ofloatofint: unary_operation           
  | Ofloatofintu: unary_operation          
  | Onegl: unary_operation                 
  | Onotl: unary_operation                 
  | Ointoflong: unary_operation            
  | Olongofint: unary_operation            
  | Olongofintu: unary_operation           
  | Olongoffloat: unary_operation          
  | Olonguoffloat: unary_operation         
  | Ofloatoflong: unary_operation          
  | Ofloatoflongu: unary_operation         
  | Osingleoflong: unary_operation         
  | Osingleoflongu: unary_operation.       

Inductive binary_operation : Type :=
  | Oadd: binary_operation                 
  | Osub: binary_operation                 
  | Omul: binary_operation                 
  | Odiv: binary_operation                 
  | Odivu: binary_operation                
  | Omod: binary_operation                 
  | Omodu: binary_operation                
  | Oand: binary_operation                 
  | Oor: binary_operation                  
  | Oxor: binary_operation                 
  | Oshl: binary_operation                 
  | Oshr: binary_operation                 
  | Oshru: binary_operation                
  | Oaddf: binary_operation                
  | Osubf: binary_operation                
  | Omulf: binary_operation                
  | Odivf: binary_operation                
  | Oaddl: binary_operation                
  | Osubl: binary_operation                
  | Omull: binary_operation                
  | Odivl: binary_operation                
  | Odivlu: binary_operation               
  | Omodl: binary_operation                
  | Omodlu: binary_operation               
  | Oandl: binary_operation                
  | Oorl: binary_operation                 
  | Oxorl: binary_operation                
  | Oshll: binary_operation                
  | Oshrl: binary_operation                
  | Oshrlu: binary_operation               
  | Ocmp: comparison -> binary_operation   
  | Ocmpu: comparison -> binary_operation  
  | Ocmpf: comparison -> binary_operation  
  | Ocmpl: comparison -> binary_operation  
  | Ocmplu: comparison -> binary_operation. 

Inductive expr : Type :=
  | Evar : ident -> expr
  | Econst : constant -> expr
  | Eunop : unary_operation -> expr -> expr
  | Ebinop : binary_operation -> expr -> expr -> expr
  | Eload : memory_chunk -> expr -> expr.

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sassign : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Stailcall: signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> list (int * nat) -> nat -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list ident;
  fn_stackspace: Z;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.
Definition program := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t val.

Fixpoint set_params (vl: list val) (il: list ident) {struct il} : env :=
  match il, vl with
  | i1 :: is, v1 :: vs => PTree.set i1 v1 (set_params vs is)
  | i1 :: is, nil => PTree.set i1 Vundef (set_params nil is)
  | _, _ => PTree.empty val
  end.

Fixpoint set_locals (il: list ident) (e: env) {struct il} : env :=
  match il with
  | nil => e
  | i1 :: is => PTree.set i1 Vundef (set_locals is e)
  end.

Definition set_optvar (optid: option ident) (v: val) (e: env) : env :=
  match optid with
  | None => e
  | Some id => PTree.set id v e
  end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> val -> env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (sp: val)                  
             (e: env)                   
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Section RELSEM.

Variable ge: genv.

Definition eval_constant (sp: val) (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  | Oaddrsymbol s ofs =>
      Some(match Genv.find_symbol ge s with
           | None => Vundef
           | Some b => Vptr b ofs end)
  | Oaddrstack ofs => Some (Val.add sp (Vint ofs))
  end.

Definition eval_unop (op: unary_operation) (arg: val) : option val :=
  match op with
  | Ocast8unsigned => Some (Val.zero_ext 8 arg)
  | Ocast8signed => Some (Val.sign_ext 8 arg)
  | Ocast16unsigned => Some (Val.zero_ext 16 arg)
  | Ocast16signed => Some (Val.sign_ext 16 arg)
  | Onegint => Some (Val.negint arg)
  | Onotint => Some (Val.notint arg)
  | Onegf => Some (Val.negf arg)
  | Oabsf => Some (Val.absf arg)
  | Osingleoffloat => Some (Val.singleoffloat arg)
  | Ointoffloat => Val.intoffloat arg
  | Ointuoffloat => Val.intuoffloat arg
  | Ofloatofint => Val.floatofint arg
  | Ofloatofintu => Val.floatofintu arg
  | Onegl => Some (Val.negl arg)
  | Onotl => Some (Val.notl arg)
  | Ointoflong => Some (Val.loword arg)
  | Olongofint => Some (Val.longofint arg)
  | Olongofintu => Some (Val.longofintu arg)
  | Olongoffloat => Val.longoffloat arg
  | Olonguoffloat => Val.longuoffloat arg
  | Ofloatoflong => Val.floatoflong arg
  | Ofloatoflongu => Val.floatoflongu arg
  | Osingleoflong => Val.singleoflong arg
  | Osingleoflongu => Val.singleoflongu arg
  end.

Definition eval_binop
            (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
  match op with
  | Oadd => Some (Val.add arg1 arg2)
  | Osub => Some (Val.sub arg1 arg2)
  | Omul => Some (Val.mul arg1 arg2)
  | Odiv => Val.divs arg1 arg2
  | Odivu => Val.divu arg1 arg2
  | Omod => Val.mods arg1 arg2
  | Omodu => Val.modu arg1 arg2
  | Oand => Some (Val.and arg1 arg2)
  | Oor => Some (Val.or arg1 arg2)
  | Oxor => Some (Val.xor arg1 arg2)
  | Oshl => Some (Val.shl arg1 arg2)
  | Oshr => Some (Val.shr arg1 arg2)
  | Oshru => Some (Val.shru arg1 arg2)
  | Oaddf => Some (Val.addf arg1 arg2)
  | Osubf => Some (Val.subf arg1 arg2)
  | Omulf => Some (Val.mulf arg1 arg2)
  | Odivf => Some (Val.divf arg1 arg2)
  | Oaddl => Some (Val.addl arg1 arg2)
  | Osubl => Some (Val.subl arg1 arg2)
  | Omull => Some (Val.mull arg1 arg2)
  | Odivl => Val.divls arg1 arg2
  | Odivlu => Val.divlu arg1 arg2
  | Omodl => Val.modls arg1 arg2
  | Omodlu => Val.modlu arg1 arg2
  | Oandl => Some (Val.andl arg1 arg2)
  | Oorl => Some (Val.orl arg1 arg2)
  | Oxorl => Some (Val.xorl arg1 arg2)
  | Oshll => Some (Val.shll arg1 arg2)
  | Oshrl => Some (Val.shrl arg1 arg2)
  | Oshrlu => Some (Val.shrlu arg1 arg2)
  | Ocmp c => Some (Val.cmp c arg1 arg2)
  | Ocmpu c => Some (Val.cmpu (Mem.valid_pointer m) c arg1 arg2)
  | Ocmpf c => Some (Val.cmpf c arg1 arg2)
  | Ocmpl c => Val.cmpl c arg1 arg2
  | Ocmplu c => Val.cmplu c arg1 arg2
  end.

Section EVAL_EXPR.

Variable sp: val.
Variable e: env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      PTree.get id e = Some v ->
      eval_expr (Evar id) v
  | eval_Econst: forall cst v,
      eval_constant sp cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk addr vaddr v,
      eval_expr addr vaddr ->
      Mem.loadv chunk m vaddr = Some v ->
      eval_expr (Eload chunk addr) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k sp e m,
      step (State f Sskip (Kseq s k) sp e m)
        E0 (State f s k sp e m)
  | step_skip_block: forall f k sp e m,
      step (State f Sskip (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f Sskip k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef k m')

  | step_assign: forall f id a k sp e m v,
      eval_expr sp e m a v ->
      step (State f (Sassign id a) k sp e m)
        E0 (State f Sskip k sp (PTree.set id v e) m)

  | step_store: forall f chunk addr a k sp e m vaddr v m',
      eval_expr sp e m addr vaddr ->
      eval_expr sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k sp e m)
        E0 (State f Sskip k sp e m')

  | step_call: forall f optid sig a bl k sp e m vf vargs fd,
      eval_expr sp e m a vf ->
      eval_exprlist sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k sp e m)
        E0 (Callstate fd vargs (Kcall optid f sp e k) m)

  | step_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      eval_expr (Vptr sp Int.zero) e m a vf ->
      eval_exprlist (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Stailcall sig a bl) k (Vptr sp Int.zero) e m)
        E0 (Callstate fd vargs (call_cont k) m')

  | step_builtin: forall f optid ef bl k sp e m vargs t vres m',
      eval_exprlist sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k sp e m)
         t (State f Sskip k sp (set_optvar optid vres e) m')

  | step_seq: forall f s1 s2 k sp e m,
      step (State f (Sseq s1 s2) k sp e m)
        E0 (State f s1 (Kseq s2 k) sp e m)

  | step_ifthenelse: forall f a s1 s2 k sp e m v b,
      eval_expr sp e m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k sp e m)
        E0 (State f (if b then s1 else s2) k sp e m)

  | step_loop: forall f s k sp e m,
      step (State f (Sloop s) k sp e m)
        E0 (State f s (Kseq (Sloop s) k) sp e m)

  | step_block: forall f s k sp e m,
      step (State f (Sblock s) k sp e m)
        E0 (State f s (Kblock k) sp e m)

  | step_exit_seq: forall f n s k sp e m,
      step (State f (Sexit n) (Kseq s k) sp e m)
        E0 (State f (Sexit n) k sp e m)
  | step_exit_block_0: forall f k sp e m,
      step (State f (Sexit O) (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_exit_block_S: forall f n k sp e m,
      step (State f (Sexit (S n)) (Kblock k) sp e m)
        E0 (State f (Sexit n) k sp e m)

  | step_switch: forall f a cases default k sp e m n,
      eval_expr sp e m a (Vint n) ->
      step (State f (Sswitch a cases default) k sp e m)
        E0 (State f (Sexit (switch_target n default cases)) k sp e m)

  | step_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn None) k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k sp e m v m',
      eval_expr (Vptr sp Int.zero) e m a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn (Some a)) k (Vptr sp Int.zero) e m)
        E0 (Returnstate v (call_cont k) m')

  | step_label: forall f lbl s k sp e m,
      step (State f (Slabel lbl s) k sp e m)
        E0 (State f s k sp e m)

  | step_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k sp e m)
        E0 (State f s' k' sp e m)

  | step_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k (Vptr sp Int.zero) e m')
  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f sp e k m,
      step (Returnstate v (Kcall optid f sp e k) m)
        E0 (State f Sskip k sp (set_optvar optid v e) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p).

Lemma semantics_receptive:
  forall (p: program), receptive (semantics p).

Inductive outcome: Type :=
  | Out_normal: outcome                
  | Out_exit: nat -> outcome           
  | Out_return: option val -> outcome  
  | Out_tailcall_return: val -> outcome. 

Definition outcome_block (out: outcome) : outcome :=
  match out with
  | Out_exit O => Out_normal
  | Out_exit (S n) => Out_exit n
  | out => out
  end.

Definition outcome_result_value
    (out: outcome) (retsig: option typ) (vres: val) : Prop :=
  match out with
  | Out_normal => vres = Vundef
  | Out_return None => vres = Vundef
  | Out_return (Some v) => retsig <> None /\ vres = v
  | Out_tailcall_return v => vres = v
  | _ => False
  end.

Definition outcome_free_mem
    (out: outcome) (m: mem) (sp: block) (sz: Z) (m': mem) :=
  match out with
  | Out_tailcall_return _ => m' = m
  | _ => Mem.free m sp 0 sz = Some m'
  end.

Section NATURALSEM.

Variable ge: genv.

Inductive eval_funcall:
        mem -> fundef -> list val -> trace ->
        mem -> val -> Prop :=
  | eval_funcall_internal:
      forall m f vargs m1 sp e t e2 m2 out vres m3,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      exec_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t e2 m2 out ->
      outcome_result_value out f.(fn_sig).(sig_res) vres ->
      outcome_free_mem out m2 sp f.(fn_stackspace) m3 ->
      eval_funcall m (Internal f) vargs t m3 vres
  | eval_funcall_external:
      forall ef m args t res m',
      external_call ef ge args m t res m' ->
      eval_funcall m (External ef) args t m' res

with exec_stmt:
         function -> val ->
         env -> mem -> stmt -> trace ->
         env -> mem -> outcome -> Prop :=
  | exec_Sskip:
      forall f sp e m,
      exec_stmt f sp e m Sskip E0 e m Out_normal
  | exec_Sassign:
      forall f sp e m id a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sassign id a) E0 (PTree.set id v e) m Out_normal
  | exec_Sstore:
      forall f sp e m chunk addr a vaddr v m',
      eval_expr ge sp e m addr vaddr ->
      eval_expr ge sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      exec_stmt f sp e m (Sstore chunk addr a) E0 e m' Out_normal
  | exec_Scall:
      forall f sp e m optid sig a bl vf vargs fd t m' vres e',
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      eval_funcall m fd vargs t m' vres ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Scall optid sig a bl) t e' m' Out_normal
  | exec_Sbuiltin:
      forall f sp e m optid ef bl t m' vargs vres e',
      eval_exprlist ge sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Sbuiltin optid ef bl) t e' m' Out_normal
  | exec_Sifthenelse:
      forall f sp e m a s1 s2 v b t e' m' out,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      exec_stmt f sp e m (if b then s1 else s2) t e' m' out ->
      exec_stmt f sp e m (Sifthenelse a s1 s2) t e' m' out
  | exec_Sseq_continue:
      forall f sp e m t s1 t1 e1 m1 s2 t2 e2 m2 out,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 s2 t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sseq s1 s2) t e2 m2 out
  | exec_Sseq_stop:
      forall f sp e m t s1 s2 e1 m1 out,
      exec_stmt f sp e m s1 t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sseq s1 s2) t e1 m1 out
  | exec_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2 e2 m2 out,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 (Sloop s) t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sloop s) t e2 m2 out
  | exec_Sloop_stop:
      forall f sp e m t s e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sloop s) t e1 m1 out
  | exec_Sblock:
      forall f sp e m s t e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      exec_stmt f sp e m (Sblock s) t e1 m1 (outcome_block out)
  | exec_Sexit:
      forall f sp e m n,
      exec_stmt f sp e m (Sexit n) E0 e m (Out_exit n)
  | exec_Sswitch:
      forall f sp e m a cases default n,
      eval_expr ge sp e m a (Vint n) ->
      exec_stmt f sp e m (Sswitch a cases default)
                E0 e m (Out_exit (switch_target n default cases))
  | exec_Sreturn_none:
      forall f sp e m,
      exec_stmt f sp e m (Sreturn None) E0 e m (Out_return None)
  | exec_Sreturn_some:
      forall f sp e m a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sreturn (Some a)) E0 e m (Out_return (Some v))
  | exec_Stailcall:
      forall f sp e m sig a bl vf vargs fd t m' m'' vres,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      eval_funcall m' fd vargs t m'' vres ->
      exec_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t e m'' (Out_tailcall_return vres).

Scheme eval_funcall_ind2 := Minimality for eval_funcall Sort Prop
  with exec_stmt_ind2 := Minimality for exec_stmt Sort Prop.
Combined Scheme eval_funcall_exec_stmt_ind2
  from eval_funcall_ind2, exec_stmt_ind2.

CoInductive evalinf_funcall:
        mem -> fundef -> list val -> traceinf -> Prop :=
  | evalinf_funcall_internal:
      forall m f vargs m1 sp e t,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      execinf_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t ->
      evalinf_funcall m (Internal f) vargs t

with execinf_stmt:
         function -> val -> env -> mem -> stmt -> traceinf -> Prop :=
  | execinf_Scall:
      forall f sp e m optid sig a bl vf vargs fd t,
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      evalinf_funcall m fd vargs t ->
      execinf_stmt f sp e m (Scall optid sig a bl) t
  | execinf_Sifthenelse:
      forall f sp e m a s1 s2 v b t,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      execinf_stmt f sp e m (if b then s1 else s2) t ->
      execinf_stmt f sp e m (Sifthenelse a s1 s2) t
  | execinf_Sseq_1:
      forall f sp e m t s1 s2,
      execinf_stmt f sp e m s1 t ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sseq_2:
      forall f sp e m t s1 t1 e1 m1 s2 t2,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 s2 t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sloop_body:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 (Sloop s) t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sblock:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sblock s) t
  | execinf_Stailcall:
      forall f sp e m sig a bl vf vargs fd m' t,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      evalinf_funcall m' fd vargs t ->
      execinf_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t.

End NATURALSEM.

Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
  | bigstep_program_terminates_intro:
      forall b f m0 t m r,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      eval_funcall ge m0 f nil t m (Vint r) ->
      bigstep_program_terminates p t r.

Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
  | bigstep_program_diverges_intro:
      forall b f m0 t,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      evalinf_funcall ge m0 f nil t ->
      bigstep_program_diverges p t.

Definition bigstep_semantics (p: program) :=
  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).

Section BIGSTEP_TO_TRANSITION.

Variable prog: program.
Let ge := Genv.globalenv prog.

Inductive outcome_state_match
        (sp: val) (e: env) (m: mem) (f: function) (k: cont):
        outcome -> state -> Prop :=
  | osm_normal:
      outcome_state_match sp e m f k
                          Out_normal
                          (State f Sskip k sp e m)
  | osm_exit: forall n,
      outcome_state_match sp e m f k
                          (Out_exit n)
                          (State f (Sexit n) k sp e m)
  | osm_return_none: forall k',
      call_cont k' = call_cont k ->
      outcome_state_match sp e m f k
                          (Out_return None)
                          (State f (Sreturn None) k' sp e m)
  | osm_return_some: forall k' a v,
      call_cont k' = call_cont k ->
      eval_expr ge sp e m a v ->
      outcome_state_match sp e m f k
                          (Out_return (Some v))
                          (State f (Sreturn (Some a)) k' sp e m)
  | osm_tail: forall v,
      outcome_state_match sp e m f k
                          (Out_tailcall_return v)
                          (Returnstate v (call_cont k) m).

Remark is_call_cont_call_cont:
  forall k, is_call_cont (call_cont k).

Remark call_cont_is_call_cont:
  forall k, is_call_cont k -> call_cont k = k.

Lemma eval_funcall_exec_stmt_steps:
  (forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m'))
/\(forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S).

Lemma eval_funcall_steps:
   forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m').
Proof (proj1 eval_funcall_exec_stmt_steps).

Lemma exec_stmt_steps:
   forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S.
Proof (proj2 eval_funcall_exec_stmt_steps).

Lemma evalinf_funcall_forever:
  forall m fd args T k,
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.

Theorem bigstep_semantics_sound:
  bigstep_sound (bigstep_semantics prog) (semantics prog).

End BIGSTEP_TO_TRANSITION. *)

Require Import Csharpminor.
(* Csharpminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Cminor.
Require Import Smallstep.

Inductive constant : Type :=
  | Ointconst: int -> constant          
  | Ofloatconst: float -> constant      
  | Olongconst: int64 -> constant.      

Definition unary_operation : Type := Cminor.unary_operation.
Definition binary_operation : Type := Cminor.binary_operation.

Inductive expr : Type :=
  | Evar : ident -> expr                
  | Eaddrof : ident -> expr             
  | Econst : constant -> expr           
  | Eunop : unary_operation -> expr -> expr  
  | Ebinop : binary_operation -> expr -> expr -> expr 
  | Eload : memory_chunk -> expr -> expr. 

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sset : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> lbl_stmt -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt

with lbl_stmt : Type :=
  | LSdefault: stmt -> lbl_stmt
  | LScase: int -> stmt -> lbl_stmt -> lbl_stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list (ident * Z);
  fn_temps: list ident;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.

Definition program : Type := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t (block * Z).
Definition temp_env := PTree.t val.

Definition empty_env : env := PTree.empty (block * Z).
Definition empty_temp_env : temp_env := PTree.empty val.

Fixpoint create_undef_temps (temps: list ident) : temp_env :=
  match temps with
  | nil => PTree.empty val
  | id :: temps' => PTree.set id Vundef (create_undef_temps temps')
 end.

Fixpoint bind_parameters (formals: list ident) (args: list val)
                         (le: temp_env) : option temp_env :=
 match formals, args with
 | nil, nil => Some le
 | id :: xl, v :: vl => bind_parameters xl vl (PTree.set id v le)
 | _, _ => None
 end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> env -> temp_env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (e: env)                   
             (le: temp_env)             
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint select_switch (n: int) (sl: lbl_stmt) {struct sl} : lbl_stmt :=
  match sl with
  | LSdefault _ => sl
  | LScase c s sl' => if Int.eq c n then sl else select_switch n sl'
  end.

Fixpoint seq_of_lbl_stmt (sl: lbl_stmt) : stmt :=
  match sl with
  | LSdefault s => s
  | LScase c s sl' => Sseq s (seq_of_lbl_stmt sl')
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Sswitch a sl =>
      find_label_ls lbl sl k
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: lbl_stmt) (k: cont)
                   {struct sl}: option (stmt * cont) :=
  match sl with
  | LSdefault s => find_label lbl s k
  | LScase _ s sl' =>
      match find_label lbl s (Kseq (seq_of_lbl_stmt sl') k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Definition eval_constant (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  end.

Definition eval_unop := Cminor.eval_unop.

Definition eval_binop := Cminor.eval_binop.

Inductive alloc_variables: env -> mem ->
                           list (ident * Z) ->
                           env -> mem -> Prop :=
  | alloc_variables_nil:
      forall e m,
      alloc_variables e m nil e m
  | alloc_variables_cons:
      forall e m id sz vars m1 b1 m2 e2,
      Mem.alloc m 0 sz = (m1, b1) ->
      alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2 ->
      alloc_variables e m ((id, sz) :: vars) e2 m2.

Definition block_of_binding (id_b_sz: ident * (block * Z)) :=
  match id_b_sz with (id, (b, sz)) => (b, 0, sz) end.

Definition blocks_of_env (e: env) : list (block * Z * Z) :=
  List.map block_of_binding (PTree.elements e).

Section RELSEM.

Variable ge: genv.

Inductive eval_var_addr: env -> ident -> block -> Prop :=
  | eval_var_addr_local:
      forall e id b sz,
      PTree.get id e = Some (b, sz) ->
      eval_var_addr e id b
  | eval_var_addr_global:
      forall e id b,
      PTree.get id e = None ->
      Genv.find_symbol ge id = Some b ->
      eval_var_addr e id b.

Section EVAL_EXPR.

Variable e: env.
Variable le: temp_env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      le!id = Some v ->
      eval_expr (Evar id) v
  | eval_Eaddrof: forall id b,
      eval_var_addr e id b ->
      eval_expr (Eaddrof id) (Vptr b Int.zero)
  | eval_Econst: forall cst v,
      eval_constant cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk a v1 v,
      eval_expr a v1 ->
      Mem.loadv chunk m v1 = Some v ->
      eval_expr (Eload chunk a) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k e le m,
      step (State f Sskip (Kseq s k) e le m)
        E0 (State f s k e le m)
  | step_skip_block: forall f k e le m,
      step (State f Sskip (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f Sskip k e le m)
        E0 (Returnstate Vundef k m')

  | step_set: forall f id a k e le m v,
      eval_expr e le m a v ->
      step (State f (Sset id a) k e le m)
        E0 (State f Sskip k e (PTree.set id v le) m)

  | step_store: forall f chunk addr a k e le m vaddr v m',
      eval_expr e le m addr vaddr ->
      eval_expr e le m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k e le m)
        E0 (State f Sskip k e le m')

  | step_call: forall f optid sig a bl k e le m vf vargs fd,
      eval_expr e le m a vf ->
      eval_exprlist e le m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k e le m)
        E0 (Callstate fd vargs (Kcall optid f e le k) m)

  | step_builtin: forall f optid ef bl k e le m vargs t vres m',
      eval_exprlist e le m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k e le m)
         t (State f Sskip k e (Cminor.set_optvar optid vres le) m')

  | step_seq: forall f s1 s2 k e le m,
      step (State f (Sseq s1 s2) k e le m)
        E0 (State f s1 (Kseq s2 k) e le m)

  | step_ifthenelse: forall f a s1 s2 k e le m v b,
      eval_expr e le m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k e le m)
        E0 (State f (if b then s1 else s2) k e le m)

  | step_loop: forall f s k e le m,
      step (State f (Sloop s) k e le m)
        E0 (State f s (Kseq (Sloop s) k) e le m)

  | step_block: forall f s k e le m,
      step (State f (Sblock s) k e le m)
        E0 (State f s (Kblock k) e le m)

  | step_exit_seq: forall f n s k e le m,
      step (State f (Sexit n) (Kseq s k) e le m)
        E0 (State f (Sexit n) k e le m)
  | step_exit_block_0: forall f k e le m,
      step (State f (Sexit O) (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_exit_block_S: forall f n k e le m,
      step (State f (Sexit (S n)) (Kblock k) e le m)
        E0 (State f (Sexit n) k e le m)

  | step_switch: forall f a cases k e le m n,
      eval_expr e le m a (Vint n) ->
      step (State f (Sswitch a cases) k e le m)
        E0 (State f (seq_of_lbl_stmt (select_switch n cases)) k e le m)

  | step_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn None) k e le m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k e le m v m',
      eval_expr e le m a v ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn (Some a)) k e le m)
        E0 (Returnstate v (call_cont k) m')
  | step_label: forall f lbl s k e le m,
      step (State f (Slabel lbl s) k e le m)
        E0 (State f s k e le m)

  | step_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k e le m)
        E0 (State f s' k' e le m)

  | step_internal_function: forall f vargs k m m1 e le,
      list_norepet (map fst f.(fn_vars)) ->
      list_norepet f.(fn_params) ->
      list_disjoint f.(fn_params) f.(fn_temps) ->
      alloc_variables empty_env m (fn_vars f) e m1 ->
      bind_parameters f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k e le m1)

  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f e le k m,
      step (Returnstate v (Kcall optid f e le k) m)
        E0 (State f Sskip k e (Cminor.set_optvar optid v le) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p). *)

Require Import Cshmgen.
(* Cshmgen:
Require Import Coqlib.
Require Import Errors.
Require Import Integers.
Require Import Floats.
Require Import AST.
Require Import Ctypes.
Require Import Cop.
Require Import Clight.
Require Import Cminor.
Require Import Csharpminor.

Open Local Scope string_scope.
Open Local Scope error_monad_scope.

Definition make_intconst (n: int) :=  Econst (Ointconst n).

Definition make_floatconst (f: float) :=  Econst (Ofloatconst f).

Definition make_longconst (f: int64) :=  Econst (Olongconst f).

Definition make_floatofint (e: expr) (sg: signedness) (sz: floatsize) :=
  match sg, sz with
  | Signed, F64 => Eunop Ofloatofint e
  | Unsigned, F64 => Eunop Ofloatofintu e
  | Signed, F32 => Eunop Osingleoffloat (Eunop Ofloatofint e)
  | Unsigned, F32 => Eunop Osingleoffloat (Eunop Ofloatofintu e)
  end.

Definition make_intoffloat (e: expr) (sg: signedness) :=
  match sg with
  | Signed => Eunop Ointoffloat e
  | Unsigned => Eunop Ointuoffloat e
  end.

Definition make_longofint (e: expr) (sg: signedness) :=
  match sg with
  | Signed => Eunop Olongofint e
  | Unsigned => Eunop Olongofintu e
  end.

Definition make_floatoflong (e: expr) (sg: signedness) (sz: floatsize) :=
  match sg, sz with
  | Signed, F64 => Eunop Ofloatoflong e
  | Unsigned, F64 => Eunop Ofloatoflongu e
  | Signed, F32 => Eunop Osingleoflong e
  | Unsigned, F32 => Eunop Osingleoflongu e
  end.

Definition make_longoffloat (e: expr) (sg: signedness) :=
  match sg with
  | Signed => Eunop Olongoffloat e
  | Unsigned => Eunop Olonguoffloat e
  end.

Definition make_cmp_ne_zero (e: expr) :=
  match e with
  | Ebinop (Ocmp c) e1 e2 => e
  | Ebinop (Ocmpu c) e1 e2 => e
  | Ebinop (Ocmpf c) e1 e2 => e
  | Ebinop (Ocmpl c) e1 e2 => e
  | Ebinop (Ocmplu c) e1 e2 => e
  | _ => Ebinop (Ocmp Cne) e (make_intconst Int.zero)
  end.

Definition make_cast_int (e: expr) (sz: intsize) (si: signedness) :=
  match sz, si with
  | I8, Signed => Eunop Ocast8signed e
  | I8, Unsigned => Eunop Ocast8unsigned e
  | I16, Signed => Eunop Ocast16signed e
  | I16, Unsigned => Eunop Ocast16unsigned e
  | I32, _ => e
  | IBool, _ => make_cmp_ne_zero e
  end.

Definition make_cast_float (e: expr) (sz: floatsize) :=
  match sz with
  | F32 => Eunop Osingleoffloat e
  | F64 => e
  end.

Definition make_cast (from to: type) (e: expr) :=
  match classify_cast from to with
  | cast_case_neutral => OK e
  | cast_case_i2i sz2 si2 => OK (make_cast_int e sz2 si2)
  | cast_case_f2f sz2 => OK (make_cast_float e sz2)
  | cast_case_i2f si1 sz2 => OK (make_floatofint e si1 sz2)
  | cast_case_f2i sz2 si2 => OK (make_cast_int (make_intoffloat e si2) sz2 si2)
  | cast_case_l2l => OK e
  | cast_case_i2l si1 => OK (make_longofint e si1)
  | cast_case_l2i sz2 si2 => OK (make_cast_int (Eunop Ointoflong e) sz2 si2)
  | cast_case_l2f si1 sz2 => OK (make_floatoflong e si1 sz2)
  | cast_case_f2l si2 => OK (make_longoffloat e si2)
  | cast_case_f2bool => OK (Ebinop (Ocmpf Cne) e (make_floatconst Float.zero))
  | cast_case_l2bool => OK (Ebinop (Ocmpl Cne) e (make_longconst Int64.zero))
  | cast_case_p2bool => OK (Ebinop (Ocmpu Cne) e (make_intconst Int.zero))
  | cast_case_struct id1 fld1 id2 fld2 => OK e
  | cast_case_union id1 fld1 id2 fld2 => OK e
  | cast_case_void => OK e
  | cast_case_default => Error (msg "Cshmgen.make_cast")
  end.

Definition make_boolean (e: expr) (ty: type) :=
  match classify_bool ty with
  | bool_case_i => make_cmp_ne_zero e
  | bool_case_f => Ebinop (Ocmpf Cne) e (make_floatconst Float.zero)
  | bool_case_p => Ebinop (Ocmpu Cne) e (make_intconst Int.zero)
  | bool_case_l => Ebinop (Ocmpl Cne) e (make_longconst Int64.zero)
  | bool_default => e   
  end.

Definition make_notbool (e: expr) (ty: type) :=
  match classify_bool ty with
  | bool_case_i => OK (Ebinop (Ocmp Ceq) e (make_intconst Int.zero))
  | bool_case_f => OK (Ebinop (Ocmpf Ceq) e (make_floatconst Float.zero))
  | bool_case_p => OK (Ebinop (Ocmpu Ceq) e (make_intconst Int.zero))
  | bool_case_l => OK (Ebinop (Ocmpl Ceq) e (make_longconst Int64.zero))
  | _ => Error (msg "Cshmgen.make_notbool")
  end.

Definition make_neg (e: expr) (ty: type) :=
  match classify_neg ty with
  | neg_case_i _ => OK (Eunop Onegint e)
  | neg_case_f => OK (Eunop Onegf e)
  | neg_case_l _ => OK (Eunop Onegl e)
  | _ => Error (msg "Cshmgen.make_neg")
  end.

Definition make_notint (e: expr) (ty: type) :=
  match classify_notint ty with
  | notint_case_i _ => OK (Eunop Onotint e)
  | notint_case_l _ => OK (Eunop Onotl e)
  | _ => Error (msg "Cshmgen.make_notint")
  end.

Definition make_binarith (iop iopu fop lop lopu: binary_operation)
                         (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  let c := classify_binarith ty1 ty2 in
  let ty := binarith_type c in
  do e1' <- make_cast ty1 ty e1;
  do e2' <- make_cast ty2 ty e2;
  match c with
  | bin_case_i Signed => OK (Ebinop iop e1' e2')
  | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')
  | bin_case_f => OK (Ebinop fop e1' e2')
  | bin_case_l Signed => OK (Ebinop lop e1' e2')
  | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')
  | bin_default => Error (msg "Cshmgen.make_binarith")
  end.

Definition make_add (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  match classify_add ty1 ty2 with
  | add_case_pi ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Oadd e1 (Ebinop Omul n e2))
  | add_case_ip ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Oadd e2 (Ebinop Omul n e1))
  | add_case_pl ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Oadd e1 (Ebinop Omul n (Eunop Ointoflong e2)))
  | add_case_lp ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Oadd e2 (Ebinop Omul n (Eunop Ointoflong e1)))
  | add_default =>
      make_binarith Oadd Oadd Oaddf Oaddl Oaddl e1 ty1 e2 ty2
  end.

Definition make_sub (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  match classify_sub ty1 ty2 with
  | sub_case_pi ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Osub e1 (Ebinop Omul n e2))
  | sub_case_pp ty =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Odivu (Ebinop Osub e1 e2) n)
  | sub_case_pl ty _ =>
      let n := make_intconst (Int.repr (Ctypes.sizeof ty)) in
      OK (Ebinop Osub e1 (Ebinop Omul n (Eunop Ointoflong e2)))
  | sub_default =>
      make_binarith Osub Osub Osubf Osubl Osubl e1 ty1 e2 ty2
  end.

Definition make_mul (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith Omul Omul Omulf Omull Omull e1 ty1 e2 ty2.

Definition make_div (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith Odiv Odivu Odivf Odivl Odivlu e1 ty1 e2 ty2.

Definition make_binarith_int (iop iopu lop lopu: binary_operation)
                             (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  let c := classify_binarith ty1 ty2 in
  let ty := binarith_type c in
  do e1' <- make_cast ty1 ty e1;
  do e2' <- make_cast ty2 ty e2;
  match c with
  | bin_case_i Signed => OK (Ebinop iop e1' e2')
  | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')
  | bin_case_l Signed => OK (Ebinop lop e1' e2')
  | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')
  | bin_case_f | bin_default => Error (msg "Cshmgen.make_binarith_int")
  end.

Definition make_mod (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith_int Omod Omodu Omodl Omodlu e1 ty1 e2 ty2.

Definition make_and (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith_int Oand Oand Oandl Oandl e1 ty1 e2 ty2.

Definition make_or (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith_int Oor Oor Oorl Oorl e1 ty1 e2 ty2.

Definition make_xor (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  make_binarith_int Oxor Oxor Oxorl Oxorl e1 ty1 e2 ty2.

Definition make_shl (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  match classify_shift ty1 ty2 with
  | shift_case_ii _ => OK (Ebinop Oshl e1 e2)
  | shift_case_li _ => OK (Ebinop Oshll e1 e2)
  | shift_case_il _ => OK (Ebinop Oshl e1 (Eunop Ointoflong e2))
  | shift_case_ll _ => OK (Ebinop Oshll e1 (Eunop Ointoflong e2))
  | shift_default => Error (msg "Cshmgen.make_shl")
  end.

Definition make_shr (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  match classify_shift ty1 ty2 with
  | shift_case_ii Signed => OK (Ebinop Oshr e1 e2)
  | shift_case_ii Unsigned => OK (Ebinop Oshru e1 e2)
  | shift_case_li Signed => OK (Ebinop Oshrl e1 e2)
  | shift_case_li Unsigned => OK (Ebinop Oshrlu e1 e2)
  | shift_case_il Signed => OK (Ebinop Oshr e1 (Eunop Ointoflong e2))
  | shift_case_il Unsigned => OK (Ebinop Oshru e1 (Eunop Ointoflong e2))
  | shift_case_ll Signed => OK (Ebinop Oshrl e1 (Eunop Ointoflong e2))
  | shift_case_ll Unsigned => OK (Ebinop Oshrlu e1 (Eunop Ointoflong e2))
  | shift_default => Error (msg "Cshmgen.make_shr")
  end.

Definition make_cmp (c: comparison) (e1: expr) (ty1: type) (e2: expr) (ty2: type) :=
  match classify_cmp ty1 ty2 with
  | cmp_case_pp => OK (Ebinop (Ocmpu c) e1 e2)
  | cmp_case_pl => OK (Ebinop (Ocmpu c) e1 (Eunop Ointoflong e2))
  | cmp_case_lp => OK (Ebinop (Ocmpu c) (Eunop Ointoflong e1) e2)
  | cmp_default =>
      make_binarith (Ocmp c) (Ocmpu c) (Ocmpf c) (Ocmpl c) (Ocmplu c) e1 ty1 e2 ty2
  end.

Definition make_load (addr: expr) (ty_res: type) :=
  match (access_mode ty_res) with
  | By_value chunk => OK (Eload chunk addr)
  | By_reference => OK addr
  | By_copy => OK addr
  | By_nothing => Error (msg "Cshmgen.make_load")
  end.

Definition make_memcpy (dst src: expr) (ty: type) :=
  Sbuiltin None (EF_memcpy (Ctypes.sizeof ty) (Ctypes.alignof_blockcopy ty))
                (dst :: src :: nil).

Definition make_store (addr: expr) (ty: type) (rhs: expr) :=
  match access_mode ty with
  | By_value chunk => OK (Sstore chunk addr rhs)
  | By_copy => OK (make_memcpy addr rhs ty)
  | _ => Error (msg "Cshmgen.make_store")
  end.

Definition transl_unop (op: Cop.unary_operation) (a: expr) (ta: type) : res expr :=
  match op with
  | Cop.Onotbool => make_notbool a ta
  | Cop.Onotint => make_notint a ta
  | Cop.Oneg => make_neg a ta
  end.

Definition transl_binop (op: Cop.binary_operation)
                        (a: expr) (ta: type)
                        (b: expr) (tb: type) : res expr :=
  match op with
  | Cop.Oadd => make_add a ta b tb
  | Cop.Osub => make_sub a ta b tb
  | Cop.Omul => make_mul a ta b tb
  | Cop.Odiv => make_div a ta b tb
  | Cop.Omod => make_mod a ta b tb
  | Cop.Oand => make_and a ta b tb
  | Cop.Oor  => make_or a ta b tb
  | Cop.Oxor => make_xor a ta b tb
  | Cop.Oshl => make_shl a ta b tb
  | Cop.Oshr => make_shr a ta b tb
  | Cop.Oeq => make_cmp Ceq a ta b tb
  | Cop.One => make_cmp Cne a ta b tb
  | Cop.Olt => make_cmp Clt a ta b tb
  | Cop.Ogt => make_cmp Cgt a ta b tb
  | Cop.Ole => make_cmp Cle a ta b tb
  | Cop.Oge => make_cmp Cge a ta b tb
  end.

Fixpoint transl_expr (a: Clight.expr) {struct a} : res expr :=
  match a with
  | Clight.Econst_int n _ =>
      OK(make_intconst n)
  | Clight.Econst_float n _ =>
      OK(make_floatconst n)
  | Clight.Econst_long n _ =>
      OK(make_longconst n)
  | Clight.Evar id ty =>
      make_load (Eaddrof id) ty
  | Clight.Etempvar id ty =>
      OK(Evar id)
  | Clight.Ederef b ty =>
      do tb <- transl_expr b;
      make_load tb ty
  | Clight.Eaddrof b _ =>
      transl_lvalue b
  | Clight.Eunop op b _ =>
      do tb <- transl_expr b;
      transl_unop op tb (typeof b)
  | Clight.Ebinop op b c _ =>
      do tb <- transl_expr b;
      do tc <- transl_expr c;
      transl_binop op tb (typeof b) tc (typeof c)
  | Clight.Ecast b ty =>
      do tb <- transl_expr b;
      make_cast (typeof b) ty tb
  | Clight.Efield b i ty =>
      match typeof b with
      | Tstruct _ fld _ =>
          do tb <- transl_expr b;
          do ofs <- field_offset i fld;
          make_load
            (Ebinop Oadd tb (make_intconst (Int.repr ofs)))
            ty
      | Tunion _ fld _ =>
          do tb <- transl_expr b;
          make_load tb ty
      | _ =>
          Error(msg "Cshmgen.transl_expr(field)")
      end
  end

with transl_lvalue (a: Clight.expr) {struct a} : res expr :=
  match a with
  | Clight.Evar id _ =>
      OK (Eaddrof id)
  | Clight.Ederef b _ =>
      transl_expr b
  | Clight.Efield b i ty =>
      match typeof b with
      | Tstruct _ fld _ =>
          do tb <- transl_expr b;
          do ofs <- field_offset i fld;
          OK (Ebinop Oadd tb (make_intconst (Int.repr ofs)))
      | Tunion _ fld _ =>
          transl_expr b
      | _ =>
          Error(msg "Cshmgen.transl_lvalue(field)")
      end
  | _ =>
      Error(msg "Cshmgen.transl_lvalue")
  end.

Fixpoint transl_arglist (al: list Clight.expr) (tyl: typelist)
                         {struct al}: res (list expr) :=
  match al, tyl with
  | nil, Tnil => OK nil
  | a1 :: a2, Tcons ty1 ty2 =>
      do ta1 <- transl_expr a1;
      do ta1' <- make_cast (typeof a1) ty1 ta1;
      do ta2 <- transl_arglist a2 ty2;
      OK (ta1' :: ta2)
  | _, _ =>
      Error(msg "Cshmgen.transl_arglist: arity mismatch")
  end.

Fixpoint transl_statement (tyret: type) (nbrk ncnt: nat)
                          (s: Clight.statement) {struct s} : res stmt :=
  match s with
  | Clight.Sskip =>
      OK Sskip
  | Clight.Sassign b c =>
      do tb <- transl_lvalue b;
      do tc <- transl_expr c;
      do tc' <- make_cast (typeof c) (typeof b) tc;
      make_store tb (typeof b) tc'
  | Clight.Sset x b =>
      do tb <- transl_expr b;
      OK(Sset x tb)
  | Clight.Scall x b cl =>
      match classify_fun (typeof b) with
      | fun_case_f args res =>
          do tb <- transl_expr b;
          do tcl <- transl_arglist cl args;
          OK(Scall x (signature_of_type args res) tb tcl)
      | _ => Error(msg "Cshmgen.transl_stmt(call)")
      end
  | Clight.Sbuiltin x ef tyargs bl =>
      do tbl <- transl_arglist bl tyargs;
      OK(Sbuiltin x ef tbl)
  | Clight.Ssequence s1 s2 =>
      do ts1 <- transl_statement tyret nbrk ncnt s1;
      do ts2 <- transl_statement tyret nbrk ncnt s2;
      OK (Sseq ts1 ts2)
  | Clight.Sifthenelse e s1 s2 =>
      do te <- transl_expr e;
      do ts1 <- transl_statement tyret nbrk ncnt s1;
      do ts2 <- transl_statement tyret nbrk ncnt s2;
      OK (Sifthenelse (make_boolean te (typeof e)) ts1 ts2)
  | Clight.Sloop s1 s2 =>
      do ts1 <- transl_statement tyret 1%nat 0%nat s1;
      do ts2 <- transl_statement tyret 0%nat (S ncnt) s2;
      OK (Sblock (Sloop (Sseq (Sblock ts1) ts2)))
  | Clight.Sbreak =>
      OK (Sexit nbrk)
  | Clight.Scontinue =>
      OK (Sexit ncnt)
  | Clight.Sreturn (Some e) =>
      do te <- transl_expr e;
      do te' <- make_cast (typeof e) tyret te;
      OK (Sreturn (Some te'))
  | Clight.Sreturn None =>
      OK (Sreturn None)
  | Clight.Sswitch a sl =>
      do ta <- transl_expr a;
      do tsl <- transl_lbl_stmt tyret 0%nat (S ncnt) sl;
      OK (Sblock (Sswitch ta tsl))
  | Clight.Slabel lbl s =>
      do ts <- transl_statement tyret nbrk ncnt s;
      OK (Slabel lbl ts)
  | Clight.Sgoto lbl =>
      OK (Sgoto lbl)
  end

with transl_lbl_stmt (tyret: type) (nbrk ncnt: nat)
                     (sl: Clight.labeled_statements)
                     {struct sl}: res lbl_stmt :=
  match sl with
  | Clight.LSdefault s =>
      do ts <- transl_statement tyret nbrk ncnt s;
      OK (LSdefault ts)
  | Clight.LScase n s sl' =>
      do ts <- transl_statement tyret nbrk ncnt s;
      do tsl' <- transl_lbl_stmt tyret nbrk ncnt sl';
      OK (LScase n ts tsl')
  end.

Definition transl_var (v: ident * type) := (fst v, sizeof (snd v)).

Definition signature_of_function (f: Clight.function) :=
  mksignature (map typ_of_type (map snd (Clight.fn_params f)))
              (opttyp_of_type (Clight.fn_return f)).

Definition transl_function (f: Clight.function) : res function :=
  do tbody <- transl_statement f.(Clight.fn_return) 1%nat 0%nat (Clight.fn_body f);
  OK (mkfunction
       (signature_of_function f)
       (map fst (Clight.fn_params f))
       (map transl_var (Clight.fn_vars f))
       (map fst (Clight.fn_temps f))
       tbody).

Definition transl_fundef (f: Clight.fundef) : res fundef :=
  match f with
  | Clight.Internal g =>
      do tg <- transl_function g; OK(AST.Internal tg)
  | Clight.External ef args res =>
      if list_typ_eq (sig_args (ef_sig ef)) (typlist_of_typelist args)
      && opt_typ_eq (sig_res (ef_sig ef)) (opttyp_of_type res)
      then OK(AST.External ef)
      else Error(msg "Cshmgen.transl_fundef: wrong external signature")
  end.

Definition transl_globvar (ty: type) := OK tt.

Definition transl_program (p: Clight.program) : res program :=
  transform_partial_program2 transl_fundef transl_globvar p. *)



Require Import Clight_coop.
(* Clight_coop:
Require Import Coqlib.
Require Import Errors.
Require Import Maps.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import AST.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Ctypes.
Require Import Cop.

Require Import Clight.
Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.

Inductive CL_core: Type :=
  | CL_State
      (f: function)
      (s: statement)
      (k: cont)
      (e: env)
      (le: temp_env): CL_core
  | CL_Callstate
      (fd: fundef)
      (args: list val)
      (k: cont): CL_core
  | CL_Returnstate
      (res: val)
      (k: cont): CL_core.

Definition CL_at_external (c: CL_core) : option (external_function * signature * list val) :=
  match c with
  | CL_State _ _ _ _ _ => None
  | CL_Callstate fd args k => match fd with
                                  Internal f => None
                                | External ef targs tres => Some (ef, ef_sig ef, args)
                              end
  | CL_Returnstate v k => None
 end.

Definition CL_after_external (rv: option val) (c: CL_core) : option CL_core :=
  match c with
     CL_Callstate fd vargs k =>
        match fd with
          Internal _ => None
        | External ef tps tp =>
            match rv with
              Some v => Some(CL_Returnstate v k)
            | None  => Some(CL_Returnstate Vundef k)
            end
        end
   | _ => None
  end.

Definition CL_halted (q : CL_core): option val :=
    match q with
       CL_Returnstate v Kstop => Some v
     | _ => None
    end.

Section SEMANTICS.
Variable function_entry: function -> list val -> mem -> env -> temp_env -> mem -> Prop.

Variable ge: genv.
Inductive clight_corestep: CL_core -> mem-> CL_core -> mem -> Prop :=

  | clight_corestep_assign:   forall f a1 a2 k e le m loc ofs v2 v m',
      eval_lvalue ge e le m a1 loc ofs ->
      eval_expr ge e le m a2 v2 ->
      sem_cast v2 (typeof a2) (typeof a1) = Some v ->
      assign_loc (typeof a1) m loc ofs v m' ->
      clight_corestep (CL_State f (Sassign a1 a2) k e le) m
        (CL_State f Sskip k e le) m'

  | clight_corestep_set:   forall f id a k e le m v,
      eval_expr ge e le m a v ->
      clight_corestep (CL_State f (Sset id a) k e le) m
        (CL_State f Sskip k e (PTree.set id v le)) m

  | clight_corestep_call:   forall f optid a al k e le m tyargs tyres vf vargs fd,
      classify_fun (typeof a) = fun_case_f tyargs tyres ->
      eval_expr ge e le m a vf ->
      eval_exprlist ge e le m al tyargs vargs ->
      Genv.find_funct ge vf = Some fd ->
      type_of_fundef fd = Tfunction tyargs tyres ->
      clight_corestep (CL_State f (Scall optid a al) k e le) m
        (CL_Callstate fd vargs (Kcall optid f e le k)) m

  | clight_corestep_seq:  forall f s1 s2 k e le m,
      clight_corestep (CL_State f (Ssequence s1 s2) k e le) m
        (CL_State f s1 (Kseq s2 k) e le) m
  | clight_corestep_skip_seq: forall f s k e le m,
      clight_corestep (CL_State f Sskip (Kseq s k) e le) m
        (CL_State f s k e le) m
  | clight_corestep_continue_seq: forall f s k e le m,
      clight_corestep (CL_State f Scontinue (Kseq s k) e le) m
        (CL_State f Scontinue k e le) m
  | clight_corestep_break_seq: forall f s k e le m,
      clight_corestep (CL_State f Sbreak (Kseq s k) e le) m
        (CL_State f Sbreak k e le) m

  | clight_corestep_ifthenelse:  forall f a s1 s2 k e le m v1 b,
      eval_expr ge e le m a v1 ->
      bool_val v1 (typeof a) = Some b ->
      clight_corestep (CL_State f (Sifthenelse a s1 s2) k e le) m
        (CL_State f (if b then s1 else s2) k e le) m

  | clight_corestep_loop: forall f s1 s2 k e le m,
      clight_corestep (CL_State f (Sloop s1 s2) k e le) m
        (CL_State f s1 (Kloop1 s1 s2 k) e le) m
  | clight_corestep_skip_or_continue_loop1:  forall f s1 s2 k e le m x,
      x = Sskip \/ x = Scontinue ->
      clight_corestep (CL_State f x (Kloop1 s1 s2 k) e le) m
        (CL_State f s2 (Kloop2 s1 s2 k) e le) m
  | clight_corestep_break_loop1:  forall f s1 s2 k e le m,
      clight_corestep (CL_State f Sbreak (Kloop1 s1 s2 k) e le) m
        (CL_State f Sskip k e le) m
  | clight_corestep_skip_loop2: forall f s1 s2 k e le m,
      clight_corestep (CL_State f Sskip (Kloop2 s1 s2 k) e le) m
        (CL_State f (Sloop s1 s2) k e le) m
  | clight_corestep_break_loop2: forall f s1 s2 k e le m,
      clight_corestep (CL_State f Sbreak (Kloop2 s1 s2 k) e le) m
        (CL_State f Sskip k e le) m

  | clight_corestep_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_corestep (CL_State f (Sreturn None) k e le) m
        (CL_Returnstate Vundef (call_cont k)) m'
  | clight_corestep_return_1: forall f a k e le m v v' m',
      eval_expr ge e le m a v ->
      sem_cast v (typeof a) f.(fn_return) = Some v' ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_corestep (CL_State f (Sreturn (Some a)) k e le) m
        (CL_Returnstate v' (call_cont k)) m'
  | clight_corestep_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_corestep (CL_State f Sskip k e le) m
        (CL_Returnstate Vundef k) m'

  | clight_corestep_switch: forall f a sl k e le m n,
      eval_expr ge e le m a (Vint n) ->
      clight_corestep (CL_State f (Sswitch a sl) k e le) m
        (CL_State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch k) e le) m
  | clight_corestep_skip_break_switch: forall f x k e le m,
      x = Sskip \/ x = Sbreak ->
      clight_corestep (CL_State f x (Kswitch k) e le) m
        (CL_State f Sskip k e le) m
  | clight_corestep_continue_switch: forall f k e le m,
      clight_corestep (CL_State f Scontinue (Kswitch k) e le) m
        (CL_State f Scontinue k e le) m

  | clight_corestep_label: forall f lbl s k e le m,
      clight_corestep (CL_State f (Slabel lbl s) k e le) m
        (CL_State f s k e le) m

  | clight_corestep_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some (s', k') ->
      clight_corestep (CL_State f (Sgoto lbl) k e le) m
        (CL_State f s' k' e le) m

  | clight_corestep_internal_function: forall f vargs k m e le m',
      function_entry f vargs m e le m' ->
      clight_corestep (CL_Callstate (Internal f) vargs k) m
        (CL_State f f.(fn_body) k e le) m'

  | clight_corestep_returnstate: forall v optid f e le k m,
      clight_corestep (CL_Returnstate v (Kcall optid f e le k)) m
        (CL_State f Sskip k e (set_opttemp optid v le)) m.

Lemma CL_corestep_not_at_external:
       forall m q m' q', clight_corestep q m q' m' -> CL_at_external q = None.

Lemma CL_corestep_not_halted : forall m q m' q',
       clight_corestep q m q' m' -> CL_halted q = None.

Lemma CL_at_external_halted_excl :
       forall q, CL_at_external q = None \/ CL_halted q = None.

Lemma CL_after_at_external_excl : forall retv q q',
      CL_after_external retv q = Some q' -> CL_at_external q' = None.

Definition CL_initial_core (v: val) (args:list val): option CL_core :=
   match v with
     | Vptr b i =>
          if Int.eq_dec i Int.zero
          then match Genv.find_funct_ptr ge b with
                 | None => None
                 | Some f => Some (CL_Callstate f args Kstop)
               end
          else None
     | _ => None
    end.
End SEMANTICS.

Definition CL_core_sem (FE:function -> list val -> mem -> env -> temp_env -> mem -> Prop)
         : CoreSemantics genv CL_core mem.

Lemma CL_forward :
  forall (FE: function -> list val -> mem -> env -> temp_env -> mem -> Prop)
         (HFE: forall f vargs m e le m', FE f vargs m e le m'-> mem_forward m m')
         g c m c' m' (CS: clight_corestep FE g c m c' m'),
                     mem_forward m m'.

Definition CL_coop_sem
           (FE:function -> list val -> mem -> env -> temp_env -> mem -> Prop)
           (HFE: forall f vargs m e le m', FE f vargs m e le m'-> mem_forward m m')
           : CoopCoreSem genv CL_core.

Lemma alloc_variables_forward: forall vars m e e2 m'
      (M: alloc_variables e m vars e2 m'),
      mem_forward m m'.

Lemma bind_parameter_forward: forall e m pars vargs m'
      (M: bind_parameters e m pars vargs m'),
      mem_forward m m'.

Inductive function_entry1 (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry1_intro: forall m1,
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
      alloc_variables empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
      bind_parameters e m1 f.(fn_params) vargs m' ->
      le = create_undef_temps f.(fn_temps) ->
      function_entry1 f vargs m e le m'.

Lemma function_entry1_forward: forall f vargs m e le m',
      function_entry1 f vargs m e le m'-> mem_forward m m'.

Definition CL_core_sem1 := CL_core_sem function_entry1.
Definition CL_coop_sem1 : CoopCoreSem genv CL_core.

Inductive function_entry2 (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry2_intro:
      list_norepet (var_names f.(fn_vars)) ->
      list_norepet (var_names f.(fn_params)) ->
      list_disjoint (var_names f.(fn_params)) (var_names f.(fn_temps)) ->
      alloc_variables empty_env m f.(fn_vars) e m' ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      function_entry2 f vargs m e le m'.

Lemma function_entry2_forward: forall f vargs m e le m',
      function_entry2 f vargs m e le m'-> mem_forward m m'.

Definition CL_core_sem2 := CL_core_sem function_entry2.
Definition CL_coop_sem2 : CoopCoreSem genv CL_core. *)

Require Import Clight_eff.
(* Clight_eff:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import compcert.common.Values.
Require Import Memory.
Require Export Maps.
Require Import Events.
Require Import Globalenvs.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.

Require Import Cop. 
Require Import Ctypes. 
Require Import Clight.
Require Import Clight_coop.

Definition assign_loc_Effect (ty:type) (b: block) (ofs: int) v : (block -> Z -> bool)  :=
  match access_mode ty with
     By_value chunk => fun b' z' => eq_block b b'
              && zle (Int.unsigned ofs) z'
              && zlt z' ((Int.unsigned ofs) + Z.of_nat (length (encode_val chunk v)))
   | By_copy => fun b' z' => eq_block b' b
              && zle (Int.unsigned ofs) z'
              && zlt z' ((Int.unsigned ofs) + (sizeof ty))
   | _ => fun b' z' => false
  end.

Lemma assign_loc_Effect_Sound: forall a m loc ofs v m'
      (AL: assign_loc (typeof a) m loc ofs v m'),
     Mem.unchanged_on (fun b z => assign_loc_Effect (typeof a)

Lemma alloc_variables_unchanged_on:
      forall P args env m e m' (H:alloc_variables env m args e m'),
      Mem.unchanged_on P m m'.

Lemma alloc_variables_freshblocks: forall vars E m e m1
      (AL: alloc_variables E m vars e m1)
      id b t (Hid: e!id = Some (b,t)),
      E!id = Some (b,t) \/ ~Mem.valid_block m b.

Lemma assign_loc_forward: forall ty m b ofs v m1
      (A: assign_loc ty m b ofs v m1),
      mem_forward m m1.

Section EFFSEM.
Variable FE:function -> list val -> mem -> env -> temp_env -> mem -> Prop.

Inductive clight_effstep (ge:genv): (block -> Z -> bool) ->
            CL_core -> mem -> CL_core -> mem -> Prop :=
  | clight_effstep_assign:   forall f a1 a2 k e le m loc ofs v2 v m',
      eval_lvalue ge e le m a1 loc ofs ->
      eval_expr ge e le m a2 v2 ->
      sem_cast v2 (typeof a2) (typeof a1) = Some v ->
      assign_loc (typeof a1) m loc ofs v m' ->
      clight_effstep ge (assign_loc_Effect (typeof a1) loc ofs v)
        (CL_State f (Sassign a1 a2) k e le) m
        (CL_State f Sskip k e le) m'

  | clight_effstep_set:   forall f id a k e le m v,
      eval_expr ge e le m a v ->
      clight_effstep ge EmptyEffect (CL_State f (Sset id a) k e le) m
        (CL_State f Sskip k e (PTree.set id v le)) m

  | clight_effstep_call:   forall f optid a al k e le m tyargs tyres vf vargs fd,
      classify_fun (typeof a) = fun_case_f tyargs tyres ->
      eval_expr ge e le m a vf ->
      eval_exprlist ge e le m al tyargs vargs ->
      Genv.find_funct ge vf = Some fd ->
      type_of_fundef fd = Tfunction tyargs tyres ->
      clight_effstep ge EmptyEffect (CL_State f (Scall optid a al) k e le) m
        (CL_Callstate fd vargs (Kcall optid f e le k)) m

  | clight_effstep_seq:  forall f s1 s2 k e le m,
      clight_effstep ge EmptyEffect (CL_State f (Ssequence s1 s2) k e le) m
        (CL_State f s1 (Kseq s2 k) e le) m

  | clight_effstep_skip_seq: forall f s k e le m,
      clight_effstep ge EmptyEffect (CL_State f Sskip (Kseq s k) e le) m
        (CL_State f s k e le) m
  | clight_effstep_continue_seq: forall f s k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f Scontinue (Kseq s k) e le) m
        (CL_State f Scontinue k e le) m

  | clight_effstep_break_seq: forall f s k e le m,
      clight_effstep ge EmptyEffect (CL_State f Sbreak (Kseq s k) e le) m
        (CL_State f Sbreak k e le) m

  | clight_effstep_ifthenelse:  forall f a s1 s2 k e le m v1 b,
      eval_expr ge e le m a v1 ->
      bool_val v1 (typeof a) = Some b ->
      clight_effstep ge EmptyEffect
        (CL_State f (Sifthenelse a s1 s2) k e le) m
        (CL_State f (if b then s1 else s2) k e le) m

  | clight_effstep_loop: forall f s1 s2 k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f (Sloop s1 s2) k e le) m
        (CL_State f s1 (Kloop1 s1 s2 k) e le) m
  | clight_effstep_skip_or_continue_loop1:  forall f s1 s2 k e le m x,
      x = Sskip \/ x = Scontinue ->
      clight_effstep ge EmptyEffect
        (CL_State f x (Kloop1 s1 s2 k) e le) m
        (CL_State f s2 (Kloop2 s1 s2 k) e le) m
  | clight_effstep_break_loop1:  forall f s1 s2 k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f Sbreak (Kloop1 s1 s2 k) e le) m
        (CL_State f Sskip k e le) m
  | clight_effstep_skip_loop2: forall f s1 s2 k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f Sskip (Kloop2 s1 s2 k) e le) m
        (CL_State f (Sloop s1 s2) k e le) m
  | clight_effstep_break_loop2: forall f s1 s2 k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f Sbreak (Kloop2 s1 s2 k) e le) m
        (CL_State f Sskip k e le) m

  | clight_effstep_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_effstep ge (FreelistEffect m (blocks_of_env e))
        (CL_State f (Sreturn None) k e le) m
        (CL_Returnstate Vundef (call_cont k)) m'
  | clight_effstep_return_1: forall f a k e le m v v' m',
      eval_expr ge e le m a v ->
      sem_cast v (typeof a) f.(fn_return) = Some v' ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_effstep ge (FreelistEffect m (blocks_of_env e))
        (CL_State f (Sreturn (Some a)) k e le) m
        (CL_Returnstate v' (call_cont k)) m'
  | clight_effstep_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      clight_effstep ge (FreelistEffect m (blocks_of_env e))
        (CL_State f Sskip k e le) m
        (CL_Returnstate Vundef k) m'

  | clight_effstep_switch: forall f a sl k e le m n,
      eval_expr ge e le m a (Vint n) ->
      clight_effstep ge EmptyEffect
       (CL_State f (Sswitch a sl) k e le) m
        (CL_State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch k) e le) m
  | clight_effstep_skip_break_switch: forall f x k e le m,
      x = Sskip \/ x = Sbreak ->
      clight_effstep ge EmptyEffect
        (CL_State f x (Kswitch k) e le) m
        (CL_State f Sskip k e le) m
  | clight_effstep_continue_switch: forall f k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f Scontinue (Kswitch k) e le) m
        (CL_State f Scontinue k e le) m

  | clight_effstep_label: forall f lbl s k e le m,
      clight_effstep ge EmptyEffect
        (CL_State f (Slabel lbl s) k e le) m
        (CL_State f s k e le) m

  | clight_effstep_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some (s', k') ->
      clight_effstep ge EmptyEffect
        (CL_State f (Sgoto lbl) k e le) m
        (CL_State f s' k' e le) m

  | clight_effstep_internal_function: forall f vargs k m e le m',
      FE f vargs m e le m' ->
      clight_effstep ge EmptyEffect
        (CL_Callstate (Internal f) vargs k) m
        (CL_State f f.(fn_body) k e le) m'

  | clight_effstep_returnstate: forall v optid f e le k m,
      clight_effstep ge EmptyEffect
        (CL_Returnstate v (Kcall optid f e le k)) m
        (CL_State f Sskip k e (set_opttemp optid v le)) m

  | clight_effstep_sub_val: forall E EE c m c' m',
      (forall b ofs, Mem.valid_block m b ->
                     E b ofs = true -> EE b ofs = true) ->
      clight_effstep ge E c m c' m' ->
      clight_effstep ge EE c m c' m'.

Variable FE_FWD: forall f vargs m e le m', FE f vargs m e le m' -> mem_forward m m'.
Variable FE_UNCH: forall f vargs m e le m', FE f vargs m e le m'->
         Mem.unchanged_on (fun b z => EmptyEffect b z = false) m m'.

Lemma clightstep_effax1: forall (M : block -> Z -> bool) ge c m c' m'
      (H: clight_effstep ge M c m c' m'),
       corestep (CL_coop_sem FE FE_FWD) ge c m c' m' /\
       Mem.unchanged_on (fun (b : block) (ofs : Z) => M b ofs = false) m m'.

Lemma clightstep_effax2: forall ge c m c' m',
      corestep (CL_coop_sem FE FE_FWD) ge c m c' m' ->
      exists M, clight_effstep ge M c m c' m'.

Definition clight_eff_sem
  :  @EffectSem Clight.genv CL_core.
End EFFSEM.

Lemma function_entry1_UNCH: forall f vargs m e le m',
      function_entry1 f vargs m e le m'->
      Mem.unchanged_on (fun b z => EmptyEffect b z = false) m m'.

Lemma function_entry2_UNCH: forall f vargs m e le m',
      function_entry2 f vargs m e le m'->
      Mem.unchanged_on (fun b z => EmptyEffect b z = false) m m'.

Definition CL_eff_sem1: @EffectSem Clight.genv CL_core.

Definition CL_eff_sem2: @EffectSem Clight.genv CL_core. *)

Require Import Csharpminor_coop.

Require Import Csharpminor_eff.
(* Csharpminor_eff:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import compcert.common.Values.
Require Import Memory.
Require Export Maps.
Require Import Events.
Require Import Globalenvs.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.

Require Import sepcomp.Csharpminor.
Require Import sepcomp.Csharpminor_coop.

Lemma EmptyEffect_allocvariables: forall L e m e' m'
      (ALLOC: alloc_variables e m L e' m'),
  Mem.unchanged_on (fun b ofs => EmptyEffect b ofs = false) m m'.

Inductive csharpmin_effstep (g: Csharpminor.genv):  (block -> Z -> bool) ->
            CSharpMin_core -> mem -> CSharpMin_core -> mem -> Prop :=

  | csharpmin_effstep_skip_seq: forall f s k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f Sskip (Kseq s k) e le) m
        (CSharpMin_State f s k e le) m
  | csharpmin_effstep_skip_block: forall f k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f Sskip (Kblock k) e le) m
        (CSharpMin_State f Sskip k e le) m
  | csharpmin_effstep_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      csharpmin_effstep g (FreelistEffect m (blocks_of_env e)) (CSharpMin_State f Sskip k e le) m
        (CSharpMin_Returnstate Vundef k) m'

  | csharpmin_effstep_set: forall f id a k e le m v,
      eval_expr g e le m a v ->
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sset id a) k e le) m
        (CSharpMin_State f Sskip k e (PTree.set id v le)) m

  | csharpmin_effstep_store: forall f chunk addr a k e le m vaddr v m',
      eval_expr g e le m addr vaddr ->
      eval_expr g e le m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      csharpmin_effstep g (StoreEffect vaddr (encode_val chunk v))
        (CSharpMin_State f (Sstore chunk addr a) k e le) m
        (CSharpMin_State f Sskip k e le) m'

  | csharpmin_effstep_call: forall f optid sig a bl k e le m vf vargs fd,
      eval_expr g e le m a vf ->
      eval_exprlist g e le m bl vargs ->
      Genv.find_funct g vf = Some fd ->
      funsig fd = sig ->
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Scall optid sig a bl) k e le) m
        (CSharpMin_Callstate fd vargs (Kcall optid f e le k)) m

  | csharpmin_effstep_seq: forall f s1 s2 k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sseq s1 s2) k e le) m
        (CSharpMin_State f s1 (Kseq s2 k) e le) m

  | csharpmin_effstep_ifthenelse: forall f a s1 s2 k e le m v b,
      eval_expr g e le m a v ->
      Val.bool_of_val v b ->
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sifthenelse a s1 s2) k e le) m
        (CSharpMin_State f (if b then s1 else s2) k e le) m

  | csharpmin_effstep_loop: forall f s k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sloop s) k e le) m
        (CSharpMin_State f s (Kseq (Sloop s) k) e le) m

  | csharpmin_effstep_block: forall f s k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sblock s) k e le) m
        (CSharpMin_State f s (Kblock k) e le) m

  | csharpmin_effstep_exit_seq: forall f n s k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sexit n) (Kseq s k) e le) m
        (CSharpMin_State f (Sexit n) k e le) m
  | csharpmin_effstep_exit_block_0: forall f k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sexit O) (Kblock k) e le) m
        (CSharpMin_State f Sskip k e le) m
  | csharpmin_effstep_exit_block_S: forall f n k e le m,
      csharpmin_effstep g EmptyEffect
        (CSharpMin_State f (Sexit (S n)) (Kblock k) e le) m
        (CSharpMin_State f (Sexit n) k e le) m

  | csharpmin_effstep_switch: forall f a cases k e le m n,
      eval_expr g e le m a (Vint n) ->
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sswitch a cases) k e le) m
        (CSharpMin_State f (seq_of_lbl_stmt (select_switch n cases)) k e le) m

  | csharpmin_effstep_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      csharpmin_effstep g (FreelistEffect m (blocks_of_env e)) (CSharpMin_State f (Sreturn None) k e le) m
        (CSharpMin_Returnstate Vundef (call_cont k)) m'
  | csharpmin_effstep_return_1: forall f a k e le m v m',
      eval_expr g e le m a v ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      csharpmin_effstep g (FreelistEffect m (blocks_of_env e)) (CSharpMin_State f (Sreturn (Some a)) k e le) m
        (CSharpMin_Returnstate v (call_cont k)) m'
  | csharpmin_effstep_label: forall f lbl s k e le m,
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Slabel lbl s) k e le) m
        (CSharpMin_State f s k e le) m

  | csharpmin_effstep_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      csharpmin_effstep g EmptyEffect (CSharpMin_State f (Sgoto lbl) k e le) m
        (CSharpMin_State f s' k' e le) m

  | csharpmin_effstep_internal_function: forall f vargs k m m1 e le,
      list_norepet (map fst f.(fn_vars)) ->
      list_norepet f.(fn_params) ->
      list_disjoint f.(fn_params) f.(fn_temps) ->
      alloc_variables empty_env m (fn_vars f) e m1 ->
      bind_parameters f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      csharpmin_effstep g EmptyEffect
        (CSharpMin_Callstate (Internal f) vargs k) m
        (CSharpMin_State f f.(fn_body) k e le) m1

  | csharpmin_effstep_return: forall v optid f e le k m,
      csharpmin_effstep g EmptyEffect (CSharpMin_Returnstate v (Kcall optid f e le k)) m
        (CSharpMin_State f Sskip k e (Cminor.set_optvar optid v le)) m

  | csharpmin_effstep_sub_val: forall E EE c m c' m',
      (forall b ofs, Mem.valid_block m b ->
                     E b ofs = true -> EE b ofs = true) ->
      csharpmin_effstep g E c m c' m' ->
      csharpmin_effstep g EE c m c' m'.

Lemma csharpminstep_effax1: forall (M : block -> Z -> bool) g c m c' m'
      (H: csharpmin_effstep g M c m c' m'),
       corestep csharpmin_coop_sem g c m c' m' /\
       Mem.unchanged_on (fun (b : block) (ofs : Z) => M b ofs = false) m m'.

Lemma csharpminstep_effax2: forall  g c m c' m',
      corestep csharpmin_coop_sem g c m c' m' ->
      exists M, csharpmin_effstep g M c m c' m'.

Program Definition csharpmin_eff_sem :
  @EffectSem Csharpminor.genv CSharpMin_core. *)



Require Import sepcomp.mem_lemmas.
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.core_semantics.

Require Import sepcomp.effect_semantics.
(* sepcomp.effect_semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Record EffectSem {C} :=
  { 
    sem :> @MemSem C

  ; effstep: (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop

  ; effax1: forall M c m c' m',
       effstep M c m c' m' ->
            corestep sem c m c' m'
         /\ Mem.unchanged_on (fun b ofs => M b ofs = false) m m'
  ; effax2: forall c m c' m',
       corestep sem c m c' m' ->
       exists M, effstep M c m c' m'
  ; effstep_perm: forall M c m c' m',
       effstep M c m c' m' ->
       forall b z, M b z = true -> Mem.perm m b z Cur Writable
  }.

Section effsemlemmas.
  Context {C:Type} (Sem: @EffectSem C).

  Lemma effstep_valid: forall M c m c' m',
       effstep Sem M c m c' m' ->
       forall b z, M b z = true -> Mem.valid_block m b.

  Lemma effstep_corestep: forall M c m c' m',
      effstep Sem M c m c' m' -> corestep Sem c m c' m'.

  Lemma effstep_unchanged: forall M c m c' m',
        effstep Sem M c m c' m' ->
        Mem.unchanged_on (fun b ofs => M b ofs = false) m m'.

  Lemma effstep_mem U c m c' m' (EF: effstep Sem U c m c' m'): mem_step m m'.

  Lemma effstep_fwd U c m c' m' (EF: effstep Sem U c m c' m'): mem_forward m m'.

  Fixpoint effstepN (n:nat) : (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop :=
    match n with
      | O => fun U c m c' m' => (c,m) = (c',m') /\ U = (fun b z => false)
      | S k => fun U c1 m1 c3 m3 => exists c2, exists m2, exists U1, exists U2,
        effstep Sem U1 c1 m1 c2 m2 /\
        effstepN k U2 c2 m2 c3 m3 /\
        U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b))
    end.

  Lemma effstepN_perm: forall n U c1 m1 c2 m2, effstepN n U c1 m1 c2 m2 ->
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.
  Lemma effstepN_valid n U c1 m1 c2 m2  (Step:effstepN n U c1 m1 c2 m2)
        b z (EFF:U b z = true): Mem.valid_block m1 b.

  Lemma effstepN_mem: forall n U c m c' m' (EF: effstepN n U c m c' m'), mem_step m m'.

  Lemma effstepN_fwd n U c m c' m' (EF:effstepN n U c m c' m'): mem_forward m m'.

  Lemma effstepN_corestepN: forall n E c m c' m',
      effstepN n E c m c' m' -> corestepN Sem n c m c' m'.

  Lemma effstepN_unchanged: forall n U c1 m1 c2 m2,
        effstepN n U c1 m1 c2 m2 ->
        Mem.unchanged_on (fun b z => U b z = false) m1 m2.

Lemma effstepN_trans: forall n1 n2 U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
   effstepN (n1+n2)
        (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) st1 m1 st3 m3.

Lemma effstepN_trans': forall n1 n2 U U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
   effstepN (n1+n2) U st1 m1 st3 m3.

  Definition effstep_plus U c m c' m' :=
    exists n, effstepN (S n) U c m c' m'.

  Definition effstep_star U c m c' m' :=
    exists n, effstepN n U c m c' m'.

  Lemma effstep_plus_corestep_plus U c m c' m' (EFF: effstep_plus U c m c' m'):
        corestep_plus Sem c m c' m'.

  Lemma effstep_star_corestep_star U c m c' m' (EFF: effstep_star U c m c' m'):
        corestep_star Sem c m c' m'.

  Lemma effstep_plus_star : forall U c1 c2 m1 m2,
    effstep_plus U c1 m1 c2 m2 -> effstep_star U c1 m1 c2 m2.

  Lemma effstep_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_plus_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_star (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_star U c1 m1 c3 m3.

  Lemma effstep_plus_one: forall U c m c' m',
    effstep Sem U c m c' m' -> effstep_plus U c m c' m'.

  Lemma effstep_plus_two: forall U1 c m c' m' U2 c'' m'',
    effstep  Sem U1 c m c' m' -> effstep Sem U2 c' m' c'' m'' ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m b)) c m c'' m''.

  Lemma effstep_star_zero: forall c m, effstep_star (fun b z =>false) c m c m.

  Lemma effstep_star_one: forall U c m c' m',
    effstep  Sem U c m c' m' -> effstep_star U c m c' m'.

  Lemma effstep_plus_split: forall U c m c' m',
    effstep_plus U c m c' m' ->
    exists c'', exists m'', exists U1, exists U2,
      effstep Sem U1 c m c'' m'' /\
      effstep_star U2 c'' m'' c' m' /\
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m b)).

  Lemma effstep_plus_perm U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_star_perm U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_plus_valid U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_valid U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_mem U c m c' m' (EF: effstep_star U c m c' m'): mem_step m m'.

  Lemma effstep_plus_mem U c m c' m' (EF: effstep_plus U c m c' m'): mem_step m m'.

  Lemma effstep_plus_fwd U c m c' m' (EF: effstep_plus U c m c' m'): mem_forward m m'.
  Lemma effstep_star_fwd U c m c' m' (EF: effstep_star U c m c' m'): mem_forward m m'.

End effsemlemmas.

Definition EmptyEffect: Values.block -> Z -> bool := fun b z => false.

Lemma EmptyEffect_alloc: forall m lo hi m' b (ALLOC: Mem.alloc m lo hi = (m', b)),

Definition FreeEffect m lo hi (sp b:Values.block) (ofs:Z): bool :=
   if valid_block_dec m b
   then eq_block b sp && zle lo ofs && zlt ofs hi
   else false.

Lemma FreeEffectD: forall m lo hi sp b z
   (FREE:FreeEffect m lo hi sp b z = true),
   b = sp /\ Mem.valid_block m b /\ lo <= z /\ z < hi.

Lemma FreeEffect_free: forall m sp lo hi m'
             (FREE: Mem.free m sp lo hi = Some m'),

Definition FreelistEffect
  m (L: list (Values.block * Z * Z)) (b:Values.block) (ofs:Z): bool :=
  List.fold_right (fun X E b z => match X with (bb,lo,hi) =>
                                   E b z || FreeEffect m lo hi bb b z
                                 end)
                  EmptyEffect L b ofs.

Lemma FreelistEffect_Dfalse: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = false),
      FreelistEffect m L b ofs = false /\
      FreeEffect m lo hi bb b ofs = false.

Lemma FreelistEffect_Dtrue: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = true),
      FreelistEffect m L b ofs = true \/
      FreeEffect m lo hi bb b ofs = true.

Lemma FreelistEffect_same: forall m bb lo hi mm L
          (F:Mem.free m bb lo hi = Some mm)

Lemma FreelistEffect_freelist: forall L m m' (FL: Mem.free_list m L = Some m'),

Lemma FreeEffect_validblock: forall m lo hi sp b ofs
        (EFF: FreeEffect m lo hi sp b ofs = true),
      Mem.valid_block m b.

Lemma FreelistEffect_validblock: forall l m b ofs
        (EFF: FreelistEffect m l b ofs = true),
      Mem.valid_block m b.

Definition StoreEffect (tv:val)(vl : list memval) (b:Values.block) (z:Z):bool :=
  match tv with Vptr bb ofs => eq_block bb b &&
             zle (Ptrofs.unsigned ofs) z && zlt z (Ptrofs.unsigned ofs + Z.of_nat (length vl))
         | _ => false
  end.

Lemma StoreEffect_Storev: forall m chunk tv tv' m'
         (STORE : Mem.storev chunk m tv tv' = Some m'),

Lemma StoreEffectD: forall vaddr v b ofs
      (STE: StoreEffect vaddr v b ofs = true),
      exists i, vaddr = Vptr b i /\
        (Ptrofs.unsigned i) <= ofs < (Ptrofs.unsigned i + Z.of_nat (length v)).

Lemma free_curWR m sp lo hi m' (FR: Mem.free m sp lo hi = Some m')

Lemma storev_curWR ch m vaddr v m' (ST:Mem.storev ch m vaddr v = Some m')

Lemma freelist_curWR l: forall m m' (FR: Mem.free_list m l = Some m') *)

Require Import StructuredInjections.
(* StructuredInjections:
Require Import Events.
Require Import Memory.
Require Import Coqlib.
Require Import compcert.common.Values.
Require Import Axioms.

Require Import sepcomp.mem_lemmas.

Lemma compose_meminjI_Some: forall j k b1 b2 d1 b3 d2
          (J:j b1 = Some(b2,d1)) (K:k b2 = Some(b3,d2)),
          compose_meminj j k b1 = Some(b3, d1+d2).

Lemma compose_meminjI_None: forall j k b1
          (H: (j b1 = None) \/
              (exists b2 d1, j b1 =Some(b2,d1) /\ k b2=None)),
          compose_meminj j k b1 = None.

Lemma inject_incr_coincide: forall f g (INC: inject_incr f g) b p
          (G:g b = Some p) q (F:f b = Some q),p=q.

Lemma inject_incr_inv: forall f g (INC: inject_incr f g) b
                       (G: g b =None), f b = None.

Lemma forall2_val_inject_D: forall vals1 vals2 j (ValInjMu : Forall2 (val_inject j) vals1 vals2)
          v1 (IN: In v1 vals1), exists v2, val_inject j v1 v2 /\ In v2 vals2.

Definition join (j k:meminj):meminj := fun b =>
  match j b with
     Some (b1, delta) => Some (b1,delta)
   | None => k b
  end.

Definition disjoint (j k:meminj):Prop :=
    forall b, j b = None \/ k b = None.

Lemma join_assoc: forall f g h, join f (join g h) = join (join f g) h.

Lemma join_com: forall f g, disjoint f g -> join f g = join g f.

Lemma disjoint_com: forall f g, disjoint f g <-> disjoint g f.

Lemma disjoint_sub: forall j k (D: disjoint j k) j' k'
              (J: inject_incr j' j) (K:inject_incr k' k),
              disjoint j' k'.

Lemma joinI: forall f g b p
             (Hp: f b = Some p \/ (f b = None /\ g b = Some p)),
      join f g b = Some p.

Lemma joinD: forall j k (D: disjoint j k) b,
   match join j k b with
     Some(b1,delta) => (j b = Some(b1,delta) /\ k b = None) \/
                       (k b = Some(b1,delta) /\ j b = None)
   | None => j b = None /\ k b = None
  end.

Lemma joinD_Some:
      forall j k b b' delta (J: join j k b = Some(b',delta)),
      j b = Some(b',delta) \/ (j b = None /\ k b = Some(b',delta)).

Lemma joinD_None:
      forall j k b (J: join j k b = None),
      j b = None /\ k b = None.

Lemma joinI_None: forall j k b (J:j b = None) (K:k b = None),
                  join j k b = None.

Lemma inject_incr_join: forall j j' k k'
  (J: inject_incr j j') (K: inject_incr k k')
  (D: disjoint j' k'),
  inject_incr (join j k) (join j' k').

Lemma join_incr_left: forall j k, inject_incr j (join j k).

Lemma join_incr_right: forall j k (D:disjoint j k),
                       inject_incr k (join j k).

Lemma disjointD_left:
      forall j k b b' delta (J: j b = Some (b',delta))
             (D:disjoint j k), k b = None.

Lemma disjointD_right:
      forall j k b b' delta (K: k b = Some (b',delta))
             (D:disjoint j k), j b = None.

Lemma join_left_agree:
      forall j k b b1 d1 (JK: join j k b = Some(b1,d1))
             b2 d2 (J: j b = Some(b2,d2)),
      b1=b2 /\ d1=d2.

Lemma join_right_agree:
      forall j k b b1 d1 (JK: join j k b = Some(b1,d1))
             b2 d2 (K: k b = Some(b2,d2)) (D:disjoint j k),
      b1=b2 /\ d1=d2.

Lemma join_disjoint: forall f g h (FH: disjoint f h) (GH: disjoint g h),
                     disjoint (join f g) h.

Lemma join_None_rightneutral: forall j, join j (fun b => None) = j.
Lemma join_None_leftneutral: forall j, join (fun b => None) j = j.

Record SM_Injection :=
  { locBlocksSrc : block -> bool;
                         locBlocksTgt : block -> bool;
                         pubBlocksSrc : block -> bool; 
    pubBlocksTgt : block -> bool; 
    local_of: meminj; 
    extBlocksSrc: block -> bool; 
    extBlocksTgt: block -> bool; 

    frgnBlocksSrc : block -> bool; 
    frgnBlocksTgt : block -> bool; 
    extern_of: meminj 
}.

Definition unknown_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if locBSrc b then None else if fSrc b then None else extern b
  end.

Definition foreign_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if fSrc b then extern b else None
  end.

Definition pub_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if pSrc b then local b else None
  end.

Definition priv_of (mu: SM_Injection) : meminj :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    fun b => if pSrc b then None else local b
  end.

Lemma local_pubpriv: forall mu,
      local_of mu = join (pub_of mu) (priv_of mu).

Definition shared_of (mu: SM_Injection) : meminj :=
  join (foreign_of mu) (pub_of mu).

Lemma unknown_in_extern: forall mu,
      inject_incr (unknown_of mu) (extern_of mu).

Lemma foreign_in_extern: forall mu,
      inject_incr (foreign_of mu) (extern_of mu).

Lemma foreign_in_shared: forall mu,
      inject_incr (foreign_of mu) (shared_of mu).

Lemma pub_in_local: forall mu,
      inject_incr (pub_of mu) (local_of mu).

Lemma priv_in_local: forall mu,
      inject_incr (priv_of mu) (local_of mu).

Lemma disjoint_pub_priv: forall mu, disjoint (pub_of mu) (priv_of mu).

Lemma disjoint_frgn_unknown: forall mu, disjoint (foreign_of mu) (unknown_of mu).

Record SM_wd (mu:SM_Injection):Prop := {
  disjoint_extern_local_Src: forall b, locBlocksSrc mu b = false \/ extBlocksSrc mu b = false;
  disjoint_extern_local_Tgt: forall b, locBlocksTgt mu b = false \/ extBlocksTgt mu b = false;

  local_DomRng: forall b1 b2 z, local_of mu b1 = Some(b2,z) ->
               (locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true);
  extern_DomRng: forall b1 b2 z, extern_of mu b1 = Some(b2,z) ->
               (extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true);

  pubSrcAx: forall b1, pubBlocksSrc mu b1 = true ->
              exists b2 z, local_of mu b1 = Some(b2,z) /\
                           pubBlocksTgt mu b2 = true;
  frgnSrcAx: forall b1, frgnBlocksSrc mu b1 = true ->
              exists b2 z, extern_of mu b1 = Some(b2,z) /\
                           frgnBlocksTgt mu b2 = true;

  pubBlocksLocalTgt: forall b, pubBlocksTgt mu b = true ->
                               locBlocksTgt mu b = true;
  frgnBlocksExternTgt: forall b, frgnBlocksTgt mu b = true ->
                              extBlocksTgt mu b = true
}.

Lemma pubSrc: forall mu (WD: SM_wd mu) b1, pubBlocksSrc mu b1 = true ->
              exists b2 z, pub_of mu b1 = Some(b2,z) /\
                           pubBlocksTgt mu b2 = true.

Lemma frgnSrc: forall mu (WD: SM_wd mu) b1, frgnBlocksSrc mu b1 = true ->
              exists b2 z, foreign_of mu b1 = Some(b2,z) /\
                           frgnBlocksTgt mu b2 = true.

Lemma extBlocksSrc_locBlocksSrc: forall mu (WD: SM_wd mu) b,
      extBlocksSrc mu b = true -> locBlocksSrc mu b = false.

Lemma extBlocksTgt_locBlocksTgt: forall mu (WD: SM_wd mu) b,
      extBlocksTgt mu b = true -> locBlocksTgt mu b = false.

Lemma locBlocksSrc_extBlocksSrc: forall mu (WD: SM_wd mu) b,
      locBlocksSrc mu b = true -> extBlocksSrc mu b = false.

Lemma locBlocksTgt_extBlocksTgt: forall mu (WD: SM_wd mu) b,
      locBlocksTgt mu b = true -> extBlocksTgt mu b = false.

Lemma pubBlocksLocalSrc: forall mu (WD: SM_wd mu) b,
      pubBlocksSrc mu b = true -> locBlocksSrc mu b = true.

Lemma frgnBlocksSrc_extBlocksSrc: forall mu (WD: SM_wd mu) b,
      frgnBlocksSrc mu b = true -> extBlocksSrc mu b = true.

Lemma locBlocksSrc_externNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), extern_of mu b = None.

Lemma locBlocksSrc_foreignNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), foreign_of mu b = None.

Lemma frgnBlocksSrc_locBlocksSrc: forall mu (WD:SM_wd mu) b
      (FB: frgnBlocksSrc mu b = true), locBlocksSrc mu b = false.

Lemma locBlocksSrc_frgnBlocksSrc: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), frgnBlocksSrc mu b = false.

Lemma locBlocksTgt_frgnBlocksTgt: forall mu (WD:SM_wd mu) b
      (MB: locBlocksTgt mu b = true), frgnBlocksTgt mu b = false.

Lemma frgnBlocksTgt_locBlocksTgt: forall mu (WD:SM_wd mu) b
      (FB: frgnBlocksTgt mu b = true), locBlocksTgt mu b = false.

Lemma locBlocksTgt_frgnBlocksTgt_D: forall mu (WD:SM_wd mu) b
            (MB: locBlocksTgt mu b = true) (FB: frgnBlocksTgt mu b = true),
      False.

Lemma locBlocksSrc_unknownNone: forall mu (WD:SM_wd mu) b
      (MB: locBlocksSrc mu b = true), unknown_of mu b = None.

Lemma extern_foreignunknown: forall mu (WD: SM_wd mu),
      extern_of mu = join (foreign_of mu) (unknown_of mu).

Lemma pubChar: forall mu (WD: SM_wd mu) b1 b2 z, pub_of mu b1 = Some(b2,z) ->
               pubBlocksSrc mu b1 = true /\ pubBlocksTgt mu b2 = true.

Lemma privChar: forall mu b1 b2 z, priv_of mu b1 = Some(b2,z) ->
                pubBlocksSrc mu b1 = false.

Lemma pubSrcContra: forall mu b1,
         pubBlocksSrc mu b1 = false -> pub_of mu b1 = None.

Lemma pubTgtContra: forall mu (WD: SM_wd mu) b2, pubBlocksTgt mu b2 = false ->
            ~ exists b1 d, pub_of mu b1 = Some(b2,d).

Lemma disjoint_extern_local: forall mu (WD: SM_wd mu),
     disjoint (extern_of mu) (local_of mu).

Lemma disjoint_foreign_pub: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (pub_of mu).

Lemma pub_in_shared: forall mu (WD: SM_wd mu),
      inject_incr (pub_of mu) (shared_of mu).

Definition DomSrc (mu: SM_Injection) (b1: block): bool :=
     locBlocksSrc mu b1 || extBlocksSrc mu b1.
Definition DOM (mu: SM_Injection) (b1: block): Prop := DomSrc mu b1 = true.

Definition DomTgt (mu: SM_Injection) (b2: block): bool :=
     locBlocksTgt mu b2 || extBlocksTgt mu b2.
Definition RNG (mu: SM_Injection) (b2:block): Prop := DomTgt mu b2 = true.

Definition intern_incr (mu mu': SM_Injection): Prop :=
   inject_incr (local_of mu) (local_of mu') /\
   (extern_of mu = extern_of mu') /\
   (forall b, locBlocksSrc mu b = true -> locBlocksSrc mu' b = true) /\
   (forall b, locBlocksTgt mu b = true -> locBlocksTgt mu' b = true) /\
   (pubBlocksSrc mu = pubBlocksSrc mu') /\
   (pubBlocksTgt mu = pubBlocksTgt mu') /\
   (frgnBlocksSrc mu = frgnBlocksSrc mu') /\
   (frgnBlocksTgt mu = frgnBlocksTgt mu') /\
   (extBlocksSrc mu = extBlocksSrc mu') /\
   (extBlocksTgt mu = extBlocksTgt mu').

Lemma intern_incr_DomSrc:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DomSrc mu b = true -> DomSrc mu' b = true.
Lemma intern_incr_DOM:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DOM mu b -> DOM mu' b.

Lemma intern_incr_DomTgt:
      forall mu mu' (Inc: intern_incr mu mu') b,
      DomTgt mu b = true -> DomTgt mu' b = true.

Lemma intern_incr_RNG:
      forall mu mu' (Inc: intern_incr mu mu') b,
      RNG mu b -> RNG mu' b.

Lemma intern_incr_DomSrc_inv: forall mu mu' (INC: intern_incr mu mu') b,
      DomSrc mu' b = false -> DomSrc mu b = false.

Lemma intern_incr_DomTgt_inv: forall mu mu' (INC: intern_incr mu mu') b,
      DomTgt mu' b = false -> DomTgt mu b = false.

Lemma intern_incr_locBlocksSrc_inv: forall mu mu' (INC: intern_incr mu mu') b,
      locBlocksSrc mu' b = false -> locBlocksSrc mu b = false.

Lemma intern_incr_locBlocksTgt_inv: forall mu mu' (INC: intern_incr mu mu') b,
      locBlocksTgt mu' b = false -> locBlocksTgt mu b = false.

Lemma intern_incr_priv: forall mu mu' (INC: intern_incr mu mu'),
      inject_incr (priv_of mu) (priv_of mu').

Lemma intern_incr_pub: forall mu mu' (INC: intern_incr mu mu')
       (WD: SM_wd mu), pub_of mu = pub_of mu'.

Lemma intern_incr_foreign: forall mu mu' (INC: intern_incr mu mu'),
      foreign_of mu = foreign_of mu'.

Lemma intern_incr_unknown: forall mu mu' (INC: intern_incr mu mu')
       (WD': SM_wd mu'), unknown_of mu = unknown_of mu'.

Definition extern_incr (mu mu': SM_Injection): Prop :=
   inject_incr (extern_of mu) (extern_of mu') /\
   (local_of mu = local_of mu') /\
   (forall b, extBlocksSrc mu b = true -> extBlocksSrc mu' b = true) /\
   (forall b, extBlocksTgt mu b = true -> extBlocksTgt mu' b = true) /\
   (locBlocksSrc mu = locBlocksSrc mu') /\
   (locBlocksTgt mu = locBlocksTgt mu') /\
   (pubBlocksSrc mu = pubBlocksSrc mu') /\
   (pubBlocksTgt mu = pubBlocksTgt mu') /\
   (frgnBlocksSrc mu = frgnBlocksSrc mu') /\
   (frgnBlocksTgt mu = frgnBlocksTgt mu').

Lemma extern_incr_DomSrc:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DomSrc mu b = true -> DomSrc mu' b = true.
Lemma extern_incr_DOM:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DOM mu b -> DOM mu' b.

Lemma extern_incr_DomTgt:
      forall mu mu' (Inc: extern_incr mu mu') b,
      DomTgt mu b = true -> DomTgt mu' b = true.

Lemma extern_incr_RNG:
      forall mu mu' (Inc: extern_incr mu mu') b,
      RNG mu b -> RNG mu' b.

Lemma extern_incr_unknown: forall mu mu' (INC: extern_incr mu mu'),
   inject_incr (unknown_of mu) (unknown_of mu').

Lemma extern_incr_frgnBlocksSrc: forall
          mu nu (INC: extern_incr mu nu),
       frgnBlocksSrc mu = frgnBlocksSrc nu.

Lemma extern_incr_frgnBlocksTgt: forall
          mu nu (INC: extern_incr mu nu),
       frgnBlocksTgt mu = frgnBlocksTgt nu.

Lemma extern_incr_foreign_inc: forall mu mu' (INC: extern_incr mu mu'),
   inject_incr (foreign_of mu) (foreign_of mu').

Lemma extern_incr_foreign: forall mu mu' (INC: extern_incr mu mu') (WDmu: SM_wd mu),
   foreign_of mu = foreign_of mu'.

Lemma extern_incr_pub: forall mu mu' (INC: extern_incr mu mu'),
   pub_of mu = pub_of mu'.

Lemma extern_incr_priv: forall mu mu' (INC: extern_incr mu mu'),
   priv_of mu = priv_of mu'.

Definition as_inj (mu: SM_Injection) : meminj :=
  join (extern_of mu) (local_of mu).

Lemma local_in_all: forall j (PR:SM_wd j), inject_incr (local_of j) (as_inj j).

Lemma pub_in_all: forall j (PR:SM_wd j), inject_incr (pub_of j) (as_inj j).

Lemma priv_in_all: forall j (PR:SM_wd j), inject_incr (priv_of j) (as_inj j).

Lemma extern_in_all: forall mu, inject_incr (extern_of mu) (as_inj mu).

Lemma foreign_in_all: forall mu, inject_incr (foreign_of mu) (as_inj mu).

Lemma unknown_in_all: forall mu, inject_incr (unknown_of mu) (as_inj mu).

Lemma shared_in_all: forall j (PR:SM_wd j), inject_incr (shared_of j) (as_inj j).

Lemma as_injD_None: forall mu b1, as_inj mu b1 = None ->
   extern_of mu b1 = None /\
   local_of mu b1 = None.

Lemma local_ofD_None: forall mu b1, local_of mu b1 = None ->
   pub_of mu b1 = None /\
   priv_of mu b1 = None.

Lemma extern_ofD_None: forall mu b1, extern_of mu b1 = None ->
   foreign_of mu b1 = None /\
   unknown_of mu b1 = None.

Lemma disjoint_foreign_priv: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (priv_of mu).

Lemma disjoint_foreign_local: forall mu (WD: SM_wd mu),
      disjoint (foreign_of mu) (local_of mu).

Lemma disjoint_unknown_local: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (local_of mu).

Lemma disjoint_unknown_pub: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (pub_of mu).

Lemma disjoint_unknown_priv: forall mu (WD: SM_wd mu),
      disjoint (unknown_of mu) (priv_of mu).

Lemma disjoint_shared_priv: forall mu (WD: SM_wd mu),
      disjoint (shared_of mu) (priv_of mu).

Lemma disjoint_shared_unknown: forall mu (WD: SM_wd mu),
      disjoint (shared_of mu) (unknown_of mu).

Lemma as_inj_DomRng: forall mu b1 b2 d, as_inj mu b1 = Some(b2, d) -> SM_wd mu ->
                DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma local_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: local_of mu b1 = Some(b2,z)),
      locBlocksSrc mu b1  = true /\ locBlocksTgt mu b2  = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma pub_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: pub_of mu b1 = Some(b2,z)),
      pubBlocksSrc mu b1 = true /\ pubBlocksTgt mu b2 = true /\
      locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma priv_locBlocks: forall mu (WD:SM_wd mu)
                  b1 b2 z (L: priv_of mu b1 = Some(b2,z)),
      pubBlocksSrc mu b1 = false /\
      locBlocksSrc mu b1 = true /\ locBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = false /\ extBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = false /\ frgnBlocksTgt mu b2 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma extern_DomRng': forall mu (WD:SM_wd mu) b1 b2 d
                      (L:extern_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma foreign_DomRng: forall mu (WD:SM_wd mu) b1 b2 d
                      (L:foreign_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      frgnBlocksSrc mu b1 = true /\ frgnBlocksTgt mu b2 = true /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Lemma unknown_DomRng: forall mu (WD:SM_wd mu) b1 b2 d
                      (L: unknown_of mu b1 = Some(b2,d)),
      pubBlocksSrc mu b1 = false /\ pubBlocksTgt mu b2 = false /\
      locBlocksSrc mu b1 = false /\ locBlocksTgt mu b2 = false /\
      extBlocksSrc mu b1 = true /\ extBlocksTgt mu b2 = true /\
      frgnBlocksSrc mu b1 = false /\
      DomSrc mu b1 = true /\ DomTgt mu b2 = true.

Definition locvisible_of mu := join (foreign_of mu) (local_of mu) .
Definition extvisible_of mu := join (extern_of mu) (pub_of mu).

Lemma locvisible_sharedprivate: forall mu,
      locvisible_of mu = join (shared_of mu) (priv_of mu).

Lemma shared_in_locvisible: forall mu,
      inject_incr (shared_of mu) (locvisible_of mu).

Lemma local_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (local_of mu) (locvisible_of mu).

Lemma private_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (priv_of mu) (locvisible_of mu).

Lemma pub_in_locvisible: forall mu (WD: SM_wd mu),
      inject_incr (pub_of mu) (locvisible_of mu).

Lemma extvisible_sharedunknown: forall mu (WD: SM_wd mu),
      extvisible_of mu = join (shared_of mu) (unknown_of mu).

Lemma shared_in_extvisible: forall mu( WD: SM_wd mu),
      inject_incr (shared_of mu) (extvisible_of mu).

Lemma unknown_in_extvisible: forall mu (WD: SM_wd mu),
      inject_incr (unknown_of mu) (extvisible_of mu).

Definition sm_inject_separated (mu mu' : SM_Injection) (m1 m2:mem):Prop :=
  (forall b1 b2 d, as_inj mu b1 = None -> as_inj mu' b1 = Some(b2,d) ->
                   (DomSrc mu b1 = false /\ DomTgt mu b2 = false)) /\
  (forall b1, DomSrc mu b1 = false -> DomSrc mu' b1 = true -> ~Mem.valid_block m1 b1) /\
  (forall b2, DomTgt mu b2 = false -> DomTgt mu' b2 = true -> ~Mem.valid_block m2 b2).

Lemma sm_inject_separated_mem: forall mu mu' m1 m2
        (SEP: sm_inject_separated mu mu' m1 m2) (WD': SM_wd mu'),
      inject_separated (as_inj mu) (as_inj mu') m1 m2.

Lemma sm_inject_separated_asinj_same: forall mu nu m1 m2
         (SEP: sm_inject_separated mu nu m1 m2)
          nu' (Hnu: as_inj nu = as_inj nu')
          (HSrc: DomSrc nu = DomSrc nu')
          (HTgt: DomTgt nu = DomTgt nu'),
      sm_inject_separated mu nu' m1 m2.

Definition freshloc m m' b := andb (valid_block_dec m' b) (negb (valid_block_dec m b)).
Lemma freshloc_charT: forall m m' b,
      (freshloc m m' b = true) <-> (Mem.valid_block m' b /\ ~Mem.valid_block m b).
Lemma freshloc_charF: forall m m' b,
      (freshloc m m' b = false) <-> (Mem.valid_block m b \/ ~Mem.valid_block m' b).
Lemma freshloc_irrefl: forall m b, freshloc m m b = false.
Lemma freshloc_trans: forall m m'' m' b
     (FWD: mem_forward m m'') (FWD': mem_forward m'' m'),
     (orb (freshloc m m'' b) (freshloc m'' m' b)) = freshloc m m' b.

Definition sm_locally_allocated (mu mu' : SM_Injection) (m1 m2 m1' m2':mem):Prop :=
  match mu, mu' with
     Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern,
     Build_SM_Injection locBSrc' locBTgt' pSrc' pTgt' local' extBSrc' extBTgt' fSrc' fTgt' extern'
  =>    locBSrc' = (fun b => orb (locBSrc b) (freshloc m1 m1' b))
     /\ locBTgt' = (fun b => orb (locBTgt b) (freshloc m2 m2' b))
     /\ extBSrc' = extBSrc
     /\ extBTgt' = extBTgt
  end.

Lemma sm_locally_allocatedChar: forall mu mu' m1 m2 m1' m2',
  sm_locally_allocated mu mu' m1 m2 m1' m2' <->
  (    DomSrc mu' = (fun b => orb (DomSrc mu b) (freshloc m1 m1' b))
    /\ DomTgt mu' = (fun b => orb (DomTgt mu b) (freshloc m2 m2' b))
    /\ locBlocksSrc mu' = (fun b => orb (locBlocksSrc mu b) (freshloc m1 m1' b))
    /\ locBlocksTgt mu' = (fun b => orb (locBlocksTgt mu b) (freshloc m2 m2' b))
    /\ extBlocksSrc mu' = extBlocksSrc mu
    /\ extBlocksTgt mu' = extBlocksTgt mu).

Lemma sm_inject_separated_intern_MYB: forall mu mu' m1 m2 m1' m2'
        (SEP: sm_inject_separated mu mu' m1 m2)
        (LAL: sm_locally_allocated mu mu' m1 m2 m1' m2'),
      (forall b, locBlocksSrc mu b = false -> locBlocksSrc mu' b = true -> ~ Mem.valid_block m1 b) /\

Definition sm_valid (mu : SM_Injection) (m1 m2: mem) :=
       (forall b1, DOM mu b1 -> Mem.valid_block m1 b1)
    /\ (forall b2, RNG mu b2 -> Mem.valid_block m2 b2).

Lemma intern_incr_refl: forall mu, intern_incr mu mu.

Definition smvalid_src (mu : SM_Injection) m1 :=
  forall b1, DOM mu b1 -> Memory.Mem.valid_block m1 b1.

Lemma sm_valid_smvalid_src mu m1 m2 :
  sm_valid mu m1 m2 -> smvalid_src mu m1.

Lemma extern_incr_refl: forall mu, extern_incr mu mu.

Lemma intern_incr_local: forall mu mu' (INC: intern_incr mu mu'),
      inject_incr (local_of mu) (local_of mu').

Lemma intern_incr_extern: forall mu mu' (INC: intern_incr mu mu'),
      extern_of mu = extern_of mu'.

Lemma extern_incr_extern: forall mu mu' (INC: extern_incr mu mu'),
      inject_incr (extern_of mu) (extern_of mu').

Lemma extern_incr_local: forall mu mu' (INC: extern_incr mu mu'),
      local_of mu = local_of mu'.

Lemma intern_incr_trans: forall mu mu' mu''
      (Inc: intern_incr mu mu') (Inc': intern_incr mu' mu''),
      intern_incr mu mu''.

Lemma extern_incr_trans: forall mu mu' mu''
      (Inc: extern_incr mu mu') (Inc': extern_incr mu' mu''),
      extern_incr mu mu''.

Lemma sm_inject_separated_same_sminj: forall mu m m',
   sm_inject_separated mu mu m m'.

Lemma intern_incr_as_inj: forall mu mu'
      (INC: intern_incr mu mu') (WD': SM_wd mu'),
      inject_incr (as_inj mu) (as_inj mu').

Lemma extern_incr_as_inj: forall mu mu'
     (INC: extern_incr mu mu') (WD': SM_wd mu'),
     inject_incr (as_inj mu) (as_inj mu').

Lemma inject_separated_intern_incr_fwd:
  forall mu mu' m1 m2 mu'' m2'
  (SEP: sm_inject_separated mu mu' m1 m2)
  (SEP': sm_inject_separated mu' mu'' m1 m2')
  (INC: intern_incr mu mu') (INC': intern_incr mu' mu'')
  (FWD: mem_forward m2 m2')
  (WD': SM_wd mu') (WD'': SM_wd mu''),
  sm_inject_separated mu mu'' m1 m2.

Lemma intern_separated_incr_fwd2:
  forall mu0 mu mu' m10 m20 m1 m2,
  intern_incr mu mu' ->
  sm_inject_separated mu mu' m1 m2 ->
  intern_incr mu0 mu ->
  mem_forward m10 m1 ->
  sm_inject_separated mu0 mu m10 m20 ->
  mem_forward m20 m2 ->
  SM_wd mu' ->
  sm_inject_separated mu0 mu' m10 m20.

Lemma sm_locally_allocated_trans: forall mu mu' mu'' m2 m3 m2' m3' m2'' m3''
(LocAlloc23 : sm_locally_allocated mu mu' m2 m3 m2'' m3')
(LocAlloc23' : sm_locally_allocated mu' mu'' m2'' m3' m2' m3'')
(Fwd2 : mem_forward m2 m2'')
(Fwd2' : mem_forward m2'' m2')
(Fwd3 : mem_forward m3 m3')
(Fwd3' : mem_forward m3' m3''),
sm_locally_allocated mu mu'' m2 m3 m2' m3''.

Definition sharedSrc mu b :=
    match shared_of mu b
    with Some _ => true | None => false
    end.

Lemma sharedSrc_iff: forall mu b, sharedSrc mu b = true <->
                     exists b2 d, shared_of mu b = Some(b2,d).

Lemma pubSrc_shared: forall mu (WD: SM_wd mu) b,
                     pubBlocksSrc mu b = true ->
                     sharedSrc mu b = true.

Lemma frgnSrc_shared: forall mu (WD: SM_wd mu) b,
                     frgnBlocksSrc mu b = true ->
                     sharedSrc mu b = true.

Lemma sharedSrc_iff_frgnpub: forall mu (WD: SM_wd mu),
      sharedSrc mu = fun b => orb (frgnBlocksSrc mu b) (pubBlocksSrc mu b).

Definition sharedTgt mu b := orb (frgnBlocksTgt mu b) (pubBlocksTgt mu b).

Lemma shared_SrcTgt: forall mu (WD: SM_wd mu) b
                    (SH: sharedSrc mu b = true),
      exists jb d, shared_of mu b = Some (jb, d) /\ sharedTgt mu jb = true.

Definition initial_SM (extS extT frgnS frgnT: block->bool)
                     (extern:meminj): SM_Injection :=
  Build_SM_Injection
       (fun b => false) (fun b => false)
      (fun b => false) (fun b => false)
      (fun b => None)
       extS extT
       frgnS frgnT
      extern.

Lemma initial_SM_wd: forall extS extT frgnS frgnT extern
                       (EXT: forall b1 b2 d, extern b1 =Some(b2,d) ->
                            extS b1 = true /\ extT b2 = true)
                       (F: forall b1, frgnS b1 = true ->
                           exists b2 z, extern b1 = Some (b2, z) /\ frgnT b2 = true)
                       (FS: forall b, frgnS b = true -> extS b = true)
                       (FT: forall b, frgnT b = true -> extT b = true),
                       SM_wd (initial_SM extS extT frgnS frgnT extern).

Lemma initial_SM_as_inj: forall extS extT frgnS frgnT j,
      as_inj (initial_SM extS extT frgnS frgnT j) = j.

Definition restrict (j: meminj) (X:block -> bool) : meminj :=
  fun b => if X b then j b else None.

Lemma restrictD_Some: forall j X b1 b2 d (R:restrict j X b1 = Some(b2,d)),
                      j b1 = Some(b2,d) /\ X b1 = true.
Lemma restrictI_Some: forall j X b b2 d (J:j b = Some(b2,d))
                            (Hb: X b = true),
                      restrict j X b = Some(b2,d).
Lemma restrictD_None: forall j X b1 b2 d (R:restrict j X b1 = None)
                      (J: j b1 = Some(b2,d)), X b1 = false.
Lemma restrictD_None': forall j X b1 (R:restrict j X b1 = None),
                         j b1 = None \/
                        (exists b2 d, j b1 =Some(b2,d) /\ X b1 = false).
Lemma restrictI_None: forall j X b (Hb: j b = None \/ X b = false),
                      restrict j X b = None.

Lemma join_restrict: forall j k X,
      join (restrict j X) (restrict k X) = restrict (join j k) X.

Lemma restrict_outside: forall j X
        (HX: forall b1 b2 d, j b1 = Some(b2, d) -> X b1 = true),
      restrict j X = j.

Lemma restrict_incr: forall j X, inject_incr (restrict j X) j.

Lemma restrict_com: forall j X Y,
      restrict (restrict j X) Y = restrict (restrict j Y) X.

Lemma restrict_nest: forall j X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict (restrict j X) Y = restrict j Y.
Lemma restrict_nest': forall j X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict (restrict j Y) X = restrict j Y.

Lemma val_inject_restrictD: forall j v v' X
       (V: val_inject (restrict j X) v v'),
     val_inject j v v'.

Lemma forall_vals_inject_restrictD: forall j vals1 vals2 X
     (Inj : Forall2 (val_inject (restrict j X)) vals1 vals2),
 Forall2 (val_inject j) vals1 vals2.

Definition reestablish (mu0 mu: SM_Injection): SM_Injection :=
  match mu0, mu with
    Build_SM_Injection locBSrc0 locBTgt0 pSrc0 pTgt0 local0
                       extBSrc0 extBTgt0 fSrc0 fTgt0 extern0,
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local
                       extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc0 locBTgt0 pSrc0 pTgt0 local0
                       (fun b => if locBSrc0 b then false else locBSrc b || extBSrc b)
                       (fun b => if locBTgt0 b then false else locBTgt b || extBTgt b)
                       fSrc0 fTgt0 
                       (fun b => if locBSrc0 b then None else join extern local b)
  end.

Lemma reestablish_DomSrc: forall mu0 mu
      (D: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true),
      DomSrc (reestablish mu0 mu) = DomSrc mu.

Lemma reestablish_DomTgt: forall mu0 mu
      (D: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true),
      DomTgt (reestablish mu0 mu) = DomTgt mu.

Lemma reestablish_wd: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (SEP: forall b1 b2 d, as_inj mu0 b1 = None -> as_inj mu b1 = Some(b2,d) ->
                                (DomSrc mu0 b1 = false /\ DomTgt mu0 b2 = false))
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      SM_wd (reestablish mu0 mu).

Lemma reestablish_wd': forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
                      (INC: inject_incr (as_inj mu0) (as_inj mu))
                      (Hmu: forall b1 b2 z (A:as_inj mu b1 = Some(b2,z)),
                            locBlocksSrc mu0 b1 = locBlocksTgt mu0 b2 /\
                            extBlocksSrc mu0 b1 = extBlocksTgt mu0 b2)
                      (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
                      SM_wd (reestablish mu0 mu).

Lemma reestablish_extern_incr': forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (INC: inject_incr (as_inj mu0) (as_inj mu))
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      extern_incr mu0 (reestablish mu0 mu).

Lemma reestablish_extern_incr: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true),
      extern_incr mu0 (reestablish mu0 mu).

Lemma reestablish_internstep': forall mu0 mu mu' (WD0:SM_wd mu0) (WD:SM_wd mu) (WD:SM_wd mu')
          (INC: inject_incr (as_inj mu0) (as_inj mu))
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true)
          (II: intern_incr mu mu'),
      extern_incr mu0 (reestablish mu0 mu').

Lemma reestablish_internstep: forall mu0 mu mu' (WD0:SM_wd mu0) (WD:SM_wd mu) (WD:SM_wd mu')
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (ExtSrc: forall b, extBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (ExtTgt: forall b, extBlocksTgt mu0 b = true -> DomTgt mu b = true)
          (II: intern_incr mu mu'),
      extern_incr mu0 (reestablish mu0 mu').

Lemma reestablish_as_inj: forall mu0 mu (WD0:SM_wd mu0)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0),
      as_inj (reestablish mu0 mu) = as_inj mu.

Lemma reestablish_as_inj': forall mu0 mu (WD0:SM_wd mu0)
           (HINC: inject_incr (as_inj mu0) (as_inj mu))
           (H: forall b, locBlocksSrc mu0 b = true -> local_of mu0 b = None ->
                         as_inj mu b = None),
      as_inj (reestablish mu0 mu) = as_inj mu.

Lemma reestablish_sm_injsep: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (REST: restrict (as_inj mu) (DomSrc mu0) = as_inj mu0)
          (LocSrc: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (LocTgt: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true)
          m1 m2 (SEP: sm_inject_separated mu0 mu m1 m2),
      sm_inject_separated mu0 (reestablish mu0 mu) m1 m2.

Lemma reestablish_sm_valid: forall mu0 mu (WD0:SM_wd mu0) (WD:SM_wd mu)
          (LocSrc: forall b, locBlocksSrc mu0 b = true -> DomSrc mu b = true)
          (DomTgt: forall b, locBlocksTgt mu0 b = true -> DomTgt mu b = true)
          m1 m2 (VAL: sm_valid mu m1 m2),
      sm_valid (reestablish mu0 mu) m1 m2. *)

Require Import effect_simulations.
(* effect_simulations:
Require Import compcert.common.Events.
Require Import compcert.common.Memory.
Require Import compcert.lib.Coqlib.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.AST.

Require Import compcert.common.Globalenvs.

Require Import compcert.lib.Axioms.

Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Definition vis mu := fun b => locBlocksSrc mu b || frgnBlocksSrc mu b.

Inductive reach (m:mem) (B:block -> Prop): list (block * Z) -> block -> Prop :=
  reach_nil: forall b, B b -> reach m B nil b
| reach_cons: forall b L b' z off n,
                     reach m B L b' ->
                     Mem.perm m b' z Cur Readable ->
                     ZMap.get z (PMap.get b' (Mem.mem_contents m)) =
                        Pointer b off n ->
              reach m B ((b',z)::L) b.

Fixpoint reach' (m:mem) (B:block -> Prop) (L:list (block * Z)): block -> Prop:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => bb = b /\
                                               Mem.perm m b' z Cur Readable /\
                                               reach' m B L b'
                           | _ => fun bb => False
                       end
            end
  end.

Lemma reach_reach': forall m B L b1, reach m B L b1 <-> reach' m B L b1.

Fixpoint reach'' (m:mem) (B:block -> bool) (L:list (block * Z)): block -> bool:=
  match L with
    nil => B
  | l::L => match l with
             (b',z) => match ZMap.get z (PMap.get b' (Mem.mem_contents m))
                       with Pointer b off n => fun bb => eq_block bb b &&
                                               Mem.perm_dec m b' z Cur Readable  &&
                                               reach'' m B L b'
                           | _ => fun bb => false
                       end
            end
  end.

Lemma reach_reach'' m B L b1 :
  reach m (fun b => B b=true) L b1 <-> reach'' m B L b1=true.

Lemma reach_inject: forall m1 m2 j (J: Mem.inject j m1 m2)

Lemma reach_mono: forall B1 B2 (HB : forall b, B1 b = true -> B2 b = true)
                         m b L1 (R : reach m (fun bb : block => B1 bb = true) L1 b),
                  exists L, reach m (fun bb : block => B2 bb = true) L b.

Parameter REACH : mem -> (block -> bool) -> block -> bool.
Axiom REACHAX : 
  forall m B b, REACH m B b = true
  <-> exists L, reach m (fun bb => B bb = true) L b.

Lemma REACH_nil: forall m B b, B b = true -> REACH m B b = true.

Lemma REACH_cons: forall m B b b' z off n,
                     REACH m B b' = true ->
                     Mem.perm m b' z Cur Readable ->

Lemma REACH_inject: forall m1 m2 j (J: Mem.inject j m1 m2) B1 B2

Lemma REACH_mono: forall B1 B2 (HB: forall b, B1 b = true -> B2 b = true) m b
                  (R: REACH m B1 b = true), REACH m B2 b = true.

Definition replace_locals (mu:SM_Injection) pSrc' pTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc' pTgt' local extBSrc extBTgt fSrc fTgt extern
  end.

Lemma replace_locals_wd: forall mu (WD: SM_wd mu) pSrc' pTgt'
         (SRC: forall b1, pSrc' b1 = true ->
               exists b2 d, local_of mu b1 = Some(b2,d) /\ pTgt' b2=true)
         (TGT: forall b, pTgt' b = true -> locBlocksTgt mu b = true),
      SM_wd (replace_locals mu pSrc' pTgt').

Lemma replace_locals_extern: forall mu pubSrc' pubTgt',
      extern_of (replace_locals mu pubSrc' pubTgt') = extern_of mu.

Lemma replace_locals_local: forall mu pubSrc' pubTgt',
      local_of (replace_locals mu pubSrc' pubTgt') = local_of mu.

Lemma replace_locals_unknown: forall mu pubSrc' pubTgt',
      unknown_of (replace_locals mu pubSrc' pubTgt') = unknown_of mu.

Lemma replace_locals_foreign: forall mu pubSrc' pubTgt',
      foreign_of (replace_locals mu pubSrc' pubTgt') = foreign_of mu.

Lemma replace_locals_pub: forall mu pubSrc' pubTgt',
      pub_of (replace_locals mu pubSrc' pubTgt') =
          (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_pub': forall mu pubSrc' pubTgt'
      (P: forall b, pubBlocksSrc mu b = true -> pubSrc' b = true)
      b (B: pubBlocksSrc mu b = true),
      pub_of (replace_locals mu pubSrc' pubTgt') b = pub_of mu b.

Lemma replace_locals_as_inj: forall mu pubSrc' pubTgt',
      as_inj (replace_locals mu pubSrc' pubTgt') = as_inj mu.

Lemma replace_locals_shared: forall mu pubSrc' pubTgt',
      shared_of (replace_locals mu pubSrc' pubTgt') =
      join (foreign_of mu) (fun b => if pubSrc' b then local_of mu b else None).

Lemma replace_locals_DOM: forall mu pubSrc' pubTgt',
      DOM (replace_locals mu pubSrc' pubTgt') = DOM mu.

Lemma replace_locals_RNG: forall mu pubSrc' pubTgt',
      RNG (replace_locals mu pubSrc' pubTgt') = RNG mu.

Lemma replace_locals_DomSrc: forall mu pubSrc' pubTgt',
      DomSrc (replace_locals mu pubSrc' pubTgt') = DomSrc mu.

Lemma replace_locals_DomTgt: forall mu pubSrc' pubTgt',
      DomTgt (replace_locals mu pubSrc' pubTgt') = DomTgt mu.

Lemma replace_locals_locBlocksSrc: forall mu pubSrc' pubTgt',
      locBlocksSrc (replace_locals mu pubSrc' pubTgt') = locBlocksSrc mu.

Lemma replace_locals_extBlocksTgt: forall mu pubSrc' pubTgt',
      extBlocksTgt (replace_locals mu pubSrc' pubTgt') = extBlocksTgt mu.

Lemma replace_locals_extBlocksSrc: forall mu pubSrc' pubTgt',
      extBlocksSrc (replace_locals mu pubSrc' pubTgt') = extBlocksSrc mu.

Lemma replace_locals_locBlocksTgt: forall mu pubSrc' pubTgt',
      locBlocksTgt (replace_locals mu pubSrc' pubTgt') = locBlocksTgt mu.

Lemma replace_locals_frgnBlocksSrc: forall mu pubSrc' pubTgt',
      frgnBlocksSrc (replace_locals mu pubSrc' pubTgt') = frgnBlocksSrc mu.

Lemma replace_locals_frgnBlocksTgt: forall mu pubSrc' pubTgt',
      frgnBlocksTgt (replace_locals mu pubSrc' pubTgt') = frgnBlocksTgt mu.

Lemma replace_locals_pubBlocksSrc: forall mu pubSrc' pubTgt',
      pubBlocksSrc (replace_locals mu pubSrc' pubTgt') = pubSrc'.

Lemma replace_locals_pubBlocksTgt: forall mu pubSrc' pubTgt',
      pubBlocksTgt (replace_locals mu pubSrc' pubTgt') = pubTgt'.

Definition replace_externs (mu:SM_Injection) fSrc' fTgt': SM_Injection :=
  match mu with
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
    Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc' fTgt' extern
  end.

Lemma replace_externs_wd: forall mu (WD: SM_wd mu) fSrc' fTgt'
         (SRC: forall b1, fSrc' b1 = true ->
               exists b2 d, extern_of mu b1 = Some(b2,d) /\ fTgt' b2=true)
         (TGT: forall b, fTgt' b = true -> extBlocksTgt mu b = true),
      SM_wd (replace_externs mu fSrc' fTgt').

Lemma replace_externs_extern: forall mu frgSrc' frgTgt',
      extern_of (replace_externs mu frgSrc' frgTgt') = extern_of mu.

Lemma replace_externs_foreign: forall mu frgSrc' frgTgt',
      foreign_of (replace_externs mu frgSrc' frgTgt') =
      fun b : block => if frgSrc' b then extern_of mu b else None.

Lemma replace_externs_local: forall mu frgSrc' frgTgt',
      local_of (replace_externs mu frgSrc' frgTgt') = local_of mu.

Lemma replace_externs_priv: forall mu frgSrc' frgTgt',
      priv_of (replace_externs mu frgSrc' frgTgt') = priv_of mu.

Lemma replace_externs_pub: forall mu frgSrc' frgTgt',
      pub_of (replace_externs mu frgSrc' frgTgt') = pub_of mu.

Lemma replace_externs_as_inj: forall mu frgSrc' frgTgt',
      as_inj (replace_externs mu frgSrc' frgTgt') = as_inj mu.

Lemma replace_externs_DOM: forall mu frgSrc' frgTgt',
      DOM (replace_externs mu frgSrc' frgTgt') = DOM mu.

Lemma replace_externs_RNG: forall mu frgSrc' frgTgt',
      RNG (replace_externs mu frgSrc' frgTgt') = RNG mu.

Lemma replace_externs_DomSrc: forall mu frgSrc' frgTgt',
      DomSrc (replace_externs mu frgSrc' frgTgt') = DomSrc mu.

Lemma replace_externs_DomTgt: forall mu frgSrc' frgTgt',
      DomTgt (replace_externs mu frgSrc' frgTgt') = DomTgt mu.

Lemma replace_externs_locBlocksSrc: forall mu frgSrc' frgTgt',
      locBlocksSrc (replace_externs mu frgSrc' frgTgt') = locBlocksSrc mu.

Lemma replace_externs_locBlocksTgt: forall mu frgSrc' frgTgt',
      locBlocksTgt (replace_externs mu frgSrc' frgTgt') = locBlocksTgt mu.

Lemma replace_externs_extBlocksSrc: forall mu frgSrc' frgTgt',
      extBlocksSrc (replace_externs mu frgSrc' frgTgt') = extBlocksSrc mu.

Lemma replace_externs_extBlocksTgt: forall mu frgSrc' frgTgt',
      extBlocksTgt (replace_externs mu frgSrc' frgTgt') = extBlocksTgt mu.

Lemma replace_externs_frgnBlocksSrc: forall mu fSrc' fTgt',
      frgnBlocksSrc (replace_externs mu fSrc' fTgt') = fSrc'.

Lemma replace_externs_frgnBlocksTgt: forall mu fSrc' fTgt',
      frgnBlocksTgt (replace_externs mu fSrc' fTgt') = fTgt'.

Lemma replace_externs_pubBlocksSrc: forall mu frgSrc' frgTgt',
      pubBlocksSrc (replace_externs mu frgSrc' frgTgt') = pubBlocksSrc mu.

Lemma replace_externs_pubBlocksTgt: forall mu frgSrc' frgTgt',
      pubBlocksTgt (replace_externs mu frgSrc' frgTgt') = pubBlocksTgt mu.

Definition getBlocks (V:list val) (b: block): bool :=
   in_dec eq_block b
    (fold_right (fun v L => match v with Vptr b' z => b'::L | _ => L end) nil V).

Lemma getBlocksD: forall v V b,
  getBlocks (v:: V) b =
    match v with
      Vptr b' _  => orb (eq_block b' b) (getBlocks V b)
    | _ => getBlocks V b
   end.

Lemma getBlocksD_nil: forall b,
  getBlocks nil b = false.

Lemma getBlocks_char: forall V b, getBlocks V b = true <->
   exists off, In (Vptr b off) V.

Lemma getBlocks_inject: forall j vals1 vals2
                       (ValInjMu : Forall2 (val_inject j) vals1 vals2)
                       b (B: getBlocks vals1 b = true),
      exists jb d, j b = Some (jb, d) /\ getBlocks vals2 jb = true.

Definition REACH_closed m (X: Values.block -> bool) : Prop :=
  (forall b, REACH m X b = true -> X b = true).

Definition mapped (j:meminj) b : bool :=
  match j b with None => false | Some _ => true end.

Lemma mappedD_true : forall j b (M: mapped j b = true),
                     exists p, j b = Some p.
Lemma mappedD_false : forall j b (M: mapped j b = false),
                      j b = None.
Lemma mappedI_true : forall j b p (J: j b = Some p),
                      mapped j b = true.
Lemma mappedI_false : forall j b (J:j b = None),
                       mapped j b = false.
Lemma mapped_charT: forall j b, (mapped j b = true) <-> (exists p, j b = Some p).
Lemma mapped_charF: forall j b, (mapped j b = false) <-> (j b = None).

Lemma inject_mapped: forall j m1 m2 (Inj12: Mem.inject j m1 m2) k

Lemma restrict_val_inject: forall j val1 val2
     (Inj : val_inject j val1 val2)
     X (HR: forall b, getBlocks (val1::nil) b = true -> X b = true),
   val_inject (restrict j X) val1 val2.

Lemma restrict_forall_vals_inject: forall j vals1 vals2
     (Inj : Forall2 (val_inject j) vals1 vals2)
     X (HR: forall b, getBlocks vals1 b = true -> X b = true),
 Forall2 (val_inject (restrict j X)) vals1 vals2.

Lemma restrict_mapped_closed: forall j m X
      (RC: REACH_closed m (mapped j))
      (RX: REACH_closed m X),
      REACH_closed m (mapped (restrict j X)).

Lemma restrict_mapped_closed_triv: forall j m X,
      REACH_closed m (fun b => mapped j b && X b) =
      REACH_closed m (mapped (restrict j X)).

Lemma REACH_closed_intersection: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b && Y b).

Lemma REACH_closed_union: forall m X Y
        (HX: REACH_closed m X) (HY: REACH_closed m Y),
      REACH_closed m (fun b => X b || Y b).

Lemma inject_REACH_closed: forall j m1 m2 (Inj: Mem.inject j m1 m2),

Lemma inject_restrict: forall j m1 m2 X
        (INJ : Mem.inject j m1 m2)

Definition exportedSrc mu vals b := orb (getBlocks vals b) (sharedSrc mu b).
Definition exportedTgt mu vals b := orb (getBlocks vals b) (sharedTgt mu b).

Lemma exported_inject: forall mu (WD: SM_wd mu) vals1 vals2
          (ValInjMu : Forall2 (val_inject (as_inj mu)) vals1 vals2) b
          (SRC: exportedSrc mu vals1 b = true ),
        exists jb d, as_inj mu b = Some (jb, d)
                  /\ exportedTgt mu vals2 jb = true.

Lemma REACH_shared_of: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (shared_of mu) m1 m2)

Lemma REACH_as_inj: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_as_inj_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_local_REACH': forall mu m1 vals1  b1
        (R : REACH m1 (exportedSrc mu vals1) b1 = true)
        (WD: SM_wd mu) m2 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Lemma REACH_extern_REACH: forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)

Goal forall m1 mu (WD: SM_wd mu) vals b, pubBlocksSrc mu b = true ->
           REACH m1 (exportedSrc mu vals) b = true.

Definition local_out_of_reach mu (m : mem) (b : block) (ofs : Z): Prop :=
  locBlocksTgt mu b = true /\
  forall b0 delta, local_of mu b0 = Some (b, delta) ->
                  (~ Mem.perm m b0 (ofs - delta) Max Nonempty \/
                   pubBlocksSrc mu b0 = false).

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Lemma genvs_domain_eq_match_genvsB: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genv2blocksBool_char1: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2: forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char1': forall F V (ge : Genv.t F V) b,

Lemma genv2blocksBool_char2': forall F V (ge : Genv.t F V) b,

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma restrict_preserves_globals: forall {F V} (ge:Genv.t F V) j X

Lemma genvs_domain_eq_isGlobal: forall {F1 V1 F2 V2} ge1 ge2
                       (DomainEQ: @genvs_domain_eq F1 V1 F2 V2 ge1 ge2),
       isGlobalBlock ge1 = isGlobalBlock ge2.

Lemma meminj_preserves_globals_isGlobalBlock: forall {F V} (g: Genv.t F V)

Lemma meminj_preserves_globals_initSM: forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma meminj_preserves_globals_init_REACH_frgn:
      forall {F1 V1} (ge: Genv.t F1 V1) j

Lemma REACH_is_closed: forall R m1,
  REACH_closed m1 (fun b : block => REACH m1 R b).

Lemma core_initial_wd : forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma intern_incr_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu

Lemma replace_externs_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) nu

Lemma after_external_meminj_preserves_globals:
      forall {F V} (ge: Genv.t F V) mu (WDmu : SM_wd mu)

Definition restrict_sm mu (X:block -> bool) :=
match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection locBSrc locBTgt pSrc pTgt (restrict local X)
                     extBSrc extBTgt fSrc fTgt (restrict extern X)
end.

Lemma restrict_sm_com: forall mu X Y,
      restrict_sm (restrict_sm mu X) Y = restrict_sm (restrict_sm mu Y) X.

Lemma restrict_sm_nest: forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu X) Y = restrict_sm mu Y.

Lemma restrict_sm_nest': forall mu X Y
         (HXY: forall b, Y b = true -> X b = true),
      restrict_sm (restrict_sm mu Y) X = restrict_sm mu Y.

Lemma restrict_sm_local: forall mu X,
      local_of (restrict_sm mu X) = restrict (local_of mu) X.
Lemma restrict_sm_pub: forall mu X,
      pub_of (restrict_sm mu X) = restrict (pub_of mu) X.

Lemma restrict_sm_extern: forall mu X,
      extern_of (restrict_sm mu X) = restrict (extern_of mu) X.
Lemma restrict_sm_foreign: forall mu X,
      foreign_of (restrict_sm mu X) = restrict (foreign_of mu) X.

Lemma restrict_sm_all: forall mu X,
       as_inj (restrict_sm mu X) = restrict (as_inj mu) X.

Lemma restrict_sm_local': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      local_of (restrict_sm mu X) = local_of mu.

Lemma restrict_sm_pub': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true ->
                     X b = true),
      pub_of (restrict_sm mu X) = pub_of mu.

Lemma restrict_sm_foreign': forall mu (WD: SM_wd mu) X
      (HX: forall b, vis mu b = true -> X b = true),
      foreign_of (restrict_sm mu X) = foreign_of mu.

Lemma restrict_sm_locBlocksSrc: forall mu X,
      locBlocksSrc (restrict_sm mu X) = locBlocksSrc mu.
Lemma restrict_sm_extBlocksSrc: forall mu X,
      extBlocksSrc (restrict_sm mu X) = extBlocksSrc mu.
Lemma restrict_sm_pubBlocksSrc: forall mu X,
      pubBlocksSrc (restrict_sm mu X) = pubBlocksSrc mu.
Lemma restrict_sm_frgnBlocksSrc: forall mu X,
      frgnBlocksSrc (restrict_sm mu X) = frgnBlocksSrc mu.
Lemma restrict_sm_DomSrc: forall mu X,
      DomSrc (restrict_sm mu X) = DomSrc mu.
Lemma restrict_sm_DOM: forall mu X,
      DOM (restrict_sm mu X) = DOM mu.

Lemma restrict_sm_locBlocksTgt: forall mu X,
      locBlocksTgt (restrict_sm mu X) = locBlocksTgt mu.
Lemma restrict_sm_extBlocksTgt: forall mu X,
      extBlocksTgt (restrict_sm mu X) = extBlocksTgt mu.
Lemma restrict_sm_pubBlocksTgt: forall mu X,
      pubBlocksTgt (restrict_sm mu X) = pubBlocksTgt mu.
Lemma restrict_sm_frgnBlocksTgt: forall mu X,
      frgnBlocksTgt (restrict_sm mu X) = frgnBlocksTgt mu.
Lemma restrict_sm_DomTgt: forall mu X,
      DomTgt (restrict_sm mu X) = DomTgt mu.
Lemma restrict_sm_RNG: forall mu X,
      RNG (restrict_sm mu X) = RNG mu.

Lemma restrict_sm_WD:
      forall mu (WD: SM_wd mu) X
          (HX: forall b, vis mu b = true -> X b = true),
      SM_wd (restrict_sm mu X).

Lemma restrict_sm_preserves_globals: forall {F V} (ge:Genv.t F V) mu X

Definition mkinitial_SM (mu: SM_Injection) frgnS frgnT :=
  match mu with
  Build_SM_Injection locBSrc locBTgt pSrc pTgt local extBSrc extBTgt fSrc fTgt extern =>
  Build_SM_Injection (fun b => false) (fun b => false) (fun b => false) (fun b => false) (fun b => None)
                     (DomSrc mu) (DomTgt mu) frgnS frgnT (as_inj mu)
  end.

Lemma mkinitial_SM_as_inj: forall mu S T,
  as_inj (mkinitial_SM mu S T) = as_inj mu.
Lemma mkinitial_SM_local: forall mu S T,
  local_of (mkinitial_SM mu S T) = fun b => None.
Lemma mkinitial_SM_extern: forall mu S T,
  extern_of (mkinitial_SM mu S T) = as_inj mu.

Lemma mkinitial_SM_foreign: forall mu S T b1,
  foreign_of (mkinitial_SM mu S T) b1 =
  if S b1 then as_inj mu b1 else None.

Lemma mkinitial_SM_DomSrc: forall mu S T,
  DomSrc (mkinitial_SM mu S T) = DomSrc mu.
Lemma mkinitial_SM_DOM: forall mu S T,
  DOM (mkinitial_SM mu S T) = DOM mu.
Lemma mkinitial_SM_DomTgt: forall mu S T,
  DomTgt (mkinitial_SM mu S T) = DomTgt mu.
Lemma mkinitial_SM_RBG: forall mu S T,
  RNG (mkinitial_SM mu S T) = RNG mu.

Lemma mkinitial_SM_equals_initial_SM: forall mu S T,
  mkinitial_SM mu S T = initial_SM (DomSrc mu) (DomTgt mu) S T (as_inj mu).

Lemma mkinitial_SM_ok: forall {F1 V1 F2 V2:Type}
        (g1: Genv.t F1 V1) (g2: Genv.t F2 V2) (G:genvs_domain_eq g1 g2)

Module SM_simulation. Section SharedMemory_simulation_inject.
  Context {F1 V1 C1 F2 V2 C2:Type}
          (Sem1 : @EffectSem (Genv.t F1 V1) C1)
          (Sem2 : @EffectSem (Genv.t F2 V2) C2)
          (ge1: Genv.t F1 V1)
          (ge2: Genv.t F2 V2)
          (entry_points : list (val * val * signature)).

  Record SM_simulation_inject :=
  { core_data : Type;
    match_state : core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop;
    core_ord : core_data -> core_data -> Prop;
    core_ord_wf : well_founded core_ord;

    match_sm_wd: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          SM_wd mu;

    genvs_dom_eq: genvs_domain_eq ge1 ge2;

    match_genv: forall d mu c1 m1 c2 m2 (MC:match_state d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true);

    match_visible: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu);

    match_restrict: forall d mu c1 m1 c2 m2 X,
          match_state d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_state d (restrict_sm mu X) c1 m1 c2 m2;

    match_validblocks: forall d mu c1 m1 c2 m2,
          match_state d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2;

    core_initial : forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists cd, exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_state cd (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2;

    core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall cd st2 mu m2,
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_state cd' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            core_ord cd' cd);

      effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall cd st2 mu m2
        (UHyp: forall b1 z, U1 b1 z = true -> Mem.valid_block m1 b1 ->
                            vis mu b1 = true),
        match_state cd mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists cd', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\

          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_state cd' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               core_ord cd' cd)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)));

    core_halted : forall cd mu c1 m1 c2 m2 v1,
      match_state cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2;

    core_at_external :
      forall cd mu c1 m1 c2 m2 e vals1 ef_sig,
        match_state cd mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\

         exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2));

    eff_after_external:
      forall cd mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_state cd mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

         (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

         (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
        exists cd', exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_state cd' mu' st1' m1' st2' m2'
}.

End SharedMemory_simulation_inject.

End SM_simulation. *)

Require Import sepcomp.effect_properties.

Require Import effect_simulations_lemmas.
(* effect_simulations_lemmas:
Require Import Events.
Require Import Memory.
Require Import Coqlib.
Require Import compcert.common.Values.
Require Import Maps.
Require Import Integers.
Require Import AST.
Require Import Globalenvs.

Require Import Axioms.
Require Import sepcomp.mem_lemmas. 
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
Require Import sepcomp.StructuredInjections.

Require Import effect_simulations.

Section Eff_INJ_SIMU_DIAGRAMS.
  Context {F1 V1 C1 F2 V2 C2:Type}
          {Sem1 : @EffectSem (Genv.t F1 V1) C1}
          {Sem2 : @EffectSem (Genv.t F2 V2) C2}

          {ge1: Genv.t F1 V1}
          {ge2: Genv.t F2 V2}
          {entry_points : list (val * val * signature)}.

  Let core_data := C1.

  Variable match_states: core_data -> SM_Injection -> C1 -> mem -> C2 -> mem -> Prop.

   Hypothesis genvs_dom_eq: genvs_domain_eq ge1 ge2.

   Hypothesis match_sm_wd: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          SM_wd mu.

    Hypothesis match_visible: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          REACH_closed m1 (vis mu).

    Hypothesis match_restrict: forall d mu c1 m1 c2 m2 X,
          match_states d mu c1 m1 c2 m2 ->
          (forall b, vis mu b = true -> X b = true) ->
          REACH_closed m1 X ->
          match_states d (restrict_sm mu X) c1 m1 c2 m2.

   Hypothesis match_validblocks: forall d mu c1 m1 c2 m2,
          match_states d mu c1 m1 c2 m2 ->
          sm_valid mu m1 m2.

    Hypothesis match_genv: forall d mu c1 m1 c2 m2 (MC:match_states d mu c1 m1 c2 m2),
          meminj_preserves_globals ge1 (extern_of mu) /\
          (forall b, isGlobalBlock ge1 b = true -> frgnBlocksSrc mu b = true).

   Hypothesis inj_initial_cores: forall v1 v2 sig,
       In (v1,v2,sig) entry_points ->
       forall vals1 c1 m1 j vals2 m2 DomS DomT,
          initial_core Sem1 ge1 v1 vals1 = Some c1 ->
          Mem.inject j m1 m2 ->
          Forall2 (val_inject j) vals1 vals2 ->
          meminj_preserves_globals ge1 j ->

         (forall b1 b2 d, j b1 = Some (b2, d) ->
                          DomS b1 = true /\ DomT b2 = true) ->
         (forall b, REACH m2 (fun b' => isGlobalBlock ge2 b' || getBlocks vals2 b') b = true -> DomT b = true) ->

         (forall b, DomS b = true -> Mem.valid_block m1 b) ->
         (forall b, DomT b = true -> Mem.valid_block m2 b) ->

       exists c2,
            initial_core Sem2 ge2 v2 vals2 = Some c2 /\
            match_states c1 (initial_SM DomS
                                       DomT
                                       (REACH m1 (fun b => isGlobalBlock ge1 b || getBlocks vals1 b))
                                       (REACH m2 (fun b => isGlobalBlock ge2 b || getBlocks vals2 b)) j)
                           c1 m1 c2 m2.

  Hypothesis inj_halted : forall cd mu c1 m1 c2 m2 v1,
      match_states cd mu c1 m1 c2 m2 ->
      halted Sem1 c1 = Some v1 ->

      exists v2,
             Mem.inject (as_inj mu) m1 m2 /\
             val_inject (restrict (as_inj mu) (vis mu)) v1 v2 /\
             halted Sem2 c2 = Some v2.

  Hypothesis inj_at_external :
      forall mu c1 m1 c2 m2 e vals1 ef_sig,
        match_states c1 mu c1 m1 c2 m2 ->
        at_external Sem1 c1 = Some (e,ef_sig,vals1) ->
        ( Mem.inject (as_inj mu) m1 m2 /\
          exists vals2,
            Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2 /\
            at_external Sem2 c2 = Some (e,ef_sig,vals2)).

  Hypothesis inj_after_external:
      forall mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'
        (MemInjMu: Mem.inject (as_inj mu) m1 m2)
        (MatchMu: match_states st1 mu st1 m1 st2 m2)
        (AtExtSrc: at_external Sem1 st1 = Some (e,ef_sig,vals1))

        (AtExtTgt: at_external Sem2 st2 = Some (e',ef_sig',vals2))

        (ValInjMu: Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

        pubSrc' (pubSrcHyp: pubSrc' = fun b => andb (locBlocksSrc mu b)
                                                    (REACH m1 (exportedSrc mu vals1) b))

        pubTgt' (pubTgtHyp: pubTgt' = fun b => andb (locBlocksTgt mu b)
                                                    (REACH m2 (exportedTgt mu vals2) b))

        nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt'),

      forall nu' ret1 m1' ret2 m2'
        (INC: extern_incr nu nu')
        (SEP: sm_inject_separated nu nu' m1 m2)

        (WDnu': SM_wd nu') (SMvalNu': sm_valid nu' m1' m2')

        (MemInjNu': Mem.inject (as_inj nu') m1' m2')
        (RValInjNu': val_inject (as_inj nu') ret1 ret2)

        (FwdSrc: mem_forward m1 m1') (FwdTgt: mem_forward m2 m2')

        frgnSrc' (frgnSrcHyp: frgnSrc' = fun b => andb (DomSrc nu' b)
                                                 (andb (negb (locBlocksSrc nu' b))
                                                       (REACH m1' (exportedSrc nu' (ret1::nil)) b)))

        frgnTgt' (frgnTgtHyp: frgnTgt' = fun b => andb (DomTgt nu' b)
                                                 (andb (negb (locBlocksTgt nu' b))
                                                       (REACH m2' (exportedTgt nu' (ret2::nil)) b)))

        mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

        (UnchPrivSrc: Mem.unchanged_on (fun b ofs => locBlocksSrc nu b = true /\
                                                      pubBlocksSrc nu b = false) m1 m1')

        (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),
       exists st1', exists st2',
          after_external Sem1 (Some ret1) st1 = Some st1' /\
          after_external Sem2 (Some ret2) st2 = Some st2' /\
          match_states st1' mu' st1' m1' st2' m2'.

Section EFF_INJ_SIMULATION_STAR_WF.
Variable order: C1 -> C1 -> Prop.
Hypothesis order_wf: well_founded order.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            corestep_star Sem2 ge2 st2 m2 st2' m2' /\
            order st1' st1).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b z, U1 b z = true -> Mem.valid_block m1 b ->
                           vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            ((effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
              (effstep_star Sem2 ge2 U2 st2 m2 st2' m2' /\
               order st1' st1)) /\

             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty))).

Lemma  inj_simulation_star_wf:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR_WF.

Section EFF_INJ_SIMULATION_STAR.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                  vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_star:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_STAR.

Section EFF_INJ_SIMULATION_PLUS.
  Variable measure: C1 -> nat.

  Hypothesis inj_core_diagram :
      forall st1 m1 st1' m1',
        corestep Sem1 ge1 st1 m1 st1' m1' ->
      forall st2 mu m2,
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\
          match_states st1' mu' st1' m1' st2' m2' /\

          SM_wd mu' /\ sm_valid mu' m1' m2' /\

          ((corestep_plus Sem2 ge2 st2 m2 st2' m2') \/
            ((measure st1' < measure st1)%nat /\ corestep_star Sem2 ge2 st2 m2 st2' m2')).

  Hypothesis inj_effcore_diagram :
      forall st1 m1 st1' m1' U1,
        effstep Sem1 ge1 U1 st1 m1 st1' m1' ->

      forall st2 mu m2
        (UHyp: forall b ofs, U1 b ofs = true -> Mem.valid_block m1 b ->
                             vis mu b = true),
        match_states st1 mu st1 m1 st2 m2 ->
        exists st2', exists m2', exists mu',
          intern_incr mu mu' /\
          sm_inject_separated mu mu' m1 m2 /\
          sm_locally_allocated mu mu' m1 m2 m1' m2' /\

          match_states st1' mu' st1' m1' st2' m2' /\

          exists U2,
            (effstep_plus Sem2 ge2 U2 st2 m2 st2' m2' \/
             ((measure st1' < measure st1)%nat /\ effstep_star Sem2 ge2 U2 st2 m2 st2' m2'))
            /\
             forall b ofs, U2 b ofs = true ->
                       (Mem.valid_block m2 b /\
                         (locBlocksTgt mu b = false ->
                           exists b1 delta1, foreign_of mu b1 = Some(b,delta1) /\
                           U1 b1 (ofs-delta1) = true /\
                           Mem.perm m1 b1 (ofs-delta1) Max Nonempty)).

Lemma inj_simulation_plus:
  SM_simulation.SM_simulation_inject Sem1 Sem2 ge1 ge2 entry_points.

End EFF_INJ_SIMULATION_PLUS.

End Eff_INJ_SIMU_DIAGRAMS.

Definition compose_sm (mu1 mu2 : SM_Injection) : SM_Injection :=
 Build_SM_Injection
   (locBlocksSrc mu1) (locBlocksTgt mu2)
   (pubBlocksSrc mu1) (pubBlocksTgt mu2)
   (compose_meminj (local_of mu1) (local_of mu2))
   (extBlocksSrc mu1) (extBlocksTgt mu2)
   (frgnBlocksSrc mu1) (frgnBlocksTgt mu2)
   (compose_meminj (extern_of mu1) (extern_of mu2)).

Lemma compose_sm_valid: forall mu1 mu2 m1 m2 m2' m3
          (SMV1: sm_valid mu1 m1 m2) (SMV2: sm_valid mu2 m2' m3),
       sm_valid (compose_sm mu1 mu2) m1 m3.

Lemma compose_sm_pub: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      pub_of (compose_sm mu12 mu23) =
      compose_meminj (pub_of mu12) (pub_of mu23).

Lemma compose_sm_DomSrc: forall mu12 mu23,
  DomSrc (compose_sm mu12 mu23) = DomSrc mu12.

Lemma compose_sm_DomTgt: forall mu12 mu23,
  DomTgt (compose_sm mu12 mu23) = DomTgt mu23.

Lemma compose_sm_foreign: forall mu12 mu23
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12),
      foreign_of (compose_sm mu12 mu23) =
      compose_meminj (foreign_of mu12) (foreign_of mu23).

Lemma compose_sm_priv: forall mu12 mu23,
   priv_of (compose_sm mu12 mu23) =
   compose_meminj (priv_of mu12) (local_of mu23).

Lemma compose_sm_unknown: forall mu12 mu23,
   unknown_of (compose_sm mu12 mu23) =
   compose_meminj (unknown_of mu12) (extern_of mu23).

Lemma compose_sm_local: forall mu12 mu23,
   local_of (compose_sm mu12 mu23) =
   compose_meminj (local_of mu12) (local_of mu23).

Lemma compose_sm_extern: forall mu12 mu23,
   extern_of (compose_sm mu12 mu23) =
   compose_meminj (extern_of mu12) (extern_of mu23).

Lemma compose_sm_shared: forall mu12 mu23
         (HypPub: forall b, pubBlocksTgt mu12 b = true ->
                            pubBlocksSrc mu23 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu12 b = true ->
                            frgnBlocksSrc mu23 b = true)
         (WD1:SM_wd mu12) (WD2:SM_wd mu23),
      shared_of (compose_sm mu12 mu23) =
      compose_meminj (shared_of mu12) (shared_of mu23).

Lemma compose_sm_wd: forall mu1 mu2 (WD1: SM_wd mu1) (WD2:SM_wd mu2)
         (HypPub: forall b, pubBlocksTgt mu1 b = true ->
                            pubBlocksSrc mu2 b = true)
         (HypFrg: forall b, frgnBlocksTgt mu1 b = true ->
                            frgnBlocksSrc mu2 b = true),
      SM_wd (compose_sm mu1 mu2).

Lemma compose_sm_as_inj: forall mu12 mu23 (WD1: SM_wd mu12) (WD2: SM_wd mu23)
   (SrcTgtLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
   (SrcTgtExt: extBlocksTgt mu12 = extBlocksSrc mu23),
   as_inj (compose_sm mu12 mu23) =
   compose_meminj (as_inj mu12) (as_inj mu23).

Lemma compose_sm_intern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: intern_incr mu12 mu12')
            (inc23: intern_incr mu23 mu23'),
      intern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma compose_sm_extern_incr:
      forall mu12 mu12' mu23 mu23'
            (inc12: extern_incr mu12 mu12')
            (inc23: extern_incr mu23 mu23')
  (FRG': forall b1 b2 d1, foreign_of mu12' b1 = Some(b2,d1) ->
         exists b3 d2, foreign_of mu23' b2 = Some(b3,d2))
  (WD12': SM_wd mu12') (WD23': SM_wd mu23'),
  extern_incr (compose_sm mu12 mu23) (compose_sm mu12' mu23').

Lemma extern_incr_inject_incr:
      forall nu12 nu23 nu' (WDnu' : SM_wd nu')
          (EXT: extern_incr (compose_sm nu12 nu23) nu')
          (GlueInvNu: SM_wd nu12 /\ SM_wd nu23 /\
                      locBlocksTgt nu12 = locBlocksSrc nu23 /\
                      extBlocksTgt nu12 = extBlocksSrc nu23 /\
                      (forall b, pubBlocksTgt nu12 b = true ->
                                 pubBlocksSrc nu23 b = true) /\
                      (forall b, frgnBlocksTgt nu12 b = true ->
                                 frgnBlocksSrc nu23 b = true)),
      inject_incr (compose_meminj (as_inj nu12) (as_inj nu23)) (as_inj nu').

Lemma compose_sm_as_injD: forall mu1 mu2 b1 b3 d
      (I: as_inj (compose_sm mu1 mu2) b1 = Some (b3, d))
      (WD1: SM_wd mu1) (WD2: SM_wd mu2),
      exists b2 d1 d2, as_inj mu1 b1 = Some(b2,d1) /\
                       as_inj mu2 b2 = Some(b3,d2) /\
                       d=d1+d2.

Lemma compose_sm_intern_separated:
      forall mu12 mu12' mu23 mu23' m1 m2 m3
        (inc12: intern_incr mu12 mu12')
        (inc23: intern_incr mu23 mu23')
        (InjSep12 : sm_inject_separated mu12 mu12' m1 m2)
        (InjSep23 : sm_inject_separated mu23 mu23' m2 m3)
        (WD12: SM_wd mu12) (WD12': SM_wd mu12') (WD23: SM_wd mu23) (WD23': SM_wd mu23')
        (BlocksLoc: locBlocksTgt mu12 = locBlocksSrc mu23)
        (BlocksExt: extBlocksTgt mu12 = extBlocksSrc mu23),
      sm_inject_separated (compose_sm mu12 mu23)
                          (compose_sm mu12' mu23') m1 m3.

Lemma vis_compose_sm: forall mu nu, vis (compose_sm mu nu) = vis mu.

Lemma restrict_compose: forall j k X,
  restrict (compose_meminj j k) X = compose_meminj (restrict j X) k. *)



Lemma storebytes_freshloc: forall m b z bytes m'

  (SB: Mem.storebytes m b z bytes = Some m'),

  freshloc m m' = (fun _ : block => false).

Proof. intros.

  extensionality bb. apply freshloc_charF.

  destruct (valid_block_dec m bb).

    left; trivial.

  right; intros N.

  apply n.

  apply (Mem.storebytes_valid_block_2 _ _ _ _ _ SB _ N).

Qed.



Lemma assign_loc_freshloc: forall ty m b ofs v m' (AL:assign_loc ty m b ofs v m'),

  freshloc m m' = fun b => false.

Proof. intros.

  inv AL. apply (store_freshloc _ _ _ _ _ H0).

  apply (storebytes_freshloc _ _ _ _ _ H4).

Qed.



Remark transl_params_types:

  forall params,

  map typ_of_type (map snd params) = typlist_of_typelist (type_of_params params).

Proof.

  induction params; simpl. auto. destruct a as [id ty]; simpl. f_equal; auto.

Qed.



Lemma transl_fundef_sig1:

  forall f tf args res,

  transl_fundef f = OK tf ->

  classify_fun (type_of_fundef f) = fun_case_f args res ->

  funsig tf = signature_of_type args res.

Proof.

  intros. destruct f; simpl in *.

  monadInv H. monadInv EQ. simpl. inversion H0.

  unfold signature_of_function, signature_of_type.

  f_equal. apply transl_params_types.

  destruct (list_typ_eq (sig_args (ef_sig e)) (typlist_of_typelist t)); simpl in H.

  destruct (opt_typ_eq (sig_res (ef_sig e)) (opttyp_of_type t0)); simpl in H.

  inv H. simpl. destruct (ef_sig e); simpl in *. inv H0.

  unfold signature_of_type. auto.

  congruence.

  congruence.

Qed.



Lemma transl_fundef_sig2:

  forall f tf args res,

  transl_fundef f = OK tf ->

  type_of_fundef f = Tfunction args res ->

  funsig tf = signature_of_type args res.

Proof.

  intros. eapply transl_fundef_sig1; eauto.

  rewrite H0; reflexivity.

Qed.



Lemma transl_expr_lvalue:

  forall ge e le m a loc ofs ta,

  Clight.eval_lvalue ge e le m a loc ofs ->

  transl_expr a = OK ta ->

  (exists tb, transl_lvalue a = OK tb /\ make_load tb (typeof a) = OK ta).

Proof.

  intros until ta; intros EVAL TR. inv EVAL; simpl in TR.

  

  exists (Eaddrof id); auto.

  

  exists (Eaddrof id); auto.

  

  monadInv TR. exists x; auto.

  

  rewrite H0 in TR. monadInv TR.

  econstructor; split. simpl. rewrite H0.

  rewrite EQ; rewrite EQ1; simpl; eauto. auto.

  

  rewrite H0 in TR. monadInv TR.

  econstructor; split. simpl. rewrite H0. rewrite EQ; simpl; eauto. auto.

Qed.



Lemma transl_lbl_stmt_1:

  forall tyret nbrk ncnt n sl tsl,

  transl_lbl_stmt tyret nbrk ncnt sl = OK tsl ->

  transl_lbl_stmt tyret nbrk ncnt (Clight.select_switch n sl) = OK (select_switch n tsl).

Proof.

  induction sl; intros.

  monadInv H. simpl. rewrite EQ. auto.

  generalize H; intro TR. monadInv TR. simpl.

  destruct (Int.eq i n). auto. auto.

Qed.



Lemma transl_lbl_stmt_2:

  forall tyret nbrk ncnt sl tsl,

  transl_lbl_stmt tyret nbrk ncnt sl = OK tsl ->

  transl_statement tyret nbrk ncnt (seq_of_labeled_statement sl) = OK (seq_of_lbl_stmt tsl).

Proof.

  induction sl; intros.

  monadInv H. simpl. auto.

  monadInv H. simpl. rewrite EQ; simpl. rewrite (IHsl _ EQ1). simpl. auto.

Qed.



Section CONSTRUCTORS.



Variable ge: genv.



Lemma make_intconst_correct:

  forall n e le m,

  eval_expr ge e le m (make_intconst n) (Vint n).

Proof.

  intros. unfold make_intconst. econstructor. reflexivity.

Qed.



Lemma make_floatconst_correct:

  forall n e le m,

  eval_expr ge e le m (make_floatconst n) (Vfloat n).

Proof.

  intros. unfold make_floatconst. econstructor. reflexivity.

Qed.



Lemma make_longconst_correct:

  forall n e le m,

  eval_expr ge e le m (make_longconst n) (Vlong n).

Proof.

  intros. unfold make_floatconst. econstructor. reflexivity.

Qed.



Lemma make_floatofint_correct:

  forall a n sg sz e le m,

  eval_expr ge e le m a (Vint n) ->

  eval_expr ge e le m (make_floatofint a sg sz) (Vfloat(cast_int_float sg sz n)).

Proof.

  intros. unfold make_floatofint, cast_int_float.

  destruct sz.

  destruct sg.

  rewrite Float.singleofint_floatofint. econstructor. econstructor; eauto. simpl; reflexivity. auto.

  rewrite Float.singleofintu_floatofintu. econstructor. econstructor; eauto. simpl; reflexivity. auto.

  destruct sg; econstructor; eauto.

Qed.



Lemma make_intoffloat_correct:

  forall e le m a sg f i,

  eval_expr ge e le m a (Vfloat f) ->

  cast_float_int sg f = Some i ->

  eval_expr ge e le m (make_intoffloat a sg) (Vint i).

Proof.

  unfold cast_float_int, make_intoffloat; intros.

  destruct sg; econstructor; eauto; simpl; rewrite H0; auto.

Qed.



Lemma make_longofint_correct:

  forall a n sg e le m,

  eval_expr ge e le m a (Vint n) ->

  eval_expr ge e le m (make_longofint a sg) (Vlong(cast_int_long sg n)).

Proof.

  intros. unfold make_longofint, cast_int_long.

  destruct sg; econstructor; eauto.

Qed.



Lemma make_floatoflong_correct:

  forall a n sg sz e le m,

  eval_expr ge e le m a (Vlong n) ->

  eval_expr ge e le m (make_floatoflong a sg sz) (Vfloat(cast_long_float sg sz n)).

Proof.

  intros. unfold make_floatoflong, cast_int_long.

  destruct sg; destruct sz; econstructor; eauto.

Qed.



Lemma make_longoffloat_correct:

  forall e le m a sg f i,

  eval_expr ge e le m a (Vfloat f) ->

  cast_float_long sg f = Some i ->

  eval_expr ge e le m (make_longoffloat a sg) (Vlong i).

Proof.

  unfold cast_float_long, make_longoffloat; intros.

  destruct sg; econstructor; eauto; simpl; rewrite H0; auto.

Qed.



Hint Resolve make_intconst_correct make_floatconst_correct make_longconst_correct

             make_floatofint_correct make_intoffloat_correct

             make_longofint_correct

             make_floatoflong_correct make_longoffloat_correct

             eval_Eunop eval_Ebinop: cshm.

Hint Extern 2 (@eq trace _ _) => traceEq: cshm.



Lemma make_cmp_ne_zero_correct:

  forall e le m a n,

  eval_expr ge e le m a (Vint n) ->

  eval_expr ge e le m (make_cmp_ne_zero a) (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).

Proof.

  intros.

  assert (DEFAULT: eval_expr ge e le m (Ebinop (Ocmp Cne) a (make_intconst Int.zero))

                                       (Vint (if Int.eq n Int.zero then Int.zero else Int.one))).

    econstructor; eauto with cshm. simpl. unfold Val.cmp, Val.cmp_bool.

    unfold Int.cmp. destruct (Int.eq n Int.zero); auto.

  assert (CMP: forall ob,

               Val.of_optbool ob = Vint n ->

               n = (if Int.eq n Int.zero then Int.zero else Int.one)).

    intros. destruct ob; simpl in H0; inv H0. destruct b; inv H2.

    rewrite Int.eq_false. auto. apply Int.one_not_zero.

    rewrite Int.eq_true. auto.

  destruct a; simpl; auto. destruct b; auto.

  inv H. econstructor; eauto. rewrite H6. decEq. decEq.

  simpl in H6. inv H6. unfold Val.cmp in H0. eauto.

  inv H. econstructor; eauto. rewrite H6. decEq. decEq.

  simpl in H6. inv H6. unfold Val.cmp in H0. eauto.

  inv H. econstructor; eauto. rewrite H6. decEq. decEq.

  simpl in H6. inv H6. unfold Val.cmp in H0. eauto.

  inv H. econstructor; eauto. rewrite H6. decEq. decEq.

  simpl in H6. unfold Val.cmpl in H6.

  destruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.

  inv H. econstructor; eauto. rewrite H6. decEq. decEq.

  simpl in H6. unfold Val.cmplu in H6.

  destruct (Val.cmplu_bool c v1 v2) as [[]|]; inv H6; reflexivity.

Qed.



Lemma make_cast_int_correct:

  forall e le m a n sz si,

  eval_expr ge e le m a (Vint n) ->

  eval_expr ge e le m (make_cast_int a sz si) (Vint (cast_int_int sz si n)).

Proof.

  intros. unfold make_cast_int, cast_int_int.

  destruct sz.

  destruct si; eauto with cshm.

  destruct si; eauto with cshm.

  auto.

  apply make_cmp_ne_zero_correct; auto.

Qed.



Lemma make_cast_float_correct:

  forall e le m a n sz,

  eval_expr ge e le m a (Vfloat n) ->

  eval_expr ge e le m (make_cast_float a sz) (Vfloat (cast_float_float sz n)).

Proof.

  intros. unfold make_cast_float, cast_float_float.

  destruct sz. eauto with cshm. auto.

Qed.



Hint Resolve make_cast_int_correct make_cast_float_correct: cshm.



Lemma make_cast_correct:

  forall e le m a b v ty1 ty2 v',

  make_cast ty1 ty2 a = OK b ->

  eval_expr ge e le m a v ->

  sem_cast v ty1 ty2 = Some v' ->

  eval_expr ge e le m b v'.

Proof.

  intros. unfold make_cast, sem_cast in *;

  destruct (classify_cast ty1 ty2); inv H; destruct v; inv H1; eauto with cshm.

  

  destruct (cast_float_int si2 f) as [i|] eqn:E; inv H2. eauto with cshm.

  

  destruct (cast_float_long si2 f) as [i|] eqn:E; inv H2. eauto with cshm.

  

  econstructor; eauto with cshm.

  simpl. unfold Val.cmpf, Val.cmpf_bool. rewrite Float.cmp_ne_eq.

  destruct (Float.cmp Ceq f Float.zero); auto.

  

  econstructor; eauto with cshm.

  simpl. unfold Val.cmpl, Val.cmpl_bool, Int64.cmp.

  destruct (Int64.eq i Int64.zero); auto.

  

  econstructor; eauto with cshm.

  simpl. unfold Val.cmpu, Val.cmpu_bool, Int.cmpu.

  destruct (Int.eq i Int.zero); auto.

  

  destruct (ident_eq id1 id2 && fieldlist_eq fld1 fld2); inv H2; auto.

  

  destruct (ident_eq id1 id2 && fieldlist_eq fld1 fld2); inv H2; auto.

Qed.



Lemma make_neg_correct:

  forall a tya c va v e le m,

  sem_neg va tya = Some v ->

  make_neg a tya = OK c ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m c v.

Proof.

  unfold sem_neg, make_neg; intros until m; intros SEM MAKE EV1;

  destruct (classify_neg tya); inv MAKE; destruct va; inv SEM; eauto with cshm.

Qed.



Lemma make_notbool_correct:

  forall a tya c va v e le m,

  sem_notbool va tya = Some v ->

  make_notbool a tya = OK c ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m c v.

Proof.

  unfold sem_notbool, make_notbool; intros until m; intros SEM MAKE EV1;

  destruct (classify_bool tya); inv MAKE; destruct va; inv SEM; eauto with cshm.

Qed.



Lemma make_notint_correct:

  forall a tya c va v e le m,

  sem_notint va tya = Some v ->

  make_notint a tya = OK c ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m c v.

Proof.

  unfold sem_notint, make_notint; intros until m; intros SEM MAKE EV1;

  destruct (classify_notint tya); inv MAKE; destruct va; inv SEM; eauto with cshm.

Qed.



Definition binary_constructor_correct

    (make: expr -> type -> expr -> type -> res expr)

    (sem: val -> type -> val -> type -> option val): Prop :=

  forall a tya b tyb c va vb v e le m,

  sem va tya vb tyb = Some v ->

  make a tya b tyb = OK c ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m b vb ->

  eval_expr ge e le m c v.



Section MAKE_BIN.



Variable sem_int: signedness -> int -> int -> option val.

Variable sem_long: signedness -> int64 -> int64 -> option val.

Variable sem_float: float -> float -> option val.

Variables iop iopu fop lop lopu: binary_operation.



Hypothesis iop_ok:

  forall x y m, eval_binop iop (Vint x) (Vint y) m = sem_int Signed x y.

Hypothesis iopu_ok:

  forall x y m, eval_binop iopu (Vint x) (Vint y) m = sem_int Unsigned x y.

Hypothesis lop_ok:

  forall x y m, eval_binop lop (Vlong x) (Vlong y) m = sem_long Signed x y.

Hypothesis lopu_ok:

  forall x y m, eval_binop lopu (Vlong x) (Vlong y) m = sem_long Unsigned x y.

Hypothesis fop_ok:

  forall x y m, eval_binop fop (Vfloat x) (Vfloat y) m = sem_float x y.



Lemma make_binarith_correct:

  binary_constructor_correct

    (make_binarith iop iopu fop lop lopu)

    (sem_binarith sem_int sem_long sem_float).

Proof.

  red; unfold make_binarith, sem_binarith;

  intros until m; intros SEM MAKE EV1 EV2.

  set (cls := classify_binarith tya tyb) in *.

  set (ty := binarith_type cls) in *.

  monadInv MAKE.

  destruct (sem_cast va tya ty) as [va'|] eqn:Ca; try discriminate.

  destruct (sem_cast vb tyb ty) as [vb'|] eqn:Cb; try discriminate.

  exploit make_cast_correct. eexact EQ. eauto. eauto. intros EV1'.

  exploit make_cast_correct. eexact EQ1. eauto. eauto. intros EV2'.

  destruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.

- destruct s; inv H0; econstructor; eauto with cshm.

  rewrite iop_ok; auto. rewrite iopu_ok; auto.

- destruct s; inv H0; econstructor; eauto with cshm.

  rewrite lop_ok; auto. rewrite lopu_ok; auto.

- erewrite <- fop_ok in SEM; eauto with cshm.

Qed.



Lemma make_binarith_int_correct:

  binary_constructor_correct

    (make_binarith_int iop iopu lop lopu)

    (sem_binarith sem_int sem_long (fun x y => None)).

Proof.

  red; unfold make_binarith_int, sem_binarith;

  intros until m; intros SEM MAKE EV1 EV2.

  set (cls := classify_binarith tya tyb) in *.

  set (ty := binarith_type cls) in *.

  monadInv MAKE.

  destruct (sem_cast va tya ty) as [va'|] eqn:Ca; try discriminate.

  destruct (sem_cast vb tyb ty) as [vb'|] eqn:Cb; try discriminate.

  exploit make_cast_correct. eexact EQ. eauto. eauto. intros EV1'.

  exploit make_cast_correct. eexact EQ1. eauto. eauto. intros EV2'.

  destruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.

- destruct s; inv H0; econstructor; eauto with cshm.

  rewrite iop_ok; auto. rewrite iopu_ok; auto.

- destruct s; inv H0; econstructor; eauto with cshm.

  rewrite lop_ok; auto. rewrite lopu_ok; auto.

Qed.



End MAKE_BIN.



Hint Extern 2 (@eq (option val) _ _) => (simpl; reflexivity) : cshm.



Lemma make_add_correct: binary_constructor_correct make_add sem_add.

Proof.

  red; unfold make_add, sem_add;

  intros until m; intros SEM MAKE EV1 EV2;

  destruct (classify_add tya tyb); inv MAKE.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- eapply make_binarith_correct; eauto; intros; auto.

Qed.



Lemma make_sub_correct: binary_constructor_correct make_sub sem_sub.

Proof.

  red; unfold make_sub, sem_sub;

  intros until m; intros SEM MAKE EV1 EV2;

  destruct (classify_sub tya tyb); inv MAKE.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- destruct va; try discriminate; destruct vb; inv SEM.

  destruct (eq_block b0 b1); try discriminate. destruct (Int.eq (Int.repr (sizeof ty)) Int.zero) eqn:E; inv H0.

  econstructor; eauto with cshm. rewrite dec_eq_true. simpl. rewrite E; auto.

- destruct va; try discriminate; destruct vb; inv SEM; eauto with cshm.

- eapply make_binarith_correct; eauto; intros; auto.

Qed.



Lemma make_mul_correct: binary_constructor_correct make_mul sem_mul.

Proof.

  apply make_binarith_correct; intros; auto.

Qed.



Lemma make_div_correct: binary_constructor_correct make_div sem_div.

Proof.

  apply make_binarith_correct; intros; auto.

Qed.



Lemma make_mod_correct: binary_constructor_correct make_mod sem_mod.

Proof.

  apply make_binarith_int_correct; intros; auto.

Qed.



Lemma make_and_correct: binary_constructor_correct make_and sem_and.

Proof.

  apply make_binarith_int_correct; intros; auto.

Qed.



Lemma make_or_correct: binary_constructor_correct make_or sem_or.

Proof.

  apply make_binarith_int_correct; intros; auto.

Qed.



Lemma make_xor_correct: binary_constructor_correct make_xor sem_xor.

Proof.

  apply make_binarith_int_correct; intros; auto.

Qed.



Ltac comput val :=

  let x := fresh in set val as x in *; vm_compute in x; subst x.



Remark small_shift_amount_1:

  forall i,

  Int64.ltu i Int64.iwordsize = true ->

  Int.ltu (Int64.loword i) Int64.iwordsize' = true

  /\ Int64.unsigned i = Int.unsigned (Int64.loword i).

Proof.

  intros. apply Int64.ltu_inv in H. comput (Int64.unsigned Int64.iwordsize).

  assert (Int64.unsigned i = Int.unsigned (Int64.loword i)).

  {

    unfold Int64.loword. rewrite Int.unsigned_repr; auto.

    comput Int.max_unsigned; omega.

  }

  split; auto. unfold Int.ltu. apply zlt_true. rewrite <- H0. tauto.

Qed.



Remark small_shift_amount_2:

  forall i,

  Int64.ltu i (Int64.repr 32) = true ->

  Int.ltu (Int64.loword i) Int.iwordsize = true.

Proof.

  intros. apply Int64.ltu_inv in H. comput (Int64.unsigned (Int64.repr 32)).

  assert (Int64.unsigned i = Int.unsigned (Int64.loword i)).

  {

    unfold Int64.loword. rewrite Int.unsigned_repr; auto.

    comput Int.max_unsigned; omega.

  }

  unfold Int.ltu. apply zlt_true. rewrite <- H0. tauto.

Qed.



Lemma small_shift_amount_3:

  forall i,

  Int.ltu i Int64.iwordsize' = true ->

  Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i.

Proof.

  intros. apply Int.ltu_inv in H. comput (Int.unsigned Int64.iwordsize').

  apply Int64.unsigned_repr. comput Int64.max_unsigned; omega.

Qed.



Lemma make_shl_correct: binary_constructor_correct make_shl sem_shl.

Proof.

  red; unfold make_shl, sem_shl, sem_shift;

  intros until m; intros SEM MAKE EV1 EV2;

  destruct (classify_shift tya tyb); inv MAKE;

  destruct va; try discriminate; destruct vb; try discriminate.

- destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.

  econstructor; eauto. simpl; rewrite E; auto.

- destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.

  exploit small_shift_amount_1; eauto. intros [A B].

  econstructor; eauto with cshm. simpl. rewrite A.

  f_equal; f_equal. unfold Int64.shl', Int64.shl. rewrite B; auto.

- destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.

  econstructor; eauto with cshm. simpl. rewrite small_shift_amount_2; auto.

- destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.

  econstructor; eauto with cshm. simpl. rewrite E.

  unfold Int64.shl', Int64.shl. rewrite small_shift_amount_3; auto.

Qed.



Lemma make_shr_correct: binary_constructor_correct make_shr sem_shr.

Proof.

  red; unfold make_shr, sem_shr, sem_shift;

  intros until m; intros SEM MAKE EV1 EV2;

  destruct (classify_shift tya tyb); inv MAKE;

  destruct va; try discriminate; destruct vb; try discriminate.

- destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.

  destruct s; inv H0; econstructor; eauto; simpl; rewrite E; auto.

- destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.

  exploit small_shift_amount_1; eauto. intros [A B].

  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;

  f_equal; f_equal.

  unfold Int64.shr', Int64.shr; rewrite B; auto.

  unfold Int64.shru', Int64.shru; rewrite B; auto.

- destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.

  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite small_shift_amount_2; auto.

- destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.

  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite E.

  unfold Int64.shr', Int64.shr; rewrite small_shift_amount_3; auto.

  unfold Int64.shru', Int64.shru; rewrite small_shift_amount_3; auto.

Qed.



Lemma make_cmp_correct:

  forall cmp a tya b tyb c va vb v e le m,

  sem_cmp cmp va tya vb tyb m = Some v ->

  make_cmp cmp a tya b tyb = OK c ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m b vb ->

  eval_expr ge e le m c v.

Proof.

  unfold sem_cmp, make_cmp; intros until m; intros SEM MAKE EV1 EV2;

  destruct (classify_cmp tya tyb).

- inv MAKE. destruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bv|] eqn:E;

  simpl in SEM; inv SEM.

  econstructor; eauto. simpl. unfold Val.cmpu. rewrite E. auto.

- inv MAKE. destruct vb; try discriminate.

  set (vb := Vint (Int.repr (Int64.unsigned i))) in *.

  destruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bv|] eqn:E;

  simpl in SEM; inv SEM.

  econstructor; eauto with cshm. simpl. change (Vint (Int64.loword i)) with vb.

  unfold Val.cmpu. rewrite E. auto.

- inv MAKE. destruct va; try discriminate.

  set (va := Vint (Int.repr (Int64.unsigned i))) in *.

  destruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bv|] eqn:E;

  simpl in SEM; inv SEM.

  econstructor; eauto with cshm. simpl. change (Vint (Int64.loword i)) with va.

  unfold Val.cmpu. rewrite E. auto.

- eapply make_binarith_correct; eauto; intros; auto.

Qed.



Lemma transl_unop_correct:

  forall op a tya c va v e le m,

  transl_unop op a tya = OK c ->

  sem_unary_operation op va tya = Some v ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m c v.

Proof.

  intros. destruct op; simpl in *.

  eapply make_notbool_correct; eauto.

  eapply make_notint_correct; eauto.

  eapply make_neg_correct; eauto.

Qed.



Lemma transl_binop_correct:

  forall op a tya b tyb c va vb v e le m,

  transl_binop op a tya b tyb = OK c ->

  sem_binary_operation op va tya vb tyb m = Some v ->

  eval_expr ge e le m a va ->

  eval_expr ge e le m b vb ->

  eval_expr ge e le m c v.

Proof.

  intros. destruct op; simpl in *.

  eapply make_add_correct; eauto.

  eapply make_sub_correct; eauto.

  eapply make_mul_correct; eauto.

  eapply make_div_correct; eauto.

  eapply make_mod_correct; eauto.

  eapply make_and_correct; eauto.

  eapply make_or_correct; eauto.

  eapply make_xor_correct; eauto.

  eapply make_shl_correct; eauto.

  eapply make_shr_correct; eauto.

  eapply make_cmp_correct; eauto.

  eapply make_cmp_correct; eauto.

  eapply make_cmp_correct; eauto.

  eapply make_cmp_correct; eauto.

  eapply make_cmp_correct; eauto.

  eapply make_cmp_correct; eauto.

Qed.



Lemma make_load_correct:

  forall addr ty code b ofs v e le m,

  make_load addr ty = OK code ->

  eval_expr ge e le m addr (Vptr b ofs) ->

  deref_loc ty m b ofs v ->

  eval_expr ge e le m code v.

Proof.

  unfold make_load; intros until m; intros MKLOAD EVEXP DEREF.

  inv DEREF.

  

  rewrite H in MKLOAD. inv MKLOAD. apply eval_Eload with (Vptr b ofs); auto.

  

  rewrite H in MKLOAD. inv MKLOAD. auto.

  

  rewrite H in MKLOAD. inv MKLOAD. auto.

Qed.



Lemma make_store_correct:

  forall addr ty rhs code e le m b ofs v m' f k,

  make_store addr ty rhs = OK code ->

  eval_expr ge e le m addr (Vptr b ofs) ->

  eval_expr ge e le m rhs v ->

  assign_loc ty m b ofs v m' ->

  CSharpMin_corestep ge (CSharpMin_State f code k e le) m

                        (CSharpMin_State f Sskip k e le) m'.

Proof.

  unfold make_store. intros until k; intros MKSTORE EV1 EV2 ASSIGN.

  inversion ASSIGN; subst.

  

  rewrite H in MKSTORE; inv MKSTORE.

  econstructor; eauto.

  

  rewrite H in MKSTORE; inv MKSTORE.

  admit. 

    

Qed.



Lemma make_store_correct_StoreEffect:

  forall addr ty rhs code e le m b ofs v m' f k,

  make_store addr ty rhs = OK code ->

  eval_expr ge e le m addr (Vptr b ofs) ->

  eval_expr ge e le m rhs v ->

  assign_loc ty m b ofs v m' ->

  match access_mode ty with

   By_value chunk =>

             effstep csharpmin_eff_sem ge

                (StoreEffect (Vptr b ofs) (encode_val chunk v))

                (CSharpMin_State f code k e le) m

                (CSharpMin_State f Sskip k e le) m'

| By_copy => True 


  | _ => False

  end.

Proof.

  unfold make_store. intros until k; intros MKSTORE EV1 EV2 ASSIGN.

  inversion ASSIGN; subst.

  

  rewrite H in MKSTORE; inv MKSTORE.

  rewrite H. econstructor; eauto.

  

  rewrite H in MKSTORE; inv MKSTORE.

  rewrite H.

  admit. 

  

Qed.



Lemma make_store_correct_AssignlocEffect:

  forall addr ty rhs code e le m b ofs v m' f k,

  make_store addr ty rhs = OK code ->

  eval_expr ge e le m addr (Vptr b ofs) ->

  eval_expr ge e le m rhs v ->

  assign_loc ty m b ofs v m' ->

  effstep csharpmin_eff_sem ge

          (assign_loc_Effect ty b ofs v)

          (CSharpMin_State f code k e le) m

          (CSharpMin_State f Sskip k e le) m'.

Proof.

  unfold make_store. intros until k; intros MKSTORE EV1 EV2 ASSIGN.

  inversion ASSIGN; subst.

  

  rewrite H in MKSTORE; inv MKSTORE.

  eapply csharpmin_effstep_sub_val; try (econstructor; eauto).

  unfold StoreEffect, assign_loc_Effect; intros.

  rewrite H. apply H2.

  

  admit. 

  
Qed.



End CONSTRUCTORS.



Section CORRECTNESS.



Variable prog: Clight.program.

Variable tprog: Csharpminor.program.

Hypothesis TRANSL: transl_program prog = OK tprog.



Let ge : Clight.genv := Genv.globalenv prog.

Let tge : Csharpminor.genv := Genv.globalenv tprog.



Lemma symbols_preserved:

  forall s, Genv.find_symbol tge s = Genv.find_symbol ge s.

Proof (Genv.find_symbol_transf_partial2 transl_fundef transl_globvar _ TRANSL).



Lemma functions_translated:

  forall v f,

  Genv.find_funct ge v = Some f ->

  exists tf, Genv.find_funct tge v = Some tf /\ transl_fundef f = OK tf.

Proof (Genv.find_funct_transf_partial2 transl_fundef transl_globvar _ TRANSL).



Lemma function_ptr_translated:

  forall b f,

  Genv.find_funct_ptr ge b = Some f ->

  exists tf, Genv.find_funct_ptr tge b = Some tf /\ transl_fundef f = OK tf.

Proof (Genv.find_funct_ptr_transf_partial2 transl_fundef transl_globvar _ TRANSL).



Lemma var_info_translated:

  forall b v,

  Genv.find_var_info ge b = Some v ->

  exists tv, Genv.find_var_info tge b = Some tv /\ transf_globvar transl_globvar v = OK tv.

Proof (Genv.find_var_info_transf_partial2 transl_fundef transl_globvar _ TRANSL).



Lemma var_info_rev_translated:

  forall b tv,

  Genv.find_var_info tge b = Some tv ->

  exists v, Genv.find_var_info ge b = Some v /\ transf_globvar transl_globvar v = OK tv.

Proof (Genv.find_var_info_rev_transf_partial2 transl_fundef transl_globvar _ TRANSL).



Lemma block_is_volatile_preserved:

  forall b, block_is_volatile tge b = block_is_volatile ge b.

Proof.

  intros. unfold block_is_volatile.

  destruct (Genv.find_var_info ge b) eqn:?.

  exploit var_info_translated; eauto. intros [tv [A B]]. rewrite A.

  unfold transf_globvar in B. monadInv B. auto.

  destruct (Genv.find_var_info tge b) eqn:?.

  exploit var_info_rev_translated; eauto. intros [tv [A B]]. congruence.

  auto.

Qed.



Definition globalfunction_ptr_inject (j:meminj):=

  forall b f, Genv.find_funct_ptr ge b = Some f ->

              j b = Some(b,0) /\ isGlobalBlock ge b = true.



Lemma restrict_preserves_globalfun_ptr: forall j X

  (PG : globalfunction_ptr_inject j)

  (Glob : forall b, isGlobalBlock ge b = true -> X b = true),

globalfunction_ptr_inject (restrict j X).

Proof. intros.

  red; intros.

  destruct (PG _ _ H). split; trivial.

  apply restrictI_Some; try eassumption.

  apply (Glob _ H1).

Qed.



Lemma restrict_GFP_vis: forall mu

  (GFP : globalfunction_ptr_inject (as_inj mu))

  (Glob : forall b, isGlobalBlock ge b = true ->

                    frgnBlocksSrc mu b = true),

  globalfunction_ptr_inject (restrict (as_inj mu) (vis mu)).

Proof. intros.

  unfold vis.

  eapply restrict_preserves_globalfun_ptr. eassumption.

  intuition.

Qed.



Remark val_inject_function_pointer:

  forall v fd j tv,

  Genv.find_funct ge v = Some fd ->

  globalfunction_ptr_inject j ->

  val_inject j v tv ->

  tv = v.

Proof.

  intros. exploit Genv.find_funct_inv; eauto. intros [b EQ]. subst v.

  inv H1.

  rewrite Genv.find_funct_find_funct_ptr in H.

  destruct (H0 _ _ H).

  rewrite H1 in H4; inv H4.

  rewrite Int.add_zero. trivial.

Qed.



Record match_env (j:meminj) (e: Clight.env) (te: Csharpminor.env) : Prop :=

  mk_match_env {

    me_local:

      forall id b ty,

      e!id = Some (b, ty) -> exists b',

                             j b = Some(b',0) /\ te!id = Some(b', sizeof ty);

    me_local_inv:

      forall id b sz,

      te!id = Some (b, sz) -> exists b' ty,

                             j b' = Some(b,0) /\e!id = Some(b', ty)

  }.



Lemma match_env_inject_incr: forall j e te

       (MENV : match_env j e te) j'

       (INC: inject_incr j j'),

     match_env j' e te.

Proof. intros.

  destruct MENV as [MENVa MENVb].

  split; intros.

    destruct (MENVa _ _ _ H) as [b' [J Eb]].

      apply INC in J.

      exists b'; split; trivial.

    destruct (MENVb _ _ _ H) as [b' [tp [J Eb]]].

      apply INC in J.

      exists b', tp; split; trivial.

Qed.



Lemma match_env_restrictD: forall j X e te

       (MENV : match_env (restrict j X) e te),

     match_env j e te.

Proof. intros.

  eapply match_env_inject_incr; try eassumption.

  eapply restrict_incr.

Qed.



Lemma match_env_globals:

  forall j e te id,

  match_env j e te ->

  e!id = None ->

  te!id = None.

Proof.

  intros. destruct (te!id) as [[b sz] | ] eqn:?; auto.

  exploit me_local_inv; eauto. intros [b' [ty [J EQ]]]. congruence.

Qed.



Lemma match_env_same_blocks: forall j e te

      (ENV: match_env j e te),

   list_forall2

      (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>

               fst i_x = fst i_y /\

               j (fst (snd i_x)) = Some (fst (snd i_y), 0) /\

               snd (snd i_y) = sizeof (snd (snd i_x)))

  (PTree.elements e) (PTree.elements te).

Proof. intros.

assert (HH1: forall (i : positive) (x : block * type),

     e ! i = Some x -> exists y : block * Z, te ! i = Some y /\

          j (fst x) = Some (fst y,0)

      /\ snd y = sizeof (snd x)).

  intros. destruct ENV. destruct x.

  destruct (me_local0 _ _ _ H) as [b' [J T]].

   exists (b', sizeof t). simpl. split; trivial. split; trivial.

assert(HH2: forall (i : positive) (y : block * Z),

  te ! i = Some y ->

  exists x : block * type, e ! i = Some x /\ j (fst x) = Some (fst y, 0)

        /\ snd y = sizeof (snd x)).

  intros. destruct ENV. destruct y.

  destruct (me_local_inv0 _ _ _ H) as [b' [t [J T]]].

   exists (b', t). simpl. split; trivial. split; trivial.

   destruct (HH1 _ _ T) as [yy [TY [JY SZY]]].

   simpl in *. rewrite H in TY. inv TY. rewrite JY in J; inv J. simpl in *. trivial.

apply (PTree.elements_canonical_order _ e te HH1 HH2).

Qed.



Lemma match_env_free_blocks_parallel_inject:

  forall e te m m' j tm

     (ENV: match_env j e te)

     (INJ: Mem.inject j m tm)

     (FL: Mem.free_list m (Clight.blocks_of_env e) = Some m'),

  exists tm', Mem.free_list tm (blocks_of_env te) = Some tm' /\

              Mem.inject j m' tm'.

Proof. intros.

apply match_env_same_blocks in ENV.

clear - ENV FL INJ.

unfold Clight.blocks_of_env in FL.

unfold blocks_of_env.

remember (PTree.elements e) as l; clear Heql.

remember (PTree.elements te) as tl; clear Heqtl.

generalize dependent tm.

generalize dependent m'.

generalize dependent m. clear - ENV.

induction ENV; simpl; intros.

  inv FL. exists tm. split; trivial.

remember (Clight.block_of_binding a1) as A1.

  unfold Clight.block_of_binding in HeqA1.

  destruct a1 as [id [b ty]]. subst. simpl in *.

  remember (Mem.free m b 0 (sizeof ty)) as d.

  destruct d; inv FL; apply eq_sym in Heqd.

  specialize (IHENV _ _ H1); clear H1.

  destruct b1 as [x [tb sizeT]].

  destruct H as [? [J SZ]]. simpl in *. subst.

  destruct (free_parallel_inject _ _ _ _ _ _ _ INJ Heqd _ _ J)

   as [tm0 [FRT INJ0]].

  destruct (IHENV _ INJ0) as [tm' [FL' INJ']]; clear IHENV.

  exists tm'. simpl in *. rewrite Zplus_0_r in FRT.

  rewrite FRT. split; trivial.

Qed.



Lemma freelist_freelist_inject: forall m1 m1' j m2 e

        (FL1: Mem.free_list m1 (Clight.blocks_of_env e) = Some m1')

        (INJ : Mem.inject j m1 m2)

        te (MENV : match_env j e te)

        m2'

        (FL2 : Mem.free_list m2 (blocks_of_env te) = Some m2'),

      Mem.inject j m1' m2'.

Proof. intros.

  destruct (match_env_free_blocks_parallel_inject _ _ _ _ _ _ MENV INJ FL1)

       as [tm [FL_tm Inj_tm]].

  rewrite FL_tm in FL2. inv FL2. assumption.

Qed.



Lemma FreelistEffect_PropagateLeft: forall

   m e m'

   (FL : Mem.free_list m (Clight.blocks_of_env e) = Some m')

   mu m2 (SMV : sm_valid mu m m2) (WD: SM_wd mu)

   te (MENV: match_env (restrict (as_inj mu) (vis mu)) e te)

   b2 ofs

   (EFF : FreelistEffect m2 (blocks_of_env te) b2 ofs = true)

   (LB: locBlocksTgt mu b2 = false),

  exists b1 delta,

    foreign_of mu b1 = Some (b2, delta) /\

    FreelistEffect m (Clight.blocks_of_env e) b1 (ofs - delta) = true /\

    Mem.perm m b1 (ofs - delta) Max Nonempty.

Proof. intros.

apply match_env_same_blocks in MENV.

clear - MENV FL SMV EFF LB WD.

unfold Clight.blocks_of_env in FL.

unfold Clight.blocks_of_env.

unfold blocks_of_env in EFF.

remember (PTree.elements e) as l; clear Heql.

remember (PTree.elements te) as tl; clear Heqtl.

generalize dependent m2.

generalize dependent m'.

generalize dependent m. clear - MENV LB WD.

induction MENV; simpl; intros.

  intuition.

destruct a1 as [x [b tp]].

destruct b1 as [id [b' z]].

simpl in *.

destruct H as [? [Rb ?]]; subst.

remember (Mem.free m b 0 (sizeof tp)) as d.

destruct d; inv FL; apply eq_sym in Heqd.

apply orb_true_iff in EFF.

destruct EFF as [EFF | EFF].

  specialize (IHMENV _ _ H0).

  assert (SMV': sm_valid mu m0 m2).

    split; intros.

      eapply (Mem.valid_block_free_1 _ _ _ _ _ Heqd).

        eapply SMV; eassumption.

        eapply SMV; eassumption.

  destruct (IHMENV _ SMV' EFF) as [b1 [delta [Frg [FL2 P]]]].

  exists b1, delta; intuition.

    apply orb_true_iff; left.

      remember (map Clight.block_of_binding al) as t.

         clear - Heqd FL2. generalize dependent m0. generalize dependent m.

         induction t; simpl; intros. assumption.

         destruct a as [[bb lo] hi].

         apply orb_true_iff in FL2.

         apply orb_true_iff.

         destruct FL2. apply (IHt _ _ Heqd) in H. left; trivial.

         right. clear IHt. unfold FreeEffect. unfold FreeEffect in H.

         destruct (valid_block_dec m0 b1).

           destruct (valid_block_dec m b1); trivial.

           apply (Mem.valid_block_free_2 _ _ _ _ _ Heqd) in v. contradiction.

         inv H.

    eapply Mem.perm_free_3; eassumption.

destruct (restrictD_Some _ _ _ _ _ Rb).

  destruct (FreeEffect_PropagateLeft _ _ _ _ _ Heqd _ _ SMV WD _ H H1 _ _ EFF LB)

    as [b1 [delta [Frg [EFF1 P1]]]].

  exists b1, delta. rewrite EFF1. intuition.

Qed.



Lemma match_env_empty: forall j,

  match_env j Clight.empty_env Csharpminor.empty_env.

Proof.

  unfold Clight.empty_env, Csharpminor.empty_env.

  constructor.

  intros until ty. repeat rewrite PTree.gempty. congruence.

  intros until sz. rewrite PTree.gempty. congruence.

Qed.



Lemma match_env_alloc_variables:

  forall vars e1 m1 e2 m2,

  Clight.alloc_variables e1 m1 vars e2 m2 ->

  forall mu te1 tm1,

  match_env (restrict (as_inj mu) (vis mu)) e1 te1 ->

  Mem.inject (as_inj mu) m1 tm1 ->

  SM_wd mu -> sm_valid mu m1 tm1 ->

  exists te2 tm2 mu',

  Csharpminor.alloc_variables te1 tm1 (map transl_var vars) te2 tm2

  /\ match_env (restrict (as_inj mu') (vis mu')) e2 te2 /\ Mem.inject (as_inj mu') m2 tm2

  /\ intern_incr mu mu'

  /\ sm_inject_separated mu mu' m1 tm1

  /\ sm_locally_allocated mu mu' m1 tm1 m2 tm2

  /\ SM_wd mu' /\ sm_valid mu' m2 tm2

  /\ (REACH_closed m1 (vis mu) -> REACH_closed m2 (vis mu')).

Proof. intros vars.

  induction vars; intros; simpl; inv H.

  exists te1, tm1, mu. intuition.

       constructor.

       apply intern_incr_refl.

       apply sm_inject_separated_same_sminj.

       apply sm_locally_allocatedChar.

         repeat split; extensionality b;

         try rewrite freshloc_irrefl; intuition.

  specialize (IHvars _ _ _ _ H11).

  exploit (alloc_parallel_intern mu); try eassumption. apply Zle_refl. apply Zle_refl.

  intros [mu0 [tm0 [b2 [Alloc2 [INJ0 [IntInc0 [A [B [C [D [E [F G]]]]]]]]]]]].

  assert (VisB1: vis mu0 b1 = true).

         assert (DomSrc mu0 b1 = true).

           eapply as_inj_DomRng; eassumption.

         unfold DomSrc in H. unfold vis.

         remember (locBlocksSrc mu0 b1) as d.

         destruct d; simpl in *; trivial.

         assert (extBlocksSrc mu = extBlocksSrc mu0) by eapply IntInc0.

         rewrite <- H4 in H.

         elim (Mem.fresh_block_alloc _ _ _ _ _ H8).

         eapply H3. unfold DOM, DomSrc. intuition.

  assert (MENV0 :match_env (restrict (as_inj mu0) (vis mu0))

                    (PTree.set id (b1, ty) e1)

                    (PTree.set id (b2, sizeof ty) te1)).

    clear IHvars.

    constructor.

    

    intros until ty0. repeat rewrite PTree.gsspec.

    destruct (peq id0 id); intros. inv H.

       exists b2; split; trivial.

         eapply restrictI_Some; assumption.

      destruct (me_local _ _ _ H0 _ _ _ H) as [b' [AI TE]].

       exists b'; split; trivial.

       eapply intern_incr_restrict; eassumption.

    

    intros until sz. repeat rewrite PTree.gsspec.

    destruct (peq id0 id); intros.

      inv H. exists b1, ty; split; trivial.

        apply restrictI_Some; trivial.

      destruct (me_local_inv _ _ _ H0 _ _ _ H) as [b' [tp [AI TE]]].

       exists b', tp; split; trivial.

       eapply intern_incr_restrict; eassumption.

  destruct (IHvars mu0 _ _ MENV0 INJ0 E F)

    as [te2 [tm2 [mu' [AVars' [MENV' [INJ' [IntInc'

        [SEP' [LAC' [WD' [VAL' RC']]]]]]]]]]].

  simpl.

  exists te2, tm2, mu'. intuition.

    econstructor; eassumption.

    eapply intern_incr_trans; eassumption.

    eapply intern_separated_incr_fwd2; try eassumption.

      eapply alloc_forward; eassumption.

      eapply alloc_forward; eassumption.

    eapply sm_locally_allocated_trans; try eassumption.

      eapply alloc_forward; eassumption.

      eapply Clight_coop.alloc_variables_forward; try eassumption.

      eapply alloc_forward; eassumption.

      eapply alloc_variables_forward; try eassumption.

Qed.



Definition match_tempenv (j:meminj) (le: temp_env) (tle: Csharpminor.temp_env) :=

  forall id v, le!id = Some v ->

  exists tv, val_inject j v tv /\ tle!id = Some tv.



Lemma match_tempenv_inject_incr: forall j e te

       (TENV : match_tempenv j e te) j'

       (INC: inject_incr j j'),

     match_tempenv j' e te.

Proof. red; intros.

  destruct (TENV _ _ H) as [v' [V' Tv']].

  exists v'; split; trivial.

  eapply val_inject_incr; eassumption.

Qed.



Lemma match_tempenv_set: forall j le tle

      (TENV : match_tempenv j le tle) v tv

      (Inj : val_inject j v tv) x,

     match_tempenv j (PTree.set x v le) (PTree.set x tv tle).

Proof. intros.

  red; intros.

  rewrite PTree.gsspec in H.

  rewrite PTree.gsspec.

  destruct (peq id x); subst.

    inv H. exists tv; split; trivial.

  apply (TENV _ _ H).

Qed.



Lemma create_undef_temps_match:

  forall temps,

  create_undef_temps (map fst temps) = Clight.create_undef_temps temps.

Proof.

  induction temps; simpl. auto.

  destruct a as [id ty]. simpl. decEq. auto.

Qed.

Lemma create_undef_temps_match_inject:

  forall temps j,

  match_tempenv j (Clight.create_undef_temps temps)

                  (create_undef_temps (map fst temps)).

Proof.

  induction temps; simpl. intros.

     red; intros.

     rewrite PTree.gempty in H; discriminate.

  intros.

    destruct a as [id ty]. simpl.

    red; intros.

      rewrite PTree.gsspec in H. rewrite PTree.gsspec.

      destruct (peq id0 id); subst.

        inv H. exists Vundef; split; trivial.

      apply (IHtemps j id0 _ H).

Qed.



Lemma bind_parameter_temps_match_inject:

  forall vars vals le1 le2

  (BP: Clight.bind_parameter_temps vars vals le1 = Some le2)

  j tle1 (TENV: match_tempenv j le1 tle1)

  tvals (Inj: val_list_inject j vals tvals),

  exists tle2,

    bind_parameters (map fst vars) tvals tle1 = Some tle2 /\

    match_tempenv j le2 tle2.

Proof.

  induction vars; simpl; intros.

  destruct vals; inv BP. inv Inj.

    exists tle1; split; trivial.

  destruct a as [id ty]. destruct vals; try discriminate.

    inv Inj.

    assert (TE:= match_tempenv_set _ _ _ TENV _ _ H1 id).

    apply (IHvars _ _ _ BP _ _ TE _ H3).

Qed.



Lemma unary_op_inject: forall op v ty u

           (SUO:sem_unary_operation op v ty = Some u)

           j tv (V: val_inject j v tv),

      val_inject j u u /\ sem_unary_operation op tv ty = Some u.

Proof. intros.

  destruct op; simpl in *.

  rewrite notbool_bool_val in *.

    remember (bool_val v ty) as q; apply eq_sym in Heqq.

    destruct q; inv SUO.

    split. apply val_inject_of_bool.

     rewrite (bool_val_inject  _ _ _ _ _ Heqq V). trivial.

  unfold sem_notint in *.

    remember (classify_notint ty) as q; apply eq_sym in Heqq.

    destruct q; inv SUO.

    destruct v; inv H0. inv V.

      split. constructor. trivial.

    destruct v; inv H0. inv V.

      split. constructor. trivial.

  unfold sem_neg in *.

    remember (classify_neg ty) as q; apply eq_sym in Heqq.

    destruct q; inv SUO.

    destruct v; inv H0. inv V.

      split. constructor. trivial.

    destruct v; inv H0. inv V.

      split. constructor. trivial.

    destruct v; inv H0. inv V.

      split. constructor. trivial.

Qed.



Lemma unary_op_inject': forall op v ty u

           (SUO:sem_unary_operation op v ty = Some u)

           j tv (V: val_inject j v tv),

      exists tu, val_inject j u tu /\

        sem_unary_operation op tv ty = Some tu.

Proof. intros.

  exists u. eapply unary_op_inject; eassumption.

Qed.



Lemma binary_op_inject: forall op v1 v2 ty1 ty2 m u

           (SBO:sem_binary_operation op v1 ty1 v2 ty2 m = Some u)

           j tm (MINJ : Mem.inject j m tm)

           tv1 (V1: val_inject j v1 tv1) tv2 (V2: val_inject j v2 tv2),

      exists tu,

           sem_binary_operation op tv1 ty1 tv2 ty2 tm = Some tu

           /\ val_inject j u tu.

Proof. intros.

eapply sem_binary_operation_inj; try eassumption.

  intros. eapply Mem.valid_pointer_inject_val; try eassumption.

          econstructor. eassumption. trivial.

  intros. eapply Mem.weak_valid_pointer_inject_val; try eassumption.

          econstructor. eassumption. trivial.

  intros. eapply Mem.weak_valid_pointer_inject_no_overflow; try eassumption.

  intros. eapply Mem.different_pointers_inject; try eassumption.

Qed.



Section EXPR.



Variable e: Clight.env.

Variable le: temp_env.

Variable m: mem.

Variable tm: mem. 

Variable te: Csharpminor.env.

Variable tle: Csharpminor.temp_env. 

Variable j: meminj. 

Hypothesis MENV: match_env j e te.

Hypothesis LENV: match_tempenv j le tle. 

Hypothesis MINJ: Mem.inject j m tm. 

Hypothesis PG: meminj_preserves_globals ge j. 



Lemma deref_loc_inject: forall ty b ofs v

        (D:deref_loc ty m b ofs v) tb delta

        (J: j b = Some(tb,delta)),

      exists tv, val_inject j v tv /\

         deref_loc ty tm tb (Int.add ofs (Int.repr delta)) tv.

Proof. intros.

  inv D.



  assert (val_inject j (Vptr b ofs) (Vptr tb (Int.add ofs (Int.repr delta)))).

    econstructor. eassumption. trivial.

  destruct (Mem.loadv_inject _ _ _ _ _ _ _ MINJ H0 H1) as [tv [TLDV VI]].

  exists tv; split; trivial.

  eapply (deref_loc_value); eassumption.



  eexists; split. econstructor. eassumption. reflexivity.

  eapply (deref_loc_reference); assumption.



  eexists; split. econstructor. eassumption. reflexivity.

  eapply (deref_loc_copy); assumption.

Qed.



Lemma transl_expr_lvalue_correct:

  (forall a v,

   Clight.eval_expr ge e le m a v ->

   forall ta (TR: transl_expr a = OK ta),

   exists tv, val_inject j v tv /\

   Csharpminor.eval_expr tge te tle tm ta tv)

/\(forall a b ofs,

   Clight.eval_lvalue ge e le m a b ofs ->

   forall ta (TR: transl_lvalue a = OK ta),

   exists tv, val_inject j (Vptr b ofs) tv /\

   Csharpminor.eval_expr tge te tle tm ta tv).

Proof.

  apply eval_expr_lvalue_ind; intros; try (monadInv TR).



  eexists. split. econstructor.

  apply make_intconst_correct.



  eexists. split. econstructor.

  apply make_floatconst_correct.



  eexists. split. econstructor.

  apply make_longconst_correct.



  destruct (LENV _ _ H) as [tv [? ?]].

  exists tv; split; trivial.

  constructor; auto.



  inv TR. auto.



  destruct (H0 _ EQ) as [tv [VI EE]]; clear H0 EQ.

  destruct (unary_op_inject _ _ _ _ H1 _ _ VI); clear H1 VI.

  exists v; split; trivial.

  eapply transl_unop_correct; eauto.



  destruct (H0 _ EQ) as [tv1 [VI1 EE1]]; clear H0 EQ.

  destruct (H2 _ EQ1) as [tv2 [VI2 EE2]]; clear H2 EQ1.

  destruct (binary_op_inject _ _ _ _ _ _ _ H3 _ _ MINJ _ VI1 _ VI2)

   as [tv [TV ETV]]; clear H3 VI1 VI2.

  exists tv; split; trivial.

  eapply transl_binop_correct; eauto.



  destruct (H0 _ EQ) as [tv1 [TV1 ET1]]. clear H0.

  destruct (sem_cast_inject _ _ _ _ _ _ H1 TV1) as [tv [SC VI]].

  exists tv; split; trivial.

  apply (make_cast_correct _ _ _ _ _ _ _ _ _ _ EQ0 ET1 SC).



  exploit transl_expr_lvalue; eauto. intros [tb [TRLVAL MKLOAD]].

  destruct (H0 _ TRLVAL) as [tv [VT ET]]; clear H0.

  inv VT.

  destruct (deref_loc_inject _ _ _ _ H1 _ _ H3) as [tv [InjTv DerefTv]].

  specialize (make_load_correct tge tb (typeof a) ta b2 (Int.add ofs (Int.repr delta)) _ _ _ _ MKLOAD ET DerefTv).

  intros.

  exists tv; split; eassumption.



  destruct (me_local _ _ _ MENV _ _ _ H) as [tb [J TH]].

   eexists; split; econstructor. eassumption. reflexivity.

   eapply eval_var_addr_local; eassumption.



  exists (Vptr l Int.zero); split.

  econstructor.

  eapply (meminj_preserves_globals_isGlobalBlock _ _ PG).

  eapply find_symbol_isGlobal; eassumption.

  rewrite Int.add_zero. trivial.

  econstructor.

    eapply eval_var_addr_global.

    eapply match_env_globals; eauto.

    rewrite symbols_preserved. eassumption.



  auto.



  simpl in TR. rewrite H1 in TR. monadInv TR.

  destruct (H0 _ EQ) as [tv [VT ET]]; clear H0.

  inv VT.

  eexists; split. econstructor. eassumption. reflexivity.

  eapply eval_Ebinop; eauto.

  apply make_intconst_correct.

  rewrite EQ1 in H2. inv H2.

  simpl. rewrite Int.add_assoc. rewrite Int.add_assoc.

         rewrite (Int.add_commut (Int.repr delta0)). trivial.



  simpl in TR. rewrite H1 in TR. eauto.

Qed.



Lemma transl_expr_correct: forall a v,

       Clight.eval_expr ge e le m a v ->

       forall ta, transl_expr a = OK ta ->

       exists tv, val_inject j v tv /\

            eval_expr tge te tle tm ta tv.

Proof (proj1 transl_expr_lvalue_correct).



Lemma transl_lvalue_correct:

   forall a b ofs,

       eval_lvalue ge e le m a b ofs ->

       forall ta, transl_lvalue a = OK ta ->

       exists tv, val_inject j (Vptr b ofs) tv /\

                   eval_expr tge te tle tm ta tv.

Proof (proj2 transl_expr_lvalue_correct).



Lemma transl_arglist_correct:

  forall al tyl vl,

  Clight.eval_exprlist ge e le m al tyl vl ->

  forall tal, transl_arglist al tyl = OK tal ->

  exists tvl, val_list_inject j vl tvl /\

  Csharpminor.eval_exprlist tge te tle tm tal tvl.

Proof.

  induction 1; intros.

  monadInv H. exists nil. split; constructor.

  monadInv H2.

  destruct (IHeval_exprlist _ EQ0) as [tv1 [VT ET]]; clear IHeval_exprlist.

  destruct (transl_expr_correct _ _ H _ EQ) as [? [? ?]].

  destruct (sem_cast_inject _ _ _ _ _ _ H0 H2) as [? [? ?]].

  specialize (make_cast_correct _ _ _ _ _ _ _ _ _ _ EQ1 H3 H4). intros.

  eexists; split. econstructor; eassumption.

  econstructor; eassumption.

Qed.



Lemma make_boolean_inject:

 forall a v ty b,

  Clight.eval_expr ge e le m a v ->

  bool_val v ty = Some b ->

  forall ta, transl_expr a = OK ta ->

  exists tv,

    Csharpminor.eval_expr tge te tle tm (make_boolean ta ty) tv

    /\ Val.bool_of_val tv b.

Proof.

  intros. unfold make_boolean. unfold bool_val in H0.

  destruct (classify_bool ty); destruct v; inv H0.



  destruct (transl_expr_correct _ _ H _ H1) as [tv [Vinj ET]].

  inv Vinj.

  eexists; split. apply make_cmp_ne_zero_correct with (n := i); auto.

  destruct (Int.eq i Int.zero); simpl; constructor.



  destruct (transl_expr_correct _ _ H _ H1) as [tv [Vinj ET]].

  inv Vinj.

  econstructor; split. econstructor; eauto. econstructor. reflexivity.

   simpl. reflexivity.

  unfold Val.cmpf, Val.cmpf_bool.

  rewrite <- Float.cmp_ne_eq.

  destruct (Float.cmp Cne f Float.zero); constructor.



  destruct (transl_expr_correct _ _ H _ H1) as [tv [Vinj ET]].

  inv Vinj.

  econstructor; split. econstructor; eauto. econstructor; reflexivity. reflexivity.

  unfold Val.cmpu, Val.cmpu_bool. simpl.

  destruct (Int.eq i Int.zero); simpl; constructor.



  destruct (transl_expr_correct _ _ H _ H1) as [tv [Vinj ET]].

  inv Vinj.

  exists Vtrue; split. econstructor; eauto. constructor; reflexivity.

     simpl. unfold Val.cmpu, Val.cmpu_bool. simpl.

  destruct (Int.eq i Int.zero); simpl; constructor.

  constructor.



  destruct (transl_expr_correct _ _ H _ H1) as [tv [Vinj ET]].

  inv Vinj.

  econstructor; split. econstructor; eauto. constructor; reflexivity.

  simpl. unfold Val.cmpl. simpl. eauto.

  destruct (Int64.eq i Int64.zero); simpl; constructor.

Qed.



End EXPR.



Inductive match_transl: stmt -> cont -> stmt -> cont -> Prop :=

  | match_transl_0: forall ts tk,

      match_transl ts tk ts tk

  | match_transl_1: forall ts tk,

      match_transl (Sblock ts) tk ts (Kblock tk).



Lemma match_transl_corestep:

  forall ts tk ts' tk' f te le m,

  match_transl (Sblock ts) tk ts' tk' ->

  corestep_star csharpmin_eff_sem  tge

       (CSharpMin_State f ts' tk' te le) m

       (CSharpMin_State f ts (Kblock tk) te le) m.

Proof.

  intros. inv H.

  apply corestep_star_one. constructor.

  apply corestep_star_zero.

Qed.



Lemma match_transl_effstep:

  forall ts tk ts' tk' f te le m,

  match_transl (Sblock ts) tk ts' tk' ->

  effstep_star csharpmin_eff_sem  tge EmptyEffect

       (CSharpMin_State f ts' tk' te le) m

       (CSharpMin_State f ts (Kblock tk) te le) m.

Proof.

  intros. inv H.

  apply effstep_star_one. constructor.

  apply effstep_star_zero.

Qed.



Inductive match_cont (j:meminj): type -> nat -> nat -> Clight.cont -> Csharpminor.cont -> Prop :=

  | match_Kstop: forall tyret nbrk ncnt,

      match_cont j tyret nbrk ncnt Clight.Kstop Kstop

  | match_Kseq: forall tyret nbrk ncnt s k ts tk,

      transl_statement tyret nbrk ncnt s = OK ts ->

      match_cont j tyret nbrk ncnt k tk ->

      match_cont j tyret nbrk ncnt

                 (Clight.Kseq s k)

                 (Kseq ts tk)

  | match_Kloop1: forall tyret s1 s2 k ts1 ts2 nbrk ncnt tk,

      transl_statement tyret 1%nat 0%nat s1 = OK ts1 ->

      transl_statement tyret 0%nat (S ncnt) s2 = OK ts2 ->

      match_cont j tyret nbrk ncnt k tk ->

      match_cont j tyret 1%nat 0%nat

                   (Clight.Kloop1 s1 s2 k)

                   (Kblock (Kseq ts2 (Kseq (Sloop (Sseq (Sblock ts1) ts2)) (Kblock tk))))

  | match_Kloop2: forall tyret s1 s2 k ts1 ts2 nbrk ncnt tk,

      transl_statement tyret 1%nat 0%nat s1 = OK ts1 ->

      transl_statement tyret 0%nat (S ncnt) s2 = OK ts2 ->

      match_cont j tyret nbrk ncnt k tk ->

      match_cont j tyret 0%nat (S ncnt)

                 (Clight.Kloop2 s1 s2 k)

                 (Kseq (Sloop (Sseq (Sblock ts1) ts2)) (Kblock tk))

  | match_Kswitch: forall tyret nbrk ncnt k tk,

      match_cont j tyret nbrk ncnt k tk ->

      match_cont j tyret 0%nat (S ncnt)

                   (Clight.Kswitch k)

                   (Kblock tk)

  | match_Kcall_some: forall tyret nbrk ncnt nbrk' ncnt' f e k id tf te le tle tk,

      transl_function f = OK tf ->

      match_env j e te ->

      match_tempenv j le tle ->

      match_cont j (Clight.fn_return f) nbrk' ncnt' k tk ->

      match_cont j tyret nbrk ncnt

                 (Clight.Kcall id f e le k)

                 (Kcall id tf te tle tk).



Lemma match_cont_inject_incr: forall j j' (I: inject_incr j j') tp n m k k'

        (MC: match_cont j tp n m k k'), match_cont j' tp n m k k'.

Proof. intros.

  induction MC; try (econstructor; try eassumption).

  eapply match_env_inject_incr; eassumption.

  eapply match_tempenv_inject_incr; eassumption.

Qed.



Inductive match_states (j:meminj) : CL_core -> mem -> CSharpMin_core -> mem -> Prop :=

  | match_state:

      forall f nbrk ncnt s k e le m tf ts tk te tle ts' tk' tm

          (TRF: transl_function f = OK tf)

          (TR: transl_statement (Clight.fn_return f) nbrk ncnt s = OK ts)

          (MTR: match_transl ts tk ts' tk')

          (MENV: match_env j e te)

          (TENV: match_tempenv j le tle)

          (MK: match_cont j (Clight.fn_return f) nbrk ncnt k tk),

      match_states j (CL_State f s k e le) m

                   (CSharpMin_State tf ts' tk' te tle) tm

  | match_callstate:

      forall fd args1 k m tfd tk targs tres tm args2

          (TR: transl_fundef fd = OK tfd)

          (MK: match_cont j Tvoid 0%nat 0%nat k tk)

          (ISCC: Clight.is_call_cont k)

          (TY: type_of_fundef fd = Tfunction targs tres)

           (ArgsInj: val_list_inject j args1 args2),

      match_states j (CL_Callstate fd args1 k) m

                   (CSharpMin_Callstate tfd args2 tk) tm

  | match_returnstate:

      forall res1 res2 k m tk tm

          (MK: match_cont j Tvoid 0%nat 0%nat k tk)

          (Vinj: val_inject j res1 res2),

      match_states j (CL_Returnstate res1 k) m

                   (CSharpMin_Returnstate res2 tk) tm.



Remark match_states_skip:

  forall j f e le te tle nbrk ncnt k tf tk m tm,

  transl_function f = OK tf ->

  match_env j e te ->

  match_tempenv j le tle ->

  match_cont j (Clight.fn_return f) nbrk ncnt k tk ->

  match_states j (CL_State f Clight.Sskip k e le) m (CSharpMin_State tf Sskip tk te tle) tm.

Proof.

  intros. econstructor; eauto. simpl; reflexivity. constructor.

Qed.



Section FIND_LABEL.

Variable lbl: label.

Variable tyret: type.



Lemma transl_find_label:

  forall s j nbrk ncnt k ts tk

  (TR: transl_statement tyret nbrk ncnt s = OK ts)

  (MC: match_cont j tyret nbrk ncnt k tk),

  match Clight.find_label lbl s k with

  | None => find_label lbl ts tk = None

  | Some (s', k') =>

      exists ts', exists tk', exists nbrk', exists ncnt',

      find_label lbl ts tk = Some (ts', tk')

      /\ transl_statement tyret nbrk' ncnt' s' = OK ts'

      /\ match_cont j tyret nbrk' ncnt' k' tk'

  end



with transl_find_label_ls:

  forall ls j nbrk ncnt k tls tk

  (TR: transl_lbl_stmt tyret nbrk ncnt ls = OK tls)

  (MC: match_cont j tyret nbrk ncnt k tk),

  match Clight.find_label_ls lbl ls k with

  | None => find_label_ls lbl tls tk = None

  | Some (s', k') =>

      exists ts', exists tk', exists nbrk', exists ncnt',

      find_label_ls lbl tls tk = Some (ts', tk')

      /\ transl_statement tyret nbrk' ncnt' s' = OK ts'

      /\ match_cont j tyret nbrk' ncnt' k' tk'

  end.



Proof.

  intros s; case s; intros; try (monadInv TR); simpl.



  auto.



  unfold make_store, make_memcpy in EQ3.

  destruct (access_mode (typeof e)); inv EQ3; auto.



  auto.



  simpl in TR. destruct (classify_fun (typeof e)); monadInv TR. auto.



  auto.



  exploit (transl_find_label s0 j nbrk ncnt (Clight.Kseq s1 k)); eauto. constructor; eauto.

  destruct (Clight.find_label lbl s0 (Clight.Kseq s1 k)) as [[s' k'] | ].

  intros [ts' [tk' [nbrk' [ncnt' [A [B C]]]]]].

  rewrite A. exists ts'; exists tk'; exists nbrk'; exists ncnt'; auto.

  intro. rewrite H. eapply transl_find_label; eauto.



  exploit (transl_find_label s0); eauto.

  destruct (Clight.find_label lbl s0 k) as [[s' k'] | ].

  intros [ts' [tk' [nbrk' [ncnt' [A [B C]]]]]].

  rewrite A. exists ts'; exists tk'; exists nbrk'; exists ncnt'; auto.

  intro. rewrite H. eapply transl_find_label; eauto.



  exploit (transl_find_label s0 j 1%nat 0%nat (Kloop1 s0 s1 k)); eauto. econstructor; eauto.

  destruct (Clight.find_label lbl s0 (Kloop1 s0 s1 k)) as [[s' k'] | ].

  intros [ts' [tk' [nbrk' [ncnt' [A [B C]]]]]].

  rewrite A. exists ts'; exists tk'; exists nbrk'; exists ncnt'; auto.

  intro. rewrite H.

  eapply transl_find_label; eauto. econstructor; eauto.



  auto.



  auto.



  simpl in TR. destruct o; monadInv TR. auto. auto.



  eapply transl_find_label_ls with (k := Clight.Kswitch k); eauto. econstructor; eauto.



  destruct (ident_eq lbl l).

  exists x; exists tk; exists nbrk; exists ncnt; auto.

  eapply transl_find_label; eauto.



  auto.



  intro ls; case ls; intros; monadInv TR; simpl.



  eapply transl_find_label; eauto.



  exploit (transl_find_label s j nbrk ncnt (Clight.Kseq (seq_of_labeled_statement l) k)); eauto.

  econstructor; eauto. apply transl_lbl_stmt_2; eauto.

  destruct (Clight.find_label lbl s (Clight.Kseq (seq_of_labeled_statement l) k)) as [[s' k'] | ].

  intros [ts' [tk' [nbrk' [ncnt' [A [B C]]]]]].

  rewrite A. exists ts'; exists tk'; exists nbrk'; exists ncnt'; auto.

  intro. rewrite H.

  eapply transl_find_label_ls; eauto.

Qed.



End FIND_LABEL.



Lemma match_cont_call_cont:

  forall j tyret' nbrk' ncnt' tyret nbrk ncnt k tk,

  match_cont j tyret nbrk ncnt k tk ->

  match_cont j tyret' nbrk' ncnt' (Clight.call_cont k) (call_cont tk).

Proof.

  induction 1; simpl; auto.

  constructor.

  econstructor; eauto.

Qed.



Lemma match_cont_is_call_cont:

  forall j tyret nbrk ncnt k tk tyret' nbrk' ncnt',

  match_cont j tyret nbrk ncnt k tk ->

  Clight.is_call_cont k ->

  match_cont j tyret' nbrk' ncnt' k tk /\ is_call_cont tk.

Proof.

  intros. inv H; simpl in H0; try contradiction; simpl.

  split; auto; constructor.

  split; auto; econstructor; eauto.

Qed.



Lemma varinfo_preserved:

  forall b, (exists gv : globvar type, Genv.find_var_info ge b = Some gv) <->

            (exists gv : globvar unit, Genv.find_var_info tge b = Some gv).

Proof. intros.

  split; intros; destruct H.

    destruct (var_info_translated _ _ H). exists x0; apply H0.

    destruct (var_info_rev_translated _ _ H). exists x0; apply H0.

Qed.



Lemma assign_loc_inject: forall ty m1 b1 ofs v m1' R

  (ASS: assign_loc ty m1 b1 ofs v m1')

  j v2 (V:val_inject (restrict j R) v v2) b2 delta

  (J: restrict j R b1 = Some(b2,delta))

  m2 (MInj: Mem.inject j m1 m2),

exists m2',

  assign_loc ty m2 b2 (Int.add ofs (Int.repr delta)) v2 m2' /\

  Mem.inject j m1' m2'.

Proof. intros.

  inv ASS.



  assert (Jb: val_inject j (Vptr b1 ofs) (Vptr b2 (Int.add ofs (Int.repr delta)))).

     destruct (restrictD_Some _ _ _ _ _ J).

     econstructor. eassumption. trivial.

  assert (Jv: val_inject j v v2).

     eapply val_inject_incr; try eassumption.

     apply restrict_incr.

  destruct (Mem.storev_mapped_inject _ _ _ _ _ _ _ _ _ MInj H0 Jb Jv) as [m2' [ST' MInj']].

  exists m2'. split; trivial. eapply assign_loc_value; eassumption.



  destruct (restrictD_Some _ _ _ _ _ J).

  assert (Jb: val_inject j (Vptr b1 ofs) (Vptr b2 (Int.add ofs (Int.repr delta)))).

     econstructor. eassumption. trivial.

  assert (Jv: val_inject j (Vptr b' ofs') v2).

     eapply val_inject_incr; try eassumption.

     apply restrict_incr.

  inv Jv.

  destruct (Mem.loadbytes_inj _ _ _ _ _ _ _ _ _ (Mem.mi_inj _ _ _ MInj) H3 H9)

     as [bytes2 [LoadBytes2 BytesInj]].

  destruct (Mem.storebytes_mapped_inject _ _ _ _ _ _ _ _ _ bytes2 MInj H4 H5 BytesInj)

   as [m2' [StoreBytes2 Inj']].

  exists m2'. split; trivial.

  assert (P: Mem.perm m1 b1 (Int.unsigned ofs) Max Nonempty).

             eapply Mem.perm_implies.

                eapply Mem.perm_max.

                   eapply Mem.storebytes_range_perm. eassumption.

                    split. omega.

                    apply Mem.loadbytes_length in H3. rewrite H3.

                      specialize (sizeof_pos ty); intros.

                      rewrite nat_of_Z_eq. omega. omega.

                constructor.

  destruct (Mem.mi_representable _ _ _ MInj _ _ _ ofs H5).

        left; trivial.

  specialize (Int.unsigned_range_2 ofs); intros.

  assert (D: delta <= Int.max_unsigned). omega.

  assert (Arith: Int.unsigned (Int.add ofs (Int.repr delta)) =

                  Int.unsigned ofs + delta).

    unfold Int.add.

      rewrite (Int.unsigned_repr delta); try omega.

      rewrite Int.unsigned_repr; trivial.

  rewrite <- Arith in StoreBytes2.

  assert (P': Mem.perm m1 b' (Int.unsigned ofs') Max Nonempty).

              eapply Mem.perm_implies.

                eapply Mem.perm_max.

                   eapply Mem.loadbytes_range_perm. eassumption.

                    split. omega. specialize (sizeof_pos ty); intros. omega.

                constructor.

  destruct (Mem.mi_representable _ _ _ MInj _ _ _ ofs' H9).

        left; trivial.

  specialize (Int.unsigned_range_2 ofs'); intros.

  assert (D0: delta0 <= Int.max_unsigned). omega.

  assert (Arith': Int.unsigned (Int.add ofs' (Int.repr delta0)) =

                  Int.unsigned ofs' + delta0).

    unfold Int.add.

      rewrite (Int.unsigned_repr delta0); try omega.

      rewrite Int.unsigned_repr; trivial.

  rewrite <- Arith' in LoadBytes2.

  admit. 



Qed.



Lemma assign_loc_unique: forall t m b z v m1 m2

  (AL1: assign_loc t m b z v m1)

  (AL2: assign_loc t m b z v m2), m1=m2.

Proof. intros.

  inv AL1; inv AL2.

  rewrite H1 in H; inv H. rewrite H2 in H0; inv H0; trivial.

  rewrite H1 in H; inv H.

  rewrite H5 in H; inv H.

  rewrite H7 in H; inv H.

    destruct (loadbytes_D _ _ _ _ _ H3).

    destruct (loadbytes_D _ _ _ _ _ H11).

    rewrite <- H5 in H12. clear H5. subst.

    rewrite H4 in H13; inv H13; trivial.

Qed.



Definition MATCH (d:CL_core) mu c1 m1 c2 m2:Prop :=

  match_states (restrict (as_inj mu) (vis mu)) c1 m1 c2 m2 /\

  REACH_closed m1 (vis mu) /\

  meminj_preserves_globals ge (as_inj mu) /\

  globalfunction_ptr_inject (as_inj mu) /\

  (forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true) /\

  sm_valid mu m1 m2 /\ SM_wd mu /\ Mem.inject (as_inj mu) m1 m2.



Lemma MATCH_wd: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), SM_wd mu.

Proof. intros. eapply MC. Qed.



Lemma MATCH_RC: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), REACH_closed m1 (vis mu).

Proof. intros. eapply MC. Qed.



Lemma MATCH_restrict: forall d mu c1 m1 c2 m2 X

  (MC: MATCH d mu c1 m1 c2 m2)

  (HX: forall b : block, vis mu b = true -> X b = true)

  (RX: REACH_closed m1 X),

  MATCH d (restrict_sm mu X) c1 m1 c2 m2.

Proof. intros.

  destruct MC as [MS [RC [PG [GF [Glob [SMV [WD INJ]]]]]]].

assert (WDR: SM_wd (restrict_sm mu X)).

   apply restrict_sm_WD; assumption.

split.

  rewrite vis_restrict_sm.

  rewrite restrict_sm_all.

  rewrite restrict_nest; intuition.

split. unfold vis.

  rewrite restrict_sm_locBlocksSrc, restrict_sm_frgnBlocksSrc.

  apply RC.

split. clear -PG Glob HX.

  eapply restrict_sm_preserves_globals; try eassumption.

  unfold vis in HX. intuition.

split. rewrite restrict_sm_all.

  eapply restrict_preserves_globalfun_ptr; try eassumption.

  unfold vis in HX. intuition.

split.

  rewrite restrict_sm_frgnBlocksSrc. apply Glob.

split.

  destruct SMV.

  split; intros.

    rewrite restrict_sm_DOM in H1.

    apply (H _ H1).

  rewrite restrict_sm_RNG in H1.

    apply (H0 _ H1).

split. assumption.

  rewrite restrict_sm_all.

  eapply inject_restrict; eassumption.

Qed.



Lemma MATCH_valid: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2), sm_valid mu m1 m2.

Proof. intros. eapply MC. Qed.



Lemma MATCH_PG: forall d mu c1 m1 c2 m2

  (MC: MATCH d mu c1 m1 c2 m2),

  meminj_preserves_globals ge (extern_of mu) /\

  (forall b : block, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true).

Proof.

  intros.

  assert (GF: forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true).

    apply MC.

  split; trivial.

  rewrite <- match_genv_meminj_preserves_extern_iff_all; trivial.

    apply MC. apply MC.

Qed.



Lemma MATCH_initial: forall v1 v2 sig entrypoints

      (EP: In (v1, v2, sig) entrypoints)

      (entry_points_ok : forall (v1 v2 : val) (sig : signature),

                  In (v1, v2, sig) entrypoints ->

                  exists b f1 f2,

                    v1 = Vptr b Int.zero /\

                    v2 = Vptr b Int.zero /\

                    Genv.find_funct_ptr ge b = Some f1 /\

                    Genv.find_funct_ptr tge b = Some f2)

      vals1 c1 m1 j vals2 m2 (DomS DomT : block -> bool)

      (FE : Clight.function -> list val -> mem -> Clight.env -> Clight.temp_env -> mem -> Prop)

      (FE_FWD : forall f vargs m e lenv m', FE f vargs m e lenv m' ->

                mem_forward m m')

      (FE_UNCH : forall f vargs m e lenv m', FE f vargs m e lenv m' ->

          Mem.unchanged_on

            (fun (b : block) (z : Z) => EmptyEffect b z = false) m m')

      (Ini: initial_core (clight_eff_sem FE FE_FWD FE_UNCH) ge v1 vals1 = Some c1)

      (Inj: Mem.inject j m1 m2)

      (VInj: Forall2 (val_inject j) vals1 vals2)

      (PG:meminj_preserves_globals ge j)

      (R : list_norepet (map fst (prog_defs prog)))

      (J: forall b1 b2 delta, j b1 = Some (b2, delta) ->

            (DomS b1 = true /\ DomT b2 = true))

      (RCH: forall b, REACH m2

          (fun b' : block => isGlobalBlock tge b' || getBlocks vals2 b') b = true ->

          DomT b = true)

      (InitMem : exists m0 : mem, Genv.init_mem prog = Some m0

               /\ Ple (Mem.nextblock m0) (Mem.nextblock m1)

               /\ Ple (Mem.nextblock m0) (Mem.nextblock m2))

      (GDE: genvs_domain_eq ge tge)

      (HDomS: forall b : block, DomS b = true -> Mem.valid_block m1 b)

      (HDomT: forall b : block, DomT b = true -> Mem.valid_block m2 b),

exists c2,

  initial_core csharpmin_eff_sem tge v2 vals2 = Some c2 /\

  MATCH c1

    (initial_SM DomS DomT

       (REACH m1 (fun b : block => isGlobalBlock ge b || getBlocks vals1 b))

       (REACH m2 (fun b : block => isGlobalBlock tge b || getBlocks vals2 b))

       j) c1 m1 c2 m2.

Proof. intros.

  inversion Ini.

  unfold  CL_initial_core in H0. unfold ge in *. unfold tge in *.

  destruct v1; inv H0.

  remember (Int.eq_dec i Int.zero) as z; destruct z; inv H1. clear Heqz.

  remember (Genv.find_funct_ptr (Genv.globalenv prog) b) as zz; destruct zz; inv H0.

    apply eq_sym in Heqzz.

  exploit function_ptr_translated; eauto. intros [tf [FP TF]].

  exists (CSharpMin_Callstate tf vals2 Kstop).

  split.

    destruct (entry_points_ok _ _ _ EP) as [b0 [f1 [f2 [A [B [C D]]]]]].

    subst. inv A. rewrite C in Heqzz. inv Heqzz.

    unfold tge in FP. rewrite D in FP. inv FP.

    unfold csharpmin_eff_sem, csharpmin_coop_sem. simpl.

    case_eq (Int.eq_dec Int.zero Int.zero). intros ? e.

    solve[rewrite D; auto].



    intros CONTRA.

    solve[elimtype False; auto].

  assert (exists targs tres, type_of_fundef f = Tfunction targs tres).

         destruct f; simpl. eexists; eexists. reflexivity.

         eexists; eexists. reflexivity.

  destruct H as [targs [tres Tfun]].

  destruct (core_initial_wd ge tge _ _ _ _ _ _ _  Inj

     VInj J RCH PG GDE HDomS HDomT _ (eq_refl _))

    as [AA [BB [CC [DD [EE [FF GG]]]]]].

  intuition.

  split.

    eapply match_callstate; try eassumption.

      constructor.

      constructor.

    rewrite initial_SM_as_inj.

      unfold vis, initial_SM; simpl.

      apply forall_inject_val_list_inject.

      eapply restrict_forall_vals_inject; try eassumption.

        intros. apply REACH_nil. rewrite H; intuition.

  intuition.

    rewrite match_genv_meminj_preserves_extern_iff_all.

      assumption.

      apply BB.

      apply EE.

    rewrite initial_SM_as_inj.

      red; intros. specialize (Genv.find_funct_ptr_not_fresh prog). intros.

         destruct InitMem as [m0 [InitMem [? ?]]].

         specialize (H0 _ _ _ InitMem H).

         destruct (valid_init_is_global _ R _ InitMem _ H0) as [id Hid].

           destruct PG as [PGa [PGb PGc]]. split. eapply PGa; eassumption.

         unfold isGlobalBlock.

          apply orb_true_iff. left. apply genv2blocksBool_char1.

            simpl. exists id; eassumption.

    rewrite initial_SM_as_inj; assumption.

Qed.



Lemma MATCH_afterExternal: forall

      (FE : Clight.function -> list val -> mem ->

            Clight.env -> Clight.temp_env -> mem -> Prop)

      (FE_FWD : forall f vargs m e lenv m',

         FE f vargs m e lenv m' -> mem_forward m m')

      (FE_UNCH : forall f vargs m e lenv m',

         FE f vargs m e lenv m' ->

         Mem.unchanged_on

            (fun (b : block) (z : Z) => EmptyEffect b z = false) m m')

      (GDE : genvs_domain_eq ge tge)

      mu st1 st2 m1 e vals1 m2 ef_sig vals2 e' ef_sig'

      (MemInjMu : Mem.inject (as_inj mu) m1 m2)

      (MatchMu: MATCH st1 mu st1 m1 st2 m2)

      (AtExtSrc : at_external (clight_eff_sem FE FE_FWD FE_UNCH) st1 = Some (e, ef_sig, vals1))

      (AtExtTgt : at_external csharpmin_eff_sem st2 = Some (e', ef_sig', vals2))

      (ValInjMu : Forall2 (val_inject (restrict (as_inj mu) (vis mu))) vals1 vals2)

      (pubSrc' : block -> bool)

      (pubSrcHyp : pubSrc' =

                 (fun b : block =>

                 locBlocksSrc mu b && REACH m1 (exportedSrc mu vals1) b))

      (pubTgt' : block -> bool)

      (pubTgtHyp: pubTgt' =

                 (fun b : block =>

                 locBlocksTgt mu b && REACH m2 (exportedTgt mu vals2) b))

       nu (NuHyp: nu = replace_locals mu pubSrc' pubTgt')

       nu' ret1 m1' ret2 m2'

       (INC: extern_incr nu nu')

       (SEP: sm_inject_separated nu nu' m1 m2)

       (WDnu': SM_wd nu')

       (SMvalNu': sm_valid nu' m1' m2')

       (MemInjNu': Mem.inject (as_inj nu') m1' m2')

       (RValInjNu': val_inject (as_inj nu') ret1 ret2)

       (FwdSrc: mem_forward m1 m1')

       (FwdTgt: mem_forward m2 m2')

       (frgnSrc' : block -> bool)

       (frgnSrcHyp: frgnSrc' =

             (fun b : block => DomSrc nu' b &&

            (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b)))

       (frgnTgt' : block -> bool)

       (frgnTgtHyp: frgnTgt' =

            (fun b : block => DomTgt nu' b &&

             (negb (locBlocksTgt nu' b) && REACH m2' (exportedTgt nu' (ret2 :: nil)) b)))

       mu' (Mu'Hyp: mu' = replace_externs nu' frgnSrc' frgnTgt')

       (UnchPrivSrc: Mem.unchanged_on

               (fun b z => locBlocksSrc nu b = true /\ pubBlocksSrc nu b = false) m1 m1')

       (UnchLOOR: Mem.unchanged_on (local_out_of_reach nu m1) m2 m2'),

  exists (st1' : CL_core) (st2' : CSharpMin_core),

  after_external (clight_eff_sem FE FE_FWD FE_UNCH) (Some ret1) st1 =Some st1' /\

  after_external csharpmin_eff_sem (Some ret2) st2 = Some st2' /\

  MATCH st1' mu' st1' m1' st2' m2'.

Proof. intros.

simpl.

 destruct MatchMu as [MC [RC [PG [GF [Glob [VAL [WDmu INJ]]]]]]].

 simpl in *. inv MC; simpl in *; inv AtExtSrc.

 destruct fd; inv H0.

 destruct tfd; inv AtExtTgt.

 eexists. eexists.

    split. reflexivity.

    split. reflexivity.

 simpl in *.

 inv TY.

 assert (INCvisNu': inject_incr

  (restrict (as_inj nu')

     (vis

        (replace_externs nu'

           (fun b : Values.block =>

            DomSrc nu' b &&

            (negb (locBlocksSrc nu' b) &&

             REACH m1' (exportedSrc nu' (ret1 :: nil)) b))

           (fun b : Values.block =>

            DomTgt nu' b &&

            (negb (locBlocksTgt nu' b) &&

             REACH m2' (exportedTgt nu' (ret2 :: nil)) b))))) (as_inj nu')).

      unfold vis. rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc.

      apply restrict_incr.

assert (RC': REACH_closed m1' (mapped (as_inj nu'))).

        eapply inject_REACH_closed; eassumption.

assert (PHnu': meminj_preserves_globals (Genv.globalenv prog) (as_inj nu')).

    subst. clear - INC SEP PG Glob WDmu WDnu'.

    apply meminj_preserves_genv2blocks in PG.

    destruct PG as [PGa [PGb PGc]].

    apply meminj_preserves_genv2blocks.

    split; intros.

      specialize (PGa _ H).

      apply joinI; left. apply INC.

      rewrite replace_locals_extern.

      assert (GG: isGlobalBlock ge b = true).

          unfold isGlobalBlock, ge. apply genv2blocksBool_char1 in H.

          rewrite H. trivial.

      destruct (frgnSrc _ WDmu _ (Glob _ GG)) as [bb2 [dd [FF FT2]]].

      rewrite (foreign_in_all _ _ _ _ FF) in PGa. inv PGa.

      apply foreign_in_extern; eassumption.

    split; intros. specialize (PGb _ H).

      apply joinI; left. apply INC.

      rewrite replace_locals_extern.

      assert (GG: isGlobalBlock ge b = true).

          unfold isGlobalBlock, ge. apply genv2blocksBool_char2 in H.

          rewrite H. intuition.

      destruct (frgnSrc _ WDmu _ (Glob _ GG)) as [bb2 [dd [FF FT2]]].

      rewrite (foreign_in_all _ _ _ _ FF) in PGb. inv PGb.

      apply foreign_in_extern; eassumption.

    eapply (PGc _ _ delta H). specialize (PGb _ H). clear PGa PGc.

      remember (as_inj mu b1) as d.

      destruct d; apply eq_sym in Heqd.

        destruct p.

        apply extern_incr_as_inj in INC; trivial.

        rewrite replace_locals_as_inj in INC.

        rewrite (INC _ _ _ Heqd) in H0. trivial.

      destruct SEP as [SEPa _].

        rewrite replace_locals_as_inj, replace_locals_DomSrc, replace_locals_DomTgt in SEPa.

        destruct (SEPa _ _ _ Heqd H0).

        destruct (as_inj_DomRng _ _ _ _ PGb WDmu).

        congruence.

assert (RR1: REACH_closed m1'

  (fun b : Values.block =>

   locBlocksSrc nu' b

   || DomSrc nu' b &&

      (negb (locBlocksSrc nu' b) &&

       REACH m1' (exportedSrc nu' (ret1 :: nil)) b))).

  intros b Hb. rewrite REACHAX in Hb. destruct Hb as [L HL].

  generalize dependent b.

  induction L; simpl; intros; inv HL.

     assumption.

  specialize (IHL _ H1); clear H1.

  apply orb_true_iff in IHL.

  remember (locBlocksSrc nu' b') as l.

  destruct l; apply eq_sym in Heql.

  

    clear IHL.

    remember (pubBlocksSrc nu' b') as p.

    destruct p; apply eq_sym in Heqp.

      assert (Rb': REACH m1' (mapped (as_inj nu')) b' = true).

        apply REACH_nil.

        destruct (pubSrc _ WDnu' _ Heqp) as [bb2 [dd1 [PUB PT]]].

        eapply mappedI_true.

         apply (pub_in_all _ WDnu' _ _ _ PUB).

      assert (Rb:  REACH m1' (mapped (as_inj nu')) b = true).

        eapply REACH_cons; try eassumption.

      specialize (RC' _ Rb).

      destruct (mappedD_true _ _ RC') as [[b2 d1] AI'].

      remember (locBlocksSrc nu' b) as d.

      destruct d; simpl; trivial.

      apply andb_true_iff.

      split. eapply as_inj_DomRng; try eassumption.

      eapply REACH_cons; try eassumption.

        apply REACH_nil. unfold exportedSrc.

        rewrite (pubSrc_shared _ WDnu' _ Heqp). intuition.

      destruct (UnchPrivSrc) as [UP UV]; clear UnchLOOR.

        specialize (UP b' z Cur Readable).

        specialize (UV b' z).

        destruct INC as [_ [_ [_ [_ [LCnu' [_ [PBnu' [_ [FRGnu' _]]]]]]]]].

        rewrite <- LCnu'. rewrite replace_locals_locBlocksSrc.

        rewrite <- LCnu' in Heql. rewrite replace_locals_locBlocksSrc in *.

        rewrite <- PBnu' in Heqp. rewrite replace_locals_pubBlocksSrc in *.

        clear INCvisNu'.

        rewrite Heql in *. simpl in *. intuition.

        assert (VB: Mem.valid_block m1 b').

          eapply VAL. unfold DOM, DomSrc. rewrite Heql. intuition.

        apply (H VB) in H2.

        rewrite (H0 H2) in H4. clear H H0.

        remember (locBlocksSrc mu b) as q.

        destruct q; simpl; trivial; apply eq_sym in Heqq.

        assert (Rb : REACH m1 (vis mu) b = true).

           eapply REACH_cons; try eassumption.

           apply REACH_nil. unfold vis. rewrite Heql; trivial.

        specialize (RC _ Rb). unfold vis in RC.

           rewrite Heqq in RC; simpl in *.

        rewrite replace_locals_frgnBlocksSrc in FRGnu'.

        rewrite FRGnu' in RC.

        apply andb_true_iff.

        split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ RC). intuition.

        apply REACH_nil. unfold exportedSrc.

          rewrite (frgnSrc_shared _ WDnu' _ RC). intuition.

  
    destruct IHL. congruence.

    apply andb_true_iff in H. simpl in H.

    destruct H as [DomNu' Rb'].

    clear INC SEP INCvisNu' UnchLOOR UnchPrivSrc.

    remember (locBlocksSrc nu' b) as d.

    destruct d; simpl; trivial. apply eq_sym in Heqd.

    apply andb_true_iff.

    split. assert (RET: Forall2 (val_inject (as_inj nu')) (ret1::nil) (ret2::nil)).

              constructor. assumption. constructor.

           destruct (REACH_as_inj _ WDnu' _ _ _ _ MemInjNu' RET

               _ Rb' (fun b => true)) as [b2 [d1 [AI' _]]]; trivial.

           assert (REACH m1' (mapped (as_inj nu')) b = true).

             eapply REACH_cons; try eassumption.

             apply REACH_nil. eapply mappedI_true; eassumption.

           specialize (RC' _ H).

           destruct (mappedD_true _ _ RC') as [[? ?] ?].

           eapply as_inj_DomRng; eassumption.

    eapply REACH_cons; try eassumption.



assert (RRC: REACH_closed m1' (fun b : Values.block =>

                         mapped (as_inj nu') b &&

                           (locBlocksSrc nu' b

                            || DomSrc nu' b &&

                               (negb (locBlocksSrc nu' b) &&

                           REACH m1' (exportedSrc nu' (ret1 :: nil)) b)))).

  eapply REACH_closed_intersection; eassumption.

assert (GFnu': forall b, isGlobalBlock (Genv.globalenv prog) b = true ->

               DomSrc nu' b &&

               (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b) = true).

     intros. specialize (Glob _ H).

       assert (FSRC:= extern_incr_frgnBlocksSrc _ _ INC).

          rewrite replace_locals_frgnBlocksSrc in FSRC.

       rewrite FSRC in Glob.

       rewrite (frgnBlocksSrc_locBlocksSrc _ WDnu' _ Glob).

       apply andb_true_iff; simpl.

        split.

          unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ Glob). intuition.

          apply REACH_nil. unfold exportedSrc.

          rewrite (frgnSrc_shared _ WDnu' _ Glob). intuition.

split.

  unfold vis in *.

  rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc in *.

  econstructor; try eassumption.

    eapply match_cont_inject_incr; try eassumption.

      rewrite replace_externs_as_inj.

      clear RRC RR1 RC' PHnu' INCvisNu' UnchLOOR UnchPrivSrc.

      destruct INC. rewrite replace_locals_extern in H.

        rewrite replace_locals_frgnBlocksTgt, replace_locals_frgnBlocksSrc,

                replace_locals_pubBlocksTgt, replace_locals_pubBlocksSrc,

                replace_locals_locBlocksTgt, replace_locals_locBlocksSrc,

                replace_locals_extBlocksTgt, replace_locals_extBlocksSrc,

                replace_locals_local in H0.

        destruct H0 as [? [? [? [? [? [? [? [? ?]]]]]]]].

        red; intros. destruct (restrictD_Some _ _ _ _ _ H9); clear H9.

          apply restrictI_Some.

            apply joinI.

            destruct (joinD_Some _ _ _ _ _ H10).

              apply H in H9. left; trivial.

            destruct H9. right. rewrite H0 in H12.

              split; trivial.

              destruct (disjoint_extern_local _ WDnu' b); trivial. congruence.

          rewrite H3, H7 in H11.

            remember (locBlocksSrc nu' b) as d.

            destruct d; trivial; simpl in *.

            apply andb_true_iff.

            split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ H11). intuition.

               apply REACH_nil. unfold exportedSrc.

                 apply frgnSrc_shared in H11; trivial. rewrite H11; intuition.

      rewrite replace_externs_as_inj. 

       eapply restrict_val_inject; try eassumption.

       intros.

        destruct (getBlocks_inject (as_inj nu') (ret1::nil) (ret2::nil))

           with (b:=b) as [bb [dd [JJ' GBbb]]]; try eassumption.

          constructor. assumption. constructor.

        remember (locBlocksSrc nu' b) as d.

        destruct d; simpl; trivial. apply andb_true_iff.

        split. eapply as_inj_DomRng; eassumption.

        apply REACH_nil. unfold exportedSrc.

           rewrite H. trivial.

unfold vis.

rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc,

        replace_externs_as_inj.

destruct (eff_after_check2 _ _ _ _ _ MemInjNu' RValInjNu'

      _ (eq_refl _) _ (eq_refl _) _ (eq_refl _) WDnu' SMvalNu').

intuition.



  red; intros. destruct (GF _ _ H1). split; trivial.

  eapply extern_incr_as_inj; try eassumption.

  rewrite replace_locals_as_inj. assumption.

Qed.



Lemma transl_expr_correctMu: forall e le m a v te tle tm mu

       (EVAL: Clight.eval_expr ge e le m a v)

       (MENV : match_env (restrict (as_inj mu) (vis mu)) e te)

       (TENV : match_tempenv (restrict (as_inj mu) (vis mu)) le tle)

       (INJ : Mem.inject (as_inj mu) m tm)

       (PG : meminj_preserves_globals ge (as_inj mu))

       (RC: REACH_closed m (vis mu))

       (GLOB: forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true),

       forall ta, transl_expr a = OK ta ->

       exists tv, val_inject (restrict (as_inj mu) (vis mu)) v tv /\

            eval_expr tge te tle tm ta tv.

Proof. intros.

         assert (MinjR:  Mem.inject (restrict (as_inj mu) (vis mu)) m tm).

           eapply inject_restrict; eassumption.

         assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

           assert (PGR': meminj_preserves_globals ge (as_inj (restrict_sm mu (vis mu)))).

              eapply restrict_sm_preserves_globals; try eassumption.

              unfold vis. intuition.

           rewrite restrict_sm_all in PGR'. assumption.

      eapply (transl_expr_correct _ _ _ _ _ _ _ MENV TENV MinjR PGR); eassumption.

Qed.



Lemma transl_arglist_correctMu:

  forall e le m al tyl vl mu te tle tm

        (EVAL:Clight.eval_exprlist ge e le m al tyl vl)

       (MENV : match_env (restrict (as_inj mu) (vis mu)) e te)

       (TENV : match_tempenv (restrict (as_inj mu) (vis mu)) le tle)

       (INJ : Mem.inject (as_inj mu) m tm)

       (PG : meminj_preserves_globals ge (as_inj mu))

       (RC: REACH_closed m (vis mu))

       (GLOB: forall b, isGlobalBlock ge b = true -> frgnBlocksSrc mu b = true),

  forall tal, transl_arglist al tyl = OK tal ->

  exists tvl, val_list_inject (restrict (as_inj mu) (vis mu)) vl tvl /\

  Csharpminor.eval_exprlist tge te tle tm tal tvl.

Proof. intros.

         assert (MinjR:  Mem.inject (restrict (as_inj mu) (vis mu)) m tm).

           eapply inject_restrict; eassumption.

         assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

           assert (PGR': meminj_preserves_globals ge (as_inj (restrict_sm mu (vis mu)))).

              eapply restrict_sm_preserves_globals; try eassumption.

              unfold vis. intuition.

           rewrite restrict_sm_all in PGR'. assumption.

      eapply transl_arglist_correct; try eassumption.

Qed.



Lemma blocks_of_bindingD: forall l b lo hi

      (I: In (b,lo,hi) (map block_of_binding l)),

      lo=0 /\ exists x, In (x,(b,hi)) l.

Proof. intros l.

  induction l; simpl; intros. contradiction.

  destruct I.

    destruct a as [? [? ?]]. simpl in H. inv H.

    split; trivial. exists i; left; trivial.

  destruct (IHl _ _ _ H) as [HH [x Hx]].

  split; trivial. exists x; right; trivial.

Qed.



Lemma blocks_of_envD: forall te b lo hi

       (I:In (b, lo, hi) (blocks_of_env te)),

  lo = 0 /\ exists x, te!x=Some(b,hi).

Proof. intros.

  destruct (blocks_of_bindingD _ _ _ _ I) as [HH [x Hx]].

  split; trivial.

  exists x. eapply PTree.elements_complete. apply Hx.

Qed.



Lemma MATCH_corestep: forall

 
  (GDE : genvs_domain_eq ge tge)

  (st1 : CL_core) (m1 : mem) (st1' : CL_core) (m1' : mem)



  (CS: corestep CL_eff_sem2 ge st1 m1 st1' m1')

  (st2 : CSharpMin_core) (mu : SM_Injection) (m2 : mem)

  (MC: MATCH st1 mu st1 m1 st2 m2),

exists (st2' : CSharpMin_core) (m2' : mem) (mu' : SM_Injection),



  corestep_plus csharpmin_eff_sem tge st2 m2 st2' m2' /\

  intern_incr mu mu' /\

  sm_inject_separated mu mu' m1 m2 /\

  sm_locally_allocated mu mu' m1 m2 m1' m2' /\

  MATCH st1' mu' st1' m1' st2' m2' /\

  SM_wd mu' /\ sm_valid mu' m1' m2'.

Proof.

  intros.

  inv CS; simpl in *.



      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      try (monadInv TR).

      destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      assert (SAME: ts' = ts /\ tk' = tk).

        inversion MTR. auto.

        subst ts. unfold make_store, make_memcpy in EQ3.

        destruct (access_mode (typeof a1)); congruence.

      destruct SAME; subst ts' tk'.

      assert (MinjR:  Mem.inject (restrict (as_inj mu) (vis mu)) m1 m2).

           eapply inject_restrict; eassumption.

      assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

           rewrite <- restrict_sm_all.

           eapply restrict_sm_preserves_globals; try eassumption.

           unfold vis. intuition.

      destruct (transl_lvalue_correct _ _ _ _ _ _ _ MENV TENV MinjR PGR _ _ _ H _ EQ)

            as [vv [Hvv1 EvalX]]; inv Hvv1.

      destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV MinjR PGR _ _ H0 _ EQ1)

            as [uu [VinjU EvalX0]].

      destruct (sem_cast_inject _ _ _ _ _ _ H1 VinjU) as [? [? ?]].

         assert (EVAL:= make_cast_correct _ _ _ _ _ _ _ _ _ _ EQ0 EvalX0 H3).

      destruct (assign_loc_inject _ _ _ _ _ _ _ H2 _ _ H4 _ _ H5 _ INJ)

            as [m2' [AL2 MINJ']].

      eexists. eexists. exists mu.

      split.

         apply corestep_plus_one.

         eapply make_store_correct. eapply EQ3. eassumption. eassumption. eassumption.

      assert (SMV': sm_valid mu m1' m2').

        inv H2.

        

        inv AL2.

          split; intros.

            eapply storev_valid_block_1; try eassumption.

            eapply SMV; assumption.

          eapply storev_valid_block_1; try eassumption.

            eapply SMV; assumption.

        rewrite H2 in H6. discriminate.

        

        inv AL2.

          rewrite H2 in H6. discriminate.

        split; intros.

            eapply Mem.storebytes_valid_block_1; try eassumption.

            eapply SMV; assumption.

          eapply Mem.storebytes_valid_block_1; try eassumption.

            eapply SMV; assumption.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

        repeat split; extensionality b;

        try rewrite (assign_loc_freshloc _ _ _ _ _ _ AL2);

        try rewrite (assign_loc_freshloc _ _ _ _ _ _ H2); intuition.

      econstructor.

        eapply match_states_skip; eauto.

        intuition.

        

          inv H2.

          

             inv H7.

             eapply REACH_Store; try eassumption.

             apply (restrictD_Some _ _ _ _ _ H5).

             intros b' Hb'. rewrite getBlocksD, getBlocksD_nil in Hb'.

               destruct v; inv Hb'. rewrite orb_false_r in H7.

               rewrite H7. simpl.

              assert (b=b').

                remember (eq_block b b') as d.

                destruct d; intuition.

              subst. inv H4. apply (restrictD_Some _ _ _ _ _ H10).

          

             eapply REACH_Storebytes; try eassumption.

             apply (restrictD_Some _ _ _ _ _ H5).

             intros bb off n Hbb. inv H4.

             destruct (Mem.loadbytes_inject _ _ _ _ _ _ _ _ _ MinjR H10 H13)

                as [bytes2 [LoadBytes2 MapBytes]].

             clear - Hbb MapBytes.

               induction MapBytes; inv Hbb.

               inv H. apply (restrictD_Some _ _ _ _ _ H4).

               apply (IHMapBytes H0).

        
      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      try (monadInv TR).

      inv MTR. destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      exploit transl_expr_correctMu; try eassumption.

        intros [uu [VinjU EvalX0]].

      eexists; eexists. exists mu.

      split. apply corestep_plus_one.

               econstructor. eassumption.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

        eapply match_tempenv_set; eassumption.

      intuition.

  

      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      revert TR. simpl. case_eq (classify_fun (typeof a)); try congruence.

      intros targs tres CF TR. monadInv TR. inv MTR.

      exploit functions_translated; eauto. intros [tfd [FIND TFD]].

      rewrite H in CF. simpl in CF. inv CF.

      destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      exploit transl_expr_correctMu; try eassumption.

        intros [tvf [VinjE EvalE]].

      exploit transl_arglist_correctMu; try eassumption.

        intros [tvl [Vargs EvalArgs]].

      inv VinjE; inv FIND.

      destruct (Int.eq_dec ofs1 Int.zero); try inv H6.

      destruct (GF _ _ H2).

      destruct (restrictD_Some _ _ _ _ _ H4).

      rewrite H8 in H5; inv H5.

      eexists; eexists. exists mu.

      split. apply corestep_plus_one.

               econstructor; try eassumption.

               eapply transl_fundef_sig1; eauto.

             rewrite H3. auto.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

          econstructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           apply csharpmin_corestep_skip_seq.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           econstructor; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           econstructor; eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  exploit make_boolean_inject; eauto.

      eapply inject_restrict; eassumption.

      assert (PGR': meminj_preserves_globals ge (as_inj (restrict_sm mu (vis mu)))).

              eapply restrict_sm_preserves_globals; try eassumption.

              unfold vis. intuition.

           rewrite restrict_sm_all in PGR'. assumption.

  intros [tv [Etv Btv]].

  exploit transl_expr_correctMu; try eassumption.

        intros [tv1 [V1inj EvalV1]].

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

         apply csharpmin_corestep_ifthenelse with (v := tv) (b := b); auto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        destruct b; econstructor; eauto; constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR.

  exists (CSharpMin_State tf x

     (Kblock (Kseq x0 (Kseq (Sloop (Sseq (Sblock x) x0)) (Kblock tk)))) te tle).

  eexists. exists mu.

  split.

    eapply corestep_star_plus_trans.

      eapply match_transl_corestep; eauto.

    eapply corestep_plus_star_trans.

      eapply corestep_plus_one.

        econstructor.

    eapply corestep_star_trans.

      eapply corestep_star_one.

        econstructor.

      eapply corestep_star_one.

        econstructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; try eassumption.

          econstructor.

          econstructor; eassumption.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  assert ((ts' = Sskip \/ ts' = Sexit ncnt) /\ tk' = tk).

    destruct H; subst x; monadInv TR; inv MTR; auto.

  destruct H0. inv MK.

  eexists; eexists. exists mu.

  split. eapply corestep_plus_star_trans.

          destruct H0; subst ts'.

           Focus 2. eapply corestep_plus_one. econstructor.

           eapply corestep_plus_one. econstructor.

         eapply corestep_star_one.

          econstructor.

  clear H0 H.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eapply corestep_plus_star_trans.

           eapply corestep_plus_one. econstructor.

         eapply corestep_star_trans.

           eapply corestep_star_one.

             econstructor.

         eapply corestep_star_trans.

           eapply corestep_star_one.

             econstructor.

           eapply corestep_star_one.

             econstructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one. constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

          simpl. rewrite H5; simpl. rewrite H7; simpl. eauto.

          constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eapply corestep_plus_trans.

           eapply corestep_plus_one. constructor.

           eapply corestep_plus_one. constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  exploit match_env_free_blocks_parallel_inject; eauto.

      eapply inject_restrict; eassumption.

    intros [m2' [FL2 Inj']].

  eexists; eexists. exists mu.

  split. apply corestep_plus_one. constructor. eassumption.

  assert (SMV': sm_valid mu m1' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H); intuition.

      econstructor.

        econstructor; eauto.

          eapply match_cont_call_cont. eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m1 m2).

      eapply inject_restrict; eassumption.

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit match_env_free_blocks_parallel_inject; eauto.

    intros [m2' [FL2 Inj']].

  destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV InjR

            PGR _ _ H _ EQ) as [tv [VInj EvalA]].

  destruct (sem_cast_inject _ _ _ _ _ _ H0 VInj) as [tv' [SemCast' VInj']].

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           constructor; try eassumption.

           eapply make_cast_correct; eauto.

  assert (SMV': sm_valid mu m1' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H1); intuition.

      econstructor.

        econstructor; eauto.

          eapply match_cont_call_cont. eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  exploit match_cont_is_call_cont; eauto. intros [A B].

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m1 m2).

      eapply inject_restrict; eassumption.

  destruct (match_env_free_blocks_parallel_inject _ _ _ _ _ _ MENV InjR H0) as [m2' [FL2 Inj']].

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           apply csharpmin_corestep_skip_call. auto.

           eassumption.

  assert (SMV': sm_valid mu m1' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H0); intuition.

      econstructor.

        econstructor; eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m1' m2).

      eapply inject_restrict; eassumption.

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV InjR

            PGR _ _ H _ EQ) as [tv [VInj EvalA]].

  inv VInj.



  eexists; eexists. exists mu.

  split. eapply corestep_star_plus_trans.

           eapply match_transl_corestep; eauto.

         eapply corestep_plus_one.

           econstructor. eauto.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; try eassumption.

          apply transl_lbl_stmt_2. apply transl_lbl_stmt_1. eauto.

          constructor.

          econstructor. eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  assert ((ts' = Sskip \/ ts' = Sexit nbrk) /\ tk' = tk).

    destruct H; subst x; monadInv TR; inv MTR; auto.

  destruct H0. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           destruct H0; subst ts'.

            2: constructor. constructor.

  clear H0 H.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. simpl. reflexivity. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  generalize TRF. unfold transl_function. intro TRF'. monadInv TRF'.

  exploit (transl_find_label lbl). eexact EQ.

  eapply match_cont_call_cont. eauto.

  rewrite H.

  intros [ts' [tk'' [nbrk' [ncnt' [A [B C]]]]]].

  eexists; eexists. exists mu.

  split. apply corestep_plus_one.

           constructor. simpl. eexact A.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  inv H. monadInv TR. monadInv EQ.

  exploit match_cont_is_call_cont; eauto. intros [A B].

  exploit match_env_alloc_variables; try eassumption.

    apply match_env_empty.

  intros [te1 [m2' [mu' [AVars2 [MENV' [INJ' [INC'

         [SEP' [LAC' [WD' [VAL' RC']]]]]]]]]]].

  specialize (create_undef_temps_match_inject

         (Clight.fn_temps f) (restrict (as_inj mu') (vis mu'))); intros.

  destruct (bind_parameter_temps_match_inject

       _ _ _ _ H4 _ _ H args2)

     as [tle [BP TENV]].

     eapply val_list_inject_incr; try eassumption.

       eapply intern_incr_restrict; eassumption.

  eexists; exists m2'. exists mu'.

  split. apply corestep_plus_one.

           eapply csharpmin_corestep_internal_function.

         simpl. rewrite list_map_compose. simpl. assumption.

         simpl. auto.

         simpl. auto.

         simpl. eauto.

         simpl. eassumption.

  intuition.

    constructor.

      simpl. econstructor; try eassumption.

         unfold transl_function. rewrite EQ0; simpl. auto.

         constructor.

         eapply match_cont_inject_incr; try eassumption.

           eapply intern_incr_restrict; eassumption.

    destruct (@intern_incr_meminj_preserves_globals_as_inj _ _ ge _ WD) with (mu' := mu').

        split; trivial. trivial. trivial.

    intuition.

       red; intros. destruct (GF _ _ H8). split; trivial.

           eapply intern_incr_as_inj; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  inv MK.

  eexists; exists m2. exists mu.

  split. apply corestep_plus_one.

           constructor.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. simpl; reflexivity.

           constructor.

        unfold set_opttemp.

        destruct optid.

          eapply match_tempenv_set; eassumption.

          simpl. assumption.

      intuition.

Qed.



Lemma restrict_vis_foreign: forall mu (WD: SM_wd mu) b1 b2 delta

         (R: restrict (as_inj mu) (vis mu) b1 = Some (b2, delta))

         (LT: locBlocksTgt mu b2 = false),

      foreign_of mu b1 = Some (b2, delta).

Proof. intros.

  destruct (restrictD_Some _ _ _ _ _ R).

  unfold vis in H0.

  destruct (joinD_Some _ _ _ _ _ H) as [EXT | [_ LOC]].

    assert (LS: locBlocksSrc mu b1 = false). eapply extern_DomRng'; try eassumption.

    rewrite LS in *; simpl in *. destruct (frgnSrc _ WD _ H0) as [bb2 [dd [FRG FT]]].

      rewrite FRG. rewrite (foreign_in_all _ _ _ _ FRG) in H. trivial.

  destruct (local_DomRng _ WD _ _ _ LOC). rewrite H2 in LT; discriminate.

Qed.



Lemma Match_effcore_diagram: forall



  (GDE : genvs_domain_eq ge tge)

  (st1 : CL_core) (m1 : mem) (st1' : CL_core) (m1' : mem)

  (U1 : block -> Z -> bool)



  (EFFSTEP: effstep CL_eff_sem2 ge U1 st1 m1 st1' m1')

  (st2 : CSharpMin_core) (mu : SM_Injection) (m2 : mem)

  (UHyp: forall b z, U1 b z = true ->

          Mem.valid_block m1 b -> vis mu b = true)

  (MC: MATCH st1 mu st1 m1 st2 m2),

exists (st2' : CSharpMin_core) (m2' : mem) (mu' : SM_Injection),

  (exists U2 : block -> Z -> bool,

     (effstep_plus csharpmin_eff_sem tge U2 st2 m2 st2' m2' /\

     (forall (b : block) (ofs : Z),

      U2 b ofs = true ->

      Mem.valid_block m2 b /\

      (locBlocksTgt mu b = false ->

       exists (b1 : block) (delta1 : Z),

         foreign_of mu b1 = Some (b, delta1) /\

         U1 b1 (ofs - delta1) = true /\

         Mem.perm m1 b1 (ofs - delta1) Max Nonempty))))

  /\

  intern_incr mu mu' /\

  sm_inject_separated mu mu' m1 m2 /\

  sm_locally_allocated mu mu' m1 m2 m1' m2' /\

  MATCH st1' mu' st1' m1' st2' m2'.

Proof.

  intros.

  induction EFFSTEP; simpl in *.



      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      try (monadInv TR).

      destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      assert (SAME: ts' = ts /\ tk' = tk).

        inversion MTR. auto.

        subst ts. unfold make_store, make_memcpy in EQ3.

        destruct (access_mode (typeof a1)); congruence.

      destruct SAME; subst ts' tk'.

      assert (MinjR:  Mem.inject (restrict (as_inj mu) (vis mu)) m m2).

           eapply inject_restrict; eassumption.

      assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

           rewrite <- restrict_sm_all.

           eapply restrict_sm_preserves_globals; try eassumption.

           unfold vis. intuition.

      destruct (transl_lvalue_correct _ _ _ _ _ _ _ MENV TENV MinjR PGR _ _ _ H _ EQ)

            as [vv [Hvv1 EvalX]]; inv Hvv1.

      destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV MinjR PGR _ _ H0 _ EQ1)

            as [uu [VinjU EvalX0]].

      destruct (sem_cast_inject _ _ _ _ _ _ H1 VinjU) as [? [? ?]].

      assert (EVAL:= make_cast_correct _ _ _ _ _ _ _ _ _ _ EQ0 EvalX0 H3).

      destruct (assign_loc_inject _ _ _ _ _ _ _ H2 _ _ H4 _ _ H5 _ INJ)

        as [m2' [AssignLoc' Minj']].

      exploit (make_store_correct_AssignlocEffect tge x (typeof a1) x1); try eassumption.

      intros MSCE. 


        eexists. eexists. exists mu.

        split. exists (assign_loc_Effect (typeof a1) b2 (Int.add ofs (Int.repr delta)) x2).

               split. apply effstep_plus_one. eassumption.

        intros. unfold assign_loc_Effect in H6. unfold assign_loc_Effect.

                inv H2. inv AssignLoc'; rewrite H2 in H7; inv H7.

                   rewrite H2 in *.

                   destruct (eq_block b2 b); subst; simpl in *; try discriminate.

                   destruct (restrictD_Some _ _ _ _ _ H5).

                   split. eapply SMV. eapply as_inj_DomRng; eassumption.

                   intros. exists loc, delta.

                   split. eapply restrict_vis_foreign; eassumption.

                   assert (WR:Mem.perm m loc (Int.unsigned ofs) Cur Writable).

                      eapply Mem.store_valid_access_3; try eassumption. specialize (size_chunk_pos chunk); intros. omega.

                   specialize (Mem.address_inject _ _ _ loc ofs b delta Writable INJ WR H7). intros.

                   destruct (eq_block loc loc); simpl.

                     clear e0. rewrite H12 in H6.

                               destruct (zle (Int.unsigned ofs + delta) ofs0); simpl in H6; try discriminate.

                               destruct (zle (Int.unsigned ofs) (ofs0 - delta)); simpl.

                               Focus 2. exfalso. clear - l g. omega.

                               rewrite encode_val_length.  rewrite encode_val_length in H6.

                               destruct (zlt ofs0 (Int.unsigned ofs + delta + Z.of_nat (size_chunk_nat chunk))); try discriminate.

                               destruct (zlt (ofs0 - delta) (Int.unsigned ofs + Z.of_nat (size_chunk_nat chunk))); simpl.

                               Focus 2. exfalso. clear - l1 g. omega.

                               split; trivial. rewrite <- size_chunk_conv in l2.

                               eapply Mem.perm_implies.

                                  eapply Mem.perm_max.

                                    eapply Mem.store_valid_access_3; eauto.

                                  apply perm_any_N.

                   elim n; trivial.

                 inv AssignLoc'; rewrite H2 in H7; inv H7. rewrite H2 in *.

                   destruct (eq_block b b2); subst; simpl in *; try discriminate.

                   destruct (restrictD_Some _ _ _ _ _ H5).

                   split. eapply SMV. eapply as_inj_DomRng; eassumption.

                   intros. exists loc, delta.

                   split. eapply restrict_vis_foreign; eassumption.

                   assert (WR:Mem.perm m loc (Int.unsigned ofs) Cur Writable).

                      eapply Mem.storebytes_range_perm; try eassumption.

                         rewrite (Mem.loadbytes_length _ _ _ _ _ H11).

                         specialize (sizeof_pos (typeof a1)); intros.

                         rewrite nat_of_Z_eq.

                         omega. omega.

                   specialize (Mem.address_inject _ _ _ loc ofs b2 delta Writable INJ WR H7). intros.

                   destruct (eq_block loc loc); simpl.

                     clear e0. rewrite H20 in H6.

                               destruct (zle (Int.unsigned ofs + delta) ofs0); simpl in H6; try discriminate.

                               destruct (zle (Int.unsigned ofs) (ofs0 - delta)); simpl.

                               Focus 2. exfalso. clear - l g. omega.

                               specialize (sizeof_pos (typeof a1)); intros.

                               destruct (zlt ofs0 (Int.unsigned ofs + delta + sizeof (typeof a1))); try discriminate.

                               destruct (zlt (ofs0 - delta) (Int.unsigned ofs + sizeof (typeof a1))); simpl.

                               Focus 2. exfalso. clear - l1 g. omega.

                               split; trivial.

                               eapply Mem.perm_implies.

                                  eapply Mem.perm_max.

                                    eapply Mem.storebytes_range_perm; eauto.

                                     split. omega. specialize (Mem.loadbytes_length _ _ _ _ _ H11); intros. rewrite H22. rewrite nat_of_Z_eq. assumption. omega.

                                  apply perm_any_N.

                   elim n; trivial.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

        repeat split; extensionality b.

        rewrite (assign_loc_freshloc _ _ _ _ _ _ H2). intuition.

        rewrite (assign_loc_freshloc _ _ _ _ _ _ AssignLoc'). intuition.

        rewrite (assign_loc_freshloc _ _ _ _ _ _ H2). intuition.

        rewrite (assign_loc_freshloc _ _ _ _ _ _ AssignLoc'). intuition.

      econstructor.

        econstructor; eauto. reflexivity. constructor.

        destruct (restrictD_Some _ _ _ _ _ H5).

        intuition.

        clear MSCE AssignLoc'.

        inv H2. inv H9.

           eapply REACH_Store; try eassumption.

           intros. rewrite getBlocks_char in H2.

             destruct H2.

             destruct H2; try contradiction; subst.

             inv H4. destruct (restrictD_Some _ _ _ _ _ H11); trivial.

        inv H4. destruct (restrictD_Some _ _ _ _ _ H15).

          eapply REACH_Storebytes; try eassumption.

          simpl; intros.

          destruct (Mem.loadbytes_inject _ _ _ _ _ _ _ _ _ MinjR H12 H15) as [bytes' [_ MVInj]].

          clear H12 H13.

          induction MVInj; simpl in *. contradiction.

          destruct H14; subst.

            inv H12. destruct (restrictD_Some _ _ _ _ _ H18); trivial.

          apply (IHMVInj H13).



       split; intros; eapply assign_loc_forward; try eassumption.

          eapply SMV; apply H8.

          eapply SMV; apply H8.

  

      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      try (monadInv TR).

      inv MTR. destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      exploit transl_expr_correctMu; try eassumption.

        intros [uu [VinjU EvalX0]].

      eexists; eexists. exists mu.

      split. eexists; split.

             apply effstep_plus_one.

               econstructor. eassumption.

               intuition.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

        eapply match_tempenv_set; eassumption.

      intuition.

  

      destruct MC as [SMC PRE].

      inv SMC; simpl in *.

      revert TR. simpl. case_eq (classify_fun (typeof a)); try congruence.

      intros targs tres CF TR. monadInv TR. inv MTR.

      exploit functions_translated; eauto. intros [tfd [FIND TFD]].

      rewrite H in CF. simpl in CF. inv CF.

      destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

      exploit transl_expr_correctMu; try eassumption.

        intros [tvf [VinjE EvalE]].

      exploit transl_arglist_correctMu; try eassumption.

        intros [tvl [Vargs EvalArgs]].

      inv VinjE; inv FIND.

      destruct (Int.eq_dec ofs1 Int.zero); try inv H6.

      destruct (GF _ _ H2).

      destruct (restrictD_Some _ _ _ _ _ H4).

      rewrite H8 in H5; inv H5.

      eexists; eexists. exists mu.

      split. eexists; split.

               apply effstep_plus_one.

                 econstructor; try eassumption.

                 eapply transl_fundef_sig1; eauto.

                 rewrite H3. auto.

               intuition.

      intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

          econstructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor.

           intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

           apply csharpmin_effstep_skip_seq.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             econstructor; eauto.

           intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             econstructor; eauto.

           intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  exploit make_boolean_inject; eauto.

      eapply inject_restrict; eassumption.

      assert (PGR': meminj_preserves_globals ge (as_inj (restrict_sm mu (vis mu)))).

              eapply restrict_sm_preserves_globals; try eassumption.

              unfold vis. intuition.

           rewrite restrict_sm_all in PGR'. assumption.

  intros [tv [Etv Btv]].

  exploit transl_expr_correctMu; try eassumption.

        intros [tv1 [V1inj EvalV1]].

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

           apply csharpmin_effstep_ifthenelse with (v := tv) (b := b); auto.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality bb;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        destruct b; econstructor; eauto; constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR.

  exists (CSharpMin_State tf x

     (Kblock (Kseq x0 (Kseq (Sloop (Sseq (Sblock x) x0)) (Kblock tk)))) te tle).

  eexists. exists mu.

  split.

  eexists; split.

    eapply effstep_star_plus_trans.

      eapply match_transl_effstep; eauto.

    eapply effstep_plus_star_trans.

      eapply effstep_plus_one.

        econstructor.

    eapply effstep_star_trans.

      eapply effstep_star_one.

        econstructor.

      eapply effstep_star_one.

        econstructor.

    intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; try eassumption.

          econstructor.

          econstructor; eassumption.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  assert ((ts' = Sskip \/ ts' = Sexit ncnt) /\ tk' = tk).

    destruct H; subst x; monadInv TR; inv MTR; auto.

  destruct H0. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           eapply effstep_plus_star_trans.

             destruct H0; subst ts'.

               Focus 2. eapply effstep_plus_one. econstructor.

               eapply effstep_plus_one. econstructor.

             eapply effstep_star_one.

               econstructor.

           intuition.

  clear H0 H.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

        econstructor; eauto.

        econstructor; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           eapply effstep_plus_star_trans.

             eapply effstep_plus_one. econstructor.

           eapply effstep_star_trans.

             eapply effstep_star_one.

               econstructor.

           eapply effstep_star_trans.

             eapply effstep_star_one.

               econstructor.

             eapply effstep_star_one.

               econstructor.

        intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one. constructor.

           intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; eauto.

          simpl. rewrite H5; simpl. rewrite H7; simpl. eauto.

          constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           eapply effstep_plus_trans.

             eapply effstep_plus_one. constructor.

             eapply effstep_plus_one. constructor.

           intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  exploit match_env_free_blocks_parallel_inject; eauto.

      eapply inject_restrict; eassumption.

    intros [m2' [FL2 Inj']].

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one. constructor. eassumption.

         intros b2 ofs FEff2.

         split. eapply FreelistEffect_validblock; eassumption.

         intros. eapply FreelistEffect_PropagateLeft; eassumption.

  assert (SMV': sm_valid mu m' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H); intuition.

      econstructor.

        econstructor; eauto.

          eapply match_cont_call_cont. eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m m2).

      eapply inject_restrict; eassumption.

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  exploit match_env_free_blocks_parallel_inject; eauto.

    intros [m2' [FL2 Inj']].

  destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV InjR

            PGR _ _ H _ EQ) as [tv [VInj EvalA]].

  destruct (sem_cast_inject _ _ _ _ _ _ H0 VInj) as [tv' [SemCast' VInj']].

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor; try eassumption.

             eapply make_cast_correct; eauto.

         intros b2 ofs FEff2.

         split. eapply FreelistEffect_validblock; eassumption.

         intros. eapply FreelistEffect_PropagateLeft; eassumption.

  assert (SMV': sm_valid mu m' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H1); intuition.

      econstructor.

        econstructor; eauto.

          eapply match_cont_call_cont. eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  exploit match_cont_is_call_cont; eauto. intros [A B].

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m m2).

      eapply inject_restrict; eassumption.

  destruct (match_env_free_blocks_parallel_inject _ _ _ _ _ _ MENV InjR H0) as [m2' [FL2 Inj']].

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             apply csharpmin_effstep_skip_call. auto.

             eassumption.

         intros b2 ofs FEff2.

         split. eapply FreelistEffect_validblock; eassumption.

         intros. eapply FreelistEffect_PropagateLeft; eassumption.

  assert (SMV': sm_valid mu m' m2').

    split; intros;

      eapply freelist_forward; try eassumption.

      eapply SMV; assumption.

      eapply SMV; assumption.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_free_list _ _ _ FL2);

          try rewrite (freshloc_free_list _ _ _ H0); intuition.

      econstructor.

        econstructor; eauto.

      intuition.

        eapply REACH_closed_freelist; eassumption.

        eapply freelist_freelist_inject; try eassumption.

          eapply match_env_restrictD; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  assert (InjR: Mem.inject (restrict (as_inj mu) (vis mu)) m m2).

      eapply inject_restrict; eassumption.

  assert (PGR: meminj_preserves_globals ge (restrict (as_inj mu) (vis mu))).

     rewrite <- restrict_sm_all.

     eapply restrict_sm_preserves_globals; try eassumption.

     unfold vis. intuition.

  destruct (transl_expr_correct _ _ _ _ _ _ _ MENV TENV InjR

            PGR _ _ H _ EQ) as [tv [VInj EvalA]].

  inv VInj.



  eexists; eexists. exists mu.

  split. eexists; split.

           eapply effstep_star_plus_trans.

             eapply match_transl_effstep; eauto.

           eapply effstep_plus_one.

             econstructor. eauto.

        intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        econstructor; try eassumption.

          apply transl_lbl_stmt_2. apply transl_lbl_stmt_1. eauto.

          constructor.

          econstructor. eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  assert ((ts' = Sskip \/ ts' = Sexit nbrk) /\ tk' = tk).

    destruct H; subst x; monadInv TR; inv MTR; auto.

  destruct H0. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             destruct H0; subst ts'.

              2: constructor. constructor.

         intuition.

  clear H0 H.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      econstructor.

        eapply match_states_skip; eauto.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR. inv MK.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. simpl. reflexivity. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  monadInv TR. inv MTR.

  generalize TRF. unfold transl_function. intro TRF'. monadInv TRF'.

  exploit (transl_find_label lbl). eexact EQ.

  eapply match_cont_call_cont. eauto.

  rewrite H.

  intros [ts' [tk'' [nbrk' [ncnt' [A [B C]]]]]].

  eexists; eexists. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor. simpl. eexact A.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. constructor.

      intuition.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  destruct PRE as [PC [PG [GF [Glob [SMV [WD INJ]]]]]].

  inv H. monadInv TR. monadInv EQ.

  exploit match_cont_is_call_cont; eauto. intros [A B].

  exploit match_env_alloc_variables; try eassumption.

    apply match_env_empty.

  intros [te1 [m2' [mu' [AVars2 [MENV' [INJ' [INC'

         [SEP' [LAC' [WD' [VAL' RC']]]]]]]]]]].

  specialize (create_undef_temps_match_inject

         (Clight.fn_temps f) (restrict (as_inj mu') (vis mu'))); intros.

  destruct (bind_parameter_temps_match_inject

       _ _ _ _ H4 _ _ H args2)

     as [tle [BP TENV]].

     eapply val_list_inject_incr; try eassumption.

       eapply intern_incr_restrict; eassumption.

  eexists; exists m2'. exists mu'.

  split. eexists; split.

           apply effstep_plus_one.

             eapply csharpmin_effstep_internal_function.

           simpl. rewrite list_map_compose. simpl. assumption.

           simpl. auto.

           simpl. auto.

           simpl. eauto.

           simpl. eassumption.

        intuition.

  intuition.

    constructor.

      simpl. econstructor; try eassumption.

         unfold transl_function. rewrite EQ0; simpl. auto.

         constructor.

         eapply match_cont_inject_incr; try eassumption.

           eapply intern_incr_restrict; eassumption.

    destruct (@intern_incr_meminj_preserves_globals_as_inj _ _ ge _ WD) with (mu' := mu').

        split; trivial. trivial. trivial.

    intuition.

       red; intros. destruct (GF _ _ H8). split; trivial.

           eapply intern_incr_as_inj; eassumption.



  destruct MC as [SMC PRE].

  inv SMC; simpl in *.

  inv MK.

  eexists; exists m2. exists mu.

  split. eexists; split.

           apply effstep_plus_one.

             constructor.

         intuition.

  intuition.

      apply intern_incr_refl.

      apply sm_inject_separated_same_sminj.

      apply sm_locally_allocatedChar.

      repeat split; extensionality b;

          try rewrite (freshloc_irrefl); intuition.

      constructor.

        econstructor; eauto. simpl; reflexivity.

           constructor.

        unfold set_opttemp.

        destruct optid.

          eapply match_tempenv_set; eassumption.

          simpl. assumption.

      intuition.



  destruct IHEFFSTEP as [c2' [m2' [mu' X]]].

    intros. eapply UHyp. apply H. assumption. eassumption.

    assumption. assumption.

  exists c2', m2', mu'. intuition.

  destruct H0 as [U2 [HH1 HH2]].

  exists U2; split; trivial.

  intros. destruct (HH2 _ _ H0). clear H0 HH2.

  split; trivial.

  intros. destruct (H6 H0) as [b1 [delta [Frg [HE HP]]]]; clear H6.

  exists b1, delta. split; trivial. split; trivial.

  apply Mem.perm_valid_block in HP.

  apply H; assumption.

Qed.



Theorem transl_program_correct:

  forall (R: list_norepet (map fst (prog_defs prog)))

         entrypoints

         (entry_points_ok :

            forall v1 v2 sig,

              In (v1, v2, sig) entrypoints ->

              exists b f1 f2,

                v1 = Vptr b Int.zero

                /\ v2 = Vptr b Int.zero

                /\ Genv.find_funct_ptr ge b = Some f1

                /\ Genv.find_funct_ptr tge b = Some f2)

         (init_mem: exists m0, Genv.init_mem prog = Some m0)



,

SM_simulation.SM_simulation_inject CL_eff_sem2

   csharpmin_eff_sem ge tge entrypoints.

Proof.

intros.

assert (GDE: genvs_domain_eq ge tge).

    unfold genvs_domain_eq, genv2blocks.

    simpl; split; intros.

     split; intros; destruct H as [id Hid].

       rewrite <- symbols_preserved in Hid.

       exists id; trivial.

     rewrite symbols_preserved in Hid.

       exists id; trivial.

    apply varinfo_preserved.

 eapply sepcomp.effect_simulations_lemmas.inj_simulation_plus with

  (match_states:=MATCH) (measure:=fun x => O).



  assumption.



  apply MATCH_wd.



  apply MATCH_RC.



  apply MATCH_restrict.



  apply MATCH_valid.



  apply MATCH_PG.



  { intros.

    eapply (MATCH_initial _ _ _ entrypoints); eauto.

    destruct init_mem as [m0 INIT].

    exists m0; split; auto.

    unfold meminj_preserves_globals in H3.

    destruct H3 as [A [B C]].



    assert (P: forall p q, {Ple p q} + {Plt q p}).

      intros p q.

      case_eq (Pos.leb p q).

      intros TRUE.

      apply Pos.leb_le in TRUE.

      left; auto.

      intros FALSE.

      apply Pos.leb_gt in FALSE.

      right; auto.



    cut (forall b, Plt b (Mem.nextblock m0) ->

           exists id, Genv.find_symbol ge id = Some b). intro D.



    split.

    destruct (P (Mem.nextblock m0) (Mem.nextblock m1)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m1 (Mem.nextblock m1)).

      eapply Mem.valid_block_inject_1; eauto.

    clear - H8; unfold Mem.valid_block in H8.

    xomega.



    destruct (P (Mem.nextblock m0) (Mem.nextblock m2)); auto.

    exfalso.

    destruct (D _ p).

    apply A in H3.

    assert (Mem.valid_block m2 (Mem.nextblock m2)).

      eapply Mem.valid_block_inject_2; eauto.

    clear - H8; unfold Mem.valid_block in H8.

    xomega.



    intros b LT.

    unfold ge.

    apply valid_init_is_global with (b0 := b) in INIT.

    eapply INIT; auto.

    apply R.

    apply LT. }



  { intros. destruct H as [MC [RC [PG [GF [Glob [VAL [WD INJ]]]]]]].

    destruct c1; inv H0. destruct k; inv H1.

    inv MC. exists res2.

    split. assumption.

    split. eassumption.

    simpl. inv MK. trivial. }



  { intros. destruct H as [MC [RC [PG [GFP [Glob [VAL [WD INJ]]]]]]].

    split; trivial.

    destruct c1; inv H0. destruct fd; inv H1.

    inv MC. simpl. exists args2; intuition.

      apply val_list_inject_forall_inject; eassumption.

    simpl.

    unfold transl_fundef in TR.

      remember (list_typ_eq (sig_args (ef_sig e)) (typlist_of_typelist t) &&

         opt_typ_eq (sig_res (ef_sig e)) (opttyp_of_type t0)).

      destruct b; inv TR. trivial. }



  { apply MATCH_afterExternal. assumption. }



  { intros. exploit MATCH_corestep; try eassumption.

    intros [st2' [m2' [mu' [CS2 MU']]]].

    exists st2', m2', mu'. intuition. }



 { intros. exploit Match_effcore_diagram; try eassumption.

    intros [st2' [m2' [mu' [[U2 CS2] MU']]]].

    exists st2', m2', mu'. intuition.

    exists U2. split. left; assumption. assumption. }

Qed.



End CORRECTNESS.

