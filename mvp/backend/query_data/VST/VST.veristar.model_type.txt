Load loadpath.
Require Import VST.msl.base VST.msl.sepalg.
Require Import veristar.variables.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)

Module Type VERISTAR_LOGIC.

Parameters loc val : Type.
Declare Instance Join_val: Join val.
Declare Instance Perm_val: Perm_alg val.
Declare Instance Sep_val: Sep_alg val.
Declare Instance Canc_val: Canc_alg val.
Parameter val2loc : val -> option loc.
Parameter nil_val : val.
Axiom nil_not_loc : val2loc nil_val = None.

Parameter empty_val : val.
Axiom emp_empty_val : forall v, identity v <-> v = empty_val.
Definition full (v : val) := forall v2, joins v v2 -> identity v2.
Axiom val2loc_full : forall v l, val2loc v = Some l -> full v.
Axiom nil_full : full nil_val.
Axiom empty_not_full : ~full empty_val.
Axiom val2loc_inj : forall v1 v2 l,
  val2loc v1 = Some l ->  val2loc v2 = Some l -> v1=v2.
Axiom loc_eq_dec : forall l1 l2 : loc, Decidable.decidable (l1=l2).
Axiom nil_dec : forall v, Decidable.decidable (v=nil_val).

Definition var : Type := Ident.t.
Parameter env : Type.
Parameter env_get : env -> var -> val.
Parameter env_set : var -> val -> env -> env.
Axiom gss_env : forall (x : var) (v : val) (s : env),
  v<>empty_val -> env_get (env_set x v s) x = v.
Axiom gso_env : forall (x y : var) (v : val) (s : env),
  x<>y -> env_get (env_set x v s) y = env_get s y.

Axiom env_reset : forall s x, env_set x (env_get s x) s = s.
Axiom env_reset2 : forall s x z, env_set x (env_get s x) (env_set x z s) = s.

Parameter heap : Type.
Declare Instance Join_heap: Join heap.
Declare Instance Perm_heap: Perm_alg heap.
Declare Instance Sep_heap: Sep_alg heap.
Declare Instance Canc_heap: Canc_alg heap.
Parameter rawnext: forall (x: loc) (y : val) (s : heap), Prop.
Parameter emp_at : forall (l: loc) (h: heap), Prop.
Axiom heap_gempty : forall h l, identity h -> emp_at l h.
Definition nil_or_loc (v: val) := v=nil_val \/ exists l, val2loc v = Some l.
Axiom mk_heap_rawnext : forall h x0 x y, val2loc (x0) = Some x ->
  nil_or_loc y -> exists h', rawnext x y h' /\ comparable h h'.
Axiom rawnext_out : forall {x x0 x' y h},
  rawnext x y h -> val2loc x0 = Some x' -> x'<>x -> emp_at x' h.

Definition rawnext' x y h := exists h0, join_sub h0 h /\ rawnext x y h0.

Axiom rawnext_at1 : forall {x y h1 h2 h},
  rawnext' x y h1 -> join h1 h2 h -> emp_at x h2 /\ rawnext' x y h.

Axiom rawnext_at2 : forall {x y h1 h2 h},
  join h1 h2 h -> rawnext' x y h -> emp_at x h2 -> rawnext' x y h1.

Axiom  rawnext_not_emp : forall {x y h}, rawnext' x y h -> ~emp_at x h.

Axiom emp_at_join: forall {h1 h2 h},
  join h1 h2 h -> forall l, (emp_at l h1 /\ emp_at l h2) <-> emp_at l h.

Axiom rawnext_unique : forall x z z' s s' t t' r,
  rawnext x z s -> rawnext x z' s' -> join s t r -> join s' t' r ->
  z' = z /\ s'=s.

Axiom vars_defined_locs : forall z (e : env),
  exists v, env_get e z = v /\ nil_or_loc v.

End VERISTAR_LOGIC.
