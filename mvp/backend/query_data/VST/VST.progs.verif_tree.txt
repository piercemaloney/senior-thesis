Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VST.progs.tree.
(* VST.progs.tree:
From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats AST Ctypes Cop Clight Clightdefs.
Local Open Scope Z_scope.

Module Info.
  Definition version := "3.3"%string.
  Definition build_number := ""%string.
  Definition build_tag := ""%string.
  Definition arch := "x86"%string.
  Definition model := "32sse2"%string.
  Definition abi := "standard"%string.
  Definition bitsize := 32.
  Definition big_endian := false.
  Definition source_file := "progs/tree.c"%string.
  Definition normalized := true.
End Info.

Definition _BinaryTree : ident := 9%positive.
Definition _XList : ident := 1%positive.
Definition _Xfoo : ident := 71%positive.
Definition _Xnode : ident := 4%positive.
Definition _Xnode_add : ident := 67%positive.
Definition _YList : ident := 7%positive.
Definition _YList_add : ident := 68%positive.
Definition _YTree_add : ident := 70%positive.
Definition _Ynode : ident := 8%positive.
Definition _Ynode_add : ident := 69%positive.
Definition ___builtin_ais_annot : ident := 13%positive.
Definition ___builtin_annot : ident := 20%positive.
Definition ___builtin_annot_intval : ident := 21%positive.
Definition ___builtin_bswap : ident := 14%positive.
Definition ___builtin_bswap16 : ident := 16%positive.
Definition ___builtin_bswap32 : ident := 15%positive.
Definition ___builtin_bswap64 : ident := 46%positive.
Definition ___builtin_clz : ident := 47%positive.
Definition ___builtin_clzl : ident := 48%positive.
Definition ___builtin_clzll : ident := 49%positive.
Definition ___builtin_ctz : ident := 50%positive.
Definition ___builtin_ctzl : ident := 51%positive.
Definition ___builtin_ctzll : ident := 52%positive.
Definition ___builtin_debug : ident := 64%positive.
Definition ___builtin_fabs : ident := 17%positive.
Definition ___builtin_fmadd : ident := 55%positive.
Definition ___builtin_fmax : ident := 53%positive.
Definition ___builtin_fmin : ident := 54%positive.
Definition ___builtin_fmsub : ident := 56%positive.
Definition ___builtin_fnmadd : ident := 57%positive.
Definition ___builtin_fnmsub : ident := 58%positive.
Definition ___builtin_fsqrt : ident := 18%positive.
Definition ___builtin_membar : ident := 22%positive.
Definition ___builtin_memcpy_aligned : ident := 19%positive.
Definition ___builtin_nop : ident := 63%positive.
Definition ___builtin_read16_reversed : ident := 59%positive.
Definition ___builtin_read32_reversed : ident := 60%positive.
Definition ___builtin_va_arg : ident := 24%positive.
Definition ___builtin_va_copy : ident := 25%positive.
Definition ___builtin_va_end : ident := 26%positive.
Definition ___builtin_va_start : ident := 23%positive.
Definition ___builtin_write16_reversed : ident := 61%positive.
Definition ___builtin_write32_reversed : ident := 62%positive.
Definition ___compcert_i64_dtos : ident := 31%positive.
Definition ___compcert_i64_dtou : ident := 32%positive.
Definition ___compcert_i64_sar : ident := 43%positive.
Definition ___compcert_i64_sdiv : ident := 37%positive.
Definition ___compcert_i64_shl : ident := 41%positive.
Definition ___compcert_i64_shr : ident := 42%positive.
Definition ___compcert_i64_smod : ident := 39%positive.
Definition ___compcert_i64_smulh : ident := 44%positive.
Definition ___compcert_i64_stod : ident := 33%positive.
Definition ___compcert_i64_stof : ident := 35%positive.
Definition ___compcert_i64_udiv : ident := 38%positive.
Definition ___compcert_i64_umod : ident := 40%positive.
Definition ___compcert_i64_umulh : ident := 45%positive.
Definition ___compcert_i64_utod : ident := 34%positive.
Definition ___compcert_i64_utof : ident := 36%positive.
Definition ___compcert_va_composite : ident := 30%positive.
Definition ___compcert_va_float64 : ident := 29%positive.
Definition ___compcert_va_int32 : ident := 27%positive.
Definition ___compcert_va_int64 : ident := 28%positive.
Definition _left : ident := 11%positive.
Definition _list : ident := 2%positive.
Definition _main : ident := 72%positive.
Definition _next : ident := 6%positive.
Definition _node : ident := 5%positive.
Definition _p : ident := 65%positive.
Definition _q : ident := 66%positive.
Definition _right : ident := 12%positive.
Definition _tree : ident := 10%positive.
Definition _v : ident := 3%positive.
Definition _t'1 : ident := 73%positive.
Definition _t'2 : ident := 74%positive.
Definition _t'3 : ident := 75%positive.
Definition _t'4 : ident := 76%positive.

Definition f_Xnode_add := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _Xnode noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_q, (tptr (Tstruct _XList noattr))) :: (_t'2, tuint) ::
               (_t'1, (tptr (Tstruct _Xnode noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _Xnode noattr)))
                 (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
    (Sreturn None)
    Sskip)
  (Ssequence
    (Ssequence
      (Sset _t'2
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
            (Tstruct _Xnode noattr)) _v tuint))
      (Sassign
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
            (Tstruct _Xnode noattr)) _v tuint)
        (Ebinop Oadd (Etempvar _t'2 tuint) (Econst_int (Int.repr 1) tint)
          tuint)))
    (Ssequence
      (Sset _q
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
            (Tstruct _Xnode noattr)) _list (tptr (Tstruct _XList noattr))))
      (Sloop
        (Ssequence
          (Sifthenelse (Ebinop One
                         (Etempvar _q (tptr (Tstruct _XList noattr)))
                         (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))
                         tint)
            Sskip
            Sbreak)
          (Ssequence
            (Sset _t'1
              (Efield
                (Ederef (Etempvar _q (tptr (Tstruct _XList noattr)))
                  (Tstruct _XList noattr)) _node
                (tptr (Tstruct _Xnode noattr))))
            (Scall None
              (Evar _Xnode_add (Tfunction
                                 (Tcons (tptr (Tstruct _Xnode noattr)) Tnil)
                                 tvoid cc_default))
              ((Etempvar _t'1 (tptr (Tstruct _Xnode noattr))) :: nil))))
        (Sset _q
          (Efield
            (Ederef (Etempvar _q (tptr (Tstruct _XList noattr)))
              (Tstruct _XList noattr)) _next (tptr (Tstruct _XList noattr))))))))
|}.

Definition f_Ynode_add := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _Ynode noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_t'2, tuint) :: (_t'1, (tptr (Tstruct _YList noattr))) ::
               nil);
  fn_body :=
(Ssequence
  (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _Ynode noattr)))
                 (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
    (Sreturn None)
    Sskip)
  (Ssequence
    (Ssequence
      (Sset _t'2
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Ynode noattr)))
            (Tstruct _Ynode noattr)) _v tuint))
      (Sassign
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Ynode noattr)))
            (Tstruct _Ynode noattr)) _v tuint)
        (Ebinop Oadd (Etempvar _t'2 tuint) (Econst_int (Int.repr 1) tint)
          tuint)))
    (Ssequence
      (Sset _t'1
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Ynode noattr)))
            (Tstruct _Ynode noattr)) _list (tptr (Tstruct _YList noattr))))
      (Scall None
        (Evar _YList_add (Tfunction
                           (Tcons (tptr (Tstruct _YList noattr)) Tnil) tvoid
                           cc_default))
        ((Etempvar _t'1 (tptr (Tstruct _YList noattr))) :: nil)))))
|}.

Definition f_YList_add := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _YList noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_t'2, (tptr (Tstruct _BinaryTree noattr))) ::
               (_t'1, (tptr (Tstruct _YList noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _YList noattr)))
                 (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
    (Sreturn None)
    Sskip)
  (Ssequence
    (Ssequence
      (Sset _t'2
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _YList noattr)))
            (Tstruct _YList noattr)) _tree
          (tptr (Tstruct _BinaryTree noattr))))
      (Scall None
        (Evar _YTree_add (Tfunction
                           (Tcons (tptr (Tstruct _BinaryTree noattr)) Tnil)
                           tvoid cc_default))
        ((Etempvar _t'2 (tptr (Tstruct _BinaryTree noattr))) :: nil)))
    (Ssequence
      (Sset _t'1
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _YList noattr)))
            (Tstruct _YList noattr)) _next (tptr (Tstruct _YList noattr))))
      (Scall None
        (Evar _YList_add (Tfunction
                           (Tcons (tptr (Tstruct _YList noattr)) Tnil) tvoid
                           cc_default))
        ((Etempvar _t'1 (tptr (Tstruct _YList noattr))) :: nil)))))
|}.

Definition f_YTree_add := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _BinaryTree noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_t'3, (tptr (Tstruct _Ynode noattr))) ::
               (_t'2, (tptr (Tstruct _BinaryTree noattr))) ::
               (_t'1, (tptr (Tstruct _BinaryTree noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _BinaryTree noattr)))
                 (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
    (Sreturn None)
    Sskip)
  (Ssequence
    (Ssequence
      (Sset _t'3
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _BinaryTree noattr)))
            (Tstruct _BinaryTree noattr)) _node
          (tptr (Tstruct _Ynode noattr))))
      (Scall None
        (Evar _Ynode_add (Tfunction
                           (Tcons (tptr (Tstruct _Ynode noattr)) Tnil) tvoid
                           cc_default))
        ((Etempvar _t'3 (tptr (Tstruct _Ynode noattr))) :: nil)))
    (Ssequence
      (Ssequence
        (Sset _t'2
          (Efield
            (Ederef (Etempvar _p (tptr (Tstruct _BinaryTree noattr)))
              (Tstruct _BinaryTree noattr)) _left
            (tptr (Tstruct _BinaryTree noattr))))
        (Scall None
          (Evar _YTree_add (Tfunction
                             (Tcons (tptr (Tstruct _BinaryTree noattr)) Tnil)
                             tvoid cc_default))
          ((Etempvar _t'2 (tptr (Tstruct _BinaryTree noattr))) :: nil)))
      (Ssequence
        (Sset _t'1
          (Efield
            (Ederef (Etempvar _p (tptr (Tstruct _BinaryTree noattr)))
              (Tstruct _BinaryTree noattr)) _right
            (tptr (Tstruct _BinaryTree noattr))))
        (Scall None
          (Evar _YTree_add (Tfunction
                             (Tcons (tptr (Tstruct _BinaryTree noattr)) Tnil)
                             tvoid cc_default))
          ((Etempvar _t'1 (tptr (Tstruct _BinaryTree noattr))) :: nil))))))
|}.

Definition f_Xfoo := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _Xnode noattr))) :: nil);
  fn_vars := ((_q, (Tstruct _Xnode noattr)) :: nil);
  fn_temps := ((_t'4, (tptr (Tstruct _XList noattr))) :: (_t'3, tuint) ::
               (_t'2, (tptr (Tstruct _XList noattr))) :: (_t'1, tuint) ::
               nil);
  fn_body :=
(Ssequence
  (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _Xnode noattr)))
                 (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
    (Sreturn None)
    Sskip)
  (Ssequence
    (Ssequence
      (Sset _t'4
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
            (Tstruct _Xnode noattr)) _list (tptr (Tstruct _XList noattr))))
      (Sassign
        (Efield (Evar _q (Tstruct _Xnode noattr)) _list
          (tptr (Tstruct _XList noattr)))
        (Etempvar _t'4 (tptr (Tstruct _XList noattr)))))
    (Ssequence
      (Ssequence
        (Sset _t'3
          (Efield
            (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
              (Tstruct _Xnode noattr)) _v tuint))
        (Sassign (Efield (Evar _q (Tstruct _Xnode noattr)) _v tuint)
          (Etempvar _t'3 tuint)))
      (Ssequence
        (Scall None
          (Evar _Xnode_add (Tfunction
                             (Tcons (tptr (Tstruct _Xnode noattr)) Tnil)
                             tvoid cc_default))
          ((Eaddrof (Evar _q (Tstruct _Xnode noattr))
             (tptr (Tstruct _Xnode noattr))) :: nil))
        (Ssequence
          (Ssequence
            (Sset _t'2
              (Efield (Evar _q (Tstruct _Xnode noattr)) _list
                (tptr (Tstruct _XList noattr))))
            (Sassign
              (Efield
                (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
                  (Tstruct _Xnode noattr)) _list
                (tptr (Tstruct _XList noattr)))
              (Etempvar _t'2 (tptr (Tstruct _XList noattr)))))
          (Ssequence
            (Sset _t'1 (Efield (Evar _q (Tstruct _Xnode noattr)) _v tuint))
            (Sassign
              (Efield
                (Ederef (Etempvar _p (tptr (Tstruct _Xnode noattr)))
                  (Tstruct _Xnode noattr)) _v tuint) (Etempvar _t'1 tuint))))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := nil;
  fn_body :=
(Sreturn (Some (Econst_int (Int.repr 0) tint)))
|}.

Definition composites : list composite_definition :=
(Composite _Xnode Struct
   ((_list, (tptr (Tstruct _XList noattr))) :: (_v, tuint) :: nil)
   noattr ::
 Composite _XList Struct
   ((_node, (tptr (Tstruct _Xnode noattr))) ::
    (_next, (tptr (Tstruct _XList noattr))) :: nil)
   noattr ::
 Composite _Ynode Struct
   ((_list, (tptr (Tstruct _YList noattr))) :: (_v, tuint) :: nil)
   noattr ::
 Composite _YList Struct
   ((_tree, (tptr (Tstruct _BinaryTree noattr))) ::
    (_next, (tptr (Tstruct _YList noattr))) :: nil)
   noattr ::
 Composite _BinaryTree Struct
   ((_node, (tptr (Tstruct _Ynode noattr))) ::
    (_left, (tptr (Tstruct _BinaryTree noattr))) ::
    (_right, (tptr (Tstruct _BinaryTree noattr))) :: nil)
   noattr :: nil).

Definition global_definitions : list (ident * globdef fundef type) :=
((___builtin_ais_annot,
   Gfun(External (EF_builtin "__builtin_ais_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___compcert_i64_dtos,
   Gfun(External (EF_runtime "__compcert_i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___compcert_i64_dtou,
   Gfun(External (EF_runtime "__compcert_i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___compcert_i64_stod,
   Gfun(External (EF_runtime "__compcert_i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___compcert_i64_utod,
   Gfun(External (EF_runtime "__compcert_i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___compcert_i64_stof,
   Gfun(External (EF_runtime "__compcert_i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___compcert_i64_utof,
   Gfun(External (EF_runtime "__compcert_i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___compcert_i64_sdiv,
   Gfun(External (EF_runtime "__compcert_i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_udiv,
   Gfun(External (EF_runtime "__compcert_i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_smod,
   Gfun(External (EF_runtime "__compcert_i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umod,
   Gfun(External (EF_runtime "__compcert_i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_shl,
   Gfun(External (EF_runtime "__compcert_i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_shr,
   Gfun(External (EF_runtime "__compcert_i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___compcert_i64_sar,
   Gfun(External (EF_runtime "__compcert_i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_smulh,
   Gfun(External (EF_runtime "__compcert_i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umulh,
   Gfun(External (EF_runtime "__compcert_i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_Xnode_add, Gfun(Internal f_Xnode_add)) ::
 (_Ynode_add, Gfun(Internal f_Ynode_add)) ::
 (_YList_add, Gfun(Internal f_YList_add)) ::
 (_YTree_add, Gfun(Internal f_YTree_add)) ::
 (_Xfoo, Gfun(Internal f_Xfoo)) :: (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _Xfoo :: _YTree_add :: _YList_add :: _Ynode_add :: _Xnode_add ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap64 :: ___compcert_i64_umulh :: ___compcert_i64_smulh ::
 ___compcert_i64_sar :: ___compcert_i64_shr :: ___compcert_i64_shl ::
 ___compcert_i64_umod :: ___compcert_i64_smod :: ___compcert_i64_udiv ::
 ___compcert_i64_sdiv :: ___compcert_i64_utof :: ___compcert_i64_stof ::
 ___compcert_i64_utod :: ___compcert_i64_stod :: ___compcert_i64_dtou ::
 ___compcert_i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fsqrt ::
 ___builtin_fabs :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___builtin_ais_annot :: nil).

Definition prog : Clight.program := 
  mkprogram composites global_definitions public_idents _main Logic.I. *)

Require Import VST.msl.iter_sepcon.
(* VST.msl.iter_sepcon:
Require Import VST.msl.base.
Require Import VST.msl.Extensionality.
Require Import VST.msl.simple_CCC.
Require Import VST.msl.seplog.
Require Import VST.msl.log_normalize.
Require Import Coq.Lists.List.
Require Import Coq.Sorting.Permutation.
Require Export Coq.Classes.Morphisms.

Lemma In_Permutation_cons: forall {A : Type} (l : list A) (x : A),
  In x l ->
  exists l', Permutation l (x :: l').

Lemma incl_Permutation {A: Type}: forall (l1 l2: list A), NoDup l2 -> incl l2 l1 -> exists l', Permutation l1 (l2 ++ l').

Local Open Scope logic.

Set Implicit Arguments.

Definition sepcon_unique1 {X A} `{SepLog A} (P: X -> A): Prop :=
  forall x, P x * P x |-- FF.

Definition sepcon_unique2 {X Y A} `{SepLog A} (P: X -> Y -> A): Prop :=
  forall x y1 y2, P x y1 * P x y2 |-- FF.

Section IterSepCon.

  Context {A : Type}.
  Context {B : Type}.
  Context {ND : NatDed A}.
  Context {SL : SepLog A}.
  Context {ClS: ClassicalSep A}.
  Context {CoSL: CorableSepLog A}.

Section SingleSepPred.

  Context (p : B -> A).

Fixpoint iter_sepcon (l : list B) : A :=
  match l with
    | nil => emp
    | x :: xl => p x * iter_sepcon xl
  end.

Lemma iter_sepcon_app:
  forall (l1 l2 : list B), iter_sepcon (l1 ++ l2) = iter_sepcon l1 * iter_sepcon l2.

Lemma iter_sepcon_app_comm: forall (l1 l2 : list B), iter_sepcon (l1 ++ l2) = iter_sepcon (l2 ++ l1).

Lemma iter_sepcon_permutation: forall  (l1 l2 : list B), Permutation l1 l2 -> iter_sepcon l1 = iter_sepcon l2.

Lemma iter_sepcon_in_true: forall (l : list B) x, In x l -> iter_sepcon l |-- p x * TT.

Lemma iter_sepcon_incl_true: forall (l s: list B),
    NoDup s -> incl s l -> iter_sepcon l |-- iter_sepcon s * TT.

Lemma iter_sepcon_unique_nodup: forall (l : list B), sepcon_unique1 p -> iter_sepcon l |-- !!(NoDup l).

Lemma iter_sepcon_emp': forall (l : list B), (forall x, In x l -> p x = emp) -> iter_sepcon l = emp.

Lemma iter_sepcon_emp: forall (l l' : list B), (forall x, p x |-- emp) -> NoDup l' -> incl l' l -> iter_sepcon l |-- iter_sepcon l'.

Lemma iter_sepcon_nil: iter_sepcon nil = emp.

End SingleSepPred.

Lemma iter_sepcon_func: forall l P Q, (forall x, P x = Q x) -> iter_sepcon P l = iter_sepcon Q l.

Lemma iter_sepcon_func_strong: forall l P Q, (forall x, In x l -> P x = Q x) -> iter_sepcon P l = iter_sepcon Q l.

End IterSepCon.

Lemma iter_sepcon_map: forall {A B C: Type} {ND : NatDed A} {SL : SepLog A} (l : list C) (f : B -> A) (g: C -> B),
                         iter_sepcon (fun x : C => f (g x)) l = iter_sepcon f (map g l).

Global Existing Instance iter_sepcon_permutation_proper.

Definition uncurry {A B C} (f: A -> B -> C) (xy: A*B) : C :=
  f (fst xy) (snd xy).

Section IterSepCon2.

  Context {A : Type}.
  Context {B1 B2 : Type}.
  Context {ND : NatDed A}.
  Context {SL : SepLog A}.
  Context {ClS: ClassicalSep A}.
  Context {CoSL: CorableSepLog A}.
  Context (p : B1 -> B2 -> A).

Fixpoint iter_sepcon2 (l : list B1) : list B2 -> A :=
    match l with
    | nil => fun l2 =>
       match l2 with
       | nil => emp
       | _ => FF
       end
    | x :: xl => fun l' =>
       match l' with
       | nil => FF
       | y :: yl => p x y * iter_sepcon2 xl yl
       end
  end.

Lemma iter_sepcon2_spec: forall l1 l2,
  iter_sepcon2 l1 l2 = EX l: list (B1 * B2), !! (l1 = map fst l /\ l2 = map snd l) && iter_sepcon (uncurry p) l.

End IterSepCon2.

Section IterPredSepCon.

  Context {A : Type}.
  Context {B : Type}.
  Context {ND : NatDed A}.
  Context {SL : SepLog A}.
  Context {ClS: ClassicalSep A}.

Definition pred_sepcon (p: B -> A) (P: B -> Prop): A :=
  EX l: list B, !! (forall x, In x l <-> P x) && !! NoDup l && iter_sepcon p l.

Lemma pred_sepcon_eq: forall (P: B -> Prop) (p: B -> A),
    pred_sepcon p P = 
    (EX l: list B, !! ((forall x, In x l <-> P x) /\ NoDup l) && iter_sepcon p l).

Lemma pred_sepcon_strong_proper: forall P1 P2 p1 p2,
  (forall x, P1 x <-> P2 x) ->
  (forall x, P1 x -> P2 x -> p1 x = p2 x) ->
  pred_sepcon p1 P1 = pred_sepcon p2 P2.

Global Existing Instance pred_sepcon_proper.

Lemma pred_sepcon1: forall p x0,
  pred_sepcon p (fun x => x = x0) = p x0.

Lemma pred_sepcon_unique_sepcon1: forall (P: B -> Prop) p x0,
  sepcon_unique1 p ->
  pred_sepcon p P * p x0 |-- !! (~ P x0).

Lemma prop_forall_allp: forall (P: B -> Prop),
  !! (forall x, P x) = ALL x: B, !! P x.

Lemma prop_impl_imp: forall (P Q: Prop),
  !! (P -> Q) = !! P --> !! Q.

Lemma pred_sepcon_prop_true: forall (P: B -> Prop) p x,
  P x ->
  pred_sepcon p P |-- p x * TT.

Lemma pred_sepcon_False: forall p,
  pred_sepcon p (fun _ => False) = emp.

End IterPredSepCon. *)

Require Import VST.msl.wand_frame.
(* VST.msl.wand_frame:
Require Import VST.msl.seplog.
Require Import VST.msl.log_normalize.
Local Open Scope logic.

Lemma wand_frame_intro {A} {ND: NatDed A} {SL: SepLog A}: forall (P Q: A),
  Q |-- P -* P * Q.

Lemma wand_frame_intro' {A} {ND: NatDed A} {SL: SepLog A}: forall (P Q R: A),
  P * Q |-- R ->
  Q |-- P -* R.

Lemma wand_frame_elim {A} {ND: NatDed A} {SL: SepLog A}: forall (P Q: A),
  P * (P -* Q) |-- Q.

Lemma wand_frame_elim' {A} {ND: NatDed A} {SL: SepLog A}: forall (P P' Q: A),
  P |-- P' -> P * (P' -* Q) |-- Q.

Lemma wand_frame_ver {A} {ND: NatDed A} {SL: SepLog A}: forall (P Q R: A),
  (P -* Q) * (Q -* R) |-- P -* R.

Lemma wand_frame_hor {A} {ND: NatDed A} {SL: SepLog A}: forall (P1 P2 Q1 Q2: A),
  (P1 -* Q1) * (P2 -* Q2) |-- P1 * P2 -* Q1 * Q2.

Lemma wand_frame_frame {A} {ND: NatDed A} {SL: SepLog A}: forall (P Q F: A),
  P -* Q |-- P * F -* Q * F. *)

Require Import VST.msl.wandQ_frame.
(* VST.msl.wandQ_frame:
Require Import VST.msl.seplog.
Require Import VST.msl.alg_seplog.
Require Import VST.msl.log_normalize.
Require Import VST.msl.wand_frame.
Local Open Scope logic.

Lemma wandQ_frame_refine {A} {ND: NatDed A} {SL: SepLog A}: forall B C (P: B -> A) (f: C -> B),
  allp P |-- allp (fun c => P (f c)).

Lemma wandQ_frame_intro {A} {ND: NatDed A} {SL: SepLog A}: forall B (P: B -> A) (Q: A),
  Q |-- allp (P -* P * (fun _ => Q)).

Lemma wandQ_frame_intro' {A} {ND: NatDed A} {SL: SepLog A}: forall B (P: B -> A) (Q: A) (R: B -> A),
  (forall x: B, P x * Q |-- R x) ->
  Q |-- allp (P -* R).

Lemma wandQ_frame_elim {A} {ND: NatDed A} {SL: SepLog A}: forall B (P Q: B -> A) (a: B),
  P a * allp (P -* Q) |-- Q a.

Lemma wandQ_frame_ver {A} {ND: NatDed A} {SL: SepLog A}: forall B (P Q R: B -> A),
  allp (P -* Q) * allp (Q -* R) |-- allp (P -* R).

Lemma wandQ_frame_hor {A} {ND: NatDed A} {SL: SepLog A}: forall B (P1 P2 Q1 Q2: B -> A),
  allp (P1 -* Q1) * allp (P2 -* Q2) |-- allp (P1 * P2 -* Q1 * Q2).

Lemma wandQ_frame_frame {A} {ND: NatDed A} {SL: SepLog A}: forall B (P Q F: B -> A),
  allp (P -* Q) |-- allp (P * F -* Q * F).

Lemma sepcon_wandQ_eq {A} {ND: NatDed A} {SL: SepLog A}: forall B (P: B -> A) (Q: A) (a: B),
  P a * (ALL b: B, P b -* P b * Q) = P a * Q. *)



Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.



Definition t_struct_Xnode := Tstruct _Xnode noattr.

Definition t_struct_Xlist := Tstruct _XList noattr.

Definition t_struct_Ynode := Tstruct _Ynode noattr.

Definition t_struct_Ylist := Tstruct _YList noattr.

Definition t_struct_Ytree := Tstruct _BinaryTree noattr.



Section LISTS.

Variable V: Type.



Variable list_cell: V -> val -> val -> mpred.



Fixpoint list_rep (l: list V) (x: val) : mpred :=

 match l with

 | h::hs => 

    EX y:val, list_cell h y x * list_rep hs y

 | nil => 

    !! (x = nullval) && emp

 end.



Lemma list_rep_valid_pointer:

  (forall v q p, list_cell v q p |-- valid_pointer p) ->

  forall l p, list_rep l p |-- valid_pointer p.

Proof.

  intros.

  destruct l; simpl; normalize; auto with valid_pointer.

Qed.



Lemma list_rep_local_facts:

  (forall v q p, list_cell v q p |-- !! (isptr p)) ->

  forall l p, list_rep l p |-- !! (is_pointer_or_null p  /\ (p=nullval <-> l=nil)).

Proof.

  intros.

  destruct l; simpl; normalize; entailer!.

  + split; auto.

  + split; intros; try congruence.

    subst; inv Pp.

Qed.



End LISTS.

Arguments list_rep {V} _ _ _.

Arguments list_rep_valid_pointer {V} _ _ _ _ _ _.

Arguments list_rep_local_facts {V} _ _ _ _ _ _.



Section TREES.

Variable V : Type.



Inductive tree : Type :=

 | E : tree

 | T: tree -> V -> tree -> tree.



Variable tree_cell: V -> val -> val -> val -> mpred.



Fixpoint tree_rep (t: tree) (p: val) : mpred :=

 match t with

 | E => !!(p=nullval) && emp

 | T a v b =>

    EX pa:val, EX pb:val,

    tree_cell v pa pb p *

    tree_rep a pa * tree_rep b pb

 end.



Lemma tree_rep_valid_pointer:

  (forall v L R p, tree_cell v L R p |-- valid_pointer p) ->

  forall t p, tree_rep t p |-- valid_pointer p.

Proof.

  intros.

  destruct t; simpl; normalize; auto with valid_pointer.

Qed.



Lemma tree_rep_local_facts:

  (forall v L R p, tree_cell v L R p |-- !! (isptr p)) ->

  forall t p, tree_rep t p |-- !! (is_pointer_or_null p  /\ (p=nullval <-> t=E)).

Proof.

  intros.

  destruct t; simpl; normalize; entailer!.

  + split; auto.

  + split; intros; try congruence.

    subst; inv Pp.

Qed.



End TREES.

Arguments E {V}.

Arguments T {V} _ _ _.

Arguments tree_rep {V} _ _ _.

Arguments tree_rep_valid_pointer {V} _ _ _ _ _ _.

Arguments tree_rep_local_facts {V} _ _ _ _ _ _.



Definition map_tree {V1 V2: Type} (f: V1 -> V2): tree V1 -> tree V2 :=

  fix map_tree (t: tree V1) :=

    match t with

    | E => E

    | T t1 x t2 => T (map_tree t1) (f x) (map_tree t2)

    end.



Section IterTreeSepCon.



  Context {A : Type}.

  Context {B : Type}.

  Context {ND : NatDed A}.

  Context {SL : SepLog A}.

  Context {ClS: ClassicalSep A}.

  Context {CoSL: CorableSepLog A}.

  Context (p : B -> A).



Fixpoint iter_tree_sepcon (t1 : tree B) : A :=

    match t1 with

    | E => emp

    | T a x b => p x * iter_tree_sepcon a * iter_tree_sepcon b

    end.



End IterTreeSepCon.



Section IterTreeSepCon2.



  Context {A : Type}.

  Context {B1 B2 : Type}.

  Context {ND : NatDed A}.

  Context {SL : SepLog A}.

  Context {ClS: ClassicalSep A}.

  Context {CoSL: CorableSepLog A}.

  Context (p : B1 -> B2 -> A).



Fixpoint iter_tree_sepcon2 (t1 : tree B1) : tree B2 -> A :=

    match t1 with

    | E => fun t2 =>

       match t2 with

       | E => emp

       | _ => FF

       end

    | T xa x xb => fun t2 =>

       match t2 with

       | E => FF

       | T ya y yb => p x y * iter_tree_sepcon2 xa ya * iter_tree_sepcon2 xb yb

       end

  end.



Lemma iter_tree_sepcon2_spec: forall tl1 tl2,

  iter_tree_sepcon2 tl1 tl2 =

  EX tl: tree (B1 * B2),

  !! (tl1 = map_tree fst tl /\ tl2 = map_tree snd tl) &&

  iter_tree_sepcon (uncurry p) tl.

Proof.

  intros.

  apply pred_ext.

  + revert tl2; induction tl1; intros; destruct tl2.

    - apply (exp_right E); simpl.

      apply andp_right; auto.

      apply prop_right; auto.

    - simpl.

      apply FF_left.

    - simpl.

      apply FF_left.

    - simpl.

      specialize (IHtl1_1 tl2_1).

      specialize (IHtl1_2 tl2_2).

      eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives |]; [apply derives_refl | apply IHtl1_1 | apply IHtl1_2] | clear IHtl1_1 IHtl1_2].

      Intros tl_2 tl_1; subst.

      Exists (T tl_1 (v, b) tl_2).

      simpl.

      apply andp_right; [apply prop_right; subst; auto |].

      apply derives_refl.

  + apply exp_left; intros tl.

    normalize.

    induction tl.

    - simpl. auto.

    - simpl.

      eapply derives_trans; [apply sepcon_derives; [apply sepcon_derives |]; [apply derives_refl | apply IHtl1 | apply IHtl2] | clear IHtl1 IHtl2].

      apply derives_refl.

Qed.



End IterTreeSepCon2.



Inductive XTree: Type :=

| XLeaf: XTree

| XNode: list XTree -> Z -> XTree.



Fixpoint xtree_rep (t: XTree) (p: val): mpred :=

  match t with

  | XLeaf =>

      !!(p = nullval) && emp

  | XNode tl v =>

      EX q: val,

        data_at Tsh t_struct_Xnode (q, Vint (Int.repr v)) p *

        EX r: list val,

          list_rep (fun (p: val) (n: val) (q: val) => data_at Tsh t_struct_Xlist (p, n) q) r q *

          iter_sepcon2 xtree_rep tl r

  end.



Lemma xtree_rep_valid_pointer:

  forall t p, xtree_rep t p |-- valid_pointer p.

Proof.

intros.

destruct t; simpl; normalize; auto with valid_pointer.

Qed.

Hint Resolve xtree_rep_valid_pointer: valid_pointer.



Lemma xtree_rep_local_facts:

  forall t p, xtree_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = XLeaf)).

Proof.

intros.

destruct t; simpl; normalize; entailer!.

+ split; auto.

+ split; intros; try congruence.

  subst; destruct H as [? _]; inv H.

Qed.

Hint Resolve xtree_rep_local_facts: saturate_local.



Lemma list_rep_Xlist_valid_pointer:

  forall (r: list val) (q: val),

    list_rep (fun (p: val) (n: val) (q: val) => data_at Tsh t_struct_Xlist (p, n) q) r q |-- valid_pointer q.

Proof.

  intros.

  apply list_rep_valid_pointer.

  intros.

  auto with valid_pointer.

Qed.

Hint Resolve list_rep_Xlist_valid_pointer: valid_pointer.



Lemma list_rep_Xlist_local_facts:

  forall (r: list val) (q: val),

    list_rep (fun (p: val) (n: val) (q: val) => data_at Tsh t_struct_Xlist (p, n) q) r q |-- !! (is_pointer_or_null q  /\ (q=nullval <-> r=nil)).

Proof.

  intros.

  apply list_rep_local_facts.

  intros.

  entailer!.

Qed.

Hint Resolve list_rep_Xlist_local_facts: saturate_local.



Lemma xtree_rep_nullval: forall t,

  xtree_rep t nullval |-- !! (t = XLeaf).

Proof.

  intros.

  destruct t; [entailer! |].

  simpl xtree_rep.

  Intros q r. entailer!.

Qed.

Hint Resolve xtree_rep_nullval: saturate_local.



Inductive YTree: Type :=

| YLeaf: YTree

| YNode: list (tree (unit * YTree) * unit) -> Z -> YTree.



Definition y_tree_rep (t: tree val) (p: val): mpred :=

  tree_rep (fun q L R p: val => data_at Tsh t_struct_Ytree (q, (L, R)) p) t p.



Definition y_list_rep (l: list val) (p: val): mpred :=

  list_rep (fun q n p: val => data_at Tsh t_struct_Ylist (q, n) p) l p.



Fixpoint ytree_rep (t: YTree) (p: val): mpred :=

  match t with

  | YLeaf =>

      !!(p = nullval) && emp

  | YNode ttl v =>

      let rep1 (t: unit * YTree) p := ytree_rep (snd t) p in

      let rep2 (t: tree (unit * YTree) * unit) p :=

            EX s: tree val, y_tree_rep s p * iter_tree_sepcon2 rep1 (fst t) s in

      let rep3 (t: list (tree (unit * YTree) * unit)) p :=

            EX r: list val, y_list_rep r p * iter_sepcon2 rep2 t r in

      EX q: val, 

        data_at Tsh t_struct_Ynode (q, Vint (Int.repr v)) p * rep3 ttl q

  end.



Definition t_ytree_rep (t: tree (unit * YTree)) (p: val): mpred :=

  EX s: tree val, y_tree_rep s p * iter_tree_sepcon2 (fun t p => ytree_rep (snd t) p) t s.



Definition lt_ytree_rep (t: list (tree (unit * YTree) * unit)) (p: val): mpred :=

  EX r: list val, y_list_rep r p * iter_sepcon2 (fun t p => t_ytree_rep (fst t) p) t r.



Theorem ytree_rep_spec: forall t p,

  ytree_rep t p =

  match t with

  | YLeaf =>

      !!(p = nullval) && emp

  | YNode ttl v =>

      EX q: val, 

        data_at Tsh t_struct_Ynode (q, Vint (Int.repr v)) p * lt_ytree_rep ttl q

  end.

Proof.

  intros.

  induction t; auto.

Qed.



Lemma y_list_rep_valid_pointer: forall t p, y_list_rep t p |-- valid_pointer p.

Proof.

  intros.

  apply list_rep_valid_pointer.

  intros; auto with valid_pointer.

Qed.

Hint Resolve y_list_rep_valid_pointer: valid_pointer.



Lemma y_list_rep_local_facts: forall t p, y_list_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = nil)).

Proof.

  apply list_rep_local_facts.

  intros; entailer!.

Qed.

Hint Resolve y_list_rep_local_facts: saturate_local.



Lemma y_tree_rep_valid_pointer: forall t p, y_tree_rep t p |-- valid_pointer p.

Proof.

  intros.

  apply tree_rep_valid_pointer.

  intros; auto with valid_pointer.

Qed.

Hint Resolve y_tree_rep_valid_pointer: valid_pointer.



Lemma y_tree_rep_local_facts: forall t p, y_tree_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = E)).

Proof.

  apply tree_rep_local_facts.

  intros; entailer!.

Qed.

Hint Resolve y_tree_rep_local_facts: saturate_local.



Lemma ytree_rep_valid_pointer:

  forall t p, ytree_rep t p |-- valid_pointer p.

Proof.

intros.

destruct t; simpl; normalize; auto with valid_pointer.

Qed.

Hint Resolve ytree_rep_valid_pointer: valid_pointer.



Lemma ytree_rep_local_facts:

  forall t p, ytree_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = YLeaf)).

Proof.

intros.

destruct t; simpl; normalize; entailer!.

+ split; auto.

+ split; intros; try congruence.

  subst; destruct H as [? _]; inv H.

Qed.

Hint Resolve ytree_rep_local_facts: saturate_local.



Lemma lt_ytree_rep_valid_pointer: forall t p, lt_ytree_rep t p |-- valid_pointer p.

Proof.

  intros.

  unfold lt_ytree_rep.

  Intros r.

  auto with valid_pointer.

Qed.

Hint Resolve lt_ytree_rep_valid_pointer: valid_pointer.



Lemma lt_ytree_rep_local_facts: forall t p, lt_ytree_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = nil)).

Proof.

  intros.

  unfold lt_ytree_rep.

  Intros r.

  rewrite iter_sepcon2_spec.

  Intros l.

  subst.

  entailer!.

  rewrite H.

  destruct l; simpl; split; intros; congruence.

Qed.

Hint Resolve lt_ytree_rep_local_facts: saturate_local.



Lemma t_ytree_rep_valid_pointer: forall t p, t_ytree_rep t p |-- valid_pointer p.

Proof.

  intros.

  unfold t_ytree_rep.

  Intros s.

  auto with valid_pointer.

Qed.

Hint Resolve t_ytree_rep_valid_pointer: valid_pointer.



Lemma t_ytree_rep_local_facts: forall t p, t_ytree_rep t p |-- !! (is_pointer_or_null p /\ (p = nullval <-> t = E)).

Proof.

  intros.

  unfold t_ytree_rep.

  Intros s.

  rewrite iter_tree_sepcon2_spec.

  Intros tl.

  subst.

  entailer!.

  rewrite H.

  destruct tl; simpl; split; intros; congruence.

Qed.

Hint Resolve t_ytree_rep_local_facts: saturate_local.



Module Alternative.



Fixpoint ytree_rep (t: YTree) (p: val): mpred :=

  match t with

  | YLeaf =>

      !!(p = nullval) && emp

  | YNode ttl v =>

      EX q: val, EX r: list val,

        data_at Tsh t_struct_Ynode (q, Vint (Int.repr v)) p *

        list_rep (fun r n q => data_at Tsh t_struct_Ylist (r, n) q) r q *

        iter_sepcon2 (fun tt_u_pair r =>

          EX s: tree val,

          tree_rep (fun p L R r => data_at Tsh t_struct_Ytree (p, (L, R)) r) s r *

          iter_tree_sepcon2 (fun u_t_pair s => ytree_rep (snd u_t_pair) s) (fst tt_u_pair) s) ttl r

  end.



End Alternative.



Fixpoint x_add1 (t: XTree): XTree :=

  match t with

  | XLeaf =>

      XLeaf

  | XNode tl v =>

      XNode (map x_add1 tl) (v + 1)

  end.



Section Forall_XTree.



Variable (P: Z -> Prop).



Fixpoint Forall_XTree (t: XTree): Prop :=

  match t with

  | XLeaf =>

      True

  | XNode tl v =>

      fold_right and (P v) (map Forall_XTree tl)

  end.



End Forall_XTree.



Lemma add1_pos: forall t, Forall_XTree (fun x => x >= 0) t -> Forall_XTree (fun x => x > 0) (x_add1 t).

Proof.

  refine (fix H t :=

            match t as t_pat

              return Forall_XTree (fun x : Z => x >= 0) t_pat ->

                     Forall_XTree (fun x : Z => x > 0) (x_add1 t_pat)

            with

            | XLeaf => fun _ => I

            | XNode tl v => _

            end).

  simpl.

  induction tl.

  + simpl.

    intros; clear H; omega.

  + simpl.

    exact (fun HH => conj (H _ (proj1 HH)) (IHtl (proj2 HH))).

Qed.



Definition Xnode_add_spec :=

 DECLARE _Xnode_add

  WITH p: val, t: XTree

  PRE  [ _p OF (tptr t_struct_Xnode) ]

    PROP  ()

    LOCAL (temp _p p)

    SEP (xtree_rep t p)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (xtree_rep (x_add1 t) p).



Definition Xfoo_spec :=

 DECLARE _Xfoo

  WITH p: val, t: XTree

  PRE  [ _p OF (tptr t_struct_Xnode) ]

    PROP  (Forall_XTree (fun x => x >= 0) t)

    LOCAL (temp _p p)

    SEP (xtree_rep t p)

  POST [ Tvoid ]

    EX t': XTree,

      PROP(Forall_XTree (fun x => x > 0) t')

      LOCAL()

      SEP (xtree_rep t' p).



Fixpoint y_add1 (t: YTree): YTree :=

  match t with

  | YLeaf =>

      YLeaf

  | YNode tl v =>

      let map1 := fun u_t_pair => (tt, y_add1 (snd u_t_pair)) in

      let map2 := fun tt_u_pair => (map_tree map1 (fst tt_u_pair), tt) in

      let map3 := fun tl => map map2 tl in

      YNode (map3 tl) (v + 1)

  end.



Definition ty_add1 (t: tree (unit * YTree)) :=

  map_tree (fun t => (tt, y_add1 (snd t))) t.



Definition lty_add1 (t: list (tree (unit * YTree) * unit)) :=

  map (fun t => (ty_add1 (fst t), tt)) t.



Theorem y_add1_spec: forall t,

  y_add1 t = 

  match t with

  | YLeaf =>

      YLeaf

  | YNode tl v =>

      YNode (lty_add1 tl) (v + 1)

  end.

Proof.

  intros.

  induction t; auto.

Qed.



Definition Ynode_add_spec :=

 DECLARE _Ynode_add

  WITH p: val, t: YTree

  PRE  [ _p OF (tptr t_struct_Ynode) ]

    PROP  ()

    LOCAL (temp _p p)

    SEP (ytree_rep t p)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (ytree_rep (y_add1 t) p).



Definition YTree_add_spec :=

 DECLARE _YTree_add

  WITH p: val, t: tree (unit * YTree)

  PRE  [ _p OF (tptr t_struct_Ytree) ]

    PROP  ()

    LOCAL (temp _p p)

    SEP (t_ytree_rep t p)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (t_ytree_rep (ty_add1 t) p).



Definition YList_add_spec :=

 DECLARE _YList_add

  WITH p: val, t: list (tree (unit * YTree) * unit)

  PRE  [ _p OF (tptr t_struct_Ylist) ]

    PROP  ()

    LOCAL (temp _p p)

    SEP (lt_ytree_rep t p)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (lt_ytree_rep (lty_add1 t) p).



Definition main_spec :=

 DECLARE _main

  WITH gv : globals

  PRE  [] main_pre prog nil gv

  POST [ tint ]

     PROP() LOCAL () SEP(TT).



Definition Gprog : funspecs :=

  ltac:(with_library prog

    [Xnode_add_spec; Xfoo_spec; Ynode_add_spec; YList_add_spec; YTree_add_spec; main_spec]).



Module GeneralLseg.



Section GeneralLseg.



Context {V: Type}.



Variable listrep: list V -> val -> mpred.



Definition lseg (contents: list V) (x z: val) : mpred :=

  ALL tcontents: list V, listrep tcontents z -* listrep (contents ++ tcontents) x.



Lemma emp_lseg_nil: forall (x: val),

  emp |-- lseg nil x x.

Proof.

  intros.

  apply allp_right; intros.

  apply wand_sepcon_adjoint.

  simpl.

  entailer!.

Qed.



Lemma lseg_lseg: forall (s1 s2: list V) (x y z: val),

  lseg s2 y z * lseg s1 x y |-- lseg (s1 ++ s2) x z.

Proof.

  intros.

  unfold lseg.

  eapply derives_trans; [apply sepcon_derives; [apply derives_refl |] | apply wandQ_frame_ver].

  eapply derives_trans; [apply (wandQ_frame_refine _ _ _ (app s2)) |].

  apply derives_refl'.

  f_equal; extensionality tcontents; simpl.

  rewrite app_assoc.

  auto.

Qed.



Lemma list_lseg: forall (s1 s2: list V) (x y: val),

  listrep s2 y * lseg s1 x y |-- listrep (s1 ++ s2) x.

Proof.

  intros.

  unfold lseg.

  change (listrep s2 y) with ((fun s2 => listrep s2 y) s2).

   change

     (ALL tcontents : list V, listrep tcontents y -* listrep (s1 ++ tcontents) x)

   with

     (allp ((fun tcontents => listrep tcontents y) -* (fun tcontents => listrep (s1 ++ tcontents) x))).

   change (listrep (s1 ++ s2) x) with ((fun s2 => listrep (s1 ++ s2) x) s2).

   apply wandQ_frame_elim.

Qed.



End GeneralLseg.

End GeneralLseg.



Lemma body_Xnode_add: semax_body Vprog Gprog f_Xnode_add Xnode_add_spec.

Proof.

  start_function.

  forward_if.

  {

    forward.

    entailer!.

    simpl.

    auto.

  }

  unfold Sfor.

  destruct t as [| tl v].

  {

    simpl.

    Intros.

    contradiction.

  }

  simpl xtree_rep.

  Intros q r.

  rewrite iter_sepcon2_spec.

  Intros tl'.

  subst tl r; rename tl' into tl.

  forward.

  forward.

  rewrite add_repr.

  unfold Sfor.

  forward.

  rename q into q_root.

  forward_loop

    (EX tl1: list (XTree * val), EX tl2: list (XTree * val), EX q: val,

      PROP (map (fun tp => (x_add1 (fst tp), snd tp)) tl = tl1 ++ map (fun tp => (x_add1 (fst tp), snd tp)) tl2)

      LOCAL (temp _q q)

      SEP (data_at Tsh t_struct_Xnode (q_root, Vint (Int.repr (v + 1))) p;

           GeneralLseg.lseg (list_rep (fun p n q : val => data_at Tsh t_struct_Xlist (p, n) q)) (map snd tl1) q_root q;

           iter_sepcon (uncurry xtree_rep) tl1;

           list_rep (fun p n q : val => data_at Tsh t_struct_Xlist (p, n) q) (map snd tl2) q;

           iter_sepcon (uncurry xtree_rep) tl2))%assert

  break:

    ( PROP ()

      LOCAL ()

      SEP (data_at Tsh t_struct_Xnode (q_root, Vint (Int.repr (v + 1))) p;

           list_rep (fun p n q : val => data_at Tsh t_struct_Xlist (p, n) q) (map snd tl) q_root;

           iter_sepcon (uncurry xtree_rep) (map (fun tp => (x_add1 (fst tp), snd tp)) tl)))%assert.

  {

    Exists (@nil (XTree * val)) tl q_root.

    entailer!.

    apply GeneralLseg.emp_lseg_nil.

  }

  {

    Intros tl1 tl2 q.

    forward_if.

    2:{

      forward.

      entailer!.

      assert (tl2 = nil) by (pose proof proj1 H4 eq_refl as HH; destruct tl2; auto; inv HH).

      subst tl2; clear H4.

      simpl in H0; rewrite app_nil_r in H0.

      simpl map.

      sep_apply (GeneralLseg.list_lseg (list_rep (fun p0 n q : val => data_at Tsh t_struct_Xlist (p0, n) q)) (map snd tl1) nil q_root nullval).

      sep_apply (eq_sym (iter_sepcon_app (uncurry xtree_rep) tl1 [])).

      rewrite !app_nil_r.

      rewrite <- H0, map_map.

      simpl. change (fun x : XTree * val => snd x) with (@snd XTree val).

      cancel.

    }

    destruct tl2 as [| [t p'] tl2].

    {

      simpl.

      Intros.

      contradiction.

    }

    simpl list_rep; simpl iter_sepcon.

    Intros q'.

    change (uncurry xtree_rep (t, p')) with (xtree_rep t p').

    forward.

    forward_call (p', t).

    forward.

    Exists (tl1 ++ (x_add1 t, p') :: nil) tl2 q'.

    entailer!.

    + rewrite <- app_assoc; auto.

    + change (xtree_rep (x_add1 t) p') with (uncurry xtree_rep (x_add1 t, p')).

      rewrite iter_sepcon_app; simpl.

      cancel.

      eapply derives_trans; [| rewrite map_app; apply (GeneralLseg.lseg_lseg _ _ _ _ q)].

      cancel.

      clear.

      apply allp_right; intros.

      apply wand_sepcon_adjoint.

      simpl list_rep.

      Exists q'.

      cancel.

  }

  forward.

  simpl.

  Exists q_root; cancel.

  Exists (map snd tl).

  cancel.

  rewrite iter_sepcon2_spec.

  Exists (map (fun tp : XTree * val => (x_add1 (fst tp), snd tp)) tl); cancel.

  entailer!.

  rewrite !map_map.

  split; f_equal.

Qed.



Lemma body_Xfoo: semax_body Vprog Gprog f_Xfoo Xfoo_spec.

Proof.

  start_function.

  forward_if.

  {

    forward.

    Exists XLeaf.

    entailer!.

  }

  destruct t as [| tl v].

  {

    simpl.

    Intros.

    contradiction.

  }

  simpl xtree_rep.

  Intros q r.

  forward.

  forward.

  forward.

  forward.

  gather_SEP 0 2 3.

  replace_SEP 0 (xtree_rep (XNode tl v) v_q).

  {

    simpl xtree_rep.

    entailer!.

    Exists q r.

    entailer!.

  }

  deadvars!.

  forward_call (v_q, XNode tl v).

  simpl xtree_rep.

  Intros q' r'.

  forward.

  forward.

  forward.

  forward.

  gather_SEP 1 2 3.

  replace_SEP 0 (xtree_rep (XNode (map x_add1 tl) (v + 1)) p).

  {

    simpl xtree_rep.

    entailer!.

    Exists q' r'.

    entailer!.

  }

  change ((XNode (map x_add1 tl) (v + 1))) with (x_add1 (XNode tl v)).

  forget (XNode tl v) as t.

  forward.

  Exists (x_add1 t).

  entailer!.

  apply add1_pos; auto.

Qed.



Lemma body_Ynode_add: semax_body Vprog Gprog f_Ynode_add Ynode_add_spec.

Proof.

  start_function.

  forward_if.

  {

    forward.

    destruct H0 as [? _]; specialize (H eq_refl).

    subst; simpl; auto.

  }

  destruct t as [| tl v].

  {

    simpl.

    Intros.

    contradiction.

  }

  rewrite ytree_rep_spec.

  Intros q.

  forward.

  forward.

  rewrite add_repr.

  forward.

  forward_call (q, tl).

  forward.

  Exists q.

  cancel.

  apply derives_refl.

Qed.



Lemma body_YList_add: semax_body Vprog Gprog f_YList_add YList_add_spec.

Proof.

  start_function.

  forward_if.

  {

    forward.

    destruct H0 as [? _]; specialize (H eq_refl).

    subst; simpl; auto.

  }

  assert_PROP (t <> nil).

  {

    entailer!.

    destruct H0 as [_ ?]; specialize (H0 eq_refl).

    congruence.

  }

  destruct t as [| [? ?] t']; [congruence | clear H0].

  unfold lt_ytree_rep.

  Intros r.

  destruct r; [simpl; normalize |].

  simpl.

  Intros y.

  forward.

  forward_call (v, t).

  forward.

  gather_SEP 2 3.

  replace_SEP 0 (lt_ytree_rep t' y).

  {

    unfold lt_ytree_rep.

    entailer!.

    Exists r; cancel.

  }

  forward_call (y, t').

  forward.

  clear.

  unfold lt_ytree_rep.

  Intros r.

  Exists (v :: r).

  unfold y_list_rep; simpl.

  Exists y.

  cancel.

Qed.



Lemma body_YTree_add: semax_body Vprog Gprog f_YTree_add YTree_add_spec.

Proof.

  start_function.

  forward_if.

  {

    forward.

    destruct H0 as [? _]; specialize (H eq_refl).

    subst; simpl; auto.

  }

  assert_PROP (t <> E).

  {

    entailer!.

    destruct H0 as [_ ?]; specialize (H0 eq_refl).

    congruence.

  }

  destruct t as [| a [? ?] b]; [congruence |].

  unfold t_ytree_rep.

  Intros s.

  destruct s; [simpl; normalize |].

  simpl.

  Intros pa pb.

  forward.

  forward_call (v, y).

  forward.

  gather_SEP 2 4.

  replace_SEP 0 (t_ytree_rep a pa).

  {

    unfold t_ytree_rep.

    entailer!.

    Exists s1; cancel.

  }

  forward_call (pa, a).

  forward.

  gather_SEP 3 4.

  replace_SEP 0 (t_ytree_rep b pb).

  {

    unfold t_ytree_rep.

    entailer!.

    Exists s2; cancel.

  }

  forward_call (pb, b).

  forward.

  clear.

  unfold t_ytree_rep.

  Intros s2 s1.

  Exists (T s1 v s2).

  unfold y_tree_rep; simpl.

  Exists pa pb.

  cancel.

Qed.



Lemma body_main:  semax_body Vprog Gprog f_main main_spec.

Proof.

  start_function.

  forward.

Qed.



Existing Instance NullExtension.Espec.



Lemma prog_correct:

  semax_prog prog Vprog Gprog.

Proof.

prove_semax_prog.

semax_func_cons body_Xnode_add.

semax_func_cons body_Ynode_add.

semax_func_cons body_YList_add.

semax_func_cons body_YTree_add.

semax_func_cons body_Xfoo.

semax_func_cons body_main.

Qed.



