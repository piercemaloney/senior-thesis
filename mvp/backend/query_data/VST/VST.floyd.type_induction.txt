Require Import VST.floyd.base2.
(* VST.floyd.base2:
Require Export VST.floyd.base.
Require Export VST.floyd.typecheck_lemmas.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.seplog_tactics.
Require Export VST.floyd.const_only_eval.
Require Export VST.floyd.computable_functions.

Fixpoint delete_id {A: Type} i (al: list (ident*A)) : option (A * list (ident*A)) :=
 match al with
 | (j,x)::bl => if ident_eq i j then Some (x,bl)
                else match delete_id i bl with
                        | None => None
                        | Some (y,cl) => Some (y, (j,x)::cl)
                        end
  | nil => None
 end.

Inductive NOTE__Perhaps_you_need_to_Import_floyd_library___See_reference_manual_chapter___with_library : Type := .

Definition cc_of_fundef (fd: Clight.fundef) : calling_convention :=
 match fd with
 | Internal f => fn_callconv f
 | External _ _ _ c => c
 end.

Definition funsig_of_fundef (fd: Clight.fundef) : funsig :=
 match fd with
 | Internal {| fn_return := fn_return; fn_params := fn_params |} =>
    (fn_params, fn_return)
 | External _ t t0 _ => (arglist 1 t, t0)
 end.

Definition vacuous_funspec (fd: Clight.fundef): funspec :=
   mk_funspec (funsig_of_fundef fd) (cc_of_fundef fd) (rmaps.ConstType NOTE__Perhaps_you_need_to_Import_floyd_library___See_reference_manual_chapter___with_library) (fun _ _ => FF) (fun _ _ => FF) (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Fixpoint augment_funspecs' (fds: list (ident * Clight.fundef)) (G:funspecs) : option funspecs :=
 match fds with
 | (i,fd)::fds' => match delete_id i G with
                       | Some (f, G') =>
                              match augment_funspecs' fds' G' with
                               | Some G2 => Some ((i,f)::G2)
                               | None => None
                              end
                       | None =>
                              match augment_funspecs' fds' G with
                               | Some G2 => Some ((i, vacuous_funspec fd)::G2)
                               | None => None
                              end
                        end
 | nil => match G with nil => Some nil | _::_ => None end
 end.

Definition augment_funspecs prog G : funspecs :=
 match augment_funspecs' (prog_funct prog) G with
 | Some G' => G'
 | None => nil
 end. *)

Require Import VST.floyd.fieldlist.
(* VST.floyd.fieldlist:
Require Import VST.floyd.base2.
Require Import VST.floyd.client_lemmas.

Arguments align !n !amount / .
Arguments Z.max !n !m / .

Definition field_type i m :=
  match Ctypes.field_type i m with
  | Errors.OK t => t
  | _ => Tvoid
  end.

Definition field_offset env i m :=
  match Ctypes.field_offset env i m with
  | Errors.OK ofs => ofs
  | _ => 0
  end.

Fixpoint field_offset_next_rec env i m ofs sz :=
  match m with
  | nil => 0
  | (i0, t0) :: m0 =>
    match m0 with
    | nil => sz
    | (_, t1) :: _ =>
      if ident_eq i i0
      then align (ofs + @sizeof env t0) (@alignof env t1)
      else field_offset_next_rec env i m0 (align (ofs + @sizeof env t0) (@alignof env t1)) sz
    end
  end.

Definition field_offset_next env i m sz := field_offset_next_rec env i m 0 sz.

Lemma in_members_field_type: forall i m,
  in_members i m ->
  In (i, field_type i m) m.

Lemma field_offset_field_type_match: forall cenv i m,
  match Ctypes.field_offset cenv i m, Ctypes.field_type i m with

Lemma field_type_in_members: forall i m,
  match Ctypes.field_type i m with

Section COMPOSITE_ENV.
Context {cs: compspecs}.

Ltac solve_field_offset_type i m :=
  let H := fresh "H" in
  let Hty := fresh "H" in
  let Hofs := fresh "H" in
  let t := fresh "t" in
  let ofs := fresh "ofs" in
  pose proof field_offset_field_type_match cenv_cs i m;
  destruct (Ctypes.field_offset cenv_cs i m) as [ofs|?] eqn:Hofs, (Ctypes.field_type i m) as [t|?] eqn:Hty;
    [clear H | inversion H | inversion H | clear H].

Lemma complete_legal_cosu_member: forall (cenv : composite_env) (id : ident) (t : type) (m : list (ident * type)),
  In (id, t) m -> @composite_complete_legal_cosu_type cenv m = true -> @complete_legal_cosu_type cenv t = true.

Lemma complete_legal_cosu_type_field_type: forall id i,
  in_members i (co_members (get_co id)) ->
  complete_legal_cosu_type (field_type i (co_members (get_co id))) = true.

Lemma align_compatible_rec_Tstruct_inv': forall id a ofs,
  align_compatible_rec cenv_cs (Tstruct id a) ofs ->
  forall i,
  in_members i (co_members (get_co id)) ->
  align_compatible_rec cenv_cs (field_type i (co_members (get_co id)))
    (ofs + field_offset cenv_cs i (co_members (get_co id))).

Lemma align_compatible_rec_Tunion_inv': forall id a ofs,
  align_compatible_rec cenv_cs (Tunion id a) ofs ->
  forall i,
  in_members i (co_members (get_co id)) ->
  align_compatible_rec cenv_cs (field_type i (co_members (get_co id))) ofs.

Lemma field_offset_aligned: forall i m,
  (alignof (field_type i m) | field_offset cenv_cs i m).

Lemma alignof_composite_hd_divide: forall i t m, (alignof t | alignof_composite cenv_cs ((i, t) :: m)).

Lemma alignof_composite_tl_divide: forall i t m, (alignof_composite cenv_cs m | alignof_composite cenv_cs ((i, t) :: m)).

Lemma alignof_field_type_divide_alignof: forall i m,
  in_members i m ->
  (alignof (field_type i m) | alignof_composite cenv_cs m).

Lemma field_offset_in_range: forall i m,
  in_members i m ->
  0 <= field_offset cenv_cs i m /\ field_offset cenv_cs i m + sizeof (field_type i m) <= sizeof_struct cenv_cs 0 m.

Lemma sizeof_union_in_members: forall i m,
  in_members i m ->
  sizeof (field_type i m) <= sizeof_union cenv_cs m.

Lemma field_offset_no_overlap:
  forall i1 i2 m,
  i1 <> i2 ->
  in_members i1 m ->
  in_members i2 m ->
  field_offset cenv_cs i1 m + sizeof (field_type i1 m) <= field_offset cenv_cs i2 m \/
  field_offset cenv_cs i2 m + sizeof (field_type i2 m) <= field_offset cenv_cs i1 m.

Lemma not_in_members_field_type: forall i m,
  ~ in_members i m ->
  field_type i m = Tvoid.

Lemma not_in_members_field_offset: forall i m,
  ~ in_members i m ->
  field_offset cenv_cs i m = 0.

Lemma field_offset_next_in_range: forall i m sz,
  in_members i m ->
  sizeof_struct cenv_cs 0 m <= sz ->
  field_offset cenv_cs i m + sizeof (field_type i m) <=
  field_offset_next cenv_cs i m sz <= sz.

Lemma Pos_eqb_eq: forall p q: positive, iff (eq (Pos.eqb p q) true) (eq p q).

Lemma id_in_list_true: forall i ids, id_in_list i ids = true -> In i ids.

Lemma id_in_list_false: forall i ids, id_in_list i ids = false -> ~In i ids.

Lemma members_no_replicate_ind: forall m,
  (members_no_replicate m = true) <->
  match m with
  | nil => True
  | (i0, _) :: m0 => ~ in_members i0 m0 /\ members_no_replicate m0 = true
  end.

Lemma map_members_ext: forall A (f f':ident * type -> A) (m: members),
  members_no_replicate m = true ->
  (forall i, in_members i m -> f (i, field_type i m) = f' (i, field_type i m)) ->
  map f m = map f' m.

Lemma in_members_tail_no_replicate: forall i i0 t0 m,
  members_no_replicate ((i0, t0) :: m) = true ->
  in_members i m ->
  i <> i0.

Lemma neq_field_offset_rec_cons: forall env i i0 t0 m z,
  i <> i0 ->
  field_offset_rec env i ((i0, t0) :: m) z =
  field_offset_rec env i m (align z (alignof t0) + sizeof t0).

Lemma neq_field_offset_next_rec_cons: forall env i i0 t0 i1 t1 m z sz,
  i <> i0 ->
  field_offset_next_rec env i ((i0, t0) :: (i1, t1) :: m) z sz =
  field_offset_next_rec env i ((i1, t1) :: m) (align (z +  sizeof t0) (alignof t1)) sz.

Lemma sizeof_struct_0: forall env i m,
  sizeof_struct env 0 m = 0 ->
  in_members i m ->
  sizeof (field_type i m) = 0 /\
  field_offset_next env i m 0 - (field_offset env i m + sizeof (field_type i m)) = 0.

Lemma sizeof_union_0: forall env i m,
  sizeof_union env m = 0 ->
  in_members i m ->
  sizeof (field_type i m) = 0.

Definition in_map: forall {A B : Type} (f : A -> B) (l : list A) (x : A),
       In x l -> In (f x) (map f l) :=
fun (A B : Type) (f : A -> B) (l : list A) =>
list_ind (fun l0 : list A => forall x : A, In x l0 -> In (f x) (map f l0))
  (fun (x : A) (H : In x nil) => H)
  (fun (a : A) (l0 : list A)
     (IHl : forall x : A, In x l0 -> In (f x) (map f l0)) (x : A)
     (H : In x (a :: l0)) =>
   or_ind
     (fun H0 : a = x =>
      or_introl (eq_ind_r (fun a0 : A => f a0 = f x) eq_refl H0))
     (fun H0 : In x l0 =>
      or_intror
        ((fun H1 : In x l0 -> In (f x) (map f l0) =>
          (fun H2 : In (f x) (map f l0) => H2) (H1 H0)) (IHl x))) H) l.

Lemma In_field_type: forall it m,
  members_no_replicate m = true ->
  In it m ->
  field_type (fst it) m = snd it.

End COMPOSITE_ENV.

Lemma members_spec_change_composite' {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  Forall (fun it => cs_preserve_type cs_from cs_to (coeq _ _) (snd it) = true) (co_members (get_co id)).

Lemma members_spec_change_composite'' {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  forall i, cs_preserve_type cs_from cs_to (coeq _ _) (field_type i (co_members (get_co id))) = true.

Lemma members_spec_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  Forall (fun it => cs_preserve_type cs_from cs_to (coeq _ _) (field_type (fst it) (co_members (get_co id))) = true) (co_members (get_co id)).

Lemma field_offset_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id i,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  field_offset (@cenv_cs cs_from) i (co_members (@get_co cs_to id)) =
  field_offset (@cenv_cs cs_to) i (co_members (@get_co cs_to id)).

Lemma field_offset_next_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall id i,
  match (coeq cs_from cs_to) ! id with
  | Some b => test_aux cs_from cs_to b id
  | None => false
  end = true ->
  field_offset_next (@cenv_cs cs_from) i (co_members (get_co id)) (co_sizeof (@get_co cs_from id)) =
field_offset_next (@cenv_cs cs_to) i (co_members (get_co id)) (co_sizeof (@get_co cs_to id)).

Arguments field_type i m / .
Arguments field_offset env i m / . *)

Require Import VST.floyd.computable_theorems.
(* VST.floyd.computable_theorems:
Require Import Coq.ZArith.ZArith.
Require Import Coq.ZArith.Znumtheory.
Require Import Coq.Lists.List.
Require Import Coq.Bool.Bool.
Require Import compcert.cfrontend.Ctypes.

Definition in_eq: forall {A: Type} (a:A) l, In a (a::l) :=
  fun A a l => or_introl eq_refl.

Definition Forall_forall: forall {A : Type} (P : A -> Prop) (l : list A),
       Forall P l <-> (forall x : A, In x l -> P x)   :=
fun (A : Type) (P : A -> Prop) (l : list A) =>
conj
  (fun H : Forall P l =>
   Forall_ind (fun l0 : list A => forall x : A, In x l0 -> P x)
     (fun (x : A) (H0 : In x nil) => False_ind (P x) H0)
     (fun (x : A) (l0 : list A) (H0 : P x) (_ : Forall P l0)
        (IHForall : forall x0 : A, In x0 l0 -> P x0) (x0 : A)
        (H2 : In x0 (x :: l0)) =>
      or_ind
        (fun H3 : x = x0 =>
         eq_ind_r (fun x1 : A => P x1 -> P x0) (fun H4 : P x0 => H4) H3 H0)
        (fun H3 : In x0 l0 =>
         (fun H4 : In x0 l0 -> P x0 => (fun H5 : P x0 => H5) (H4 H3))
           (IHForall x0)) H2) H)
  (list_ind
     (fun l0 : list A => (forall x : A, In x l0 -> P x) -> Forall P l0)
     (fun _ : forall x : A, In x nil -> P x => Forall_nil P)
     (fun (a : A) (l0 : list A)
        (IHl : (forall x : A, In x l0 -> P x) -> Forall P l0)
        (H : forall x : A, In x (a :: l0) -> P x) =>
      (fun H0 : forall x : A, In x l0 -> P x =>
       (fun H1 : forall x : A, In x l0 -> P x =>
        (fun H2 : Forall P l0 =>
         (fun H3 : A =>
          (fun X : A =>
           (fun H4 : In X (a :: l0) -> P X =>
            (fun (_ : a = X -> P X)
               (_ : (fix In (a0 : A) (l1 : list A) {struct l1} : Prop :=
                       match l1 with
                       | nil => False
                       | b :: m => b = a0 \/ In a0 m
                       end) X l0 -> P X) =>
             Forall_cons a (H a (in_eq a l0)) H2)
              (fun H5 : a = X => H4 (or_introl H5))
              (fun
                 H5 : (fix In (a0 : A) (l1 : list A) {struct l1} : Prop :=
                         match l1 with
                         | nil => False
                         | b :: m => b = a0 \/ In a0 m
                         end) X l0 => H4 (or_intror H5))) (H X)) H3) a)
          (IHl H1)) H0)
        (fun (x : A) (H0 : In x l0) =>
         (fun H1 : In x (a :: l0) -> P x =>
          (fun (_ : a = x -> P x)
             (H3 : (fix In (a0 : A) (l1 : list A) {struct l1} : Prop :=
                      match l1 with
                      | nil => False
                      | b :: m => b = a0 \/ In a0 m
                      end) x l0 -> P x) => (fun H4 : P x => H4) (H3 H0))
            (fun H2 : a = x => H1 (or_introl H2))
            (fun
               H2 : (fix In (a0 : A) (l1 : list A) {struct l1} : Prop :=
                       match l1 with
                       | nil => False
                       | b :: m => b = a0 \/ In a0 m
                       end) x l0 => H1 (or_intror H2))) (H x))) l).

Lemma Forall_forall1: forall {A : Type} (P : A -> Prop) (l : list A),
       Forall P l -> (forall x : A, In x l -> P x).

Lemma Zcompare_refl: forall n, Z.compare n n = Eq.

Lemma Zle_refl: forall n, Z.le n n.

Lemma Zle_max_l: forall n m : Z, n <= Z.max n m.

Definition Pos_compare_cont_antisym :
  forall (p q : positive) (c : comparison),
       eq (CompOpp (Pos.compare_cont c p q))
         (Pos.compare_cont (CompOpp c) q p ) :=
fun (p q : positive) (c : comparison) =>
positive_ind
  (fun p0 : positive =>
   forall (q0 : positive) (c0 : comparison),
   CompOpp (Pos.compare_cont c0 p0 q0) =
   Pos.compare_cont (CompOpp c0) q0 p0)
  (fun (p0 : positive)
     (IHp : forall (q0 : positive) (c0 : comparison),
            CompOpp (Pos.compare_cont c0 p0 q0) =
            Pos.compare_cont (CompOpp c0) q0 p0)
     (q0 : positive) =>
   match
     q0 as p1
     return
       (forall c0 : comparison,
        CompOpp (Pos.compare_cont c0 p0~1 p1) =
        Pos.compare_cont (CompOpp c0) p1 p0~1)
   with
   | (q1~1)%positive =>
       fun c0 : comparison => IHp q1 c0
   | (q1~0)%positive =>
       fun c0 : comparison => IHp q1 Gt
   | 1%positive => fun c0 : comparison => eq_refl
   end)
  (fun (p0 : positive)
     (IHp : forall (q0 : positive) (c0 : comparison),
            CompOpp (Pos.compare_cont c0 p0 q0) =
            Pos.compare_cont (CompOpp c0) q0 p0)
     (q0 : positive) =>
   match
     q0 as p1
     return
       (forall c0 : comparison,
        CompOpp (Pos.compare_cont c0 p0~0 p1) =
        Pos.compare_cont (CompOpp c0) p1 p0~0)
   with
   | (q1~1)%positive =>
       fun c0 : comparison => IHp q1 Lt
   | (q1~0)%positive =>
       fun c0 : comparison => IHp q1 c0
   | 1%positive => fun c0 : comparison => eq_refl
   end)
  (fun q0 : positive =>
   match
     q0 as p0
     return
       (forall c0 : comparison,
        CompOpp (Pos.compare_cont c0 1 p0) =
        Pos.compare_cont (CompOpp c0) p0 1)
   with
   | (q1~1)%positive =>
       fun c0 : comparison => eq_refl
   | (q1~0)%positive =>
       fun c0 : comparison => eq_refl
   | 1%positive => fun c0 : comparison => eq_refl
   end) p q c.

Definition Pos_compare_antisym:
  forall p q : positive,
       eq (Pos.compare q p) (CompOpp (Pos.compare p q)) :=
  fun p q : positive =>
eq_ind_r (fun c : comparison => eq (Pos.compare_cont Eq q p) c) eq_refl
  (Pos_compare_cont_antisym p q Eq).

Lemma Pos_compare_absurd:
  forall x y c, (eq (Pos.compare_cont c x y) Eq) -> c=Eq.

Lemma Pos_compare_cont_eq:
  forall x y c, eq (Pos.compare_cont c x y) Eq -> eq x y.

Lemma Pos_compare_eq:
  forall x y, eq (Pos.compare x y) Eq -> eq x y.

Lemma Zmax_comm: forall n m, Z.max n m = Z.max m n.

Lemma Zle_max_r: forall n m : Z, m <= Z.max n m.

Local Open Scope nat.

Definition le_pred: forall n m : nat, n <= m -> pred n <= pred m :=
fun (n m : nat) (H : n <= m) =>
le_ind n (fun m0 : nat => pred n <= pred m0) (le_n (pred n))
  (fun (m0 : nat) (H0 : n <= m0) (IHle : pred n <= pred m0) =>
   match
     m0 as n0 return (n <= n0 -> pred n <= pred n0 -> pred n <= pred (S n0))
   with
   | 0 => fun (_ : n <= 0) (IHle0 : pred n <= pred 0) => IHle0
   | S m1 =>
       fun (_ : n <= S m1) (IHle0 : pred n <= pred (S m1)) =>
       le_S (pred n) m1 IHle0
   end H0 IHle) m H.

Definition le_S_n : forall n m : nat, S n <= S m -> n <= m  :=
   fun n m => le_pred (S n) (S m).

Definition max_l: forall n m : nat, m <= n -> max n m = n :=
fun n : nat =>
nat_ind (fun n0 : nat => forall m : nat, m <= n0 -> max n0 m = n0)
  (fun m : nat =>
   match m as n0 return (n0 <= 0 -> max 0 n0 = 0) with
   | 0 => fun _ : 0 <= 0 => eq_refl
   | S m0 =>
       fun H : S m0 <= 0 =>
       (fun H0 : 0 = 0 -> S m0 = 0 => H0 eq_refl)
         match H in (_ <= n0) return (n0 = 0 -> S m0 = 0) with
         | le_n =>
             fun H0 : S m0 = 0 =>
             (fun H1 : S m0 = 0 =>
              (fun H2 : False =>
               (fun H3 : False => False_ind (S m0 = 0) H3) H2)
                (eq_ind (S m0)
                   (fun e : nat =>
                    match e with
                    | 0 => False
                    | S _ => True
                    end) I 0 H1)) H0
         | le_S m1 H0 =>
             fun H1 : S m1 = 0 =>
             (fun H2 : S m1 = 0 =>
              (fun H3 : False =>
               (fun H4 : False => False_ind (S m0 <= m1 -> S m0 = 0) H4) H3)
                (eq_ind (S m1)
                   (fun e : nat =>
                    match e with
                    | 0 => False
                    | S _ => True
                    end) I 0 H2)) H1 H0
         end
   end)
  (fun (n0 : nat) (IHn : forall m : nat, m <= n0 -> max n0 m = n0) (m : nat) =>
   match m as n1 return (n1 <= S n0 -> max (S n0) n1 = S n0) with
   | 0 => fun _ : 0 <= S n0 => eq_refl
   | S m0 =>
       fun H : S m0 <= S n0 => f_equal S (IHn m0 (le_S_n m0 n0 H))
   end) n.

Definition max_r     : forall n m : nat, n <= m -> max n m = m :=
fun n : nat =>
nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> max n0 m = m)
  (fun m : nat =>
   match m as n0 return (0 <= n0 -> max 0 n0 = n0) with
   | 0 => fun _ : 0 <= 0 => eq_refl
   | S m0 => fun _ : 0 <= S m0 => eq_refl
   end)
  (fun (n0 : nat) (IHn : forall m : nat, n0 <= m -> max n0 m = m) (m : nat) =>
   match m as n1 return (S n0 <= n1 -> max (S n0) n1 = n1) with
   | 0 =>
       fun H : S n0 <= 0 =>
       (fun H0 : 0 = 0 -> S n0 = 0 => H0 eq_refl)
         match H in (_ <= n1) return (n1 = 0 -> S n0 = 0) with
         | le_n =>
             fun H0 : S n0 = 0 =>
             (fun H1 : S n0 = 0 =>
              (fun H2 : False =>
               (fun H3 : False => False_ind (S n0 = 0) H3) H2)
                (eq_ind (S n0)
                   (fun e : nat =>
                    match e with
                    | 0 => False
                    | S _ => True
                    end) I 0 H1)) H0
         | le_S m0 H0 =>
             fun H1 : S m0 = 0 =>
             (fun H2 : S m0 = 0 =>
              (fun H3 : False =>
               (fun H4 : False => False_ind (S n0 <= m0 -> S n0 = 0) H4) H3)
                (eq_ind (S m0)
                   (fun e : nat =>
                    match e with
                    | 0 => False
                    | S _ => True
                    end) I 0 H2)) H1 H0
         end
   | S m0 =>
       fun H : S n0 <= S m0 => f_equal S (IHn m0 (le_S_n n0 m0 H))
   end) n.

Definition le_n_S : forall n m : nat, n <= m -> S n <= S m :=
fun (n m : nat) (H : n <= m) =>
le_ind n (fun m0 : nat => S n <= S m0) (le_n (S n))
  (fun (m0 : nat) (_ : n <= m0) (IHle : S n <= S m0) =>
   le_S (S n) (S m0) IHle) m H.

Definition lt_n_S: forall n m : nat, n < m -> S n < S m :=
fun (n m : nat) (H : n < m) => le_n_S (S n) m H.

Definition le_trans: forall n m p : nat, n <= m -> m <= p -> n <= p :=
fun (n m p : nat) (H : n <= m) (H0 : m <= p) =>
le_ind m (fun p0 : nat => n <= p0) H
  (fun (m0 : nat) (_ : m <= m0) (IHle : n <= m0) => le_S n m0 IHle) p H0.

Definition le_Sn_le: forall n m : nat, S n <= m -> n <= m :=
fun (n m : nat) (H : S n <= m) => le_trans n (S n) m (le_S n n (le_n n)) H.

Definition lt_le_weak: forall n m : nat, n < m -> n <= m :=
fun (n m : nat) (H : n < m) => le_Sn_le n m H.

Lemma le_or_lt: forall n m : nat, n <= m \/ m < n.

Lemma le_max_l: forall n m : nat, n <= max n m.

Lemma le_max_r: forall n m : nat, m <= max n m.

Lemma rank_type_members:
  forall ce id t m, In (id, t) m -> (rank_type ce t <= rank_members ce m)%nat. *)

Open Scope nat.



Inductive ListType: list Type -> Type :=

  | Nil: ListType nil

  | Cons: forall {A B} (a: A) (b: ListType B), ListType (A :: B).



Fixpoint ListTypeGen {A} (F: A -> Type) (f: forall A, F A) (l: list A) : ListType (map F l) :=

  match l with

  | nil => Nil

  | cons h t => Cons (f h) (ListTypeGen F f t)

  end.



Lemma ListTypeGen_preserve: forall A F f1 f2 (l: list A),

  (forall a, In a l -> f1 a = f2 a) ->

  ListTypeGen F f1 l = ListTypeGen F f2 l.

Proof.

  intros.

  induction l.

  + reflexivity.

  + simpl.

    rewrite H, IHl.

    - reflexivity.

    - intros; apply H; simpl; tauto.

    - simpl; left; auto.

Defined.



Definition decay' {X} {F: Type} {l: list X} (v: ListType (map (fun _ => F) l)): list F.

  remember (map (fun _ : X => F) l) eqn:E.

  revert l E.

  induction v; intros.

  + exact nil.

  + destruct l; inversion E.

    specialize (IHv l H1).

    rewrite H0 in a.

    exact (a :: IHv).

Defined.



Fixpoint decay'' {X} {F: Type} (l0 : list Type) (v: ListType l0) :

  forall (l: list X), l0 = map (fun _ => F) l -> list F :=

  match v in ListType l1

    return forall l2, l1 = map (fun _ => F) l2 -> list F

  with

  | Nil => fun _ _ => nil

  | Cons A B a b =>

    fun (l1 : list X) (E0 : A :: B = map (fun _ : X => F) l1) =>

    match l1 as l2 return (A :: B = map (fun _ : X => F) l2 -> list F) with

    | nil => fun _ => nil 

    | x :: l2 =>

       fun E1 : A :: B = map (fun _ : X => F) (x :: l2) =>

       (fun

          X0 : map (fun _ : X => F) (x :: l2) =

               map (fun _ : X => F) (x :: l2) -> list F =>

        X0 eq_refl)

         match

           E1 in (_ = y)

           return (y = map (fun _ : X => F) (x :: l2) -> list F)

         with

         | eq_refl =>

             fun H0 : A :: B = map (fun _ : X => F) (x :: l2) =>

              (fun (H3 : A = F) (H4 : B = map (fun _ : X => F) l2) =>

                  (eq_rect A (fun A0 : Type => A0) a F H3) :: (decay'' B b l2 H4))

                 (f_equal

                    (fun e : list Type =>

                     match e with

                     | nil => A

                     | T :: _ => T

                     end) H0)

                (f_equal

                   (fun e : list Type =>

                    match e with

                    | nil => B

                    | _ :: l3 => l3

                    end) H0)

         end

    end E0

  end.



Definition decay {X} {F: Type} {l: list X} (v: ListType (map (fun _ => F) l)): list F :=

  let l0 := map (fun _ => F) l in

  let E := @eq_refl _ (map (fun _ => F) l) : l0 = map (fun _ => F) l in

  decay'' l0 v l E.



Lemma decay_spec: forall A F f l,

  decay (ListTypeGen (fun _: A => F) f l) = map f l.

Proof.

  intros.

  unfold decay.

  induction l.

  + simpl.

    reflexivity.

  + simpl.

    f_equal.

    auto.

Defined.



Section COMPOSITE_ENV.

Context {cs: compspecs}.



Lemma type_ind: forall P : type -> Prop,

  (forall t,

  match t with

  | Tarray t0 _ _ => P t0

  | Tstruct id _ => let m := co_members (get_co id) in Forall (fun it => P (field_type (fst it) m)) m

  | Tunion id _ => let m := co_members (get_co id) in Forall (fun it => P (field_type (fst it) m)) m

  | _ => True

  end -> P t) ->

  forall t, P t.

Proof.

  intros P IH_TYPE.

  intros.

  remember (rank_type cenv_cs t) as n eqn: RANK'.

  assert (rank_type cenv_cs t <= n)%nat as RANK.

  subst. apply le_n.

  clear RANK'.

  revert t RANK.

  induction n;

  intros;

  specialize (IH_TYPE t); destruct t;

  try solve [specialize (IH_TYPE I); auto].

  + 

    simpl in RANK. inv RANK.

  + 

    simpl in RANK.

    unfold get_co in IH_TYPE.

    destruct (cenv_cs ! i); [inv RANK | apply IH_TYPE; simpl; constructor].

  + 

    simpl in RANK.

    unfold get_co in IH_TYPE.

    destruct (cenv_cs ! i); [inv RANK | apply IH_TYPE].

    simpl; constructor.

  + 

    simpl in RANK.

    specialize (IHn t).

    apply IH_TYPE, IHn.

    apply le_S_n; auto.

  + 

    simpl in RANK.

    pose proof get_co_members_no_replicate i.

    unfold get_co in *.

    destruct (cenv_cs ! i) as [co |] eqn:CO; [| apply IH_TYPE; simpl; constructor].

    apply IH_TYPE; clear IH_TYPE.

    apply Forall_forall.

    intros [i0 t0] ?; simpl.

    apply IHn.

    pose proof In_field_type _ _ H H0.

    simpl in H1; rewrite H1.

    apply rank_type_members with (ce := cenv_cs) in H0.

    rewrite <- co_consistent_rank in H0.

    eapply le_trans; [eassumption |].

    apply le_S_n; auto.

    exact (cenv_consistent i co CO).

  + 

    simpl in RANK.

    pose proof get_co_members_no_replicate i.

    unfold get_co in *.

    destruct (cenv_cs ! i) as [co |] eqn:CO; [| apply IH_TYPE; simpl; constructor].

    apply IH_TYPE; clear IH_TYPE.

    apply Forall_forall.

    intros [i0 t0] ?; simpl.

    apply IHn.

    pose proof In_field_type _ _ H H0.

    simpl in H1; rewrite H1.

    apply rank_type_members with (ce := cenv_cs) in H0.

    rewrite <- co_consistent_rank in H0.

    eapply le_trans; [eassumption |].

    apply le_S_n; auto.

    exact (cenv_consistent i co CO).

Defined.



Ltac type_induction t :=

  pattern t;

  match goal with

  | |- ?P t =>

    apply type_ind; clear t;

    let t := fresh "t" in

    intros t IH;

    let id := fresh "id" in

    let a := fresh "a" in

    destruct t as [| | | | | | | id a | id a]

  end.



Variable A: type -> Type.



Definition FT_aux id :=

    let m := co_members (get_co id) in

    ListType (map (fun it => A (field_type (fst it) m)) m).



Variable F_ByValue: forall t: type, A t.

Variable F_Tarray: forall t n a, A t -> A (Tarray t n a).

Variable F_Tstruct: forall id a, FT_aux id -> A (Tstruct id a).

Variable F_Tunion: forall id a, FT_aux id -> A (Tunion id a).



Fixpoint type_func_rec (n: nat) (t: type): A t :=

  match n with

  | 0 =>

    match t as t0 return A t0 with

    | Tstruct id a =>

       match cenv_cs ! id with

       | None => let m := co_members (get_co id) in

                       F_Tstruct id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => F_ByValue (field_type (fst it) m)) m)

       | _ => F_ByValue (Tstruct id a)

       end

    | Tunion id a =>

       match cenv_cs ! id with

       | None => let m := co_members (get_co id) in

                      F_Tunion id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => F_ByValue (field_type (fst it) m)) m)

       | _ => F_ByValue (Tunion id a)

       end

    | t' => F_ByValue t'

    end

  | S n' =>

    match t as t0 return A t0 with

    | Tarray t0 n a => F_Tarray t0 n a (type_func_rec n' t0)

    | Tstruct id a =>  let m := co_members (get_co id) in

                            F_Tstruct id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func_rec n' (field_type (fst it) m)) m)

    | Tunion id a =>  let m := co_members (get_co id) in

                            F_Tunion id a (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func_rec n' (field_type (fst it) m)) m)

    | t' => F_ByValue t'

    end

  end.



Definition type_func t := type_func_rec (rank_type cenv_cs t) t.



Lemma rank_type_Tstruct: forall id a co, cenv_cs ! id = Some co ->

  rank_type cenv_cs (Tstruct id a) = S (co_rank (get_co id)).

Proof.

  intros.

  unfold get_co; simpl.

  destruct (cenv_cs ! id); auto; congruence.

Defined.



Lemma rank_type_Tunion: forall id a co, cenv_cs ! id = Some co ->

  rank_type cenv_cs (Tunion id a) = S (co_rank (get_co id)).

Proof.

  intros.

  unfold get_co; simpl.

  destruct (cenv_cs ! id); auto; congruence.

Defined.



Lemma type_func_rec_rank_irrelevent: forall t n n0,

  n >= rank_type cenv_cs t ->

  n0 >= rank_type cenv_cs t ->

  type_func_rec n t = type_func_rec n0 t.

Proof.

 
  intros t.

  type_induction t;

  intros;

  try solve [destruct n; simpl; auto; destruct n0; simpl; auto].

  + 

    destruct n; simpl in H; try solve [inv H].

    destruct n0; simpl in H; try solve [inv H0].

    simpl. f_equal.

    apply IH; apply le_S_n; auto.

  + 

    destruct (cenv_cs ! id) as [co |] eqn: CO.

    - erewrite rank_type_Tstruct in H by eauto.

      erewrite rank_type_Tstruct in H0 by eauto.

      clear co CO.

    destruct n; simpl in H; try solve [inv H].

    destruct n0; simpl in H; try solve [inv H0].

      simpl.

      f_equal.

      apply ListTypeGen_preserve.

      intros [i t] Hin.

      simpl in IH.

      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.

      specialize (IH (i, t) Hin n n0).

      apply le_S_n in H; apply le_S_n in H0.

      assert (H3 := rank_type_members cenv_cs i t _ Hin).

      pose proof get_co_members_no_replicate id.

      pose proof In_field_type (i, t) _ H1 Hin.

      rewrite <- (co_consistent_rank cenv_cs (get_co id) (get_co_consistent _)) in H3.

      unfold field_type in H2.

      apply IH;

       (eapply le_trans; [ | eassumption]; rewrite H2; auto).

    - destruct n, n0; simpl;  unfold FT_aux in *;

      generalize (F_Tstruct id a) as FF; unfold get_co;

      rewrite CO; intros; auto.

  + 

    destruct (cenv_cs ! id) as [co |] eqn: CO.

    - erewrite rank_type_Tunion in H by eauto.

      erewrite rank_type_Tunion in H0 by eauto.

      clear co CO.

    destruct n; simpl in H; try solve [inv H].

    destruct n0; simpl in H; try solve [inv H0].

      simpl.

      f_equal.

      apply ListTypeGen_preserve.

      intros [i t] Hin.

      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.

      specialize (IH (i, t) Hin n n0).

      apply le_S_n in H; apply le_S_n in H0.

      assert (H3 := rank_type_members cenv_cs i t _ Hin).

      pose proof get_co_members_no_replicate id.

      pose proof In_field_type (i, t) _ H1 Hin.

      rewrite <- (co_consistent_rank cenv_cs (get_co id) (get_co_consistent _)) in H3.

      apply IH;

       (eapply le_trans; [ | eassumption]; rewrite H2; auto).

    - destruct n, n0; simpl;  unfold FT_aux in *;

      generalize (F_Tunion id a) as FF; unfold get_co;

      rewrite CO; intros; auto.

Defined.



Definition FTI_aux id :=

    let m := co_members (get_co id) in

    (ListTypeGen (fun it => A (field_type (fst it) m)) (fun it => type_func (field_type (fst it) m)) m).



Lemma type_func_eq: forall t,

  type_func t =

  match t as t0 return A t0 with

  | Tarray t0 n a => F_Tarray t0 n a (type_func t0)

  | Tstruct id a => F_Tstruct id a (FTI_aux id)

  | Tunion id a => F_Tunion id a (FTI_aux id)

  | t' => F_ByValue t'

  end.

Proof.

  intros.

  type_induction t; try reflexivity.

  + 

    unfold type_func in *.

    simpl type_func_rec.

    destruct (cenv_cs ! id) as [co |] eqn:CO; simpl.

    - f_equal.

      apply ListTypeGen_preserve; intros [i t].

      unfold get_co; rewrite CO.

      intro Hin.

      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.

      apply type_func_rec_rank_irrelevent.

      * assert (H0 := get_co_members_no_replicate id).

        unfold get_co in H0; rewrite CO in H0.

        rewrite (In_field_type _ _ H0 Hin).

        rewrite (co_consistent_rank cenv_cs _

                           (cenv_consistent id co CO)).

        eapply rank_type_members; eauto.

      * apply le_n.

    - rewrite CO.

      f_equal.

      unfold FTI_aux, get_co; rewrite CO.

      reflexivity.

  + 

    unfold type_func in *.

    simpl type_func_rec.

    destruct (cenv_cs ! id) as [co |] eqn:CO; simpl.

    - f_equal.

      apply ListTypeGen_preserve; intros [i t].

      unfold get_co; rewrite CO.

      intro Hin.

      generalize (Forall_forall1 _ _ IH); clear IH; intro IH.

      apply type_func_rec_rank_irrelevent.

      * assert (H0 := get_co_members_no_replicate id).

        unfold get_co in H0; rewrite CO in H0.

        rewrite (In_field_type _ _ H0 Hin).

        rewrite (co_consistent_rank cenv_cs _

                           (cenv_consistent id co CO)).

        eapply rank_type_members; eauto.

      * apply le_n.

    - rewrite CO.

      f_equal.

      unfold FTI_aux, get_co; rewrite CO.

      reflexivity.

Defined.



End COMPOSITE_ENV.



Arguments type_func {cs} A F_ByValue F_Tarray F_Tstruct F_Tunion t / .



Ltac type_induction t :=

  pattern t;

  match goal with

  | |- ?P t =>

    apply type_ind; clear t;

    let t := fresh "t" in

    intros t IH;

    let id := fresh "id" in

    let a := fresh "a" in

    destruct t as [| | | | | | | id a | id a]

  end.

