Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)
Require Import mc_reify.list_ctype_eq.
(* mc_reify.list_ctype_eq:
Instance RelDec_list_ctype_beq: RelDec (@eq (list type)) := List.RelDec_eq_list RelDec_ctype_beq.
Instance RelDec_Correct_list_ctype_beq: RelDec_Correct RelDec_list_ctype_beq :=
  List.RelDec_Correct_eq_list RelDec_Correct_ctype_beq. *)
Require Import mc_reify.get_set_reif.
(* mc_reify.get_set_reif:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.
Locate expr.
Definition as_tree (e : expr typ func) : option
  ((typ * expr typ func * expr typ func * expr typ func) + typ) :=
match e with
  | (App (App (App (Inj (inr (Data (fnode t)))) l) o) r) =>
    Some (inl (t, l, o, r))
  | (Inj (inr (Data (fleaf t)))) =>
    Some (inr t)
  | _ => None
end.

Fixpoint set_reif (i : positive) (v : expr typ func) (m : expr typ func) (ty : typ) :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => node l (some_reif v t) r ty
      | xO ii => node (set_reif ii v l ty) o r t
      | xI ii => node l o (set_reif ii v r ty) t
    end
  | Some (inr t) =>
    match i with
      | xH => node (leaf t) (some_reif v t) (leaf t) ty
      | xO ii => node (set_reif ii v (leaf t) ty) (none_reif t) (leaf t) t
      | xI ii => node (leaf t) (none_reif t) (set_reif ii v (leaf t) ty) t
    end
  | _ => (App (App (Inj (inr (Data (fset ty i)))) v) m)
end.

Fixpoint get_reif (i : positive) (m : expr typ func) ty :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => o
      | xO ii => get_reif ii l ty
      | xI ii => get_reif ii r ty
    end
  | Some (inr t) => none_reif t
  | _ => (App (Inj (inr (Data (fget ty i))))  m)
end. *)
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCore.Lemma.
Require Import MirrorCore.RTac.Core.

Require Import mc_reify.update_tycon.
(* mc_reify.update_tycon:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.reify.
Require Import MirrorCore.Lambda.ExprCore.

Definition initialized_temp (id : positive) (t : PTree.t (type * bool)) :=
match (t ! id) with
| Some (ty, _) =>
  PTree.set id (ty, true) t
| None => t
end.

Fixpoint update_temp (t : PTree.t (type * bool)) (s : statement) :=
 match s with
 | Sskip | Scontinue | Sbreak => t
 | Sassign e1 e2 => t 
 | Sset id e2 => (initialized_temp id t)
 | Ssequence s1 s2 => let t' := update_temp t s1 in
                      update_temp t' s2
 | Sifthenelse b s1 s2 => join_te (update_temp t s1) (update_temp t s2)
 | Sloop _ _ => t
 | Sswitch e ls => update_temp_labeled t ls
 | Scall (Some id) _ _ => (initialized_temp id t)
 | _ => t  
end
with update_temp_labeled (t : PTree.t (type * bool)) (ls : labeled_statements) :=
       match ls with
         | LSnil => t
         | LScons _ s ls' =>
           join_te (update_temp t s) (update_temp_labeled t ls')
       end.

Lemma initialized_temp_eq : forall t v r gt gs i,
initialized i (mk_tycontext t v r gt gs) = mk_tycontext (initialized_temp i t) v r gt gs.

Lemma update_temp_eq : forall t v r gt gs s,
update_tycon (mk_tycontext t v r gt gs) s = (mk_tycontext (update_temp t s) v r gt gs)
with
update_temp_labeled_eq : forall t v r gt gs s,
join_tycon_labeled s (mk_tycontext t v r gt gs) = (mk_tycontext (update_temp_labeled t s) v r gt gs). *)
Require Import mc_reify.set_reif.
(* mc_reify.set_reif:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCore.Lambda.ExprCore.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.

Definition match_reif_option {B: Type} (e: expr typ func) (somef : typ -> expr typ func -> B)
           (nonef : typ -> B) (d : B) :=
match e with
| (App (Inj (inr (Other (fsome t)))) e) => somef t e
| (Inj (inr (Other (fnone t)))) => nonef t
| _ => d
end.

Inductive val_e :=
    Vundef : val_e
  | Vint : int -> val_e
  | Vlong : int64 -> val_e
  | Vfloat : float -> val_e
  | Vsingle : float32 -> val_e
  | Vexpr : expr typ func -> val_e
  | Vunop : Cop.unary_operation -> type ->  val_e -> val_e
  | Vbinop : Cop.binary_operation -> type -> type -> val_e -> val_e -> val_e
  | Veval_cast : type -> type -> val_e -> val_e
  | Vforce_ptr : val_e -> val_e
  | Veval_field : type -> ident -> val_e -> val_e.

Definition Vderef_noload (t: type) (e: val_e) : val_e :=
  match access_mode t with
  | By_reference => e
  | _ => Vundef
  end.

Definition val_e_binarith op ty1 ty2 e1 e2 :=
  match op, ty1, ty2, e1, e2 with
  | Oand, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_land) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_and) e1') e2')
      end
  | Oadd, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_add) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_add) e1') e2')
      end
  | _, _, _, _, _ => App (appR (Eval_f (feval_binop op
                                         ty1 ty2)) e1) e2
  end.

Fixpoint val_e_to_expr (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (appR (Intop fint_repr) (injR (Const (fZ (Int.unsigned i))))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr e)
  | Vbinop op ty1 ty2 e1 e2 => val_e_binarith op ty1 ty2 (val_e_to_expr e1) (val_e_to_expr e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr v)
end.

Definition msubst_var id T2 ty :=
match get_reif id T2 (typrod tyc_type tyval) with
  | App (Inj (inr (Other (fsome t))))
        (App (App (Inj (inr (Data (fpair t1 t2))))
                  (Inj (inr (Const (fCtype ty')))))
             v) =>
    if eqb_type ty ty'
    then Some (Vexpr v)
    else None
  | _ => None
end.

Fixpoint msubst_eval_expr_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option (val_e) :=
  match e with
  | Econst_int i ty => Some (Vint i)
  | Econst_long i ty => Some (Vlong i)
  | Econst_float f ty => Some (Vfloat f)
  | Econst_single f ty => Some (Vsingle f)
  | Etempvar id ty => match get_reif id T1 tyval with
                        | (App (Inj (inr (Other (fsome t)))) v) => Some (Vexpr v)
                        | _ => None
                      end
  | Eaddrof a ty => msubst_eval_lvalue_reif T1 T2 a
  | Eunop op a ty =>  option_map (Vunop op (typeof a)) (msubst_eval_expr_reif T1 T2 a)
  | Ebinop op a1 a2 ty => match (msubst_eval_expr_reif T1 T2 a1), (msubst_eval_expr_reif T1 T2 a2) with
                            | Some v1, Some v2 => Some (Vbinop op (typeof a1) (typeof a2) v1 v2)
                            | _, _ => None
                          end
  | Ecast a ty => option_map (Veval_cast (typeof a) ty) (msubst_eval_expr_reif T1 T2 a)
  | Evar id ty => option_map (Vderef_noload ty) (msubst_var id T2 ty)
  | Ederef a ty => option_map (Vderef_noload ty) (option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a))
  | Efield a i ty => option_map (Vderef_noload ty) (option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a))
  end
with
msubst_eval_lvalue_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option val_e :=
  match e with
  | Evar id ty => (msubst_var id T2 ty)
  | Ederef a ty => option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a)
  | Efield a i ty => option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a)
  | _  => Some Vundef
  end.

Definition rmsubst_eval_expr (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue T1 T2 e
| RRRR => rmsubst_eval_expr T1 T2 e
end.

Fixpoint msubst_efield_denote_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
  match efs with
  | nil => Some (injR (Data (fnil tygfield)))
  | cons (eStructField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx fstruct_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eUnionField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx funion_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eArraySubsc ei) efs0 =>
      match typeof ei, rmsubst_eval_expr T1 T2 ei with
      | Tint _ _ _,
        App (Inj (inr (Other (fsome _))))
         (App (Inj (inr (Value fVint))) i) =>
          match i with
          | App (Inj (inr (Intop fint_repr))) i' =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) i')))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          | _ =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) (appR (Intop fint_unsigned) i))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          end
      | _, _ => None
      end
  end.

Definition rmsubst_efield_denote (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
match msubst_efield_denote_reif T1 T2 efs with
| Some e => some_reif e (tylist tygfield)
| None => none_reif (tylist tygfield)
end.

Lemma Forall_reverse :
forall A P (l: list A),
Forall P l <->
Forall P (rev l).

Lemma in_fst :
forall T T2 (p : T) (v: T2) l,
In (p, v) l -> In p (map fst l).

Lemma elt_eq : forall T l p (v:T) v0 ls,
(p, v0) :: l = rev (PTree.elements (PTree.set p v ls)) ->

Definition tempD' := (fun Q i v => `(eq v) (eval_id i) :: Q).
Definition localD' := (fun Q i tv => `(eq (snd tv)) (eval_var i (fst tv)) :: Q).
Definition LocalD_app (T1: PTree.t val) (T2: PTree.t (type * val)) (Q: list (environ -> Prop)) :=
  (PTree.fold tempD' T1 nil) ++
 (PTree.fold localD' T2 nil) ++ Q.

Lemma localD_app_eq : forall t2 q, PTree.fold localD' t2 q = PTree.fold localD' t2 nil ++ q.

Lemma tempD_app_eq : forall t2 q, PTree.fold tempD' t2 q = PTree.fold tempD' t2 nil ++ q.

Lemma LocalD_app_eq :
forall t1 t2 q,
LocalD t1 t2 q = LocalD_app t1 t2 q.

Lemma fold_right_conj :
forall a b rho,
(fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) (a ++ b) rho) <-> ((fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) a rho /\ fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) b rho)).

Lemma LocalD_to_localD : forall P R t l,
PROPx (P) (LOCALx (LocalD t l []) (SEPx (R))) =
PROPx (P) (LOCALx (localD t l) (SEPx (R))).

Fixpoint val_e_to_expr_std (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (injR (Const (fint i))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr_std e)
  | Vbinop op ty1 ty2 e1 e2 => App (appR (Eval_f (feval_binop op ty1 ty2)) (val_e_to_expr_std e1)) (val_e_to_expr_std e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr_std v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr_std v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr_std v)
end.

Definition rmsubst_eval_expr_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue_std T1 T2 e
| RRRR => rmsubst_eval_expr_std T1 T2 e
end. *)
Require Import mc_reify.nth_reif.
(* mc_reify.nth_reif:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.

Definition as_list (e : expr typ func) : option
  ((typ * expr typ func * expr typ func) + typ) :=
match e with
  | Inj (inr (Data (fnil ty))) => Some (inr ty)
  | App (App (Inj (inr (Data (fcons ty)))) hd) tl => Some (inl (ty, hd, tl))
  | _ => None
end.

Fixpoint rnth_error (t: typ) (xs: expr typ func) (n: nat) : expr typ func :=
  match as_list xs with
  | Some (inr ty) => none_reif ty
  | Some (inl (ty, hd, tl)) =>
    match n with
    | O => some_reif hd ty
    | S n0 => rnth_error ty tl n0
    end
  | _ => App (Inj (inr (Data (fnth_error t n)))) xs
  end.

Fixpoint rreplace_nth (t: typ) (n: nat) (xs: expr typ func) (x: expr typ func) : expr typ func :=
  match as_list xs with
  | Some (inr ty) => xs
  | Some (inl (ty, hd, tl)) =>
    match n with
    | O => App (App (Inj (inr (Data (fcons ty)))) x) tl
    | S n0 => App (App (Inj (inr (Data (fcons ty)))) hd) (rreplace_nth t n0 tl x)
    end
  | _ => App (App (Inj (inr (Data (freplace_nth t n)))) xs) x
  end.

Require Import ExtLib.Tactics.
Require Import solve_exprD.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let RSym_sym_ok :  RSymOk RSym_sym := _.
Existing Instance RSym_sym_ok.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Existing Instance MA.

Definition reflect tus tvs e (ty : typ)
 := @exprD _ _ _ Expr_expr_fs tus tvs e ty.

Lemma some_none: forall T v, @None T = Some v -> False.

Lemma as_list_cons : forall e t hd tl,
  as_list e = Some (inl (t, hd, tl)) ->
  e = App (App (Inj (inr (Data (fcons t)))) hd) tl.

Lemma as_list_nil : forall e t,
  as_list e = Some (inr t) ->
  e = Inj (inr (Data (fnil t))).

Ltac solve_exprD := solve_exprD.solve_exprD tbl.

Opaque type_cast.

Ltac destruct_as_list :=
repeat
match goal with
| [ H : context [ match as_list ?x with _ => _ end] |- _] => destruct (as_list x) eqn:?
| [ |- context [ match as_list ?x with _ => _ end]] => destruct (as_list x) eqn:?
| [ H : as_list _ = Some (inr _) |- _ ] => apply as_list_nil in H
| [ H : as_list _ = Some (inl (_ , _, _)) |- _ ] => apply as_list_cons in H
| [ H : as_list _ = Some (inl (?p, _)) |- _ ] => destruct p
| [ H : as_list _ = Some (inl ?p) |- _ ] => destruct p
| [ H : as_list _ = Some ?p |- _ ] => destruct p
end;
subst.

Lemma rnth_error_eq2 :
forall typ xs n tus tvs val,
exprD' tus tvs (tylist typ) xs = Some val ->
exprD' tus tvs (tyoption typ) (App (Inj (inr (Data (fnth_error typ n)))) xs)  =
exprD' tus tvs (tyoption typ) (rnth_error typ xs n).

Lemma typeof_rreplace_nth: forall t xs x n tus tvs,
  typeof_expr tus tvs xs = Some (tylist t) ->
  typeof_expr tus tvs x = Some t ->
  typeof_expr tus tvs (rreplace_nth t n xs x) = Some (tylist t).

Lemma rreplace_nth_eq2 :
forall typ xs x n tus tvs val v,
exprD' tus tvs (tylist typ) xs = Some val ->
exprD' tus tvs typ x = Some v ->
exprD' tus tvs (tylist typ) (App (App (Inj (inr (Data (freplace_nth typ n)))) xs) x)  =
exprD' tus tvs (tylist typ) (rreplace_nth typ n xs x).

End tbled. *)
Require Import mc_reify.solve_exprD.
(* mc_reify.solve_exprD:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.
Require Import mc_reify.get_set_reif.
Require Import ExtLib.Tactics.
Require Import VST.floyd.client_lemmas.

Ltac destruct_match H :=
match type of H with
| context [ match ?x with _ => _  end] => destruct x eqn:?
end.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let RSym_sym_ok :  RSymOk RSym_sym := _.
Existing Instance RSym_sym_ok.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Existing Instance MA.

Lemma exprD'_App_R_typ  (e1 e2 : expr typ func) tus tvs ty1 ty2 v:
exprD' tus tvs ty2 (App e1 e2) = Some v ->
typeof_expr tus tvs e2 = Some ty1 ->
(exists v1 , exprD' tus tvs (tyArr ty1 ty2) e1 = Some v1) /\
(exists v2, exprD' tus tvs ty1 e2 = Some v2).

Lemma exprD'_App_L_typ  (e1 e2 : expr typ func) tus tvs ty1 ty2 v:
exprD' tus tvs ty2 (App e1 e2) = Some v ->
typeof_expr tus tvs e1 = Some (tyArr ty1 ty2) ->
(exists v1 , exprD' tus tvs (tyArr ty1 ty2) e1 = Some v1) /\
(exists v2, exprD' tus tvs ty1 e2 = Some v2).

Lemma exprD_typeof_Some : forall tus tvs t (e : expr typ func) val,
exprD' tus tvs t e = Some val -> typeof_expr tus tvs e = Some t.

Lemma typeof_app : forall (e1 e2 : expr typ func) t tvs tus,
typeof_expr tus tvs (App e1 e2) = Some t ->
exists t2, typeof_expr tus tvs e1 = Some (tyArr t2 t) /\
typeof_expr tus tvs e2 = Some (t2).

Lemma exprD_ex_typs : forall tus tvs t (e1 e2 : expr typ func) v,
exprD' tus tvs t (App e1 e2) = Some v ->
exists t2, typeof_expr tus tvs e1 = Some (tyArr t2 t) /\
typeof_expr tus tvs e2 = Some (t2).

Lemma exprD'_one_type : forall tus tvs t1 t2 (e : expr typ func) v1 v2,
exprD' tus tvs t1 e = Some v1 ->
exprD' tus tvs t2 e = Some v2 ->
t1 = t2.

End tbled.

Ltac inv H := inversion H; first [subst | subst_any]; clear H.

Ltac inv_some :=
repeat
match goal with
| [ H : Some _ = Some _ |- _] => inv H
| [ H : None = None |- _ ] => clear H
end.

Ltac rewrite_in_match :=
repeat
match goal with
| [ H : ?x = _ |- context[match ?x with _ => _ end]] =>
   rewrite H
| [ H : ?x = _, H1 : context[match ?x with _ => _ end] |- _] =>
   rewrite H in H1
end.

Ltac destruct_match_oneres :=
repeat match goal with
[ H : context[match ?x with _ => _ end] |- _] =>
  (destruct x eqn:?; try congruence); [ idtac ]
end.

Ltac progress_match :=
repeat (rewrite_in_match; destruct_match_oneres).

Ltac try_simpl_typeof :=
try
match goal with
| [ |- context [typeof_expr ?tus ?tvs ?e] ] =>
   let simpd := eval hnf in (typeof_expr tus tvs e) in
   match simpd with
     | Some _ => change (typeof_expr tus tvs e) with simpd; cbv beta iota
   end
| [ H : context [typeof_expr ?tus ?tvs ?e] |- _ ] =>
   let simpd := eval hnf in (typeof_expr tus tvs e) in
   match simpd with
     | Some _ => change (typeof_expr tus tvs e) with simpd in H; cbv beta iota in H
   end
end.

Ltac cautious_simpl :=
repeat (
cbv [Monad.bind Monad.ret OptionMonad.Monad_option
] in *;
try_simpl_typeof).

Ltac p_exprD H1 :=
autorewrite with exprD_rw in H1; try apply _;
cautious_simpl; repeat (progress_match; inv_some).

Ltac cleanup_dups :=
  repeat
    match goal with
      | [ H : ?x = Some _, H2 : ?x = Some _ |- _ ] => rewrite H in H2; inv_some
      | [ H : ?x = ?x |- _] => clear H
    end.

Ltac remove_no_cast :=
repeat
match goal with
[ H : type_cast ?x ?x = Some _ |- _] => clear H
end.

Ltac subst_rty :=
repeat
match goal with
| [ H : Rty _ _ |- _ ] => unfold Rty in H; inversion H; subst; remove_no_cast;
                          try clear H
end.

Ltac inv_same_types tbl :=
repeat
match goal with
 [ H : exprD' ?tus ?tvs ?t1 ?e = Some ?v1,
   H1 : exprD' ?tus ?tvs ?t2 ?e = Some ?v2 |- _] =>
let N := fresh "H" in assert (N := exprD'_one_type tbl tus tvs t1 t2 e v1 v2 H H1); subst; try inv N; cleanup_dups
end.

Ltac p_exprD_app tbl :=
  repeat
    (match goal with
       | [ H : exprD' _ _ _ (App _ _ ) =  _ |- _ ] => p_exprD H
       | [ H : context [match exprD' _ _ _ (App _ _) with _ => _ end] |- _] =>
         p_exprD H
    end;
  cleanup_dups; subst_rty; inv_same_types tbl).

Ltac solve_funcAs :=
repeat
match goal with
| [ H : context [funcAs _ _] |- _ ]  =>
  unfold funcAs in H; simpl in H;
repeat (rewrite type_cast_refl in H; try apply _; unfold Rcast, Relim in H; simpl in H)
| [ |- context [funcAs _ _ ] ]=> unfold funcAs; simpl;
repeat (try rewrite type_cast_refl; try apply _; unfold Rcast, Relim; simpl)
end;
repeat (try rewrite type_cast_refl; try apply _; unfold Rcast, Relim; simpl).

Ltac solve_funcAs_f H :=
  p_exprD H;
  solve_funcAs H;
  match type of H with
    | match ?f with _ => _ end = _ =>
      let eqn := fresh "eqn" in
      let v := fresh "v" in
      (destruct f as [v | ]; try congruence);
        clear H; unfold Rty in v; inversion v; subst; try clear v
  end.

Ltac p_exprD_inj tbl :=
repeat (
match goal with
| [ H : exprD' ?tus ?tvs ?t (Inj ?e ) = Some ?val |- _ ] =>
let X := fresh "X" in
     (assert (X := exprD_typeof_Some tbl tus tvs t (Inj e) val);
     simpl in X; specialize (X H); inv X);
       p_exprD H; ( solve_funcAs || fail)
| [ H : context [match exprD' ?tus ?tvs ?t (Inj ?e ) with _ => _ end] |- _ ] =>
       p_exprD H; ( solve_funcAs || fail)
| [ H : exprD' ?tus ?tvs ?t (Inj ?e ) = _ |- _ ] =>
       p_exprD H; ( solve_funcAs || fail)
end; unfold Rcast in *; cautious_simpl; inv_some; subst_rty);
cleanup_dups; try apply _; inv_some.

Ltac copy H :=
  match type of H with
    | ?x => assert x by exact H
  end.

Ltac pose_exprD' :=
  repeat
    match goal with
      | [ H : typeof_expr ?tus ?tvs ?v = Some ?t  |- _ ] =>
        match goal with
          | [H' : exprD' tus tvs t v = Some _ |- _ ] => fail 1
          | _ => match type of H with
                   | ?x => let X := fresh "H" in
                       assert x as X by exact H;
                       rewrite (ExprFacts.exprD'_typeof_expr tus tvs v t) in X;
                       destruct X
                 end
        end
    end.

Ltac pose_types tbl :=
             repeat
             match goal with
               | [ H : exprD' ?tus ?tvs ?ty ?v = Some ?r  |- _ ] =>
                   match goal with
                     | [H' : typeof_expr tus tvs v = Some ty |- _ ] => fail 1
                     | _ => let X := fresh "H" in
                             assert (X := exprD_typeof_Some tbl tus tvs ty v r H)
                   end
             end.

Ltac solve_exprD tbl :=
repeat (
    p_exprD_app tbl;
    p_exprD_inj tbl;
    autorewrite with exprD_rw; cautious_simpl; solve_funcAs;
    try solve [auto with typeclass_instances | reflexivity | apply _];
    try congruence; pose_types tbl;  fold func in *;
                                                 progress_match;
    try (rewrite type_cast_refl in *; apply _;
         unfold Rcast, Relim; cautious_simpl);
    try solve [unfold exprT_App in *; simpl; eauto];
    try apply _). *)
Require Import ExtLib.Tactics.
Require Import MirrorCore.Lambda.ExprDsimul.
Require Import get_set_reif_soundness.
(* get_set_reif_soundness:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.
Require Import mc_reify.get_set_reif.
Require Import ExtLib.Tactics.
Require Import solve_exprD.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let RSym_sym_ok :  RSymOk RSym_sym := _.
Existing Instance RSym_sym_ok.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Existing Instance MA.

Definition reflect tus tvs e (ty : typ)
 := @exprD _ _ _ Expr_expr_fs tus tvs e ty.

Lemma some_none: forall T v, @None T = Some v -> False.

Lemma as_tree_l : forall e t l o r,
as_tree e = Some (inl (t, l, o, r)) ->
e = (App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Lemma as_tree_r : forall e t,
as_tree e = Some (inr t) ->
e = (Inj (inr (Data (fleaf t)))).

Ltac destruct_as_tree :=
repeat
match goal with
| [ H : context [ match as_tree ?x with _ => _ end] |- _] => destruct (as_tree x) eqn:?
| [ H : as_tree _ = Some (inl (_ , _ , _, _)) |- _ ] => apply as_tree_l in H
| [ H : as_tree _ = Some (inr _) |- _ ] => apply as_tree_r in H
| [ H : as_tree _ = Some (inl (?p, _, _)) |- _ ] => destruct p
| [ H : as_tree _ = Some (inl (?p, _)) |- _ ] => destruct p
| [ H : as_tree _ = Some (inl ?p) |- _ ] => destruct p
| [ H : as_tree _ = Some ?p |- _ ] => destruct p
end;
subst.

Ltac solve_exprD := solve_exprD.solve_exprD tbl.

Opaque type_cast.

Lemma get_reif_val_exists :
forall i tr typ tus tvs vtr,
exprD' tus tvs (typtree typ) tr = Some vtr ->
exists v, exprD' tus tvs (tyoption typ) (get_reif i tr typ) = Some v.

Lemma get_reif_eq2 :
forall typ i tr tus tvs val,
exprD' tus tvs (typtree typ) tr = Some val ->
exprD' tus tvs (tyoption typ) (App (Inj (inr (Data (fget typ i)))) tr)  =
exprD' tus tvs (tyoption typ) (get_reif i tr typ) .

Lemma set_reif_istree :
  forall i tus tvs t0 vr e t x,
    exprD' tus tvs t0 (set_reif i vr e t) = Some x ->
    t0 = typtree t.

Lemma set_reif_exprD :
forall tus tvs typ i vr e v ev,
exprD' tus tvs (typtree typ) e = Some ev ->
exprD' tus tvs typ vr = Some v ->
exists r, exprD' tus tvs (typtree typ) (set_reif i vr e typ) = Some r.
 
Lemma set_reif_vr : forall tus tvs typ i e vr e4,
  exprD' tus tvs (typtree typ) (set_reif i vr e typ) = Some e4 ->
  exists v, exprD' tus tvs typ vr = Some v.

Ltac extract_set_reif_type :=
repeat
match goal with
| [ H : exprD' ?tus ?tvs (typtree ?t) (set_reif _ _ _ _) = _ |- _] => fail 1
| [ H : exprD' ?tus ?tvs ?t (set_reif ?i ?vr ?e ?t0) = Some ?x |- _] =>
pose proof (set_reif_istree i tus tvs t vr e t0 x H); subst; try congruence
end.

Ltac set_reif_ex :=
match goal with
|  [ H : exprD' ?tus ?tvs (typtree ?t) (set_reif ?i ?vr ?e ?t) = None |- _ ] =>
      edestruct (set_reif_exprD tus tvs t i vr e); eauto; fold func in *;
try congruence
| [ H : context[match typeof_expr ?tus ?tvs (set_reif ?i ?vr ?e ?t) with _ => _ end ] |- _ ] =>
  edestruct (set_reif_exprD tus tvs t i vr e); eauto; pose_types; fold func in *;  forward
end.

Lemma typeof_set_reif_None_F :
forall tus tvs i e t ev vr v,
exprD' tus tvs (typtree t) e = Some ev ->
exprD' tus tvs t vr = Some v ->
typeof_expr tus tvs (set_reif i vr e t) = None ->
False.

Ltac set_typeof_None :=
  match goal with
    | [H: typeof_expr ?tus ?tvs (set_reif ?i ?vr ?e ?t) = None |- _ ] =>
      try solve [eapply typeof_set_reif_None_F in H; first [progress eauto | solve_exprD]; try contradiction]
end.

Ltac get_vr_type :=
repeat
match goal with
|  [ H :  exprD' ?tus ?tvs (typtree ?typ) (set_reif ?i ?vr ?e ?typ) = Some ?v |- _ ] =>
   match goal with
     | [ H': exprD' tus tvs typ vr = Some _ |- _] => fail 1
     | _ => destruct (set_reif_vr _ _ typ _ _ _ _ H)
   end
end.

Ltac set_reif_tac :=
repeat (unfold RSym_sym in *;
        solve_exprD;
        try set_reif_ex;
        extract_set_reif_type;
        try set_typeof_None;
        try (progress get_vr_type; pose_types tbl)
        ).

Lemma set_reif_eq2 :
forall i tus tvs typ vr tr val,
exprD' tus tvs (typtree typ) tr = Some val ->
exprD' tus tvs (typtree typ) (App (App (Inj (inr (Data (fset typ i)))) vr) tr)  =
exprD' tus tvs (typtree typ) (set_reif i vr tr typ).

End tbled. *)
Import ExprDenote.

Section tbled.

Existing Instance SubstUpdate_ctx_subst.

Variable tbl : SymEnv.functions RType_typ.

Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Existing Instance SubstOk_ctx_subst.
Existing Instance SubstUpdate_ctx_subst.
Existing Instance SubstUpdateOk_ctx_subst.
Existing Instance RType_typ.
Existing Instance Typ2_tyArr.
Existing Instance Expr_expr.
Existing Instance MA.
Existing Instance Expr_ok_fs.
Instance MentionsAnyOk : MentionsAnyOk MA _ _.
Admitted.

Ltac solve_exprD := solve_exprD.solve_exprD tbl.
Opaque type_cast.

Definition AFTER_SET_LOAD : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App (App (Inj (inr (Smx fassertD))) P)
         (App
            (App (Inj (inr (Smx flocalD)))
               (App
                  (App (Inj (inr (Data (fset tyval id))))
                     v) T1)) T2)) R =>
    let l' :=
    App
      (App (App (Inj (inr (Smx fassertD))) P)
         (App
            (App (Inj (inr (Smx flocalD)))
                  (set_reif id v T1 tyval)) T2)) R
    in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma AFTER_SET_LOAD_sound : rtac_sound AFTER_SET_LOAD.
Proof.
unfold rtac_sound.
intros.
unfold AFTER_SET_LOAD in *.
repeat (destruct_match H; try solve [subst; apply rtac_spec_Fail]; try congruence).
pose proof (exprUnify_sound).
specialize (H0 (ctx_subst ctx) typ func  _ _ _ _ _ _ _ _

_ _ 3).
subst.
red in H0. red in H0.
unfold rtac_spec. simpl. intros.
apply H0 with (tv' := nil) in Heqo1; auto. clear H0.
destruct Heqo1.

split. auto.
forward. simpl in *.
unfold propD in H4. unfold exprD'_typ0 in H4.
simpl in H4.
solve_exprD.
unfold exprT_App. simpl.
destruct (pctxD_substD H1 H3).
destruct H4.
edestruct (H2 ( (fun (us0 : HList.hlist types.typD (getUVars ctx))
             (vs0 : HList.hlist types.typD (getVars ctx)) =>
           local2ptree.assertD (e14 us0 vs0)
             (local2ptree.localD
                (Maps.PTree.set p (e13 us0 vs0) (e11 us0 vs0))
                (e8 us0 vs0)) (e5 us0 vs0)))); eauto.

solve_exprD.
edestruct set_reif_exprD. apply Heqo14.
eauto.
instantiate (1 := p) in H6.
pose_types tbl. fold func in *. unfold RSym_sym in *.
 progress_match. solve_funcAs.
solve_exprD. unfold exprT_App. simpl.
erewrite <- set_reif_eq2 in H6; eauto.
solve_exprD.
forward_reason.
destruct (substD_pctxD _ H0 H3 H6).
forward_reason.
forward. inv_some.
split. admit. 
intros.  gather_facts.
eapply Pure_pctxD. eauto.
intros. simpl in *.
edestruct H7; eauto.
specialize (H11 HList.Hnil).
apply H11.
Admitted.

Definition AFTER_STORE : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App (App (Inj (inr (Smx fassertD))) P) Q)
      (App
         (App (Inj (inr (Data (freplace_nth tympred n)))) R) Rn) =>
    let l' :=
    App
      (App (App (Inj (inr (Smx fassertD))) P) Q)
      (rreplace_nth tympred n R Rn)
    in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma AFTER_STORE_sound : rtac_sound AFTER_STORE.
Proof.
unfold rtac_sound.
intros.
unfold AFTER_STORE in *.
repeat (destruct_match H; try solve [subst; apply rtac_spec_Fail]; try congruence).
pose proof (exprUnify_sound).
specialize (H0 (ctx_subst ctx) typ func  _ _ _ _ _ _ _ _

_ _ 3).
subst.
red in H0. red in H0.
unfold rtac_spec. simpl. intros.
apply H0 with (tv' := nil) in Heqo1; auto. clear H0.
destruct Heqo1.

split. auto.
forward. simpl in *.
unfold propD in H4. unfold exprD'_typ0 in H4.
simpl in H4.
solve_exprD.
unfold exprT_App. simpl.
destruct (pctxD_substD H1 H3).
destruct H4.
edestruct (H2 ( (fun (us0 : HList.hlist types.typD (getUVars ctx))
             (vs0 : HList.hlist types.typD (getVars ctx)) =>
           local2ptree.assertD (e11 us0 vs0) (e9 us0 vs0)
             (canon.replace_nth n (e7 us0 vs0) (e6 us0 vs0))))); eauto.
admit.
forward_reason.
destruct (substD_pctxD _ H0 H3 H6).
forward_reason.
forward. inv_some.
split. admit. 
intros.  gather_facts.
eapply Pure_pctxD. eauto.
intros. simpl in *.
edestruct H7; eauto.
specialize (H11 HList.Hnil).
apply H11.
Admitted.

Definition REFLEXIVITYTAC : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l r ty s with
    | Some su => RTac.Core.Solved su
    | None =>  RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma REFLEXIVITYTAC_sound  :
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) REFLEXIVITYTAC.
unfold rtac_sound.
intros.
unfold REFLEXIVITYTAC in H.
do 7 (match type of H with
          | match ?g with _ => _ end = _ => destruct g eqn:?;
                      try solve [simpl in H; subst;
                      try apply rtac_spec_Fail]
        end).
pose proof (exprUnify_sound).
specialize (H0 (ctx_subst ctx) typ func  _ _ _ _ _ _ _ _

_ _ 3).
subst.
red in H0. red in H0.
unfold rtac_spec. simpl. intros.
apply H0 with (tv' := nil) in Heqo1; auto. clear H0.
destruct Heqo1.

split. auto.
forward. simpl in *.
unfold propD in H4. unfold exprD'_typ0 in H4.
simpl in H4.

solve_exprD.
unfold exprT_App. simpl.
destruct (pctxD_substD H1 H3).
destruct H4.
edestruct H2; eauto.
forward_reason.
destruct (substD_pctxD _ H0 H3 H6).
forward_reason.
forward. inv_some.
split. admit. 
intros.  gather_facts.
eapply Pure_pctxD. eauto.
intros. simpl in *.
edestruct H7; eauto.
specialize (H11 HList.Hnil).
apply H11.
Admitted.

Definition REFLEXIVITY := REFLEXIVITYTAC.

Definition REFLEXIVITYTAC_msubst : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App
         (App
            (App (Inj (inr (Smx fmsubst_eval_LR))) T1) T2)
         (Inj (inr (Const (fCexpr e1)))))
      (Inj (inr (Const (fllrr lr)))) =>
    let l' := rmsubst_eval_LR T1 T2 e1 lr in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_MSUBST := REFLEXIVITYTAC_msubst.

Definition REFLEXIVITYTAC_msubst_efield : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App (App (Inj (inr (Smx (fmsubst_efield_denote e)))) T1) T2 =>
    let l' := rmsubst_efield_denote T1 T2 e in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_MSUBST_EFIELD := REFLEXIVITYTAC_msubst_efield.

Definition REFLEXIVITYTAC_nth_error : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App (Inj (inr (Data (fnth_error ty n)))) xs =>
    let l' := rnth_error ty xs n in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_NTH_ERROR := REFLEXIVITYTAC_nth_error.

Definition REFLEXIVITY_DENOTE (rtype : typ) {H: @RelDec.RelDec (typD rtype) eq}
{H0: RelDec.RelDec_Correct H} tbl : rtac typ (expr typ func) :=
   fun tus tvs lus lvs c s e => (
match e with
| (App (App (Inj (inr (Other (feq _)))) l) r) =>
  match func_defs.reflect tbl nil nil l rtype, func_defs.reflect tbl nil nil r rtype with
  | Some v1, Some v2 => if @RelDec.rel_dec _ eq H v1 v2 then Solved s else Fail
  | _, _ => Fail
  end
| _ => Fail
end).

Lemma REFLEXIVITY_DENOTE_sound (rtype : typ) {H: @RelDec.RelDec (typD rtype) eq}
{H0: RelDec.RelDec_Correct H}:
rtac_sound (REFLEXIVITY_DENOTE rtype tbl).
unfold rtac_sound.
intros.
unfold REFLEXIVITY_DENOTE in H1.
repeat (match type of H1 with
          | match ?g with _ => _ end = _ => destruct g eqn:?;
                      try solve [simpl in H; subst;
                      try apply rtac_spec_Fail]
        end).
subst. simpl. intros.
split.
unfold func_defs.reflect, exprD in *. simpl in *.
solve_exprD.
forward. split. reflexivity.
intros.
unfold propD, exprD'_typ0 in *.  simpl in H4.
solve_exprD.
unfold exprT_App. simpl.
eapply Pure_pctxD. eauto.
intros.
unfold func_defs.reflect, exprD in *. simpl in *.
forward. inv_some.
inversion H0. rewrite rel_dec_correct in Heqb.
generalize (ExprFacts.exprD'_weaken    _ _ _ (getUVars ctx) (getVars ctx)  H4).
generalize (ExprFacts.exprD'_weaken    _ _ _ (getUVars ctx) (getVars ctx)  H5).
intros.
destruct H6, H7. simpl  in *. destruct H6, H7.
fold func in *. unfold RSym_sym in *.
solve_exprD.
specialize (H8 HList.Hnil HList.Hnil).
specialize (H9 HList.Hnil HList.Hnil).
simpl in *.
solve_exprD.
Qed.

Definition REFLEXIVITY_BOOL := REFLEXIVITY_DENOTE tybool.

Definition REFLEXIVITY_BOOL_sound := REFLEXIVITY_DENOTE_sound tybool.

Definition REFLEXIVITY_CEXPR := REFLEXIVITY_DENOTE tyc_expr.

Definition REFLEXIVITY_CEXPR_sound := REFLEXIVITY_DENOTE_sound tyc_expr.

Definition REFLEXIVITY_CTYPE := REFLEXIVITY_DENOTE (tyc_type).

Definition REFLEXIVITY_CTYPE_sound := REFLEXIVITY_DENOTE_sound (tyc_type).

Instance RelDec_op_ctypes_beq : @RelDec.RelDec (option Ctypes.type) eq :=
  Option.RelDec_eq_option RelDec_ctype_beq.

Instance RelDec_Correct_op_ctypes_beq : RelDec.RelDec_Correct RelDec_op_ctypes_beq :=
  Option.RelDec_Correct_eq_option RelDec_Correct_ctype_beq.

Definition REFLEXIVITY_OP_CTYPE := REFLEXIVITY_DENOTE (tyoption tyc_type).

Definition REFLEXIVITY_OP_CTYPE_sound := REFLEXIVITY_DENOTE_sound (tyoption tyc_type).

End tbled.
