

Require Import Coqlib Decidableplus.
(* Decidableplus:
Program Definition Decidable_eq {A: Type} (eqdec: forall (x y: A), {x=y} + {x<>y}) (x y: A) : Decidable (eq x y) := {|
  Decidable_witness := proj_sumbool (eqdec x y)
|}. *)

Require Import AST Machregs Locations.
(* Machregs:
Require Import String.
Require Import Coqlib.
Require Import Decidableplus.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Op.

Inductive mreg: Type :=
  
  | AX | BX | CX | DX | SI | DI | BP
  | R8 | R9 | R10 | R11 | R12 | R13 | R14 | R15  
  
  | X0 | X1 | X2 | X3 | X4 | X5 | X6 | X7
  | X8 | X9 | X10 | X11 | X12 | X13 | X14 | X15  
  
  | FP0.

Lemma mreg_eq: forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2}.
Global Opaque mreg_eq.

Definition all_mregs :=
     AX :: BX :: CX :: DX :: SI :: DI :: BP
  :: R8 :: R9 :: R10 :: R11 :: R12 :: R13 :: R14 :: R15
  :: X0 :: X1 :: X2 :: X3 :: X4 :: X5 :: X6 :: X7
  :: X8 :: X9 :: X10 :: X11 :: X12 :: X13 :: X14 :: X15
  :: FP0 :: nil.

Lemma all_mregs_complete:
  forall (r: mreg), In r all_mregs.

Instance Decidable_eq_mreg : forall (x y: mreg), Decidable (eq x y) := Decidable_eq mreg_eq.

Instance Finite_mreg : Finite mreg := {
  Finite_elements := all_mregs;
  Finite_elements_spec := all_mregs_complete
}.

Definition mreg_type (r: mreg): typ :=
  match r with
  | AX | BX | CX | DX | SI | DI | BP => if Archi.ptr64 then Tany64 else Tany32
  | R8 | R9 | R10 | R11 | R12 | R13 | R14 | R15 => Tany64
  | X0 | X1 | X2 | X3 | X4 | X5 | X6 | X7 => Tany64
  | X8 | X9 | X10 | X11 | X12 | X13 | X14 | X15 => Tany64
  | FP0 => Tany64
  end.

Local Open Scope positive_scope.

Module IndexedMreg <: INDEXED_TYPE.
  Definition t := mreg.
  Definition eq := mreg_eq.
  Definition index (r: mreg): positive :=
    match r with
    | AX => 1 | BX => 2 | CX => 3 | DX => 4 | SI => 5 | DI => 6 | BP => 7
    | R8 => 8 | R9 => 9 | R10 => 10 | R11 => 11 | R12 => 12 | R13 => 13 | R14 => 14 | R15 => 15
    | X0 => 16 | X1 => 17 | X2 => 18 | X3 => 19 | X4 => 20 | X5 => 21 | X6 => 22 | X7 => 23
    | X8 => 24 | X9 => 25 | X10 => 26 | X11 => 27 | X12 => 28 | X13 => 29 | X14 => 30 | X15 => 31
    | FP0 => 32
    end.
  Lemma index_inj:
    forall r1 r2, index r1 = index r2 -> r1 = r2.
End IndexedMreg.

Definition is_stack_reg (r: mreg) : bool :=
  match r with FP0 => true | _ => false end.

Local Open Scope string_scope.

Definition register_names :=
  ("RAX", AX) :: ("RBX", BX) :: ("RCX", CX) :: ("RDX", DX) ::
  ("RSI", SI) :: ("RDI", DI) :: ("RBP", BP) ::
  ("EAX", AX) :: ("EBX", BX) :: ("ECX", CX) :: ("EDX", DX) ::
  ("ESI", SI) :: ("EDI", DI) :: ("EBP", BP) ::
  ("R8", R8) :: ("R9", R9) :: ("R10", R10) :: ("R11", R11) ::
  ("R12", R12) :: ("R13", R13) :: ("R14", R14) :: ("R15", R15) ::
  ("XMM0", X0) :: ("XMM1", X1) :: ("XMM2", X2) :: ("XMM3", X3) ::
  ("XMM4", X4) :: ("XMM5", X5) :: ("XMM6", X6) :: ("XMM7", X7) ::
  ("XMM8", X8) :: ("XMM9", X9) :: ("XMM10", X10) :: ("XMM11", X11) ::
  ("XMM12", X12) :: ("XMM13", X13) :: ("XMM14", X14) :: ("XMM15", X15) ::
  ("ST0", FP0) :: nil.

Definition register_by_name (s: string) : option mreg :=
  let fix assoc (l: list (string * mreg)) : option mreg :=
    match l with
    | nil => None
    | (s1, r1) :: l' => if string_dec s s1 then Some r1 else assoc l'
    end
  in assoc register_names.

Definition destroyed_by_op (op: operation): list mreg :=
  match op with
  | Ocast8signed | Ocast8unsigned => AX :: nil
  | Omulhs => AX :: DX :: nil
  | Omulhu => AX :: DX :: nil
  | Odiv => AX :: DX :: nil
  | Odivu => AX :: DX :: nil
  | Omod => AX :: DX :: nil
  | Omodu => AX :: DX :: nil
  | Oshrximm _ => CX :: nil
  | Omullhs => AX :: DX :: nil
  | Omullhu => AX :: DX :: nil
  | Odivl => AX :: DX :: nil
  | Odivlu => AX :: DX :: nil
  | Omodl => AX :: DX :: nil
  | Omodlu => AX :: DX :: nil
  | Oshrxlimm _ => DX :: nil
  | Ocmp _ => AX :: CX :: nil
  | _ => nil
  end.

Definition destroyed_by_load (chunk: memory_chunk) (addr: addressing): list mreg :=
  nil.

Definition destroyed_by_store (chunk: memory_chunk) (addr: addressing): list mreg :=
  match chunk with
  | Mint8signed | Mint8unsigned => if Archi.ptr64 then nil else AX :: CX :: nil
  | _ => nil
  end.

Definition destroyed_by_cond (cond: condition): list mreg :=
  nil.

Definition destroyed_by_jumptable: list mreg :=
  AX :: DX :: nil.

Fixpoint destroyed_by_clobber (cl: list string): list mreg :=
  match cl with
  | nil => nil
  | c1 :: cl =>
      match register_by_name c1 with
      | Some r => r :: destroyed_by_clobber cl
      | None   => destroyed_by_clobber cl
      end
  end.

Definition destroyed_by_builtin (ef: external_function): list mreg :=
  match ef with
  | EF_memcpy sz al =>
      if zle sz 32 then CX :: X7 :: nil else CX :: SI :: DI :: nil
  | EF_vstore (Mint8unsigned|Mint8signed) =>
      if Archi.ptr64 then nil else AX :: CX :: nil
  | EF_builtin name sg =>
      if string_dec name "__builtin_va_start" then AX :: nil
      else if string_dec name "__builtin_write16_reversed"
           || string_dec name "__builtin_write32_reversed"
      then CX :: DX :: nil
      else nil
  | EF_inline_asm txt sg clob => destroyed_by_clobber clob
  | _ => nil
  end.

Definition destroyed_at_function_entry: list mreg :=
  
  AX :: FP0 :: nil.

Definition destroyed_by_setstack (ty: typ): list mreg :=
  match ty with
  | Tfloat | Tsingle => FP0 :: nil
  | _ => nil
  end.

Definition destroyed_at_indirect_call: list mreg :=
  AX :: nil.

Definition temp_for_parent_frame: mreg :=
  AX.

Definition mregs_for_operation (op: operation): list (option mreg) * option mreg :=
  match op with
  | Omulhs => (Some AX :: None :: nil, Some DX)
  | Omulhu => (Some AX :: None :: nil, Some DX)
  | Odiv => (Some AX :: Some CX :: nil, Some AX)
  | Odivu => (Some AX :: Some CX :: nil, Some AX)
  | Omod => (Some AX :: Some CX :: nil, Some DX)
  | Omodu => (Some AX :: Some CX :: nil, Some DX)
  | Oshl => (None :: Some CX :: nil, None)
  | Oshr => (None :: Some CX :: nil, None)
  | Oshru => (None :: Some CX :: nil, None)
  | Oshrximm _ => (Some AX :: nil, Some AX)
  | Omullhs => (Some AX :: None :: nil, Some DX)
  | Omullhu => (Some AX :: None :: nil, Some DX)
  | Odivl => (Some AX :: Some CX :: nil, Some AX)
  | Odivlu => (Some AX :: Some CX :: nil, Some AX)
  | Omodl => (Some AX :: Some CX :: nil, Some DX)
  | Omodlu => (Some AX :: Some CX :: nil, Some DX)
  | Oshll => (None :: Some CX :: nil, None)
  | Oshrl => (None :: Some CX :: nil, None)
  | Oshrlu => (None :: Some CX :: nil, None)
  | Oshrxlimm _ => (Some AX :: nil, Some AX)
  | _ => (nil, None)
  end.

Definition mregs_for_builtin (ef: external_function): list (option mreg) * list (option mreg) :=
  match ef with
  | EF_memcpy sz al =>
     if zle sz 32 then (Some AX :: Some DX :: nil, nil) else (Some DI :: Some SI :: nil, nil)
  | EF_builtin name sg =>
     if string_dec name "__builtin_negl" then
       (Some DX :: Some AX :: nil, Some DX :: Some AX :: nil)
     else if string_dec name "__builtin_addl"
          || string_dec name "__builtin_subl" then
       (Some DX :: Some AX :: Some CX :: Some BX :: nil, Some DX :: Some AX :: nil)
     else if string_dec name "__builtin_mull" then
       (Some AX :: Some DX :: nil, Some DX :: Some AX :: nil)
     else if string_dec name "__builtin_va_start" then
       (Some DX :: nil, nil)
     else if (negb Archi.ptr64) && string_dec name "__builtin_bswap64" then
       (Some AX :: Some DX :: nil, Some DX :: Some AX :: nil)
     else
       (nil, nil)
  | _ => (nil, nil)
  end.

Global Opaque
    destroyed_by_op destroyed_by_load destroyed_by_store
    destroyed_by_cond destroyed_by_jumptable destroyed_by_builtin
    destroyed_by_setstack destroyed_at_function_entry temp_for_parent_frame
    mregs_for_operation mregs_for_builtin.

Definition two_address_op (op: operation) : bool :=
  match op with
  | Omove => false
  | Ointconst _ => false
  | Olongconst _ => false
  | Ofloatconst _ => false
  | Osingleconst _ => false
  | Oindirectsymbol _ => false
  | Ocast8signed => false
  | Ocast8unsigned => false
  | Ocast16signed => false
  | Ocast16unsigned => false
  | Oneg => true
  | Osub => true
  | Omul => true
  | Omulimm _ => true
  | Omulhs => false
  | Omulhu => false
  | Odiv => false
  | Odivu => false
  | Omod => false
  | Omodu => false
  | Oand => true
  | Oandimm _ => true
  | Oor => true
  | Oorimm _ => true
  | Oxor => true
  | Oxorimm _ => true
  | Onot => true
  | Oshl => true
  | Oshlimm _ => true
  | Oshr => true
  | Oshrimm _ => true
  | Oshrximm _ => false
  | Oshru => true
  | Oshruimm _ => true
  | Ororimm _ => true
  | Oshldimm _ => true
  | Olea addr => false
  | Omakelong => true
  | Olowlong => true
  | Ohighlong => true
  | Ocast32signed => false
  | Ocast32unsigned => false
  | Onegl => true
  | Oaddlimm _ => true
  | Osubl => true
  | Omull => true
  | Omullimm _ => true
  | Omullhs => false
  | Omullhu => false
  | Odivl => false
  | Odivlu => false
  | Omodl => false
  | Omodlu => false
  | Oandl => true
  | Oandlimm _ => true
  | Oorl => true
  | Oorlimm _ => true
  | Oxorl => true
  | Oxorlimm _ => true
  | Onotl => true
  | Oshll => true
  | Oshllimm _ => true
  | Oshrl => true
  | Oshrlimm _ => true
  | Oshrxlimm _ => false
  | Oshrlu => true
  | Oshrluimm _ => true
  | Ororlimm _ => true
  | Oleal addr => false
  | Onegf => true
  | Oabsf => true
  | Oaddf => true
  | Osubf => true
  | Omulf => true
  | Odivf => true
  | Onegfs => true
  | Oabsfs => true
  | Oaddfs => true
  | Osubfs => true
  | Omulfs => true
  | Odivfs => true
  | Osingleoffloat => false
  | Ofloatofsingle => false
  | Ointoffloat => false
  | Ofloatofint => false
  | Ointofsingle => false
  | Osingleofint => false
  | Olongoffloat => false
  | Ofloatoflong => false
  | Olongofsingle => false
  | Osingleoflong => false
  | Ocmp c => false
  end.

Definition builtin_constraints (ef: external_function) :
                                       list builtin_arg_constraint :=
  match ef with
  | EF_vload _ => OK_addressing :: nil
  | EF_vstore _ => OK_addressing :: OK_default :: nil
  | EF_memcpy _ _ => OK_addrstack :: OK_addrstack :: nil
  | EF_annot kind txt targs => map (fun _ => OK_all) targs
  | EF_debug kind txt targs => map (fun _ => OK_all) targs
  | _ => nil
  end. *)
(* Locations:
Require Import OrderedType.
Require Import Coqlib.
Require Import Maps.
Require Import Ordered.
Require Import AST.
Require Import Values.
Require Export Machregs.

Inductive slot: Type :=
  | Local
  | Incoming
  | Outgoing.

Lemma slot_eq: forall (p q: slot), {p = q} + {p <> q}.

Open Scope Z_scope.

Definition typesize (ty: typ) : Z :=
  match ty with
  | Tint => 1
  | Tlong => 2
  | Tfloat => 2
  | Tsingle => 1
  | Tany32 => 1
  | Tany64 => 2
  end.

Lemma typesize_pos:
  forall (ty: typ), typesize ty > 0.

Definition typealign (ty: typ) : Z :=
  match ty with
  | Tint => 1
  | Tlong => 2
  | Tfloat => 1
  | Tsingle => 1
  | Tany32 => 1
  | Tany64 => 1
  end.

Lemma typealign_pos:
  forall (ty: typ), typealign ty > 0.

Lemma typealign_typesize:
  forall (ty: typ), (typealign ty | typesize ty).

Inductive loc : Type :=
  | R (r: mreg)
  | S (sl: slot) (pos: Z) (ty: typ).

Module Loc.

  Definition type (l: loc) : typ :=
    match l with
    | R r => mreg_type r
    | S sl pos ty => ty
    end.

  Lemma eq: forall (p q: loc), {p = q} + {p <> q}.

  Definition diff (l1 l2: loc) : Prop :=
    match l1, l2 with
    | R r1, R r2 =>
        r1 <> r2
    | S s1 d1 t1, S s2 d2 t2 =>
        s1 <> s2 \/ d1 + typesize t1 <= d2 \/ d2 + typesize t2 <= d1
    | _, _ =>
        True
    end.

  Lemma same_not_diff:
    forall l, ~(diff l l).

  Lemma diff_not_eq:
    forall l1 l2, diff l1 l2 -> l1 <> l2.

  Lemma diff_sym:
    forall l1 l2, diff l1 l2 -> diff l2 l1.

  Definition diff_dec (l1 l2: loc) : { Loc.diff l1 l2 } + { ~Loc.diff l1 l2 }.

  Fixpoint notin (l: loc) (ll: list loc) {struct ll} : Prop :=
    match ll with
    | nil => True
    | l1 :: ls => diff l l1 /\ notin l ls
    end.

  Lemma notin_iff:
    forall l ll, notin l ll <-> (forall l', In l' ll -> Loc.diff l l').

  Lemma notin_not_in:
    forall l ll, notin l ll -> ~(In l ll).

  Lemma notin_dec (l: loc) (ll: list loc) : {notin l ll} + {~notin l ll}.

  Definition disjoint (l1 l2: list loc) : Prop :=
    forall x1 x2, In x1 l1 -> In x2 l2 -> diff x1 x2.

  Lemma disjoint_cons_left:
    forall a l1 l2,
    disjoint (a :: l1) l2 -> disjoint l1 l2.
  Lemma disjoint_cons_right:
    forall a l1 l2,
    disjoint l1 (a :: l2) -> disjoint l1 l2.

  Lemma disjoint_sym:
    forall l1 l2, disjoint l1 l2 -> disjoint l2 l1.

  Lemma in_notin_diff:
    forall l1 l2 ll, notin l1 ll -> In l2 ll -> diff l1 l2.

  Lemma notin_disjoint:
    forall l1 l2,
    (forall x, In x l1 -> notin x l2) -> disjoint l1 l2.

  Lemma disjoint_notin:
    forall l1 l2 x, disjoint l1 l2 -> In x l1 -> notin x l2.

  Inductive norepet : list loc -> Prop :=
  | norepet_nil:
      norepet nil
  | norepet_cons:
      forall hd tl, notin hd tl -> norepet tl -> norepet (hd :: tl).

  Lemma norepet_dec (ll: list loc) : {norepet ll} + {~norepet ll}.

  Definition no_overlap (l1 l2 : list loc) :=
   forall r, In r l1 -> forall s, In s l2 ->  r = s \/ Loc.diff r s.

End Loc.

Set Implicit Arguments.

Module Locmap.

  Definition t := loc -> val.

  Definition init (x: val) : t := fun (_: loc) => x.

  Definition get (l: loc) (m: t) : val := m l.

  Definition set (l: loc) (v: val) (m: t) : t :=
    fun (p: loc) =>
      if Loc.eq l p then
        match l with R r => v | S sl ofs ty => Val.load_result (chunk_of_type ty) v end
      else if Loc.diff_dec l p then
        m p
      else Vundef.

  Lemma gss: forall l v m,
    (set l v m) l =
    match l with R r => v | S sl ofs ty => Val.load_result (chunk_of_type ty) v end.

  Lemma gss_reg: forall r v m, (set (R r) v m) (R r) = v.

  Lemma gss_typed: forall l v m, Val.has_type v (Loc.type l) -> (set l v m) l = v.

  Lemma gso: forall l v m p, Loc.diff l p -> (set l v m) p = m p.

  Fixpoint undef (ll: list loc) (m: t) {struct ll} : t :=
    match ll with
    | nil => m
    | l1 :: ll' => undef ll' (set l1 Vundef m)
    end.

  Lemma guo: forall ll l m, Loc.notin l ll -> (undef ll m) l = m l.

  Lemma gus: forall ll l m, In l ll -> (undef ll m) l = Vundef.

  Definition getpair (p: rpair loc) (m: t) : val :=
    match p with
    | One l => m l
    | Twolong l1 l2 => Val.longofwords (m l1) (m l2)
    end.

  Definition setpair (p: rpair mreg) (v: val) (m: t) : t :=
    match p with
    | One r => set (R r) v m
    | Twolong hi lo => set (R lo) (Val.loword  v) (set (R hi) (Val.hiword v) m)
    end.

  Lemma getpair_exten:
    forall p ls1 ls2,
    (forall l, In l (regs_of_rpair p) -> ls2 l = ls1 l) ->
    getpair p ls2 = getpair p ls1.

  Lemma gpo:
    forall p v m l,
    forall_rpair (fun r => Loc.diff l (R r)) p -> setpair p v m l = m l.

  Fixpoint setres (res: builtin_res mreg) (v: val) (m: t) : t :=
    match res with
    | BR r => set (R r) v m
    | BR_none => m
    | BR_splitlong hi lo =>
        setres lo (Val.loword v) (setres hi (Val.hiword v) m)
    end.

End Locmap.

Module IndexedTyp <: INDEXED_TYPE.
  Definition t := typ.
  Definition index (x: t) :=
    match x with
    | Tany32 => 1%positive
    | Tint => 2%positive
    | Tsingle => 3%positive
    | Tany64 => 4%positive
    | Tfloat => 5%positive
    | Tlong => 6%positive
    end.
  Lemma index_inj: forall x y, index x = index y -> x = y.
  Definition eq := typ_eq.
End IndexedTyp.

Module OrderedTyp := OrderedIndexed(IndexedTyp).

Module IndexedSlot <: INDEXED_TYPE.
  Definition t := slot.
  Definition index (x: t) :=
    match x with Local => 1%positive | Incoming => 2%positive | Outgoing => 3%positive end.
  Lemma index_inj: forall x y, index x = index y -> x = y.
  Definition eq := slot_eq.
End IndexedSlot.

Module OrderedSlot := OrderedIndexed(IndexedSlot).

Module OrderedLoc <: OrderedType.
  Definition t := loc.
  Definition eq (x y: t) := x = y.
  Definition lt (x y: t) :=
    match x, y with
    | R r1, R r2 => Plt (IndexedMreg.index r1) (IndexedMreg.index r2)
    | R _, S _ _ _ => True
    | S _ _ _, R _ => False
    | S sl1 ofs1 ty1, S sl2 ofs2 ty2 =>
        OrderedSlot.lt sl1 sl2 \/ (sl1 = sl2 /\
        (ofs1 < ofs2 \/ (ofs1 = ofs2 /\ OrderedTyp.lt ty1 ty2)))
    end.
  Lemma eq_refl : forall x : t, eq x x.
  Proof (@eq_refl t).
  Lemma eq_sym : forall x y : t, eq x y -> eq y x.
  Proof (@eq_sym t).
  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
  Proof (@eq_trans t).
  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
  Definition compare : forall x y : t, Compare lt eq x y.
  Definition eq_dec := Loc.eq.

  Definition diff_low_bound (l: loc) : loc :=
    match l with
    | R mr => l
    | S sl ofs ty => S sl (ofs - 1) Tany64
    end.

  Definition diff_high_bound (l: loc) : loc :=
    match l with
    | R mr => l
    | S sl ofs ty => S sl (ofs + typesize ty - 1) Tlong
    end.

  Lemma outside_interval_diff:
    forall l l', lt l' (diff_low_bound l) \/ lt (diff_high_bound l) l' -> Loc.diff l l'.

  Lemma diff_outside_interval:
    forall l l', Loc.diff l l' -> lt l' (diff_low_bound l) \/ lt (diff_high_bound l) l'.

End OrderedLoc. *)



Definition is_callee_save (r: mreg) : bool :=

  match r with

  | AX | CX | DX => false

  | BX | BP => true

  | SI | DI => negb Archi.ptr64 

  | R8 | R9 | R10 | R11 => false

  | R12 | R13 | R14 | R15 => true

  | X0 | X1 | X2 | X3 | X4 | X5 | X6 | X7 => false

  | X8 | X9 | X10 | X11 | X12 | X13 | X14 | X15 => false

  | FP0 => false

  end.



Definition int_caller_save_regs :=

  if Archi.ptr64

  then AX :: CX :: DX :: SI :: DI :: R8 :: R9 :: R10 :: R11 :: nil

  else AX :: CX :: DX :: nil.



Definition float_caller_save_regs :=

  if Archi.ptr64

  then X0 :: X1 :: X2 :: X3 :: X4 :: X5 :: X6 :: X7 ::

       X8 :: X9 :: X10 :: X11 :: X12 :: X13 :: X14 :: X15 :: nil

  else X0 :: X1 :: X2 :: X3 :: X4 :: X5 :: X6 :: X7 :: nil.



Definition int_callee_save_regs :=

  if Archi.ptr64

  then BX :: BP :: R12 :: R13 :: R14 :: R15 :: nil

  else BX :: SI :: DI :: BP :: nil.



Definition float_callee_save_regs : list mreg := nil.



Definition destroyed_at_call :=

  List.filter (fun r => negb (is_callee_save r)) all_mregs.



Definition dummy_int_reg := AX.     

Definition dummy_float_reg := X0.   



Definition callee_save_type := mreg_type.

  

Definition is_float_reg (r: mreg) :=

  match r with

  | AX | BX | CX | DX | SI | DI | BP

  | R8 | R9 | R10 | R11 | R12 | R13 | R14 | R15 => false

  | X0 | X1 | X2 | X3 | X4 | X5 | X6 | X7

  | X8 | X9 | X10 | X11 | X12 | X13 | X14 | X15 | FP0 => true

  end.



Definition loc_result_32 (s: signature) : rpair mreg :=

  match s.(sig_res) with

  | None => One AX

  | Some (Tint | Tany32) => One AX

  | Some (Tfloat | Tsingle) => One FP0

  | Some Tany64 => One X0

  | Some Tlong => Twolong DX AX

  end.



Definition loc_result_64 (s: signature) : rpair mreg :=

  match s.(sig_res) with

  | None => One AX

  | Some (Tint | Tlong | Tany32 | Tany64) => One AX

  | Some (Tfloat | Tsingle) => One X0

  end.



Definition loc_result :=

  if Archi.ptr64 then loc_result_64 else loc_result_32.



Lemma loc_result_type:

  forall sig,

  subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.

Proof.

  intros. unfold proj_sig_res, loc_result, loc_result_32, loc_result_64, mreg_type;

  destruct Archi.ptr64; destruct (sig_res sig) as [[]|]; auto.

Qed.



Lemma loc_result_caller_save:

  forall (s: signature),

  forall_rpair (fun r => is_callee_save r = false) (loc_result s).

Proof.

  intros. unfold loc_result, loc_result_32, loc_result_64, is_callee_save;

  destruct Archi.ptr64; destruct (sig_res s) as [[]|]; simpl; auto.

Qed.



Lemma loc_result_pair:

  forall sg,

  match loc_result sg with

  | One _ => True

  | Twolong r1 r2 =>

       r1 <> r2 /\ sg.(sig_res) = Some Tlong

    /\ subtype Tint (mreg_type r1) = true /\ subtype Tint (mreg_type r2) = true

    /\ Archi.ptr64 = false

  end.

Proof.

  intros. 

  unfold loc_result, loc_result_32, loc_result_64, mreg_type;

  destruct Archi.ptr64; destruct (sig_res sg) as [[]|]; auto.

  split; auto. congruence.

Qed.



Lemma loc_result_exten:

  forall s1 s2, s1.(sig_res) = s2.(sig_res) -> loc_result s1 = loc_result s2.

Proof.

  intros. unfold loc_result, loc_result_32, loc_result_64.

  destruct Archi.ptr64; rewrite H; auto.

Qed.



Fixpoint loc_arguments_32

    (tyl: list typ) (ofs: Z) {struct tyl} : list (rpair loc) :=

  match tyl with

  | nil => nil

  | ty :: tys =>

      match ty with

      | Tlong => Twolong (S Outgoing (ofs + 1) Tint) (S Outgoing ofs Tint)

      | _     => One (S Outgoing ofs ty)

      end

      :: loc_arguments_32 tys (ofs + typesize ty)

  end.



Definition int_param_regs := DI :: SI :: DX :: CX :: R8 :: R9 :: nil.

Definition float_param_regs := X0 :: X1 :: X2 :: X3 :: X4 :: X5 :: X6 :: X7 :: nil.



Fixpoint loc_arguments_64

    (tyl: list typ) (ir fr ofs: Z) {struct tyl} : list (rpair loc) :=

  match tyl with

  | nil => nil

  | (Tint | Tlong | Tany32 | Tany64) as ty :: tys =>

      match list_nth_z int_param_regs ir with

      | None =>

          One (S Outgoing ofs ty) :: loc_arguments_64 tys ir fr (ofs + 2)

      | Some ireg =>

          One (R ireg) :: loc_arguments_64 tys (ir + 1) fr ofs

      end

  | (Tfloat | Tsingle) as ty :: tys =>

      match list_nth_z float_param_regs fr with

      | None =>

          One (S Outgoing ofs ty) :: loc_arguments_64 tys ir fr (ofs + 2)

      | Some freg =>

          One (R freg) :: loc_arguments_64 tys ir (fr + 1) ofs

      end

  end.



Definition loc_arguments (s: signature) : list (rpair loc) :=

  if Archi.ptr64

  then loc_arguments_64 s.(sig_args) 0 0 0

  else loc_arguments_32 s.(sig_args) 0.



Fixpoint size_arguments_32

    (tyl: list typ) (ofs: Z) {struct tyl} : Z :=

  match tyl with

  | nil => ofs

  | ty :: tys => size_arguments_32 tys (ofs + typesize ty)

  end.



Fixpoint size_arguments_64 (tyl: list typ) (ir fr ofs: Z) {struct tyl} : Z :=

  match tyl with

  | nil => ofs

  | (Tint | Tlong | Tany32 | Tany64) :: tys =>

      match list_nth_z int_param_regs ir with

      | None => size_arguments_64 tys ir fr (ofs + 2)

      | Some ireg => size_arguments_64 tys (ir + 1) fr ofs

      end

  | (Tfloat | Tsingle) :: tys =>

      match list_nth_z float_param_regs fr with

      | None => size_arguments_64 tys ir fr (ofs + 2)

      | Some freg => size_arguments_64 tys ir (fr + 1) ofs

      end

  end.



Definition size_arguments (s: signature) : Z :=

  if Archi.ptr64

  then size_arguments_64 s.(sig_args) 0 0 0

  else size_arguments_32 s.(sig_args) 0.



Definition loc_argument_acceptable (l: loc) : Prop :=

  match l with

  | R r => is_callee_save r = false

  | S Outgoing ofs ty => ofs >= 0 /\ (typealign ty | ofs)

  | _ => False

  end.



Definition loc_argument_32_charact (ofs: Z) (l: loc) : Prop :=

  match l with

  | S Outgoing ofs' ty => ofs' >= ofs /\ typealign ty = 1

  | _ => False

  end.



Definition loc_argument_64_charact (ofs: Z) (l: loc) : Prop :=

  match l with

  | R r => In r int_param_regs \/ In r float_param_regs

  | S Outgoing ofs' ty => ofs' >= ofs /\ (2 | ofs')

  | _ => False

  end.



Remark loc_arguments_32_charact:

  forall tyl ofs p,

  In p (loc_arguments_32 tyl ofs) -> forall_rpair (loc_argument_32_charact ofs) p.

Proof.

  assert (X: forall ofs1 ofs2 l, loc_argument_32_charact ofs2 l -> ofs1 <= ofs2 -> loc_argument_32_charact ofs1 l).

  { destruct l; simpl; intros; auto. destruct sl; auto. intuition omega. }

  induction tyl as [ | ty tyl]; simpl loc_arguments_32; intros.

- contradiction.

- destruct H.

+ destruct ty; subst p; simpl; omega.

+ apply IHtyl in H. generalize (typesize_pos ty); intros. destruct p; simpl in *.

* eapply X; eauto; omega.

* destruct H; split; eapply X; eauto; omega.

Qed.



Remark loc_arguments_64_charact:

  forall tyl ir fr ofs p,

  In p (loc_arguments_64 tyl ir fr ofs) -> (2 | ofs) -> forall_rpair (loc_argument_64_charact ofs) p.

Proof.

  assert (X: forall ofs1 ofs2 l, loc_argument_64_charact ofs2 l -> ofs1 <= ofs2 -> loc_argument_64_charact ofs1 l).

  { destruct l; simpl; intros; auto. destruct sl; auto. intuition omega. }

  assert (Y: forall ofs1 ofs2 p, forall_rpair (loc_argument_64_charact ofs2) p -> ofs1 <= ofs2 -> forall_rpair (loc_argument_64_charact ofs1) p).

  { destruct p; simpl; intuition eauto. }

  assert (Z: forall ofs, (2 | ofs) -> (2 | ofs + 2)).

  { intros. apply Z.divide_add_r; auto. apply Z.divide_refl. }

Opaque list_nth_z.

  induction tyl; simpl loc_arguments_64; intros.

  elim H.

  assert (A: forall ty, In p

      match list_nth_z int_param_regs ir with

      | Some ireg => One (R ireg) :: loc_arguments_64 tyl (ir + 1) fr ofs

      | None => One (S Outgoing ofs ty) :: loc_arguments_64 tyl ir fr (ofs + 2)

      end ->

      forall_rpair (loc_argument_64_charact ofs) p).

  { intros. destruct (list_nth_z int_param_regs ir) as [r|] eqn:E; destruct H1.

    subst. left. eapply list_nth_z_in; eauto.

    eapply IHtyl; eauto.

    subst. split. omega. assumption.

    eapply Y; eauto. omega. }

  assert (B: forall ty, In p

      match list_nth_z float_param_regs fr with

      | Some ireg => One (R ireg) :: loc_arguments_64 tyl ir (fr + 1) ofs

      | None => One (S Outgoing ofs ty) :: loc_arguments_64 tyl ir fr (ofs + 2)

      end ->

      forall_rpair (loc_argument_64_charact ofs) p).

  { intros. destruct (list_nth_z float_param_regs fr) as [r|] eqn:E; destruct H1.

    subst. right. eapply list_nth_z_in; eauto.

    eapply IHtyl; eauto.

    subst. split. omega. assumption.

    eapply Y; eauto. omega. }

  destruct a; eauto.

Qed.



Lemma loc_arguments_acceptable:

  forall (s: signature) (p: rpair loc),

  In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p.

Proof.

  unfold loc_arguments; intros. destruct Archi.ptr64 eqn:SF.

- 

  assert (A: forall r, In r int_param_regs -> is_callee_save r = false) by (unfold is_callee_save; rewrite SF; decide_goal).

  assert (B: forall r, In r float_param_regs -> is_callee_save r = false) by decide_goal.

  assert (X: forall l, loc_argument_64_charact 0 l -> loc_argument_acceptable l).

  { unfold loc_argument_64_charact, loc_argument_acceptable.

    destruct l as [r | [] ofs ty]; auto.  intros [C|C]; auto.

    intros [C D]. split; auto. apply Z.divide_trans with 2; auto.

    exists (2 / typealign ty); destruct ty; reflexivity.

  }

  exploit loc_arguments_64_charact; eauto using Z.divide_0_r.

  unfold forall_rpair; destruct p; intuition auto.

- 

  assert (X: forall l, loc_argument_32_charact 0 l -> loc_argument_acceptable l).

  { destruct l as [r | [] ofs ty]; simpl; intuition auto. rewrite H2; apply Z.divide_1_l. }

  exploit loc_arguments_32_charact; eauto.

  unfold forall_rpair; destruct p; intuition auto.

Qed.



Hint Resolve loc_arguments_acceptable: locs.



Remark size_arguments_32_above:

  forall tyl ofs0, ofs0 <= size_arguments_32 tyl ofs0.

Proof.

  induction tyl; simpl; intros.

  omega.

  apply Z.le_trans with (ofs0 + typesize a); auto.

  generalize (typesize_pos a); omega.

Qed.



Remark size_arguments_64_above:

  forall tyl ir fr ofs0,

  ofs0 <= size_arguments_64 tyl ir fr ofs0.

Proof.

  induction tyl; simpl; intros.

  omega.

  assert (A: ofs0 <=

    match list_nth_z int_param_regs ir with

    | Some _ => size_arguments_64 tyl (ir + 1) fr ofs0

    | None => size_arguments_64 tyl ir fr (ofs0 + 2)

    end).

  { destruct (list_nth_z int_param_regs ir); eauto.

    apply Z.le_trans with (ofs0 + 2); auto. omega. }

  assert (B: ofs0 <=

    match list_nth_z float_param_regs fr with

    | Some _ => size_arguments_64 tyl ir (fr + 1) ofs0

    | None => size_arguments_64 tyl ir fr (ofs0 + 2)

    end).

  { destruct (list_nth_z float_param_regs fr); eauto.

    apply Z.le_trans with (ofs0 + 2); auto. omega. }

  destruct a; auto.

Qed.



Lemma size_arguments_above:

  forall s, size_arguments s >= 0.

Proof.

  intros; unfold size_arguments. apply Z.le_ge.

  destruct Archi.ptr64; [apply size_arguments_64_above|apply size_arguments_32_above].

Qed.



Lemma loc_arguments_32_bounded:

  forall ofs ty tyl ofs0,

  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments_32 tyl ofs0)) ->

  ofs + typesize ty <= size_arguments_32 tyl ofs0.

Proof.

  induction tyl as [ | t l]; simpl; intros x IN.

- contradiction.

- rewrite in_app_iff in IN; destruct IN as [IN|IN].

+ apply Z.le_trans with (x + typesize t); [|apply size_arguments_32_above].

  Ltac decomp :=

  match goal with

  | [ H: _ \/ _ |- _ ] => destruct H; decomp

  | [ H: S _ _ _ = S _ _ _ |- _ ] => inv H

  | [ H: False |- _ ] => contradiction

  end.

  destruct t; simpl in IN; decomp; simpl; omega.

+ apply IHl; auto.

Qed.



Lemma loc_arguments_64_bounded:

  forall ofs ty tyl ir fr ofs0,

  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments_64 tyl ir fr ofs0)) ->

  ofs + typesize ty <= size_arguments_64 tyl ir fr ofs0.

Proof.

  induction tyl; simpl; intros.

  contradiction.

  assert (T: forall ty0, typesize ty0 <= 2).

  { destruct ty0; simpl; omega. }

  assert (A: forall ty0,

             In (S Outgoing ofs ty) (regs_of_rpairs

              match list_nth_z int_param_regs ir with

              | Some ireg =>

                  One (R ireg) :: loc_arguments_64 tyl (ir + 1) fr ofs0

              | None => One (S Outgoing ofs0 ty0) :: loc_arguments_64 tyl ir fr (ofs0 + 2)

              end) ->

             ofs + typesize ty <=

             match list_nth_z int_param_regs ir with

             | Some _ => size_arguments_64 tyl (ir + 1) fr ofs0

             | None => size_arguments_64 tyl ir fr (ofs0 + 2)

             end).

  { intros. destruct (list_nth_z int_param_regs ir); simpl in H0; destruct H0.

  - discriminate.

  - eapply IHtyl; eauto.

  - inv H0. apply Z.le_trans with (ofs + 2). specialize (T ty). omega. apply size_arguments_64_above.

  - eapply IHtyl; eauto. }

  assert (B: forall ty0,

             In (S Outgoing ofs ty) (regs_of_rpairs

              match list_nth_z float_param_regs fr with

              | Some ireg =>

                  One (R ireg) :: loc_arguments_64 tyl ir (fr + 1) ofs0

              | None => One (S Outgoing ofs0 ty0) :: loc_arguments_64 tyl ir fr (ofs0 + 2)

              end) ->

             ofs + typesize ty <=

             match list_nth_z float_param_regs fr with

             | Some _ => size_arguments_64 tyl ir (fr + 1) ofs0

             | None => size_arguments_64 tyl ir fr (ofs0 + 2)

             end).

  { intros. destruct (list_nth_z float_param_regs fr); simpl in H0; destruct H0.

  - discriminate.

  - eapply IHtyl; eauto.

  - inv H0. apply Z.le_trans with (ofs + 2). specialize (T ty). omega. apply size_arguments_64_above.

  - eapply IHtyl; eauto. }

  destruct a; eauto.

Qed.



Lemma loc_arguments_bounded:

  forall (s: signature) (ofs: Z) (ty: typ),

  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments s)) ->

  ofs + typesize ty <= size_arguments s.

Proof.

  unfold loc_arguments, size_arguments; intros.

  destruct Archi.ptr64; eauto using loc_arguments_32_bounded, loc_arguments_64_bounded.

Qed.



Lemma loc_arguments_main:

  loc_arguments signature_main = nil.

Proof.

  unfold loc_arguments; destruct Archi.ptr64; reflexivity.

Qed.

