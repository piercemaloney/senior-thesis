Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VFA.Maps.

Require Import VFA.SearchTree.

Require Import WandDemo.SearchTree_ext.

Require Import WandDemo.bst.

Require Import WandDemo.bst_lemmas.

Require Import WandDemo.VST_lemmas.

Require Import WandDemo.spec_bst.



Lemma if_trueb: forall {A: Type} b (a1 a2: A), b = true -> (if b then a1 else a2) = a1.

Proof. intros; subst; auto. Qed.



Lemma if_falseb: forall {A: Type} b (a1 a2: A), b = false -> (if b then a1 else a2) = a2.

Proof. intros; subst; auto. Qed.



Ltac simpl_compb := first [ rewrite if_trueb by (apply NPeano.Nat.ltb_lt; rewrite Nat2Z.inj_lt; omega)

                          | rewrite if_falseb by (apply NPeano.Nat.ltb_nlt; rewrite Nat2Z.inj_lt; omega)].



Lemma insert_concrete_to_abstract:

 forall {Espec: OracleKind} CMD p0 x v m0,

 (forall t0, 

   semax (func_tycontext f_insert Vprog Gprog [])

    (PROP ( )

     LOCAL (temp _p p0; temp _x (Vint (Int.repr (Z.of_nat x))); temp _value v)  

     SEP (treebox_rep t0 p0)) CMD

   (frame_ret_assert

     (function_body_ret_assert tvoid

        (PROP ( )  LOCAL ()  SEP (treebox_rep (insert x v t0) p0))) emp))  ->

 semax (func_tycontext f_insert Vprog Gprog [])

   (PROP ( )

    LOCAL (temp _p p0; temp _x (Vint (Int.repr (Z.of_nat x))); temp _value v)

    SEP (Mapbox_rep m0 p0)) CMD

  (frame_ret_assert

    (function_body_ret_assert tvoid

     (PROP ( )  LOCAL ()  SEP (Mapbox_rep (t_update m0 x v) p0))) emp).

Proof.

  intros.

  rewrite !Mapbox_rep_unfold.

  Intros t0.

  apply (semax_post'' (PROP () LOCAL () SEP (treebox_rep (insert x v t0) p0))); auto.

  Exists (insert x v t0).

  entailer!.

  split; [apply insert_relate | apply insert_SearchTree]; auto.

Qed.



Module insert_by_WandQFrame_Func_Hole.



Import PartialTreeboxRep_WandQFrame_Func_Hole.



Lemma body_insert: semax_body Vprog Gprog f_insert insert_spec.

Proof.

  start_function.

  apply insert_concrete_to_abstract; intros.

  abbreviate_semax.

  forward_loop (EX p: val, EX t: tree val, EX P: tree val -> tree val,

       PROP(P (insert x v t) = (insert x v t0))

       LOCAL(temp _p p; temp _x (Vint (Int.repr (Z.of_nat x)));   temp _value v)

       SEP(treebox_rep t p;  partial_treebox_rep P p0 p)).

  * 

    Exists p0 t0 (fun t: tree val => t). entailer!.

    apply emp_partial_treebox_rep_H.

  * 

    Intros p t P.

    rewrite treebox_rep_tree_rep at 1. Intros q.

    forward. 

    forward_if.

    + 

      subst q.

      forward_call (sizeof t_struct_tree).

        1: simpl; rep_omega.

      Intros q.

      rewrite memory_block_data_at_ by auto.

      forward. 

      forward. 

      forward. 

      forward. 

      assert_PROP (t = (@E _)) by entailer!.

      subst t. rewrite tree_rep_treebox_rep. normalize.

      forward. 

      forward. 

      entailer!.  clear - H1 H0 H.

      sep_apply (treebox_rep_leaf x q p v); auto.

      rewrite <- H1. apply treebox_rep_partial_treebox_rep.

    + 

      destruct t; rewrite tree_rep_treebox_rep.

      { normalize. }

      Intros. clear H2.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _left] q) t1 (fun t1 => P (T t1 k v0 t2)).

        entailer!.

       ** rewrite <- H1.

          simpl; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_left t2 k v0 q p); auto.

          apply partial_treebox_rep_partial_treebox_rep.

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _right] q) t2 (fun t2 => P (T t1 k v0 t2)).

        entailer!.

       ** rewrite <- H1.

          simpl; simpl_compb; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_right t1 k v0 q p); auto.

          cancel; apply partial_treebox_rep_partial_treebox_rep.

      - 

        assert (x=k) by omega.

        subst x. clear H H2 H5.

        forward. 

        forward. 

        entailer!.

        rewrite <- H1.

        simpl insert. simpl_compb; simpl_compb.

        sep_apply (treebox_rep_internal t1 k v t2 p q); auto.

        apply treebox_rep_partial_treebox_rep.

Qed.



End insert_by_WandQFrame_Func_Hole.



Module insert_by_WandFrame.



Import PartialTreeboxRep_WandFrame.



Lemma body_insert: semax_body Vprog Gprog f_insert insert_spec.

Proof.

  start_function.

  apply insert_concrete_to_abstract; intros.

  abbreviate_semax.

  forward_loop (EX p: val, EX t: tree val,

      PROP()

      LOCAL(temp _p p; temp _x (Vint (Int.repr (Z.of_nat x)));   temp _value v)

      SEP(treebox_rep t p;  (treebox_rep (insert x v t) p -* treebox_rep (insert x v t0) p0))).

  * 

    Exists p0 t0. entailer.

    apply ramify_PPQQ.

  * 

    Intros p t.

    rewrite treebox_rep_tree_rep at 1. Intros q.

    forward. 

    forward_if.

    + 

      subst q.

      forward_call (sizeof t_struct_tree).

        1: simpl; rep_omega.

      Intros q.

      rewrite memory_block_data_at_ by auto.

      forward. 

      simpl.

      forward. 

      forward. 

      forward. 

      assert_PROP (t = (@E _)).

        1: entailer!.

      subst t. rewrite tree_rep_treebox_rep. rewrite !prop_true_andp by auto.

      forward. 

      forward. 

      entailer!.

      sep_apply (treebox_rep_leaf x q p v); auto.

      apply treebox_rep_partial_treebox_rep.

    + 

      destruct t; rewrite tree_rep_treebox_rep.

      { normalize. }

      Intros. clear H1.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _left] q) t1.

        entailer!.

        simpl_compb.

        sep_apply (partial_treebox_rep_singleton_left (insert x v t1) t2 k v0 q p); auto.

        cancel; apply partial_treebox_rep_partial_treebox_rep.

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _right] q) t2.

        entailer!.

        simpl_compb; simpl_compb.

        sep_apply (partial_treebox_rep_singleton_right t1 (insert x v t2) k v0 q p); auto.

        cancel; apply partial_treebox_rep_partial_treebox_rep.

      - 

        assert (x=k) by omega.

        subst x. clear H H1 H4.

        forward. 

        forward. 

        entailer!.

        simpl_compb; simpl_compb.

        sep_apply (treebox_rep_internal t1 k v t2 p q); auto.

        apply treebox_rep_partial_treebox_rep.

Qed.



End insert_by_WandFrame.



Module insert_by_WandQFrame_Ind_Hole.



Import PartialTreeboxRep_WandQFrame_Ind_Hole.



Lemma body_insert: semax_body Vprog Gprog f_insert insert_spec.

Proof.

  start_function.

  apply insert_concrete_to_abstract; intros.

  abbreviate_semax.

  forward_loop (EX p: val, EX t: tree val, EX pt: partial_tree val,

      PROP(partial_tree_tree pt (insert x v t) = (insert x v t0))

      LOCAL(temp _p p; temp _x (Vint (Int.repr (Z.of_nat x)));   temp _value v)

      SEP(treebox_rep t p;  partial_treebox_rep pt p0 p)).

  * 

    Exists p0 t0 (@SearchTree_ext.H val). entailer!.

    apply emp_partial_treebox_rep_H.

  * 

    Intros p t pt.

    rewrite treebox_rep_tree_rep at 1. Intros q.

    forward. 

    forward_if.

    + 

      subst q.

      forward_call (sizeof t_struct_tree).

        1: simpl; rep_omega.

      Intros q.

      rewrite memory_block_data_at_ by auto.

      forward. 

      simpl.

      forward. 

      forward. 

      forward. 

      assert_PROP (t = (@E _)).

        1: entailer!.

      subst t. rewrite tree_rep_treebox_rep. rewrite !prop_true_andp by auto.

      forward. 

      forward. 

      entailer!.

      sep_apply (treebox_rep_leaf x q p v); auto.

      rewrite <- H1. apply treebox_rep_partial_treebox_rep.

    + 

      destruct t; rewrite tree_rep_treebox_rep.

      { normalize. }

      Intros. clear H2.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _left] q) t1 (partial_tree_partial_tree pt (SearchTree_ext.L SearchTree_ext.H k v0 t2)).

        entailer!.

       ** rewrite partial_tree_partial_tree_tree.

          rewrite <- H1.

          simpl; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_left t2 k v0 q p); auto.

          apply partial_treebox_rep_partial_treebox_rep.

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _right] q) t2 (partial_tree_partial_tree pt (SearchTree_ext.R t1 k v0 SearchTree_ext.H)).

        entailer!.

       ** rewrite partial_tree_partial_tree_tree.

          rewrite <- H1.

          simpl; simpl_compb; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_right t1 k v0 q p); auto.

          cancel; apply partial_treebox_rep_partial_treebox_rep.

      - 

        assert (x=k) by omega.

        subst x. clear H H2 H5.

        forward. 

        forward. 

        entailer!.

        rewrite <- H1.

        simpl insert.

        simpl_compb; simpl_compb.

        sep_apply (treebox_rep_internal t1 k v t2 p q); auto.

        apply treebox_rep_partial_treebox_rep.

Qed.



End insert_by_WandQFrame_Ind_Hole.



Module insert_by_Ind_Pred_Ind_Hole.



Import PartialTreeboxRep_Ind_Pred_Ind_Hole.



Opaque partial_treebox_rep.

Arguments partial_treebox_rep: simpl never.



Lemma body_insert: semax_body Vprog Gprog f_insert insert_spec.

Proof.

  start_function.

  apply insert_concrete_to_abstract; intros.

  abbreviate_semax.

  forward_loop (EX p: val, EX t: tree val, EX pt: partial_tree val,

      PROP(partial_tree_tree pt (insert x v t) = (insert x v t0))

      LOCAL(temp _p p; temp _x (Vint (Int.repr (Z.of_nat x)));   temp _value v)

      SEP(treebox_rep t p; partial_treebox_rep pt p0 p)).

  * 

    Exists p0 t0 (@SearchTree_ext.H val). entailer!.

    apply emp_partial_treebox_rep_H.

  * 

    Intros p t pt.

    rewrite treebox_rep_tree_rep at 1. Intros q.

    forward. 

    forward_if.

    + 

      subst q.

      forward_call (sizeof t_struct_tree).

        1: simpl; rep_omega.

      Intros q.

      rewrite memory_block_data_at_ by auto.

      forward. 

      simpl.

      forward. 

      forward. 

      forward. 

      assert_PROP (t = (@E _)).

        1: entailer!.

      subst t. rewrite tree_rep_treebox_rep. rewrite !prop_true_andp by auto.

      forward. 

      forward. 

      entailer!.

      sep_apply (treebox_rep_leaf x q p v); auto.

      rewrite <- H1. apply treebox_rep_partial_treebox_rep.

    + 

      destruct t; rewrite tree_rep_treebox_rep.

      { normalize. }

      Intros. clear H2.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _left] q) t1 (partial_tree_partial_tree pt (SearchTree_ext.L SearchTree_ext.H k v0 t2)).

        entailer!.

       ** rewrite partial_tree_partial_tree_tree.

          rewrite <- H1.

          simpl; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_left t2 k v0 q p); auto.

          apply partial_treebox_rep_partial_treebox_rep.

      - 

        forward. 

        Exists (field_address t_struct_tree [StructField _right] q) t2 (partial_tree_partial_tree pt (SearchTree_ext.R t1 k v0 SearchTree_ext.H)).

        entailer!.

       ** rewrite partial_tree_partial_tree_tree.

          rewrite <- H1.

          simpl; simpl_compb; simpl_compb; auto.

       ** sep_apply (partial_treebox_rep_singleton_right t1 k v0 q p); auto.

          cancel; apply partial_treebox_rep_partial_treebox_rep.

      - 

        assert (x=k) by omega.

        subst x. clear H H2 H5.

        forward. 

        forward. 

        entailer!.

        rewrite <- H1.

        simpl insert.

        simpl_compb; simpl_compb.

        sep_apply (treebox_rep_internal t1 k v t2 p q); auto.

        apply treebox_rep_partial_treebox_rep.

Qed.



End insert_by_Ind_Pred_Ind_Hole.



