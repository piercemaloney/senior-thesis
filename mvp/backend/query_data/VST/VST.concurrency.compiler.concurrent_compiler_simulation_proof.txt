Require Import Omega.



Require Import compcert.common.Globalenvs.
(* compcert.common.Globalenvs:
Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Senv.

Record t: Type := mksenv {
  
  find_symbol: ident -> option block;
  public_symbol: ident -> bool;
  invert_symbol: block -> option ident;
  block_is_volatile: block -> bool;
  nextblock: block;
  
  find_symbol_injective:
    forall id1 id2 b, find_symbol id1 = Some b -> find_symbol id2 = Some b -> id1 = id2;
  invert_find_symbol:
    forall id b, invert_symbol b = Some id -> find_symbol id = Some b;
  find_invert_symbol:
    forall id b, find_symbol id = Some b -> invert_symbol b = Some id;
  public_symbol_exists:
    forall id, public_symbol id = true -> exists b, find_symbol id = Some b;
  find_symbol_below:
    forall id b, find_symbol id = Some b -> Plt b nextblock;
  block_is_volatile_below:
    forall b, block_is_volatile b = true -> Plt b nextblock
}.

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Definition equiv (se1 se2: t) : Prop :=
     (forall id, find_symbol se2 id = find_symbol se1 id)
  /\ (forall id, public_symbol se2 id = public_symbol se1 id)
  /\ (forall b, block_is_volatile se2 b = block_is_volatile se1 b).

End Senv.

Module Genv.

Section GENV.

Variable F: Type.  
Variable V: Type.  

Record t: Type := mkgenv {
  genv_public: list ident;              
  genv_symb: PTree.t block;             
  genv_defs: PTree.t (globdef F V);     
  genv_next: block;                     
  genv_symb_range: forall id b, PTree.get id genv_symb = Some b -> Plt b genv_next;
  genv_defs_range: forall b g, PTree.get b genv_defs = Some g -> Plt b genv_next;
  genv_vars_inj: forall id1 id2 b,
    PTree.get id1 genv_symb = Some b -> PTree.get id2 genv_symb = Some b -> id1 = id2
}.

Definition find_symbol (ge: t) (id: ident) : option block :=
  PTree.get id ge.(genv_symb).

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Definition public_symbol (ge: t) (id: ident) : bool :=
  match find_symbol ge id with
  | None => false
  | Some _ => In_dec ident_eq id ge.(genv_public)
  end.

Definition find_def (ge: t) (b: block) : option (globdef F V) :=
  PTree.get b ge.(genv_defs).

Definition find_funct_ptr (ge: t) (b: block) : option F :=
  match find_def ge b with Some (Gfun f) => Some f | _ => None end.

Definition find_funct (ge: t) (v: val) : option F :=
  match v with
  | Vptr b ofs => if Ptrofs.eq_dec ofs Ptrofs.zero then find_funct_ptr ge b else None
  | _ => None
  end.

Definition invert_symbol (ge: t) (b: block) : option ident :=
  PTree.fold
    (fun res id b' => if eq_block b b' then Some id else res)
    ge.(genv_symb) None.

Definition find_var_info (ge: t) (b: block) : option (globvar V) :=
  match find_def ge b with Some (Gvar v) => Some v | _ => None end.

Definition block_is_volatile (ge: t) (b: block) : bool :=
  match find_var_info ge b with
  | None => false
  | Some gv => gv.(gvar_volatile)
  end.

Program Definition add_global (ge: t) (idg: ident * globdef F V) : t :=
  @mkgenv
    ge.(genv_public)

Definition add_globals (ge: t) (gl: list (ident * globdef F V)) : t :=
  List.fold_left add_global gl ge.

Lemma add_globals_app:
  forall gl2 gl1 ge,
  add_globals ge (gl1 ++ gl2) = add_globals (add_globals ge gl1) gl2.

Program Definition empty_genv (pub: list ident): t :=
  @mkgenv pub (PTree.empty _) (PTree.empty _) 1%positive _ _ _.

Definition globalenv (p: program F V) :=
  add_globals (empty_genv p.(prog_public)) p.(prog_defs).

Section GLOBALENV_PRINCIPLES.

Variable P: t -> Prop.

Lemma add_globals_preserves:
  forall gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  P ge -> P (add_globals ge gl).

Lemma add_globals_ensures:
  forall id g gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> P (add_globals ge gl).

Lemma add_globals_unique_preserves:
  forall id gl ge,
  (forall ge id1 g, P ge -> In (id1, g) gl -> id1 <> id -> P (add_global ge (id1, g))) ->
  ~In id (map fst gl) -> P ge -> P (add_globals ge gl).

Lemma add_globals_unique_ensures:
  forall gl1 id g gl2 ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  ~In id (map fst gl2) -> P (add_globals ge (gl1 ++ (id, g) :: gl2)).

Remark in_norepet_unique:
  forall id g (gl: list (ident * globdef F V)),
  In (id, g) gl -> list_norepet (map fst gl) ->
  exists gl1 gl2, gl = gl1 ++ (id, g) :: gl2 /\ ~In id (map fst gl2).

Lemma add_globals_norepet_ensures:
  forall id g gl ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> list_norepet (map fst gl) -> P (add_globals ge gl).

End GLOBALENV_PRINCIPLES.

Theorem public_symbol_exists:
  forall ge id, public_symbol ge id = true -> exists b, find_symbol ge id = Some b.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Theorem find_funct_inv:
  forall ge v f,
  find_funct ge v = Some f -> exists b, v = Vptr b Ptrofs.zero.

Theorem find_funct_find_funct_ptr:
  forall ge b,
  find_funct ge (Vptr b Ptrofs.zero) = find_funct_ptr ge b.

Theorem find_funct_ptr_iff:
  forall ge b f, find_funct_ptr ge b = Some f <-> find_def ge b = Some (Gfun f).

Theorem find_var_info_iff:
  forall ge b v, find_var_info ge b = Some v <-> find_def ge b = Some (Gvar v).

Theorem find_def_symbol:
  forall p id g,
  (prog_defmap p)!id = Some g <-> exists b, find_symbol (globalenv p) id = Some b /\ find_def (globalenv p) b = Some g.

Theorem find_symbol_exists:
  forall p id g,
  In (id, g) (prog_defs p) ->
  exists b, find_symbol (globalenv p) id = Some b.

Theorem find_symbol_inversion : forall p x b,
  find_symbol (globalenv p) x = Some b ->
  In x (prog_defs_names p).

Theorem find_def_inversion:
  forall p b g,
  find_def (globalenv p) b = Some g ->
  exists id, In (id, g) (prog_defs p).

Corollary find_funct_ptr_inversion:
  forall p b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Corollary find_funct_inversion:
  forall p v f,
  find_funct (globalenv p) v = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Theorem find_funct_ptr_prop:
  forall (P: F -> Prop) p b f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct_ptr (globalenv p) b = Some f ->
  P f.

Theorem find_funct_prop:
  forall (P: F -> Prop) p v f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct (globalenv p) v = Some f ->
  P f.

Theorem global_addresses_distinct:
  forall ge id1 id2 b1 b2,
  id1 <> id2 ->
  find_symbol ge id1 = Some b1 ->
  find_symbol ge id2 = Some b2 ->
  b1 <> b2.

Theorem invert_find_symbol:
  forall ge id b,
  invert_symbol ge b = Some id -> find_symbol ge id = Some b.

Theorem find_invert_symbol:
  forall ge id b,
  find_symbol ge id = Some b -> invert_symbol ge b = Some id.

Definition advance_next (gl: list (ident * globdef F V)) (x: positive) :=
  List.fold_left (fun n g => Pos.succ n) gl x.

Remark genv_next_add_globals:
  forall gl ge,
  genv_next (add_globals ge gl) = advance_next gl (genv_next ge).

Remark genv_public_add_globals:
  forall gl ge,
  genv_public (add_globals ge gl) = genv_public ge.

Theorem globalenv_public:
  forall p, genv_public (globalenv p) = prog_public p.

Theorem block_is_volatile_below:
  forall ge b, block_is_volatile ge b = true ->  Plt b ge.(genv_next).

Definition to_senv (ge: t) : Senv.t :=
 @Senv.mksenv
    (find_symbol ge)
    (public_symbol ge)
    (invert_symbol ge)
    (block_is_volatile ge)
    ge.(genv_next)
    ge.(genv_vars_inj)
    (invert_find_symbol ge)
    (find_invert_symbol ge)
    (public_symbol_exists ge)
    ge.(genv_symb_range)
    (block_is_volatile_below ge).

Section INITMEM.

Variable ge: t.

Definition store_init_data (m: mem) (b: block) (p: Z) (id: init_data) : option mem :=
  match id with
  | Init_int8 n => Mem.store Mint8unsigned m b p (Vint n)
  | Init_int16 n => Mem.store Mint16unsigned m b p (Vint n)
  | Init_int32 n => Mem.store Mint32 m b p (Vint n)
  | Init_int64 n => Mem.store Mint64 m b p (Vlong n)
  | Init_float32 n => Mem.store Mfloat32 m b p (Vsingle n)
  | Init_float64 n => Mem.store Mfloat64 m b p (Vfloat n)
  | Init_addrof symb ofs =>
      match find_symbol ge symb with
      | None => None
      | Some b' => Mem.store Mptr m b p (Vptr b' ofs)
      end
  | Init_space n => Some m
  end.

Fixpoint store_init_data_list (m: mem) (b: block) (p: Z) (idl: list init_data)
                              {struct idl}: option mem :=
  match idl with
  | nil => Some m
  | id :: idl' =>
      match store_init_data m b p id with
      | None => None
      | Some m' => store_init_data_list m' b (p + init_data_size id) idl'
      end
  end.

Definition perm_globvar (gv: globvar V) : permission :=
  if gv.(gvar_volatile) then Nonempty
  else if gv.(gvar_readonly) then Readable
  else Writable.

Definition alloc_global (m: mem) (idg: ident * globdef F V): option mem :=
  match idg with
  | (id, Gfun f) =>
      let (m1, b) := Mem.alloc m 0 1 in
      Mem.drop_perm m1 b 0 1 Nonempty
  | (id, Gvar v) =>
      let init := v.(gvar_init) in
      let sz := init_data_list_size init in
      let (m1, b) := Mem.alloc m 0 sz in
      match store_zeros m1 b 0 sz with
      | None => None
      | Some m2 =>
          match store_init_data_list m2 b 0 init with
          | None => None
          | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)
          end
      end
  end.

Fixpoint alloc_globals (m: mem) (gl: list (ident * globdef F V))
                       {struct gl} : option mem :=
  match gl with
  | nil => Some m
  | g :: gl' =>
      match alloc_global m g with
      | None => None
      | Some m' => alloc_globals m' gl'
      end
  end.

Lemma alloc_globals_app : forall gl1 gl2 m m1,
  alloc_globals m gl1 = Some m1 ->
  alloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2).

Remark store_zeros_nextblock:
  forall m b p n m', store_zeros m b p n = Some m' -> Mem.nextblock m' = Mem.nextblock m.

Remark store_init_data_list_nextblock:
  forall idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  Mem.nextblock m' = Mem.nextblock m.

Remark alloc_global_nextblock:
  forall g m m',
  alloc_global m g = Some m' ->
  Mem.nextblock m' = Pos.succ(Mem.nextblock m).

Remark alloc_globals_nextblock:
  forall gl m m',
  alloc_globals m gl = Some m' ->
  Mem.nextblock m' = advance_next gl (Mem.nextblock m).

Remark store_zeros_perm:
  forall k prm b' q m b p n m',
  store_zeros m b p n = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_perm:
  forall k prm b' q i b m p m',
  store_init_data m b p i = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_list_perm:
  forall k prm b' q idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark alloc_global_perm:
  forall k prm b' q idg m m',
  alloc_global m idg = Some m' ->
  Mem.valid_block m b' ->

Remark alloc_globals_perm:
  forall k prm b' q gl m m',
  alloc_globals m gl = Some m' ->
  Mem.valid_block m b' ->

Remark store_zeros_unchanged:
  forall (P: block -> Z -> Prop) m b p n m',
  store_zeros m b p n = Some m' ->
  (forall i, p <= i < p + n -> ~ P b i) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_unchanged:
  forall (P: block -> Z -> Prop) b i m p m',
  store_init_data m b p i = Some m' ->
  (forall ofs, p <= ofs < p + init_data_size i -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_list_unchanged:
  forall (P: block -> Z -> Prop) b il m p m',
  store_init_data_list m b p il = Some m' ->
  (forall ofs, p <= ofs -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Definition readbytes_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall p n,
  ofs <= p -> p + Z.of_nat n <= ofs + len ->
  Mem.loadbytes m b p (Z.of_nat n) = Some (list_repeat n (Byte Byte.zero)).

Lemma store_zeros_loadbytes:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  readbytes_as_zero m' b p n.

Definition bytes_of_init_data (i: init_data): list memval :=
  match i with
  | Init_int8 n => inj_bytes (encode_int 1%nat (Int.unsigned n))
  | Init_int16 n => inj_bytes (encode_int 2%nat (Int.unsigned n))
  | Init_int32 n => inj_bytes (encode_int 4%nat (Int.unsigned n))
  | Init_int64 n => inj_bytes (encode_int 8%nat (Int64.unsigned n))
  | Init_float32 n => inj_bytes (encode_int 4%nat (Int.unsigned (Float32.to_bits n)))
  | Init_float64 n => inj_bytes (encode_int 8%nat (Int64.unsigned (Float.to_bits n)))
  | Init_space n => list_repeat (Z.to_nat n) (Byte Byte.zero)
  | Init_addrof id ofs =>
      match find_symbol ge id with
      | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b ofs)
      | None   => list_repeat (if Archi.ptr64 then 8%nat else 4%nat) Undef
      end
  end.

Remark init_data_size_addrof:
  forall id ofs, init_data_size (Init_addrof id ofs) = size_chunk Mptr.

Lemma store_init_data_loadbytes:
  forall m b p i m',
  store_init_data m b p i = Some m' ->
  readbytes_as_zero m b p (init_data_size i) ->
  Mem.loadbytes m' b p (init_data_size i) = Some (bytes_of_init_data i).

Fixpoint bytes_of_init_data_list (il: list init_data): list memval :=
  match il with
  | nil => nil
  | i :: il => bytes_of_init_data i ++ bytes_of_init_data_list il
  end.

Lemma store_init_data_list_loadbytes:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  readbytes_as_zero m b p (init_data_list_size il) ->
  Mem.loadbytes m' b p (init_data_list_size il) = Some (bytes_of_init_data_list il).

Definition read_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall chunk p,
  ofs <= p -> p + size_chunk chunk <= ofs + len ->
  (align_chunk chunk | p) ->
  Mem.load chunk m b p =
  Some (match chunk with
        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 => Vint Int.zero
        | Mint64 => Vlong Int64.zero
        | Mfloat32 => Vsingle Float32.zero
        | Mfloat64 => Vfloat Float.zero
        | Many32 | Many64 => Vundef
        end).

Remark read_as_zero_unchanged:
  forall (P: block -> Z -> Prop) m b ofs len m',
  read_as_zero m b ofs len ->
  Mem.unchanged_on P m m' ->

Lemma store_zeros_read_as_zero:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  read_as_zero m' b p n.

Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | Init_int8 n :: il' =>
      Mem.load Mint8unsigned m b p = Some(Vint(Int.zero_ext 8 n))
      /\ load_store_init_data m b (p + 1) il'
  | Init_int16 n :: il' =>
      Mem.load Mint16unsigned m b p = Some(Vint(Int.zero_ext 16 n))
      /\ load_store_init_data m b (p + 2) il'
  | Init_int32 n :: il' =>
      Mem.load Mint32 m b p = Some(Vint n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_int64 n :: il' =>
      Mem.load Mint64 m b p = Some(Vlong n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_float32 n :: il' =>
      Mem.load Mfloat32 m b p = Some(Vsingle n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_float64 n :: il' =>
      Mem.load Mfloat64 m b p = Some(Vfloat n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_addrof symb ofs :: il' =>
      (exists b', find_symbol ge symb = Some b' /\ Mem.load Mptr m b p = Some(Vptr b' ofs))
      /\ load_store_init_data m b (p + size_chunk Mptr) il'
  | Init_space n :: il' =>
      read_as_zero m b p n
      /\ load_store_init_data m b (p + Z.max n 0) il'
  end.

Lemma store_init_data_list_charact:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  read_as_zero m b p (init_data_list_size il) ->
  load_store_init_data m' b p il.

Remark alloc_global_unchanged:
  forall (P: block -> Z -> Prop) m id g m',
  alloc_global m (id, g) = Some m' ->
  Mem.unchanged_on P m m'.

Remark alloc_globals_unchanged:
  forall (P: block -> Z -> Prop) gl m m',
  alloc_globals m gl = Some m' ->
  Mem.unchanged_on P m m'.

Remark load_store_init_data_invariant:
  forall m m' b,
  (forall chunk ofs, Mem.load chunk m' b ofs = Mem.load chunk m b ofs) ->

Definition globals_initialized (g: t) (m: mem) :=
  forall b gd,
  find_def g b = Some gd ->
  match gd with
  | Gfun f =>
         Mem.perm m b 0 Cur Nonempty
      /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty)
  | Gvar v =>
         Mem.range_perm m b 0 (init_data_list_size v.(gvar_init)) Cur (perm_globvar v)
      /\ (forall ofs k p, Mem.perm m b ofs k p ->
            0 <= ofs < init_data_list_size v.(gvar_init) /\ perm_order (perm_globvar v) p)
      /\ (v.(gvar_volatile) = false -> load_store_init_data m b 0 v.(gvar_init))
      /\ (v.(gvar_volatile) = false -> Mem.loadbytes m b 0 (init_data_list_size v.(gvar_init)) = Some (bytes_of_init_data_list v.(gvar_init)))
  end.

Lemma alloc_global_initialized:
  forall g m id gd m',
  genv_next g = Mem.nextblock m ->

Lemma alloc_globals_initialized:
  forall gl ge m m',
  alloc_globals m gl = Some m' ->
  genv_next ge = Mem.nextblock m ->

End INITMEM.

Definition init_mem (p: program F V) :=
  alloc_globals (globalenv p) Mem.empty p.(prog_defs).

Lemma init_mem_genv_next: forall p m,
  init_mem p = Some m ->
  genv_next (globalenv p) = Mem.nextblock m.

Theorem find_symbol_not_fresh:
  forall p id b m,
  init_mem p = Some m ->
  find_symbol (globalenv p) id = Some b -> Mem.valid_block m b.

Theorem find_def_not_fresh:
  forall p b g m,
  init_mem p = Some m ->
  find_def (globalenv p) b = Some g -> Mem.valid_block m b.

Theorem find_funct_ptr_not_fresh:
  forall p b f m,
  init_mem p = Some m ->
  find_funct_ptr (globalenv p) b = Some f -> Mem.valid_block m b.

Theorem find_var_info_not_fresh:
  forall p b gv m,
  init_mem p = Some m ->
  find_var_info (globalenv p) b = Some gv -> Mem.valid_block m b.

Lemma init_mem_characterization_gen:
  forall p m,
  init_mem p = Some m ->
  globals_initialized (globalenv p) (globalenv p) m.

Theorem init_mem_characterization:
  forall p b gv m,
  find_var_info (globalenv p) b = Some gv ->
  init_mem p = Some m ->
  Mem.range_perm m b 0 (init_data_list_size gv.(gvar_init)) Cur (perm_globvar gv)

Theorem init_mem_characterization_2:
  forall p b fd m,
  find_funct_ptr (globalenv p) b = Some fd ->
  init_mem p = Some m ->
  Mem.perm m b 0 Cur Nonempty

Section INITMEM_INJ.

Variable ge: t.
Variable thr: block.
Hypothesis symb_inject: forall id b, find_symbol ge id = Some b -> Plt b thr.

Lemma store_zeros_neutral:
  forall m b p n m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_neutral:
  forall m b p id m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_list_neutral:
  forall b idl m p m',
  Mem.inject_neutral thr m ->

Lemma alloc_global_neutral:
  forall idg m m',
  alloc_global ge m idg = Some m' ->
  Mem.inject_neutral thr m ->

Remark advance_next_le: forall gl x, Ple x (advance_next gl x).

Lemma alloc_globals_neutral:
  forall gl m m',
  alloc_globals ge m gl = Some m' ->
  Mem.inject_neutral thr m ->

End INITMEM_INJ.

Theorem initmem_inject:
  forall p m,
  init_mem p = Some m ->
  Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m.

Definition init_data_alignment (i: init_data) : Z :=
  match i with
  | Init_int8 n => 1
  | Init_int16 n => 2
  | Init_int32 n => 4
  | Init_int64 n => 8
  | Init_float32 n => 4
  | Init_float64 n => 4
  | Init_addrof symb ofs => if Archi.ptr64 then 8 else 4
  | Init_space n => 1
  end.

Fixpoint init_data_list_aligned (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | i1 :: il => (init_data_alignment i1 | p) /\ init_data_list_aligned (p + init_data_size i1) il
  end.

Section INITMEM_INVERSION.

Variable ge: t.

Lemma store_init_data_aligned:
  forall m b p i m',
  store_init_data ge m b p i = Some m' ->
  (init_data_alignment i | p).

Lemma store_init_data_list_aligned:
  forall b il m p m',
  store_init_data_list ge m b p il = Some m' ->
  init_data_list_aligned p il.

Lemma store_init_data_list_free_idents:
  forall b i o il m p m',
  store_init_data_list ge m b p il = Some m' ->
  In (Init_addrof i o) il ->
  exists b', find_symbol ge i = Some b'.

End INITMEM_INVERSION.

Theorem init_mem_inversion:
  forall p m id v,
  init_mem p = Some m ->
  In (id, Gvar v) p.(prog_defs) ->

Section INITMEM_EXISTS.

Variable ge: t.

Lemma store_zeros_exists:
  forall m b p n,
  Mem.range_perm m b p (p + n) Cur Writable ->

Lemma store_init_data_exists:
  forall m b p i,
  Mem.range_perm m b p (p + init_data_size i) Cur Writable ->

Lemma store_init_data_list_exists:
  forall b il m p,
  Mem.range_perm m b p (p + init_data_list_size il) Cur Writable ->

Lemma alloc_global_exists:
  forall m idg,
  match idg with
  | (id, Gfun f) => True
  | (id, Gvar v) =>
        init_data_list_aligned 0 v.(gvar_init)

End INITMEM_EXISTS.

Theorem init_mem_exists:
  forall p,
  (forall id v, In (id, Gvar v) (prog_defs p) ->
        init_data_list_aligned 0 v.(gvar_init)

End GENV.

Section MATCH_GENVS.

Context {A B V W: Type} (R: globdef A V -> globdef B W -> Prop).

Record match_genvs (ge1: t A V) (ge2: t B W): Prop := {
  mge_next:
    genv_next ge2 = genv_next ge1;
  mge_symb:
    forall id, PTree.get id (genv_symb ge2) = PTree.get id (genv_symb ge1);
  mge_defs:
    forall b, option_rel R (PTree.get b (genv_defs ge1)) (PTree.get b (genv_defs ge2))
}.

Lemma add_global_match:
  forall ge1 ge2 id g1 g2,
  match_genvs ge1 ge2 ->
  R g1 g2 ->
  match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).

Lemma add_globals_match:
  forall gl1 gl2,
  list_forall2 (fun idg1 idg2 => fst idg1 = fst idg2 /\ R (snd idg1) (snd idg2)) gl1 gl2 ->
  forall ge1 ge2, match_genvs ge1 ge2 ->
  match_genvs (add_globals ge1 gl1) (add_globals ge2 gl2).

End MATCH_GENVS.

Section MATCH_PROGRAMS.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.
Variable ctx: C.
Variable p: program F1 V1.
Variable tp: program F2 V2.
Hypothesis progmatch: match_program_gen match_fundef match_varinfo ctx p tp.

Lemma globalenvs_match:
  match_genvs (match_globdef match_fundef match_varinfo ctx) (globalenv p) (globalenv tp).

Theorem find_def_match_2:
  forall b, option_rel (match_globdef match_fundef match_varinfo ctx)
                       (find_def (globalenv p) b) (find_def (globalenv tp) b).
Proof (mge_defs globalenvs_match).

Theorem find_def_match:
  forall b g,
  find_def (globalenv p) b = Some g ->
  exists tg,
  find_def (globalenv tp) b = Some tg /\ match_globdef match_fundef match_varinfo ctx g tg.

Theorem find_funct_ptr_match:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists cunit tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_funct_match:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists cunit tf,
  find_funct (globalenv tp) v = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_var_info_match:
  forall b v,
  find_var_info (globalenv p) b = Some v ->
  exists tv,
  find_var_info (globalenv tp) b = Some tv /\ match_globvar match_varinfo v tv.

Theorem find_symbol_match:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_match:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Lemma store_init_data_list_match:
  forall idl m b ofs m',
  store_init_data_list (globalenv p) m b ofs idl = Some m' ->
  store_init_data_list (globalenv tp) m b ofs idl = Some m'.

Lemma alloc_globals_match:
  forall gl1 gl2, list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) gl1 gl2 ->
  forall m m',
  alloc_globals (globalenv p) m gl1 = Some m' ->
  alloc_globals (globalenv tp) m gl2 = Some m'.

Theorem init_mem_match:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End MATCH_PROGRAMS.

Section TRANSFORM_PARTIAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> res B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => transf f = OK tf) eq p tp.

Theorem find_funct_ptr_transf_partial:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ transf f = OK tf.

Theorem find_funct_transf_partial:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists tf,
  find_funct (globalenv tp) v = Some tf /\ transf f = OK tf.

Theorem find_symbol_transf_partial:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf_partial:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf_partial:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_PARTIAL.

Section TRANSFORM_TOTAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => tf = transf f) eq p tp.

Theorem find_funct_ptr_transf:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  find_funct_ptr (globalenv tp) b = Some (transf f).

Theorem find_funct_transf:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  find_funct (globalenv tp) v = Some (transf f).

Theorem find_symbol_transf:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_TOTAL.

End Genv.

Coercion Genv.to_senv: Genv.t >-> Senv.t. *)

Require Import compcert.common.ExposedSimulations.

Require Import compcert.common.Values.
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)

Require Import compcert.common.Memory.
(* compcert.common.Memory:
Require Import Zwf.
Require Import Axioms.
Require Import Coqlib.
Require Intv.
Require Import Maps.
Require Archi.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Export Memdata.
Require Export Memtype.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Local Notation "a # b" := (PMap.get b a) (at level 1).

Module Mem <: MEM.

Definition perm_order' (po: option permission) (p: permission) :=
  match po with
  | Some p' => perm_order p' p
  | None => False
 end.

Definition perm_order'' (po1 po2: option permission) :=
  match po1, po2 with
  | Some p1, Some p2 => perm_order p1 p2
  | _, None => True
  | None, Some _ => False
 end.

Record mem' : Type := mkmem {
  mem_contents: PMap.t (ZMap.t memval);  
  mem_access: PMap.t (Z -> perm_kind -> option permission);
                                         
  nextblock: block;
  access_max:
    forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
  nextblock_noaccess:
    forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
  contents_default:
    forall b, fst mem_contents#b = Undef
}.

Definition mem := mem'.

Lemma mkmem_ext:
 forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.

Definition valid_block (m: mem) (b: block) := Plt b (nextblock m).

Theorem valid_not_valid_diff:
  forall m b b', valid_block m b -> ~(valid_block m b') -> b <> b'.

Local Hint Resolve valid_not_valid_diff: mem.

Definition perm (m: mem) (b: block) (ofs: Z) (k: perm_kind) (p: permission) : Prop :=
   perm_order' (m.(mem_access)#b ofs k) p.

Theorem perm_implies:
  forall m b ofs k p1 p2, perm m b ofs k p1 -> perm_order p1 p2 -> perm m b ofs k p2.

Local Hint Resolve perm_implies: mem.

Theorem perm_cur_max:
  forall m b ofs p, perm m b ofs Cur p -> perm m b ofs Max p.

Theorem perm_cur:
  forall m b ofs k p, perm m b ofs Cur p -> perm m b ofs k p.

Theorem perm_max:
  forall m b ofs k p, perm m b ofs k p -> perm m b ofs Max p.

Local Hint Resolve perm_cur perm_max: mem.

Theorem perm_valid_block:
  forall m b ofs k p, perm m b ofs k p -> valid_block m b.

Local Hint Resolve perm_valid_block: mem.

Remark perm_order_dec:
  forall p1 p2, {perm_order p1 p2} + {~perm_order p1 p2}.

Remark perm_order'_dec:
  forall op p, {perm_order' op p} + {~perm_order' op p}.

Theorem perm_dec:
  forall m b ofs k p, {perm m b ofs k p} + {~ perm m b ofs k p}.

Definition range_perm (m: mem) (b: block) (lo hi: Z) (k: perm_kind) (p: permission) : Prop :=
  forall ofs, lo <= ofs < hi -> perm m b ofs k p.

Theorem range_perm_implies:
  forall m b lo hi k p1 p2,
  range_perm m b lo hi k p1 -> perm_order p1 p2 -> range_perm m b lo hi k p2.

Theorem range_perm_cur:
  forall m b lo hi k p,
  range_perm m b lo hi Cur p -> range_perm m b lo hi k p.

Theorem range_perm_max:
  forall m b lo hi k p,
  range_perm m b lo hi k p -> range_perm m b lo hi Max p.

Local Hint Resolve range_perm_implies range_perm_cur range_perm_max: mem.

Lemma range_perm_dec:
  forall m b lo hi k p, {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.

Definition valid_access (m: mem) (chunk: memory_chunk) (b: block) (ofs: Z) (p: permission): Prop :=
  range_perm m b ofs (ofs + size_chunk chunk) Cur p
  /\ (align_chunk chunk | ofs).

Theorem valid_access_implies:
  forall m chunk b ofs p1 p2,
  valid_access m chunk b ofs p1 -> perm_order p1 p2 ->
  valid_access m chunk b ofs p2.

Theorem valid_access_freeable_any:
  forall m chunk b ofs p,
  valid_access m chunk b ofs Freeable ->
  valid_access m chunk b ofs p.

Local Hint Resolve valid_access_implies: mem.

Theorem valid_access_valid_block:
  forall m chunk b ofs,
  valid_access m chunk b ofs Nonempty ->
  valid_block m b.

Local Hint Resolve valid_access_valid_block: mem.

Lemma valid_access_perm:
  forall m chunk b ofs k p,
  valid_access m chunk b ofs p ->
  perm m b ofs k p.

Lemma valid_access_compat:
  forall m chunk1 chunk2 b ofs p,
  size_chunk chunk1 = size_chunk chunk2 ->
  align_chunk chunk2 <= align_chunk chunk1 ->
  valid_access m chunk1 b ofs p->
  valid_access m chunk2 b ofs p.

Lemma valid_access_dec:
  forall m chunk b ofs p,
  {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.

Definition valid_pointer (m: mem) (b: block) (ofs: Z): bool :=
  perm_dec m b ofs Cur Nonempty.

Theorem valid_pointer_nonempty_perm:
  forall m b ofs,
  valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.

Theorem valid_pointer_valid_access:
  forall m b ofs,
  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.

Definition weak_valid_pointer (m: mem) (b: block) (ofs: Z) :=
  valid_pointer m b ofs || valid_pointer m b (ofs - 1).

Lemma weak_valid_pointer_spec:
  forall m b ofs,
  weak_valid_pointer m b ofs = true <->
    valid_pointer m b ofs = true \/ valid_pointer m b (ofs - 1) = true.
Lemma valid_pointer_implies:
  forall m b ofs,
  valid_pointer m b ofs = true -> weak_valid_pointer m b ofs = true.

Program Definition empty: mem :=
  mkmem (PMap.init (ZMap.init Undef))

Program Definition alloc (m: mem) (lo hi: Z) :=
  (mkmem (PMap.set m.(nextblock)

Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
  mkmem m.(mem_contents)

Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
  if range_perm_dec m b lo hi Cur Freeable
  then Some(unchecked_free m b lo hi)
  else None.

Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
  match l with
  | nil => Some m
  | (b, lo, hi) :: l' =>
      match free m b lo hi with
      | None => None
      | Some m' => free_list m' l'
      end
  end.

Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
  match n with
  | O => nil
  | S n' => ZMap.get p c :: getN n' (p + 1) c
  end.

Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
  if valid_access_dec m chunk b ofs Readable
  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
  else None.

Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
  match addr with
  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
  | _ => None
  end.

Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
  if range_perm_dec m b ofs (ofs + n) Cur Readable
  then Some (getN (nat_of_Z n) ofs (m.(mem_contents)#b))
  else None.

Fixpoint setN (vl: list memval) (p: Z) (c: ZMap.t memval) {struct vl}: ZMap.t memval :=
  match vl with
  | nil => c
  | v :: vl' => setN vl' (p + 1) (ZMap.set p v c)
  end.

Remark setN_other:
  forall vl c p q,
  (forall r, p <= r < p + Z.of_nat (length vl) -> r <> q) ->

Remark setN_outside:
  forall vl c p q,
  q < p \/ q >= p + Z.of_nat (length vl) ->

Remark getN_setN_same:
  forall vl p c,
  getN (length vl) p (setN vl p c) = vl.

Remark getN_exten:
  forall c1 c2 n p,
  (forall i, p <= i < p + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->

Remark getN_setN_disjoint:
  forall vl q c n p,
  Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (length vl)) ->

Remark getN_setN_outside:
  forall vl q c n p,
  p + Z.of_nat n <= q \/ q + Z.of_nat (length vl) <= p ->

Remark setN_default:
  forall vl q c, fst (setN vl q c) = fst c.

Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val): option mem :=
  if valid_access_dec m chunk b ofs Writable then
    Some (mkmem (PMap.set b

Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
  match addr with
  | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
  | _ => None
  end.

Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
  if range_perm_dec m b ofs (ofs + Z.of_nat (length bytes)) Cur Writable then

Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
  if range_perm_dec m b lo hi Cur Freeable then
    Some (mkmem m.(mem_contents)

Theorem nextblock_empty: nextblock empty = 1%positive.

Theorem perm_empty: forall b ofs k p, ~perm empty b ofs k p.

Theorem valid_access_empty: forall chunk b ofs p, ~valid_access empty chunk b ofs p.

Theorem valid_access_load:
  forall m chunk b ofs,
  valid_access m chunk b ofs Readable ->
  exists v, load chunk m b ofs = Some v.

Theorem load_valid_access:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  valid_access m chunk b ofs Readable.

Lemma load_result:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).

Local Hint Resolve load_valid_access valid_access_load: mem.

Theorem load_type:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  Val.has_type v (type_of_chunk chunk).

Theorem load_cast:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v

Theorem load_int8_signed_unsigned:
  forall m b ofs,
  load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).

Theorem load_int16_signed_unsigned:
  forall m b ofs,
  load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).

Theorem range_perm_loadbytes:
  forall m b ofs len,
  range_perm m b ofs (ofs + len) Cur Readable ->
  exists bytes, loadbytes m b ofs len = Some bytes.

Theorem loadbytes_range_perm:
  forall m b ofs len bytes,
  loadbytes m b ofs len = Some bytes ->
  range_perm m b ofs (ofs + len) Cur Readable.

Theorem loadbytes_load:
  forall chunk m b ofs bytes,
  loadbytes m b ofs (size_chunk chunk) = Some bytes ->
  (align_chunk chunk | ofs) ->
  load chunk m b ofs = Some(decode_val chunk bytes).

Theorem load_loadbytes:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
             /\ v = decode_val chunk bytes.

Lemma getN_length:
  forall c n p, length (getN n p c) = n.

Theorem loadbytes_length:
  forall m b ofs n bytes,
  loadbytes m b ofs n = Some bytes ->
  length bytes = nat_of_Z n.

Theorem loadbytes_empty:
  forall m b ofs n,
  n <= 0 -> loadbytes m b ofs n = Some nil.

Lemma getN_concat:
  forall c n1 n2 p,
  getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z.of_nat n1) c.

Theorem loadbytes_concat:
  forall m b ofs n1 n2 bytes1 bytes2,
  loadbytes m b ofs n1 = Some bytes1 ->
  loadbytes m b (ofs + n1) n2 = Some bytes2 ->
  n1 >= 0 -> n2 >= 0 ->
  loadbytes m b ofs (n1 + n2) = Some(bytes1 ++ bytes2).

Theorem loadbytes_split:
  forall m b ofs n1 n2 bytes,
  loadbytes m b ofs (n1 + n2) = Some bytes ->
  n1 >= 0 -> n2 >= 0 ->
  exists bytes1, exists bytes2,
     loadbytes m b ofs n1 = Some bytes1
  /\ loadbytes m b (ofs + n1) n2 = Some bytes2
  /\ bytes = bytes1 ++ bytes2.

Theorem load_rep:
 forall ch m1 m2 b ofs v1 v2,
  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->

Theorem load_int64_split:
  forall m b ofs v,
  load Mint64 m b ofs = Some v -> Archi.ptr64 = false ->

Lemma addressing_int64_split:
  forall i,
  Archi.ptr64 = false ->

Theorem loadv_int64_split:
  forall m a v,
  loadv Mint64 m a = Some v -> Archi.ptr64 = false ->

Theorem valid_access_store:
  forall m1 chunk b ofs v,
  valid_access m1 chunk b ofs Writable ->
  { m2: mem | store chunk m1 b ofs v = Some m2 }.

Local Hint Resolve valid_access_store: mem.

Section STORE.
Variable chunk: memory_chunk.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable v: val.
Variable m2: mem.
Hypothesis STORE: store chunk m1 b ofs v = Some m2.

Lemma store_access: mem_access m2 = mem_access m1.

Lemma store_mem_contents:
  mem_contents m2 = PMap.set b (setN (encode_val chunk v) ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_store_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_store_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_store_1 perm_store_2: mem.

Theorem nextblock_store:
  nextblock m2 = nextblock m1.

Theorem store_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem store_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.

Theorem store_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem store_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Theorem store_valid_access_3:
  valid_access m1 chunk b ofs Writable.

Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.

Theorem load_store_similar:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  exists v', load chunk' m2 b ofs = Some v' /\ decode_encode_val v chunk chunk' v'.

Theorem load_store_similar_2:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  type_of_chunk chunk' = type_of_chunk chunk ->
  load chunk' m2 b ofs = Some (Val.load_result chunk' v).

Theorem load_store_same:
  load chunk m2 b ofs = Some (Val.load_result chunk v).

Theorem load_store_other:
  forall chunk' b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk' <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.

Theorem loadbytes_store_same:
  loadbytes m2 b ofs (size_chunk chunk) = Some(encode_val chunk v).

Theorem loadbytes_store_other:
  forall b' ofs' n,
  b' <> b
  \/ n <= 0
  \/ ofs' + n <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.

Lemma setN_in:
  forall vl p q c,
  p <= q < p + Z.of_nat (length vl) ->

Lemma getN_in:
  forall c q n p,
  p <= q < p + Z.of_nat n ->

End STORE.

Local Hint Resolve perm_store_1 perm_store_2: mem.
Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.
Local Hint Resolve store_valid_access_1 store_valid_access_2
             store_valid_access_3: mem.

Lemma load_store_overlap:
  forall chunk m1 b ofs v m2 chunk' ofs' v',
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b ofs' = Some v' ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  exists mv1 mvl mv1' mvl',
      shape_encoding chunk v (mv1 :: mvl)
  /\  shape_decoding chunk' (mv1' :: mvl') v'
  /\  (   (ofs' = ofs /\ mv1' = mv1)
       \/ (ofs' > ofs /\ In mv1' mvl)
       \/ (ofs' < ofs /\ In mv1 mvl')).

Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
  match chunk1, chunk2 with
  | (Mint32 | Many32), (Mint32 | Many32) => True
  | (Mint64 | Many64), (Mint64 | Many64) => True
  | _, _ => False
  end.

Lemma compat_pointer_chunks_true:
  forall chunk1 chunk2,
  (chunk1 = Mint32 \/ chunk1 = Many32 \/ chunk1 = Mint64 \/ chunk1 = Many64) ->
  (chunk2 = Mint32 \/ chunk2 = Many32 \/ chunk2 = Mint64 \/ chunk2 = Many64) ->
  quantity_chunk chunk1 = quantity_chunk chunk2 ->
  compat_pointer_chunks chunk1 chunk2.

Theorem load_pointer_store:
  forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b' ofs' = Some(Vptr v_b v_o) ->
  (v = Vptr v_b v_o /\ compat_pointer_chunks chunk chunk' /\ b' = b /\ ofs' = ofs)
  \/ (b' <> b \/ ofs' + size_chunk chunk' <= ofs \/ ofs + size_chunk chunk <= ofs').

Theorem load_store_pointer_overlap:
  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs' = Some v ->
  ofs' <> ofs ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  v = Vundef.

Theorem load_store_pointer_mismatch:
  forall chunk m1 b ofs v_b v_o m2 chunk' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs = Some v ->
  ~compat_pointer_chunks chunk chunk' ->
  v = Vundef.

Lemma store_similar_chunks:
  forall chunk1 chunk2 v1 v2 m b ofs,
  encode_val chunk1 v1 = encode_val chunk2 v2 ->
  align_chunk chunk1 = align_chunk chunk2 ->
  store chunk1 m b ofs v1 = store chunk2 m b ofs v2.

Theorem store_signed_unsigned_8:
  forall m b ofs v,
  store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.

Theorem store_signed_unsigned_16:
  forall m b ofs v,
  store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.

Theorem store_int8_zero_ext:
  forall m b ofs n,
  store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =

Theorem store_int8_sign_ext:
  forall m b ofs n,
  store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =

Theorem store_int16_zero_ext:
  forall m b ofs n,
  store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =

Theorem store_int16_sign_ext:
  forall m b ofs n,
  store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =

Theorem range_perm_storebytes:
  forall m1 b ofs bytes,
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable ->

Theorem storebytes_store:
  forall m1 b ofs chunk v m2,
  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
  (align_chunk chunk | ofs) ->
  store chunk m1 b ofs v = Some m2.

Theorem store_storebytes:
  forall m1 b ofs chunk v m2,
  store chunk m1 b ofs v = Some m2 ->
  storebytes m1 b ofs (encode_val chunk v) = Some m2.

Section STOREBYTES.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable bytes: list memval.
Variable m2: mem.
Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.

Lemma storebytes_access: mem_access m2 = mem_access m1.

Lemma storebytes_mem_contents:
   mem_contents m2 = PMap.set b (setN bytes ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_storebytes_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_storebytes_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.

Theorem storebytes_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem storebytes_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Local Hint Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.

Theorem nextblock_storebytes:
  nextblock m2 = nextblock m1.

Theorem storebytes_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem storebytes_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.

Theorem storebytes_range_perm:
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable.

Theorem loadbytes_storebytes_same:
  loadbytes m2 b ofs (Z.of_nat (length bytes)) = Some bytes.

Theorem loadbytes_storebytes_disjoint:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b \/ Intv.disjoint (ofs', ofs' + len) (ofs, ofs + Z.of_nat (length bytes)) ->

Theorem loadbytes_storebytes_other:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b
  \/ ofs' + len <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

Theorem load_storebytes_other:
  forall chunk b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

End STOREBYTES.

Lemma setN_concat:
  forall bytes1 bytes2 ofs c,
  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z.of_nat (length bytes1)) (setN bytes1 ofs c).

Theorem storebytes_concat:
  forall m b ofs bytes1 m1 bytes2 m2,
  storebytes m b ofs bytes1 = Some m1 ->
  storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2 ->

Theorem storebytes_split:
  forall m b ofs bytes1 bytes2 m2,
  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
  exists m1,
     storebytes m b ofs bytes1 = Some m1
  /\ storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2.

Theorem store_int64_split:
  forall m b ofs v m',
  store Mint64 m b ofs v = Some m' -> Archi.ptr64 = false ->

Theorem storev_int64_split:
  forall m a v m',
  storev Mint64 m a v = Some m' -> Archi.ptr64 = false ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: block.
Hypothesis ALLOC: alloc m1 lo hi = (m2, b).

Theorem nextblock_alloc:
  nextblock m2 = Pos.succ (nextblock m1).

Theorem alloc_result:
  b = nextblock m1.

Theorem valid_block_alloc:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem fresh_block_alloc:
  ~(valid_block m1 b).

Theorem valid_new_block:
  valid_block m2 b.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.

Theorem valid_block_alloc_inv:
  forall b', valid_block m2 b' -> b' = b \/ valid_block m1 b'.

Theorem perm_alloc_1:
  forall b' ofs k p, perm m1 b' ofs k p -> perm m2 b' ofs k p.

Theorem perm_alloc_2:
  forall ofs k, lo <= ofs < hi -> perm m2 b ofs k Freeable.

Theorem perm_alloc_inv:
  forall b' ofs k p,
  perm m2 b' ofs k p ->
  if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p.

Theorem perm_alloc_3:
  forall ofs k p, perm m2 b ofs k p -> lo <= ofs < hi.

Theorem perm_alloc_4:
  forall b' ofs k p, perm m2 b' ofs k p -> b' <> b -> perm m1 b' ofs k p.

Local Hint Resolve perm_alloc_1 perm_alloc_2 perm_alloc_3 perm_alloc_4: mem.

Theorem valid_access_alloc_other:
  forall chunk b' ofs p,
  valid_access m1 chunk b' ofs p ->
  valid_access m2 chunk b' ofs p.

Theorem valid_access_alloc_same:
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  valid_access m2 chunk b ofs Freeable.

Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem valid_access_alloc_inv:
  forall chunk b' ofs p,
  valid_access m2 chunk b' ofs p ->
  if eq_block b' b
  then lo <= ofs /\ ofs + size_chunk chunk <= hi /\ (align_chunk chunk | ofs)
  else valid_access m1 chunk b' ofs p.

Theorem load_alloc_unchanged:
  forall chunk b' ofs,
  valid_block m1 b' ->
  load chunk m2 b' ofs = load chunk m1 b' ofs.

Theorem load_alloc_other:
  forall chunk b' ofs v,
  load chunk m1 b' ofs = Some v ->
  load chunk m2 b' ofs = Some v.

Theorem load_alloc_same:
  forall chunk ofs v,
  load chunk m2 b ofs = Some v ->
  v = Vundef.

Theorem load_alloc_same':
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  load chunk m2 b ofs = Some Vundef.

Theorem loadbytes_alloc_unchanged:
  forall b' ofs n,
  valid_block m1 b' ->
  loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.

Theorem loadbytes_alloc_same:
  forall n ofs bytes byte,
  loadbytes m2 b ofs n = Some bytes ->
  In byte bytes -> byte = Undef.

End ALLOC.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem range_perm_free:
  forall m1 b lo hi,
  range_perm m1 b lo hi Cur Freeable ->
  { m2: mem | free m1 b lo hi = Some m2 }.

Section FREE.

Variable m1: mem.
Variable bf: block.
Variables lo hi: Z.
Variable m2: mem.
Hypothesis FREE: free m1 bf lo hi = Some m2.

Theorem free_range_perm:
  range_perm m1 bf lo hi Cur Freeable.

Lemma free_result:
  m2 = unchecked_free m1 bf lo hi.

Theorem nextblock_free:
  nextblock m2 = nextblock m1.

Theorem valid_block_free_1:
  forall b, valid_block m1 b -> valid_block m2 b.

Theorem valid_block_free_2:
  forall b, valid_block m2 b -> valid_block m1 b.

Local Hint Resolve valid_block_free_1 valid_block_free_2: mem.

Theorem perm_free_1:
  forall b ofs k p,
  b <> bf \/ ofs < lo \/ hi <= ofs ->
  perm m1 b ofs k p ->
  perm m2 b ofs k p.

Theorem perm_free_2:
  forall ofs k p, lo <= ofs < hi -> ~ perm m2 bf ofs k p.

Theorem perm_free_3:
  forall b ofs k p,
  perm m2 b ofs k p -> perm m1 b ofs k p.

Theorem perm_free_inv:
  forall b ofs k p,
  perm m1 b ofs k p ->
  (b = bf /\ lo <= ofs < hi) \/ perm m2 b ofs k p.

Theorem valid_access_free_1:
  forall chunk b ofs p,
  valid_access m1 chunk b ofs p ->
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  valid_access m2 chunk b ofs p.

Theorem valid_access_free_2:
  forall chunk ofs p,
  lo < hi -> ofs + size_chunk chunk > lo -> ofs < hi ->
  ~(valid_access m2 chunk bf ofs p).

Theorem valid_access_free_inv_1:
  forall chunk b ofs p,
  valid_access m2 chunk b ofs p ->
  valid_access m1 chunk b ofs p.

Theorem valid_access_free_inv_2:
  forall chunk ofs p,
  valid_access m2 chunk bf ofs p ->
  lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs.

Theorem load_free:
  forall chunk b ofs,
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  load chunk m2 b ofs = load chunk m1 b ofs.

Theorem load_free_2:
  forall chunk b ofs v,
  load chunk m2 b ofs = Some v -> load chunk m1 b ofs = Some v.

Theorem loadbytes_free:
  forall b ofs n,
  b <> bf \/ lo >= hi \/ ofs + n <= lo \/ hi <= ofs ->
  loadbytes m2 b ofs n = loadbytes m1 b ofs n.

Theorem loadbytes_free_2:
  forall b ofs n bytes,
  loadbytes m2 b ofs n = Some bytes -> loadbytes m1 b ofs n = Some bytes.

End FREE.

Local Hint Resolve valid_block_free_1 valid_block_free_2
             perm_free_1 perm_free_2 perm_free_3
             valid_access_free_1 valid_access_free_inv_1: mem.

Theorem range_perm_drop_1:
  forall m b lo hi p m', drop_perm m b lo hi p = Some m' -> range_perm m b lo hi Cur Freeable.

Theorem range_perm_drop_2:
  forall m b lo hi p,
  range_perm m b lo hi Cur Freeable -> {m' | drop_perm m b lo hi p = Some m' }.

Section DROP.

Variable m: mem.
Variable b: block.
Variable lo hi: Z.
Variable p: permission.
Variable m': mem.
Hypothesis DROP: drop_perm m b lo hi p = Some m'.

Theorem nextblock_drop:
  nextblock m' = nextblock m.

Theorem drop_perm_valid_block_1:
  forall b', valid_block m b' -> valid_block m' b'.

Theorem drop_perm_valid_block_2:
  forall b', valid_block m' b' -> valid_block m b'.

Theorem perm_drop_1:
  forall ofs k, lo <= ofs < hi -> perm m' b ofs k p.

Theorem perm_drop_2:
  forall ofs k p', lo <= ofs < hi -> perm m' b ofs k p' -> perm_order p p'.

Theorem perm_drop_3:
  forall b' ofs k p', b' <> b \/ ofs < lo \/ hi <= ofs -> perm m b' ofs k p' -> perm m' b' ofs k p'.

Theorem perm_drop_4:
  forall b' ofs k p', perm m' b' ofs k p' -> perm m b' ofs k p'.

Lemma valid_access_drop_1:
  forall chunk b' ofs p',
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p p' ->
  valid_access m chunk b' ofs p' -> valid_access m' chunk b' ofs p'.

Lemma valid_access_drop_2:
  forall chunk b' ofs p',
  valid_access m' chunk b' ofs p' -> valid_access m chunk b' ofs p'.

Theorem load_drop:
  forall chunk b' ofs,
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p Readable ->
  load chunk m' b' ofs = load chunk m b' ofs.

Theorem loadbytes_drop:
  forall b' ofs n,
  b' <> b \/ ofs + n <= lo \/ hi <= ofs \/ perm_order p Readable ->
  loadbytes m' b' ofs n = loadbytes m b' ofs n.

End DROP.

Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
  mk_mem_inj {
    mi_perm:
      forall b1 b2 delta ofs k p,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs k p ->
      perm m2 b2 (ofs + delta) k p;
    mi_align:
      forall b1 b2 delta chunk ofs p,
      f b1 = Some(b2, delta) ->
      range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->
      (align_chunk chunk | delta);
    mi_memval:
      forall b1 ofs b2 delta,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs Cur Readable ->
      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
  }.

Lemma perm_inj:
  forall f m1 m2 b1 ofs k p b2 delta,
  mem_inj f m1 m2 ->
  perm m1 b1 ofs k p ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p.

Lemma range_perm_inj:
  forall f m1 m2 b1 lo hi k p b2 delta,
  mem_inj f m1 m2 ->
  range_perm m1 b1 lo hi k p ->
  f b1 = Some(b2, delta) ->
  range_perm m2 b2 (lo + delta) (hi + delta) k p.

Lemma valid_access_inj:
  forall f m1 m2 b1 b2 delta chunk ofs p,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Lemma getN_inj:
  forall f m1 m2 b1 b2 delta,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  forall n ofs,
  range_perm m1 b1 ofs (ofs + Z.of_nat n) Cur Readable ->

Lemma load_inj:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  mem_inj f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Lemma loadbytes_inj:
  forall f m1 m2 len b1 ofs b2 delta bytes1,
  mem_inj f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Lemma setN_inj:
  forall (access: Z -> Prop) delta f vl1 vl2,
  list_forall2 (memval_inject f) vl1 vl2 ->
  forall p c1 c2,
  (forall q, access q -> memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2)) ->

Definition meminj_no_overlap (f: meminj) (m: mem) : Prop :=
  forall b1 b1' delta1 b2 b2' delta2 ofs1 ofs2,
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m b1 ofs1 Max Nonempty ->
  perm m b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Lemma store_mapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Lemma store_unmapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma store_outside_inj:
  forall f m1 m2 chunk b ofs v m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  mem_inj f m1 m2'.

Lemma storebytes_mapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ mem_inj f n1 n2.

Lemma storebytes_unmapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma storebytes_outside_inj:
  forall f m1 m2 b ofs bytes2 m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Lemma storebytes_empty_inj:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  mem_inj f m1' m2'.

Lemma alloc_right_inj:
  forall f m1 m2 lo hi b2 m2',
  mem_inj f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  mem_inj f m1 m2'.

Lemma alloc_left_unmapped_inj:
  forall f m1 m2 lo hi m1' b1,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  f b1 = None ->
  mem_inj f m1' m2.

Definition inj_offset_aligned (delta: Z) (size: Z) : Prop :=
  forall chunk, size_chunk chunk <= size -> (align_chunk chunk | delta).

Lemma alloc_left_mapped_inj:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  inj_offset_aligned delta (hi-lo) ->
  (forall ofs k p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) ->
  f b1 = Some(b2, delta) ->
  mem_inj f m1' m2.

Lemma free_left_inj:
  forall f m1 m2 b lo hi m1',
  mem_inj f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  mem_inj f m1' m2.

Lemma free_right_inj:
  forall f m1 m2 b lo hi m2',
  mem_inj f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  mem_inj f m1 m2'.

Lemma drop_unmapped_inj:
  forall f m1 m2 b lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b lo hi p = Some m1' ->
  f b = None ->
  mem_inj f m1' m2.

Lemma drop_mapped_inj:
  forall f m1 m2 b1 b2 delta lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b1 lo hi p = Some m1' ->
  meminj_no_overlap f m1 ->
  f b1 = Some(b2, delta) ->
  exists m2',
      drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'
   /\ mem_inj f m1' m2'.

Lemma drop_outside_inj: forall f m1 m2 b lo hi p m2',
  mem_inj f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs' k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs' k p ->
    lo <= ofs' + delta < hi -> False) ->
  mem_inj f m1 m2'.

Record extends' (m1 m2: mem) : Prop :=
  mk_extends {
    mext_next: nextblock m1 = nextblock m2;
    mext_inj:  mem_inj inject_id m1 m2;
    mext_perm_inv: forall b ofs k p,
      perm m2 b ofs k p ->
      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
  }.

Definition extends := extends'.

Theorem extends_refl:
  forall m, extends m m.

Theorem load_extends:
  forall chunk m1 m2 b ofs v1,
  extends m1 m2 ->
  load chunk m1 b ofs = Some v1 ->
  exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.

Theorem loadv_extends:
  forall chunk m1 m2 addr1 addr2 v1,
  extends m1 m2 ->
  loadv chunk m1 addr1 = Some v1 ->
  Val.lessdef addr1 addr2 ->

Theorem loadbytes_extends:
  forall m1 m2 b ofs len bytes1,
  extends m1 m2 ->
  loadbytes m1 b ofs len = Some bytes1 ->
  exists bytes2, loadbytes m2 b ofs len = Some bytes2
              /\ list_forall2 memval_lessdef bytes1 bytes2.

Theorem store_within_extends:
  forall chunk m1 m2 b ofs v1 m1' v2,
  extends m1 m2 ->
  store chunk m1 b ofs v1 = Some m1' ->
  Val.lessdef v1 v2 ->

Theorem store_outside_extends:
  forall chunk m1 m2 b ofs v m2',
  extends m1 m2 ->
  store chunk m2 b ofs v = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) ->
  extends m1 m2'.

Theorem storev_extends:
  forall chunk m1 m2 addr1 v1 m1' addr2 v2,
  extends m1 m2 ->
  storev chunk m1 addr1 v1 = Some m1' ->
  Val.lessdef addr1 addr2 ->

Theorem storebytes_within_extends:
  forall m1 m2 b ofs bytes1 m1' bytes2,
  extends m1 m2 ->
  storebytes m1 b ofs bytes1 = Some m1' ->
  list_forall2 memval_lessdef bytes1 bytes2 ->
  exists m2',
     storebytes m2 b ofs bytes2 = Some m2'
  /\ extends m1' m2'.

Theorem storebytes_outside_extends:
  forall m1 m2 b ofs bytes2 m2',
  extends m1 m2 ->
  storebytes m2 b ofs bytes2 = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem alloc_extends:
  forall m1 m2 lo1 hi1 b m1' lo2 hi2,
  extends m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists m2',
     alloc m2 lo2 hi2 = (m2', b)
  /\ extends m1' m2'.

Theorem free_left_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  extends m1' m2.

Theorem free_right_extends:
  forall m1 m2 b lo hi m2',
  extends m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall ofs k p, perm m1 b ofs k p -> lo <= ofs < hi -> False) ->
  extends m1 m2'.

Theorem free_parallel_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  exists m2',
     free m2 b lo hi = Some m2'
  /\ extends m1' m2'.

Theorem valid_block_extends:
  forall m1 m2 b,
  extends m1 m2 ->
  (valid_block m1 b <-> valid_block m2 b).

Theorem perm_extends:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m1 b ofs k p -> perm m2 b ofs k p.

Theorem perm_extends_inv:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m2 b ofs k p -> perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty.

Theorem valid_access_extends:
  forall m1 m2 chunk b ofs p,
  extends m1 m2 -> valid_access m1 chunk b ofs p -> valid_access m2 chunk b ofs p.

Theorem valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 -> valid_pointer m1 b ofs = true -> valid_pointer m2 b ofs = true.

Theorem weak_valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 ->
  weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.

Record inject' (f: meminj) (m1 m2: mem) : Prop :=
  mk_inject {
    mi_inj:
      mem_inj f m1 m2;
    mi_freeblocks:
      forall b, ~(valid_block m1 b) -> f b = None;
    mi_mappedblocks:
      forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
    mi_no_overlap:
      meminj_no_overlap f m1;
    mi_representable:
      forall b b' delta ofs,
      f b = Some(b', delta) ->
      perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/ perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
      delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
    mi_perm_inv:
      forall b1 ofs b2 delta k p,
      f b1 = Some(b2, delta) ->
      perm m2 b2 (ofs + delta) k p ->
      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
  }.
Definition inject := inject'.

Local Hint Resolve mi_mappedblocks: mem.

Theorem valid_block_inject_1:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m1 b1.

Theorem valid_block_inject_2:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m2 b2.

Local Hint Resolve valid_block_inject_1 valid_block_inject_2: mem.

Theorem perm_inject:
  forall f m1 m2 b1 b2 delta ofs k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.

Theorem perm_inject_inv:
  forall f m1 m2 b1 ofs b2 delta k p,
  inject f m1 m2 ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p ->
  perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty.

Theorem range_perm_inject:
  forall f m1 m2 b1 b2 delta lo hi k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  range_perm m1 b1 lo hi k p -> range_perm m2 b2 (lo + delta) (hi + delta) k p.

Theorem valid_access_inject:
  forall f m1 m2 chunk b1 ofs b2 delta p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Theorem valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_pointer m1 b1 ofs = true ->
  valid_pointer m2 b2 (ofs + delta) = true.

Theorem weak_valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  weak_valid_pointer m1 b1 ofs = true ->
  weak_valid_pointer m2 b2 (ofs + delta) = true.

Lemma address_inject:
  forall f m1 m2 b1 ofs1 b2 delta p,
  inject f m1 m2 ->
  perm m1 b1 (Ptrofs.unsigned ofs1) Cur p ->

Lemma address_inject':
  forall f m1 m2 chunk b1 ofs1 b2 delta,
  inject f m1 m2 ->
  valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty ->

Theorem weak_valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem weak_valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem inject_no_overlap:
  forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
  inject f m1 m2 ->
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m1 b1 ofs1 Max Nonempty ->
  perm m1 b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Theorem different_pointers_inject:
  forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  inject f m m' ->
  b1 <> b2 ->
  valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->

Theorem disjoint_or_equal_inject:
  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
  inject f m m' ->
  f b1 = Some(b1', delta1) ->
  f b2 = Some(b2', delta2) ->
  range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty ->
  range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty ->
  sz > 0 ->
  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
             \/ ofs1 + delta1 + sz <= ofs2 + delta2
             \/ ofs2 + delta2 + sz <= ofs1 + delta1.

Theorem aligned_area_inject:
  forall f m m' b ofs al sz b' delta,
  inject f m m' ->
  al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz > 0 ->
  (al | sz) ->
  range_perm m b ofs (ofs + sz) Cur Nonempty ->
  (al | ofs) ->
  f b = Some(b', delta) ->
  (al | ofs + delta).

Theorem load_inject:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  inject f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Theorem loadv_inject:
  forall f m1 m2 chunk a1 a2 v1,
  inject f m1 m2 ->
  loadv chunk m1 a1 = Some v1 ->
  Val.inject f a1 a2 ->

Theorem loadbytes_inject:
  forall f m1 m2 b1 ofs len b2 delta bytes1,
  inject f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Theorem store_mapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Theorem store_unmapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem store_outside_inject:
  forall f m1 m2 chunk b ofs v m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  inject f m1 m2'.

Theorem storev_mapped_inject:
  forall f chunk m1 a1 v1 n1 m2 a2 v2,
  inject f m1 m2 ->
  storev chunk m1 a1 v1 = Some n1 ->
  Val.inject f a1 a2 ->

Theorem storebytes_mapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ inject f n1 n2.

Theorem storebytes_unmapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem storebytes_outside_inject:
  forall f m1 m2 b ofs bytes2 m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem storebytes_empty_inject:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  inject f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  inject f m1' m2'.

Theorem alloc_right_inject:
  forall f m1 m2 lo hi b2 m2',
  inject f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  inject f m1 m2'.

Theorem alloc_left_unmapped_inject:
  forall f m1 m2 lo hi m1' b1,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  exists f',
     inject f' m1' m2
  /\ inject_incr f f'
  /\ f' b1 = None
  /\ (forall b, b <> b1 -> f' b = f b).

Theorem alloc_left_mapped_inject:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  0 <= delta <= Ptrofs.max_unsigned ->

Theorem alloc_parallel_inject:
  forall f m1 m2 lo1 hi1 m1' b1 lo2 hi2,
  inject f m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b1) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists f', exists m2', exists b2,
  alloc m2 lo2 hi2 = (m2', b2)
  /\ inject f' m1' m2'
  /\ inject_incr f f'
  /\ f' b1 = Some(b2, 0)
  /\ (forall b, b <> b1 -> f' b = f b).

Lemma free_left_inject:
  forall f m1 m2 b lo hi m1',
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  inject f m1' m2.

Lemma free_list_left_inject:
  forall f m2 l m1 m1',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  inject f m1' m2.

Lemma free_right_inject:
  forall f m1 m2 b lo hi m2',
  inject f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) -> perm m1 b1 ofs k p ->
    lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma perm_free_list:
  forall l m m' b ofs k p,
  free_list m l = Some m' ->
  perm m' b ofs k p ->
  perm m b ofs k p /\
  (forall lo hi, In (b, lo, hi) l -> lo <= ofs < hi -> False).

Theorem free_inject:
  forall f m1 l m1' m2 b lo hi m2',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) ->
    perm m1 b1 ofs k p -> lo <= ofs + delta < hi ->
    exists lo1, exists hi1, In (b1, lo1, hi1) l /\ lo1 <= ofs < hi1) ->
  inject f m1' m2'.

Theorem free_parallel_inject:
  forall f m1 m2 b lo hi m1' b' delta,
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  f b = Some(b', delta) ->
  exists m2',
     free m2 b' (lo + delta) (hi + delta) = Some m2'
  /\ inject f m1' m2'.

Lemma drop_outside_inject: forall f m1 m2 b lo hi p m2',
  inject f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma mem_inj_compose:
  forall f f' m1 m2 m3,
  mem_inj f m1 m2 -> mem_inj f' m2 m3 -> mem_inj (compose_meminj f f') m1 m3.

Theorem inject_compose:
  forall f f' m1 m2 m3,
  inject f m1 m2 -> inject f' m2 m3 ->
  inject (compose_meminj f f') m1 m3.

Lemma val_lessdef_inject_compose:
  forall f v1 v2 v3,
  Val.lessdef v1 v2 -> Val.inject f v2 v3 -> Val.inject f v1 v3.

Lemma val_inject_lessdef_compose:
  forall f v1 v2 v3,
  Val.inject f v1 v2 -> Val.lessdef v2 v3 -> Val.inject f v1 v3.

Lemma extends_inject_compose:
  forall f m1 m2 m3,
  extends m1 m2 -> inject f m2 m3 -> inject f m1 m3.

Lemma inject_extends_compose:
  forall f m1 m2 m3,
  inject f m1 m2 -> extends m2 m3 -> inject f m1 m3.

Lemma extends_extends_compose:
  forall m1 m2 m3,
  extends m1 m2 -> extends m2 m3 -> extends m1 m3.

Definition flat_inj (thr: block) : meminj :=
  fun (b: block) => if plt b thr then Some(b, 0) else None.

Definition inject_neutral (thr: block) (m: mem) :=
  mem_inj (flat_inj thr) m m.

Remark flat_inj_no_overlap:
  forall thr m, meminj_no_overlap (flat_inj thr) m.

Theorem neutral_inject:
  forall m, inject_neutral (nextblock m) m -> inject (flat_inj (nextblock m)) m m.

Theorem empty_inject_neutral:
  forall thr, inject_neutral thr empty.

Theorem alloc_inject_neutral:
  forall thr m lo hi b m',
  alloc m lo hi = (m', b) ->
  inject_neutral thr m ->
  Plt (nextblock m) thr ->
  inject_neutral thr m'.

Theorem store_inject_neutral:
  forall chunk m b ofs v m' thr,
  store chunk m b ofs v = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  Val.inject (flat_inj thr) v v ->

Theorem drop_inject_neutral:
  forall m b lo hi p m' thr,
  drop_perm m b lo hi p = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  inject_neutral thr m'.

Section UNCHANGED_ON.

Variable P: block -> Z -> Prop.

Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
  unchanged_on_nextblock:
    Ple (nextblock m_before) (nextblock m_after);
  unchanged_on_perm:
    forall b ofs k p,
    P b ofs -> valid_block m_before b ->
    (perm m_before b ofs k p <-> perm m_after b ofs k p);
  unchanged_on_contents:
    forall b ofs,
    P b ofs -> perm m_before b ofs Cur Readable ->
    ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
    ZMap.get ofs (PMap.get b m_before.(mem_contents))
}.

Lemma unchanged_on_refl:
  forall m, unchanged_on m m.

Lemma valid_block_unchanged_on:
  forall m m' b,
  unchanged_on m m' -> valid_block m b -> valid_block m' b.

Lemma perm_unchanged_on:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs ->
  perm m b ofs k p -> perm m' b ofs k p.

Lemma perm_unchanged_on_2:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs -> valid_block m b ->
  perm m' b ofs k p -> perm m b ofs k p.

Lemma unchanged_on_trans:
  forall m1 m2 m3, unchanged_on m1 m2 -> unchanged_on m2 m3 -> unchanged_on m1 m3.

Lemma loadbytes_unchanged_on_1:
  forall m m' b ofs n,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m' b ofs n = loadbytes m b ofs n.

Lemma loadbytes_unchanged_on:
  forall m m' b ofs n bytes,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m b ofs n = Some bytes ->
  loadbytes m' b ofs n = Some bytes.

Lemma load_unchanged_on_1:
  forall m m' chunk b ofs,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m' b ofs = load chunk m b ofs.

Lemma load_unchanged_on:
  forall m m' chunk b ofs v,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m b ofs = Some v ->
  load chunk m' b ofs = Some v.

Lemma store_unchanged_on:
  forall chunk m b ofs v m',
  store chunk m b ofs v = Some m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> ~ P b i) ->
  unchanged_on m m'.

Lemma storebytes_unchanged_on:
  forall m b ofs bytes m',
  storebytes m b ofs bytes = Some m' ->
  (forall i, ofs <= i < ofs + Z.of_nat (length bytes) -> ~ P b i) ->

Lemma alloc_unchanged_on:
  forall m lo hi m' b,
  alloc m lo hi = (m', b) ->
  unchanged_on m m'.

Lemma free_unchanged_on:
  forall m b lo hi m',
  free m b lo hi = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

Lemma drop_perm_unchanged_on:
  forall m b lo hi p m',
  drop_perm m b lo hi p = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

End UNCHANGED_ON.

Lemma unchanged_on_implies:
  forall (P Q: block -> Z -> Prop) m m',
  unchanged_on P m m' ->
  (forall b ofs, Q b ofs -> valid_block m b -> P b ofs) ->
  unchanged_on Q m m'.

End Mem.

Notation mem := Mem.mem.

Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.

Hint Resolve
  Mem.valid_not_valid_diff
  Mem.perm_implies
  Mem.perm_cur
  Mem.perm_max
  Mem.perm_valid_block
  Mem.range_perm_implies
  Mem.range_perm_cur
  Mem.range_perm_max
  Mem.valid_access_implies
  Mem.valid_access_valid_block
  Mem.valid_access_perm
  Mem.valid_access_load
  Mem.load_valid_access
  Mem.loadbytes_range_perm
  Mem.valid_access_store
  Mem.perm_store_1
  Mem.perm_store_2
  Mem.nextblock_store
  Mem.store_valid_block_1
  Mem.store_valid_block_2
  Mem.store_valid_access_1
  Mem.store_valid_access_2
  Mem.store_valid_access_3
  Mem.storebytes_range_perm
  Mem.perm_storebytes_1
  Mem.perm_storebytes_2
  Mem.storebytes_valid_access_1
  Mem.storebytes_valid_access_2
  Mem.nextblock_storebytes
  Mem.storebytes_valid_block_1
  Mem.storebytes_valid_block_2
  Mem.nextblock_alloc
  Mem.alloc_result
  Mem.valid_block_alloc
  Mem.fresh_block_alloc
  Mem.valid_new_block
  Mem.perm_alloc_1
  Mem.perm_alloc_2
  Mem.perm_alloc_3
  Mem.perm_alloc_4
  Mem.perm_alloc_inv
  Mem.valid_access_alloc_other
  Mem.valid_access_alloc_same
  Mem.valid_access_alloc_inv
  Mem.range_perm_free
  Mem.free_range_perm
  Mem.nextblock_free
  Mem.valid_block_free_1
  Mem.valid_block_free_2
  Mem.perm_free_1
  Mem.perm_free_2
  Mem.perm_free_3
  Mem.valid_access_free_1
  Mem.valid_access_free_2
  Mem.valid_access_free_inv_1
  Mem.valid_access_free_inv_2
  Mem.unchanged_on_refl
: mem. *)



Require Import VST.concurrency.common.permissions. Import permissions.
(* VST.concurrency.common.permissions:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool
        ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.
Require Import VST.msl.Coqlib2.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permjoin_def.
Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import compcert.lib.Integers.
Require Export compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
From VST.veric Require Import shares juicy_mem juicy_mem_lemmas.
Require Import VST.msl.msl_standard.
Require Import FunInd.
Import cjoins.

Require Import ProofIrrelevance.

Lemma po_refl: forall p, Mem.perm_order'' p p.

Lemma perm_order_antisym :
  forall p p'
    (Hlt: Mem.perm_order'' p p')

Definition access_map := Maps.PMap.t (Z -> option permission).
Definition delta_map := Maps.PTree.t (Z -> option (option permission)).

Section permMapDefs.

  Definition empty_map : access_map :=
    (fun z => None, Maps.PTree.empty (Z -> option permission)).

  Lemma empty_map_spec: forall b ofs,
      Maps.PMap.get b empty_map ofs = None.

  Definition permission_at (m : mem) (b : block) (ofs : Z) (k : perm_kind) :=
    Maps.PMap.get b (Mem.mem_access m) ofs k.

  Definition perm_coh (p1 p2 : option permission) :=
    match p1 with
    | Some Freeable | Some Writable | Some Readable =>
                                      match p2 with
                                      | None => True
                                      | _ => False
                                      end
    | Some Nonempty | None =>
                      match p2 with
                      | Some Freeable => False
                      | _ => True
                      end
    end.

  Lemma perm_coh_lower:
    forall p1 p2 p3 p4
      (Hpu: perm_coh p1 p2)
      (Hperm2: Mem.perm_order'' p2 p4)

  Lemma perm_coh_not_freeable:
    forall p p',
      perm_coh p p' ->
      p' <> Some Freeable.

  Lemma perm_coh_empty_1:
    forall p,
      perm_coh p None.

  Lemma perm_coh_empty_2:
    forall p : option permission,
      Mem.perm_order'' (Some Writable) p ->

  Lemma perm_of_glb_not_Freeable: forall sh,
      ~ perm_of_sh (Share.glb Share.Rsh sh) = Some Freeable.

  Lemma perm_coh_self: forall res,
      perm_coh (perm_of_res res)
               (perm_of_res_lock res).

  Lemma perm_coh_joins:
    forall a b, joins a b ->
           perm_coh (perm_of_res a) (perm_of_res_lock b).

  Lemma po_join_sub_lock:
  forall r1 r2 ,
    join_sub r2 r1 ->
    Mem.perm_order'' (perm_of_res_lock r1) (perm_of_res_lock r2).

  Definition permMapCoherence (pmap1 pmap2 : access_map) :=
    forall b ofs, perm_coh (pmap1 !! b ofs) (pmap2 !! b ofs).

  Lemma permCoh_empty: forall r,
      (forall b ofs, Mem.perm_order'' (Some Writable) (r !! b ofs)) ->

  Lemma permCoh_empty': forall x,
      permMapCoherence x empty_map.

  Lemma perm_of_res_lock_not_Freeable:
    forall r,
      Mem.perm_order'' (Some Writable) (perm_of_res_lock r).

  Definition perm_union (p1 p2 : option permission) : option (option permission) :=
    match p1,p2 with
      | None, _ => Some p2
      | _, None => Some p1
      | Some p1', Some p2' =>
        match p1', p2' with
          | Freeable, _ => None
          | _, Freeable => None
          | Nonempty, _ => Some p2
          | _, Nonempty => Some p1
          | Writable, _ => None
          | _, Writable => None
          | Readable, Readable => Some (Some Readable)
        end
    end.

  Lemma perm_union_comm :
    forall p1 p2,
      perm_union p1 p2 = perm_union p2 p1.

  Lemma perm_union_result : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                              pu = p1 \/ pu = p2.

  Lemma perm_union_ord : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Lemma perm_union_lower:
    forall p1 p2 p3
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p2 p3),

  Lemma perm_union_lower_2:
    forall p1 p2 p3 p4
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p1 p3)

  Inductive not_racy : option permission -> Prop :=
  | empty : not_racy None.

  Inductive racy : option permission -> Prop :=
  | freeable : racy (Some Freeable).

  Lemma not_racy_union :
    forall p1 p2 (Hnot_racy: not_racy p1),
    exists pu, perm_union p1 p2 = Some pu.

  Lemma no_race_racy : forall p1 p2 (Hracy: racy p1)
                              (Hnorace: exists pu, perm_union p1 p2 = Some pu),
                         not_racy p2.

  Lemma perm_order_clash:
    forall p p'
      (Hreadable: Mem.perm_order' p Readable)

  Lemma perm_order_incompatible:
    forall p p'
      (Hreadable: Mem.perm_order'' p (Some Readable))

  Definition perm_max (p1 p2 : option permission) : option permission :=
    match p1,p2 with
      | Some Freeable, _ => p1
      | _, Some Freeable => p2
      | Some Writable, _ => p1
      | _, Some Writable => p2
      | Some Readable, _ => p1
      | _, Some Readable => p2
      | Some Nonempty, _ => p1
      | _, Some Nonempty => p2
      | None, None => None
    end.

  Lemma perm_max_comm :
    forall p1 p2,
      perm_max p1 p2 = perm_max p2 p1.

  Lemma perm_max_result : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                            pu = p1 \/ pu = p2.

  Lemma perm_max_ord : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Definition getMaxPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Max) (Mem.mem_access m).

  Definition getCurPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Cur) (Mem.mem_access m).

  Definition getPermMap (m : mem) : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    Mem.mem_access m.

  Lemma getCur_Max : forall m b ofs,
                       Mem.perm_order'' (Maps.PMap.get b (getMaxPerm m) ofs)

  Lemma getMaxPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getMaxPerm m) ofs = permission_at m b ofs Max.

  Lemma getCurPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getCurPerm m) ofs = permission_at m b ofs Cur.

  Definition permDisjoint p1 p2:=
    exists pu : option permission,
      perm_union p1 p2 = Some pu.

   Lemma permDisjoint_None: forall p,
      permDisjoint None p.

  Lemma permDisjoint_comm: forall p1 p2,
      permDisjoint p1 p2 -> permDisjoint p2 p1.

  Lemma permDisjointLT: forall a b c,
      permDisjoint a c ->
      Mem.perm_order'' a b ->

  Ltac if_simpl:=
    repeat match goal with
           | [ H: ?X = true |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = false |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = left _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: ?X = right _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: (@is_left _ _ ?X) = true |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           | [ H: (@is_left _ _ ?X) = false |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           end.

  Ltac permDisj_solve:= eexists; simpl; reflexivity.
  
  Lemma join_sh_permDisjoint:
        forall sh1 sh2,
          joins sh1 sh2 ->
          permDisjoint (perm_of_sh sh1) (perm_of_sh sh2).
  
  Lemma writable0_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ readable_share sh2.

  Lemma writable0_not_join_writable0 :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ writable0_share sh2.
 
  Lemma joins_permDisjoint: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res r1) (perm_of_res r2).
  
  Ltac glb_contradictions:=
    repeat match goal with
           | [ H: writable0_share_dec _ = _ |- _ ] => clear H
           end;
    match goal with
    | [ H:  Share.glb Share.Rsh ?sh = Share.top  |- _ ] =>
      exfalso; eapply glb_Rsh_not_top; eassumption
    | [ H: writable0_share (Share.glb Share.Rsh ?sh) |- _ ] =>
      eapply writable0_right in H
    end; join_sh_contradiction.
  
  Lemma joins_permDisjoint_lock: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res_lock r1) (perm_of_res_lock r2).
  
  Definition permMapsDisjoint (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs, exists pu,
      perm_union ((Maps.PMap.get b pmap1) ofs)
                 ((Maps.PMap.get b pmap2) ofs) = Some pu.

  Definition permMapsDisjoint2 (pmap pmap': access_map * access_map) :=
    permMapsDisjoint pmap.1 pmap'.1 /\
    permMapsDisjoint pmap.2 pmap'.2.

  Lemma permDisjoint_permMapsDisjoint: forall r1 r2,
      (forall b ofs, permDisjoint (r1 !! b ofs) (r2 !! b ofs))->
      permMapsDisjoint r1 r2.

  Lemma permMapsDisjoint_permDisjoint: forall r1 r2 b ofs,
      permMapsDisjoint r1 r2 ->
      permDisjoint (r1 !! b ofs) (r2 !! b ofs).

  Lemma empty_disjoint':
    forall pmap,
      permMapsDisjoint empty_map pmap.
  Lemma empty_disjoint:
    permMapsDisjoint empty_map
                     empty_map.

  Lemma permMapsDisjoint_comm :
    forall pmap1 pmap2
      (Hdis: permMapsDisjoint pmap1 pmap2),
      permMapsDisjoint pmap2 pmap1.

  Lemma permMapsDisjoint2_comm:
    forall pmaps pmaps',
      permMapsDisjoint2 pmaps pmaps' <-> permMapsDisjoint2 pmaps' pmaps.

  Lemma disjoint_norace:
    forall (mi mj : mem) (b : block) (ofs : Z)
      (Hdisjoint: permMapsDisjoint (getCurPerm mi) (getCurPerm mj))
      (Hpermj: Mem.perm mj b ofs Cur Readable)

  Definition isCanonical (pmap : access_map) := pmap.1 = fun _ => None.
  Import Maps.
  Definition TreeMaxIndex {A} (t:Maps.PTree.t A): positive:=
    compcert.lib.Coqlib.list_fold_left (fun a => [eta Pos.max a.1]) 1%positive (Maps.PTree.elements t) .
  Lemma fold_max_monoton: forall  {A} (ls: seq.seq (positive * A)), forall i,
  Lemma fold_max_monoton': forall  {A} (ls: seq.seq (positive * A)), forall i j,
  Lemma TreeMaxIndex_help: forall {A} (ls: seq.seq (positive * A)), forall i v,

  Lemma max_works: forall A (t:PTree.t A) m, (m > TreeMaxIndex t)%positive ->

  Lemma Cur_isCanonical: forall m, isCanonical (getCurPerm m).

  Lemma Max_isCanonical: forall m, isCanonical (getMaxPerm m).

  Definition permMapLt (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs,
      Mem.perm_order'' (Maps.PMap.get b pmap2 ofs)
                       (Maps.PMap.get b pmap1 ofs).

  Lemma empty_LT: forall pmap,
             permMapLt empty_map pmap.

  Lemma canonical_lt :
    forall p' m
      (Hlt: permMapLt p' (getMaxPerm m)),
      isCanonical p'.

   Lemma invalid_block_empty:
    forall pmap m
      (Hlt: permMapLt pmap (getMaxPerm m)),
    forall b, ~ Mem.valid_block m b ->

  Definition setPerm (p : option permission) (b : block)
             (ofs : Z) (pmap : access_map) : access_map :=
    Maps.PMap.set b (fun ofs' => if compcert.lib.Coqlib.zeq ofs ofs' then
                                p
                              else
                                Maps.PMap.get b pmap ofs')
                  pmap.

   Fixpoint setPermBlock (p : option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm p b (ofs + (Z_of_nat len))%Z (setPermBlock p b ofs pmap len)
    end.

  Lemma setPermBlock_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock p b ofs pmap sz)) ofs' =

  Lemma setPermBlock_or:
    forall p b ofs sz pmap b' ofs',
      (setPermBlock p b ofs pmap sz) !! b' ofs' = p \/
      (setPermBlock p b ofs pmap sz) !! b' ofs' = pmap !! b' ofs'.

  Fixpoint setPermBlock_var (fp : nat -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp length) b (ofs + (Z_of_nat len))%Z
              (setPermBlock_var fp b ofs pmap len)
    end.

  Lemma setPermBlock_var_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock_var p b ofs pmap sz)) ofs' =

   Lemma setPermBlock_var_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_var_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_setPermBlock_var:
    forall b ofs sz pmap p,
      setPermBlock p b ofs pmap sz =
      setPermBlock_var (fun _ => p) b ofs pmap sz.

  Lemma permMapCoherence_increase:
    forall pmap pmap' b ofs sz_nat sz
      (Hsz: sz = Z.of_nat (sz_nat))

  Fixpoint setPermBlockFunc (fp : Z -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp (ofs + (Z_of_nat len))%Z) b (ofs + (Z_of_nat len))%Z (setPermBlockFunc fp b ofs pmap len)
    end.

  Lemma setPermBlockFunc_same:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_1:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_2:
    forall fp b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock fp b ofs pmap sz)) ofs' =

  Lemma setPermBlock_coherent:
    forall pmap pmap' b ofs sz
      (Hcoh: permMapCoherence pmap pmap')
      (Hnonempty: forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat sz)%Z ->

  Definition computeMap (pmap : access_map) (delta : delta_map) : access_map :=
    (pmap.1,
     @Maps.PTree.combine (Z -> option permission) (Z -> option (option permission))
                         (Z -> option permission)
                         (fun p1 pd => match pd, p1 with
                                    | Some pd', Some p1' =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => p1' z
                                                  end)
                                    | Some pd', None =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => pmap.1 z
                                                  end)
                                    | None, _ => p1
                                    end)
                         pmap.2 delta).

  Lemma computeMap_1 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df (p : option permission),
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_2 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df,
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_3 :
    forall (pmap : access_map) (dmap : delta_map) b ofs,
      Maps.PTree.get b dmap = None ->

  Import Maps BlockList.

  Definition maxF (f : Z -> perm_kind -> option permission) :=
    fun ofs k => match k with
              | Max => Some Freeable
              | Cur => f ofs k
              end.

  Definition allF (f : Z -> perm_kind -> option permission) :=
    fun (_ : Z) (_ : perm_kind) => Some Freeable.

  Fixpoint PList (f : (Z -> perm_kind -> option permission) ->
                      Z -> perm_kind -> option permission)
           l m : list (positive * (Z -> perm_kind -> option permission)) :=
    match l with
      | nil => nil
      | x :: l =>
        (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m)
  end.

  Lemma PList_app :
    forall l m x f,
      (PList f l m) ++ ((Pos.of_nat x,

  Lemma PList_cons :
    forall f l m x,
      (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m) =

  Lemma PList_correct :
    forall f l m k v
           (HInl: List.In k l)

  Lemma PList_mkBlock_complete :
    forall f k v m n
           (Hk: k > 0)
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m)),

  Lemma PList_mkBlock_det :
    forall n f k v v' m
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m))

  Fixpoint canonicalPTree (l : list (positive * (Z -> perm_kind -> option permission))) :=
    match l with
      | nil => PTree.empty _
      | x :: l =>
        PTree.set (fst x) (snd x) (canonicalPTree l)
    end.

  Lemma canonicalPTree_elements :
    forall l x
           (Hin: List.In x (PTree.elements (canonicalPTree l))),

  Lemma canonicalPTree_get_complete :
    forall l m k f fn
           (HGet: (canonicalPTree (PList fn l m)) ! k = Some f),
      List.In (k, f) (PList fn l m).

  Lemma canonicalPTree_get_sound :
    forall n m k fn
           (Hk: k > 0)
           (Hn: n > 1)
           (HGet: (canonicalPTree (PList fn (mkBlockList n) m)) ! (Pos.of_nat k) = None),

  Definition canonicalPMap fn n m : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    let l := mkBlockList n in
    (fun _ _ => None, canonicalPTree (PList fn l m)).

  Lemma canonicalPMap_sound :
    forall k n m fn
           (Hk : k > 0)
           (Hkn : k < n),
      fn (m !! (Pos.of_nat k)) = (canonicalPMap fn n m) !! (Pos.of_nat k).

  Lemma canonicalPMap_default :
    forall n k m fn
           (Hkn : k >= n),
      (canonicalPMap fn n m) !! (Pos.of_nat k) = fun _ _ => None.

  Definition setMaxPerm (m : mem) : mem.

  Lemma setMaxPerm_Max :
    forall m b ofs,
      (Mem.valid_block m b ->

   Lemma setMaxPerm_MaxV :
    forall m b ofs,
      Mem.valid_block m b ->

  Lemma setMaxPerm_MaxI :
    forall m b ofs,
      ~ Mem.valid_block m b ->

  Lemma setMaxPerm_Cur :
    forall m b ofs,
      permission_at (setMaxPerm m) b ofs Cur = permission_at m b ofs Cur.

  Definition makeCurMax_map (mem_access:PMap.t (Z -> perm_kind -> option permission)):
    PMap.t (Z -> perm_kind -> option permission):=
    PMap.map (fun f => fun z k => f z Max) mem_access.

  Definition makeCurMax (m:mem): mem.

  Lemma makeCurMax_correct :
    forall m b ofs k,
      permission_at m b ofs Max = permission_at (makeCurMax m) b ofs k.

  Lemma makeCurMax_valid :
    forall m b,
      Mem.valid_block m b <-> Mem.valid_block (makeCurMax m) b.

  Definition restrPermMap p' m (Hlt: permMapLt p' (getMaxPerm m)) : mem.

Lemma restrPermMap_irr:
      forall p1 p2 m1 m2
        (P1: permMapLt p1 (getMaxPerm m1))
        (P2: permMapLt p2 (getMaxPerm m2)),
        p1 = p2 -> m1 = m2 ->
        restrPermMap P1 = restrPermMap P2.
    Lemma restrPermMap_ext:
      forall p1 p2 m
        (P1: permMapLt p1 (getMaxPerm m))
        (P2: permMapLt p2 (getMaxPerm m)),
        (forall b, (p1 !! b) = (p2 !! b)) ->
        restrPermMap P1 = restrPermMap P2.

  Lemma restrPermMap_nextblock :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      Mem.nextblock (restrPermMap Hlt) = Mem.nextblock m.

  Lemma restrPermMap_valid :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      Mem.valid_block (restrPermMap Hlt) b <-> Mem.valid_block m b.

  Lemma restrPermMap_contents :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      contents_at (restrPermMap Hlt) = contents_at m.

  Lemma restrPermMap_max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      max_access_at (restrPermMap Hlt) = max_access_at m.

  Lemma getMax_restr :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      (getMaxPerm (restrPermMap Hlt)) !!  b = (getMaxPerm m) !! b.

  Lemma restrPermMap_irr' : forall p' p'' m
                             (Hlt : permMapLt p' (getMaxPerm m))
                             (Hlt': permMapLt p'' (getMaxPerm m))
                             (Heq_new: p' = p''),
                             restrPermMap Hlt = restrPermMap Hlt'.

  Lemma restrPermMap_disjoint_inv:
    forall (mi mj m : mem) (pi pj : access_map)
      (Hltj: permMapLt pj (getMaxPerm m))
      (Hlti: permMapLt pi (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pi pj)
      (Hrestrj: restrPermMap Hltj = mj)
      (Hrestri: restrPermMap Hlti = mi),
      permMapsDisjoint (getCurPerm mi) (getCurPerm mj).

  Lemma restrPermMap_correct :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m))
      b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs /\

  Corollary restrPermMap_Cur :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Cur =
      Maps.PMap.get b p' ofs.

  Corollary restrPermMap_Max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs.

  Lemma restrPermMap_can : forall (p : access_map) (m m': mem)
                             (Hlt: permMapLt p (getMaxPerm m))
                             (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getCurPerm m').

  Lemma restrPermMap_can_max : forall (p : access_map) (m m': mem)
                                 (Hlt: permMapLt p (getMaxPerm m))
                                 (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getMaxPerm m').

  Definition erasePerm (m : mem) : mem.

  Lemma erasePerm_Perm :
    forall m b ofs k ,
      (Mem.valid_block m b ->

   Lemma erasePerm_V :
    forall m b ofs k,
      Mem.valid_block m b ->

  Lemma erasePerm_I :
    forall m b ofs k,
      ~ Mem.valid_block m b ->

   Definition decay m_before m_after := forall b ofs,
      (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k,
           (Maps.PMap.get b (Mem.mem_access m_before) ofs k = Some Freeable /\
            Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) \/
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Definition strong_decay m_before m_after := forall b ofs,
       (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Lemma strong_decay_implies_decay:
     forall m m',
       strong_decay m m' ->
       decay m m'.

  Lemma decay_refl:
    forall m,
      decay m m.

  Lemma decay_trans :
    forall m m' m'',
      (forall b, Mem.valid_block m b -> Mem.valid_block m' b) ->

  Definition permMapJoin (pmap1 pmap2 pmap3: access_map) :=
    forall b ofs,
      permjoin ((pmap1 !! b) ofs) ((pmap2 !! b) ofs) ((pmap3 !! b) ofs).

  Lemma permMapJoin_order:
    forall p1 p2 p3
      (Hjoin: permMapJoin p1 p2 p3),
    forall b ofs,
      Mem.perm_order'' (p3 !! b ofs) (p1 !! b ofs) /\

  Lemma permMapLt_invalid_block:
    forall pmap m b ofs
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma perm_order_valid_block:
    forall pmap m b ofs p
      (Hperm: Mem.perm_order'' (pmap !! b ofs) (Some p))

  Definition perm_order''_dec : forall (op op' : option permission),
      {Mem.perm_order'' op op'} + {~ Mem.perm_order'' op op'}.

  Definition perm_eq_dec: forall (op op' : option permission),
      {op = op'} + {~ op = op'}.

End permMapDefs.

Require Import VST.concurrency.common.core_semantics.
Require Import compcert.lib.Coqlib.

Lemma storebytes_decay:
  forall m loc p vl m', Mem.storebytes m loc p vl = Some m' -> decay m m'.

Lemma alloc_decay:
  forall m lo hi m1 b1, Mem.alloc m lo hi = (m1,b1) -> decay m m1.

Lemma free_decay: forall m b lo hi m', Mem.free m b lo hi = Some m' -> decay m m'.

Lemma msem_decay: 
  forall C (Sem: MemSem C) c m c' m',
   corestep (csem Sem)  c m c' m' ->
  decay m m'. *)

Require Import VST.concurrency.compiler.concurrent_compiler_simulation.
(* VST.concurrency.compiler.concurrent_compiler_simulation:
Require Import VST.concurrency.compiler.HybridMachine_simulation.

Require Import VST.concurrency.common.ClightMachine.

Require Import VST.concurrency.common.x86_context.

Section ConcurrentCopmpilerSpecification.
  
  Import ClightMachine.
  Import DMS.  
  
  Import X86Context.

  Context (Clight_g : Clight.genv).
  Context (Asm_g : Clight.genv).
  Context (Asm_program: Asm.program).
  Context (Asm_genv_safe: Asm_core.safe_genv (@the_ge Asm_program)).

  Variable opt_init_mem_source: option Memory.Mem.mem.
  Variable opt_init_mem_target: option Memory.Mem.mem.
  Definition ConcurrentCompilerCorrectness_specification: Type:=
    HybridMachine_simulation (ClightConcurSem(ge:=Clight_g) opt_init_mem_source) (@AsmConcurSem Asm_program Asm_genv_safe opt_init_mem_target).

End ConcurrentCopmpilerSpecification. *)

Require Import VST.concurrency.compiler.sequential_compiler_correct.
(* VST.concurrency.compiler.sequential_compiler_correct:
Require Import compcert.common.ExposedSimulations.
Require Import compcert.cfrontend.Clight.
Require Import compcert.x86.Asm.

Module Type CompCert_correctness.

Parameter CompCert_compiler: Clight.program -> option Asm.program.
Hypothesis simpl_clight_semantic_preservation:
  forall (p:Clight.program) (tp:Asm.program),
  CompCert_compiler p = Some tp ->
  fsim_properties_inj (Clight.semantics2 p) (Asm.semantics tp) Clight.get_mem Asm.get_mem.

End CompCert_correctness. *)

Require Import VST.concurrency.compiler.CoreSemantics_sum.
(* VST.concurrency.compiler.CoreSemantics_sum:
Require Import VST.concurrency.common.core_semantics.
Require Import VST.concurrency.common.semantics.
Require Import VST.sepcomp.event_semantics.

Inductive state_sum (Cs Ct:Type): Type :=
| SState (c:Cs)
| TState (c:Ct).

Definition state_sum_options {Cs Ct:Type} (cso: option Cs): option (state_sum Cs Ct) :=
  match cso with
  | Some cs => Some (SState _ _ cs)
  | _ => None
  end.
Definition state_sum_optiont {Cs Ct:Type} (cto: option Ct): option (state_sum Cs Ct) :=
  match cto with
  | Some ct => Some (TState _ _ ct)
  | _ => None
  end.

Definition state_sum_optionms {Cs Ct M:Type} (cso: option (Cs * option M)): option (state_sum Cs Ct * option M) :=
  match cso with
  | Some (cs, m) => Some (SState _ _ cs, m)
  | _ => None
  end.
Definition state_sum_optionmt {Cs Ct M:Type} (cto: option (Ct * option M)): option (state_sum Cs Ct * option M) :=
  match cto with
  | Some (ct, m) => Some (TState _ _ ct, m)
  | _ => None
  end.

Definition lt_op (n: nat) (no:option nat): Prop :=
  match no with
    | None => False
    | Some n' => n < n' 
  end.

Definition initial_core_sum (no:option nat) (Cs Ct:Type) (M: Type)
           (sinitial_core : nat -> M -> Cs -> M -> Values.val -> list Values.val -> Prop)
           (tinitial_core : nat -> M -> Ct -> M -> Values.val -> list Values.val -> Prop):
  nat -> M -> state_sum Cs Ct -> M -> Values.val -> list Values.val -> Prop :=
  fun (n:nat) m c m' val vals =>
    match c with
    | SState c => lt_op n no /\ sinitial_core n m c m' val vals
    | TState c => ~lt_op n no /\ tinitial_core n m c m' val vals
    end.

Definition sum_func {Cs Ct X:Type} (fs:Cs -> X) (ft:Ct-> X) s:=
  match s with
  | SState c => (fs c)
  | TState c => (ft c)
  end.

Definition sum_func_option {Cs Ct Cs' Ct':Type} 
           (fs: Cs -> option Cs') (ft: Ct-> option Ct') s:=
  match s with
  | SState c => state_sum_options (fs c) 
  | TState c => state_sum_optiont (ft c) 
  end.

Definition at_external_sum (Cs Ct M: Type)
           (sat_external: Cs -> M -> option (AST.external_function * list Values.val))
           (tat_external: Ct -> M -> option (AST.external_function * list Values.val))
           :=
  sum_func sat_external tat_external.

Definition after_external_sum (Cs Ct M: Type)
           (safter_external: option Values.val -> Cs -> M -> option Cs)
           (tafter_external: option Values.val -> Ct -> M -> option Ct)
           :=
  fun vals c m => sum_func_option (fun c => safter_external vals c m)
                                  (fun c => tafter_external vals c m) c.

Definition halted_sum Cs Ct
           (shalted: Cs -> Integers.Int.int -> Prop)
           (thalted: Ct -> Integers.Int.int -> Prop) :=
  sum_func shalted thalted.

Inductive corestep_sum {M Cs Ct}
          (scorestep: Cs -> M -> Cs -> M -> Prop)
          (tcorestep: Ct -> M -> Ct -> M -> Prop):
  state_sum Cs Ct -> M -> state_sum Cs Ct -> M -> Prop:=
| SCorestep: forall s m s' m',
    scorestep s m s' m' ->
    corestep_sum scorestep tcorestep (SState _ _ s) m (SState _ _ s') m'
| TCorestep: forall s m s' m',
    tcorestep s m s' m' ->
    corestep_sum scorestep tcorestep (TState _ _ s) m (TState _ _ s') m'.

Lemma corestep_not_at_external_sum:
  forall M Cs Ct
    {scorestep: Cs -> M -> Cs -> M -> Prop} 
    {sat_external: Cs -> M -> option (AST.external_function * list Values.val)}

Lemma corestep_not_halted_sum:
  forall  M Cs Ct
    (scorestep: Cs -> M -> Cs -> M -> Prop) 
    (shalted : Cs -> Integers.Int.int -> Prop)

Program Definition CoreSemanticsSum hb M Cs Ct
        (CSs: CoreSemantics Cs M )
        (CSt: CoreSemantics Ct M ): CoreSemantics (state_sum Cs Ct) M:=
  Build_CoreSemantics _ _
    (initial_core_sum hb _ _ _ (initial_core CSs) (initial_core CSt))
    (at_external_sum _ _ _ (at_external CSs) (at_external CSt))
    (after_external_sum _ _ _ (after_external CSs) (after_external CSt))
    (halted_sum _ _  (halted CSs) (halted CSt))
    (corestep_sum (corestep CSs) (corestep CSt)) 
    _
    _.

Program Definition MemSemanticsSum (hb:option nat) Cs Ct
        (CSs: MemSem Cs )
        (CSt: MemSem Ct ): MemSem (state_sum Cs Ct):=
  Build_MemSem _ (CoreSemanticsSum hb Memory.Mem.mem Cs Ct CSs CSt) _.

Inductive ev_step_sum {Cs Ct:Type}
          (ESs: Cs -> Memory.Mem.mem -> list mem_event -> Cs -> Memory.Mem.mem -> Prop)
          (ESt: Ct -> Memory.Mem.mem -> list mem_event -> Ct -> Memory.Mem.mem -> Prop):
  (state_sum Cs Ct) -> Memory.Mem.mem -> list mem_event -> (state_sum Cs Ct) -> Memory.Mem.mem -> Prop
  :=
| SEvstep: forall s m t s' m',
    ESs s m t s' m' ->
    ev_step_sum ESs ESt (SState _ _ s) m t (SState _ _ s') m'
| TEvstep: forall s m t s' m',
    ESt s m t s' m' ->
    ev_step_sum ESs ESt (TState _ _ s) m t (TState _ _ s') m'.
  
Program Definition EvSemanticsSum (hb:option nat) Cs Ct
        (CSs: @EvSem Cs )
        (CSt: @EvSem Ct ): @EvSem (state_sum Cs Ct):=
  Build_EvSem _ (MemSemanticsSum hb Cs Ct CSs CSt) (ev_step_sum (ev_step CSs) (ev_step CSt)) _ _ _ _.

Definition CoreSem_Sum (hb:option nat) (Sems Semt: Semantics): Semantics:=
  Build_Semantics _ _
                  (EvSemanticsSum hb _ _ (@semSem Sems) (@semSem Semt))
                  (@the_ge Sems, @the_ge Semt) . *)

Require Import VST.concurrency.common.HybridMachine.
(* VST.concurrency.common.HybridMachine:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool ssrfun.
Require Import compcert.common.Memory.
Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.

Require Import VST.msl.Axioms.
Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.event_semantics.
Require Export VST.concurrency.common.semantics.
Require Export VST.concurrency.common.lksize.
Require Import VST.concurrency.common.threadPool.

Require Import VST.concurrency.common.machine_semantics.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.bounded_maps.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.scheduler.
Require Import Coq.Program.Program.

Require Import VST.concurrency.common.HybridMachineSig.

Module DryHybridMachine.
  Import Events ThreadPool.

  Instance dryResources: Resources:=
    {| res := access_map * access_map;
       lock_info := access_map * access_map |}.

  Section DryHybridMachine.
        
    Context {Sem: Semantics}
            {tpool : @ThreadPool.ThreadPool dryResources Sem}.
    
    Notation C:= (@semC Sem).
    Notation G:= (@semG Sem).
    Notation semSem:= (@semSem Sem).

    Notation thread_pool := (@t dryResources Sem).
    
    Definition richMem: Type:= mem.
    Definition dryMem: richMem -> mem:= fun x => x.
    
    Record mem_compatible (tp: thread_pool) m : Prop :=
      { compat_th :> forall {tid} (cnt: containsThread tp tid),
            permMapLt (getThreadR cnt).1 (getMaxPerm m) /\
            permMapLt (getThreadR cnt).2 (getMaxPerm m);
        compat_lp : forall l pmaps, lockRes tp l = Some pmaps ->
                               permMapLt pmaps.1 (getMaxPerm m) /\
                               permMapLt pmaps.2 (getMaxPerm m);
        lockRes_blocks: forall l rmap, lockRes tp l = Some rmap ->
                                  Mem.valid_block m l.1}.

    Record invariant (tp: thread_pool) :=
      { no_race_thr :
          forall i j (cnti: containsThread tp i) (cntj: containsThread tp j)
            (Hneq: i <> j),
            permMapsDisjoint2 (getThreadR cnti)
                              (getThreadR cntj); 
        no_race_lr:
          forall laddr1 laddr2 rmap1 rmap2
            (Hneq: laddr1 <> laddr2)
            (Hres1: lockRes tp laddr1 = Some rmap1)
            (Hres2: lockRes tp laddr2 = Some rmap2),
            permMapsDisjoint2 rmap1 rmap2; 
        no_race:
          forall i laddr (cnti: containsThread tp i) rmap
            (Hres: lockRes tp laddr = Some rmap),
            permMapsDisjoint2 (getThreadR cnti) rmap; 
        thread_data_lock_coh:
          forall i (cnti: containsThread tp i),
            (forall j (cntj: containsThread tp j),
                permMapCoherence (getThreadR cntj).1 (getThreadR cnti).2) /\
            (forall laddr rmap,
                lockRes tp laddr = Some rmap ->
                permMapCoherence rmap.1 (getThreadR cnti).2);
        locks_data_lock_coh:
          forall laddr rmap
            (Hres: lockRes tp laddr = Some rmap),
            (forall j (cntj: containsThread tp j),
                permMapCoherence (getThreadR cntj).1 rmap.2) /\
            (forall laddr' rmap',
                lockRes tp laddr' = Some rmap' ->
                permMapCoherence rmap'.1 rmap.2);
        lockRes_valid: lr_valid (lockRes tp) 
      }.

    Inductive dry_step {tid0 tp m} (cnt: containsThread tp tid0)
              (Hcompatible: mem_compatible tp m) :
      thread_pool -> mem -> seq.seq mem_event -> Prop :=
    | step_dry :
        forall (tp':thread_pool) c m1 m' (c' : C) ev
          
          (Hrestrict_pmap: restrPermMap (Hcompatible tid0 cnt).1 = m1)
          (Hinv: invariant tp)
          (Hcode: getThreadC cnt = Krun c)
          (Hcorestep: ev_step semSem c m1 ev c' m')
                    (Htp': tp' = updThread cnt (Krun c') (getCurPerm m', (getThreadR cnt).2)),
          dry_step cnt Hcompatible tp' m' ev.

    Definition option_function {A B} (opt_f: option (A -> B)) (x:A): option B:=
      match opt_f with
        Some f => Some (f x)
      | None => None
      end.
    Infix "??" := option_function (at level 80, right associativity).

    Definition build_delta_content (dm: delta_map) (m:mem): delta_content :=
      PTree.map (fun b dm_f =>
                   fun ofs =>
                     match dm_f ofs with
                     | None | Some (None) 
                     | Some (Some Nonempty) => None
                     | Some _ => Some (ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m)))
                     end) dm.
    
    Inductive ext_step {isCoarse:bool} {tid0 tp m}
              (cnt0:containsThread tp tid0)(Hcompat:mem_compatible tp m):
      thread_pool -> mem -> sync_event -> Prop :=
    | step_acquire :
        forall (tp' tp'':thread_pool) marg m0 m1 c m' b ofs
          (pmap : lock_info)
          (pmap_tid' : access_map)
          (virtueThread : delta_map * delta_map)
          (Hbounded: if isCoarse then
                       ( sub_map virtueThread.1 (getMaxPerm m).2 /\
                         sub_map virtueThread.2 (getMaxPerm m).2)
                     else
                       True ),
          let newThreadPerm := (computeMap (getThreadR cnt0).1 virtueThread.1,
                                computeMap (getThreadR cnt0).2 virtueThread.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (LOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap0: restrPermMap (Hcompat tid0 cnt0).2 = m0)
            
            (Haccess: Mem.range_perm m0 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
            
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.one))
            
            (Hset_perm: setPermBlock (Some Writable)
                                     b (Ptrofs.intval ofs) ((getThreadR cnt0).2) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
            (Hrestrict_pmap: restrPermMap Hlt' = m1)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
            (HisLock: lockRes tp (b, Ptrofs.intval ofs) = Some pmap)
            (Hangel1: permMapJoin pmap.1 (getThreadR cnt0).1 newThreadPerm.1)
            (Hangel2: permMapJoin pmap.2 (getThreadR cnt0).2 newThreadPerm.2)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) newThreadPerm)
            
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) (empty_map, empty_map)),
            ext_step cnt0 Hcompat tp'' m'
                     (acquire (b, Ptrofs.intval ofs)
                              (Some (build_delta_content (fst virtueThread) m')))

    | step_release :
        forall (tp' tp'':thread_pool) marg m0 m1 c m' b ofs virtueThread virtueLP pmap_tid' rmap
          (Hbounded: if isCoarse then
                       ( sub_map virtueThread.1 (getMaxPerm m).2 /\
                         sub_map virtueThread.2 (getMaxPerm m).2)
                     else
                       True )
          (HboundedLP: if isCoarse then
                         ( map_empty_def virtueLP.1 /\
                           map_empty_def virtueLP.2 /\
                           sub_map virtueLP.1.2 (getMaxPerm m).2 /\
                           sub_map virtueLP.2.2 (getMaxPerm m).2)
                       else
                         True ),
          let newThreadPerm := (computeMap (getThreadR cnt0).1 virtueThread.1,
                                computeMap (getThreadR cnt0).2 virtueThread.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg =
                           Some (UNLOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap0: restrPermMap (Hcompat tid0 cnt0).2 = m0)
            
            (Haccess: Mem.range_perm m0 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.zero))
            
            (Hset_perm: setPermBlock (Some Writable)
                                     b (Ptrofs.intval ofs) ((getThreadR cnt0).2) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
            (Hrestrict_pmap: restrPermMap Hlt' = m1)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.one) = Some m')
            (HisLock: lockRes tp (b, Ptrofs.intval ofs) = Some rmap)
            (Hrmap: forall b ofs, rmap.1 !! b ofs = None /\ rmap.2 !! b ofs = None)
            (Hangel1: permMapJoin newThreadPerm.1 virtueLP.1 (getThreadR cnt0).1)
            (Hangel2: permMapJoin newThreadPerm.2 virtueLP.2 (getThreadR cnt0).2)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef)
                                   (computeMap (getThreadR cnt0).1 virtueThread.1,
                                    computeMap (getThreadR cnt0).2 virtueThread.2))
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) virtueLP),
            ext_step cnt0 Hcompat tp'' m'
                     (release (b, Ptrofs.intval ofs)
                              (Some (build_delta_content (fst virtueThread) m')))
    | step_create :
        forall (tp_upd tp':thread_pool) c marg b ofs arg virtue1 virtue2
          (Hbounded: if isCoarse then
                       ( sub_map virtue1.1 (getMaxPerm m).2 /\
                         sub_map virtue1.2 (getMaxPerm m).2)
                     else
                       True )
          (Hbounded_new: if isCoarse then
                           ( sub_map virtue2.1 (getMaxPerm m).2 /\
                             sub_map virtue2.2 (getMaxPerm m).2)
                         else
                           True ),
          let threadPerm' := (computeMap (getThreadR cnt0).1 virtue1.1,
                              computeMap (getThreadR cnt0).2 virtue1.2) in
          let newThreadPerm := (computeMap empty_map virtue2.1,
                                computeMap empty_map virtue2.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (CREATE, Vptr b ofs::arg::nil))
            (Harg: Val.inject (Mem.flat_inj (Mem.nextblock m)) arg arg)
                        (Hangel1: permMapJoin newThreadPerm.1 threadPerm'.1 (getThreadR cnt0).1)
            (Hangel2: permMapJoin newThreadPerm.2 threadPerm'.2 (getThreadR cnt0).2)
            (Htp_upd: tp_upd = updThread cnt0 (Kresume c Vundef) threadPerm')
            (Htp': tp' = addThread tp_upd (Vptr b ofs) arg newThreadPerm),
            ext_step cnt0 Hcompat tp' m
                     (spawn (b, Ptrofs.intval ofs)
                            (Some (build_delta_content (fst virtue1) m))
                            (Some (build_delta_content (fst virtue2) m)))

    | step_mklock :
        forall  (tp' tp'': thread_pool) marg m1 c m' b ofs pmap_tid',
          let: pmap_tid := getThreadR cnt0 in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (MKLOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).1 = m1)
            
            (Hfreeable: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Writable)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
            
            (Hdata_perm: setPermBlock
                           (Some Nonempty)
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.1
                           LKSIZE_nat = pmap_tid'.1)
            
            (Hlock_perm: setPermBlock
                           (Some Writable)
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.2
                           LKSIZE_nat = pmap_tid'.2)
            
            (HlockRes: lockRes tp (b, Ptrofs.intval ofs) = None)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) pmap_tid')
            
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) (empty_map, empty_map)),
            ext_step cnt0 Hcompat tp'' m' (mklock (b, Ptrofs.intval ofs))

    | step_freelock :
        forall  (tp' tp'': thread_pool) c marg b ofs pmap_tid' m1 pdata rmap
           (Hbounded: if isCoarse then
                        ( bounded_maps.bounded_nat_func' pdata LKSIZE_nat)
                      else
                        True ),
          let: pmap_tid := getThreadR cnt0 in
          forall
            (Hinv: invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (FREE_LOCK, Vptr b ofs::nil))
            
            (His_lock: lockRes tp (b, (Ptrofs.intval ofs)) = Some rmap)
            
            (Hrmap: forall b ofs, rmap.1 !! b ofs = None /\ rmap.2 !! b ofs = None)
            
            (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).2 = m1)
            
            (Hfreeable: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Writable)
            
            (Hlock_perm: setPermBlock
                           None
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.2
                           LKSIZE_nat = pmap_tid'.2)
            
            (Hneq_perms: forall i,
                (0 <= Z.of_nat i < LKSIZE)%Z ->
                Mem.perm_order'' (pdata (S i)) (Some Writable)
            )
            
            (Hdata_perm: setPermBlock_var 
                           pdata
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.1
                           LKSIZE_nat = pmap_tid'.1)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) pmap_tid')
            (Htp'': tp'' = remLockSet tp' (b, Ptrofs.intval ofs)),
            ext_step cnt0 Hcompat  tp'' m (freelock (b, Ptrofs.intval ofs))
    | step_acqfail :
        forall  c b ofs marg m1
           (Hinv : invariant tp)
           (Hcode: getThreadC cnt0 = Kblocked c)
           
           (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
           (Hat_external: semantics.at_external semSem c marg = Some (LOCK, Vptr b ofs::nil))
           
           (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).2 = m1)
           
           (Haccess: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
           
           (Hload: Mem.load Mint32 m1 b (Ptrofs.intval ofs) = Some (Vint Int.zero)),
          ext_step cnt0 Hcompat tp m (failacq (b, Ptrofs.intval ofs)).

    Definition threadStep: forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> seq.seq mem_event -> Prop:=
      @dry_step.

    Lemma threadStep_at_Krun:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        (exists q, @getThreadC _ _ _ i tp cnt = Krun q).
    
    Lemma threadStep_equal_run:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        forall j,
          (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
          (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Definition syncStep (isCoarse:bool) :
      forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> sync_event -> Prop:=
      @ext_step isCoarse.

    Lemma syncstep_equal_run:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall j,
          (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
          (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Lemma syncstep_not_running:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q.

    Definition initial_machine pmap c := mkPool (Krun c) (pmap, empty_map).

    Definition init_mach (pmap : option res) (m: mem)
               (ms:thread_pool) (m' : mem) (v:val) (args:list val) : Prop :=
      exists c, semantics.initial_core semSem 0 m c m' v args /\
           ms = mkPool (Krun c) (getCurPerm m', empty_map).
    Set Printing All.
    Section HybDryMachineLemmas.

      Lemma build_delta_content_restr: forall d m p Hlt,
        build_delta_content d (@restrPermMap p m Hlt) = build_delta_content d m.

      Lemma threads_canonical:
        forall ds m i (cnt:containsThread ds i),
          mem_compatible ds m ->
          isCanonical (getThreadR cnt).1 /\
      
    End HybDryMachineLemmas.

    Definition install_perm tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) m' :=
      m' = restrPermMap (Hcmpt tid Hcnt).1.

    Definition add_block tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) m' :=
      (getCurPerm m', (getThreadR Hcnt).2).

    Instance DryHybridMachineSig: @HybridMachineSig.MachineSig dryResources Sem tpool :=
      (@HybridMachineSig.Build_MachineSig dryResources Sem tpool
                             richMem
                             dryMem
                             mem_compatible
                             invariant
                             install_perm
                             add_block
                             (@threadStep)
                             threadStep_at_Krun
                             threadStep_equal_run
                             (@syncStep)
                             syncstep_equal_run
                             syncstep_not_running
                             init_mach
      ).

  End DryHybridMachine.
End DryHybridMachine.

Export DryHybridMachine. *)

Require Import VST.concurrency.compiler.HybridMachine_simulation.
(* VST.concurrency.compiler.HybridMachine_simulation:
Require Import compcert.common.Memory.
Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Require Import VST.msl.Axioms.
Require Import Coq.ZArith.ZArith.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.event_semantics.
Require Export VST.concurrency.common.semantics.
Require Export VST.concurrency.common.lksize.
Require Import VST.concurrency.common.threadPool. Export threadPool.

Require Import VST.concurrency.common.machine_semantics.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.bounded_maps.
Require Import VST.concurrency.common.addressFiniteMap.

Require Import VST.concurrency.common.scheduler.
Require Import Coq.Program.Program.

Require Import VST.concurrency.compiler.safety.

Require Import VST.concurrency.compiler.coinductive_safety.

Require Import VST.concurrency.common.HybridMachineSig.

Require Import VST.veric.res_predicates.

Require Import VST.concurrency.common.HybridMachine.

Require Import VST.concurrency.compiler.CoreSemantics_sum.

Require Import compcert.common.Smallstep.

Require Import VST.concurrency.common.machine_semantics_lemmas.

Import Events.

Set Implicit Arguments.

Section HybridSimulation. 

  Context (SG TG TID SCH SC TC R1 R2 : Type).
  Variable SourceHybridMachine: @ConcurSemantics SG TID SCH (list machine_event) SC mem R1.
  Variable TargetHybridMachine: @ConcurSemantics TG TID SCH (list machine_event) TC mem R2.
  Variable opt_init_mem_source : option Memory.Mem.mem.
  Variable opt_init_mem_target : option Memory.Mem.mem.

  Inductive inject_address (f : meminj) : address -> address -> Prop :=
  | inj_addr : forall b1 o1 b2 ofs, f b1 = Some (b2, ofs) ->
      inject_address f (b1, o1) (b2, o1 + ofs).

  Inductive inject_sync_event (f : meminj) : sync_event -> sync_event -> Prop :=
  | inj_release : forall l1 l2 r1 r2, inject_address f l1 l2 ->
      match r1, r2 with
      | Some (a1), Some (a2) => inject_delta_content f a1 a2
      | None, None => True
      | _, _ => False
      end ->
      inject_sync_event f (release l1 r1) (release l2 r2)
  | inj_acquire : forall l1 l2 r1 r2, inject_address f l1 l2 ->
      match r1, r2 with
      | Some (a1), Some (a2) => inject_delta_content f a1 a2
      | None, None => True
      | _, _ => False
      end ->
      inject_sync_event f (acquire l1 r1) (acquire l2 r2)
  | inj_mklock : forall l1 l2, inject_address f l1 l2 ->
      inject_sync_event f (mklock l1) (mklock l2)
  | inj_freelock : forall l1 l2, inject_address f l1 l2 ->
      inject_sync_event f (freelock l1) (freelock l2)
  | inj_spawn : forall l1 l2 r1 r1' r2 r2', inject_address f l1 l2 ->
      match r1, r2 with
      | Some a1, Some a2 =>
          inject_delta_content f a1 a2
      | None, None => True
      | _, _ => False
      end ->
      match r1', r2' with
      | Some a1', Some a2' =>
          inject_delta_content f a1' a2'
      | None, None => True
      | _, _ => False
      end ->
      inject_sync_event f (spawn l1 r1 r1') (spawn l2 r2 r2')
  | inj_failacq : forall l1 l2, inject_address f l1 l2 ->
      inject_sync_event f (failacq l1) (failacq l2).

  Parameter inject_mem_event : meminj -> mem_event -> mem_event -> Prop.

  Inductive inject_mevent (f : meminj) : machine_event -> machine_event -> Prop :=
  | inj_internal : forall n me1 me2, inject_mem_event f me1 me2 ->
      inject_mevent f (internal n me1) (internal n me2)
  | inj_external : forall n se1 se2, inject_sync_event f se1 se2 ->
      inject_mevent f (external n se1) (external n se2).

  Record HybridMachine_simulation_properties
         (index: Type)(match_state : index -> meminj -> SC -> mem -> TC -> mem -> Prop) :=
    { core_ord : index -> index -> Prop
      ; core_ord_wf : well_founded core_ord

      ; initial_setup :
          forall  s_mem s_mem' main main_args s_mach_state r1,
            
            machine_semantics.initial_machine SourceHybridMachine r1 s_mem s_mach_state s_mem' main main_args ->
            exists j cd t_mach_state t_mem t_mem' r2,
              machine_semantics.initial_machine TargetHybridMachine r2 t_mem t_mach_state t_mem' main main_args
           /\ match_state cd j s_mach_state s_mem' t_mach_state t_mem'
      ; thread_diagram :
          forall sge tge U tr1 st1 m1 st1' m1',
            thread_step SourceHybridMachine sge U st1 m1 st1' m1' ->
            forall cd tr2 st2 mu m2,
              match_state cd mu st1 m1 st2 m2 ->
              Forall2 (inject_mevent mu) tr1 tr2 ->
              exists st2', exists m2', exists cd', exists mu',
                      match_state cd' mu' st1' m1' st2' m2'
                      /\ Forall2 (inject_mevent mu') tr1 tr2
                      /\ (thread_step_plus (TargetHybridMachine) tge U st2 m2 st2' m2'
               \/ (thread_step_star (TargetHybridMachine) tge U st2 m2 st2' m2' /\ core_ord cd' cd))
      ; machine_diagram :
          forall sge tge U tr1 st1 m1 U' tr1' st1' m1',
            machine_step SourceHybridMachine sge U tr1 st1 m1 U' tr1' st1' m1' ->
            forall cd tr2 st2 mu m2,
              match_state cd mu st1 m1 st2 m2 ->
              Forall2 (inject_mevent mu) tr1 tr2 ->
              exists tr2', exists st2', exists m2', exists cd', exists mu',
                      match_state cd' mu' st1' m1' st2' m2'
                      /\ Forall2 (inject_mevent mu') tr1' tr2'
                      /\ machine_step (TargetHybridMachine) tge U tr2 st2 m2 U' tr2' st2' m2'
      ; thread_halted :
          forall cd mu U c1 m1 c2 m2 v1,
            match_state cd mu c1 m1 c2 m2 ->
            conc_halted SourceHybridMachine U c1 = Some v1 ->
            exists v2,
              conc_halted TargetHybridMachine U c2 = Some v2
      ; thread_running:
          forall cd mu c1 m1 c2 m2 ,
            match_state cd mu c1 m1 c2 m2 ->
            forall i, running_thread SourceHybridMachine c1 i <-> running_thread TargetHybridMachine c2 i
    }.

  Record HybridMachine_simulation:=
    { index: Type
      ; match_state : index -> meminj -> SC -> mem -> TC -> mem -> Prop
      ; SIM:> @HybridMachine_simulation_properties index match_state}.

End HybridSimulation. *)



Require Import VST.concurrency.compiler.Clight_self_simulation.
(* VST.concurrency.compiler.Clight_self_simulation:
Require Import compcert.lib.Coqlib.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Maps.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.
Require Import compcert.cfrontend.Ctypes.
Require Import compcert.cfrontend.Cop.
Require Import compcert.cfrontend.Clight.

Require Import VST.veric.Clight_core.

Require Import VST.concurrency.compiler.self_simulation.
Require Import VST.veric.Clight_core.

Set Bullet Behavior "Strict Subproofs".

Section ClightSelfSim.
  
  Context (ge: genv).
  Lemma clight_self_simulation:
    self_simulation _ (cl_core_sem ge).

End ClightSelfSim. *)

Require Import VST.concurrency.compiler.Asm_self_simulation.
(* VST.concurrency.compiler.Asm_self_simulation:
Require Import compcert.x86.Asm.

Require Import VST.concurrency.compiler.self_simulation.

Require Import VST.concurrency.common.Asm_core.

Section AsmSelfSim.

  Context (ge:genv).
  Lemma Asm_self_simulation:
    self_simulation _ (Asm_core_sem ge).

End AsmSelfSim. *)



Require Import VST.concurrency.memsem_lemmas.
(* VST.concurrency.memsem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.
Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.mem_lemmas.
Require Import VST.concurrency.common.core_semantics.

Require Import VST.msl.Coqlib2.

Lemma mem_step_refl m: mem_step m m.

Lemma mem_step_free:
      forall m b lo hi m', Mem.free m b lo hi = Some m' -> mem_step m m'.

Lemma mem_step_store:
      forall m ch b a v m', Mem.store ch m b a v = Some m' -> mem_step m m'.

Record memstep_preserve (P:mem -> mem -> Prop) :=
  {
    preserve_trans: forall m1 m2 m3, P m1 m2 -> P m2 m3 -> P m1 m3;
    preserve_mem: forall m m', mem_step m m' -> P m m'
  }.

Lemma preserve_refl {P} (HP: memstep_preserve P): forall m, P m m.

Lemma preserve_free {P} (HP: memstep_preserve P):
      forall m b lo hi m', Mem.free m b lo hi = Some m' -> P m m'.

Theorem preserve_conj {P Q} (HP:memstep_preserve P) (HQ: memstep_preserve Q):
        memstep_preserve (fun m m' => P m m' /\ Q m m').

Theorem preserve_impl {A} (P:A -> mem -> mem -> Prop) (Q:A->Prop):
        (forall a, Q a -> memstep_preserve (P a)) -> memstep_preserve (fun m m' => forall a, Q a -> P a m m').

Lemma preserve_exensional {P Q} (HP:memstep_preserve P) (PQ:P=Q): memstep_preserve Q.

Theorem preserve_univ {A} (P:A -> mem -> mem -> Prop):
        (forall a, memstep_preserve (P a)) -> memstep_preserve (fun m m' => forall a, P a m m').

Theorem mem_forward_preserve: memstep_preserve mem_forward.

Theorem readonly_preserve b: memstep_preserve (fun m m' => mem_forward m m' /\ (Mem.valid_block m b -> readonly m b m')).

Theorem readonly_preserve':
   memstep_preserve (fun m m' => mem_forward m m' /\ (forall b, Mem.valid_block m b -> readonly m b m')).

Lemma storebytes_unch_loc_unwritable b ofs: forall l m m' (L: Mem.storebytes m b ofs l = Some m'),

Lemma unch_on_loc_not_writable_trans m1 m2 m3
        (Q : Mem.unchanged_on (loc_not_writable m1) m1 m2)

Theorem loc_not_writable_preserve:
   memstep_preserve (fun m m' => mem_forward m m' /\ Mem.unchanged_on (loc_not_writable m) m m').

Lemma freelist_perm: forall l m m' (L : Mem.free_list m l = Some m') b (B: Mem.valid_block m b)

Theorem perm_preserve:
   memstep_preserve (fun m m' =>  mem_forward m m' /\ forall b, Mem.valid_block m b -> forall ofs, Mem.perm m' b ofs Max Nonempty ->

Lemma mem_step_forward m m': mem_step m m' -> mem_forward m m'.

Lemma freelist_perm_inv: forall l m m' (L : Mem.free_list m l = Some m') b (B: Mem.valid_block m b)

Theorem preserves_max_eq_or_free:
   memstep_preserve (fun m m' =>  mem_forward m m' /\
                                  forall b (VB: Mem.valid_block m b) ofs,

Theorem mem_step_max_eq_or_free m m' (STEP: mem_step m m') b (VB: Mem.valid_block m b) ofs:

Lemma memsem_preserves {C} (s: @MemSem C) P (HP:memstep_preserve P):
      forall c m c' m', corestep s c m c' m'-> P m m'.

Lemma corestep_fwd {C} (s:@MemSem C) c m c' m'
   (CS:corestep s c m c' m' ): mem_forward m m'.

Lemma corestep_rdonly {C} (s:@MemSem C) c m c' m'
   (CS:corestep s c m c' m') b (VB:Mem.valid_block m b): readonly m b m'.

Lemma mem_step_nextblock:  memstep_preserve (fun m m' => Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma mem_step_nextblock':
  forall m m',
     mem_step m m' ->
   (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma mem_step_obeys_cur_write:
  forall m b ofs m',
    Mem.valid_block m b ->

Lemma ple_load m ch a v
            (LD: Mem.loadv ch m a = Some v)

Lemma ple_store:
  forall ch m v1 v2 m' m1
   (PLE: perm_lesseq m m1),
   Mem.storev ch m v1 v2 = Some m' ->

Lemma free_access_inv m b lo hi m' (FR: Mem.free m b lo hi = Some m') b' ofs k p

Lemma free_access_inv_None m b lo hi m' (FR: Mem.free m b lo hi = Some m') b' ofs k

Lemma ple_free: forall m m' b lo hi (FL: Mem.free m b lo hi = Some m') m1 (PLE:perm_lesseq m m1),

Lemma ple_freelist: forall l m m' (FL: Mem.free_list m l = Some m') m1 (PLE:perm_lesseq m m1),

Lemma ple_storebytes:
  forall m b ofs bytes m' m1
   (PLE: perm_lesseq m m1),
   Mem.storebytes m b ofs bytes = Some m' ->

Lemma ple_loadbytes m b ofs n bytes
            (LD: Mem.loadbytes m b ofs n = Some bytes)

Lemma alloc_access_inv m b lo hi m' (ALLOC: Mem.alloc m lo hi = (m', b)) b' ofs k p

Lemma alloc_access_inv_None m b lo hi m' (ALLOC: Mem.alloc m lo hi = (m', b)) b' ofs k

Lemma alloc_inc_perm: forall m lo hi m' b
      (M: Mem.alloc m lo hi = (m',b)) m1 (PLE: perm_lesseq m m1),

Lemma perm_lesseq_refl:
  forall m, perm_lesseq m m.

Definition corestep_fun {C M : Type} (sem : @CoreSemantics C M) :=
  forall (m m' m'' : M) c c' c'',
  corestep sem c m c' m' ->
  corestep sem c m c'' m'' ->
  c'=c'' /\ m'=m''.

Section corestepN.
  Context {C M E:Type} (Sem:@CoreSemantics C M).

  Fixpoint corestepN (n:nat) : C -> M -> C -> M -> Prop :=
    match n with
      | O => fun c m c' m' => (c,m) = (c',m')
      | S k => fun c1 m1 c3 m3 => exists c2, exists m2,
        corestep Sem c1 m1 c2 m2 /\
        corestepN k c2 m2 c3 m3
    end.

  Lemma corestepN_add : forall n m c1 m1 c3 m3,
    corestepN (n+m) c1 m1 c3 m3 <->
    exists c2, exists m2,
      corestepN n c1 m1 c2 m2 /\
      corestepN m c2 m2 c3 m3.

  Definition corestep_plus c m c' m' :=
    exists n, corestepN (S n) c m c' m'.

  Definition corestep_star c m c' m' :=
    exists n, corestepN n c m c' m'.

  Lemma corestep_plus_star : forall c1 c2 m1 m2,
    corestep_plus c1 m1 c2 m2 -> corestep_star c1 m1 c2 m2.

  Lemma corestep_plus_trans : forall c1 c2 c3 m1 m2 m3,
    corestep_plus c1 m1 c2 m2 -> corestep_plus c2 m2 c3 m3 ->
    corestep_plus c1 m1 c3 m3.

  Lemma corestep_star_plus_trans : forall c1 c2 c3 m1 m2 m3,
    corestep_star c1 m1 c2 m2 -> corestep_plus c2 m2 c3 m3 ->
    corestep_plus c1 m1 c3 m3.

  Lemma corestep_plus_star_trans: forall c1 c2 c3 m1 m2 m3,
    corestep_plus c1 m1 c2 m2 -> corestep_star c2 m2 c3 m3 ->
    corestep_plus c1 m1 c3 m3.

  Lemma corestep_star_trans: forall c1 c2 c3 m1 m2 m3,
    corestep_star c1 m1 c2 m2 -> corestep_star c2 m2 c3 m3 ->
    corestep_star c1 m1 c3 m3.

  Lemma corestep_plus_one: forall c m c' m',
    corestep Sem c m c' m' -> corestep_plus c m c' m'.

  Lemma corestep_plus_two: forall c m c' m' c'' m'',
    corestep Sem c m c' m' -> corestep Sem c' m' c'' m'' ->
    corestep_plus c m c'' m''.

  Lemma corestep_star_zero: forall c m, corestep_star  c m c m.

  Lemma corestep_star_one: forall c m c' m',
    corestep  Sem c m c' m' -> corestep_star c m c' m'.

  Lemma corestep_plus_split: forall c m c' m',
    corestep_plus c m c' m' ->
    exists c'', exists m'', corestep  Sem c m c'' m'' /\
      corestep_star c'' m'' c' m'.

End corestepN.

Section memstepN.
  Context {C:Type} (M:@MemSem C).

Lemma corestepN_mem n: forall c m c' m', corestepN M n c m c' m' -> mem_step m m'.

Lemma corestep_plus_mem c m c' m' (H:corestep_plus M c m c' m'): mem_step m m'.

Lemma corestep_star_mem c m c' m' (H:corestep_star M c m c' m'): mem_step m m'.

Lemma memsem_preservesN P (HP: memstep_preserve P)
      n c m c' m' (H: corestepN M n c m c' m'): P m m'.

Lemma memsem_preserves_plus P (HP:memstep_preserve P)
      c m c' m' (H: corestep_plus M c m c' m'): P m m'.

Lemma memsem_preserves_star P (HP:memstep_preserve P)
      c m c' m' (H: corestep_star M c m c' m'): P m m'.

Lemma corestepN_fwd n  c m c' m'
   (CS:corestepN M n c m c' m'): mem_forward m m'.

Lemma corestep_plus_fwd c m c' m'
   (CS:corestep_plus M c m c' m'): mem_forward m m'.

Lemma corestep_star_fwd c m c' m'
   (CS:corestep_star M c m c' m'): mem_forward m m'.

Lemma corestepN_rdonly n c m c' m'
    (CS:corestepN M n c m c' m') b (VB:Mem.valid_block m b): readonly m b m'.

Lemma corestep_plus_rdonly c m c' m'
   (CS:corestep_plus M c m c' m') b (VB:Mem.valid_block m b): readonly m b m'.

Lemma corestep_star_rdonly c m c' m'
   (CS:corestep_star M c m c' m')b (VB:Mem.valid_block m b): readonly m b m'.

End memstepN. *)

Import BinNums.

Import BinInt.

Import List.

Import Integers.

Import Ptrofs.



Set Bullet Behavior "Strict Subproofs".



Require Import VST.concurrency.common.ClightMachine.
(* VST.concurrency.common.ClightMachine:
Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import ProofIrrelevance.

Require Import VST.concurrency.common.scheduler.

Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.

Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.erased_machine.

Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.sepcomp.event_semantics.

Require Import VST.concurrency.common.ClightSemanticsForMachines.
Require Import VST.concurrency.common.Clight_bounds.

From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Require Import VST.concurrency.common.ssromega. 
Set Bullet Behavior "Strict Subproofs".

Import threadPool.

Module Clight_newMachine.

  Import HybridMachineSig.

  Module DMS.
  Section DMS.

  Context {ge : Clight.genv}.
  Existing Instance OrdinalPool.OrdinalThreadPool.
  Instance DSem : Semantics := Clight_newSem ge.

  Definition ClightMachine :=(HybridCoarseMachine.HybridCoarseMachine
                                 (machineSig := DryHybridMachine.DryHybridMachineSig)).
  Definition ClightMachineSem := (MachineSemantics(HybridMachine := ClightMachine)).
  Definition ClightConcurSem := (ConcurMachineSemantics(HybridMachine := ClightMachine)).   
  End DMS.
  End DMS.
End Clight_newMachine.

Module ClightMachine.

  Import HybridMachineSig.

  Module DMS.
  Section DMS.

  Context {ge : Clight.genv}.
  Existing Instance OrdinalPool.OrdinalThreadPool.
  Instance DSem : Semantics := ClightSem ge.

  Definition ClightMachine :=(HybridCoarseMachine.HybridCoarseMachine
                                 (machineSig := DryHybridMachine.DryHybridMachineSig)).
  Definition ClightMachineSem := (MachineSemantics(HybridMachine := ClightMachine)).
  Definition ClightConcurSem := (ConcurMachineSemantics(HybridMachine := ClightMachine)).   
  End DMS.
  End DMS.
End ClightMachine.

Module FiniteBranching.

  End FiniteBranching. *)



Require Import VST.concurrency.common.x86_context.
(* VST.concurrency.common.x86_context:
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.erased_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.memory_lemmas.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.Asm_core.
Require Import VST.concurrency.common.Asm_event.
Require Import VST.concurrency.common.dry_context.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.

Set Bullet Behavior "None".
Set Bullet Behavior "Strict Subproofs".

Module X86Context.
  Import AsmContext.
  
  Section X86Context.

    Context {the_program: Asm.program}.

    Definition the_ge := Globalenvs.Genv.globalenv the_program.
    Context {Hsafe : safe_genv the_ge}.

    Instance X86Sem: Semantics:=
      { semG:= Asm.genv;
         semC:= Asm.state;
         semSem:= Asm_EvSem the_ge Hsafe;
         the_ge := the_ge
      }.

  Import AsmContext.
  Definition AsmHybridMachine    := @dryCoarseMach X86Sem.
  Definition AsmConcurSem    := HybridMachineSig.HybridMachineSig.ConcurMachineSemantics
                                  (HybridMachine:= AsmHybridMachine).

  Import AsmContext.
  Definition AsmFineHybridMachine    := @dryFineMach X86Sem.
  Definition AsmFineConcurSem    := HybridMachineSig.HybridMachineSig.ConcurMachineSemantics
                                  (HybridMachine:= AsmFineHybridMachine).

  Definition Asm_initial_state := tpc_init(asmSem:=X86Sem).
  Definition Asm_initial_state_fine := tpf_init(asmSem:=X86Sem).
  Definition Asm_initial_state_bare := bare_init(asmSem:=X86Sem).
  
  End X86Context.
End X86Context.

Module X86SEMAxioms.

  Import Asm Asm_core event_semantics semantics_lemmas
           X86Context Memory.

  Section X86Context.

    Context {initU: seq.seq nat}
            {the_program: Asm.program}.
    Notation the_ge := (@the_ge the_program).
    Context {Hsafe : safe_genv the_ge}.

    Instance X86Sem: Semantics := @X86Sem the_program Hsafe.

    Lemma corestep_det: corestep_fun semSem.
      
    Lemma mem_step_decay:
      forall m m',
        mem_step m m' ->
        decay m m'.

    Lemma exec_load_same_mem:
      forall ch m a rs rd rs' m',
        exec_load the_ge ch m a rs rd = Next rs' m' ->
        m=m'.

    Lemma exec_store_obeys_cur_write:
      forall ch m a rs rs0 d rs' m',
        exec_store the_ge ch m a rs rs0 d = Next rs' m' ->
        forall b ofs,
          Memory.Mem.valid_block m b ->
          ~ Memory.Mem.perm m b ofs Memtype.Cur Memtype.Writable ->
          ZMap.get ofs (PMap.get b (Memory.Mem.mem_contents m)) =
          ZMap.get ofs (PMap.get b (Memory.Mem.mem_contents m')).
    Proof.
      intros.
      unfold exec_store in H.
      destruct (Memory.Mem.storev ch m (eval_addrmode the_ge a rs) (rs rs0)) eqn:?; inv H.
      unfold Memory.Mem.storev in Heqo.
      destruct (eval_addrmode the_ge a rs); inv Heqo.
      symmetry;
        eapply MemoryLemmas.store_contents_other; eauto.

    Lemma mem_step_obeys_cur_write:
      forall m b ofs m',
        Memory.Mem.valid_block m b ->

    Lemma corestep_unchanged_on:
      forall c m
        c' m' b (ofs : Z),
        corestep semSem c m c' m' ->
        Memory.Mem.valid_block m b ->

    Lemma corestep_decay:
      forall c c' m m',
        corestep semSem c m c' m' -> decay m m'.

    Lemma corestep_nextblock :
      forall c m c' m',
        corestep semSem c m c' m' ->
        (Memory.Mem.nextblock m <= Memory.Mem.nextblock m')%positive.

    Lemma at_external_halted_excl:
      forall q m, semantics.at_external (@semSem X86Sem) q m = None \/ forall i, ~ halted semSem q i.

    Lemma initial_core_det:
      forall i m v args c c' m' m'',
        initial_core semSem i m c m' v args ->
        initial_core semSem i m c' m'' v args ->
        c = c' /\ m' = m''.
      
    Lemma make_arg_unchanged_on:
      forall rs m l arg rs' m'
        (Hmake_args: make_arg rs m l arg = Some (rs', m')),
        (forall b ofs, ~ Mem.perm m b ofs Cur Writable -> ZMap.get ofs (Mem.mem_contents m) !! b = ZMap.get ofs (Mem.mem_contents m') !! b) /\
        (forall b ofs k, permission_at m b ofs k = permission_at m' b ofs k) /\
        (forall b, Mem.valid_block m' b <-> Mem.valid_block m b).
    Proof.
      intros.
      unfold make_arg in *.
      destruct l.
      inv Hmake_args.
      repeat split; intros; auto.
      destruct (Mem.storev (AST.chunk_of_type ty) m (Values.Val.offset_ptr (rs RSP) (Integers.Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * pos))) arg) eqn:Hstorev;
        try discriminate.
      inv Hmake_args.
      eapply MemoryLemmas.mem_storev_store in Hstorev.
      destruct Hstorev as [b' [ofs' [? Hstore]]].
      split.
      - intros.
        symmetry.
          eapply MemoryLemmas.store_contents_other;

    Lemma make_arguments_unchanged_on:
      forall rs m args ls rs' m'
        (Hmake_args: make_arguments rs m ls args = Some (rs', m')),
        (forall b ofs, ~ Mem.perm m b ofs Cur Writable -> ZMap.get ofs (Mem.mem_contents m) !! b = ZMap.get ofs (Mem.mem_contents m') !! b) /\

    Lemma initial_core_unchanged_on :
      forall (i : nat) (v : Values.val) (args : list Values.val) (c : semC) (m m' : mem) (b : Values.block) (ofs : Z),
        initial_core semSem i m c m' v args ->
        Mem.valid_block m b -> ~ Mem.perm m b ofs Cur Writable -> ZMap.get ofs (Mem.mem_contents m) !! b = ZMap.get ofs (Mem.mem_contents m') !! b /\
                                                                forall k, permission_at m b ofs k = permission_at m' b ofs k.
    Proof.
      intros.
      unfold initial_core in H. simpl in H.
      destruct H.
      inv H.
      simpl.
      eapply MemoryLemmas.mem_storev_store in H6.
      destruct H6 as [? [? [? Hstore6]]].
      eapply MemoryLemmas.mem_storev_store in H5.
      destruct H5 as [? [? [? Hstore5]]].
      assert ( ~ Mem.perm m1 b ofs Cur Writable).
      { intros Hcontra.
        eapply H1.
        eapply Mem.perm_alloc_4; eauto.
        apply Mem.fresh_block_alloc in H4.
        intros ?; subst;
          now auto.
      }
      assert ( ~ Mem.perm m2 b ofs Cur Writable).
      { unfold Mem.perm in *.
        erewrite Mem.store_access with (m2:= m2) (m1 := m1) by eauto.
        assumption.
      }
      assert ( ~ Mem.perm m3 b ofs Cur Writable).
      { unfold Mem.perm in *.
        erewrite Mem.store_access with (m2:= m3) (m1 := m2) by eauto.
        assumption.
      } 
      eapply make_arguments_unchanged_on in H7; eauto.
      destruct H7 as [Hvaleq34 [Hpermeq34 _]].
      specialize (Hvaleq34 b ofs ltac:(eauto)).
      specialize (Hpermeq34 b ofs).
      erewrite <- Hvaleq34.
      erewrite MemoryLemmas.store_contents_other with (m' := m3); eauto. 
      erewrite MemoryLemmas.store_contents_other with (m' := m2); eauto.
      erewrite MemoryLemmas.val_at_alloc_1; eauto.
      split; [reflexivity|].
      intros k.
      erewrite MemoryLemmas.permission_at_alloc_1 with (m' := m1) by eauto.

    Corollary initial_core_unchanged_on' :
      forall (i : nat) (v : Values.val) (args : list Values.val) (c : semC) (m m' : mem) (b : Values.block) (ofs : Z),
    
    Lemma initial_core_decay :
      forall (i : nat) (v : Values.val) (args : list Values.val) (c : semC) (m m' : mem),
        initial_core semSem i m c m' v args ->
        strong_decay m m'.
    Proof.
      intros.
      simpl in H.
      destruct H as [Hinit ?].
      subst.
      inv Hinit.
      simpl.
      split.
      - intros.
        eapply make_arguments_unchanged_on in H3; eauto.
        destruct H3 as [Hval3 [Hperm3 Hblock3]].
        unfold permission_at in Hperm3.
        eapply MemoryLemmas.mem_storev_store in H1.
        destruct H1 as [? [? [? Hstore1]]].
        eapply MemoryLemmas.mem_storev_store in H2.
        destruct H2 as [? [? [? Hstore2]]].
        assert (b0 = stk).
          { eapply Hblock3 in H5.
            eapply Mem.store_valid_block_2 in H5; eauto.
            eapply Mem.store_valid_block_2 in H5; eauto.
            eapply Mem.valid_block_alloc_inv in H0; eauto.
            destruct H0; [assumption | exfalso; now auto].
          }
          subst.
          destruct (Intv.In_dec ofs (0%Z,(3*size_chunk AST.Mptr))).
        + left.
          intros k.
          erewrite <- Hperm3.
          erewrite Mem.store_access with (m2 := m3) by eauto.
          erewrite Mem.store_access with (m2 := m2) by eauto.
          eapply MemoryLemmas.permission_at_alloc_2 in H0;
            now eauto.
        + right.
          intros k.
          erewrite <- Hperm3.
          erewrite Mem.store_access with (m2 := m3) by eauto.
          erewrite Mem.store_access with (m2 := m2) by eauto.
          eapply MemoryLemmas.permission_at_alloc_3 in H0;
            eauto.
          eapply Intv.range_notin in n; eauto.
          simpl.
          unfold AST.Mptr. destruct Archi.ptr64; simpl; omega.
      - intros Hvalid.
        eapply make_arguments_unchanged_on in H3; eauto.
        destruct H3 as [_ [Hperm3 Hblock3]].
        unfold permission_at in Hperm3.
        eapply MemoryLemmas.mem_storev_store in H1.
        destruct H1 as [? [? [? Hstore1]]].
        eapply MemoryLemmas.mem_storev_store in H2.
        destruct H2 as [? [? [? Hstore2]]].
        intros k.
        erewrite <- Hperm3.
        erewrite Mem.store_access with (m2 := m3) by eauto.
        erewrite Mem.store_access with (m2 := m2) by eauto.
        pose proof (MemoryLemmas.permission_at_alloc_1 _ _ _ _ _ _ ofs H0 Hvalid k) as Heq_perm.

    Lemma initial_core_nextblock :
      forall (i : nat) (v : Values.val) (args : list Values.val) (c : semC) (m m' : mem),

    Instance X86Axioms : CoreLanguage.SemAxioms :=
      { corestep_unchanged_on := corestep_unchanged_on;
        corestep_decay := corestep_decay;
        corestep_nextblock := corestep_nextblock;
        at_external_halted_excl := at_external_halted_excl;
        initial_core_unchanged_on := initial_core_unchanged_on';
        initial_core_decay := initial_core_decay;
        initial_core_nextblock := initial_core_nextblock
      }.

    Instance X86Det : CoreLanguage.SemDet :=
      { corestep_det := corestep_det;
        initial_core_det := initial_core_det
      }.

  End X86Context.
End X86SEMAxioms. *)



Module ThreadedSimulation (CC_correct: CompCert_correctness).

   

  Import HybridMachineSig.

  Import DryHybridMachine.



  Existing Instance OrdinalPool.OrdinalThreadPool.

  Existing Instance HybridMachineSig.HybridCoarseMachine.DilMem.



  Section ThreadedSimulation.

  

  Context (C_program: Clight.program).

  Definition Clight_g : Clight.genv := Clight.globalenv C_program.

  Definition CSem : Semantics := ClightSemanticsForMachines.ClightSem Clight_g.

  Definition Cself_simulation := clight_self_simulation Clight_g.

  Definition Clight_code_inject := self_simulation.code_inject _ _ Cself_simulation.

  Definition Clight_match := self_simulation.match_self Clight_code_inject.

  

  Import X86Context.

  

  Context (Asm_program: Asm.program).

  Definition Asm_g := (@the_ge Asm_program).

  Context (Asm_genv_safe: Asm_core.safe_genv (@the_ge Asm_program)).

  Definition Aself_simulation := Asm_self_simulation Asm_g.

  Definition Asm_code_inject := self_simulation.code_inject _ _ Aself_simulation.

  Definition Asm_match := self_simulation.match_self Asm_code_inject.



  Definition AsmSem : Semantics := @X86Sem Asm_program Asm_genv_safe.



  Instance HybridSem h : Semantics := CoreSem_Sum h CSem AsmSem.

  Existing Instance dryResources.

  Notation TP h := (threadPool.OrdinalPool.OrdinalThreadPool(Sem:=HybridSem h)).

  Existing Instance DryHybridMachineSig.

  Definition HybMachine h:=

    HybridMachineSig.HybridCoarseMachine.HybridCoarseMachine

      (ThreadPool:= TP h).

  Definition HybConcSem h:=

    HybridMachineSig.ConcurMachineSemantics(HybridMachine:=HybMachine h).

  Notation ThreadPool n :=

    (ThreadPool.t(Sem:= HybridSem n)).



  Context (compiled: 

             CC_correct.CompCert_compiler C_program = Some Asm_program).

  Definition compiler_sim:= CC_correct.simpl_clight_semantic_preservation _ _ compiled.

  Definition compiler_index: Type:= Injindex compiler_sim.

  Definition compiler_match (i:compiler_index) (j:meminj)

       (c1:  Smallstep.state (Smallstep.part_sem (Clight.semantics2 C_program)))

       (m1: mem)

       (c2: Smallstep.state (Asm.part_semantics Asm_g))

       (m2: mem): Prop

    := Injmatch_states compiler_sim i j

                       (Smallstep.set_mem c1 m1)

                       (Smallstep.set_mem c2 m2).



  Inductive compiler_match_padded:

    compiler_index -> meminj -> Smallstep.state (Smallstep.part_sem (Clight.semantics2 C_program)) ->

    mem -> Smallstep.state (Asm.part_semantics Asm_g) -> mem -> Prop

    :=

    | BuildCompilerMatch: forall cd j1 j2 j3 j s1 m1 s2 m2 s3 m3 s4 m4,

        Clight_match j1 s1 m1 s2 m2 ->

        compiler_match cd j2 s2 m2 s3 m3 ->

        Asm_match j3 s3 m3 s4 m4 ->

        compose_meminj (compose_meminj j1 j2) j3 = j ->

        compiler_match_padded cd j s1 m1 s4 m4.



  Section CompileOneThread.

    Import OrdinalPool.



    Context (hb: nat).

    Definition SemTop: Semantics:= (HybridSem (Some hb)).

    Definition SemBot: Semantics:= (HybridSem (Some (S hb))).

    

    Inductive match_state2match_thread

              {sem1 sem2: Semantics}

              (SState: @semC sem1 -> state_sum (@semC CSem) (@semC AsmSem))

              (TState: @semC sem2 -> state_sum (@semC CSem) (@semC AsmSem))

              (match_state : meminj -> @semC sem1 -> mem -> @semC sem2 -> mem -> Prop) :

    meminj ->

    @ctl (@semC SemTop) -> mem ->

    @ctl (@semC SemBot) -> mem -> Prop  :=

  | CThread_Running: forall j code1 m1 code2 m2,

      match_state j code1 m1 code2 m2 ->

      match_state2match_thread SState TState match_state j (Krun (SState code1)) m1

                            (Krun (TState code2)) m2

  | CThread_Blocked: forall j code1 m1 code2 m2,

      match_state j code1 m1 code2 m2 ->

      match_state2match_thread SState TState match_state j (Kblocked (SState code1)) m1

                            (Kblocked (TState code2)) m2

  | CThread_Resume: forall j code1 m1 code2 m2 v v',

      match_state2match_thread SState TState match_state j (Kresume (SState code1) v) m1

                            (Kresume (TState code2) v') m2

  | CThread_Init: forall j m1 m2 v1 v1' v2 v2',

      Val.inject j v1 v2 ->

      Val.inject j v1' v2' ->

      match_state2match_thread SState TState match_state j (Kinit v1 v1') m1

                               (Kinit v1 v1') m2.

    

    Definition SST := SState (@semC CSem) (@semC AsmSem).

    Definition TST := TState (@semC CSem) (@semC AsmSem).

    

    Definition match_thread_source:

      meminj -> @ctl (@semC SemTop) -> mem -> @ctl (@semC SemBot) -> mem -> Prop:=

      match_state2match_thread SST SST

                               Clight_match.

    Definition match_thread_target:

      meminj -> @ctl (@semC SemTop) -> mem -> @ctl (@semC SemBot) -> mem -> Prop:=

      match_state2match_thread TST TST

                               Asm_match.

    Definition match_thread_compiled cd:

      meminj -> @ctl (@semC SemTop) -> mem -> @ctl (@semC SemBot) -> mem -> Prop:=

      match_state2match_thread SST TST

                               (compiler_match_padded cd).



    Definition merge_func {A} (f1 f2:Z -> option A):

      (BinNums.Z -> option A):=

      fun ofs =>

        match f1 ofs with

          None => f2 ofs

        | _ => f1 ofs

        end.

    

    Fixpoint build_function_for_a_block

             (mu:meminj) {A} (b: positive) (ls: list (positive * (Z -> option A))):

      Z -> option A:=

      match ls with

      | nil => (fun _ => None)

      | (b0, fb)::ls' =>

        match mu b0 with

        | Some (b1, delt) =>

          if PMap.elt_eq b b1 then

            merge_func (fun p => (fb (p - delt)%Z)) (build_function_for_a_block mu b ls')

          else  (build_function_for_a_block mu b ls')

        | None => (build_function_for_a_block mu b ls') 

        end

      end.

    

    Definition tree_map_inject_over_tree {A B} (t:PTree.t (Z -> option B))(mu:meminj) (map:PTree.t (Z -> option A)):

      PTree.t (Z -> option A):=

      PTree.map (fun b _ => build_function_for_a_block mu b (PTree.elements map)) t.



    Definition tree_map_inject_over_mem {A} m mu map:

      PTree.t (Z -> option A) :=

      tree_map_inject_over_tree (snd (getMaxPerm m)) mu map.

    

    Fixpoint apply_injection_elements

             {A}

             (mu:meminj) (ls: list (positive * (Z -> option A)))

      : list (positive * (Z -> option A)) :=

      match ls with

        nil => nil

      | cons (b, ofs_f) ls' =>

        match (mu b) with

        | None => apply_injection_elements mu ls'

        | Some (b',d) =>

          cons

            (b', fun ofs => ofs_f (ofs-d)%Z)

            (apply_injection_elements mu ls')

        end

      end.

    Fixpoint extract_function_for_block

             {A} (b: positive) (ls: list (positive * (Z -> option A)))

      : Z -> option A :=

      match ls with

        nil => fun _ => None

      | cons (b', ofs_f') ls' =>

        if (Pos.eq_dec b b') then

          merge_func ofs_f' (extract_function_for_block b ls')

        else (extract_function_for_block b ls')

      end.



    Fixpoint map_from_list

             {A:Type}

             (mu:meminj) (ls: list (positive * (Z -> option A))):

      PTree.t (Z -> option A) :=

      match ls with

        nil => @PTree.empty (BinNums.Z -> option A)

      | cons (b, ofs_f) ls =>

        let t:= map_from_list mu ls in

        match mu b with

          None => t

        | Some (b',d) =>

          match PTree.get b' t with

            None => PTree.set b' (fun ofs => ofs_f (ofs-d)%Z) t

          | Some f_old =>

            PTree.set b' (merge_func (fun ofs => ofs_f (ofs-d)%Z) f_old) t

          end

        end

      end.



    Definition tree_map_inject {A}(mu:meminj) (map:PTree.t (Z -> option A)):

      PTree.t (Z -> option A):=

      map_from_list mu (PTree.elements map).

    Definition virtueThread_inject m (mu:meminj) (virtue:delta_map * delta_map):

      delta_map * delta_map:=

      let (m1,m2):= virtue in

      (tree_map_inject_over_mem m mu m1, tree_map_inject_over_mem m mu m2).

    

    Definition access_map_inject m (mu:meminj) (map:access_map):

      access_map:=

      (fst map, tree_map_inject_over_mem m mu (snd map)).

    Definition virtueLP_inject m (mu:meminj) (virtue:access_map * access_map):

      access_map * access_map:=

      (access_map_inject m mu (fst virtue), access_map_inject m mu (snd virtue)).

    

    Record concur_match (ocd: option compiler_index)

           (j:meminj) (cstate1: ThreadPool (Some hb)) (m1: Mem.mem) (cstate2: ThreadPool(Some (S hb))) (m2: mem):=

      { same_length: num_threads cstate1 = num_threads cstate2

        ; memcompat1: mem_compatible cstate1 m1

        ; memcompat2: mem_compatible cstate2 m2

        ; INJ: Mem.inject j m1 m2

        ; INJ_threads:

            forall i (cnti1: containsThread cstate1 i) (cnti2: containsThread cstate2 i),

              Mem.inject j

                         (restrPermMap (proj1 (memcompat1 i cnti1)))

                         (restrPermMap (proj1 (memcompat2 i cnti2)))

        ; INJ_locks:

            forall i (cnti1: containsThread cstate1 i) (cnti2: containsThread cstate2 i),

              Mem.inject j

                         (restrPermMap (proj2 (memcompat1 i cnti1)))

                         (restrPermMap (proj2 (memcompat2 i cnti2)))

        ; INJ_lock_content:

            forall b b' delt rmap,

              j b = Some (b', delt) ->

              forall ofs, lockRes cstate1 (b, intval ofs) = Some rmap ->

                     lockRes cstate2 (b', intval (add ofs (repr delt))) =

                     Some (virtueLP_inject m2 j rmap)

        ; taret_invariant: invariant cstate2

        ; mtch_source:

            forall (i:nat),

              (i > hb)%nat ->

              forall (cnti1: containsThread cstate1 i)

                (cnti2: containsThread cstate2 i),

                match_thread_source j

                                    (getThreadC cnti1)

                                    (restrPermMap (proj1 (memcompat1 i cnti1)))

                                    (getThreadC cnti2)

                                    (restrPermMap (proj1 (memcompat2 i cnti2)))

        ; mtch_target:

            forall (i:nat),

              (i < hb)%nat ->

              forall (cnti1: containsThread cstate1 i)

                (cnti2: containsThread cstate2 i),

                match_thread_target  j

                                     (getThreadC cnti1)

                                     (restrPermMap (proj1(memcompat1 i cnti1)))

                                     (getThreadC cnti2)

                                     (restrPermMap (proj1(memcompat2 i cnti2)))

        ; mtch_compiled:

            forall (i:nat),

              (i = hb)%nat ->

              forall (cnti1: containsThread cstate1 i)

                (cnti2: containsThread cstate2 i),

              exists cd, ocd = Some cd /\

                    match_thread_compiled cd j

                                          (getThreadC cnti1)

                                          (restrPermMap (proj1 (memcompat1 i cnti1)))

                                          (getThreadC cnti2)

                                          (restrPermMap (proj1 (memcompat2 i cnti2))) }.

    Arguments memcompat1 {ocd j cstate1 m1 cstate2 m2}. 

    Arguments memcompat2 {ocd j cstate1 m1 cstate2 m2}.



    Ltac forget_memcompat1:=

      match goal with

      | [ H: context[memcompat1 ?CM] |- _ ] =>

        let HH:= fresh "HH" in

        let Hcmpt:= fresh "Hcmpt" in

        remember (memcompat1 CM) as Hcmpt eqn:HH; clear HH 

      | [ |-  context[memcompat1 ?CM] ] =>

        let HH:= fresh "HH" in

        let Hcmpt:= fresh "Hcmpt" in

        remember (memcompat1 CM) as Hcmpt eqn:HH; clear HH 

      end.



    Ltac forget_memcompat2:=

      match goal with

      | [ H: context[memcompat2 ?CM] |- _ ] =>

        let HH:= fresh "HH" in

        let Hcmpt:= fresh "Hcmpt" in

        remember (memcompat2 CM) as Hcmpt eqn:HH; clear HH

      | [  |- context[memcompat2 ?CM] ] =>

        let HH:= fresh "HH" in

        let Hcmpt:= fresh "Hcmpt" in

        remember (memcompat2 CM) as Hcmpt eqn:HH; clear HH 

      end.



    Ltac consolidate_mem_compatible:=

      repeat match goal with

             | [ H1: mem_compatible ?st ?m,

                     H2: mem_compatible ?st ?m |- _ ] =>

               replace H2 with H1 in * by ( apply Axioms.proof_irr); clear H2

             end.



    Ltac clean_cmpt:=

      try forget_memcompat1;

      try forget_memcompat2;

      consolidate_mem_compatible.

    

    Ltac clean_cmpt':=

      match goal with

      | [ CMatch: concur_match _ _ _ _ _ _,

                  Hcmpt:mem_compatible ?st ?m |- _ ] =>

        repeat(

            match goal with

            | [   |- context[Hcmpt] ] =>

              replace Hcmpt with (memcompat1 CMatch)

                by apply Axioms.proof_irr

            | [ HH:context[Hcmpt]  |- _ ] =>

              replace Hcmpt with (memcompat1 CMatch) in HH

                by apply Axioms.proof_irr

            end)

      end.



    Lemma mem_compat_restrPermMap:

      forall sem tpool m perms st (permMapLt: permMapLt perms (getMaxPerm m)),

        (mem_compatible(Sem:=sem)(tpool:=tpool) st m) ->

        (mem_compatible st (restrPermMap permMapLt)).

    Proof.

      intros.

      inversion H.

      econstructor.

      - intros; unfold permissions.permMapLt.

        split; intros;

          erewrite getMax_restr; 

          eapply compat_th0.

      - intros; unfold permissions.permMapLt.

        split; intros;

          erewrite getMax_restr; 

          eapply compat_lp0; eauto.

      - intros. eapply restrPermMap_valid; eauto.

    Qed.

      

    Lemma concur_match_perm_restrict:

      forall cd j st1 m1 st2 m2,

        concur_match cd j st1 m1 st2 m2 ->

        forall perms1 perms2 (permMapLt1: permMapLt perms1 (getMaxPerm m1))

          (permMapLt2: permMapLt perms2 (getMaxPerm m2)),

          concur_match cd j st1 (restrPermMap permMapLt1) st2 (restrPermMap permMapLt2).

    Proof.

      intros.

      inversion H.



      assert (memcompat3': mem_compatible st1 (restrPermMap permMapLt1)) by

      (eapply mem_compat_restrPermMap; eauto).

      assert (memcompat4': mem_compatible st2 (restrPermMap permMapLt2)) by

          (eapply mem_compat_restrPermMap; eauto).

      eapply Build_concur_match with memcompat3' memcompat4'; eauto.

      - intros; simpl.

        destruct memcompat3';

        destruct memcompat4';

        destruct memcompat3;

        destruct memcompat4; simpl in *.

        

    Admitted.



    Lemma contains12:

      forall {data j cstate1 m1 cstate2 m2},

        concur_match data j cstate1 m1 cstate2 m2 ->

        forall {i:nat} (cnti1: containsThread cstate1 i),

          containsThread cstate2 i.

    Proof.

      unfold containsThread.

      intros ? ? ? ? ? ? H. destruct H.

      rewrite same_length0; auto.

    Qed.



    Lemma contains21:

      forall {data j cstate1 m1 cstate2 m2},

        concur_match data j cstate1 m1 cstate2 m2 ->

        forall {i:nat} (cnti1: containsThread cstate2 i),

          containsThread cstate1 i.

    Proof.

      unfold containsThread.

      intros ? ? ? ? ? ? H. destruct H.

      rewrite same_length0; auto.

    Qed.



    Ltac forget_contains12:=

      match goal with

      | [ H: context[@contains12 _ _ _ _ _ _ ?CM ?i ?cnt1] |- _ ] =>

        let HH:= fresh "HH" in

        let Hcnt:= fresh "Hcnt" in

        remember (@contains12 _ _ _ _ _ _ CM i cnt1) as Hcnt eqn:HH; clear HH 

      | [ |- context[@contains12 _ _ _ _ _ _ ?CM ?i ?cnt1] ] =>

        let HH:= fresh "HH" in

        let Hcnt:= fresh "Hcnt" in

        remember (@contains12 _ _ _ _ _ _ CM i cnt1) as Hcnt eqn:HH; clear HH 

      end.



    Ltac forget_contains21:=

      match goal with

      | [ H: context[@contains21 _ _ _ _ _ _ ?CM ?i ?cnt1] |- _ ] =>

        let HH:= fresh "HH" in

        let Hcnt:= fresh "Hcnt" in

        remember (@contains21 _ _ _ _ _ _ CM i cnt1) as Hcnt eqn:HH; clear HH 

      | [ |- context[@contains21 _ _ _ _ _ _ ?CM ?i ?cnt1] ] =>

        let HH:= fresh "HH" in

        let Hcnt:= fresh "Hcnt" in

        remember (@contains21 _ _ _ _ _ _ CM i cnt1) as Hcnt eqn:HH; clear HH 

      end.



    Ltac consolidate_containsThread:=

      repeat match goal with

             | [ H: ThreadPool.containsThread _ _ |- _ ] => simpl in H

             end;

      repeat match goal with

             | [ H1: containsThread ?st ?i,

                     H2: containsThread ?st ?i |- _ ] =>

               replace H2 with H1 in * by ( apply Axioms.proof_irr); clear H2

             end.



    Ltac clean_cnt:=

      try forget_contains12;

      try forget_contains21;

      consolidate_containsThread.

    

    Ltac clean_cnt':=

      match goal with

      | [ CMatch: concur_match _ _ ?st1 _ ?st2 _ |- _] =>

        match goal with

        | [ Hcnt1: containsThread st1 ?i,

                   Hcnt2: containsThread st2 ?i |- _ ] =>

          

          first [match goal with

                 | [ HH: context[contains21] |- _ ] =>  idtac

                 | [  |- context[contains21] ] =>  idtac

                 | _ => fail 1

                 end; 

                 repeat(

                     match goal with

                     | [   |- context[Hcnt1] ] =>

                       replace Hcnt1 with (contains21 CMatch Hcnt2)

                         by apply Axioms.proof_irr

                     | [ HH:context[Hcnt1]  |- _ ] =>

                       replace Hcnt1 with (contains21 CMatch Hcnt2) in HH

                         by apply Axioms.proof_irr

                     end) |

                 repeat(

                     match goal with

                     | [   |- context[Hcnt2] ] =>

                       replace Hcnt2 with (contains12 CMatch Hcnt1)

                         by apply Axioms.proof_irr

                     | [ HH:context[Hcnt2]  |- _ ] =>

                       replace Hcnt2 with (contains12 CMatch Hcnt1) in HH

                         by apply Axioms.proof_irr

                     end) ]

        end

      end.

    

    Lemma concur_match_same_running:

      forall (m : option mem) (cd : option compiler_index) (mu : meminj)

        (c1 : ThreadPool (Some hb)) (m1 : mem) (c2 : ThreadPool (Some (S hb))) 

        (m2 : mem),

        concur_match cd mu c1 m1 c2 m2 ->

        forall i : nat,

          machine_semantics.running_thread (HybConcSem (Some hb) m) c1 i <->

          machine_semantics.running_thread (HybConcSem (Some (S hb)) m) c2 i.

    Proof.

      intros.

      pose proof (@contains12 _ _ _ _ _ _ H) as CNT12.

      pose proof (@contains21 _ _ _ _ _ _ H) as CNT21.

      inversion H; simpl.

      split; intros H0 ? ? ? ?.

      - destruct (Compare_dec.lt_eq_lt_dec j hb) as [[?|?]|?].  

        + specialize (mtch_target0 j l (CNT21 _ cnti) cnti).

    Admitted.



    Inductive ord_opt {A} (ord: A -> A -> Prop): option A -> option A -> Prop:=

    | Some_ord:

        forall x y, ord x y -> ord_opt ord (Some x) (Some y).

    

    Lemma option_wf:

      forall A (ord: A -> A -> Prop),

        well_founded ord ->

        well_founded (ord_opt ord).

    Proof.

      unfold well_founded.

      intros.

      destruct a.

      2: econstructor; intros; inversion H0.

      specialize (H a).

      induction H.

      econstructor; intros.

      inversion H1; subst.

      eapply H0; eauto.

    Qed.



    Inductive individual_match ocd i:

      meminj -> ctl -> mem -> ctl -> mem -> Prop:= 

    |individual_mtch_source:

       (i > hb)%nat ->

       forall j s1 m1 s2 m2,

         match_thread_source j s1 m1 s2 m2 ->

         individual_match ocd i j s1 m1 s2 m2

    |individual_mtch_target:

       (i < hb)%nat ->

       forall j s1 m1 s2 m2,

         match_thread_target j s1 m1 s2 m2 ->

         individual_match ocd i j s1 m1 s2 m2

    | individual_mtch_compiled:

        (i = hb)%nat ->

        forall cd j s1 m1 s2 m2,

          ocd = Some cd ->

          match_thread_compiled cd j s1 m1 s2 m2 ->

          individual_match ocd i j s1 m1 s2 m2.



    Lemma simulation_equivlanence:

      forall s3 t s2 cd cd0,

        (Smallstep.plus (Asm.step (Genv.globalenv Asm_program)) 

                        s3 t s2 \/

         Smallstep.star (Asm.step (Genv.globalenv Asm_program)) 

                        s3 t s2 /\ Injorder compiler_sim cd cd0) ->

        Smallstep.plus (Asm.step (Genv.globalenv Asm_program)) 

                       s3 t s2 \/

        t = Events.E0 /\

        s2 = s3 /\

        Injorder compiler_sim cd cd0.

    Proof.

      intros. destruct H; eauto.

      destruct H.

      inversion H; subst; eauto.

      left. econstructor; eauto.

    Qed.

    

    Lemma Concur_update:

      forall (st1: ThreadPool.t) (m1 m1' : mem) (tid : nat) (Htid : ThreadPool.containsThread st1 tid)

        c1 (cd cd' : option compiler_index) (st2 : ThreadPool.t) 

        (mu : meminj) (m2 : mem)

        c2

        (f' : meminj) (m2' : mem) (Htid' : ThreadPool.containsThread st2 tid)

        (mcompat1: mem_compatible st1 m1)

        (mcompat2: mem_compatible st2 m2),

        semantics.mem_step

          (restrPermMap (proj1 (mcompat1 tid Htid))) m1' ->

        semantics.mem_step

          (restrPermMap (proj1 (mcompat2 tid Htid'))) m2' ->

        invariant st1 ->

        invariant st2 ->

        concur_match cd mu st1 m1 st2 m2 ->

        individual_match cd' tid f' c1 m1' c2 m2' ->

        self_simulation.is_ext mu (Mem.nextblock m1) f' (Mem.nextblock m2) ->

        concur_match cd' f'

                     (updThread Htid c1

                                (getCurPerm m1', snd (getThreadR Htid))) m1'

                     (updThread Htid' c2

                                (getCurPerm m2', snd (getThreadR Htid'))) m2'.

    Proof.

    Admitted.



    Lemma Concur_update_compiled:

      forall (st1 : ThreadPool.t) (m1 m1' : mem) (Htid : ThreadPool.containsThread st1 hb) 

        (st2 : ThreadPool.t) (mu : meminj) (m2 : mem) (cd0 : compiler_index),

        concur_match (Some cd0) mu st1 m1 st2 m2 ->

        forall (s' : Clight.state) (j1' : meminj) (cd' : Injindex compiler_sim)

          (j2' : meminj) (s4' : Asm.state) (j3' : meminj) (m2' : mem)

          (Htid' : containsThread st2 hb)

        (mcompat1: mem_compatible st1 m1)

        (mcompat2: mem_compatible st2 m2),

        semantics.mem_step

          (restrPermMap (proj1 (mcompat1 hb Htid))) m1' ->

        semantics.mem_step

          (restrPermMap (proj1 (mcompat2 hb Htid'))) m2' ->

        invariant st1 ->

        invariant st2 ->

        match_thread_compiled cd' (compose_meminj (compose_meminj j1' j2') j3')

                              (Krun (SState Clight.state Asm.state s')) m1'

                              (Krun (TState Clight.state Asm.state s4')) m2' ->

        concur_match (Some cd') (compose_meminj (compose_meminj j1' j2') j3')

                     (updThread Htid (Krun (SState Clight.state Asm.state s'))

                                (getCurPerm m1', snd (getThreadR Htid))) m1'

                     (updThread Htid' (Krun (TState Clight.state Asm.state s4'))

                                (getCurPerm m2', snd (getThreadR Htid'))) m2'.

    Proof.

      

    Admitted.



    Lemma Concur_update_compiled':

      forall (st1 : ThreadPool.t) (m1 m1' : mem) (Htid : ThreadPool.containsThread st1 hb) 

        (st2 : ThreadPool.t) (mu : meminj) (m2 : mem) (cd0 : compiler_index),

        concur_match (Some cd0) mu st1 m1 st2 m2 ->

        forall (s' : Clight.state) (j1' : meminj) (cd' : Injindex compiler_sim)

          (j2' : meminj) (s4 : Asm.state) (j3' : meminj)

          (Htid' : containsThread st2 hb)

        (mcompat1: mem_compatible st1 m1)

        (mcompat2: mem_compatible st2 m2),

        semantics.mem_step

          (restrPermMap (proj1 (mcompat1 hb Htid))) m1' ->

        invariant st1 ->

        invariant st2 ->

        match_thread_compiled cd' (compose_meminj (compose_meminj j1' j2') j3')

                              (Krun (SState Clight.state Asm.state s')) m1'

                              (Krun (TState Clight.state Asm.state s4))

                              (restrPermMap (proj1 (mcompat2 hb Htid'))) ->

        concur_match (Some cd') (compose_meminj (compose_meminj j1' j2') j3')

                     (updThread Htid (Krun (SState Clight.state Asm.state s'))

                                (getCurPerm m1', snd (getThreadR Htid))) m1'

                     st2 m2.

    Proof.

      

    Admitted.

    

    Ltac exploit_match:=

      unfold match_thread_target,match_thread_source,match_thread_compiled in *;

      match goal with

      | [ H: getThreadC ?i = _ ?c,

             H0: context[match_state2match_thread] |- _ ] =>

        rewrite H in H0; inversion H0; subst; simpl in *; clear H0

      end;

      fold match_thread_target in *;

      fold match_thread_source in *;

      fold match_thread_compiled in *.



    Ltac destroy_ev_step_sum:=

      match goal with

      | [ H: ev_step_sum _ _ _ _ _ _ _ |- _ ] => inversion H; clear H

      end.



    Lemma self_simulation_plus:

      forall state coresem

        (SIM: self_simulation.self_simulation state coresem),

      forall (f : meminj) (t : Events.trace) (c1 : state) 

        (m1 : mem) (c2 : state) (m2 : mem),

        self_simulation.match_self (self_simulation.code_inject _ _ SIM) f c1 m1 c2 m2 ->

        forall (c1' : state) (m1' : mem),

          (corestep_plus coresem) c1 m1 c1' m1' ->

          exists (c2' : state) (f' : meminj) (t' : Events.trace) 

            (m2' : mem),

                (corestep_plus coresem) c2 m2 c2' m2' /\

                self_simulation.match_self (self_simulation.code_inject _ _ SIM) f' c1' m1' c2' m2' /\

                inject_incr f f' /\

                self_simulation.is_ext f (Mem.nextblock m1) f' (Mem.nextblock m2) /\

                Events.inject_trace f' t t'.

    Admitted.



            Lemma thread_step_plus_from_corestep:

              forall (m : option mem) (tge : ClightSemanticsForMachines.G * Asm.genv)

                     (U : list nat) (st1 : t) (m1 : mem) (Htid : containsThread st1 hb) 

                     (st2 : t) (mu : meminj) (m2 : mem) (cd0 : compiler_index)

                     (H0 : concur_match (Some cd0) mu st1 m1 st2 m2) (code2 : Asm.state)

                     (s4' : Smallstep.state (Asm.part_semantics Asm_g)) 

                     (m4' : mem),

                corestep_plus (Asm_core.Asm_core_sem Asm_g) code2

                              (restrPermMap

                                 (proj1 ((memcompat2 H0) hb (contains12 H0 Htid))))

                              s4' m4' ->

                forall Htid' : containsThread st2 hb,

                  machine_semantics_lemmas.thread_step_plus (HybConcSem (Some (S hb)) m) tge U st2

                                                            m2

                                                            (updThread Htid' (Krun (TState Clight.state Asm.state s4'))

                                                                       (getCurPerm m4', snd (getThreadR Htid'))) m4'.

            Proof.

              
            Admitted.



          Lemma step2corestep_plus:

            forall (s1 s2: Smallstep.state (Asm.part_semantics Asm_g)) m1 t,

            Smallstep.plus

                (Asm.step (Genv.globalenv Asm_program))

                (Smallstep.set_mem s1 m1) t s2 ->

            (corestep_plus (Asm_core.Asm_core_sem Asm_g))

              s1 m1 s2 (Smallstep.get_mem s2).

           
          Admitted.



    Lemma Forall2_impl: forall {A B} (P Q : A -> B -> Prop) l1 l2,

      (forall a b, P a b -> Q a b) -> List.Forall2 P l1 l2 -> List.Forall2 Q l1 l2.

    Proof.

      induction 2; constructor; auto.

    Qed.



    Lemma inject_incr_trace:

      forall (tr1 tr2 : list Events.machine_event) (mu f' : meminj),

        inject_incr mu f' ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        List.Forall2 (inject_mevent f') tr1 tr2.

    Proof.

      intros. eapply Forall2_impl; try eassumption.

      - intros. admit.

    Admitted.

    

    Lemma internal_step_diagram:

      forall (m : option mem) (sge tge : HybridMachineSig.G) (U : list nat)

        tr1 (st1 : ThreadPool (Some hb)) (m1 : mem) (st1' : ThreadPool (Some hb)) 

        (m1' : mem),

        machine_semantics.thread_step (HybConcSem (Some hb) m) sge U st1 m1 st1' m1' ->

        forall (cd : option compiler_index) tr2 (st2 : ThreadPool (Some (S hb))) 

          (mu : meminj) (m2 : mem),

          concur_match cd mu st1 m1 st2 m2 ->

          forall (Hmatch_event : List.Forall2 (inject_mevent mu) tr1 tr2),

          exists

            (st2' : ThreadPool (Some (S hb))) (m2' : mem) (cd' : option compiler_index) 

            (mu' : meminj),

            concur_match cd' mu' st1' m1' st2' m2' /\

            List.Forall2 (inject_mevent mu') tr1 tr2 /\

            (machine_semantics_lemmas.thread_step_plus

               (HybConcSem (Some (S hb)) m) tge U st2 m2

               st2' m2' \/

             machine_semantics_lemmas.thread_step_star

               (HybConcSem (Some (S hb)) m) tge U st2 m2

               st2' m2' /\ ord_opt (Injorder compiler_sim) cd' cd).

    Proof.

      intros.

      inversion H; subst.

      inversion Htstep; subst.

      destruct (Compare_dec.lt_eq_lt_dec tid hb) as [[?|?]|?].  

      - 

        pose proof (mtch_target _ _ _ _ _ _ H0 _ l Htid (contains12 H0 Htid)) as HH.

        simpl in *.

        exploit_match.

        destroy_ev_step_sum; subst; simpl in *.

        simpl.

        eapply Asm_event.asm_ev_ax1 in H2.

        clean_cmpt.

        instantiate (1:=Asm_genv_safe) in H2.

        

        eapply Aself_simulation in H5; eauto.

        destruct H5 as (c2' & f' & t' & m2' & (CoreStep & MATCH & Hincr & is_ext & inj_trace)).



        eapply Asm_event.asm_ev_ax2 in CoreStep; try eapply Asm_genv_safe.

        destruct CoreStep as (?&?); eauto.

         

        pose proof (@contains12  _ _ _ _ _ _  H0 _ Htid) as Htid'.



        exists (updThread Htid' (Krun (TState Clight.state Asm.state c2'))

           (getCurPerm m2', snd (getThreadR Htid'))).

        

        exists m2', cd, f'. split; [|split; [|left]].

        

        + 

          simpl.

          move H0 at bottom.

          

          eapply Concur_update; eauto.

          { eapply semantics.corestep_mem in H2.

            eapply H2. }

          { eapply Asm_event.asm_ev_ax1 in H1.

            

            eapply semantics.corestep_mem.

            clean_cnt.

            eassumption.

          }

          { apply H0. }



          econstructor 2; eauto.

          simpl in MATCH.

          unfold match_thread_target; simpl.

          constructor.

          exact MATCH.

          

        + 

          eapply inject_incr_trace; eauto.

        + 

          exists 0; simpl.

          do 2 eexists; split; [|reflexivity].

          replace m2' with (HybridMachineSig.diluteMem m2') by reflexivity.

          econstructor; eauto; simpl.

          econstructor; eauto.

          * simpl in *.

            eapply H0.

          * simpl. econstructor; eauto.

          * simpl; repeat (f_equal; try eapply Axioms.proof_irr).



      - 

        pose proof (mtch_compiled _ _ _ _ _ _ H0 _ e Htid (contains12 H0 Htid)) as HH.

        destruct HH as (cd0 & H1 & ?).

        subst.

        simpl in *; exploit_match. 

        

        inversion H6. subst cd j s1 s4.

        rename H1 into CMatch.

        rename H3 into Compiler_Match.

        rename H5 into AsmMatch.

        simpl in *.



        destroy_ev_step_sum. subst m'0 t0 s.

        eapply (event_semantics.ev_step_ax1 (@semSem CSem)) in H3; eauto.

        assert (original_CoreStep:=H3).

        replace Hcmpt with (memcompat1 H0) in H3

          by eapply Axioms.proof_irr.

        

        eapply Cself_simulation in H3; eauto.

        destruct H3 as (c2' & j1' & t' & m2' & (CoreStep & MATCH & Hincr & His_ext & Htrace)).

        

        inversion CoreStep. subst s1 m7 s0.

        eapply compiler_sim in H1; simpl in *; eauto.

        destruct H1 as (cd' & s2' & j2' & t'' & step & comp_match & Hincr2 & inj_event).



        eapply simulation_equivlanence in step.

        destruct step as [plus_step | (? & ? & ?)].

        

        + 

          eapply step2corestep_plus in plus_step.



          eapply (self_simulation_plus _ _ Aself_simulation) in plus_step; eauto.

          destruct plus_step as (s4' & j3' & t3 & m4' & CstepPlus & AMatch & Hincr3 & His_ext3 & Htrace3).  

          

          pose proof (@contains12  _ _ _ _ _ _  H0 _ Htid) as Htid'.

          

          exists (updThread Htid' (Krun (TState Clight.state Asm.state s4'))

                       (getCurPerm m4', snd (getThreadR Htid'))).

          

          exists m4', (Some cd'), (compose_meminj (compose_meminj j1' j2') j3').

          split; [|split; [|left]].

          * 



            simpl in *.

            eapply Concur_update_compiled; eauto.

            

            { eapply (semantics.corestep_mem (Clightcore_coop.CLC_memsem  Clight_g)).

              eauto.

            }

            { 

              instantiate(1:=(memcompat2 H0)).

              remember (memcompat2 H0) as Hcmpt'.

              clean_cnt.

              eapply memsem_lemmas.corestep_star_mem.

              eapply corestep_plus_star; eauto.

              instantiate(3:= Asm_core.Asm_mem_sem _ Asm_genv_safe).

              eauto.

            }

            { apply H0. }

            

            {

              unfold match_thread_compiled.

              econstructor.

              econstructor; eauto.

              move comp_match at bottom.

              simpl in comp_match.

              unfold compiler_match.

              match goal with

              | [  |- context[Injmatch_states _ _ _ _ ?X] ] =>

                replace X with s2' by (destruct s2'; reflexivity)

              end.

              match goal with

              | [  |- context[Injmatch_states _ _ _ ?X _] ] =>

                replace X with c2' by (subst; destruct c2'; reflexivity)

              end.

              eauto.

            }

          * eapply inject_incr_trace; try eassumption. eauto.

            subst mu. repeat eapply compose_inject_incr; eauto.

            

          * eapply thread_step_plus_from_corestep; eauto.

        + remember (compose_meminj (compose_meminj j1' j2') j3) as mu'.

          exists st2, m2, (Some cd'), mu'.

          subst.

          split; [|split; auto].

          * 

            eapply Concur_update_compiled'; eauto; try apply H0.

            { 

              eapply (semantics.corestep_mem (event_semantics.msem (@semSem CSem))).

              eauto.

            }

            

            econstructor.

            econstructor; eauto.

            move H2 at bottom.

            unfold compiler_match.

            match goal with

            | [  |- Injmatch_states _ _ _ ?c _ ] =>

              replace c with c2' 

            end.

            eauto.

            {

              clear; simpl.

              destruct c2'; reflexivity.

            }

            

          * eapply inject_incr_trace; try eassumption. eauto.

            repeat eapply compose_inject_incr; eauto.

          * 

            right; split.

            { exists 0; econstructor; eauto. }

            econstructor; eauto.

            

      - 

        pose proof (mtch_source _ _ _ _ _ _ H0 _ l Htid (contains12 H0 Htid)) as HH.

        simpl in *.

        exploit_match.

        destroy_ev_step_sum; subst; simpl in *.

        simpl.

        eapply (event_semantics.ev_step_ax1 (@semSem CSem)) in H2; eauto.

        replace Hcmpt with (memcompat1 H0) in H2

          by eapply Axioms.proof_irr.

        

        eapply Cself_simulation in H5; eauto.

        destruct H5 as (c2' & f' & t' & m2' & (CoreStep & MATCH & Hincr & His_ext & Htrace)).

        

        eapply (event_semantics.ev_step_ax2 (@semSem CSem)) in CoreStep.

        destruct CoreStep as (?&?); eauto.

         

        pose proof (@contains12  _ _ _ _ _ _  H0 _ Htid) as Htid'.



        exists (updThread Htid' (Krun (SState Clight.state Asm.state c2'))

           (getCurPerm m2', snd (getThreadR Htid'))).

        

        exists m2', cd, f'. split; [|split; [|left]].

        

        + 

          simpl.

          move H0 at bottom.

          eapply Concur_update; eauto.

          { eapply semantics.corestep_mem in H2.

            eapply H2. }

          { eapply (event_semantics.ev_step_ax1 (@semSem CSem)) in H1.

            eapply semantics.corestep_mem in H1.

            clean_cnt.

            eauto.

          }

          { apply H0. }

          

          econstructor 1; eauto.

          simpl in MATCH.

          unfold match_thread_source; simpl.

          constructor.

          exact MATCH.

        + eapply inject_incr_trace; try eassumption. 

        + 

          exists 0; simpl.

          do 2 eexists; split; [|reflexivity].

          replace m2' with (HybridMachineSig.diluteMem m2') by reflexivity.

          econstructor; eauto; simpl.

          econstructor; eauto.

          * simpl in *.

            eapply H0.

          * simpl. econstructor; eauto.

          * simpl; repeat (f_equal; try eapply Axioms.proof_irr).



            Unshelve. all: auto.

             

            all: exact nil.

    Qed.



    Lemma acquire_step_diagram:

          forall (cd : option compiler_index) (m1 : mem) (st1 : ThreadPool (Some hb)) (st2 : ThreadPool.t) (mu : meminj) (m2 : mem)

            (tr1 tr2 : HybridMachineSig.event_trace)

            (Hmatch : concur_match cd mu st1 m1 st2 m2) (Htr : List.Forall2 (inject_mevent mu) tr1 tr2)

            (U : list nat)

            (m1' : mem) (tid : nat)

            (Htid : ThreadPool.containsThread st1 tid) (Hpeek : HybridMachineSig.schedPeek U = Some tid) (c : semC) (b : block)

            (ofs : Integers.Ptrofs.int) (virtueThread : delta_map * delta_map)

            (newThreadPerm : access_map * access_map) (pmap : lock_info)

            (Hcmpt: mem_compatible st1 m1)

          (Hlt': permMapLt

           (setPermBlock (Some Writable) b (Integers.Ptrofs.intval ofs)

              (snd (ThreadPool.getThreadR Htid)) LKSIZE_nat) (getMaxPerm m1))

          (Hbounded : bounded_maps.sub_map (fst virtueThread) (snd (getMaxPerm m1)) /\

             bounded_maps.sub_map (snd virtueThread) (snd (getMaxPerm m1)))

          (Hinv : invariant st1),

            semantics.at_external (semantics.csem (event_semantics.msem semSem))

                   c (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

                 Some (LOCK, (Vptr b ofs :: nil)%list) ->

            getThreadC Htid = Kblocked c ->

            Mem.load AST.Mint32 (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                     (Integers.Ptrofs.intval ofs) = Some (Vint Integers.Int.one) ->

             Mem.range_perm (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

              (Integers.Ptrofs.intval ofs) (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE)

              Cur Readable ->

             Mem.store AST.Mint32 (restrPermMap Hlt') b (Integers.Ptrofs.intval ofs)

             (Vint Integers.Int.zero) = Some m1' ->

            ThreadPool.lockRes st1 (b, Integers.Ptrofs.intval ofs) = Some pmap ->

            permMapJoin (fst pmap) (fst (ThreadPool.getThreadR Htid)) (fst newThreadPerm) ->

            permMapJoin (snd pmap) (snd (ThreadPool.getThreadR Htid)) (snd newThreadPerm) ->

            exists e' (st2' : ThreadPool.t) (m2' : mem) (cd' : option compiler_index) (mu' : meminj),

              concur_match cd' mu'

                           (ThreadPool.updLockSet (ThreadPool.updThread Htid (Kresume c Vundef) newThreadPerm)

                                                  (b, Integers.Ptrofs.intval ofs) (empty_map, empty_map)) m1' st2' m2' /\

              List.Forall2 (inject_mevent mu')

                           (seq.cat tr1

                                    (Events.external tid

                                                     (Events.acquire

                                                        (b, Integers.Ptrofs.intval ofs)

                                                     (Some (build_delta_content (fst virtueThread) m1'))) :: nil))

                                               (seq.cat tr2 (Events.external tid e' :: nil)) /\

              HybridMachineSig.external_step(scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                                            U tr2 st2 m2 (HybridMachineSig.schedSkip U)

                                            (seq.cat tr2

                                                     (Events.external tid e' :: nil)) st2'

                                            m2'.

    Proof.



      intros.



      destruct (Compare_dec.lt_eq_lt_dec tid hb) as [[?|?]|?].



      -



        pose proof (mtch_target _ _ _ _ _ _ Hmatch _ l Htid (contains12 Hmatch Htid)) as match_thread.

        exploit_match.

        inversion H11; clear H11.

        inversion matchmem.

    
        Admitted.



        Lemma map_map1:

          forall {A B} f m,

            @PTree.map1 A B f m = PTree.map (fun _=> f) m.

        Proof.

          intros. unfold PTree.map.

          remember 1%positive as p eqn:Heq.

          clear Heq; revert p.

          induction m; try reflexivity.

          intros; simpl; rewrite <- IHm1.

          destruct o; simpl; 

            rewrite <- IHm2; auto.

        Qed.

        Lemma strong_tree_leq_xmap:

          forall {A B} f1 f2 t (leq: option B -> option A -> Prop),

            (forall a p, leq (Some (f1 p a)) (Some (f2 p a))) ->

            leq None None ->

            forall p,

              bounded_maps.strong_tree_leq

                (PTree.xmap f1 t p)

                (@PTree.xmap A A f2 t p)

                leq.

        Proof.

          intros; revert p.

          induction t0; simpl; auto.

          repeat split; eauto.

          - destruct o; auto.

        Qed.

        Lemma strong_tree_leq_map:

          forall {A B} f1 f2 t (leq: option B -> option A -> Prop),

            (forall a p, leq (Some (f1 p a)) (Some (f2 p a))) ->

            leq None None ->

            bounded_maps.strong_tree_leq

              (@PTree.map A B f1 t)

              (@PTree.map A A f2 t)

              leq.

        Proof. intros; eapply strong_tree_leq_xmap; eauto. Qed.



        Lemma strong_tree_leq_xmap':

          forall {A B} f1 f2 t (leq: option B -> option A -> Prop),

          forall p,

            (forall a p0,

                PTree.get p0 t = Some a ->

                leq (Some (f1 (PTree.prev_append p p0)%positive a))

                    (Some (f2 (PTree.prev_append p p0)%positive a))) ->

            leq None None ->

            bounded_maps.strong_tree_leq

              (@PTree.xmap A B f1 t p)

              (@PTree.xmap A A f2 t p)

              leq.

        Proof.

          intros. revert p H.

          induction t0. simpl; auto.

          intros.

          repeat split.

          - destruct o; auto.

            move H at bottom.

            assert ((PTree.Node t0_1 (Some a) t0_2) ! 1%positive = Some a)

              by reflexivity.

            eapply H in H1. auto.

          -  eapply IHt0_1.

             intros; specialize (H a (p0~0)%positive).

             eapply H; auto.

          -  eapply IHt0_2.

             intros; specialize (H a (p0~1)%positive).

             eapply H; auto.

        Qed.

        

        Lemma strong_tree_leq_map':

          forall {A B} f1 f2 t (leq: option B -> option A -> Prop),

            (forall a p0,

                PTree.get p0 t = Some a ->

                leq (Some (f1 (PTree.prev_append 1 p0)%positive a))

                    (Some (f2 (PTree.prev_append 1 p0)%positive a))) ->

            leq None None ->

            bounded_maps.strong_tree_leq

              (@PTree.map A B f1 t)

              (@PTree.map A A f2 t)

              leq.

        Proof. intros; eapply strong_tree_leq_xmap'; eauto. Qed.

        

        Lemma release_step_diagram:

          forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

            (st1 : ThreadPool (Some hb)) (m1 m1' : mem) 

            (tid : nat) (cd : option compiler_index)

            (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

            (m2 : mem) (Htid : ThreadPool.containsThread st1 tid)

            (c : semC) (b : block) (ofs : Integers.Ptrofs.int)

            (virtueThread : PTree.t

                              (BinNums.Z -> option (option permission)) *

                            PTree.t

                              (BinNums.Z -> option (option permission)))

            (virtueLP : PMap.t (BinNums.Z -> option permission) *

                        PMap.t (BinNums.Z -> option permission))

            (rmap : lock_info) (newThreadPerm : access_map * access_map)

            (HSched: HybridMachineSig.schedPeek U = Some tid)

            (Hcmpt : mem_compatible st1 m1)

            (CMatch:concur_match cd mu st1 m1 st2 m2)

            (HTraceInj: List.Forall2 (inject_mevent mu) tr1 tr2)

            (Hlt' : permMapLt

                         (setPermBlock (Some Writable) b

                                       (Integers.Ptrofs.intval ofs)

                                       (snd (getThreadR Htid)) LKSIZE_nat)

                         (getMaxPerm m1))

            (Hbounded: bounded_maps.sub_map (fst virtueThread) (snd (getMaxPerm m1)) /\

                bounded_maps.sub_map (snd virtueThread) (snd (getMaxPerm m1)))

            (HboundedLP: bounded_maps.map_empty_def (fst virtueLP) /\

                bounded_maps.map_empty_def (snd virtueLP) /\

                bounded_maps.sub_map (snd (fst virtueLP)) (snd (getMaxPerm m1)) /\

                bounded_maps.sub_map (snd (snd virtueLP)) (snd (getMaxPerm m1)))

            (Hinv: invariant st1)

            (Hcode: ThreadPool.getThreadC Htid = Kblocked c)

            (Hat_external: semantics.at_external

                  (semantics.csem (event_semantics.msem semSem)) c

                  (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

                Some (UNLOCK, (Vptr b ofs :: nil)%list))

            (Hload: Mem.load AST.Mint32

                         (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                         (Integers.Ptrofs.intval ofs) = Some (Vint Integers.Int.zero))

            (Haccess: Mem.range_perm

                  (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                  (Integers.Ptrofs.intval ofs)

                  (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE) Cur Readable)

            (Hstore: Mem.store AST.Mint32 (restrPermMap Hlt') b

                          (Integers.Ptrofs.intval ofs) (Vint Integers.Int.one) = 

                Some m1')

             (HisLock: ThreadPool.lockRes st1 (b, Integers.Ptrofs.intval ofs) =

                Some rmap)

             (Hrmap: (forall (b0 : BinNums.positive) (ofs0 : BinNums.Z),

                    (fst rmap) !! b0 ofs0 = None /\ (snd rmap) !! b0 ofs0 = None))

             (Hangel1: permMapJoin (fst newThreadPerm) (fst virtueLP)

                            (fst (getThreadR Htid)))

             (Hangel2: permMapJoin (snd newThreadPerm) (snd virtueLP)

                            (snd (getThreadR Htid))),

                exists

                  e' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

                  (mu' : meminj),

                  concur_match cd' mu'

                               (ThreadPool.updLockSet

                                  (ThreadPool.updThread Htid (Kresume c Vundef)

                                                        (computeMap (fst (getThreadR Htid))

                                                                    (fst virtueThread),

                                                         computeMap (snd (getThreadR Htid))

                                                                    (snd virtueThread))) (b, Integers.Ptrofs.intval ofs)

                                  virtueLP) m1' st2' m2' /\

                  List.Forall2 (inject_mevent mu') (seq.cat tr1 (Events.external tid (Events.release (b, Integers.Ptrofs.intval ofs) (Some (build_delta_content (fst virtueThread) m1'))) :: nil))

                               (seq.cat tr2 (Events.external tid e' :: nil)) /\

                  HybridMachineSig.external_step

                    (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                    U tr2 st2 m2 (HybridMachineSig.schedSkip U)

                    (seq.cat tr2

                             (Events.external tid e' :: nil)) st2' m2'.

        Proof.

          intros.



          destruct (Compare_dec.lt_eq_lt_dec tid hb) as [[?|?]|?].



          -



            Lemma release_step_diagram_target:

              forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

                (st1 : ThreadPool (Some hb)) (m1 m1' : mem) 

                (tid : nat) (cd : option compiler_index)

                (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

                (m2 : mem)

                (Htid1 : ThreadPool.containsThread st1 tid)

                (Htid2 : ThreadPool.containsThread st2 tid)

                (code1: Asm.state) (b : block) (ofs : Integers.Ptrofs.int)

                (virtueThread : PTree.t

                                  (BinNums.Z -> option (option permission)) *

                                PTree.t

                                  (BinNums.Z -> option (option permission)))

                (virtueLP : PMap.t (BinNums.Z -> option permission) *

                            PMap.t (BinNums.Z -> option permission))

                (rmap : lock_info) (newThreadPerm : access_map * access_map)

                (HSched: HybridMachineSig.schedPeek U = Some tid)

                (Hcmpt1 : mem_compatible st1 m1)

                

                (target_inv: invariant st2)

                (HTraceInj: List.Forall2 (inject_mevent mu) tr1 tr2)

                (Hlt' : permMapLt

                          (setPermBlock (Some Writable) b

                                        (Integers.Ptrofs.intval ofs)

                                        (snd (ThreadPool.getThreadR Htid1)) LKSIZE_nat)

                         (getMaxPerm m1))

            (Hbounded: bounded_maps.sub_map (fst virtueThread) (snd (getMaxPerm m1)) /\

                bounded_maps.sub_map (snd virtueThread) (snd (getMaxPerm m1)))

            (HboundedLP: bounded_maps.map_empty_def (fst virtueLP) /\

                bounded_maps.map_empty_def (snd virtueLP) /\

                bounded_maps.sub_map (snd (fst virtueLP)) (snd (getMaxPerm m1)) /\

                bounded_maps.sub_map (snd (snd virtueLP)) (snd (getMaxPerm m1)))

            (Hinv: invariant st1)

            (Hcode: ThreadPool.getThreadC Htid1 = Kblocked (TST code1))

            (Hat_external: semantics.at_external

                  (semantics.csem (event_semantics.msem (@semSem AsmSem) )) (code1)

                  (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt1 tid Htid1)))) =

                Some (UNLOCK, (Vptr b ofs :: nil)%list))

            (Hload: Mem.load AST.Mint32

                         (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt1 tid Htid1)))) b

                         (Integers.Ptrofs.intval ofs) = Some (Vint Integers.Int.zero))

            (Haccess: Mem.range_perm

                  (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt1 tid Htid1)))) b

                  (Integers.Ptrofs.intval ofs)

                  (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE) Cur Readable)

            (Hstore: Mem.store AST.Mint32 (restrPermMap Hlt') b

                          (Integers.Ptrofs.intval ofs) (Vint Integers.Int.one) = 

                Some m1')

             (HisLock: ThreadPool.lockRes st1 (b, Integers.Ptrofs.intval ofs) =

                Some rmap)

             (Hrmap: (forall (b0 : BinNums.positive) (ofs0 : BinNums.Z),

                    (fst rmap) !! b0 ofs0 = None /\ (snd rmap) !! b0 ofs0 = None))

             (Hangel1: permMapJoin (fst newThreadPerm) (fst virtueLP)

                            (fst (ThreadPool.getThreadR Htid1)))

             (Hangel2: permMapJoin (snd newThreadPerm) (snd virtueLP)

                                   (snd (ThreadPool.getThreadR Htid1)))

             code2 (Hcmpt2: mem_compatible st2 m2)

             (Amatch : Asm_match mu code1

                                 (restrPermMap (proj1 (Hcmpt1 tid Htid1)))

                                 code2

                                 (restrPermMap

                                    (proj1

                                       (Hcmpt2 tid (Htid2)))) )

             (getCode2 : Kblocked (TST code2) = ThreadPool.getThreadC Htid2)

             (Hinj_lock: 

                Mem.inject mu (restrPermMap (proj2 (Hcmpt1 tid Htid1)))

                           (restrPermMap (proj2 (Hcmpt2 tid Htid2))))

              b' delt (Hinj_b : mu b = Some (b', delt)),

                let code1' := (Kresume (TST code1) Vundef) in

                exists e' (m2' : mem) Htid2

                  (mu' : meminj),

                  Asm_code_inject mu code1 code2 /\

                  self_simulation.match_mem mu (restrPermMap (proj1 (Hcmpt1 tid Htid1)))

                                       (restrPermMap (proj1 (Hcmpt2 tid Htid2)))

                  /\

                  List.Forall2 (inject_mevent mu')

                               (seq.cat tr1 (Events.external tid (Events.release (b, Integers.Ptrofs.intval ofs) (Some (build_delta_content (fst virtueThread) m1'))) :: nil))

                               (seq.cat tr2 (Events.external tid e' :: nil)) /\

                  let virtueThread2:= (virtueThread_inject m2 mu virtueThread)  in

                  let virtueLP2:= virtueLP_inject m2 mu virtueLP  in

                  let st2':=

                      (ThreadPool.updLockSet

                         

                         (ThreadPool.updThread

                            (tp:=st2)

                            (tid:=tid)

                            (Sem:=HybridSem (Some (S hb)))

                            (resources:=dryResources)

                            Htid2 (Kresume (TST code2) Vundef)

                            (computeMap (fst (ThreadPool.getThreadR Htid2)) (fst virtueThread2),

                             computeMap (snd (ThreadPool.getThreadR Htid2)) (snd virtueThread2))) 

         (b', intval (add ofs (repr delt))) virtueLP2) in 

                  HybridMachineSig.external_step

                    (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                    U tr2 st2 m2 (HybridMachineSig.schedSkip U)

                    (seq.cat tr2

                             (Events.external tid e' :: nil)) st2' m2'.

            Proof.

              intros. 

              

              inversion Amatch; clear Amatch.

              

              remember (virtueThread_inject m2 mu virtueThread)  as virtueThread2.

              remember (virtueLP_inject m2 mu virtueLP) as virtueLP2.



            pose proof (self_simulation.minject _ _ _ matchmem) as Hinj.

            assert (Hinj':=Hinj).

            pose proof (self_simulation.ssim_external _ _ Aself_simulation) as sim_atx.

            eapply sim_atx in Hinj'; eauto.

            clear sim_atx.

            destruct Hinj' as (b'' & delt' & Hinj_b' & Hat_external2); eauto.

            

            rewrite Hinj_b in Hinj_b'; inversion Hinj_b'; subst b'' delt'.

            

            assert (HlockRes:= Hinj_b).

            eapply INJ_lock_content in HlockRes; eauto.

            

            assert (Hlt2': permMapLt

           (setPermBlock (Some Writable) b' (intval ofs + delt)%Z

                         (snd (getThreadR Htid2)) LKSIZE_nat) (getMaxPerm m2)).

            {

              

              Lemma setPermBlock_inject_permMapLt:

                forall {Sem1 Sem2} n (NZ: 0 < n) 

                  (st1 : t(resources:=dryResources)(Sem:=Sem1)) (m1 : mem) (tid : nat) (cd : option compiler_index)

                  (st2 : t(resources:=dryResources)(Sem:=Sem2)) (mu : meminj) (m2 : mem) (Htid1 : containsThread st1 tid)

                  (b : block) (ofs : ptrofs),

                  permMapLt

                    (setPermBlock (Some Writable) b (intval ofs) (snd (getThreadR Htid1)) n)

                    (getMaxPerm m1) ->

                  Mem.inject mu m1 m2 ->

                  forall (b' : block) (delt : Z),

                    mu b = Some (b', delt) ->

                    forall Htid2 : containsThread st2 tid,

                      permMapLt (snd (getThreadR Htid2)) (getMaxPerm m2) ->

                      permMapLt

                        (setPermBlock (Some Writable) b' (intval ofs + delt)

                                      (snd (getThreadR Htid2)) n) (getMaxPerm m2).

              Proof.



                intros; intros b0 ofs0.

                destruct (base.block_eq_dec b' b0);

                  [destruct (Intv.In_dec ofs0 ((intval ofs + delt)%Z, (intval ofs + delt + (Z.of_nat n))%Z))|

                  ].

                - subst. unfold Intv.In in i; simpl in *.

                  rewrite setPermBlock_same; auto.

                  replace ofs0 with ((ofs0 - delt) + delt)%Z by omega.

                  eapply juicy_mem.perm_order''_trans.



                  + rewrite getMaxPerm_correct; unfold permission_at.

                    eapply mem_lemmas.inject_permorder; eauto.



                  + specialize (H b (ofs0 - delt)%Z).

                    rewrite getMaxPerm_correct in H; unfold permission_at in H.

                    rewrite setPermBlock_same in H.

                    assumption.

                    omega.

                - subst.

                  rewrite setPermBlock_other_1; eauto.

                  eapply Intv.range_notin in n0; auto; simpl.

                  eapply inj_lt in NZ. rewrite Nat2Z.inj_0 in NZ.

                  omega.

                - subst.

                  rewrite setPermBlock_other_2; eauto.

              Qed.



              Lemma permMapLt_extensional:

                forall p1 p2 p3,

                (forall b, p2 !! b = p3 !! b) -> 

                permMapLt p1 p2 ->

                permMapLt p1 p3.

              Proof. intros; intros ??. rewrite <- H. eapply H0. Qed.



              eapply permMapLt_extensional.

              - eapply (@getMax_restr _ _ (proj1 (Hcmpt2 tid Htid2))).

              - clear Hstore.

                eapply permMapLt_extensional in Hlt'. 

                2: { intros; symmetry; eapply (@getMax_restr _ _ (proj1 (Hcmpt1 tid Htid1))). }

                

                eapply setPermBlock_inject_permMapLt; simpl in *; eauto.

                { unfold LKSIZE_nat, LKSIZE; rewrite size_chunk_Mptr.

                  destruct Archi.ptr64; simpl; unfold Pos.to_nat; simpl; omega. }



                eapply permMapLt_extensional.

                intros; symmetry. eapply (@getMax_restr _ _ (proj1 (Hcmpt2 tid Htid2))).

                eapply Hcmpt2; eauto.

            }

            

            eapply Mem.store_mapped_inject in Hstore; eauto.

            2: {

              
              instantiate  (1:=restrPermMap Hlt2') .

              admit.

            }



            destruct Hstore as (m2' & Hstore2 & Hinj2).

            

            econstructor. exists m2'. econstructor. exists mu.

            split; [|split; [|split]].

            

              + 

                eauto.

                

              + 

                eauto.

                

              + simpl.

                Lemma cat_app:

                  forall {T} (l1 l2:list T),

                    seq.cat l1 l2 = app l1 l2.

                Proof. intros. induction l1; eauto. Qed.

                

                rewrite cat_app.

                rewrite (cat_app tr2).

                eapply List.Forall2_app.

                * admit.

                
                * econstructor; try solve[constructor].

                  simpl.

                  

                  admit. 

                  

              + 

                

                econstructor; eauto.

                eapply step_release with

                    (b0:= b')

                    (virtueThread0:=virtueThread2)

                    (virtueLP0:=virtueLP2)

                    (m':=m2'); eauto; try reflexivity.

                

                * unfold HybridMachineSig.isCoarse, HybridMachineSig.HybridCoarseMachine.scheduler.

                 
                { destruct Hbounded as (A&B).



                  Lemma strong_tree_leq_spec:

                    forall {A B} (leq: option A -> option B -> Prop),

                      leq None None ->

                      forall t1 t2,

                        bounded_maps.strong_tree_leq t1 t2 leq ->

                        forall b, leq (@PTree.get A b t1) 

                                 (@PTree.get B b t2).

                  Proof.

                    intros A B leq Hleq t1.

                    induction t1; eauto.

                    - intros.

                      destruct t2; try solve[inversion H].

                      destruct b; simpl; auto.

                    - intros t2 HH.

                      destruct t2; try solve[inversion HH].

                      destruct HH as (INEQ&L&R).

                      destruct b; simpl; eauto.

                  Qed.

                  Lemma trivial_map1:

                    forall {A} (t : PTree.t A),

                      PTree.map1 (fun (a : A) => a) t = t.

                  Proof.

                    intros ? t; induction t; auto.

                    simpl; f_equal; eauto.

                    destruct o; reflexivity.

                  Qed.

                  Lemma trivial_map:

                    forall {A} (t : PTree.t A),

                      PTree.map (fun (_ : positive) (a : A) => a) t = t.

                  Proof.

                    intros; rewrite <- map_map1; eapply trivial_map1.

                  Qed.



                  eapply self_simulation.minject in matchmem.

                    subst.

                  unfold virtueThread_inject.

                  destruct virtueThread as (virtue1, virtue2).

                  cbv iota beta delta[fst] in *.

                  split.

                  

                  - clear - A matchmem compiled .

                    

                    Lemma inject_virtue_sub_map:

                      forall {Sem1 Sem2}

                        (st1 : ThreadPool.t(resources:=dryResources)(Sem:=Sem1))

                        (m1 : mem) (tid : nat)

                        (st2 : ThreadPool.t(resources:=dryResources)(Sem:=Sem2))

                        (mu : meminj) (m2 : mem)

                        (Htid1 : ThreadPool.containsThread st1 tid) (Htid2 : ThreadPool.containsThread st2 tid)

                        {A} (virtue1 : PTree.t (Z -> option A))

                        

                        (Hcmpt1: mem_compatible st1 m1)(Hcmpt2: mem_compatible st2 m2),

                        Mem.inject mu (restrPermMap (proj1 (Hcmpt1 tid Htid1)))

                                   (restrPermMap (proj1 (Hcmpt2 tid Htid2))) ->

                        bounded_maps.sub_map virtue1 (snd (getMaxPerm m1)) ->

                        bounded_maps.sub_map (tree_map_inject_over_mem m2 mu virtue1) (snd (getMaxPerm m2)).

                    Proof.



                      intros ?? st1 m1 tid st2 mu m2 Htid1 Htid2 AT virtue1 Hcmpt1 Hcmpt2 injmem A.



                      replace  (snd (getMaxPerm m2)) with

                          (PTree.map (fun _ a => a)  (snd (getMaxPerm m2))) by eapply trivial_map.

                      unfold tree_map_inject_over_mem, tree_map_inject_over_tree.



                      pose proof (@strong_tree_leq_map') as HHH.

                      specialize (HHH _ (Z -> option AT)

                                     (fun (b : positive) _ =>

                                        build_function_for_a_block mu b (PTree.elements virtue1))

                                     (fun (_ : positive) a => a)

                                     (snd (getMaxPerm m2))

                                     bounded_maps.fun_leq

                                 ).

                      unfold bounded_maps.sub_map.

                      eapply HHH; eauto; try constructor.

                      clear HHH.

                      

                      intros; simpl. intros p HH.



                      pose proof (PTree.elements_complete virtue1).

                      remember (PTree.elements virtue1) as Velmts.

                      clear HeqVelmts.

                      induction Velmts as [|[b0 fb]]; try solve[inversion HH].

                      simpl in HH.

                      destruct (mu b0) as [[b1 delt]|] eqn:Hinj.

                      * unfold merge_func in HH.



                        destruct (PMap.elt_eq p0 b1); subst.

                        destruct (fb (p-delt)%Z) eqn:Hfbp.

                           

                        -- specialize (H0 b0 fb ltac:(left; auto)).

                           clear HH.

                           cbv beta zeta iota delta[fst] in A.

                           pose proof (strong_tree_leq_spec

                                         bounded_maps.fun_leq

                                         ltac:(simpl; auto)

                                                virtue1 (snd (getMaxPerm m1)) A b0).

                           rewrite H0 in H1.

                           unfold bounded_maps.fun_leq in H1.

                           destruct ((snd (getMaxPerm m1)) ! b0) eqn:Heqn;

                             try solve[inversion H1].

                           specialize (H1 (p - delt)%Z ltac:(rewrite Hfbp; auto)).

                           eapply Mem.mi_perm in Hinj; try apply injmem.

                           

                           2: {

                             

                             clear IHVelmts Velmts Hinj.

                             clear Hfbp A a b1 H.



                             instantiate (2:= Max).

                             instantiate (2:= (p - delt)%Z).

                             instantiate (1:= Nonempty).

                             unfold Mem.perm.

                             pose proof restrPermMap_Max as H3.

                             unfold permission_at in H3.

                             rewrite H3; clear H3.

                             unfold PMap.get.

                             rewrite Heqn.

                             

                             destruct (o (p - delt)%Z); try solve[inversion H1].

                             destruct p; try constructor.

                           }



                           unfold Mem.perm in Hinj.

                           pose proof restrPermMap_Max as H2.

                           unfold permission_at in H2.

                           rewrite H2 in Hinj.

                           unfold PMap.get in Hinj.

                           rewrite H in Hinj.

                           replace (p - delt + delt)%Z with p in Hinj by omega.

                           destruct (a p); inversion Hinj; auto.



                        -- eapply IHVelmts in HH; auto.

                           intros; eapply H0; right.

                           auto.



                        -- eapply IHVelmts in HH; auto.

                           intros; eapply H0.

                           right; auto.



                      * 

                        eapply IHVelmts in HH; auto.

                        intros; eapply H0.

                        right; auto.

                    Qed.



                    eapply inject_virtue_sub_map;

                      try eapply matchmem; eauto.

                    

                  - eapply inject_virtue_sub_map; eauto.

                    

                }

                

              * unfold HybridMachineSig.isCoarse, HybridMachineSig.HybridCoarseMachine.scheduler.

                move HboundedLP at bottom.

                destruct HboundedLP as (?&?&?).

                

                eapply (proj1 (Logic.and_assoc _ _ _)).

                split.



                subst virtueLP2.

                unfold virtueLP_inject,

                bounded_maps.map_empty_def, access_map_inject;

                  simpl.

                split; auto.



                assert (HboundedLP':

                    bounded_maps.sub_map (snd (fst virtueLP)) (snd (getMaxPerm m1)) /\

                    bounded_maps.sub_map (snd (snd virtueLP)) (snd (getMaxPerm m1))

                  ) by assumption.

                

                subst virtueLP2.

                destruct virtueLP as (virtueLP_fst, virtueLP_snd).

                revert HboundedLP'.

                unfold virtueLP_inject, access_map_inject.

                simpl (fst _).

                simpl (snd _) at 3 6 9.



                eapply self_simulation.minject in matchmem.

                intros (Hl & Hr); split;

                  eapply inject_virtue_sub_map;

                  try eapply Hinj; eauto.

                

              * clean_cnt.

                eapply Hat_external2.

                

              * 



                move Haccess at bottom.

                
                clean_cmpt.

                

                assert (Hperm_range:=Hinj_lock).

                eapply Mem.range_perm_inject in Hperm_range; eauto.

                simpl.

                clean_cnt.

                erewrite Mem.address_inject; try eapply Hinj_lock; eauto.

                2: {

                  

                  specialize(Haccess (unsigned ofs)).

                  eapply Haccess.

                  unfold unsigned; split; try omega.

                  eapply Z.lt_add_pos_r.

                  unfold LKSIZE.

                  rewrite size_chunk_Mptr.

                  destruct Archi.ptr64; omega.

                }

                unfold unsigned; eauto.

                replace (intval ofs + delt + LKSIZE)%Z with (intval ofs + LKSIZE + delt)%Z

                  by omega.

                eassumption.



              * 

                move Hload at bottom.

                clean_cmpt.

                eapply Mem.load_inject in Hload; eauto.

                destruct Hload as (v2& Hload & Hval_inj).

                simpl.

                inversion Hval_inj; subst.

                eauto.

                erewrite Mem.address_inject; try eapply Hinj_lock; eauto.



                {

                  specialize(Haccess (unsigned ofs)).

                  eapply Haccess.

                  unfold unsigned; split; try omega.

                  eapply Z.lt_add_pos_r.

                  unfold LKSIZE.

                  rewrite size_chunk_Mptr.

                  destruct Archi.ptr64; omega.

                }

                

              * move Hstore2 at bottom.

                assert(Heq: intval (add ofs (repr delt)) = (intval ofs + delt)%Z ).

                {

                  unfold add.

                  admit. 


                }



                match goal with

                | [  |- context[restrPermMap ?X] ] =>

                  replace (restrPermMap X) with (restrPermMap Hlt2')

                end.

                -- rewrite Heq; assumption.

                --   

                    

                   admit. 

                

              * intros; simpl.

                move Hrmap at bottom.

                unfold access_map_inject; simpl.

                admit. 

                

              * 

                simpl. move Hangel1 at bottom.

                

                admit.



              * 

                simpl. move Hangel2 at bottom.

                

                admit.



            Admitted.

            

            pose proof (mtch_target _ _ _ _ _ _ CMatch _ l Htid (contains12 CMatch Htid)) as match_thread.

            simpl in Hcode; exploit_match.

            inversion H3.

            

            pose proof (self_simulation.minject _ _ _ matchmem) as Hinj.

            assert (Hinj':=Hinj).

            pose proof (self_simulation.ssim_external _ _ Aself_simulation) as sim_atx.

            eapply sim_atx in Hinj'; eauto.

            2: { clean_cmpt.

                 eauto.

            }

            clear sim_atx.

            destruct Hinj' as (b' & delt & Hinj_b & Hat_external2); eauto.



            edestruct release_step_diagram_target as

            (e' & m2' & Htid2' & mu' & Hcode_inj & matchmem' & Htrace_inj & external_step)

            ; eauto; simpl; try eassumption.



            {  

              eapply CMatch. }



            { 

              clean_cmpt; assumption. }



            { 

              eapply CMatch.

              }



            exists e'. eexists. exists m2', cd, mu'.

            split ; [|split].



            + 

              admit.



            + eassumption.

            + eassumption.

            

          - subst tid.



            pose proof (mtch_compiled _ _ _ _ _ _ CMatch _ ltac:(reflexivity)

                                                                  Htid (contains12 CMatch Htid)) as Hmatch.

            simpl in Hcode; rewrite Hcode in Hmatch.

            destruct Hmatch as (ind&?&Hmatch_thread); subst cd.

            inversion Hmatch_thread; subst.

            rename H1 into Hcode'.

            

            assert (FirstTheSourceExecution:= True).

            move H3 at bottom; move Hcode' at bottom.

            

            inversion H3. subst cd j s1 m0 s4 m5.

            clear H3.



            assert (HH:=H).

            inversion H as (Clight_cinject & Clight_matchmem); clear H.



            pose proof (self_simulation.minject _ _ _ Clight_matchmem) as Hinj.

            assert (Hinj':=Hinj).

            pose proof (self_simulation.ssim_external _ _ Cself_simulation) as sim_atx.

            eapply sim_atx in Hinj'; eauto.

            2: { clean_cmpt.

                 eauto.

            }

            clear sim_atx.

            destruct Hinj' as (b1' & delt1 & Hinj_b1 & Hat_external1'); eauto.



            clean_cnt.

            clean_cmpt. 

            rename m2 into m_temp. 

            rename m3 into m2.

            rename m4 into m3.

            rename m_temp into m4.

            

            rename Htid into Htid1.

            rename st2 into st4.

            rename Hcmpt1 into Hcmpt4.

            rename Hcnt into Hcnt4.

            rename code2 into code4.

            move code4 at bottom.

            

            rename s2 into code2.

            rename s3 into code3.

            

              evar (b4': positive).

              evar (virtueThread3 : (delta_map * delta_map)%type).

              remember (virtueThread_inject m4 j3 (virtueThread3))  as virtueThread4.

              evar (virtueLP4 : (access_map * access_map)%type).

              evar (m4' : Mem.mem).

            

            do 5 eexists; split; [|split]. 



            + 

              admit.



            + 

              admit.



            + 

              

              econstructor; eauto.

              eapply step_release with

                    (b0:= b4')

                    (virtueThread0:=virtueThread4)

                    (virtueLP0:=virtueLP4)

                    (m':=m4'); eauto; try reflexivity;

              try unfold HybridMachineSig.isCoarse,

              HybridMachineSig.HybridCoarseMachine.scheduler.



              * 



                subst virtueThread4.

                unfold virtueThread_inject.

                  destruct virtueThread3 as (virtue1, virtue2).

                  cbv iota beta delta[fst] in *.

                  split.

                -- 


                   admit.

                -- admit.

                

              * 

                admit.

              * 

                admit.



              * 

                admit.



              * 

                

                admit.



              * 

                admit.



              * 

                admit.



              * 

                

                admit. 

              * 

                admit.

                

              * 

                admit.

                

          - admit.



        Admitted.



        Lemma Create_step_diagram:

          forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

                 (st1 : ThreadPool (Some hb)) (m1' : mem) 

                 (tid : nat) (cd : option compiler_index)

                 (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

                 (m2 : mem) (Htid : ThreadPool.containsThread st1 tid)

                 (c : semC) (b : block) (ofs : Integers.Ptrofs.int) 

                 (arg : val)

                 (virtue1

                    virtue2 : PTree.t (BinNums.Z -> option (option permission)) *

                              PTree.t (BinNums.Z -> option (option permission)))

                 (threadPerm' newThreadPerm : access_map * access_map),

            HybridMachineSig.schedPeek U = Some tid ->

            forall Hcmpt : mem_compatible st1 m1',

              concur_match cd mu st1 m1' st2 m2 ->

              List.Forall2 (inject_mevent mu) tr1 tr2 ->

              bounded_maps.sub_map (fst virtue2) (snd (getMaxPerm m1')) /\

              bounded_maps.sub_map (snd virtue2) (snd (getMaxPerm m1')) ->

              bounded_maps.sub_map (fst virtue1) (snd (getMaxPerm m1')) /\

              bounded_maps.sub_map (snd virtue1) (snd (getMaxPerm m1')) ->

              invariant st1 ->

              ThreadPool.getThreadC Htid = Kblocked c ->

              Val.inject (Mem.flat_inj (Mem.nextblock m1')) arg arg ->

              semantics.at_external

                (semantics.csem (event_semantics.msem semSem)) c

                (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

              Some (CREATE, (Vptr b ofs :: arg :: nil)%list) ->

              permMapJoin (fst newThreadPerm) (fst threadPerm')

                          (fst (ThreadPool.getThreadR Htid)) ->

              permMapJoin (snd newThreadPerm) (snd threadPerm')

                          (snd (ThreadPool.getThreadR Htid)) ->

              exists

                e' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

                (mu' : meminj),

                concur_match cd' mu'

                             (ThreadPool.addThread

                                (ThreadPool.updThread Htid (Kresume c Vundef) threadPerm')

                                (Vptr b ofs) arg newThreadPerm) m1' st2' m2' /\

                List.Forall2 (inject_mevent mu')

                             (seq.cat tr1

                                      (Events.external tid

                                                       (Events.spawn

                                                          (b, Integers.Ptrofs.intval ofs)

                                                          

                                                          (Some (build_delta_content (fst virtue1) m1'))

                                                          

                                                          (Some (build_delta_content (fst virtue2) m1'))) :: nil))

                  (seq.cat tr2 (Events.external tid e' :: nil)) /\

                HybridMachineSig.external_step

                  (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                  U tr2 st2 m2 (HybridMachineSig.schedSkip U)

                                               (seq.cat tr2

                                                        (Events.external tid e' :: nil)) st2' m2'.

        Proof.

          intros U tr1 tr2 st1 m1' tid cd st2 mu m2 Htid c b ofs arg virtue1 virtue2 threadPerm' newThreadPerm.

          

          intros.

          destruct (Compare_dec.lt_eq_lt_dec tid hb) as [[?|?]|?].

          - 

            

            pose proof (mtch_target _ _ _ _ _ _ H0 _ l Htid (contains12 H0 Htid)) as HH.

            simpl in H5; exploit_match.

            inversion H14; clear H14.

            simpl.



            do 5 econstructor.

            split; [|split].



            + 

              admit.



            + simpl.

              admit.

            + econstructor; eauto.

              econstructor.

              admit.



        Admitted.



        Lemma make_step_diagram:

          forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

                 (st1 : ThreadPool (Some hb)) (m1 m1' : mem) 

                 (tid : nat) (cd : option compiler_index)

                 (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

                 (m2 : mem) (Htid : ThreadPool.containsThread st1 tid)

                 (c : semC) (b : block) (ofs : Integers.Ptrofs.int)

                 (pmap_tid' : access_map * access_map),

            concur_match cd mu st1 m1 st2 m2 ->

            List.Forall2 (inject_mevent mu) tr1 tr2 ->

            forall Hcmpt : mem_compatible st1 m1,

              HybridMachineSig.schedPeek U = Some tid ->

              invariant st1 ->

              ThreadPool.getThreadC Htid = Kblocked c ->

              semantics.at_external

                (semantics.csem (event_semantics.msem semSem)) c

                (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

              Some (MKLOCK, (Vptr b ofs :: nil)%list) ->

              Mem.store AST.Mint32

                        (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                        (Integers.Ptrofs.intval ofs) (Vint Integers.Int.zero) =

              Some m1' ->

              Mem.range_perm

                (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                (Integers.Ptrofs.intval ofs)

                (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE) Cur Writable ->

              setPermBlock (Some Nonempty) b (Integers.Ptrofs.intval ofs)

                           (fst (ThreadPool.getThreadR Htid)) LKSIZE_nat = 

              fst pmap_tid' ->

              setPermBlock (Some Writable) b (Integers.Ptrofs.intval ofs)

                           (snd (ThreadPool.getThreadR Htid)) LKSIZE_nat = 

              snd pmap_tid' ->

              ThreadPool.lockRes st1 (b, Integers.Ptrofs.intval ofs) = None ->

              exists

                e' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

                (mu' : meminj),

                concur_match cd' mu'

                             (ThreadPool.updLockSet

                                (ThreadPool.updThread Htid (Kresume c Vundef) pmap_tid')

                                (b, Integers.Ptrofs.intval ofs) (empty_map, empty_map))

                             m1' st2' m2' /\

                List.Forall2 (inject_mevent mu') (seq.cat tr1 (Events.external tid (Events.mklock (b, Integers.Ptrofs.intval ofs)) :: nil))

                  (seq.cat tr2 (Events.external tid e' :: nil)) /\

                HybridMachineSig.external_step

                  (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                  U tr2 st2 m2 (HybridMachineSig.schedSkip U)

                  (seq.cat tr2

                           (Events.external tid e' :: nil))

                  st2' m2'.

        Proof.

        Admitted.



        Lemma free_step_diagram:

          forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

                 (st1 : ThreadPool (Some hb)) (m1' : mem) 

                 (tid : nat) (cd : option compiler_index)

                 (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

                 (m2 : mem) (Htid : ThreadPool.containsThread st1 tid)

                 (c : semC) (b : block) (ofs : Integers.Ptrofs.int)

                 (pmap_tid' : access_map * access_map)

                 (pdata : nat -> option permission) (rmap : lock_info),

            concur_match cd mu st1 m1' st2 m2 ->

            List.Forall2 (inject_mevent mu) tr1 tr2 ->

            forall Hcmpt : mem_compatible st1 m1',

              HybridMachineSig.schedPeek U = Some tid ->

              bounded_maps.bounded_nat_func' pdata LKSIZE_nat ->

              invariant st1 ->

              ThreadPool.getThreadC Htid = Kblocked c ->

              semantics.at_external

                (semantics.csem (event_semantics.msem semSem)) c

                (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

              Some (FREE_LOCK, (Vptr b ofs :: nil)%list) ->

              ThreadPool.lockRes st1 (b, Integers.Ptrofs.intval ofs) =

              Some rmap ->

              (forall (b0 : BinNums.positive) (ofs0 : BinNums.Z),

                  (fst rmap) !! b0 ofs0 = None /\ (snd rmap) !! b0 ofs0 = None) ->

              Mem.range_perm

                (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                (Integers.Ptrofs.intval ofs)

                (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE) Cur Writable ->

              setPermBlock None b (Integers.Ptrofs.intval ofs)

                           (snd (ThreadPool.getThreadR Htid)) LKSIZE_nat = 

              snd pmap_tid' ->

              (forall i : nat,

                  BinInt.Z.le 0 (BinInt.Z.of_nat i) /\

                  BinInt.Z.lt (BinInt.Z.of_nat i) LKSIZE ->

                  Mem.perm_order'' (pdata (S i)) (Some Writable)) ->

              setPermBlock_var pdata b (Integers.Ptrofs.intval ofs)

                               (fst (ThreadPool.getThreadR Htid)) LKSIZE_nat = 

              fst pmap_tid' ->

              exists

                e' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

                (mu' : meminj),

                concur_match cd' mu'

                             (ThreadPool.remLockSet

                                (ThreadPool.updThread Htid (Kresume c Vundef) pmap_tid')

                                (b, Integers.Ptrofs.intval ofs)) m1' st2' m2' /\

                List.Forall2 (inject_mevent mu') (seq.cat tr1 (Events.external tid (Events.freelock (b, Integers.Ptrofs.intval ofs)) :: nil))

                  (seq.cat tr2 (Events.external tid e' :: nil)) /\

                HybridMachineSig.external_step

                  (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                  U tr2 st2 m2

                  (HybridMachineSig.schedSkip U)

                  (seq.cat tr2 (Events.external tid e' :: nil)) st2' m2'.

        Proof.

        Admitted.



        Lemma acquire_fail_step_diagram:

          forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

                 (st1' : ThreadPool (Some hb)) (m1' : mem) 

                 (tid : nat) (cd : option compiler_index)

                 (st2 : ThreadPool (Some (S hb))) (mu : meminj) 

                 (m2 : mem) (Htid : ThreadPool.containsThread st1' tid)

                 (b : block) (ofs : Integers.Ptrofs.int) 

                 (c : semC) (Hcmpt : mem_compatible st1' m1'),

            concur_match cd mu st1' m1' st2 m2 ->

            List.Forall2 (inject_mevent mu) tr1 tr2 ->

            HybridMachineSig.schedPeek U = Some tid ->

            semantics.at_external

              (semantics.csem (event_semantics.msem semSem)) c

              (restrPermMap (fst (ssrfun.pair_of_and (Hcmpt tid Htid)))) =

            Some (LOCK, (Vptr b ofs :: nil)%list) ->

            Mem.load AST.Mint32

                     (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

                     (Integers.Ptrofs.intval ofs) = Some (Vint Integers.Int.zero) ->

            Mem.range_perm

              (restrPermMap (snd (ssrfun.pair_of_and (Hcmpt tid Htid)))) b

              (Integers.Ptrofs.intval ofs)

              (BinInt.Z.add (Integers.Ptrofs.intval ofs) LKSIZE) Cur Readable ->

            ThreadPool.getThreadC Htid = Kblocked c ->

            invariant st1' ->

            exists

              e' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

              (mu' : meminj),

              concur_match cd' mu' st1' m1' st2' m2' /\

              List.Forall2 (inject_mevent mu') (seq.cat tr1 (Events.external tid (Events.failacq (b, Integers.Ptrofs.intval ofs)) :: nil))

                (seq.cat tr2 (Events.external tid e' :: nil)) /\

              HybridMachineSig.external_step

                (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                U tr2 st2 m2

                (HybridMachineSig.schedSkip U)

                (seq.cat tr2 (Events.external tid e' :: nil))

                st2' m2'.

        Proof.

        Admitted.

        

    Lemma external_step_diagram:

      forall (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace) (st1 : ThreadPool.t) 

        (m1 : mem) (st1' : ThreadPool.t) (m1' : mem) (tid : nat) (ev : Events.sync_event),

      forall (cd : option compiler_index) (st2 : ThreadPool.t) (mu : meminj) (m2 : mem),

        concur_match cd mu st1 m1 st2 m2 ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        forall (Htid : ThreadPool.containsThread st1 tid) (Hcmpt : mem_compatible st1 m1),

          HybridMachineSig.schedPeek U = Some tid ->

          syncStep true Htid Hcmpt st1' m1' ev ->

          exists ev' (st2' : t) (m2' : mem) (cd' : option compiler_index) 

            (mu' : meminj),

            concur_match cd' mu' st1' m1' st2' m2' /\

            List.Forall2 (inject_mevent mu') (seq.cat tr1 (Events.external tid ev :: nil)) (seq.cat tr2 (Events.external tid ev' :: nil)) /\

            HybridMachineSig.external_step

              (scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler) U tr2 st2 m2 (HybridMachineSig.schedSkip U)

              (seq.cat tr2 (Events.external tid ev' :: nil)) st2' m2'.

    Proof.

      intros.

      inversion H2; subst.

      - 

        eapply acquire_step_diagram; eauto.

      - 

        eapply release_step_diagram; eauto.

      - 

        eapply Create_step_diagram; eauto.

      - 

        eapply make_step_diagram; eauto.

      - 

        eapply free_step_diagram; eauto.

      - 

        eapply acquire_fail_step_diagram; eauto.

    Qed.



    Lemma start_step_diagram:

      forall (m : option mem) (tge : HybridMachineSig.G) 

        (U : list nat) (st1 : ThreadPool (Some hb)) 

        (m1 : mem) (tr1 tr2 : HybridMachineSig.event_trace)

        (st1' : ThreadPool (Some hb)) (m' : mem)

        (cd : option compiler_index) (st2 : ThreadPool (Some (S hb)))

        (mu : meminj) (m2 : mem) (tid : nat)

        (Htid : ThreadPool.containsThread st1 tid),

        concur_match cd mu st1 m1 st2 m2 ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        HybridMachineSig.schedPeek U = Some tid ->

        HybridMachineSig.start_thread m1 Htid st1' m' ->

        exists

          (st2' : ThreadPool (Some (S hb))) (m2' : mem) 

          (cd' : option compiler_index) (mu' : meminj),

          concur_match cd' mu' st1' (HybridMachineSig.diluteMem m') st2'

                       m2' /\

          List.Forall2 (inject_mevent mu') tr1 tr2 /\

          machine_semantics.machine_step(HybConcSem (Some (S hb)) m) tge

                                        U tr2 st2 m2 (HybridMachineSig.yield

                                                        (Scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                                                        U) tr2 st2' m2'.

    Proof.

    Admitted.



    Lemma resume_step_diagram:

      forall (m : option mem) (tge : HybridMachineSig.G) 

        (U : list nat) (st1 : ThreadPool (Some hb))

        (tr1 tr2 : HybridMachineSig.event_trace)

        (st1' : ThreadPool (Some hb)) (m1' : mem)

        (cd : option compiler_index) (st2 : ThreadPool (Some (S hb)))

        (mu : meminj) (m2 : mem) (tid : nat)

        (Htid : ThreadPool.containsThread st1 tid),

        concur_match cd mu st1 m1' st2 m2 ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        HybridMachineSig.schedPeek U = Some tid ->

        HybridMachineSig.resume_thread m1' Htid st1' ->

        exists

          (st2' : ThreadPool (Some (S hb))) (m2' : mem) 

          (cd' : option compiler_index) (mu' : meminj),

          concur_match cd' mu' st1' m1' st2' m2' /\

          List.Forall2 (inject_mevent mu') tr1 tr2 /\

          machine_semantics.machine_step (HybConcSem (Some (S hb)) m) tge

                                         U tr2 st2 m2

                                         (HybridMachineSig.yield(Scheduler:=HybridMachineSig.HybridCoarseMachine.scheduler)

                                                                U) tr2 st2' m2'.

    Proof.

      admit.  

    Admitted.



    Lemma suspend_step_diagram:

      forall (m : option mem) (tge : HybridMachineSig.G) 

        (U : list nat) (st1 : ThreadPool (Some hb))

        (tr1 tr2 : HybridMachineSig.event_trace)

        (st1' : ThreadPool (Some hb)) (m1' : mem)

        (cd : option compiler_index) (st2 : ThreadPool (Some (S hb)))

        (mu : meminj) (m2 : mem) (tid : nat)

        (Htid : ThreadPool.containsThread st1 tid),

        concur_match cd mu st1 m1' st2 m2 ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        HybridMachineSig.schedPeek U = Some tid ->

        HybridMachineSig.suspend_thread m1' Htid st1' ->

        exists

          (st2' : ThreadPool (Some (S hb))) (m2' : mem) 

          (cd' : option compiler_index) (mu' : meminj),

          concur_match cd' mu' st1' m1' st2' m2' /\

          List.Forall2 (inject_mevent mu') tr1 tr2 /\

          machine_semantics.machine_step (HybConcSem (Some (S hb)) m) tge

                                         U tr2 st2 m2 (HybridMachineSig.schedSkip U) tr2 st2' m2'.

    Proof.

      admit. 

    Admitted.



    Lemma schedfail_step_diagram:

      forall (m : option mem) (tge : HybridMachineSig.G) 

        (U : list nat) (tr1 tr2 : HybridMachineSig.event_trace)

        (st1' : ThreadPool (Some hb)) (m1' : mem)

        (st2 : ThreadPool (Some (S hb))) (m2 : mem) 

        (tid : nat) cd mu,

        concur_match cd mu st1' m1' st2 m2 ->

        List.Forall2 (inject_mevent mu) tr1 tr2 ->

        HybridMachineSig.schedPeek U = Some tid ->

        ~ ThreadPool.containsThread st1' tid ->

        HybridMachineSig.invariant st1' ->

        HybridMachineSig.mem_compatible st1' m1' ->

        exists

          (st2' : ThreadPool (Some (S hb))) (m2' : mem) 

          (cd' : option compiler_index) (mu' : meminj),

          concur_match cd' mu' st1' m1' st2' m2' /\

          List.Forall2 (inject_mevent mu') tr1 tr2 /\

          machine_semantics.machine_step (HybConcSem (Some (S hb)) m) tge

                                         U tr2 st2 m2 (HybridMachineSig.schedSkip U) tr2 st2' m2'.

    Proof.

      admit.

      

    Admitted.

    

    Lemma machine_step_diagram:

      forall (m : option mem) (sge tge : HybridMachineSig.G) (U : list nat)

        (tr1 : HybridMachineSig.event_trace) (st1 : ThreadPool (Some hb)) 

        (m1 : mem) (U' : list nat) (tr1' : HybridMachineSig.event_trace)

        (st1' : ThreadPool (Some hb)) (m1' : mem),

        machine_semantics.machine_step (HybConcSem (Some hb) m) sge U tr1 st1 m1 U' tr1' st1' m1' ->

            forall (cd : option compiler_index) tr2 (st2 : ThreadPool (Some (S hb))) 

                   (mu : meminj) (m2 : mem),

              concur_match cd mu st1 m1 st2 m2 ->

              List.Forall2 (inject_mevent mu) tr1 tr2 ->

              exists

                tr2' (st2' : ThreadPool (Some (S hb))) (m2' : mem) (cd' : option compiler_index) 

                (mu' : meminj),

                concur_match cd' mu' st1' m1' st2' m2' /\

                List.Forall2 (inject_mevent mu') tr1' tr2' /\

                machine_semantics.machine_step (HybConcSem (Some (S hb)) m) tge U tr2 st2 m2 U' tr2' st2'

                                               m2'.

    Proof.

      intros.

      simpl in H.

      inversion H; subst.

      - 

        exists tr2; eapply start_step_diagram; eauto.

        

      - 

        exists tr2; eapply resume_step_diagram; eauto.

          

      - 

        exists tr2; eapply suspend_step_diagram; eauto.

        

      - 

        edestruct external_step_diagram as (? & ? & ? & ? & ? & ? & ? & ?); eauto 8.



      - 

        exists tr2; eapply schedfail_step_diagram; eauto.

    Qed.



    Lemma initial_diagram:

      forall (m : option mem) (s_mem s_mem' : mem) (main : val) (main_args : list val)

        (s_mach_state : ThreadPool (Some hb)) (r1 : option res),

        machine_semantics.initial_machine (HybConcSem (Some hb) m) r1 s_mem s_mach_state s_mem'

                                          main main_args ->

        exists

          (j : meminj) (cd : option compiler_index) (t_mach_state : ThreadPool (Some (S hb))) 

          (t_mem t_mem' : mem) (r2 : option res),

          machine_semantics.initial_machine (HybConcSem (Some (S hb)) m) r2 t_mem t_mach_state

                                            t_mem' main main_args /\ concur_match cd j s_mach_state s_mem' t_mach_state t_mem'.

    Proof.

      intros m.

      

      simpl; unfold HybridMachineSig.init_machine''.

      intros ? ? ? ? ? ? (?&?).

      destruct r1; try solve[inversion H0].

      simpl in H0.

      destruct H0 as (init_thread&?&?); simpl in *.

      unfold initial_core_sum in *.

      destruct init_thread; destruct H0 as (LT&H0); simpl in LT.

      + admit. 

      + admit. 

    Admitted.

    

    Lemma compile_one_thread:

      forall m,

        HybridMachine_simulation_properties

          (HybConcSem (Some hb) m)

          (HybConcSem (Some (S hb)) m)

          (concur_match).

    Proof.

      intros.

      econstructor.

      - eapply option_wf.

        eapply (Injfsim_order_wf compiler_sim). 



      - eapply initial_diagram.



      - eapply internal_step_diagram.



      - eapply machine_step_diagram.



      - simpl; unfold HybridMachineSig.halted_machine; simpl; intros.

        destruct (HybridMachineSig.schedPeek U); inversion H0.

        eexists; reflexivity.



      - eapply concur_match_same_running.

        

    Qed.



  End CompileOneThread.



  Section CompileNThreads.

    

    Definition nth_index:= list (option compiler_index).

    Definition list_lt: nth_index -> nth_index -> Prop.

    Admitted.

    Lemma list_lt_wf:

      well_founded list_lt.

    Admitted.

    Inductive match_state:

      forall n,

      nth_index ->

        Values.Val.meminj ->

        ThreadPool (Some 0) -> Memory.Mem.mem -> ThreadPool (Some n) -> Memory.Mem.mem -> Prop:=

    | refl_match: forall j tp m,

        match_state 0 nil j tp m tp m

    | step_match_state:

        forall n ocd ils jn jSn tp0 m0 tpn mn tpSn mSn,

          match_state n ils jn tp0 m0 tpn mn ->

          concur_match n ocd jSn tpn mn tpSn mSn ->

          match_state (S n) (cons ocd ils) (compose_meminj jn jSn) tp0 m0 tpSn mSn.



    Lemma trivial_self_injection:

          forall m : option mem,

            HybridMachine_simulation_properties (HybConcSem (Some 0) m)

                                                (HybConcSem (Some 0) m) (match_state 0).

    Proof.

      
    Admitted.



    Lemma simulation_inductive_case:

      forall n : nat,

        (forall m : option mem,

            HybridMachine_simulation_properties (HybConcSem (Some 0) m)

                                                (HybConcSem (Some n) m) (match_state n)) ->

        (forall m : option mem,

            HybridMachine_simulation_properties (HybConcSem (Some n) m)

                                                (HybConcSem (Some (S n)) m) (concur_match n)) ->

        forall m : option mem,

          HybridMachine_simulation_properties (HybConcSem (Some 0) m)

                                              (HybConcSem (Some (S n)) m) (match_state (S n)).

    Proof.

      intros n.

    Admitted.

    

    Lemma compile_n_threads:

      forall n m,

        HybridMachine_simulation.HybridMachine_simulation_properties

          (HybConcSem (Some 0) m)

          (HybConcSem (Some n) m)

          (match_state n).

    Proof.

      induction n.

      - 

        apply trivial_self_injection.

      - eapply simulation_inductive_case; eauto.

        eapply compile_one_thread.

    Qed.



  End CompileNThreads.



 Section CompileInftyThread.



   Parameter lift_state: forall on, ThreadPool on -> forall on', ThreadPool on' -> Prop.

   

   Inductive infty_match:

             nth_index -> meminj ->

             ThreadPool (Some 0) -> mem ->

             ThreadPool None -> mem -> Prop:=

   | Build_infty_match:

       forall n cd j st0 m0 stn mn st,

         match_state n cd j st0 m0 stn mn ->

         lift_state (Some n) stn None st ->

         infty_match cd j st0 m0 st mn.



   Lemma initial_infty:

          forall (m : option mem) (s_mem s_mem' : mem) 

                 (main : val) (main_args : list val)

                 (s_mach_state : ThreadPool (Some 0)) (r1 : option res),

            machine_semantics.initial_machine (HybConcSem (Some 0) m) r1

                                              s_mem s_mach_state s_mem' main main_args ->

            exists

              (j : meminj) (cd : nth_index) (t_mach_state : ThreadPool None) 

              (t_mem t_mem' : mem) (r2 : option res),

              machine_semantics.initial_machine (HybConcSem None m) r2 t_mem

                                                t_mach_state t_mem' main main_args /\

              infty_match cd j s_mach_state s_mem' t_mach_state t_mem'.

   Proof.

     
   Admitted.



   Lemma infinite_step_diagram:

          forall (m : option mem) (sge tge : HybridMachineSig.G)

                 (U : list nat) tr1 (st1 : ThreadPool (Some 0)) 

                 (m1 : mem) (st1' : ThreadPool (Some 0)) 

                 (m1' : mem),

            machine_semantics.thread_step (HybConcSem (Some 0) m) sge U st1

                                          m1 st1' m1' ->

            forall (cd : nth_index) tr2 (st2 : ThreadPool None) 

                   (mu : meminj) (m2 : mem),

              infty_match cd mu st1 m1 st2 m2 ->

              List.Forall2 (inject_mevent mu) tr1 tr2 ->

              exists

                (st2' : ThreadPool None) (m2' : mem) (cd' : nth_index) 

                (mu' : meminj),

                infty_match cd' mu' st1' m1' st2' m2' /\

                List.Forall2 (inject_mevent mu') tr1 tr2 /\

                (machine_semantics_lemmas.thread_step_plus 

                   (HybConcSem None m) tge U st2 m2 st2' m2' \/

                 machine_semantics_lemmas.thread_step_star 

                   (HybConcSem None m) tge U st2 m2 st2' m2' /\ 

                 list_lt cd' cd).

        Proof.

          
        Admitted.

        Lemma infinite_machine_step_diagram:

          forall (m : option mem) (sge tge : HybridMachineSig.G)

                 (U : list nat) (tr1 : HybridMachineSig.event_trace)

                 (st1 : ThreadPool (Some 0)) (m1 : mem) (U' : list nat)

                 (tr1' : HybridMachineSig.event_trace)

                 (st1' : ThreadPool (Some 0)) (m1' : mem),

            machine_semantics.machine_step (HybConcSem (Some 0) m) sge U tr1

                                           st1 m1 U' tr1' st1' m1' ->

            forall (cd : nth_index) tr2 (st2 : ThreadPool None) 

                   (mu : meminj) (m2 : mem),

              infty_match cd mu st1 m1 st2 m2 ->

              List.Forall2 (inject_mevent mu) tr1 tr2 ->

              exists

                tr2' (st2' : ThreadPool None) (m2' : mem) (cd' : nth_index) 

                (mu' : meminj),

                infty_match cd' mu' st1' m1' st2' m2' /\

                List.Forall2 (inject_mevent mu') tr1' tr2' /\

                machine_semantics.machine_step (HybConcSem None m) tge U tr2 st2

                                               m2 U' tr2' st2' m2'.

        Proof.

          

        Admitted.



        Lemma infinite_halted:

          forall (m : option mem) (cd : nth_index) (mu : meminj)

                 (U : list nat) (c1 : ThreadPool (Some 0)) 

                 (m1 : mem) (c2 : ThreadPool None) (m2 : mem) 

                 (v1 : val),

            infty_match cd mu c1 m1 c2 m2 ->

            machine_semantics.conc_halted (HybConcSem (Some 0) m) U c1 =

            Some v1 ->

            exists v2 : val,

              machine_semantics.conc_halted (HybConcSem None m) U c2 =

              Some v2.

        Proof.

          intros m.

          

        Admitted.



        Lemma infinite_running:

          forall (m : option mem) (cd : nth_index) (mu : meminj)

                 (c1 : ThreadPool (Some 0)) (m1 : mem) (c2 : ThreadPool None)

                 (m2 : mem),

            infty_match cd mu c1 m1 c2 m2 ->

            forall i : nat,

              machine_semantics.running_thread (HybConcSem (Some 0) m) c1 i <->

              machine_semantics.running_thread (HybConcSem None m) c2 i.

        Proof.

          intros m.

          
        Admitted.

  Lemma compile_all_threads:

      forall m,

        HybridMachine_simulation.HybridMachine_simulation_properties

          (HybConcSem (Some 0) m)

          (HybConcSem None m)

          infty_match.

    Proof.

      intros. 

      

      pose proof compile_n_threads as HH.

      econstructor.

      - eapply list_lt_wf.

      - apply initial_infty.

      - apply infinite_step_diagram.

      - apply infinite_machine_step_diagram.

      - apply infinite_halted.

      - apply infinite_running.



    Qed.



 End CompileInftyThread.



 Section TrivialSimulations.

   Lemma trivial_clight_simulation:

   (HybridMachine_simulation

    (ClightMachine.DMS.ClightConcurSem(ge:=Clight_g)

       (Genv.init_mem (Ctypes.program_of_program C_program)))

    (HybConcSem (Some 0) (Genv.init_mem (Ctypes.program_of_program C_program)))).

   Admitted.

   Lemma trivial_asm_simulation:

     (HybridMachine_simulation

        (HybConcSem None (Genv.init_mem Asm_program))

        (X86Context.AsmConcurSem

           (the_program:=Asm_program)

           (Hsafe:=Asm_genv_safe)

           (Genv.init_mem Asm_program))).

   Admitted.

   End TrivialSimulations.



 Section SimulationTransitivity.

   Lemma HBSimulation_transitivity:

     forall G1 G2 G3 TID SCH C1 C2 C3 res,

     forall (Machine1 : @machine_semantics.ConcurSemantics G1 TID SCH _ C1 mem res)

       (Machine2 : @machine_semantics.ConcurSemantics G2 TID SCH _ C2 mem res)

       (Machine3 : @machine_semantics.ConcurSemantics G3 TID SCH _ C3 mem res),

     HybridMachine_simulation Machine1 Machine2 -> 

     HybridMachine_simulation Machine2 Machine3 ->

     HybridMachine_simulation Machine1 Machine3.

   Proof.

    destruct 1 as [index1 match_state1 SIM1].

    destruct 1 as [index2 match_state2 SIM2].

    eapply Build_HybridMachine_simulation with (index := (index1 * index2)%type)

      (match_state := fun a j c1 m1 c3 m3 => exists j1 j2 c2 m2, j = compose_meminj j1 j2 /\

         match_state1 (fst a) j1 c1 m1 c2 m2 /\ match_state2 (snd a) j2 c2 m2 c3 m3).

    inversion SIM1; inversion SIM2; econstructor.

    - apply Coqlib.wf_lex_ord; eauto.

    - intros.

      destruct (initial_setup _ _ _ _ _ _ H) as (? & ? & ? & ? & ? & ? & H2 & ?).

      destruct (initial_setup0 _ _ _ _ _ _ H2) as (? & ? & ? & ? & ? & ? & ? & ?).

      eexists; eexists (_, _); eauto 12.

    - intros.

      
      admit.



    - intros.

      
      admit.

    - intros ???????? (? & ? & ? & ? & ? & ? & ?) ?.

      edestruct thread_halted; eauto.

    - intros ?????? (? & ? & ? & ? & ? & ? & ?) ?.

      erewrite thread_running; eauto.

   Admitted.

 End SimulationTransitivity.

 

 End ThreadedSimulation.

End ThreadedSimulation.



Module Concurrent_correctness (CC_correct: CompCert_correctness).

  Module TSim:= (ThreadedSimulation CC_correct).

  Import TSim.



  Lemma initial_memories_are_equal:

              forall (p : Clight.program) (tp : Asm.program),

                Genv.init_mem tp = Genv.init_mem (Ctypes.program_of_program p).

        Proof.

          intros p tp.

        Admitted.

  

  Lemma ConcurrentCompilerCorrectness:

    forall (p:Clight.program) (tp:Asm.program),

      CC_correct.CompCert_compiler p = Some tp ->

      forall asm_genv_safety,

        ConcurrentCompilerCorrectness_specification

          (Clight.globalenv p) tp asm_genv_safety

          (Genv.init_mem (Ctypes.program_of_program p)) (Genv.init_mem tp)

  .

  Proof.

    unfold ConcurrentCompilerCorrectness_specification.

    intros.

    eapply HBSimulation_transitivity; eauto.

    - eapply trivial_clight_simulation; eauto.

    -

      eapply HBSimulation_transitivity.

      + eauto.

      + eauto.

      + econstructor.

        eapply compile_all_threads.

      + replace (Genv.init_mem (Ctypes.program_of_program p)) with (Genv.init_mem tp) by

            eapply initial_memories_are_equal.

        eapply trivial_asm_simulation; eauto.

        

      Unshelve. auto.

  Qed.



End Concurrent_correctness.

