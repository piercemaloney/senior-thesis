
Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)
Require Import lam_ref_eval.
(* lam_ref_eval:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.

Require Import msl.msl_standard.

Section eval.
  Variable eval : mem -> expr -> (mem * expr).

  Definition eval' (m:mem) (e0:expr) : mem * expr :=
  match e0 with
  | App e1 e2 =>
      match eval m e1 with
      | (m', Lam e1') =>
          let (m'',e2') := eval m' e2 in
            match value_dec e2' with
            | left H => eval m'' (subst 0 (exp_to_val e2' H) e1')
            | _ => (m'',App (Lam e1') e2')
            end
      | (m',e1') => (m',App e1' e2)
      end
  | Prim f e1 =>
      match eval m e1 with
      | (m', Nat x) =>
        match value_dec (f x) with
        | left H => (m',f x)
        | _ => (m',Prim f (Nat x))
        end
      | (m',e1') => (m',Prim f e1')
      end
  | New e1 =>
      let (m',e') := eval m e1 in
      match value_dec e' with
      | left H =>
           let (m'',l) := new m' (exp_to_val e' H) in (m'',Loc l)
      | _ => (m',New e')
      end
  | Deref e1 =>
      match eval m e1 with
      | (m',Loc l) => eval m' (val_to_exp (deref m' l))
      | (m',e1') => (m',Deref e1')
      end
  | Update e1 e2 e3 =>
      match eval m e1 with
      | (m',Loc l) =>
          let (m'',e2') := eval m' e2 in
          match value_dec e2' with
          | left H =>
              eval (update m'' l (exp_to_val e2' H)) e3
          | _ => (m'',Update (Loc l) e2' e3)
          end
      | (m',x) => (m',Update x e2 e3)
      end
  | x => (m,x)
  end.

  Hypothesis Heval :
    forall m e m' e',
      eval m e = (m',e') ->
      stepstar (m,e) (m',e').

  Lemma eval'_correct :
    forall m e m' e',
      eval' m e = (m',e') ->
      stepstar (m,e) (m',e').
End eval.

Definition eval (x:Z) := Zmisc.iter x _ eval' (fun m e => (m,e)).

Lemma eval_correct : forall x m e m' e',
  eval x m e = (m',e') ->
  stepstar (m,e) (m',e'). *)
Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)
Require Import lam_ref_mach_lemmas.
(* lam_ref_mach_lemmas:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Lemma isVal_val2exp : forall v, isValue (val_to_exp v).

Lemma closed_dec : forall e n,
  { closed' n e} + { ~closed' n e}.

Lemma value_dec : forall e,
  { isValue e } + { ~isValue e }.

Ltac show_stopped :=
  let m' := fresh "m'" in
  let e' := fresh "e'" in
  let H := fresh "H" in
  right; intros [m' [e' H]]; inv H.

Lemma stopped_dec : forall e m,
  { st | step (m,e) st} + { stopped m e }.

Lemma closed'_S : forall n e,
  closed' n e ->
  closed' (S n) e.

Lemma closed'_le : forall m n,
  m <= n ->
  forall e,
  closed' m e ->
  closed' n e.

Lemma closed'_subst: forall m e x v,
  closed' m e ->
  subst (x + m) v e = e.

Lemma closed_closed_subst: forall x v e,
  closed e ->
  closed (subst x v e).

Lemma closed_Lam_subst: forall e x v,
  closed (Lam e) ->
  subst x v (Lam e) = Lam e.

Lemma subst_env'_Nat: forall rho m n,
  subst_env' m rho (Nat n) = Nat n.

Lemma subst_env'_Loc: forall rho m l,
  subst_env' m rho (Loc l) = Loc l.

Lemma subst_env'_Var': forall n m rho,
  subst_env' (S (n + m)) rho (Var n) = Var n.

Lemma subst_env'_Var: forall rho n v m,
  nth_error rho n = Some v ->
  subst_env' m rho (Var (n + m)) = val_to_exp v.

Lemma subst_env'_New: forall rho m e,
  subst_env' m rho (New e) = New (subst_env' m rho e).

Lemma subst_env'_Deref: forall rho m e,
  subst_env' m rho (Deref e) = Deref (subst_env' m rho e).

Lemma subst_env'_Update: forall rho m e1 e2 e3,
  subst_env' m rho (Update e1 e2 e3) =
  Update (subst_env' m rho e1) (subst_env' m rho e2) (subst_env' m rho e3).

Lemma subst_env_New: forall rho e,
  subst_env rho (New e) = New (subst_env rho e).

Lemma subst_env_Deref: forall rho e,
  subst_env rho (Deref e) = Deref (subst_env rho e).

Lemma subst_env_Update: forall rho e1 e2 e3,
  subst_env rho (Update e1 e2 e3) =
  Update (subst_env rho e1) (subst_env rho e2) (subst_env rho e3).

Lemma subst_env_App : forall env e1 e2,
  subst_env env (App e1 e2) = App (subst_env env e1) (subst_env env e2).

Lemma subst_env_Prim : forall env f e,
  subst_env env (Prim f e) = Prim f (subst_env env e).

Lemma subst_subst_neq : forall e n m v1 v2,
  n <> m ->
  subst n v1 (subst m v2 e) =
  subst m v2 (subst n v1 e).

Lemma subst_env_split : forall env1 env2 n e,
  subst_env' n (env1 ++ env2) e =
  subst_env' n env1 (subst_env' (length env1 + n) env2 e).

Lemma subst_subst_env_lt : forall env n m v e,
  n < m ->
  subst n v (subst_env' m env e) =
  subst_env' m env (subst n v e).

Lemma subst_closed' :
  forall e n v,
    closed' (S n) e ->
    closed' n (subst n v e).

Lemma closed_subst_env : forall env e x n,
   closed' (length env + x) e ->
   closed' (x + n) (subst_env' (x + n) env e).

Lemma closed_step : forall x y ,
  step x y ->
  closed (snd x) ->
  closed (snd y).

Lemma values_stopped: forall e,
  isValue e ->
  forall m,
  stopped m e.

Lemma stopped_New: forall m e,
  stopped m (New e) ->
  stopped m e.

Lemma stopped_Deref: forall m e,
  stopped m (Deref e) ->
  stopped m e.

Lemma stopped_Update: forall m e1 e2 e3,
  stopped m (Update e1 e2 e3) ->
  stopped m e1 \/ (isValue e1 /\ stopped m e2).

Lemma step_deterministic: forall m e m1 e1 m2 e2,
  step (m,e) (m1,e1) ->
  step (m,e) (m2,e2) ->
  m1 = m2 /\ e1 = e2.

Lemma stepn_value: forall j m v st,
  isValue v ->
  stepn j (m, v) st ->
  st = (m, v).

Lemma stepstar_search : forall f m e m' e',
  (forall m e m' e',
    step (m,e) (m',e') -> step (m,f e) (m',f e')) ->
  stepstar (m,e) (m',e') ->
  stepstar (m,f e) (m', f e').

Lemma stepn_trans : forall n m st1 st2 st3,
  stepn n st1 st2 ->
  stepn m st2 st3 ->
  stepn (n+m) st1 st3.

Lemma stepstar_stepn : forall st st',
  stepstar st st' <-> exists n, stepn n st st'. *)
Require Import lam_ref_type_defs.
(* lam_ref_type_defs:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Require Export lam_ref_type_prelim.

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.

Lemma ty_nat_extends :
  boxy extendM ty_nat.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).

Lemma just_extends : forall v,
  %just v = just v.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau. *)
Require Import lam_ref_type_safety.
(* lam_ref_type_safety:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.

Lemma expr_type_safen: forall k v e tau,
  expr_type e tau (k,v) ->
    forall m, mtype_valid m (k,v) ->
      safen (level k) (m,e).

Theorem typing_implies_safety: forall e tau,
  Typ nil e tau ->
  safe_prog e. *)
Require Import lam_ref_type_rules.
(* lam_ref_type_rules:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.
Require Import lam_ref_type_safety.
Require Import lam_ref_type_lemmas.

Lemma T_weaken : forall G G' e tau,
  Typ G e tau ->
  Typ (G++G') e tau.

Lemma T_weaken_nil : forall G e tau,
  Typ nil e tau ->
  Typ G e tau.

Fixpoint gamma_sub (G G':etype) {struct G} : Prop :=
  match G, G' with
  | nil, nil => True
  | x::xs, y::ys => TT |-- y >=> x /\ gamma_sub xs ys
  | _, _ => False
  end.

Lemma etype_valid_sub : forall G G' env a,
  gamma_sub G G' ->
  etype_valid env G' a ->
  etype_valid env G  a.

Lemma T_weaken_sub : forall G G' e tau,
  gamma_sub G G' ->
  Typ G  e tau ->
  Typ G' e tau.

Lemma T_sub : forall G tau tau' e,
  TT |-- tau >=> tau' ->
  Typ G e tau ->
  Typ G e tau'.

Lemma T_Nat : forall G n,
  Typ G (Nat n) ty_nat.

Lemma T_Var: forall G x tau,
  nth_error G x = Some tau -> 
  Typ G (Var x) tau.

Lemma T_Abs: forall G sigma e tau,
  Typ (sigma :: G) e tau ->
  Typ G (Lam e) (ty_lam sigma tau).

Definition prim (f:nat -> value) : expr -> expr :=
  Prim (val_to_exp oo f).

Lemma T_Prim : forall G f e sigma,
  (forall n, Typ nil (val_to_exp (f n)) sigma) ->
  Typ G e ty_nat ->
  Typ G (prim f e) sigma.

Lemma T_New: forall G e tau,
  Typ G e tau ->
  Typ G (New e) (ty_ref tau).

Lemma T_App: forall G e1 sigma tau e2,
  Typ G e1 (ty_lam sigma tau) ->
  Typ G e2 sigma ->
  Typ G (App e1 e2) tau.

Lemma T_Deref: forall G e tau,
  Typ G e (ty_ref tau) ->
  Typ G (Deref e) tau.

Lemma T_Update: forall G e1 tau e2 e3 sigma,
  Typ G e1 (ty_ref tau) ->
  Typ G e2 tau ->
  Typ G e3 sigma ->
  Typ G (Update e1 e2 e3) sigma.

Definition AllBnd (T:pred world) (X:pred world -> pred world)
  := ALL tau:pred world, !!(TT |-- tau >=> T) --> X tau.

Lemma sub_AllBnd : forall T1 T2 (X1 X2:pred world -> pred world),
  TT |-- T2 >=> T1 ->
  (forall x, TT |-- x >=> T2 -> TT |-- X1 x >=> X2 x) ->
  TT |-- AllBnd T1 X1 >=> AllBnd T2 X2.

Lemma AllBnd_ALL : forall (X:pred world -> pred world),
  allp X = AllBnd TT X.

Lemma T_UnivBoundedI : forall G e T (X:pred world -> pred world),
  openValue e ->
  (forall tau, TT |-- tau >=> T -> Typ G e (X tau)) ->
  Typ G e (AllBnd T X).

Lemma T_UnivBoundedE : forall G e T (X:pred world -> pred world) tau,
  TT |-- tau >=> T ->
  Typ G e (AllBnd T X) ->
  Typ G e (X tau).

Lemma T_UnivI : forall G e (X:pred world -> pred world),
  openValue e ->
  (forall tau, Typ G e (X tau)) ->
  Typ G e (allp X).

Lemma T_UnivE : forall G e (X:pred world -> pred world) tau,
  Typ G e (allp X) ->
  Typ G e (X tau).

Definition ty_ex (F:pred world -> pred world) : pred world :=
  EX tau:pred world, !!(boxy extendM tau) && F tau.

Lemma T_ExtI : forall G e (X:pred world -> pred world) tau
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  boxy extendM tau ->
  Typ G e (X tau) ->
  Typ G e (ty_ex X).

Lemma T_ExtE : forall G e f (X:pred world -> pred world) sigma
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  Typ G e (ty_ex X) ->
  (forall tau, Typ (X tau::G) f sigma) ->
  Typ G (App (Lam f) e) sigma. *)

Definition unary_primop (f:nat -> nat) : expr :=
  Lam (prim (v_Nat oo f) (Var 0)).

Program Definition bin_primop (f:nat -> nat -> nat) : expr :=
  Lam (prim (fun n1 => Lam (prim (fun n2 => v_Nat (f n1 n2)) (Var 0))) (Var 0)).
Next Obligation.
  compute; split; auto.
Qed.

Lemma unary_primop_typ : forall f,
  Typ nil (unary_primop f) (ty_lam ty_nat ty_nat).
Proof.
  intros; unfold unary_primop.
  apply T_Abs.
  apply T_Prim.
  intros.
  unfold val_to_exp, v_Nat; simpl.
  eapply T_Nat.
  apply T_Var; auto.
Qed.

Lemma binary_primop_typ : forall (f:nat -> nat -> nat),
  Typ nil (bin_primop f) (ty_lam ty_nat (ty_lam ty_nat ty_nat)).
Proof.
  intros.
  unfold bin_primop.
  apply T_Abs.
  apply T_Prim; intros.
  unfold val_to_exp; simpl.
  apply T_Abs.
  apply T_Prim; intros.
  unfold val_to_exp, v_Nat; simpl.
  apply T_Nat.
  apply T_Var; auto.
  apply T_Var; auto.
Qed.

Definition ty_bool := ALL a:pred world, ty_lam a (ty_lam a a).
Definition e_true := Lam (Lam (Var 1)).
Definition e_false := Lam (Lam (Var 0)).

Definition e_if b t f :=
  (App (App (App b (Lam t)) (Lam f)) (Nat 0)).

Lemma e_true_typ :
  Typ nil e_true ty_bool.
Proof.
  unfold e_true, ty_bool.
  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_Abs.
  apply T_Var; simpl; auto.
Qed.

Lemma e_false_typ :
  Typ nil e_false ty_bool.
Proof.
  unfold e_false, ty_bool.
  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_Abs.
  apply T_Var; simpl; auto.
Qed.

Lemma T_if : forall G b t f tau,
  Typ G b ty_bool ->
  Typ (TT :: G) t tau ->
  Typ (TT :: G) f tau ->
  Typ G (e_if b t f) tau.
Proof.
  intros.
  unfold e_if.
  apply T_App with TT.
  apply T_App with (ty_lam TT tau).
  apply T_App with (ty_lam TT tau).
  change (ty_lam (ty_lam TT tau) (ty_lam (ty_lam TT tau) (ty_lam TT tau)))
    with ((fun t => ty_lam t (ty_lam t t)) (ty_lam TT tau)).
  apply T_UnivE.
  apply H.
  apply T_Abs; auto.
  apply T_Abs; auto.
  apply T_weaken_nil.
  apply T_sub with ty_nat.
  apply subp_top.
  apply T_Nat.
Qed.

Program Definition isZ : expr -> expr :=
  prim (fun n => if beq_nat n 0 then e_true else e_false).
Solve Obligations using (compute; split; auto).

Lemma T_isZ : forall G e,
  Typ G e ty_nat ->
  Typ G (isZ e) ty_bool.
Proof.
  intros.
  unfold isZ.
  apply T_Prim; intros; auto.
  unfold val_to_exp; simpl.
  destruct (beq_nat n 0); simpl.
  apply e_true_typ.
  apply e_false_typ.
Qed.

Definition e_let (def body:expr) :=
  (App (Lam body) def).

Definition option (a:pred world) :=
  ALL b:pred world, ty_lam b (ty_lam (ty_lam a b) b).

Definition none : expr := Lam (Lam (Var 1)).
Definition some : expr := Lam (Lam (Lam (App (Var 0) (Var 2)))).
Definition out  : expr := Lam (Lam (App (App (Var 0) (Var 1)) (Lam (Var 0)))).

Lemma out_typ :
  Typ nil out (ALL tau:pred world, ty_lam tau (ty_lam (option tau) tau)).
Proof.
  intros.
  unfold out.
  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_Abs.
  eapply T_App with (ty_lam tau tau).
  2: apply T_Abs.
  2: apply T_Var; simpl; auto.
  apply T_App with tau.
  2: apply T_Var; simpl; auto.
  unfold option.
  change (ty_lam tau (ty_lam (ty_lam tau tau) tau))
    with ((fun b => ty_lam b (ty_lam (ty_lam tau b) b)) tau).
  apply T_UnivE.
  apply T_Var; simpl; auto.
Qed.

Lemma none_typ :
  Typ nil none (ALL tau:pred world, option tau).
Proof.
  intros.
  unfold none.
  unfold option.
  apply T_UnivI.
  simpl; auto.
  intros.
  apply T_UnivI.
  simpl; auto.
  intros b.
  apply T_Abs.
  apply T_Abs.
  apply T_Var.
  simpl; auto.
Qed.

Lemma some_typ :
  Typ nil some (ALL tau:pred world, ty_lam tau (option tau)).
Proof.
  unfold some.
  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  unfold option.
  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_Abs.
  apply T_App with tau.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
Qed.

Definition W := (Lam (App (Var 0) (Var 0))).
Definition diverge := App W W.

Definition W_ty Z := fun X => ty_lam X Z.
Lemma W_ty_cont : forall Z, contractive (W_ty Z).
Proof.
  intros.
  unfold W_ty.
  apply ty_lam_contractive.
  hnf; simpl; intros.
  hnf; auto.
  hnf; simpl; repeat intro.
  split; hnf; eauto.
Qed.

Lemma W_typ : forall Z, Typ nil W (Rec (W_ty Z)).
Proof.
  intros.
  rewrite Rec_fold_unfold.
  2: apply W_ty_cont.
  unfold W.
  unfold W_ty.
  apply T_Abs.
  apply T_App with (Rec (W_ty Z)).
  rewrite Rec_fold_unfold.
  2: apply W_ty_cont.
  apply T_Var; auto.
  apply T_Var; auto.
Qed.

Lemma diverge_typ : forall t,
  Typ nil diverge t.
Proof.
  intros.
  unfold diverge.
  apply T_App with (Rec (W_ty t)).
  generalize (W_typ t).
  rewrite Rec_fold_unfold at 1; auto.
  apply W_ty_cont.
  apply W_typ.
Qed.

Definition Wf := (Lam (App (Var 1) (Lam (App (App (Var 1) (Var 1)) (Var 0))))).
Definition Y := Lam (App Wf Wf).

Definition Wf_ty A B := fun X => ty_lam X (ty_lam A B).
Lemma Wf_ty_cont : forall A B, contractive (Wf_ty A B).
Proof.
  intros.
  unfold Wf_ty.
  apply ty_lam_contractive.
  repeat intro; auto.
  repeat intro; split; repeat intro; auto.
Qed.

Lemma Wf_typ : forall A B,
  Typ (ty_lam (ty_lam A B) (ty_lam A B) :: nil) Wf (Rec (Wf_ty A B)).
Proof.
  intros.
  unfold Wf.
  rewrite Rec_fold_unfold.
  2: apply Wf_ty_cont.
  unfold Wf_ty.
  apply T_Abs.
  apply T_App with (ty_lam A B).
  apply T_Var; simpl; auto.
  apply T_Abs.
  apply T_App with A.
  apply T_App with (Rec (Wf_ty A B)).
  rewrite Rec_fold_unfold at 1.
  2: apply (Wf_ty_cont A B).
  apply T_Var; auto.
  apply T_Var; auto.
  apply T_Var; auto.
Qed.

Lemma Y_typ : forall A B,
  Typ nil Y (ty_lam (ty_lam (ty_lam A B) (ty_lam A B)) (ty_lam A B)).
Proof.
  intros.
  unfold Y.
  apply T_Abs.
  apply T_App with (Rec (Wf_ty A B)).
  generalize (Wf_typ A B).
  rewrite Rec_fold_unfold at 1; auto.
  apply Wf_ty_cont.
  apply Wf_typ.
Qed.

Definition e_fix f := App Y (Lam f).

Lemma fix_ty : forall A B G f,
  Typ (ty_lam A B :: G) f (ty_lam A B) ->
  Typ G (e_fix f) (ty_lam A B).
Proof.
  intros.
  unfold e_fix.
  apply T_App with (ty_lam (ty_lam A B) (ty_lam A B)).
  apply T_weaken_nil.
  apply Y_typ.
  apply T_Abs.
  auto.
Qed.

Definition refY :=
  Lam (e_let (New (Lam diverge))
             (Update (Var 0) (Lam (App (App (Var 2) (Deref (Var 1))) (Var 0))) (Deref (Var 0)) )).

Lemma refY_typ : forall A B,
  Typ nil refY (ty_lam (ty_lam (ty_lam A B) (ty_lam A B)) (ty_lam A B)).
Proof.
  intros.
  unfold refY.
  apply T_Abs.
  unfold e_let.
  apply T_App with (ty_ref (ty_lam A B)).
  2: apply T_New.
  2: apply T_Abs.
  2: apply T_weaken_nil.
  2: apply diverge_typ.
  apply T_Abs.
  eapply T_Update.
  apply T_Var; simpl; auto.
  apply T_Abs.
  apply T_App with A.
  apply T_App with (ty_lam A B).
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
Qed.

Definition r_fix f := App refY (Lam f).

Lemma rfix_ty : forall A B G f,
  Typ (ty_lam A B :: G) f (ty_lam A B) ->
  Typ G (r_fix f) (ty_lam A B).
Proof.
  intros.
  unfold r_fix.
  apply T_App with (ty_lam (ty_lam A B) (ty_lam A B)).
  apply T_weaken_nil.
  apply refY_typ.
  apply T_Abs.
  assumption.
Qed.

Definition e_fac : expr :=
  r_fix (Lam
          (e_if (isZ (Var 0))

            (Nat 1)

            (App (App (bin_primop mult) (Var 1))
                 (App (Var 2) (App (unary_primop Peano.pred) (Var 1)))))).

Lemma e_fac_typ :
  Typ nil e_fac (ty_lam ty_nat ty_nat).
Proof.
  unfold e_fac.
  apply rfix_ty.
  apply T_Abs.
  apply T_if.
  apply T_isZ.
  apply T_Var; auto.
  apply T_Nat.
  apply T_App with ty_nat.
  apply T_App with ty_nat.
  apply T_weaken_nil.
  apply binary_primop_typ.
  apply T_Var; auto.
  apply T_App with ty_nat.
  apply T_Var; auto.
  apply T_App with ty_nat.
  apply T_weaken_nil.
  apply unary_primop_typ.
  apply T_Var; auto.
Qed.

Eval vm_compute in (snd (eval 100 empty_mem (App e_fac (Nat 6)))).

Fixpoint isULTerm (e:expr) : Prop :=
  match e with
  | Lam e' => isULTerm e'
  | App e1 e2 => isULTerm e1 /\ isULTerm e2
  | Var _ => True
  | _ => False
  end.

Lemma U_contractive : contractive (fun X => ty_lam X X).
Proof.
  apply ty_lam_contractive; hnf; repeat intro; auto.
Qed.

Definition U := Rec (fun X => ty_lam X X).
Lemma U_eqn : U = ty_lam U U.
Proof.
  unfold U at 1.
  rewrite Rec_fold_unfold; fold U; auto.
  apply U_contractive.
Qed.

Fixpoint Ulist (n:nat) :=
  match n with
  | 0 => nil
  | S n' => U :: Ulist n'
  end.

Lemma ULTyped' : forall e n,
  isULTerm e ->
  closed' n e ->
  Typ (Ulist n) e U.
Proof.
  induction e; simpl; intuition.

  apply T_Var.
  revert n0 H0; induction n; simpl; intros.
  inv H0; simpl; auto.
  destruct n0.
  omegac.
  simpl; apply IHn; omega.

  rewrite U_eqn.
  apply T_Abs.
  apply (IHe (S n)); auto.
  replace (S n) with (n+1) by omega; auto.

  apply T_App with U.
  rewrite <- U_eqn.
  apply IHe1; auto.
  apply IHe2; auto.
Qed.

Theorem ULTyped : forall e,
  closed e /\ isULTerm e ->
  Typ nil e U.
Proof.
  intuition; apply (ULTyped' e 0); auto.
Qed.
