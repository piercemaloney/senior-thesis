

Require Import FSets.

Require FSetAVL.

Require Import Orders.

Require Mergesort.

Require Import Coqlib.

Require Import Errors.

Require Import Maps.

Require Import Ordered.

Require Import AST.

Require Import Integers.

Require Import Floats.

Require Import Csharpminor.
(* Csharpminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Cminor.
Require Import Smallstep.

Inductive constant : Type :=
  | Ointconst: int -> constant          
  | Ofloatconst: float -> constant      
  | Olongconst: int64 -> constant.      

Definition unary_operation : Type := Cminor.unary_operation.
Definition binary_operation : Type := Cminor.binary_operation.

Inductive expr : Type :=
  | Evar : ident -> expr                
  | Eaddrof : ident -> expr             
  | Econst : constant -> expr           
  | Eunop : unary_operation -> expr -> expr  
  | Ebinop : binary_operation -> expr -> expr -> expr 
  | Eload : memory_chunk -> expr -> expr. 

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sset : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> lbl_stmt -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt

with lbl_stmt : Type :=
  | LSdefault: stmt -> lbl_stmt
  | LScase: int -> stmt -> lbl_stmt -> lbl_stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list (ident * Z);
  fn_temps: list ident;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.

Definition program : Type := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t (block * Z).
Definition temp_env := PTree.t val.

Definition empty_env : env := PTree.empty (block * Z).
Definition empty_temp_env : temp_env := PTree.empty val.

Fixpoint create_undef_temps (temps: list ident) : temp_env :=
  match temps with
  | nil => PTree.empty val
  | id :: temps' => PTree.set id Vundef (create_undef_temps temps')
 end.

Fixpoint bind_parameters (formals: list ident) (args: list val)
                         (le: temp_env) : option temp_env :=
 match formals, args with
 | nil, nil => Some le
 | id :: xl, v :: vl => bind_parameters xl vl (PTree.set id v le)
 | _, _ => None
 end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> env -> temp_env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (e: env)                   
             (le: temp_env)             
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint select_switch (n: int) (sl: lbl_stmt) {struct sl} : lbl_stmt :=
  match sl with
  | LSdefault _ => sl
  | LScase c s sl' => if Int.eq c n then sl else select_switch n sl'
  end.

Fixpoint seq_of_lbl_stmt (sl: lbl_stmt) : stmt :=
  match sl with
  | LSdefault s => s
  | LScase c s sl' => Sseq s (seq_of_lbl_stmt sl')
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Sswitch a sl =>
      find_label_ls lbl sl k
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: lbl_stmt) (k: cont)
                   {struct sl}: option (stmt * cont) :=
  match sl with
  | LSdefault s => find_label lbl s k
  | LScase _ s sl' =>
      match find_label lbl s (Kseq (seq_of_lbl_stmt sl') k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Definition eval_constant (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  end.

Definition eval_unop := Cminor.eval_unop.

Definition eval_binop := Cminor.eval_binop.

Inductive alloc_variables: env -> mem ->
                           list (ident * Z) ->
                           env -> mem -> Prop :=
  | alloc_variables_nil:
      forall e m,
      alloc_variables e m nil e m
  | alloc_variables_cons:
      forall e m id sz vars m1 b1 m2 e2,
      Mem.alloc m 0 sz = (m1, b1) ->
      alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2 ->
      alloc_variables e m ((id, sz) :: vars) e2 m2.

Definition block_of_binding (id_b_sz: ident * (block * Z)) :=
  match id_b_sz with (id, (b, sz)) => (b, 0, sz) end.

Definition blocks_of_env (e: env) : list (block * Z * Z) :=
  List.map block_of_binding (PTree.elements e).

Section RELSEM.

Variable ge: genv.

Inductive eval_var_addr: env -> ident -> block -> Prop :=
  | eval_var_addr_local:
      forall e id b sz,
      PTree.get id e = Some (b, sz) ->
      eval_var_addr e id b
  | eval_var_addr_global:
      forall e id b,
      PTree.get id e = None ->
      Genv.find_symbol ge id = Some b ->
      eval_var_addr e id b.

Section EVAL_EXPR.

Variable e: env.
Variable le: temp_env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      le!id = Some v ->
      eval_expr (Evar id) v
  | eval_Eaddrof: forall id b,
      eval_var_addr e id b ->
      eval_expr (Eaddrof id) (Vptr b Int.zero)
  | eval_Econst: forall cst v,
      eval_constant cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk a v1 v,
      eval_expr a v1 ->
      Mem.loadv chunk m v1 = Some v ->
      eval_expr (Eload chunk a) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k e le m,
      step (State f Sskip (Kseq s k) e le m)
        E0 (State f s k e le m)
  | step_skip_block: forall f k e le m,
      step (State f Sskip (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f Sskip k e le m)
        E0 (Returnstate Vundef k m')

  | step_set: forall f id a k e le m v,
      eval_expr e le m a v ->
      step (State f (Sset id a) k e le m)
        E0 (State f Sskip k e (PTree.set id v le) m)

  | step_store: forall f chunk addr a k e le m vaddr v m',
      eval_expr e le m addr vaddr ->
      eval_expr e le m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k e le m)
        E0 (State f Sskip k e le m')

  | step_call: forall f optid sig a bl k e le m vf vargs fd,
      eval_expr e le m a vf ->
      eval_exprlist e le m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k e le m)
        E0 (Callstate fd vargs (Kcall optid f e le k) m)

  | step_builtin: forall f optid ef bl k e le m vargs t vres m',
      eval_exprlist e le m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k e le m)
         t (State f Sskip k e (Cminor.set_optvar optid vres le) m')

  | step_seq: forall f s1 s2 k e le m,
      step (State f (Sseq s1 s2) k e le m)
        E0 (State f s1 (Kseq s2 k) e le m)

  | step_ifthenelse: forall f a s1 s2 k e le m v b,
      eval_expr e le m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k e le m)
        E0 (State f (if b then s1 else s2) k e le m)

  | step_loop: forall f s k e le m,
      step (State f (Sloop s) k e le m)
        E0 (State f s (Kseq (Sloop s) k) e le m)

  | step_block: forall f s k e le m,
      step (State f (Sblock s) k e le m)
        E0 (State f s (Kblock k) e le m)

  | step_exit_seq: forall f n s k e le m,
      step (State f (Sexit n) (Kseq s k) e le m)
        E0 (State f (Sexit n) k e le m)
  | step_exit_block_0: forall f k e le m,
      step (State f (Sexit O) (Kblock k) e le m)
        E0 (State f Sskip k e le m)
  | step_exit_block_S: forall f n k e le m,
      step (State f (Sexit (S n)) (Kblock k) e le m)
        E0 (State f (Sexit n) k e le m)

  | step_switch: forall f a cases k e le m n,
      eval_expr e le m a (Vint n) ->
      step (State f (Sswitch a cases) k e le m)
        E0 (State f (seq_of_lbl_stmt (select_switch n cases)) k e le m)

  | step_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn None) k e le m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k e le m v m',
      eval_expr e le m a v ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn (Some a)) k e le m)
        E0 (Returnstate v (call_cont k) m')
  | step_label: forall f lbl s k e le m,
      step (State f (Slabel lbl s) k e le m)
        E0 (State f s k e le m)

  | step_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k e le m)
        E0 (State f s' k' e le m)

  | step_internal_function: forall f vargs k m m1 e le,
      list_norepet (map fst f.(fn_vars)) ->
      list_norepet f.(fn_params) ->
      list_disjoint f.(fn_params) f.(fn_temps) ->
      alloc_variables empty_env m (fn_vars f) e m1 ->
      bind_parameters f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k e le m1)

  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f e le k m,
      step (Returnstate v (Kcall optid f e le k) m)
        E0 (State f Sskip k e (Cminor.set_optvar optid v le) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p). *)

Require Import Cminor.
(* Cminor:
Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Events.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Switch.

Inductive constant : Type :=
  | Ointconst: int -> constant     
  | Ofloatconst: float -> constant 
  | Olongconst: int64 -> constant  
  | Oaddrsymbol: ident -> int -> constant 
  | Oaddrstack: int -> constant.   

Inductive unary_operation : Type :=
  | Ocast8unsigned: unary_operation        
  | Ocast8signed: unary_operation          
  | Ocast16unsigned: unary_operation       
  | Ocast16signed: unary_operation         
  | Onegint: unary_operation               
  | Onotint: unary_operation               
  | Onegf: unary_operation                 
  | Oabsf: unary_operation                 
  | Osingleoffloat: unary_operation        
  | Ointoffloat: unary_operation           
  | Ointuoffloat: unary_operation          
  | Ofloatofint: unary_operation           
  | Ofloatofintu: unary_operation          
  | Onegl: unary_operation                 
  | Onotl: unary_operation                 
  | Ointoflong: unary_operation            
  | Olongofint: unary_operation            
  | Olongofintu: unary_operation           
  | Olongoffloat: unary_operation          
  | Olonguoffloat: unary_operation         
  | Ofloatoflong: unary_operation          
  | Ofloatoflongu: unary_operation         
  | Osingleoflong: unary_operation         
  | Osingleoflongu: unary_operation.       

Inductive binary_operation : Type :=
  | Oadd: binary_operation                 
  | Osub: binary_operation                 
  | Omul: binary_operation                 
  | Odiv: binary_operation                 
  | Odivu: binary_operation                
  | Omod: binary_operation                 
  | Omodu: binary_operation                
  | Oand: binary_operation                 
  | Oor: binary_operation                  
  | Oxor: binary_operation                 
  | Oshl: binary_operation                 
  | Oshr: binary_operation                 
  | Oshru: binary_operation                
  | Oaddf: binary_operation                
  | Osubf: binary_operation                
  | Omulf: binary_operation                
  | Odivf: binary_operation                
  | Oaddl: binary_operation                
  | Osubl: binary_operation                
  | Omull: binary_operation                
  | Odivl: binary_operation                
  | Odivlu: binary_operation               
  | Omodl: binary_operation                
  | Omodlu: binary_operation               
  | Oandl: binary_operation                
  | Oorl: binary_operation                 
  | Oxorl: binary_operation                
  | Oshll: binary_operation                
  | Oshrl: binary_operation                
  | Oshrlu: binary_operation               
  | Ocmp: comparison -> binary_operation   
  | Ocmpu: comparison -> binary_operation  
  | Ocmpf: comparison -> binary_operation  
  | Ocmpl: comparison -> binary_operation  
  | Ocmplu: comparison -> binary_operation. 

Inductive expr : Type :=
  | Evar : ident -> expr
  | Econst : constant -> expr
  | Eunop : unary_operation -> expr -> expr
  | Ebinop : binary_operation -> expr -> expr -> expr
  | Eload : memory_chunk -> expr -> expr.

Definition label := ident.

Inductive stmt : Type :=
  | Sskip: stmt
  | Sassign : ident -> expr -> stmt
  | Sstore : memory_chunk -> expr -> expr -> stmt
  | Scall : option ident -> signature -> expr -> list expr -> stmt
  | Stailcall: signature -> expr -> list expr -> stmt
  | Sbuiltin : option ident -> external_function -> list expr -> stmt
  | Sseq: stmt -> stmt -> stmt
  | Sifthenelse: expr -> stmt -> stmt -> stmt
  | Sloop: stmt -> stmt
  | Sblock: stmt -> stmt
  | Sexit: nat -> stmt
  | Sswitch: expr -> list (int * nat) -> nat -> stmt
  | Sreturn: option expr -> stmt
  | Slabel: label -> stmt -> stmt
  | Sgoto: label -> stmt.

Record function : Type := mkfunction {
  fn_sig: signature;
  fn_params: list ident;
  fn_vars: list ident;
  fn_stackspace: Z;
  fn_body: stmt
}.

Definition fundef := AST.fundef function.
Definition program := AST.program fundef unit.

Definition funsig (fd: fundef) :=
  match fd with
  | Internal f => fn_sig f
  | External ef => ef_sig ef
  end.

Definition genv := Genv.t fundef unit.
Definition env := PTree.t val.

Fixpoint set_params (vl: list val) (il: list ident) {struct il} : env :=
  match il, vl with
  | i1 :: is, v1 :: vs => PTree.set i1 v1 (set_params vs is)
  | i1 :: is, nil => PTree.set i1 Vundef (set_params nil is)
  | _, _ => PTree.empty val
  end.

Fixpoint set_locals (il: list ident) (e: env) {struct il} : env :=
  match il with
  | nil => e
  | i1 :: is => PTree.set i1 Vundef (set_locals is e)
  end.

Definition set_optvar (optid: option ident) (v: val) (e: env) : env :=
  match optid with
  | None => e
  | Some id => PTree.set id v e
  end.

Inductive cont: Type :=
  | Kstop: cont                         
  | Kseq: stmt -> cont -> cont          
  | Kblock: cont -> cont                
  | Kcall: option ident -> function -> val -> env -> cont -> cont.
                                        
Inductive state: Type :=
  | State:                      
      forall (f: function)              
             (s: stmt)                  
             (k: cont)                  
             (sp: val)                  
             (e: env)                   
             (m: mem),                  
      state
  | Callstate:                  
      forall (f: fundef)                
             (args: list val)           
             (k: cont)                  
             (m: mem),                  
      state
  | Returnstate:                
      forall (v: val)                   
             (k: cont)                  
             (m: mem),                  
      state.

Section RELSEM.

Variable ge: genv.

Definition eval_constant (sp: val) (cst: constant) : option val :=
  match cst with
  | Ointconst n => Some (Vint n)
  | Ofloatconst n => Some (Vfloat n)
  | Olongconst n => Some (Vlong n)
  | Oaddrsymbol s ofs =>
      Some(match Genv.find_symbol ge s with
           | None => Vundef
           | Some b => Vptr b ofs end)
  | Oaddrstack ofs => Some (Val.add sp (Vint ofs))
  end.

Definition eval_unop (op: unary_operation) (arg: val) : option val :=
  match op with
  | Ocast8unsigned => Some (Val.zero_ext 8 arg)
  | Ocast8signed => Some (Val.sign_ext 8 arg)
  | Ocast16unsigned => Some (Val.zero_ext 16 arg)
  | Ocast16signed => Some (Val.sign_ext 16 arg)
  | Onegint => Some (Val.negint arg)
  | Onotint => Some (Val.notint arg)
  | Onegf => Some (Val.negf arg)
  | Oabsf => Some (Val.absf arg)
  | Osingleoffloat => Some (Val.singleoffloat arg)
  | Ointoffloat => Val.intoffloat arg
  | Ointuoffloat => Val.intuoffloat arg
  | Ofloatofint => Val.floatofint arg
  | Ofloatofintu => Val.floatofintu arg
  | Onegl => Some (Val.negl arg)
  | Onotl => Some (Val.notl arg)
  | Ointoflong => Some (Val.loword arg)
  | Olongofint => Some (Val.longofint arg)
  | Olongofintu => Some (Val.longofintu arg)
  | Olongoffloat => Val.longoffloat arg
  | Olonguoffloat => Val.longuoffloat arg
  | Ofloatoflong => Val.floatoflong arg
  | Ofloatoflongu => Val.floatoflongu arg
  | Osingleoflong => Val.singleoflong arg
  | Osingleoflongu => Val.singleoflongu arg
  end.

Definition eval_binop
            (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
  match op with
  | Oadd => Some (Val.add arg1 arg2)
  | Osub => Some (Val.sub arg1 arg2)
  | Omul => Some (Val.mul arg1 arg2)
  | Odiv => Val.divs arg1 arg2
  | Odivu => Val.divu arg1 arg2
  | Omod => Val.mods arg1 arg2
  | Omodu => Val.modu arg1 arg2
  | Oand => Some (Val.and arg1 arg2)
  | Oor => Some (Val.or arg1 arg2)
  | Oxor => Some (Val.xor arg1 arg2)
  | Oshl => Some (Val.shl arg1 arg2)
  | Oshr => Some (Val.shr arg1 arg2)
  | Oshru => Some (Val.shru arg1 arg2)
  | Oaddf => Some (Val.addf arg1 arg2)
  | Osubf => Some (Val.subf arg1 arg2)
  | Omulf => Some (Val.mulf arg1 arg2)
  | Odivf => Some (Val.divf arg1 arg2)
  | Oaddl => Some (Val.addl arg1 arg2)
  | Osubl => Some (Val.subl arg1 arg2)
  | Omull => Some (Val.mull arg1 arg2)
  | Odivl => Val.divls arg1 arg2
  | Odivlu => Val.divlu arg1 arg2
  | Omodl => Val.modls arg1 arg2
  | Omodlu => Val.modlu arg1 arg2
  | Oandl => Some (Val.andl arg1 arg2)
  | Oorl => Some (Val.orl arg1 arg2)
  | Oxorl => Some (Val.xorl arg1 arg2)
  | Oshll => Some (Val.shll arg1 arg2)
  | Oshrl => Some (Val.shrl arg1 arg2)
  | Oshrlu => Some (Val.shrlu arg1 arg2)
  | Ocmp c => Some (Val.cmp c arg1 arg2)
  | Ocmpu c => Some (Val.cmpu (Mem.valid_pointer m) c arg1 arg2)
  | Ocmpf c => Some (Val.cmpf c arg1 arg2)
  | Ocmpl c => Val.cmpl c arg1 arg2
  | Ocmplu c => Val.cmplu c arg1 arg2
  end.

Section EVAL_EXPR.

Variable sp: val.
Variable e: env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Evar: forall id v,
      PTree.get id e = Some v ->
      eval_expr (Evar id) v
  | eval_Econst: forall cst v,
      eval_constant sp cst = Some v ->
      eval_expr (Econst cst) v
  | eval_Eunop: forall op a1 v1 v,
      eval_expr a1 v1 ->
      eval_unop op v1 = Some v ->
      eval_expr (Eunop op a1) v
  | eval_Ebinop: forall op a1 a2 v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      eval_binop op v1 v2 m = Some v ->
      eval_expr (Ebinop op a1 a2) v
  | eval_Eload: forall chunk addr vaddr v,
      eval_expr addr vaddr ->
      Mem.loadv chunk m vaddr = Some v ->
      eval_expr (Eload chunk addr) v.

Inductive eval_exprlist: list expr -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil nil
  | eval_Econs: forall a1 al v1 vl,
      eval_expr a1 v1 -> eval_exprlist al vl ->
      eval_exprlist (a1 :: al) (v1 :: vl).

End EVAL_EXPR.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kblock k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Fixpoint find_label (lbl: label) (s: stmt) (k: cont)
                    {struct s}: option (stmt * cont) :=
  match s with
  | Sseq s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 =>
      find_label lbl s1 (Kseq (Sloop s1) k)
  | Sblock s1 =>
      find_label lbl s1 (Kblock k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end.

Inductive step: state -> trace -> state -> Prop :=

  | step_skip_seq: forall f s k sp e m,
      step (State f Sskip (Kseq s k) sp e m)
        E0 (State f s k sp e m)
  | step_skip_block: forall f k sp e m,
      step (State f Sskip (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_skip_call: forall f k sp e m m',
      is_call_cont k ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f Sskip k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef k m')

  | step_assign: forall f id a k sp e m v,
      eval_expr sp e m a v ->
      step (State f (Sassign id a) k sp e m)
        E0 (State f Sskip k sp (PTree.set id v e) m)

  | step_store: forall f chunk addr a k sp e m vaddr v m',
      eval_expr sp e m addr vaddr ->
      eval_expr sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      step (State f (Sstore chunk addr a) k sp e m)
        E0 (State f Sskip k sp e m')

  | step_call: forall f optid sig a bl k sp e m vf vargs fd,
      eval_expr sp e m a vf ->
      eval_exprlist sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      step (State f (Scall optid sig a bl) k sp e m)
        E0 (Callstate fd vargs (Kcall optid f sp e k) m)

  | step_tailcall: forall f sig a bl k sp e m vf vargs fd m',
      eval_expr (Vptr sp Int.zero) e m a vf ->
      eval_exprlist (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Stailcall sig a bl) k (Vptr sp Int.zero) e m)
        E0 (Callstate fd vargs (call_cont k) m')

  | step_builtin: forall f optid ef bl k sp e m vargs t vres m',
      eval_exprlist sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef bl) k sp e m)
         t (State f Sskip k sp (set_optvar optid vres e) m')

  | step_seq: forall f s1 s2 k sp e m,
      step (State f (Sseq s1 s2) k sp e m)
        E0 (State f s1 (Kseq s2 k) sp e m)

  | step_ifthenelse: forall f a s1 s2 k sp e m v b,
      eval_expr sp e m a v ->
      Val.bool_of_val v b ->
      step (State f (Sifthenelse a s1 s2) k sp e m)
        E0 (State f (if b then s1 else s2) k sp e m)

  | step_loop: forall f s k sp e m,
      step (State f (Sloop s) k sp e m)
        E0 (State f s (Kseq (Sloop s) k) sp e m)

  | step_block: forall f s k sp e m,
      step (State f (Sblock s) k sp e m)
        E0 (State f s (Kblock k) sp e m)

  | step_exit_seq: forall f n s k sp e m,
      step (State f (Sexit n) (Kseq s k) sp e m)
        E0 (State f (Sexit n) k sp e m)
  | step_exit_block_0: forall f k sp e m,
      step (State f (Sexit O) (Kblock k) sp e m)
        E0 (State f Sskip k sp e m)
  | step_exit_block_S: forall f n k sp e m,
      step (State f (Sexit (S n)) (Kblock k) sp e m)
        E0 (State f (Sexit n) k sp e m)

  | step_switch: forall f a cases default k sp e m n,
      eval_expr sp e m a (Vint n) ->
      step (State f (Sswitch a cases default) k sp e m)
        E0 (State f (Sexit (switch_target n default cases)) k sp e m)

  | step_return_0: forall f k sp e m m',
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn None) k (Vptr sp Int.zero) e m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k sp e m v m',
      eval_expr (Vptr sp Int.zero) e m a v ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      step (State f (Sreturn (Some a)) k (Vptr sp Int.zero) e m)
        E0 (Returnstate v (call_cont k) m')

  | step_label: forall f lbl s k sp e m,
      step (State f (Slabel lbl s) k sp e m)
        E0 (State f s k sp e m)

  | step_goto: forall f lbl k sp e m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some(s', k') ->
      step (State f (Sgoto lbl) k sp e m)
        E0 (State f s' k' sp e m)

  | step_internal_function: forall f vargs k m m' sp e,
      Mem.alloc m 0 f.(fn_stackspace) = (m', sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k (Vptr sp Int.zero) e m')
  | step_external_function: forall ef vargs k m t vres m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef) vargs k m)
         t (Returnstate vres k m')

  | step_return: forall v optid f sp e k m,
      step (Returnstate v (Kcall optid f sp e k) m)
        E0 (State f Sskip k sp (set_optvar optid v e) m).

End RELSEM.

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

Definition semantics (p: program) :=
  Semantics step (initial_state p) final_state (Genv.globalenv p).

Lemma semantics_receptive:
  forall (p: program), receptive (semantics p).

Inductive outcome: Type :=
  | Out_normal: outcome                
  | Out_exit: nat -> outcome           
  | Out_return: option val -> outcome  
  | Out_tailcall_return: val -> outcome. 

Definition outcome_block (out: outcome) : outcome :=
  match out with
  | Out_exit O => Out_normal
  | Out_exit (S n) => Out_exit n
  | out => out
  end.

Definition outcome_result_value
    (out: outcome) (retsig: option typ) (vres: val) : Prop :=
  match out with
  | Out_normal => vres = Vundef
  | Out_return None => vres = Vundef
  | Out_return (Some v) => retsig <> None /\ vres = v
  | Out_tailcall_return v => vres = v
  | _ => False
  end.

Definition outcome_free_mem
    (out: outcome) (m: mem) (sp: block) (sz: Z) (m': mem) :=
  match out with
  | Out_tailcall_return _ => m' = m
  | _ => Mem.free m sp 0 sz = Some m'
  end.

Section NATURALSEM.

Variable ge: genv.

Inductive eval_funcall:
        mem -> fundef -> list val -> trace ->
        mem -> val -> Prop :=
  | eval_funcall_internal:
      forall m f vargs m1 sp e t e2 m2 out vres m3,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      exec_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t e2 m2 out ->
      outcome_result_value out f.(fn_sig).(sig_res) vres ->
      outcome_free_mem out m2 sp f.(fn_stackspace) m3 ->
      eval_funcall m (Internal f) vargs t m3 vres
  | eval_funcall_external:
      forall ef m args t res m',
      external_call ef ge args m t res m' ->
      eval_funcall m (External ef) args t m' res

with exec_stmt:
         function -> val ->
         env -> mem -> stmt -> trace ->
         env -> mem -> outcome -> Prop :=
  | exec_Sskip:
      forall f sp e m,
      exec_stmt f sp e m Sskip E0 e m Out_normal
  | exec_Sassign:
      forall f sp e m id a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sassign id a) E0 (PTree.set id v e) m Out_normal
  | exec_Sstore:
      forall f sp e m chunk addr a vaddr v m',
      eval_expr ge sp e m addr vaddr ->
      eval_expr ge sp e m a v ->
      Mem.storev chunk m vaddr v = Some m' ->
      exec_stmt f sp e m (Sstore chunk addr a) E0 e m' Out_normal
  | exec_Scall:
      forall f sp e m optid sig a bl vf vargs fd t m' vres e',
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      eval_funcall m fd vargs t m' vres ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Scall optid sig a bl) t e' m' Out_normal
  | exec_Sbuiltin:
      forall f sp e m optid ef bl t m' vargs vres e',
      eval_exprlist ge sp e m bl vargs ->
      external_call ef ge vargs m t vres m' ->
      e' = set_optvar optid vres e ->
      exec_stmt f sp e m (Sbuiltin optid ef bl) t e' m' Out_normal
  | exec_Sifthenelse:
      forall f sp e m a s1 s2 v b t e' m' out,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      exec_stmt f sp e m (if b then s1 else s2) t e' m' out ->
      exec_stmt f sp e m (Sifthenelse a s1 s2) t e' m' out
  | exec_Sseq_continue:
      forall f sp e m t s1 t1 e1 m1 s2 t2 e2 m2 out,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 s2 t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sseq s1 s2) t e2 m2 out
  | exec_Sseq_stop:
      forall f sp e m t s1 s2 e1 m1 out,
      exec_stmt f sp e m s1 t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sseq s1 s2) t e1 m1 out
  | exec_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2 e2 m2 out,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      exec_stmt f sp e1 m1 (Sloop s) t2 e2 m2 out ->
      t = t1 ** t2 ->
      exec_stmt f sp e m (Sloop s) t e2 m2 out
  | exec_Sloop_stop:
      forall f sp e m t s e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      out <> Out_normal ->
      exec_stmt f sp e m (Sloop s) t e1 m1 out
  | exec_Sblock:
      forall f sp e m s t e1 m1 out,
      exec_stmt f sp e m s t e1 m1 out ->
      exec_stmt f sp e m (Sblock s) t e1 m1 (outcome_block out)
  | exec_Sexit:
      forall f sp e m n,
      exec_stmt f sp e m (Sexit n) E0 e m (Out_exit n)
  | exec_Sswitch:
      forall f sp e m a cases default n,
      eval_expr ge sp e m a (Vint n) ->
      exec_stmt f sp e m (Sswitch a cases default)
                E0 e m (Out_exit (switch_target n default cases))
  | exec_Sreturn_none:
      forall f sp e m,
      exec_stmt f sp e m (Sreturn None) E0 e m (Out_return None)
  | exec_Sreturn_some:
      forall f sp e m a v,
      eval_expr ge sp e m a v ->
      exec_stmt f sp e m (Sreturn (Some a)) E0 e m (Out_return (Some v))
  | exec_Stailcall:
      forall f sp e m sig a bl vf vargs fd t m' m'' vres,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      eval_funcall m' fd vargs t m'' vres ->
      exec_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t e m'' (Out_tailcall_return vres).

Scheme eval_funcall_ind2 := Minimality for eval_funcall Sort Prop
  with exec_stmt_ind2 := Minimality for exec_stmt Sort Prop.
Combined Scheme eval_funcall_exec_stmt_ind2
  from eval_funcall_ind2, exec_stmt_ind2.

CoInductive evalinf_funcall:
        mem -> fundef -> list val -> traceinf -> Prop :=
  | evalinf_funcall_internal:
      forall m f vargs m1 sp e t,
      Mem.alloc m 0 f.(fn_stackspace) = (m1, sp) ->
      set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e ->
      execinf_stmt f (Vptr sp Int.zero) e m1 f.(fn_body) t ->
      evalinf_funcall m (Internal f) vargs t

with execinf_stmt:
         function -> val -> env -> mem -> stmt -> traceinf -> Prop :=
  | execinf_Scall:
      forall f sp e m optid sig a bl vf vargs fd t,
      eval_expr ge sp e m a vf ->
      eval_exprlist ge sp e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      evalinf_funcall m fd vargs t ->
      execinf_stmt f sp e m (Scall optid sig a bl) t
  | execinf_Sifthenelse:
      forall f sp e m a s1 s2 v b t,
      eval_expr ge sp e m a v ->
      Val.bool_of_val v b ->
      execinf_stmt f sp e m (if b then s1 else s2) t ->
      execinf_stmt f sp e m (Sifthenelse a s1 s2) t
  | execinf_Sseq_1:
      forall f sp e m t s1 s2,
      execinf_stmt f sp e m s1 t ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sseq_2:
      forall f sp e m t s1 t1 e1 m1 s2 t2,
      exec_stmt f sp e m s1 t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 s2 t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sseq s1 s2) t
  | execinf_Sloop_body:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sloop_loop:
      forall f sp e m s t t1 e1 m1 t2,
      exec_stmt f sp e m s t1 e1 m1 Out_normal ->
      execinf_stmt f sp e1 m1 (Sloop s) t2 ->
      t = t1 *** t2 ->
      execinf_stmt f sp e m (Sloop s) t
  | execinf_Sblock:
      forall f sp e m s t,
      execinf_stmt f sp e m s t ->
      execinf_stmt f sp e m (Sblock s) t
  | execinf_Stailcall:
      forall f sp e m sig a bl vf vargs fd m' t,
      eval_expr ge (Vptr sp Int.zero) e m a vf ->
      eval_exprlist ge (Vptr sp Int.zero) e m bl vargs ->
      Genv.find_funct ge vf = Some fd ->
      funsig fd = sig ->
      Mem.free m sp 0 f.(fn_stackspace) = Some m' ->
      evalinf_funcall m' fd vargs t ->
      execinf_stmt f (Vptr sp Int.zero) e m (Stailcall sig a bl) t.

End NATURALSEM.

Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
  | bigstep_program_terminates_intro:
      forall b f m0 t m r,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      eval_funcall ge m0 f nil t m (Vint r) ->
      bigstep_program_terminates p t r.

Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
  | bigstep_program_diverges_intro:
      forall b f m0 t,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      funsig f = mksignature nil (Some Tint) ->
      evalinf_funcall ge m0 f nil t ->
      bigstep_program_diverges p t.

Definition bigstep_semantics (p: program) :=
  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).

Section BIGSTEP_TO_TRANSITION.

Variable prog: program.
Let ge := Genv.globalenv prog.

Inductive outcome_state_match
        (sp: val) (e: env) (m: mem) (f: function) (k: cont):
        outcome -> state -> Prop :=
  | osm_normal:
      outcome_state_match sp e m f k
                          Out_normal
                          (State f Sskip k sp e m)
  | osm_exit: forall n,
      outcome_state_match sp e m f k
                          (Out_exit n)
                          (State f (Sexit n) k sp e m)
  | osm_return_none: forall k',
      call_cont k' = call_cont k ->
      outcome_state_match sp e m f k
                          (Out_return None)
                          (State f (Sreturn None) k' sp e m)
  | osm_return_some: forall k' a v,
      call_cont k' = call_cont k ->
      eval_expr ge sp e m a v ->
      outcome_state_match sp e m f k
                          (Out_return (Some v))
                          (State f (Sreturn (Some a)) k' sp e m)
  | osm_tail: forall v,
      outcome_state_match sp e m f k
                          (Out_tailcall_return v)
                          (Returnstate v (call_cont k) m).

Remark is_call_cont_call_cont:
  forall k, is_call_cont (call_cont k).

Remark call_cont_is_call_cont:
  forall k, is_call_cont k -> call_cont k = k.

Lemma eval_funcall_exec_stmt_steps:
  (forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m'))
/\(forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S).

Lemma eval_funcall_steps:
   forall m fd args t m' res,
   eval_funcall ge m fd args t m' res ->
   forall k,
   is_call_cont k ->
   star step ge (Callstate fd args k m)
              t (Returnstate res k m').
Proof (proj1 eval_funcall_exec_stmt_steps).

Lemma exec_stmt_steps:
   forall f sp e m s t e' m' out,
   exec_stmt ge f sp e m s t e' m' out ->
   forall k,
   exists S,
   star step ge (State f s k sp e m) t S
   /\ outcome_state_match sp e' m' f k out S.
Proof (proj2 eval_funcall_exec_stmt_steps).

Lemma evalinf_funcall_forever:
  forall m fd args T k,
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.

Theorem bigstep_semantics_sound:
  bigstep_sound (bigstep_semantics prog) (semantics prog).

End BIGSTEP_TO_TRANSITION. *)



Local Open Scope string_scope.

Local Open Scope error_monad_scope.



Definition compilenv := PTree.t Z.



Function uncast_int (m: int) (e: expr) {struct e} : expr :=

  match e with

  | Eunop (Ocast8unsigned|Ocast8signed) e1 =>

      if Int.eq (Int.and (Int.repr 255) m) m then uncast_int m e1 else e

  | Eunop (Ocast16unsigned|Ocast16signed) e1 =>

      if Int.eq (Int.and (Int.repr 65535) m) m then uncast_int m e1 else e

  | Ebinop Oand e1 (Econst (Ointconst n)) =>

      if Int.eq (Int.and n m) m then uncast_int m e1 else e

  | Ebinop Oshru e1 (Econst (Ointconst n)) =>

      if Int.eq (Int.shru (Int.shl m n) n) m

      then Ebinop Oshru (uncast_int (Int.shl m n) e1) (Econst (Ointconst n))

      else e

  | Ebinop Oshr e1 (Econst (Ointconst n)) =>

      if Int.eq (Int.shru (Int.shl m n) n) m

      then Ebinop Oshr (uncast_int (Int.shl m n) e1) (Econst (Ointconst n))

      else e

  | _ => e

  end.



Definition uncast_int8 (e: expr) : expr := uncast_int (Int.repr 255) e.



Definition uncast_int16 (e: expr) : expr := uncast_int (Int.repr 65535) e.



Function uncast_float32 (e: expr) : expr :=

  match e with

  | Eunop Osingleoffloat e1 => uncast_float32 e1

  | _ => e

  end.



Function store_arg (chunk: memory_chunk) (e: expr) : expr :=

  match chunk with

  | Mint8signed | Mint8unsigned => uncast_int8 e

  | Mint16signed | Mint16unsigned => uncast_int16 e

  | Mfloat32 => uncast_float32 e

  | _ => e

  end.



Definition make_store (chunk: memory_chunk) (e1 e2: expr): stmt :=

  Sstore chunk e1 (store_arg chunk e2).



Definition make_stackaddr (ofs: Z): expr :=

  Econst (Oaddrstack (Int.repr ofs)).



Definition make_globaladdr (id: ident): expr :=

  Econst (Oaddrsymbol id Int.zero).



Definition make_unop (op: unary_operation) (e: expr): expr :=

  match op with

  | Ocast8unsigned => Eunop Ocast8unsigned (uncast_int8 e)

  | Ocast8signed => Eunop Ocast8signed (uncast_int8 e)

  | Ocast16unsigned => Eunop Ocast16unsigned (uncast_int16 e)

  | Ocast16signed => Eunop Ocast16signed (uncast_int16 e)

  | Osingleoffloat => Eunop Osingleoffloat (uncast_float32 e)

  | _ => Eunop op e

  end.



Inductive approx : Type :=

  | Any                   

  | Int1                  

  | Int7                  

  | Int8s                 

  | Int8u                 

  | Int15                 

  | Int16s                

  | Int16u                

  | Float32.               



Module Approx.



Definition bge (x y: approx) : bool :=

  match x, y with

  | Any, _ => true

  | Int1, Int1 => true

  | Int7, (Int1 | Int7) => true

  | Int8s, (Int1 | Int7 | Int8s) => true

  | Int8u, (Int1 | Int7 | Int8u) => true

  | Int15, (Int1 | Int7 | Int8u | Int15) => true

  | Int16s, (Int1 | Int7 | Int8s | Int8u | Int15 | Int16s) => true

  | Int16u, (Int1 | Int7 | Int8u | Int15 | Int16u) => true

  | Float32, Float32 => true

  | _, _ => false

  end.



Definition of_int (n: int) :=

  if Int.eq_dec n Int.zero || Int.eq_dec n Int.one then Int1

  else if Int.eq_dec n (Int.zero_ext 7 n) then Int7

  else if Int.eq_dec n (Int.zero_ext 8 n) then Int8u

  else if Int.eq_dec n (Int.sign_ext 8 n) then Int8s

  else if Int.eq_dec n (Int.zero_ext 15 n) then Int15

  else if Int.eq_dec n (Int.zero_ext 16 n) then Int16u

  else if Int.eq_dec n (Int.sign_ext 16 n) then Int16s

  else Any.



Definition of_float (n: float) :=

  if Float.eq_dec n (Float.singleoffloat n) then Float32 else Any.



Definition of_chunk (chunk: memory_chunk) :=

  match chunk with

  | Mint8signed => Int8s

  | Mint8unsigned => Int8u

  | Mint16signed => Int16s

  | Mint16unsigned => Int16u

  | Mint32 => Any

  | Mint64 => Any

  | Mfloat32 => Float32

  | Mfloat64 => Any

  | Mfloat64al32 => Any

  end.



Definition unop (op: unary_operation) (a: approx) :=

  match op with

  | Ocast8unsigned => Int8u

  | Ocast8signed => Int8s

  | Ocast16unsigned => Int16u

  | Ocast16signed => Int16s

  | Osingleoffloat => Float32

  | _ => Any

  end.



Definition unop_is_redundant (op: unary_operation) (a: approx) :=

  match op with

  | Ocast8unsigned => bge Int8u a

  | Ocast8signed => bge Int8s a

  | Ocast16unsigned => bge Int16u a

  | Ocast16signed => bge Int16s a

  | Osingleoffloat => bge Float32 a

  | _ => false

  end.



Definition bitwise_and (a1 a2: approx) :=

  if bge Int1 a1 || bge Int1 a2 then Int1

  else if bge Int8u a1 || bge Int8u a2 then Int8u

  else if bge Int16u a1 || bge Int16u a2 then Int16u

  else Any.



Definition bitwise_or (a1 a2: approx) :=

  if bge Int1 a1 && bge Int1 a2 then Int1

  else if bge Int8u a1 && bge Int8u a2 then Int8u

  else if bge Int16u a1 && bge Int16u a2 then Int16u

  else Any.



Definition binop (op: binary_operation) (a1 a2: approx) :=

  match op with

  | Oand => bitwise_and a1 a2

  | Oor | Oxor => bitwise_or a1 a2

  | Ocmp _ => Int1

  | Ocmpu _ => Int1

  | Ocmpf _ => Int1

  | _ => Any

  end.



End Approx.



Definition var_addr (cenv: compilenv) (id: ident): expr :=

  match PTree.get id cenv with

  | Some ofs => make_stackaddr ofs

  | None     => make_globaladdr id

  end.



Definition transl_constant (cst: Csharpminor.constant): (constant * approx) :=

  match cst with

  | Csharpminor.Ointconst n =>

      (Ointconst n, Approx.of_int n)

  | Csharpminor.Ofloatconst n =>

      (Ofloatconst n, Approx.of_float n)

  | Csharpminor.Olongconst n =>

      (Olongconst n, Any)

  end.



Fixpoint transl_expr (cenv: compilenv) (e: Csharpminor.expr)

                     {struct e}: res (expr * approx) :=

  match e with

  | Csharpminor.Evar id =>

      OK (Evar id, Any)

  | Csharpminor.Eaddrof id =>

      OK (var_addr cenv id, Any)

  | Csharpminor.Econst cst =>

      let (tcst, a) := transl_constant cst in OK (Econst tcst, a)

  | Csharpminor.Eunop op e1 =>

      do (te1, a1)  <- transl_expr cenv e1;

      if Approx.unop_is_redundant op a1

      then OK (te1, a1)

      else OK (make_unop op te1, Approx.unop op a1)

  | Csharpminor.Ebinop op e1 e2 =>

      do (te1, a1) <- transl_expr cenv e1;

      do (te2, a2) <- transl_expr cenv e2;

      OK (Ebinop op te1 te2, Approx.binop op a1 a2)

  | Csharpminor.Eload chunk e =>

      do (te, a) <- transl_expr cenv e;

      OK (Eload chunk te, Approx.of_chunk chunk)

  end.



Fixpoint transl_exprlist (cenv: compilenv) (el: list Csharpminor.expr)

                     {struct el}: res (list expr) :=

  match el with

  | nil =>

      OK nil

  | e1 :: e2 =>

      do (te1, a1) <- transl_expr cenv e1;

      do te2 <- transl_exprlist cenv e2;

      OK (te1 :: te2)

  end.



Definition exit_env := list bool.



Fixpoint shift_exit (e: exit_env) (n: nat) {struct e} : nat :=

  match e, n with

  | nil, _ => n

  | false :: e', _ => S (shift_exit e' n)

  | true :: e', O => O

  | true :: e', S m => S (shift_exit e' m)

  end.



Fixpoint switch_table (ls: lbl_stmt) (k: nat) {struct ls} : list (int * nat) :=

  match ls with

  | LSdefault _ => nil

  | LScase ni _ rem => (ni, k) :: switch_table rem (S k)

  end.



Fixpoint switch_env (ls: lbl_stmt) (e: exit_env) {struct ls}: exit_env :=

  match ls with

  | LSdefault _ => e

  | LScase _ _ ls' => false :: switch_env ls' e

  end.



Fixpoint transl_stmt (cenv: compilenv) (xenv: exit_env) (s: Csharpminor.stmt)

                     {struct s}: res stmt :=

  match s with

  | Csharpminor.Sskip =>

      OK Sskip

  | Csharpminor.Sset id e =>

      do (te, a) <- transl_expr cenv e;

      OK (Sassign id te)

  | Csharpminor.Sstore chunk e1 e2 =>

      do (te1, a1) <- transl_expr cenv e1;

      do (te2, a2) <- transl_expr cenv e2;

      OK (make_store chunk te1 te2)

  | Csharpminor.Scall optid sig e el =>

      do (te, a) <- transl_expr cenv e;

      do tel <- transl_exprlist cenv el;

      OK (Scall optid sig te tel)

  | Csharpminor.Sbuiltin optid ef el =>

      do tel <- transl_exprlist cenv el;

      OK (Sbuiltin optid ef tel)

  | Csharpminor.Sseq s1 s2 =>

      do ts1 <- transl_stmt cenv xenv s1;

      do ts2 <- transl_stmt cenv xenv s2;

      OK (Sseq ts1 ts2)

  | Csharpminor.Sifthenelse e s1 s2 =>

      do (te, a) <- transl_expr cenv e;

      do ts1 <- transl_stmt cenv xenv s1;

      do ts2 <- transl_stmt cenv xenv s2;

      OK (Sifthenelse te ts1 ts2)

  | Csharpminor.Sloop s =>

      do ts <- transl_stmt cenv xenv s;

      OK (Sloop ts)

  | Csharpminor.Sblock s =>

      do ts <- transl_stmt cenv (true :: xenv) s;

      OK (Sblock ts)

  | Csharpminor.Sexit n =>

      OK (Sexit (shift_exit xenv n))

  | Csharpminor.Sswitch e ls =>

      let cases := switch_table ls O in

      let default := length cases in

      do (te, a) <- transl_expr cenv e;

      transl_lblstmt cenv (switch_env ls xenv) ls (Sswitch te cases default)

  | Csharpminor.Sreturn None =>

      OK (Sreturn None)

  | Csharpminor.Sreturn (Some e) =>

      do (te, a) <- transl_expr cenv e;

      OK (Sreturn (Some te))

  | Csharpminor.Slabel lbl s =>

      do ts <- transl_stmt cenv xenv s; OK (Slabel lbl ts)

  | Csharpminor.Sgoto lbl =>

      OK (Sgoto lbl)

  end



with transl_lblstmt (cenv: compilenv) (xenv: exit_env) (ls: Csharpminor.lbl_stmt) (body: stmt)

                    {struct ls}: res stmt :=

  match ls with

  | Csharpminor.LSdefault s =>

      do ts <- transl_stmt cenv xenv s;

      OK (Sseq (Sblock body) ts)

  | Csharpminor.LScase _ s ls' =>

      do ts <- transl_stmt cenv xenv s;

      transl_lblstmt cenv (List.tail xenv) ls' (Sseq (Sblock body) ts)

  end.



Definition block_alignment (sz: Z) : Z :=

  if zlt sz 2 then 1

  else if zlt sz 4 then 2

  else if zlt sz 8 then 4 else 8.



Definition assign_variable

    (cenv_stacksize: compilenv * Z) (id_sz: ident * Z) : compilenv * Z :=

  let (id, sz) := id_sz in

  let (cenv, stacksize) := cenv_stacksize in

  let ofs := align stacksize (block_alignment sz) in

  (PTree.set id ofs cenv, ofs + Zmax 0 sz).



Definition assign_variables (cenv_stacksize: compilenv * Z) (vars: list (ident * Z)) : compilenv * Z :=

  List.fold_left assign_variable vars cenv_stacksize.



Module VarOrder <: TotalLeBool.

  Definition t := (ident * Z)%type.

  Definition leb (v1 v2: t) : bool := zle (snd v1) (snd v2).

  Theorem leb_total: forall v1 v2, leb v1 v2 = true \/ leb v2 v1 = true.

  Proof.

    unfold leb; intros.

    assert (snd v1 <= snd v2 \/ snd v2 <= snd v1) by omega.

    unfold proj_sumbool. destruct H; [left|right]; apply zle_true; auto.

  Qed.

End VarOrder.



Module VarSort := Mergesort.Sort(VarOrder).



Definition build_compilenv (f: Csharpminor.function) : compilenv * Z :=

  assign_variables (PTree.empty Z, 0) (VarSort.sort (Csharpminor.fn_vars f)).



Definition transl_funbody

      (cenv: compilenv) (stacksize: Z) (f: Csharpminor.function): res function :=

   do tbody <- transl_stmt cenv nil f.(Csharpminor.fn_body);

       OK (mkfunction

              (Csharpminor.fn_sig f)

              (Csharpminor.fn_params f)

              (Csharpminor.fn_temps f)

              stacksize

              tbody).



Definition transl_function (f: Csharpminor.function): res function :=

  let (cenv, stacksize) := build_compilenv f in

  if zle stacksize Int.max_unsigned

  then transl_funbody cenv stacksize f

  else Error(msg "Cminorgen: too many local variables, stack size exceeded").



Definition transl_fundef (f: Csharpminor.fundef): res fundef :=

  transf_partial_fundef transl_function f.



Definition transl_program (p: Csharpminor.program) : res program :=

  transform_partial_program transl_fundef p.

