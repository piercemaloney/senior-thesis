Require Import VST.veric.SeparationLogic.
Require Export VST.veric.xexpr_rel.

Transparent mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric SRveric.

Lemma rel_r_value_const: forall {CS: compspecs} v P rho,
  P |-- rel_r_value (R_const v) v rho.
Proof. intros. intros ? ?. constructor. Qed.

Lemma rel_r_value_tempvar: forall {CS: compspecs} id v P rho,
  Map.get (te_of rho) id = Some v ->
  P |-- rel_r_value (R_tempvar id) v rho.
Proof. intros. intros ? ?. constructor; auto. Qed.

Lemma rel_r_value_addrof: forall {CS: compspecs} l v P rho,
  P |-- rel_l_value l v rho ->
  P |-- rel_r_value (R_addrof l) v rho.
Proof. intros. intros ? ?. constructor. apply H; auto. Qed.

Lemma rel_r_value_unop: forall {CS: compspecs} op r t v0 P v rho,
  P |-- rel_r_value r v0 rho ->
  sem_unary_operation op t v0 = Some v ->
  P |-- rel_r_value (R_unop op r t) v rho.
Proof.
  intros.
  intros ? ?.
  econstructor; [apply H; auto |].
  intros.
  destruct op; simpl in H0 |- *.
  + clear - H0.
    unfold Cop.sem_notbool; unfold sem_notbool in H0.
    destruct (Cop.classify_bool t), v0; try solve [simpl in H0 |- *; congruence].
    admit.
  + clear - H0.
    unfold Cop.sem_notint; unfold sem_notint in H0.
    destruct (Cop.classify_notint t), v0; try solve [simpl in H0 |- *; congruence].
  + clear - H0.
    unfold Cop.sem_neg; unfold sem_neg in H0.
    destruct (Cop.classify_neg t), v0; try solve [simpl in H0 |- *; congruence].
  + clear - H0.
    unfold Cop.sem_absfloat; unfold sem_absfloat in H0.
    destruct (Cop.classify_neg t), v0; try solve [simpl in H0 |- *; congruence].
Qed.

Opaque mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric SRveric Bveric.
