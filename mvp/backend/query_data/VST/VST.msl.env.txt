Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.boolean_alg.
(* VST.msl.boolean_alg:
Require Import VST.msl.base.
Require Import VST.msl.eq_dec.
Require Import VST.msl.sepalg.
Require Import GenericMinMax.

Module Type BOOLEAN_ALGEBRA.
  Parameters (t:Type) (Ord : t -> t -> Prop)
     (top bot : t) (lub glb : t -> t -> t) (comp : t -> t).

  Delimit Scope ba with ba. Open Scope ba.
  Notation "x <= y" := (Ord x y) (at level 70, no associativity) : ba.

  Axiom ord_refl : forall x, x <= x.
  Axiom ord_trans : forall x y z, x <= y -> y <= z -> x <= z.
  Axiom ord_antisym : forall x y, x <= y -> y <= x -> x = y.

  Axiom lub_upper1 : forall x y, x <= (lub x y).
  Axiom lub_upper2 : forall x y, y <= (lub x y).
  Axiom lub_least : forall x y z, x <= z -> y <= z -> (lub x y) <= z.

  Axiom glb_lower1 : forall x y, (glb x y) <= x.
  Axiom glb_lower2 : forall x y, (glb x y) <= y.
  Axiom glb_greatest : forall x y z, z <= x -> z <= y -> z <= (glb x y).

  Axiom top_correct : forall x, x <= top.
  Axiom bot_correct : forall x, bot <= x.

  Axiom distrib1 : forall x y z, glb x (lub y z) = lub (glb x y) (glb x z).

  Axiom comp1 : forall x, lub x (comp x) = top.
  Axiom comp2 : forall x, glb x (comp x) = bot.

  Axiom nontrivial : top <> bot.

  Hint Resolve ord_refl ord_antisym lub_upper1 lub_upper2 lub_least
         glb_lower1 glb_lower2 glb_greatest top_correct bot_correct
         ord_trans : ba.
End BOOLEAN_ALGEBRA.

Module Type BA_FACTS.
  Include BOOLEAN_ALGEBRA.

  Axiom ord_spec1 : forall x y, x <= y <-> x = glb x y.
  Axiom ord_spec2 : forall x y, x <= y <-> lub x y = y.

  Axiom lub_idem : forall x, (lub x x) = x.
  Axiom lub_commute : forall x y, lub x y = lub y x.
  Axiom lub_bot : forall x, lub x bot = x.
  Axiom lub_top : forall x, lub x top = top.
  Axiom lub_absorb : forall x y, lub x (glb x y) = x.
  Axiom lub_assoc : forall x y z, lub (lub x y) z = lub x (lub y z).

  Axiom glb_idem : forall x, glb x x = x.
  Axiom glb_commute : forall x y, glb x y = glb y x.
  Axiom glb_bot : forall x, glb x bot = bot.
  Axiom glb_top : forall x, glb x top = x.
  Axiom glb_absorb : forall x y, glb x (lub x y) = x.
  Axiom glb_assoc : forall x y z, glb (glb x y) z = glb x (glb y z).

  Axiom distrib2 : forall x y z, lub x (glb y z) = glb (lub x y) (lub x z).

  Axiom distrib_spec : forall x y1 y2,
    lub x y1 = lub x y2 ->
    glb x y1 = glb x y2 ->
    y1 = y2.

  Axiom demorgan1 : forall x y, comp (lub x y) = glb (comp x) (comp y).
  Axiom demorgan2 : forall x y, comp (glb x y) = lub (comp x) (comp y).
  Axiom comp_inv : forall x, comp (comp x) = x.

  Instance Join_ba: Join t := fun x y z : t => glb x y = bot /\ lub x y = z.

  Axiom pa: Perm_alg t.   Existing Instance pa.
  Axiom sa : Sep_alg t.   Existing Instance sa.
  Axiom ca : Canc_alg t. Existing Instance ca.
  Axiom singa : Sing_alg t.   Existing Instance singa.
  Axiom da : Disj_alg t.   Existing Instance da.
End BA_FACTS.

Class heightable (A : Type) : Type := Heightable {
  height : A -> nat;
  is_height_zero : forall a : A, {height a = 0} + {height a <> 0} 
 }.
Arguments Heightable [A] _ _.
Definition is_height_zero_spec {A : Type} (height : A -> nat) : Type :=
  forall a : A, {height a = 0} + {height a <> 0}.

Definition list_height {A} `{heightable A} (LA : list A) : nat :=
  fold_right max 0 (map height LA).
Fixpoint list_is_height_zero_bool {A} `{heightable A} (L : list A) : bool :=
  match L with
   | nil => true
   | a :: L' =>
      if is_height_zero a then list_is_height_zero_bool L' else false
  end.

 Class decomposible (A : Type) : Type := Decomposible {
  decompose : A -> (A * A)
 }.
 Arguments Decomposible [A] _.

 Class roundableLeft (A : Type) : Type := RoundableLeft {
   roundL : nat -> A -> option A
 }.
 Arguments RoundableLeft [A] _.

 Class roundableRight (A : Type) : Type := RoundableRight {
   roundR : nat -> A -> option A
 }.
 Arguments RoundableRight [A] _.

 Class avgable (A : Type) : Type := Avgable {
    avg : nat -> A -> A -> option A
 }.
 Arguments Avgable [A] _.

Module Type SHARE_MODEL.
  Include BA_FACTS.

  Parameter EqDec_share: EqDec t.
  Existing Instance EqDec_share.

  Parameter split : t -> t * t.

  Axiom split_disjoint : forall x1 x2 x,
    split x = (x1, x2) ->
    glb x1 x2 = bot.

  Axiom split_together : forall x1 x2 x,
    split x = (x1, x2) ->
    lub x1 x2 = x.

  Axiom split_nontrivial : forall x1 x2 x,
    split x = (x1, x2) ->
    (x1 = bot \/ x2 = bot) ->
    x = bot.

  Parameter isTokenFactory : t -> nat -> Prop.
  Parameter isToken : t -> nat -> Prop.

  Parameter create_token : nat -> t -> (t*t).

  Axiom create_token_correct : forall fac fac' tok x n,
    create_token n fac = (fac',tok) ->
    isTokenFactory fac x ->
      isTokenFactory fac' (n+x) /\
      isToken tok n /\
      join fac' tok fac.

  Axiom absorbToken : forall fac fac' tok x n,
    isTokenFactory fac' (n+x) ->
    isToken tok n ->
    join fac' tok fac ->
    isTokenFactory fac x.

  Axiom mergeToken : forall tok1 n1 tok2 n2 tok',
    isToken tok1 n1 ->
    isToken tok2 n2 ->
    join tok1 tok2 tok' ->
    isToken tok' (n1+n2).

  Parameter split_token : nat -> t -> t*t.

  Axiom split_token_correct : forall n1 n2 tok tok1 tok2,
    isToken tok (n1+n2) ->
    split_token n1 tok = (tok1,tok2) ->
      isToken tok1 n1 /\
      isToken tok2 n2 /\
      join tok1 tok2 tok.

  Axiom factoryOverlap : forall f1 f2 n1 n2,
    isTokenFactory f1 n1 -> isTokenFactory f2 n2 -> glb f1 f2 <> bot.

  Axiom fullFactory : forall x, isTokenFactory x 0 <-> x = top.
  Axiom identityToken : forall x, isToken x 0 <-> x = bot.

  Axiom nonidentityToken : forall x n, (n > 0)%nat -> isToken x n -> x <> bot.
  Axiom nonidentityFactory : forall x n, isTokenFactory x n -> x <> bot.

  Parameter rel : t -> t -> t.

  Axiom rel_inj_l : forall a x y, a <> bot -> rel a x = rel a y -> x = y.
  Axiom rel_inj_r : forall a b x, x <> bot -> rel a x = rel b x -> a = b.

  Axiom rel_assoc : forall x y z, rel x (rel y z) = rel (rel x y) z.

  Axiom rel_preserves_glb : forall a x y, rel a (glb x y) = glb (rel a x) (rel a y).
  Axiom rel_preserves_lub : forall a x y, rel a (lub x y) = lub (rel a x) (rel a y).

  Axiom rel_bot1 : forall a, rel a bot = bot.
  Axiom rel_bot2 : forall x, rel bot x = bot.
  Axiom rel_top1 : forall a, rel a top = a.
  Axiom rel_top2 : forall x, rel top x = x.

  Parameter unrel: t -> t -> t.
  Definition Lsh  : t := fst (split top).
  Definition Rsh  : t := snd (split top).
  Definition splice (a b: t) : t := lub (rel Lsh a) (rel Rsh b).

  Axiom unrel_rel: forall x sh, nonidentity x -> unrel x (rel x sh) = sh.
  Axiom unrel_splice_L: forall a b, unrel Lsh (splice a b) = a.
  Axiom unrel_splice_R: forall a b, unrel Rsh (splice a b) = b.
  Axiom contains_Lsh_e: forall sh, join_sub Lsh sh -> unrel Lsh sh = top.
  Axiom contains_Rsh_e: forall sh, join_sub Rsh sh -> unrel Rsh sh = top.
  Axiom unrel_disjoint: forall a a', a <> bot -> glb a a' = bot -> unrel a a' = bot.
  Axiom unrel_lub: forall a b1 b2, unrel a (lub b1 b2) = lub (unrel a b1) (unrel a b2).
  Axiom unrel_glb: forall a b1 b2, unrel a (glb b1 b2) = glb (unrel a b1) (unrel a b2).
  Axiom unrel_join: forall x a b c, join a b c -> join (unrel x a) (unrel x b) (unrel x c).
  Axiom unrel_top: forall a, unrel a top = top.
  Axiom unrel_bot: forall a, unrel a bot = bot.
  Axiom top_unrel: forall a, unrel top a = a.
  Axiom bot_unrel: forall a, unrel bot a = a.

 Parameter tree_height : t -> nat.
 Parameter tree_height_zero : forall t, {tree_height t = 0} + {tree_height t <> 0}.
 Instance tree_heightable : heightable t :=
   Heightable tree_height tree_height_zero.
 
 Parameter tree_round_left : nat -> t -> option t.
 Instance  roundableL_tree : roundableLeft t :=
   RoundableLeft tree_round_left.
 
 Parameter tree_round_right : nat -> t -> option t.
 Instance  roundableR_tree : roundableRight t :=
   RoundableRight tree_round_right.
 
 Parameter tree_avg : nat -> t -> t -> option t.
 Instance avgable_tree : avgable t :=
    Avgable tree_avg.
 
 Parameter countBLeafCT : nat -> t -> nat.
 
 Parameter share_metric : nat -> t -> nat.
 
 Parameter tree_decompose : t -> (t * t).
 Instance decompose_tree : decomposible t :=
   Decomposible tree_decompose.
 
 Parameter recompose : (t * t) -> t.
 
 Parameter power : nat -> nat -> nat.
 
 Parameter add : t -> t -> option t.
 
 Parameter sub : t -> t -> option t.
 
 Axiom leq_dec : forall (x y : t), {x <= y} + {~ (x <= y)}.
 
 Axiom height_top : height top = 0.
 
 Axiom height_bot : height bot = 0.
 
 Axiom height_zero_eq: forall t, height t = 0 -> {t = top} + {t = bot}.
 
 Axiom decompose_height : forall n t1 t2 t3,
                          height t1 = S n ->
                          decompose t1 = (t2, t3) ->
                          (height t2 <= n)%nat /\ (height t3 <= n)%nat.
 
 Axiom decompose_recompose: forall t,
    decompose (recompose t) = t.
 
 Axiom recompose_decompose: forall t,
    recompose (decompose t) = t.
 
 Axiom decompose_join: forall t1 t11 t12 t2 t21 t22 t3 t31 t32,
    decompose t1 = (t11, t12) ->
    decompose t2 = (t21, t22) ->
    decompose t3 = (t31, t32) ->
    (join t1 t2 t3 <->
    (join t11 t21 t31 /\ join t12 t22 t32)).
 Axiom decompose_glb: forall t1 t11 t12 t2 t21 t22 t3 t31 t32,
  decompose t1 = (t11,t12) ->
  decompose t2 = (t21,t22) ->
  decompose t3 = (t31,t32) ->
  (glb t1 t2 = t3 <-> (glb t11 t21 = t31 /\ glb t12 t22 = t32)).
 Axiom decompose_lub: forall t1 t11 t12 t2 t21 t22 t3 t31 t32,
  decompose t1 = (t11,t12) ->
  decompose t2 = (t21,t22) ->
  decompose t3 = (t31,t32) ->
  (lub t1 t2 = t3 <-> (lub t11 t21 = t31 /\ lub t12 t22 = t32)).
 
 Axiom add_join : forall t1 t2 t3,
    add t1 t2 = Some t3 <-> join t1 t2 t3.
 
 Axiom sub_join : forall t1 t2 t3,
    sub t1 t2 = Some t3 <-> join t2 t3 t1.
 
 Axiom decompose_share_height_no_increase: forall sh sh' sh'' ,
   decompose sh = (sh',sh'')->
   (height sh' <= height sh /\ height sh'' <= height sh)%nat.
  Axiom decompose_height_le: forall n s s1 s2,
  decompose s = (s1,s2) ->
  (height s <= S n)%nat ->
  (height s1 <= n)%nat /\ (height s2 <= n)%nat.
 
 Axiom decompose_le: forall s1 s2 s11 s12 s21 s22,
  s1 <= s2 ->
  decompose s1 = (s11,s12) ->
  decompose s2 = (s21,s22) ->
  s11 <= s21 /\ s12 <= s22.
 
 Axiom decompose_diff: forall s1 s2 s11 s12 s21 s22,
  s1 <> s2 ->
  decompose s1 = (s11,s12) ->
  decompose s2 = (s21,s22) ->
  s11 <> s21 \/ s12 <> s22.
 
 Axiom tree_round_left_join : forall n t1 t2 t3 t1' t2' t3',
    join t1 t2 t3 ->
    roundL n t1 = Some t1' ->
    roundL n t2 = Some t2' ->
    roundL n t3 = Some t3' ->
    join t1' t2' t3'.
 
 Axiom tree_round_left_identity : forall n t,
    height t < n ->
    roundL n t = Some t.
 
 Axiom tree_round_left_None : forall n t,
    n < height t ->
    roundL n t = None.
 
 Axiom tree_round_left_decrease : forall n t,
    S n = height t ->
    exists t', roundL (S n) t = Some t' /\ (height t' <= n)%nat.
 
 Axiom tree_round_left_Some : forall n t,
    (height t <= S n)%nat ->
    exists t', roundL (S n) t = Some t'.
 
 Axiom tree_round_left_height_compare : forall t t' n,
    roundL n t = Some t' ->
    (height t' < n)%nat.
 
  Axiom tree_round_left_zero: forall t,
    roundL 0 t = None.
 
 Axiom tree_round_right_join : forall n t1 t2 t3 t1' t2' t3',
    join t1 t2 t3 ->
    roundR n t1 = Some t1' ->
    roundR n t2 = Some t2' ->
    roundR n t3 = Some t3' ->
    join t1' t2' t3'.
 
 Axiom tree_round_right_identity : forall n t,
    height t < n ->
    roundR n t = Some t.
 
 Axiom tree_round_right_None : forall n t,
    n < height t ->
    roundR n t = None.
 
 Axiom tree_round_right_decrease : forall n t,
    S n = height t ->
    exists t', roundR (S n) t = Some t' /\ (height t' <= n)%nat.
 
 Axiom tree_round_right_Some : forall n t,
    (height t <= S n)%nat ->
    exists t', roundR (S n) t = Some t'.
 
 Axiom tree_round_right_height_compare : forall t t' n,
    roundR n t = Some t' ->
    (height t' < n)%nat.
 
  Axiom tree_round_right_zero: forall t,
    roundR 0 t = None.

  Axiom tree_avg_identity : forall n t,
   height t < n ->
   avg n t t = Some t.
  
  Axiom tree_avg_None : forall n t1 t2,
   (n <= max (height t1) (height t2))%nat ->
   avg n t1 t2 = None.
  
    Axiom tree_avg_round2avg : forall n t1 t2 t3,
   roundL n t3 = Some t1 ->
   roundR n t3 = Some t2 ->
   avg n t1 t2 = Some t3.
  
  Axiom tree_avg_avg2round : forall n t1 t2 t3,
   avg n t1 t2 = Some t3 ->
   roundL n t3 = Some t1 /\
   roundR n t3 = Some t2.
  
  Axiom tree_avg_join : forall n t11 t12 t13 t21 t22 t23 t31 t32 t33,
   avg n t11 t12 =  Some t13 ->
   avg n t21 t22 = Some t23 ->
   avg n t31 t32 = Some t33 ->
   join t11 t21 t31 ->
   join t12 t22 t32 ->
   join t13 t23 t33.
  
  Axiom tree_avg_ex: forall n t1 t2,
   height t1 < n ->
   height t2 < n ->
   exists t3, avg n t1 t2 = Some t3.
  
  Axiom avg_share_correct: forall n s,
   (height s <= S n)%nat ->
   exists s', exists s'',
    roundL (S n) s = Some s' /\
    roundR (S n) s = Some s'' /\
    avg (S n) s' s'' = Some s.

 Axiom countBLeafCT_decompose : forall n s s1 s2,
  decompose s = (s1,s2) ->
  countBLeafCT (S n) s = countBLeafCT n s1 + countBLeafCT n s2.
 
 Axiom countBLeafCT_le : forall n s1 s2,
  s1 <= s2 -> (countBLeafCT n s1 <= countBLeafCT n s2)%nat.
 
 Axiom countBLeafCT_lt : forall n s1 s2,
  s1 <= s2 ->
  s1 <> s2 ->
  (height s2 <= n)%nat ->
  countBLeafCT n s1 < countBLeafCT n s2.
 
 Axiom countBLeafCT_limit: forall n s, (countBLeafCT n s <= power 2 n)%nat.
 
 Axiom countBLeafCT_bot: forall n, countBLeafCT n bot = 0.
 
 Axiom countBLeafCT_top: forall n, countBLeafCT n top = power 2 n.
 
 Axiom countBLeafCT_positive : forall s n,
   (height s <= n)%nat ->
   bot <> s -> 0 < countBLeafCT n s.
 
 Axiom countBLeafCT_mono_le: forall n1 n2 s,
  (n1 <= n2)%nat ->
  (countBLeafCT n1 s <= countBLeafCT n2 s)%nat .
 
 Axiom countBLeafCT_mono_diff: forall n1 n2 s1 s2,
  (n1 <= n2)%nat ->
   s1 <= s2 ->
  (countBLeafCT n1 s2 - countBLeafCT n1 s1 <= countBLeafCT n2 s2 - countBLeafCT n2 s1)%nat.
 
 Axiom countBLeafCT_mono_lt: forall n1 n2 s,
  n1 < n2 ->
  0 < countBLeafCT n1 s ->
  countBLeafCT n1 s < countBLeafCT n2 s .
 
 Axiom countBLeafCT_join_le: forall n s1 s2 s3,
  join s1 s2 s3 ->
  (countBLeafCT n s1 + countBLeafCT n s2 <= countBLeafCT n s3)%nat.
 
 Axiom countBLeafCT_join_eq: forall n s1 s2 s3,
  join s1 s2 s3 ->
  (height s1 <= n)%nat ->
  (height s2 <= n)%nat ->
  countBLeafCT n s1 + countBLeafCT n s2 = countBLeafCT n s3.
 
 Axiom share_metric_nerr : forall s n,
  height s < n ->
  0 < share_metric n s.
 
 Axiom share_metric_err  : forall s n,
  (n <= height s)%nat ->
  share_metric n s = 0.
 
 Axiom share_metric_height_monotonic : forall s n1 n2,
  (n1 <= n2)%nat ->
  (share_metric n1 s <= share_metric n2 s)%nat.
 
 Axiom share_metric_lub : forall s s' n,
  ~(s'<=s) ->
  0 < share_metric n s ->
  0 < share_metric n (lub s s') ->
  share_metric n s < share_metric n (lub s s').
 
 Axiom share_metric_glb : forall s s' n,
  ~(s<=s') ->
  0 < share_metric n s ->
  0 < share_metric n (glb s s') ->
  share_metric n (glb s s') < share_metric n s.
 
 Axiom share_metric_dif_monotonic: forall s1 s2 n n0,
  s1<=s2 ->
  (n<=n0)%nat ->
  height s1 < n -> height s2 < n ->
  (share_metric n s2 - share_metric n s1 <=
  share_metric n0 s2 - share_metric n0 s1)%nat.

 Axiom tree_height_lub_limit: forall n s1 s2,
  (height s1 <= n)%nat ->
  (height s2 <= n)%nat ->
  (height (lub s1 s2) <= n)%nat.
 
 Axiom tree_height_glb_limit: forall n s1 s2,
  (height s1 <= n)%nat ->
  (height s2 <= n)%nat ->
  (height (glb s1 s2) <= n)%nat.
 
 Axiom height_lub1 : forall s1 s2,
  (height s1<= height s2)%nat->
  (height (lub s1 s2) <= height s2)%nat.
 
 Axiom height_glb1 : forall s1 s2,
  (height s1<= height s2)%nat->
  (height (glb s1 s2) <= height s2)%nat.
 
 Axiom height_comp: forall s,
  height (comp s)= height s.

 Axiom decompose_height_zero: forall s sL sR,
  decompose s = (sL,sR) ->
  height s = 0 ->
  sL = s /\ sR = s.

 Axiom decompose_equal: forall a b aL aR bL bR,
  decompose a = (aL,aR) ->
  decompose b = (bL,bR) ->
  (a = b <-> aL = bL /\ aR = bR).

 Axiom decompose_nonzero: forall sL sR s,
 decompose s = (sL,sR) ->
 (s <> bot <-> sL <> bot \/ sR <> bot).

 Axiom tree_avg_equal: forall sL sR sL' sR' s n,
  avg n sL sR = Some s ->
  avg n sL' sR' = Some s ->
  sL = sL' /\ sR = sR'.

 Axiom tree_avg_zero: forall sL sR s n,
  avg n sL sR = Some s ->
  (s = bot <-> sL = bot /\ sR = bot).

 Axiom tree_avg_nonzero: forall sL sR s n,
  avg n sL sR = Some s ->
  (s <> bot <-> sL <> bot \/ sR <> bot).

 Axiom tree_avg_bound: forall sL sR s n,
  avg n sL sR = Some s -> (height s <= n)%nat.

 Axiom Lsh_recompose: Lsh = recompose (top, bot).
 Axiom Rsh_recompose: Rsh = recompose (bot,top).
 Axiom decompose_Rsh: forall sh, unrel Rsh sh = snd (decompose sh).
 Axiom decompose_Lsh: forall sh, unrel Lsh sh = fst (decompose sh).
 Axiom rel_Lsh: forall sh, rel Lsh sh = recompose (sh,bot).
 Axiom rel_Rsh: forall sh, rel Rsh sh = recompose (bot,sh).
 Axiom lub_rel_recompose: forall sh1 sh2,
             lub (rel Lsh sh1) (rel Rsh sh2) = recompose (sh1,sh2).

End SHARE_MODEL.

Module BA_Facts (BA:BOOLEAN_ALGEBRA) <: BA_FACTS.
  Include BA.

  Lemma ord_spec1 : forall x y, x <= y <-> x = glb x y.

  Lemma ord_spec2 : forall x y, x <= y <-> lub x y = y.

  Lemma lub_idem : forall x, lub x x = x.

  Lemma glb_idem : forall x, glb x x = x.

  Lemma lub_commute : forall x y, lub x y = lub y x.

  Lemma glb_commute : forall x y, glb x y = glb y x.

  Lemma lub_absorb : forall x y, lub x (glb x y) = x.

  Lemma glb_absorb : forall x y, glb x (lub x y) = x.

  Lemma lub_assoc : forall x y z, lub (lub x y) z = lub x (lub y z).

  Lemma glb_assoc : forall x y z, glb (glb x y) z = glb x  (glb y z).

  Lemma glb_bot : forall x, glb x bot = bot.

  Lemma lub_top : forall x, lub x top = top.

  Lemma lub_bot : forall x, lub x bot = x.

  Lemma glb_top : forall x, glb x top = x.

  Lemma distrib2 : forall x y z,
    lub x (glb y z) = glb (lub x y) (lub x z).

  Lemma distrib_spec : forall x y1 y2,
    lub x y1 = lub x y2 ->
    glb x y1 = glb x y2 ->
    y1 = y2.

  Lemma comp_inv : forall x, comp (comp x) = x.

  Lemma demorgan1 : forall x y, comp (lub x y) = glb (comp x) (comp y).

  Lemma demorgan2 : forall x y, comp (glb x y) = lub (comp x) (comp y).

End BA_Facts. *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.functors.
(* VST.msl.functors:
Require Import VST.msl.base.

Set Implicit Arguments.

Module CovariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : A -> B), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : B -> C) (g : A -> B),
fmap _ _ f oo fmap _ _ g = fmap _ _ (f oo g)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : A -> B), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End CovariantFunctor.

Module ContraVariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : C -> B) (g : B -> A),
fmap _ _ f oo fmap _ _ g = fmap _ _ (g oo f)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End ContraVariantFunctor.

Module MixVariantFunctor.

Record functorFacts (PS : Type -> Type)
 (fmap : forall A B (f1 : A -> B) (f2 : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) (id A) = id (PS A);
  ff_comp : forall A B C (f1 : B -> C) (f2 : C -> B) (g1 : A -> B)
(g2 : B -> A), fmap _ _ f1 f2 oo fmap _ _ g1 g2 = fmap _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f1 : A -> B) (f2 : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End MixVariantFunctor.

Module CovariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : B2 -> C2)
(g1 : A1 -> B1) (g2 : A2 -> B2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (f2 oo g2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CovariantBiFunctor.

Module CoContraVariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : C2 -> B2)
(g1 : A1 -> B1) (g2 : B2 -> A2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CoContraVariantBiFunctor.

Coercion CovariantFunctor._functor:
  CovariantFunctor.functor >-> Funclass.
Coercion ContraVariantFunctor._functor:
  ContraVariantFunctor.functor >-> Funclass.
Coercion MixVariantFunctor._functor:
  MixVariantFunctor.functor >-> Funclass.
Coercion CovariantBiFunctor._functor:
  CovariantBiFunctor.functor >-> Funclass.
Coercion CoContraVariantBiFunctor._functor:
  CoContraVariantBiFunctor.functor >-> Funclass.

Module CovariantFunctorLemmas.

Import CovariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : B -> C) (g : A -> B),
  fmap F f oo fmap F g = fmap F (f oo g).

Lemma fmap_app {F: functor} : forall A B C (f : B -> C) (g : A -> B) x,
  fmap F f (fmap F g x) = fmap F (f oo g) x.

End CovariantFunctorLemmas.

Module ContraVariantFunctorLemmas.

Import ContraVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : C -> B) (g : B -> A),
  fmap F f oo fmap F g = fmap F (g oo f).

Lemma fmap_app {F: functor} : forall A B C (f : C -> B) (g : B -> A) x,
  fmap F f (fmap F g x) = fmap F (g oo f) x.

End ContraVariantFunctorLemmas.

Module MixVariantFunctorLemmas.

Import MixVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End MixVariantFunctorLemmas.

Module CovariantBiFunctorLemmas.

Import CovariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (f2 oo g2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (f2 oo g2) x.

End CovariantBiFunctorLemmas.

Module CoContraVariantBiFunctorLemmas.

Import CoContraVariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End CoContraVariantBiFunctorLemmas.

Module GeneralFunctorGenerator.

Definition CovariantFunctor_MixVariantFunctor (F: CovariantFunctor.functor):

Definition ContraVariantFunctor_MixVariantFunctor
 (F: ContraVariantFunctor.functor):

Definition CovariantFunctor_CoContraVariantBiFunctor
 (F: CovariantFunctor.functor):

Definition CoContraVariantBiFunctor_MixVariantFunctor
 (F: CoContraVariantBiFunctor.functor):

Definition CovariantFunctor_CovariantFunctor_compose
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f => CovariantFunctor.fmap F1 (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantFunctor_MixVariantFunctor_compose
(F1: CovariantFunctor.functor) (F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f g => CovariantFunctor.fmap F1 (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite MixVariantFunctorLemmas.fmap_id, CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp, MixVariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_CovariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CovariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_MixVariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CovariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_CoContraVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1: CovariantFunctor.functor)
(F2: ContraVariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CoContraVariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (ContraVariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite CovariantFunctorLemmas.fmap_id, ContraVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, CovariantFunctorLemmas.fmap_comp, ContraVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_MixVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CoContraVariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 g f)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

End GeneralFunctorGenerator.

Module CovariantBiFunctorGenerator.

Import CovariantBiFunctor.
Import CovariantBiFunctorLemmas.

Definition Fpair: functor.

Definition Fchoice: functor.

End CovariantBiFunctorGenerator.

Module CoContraVariantBiFunctorGenerator.

Import CoContraVariantBiFunctor.
Import CoContraVariantBiFunctorLemmas.

Definition Ffunc: functor.

End CoContraVariantBiFunctorGenerator.

Module CovariantFunctorGenerator.

Import CovariantFunctor.
Import CovariantFunctorLemmas.

Definition fconst (T : Type): functor.

Definition fidentity: functor.

Definition Foption: functor.

Definition Flist: functor.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Goal forall (F1 F2: functor) (T: Type), fpair F1 F2 T = prod (F1 T) (F2 T).

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Flist
  F.

Goal forall (F : functor) (T: Type), foption F T = option (F T).

Definition ffunc (F1: ContraVariantFunctor.functor) (F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_CoContraVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Goal forall (F1 : ContraVariantFunctor.functor) (F2: functor) (T: Type),

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B (f: A -> B) x, P A x -> P B (fmap F f x)): functor.

End CovariantFunctorGenerator.

Module MixVariantFunctorGenerator.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.

Definition fconst (T : Type): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  (CovariantFunctorGenerator.fconst T).

Definition fidentity: functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  CovariantFunctorGenerator.fidentity.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Flist
  F.

Definition ffunc (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_MixVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fpi {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B f g x, P A x -> P B (fmap F f g x)): functor.

End MixVariantFunctorGenerator.

Unset Implicit Arguments. *)

Require Import VST.msl.sepalg_functors.
(* VST.msl.sepalg_functors:
Require Import VST.msl.base.
Require Import VST.msl.functors.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Set Implicit Arguments.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.
Import MixVariantFunctorGenerator.

Section unmaps.
  Variables (A: Type)(J_A: Join A).
  Variables (B: Type)(J_B: Join B).

  Definition unmap_left (f:A -> B) :=
    forall x' y z,
      join x' (f y) (f z) ->
      { x:A & { y0:A | join x y0 z /\ f x = x' /\ f y0 = f y }}.

  Definition unmap_right (f:A -> B) :=
    forall x y z',
      join (f x) (f y) z' ->
      { y0: A & { z:A | join x y0 z /\ f y0 = f y /\ f z = z' }}.
End unmaps.

Record pafunctor (F: functor) (paf_join: forall A, Join (F A)): Type := Pafunctor
{
  paf_join_hom : forall A B (f : A -> B) (g: B -> A), join_hom (fmap F f g);
  paf_preserves_unmap_left : forall A B (f : A -> B) (g: B -> A),
    unmap_left (paf_join A) (paf_join B) (fmap F f g);
  paf_preserves_unmap_right : forall A B (f : A -> B) (g: B -> A),
    unmap_right (paf_join A) (paf_join B) (fmap F f g)
}.

Section ConstPAFunctor.

  Variables (T : Type)(J_T: Join T).

  Lemma paf_const : pafunctor (fconst T) (fun _ => J_T).
End ConstPAFunctor.

Section EquivPAFunctor.
  Variables (F : functor).

  Lemma paf_equiv : @pafunctor F (fun A => @Join_equiv (F A)).

End EquivPAFunctor.

Section PairSAFunctor.
  Variables (F1 F2: functor).
  Variables (J_F1: forall A, Join (F1 A)) (pafF1: pafunctor F1 J_F1).
  Variables (J_F2: forall A, Join (F2 A)) (pafF2: pafunctor F2 J_F2).

  Lemma paf_pair : @pafunctor (fpair F1 F2) (fun A : Type => Join_prod (F1 A) (J_F1 A) (F2 A) (J_F2 A)).
End PairSAFunctor.

Section CoFunSAFunctor.
  Variables (dom: Type) (rng : functor).
  Variables (Join_rng: forall A, Join (rng A)) (pss_rng : pafunctor rng Join_rng).

  Definition paf_fun : @pafunctor (ffunc (fconst dom) rng)
                         (fun A => Join_fun dom _ (Join_rng A)).
End CoFunSAFunctor.

Section SepAlgSubset_Functor.
  Variables (F: functor).
  Variables (JOIN: forall A, Join (F A))
            (fSA : @pafunctor F JOIN).

  Variable P : forall A, F A -> Prop.
  Arguments P {A} _.
  Hypothesis HPfmap1 : forall A B (f: A -> B) (g: B -> A) x,
    P x -> P (fmap F f g x).
  Hypothesis HPfmap2 : forall A B (f: A -> B) (g: B -> A) x,
    P (fmap F f g x) -> P x.

  Definition paf_subset :
    @pafunctor (fsubset F (@P) HPfmap1) (fun A => Join_prop _ _ P).

End SepAlgSubset_Functor. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)

Require Import VST.msl.shares.
(* VST.msl.shares:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.
Require Import VST.msl.psepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.boolean_alg.
Require Import VST.msl.eq_dec.

Require VST.msl.tree_shares.

Module Share : SHARE_MODEL := tree_shares.Share.
Import Share.

Definition share : Type := Share.t.

Instance pa_share : Perm_alg share := Share.pa.
Instance sa_share : Sep_alg share := Share.sa.
Instance ca_share : Canc_alg share := Share.ca.
Definition emptyshare : share := Share.bot.
Definition fullshare : share := Share.top.

Theorem leq_join_sub : forall s1 s2:Share.t,

Lemma top_correct' : forall x:t, join_sub x top.

Lemma bot_identity : identity bot.

Hint Resolve bot_identity.

Lemma identity_share_bot : forall s,
  identity s -> s = bot.

Lemma factoryOverlap' : forall f1 f2 n1 n2,
  isTokenFactory f1 n1 -> isTokenFactory f2 n2 -> joins f1 f2 -> False.

Lemma identityToken' : forall x, isToken x 0 <-> identity x.

Lemma nonidentityToken' : forall x n, (n > 0)%nat -> isToken x n -> nonidentity x.

Lemma nonidentityFactory' : forall x n, isTokenFactory x n -> nonidentity x.
Proof.
  intros.
  generalize (nonidentityFactory x n H); repeat intro.

Lemma split_join : forall x1 x2 x,
  split x = (x1,x2) -> join x1 x2 x.

Lemma split_nontrivial' : forall x1 x2 x,
  split x = (x1, x2) ->
    (identity x1 \/ identity x2) ->
    identity x.

Lemma rel_leq : forall a x, join_sub (rel a x) a.

Lemma rel_join : forall a x y z,
  join x y z ->
  join (rel a x) (rel a y) (rel a z).

Lemma rel_join2 : forall a x y s,
  nonidentity a ->
  join (rel a x) (rel a y) s ->
  exists z, s = rel a z /\ join x y z.

Lemma rel_nontrivial : forall a x,
  identity (rel a x) ->
  (identity a \/ identity x).

Lemma bot_correct' : forall x, join_sub bot x.

Lemma top_share_nonidentity : nonidentity top.

Lemma top_share_nonunit: nonunit top.

Lemma bot_join_eq : forall x, join bot x x.

Lemma join_bot_eq : forall x, join x bot x.

Lemma bot_joins : forall x, joins bot x.

Lemma dec_share_identity : forall x:t, { identity x } + { ~identity x }.

Lemma dec_share_nonunit : forall x:t, { nonunit x } + { ~ nonunit x }.

Lemma fullshare_full : full fullshare.

Lemma join_sub_fullshare : forall sh,
  join_sub fullshare sh -> sh = fullshare.

Lemma dec_share_full : forall (sh : Share.t),

Lemma rel_congruence : forall a x1 x2,
  join_sub x1 x2 ->
  join_sub (rel a x1) (rel a x2).

Lemma share_split_injective:
  forall sh1 sh2, Share.split sh1 = Share.split sh2 -> sh1=sh2.

Lemma share_joins_constructive:
  forall sh1 sh2 : t , joins sh1 sh2 ->  {sh3 | join sh1 sh2 sh3}.

Lemma share_join_sub_constructive:
  forall sh1 sh3 : t , join_sub sh1 sh3 ->  {sh2 | join sh1 sh2 sh3}.

Lemma triple_join_exists_share : Trip_alg t.

Lemma nonemp_split_neq1: forall sh sh1 sh2, nonidentity sh -> split sh = (sh1, sh2) -> sh1 <> sh.

Lemma nonemp_split_neq2: forall sh sh1 sh2, nonidentity sh -> split sh = (sh1, sh2) -> sh2 <> sh.

Lemma bot_unit: forall sh,
  join emptyshare sh sh.

Hint Resolve bot_unit.

Lemma join_bot: join emptyshare emptyshare emptyshare.

Lemma share_rel_nonidentity:
  forall {sh1 sh2}, nonidentity sh1 -> nonidentity sh2 -> nonidentity (Share.rel sh1 sh2).

Lemma share_rel_nonunit: forall {sh1 sh2: Share.t},

Lemma decompose_bijection: forall sh1 sh2,
 sh1 = sh2 <-> decompose sh1 = decompose sh2.

Module ShareMap.
Section SM.
  Variable A:Type.
  Variable EqDec_A : EqDec A.

  Variable B:Type.
  Variable JB: Join B.
  Variable paB : Perm_alg B.
  Variable saB : Sep_alg B.

  Definition map := fpm A (lifted Share.Join_ba * B).
  Instance Join_map : Join map := Join_fpm _.
  Instance pa_map : Perm_alg map := Perm_fpm _ _.
  Instance sa_map : Sep_alg map := Sep_fpm _ _.
  Instance ca_map {CA: Canc_alg B} : Canc_alg map := Canc_fpm _.
  Instance da_map {DA: Disj_alg B} : Disj_alg map := @Disj_fpm _ _ _ _ _ _.

  Definition map_share (a:A) (m:map) : share :=
    match lookup_fpm m a with
    | Some (sh,_) => lifted_obj sh
    | None => Share.bot
    end.

  Definition map_val (a:A) (m:map) : option B :=
    match lookup_fpm m a with
    | Some (_,b) => Some b
    | None => None
    end.

  Definition empty_map : map := empty_fpm _ _.

  Definition map_upd (a:A) (b:B) (m:map) : option map :=
    match lookup_fpm m a with
    | Some (sh,_) =>
        if eq_dec (lifted_obj sh) fullshare
           then Some (insert_fpm _ a (sh,b) m)
           else None
    | None => None
    end.

Lemma join_lifted {t} {J: Join t}:
    forall (a b c: lifted J), join a b c -> join (lifted_obj a) (lifted_obj b) (lifted_obj c).

  Lemma map_join_char : forall m1 m2 m3,
    join m1 m2 m3 <->
    (forall a,
       join (map_share a m1) (map_share a m2) (map_share a m3) /\
       join (map_val a m1) (map_val a m2) (map_val a m3)).

  Lemma empty_map_identity {CAB: Disj_alg B}: identity empty_map.

  Lemma map_identity_unique {CAB: Disj_alg B}: forall m1 m2:map,
    identity m1 -> identity m2 -> m1 = m2.

  Lemma map_identity_is_empty  {CAB: Disj_alg B} : forall m,
    identity m -> m = empty_map.

  Lemma empty_map_join {CAB: Disj_alg B} : forall m,
    join empty_map m m.

  Lemma map_val_bot  : forall a m,
    map_val a m = None <-> map_share a m = Share.bot.

  Lemma map_upd_success : forall a v m,
    map_share a m = Share.top ->

  Lemma map_set_share1 : forall a v m m',
    map_upd a v m = Some m' ->
    map_share a m = Share.top.

  Lemma map_set_share2 : forall a v m m',
    map_upd a v m = Some m' ->
    map_share a m' = Share.top.

  Lemma map_set_share3 : forall a v m m',
    map_upd a v m = Some m' ->
    forall a',
      map_share a' m = map_share a' m'.

  Lemma map_gss_val: forall a v m m',
        map_upd a v m = Some m' ->
        map_val a m' = Some v.

  Lemma map_gso_val : forall i j v m m',
       i <> j ->
       map_upd j v m = Some m' ->
       map_val i m = map_val i m'.

  Lemma map_gso_share : forall i j v m m',
    i <> j ->
    map_upd j v m = Some m' ->
    map_share i m = map_share i m'.

  Lemma map_upd_join : forall m1 m2 m3 a v m1',
    map_upd a v m1 = Some m1' ->
    join m1 m2 m3 ->
    exists m3', map_upd a v m3 = Some m3' /\
      join m1' m2 m3'.

  Definition build_map (l:list (A * B)) : map :=
     fold_right
      (fun (ab:A * B) m =>
        insert_fpm EqDec_A
           (fst ab)
           (mk_lifted fullshare top_share_nonunit,snd ab) m)
      empty_map l.

  Lemma build_map_results : forall (l:list (A*B)) a b,
    NoDup (List.map (@fst _ _) l) ->

  Lemma build_map_join : forall (l1 l2:list (A * B)),
    NoDup (List.map (@fst _ _) (l1++l2)) ->

End SM.
End ShareMap. *)

Require Import VST.msl.cross_split.
(* VST.msl.cross_split:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.
Require Import VST.msl.psepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.cjoins.
Require Import VST.msl.eq_dec.

  Definition sa_distributive (A: Type) {JOIN: Join A} :=
    forall a b x z,
      join a b z ->
      constructive_join_sub x z ->
      {a' : A & {b' : A &
           (constructive_join_sub a' a * constructive_join_sub b' b * join a' b' x)%type}}.

  Theorem cross_split_distibutive {A} `{Perm_alg A}{SA: Sep_alg A}{CS: Cross_alg A} :
          sa_distributive A.

  Theorem distributive_cross_split {A} `{Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     sa_distributive A -> Cross_alg A.

Lemma distributive_equiv: forall A, @sa_distributive  _ (@Join_equiv A).

Lemma cross_split_equiv : forall A,  @Cross_alg _ (@Join_equiv A).

Lemma distributive_fun: forall A (JOIN: Join A) (key: Type),
               sa_distributive A -> @sa_distributive (key -> A) (Join_fun key A JOIN).

Lemma sa_distributive_prod : forall A B saA saB,
  @sa_distributive A saA ->
  @sa_distributive B saB ->
  @sa_distributive (A * B) (Join_prod A _ B _).

Lemma sa_distributive_bij : forall A B JA bij,
  @sa_distributive A JA ->
  @sa_distributive B (Join_bij A JA B bij).

Lemma Cross_bij : forall A B JA bij,
  @Cross_alg A  JA ->
  @Cross_alg B (Join_bij A JA B bij).

Lemma constructive_join_sub_smash {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  (forall x:A, {identity x}+{~identity x}) ->
  forall a c : lifted JA,
    constructive_join_sub (proj1_sig a) (proj1_sig c) ->
    @constructive_join_sub (option (lifted JA)) _ (Some a) (Some c).

Lemma sa_distributive_smash : forall A JA {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  @sa_distributive A JA ->
  sa_distributive (option (lifted JA)).

Lemma Cross_smash : forall A (JA: Join A) {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  Cross_alg A ->
  Cross_alg (option (lifted JA)).

Lemma cross_split_fpm : forall A B
      (JB: Join B) (PB: Perm_alg B)(SB : Sep_alg B)(CB: Disj_alg B)
  (Bdec: forall x:B, {identity x}+{~identity x}) ,
  Cross_alg B  ->
  Cross_alg (fpm A (lifted JB)) .

Lemma Cross_fpm (A B: Type){JB: Join B} {PB: Perm_alg B}{PosB : Pos_alg B}
  {CrB: Cross_alg B}:   Cross_alg (fpm A B) .

Definition opposite_bij {A B} (b: bijection A B) : bijection B A :=
 Bijection _ _ (bij_g _ _ b) (bij_f _ _ b) (bij_gf _ _ b) (bij_fg _ _ b).

Lemma Cross_bij' : forall A B JA JB bij,
  @Cross_alg B JB ->
   JB =  (Join_bij A JA B bij) ->
  @Cross_alg A  JA.

Definition option_bij {A B} (D: bijection A B) : bijection (option A) (option B). *)

Require Import VST.msl.psepalg.
(* VST.msl.psepalg:
Require Import VST.msl.base.
Require Import VST.msl.eq_dec.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Lemma pjoin_unit {A} {JA: Join A}{PosA: Pos_alg A}: forall {a b : A},
  join a b b -> False.

Definition cjoins {A} {JA: Join A} (a b : A) : Type := {c : A | join a b c}.

Definition cjoin_sub {A} {JA: Join A} (a c : A) : Type := {b : A | join a b c}.

Lemma joins_comm {A} {JA: Join A}{PA: Perm_alg A} : forall a b,
  joins a b -> joins b a.

Lemma pfull_pmaximal {A} {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A} : full = maximal.

Lemma psub_joins {A}  {JA: Join A} {PA: Perm_alg A} {Pos_A: Pos_alg A}{DA: Disj_alg A} : forall a b,
  join_sub a b -> joins a b -> False.
End DISCRETE.

Set Implicit Arguments.

Section PSA_LIFT.
  Variable A : Type.
  Variable J_A: Join A.
  Variable PA_A : Perm_alg A.
  
  Definition lifted : Type := sig nonunit.
  
  Definition lifted_obj (la: lifted) : A := proj1_sig la.

  Coercion lifted_obj : lifted >-> A.
  Definition mk_lifted (a : A) (pf : nonunit a) : lifted :=
    exist nonunit a pf.

  Lemma lifted_eq : forall a b, 
    lifted_obj a = lifted_obj b -> 
    a = b.

  Lemma mk_lifted_refl1: forall (a:A)  (pf1 pf2: nonunit a),
    mk_lifted pf1 = mk_lifted pf2.

  Lemma lifted_pjoins : forall a b : lifted,
    joins a b = @joins A J_A a b.
  
  Lemma lifted_psub : forall a b : lifted, 
    join_sub a b -> @join_sub A J_A a b.  

  Lemma lifted_full {CA: Canc_alg A} : forall a : lifted,
    @full A J_A a -> full a.    

End SA_LOWER.
Arguments Perm_lower _ [Pj_A][PA_A].
Arguments Sep_lower _ [Pj_A].
Arguments Sing_lower _ [Pj_A].
Arguments Canc_lower _ [Pj_A][psa_A][CA] _ _ _ _ _ _.
Arguments Disj_lower _ [Pj_A][PA_A][psa_A][DA] _ _ _.

Existing Instance Join_lower.  
Existing Instance Perm_lower.
Existing Instance Sep_lower.
Existing Instance Sing_lower.
Existing Instance Canc_lower.
Existing Instance Disj_lower.

Lemma None_unit {A}{JOIN: Join A}: 
      forall x: option A, @unit_for (option A) (@Join_lower _ _) None x.

Hint Resolve @None_unit.

Lemma None_identity {A} {JA: Join A}{psaA: Pos_alg A}: 
     @identity (option A) (Join_lower _) None.

Hint Resolve @None_identity.

  Lemma lower_inv: forall {A}{JA: Join A} {PA: Perm_alg A} {psa_A: Pos_alg A} (a b c : option A),
    join a b c ->
    (a = None /\ b = c) + (a = c /\ b = None) + 
    ({a' : A & {b' : A & {c' : A | a = Some a' /\ b = Some b' /\ c = Some c' /\
    join a' b' c'}}}).

Section SA_SMASH.
  Variable T : Type.
  Variable J_T: Join T.
  Variable PA_T : Perm_alg T. 

  Definition smashed : Type := option (lifted J_T).
  Definition Perm_smash :  Perm_alg smashed  := Perm_lower (lifted J_T). 
  Definition Sep_smash : Sep_alg smashed := Sep_lower (lifted J_T).

  Lemma smash_inv: forall a b c : smashed,
    join a b c ->
    (a = None /\ b = c) + (a = c /\ b = None) + 
    ({a' : lifted J_T & {b' : lifted J_T & {c' : lifted J_T | a = Some a' /\ b = Some b' /\ c = Some c' /\
    join (lifted_obj a') (lifted_obj b') (lifted_obj c')}}}).
End SA_SMASH.

Arguments smashed _  [J_T].
Existing Instance Perm_smash. 
Existing Instance Sep_smash. 

Lemma smashed_lifted_None_identity {A}`{Perm_alg A}:
  @identity (smashed A) _ None.

Section FinitePartialMap.
  Variable A:Type.
  Variable dec_A : EqDec A.

  Variable B:Type.
  Variable PJ_B: Join B.
  Variable Perm_B : Perm_alg B.
  Variable Pos_B : Pos_alg B.

  Let Rng := option B.
  Let Join_Rng := Join_lower PJ_B.
  Let Sep_Rng := Sep_lower B.
  Let Perm_Rng := Perm_lower B. 

  Definition finMap (f:A -> Rng) : Prop :=
    exists l, forall a:A, ~In a l -> f a = None.

  Lemma finMap_unit : forall x e,
    finMap x -> @unit_for _ (Join_fun A _ Join_Rng) e x -> finMap e.

  Lemma finMap_join : forall x y z,
    @join _ (Join_fun A _ Join_Rng) x y z -> finMap x -> finMap y -> finMap z.

  Definition fpm := sig finMap.
  Instance Join_fpm : Join fpm := 
     Join_prop (A -> option B)  (Join_fun A (option B) Join_Rng) finMap.

  Definition PAF: (@Perm_alg (A -> Rng)  (Join_fun A Rng Join_Rng))
  := Perm_fun _ _ _ Perm_Rng.

  Instance Perm_fpm : @Perm_alg fpm Join_fpm :=
    Perm_prop (A -> Rng) _ _ finMap finMap_join.

  Lemma finMap_core  x: finMap x -> 
        finMap (@core _ _ (Sep_fun A (option B) Join_Rng _ ) x).

  Definition empty_fpm : fpm.

  Definition lookup_fpm (f:fpm) : A -> Rng := proj1_sig f.

  Definition insert_fpm (a:A) (b: B) (f:fpm) : fpm.

   Definition insert'_fpm (a:A)(b: option B) (f: fpm) : fpm.

  Definition remove_fpm (a:A) (f:fpm) : fpm.

  Lemma fpm_gss: forall  i v rho, 
        lookup_fpm (insert_fpm i v rho) i = Some v.

  Lemma fpm_gso: forall i j v rho, 
       i <> j -> lookup_fpm (insert_fpm j v rho) i =
                               lookup_fpm rho i.

  Lemma empty_fpm_join : forall x,
    @join _ Join_fpm empty_fpm x x.

  Lemma insert_fpm_join : forall i v (x y z:fpm),
    lookup_fpm y i = None ->
    @join _ Join_fpm x y z ->
    @join _ Join_fpm (insert_fpm i v x) y (insert_fpm i v z).
End FinitePartialMap.

Lemma fpm_bij_aux: forall A B B' (f: B -> B') (rho: A -> option B), 
       @finMap A B rho -> 
       @finMap A B' (fun i => match rho i with None => None | Some j => Some (f j) end).
Definition fpm_bij (A B B': Type) (bij: bijection B B') : bijection (fpm A B) (fpm A B').

Lemma lift_prod_aux1 {A}{JA: Join A}{B}:
  forall x,   @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x -> nonunit (fst x).

Definition lift_prod1  {A}{JA: Join A}{B} : (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) -> (@lifted A _ * B).

Lemma lift_prod_aux2 {A}{JA: Join A}{B}: 
  forall x,
    nonunit (fst x) -> @nonunit (A * B) (Join_prod A JA B (Join_equiv B)) x.

Definition lift_prod2  {A}{JA: Join A}{B} :(@lifted A _ * B) -> (@lifted (A * B) (Join_prod A _ B (Join_equiv B))).

Definition lift_prod_bij: forall A (JA: Join A) B,
     bijection  (@lifted (A * B) (Join_prod A _ B (Join_equiv B))) (@lifted A _ * B). *)

Require Import VST.msl.pshares.
(* VST.msl.pshares:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.
Require Import VST.msl.psepalg.
Require Import VST.msl.eq_dec.
Require Import VST.msl.shares.

Definition pshare : Type := lifted Share.Join_ba.
Instance Join_pshare: Join pshare := @Join_lift _ _.
Instance Perm_pshare : Perm_alg pshare := Perm_lift Share.pa.
Instance Canc_pshare : Canc_alg pshare := @Canc_lift _ _ Share.ca.
Instance Disj_pshare : Disj_alg pshare := @Disj_lift _ _ Share.da.
Instance Pos_pshare : Pos_alg pshare := @Pos_lift _ _.

Definition pshare_sh : pshare -> share := @lifted_obj share Share.Join_ba.
Coercion pshare_sh : pshare >-> share.

Lemma pshare_eq_dec: forall sh1 sh2: pshare, {sh1=sh2}+{sh1<>sh2}.

Instance EqDec_pshare : EqDec pshare := pshare_eq_dec.

Definition pfullshare : pshare :=
  mk_lifted fullshare top_share_nonunit.

Lemma pfullshare_pfull : full pfullshare.

Lemma join_sub_pfullshare: forall (p: pshare),
  @join_sub share Share.Join_ba pfullshare p ->

Lemma pjoin_sub_pfullshare: forall (p : pshare),
  join_sub pfullshare p -> False.

Lemma pshare_join_full_false1 : forall (p:pshare),
   joins pfullshare p -> False.

Lemma pshare_join_full_false2 : forall (p:pshare),
   joins p pfullshare -> False.

Lemma pshare_join_full_false3: forall (p1: pshare) sh3,
  join (lifted_obj p1) Share.top sh3 -> False.

Lemma pshare_join_full_false4: forall (p1: pshare) sh3,
  join Share.top (lifted_obj p1) sh3 -> False.

Lemma pshare_pjoin_full_false3: forall (p1: pshare) pp sh3,
   join p1 (mk_lifted Share.top pp) sh3 -> False.

Lemma pshare_pjoin_full_false4: forall (p1: pshare) pp sh3,
   join (mk_lifted Share.top pp) p1 sh3 -> False.

Ltac pfullshare_join :=
  elimtype False;
  solve [ eapply pshare_join_full_false1; eauto
    | eapply pshare_join_full_false2; eauto
    | eapply pshare_join_full_false3; eauto
    | eapply pshare_join_full_false4; eauto
    | eapply pshare_pjoin_full_false3; eauto
    | eapply pshare_pjoin_full_false4; eauto
  ].

Program Definition split_pshare (sh: pshare) : pshare * pshare :=
  (mk_lifted (fst (Share.split sh)) _, mk_lifted (snd (Share.split sh)) _).

Lemma psplit_split: forall psh psha pshb,
  (split_pshare psh = (psha, pshb)) =
  (Share.split (lifted_obj psh) = (lifted_obj psha, lifted_obj pshb)).

Lemma psplit_pjoin: forall psh psha pshb,
  split_pshare psh = (psha, pshb) ->
   join psha pshb psh.

Lemma pshare_split_neq1: forall psh psh1 psh2, split_pshare psh = (psh1, psh2) -> psh1 <> psh.

Lemma pshare_split_neq2: forall psh psh1 psh2, split_pshare psh = (psh1, psh2) -> psh2 <> psh.

Definition pLhalf : pshare := fst (split_pshare pfullshare).
Definition pRhalf : pshare := snd (split_pshare pfullshare).

Lemma pleftright :  join pLhalf pRhalf pfullshare.

Lemma pshare_nonunit: forall sh: pshare, nonunit (pshare_sh sh).

Lemma pshare_not_identity: forall sh: pshare, ~ identity (pshare_sh sh). *)

Require Import VST.msl.eq_dec.
(* VST.msl.eq_dec:
Require Import VST.msl.base.

Class EqDec (A : Type) : Type :=
  eq_dec : forall a a' : A, {a = a'} + {a <> a'}.

Instance EqDec_nat : EqDec nat := eq_nat_dec.

Definition upd {A} `{EqDec A} (B : Type) (f : A -> B) (a : A) (b : B) : A -> B :=
  fun a' => if eq_dec a a' then b else f a'.
Arguments upd [A H B] _ _ _ _.

Lemma upd_eq {A} `{EqDec A} : forall B (f : A -> B) a b,
  upd f a b a = b.
Arguments upd_eq [A H B] _ _ _.

Lemma upd_eq' {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a = a' ->
  upd f a b a' = b.
Arguments upd_eq' [A H B] _ _ _ _ _.

Lemma upd_neq {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a <> a' ->
  upd f a b a' = f a'. *)



Require VST.msl.predicates_sa.



Lemma in_app:   

  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Proof.

  intros. split; intro. apply in_app_or. auto. apply in_or_app. auto.

Qed.



Definition list_disjoint {A: Type} (l1 l2: list A) : Prop :=   

  forall (x y: A), In x l1 -> In y l2 -> x <> y.



Inductive pshareval_join' {A}{JA: Join A}

  : option (pshare * A) ->  option (pshare * A) ->  option (pshare * A) -> Prop :=

  | pshareval_None1: forall x, pshareval_join' None x x

  | pshareval_None2: forall x, pshareval_join' x None x

  | pshareval_Some: forall x y z,

      join (fst x) (fst y) (fst z) ->

      join (snd x) (snd y) (snd z) ->

      pshareval_join' (Some x) (Some y) (Some z).



Lemma pshareval_join_e{A}{JA: Join A}:  forall a b c, join a b c -> pshareval_join' a b c.

Proof.

intros.

inv H; [constructor 1 | constructor 2 | constructor 3]; auto.

apply H0.

apply H0.

Qed.



Lemma pshareval_join_i{A}{JA: Join A}: forall a b c, pshareval_join' a b c -> join a b c.

Proof.

intros.

inv H; [constructor 1 | constructor 2 | constructor 3]; auto.

split; auto.

Qed.



Module Type ENV.



Parameter env: forall (key: Type) (A: Type), Type.



Section ENVSEC.

Context {key: Type}{A: Type}.



Instance JA: Join A := Join_equiv A. 


Parameter env_get: forall (rho: env key A) (id: key), option (pshare * A).

Parameter env_set_sh: forall {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env key A), env key A.



Definition env_set  {KE: EqDec key} (id: key) (v: A) (rho: env key A) : env key A :=

     env_set_sh id (Some (pfullshare, v)) rho.



Axiom env_gss: forall {KE: EqDec key}  i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).

Axiom env_gso: forall {KE: EqDec key}  i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.



Axiom env_gss_sh: forall {KE: EqDec key} i v rho,

  env_get (env_set_sh i v rho) i = v.



Axiom env_gso_sh: forall {KE: EqDec key} i j v rho, i <> j ->

   env_get (env_set_sh j v rho) i = env_get rho i.



Definition finite_idfun (f: key -> option (pshare * A)) :=

  exists l, forall a, ~In a l -> f a = None.



Parameter mk_env:  forall (f: key -> option (pshare * A)), finite_idfun f -> env key A.



Axiom env_get_mk_env:  forall (f: key -> option (pshare * A)) P, env_get (mk_env f P) = f.



Axiom env_finite: forall rho, finite_idfun (env_get rho).



Axiom env_ext: forall rho1 rho2, env_get rho1 = env_get rho2 -> rho1=rho2.



Axiom env_funct: forall rho1 rho2,

  rho1 = rho2 -> forall id sh1 sh2 v1 v2, env_get rho1 id = Some(sh1, v1)

  -> env_get rho2 id = Some(sh2, v2)

  -> v1 = v2.



Parameter empty_env : env key A.



Axiom env_get_empty: forall id, env_get empty_env id = None.



Instance Join_env: Join (env key A) :=

    fun (rho1 rho2 rho3: env key A) => join (env_get rho1) (env_get rho2) (env_get rho3).

Parameter Perm_env: forall {PA: Perm_alg A}, Perm_alg (env key A).  Existing Instance Perm_env.



Instance Sep_env {SA: Sep_alg A}: Sep_alg (env key A).

 refine (mkSep Join_env (fun _ => empty_env) _ _).

 repeat intro; rewrite env_get_empty; constructor.

 auto.

Defined.



Instance Sing_env  {SA: Sep_alg A} : Sing_alg (env key A).

  refine (mkSing empty_env _). reflexivity.

Defined.



Parameter Canc_env: forall {PA: Perm_alg A}{CA: Canc_alg A}, Canc_alg (env key A). Existing Instance Canc_env.

Parameter Disj_env: forall {PA: Perm_alg A}{DA: Disj_alg A}, Disj_alg (env key A).   Existing Instance Disj_env.

Parameter Cross_env : Cross_alg (env key A).  Existing Instance Cross_env.



Import VST.msl.predicates_sa.



Parameter _env_mapsto: forall {KE: EqDec key}  (id: key) (sh: Share.t) (v: A), pred (env key A).



Axiom _env_mapsto_exists: forall {KE: EqDec key}  id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.



Axiom _env_get_mapsto: forall {KE: EqDec key}  id v rho,

  (exists sh, env_get rho id = Some (sh,v)) =

  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.



Axiom _env_get_mapsto': forall {KE: EqDec key}  id (sh: pshare) v rho,

  env_get rho id = Some(pfullshare,v) ->

       (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.



Axiom _env_mapsto_set: forall {KE: EqDec key} id v,

  _env_mapsto id Share.top v (env_set id v empty_env).



Axiom _env_mapsto_set_sh: forall {KE: EqDec key} id (sh: pshare) v,

  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh, v)) empty_env).



Axiom _env_mapsto_get: forall {KE: EqDec key}  id sh v rho,

  _env_mapsto id sh v rho

   -> exists Pf,

        env_get rho id = Some (exist nonunit sh Pf, v).



Axiom _env_mapsto_get_neq: forall {KE: EqDec key}  (id1 id2: key) (sh: Share.t) (v: A) rho,

  id1 <> id2 -> _env_mapsto id1 sh v rho -> env_get rho id2 = None.



Axiom _env_mapsto_empty_env: forall {KE: EqDec key}  id v sh, ~(_env_mapsto id sh v empty_env).



Axiom _env_mapsto_splittable: forall {KE: EqDec key}  id v (sh sh1 sh2: pshare) rho,

  join sh1 sh2 sh

  -> (_env_mapsto id (pshare_sh sh) v rho

        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho).

End ENVSEC.



End ENV.



Module Env: ENV.



Section ENVSEC.

Context {key: Type}{A: Type}.

Instance JA: Join A := Join_equiv A.



Definition env := fpm key (pshare * A).



Definition env_get (rho: env) (id: key) : option (pshare * A) := lookup_fpm rho id.



Definition env_set_sh {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env) : env :=

  insert'_fpm _ id v rho.



Definition env_set {KE: EqDec key} (id: key) (v: A) (rho: env) : env :=

  insert_fpm _ id (pfullshare,v) rho.



Lemma env_gss {KE: EqDec key} : forall i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).

Proof.

intros.

apply fpm_gss.

Qed.



Lemma env_gso {KE: EqDec key}: forall i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.

Proof.

intros.

apply fpm_gso; auto.

Qed.



Lemma env_gss_sh {KE: EqDec key}: forall i v rho, env_get (env_set_sh i v rho) i = v.

Proof.

  intros. unfold env_get, env_set_sh.

  unfold lookup_fpm, insert'_fpm; simpl. destruct rho as [f Hf]. simpl.

  destruct (eq_dec i i); auto. contradiction n; auto.

Qed.



Lemma env_gso_sh {KE: EqDec key} : forall i j v rho, i <> j -> env_get (env_set_sh j v rho) i = env_get rho i.

Proof.

  intros. unfold env_get, env_set_sh.

  unfold lookup_fpm, insert'_fpm; simpl. destruct rho as [f Hf]. simpl.

  destruct (eq_dec j i); auto.

  subst; contradiction H; auto.

Qed.



Definition finite_idfun (f: key -> option (pshare * A)) :=

          (exists l, forall a, ~In a l -> f a = None).



Definition mk_env_aux: forall f, finite_idfun f -> finMap f.

Proof.

intros.

unfold finMap.

destruct H as  [l ?].

exists l.

intros.

unfold compose; simpl.

rewrite H; auto.

Qed.



Definition mk_env (f: key -> option (pshare * A))  (FIN: finite_idfun f):  env :=

   exist _ _ (mk_env_aux _ FIN).



Lemma env_get_mk_env: forall (f: key -> option (pshare * A)) P, env_get (mk_env f P) = f.

Proof.

intros.

unfold mk_env, env_get.

simpl.

unfold compose.

extensionality id; auto.

Qed.



Lemma env_finite: forall rho, finite_idfun (env_get rho).

intros.

destruct rho.

unfold finite_idfun, finMap in *.

generalize f; intros [l ?].

exists l; simpl in *.

intros; unfold compose in *.

apply e; auto.

Qed.



Lemma env_ext: forall rho1 rho2, env_get rho1 = env_get rho2 -> rho1=rho2.

Proof.

intros.

destruct rho1; destruct rho2; simpl in *.

apply exist_ext.

unfold env_get in *.

simpl in *.

extensionality id.

generalize (equal_f  H id); intro.

destruct (x id); destruct (x0 id); inv H0; auto.

Qed.



Lemma env_funct: forall rho1 rho2,

  rho1 = rho2 -> forall id sh1 sh2 v1 v2, env_get rho1 id = Some(sh1, v1)

  -> env_get rho2 id = Some(sh2, v2)

  -> v1 = v2.

Proof.

  intros rho1 rho2 H id sh1 sh2 v1 v2 H1 H2.

  destruct rho1; destruct rho2; unfold env_get in *; simpl in *.

  inversion H; subst x0. inv H. congruence.

Qed.



Lemma finite_idfun_empty: finite_idfun (fun _ => None).

Proof.

exists nil.

auto.

Qed.



Definition empty_env : env := mk_env _ finite_idfun_empty.



Lemma env_get_empty: forall id, env_get empty_env id = None.

Proof.

intros.

unfold empty_env. rewrite env_get_mk_env; auto.

Qed.



Instance Join_env: Join env :=

    fun (rho1 rho2 rho3: env) => join (env_get rho1) (env_get rho2) (env_get rho3).



Lemma Join_env_eq: Join_env = Join_fpm (Join_prod _ Join_pshare _ JA).

Proof.

  repeat intro.

 extensionality rho1 rho2 rho3;

destruct rho1 as [rho1 V1]; destruct rho2 as [rho2 V2]; destruct rho3 as [rho3 V3].

unfold Join_env, Join_fpm; simpl.

apply prop_ext; split; intros H id; specialize ( H id);

unfold env_get in * ; simpl in *; clear - H;

destruct (rho1 id) as [[[sh1 v1] n1]| ];

destruct (rho2 id) as [[[sh2 v2] n2]| ];

destruct (rho3 id) as [[[sh3 v3] n3]| ];

inv H; simpl in *;  try constructor; auto.

rewrite (proof_irr v1 v3); constructor.

rewrite (proof_irr v2 v3); constructor.

rewrite (proof_irr v1 v3); constructor.

rewrite (proof_irr v2 v3); constructor.

Qed.



Instance Perm_env {PA: Perm_alg A}: @Perm_alg env Join_env.

Proof.

  rewrite Join_env_eq. apply Perm_fpm; auto with typeclass_instances.

Qed.



Instance Sep_env {SA: Sep_alg A}: @Sep_alg env Join_env.

 refine (mkSep Join_env (fun _ => empty_env) _ _).

 repeat intro; rewrite env_get_empty; constructor.

 auto.

Defined.



Instance Sing_env {SA: Sep_alg A}: @Sing_alg env Join_env Sep_env.

  refine (mkSing empty_env _). reflexivity.

Defined.



Instance Canc_env {PA: Perm_alg A}{CA: Canc_alg A}: @Canc_alg env Join_env.

Proof.   rewrite Join_env_eq. apply Canc_fpm; auto with typeclass_instances.

Qed.



Instance Disj_env {PA: Perm_alg A}{DA: Disj_alg A}: @Disj_alg env Join_env.

Proof.   rewrite Join_env_eq. apply Disj_fpm; auto with typeclass_instances.

Qed.



Instance Cross_env: Cross_alg env.

Proof.

 rewrite Join_env_eq.

 unfold env.

 pose (bij := @fpm_bij key _ _ (@lift_prod_bij share _ A)).

 pose (J := @Join_fpm key _ (@Join_lift _ (Join_prod share _ _ JA))).

 unfold pshare.

 replace

  (@Join_fpm key (@lifted Share.t Share.Join_ba * A)

     (Join_prod (@lifted Share.t Share.Join_ba) Join_pshare A

        JA))

  with (Join_bij

       (fpm key

          (@lifted (share * A)

             (Join_prod share Share.Join_ba A JA))) _

       (fpm key (@lifted share Share.Join_ba * A)) bij).

 apply (Cross_bij _ _ _ bij).

 apply cross_split_fpm; auto with typeclass_instances.

 intros [sh v]. destruct (dec_share_identity sh); [left | right].

 apply identity_unit_equiv in i. apply identity_unit_equiv. split; auto.

 contradict n.

 apply identity_unit_equiv in n. apply identity_unit_equiv. destruct n; auto.

 extensionality x y z.

 unfold J, bij; clear J bij.

 apply forall_ext; intro i.

 unfold finMap; simpl.

 change  (@proj1_sig (key -> option (@lifted Share.t Share.Join_ba * A))

     (fun f : key -> option (@lifted Share.t Share.Join_ba * A) =>

      exists l : list key,

        forall a : key,

        ~ @In key a l -> f a = @None (@lifted Share.t Share.Join_ba * A)))

  with (@proj1_sig (key -> option (@lifted share Share.Join_ba * A))

      (@finMap key (@lifted share Share.Join_ba * A))).

 set  (xi := proj1_sig x i); clearbody xi.

 set (yi:= proj1_sig y i); clearbody yi.

 set (zi:= proj1_sig z i); clearbody zi.

 clear.

 destruct xi; destruct yi; destruct zi;

 apply prop_ext; split; intro; inv H; try constructor.

 destruct p as [[x Hx] x']. destruct p0 as [[y Hy] y']. destruct p1 as [[z Hz] z'].

  simpl in *. inv H3; simpl in *. split; auto.

 destruct p as [[x Hx] x']. destruct p0 as [[y Hy] y']. destruct p1 as [[z Hz] z'].

  simpl in *. inv H3; simpl in *. split; auto.

 destruct p as [[x Hx] x']. destruct p0 as [[z Hz] z'].

 simpl in H1. inv H1. apply join_unit2; auto.

 repeat f_equal; apply proof_irr.

 destruct p as [[x Hx] x']. destruct p0 as [[z Hz] z'].

 simpl in H0. inv H0. apply join_unit1; auto.

 repeat f_equal; apply proof_irr.

Qed.



Import VST.msl.predicates_sa.



Definition _env_mapsto {KE: EqDec key} (id: key) (sh: Share.t) (v: A) : pred env :=

    fun rho => exists p,

   forall id', env_get rho id' = if eq_dec id id' then Some (exist _ sh p,v) else None.



Lemma _env_mapsto_exists{KE: EqDec key}: forall id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.

Proof.

intros.

assert (finite_idfun (fun id' => if eq_dec id id' then Some (sh, v) else None)).

exists (id::nil).

intros.

simpl in H.

intuition.

destruct (eq_dec id a); try contradiction; auto.

exists (mk_env _ H).

unfold _env_mapsto.

destruct sh; simpl in *.

exists n.

intros.

auto.

Qed.



Lemma _env_get_mapsto {KE: EqDec key}:  forall (id: key) (v: A) (rho: env),

  (exists sh, env_get rho id = Some (sh,v)) =

  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Proof.

intros.

apply prop_ext; split; intros.

destruct H as [sh ?].

destruct (_env_mapsto_exists id sh v) as [rho1 ?].

exists rho1.

assert (finite_idfun (fun id' => if eq_dec id id' then None else env_get rho id')).

destruct (env_finite rho) as [l ?].

exists l.

intros.

destruct (eq_dec id a); auto.

exists (mk_env _ H1).

split.

simpl.

intro x.

rewrite env_get_mk_env.

intros.

destruct H0.

rename x into id0.

specialize ( H0 id0).

destruct (eq_dec id id0).

subst.

rewrite H; rewrite H0.

destruct sh; simpl in *.

rewrite (proof_irr x0 n); constructor.

rewrite H0.

constructor.

split.

exists (pshare_sh sh).

auto.

auto.

destruct H as [?w [?w [? [[sh ?] _]]]].

destruct H0.

specialize ( H0 id).

destruct (eq_dec id id); try congruence.

specialize ( H id).

rewrite H0 in H.

inv H.

econstructor; eauto.

destruct a2; destruct a3; destruct H4 as [? [? ?]]; simpl in *; subst.

econstructor; eauto.

Qed.



Lemma _env_get_mapsto'  {KE: EqDec key}: forall id (sh: pshare) v rho,

  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Proof.

intros.

destruct (top_correct' (pshare_sh sh)) as [sh2 ?].

assert (finite_idfun (fun i => if eq_dec i id then Some (sh,v) else None)).

exists (id::nil); intros. simpl in H1.

assert (id <> a) by intuition.

destruct (eq_dec a id); auto. contradiction H2; auto.

destruct (dec_share_identity sh2).

assert (finite_idfun (fun i => if eq_dec i id then None else env_get rho i)).

destruct (env_finite rho) as [l ?].

exists l; intros. destruct (eq_dec a id); auto.

exists (mk_env _ H1); exists (mk_env _ H2); split; [|split]; auto.

intro i'.

do 2 rewrite env_get_mk_env.

destruct (eq_dec i' id).

subst. rewrite H.

apply join_comm in H0.

apply i in H0.

destruct sh; simpl in *.

subst.

rewrite (proof_irr n top_share_nonunit).

constructor.

constructor.

exists (proj2_sig sh).

intros.

rewrite env_get_mk_env.

destruct (eq_dec id' id).

subst. destruct (eq_dec id id); try congruence.

f_equal. f_equal. destruct sh; simpl. auto.

destruct (eq_dec id' id); try contradiction; auto.

destruct (eq_dec id id'); try contradiction; auto.

contradiction n; auto.

assert (finite_idfun (fun i => if eq_dec i id then Some(mk_lifted sh2 (nonidentity_nonunit n), v) else env_get rho i)).

destruct (env_finite rho) as [l ?].

exists l; intros. destruct (eq_dec a id); auto.

subst.

specialize ( H2 id H3).

rewrite H in H2; inv H2.

exists (mk_env _ H1); exists (mk_env _ H2); split; [|split]; auto.

intro i'.

do 2 rewrite env_get_mk_env.

destruct (eq_dec i' id).

subst. rewrite H.

constructor; simpl; auto.

constructor; simpl; auto.

apply join_equiv_refl.

constructor.

exists (proj2_sig sh).

intros.

rewrite env_get_mk_env.

destruct (eq_dec id' id).

subst. destruct (eq_dec id id); try contradiction n0; auto.

f_equal. f_equal. destruct sh; simpl.  auto.

destruct (eq_dec id id'); auto. contradiction n0; auto.

Qed.



Lemma _env_mapsto_set{KE: EqDec key}: forall id v,

  _env_mapsto id Share.top v (env_set id v empty_env).

Proof.

  intros id v.

  exists top_share_nonunit.

  intros id'.

  destruct (eq_dec id id') as [Hid|].

    rewrite <- Hid.

    rewrite env_gss; auto.

    rewrite env_gso; auto.

Qed.



Lemma _env_mapsto_set_sh{KE: EqDec key}: forall id (sh: pshare) v,

  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Proof.

  intros id [sh Pf] v.

  exists Pf.

  intros id'.

  destruct (eq_dec id id') as [Hid|].

    rewrite <- Hid.

    rewrite env_gss_sh; auto.

    rewrite env_gso_sh; auto.

Qed.



Lemma _env_mapsto_get{KE: EqDec key}: forall id sh v rho,

  _env_mapsto id sh v rho

   -> exists Pf: nonunit sh,

        env_get rho id = Some (exist nonunit sh Pf, v).

Proof.

  unfold _env_mapsto, env_get.

  intros id sh v rho [p H1].

  specialize ( H1 id); simpl in *.

  destruct (eq_dec id id); firstorder.

Qed.



Lemma _env_mapsto_empty_env {KE: EqDec key} : forall id v sh,

  ~(_env_mapsto id sh v empty_env).

Proof.

  unfold not, _env_mapsto.

  intros ? ? ? [p H].

  specialize ( H id).

  destruct (eq_dec id id); auto.

  inversion H.

Qed.



Lemma _env_mapsto_get_neq {KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

  id1 <> id2 -> _env_mapsto id1 sh v rho -> env_get rho id2 = None.

Proof.

  unfold _env_mapsto.

  intros id1 id2 sh v rho Hneq [p H1].

  specialize ( H1 id2).

  destruct (eq_dec id1 id2); try contradiction ;auto.

Qed.



Lemma _env_mapsto_splittable1 {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,

  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)

  -> (_env_mapsto id  (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho

  -> _env_mapsto id (pshare_sh sh) v rho.

Proof.

  intros id v sh sh1 sh2 rho H1 H2.

  destruct H2 as [rho1 [rho2 [Hrho_join [[Pf1 H_env_mapsto1] [Pf2 H_env_mapsto2]]]]].

  exists (proj2_sig sh); intro id'.

  specialize ( H_env_mapsto1 id'); specialize ( H_env_mapsto2 id').

  generalize Hrho_join; clear Hrho_join; unfold join; simpl; intros Hrho_join.

  specialize ( Hrho_join id').

  rewrite H_env_mapsto1 in Hrho_join; rewrite H_env_mapsto2 in Hrho_join.

  destruct (eq_dec id id').



  inversion Hrho_join; simpl in *; subst.

  destruct a3; destruct H3 as [? [? ?]]; simpl in *; subst.

  apply (f_equal (fun x => Some(x, a))).

  apply lifted_eq.

  eapply join_eq; eauto.



  inversion Hrho_join; auto.

Qed.



Lemma _env_mapsto_splittable2{KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,

  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)

  -> _env_mapsto id (pshare_sh sh) v rho

  -> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho.

Proof.

  intros id v sh sh1 sh2 rho Hjoin H.

  destruct H as [? H0].

  exists (env_set_sh id (Some (sh1,v)) empty_env); exists (env_set_sh id (Some(sh2,v)) empty_env).

  split.



  intros id'.

  specialize ( H0 id'); rewrite H0.

  destruct (eq_dec id id') as [Hid_id'_eq | Hid_id'_neq].



  subst id'.

  do 2 rewrite env_gss_sh. constructor.

  constructor; auto.

  apply join_equiv_refl.



  rewrite (env_gso_sh); auto.

  rewrite (env_gso_sh); auto.

  rewrite env_get_empty. constructor.



  destruct sh1 as [sh1 n1]; destruct sh2 as [sh2 n2];  unfold _env_mapsto; split.

  exists n1; reflexivity.

  exists n2; reflexivity.

Qed.



Lemma _env_mapsto_splittable {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,

  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)

  -> (_env_mapsto id (pshare_sh sh) v rho

        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

Proof.

  intros.

  split; intros.

  eapply _env_mapsto_splittable2; eauto.

  eapply _env_mapsto_splittable1; eauto.

Qed.



End ENVSEC.

End Env.

Export Env.



Module EnvSA.



Existing Instance Join_env.

Existing Instance Perm_env.

Existing Instance Sep_env.

Existing Instance Sing_env.

Existing Instance Canc_env.

Existing Instance Disj_env.

Existing Instance Cross_env.



Lemma empty_env_unit {key: Type}{A: Type}:

    forall rho: env key A, unit_for empty_env rho.

Proof.

intro; intros.

unfold unit_for.

intro.

rewrite env_get_empty.

constructor.

Qed.



Lemma empty_env_unit' {key: Type}{A: Type}: forall rho: env key A, join empty_env rho rho.

Proof.

intros; apply empty_env_unit.

Qed.

Hint Resolve @empty_env_unit @empty_env_unit'.



Lemma env_join_sub1 {key: Type}{A: Type}:

  forall rho1 rho2: env key A, (forall id x, env_get rho1 id = Some x -> env_get rho2 id = Some x) ->

     join_sub rho1 rho2.

Proof.

intros.

pose (JA := Join_equiv A).

assert (forall i: key, cjoin_sub (env_get rho1 i) (env_get rho2 i)).



intro.

case_eq (env_get rho1 i); intros.

specialize (H _ _ H0).

exists None. rewrite H. constructor.

econstructor; constructor.

assert (finite_idfun (fun i => proj1_sig (X i))).

destruct (env_finite rho2) as [l ?].

exists l; intros.

specialize (H0 _ H1).

generalize (X a); intro.

destruct c.

simpl.

rewrite H0 in j; inv j; auto.

exists (mk_env _ H0).

intro i.

rewrite env_get_mk_env.

destruct (X i).

simpl.

auto.

Qed.



Lemma env_get_join_sub {key: Type}{A: Type}: forall (rho rho': env key A) id sh v,

   join_sub rho rho' -> env_get rho id = Some (sh,v) ->

     exists sh', env_get rho' id = Some (sh', v) /\ join_sub (pshare_sh sh)  (pshare_sh sh').

Proof.

intros.

destruct H.

specialize ( H id).

rewrite H0 in H.

clear H0 rho.

destruct sh as [sh n].

destruct (env_get rho' id) as [[[sh' n'] v'] |]; [|inv H].

revert H;

destruct (env_get x id) as [[[shx nx] vx] | ]; intro H; inv H.

simpl in *.

destruct H3 as [? [? ?]]; simpl in *; subst.

econstructor; split; eauto. econstructor; eauto.

econstructor; split; eauto.

simpl. apply join_sub_refl.

Qed.



Lemma env_at_joins {key: Type}{A: Type}{KE: EqDec key}:

  forall rho1 rho2: env key A,

         (forall id, @joins _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) ->

               joins rho1 rho2.

Proof.

intros.

unfold joins in H.

pose (share_of rho id := match @env_get key A rho id with

                                       | None => Share.bot

                                       | Some (p,v) => pshare_sh p

                                       end).

assert (forall id, joins (share_of rho1 id) (share_of rho2 id)).

intros.

destruct (H id) as [x H0].

clear - H0.

unfold share_of.

inv H0.

apply bot_joins.

rewrite joins_sym.

apply bot_joins.

destruct a1; destruct a2; destruct a3; destruct H2 as [? [? ?]]; simpl in *. subst. eauto.

pose (h id := proj1_sig (share_joins_constructive _ _ (H0 id))).

pose (g sh (v: A) := match dec_share_identity sh with

                         | left _ => None

                         | right p => Some (mk_lifted _ (nonidentity_nonunit p), v)

                         end).

pose (f id := match env_get rho1 id, env_get rho2 id with

                     | None, shv => shv

                     | shv, None => shv

                     | Some (_,v), _ => g (h id) v

                      end).

assert (finite_idfun f).

destruct (env_finite rho1) as [l1 ?].

destruct (env_finite rho2) as [l2 ?].

exists (l1++l2).

intros.

rewrite in_app in H3.

destruct (In_dec eq_dec a l1) as [H3' | H3'].

contradiction H3; auto.

assert (H4: ~In a l2) by intuition.

specialize ( H1 a H3'). specialize ( H2 a H4).

unfold f.

rewrite H1; rewrite H2; auto.

exists (mk_env _ H1).

intro id.

rewrite env_get_mk_env.

unfold f; clear H1 f.

unfold g, h; clear g h.

destruct (share_joins_constructive (share_of rho1 id) (share_of rho2 id) (H0 id)).

simpl.

specialize ( H id). destruct H as [c ?].

unfold share_of in *; clear share_of.

specialize ( H0 id).

destruct (env_get rho1 id) as [[sh1 v1]|];

destruct (env_get rho2 id) as [[sh2 v2]|];

try solve [constructor].

inv H.

destruct a3; destruct H3 as [? [? ?]].  simpl in H,H1,H2; subst.

destruct (dec_share_identity x).

generalize (split_identity _ _ j i); intro.

elimtype False; clear - H1.

revert H1; apply nonunit_nonidentity.

apply pshare_nonunit.

constructor; auto. constructor; auto. simpl. apply join_equiv_refl.

Qed.



Lemma env_at_join_sub {key: Type}{A: Type}{KE: EqDec key}:

  forall rho1 rho2, (forall id: key, @join_sub _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) -> join_sub rho1 rho2.

Proof.

intros.

unfold join_sub in H.

pose (share_of rho id := match @env_get key A rho id with

                                       | None => Share.bot

                                       | Some (p,v) => pshare_sh p

                                       end).

assert (forall id, join_sub (share_of rho1 id) (share_of rho2 id)).

intros.

specialize (H id); destruct H.

unfold share_of.

inv H.

apply bot_correct'.

apply join_sub_refl.

destruct a1; destruct a2; destruct a3; destruct H3 as [? [? ?]]; simpl in *. subst.

econstructor; eauto.

pose (h id := proj1_sig (share_join_sub_constructive _ _ (H0 id))).

pose (g sh (v: A) := match dec_share_identity sh with

                         | left _ => None

                         | right p => Some (mk_lifted _ (nonidentity_nonunit p), v)

                         end).

pose (f id := match env_get rho2 id with

                     | None => None

                     | Some (_,v) => g (h id) v

                      end).

assert (finite_idfun f).

destruct (env_finite rho2) as [l2 ?].

exists l2.

intros.

unfold f. rewrite H1; auto.

exists (mk_env _ H1).

intro id.

rewrite env_get_mk_env.

unfold f; clear H1 f.

unfold g, h; clear g h.

destruct (share_join_sub_constructive (share_of rho1 id) (share_of rho2 id) (H0 id)).

simpl.

specialize ( H id). destruct H as [c ?].

unfold share_of in *; clear share_of.

specialize ( H0 id).

destruct (env_get rho1 id) as [[sh1 v1]|];

destruct (env_get rho2 id) as [[sh2 v2]|].

inv H.

destruct (dec_share_identity x).

constructor.

contradiction n.

apply unit_identity with (pshare_sh sh2); apply join_comm; auto.

destruct H4 as [? [? ?]]; simpl snd in *; subst.

generalize (join_canc (join_comm j) (join_comm H)); intro; subst.

destruct (dec_share_identity (lifted_obj (fst a2))).

contradiction (@nonunit_nonidentity _ _ _ _ (lifted_obj (fst a2))).

destruct (fst a2); simpl; auto.

destruct a2; simpl in *. destruct p; simpl in *.

constructor; simpl; auto.

constructor; auto.

simpl. apply join_equiv_refl.

inv H.

apply bot_identity in j.

subst.

destruct (dec_share_identity (pshare_sh sh2)).

contradiction (@nonunit_nonidentity _ _ _ _ (pshare_sh sh2)).

apply pshare_nonunit.

apply join_unit1; auto.

f_equal. f_equal. unfold mk_lifted; destruct sh2; simpl. f_equal. apply proof_irr.

constructor.

Qed.



Lemma identity_empty_env {key: Type}{A: Type}{KE: EqDec key}:  forall rho: env key A, identity rho <-> rho = empty_env.

Proof.

intros.

split; intros.

generalize (identity_unit (a:=empty_env)H); intro.

spec H0.

exists rho; apply join_comm; apply empty_env_unit.

generalize (empty_env_unit rho); intro.

unfold unit_for in *.

generalize (join_eq H0 (join_comm H1)); intro; auto.

subst.

simpl.

apply unit_identity with empty_env; auto.

Qed.



End EnvSA.



Module EnvSL.

Import EnvSA.

Import VST.msl.predicates_sa.



Definition env_mapsto: forall {key A}{KE: EqDec key} (id: key) (sh: Share.t) (v: A) , pred (env key A) := @_env_mapsto.

Arguments env_mapsto [key] [A] [KE] _ _ _ _.



Lemma env_mapsto_exists{key A}{KE: EqDec key}: forall id sh (v: A), exists rho, _env_mapsto id (pshare_sh sh) v rho.

Proof. apply _env_mapsto_exists. Qed.



Lemma env_get_mapsto {key A}{KE: EqDec key}:  forall (id: key) (v: A) (rho: env _ _),

  (exists sh, env_get rho id = Some (sh,v)) =

  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Proof. apply _env_get_mapsto. Qed.



Lemma env_get_mapsto'  {key A}{KE: EqDec key}: forall id (sh: pshare) (v: A) rho,

  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Proof. apply _env_get_mapsto'. Qed.



Lemma env_mapsto_set {key A}{KE: EqDec key}: forall id (v: A),

    env_mapsto id Share.top v (env_set id v empty_env).

Proof. apply _env_mapsto_set. Qed.



Lemma env_mapsto_set_sh{key A}{KE: EqDec key}: forall id (sh: pshare) (v: A),

  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Proof. apply _env_mapsto_set_sh. Qed.



Lemma env_mapsto_get{key A}{KE: EqDec key}: forall id sh (v:A) rho,

  env_mapsto id sh v rho

   -> exists Pf: nonunit sh,

        env_get rho id = Some (exist nonunit sh Pf, v).

Proof. apply _env_mapsto_get. Qed.



Lemma env_mapsto_empty_env {key A}{KE: EqDec key} : forall id (v:A) sh,

  ~(env_mapsto id sh v empty_env).

  Proof. apply _env_mapsto_empty_env. Qed.



Lemma env_mapsto_get_neq {key A}{KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

  id1 <> id2 -> env_mapsto id1 sh v rho -> env_get rho id2 = None.

Proof. apply _env_mapsto_get_neq. Qed.



Lemma env_mapsto_splittable {key A}{KE: EqDec key}: forall id (v:A) (sh sh1 sh2: pshare) rho,

  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)

  -> (_env_mapsto id (pshare_sh sh) v rho

        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

Proof. apply _env_mapsto_splittable. Qed.



Lemma env_mapsto_positive{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v: A) rho,

  env_mapsto id sh v rho -> nonidentity sh.

Proof.

  intros until rho.

  intro H; apply env_mapsto_get in H; destruct H.

  auto.

  apply nonunit_nonidentity; auto.

Qed.



Lemma emp_empty_env {key: Type}{A: Type}:  forall rho: env key A, emp rho <-> rho = empty_env.

Proof.

intros.

split; intros.

generalize (identity_unit (a:=empty_env)H); intro.

spec H0.

exists rho; apply join_comm; apply empty_env_unit.

generalize (empty_env_unit rho); intro.

unfold unit_for in *.

generalize (join_eq H0 (join_comm H1)); intro; auto.

subst.

simpl.

apply unit_identity with empty_env; auto.

Qed.



Lemma emp_empty_env' {key}{A}: emp (@empty_env key A).

Proof.

rewrite emp_empty_env.

auto.

Qed.

Hint Resolve @emp_empty_env'.



Lemma env_mapsto_cohere{key: Type}{A: Type}{KE: EqDec key}: forall id sh1 (v1: A) sh2 v2,

  (env_mapsto id sh1 v1 * TT) && (env_mapsto id sh2 v2 * TT)

    |-- !!(v1=v2).

Proof.

  intros.

  intros w [? ?].

  unfold prop.

  destruct H as [?w [?w [? [? _]]]].

  destruct H0 as [?w [?w [? [? _]]]].

  apply env_mapsto_get in H1; destruct H1.

  apply env_mapsto_get in H2; destruct H2.

  destruct (env_get_join_sub _ _ _ _ _ (join_join_sub H) H1) as [sh' [? ?]].

  destruct (env_get_join_sub _ _ _ _ _ (join_join_sub H0) H2) as [sh'' [? ?]].

  congruence.

Qed.



Lemma env_mapsto_precise{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v:A), precise (env_mapsto id sh v).

Proof.

  intros; intro; intros.

  apply env_ext.

  extensionality id'.

  destruct (eq_dec id id'); auto; subst.

    apply env_mapsto_get in H; destruct H.

    apply env_mapsto_get in H0; destruct H0.

    rewrite H; rewrite H0.

    repeat f_equal; auto. apply proof_irr.



    eapply env_mapsto_get_neq in H; eauto.

    eapply env_mapsto_get_neq in H0; eauto.

    rewrite H; rewrite H0; auto.

Qed.



Definition own_var {key: Type}{A: Type}{KE: EqDec key} (sh: pshare) (id: key) : pred (env key A) :=

  exp (env_mapsto id (pshare_sh sh)).



Definition see_var {key: Type}{A: Type}{KE: EqDec key} (id: key) : pred (env key A) :=

  exp (fun sh: pshare => own_var sh id).



Definition own_all {key: Type}{A: Type}{KE: EqDec key} (l: list key) : pred (env key A) :=

   list_sepcon (map (own_var pfullshare) l).



Lemma own_all_nil {key: Type}{A: Type}{KE: EqDec key} : own_all nil = (emp: pred (env key A)).

Proof. unfold own_all; simpl; auto. Qed.



Opaque env_mapsto.

End EnvSL.



Definition restrict_env' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=

  if  In_dec eq_dec id ids

                      then env_get rho id

                      else None.



Lemma restrict_env'_finite {key: Type}{A: Type}{KE: EqDec key} : forall ids (rho: env key A), finite_idfun (restrict_env' ids rho).

Proof.

unfold finite_idfun, restrict_env'; intros.

exists ids.

intros.

destruct (in_dec eq_dec a ids); try contradiction; auto.

Qed.



Definition restrict_env {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A :=

  mk_env _ (restrict_env'_finite ids rho).



Definition restrict_env_comp' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=

  if  In_dec eq_dec id ids

                      then None

                      else env_get rho id.



Lemma restrict_env_comp'_finite {key: Type}{A: Type}{KE: EqDec key}:

    forall ids (rho: env key A), finite_idfun (restrict_env_comp' ids rho).

Proof.

unfold finite_idfun, restrict_env_comp'; intros.

destruct (env_finite rho) as [l ?].

exists l.

intros.

destruct (in_dec eq_dec a ids); try contradiction; auto.

Qed.



Definition restrict_env_comp  {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A:=

  mk_env _ (restrict_env_comp'_finite ids rho).



Lemma restrict_env_nil  {key: Type}{A: Type}{KE: EqDec key}:

  forall ge, restrict_env nil ge = (empty_env: env key A).

Proof.

intros.

apply env_ext. extensionality id.

unfold restrict_env; rewrite env_get_mk_env; unfold restrict_env'; simpl.

rewrite env_get_empty.

auto.

Qed.



Lemma restrict_env_app  {key: Type}{A: Type}{KE: EqDec key} :

  forall ids1 ids2 (rho: env key A),  list_disjoint ids1 ids2 ->

    join (restrict_env ids1 rho) (restrict_env ids2 rho) (restrict_env (ids1++ids2) rho).

Proof.

intros.

intro id.

unfold restrict_env; simpl.

repeat rewrite env_get_mk_env.

unfold restrict_env'.

unfold list_disjoint in H.

specialize ( H id id).

destruct (in_dec eq_dec id ids1).

destruct (in_dec eq_dec id ids2).

contradiction H; auto.

destruct (in_dec eq_dec id (ids1++ids2)).

constructor.

contradiction n0;

rewrite in_app; auto.

destruct (in_dec eq_dec id ids2).

destruct (in_dec eq_dec id (ids1++ids2)).

constructor.

contradiction n0;

rewrite in_app; auto.

destruct (in_dec eq_dec id (ids1++ids2)).

rewrite in_app in i; intuition.

constructor.

Qed.



Lemma restrict_env_comp_join {key: Type}{A: Type}{KE: EqDec key}:

  forall ids (ge: env key A), join (restrict_env ids ge) (restrict_env_comp ids ge) ge.

Proof.

intros.

intro id.

unfold restrict_env, restrict_env_comp.

repeat rewrite env_get_mk_env.

unfold restrict_env', restrict_env_comp'.

destruct (in_dec eq_dec id ids); constructor.

Qed.



Lemma restrict_env_rev {key: Type}{A: Type}{KE: EqDec key}:

    forall ids, @restrict_env key A _ (rev ids) = restrict_env ids.

Proof.

intros.

extensionality w.

unfold restrict_env.

apply env_ext; extensionality id.

repeat rewrite env_get_mk_env.

unfold restrict_env'.

destruct (in_dec eq_dec id (rev ids));

destruct (in_dec eq_dec id ids); auto.

rewrite <- In_rev in i; contradiction.

rewrite In_rev in i; contradiction.

Qed.



Instance Trip_pshareval {B} : @Trip_alg (option (pshare * B)) (Join_lower (Join_prod _ _ _ (Join_equiv B))).

Proof.

intro; intros.

apply pshareval_join_e in H.

apply pshareval_join_e in H0.

apply pshareval_join_e in H1.

destruct a as [[[sa pa] va]|];

destruct b as [[[sb pb] vb]|];

destruct ab as [[[sab pab] vab]|]; try solve [elimtype False; inv H];

destruct c as [[[sc pc] vc]|];

destruct bc as [[[sbc pbc] vbc]|]; try solve [elimtype False; inv H0];

destruct ac as [[[sac pac] vac]|]; try solve [elimtype False; inv H1];

simpl in *;

try (assert (Hx: join sa sb sab /\ va = vb /\ vb = vab)

     by (inv H; simpl in *; intuition;

            match goal with H: @join B _ _ _ _ |- _ => destruct H end;

             congruence);

    decompose [and] Hx; clear H Hx; subst vab);

try (assert (Hx: join sb sc sbc /\ vb = vc /\ vb = vbc)

    by (inv H0; simpl in *; intuition;

            match goal with H: @join B _ _ _ _ |- _ => destruct H end;

             congruence);

    decompose [and] Hx; clear H0 Hx; subst vbc);

try (assert (Hx: join sa sc sac /\ va = vc /\ va = vac)

    by (inv H1; simpl in *; intuition;

            match goal with H: @join B _ _ _ _ |- _ => destruct H end;

             congruence);

    decompose [and] Hx; clear H1 Hx; subst vac);

subst; subst;

try solve [econstructor; constructor].

destruct (triple_join_exists_share _ _ _ _ _ _ H2 H H0) as [sabc ?].

assert (nonidentity sabc). eapply join_nonidentity. apply nonunit_nonidentity; apply pab. eauto.

exists (Some (mk_lifted _ (nonidentity_nonunit H1), vc)).

constructor; split; simpl; auto.

exists (Some (mk_lifted _ pac, vbc)); econstructor; simpl; auto.

inv H0. inv H. constructor; auto.

exists (Some (mk_lifted _ pbc, vac)); inv H1; inv H; constructor; simpl; auto.

constructor; auto.

Qed.



Instance Trip_env {A} {EA: EqDec A} {B} {JB: Join B}: Trip_alg (env A B).

Proof.

intro; intros.

pose (f id := Trip_pshareval _ _ _ _ _ _ (H id) (H0 id) (H1 id)).

assert (finite_idfun (fun id => proj1_sig (f id))).

destruct (env_finite ab) as [l1 H3].

destruct (env_finite c) as [l2 H4].

exists (l1++l2).

intro id; specialize ( H3 id); specialize ( H4 id).

intro.

assert (~ (In id l1 \/ In id l2)).

contradict H2.

rewrite in_app. auto.

clear H2.

destruct (In_dec eq_dec id l1) as [H5' | H5'].

contradiction H5; auto.

assert (H6: ~In id l2) by intuition.

destruct (f id).

simpl.

apply pshareval_join_e in j.

rewrite H3 in j; rewrite H4 in j; inv j; auto.

exists (mk_env (fun id => proj1_sig (f id)) H2).

intro id.

rewrite env_get_mk_env.

destruct (f id); simpl.

auto.

Qed.

