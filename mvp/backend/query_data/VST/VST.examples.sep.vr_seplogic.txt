Require Import language.

Require Import msl.msl_direct.
(* msl.msl_direct:
Require Export VST.msl.Extensionality.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.sepalg.
Require Export VST.msl.predicates_sa.
Require Export VST.msl.corable_direct.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.corec.
Require Export VST.msl.eq_dec. *)

Require Import msl.env.
(* msl.env:
Require Import VST.msl.base.
Require Import VST.msl.boolean_alg.
Require Import VST.msl.sepalg.
Require Import VST.msl.functors.
Require Import VST.msl.sepalg_functors.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.shares.
Require Import VST.msl.cross_split.
Require Import VST.msl.psepalg.
Require Import VST.msl.pshares.
Require Import VST.msl.eq_dec.

Require VST.msl.predicates_sa.

Lemma in_app:   
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Definition list_disjoint {A: Type} (l1 l2: list A) : Prop :=   
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Inductive pshareval_join' {A}{JA: Join A}
  : option (pshare * A) ->  option (pshare * A) ->  option (pshare * A) -> Prop :=
  | pshareval_None1: forall x, pshareval_join' None x x
  | pshareval_None2: forall x, pshareval_join' x None x
  | pshareval_Some: forall x y z,
      join (fst x) (fst y) (fst z) ->
      join (snd x) (snd y) (snd z) ->
      pshareval_join' (Some x) (Some y) (Some z).

Lemma pshareval_join_e{A}{JA: Join A}:  forall a b c, join a b c -> pshareval_join' a b c.

Lemma pshareval_join_i{A}{JA: Join A}: forall a b c, pshareval_join' a b c -> join a b c.

Module Type ENV.

Parameter env: forall (key: Type) (A: Type), Type.

Section ENVSEC.
Context {key: Type}{A: Type}.

Instance JA: Join A := Join_equiv A. 
Parameter env_get: forall (rho: env key A) (id: key), option (pshare * A).
Parameter env_set_sh: forall {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env key A), env key A.

Definition env_set  {KE: EqDec key} (id: key) (v: A) (rho: env key A) : env key A :=
     env_set_sh id (Some (pfullshare, v)) rho.

Axiom env_gss: forall {KE: EqDec key}  i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).
Axiom env_gso: forall {KE: EqDec key}  i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.

Axiom env_gss_sh: forall {KE: EqDec key} i v rho,
  env_get (env_set_sh i v rho) i = v.

Axiom env_gso_sh: forall {KE: EqDec key} i j v rho, i <> j ->
   env_get (env_set_sh j v rho) i = env_get rho i.

Definition finite_idfun (f: key -> option (pshare * A)) :=
  exists l, forall a, ~In a l -> f a = None.

Parameter Canc_env: forall {PA: Perm_alg A}{CA: Canc_alg A}, Canc_alg (env key A). Existing Instance Canc_env.
Parameter Disj_env: forall {PA: Perm_alg A}{DA: Disj_alg A}, Disj_alg (env key A).   Existing Instance Disj_env.
Parameter Cross_env : Cross_alg (env key A).  Existing Instance Cross_env.

Import VST.msl.predicates_sa.

Parameter _env_mapsto: forall {KE: EqDec key}  (id: key) (sh: Share.t) (v: A), pred (env key A).

Axiom _env_mapsto_exists: forall {KE: EqDec key}  id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.

Axiom _env_get_mapsto: forall {KE: EqDec key}  id v rho,
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Axiom _env_get_mapsto': forall {KE: EqDec key}  id (sh: pshare) v rho,
  env_get rho id = Some(pfullshare,v) ->
       (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Axiom _env_mapsto_set: forall {KE: EqDec key} id v,
  _env_mapsto id Share.top v (env_set id v empty_env).

Axiom _env_mapsto_set_sh: forall {KE: EqDec key} id (sh: pshare) v,
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh, v)) empty_env).

Axiom _env_mapsto_get: forall {KE: EqDec key}  id sh v rho,
  _env_mapsto id sh v rho
   -> exists Pf,
        env_get rho id = Some (exist nonunit sh Pf, v).

Axiom _env_mapsto_get_neq: forall {KE: EqDec key}  (id1 id2: key) (sh: Share.t) (v: A) rho,
  id1 <> id2 -> _env_mapsto id1 sh v rho -> env_get rho id2 = None.

Axiom _env_mapsto_empty_env: forall {KE: EqDec key}  id v sh, ~(_env_mapsto id sh v empty_env).

Axiom _env_mapsto_splittable: forall {KE: EqDec key}  id v (sh sh1 sh2: pshare) rho,
  join sh1 sh2 sh
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho).
End ENVSEC.

End ENV.

Module Env: ENV.

Section ENVSEC.
Context {key: Type}{A: Type}.
Instance JA: Join A := Join_equiv A.

Definition env := fpm key (pshare * A).

Definition env_get (rho: env) (id: key) : option (pshare * A) := lookup_fpm rho id.

Definition env_set_sh {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env) : env :=
  insert'_fpm _ id v rho.

Definition env_set {KE: EqDec key} (id: key) (v: A) (rho: env) : env :=
  insert_fpm _ id (pfullshare,v) rho.

Lemma env_gss {KE: EqDec key} : forall i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).

Lemma env_gso {KE: EqDec key}: forall i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.

Lemma env_gss_sh {KE: EqDec key}: forall i v rho, env_get (env_set_sh i v rho) i = v.

Lemma env_gso_sh {KE: EqDec key} : forall i j v rho, i <> j -> env_get (env_set_sh j v rho) i = env_get rho i.

Definition finite_idfun (f: key -> option (pshare * A)) :=
          (exists l, forall a, ~In a l -> f a = None).

Definition mk_env_aux: forall f, finite_idfun f -> finMap f.

Definition mk_env (f: key -> option (pshare * A))  (FIN: finite_idfun f):  env :=
   exist _ _ (mk_env_aux _ FIN).

Lemma env_get_mk_env: forall (f: key -> option (pshare * A)) P, env_get (mk_env f P) = f.

Lemma env_finite: forall rho, finite_idfun (env_get rho).

Lemma env_ext: forall rho1 rho2, env_get rho1 = env_get rho2 -> rho1=rho2.

Lemma env_funct: forall rho1 rho2,
  rho1 = rho2 -> forall id sh1 sh2 v1 v2, env_get rho1 id = Some(sh1, v1)
  -> env_get rho2 id = Some(sh2, v2)
  -> v1 = v2.

Lemma finite_idfun_empty: finite_idfun (fun _ => None).

Definition empty_env : env := mk_env _ finite_idfun_empty.

Lemma env_get_empty: forall id, env_get empty_env id = None.

Instance Join_env: Join env :=
    fun (rho1 rho2 rho3: env) => join (env_get rho1) (env_get rho2) (env_get rho3).

Lemma Join_env_eq: Join_env = Join_fpm (Join_prod _ Join_pshare _ JA).

Import VST.msl.predicates_sa.

Definition _env_mapsto {KE: EqDec key} (id: key) (sh: Share.t) (v: A) : pred env :=
    fun rho => exists p,
   forall id', env_get rho id' = if eq_dec id id' then Some (exist _ sh p,v) else None.

Lemma _env_mapsto_exists{KE: EqDec key}: forall id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.

Lemma _env_get_mapsto {KE: EqDec key}:  forall (id: key) (v: A) (rho: env),
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Lemma _env_get_mapsto'  {KE: EqDec key}: forall id (sh: pshare) v rho,
  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Lemma _env_mapsto_set{KE: EqDec key}: forall id v,
  _env_mapsto id Share.top v (env_set id v empty_env).

Lemma _env_mapsto_set_sh{KE: EqDec key}: forall id (sh: pshare) v,
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Lemma _env_mapsto_get{KE: EqDec key}: forall id sh v rho,
  _env_mapsto id sh v rho
   -> exists Pf: nonunit sh,
        env_get rho id = Some (exist nonunit sh Pf, v).

Lemma _env_mapsto_empty_env {KE: EqDec key} : forall id v sh,
  ~(_env_mapsto id sh v empty_env).

Lemma _env_mapsto_get_neq {KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

Lemma _env_mapsto_splittable1 {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id  (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho
  -> _env_mapsto id (pshare_sh sh) v rho.

Lemma _env_mapsto_splittable2{KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> _env_mapsto id (pshare_sh sh) v rho
  -> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho.

Lemma _env_mapsto_splittable {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

End ENVSEC.
End Env.
Export Env.

Module EnvSA.

Existing Instance Join_env.
Existing Instance Perm_env.
Existing Instance Sep_env.
Existing Instance Sing_env.
Existing Instance Canc_env.
Existing Instance Disj_env.
Existing Instance Cross_env.

Lemma empty_env_unit {key: Type}{A: Type}:
    forall rho: env key A, unit_for empty_env rho.

Lemma empty_env_unit' {key: Type}{A: Type}: forall rho: env key A, join empty_env rho rho.
Hint Resolve @empty_env_unit @empty_env_unit'.

Lemma env_join_sub1 {key: Type}{A: Type}:
  forall rho1 rho2: env key A, (forall id x, env_get rho1 id = Some x -> env_get rho2 id = Some x) ->
     join_sub rho1 rho2.

Lemma env_get_join_sub {key: Type}{A: Type}: forall (rho rho': env key A) id sh v,
   join_sub rho rho' -> env_get rho id = Some (sh,v) ->
     exists sh', env_get rho' id = Some (sh', v) /\ join_sub (pshare_sh sh)  (pshare_sh sh').

Lemma env_at_joins {key: Type}{A: Type}{KE: EqDec key}:
  forall rho1 rho2: env key A,
         (forall id, @joins _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) ->
               joins rho1 rho2.

Lemma env_at_join_sub {key: Type}{A: Type}{KE: EqDec key}:
  forall rho1 rho2, (forall id: key, @join_sub _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) -> join_sub rho1 rho2.

Lemma identity_empty_env {key: Type}{A: Type}{KE: EqDec key}:  forall rho: env key A, identity rho <-> rho = empty_env.

End EnvSA.

Module EnvSL.
Import EnvSA.
Import VST.msl.predicates_sa.

Definition env_mapsto: forall {key A}{KE: EqDec key} (id: key) (sh: Share.t) (v: A) , pred (env key A) := @_env_mapsto.
Arguments env_mapsto [key] [A] [KE] _ _ _ _.

Lemma env_mapsto_exists{key A}{KE: EqDec key}: forall id sh (v: A), exists rho, _env_mapsto id (pshare_sh sh) v rho.

Lemma env_get_mapsto {key A}{KE: EqDec key}:  forall (id: key) (v: A) (rho: env _ _),
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Lemma env_get_mapsto'  {key A}{KE: EqDec key}: forall id (sh: pshare) (v: A) rho,
  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Lemma env_mapsto_set {key A}{KE: EqDec key}: forall id (v: A),
    env_mapsto id Share.top v (env_set id v empty_env).

Lemma env_mapsto_set_sh{key A}{KE: EqDec key}: forall id (sh: pshare) (v: A),
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Lemma env_mapsto_get{key A}{KE: EqDec key}: forall id sh (v:A) rho,
  env_mapsto id sh v rho
   -> exists Pf: nonunit sh,
        env_get rho id = Some (exist nonunit sh Pf, v).

Lemma env_mapsto_empty_env {key A}{KE: EqDec key} : forall id (v:A) sh,
  ~(env_mapsto id sh v empty_env).

Lemma env_mapsto_get_neq {key A}{KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

Lemma env_mapsto_splittable {key A}{KE: EqDec key}: forall id (v:A) (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

Lemma env_mapsto_positive{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v: A) rho,
  env_mapsto id sh v rho -> nonidentity sh.

Lemma emp_empty_env {key: Type}{A: Type}:  forall rho: env key A, emp rho <-> rho = empty_env.

Lemma emp_empty_env' {key}{A}: emp (@empty_env key A).
Hint Resolve @emp_empty_env'.

Lemma env_mapsto_cohere{key: Type}{A: Type}{KE: EqDec key}: forall id sh1 (v1: A) sh2 v2,
  (env_mapsto id sh1 v1 * TT) && (env_mapsto id sh2 v2 * TT)
    |-- !!(v1=v2).

Lemma env_mapsto_precise{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v:A), precise (env_mapsto id sh v).

Definition own_var {key: Type}{A: Type}{KE: EqDec key} (sh: pshare) (id: key) : pred (env key A) :=
  exp (env_mapsto id (pshare_sh sh)).

Definition see_var {key: Type}{A: Type}{KE: EqDec key} (id: key) : pred (env key A) :=
  exp (fun sh: pshare => own_var sh id).

Definition own_all {key: Type}{A: Type}{KE: EqDec key} (l: list key) : pred (env key A) :=
   list_sepcon (map (own_var pfullshare) l).

Lemma own_all_nil {key: Type}{A: Type}{KE: EqDec key} : own_all nil = (emp: pred (env key A)).

Opaque env_mapsto.
End EnvSL.

Definition restrict_env' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=
  if  In_dec eq_dec id ids
                      then env_get rho id
                      else None.

Lemma restrict_env'_finite {key: Type}{A: Type}{KE: EqDec key} : forall ids (rho: env key A), finite_idfun (restrict_env' ids rho).

Definition restrict_env {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A :=
  mk_env _ (restrict_env'_finite ids rho).

Definition restrict_env_comp' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=
  if  In_dec eq_dec id ids
                      then None
                      else env_get rho id.

Lemma restrict_env_comp'_finite {key: Type}{A: Type}{KE: EqDec key}:
    forall ids (rho: env key A), finite_idfun (restrict_env_comp' ids rho).

Definition restrict_env_comp  {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A:=
  mk_env _ (restrict_env_comp'_finite ids rho).

Lemma restrict_env_nil  {key: Type}{A: Type}{KE: EqDec key}:
  forall ge, restrict_env nil ge = (empty_env: env key A).

Lemma restrict_env_app  {key: Type}{A: Type}{KE: EqDec key} :
  forall ids1 ids2 (rho: env key A),  list_disjoint ids1 ids2 ->
    join (restrict_env ids1 rho) (restrict_env ids2 rho) (restrict_env (ids1++ids2) rho).

Lemma restrict_env_comp_join {key: Type}{A: Type}{KE: EqDec key}:
  forall ids (ge: env key A), join (restrict_env ids ge) (restrict_env_comp ids ge) ge.

Lemma restrict_env_rev {key: Type}{A: Type}{KE: EqDec key}:
    forall ids, @restrict_env key A _ (rev ids) = restrict_env ids. *)



Import EnvSA EnvSL.



Definition world := (env var adr * env adr adr)%type.



Instance Join_world: Join world := _.

Instance Perm_world : Perm_alg world := _.

Instance Sep_world : Perm_alg world := _.

Instance Canc_world : Perm_alg world := _.

Instance Disj_world : Perm_alg world := _.



Fixpoint den_env {key}{A}{KE: EqDec key} (rho: table key A)  : env key A :=

  match rho with

  | (x,v)::xs => env_set x v (den_env xs)

  | nil => empty_env

  end.



Definition den (s: state) : world := (den_env (fst s), den_env (snd s)).



Definition world_op (P: pred (env var adr)) (Q: pred (env adr adr)) : pred world :=

    fun w => P (fst w) /\ Q (snd w).



Notation "'^stk' e" := (world_op e emp) (at level 30, no associativity): pred.

Notation "'^hp' e" := (world_op emp e) (at level 30, no associativity): pred.



Definition world_op_sepcon:

     forall P P' Q Q',

       (world_op P P' * world_op Q Q' = world_op (P*Q) (P'*Q'))%pred.

Proof.

 repeat intro.

 apply pred_ext.

 intros [s h] [[s1 h1] [[s2 h2] [[? ?] [[? ?] [? ?]]]]]; simpl in *.

 split.

 exists s1; exists s2; repeat split; auto.

 exists h1; exists h2; repeat split; auto.

 intros [s h] [[s1 [s2 [? [? ?]]]] [h1 [h2 [? [? ?]]]]].

 exists (s1,h1); exists (s2,h2); repeat split; auto.

Qed.



Definition eval_var (x: var) (y: adr) : pred world :=

   (EX sh: share, (^stk env_mapsto x sh y) * TT)%pred.



Notation "x '=#' v" := (eval_var x v) (at level 25, no associativity): pred.



Definition defined (x: var) : pred world := (EX v:adr, x =# v)%pred.



Definition subst (x: var) (v: option (pshare * adr)) (P: pred world) : pred world :=

   fun w => P (env_set_sh x v (fst w), snd w).



Inductive modvars : command -> var -> Prop :=

| mod_assign: forall x y, modvars (Assign x y) x

| mod_load: forall x y, modvars (Load x y) x

| mod_seq1: forall x c1 c2, modvars c1 x -> modvars (Seq c1 c2) x

| mod_seq2: forall x c1 c2, modvars c2 x -> modvars (Seq c1 c2) x.



Definition nonfreevars (P: pred world) (x: var) : Prop :=

  forall v, P |-- subst x v P.



Definition subset (S1 S2: var -> Prop) :=

  forall x, S1 x -> S2 x.



Definition semax (P: pred world) (c: command) (Q: pred world) : Prop :=

  forall F s,

    (P*F)%pred (den s) -> exists s', exec c s = Some s' /\ (Q*F)%pred (den s').



Lemma env_get_den {A B}{AE: EqDec A}:  forall s (y: A) sh (v: B), env_get (den_env s) y = Some (sh,v) ->

             table_get s y = Some v /\ sh = pfullshare.

Proof.

Admitted.



Lemma eval_var_get: forall s x v, (x =# v)%pred s ->

     exists sh, env_get (fst s) x = Some (sh,v).

Admitted.



Definition own (x: var) : pred world := (^stk (own_var pfullshare x) * TT) %pred.



Lemma env_get_own:

  forall x s, (own x * TT)%pred s -> exists v, env_get (fst s) x = Some (pfullshare, v).

Admitted.



Lemma semax_assign: forall P x y v,

      semax (y =# v && (own x * TT) && subst x (Some(pfullshare, v)) P) (Assign x y) P.

Proof.

  intros.  intros F s H.

  destruct H as [[stk1 hp1] [[stk2 hp2] [? [[[? OWN] ?] ?]]]].

  simpl in *.

  destruct H as [H H']. simpl in H,H'.

  exists (table_set x v (fst s), snd s).

   assert (H0': (y =# v)%pred (den s)).

   admit.  

   apply eval_var_get in H0'.

   destruct H0' as [sh ?].

  destruct s as [s h]. simpl in *.

  apply env_get_den in H3. destruct H3; subst sh.

  change nat with var in H3. rewrite H3.

  simpl. split; auto.

  unfold subst in H1. simpl in H1.

  unfold den; simpl.

  econstructor; econstructor; repeat split; try apply H1; try apply H2; simpl; auto.

  intro i. specialize (H i).

  destruct (eq_dec i x). subst.  rewrite env_gss. rewrite env_gss_sh.

  apply env_get_own in OWN; destruct OWN as [v' OWN]. simpl in OWN.

  change nat with var in OWN.

  rewrite OWN in H.

  inv H; try pfullshare_join. constructor.

  rewrite env_gso; auto. rewrite env_gso_sh; auto.

Qed.



Lemma semax_load: forall x y p v v0 sh sh',

       semax (^stk env_mapsto x Share.top v0 * ^stk (env_mapsto y sh p) *

                    ^hp env_mapsto p sh' v)

                  (Load x y)

                  (^stk env_mapsto x Share.top v * ^stk (env_mapsto y sh p) *

                    ^hp env_mapsto p sh' v).

Proof.

 intros.

 repeat rewrite world_op_sepcon.

 repeat rewrite sepcon_emp; repeat rewrite emp_sepcon.

 hnf; intros.

 destruct s as [s h].

 exists (table_set x v s, h).

 unfold den in *; simpl in *.

 assert (table_get s y = Some p).

 admit.  

 assert (table_get h p = Some v).

 admit.  

 rewrite H0. simpl. rewrite H1. simpl. split; auto.

 rewrite <- (emp_sepcon (env_mapsto p sh' v)) in H|-*.

 rewrite <- @world_op_sepcon in H|-*.

 rewrite sepcon_assoc in H|-*.

 destruct H as [[s1 h1] [[s2 h2] [[? ?] [[? ?] ?]]]]; simpl in *.

 exists (env_set x v s1, h1).

 exists (s2,h2).

 repeat split; simpl; auto.

 intro i. specialize (H i). destruct (eq_dec i x).

 subst. repeat rewrite env_gss. apply env_mapsto_get in H3. destruct H3.

 change nat with var in H3; rewrite H3 in H.

 inv H; try pfullshare_join. constructor.

 repeat rewrite env_gso; auto.

 replace (env_set x v s1) with (env_set x v empty_env).

 apply env_mapsto_set.

 clear - H3.

 apply env_ext. extensionality i.

 destruct (eq_dec i x).

 subst; repeat rewrite env_gss. auto.

 subst; repeat rewrite env_gso; auto.

 rewrite env_get_empty.

 symmetry.

 eapply env_mapsto_get_neq; eauto.

Qed.



Lemma semax_store: forall x y p v v0 sh sh',

       semax (^stk env_mapsto x sh p * ^stk (env_mapsto y sh' v) *

                    ^hp env_mapsto p Share.top v0)

                  (Store x y)

                  (^stk env_mapsto x sh p * ^stk (env_mapsto y sh' v) *

                    ^hp env_mapsto p Share.top v).

Proof.

 intros. hnf; intros.

 exists (fst s, table_set p v (snd s)).

 destruct s as [s h].

 simpl.

 assert (table_get s y = Some v).

 admit. 

 assert (table_get s x = Some p).

 admit. 

 rewrite H0. simpl. rewrite H1. simpl. split; auto.

 rewrite sepcon_assoc in H|-*.

 rewrite <- (sepcon_comm F) in H|-*.

 rewrite <- sepcon_assoc in H|-*.

 destruct H as [[s1 h1] [[s2 h2] [[? ?] [? ?]]]].

 simpl in *.

 exists (s1,h1).

 exists (s2, env_set p v h2).

 split; [|split]; auto.

 split; auto. simpl.

 destruct H4 as [_ ?].

 clear - H2 H4.

 admit. 

 destruct H4; split; auto.

 simpl in *.

 clear - H5.

 replace (env_set p v h2) with (env_set p v empty_env).

 apply env_mapsto_set.

 apply env_ext. extensionality i.

 destruct (eq_dec i p).

 subst; repeat rewrite env_gss. auto.

 subst; repeat rewrite env_gso; auto.

 rewrite env_get_empty.

 symmetry.

 eapply env_mapsto_get_neq; eauto.

Qed.



Lemma semax_seq: forall P c1 Q c2 R,

  semax P c1 Q -> semax Q c2 R -> semax P (Seq c1 c2) R.

Proof.

 unfold semax; intros.

 destruct (H F s) as [s1 [? ?]]; auto.

 destruct (H0 F s1) as [s2 [? ?]]; auto.

 exists s2; split; auto.

 simpl. rewrite H2; simpl. auto.

Qed.



Lemma frame: forall F P c Q,

    semax P c Q -> semax (P * F) c (Q * F).

Proof.

 repeat intro.

 rewrite sepcon_assoc in H0|-*.

 apply H in H0. auto.

Qed.

