

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)



  Instance Join_unit : Join unit := fun x y z => True.



  Instance Perm_unit : Perm_alg unit.

  Proof.

  constructor; auto with typeclass_instances; try firstorder.

  destruct z; destruct z'; auto.

  destruct a; destruct b; auto.

  Qed.



  Instance Sep_unit: Sep_alg unit.

  Proof. apply mkSep with (fun _ => tt); intros;  hnf; auto with typeclass_instances. Qed.



  Instance Sing_unit: Sing_alg unit.

  Proof. apply (mkSing tt); intros; hnf; simpl.

        destruct (core a); destruct tt; auto.

 Qed.



  Instance Canc_unit: Canc_alg unit.

  Proof. repeat intro. auto. hnf; destruct a1; destruct a2; auto. Qed.



  Instance Disj_unit: Disj_alg unit.

  Proof. repeat intro. destruct a0, b0;  auto. Qed.



  Instance Cross_unit: Cross_alg unit.

  Proof. repeat intro. exists (tt,tt,tt,tt). repeat split; constructor. Qed.



  Inductive Void : Type :=.



  Instance Join_void : Join Void := fun x y z => False.



  Instance Perm_void : Perm_alg Void.

  Proof. constructor; intuition.  Qed.

  Instance Sep_void: Sep_alg Void.

  Proof. apply mkSep with (fun x => x); intros.

      auto with typeclass_instances. destruct t. destruct a.

  Qed.

  Instance Canc_void: Canc_alg Void.

  Proof. repeat intro. destruct b. Qed.

  Instance Disj_void: Disj_alg Void.

  Proof. repeat intro. destruct a. Qed.

  Instance Cross_void: Cross_alg Void.

  Proof. repeat intro. destruct z. Qed.



  Inductive join_bool : bool -> bool -> bool -> Prop :=

  | jb_fff: join_bool false false false

  | jb_tft: join_bool true false true

  | jb_ftt: join_bool false true true.



  Instance Join_bool : Join bool := join_bool.



  Instance Perm_bool: Perm_alg bool.

  Proof.

    constructor. auto with typeclass_instances.

    intros; inv H; inv H0; hnf; auto.

    repeat intro; hnf in *; subst; auto.

    intros. icase a; icase b; icase d; try solve [elimtype False; (inv H || inv H0)].

    exists c; inv H0; split; constructor.

    exists true; inv H0; split; constructor.

    exists c; inv H0; split; constructor.

    intros; inv H; constructor; auto.

    intros. inv H; inv H0; hnf; auto.

  Qed.



  Instance Sep_bool: Sep_alg bool.

  Proof. apply mkSep with (fun t => false); intros; hnf; auto with typeclass_instances.

     icase t; constructor.

  Defined.



  Instance Sing_bool: Sing_alg bool.

  Proof. apply (mkSing false). intros; simpl; reflexivity.

  Defined.



  Instance Canc_bool: Canc_alg bool.

  Proof. repeat intro. inv H; inv H0; hnf; auto. Qed.



  Instance Disj_bool: Disj_alg bool.

  Proof. repeat intro. inv H; inv H0; auto. Qed.



  Instance Cross_bool: Cross_alg bool.

  Proof. repeat intro.

     icase a; icase b; try solve [elimtype False; (try inv H; inv H0)];

    icase z; icase c; icase d; try solve [elimtype False; (try inv H; inv H0)].

     exists (true,false,false,false); repeat split; constructor.

     exists (false,true,false,false); repeat split; constructor.

     exists (false,false,true,false); repeat split; constructor.

     exists (false,false,false,true); repeat split; constructor.

     exists (false,false,false,false); repeat split; constructor.

  Qed.



Section JOIN_EQUIV.



  Instance Join_equiv (A: Type) : Join A := fun x y z => x=y/\y=z.



  Instance Perm_equiv (A: Type) :  @Perm_alg A (Join_equiv A).

  Proof. constructor; intros.

     destruct H; destruct H0; unfold equiv in *; subst; auto.

     destruct H; destruct H0; subst. exists e; split; split; auto.

     destruct H; split; subst; auto.

     destruct H; subst; reflexivity.

  Qed.



  Instance Sep_equiv (A: Type): Sep_alg A.

  Proof. apply mkSep with (fun a => a); intros.

            apply Perm_equiv.

            split; reflexivity.

            destruct H; subst; reflexivity.

  Defined.



  Instance Canc_equiv (A: Type): Canc_alg A.

  Proof. repeat intro. destruct H; destruct H0; subst; reflexivity. Qed.



  Instance Disj_equiv (A: Type): Disj_alg A.

  Proof. repeat intro. inv H0; auto. Qed.



  Instance Cross_equiv (A: Type): Cross_alg A.

  Proof. repeat intro. destruct H; destruct H0; subst.

   exists (z,z,z,z); repeat split; reflexivity.

  Qed.



Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.

Proof. split; auto. Qed.

End JOIN_EQUIV.



Existing Instance Perm_equiv.

Existing Instance Sep_equiv.

Existing Instance Canc_equiv.

Existing Instance Disj_equiv.

Existing Instance Cross_equiv.



Hint Extern 1 (@join _ _ _ _ _) =>

   match goal with |- @join _ (@Join_equiv _) _ _ _ => apply join_equiv_refl end.



Section SepAlgProp.

  Variable A:Type.

  Variable JOIN: Join A.

  Variable PA: Perm_alg A.

  Variable P:A -> Prop.



  Variable HPjoin : forall x y z, join x y z -> P x -> P y -> P z.



  Instance Join_prop : Join (sig P) :=

                 fun x y z: (sig P) => join (proj1_sig x) (proj1_sig y) (proj1_sig z).



  Instance Perm_prop : Perm_alg (sig P).

  Proof.

   constructor; intros.

    destruct z; destruct z'. apply exist_ext. do 2 red in H,H0; eapply join_eq; eauto.

    do 2 red in H,H0.

    destruct (join_assoc H H0) as [f [? ?]].

     assert (P f) by (apply (HPjoin _ _ _ H1); auto; apply proj2_sig; auto).

     exists (exist P f H3).

     split; auto.

     do 2 red in H; apply join_comm in H; auto.

     do 2 red in H,H0. simpl in H,H0.

     destruct a, b; simpl; apply exist_ext; eapply join_positivity; eauto.

 Qed.



  Instance Sep_prop (SA: Sep_alg A)(HPcore : forall x, P x -> P (core x)): Sep_alg (sig P).

  Proof. repeat intro.

     apply mkSep with (fun a : sig P => exist P (core (proj1_sig a)) (HPcore _ (proj2_sig a)));

      intros. apply Perm_prop.

      do 2 red. destruct t; simpl. apply join_comm; apply core_unit.

      apply exist_ext.

      do 2 red in H. apply join_core in H. apply H.

  Defined.



 Instance Sing_prop  (SA: Sep_alg A)(Sing_A: Sing_alg A)

               (HPcore : forall x, P x -> P (core x)): P the_unit ->

    @Sing_alg (sig P) Join_prop (Sep_prop _ HPcore).

 Proof. intros.

  apply (mkSing (exist P the_unit H)).

  intros. destruct a as  [a Ha]. simpl. apply exist_ext.

  rewrite <- (the_unit_core a).

  apply core_uniq.

 Defined.



  Instance Canc_prop  {CA: Canc_alg A}:  Canc_alg (sig P).

  Proof.

   intros [a Ha] [b Hb] [c1 Hc1] [c2 Hc2].

    unfold join, Join_prop; simpl; intros. apply exist_ext.

  eapply join_canc; eauto.

  Qed.



  Instance Disj_prop {DA: Disj_alg A}: Disj_alg (sig P).

  Proof. intros [a Ha][b Hb].

    unfold join, Join_prop; simpl; intros.

    intros [] [] Hj.

    eapply exist_ext, join_self; eauto.

  Qed.



End SepAlgProp.

Existing Instance Join_prop.

Existing Instance Perm_prop.

Existing Instance Sep_prop.

Existing Instance Sing_prop.

Existing Instance Canc_prop.

Existing Instance Disj_prop.



Section SepAlgFun.

  Variable key: Type.

  Variable t' : Type.

  Variable JOIN: Join t'.

  Variable Pt': Perm_alg t'.



  Instance Join_fun: Join (key -> t') :=

                  fun a b c : key -> t' => forall x, join (a x) (b x) (c x).



  Instance Perm_fun : Perm_alg (key -> t').

  Proof.

   constructor; intros.

   extensionality k.

   apply (join_eq (H k) (H0 k)).

  exists (fun x => projT1 (join_assoc (H x) (H0 x))).

  split; intro k; destruct (join_assoc (H k) (H0 k)) as [f [? ?]]; auto.

  intro k; apply join_comm; apply H.

  extensionality k; specialize (H k); specialize (H0 k).

  apply (join_positivity H H0).

 Qed.



  Instance Sep_fun (SA: Sep_alg t'): Sep_alg (key -> t').

  Proof. apply mkSep with (fun a k => core (a k)); intros.

   intro k; apply core_unit.

   extensionality k; apply @join_core with (b k); auto.

 Defined.



 Instance Sing_fun (SA: Sep_alg t'): Sing_alg t' -> Sing_alg (key -> t').

 Proof.

 intros. apply (mkSing (fun _: key => the_unit)).

 intro a; extensionality k.

 rewrite <- (the_unit_core (a k)).

  unfold core. simpl. auto.

 Defined.



 Instance Canc_fun: Canc_alg t' -> Canc_alg (key -> t').

 Proof. repeat intro. extensionality x; apply (join_canc (H0 x) (H1 x)). Qed.



 Instance Disj_fun: Disj_alg t' -> Disj_alg (key -> t').

 Proof.  repeat intro. extensionality x. eapply join_self; eauto. Qed.

End SepAlgFun.



Existing Instance Join_fun.

Existing Instance Perm_fun.

Existing Instance Sep_fun.

Existing Instance Sing_fun.

Existing Instance Canc_fun.

Existing Instance Disj_fun.



Section SepAlgPi.

  Variable I:Type.

  Variable Pi: I -> Type.

  Variable pi_J: forall i, Join (Pi i).

  Variable PA:  forall i, Perm_alg (Pi i).



  Let P := forall i:I, Pi i.



  Instance Join_pi: Join P := fun x y z => forall i:I, join (x i) (y i) (z i).



  Instance Perm_pi  : Perm_alg P.

  Proof.

   constructor; intros.

   extensionality i. apply (join_eq (H i) (H0 i)).

   exists (fun i => projT1 (join_assoc (H i) (H0 i))).

   split; intro i; destruct (join_assoc (H i) (H0 i)) as [f [? ?]]; auto.

   intro i; apply join_comm; auto.

   extensionality i. specialize (H i); specialize (H0 i).

   apply (join_positivity H H0).

 Qed.



  Instance Sep_pi (SA : forall i:I, Sep_alg (Pi i)): Sep_alg P.

  Proof. apply mkSep with (fun a i => core (a i)); intros.

   intro i; apply core_unit.

   extensionality i; apply @join_core with (b i); auto.

 Defined.



  Instance Canc_pi: (forall i, Canc_alg (Pi i)) -> Canc_alg P.

  Proof. repeat intro. extensionality i; apply (join_canc (H0 i) (H1 i)). Qed.



  Instance Disj_pi: (forall i, Disj_alg (Pi i)) -> Disj_alg P.

  Proof. repeat intro. extensionality i; apply (join_self (H0 i)); auto. Qed.



End SepAlgPi.

Existing Instance Join_pi.

Existing Instance Perm_pi.

Existing Instance Sep_pi.

Existing Instance Canc_pi.

Existing Instance Disj_pi.



Section SepAlgSigma.

  Variable I:Type.

  Variable Sigma: I -> Type.

  Variable JOIN: forall i, Join (Sigma i).

  Variable PA: forall i, Perm_alg (Sigma i).

  Let S := sigT Sigma.



  Inductive join_sigma : S -> S -> S -> Prop :=

    j_sig_def : forall (i:I) (a b c:Sigma i),

      join a b c ->

      join_sigma (existT Sigma i a) (existT Sigma i b) (existT Sigma i c).



  Instance Join_sigma: Join S := join_sigma.



  Instance Perm_sigma: Perm_alg S.

  Proof.  constructor; intros.



    destruct z as [z Hz]. destruct z' as [z' Hz'].

    destruct x as [x Hx]; destruct y as [y Hy].

    assert (z=z').

    inv H. subst.

    apply inj_pair2 in H3; subst.  apply inj_pair2 in H5; subst.

    apply inj_pair2 in H7; subst.

    inv H0; subst; auto. subst z'.

    f_equal.

    inv H; subst.

   apply inj_pair2 in H3; subst.

    apply inj_pair2 in H5; subst.  apply inj_pair2 in H7;  subst.

    inv H0; subst.

   apply inj_pair2 in H3; subst.

    apply inj_pair2 in H4; subst.  apply inj_pair2 in H5;  subst.

    eapply join_eq; eauto.



    destruct a as [ai a]; destruct b as [bi b]; destruct c as [ci c];

    destruct d as [di d]; destruct e as [ei e].

    assert (ai = bi /\ bi = ci /\ ci = di /\ di = ei).

    inv H; inv H0; simpl; auto.

    decompose [and] H1; subst; clear H1.

    rename ei into i.

    assert (join a b d).

    inversion H. apply inj_pair2 in H3. apply inj_pair2 in H4. apply inj_pair2 in H5.

    subst; auto.

    assert (join d c e).

    inversion H0. apply inj_pair2 in H4. apply inj_pair2 in H5. apply inj_pair2 in H6.

    subst; auto.

    destruct (join_assoc H1 H2) as [f [? ?]].

    exists (existT Sigma i f).

    split; constructor; auto.



    inv H; subst.

    constructor.

    apply join_comm; auto.



    inv H; inv H0.  apply inj_pair2 in H3.  apply inj_pair2 in H5.  subst.

    f_equal.

    eapply join_positivity; eauto.

 Qed.



  Instance Sep_sigma (SA : forall i:I, Sep_alg (Sigma i)) : Sep_alg S.

  Proof. apply mkSep with

      (fun (a : S) => existT Sigma (projT1 a) (core (projT2 a))).

   intros [i a]. constructor. apply core_unit.

   intros. inv H. f_equal. apply (join_core H0).

 Defined.



  Instance Canc_sigma: (forall i, Canc_alg (Sigma i)) -> Canc_alg S.

  Proof. repeat intro.

       destruct a1; destruct a2; destruct b; destruct c;

       inv H0; inv H1; subst.

       repeat match goal with H: existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end.

     subst.

    f_equal. apply (join_canc H3 H2).

  Qed.



  Instance Disj_sigma: (forall i, Disj_alg (Sigma i)) -> Disj_alg S.

  Proof. repeat intro.

    destruct a as [ia a]; destruct b as [ib b].

  

    red in H0. generalize H0; intro. inv H2.

     apply inj_pair2 in H8; apply inj_pair2 in H5; apply inj_pair2 in H6;

     subst. inv H0.

     apply inj_pair2 in H7; apply inj_pair2 in H5; apply inj_pair2 in H6;

     subst.

    inv H1. apply inj_pair2 in H5; subst.

    f_equal; eapply join_self; eauto.

 Qed.

End SepAlgSigma.



Existing Instance Join_sigma.

Existing Instance Perm_sigma.

Existing Instance Sep_sigma.

Existing Instance Canc_sigma.

Existing Instance Disj_sigma.



Section SepAlgProd.



  Variables (A: Type) (Ja: Join A).

  Variables (B: Type) (Jb: Join B) .

  Variables (PAa: Perm_alg A)(PAb: Perm_alg B).



  Instance Join_prod : Join (A*B) :=

               fun (x y z:A*B) =>  join (fst x) (fst y) (fst z) /\ join (snd x) (snd y) (snd z).



  Instance Perm_prod  : Perm_alg (A*B).

  Proof.

    constructor.



    intros [? ?] [? ?] [? ?] [? ?] [? ?] [? ?]; simpl in *.

    f_equal; simpl; eapply join_eq; eauto.



    intros [? ?] [? ?] [? ?] [? ?] [? ?] [? ?] [? ?]; simpl in *.

    destruct (join_assoc H H1) as [x [? ?]].

    destruct (join_assoc H0 H2) as [y [? ?]].

    exists (x,y); simpl; repeat split; auto.



    intros [? ?] [? ?] [? ?] [? ?]; repeat split; simpl in *; apply join_comm; auto.



    intros [? ?] [? ?] [? ?] [? ?] [? ?] [? ?]; simpl in *.

    f_equal; simpl; eapply join_positivity; eauto.

 Qed.



  Instance Sep_prod (SAa: Sep_alg A) (SAb: Sep_alg B) : Sep_alg (A*B).

  Proof.

    apply mkSep with (fun a => (core (fst a), core (snd a))).

    intros [? ?]; split; apply core_unit; auto.

    intros [? ?] [? ?] [? ?] [? ?]; f_equal; simpl; eapply join_core; eauto.

  Defined.



  Instance Sing_prod {SAa: Sep_alg A} {SAb: Sep_alg B} {SingA: Sing_alg A}{SingB: Sing_alg B}: Sing_alg (A*B).

  Proof. apply (mkSing  (the_unit, the_unit)).

     intros [? ?].  f_equal; simpl; f_equal; apply the_unit_core.

  Defined.



  Instance Canc_prod {CAa: Canc_alg A} {CAb:  Canc_alg B}: Canc_alg (A*B).

  Proof. intros  [? ?] [? ?] [? ?] [? ?] [? ?] [? ?].

   f_equal; simpl in *; eapply join_canc;eauto.

  Qed.



  Instance Disj_prod {DAa: Disj_alg A} {DAb:  Disj_alg B}: Disj_alg (A*B).

  Proof. intros  [? ?]  [? ?] [? ?] [] [] Hj.

   f_equal; simpl in *; inv Hj; eapply join_self; eauto.

  Qed.



End SepAlgProd.



Arguments Perm_prod [A] [Ja] [B] [Jb] _ _.

Arguments Sep_prod [A] [Ja] [B] [Jb] _ _.

Existing Instance Join_prod.

Existing Instance Perm_prod.

Existing Instance Sep_prod.

Existing Instance Canc_prod.

Existing Instance Disj_prod.



Section SepAlgSum.



  Variables (A: Type) (Ja: Join A) .

  Variables (B: Type) (Jb: Join B) .

  Variables (PAa: Perm_alg A) (PAb: Perm_alg B).

  Instance Join_sum : Join (A+B) :=

    (fun (x y z: A+B) =>

    match x, y, z with

    | inl xa, inl ya, inl za => join xa ya za

    | inr xb, inr yb, inr zb => join xb yb zb

    | _, _, _ => False

    end).



  Instance Perm_sum: Perm_alg (A+B).

  Proof.

    constructor.



    intros. icase x; icase y; icase z; icase z'; simpl in *; hnf; simpl;

    f_equal; eapply join_eq; eauto.



    intros; destruct e,a,b,c,d; try contradiction; hnf in H,H0;

    destruct (join_assoc H H0) as [f [? ?]].

    exists (inl B f); simpl; auto.

    exists (inr A f); simpl; auto.



    intros; destruct a; destruct b; destruct c; hnf in H|-*; try contradiction;

    apply join_comm; auto.



    intros; hnf in H,H0|-*; destruct a; destruct a'; destruct b; destruct b'; try contradiction;

    f_equal; eapply join_positivity; eauto.

 Qed.



  Instance Sep_sum (SAa: Sep_alg A) (SAb: Sep_alg B): Sep_alg (A+B).

  Proof.

    apply mkSep

      with (fun ab : A+B =>

              match ab with

              | inl a => inl _ (core a)

              | inr b => inr _ (core b)

              end).

    intro a; icase a; hnf; apply core_unit; auto.

    intros; icase a; icase b; icase c; hnf in *; f_equal; eapply join_core; eauto.

  Defined.



  Instance Canc_sum {CAa: Canc_alg A} {CAb:  Canc_alg B}: Canc_alg (A+B).

  Proof. repeat intro. icase a1; icase a2; icase b; icase c; hnf;

    f_equal; eapply join_canc; hnf in *; eauto.

  Qed.



  Instance Disj_sum {DAa: Disj_alg A} {DAb:  Disj_alg B}: Disj_alg (A+B).

  Proof. repeat intro. icase a; icase b; icase a0; icase b0; eapply f_equal, join_self; eauto.

  Qed.



End SepAlgSum.

Existing Instance Join_sum.

Existing Instance Perm_sum.

Existing Instance Sep_sum.

Existing Instance Canc_sum.

Existing Instance Disj_sum.



Section sa_list.



  Variables (A: Type) (Ja: Join A)  (PAa: Perm_alg A).



  Inductive list_join : list A -> list A -> list A -> Prop :=

  | lj_nil : list_join nil nil nil

  | lj_cons : forall x y z xs ys zs,

      join x y z ->

      list_join xs ys zs ->

      list_join (x::xs) (y::ys) (z::zs).



  Instance Join_list: Join (list A) := list_join.



  Instance Perm_list: Perm_alg (list A).

  Proof.

    constructor.



    induction x; intros; inv H; inv H0; auto; try constructor.

    f_equal. eapply join_eq; eauto. eapply IHx; eauto.



    induction a; intros;

    destruct b; destruct d; try (elimtype False; inv H; fail);

    destruct c; destruct e; try (elimtype False; inv H0; fail).

    exists nil. split; constructor.

    assert (join a a1 a2) by (inv H; auto).

    assert (join a2 a3 a4) by (inv H0; auto).

    assert (list_join a0 b d) by (inv H; auto).

    assert (list_join d c e) by (inv H0; auto).

    destruct (join_assoc H1 H2) as [z [? ?]].

    destruct (IHa _ _ _ _ H3 H4) as [zs [? ?]].

    exists (z::zs); split; constructor; auto.

    induction a; intros; inv H; constructor; auto.

    apply IHa; auto.



    induction a; intros.

    inv H; inv H0; auto.

    inv H0; inv H.

    f_equal.  eapply join_positivity; eauto.

    eapply IHa; eauto.

 Qed.



  Instance Sep_list (SAa: Sep_alg A) : Sep_alg (list A).

  Proof.

    apply mkSep with (map core).

    induction t; constructor; auto; apply core_unit.

    induction a; intros; inv H; auto. simpl.

    f_equal.  eapply join_core; eauto. eapply IHa; eauto.

 Defined.



  Instance Canc_list {CA: Canc_alg A}: Canc_alg (list A).

  Proof.

   intro. induction a1; intros; inv H; inv H0; auto.

    f_equal.

     eapply join_canc;eauto.

   eapply IHa1; eauto.

  Qed.



  Instance Disj_list {DAa: Disj_alg A} : Disj_alg (list A).

  Proof. intro. induction a; repeat intro; inv H; inv H0; auto.

    f_equal; [eapply join_self; eauto | eapply IHa; eauto].

  Qed.



End sa_list.

Existing Instance Join_list.

Existing Instance Perm_list.

Existing Instance Sep_list.

Existing Instance Canc_list.

Existing Instance Disj_list.



Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=

  forall x y z,

    j1 x y z ->

    j2 (f x) (f y) (f z).

Arguments raw_join_hom [A B] _ _ _.



Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=

  forall x y z,

    join x y z ->

    join (f x) (f y) (f z).



Section sa_preimage.

  Variables A B:Type.

  Variable B_J: Join B.

   Variable PA: Perm_alg B.



  Variable f:A -> B.

  Variable f':B -> A.



  Hypothesis Hf'_f : forall x, f' (f x) = x.

  Hypothesis Hf_f' : join_hom (f oo f').



  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

  Proof.

    intros.

    rewrite <- (Hf'_f x).

    rewrite <- (Hf'_f y).

    rewrite H; auto.

  Qed.



  Instance Join_preimage: Join A :=

          fun a b c => join (f a) (f b) (f c).



  Instance Perm_preimage  : @Perm_alg _  Join_preimage.

  Proof.

    constructor; simpl; intros.

   do 2 red in H,H0.

   apply f_inj.

   apply (join_eq H H0).



    do 2 red in H,H0.

    destruct (join_assoc H H0) as [z [? ?]].

    exists (f' z).

    split;

     [ do 2 red; rewrite <- (Hf'_f b); rewrite <- (Hf'_f c)

     | do 2 red; rewrite <- (Hf'_f a); rewrite <- (Hf'_f e)];

    apply (Hf_f' _ _ _); auto.



    do 2 red in H|-*; auto.



    apply f_inj; eapply join_positivity; eauto.

 Qed.



  Instance Sep_preimage {SAb: Sep_alg B}: Sep_alg A.

  Proof.

    apply mkSep with (fun x : A => f' (core (f x))); intros.



    do 3 red.

    generalize (@Hf_f' (@core B B_J SAb (f t)) (f t) (f t) (core_unit _)).

    intro.

    unfold compose in H. rewrite Hf'_f in H. auto.

    do 2 red in H.

    f_equal; apply (join_core H).

  Defined.



 Instance Sing_preimage {SAb: Sep_alg B}{Sing_b: Sing_alg B}: Sing_alg A.

 Proof.

 apply (mkSing (f' the_unit)).

 intro.

 simpl. rewrite <- (the_unit_core (f a)). f_equal; apply core_uniq.

 Defined.



 Instance Canc_preimage {SAb: Sep_alg B}{CAb: Canc_alg B} : Canc_alg A.

 Proof. intros ? ? ? ? ? ?. do 2 red in H,H0.

  generalize (join_canc H H0); intro.

  apply f_inj; auto.

 Qed.



 Instance Disj_preimage {SAb: Sep_alg B}{DAb: Disj_alg B} : Disj_alg A.

  Proof. repeat intro. do 2 red in H. apply join_self in H. apply f_inj; auto.

  Qed.



End sa_preimage.



Existing Instance Join_preimage.

Existing Instance Perm_preimage.

Existing Instance Sep_preimage.

Existing Instance Sing_preimage.

Existing Instance Canc_preimage.

Existing Instance Disj_preimage.



Section SepAlgBijection.

  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).

  Variable B:Type .



  Variable bij : bijection A B.

  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).



  Lemma Perm_bij  : Perm_alg B.

  Proof.

    constructor; intros.



    do 2 red in H,H0.

    generalize (join_eq H H0); clear H H0; intro.

    rewrite <- (bij_fg _ _ bij z). rewrite <- (bij_fg _ _ bij z'). f_equal; auto.



    do 2 red in H,H0.

   destruct (join_assoc H H0) as [m [? ?]]; exists (bij_f _ _ bij m); split;

   do 2 red; rewrite bij_gf; auto.



    do 2 red in H|-*. apply join_comm; auto.



    do 2 red in H,H0. rewrite <- (bij_fg _ _ bij a); rewrite <- (bij_fg _ _ bij b).

    f_equal. eapply join_positivity; eauto.

   Qed.



  Instance Sep_bij {SAa: Sep_alg A} : Sep_alg B.

  Proof.

   apply mkSep with (fun b => bij_f _ _ bij (core (bij_g _ _ bij b))); intros.

   do 3 red.

   repeat rewrite bij_gf. simpl. apply core_unit.

   do 2 red in H. f_equal. apply (join_core H).

 Defined.



 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

  Proof.

   apply (mkSing (bij_f _ _ bij the_unit)); intros.

   simpl. f_equal. apply  (the_unit_core (bij_g _ _ bij a)).

  Defined.



 Instance Canc_bij {SAa: Canc_alg A} : Canc_alg B.

  Proof. repeat intro.

    do 2 red in H,H0.

    generalize (join_canc H H0);intro.

    rewrite <- (bij_fg _ _ bij a1). rewrite <- (bij_fg _ _ bij a2). rewrite H1; auto.

  Qed.



  Instance  Disj_bij {DAa: Disj_alg A} : Disj_alg B.

  Proof. repeat intro. do 2 red in H.

    apply join_self in H.

    specialize (H _ _ H0).

    eapply bij_g_inj; eauto.

  Qed.



End SepAlgBijection.

Existing Instance Join_bij.

Existing Instance Perm_bij.

Existing Instance Sep_bij.

Existing Instance Sing_bij.

Existing Instance Canc_bij.

Existing Instance Disj_bij.

