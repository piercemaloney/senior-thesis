Require Import Coq.Sorting.Permutation.

Require Import Coq.Sorting.Sorting.

Require Import Coq.Structures.Orders.

Require Import VST.veric.Clight_base.
(* VST.veric.Clight_base:
Require Export compcert.exportclight.Clightdefs.

Require Export VST.veric.base.
Require Export compcert.cfrontend.Ctypes.
Require Export compcert.cfrontend.Cop. 
Require Export compcert.cfrontend.Clight. 

Require Export EqNat.  

Require Export VST.veric.Memory. *)

Require Import VST.veric.Clight_lemmas.
(* VST.veric.Clight_lemmas:
Require Import VST.veric.Clight_base.
Require Import compcert.cfrontend.Clight.

Definition var_name (V: Type) (bdec: ident * globvar V) : ident :=
   fst bdec.

Definition no_dups (F V: Type) (fdecs: list (ident * F)) (bdecs: list (ident * globvar V)) : Prop :=
  list_norepet (map (@fst ident F) fdecs ++ map (@var_name V) bdecs).
Arguments no_dups [F V] _ _.

Lemma no_dups_inv:
  forall  (A V: Type) id f fdecs bdecs,
    no_dups ((id,f)::fdecs) bdecs ->
    no_dups fdecs bdecs /\
     ~ In id (map (@fst ident A) fdecs) /\
     ~ In id (map (@var_name V) bdecs).
Arguments no_dups_inv [A V] _ _ _ _ _.

Lemma of_bool_Int_eq_e:
  forall i j, Val.of_bool (Int.eq i j) = Vtrue -> i = j.

Lemma eq_block_lem:
    forall (A: Set) a (b: A) c, (if eq_block a a then b else c) = b.

Lemma signed_zero: Int.signed Int.zero = 0.

Lemma equiv_e1 : forall A B: Prop, A=B -> A -> B.
Arguments equiv_e1 [A B] _ _.

Lemma deref_loc_fun: forall {ty m b z v v'},
   Clight.deref_loc ty m b z v -> Clight.deref_loc ty m b z v' -> v=v'.

Lemma eval_expr_lvalue_fun:
  forall ge e le m,
    (forall a v v', Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v') /\

Lemma eval_expr_fun:   forall {ge e le m a v v'},
    Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v'.

Lemma eval_exprlist_fun:   forall {ge e le m a ty v v'},
    Clight.eval_exprlist ge e le m a ty v -> Clight.eval_exprlist ge e le m a ty v' -> v=v'.

Lemma eval_lvalue_fun:   forall {ge e le m a b b' z z'},
    Clight.eval_lvalue ge e le m a b z -> Clight.eval_lvalue ge e le m a b' z' -> (b,z)=(b',z').

Lemma inv_find_symbol_fun:
  forall {ge id id' b},
    Senv.find_symbol ge id = Some b ->

Lemma assign_loc_fun:
  forall {cenv ty m b ofs v m1 m2},
   assign_loc cenv ty m b ofs v m1 ->
   assign_loc cenv ty m b ofs v m2 ->
   m1=m2.

Lemma alloc_variables_fun:
  forall {ge e m vl e1 m1 e2 m2},
     Clight.alloc_variables ge e m vl e1 m1 ->

Lemma bind_parameters_fun:
  forall {ge e m p v m1 m2},
    Clight.bind_parameters ge e m p v m1 ->

Lemma eventval_list_match_fun:
  forall {se a a' t v},
    Events.eventval_list_match se a t v ->

Ltac fun_tac :=
  match goal with
  | H: ?A = Some _, H': ?A = Some _ |- _ => inversion2 H H'
  | H: Clight.eval_expr ?ge ?e ?le ?m ?A _,
    H': Clight.eval_expr ?ge ?e ?le ?m ?A _ |- _ =>
        apply (eval_expr_fun H) in H'; subst
  | H: Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _,
    H': Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _ |- _ =>
        apply (eval_exprlist_fun H) in H'; subst
  | H: Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _,
    H': Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _ |- _ =>
        apply (eval_lvalue_fun H) in H'; inv H'
  | H: Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _,
    H': Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _ |- _ =>
        apply (assign_loc_fun H) in H'; inv H'
  | H: Clight.deref_loc ?ty ?m ?b ?ofs _,
    H': Clight.deref_loc ?ty ?m ?b ?ofs _ |- _ =>
        apply (deref_loc_fun H) in H'; inv H'
  | H: Clight.alloc_variables ?ge ?e ?m ?vl _ _,
    H': Clight.alloc_variables ?ge ?e ?m ?vl _ _ |- _ =>
        apply (alloc_variables_fun H) in H'; inv H'
  | H: Clight.bind_parameters ?ge ?e ?m ?p ?vl _,
    H': Clight.bind_parameters ?ge ?e ?m ?p ?vl _ |- _ =>
        apply (bind_parameters_fun H) in H'; inv H'
  | H: Senv.find_symbol ?ge _ = Some ?b,
    H': Senv.find_symbol ?ge _ = Some ?b |- _ =>
       apply (inv_find_symbol_fun H) in H'; inv H'
  | H: Events.eventval_list_match ?ge _ ?t ?v,
    H': Events.eventval_list_match ?ge _ ?t ?v |- _ =>
       apply (eventval_list_match_fun H) in H'; inv H'
 end. *)

Require Import VST.veric.type_induction.
(* VST.veric.type_induction:
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes.

Section COMPOSITE_ENV.

Context (cenv: composite_env)
        (cenv_consistent: composite_env_consistent cenv).

Lemma type_ind: forall P : type -> Prop,
  (forall t,
  match t with
  | Tarray t0 _ _ => P t0
  | Tstruct id _ 
  | Tunion id _ => match cenv ! id with
                    | Some co => Forall (Basics.compose P snd) (co_members co)

End COMPOSITE_ENV.

Ltac type_induction t cenv cenv_consistent :=
  pattern t;
  match goal with
  | |- ?P t =>
    apply (type_ind cenv cenv_consistent); clear t;
    let t := fresh "t" in
    intros t IH;
    let id := fresh "id" in
    let a := fresh "a" in
    destruct t as [| | | | | | | id a | id a]
  end. *)

Require Import VST.veric.composite_compute.
(* VST.veric.composite_compute:
Require Import Coq.Sorting.Permutation.
Require Import Coq.Sorting.Sorting.
Require Import Coq.Structures.Orders.
Require Import VST.veric.base.

Require Import compcert.cfrontend.Ctypes. 

Axiom list_norepet_NoDup: forall {A: Type} (l: list A), list_norepet l <-> NoDup l.

Lemma PTree_In_fst_elements {A: Type}: forall (T: PTree.t A) i,

Lemma PTree_gs {A: Type}: forall (T: PTree.t A) i j x,

Lemma PTree_gs_equiv {A: Type}: forall (T: PTree.t A) i j x,

Lemma PTree_set_In_fst_elements {A: Type}: forall (T: PTree.t A) i i' a',
  
Fixpoint relative_defined_type {A: Type} (l: list (ident * A)) (t: type): Prop :=
  match t with
  | Tarray t' _ _ => relative_defined_type l t'
  | Tstruct id _ => In id (map fst l)
  | Tunion id _ => In id (map fst l)
  | _ => True
  end.

Lemma relative_defined_type_mono: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type),
  (forall i, In i (map fst l1) -> In i (map fst l2)) ->
  relative_defined_type l1 t ->
  relative_defined_type l2 t.

Lemma relative_defined_type_equiv: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type),
  (forall i, In i (map fst l1) <-> In i (map fst l2)) ->
  (relative_defined_type l1 t <-> relative_defined_type l2 t).

Inductive ordered_composite: list (positive * composite) -> Prop :=
| ordered_composite_nil: ordered_composite nil
| ordered_composite_cons: forall i co l,
    Forall (relative_defined_type l) (map snd (co_members co)) ->
    ordered_composite l ->
    ordered_composite ((i, co) :: l).

Module composite_reorder.

Module CompositeRankOrder <: TotalLeBool.
  Definition t := (positive * composite)%type.
  Definition leb (x y: t) := Nat.leb (co_rank (snd y)) (co_rank (snd x)).

  Theorem leb_total : forall a1 a2, leb a1 a2 = true \/ leb a2 a1 = true.

  Theorem leb_trans: Transitive (fun x y => is_true (leb x y)).

End CompositeRankOrder.

Module CompositeRankSort := Sort CompositeRankOrder.

Section composite_reorder.

Context (cenv: composite_env)
        (cenv_consistent: composite_env_consistent cenv).

Definition rebuild_composite_elements := CompositeRankSort.sort (PTree.elements cenv).

Inductive ordered_and_complete: list (positive * composite) -> Prop :=
| ordered_and_complete_nil: ordered_and_complete nil
| ordered_and_complete_cons: forall i co l,
    (forall i' co',
        cenv ! i' = Some co' ->
        (co_rank co' < co_rank co)%nat ->
        In (i', co') l) ->
    ordered_and_complete l ->
    ordered_and_complete ((i, co) :: l).

Theorem RCT_Permutation: Permutation rebuild_composite_elements (PTree.elements cenv).

Lemma RCT_ordered_and_complete: ordered_and_complete rebuild_composite_elements.

Theorem RCT_ordered: ordered_composite rebuild_composite_elements.

End composite_reorder.

End composite_reorder.

Module type_func.
Section type_func.

Context {A: Type}
        (f_default: type -> A)
        (f_array: A -> type -> Z -> attr -> A)
        (f_struct: A -> ident -> attr -> A)
        (f_union: A -> ident -> attr -> A)
        (f_member: struct_or_union -> list (ident * type * A) -> A).

Fixpoint F (env: PTree.t A) (t: type): A :=
  match t with
  | Tarray t n a => f_array (F env t) t n a
  | Tstruct id a =>
      match env ! id with
      | Some v => f_struct v id a
      | None => f_default t
      end
  | Tunion id a =>
      match env ! id with
      | Some v => f_union v id a
      | None => f_default t
      end
  | _ => f_default t
  end.

Definition Complete (cenv: composite_env) (env: PTree.t A): Prop :=
  forall i,
    (exists co, PTree.get i cenv = Some co) <->
    (exists a, PTree.get i env = Some a).

Definition Consistent (cenv: composite_env) (env: PTree.t A): Prop :=
  forall i co a,
    PTree.get i cenv = Some co ->
    PTree.get i env = Some a ->
    a = f_member (co_su co) (map
                              (fun it0: positive * type =>
                                 let (i0, t0) := it0 in
                                 (i0, t0, F env t0))
                              (co_members co)).

Definition env_rec (i: positive) (co: composite) (env: PTree.t A): PTree.t A :=
  PTree.set i
    (f_member (co_su co) (map
                              (fun it0: positive * type =>
                                 let (i0, t0) := it0 in (i0, t0, F env t0))
                              (co_members co)))
    env.

Definition Env (l: list (positive * composite)): PTree.t A :=
  fold_right
    (fun (ic: positive * composite) =>
       let (i, co) := ic in env_rec i co)
    (PTree.empty A)
    l.

Lemma F_PTree_set: forall t env i a,
  ~ In i (map fst (PTree.elements env)) ->

Lemma relative_defined_type_PTree_set: forall t (env: PTree.t A) i a,

Section Consistency_Induction_Step.

Context (cenv: composite_env)
        (env: PTree.t A)
        (l: list (positive * composite))
        (i0: positive)
        (co0: composite).

Hypothesis NOT_IN_LIST: ~ In i0 (map fst l).

Hypothesis RDT_list: Forall (relative_defined_type l) (map snd (co_members co0)).

Hypothesis CENV0: PTree.get i0 cenv = Some co0.

Hypothesis IH_In_equiv: forall i, In i (map fst l) <-> In i (map fst (PTree.elements env)).

Hypothesis IH_RDT:
  forall i co a,
    PTree.get i cenv = Some co ->
    PTree.get i env = Some a ->
    Forall (relative_defined_type (PTree.elements env)) (map snd (co_members co)).

Hypothesis IH_main:
  Consistent cenv env.

Lemma NOT_IN: ~ In i0 (map fst (PTree.elements env)).

Lemma RDT_PTree: Forall (relative_defined_type (PTree.elements env)) (map snd (co_members co0)).

Lemma establish_In_equiv:
  forall i, In i (map fst ((i0, co0) :: l)) <-> In i (map fst (PTree.elements (env_rec i0 co0 env))).

Lemma establish_RDT:
  forall i co a,
    PTree.get i cenv = Some co ->

Lemma establish_main:
  Consistent cenv (env_rec i0 co0 env).

End Consistency_Induction_Step.

Lemma Consistency: forall cenv l,
  Permutation l (PTree.elements cenv) ->

Lemma Completeness: forall cenv l,
  Permutation l (PTree.elements cenv) ->

End type_func.

End type_func.

Corollary composite_reorder_consistent {A: Type}:
  forall cenv f_default f_array f_struct f_union f_members,
    composite_env_consistent cenv ->
    type_func.Consistent f_default f_array f_struct f_union f_members cenv (@type_func.Env A f_default f_array f_struct f_union f_members (composite_reorder.rebuild_composite_elements cenv)).

Corollary composite_reorder_complete {A: Type}:
  forall cenv f_default f_array f_struct f_union f_members,
    type_func.Complete cenv (@type_func.Env A f_default f_array f_struct f_union f_members (composite_reorder.rebuild_composite_elements cenv)).

Section cuof.

Context (cenv: composite_env).

Fixpoint complete_legal_cosu_type t :=
  match t with
  | Tarray t' _ _ => complete_legal_cosu_type t'
  | Tstruct id _ => match cenv ! id with
                    | Some co => match co_su co with
                                 | Struct => true
                                 | Union => false
                                 end
                    | _ => false
                    end
  | Tunion id _ => match cenv ! id with
                   | Some co => match co_su co with
                                | Struct => false
                                | Union => true
                                end
                   | _ => false
                   end
  | Tfunction _ _ _
  | Tvoid => false
  | _ => true
  end.

Fixpoint composite_complete_legal_cosu_type (m: members): bool :=
  match m with
  | nil => true
  | (_, t) :: m' => complete_legal_cosu_type t && composite_complete_legal_cosu_type m'
  end.

Definition composite_env_complete_legal_cosu_type: Prop :=
  forall (id : positive) (co : composite),
    cenv ! id = Some co -> composite_complete_legal_cosu_type (co_members co) = true.
  
End cuof.

Lemma complete_legal_cosu_type_complete_type: forall cenv: composite_env,
  forall t,
    complete_legal_cosu_type cenv t = true ->
    complete_type cenv t = true. *)

Require Import VST.veric.align_mem.
(* VST.veric.align_mem:
Require Import Coq.Sorting.Permutation.
Require Import Coq.Sorting.Sorting.
Require Import Coq.Structures.Orders.
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes. 
Require Import VST.veric.type_induction.
Require Import VST.veric.composite_compute.

Section align_compatible_rec.

Context (cenv: composite_env).

Inductive align_compatible_rec: type -> Z -> Prop :=
| align_compatible_rec_by_value: forall t ch z, access_mode t = By_value ch -> (Memdata.align_chunk ch | z) -> align_compatible_rec t z
| align_compatible_rec_Tarray: forall t n a z, (forall i, 0 <= i < n -> align_compatible_rec t (z + sizeof cenv t * i)) -> align_compatible_rec (Tarray t n a) z
| align_compatible_rec_Tstruct: forall i a co z, cenv ! i = Some co -> (forall i0 t0 z0, field_type i0 (co_members co) = Errors.OK t0 -> field_offset cenv i0 (co_members co) = Errors.OK z0 -> align_compatible_rec t0 (z + z0)) -> align_compatible_rec (Tstruct i a) z
| align_compatible_rec_Tunion: forall i a co z, cenv ! i = Some co -> (forall i0 t0, field_type i0 (co_members co) = Errors.OK t0 -> align_compatible_rec t0 z) -> align_compatible_rec (Tunion i a) z.

Lemma align_compatible_rec_by_value_inv : forall t ch z,
  access_mode t = By_value ch ->
  align_compatible_rec t z -> (Memdata.align_chunk ch | z).

Lemma align_compatible_rec_Tarray_inv: forall t n a z,
  align_compatible_rec (Tarray t n a) z ->
  (forall i : Z, 0 <= i < n -> align_compatible_rec t (z + sizeof cenv t * i)).

Lemma align_compatible_rec_Tstruct_inv: forall i a co z,
  cenv ! i = Some co ->
  align_compatible_rec (Tstruct i a) z ->
  (forall i0 t0 z0, field_type i0 (co_members co) = Errors.OK t0 -> field_offset cenv i0 (co_members co) = Errors.OK z0 -> align_compatible_rec t0 (z + z0)).
  
Lemma align_compatible_rec_Tunion_inv: forall i a co z,
  cenv ! i = Some co ->
  align_compatible_rec (Tunion i a) z ->
  (forall i0 t0, field_type i0 (co_members co) = Errors.OK t0 -> align_compatible_rec t0 z).

End align_compatible_rec.

Lemma align_chunk_1248: forall ch, align_chunk ch = 1 \/ align_chunk ch = 2 \/ align_chunk ch = 4 \/ align_chunk ch = 8.

Lemma align_chunk_two_p:
  forall ch, exists n, align_chunk ch = two_power_nat n.

Fixpoint hardware_alignof (ha_env: PTree.t Z) t: Z :=
  match t with
  | Tarray t' _ _ => hardware_alignof ha_env t'
  | Tstruct id _ =>
      match ha_env ! id with
      | Some ha => ha
      | None => 1
      end
  | Tunion id _ =>
      match ha_env ! id with
      | Some ha => ha
      | None => 1
      end
  | _ => match access_mode t with
         | By_value ch => Memdata.align_chunk ch
         | _ => 1
         end
  end.

Fixpoint hardware_alignof_composite (ha_env: PTree.t Z) (m: members): Z :=
  match m with
  | nil => 1
  | (_, t) :: m' => Z.max (hardware_alignof ha_env t) (hardware_alignof_composite ha_env m')
  end.

Definition hardware_alignof_env (cenv: composite_env): PTree.t Z :=
  let l := composite_reorder.rebuild_composite_elements cenv in
  fold_right (fun (ic: positive * composite) (T0: PTree.t Z) => let (i, co) := ic in let T := T0 in PTree.set i (hardware_alignof_composite T (co_members co)) T) (PTree.empty _) l.

Definition hardware_alignof_env_consistent (cenv: composite_env) (ha_env: PTree.t Z): Prop :=
  forall i co ha,
    cenv ! i = Some co ->
    ha_env ! i = Some ha ->
    ha = hardware_alignof_composite ha_env (co_members co).

Definition hardware_alignof_env_complete (cenv: composite_env) (ha_env: PTree.t Z): Prop :=
  forall i,
    (exists co, cenv ! i = Some co) <->
    (exists ha, ha_env ! i = Some ha).

Module Type HARDWARE_ALIGNOF_FACTS.

  Axiom hardware_alignof_consistency:
    forall (cenv: composite_env) (ha_env: PTree.t Z),
      composite_env_consistent cenv ->
      ha_env = hardware_alignof_env cenv ->
      hardware_alignof_env_consistent cenv ha_env.

  Axiom hardware_alignof_completeness:
    forall (cenv: composite_env) (ha_env: PTree.t Z),
      ha_env = hardware_alignof_env cenv ->
      hardware_alignof_env_complete cenv ha_env.

End HARDWARE_ALIGNOF_FACTS.

Module hardware_alignof_facts: HARDWARE_ALIGNOF_FACTS.

Lemma aux1: forall T co,
  (fix fm (l : list (ident * type * Z)) : Z :=
     match l with
     | nil => 1
     | (_, _, ha) :: l' => Z.max ha (fm l')

Lemma aux2: forall (cenv: composite_env),
  type_func.Env

Lemma hardware_alignof_consistency (cenv: composite_env) (ha_env: PTree.t Z):

Lemma hardware_alignof_completeness (cenv: composite_env) (ha_env: PTree.t Z):

End hardware_alignof_facts.

Export hardware_alignof_facts.

Lemma hardware_alignof_two_p: forall (cenv: composite_env) (ha_env: PTree.t Z),

Lemma hardware_alignof_pos: forall (cenv: composite_env) (ha_env: PTree.t Z),

Lemma hardware_alignof_composite_two_p: forall (cenv: composite_env) (ha_env: PTree.t Z),

Hint Resolve alignof_two_p: align.
Hint Resolve align_chunk_two_p: align.
Hint Extern 10 (exists n: nat, hardware_alignof _ _ = two_power_nat n) => (eapply hardware_alignof_two_p; eassumption): align.
Hint Extern 10 (exists n: nat, hardware_alignof_composite _ _ = two_power_nat n) => (eapply hardware_alignof_composite_two_p; eassumption): align.

Lemma hardware_alignof_by_value: forall ha_env t ch,
  access_mode t = By_value ch ->
  hardware_alignof ha_env t = align_chunk ch.

Lemma align_compatible_rec_hardware_alignof_divide: forall cenv ha_env t z1 z2,
  composite_env_consistent cenv ->
  composite_env_complete_legal_cosu_type cenv ->
  hardware_alignof_env_consistent cenv ha_env ->
  hardware_alignof_env_complete cenv ha_env ->
  complete_legal_cosu_type cenv t = true ->
  (hardware_alignof ha_env t | z1 - z2) ->
  (align_compatible_rec cenv t z1 <-> align_compatible_rec cenv t z2).

Lemma align_compatible_rec_hardware_1: forall cenv ha_env t z,
  composite_env_consistent cenv ->
  composite_env_complete_legal_cosu_type cenv ->
  hardware_alignof_env_consistent cenv ha_env ->
  hardware_alignof_env_complete cenv ha_env ->
  complete_legal_cosu_type cenv t = true ->
  hardware_alignof ha_env t = 1 ->
  align_compatible_rec cenv t z.

Module Type LEGAL_ALIGNAS.

  Parameter legal_alignas_obs: Type.
  Parameter legal_alignas_type: composite_env -> PTree.t Z -> PTree.t legal_alignas_obs -> type -> legal_alignas_obs.
  Parameter legal_alignas_composite: composite_env -> PTree.t Z -> PTree.t legal_alignas_obs -> composite -> legal_alignas_obs.
  Parameter legal_alignas_env: composite_env -> PTree.t Z -> PTree.t legal_alignas_obs.
  Parameter is_aligned_aux: legal_alignas_obs -> Z -> Z -> bool.  

End LEGAL_ALIGNAS.

Module LegalAlignasDefsGen (LegalAlignas: LEGAL_ALIGNAS).

  Import LegalAlignas.

  Definition legal_alignas_env_consistent (cenv: composite_env) (ha_env: PTree.t Z) (la_env: PTree.t legal_alignas_obs): Prop :=
    forall i co la,
      cenv ! i = Some co ->
      la_env ! i = Some la ->
      la = legal_alignas_composite cenv ha_env la_env co.

  Definition legal_alignas_env_complete (cenv: composite_env) (la_env: PTree.t legal_alignas_obs): Prop :=
    forall i,
      (exists co, cenv ! i = Some co) <->
      (exists la, la_env ! i = Some la).

  Definition is_aligned cenv ha_env la_env (t: type) (ofs: Z): bool := is_aligned_aux (legal_alignas_type cenv ha_env la_env t) (hardware_alignof ha_env t) ofs.

  Definition legal_alignas_env_sound (cenv: composite_env) (ha_env: PTree.t Z) (la_env: PTree.t legal_alignas_obs): Prop :=
    forall ofs t,
      complete_legal_cosu_type cenv t = true ->
      is_aligned cenv ha_env la_env t ofs = true ->
      align_compatible_rec cenv t ofs.

End LegalAlignasDefsGen.

Module Type LEGAL_ALIGNAS_FACTS.

  Declare Module LegalAlignas: LEGAL_ALIGNAS.
  Module LegalAlignasDefs := LegalAlignasDefsGen (LegalAlignas).
  Export LegalAlignas LegalAlignasDefs.

  Axiom legal_alignas_env_consistency: forall cenv ha_env,
    composite_env_consistent cenv ->
    legal_alignas_env_consistent cenv ha_env (legal_alignas_env cenv ha_env).

  Axiom legal_alignas_env_completeness: forall cenv ha_env,
    legal_alignas_env_complete cenv (legal_alignas_env cenv ha_env).

  Axiom legal_alignas_soundness: forall cenv ha_env la_env,
    composite_env_consistent cenv ->
    composite_env_complete_legal_cosu_type cenv ->
    hardware_alignof_env_consistent cenv ha_env ->
    hardware_alignof_env_complete cenv ha_env ->
    legal_alignas_env_consistent cenv ha_env la_env ->
    legal_alignas_env_complete cenv la_env ->
    legal_alignas_env_sound cenv ha_env la_env.

End LEGAL_ALIGNAS_FACTS.

Module LegalAlignasStrict <: LEGAL_ALIGNAS.

Section legal_alignas.

Context (cenv: composite_env) (ha_env: PTree.t Z).

Definition legal_alignas_obs: Type := bool.

Fixpoint legal_alignas_type (la_env: PTree.t bool) t: bool :=
  (hardware_alignof ha_env t <=? alignof cenv t) &&
  match t with
  | Tarray t' _ _ => (sizeof cenv t' mod alignof cenv t' =? 0) && legal_alignas_type la_env t'
  | Tstruct id _ =>
      match la_env ! id with
      | Some la => la
      | None => false
      end
  | Tunion id _ =>
      match la_env ! id with
      | Some la => la
      | None => false
      end
  | _ => match access_mode t with
         | By_value ch => true
         | _ => false
         end
  end.

Fixpoint legal_alignas_members (la_env: PTree.t bool) (m: members): bool :=
  match m with
  | nil => true
  | (_, t) :: m' => (legal_alignas_type la_env t) && (legal_alignas_members la_env m')
  end.

Definition legal_alignas_composite (la_env: PTree.t bool) (co: composite): bool :=
  legal_alignas_members la_env (co_members co).

Definition legal_alignas_env: PTree.t bool :=
  let l := composite_reorder.rebuild_composite_elements cenv in
  fold_right (fun (ic: positive * composite) (T0: PTree.t bool) => let (i, co) := ic in let T := T0 in PTree.set i (legal_alignas_composite T co) T) (PTree.empty _) l.

Definition is_aligned_aux (b: bool) (ha: Z) (ofs: Z) := b && ((ofs mod ha) =? 0).

End legal_alignas.

End LegalAlignasStrict.

Module LegalAlignasStrictFacts: LEGAL_ALIGNAS_FACTS with Module LegalAlignas := LegalAlignasStrict.

Module LegalAlignas := LegalAlignasStrict.
Module LegalAlignasDefs := LegalAlignasDefsGen (LegalAlignas).
Export LegalAlignas LegalAlignasDefs.

Section legal_alignas.

Context (cenv: composite_env) (ha_env: PTree.t Z).

Lemma aux1: forall T co,
      (fix fm (l : list (ident * type * bool)) : bool :=
          match l with
          | nil => true
          | (_, _, la) :: l' => la && fm l'
          end)
         (map
            (fun it0 : positive * type =>
             let (i0, t0) := it0 in
             (i0, t0,
             type_func.F

Lemma aux2:
    (type_func.Env

End legal_alignas.

Theorem legal_alignas_env_consistency:
  forall (cenv: composite_env) (ha_env: PTree.t Z),

Theorem legal_alignas_env_completeness:
  forall (cenv: composite_env) (ha_env: PTree.t Z),

Section soundness.

Context (cenv: composite_env)
        (ha_env: PTree.t Z)
        (la_env: PTree.t bool)
        (CENV_CONSI: composite_env_consistent cenv)
        (CENV_COSU: composite_env_complete_legal_cosu_type cenv)
        (HA_ENV_CONSI: hardware_alignof_env_consistent cenv ha_env)
        (HA_ENV_COMPL: hardware_alignof_env_complete cenv ha_env)
        (LA_ENV_CONSI: legal_alignas_env_consistent cenv ha_env la_env)
        (LA_ENV_COMPL: legal_alignas_env_complete cenv la_env).

Lemma legal_alignas_type_divide: forall t,
  legal_alignas_type cenv ha_env la_env t = true ->
  (hardware_alignof ha_env t | alignof cenv t).

Lemma by_value_sound:
  forall t ofs,
    is_aligned cenv ha_env la_env t ofs = true ->
    (exists ch, access_mode t = By_value ch) ->
    align_compatible_rec cenv t ofs.

Theorem legal_alignas_soundness:
  legal_alignas_env_sound cenv ha_env la_env.

End soundness.

End LegalAlignasStrictFacts.

Module LegalAlignasStrong <: LEGAL_ALIGNAS.

Section legal_alignas.

Context (cenv: composite_env) (ha_env: PTree.t Z).

Definition legal_alignas_obs: Type := bool.

Fixpoint legal_alignas_type (la_env: PTree.t bool) t: bool :=
  match t with
  | Tarray t' _ _ => (sizeof cenv t' mod hardware_alignof ha_env t' =? 0) && legal_alignas_type la_env t'
  | Tstruct id _ =>
      match la_env ! id with
      | Some la => la
      | None => false
      end
  | Tunion id _ =>
      match la_env ! id with
      | Some la => la
      | None => false
      end
  | _ => match access_mode t with
         | By_value ch => true
         | _ => false
         end
  end.

Fixpoint legal_alignas_struct_members_rec (la_env: PTree.t bool) (m: members) (pos: Z): bool :=
  match m with
  | nil => true
  | (_, t) :: m' => (align pos (alignof cenv t) mod hardware_alignof ha_env t =? 0) && (legal_alignas_type la_env t) && (legal_alignas_struct_members_rec la_env m' (align pos (alignof cenv t) + sizeof cenv t))
  end.

Fixpoint legal_alignas_union_members_rec (la_env: PTree.t bool) (m: members): bool :=
  match m with
  | nil => true
  | (_, t) :: m' => (legal_alignas_type la_env t) && (legal_alignas_union_members_rec la_env m')
  end.

Definition legal_alignas_composite (la_env: PTree.t bool) (co: composite): bool :=
  match co_su co with
  | Struct => legal_alignas_struct_members_rec la_env (co_members co) 0
  | Union => legal_alignas_union_members_rec la_env (co_members co)
  end.

Definition legal_alignas_env: PTree.t bool :=
  let l := composite_reorder.rebuild_composite_elements cenv in
  fold_right (fun (ic: positive * composite) (T0: PTree.t bool) => let (i, co) := ic in let T := T0 in PTree.set i (legal_alignas_composite T co) T) (PTree.empty _) l.

Definition is_aligned_aux (b: bool) (ha: Z) (ofs: Z) := b && ((ofs mod ha) =? 0).

End legal_alignas.

End LegalAlignasStrong.

Module LegalAlignasStrongFacts: LEGAL_ALIGNAS_FACTS with Module LegalAlignas := LegalAlignasStrong.

Module LegalAlignas := LegalAlignasStrong.
Module LegalAlignasDefs := LegalAlignasDefsGen (LegalAlignas).
Export LegalAlignas LegalAlignasDefs.

Section legal_alignas.

Context (cenv: composite_env) (ha_env: PTree.t Z).

Lemma aux1: forall T co,
  match co_su co with
  | Struct =>
      (fix fm (pos : Z) (l : list (ident * type * bool)) {struct l} : bool :=
         match l with
         | nil => true
         | (_, t, la) :: l' =>
             (align pos (alignof cenv t) mod hardware_alignof ha_env t =? 0) &&
             la && fm (align pos (alignof cenv t) + sizeof cenv t) l'
         end) 0
  | Union =>
      fix fm (l : list (ident * type * bool)) : bool :=
        match l with
        | nil => true
        | (_, _, la) :: l' => la && fm l'
        end
  end
    (map
       (fun it0 : positive * type =>
        let (i0, t0) := it0 in
        (i0, t0,
        type_func.F

Lemma aux2:
    (type_func.Env

End legal_alignas.

Theorem legal_alignas_env_consistency:
  forall (cenv: composite_env) (ha_env: PTree.t Z),

Theorem legal_alignas_env_completeness:
  forall (cenv: composite_env) (ha_env: PTree.t Z),

Section soundness.

Context (cenv: composite_env)
        (ha_env: PTree.t Z)
        (la_env: PTree.t bool)
        (CENV_CONSI: composite_env_consistent cenv)
        (CENV_COSU: composite_env_complete_legal_cosu_type cenv)
        (HA_ENV_CONSI: hardware_alignof_env_consistent cenv ha_env)
        (HA_ENV_COMPL: hardware_alignof_env_complete cenv ha_env)
        (LA_ENV_CONSI: legal_alignas_env_consistent cenv ha_env la_env)
        (LA_ENV_COMPL: legal_alignas_env_complete cenv la_env).

Lemma by_value_sound:
  forall t ofs,
    is_aligned cenv ha_env la_env t ofs = true ->
    (exists ch, access_mode t = By_value ch) ->
    align_compatible_rec cenv t ofs.

Theorem legal_alignas_soundness:
  legal_alignas_env_sound cenv ha_env la_env.

End soundness.

End LegalAlignasStrongFacts.

Module Export LegalAlignasFacts := LegalAlignasStrongFacts. *)

Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)

Require Import VST.veric.Cop2.
(* VST.veric.Cop2:
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes.
Require Import VST.veric.val_lemmas.

Definition eqb_option {A} (f: A -> A -> bool) (x y: option A) : bool :=
  match x, y with
  | None, None => true
  | Some x' , Some y' => f x' y'
 | _, _ => false
  end.

Definition eqb_attr (a b: attr) : bool :=
 match a, b with
 | mk_attr av an, mk_attr bv bn => eqb av bv && eqb_option N.eqb an bn
 end.

Definition eqb_floatsize (a b: floatsize) : bool :=
 match a , b with
 | F32, F32 => true
 | F64, F64 => true
 | _, _ => false
 end.

Definition eqb_ident : ident -> ident -> bool := Pos.eqb.

Definition eqb_intsize (a b: intsize) : bool :=
 match a , b with
 | I8, I8 => true
 | I16, I16 => true
 | I32, I32 => true
 | IBool, IBool => true
 | _, _ => false
 end.

Definition eqb_signedness (a b : signedness) :=
 match a, b with
 | Signed, Signed => true
 | Unsigned, Unsigned => true
 | _, _ => false
 end.

Definition eqb_calling_convention (a b: calling_convention) :=
 andb (eqb (cc_vararg a) (cc_vararg b))
     (andb  (eqb (cc_unproto a) (cc_unproto b))
      (eqb (cc_structret a) (cc_structret b))).

Fixpoint eqb_type (a b: type) {struct a} : bool :=
 match a, b with
 | Tvoid, Tvoid => true
 | Tint ia sa aa, Tint ib sb ab => andb (eqb_intsize ia ib)
                                                    (andb (eqb_signedness sa sb) (eqb_attr aa ab))
 | Tlong sa aa, Tlong sb ab => andb (eqb_signedness sa sb) (eqb_attr aa ab)
 | Tfloat sa aa, Tfloat sb ab => andb (eqb_floatsize sa sb) (eqb_attr aa ab)
 | Tpointer ta aa, Tpointer tb ab => andb (eqb_type ta tb) (eqb_attr aa ab)
 | Tarray ta sa aa, Tarray tb sb ab => andb (eqb_type ta tb)
                                                                   (andb (Zeq_bool sa sb) (eqb_attr aa ab))
 | Tfunction sa ta ca, Tfunction sb tb cb =>
       andb (andb (eqb_typelist sa sb) (eqb_type ta tb)) (eqb_calling_convention ca cb)
 | Tstruct ia aa, Tstruct ib ab => andb (eqb_ident ia ib) (eqb_attr aa ab)
 | Tunion ia aa, Tunion ib ab => andb (eqb_ident ia ib) (eqb_attr aa ab)
 | _, _ => false
 end
with eqb_typelist (a b: typelist)  {struct a}: bool :=
  match a, b with
  | Tcons ta ra, Tcons tb rb => andb (eqb_type ta tb) (eqb_typelist ra rb)
  | Tnil, Tnil => true
  | _ , _ => false
  end.

Scheme eqb_type_sch := Induction for type Sort Prop
  with eqb_typelist_sch := Induction for  typelist Sort Prop.

Definition eqb_member (it1 it2: ident * type): bool :=
  eqb_ident (fst it1) (fst it2) && eqb_type (snd it1) (snd it2).

Definition eqb_su (su1 su2: struct_or_union): bool :=
  match su1, su2 with
  | Struct, Struct
  | Union, Union => true
  | _, _ => false
  end.

Lemma eqb_intsize_spec: forall i j, eqb_intsize i j = true <-> i=j.
Lemma eqb_floatsize_spec: forall i j, eqb_floatsize i j = true <-> i=j.
Lemma eqb_signedness_spec: forall i j, eqb_signedness i j = true <-> i=j.
Lemma eqb_attr_spec: forall i j, eqb_attr i j = true <-> i=j.
Lemma eqb_ident_spec: forall i j, eqb_ident i j = true <-> i=j.

Lemma eqb_type_spec: forall a b, eqb_type a b = true <-> a=b.

Lemma eqb_type_true: forall a b, eqb_type a b = true -> a=b.

Lemma eqb_type_false: forall a b, eqb_type a b = false <-> a<>b.

Lemma eqb_type_refl: forall a, eqb_type a a = true.

Lemma eqb_member_spec: forall a b, eqb_member a b = true <-> a=b.

Lemma eqb_su_spec: forall a b, eqb_su a b = true <-> a=b.

Definition log2_sizeof_pointer : N := 
  ltac:(let n := eval compute in 
  (N.log2 (Z.to_N (@sizeof (PTree.empty _) (Tpointer Tvoid noattr))))
   in exact (n)).

Definition int_or_ptr_type : type :=
  Tpointer Tvoid {| attr_volatile := false; attr_alignas := Some log2_sizeof_pointer |}.

Definition bool_val_i (v : val) : option bool :=
match v with
      | Vint n => Some (negb (Int.eq n Int.zero))
      | _ => None
      end.

Definition bool_val_p (v : val) : option bool :=
match v with
      | Vint n => if Archi.ptr64 then None else Some (negb (Int.eq n Int.zero))
      | Vlong n => if Archi.ptr64 then Some (negb (Int64.eq n Int64.zero)) else None
      | Vptr b ofs => Some true
      | _ => None
      end.

Definition bool_val_s (v : val) : option bool :=
 match v with
      | Vsingle f => Some (negb (Float32.cmp Ceq f Float32.zero))
      | _ => None
      end.

Definition bool_val_f (v : val) : option bool :=
 match v with
      | Vfloat f => Some (negb (Float.cmp Ceq f Float.zero))
      | _ => None
      end.

Definition bool_val_l (v : val) : option bool :=
 match v with
      | Vlong n => Some (negb (Int64.eq n Int64.zero))
      | Vptr b ofs =>
          if negb Archi.ptr64 then None else Some true
      | _ => None
      end.

Definition bool_val (t: type) : val -> option bool :=
  match t with
  | Tint _ _ _ => bool_val_i
  | Tpointer _ _ => if  eqb_type t int_or_ptr_type then (fun _ => None) else bool_val_p
  | Tfloat F64 _ => bool_val_f
  | Tfloat F32 _ => bool_val_s
  | Tlong _ _ => bool_val_l
  | _ => fun v => None
  end.

Definition size_t := if Archi.ptr64 then Tlong Unsigned noattr else Tint I32 Unsigned noattr.

Definition is_int (sz: intsize) (sg: signedness) (v: val) :=
  match v with
  | Vint i =>
    match sz, sg with
    | I8, Signed => Byte.min_signed <= Int.signed i <= Byte.max_signed
    | I8, Unsigned => Int.unsigned i <= Byte.max_unsigned
    | I16, Signed => -two_p (16-1) <= Int.signed i <= two_p (16-1) -1
    | I16, Unsigned => Int.unsigned i <= two_p 16 - 1
    | I32, _ => True
    | IBool, _ => i = Int.zero \/ i = Int.one
    end
  | _ => False
  end.

Definition tc_val (ty: type) : val -> Prop :=
 match ty with
 | Tint sz sg _ => is_int sz sg
 | Tlong _ _ => is_long
 | Tfloat F64 _ => is_float
 | Tfloat F32 _ => is_single
 | Tpointer _ _ => if eqb_type ty int_or_ptr_type then is_pointer_or_integer else is_pointer_or_null
 | Tarray _ _ _ | Tfunction _ _ _ => is_pointer_or_null
 | Tstruct _ _ => isptr
 | Tunion _ _ => isptr
 | _ => fun _ => False
 end.

Definition tc_val' t v := v <> Vundef -> tc_val t v.

Fixpoint tc_vals (ty: list type) (v: list val) : Prop :=
 match v, ty with
 | v1::vs , t1::ts => tc_val t1 v1 /\ tc_vals ts vs
 | nil, nil => True
 | _, _ => False
end.

Lemma tc_val_Vundef:
  forall t, ~tc_val t Vundef.

Lemma tc_val'_Vundef:
  forall t, tc_val' t Vundef.

Lemma tc_val_tc_val':
  forall t v, tc_val t v -> tc_val' t v.

Lemma tc_val_has_type (ty : type) (v : val) :
  tc_val ty v ->
  Val.has_type v (typ_of_type ty).

Arguments bool_val t / v  : simpl nomatch. *)



Section cs_preserve.



Context (cs_from cs_to: compspecs).



Definition test_aux (b: bool) (i: ident): bool :=

  b && match (@cenv_cs cs_from) ! i, (@cenv_cs cs_to) ! i with

       | Some co_from, Some co_to => eqb_list eqb_member (co_members co_from) (co_members co_to) && eqb_su (co_su co_from) (co_su co_to) && eqb_attr (co_attr co_from) (co_attr co_to)

       | _, _ => false

       end.



Fixpoint cs_preserve_type (coeq: PTree.t bool) (t: type): bool :=

  match t with

  | Tarray t0 _ _ => cs_preserve_type coeq t0

  | Tstruct id _ => match coeq ! id with | Some b => test_aux b id | _ => false end

  | Tunion id _ => match coeq ! id with | Some b => test_aux b id | _ => false end

  | _ => true

  end.



Fixpoint cs_preserve_members (coeq: PTree.t bool) (m: members): bool :=

  match m with

  | nil => true

  | ((_, t) :: m) => andb (cs_preserve_type coeq t) (cs_preserve_members coeq m)

  end.



Class change_composite_env: Type := {

  coeq: PTree.t bool;

  coeq_consistent:

    forall i co b,

      (@cenv_cs cs_to) ! i = Some co ->

      coeq ! i = Some b ->

      b = cs_preserve_members coeq (co_members co);

  coeq_complete:

    forall i,

      (exists co, (@cenv_cs cs_to) ! i = Some co) <->

      (exists b, coeq ! i = Some b)

}.



Definition cs_preserve_env: PTree.t bool :=

  let l := composite_reorder.rebuild_composite_elements (@cenv_cs cs_to) in

  fold_right (fun (ic: positive * composite) (T0: PTree.t bool) => let (i, co) := ic in let T := T0 in PTree.set i (cs_preserve_members T (co_members co)) T) (PTree.empty _) l.



Lemma aux1: forall T co,

  (fix fm (l : list (ident * type * bool)) : bool :=

   match l with

   | nil => true

   | (_, _, b) :: l' => b && fm l'

   end)

  (map

     (fun it0 : positive * type =>

      let (i0, t0) := it0 in

      (i0, t0,

      type_func.F (fun t : type => match t with | Tstruct _ _ | Tunion _ _ => false | _ => true end) (fun (b : bool) (_ : type) (_ : Z) (_ : attr) => b)

        (fun (b : bool) (id : ident) (_ : attr) => test_aux b id)

        (fun (b : bool) (id : ident) (_ : attr) => test_aux b id) T t0)) (co_members co)) =

  cs_preserve_members T (co_members co).

Proof.

  intros; unfold cs_preserve_members, cs_preserve_type, type_func.F.

  induction (co_members co) as [| [i t] ?].

  + auto.

  + simpl.

    f_equal; auto.

    induction t; auto.

Qed.



Lemma aux2:

  type_func.Env (fun t : type => match t with | Tstruct _ _ | Tunion _ _ => false | _ => true end) (fun (b : bool) (_ : type) (_ : Z) (_ : attr) => b)

        (fun (b : bool) (id : ident) (_ : attr) => test_aux b id)

        (fun (b : bool) (id : ident) (_ : attr) => test_aux b id)

        (fun _ : struct_or_union =>

         fix fm (l : list (ident * type * bool)) : bool :=

           match l with

           | nil => true

           | (_, _, b) :: l' => b && fm l'

           end) (composite_reorder.rebuild_composite_elements cenv_cs) =

  cs_preserve_env.

Proof.

  intros.

  unfold type_func.Env, type_func.env_rec, cs_preserve_env.

  f_equal.

  extensionality ic.

  destruct ic as [i co].

  extensionality T.

  f_equal.

  apply aux1.

Qed.



Lemma cs_preserve_env_consisent: forall (coeq: PTree.t bool),

  coeq = cs_preserve_env ->

  forall i co b,

    (@cenv_cs cs_to) ! i = Some co ->

    coeq ! i = Some b ->

    b = cs_preserve_members coeq (co_members co).

Proof.

  intros.

  pose proof @composite_reorder_consistent bool (@cenv_cs cs_to)

             (fun t : type => match t with | Tstruct _ _ | Tunion _ _ => false | _ => true end)

             (fun b _ _ _ => b)

             (fun b id _ => test_aux b id)

             (fun b id _ => test_aux b id)

             (fun _ =>

                fix fm (l: list (ident * type * bool)): bool :=

                match l with

                | nil => true

                | (_, _, b) :: l' => b && (fm l')

                end)

             (@cenv_consistent cs_to)

    as HH.

  hnf in HH.

  subst coeq0.

  rewrite aux2 in HH.

  specialize (HH _ _ b H0 H1).

  rewrite HH, aux1; auto.

Qed.



Lemma cs_preserve_completeness: forall (coeq: PTree.t bool),

  coeq = cs_preserve_env ->

  forall i,

    (exists co, (@cenv_cs cs_to) ! i = Some co) <->

    (exists b, coeq ! i = Some b).

Proof.

  intros.

  pose proof @composite_reorder_complete bool (@cenv_cs cs_to)

             (fun t : type => match t with | Tstruct _ _ | Tunion _ _ => false | _ => true end)

             (fun b _ _ _ => b)

             (fun b id _ => test_aux b id)

             (fun b id _ => test_aux b id)

             (fun _ =>

                fix fm (l: list (ident * type * bool)): bool :=

                match l with

                | nil => true

                | (_, _, b) :: l' => b && (fm l')

                end)

    as HH.

  hnf in HH.

  subst.

  rewrite aux2 in HH.

  auto.

Qed.



End cs_preserve.



Ltac make_cs_preserve cs_from cs_to :=

  let coeq0 := eval cbv in (cs_preserve_env cs_from cs_to) in

  let Hcoeq0 := constr: (eq_refl: coeq0 = cs_preserve_env cs_from cs_to) in

  let coeq0_consistent := constr: (cs_preserve_env_consisent cs_from cs_to coeq0 Hcoeq0) in

  let coeq0_complete := constr: (cs_preserve_completeness cs_from cs_to coeq0 Hcoeq0) in

  refine (  {| coeq := coeq0 ;

               coeq_consistent := coeq0_consistent;

               coeq_complete := coeq0_complete |}).



Lemma sizeof_composite_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall su (m: members),

  Forall

       (Basics.compose

          (fun t : type =>

           cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->

           @sizeof (@cenv_cs cs_from) t = @sizeof (@cenv_cs cs_to) t /\

           @alignof (@cenv_cs cs_from) t = @alignof (@cenv_cs cs_to) t) snd) m ->

  true = cs_preserve_members cs_from cs_to (coeq cs_from cs_to) m ->

  sizeof_composite (@cenv_cs cs_from) su m = sizeof_composite (@cenv_cs cs_to) su m.

Proof.

  intros.

  symmetry in H0.

  destruct su; simpl; auto.

  + generalize 0 as z.

    induction H as [| [i t] ? ?]; intros; [reflexivity |].

    simpl.

    simpl in H0.

    rewrite andb_true_iff in H0.

    destruct H0.

    apply H in H0; clear H; simpl in H0; destruct H0.

    rewrite H, H0.

    apply (IHForall H2 (align z (alignof t) + sizeof t)).

  + induction H as [| [i t] ? ?]; intros; [reflexivity |].

    simpl.

    simpl in H0.

    rewrite andb_true_iff in H0.

    destruct H0.

    apply H in H0; clear H; simpl in H0; destruct H0.

    f_equal; auto.

Qed.



Lemma alignof_composite_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (m: members),

  Forall

       (Basics.compose

          (fun t : type =>

           cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->

           @sizeof (@cenv_cs cs_from) t = @sizeof (@cenv_cs cs_to) t /\

           @alignof (@cenv_cs cs_from) t = @alignof (@cenv_cs cs_to) t) snd) m ->

  true = cs_preserve_members cs_from cs_to (coeq cs_from cs_to) m ->

  alignof_composite (@cenv_cs cs_from) m = alignof_composite (@cenv_cs cs_to) m.

Proof.

  intros.

  symmetry in H0.

  induction H as [| [i t] ? ?]; intros; [reflexivity |].

  simpl.

  simpl in H0.

  rewrite andb_true_iff in H0.

  destruct H0.

  apply H in H0; clear H; simpl in H0; destruct H0.

  f_equal; auto.

Qed.



Lemma sizeof_alignof_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @sizeof (@cenv_cs cs_from) t = @sizeof (@cenv_cs cs_to) t /\

  @alignof (@cenv_cs cs_from) t = @alignof (@cenv_cs cs_to) t.

Proof.

  intros t.

  type_induction t (@cenv_cs cs_to) (@cenv_consistent cs_to); intros.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + simpl.

    pose proof IH H as [? ?].

    split; f_equal; auto.

  + split; reflexivity.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite (co_consistent_sizeof (@cenv_cs cs_to) c (@cenv_consistent cs_to _ _ H0)).

      rewrite (co_consistent_sizeof (@cenv_cs cs_from) c0 (@cenv_consistent cs_from _ _ H2)).

      rewrite (co_consistent_alignof (@cenv_cs cs_to) c (@cenv_consistent cs_to _ _ H0)).

      rewrite (co_consistent_alignof (@cenv_cs cs_from) c0 (@cenv_consistent cs_from _ _ H2)).

      simpl in H.

      rewrite !andb_true_iff in H; destruct H as [[? ?] ?].

      apply eqb_list_spec in H; [| apply eqb_member_spec].

      apply eqb_su_spec in H3.

      apply eqb_attr_spec in H4.

      apply (coeq_consistent _ _ _ _ _ H0) in H1.

      rewrite H in *; rewrite H4 in  *; rewrite H3 in *; clear c0 H H0 H2 H3 H4.

      split; [f_equal; [ | f_equal] | f_equal; f_equal].

      * apply sizeof_composite_change_composite; auto.

      * apply alignof_composite_change_composite; auto.

      * apply alignof_composite_change_composite; auto.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite (co_consistent_sizeof (@cenv_cs cs_to) c (@cenv_consistent cs_to _ _ H0)).

      rewrite (co_consistent_sizeof (@cenv_cs cs_from) c0 (@cenv_consistent cs_from _ _ H2)).

      rewrite (co_consistent_alignof (@cenv_cs cs_to) c (@cenv_consistent cs_to _ _ H0)).

      rewrite (co_consistent_alignof (@cenv_cs cs_from) c0 (@cenv_consistent cs_from _ _ H2)).

      simpl in H.

      rewrite !andb_true_iff in H; destruct H as [[? ?] ?].

      apply eqb_list_spec in H; [| apply eqb_member_spec].

      apply eqb_su_spec in H3.

      apply eqb_attr_spec in H4.

      apply (coeq_consistent _ _ _ _ _ H0) in H1.

      rewrite H in *; rewrite H4 in  *; rewrite H3 in *; clear c0 H H0 H2 H3 H4.

      split; [f_equal; [ | f_equal] | f_equal; f_equal].

      * apply sizeof_composite_change_composite; auto.

      * apply alignof_composite_change_composite; auto.

      * apply alignof_composite_change_composite; auto.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

Qed.



Lemma sizeof_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @sizeof (@cenv_cs cs_from) t = @sizeof (@cenv_cs cs_to) t.

Proof.

  intros.

  exact (proj1 (sizeof_alignof_change_composite t H)).

Qed.



Lemma alignof_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @alignof (@cenv_cs cs_from) t = @alignof (@cenv_cs cs_to) t.

Proof.

  intros.

  exact (proj2 (sizeof_alignof_change_composite t H)).

Qed.



Lemma complete_legal_cosu_type_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  @complete_legal_cosu_type (@cenv_cs cs_from) t = @complete_legal_cosu_type (@cenv_cs cs_to) t.

Proof.

  intros t.

  type_induction t (@cenv_cs cs_to) (@cenv_consistent cs_to); intros.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + split; reflexivity.

  + simpl.

    apply IH; auto.

  + split; reflexivity.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite !andb_true_iff in H. destruct H as [_ [[? ?] ?]].

      apply eqb_su_spec in H3.

      rewrite H3; auto.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite !andb_true_iff in H. destruct H as [_ [[? ?] ?]].

      apply eqb_su_spec in H3.

      rewrite H3; auto.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

Qed.



Lemma field_offset_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall i m,

  true = cs_preserve_members cs_from cs_to (coeq cs_from cs_to) m ->

  field_offset (@cenv_cs cs_from) i m = field_offset (@cenv_cs cs_to) i m.

Proof.

  intros.

  unfold field_offset.

  generalize 0.

  symmetry in H.

  induction m as [| [i0 t0] m]; [auto |].

  intros.

  simpl in *.

  rewrite andb_true_iff in H.

  destruct H.

  if_tac.

  + subst.

    f_equal.

    f_equal.

    apply alignof_change_composite; auto.

  + rewrite alignof_change_composite by auto.

    rewrite sizeof_change_composite by auto.

    apply IHm; auto.

Qed.



Lemma align_compatible_rec_field_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (m: members),

  true = cs_preserve_members cs_from cs_to (coeq cs_from cs_to) m ->

  Forall

    (Basics.compose

       (fun t : type =>

          cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->

          forall ofs : Z, @align_compatible_rec (@cenv_cs cs_from) t ofs <-> @align_compatible_rec (@cenv_cs cs_to) t ofs) snd)

    m ->

  forall i t,

    field_type i m = Errors.OK t ->

    forall ofs : Z, @align_compatible_rec (@cenv_cs cs_from) t ofs <-> @align_compatible_rec (@cenv_cs cs_to) t ofs.

Proof.

  intros.

  induction H0 as [| [i0 t0] m]; [inv H1 |].

  simpl in H1.

  if_tac in H1.

  + subst.

    inv H1.

    apply H0.

    simpl in H.

    symmetry in H.

    rewrite andb_true_iff in H.

    tauto.

  + apply IHForall; auto.

    simpl in H.

    symmetry in H |- *.

    rewrite andb_true_iff in H.

    tauto.

Qed.



Lemma align_compatible_rec_change_composite {cs_from cs_to} {CCE: change_composite_env cs_from cs_to}: forall (t: type),

  cs_preserve_type cs_from cs_to (coeq _ _) t = true ->

  (forall ofs, @align_compatible_rec (@cenv_cs cs_from) t ofs <-> @align_compatible_rec (@cenv_cs cs_to) t ofs).

Proof.

  intros t.

  type_induction t (@cenv_cs cs_to) (@cenv_consistent cs_to); intros.

  + split; intros;

    inv H0; econstructor; eauto.

  + split; intros;

    inv H0; econstructor; eauto.

  + split; intros;

    inv H0; econstructor; eauto.

  + split; intros;

    inv H0; econstructor; eauto.

  + split; intros;

    inv H0; econstructor; eauto.

  + simpl.

    split; intros.

    - inv H0.

      1: inv H1.

      constructor.

      intros.

      apply IH; auto.

      rewrite <- sizeof_change_composite by auto.

      apply (H5 i); auto.

    - inv H0.

      1: inv H1.

      constructor.

      intros.

      apply IH; auto.

      rewrite sizeof_change_composite by auto.

      apply (H5 i); auto.

  + split; intros;

    inv H0; econstructor; eauto.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite !andb_true_iff in H. destruct H as [_ [[? ?] ?]].

      apply eqb_list_spec in H; [| apply eqb_member_spec].

      apply eqb_su_spec in H3.

      apply eqb_attr_spec in H4.

      apply (coeq_consistent _ _ _ _ _ H0) in H1.

      pose proof align_compatible_rec_field_change_composite _ H1 IH.

      pose proof fun i => field_offset_change_composite i _ H1.

      split; intros.

      * inv H7.

        1: inv H8.

        eapply align_compatible_rec_Tstruct; eauto.

        rewrite H2 in H10; inv H10.

        intros.

        rewrite <- H5 by eauto.

        rewrite <- H in H7, H8.

        eapply H12; eauto.

        rewrite <- H8, H.

        apply H6.

      * inv H7.

        1: inv H8.

        eapply align_compatible_rec_Tstruct; eauto.

        rewrite H0 in H10; inv H10.

        intros.

        rewrite H in H7, H8.

        rewrite H5 by eauto.

        eapply H12; eauto.

        rewrite <- H8.

        symmetry.

        apply H6.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

  + simpl in *.

    unfold test_aux in H.

    destruct ((@cenv_cs cs_to) ! id) eqn:?H.

    - pose proof proj1 (coeq_complete _ _ _) (ex_intro _ _ H0) as [b ?H].

      rewrite H1 in H.

      destruct b; [| inv H].

      destruct ((@cenv_cs cs_from) ! id) eqn:?H; [| inv H].

      rewrite !andb_true_iff in H. destruct H as [_ [[? ?] ?]].

      apply eqb_list_spec in H; [| apply eqb_member_spec].

      apply eqb_su_spec in H3.

      apply eqb_attr_spec in H4.

      apply (coeq_consistent _ _ _ _ _ H0) in H1.

      pose proof align_compatible_rec_field_change_composite _ H1 IH.

      split; intros.

      * inv H6.

        1: inv H7.

        eapply align_compatible_rec_Tunion; eauto.

        rewrite H2 in H9; inv H9.

        intros.

        rewrite <- H5 by eauto.

        rewrite <- H in H6.

        eapply H11; eauto.

      * inv H6.

        1: inv H7.

        eapply align_compatible_rec_Tunion; eauto.

        rewrite H0 in H9; inv H9.

        intros.

        rewrite H in H6.

        rewrite H5 by eauto.

        eapply H11; eauto.

    - destruct ((coeq cs_from cs_to) ! id) eqn:?H.

      * pose proof proj2 (coeq_complete _ _ id) (ex_intro _ b H1) as [co ?].

        congruence.

      * inv H.

Qed.

