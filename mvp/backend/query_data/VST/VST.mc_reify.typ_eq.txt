Require Import types.
(* types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)
Import Coq.Bool.Bool.

Fixpoint typ_beq a b :=
match a, b with
| tytycontext, tytycontext
| tyc_expr, tyc_expr
| tyc_type, tyc_type
| tyenviron, tyenviron
| tyval, tyval
| tyshare, tyshare
| tyident, tyident
| tyint, tyint
| tyZ, tyZ
| tynat, tynat
| typositive, typositive
| tybool, tybool
| tycomparison, tycomparison
| tytc_assert, tytc_assert
| tyint64, tyint64
| tyfloat, tyfloat
| tyattr, tyattr
| tysignedness, tysignedness
| tyintsize, tyintsize
| tyfloatsize, tyfloatsize
| tytypelist, tytypelist
| tyfieldlist, tyfieldlist
| tybinary_operation, tybinary_operation
| tyunary_operation, tyunary_operation
| tyN, tyN
| typrop, typrop
| tympred, tympred
| tyunit, tyunit
| tyOracleKind, tyOracleKind
| tystatement, tystatement
| tygfield, tygfield
| tyfunspec, tyfunspec
| tyret_assert, tyret_assert => true

| tysum tl1 tr1, tysum tl2 tr2
| typrod tl1 tr1, typrod tl2 tr2
| tyArr tl1 tr1, tyArr tl2 tr2 => andb (typ_beq tl1 tl2) (typ_beq tr1 tr2)
| tyoption t1, tyoption t2 => typ_beq t1 t2
| tylist t1, tylist t2 => typ_beq t1 t2
| _, _ => false
end.

SearchAbout BinPos.Pos.eqb.
Hint Resolve expr.eqb_type_true : beq_sound.
Hint Resolve BinPos.Peqb_true_eq : beq_sound.

Ltac prove_beq_sound :=
try solve [try reflexivity; inversion H];
repeat
match goal with
 | [H : typ_beq _ _ = true |- _ ] => simpl in H; rewrite andb_true_iff in H; destruct H
 | [ |- _ _ _ = _ _ _ ] => try f_equal
 | [ |- _ _  = _ _  ] => try f_equal
 | [H : forall x, _ -> ?a = x |- ?a = _ ] => apply H
end;
auto with beq_sound.

Lemma typ_beq_sound : forall a b, typ_beq a b = true -> a = b.
Proof.
intro a.
induction a; intros;  destruct b; prove_beq_sound.
Qed.
