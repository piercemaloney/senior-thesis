Require Import VST.progs.ghosts.
(* VST.progs.ghosts:
Require Import VST.veric.compcert_rmaps.
Require Export VST.msl.ghost.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.veric.SeparationLogic.
Require Import VST.progs.conclib.
Import List.

Hint Resolve Share.nontrivial.

Definition gname := own.gname.

Instance Inhabitant_preds : Inhabitant preds := NoneP.

Section ghost.

Context {RA: Ghost}.

Lemma own_op' : forall g a1 a2 pp,
  own g a1 pp * own g a2 pp = EX a3 : _, !!(join a1 a2 a3 /\ valid a3) && own g a3 pp.

Lemma own_op_gen : forall g a1 a2 a3 pp, (valid_2 a1 a2 -> join a1 a2 a3) ->
  own g a1 pp * own g a2 pp = !!(valid_2 a1 a2) && own g a3 pp.

Lemma own_list_alloc : forall la lp, Forall valid la -> length lp = length la ->
  emp |-- |==> (EX lg : _, !!(Zlength lg = Zlength la) &&
    iter_sepcon (fun '(g, a, p) => own g a p) (combine (combine lg la) lp)).

Corollary own_list_alloc' : forall a pp i, 0 <= i -> valid a ->
  emp |-- |==> (EX lg : _, !!(Zlength lg = i) && iter_sepcon (fun g => own g a pp) lg).

Lemma own_list_dealloc : forall {A} f (l : list A),
  (forall b, exists g a pp, f b |-- own g a pp) ->
  iter_sepcon f l |-- |==> emp.

Lemma own_list_dealloc' : forall {A} g a p (l : list A),
  iter_sepcon (fun x => own (g x) (a x) (p x)) l |-- |==> emp.

End ghost.

Program Instance exclusive_PCM A : Ghost := { valid a := True;
  Join_G := Join_lower (Join_discrete A) }.

Definition excl {A} g a := own(RA := exclusive_PCM A) g (Some a) NoneP.

Lemma exclusive_update : forall {A} (v v' : A) p, excl p v |-- |==> excl p v'.

Class PCM_order `{P : Ghost} (ord : G -> G -> Prop) := { ord_refl :> RelationClasses.Reflexive ord;
  ord_trans :> RelationClasses.Transitive ord;
  ord_lub : forall a b c, ord a c -> ord b c -> {c' | join a b c' /\ ord c' c};
  join_ord : forall a b c, join a b c -> ord a c /\ ord b c; ord_join : forall a b, ord b a -> join a b a }.

Section Snapshot.

Context `{ORD : PCM_order}.

Lemma join_refl : forall (v : G), join v v v.

Lemma join_compat : forall v1 v2 v' v'', join v2 v' v'' -> ord v1 v2 -> exists v0, join v1 v' v0 /\ ord v0 v''.

Lemma join_ord_eq : forall a b, ord a b <-> exists c, join a c b.

Definition ghost_snap (a : @G P) p := own p (Share.bot, a) NoneP.

Lemma ghost_snap_join : forall v1 v2 p v, join v1 v2 v ->
  ghost_snap v1 p * ghost_snap v2 p = ghost_snap v p.

Lemma ghost_snap_conflict : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p |-- !!(joins v1 v2).

Lemma ghost_snap_join' : forall v1 v2 p,
  ghost_snap v1 p * ghost_snap v2 p = EX v : _, !!(join v1 v2 v) && ghost_snap v p.

Definition ghost_master sh (a : @G P) p := own p (sh, a) NoneP.

Lemma snap_master_join : forall v1 sh v2 p, sh <> Share.bot ->

Corollary snaps_master_join : forall lv sh v2 p, sh <> Share.bot ->

Lemma master_update : forall v v' p, ord v v' -> ghost_master Tsh v p |-- |==> ghost_master Tsh v' p.

Lemma master_init : forall (a : @G P), exists g', joins (Tsh, a) g'.

Lemma make_snap : forall (sh : share) v p, ghost_master sh v p |-- |==> ghost_snap v p * ghost_master sh v p.

Lemma ghost_snap_forget : forall v1 v2 p, ord v1 v2 -> ghost_snap v2 p |-- |==> ghost_snap v1 p.

Lemma ghost_snap_choose : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p |-- |==> ghost_snap v1 p.

Lemma master_share_join : forall sh1 sh2 sh v p, sepalg.join sh1 sh2 sh ->

Lemma master_inj : forall sh1 sh2 v1 v2 p, readable_share sh1 -> readable_share sh2 ->
  ghost_master sh1 v1 p * ghost_master sh2 v2 p |-- !!(v1 = v2).

Lemma master_share_join' : forall sh1 sh2 sh v1 v2 p, readable_share sh1 -> readable_share sh2 ->
  sepalg.join sh1 sh2 sh ->

Definition ghost_master1 a p := ghost_master Tsh a p.

Lemma snap_master_join1 : forall v1 v2 p,
  ghost_snap v1 p * ghost_master1 v2 p = !!(ord v1 v2) && ghost_master1 v2 p.

Lemma snap_master_update1 : forall v1 v2 p v', ord v2 v' ->
  ghost_snap v1 p * ghost_master1 v2 p |-- |==> ghost_snap v' p * ghost_master1 v' p.

End Snapshot.

Definition pos_PCM := ghost_PCM.pos_PCM.
Definition ref_PCM := ghost_PCM.ref_PCM.
Notation completable := ghost_PCM.completable.

Section Reference.

Context {P : Ghost}.

Definition ghost_reference g a := own(RA := ref_PCM P) g (None, Some a) NoneP.
Definition ghost_part g sh a := own(RA := ref_PCM P) g (Some (sh, a), None) NoneP.
Definition ghost_part_ref g sh a r :=
  own(RA := ref_PCM P) g (Some (sh, a), Some r) NoneP.

Lemma ghost_part_ref_join : forall g (sh : share) a b,
  ghost_part g sh a * ghost_reference g b = ghost_part_ref g sh a b.

Lemma ref_sub : forall g sh a b pp,
  own(RA := ref_PCM P) g (Some (sh, a), None) pp * own(RA := ref_PCM P) g (None, Some b) pp |--
    !!(if eq_dec sh Tsh then a = b else exists x, join a x b).

Lemma ref_add : forall g sh a r b a' r' pp
  (Ha : join a b a') (Hr : join r b r') (Hb : forall c, join_sub a c -> join_sub c r -> joins c b),
  own(RA := ref_PCM P) g (Some (sh, a), Some r) pp |-- |==>
  own(RA := ref_PCM P) g (Some (sh, a'), Some r') pp.

Lemma self_completable : forall a, completable (Some (Tsh, a)) a.

End Discrete.

Section GVar.

Context {A : Type}.

Definition ghost_var (sh : share) (v : A) g :=
  own(RA := @pos_PCM (discrete_PCM A)) g (Some (sh, v)) NoneP.

Lemma ghost_var_share_join : forall sh1 sh2 sh v p, sepalg.join sh1 sh2 sh ->

Lemma ghost_var_share_join_gen : forall sh1 sh2 v1 v2 p,
  ghost_var sh1 v1 p * ghost_var sh2 v2 p = EX sh : _,
  !!(v1 = v2 /\ sh1 <> Share.bot /\ sh2 <> Share.bot /\ sepalg.join sh1 sh2 sh) && ghost_var sh v1 p.

Lemma ghost_var_inj : forall sh1 sh2 v1 v2 p, sh1 <> Share.bot -> sh2 <> Share.bot ->

Lemma ghost_var_share_join' : forall sh1 sh2 sh v1 v2 p, sh1 <> Share.bot -> sh2 <> Share.bot ->

Lemma ghost_var_update : forall v p v', ghost_var Tsh v p |-- |==> ghost_var Tsh v' p.

Global Instance max_order : PCM_order le.

Lemma ghost_snap_join_N : forall v1 v2 p, ghost_snap v1 p * ghost_snap v2 p = ghost_snap (Nat.max v1 v2) p.

Lemma snap_master_join' : forall v1 v2 p,
  ghost_snap v1 p * ghost_master1 v2 p = !!(v1 <= v2)%nat && ghost_master1 v2 p.

Lemma snap_master_update' : forall (v1 v2 : nat) p v', (v2 <= v')%nat ->
  ghost_snap v1 p * ghost_master1 v2 p |-- |==> ghost_snap v' p * ghost_master1 v' p.

End PVar.

Section Maps.

Context {A B : Type} {A_eq : EqDec A}.

Implicit Types (k : A) (v : B) (m : A -> option B).

Definition map_upd m k v k' := if eq_dec k' k then Some v else m k'.

Lemma map_upd_triv : forall m k v, m k = Some v -> map_upd m k v = m.

Fixpoint map_upd_list m l :=
  match l with
  | [] => m
  | (k, v) :: rest => map_upd_list (map_upd m k v) rest
  end.

Definition map_add m1 m2 k := match m1 k with Some v' => Some v' | None => m2 k end.

Definition empty_map k : option B := None.

Global Instance Inhabitant_map : Inhabitant (A -> option B) := empty_map.

Definition singleton k v k1 := if eq_dec k1 k then Some v else None.

Definition map_incl m1 m2 := forall k v, m1 k = Some v -> m2 k = Some v.

Global Instance map_incl_refl : Reflexive map_incl.

Global Instance map_incl_antisym : Antisymmetric _ _ map_incl.

Global Instance map_incl_trans : Transitive map_incl.

Lemma map_add_incl_compat : forall m1 m2 m3, map_incl m1 m2 -> map_incl (map_add m3 m1) (map_add m3 m2).

Definition compatible m1 m2 := forall k v1 v2, m1 k = Some v1 -> m2 k = Some v2 -> v1 = v2.

Global Instance compatible_refl : Reflexive compatible.

Global Instance compatible_comm : Symmetric compatible.

Lemma map_add_comm : forall m1 m2, compatible m1 m2 -> map_add m1 m2 = map_add m2 m1.

Lemma map_add_assoc : forall m1 m2 m3, map_add (map_add m1 m2) m3 = map_add m1 (map_add m2 m3).

Lemma compatible_add_assoc : forall m1 m2 m3, compatible m1 m2 ->
  compatible (map_add m1 m2) m3 -> compatible m1 (map_add m2 m3).

Lemma compatible_incl : forall m1 m2 m (Hcompat : compatible m2 m) (Hincl : map_incl m1 m2), compatible m1 m.

Lemma map_incl_add : forall m1 m2, map_incl m1 (map_add m1 m2).

Lemma map_incl_compatible : forall m1 m2 m3 (Hincl1 : map_incl m1 m3) (Hincl2 : map_incl m2 m3),
  compatible m1 m2.

Lemma map_add_incl : forall m1 m2 m3, map_incl m1 m3 -> map_incl m2 m3 -> map_incl (map_add m1 m2) m3.

Global Instance map_join : Join (A -> option B) :=
  fun a b c => forall k v, c k = Some v <-> a k = Some v \/ b k = Some v.

Lemma map_join_spec : forall m1 m2 m3, join m1 m2 m3 <-> compatible m1 m2 /\ m3 = map_add m1 m2.

Lemma map_snap_join : forall m1 m2 p,
  ghost_snap m1 p * ghost_snap m2 p = !!(compatible m1 m2) && ghost_snap (map_add m1 m2) p.

Lemma map_upd_list_app : forall l1 l2 m, map_upd_list m (l1 ++ l2) = map_upd_list (map_upd_list m l1) l2.

Lemma map_upd_list_out : forall l m k, m k = None -> ~In k (map fst l) -> map_upd_list m l k = None.

Lemma compatible_k : forall m1 m2 (Hcompat : compatible m1 m2) k v, m2 k = Some v -> map_add m1 m2 k = Some v.

Lemma map_join_incl_compat : forall m1 m2 m' m'' (Hincl : map_incl m1 m2) (Hjoin : join m2 m' m''),
  exists m, join m1 m' m /\ map_incl m m''.

Lemma map_add_empty : forall m, map_add m empty_map = m.

Lemma map_upd_incl : forall m1 m2 k v, map_incl m1 m2 ->
  m2 k = Some v -> map_incl (map_upd m1 k v) m2.

Lemma map_add_single : forall m k v, map_add (singleton k v) m = map_upd m k v.

Lemma incl_compatible : forall m1 m2, map_incl m1 m2 -> compatible m1 m2.

Lemma map_add_redundant : forall m1 m2, map_incl m1 m2 -> map_add m1 m2 = m2.

Lemma empty_map_incl : forall m, map_incl empty_map m.

Lemma map_upd2_incl : forall m1 m2 k v, map_incl m1 m2 -> map_incl (map_upd m1 k v) (map_upd m2 k v).

Lemma compatible_upd : forall m1 m2 k v, compatible m1 m2 -> m2 k = None ->
  compatible (map_upd m1 k v) m2.

Lemma map_add_upd : forall m1 m2 k v, map_upd (map_add m1 m2) k v = map_add (map_upd m1 k v) m2.

Notation maps_add l := (fold_right map_add empty_map l).

Lemma in_maps_add : forall l (k : A) (v : B), maps_add l k = Some v -> exists m, In m l /\ m k = Some v.

Definition all_compatible (l : list (A -> option B)) := forall m1 m2, In m1 l -> In m2 l -> compatible m1 m2.

Lemma all_compatible_cons : forall (m : A -> option B) l, all_compatible (m :: l) -> compatible m (maps_add l) /\ all_compatible l.

Lemma maps_add_in : forall l m (k : A) (v : B) (Hcompat : all_compatible l),
  In m l -> m k = Some v -> maps_add l k = Some v.

Lemma fold_right_maps_add : forall l (e : A -> option B), fold_right map_add e l = map_add (maps_add l) e.

Section Maps_Disjoint.

Definition disjoint m1 m2 := forall k v1, m1 k = Some v1 -> m2 k = None.

Global Instance disjoint_comm : Symmetric disjoint.

Lemma disjoint_compatible : forall m1 m2, disjoint m1 m2 -> compatible m1 m2.

Instance map_disj_join : Join (A -> option B) :=
  fun a b c => forall k, match a k, b k with Some v, None | None, Some v => c k = Some v | None, None => c k = None | _, _ => False end.

Lemma map_disj_join_spec : forall m1 m2 m3, join m1 m2 m3 <-> disjoint m1 m2 /\ m3 = map_add m1 m2.

Lemma disjoint_incl : forall m1 m2 m (Hcompat : disjoint m2 m) (Hincl : map_incl m1 m2), disjoint m1 m.

Lemma disjoint_add : forall m1 m2 m3, disjoint m1 m2 -> disjoint m1 m3 -> disjoint m1 (map_add m2 m3).

Lemma disj_join_sub : forall m1 m2, map_incl m1 m2 -> exists m3, join m1 m3 m2.

Definition all_disjoint (l : list (A -> option B)) := forall i j, 0 <= i < Zlength l -> 0 <= j < Zlength l ->
  i <> j -> disjoint (Znth i l) (Znth j l).

Lemma all_disjoint_compatible : forall l, all_disjoint l -> all_compatible l.

Lemma all_disjoint_nil : all_disjoint [].

Lemma all_disjoint_cons : forall (m : A -> option B) l, all_disjoint (m :: l) <-> disjoint m (maps_add l) /\ all_disjoint l.

Lemma all_disjoint_rev1 : forall l, all_disjoint l -> all_disjoint (rev l).

Lemma all_disjoint_rev : forall l, all_disjoint l <-> all_disjoint (rev l).

Lemma maps_add_rev : forall l, all_compatible l -> maps_add (rev l) = maps_add l.

Lemma all_disjoint_snoc : forall m l, all_disjoint (l ++ [m]) <-> disjoint m (maps_add l) /\ all_disjoint l.

Lemma empty_map_disjoint : forall m, disjoint empty_map m.

Definition map_sub (m : A -> option B) k := fun x => if eq_dec x k then None else m x.

Lemma map_upd_sub : forall m (k : A) (v : B), m k = Some v -> map_upd (map_sub m k) k v = m.

Lemma map_sub_upd : forall m (k : A) (v : B), m k = None -> map_sub (map_upd m k v) k = m.

Lemma disjoint_sub : forall (m1 m2 : A -> option B) k, disjoint m1 m2 ->
  disjoint (map_sub m1 k) m2.

End Maps_Disjoint.

End Maps.

Notation maps_add l := (fold_right map_add empty_map l).

Hint Resolve empty_map_incl empty_map_disjoint all_disjoint_nil.

Section GHist.

Context {hist_el : Type}.

Notation hist_part := (nat -> option hist_el).

Definition hist_sub sh (h : hist_part) hr := sh <> Share.bot /\ if eq_dec sh Tsh then h = hr
  else map_incl h hr.

Lemma completable_alt : forall sh h hr, @completable map_disj_PCM (Some (sh, h)) hr <-> hist_sub sh h hr.

Lemma hist_sub_upd : forall sh h hr t' e (Hsub : hist_sub sh h hr),
  hist_sub sh (map_upd h t' e) (map_upd hr t' e).

Definition ghost_hist (sh : share) (h : hist_part) g :=
  own(RA := ref_PCM map_disj_PCM) g (Some (sh, h), None) NoneP.

Lemma ghost_hist_join : forall sh1 sh2 sh h1 h2 p (Hsh : sepalg.join sh1 sh2 sh)

Definition hist_incl (h : hist_part) l := forall t e, h t = Some e -> nth_error l t = Some e.

Definition hist_list (h : hist_part) l := forall t e, h t = Some e <-> nth_error l t = Some e.

Lemma hist_list_inj : forall h l1 l2 (Hl1 : hist_list h l1) (Hl2 : hist_list h l2), l1 = l2.

Lemma hist_list_nil_inv1 : forall l, hist_list empty_map l -> l = [].

Lemma hist_list_nil_inv2 : forall h, hist_list h [] -> h = empty_map.

Definition ghost_ref l g := EX hr : hist_part, !!(hist_list hr l) &&
  own(RA := ref_PCM map_disj_PCM) g (None, Some hr) NoneP.

Lemma hist_next : forall h l (Hlist : hist_list h l), h (length l) = None.

Definition ghost_hist_ref sh (h r : hist_part) g :=
  own(RA := ref_PCM map_disj_PCM) g (Some (sh, h), Some r) NoneP.

Lemma hist_add : forall (sh : share) (h h' : hist_part) e p t' (Hfresh : h' t' = None),
  ghost_hist_ref sh h h' p |-- |==> ghost_hist_ref sh (map_upd h t' e) (map_upd h' t' e) p.

Lemma hist_incl_nil : forall h, hist_incl empty_map h.

Lemma hist_list_nil : hist_list empty_map [].

Lemma hist_list_snoc : forall h l e, hist_list h l ->
  hist_list (map_upd h (length l) e) (l ++ [e]).

Lemma hist_sub_list_incl : forall sh h h' l (Hsub : hist_sub sh h h') (Hlist : hist_list h' l),
  hist_incl h l.

Lemma hist_sub_Tsh : forall h h', hist_sub Tsh h h' <-> (h = h').

Lemma hist_ref_join : forall sh h l p, sh <> Share.bot ->

Corollary hist_ref_join_nil : forall sh p, sh <> Share.bot ->

Lemma hist_ref_incl : forall sh h h' p, sh <> Share.bot ->

Lemma hist_add' : forall sh h h' e p, sh <> Share.bot ->

Definition newer (l : hist_part) t := forall t', l t' <> None -> (t' < t)%nat.

Lemma newer_trans : forall l t1 t2, newer l t1 -> (t1 <= t2)%nat -> newer l t2.

Corollary newer_upd : forall l t1 e t2, newer l t1 -> (t1 < t2)%nat ->
  newer (map_upd l t1 e) t2.

Lemma newer_over : forall h t t', newer h t -> (t <= t')%nat -> h t' = None.

Corollary newer_out : forall h t, newer h t -> h t = None.

Lemma add_new_inj : forall h h' t t' v v' (Ht : newer h t) (Ht' : newer h' t'),
  map_upd h t v = map_upd h' t' v' -> h = h' /\ t = t' /\ v = v'.

Lemma hist_incl_lt : forall h l, hist_incl h l -> newer h (length l).

Corollary hist_list_lt : forall h l, hist_list h l -> newer h (length l).

Inductive hist_list' : hist_part -> list hist_el -> Prop :=
| hist_list'_nil : hist_list' empty_map []
| hist_list'_snoc : forall h l t e (Hlast : newer h t) (Hrest : hist_list' h l),
    hist_list' (map_upd h t e) (l ++ [e]).
Hint Resolve hist_list'_nil.

Lemma hist_list'_in : forall h l (Hl : hist_list' h l) e, (exists t, h t = Some e) <-> In e l.

Lemma hist_list_weak : forall l h (Hl : hist_list h l), hist_list' h l.

Lemma hist_list'_add : forall h1 h2 (l : list hist_el) (Hdisj : disjoint h1 h2), hist_list' (map_add h1 h2) l ->
  exists l1 l2, Permutation l (l1 ++ l2) /\ hist_list' h1 l1 /\ hist_list' h2 l2.

Lemma ghost_hist_init : @valid (ref_PCM (@map_disj_PCM nat hist_el)) (Some (Tsh, empty_map), Some empty_map).

Inductive add_events h : list hist_el -> hist_part -> Prop :=
| add_events_nil : add_events h [] h
| add_events_snoc : forall le h' t e (Hh' : add_events h le h') (Ht : newer h' t),
    add_events h (le ++ [e]) (map_upd h' t e).
Hint Resolve add_events_nil.

Lemma add_events_1 : forall h t e (Ht : newer h t), add_events h [e] (map_upd h t e).

Lemma add_events_trans : forall h le h' le' h'' (H1 : add_events h le h') (H2 : add_events h' le' h''),
  add_events h (le ++ le') h''.

Lemma add_events_add : forall h le h', add_events h le h' ->
  exists h2, h' = map_add h h2 /\ forall t e, h2 t = Some e -> newer h t /\ In e le.

Corollary add_events_dom : forall h le h' t e, add_events h le h' -> h' t = Some e ->
  h t = Some e \/ In e le.

Corollary add_events_incl : forall h le h', add_events h le h' -> map_incl h h'.

Corollary add_events_newer : forall h le h' t, add_events h le h' -> newer h' t -> newer h t.

Lemma add_events_in : forall h le h' e, add_events h le h' -> In e le ->
  exists t, newer h t /\ h' t = Some e.

End GHist.

Hint Resolve hist_incl_nil hist_list_nil hist_list'_nil add_events_nil.

Hint Resolve  master_init  ghost_hist_init : init.

Ltac ghost_alloc G :=
  match goal with |-semax _ (PROPx ?P (LOCALx ?Q (SEPx ?R))) _ _ =>
    apply (semax_pre_bupd (PROPx P (LOCALx Q (SEPx ((EX g : _, G g) :: R)))));
  [go_lower; rewrite !prop_true_andp by (repeat (split; auto));
   rewrite <- emp_sepcon at 1; eapply derives_trans, bupd_frame_r;
   apply sepcon_derives, derives_refl; apply own_alloc; auto; simpl; auto with init|] end.

Ltac ghosts_alloc G n :=
  match goal with |-semax _ (PROPx ?P (LOCALx ?Q (SEPx ?R))) _ _ =>
    apply (semax_pre_bupd (PROPx P (LOCALx Q (SEPx ((EX lg : _, !!(Zlength lg = n) && iter_sepcon G lg) :: R)))));
  [go_lower; rewrite !prop_true_andp by (repeat (split; auto));
   rewrite <- emp_sepcon at 1; eapply derives_trans, bupd_frame_r;
   apply sepcon_derives, derives_refl; apply own_list_alloc'; auto; simpl; auto with init|] end.

Program Definition weak_view_shift (P Q: mpred): mpred :=
  fun w => predicates_hered.derives (approx (S (level w)) P) (own.bupd (approx (S (level w)) Q)).

Lemma view_shift_nonexpansive: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift (approx n P) (approx n Q)).

Lemma view_shift_nonexpansive_l: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift (approx n P) Q).

Lemma view_shift_nonexpansive_R: forall P Q n,
  approx n (weak_view_shift P Q) = approx n (weak_view_shift P (approx n Q)).

Lemma view_shift_weak: forall P Q, P |-- |==> Q -> TT |-- weak_view_shift P Q.

Lemma apply_view_shift: forall P Q, (weak_view_shift P Q && emp) * P |-- |==> Q. *)

Require Import atomics.verif_atomics.
(* atomics.verif_atomics:
Definition acquire_spec := DECLARE _acquire acquire_spec.
Definition release_spec := DECLARE _release release_spec.
Definition makelock_spec := DECLARE _makelock (makelock_spec _).
Definition freelock_spec := DECLARE _freelock (freelock_spec _).

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH n:Z
   PRE [ _n OF tuint ]
       PROP (0 <= n <= Int.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh n p * memory_block Tsh n p).

Definition tatomic := Tstruct _atomic_loc noattr.

Definition A_inv p l R := EX v : Z, !!(repable_signed v) &&
  (field_at Tsh tatomic [StructField _val] (vint v) p * R v *
   (weak_precise_mpred (R v) && emp) * malloc_token Tsh (sizeof tatomic) p * malloc_token Tsh (sizeof tlock) l).

Definition atomic_loc sh p R := !!(field_compatible tatomic [] p) &&
  (EX lock : val, field_at sh tatomic [StructField _lock] lock p * lock_inv sh lock (A_inv p lock R)).

Lemma A_inv_super_non_expansive : forall n p l R,
  compcert_rmaps.RML.R.approx n (A_inv p l R) =

Lemma atomic_loc_super_non_expansive : forall n sh p R,
  compcert_rmaps.RML.R.approx n (atomic_loc sh p R) =

Definition MA_spec i P (R : Z -> mpred) Q := view_shift P (R i * (weak_precise_mpred (R i) && emp) * Q).

Definition MA_type := ProdType (ProdType (ProdType (ConstType Z) Mpred) (ArrowType (ConstType Z) Mpred)) Mpred.

Program Definition make_atomic_spec := DECLARE _make_atomic TYPE MA_type
  WITH i : Z, P : mpred, R : Z -> mpred, Q : mpred
  PRE [ _i OF tint ]
   PROP (MA_spec i P R Q; repable_signed i)
   LOCAL (temp _i (vint i))
   SEP (P)
  POST [ tptr tatomic ]
   EX p : val,
   PROP ()
   LOCAL (temp ret_temp p)
   SEP (atomic_loc Tsh p R; Q).

Program Definition free_atomic_spec := DECLARE _free_atomic
  TYPE ProdType (ConstType val) (ArrowType (ConstType Z) Mpred)
  WITH p : val, R : Z -> mpred
  PRE [ _tgt OF tptr tatomic ]
   PROP ()
   LOCAL (temp _tgt p)
   SEP (atomic_loc Tsh p R)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (R v).

Definition AL_spec P (R : Z -> mpred) Q := forall vx, repable_signed vx -> view_shift (R vx * P) (R vx * Q vx).

Definition AL_type := ProdType (ProdType (ProdType (ConstType (share * val))
  Mpred) (ArrowType (ConstType Z) Mpred)) (ArrowType (ConstType Z) Mpred).

Program Definition load_SC_spec := DECLARE _load_SC TYPE AL_type
  WITH sh : share, tgt : val, P : mpred, R : Z -> mpred, Q : Z -> mpred
  PRE [ _tgt OF tptr tatomic ]
   PROP (AL_spec P R Q; readable_share sh)
   LOCAL (temp _tgt tgt)
   SEP (atomic_loc sh tgt R; P)
  POST [ tint ]
   EX v : Z,
   PROP (repable_signed v)
   LOCAL (temp ret_temp (vint v))
   SEP (atomic_loc sh tgt R; Q v).

Definition AS_spec v P (R : Z -> mpred) Q := forall vx, repable_signed vx ->
  view_shift (R vx * P)
  (R v * (weak_precise_mpred (R v) && emp) * Q).

Definition AS_type := ProdType (ProdType (ProdType
  (ConstType (share * val * Z)) Mpred) (ArrowType (ConstType Z) Mpred)) Mpred.

Program Definition store_SC_spec := DECLARE _store_SC
  TYPE AS_type WITH sh : share, tgt : val, v : Z, P : mpred, R : Z -> mpred, Q : mpred
  PRE [ _tgt OF tptr tatomic, _v OF tint ]
   PROP (AS_spec v P R Q; readable_share sh; repable_signed v)
   LOCAL (temp _tgt tgt; temp _v (vint v))
   SEP (atomic_loc sh tgt R; P)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (atomic_loc sh tgt R; Q).

Definition ACAS_spec c v P (R Q : Z -> mpred) := forall vx, repable_signed vx ->
  view_shift (R vx * P)
  (R (if eq_dec c vx then v else vx) * (weak_precise_mpred (R (if eq_dec c vx then v else vx)) && emp) * Q vx).

Definition ACAS_type := ProdType (ProdType (ProdType
  (ConstType (share * val * Z * Z)) Mpred)
  (ArrowType (ConstType Z) Mpred))
  (ArrowType (ConstType Z) Mpred).

Program Definition CAS_SC_spec := DECLARE _CAS_SC
  TYPE ACAS_type WITH sh : share, tgt : val, c : Z, v : Z, P : mpred, R : Z -> mpred, Q : Z -> mpred
  PRE [ _tgt OF tptr tatomic, _c OF tint, _v OF tint ]
   PROP (ACAS_spec c v P R Q; readable_share sh; repable_signed c; repable_signed v)
   LOCAL (temp _tgt tgt; temp _c (vint c); temp _v (vint v))
   SEP (atomic_loc sh tgt R; P)
  POST [ tint ]
   EX v' : Z,
   PROP (repable_signed v')
   LOCAL (temp ret_temp (if eq_dec c v' then vint 1 else vint 0))
   SEP (atomic_loc sh tgt R; Q v').

Definition Gprog : funspecs := ltac:(with_library prog [acquire_spec; release_spec; makelock_spec; freelock_spec;
  surely_malloc_spec; make_atomic_spec; free_atomic_spec; load_SC_spec; store_SC_spec; CAS_SC_spec]).

Lemma body_surely_malloc: semax_body Vprog Gprog f_surely_malloc surely_malloc_spec.

Lemma A_inv_positive : forall x l R, positive_mpred (A_inv x l R).
Hint Resolve A_inv_positive.

Lemma A_inv_precise : forall x l R,
  predicates_hered.derives TT (weak_precise_mpred (A_inv x l R)).

Lemma body_make_atomic : semax_body Vprog Gprog f_make_atomic make_atomic_spec.

Lemma body_free_atomic : semax_body Vprog Gprog f_free_atomic free_atomic_spec.

Lemma body_load_SC : semax_body Vprog Gprog f_load_SC load_SC_spec.

Lemma body_store_SC : semax_body Vprog Gprog f_store_SC store_SC_spec.

Lemma body_CAS_SC : semax_body Vprog Gprog f_CAS_SC CAS_SC_spec.

Lemma atomic_loc_isptr : forall sh p R, atomic_loc sh p R = !!isptr p && atomic_loc sh p R.
Hint Resolve atomic_loc_isptr : saturate_local.

Lemma atomic_loc_precise : forall sh p R, readable_share sh -> precise (atomic_loc sh p R).

Lemma atomic_loc_join : forall sh1 sh2 sh p R (Hjoin : sepalg.join sh1 sh2 sh)

Fixpoint apply_hist a h :=
  match h with
  | [] => Some a
  | Load v :: h' => if eq_dec v a then apply_hist a h' else None
  | Store v :: h' => apply_hist v h'
  | CAS r c w :: h' => if eq_dec r a then if eq_dec c a then apply_hist w h' else apply_hist a h' else None
  end.

Notation hist := (list (nat * hist_el)).

Lemma apply_hist_app : forall h1 i h2, apply_hist i (h1 ++ h2) =
  match apply_hist i h1 with Some v => apply_hist v h2 | None => None end.

Definition writes e v :=
  match e with
  | Load _ => False
  | Store v' => v' = v
  | CAS r c v' => r = c /\ v' = v
  end.

Lemma change_implies_write : forall v h i, apply_hist i h = Some v -> v <> i ->
  exists e, In e h /\ writes e v.

Definition value_of e :=
  match e with
  | Load v => v
  | Store v => v
  | CAS r c w => if eq_dec r c then w else r
  end.

Lemma apply_one_value : forall i a v, apply_hist i [a] = Some v -> value_of a = v.

Definition last_value (h : hist) v :=
  
  (h = [] /\ v = vint 0) \/
  exists n e, In (n, e) h /\ value_of e = v /\ Forall (fun x => let '(m, _) := x in m <= n)%nat h.

Lemma last_value_new : forall h n e, newer h n ->
  last_value (h ++ [(n, e)]) (value_of e).

Definition value_of_hist (h : hist) := value_of (snd (last h (O, Store (vint 0)))).

Lemma value_of_hist_snoc : forall h t e, value_of_hist (h ++ [(t, e)]) = value_of e.

Notation ordered_hist := (ordered_hist (Store (vint 0))).

Lemma ordered_last_value : forall h v (Hordered : ordered_hist h), last_value h v <-> value_of_hist h = v.

Lemma hist_list_value : forall h l v (Horder : ordered_hist h) (Hl : hist_list h l)
  (Hv : apply_hist (vint 0) l = Some v), value_of_hist h = v.

Definition full_hist h v := exists l, hist_list h l /\ apply_hist (vint 0) l = Some (vint v).

Definition full_hist' h v := exists l, hist_list' h l /\ apply_hist (vint 0) l = Some v.

Lemma full_hist_weak : forall h v (Hl : full_hist h v), full_hist' h (vint v).

Lemma full_hist'_drop : forall h h' v (Hh : full_hist' h v)
  (Hh' : incl h' h) (HNoDup : NoDup (map fst h'))
  (Hdiff : forall t e, In (t, e) h -> ~In (t, e) h' -> forall v, ~writes e v),
  full_hist' h' v.

Lemma full_hist'_nil : forall n l, Forall2 full_hist' (repeat [] n) l -> l = repeat (vint 0) n.

Corollary full_hist_nil' : forall n l (Hfull : Forall2 full_hist' (repeat [] n) (map (fun x => vint x) l))
  (Hrep : Forall repable_signed l), l = repeat 0 n.

Corollary full_hist_nil : forall n l (Hfull : Forall2 full_hist (repeat [] n) l)
  (Hrep : Forall repable_signed l), l = repeat 0 n.

Definition int_op e :=
  match e with
  | Load v | Store v => tc_val tint v
  | CAS r c w => tc_val tint r /\ tc_val tint c /\ tc_val tint w
  end.

Definition make_int v := match v with Vint i => Int.signed i | _ => 0 end.

Lemma make_int_spec : forall v, tc_val tint v -> vint (make_int v) = v.

Lemma make_int_repable : forall v, repable_signed (make_int v).

Lemma int_op_value : forall e, int_op e -> tc_val tint (value_of e).

Corollary int_op_value_of_hist : forall h, Forall int_op (map snd h) -> tc_val tint (value_of_hist h).

Lemma apply_int_ops : forall v h i (Hv : apply_hist (Vint i) h = Some v)
  (Hints : Forall int_op h), tc_val tint v.

Definition hist_R g i R v := EX h : _, !!(apply_hist (vint i) h = Some (vint v)) && ghost_ref h g * R h v.

Definition atomic_loc_hist sh p g i R (h : hist) := atomic_loc sh p (hist_R g i R) * ghost_hist sh h g.

Lemma atomic_loc_hist_isptr : forall sh p g i R h,
  atomic_loc_hist sh p g i R h = !!(isptr p) && atomic_loc_hist sh p g i R h.
Hint Resolve atomic_loc_hist_isptr : saturate_local.

Lemma hist_R_precise : forall p i R v, precise (EX h : _, R h v) -> precise (hist_R p i R v).
Hint Resolve hist_R_precise.

Lemma atomic_loc_hist_precise : forall sh p g i R, readable_share sh ->
  precise (EX h : _, atomic_loc_hist sh p g i R h).

Notation init_hist := (Some (Tsh, [] : hist), Some ([] : hist)).

Notation MA_witness g i R :=
  (i%Z, ghost init_hist g * R%function [] i%Z, hist_R g i R, ghost_hist Tsh ([] : hist) g).
Lemma MA_hist_spec : forall g i R, precise (EX h : _, R h i) ->
  MA_spec i (ghost init_hist g * R [] i) (hist_R g i R) (ghost_hist Tsh ([] : hist) g).

Inductive add_events h : list hist_el -> hist -> Prop :=
| add_events_nil : add_events h [] h
| add_events_snoc : forall le h' t e (Hh' : add_events h le h') (Ht : newer h' t),
    add_events h (le ++ [e]) (h' ++ [(t, e)]).
Hint Resolve add_events_nil.

Lemma add_events_1 : forall h t e (Ht : newer h t), add_events h [e] (h ++ [(t, e)]).

Lemma add_events_trans : forall h le h' le' h'' (H1 : add_events h le h') (H2 : add_events h' le' h''),
  add_events h (le ++ le') h''.

Lemma add_events_add : forall h le h', add_events h le h' -> exists h2, h' = h ++ h2 /\ map snd h2 = le.

Corollary add_events_snd : forall h le h', add_events h le h' -> map snd h' = map snd h ++ le.

Corollary add_events_incl : forall h le h', add_events h le h' -> incl h h'.

Corollary add_events_newer : forall h le h' t, add_events h le h' -> newer h' t -> newer h t.

Lemma add_events_in : forall h le h' e, add_events h le h' -> In e le -> exists t, newer h t /\ In (t, e) h'.

Lemma add_events_ordered : forall h le h', add_events h le h' -> ordered_hist h -> ordered_hist h'.

Lemma add_events_last : forall h le h', add_events h le h' -> le <> [] ->
  value_of_hist h' = value_of (last le (Store (vint 0))).

Lemma add_events_NoDup : forall h le h', add_events h le h' -> NoDup (map fst h) -> NoDup (map fst h').

Notation AL_witness sh p g i R h P Q :=
  (sh%logic, p%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   EX h' : hist, fun v => !!(add_events h [Load (vint v)] h') && ghost_hist sh h' g * Q v).
Lemma AL_hist_spec : forall sh g i R h P Q
  (HPQR : forall h' v (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v) -> repable_signed v ->
    view_shift (R h' v * P) (R (h' ++ [Load (vint v)]) v * Q v)) (Hsh : sh <> Share.bot),

Notation AS_witness sh p g i R h v P Q :=
  (sh%logic, p%logic, v%Z%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   EX h' : hist, !!(add_events h [Store (vint v)] h') && ghost_hist sh h' g * Q).
Lemma AS_hist_spec : forall sh g i R h v P Q
  (HPQR : forall h' v' (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v') -> repable_signed v' ->
     view_shift (R h' v' * P) (R (h' ++ [Store (vint v)]) v * Q)) (Hsh : sh <> Share.bot)

Notation ACAS_witness sh p g i R h c v P Q :=
  (sh%logic, p%logic, c%Z%logic, v%Z%logic, (ghost_hist sh h g * P)%logic, hist_R g%logic i R,
   fun v' => EX h' : hist, !!(add_events h [CAS (vint v') (vint c) (vint v)] h') &&
     ghost_hist sh h' g * Q v').
Lemma ACAS_hist_spec : forall sh g i R h v c P Q
  (HPQR : forall h' v' (Hhist : hist_incl h h'), apply_hist (vint i) h' = Some (vint v') -> repable_signed v' ->
    view_shift (R h' v' * P) (R (h' ++ [CAS (vint v') (vint c) (vint v)]) (if eq_dec c v' then v else v') * Q v'))
  (Hsh : sh <> Share.bot) (Hc : repable_signed c) (Hprecise : forall v, precise (EX h : _, R h v)),

Lemma atomic_loc_hist_join : forall sh1 sh2 sh p g i R h1 h2 h (Hjoin : sepalg.join sh1 sh2 sh) *)

Require Import VST.progs.conclib.
(* VST.progs.conclib:
Require Import VST.veric.ghost_PCM.
Require Export VST.msl.iter_sepcon.
Require Export VST.concurrency.semax_conc_pred.
Require Export VST.concurrency.semax_conc.
Require Export VST.floyd.proofauto.
Require Import VST.floyd.library.
Require Export VST.floyd.sublist.

Notation vint z := (Vint (Int.repr z)).
Notation vptrofs z := (Vptrofs (Ptrofs.repr z)).

Lemma app_cons_assoc : forall {A} l1 (x : A) l2, l1 ++ x :: l2 = (l1 ++ [x]) ++ l2.

Lemma Forall_forall_Znth : forall {A}{d: Inhabitant A} (P : A -> Prop) l,
  Forall P l <-> forall i, 0 <= i < Zlength l -> P (Znth i l).

Lemma Zmod_smallish : forall x y, y <> 0 -> 0 <= x < 2 * y ->
  x mod y = x \/ x mod y = x - y.

Lemma Zmod_plus_inv : forall a b c d (Hc : c > 0) (Heq : (a + b) mod c = (d + b) mod c),
  a mod c = d mod c.

Lemma Znth_app : forall {A}{d: Inhabitant A} (l1 l2 : list A) i,
      Zlength l1 = i -> Znth i (l1 ++ l2) = Znth 0 l2.

Corollary Znth_app1 : forall {A}{d: Inhabitant A} l1 (x : A) l2 i,
     Zlength l1 = i -> Znth i (l1 ++ x :: l2) = x.

Lemma repable_0 : repable_signed 0.
Hint Resolve repable_0.

Definition complete MAX l := l ++ repeat (vptrofs 0) (Z.to_nat MAX - length l).

Lemma upd_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX l) x = complete MAX (l ++ [x]).

Lemma Znth_complete : forall n l MAX, n < Zlength l -> 
     Znth n (complete MAX l) = Znth n l.

Lemma remove_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX (l ++ [x])) (vptrofs 0) = complete MAX l.

Lemma Forall_app : forall {A} (P : A -> Prop) l1 l2,
  Forall P (l1 ++ l2) <-> Forall P l1 /\ Forall P l2.

Lemma Forall_incl : forall {A} (P : A -> Prop) l1 l2 (Hall : Forall P l2) (Hincl : incl l1 l2),
  Forall P l1.

Lemma repeat_plus : forall {A} (x : A) i j, repeat x (i + j) = repeat x i ++ repeat x j.

Lemma in_insert_iff : forall {A} (x y : A) l1 l2, In x (l1 ++ y :: l2) <-> x = y \/ In x (l1 ++ l2).

Definition remove_at {A} i (l : list A) := firstn i l ++ skipn (S i) l.

Lemma Forall_firstn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (firstn i l).

Lemma Forall_skipn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (skipn i l).

Lemma Forall_upd_Znth : forall {A} (P : A -> Prop) x l i, Forall P l -> P x ->
  Forall P (upd_Znth i l x).

Lemma last_cons : forall {A} (d : A) l x, l <> [] -> last (x :: l) d = last l d.

Lemma nth_last : forall {A} (d : A) l, nth (length l - 1) l d = last l d.

Lemma Znth_last : forall {A}{d: Inhabitant A} l, Znth (Zlength l - 1) l = last l default.

Lemma last_app : forall {A} l1 l2 (d : A), l2 <> [] -> last (l1 ++ l2) d = last l2 d.

Lemma nat_sorted_list_eq : forall d n l (Hl : forall i, (i < n)%nat <-> In i l) (Hlen : length l = n)
  (Hsorted : forall i j, (i < j < n -> nth i l d < nth j l d)%nat) i (Hi : (i < n)%nat), nth i l d = i.

Lemma Forall2_In_l : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l1 ->
  exists y, In y l2 /\ P x y.

Lemma Forall2_In_r : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l2 ->
  exists y, In y l1 /\ P y x.

Lemma last_snoc : forall {A} (d : A) x l, last (l ++ [x]) d = x.

Lemma iter_sepcon_sepcon: forall {A} f g1 g2 l, (forall b : A, f b = g1 b * g2 b) ->
  iter_sepcon f l = iter_sepcon g1 l * iter_sepcon g2 l.

Lemma sepcon_app : forall l1 l2, fold_right sepcon emp (l1 ++ l2) =
  fold_right sepcon emp l1 * fold_right sepcon emp l2.

Definition rotate {A} (l : list A) n m := sublist (m - n) (Zlength l) l ++
  sublist 0 (m - n) l.

Lemma sublist_of_nil : forall {A} i j, sublist i j (@nil A) = [].

Lemma sublist_0_cons : forall {A} j x (l : list A), j > 0 ->
  sublist 0 j (x :: l) = x :: sublist 0 (j - 1) l.

Lemma sublist_S_cons : forall {A} i j x (l : list A), i > 0 ->
  sublist i j (x :: l) = sublist (i - 1) (j - 1) l.

Lemma upd_rotate : forall {A} i (l : list A) n m x (Hl : Zlength l = m) (Hlt : 0 <= n <= m)
  (Hi : 0 <= i < Zlength l),
  upd_Znth i (rotate l n m) x = rotate (upd_Znth ((i - n) mod m) l x) n m.

Lemma Znth_cons_eq : forall {A}{d : Inhabitant A} i x l, 
   Znth i (x :: l) = if eq_dec i 0 then x else Znth (i - 1) l.

Lemma Znth_rotate : forall {A} {d : Inhabitant A} i l n, 
    0 <= n <= Zlength l -> 0 <= i < Zlength l ->
  Znth i (rotate l n (Zlength l)) = Znth ((i - n) mod Zlength l) l.

Lemma rotate_nil : forall {A} n m, rotate (@nil A) n m = [].

Lemma Forall_sublist_le : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i) (Hrangej : j <= Zlength l) (Hi : ~P (Znth i l)) (Hj : Forall P (sublist 0 j l)),
  j <= i.

Corollary Forall_sublist_first : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i <= Zlength l) (Hi : Forall P (sublist 0 i l)) (Hi' : ~P (Znth i l))
  (Hrangej : 0 <= j <= Zlength l) (Hj : Forall P (sublist 0 j l)) (Hj' : ~P (Znth j l)),
  i = j.

Lemma NoDup_Znth_inj : forall {A} {d : Inhabitant A} l i j (HNoDup : NoDup l)
  (Hi : 0 <= i < Zlength l) (Hj : 0 <= j < Zlength l) (Heq : Znth i l = Znth j l ),
  i = j.

Lemma rotate_In : forall {A} (x : A) n m l, 0 <= m - n <= Zlength l -> In x (rotate l n m) <-> In x l.

Lemma rotate_map : forall {A B} (f : A -> B) n m l, rotate (map f l) n m = map f (rotate l n m).

Lemma combine_app : forall {A B} (l1 l2 : list A) (l1' l2' : list B), length l1 = length l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma combine_app' : forall {A B} (l1 l2 : list A) (l1' l2' : list B), Zlength l1 = Zlength l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma Forall_rotate : forall {A} P (l : list A) n m, Forall P l ->
  Forall P (rotate l m n).

Lemma Forall_repeat : forall {A} (P : A -> Prop) x n, P x -> Forall P (repeat x n).

Lemma Forall_complete : forall P l m, Forall P l -> P (vptrofs 0) ->
  Forall P (complete m l).

Lemma app_eq_inv : forall {A} (l1 l2 l3 l4 : list A)
  (Heq : l1 ++ l2 = l3 ++ l4) (Hlen : length l1 = length l3), l1 = l3 /\ l2 = l4.

Lemma rotate_inj : forall {A} (l1 l2 : list A) n m, rotate l1 n m = rotate l2 n m ->
  length l1 = length l2 -> 0 <= n <= m -> m <= Zlength l1 -> l1 = l2.

Lemma complete_inj : forall l1 l2 m, complete m l1 = complete m l2 ->
  length l1 = length l2 -> l1 = l2.

Lemma length_complete : forall l m, Zlength l <= m -> length (complete m l) = Z.to_nat m.

Lemma Zlength_rotate : forall {A} (l : list A) n m, 0 <= n <= m -> m <= Zlength l ->
  Zlength (rotate l n m) = Zlength l.

Lemma Zlength_repeat : forall {A} (x : A) n, Zlength (repeat x n) = Z.of_nat n.

Lemma Zlength_complete : forall l m, Zlength l <= m -> Zlength (complete m l) = m.

Lemma combine_eq : forall {A B} (l : list (A * B)), combine (map fst l) (map snd l) = l.

Lemma signed_inj : forall i1 i2, Int.signed i1 = Int.signed i2 -> i1 = i2.

Lemma mods_repr : forall a b, 0 <= a <= Int.max_signed -> 0 < b <= Int.max_signed ->

Lemma repeat_list_repeat : forall {A} n (x : A), repeat x n = list_repeat n x.

Lemma sublist_repeat : forall {A} i j k (v : A), 0 <= i -> i <= j <= k ->
  sublist i j (repeat v (Z.to_nat k)) = repeat v (Z.to_nat (j - i)).

Lemma Znth_head : forall reqs head m, Zlength reqs <= m -> 0 <= head < m ->
  Zlength reqs > 0 ->
  Znth head (rotate (complete m reqs) head m) = Znth 0 reqs.

Lemma Znth_repeat : forall {A} {x : Inhabitant A} n i, Znth i (repeat default n) = default.

Lemma Znth_repeat' : forall {A} {d: Inhabitant A} (x : A) n i, 
    0 <= i < Z.of_nat n -> Znth i (repeat x n)  = x.

Lemma rotate_1 : forall v l n m, 0 <= n < m -> Zlength l < m ->
  rotate (upd_Znth 0 (complete m (v :: l)) (vptrofs 0)) n m =
  rotate (complete m l) ((n + 1) mod m) m.

Lemma upd_complete_gen : forall {A} (l : list A) x n y, Zlength l < n ->
  upd_Znth (Zlength l) (l ++ repeat y (Z.to_nat (n - Zlength l))) x =

Lemma upd_complete' : forall l x n, (length l < n)%nat ->
  upd_Znth (Zlength l) (map Vint (map Int.repr l) ++ repeat Vundef (n - length l)) (Vint (Int.repr x)) =

Fixpoint upto n :=
  match n with
  | O => []
  | S n' => 0 :: map Z.succ (upto n')
  end.

Opaque Z.of_nat.

Lemma upto_app : forall n m, upto (n + m) = upto n ++ map (fun i => Z.of_nat n + i) (upto m).

Lemma upto_length : forall n, length (upto n) = n.

Corollary Zlength_upto : forall n, Zlength (upto n) = Z.of_nat n.

Lemma skipn_cons : forall {A}{d: Inhabitant A} n (l : list A), (length l > n)%nat ->
  skipn n l = Znth (Z.of_nat n) l :: skipn (S n) l.

Lemma Znth_upto : forall d m n, 
  0 <= n < Z.of_nat m -> @Znth _ d n (upto m) = n.

Transparent Z.of_nat.

Lemma In_Znth : forall {A} {d: Inhabitant A} (l : list A) x,
    In x l ->
    exists i, 0 <= i < Zlength l /\ Znth i l = x.

Lemma In_upd_Znth_old : forall {A}{d: Inhabitant A} i (x y : A) l, In x l -> x <> Znth i l -> 0 <= i <= Zlength l ->
  In x (upd_Znth i l y).

Lemma Znth_combine : forall {A B} {a: Inhabitant A} {b: Inhabitant B} i (l1: list A) (l2: list B), 
   Zlength l1 = Zlength l2 ->
  Znth i (combine l1 l2) = (Znth i l1, Znth i l2).

Lemma Zlength_combine : forall {A B} (l : list A) (l' : list B),
  Zlength (combine l l') = Z.min (Zlength l) (Zlength l').

Lemma nth_Znth : forall {A}{d: Inhabitant A} i l, nth i l default = Znth (Z.of_nat i) l.

Lemma upd_Znth_cons : forall {A} i a l (x : A), i > 0 ->
  upd_Znth i (a :: l) x = a :: upd_Znth (i - 1) l x.

Lemma upd_Znth_triv : forall {A}{d: Inhabitant A} i (l : list A) x (Hi : 0 <= i < Zlength l),
  Znth i l = x -> upd_Znth i l x = l.

Lemma combine_upd_Znth : forall {A B} (l1 : list A) (l2 : list B) i x1 x2, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine (upd_Znth i l1 x1) (upd_Znth i l2 x2) = upd_Znth i (combine l1 l2) (x1, x2).

Corollary combine_upd_Znth1 : forall {A B}{d: Inhabitant B} (l1 : list A) (l2 : list B) i x,
   0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 ->
   combine (upd_Znth i l1 x) l2 = upd_Znth i (combine l1 l2) (x, Znth i l2).

Corollary combine_upd_Znth2 : forall {A B}{d: Inhabitant A} (l1 : list A) (l2 : list B) i x, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine l1 (upd_Znth i l2 x) = upd_Znth i (combine l1 l2) (Znth i l1, x).

Lemma in_concat : forall {A} (l : list (list A)) x, In x (concat l) <-> exists l1, In x l1 /\ In l1 l.

Lemma length_concat : forall {A} (l : list (list A)), length (concat l) = fold_right plus O (map (@length A) l).

Lemma length_concat_min : forall {A}{d: Inhabitant A} (l : list (list A)) i (Hi : 0 <= i < Zlength l),
  (length (Znth i l) <= length (concat l))%nat.

Lemma length_concat_upd : forall {A} {d: Inhabitant A} l i (l' : list A) (Hi : 0 <= i < Zlength l),
  length (concat (upd_Znth i l l')) = (length (concat l) + length l' - length (Znth i l))%nat.

Lemma sepcon_rev : forall l, fold_right sepcon emp (rev l) = fold_right sepcon emp l.

Lemma incl_nil : forall {A} (l : list A), incl [] l.
Hint Resolve incl_nil.

Lemma incl_cons_out : forall {A} (a : A) l1 l2, incl l1 (a :: l2) -> ~In a l1 -> incl l1 l2.

Lemma In_upto : forall n i, In i (upto n) <-> 0 <= i < Z.of_nat n.

Lemma combine_fst : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map fst (combine l l') = l.

Lemma combine_snd : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map snd (combine l l') = l'.

Lemma rev_combine : forall {A B} (l1 : list A) (l2 : list B), length l1 = length l2 ->
  rev (combine l1 l2) = combine (rev l1) (rev l2).

Lemma combine_map_snd : forall {A B C} (l1 : list A) (l2 : list B) (f : B -> C),
  combine l1 (map f l2) = map (fun x => let '(a, b) := x in (a, f b)) (combine l1 l2).

Lemma combine_const1 : forall {A B} (l1 : list A) (x : B) n, Z.of_nat n >= Zlength l1 ->

Lemma combine_const2 : forall {A B} (x : A) n (l2 : list B), Z.of_nat n >= Zlength l2 ->

Lemma map_const: forall {A B} (c : A) (l : list B), map (fun _ => c) l = repeat c (length l).

Lemma In_upd_Znth : forall {A} i l (x y : A), In x (upd_Znth i l y) -> x = y \/ In x l.

Lemma upd_Znth_In : forall {A} i l (x : A), In x (upd_Znth i l x).

Lemma NoDup_Znth_iff : forall {A}{d: Inhabitant A} (l : list A),
  NoDup l <-> forall i j (Hi : 0 <= i < Zlength l)
                            (Hj : 0 <= j < Zlength l), Znth i l = Znth j l -> i = j.

Lemma concat_less_incl : forall {A} l i (l1 l2 : list A) (Hi : 0 <= i < Zlength l)
  (Hless : Znth i l = l1 ++ l2), incl (concat (upd_Znth i l l1)) (concat l).

Lemma NoDup_app : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) ->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Lemma NoDup_app_iff : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Corollary NoDup_app_swap : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <-> NoDup (l2 ++ l1).

Lemma NoDup_concat_less : forall {A} l i (l1 l2 : list A) (Hl : NoDup (concat l))
  (Hi : 0 <= i < Zlength l) (Hless : Znth i l = l1 ++ l2),
  NoDup (concat (upd_Znth i l l1)).

Lemma Forall2_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2 (Hall : Forall2 P l1 l2) i
  (Hi : 0 <= i < Zlength l1), P (Znth i l1) (Znth i l2).

Lemma Forall2_app_inv : forall {A B} (P : A -> B -> Prop) l1 l2 l3 l4 (Hlen : length l1 = length l3),
  Forall2 P (l1 ++ l2) (l3 ++ l4) -> Forall2 P l1 l3 /\ Forall2 P l2 l4.

Lemma Forall2_firstn : forall {A B} (P : A -> B -> Prop) l1 l2 n, Forall2 P l1 l2 ->
  Forall2 P (firstn n l1) (firstn n l2).

Lemma Forall2_upd_Znth : forall {A B} (P : A -> B -> Prop) l1 l2 i x1 x2, Forall2 P l1 l2 ->
  P x1 x2 -> 0 <= i <= Zlength l1 -> Forall2 P (upd_Znth i l1 x1) (upd_Znth i l2 x2).

Lemma Forall2_impl' : forall {A B} (P Q : A -> B -> Prop) l1 l2,
  (forall a b, In a l1 -> In b l2 -> P a b -> Q a b) -> Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma Forall2_impl : forall {A B} (P Q : A -> B -> Prop), (forall a b, P a b -> Q a b) ->
  forall l1 l2, Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma map_id_eq : forall {A} (l : list A), map (@id A) l = l.

Lemma Forall2_map : forall {A B C D} (P : A -> B -> Prop) (f1 : C -> A) (f2 : D -> B) l1 l2,
  Forall2 P (map f1 l1) (map f2 l2) <-> Forall2 (fun a b => P (f1 a) (f2 b)) l1 l2.

Corollary Forall2_map1 : forall {A B C} (P : A -> B -> Prop) (f : C -> A) l1 l2, Forall2 P (map f l1) l2 <->
  Forall2 (fun a b => P (f a) b) l1 l2.

Corollary Forall2_map2 : forall {A B C} (P : A -> B -> Prop) (f : C -> B) l1 l2, Forall2 P l1 (map f l2) <->
  Forall2 (fun a b => P a (f b)) l1 l2.

Lemma sublist_max_length : forall {A} i j (al : list A), Zlength (sublist i j al) <= Zlength al.

Lemma Forall2_sublist : forall {A B} (P : A -> B -> Prop) l1 l2 i j, Forall2 P l1 l2 -> 0 <= i ->
  Forall2 P (sublist i j l1) (sublist i j l2).

Lemma Forall_last : forall {A} (P : A -> Prop) d l, Forall P l -> P d -> P (last l d).

Lemma last_map : forall {A B} (f : A -> B) d l, f (last l d) = last (map f l) (f d).

Lemma In_removelast : forall {A} (l : list A) x, In x (removelast l) -> In x l.

Definition nil_dec {A} (l : list A) : {l = []} + {l <> []}.

Lemma Forall2_upd_Znth_l : forall {A B}{d: Inhabitant B} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P x (Znth i l2) -> 0 <= i < Zlength l1 -> Forall2 P (upd_Znth i l1 x) l2.

Lemma Forall2_upd_Znth_r : forall {A B}{d: Inhabitant A} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P (Znth i l1) x -> 0 <= i < Zlength l1 -> Forall2 P l1 (upd_Znth i l2 x).

Lemma Forall2_eq_upto : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2, Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ Forall (fun i => P (Znth i l1) (Znth i l2)) (upto (Z.to_nat (Zlength l1))).

Lemma Forall2_forall_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B}  (P : A -> B -> Prop) l1 l2,
  Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ (forall i, 0 <= i < Zlength l1 -> P (Znth i l1) (Znth i l2)).

Lemma Znth_inbounds : forall {A}{d: Inhabitant A} i (l : list A), 
    Znth i l <> default -> 0 <= i < Zlength l.

Lemma sublist_next : forall {A}{d: Inhabitant A} i j l,
      0 <= i < j -> j <= Zlength l ->
  sublist i j l = Znth i l :: sublist (i + 1) j l.

Lemma upd_init : forall {A} (l : list A) i b v v', i < b -> Zlength l = i ->
  upd_Znth i (l ++ repeat v (Z.to_nat (b - i))) v' = l ++ v' :: repeat v (Z.to_nat (b - (i + 1))).

Corollary upd_init_const : forall {A} i b (v v' : A), 0 <= i < b ->
  upd_Znth i (repeat v' (Z.to_nat i) ++ repeat v (Z.to_nat (b - i))) v' =

Lemma list_Znth_eq : forall {A}{d: Inhabitant A} (l : list A),
    l = map (fun j => Znth j l) (upto (length l)).

Arguments eq_dec _ _ _ _ : simpl never.

Lemma upd_Znth_eq : forall {A} {EqDec : EqDec A} {d: Inhabitant A} (x : A) (l : list A) i, 0 <= i < Zlength l ->
  upd_Znth i l x = map (fun j => if eq_dec j i then x else Znth j l) (upto (length l)).

Lemma upd_Znth_diff' : forall {A}{d: Inhabitant A} i j l (u : A),
    0 <= j < Zlength l -> i <> j ->
  Znth i (upd_Znth j l u) = Znth i l.

Lemma list_nth_error_eq : forall {A} (l1 l2 : list A)
  (Heq : forall j, nth_error l1 j = nth_error l2 j), l1 = l2.

Lemma list_Znth_eq' : forall {A} {d: Inhabitant A} (l1 l2 : list A)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> Znth j l1 = Znth j l2), l1 = l2.

Corollary upd_Znth_eq' : forall {A}{d: Inhabitant A} x (l1 l2 : list A) i (Hi : 0 <= i < Zlength l1)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> j <> i -> Znth j l1 = Znth j l2),
  upd_Znth i l1 x = upd_Znth i l2 x.

Lemma upd_Znth_twice : forall {A} i l (x y : A), 0 <= i < Zlength l ->
  upd_Znth i (upd_Znth i l x) y = upd_Znth i l y.

Lemma hd_Znth : forall {A}{d: Inhabitant A} (l : list A), hd default l = Znth 0 l.

Lemma NoDup_filter : forall {A} (f : A -> bool) l, NoDup l -> NoDup (filter f l).

Lemma Permutation_Zlength : forall {A} (l1 l2 : list A), Permutation.Permutation l1 l2 ->

Lemma Permutation_filter : forall {A} (f : A -> bool) l1 l2, Permutation.Permutation l1 l2 ->

Lemma NoDup_add : forall {A} l1 l2 (x : A), NoDup (l1 ++ l2) -> ~In x (l1 ++ l2) -> NoDup (l1 ++ x :: l2).

Lemma list_in_count : forall {A} {A_eq : EqDec A} (l l' : list A), NoDup l' ->
  (length (filter (fun x => if in_dec eq_dec x l then true else false) l') <= length l)%nat.

Lemma filter_length : forall {A} (f : A -> bool) l,
  length l = (length (filter f l) + length (filter (fun x => negb (f x)) l))%nat.

Lemma Zlength_filter : forall {A} f (l : list A), Zlength (filter f l) <= Zlength l.

Lemma Zlength_concat : forall {A} (l : list (list A)),
  Zlength (concat l) = fold_right Z.add 0 (map (@Zlength A) l).

Lemma Zlength_concat_le : forall {A} (l : list (list A)) n,
  Forall (fun l => Zlength l <= n) l -> Zlength (concat l) <= n * Zlength l.

Lemma filter_app : forall {A} (f : A -> bool) l1 l2, filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_concat : forall {A} f (l : list (list A)),
  filter f (concat l) = concat (map (filter f) l).

Lemma NoDup_upto : forall n, NoDup (upto n).

Lemma In_remove : forall {A} {A_eq : EqDec A} (x y : A) l, In x (remove A_eq y l) <-> In x l /\ x <> y.

Lemma remove_NoDup : forall {A} {A_eq : EqDec A} (x : A) l, NoDup l -> NoDup (remove A_eq x l).

Lemma remove_out : forall {A} {A_eq : EqDec A} (x : A) l, ~In x l -> remove A_eq x l = l.

Lemma remove_from_NoDup : forall {A} {A_eq : EqDec A} (x : A) l1 l2, NoDup (l1 ++ x :: l2) ->
  remove A_eq x (l1 ++ x :: l2) = l1 ++ l2.

Lemma incl_remove_add : forall {A} {A_eq : EqDec A} (x : A) l1 l2, incl l1 l2 -> incl l1 (x :: remove A_eq x l2).

Lemma list_pigeonhole : forall l n, Zlength l < n -> exists a, 0 <= a < n /\ ~In a l.

Lemma In_sublist_upto : forall n x i j, In x (sublist i j (upto n)) -> 0 <= i ->
  i <= x < j /\ x < Z.of_nat n.

Lemma incl_cons_iff : forall {A} (a : A) b c, incl (a :: b) c <-> In a c /\ incl b c.

Lemma lt_le_1 : forall i j, i < j <-> i + 1 <= j.

Lemma firstn_all : forall {A} n (l : list A), (length l <= n)%nat -> firstn n l = l.

Lemma sublist_all : forall {A} i (l : list A), Zlength l <= i -> sublist 0 i l = l.

Lemma sublist_prefix : forall {A} i j (l : list A), sublist 0 i (sublist 0 j l) = sublist 0 (Z.min i j) l.

Lemma sublist_suffix : forall {A} i j (l : list A), 0 <= i -> 0 <= j ->
  sublist i (Zlength l - j) (sublist j (Zlength l) l) = sublist (i + j) (Zlength l) l.

Lemma sublist_parts1 : forall {A} i j (l : list A), 0 <= i -> sublist i j l = sublist i j (sublist 0 j l).

Lemma sublist_parts2 : forall {A} i j (l : list A), 0 <= i -> j <= Zlength l ->
  sublist i j l = sublist 0 (j - i) (sublist i (Zlength l) l).

Lemma Forall_Forall2 : forall {A} (P : A -> Prop) Q l1 l2 (HP : Forall P l1) (HQ : Forall2 Q l1 l2)
  (Htransfer : forall x y, P x -> Q x y -> P y), Forall P l2.

Lemma Forall_suffix_max : forall {A} (P : A -> Prop) l1 l2 i j
  (Hi : 0 <= i <= Zlength l1) (Hj : 0 <= j <= Zlength l1)
  (Hl1 : Forall P (sublist j (Zlength l1) l1))
  (Hl2 : sublist i (Zlength l1) l1 = sublist i (Zlength l2) l2),
  Forall P (sublist (Z.max i j) (Zlength l2) l2).

Fixpoint extend {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (x :: y) :: extend xs ys
  | _, _ => ls
  end.

Lemma Zlength_extend : forall {A} (l : list A) ls, Zlength (extend l ls) = Zlength ls.

Lemma Znth_extend_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extend l ls) = Znth i l :: Znth i ls.

Lemma Znth_extend_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extend l ls) = Znth i ls.

Fixpoint extendr {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (y ++ [x]) :: extendr xs ys
  | _, _ => ls
  end.

Lemma Zlength_extendr : forall {A} (l : list A) ls, Zlength (extendr l ls) = Zlength ls.

Lemma Znth_extendr_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extendr l ls) = Znth i ls ++ [Znth i l].

Lemma Znth_extendr_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extendr l ls) = Znth i ls.

Lemma list_join_eq : forall (b : list share) a c c'
  (Hc : sepalg_list.list_join a b c) (Hc' : sepalg_list.list_join a b c'), c = c'.

Lemma readable_share_list_join : forall sh shs sh', sepalg_list.list_join sh shs sh' ->

Lemma sublist_0_cons' : forall {A} i j (x : A) l, i <= 0 -> j > i -> sublist i j (x :: l) =
  x :: sublist i (j - 1) l.

Lemma sublist_combine : forall {A B} (l1 : list A) (l2 : list B) i j,
  sublist i j (combine l1 l2) = combine (sublist i j l1) (sublist i j l2).

Lemma extend_nil : forall {A} (l : list A), extend l [] = [].

Lemma extend_cons : forall {A} (l : list A) l1 ls, extend l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (a :: l1) :: extend l' ls end.

Lemma sublist_extend : forall {A} (l : list A) ls i j,
  sublist i j (extend l ls) = extend (sublist i j l) (sublist i j ls).

Lemma extendr_nil : forall {A} (l : list A), extendr l [] = [].

Lemma extendr_cons : forall {A} (l : list A) l1 ls, extendr l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (l1 ++ [a]) :: extendr l' ls end.

Lemma sublist_extendr : forall {A} (l : list A) ls i j,
  sublist i j (extendr l ls) = extendr (sublist i j l) (sublist i j ls).

Lemma sublist_over : forall {A} (l : list A) i j, Zlength l <= i -> sublist i j l = [].

Lemma make_tycontext_s_distinct : forall a l (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (make_tycontext_s l) ! (fst a) = Some (snd a).

Lemma lookup_distinct : forall {A B} (f : A -> B) a l t (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! (fst a) =

Lemma lookup_out : forall {A B} (f : A -> B) a l t (Ha : ~In a (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! a = t ! a.

Lemma data_at__eq : forall {cs : compspecs} sh t p, data_at_ sh t p = data_at sh t (default_val t) p.

Lemma func_tycontext_sub : forall f V G A V2 G2 (HV : incl V V2) (HG : incl G G2)
  (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  tycontext_sub (func_tycontext f V G A) (func_tycontext f V2 G2 A).

Lemma semax_body_mono : forall V G {cs : compspecs} f s V2 G2
  (HV : incl V V2) (HG : incl G G2) (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  semax_body V G f s -> semax_body V2 G2 f s.

Lemma weak_exclusive_conflict : forall P,
  predicates_hered.derives ((weak_exclusive_mpred P && emp) * P * P) FF.

Lemma exclusive_sepcon1 : forall (P Q : mpred) (HP : exclusive_mpred P), exclusive_mpred (P * Q).

Lemma exclusive_sepcon2 : forall (P Q : mpred) (HP : exclusive_mpred Q), exclusive_mpred (P * Q).

Lemma exclusive_andp1 : forall P Q (HP : exclusive_mpred P), exclusive_mpred (P && Q).

Lemma exclusive_andp2 : forall P Q (HQ : exclusive_mpred Q), exclusive_mpred (P && Q).

Lemma lock_inv_exclusive : forall v sh R, exclusive_mpred (lock_inv sh v R).

Lemma selflock_exclusive : forall R sh v, exclusive_mpred R -> exclusive_mpred (selflock R v sh).

Lemma exclusive_FF : exclusive_mpred FF.

Lemma derives_exclusive : forall P Q (Hderives : P |-- Q) (HQ : exclusive_mpred Q),
  exclusive_mpred P.

Lemma mapsto_exclusive : forall (sh : Share.t) (t : type) (v : val),

Lemma field_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Lemma ex_field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Corollary field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) v (p : val),

Lemma ex_data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Corollary data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) v (p : val),

Corollary data_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Lemma cond_var_exclusive : forall {cs} sh p, sepalg.nonidentity sh ->

Lemma lock_inv_isptr : forall sh v R, lock_inv sh v R = !!isptr v && lock_inv sh v R.

Lemma cond_var_isptr : forall {cs} sh v, @cond_var cs sh v = !! isptr v && cond_var sh v.
Hint Resolve lock_inv_isptr cond_var_isptr : saturate_local.

Lemma cond_var_share_join : forall {cs} sh1 sh2 sh v (Hjoin : sepalg.join sh1 sh2 sh),

Hint Resolve lock_inv_exclusive selflock_exclusive cond_var_exclusive data_at_exclusive
  data_at__exclusive field_at_exclusive field_at__exclusive selflock_rec.

Lemma eq_dec_refl : forall {A B} {A_eq : EqDec A} (a : A) (b c : B), (if eq_dec a a then b else c) = b.

Lemma LKspec_readable lock_size :
  0 < lock_size ->
  forall R sh p, predicates_hered.derives (res_predicates.LKspec lock_size R sh p)

Lemma lock_inv_share_join : forall sh1 sh2 sh v R (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (Hjoin : sepalg.join sh1 sh2 sh),

Lemma comp_join_top : forall sh, sepalg.join sh (Share.comp sh) Tsh.

Lemma unreadable_bot : ~readable_share Share.bot.
Hint Resolve unreadable_bot.

Definition join_Bot := join_Bot.

Lemma join_Tsh : forall a b, sepalg.join Tsh a b -> b = Tsh /\ a = Share.bot.

Definition gsh1 := fst (slice.cleave Tsh).
Definition gsh2 := snd (slice.cleave Tsh).

Lemma readable_gsh1 : readable_share gsh1.

Lemma readable_gsh2 : readable_share gsh2.

Lemma gsh1_gsh2_join : sepalg.join gsh1 gsh2 Tsh.

Hint Resolve readable_gsh1 readable_gsh2 gsh1_gsh2_join.

Lemma gsh1_not_bot : gsh1 <> Share.bot.

Lemma gsh2_not_bot : gsh2 <> Share.bot.
Hint Resolve gsh1_not_bot gsh2_not_bot.

Lemma split_readable_share sh :
  readable_share sh ->
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 sh.

Lemma split_Ews :
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 Ews.

Definition remove_Znth {A} i (al : list A) := sublist 0 i al ++ sublist (i + 1) (Zlength al) al.

Lemma remove_Znth0 : forall {A} (l : list A), remove_Znth 0 l = sublist 1 (Zlength l) l.

Lemma remove_Znth_cons : forall {A} i a (l : list A), i > 0 ->
  remove_Znth i (a :: l) = a :: remove_Znth (i - 1) l.

Lemma Zlength_remove_Znth : forall {A} i (l : list A), 0 <= i < Zlength l ->
  Zlength (remove_Znth i l) = Zlength l - 1.

Lemma remove_upd_Znth: forall {A} i l (a : A), 0 <= i < Zlength l ->
  remove_Znth i (upd_Znth i l a) = remove_Znth i l.

Lemma remove_Znth_map: forall {A B} (f : A -> B) i l,
  remove_Znth i (map f l) = map f (remove_Znth i l).

Lemma remove_Znth_combine: forall {A B} i (l1 : list A) (l2 : list B),
  0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  remove_Znth i (combine l1 l2) = combine (remove_Znth i l1) (remove_Znth i l2).

Lemma iter_sepcon_Znth: forall {A} {d : Inhabitant A} f (l : list A) i, 0 <= i < Zlength l ->
  iter_sepcon f l = f (Znth i l) * iter_sepcon f (remove_Znth i l).

Lemma iter_sepcon2_Znth: forall {A B} {d1 : Inhabitant A} {d2 : Inhabitant B}
  f (l1 : list A) (l2 : list B) i, 0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  iter_sepcon2 f l1 l2 =
  f (Znth i l1) (Znth i l2) * iter_sepcon2 f (remove_Znth i l1) (remove_Znth i l2).

Instance Inhabitant_share : Inhabitant share := Share.bot.  
Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.  

Lemma join_shares_nth : forall shs sh1 sh i, sepalg_list.list_join sh1 shs sh -> 0 <= i < Zlength shs ->

Lemma list_join_comm : forall (l1 l2 : list share) a b, sepalg_list.list_join a (l1 ++ l2) b ->

Lemma split_shares : forall n sh, readable_share sh ->
  exists sh1 shs, Zlength shs = Z.of_nat n /\ readable_share sh1 /\ Forall readable_share shs /\

Lemma data_at_shares_join : forall {cs} sh t v p shs sh1 (Hsplit : sepalg_list.list_join sh1 shs sh),

Lemma exp_comm : forall {A B} P,
  (EX x : A, EX y : B, P x y) = EX y : B, EX x : A, P x y.

Lemma mapsto_value_eq: forall sh1 sh2 t p v1 v2, readable_share sh1 -> readable_share sh2 ->
  v1 <> Vundef -> v2 <> Vundef -> mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- !!(v1 = v2).

Lemma mapsto_value_cohere: forall sh1 sh2 t p v1 v2, readable_share sh1 ->
  mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- mapsto sh1 t p v1 * mapsto sh2 t p v1.

Lemma struct_pred_value_cohere : forall {cs : compspecs} m sh1 sh2 p t f off v1 v2
  (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (IH : Forall (fun it : ident * type => forall v1 v2 (p : val),
        readable_share sh1 -> readable_share sh2 ->
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v2 p |--
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v1 p) m),
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v2 p |--
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v1 p.

Lemma data_at_value_cohere : forall {cs : compspecs} sh1 sh2 t v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 t v1 p * data_at sh2 t v2 p |--
  data_at sh1 t v1 p * data_at sh2 t v1 p.

Lemma data_at_array_value_cohere : forall {cs : compspecs} sh1 sh2 t z a v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v2 p |--
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v1 p.

Lemma extract_nth_sepcon : forall l i, 0 <= i < Zlength l ->
  fold_right sepcon emp l = Znth i l * fold_right sepcon emp (upd_Znth i l emp).

Lemma replace_nth_sepcon : forall P l i, P * fold_right sepcon emp (upd_Znth i l emp) =
  fold_right sepcon emp (upd_Znth i l P).

Lemma sepcon_derives_prop : forall P Q R, P |-- !!R -> P * Q |-- !!R.

Lemma sepcon_map : forall {A} P Q (l : list A), fold_right sepcon emp (map (fun x => P x * Q x) l) =
  fold_right sepcon emp (map P l) * fold_right sepcon emp (map Q l).

Lemma sepcon_list_derives : forall l1 l2 (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall i, 0 <= i < Zlength l1 -> Znth i l1 |-- Znth i l2),
  fold_right sepcon emp l1 |-- fold_right sepcon emp l2.

Lemma sepcon_rotate : forall lP m n, 0 <= n - m < Zlength lP ->
  fold_right sepcon emp lP = fold_right sepcon emp (rotate lP m n).

Lemma wand_eq : forall P Q R, P = Q * R -> P = Q * (Q -* P).

Lemma wand_twice : forall P Q R, P -* Q -* R = P * Q -* R.

Lemma sepcon_In : forall l P, In P l -> exists Q, fold_right sepcon emp l = P * Q.

Lemma extract_wand_sepcon : forall l P, In P l ->
  fold_right sepcon emp l = P * (P -* fold_right sepcon emp l).

Lemma wand_sepcon_map : forall {A} (R : A -> mpred) l P Q
  (HR : forall i, In i l -> R i = P i * Q i),
  fold_right sepcon emp (map R l) = fold_right sepcon emp (map P l) *
    (fold_right sepcon emp (map P l) -* fold_right sepcon emp (map R l)).

Lemma wand_frame : forall P Q R, P -* Q |-- P * R -* Q * R.

Lemma semax_extract_later_prop'':
  forall {CS : compspecs} {Espec: OracleKind},
    forall (Delta : tycontext) (PP : Prop) P Q R c post P1 P2,
      P2 |-- !!PP ->
      (PP -> semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post) ->
      semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post.

Lemma field_at_array_inbounds : forall {cs : compspecs} sh t z a i v p,
  field_at sh (Tarray t z a) [ArraySubsc i] v p |-- !!(0 <= i < z).

Lemma valid_pointer_isptr : forall v, valid_pointer v |-- !!(is_pointer_or_null v).

Hint Resolve valid_pointer_isptr : saturate_local.

Lemma approx_imp : forall n P Q, compcert_rmaps.RML.R.approx n (predicates_hered.imp P Q) =

Definition super_non_expansive' {A} P := forall n ts x, compcert_rmaps.RML.R.approx n (P ts x) =
  compcert_rmaps.RML.R.approx n (P ts (functors.MixVariantFunctor.fmap (rmaps.dependent_type_functor_rec ts A)
        (compcert_rmaps.RML.R.approx n) (compcert_rmaps.RML.R.approx n) x)).

Lemma approx_sepcon_list: forall n lP, lP <> [] ->
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP) =

Corollary approx_sepcon_list' : forall n lP P,
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP)  * compcert_rmaps.RML.R.approx n P =

Lemma approx_FF : forall n, compcert_rmaps.RML.R.approx n FF = FF.

Lemma later_nonexpansive : nonexpansive (@later mpred _ _).

Lemma eqp_refl : forall (G : Triv) P, G |-- P <=> P.

Lemma eqp_sepcon : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P * Q <=> P' * Q'.

Lemma eqp_andp : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P && Q <=> P' && Q'.

Lemma eqp_exp : forall (A : Type) (NA : NatDed A) (IA : Indir A) (RecIndir : RecIndir A)
    (G : Triv) (B : Type) (X Y : B -> A),
  (forall x : B, G |-- X x <=> Y x) ->
  G |-- (EX x : _, X x) <=> (EX x : _, Y x).

Lemma fold_right_sepcon_nonexpansive : forall lP1 lP2, Zlength lP1 = Zlength lP2 ->
  (ALL i : Z, Znth i lP1 <=> Znth i lP2) |--
  fold_right sepcon emp lP1 <=> fold_right sepcon emp lP2.

Lemma void_ret : ifvoid tvoid (` (PROP ( )  LOCAL ()  SEP ()) (make_args [] []))
  (EX v : val, ` (PROP ( )  LOCAL ()  SEP ()) (make_args [ret_temp] [v])) = emp.

Ltac lock_props := rewrite ?sepcon_assoc; rewrite <- sepcon_emp at 1; rewrite sepcon_comm; apply sepcon_derives;
  [repeat apply andp_right; auto; eapply derives_trans;
   try (apply exclusive_weak_exclusive || (apply rec_inv_weak_rec_inv; try apply selflock_rec)); auto |
   try timeout 20 cancel].

Ltac join_sub := repeat (eapply sepalg.join_sub_trans;
  [eexists; first [eassumption | simple eapply sepalg.join_comm; eassumption]|]); eassumption.

Ltac join_inj := repeat match goal with H1 : sepalg.join ?a ?b ?c, H2 : sepalg.join ?a ?b ?d |- _ =>
    pose proof (sepalg.join_eq H1 H2); clear H1 H2; subst; auto end.

Ltac fast_cancel := rewrite ?sepcon_emp, ?emp_sepcon; rewrite ?sepcon_assoc;
  repeat match goal with
    | |- ?P |-- ?P => apply derives_refl
    | |- ?P * _ |-- ?P * _ => apply sepcon_derives; [apply derives_refl|]
    | |- _ |-- ?P * _ => rewrite <- !sepcon_assoc, (sepcon_comm _ P), !sepcon_assoc end;
  try cancel_frame.

Lemma semax_fun_id'' id f gv Espec {cs} Delta P Q R Post c :
  (var_types Delta) ! id = None ->
  (glob_specs Delta) ! id = Some f ->
  (glob_types Delta) ! id = Some (type_of_funspec f) ->
  snd (local2ptree Q) = Some gv ->
  @semax cs Espec Delta
    (PROPx P
      (LOCALx Q
      (SEPx ((func_ptr' f (gv id)) :: R)))) c Post ->
  @semax cs Espec Delta (PROPx P (LOCALx Q (SEPx R))) c Post.

Ltac get_global_function'' _f :=
eapply (semax_fun_id'' _f); try reflexivity.

Ltac start_dep_function := 
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH _ : globals
               PRE  [] main_pre _ nil _
               POST [ tint ] main_post _ nil _) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match _ with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList i
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax.

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => P%assert end)
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, 
             x5 at level 0, x6 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             P at level 100, Q at level 100).

Definition call_setup2'
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost
  (bl: list expr) (vl : list val)
  (Qactuals : PTree.t _)
  (witness: functors.MixVariantFunctor._functor (rmaps.dependent_type_functor_rec ts A) mpred)
  (Frame: list mpred)
  (Ppre: list Prop) (Qpre : list localdef) (Rpre: list mpred)
  (Qpre_temp : PTree.t _) GV' :=
 call_setup1 cs Qtemp Qvar GV a Delta P Q R R' fs argsig retty cc A Pre Post NEPre NEPost bl vl Qactuals /\
  Pre ts witness = PROPx Ppre (LOCALx Qpre (SEPx Rpre)) /\
  local2ptree Qpre = (Qpre_temp, PTree.empty _, nil, GV') /\
  ENTAIL Delta, PROPx P (LOCALx Q (SEPx R))
           |-- !! Forall (check_one_temp_spec Qactuals) (PTree.elements Qpre_temp) /\
  check_gvars_spec GV GV' /\
  fold_right_sepcon R |-- fold_right_sepcon Rpre * fold_right_sepcon Frame.

Lemma call_setup2'_i:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree) Pre Post NEPre NEPost

Ltac check_witness_type' ts A witness :=
  (unify A (rmaps.ConstType Ridiculous); 
             elimtype False)
 ||
 let TA := constr:(functors.MixVariantFunctor._functor
     (rmaps.dependent_type_functor_rec ts A) mpred) in
  let TA' := eval cbv 
     [functors.MixVariantFunctor._functor
      functors.MixVariantFunctorGenerator.fpair
      functors.MixVariantFunctorGenerator.fconst
      functors.MixVariantFunctorGenerator.fidentity
      rmaps.dependent_type_functor_rec
      functors.GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
      functors.CovariantFunctorGenerator.fconst
      functors.CovariantFunctorGenerator.fidentity
      functors.CovariantBiFunctor._functor
      functors.CovariantBiFunctorGenerator.Fpair
      functors.GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
      functors.CovariantFunctor._functor
      functors.MixVariantFunctor.fmap
      ] in TA
 in let TA'' := eval simpl in TA'
  in match type of witness with ?T => 
       unify T TA''
      + (fail "Type of witness does not match type required by funspec WITH clause.
Witness value: " witness "
Witness type: " T "
Funspec type: " TA'')
     end.

Ltac prove_call_setup' ts witness :=
 prove_call_setup1 subsume_funspec_refl;
 [ .. | 
 match goal with |- call_setup1  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?A _ _ _ _ _ _ _ -> _ =>
      check_witness_type' ts A witness
 end;
 let H := fresh in
 intro H;
 match goal with | |- @semax ?CS _ _ _ _ _ =>
 let Frame := fresh "Frame" in evar (Frame: list mpred);
 exploit (call_setup2'_i _ _ _ _ _ _ _ _ _ _ _ _ _ _ ts _ _ _ _ _ _ _ _ H witness Frame); clear H;
 simpl functors.MixVariantFunctor._functor;
 [ reflexivity
 | check_prove_local2ptree
 | Forall_pTree_from_elements
 | unfold check_gvars_spec; solve [exact I | reflexivity]
 | try change_compspecs CS; cancel_for_forward_call
 | 
 ]
 end].

Lemma semax_call_aux55:
 forall (cs: compspecs) (Qtemp: PTree.t val) (Qvar: PTree.t (type * val)) GV (a: expr)

Lemma semax_call_id00_wow:
 forall  
  (cs: compspecs) Qtemp Qvar a GV Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_x_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_y_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id01_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Ltac  forward_call_id1_wow' := 
let H := fresh in intro H;
eapply (semax_call_id1_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H);
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [check_result_type
 |apply Logic.I
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_x_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_x_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_y_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_y_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id01_wow' :=
let H := fresh in intro H;
eapply (semax_call_id01_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ apply Coq.Init.Logic.I 
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id00_wow'  :=
let H := fresh in intro H;
eapply (semax_call_id00_wow _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type 
 | cbv beta iota zeta; unfold_post; extensionality rho;
    repeat rewrite exp_uncurry;
    try rewrite no_post_exists0;
    repeat rewrite exp_unfold;
    first [reflexivity | extensionality; simpl; reflexivity | give_EX_warning]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac fwd_call'_dep ts witness :=
lazymatch goal with
| |- semax _ _ (Ssequence (Scall _ _ _) _) _ =>
  eapply semax_seq';
    [prove_call_setup' ts witness;
     clear_Delta_specs; clear_MORE_POST;
     [ .. |
      lazymatch goal with
      | |- _ -> semax _ _ (Scall (Some _) _ _) _ =>
         forward_call_id1_wow'
      | |- call_setup2' _ _ _ _ _ _ _ _ _ _ _ _ ?retty _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ -> 
                semax _ _ (Scall None _ _) _ =>
        tryif (unify retty Tvoid)
        then forward_call_id00_wow'
        else forward_call_id01_wow'
     end]
   | after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Ecast (Etempvar ?ret'2 _) _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_x_wow' ]
         |  after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Etempvar ?ret'2 _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_y_wow' ]
         |  after_forward_call ]
| |- _ => rewrite <- seq_assoc; fwd_call'_dep ts witness
end.

Ltac fwd_call_dep ts witness :=
 try lazymatch goal with
      | |- semax _ _ (Scall _ _ _) _ => rewrite -> semax_seq_skip
      end;
 repeat lazymatch goal with
  | |- semax _ _ (Ssequence (Ssequence (Ssequence _ _) _) _) _ =>
      rewrite <- seq_assoc
 end;
lazymatch goal with |- @semax ?CS _ ?Delta _ (Ssequence ?C _) _ =>
  lazymatch C with context [Scall _ _ _] =>
         fwd_call'_dep ts witness
    end
end.

Tactic Notation "forward_call_dep" constr(ts) constr(witness) := fwd_call_dep ts witness.

Lemma PROP_into_SEP : forall P Q R, PROPx P (LOCALx Q (SEPx R)) =
  PROPx [] (LOCALx Q (SEPx (!!fold_right and True P && emp :: R))).

Ltac cancel_for_forward_spawn :=
  eapply symbolic_cancel_setup;
   [ construct_fold_right_sepcon
   | construct_fold_right_sepcon
   | fold_abnormal_mpred
   | cbv beta iota delta [before_symbol_cancel]; cancel_for_forward_call].

Ltac forward_spawn id arg wit :=
  match goal with gv : globals |- _ =>
  make_func_ptr id; let f := fresh "f_" in set (f := gv id);
  match goal with |- context[func_ptr' (NDmk_funspec _ _ (val * ?A) ?Pre _) f] =>
    let y := fresh "y" in let Q := fresh "Q" in let R := fresh "R" in
    evar (y : ident); evar (Q : A -> globals); evar (R : A -> val -> mpred);
    replace Pre with (fun '(a, w) => PROPx [] (LOCALx (temp y a :: gvars (Q w) :: nil) (SEPx [R w a])));
    [|let x := fresh "x" in extensionality x; destruct x as (?, x);
      instantiate (1 := fun w a => _ w) in (Value of R);
      repeat (destruct x as (x, ?);
        instantiate (1 := fun '(a, b) => _ a) in (Value of Q);
        instantiate (1 := fun '(a, b) => _ a) in (Value of R));
      etransitivity; [|symmetry; apply PROP_into_SEP]; f_equal; f_equal ; [instantiate (1 := fun _ => _) in (Value of Q); subst y Q; f_equal; simpl; f_equal |
       unfold SEPx; extensionality; simpl; rewrite sepcon_emp; instantiate (1 := fun _ => _); reflexivity]];
  forward_call_dep [A] (f, arg, Q, wit, R); subst Q R; [ .. | subst y f]; try (Exists y; subst y f; simpl; cancel_for_forward_spawn) end end. *)

Require Import VST.floyd.library.
(* VST.floyd.library:
Require Import VST.floyd.base2.
Require Import VST.floyd.sublist.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.closed_lemmas.
Require Import VST.floyd.compare_lemmas.
Require Import VST.floyd.semax_tactics.
Require Import VST.floyd.forward.
Require Import VST.floyd.call_lemmas.
Require Import VST.floyd.forward_lemmas.
Require Import VST.floyd.for_lemmas.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.nested_field_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import VST.floyd.mapsto_memory_block.
Require Import VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.data_at_rec_lemmas.
Require Import VST.floyd.field_at.
Require Import VST.floyd.field_compat.
Require Import VST.floyd.stronger.
Require Import VST.floyd.loadstore_mapsto.
Require Import VST.floyd.loadstore_field_at.
Require Import VST.floyd.nested_loadstore.
Require Import VST.floyd.local2ptree_denote.
Require Import VST.floyd.local2ptree_eval.
Require Import VST.floyd.proj_reptype_lemmas.
Require Import VST.floyd.replace_refill_reptype_lemmas.
Require Import VST.floyd.sc_set_load_store.

Require Import VST.floyd.entailer.
Require Import VST.floyd.globals_lemmas.
Require Import VST.floyd.diagnosis.
Require Import VST.floyd.freezer.
Import ListNotations.
Import String.

Definition body_lemma_of_funspec  {Espec: OracleKind} (ef: external_function) (f: funspec) :=
  match f with mk_funspec sig _ A P Q _ _ =>
    semax_external (map fst (fst sig)) ef A P Q
  end.

Definition try_spec  (name: string) (spec: funspec) : 
   list (ident * globdef Clight.fundef type) -> list (ident*funspec) :=
fun defs => 
 match ext_link_prog' defs name with
 | Some id => [(id,spec)]
 | None => nil
 end.
Arguments try_spec name spec defs / .

Definition exit_spec' :=
 WITH u: unit
 PRE [1%positive OF tint]
   PROP () LOCAL() SEP()
 POST [ tvoid ]
   PROP(False) LOCAL() SEP().

Definition exit_spec := try_spec "exit" exit_spec'.

Parameter body_exit:
 forall {Espec: OracleKind},
  body_lemma_of_funspec
    (EF_external "exit"
       {| sig_args := AST.Tint :: nil; sig_res := None; sig_cc := cc_default |})
   exit_spec'.

Parameter mem_mgr: globals -> mpred.
Axiom create_mem_mgr: forall gv, emp |-- mem_mgr gv.

Parameter malloc_token : forall {cs: compspecs}, share -> type -> val -> mpred.
Parameter malloc_token_valid_pointer:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- valid_pointer p.
Hint Resolve malloc_token_valid_pointer : valid_pointer.

Parameter malloc_token_local_facts:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- !! malloc_compatible (sizeof t) p.
Hint Resolve malloc_token_local_facts : saturate_local.
Parameter malloc_token_change_composite: forall {cs_from cs_to} {CCE : change_composite_env cs_from cs_to} sh t,
  cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->
  @malloc_token cs_from sh t = @malloc_token cs_to sh t.
Ltac change_compspecs' cs cs' ::=
  match goal with
  | |- context [@data_at cs' ?sh ?t ?v1] => erewrite (@data_at_change_composite cs' cs _ sh t); [| apply JMeq_refl | reflexivity]
  | |- context [@field_at cs' ?sh ?t ?gfs ?v1] => erewrite (@field_at_change_composite cs' cs _ sh t gfs); [| apply JMeq_refl | reflexivity]
  | |- context [@data_at_ cs' ?sh ?t] => erewrite (@data_at__change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [@field_at_ cs' ?sh ?t ?gfs] => erewrite (@field_at__change_composite cs' cs _ sh t gfs); [| reflexivity]
  | |- context [@malloc_token cs' ?sh ?t] => erewrite (@malloc_token_change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [?A cs'] => change (A cs') with (A cs)
  | |- context [?A cs' ?B] => change (A cs' B) with (A cs B)
  | |- context [?A cs' ?B ?C] => change (A cs' B C) with (A cs B C)
  | |- context [?A cs' ?B ?C ?D] => change (A cs' B C D) with (A cs B C D)
  | |- context [?A cs' ?B ?C ?D ?E] => change (A cs' B C D E) with (A cs B C D E)
  | |- context [?A cs' ?B ?C ?D ?E ?F] => change (A cs' B C D E F) with (A cs B C D E F)
 end.

Definition malloc_spec'  {cs: compspecs} :=
   WITH t:type, gv: globals
   PRE [ 1%positive OF size_t ]
       PROP (0 <= sizeof t <= Ptrofs.max_unsigned;
                complete_legal_cosu_type t = true;
                natural_aligned natural_alignment t = true)
       LOCAL (temp 1%positive (Vptrofs (Ptrofs.repr (sizeof t))); gvars gv)
       SEP (mem_mgr gv)
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (mem_mgr gv;
             if eq_dec p nullval then emp
            else (malloc_token Ews t p * data_at_ Ews t p)).

Parameter body_malloc:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_malloc malloc_spec'.

Definition free_spec'  {cs: compspecs} :=
   WITH t: type, p:val, gv: globals
   PRE [ 1%positive OF tptr tvoid ]
       PROP ()
       LOCAL (temp 1%positive p; gvars gv)
       SEP (mem_mgr gv;
              if eq_dec p nullval then emp
              else (malloc_token Ews t p * data_at_ Ews t p))
    POST [ Tvoid ]
       PROP ()
       LOCAL ()
       SEP (mem_mgr gv).

Parameter body_free:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_free free_spec'.

Definition library_G  {cs: compspecs} prog :=
 let defs := prog_defs prog in 
  try_spec "exit" exit_spec' defs ++
  try_spec "_malloc" malloc_spec' defs ++
  try_spec "_free" free_spec' defs.

Ltac with_library prog G :=
  let pr := eval unfold prog in prog in  
 let x := constr:(library_G pr ++ G) in
  let x := eval cbv beta delta [app library_G] in x in
  let x := simpl_prog_defs x in 
  let x := eval cbv beta iota zeta delta [try_spec] in x in 
  let x := eval simpl in x in 
    with_library' pr x.

Lemma semax_func_cons_malloc_aux:
  forall {cs: compspecs} (gv: globals) (gx : genviron) (t :type) (ret : option val),
(EX p : val,
 PROP ( )
 LOCAL (temp ret_temp p)
 SEP (mem_mgr gv;
      if eq_dec p nullval
      then emp
      else malloc_token Ews t p * data_at_ Ews t p))%assert
  (make_ext_rval gx ret) |-- !! is_pointer_or_null (force_val ret). *)

Require Import VST.floyd.sublist.
(* VST.floyd.sublist:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Require Import Coq.Lists.List.
Import ListNotations.

Class Inhabitant (A: Type) := default : A.

Instance Inhabitant_Z : Inhabitant Z := 0.
Instance Inhabitant_nat : Inhabitant nat := O.
Instance Inhabitant_positive : Inhabitant positive := 1%positive.
Instance Inhabitant_list {T: Type} : Inhabitant (list T) := @nil T.
Instance Inhabitant_fun {T1 T2: Type} {H: Inhabitant T2} : Inhabitant (T1->T2) := fun _ => H.
Instance Inhabitant_Prop : Inhabitant Prop := False.
Instance Inhabitant_bool : Inhabitant bool := false.
Instance Inhabitant_pair {T1 T2 : Type} {x1: Inhabitant T1} {x2: Inhabitant T2} : Inhabitant (T1*T2)%type := (x1,x2).

Lemma Zlength_length:
  forall A (al: list A) (n: Z),
    0 <= n ->
    (Zlength al = n <-> length al = Z.to_nat n).

Lemma firstn_app1: forall {A} n (p l: list A),
  (n <= Datatypes.length p)%nat ->

Lemma firstn_app2: forall {A} (n: nat) (al bl: list A),
 (n >= length al)%nat ->
 firstn n (al++bl) = al ++ firstn (n - length al) bl.

Lemma firstn_list_repeat {A} (v:A): forall i k, (i<=k)%nat ->
      firstn i (list_repeat k v) = list_repeat i v.

Lemma firstn_app:
 forall {A} n m (al: list A), firstn n al ++ firstn m (skipn n al) =
  firstn (n+m) al.

Lemma nth_skipn:
  forall {A} i n data (d:A),
       nth i (skipn n data) d = nth (i+n) data d.

Lemma skipn_skipn: forall {A} n m (xs: list A),
  skipn n (skipn m xs) = skipn (m + n) xs.

Lemma firstn_exact_length: forall {A} (xs: list A), firstn (length xs) xs = xs.

Lemma skipn_exact_length: forall {A} (xs: list A), skipn (length xs) xs = nil.

Lemma len_le_1_rev: forall {A} (contents: list A),
  (length contents <= 1)%nat ->
  contents = rev contents.

Lemma firstn_firstn: forall {A} (contents: list A) n m,
  (n <= m)%nat ->
  firstn n (firstn m contents) = firstn n contents.

Lemma firstn_1_skipn: forall {A} n (ct: list A) d,
  (n < length ct)%nat ->
  nth n ct d :: nil = firstn 1 (skipn n ct).

Lemma skipn_length: forall {A} (contents: list A) n,
  length (skipn n contents) = (length contents - n)%nat.

Lemma nth_firstn: forall {A} (contents: list A) n m d,
  (n < m)%nat ->
  nth n (firstn m contents) d = nth n contents d.

Lemma skipn_length_short:
  forall {A} n (al: list A),
    (length al <= n)%nat ->
    (length (skipn n al) = 0)%nat.

Lemma skipn_short:
   forall {A} n (al: list A), (n >= length al)%nat -> skipn n al = nil.

Lemma nth_map':
  forall {A B} (f: A -> B) d d' i al,
  (i < length al)%nat ->
   nth i (map f al) d = f (nth i al d').

Lemma skipn_nil: forall A n, skipn n (@nil A) = nil.

Lemma skipn_drop:
 forall A n m (al: list A), skipn n (skipn m al) = skipn (n+m) al.

Lemma skipn_app1:
 forall A n (al bl: list A),
  (n <= length al)%nat ->
  skipn n (al++bl) = skipn n al ++ bl.

Lemma skipn_app2:
 forall A n (al bl: list A),
  (n >= length al)%nat ->
  skipn n (al++bl) = skipn (n-length al) bl.

Lemma list_repeat_app: forall A a b (x:A),
  list_repeat a x ++ list_repeat b x = list_repeat (a+b) x.

Lemma firstn_same:
  forall A n (b: list A), (n >= length b)%nat -> firstn n b = b.

Lemma nth_firstn_low:
 forall A i n al (d: A),
  (i < n <= length al)%nat -> nth i (firstn n al) d = nth i al d.

Lemma nth_error_nth:
  forall A (d: A) i al, (i < length al)%nat -> nth_error al i = Some (nth i al d).

Lemma skipn_rev:
  forall {A} n (vl: list A),
   skipn n (rev vl) = rev (firstn (length vl - n) vl).

Lemma Forall_list_repeat:
  forall {A} (P: A -> Prop) (n: nat) (a: A),
    P a -> Forall P (list_repeat n a).

Lemma skipn_firstn: forall {A} n m (xs: list A),
  skipn n (firstn m xs) = firstn (m-n) (skipn n xs).

Lemma rev_skipn:
 forall {A} n (vl: list A),
  rev (skipn n vl) = firstn (length vl -n) (rev vl).

Lemma firstn_skipn_rev:
  forall {A} lo n (vl: list A),
  (n+lo <= length vl)%nat ->
  firstn n (skipn lo (rev vl)) =
  rev (firstn n (skipn (length vl - (lo+n))%nat vl)).

Lemma map_firstn:
  forall A B (F: A -> B) n (al: list A),
  map F (firstn n al) = firstn n (map F al).

Lemma map_skipn:
  forall A B (F: A -> B) n (al: list A),
  map F (skipn n al) = skipn n (map F al).

Lemma Zlength_app: forall T (al bl: list T),
    Zlength (al++bl) = Zlength al + Zlength bl.

Lemma Zlength_rev: forall T (vl: list T), Zlength (rev vl) = Zlength vl.

Lemma Zlength_map: forall A B (f: A -> B) l, Zlength (map f l) = Zlength l.

Lemma ZtoNat_Zlength:
 forall {A} (l: list A), Z.to_nat (Zlength l) = length l.
Hint Rewrite @ZtoNat_Zlength : norm.

Lemma Zlength_nonneg:
 forall {A} (l: list A), 0 <= Zlength l.

Definition Zlength' := @Zlength.

Ltac pose_Zlength_nonneg1 T A :=
     lazymatch goal with
      | H:  0 <= @Zlength T A |- _ => idtac
      | H:  0 <= @Zlength T A /\ _ |- _ => idtac
      | |- _ => pose proof (@Zlength_nonneg T A)
     end;
     
     let x := fresh "x" in set (x:= @Zlength T A) in *;
     let y := fresh "y" in set (y := @Zlength) in x;
     fold @Zlength' in y; subst y; subst x.

Ltac pose_Zlength_nonneg :=
 repeat
  match goal with
  | |- context [@Zlength ?T ?A] => pose_Zlength_nonneg1 T A
  | H: context [@Zlength ?T ?A] |- _ => pose_Zlength_nonneg1 T A
 end;
  unfold Zlength' in *.

Ltac list_solve := autorewrite with sublist; pose_Zlength_nonneg; omega.

Definition Znth {X}{d: Inhabitant X} n (xs: list X) :=
  if (zlt n 0) then default else nth (Z.to_nat n) xs d.

Lemma Znth_map:
  forall {A:Type} {da: Inhabitant A}{B:Type}{db: Inhabitant B} i (f: A -> B) (al: list A),
  0 <= i < Zlength al ->
  Znth i (map f al)  = f (Znth i al).

Hint Rewrite 
   (@Znth_map Z _) (@Znth_map nat _) (@Znth_map positive _)
    using (auto; rewrite ?Zlength_map in *; omega) : sublist.

Lemma Znth_succ: forall {A}{a: Inhabitant A} i lo (v: list A), Z.succ lo <= i -> Znth (i - lo) v = Znth (i - (Z.succ lo)) (skipn 1 v).

Lemma Znth_0_cons {A}{a: Inhabitant A} l (v:A): Znth 0 (v::l) = v.
Hint Rewrite @Znth_0_cons : sublist.

Lemma Znth_pos_cons {A}{a: Inhabitant A} i l (v:A): 0<i -> Znth i (v::l) = Znth (i-1) l.

Lemma Znth_In : forall {A}{a: Inhabitant A} i l, 0 <= i < Zlength l -> In (Znth i l) l.

Lemma split3_full_length_list: forall {A}{a: Inhabitant A} lo mid hi (ct: list A),
  lo <= mid < hi ->
  Zlength ct = hi - lo ->
  ct = firstn (Z.to_nat (mid - lo)) ct ++

Lemma Forall_Znth:
 forall {A}{a: Inhabitant A} (F: A -> Prop) (al: list A) i,
   0 <= i < Zlength al ->
   Forall F al ->
   F (Znth i al).

Hint Rewrite @app_nil_l @app_nil_r : sublist.

Lemma app_Znth1:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i < Zlength l -> Znth i (l++l') = Znth i l.

Lemma app_Znth2:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i >= Zlength l -> Znth i (l++l') = Znth (i-Zlength l) l'.

Lemma Znth_firstn:
  forall {A}{a: Inhabitant A} (al: list A) (n m : Z),
  n<m -> Znth n (firstn (Z.to_nat m) al) = Znth n al.

Lemma Znth_skipn: forall {A}{a: Inhabitant A}  i n xs,
  0 <= i ->
  0 <= n ->
  Znth i (skipn (nat_of_Z n) xs) = Znth (i+n) xs.

Lemma Z2Nat_neg: forall i, i < 0 -> Z.to_nat i = 0%nat.

Lemma Zlength_firstn:
  forall {A} n (v: list A), Zlength (firstn (Z.to_nat n) v) = Z.min (Z.max 0 n) (Zlength v).

Lemma Zlength_skipn:
  forall {A} n (v: list A),
  Zlength (skipn (Z.to_nat n) v) = Z.max 0 (Zlength v - (Z.max 0n)).

Lemma Znth_cons:
 forall {A}(a: Inhabitant A)  i (al: list A) bl,
  0 <= i < Zlength al  ->
  Znth i al :: bl = firstn (Z.to_nat 1) (skipn (Z.to_nat i) al) ++ bl.

Lemma Zfirstn_app1:
 forall A n (al bl: list A),
  n <= Zlength al -> firstn (Z.to_nat n) (al++bl) = firstn (Z.to_nat n) al.

Lemma Zfirstn_same:
  forall A n (b: list A), n >= Zlength b -> firstn (Z.to_nat n) b = b.

Lemma Zfirstn_app2: forall {A} n (al bl: list A),
 n >= Zlength al ->
 firstn (Z.to_nat n) (al++bl) = al ++ firstn (Z.to_nat (n - Zlength al)) bl.

Lemma Zfirstn_firstn: forall {A} (contents: list A) n m,
  n <= m ->
  firstn (Z.to_nat n) (firstn (Z.to_nat m) contents) = firstn (Z.to_nat n) contents.
Lemma Zskipn_app1:
 forall A n (al bl: list A),
  n <= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat n) al ++ bl.

Lemma Zskipn_app2:
 forall A n (al bl: list A),
  n >= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat (n-Zlength al)) bl.

Lemma Znth_rev:
  forall {A}{d: Inhabitant A} i (al:list A),
  0 <= i < Zlength al ->
  Znth i (rev al) = Znth (Zlength al - i - 1) al.

Lemma Zskipn_firstn: forall {A} n m (xs: list A),
 0 <= n ->
 skipn (Z.to_nat n) (firstn (Z.to_nat m) xs) =

Lemma Zskipn_skipn: forall {A} n m (xs: list A),
  0 <= n -> 0 <= m ->
  skipn (Z.to_nat n) (skipn (Z.to_nat m) xs) = skipn (Z.to_nat (m + n)) xs.

Lemma Zfirstn_app:
 forall {A} n m (al: list A),
  0 <= n -> 0 <= m ->
  firstn (Z.to_nat n) al ++ firstn (Z.to_nat m) (skipn (Z.to_nat n) al) =

Lemma Zfirstn_exact_length:
  forall {A} n (al: list A),
  n = Zlength al ->
  firstn (Z.to_nat n) al = al.

Definition sublist {A} (lo hi: Z) (al: list A) : list A :=
  firstn (Z.to_nat (hi-lo)) (skipn (Z.to_nat lo) al).

Definition upd_Znth {A} (i: Z) (al: list A) (x: A): list A :=
   sublist 0 i al ++ x :: sublist (i+1) (Zlength al) al.

Lemma sublist_sublist {A} i j k m (l:list A): 0<=m -> 0<=k <=i -> i <= j-m ->
  sublist k i (sublist m j l) = sublist (k+m) (i+m) l.

Lemma sublist_rejoin:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid hi al = sublist lo hi al.

Lemma sublist_map:
  forall {A B} (F: A -> B) lo hi (al: list A),
  sublist lo hi (map F al) = map F (sublist lo hi al).

Lemma map_sublist:
  forall {A B} (F: A -> B) lo hi (al: list A),
  map F (sublist lo hi al) = sublist lo hi (map F al).

Lemma sublist_len_1:
  forall {A}{d: Inhabitant A} i (al: list A),
  0 <= i < Zlength al ->
  sublist i (i+1) al = Znth i al :: nil.

Lemma Znth_cons_sublist:
  forall {A}{d: Inhabitant A} i (al: list A) bl,
  0 <= i < Zlength al ->
  Znth i al :: bl = sublist i (i+1) al ++ bl.

Lemma Zlength_sublist:
  forall {A} lo hi (al: list A),
 0 <= lo <= hi -> hi <= Zlength al ->
 Zlength (sublist lo hi al) = hi-lo.

Lemma sublist_same_gen:
forall {A} lo hi (al: list A),
  lo = 0 -> hi >= Zlength al ->
  sublist lo hi al = al.

Lemma sublist_same:
forall {A} lo hi (al: list A),
  lo = 0 -> hi = Zlength al ->
  sublist lo hi al = al.

Lemma Znth_sublist:
  forall {A}{d: Inhabitant A} lo i hi (al: list A),
 0 <= lo ->
 0 <= i < hi-lo ->
 Znth i (sublist lo hi al) = Znth (i+lo) al.

Lemma rev_sublist:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  rev (sublist lo hi al) = sublist (Zlength al - hi) (Zlength al - lo) (rev al).

Lemma sublist_nil:
  forall {A} lo (al: list A),
  sublist lo lo al = nil.

Lemma sublist_nil_gen : forall {A} (l : list A) i j, j <= i -> sublist i j l = [].

Lemma sublist_rev:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  sublist lo hi (rev al) = rev (sublist (Zlength al - hi) (Zlength al - lo) al).

Lemma sublist_app:
  forall {A} lo hi (al bl: list A),
  0 <= lo <= hi -> hi <= Zlength al + Zlength bl ->
  sublist lo hi (al++bl) =
  sublist (Z.min lo (Zlength al)) (Z.min hi (Zlength al)) al ++

Lemma sublist_split:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo hi al = sublist lo mid al ++ sublist mid hi al.

Lemma sublist_last_1 : forall {A}{d: Inhabitant A} lo hi (al : list A), 0 <= lo <= hi -> hi + 1 <= Zlength al ->
  sublist lo (hi + 1) al = sublist lo hi al ++ [Znth hi al].

Lemma Zlen_le_1_rev:
 forall {A} (al: list A),
  Zlength al <= 1 -> rev al = al.

Lemma skipn_0:
  forall A (l: list A), skipn 0 l = l.

Lemma sublist_1_cons {A} l (v:A) n: sublist 1 n (v::l) = sublist 0 (n-1) l.

Lemma sublist_nil': forall (A : Type) (lo lo': Z) (al : list A), lo=lo' -> sublist lo lo' al = [].

Lemma sublist_skip {A} (l:list A) i : 0<=i ->  sublist i (Zlength l) l = skipn (Z.to_nat i) l.

Lemma sublist_firstn {A} (l:list A) i: sublist 0 i l = firstn (Z.to_nat i) l.

Lemma sublist_app1:
  forall (A : Type) (k i : Z) (al bl : list A),
  0 <= k <= i -> i <= Zlength al -> sublist k i (al ++ bl) = sublist k i al.

Lemma sublist0_app1 {A} i (al bl:list A): 0<= i <= Zlength al ->
  sublist 0 i (al ++ bl) = sublist 0 i al.

Lemma sublist_app2 {A} i j (al bl:list A): 0<=Zlength al <= i->
  sublist i j (al ++ bl) = sublist (i-Zlength al) (j-Zlength al) bl.

Lemma sublist_sublist0 {A} i j k (l:list A): 0<=k -> k<=i<=j ->
  sublist k i (sublist 0 j l) = sublist k i l.

Lemma sublist_sublist00 {A} i j (l:list A): 0<=i<=j ->
  sublist 0 i (sublist 0 j l) = sublist 0 i l.

Lemma skipn_list_repeat:
   forall A k n (a: A),
     (k <= n)%nat -> skipn k (list_repeat n a) = list_repeat (n-k) a.

Lemma sublist_list_repeat {A} i j k (v:A) (I: 0<=i)
          (IJK: i <= j <= k):
      sublist i j (list_repeat (Z.to_nat k) v) = list_repeat (Z.to_nat (j-i)) v.

Lemma Zlength_list_repeat:
  forall {A} n (x: A),
  0 <= n ->
  Zlength (list_repeat (Z.to_nat n) x) = n.

Lemma list_repeat_0:
  forall {A} (x:A), list_repeat (Z.to_nat 0) x = nil.

Lemma Znth_list_repeat_inrange:
  forall {A}{d: Inhabitant A} i n (a: A),
   (0 <= i < n)%Z ->
   Znth i (list_repeat (Z.to_nat n) a) = a.

Lemma firstn_nil {A} n: firstn n (nil:list A) = nil.

Lemma firstn_In {A} (x:A): forall l n, In x (firstn n l) -> In x l.
Lemma skipn_In {A} (x:A): forall l n, In x (skipn n l) -> In x l.

Lemma sublist_In {A} lo hi data (x:A) (I:In x (sublist lo hi data)): In x data.

Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Lemma sublist0_app2 {A : Type} i (al bl : list A):
  Zlength al <= i <= Zlength al + Zlength bl ->
  sublist 0 i (al ++ bl) = al ++ sublist 0 (i - Zlength al) bl.

Lemma sublist_rejoin':
  forall {A} lo mid mid' hi (al: list A),
  mid=mid' ->
  0 <= lo <= mid ->
  mid' <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid' hi al = sublist lo hi al.

Hint Rewrite @sublist_nil' using list_solve: sublist.
Hint Rewrite @app_nil_l : sublist.
Hint Rewrite @Zlength_rev : sublist.
Hint Rewrite @sublist_rejoin' using list_solve : sublist.

Lemma subsub1:
 forall a b : Z, (a-(a-b)) = b.
Hint Rewrite subsub1 : sublist.

Lemma sublist_app':
  forall {A} lo hi (al bl: list A),
  0 <= lo <= Zlength al ->
  0 <= hi-Zlength al <= Zlength bl ->
  sublist lo hi (al++bl) =
  sublist lo (Zlength al) al ++
  sublist 0 (hi-Zlength al) bl.

Lemma upd_Znth_Zlength {A} i (l:list A) v: 0<=i < Zlength l ->
      Zlength (upd_Znth i l v) = Zlength l.

Lemma upd_Znth_map {A B} (f:A -> B) i l v:
      upd_Znth i (map f l) (f v) =
      map f (upd_Znth i l v).

Lemma upd_Znth_lookup K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i j (v:A) (I: 0<=i<K) (J: 0<=j<K),
   (i=j /\ Znth i (upd_Znth j l v) = v) \/
   (i<>j /\ Znth i (upd_Znth j l v) = Znth i l).

Lemma upd_Znth_lookup' K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i (I: 0<=i<K) j (J: 0<=j<K) (v:A),
    Znth i (upd_Znth j l v) = if zeq i j then v else Znth i l.

Lemma upd_Znth_char {A} n l1 (v:A) l2 w: Zlength l1=n ->
      upd_Znth n (l1 ++ v :: l2) w = l1 ++ w :: l2.

Lemma upd_Znth_same {A}{d: Inhabitant A}: forall i l u, 0<= i< Zlength l -> Znth i (upd_Znth i l u) = u.

Lemma upd_Znth_diff {A}{d: Inhabitant A}: forall i j l u, 0<= i< Zlength l -> 0<= j< Zlength l -> i<>j ->
      Znth i (upd_Znth j l u) = Znth i l.

Lemma upd_Znth_app1 {A} i l1 l2 (I: 0 <= i < Zlength l1) (v:A):
      upd_Znth i (l1++l2) v = upd_Znth i l1 v ++ l2.

Lemma upd_Znth_app2 {A} (l1 l2:list A) i v:
  Zlength l1 <= i <= Zlength l1 + Zlength l2 ->
  upd_Znth i (l1 ++ l2) v = l1 ++ upd_Znth (i-Zlength l1) l2 v.

Lemma upd_Znth0 {A} (l:list A) v:
upd_Znth 0 l v = v :: sublist 1 (Zlength l) l.

Lemma sublist_upd_Znth_l: forall {A} (l: list A) i lo hi v,
  0 <= lo <= hi ->
  hi <= i < Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_r: forall {A} (l: list A) i lo hi v,
  0 <= i < lo ->
  lo <= hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_lr: forall {A} (l: list A) i lo hi v,
  0 <= lo <= i->
  i < hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = upd_Znth (i - lo) (sublist lo hi l) v.

Hint Rewrite @Znth_list_repeat_inrange : sublist.
Hint Rewrite @Zlength_cons @Zlength_nil: sublist.
Hint Rewrite @list_repeat_0: sublist.
Hint Rewrite <- @app_nil_end : sublist.
Hint Rewrite @Zlength_app: sublist.
Hint Rewrite @Zlength_map: sublist.
Hint Rewrite @Zlength_list_repeat using list_solve: sublist.
Hint Rewrite Z.sub_0_r Z.add_0_l Z.add_0_r : sublist.
Hint Rewrite @Zlength_sublist using list_solve: sublist.
Hint Rewrite Z.max_r Z.max_l using omega : sublist.
Hint Rewrite Z.min_r Z.min_l using omega : sublist.
Hint Rewrite Z.add_simpl_r Z.sub_add Z.sub_diag : sublist.
Hint Rewrite @sublist_sublist using list_solve : sublist.
Hint Rewrite @sublist_app1 using list_solve : sublist.
Hint Rewrite @sublist_app2 using list_solve : sublist.
Hint Rewrite @sublist_list_repeat  using list_solve : sublist.
Hint Rewrite @sublist_same using list_solve : sublist.
Hint Rewrite Z.add_simpl_l : sublist.
Hint Rewrite Z.add_add_simpl_l_l Z.add_add_simpl_l_r
     Z.add_add_simpl_r_l Z.add_add_simpl_r_r : sublist.
Hint Rewrite Z.add_0_r : sublist.
Hint Rewrite @app_Znth1 using list_solve : sublist.
Hint Rewrite @app_Znth2 using list_solve : sublist.
Hint Rewrite @Znth_sublist using list_solve : sublist.
Hint Rewrite @upd_Znth_Zlength using list_solve : sublist.

Hint Rewrite @sublist_nil : sublist.

Lemma list_repeat_app':
 forall {A: Type} a b (x:A), 
    0 <= a -> 0 <= b ->
    list_repeat (Z.to_nat a) x ++ list_repeat (Z.to_nat b) x = list_repeat (Z.to_nat (a+b)) x.

Lemma Znth_overflow:
  forall {A}{d: Inhabitant A} i (al: list A), i >= Zlength al -> Znth i al = d.

Lemma Znth_underflow:
  forall {A}{d: Inhabitant A} i (al: list A),  i < 0 -> Znth i al = d.

Lemma Znth_outofbounds:
  forall {A}{d: Inhabitant A} i (al: list A),  (i < 0 \/ i >= Zlength al) -> Znth i al = d.

Lemma sublist_one:
  forall {A}{d: Inhabitant A} lo hi (al: list A),
    0 <= lo -> hi <= Zlength al ->
    lo+1=hi -> sublist lo hi al = Znth lo al :: nil.

Lemma Forall_app :
forall {A} P (l1 l2 :list A),
Forall P (l1 ++ l2) <->
Forall P l1 /\ Forall P l2.

Lemma Forall_firstn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (firstn n l).

Lemma Forall_skipn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (skipn n l).

Lemma Forall_map:
  forall {A B} (f: B -> Prop) (g: A -> B) al,
   Forall f (map g al) <-> Forall (Basics.compose f g) al.

Lemma Forall_sublist:
  forall {A} (f: A -> Prop) lo hi al,
   Forall f al -> Forall f (sublist lo hi al).

Hint Rewrite @upd_Znth_app1 using list_solve : sublist.
Hint Rewrite @upd_Znth_app2 using list_solve : sublist.

Lemma map_list_repeat: forall {A B} (f: A->B) n (x:A), map f (list_repeat n x) = list_repeat n (f x).
Hint Rewrite @map_list_repeat : sublist.

Lemma Zlength_sublist_correct: forall {A} (l: list A) (lo hi: Z),
  0 <= lo <= hi ->
  hi <= Zlength l ->
  Zlength (sublist lo hi l) = hi - lo.

Lemma Zlength_sublist_incorrect: forall {A} (l: list A) (lo hi: Z),
  0 <= lo < hi ->
  hi > Zlength l ->
  Zlength (sublist lo hi l) < hi - lo.

Lemma nth_Znth {A} {d: Inhabitant A}:
forall n (xs:list A), 0 <= n < Zlength xs -> (nth (Z.to_nat n) xs d) = (Znth n xs). *)

Require Import atomics.hashtable1.
(* atomics.hashtable1:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition _CAS_SC : ident := 74%positive.
Definition ___builtin_annot : ident := 8%positive.
Definition ___builtin_annot_intval : ident := 9%positive.
Definition ___builtin_bswap : ident := 32%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 6%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 10%positive.
Definition ___builtin_memcpy_aligned : ident := 7%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 12%positive.
Definition ___builtin_va_copy : ident := 13%positive.
Definition ___builtin_va_end : ident := 14%positive.
Definition ___builtin_va_start : ident := 11%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 18%positive.
Definition ___compcert_va_float64 : ident := 17%positive.
Definition ___compcert_va_int32 : ident := 15%positive.
Definition ___compcert_va_int64 : ident := 16%positive.
Definition ___i64_dtos : ident := 19%positive.
Definition ___i64_dtou : ident := 20%positive.
Definition ___i64_sar : ident := 31%positive.
Definition ___i64_sdiv : ident := 25%positive.
Definition ___i64_shl : ident := 29%positive.
Definition ___i64_shr : ident := 30%positive.
Definition ___i64_smod : ident := 27%positive.
Definition ___i64_stod : ident := 21%positive.
Definition ___i64_stof : ident := 23%positive.
Definition ___i64_udiv : ident := 26%positive.
Definition ___i64_umod : ident := 28%positive.
Definition ___i64_utod : ident := 22%positive.
Definition ___i64_utof : ident := 24%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 59%positive.
Definition _add_item : ident := 92%positive.
Definition _arg : ident := 97%positive.
Definition _atomic_loc : ident := 5%positive.
Definition _c : ident := 73%positive.
Definition _entry : ident := 79%positive.
Definition _exit : ident := 54%positive.
Definition _f : ident := 102%positive.
Definition _free : ident := 55%positive.
Definition _free_atomic : ident := 68%positive.
Definition _freelock : ident := 58%positive.
Definition _freelock2 : ident := 80%positive.
Definition _freeze_table : ident := 96%positive.
Definition _get_item : ident := 91%positive.
Definition _i : ident := 64%positive.
Definition _i__1 : ident := 103%positive.
Definition _i__2 : ident := 104%positive.
Definition _i__3 : ident := 106%positive.
Definition _idx : ident := 87%positive.
Definition _init_table : ident := 93%positive.
Definition _integer_hash : ident := 86%positive.
Definition _key : ident := 77%positive.
Definition _keys : ident := 94%positive.
Definition _l : ident := 65%positive.
Definition _l__1 : ident := 105%positive.
Definition _load_SC : ident := 70%positive.
Definition _load_relaxed : ident := 75%positive.
Definition _lock : ident := 4%positive.
Definition _lock_t : ident := 2%positive.
Definition _m_entries : ident := 83%positive.
Definition _main : ident := 76%positive.
Definition _make_atomic : ident := 66%positive.
Definition _makelock : ident := 57%positive.
Definition _malloc : ident := 56%positive.
Definition _n : ident := 61%positive.
Definition _p : ident := 62%positive.
Definition _probed_key : ident := 88%positive.
Definition _r : ident := 101%positive.
Definition _release : ident := 60%positive.
Definition _release2 : ident := 81%positive.
Definition _res : ident := 99%positive.
Definition _result : ident := 89%positive.
Definition _results : ident := 85%positive.
Definition _set_item : ident := 90%positive.
Definition _spawn : ident := 82%positive.
Definition _store_SC : ident := 72%positive.
Definition _surely_malloc : ident := 63%positive.
Definition _t : ident := 98%positive.
Definition _tgt : ident := 67%positive.
Definition _thread_locks : ident := 84%positive.
Definition _total : ident := 100%positive.
Definition _v : ident := 71%positive.
Definition _val : ident := 3%positive.
Definition _value : ident := 78%positive.
Definition _values : ident := 95%positive.
Definition _x : ident := 69%positive.
Definition _t'1 : ident := 107%positive.
Definition _t'2 : ident := 108%positive.
Definition _t'3 : ident := 109%positive.
Definition _t'4 : ident := 110%positive.

Definition v_m_entries := {|
  gvar_info := (tarray (Tstruct _entry noattr) 16384);
  gvar_init := (Init_space 131072 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_thread_locks := {|
  gvar_info := (tarray (tptr (Tstruct _lock_t noattr)) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_results := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_integer_hash := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_i, tint) :: nil);
  fn_vars := nil;
  fn_temps := nil;
  fn_body :=
(Sreturn (Some (Ebinop Omul (Ecast (Etempvar _i tint) tuint)
                 (Ecast (Econst_int (Int.repr 654435761) tint) tuint) tuint)))
|}.

Definition f_set_item := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr (Tstruct _atomic_loc noattr))) ::
               (_probed_key, tint) :: (_result, tint) :: (_t'4, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key
              (tptr (Tstruct _atomic_loc noattr))))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction
                                 (Tcons (tptr (Tstruct _atomic_loc noattr))
                                   Tnil) tint cc_default))
                ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                 (Econst_int (Int.repr 0) tint) tint)
                    Scontinue
                    Sskip)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'3)
                        (Evar _CAS_SC (Tfunction
                                        (Tcons
                                          (tptr (Tstruct _atomic_loc noattr))
                                          (Tcons tint (Tcons tint Tnil)))
                                        tint cc_default))
                        ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                         (Econst_int (Int.repr 0) tint) ::
                         (Etempvar _key tint) :: nil))
                      (Sset _result (Etempvar _t'3 tint)))
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_SC (Tfunction
                                             (Tcons
                                               (tptr (Tstruct _atomic_loc noattr))
                                               Tnil) tint cc_default))
                            ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                             nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          Scontinue
                          Sskip))
                      Sskip)))
                Sskip)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value
                    (tptr (Tstruct _atomic_loc noattr))))
                (Ssequence
                  (Scall None
                    (Evar _store_SC (Tfunction
                                      (Tcons
                                        (tptr (Tstruct _atomic_loc noattr))
                                        (Tcons tint Tnil)) tvoid cc_default))
                    ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                     (Etempvar _value tint) :: nil))
                  (Sreturn None))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_get_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr (Tstruct _atomic_loc noattr))) ::
               (_probed_key, tint) :: (_t'3, tint) :: (_t'2, tint) ::
               (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key
              (tptr (Tstruct _atomic_loc noattr))))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction
                                 (Tcons (tptr (Tstruct _atomic_loc noattr))
                                   Tnil) tint cc_default))
                ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Ssequence
                  (Sset _i
                    (Efield
                      (Ederef
                        (Ebinop Oadd
                          (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                          (Etempvar _idx tint)
                          (tptr (Tstruct _entry noattr)))
                        (Tstruct _entry noattr)) _value
                      (tptr (Tstruct _atomic_loc noattr))))
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _load_SC (Tfunction
                                       (Tcons
                                         (tptr (Tstruct _atomic_loc noattr))
                                         Tnil) tint cc_default))
                      ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                       nil))
                    (Sreturn (Some (Etempvar _t'3 tint)))))
                Sskip)
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Econst_int (Int.repr 0) tint) tint)
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))
                Sskip))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_add_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr (Tstruct _atomic_loc noattr))) ::
               (_probed_key, tint) :: (_result, tint) :: (_t'4, tint) ::
               (_t'3, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _integer_hash (Tfunction (Tcons tint Tnil) tint cc_default))
      ((Etempvar _key tint) :: nil))
    (Sset _idx (Etempvar _t'1 tint)))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _idx
          (Ebinop Oand (Etempvar _idx tint)
            (Ebinop Osub (Econst_int (Int.repr 16384) tint)
              (Econst_int (Int.repr 1) tint) tint) tint))
        (Ssequence
          (Sset _i
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key
              (tptr (Tstruct _atomic_loc noattr))))
          (Ssequence
            (Ssequence
              (Scall (Some _t'2)
                (Evar _load_SC (Tfunction
                                 (Tcons (tptr (Tstruct _atomic_loc noattr))
                                   Tnil) tint cc_default))
                ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) :: nil))
              (Sset _probed_key (Etempvar _t'2 tint)))
            (Ssequence
              (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                             (Etempvar _key tint) tint)
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))
                Sskip)
              (Ssequence
                (Sifthenelse (Ebinop One (Etempvar _probed_key tint)
                               (Econst_int (Int.repr 0) tint) tint)
                  Scontinue
                  Sskip)
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _CAS_SC (Tfunction
                                      (Tcons
                                        (tptr (Tstruct _atomic_loc noattr))
                                        (Tcons tint (Tcons tint Tnil))) tint
                                      cc_default))
                      ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                       (Econst_int (Int.repr 0) tint) ::
                       (Etempvar _key tint) :: nil))
                    (Sset _result (Etempvar _t'3 tint)))
                  (Ssequence
                    (Sifthenelse (Eunop Onotbool (Etempvar _result tint)
                                   tint)
                      (Ssequence
                        (Ssequence
                          (Scall (Some _t'4)
                            (Evar _load_SC (Tfunction
                                             (Tcons
                                               (tptr (Tstruct _atomic_loc noattr))
                                               Tnil) tint cc_default))
                            ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                             nil))
                          (Sset _probed_key (Etempvar _t'4 tint)))
                        (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                                       (Etempvar _key tint) tint)
                          (Sreturn (Some (Econst_int (Int.repr 0) tint)))
                          Scontinue))
                      Sskip)
                    (Ssequence
                      (Sset _i
                        (Efield
                          (Ederef
                            (Ebinop Oadd
                              (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                              (Etempvar _idx tint)
                              (tptr (Tstruct _entry noattr)))
                            (Tstruct _entry noattr)) _value
                          (tptr (Tstruct _atomic_loc noattr))))
                      (Ssequence
                        (Scall None
                          (Evar _store_SC (Tfunction
                                            (Tcons
                                              (tptr (Tstruct _atomic_loc noattr))
                                              (Tcons tint Tnil)) tvoid
                                            cc_default))
                          ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                           (Etempvar _value tint) :: nil))
                        (Sreturn (Some (Econst_int (Int.repr 1) tint)))))))))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_init_table := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_t'2, (tptr (Tstruct _atomic_loc noattr))) ::
               (_t'1, (tptr (Tstruct _atomic_loc noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sset _i (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                     (Econst_int (Int.repr 16384) tint) tint)
        Sskip
        Sbreak)
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _make_atomic (Tfunction (Tcons tint Tnil)
                                 (tptr (Tstruct _atomic_loc noattr))
                                 cc_default))
            ((Econst_int (Int.repr 0) tint) :: nil))
          (Sassign
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _key
              (tptr (Tstruct _atomic_loc noattr)))
            (Etempvar _t'1 (tptr (Tstruct _atomic_loc noattr)))))
        (Ssequence
          (Scall (Some _t'2)
            (Evar _make_atomic (Tfunction (Tcons tint Tnil)
                                 (tptr (Tstruct _atomic_loc noattr))
                                 cc_default))
            ((Econst_int (Int.repr 0) tint) :: nil))
          (Sassign
            (Efield
              (Ederef
                (Ebinop Oadd
                  (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                  (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                (Tstruct _entry noattr)) _value
              (tptr (Tstruct _atomic_loc noattr)))
            (Etempvar _t'2 (tptr (Tstruct _atomic_loc noattr)))))))
    (Sset _i
      (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_freeze_table := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_keys, (tptr tint)) :: (_values, (tptr tint)) :: nil);
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_l, (tptr (Tstruct _atomic_loc noattr))) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _i (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                     (Econst_int (Int.repr 16384) tint) tint)
        Sskip
        Sbreak)
      (Ssequence
        (Sset _l
          (Efield
            (Ederef
              (Ebinop Oadd
                (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
              (Tstruct _entry noattr)) _key
            (tptr (Tstruct _atomic_loc noattr))))
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _free_atomic (Tfunction
                                   (Tcons (tptr (Tstruct _atomic_loc noattr))
                                     Tnil) tint cc_default))
              ((Etempvar _l (tptr (Tstruct _atomic_loc noattr))) :: nil))
            (Sassign
              (Ederef
                (Ebinop Oadd (Etempvar _keys (tptr tint)) (Etempvar _i tint)
                  (tptr tint)) tint) (Etempvar _t'1 tint)))
          (Ssequence
            (Sset _l
              (Efield
                (Ederef
                  (Ebinop Oadd
                    (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                    (Etempvar _i tint) (tptr (Tstruct _entry noattr)))
                  (Tstruct _entry noattr)) _value
                (tptr (Tstruct _atomic_loc noattr))))
            (Ssequence
              (Scall (Some _t'2)
                (Evar _free_atomic (Tfunction
                                     (Tcons
                                       (tptr (Tstruct _atomic_loc noattr))
                                       Tnil) tint cc_default))
                ((Etempvar _l (tptr (Tstruct _atomic_loc noattr))) :: nil))
              (Sassign
                (Ederef
                  (Ebinop Oadd (Etempvar _values (tptr tint))
                    (Etempvar _i tint) (tptr tint)) tint)
                (Etempvar _t'2 tint)))))))
    (Sset _i
      (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_f := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_t, tint) :: (_l, (tptr (Tstruct _lock_t noattr))) ::
               (_res, (tptr tint)) :: (_total, tint) :: (_i, tint) ::
               (_r, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _t (Ederef (Ecast (Etempvar _arg (tptr tvoid)) (tptr tint)) tint))
  (Ssequence
    (Sset _l
      (Ederef
        (Ebinop Oadd
          (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
          (Etempvar _t tint) (tptr (tptr (Tstruct _lock_t noattr))))
        (tptr (Tstruct _lock_t noattr))))
    (Ssequence
      (Sset _res
        (Ederef
          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
            (Etempvar _t tint) (tptr (tptr tint))) (tptr tint)))
      (Ssequence
        (Sset _total (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Scall None
            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                          cc_default)) ((Etempvar _arg (tptr tvoid)) :: nil))
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 3) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'1)
                        (Evar _add_item (Tfunction
                                          (Tcons tint (Tcons tint Tnil)) tint
                                          cc_default))
                        ((Ebinop Oadd (Etempvar _i tint)
                           (Econst_int (Int.repr 1) tint) tint) ::
                         (Econst_int (Int.repr 1) tint) :: nil))
                      (Sset _r (Etempvar _t'1 tint)))
                    (Sifthenelse (Etempvar _r tint)
                      (Sset _total
                        (Ebinop Oadd (Etempvar _total tint)
                          (Econst_int (Int.repr 1) tint) tint))
                      Sskip)))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Sassign (Ederef (Etempvar _res (tptr tint)) tint)
                (Etempvar _total tint))
              (Ssequence
                (Scall None
                  (Evar _release2 (Tfunction (Tcons (tptr tvoid) Tnil) tvoid
                                    cc_default))
                  ((Etempvar _l (tptr (Tstruct _lock_t noattr))) :: nil))
                (Sreturn (Some (Econst_int (Int.repr 0) tint)))))))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_keys, (tarray tint 16384)) ::
              (_values, (tarray tint 16384)) :: nil);
  fn_temps := ((_total, tint) :: (_i, tint) ::
               (_l, (tptr (Tstruct _lock_t noattr))) :: (_i__1, tint) ::
               (_t, (tptr tint)) :: (_i__2, tint) ::
               (_l__1, (tptr (Tstruct _lock_t noattr))) ::
               (_r, (tptr tint)) :: (_i__3, tint) :: (_t'3, (tptr tvoid)) ::
               (_t'2, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _total (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Scall None (Evar _init_table (Tfunction Tnil tvoid cc_default)) nil)
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof (Tstruct _lock_t noattr) tuint) :: nil))
                  (Sset _l
                    (Ecast (Etempvar _t'1 (tptr tvoid))
                      (tptr (Tstruct _lock_t noattr)))))
                (Ssequence
                  (Sassign
                    (Ederef
                      (Ebinop Oadd
                        (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                        (Etempvar _i tint)
                        (tptr (tptr (Tstruct _lock_t noattr))))
                      (tptr (Tstruct _lock_t noattr)))
                    (Etempvar _l (tptr (Tstruct _lock_t noattr))))
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                               (tptr tvoid) cc_default))
                        ((Esizeof tint tuint) :: nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Evar _results (tarray (tptr tint) 3))
                            (Etempvar _i tint) (tptr (tptr tint)))
                          (tptr tint))
                        (Ecast (Etempvar _t'2 (tptr tvoid)) (tptr tint))))
                    (Scall None
                      (Evar _makelock (Tfunction (Tcons (tptr tvoid) Tnil)
                                        tvoid cc_default))
                      ((Ecast (Etempvar _l (tptr (Tstruct _lock_t noattr)))
                         (tptr tvoid)) :: nil))))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Ssequence
          (Ssequence
            (Sset _i__1 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__1 tint)
                               (Econst_int (Int.repr 3) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Ssequence
                    (Scall (Some _t'3)
                      (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                             (tptr tvoid) cc_default))
                      ((Esizeof tint tuint) :: nil))
                    (Sset _t
                      (Ecast (Etempvar _t'3 (tptr tvoid)) (tptr tint))))
                  (Ssequence
                    (Sassign (Ederef (Etempvar _t (tptr tint)) tint)
                      (Etempvar _i__1 tint))
                    (Scall None
                      (Evar _spawn (Tfunction
                                     (Tcons
                                       (tptr (Tfunction
                                               (Tcons (tptr tvoid) Tnil)
                                               (tptr tvoid) cc_default))
                                       (Tcons (tptr tvoid) Tnil)) tvoid
                                     cc_default))
                      ((Ecast
                         (Eaddrof
                           (Evar _f (Tfunction (Tcons (tptr tvoid) Tnil)
                                      (tptr tvoid) cc_default))
                           (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                   (tptr tvoid) cc_default))) (tptr tvoid)) ::
                       (Ecast (Etempvar _t (tptr tint)) (tptr tvoid)) :: nil)))))
              (Sset _i__1
                (Ebinop Oadd (Etempvar _i__1 tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Ssequence
            (Ssequence
              (Sset _i__2 (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i__2 tint)
                                 (Econst_int (Int.repr 3) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Sset _l__1
                      (Ederef
                        (Ebinop Oadd
                          (Evar _thread_locks (tarray (tptr (Tstruct _lock_t noattr)) 3))
                          (Etempvar _i__2 tint)
                          (tptr (tptr (Tstruct _lock_t noattr))))
                        (tptr (Tstruct _lock_t noattr))))
                    (Ssequence
                      (Scall None
                        (Evar _acquire (Tfunction (Tcons (tptr tvoid) Tnil)
                                         tvoid cc_default))
                        ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                         nil))
                      (Ssequence
                        (Scall None
                          (Evar _freelock2 (Tfunction
                                             (Tcons (tptr tvoid) Tnil) tvoid
                                             cc_default))
                          ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                           nil))
                        (Ssequence
                          (Scall None
                            (Evar _free (Tfunction (Tcons (tptr tvoid) Tnil)
                                          tvoid cc_default))
                            ((Etempvar _l__1 (tptr (Tstruct _lock_t noattr))) ::
                             nil))
                          (Ssequence
                            (Sset _r
                              (Ederef
                                (Ebinop Oadd
                                  (Evar _results (tarray (tptr tint) 3))
                                  (Etempvar _i__2 tint) (tptr (tptr tint)))
                                (tptr tint)))
                            (Ssequence
                              (Sset _i__3
                                (Ederef (Etempvar _r (tptr tint)) tint))
                              (Ssequence
                                (Scall None
                                  (Evar _free (Tfunction
                                                (Tcons (tptr tvoid) Tnil)
                                                tvoid cc_default))
                                  ((Etempvar _r (tptr tint)) :: nil))
                                (Sset _total
                                  (Ebinop Oadd (Etempvar _total tint)
                                    (Etempvar _i__3 tint) tint))))))))))
                (Sset _i__2
                  (Ebinop Oadd (Etempvar _i__2 tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Scall None
              (Evar _freeze_table (Tfunction
                                    (Tcons (tptr tint)
                                      (Tcons (tptr tint) Tnil)) tvoid
                                    cc_default))
              ((Evar _keys (tarray tint 16384)) ::
               (Evar _values (tarray tint 16384)) :: nil)))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _lock_t Struct ((_a, (tarray (tptr tvoid) 2)) :: nil) noattr ::
 Composite _entry Struct
   ((_key, (tptr (Tstruct _atomic_loc noattr))) ::
    (_value, (tptr (Tstruct _atomic_loc noattr))) :: nil)
   noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_free, Gfun(External EF_free (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_makelock,
   Gfun(External (EF_external "makelock"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_acquire,
   Gfun(External (EF_external "acquire"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_freelock2,
   Gfun(External (EF_external "freelock2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_release2,
   Gfun(External (EF_external "release2"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (_spawn,
   Gfun(External (EF_external "spawn"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons
       (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default))
       (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (_surely_malloc,
   Gfun(External (EF_external "surely_malloc"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_make_atomic,
   Gfun(External (EF_external "make_atomic"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tint Tnil) (tptr (Tstruct _atomic_loc noattr)) cc_default)) ::
 (_free_atomic,
   Gfun(External (EF_external "free_atomic"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) tint cc_default)) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_CAS_SC,
   Gfun(External (EF_external "CAS_SC"
                   (mksignature (AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr))
       (Tcons tint (Tcons tint Tnil))) tint cc_default)) ::
 (_m_entries, Gvar v_m_entries) :: (_thread_locks, Gvar v_thread_locks) ::
 (_results, Gvar v_results) ::
 (_integer_hash, Gfun(Internal f_integer_hash)) ::
 (_set_item, Gfun(Internal f_set_item)) ::
 (_get_item, Gfun(Internal f_get_item)) ::
 (_add_item, Gfun(Internal f_add_item)) ::
 (_init_table, Gfun(Internal f_init_table)) ::
 (_freeze_table, Gfun(Internal f_freeze_table)) ::
 (_f, Gfun(Internal f_f)) :: (_main, Gfun(Internal f_main)) :: nil);
prog_public :=
(_main :: _f :: _freeze_table :: _init_table :: _add_item :: _get_item ::
 _set_item :: _integer_hash :: _results :: _thread_locks :: _m_entries ::
 _CAS_SC :: _store_SC :: _load_SC :: _free_atomic :: _make_atomic ::
 _surely_malloc :: _spawn :: _release2 :: _freelock2 :: _acquire ::
 _makelock :: _free :: ___builtin_debug :: ___builtin_nop ::
 ___builtin_write32_reversed :: ___builtin_write16_reversed ::
 ___builtin_read32_reversed :: ___builtin_read16_reversed ::
 ___builtin_fnmsub :: ___builtin_fnmadd :: ___builtin_fmsub ::
 ___builtin_fmadd :: ___builtin_fmin :: ___builtin_fmax ::
 ___builtin_fsqrt :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap16 :: ___builtin_bswap32 :: ___builtin_bswap ::
 ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod :: ___i64_smod ::
 ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof :: ___i64_utod ::
 ___i64_stod :: ___i64_dtou :: ___i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)

Require Import atomics.hashtable.
(* atomics.hashtable:
Require Import VST.progs.conclib.
Require Import VST.floyd.sublist.

Set Bullet Behavior "Strict Subproofs".

Fixpoint index_of (m : list (Z * Z)) (k : Z) :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of rest k)
  end.

Lemma index_of_spec : forall k m, match index_of m k with
  | Some i => 0 <= i < Zlength m /\ fst (Znth i m) = k /\ Forall (fun x => fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) end.

Class hash_fun := { size : Z; hash : Z -> Z; size_pos : size > 0; hash_range : forall i, 0 <= hash i < size }.

Section Hashtable.

Context {hf : hash_fun}.
Hint Resolve size_pos hash_range.

Definition rebase {A} (m : list A) i := rotate m (Zlength m - i) (Zlength m).

Definition well_chained (m : list (Z * Z)) := forall k i, index_of (rebase m (hash k)) k = Some i ->
  Forall (fun x => fst x <> 0) (sublist 0 i (rebase m (hash k))).

Definition wf_map (m : list (Z * Z)) := NoDup (map fst m).

Definition indices i j := (map (fun x => (i + x) mod size) (upto (Z.to_nat ((j - i) mod size)))).

Fixpoint index_of' (m : list (Z * Z)) k :=
  match m with
  | [] => None
  | (k1, v1) :: rest => if eq_dec k1 0 then Some 0 else
                        if eq_dec k1 k then Some 0
                        else option_map Z.succ (index_of' rest k)
  end.

Definition lookup (m : list (Z * Z)) (k : Z) :=
  option_map (fun i => (i + hash k) mod size) (index_of' (rebase m (hash k)) k).

Definition set m k v := option_map (fun i => upd_Znth i m (k, v)) (lookup m k).

Definition get m k := match lookup m k with Some i => let '(k', v') := Znth i m in
  if eq_dec k' 0 then None else Some v' | None => None end.

Lemma rebase_0 : forall {A} {d : Inhabitant A} (m : list A) i, 0 <= i < Zlength m -> Znth 0 (rebase m i) = Znth i m.

Lemma index_of'_spec : forall k m, match index_of' m k with
  | Some i => 0 <= i < Zlength m /\ (fst (Znth i m) = k \/ fst (Znth i m) = 0) /\
              Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m)
  | None => ~In k (map fst m) /\ ~In 0 (map fst m)
  end.

Lemma Znth_rebase : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth i (rebase m j) = Znth ((i + j) mod Zlength m) m.

Corollary Znth_rebase' : forall {A} {d : Inhabitant A} (m : list A) i j, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  Znth ((i - j) mod Zlength m) (rebase m j) = Znth i m.

Lemma index_of'_upd : forall m k v i (Hrange : 0 <= i < Zlength m)
  (Hi : fst (Znth i m) = k \/ fst (Znth i m) = 0),
  index_of' (upd_Znth i m (k, v)) k = index_of' m k.

Lemma Zlength_rebase : forall {A} (m : list A) i, 0 <= i < Zlength m -> Zlength (rebase m i) = Zlength m.

Lemma rebase_upd : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth i m x) j = upd_Znth ((i - j) mod Zlength m) (rebase m j) x.

Corollary rebase_upd' : forall {A} (m : list A) i j x, 0 <= i < Zlength m -> 0 <= j < Zlength m ->
  rebase (upd_Znth ((i + j) mod Zlength m) m x) j = upd_Znth i (rebase m j) x.

Lemma lookup_set : forall m k v m', set m k v = Some m' -> Zlength m = size -> lookup m' k = lookup m k.

Lemma lookup_range : forall m k i, lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m.

Lemma index_of'_upd2 : forall m k i k' v' (Hrange : 0 <= i < Zlength m)
  (Hi : index_of' m k <> Some i) (Hdiff : k' <> k /\ k' <> 0),
  index_of' (upd_Znth i m (k', v')) k = index_of' m k.

Lemma lookup_upd_same : forall m k i v', lookup m k = Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  lookup (upd_Znth i m (k, v')) k = lookup m k.

Lemma lookup_upd_diff : forall m k i k' v', lookup m k <> Some i -> Zlength m = size -> 0 <= i < Zlength m ->
  k' <> k /\ k' <> 0 ->
  lookup (upd_Znth i m (k', v')) k = lookup m k.

Lemma Zlength_set : forall m k v m', set m k v = Some m' -> Zlength m = size ->
  Zlength m' = size.

Lemma get_set_same : forall m k v m', set m k v = Some m' -> Zlength m = size -> k <> 0 ->
  get m' k = Some v.

Lemma get_override : forall m k v m' v', set m k v = Some m' -> Zlength m = size -> set m' k v' = set m k v'.

Lemma index_of_app : forall k m1 m2, index_of (m1 ++ m2) k =
  match index_of m1 k with Some i => Some i | None => option_map (Z.add (Zlength m1)) (index_of m2 k) end.

Lemma index_of_out : forall k m, Forall (fun x => fst x <> k) m -> index_of m k = None.

Lemma index_of_sublist : forall m a b i k (HNoDup : NoDup (map fst m))
  (Hi : index_of (sublist a b m) k = Some i) (Ha : 0 <= a) (Hb : b <= Zlength m),
  index_of m k = Some (i + a).

Lemma index_of_rotate : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rotate m n (Zlength m)) k = option_map (fun i => (i + n) mod Zlength m) (index_of m k).

Corollary index_of_rebase : forall m n k, 0 <= n <= Zlength m -> NoDup (map fst m) ->
  index_of (rebase m n) k = option_map (fun i => (i - n) mod Zlength m) (index_of m k).

Lemma index_of'_succeeds : forall k m i (Hi : 0 <= i < Zlength m)
  (Hnz : Forall (fun x => fst x <> 0 /\ fst x <> k) (sublist 0 i m))
  (Hk : fst (Znth i m) = k \/ fst (Znth i m) = 0), index_of' m k = Some i.

Lemma lookup_spec : forall m k (Hwf : wf_map m) (Hchain : well_chained m) (Hlen : Zlength m = size)
  (Hnz : k <> 0) (Hin : In k (map fst m)), lookup m k = index_of m k.

End Hashtable.

Lemma sepcon_rebase : forall l m, 0 <= m <= Zlength l ->
  fold_right sepcon emp l = fold_right sepcon emp (rebase l m).

Lemma rebase_map : forall {A B} (f : A -> B) l m, rebase (map f l) m = map f (rebase l m). *)



Set Bullet Behavior "Strict Subproofs".



Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.



Definition release2_spec := DECLARE _release2 release2_spec.

Definition freelock2_spec := DECLARE _freelock2 (freelock2_spec _).

Definition spawn_spec := DECLARE _spawn spawn_spec.



Definition integer_hash_spec :=

 DECLARE _integer_hash

  WITH i : Z

  PRE [ _i OF tint ]

   PROP () LOCAL (temp _i (vint i)) SEP ()

  POST [ tint ]

   PROP () LOCAL (temp ret_temp (vint (i * 654435761))) SEP ().



Definition tentry := Tstruct _entry noattr.



Instance hf1 : hash_fun := { size := 16384; hash i := (i * 654435761) mod 16384 }.

Proof.

  - computable.

  - intro; apply Z_mod_lt; computable.

Defined.



Definition k_R (h : list hist_el) (v : Z) := !!(Forall int_op h /\

  forall e, In e h -> value_of e <> vint 0 -> vint v = value_of e) && emp.



Definition v_R (h : list hist_el) (v : Z) := emp.



Definition wf_hists h := Forall (fun x => (ordered_hist (fst x) /\ Forall int_op (map snd (fst x))) /\

  (ordered_hist (snd x) /\ Forall int_op (map snd (snd x)))) h.



Definition make_map h :=

  map (fun hs => (make_int (value_of_hist (fst hs)), make_int (value_of_hist (snd hs)))) h.



Definition atomic_entry sh pk pv gk gv hk hv :=

  atomic_loc_hist sh pk gk 0 k_R hk * atomic_loc_hist sh pv gv 0 v_R hv.



Definition atomic_entries sh entries ghosts hists := fold_right sepcon emp

  (map (fun x => let '((pk, pv), (gk, gv), (hk, hv)) := x in atomic_entry sh pk pv gk gv hk hv)

    (combine (combine entries ghosts) hists)).



Definition failed_CAS k (a b : hist * hist) := exists r, repable_signed r /\

  (add_events (fst a) [Load (vint r)] (fst b) \/

   add_events (fst a) [Load (vint 0); CAS (vint r) (vint 0) (vint k); Load (vint r)] (fst b)) /\

  r <> 0 /\ r <> k /\ snd b = snd a /\

  (let v := value_of_hist (fst a) in v <> vint 0 -> v = vint r).



Definition found_key k (a b : hist) := (add_events a [Load (vint k)] b \/

  add_events a [Load (vint 0); CAS (vint 0) (vint 0) (vint k)] b \/

  add_events a [Load (vint 0); CAS (vint k) (vint 0) (vint k); Load (vint k)] b) /\

  let v := value_of_hist a in v <> vint 0 -> v = vint k.



Definition set_item_trace (h : list (hist * hist)) k v i h' := Zlength h' = Zlength h /\

  0 <= i < Zlength h /\ found_key k (fst (Znth i h ([], []))) (fst (Znth i h' ([], []))) /\

  (add_events (snd (Znth i h ([], []))) [Store (vint v)] (snd (Znth i h' ([], [])))) /\

  forall j, (In j (indices (hash k) i) -> failed_CAS k (Znth j h ([], [])) (Znth j h' ([], []))) /\

    (~In j (indices (hash k) i) -> j <> i -> Znth j h' ([], []) = Znth j h ([], [])).



Definition set_item_spec :=

 DECLARE _set_item

  WITH key : Z, value : Z, p : val, sh : share, entries : list (val * val), ghosts : list (val * val),

    h : list (hist * hist)

  PRE [ _key OF tint, _value OF tint ]

   PROP (repable_signed key; repable_signed value; readable_share sh; key <> 0; Zlength ghosts = size;

         Zlength h = size; wf_hists h)

   LOCAL (temp _key (vint key); temp _value (vint value); gvar _m_entries p)

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h)

  POST [ tvoid ]

   EX i : Z, EX h' : list (hist * hist),

   PROP (set_item_trace h key value i h')

   LOCAL ()

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h').



Definition failed_load k (a b : hist * hist) := exists r, repable_signed r /\

  add_events (fst a) [Load (vint r)] (fst b) /\ r <> 0 /\ r <> k /\ snd b = snd a /\

  (let v := value_of_hist (fst a) in v <> vint 0 -> v = vint r).



Definition get_item_trace (h : list (hist * hist)) k v i h' := Zlength h' = Zlength h /\

  0 <= i < Zlength h /\

  (let '(hk, hv) := Znth i h ([], []) in exists r, add_events hk [Load (vint r)] (fst (Znth i h' ([], []))) /\

     (v = 0 /\ r = 0 /\ snd (Znth i h' ([], [])) = hv \/

      r = k /\ add_events hv [Load (vint v)] (snd (Znth i h' ([], [])))) /\

    (let v := value_of_hist hk in v <> vint 0 -> v = vint r)) /\

  forall j, (In j (indices (hash k) i) -> failed_load k (Znth j h ([], [])) (Znth j h' ([], []))) /\

    (~In j (indices (hash k) i) -> j <> i -> Znth j h' ([], []) = Znth j h ([], [])).



Definition get_item_spec :=

 DECLARE _get_item

  WITH key : Z, p : val, sh : share, entries : list (val * val), ghosts : list (val * val),

    h : list (hist * hist)

  PRE [ _key OF tint, _value OF tint ]

   PROP (repable_signed key; readable_share sh; key <> 0; Zlength ghosts = size; Zlength h = size; wf_hists h)

   LOCAL (temp _key (vint key); gvar _m_entries p)

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h)

  POST [ tint ]

   EX value : Z, EX i : Z, EX h' : list (hist * hist),

   PROP (repable_signed value; get_item_trace h key value i h')

   LOCAL (temp ret_temp (vint value))

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h').



Definition add_item_trace (h : list (hist * hist)) k v i (success : bool) h' := Zlength h' = Zlength h /\

  0 <= i < Zlength h /\ (let '(hk, hv) := Znth i h ([], []) in if success then

    add_events hk [Load (vint 0); CAS (vint 0) (vint 0) (vint k)] (fst (Znth i h' ([], []))) /\

    add_events hv [Store (vint v)] (snd (Znth i h' ([], []))) /\ value_of_hist hk = vint 0

  else (add_events hk [Load (vint k)] (fst (Znth i h' ([], []))) \/

    add_events hk [Load (vint 0); CAS (vint k) (vint 0) (vint k); Load (vint k)] (fst (Znth i h' ([], [])))) /\

      snd (Znth i h' ([], [])) = hv /\ let v := value_of_hist hk in v <> vint 0 -> v = vint k) /\

  forall j, (In j (indices (hash k) i) -> failed_CAS k (Znth j h ([], [])) (Znth j h' ([], []))) /\

    (~In j (indices (hash k) i) -> j <> i -> Znth j h' ([], []) = Znth j h ([], [])).



Definition add_item_spec :=

 DECLARE _add_item

  WITH key : Z, value : Z, p : val, sh : share, entries : list (val * val), ghosts : list (val * val),

    h : list (hist * hist)

  PRE [ _key OF tint, _value OF tint ]

   PROP (repable_signed key; repable_signed value; readable_share sh; key <> 0; Zlength ghosts = size;

         Zlength h = size; wf_hists h)

   LOCAL (temp _key (vint key); temp _value (vint value); gvar _m_entries p)

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h)

  POST [ tint ]

   EX success : bool, EX i : Z, EX h' : list (hist * hist),

   PROP (add_item_trace h key value i success h')

   LOCAL (temp ret_temp (Val.of_bool success))

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h').



Notation empty_hists := (repeat ([] : hist, [] : hist) (Z.to_nat size)).



Definition init_table_spec :=

 DECLARE _init_table

  WITH p : val

  PRE [ ]

   PROP ()

   LOCAL (gvar _m_entries p)

   SEP (data_at_ Ews (tarray tentry size) p)

  POST [ tvoid ]

   EX entries : list (val * val), EX ghosts : list (val * val),

   PROP (Zlength ghosts = size)

   LOCAL ()

   SEP (data_at Ews (tarray tentry size) entries p; atomic_entries Tsh entries ghosts empty_hists).



Definition freeze_table_spec :=

 DECLARE _freeze_table

  WITH sh : share, p : val, entries : list (val * val), ghosts : list (val * val), h : list (hist * hist),

    keys : val, values : val

  PRE [ _keys OF tptr tint, _values OF tptr tint ]

   PROP (readable_share sh; Zlength ghosts = Zlength entries; Zlength h = Zlength entries)

   LOCAL (gvar _m_entries p; temp _keys keys; temp _values values)

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries Tsh entries ghosts h;

        data_at_ Tsh (tarray tint size) keys; data_at_ Tsh (tarray tint size) values)

  POST [ tvoid ]

   EX lk : list Z, EX lv : list Z,

   PROP (Forall repable_signed lk; Forall repable_signed lv;

         Forall2 full_hist (map fst h) lk; Forall2 full_hist (map snd h) lv;

         Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e) (map fst h) lk)

   LOCAL ()

   SEP (data_at_ sh (tarray tentry size) p;

        data_at Tsh (tarray tint size) (map (fun x => vint x) lk) keys;

        data_at Tsh (tarray tint size) (map (fun x => vint x) lv) values).



Inductive add_items_trace : list (hist * hist) -> list (Z * Z * Z * bool) -> list (hist * hist) -> Prop :=

| add_nil_items : forall h, add_items_trace h [] h

| add_snoc_items : forall h la h' k v i s h'' (Hn : add_items_trace h la h')

    (Hadd : add_item_trace h' k v i s h''), add_items_trace h (la ++ [(k, v, i, s)]) h''.



Definition f_lock_inv sh entries ghosts p t locksp lockt resultsp res :=

  (EX h : list (hist * hist), EX li : list Z, EX ls : list bool,

  !!(Zlength li = 3 /\ Zlength ls = 3 /\

     add_items_trace empty_hists (combine (combine (combine [1; 2; 3] [1; 1; 1]) li) ls) h) &&

   data_at sh (tarray tentry size) entries p * atomic_entries sh entries ghosts h *

   data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp *

   data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp *

   data_at Tsh tint (vint (Zlength (filter id ls))) res).



Definition f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res :=

  selflock (f_lock_inv sh entries ghosts p t locksp lockt resultsp res) tsh lockt.



Definition f_spec :=

 DECLARE _f

  WITH tid : val, x : share * share * list (val * val) * list (val * val) * val * Z * val * val * val * val

  PRE [ _arg OF (tptr tvoid) ]

   let '(sh, tsh, entries, ghosts, p, t, locksp, lockt, resultsp, res) := x in

   PROP (0 <= t < 3; isptr lockt; readable_share sh; readable_share tsh; Zlength ghosts = size)

   LOCAL (temp _arg tid; gvar _m_entries p; gvar _thread_locks locksp; gvar _results resultsp)

   SEP (data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts empty_hists;

        data_at Tsh tint (vint t) tid; malloc_token Tsh (sizeof tint) tid;

        data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

        data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

        data_at_ Tsh tint res;

        lock_inv tsh lockt (f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res))

  POST [ tptr tvoid ] PROP () LOCAL () SEP ().



Definition main_spec :=

 DECLARE _main

  WITH u : unit

  PRE  [] main_pre prog [] u

  POST [ tint ] main_post prog [] u.



Definition Gprog : funspecs := ltac:(with_library prog [verif_atomics.makelock_spec; freelock2_spec;

  verif_atomics.acquire_spec; release2_spec; spawn_spec; surely_malloc_spec;

  make_atomic_spec; free_atomic_spec; load_SC_spec; store_SC_spec; CAS_SC_spec;

  integer_hash_spec; set_item_spec; get_item_spec; add_item_spec; init_table_spec; freeze_table_spec;

  f_spec; main_spec]).



Lemma body_integer_hash: semax_body Vprog Gprog f_integer_hash integer_hash_spec.

Proof.

  start_function.

  forward.

Qed.



Opaque upto.



Ltac cancel_for_forward_call ::= repeat (rewrite ?sepcon_andp_prop', ?sepcon_andp_prop);

  repeat (apply andp_right; [auto; apply prop_right; auto|]); fast_cancel.



Ltac entailer_for_return ::= go_lower; entailer'.



Lemma indices_next : forall i j, ((j - i) mod size) < size - 1 -> indices i (j + 1) = indices i j ++ [j mod size].

Proof.

  intros; unfold indices.

  exploit (Z_mod_lt (j - i) size); [apply size_pos | intro].

  rewrite Z.add_sub_swap, <- Zplus_mod_idemp_l, Zmod_small by omega.

  rewrite Z2Nat.inj_add by omega.

  rewrite upto_app, map_app; simpl.

  change (upto 1) with [0]; simpl.

  rewrite Z2Nat.id, Z.add_0_r by (apply Z_mod_lt; computable).

  rewrite Zplus_mod_idemp_r, Zplus_minus; auto.

Qed.



Lemma update_entries_hist : forall sh entries ghosts h i hk hv pki pvi gki gvi

  (Hlen : Zlength entries = Zlength h) (Hleng : Zlength ghosts = Zlength entries)

  (Hpi : Znth i entries (Vundef, Vundef) = (pki, pvi)) (Hgi : Znth i ghosts (Vundef, Vundef) = (gki, gvi))

  (Hi : 0 <= i < Zlength entries),

  atomic_entries sh entries ghosts (upd_Znth i h (hk, hv)) =

  fold_right sepcon emp (upd_Znth i (map (fun x => let '((pk, pv), (gk, gv), (hk, hv)) := x in

    atomic_loc_hist sh pk gk 0 k_R hk * atomic_loc_hist sh pv gv 0 v_R hv) (combine (combine entries ghosts) h))

    (atomic_loc_hist sh pki gki 0 k_R hk * atomic_loc_hist sh pvi gvi 0 v_R hv)).

Proof.

  intros; unfold atomic_entries.

  f_equal.

  erewrite upd_Znth_map with (v := ((pki, pvi), (gki, gvi), (hk, hv))), combine_upd_Znth2

    by (rewrite Zlength_combine, Z.min_l; auto; omega).

  rewrite Znth_combine, Hpi, Hgi; eauto.

Qed.



Lemma incr_invariant : forall (P : _ -> _ -> Prop) i1 i key (h h' : list (hist * hist)) h1

  (Hi1 : i1 = (i + hash key) mod size) (Hh' : Zlength h' = size) (Hinv : forall j,

  (In j (indices (hash key) (i + hash key)) -> P (Znth j h ([], [])) (Znth j h' ([], []))) /\

  (~In j (indices (hash key) (i + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

  (HP : P (Znth i1 h ([], [])) h1) (Hi : i mod size < size - 1) j,

  (In j (indices (hash key) ((i + 1) + hash key)) -> P (Znth j h ([], [])) (Znth j (upd_Znth i1 h' h1) ([], []))) /\

  (~In j (indices (hash key) ((i + 1) + hash key)) -> Znth j (upd_Znth i1 h' h1) ([], []) = Znth j h ([], [])).

Proof.

  intros; specialize (Hinv j); destruct Hinv.

  rewrite <- Z.add_assoc, (Z.add_comm 1), Z.add_assoc, indices_next, in_app.

  assert (0 <= i1 < Zlength h') by (subst; rewrite Hh'; apply Z_mod_lt, size_pos).

  assert (~ In i1 (indices (hash key) (i + hash key))) as Hnew.

  { unfold indices; rewrite in_map_iff; intros (? & Heq & Hin).

    rewrite Z.add_simpl_r, In_upto, Z2Nat.id in Hin by (apply Z_mod_lt, size_pos).

    subst; rewrite Z.add_comm in Heq; apply Zmod_plus_inv in Heq; [|apply size_pos].

    rewrite Zmod_small in Heq; [omega|].

    destruct Hin; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos. }

  split.

  * intros [Hin | Hin].

    { rewrite upd_Znth_diff'; auto.

      intro; contradiction Hnew; subst; auto. }

    simpl in Hin; destruct Hin; [subst | contradiction].

    simpl in *; rewrite upd_Znth_same; auto.

  * intro Hout; rewrite upd_Znth_diff'; auto.

    intro; contradiction Hout; subst; simpl; auto.

  * rewrite Z.add_simpl_r; auto.

Qed.



Lemma k_R_precise : forall v, precise (EX h : _, k_R h v).

Proof.

  intros; apply derives_precise' with (Q := emp); auto.

  unfold k_R; entailer!.

Qed.



Lemma v_R_precise : forall v, precise (EX h : _, v_R h v).

Proof.

  intros; apply derives_precise' with (Q := emp); auto.

  unfold v_R; entailer!.

Qed.

Hint Resolve k_R_precise v_R_precise.



Lemma body_set_item : semax_body Vprog Gprog f_set_item set_item_spec.

Proof.

  start_function.

  assert (sh <> Share.bot) by (intro; subst; contradiction unreadable_bot).

  forward_call key.

  eapply semax_pre with (P' := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

    PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

          forall j, (In j (indices (hash key) (i + hash key)) ->

            failed_CAS key (Znth j h ([], [])) (Znth j h' ([], []))) /\

            (~In j (indices (hash key) (i + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

    LOCAL (temp _idx (vint i1); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

  { Exists 0 (key * 654435761)%Z h; entailer!.

    rewrite Zmod_mod; split; auto.

    unfold indices; rewrite Zminus_diag; split; auto; contradiction. }

  eapply semax_loop.

  - Intros i i1 h'; forward.

    forward.

    rewrite sub_repr, and_repr; simpl.

    rewrite Zland_two_p with (n := 14) by omega.

    change (2 ^ 14) with size.

    exploit (Z_mod_lt i1 size); [omega | intro Hi1].

    assert (0 <= i1 mod size < Zlength h') by omega.

    assert_PROP (Zlength entries = size) as Hentries by entailer!.

    assert (0 <= i1 mod size < Zlength entries) by omega.

    assert (i <= Zlength h') by omega.

    unfold atomic_entries; rewrite extract_nth_sepcon with (i := i1 mod size),

      Znth_map with (d' := (Vundef, Vundef, (Vundef, Vundef), ([], []))), !Znth_combine

      by (rewrite ?Zlength_map, ?Zlength_combine; rewrite ?Zlength_combine, ?Z.min_l; rewrite ?Z.min_l; auto;

          omega).

    destruct (Znth (i1 mod size) entries (Vundef, Vundef)) as (pki, pvi) eqn: Hpi.

    destruct (Znth (i1 mod size) ghosts (Vundef, Vundef)) as (gki, gvi) eqn: Hgi.

    destruct (Znth (i1 mod size) h' ([], [])) as (hki, hvi) eqn: Hhi.

    unfold atomic_entry, atomic_loc_hist; Intros.

    rewrite atomic_loc_isptr; Intros.

    forward.

    { entailer!.

      setoid_rewrite Hpi; auto. }

    assert (~ In (i1 mod size) (indices (hash key) (i + hash key))) as Hnew.

    { unfold indices; rewrite in_map_iff; intros (? & Heq & Hin).

      rewrite Z.add_simpl_r, In_upto, Z2Nat.id in Hin by (apply Z_mod_lt, size_pos).

      replace (i1 mod size) with ((i + hash key) mod size) in Heq.

      rewrite Z.add_comm in Heq; apply Zmod_plus_inv in Heq; [|apply size_pos].

      rewrite Zmod_small in Heq; [omega|].

      destruct Hin; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos. }

    assert (Znth (i1 mod size) h ([], []) = Znth (i1 mod size) h' ([], [])) as Heq.

    { match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => symmetry; apply H; auto end. }

    assert (ordered_hist hki).

    { match goal with H : wf_hists h |- _ => eapply Forall_Znth with (i0 := i1 mod size) in H; [|omega];

      rewrite Heq, Hhi in H; tauto end. }

    forward_call (AL_witness sh pki gki 0 k_R hki emp

      (fun v => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0) && emp)).

    { entailer!.

      setoid_rewrite Hpi; auto. }

    { repeat (split; auto).

      apply AL_hist_spec; auto.

      intros ???????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        specialize (Hhist _ _ Hin); apply nth_error_In in Hhist; subst; auto. }

    Intros v.

    simpl; Intros hki1.

    match goal with |- semax _ (PROP () (LOCALx (_ :: ?Q) (SEPx (_ :: _ :: ?R)))) _ _ =>

      forward_if (EX hki' : hist, PROP (found_key key hki hki') (LOCALx Q

        (SEPx (atomic_loc_hist sh pki gki 0 k_R hki' :: R)))) end.

    + match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

        forward_if (PROP (v = 0) (LOCALx Q (SEPx R))) end.

      { eapply semax_pre; [|apply semax_continue].

        unfold POSTCONDITION, abbreviate, overridePost.

        destruct (eq_dec EK_continue EK_normal); [discriminate|].

        unfold loop1_ret_assert.

        instantiate (1 := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

          PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

          forall j, (In j (indices (hash key) ((i + 1) + hash key)) ->

            failed_CAS key (Znth j h ([], [])) (Znth j h' ([], []))) /\

            (~In j (indices (hash key) ((i + 1) + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

          LOCAL (temp _idx (vint i1); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

          SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

        Exists i (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi)); entailer!.

        { split.

          { rewrite upd_Znth_Zlength; auto; omega. }

          rewrite Zmod_mod.

          split; auto.

          apply incr_invariant; auto; simpl in *; try omega.

          * rewrite Heq, Hhi; repeat (eexists; eauto); auto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          * admit.  }

        fast_cancel.

        erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

        rewrite sepcon_assoc; auto. }

      { forward.

        entailer!. }

      Intros; subst.

      forward_call (ACAS_witness sh pki gki 0 k_R hki1 0 key emp

        (fun v => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0) && emp)).

      { entailer!.

        setoid_rewrite Hpi; auto. }

      { repeat (split; auto).

        apply ACAS_hist_spec; auto.

        intros ???????????? Ha.

        unfold k_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!.

        repeat split.

        + rewrite Forall_app; repeat constructor; auto.

        + intros ? Hin; rewrite in_app in Hin.

          destruct Hin as [? | [? | ?]]; [| |contradiction].

          * intros.

            if_tac; auto; absurd (value_of e = vint 0); auto.

            subst; symmetry; auto.

          * subst; simpl; intros.

            if_tac; if_tac; auto; [subst; absurd (vint 0 = vint 0); auto|].

            absurd (v' = 0); auto; apply repr_inj_signed; auto; congruence.

        + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

          exploit Hhist.

          { eapply add_events_incl; eauto. }

          intro X; apply nth_error_In in X; subst; auto. }

      Intros v hki2.

      exploit (add_events_trans hki); eauto; intro.

      match goal with |- semax _ (PROP () (LOCALx (_ :: _ :: ?Q) (SEPx (_ :: _ :: ?R)))) _ _ =>

        forward_if (EX hki' : hist, PROP (found_key key hki hki') ((LOCALx Q)

        (SEPx (atomic_loc_hist sh pki gki 0 k_R hki' :: R)))) end.

      * destruct (eq_dec 0 v); [discriminate|].

        forward_call (AL_witness sh pki gki 0 k_R hki2 emp (fun v' => !!(v' = v) && emp)).

        { entailer!.

          simpl in *; rewrite Hpi; auto. }

        { split; auto.

          apply AL_hist_spec; auto.

          intros ???????????? Ha.

          unfold k_R in *; simpl in *.

          eapply semax_pre, Ha.

          go_lowerx; entailer!.

          repeat split.

          + rewrite Forall_app; repeat constructor; auto.

          + intros ? Hin; rewrite in_app in Hin.

            destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

          + exploit add_events_in; eauto; simpl; eauto; intros (? & ? & ?).

            match goal with H : forall e, In e h'0 -> _ |- _ =>

              exploit (H (CAS (vint v) (vint 0) (vint key))) end.

            { eapply nth_error_In, Hhist; eauto. }

            { simpl.

              if_tac; [absurd (v = 0)|]; auto.

              apply repr_inj_signed; auto; congruence. }

            simpl.

            if_tac; [absurd (v = 0)|]; auto; intros; apply repr_inj_signed; auto; congruence. }

        Intros v'; simpl; Intros hki3; subst.

        exploit (add_events_trans hki); eauto; intro.

        match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

          forward_if (PROP (v = key) (LOCALx Q (SEPx R))) end.

        { eapply semax_pre; [|apply semax_continue].

          unfold POSTCONDITION, abbreviate, overridePost.

          destruct (eq_dec EK_continue EK_normal); [discriminate|].

          unfold loop1_ret_assert.

          go_lower.

          Exists i (i1 mod size) (upd_Znth (i1 mod size) h' (hki3, hvi)); entailer!.

          { split.

            { rewrite upd_Znth_Zlength; auto; omega. }

            rewrite Zmod_mod.

            split; auto.

            apply incr_invariant; auto; simpl in *; try omega.

            * rewrite Heq, Hhi; do 2 eexists; eauto.

              repeat split; auto.

              match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0 |- _ =>

                symmetry; apply H; auto end.

              rewrite ordered_last_value; auto.

            * admit.  }

          fast_cancel.

          erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

          rewrite sepcon_assoc; auto. }

        { forward.

          entailer!. }

        intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

        rewrite eq_dec_refl.

        go_lower.

        apply andp_right; [apply prop_right; auto|].

        Exists hki3; entailer!.

        split; auto.

        match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

          symmetry; apply H; auto end.

        apply ordered_last_value; auto.

      * forward.

        destruct (eq_dec 0 v); [|discriminate].

        subst; Exists hki2; entailer!.

        split; auto.

        intros ? X; contradiction X.

        match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint 0 = v0 |- _ =>

          symmetry; apply H; auto end.

        apply ordered_last_value; auto.

      * intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

        rewrite eq_dec_refl.

        Intros hki'.

        go_lower.

        apply andp_right; [apply prop_right; auto|].

        Exists hki'; entailer!.

    + forward.

      subst; Exists hki1; entailer!.

      split; auto.

      match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

        symmetry; apply H; auto end.

      apply ordered_last_value; auto.

    + rewrite (atomic_loc_isptr _ pvi).

      Intros hki'.

      forward.

      { entailer!.

        simpl in *; rewrite Hpi; auto. }

      forward_call (AS_witness sh pvi gvi 0 v_R hvi value emp emp).

      { entailer!.

        simpl in *; rewrite Hpi; auto. }

      { repeat (split; auto).

        apply AS_hist_spec; auto.

        intros ???????????? Ha.

        unfold v_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!. }

      Intros hvi1.

      forward.

      Exists (i1 mod size) (upd_Znth (i1 mod size) h' (hki', hvi1)); entailer!.

      { split.

        { rewrite upd_Znth_Zlength; auto. }

        split; [replace (Zlength h) with (Zlength h'); auto|].

        setoid_rewrite Heq.

        rewrite Hhi; simpl.

        rewrite upd_Znth_same by auto; simpl; split; auto.

        split; eauto.

        assert (indices (hash key) (i + hash key) = indices (hash key) (i1 mod size)) as Hindex.

        { unfold indices.

          replace (i1 mod size) with ((i + hash key) mod size).

          rewrite Zminus_mod_idemp_l; auto. }

        simpl in Hindex; split.

        + intro Hin; simpl in *.

          rewrite upd_Znth_diff'; auto.

          match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

          rewrite Hindex; auto.

          { intro; contradiction Hnew; subst.

            rewrite Hindex; auto. }

        + intros Hout ?; rewrite upd_Znth_diff'; auto.

          match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

          { intro; contradiction Hout; subst; simpl.

            rewrite <- Hindex; auto. } }

      fast_cancel.

      erewrite <- !sepcon_assoc, (sepcon_comm _ (atomic_loc_hist _ _ _ _ _ _)), replace_nth_sepcon,

        update_entries_hist; eauto; auto; omega.

  - Intros i i1 h'.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) (i1 + 1) h'; entailer!.

    split.

    { rewrite <- Zplus_mod_idemp_l.

      replace (i1 mod _) with ((i + hash key) mod size); simpl.

      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }

    admit. 

Admitted.



Lemma body_get_item : semax_body Vprog Gprog f_get_item get_item_spec.

Proof.

  start_function.

  assert (sh <> Share.bot) by (intro; subst; contradiction unreadable_bot).

  forward_call key.

  eapply semax_pre with (P' := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

    PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

          forall j, (In j (indices (hash key) (i + hash key)) ->

            failed_load key (Znth j h ([], [])) (Znth j h' ([], []))) /\

            (~In j (indices (hash key) (i + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

    LOCAL (temp _idx (vint i1); temp _key (vint key); gvar _m_entries p)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

  { Exists 0 (key * 654435761)%Z h; entailer!.

    rewrite Zmod_mod; split; auto.

    unfold indices; rewrite Zminus_diag; split; auto; contradiction. }

  eapply semax_loop.

  - Intros i i1 h'; forward.

    forward.

    rewrite sub_repr, and_repr; simpl.

    rewrite Zland_two_p with (n := 14) by omega.

    change (2 ^ 14) with size.

    exploit (Z_mod_lt i1 size); [omega | intro Hi1].

    assert (0 <= i1 mod size < Zlength h') by omega.

    assert_PROP (Zlength entries = size) as Hentries by entailer!.

    assert (0 <= i1 mod size < Zlength entries) by omega.

    assert (i <= Zlength h') by omega.

    unfold atomic_entries; rewrite extract_nth_sepcon with (i := i1 mod size),

      Znth_map with (d' := (Vundef, Vundef, (Vundef, Vundef), ([], []))), !Znth_combine

      by (rewrite ?Zlength_map, ?Zlength_combine; rewrite ?Zlength_combine, ?Z.min_l; rewrite ?Z.min_l; auto;

          omega).

    destruct (Znth (i1 mod size) entries (Vundef, Vundef)) as (pki, pvi) eqn: Hpi.

    destruct (Znth (i1 mod size) ghosts (Vundef, Vundef)) as (gki, gvi) eqn: Hgi.

    destruct (Znth (i1 mod size) h' ([], [])) as (hki, hvi) eqn: Hhi.

    unfold atomic_entry, atomic_loc_hist; Intros.

    rewrite atomic_loc_isptr; Intros.

    forward.

    { entailer!.

      setoid_rewrite Hpi; auto. }

    assert (~ In (i1 mod size) (indices (hash key) (i + hash key))) as Hnew.

    { unfold indices; rewrite in_map_iff; intros (? & Heq & Hin).

      rewrite Z.add_simpl_r, In_upto, Z2Nat.id in Hin by (apply Z_mod_lt, size_pos).

      replace (i1 mod size) with ((i + hash key) mod size) in Heq.

      rewrite Z.add_comm in Heq; apply Zmod_plus_inv in Heq; [|apply size_pos].

      rewrite Zmod_small in Heq; [omega|].

      destruct Hin; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos. }

    assert (Znth (i1 mod size) h ([], []) = Znth (i1 mod size) h' ([], [])) as Heq.

    { match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => symmetry; apply H; auto end. }

    assert (ordered_hist hki).

    { match goal with H : wf_hists h |- _ => eapply Forall_Znth with (i0 := i1 mod size) in H; [|omega];

      rewrite Heq, Hhi in H; tauto end. }

    forward_call (AL_witness sh pki gki 0 k_R hki emp

      (fun v => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0) && emp)).

    { entailer!.

      setoid_rewrite Hpi; auto. }

    { repeat (split; auto).

      apply AL_hist_spec; auto.

      intros ???????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        specialize (Hhist _ _ Hin); apply nth_error_In in Hhist; subst; auto. }

    Intros v; simpl; Intros hki1.

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (v <> key) (LOCALx Q (SEPx R))) end.

    + rewrite (atomic_loc_isptr _ pvi).

      forward.

      { entailer!.

        simpl in *; rewrite Hpi; auto. }

      forward_call (AL_witness sh pvi gvi 0 v_R hvi emp (fun (v : Z) => emp)).

      { entailer!.

        simpl in Hpi; rewrite Hpi; auto. }

      { repeat (split; auto).

        apply AL_hist_spec; auto.

        intros ???????????? Ha.

        unfold v_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!. }

      subst; Intros v; simpl; Intros hvi1.

      forward.

      Exists v (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi1)); entailer!.

      { split.

        { rewrite upd_Znth_Zlength; auto. }

        split; [replace (Zlength h) with (Zlength h'); auto|].

        setoid_rewrite Heq.

        rewrite Hhi; simpl.

        rewrite upd_Znth_same by auto; simpl; split.

        - do 2 eexists; eauto; split; eauto.

          match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

            symmetry; apply H; auto end.

          rewrite ordered_last_value; auto.

        - assert (indices (hash key) (i + hash key) = indices (hash key) (i1 mod size)) as Hindex.

          { unfold indices.

            replace (i1 mod size) with ((i + hash key) mod size).

            rewrite Zminus_mod_idemp_l; auto. }

          simpl in Hindex; split.

          + intro Hin; simpl in *.

            rewrite upd_Znth_diff'; auto.

            match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

            rewrite Hindex; auto.

            { intro; contradiction Hnew; subst.

              rewrite Hindex; auto. }

          + intros Hout ?; rewrite upd_Znth_diff'; auto.

            match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

            { intro; contradiction Hout; subst; simpl.

              rewrite <- Hindex; auto. } }

      fast_cancel.

      erewrite <- !sepcon_assoc, (sepcon_assoc _ (atomic_loc _ _ _)), replace_nth_sepcon,

        update_entries_hist; eauto; try omega.

      rewrite (sepcon_comm (atomic_loc_hist _ _ _ _ _ _)); auto.

    + forward.

      entailer!.

    + Intros; match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

        forward_if (PROP (v <> 0) (LOCALx Q (SEPx R))) end.

      * forward.

        Exists 0 (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi)); entailer!.

        { split.

          { rewrite upd_Znth_Zlength; auto. }

          split; [replace (Zlength h) with (Zlength h'); auto|].

          setoid_rewrite Heq.

          rewrite Hhi; simpl.

          rewrite upd_Znth_same by auto; simpl; split.

          - do 2 eexists; eauto; split; auto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint 0 = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          - assert (indices (hash key) (i + hash key) = indices (hash key) (i1 mod size)) as Hindex.

            { unfold indices.

              replace (i1 mod size) with ((i + hash key) mod size).

              rewrite Zminus_mod_idemp_l; auto. }

            simpl in Hindex; split.

            + intro Hin; simpl in *.

              rewrite upd_Znth_diff'; auto.

              match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

              rewrite Hindex; auto.

              { intro; contradiction Hnew; subst.

                rewrite Hindex; auto. }

            + intros Hout ?; rewrite upd_Znth_diff'; auto.

              match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

              { intro; contradiction Hout; subst; simpl.

                rewrite <- Hindex; auto. } }

        fast_cancel.

        erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

        rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto.

      * forward.

        entailer!.

      * intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert.

        instantiate (1 := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

          PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

          forall j, (In j (indices (hash key) ((i + 1) + hash key)) ->

            failed_load key (Znth j h ([], [])) (Znth j h' ([], []))) /\

            (~In j (indices (hash key) ((i + 1) + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

          LOCAL (temp _idx (vint i1); temp _key (vint key); gvar _m_entries p)

          SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

        Exists i (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi)); entailer!.

        { split.

          { rewrite upd_Znth_Zlength; auto; omega. }

          rewrite Zmod_mod.

          split; auto.

          apply incr_invariant; auto; simpl in *; try omega.

          * rewrite Heq, Hhi; repeat (eexists; eauto); auto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          * admit.  }

        fast_cancel.

        erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

        rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto.

  - Intros i i1 h'.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) (i1 + 1) h'; entailer!.

    split.

    { rewrite <- Zplus_mod_idemp_l.

      replace (i1 mod _) with ((i + hash key) mod size).

      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }

    admit. 

Admitted.



Lemma body_add_item : semax_body Vprog Gprog f_add_item add_item_spec.

Proof.

  start_function.

  assert (sh <> Share.bot) by (intro; subst; contradiction unreadable_bot).

  forward_call key.

  eapply semax_pre with (P' := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

    PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

          forall j, (In j (indices (hash key) (i + hash key)) -> failed_CAS key (Znth j h ([], [])) (Znth j h' ([], []))) /\

            (~In j (indices (hash key) (i + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

    LOCAL (temp _idx (vint i1); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

  { Exists 0 (key * 654435761)%Z h; entailer!.

    rewrite Zmod_mod; split; auto.

    unfold indices; rewrite Zminus_diag; split; auto; contradiction. }

  eapply semax_loop.

  - Intros i i1 h'; forward.

    forward.

    rewrite sub_repr, and_repr; simpl.

    rewrite Zland_two_p with (n := 14) by omega.

    change (2 ^ 14) with size.

    exploit (Z_mod_lt i1 size); [omega | intro Hi1].

    assert (0 <= i1 mod size < Zlength h') by omega.

    assert (0 <= i1 mod size < Zlength h) by omega.

    assert_PROP (Zlength entries = size) as Hentries by entailer!.

    assert (0 <= i1 mod size < Zlength entries) by omega.

    assert (i <= Zlength h') by omega.

    unfold atomic_entries; rewrite extract_nth_sepcon with (i := i1 mod size),

      Znth_map with (d' := (Vundef, Vundef, (Vundef, Vundef), ([], []))), !Znth_combine

      by (rewrite ?Zlength_map, ?Zlength_combine; rewrite ?Zlength_combine, ?Z.min_l; rewrite ?Z.min_l; auto;

          omega).

    destruct (Znth (i1 mod size) entries (Vundef, Vundef)) as (pki, pvi) eqn: Hpi.

    destruct (Znth (i1 mod size) ghosts (Vundef, Vundef)) as (gki, gvi) eqn: Hgi.

    destruct (Znth (i1 mod size) h' ([], [])) as (hki, hvi) eqn: Hhi.

    unfold atomic_entry, atomic_loc_hist; Intros.

    rewrite atomic_loc_isptr; Intros.

    forward.

    { entailer!.

      setoid_rewrite Hpi; auto. }

    assert (~ In (i1 mod size) (indices (hash key) (i + hash key))) as Hnew.

    { unfold indices; rewrite in_map_iff; intros (? & Heq & Hin).

      rewrite Z.add_simpl_r, In_upto, Z2Nat.id in Hin by (apply Z_mod_lt, size_pos).

      replace (i1 mod size) with ((i + hash key) mod size) in Heq.

      rewrite Z.add_comm in Heq; apply Zmod_plus_inv in Heq; [|apply size_pos].

      rewrite Zmod_small in Heq; [omega|].

      destruct Hin; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos. }

    assert (Znth (i1 mod size) h ([], []) = Znth (i1 mod size) h' ([], [])) as Heq.

    { match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => symmetry; apply H; auto end. }

    assert (ordered_hist hki).

    { match goal with H : wf_hists h |- _ => eapply Forall_Znth with (i0 := i1 mod size) in H; [|omega];

      rewrite Heq, Hhi in H; tauto end. }

    forward_call (AL_witness sh pki gki 0 k_R hki emp

      (fun v => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0) && emp)).

    { entailer!.

      setoid_rewrite Hpi; auto. }

    { repeat (split; auto).

      apply AL_hist_spec; auto.

      intros ???????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        specialize (Hhist _ _ Hin); apply nth_error_In in Hhist; subst; auto. }

    Intros v; simpl; Intros hki1.

    assert (indices (hash key) (i + hash key) = indices (hash key) (i1 mod size)) as Hindex.

    { unfold indices.

      replace (i1 mod size) with ((i + hash key) mod size).

      rewrite Zminus_mod_idemp_l; auto. }

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (v <> key) (LOCALx Q (SEPx R))) end.

    { forward.

      Exists false (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi)); entailer!.

      + split.

        { rewrite upd_Znth_Zlength; auto. }

        split; [auto|].

        setoid_rewrite Heq; rewrite Hhi; simpl.

        rewrite upd_Znth_same by auto; simpl.

        split; [repeat split; eauto|].

        { match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

            symmetry; apply H; auto end.

          rewrite ordered_last_value; auto. }

        simpl in Hindex; split.

        * intro Hin; simpl in *.

          rewrite upd_Znth_diff'; auto.

          match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

          simpl in *; rewrite Hindex; auto.

          { intro; contradiction Hnew; subst.

            simpl in *; rewrite Hindex; auto. }

        * intros Hout ?; rewrite upd_Znth_diff'; auto.

          match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

          { intro; contradiction Hout; subst; simpl.

            rewrite <- Hindex; auto. }

      + erewrite replace_nth_sepcon, update_entries_hist; eauto; try omega.

        rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto. }

    { forward.

      entailer!. }

    Intros.

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (v = 0) (LOCALx Q (SEPx R))) end.

    { eapply semax_pre; [|apply semax_continue].

      unfold POSTCONDITION, abbreviate, overridePost.

      destruct (eq_dec EK_continue EK_normal); [discriminate|].

      unfold loop1_ret_assert.

      instantiate (1 := EX i : Z, EX i1 : Z, EX h' : list (hist * hist),

        PROP (Zlength h' = Zlength h; i1 mod size = (i + hash key) mod size; 0 <= i < size;

        forall j, (In j (indices (hash key) ((i + 1) + hash key)) ->

          failed_CAS key (Znth j h ([], [])) (Znth j h' ([], []))) /\

          (~In j (indices (hash key) ((i + 1) + hash key)) -> Znth j h' ([], []) = Znth j h ([], [])))

        LOCAL (temp _idx (vint i1); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

        SEP (@data_at CompSpecs sh (tarray tentry size) entries p; atomic_entries sh entries ghosts h')).

      Exists i (i1 mod size) (upd_Znth (i1 mod size) h' (hki1, hvi)); entailer!.

      { split.

        { rewrite upd_Znth_Zlength; auto; omega. }

        rewrite Zmod_mod.

        split; auto.

        apply incr_invariant; auto; simpl in *; try omega.

        * rewrite Heq, Hhi; repeat (eexists; eauto); auto.

          match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0 |- _ =>

            symmetry; apply H; auto end.

          rewrite ordered_last_value; auto.

        * admit.  }

      fast_cancel.

      erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

      rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto. }

    { forward.

      entailer!. }

    Intros; subst.

    forward_call (ACAS_witness sh pki gki 0 k_R hki1 0 key emp

      (fun v => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0) && emp)).

    { entailer!.

      setoid_rewrite Hpi; auto. }

    { repeat (split; auto).

      apply ACAS_hist_spec; auto.

      intros ???????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; [| |contradiction].

        * intros.

          assert (vint v' = value_of e) by auto.

          if_tac; auto.

          subst; absurd (value_of e = vint 0); auto.

        * subst; simpl; intros.

          if_tac; if_tac; auto; [absurd (vint v' = vint 0); subst; auto|].

          absurd (v' = 0); auto; apply repr_inj_signed; auto; congruence.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        exploit Hhist.

        { eapply add_events_incl; eauto. }

        intro X; apply nth_error_In in X; subst; auto. }

    Intros v; simpl; Intros hki2.

    exploit (add_events_trans hki); eauto; intro.

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (v = 0) ((LOCALx Q) (SEPx R))) end.

    { destruct (eq_dec 0 v); [discriminate|].

      forward_call (AL_witness sh pki gki 0 k_R hki2 emp (fun v' => !!(v' = v) && emp)).

      { entailer!.

        simpl in Hpi; rewrite Hpi; auto. }

      { split; auto.

        apply AL_hist_spec; auto.

        intros ???????????? Ha.

        unfold k_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!.

        repeat split.

        + rewrite Forall_app; repeat constructor; auto.

        + intros ? Hin; rewrite in_app in Hin.

          destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

        + exploit add_events_in; eauto; simpl; eauto; intros (? & ? & ?).

          match goal with H : forall e, In e _ -> _ |- _ =>

            exploit (H (CAS (vint v) (vint 0) (vint key))) end.

          { eapply nth_error_In, Hhist; eauto. }

          { simpl.

            if_tac; [absurd (v = 0)|]; auto; apply repr_inj_signed; auto; congruence. }

          simpl.

          if_tac; [absurd (v = 0)|]; auto; intros; apply repr_inj_signed; auto; congruence. }

      Intros v'; simpl; Intros hki3; subst.

      exploit (add_events_trans hki); eauto; intro.

      match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

        forward_if (fun _ : environ => FF) end.

      - forward.

        Exists false (i1 mod size) (upd_Znth (i1 mod size) h' (hki3, hvi)); entailer!.

        + split.

          { rewrite upd_Znth_Zlength; auto. }

          split; [auto|].

          setoid_rewrite Heq; rewrite Hhi; simpl.

          rewrite upd_Znth_same by auto; simpl.

          split; [split; auto; split; auto|].

          { match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto. }

          simpl in Hindex; split.

          * intro Hin; simpl in *.

            rewrite upd_Znth_diff'; auto.

            match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

            rewrite Hindex; auto.

            { intro; contradiction Hnew; subst.

              rewrite Hindex; auto. }

          * intros Hout ?; rewrite upd_Znth_diff'; auto.

            match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

            { intro; contradiction Hout; subst; simpl.

              rewrite <- Hindex; auto. }

        + erewrite replace_nth_sepcon, update_entries_hist; eauto; try omega.

          rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto.

      - eapply semax_pre; [|apply semax_continue].

        unfold POSTCONDITION, abbreviate, overridePost.

        destruct (eq_dec EK_continue EK_normal); [discriminate|].

        unfold loop1_ret_assert.

        go_lower.

        Exists i (i1 mod size) (upd_Znth (i1 mod size) h' (hki3, hvi)); entailer!.

        { split.

          { rewrite upd_Znth_Zlength; auto; omega. }

          rewrite Zmod_mod.

          split; auto.

          apply incr_invariant; auto; simpl in *; try omega.

          * rewrite Heq, Hhi; do 2 eexists; eauto; repeat split; auto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint v = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          * admit.  }

        fast_cancel.

        erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

        rewrite (sepcon_assoc _ (atomic_loc _ _ _)); auto.

      - intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; go_lowerx; contradiction. }

    { forward.

      destruct (eq_dec 0 v); [|discriminate].

      entailer!. }

    rewrite (atomic_loc_isptr _ pvi).

    Intros; subst; simpl in Hpi.

    forward.

    { entailer!.

      rewrite Hpi; auto. }

    forward_call (AS_witness sh pvi gvi 0 v_R hvi value emp emp).

    { entailer!.

      rewrite Hpi; auto. }

    { repeat (split; auto).

      apply AS_hist_spec; auto.

      intros ???????????? Ha.

      unfold v_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!. }

    Intros hvi1.

    forward.

    Exists true (i1 mod size) (upd_Znth (i1 mod size) h' (hki2, hvi1)); entailer!.

    { split.

      { rewrite upd_Znth_Zlength; auto. }

      split; [auto|].

      setoid_rewrite Heq.

      rewrite Hhi; simpl.

      rewrite upd_Znth_same by auto; simpl; split; [repeat eexists; auto|].

      { destruct (eq_dec (value_of_hist hki) (vint 0)); auto.

        match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint 0 = v0 |- _ =>

          symmetry; apply H; auto end.

        rewrite ordered_last_value; auto. }

      split.

      + intro Hin.

        rewrite upd_Znth_diff'; auto.

        match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

        rewrite Hindex; auto.

        { intro; contradiction Hnew; subst.

          rewrite Hindex; auto. }

      + intros Hout ?; simpl in *; rewrite upd_Znth_diff'; auto.

        match goal with H : forall j, (In j _ -> _) /\ (~In j _ -> _) |- _ => apply H; auto end.

        { intro; contradiction Hout; subst; simpl.

          rewrite <- Hindex; auto. } }

    fast_cancel.

    erewrite <- !sepcon_assoc, replace_nth_sepcon, update_entries_hist; eauto; try omega.

    rewrite (sepcon_assoc _ (atomic_loc _ _ _)), sepcon_comm; auto.

  - Intros i i1 h'.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) (i1 + 1) h'; entailer!.

    split.

    { rewrite <- Zplus_mod_idemp_l.

      replace (i1 mod _) with ((i + hash key) mod size); simpl.

      rewrite Zplus_mod_idemp_l, <- Z.add_assoc, (Z.add_comm _ 1), Z.add_assoc; auto. }

    admit. 

Admitted.



Opaque size.

Opaque Znth.



Lemma Zlength_empty : Zlength empty_hists = size.

Proof.

  rewrite Zlength_repeat, Z2Nat.id; auto.

  pose proof size_pos; omega.

Qed.



Lemma body_init_table : semax_body Vprog Gprog f_init_table init_table_spec.

Proof.

  start_function.

  forward_for_simple_bound size (EX i : Z, PROP () LOCAL (gvar _m_entries p)

    SEP (EX entries : list (val * val), EX ghosts : list (val * val),

      !!(Zlength entries = i /\ Zlength ghosts = i) && @data_at CompSpecs Ews (tarray tentry size)

          (entries ++ repeat (Vundef, Vundef) (Z.to_nat (size - i))) p *

        atomic_entries Tsh entries ghosts (repeat ([], []) (Z.to_nat i)))).

  { change size with 16384; computable. }

  { change size with 16384; computable. }

  - Exists (@nil (val * val)) (@nil (val * val)); entailer!.

    rewrite data_at__eq; unfold default_val; simpl.

    rewrite repeat_list_repeat, Z.sub_0_r; auto.

  - Intros entries ghosts.

    eapply ghost_alloc with (g := init_hist); auto with init.

    Intro gk.

    forward_call (MA_witness gk 0 k_R).

    { unfold k_R; entailer!. }

    { split; [|split; computable].

      apply MA_hist_spec; auto. }

    Intro k.

    forward.

    eapply ghost_alloc with (g := init_hist); auto with init.

    Intro gv.

    forward_call (MA_witness gv 0 v_R).

    { unfold v_R; entailer!. }

    { split; [|split; computable].

      apply MA_hist_spec; auto. }

    Intro v.

    forward.

    assert (0 <= Zlength entries < Zlength (entries ++

      repeat (Vundef, Vundef) (Z.to_nat (size - Zlength entries)))).

    { rewrite Zlength_app, Zlength_repeat, Z2Nat.id; omega. }

    subst; rewrite upd_Znth_twice, upd_complete_gen by (auto; omega).

    Exists (entries ++ [(k, v)]) (ghosts ++ [(gk, gv)]); entailer!.

    + rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; omega.

    + rewrite upd_Znth_same by auto.

      rewrite Zlength_app, Zlength_cons, Zlength_nil; entailer!.

      unfold atomic_entries.

      rewrite Z2Nat.inj_add, repeat_plus by omega; simpl.

      rewrite !combine_app, map_app, sepcon_app; simpl.

      unfold atomic_entry, atomic_loc_hist; entailer!.

      { rewrite combine_length, repeat_length, Zlength_correct, Nat2Z.id, Nat.min_l; auto.

        apply Nat2Z.inj_le; rewrite <- !Zlength_correct; omega. }

      { apply Nat2Z.inj; rewrite <- !Zlength_correct; omega. }

  - Intros entries ghosts.

    rewrite Zminus_diag, app_nil_r.

    forward.

    Exists entries ghosts; entailer!.

Qed.



Lemma body_freeze_table : semax_body Vprog Gprog f_freeze_table freeze_table_spec.

Proof.

  start_function.

  assert_PROP (Zlength entries = size) as Hlen by entailer!.

  forward_for_simple_bound size (EX i : Z, PROP () LOCAL (gvar _m_entries p; temp _keys keys; temp _values values)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p;

         atomic_entries Tsh (sublist i (Zlength entries) entries) (sublist i (Zlength entries) ghosts)

           (sublist i (Zlength entries) h);

         EX lk : list Z, EX lv : list Z, !!(Zlength lk = i /\ Zlength lv = i /\

           Forall repable_signed lk /\ Forall repable_signed lv /\

           Forall2 full_hist (map fst (sublist 0 i h)) lk /\ Forall2 full_hist (map snd (sublist 0 i h)) lv /\

           Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e)

             (map fst (sublist 0 i h)) lk) &&

           data_at Tsh (tarray tint size) (map (fun x => vint x) lk ++ repeat Vundef (Z.to_nat (Zlength entries - i))) keys *

           data_at Tsh (tarray tint size) (map (fun x => vint x) lv ++ repeat Vundef (Z.to_nat (Zlength entries - i))) values)).

  { change size with 16384; computable. }

  { change size with 16384; computable. }

  - Exists (@nil Z) (@nil Z); rewrite sublist_nil.

    go_lower; repeat (apply andp_right; [apply prop_right; auto|]).

    rewrite !sublist_same by (auto; omega).

    repeat (apply sepcon_derives; [auto|]).

    + apply andp_right; [apply prop_right; repeat (split; auto)|].

      rewrite data_at__eq; unfold default_val; simpl.

      rewrite repeat_list_repeat, Z.sub_0_r, Hlen; auto.

    + rewrite data_at__eq; unfold default_val; simpl.

      rewrite repeat_list_repeat, Z.sub_0_r, Hlen; auto.

  - Intros lk lv.

    unfold atomic_entries.

    rewrite !sublist_next with (d := (Vundef, Vundef)) by omega.

    rewrite sublist_next with (i0 := i)(d := (Vundef, Vundef)) by omega.

    rewrite sublist_next with (d := ([], [])) by omega; simpl.

    destruct (Znth i entries (Vundef, Vundef)) as (pki, pvi) eqn: Hpi.

    destruct (Znth i ghosts (Vundef, Vundef)) as (gki, gvi) eqn: Hgi.

    destruct (Znth i h ([], [])) as (hki, hvi) eqn: Hhi.

    unfold atomic_entry, atomic_loc_hist; rewrite atomic_loc_isptr; Intros.

    forward.

    { entailer!.

      rewrite Hpi; auto. }

    rewrite Hpi.

    forward_call (pki, hist_R gki 0 k_R).

    unfold hist_R; Intros ki lki.

    gather_SEP 3 0; rewrite hist_ref_join by (apply Share.nontrivial).

    Intro hk'; unfold hist_sub; rewrite eq_dec_refl; Intros; subst hk'.

    forward.

    rewrite atomic_loc_isptr; Intros.

    forward.

    { entailer!.

      rewrite Hpi; auto. }

    rewrite Hpi.

    forward_call (pvi, hist_R gvi 0 v_R).

    unfold hist_R; Intros vi lvi.

    gather_SEP 5 0; rewrite hist_ref_join by (apply Share.nontrivial).

    Intro hv'; unfold hist_sub; rewrite eq_dec_refl; Intros; subst hv'.

    apply ghost_dealloc.

    focus_SEP 2; apply ghost_dealloc.

    forward.

    Exists (lk ++ [ki]) (lv ++ [vi]).

    go_lower.

    unfold v_R, k_R; Intros.

    rewrite !Zlength_app, !Zlength_cons, !Zlength_nil.

    apply andp_right.

    + apply prop_right.

      repeat (split; [repeat split; auto; omega|]).

      rewrite sublist_split with (mid := i), sublist_len_1 with (d := ([], [])), !map_app, Hhi by omega.

      do 2 (split; [rewrite Forall_app; auto|]).

      split; [|split]; apply Forall2_app; auto; repeat constructor; unfold full_hist; eauto.

      intros t e Hin; match goal with H : hist_list hki _ |- _ => apply H, nth_error_in in Hin; auto end.

    + fast_cancel.

      rewrite !map_app; simpl.

      replace (i + 1) with (Zlength (map (fun x => vint x) lk ++ [vint ki]))

        by (rewrite Zlength_app, Zlength_map, Zlength_cons, Zlength_nil; omega).

      rewrite <- upd_complete_gen by (rewrite Zlength_map; omega).

      replace (Zlength (map _ _ ++ _)) with (Zlength (map (fun x => vint x) lv ++ [vint vi]))

        by (rewrite !Zlength_app, !Zlength_map, !Zlength_cons, !Zlength_nil; omega).

      rewrite <- upd_complete_gen by (rewrite Zlength_map; omega).

      rewrite !Zlength_map.

      apply sepcon_derives; [auto|].

      apply sepcon_derives; [replace i with (Zlength lk) | replace i with (Zlength lv)]; auto.

  - Intros lk lv; forward.

    rewrite Hlen, Zminus_diag, !app_nil_r, !sublist_nil.

    unfold atomic_entries; simpl.

    repeat match goal with H : Forall2 _ (map _ (sublist _ _ _)) _ |- _ =>

      rewrite sublist_same in H by (auto; omega) end.

    Exists lk lv; apply andp_right; auto.

    

    apply andp_right; [entailer!|].

    apply andp_right; auto.

    apply sepcon_derives; [apply data_at_data_at_ | fast_cancel].

Qed.



Lemma lock_struct_array : forall sh z (v : list val) p,

  data_at sh (tarray (tptr (Tstruct _lock_t noattr)) z) v p =

  data_at sh (tarray (tptr tlock) z) v p.

Proof.

  intros.

  unfold data_at, field_at, at_offset; rewrite !data_at_rec_eq; simpl; f_equal.

Qed.



Lemma add_item_trace_wf : forall h k v i s h' (Hwf : wf_hists h) (Htrace : add_item_trace h k v i s h'),

  wf_hists h'.

Proof.

  intros.

  destruct Htrace as (Hlen & Hbounds & Hi & Hrest).

  destruct (Znth i h ([], [])) as (hk, hv) eqn: Hhi.

  unfold wf_hists; rewrite Forall_forall_Znth; intros j ?.

  apply (Forall_Znth _ _ j ([], [])) in Hwf; [destruct Hwf as ((? & ?) & ? & ?) | omega].

  destruct (eq_dec j i); [|specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i))].

  - subst; rewrite Hhi in *.

    destruct s.

    + destruct Hi as (Hi1 & Hi2 & ?).

      rewrite (add_events_snd _ _ _ Hi1), (add_events_snd _ _ _ Hi2), !Forall_app.

      repeat constructor; auto; eapply add_events_ordered; eauto.

    + destruct Hi as (Hi1 & -> & ?).

      split; auto.

      destruct Hi1 as [Hi1 | Hi1]; rewrite (add_events_snd _ _ _ Hi1), Forall_app; repeat constructor; auto;

        eapply add_events_ordered; eauto.

  - destruct Hrest as ((? & ? & Hcase & ? & ? & -> & ?) & _); auto.

    split; auto.

    destruct Hcase as [Hi1 | Hi1]; rewrite (add_events_snd _ _ _ Hi1), Forall_app; repeat constructor; auto;

      eapply add_events_ordered; eauto.

  - destruct Hrest as (_ & ->); auto.

Qed.



Corollary add_items_trace_wf : forall h la h', add_items_trace h la h' ->

  wf_hists h -> wf_hists h'.

Proof.

  induction 1; auto.

  intro; apply add_item_trace_wf in Hadd; auto.

Qed.



Lemma wf_empty : wf_hists empty_hists.

Proof.

  apply Forall_repeat; repeat split; simpl; auto; apply ordered_nil.

Qed.

Hint Resolve wf_empty.



Lemma add_items_length : forall h la h', add_items_trace h la h' -> Zlength h' = Zlength h.

Proof.

  induction 1; auto.

  destruct Hadd; omega.

Qed.



Corollary add_items_empty_length : forall h la, add_items_trace empty_hists la h -> Zlength h = size.

Proof.

  intros; erewrite add_items_length, Zlength_empty; eauto.

Qed.



Lemma f_pred_precise : forall tsh sh (entries ghosts : list (val * val)) p t locksp lockt resultsp res,

  readable_share sh -> Zlength ghosts = Zlength entries ->

  precise (f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res).

Proof.

  intros; unfold f_lock_pred.

  apply selflock_precise.

  unfold f_lock_inv.

  eapply derives_precise' with (Q := data_at_ _ _ _ *

    fold_right sepcon emp (map (fun '((pk, pv), (gk, gv)) =>

      (EX h : hist, atomic_loc_hist sh pk gk 0 k_R h) * (EX h : hist, atomic_loc_hist sh pv gv 0 v_R h))

      (combine entries ghosts)) * data_at_ sh _ _ * data_at_ _ _ _ * data_at_ _ _ _).

  - Intros hists li ls; assert_PROP (Zlength entries = size) as Hlene by entailer!.

    repeat (apply sepcon_derives; try apply data_at_data_at_).

    exploit add_items_length; eauto.

    rewrite Zlength_empty; intro Hlenh.

    assert (Zlength entries <= Zlength hists) by omega.

    apply sepcon_list_derives; rewrite !Zlength_map, !Zlength_combine, !Z.min_l; rewrite ?Z.min_l; auto;

      try omega.

    intros; rewrite Znth_map with (d' := ((Vundef, Vundef), (Vundef, Vundef), ([], [])))

      by (rewrite !Zlength_combine, !Z.min_l; rewrite ?Z.min_l; auto; omega).

    rewrite Znth_map with (d' := ((Vundef, Vundef), (Vundef, Vundef)))

      by (rewrite Zlength_combine, Z.min_l; omega).

    rewrite !Znth_combine by (rewrite ?Zlength_combine, ?Z.min_l; omega).

    unfold atomic_entry.

    destruct (Znth i entries (Vundef, Vundef)), (Znth i ghosts (Vundef, Vundef)).

    destruct (Znth i hists ([], [])) as (hk, hv).

    Exists hk hv; auto.

  - repeat (apply precise_sepcon; auto).

    apply precise_fold_right.

    rewrite Forall_map, Forall_forall; intros ((?, ?), (?, ?)) ?; simpl.

    apply precise_sepcon; apply atomic_loc_hist_precise; auto.

Qed.



Lemma f_pred_positive : forall tsh sh entries ghosts p t locksp lockt resultsp res,

  positive_mpred (f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res).

Proof.

  intros; apply selflock_positive.

Qed.

Hint Resolve f_pred_precise f_pred_positive.



Lemma body_f : semax_body Vprog Gprog f_f f_spec.

Proof.

  start_function.

  rewrite (data_at_isptr Tsh); Intros.

  assert (force_val (sem_cast_neutral tid) = tid) as Htid.

  { destruct tid; try contradiction; auto. }

  replace_SEP 2 (data_at Tsh tint (vint t) (force_val (sem_cast_neutral tid))).

  { rewrite Htid; entailer!. }

  forward.

  rewrite <- lock_struct_array.

  forward.

  { entailer!.

    rewrite upd_Znth_same; auto. }

  forward.

  { entailer!.

    rewrite upd_Znth_same; auto. }

  rewrite !upd_Znth_same by auto.

  forward.

  focus_SEP 2.

  forward_call (tid, sizeof tint).

  { rewrite Htid; apply sepcon_derives; [apply data_at_memory_block | cancel_frame]. }

  forward_for_simple_bound 3 (EX i : Z, EX ls : list bool,

    PROP (Zlength ls = i)

    LOCAL (temp _total (vint (Zlength (filter id ls))); temp _res res; temp _l lockt; temp _t (vint t);

           temp _arg tid; gvar _m_entries p; gvar _thread_locks locksp; gvar _results resultsp)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries p;

         EX h : list (hist * hist), EX li : list Z,

           !!(Zlength li = i /\ add_items_trace empty_hists (combine (combine (combine (sublist 0 i [1; 2; 3])

              (sublist 0 i [1; 1; 1])) li) ls) h) && atomic_entries sh entries ghosts h;

         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

         data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

         data_at_ Tsh tint res;

         lock_inv tsh lockt (f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res))).

  - Exists (@nil bool) (empty_hists : list (hist * hist)) (@nil Z); entailer!.

    constructor.

  - Intros h li.

    forward_call (i + 1, 1, p, sh, entries, ghosts, h).

    { repeat (split; auto; try computable; try omega).

      + pose proof (Int.min_signed_neg); omega.

      + transitivity 4; [omega | computable].

      + eapply add_items_empty_length; eauto.

      + eapply add_items_trace_wf; eauto. }

    apply extract_exists_pre; intros ((s, j), h'); simpl; Intros.

    match goal with |- semax _ (PROP () (LOCALx (?a :: ?b :: temp _total _ :: ?Q) (SEPx ?R))) _ _ =>

      forward_if (PROP () (LOCALx (a :: b :: temp _total (vint (Zlength (filter id (x ++ [s])))) :: Q)

                 (SEPx R))) end.

    + forward.

      subst; rewrite filter_app, Zlength_app; entailer!.

    + forward.

      subst; rewrite filter_app, Zlength_app; entailer!.

    + intros.

      unfold exit_tycon, overridePost.

      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

      Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert, overridePost.

      repeat (apply andp_right; [apply prop_right; auto|]).

      Exists (x ++ [s]) h' (li ++ [j]); entailer!.

      erewrite !sublist_split with (lo := 0)(mid := Zlength x)(hi := Zlength x + 1), !sublist_len_1;

        rewrite ?Zlength_app, ?Zlength_cons, ?Zlength_nil; auto; try omega.

      split; auto; split; [omega|].

      rewrite !combine_app'; rewrite ?Zlength_combine, ?Zlength_sublist, ?Z.min_l; rewrite ?Z.min_l, ?Zlength_cons,

        ?Zlength_nil; try omega; simpl.

      econstructor; eauto.

      change [1; 2; 3] with (map Z.succ (upto 3)); change [1; 1; 1] with (repeat 1 3).

      rewrite Znth_map', Znth_upto, Znth_repeat; auto; simpl; omega.

  - Intros ls h li.

    forward.

    forward_call (lockt, tsh, f_lock_inv sh entries ghosts p t locksp lockt resultsp res,

                  f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res).

    { assert_PROP (Zlength entries = size) by entailer!.

      lock_props.

      { apply f_pred_precise; auto; omega. }

      { apply selflock_rec. }

      unfold f_lock_pred.

      rewrite selflock_eq at 2.

      unfold f_lock_inv at 2.

      rewrite lock_struct_array.

      Exists h li ls; entailer!.

      subst Frame; instantiate (1 := []); simpl; rewrite sepcon_emp; apply lock_inv_later. }

    forward.

Qed.



Lemma lock_struct : forall p, data_at_ Tsh (Tstruct _lock_t noattr) p |-- data_at_ Tsh tlock p.

Proof.

  intros.

  unfold data_at_, field_at_; unfold_field_at 1%nat.

  unfold field_at, at_offset; simpl.

  rewrite field_compatible_cons; simpl; entailer!.

Qed.



Fixpoint join_hists (h1 h2 : list (hist * hist)) :=

  match (h1, h2) with

  | ((k1, v1) :: rest1, (k2, v2) :: rest2) => (k1 ++ k2, v1 ++ v2) :: join_hists rest1 rest2

  | _ => []

  end.



Lemma join_hists_spec : forall h1 h2 i, Zlength h1 = Zlength h2 ->

  Znth i (join_hists h1 h2) ([], []) =

  (fst (Znth i h1 ([], [])) ++ fst (Znth i h2 ([], [])),

  (snd (Znth i h1 ([], [])) ++ snd (Znth i h2 ([], [])))).

Proof.

  induction h1; destruct h2; simpl; intros; rewrite ?Zlength_cons, ?Zlength_nil in *.

  - rewrite Znth_nil; auto.

  - pose proof (Zlength_nonneg h2); omega.

  - pose proof (Zlength_nonneg h1); omega.

  - destruct a, p.

    destruct (zlt i 0).

    { rewrite !Znth_underflow; auto. }

    destruct (eq_dec i 0).

    + subst; rewrite !Znth_0_cons; auto.

    + rewrite !Znth_pos_cons by omega.

      apply IHh1; omega.

Qed.



Lemma join_empty : forall h, Zlength h = size -> join_hists empty_hists h = h.

Proof.

  intros.

  rewrite Zlength_correct in H.

  assert (length h = Z.to_nat size) as Hlen by Omega0.

  forget (Z.to_nat size) as n; clear H.

  revert dependent h; induction n; destruct h; auto; intros; inv Hlen; simpl.

  destruct p; rewrite IHn; auto.

Qed.



Lemma atomic_entries_join : forall sh1 sh2 sh entries ghosts hists1 hists2 hists

  (Hjoin : sepalg.join sh1 sh2 sh) (Hhists : join_hists hists1 hists2 = hists)

  (Hghosts : Zlength ghosts = Zlength entries)

  (Hlen : Zlength entries = Zlength hists1) (Hlen1 : Zlength hists1 = Zlength hists2)

  (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2),

  atomic_entries sh1 entries ghosts hists1 * atomic_entries sh2 entries ghosts hists2 =

  !!(forall i, disjoint (fst (Znth i hists1 ([], []))) (fst (Znth i hists2 ([], []))) /\

               disjoint (snd (Znth i hists1 ([], []))) (snd (Znth i hists2 ([], [])))) &&

    atomic_entries sh entries ghosts hists.

Proof.

  induction entries; unfold atomic_entries; simpl; intros.

  { exploit Zlength_nil_inv; eauto; intro; subst.

    exploit (Zlength_nil_inv hists1); auto; intro; subst.

    exploit (Zlength_nil_inv hists2); auto; intro; subst.

    rewrite prop_true_andp, sepcon_emp; auto.

    intro; rewrite Znth_nil; simpl; auto. }

  destruct ghosts; [exploit (Zlength_nil_inv (a :: entries)); eauto; discriminate|].

  destruct hists1; [exploit (Zlength_nil_inv (a :: entries)); eauto; discriminate|].

  destruct hists2; [exploit Zlength_nil_inv; eauto; discriminate|].

  rewrite !Zlength_cons in *; simpl in *.

  destruct a, p as (gk, gv), p0 as (hk1, hv1), p1 as (hk2, hv2); subst; simpl.

  unfold atomic_entry.

  match goal with |- (?P1 * ?Q1) * (?P2 * ?Q2) = _ =>

    transitivity ((P1 * P2) * (Q1 * Q2)); [apply mpred_ext; cancel|] end.

  setoid_rewrite (IHentries _ _ _ _ Hjoin eq_refl); auto; try omega.

  match goal with |- (?P1 * ?Q1 * (?P2 * ?Q2) * ?R) = _ =>

    transitivity ((P1 * P2) * (Q1 * Q2) * R); [apply mpred_ext; cancel|] end.

  erewrite !atomic_loc_hist_join by eauto.

  apply mpred_ext; entailer!.

  - intros.

    destruct (zlt i 0); [rewrite !Znth_underflow; simpl; auto|].

    destruct (eq_dec i 0).

    + subst; rewrite !Znth_0_cons; auto.

    + rewrite !Znth_pos_cons by omega; auto.

  - pose proof (H 0) as H0.

    rewrite !Znth_0_cons in H0; destruct H0; split; auto; split; auto.

    intro i; specialize (H (i + 1)).

    destruct (zlt i 0); [rewrite !Znth_underflow; simpl; auto|].

    rewrite !Znth_pos_cons, Z.add_simpl_r in H by omega; auto.

Qed.



Corollary atomic_entries_join_nil : forall sh1 sh2 sh entries ghosts

  (Hjoin : sepalg.join sh1 sh2 sh) (Hlen : Zlength entries = size) (Hleng : Zlength ghosts = size)

  (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2),

  atomic_entries sh1 entries ghosts empty_hists * atomic_entries sh2 entries ghosts empty_hists =

  atomic_entries sh entries ghosts empty_hists.

Proof.

  intros; erewrite atomic_entries_join with (sh := sh)

    by (rewrite ?join_empty; rewrite ?Zlength_empty; auto; omega).

  rewrite prop_true_andp; eauto.

  intro; rewrite Znth_repeat; simpl; auto.

Qed.



Lemma join_hists_length : forall h1 h2, Zlength h1 = Zlength h2 ->

  Zlength (join_hists h1 h2) = Zlength h1.

Proof.

  induction h1; auto; simpl; intros.

  destruct h2; [apply Zlength_nil_inv in H; discriminate|].

  destruct a, p; rewrite !Zlength_cons in *; rewrite IHh1; auto; omega.

Qed.



Corollary fold_join_hists_length : forall lh h, Forall (fun h' => Zlength h' = Zlength h) lh ->

  Zlength (fold_right join_hists h lh) = Zlength h.

Proof.

  induction lh; auto; simpl; intros.

  inv H.

  rewrite join_hists_length; auto.

  rewrite IHlh; auto.

Qed.



Corollary join_hists_empty_length : forall lh, Forall (fun h => Zlength h = size) lh ->

  Zlength (fold_right join_hists empty_hists lh) = size.

Proof.

  intros; rewrite fold_join_hists_length.

  - apply Zlength_empty.

  - eapply Forall_impl; [|eauto].

    intros; rewrite Zlength_empty; auto.

Qed.



Lemma join_empty_r : forall h, Zlength h = size -> join_hists h empty_hists = h.

Proof.

  intros.

  rewrite Zlength_correct in H.

  assert (length h = Z.to_nat size) as Hlen by Omega0.

  forget (Z.to_nat size) as n; clear H.

  revert dependent h; induction n; destruct h; auto; intros; inv Hlen; simpl.

  destruct p; rewrite IHn, !app_nil_r; auto.

Qed.



Lemma join_hists_assoc : forall a b c, join_hists a (join_hists b c) = join_hists (join_hists a b) c.

Proof.

  induction a; auto; simpl; intros.

  destruct a, b; auto; simpl.

  destruct p, c; auto; simpl.

  destruct p; rewrite IHa, !app_assoc; auto.

Qed.



Lemma join_hists_base : forall l h, Zlength h = size ->

  fold_right join_hists (join_hists h empty_hists) l = join_hists (fold_right join_hists empty_hists l) h.

Proof.

  induction l; simpl; intros.

  - rewrite join_empty, join_empty_r; auto.

  - rewrite IHl, join_hists_assoc; auto.

Qed.



Lemma add_rest_hists : forall k i h h' (Hrest : forall j,

  (In j (indices (hash k) i) -> failed_CAS k (Znth j h ([], [])) (Znth j h' ([], []))) /\

  (~ In j (indices (hash k) i) -> j <> i -> Znth j h' ([], []) = Znth j h ([], []))) j (Hj : j <> i),

  exists rest, Znth j h' ([], []) = (fst (Znth j h ([], [])) ++ rest, snd (Znth j h ([], []))) /\

    Forall (fun e => forall v, ~writes e v) (map snd rest).

Proof.

  intros.

  specialize (Hrest j).

  destruct (in_dec Z_eq_dec j (indices (hash k) i)).

  - destruct (Znth j h' ([], [])).

    destruct Hrest as ((r & ? & Hi1 & ? & ? & Hi2 & _) & _); auto.

    simpl in *; rewrite Hi2.

    destruct Hi1 as [Hi1 | Hi1]; apply add_events_add in Hi1; destruct Hi1 as (rest & ? & Hsnd); subst;

      exists rest; split; auto; rewrite Hsnd; repeat constructor; auto; simpl.

    intros ? (? & ?).

    absurd (r = 0); auto; apply repr_inj_signed; auto; congruence.

  - destruct Hrest as (_ & Hrest); rewrite Hrest by auto.

    destruct (Znth j h ([], [])); exists []; rewrite app_nil_r; simpl; auto.

Qed.



Lemma key_hists_fail : forall h k v i h' j (Hfail : add_item_trace h k v i false h')

  (Hk : k <> 0) (Hrep : repable_signed k),

  exists rest, Znth j h' ([], []) = (fst (Znth j h ([], [])) ++ rest, snd (Znth j h ([], []))) /\

    Forall (fun e => forall v, ~writes e v) (map snd rest).

Proof.

  intros.

  destruct (eq_dec j i).

  - destruct Hfail as (? & ? & Hi & _).

    subst; destruct (Znth i h ([], [])), (Znth i h' ([], [])); simpl in *.

    destruct Hi as ([Hi1 | Hi1] & ? & ?); apply add_events_add in Hi1; destruct Hi1 as (rest & ? & Hsnd); subst;

      exists rest; split; auto; rewrite Hsnd; repeat constructor; auto; simpl.

    intros ? (? & ?).

    contradiction Hk; apply repr_inj_signed; auto; congruence.

  - destruct Hfail as (? & ? & _ & Hrest).

    eapply add_rest_hists; eauto.

Qed.



Lemma add_item_trace_map : forall h k v i s h' (Hlenh : Zlength h = size)

  (Htrace : add_item_trace h k v i s h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),

  let m' := make_map (upd_Znth i h' (Znth i h ([], []))) in

    map_incl (make_map h) m' /\ lookup m' k = Some i /\

    if s then get (make_map h) k = None /\ make_map h' = upd_Znth i m' (k, v)

    else make_map h' = upd_Znth i m' (k, make_int (value_of_hist (snd (Znth i h' ([], []))))).

Proof.

  intros.

  destruct Htrace as (Hlen & Hbounds & Hi & Hrest).

  destruct (Znth i h ([], [])) as (hk, hv) eqn: Hhi.

  assert (i <= Zlength h') by (rewrite Hlen; destruct Hbounds; apply Z.lt_le_incl; auto).

  assert (0 <= i + 1 <= Zlength h').

  { rewrite Hlen; destruct Hbounds; split; [|rewrite <- lt_le_1]; auto; omega. }

  assert (vint k <> vint 0).

  { intro; contradiction Hk; apply repr_inj_signed; auto; congruence. }

  split.

  - intros k0 v0 j Hk0 Hj.

    exploit (Znth_inbounds j (make_map h) (0, 0)).

    { rewrite Hj; intro X; inv X; contradiction Hk0; auto. }

    intro; unfold make_map in *.

    rewrite Zlength_map in *.

    rewrite Znth_map with (d' := ([], [])) in Hj by auto; inv Hj.

    subst m'; rewrite Znth_map with (d' := ([], [])) by (rewrite upd_Znth_Zlength; omega).

    destruct (eq_dec j i); [subst; rewrite upd_Znth_same, Hhi by omega; auto|].

    rewrite upd_Znth_diff by (auto; omega).

    specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i));

      [|destruct Hrest as (_ & ->); auto].

    destruct Hrest as ((r1 & ? & Hcase & ? & ? & -> & Heq) & _); auto; simpl in *.

    assert (value_of_hist (fst (Znth j h ([], []))) <> vint 0).

    { intro X; rewrite X in Hk0; contradiction Hk0; auto. }

    destruct Hcase as [Hi1 | Hi1]; rewrite (add_events_last _ _ _ Hi1); simpl; try discriminate;

      rewrite Heq; auto.

  - assert (0 <= i < Zlength h') by (rewrite Hlen; auto).

    split.

    + subst m'; unfold lookup, make_map.

      assert (i = ((i - hash k) mod size + hash k) mod size) as Hmod.

      { rewrite Zplus_mod_idemp_l, Z.sub_simpl_r, Zmod_small by omega; auto. }

      pose proof (hash_range k).

      assert (Zlength (map (fun hs => (make_int (value_of_hist (fst hs)), make_int (value_of_hist (snd hs))))

              (upd_Znth i h' (hk, hv))) = size) as Hlen1.

      { rewrite Zlength_map, upd_Znth_Zlength; auto; omega. }

      erewrite index_of'_succeeds; simpl.

      f_equal; symmetry; apply Hmod.

      { rewrite Zlength_rebase; rewrite ?Zlength_map, ?upd_Znth_Zlength; auto;

          replace (Zlength h') with size; auto; try omega.

        apply Z_mod_lt, size_pos. }

      { rewrite Forall_forall; intros x Hin.

        apply In_Znth with (d := (0, 0)) in Hin; destruct Hin as (j & Hj & Hx).

        exploit (Z_mod_lt (i - hash k) size); [apply size_pos | intro].

        rewrite Zlength_sublist in Hj; rewrite ?Zlength_rebase; rewrite ?Hlen1; try (simpl in *; omega).

        rewrite Znth_sublist, Z.add_0_r in Hx by (auto; omega).

        rewrite Znth_rebase in Hx by (simpl in *; omega).

        rewrite Hlen1, Znth_map with (d' := ([], [])) in Hx.

        subst x; simpl.

        specialize (Hrest ((j + hash k) mod size)); destruct Hrest as ((r1 & ? & Hcase & ? & ? & ?) & _).

        { unfold indices; rewrite in_map_iff.

          exists j; split; [rewrite Z.add_comm; auto|].

          rewrite In_upto, Z2Nat.id; omega. }

        rewrite upd_Znth_diff'; auto.

        destruct Hcase as [Hj1 | Hj1]; setoid_rewrite (add_events_last _ _ _ Hj1); try discriminate; simpl;

          rewrite Int.signed_repr; auto.

        * intro X; rewrite <- X, Zminus_mod_idemp_l, Z.add_simpl_r, Z.sub_0_r, Zmod_small in Hj; try omega.

          destruct Hj; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos.

        * rewrite upd_Znth_Zlength by auto.

          replace (Zlength h') with size by omega; apply Z_mod_lt, size_pos. }

      { rewrite <- Hlen1, Znth_rebase', Znth_map with (d' := ([], [])); simpl;

          rewrite ?Zlength_map, ?upd_Znth_Zlength; auto; try (simpl in *; omega).

        rewrite upd_Znth_same by auto; simpl.

        destruct s; [destruct Hi as (? & ? & ->); auto|].

        destruct Hi as (? & ? & Hr0).

        destruct (eq_dec (value_of_hist hk) (vint 0)); [rewrite e; auto|].

        rewrite Hr0; auto; simpl.

        rewrite Int.signed_repr; auto. }

    + subst m'; unfold make_map; rewrite <- upd_Znth_map; destruct s; [split|].

      * unfold get, lookup.

        pose proof (index_of'_spec k (rebase (make_map h) (hash k))) as Hspec.

        unfold make_map in *; destruct (index_of' _ _); auto; simpl.

        assert (0 <= hash k < Zlength (make_map h)); unfold make_map in *.

        { rewrite Zlength_map, Hlenh; apply Z_mod_lt, size_pos. }

        rewrite Znth_map with (d' := ([], [])) by (rewrite Hlenh; apply Z_mod_lt, size_pos).

        destruct (eq_dec _ _); auto.

        destruct Hspec as (? & Hz & Hall).

        eapply Forall_sublist_le in Hall; rewrite ?Znth_rebase' with (i := i); auto; try omega.

        rewrite Zlength_rebase in * by auto.

        rewrite Znth_rebase, Znth_map with (d' := ([], [])) in Hz

          by (auto; rewrite Zlength_map; apply Z_mod_lt; omega); simpl in Hz.

        rewrite Zlength_map in *.

        rewrite Hlenh in *; destruct (eq_dec ((z + hash k) mod size) i).

        { simpl in e; rewrite e, Hhi in n; simpl in n.

          destruct Hi as (? & ? & Hzero); rewrite Hzero in n; contradiction. }

        destruct (eq_dec z ((i - hash k) mod size)).

        { subst z; contradiction n0.

          rewrite Zplus_mod_idemp_l, Z.sub_simpl_r, Zmod_small; auto. }

        destruct (Hrest ((z + hash k) mod size)) as ((r0 & ? & ? & ? & Hrk & ? & Hr0) & ?).

        { unfold indices; rewrite in_map_iff.

          do 2 eexists; [rewrite Z.add_comm; eauto|].

          rewrite In_upto, Z2Nat.id; omega. }

        destruct Hz as [Hz | Hz]; [|contradiction].

        simpl in *; destruct (value_of_hist (fst _)); try contradiction; simpl in Hz; subst.

        subst; destruct (eq_dec (Vint i0) (vint 0)).

        { inv e; contradiction Hk; rewrite Int.signed_repr; auto. }

        assert (Vint i0 = vint r0) as Heq by auto.

        inv Heq; contradiction Hrk; rewrite Int.signed_repr; auto.

        { rewrite Zlength_map, Hlenh; apply Z_mod_lt, size_pos. }

        { rewrite Znth_map', Hhi; simpl.

          destruct Hi as (? & ? & ->); tauto. }

        { rewrite Zlength_map; auto. }

      * erewrite upd_Znth_twice, upd_Znth_triv; rewrite ?Zlength_map; auto.

        rewrite Znth_map'.

        destruct Hi as (Hi1 & Hi2 & ?).

        rewrite (add_events_last _ _ _ Hi1), (add_events_last _ _ _ Hi2); try discriminate; simpl.

        rewrite !Int.signed_repr; auto.

      * erewrite upd_Znth_twice, upd_Znth_triv; rewrite ?Zlength_map; auto.

        rewrite Znth_map'; f_equal.

        destruct Hi as ([Hi1 | Hi1] & ? & ?); rewrite (add_events_last _ _ _ Hi1); try discriminate; simpl;

          rewrite Int.signed_repr; auto.

Qed.



Lemma join_empty_hists : forall h n, Zlength h = size -> fold_right join_hists h (repeat empty_hists n) = h.

Proof.

  induction n; auto; simpl; intro.

  rewrite join_empty; auto.

  rewrite fold_join_hists_length; auto.

  apply Forall_repeat; rewrite Zlength_repeat, Z2Nat.id; auto.

  pose proof size_pos; omega.

Qed.



Lemma Znth_join_hists : forall i lh (Hlen : Forall (fun h => Zlength h = size) lh),

  Znth i (fold_right join_hists empty_hists lh) ([], []) =

  (concat (map fst (map (fun h => Znth i h ([], [])) lh)),

   concat (map snd (map (fun h => Znth i h ([], [])) lh))).

Proof.

  induction lh; simpl; intro.

  - rewrite Znth_repeat; auto.

  - inv Hlen.

    rewrite join_hists_spec by (rewrite join_hists_empty_length; auto).

    rewrite IHlh by auto; reflexivity.

Qed.



Lemma add_items_hist_length : forall h lr, Forall (fun '(la, h') => add_items_trace h la h') lr ->

  Forall (fun h' => Zlength h' = Zlength h) (map snd lr).

Proof.

  intros.

  rewrite Forall_map; eapply Forall_impl; [|eauto].

  simpl; intros (?, ?) ?.

  eapply add_items_length; eauto.

Qed.



Corollary add_items_empty_hist_length : forall lr,

  Forall (fun '(la, h') => add_items_trace empty_hists la h') lr ->

  Forall (fun h' => Zlength h' = size) (map snd lr).

Proof.

  intros.

  eapply Forall_impl, add_items_hist_length; [|eauto].

  intros; rewrite <- Zlength_empty; auto.

Qed.



Definition hists_mono (h1 h2 : list (hist * hist)) := Forall2 (fun a b =>

  (exists l, fst b = fst a ++ l) /\ (exists l, snd b = snd a ++ l)) h1 h2.



Instance hists_mono_refl : RelationClasses.Reflexive hists_mono.

Proof.

  intro; unfold hists_mono; rewrite Forall2_eq_upto with (d1 := ([], []))(d2 := ([], [])); split; auto.

  rewrite Forall_forall; intros j Hin; rewrite In_upto, Z2Nat.id in Hin by (apply Zlength_nonneg).

  split; exists []; rewrite app_nil_r; auto.

Qed.

Hint Resolve hists_mono_refl.



Instance hists_mono_trans : RelationClasses.Transitive hists_mono.

Proof.

  intro x; induction x; intros ?? H; inv H; intro H; inv H; auto.

  constructor; [|eapply IHx; eauto].

  match goal with H : (exists l, fst y = _ ++ l) /\ _ |- _ => destruct H as ((? & ->) & (? & ->)) end.

  match goal with H : (exists l, fst y0 = _ ++ l) /\ _ |- _ => destruct H as ((? & ->) & (? & ->)) end.

  rewrite <- !app_assoc; eauto.

Qed.



Lemma add_item_trace_mono : forall h k v i s h', add_item_trace h k v i s h' -> hists_mono h h'.

Proof.

  intros; destruct H as (? & ? & Hi & Hrest).

  unfold hists_mono; rewrite Forall2_eq_upto with (d1 := ([], []))(d2 := ([], [])); split; auto.

  rewrite Forall_forall; intros j Hin; rewrite In_upto, Z2Nat.id in Hin by omega.

  destruct (eq_dec j i).

  - subst; destruct (Znth i h ([], [])), s.

    + destruct Hi as (Hi1 & Hi2 & ?); apply add_events_add in Hi1; apply add_events_add in Hi2.

      destruct Hi1 as (? & ? & ?); destruct Hi2 as (? & ? & ?); eauto.

    + destruct Hi as (Hi & -> & ?); split; [|exists []; rewrite app_nil_r; auto].

      destruct Hi as [Hi | Hi]; apply add_events_add in Hi; destruct Hi as (? & ? & ?); eauto.

  - exploit add_rest_hists; eauto; intros (? & -> & ?); simpl.

    split; eexists; eauto.

    rewrite app_nil_r; auto.

Qed.



Corollary add_items_trace_mono : forall h la h', add_items_trace h la h' ->

  hists_mono h h'.

Proof.

  induction 1; auto.

  etransitivity; eauto; eapply add_item_trace_mono; eauto.

Qed.



Lemma remove_last_full_hist : forall lh h j h' k v i k' i' (Hj : 0 <= j < Zlength lh) (Hh : Znth j lh [] = h)

  (Hi' : 0 <= i' < Zlength h) (Hadd : add_item_trace h' k v i false h) (Hk : k <> 0) (Hrep : repable_signed k)

  (Hfull : full_hist' (concat (map fst (map (fun h => Znth i' h ([], [])) lh))) k'),

  full_hist' (concat (upd_Znth j (map fst (map (fun h => Znth i' h ([], [])) lh))

    (fst (Znth i' h' ([], []))))) k'.

Proof.

  intros.

  apply key_hists_fail with (j := i') in Hadd; auto.

  destruct Hadd as (? & Heq & Hfail).

  eapply full_hist'_drop; eauto.

  - eapply concat_less_incl.

    + rewrite !Zlength_map; auto.

    + erewrite Znth_map, Znth_map', Hh, Heq by (rewrite Zlength_map; auto); simpl; eauto.

  - rewrite concat_map in *.

    rewrite <- upd_Znth_map.

    eapply NoDup_concat_less.

    + destruct Hfull as (? & Hl & ?).

      rewrite <- concat_map; eapply hist_list'_NoDup; eauto.

    + rewrite !Zlength_map; auto.

    + erewrite Znth_map, !Znth_map', Hh, Heq by (rewrite !Zlength_map; auto); simpl.

      rewrite map_app; auto.

  - intros t e Hin Hout.

    rewrite in_concat in Hin, Hout.

    destruct Hin as (? & ? & Hin).

    rewrite in_map_iff in Hin; destruct Hin as (? & ? & Hin); subst.

    rewrite in_map_iff in Hin; destruct Hin as (? & ? & Hin); subst.

    apply In_Znth with (d := []) in Hin; destruct Hin as (j' & ? & Hj').

    destruct (eq_dec j' j); subst.

    + rewrite Heq in H; simpl in H.

      rewrite in_app in H; destruct H.

      * contradiction Hout.

        do 2 eexists; eauto.

        apply upd_Znth_In.

      * rewrite Forall_map, Forall_forall in Hfail; specialize (Hfail _ H); auto.

    + contradiction Hout.

      do 2 eexists; eauto.

      rewrite upd_Znth_map, in_map_iff; do 2 eexists; eauto.

      rewrite upd_Znth_map with (f := fun h => Znth i' h ([], [])), in_map_iff; do 2 eexists; eauto.

      erewrite <- upd_Znth_diff with (j0 := j); auto.

      apply Znth_In; rewrite upd_Znth_Zlength; auto.

Qed.



Lemma remove_last_full_hist' : forall lh h j h' k v i k' i' (Hj : 0 <= j < Zlength lh) (Hh : Znth j lh [] = h)

  (Hi' : 0 <= i' < Zlength h) (Hadd : add_item_trace h' k v i true h) (Hk : k <> 0) (Hrep : repable_signed k)

  (Hfull : full_hist' (concat (map fst (map (fun h => Znth i' h ([], [])) lh))) k') (Hneq : i' <> i),

  full_hist' (concat (upd_Znth j (map fst (map (fun h => Znth i' h ([], [])) lh))

    (fst (Znth i' h' ([], []))))) k'.

Proof.

  intros.

  destruct Hadd as (? & ? & _ & Hrest); apply add_rest_hists with (j := i') in Hrest; auto.

  destruct Hrest as (? & Heq & Hfail).

  eapply full_hist'_drop; eauto.

  - eapply concat_less_incl.

    + rewrite !Zlength_map; auto.

    + erewrite Znth_map, Znth_map', Hh, Heq by (rewrite Zlength_map; auto); simpl; eauto.

  - rewrite concat_map in *.

    rewrite <- upd_Znth_map.

    eapply NoDup_concat_less.

    + destruct Hfull as (? & Hl & ?).

      rewrite <- concat_map; eapply hist_list'_NoDup; eauto.

    + rewrite !Zlength_map; auto.

    + erewrite Znth_map, !Znth_map', Hh, Heq by (rewrite !Zlength_map; auto); simpl.

      rewrite map_app; auto.

  - intros t e Hin Hout.

    rewrite in_concat in Hin, Hout.

    destruct Hin as (? & Hin0 & Hin).

    rewrite in_map_iff in Hin; destruct Hin as (? & ? & Hin); subst.

    rewrite in_map_iff in Hin; destruct Hin as (? & ? & Hin); subst.

    apply In_Znth with (d := []) in Hin; destruct Hin as (j' & ? & Hj').

    destruct (eq_dec j' j); subst.

    + rewrite Heq in Hin0; simpl in Hin0.

      rewrite in_app in Hin0; destruct Hin0 as [|Hin0].

      * contradiction Hout.

        do 2 eexists; eauto.

        apply upd_Znth_In.

      * rewrite Forall_map, Forall_forall in Hfail; specialize (Hfail _ Hin0); auto.

    + contradiction Hout.

      do 2 eexists; eauto.

      rewrite upd_Znth_map, in_map_iff; do 2 eexists; eauto.

      rewrite upd_Znth_map with (f := fun h => Znth i' h ([], [])), in_map_iff; do 2 eexists; eauto.

      erewrite <- upd_Znth_diff with (j0 := j); auto.

      apply Znth_In; rewrite upd_Znth_Zlength; auto.

Qed.



Lemma add_key_success : forall la h' t e i v (Hadd : add_items_trace empty_hists la h')

  (Hin : In (t, e) (fst (Znth i h' ([], [])))) (Hval : writes e v)

  (Hnzk : Forall (fun x => let '(k, _, _, _) := x in k <> 0 /\ repable_signed k) la),

  exists k v', In (k, v', i, true) la /\ v = vint k /\ e = CAS (vint 0) (vint 0) (vint k) /\ repable_signed k.

Proof.

  intros; remember empty_hists as h0; induction Hadd; subst.

  - rewrite Znth_repeat in Hin; contradiction.

  - rewrite Forall_app in Hnzk; destruct Hnzk as (? & Hnzk); inversion Hnzk as [|?? Hk].

    destruct Hk; subst.

    assert (0 <= i < Zlength h'').

    { apply Znth_inbounds with (d := ([], [])).

      intro X; rewrite X in Hin; contradiction. }

    assert (0 <= i < Zlength h').

    { destruct Hadd0; omega. }

    destruct (in_dec (EqDec_prod _ _ _ _) (t, e) (fst (Znth i h' ([], [])))).

    { exploit IHHadd; eauto.

      intros (? & ? & ? & ?); do 2 eexists; rewrite in_app; eauto. }

    destruct Hadd0 as (? & ? & Hi & Hrest).

    destruct (eq_dec i0 i).

    + subst; destruct (Znth i h' ([], [])).

      destruct s.

      * destruct Hi as (Hi1 & ? & _).

        apply add_events_add in Hi1; destruct Hi1 as (x & Happ & Hsnd); rewrite Happ, in_app in Hin.

        destruct Hin as [? | Hin]; [contradiction|].

        assert (In e (map snd x)) as Hin' by (rewrite in_map_iff; do 2 eexists; eauto; auto).

        rewrite Hsnd in Hin'; destruct Hin' as [Heq | [Heq | Heq]]; subst; try contradiction.

        simpl in Hval; destruct Hval.

        subst; do 2 eexists; rewrite in_app; simpl; split; eauto.

      * destruct Hi as ([Hi1 | Hi1] & ? & ?); apply add_events_add in Hi1; destruct Hi1 as (x & Happ & Hsnd);

          rewrite Happ, in_app in Hin; destruct Hin as [? | Hin]; try contradiction;

          assert (In e (map snd x)) as Hin' by (rewrite in_map_iff; do 2 eexists; eauto; auto);

          rewrite Hsnd in Hin'; simpl in Hin'; decompose [or] Hin'; subst; try contradiction.

        simpl in Hval; destruct Hval; subst.

        absurd (k = 0); auto; apply repr_inj_signed; auto; congruence.

    + exploit add_rest_hists; eauto; intros (? & Hh & Hw); rewrite Hh in Hin.

      simpl in Hin; rewrite in_app in Hin; destruct Hin as [|Hin]; [contradiction|].

      rewrite Forall_map, Forall_forall in Hw; exploit (Hw _ Hin); eauto; contradiction.

Qed.



Lemma add_val_success : forall la h' t e i v (Hadd : add_items_trace empty_hists la h')

  (Hin : In (t, e) (snd (Znth i h' ([], [])))) (Hval : value_of e = vint v) (Hv : repable_signed v)

  (Hrep : Forall (fun x => let '(_, v, _, _) := x in repable_signed v) la),

  exists k, In (k, v, i, true) la /\

    exists t', In (t', CAS (vint 0) (vint 0) (vint k)) (fst (Znth i h' ([], []))).

Proof.

  intros; remember empty_hists as h0; induction Hadd; subst.

  - rewrite Znth_repeat in Hin; contradiction.

  - rewrite Forall_app in Hrep; destruct Hrep as (? & Hrep); inv Hrep.

    assert (0 <= i < Zlength h'').

    { apply Znth_inbounds with (d := ([], [])).

      intro X; rewrite X in Hin; contradiction. }

    assert (0 <= i < Zlength h').

    { destruct Hadd0; omega. }

    destruct (in_dec (EqDec_prod _ _ _ _) (t, e) (snd (Znth i h' ([], [])))).

    { exploit IHHadd; eauto.

      intros (? & ? & ? & ?); eexists; rewrite in_app; split; eauto.

      eapply add_item_trace_mono, Forall2_Znth with (i2 := i) in Hadd0; auto.

      eexists; destruct Hadd0 as ((? & X) & _); rewrite X, in_app; eauto. }

    destruct Hadd0 as (? & ? & Hi & Hrest).

    destruct (eq_dec i0 i).

    + subst; destruct (Znth i h' ([], [])).

      destruct s.

      * destruct Hi as (Hi1 & Hi2 & _).

        apply add_events_add in Hi2; destruct Hi2 as (x & Happ & Hsnd); rewrite Happ, in_app in Hin.

        destruct Hin as [? | Hin]; [contradiction|].

        assert (In e (map snd x)) as Hin' by (rewrite in_map_iff; do 2 eexists; eauto; auto).

        rewrite Hsnd in Hin'; simpl in Hin'; decompose [or] Hin'; subst; try contradiction.

        simpl in Hval; assert (v0 = v) by (apply repr_inj_signed; auto; congruence).

        subst; eexists; rewrite in_app; simpl; split; eauto.

        eapply add_events_in in Hi1; [destruct Hi1 as (? & ? & ?); eauto | simpl; auto].

      * destruct Hi as (? & ? & ?); subst; contradiction.

    + exploit add_rest_hists; eauto; intros (? & Hi2 & ?); rewrite Hi2 in Hin; contradiction.

Qed.



Lemma writes_val : forall i e h v v', writes e v -> apply_hist i (h ++ [e]) = Some v' -> v' = v.

Proof.

  intros; rewrite apply_hist_app in *.

  destruct (apply_hist i h); [|discriminate].

  exploit apply_one_value; eauto.

  destruct e; simpl in *; try contradiction; subst; auto.

  destruct H; subst.

  rewrite eq_dec_refl; auto.

Qed.



Lemma apply_no_write : forall i h l v (Hl : hist_list' h l) (Hv : apply_hist i l = Some v)

  (Hh : Forall (fun p => ~writes (snd p) v) h), v = i /\ Forall (fun e => forall w, ~writes e w) l.

Proof.

  induction 1; simpl; intros.

  - inv Hv; auto.

  - assert (forall w, writes e w -> w = v) as Hwrite.

    { intros; symmetry; eapply writes_val; eauto. }

    rewrite apply_hist_app in Hv; destruct (apply_hist i l) eqn: Hv'; [|discriminate].

    subst; rewrite Forall_app in Hh; destruct Hh as (? & Hh); inv Hh.

    destruct (eq_dec v0 v).

    + subst; exploit IHHl; auto.

      { rewrite Forall_app; auto. }

      intros (? & ?); rewrite Forall_app; repeat constructor; auto.

      intros ? Hw; specialize (Hwrite _ Hw); subst; contradiction.

    + exploit change_implies_write; eauto; intros (? & [? | ?] & ?); subst; contradiction.

Qed.



Lemma one_CAS_succeeds : forall h v a t1 t2 b1 b2 (Hl : full_hist' h v) (Hin1 : In (t1, CAS a a b1) h)

  (Hin2 : In (t2, CAS a a b2) h) (Ha : Forall (fun p => ~writes (snd p) a) h),

  t1 = t2 /\ b1 = b2.

Proof.

  intros.

  destruct Hl as (l & Hl & Hv).

  revert dependent v; induction Hl; [contradiction|].

  subst; intros; rewrite !in_app in *; simpl in *.

  rewrite Forall_app in Ha; destruct Ha as (? & Ha); inv Ha.

  rewrite apply_hist_app in Hv.

  destruct (apply_hist (vint 0) l) eqn: Hv'; [|discriminate].

  destruct (in_dec (EqDec_prod _ _ _ _) (t1, CAS a a b1) (h1 ++ h2)),

    (in_dec (EqDec_prod _ _ _ _) (t2, CAS a a b2) (h1 ++ h2)); rewrite in_app in *.

  - eapply IHHl; eauto.

    rewrite Forall_app; auto.

  - destruct Hin2 as [? | [Heq | ?]]; try solve [contradiction n; auto]; inv Heq.

    simpl in Hv.

    destruct (eq_dec _ _); inv Hv.

    exploit apply_no_write; eauto.

    { rewrite Forall_app; auto. }

    intros (? & Hout); subst.

    assert (In (CAS (vint 0) (vint 0) b1) l) as Hin.

    { rewrite <- hist_list'_in; eauto.

      eexists; rewrite in_app; eauto. }

    rewrite Forall_forall in Hout; specialize (Hout _ Hin); simpl in Hout.

    exploit Hout; eauto; contradiction.

  - destruct Hin1 as [? | [Heq | ?]]; try solve [contradiction n; auto]; inv Heq.

    simpl in Hv.

    destruct (eq_dec _ _); inv Hv.

    exploit apply_no_write; eauto.

    { rewrite Forall_app; auto. }

    intros (? & Hout); subst.

    assert (In (CAS (vint 0) (vint 0) b2) l) as Hin.

    { rewrite <- hist_list'_in; eauto.

      eexists; rewrite in_app; eauto. }

    rewrite Forall_forall in Hout; specialize (Hout _ Hin); simpl in Hout.

    exploit Hout; eauto; contradiction.

  - destruct Hin1 as [? | [Heq | ?]]; try solve [contradiction n; auto]; inv Heq.

    destruct Hin2 as [? | [Heq | ?]]; try solve [contradiction n0; auto]; inv Heq; auto.

Qed.



Lemma timestamp_unique : forall (h : list hist) l t e1 e2 i1 i2 (Hl : hist_list' (concat h) l)

  (Ht1 : In (t, e1) (Znth i1 h [])) (Ht2 : In (t, e2) (Znth i2 h [])), i1 = i2.

Proof.

  intros.

  apply hist_list'_NoDup in Hl.

  exploit (Znth_inbounds i1 h).

  { intro X; rewrite X in Ht1; contradiction. }

  exploit (Znth_inbounds i2 h).

  { intro X; rewrite X in Ht2; contradiction. }

  intros.

  replace h with (sublist 0 i2 h ++ Znth i2 h [] :: sublist (i2 + 1) (Zlength h) h) in Ht1, Hl.

  rewrite concat_app in Hl; simpl in Hl; rewrite !map_app in Hl.

  exploit (Zlength_sublist 0 i2 h); try omega.

  rewrite Z.sub_0_r; intro Hsub.

  destruct (zlt i1 i2).

  - rewrite app_Znth1 in Ht1 by omega.

    rewrite app_assoc in Hl; apply NoDup_app in Hl; destruct Hl as (Hl & _).

    apply NoDup_app in Hl; destruct Hl as (_ & _ & Hl).

    exploit Hl; try contradiction.

    + rewrite in_map_iff; exists (t, e1); split; [reflexivity|].

      rewrite in_concat; do 2 eexists; eauto.

      apply Znth_In; omega.

    + simpl; rewrite in_map_iff; do 2 eexists; eauto; auto.

  - rewrite app_Znth2 in Ht1 by omega.

    rewrite Hsub in Ht1.

    destruct (eq_dec (i1 - i2) 0); [omega|].

    rewrite Znth_pos_cons in Ht1 by omega.

    apply NoDup_app in Hl; destruct Hl as (_ & Hl & _).

    apply NoDup_app in Hl; destruct Hl as (_ & _ & Hl).

    exploit Hl; try contradiction.

    + rewrite in_map_iff; exists (t, e2); split; [reflexivity | auto].

    + simpl; rewrite in_map_iff.

      exists (t, e1); split; auto.

      rewrite in_concat; do 2 eexists; eauto.

      apply Znth_In.

      rewrite Zlength_sublist; omega.

  - rewrite <- sublist_next, sublist_rejoin, sublist_same; auto; omega.

Qed.



Lemma add_items_Znth : forall h la h' j, add_items_trace h la h' -> 0 <= j < Zlength la ->

  exists h1 h2, let '(k, v, i, s) := Znth j la (0, 0, 0, false) in

    add_item_trace h1 k v i s h2 /\ hists_mono h h1 /\ hists_mono h2 h'.

Proof.

  induction 1; [rewrite Zlength_nil; omega | intros].

  rewrite Zlength_app, Zlength_cons, Zlength_nil in *.

  destruct (eq_dec j (Zlength la)).

  - subst; do 2 eexists; rewrite !app_Znth2, Zminus_diag, Znth_0_cons by omega.

    split; eauto; split; auto; eapply add_items_trace_mono; eauto.

  - destruct IHadd_items_trace as (h1 & h2 & IH); [omega | exists h1, h2].

    rewrite !app_Znth1 by omega.

    destruct (Znth j la (0, 0, 0, false)) as (((?, ?), ?), ?); destruct IH as (? & ? & ?).

    split; [|split]; auto.

    etransitivity; eauto; eapply add_item_trace_mono; eauto.

Qed.



Lemma one_add_succeeds : forall lr keys

  (Hadd : Forall (fun '(la, h) => add_items_trace empty_hists la h) lr)

  (Hfullk : Forall2 full_hist' (map fst (fold_right join_hists empty_hists (map snd lr))) (map (fun x => vint x) keys))

  (Hkeys : Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e)

    (map fst (fold_right join_hists empty_hists (map snd lr))) keys)

  (Hrepk : Forall repable_signed keys)

  (Hnzk : Forall (fun x => Forall (fun x => let '(k, _, _, _) := x in k <> 0 /\ repable_signed k) (fst x)) lr)

  k (Hin : In k (map fst (map fst (map fst (concat (map fst lr)))))),

  exists v i th t, In (k, v, i, true) (fst (Znth th lr ([], []))) /\

    In (t, CAS (vint 0) (vint 0) (vint k)) (fst (Znth i (snd (Znth th lr ([], []))) ([], []))).

Proof.

  intros.

  repeat (rewrite in_map_iff in Hin; destruct Hin as ((?, ?) & ? & Hin); simpl in *; subst).

  rewrite in_concat in Hin; destruct Hin as (? & Hin0 & Hin); subst.

  rewrite in_map_iff in Hin; destruct Hin as ((la, h) & ? & Hin); subst.

  assert (repable_signed k /\ vint k <> vint 0) as (? & ?).

  { rewrite Forall_forall in Hnzk; specialize (Hnzk _ Hin).

    rewrite Forall_forall in Hnzk; specialize (Hnzk _ Hin0); destruct Hnzk as (Hk & ?).

    split; auto; intro; contradiction Hk; apply repr_inj_signed; auto; congruence. }

  exploit add_items_empty_hist_length; eauto; intro.

  destruct (existsb (Z.eqb k) keys) eqn: Hk.

  - rewrite existsb_exists in Hk.

    destruct Hk as (? & Hin' & Heq); rewrite Z.eqb_eq in Heq; symmetry in Heq; subst.

    apply In_Znth with (d := 0) in Hin'; destruct Hin' as (i & ? & Hi).

    eapply Forall2_Znth with (i0 := i) in Hfullk; [|rewrite (mem_lemmas.Forall2_Zlength Hfullk), Zlength_map; auto].

    destruct Hfullk as (l & Hl & Hv); rewrite Znth_map', Hi in Hv.

    rewrite Znth_map', Znth_join_hists in Hl by auto; simpl in Hl.

    apply change_implies_write in Hv; auto.

    destruct Hv as (w & Hinw & Hw).

    rewrite <- hist_list'_in in Hinw by eauto.

    destruct Hinw as (t & Hinw).

    rewrite in_concat in Hinw; destruct Hinw as (h' & Hinw & Hin2).

    repeat (rewrite in_map_iff in Hin2; destruct Hin2 as (? & ? & Hin2); subst).

    rewrite Forall_forall in Hadd; specialize (Hadd _ Hin2).

    destruct x as (la2, h2).

    exploit add_key_success; try apply Hadd; eauto.

    { rewrite Forall_forall in Hnzk; apply (Hnzk (la2, h2)); auto. }

    intros (k & ? & ? & ? & ? & ?); subst.

    assert (Znth i keys 0 = k).

    { apply repr_inj_signed; auto; congruence. }

    eapply In_Znth in Hin2; destruct Hin2 as (? & ? & Heq).

    subst; do 5 eexists; rewrite Heq; eauto.

  - rewrite Forall_forall in Hadd; specialize (Hadd _ Hin).

    eapply In_Znth in Hin0; destruct Hin0 as (j & ? & Hj).

    apply add_items_Znth with (j := j) in Hadd; auto.

    destruct Hadd as (h1 & h2 & Hadd); rewrite Hj in Hadd.

    destruct Hadd as ((? & ? & Hi & _) & Hh1 & Hh).

    assert (exists t e, In (t, e) (fst (Znth z h2 ([], []))) /\ value_of e = vint k) as (t & e & ? & He).

    { destruct (Znth z h1 ([], [])), b.

      + destruct Hi as (Hi1 & ? & ?); eapply add_events_in in Hi1; [|simpl; eauto].

        destruct Hi1 as (? & ? & ?); eauto.

      + destruct Hi as ([Hi1 | Hi1] & ? & ?); eapply add_events_in in Hi1; simpl; eauto;

          destruct Hi1 as (? & ? & ?); eauto. }

    clear Hi.

    assert (Zlength h1 = size) by (rewrite <- (mem_lemmas.Forall2_Zlength Hh1), Zlength_empty; auto).

    eapply Forall2_Znth with (i := z)(d2 := 0) in Hkeys;

      [|rewrite Zlength_map, join_hists_empty_length by auto; omega].

    rewrite Znth_map', Znth_join_hists in Hkeys by auto; simpl in Hkeys.

    exploit (Hkeys t e).

    { eapply Forall2_Znth with (i := z) in Hh; [|omega].

      rewrite in_concat; do 2 eexists; [|repeat (rewrite in_map_iff; do 2 eexists; eauto)].

      simpl; destruct Hh as ((? & ->) & _).

      rewrite in_app; eauto. }

    { intro X; rewrite X in He.

      absurd (vint k = vint 0); auto. }

    intro X; rewrite <- X in He.

    assert (Zlength keys = size).

    { erewrite <- Zlength_map, <- (mem_lemmas.Forall2_Zlength Hfullk), Zlength_map, join_hists_empty_length

        by auto; omega. }

    exploit existsb_nth; eauto.

    { apply Nat2Z.inj_lt; rewrite Z2Nat.id, <- Zlength_correct.

      instantiate (1 := z); omega.

      { tauto. } }

    rewrite nth_Znth with (d := 0), Z2Nat.id, Z.eqb_neq by tauto; intro Hn; contradiction Hn.

    apply repr_inj_signed; auto.

    { apply Forall_Znth; auto; omega. }

    congruence.

Qed.



Lemma only_one_add_succeeds : forall lr keys th1 th2 k v1 v2 i1 i2

  (Hadd : Forall (fun '(la, h) => add_items_trace empty_hists la h) lr)

  (Hfullk : Forall2 full_hist' (map fst (fold_right join_hists empty_hists (map snd lr))) (map (fun x => vint x) keys))

  (Hkeys : Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e)

    (map fst (fold_right join_hists empty_hists (map snd lr))) keys)

  (Hrepk : Forall repable_signed keys)

  (Hnzk : Forall (fun x => Forall (fun x => let '(k, _, _, _) := x in k <> 0 /\ repable_signed k) (fst x)) lr)

  (Hsucc1 : In (k, v1, i1, true) (fst (Znth th1 lr ([], []))))

  (Hsucc2 : In (k, v2, i2, true) (fst (Znth th2 lr ([], [])))),

  th1 = th2 /\ i1 = i2.

Proof.

  intros.

  assert (0 <= th1 < Zlength lr) as Hth1.

  { exploit (Znth_inbounds th1 lr ([], [])); auto.

    intro X; rewrite X in Hsucc1; contradiction. }

  assert (0 <= th2 < Zlength lr) as Hth2.

  { exploit (Znth_inbounds th2 lr ([], [])); auto.

    intro X; rewrite X in Hsucc2; contradiction. }

  pose proof (Forall_Znth _ _ _ ([], []) Hth1 Hadd) as Hadd1.

  pose proof (Forall_Znth _ _ _ ([], []) Hth2 Hadd) as Hadd2.

  destruct (Znth th1 lr ([], [])) as (la1, h1) eqn: Hr1,

           (Znth th2 lr ([], [])) as (la2, h2) eqn: Hr2; simpl in *.

  eapply In_Znth in Hsucc1; destruct Hsucc1 as (j1 & ? & Hj1).

  apply add_items_Znth with (j := j1) in Hadd1; auto.

  destruct Hadd1 as (ha1 & hb1 & Hadd1); rewrite Hj1 in Hadd1.

  destruct Hadd1 as ((? & ? & Hi1 & Hrest1) & Hha1 & Hhb1).

  eapply In_Znth in Hsucc2; destruct Hsucc2 as (j2 & ? & Hj2).

  apply add_items_Znth with (j := j2) in Hadd2; auto.

  destruct Hadd2 as (ha2 & hb2 & Hadd2); rewrite Hj2 in Hadd2.

  destruct Hadd2 as ((? & ? & Hi2 & Hrest2) & Hha2 & Hhb2).

  exploit add_items_empty_hist_length; eauto; intro.

  assert (Zlength ha1 = size) by (rewrite <- (mem_lemmas.Forall2_Zlength Hha1), Zlength_empty; auto).

  assert (Zlength ha2 = size) by (rewrite <- (mem_lemmas.Forall2_Zlength Hha2), Zlength_empty; auto).

  destruct (Znth i1 ha1 ([], [])) eqn: Hh1, (Znth i2 ha2 ([], [])) eqn: Hh2.

  destruct Hi1 as (Hi1 & _ & Hzero1).

  destruct Hi2 as (Hi2 & _ & Hzero2).

  eapply add_events_in in Hi1; [|simpl; eauto].

  destruct Hi1 as (t1 & ? & ?).

  eapply add_events_in in Hi2; [|simpl; eauto].

  destruct Hi2 as (t2 & ? & ?).

  assert (In (t1, CAS (vint 0) (vint 0) (vint k)) (fst (Znth i1 h1 ([], [])))).

  { eapply Forall2_Znth with (i := i1) in Hhb1; [|omega].

    destruct Hhb1 as ((? & ->) & _); rewrite in_app; eauto. }

  assert (In (t2, CAS (vint 0) (vint 0) (vint k)) (fst (Znth i2 h2 ([], [])))).

  { eapply Forall2_Znth with (i := i2) in Hhb2; [|omega].

    destruct Hhb2 as ((? & ->) & _); rewrite in_app; eauto. }

  assert (In h1 (map snd lr)) by (rewrite in_map_iff; do 2 eexists; [|apply Znth_In]; [rewrite Hr1|]; auto).

  assert (In h2 (map snd lr)) by (rewrite in_map_iff; do 2 eexists; [|apply Znth_In]; [rewrite Hr2|]; auto).

  destruct (eq_dec i1 i2).

  - split; auto.

    eapply Forall2_Znth with (i := i1) in Hfullk;

      [|rewrite Zlength_map, join_hists_empty_length by auto; omega].

    rewrite !Znth_map', Znth_join_hists in Hfullk by auto; simpl in Hfullk.

    instantiate (1 := 0) in Hfullk.

    exploit one_CAS_succeeds; eauto.

    { rewrite in_concat; exists (fst (Znth i1 h1 ([], []))); split; eauto.

      do 2 (rewrite in_map_iff; do 2 eexists; eauto). }

    { subst; rewrite in_concat; do 2 eexists; eauto.

      do 2 (rewrite in_map_iff; do 2 eexists; eauto). }

    { rewrite Forall_forall; intros (?, ?) Hink.

      rewrite in_concat in Hink; destruct Hink as (? & ? & Hink); subst.

      do 2 (rewrite in_map_iff in Hink; destruct Hink as (? & ? & Hink); subst).

      rewrite in_map_iff in Hink; destruct Hink as ((?, ?) & ? & Hink); subst.

      rewrite Forall_forall in Hadd; specialize (Hadd _ Hink); simpl in Hadd.

      rewrite Forall_forall in Hnzk; specialize (Hnzk _ Hink).

      intro; exploit add_key_success; try apply Hadd; eauto.

      intros (k'' & ? & Hin' & ? & ? & ?); rewrite Forall_forall in Hnzk; specialize (Hnzk _ Hin').

      destruct Hnzk; absurd (k'' = 0); auto; apply repr_inj_signed; auto; congruence. }

    intros (? & ?); subst.

    destruct Hfullk as (? & ? & ?).

    eapply timestamp_unique; eauto.

    + erewrite Znth_map, !Znth_map', Hr1 by (rewrite !Zlength_map; auto); eauto.

    + erewrite Znth_map, !Znth_map', Hr2 by (rewrite !Zlength_map; auto); eauto.

  - set (i' := if zlt ((i1 - hash k) mod size) ((i2 - hash k) mod size) then i1 else i2).

    assert (0 <= i' < size) by (destruct (zlt _ _); subst i'; omega).

    assert (Zlength keys = size).

    { erewrite <- Zlength_map, <- (mem_lemmas.Forall2_Zlength Hfullk), Zlength_map, join_hists_empty_length;

        auto. }

    assert (Znth i' keys 0 = k); [|assert (exists k', Znth i' keys 0 = k' /\ k' <> k) as (? & ? & ?); [|omega]].

    + eapply Forall2_Znth with (i := i')(d2 := 0) in Hkeys.

      assert (exists t' h', In (t', CAS (vint 0) (vint 0) (vint k)) (fst (Znth i' h' ([], []))) /\

        In h' (map snd lr)) as (t' & h' & Hin & Hh').

      { destruct (zlt _ _); do 3 eexists; eauto. }

      assert (repable_signed k /\ vint k <> vint 0) as (? & ?).

      { eapply Forall_Znth with (i := th1) in Hnzk; auto.

        rewrite Hr1 in Hnzk; simpl in Hnzk.

        eapply Forall_Znth with (i := j1) in Hnzk; auto.

        rewrite Hj1 in Hnzk; destruct Hnzk as (Hz & ?); split; auto.

        intro; contradiction Hz; apply repr_inj_signed; auto; congruence. }

      exploit Hkeys.

      { rewrite Znth_map', Znth_join_hists by auto; simpl.

        rewrite in_concat; do 2 eexists; eauto.

        repeat (rewrite in_map_iff; do 2 eexists; eauto). }

      { auto. }

      simpl; intro; apply repr_inj_signed; auto.

      { apply Forall_Znth; auto; omega. }

      congruence.

      { rewrite Zlength_map, join_hists_empty_length; auto. }

    + set (j' := if zlt ((i1 - hash k) mod size) ((i2 - hash k) mod size) then i2 else i1).

      assert (exists ha hb h', Zlength hb = size /\ hists_mono hb h' /\ In h' (map snd lr) /\ forall j,

        In j (indices (hash k) j') -> failed_CAS k (Znth j ha ([], [])) (Znth j hb ([], [])))

        as (ha & hb & h' & ? & Hh' & Hin' & Hrest).

      { destruct (zlt _ _); subst i'; [exists ha2, hb2, h2 | exists ha1, hb1, h1];

          repeat split; auto; try omega; intro; [apply Hrest2 | apply Hrest1]. }

      specialize (Hrest i'); destruct Hrest as (r & ? & Hi & ? & ? & ? & ?).

      { unfold indices; rewrite in_map_iff.

        exists ((i' - hash k) mod size); split.

        { rewrite Zplus_mod_idemp_r, Zplus_minus, Zmod_small; auto. }

        rewrite In_upto, Z2Nat.id by (apply Z_mod_lt, size_pos).

        destruct (zlt _ _); subst i' j'; split; try (apply Z_mod_lt, size_pos); try tauto.

        destruct (eq_dec ((i1 - hash k) mod size) ((i2 - hash k) mod size)); try omega.

        apply Zmod_plus_inv in e; [|apply size_pos].

        rewrite !Zmod_small in e; omega. }

      assert (exists t e, In (t, e) (fst (Znth i' hb ([], []))) /\ value_of e = vint r) as (? & ? & ? & ?).

      { destruct Hi as [Hi | Hi]; eapply add_events_in in Hi; simpl; eauto; destruct Hi as (? & ? & ?); eauto. }

      eapply Forall2_Znth with (i := i')(d2 := 0) in Hkeys.

      exploit Hkeys.

      { rewrite Znth_map', Znth_join_hists by auto; simpl.

        rewrite in_concat; exists (fst (Znth i' h' ([], []))); split.

        { eapply Forall2_Znth with (i := i') in Hh'; [|omega].

          destruct Hh' as ((? & ->) & _); rewrite in_app; eauto. }

        repeat (rewrite in_map_iff; do 2 eexists; eauto). }

      { intro; absurd (r = 0); auto; apply repr_inj_signed; auto; congruence. }

      intro; assert (Znth i' keys 0 = r); [|eauto].

      apply repr_inj_signed; auto.

      { apply Forall_Znth; auto; omega. }

      congruence.

      { rewrite Zlength_map, join_hists_empty_length; auto. }

Qed.



Transparent Znth.



Lemma add_three : forall lr lk lv (Hlen : Zlength lr = 3)

  (Hadd : Forall (fun '(h, li, ls) => add_items_trace (repeat ([], []) (Z.to_nat size))

     (combine (combine (combine [1; 2; 3] [1; 1; 1]) li) ls) h) lr)

  (H3 : Forall (fun '(_, li, ls) => Zlength li = 3 /\ Zlength ls = 3) lr)

  (Hrepk : Forall repable_signed lk) (Hrepv : Forall repable_signed lv)

  (Hfullk : Forall2 full_hist (map fst (fold_right join_hists empty_hists (map fst (map fst lr)))) lk)

  (Hfullv : Forall2 full_hist (map snd (fold_right join_hists empty_hists (map fst (map fst lr)))) lv)

  (Hvalk : Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e)

     (map fst (fold_right join_hists empty_hists (map fst (map fst lr)))) lk),

  Zlength (filter id (concat (map snd lr))) = 3.

Proof.

  intros; set (lr' := map (fun '(h, li, ls) => (combine (combine (combine [1; 2; 3] [1; 1; 1]) li) ls, h)) lr).

  assert (map snd lr' = map fst (map fst lr)) as Hlr.

  { subst lr'; rewrite !map_map; apply map_ext.

    intros ((?, ?), ?); auto. }

  assert (Forall (fun '(la, h) => add_items_trace empty_hists la h) lr') as Hadd'.

  { subst lr'; rewrite Forall_map;

      match goal with H : Forall _ lr |- _ => eapply Forall_impl; [|apply H];

        intros ((?, ?), ?); solve [auto] end. }

  assert (Forall2 full_hist' (map fst (fold_right join_hists empty_hists

    (map snd lr'))) (map (fun x => vint x) lk)) as Hfullk'.

  { rewrite Hlr; eapply Forall2_map2, Forall2_impl; [intros; apply full_hist_weak; eauto | auto]. }

  assert (Forall2 (fun h v => forall t e, In (t, e) h -> value_of e <> vint 0 -> vint v = value_of e)

    (map fst (fold_right join_hists empty_hists (map snd lr'))) lk) as Hkeys.

  { rewrite Hlr; auto. }

  assert (Forall (fun x => Forall (fun '(k, _, _, _) => k <> 0 /\ repable_signed k) (fst x)) lr') as Hnzk.

  { subst lr'.

    rewrite Forall_forall; intros ? Hin.

    rewrite in_map_iff in Hin; destruct Hin as (((?, ?), ?) & ? & Hin); subst.

    rewrite Forall_forall; intros (((?, ?), ?), ?) Hin'.

    do 3 apply in_combine_l in Hin'.

    destruct Hin' as [? | [? | [? | ?]]]; try contradiction; subst; repeat split; computable. }

  pose proof (one_add_succeeds _ _ Hadd' Hfullk' Hkeys Hrepk Hnzk) as Hone.

  assert (incl [1; 2; 3] (map fst (map fst (map fst (concat (map fst lr')))))) as Hks.

  { intros a Ha.

    subst lr'; destruct lr as [|((?, li), ls)]; [rewrite Zlength_nil in *; discriminate|]; simpl.

    repeat match goal with H : Forall _ (_ :: _) |- _ => inv H end.

    match goal with H : _ /\ _ |- _ => destruct H end.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    rewrite !Zlength_cons in *.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    rewrite !Zlength_cons in *.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    destruct Ha as [? | [? | [? | ?]]]; auto; contradiction. }

  rewrite !incl_cons_iff in Hks; destruct Hks as (Hk1 & Hk2 & Hk3 & _).

  generalize (Hone _ Hk1), (Hone _ Hk2), (Hone _ Hk3).

  intros (? & ? & th1 & ? & Hin1 & ?) (? & ? & th2 & ? & Hin2 & ?) (? & ? & th3 & ? & Hin3 & ?).

  assert (forall th, 0 <= th < Zlength lr -> Znth th lr' ([], []) = (map (fun j => (j + 1, 1,

    Znth j (snd (fst (Znth th lr ([], [], [])))) 0, Znth j (snd (Znth th lr ([], [], []))) false)) (upto 3),

    fst (fst (Znth th lr ([], [], []))))) as Hnth'.

  { subst lr'; intros.

    rewrite Znth_map with (d' := ([], [], [])) by auto.

    repeat match goal with H : Forall _ lr |- _ => eapply Forall_Znth with (i := th)(d := ([], [], [])) in H;

      [|auto] end.

    destruct (Znth th lr ([], [], [])) as ((h, li), ls) eqn: Hth.

    match goal with H : Zlength li = _ /\ _ |- _ => destruct H as (Hli & Hls) end.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    rewrite !Zlength_cons in *.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    rewrite !Zlength_cons in *.

    destruct li; [rewrite Zlength_nil in *; discriminate|].

    destruct ls; [rewrite Zlength_nil in *; discriminate | simpl].

    change (upto 3) with [0; 1; 2]; auto. }

  assert (Zlength lr' = Zlength lr) as Hlenr.

  { clear; subst lr'; rewrite Zlength_map; auto. }

  assert (0 <= th1 < Zlength lr).

  { rewrite <- Hlenr; apply Znth_inbounds with (d := ([], [])); intro X; rewrite X in Hin1; contradiction. }

  assert (0 <= th2 < Zlength lr).

  { rewrite <- Hlenr; apply Znth_inbounds with (d := ([], [])); intro X; rewrite X in Hin2; contradiction. }

  assert (0 <= th3 < Zlength lr).

  { rewrite <- Hlenr; apply Znth_inbounds with (d := ([], [])); intro X; rewrite X in Hin3; contradiction. }

  assert (forall th, 0 <= th < Zlength lr -> Zlength (fst (Znth th lr' ([], []))) = 3) as Hli.

  { intros; rewrite Hnth' by auto; simpl.

    rewrite Zlength_map; auto. }

  destruct (In_Znth _ _ (0, 0, 0, false) Hin1) as (j1 & ? & Hnth1).

  rewrite Hnth' in Hnth1 by auto; simpl in Hnth1.

  destruct (In_Znth _ _ (0, 0, 0, false) Hin2) as (j2 & ? & Hnth2).

  rewrite Hnth' in Hnth2 by auto; simpl in Hnth2.

  destruct (In_Znth _ _ (0, 0, 0, false) Hin3) as (j3 & ? & Hnth3).

  rewrite Hnth' in Hnth3 by auto; simpl in Hnth3.

  rewrite Hli in * by auto.

  erewrite Znth_map, Znth_upto in Hnth1, Hnth2, Hnth3 by (auto; simpl; omega).

  inv Hnth1; inv Hnth2; inv Hnth3.

  assert (j1 = 0) by omega; subst.

  assert (j2 = 1) by omega; subst.

  assert (j3 = 2) by omega; subst.

  assert (forall th, 0 <= th < Zlength lr -> Znth 0 (snd (Znth th lr ([], [], []))) false = true -> th = th1) as Hth1.

  { intros ?? Hsucc.

    exploit (only_one_add_succeeds lr' lk th th1); eauto; [|tauto].

    rewrite Hnth' by auto; simpl.

    rewrite in_map_iff; do 2 eexists; [rewrite Hsucc; eauto|].

    rewrite In_upto; simpl; computable. }

  assert (forall th, 0 <= th < Zlength lr -> Znth 1 (snd (Znth th lr ([], [], []))) false = true -> th = th2) as Hth2.

  { intros ?? Hsucc.

    exploit (only_one_add_succeeds lr' lk th th2); eauto; [|tauto].

    rewrite Hnth' by auto; simpl.

    rewrite in_map_iff; do 2 eexists; [rewrite Hsucc; eauto|].

    rewrite In_upto; simpl; computable. }

  assert (forall th, 0 <= th < Zlength lr -> Znth 2 (snd (Znth th lr ([], [], []))) false = true -> th = th3) as Hth3.

  { intros ?? Hsucc.

    exploit (only_one_add_succeeds lr' lk th th3); eauto; [|tauto].

    rewrite Hnth' by auto; simpl.

    rewrite in_map_iff; do 2 eexists; [rewrite Hsucc; eauto|].

    rewrite In_upto; simpl; computable. }

  assert (forall th, 0 <= th < Zlength lr -> Zlength (filter id (Znth th (map snd lr) [])) =

    (if eq_dec th th1 then 1 else 0) + (if eq_dec th th2 then 1 else 0) + (if eq_dec th th3 then 1 else 0)) as Hls.

  { intros ? Hth.

    specialize (Hth1 _ Hth); specialize (Hth2 _ Hth); specialize (Hth3 _ Hth).

    rewrite Znth_map with (d' := ([], [], [])) by auto.

    repeat match goal with H : Forall _ lr |- _ => eapply Forall_Znth with (i := th)(d := ([], [], [])) in H; [|auto] end.

    destruct (Znth th lr ([], [], [])) as ((h, li), ls) eqn: Hnth.

    match goal with H : Zlength _ = _ /\ _ |- _ => destruct H as (? & Hls) end.

    simpl; replace ls with [if eq_dec th th1 then true else false; if eq_dec th th2 then true else false; if eq_dec th th3 then true else false].

    { repeat if_tac; simpl; auto. }

    destruct ls; [rewrite Zlength_nil in Hls; discriminate | simpl; rewrite Zlength_cons in Hls].

    destruct ls; [rewrite Zlength_nil in Hls; discriminate | simpl; rewrite Zlength_cons in Hls].

    destruct ls; [rewrite Zlength_nil in Hls; discriminate | simpl; rewrite Zlength_cons in Hls].

    destruct ls; [|rewrite Zlength_cons in Hls; pose proof (Zlength_nonneg ls); omega].

    simpl in *; f_equal; [|f_equal].

    - destruct (eq_dec _ _); [subst; rewrite Hnth in *; simpl in *; auto|].

      destruct b; auto; contradiction.

    - destruct (eq_dec _ _); [subst; rewrite Hnth in *; simpl in *; auto|].

      destruct b0; auto; contradiction.

    - f_equal; destruct (eq_dec _ _); [subst; rewrite Hnth in *; simpl in *; auto|].

      destruct b1; auto; contradiction. }

  destruct lr as [|((?, ?), ls1)]; [rewrite Zlength_nil in *; discriminate|]; simpl in *.

  rewrite Zlength_cons in *; destruct lr as [|((?, ?), ls2)]; [rewrite Zlength_nil in *; discriminate|]; simpl in *.

  rewrite Zlength_cons in *; destruct lr as [|((?, ?), ls3)]; [rewrite Zlength_nil in *; discriminate|]; simpl in *.

  rewrite Zlength_cons in *; destruct lr; [|rewrite Zlength_cons in *; pose proof (Zlength_nonneg lr); omega].

  rewrite app_nil_r, !filter_app, !Zlength_app.

  generalize (Hls 0), (Hls 1), (Hls 2); unfold Znth; simpl.

  intros -> -> ->; auto.

  assert (forall i, 0 <= i < 3 ->

    (if eq_dec 0 i then 1 else 0) + (if eq_dec 1 i then 1 else 0) + (if eq_dec 2 i then 1 else 0) = 1) as Hsum.

  { intros; do 3 if_tac; omega. }

  rewrite Zlength_nil in *; simpl in *.

  generalize (Hsum th1), (Hsum th2), (Hsum th3); omega.

Qed.



Opaque combine.



Lemma body_main : semax_body Vprog Gprog f_main main_spec.

Proof.

  name m_entries _m_entries.

  name locksp _thread_locks.

  name resp _results.

  name keys _keys.

  name values _values.

  start_function.

  forward.

  forward_call m_entries.

  Intros x; destruct x as (entries, ghosts); simpl in *.

  destruct (split_shares 3 Ews) as (sh0 & shs & ? & ? & ? & Hshs); auto.

  rewrite <- seq_assoc.

  destruct (split_readable_share Tsh) as (sh1 & sh2 & ? & ? & ?); auto.

  forward_for_simple_bound 3 (EX i : Z, PROP ()

    LOCAL (temp _total (vint 0); lvar _values (tarray tint 16384) values;

           lvar _keys (tarray tint 16384) keys; gvar _results resp;

           gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs Ews (tarray tentry size) entries m_entries;

         atomic_entries Tsh entries ghosts empty_hists;

         data_at_ Tsh (tarray tint 16384) values; data_at_ Tsh (tarray tint 16384) keys;

         EX res : list val, !!(Zlength res = i) &&

           data_at Ews (tarray (tptr tint) 3) (res ++ repeat Vundef (Z.to_nat (3 - i))) resp *

           fold_right sepcon emp (map (data_at_ Tsh tint) res) *

           fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) res) *

         EX locks : list val, !!(Zlength locks = i) &&

           data_at Ews (tarray (tptr (Tstruct _lock_t noattr)) 3)

             (locks ++ repeat Vundef (Z.to_nat (3 - i))) locksp *

           fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) locks) *

           fold_right sepcon emp (map (fun j => lock_inv Tsh (Znth j locks Vundef)

             (f_lock_pred sh2 (Znth j shs Ews) entries ghosts m_entries j locksp (Znth j locks Vundef)

              resp (Znth j res Vundef))) (upto (Z.to_nat i))))).

  { Exists (@nil val) (@nil val); go_lower; entailer'. }

  { 

    Intros res locks.

    forward_call (sizeof (Tstruct _lock_t noattr)).

    { simpl; computable. }

    Intro l.

    rewrite malloc_compat by (auto; exists 2; auto); Intros.

    rewrite memory_block_data_at_ by auto.

    forward.

    forward_call (sizeof tint).

    { simpl; computable. }

    Intro r.

    rewrite malloc_compat by (auto; exists 2; auto); Intros.

    rewrite memory_block_data_at_ by auto.

    forward.

    focus_SEP 3.

    forward_call (l, Tsh, f_lock_pred sh2 (Znth i shs Ews) entries ghosts m_entries i locksp l resp r).

    { entailer!.

      destruct l; try contradiction; auto. }

    { apply sepcon_derives; [apply lock_struct | cancel_frame]. }

    Exists (res ++ [r]) (locks ++ [l]); rewrite !Zlength_app, !Zlength_cons, !Zlength_nil.

    go_lower; entailer'.

    rewrite lock_inv_isptr, data_at__isptr; Intros.

    rewrite Z2Nat.inj_add, upto_app, !map_app, !sepcon_app by omega.

    simpl; change (upto 1) with [0]; simpl.

    rewrite Z2Nat.id, Z.add_0_r by omega.

    replace (Zlength res + 1) with (Zlength (res ++ [r]))

      by (rewrite Zlength_app, Zlength_cons, Zlength_nil; auto).

    rewrite <- upd_complete_gen by omega.

    replace (Zlength (res ++ [r])) with (Zlength (locks ++ [l]))

      by (rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; auto; omega).

    rewrite <- upd_complete_gen by omega.

    rewrite !app_Znth2 by omega.

    replace (Zlength locks) with (Zlength res); rewrite Zminus_diag, !Znth_0_cons.

    rewrite <- !sepcon_assoc, (sepcon_comm _ (@data_at CompSpecs Ews (tarray tentry size) entries m_entries)),

      !sepcon_assoc; apply sepcon_derives; [auto|].

    rewrite <- !sepcon_assoc, (sepcon_comm _ (atomic_entries Tsh entries ghosts empty_hists)), !sepcon_assoc;

      apply sepcon_derives; [auto|].

    rewrite ?sepcon_emp, ?emp_sepcon; rewrite ?sepcon_assoc.

    rewrite <- !sepcon_assoc.

    match goal with |- _ |-- ?P * ?Q => rewrite (sepcon_comm P Q) end.

    rewrite !sepcon_assoc; apply sepcon_derives; [auto|].

    rewrite <- 2sepcon_assoc, sepcon_comm, !sepcon_assoc.

    destruct r; try contradiction.

    destruct l; try contradiction.

    cancel.

    apply sepcon_list_derives; rewrite !Zlength_map, !Zlength_upto, <- Zlength_correct.

    { rewrite Z2Nat.id; auto; omega. }

    intros.

    erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, <- ?Zlength_correct, ?Z2Nat.id; auto; omega).

    rewrite !app_Znth1 by omega; auto. }

  Intros res locks.

  rewrite !app_nil_r.

  assert_PROP (Zlength entries = size) by entailer!.

  rewrite <- seq_assoc.

  forward_for_simple_bound 3 (EX i : Z, EX sh : share,

    PROP (sepalg_list.list_join sh0 (sublist i 3 shs) sh)

    LOCAL (temp _total (vint 0); lvar _values (tarray tint 16384) values;

           lvar _keys (tarray tint 16384) keys; gvar _results resp;

           gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs sh (tarray tentry size) entries m_entries;

         EX sh' : share, !!(sepalg.join sh (Share.comp Ews) sh') && atomic_entries sh' entries ghosts empty_hists;

         data_at_ Tsh (tarray tint 16384) values; data_at_ Tsh (tarray tint 16384) keys;

         data_at sh (tarray (tptr tint) 3) res resp;

         fold_right sepcon emp (map (data_at_ Tsh tint) (sublist i 3 res));

         fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) res);

         data_at sh (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) locks);

         fold_right sepcon emp (map (fun j => lock_inv (if zlt j i then sh1 else Tsh) (Znth j locks Vundef)

           (f_lock_pred sh2 (Znth j shs Ews) entries ghosts m_entries j locksp (Znth j locks Vundef)

           resp (Znth j res Vundef))) (upto 3)))).

  { rewrite !sublist_same by auto; Exists Ews Tsh; go_lower; entailer'.

    apply prop_right, comp_join_top. }

  { 

    forward_call (sizeof tint).

    { simpl; computable. }

    Intros t sh'.

    rewrite malloc_compat by (auto; exists 2; auto); Intros.

    rewrite memory_block_data_at_ by auto.

    forward.

    simpl in *; assert (3 <= Zlength shs) by omega.

    match goal with H : sepalg_list.list_join sh0 _ _ |- _ => rewrite sublist_next with (d := Ews) in H by auto;

      inversion H as [|????? Hj1 Hj2]; subst end.

    apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (sh3 & ? & Hj3).

    destruct (sepalg.join_assoc(c := Share.comp Ews)(e := sh') Hj3) as (sh3' & ? & Hj3'); auto.

    get_global_function'' _f; Intros.

    apply extract_exists_pre; intros f_.

    forward_spawn (share * share * list (val * val) * list (val * val) * val * Z * val * val * val * val)%type

      (f_, t, (Znth i shs Ews, sh2, entries, ghosts, m_entries, i, locksp, Znth i locks Vundef, resp,

               Znth i res Vundef),

    fun (x : (share * share * list (val * val) * list (val * val) * val * Z * val * val * val * val)%type)

        (tid : val) =>

    let '(sh, tsh, entries, ghosts, p, t, locksp, lockt, resultsp, res) := x in

    fold_right sepcon emp

      [!!(0 <= t < 3 /\ isptr lockt /\ readable_share sh /\ readable_share tsh /\ Zlength ghosts = size) && emp;

        data_at sh (tarray tentry size) entries p; atomic_entries sh entries ghosts empty_hists;

        data_at Tsh tint (vint t) tid; malloc_token Tsh (sizeof tint) tid;

        data_at sh (tarray (tptr tlock) 3) (upd_Znth t (repeat Vundef 3) lockt) locksp;

        data_at sh (tarray (tptr tint) 3) (upd_Znth t (repeat Vundef 3) res) resultsp;

        data_at_ Tsh tint res;

        lock_inv tsh lockt (f_lock_pred tsh sh entries ghosts p t locksp lockt resultsp res)]).

    { unfold spawn_pre; go_lower.

      Exists _arg (fun x : (share * share * list (val * val) * list (val * val) * val * Z * val * val * val * val) =>

        let '(sh, tsh, entries, ghosts, p, t, locksp, lockt, resultsp, res) := x in

        [(_m_entries, p); (_thread_locks, locksp); (_results, resultsp)]).

      rewrite !sepcon_andp_prop, !sepcon_andp_prop'.

      repeat (apply andp_right; [apply prop_right; repeat split; auto|]).

      { rewrite sem_cast_neutral_ptr; rewrite sem_cast_neutral_ptr; auto. }

      rewrite !sepcon_assoc; apply sepcon_derives.

      { apply derives_refl'.

        f_equal; f_equal; extensionality.

        destruct x0 as (?, x0); repeat destruct x0 as (x0, ?); simpl.

        extensionality; apply mpred_ext; entailer!. }

      rewrite (extract_nth_sepcon (map _ (upto 3)) i) by (rewrite Zlength_map; auto).

      erewrite Znth_map, Znth_upto by (auto; simpl; omega).

      destruct (zlt i i); [omega|].

      rewrite lock_inv_isptr; Intros.

      assert (0 <= i < Zlength shs) by omega.

      apply andp_right.

      - apply prop_right; split; [omega|]; split; [omega|]; split; auto; split; auto.

        apply Forall_Znth; auto.

      - rewrite <- !(data_at_share_join _ _ _ _ _ _ Hj3).

        rewrite <- (atomic_entries_join_nil _ _ _ _ _ Hj3'); auto.

        rewrite <- (lock_inv_share_join sh1 sh2) by auto.

        rewrite emp_sepcon, <- !sepcon_assoc, (sepcon_comm _ (data_at (Znth i shs Ews) _ _ m_entries)),

          !sepcon_assoc; apply sepcon_derives; [apply derives_refl|].

        fast_cancel.

        rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at (Znth i shs Ews) _ _ locksp)),

          !sepcon_assoc; apply sepcon_derives.

        { rewrite lock_struct_array; apply stronger_array_ext.

          - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.

          - intros j ???; unfold unfold_reptype; simpl.

            destruct (eq_dec j i).

            + subst; rewrite upd_Znth_same; auto.

            + rewrite upd_Znth_diff by auto.

              rewrite Znth_repeat with (x1 := Vundef)(n0 := 3%nat); apply stronger_default_val. }

        rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at (Znth i shs Ews) _ _ resp)),

          !sepcon_assoc; apply sepcon_derives.

        { apply stronger_array_ext.

          - unfold unfold_reptype; simpl; rewrite upd_Znth_Zlength; auto.

          - intros j ???; unfold unfold_reptype; simpl.

            destruct (eq_dec j i).

            + subst; rewrite upd_Znth_same; auto.

            + rewrite upd_Znth_diff' by auto.

              rewrite Znth_repeat with (x1 := Vundef)(n0 := 3%nat); apply stronger_default_val. }

        erewrite sublist_next by (auto; omega); simpl; fast_cancel.

        { apply Forall_Znth; auto. }

        { eapply join_readable1, readable_share_list_join; eauto. } }

    go_lower.

    Exists sh3 sh3'; entailer'.

    fast_cancel.

    rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto.

    intros j ?; destruct (eq_dec j i).

    - subst; rewrite upd_Znth_same by auto.

      erewrite Znth_map, Znth_upto by (auto; simpl; omega).

      if_tac; [auto | omega].

    - rewrite upd_Znth_diff' by auto.

      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).

      if_tac; if_tac; auto; omega. }

  Intros sh sh'.

  rewrite sublist_nil, <- seq_assoc.

  forward_for_simple_bound 3 (EX i : Z, EX x : (share * (list (list (hist * hist) * list Z * list bool))),

    PROP (readable_share (fst x); sepalg_list.list_join (fst x) (sublist i 3 shs) Ews; Zlength (snd x) = i;

          Forall (fun p => let '(h, li, ls) := p in add_items_trace empty_hists (combine (combine (combine

            [1; 2; 3] [1; 1; 1]) li) ls) h) (snd x);

          Forall (fun h => Zlength h = size) (map fst (map fst (snd x)));

          Forall (fun '(h, li, ls) => Zlength li = 3 /\ Zlength ls = 3) (snd x))

    LOCAL (let ls := map snd (snd x) in temp _total (vint (Zlength (filter id (concat ls))));

           lvar _values (tarray tint 16384) values; lvar _keys (tarray tint 16384) keys; gvar _results resp;

           gvar _thread_locks locksp; gvar _m_entries m_entries)

    SEP (@data_at CompSpecs (fst x) (tarray tentry size) entries m_entries;

         EX sh' : share, !!(readable_share sh' /\ sepalg_list.list_join sh' (sublist i 3 shs) Tsh) &&

           let h := map fst (map fst (snd x)) in

           atomic_entries sh' entries ghosts (fold_right join_hists empty_hists h);

         data_at_ Tsh (tarray tint 16384) values; data_at_ Tsh (tarray tint 16384) keys;

         data_at (fst x) (tarray (tptr tint) 3) res resp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) (sublist i 3 res));

         data_at (fst x) (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp;

         fold_right sepcon emp (map (malloc_token Tsh (sizeof (Tstruct _lock_t noattr))) (sublist i 3 locks));

         fold_right sepcon emp (map (fun j => lock_inv sh1 (Znth j locks Vundef)

           (f_lock_pred sh2 (Znth j shs Ews) entries ghosts m_entries j locksp

              (Znth j locks Vundef) resp (Znth j res Vundef))) (sublist i 3 (upto 3))))).

  { rewrite !(sublist_same 0 3) by auto.

    Exists (sh, @nil (list (hist * hist) * list Z * list bool)) sh'; go_lower.

    match goal with H : sepalg_list.list_join _ (sublist _ _ _) _ |- _ => rewrite sublist_nil in H; inv H end.

    apply andp_right; [apply prop_right; repeat (split; auto)|].

    apply andp_right; [apply prop_right; repeat (split; auto)|].

    entailer'.

    apply prop_right; split.

    { eapply join_readable1; eauto. }

    eapply sepalg_list.list_join_assoc2 in Hshs; [|eapply sepalg.join_comm, comp_join_top].

    destruct Hshs as (shd & Hjoin' & ?).

    apply sepalg.join_comm in Hjoin'; exploit (sepalg.join_eq(x := sh)(y := Share.comp Ews)(z := shd)(z' := sh'));

      auto; intro; subst; auto. }

  { 

    destruct x as (sh3, lr); Intros sh3'; simpl in *.

    erewrite sublist_next with (l := upto 3), Znth_upto by (auto; rewrite ?Zlength_upto; simpl; omega); simpl.

    rewrite lock_inv_isptr; Intros.

    forward.

    forward_call (Znth i locks Vundef, sh1, f_lock_pred sh2 (Znth i shs Ews) entries ghosts m_entries i locksp

      (Znth i locks Vundef) resp (Znth i res Vundef)).

    forward_call (Znth i locks Vundef, Tsh, sh2,

      |>f_lock_inv (Znth i shs Ews) entries ghosts m_entries i locksp (Znth i locks Vundef) resp (Znth i res Vundef),

      |>f_lock_pred sh2 (Znth i shs Ews) entries ghosts m_entries i locksp (Znth i locks Vundef) resp (Znth i res Vundef)).

    { rewrite ?sepcon_assoc; rewrite <- sepcon_emp at 1; rewrite sepcon_comm; apply sepcon_derives;

        [repeat apply andp_right; auto; eapply derives_trans;

         try (apply precise_weak_precise || apply positive_weak_positive || apply rec_inv_weak_rec_inv); auto |].

      { apply later_positive; auto. }

      { apply later_rec_lock, selflock_rec. }

      unfold f_lock_pred at 2.

      rewrite selflock_eq.

      rewrite <- !sepcon_assoc, (sepcon_comm _ (lock_inv _ _ _)), !sepcon_assoc, <- sepcon_assoc;

        apply sepcon_derives; [|cancel_frame].

      rewrite <- (lock_inv_share_join sh1 sh2 Tsh) by auto; unfold f_lock_pred; cancel.

      apply lock_inv_later. }

    erewrite sublist_next with (l := locks) by (auto; omega); simpl.

    forward_call (Znth i locks Vundef, sizeof (Tstruct _lock_t noattr)).

    { entailer!. }

    { apply sepcon_derives; [|cancel_frame].

      rewrite data_at__memory_block; Intros; auto. }

    unfold f_lock_inv at 1; Intros hi lii lsi.

    assert (0 <= i < Zlength shs) by omega.

    forward.

    { apply Forall_Znth; auto. }

    { assert (0 <= i < 3) as Hi by auto; clear - Hi; entailer!.

      rewrite upd_Znth_same; auto. }

    rewrite upd_Znth_same by auto.

    forward.

    erewrite sublist_next with (l := res) by (auto; omega); simpl.

    forward_call (Znth i res Vundef, sizeof tint).

    { entailer!. }

    { rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at _ _ _ (Znth i res Vundef))), !sepcon_assoc;

        apply sepcon_derives; [|cancel_frame].

      apply data_at_memory_block. }

    assert (3 <= Zlength shs) by omega.

    match goal with H : sepalg_list.list_join sh3 _ _ |- _ => rewrite sublist_next with (d := Ews) in H by auto;

      inversion H as [|??? w1 ? Hj1]; subst end.

    match goal with H : sepalg_list.list_join sh3' _ _ |- _ => rewrite sublist_next with (d := Ews) in H by auto;

      inversion H as [|??? w1' ? Hj1']; subst end.

    gather_SEP 10 2.

    replace_SEP 0 (data_at w1 (tarray (tptr (Tstruct _lock_t noattr)) 3) locks locksp).

    { go_lower.

      rewrite <- lock_struct_array.

      eapply derives_trans; [apply data_at_array_value_cohere; auto|].

      erewrite data_at_share_join; eauto. }

    gather_SEP 8 3.

    replace_SEP 0 (data_at w1 (tarray (tptr tint) 3) res resp).

    { go_lower.

      eapply derives_trans; [apply data_at_array_value_cohere; auto|].

      erewrite data_at_share_join; eauto. }

    forward.

    go_lower; Exists (w1, lr ++ [(hi, lii, lsi)]) w1'.

    rewrite sepcon_andp_prop', sepcon_andp_prop.

    assert (Zlength hi = size) by (erewrite add_items_empty_length; eauto).

    apply andp_right; [|apply andp_right; [|apply andp_right]]; try apply prop_right.

    - simpl; split; [omega|].

      split; [eapply join_readable1; eauto|].

      split; auto.

      split; [rewrite Zlength_app, Zlength_cons, Zlength_nil; auto|].

      rewrite !map_app, !Forall_app; repeat constructor; auto.

    - repeat (split; auto).

      simpl; rewrite add_repr, map_app, concat_app, filter_app, Zlength_app; simpl; rewrite app_nil_r; auto.

    - split; auto.

      eapply join_readable1; eauto.

    - rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at sh3 _ _ m_entries)),

        (sepcon_comm _ (data_at _ _ _ m_entries)).

      erewrite <- !sepcon_assoc, data_at_share_join by eauto.

      rewrite !sepcon_assoc; apply sepcon_derives; [apply derives_refl|].

      rewrite <- !sepcon_assoc, (sepcon_comm _ (atomic_entries _ _ _ _)),

        (sepcon_comm _ (atomic_entries _ _ _ _)).

      erewrite <- !sepcon_assoc, atomic_entries_join; rewrite ?join_hists_empty_length; eauto; try omega.

      Intros.

      simpl; rewrite !map_app, fold_right_app; simpl.

      rewrite join_hists_base by auto.

      cancel.

      { apply Forall_Znth; auto. } }

  Intros x sh''; destruct x as (?, lr); simpl in *.

  repeat match goal with H : sepalg_list.list_join _ (sublist 3 3 _) _ |- _ =>

    rewrite sublist_nil in H; inv H end.

  forward_call (Ews, m_entries, entries, ghosts, fold_right join_hists empty_hists (map fst (map fst lr)),

    keys, values).

  { apply sepcon_derives; [apply derives_refl | cancel_frame]. }

  { split; auto; split; [omega|].

    rewrite join_hists_empty_length; auto. }

  Intro x; destruct x as (lk, lv); simpl; Intros.

  exploit (add_three lr lk lv); auto; intro.

  forward.

  Exists values keys.

  rewrite (sepcon_comm (data_at _ _ _ keys)), (sepcon_comm (data_at _ _ _ values)).

  rewrite sepcon_assoc, (sepcon_comm (data_at _ _ _ values)), <- !sepcon_assoc; apply sepcon_derives;

    [apply sepcon_derives; auto|]; apply andp_right, data_at_data_at_; apply prop_right; auto.

Qed.



Lemma make_map_eq : forall h h', Forall2 (fun a b => value_of_hist (fst a) = value_of_hist (fst b) /\

  value_of_hist (snd a) = value_of_hist (snd b)) h h' -> make_map h = make_map h'.

Proof.

  induction 1; auto; simpl.

  destruct x, y; simpl in *.

  destruct H as (-> & ->); rewrite IHForall2; auto.

Qed.



Lemma make_map_no_key : forall h k (Hout : Forall (fun x => make_int (value_of_hist (fst x)) <> k) h),

  Forall (fun x => fst x <> k) (make_map h).

Proof.

  induction h; simpl; auto; intros.

  destruct a.

  inv Hout.

  constructor; auto.

Qed.



Lemma set_item_trace_map : forall h k v i h' (Hwf : wf_hists h) (Hlenh : Zlength h = size)

  (Htrace : set_item_trace h k v i h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),

  wf_hists h' /\ let m' := make_map (upd_Znth i h' (Znth i h ([], []))) in

    map_incl (make_map h) m' /\ set m' k v = Some (make_map h').

Proof.

  intros.

  destruct Htrace as (Hlen & Hbounds & (Hi1 & Hr0) & Hi2 & Hrest).

  assert (i <= Zlength h') by (rewrite Hlen; destruct Hbounds; apply Z.lt_le_incl; auto).

  assert (0 <= i + 1 <= Zlength h').

  { rewrite Hlen; destruct Hbounds; split; [|rewrite <- lt_le_1]; auto; omega. }

  assert (vint k <> vint 0).

  { intro; contradiction Hk; apply repr_inj_signed; auto; congruence. }

  assert (value_of_hist (fst (Znth i h' ([], []))) = vint k) as Hk'.

  { destruct Hi1 as [Hi1 | [Hi1 | Hi1]]; rewrite (add_events_last _ _ _ Hi1); try discriminate; auto. }

  assert (wf_hists h') as Hwf'; [|split; auto; split].

  - unfold wf_hists; rewrite Forall_forall_Znth; intros j ?.

    apply (Forall_Znth _ _ j ([], [])) in Hwf; [destruct Hwf as ((? & ?) & ? & ?) | omega].

    destruct (eq_dec j i); [|specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i))].

    + subst.

      rewrite (add_events_snd _ _ _ Hi2), Forall_app; split;

        [|repeat constructor; auto; eapply add_events_ordered; eauto].

      destruct Hi1 as [Hi1 | [Hi1 | Hi1]]; rewrite (add_events_snd _ _ _ Hi1), Forall_app; repeat constructor;

        auto; eapply add_events_ordered; eauto.

    + destruct Hrest as ((? & ? & Hcase & ? & ? & -> & ?) & _); auto; simpl in *.

      split; auto.

      destruct Hcase as [Hj1 | Hj1]; rewrite (add_events_snd _ _ _ Hj1), Forall_app; repeat constructor; auto;

        eapply add_events_ordered; eauto.

    + destruct Hrest as (_ & ->); auto.

  - intros k0 v0 j Hk0 Hj.

    exploit (Znth_inbounds j (make_map h) (0, 0)).

    { rewrite Hj; intro X; inv X; contradiction Hk0; auto. }

    intro; unfold make_map in *; rewrite <- upd_Znth_map.

    rewrite Zlength_map in *.

    rewrite Znth_map with (d' := ([], [])) in Hj by auto; inv Hj.

    destruct (eq_dec j i); [subst; rewrite upd_Znth_same; auto | rewrite upd_Znth_diff'];

      rewrite ?Zlength_map in *; auto; try omega.

    rewrite Znth_map with (d' := ([], [])) by omega.

    specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i));

      [|destruct Hrest as (_ & ->); auto].

    destruct Hrest as ((r1 & ? & Hcase & ? & ? & -> & Heq) & _); auto; simpl in *.

    assert (value_of_hist (fst (Znth j h ([], []))) <> vint 0).

    { intro X; rewrite X in Hk0; contradiction Hk0; auto. }

    destruct Hcase as [Hj1 | Hj1]; rewrite (add_events_last _ _ _ Hj1), Heq; try discriminate; auto.

  - assert (0 <= i < Zlength h') by (rewrite Hlen; auto).

    unfold set.

    assert (lookup (make_map (upd_Znth i h' (Znth i h ([], [])))) k = Some i) as ->.

    + unfold lookup, make_map.

      assert (i = ((i - hash k) mod size + hash k) mod size) as Hmod.

      { rewrite Zplus_mod_idemp_l, Z.sub_simpl_r, Zmod_small by omega; auto. }

      pose proof (hash_range k).

      assert (Zlength (map (fun hs => (make_int (value_of_hist (fst hs)), make_int (value_of_hist (snd hs))))

              (upd_Znth i h' (Znth i h ([], [])))) = size) as Hlen1.

      { rewrite Zlength_map, upd_Znth_Zlength; auto; omega. }

      erewrite index_of'_succeeds; simpl.

      f_equal; symmetry; apply Hmod.

      { rewrite Zlength_rebase; rewrite ?Zlength_map, ?upd_Znth_Zlength; auto;

          replace (Zlength h') with size; auto; try omega.

        apply Z_mod_lt, size_pos. }

      { rewrite Forall_forall; intros x Hin.

        apply In_Znth with (d := (0, 0)) in Hin; destruct Hin as (j & Hj & Hx).

        exploit (Z_mod_lt (i - hash k) size); [apply size_pos | intro].

        rewrite Zlength_sublist in Hj; rewrite ?Zlength_rebase; rewrite ?Hlen1; try (simpl in *; omega).

        rewrite Znth_sublist, Z.add_0_r in Hx by (auto; omega).

        rewrite Znth_rebase in Hx by (simpl in *; omega).

        rewrite Hlen1, Znth_map with (d' := ([], [])) in Hx.

        subst x; simpl.

        specialize (Hrest ((j + hash k) mod size)); destruct Hrest as ((r1 & ? & Hcase & ? & ? & ?) & _).

        { unfold indices; rewrite in_map_iff.

          exists j; split; [rewrite Z.add_comm; auto|].

          rewrite In_upto, Z2Nat.id; omega. }

        rewrite upd_Znth_diff'; auto.

        simpl in *; destruct Hcase as [Hj1 | Hj1]; rewrite (add_events_last _ _ _ Hj1); try discriminate;

          simpl; rewrite !Int.signed_repr; auto.

        * intro X; rewrite <- X, Zminus_mod_idemp_l, Z.add_simpl_r, Z.sub_0_r, Zmod_small in Hj; try omega.

          destruct Hj; split; auto; etransitivity; eauto; apply Z_mod_lt, size_pos.

        * rewrite upd_Znth_Zlength by auto.

          replace (Zlength h') with size by omega; apply Z_mod_lt, size_pos. }

      { rewrite <- Hlen1, Znth_rebase', Znth_map with (d' := ([], [])); simpl;

          rewrite ?Zlength_map, ?upd_Znth_Zlength; auto; try (simpl in *; omega).

        rewrite upd_Znth_same by auto; simpl.

        destruct (eq_dec (value_of_hist (fst (Znth i h ([], [])))) (vint 0)); [rewrite e; auto|].

        rewrite Hr0; auto; simpl.

        rewrite Int.signed_repr; auto. }

    + simpl; unfold make_map; erewrite <- upd_Znth_map, upd_Znth_twice, upd_Znth_triv; rewrite ?Zlength_map;

        auto.

      rewrite Znth_map', Hk', (add_events_last _ _ _ Hi2); [simpl | discriminate].

      rewrite !Int.signed_repr; auto.

Qed.



Lemma get_item_trace_map : forall h k v i h' (Hwf : wf_hists h) (Hlenh : Zlength h = size)

  (Htrace : get_item_trace h k v i h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),

  wf_hists h' /\ match get (make_map h') k with

  | Some v' => v' = v /\ map_incl (upd_Znth i (make_map h) (k, v)) (make_map h')

  | None => v = 0 /\ map_incl (make_map h) (make_map h') end.

Proof.

  intros.

  destruct Htrace as (Hlen & Hbounds & Hi & Hrest).

  destruct (Znth i h ([], [])) as (hk, hv) eqn: Hhi.

  destruct Hi as (r & Hi1 & Hi2 & Hr0).

  assert (i <= Zlength h') by (rewrite Hlen; destruct Hbounds; apply Z.lt_le_incl; auto).

  assert (0 <= i + 1 <= Zlength h').

  { rewrite Hlen; destruct Hbounds; split; [|rewrite <- lt_le_1]; auto; omega. }

  assert (vint k <> vint 0).

  { intro; contradiction Hk; apply repr_inj_signed; auto; congruence. }

  assert (wf_hists h') as Hwf'; [|split; auto].

  - unfold wf_hists; rewrite Forall_forall_Znth; intros j ?.

    apply (Forall_Znth _ _ j ([], [])) in Hwf; [destruct Hwf as ((? & ?) & ? & ?) | omega].

    destruct (eq_dec j i); [|specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i))].

    + subst; rewrite Hhi in *.

      rewrite (add_events_snd _ _ _ Hi1), Forall_app; split;

        [repeat constructor; auto; eapply add_events_ordered; eauto|].

      destruct Hi2 as [(? & ? & ->) | (? & Hi2)]; auto.

      rewrite (add_events_snd _ _ _ Hi2), Forall_app; repeat constructor; auto; eapply add_events_ordered; eauto.

    + destruct Hrest as ((? & ? & Hj1 & ? & ? & -> & ?) & _); auto; simpl in *.

      split; auto.

      rewrite (add_events_snd _ _ _ Hj1), Forall_app; repeat constructor; auto.

      eapply add_events_ordered; eauto.

    + destruct Hrest as (_ & ->); auto.

  - unfold get, lookup.

    pose proof (index_of'_spec k (rebase (make_map h') (hash k))) as Hspec.

    destruct (index_of' (rebase (make_map h') (hash k)) k) eqn: Hindex; simpl.

    unfold make_map at 1; rewrite Znth_map with (d' := ([], [])).

    pose proof (hash_range k).

    assert ((z + hash k) mod size = i) as Hz.

    { destruct Hspec as (Hz & Hcase & Hall).

      assert (Zlength (make_map h') = Zlength h') as Hlenm by (unfold make_map; rewrite Zlength_map; auto).

      assert (z <= (i - hash k) mod Zlength (make_map h')) as Hle.

      { eapply Forall_sublist_le; try apply Hall; simpl.

        { apply Z_mod_lt; omega. }

        { simpl in *; omega. }

        rewrite Znth_rebase' by (simpl in *; omega).

        unfold make_map; rewrite Znth_map'.

        rewrite (add_events_last _ _ _ Hi1); [simpl | discriminate].

        destruct Hi2 as [(? & ? & ?) | (? & ?)]; subst; [|rewrite Int.signed_repr by auto]; tauto. }

      rewrite Zlength_rebase in Hz by omega.

      rewrite Znth_rebase, Hlenm in Hcase by omega.

      unfold make_map in Hcase; rewrite Znth_map with (d' := ([], [])) in Hcase; simpl in Hcase.

      destruct (eq_dec ((z + hash k) mod size) i); auto.

      specialize (Hrest ((z + hash k) mod size)); destruct Hrest as ((r1 & ? & Hfst & ? & ? & ?) & _).

      { unfold indices.

        rewrite in_map_iff.

        exists z; split; [rewrite Z.add_comm; auto|].

        rewrite In_upto, Z2Nat.id.

        rewrite Hlenm in Hle; replace (Zlength h') with size in Hle by omega.

        destruct (eq_dec z ((i - hash k) mod size)); [|omega].

        contradiction n; rewrite e, Zplus_mod_idemp_l, Z.sub_simpl_r, Zmod_small; auto; omega.

        { apply Z_mod_lt, size_pos. } }

      replace (Zlength h') with size in Hcase by omega.

      simpl in *; rewrite (add_events_last _ _ _ Hfst) in Hcase; [simpl in Hcase | discriminate].

      rewrite !Int.signed_repr in Hcase; tauto.

      { apply Z_mod_lt; omega. } }

    simpl in *; rewrite Hz.

    replace (value_of_hist (fst _)) with (vint r)

      by (rewrite (add_events_last _ _ _ Hi1); [auto | discriminate]); simpl.

    destruct Hi2 as [(? & ? & Hi2) | (? & Hi2)]; clear dependent z; subst; simpl.

    + split; auto.

      intros k0 v0 j Hk0 Hj.

      exploit (Znth_inbounds j (make_map h) (0, 0)).

      { rewrite Hj; intro X; inv X; contradiction Hk0; auto. }

      unfold make_map in *; rewrite Zlength_map; intro;

        rewrite Znth_map with (d' := ([], [])) in Hj by auto; inv Hj.

      rewrite Znth_map with (d' := ([], [])) by omega.

      destruct (eq_dec j i).

      { subst; rewrite Hhi in *; simpl in *; contradiction Hk0.

        destruct (eq_dec (value_of_hist hk) (vint 0)); [rewrite e; auto|].

        rewrite Hr0; auto. }

      specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i)).

      * destruct Hrest as ((? & ? & Hj1 & ? & ? & -> & Heq) & _); auto.

        rewrite (add_events_last _ _ _ Hj1); [simpl | discriminate].

        destruct (eq_dec (value_of_hist (fst (Znth j h ([], [])))) (vint 0));

          [contradiction Hk0; rewrite e; auto|].

        rewrite Heq; auto.

      * destruct Hrest as (_ & ->); auto.

    + rewrite (add_events_last _ _ _ Hi2); [simpl | discriminate].

      rewrite !Int.signed_repr by auto.

      if_tac; [contradiction Hk; auto|].

      split; auto.

      intros k0 v0 j Hk0 Hj.

      exploit (Znth_inbounds j (upd_Znth i (make_map h) (k, v)) (0, 0)).

      { rewrite Hj; intro X; inv X; contradiction Hk0; auto. }

      unfold make_map in *; rewrite upd_Znth_Zlength; rewrite Zlength_map; auto.

      intro; rewrite Znth_map with (d' := ([], [])) by omega.

      destruct (eq_dec j i).

      { subst; rewrite upd_Znth_same in Hj by (rewrite Zlength_map; auto).

        inv Hj; rewrite (add_events_last _ _ _ Hi1), (add_events_last _ _ _ Hi2); try discriminate; simpl.

        rewrite !Int.signed_repr; auto. }

      rewrite upd_Znth_diff' in Hj; rewrite ?Zlength_map; auto.

      rewrite Znth_map with (d' := ([], [])) in Hj by auto; inv Hj.

      specialize (Hrest j); destruct (in_dec Z_eq_dec j (indices (hash k) i)).

      * destruct Hrest as ((? & ? & Hj1 & ? & ? & -> & Heq) & _); auto.

        rewrite (add_events_last _ _ _ Hj1); [simpl | discriminate].

        destruct (eq_dec (value_of_hist (fst (Znth j h ([], [])))) (vint 0));

          [contradiction Hk0; rewrite e; auto|].

        rewrite Heq; auto.

      * destruct Hrest as (_ & ->); auto.

    + replace (Zlength h') with size by omega; apply Z_mod_lt, size_pos.

    + assert (In r (map fst (rebase (make_map h') (hash k)))).

      { rewrite in_map_iff.

        unfold rebase, make_map; eexists; rewrite rotate_In, in_map_iff.

        split; [|do 2 eexists; eauto; apply Znth_In with (i0 := i); omega].

        rewrite (add_events_last _ _ _ Hi1); [simpl | discriminate].

        apply Int.signed_repr; destruct Hi2 as [(? & ? & ?) | (? & ?)]; subst; auto.

        { pose proof (hash_range k).

          rewrite Zlength_map; omega. } }

      destruct Hspec as (Hnk & Hnz), Hi2 as [(? & ? & ?) | (? & ?)]; subst;

        [contradiction Hnz | contradiction Hnk].

Qed.

