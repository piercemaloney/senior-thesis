

Load loadpath.

Require Import ZArith List Bool.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import veristar.datatypes veristar.clauses.
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)

Require Import veristar.wellfounded.
(* veristar.wellfounded:
Require Import Arith.
Require Import Relations.
Require Import Lexicographic_Product.

Section LT_WF_REL.
   Variable A : Type.
  Variable R : A -> A -> Prop.

  Variable F : A -> nat -> Prop.
  Definition inv_lt_rel x y := exists2 n, F x n & (forall m, F y m -> n < m).

  Hypothesis F_compat : forall x y:A, R x y -> inv_lt_rel x y.
  Remark acc_lt_rel : forall x:A, (exists n, F x n) -> Acc R x.

  Theorem well_founded_inv_lt_rel_compat : well_founded R.

End LT_WF_REL.

Definition lex_pair {A B} (Ra: A -> A -> Prop) (Rb: B -> B -> Prop)
            (x: A*B) (y: A*B) : Prop :=
 Ra (fst x) (fst y) \/ (fst x = fst y /\ Rb (snd x) (snd y)).

Lemma well_founded_incl:
  forall A (Rs Rt: A -> A -> Prop),
   inclusion _ Rt Rs -> well_founded Rs -> well_founded Rt.

Lemma well_founded_image:
  forall A B (f: A -> B) (Rb: B -> B -> Prop),
    well_founded Rb ->
    well_founded (fun x y => Rb (f x) (f y)).

Lemma well_founded_lex_pair:
  forall A B (Ra: A -> A -> Prop) (Rb: B -> B -> Prop),
  well_founded Ra -> well_founded Rb -> well_founded (lex_pair Ra Rb).

Lemma well_founded_trans:
  forall A (Ra: A -> A -> Prop),
    well_founded Ra <-> well_founded (clos_trans _ Ra).

Definition lexprodx {B A : Type} (f: A -> B) (R1: B -> B -> Prop)
  (R2: B -> A -> A -> Prop)
  (x y : A) : Prop :=
     R1 (f x) (f y) \/ f x = f y /\ R2 (f x) x y.

Lemma lexprodx_eq: forall B A f R1 R2 x y,
    lexprodx f R1 R2 x y <->
    lexprod B (fun _ => A) R1 R2 (existT (fun _:B => A) (f x) x)
               (existT (fun _:B => A) (f y) y).

Lemma well_founded_lexprodx: forall B A (f: A -> B) R1 R2,
  well_founded R1 -> (forall n, well_founded (R2 n)) ->
  well_founded (lexprodx f R1 R2).

Definition simple_lexprod {A: Type} (R1: A -> A -> Prop) (R2: A -> A -> Prop)
            (x y: A) : Prop :=
  R1 x y \/ x=y /\ R2 x y.

Lemma simple_lexprod_eq:
  forall A R1 R2 x y,
     @simple_lexprod A R1 R2 x y <->
    lexprod A (fun _ => A) R1 (fun _ => R2)
       (existT (fun _:A => A) x x) (existT (fun _:A => A) y y).

Lemma wellfounded_simple_lexprod:
  forall A (R1: A -> A -> Prop) (R2: A -> A -> Prop),
    well_founded R1 ->
    well_founded R2 ->
    well_founded (simple_lexprod R1 R2). *)

Require Import Image.

Require Import veristar.basic.
(* veristar.basic:
Load loadpath.
Require Import Coq.Lists.List Coq.Arith.EqNat Coq.Arith.Compare_dec
               Coq.ZArith.ZArith.
Require Import veristar.tactics.

Set Implicit Arguments.
Unset Strict Implicit.

Section option.
Variables (A B : Type) (h : A -> B) (f : A -> option B) (o : option A).

Definition omap := match o with Some a => Some (h a) | None => None end.

Definition obnd := match o with Some a => f a | None => None end.

End option.
Implicit Arguments omap [A B].
Implicit Arguments obnd [A B].

Definition isSome {A : Type} (o : option A) :=
  match o with Some _ => true | _ => false end.

Section comp.
Variables (A B C : Type) (g : B -> C) (f : A -> B) (a : A).

Definition compose := g (f a).

End comp.
Implicit Arguments compose [A B C].

Infix "oo" := compose (at level 54, right associativity).

Notation "[ ]" := nil.
Notation "[ x , .. , y ]" := (cons x .. (cons y []) ..).

Fixpoint zip_with_acc {A B : Type} acc (l1 : list A) (l2 : list B) :=
  match l1, l2 with
    | a :: l1', b :: l2' => (a, b) :: zip_with_acc acc l1' l2'
    | _, _ => acc
  end.

Definition zip {A B : Type} := @zip_with_acc A B [].

Section iter.
Variables (A : Type) (f : nat -> A -> A).

Fixpoint iter (n : nat) (a : A) :=
  match n with
    | O => a
    | S n' => iter n' (f n' a)
  end.

End iter.
Implicit Arguments iter [A].

Section tryfind.
Variables (A E B : Type) (f : A -> E + B).

Fixpoint tryfind (err : E) (l : list A) :=
  match l with
    | nil => inl _ err
    | a :: l' => match f a with
                   | inl err' => tryfind err' l'
                   | inr success as r => r
                 end
  end.

End tryfind.

Definition max (n m : nat) := if leb n m then m else n.

Definition maxs (l : list nat) := fold_left (fun m n => max m n) l 0.

Definition elemb (n : nat) := existsb (fun m => beq_nat n m).

Require Import ZArith.

Lemma Ppred_decrease n : (n<>1)%positive -> (nat_of_P (Ppred n)<nat_of_P n)%nat.

Ltac Ppred_tac n :=
  apply Ppred_decrease; destruct n;
  let H := fresh "H" in intro H; try (inversion H||inversion H1); congruence.

Definition Pleb (x y : positive) :=
  match Pcompare x y Eq with
    | Lt => true
    | Eq => true
    | Gt => false
  end.

Lemma Pleb_Ple (x y : positive) : Pleb x y = true <-> Ple x y.

Require Import NArith NOrderedType.

Definition Nleb (x y : N) :=
  match Ncompare x y with
    | Lt => true
    | Eq => true
    | Gt => false
  end.

Lemma Nleb_Nle (x y : N) : Nleb x y = true <-> Nle x y.

Section revc.
Variables (A : Type) (c : A -> A -> comparison).

Definition revc a1 a2 :=
  match c a1 a2 with
    | Gt => Lt
    | Eq => Eq
    | Lt => Gt
  end.

End revc.

Inductive ret_kind (val : Type) : Type :=
| Success : val -> ret_kind val
| Failure : ret_kind val.

Implicit Arguments Success [val].
Implicit Arguments Failure [val]. *)

Require Import veristar.clause_universe.
(* veristar.clause_universe:
Load loadpath.
Require MSets.
Require Coq.Structures.Orders.
Require Coq.Structures.OrdersFacts.
Require Import Morphisms.
Require Import ProofIrrelevance.
Require Import List.
Require Import Relation_Definitions.
Require Import Sorting.
Require Recdef.
Require Omega.
Require Import VST.msl.Axioms VST.msl.Coqlib2.
Require Import NArith veristar.variables veristar.datatypes veristar.clauses.
Require Import veristar.fresh.
Require Import Finite_sets_facts.
Require Import VST.msl.base.

Definition list_bound {A: Type} (f: A -> Prop) (l: list A):=
  Forall f l /\  NoDup l.

Definition vset := Ensemble var.

Definition expr_bound (n: vset) (e: expr) :=
 match e with Nil => True | Var v => n v end.

Definition pure_bound (n: vset) (a : pure_atom) :=
 match a with
 | Eqv e e' => expr_bound n e /\ expr_bound n e'
 end.

Definition space_bound (n: vset) (a: space_atom) :=
 match a with
 | Next e e' =>  expr_bound n e /\ expr_bound n e'
 | Lseg e e' =>  expr_bound n e /\ expr_bound n e'
 end.

Definition pures_bound n := list_bound (pure_bound n).
Definition spaces_bound n := list_bound (space_bound n).

Definition pures_bound' n := Forall (pure_bound n).
Definition spaces_bound' n := Forall (space_bound n).

Definition clause_bound' (n: vset)  (cl: clause) :=
 match cl with
 | PureClause pi pi' _ _ =>  pures_bound' n pi /\ pures_bound' n pi'
 | PosSpaceClause pi pi' sigma =>
    pures_bound' n pi /\ pures_bound' n pi'/\ spaces_bound' n sigma
 | NegSpaceClause pi sigma pi' =>
    pures_bound' n pi /\ pures_bound' n pi'/\ spaces_bound' n sigma
 end.

Definition clause_bound (n: vset)  (cl: clause) :=
 match cl with
 | PureClause pi pi' _ _ =>  pures_bound n pi /\ pures_bound n pi'
 | PosSpaceClause pi pi' sigma =>
    pures_bound n pi /\ pures_bound n pi'/\ spaces_bound n sigma
 | NegSpaceClause pi sigma pi' =>
    pures_bound n pi /\ pures_bound n pi'/\ spaces_bound n sigma
 end.

Lemma expr_bound_more: forall  n n' e,
    Included _ n n' -> expr_bound n e -> expr_bound n' e.

Lemma pure_bound_more:
  forall n n' a, Included _ n n' -> pure_bound n a -> pure_bound n' a.

Lemma pures_bound'_more:
  forall n n' gamma, Included _ n n' -> pures_bound' n gamma -> pures_bound' n' gamma.

Lemma space_bound_more:
  forall n n' a, Included _ n n' -> space_bound n a -> space_bound n' a.

Lemma spaces_bound'_more:
  forall n n' gamma, Included _ n n' -> spaces_bound' n gamma -> spaces_bound' n' gamma.

Lemma clause_bound'_more:
  forall n n' c, Included _ n n' -> clause_bound' n c -> clause_bound' n' c.

Definition var_upto (v: var): Ensemble var := fun x => Ile x v.

Lemma expr_bound_freshmax:
  forall e, expr_bound (var_upto (freshmax_expr e)) e.

Lemma S_nat_of_P_id2pos_le:
 forall x y, Ile x y -> S (nat_of_P (id2pos x)) <= S (nat_of_P (id2pos y)).

Lemma included_var_upto:
  forall a b, Ile a b -> Included _ (var_upto a) (var_upto b).

Lemma pure_bound_freshmax:
 forall a, pure_bound (var_upto (freshmax_pure_atom a)) a.

Lemma pures_bound_freshmax:
  forall gamma,
  pures_bound' (var_upto (freshmax_list freshmax_pure_atom gamma)) gamma.

Lemma space_bound_freshmax:
 forall a, space_bound (var_upto (freshmax_space_atom a)) a.

Lemma spaces_bound'_freshmax:
  forall gamma,
  spaces_bound' (var_upto (freshmax_list freshmax_space_atom gamma)) gamma.

Lemma clause_bound'_freshmax:
  forall c, clause_bound' (var_upto (freshmax_clause c)) c.

Module Type CLAUSE_UNIVERSE_FINITE.

 Axiom Finite_var_upto:  forall v, Finite _ (var_upto v).
 Axiom clause_bound_finite: forall n, Finite _ n -> Finite _ (clause_bound n).
End CLAUSE_UNIVERSE_FINITE.

Module ClauseUniverseFinite : CLAUSE_UNIVERSE_FINITE.

Require Import Image.

Implicit Arguments Finite.
Implicit Arguments Union.
Implicit Arguments Intersection.
Implicit Arguments Im.
Implicit Arguments In.
Implicit Arguments Add.
Implicit Arguments Subtract.
Implicit Arguments Singleton.
Implicit Arguments injective.
Implicit Arguments Included.
Implicit Arguments Power_set.

Ltac inv H := inversion H; clear H; subst.

Lemma finite_pair:
  forall U V (S : Ensemble U) (T: Ensemble V),
         Finite S -> Finite T ->
         Finite (fun xy => S (fst xy) /\ T (snd xy)).

Definition pures_bound2 n pi2 :=
      pures_bound n (fst pi2) /\ pures_bound n (snd pi2).

Lemma finite_unimage :
    forall {U V} (X:Ensemble U) (f:U -> V),
       injective f ->
       Finite (Im X f) -> Finite X.

Lemma Power_set_finite:
  forall U (F: Ensemble U), Finite F -> Finite (Power_set F).

Definition list2set {U} (l: list U) : Ensemble U :=
  fun x => List.In x l.

Program Definition ff U (F: Ensemble U) (l : sig (@NoDup (sig F))) : sig (@NoDup U) :=
 (map (@proj1_sig _ _) (proj1_sig l)).

Lemma NoDup_finite:
  forall U (F: Ensemble U), Finite F -> Finite (fun l: sig (@NoDup _) => Forall F (proj1_sig l)).

Lemma finite_list_bound:
 forall U (F: Ensemble U), Finite F -> Finite (list_bound F).

Lemma finite_expr_bound:
  forall n, Finite n -> Finite (expr_bound n).

Lemma finite_pure_bound: forall n, Finite n -> Finite (pure_bound n).

Lemma finite_space_bound: forall n, Finite n -> Finite (space_bound n).

Lemma finite_pures_bound: forall n, Finite n -> Finite (pures_bound n).

Lemma finite_spaces_bound: forall n, Finite n -> Finite (spaces_bound n).

Lemma clause_bound_finite: forall n, Finite n -> Finite (clause_bound n).

Definition var2nat v := nat_of_P (id2pos v).

Lemma Finite_var_upto:
  forall v, Finite (var_upto v).

End ClauseUniverseFinite. *)

Require Import veristar.compare.
(* veristar.compare:
Load loadpath.
Require Import ZArith.
Require Import Coq.Lists.List.
Require Import Sorted.
Require Import Coq.Sorting.Mergesort.
Require Import Permutation.

Definition StrictCompSpec {A} (eq lt: A -> A -> Prop)
                          (cmp: A -> A -> comparison) :=
  StrictOrder lt /\ forall x y, CompSpec eq lt x y (cmp x y).

Definition CompSpec' {A} (cmp: A -> A -> comparison) :=
   StrictCompSpec (@Logic.eq A) (fun x y => Lt = cmp x y) cmp.

Ltac do_comp cspec x y := destruct (CompSpec2Type (proj2 cspec x y)).

Lemma lt_comp: forall {A} lt cmp,
             StrictCompSpec Logic.eq lt cmp ->

Lemma eq_comp: forall {A} lt cmp,
        StrictCompSpec Logic.eq lt cmp ->

Lemma gt_comp: forall {A} lt cmp,
        StrictCompSpec Logic.eq lt cmp ->

Lemma comp_refl: forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x, cmp x x = Eq.

Lemma comp_eq: forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
   forall x y, Eq = cmp x y -> x=y.

Lemma comp_trans:  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x y z, Lt = cmp x y -> Lt = cmp y z -> Lt = cmp x z.

Definition isGe (c: comparison) := match c with Lt => False | _ => True end.
Definition isGeq cc := match cc with Lt => false | _ => true end.

Fixpoint insert {A: Type} (cmp: A -> A -> comparison) (a: A) (l: list A)
  : list A:=
  match l with
  | h :: t => if isGeq (cmp a h)
                 then a :: l
                 else h :: (insert cmp a t)
  | nil => a :: nil
  end.

Fixpoint rsort {A: Type} (cmp: A -> A -> comparison) (l: list A) : list A :=
  match l with nil => nil | h::t => insert cmp h (rsort cmp t)
  end.

Fixpoint insert_uniq {A: Type} (cmp: A -> A -> comparison) (a: A) (l: list A)
  : list A:=
  match l with
  | h :: t => match cmp a h with
              | Eq => l
              | Gt => a :: l
              | Lt => h :: (insert_uniq cmp a t)
              end
  | nil => a::nil
  end.

Fixpoint rsort_uniq {A: Type} (cmp: A -> A -> comparison) (l: list A)
  : list A :=
  match l with nil => nil | h::t => insert_uniq cmp h (rsort_uniq cmp t)
  end.

Lemma perm_insert {T} cmp (a : T) l : Permutation (insert cmp a l) (a :: l).

Fixpoint compare_list {A: Type} (f: A -> A -> comparison) (xl yl : list A)
  : comparison :=
  match xl , yl with
  | x :: xl', y :: yl' => match f x y with
                          | Eq => compare_list f xl' yl'
                          | c => c
                          end
  | nil , _ :: _ => Lt
  | _ :: _ , nil => Gt
  | nil, nil => Eq
  end.

Lemma list_cspec:
  forall  {A} (cmp: A -> A -> comparison) (cmp_spec: CompSpec' cmp),
    CompSpec' (compare_list cmp).

Hint Resolve @list_cspec.

Lemma comp_antisym:  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x y, Lt = cmp x y <-> Gt = cmp y x.

Lemma NoDup_rsort_uniq:
  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
  forall  l, NoDup (rsort_uniq cmp l).

Lemma Forall_sortu:
  forall  {A} (f: A -> Prop) (cmp: A -> A -> comparison) l,
    Forall f l -> Forall f  (rsort_uniq cmp l).

Lemma rsort_uniq_in:
  forall {A} (R: A -> A -> comparison)
          (EQ: forall a b, (a=b) <-> (Eq = R a b))
          x l,
      List.In x (rsort_uniq  R l) <-> List.In x l. *)

Require Import VST.veric.Coqlib2.



Module Type SUPERPOSITION.



Definition model := list (var * expr).



Inductive superposition_result : Type :=

| Valid : superposition_result

| C_example : model -> M.t -> superposition_result

| Aborted : list clause -> superposition_result.



Parameter check : entailment -> superposition_result * M.t * M.t.



Parameter check_clauseset : M.t -> superposition_result * M.t * M.t.



Parameter clause_generate : model -> clause -> option (var * expr * clause).



Parameter clauses_generate : model -> list clause -> model * M.t.



End SUPERPOSITION.



Module Superposition <: SUPERPOSITION.



Definition pure_atom_gt1 a (l: list pure_atom) :=

  match l with b :: _ => pure_atom_gt a b | _ => true end.



Definition pure_atom_geq1 a (l: list pure_atom) :=

  match l with b :: _ => pure_atom_geq a b | _ => true end.



Definition sp (c d : clause) l0 : list clause :=

  match c, d with

  

  | PureClause nil (Eqv s t :: pos) _ _ ,

        PureClause (Eqv s' v :: neg') pos' _ _ =>

    if expr_eq s s' && expr_lt t s && expr_lt v s'

    then mkPureClause (insu_atm (norm_pure_atom (Eqv t v)) neg')

                      (merge pure_atom_cmp pos pos') :: l0

    else l0

  | PureClause nil (Eqv s t :: pos) _ _,

        PureClause nil (Eqv s' v :: pos') _ _ =>

    let ef := match c with

      

      | PureClause nil (Eqv u v :: Eqv s t :: pos) _ _ =>

        if expr_eq s u && pure_atom_gt (Eqv u v) (Eqv s t)

        then mkPureClause [norm_pure_atom (Eqv v t)]

               (insu_atm (norm_pure_atom (Eqv u t)) pos) :: l0

        else l0

      | _ => l0 end in

    

    if expr_eq s s' && expr_lt t s && expr_lt v s' &&

       pure_atom_gt1 (Eqv s t) pos && pure_atom_gt1 (Eqv s' v) pos' &&

       pure_atom_gt (Eqv s' v) (Eqv s t)

    then mkPureClause nil (insu_atm (norm_pure_atom (Eqv t v))

                          (merge pure_atom_cmp pos pos')) :: ef

    else ef

  | _ , _ => l0

  end.



Definition superpose (c d : clause) l0 : list clause := sp c d (sp d c l0).



Definition rewrite_by s t atm :=

  match atm with Eqv u v =>

    if expr_eq s u then if expr_eq s v then norm_pure_atom (Eqv t t)

                        else norm_pure_atom (Eqv t v)

    else if expr_eq s v then norm_pure_atom (Eqv u t)

         else atm

  end.



Definition demodulate (c d : clause) : clause :=

  match c, d with

  | PureClause nil [Eqv s t] _ _, PureClause neg pos _ _ =>

      mkPureClause (map (rewrite_by s t) neg) (map (rewrite_by s t) pos)

  | _, _ => d

  end.



Definition delete_resolved (c : clause) : clause :=

  match c with

  | PureClause neg pos _ _ =>

     mkPureClause (sortu_atms (remove_trivial_atoms neg))

                            (sortu_atms pos)

  | _ => mkPureClause nil [Eqv Nil Nil] 

  end.



Definition not_taut (c: clause) :=

  negb (match c with

        | PureClause neg pos _ _ =>

          existsb (fun a => existsb (fun b =>

                     pure_atom_eq a b) pos) neg ||

          existsb (fun a =>

            match a with Eqv e1 e2 => expr_eq e1 e2 end) pos

        | _ => false end).



Definition simplify (l : list clause) (c : clause) : clause :=

  delete_resolved (fold_left (fun d c => demodulate c d) l c).



Definition infer_list (c : clause) (l : list clause) : list clause :=

  print_inferred_list (filter not_taut (map (simplify l)

    (fold_left (fun l0 d => superpose c d l0) l nil))).



Definition mem_add := M.mem_add.

Lemma mem_add_spec:

    forall x s, mem_add x s = if M.mem x s then None else Some (M.add x s).

Proof. apply M.mem_add_spec. Qed.



Definition mem_add_nonempty x s :=

  if isEq (compare_clause x (mkPureClause nil nil)) then None else

    mem_add x s.



Definition add_list_to_set_simple (l: list M.elt) (s: M.t) : M.t :=

  fold_left (Basics.flip M.add) l s.



Fixpoint add_list_to_set (l: list M.elt) (s: M.t) : option M.t :=

 match l with

 | x::xs => match mem_add x s with

                  | None => add_list_to_set xs s

                  | Some s' => Some (add_list_to_set_simple xs s')

                  end

 | nil => None

 end.



Definition is_pure_clause (c : clause) : bool :=

 match c with PureClause _ _ _ _ => true | _ => false end.



Definition is_unit_cls (c: clause) :=

  match c with

  | PureClause nil [Eqv _ _] _ _ => true | _ => false end.



Definition one_inference_step (given_unselected: M.t*M.t)

  : (M.t * M.t) :=

  let (given, unselected) := given_unselected in

  match M.delete_min unselected with

  | Some (given_clause, unselected') =>

    if is_pure_clause given_clause &&

       not_taut given_clause

    then let s := M.elements given in

      let c := simplify s given_clause in

      match mem_add c given with

      | None => (given, unselected')

      | Some new_given =>

        let inferred_clauses := infer_list c s in

        let new_unselected :=

          fold_left (fun s0 c =>

            if M.mem c new_given then s0

            else M.add c s0) inferred_clauses unselected'

          in (new_given, new_unselected)

      end

    else (given, unselected')

  | None => (given, unselected)

  end.



Definition model := list (var * expr).



Inductive superposition_result : Type :=

| Valid : superposition_result

| C_example : model -> M.t -> superposition_result

| Aborted : list clause -> superposition_result.



Definition apply_model (R: model) (cl: clause) : clause :=

  fold_right (fun ve => subst_clause (fst ve) (snd ve)) cl R.



Definition is_model_of (R: model) (gamma delta : list pure_atom) : bool :=

  match fold_right (fun ve => subst_pures_delete (fst ve) (snd ve)) gamma R,

          fold_right (fun ve => subst_pures (fst ve) (snd ve)) delta R with

  | _::_, _ => true

  | nil , delta' => negb (forallb nonreflex_atom delta')

  end.



Definition is_model_of_PI (R: model) (nc :  clause) : bool :=

 match nc with NegSpaceClause pi_plus _ pi_minus =>

  match remove_trivial_atoms (fold_right (fun ve =>

          subst_pures_delete (fst ve) (snd ve)) pi_plus R),

        fold_right (fun ve =>

          subst_pures (fst ve) (snd ve)) pi_minus R with

  | nil , pi_minus' => forallb nonreflex_atom pi_minus'

  | _ :: _ , _ => false

  end

 | _ => false

 end.



Definition clause_generate (R: model) (cl: clause) : option (var * expr * clause) :=

  match apply_model R cl with

  | PureClause gamma (Eqv (Var l' as l) r :: delta) _ _ as c' =>

    if (andb (greater_than_expr l' r)

         (andb (greater_than_all l' gamma)

           (andb (greater_than_atoms (Eqv l r) delta)

             (negb (is_model_of R gamma delta))))) then Some (l', r, cl)

    else None

  | _ => None

  end.



Fixpoint clauses_generate (R: model) (cl: list clause) : model * M.t :=

  match cl with

  | nil => (R, M.empty)

  | c::cs => match clause_generate R c with

             | Some (i,e,c') => match clauses_generate ((i,e)::R) cs with

                                | (R', cs') => (R', M.add c cs')

                                end

             | None => clauses_generate R cs

             end

  end.



Definition arg := (M.t * M.t)%type.



Require Import veristar.variables.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)

Require Import veristar.fresh.
(* veristar.fresh:
Load loadpath.
Require Import Coq.Lists.List.
Require Import veristar.variables veristar.datatypes.
Require Import Coqlib.
Require Import VST.msl.Coqlib2.
Require Import ZArith.
Require Import veristar.compare.
Require Import veristar.clauses.

Fixpoint freshmax_expr (e: expr) : var :=
  match e with
  | Nil => minid
  | Var v => v
  end.

Definition var_max (x y : var) : var :=
 match Ident.compare x y with Lt => y | _ => x end.

Definition freshmax_pn_atom (a: pn_atom) : var :=
  match a with
  | Equ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  | Nequ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_space_atom (a: space_atom) : var :=
  match a with
  | Next e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
  | Lseg e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
 end.

Definition freshmax_list {A} (f: A -> var) (l: list A) : var :=
  fold_right (fun a i => var_max (f a) i) minid l.

Definition freshmax_assertion (a: assertion) : var :=
  match a with
  | Assertion pi sigma =>
     var_max (freshmax_list freshmax_pn_atom pi)
            (freshmax_list freshmax_space_atom sigma)
  end.

Definition freshmax_pure_atom (a: pure_atom) : var :=
  match a with
  | Eqv e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_clause (c : clause) : var :=
 match c with
 | PureClause pi pi' _ _ =>  var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi')
 | PosSpaceClause pi pi' sigma =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 | NegSpaceClause pi sigma pi' =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 end.

Lemma varmax_minid: forall x, var_max minid x = x.

Lemma varmax_minid': forall x, var_max x minid = x.

Lemma var_max_intro:
  forall a b c, Ident.lt a c -> Ident.lt b c -> Ident.lt (var_max a b) c.

Lemma Ile_var_max1:  forall a b, Ile a (var_max a b).

Lemma Ile_var_max2:  forall a b, Ile b (var_max a b).

Lemma Ile_trans: forall a b c, Ile a b -> Ile b c -> Ile a c.

Lemma Ile_minid: forall m, Ile minid m.

Lemma var_max_intro':
  forall a b c, Ile a c -> Ile b c -> Ile (var_max a b) c.

Lemma var_max_split': forall a b c, Ile (var_max a b) c -> Ile a c /\ Ile b c.

Lemma id_compare_refl: forall z, Ident.compare z z = Eq.

Lemma id_compare_lt: forall x y, Ident.lt x y -> Ident.compare x y = Lt.

Lemma id_compare_gt: forall x y, Ident.lt y x -> Ident.compare x y = Gt.

Lemma var_max_assoc: forall x y z, var_max x (var_max y z) = var_max (var_max x y) z.

Lemma var_max_com: forall x y, var_max x y = var_max y x.

Lemma var_max_split: forall a b c, Ident.lt (var_max a b) c -> Ident.lt a c /\ Ident.lt b c.

Lemma freshmax_list_app:
 forall {A} (f: A -> var) l1 l2,
    freshmax_list f (l1++l2) = var_max (freshmax_list f l1) (freshmax_list f l2).

Lemma freshmax_list_rev:
 forall {A} (f: A -> var) l,
    freshmax_list f (rev l) = freshmax_list f l.

Lemma Ile_freshmax_i3:
  forall s m,
    (forall x, M.In x s -> Ile (freshmax_clause x) m) ->

Lemma merge_nil1:
  forall {A} (f: A -> A -> comparison) l, merge f nil l = l.

Lemma freshmax_list_merge:
  forall m al bl,
     Ile (freshmax_list freshmax_pure_atom al) m ->
     Ile (freshmax_list freshmax_pure_atom bl) m ->
     Ile (freshmax_list freshmax_pure_atom (merge pure_atom_cmp al bl)) m.

Lemma Ile_freshmax_list:
  forall A (f: A -> var) m (s: list A),
    Ile (freshmax_list f s) m <-> (forall x, List.In x s -> Ile (f x) m).

Lemma freshmax_list_insu:
   forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      a s,
      freshmax_list f (insert_uniq cmp a s) = var_max (f a) (freshmax_list f s).

Lemma freshmax_list_sort:
  forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      (s: list A),
    freshmax_list f (rsort_uniq cmp s) = freshmax_list f s.

Lemma freshmax_insu:
  forall m a pi,
       Ile (freshmax_pure_atom a) m ->
       Ile (freshmax_list freshmax_pure_atom pi) m ->
       Ile (freshmax_list freshmax_pure_atom
              (insert_uniq pure_atom_cmp a pi)) m. *)



Definition varbound (ss: arg) : vset := var_upto (freshmax_list freshmax_clause (M.elements (M.union (fst ss) (snd ss)))).



Definition effective_cardinal (vb : vset) (s: M.t) (n: nat) :=

  cardinal _ (Intersection _ (Basics.flip M.In s) (clause_bound vb) ) n.



Definition headroom (vb: vset) (s: M.t) (h: nat) :=

 exists n, effective_cardinal vb s n /\ cardinal _ (clause_bound vb) (n+h).



Definition clause_set_increases vb (s s':  M.t) : Prop :=

  exists n, exists n',  headroom vb s n /\ headroom vb s' n' /\ n < n'.



Lemma effective_cardinal_fun: forall vb s n n',

   effective_cardinal vb s n -> effective_cardinal vb s n' -> n=n'.

Proof.

intros. unfold effective_cardinal in *.

 eapply cardinal_is_functional; eauto.

Qed.



Definition unselected_set_decreases (s s' : M.t) := M.cardinal s < M.cardinal s'.



Lemma well_founded_unselected_set_decreases: well_founded unselected_set_decreases.

Proof.

 intros.

 apply (well_founded_inv_lt_rel_compat _ _ (fun x n => M.cardinal x = n)).

 unfold inv_lt_rel; intros. eexists; eauto.

 unfold unselected_set_decreases in H.

 intros; subst; auto. omega.

Qed.



Lemma well_founded_clause_set_increases:

 forall vb, well_founded (clause_set_increases vb).

Proof.

 intro vb.

  apply (well_founded_inv_lt_rel_compat _ _ (headroom vb)).

  intros. unfold inv_lt_rel.

  destruct H as [n [n' [? [? ?]]]].

  exists n; auto.

  intros.

  destruct H0 as [h' [? ?]].

  destruct H2 as [h'' [? ?]].

  assert (h'=h'') by (eapply effective_cardinal_fun; eauto).

  subst h''.

  assert (h'+m = h' + n').

  eapply cardinal_is_functional; eauto.

  omega.

Qed.



Definition superpose_loop_order (s s': arg)  : Prop :=

   (Included _ (varbound s) (varbound s') /\

     (clause_set_increases (varbound s) (fst s) (fst s') \/

      fst s = fst s' /\ unselected_set_decreases (snd s) (snd s'))).



Definition Strict_Included_Fin (U: Type) (x y: Ensemble U) :=

  Strict_Included _ x y /\ Finite _ y.



Lemma well_founded_Strict_Included_Fin:

  forall U, well_founded (Strict_Included_Fin U).

Proof.

 intros.

 apply (well_founded_inv_lt_rel_compat _ _ (cardinal _)); intros.

 unfold inv_lt_rel.

 destruct H.

 assert (Finite U x).

   apply Finite_downward_closed with y; auto.

  destruct (Strict_Included_inv _ _ _ H); auto.

 destruct (finite_cardinal _ _ H1) as [n ?].

 exists n; auto.

 intros.

 eapply incl_st_card_lt; eauto.

Qed.



Import ClauseUniverseFinite.



Lemma well_founded_superpose_loop_order: well_founded superpose_loop_order.

Proof.

  apply well_founded_incl

     with  (lexprodx varbound (Strict_Included_Fin _)

                   (fun vb => lex_pair (clause_set_increases vb) unselected_set_decreases)).

 

 intros ? ? ?.

 destruct H.

 apply Included_Strict_Included in H.

 destruct H; [left | right]; auto.

 split; auto.

 apply Finite_var_upto.

  

 apply well_founded_lexprodx.

 apply well_founded_Strict_Included_Fin.

 intro vb.

 apply well_founded_lex_pair.

 apply well_founded_clause_set_increases.

 apply well_founded_unselected_set_decreases.

Qed.



Lemma pures_bound_empty n : pures_bound n [].

Proof. split; [apply Forall_nil|apply NoDup_nil]. Qed.



Lemma pures_bound_nil_nil n : pures_bound n [Eqv Nil Nil].

Proof.

split; [solve[apply Forall_cons; simpl; auto]|].

apply NoDup_cons; simpl; auto. apply NoDup_nil.

Qed.



Hint Resolve pures_bound_empty pures_bound_nil_nil.



Lemma clause_bound_delete_resolved:

  forall n cl, clause_bound' n cl -> clause_bound n (delete_resolved cl).

Proof.

 unfold delete_resolved; destruct cl; simpl; intros; auto;

 try solve [repeat split; simpl; auto; constructor].

 destruct H; unfold pures_bound' in *.

 split; split; try apply NoDup_rsort_uniq; auto.

 apply Forall_sortu.

 clear - H; induction H; simpl; try constructor.

 destruct x; auto. destruct (expr_cmp e e0); try constructor; auto.

 apply Forall_sortu. auto.

Qed.



Lemma pure_bound_norm:

  forall n e1 e2, expr_bound n e1 -> expr_bound n  e2 ->

           pure_bound n (norm_pure_atom (Eqv e1 e2)).

Proof.

 intros. simpl.

 destruct (expr_lt e1 e2); simpl; auto.

Qed.



Lemma pure_bound_rewrite:

  forall n e1 e2 a, expr_bound n e1 -> expr_bound n e2 -> pure_bound n a ->

                pure_bound n (rewrite_by e1 e2 a).

Proof.

unfold rewrite_by; intros.

destruct a; auto.

simpl in H1; destruct H1.

destruct (expr_eq e1 e); destruct (expr_eq e1 e0); try apply pure_bound_norm; auto.

simpl; auto.

Qed.



Lemma pures_bound_sortu_rewrite:

  forall n e1 e2 pi,

        pures_bound' n [Eqv e1 e2] ->

        pures_bound' n pi ->

        pures_bound' n (map (rewrite_by e1 e2) pi).

Proof.

unfold pures_bound'; intros.



inversion H; clear H; subst.

clear H4.

destruct H3.

induction H0; constructor; auto.

apply pure_bound_rewrite; auto.

Qed.



Lemma clause_bound_demodulate:

  forall n c d, clause_bound' n c  -> clause_bound' n d ->

    clause_bound' n (demodulate c d).

Proof.

unfold demodulate; intros.

destruct c; auto.

destruct gamma; auto. destruct delta; auto.

destruct p; auto. destruct delta; auto. destruct d; auto.

simpl in *.

destruct H as [_ ?].

destruct H0.

split; apply pures_bound_sortu_rewrite; auto.

Qed.



Lemma clause_bound'_in:

 forall ss c,

  M.In c (M.union (fst ss) (snd ss)) ->

  clause_bound' (varbound ss) c.

Proof.

  unfold varbound;  simpl; intros. destruct ss; simpl in *.

  remember (M.union t t0) as s; clear t t0 Heqs.

  rewrite <- Melements_spec1  in H.

  revert H; induction (M.elements s); intros.

  inversion H.

  simpl in H. destruct H.

  subst.

  simpl.

  clear.

  apply clause_bound'_more with (var_upto (freshmax_clause c)).

 apply included_var_upto;  apply Ile_var_max1.

  apply clause_bound'_freshmax.

  simpl.

  eapply clause_bound'_more; try apply IHl; auto.

 apply included_var_upto;  apply Ile_var_max2.

Qed.



Lemma remove_trivial_atoms_in:

 forall a pi, List.In a (remove_trivial_atoms pi) -> List.In a pi.

Proof.

 induction pi; simpl; intros; auto.

 destruct a0. destruct (expr_cmp e e0); auto.

 destruct H; auto.

 destruct H; auto.

Qed.



Lemma freshmax_norm:

  forall a, freshmax_pure_atom (norm_pure_atom a) = freshmax_pure_atom a.

Proof. destruct a; simpl. destruct (expr_lt e e0); simpl; auto. apply var_max_com.

Qed.



Ltac fresh_tac :=

   solve [auto]

 || rewrite freshmax_norm in *

 || match goal with

  | H : List.In _ (match ?D with | PureClause _ _ _ _ => _

          | PosSpaceClause _ _ _ => _ | NegSpaceClause _ _ _ => _ end)

     |- _  => destruct D

  | H : List.In _ (match ?D with nil => _ | _ :: _ => _ end) |- _  => destruct D

  | H : List.In _ (match ?D with Eqv _ _ => _ end) |- _  => destruct D

  | H : List.In _ (if ?D then _ else _) |- _ =>

      let H' := fresh in revert H; case_eq D; intros H' H;

           repeat rewrite <- andb_assoc in H';

           try (rewrite andb_true_iff in H'; destruct H' as [H' _])

  | H : expr_eq _ ?e1 = true |- _ => symmetry in H; apply expr_eq_eq' in H;

                                        subst e1

  | H : Ile _ _ |- _ => apply var_max_split' in H; destruct H

  | H : List.In ?c (_ :: _) |- _ => destruct H; [ subst c | ]

  | |- Ile (freshmax_pure_atom (norm_pure_atom _)) _ => unfold norm_pure_atom

  | |- Ile (freshmax_pure_atom (if ?D then _ else _)) _ => destruct D

  end

 || apply freshmax_list_merge

 || simpl freshmax_clause

 || apply Ile_minid

 || apply var_max_intro'

 || (rewrite comp_refl in *; auto)

 || (rewrite freshmax_list_sort; [auto | apply pure_atom_cmp_eq])

 || apply freshmax_insu.



Lemma freshmax_delete_resolved:

  forall c m, Ile (freshmax_clause c) m -> Ile (freshmax_clause (delete_resolved c)) m.

Proof.

 unfold delete_resolved; intros.

 destruct c; repeat fresh_tac; auto.

 clear - H; rewrite  Ile_freshmax_list in *; intros.

 apply H. apply remove_trivial_atoms_in. auto.

Qed.



Lemma freshmax_rewrite_by:

  forall m e e' a, Ile (freshmax_expr e) m -> Ile (freshmax_expr e') m ->

      Ile (freshmax_pure_atom a) m ->

      Ile (freshmax_pure_atom (rewrite_by e e' a)) m.

Proof.

 intros.

 unfold rewrite_by.

 destruct a; auto.

 repeat fresh_tac.

Qed.



Lemma freshmax_demodulate:

  forall a c m, Ile (freshmax_clause a) m -> Ile (freshmax_clause c) m ->

             Ile (freshmax_clause (demodulate a c)) m.

Proof.

 unfold demodulate; intros.

 destruct a; auto. destruct gamma; auto. destruct delta; auto. destruct p; auto.

 destruct delta; auto. destruct c; auto.

 repeat fresh_tac.

 rewrite Ile_freshmax_list in *.

 intros.

  apply Coqlib.list_in_map_inv in H5.

 destruct H5 as [a [? ?]]; subst x.

  apply freshmax_rewrite_by; auto.

 rewrite Ile_freshmax_list in *.

 intros.

  apply Coqlib.list_in_map_inv in H5.

 destruct H5 as [a [? ?]]; subst x.

  apply freshmax_rewrite_by; auto.

Qed.



Lemma varbound_remove:

  forall s x s', Included _ (varbound (s, M.remove x s')) (varbound (s, s')).

Proof.

 unfold varbound; intros.

 simpl.

 intros ? ?; unfold In, var_upto in *.

 remember (freshmax_list freshmax_clause (M.elements (M.union s s')))  as m.

 assert (forall c, M.In c (M.union s s') -> Ile (freshmax_clause c) m).

  subst; clear; intros.

  rewrite <- Melements_spec1 in H.

  revert H; induction (M.elements (M.union s s')); intros.

  inversion H.

  simpl in H. destruct H. subst.

  simpl.

  apply Ile_var_max1.

  simpl. eapply Ile_trans; try apply IHl; auto.

  apply Ile_var_max2.

  eapply Ile_trans; try apply H.

  clear - H0.

  apply Ile_freshmax_i3; intros.

  apply H0; clear H0.

  rewrite M.union_spec in *.

  intuition.

  right. rewrite M.remove_spec in H0; intuition.

Qed.



Lemma freshmax_simplify:

  forall m l g, (forall c : M.elt, List.In c l -> Ile (freshmax_clause c) m) ->

    Ile (freshmax_clause g) m ->

   Ile (freshmax_clause (simplify l g)) m.

Proof.

 intros.

 unfold simplify.

 apply freshmax_delete_resolved.

 revert H g H H0; induction l; simpl; intros; auto.

 apply IHl; auto.

 apply freshmax_demodulate; auto.

Qed.



Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)



Lemma freshmax_sp:

  forall m d a l,

    Ile (freshmax_clause d) m ->

    Ile (freshmax_clause a) m ->

    (forall c, List.In c l -> Ile (freshmax_clause c) m) ->

    forall c, List.In c (sp d a l) -> Ile (freshmax_clause c) m.

Proof.

  intros.

  unfold sp in H2.

  repeat fresh_tac.

  destruct delta; auto; destruct p; auto.

  if_tac in H2; auto.

  destruct H2; auto. rewrite <-H2.

  repeat fresh_tac; auto.

Qed.



Lemma freshmax_superpose:

  forall m d a l,

    Ile (freshmax_clause d) m ->

    Ile (freshmax_clause a) m ->

    (forall c, List.In c l -> Ile (freshmax_clause c) m) ->

    forall c, List.In c (superpose d a l) -> Ile (freshmax_clause c) m.

Proof.

 intros.

 unfold superpose in H2.

 eapply freshmax_sp; try apply H2; eauto.

 intros.

 eapply freshmax_sp; try apply H3; eauto.

Qed.



Lemma freshmax_infer_list:

  forall d l m,

        Ile (freshmax_clause d) m ->

        (forall c, List.In c l -> Ile (freshmax_clause c) m) ->

        forall c, List.In c (infer_list d l) -> Ile (freshmax_clause c) m.

Proof.

 intros.

 unfold infer_list in H1.  autounfold with DEBUG_UNFOLD in *.

 rewrite filter_In in H1. destruct H1 as [H1 _].

 apply Coqlib.list_in_map_inv in H1.

 destruct H1 as [c' [? ?]].

 subst c. apply freshmax_simplify; auto.

 remember (@nil clause) as b.

 assert (forall c, List.In c b -> Ile (freshmax_clause c) m).

 subst b; intros. inversion H1.

 clear Heqb.

 revert b H0 H1 H2; induction l; simpl; intros; auto.

 apply (IHl (superpose d a b)); auto.

 apply freshmax_superpose; auto.

Qed.



Lemma varbound_nonincreasing: forall given unselected giv,

  M.In giv unselected ->

 Included _ (varbound

  (M.add (simplify (M.elements given) giv) given,

  fold_left

    (fun (s0 : M.t) (c : M.elt) =>

     if M.mem c (M.add (simplify (M.elements given) giv) given)

     then s0

     else M.add c s0)

    (infer_list (simplify (M.elements given) giv)

       (simplify (M.elements given) giv :: M.elements given))

    (M.remove giv unselected)))

    (varbound (given, unselected)).

Proof.

  intros.

  unfold varbound.

  simpl.

  apply included_var_upto.

  remember (freshmax_list freshmax_clause (M.elements (M.union given unselected)))

    as m.

  assert (forall c, M.In c (M.union given unselected) -> Ile (freshmax_clause c) m).

  subst; clear; intros.

  rewrite <- Melements_spec1 in H.

  revert H; induction (M.elements (M.union given unselected)); intros.

  inversion H.

  simpl in H. destruct H. subst.

  simpl.

  apply Ile_var_max1.

  simpl. eapply Ile_trans; try apply IHl; auto.

  apply Ile_var_max2.

  clear - H H0.

  apply Ile_freshmax_i3; intros.

  rewrite M.union_spec in H1.

  assert (forall c, List.In c (M.elements given) -> Ile (freshmax_clause c) m).

  intros. apply H0. rewrite M.union_spec; left. rewrite Melements_spec1 in H2; auto.

  destruct H1.

  rewrite M.add_spec in H1.

  destruct H1. subst.

  assert (Ile (freshmax_clause giv) m).

  apply H0. rewrite M.union_spec; auto.

  remember (M.elements given) as l;

  clear - H1 H2.

  apply freshmax_simplify; auto.

  apply H0. rewrite M.union_spec; auto.

  assert (forall c, M.In c (M.remove giv unselected) -> Ile (freshmax_clause c) m).

  intros; apply H0. rewrite M.union_spec; right. rewrite M.remove_spec in H3; intuition.

  remember (M.remove giv unselected) as J.

  assert (Ile (freshmax_clause giv) m).

  apply H0. rewrite M.union_spec; right; auto.

  remember (M.elements given) as givl.

  remember (M.add (simplify givl giv) given) as foo.

  clear - H1 H2 H3 H4.

  assert (Ile (freshmax_clause (simplify givl giv)) m).

  clear - H4 H2.

  apply freshmax_simplify; auto.

  remember (simplify givl giv) as d; clear - H H1 H2 H3.

  assert (forall c, List.In c (infer_list d (d :: givl)) -> Ile (freshmax_clause c) m).

  apply freshmax_infer_list; auto.

  intros. destruct H0; auto. subst; auto.

  remember (infer_list d (d :: givl)) as dl; clear givl Heqdl H2 d H.

  revert J H1 H3 H0; induction dl; simpl; intros; auto.

  destruct (M.mem a foo).

  eapply IHdl; eauto.

  eapply IHdl; eauto.

  intros.

  rewrite M.add_spec in H.

  destruct H.

  subst c. auto.

  apply H3; auto.

Qed.



Lemma varbound_nonincreasing': forall given unselected giv,

  M.In giv unselected ->

  Included _ (varbound

  (M.add (simplify (M.elements given) giv) given,

  fold_left

    (fun (s0 : M.t) (c : M.elt) =>

     if M.mem c (M.add (simplify (M.elements given) giv) given)

     then s0

     else M.add c s0)

    (infer_list (simplify (M.elements given) giv)

       (M.elements given))

    (M.remove giv unselected)))

   (varbound (given, unselected)).

Proof.

  intros.

  unfold varbound.

  simpl.

  apply included_var_upto.

  remember (freshmax_list freshmax_clause (M.elements (M.union given unselected)))

    as m.

  assert (forall c, M.In c (M.union given unselected) -> Ile (freshmax_clause c) m).

  subst; clear; intros.

  rewrite <- Melements_spec1 in H.

  revert H; induction (M.elements (M.union given unselected)); intros.

  inversion H.

  simpl in H. destruct H. subst.

  simpl.

  apply Ile_var_max1.

  simpl. eapply Ile_trans; try apply IHl; auto.

  apply Ile_var_max2.

  clear - H H0.

  apply Ile_freshmax_i3; intros.

  rewrite M.union_spec in H1.

  assert (forall c, List.In c (M.elements given) -> Ile (freshmax_clause c) m).

  intros. apply H0. rewrite M.union_spec; left. rewrite Melements_spec1 in H2; auto.

  destruct H1.

  rewrite M.add_spec in H1.

  destruct H1. subst.

  assert (Ile (freshmax_clause giv) m).

  apply H0. rewrite M.union_spec; auto.

  remember (M.elements given) as l;

  clear - H1 H2.

  apply freshmax_simplify; auto.

  apply H0. rewrite M.union_spec; auto.

  assert (forall c, M.In c (M.remove giv unselected) -> Ile (freshmax_clause c) m).

  intros; apply H0. rewrite M.union_spec; right. rewrite M.remove_spec in H3; intuition.

  remember (M.remove giv unselected) as J.

  assert (Ile (freshmax_clause giv) m).

  apply H0. rewrite M.union_spec; right; auto.

  remember (M.elements given) as givl.

  remember (M.add (simplify givl giv) given) as foo.

  clear - H1 H2 H3 H4.

  assert (Ile (freshmax_clause (simplify givl giv)) m).

  clear - H4 H2.

  apply freshmax_simplify; auto.

  remember (simplify givl giv) as d; clear - H H1 H2 H3.

  assert (forall c, List.In c (infer_list d (givl)) -> Ile (freshmax_clause c) m).

  apply freshmax_infer_list; auto.

  remember (infer_list d (givl)) as dl; clear d givl Heqdl H2 H.

  revert J H1 H3 H0; induction dl; simpl; intros; auto.

  destruct (M.mem a foo).

  eapply IHdl; eauto.

  eapply IHdl; eauto.

  intros.

  rewrite M.add_spec in H.

  destruct H.

  subst c. auto.

  apply H3; auto.

Qed.



Lemma simplify_nodup:

   forall n l c,

     clause_bound' n (simplify l c) ->

     clause_bound n (simplify l c).

Proof.

 unfold simplify, delete_resolved; simpl; intros.

 destruct (fold_left  (fun d c : clause => demodulate c d) l c);

 unfold clause_bound; simpl in *.

 destruct H.

 split; split; auto;  apply NoDup_rsort_uniq; auto.

 destruct H; split; split; auto; constructor; auto. apply NoDup_nil.

 destruct H; split; split; auto; constructor; auto. apply NoDup_nil.

Qed.



Lemma one_inference_step_order:

       forall given unselected new_given  new_unselected,

       M.mem empty_clause unselected = false ->

       M.is_empty new_unselected = false ->

       one_inference_step (given, unselected) = (new_given, new_unselected) ->

       superpose_loop_order (new_given, new_unselected) (given, unselected).

 Proof.

  unfold one_inference_step; intros.

  rewrite mem_spec' in H. rewrite is_empty_spec' in H0.

  revert H1; case_eq (M.delete_min unselected); intros.

Focus 2.

  rewrite M.delete_min_spec2 in H1.

  symmetry in H2;   inversion H2; clear H2; subst.

  contradiction.

 

  destruct p as [giv uns].

  rewrite M.delete_min_spec1 in H1.

  destruct H1.   subst uns.

  apply M.min_elt_spec1 in H1.

  autounfold with DEBUG_UNFOLD in *.

  destruct (is_pure_clause giv).

 Focus 2.

  symmetry in H2; inversion H2; clear H2; subst.

  split. apply varbound_remove.

  simpl. right; split; auto.

  apply remove_decreases; auto.

  rewrite mem_add_spec in H2.

  destruct (not_taut giv); simpl in H2.

  revert H2; case_eq (M.mem  (simplify (M.elements given) giv) given); intros.

  symmetry in H3; inversion H3; clear H3; subst.

  split. apply varbound_remove.

  right; simpl; split; auto.

  apply remove_decreases; auto.

  inversion H3; clear H3; subst.

  clear H0.

  match goal with |- superpose_loop_order ?SS _ => remember SS as ss end.

  split.

  subst ss; clear - H1.

 apply varbound_nonincreasing'; auto.

  left.

  unfold clause_set_increases.

  destruct (finite_cardinal _ _ ( Intersection_preserves_finite _

                      _ (clause_bound_finite (varbound ss) (Finite_var_upto _))

         (Basics.flip M.In (M.add (simplify (M.elements given) giv) given)))) as [n ?].

  destruct (finite_cardinal _ _ ( Intersection_preserves_finite _

                      _ (clause_bound_finite (varbound ss) (Finite_var_upto _))

         (Basics.flip M.In given))) as [n' ?].

  destruct (finite_cardinal _ _ (clause_bound_finite (varbound ss) (Finite_var_upto _)))

     as [N ?].

  assert (N>=n) by (eapply incl_card_le; eauto;  intros ? [? ?]; auto).

  assert (N>=n') by (eapply incl_card_le; eauto;  intros ? [? ?]; auto).

  exists (N-n); exists (N-n').

  assert (clause_bound (varbound ss) (simplify (M.elements given) giv)).

  apply simplify_nodup.

  apply clause_bound'_in.

  rewrite M.union_spec. left. rewrite Heqss. simpl.

  rewrite M.add_spec. left. auto.

  split; [|split]; auto.

  rewrite Heqss at 2; simpl.

  unfold headroom.

  exists n. split; auto.

  replace (n+(N-n)) with N by omega. auto.

  exists n'; split; auto.

  replace (n'+(N-n')) with N by omega. auto.

  assert (n>n'); [ | omega].

   eapply (incl_st_card_lt); eauto.

  split.

   intros ? [? ?]. unfold In in *.

   split; auto.

    unfold In, Basics.flip in *. rewrite M.add_spec. auto.

   remember  (simplify (M.elements given) giv) as c.

   rewrite mem_spec' in H2.

   clear - H7 H2.

   intro H.

   match type of H with ?A = ?B => assert (A c) end.

   rewrite H.

   split; auto.

    unfold In, Basics.flip; rewrite M.add_spec. left.

    auto.

   destruct H0. unfold In, Basics.flip in H0; contradiction.

 

 inversion H2; subst. split; auto. apply varbound_remove.

 right; simpl; split; auto. apply remove_decreases; auto.

Qed.



Function loop (given_unselected : M.t*M.t)

  {wf superpose_loop_order given_unselected}

  : superposition_result * M.t*M.t :=

  let (given, unselected) := given_unselected in

    if M.mem empty_clause given || M.mem empty_clause unselected

    then (Valid, given, unselected)

    else match one_inference_step (given, unselected) with

         | (new_given, new_unselected) =>

           if M.is_empty new_unselected

             then let (R, selected) := clauses_generate nil

                 (rsort_uniq (rev_cmp compare_clause) (M.elements new_given)) in

               (C_example R selected, new_given, new_unselected)

             else loop (new_given, new_unselected)

         end.

Proof.

  intros.

  subst. eapply one_inference_step_order; eauto.

  rewrite orb_false_iff in teq0; destruct teq0 as [_ H]; auto.

  apply well_founded_superpose_loop_order.

Defined.



Definition purecnf (en: entailment) : M.t :=

  match en with

    Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>

    match mk_pureR pureL, mk_pureR pureR with (p, n), (p', n') =>

      let pureplus :=

        map (fun a => mkPureClause nil (norm_pure_atom a::nil)) p in

      let pureminus :=

        map (fun a => mkPureClause (norm_pure_atom a::nil) nil) n in

      let pureplus' := rsort_uniq pure_atom_cmp (map norm_pure_atom p') in

      let pureminus' := rsort_uniq pure_atom_cmp (map norm_pure_atom n') in

      let cl := mkPureClause pureplus' pureminus' in

        clause_list2set (cl :: pureplus ++ pureminus)

    end

  end.



Definition check (ent : entailment) : superposition_result * M.t*M.t :=

  loop (M.empty, purecnf ent).



Definition check_clauseset (s : M.t) : superposition_result * M.t*M.t :=

  loop (M.empty, M.filter not_taut s).



End Superposition.

