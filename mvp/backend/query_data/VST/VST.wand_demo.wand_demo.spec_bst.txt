Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VFA.Maps.

Require Import VFA.SearchTree.

Require Import WandDemo.SearchTree_ext.

Require Import WandDemo.bst.

Require Import WandDemo.bst_lemmas.



Definition mallocN_spec :=

 DECLARE _mallocN

  WITH n: Z

  PRE [ 1%positive OF tint]

     PROP (4 <= n <= Int.max_unsigned)

     LOCAL (temp 1%positive (Vint (Int.repr n)))

     SEP ()

  POST [ tptr tvoid ]

     EX v: val,

     PROP (malloc_compatible n v)

     LOCAL (temp ret_temp v)

     SEP (memory_block Tsh n v).



Definition freeN_spec :=

 DECLARE _freeN

  WITH p : val , n : Z

  PRE [ 1%positive OF tptr tvoid , 2%positive OF tint]

     

      PROP() LOCAL (temp 1%positive p; temp 2%positive (Vint (Int.repr n)))

      SEP (memory_block Tsh n p)

  POST [ tvoid ]

    PROP () LOCAL () SEP ().



Definition insert_spec :=

 DECLARE _insert

  WITH p0: val, x: nat, v: val, m0: total_map val

  PRE  [ _p OF (tptr (tptr t_struct_tree)), _x OF tint,

        _value OF (tptr Tvoid)   ]

    PROP( Int.min_signed <= Z.of_nat x <= Int.max_signed; is_pointer_or_null v)

    LOCAL(temp _p p0; temp _x (Vint (Int.repr (Z.of_nat x))); temp _value v)

    SEP (Mapbox_rep m0 p0)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (Mapbox_rep (t_update m0 x v) p0).



Definition lookup_spec :=

 DECLARE _lookup

  WITH p0: val, x: nat, v: val, m0: total_map val

  PRE  [ _p OF (tptr t_struct_tree), _x OF tint  ]

    PROP( Int.min_signed <= Z.of_nat x <= Int.max_signed)

    LOCAL(temp _p p0; temp _x (Vint (Int.repr (Z.of_nat x))))

    SEP (Map_rep m0 p0)

  POST [ tptr Tvoid ]

    PROP()

    LOCAL(temp ret_temp (m0 x))

    SEP (Map_rep m0 p0).



Definition turn_left_spec :=

 DECLARE _turn_left

  WITH ta: tree val, x: nat, vx: val, tb: tree val, y: nat, vy: val, tc: tree val, b: val, l: val, pa: val, r: val

  PRE  [ __l OF (tptr (tptr (Tstruct _tree noattr))),

        _l OF (tptr (Tstruct _tree noattr)),

        _r OF (tptr (Tstruct _tree noattr))]

    PROP(Int.min_signed <= Z.of_nat x <= Int.max_signed; is_pointer_or_null vx)

    LOCAL(temp __l b; temp _l l; temp _r r)

    SEP (data_at Tsh (tptr t_struct_tree) l b;

         data_at Tsh t_struct_tree (Vint (Int.repr (Z.of_nat x)), (vx, (pa, r))) l;

         tree_rep ta pa;

         tree_rep (T tb y vy tc) r)

  POST [ Tvoid ] 

    EX pc: val,

    PROP(Int.min_signed <= Z.of_nat y <= Int.max_signed; is_pointer_or_null vy)

    LOCAL()

    SEP (data_at Tsh (tptr t_struct_tree) r b;

         data_at Tsh t_struct_tree (Vint (Int.repr (Z.of_nat y)), (vy, (l, pc))) r;

         tree_rep (T ta x vx tb) l;

         tree_rep tc pc).



Definition pushdown_left_spec :=

 DECLARE _pushdown_left

  WITH ta: tree val, x: nat, v: val, tb: tree val, b: val, p: val

  PRE  [ _t OF (tptr (tptr (Tstruct _tree noattr)))]

    PROP(Int.min_signed <= Z.of_nat x <= Int.max_signed; tc_val (tptr Tvoid) v)

    LOCAL(temp _t b)

    SEP (data_at Tsh (tptr t_struct_tree) p b;

         field_at Tsh t_struct_tree [StructField _key] (Vint (Int.repr (Z.of_nat x))) p;

         field_at Tsh t_struct_tree [StructField _value] v p;

         treebox_rep ta (field_address t_struct_tree [StructField _left] p);

         treebox_rep tb (field_address t_struct_tree [StructField _right] p))

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (treebox_rep (pushdown_left ta tb) b).



Definition delete_spec :=

 DECLARE _delete

  WITH b: val, x: nat, t: tree val

  PRE  [ _t OF (tptr (tptr t_struct_tree)), _x OF tint]

    PROP( Int.min_signed <= Z.of_nat x <= Int.max_signed)

    LOCAL(temp _t b; temp _x (Vint (Int.repr (Z.of_nat x))))

    SEP (treebox_rep t b)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (treebox_rep (delete x t) b).



Definition Gprog : funspecs :=

    ltac:(with_library prog [

    mallocN_spec; freeN_spec;

    insert_spec; lookup_spec;

    turn_left_spec; pushdown_left_spec; delete_spec

  ]).



