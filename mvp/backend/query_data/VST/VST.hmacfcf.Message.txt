

Set Implicit Arguments.



Require Import Bvector.

Require Import EqDec.
(* EqDec:
Set Implicit Arguments.
Require Import Bvector.
Require Import Arith.

Definition eq_dec(A : Set) := forall (a1 a2 : A), {a1 = a2} + {a1 <> a2}.

Class EqDec (A : Set) := {
  eqb : A -> A -> bool ;
  eqb_leibniz : forall x y, eqb x y = true <-> x = y 
}.

Infix "?=" := eqb (at level 70) : eq_scope.
Infix "!=" := (fun x y => negb (eqb x y)) (at level 70) : eq_scope.

Theorem eqb_refl : forall (A : Set)(pf : EqDec A)(a : A),
  eqb a a = true.

Theorem eqb_symm : 
  forall (A : Set){eqd : EqDec A}(x y : A),
    eqb x y = eqb y x.

Theorem EqDec_dec : forall A,
  EqDec A ->
  forall (a b : A), {a = b} + {a <> b}.

Theorem dec_EqDec : forall (A : Set)(eqd : eq_dec A),
  EqDec A.

Lemma vector_0 : forall (A : Set)(v : Vector.t A 0),

Lemma vector_S : forall (A : Set)(n : nat)(v : Vector.t A (S n)),
  
Definition eqb_vector(A : Set)(eqd : EqDec A)(n : nat)(v1 v2 : Vector.t A n) :=
  Vector.fold_left2 (fun b a1 a2 => b && (eqb a1 a2)) true v1 v2.

Theorem eqb_vector_refl : 
  forall (A : Set)(eqd : EqDec A)(n : nat)(v : Vector.t A n),

Theorem vector_fold_false : 
  forall (A : Set)(f : A -> A -> bool)(n : nat)(v1 v2 : Vector.t A n),

Theorem eqb_vector_leibniz:
  forall (A : Set)(eqd : EqDec A)(n : nat)(v1 v2 : Vector.t A n),

Definition eqbBvector n (v1 v2 : Bvector n) : bool :=
  (eqb_vector _ v1 v2).

Theorem eqbBvector_sound : forall n (v1 v2 : Bvector n),
  eqbBvector v1 v2 = true -> v1 = v2.

Theorem eqbBvector_complete : forall n (v : Bvector n),
  eqbBvector v v = true.

Definition eqbPair (A B : Set)(dA : EqDec A)(dB : EqDec B)(p1 p2 : (A*B)) :=
  (eqb (fst p1) (fst p2)) && (eqb (snd p1) (snd p2)).

Definition eqbSum(A B : Set)(dA : EqDec A)(dB : EqDec B)(s1 s2 : (A + B)) :=
  match s1 with
    | inl a1 =>
    match s2 with
      | inl a2 => eqb a1 a2
      | inr b2 => false
    end
    | inr b1 =>
    match s2 with
      | inl a2 => false
      | inr b2 => eqb b1 b2
    end
  end.

Definition eqbOption (A : Set)(dA : EqDec A)(o1 o2 : option A) :=
  match o1 with
    | None => 
      match o2 with
        | None => true
        | Some _ => false
      end
    | Some a1 =>
      match o2 with
        | None => false
        | Some a2 => (eqb a1 a2)
      end
  end.

Local Open Scope list_scope.
Fixpoint eqbList(A : Set)(eqd : EqDec A)(ls1 ls2 : list A) :=
  match ls1 with
    | nil => 
      match ls2 with
        | nil => true
        | _ :: _ => false
      end
    | a1 :: ls1' =>
      match ls2 with
        | nil => false 
        | a2 :: ls2' =>
          (eqb a1 a2) && (eqbList _ ls1' ls2')
      end
  end.

Lemma eqbList_correct1 : forall (A : Set)(eqd : EqDec A) ls1 ls2,
  eqbList eqd ls1 ls2 = true -> 
  ls1 = ls2.

Lemma eqbList_correct2 : forall (A : Set)(eqd : EqDec A) ls1 ls2,
  ls1 = ls2 -> 
  eqbList eqd ls1 ls2 = true.

Theorem eqb_false_iff : 
  forall (A : Set)(eqd : EqDec A)(a1 a2 : A),
    eqb a1 a2 = false <->
    a1 <> a2.

Theorem eqbPair_symm : 
  forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (p1 p2 : (A * B)),
    eqbPair _ _ p1 p2 = eqbPair _ _ p2 p1. *)



Local Open Scope type_scope.



Section HMAC_Message.



  Variable word_size max_size : nat.



  Definition Message := nat * Vector.t (Bvector word_size) max_size.



  Instance Message_EqDec : EqDec Message.



  eapply pair_EqDec;  eauto with typeclass_instances.

  eapply Vector_EqDec.

  eapply Vector_EqDec.

  eauto with typeclass_instances.



  Qed.



End HMAC_Message.
