Require Import sepcomp.compcert. Import CompcertAll.

Require Import msl.Axioms.
(* msl.Axioms:
Require Coq.Logic.ClassicalFacts.

Require Export Coq.Logic.FunctionalExtensionality.

Lemma extensionality:
  forall (A B: Type) (f g : A -> B),  (forall x, f x = g x) -> f = g.

Arguments extensionality [A B] _ _ _.

Axiom prop_ext: ClassicalFacts.prop_extensionality.
Arguments prop_ext [A B] _.

Lemma proof_irr: ClassicalFacts.proof_irrelevance.
Proof.
  exact (ClassicalFacts.ext_prop_dep_proof_irrel_cic prop_ext).
Arguments proof_irr [A] _ _. *)

Require Import sepcomp.step_lemmas.
(* sepcomp.step_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.

Require Import compcert.common.AST.
Require Import compcert.common.Values.

Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Definition has_opttyp (v : option val) (t : option typ) :=
  match v, t with
    None, None => True
  | Some v, Some t => Val.has_type v t
  | _, _ => False
  end.

Section safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context {Hrel: nat -> M -> M -> Prop}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).

  Variable ge : G.

  Inductive safeN_ : nat -> Z -> C -> M -> Prop :=
  | safeN_0: forall z c m, safeN_ O z c m
  | safeN_step:
      forall n z c m c' m',
      corestep Hcore c m c' m' ->
      safeN_ n z c' m' ->
      safeN_ (S n) z c m
  | safeN_external:
      forall n z c m e args x,
      at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           after_external Hcore ret c m' = Some c' /\
           safeN_ n' z' c' m') ->
      safeN_ (S n) z c m
  | safeN_halted:
      forall n z c m i,
      halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      safeN_ n z c m.

  Definition corestep_fun  :=
       forall m q m1 q1 m2 q2 ,
       corestep Hcore q m q1 m1 ->
       corestep Hcore q m q2 m2 ->
       (q1, m1) = (q2, m2).

  Lemma safe_corestep_forward:
     corestep_fun ->
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ (S n) z c m -> safeN_ n z c' m'.

  Lemma safe_corestep_backward:
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ n z c' m' -> safeN_ (S n) z c m.

  Lemma safe_downward1 :
    forall n c m z,
      safeN_ (S n) z c m -> safeN_ n z c m.

  Lemma safe_downward :
    forall n n' c m z,
      le n' n ->
      safeN_ n z c m -> safeN_ n' z c m.

  Lemma safe_corestepN_forward:
    corestep_fun ->
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n + S n0) z c m ->
      safeN_ n z c' m'.

  Lemma safe_step'_back2 :
    forall
      {ora st m st' m' n},
      corestep Hcore st m st' m' ->
      safeN_ (n-1) ora st' m' ->
      safeN_ n ora st m.

  Lemma safe_corestepN_backward:
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n - n0) z c' m' ->
      safeN_ n z c m.

  Lemma convergent_controls_safe :
    forall m q1 q2,
      (at_external Hcore q1 m = at_external Hcore q2 m) ->
      (forall ret m q', after_external Hcore ret q1 m = Some q' ->
                      after_external Hcore ret q2 m = Some q') ->
      (halted Hcore q1 = halted Hcore q2) ->
      (forall q' m', corestep Hcore q1 m q' m' ->
                     corestep Hcore q2 m q' m') ->
      (forall n z, safeN_ n z q1 m -> safeN_ n z q2 m).

  Lemma wlog_safeN_gt0 : forall
    n z q m,
    (lt 0 n -> safeN_ n z q m) ->
    safeN_ n z q m.

End safety.

Section dry_safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).
  Definition dry_safeN := @safeN_ G C M Z genv_symb (fun n' m m' => True) Hcore Hspec.
End dry_safety. *)
Require Import sepcomp.mem_lemmas. 
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)
Require Import sepcomp.core_semantics.
Require Import sepcomp.effect_semantics.
(* sepcomp.effect_semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Record EffectSem {C} :=
  { 
    sem :> @MemSem C

  ; effstep: (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop

  ; effax1: forall M c m c' m',
       effstep M c m c' m' ->
            corestep sem c m c' m'
         /\ Mem.unchanged_on (fun b ofs => M b ofs = false) m m'
  ; effax2: forall c m c' m',
       corestep sem c m c' m' ->
       exists M, effstep M c m c' m'
  ; effstep_perm: forall M c m c' m',
       effstep M c m c' m' ->
       forall b z, M b z = true -> Mem.perm m b z Cur Writable
  }.

Section effsemlemmas.
  Context {C:Type} (Sem: @EffectSem C).

  Lemma effstep_valid: forall M c m c' m',
       effstep Sem M c m c' m' ->
       forall b z, M b z = true -> Mem.valid_block m b.

  Lemma effstep_corestep: forall M c m c' m',
      effstep Sem M c m c' m' -> corestep Sem c m c' m'.

  Lemma effstep_unchanged: forall M c m c' m',
        effstep Sem M c m c' m' ->
        Mem.unchanged_on (fun b ofs => M b ofs = false) m m'.

  Lemma effstep_mem U c m c' m' (EF: effstep Sem U c m c' m'): mem_step m m'.

  Lemma effstep_fwd U c m c' m' (EF: effstep Sem U c m c' m'): mem_forward m m'.

  Fixpoint effstepN (n:nat) : (block -> Z -> bool) -> C -> mem -> C -> mem -> Prop :=
    match n with
      | O => fun U c m c' m' => (c,m) = (c',m') /\ U = (fun b z => false)
      | S k => fun U c1 m1 c3 m3 => exists c2, exists m2, exists U1, exists U2,
        effstep Sem U1 c1 m1 c2 m2 /\
        effstepN k U2 c2 m2 c3 m3 /\
        U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b))
    end.

  Lemma effstepN_perm: forall n U c1 m1 c2 m2, effstepN n U c1 m1 c2 m2 ->
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.
  Lemma effstepN_valid n U c1 m1 c2 m2  (Step:effstepN n U c1 m1 c2 m2)
        b z (EFF:U b z = true): Mem.valid_block m1 b.

  Lemma effstepN_mem: forall n U c m c' m' (EF: effstepN n U c m c' m'), mem_step m m'.

  Lemma effstepN_fwd n U c m c' m' (EF:effstepN n U c m c' m'): mem_forward m m'.

  Lemma effstepN_corestepN: forall n E c m c' m',
      effstepN n E c m c' m' -> corestepN Sem n c m c' m'.

  Lemma effstepN_unchanged: forall n U c1 m1 c2 m2,
        effstepN n U c1 m1 c2 m2 ->
        Mem.unchanged_on (fun b z => U b z = false) m1 m2.

Lemma effstepN_trans: forall n1 n2 U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
   effstepN (n1+n2)
        (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) st1 m1 st3 m3.

Lemma effstepN_trans': forall n1 n2 U U1 st1 m1 st2 m2 U2 st3 m3,
      effstepN n1 U1 st1 m1 st2 m2 ->
      effstepN n2 U2 st2 m2 st3 m3 ->
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
   effstepN (n1+n2) U st1 m1 st3 m3.

  Definition effstep_plus U c m c' m' :=
    exists n, effstepN (S n) U c m c' m'.

  Definition effstep_star U c m c' m' :=
    exists n, effstepN n U c m c' m'.

  Lemma effstep_plus_corestep_plus U c m c' m' (EFF: effstep_plus U c m c' m'):
        corestep_plus Sem c m c' m'.

  Lemma effstep_star_corestep_star U c m c' m' (EFF: effstep_star U c m c' m'):
        corestep_star Sem c m c' m'.

  Lemma effstep_plus_star : forall U c1 c2 m1 m2,
    effstep_plus U c1 m1 c2 m2 -> effstep_star U c1 m1 c2 m2.

  Lemma effstep_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_plus_trans : forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_plus_trans' : forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_plus U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_plus_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_plus_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_plus U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_plus U c1 m1 c3 m3.

  Lemma effstep_star_trans: forall U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    effstep_star (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) c1 m1 c3 m3.
  Lemma effstep_star_trans': forall U U1 c1 c2 c3 U2 m1 m2 m3,
    effstep_star U1 c1 m1 c2 m2 -> effstep_star U2 c2 m2 c3 m3 ->
    U = (fun b z => U1 b z || (U2 b z && valid_block_dec m1 b)) ->
    effstep_star U c1 m1 c3 m3.

  Lemma effstep_plus_one: forall U c m c' m',
    effstep Sem U c m c' m' -> effstep_plus U c m c' m'.

  Lemma effstep_plus_two: forall U1 c m c' m' U2 c'' m'',
    effstep  Sem U1 c m c' m' -> effstep Sem U2 c' m' c'' m'' ->
    effstep_plus (fun b z => U1 b z || (U2 b z && valid_block_dec m b)) c m c'' m''.

  Lemma effstep_star_zero: forall c m, effstep_star (fun b z =>false) c m c m.

  Lemma effstep_star_one: forall U c m c' m',
    effstep  Sem U c m c' m' -> effstep_star U c m c' m'.

  Lemma effstep_plus_split: forall U c m c' m',
    effstep_plus U c m c' m' ->
    exists c'', exists m'', exists U1, exists U2,
      effstep Sem U1 c m c'' m'' /\
      effstep_star U2 c'' m'' c' m' /\
      U = (fun b z => U1 b z || (U2 b z && valid_block_dec m b)).

  Lemma effstep_plus_perm U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_star_perm U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.perm m1 b z Cur Writable.

  Lemma effstep_plus_valid U c1 m1 c2 m2 (Step: effstep_plus U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_valid U c1 m1 c2 m2 (Step: effstep_star U c1 m1 c2 m2):
       forall b z, U b z = true -> Mem.valid_block m1 b.

  Lemma effstep_star_mem U c m c' m' (EF: effstep_star U c m c' m'): mem_step m m'.

  Lemma effstep_plus_mem U c m c' m' (EF: effstep_plus U c m c' m'): mem_step m m'.

  Lemma effstep_plus_fwd U c m c' m' (EF: effstep_plus U c m c' m'): mem_forward m m'.
  Lemma effstep_star_fwd U c m c' m' (EF: effstep_star U c m c' m'): mem_forward m m'.

End effsemlemmas.

Definition EmptyEffect: Values.block -> Z -> bool := fun b z => false.

Lemma EmptyEffect_alloc: forall m lo hi m' b (ALLOC: Mem.alloc m lo hi = (m', b)),

Definition FreeEffect m lo hi (sp b:Values.block) (ofs:Z): bool :=
   if valid_block_dec m b
   then eq_block b sp && zle lo ofs && zlt ofs hi
   else false.

Lemma FreeEffectD: forall m lo hi sp b z
   (FREE:FreeEffect m lo hi sp b z = true),
   b = sp /\ Mem.valid_block m b /\ lo <= z /\ z < hi.

Lemma FreeEffect_free: forall m sp lo hi m'
             (FREE: Mem.free m sp lo hi = Some m'),

Definition FreelistEffect
  m (L: list (Values.block * Z * Z)) (b:Values.block) (ofs:Z): bool :=
  List.fold_right (fun X E b z => match X with (bb,lo,hi) =>
                                   E b z || FreeEffect m lo hi bb b z
                                 end)
                  EmptyEffect L b ofs.

Lemma FreelistEffect_Dfalse: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = false),
      FreelistEffect m L b ofs = false /\
      FreeEffect m lo hi bb b ofs = false.

Lemma FreelistEffect_Dtrue: forall m bb lo hi L b ofs
      (F:FreelistEffect m ((bb, lo, hi) :: L) b ofs = true),
      FreelistEffect m L b ofs = true \/
      FreeEffect m lo hi bb b ofs = true.

Lemma FreelistEffect_same: forall m bb lo hi mm L
          (F:Mem.free m bb lo hi = Some mm)

Lemma FreelistEffect_freelist: forall L m m' (FL: Mem.free_list m L = Some m'),

Lemma FreeEffect_validblock: forall m lo hi sp b ofs
        (EFF: FreeEffect m lo hi sp b ofs = true),
      Mem.valid_block m b.

Lemma FreelistEffect_validblock: forall l m b ofs
        (EFF: FreelistEffect m l b ofs = true),
      Mem.valid_block m b.

Definition StoreEffect (tv:val)(vl : list memval) (b:Values.block) (z:Z):bool :=
  match tv with Vptr bb ofs => eq_block bb b &&
             zle (Ptrofs.unsigned ofs) z && zlt z (Ptrofs.unsigned ofs + Z.of_nat (length vl))
         | _ => false
  end.

Lemma StoreEffect_Storev: forall m chunk tv tv' m'
         (STORE : Mem.storev chunk m tv tv' = Some m'),

Lemma StoreEffectD: forall vaddr v b ofs
      (STE: StoreEffect vaddr v b ofs = true),
      exists i, vaddr = Vptr b i /\
        (Ptrofs.unsigned i) <= ofs < (Ptrofs.unsigned i + Z.of_nat (length v)).

Lemma free_curWR m sp lo hi m' (FR: Mem.free m sp lo hi = Some m')

Lemma storev_curWR ch m vaddr v m' (ST:Mem.storev ch m vaddr v = Some m')

Lemma freelist_curWR l: forall m m' (FR: Mem.free_list m l = Some m') *)
Require Import sepcomp.trace_semantics.
Require Import sepcomp.StructuredInjections.
Require Import sepcomp.effect_simulations.
Require Import sepcomp.effect_properties.
Require Import sepcomp.rg_lemmas.
Require Import sepcomp.extspec. Import ExtSpecProperties.
(* sepcomp.extspec:
Require Import Coq.Lists.ListSet.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Maps.

Definition PTree_injective {A} (t: PTree.t A) : Prop :=
  forall id1 id2 b, t ! id1 = Some b -> t ! id2 = Some b -> id1 = id2.

Definition injective_PTree A := sig (@PTree_injective A).

Structure external_specification (M E Z : Type) :=
  { ext_spec_type : E -> Type
  ; ext_spec_pre: forall e: E,
    ext_spec_type e -> injective_PTree block -> list typ -> list val -> Z -> M -> Prop
  ; ext_spec_post: forall e: E,
    ext_spec_type e -> injective_PTree block -> option typ -> option val -> Z -> M ->  Prop
  ; ext_spec_exit: option val -> Z -> M ->  Prop }.

Arguments ext_spec_type {M E Z} _ _.
Arguments ext_spec_pre {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_post {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_exit {M E Z} _ _ _ _.

Definition ext_spec := external_specification mem external_function.

Lemma extfunct_eqdec (ef1 ef2 : external_function) : {ef1=ef2} + {~ef1=ef2}.

Set Implicit Arguments.

Definition ef_ext_spec (M Z : Type) :=
  external_specification M AST.external_function Z.

Definition spec_of
  (M Z : Type) (ef : AST.external_function) (spec : ef_ext_spec M Z) :=
  (ext_spec_pre spec ef, ext_spec_post spec ef).

Definition oval_inject j (v tv : option val) :=
  match v, tv with
    | None, None => True
    | Some v', Some tv' => Val.inject j v' tv'
    | _, _ => False
  end.

Module ExtSpecProperties.

Definition det (M E Z : Type) (spec : external_specification M E Z) :=
  forall ef (x x' : ext_spec_type spec ef) ge tys z vals m
         oty' ov' z' m' oty'' ov'' z'' m'',
  ext_spec_pre spec ef x ge tys vals z m ->
  ext_spec_post spec ef x ge oty' ov' z' m' ->
  ext_spec_pre spec ef x' ge tys vals z m ->
  ext_spec_post spec ef x' ge oty'' ov'' z'' m'' ->
  oty'=oty'' /\ ov'=ov'' /\ z'=z'' /\ m'=m''.

Record closed (Z : Type) (spec : ext_spec Z) :=
  { P_closed :
      forall ef (x : ext_spec_type spec ef) ge j tys vals z m tvals tm,
      ext_spec_pre spec ef x ge tys vals z m ->
      Val.inject_list j vals tvals ->
      Mem.inject j m tm ->
      ext_spec_pre spec ef x ge tys tvals z tm
  ; Q_closed :
      forall ef (x : ext_spec_type spec ef) ge j oty ov z m otv tm,
      ext_spec_post spec ef x ge oty ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_post spec ef x ge oty otv z tm
  ; exit_closed :
      forall j ov z m otv tm,
      ext_spec_exit spec ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_exit spec otv z tm }.

End ExtSpecProperties. *)
Require Import sepcomp.arguments.
Require Import sepcomp.closed_safety.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import SM_simulation.

Definition target_accessible mu m tm args b ofs :=
  Mem.valid_block tm b /\
  (locBlocksTgt mu b=false ->
    exists b0 d,
      foreign_of mu b0 = Some (b, d)
      /\ REACH m (getBlocks args) b0=true
      /\ Mem.perm m b0 (ofs-d) Max Nonempty).

Definition incr mu mu' :=
  inject_incr (as_inj mu) (as_inj mu')
  /\ (forall b, DomSrc mu b=true -> DomSrc mu' b=true)
  /\ (forall b, DomTgt mu b=true -> DomTgt mu' b=true).

Section open_semantics_preservation.

Variable (F V TF TV C D Z : Type) (z_init : Z).

Variable source : @EffectSem (Genv.t F V) C.
Variable target : @EffectSem (Genv.t TF TV) D.

Variable (geS : Genv.t F V) (geT : Genv.t TF TV).
Variable entry_points : list (val*val*signature).

Variable spec : ext_spec Z.

Variable spec_closed : ExtSpecProperties.closed spec.

Variable spec_ok :
  forall ef x tys args targs m rty rv m' tm z z' j,
  ext_spec_pre spec ef x tys args z m ->
  ext_spec_post spec ef x rty rv z' m' ->
  Mem.inject (as_inj j) m tm ->
  val_list_inject (restrict (as_inj j) (vis j)) args targs ->
  mem_forward m m' ->
  Mem.unchanged_on (fun b ofs => REACH m (getBlocks args) b=false) m m' ->
  exists j' rv' tm',
    incr j j'
    /\ oval_inject (as_inj j') rv rv'
    /\ Mem.inject (as_inj j') m' tm'
    /\ sm_inject_separated j j' m tm
    /\ SM_wd j'
    /\ sm_valid j' m' tm'
    /\ mem_forward tm tm'
    /\ Mem.unchanged_on (fun b ofs =>
         ~target_accessible j m tm args b ofs) tm tm'.

Variable sim : SM_simulation_inject source target geS geT entry_points.

Variable src_det : corestep_fun source.
Variable tgt_det : corestep_fun target.
Variable ext_spec_det : ExtSpecProperties.det spec.

Notation tr_source := (TraceSemantics.coopsem z_init source spec).
Notation tr_target := (TraceSemantics.coopsem z_init target spec).

Lemma tr_src_det : corestep_fun tr_source.
Proof. apply TraceSemantics.fun_FUN; auto. Qed.

Lemma tr_tgt_det : corestep_fun tr_target.
Proof. apply TraceSemantics.fun_FUN; auto. Qed.

Definition ogetBlock (ov : option val) : block -> bool :=
  match ov with
    | None => fun _:block => false
    | Some v => getBlocks (v::nil)
  end.

Section match_event.

Import Event.

Inductive match_event : Event.t -> Event.t -> Prop :=
| mk_match_event :
  forall j j' ev1 ev2,
  let args1 := ev1.(args) in
  let args2 := ev2.(args) in
  let rv1 := ev1.(rv) in
  let rv2 := ev2.(rv) in
  let m1 := ev1.(pre_mem) in
  let m1' := ev1.(post_mem) in
  let m2 := ev2.(pre_mem) in
  let m2' := ev2.(post_mem) in
  inject_incr (as_inj j) (as_inj j') ->
  Mem.inject (as_inj j) m1 m2 ->
  Mem.inject (as_inj j') m1' m2' ->
  Forall2 (val_inject (as_inj j)) args1 args2 ->
  oval_inject (as_inj j') rv1 rv2 ->
  match_event ev1 ev2.

End match_event.

Inductive match_trace : list Event.t -> list Event.t -> Prop :=
| match_trace_nil : match_trace nil nil
| match_trace_cons :
  forall tr1 tr2 ev1 ev2,
  match_event ev1 ev2 ->
  match_trace tr1 tr2 ->
  match_trace (ev1 :: tr1) (ev2 :: tr2).

Notation data := (sim.(SM_simulation.core_data _ _ _ _ _)).
Notation ord  := (sim.(SM_simulation.core_ord _ _ _ _ _)).
Notation match_state := (sim.(SM_simulation.match_state _ _ _ _ _)).

Inductive trace_match_state :
  data -> SM_Injection -> Z*list Event.t*C -> mem ->
                          Z*list Event.t*D -> mem -> Prop :=
| mk_trace_match_state :
  forall j tr z c m ttr d tm cd,
  match_trace tr ttr ->
  match_state cd j c m d tm ->
  trace_match_state cd j (z,tr,c) m (z,ttr,d) tm.

Lemma corestep_matchN {c m d tm c' m' cd j n} :
  corestepN source geS n c m c' m' ->
  match_state cd j c m d tm ->
  exists d' tm' cd' j' n',
    corestepN target geT n' d tm d' tm'
    /\ match_state cd' j' c' m' d' tm'.
Proof.
revert cd j c m d tm; induction n; simpl; intros cd j c m d tm.
inversion 1; subst.
intros MATCH; exists d, tm, cd, j, O; split; simpl; auto.
intros [c2 [m2 [STEP STEPN]]] MATCH.
generalize STEP as STEP'; intro.
eapply core_diagram in STEP; eauto.
destruct STEP as [d2 [tm2 [cd2 [j2 [? [? [? [MATCH2 [? [? TSTEPN]]]]]]]]]].
assert (exists n', corestepN target geT n' d tm d2 tm2) as [n' TSTEPN'].
{ destruct TSTEPN as [[n' X]|[[n' X] _]].
  exists (S n'); auto.
  exists n'; auto. }
assert (STEPN': corestepN source geS (S O) c m c2 m2).
{ simpl; exists c2, m2; split; auto. }
destruct (IHn _ _ _ _ _ _ STEPN MATCH2)
  as [d'' [tm'' [cd'' [j'' [n'' [TSTEPN'' MATCH']]]]]].
exists d'', tm'', cd'', j'', (plus n' n''); split; auto.
rewrite corestepN_add; exists d2, tm2; split; auto.
Qed.

Lemma yielded_src_tgt {cd j c d m tm} :
  match_state cd j c m d tm ->
  TraceSemantics.yielded source c ->
  TraceSemantics.yielded target d.
Proof.
intros MATCH [[ef [sig [args X]]]|[rv X]].
eapply core_at_external in MATCH; eauto.
destruct MATCH as [? [? [? ?]]]; left.
exists ef, sig, x; auto.
eapply core_halted in MATCH; eauto.
destruct MATCH as [? [? [? ?]]].
right; exists x; auto.
Qed.

Lemma nyielded_tgt_src {cd j c d m tm} :
  match_state cd j c m d tm ->
  ~TraceSemantics.yielded target d ->
  ~TraceSemantics.yielded source c.
Proof. intros H H2 H3; apply H2; eapply yielded_src_tgt; eauto. Qed.

Lemma REACH_mono':
  forall B1 B2 : block -> bool,
  (forall b : block, B1 b = true -> B2 b = true) ->
  forall (m : mem) (b : block), REACH m B2 b = false -> REACH m B1 b = false.
Proof.
intros ? ? SUB m b HR.
case_eq (REACH m B1 b); auto.
solve[intros H; generalize (REACH_mono _ _ SUB _ _ H); congruence].
Qed.

Lemma REACH_as_inj': forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)
        (ValInjMu : Forall2 (val_inject (as_inj mu)) vals1 vals2) b1
        (R : REACH m1 (getBlocks vals1) b1 = true)
        B (HB: forall b b2 d, shared_of mu b = Some(b2,d) -> B b2 = true),
      exists b2 d, as_inj mu b1 = Some (b2, d) /\
                   REACH m2 (fun b => orb (getBlocks vals2 b) (B b)) b2 = true.
Proof. intros.
 eapply (REACH_inject _ _ _ MemInjMu); try eassumption.
 clear R. simpl; intros.
 destruct (getBlocks_inject _ _ _ ValInjMu _ H) as [b2 [d [J G]]].
 exists b2, d. rewrite J, G. intuition.
Qed.

Lemma REACH_as_inj_REACH': forall mu (WD: SM_wd mu) m1 m2 vals1 vals2
        (MemInjMu : Mem.inject (as_inj mu) m1 m2)
        (ValInjMu : Forall2 (val_inject (as_inj mu)) vals1 vals2) b1
        (R : REACH m1 (getBlocks vals1) b1 = true),
      exists b2 d, as_inj mu b1 = Some (b2, d) /\
                   REACH m2 (getBlocks vals2) b2 = true.
Proof. intros.
  destruct (@REACH_as_inj' _ WD _ _ _ _ MemInjMu ValInjMu _ R (fun b => true))
       as [b2 [d [ASI _]]]. trivial.
  exists b2, d. split; trivial.
  destruct (REACH_inject _ _ _ MemInjMu)
    with (B1 := getBlocks vals1) (B2 := getBlocks vals2) (b1 := b1); auto.
  intros.
  solve[apply getBlocks_inject with (vals1 := vals1); auto].
  destruct H as [bb2 [ASI' RR]]; rewrite ASI' in ASI; inv ASI.
  assumption.
Qed.

Definition marshal j m args tm targs :=
  Build_SM_Injection
  (fun _ => false) (fun _ => false)
  (fun _ => false) (fun _ => false)
  (fun _ => None)
  (DomSrc j)
  (DomTgt j)
  (REACH m (getBlocks args))
  (REACH tm (getBlocks targs))
  (as_inj j).

Lemma as_inj_marshal j m args tm targs :
  as_inj (marshal j m args tm targs) = as_inj j.
Proof.
unfold marshal, as_inj, join; simpl; extensionality b.
destruct (extern_of j b).
destruct p; auto.
destruct (local_of j b); auto.
destruct p; auto.
Qed.

Lemma foreign_of_marshal j m args tm targs :
  foreign_of (marshal j m args tm targs)
  = restrict (as_inj j) (REACH m (getBlocks args)).
Proof.
unfold marshal, as_inj, join, restrict; simpl.
extensionality b.
destruct (REACH m (getBlocks args) b); simpl; auto.
Qed.

Lemma DomSrc_marshal j m args tm targs :
  DomSrc (marshal j m args tm targs) = DomSrc j.
Proof. unfold DomSrc; extensionality b; auto. Qed.

Lemma DomTgt_marshal j m args tm targs :
  DomTgt (marshal j m args tm targs) = DomTgt j.
Proof. unfold DomSrc; extensionality b; auto. Qed.

Lemma locBlocksTgt_marshal j m args tm targs :
  locBlocksTgt (marshal j m args tm targs) = (fun _ => false).
Proof. unfold marshal, as_inj, join, restrict; auto. Qed.

Lemma vis_marshal j m args tm targs :
  vis (marshal j m args tm targs) = REACH m (getBlocks args).
Proof. unfold marshal, vis; simpl; auto. Qed.

Lemma injsep_marshal j j' m args tm targs m1 m2 :
  sm_inject_separated j (marshal j' m args tm targs) m1 m2 ->
  sm_inject_separated j j' m1 m2.
Proof.
intros [H [H2 H3]].
rewrite as_inj_marshal in H.
rewrite DomSrc_marshal in H2.
rewrite DomTgt_marshal in H3.
split; intros.
solve[destruct (H _ _ _ H0 H1); split; auto].
split; intros.
apply H2; auto.
apply H3; auto.
Qed.

Lemma injsep_marshal' j j' m args tm targs m1 m2 :
  sm_inject_separated (marshal j m args tm targs) j' m1 m2 ->
  sm_inject_separated j j' m1 m2.
Proof.
intros [H [H2 H3]].
rewrite as_inj_marshal in H.
rewrite DomSrc_marshal in H2.
rewrite DomTgt_marshal in H3.
split; intros.
destruct (H _ _ _ H0 H1); split.
rewrite DomSrc_marshal in H4; auto.
rewrite DomTgt_marshal in H5; auto.
split; intros.
apply H2; auto.
apply H3; auto.
Qed.

Lemma restrict_as_inj_eq j j' m1 m2 :
  SM_wd j ->
  SM_wd j' ->
  inject_incr (as_inj j) (as_inj j') ->
  sm_inject_separated j j' m1 m2 ->
  sm_valid j m1 m2 ->
  restrict (as_inj j') (DomSrc j) = as_inj j.
Proof.
intros.
extensionality b.
case_eq (as_inj j b).
intros [ofs d] INJ.
assert (H4: DomSrc j b=true).
{ apply as_inj_DomRng in INJ; auto.
  destruct INJ; auto. }
apply H1 in INJ.
unfold restrict.
rewrite H4; auto.
intros INJ.
case_eq (as_inj j' b).
intros [ofs d] INJ'.
assert (H5: DomSrc j b=false).
{ destruct H3 as [H3 H4].
  destruct H2 as [H5 [H6 H7]].
  destruct (H5 _ _ _ INJ INJ'); auto. }
assert (H6: ~Mem.valid_block m1 b).
{ destruct H3 as [H3 H4].
  destruct H2 as [H6 [H7 H8]].
  apply as_inj_DomRng in INJ'; auto.
  destruct INJ' as [X Y]; auto. }
unfold restrict; rewrite H5; auto.
intros INJ'.
unfold restrict.
rewrite INJ'; destruct (DomSrc j b); auto.
Qed.

Lemma reach_in_exported_src b m args j :
  REACH m (getBlocks args) b=true -> REACH m (exportedSrc j args) b=true.
Proof.
intros H; apply REACH_mono with (B1 := getBlocks args); auto.
intros b0 H2; unfold exportedSrc; rewrite H2; auto.
Qed.

Arguments reach_in_exported_src {b m args} j _.

Lemma reach_in_exported_tgt {b m args} j :
  REACH m (getBlocks args) b=true -> REACH m (exportedTgt j args) b=true.
Proof.
intros H; apply REACH_mono with (B1 := getBlocks args); auto.
intros b0 H2; unfold exportedTgt; rewrite H2; auto.
Qed.

Arguments reach_in_exported_tgt {b m args} j _.

Lemma extern_semantics_preservation c c' d m m' tm cd j ef sig args :
  trace_match_state cd j c m d tm ->
  corestep tr_source geS c m c' m' ->
  at_external source (snd c) = Some (ef, sig, args) ->
  exists cd' j' d' tm',
    corestep tr_target geT d tm d' tm'
    /\ trace_match_state cd' j' c' m' d' tm'.
Proof.
intros TRMATCH STEP ATEXTSRC.
destruct c as [[z tr2] c].
destruct d as [[tz ttr] d].
assert (MATCH: match_state cd j c m d tm) by (inv TRMATCH; auto).
inv STEP. rename H6 into STEP.

{ 
elimtype False.
apply corestep_not_at_external in STEP.
simpl in ATEXTSRC; rewrite STEP in ATEXTSRC; inv ATEXTSRC. }

{ 
assert (exists targs,
  at_external target d = Some (ef, sig, targs)
  /\ val_list_inject (restrict (as_inj j) (vis j)) args targs)
  as [targs [AT VALINJ]].
  { inv TRMATCH; eapply core_at_external in ATEXTSRC; eauto.
    destruct ATEXTSRC as [_ [targs [? ?]]]; exists targs; split; auto.
    solve[apply forall_inject_val_list_inject; auto]. }

assert (INJ: Mem.inject (as_inj j) m tm).
  { inv TRMATCH; eapply core_at_external in ATEXTSRC; eauto.
    solve[destruct ATEXTSRC as [? _]; auto]. }

set (pubSrc' := fun b =>
  andb (locBlocksSrc j b) (REACH m (exportedSrc j args) b)).
set (pubTgt' := fun b =>
  andb (locBlocksTgt j b) (REACH tm (exportedTgt j targs) b)).
set (nu := replace_locals j pubSrc' pubTgt').
set (mu := marshal nu m args tm targs).

assert (MU_INJ: Mem.inject (as_inj mu) m tm)
  by (unfold mu, nu; rewrite as_inj_marshal, replace_locals_as_inj; auto).

assert (MU_VALINJ:
  val_list_inject (restrict (as_inj mu) (vis mu)) args targs).
  { inv TRMATCH; eapply core_at_external in ATEXTSRC; eauto.
    destruct ATEXTSRC as [_ [? [VALINJ' ATEXT]]].
    rewrite ATEXT in AT; inv AT.
    unfold mu; rewrite as_inj_marshal, vis_marshal.
    apply forall_inject_val_list_inject.
    unfold nu; rewrite replace_locals_as_inj.
    apply forall_vals_inject_restrictD in VALINJ'.
    apply restrict_forall_vals_inject; auto.
    intros b GET; apply REACH_nil; auto. }

simpl in ATEXTSRC; rewrite H2 in ATEXTSRC; inv ATEXTSRC.
rename H3 into UNCH; rename H4 into FORWARD.
rename H6 into PRE; rename H10 into POST.
generalize (@spec_ok ef x (sig_args sig) args targs m
  (sig_res sig) (Some rv) m' tm _ _ mu PRE POST MU_INJ MU_VALINJ FORWARD UNCH).
intros [mu2 [trv [tm2 [INCR [RVALINJ [INJ2 [SEP2 [WD2
  [VAL2 [TFWD2 TUNCH]]]]]]]]]].
set (nu2 := reestablish nu mu2).
set (frgnSrc' := fun b : block =>
     DomSrc nu2 b && (negb (locBlocksSrc nu2 b)
       && REACH m' (exportedSrc nu2 (rv :: nil)) b)).

assert (exists trv0, trv = Some trv0) as [trv0 ->].
  { simpl in RVALINJ; destruct trv as [trv|]; try solve[elimtype False; auto].
    solve[exists trv; auto]. }

set (frgnTgt' := fun b : block =>
     DomTgt nu2 b && (negb (locBlocksTgt nu2 b)
       && REACH tm2 (exportedTgt nu2 (trv0 :: nil)) b)).

set (nu' := replace_externs nu2 frgnSrc' frgnTgt').

assert (VALINJ': Forall2 (val_inject (as_inj j)) args targs).
  { apply val_list_inject_forall_inject in MU_VALINJ.
    apply forall_vals_inject_restrictD in MU_VALINJ.
    generalize MU_VALINJ; unfold mu; rewrite as_inj_marshal.
    unfold nu; rewrite replace_locals_as_inj; auto. }

assert (VALINJ'':
  Forall2 (val_inject (restrict (as_inj j) (vis j))) args targs)
  by (apply val_list_inject_forall_inject; auto).

assert (J_WD: SM_wd j)
  by (apply (match_sm_wd sim _ _ _ _ _ _ MATCH)).

assert (J_VAL: sm_valid j m tm)
  by (apply match_validblocks in MATCH; auto).

assert (NU_WD: SM_wd nu).
  { edestruct eff_after_check1
    with (mu := j) (m1 := m) (m2 := tm) (vals1 := args) (vals2 := targs)
       (pubSrc' := pubSrc') (pubTgt' := pubTgt'); auto. }

assert (NU_VAL: sm_valid nu m tm).
  { edestruct eff_after_check1
    with (mu := j) (m1 := m) (m2 := tm) (vals1 := args) (vals2 := targs)
      (pubSrc' := pubSrc') (pubTgt' := pubTgt'); auto.
    destruct H0; auto. }

assert (EINCR: extern_incr nu nu2).
  { apply reestablish_extern_incr'; auto.
    unfold nu; rewrite replace_locals_as_inj.
    apply inject_incr_trans with (f2 := as_inj mu); auto.
    unfold mu, nu; rewrite as_inj_marshal, replace_locals_as_inj.
    apply inject_incr_refl.
    destruct INCR; auto.
    intros b; unfold nu; rewrite replace_locals_extBlocksSrc; intros A.
    destruct INCR as [X [Y W]]; apply Y.
    unfold mu, nu, marshal, DomSrc; simpl.
    rewrite replace_locals_extBlocksSrc, A.
    solve[rewrite !orb_true_iff; auto].
    intros b; unfold nu; rewrite replace_locals_extBlocksTgt; intros A.
    destruct INCR as [X [Y W]]; apply W.
    unfold mu, nu, marshal, DomTgt; simpl.
    rewrite replace_locals_extBlocksTgt, A.
    solve[rewrite !orb_true_iff; auto]. }

assert (NUMU2_SEP: sm_inject_separated nu mu2 m tm).
  { apply injsep_marshal' in SEP2; auto. }

assert (RESTRICT_MU2_NU: restrict (as_inj mu2) (DomSrc nu) = as_inj nu).
  { apply restrict_as_inj_eq with (m1 := m) (m2 := tm); auto.
    destruct INCR as [INCR _].
    apply inject_incr_trans with (f2 := as_inj mu); auto.
    unfold mu; rewrite as_inj_marshal.
    apply inject_incr_refl. }

assert (LOCNU_IN_DOMSRC:
  forall b, locBlocksSrc nu b=true -> DomSrc mu2 b=true).
  { unfold nu; rewrite replace_locals_locBlocksSrc.
    intros b LOC. cut (DomSrc mu b=true). intro DOM.
    destruct INCR as [X [Y W]]; auto.
    unfold mu; rewrite DomSrc_marshal.
    unfold nu; rewrite replace_locals_DomSrc.
    unfold DomSrc; rewrite LOC; auto. }

assert (LOCNU_IN_DOMTGT:
  forall b, locBlocksTgt nu b=true -> DomTgt mu2 b=true).
  { intros b LOC. cut (DomTgt mu b=true). intro DOM.
    destruct INCR as [X [Y W]]; auto.
    unfold mu; rewrite DomTgt_marshal.
    unfold nu; rewrite replace_locals_DomTgt.
    unfold nu in LOC; rewrite replace_locals_locBlocksTgt in LOC.
    unfold DomTgt. rewrite LOC; auto. }

assert (NU_SEP: sm_inject_separated nu nu2 m tm)
  by (unfold nu; apply reestablish_sm_injsep in NUMU2_SEP; auto).

assert (NU2_WD: SM_wd nu2).
  { apply reestablish_wd; auto.
    solve[destruct NUMU2_SEP; auto].
    intros b; unfold nu; rewrite replace_locals_extBlocksTgt.
    intros EXT. cut (DomTgt mu b=true). intro DOM.
    destruct INCR as [X [Y W]]; auto.
    unfold mu; rewrite DomTgt_marshal.
    unfold nu; rewrite replace_locals_DomTgt.
    unfold DomTgt; rewrite EXT; rewrite orb_true_iff; auto. }

assert (NU2_VAL: sm_valid nu2 m' tm2)
  by (apply reestablish_sm_valid; auto).

assert (NU2_INJ: Mem.inject (as_inj nu2) m' tm2).
  { unfold nu2; rewrite reestablish_as_inj'; auto.
    unfold mu in INCR; destruct INCR as [X _].
    rewrite as_inj_marshal in X; auto.
    intros b LOC LOCOF; case_eq (as_inj mu2 b); auto.
    intros [b0 d0] ASINJ; elimtype False.
    destruct NUMU2_SEP as [X Y].
    cut (as_inj nu b = None). intro ASINJ'.
    destruct (X _ _ _ ASINJ' ASINJ).
    unfold DomSrc in H; rewrite LOC in H; inv H.
    unfold as_inj, join.
    assert (extern_of nu b = None) as ->; auto.
      generalize (disjoint_extern_local_Src NU_WD b).
      rewrite LOC; inversion 1; subst. congruence.
      case_eq (extern_of nu b); auto; intros [? ?] EXT.
      apply extern_DomRng in EXT; auto.
      destruct EXT as [W _]; rewrite H0 in W; congruence. }

assert (NU2_VINJ: val_inject (as_inj nu2) rv trv0)
  by (simpl in RVALINJ; unfold nu2; rewrite reestablish_as_inj; auto).

rename H2 into ATEXTSRC.

generalize (@eff_after_external _ _ _ _ _ _ _ _ _ _ _
  sim cd j c d m ef args tm sig targs ef sig INJ MATCH
  ATEXTSRC AT VALINJ''
  pubSrc' refl_equal
  pubTgt' refl_equal
  nu refl_equal nu2 rv m' trv0 tm2
  EINCR NU_SEP NU2_WD NU2_VAL NU2_INJ NU2_VINJ FORWARD TFWD2
  frgnSrc' refl_equal
  frgnTgt' refl_equal
  nu' refl_equal).

destruct 1 as [acd [ac [ad [AFT1 [AFT2 AMATCH]]]]]; auto.
apply unchanged_on_validblock with (V :=
  fun b ofs => REACH m (getBlocks args) b=false); auto.
intros b ofs BVAL [X Y].
unfold nu in Y; unfold pubSrc', pubTgt' in Y.
rewrite replace_locals_pubBlocksSrc in Y.
unfold nu in X; rewrite replace_locals_locBlocksSrc in X.
rewrite X in Y; simpl in Y.
apply REACH_mono' with (B2 := exportedSrc j args); auto.
solve[intros b'; unfold exportedSrc; intros ->; auto].

apply unchanged_on_validblock with (V :=
  fun b ofs => ~target_accessible mu m tm args b ofs); auto.
intros b ofs BVAL [X Y].
unfold nu in Y; unfold pubSrc', pubTgt' in Y.
rewrite replace_locals_pubBlocksSrc in Y.
rewrite replace_locals_local in Y.
unfold nu in X; rewrite replace_locals_locBlocksTgt in X.
unfold target_accessible; unfold mu; simpl; intros [VAL TA].
destruct TA as [b0 [d0 [INJ0 [HR' PERM]]]]; auto.
assert (HR'': REACH m (exportedSrc j args) b0=true).
  apply REACH_mono with (B1 := getBlocks args); auto.
  solve[unfold exportedSrc; intros ? ->; auto].
generalize (match_sm_wd sim _ _ _ _ _ _ MATCH); intros WD.
apply REACH_as_inj_REACH with (m2 := tm) (vals2 := targs) in HR''; auto.
destruct HR'' as [b' [d' [INJ'' HR'']]].
assert (b = b' /\ d0 = d') as [? ?].
  unfold nu in INJ0; rewrite HR', replace_locals_as_inj in INJ0.
  solve[rewrite INJ0 in INJ''; inv INJ''; auto].
subst b' d'.

assert (local_of j b0 = Some (b, d0) /\ locBlocksSrc j b0=true)
  as [LOCOF LSRC].
  generalize INJ''; clear INJ''.
  unfold as_inj, join.
  case_eq (extern_of j b0); auto.
  intros [? ?] EXT; inversion 1; subst.
  apply extern_DomRng' in EXT; auto.
  destruct EXT as [_ [_ [_ [TLOC _]]]].
  solve[rewrite TLOC in X; congruence].
  intros; split; auto.
  apply local_DomRng in INJ''; auto.
  destruct INJ''; auto.
destruct (Y _ _ LOCOF).
solve[apply H; apply PERM].
assert (HR''': REACH m (exportedSrc j args) b0=true).
  apply REACH_mono with (B1 := getBlocks args); auto.
  solve[unfold exportedSrc; intros ? ->; auto].
rewrite LSRC, HR''' in H; simpl in H; congruence.

edestruct eff_after_check1
  with (mu := j) (m1 := m) (m2 := tm) (vals1 := args) (vals2 := targs)
       (pubSrc' := pubSrc') (pubTgt' := pubTgt'); auto.

set (tr2' := Event.mk m m' args (Some rv) :: tr2).
set (ttr' := Event.mk tm tm2 targs (Some trv0) :: ttr).

exists acd, nu', (z',ttr',ad), tm2.
split; auto.
econstructor; eauto.

apply unchanged_on_validblock with (V :=
  fun b ofs => ~target_accessible mu m tm args b ofs); auto.
intros b ofs X Y.
unfold target_accessible; intros [VAL TA].
destruct TA as [b0 [d0 [FR [RC PERM]]]]; auto.
apply REACH_as_inj_REACH' with (m2 := tm) (vals2 := targs) (mu := j) in RC; auto.
destruct RC as [b2 [d2 [INJ' RR]]].
assert (b = b2).
  apply foreign_in_all in FR.
  unfold mu, nu in FR; rewrite as_inj_marshal, replace_locals_as_inj in FR.
  solve[rewrite FR in INJ'; inv INJ'; auto].
solve[subst; congruence].

instantiate (1 := x).
assert (VALINJ''' : val_list_inject (as_inj j) args targs).
  solve[apply forall_inject_val_list_inject; auto].
generalize (P_closed spec_closed ef x (sig_args sig) z PRE VALINJ''' INJ).
assert (z = tz) as -> by (inv TRMATCH; auto).
solve[auto].
generalize (Q_closed spec_closed ef x
  (sig_res sig) (Some rv) z' (Some trv0) POST RVALINJ INJ2).
solve[auto].

constructor. constructor.
destruct H0 as [VAL [INJ' VINJ]].
apply mk_match_event
  with (j := replace_locals j pubSrc' pubTgt')
       (j' := nu2); auto.
solve[apply extern_incr_as_inj; auto].
solve[inv TRMATCH; auto].
solve[rewrite H11 in AFT1; inv AFT1; auto]. }
Qed.

Lemma safe_match_target_step cd j c m d tm z tr :
  (forall n, safeN tr_source geS n (z,tr,c) m) ->
  match_state cd j c m d tm ->
  ~TraceSemantics.yielded target d ->
  exists c' m' d' tm' n tn,
    corestepN source geS n c m c' m'
    /\ corestepN target geT (S tn) d tm d' tm'
    /\ exists cd' j', match_state cd' j' c' m' d' tm'.
Proof.
set (my_P := fun (x: data) =>
  forall j c m d tm z tr,
  (forall n, safeN tr_source geS n (z,tr,c) m) ->
  match_state x j c m d tm ->
  ~TraceSemantics.yielded target d ->
  exists c' m' d' tm' n tn,
    corestepN source geS n c m c' m'
    /\ corestepN target geT (S tn) d tm d' tm'
    /\ exists cd' j', match_state cd' j' c' m' d' tm').
assert (my_well_founded_induction
     : (forall x, (forall y, ord y x -> my_P y) -> my_P x) ->
       forall a, my_P a)
  by (apply well_founded_induction; destruct sim; auto).
unfold my_P in my_well_founded_induction.
intros SAFE; revert cd j SAFE.
intros cd j; revert j c m d tm z tr.
apply my_well_founded_induction; auto.
intros. rename H0 into SAFE. rename H into IH.
destruct (TraceSemantics.yielded_dec source c).
exists c, m, d, tm, O, O; split; simpl; auto.
split; auto.
eapply yielded_src_tgt in y; eauto. contradiction.
solve[exists x, j; auto].
generalize (SAFE (S O)); simpl.
assert (TraceSemantics.halted source (z,tr,c) = None) as ->
  by (apply TraceSemantics.nyielded_nhalted in n; auto).
intros [[[z' tr'] c2] [m2 [STEP _]]].
inv STEP.
rename H11 into STEP.
generalize STEP as STEP'; intro.
eapply (core_diagram sim) in STEP; eauto.
destruct STEP as [d2 [tm2 [cd2 [mu2 [_ [_ [_ [MATCH2 [_ [_ STEP2]]]]]]]]]].
destruct STEP2.
destruct H0 as [n0 TSTEPN].
solve[exists c2, m2, d2, tm2, (S O), n0; split; simpl; eauto].
destruct H0 as [[n0 TSTEPN] ORD].
assert (SAFE': forall n,
  safeN (TraceSemantics.coopsem z_init source spec) geS n (z', tr', c2) m2).
  { intros n1; specialize (SAFE (S n1)).
    eapply safe_corestep_forward; eauto. apply tr_src_det.
    constructor; auto. }
destruct n0. inv TSTEPN.
generalize (IH _ ORD _ c2 m2 d2 tm2 _ _ SAFE' MATCH2 H2).
intros [c' [m' [d' [tm' [n' [tn' [A [B E]]]]]]]].
exists c', m', d', tm', (S n'), tn'; split; auto.
solve[exists c2, m2; split; auto].
solve[exists c2, m2, d2, tm2, (S O), n0; split; simpl; eauto].
eapply TraceSemantics.nyielded_natext in n; eauto.
solve[rewrite n in H9; congruence].
Qed.

Lemma safe_match_target_atext cd j c m d tm z tr ef sig args :
  (forall n, safeN tr_source geS n (z,tr,c) m) ->
  match_state cd j c m d tm ->
  at_external target d = Some (ef, sig, args) ->
  exists c' m' n,
    corestepN source geS n c m c' m'
    /\ TraceSemantics.yielded source c'
    /\ exists cd' j', match_state cd' j' c' m' d tm.
Proof.
set (my_P := fun (x: data) =>
  forall j c m,
  (forall n, safeN tr_source geS n (z,tr,c) m) ->
  match_state x j c m d tm ->
  at_external target d = Some (ef, sig, args) ->
  exists c' m' n,
    corestepN source geS n c m c' m'
    /\ TraceSemantics.yielded source c'
    /\ exists cd' j', match_state cd' j' c' m' d tm).
assert (my_well_founded_induction
     : (forall x, (forall y, ord y x -> my_P y) -> my_P x) ->
       forall a, my_P a)
  by (apply well_founded_induction; destruct sim; auto).
unfold my_P in my_well_founded_induction.
intros SAFE; revert cd j SAFE.
intros cd j; revert j c m.
apply my_well_founded_induction; auto.
intros. rename H0 into SAFE. rename H into IH.
destruct (TraceSemantics.yielded_dec source c).
exists c, m, O; split; simpl; auto.
split; auto.
solve[exists x, j; auto].
generalize (SAFE (S O)); simpl.
assert (TraceSemantics.halted source (z,tr,c) = None) as ->
  by (apply TraceSemantics.nyielded_nhalted in n; auto).
intros [[[z' tr'] c2] [m2 [STEP _]]].
inv STEP.
rename H11 into STEP.
generalize STEP as STEP'; intro.
eapply (core_diagram sim) in STEP; eauto.
destruct STEP as [d2 [tm2 [cd2 [mu2 [_ [_ [_ [MATCH2 [_ [_ STEP2]]]]]]]]]].
destruct STEP2.
destruct H0 as [n0 TSTEPN].
destruct TSTEPN as [? [? [TSTEP _]]].
apply corestep_not_at_external in TSTEP.
rewrite TSTEP in H2; congruence.
destruct H0 as [[n0 TSTEPN] ORD].
destruct n0. inv TSTEPN.
assert (SAFE2: forall n, safeN tr_source geS n (z',tr',c2) m2).
  { intros n1; specialize (SAFE (S n1)).
    eapply safe_corestep_forward in SAFE; eauto.  apply tr_src_det.
    constructor; auto. }
generalize (IH _ ORD _ _ _ SAFE2 MATCH2 H2).
intros [c' [m' [n0 [STEPN [SY MATCH']]]]].
exists c', m', (S n0).
split; auto.
exists c2, m2; split; auto.
destruct TSTEPN as [? [? [TSTEP _]]].
apply corestep_not_at_external in TSTEP.
rewrite TSTEP in H2; inv H2.
exists c, m, O.
split; auto.
simpl; eauto.
split.
left; exists ef0, sig0, args0; auto.
exists x, j; auto.
Qed.

Lemma trace_refinement z z' c d d' m tm tm' tr0 ttr0 ttr cd j tn :
  match_state cd j c m d tm ->
  match_trace tr0 ttr0 ->
  (forall n, safeN tr_source geS n (z,tr0,c) m) ->
  corestepN tr_target geT tn (z,ttr0,d) tm (z',ttr,d') tm' ->
  exists z'' c' m' tr n,
    corestepN tr_source geS n (z,tr0,c) m (z'',tr,c') m'
    /\ match_trace tr ttr.
Proof.
intros MATCH TMATCH SSAFE TSTEPN.
assert (TRMATCH: trace_match_state cd j (z,tr0,c) m (z,ttr0,d) tm)
  by (constructor; auto).
revert c d m tm z cd j tr0 ttr0 MATCH SSAFE TMATCH TSTEPN TRMATCH.
set (my_P := fun (x: nat) =>
   forall (c : C) (d : D) (m tm : mem) (z : Z) (cd : data)
     (j : SM_Injection) (tr0 ttr0 : list Event.t),
   match_state cd j c m d tm ->
   (forall n : nat,
    safeN (TraceSemantics.coopsem z_init source spec) geS n (z, tr0, c) m) ->
   match_trace tr0 ttr0 ->
   corestepN (TraceSemantics.coopsem z_init target spec) geT x
     (z, ttr0, d) tm (z', ttr, d') tm' ->
   trace_match_state cd j (z, tr0, c) m (z, ttr0, d) tm ->
   exists (z'' : Z) (c' : C) (m' : mem) (tr : list Event.t)
   (n : nat),
     corestepN (TraceSemantics.coopsem z_init source spec) geS n
       (z, tr0, c) m (z'', tr, c') m' /\ match_trace tr ttr).
assert (my_well_founded_induction
     : (forall x, (forall y, lt y x -> my_P y) -> my_P x) ->
       forall a, my_P a)
  by (apply well_founded_induction; apply lt_wf).
unfold my_P in my_well_founded_induction.
apply my_well_founded_induction; auto.
intros until ttr0; intros MATCH SSAFE TMATCH TSTEPN TRMATCH.
rename H into IHtn. destruct x.
solve[inv TSTEPN; exists z', c, m, tr0, O; split; try constructor; auto].
destruct TSTEPN as [d2 [tm2 [TSTEP TSTEPN]]].
generalize TSTEP as TSTEP'; intro; inv TSTEP.

{ 
  rename H6 into TSTEP; rename c' into d2.
  assert (TNY: ~TraceSemantics.yielded target d).
    { intros [[ef [sig [args Y]]]|[rv Y]].
      apply corestep_not_at_external in TSTEP.
      rewrite TSTEP in Y; inv Y.
      apply corestep_not_halted in TSTEP.
      rewrite TSTEP in Y; inv Y. }
  eapply nyielded_tgt_src in TNY; eauto.
  generalize (safe_match_target_step SSAFE MATCH).
  intros [c2 [m2 [d2' [tm2' [n [tn0 [STEPN [TSTEPN' MATCH2]]]]]]]].
  solve[apply TraceSemantics.corestep_nyielded in TSTEP; auto].

  assert (SSAFE': forall n,
    safeN (TraceSemantics.coopsem z_init source spec) geS n (z, tr0, c2) m2).
    { intros n1; specialize (SSAFE (plus n1 (S n))).
      generalize tr_src_det. intro.
      eapply TraceSemantics.corestepN_CORESTEPN in STEPN; eauto.
      eapply safe_corestepN_forward in STEPN; eauto. }

  destruct MATCH2 as [cd2 [j2 MATCH2]].
  assert (TSTEPN'':
    corestepN tr_target geT (S x) (z,ttr0,d) tm (z',ttr,d') tm').
    { exists (z,ttr0,d2), tm2; split; auto. }
  case_eq (lt_dec tn0 (S x)). intros LT _.
  generalize (TraceSemantics.corestepN_splits_lt tgt_det TSTEPN' TSTEPN'' LT).
  intros [nx [ny [EQ [POS [A B]]]]].

  assert (LT': (ny < S x)%nat) by omega.
  destruct (IHtn ny LT' c2 _ _ _ _ _ _ _ _ MATCH2 SSAFE' TMATCH B)
    as [z'' [c' [m' [tr [n' [STEPN' MATCH']]]]]].
  solve[constructor; auto].
  exists z'', c', m', tr, (plus n n'); split; auto.
  rewrite corestepN_add.
  exists (z,tr0,c2), m2; split; auto.
  solve[apply TraceSemantics.corestepN_CORESTEPN; auto].
  intros NLT _. assert (GEQ: (S tn0 >= S x)%nat) by omega.
  generalize (TraceSemantics.corestepN_geq tgt_det TSTEPN' TSTEPN'' GEQ).
  intros [? ?]; subst z' ttr.
  exists z,c,m,tr0,O; split; auto.
  simpl; auto. }

{ 
  rename H2 into TATEXT; rename c' into d2.
  set (d2' := (z'0,Event.mk tm tm2 args (Some rv)::ttr0,d2)) in *.
  generalize (safe_match_target_atext SSAFE MATCH TATEXT).
  intros [c2 [m2 [n [STEPN [SY [cd2 [j2 MATCH2]]]]]]].
  assert (exists args, at_external source c2 = Some (ef,sig,args))
    as [args0 ATEXT].
    { destruct SY as [H|H].
      destruct H as [ef' [sig' [args' ATEXT]]].
      generalize ATEXT as ATEXT'; intro.
      eapply (core_at_external sim) in ATEXT; eauto.
      destruct ATEXT as [_ [? [? ATEXT'']]].
      rewrite ATEXT'' in TATEXT; inv TATEXT; exists args'; auto.
      destruct H as [rv' HALT].
      Arguments core_halted : default implicits.
      eapply core_halted in HALT; eauto.
      destruct HALT as [? [? [? THALT]]].
      generalize (@at_external_halted_excl _ _ _ target d).
      rewrite THALT. intros [W|W]; try congruence. }
  assert (SSAFE': forall n,
    safeN (TraceSemantics.coopsem z_init source spec) geS n (z, tr0, c2) m2).
    { intros n1; specialize (SSAFE (plus n1 (S n))).
      generalize tr_src_det. intro.
      eapply TraceSemantics.corestepN_CORESTEPN in STEPN; eauto.
      eapply safe_corestepN_forward in STEPN; eauto. }
  generalize SSAFE' as SSAFE''; intro.
  generalize (SSAFE' (S O)); simpl.
  assert (TraceSemantics.halted source (z,tr0,c2) = None) as ->.
    { generalize (@at_external_halted_excl _ _ _ source c2).
      rewrite ATEXT. intros [W|W]; try congruence.
      unfold TraceSemantics.halted; simpl; rewrite W; auto. }
  intros [c2' [m2' [STEP _]]].
  assert (trace_match_state cd2 j2 (z,tr0,c2) m2 (z,ttr0,d) tm)
    by (constructor; auto).
  generalize STEP as STEP'; intro.
  eapply extern_semantics_preservation in STEP; eauto.
  destruct STEP as [cd3 [j3 [[[z'' ttr'] d3] [tm3 [TSTEP'' TRMATCH']]]]].
  assert ((z'',ttr',d3) = d2' /\ tm2=tm3) as [EQ1 EQ2].
    { destruct (tr_tgt_det TSTEP' TSTEP'').
      subst d2'; subst tm2; inv H1; auto. }
  inversion EQ1. subst z'' ttr' d3.
  inversion EQ2. subst tm3.
  inv TRMATCH'. rename H15 into TMATCH'; rename H16 into MATCH'.
  set (c2' := (z'0,tr,c0)) in *.
  assert (SSAFE''': forall n,
    safeN (TraceSemantics.coopsem z_init source spec) geS n c2' m2').
    { intros n1; specialize (SSAFE' (S O)).
      assert (STEPN': corestepN tr_source geS (S O) (z,tr0,c2) m2 c2' m2').
        { exists c2', m2'; split; auto. simpl; auto. }
      eapply safe_corestepN_forward in STEPN'; eauto.
      apply tr_src_det. }
  set (ttr' := Event.mk tm tm2 args (Some rv) :: ttr0) in *.
  assert (LT: (x < S x)%nat) by omega.
  destruct (IHtn x LT c0 _ _ _ _ _ _ _ _ MATCH' SSAFE''' TMATCH' TSTEPN)
    as [z'' [c' [m' [tr' [n' [STEPN' MATCH'']]]]]].
  solve[constructor; auto].
  exists z'', c', m', tr', (plus (S n) n'); split; auto.
  rewrite corestepN_add.
  exists (z'0,tr,c0), m2'; split; auto.
  clear - STEPN STEP'.
  assert (STEPN': corestepN tr_source geS n (z,tr0,c) m (z,tr0,c2) m2)
    by (eapply TraceSemantics.corestepN_CORESTEPN; eauto).
  assert (S n = plus n 1) as -> by omega.
  rewrite corestepN_add.
  exists (z,tr0,c2), m2; split; auto.
  solve[simpl; eexists; eauto]. }
Qed.

Section corollary.

Import Event.

Definition injclosed (P : Event.t -> Prop) :=
  forall vals1 vals2 orv1 orv2 m1 m2 m1' m2' j j',
  P (Event.mk m1 m1' vals1 orv1) ->
  Mem.inject (as_inj j) m1 m2 ->
  val_list_inject (as_inj j) vals1 vals2 ->
  Mem.inject (as_inj j') m1' m2' ->
  oval_inject (as_inj j') orv1 orv2 ->
  P (Event.mk m2 m2' vals2 orv2).

Definition tracepred := list (Event.t -> Prop).

Fixpoint tracepred_injclosed (Ps : tracepred) :=
  match Ps with
    | nil => True
    | P :: Ps' => injclosed P /\ tracepred_injclosed Ps'
  end.

Fixpoint app_tracepred (Ps : tracepred) (tr : list Event.t) :=
  match Ps, tr with
    | P :: Ps', ev :: tr' => P ev /\ app_tracepred Ps' tr'
    | _, _ => True
  end.

Lemma app_match_trace (Ps : tracepred) tr tr' :
  tracepred_injclosed Ps ->
  match_trace tr tr' ->
  app_tracepred Ps tr ->
  app_tracepred Ps tr'.
Proof.
revert tr tr'; induction Ps; auto.
intros tr tr' [A B] E.
destruct tr; auto.
inv E; auto.
intros [G H].
destruct tr'; simpl; auto.
split.
inv E.
inv H3.
apply forall_inject_val_list_inject in H4.
unfold injclosed in A.
destruct t0, t1.
eapply A; eauto.
eapply IHPs; eauto.
inv E; auto.
Qed.

Lemma corollary c d m tm cd j Ps z :
  
  (forall n, safeN tr_source geS n (z,nil,c) m) ->

  match_state cd j c m d tm ->

  tracepred_injclosed Ps ->

  (forall c' m' z' tr,
    corestep_star tr_source geS (z,nil,c) m (z',tr,c') m' ->
    app_tracepred Ps tr) ->

  forall d' tm' z' tr',
    corestep_star tr_target geT (z,nil,d) tm (z',tr',d') tm' ->
    app_tracepred Ps tr'.
Proof.
intros SAFE MATCH CLOSED PSRC ? ? ? ? [n TSTEPN].
assert (TRMATCH: match_trace nil nil) by constructor.
eapply trace_refinement in MATCH; eauto.
destruct MATCH as [z'' [c' [m' [tr'' [n' [STEPN TRMATCH']]]]]].
eapply app_match_trace; eauto.
eapply PSRC; exists n'; eauto.
Qed.

End corollary.

End open_semantics_preservation.