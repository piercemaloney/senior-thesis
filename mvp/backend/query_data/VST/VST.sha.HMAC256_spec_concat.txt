Require Import List. Import ListNotations.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import sha.general_lemmas.
(* sha.general_lemmas:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import compcert.lib.Integers.
Require Import VST.msl.Coqlib2.
Require Import VST.floyd.coqlib3.
Require Import VST.floyd.sublist.
Require Import VST.floyd.functional_base.

Local Open Scope nat.

Fixpoint map2 {A B C: Type} (f: A -> B -> C) (al: list A) (bl: list B) : list C :=
 match al, bl with
  | a::al', b::bl' => f a b :: map2 f al' bl'
  | _, _ => nil
  end.

Lemma length_map2:
 forall A B C (f: A -> B -> C) al bl n,
  length al = n -> length bl = n ->
  length (map2 f al bl) = n.

Lemma list_repeat_injective {A} (a a':A) n: (0<n)%nat ->
      list_repeat n a = list_repeat n a' -> a=a'.

Local Open Scope Z.

Definition roundup (a b : Z) := (a + (b-1))/b*b.

Lemma roundup_minus:
   forall a b,  b > 0 -> roundup a b - a = (- a) mod b.

Definition Shr b x := Int.shru x (Int.repr b).

Lemma byte_testbit:
  forall i j, j >= 8 -> Z.testbit (Byte.unsigned i) j = false.

Fixpoint intlist_to_bytelist (l: list int) : list byte :=
 match l with
 | nil => nil
 | i::r =>
     Byte.repr (Int.unsigned (Shr 24 i)) ::
     Byte.repr (Int.unsigned (Shr 16 i)) ::
     Byte.repr (Int.unsigned (Shr 8 i)) ::
     Byte.repr (Int.unsigned i) ::
     intlist_to_bytelist r
 end.

Definition bytes_to_Int (a b c d : byte) : Int.int :=
  Int.or (Int.or (Int.or 
       (Int.shl (Int.repr (Byte.unsigned a)) (Int.repr 24))
      (Int.shl (Int.repr (Byte.unsigned b)) (Int.repr 16)))
       (Int.shl (Int.repr (Byte.unsigned c)) (Int.repr 8)))
         (Int.repr (Byte.unsigned d)).

Fixpoint bytelist_to_intlist (nl: list byte) : list int :=
  match nl with
  | h1::h2::h3::h4::t => bytes_to_Int h1 h2 h3 h4 :: bytelist_to_intlist t
  | _ => nil
  end.

Hint Rewrite Int.bits_or using omega : testbit.
Hint Rewrite Int.bits_shl using omega : testbit.
Hint Rewrite Int.bits_and using omega : testbit.
Hint Rewrite Int.bits_shru using omega : testbit.
Hint Rewrite Int.unsigned_repr using omega : testbit.
Hint Rewrite Int.testbit_repr using omega : testbit.
Hint Rewrite if_false using omega : testbit.
Hint Rewrite if_true using omega : testbit.
Hint Rewrite Z.ones_spec_low using omega : testbit.
Hint Rewrite Z.ones_spec_high using omega : testbit.
Hint Rewrite orb_false_r orb_true_r andb_false_r andb_true_r : testbit.
Hint Rewrite orb_false_l orb_true_l andb_false_l andb_true_l : testbit.
Hint Rewrite Z.add_simpl_r : testbit.
Hint Rewrite Int.unsigned_repr using rep_omega : testbit.
Hint Rewrite Byte.testbit_repr using rep_omega : testbit.
Hint Rewrite Byte.bits_above using rep_omega : testbit.

Lemma Ztest_Inttest:
 forall a, Z.testbit (Int.unsigned a) = Int.testbit a.
Hint Rewrite Ztest_Inttest : testbit.

Lemma Ztest_Bytetest:
 forall a, Z.testbit (Byte.unsigned a) = Byte.testbit a.
Hint Rewrite Ztest_Bytetest : testbit.

Definition swap (i: int) : int :=
 Int.or (Int.shl (Int.and i (Int.repr 255)) (Int.repr 24))
   (Int.or (Int.shl (Int.and (Shr 8 i) (Int.repr 255)) (Int.repr 16))
      (Int.or (Int.shl (Int.and (Shr 16 i) (Int.repr 255)) (Int.repr 8))
         (Shr 24 i))).

Lemma swap_swap: forall w, swap (swap w) = w.

Lemma map_swap_involutive:
 forall l, map swap (map swap l)  = l.

Lemma length_intlist_to_bytelist:
  forall l, length (intlist_to_bytelist l) = (4 * length l)%nat.

Lemma intlist_to_bytelist_bytes_to_int_cons:
  forall a b c d l,
     intlist_to_bytelist (bytes_to_Int a b c d :: l) =
     a::b::c::d:: intlist_to_bytelist l.

Lemma intlist_to_bytelist_to_intlist:
  forall il: list int,
   bytelist_to_intlist (intlist_to_bytelist il) = il.

Lemma intlist_to_bytelist_app:
 forall al bl, intlist_to_bytelist (al++bl) = intlist_to_bytelist al ++ intlist_to_bytelist bl.
Local Open Scope nat.

Local Open Scope Z.

Lemma int_unsigned_inj: forall a b, Int.unsigned a = Int.unsigned b -> a=b.

Lemma intlist_to_bytelist_inj: forall al bl, intlist_to_bytelist al = intlist_to_bytelist bl -> al=bl.

Lemma Zlength_intlist_to_bytelist_app:
 forall al bl,  Zlength (intlist_to_bytelist (al++bl)) =
    (Zlength (intlist_to_bytelist al) + Zlength (intlist_to_bytelist bl))%Z.

Local Open Scope Z.

Lemma divide_length_app:
 forall {A} n (al bl: list A),
      (n | Zlength al) ->
      (n | Zlength bl) ->
      (n | Zlength (al++bl)).

Lemma nth_list_repeat: forall A i n (x :A),
    nth i (list_repeat n x) x = x.

Lemma map_list_repeat:
  forall A B (f: A -> B) n x,
     map f (list_repeat n x) = list_repeat n (f x). *)

Require Import sha.ByteBitRelations.
(* sha.ByteBitRelations:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.ZArith.BinInt. 
Require Import Coq.ZArith.Zcomplements. 
Require Import compcert.lib.Integers.          
Require Import Coq.Numbers.Natural.Peano.NPeano.

Require Import Coq.Strings.Ascii.
Require Import Coq.Program.Tactics.
Require Import sha.XorCorrespondence. 
Require Import sha.Bruteforce.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.

Definition Blist := list bool.
Open Scope Z_scope.

Inductive InBlocks {A : Type} (n : nat) : list A -> Prop :=
  | InBlocks_nil : InBlocks n []
  | InBlocks_block : forall (front back full : list A),
                   length front = n ->
                   full = front ++ back ->
                   InBlocks n back ->
                   InBlocks n full.

Lemma InBlocks_len : forall {A : Type} (l : list A) (n : nat),
                       PeanoNat.Nat.divide (n) (length l) -> InBlocks n l.

Inductive bytes_bits_lists : Blist -> list byte -> Prop :=
  | eq_empty : bytes_bits_lists nil nil
  | eq_cons : forall (bits : Blist) (bytes : list byte)
                     (b0 b1 b2 b3 b4 b5 b6 b7 : bool) (b : byte),
                bytes_bits_lists bits bytes ->
                convertByteBits [b0; b1; b2; b3; b4; b5; b6; b7] b ->
                bytes_bits_lists (b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: bits)
                                 (b :: bytes).

Definition div_mod (num : Z) (denom : Z) : bool * Z :=
  (Z.gtb (num / denom) 0, num mod denom).

Definition byteToBits (byte : byte) : Blist :=
  let (b7, rem7) := div_mod (Byte.unsigned byte) 128 in
  let (b6, rem6) := div_mod rem7 64 in
  let (b5, rem5) := div_mod rem6 32 in
  let (b4, rem4) := div_mod rem5 16 in
  let (b3, rem3) := div_mod rem4 8 in
  let (b2, rem2) := div_mod rem3 4 in
  let (b1, rem1) := div_mod rem2 2 in
  let (b0, rem0) := div_mod rem1 1 in
  [b0; b1; b2; b3; b4; b5; b6; b7].

Fixpoint bytesToBits (bytes : list byte) : Blist :=
  match bytes with
    | [] => []
    | byte :: xs => byteToBits byte ++ bytesToBits xs
  end.

Definition bitsToByte (bits : Blist) : byte :=
  Byte.repr 
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: nil =>
      (1 * (asZ b0) + 2 * (asZ b1) + 4 * (asZ b2) + 8 * (asZ b3)
      + 16 * (asZ b4) + 32 * (asZ b5) + 64 * (asZ b6) + 128 * (asZ b7))
    | _ => -1                  
  end.

Fixpoint bitsToBytes (bits : Blist) : list byte :=
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs =>
      bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] :: bitsToBytes xs
    | _ => []
  end.

Lemma byteToBits_length bt: length (byteToBits bt) = 8%nat.

Lemma bytes_bits_length : forall (bits : Blist) (bytes : list byte),
  bytes_bits_lists bits bytes -> length bits = (length bytes * 8)%nat.

Lemma bytesToBits_app : forall (l1 l2 : list byte),
                          bytesToBits (l1 ++ l2) = bytesToBits l1 ++ bytesToBits l2.

Lemma bytesToBits_len : forall (l : list byte),
                          length (bytesToBits l) = (length l * 8)%nat.

Theorem byte_bit_byte_id : forall (b : byte),
                                bitsToByte (byteToBits b) = b.

Theorem bits_byte_bits_id : forall (b0 b1 b2 b3 b4 b5 b6 b7 : bool),
                              [b0; b1; b2; b3; b4; b5; b6; b7] =
                              byteToBits (bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7]).

Theorem bytes_bits_bytes_id : forall (bytes : list byte),
                                bitsToBytes (bytesToBits bytes) = bytes.

Theorem bytes_bits_def_eq : forall (bytes : list byte),
                              bytes_bits_lists (bytesToBits bytes) bytes.

Theorem bytes_bits_comp_ind : forall (bits : Blist) (bytes : list byte),
                               bits = bytesToBits bytes ->
                               bytes_bits_lists bits bytes.

Theorem bytes_bits_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bytes = bitsToBytes bits.

Theorem bits_bytes_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bits = bytesToBits bytes.

Lemma bitsToBytes_app : forall (l m : Blist),
                          InBlocks 8 l ->
                          bitsToBytes (l ++ m) = bitsToBytes l ++ bitsToBytes m.

Lemma bitsToBytes_len_gen : forall (l : Blist) (n : nat),
                          length l = (n * 8)%nat ->
                          length (bitsToBytes l) = n.

Lemma bitsToBytes_len : forall (l : Blist),
                          length l = 512%nat ->
                          Zlength (bitsToBytes l) = 64%Z.

Lemma bits_bytes_bits_id : forall (l : Blist),
                             InBlocks 8 l ->
                             bytesToBits (bitsToBytes l) = l.

Lemma bytes_bits_lists_append:
  forall (l1 : Blist) (l2 : list byte) (m1 : Blist) (m2 : list byte),
    bytes_bits_lists l1 l2
    -> bytes_bits_lists m1 m2
    -> bytes_bits_lists (l1 ++ m1) (l2 ++ m2).

Lemma bytesToBits_nil_inv l: nil = bytesToBits l -> l = nil.

Lemma bytesToBits_cons b l:
      bytesToBits (b::l) = byteToBits b ++ bytesToBits l.

Lemma byteToBits_injective: forall a b,
      byteToBits a = byteToBits b ->
      a = b.

Lemma bytesToBits_injective: forall b1 b2, bytesToBits b1 = bytesToBits b2 ->
       b1=b2.

Lemma bitsToBytes_injective8 b1 b2 (B: bitsToBytes b1 = bitsToBytes b2)
       (L1: PeanoNat.Nat.divide 8 (length b1))

Lemma bitsToByte_cons: forall bits h t, (h::t) = bitsToBytes bits ->
      exists b0, exists b1, exists b2, exists b3,
      exists b4, exists b5, exists b6, exists b7, exists xs,
      bits = b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs /\
      h = bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] /\
      t = bitsToBytes xs.

Definition intsToBits (l : list Int.int) : list bool :=
  bytesToBits (intlist_to_bytelist l).

Definition bitsToInts (l : Blist) : list Int.int :=
  bytelist_to_intlist (bitsToBytes l). *)

Require Import sha.HMAC_spec_concat.
(* sha.HMAC_spec_concat:
Set Implicit Arguments.

Require Import List.
Require Import sha.ByteBitRelations. 
Require Import sha.HMAC_common_defs.
Require Import sha.HMAC_spec_pad.

Module HMAC_Concat.
Section HMAC.
  Variable c:nat.
  Variable p:nat.
  Definition b := (c+p)%nat.
  Variable B: (0<b)%nat.

  Variable h : Blist -> Blist -> Blist.

  Variable iv : Blist.

  Definition h_star k (m : Blist) :=
    hash_blocks_bits b B h k m.

  Definition hash_words := h_star iv.

  Variable splitAndPad : Blist -> Blist.

  Variable fpad : Blist -> Blist.
  Definition app_fpad (x : Blist) : Blist :=
    x ++ fpad x.

  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GHMAC_2K (k : Blist) m :=
    let (k_Out, k_In) := splitList b k in
      let h_in := (hash_words (k_In ++ m)) in
        hash_words (k_Out ++ app_fpad h_in).

  Definition HMAC_2K (k : Blist) (m : Blist) :=
    GHMAC_2K k (splitAndPad m).

  Variable opad ipad : Blist.

  Definition HMAC (k : Blist) :=
    HMAC_2K (BLxor k opad ++ BLxor k ipad).

End HMAC.

Lemma h_star_eq :
  sha.HMAC_spec_pad.h_star = h_star.

Theorem HMAC_concat_pad c p (C: NPeano.Nat.divide 8 c) B sap sap' fp

End HMAC_Concat. *)

Require Import sha.HMAC_spec_pad.
(* sha.HMAC_spec_pad:
Set Implicit Arguments.

Require Import compcert.lib.Coqlib.
Require Import Coq.Program.Basics. 
Require Import List. Import ListNotations.
Require Import compcert.lib.Integers.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.
Require Import sha.ByteBitRelations.
Require Import sha.HMAC_common_defs.

Local Open Scope program_scope.

Section HMAC.
  Variable c:nat.
  Variable p:nat.
  Definition b := (c+p)%nat.
  Variable B: (0<b)%nat.

  Variable h : Blist -> Blist -> Blist.

  Variable iv : Blist.

  Definition h_star k (m : Blist) :=
    hash_blocks_bits b B h k m.

  Definition hash_words := h_star iv.

  Variable splitAndPad : Blist -> Blist.

  Definition hash_words_padded : Blist -> Blist :=
    hash_words ∘ splitAndPad.

  Variable fpad : Blist.

  Definition app_fpad (x : Blist) : Blist :=
    x ++ fpad.
  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GHMAC_2K (k : Blist) m :=
    let (k_Out, k_In) := splitList b k in 
      let h_in := (hash_words_padded (k_In ++ m)) in
        hash_words_padded (k_Out ++ h_in).

  Definition HMAC_2K (k : Blist) (m : Blist) :=
    
    GHMAC_2K k m.

  Variable opad ipad : Blist.

  Definition HMAC (k : Blist) :=
    HMAC_2K (BLxor k opad ++ BLxor k ipad).

End HMAC.

Definition convert (l : list int) : list bool :=
  bytesToBits (intlist_to_bytelist l).

Lemma front_equiv b d (DB32: (d*32)%nat = b):
  forall (back : Blist) (BACK : list int) (front : Blist) (FRONT : list int),
    (length front)%nat = b ->
    (length FRONT)%nat = d ->
    front ++ back = convert (FRONT ++ BACK) ->
    front = convert FRONT.

Lemma back_equiv b d (DB32: (d*32)%nat = b):
  forall (back : Blist) (BACK : list int) (front : Blist) (FRONT : list int),
    (length front)%nat = b ->
    (length FRONT)%nat = d ->
    front ++ back = convert (FRONT ++ BACK) ->
    back = convert BACK.

Module Type INST.
Parameter shah : Blist -> Blist ->  Blist.
Parameter hashblock : list int -> list int -> list int.
Parameter HHB : shah =
      (fun rgs bl : Blist =>
       intsToBits (hashblock (bitsToInts rgs) (bitsToInts bl))).

Parameter hashblocks: list int -> list int -> list int.
Parameter d:nat.

Parameter HBS_eq : forall r msg : list int,
         hashblocks r msg =
         match msg with
         | [] => r
         | _ :: _ => hashblocks (hashblock r (firstn d msg)) (skipn d msg)
         end.
End INST.

Require Import sha.HMAC_functional_prog. 

Module HMAC_Pad (HF:HP.HASH_FUNCTION) (I:INST).

Module HM:= HP.HMAC_FUN HF.

Lemma xor_equiv_byte: forall xpad XPAD k K, 
                          bytes_bits_lists xpad (HM.sixtyfour XPAD) ->

Lemma hash_block_equiv:
  forall (bits : Blist) (bytes : list byte)
         (regs : Blist) REGS,
    regs = bytesToBits (intlist_to_bytelist REGS) ->
    bits = bytesToBits bytes ->
    I.shah regs bits =

Lemma fold_equiv_blocks b (B:(0<b)%nat) (DB32: (I.d*32)%nat=b):

Lemma equiv_pad shaiv shasplitandpad c p (B: (0< b c p)%nat) (DB32: (I.d*32 =b c p)%nat)

Theorem HMAC_pad_concrete splitandpad c p (B: (0< b c p)%nat) (BS: (HF.BlockSize * 8)%nat = b c p)

Theorem HMAC_pad_concrete' splitandpad c p (B: (0< b c p)%nat) (BS: (HF.BlockSize * 8)%nat =b c p)

End HMAC_Pad. *)



Require Import sha.sha_padding_lemmas. 
(* sha.sha_padding_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Integers.
Require Import List. Import ListNotations.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.
Require Import sha.SHA256.
Require Import sha.pure_lemmas.
Require Import sha.functional_prog.

Inductive InWords : list byte -> Prop :=
  | words_nil : InWords []
  | words_word : forall (a b c d : byte) (msg : list byte),
                   InWords msg -> InWords (a :: b :: c :: d :: msg).

Definition pad (msg : list byte) : list byte :=
  let n := Zlength msg in
  msg ++ [Byte.repr 128%Z]
      ++ list_repeat (Z.to_nat (-(n + 9) mod 64)) Byte.zero
      ++ intlist_to_bytelist (([Int.repr (n * 8 / Int.modulus); Int.repr (n * 8)])%list).

Definition generate_and_pad' (msg : list byte) : list int :=
  bytelist_to_intlist (pad msg).

Lemma fstpad_len :
  forall (msg : list byte),
    Datatypes.length (msg ++ [Byte.repr 128]

Lemma InWords_len4 : forall (l : list byte),
                       Nat.divide (Z.to_nat WORD) (length l) -> InWords l.

Lemma pad_len_64_mod : forall (msg : list byte),
                           (Zlength (pad msg)) mod 64 = 0.

Lemma pad_len_64 : forall (msg : list byte), exists (n : Z),
                           Zlength (pad msg) = 64 * n /\ n >= 0.

Lemma pad_len_64_nat : forall (msg : list byte), exists (n : nat),
                           (length (pad msg))%nat = (64 * n)%nat.

Lemma total_pad_len_Zlist : forall (msg : list byte), exists (n : nat),
     length
       (msg ++ [Byte.repr 128] ++ list_repeat (Z.to_nat (- (Zlength msg + 9) mod 64)) Byte.zero)

Lemma pad_inwords :
  forall (msg : list byte),
    InWords (msg ++ [Byte.repr 128]

Definition fulllen (len : Z) :=
  len + 1%Z + (- (len + 9) mod 64).

Lemma app_left : forall (a b c d : list byte),
   a ++ b ++ c ++ d = (a ++ b ++ c) ++ d.

Theorem pad_compose_equal : forall (msg : list byte),
                              generate_and_pad' msg = generate_and_pad msg.

Theorem length_equal_pad_length : forall (msg1 : list byte) (msg2 : list byte),
     Zlength msg1  = Zlength msg2 ->
     Zlength (generate_and_pad msg1) = Zlength (generate_and_pad msg2). *)

Require Import sha.ShaInstantiation.
(* sha.ShaInstantiation:
Require Import compcert.lib.Integers.
Require Import Recdef.
Require Import List. Import ListNotations.
Require Import Arith.
Require Import compcert.lib.Coqlib.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.
Require Import sha.ByteBitRelations.
Require Import sha.HMAC_common_defs.

Require Import sha.SHA256.
Require Import sha.HMAC_functional_prog.
Require Import sha.HMAC256_functional_prog.
Require Import sha.hmac_common_lemmas.

Require Import sha.pure_lemmas.
Require Import sha.sha_padding_lemmas.
Require Import VST.floyd.sublist. 
Import List.

Definition c := (32 * 8)%nat.
Definition p := (32 * 8)%nat.
Definition b := (c + p)%nat.
Definition BlockSize := 64.
Definition BlockSize_Bits := BlockSize * 8.

Definition sha_iv : Blist :=
  intsToBits SHA256.init_registers.

Definition sha_h (regs : Blist) (block : Blist) : Blist :=
  intsToBits (SHA256.hash_block (bitsToInts regs) (bitsToInts block)).

Definition sha_splitandpad (msg : Blist) : Blist :=
  bytesToBits (sha_padding_lemmas.pad (bitsToBytes msg)).

Definition fpad_inner (msg : list byte) : list byte :=
  (let n := BlockSize + Zlength msg in
  [Byte.repr 128%Z]
    ++ list_repeat (Z.to_nat (-(n + 9) mod 64)) Byte.zero
    ++ intlist_to_bytelist ([Int.repr (n * 8 / Int.modulus); Int.repr (n * 8)]))%list.

Lemma fpad_inner_length l (L:length l = p): (length (fpad_inner (bitsToBytes l)) * 8)%nat = p.

Definition fpad (msg : Blist) : Blist :=
  bytesToBits (fpad_inner (bitsToBytes msg)).

Lemma fpad_length msg (M:length msg = c): length (fpad msg) = p.

Lemma xor_equiv_byte: forall xpad XPAD k K, 
                          bytes_bits_lists xpad (HMAC_SHA256.sixtyfour XPAD) ->

Lemma fold_left_iv_length: forall k (HK: forall iv x, length iv = k -> length (sha_h iv x) = k) l iv x ,
  length iv = k ->
  length (fold_left sha_h l (sha_h iv x)) = k.

Definition pad_inc (msg : list byte) : list byte :=
  let n := BlockSize + Zlength msg in
  msg ++ [Byte.repr 128%Z]
      ++ list_repeat (Z.to_nat (-(n + 9) mod 64)) Byte.zero
      ++ intlist_to_bytelist ([Int.repr (n * 8 / Int.modulus); Int.repr (n * 8)]).

Definition sha_splitandpad_inc (msg : Blist) : Blist :=
  bytesToBits (pad_inc (bitsToBytes msg)).

Lemma sha_splitandpad_inc_nil: length (sha_splitandpad_inc nil) = 512%nat.

Lemma pad_inc_length: forall l, exists k, (0 < k /\ length (pad_inc l) = k*64)%nat.

Lemma sha_splitandpad_inc_length: forall m, exists k,
      (0<k /\ length (sha_splitandpad_inc m) = k * 512)%nat.

Lemma sha_splitandpad_inc_InBlocks m : InBlocks 512 (sha_splitandpad_inc m).

Lemma sha_iv_length: length sha_iv = 256%nat.

Lemma hash_blocks_bits_len': forall r l, length r = 256%nat ->
      InBlocks 512 l ->
      length (hash_blocks_bits _ B sha_h r l) = 256%nat.

Lemma sha_h_length iv blk: length iv = c -> length blk = b ->
      length (sha_h iv blk) = c.

Lemma pad_injective_aux (l1 l2: list byte) k
     (K : k * Int.modulus + (BlockSize + Zlength l1) * 8 =

Lemma pad_injective_Case5 l1 l2
  (H0 : (l1 ++ Byte.repr 128 :: nil) ++

Lemma pad_inc_injective: forall l1 l2, pad_inc l1 = pad_inc l2 -> l1=l2.

Lemma block_8 A (l:list A): length l = b -> InBlocks 8 l.

Lemma sha_splitandpad_app : forall (l m : Blist),
                         length l = b ->
                         sha_splitandpad (l ++ m) = l ++ sha_splitandpad_inc m. *)



Lemma sha_splitandpad_fpad : forall (l m : Blist),

                  length l = b ->

                  InBlocks 8 m ->

                  sha_splitandpad (l ++ m) = l ++ HMAC_Concat.app_fpad fpad m.

Proof.

  intros l m len len_m.

  unfold HMAC_Concat.app_fpad.

  unfold sha_splitandpad. unfold fpad.

  unfold pad. unfold fpad_inner.



  rewrite -> bitsToBytes_app.

  repeat rewrite -> bytesToBits_app.

  repeat rewrite -> bits_bytes_bits_id.

  rewrite <- app_assoc.

  rewrite -> sublist.Zlength_app.

  repeat f_equal.



  * apply bitsToBytes_len. apply len.

  * apply bitsToBytes_len. apply len.

  * apply bitsToBytes_len. apply len.

  * apply len_m.

  * apply block_8. apply len.

  * apply block_8. apply len.

Qed.



Theorem HMAC_concat_pad_sap_instantiated

        h (HH: forall x y, length x = c -> length y = b -> length (h x y)  = c)

        iv (IV: length iv = c) (op ip : Blist) (IL: length ip = b) (OL: length op = b)

        : forall (k m : Blist), length k = b ->

  sha.HMAC_spec_pad.HMAC c p B h iv sha_splitandpad op ip k m =

  HMAC_Concat.HMAC c p B h iv sha_splitandpad_inc fpad op ip k m.

Proof. intros.

  apply HMAC_Concat.HMAC_concat_pad; trivial.

  exists 32%nat. reflexivity.

  apply sha_splitandpad_app.

  apply sha_splitandpad_fpad.

  apply sha_splitandpad_inc_InBlocks.

Qed.



Theorem HMAC_concat_pad_explicit : forall (k m : Blist) (op ip : Blist),

                            length k = b ->

                            length ip = b ->

                            length op = b ->

  sha.HMAC_spec_pad.HMAC c p B sha_h sha_iv sha_splitandpad op ip k m =

  HMAC_Concat.HMAC c p B sha_h sha_iv sha_splitandpad_inc fpad op ip k m.

Proof.

  intros k m op ip len_k len_ip len_op.

  apply HMAC_concat_pad_sap_instantiated; trivial.

    apply sha_h_length.

Qed.

