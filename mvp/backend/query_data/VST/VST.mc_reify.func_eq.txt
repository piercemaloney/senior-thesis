Require Import ExtLib.Data.Positive.

Require Import mc_reify.funcs.
(* mc_reify.funcs:
Require Import MirrorCore.syms.SymEnv.
Require Import MirrorCore.Lambda.ExprCore.
Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import VST.floyd_funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import VST.floyd.local2ptree.
Require Import mc_reify.local2list.

Inductive const :=
| fN : nat -> const
| fZ : Z -> const
| fint : int -> const
| fint64 : int64 -> const
| fPos : positive -> const
| fident : ident -> const
| fCtype : type -> const
| fCexpr : expr -> const
| fComparison : comparison -> const
| fbool : bool -> const
| ffloat : float -> const
| ffloat32 : float32 -> const
| fenv : type_id_env -> const
| fllrr : LLRR -> const
.

Definition typeof_const (c : const) : typ :=
 match c with
| fN _ => tynat
| fZ _ => tyZ
| fPos _ => typositive
| fident _ => tyident
| fCtype _ => tyc_type
| fCexpr _ => tyc_expr
| fComparison _ => tycomparison
| fbool _ => tybool
| fint _ => tyint
| fint64 _ => tyint64
| ffloat _ => tyfloat
| ffloat32 _ => tyfloat32
| fenv _ => tytype_id_env
| fllrr _ => tyllrr
end.

Definition constD (c : const)
: typD (typeof_const c) :=
match c with
| fN c | fZ c | fPos c | fident c | fCtype c | fCexpr c | fComparison c | fbool c | fint c
| fint64 c | ffloat c | ffloat32 c | fenv c | fllrr c
                                          => c
end.

Inductive z_op :=
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max
| fZ_opp.

Definition typeof_z_op z : typ :=
match z with
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge => (tyArr tyZ (tyArr tyZ typrop))
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max => (tyArr tyZ (tyArr tyZ tyZ))
| fZ_opp => (tyArr tyZ tyZ)
end.

Definition z_opD (z : z_op) : typD  (typeof_z_op z) :=
match z with
| fZ_lt => Z.lt
| fZ_le => Z.le
| fZ_gt => Z.gt
| fZ_ge => Z.ge
| fZ_add => Z.add
| fZ_sub => Z.sub
| fZ_mul => Z.mul
| fZ_div => Z.div
| fZ_mod => Zmod
| fZ_land => Z.land
| fZ_max => Z.max
| fZ_opp => Z.opp
end.

Inductive int_op :=
| fint_add
| fint_and
| fint_lt
| fint_ltu
| fint_mul
| fint_neg
| fint_sub
| fint_cmp
| fint_cmpu
| fint_repr
| fint_signed
| fint_unsigned
| fint_max_unsigned
| fint64_repr.

Definition typeof_int_op i : typ :=
match i with
| fint_lt
| fint_ltu => tyArr tyint (tyArr tyint tybool)
| fint_mul
| fint_sub
| fint_add => tyArr tyint (tyArr tyint tyint)
| fint_and => tyArr tyint (tyArr tyint tyint)
| fint_neg => tyArr tyint tyint
| fint_cmp
| fint_cmpu => tyArr tycomparison (tyArr tyint (tyArr tyint tybool))
| fint_repr => tyArr tyZ tyint
| fint_signed
| fint_unsigned  => tyArr tyint tyZ
| fint_max_unsigned => tyZ
| fint64_repr => tyArr tyZ tyint64
end.

Definition int_opD (i : int_op): typD  (typeof_int_op i) :=
match i with
| fint_add => Int.add
| fint_and => Int.and
| fint_lt => Int.lt
| fint_ltu => Int.ltu
| fint_mul => Int.mul
| fint_neg => Int.neg
| fint_sub => Int.sub
| fint_cmp => Int.cmp
| fint_cmpu => Int.cmpu
| fint_repr => Int.repr
| fint_signed => Int.signed
| fint_unsigned => Int.unsigned
| fint_max_unsigned => Int.max_unsigned
| fint64_repr => Int64.repr
end.

Inductive values :=
| fVint
| fVfloat
| fVlong
| fVptr
| fVundef
| fVsingle.

Definition typeof_value (v : values) :=
match v with
| fVint => tyArr tyint tyval
| fVfloat => tyArr tyfloat tyval
| fVlong => tyArr tyint64 tyval
| fVptr => tyArr typositive (tyArr tyint tyval)
| fVsingle => tyArr tyfloat32 tyval
| fVundef => tyval
end.

Definition valueD  (v : values): typD  (typeof_value v) :=
match v with
| fVint => Vint
| fVfloat => Vfloat
| fVlong => Vlong
| fVptr => Vptr
| fVsingle => Vsingle
| fVundef => Vundef
end.

Inductive eval :=
| feval_cast : type -> type -> eval
| fderef_noload : type -> eval
| feval_field : type -> ident -> eval
| feval_binop : binary_operation -> type -> type -> eval
| feval_unop : unary_operation -> type -> eval
| feval_id : ident -> eval.

Definition typeof_eval (e : eval) :=
 match e with
| feval_cast _ _ => (tyArr tyval tyval)
| fderef_noload _ => (tyArr tyval tyval)
| feval_field _ _ => (tyArr tyval tyval)
| feval_binop _ _ _=> (tyArr tyval (tyArr tyval tyval))
| feval_unop _ _ => (tyArr tyval tyval)
| feval_id _  => (tyArr tyenviron tyval)
end.

Definition evalD  (e : eval) : typD  (typeof_eval e) :=
match e with
| feval_id id => eval_id id
| feval_cast t1 t2 => eval_cast t1 t2
| fderef_noload t => deref_noload t
| feval_field t id => eval_field t id
| feval_binop op t1 t2 => eval_binop op t1 t2
| feval_unop op t => eval_unop op t
end.

Inductive other :=
| ftwo_power_nat
| fforce_ptr
| fand
| falign
| ftyped_true
| feq : typ -> other
| fnone : typ -> other
| fsome : typ -> other
| ftypeof
| fTrue
| fFalse
.

Definition typeof_other (o : other) :=
match o with
| ftwo_power_nat => tyArr tynat tyZ
| fforce_ptr  => tyArr tyval tyval
| fand => tyArr typrop (tyArr typrop typrop)
| falign => tyArr tyZ (tyArr tyZ tyZ)
| ftyped_true => tyArr tyc_type (tyArr tyval typrop)
| feq t => tyArr t (tyArr t typrop)
| fnone t => tyoption t
| fsome t => tyArr t (tyoption t)
| ftypeof => tyArr tyc_expr tyc_type
| fTrue | fFalse => typrop
end.

Definition otherD  (o : other) : typD  (typeof_other o) :=
match o with
| ftwo_power_nat => (two_power_nat : typD (typeof_other ftwo_power_nat))
| fforce_ptr => force_ptr
| fand => and
| falign => align
| ftyped_true => typed_true
| feq t => @eq (typD t)
| fsome t => @Some (typD t)
| fnone t => @None (typD t)
| ftypeof => typeof
| fTrue => True
| fFalse => False
end.

Inductive data :=
| fnil : typ -> data
| fmap : typ -> typ -> data
| ffold_right : typ -> typ -> data
| ffold_left : typ -> typ -> data
| fcons : typ -> data
| fappend : typ -> data
| fnth_error : typ -> nat -> data
| freplace_nth : typ -> nat -> data
| fpair : typ -> typ -> data
| fget : typ -> positive -> data
| fset : typ -> positive -> data
| fleaf : typ -> data
| fnode : typ -> data
| fempty : typ -> data
.

Definition typeof_data (l : data) :=
match l with
| fmap a b => tyArr (tyArr a b) (tyArr (tylist a) (tylist b))
| fnil a => (tylist a)
| ffold_right a b => tyArr (tyArr b (tyArr a a)) (tyArr a (tyArr (tylist b) a))
| ffold_left a b => tyArr (tyArr a (tyArr b a)) (tyArr (tylist b) (tyArr a a))
| fcons a => tyArr a (tyArr (tylist a) (tylist a))
| fappend a => tyArr (tylist a) (tyArr (tylist a) (tylist a))
| fnth_error a _ => tyArr (tylist a) (tyoption a)
| freplace_nth a _ => tyArr (tylist a) (tyArr a (tylist a))
| fpair t1 t2 => tyArr t1 (tyArr t2 (typrod t1 t2))
| fleaf t => typtree t
| fnode t => tyArr (typtree t) (tyArr (tyoption t) (tyArr (typtree t) (typtree t)))
| fset t _ => tyArr t (tyArr (typtree t) (typtree t))
| fget t _ => (tyArr (typtree t) (tyoption t))
| fempty t => typtree t
end.

Definition dataD (l : data) : typD (typeof_data l) :=
match l with
| fmap t1 t2 => @map (typD  t1) (typD  t2)
| fnil t => (@nil (typD t) : typD (typeof_data (fnil t)))
| ffold_right a b => @fold_right (typD a) (typD b)
| ffold_left a b => @fold_left (typD a) (typD b)
| fcons a => @cons (typD a)
| fappend a => @app (typD a)
| fnth_error a n => fun l => @nth_error (typD a) l n
| freplace_nth a n => @canon.replace_nth (typD a) n
| fpair a b => ((@pair (typD a) (typD b)) : typD (typeof_data (fpair a b)))
| fleaf t => @PTree.Leaf (typD t)
| fnode t => @PTree.Node (typD t)
| fset t p => @PTree.set (typD t) p
| fget t p => @PTree.get (typD t) p
| fempty t => @PTree.empty (typD t)
end.

Inductive sep :=
| flocal
| fprop
| fdata_at : type -> sep
| ffield_at : type -> list gfield -> sep
| fproj_val : type -> sep
| fupd_val : type -> sep

.

Fixpoint reptyp (ty: type) : typ :=
  match ty with
  | Tvoid => tyunit
  | Tint _ _ _ => tyval
  | Tlong _ _ => tyval
  | Tfloat _ _ => tyval
  | Tpointer t1 a => tyval
  | Tarray t1 sz a => tylist (reptyp t1)
  | Tfunction t1 t2 _ => tyunit
  | Tstruct id fld a => reptyp_structlist fld
  | Tunion id fld a => reptyp_unionlist fld
  | Tcomp_ptr id a => tyval
  end
with reptyp_structlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else typrod (reptyp ty) (reptyp_structlist fld')
  end
with reptyp_unionlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else tysum (reptyp ty) (reptyp_unionlist fld')
  end.

Definition typeof_sep (s : sep) : typ :=
match s with
| fdata_at t => tyArr tyshare (tyArr (reptyp t) (tyArr tyval tympred))
| ffield_at t gfs => tyArr tyshare (tyArr (reptyp (nested_field_type2 t gfs)) (tyArr tyval tympred))

| flocal => tyArr (tyArr tyenviron typrop) (tyArr tyenviron tympred)
| fprop => tyArr typrop tympred
| fproj_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t) tyval)
| fupd_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t)
                  (tyArr tyval (reptyp t)))
end.

Definition proj1T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => y
  end.

Definition proj2T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => z
  end.

Definition typD_reptyp_reptype: forall t, typD  (reptyp t) = reptype t.

Definition reptyp_reptype ty (v: typD  (reptyp ty)): reptype ty :=
  eq_rect_r (fun x => x) v (eq_sym (typD_reptyp_reptype ty)).

Definition reptype_reptyp ty (v: reptype ty): typD  (reptyp ty) :=
  eq_rect_r (fun x => x) v (typD_reptyp_reptype ty).

Lemma reptyp_reptype_reptype_reptyp: forall t v, reptyp_reptype t (reptype_reptyp t v) = v.

Definition sepD  (s : sep) : typD  (typeof_sep s).

Inductive smx :=
| fenviron : environ -> smx
| fsemax
| fstatement : statement -> smx
| fretassert : ret_assert -> smx
| ftycontext : PTree.t (type * bool) -> PTree.t type -> type -> PTree.t type ->  smx
| fupdate_tycon

| fnormal_ret_assert

| fassertD
| flocalD
| fvaltree : PTree.t val -> smx
| fdenote_tc_assert_b_norho
| ftc_expr_b_norho
| ftc_temp_id_b_norho : positive -> type ->  smx

| flater
| flater_lift
| fnested_field_type2
| fis_neutral_cast
| fmsubst_efield_denote : list efield -> smx
| flegal_nested_efield : list type -> smx
| fmsubst_eval_LR
| ftc_LR_b_norho
| ftc_environ
| ftc_efield_b_norho : list efield -> smx
| fnested_efield
| ftypeof_temp
| ftc_val
| flegal_nested_field
| fstruct_field
| funion_field
| farray_subsc
| fwritable_share
| fTsh
| fEws
| ftype_is_by_value
.

Definition typeof_smx (t : smx) :=
match t with
| fsemax => tyArr tyOracleKind (tyArr tytycontext (tyArr (tyArr tyenviron tympred) (tyArr tystatement (tyArr tyret_assert typrop))))
| fstatement s => tystatement
| fretassert r => tyret_assert
| ftycontext _ _ _ _ => tyArr (typtree tyfunspec) tytycontext

| fnormal_ret_assert => tyArr (tyArr tyenviron tympred) (tyret_assert)
| fenviron e => tyenviron
| flocalD  => tyArr (typtree tyval)
                    (tyArr (typtree (typrod tyc_type tyval)) (tylist (tyArr tyenviron typrop)))
| fupdate_tycon => tyArr tytycontext (tyArr tystatement tytycontext)
| fvaltree t => typtree tyval
| fassertD => tyArr  (tylist typrop) (tyArr (tylist (tyArr tyenviron typrop)) (tyArr (tylist tympred) (tyArr tyenviron tympred)))
| fdenote_tc_assert_b_norho => tyArr tytc_assert tybool
| ftc_expr_b_norho => tyArr tytycontext (tyArr tyc_expr tybool)
| ftc_temp_id_b_norho _ _  => tyArr tytycontext (tyArr tyc_expr tybool)

| flater => tyArr tympred tympred
| flater_lift => tyArr (tyArr tyenviron tympred) (tyArr tyenviron tympred)
| fnested_field_type2 => tyArr tyc_type (tyArr (tylist tygfield) tyc_type)
| fis_neutral_cast => tyArr tyc_type (tyArr tyc_type tybool)
| fmsubst_efield_denote _ => tyArr (typtree tyval)
                           (tyArr (typtree (typrod tyc_type tyval))
                                 (tyoption (tylist tygfield)))
| flegal_nested_efield _ => tyArr tytype_id_env
                          (tyArr tyc_type
                           (tyArr tyc_expr
                            (tyArr (tylist tygfield)
                              (tyArr tyllrr tybool))))
| fmsubst_eval_LR => tyArr (typtree tyval)
                     (tyArr (typtree (typrod tyc_type tyval))
                      (tyArr tyc_expr
                       (tyArr tyllrr (tyoption tyval))))
| ftc_LR_b_norho => tyArr tytycontext (tyArr tyc_expr (tyArr tyllrr tybool))
| ftc_environ => tyArr tytycontext (tyArr tyenviron typrop)
| ftc_efield_b_norho efs => tyArr tytycontext tybool
| fnested_efield => tyArr tyc_expr
                    (tyArr (tylist tyefield)
                     (tyArr (tylist tyc_type) tyc_expr))
| ftypeof_temp => tyArr tytycontext (tyArr tyident (tyoption tyc_type))
| ftc_val => tyArr tyc_type (tyArr tyval typrop)
| flegal_nested_field => tyArr tyc_type (tyArr (tylist tygfield) typrop)
| fstruct_field => tyArr tyident tygfield
| funion_field => tyArr tyident tygfield
| farray_subsc => tyArr tyZ tygfield
| fwritable_share => tyArr tyshare typrop
| fTsh => tyshare
| fEws => tyshare
| ftype_is_by_value => tyArr tyc_type tybool
end.

Definition smxD (t : smx) : typD (typeof_smx t) :=
match t with
| fsemax => (@semax : typD (typeof_smx fsemax))
| fstatement s | fretassert s  => s
| ftycontext t v r gt => fun gf => mk_tycontext t v r gt gf

| fnormal_ret_assert => normal_ret_assert
| fenviron e => (e : typD (typeof_smx (fenviron e)))
| flocalD => localD
| fupdate_tycon => update_tycon
| fvaltree t => t
| fassertD => assertD
| fdenote_tc_assert_b_norho => (denote_tc_assert_b_norho : typD (typeof_smx fdenote_tc_assert_b_norho))
| ftc_expr_b_norho => tc_expr_b_norho
| ftc_temp_id_b_norho id ty  => tc_temp_id_b_norho id ty

| flater => later
| flater_lift => later
| fnested_field_type2 => nested_field_type2
| fis_neutral_cast => is_neutral_cast
| fmsubst_efield_denote efs => (fun T1 T2 => msubst_efield_denote T1 T2 efs)
| flegal_nested_efield tts => (fun e t_root e1 gfs => legal_nested_efield e t_root e1 gfs tts)
| fmsubst_eval_LR => msubst_eval_LR
| ftc_LR_b_norho => tc_LR_b_norho
| ftc_environ => tc_environ
| ftc_efield_b_norho efs => (fun tycon => tc_efield_b_norho tycon efs)
| fnested_efield => nested_efield
| ftypeof_temp => typeof_temp
| ftc_val => tc_val
| flegal_nested_field => legal_nested_field
| fstruct_field => StructField
| funion_field => UnionField
| farray_subsc => ArraySubsc
| fwritable_share => writable_share
| fTsh => SeparationLogic.Tsh
| fEws => assert_lemmas.Ews
| ftype_is_by_value => client_lemmas.type_is_by_value
end.

Inductive func' :=
| Const : const -> func'
| Zop : z_op -> func'
| Intop : int_op -> func'
| Value : values -> func'
| Eval_f : eval -> func'
| Other : other -> func'
| Sep : sep -> func'
| Data : data -> func'
| Smx : smx -> func'.

Definition func := (SymEnv.func + @ilfunc typ + @bilfunc typ + func')%type.

Definition typeof_func (f: func') : typ :=
match f with
| Const c => typeof_const c
| Zop z => typeof_z_op z
| Intop i => typeof_int_op i
| Value v => typeof_value v
| Eval_f e => typeof_eval e
| Other o => typeof_other o
| Sep s => typeof_sep s
| Data l => typeof_data l
| Smx t => typeof_smx t
end.

Definition funcD  (f : func') : typD  (typeof_func f) :=
match f with
| Const c => constD  c
| Zop z => z_opD  z
| Intop i => int_opD  i
| Value v => valueD  v
| Eval_f e => evalD  e
| Other o => otherD  o
| Sep s => sepD  s
| Data l => dataD l
| Smx t => smxD t
end. *)

Require Import mc_reify.typ_eq.
(* mc_reify.typ_eq:
Require Import types.
Import Coq.Bool.Bool.

Fixpoint typ_beq a b :=
match a, b with
| tytycontext, tytycontext
| tyc_expr, tyc_expr
| tyc_type, tyc_type
| tyenviron, tyenviron
| tyval, tyval
| tyshare, tyshare
| tyident, tyident
| tyint, tyint
| tyZ, tyZ
| tynat, tynat
| typositive, typositive
| tybool, tybool
| tycomparison, tycomparison
| tytc_assert, tytc_assert
| tyint64, tyint64
| tyfloat, tyfloat
| tyattr, tyattr
| tysignedness, tysignedness
| tyintsize, tyintsize
| tyfloatsize, tyfloatsize
| tytypelist, tytypelist
| tyfieldlist, tyfieldlist
| tybinary_operation, tybinary_operation
| tyunary_operation, tyunary_operation
| tyN, tyN
| typrop, typrop
| tympred, tympred
| tyunit, tyunit
| tyOracleKind, tyOracleKind
| tystatement, tystatement
| tygfield, tygfield
| tyfunspec, tyfunspec
| tyret_assert, tyret_assert => true

| tysum tl1 tr1, tysum tl2 tr2
| typrod tl1 tr1, typrod tl2 tr2
| tyArr tl1 tr1, tyArr tl2 tr2 => andb (typ_beq tl1 tl2) (typ_beq tr1 tr2)
| tyoption t1, tyoption t2 => typ_beq t1 t2
| tylist t1, tylist t2 => typ_beq t1 t2
| _, _ => false
end.

SearchAbout BinPos.Pos.eqb.
Hint Resolve expr.eqb_type_true : beq_sound.
Hint Resolve BinPos.Peqb_true_eq : beq_sound.

Ltac prove_beq_sound :=
try solve [try reflexivity; inversion H];
repeat
match goal with
 | [H : typ_beq _ _ = true |- _ ] => simpl in H; rewrite andb_true_iff in H; destruct H
 | [ |- _ _ _ = _ _ _ ] => try f_equal
 | [ |- _ _  = _ _  ] => try f_equal
 | [H : forall x, _ -> ?a = x |- ?a = _ ] => apply H
end;
auto with beq_sound.

Lemma typ_beq_sound : forall a b, typ_beq a b = true -> a = b. *)

Require Import mc_reify.statement_eq.
(* mc_reify.statement_eq:
Fixpoint statement_beq s1 s2 :=
  match s1, s2 with
  | Sskip, Sskip
  | Sbreak, Sbreak
  | Scontinue, Scontinue => true
  | Sset id1 e1, Sset id2 e2 => andb (BinPos.Pos.eqb id1 id2) (expr_beq e1 e2)
  | Sassign e11 e21, Sassign e12 e22 =>  andb (expr_beq e11 e12) (expr_beq e21 e22)
  | Scall id1 e1 l1, Scall id2 e2 l2 => andb (andb (expr.eqb_option BinPos.Pos.eqb id1 id2) (expr_beq e1 e2)) (List.list_eqb _ l1 l2)
  | Sbuiltin _ _ _ _, Sbuiltin _ _ _ _ => false 
  | Ssequence st1 st2, Ssequence st3 st4
  | Sloop st1 st2, Sloop st3 st4 => andb (statement_beq st1 st3) (statement_beq st2 st4)
  | Sifthenelse e1 st1 st2, Sifthenelse e2 st3 st4 => andb (andb (statement_beq st1 st3) (statement_beq st2 st4)) (expr_beq e1 e2)
  | Sreturn e1, Sreturn e2 => expr.eqb_option expr_beq e1 e2
  | Slabel l1 s1, Slabel l2 s2 => andb (BinPos.Pos.eqb l1 l2) (statement_beq s1 s2)
  | Sgoto l1, Sgoto l2 => BinPos.Pos.eqb l1 l2
  | Sswitch e1 l1, Sswitch e2 l2 => andb (expr_beq e1 e2) (labeled_statements_beq l1 l2)
  | _ , _ => false
end
with labeled_statements_beq a b :=
match a, b with
| LSnil, LSnil => true
| LScons z1 s1 t1, LScons z2 s2 t2 => andb (andb (expr.eqb_option Zbool.Zeq_bool z1 z2) (statement_beq s1 s2)) (labeled_statements_beq t1 t2)
| _, _ => false
end.

Ltac destruct_ands :=
repeat rewrite andb_true_iff in *;
repeat
match goal with
| [ H: _ /\ _ |- _] => destruct H
end.

Lemma eqb_option_sound : forall T f a b,  (forall (x y : T), f x y = true -> x = y) -> expr.eqb_option f a b = true -> a = b.

Hint Resolve eqb_option_sound : expr_beq.

Lemma statement_beq_sound : forall s1 s2, statement_beq s1 s2 = true -> s1 = s2
with labeled_statements_beq_sound : forall ls1 ls2, labeled_statements_beq ls1 ls2 = true -> ls1 = ls2. *)

Require Import Coq.Arith.EqNat.

Require Import mc_reify.clight_expr_eq.
(* mc_reify.clight_expr_eq:
Require Import Clight.
Require Import Ctypes.
Require Import VST.veric.expr.
Require Import Integers.
Require Import Floats.
Require Import Zbool.
Require Import Coq.Numbers.BinNums.
Require Import Cop.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.List.

Definition beq_int (i1 i2 : Integers.int) : bool :=
Zbool.Zeq_bool (Int.intval i1) (Int.intval i2).

Lemma beq_int_true : forall a b, beq_int a b = true -> a = b.

Hint Resolve beq_int_true : expr_beq.

Lemma beq_int_refl : forall i, beq_int i i = true.

Hint Resolve beq_int_refl : expr_beq.
Hint Rewrite beq_int_refl : expr_beq.

Definition beq_long (i1 i2 : int64) : bool :=
Zeq_bool (Int64.intval i1) (Int64.intval i2).

Lemma beq_long_true : forall a b, beq_long a b = true -> a = b.

Lemma beq_long_refl : forall i, beq_long i i = true.

Hint Resolve beq_long_refl : expr_beq.
Hint Rewrite beq_long_refl : expr_beq.
Hint Resolve beq_long_true : expr_beq.

Definition beq_float_dec a b:= if Float.eq_dec a b then true else false.

Lemma beq_float_dec_true a b : beq_float_dec a b = true -> a = b.

Lemma beq_float_refl : forall a, beq_float_dec a a = true.

Hint Resolve beq_float_refl : expr_beq.
Hint Rewrite beq_float_refl : expr_beq.
Hint Resolve beq_float_dec_true : expr_beq.

Definition beq_float32_dec a b:= if Float32.eq_dec a b then true else false.

Lemma beq_float32_dec_true a b : beq_float32_dec a b = true -> a = b.

Lemma beq_float32_refl : forall a, beq_float32_dec a a = true.

Hint Resolve beq_float32_refl : expr_beq.
Hint Rewrite beq_float32_refl : expr_beq.

Hint Resolve beq_float32_dec_true : expr_beq.

Definition unary_op_beq a b :=
match a, b with
  | Onotbool, Onotbool
  | Onotint, Onotint
  | Oneg, Oneg
  | Oabsfloat, Oabsfloat => true
  | _, _ => false
end.

Lemma unary_op_beq_sound : forall a b, unary_op_beq a b = true -> a = b .

Lemma unary_op_beq_refl : forall a, unary_op_beq a a = true.

Hint Resolve unary_op_beq_refl : expr_beq.
Hint Rewrite unary_op_beq_refl : expr_beq.
Hint Resolve unary_op_beq_sound: expr_beq.

Definition binary_op_beq a b :=
match a, b with
    Oadd, Oadd
  | Osub, Osub
  | Omul, Omul
  | Odiv, Odiv
  | Omod, Omod
  | Oand, Oand
  | Oor, Oor
  | Oxor, Oxor
  | Oshl, Oshl
  | Oshr, Oshr
  | Oeq, Oeq
  | One, One
  | Olt, Olt
  | Ogt, Ogt
  | Ole, Ole
  | Oge, Oge => true
  | _, _ => false
end.

Lemma binary_op_beq_sound : forall a b, binary_op_beq a b = true -> a = b .

Lemma binary_op_beq_refl : forall a, binary_op_beq a a = true.

Hint Resolve binary_op_beq_refl : expr_beq.
Hint Rewrite binary_op_beq_refl : expr_beq.
Hint Resolve binary_op_beq_sound : expr_beq.

Fixpoint expr_beq a b :=
match a, b with
| Econst_int i1 ty1, Econst_int i2 ty2 => andb (beq_int i1 i2) (eqb_type ty1 ty2)
| Econst_float f1 ty1, Econst_float f2 ty2 => andb (beq_float_dec f1 f2) (eqb_type ty1 ty2)
| Econst_single f1 ty1, Econst_single f2 ty2 => andb (beq_float32_dec f1 f2) (eqb_type ty1 ty2)
| Econst_long l1 ty1, Econst_long l2 ty2 => andb (beq_long l1 l2) (eqb_type ty1 ty2)
| Evar id1 ty1, Evar id2 ty2
| Etempvar id1 ty1, Etempvar id2 ty2 => andb (BinPos.Pos.eqb id1 id2) (eqb_type ty1 ty2)
| Ederef e1 ty1, Ederef e2 ty2
| Eaddrof e1 ty1, Eaddrof e2 ty2
| Ecast e1 ty1, Ecast e2 ty2 => (andb (expr_beq e1 e2) (eqb_type ty1 ty2))
| Eunop op1 e1 ty1, Eunop op2 e2 ty2 => (andb (andb (unary_op_beq op1 op2) (expr_beq e1 e2)) (eqb_type ty1 ty2))
| Ebinop op1 e11 e21 ty1, Ebinop op2 e12 e22 ty2 => (andb (andb (andb (binary_op_beq op1 op2) (expr_beq e11 e12)) (eqb_type ty1 ty2)) (expr_beq e21 e22))
| Efield e1 id1 ty1, Efield e2 id2 ty2 => andb (andb (expr_beq e1 e2) (BinPos.Pos.eqb id1 id2)) (eqb_type ty1 ty2)
| _, _ => false
end.

Hint Rewrite Bool.andb_true_iff : expr_beq.
Hint Resolve eqb_type_true : expr_beq.
Hint Resolve BinPos.Peqb_true_eq : expr_beq.
Hint Rewrite BinPos.Pos.eqb_refl : expr_beq.
Hint Resolve BinPos.Pos.eqb_refl : expr_beq.
Hint Resolve eqb_type_refl : expr_beq.
Hint Rewrite eqb_type_refl : expr_beq.

Ltac solve_expr_beq_sound :=
try solve [simpl in *; try congruence]; try reflexivity;
simpl in *; autorewrite with expr_beq in *;
repeat match goal with
| [ H : _ /\ _  |- _] => destruct H
end;
try match goal with
| [ H : List.list_eqb ?r ?a ?b = _ |- _] => consider ( List.list_eqb r a b); intros
end;
try f_equal;
auto with expr_beq.

Lemma expr_beq_refl : forall a, expr_beq a a = true.

Hint Resolve expr_beq_refl : expr_beq.

Lemma expr_beq_spec : forall a b, expr_beq a b = true <-> a = b.

Lemma expr_beq_sound : forall a b, expr_beq a b = true -> a = b. *)

Require Import mc_reify.list_ctype_eq.
(* mc_reify.list_ctype_eq:
Instance RelDec_list_ctype_beq: RelDec (@eq (list type)) := List.RelDec_eq_list RelDec_ctype_beq.
Instance RelDec_Correct_list_ctype_beq: RelDec_Correct RelDec_list_ctype_beq :=
  List.RelDec_Correct_eq_list RelDec_Correct_ctype_beq. *)

Require Import mc_reify.list_efield_eq.
(* mc_reify.list_efield_eq:
Require Import Clight.
Require Import Ctypes.
Require Import VST.veric.expr.
Require Import VST.floyd.efield_lemmas.
Require Import mc_reify.clight_expr_eq.
Require Import compcert.common.AST.
Require Import ExtLib.Core.RelDec.

Definition efield_beq a b :=
  match a, b with
  | eStructField x, eStructField y => eqb_ident x y
  | eUnionField x, eUnionField y => eqb_ident x y
  | eArraySubsc x, eArraySubsc y => expr_beq x y
  | _, _ => false
  end.

Lemma efield_beq_spec: forall a b, efield_beq a b = true <-> a = b.

Instance RelDec_list_efield_beq: RelDec (@eq (list efield)) := List.RelDec_eq_list RelDec_efield_beq.
Instance RelDec_Correct_list_efield_beq: RelDec_Correct RelDec_list_efield_beq :=
  List.RelDec_Correct_eq_list RelDec_Correct_efield_beq. *)

Require Import ExtLib.Tactics.

Require Import ExtLib.Data.List.

Require Import ExtLib.Core.RelDec.



Fixpoint ptree_cmp {T : Type} (p1 p2: Maps.PTree.tree T)

         (e : T -> T -> bool) :=

match p1, p2 with

| Maps.PTree.Leaf, Maps.PTree.Leaf => true

| Maps.PTree.Node l1 i1 r1, Maps.PTree.Node l2 i2 r2 =>

  match i1, i2 with

    | Some v1, Some v2 => andb (e v1 v2)

                               (andb (ptree_cmp l1 l2 e)

                                     (ptree_cmp r1 r2 e))

    | None, None => (andb (ptree_cmp l1 l2 e)

                          (ptree_cmp r1 r2 e))

    | _, _ => false

  end

| _, _ => false

end.



Lemma ptree_cmp_sound : forall T p1 p2 e,

(forall (i1 i2 : T), e i1 i2 = true -> i1 = i2) ->

ptree_cmp p1 p2 e = true ->

p1 = p2.

Proof.

intros.

generalize dependent p2. induction p1; intros; destruct p2; auto;

simpl in *; try congruence.

destruct o, o0. simpl in *.

consider (e t t0); intros. specialize (H _ _ H0).

 subst.

consider (ptree_cmp p1_1 p2_1 e); intros.

apply IHp1_1 in H. apply IHp1_2 in H1. subst.

auto.

simpl in *; congruence.

simpl in *; congruence.

congruence. congruence.

consider (ptree_cmp p1_1 p2_1 e); intros.

apply IHp1_1 in H0. apply IHp1_2 in H1.

subst; auto.

simpl in *; congruence.

Qed.



Definition const_beq a b :=

match a, b with

| fN c1, fN c2 => beq_nat c1 c2

| fZ c1, fZ c2 => Zbool.Zeq_bool c1 c2

| fPos c1, fPos c2 =>  BinPos.Pos.eqb c1 c2

| fCtype c1, fCtype c2 => expr.eqb_type c1 c2

| fCexpr c1, fCexpr c2 => expr_beq c1 c2

| fenv c1, fenv c2 => ptree_cmp c1 c2 expr.eqb_type

| fllrr c1, fllrr c2 => match c1, c2 with | efield_lemmas.LLLL, efield_lemmas.LLLL | efield_lemmas.RRRR, efield_lemmas.RRRR => true | _, _ => false end

| _, _ => false

end.



Instance const_rel_dec : RelDec (@eq const) := { rel_dec := const_beq }.



Definition beq_z_true : forall a b, Zbool.Zeq_bool a b = true -> a = b.

Proof.

intros. apply Zbool.Zeq_bool_eq in H. subst.

auto.

Qed.



Hint Resolve beq_nat_true : expr_beq.

Hint Resolve beq_z_true : expr_beq.



Lemma const_beq_sound : forall a b, const_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

+ eapply ptree_cmp_sound; [| exact H].

  intros; solve_expr_beq_sound.

+ destruct l, l0; try inversion H; reflexivity.

Qed.



Hint Resolve const_beq_sound : expr_beq.



Definition z_op_beq a b : bool :=

match a, b with

| fZ_lt, fZ_lt

| fZ_le, fZ_le

| fZ_gt, fZ_gt

| fZ_ge, fZ_ge

| fZ_add, fZ_add

| fZ_sub, fZ_sub

| fZ_mul, fZ_mul

| fZ_div, fZ_div

| fZ_mod, fZ_mod

| fZ_land, fZ_land

| fZ_max, fZ_max

| fZ_opp, fZ_opp  => true

| _, _ => false

end.



Hint Resolve beq_nat_true : expr_beq.



Lemma z_op_beq_sound : forall a b, z_op_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve z_op_beq_sound : expr_beq.



Definition int_op_beq a b : bool :=

match a, b with

| fint_add, fint_add

| fint_and, fint_and

| fint_lt, fint_lt

| fint_ltu, fint_ltu

| fint_mul, fint_mul

| fint_neg, fint_neg

| fint_sub, fint_sub

| fint_cmp, fint_cmp

| fint_cmpu, fint_cmpu

| fint_repr, fint_repr

| fint_signed, fint_signed

| fint_unsigned, fint_unsigned

| fint_max_unsigned, fint_max_unsigned

| fint64_repr, fint64_repr => true

| _, _ => false

end.



Lemma int_op_beq_sound : forall a b, int_op_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve int_op_beq_sound : expr_beq.



Definition values_beq a b:=

match a, b with

| fVint, fVint

| fVfloat, fVfloat

| fVlong, fVlong

| fVptr, fVptr

| fVundef, fVundef => true

| _, _ => false

end.



Lemma values_beq_sound : forall a b, values_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve values_beq_sound : expr_beq.



Definition eval_beq a b :=

match a,b with

| feval_cast t1_1 t2_1 , feval_cast t1_2 t2_2 => andb (expr.eqb_type t1_1 t1_2)

                                                      (expr.eqb_type t2_1 t2_2)

| fderef_noload t1, fderef_noload t2 => expr.eqb_type t1 t2

| feval_field t1 id1 , feval_field t2 id2 =>  andb (expr.eqb_type t1 t2)

                                                   (BinPos.Pos.eqb id1 id2)

| feval_binop op1 t1_1 t2_1, feval_binop op2 t1_2 t2_2 =>

              andb (andb (binary_op_beq op1 op2)

                   (expr.eqb_type t1_1 t1_2))

                   (expr.eqb_type t2_1 t2_2)

| feval_unop op1 t1 , feval_unop op2 t2 =>

              andb (unary_op_beq op1 op2)

                   (expr.eqb_type t1 t2)

| feval_id id1, feval_id id2 => BinPos.Pos.eqb id1 id2

| _, _ => false

end.



Lemma eval_beq_sound : forall a b, eval_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve eval_beq_sound : expr_beq.



Definition other_beq a b :=

match a, b with

| ftwo_power_nat, ftwo_power_nat

| fforce_ptr, fforce_ptr

| fand, fand

| falign, falign

| ftyped_true, ftyped_true => true

| fnone t1, fnone t2

| fsome t1, fsome t2

| feq t1, feq t2 => typ_beq t1 t2

| _, _ => false

end

.



Hint Resolve typ_beq_sound : expr_beq.



Lemma other_beq_sound : forall a b, other_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve other_beq_sound : expr_beq.



Definition data_beq a b :=

match a, b with

| fnil t1, fnil t2

| fcons t1, fcons t2

| fappend t1, fappend t2 => typ_beq t1 t2

| fnth_error t1 n1, fnth_error t2 n2

| freplace_nth t1 n1, freplace_nth t2 n2 => andb (beq_nat n1 n2) (typ_beq t1 t2)

| fmap ta1 tb1, fmap ta2 tb2

| ffold_right ta1 tb1, ffold_right ta2 tb2

| ffold_left ta1 tb1, ffold_left ta2 tb2 => andb (typ_beq ta1 ta2) (typ_beq tb1 tb2)

| fleaf t, fleaf t'

| fnode t, fnode t'

| fempty t, fempty t' => typ_beq t t'

| _ , _ => false

end.



Lemma data_beq_sound : forall a b, data_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve data_beq_sound : expr_beq.



Definition sep_beq a b :=

match a, b with

| flocal, flocal

| fprop, fprop => true

| fdata_at ty1, fdata_at ty2 => expr.eqb_type ty1 ty2

| fproj_val ty1, fproj_val ty2 => expr.eqb_type ty1 ty2

| fupd_val ty1, fupd_val ty2 => expr.eqb_type ty1 ty2



| _, _ => false

end

.



Lemma sep_beq_sound : forall a b, sep_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed. 


Hint Resolve sep_beq_sound : expr_beq.



Definition type_bool_eq (a b : Ctypes.type * bool) :=

match a, b with

| (t1, b1), (t2, b2) => andb (expr.eqb_type t1 t2)

                             match b1, b2 with

                               | true, true | false, false => true

                               | _, _ => false

                             end

end.



Definition type_bool_eq_sound : forall a b,

type_bool_eq a b = true-> a = b.

intros. destruct a, b.

solve_expr_beq_sound.

destruct b, b0; simpl in H0; congruence.

Qed.



Definition smx_beq a b :=

match a, b with

| fsemax, fsemax

| fnormal_ret_assert, fnormal_ret_assert

| fassertD, fassertD => true

| flocalD , flocalD => true

| fstatement s1, fstatement s2 => statement_beq s1 s2

| ftycontext t1 l1 r1 gt1, ftycontext t2 l2 r2 gt2  =>

  andb (ptree_cmp t1 t2 type_bool_eq)

       (andb (ptree_cmp l1 l2 expr.eqb_type)

             (andb (expr.eqb_type r1 r2)

                   (ptree_cmp gt1 gt2 expr.eqb_type)))

| flater, flater => true

| flater_lift, flater_lift => true

| fnested_field_type2, fnested_field_type2 => true

| fis_neutral_cast, fis_neutral_cast => true

| fmsubst_efield_denote efs1, fmsubst_efield_denote efs2 => list_eqb RelDec_efield_beq efs1 efs2

| flegal_nested_efield tts1, flegal_nested_efield tts2 => list_eqb RelDec_ctype_beq tts1 tts2

| fmsubst_eval_LR, fmsubst_eval_LR => true

| ftc_LR_b_norho, ftc_LR_b_norho => true

| ftc_environ, ftc_environ => true

| ftc_efield_b_norho efs1, ftc_efield_b_norho efs2 => list_eqb RelDec_efield_beq efs1 efs2

| fnested_efield, fnested_efield => true

| ftypeof_temp, ftypeof_temp => true

| ftc_val, ftc_val => true

| flegal_nested_field, flegal_nested_field => true

| fstruct_field, fstruct_field => true

| funion_field, funion_field => true

| farray_subsc, farray_subsc => true

| fwritable_share, fwritable_share => true

| fTsh, fTsh => true

| fEws, fEws => true

| ftype_is_by_value, ftype_is_by_value => true

| _, _ => false

end.



Hint Resolve statement_beq_sound : expr_beq.



Lemma smx_beq_sound : forall a b, smx_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

apply ptree_cmp_sound in H; auto.

intros. apply type_bool_eq_sound in H3. auto.

apply ptree_cmp_sound in H0;

solve_expr_beq_sound.

apply ptree_cmp_sound in H2;

solve_expr_beq_sound.

Qed.



Hint Resolve smx_beq_sound : expr_beq.



Definition func_beq a b :=

match a, b with

| Const f1, Const f2 => const_beq f1 f2

| Zop f1, Zop f2 => z_op_beq f1 f2

| Intop f1, Intop f2 => int_op_beq f1 f2

| Value f1, Value f2 => values_beq f1 f2

| Eval_f f1, Eval_f f2 => eval_beq f1 f2

| Other f1, Other f2 => other_beq f1 f2

| Sep f1, Sep f2 => sep_beq f1 f2

| Data f1, Data f2 => data_beq f1 f2

| Smx f1, Smx f2 => smx_beq f1 f2

| _, _ => false

end.



Lemma func_beq_sound : forall a b, func_beq a b = true -> a = b.

Proof.

intros.

destruct a, b; auto; solve_expr_beq_sound.

Qed.



Hint Resolve data_beq_sound : expr_beq.

