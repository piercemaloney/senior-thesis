Require Import VST.veric.Clight_base.
(* VST.veric.Clight_base:
Require Export compcert.exportclight.Clightdefs.

Require Export VST.veric.base.
Require Export compcert.cfrontend.Ctypes.
Require Export compcert.cfrontend.Cop. 
Require Export compcert.cfrontend.Clight. 

Require Export EqNat.  

Require Export VST.veric.Memory. *)

Require Export compcert.lib.Axioms.

Require Import compcert.lib.Coqlib.
(* compcert.lib.Coqlib:
Require Export String.
Require Export ZArith.
Require Export Znumtheory.
Require Export List.
Require Export Bool.

Global Set Asymmetric Patterns.

Ltac inv H := inversion H; clear H; subst.

Ltac predSpec pred predspec x y :=
  generalize (predspec x y); case (pred x y); intro.

Ltac caseEq name :=
  generalize (eq_refl name); pattern name at -1 in |- *; case name.

Ltac destructEq name :=
  destruct name eqn:?.

Ltac decEq :=
  match goal with
  | [ |- _ = _ ] => f_equal
  | [ |- (?X ?A <> ?X ?B) ] =>
      cut (A <> B); [intro; congruence | try discriminate]
  end.

Ltac byContradiction :=
  cut False; [contradiction|idtac].

Ltac omegaContradiction :=
  cut False; [contradiction|omega].

Lemma modusponens: forall (P Q: Prop), P -> (P -> Q) -> Q.

Ltac exploit x :=
    refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _) _)
 || refine (modusponens _ _ (x _ _) _)
 || refine (modusponens _ _ (x _) _).

Definition peq: forall (x y: positive), {x = y} + {x <> y} := Pos.eq_dec.
Global Opaque peq.

Lemma peq_true:
  forall (A: Type) (x: positive) (a b: A), (if peq x x then a else b) = a.

Lemma peq_false:
  forall (A: Type) (x y: positive) (a b: A), x <> y -> (if peq x y then a else b) = b.

Definition Plt: positive -> positive -> Prop := Pos.lt.

Lemma Plt_ne:
  forall (x y: positive), Plt x y -> x <> y.
Hint Resolve Plt_ne: coqlib.

Lemma Plt_trans:
  forall (x y z: positive), Plt x y -> Plt y z -> Plt x z.
Proof (Pos.lt_trans).

Lemma Plt_succ:
  forall (x: positive), Plt x (Pos.succ x).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_trans_succ:
  forall (x y: positive), Plt x y -> Plt x (Pos.succ y).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_succ_inv:
  forall (x y: positive), Plt x (Pos.succ y) -> Plt x y \/ x = y.

Definition plt (x y: positive) : {Plt x y} + {~ Plt x y}.
Global Opaque plt.

Definition Ple: positive -> positive -> Prop := Pos.le.

Lemma Ple_refl: forall (p: positive), Ple p p.
Proof (Pos.le_refl).

Lemma Ple_trans: forall (p q r: positive), Ple p q -> Ple q r -> Ple p r.
Proof (Pos.le_trans).

Lemma Plt_Ple: forall (p q: positive), Plt p q -> Ple p q.
Proof (Pos.lt_le_incl).

Lemma Ple_succ: forall (p: positive), Ple p (Pos.succ p).

Lemma Plt_Ple_trans:
  forall (p q r: positive), Plt p q -> Ple q r -> Plt p r.
Proof (Pos.lt_le_trans).

Lemma Plt_strict: forall p, ~ Plt p p.
Proof (Pos.lt_irrefl).

Hint Resolve Ple_refl Plt_Ple Ple_succ Plt_strict: coqlib.

Ltac xomega := unfold Plt, Ple in *; zify; omega.
Ltac xomegaContradiction := exfalso; xomega.

Section POSITIVE_ITERATION.

Lemma Plt_wf: well_founded Plt.

Variable A: Type.
Variable v1: A.
Variable f: positive -> A -> A.

Lemma Ppred_Plt:
  forall x, x <> xH -> Plt (Pos.pred x) x.

Let iter (x: positive) (P: forall y, Plt y x -> A) : A :=
  match peq x xH with
  | left EQ => v1
  | right NOTEQ => f (Pos.pred x) (P (Pos.pred x) (Ppred_Plt x NOTEQ))
  end.

Definition positive_rec : positive -> A :=
  Fix Plt_wf (fun _ => A) iter.

Lemma unroll_positive_rec:
  forall x,
  positive_rec x = iter x (fun y _ => positive_rec y).

Lemma positive_rec_base:
  positive_rec 1%positive = v1.

Lemma positive_rec_succ:
  forall x, positive_rec (Pos.succ x) = f x (positive_rec x).

Lemma positive_Peano_ind:
  forall (P: positive -> Prop),
  P xH ->
  (forall x, P x -> P (Pos.succ x)) ->

End POSITIVE_ITERATION.

Definition zeq: forall (x y: Z), {x = y} + {x <> y} := Z.eq_dec.

Lemma zeq_true:
  forall (A: Type) (x: Z) (a b: A), (if zeq x x then a else b) = a.

Lemma zeq_false:
  forall (A: Type) (x y: Z) (a b: A), x <> y -> (if zeq x y then a else b) = b.

Open Scope Z_scope.

Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_dec.

Lemma zlt_true:
  forall (A: Type) (x y: Z) (a b: A),
  x < y -> (if zlt x y then a else b) = a.

Lemma zlt_false:
  forall (A: Type) (x y: Z) (a b: A),
  x >= y -> (if zlt x y then a else b) = b.

Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.

Lemma zle_true:
  forall (A: Type) (x y: Z) (a b: A),
  x <= y -> (if zle x y then a else b) = a.

Lemma zle_false:
  forall (A: Type) (x y: Z) (a b: A),
  x > y -> (if zle x y then a else b) = b.

Lemma two_power_nat_O : two_power_nat O = 1.

Lemma two_power_nat_pos : forall n : nat, two_power_nat n > 0.

Lemma two_power_nat_two_p:
  forall x, two_power_nat x = two_p (Z.of_nat x).

Lemma two_p_monotone:
  forall x y, 0 <= x <= y -> two_p x <= two_p y.

Lemma two_p_monotone_strict:
  forall x y, 0 <= x < y -> two_p x < two_p y.

Lemma two_p_strict:
  forall x, x >= 0 -> x < two_p x.

Lemma two_p_strict_2:
  forall x, x >= 0 -> 2 * x - 1 < two_p x.

Lemma Zmin_spec:
  forall x y, Z.min x y = if zlt x y then x else y.

Lemma Zmax_spec:
  forall x y, Z.max x y = if zlt y x then x else y.

Lemma Zmax_bound_l:
  forall x y z, x <= y -> x <= Z.max y z.
Lemma Zmax_bound_r:
  forall x y z, x <= z -> x <= Z.max y z.

Lemma Zdiv_small:
  forall x y, 0 <= x < y -> x / y = 0.

Lemma Zmod_small:
  forall x y, 0 <= x < y -> x mod y = x.

Lemma Zmod_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x mod y = b.

Lemma Zdiv_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x / y = a.

Lemma Zdiv_Zdiv:
  forall a b c,
  b > 0 -> c > 0 -> (a / b) / c = a / (b * c).

Lemma Zmult_le_compat_l_neg :
  forall n m p:Z, n >= m -> p <= 0 -> p * n <= p * m.

Lemma Zdiv_interval_1:
  forall lo hi a b,
  lo <= 0 -> hi > 0 -> b > 0 ->
  lo * b <= a < hi * b ->
  lo <= a/b < hi.

Lemma Zdiv_interval_2:
  forall lo hi a b,
  lo <= a <= hi -> lo <= 0 -> hi >= 0 -> b > 0 ->
  lo <= a/b <= hi.

Lemma Zmod_recombine:
  forall x a b,
  a > 0 -> b > 0 ->
  x mod (a * b) = ((x/b) mod a) * b + (x mod b).

Lemma Zdivides_trans:
  forall x y z, (x | y) -> (y | z) -> (x | z).

Definition Zdivide_dec:
  forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
Global Opaque Zdivide_dec.

Lemma Zdivide_interval:
  forall a b c,
  0 < c -> 0 <= a < b -> (c | a) -> (c | b) -> 0 <= a <= b - c.

Definition nat_of_Z: Z -> nat := Z.to_nat.

Lemma nat_of_Z_of_nat:
  forall n, nat_of_Z (Z.of_nat n) = n.

Lemma nat_of_Z_max:
  forall z, Z.of_nat (nat_of_Z z) = Z.max z 0.

Lemma nat_of_Z_eq:
  forall z, z >= 0 -> Z.of_nat (nat_of_Z z) = z.

Lemma nat_of_Z_neg:
  forall n, n <= 0 -> nat_of_Z n = O.

Lemma nat_of_Z_plus:
  forall p q,
  p >= 0 -> q >= 0 ->
  nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.

Definition align (n: Z) (amount: Z) :=
  ((n + amount - 1) / amount) * amount.

Lemma align_le: forall x y, y > 0 -> x <= align x y.

Lemma align_divides: forall x y, y > 0 -> (y | align x y).

Set Implicit Arguments.

Definition option_eq (A: Type) (eqA: forall (x y: A), {x=y} + {x<>y}):
  forall (x y: option A), {x=y} + {x<>y}.
Global Opaque option_eq.

Inductive option_rel (A B: Type) (R: A -> B -> Prop) : option A -> option B -> Prop :=
  | option_rel_none: option_rel R None None
  | option_rel_some: forall x y, R x y -> option_rel R (Some x) (Some y).

Definition option_map (A B: Type) (f: A -> B) (x: option A) : option B :=
  match x with
  | None => None
  | Some y => Some (f y)
  end.

Definition sum_left_map (A B C: Type) (f: A -> B) (x: A + C) : B + C :=
  match x with
  | inl y => inl C (f y)
  | inr z => inr B z
  end.

Hint Resolve in_eq in_cons: coqlib.

Lemma nth_error_in:
  forall (A: Type) (n: nat) (l: list A) (x: A),
  List.nth_error l n = Some x -> In x l.
Hint Resolve nth_error_in: coqlib.

Lemma nth_error_nil:
  forall (A: Type) (idx: nat), nth_error (@nil A) idx = None.
Hint Resolve nth_error_nil: coqlib.

Fixpoint list_length_z_aux (A: Type) (l: list A) (acc: Z) {struct l}: Z :=
  match l with
  | nil => acc
  | hd :: tl => list_length_z_aux tl (Z.succ acc)
  end.

Remark list_length_z_aux_shift:
  forall (A: Type) (l: list A) n m,
  list_length_z_aux l n = list_length_z_aux l m + (n - m).

Definition list_length_z (A: Type) (l: list A) : Z :=
  list_length_z_aux l 0.

Lemma list_length_z_cons:
  forall (A: Type) (hd: A) (tl: list A),
  list_length_z (hd :: tl) = list_length_z tl + 1.

Lemma list_length_z_pos:
  forall (A: Type) (l: list A),
  list_length_z l >= 0.

Lemma list_length_z_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_length_z (map f l) = list_length_z l.

Fixpoint list_nth_z (A: Type) (l: list A) (n: Z) {struct l}: option A :=
  match l with
  | nil => None
  | hd :: tl => if zeq n 0 then Some hd else list_nth_z tl (Z.pred n)
  end.

Lemma list_nth_z_in:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> In x l.

Lemma list_nth_z_map:
  forall (A B: Type) (f: A -> B) (l: list A) n,
  list_nth_z (List.map f l) n = option_map f (list_nth_z l n).

Lemma list_nth_z_range:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> 0 <= n < list_length_z l.

Lemma incl_cons_inv:
  forall (A: Type) (a: A) (b c: list A),
  incl (a :: b) c -> incl b c.
Hint Resolve incl_cons_inv: coqlib.

Lemma incl_app_inv_l:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l1 m.

Lemma incl_app_inv_r:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l2 m.

Hint Resolve  incl_tl incl_refl incl_app_inv_l incl_app_inv_r: coqlib.

Lemma incl_same_head:
  forall (A: Type) (x: A) (l1 l2: list A),
  incl l1 l2 -> incl (x::l1) (x::l2).

Lemma list_map_exten:
  forall (A B: Type) (f f': A -> B) (l: list A),
  (forall x, In x l -> f x = f' x) ->
  List.map f' l = List.map f l.

Lemma list_map_compose:
  forall (A B C: Type) (f: A -> B) (g: B -> C) (l: list A),
  List.map g (List.map f l) = List.map (fun x => g(f x)) l.

Lemma list_map_identity:
  forall (A: Type) (l: list A),
  List.map (fun (x:A) => x) l = l.

Lemma list_map_nth:
  forall (A B: Type) (f: A -> B) (l: list A) (n: nat),
  nth_error (List.map f l) n = option_map f (nth_error l n).

Lemma list_length_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  List.length (List.map f l) = List.length l.

Lemma list_in_map_inv:
  forall (A B: Type) (f: A -> B) (l: list A) (y: B),
  In y (List.map f l) -> exists x:A, y = f x /\ In x l.

Lemma list_append_map:
  forall (A B: Type) (f: A -> B) (l1 l2: list A),
  List.map f (l1 ++ l2) = List.map f l1 ++ List.map f l2.

Lemma list_append_map_inv:
  forall (A B: Type) (f: A -> B) (m1 m2: list B) (l: list A),
  List.map f l = m1 ++ m2 ->

Section LIST_FOLD.

Variables A B: Type.
Variable f: A -> B -> B.

Fixpoint list_fold_left (accu: B) (l: list A) : B :=
  match l with nil => accu | x :: l' => list_fold_left (f x accu) l' end.

Definition list_fold_right (l: list A) (base: B) : B :=
  list_fold_left base (List.rev' l).

Remark list_fold_left_app:
  forall l1 l2 accu,
  list_fold_left accu (l1 ++ l2) = list_fold_left (list_fold_left accu l1) l2.

Lemma list_fold_right_eq:
  forall l base,
  list_fold_right l base =
  match l with nil => base | x :: l' => f x (list_fold_right l' base) end.

Lemma list_fold_right_spec:
  forall l base, list_fold_right l base = List.fold_right f base l.

End LIST_FOLD.

Lemma in_cns:
  forall (A: Type) (x y: A) (l: list A), In x (y :: l) <-> y = x \/ In x l.

Lemma in_app:
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Lemma list_in_insert:
  forall (A: Type) (x: A) (l1 l2: list A) (y: A),
  In x (l1 ++ l2) -> In x (l1 ++ y :: l2).

Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Lemma list_disjoint_cons_l:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l2 -> list_disjoint (a :: l1) l2.

Lemma list_disjoint_cons_r:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l1 -> list_disjoint l1 (a :: l2).

Lemma list_disjoint_cons_left:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.

Lemma list_disjoint_cons_right:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.

Lemma list_disjoint_notin:
  forall (A: Type) (l1 l2: list A) (a: A),
  list_disjoint l1 l2 -> In a l1 -> ~(In a l2).

Lemma list_disjoint_sym:
  forall (A: Type) (l1 l2: list A),
  list_disjoint l1 l2 -> list_disjoint l2 l1.

Lemma list_disjoint_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l1 l2: list A),
  {list_disjoint l1 l2} + {~list_disjoint l1 l2}.

Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
  forall x, In x l1 <-> In x l2.

Inductive list_norepet (A: Type) : list A -> Prop :=
  | list_norepet_nil:
      list_norepet nil
  | list_norepet_cons:
      forall hd tl,
      ~(In hd tl) -> list_norepet tl -> list_norepet (hd :: tl).

Lemma list_norepet_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l: list A),
  {list_norepet l} + {~list_norepet l}.

Lemma list_map_norepet:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_norepet l ->
  (forall x y, In x l -> In y l -> x <> y -> f x <> f y) ->
  list_norepet (List.map f l).

Remark list_norepet_append_commut:
  forall (A: Type) (a b: list A),
  list_norepet (a ++ b) -> list_norepet (b ++ a).

Lemma list_norepet_app:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) <->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Lemma list_norepet_append:
  forall (A: Type) (l1 l2: list A),
  list_norepet l1 -> list_norepet l2 -> list_disjoint l1 l2 ->
  list_norepet (l1 ++ l2).

Lemma list_norepet_append_right:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l2.

Lemma list_norepet_append_left:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l1.

Inductive is_tail (A: Type): list A -> list A -> Prop :=
  | is_tail_refl:
      forall c, is_tail c c
  | is_tail_cons:
      forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).

Lemma is_tail_in:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.

Lemma is_tail_cons_left:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.

Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.

Lemma is_tail_incl:
  forall (A: Type) (l1 l2: list A), is_tail l1 l2 -> incl l1 l2.

Lemma is_tail_trans:
  forall (A: Type) (l1 l2: list A),
  is_tail l1 l2 -> forall (l3: list A), is_tail l2 l3 -> is_tail l1 l3.

Section FORALL2.

Variable A: Type.
Variable B: Type.
Variable P: A -> B -> Prop.

Inductive list_forall2: list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 al bl ->
      list_forall2 (a1 :: al) (b1 :: bl).

Lemma list_forall2_app:
  forall a2 b2 a1 b1,
  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
  list_forall2 (a1 ++ a2) (b1 ++ b2).

Lemma list_forall2_length:
  forall l1 l2,
  list_forall2 l1 l2 -> length l1 = length l2.

Lemma list_forall2_in_left:
  forall x1 l1 l2,
  list_forall2 l1 l2 -> In x1 l1 -> exists x2, In x2 l2 /\ P x1 x2.

Lemma list_forall2_in_right:
  forall x2 l1 l2,
  list_forall2 l1 l2 -> In x2 l2 -> exists x1, In x1 l1 /\ P x1 x2.

End FORALL2.

Lemma list_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
  list_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, In v1 l1 -> In v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  list_forall2 P2 l1 l2.

Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
  match n with
  | O => x
  | S n' => match x with nil => nil | hd :: tl => list_drop n' tl end
  end.

Lemma list_drop_incl:
  forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.

Lemma list_drop_norepet:
  forall (A: Type) n (l: list A), list_norepet l -> list_norepet (list_drop n l).

Lemma list_map_drop:
  forall (A B: Type) (f: A -> B) n (l: list A),
  list_drop n (map f l) = map f (list_drop n l).

Fixpoint list_repeat {A: Type} (n: nat) (x: A) {struct n} :=
  match n with
  | O => nil
  | S m => x :: list_repeat m x
  end.

Lemma length_list_repeat:
  forall (A: Type) n (x: A), length (list_repeat n x) = n.

Lemma in_list_repeat:
  forall (A: Type) n (x: A) y, In y (list_repeat n x) -> y = x.

Definition proj_sumbool {P Q: Prop} (a: {P} + {Q}) : bool :=
  if a then true else false.

Coercion proj_sumbool: sumbool >-> bool.

Lemma proj_sumbool_true:
  forall (P Q: Prop) (a: {P}+{Q}), proj_sumbool a = true -> P.

Lemma proj_sumbool_is_true:
  forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.

Ltac InvBooleans :=
  match goal with
  | [ H: _ && _ = true |- _ ] =>
      destruct (andb_prop _ _ H); clear H; InvBooleans
  | [ H: _ || _ = false |- _ ] =>
      destruct (orb_false_elim _ _ H); clear H; InvBooleans
  | [ H: proj_sumbool ?x = true |- _ ] =>
      generalize (proj_sumbool_true _ H); clear H; intro; InvBooleans
  | _ => idtac
  end.

Section DECIDABLE_EQUALITY.

Variable A: Type.
Variable dec_eq: forall (x y: A), {x=y} + {x<>y}.
Variable B: Type.

Lemma dec_eq_true:
  forall (x: A) (ifso ifnot: B),
  (if dec_eq x x then ifso else ifnot) = ifso.

Lemma dec_eq_false:
  forall (x y: A) (ifso ifnot: B),
  x <> y -> (if dec_eq x y then ifso else ifnot) = ifnot.

Lemma dec_eq_sym:
  forall (x y: A) (ifso ifnot: B),
  (if dec_eq x y then ifso else ifnot) =
  (if dec_eq y x then ifso else ifnot).

End DECIDABLE_EQUALITY.

Section DECIDABLE_PREDICATE.

Variable P: Prop.
Variable dec: {P} + {~P}.
Variable A: Type.

Lemma pred_dec_true:
  forall (a b: A), P -> (if dec then a else b) = a.

Lemma pred_dec_false:
  forall (a b: A), ~P -> (if dec then a else b) = b.

End DECIDABLE_PREDICATE.

Require Import Relations.

Section LEX_ORDER.

Variable A: Type.
Variable B: Type.
Variable ordA: A -> A -> Prop.
Variable ordB: B -> B -> Prop.

Inductive lex_ord: A*B -> A*B -> Prop :=
  | lex_ord_left: forall a1 b1 a2 b2,
      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
  | lex_ord_right: forall a b1 b2,
      ordB b1 b2 -> lex_ord (a,b1) (a,b2).

Lemma wf_lex_ord:
  well_founded ordA -> well_founded ordB -> well_founded lex_ord.

Lemma transitive_lex_ord:
  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.

End LEX_ORDER.

Inductive nlist (A: Type) : Type :=
  | nbase: A -> nlist A
  | ncons: A -> nlist A -> nlist A.

Definition nfirst {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => a end.

Fixpoint nlast {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => nlast l' end.

Fixpoint nIn {A: Type} (x: A) (l: nlist A) : Prop :=
  match l with
  | nbase a => a = x
  | ncons a l => a = x \/ nIn x l
  end.

Inductive nlist_forall2 {A B: Type} (R: A -> B -> Prop) : nlist A -> nlist B -> Prop :=
  | nbase_forall2: forall a b, R a b -> nlist_forall2 R (nbase a) (nbase b)
  | ncons_forall2: forall a l b m, R a b -> nlist_forall2 R l m -> nlist_forall2 R (ncons a l) (ncons b m).

Lemma nlist_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: nlist A) (l2: nlist B),
  nlist_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, nIn v1 l1 -> nIn v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  nlist_forall2 P2 l1 l2. *)

Require Export compcert.lib.Integers.

Require Export compcert.lib.Floats.

Require Export compcert.lib.Maps.

Require Export compcert.common.AST.

Require Export compcert.common.Values.

Require Export compcert.cfrontend.Ctypes.

Require Export compcert.cfrontend.Clight.

Require Export VST.sepcomp.Address.

Require Export VST.msl.eq_dec.

Require Export VST.msl.shares.

Require Export VST.msl.predicates_rec.

Require Export VST.msl.contractive.

Require Export VST.msl.seplog.

Require Export VST.msl.ghost_seplog.

Require Export VST.msl.alg_seplog.

Require Export VST.msl.log_normalize.

Require Export VST.msl.wand_frame.

Require Export VST.msl.wandQ_frame.

Require Export VST.msl.ramification_lemmas.

Require Export VST.veric.tycontext.

Require Export VST.veric.change_compspecs.

Require Export VST.veric.mpred.

Require Export VST.veric.expr.

Require Export VST.veric.expr_rel.

Require Export VST.veric.Clight_lemmas.

Require Export VST.veric.composite_compute.

Require Export VST.veric.align_mem.

Require Export VST.veric.shares.



Require VST.veric.Clight_seplog.

Require VST.veric.Clight_assert_lemmas.

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Require Import VST.veric.juicy_extspec.
(* VST.veric.juicy_extspec:
Require Import VST.veric.juicy_base.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.shares.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.juicy_mem. 

Require Import VST.veric.ghost_PCM. 
Require Import VST.veric.own. 

Require Import VST.veric.age_to_resource_at.

Local Open Scope nat_scope.
Local Open Scope pred.

Record juicy_ext_spec (Z: Type) := {
  JE_spec:> external_specification juicy_mem external_function Z;
  JE_pre_hered: forall e t ge_s typs args z, hereditary age (ext_spec_pre JE_spec e t ge_s typs args z);
  JE_post_hered: forall e t ge_s tret rv z, hereditary age (ext_spec_post JE_spec e t ge_s tret rv z);
  JE_exit_hered: forall rv z, hereditary age (ext_spec_exit JE_spec rv z)
}.

Class OracleKind := {
  OK_ty : Type;
  OK_spec: juicy_ext_spec OK_ty
}.

Definition void_spec T : external_specification juicy_mem external_function T :=
    Build_external_specification
      juicy_mem external_function T
      (fun ef => False)
      (fun ef Hef ge tys vl m z => False)
      (fun ef Hef ge ty vl m z => False)
      (fun rv m z => False).

Definition ok_void_spec (T : Type) : OracleKind.

Definition j_initial_core {C} (csem: @CoreSemantics C mem)
     (n: nat) (m: juicy_mem) (q: C) (m': juicy_mem) (v: val) (args: list val) 
     : Prop :=
  m' = m /\
  semantics.initial_core csem n (m_dry m) q (m_dry m') v args.

Definition j_at_external {C} (csem: @CoreSemantics C mem)
   (q: C) (jm: juicy_mem) : option (external_function * list val) :=
   semantics.at_external csem q (m_dry jm).

Definition j_after_external {C} (csem: @CoreSemantics C mem)
    (ret: option val) (q: C) (jm: juicy_mem) :=
   semantics.after_external csem ret q (m_dry jm).

Definition jstep {C} (csem: @CoreSemantics C mem)
  (q: C) (jm: juicy_mem) (q': C) (jm': juicy_mem) : Prop :=
 corestep csem q (m_dry jm) q' (m_dry jm') /\ 
 resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm') /\
 level jm = S (level jm') /\
 ghost_of (m_phi jm') = ghost_approx jm' (ghost_of (m_phi jm)).

Definition j_halted {C} (csem: @CoreSemantics C mem)
       (c: C) (i: int): Prop :=
     halted csem c i.

Lemma jstep_not_at_external {C} (csem: @CoreSemantics C mem):
  forall m q m' q', jstep csem q m q' m' -> at_external csem q (m_dry m) = None.

Lemma jstep_not_halted  {C} (csem: @CoreSemantics C mem):
  forall m q m' q' i, jstep csem q m q' m' -> ~j_halted csem q i.

Definition juicy_core_sem
  {C} (csem: @CoreSemantics C mem) :
   @CoreSemantics C juicy_mem :=
  @Build_CoreSemantics _ juicy_mem
    (j_initial_core csem)
    (j_at_external csem)
    (j_after_external csem)
    (j_halted csem)
    (jstep csem)
    (jstep_not_halted csem)
    (jstep_not_at_external csem)
.

Section upd_exit.
  Context {Z : Type}.
  Variable spec : juicy_ext_spec Z.

  Definition upd_exit' (Q_exit : option val -> Z -> juicy_mem -> Prop) :=
  {| ext_spec_type := ext_spec_type spec
   ; ext_spec_pre := ext_spec_pre spec
   ; ext_spec_post := ext_spec_post spec
   ; ext_spec_exit := Q_exit |}.

  Definition upd_exit'' (ef : external_function) (x : ext_spec_type spec ef) ge :=
    upd_exit' (ext_spec_post spec ef x ge (sig_res (ef_sig ef))).

  Program Definition upd_exit {ef : external_function} (x : ext_spec_type spec ef) ge :=
    Build_juicy_ext_spec _ (upd_exit'' _ x ge) _ _ _.
End upd_exit.

Obligation Tactic := Tactics.program_simpl.

Program Definition juicy_mem_op (P : pred rmap) : pred juicy_mem :=
  fun jm => P (m_phi jm).

Lemma age_resource_decay:
   forall b jm1 jm2 jm1' jm2',
        resource_decay b jm1 jm2 ->
        age jm1 jm1' -> age jm2 jm2' ->
        level jm1 = S (level jm2) ->
        resource_decay b jm1' jm2'.

Lemma necR_PURE' phi0 phi k p adr :
  necR phi0 phi ->
  phi @ adr = PURE k p ->
  
  exists pp, phi0 @ adr = PURE k pp.

Definition jm_update m m' := m_dry m' = m_dry m /\ level m' = level m /\
  resource_at (m_phi m') = resource_at (m_phi m).

Lemma jm_update_age: forall m1 m2 m1', jm_update m1 m2 -> age m1 m1' ->
  exists m2', jm_update m1' m2' /\ age m2 m2'.

Definition has_ext {Z} (ora : Z) : pred rmap := @own (ext_PCM _) 0 (Some (Tsh, Some ora), None) NoneP.

Definition jm_bupd {Z} (ora : Z) P m := forall C : ghost,
  
  join_sub (Some (ext_ref ora, NoneP) :: nil) C ->
  joins (ghost_of (m_phi m)) (ghost_approx m C) ->
  exists m' : juicy_mem, joins (ghost_of (m_phi m')) ((ghost_approx m) C) /\
    jm_update m m' /\ P m'.

Lemma jm_bupd_intro: forall {Z} (ora : Z) (P : juicy_mem -> Prop) m, P m -> jm_bupd ora P m.

Section juicy_safety.
  Context {G C Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C mem).
  Variable (Hspec : juicy_ext_spec Z).
  Variable ge : G.

  Definition Hrel n' m m' :=
    n' = level m' /\
    (level m' < level m)%nat /\
    pures_eq (m_phi m) (m_phi m').

  Inductive jsafeN_:
    nat -> Z -> C -> juicy_mem -> Prop :=
  | jsafeN_0: forall z c m, jsafeN_ O z c m
  | jsafeN_step:
      forall n z c m c' m',
      jstep Hcore c m c' m' ->
      jm_bupd z (jsafeN_ n z c') m' ->
      jsafeN_ (S n) z c m
  | jsafeN_external:
      forall n z c m e args x,
      j_at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           semantics.after_external Hcore ret c (m_dry m') = Some c' /\
           jm_bupd z' (jsafeN_ n' z' c') m') ->
      jsafeN_ (S n) z c m
  | jsafeN_halted:
      forall n z c m i,
      semantics.halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      jsafeN_ n z c m.

  Lemma jsafe_corestep_backward:
    forall c m c' m' n z,
    jstep Hcore c m c' m' ->
    jsafeN_ n z c' m' -> jsafeN_ (S n) z c m.

  Lemma jsafe_downward1 :
    forall n c m z,
      jsafeN_ (S n) z c m -> jsafeN_ n z c m.

  Lemma jsafe_downward :
    forall n n' c m z,
      le n' n ->
      jsafeN_ n z c m -> jsafeN_ n' z c m.

  Lemma jsafe_step'_back2 :
    forall
      {ora st m st' m' n},
      jstep Hcore st m st' m' ->
      jsafeN_ (n-1) ora st' m' ->
      jsafeN_ n ora st m.

  Lemma jsafe_corestepN_backward:
    forall z c m c' m' n n0,
      semantics_lemmas.corestepN (juicy_core_sem Hcore) n0 c m c' m' ->

  Lemma convergent_controls_jsafe :
    forall m q1 q2,
      (j_at_external Hcore q1 m = j_at_external Hcore q2 m) ->
      (forall ret m q', semantics.after_external Hcore ret q1 m = Some q' ->

  Lemma wlog_jsafeN_gt0 : forall
    n z q m,
    (lt 0 n -> jsafeN_ n z q m) ->
    jsafeN_ n z q m.

Lemma make_join_ext : forall (ora : Z) a c n,
  join_sub (Some (ext_ref ora, NoneP) :: nil) c ->
  joins (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) c) ->
  join_sub (Some (ext_ref ora, NoneP) :: nil) (make_join a c).

Lemma age_safe:
  forall jm jm0, age jm0 jm ->
  forall ora c,
   jsafeN_ (level jm0) ora c jm0 ->
   jsafeN_ (level jm) ora c jm.

End juicy_safety.

Lemma juicy_core_sem_preserves_corestep_fun
  {C} (csem: @CoreSemantics C mem) :
  corestep_fun csem ->
  corestep_fun (juicy_core_sem csem). *)

Require Import VST.veric.valid_pointer.
(* VST.veric.valid_pointer:
Require Import VST.veric.base.
Require Import VST.msl.normalize.
Require Import VST.veric.compcert_rmaps.
Require Import VST.msl.msl_standard.
Require Import VST.veric.res_predicates.
Require Import VST.veric.Clight_seplog. 
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.

Definition size_compatible {C: compspecs} t p :=
  match p with
  | Vptr b i_ofs => Ptrofs.unsigned i_ofs + sizeof t < Ptrofs.modulus
  | _ => True
  end.

Lemma nonlock_permission_bytes_valid_pointer: forall sh b ofs n i,
  0 <= ofs /\ ofs + n <= Ptrofs.modulus ->

Lemma VALspec_range_valid_pointer: forall sh b ofs n i,
  0 <= ofs /\ ofs + n <= Ptrofs.modulus ->

Lemma address_mapsto_valid_pointer: forall ch v sh b ofs i,
  0 <= ofs /\ ofs + size_chunk ch <= Ptrofs.modulus ->

Lemma mapsto_valid_pointer: forall {cs: compspecs} sh t p v i,
  size_compatible t p ->
  0 <= i < sizeof t ->
  nonidentity sh ->
  mapsto sh t p v |-- valid_pointer (offset_val i p).

Lemma memory_block_valid_pointer: forall {cs: compspecs} sh n p i,
  0 <= i < n ->
  nonidentity sh ->
  memory_block sh n p |-- valid_pointer (offset_val i p).

Lemma VALspec_range_weak_valid_pointer: forall sh b ofs n i,
  0 <= ofs /\ ofs + n < Ptrofs.modulus -> 0 <= i <= n -> 0 < n ->

Lemma nonlock_permission_bytes_weak_valid_pointer: forall sh b ofs n i,
  0 <= ofs /\ ofs + n < Ptrofs.modulus -> 0 <= i <= n -> 0 < n -> nonidentity sh ->

Lemma memory_block_weak_valid_pointer: forall {cs: compspecs} sh n p i,
  0 <= i <= n -> 0 < n -> nonidentity sh ->
  memory_block sh n p |-- weak_valid_pointer (offset_val i p). *)

Require Import VST.veric.own.
(* VST.veric.own:
Require Import VST.msl.log_normalize.
Require Import VST.msl.ghost.
Require Import VST.msl.ghost_seplog.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.res_predicates.

Import RML. Import R.
Local Open Scope pred.

Notation ghost_approx m := (ghost_fmap (approx (level m)) (approx (level m))).

Program Definition ghost_is g: pred rmap :=
  fun m => ghost_of m = ghost_approx m g.

Definition Own g: pred rmap := allp noat && ghost_is g.

Lemma Own_op: forall a b c, join a b c -> Own c = Own a * Own b.

Fixpoint make_join (a c : ghost) : ghost :=
  match a, c with
  | nil, _ => c
  | _, nil => nil
  | None :: a', x :: c' => x :: make_join a' c'
  | _ :: a', None :: c' => None :: make_join a' c'
  | Some (ga, pa) :: a', Some (gc, _) :: c' => Some (gc, pa) :: make_join a' c'
  end.

Lemma make_join_nil : forall a, make_join a nil = nil.

Lemma make_join_nil_cons : forall o a c, make_join (o :: a) (None :: c) = None :: make_join a c.

Lemma ghost_joins_approx: forall n a c,
  joins (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) c) ->
  let c' := make_join a c in
  joins (ghost_fmap (approx (S n)) (approx (S n)) a) (ghost_fmap (approx (S n)) (approx (S n)) c') /\
    forall b, joins b (ghost_fmap (approx (S n)) (approx (S n)) c') ->
      joins (ghost_fmap (approx n) (approx n) b) (ghost_fmap (approx n) (approx n) c).

Program Definition bupd (P: pred rmap): pred rmap :=
  fun m => forall c, joins (ghost_of m) (ghost_approx m c) ->
    exists b, joins b (ghost_approx m c) /\
    exists m', level m' = level m /\ resource_at m' = resource_at m /\ ghost_of m' = b /\ P m'.

Lemma bupd_intro: forall P, P |-- bupd P.

Lemma bupd_mono: forall P Q, P |-- Q -> bupd P |-- bupd Q.

Lemma bupd_frame_r: forall P Q, bupd P * Q |-- bupd (P * Q).

Lemma bupd_frame_l: forall P Q, P * bupd Q |-- bupd (P * Q).

Lemma bupd_trans: forall P, bupd (bupd P) |-- bupd P.

Lemma bupd_prop : forall P, bupd (!! P) = !! P.

Lemma subp_bupd: forall (G : pred nat) (P P' : pred rmap), G |-- P >=> P' ->
    G |-- (bupd P >=> bupd P')%pred.

Lemma eqp_bupd: forall (G : pred nat) (P P' : pred rmap), G |-- P <=> P' ->
    G |-- (bupd P <=> bupd P').

Definition ghost_fp_update_ND a B :=
  forall n c, joins (ghost_fmap (approx n) (approx n) a) c ->
    exists b, B b /\ joins (ghost_fmap (approx n) (approx n) b) c.

Lemma Own_update_ND: forall a B, ghost_fp_update_ND a B ->
  Own a |-- bupd (EX b : _, !!(B b) && Own b).

Definition ghost_fp_update (a b : ghost) :=
  forall n c, joins (ghost_fmap (approx n) (approx n) a) c ->
               joins (ghost_fmap (approx n) (approx n) b) c.

Lemma ghost_fp_update_approx: forall a b n, ghost_fp_update a b ->
  ghost_fp_update (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) b).

Lemma Own_update: forall a b, ghost_fp_update a b ->
  Own a |-- bupd (Own b).

Lemma Own_unit: emp |-- EX a : _, !!(identity a) && Own a.

Lemma Own_dealloc: forall a, Own a |-- bupd emp.

Definition singleton {A} k (x : A) : list (option A) := repeat None k ++ Some x :: nil.

Definition gname := nat.

Definition own {RA: Ghost} (n: gname) (a: G) (pp: preds) :=
  EX v : _, Own (singleton n (existT _ RA (exist _ a v), pp)).

Definition list_set {A} (m : list (option A)) k v : list (option A) :=
  firstn k m ++ repeat None (k - length m) ++ Some v :: skipn (S k) m.

Lemma singleton_join_gen: forall k a c (m: ghost)
  (Hjoin: join (Some a) (nth k m None) (Some c)),
  join (singleton k a) m (list_set m k c).

Lemma map_repeat : forall {A B} (f : A -> B) x n, map f (repeat x n) = repeat (f x) n.

Lemma ghost_fmap_singleton: forall f g k v, ghost_fmap f g (singleton k v) =
  singleton k (match v with (a, b) => (a, preds_fmap f g b) end).

Lemma ghost_fmap_singleton_inv : forall f g a k v,
  ghost_fmap f g a = singleton k v ->
  exists v', a = singleton k v' /\ v = let (a, b) := v' in (a, preds_fmap f g b).

Lemma ghost_alloc: forall {RA: Ghost} a pp, ghost.valid a ->

Lemma singleton_join: forall a b c k,
  join (singleton k a) (singleton k b) (singleton k c) <-> join a b c.

Lemma singleton_join_inv: forall k a b c,
  join (singleton k a) (singleton k b) c -> exists c', join a b c' /\ c = singleton k c'.

Lemma ghost_valid_2: forall {RA: Ghost} g a1 a2 pp,
  own g a1 pp * own g a2 pp |-- !!ghost.valid_2 a1 a2.

Lemma ghost_op: forall {RA: Ghost} g (a1 a2 a3: G) pp, join a1 a2 a3 ->
  own g a3 pp = own g a1 pp * own g a2 pp.

Lemma ghost_valid: forall {RA: Ghost} g a pp,
  own g a pp |-- !!ghost.valid a.

Lemma singleton_join_inv_gen: forall k a (b c: ghost),
  join (singleton k a) b c ->
  join (Some a) (nth k b None) (nth k c None) /\
    exists c', nth k c None = Some c' /\ c = list_set b k c'.

Lemma ghost_update_ND: forall {RA: Ghost} g (a: G) B pp,
  fp_update_ND a B -> own g a pp |-- bupd (EX b : _, !!(B b) && own g b pp).

Lemma ghost_update: forall {RA: Ghost} g (a b: G) pp,
  fp_update a b -> own g a pp |-- bupd (own g b pp).

Lemma ghost_dealloc: forall {RA: Ghost} g a pp,
  own g a pp |-- bupd emp.

Lemma list_set_same : forall {A} n l (a : A), nth n l None = Some a ->
  list_set l n a = l.

Definition cored: pred rmap := ALL P : pred rmap, ALL Q : pred rmap,
  P && Q --> P * Q.

Program Definition is_w w: pred rmap := fun w' => necR w w'.

Lemma cored_unit: forall w, cored w = join w w w.

Lemma cored_dup: forall P, P && cored |-- (P && cored) * (P && cored).

Lemma cored_core: forall w, cored (core w).

Lemma cored_duplicable: cored = cored * cored.

Lemma cored_emp: cored |-- bupd emp.

Lemma join_singleton_inv: forall k a b RA c v pp,
  join a b (singleton k (existT _ RA (exist _ (core c) v), pp)) ->
  a = singleton k (existT _ RA (exist _ (core c) v), pp) \/ b = singleton k (existT _ RA (exist _ (core c) v), pp).

Lemma own_cored: forall {RA: Ghost} g a pp, join a a a -> own g a pp |-- cored.

Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_seplog.
 
Lemma own_super_non_expansive: forall {RA: Ghost} n g a pp,
  approx n (own g a pp) = approx n (own g a (preds_fmap (approx n) (approx n) pp)). *)

Require VST.veric.semax_prog.

Require VST.veric.semax_ext.



Instance Nveric: NatDed mpred := algNatDed compcert_rmaps.RML.R.rmap.

Instance Sveric: SepLog mpred := algSepLog compcert_rmaps.RML.R.rmap.

Instance Cveric: ClassicalSep mpred := algClassicalSep compcert_rmaps.RML.R.rmap.

Instance Iveric: Indir mpred := algIndir compcert_rmaps.RML.R.rmap.

Instance Rveric: RecIndir mpred := algRecIndir compcert_rmaps.RML.R.rmap.

Instance SIveric: SepIndir mpred := algSepIndir compcert_rmaps.RML.R.rmap.

Instance CSLveric: CorableSepLog mpred := algCorableSepLog compcert_rmaps.RML.R.rmap.

Instance CIveric: CorableIndir mpred := algCorableIndir compcert_rmaps.RML.R.rmap.

Instance SRveric: SepRec mpred := algSepRec compcert_rmaps.RML.R.rmap.

Instance Bveric: BupdSepLog mpred gname compcert_rmaps.RML.R.preds :=

  mkBSL _ _ _ _ _ bupd (@own) bupd_intro bupd_mono bupd_trans bupd_frame_r

    (@ghost_alloc) (@ghost_op) (@ghost_valid_2) (@ghost_update_ND) (@ghost_dealloc).



Instance LiftNatDed' T {ND: NatDed T}: NatDed (LiftEnviron T) := LiftNatDed _ _.

Instance LiftSepLog' T {ND: NatDed T}{SL: SepLog T}: SepLog (LiftEnviron T) := LiftSepLog _ _.

Instance LiftClassicalSep' T {ND: NatDed T}{SL: SepLog T}{CS: ClassicalSep T} :

           ClassicalSep (LiftEnviron T) := LiftClassicalSep _ _.

Instance LiftIndir' T {ND: NatDed T}{SL: SepLog T}{IT: Indir T} :

           Indir (LiftEnviron T) := LiftIndir _ _.

Instance LiftSepIndir' T {ND: NatDed T}{SL: SepLog T}{IT: Indir T}{SI: SepIndir T} :

           SepIndir (LiftEnviron T) := LiftSepIndir _ _.

Instance LiftCorableSepLog' T {ND: NatDed T}{SL: SepLog T}{CSL: CorableSepLog T} :

           CorableSepLog (LiftEnviron T) := LiftCorableSepLog _ _.

Instance LiftCorableIndir' T {ND: NatDed T}{SL: SepLog T}{IT: Indir T}{SI: SepIndir T}{CSL: CorableSepLog T}{CI: CorableIndir T} :

           CorableIndir (LiftEnviron T) := LiftCorableIndir _ _.



Definition local:  (environ -> Prop) -> environ->mpred :=  lift1 prop.



Global Opaque mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric CSLveric CIveric SRveric Bveric.



Hint Resolve any_environ : typeclass_instances.



Local Open Scope logic.



Transparent mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric CSLveric CIveric SRveric Bveric.



Definition denote_tc_iszero v : mpred :=

         match v with

         | Vint i => prop (is_true (Int.eq i Int.zero))

         | Vlong i => prop (is_true (Int64.eq i Int64.zero))

         | _ => FF

         end.



Definition denote_tc_nonzero v : mpred :=

         match v with

         | Vint i => prop (i <> Int.zero)

         | Vlong i =>prop (i <> Int64.zero)

         | _ => FF end.



Definition denote_tc_igt i v : mpred :=

     match v with

     | Vint i1 => prop (Int.unsigned i1 < Int.unsigned i)

     | _ => FF

     end.



Definition denote_tc_lgt l v : mpred :=

     match v with

     | Vlong l1 => prop (Int64.unsigned l1 < Int64.unsigned l)

     | _ => FF

     end.



Definition Zoffloat (f:float): option Z := 

  match f with

    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>

       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)%Z

    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))

    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))

    | Fappli_IEEE.B754_zero _ => Some 0

    | _ => None

  end.  



Definition Zofsingle (f: float32): option Z := 

  match f with

    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>

       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)%Z

    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))

    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))

    | Fappli_IEEE.B754_zero _ => Some 0

    | _ => None

  end.  



Definition denote_tc_Zge z v : mpred :=

          match v with

                     | Vfloat f => match Zoffloat f with

                                    | Some n => prop (z >= n)

                                    | None => FF

                                   end

                     | Vsingle f => match Zofsingle f with

                                    | Some n => prop (z >= n)

                                    | None => FF

                                   end

                     | _ => FF

                  end.



Definition denote_tc_Zle z v : mpred :=

          match v with

                     | Vfloat f => match Zoffloat f with

                                    | Some n => prop (z <= n)

                                    | None => FF

                                   end

                     | Vsingle f => match Zofsingle f with

                                    | Some n => prop (z <= n)

                                    | None => FF

                                   end

                     | _ => FF

                  end.



Definition sameblock v1 v2 : bool :=

         match v1, v2 with

          | Vptr b1 _, Vptr b2 _ => peq b1 b2

          | _, _ => false

         end.



Definition denote_tc_samebase v1 v2 : mpred :=

       prop (is_true (sameblock v1 v2)).



Definition denote_tc_nodivover v1 v2 : mpred :=

match v1, v2 with

          | Vint n1, Vint n2 => prop (~(n1 = Int.repr Int.min_signed /\ n2 = Int.mone))

          | Vlong n1, Vlong n2 => prop (~(n1 = Int64.repr Int64.min_signed /\ n2 = Int64.mone))

          | Vint n1, Vlong n2 => TT

          | Vlong n1, Vint n2 => prop (~ (n1 = Int64.repr Int64.min_signed  /\ n2 = Int.mone))

          | _ , _ => FF

        end.



Definition denote_tc_nosignedover (op: Z->Z->Z) v1 v2 : mpred :=

 match v1,v2 with

 | Vint n1, Vint n2 => 

   prop (Int.min_signed <= op (Int.signed n1) (Int.signed n2) <= Int.max_signed)

 | Vlong n1, Vlong n2 =>

   prop (Int64.min_signed <= op (Int64.signed n1) (Int64.signed n2) <= Int64.max_signed)

 | Vint n1, Vlong n2 =>

   prop (Int64.min_signed <= op (Int.signed n1) (Int64.signed n2) <= Int64.max_signed)

 | Vlong n1, Vint n2 =>

   prop (Int64.min_signed <= op (Int64.signed n1) (Int.signed n2) <= Int64.max_signed)

 | _, _ => FF

 end.



Definition denote_tc_initialized id ty rho : mpred :=

    prop (exists v, Map.get (te_of rho) id = Some v

               /\ tc_val ty v).



Definition denote_tc_isptr v : mpred :=

  prop (isptr v).



Definition denote_tc_isint v : mpred :=

  prop (is_int I32 Signed v).



Definition denote_tc_islong v : mpred :=

  prop (is_long v).



Definition test_eq_ptrs v1 v2 : mpred :=

  if sameblock v1 v2

  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))

  else (andp (valid_pointer v1) (valid_pointer v2)).



Definition test_order_ptrs v1 v2 : mpred :=

  if sameblock v1 v2

  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))

  else FF.



Definition denote_tc_test_eq v1 v2 : mpred :=

 match v1, v2 with

 | Vint i, Vint j => 

     if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))

 | Vlong i, Vlong j => 

     if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF

 | Vint i, Vptr _ _ =>

      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v2)

 | Vlong i, Vptr _ _ =>

      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v2) else FF

 | Vptr _ _, Vint i =>

      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v1)

 | Vptr _ _, Vlong i =>

      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v1) else FF

 | Vptr _ _, Vptr _ _ =>

      test_eq_ptrs v1 v2

 | _, _ => FF

 end.



Definition denote_tc_test_order v1 v2 : mpred :=

 match v1, v2 with

 | Vint i, Vint j => if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))

 | Vlong i, Vlong j => if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF

 | Vptr _ _, Vptr _ _ =>

      test_order_ptrs v1 v2

 | _, _ => FF

 end.



Definition typecheck_error (e: tc_error) : Prop := False.

Global Opaque typecheck_error.



Definition fool := @map _ Type (fun it : ident * type => mpred).



Fixpoint denote_tc_assert {CS: compspecs} (a: tc_assert) : environ -> mpred :=

  match a with

  | tc_FF msg => `(prop (typecheck_error msg))

  | tc_TT => TT

  | tc_andp' b c => fun rho => andp (denote_tc_assert b rho) (denote_tc_assert c rho)

  | tc_orp' b c => `orp (denote_tc_assert b) (denote_tc_assert c)

  | tc_nonzero' e => `denote_tc_nonzero (eval_expr e)

  | tc_isptr e => `denote_tc_isptr (eval_expr e)

  | tc_isint e => `denote_tc_isint (eval_expr e)

  | tc_islong e => `denote_tc_islong (eval_expr e)

  | tc_test_eq' e1 e2 => `denote_tc_test_eq (eval_expr e1) (eval_expr e2)

  | tc_test_order' e1 e2 => `denote_tc_test_order (eval_expr e1) (eval_expr e2)

  | tc_ilt' e i => `(denote_tc_igt i) (eval_expr e)

  | tc_llt' e i => `(denote_tc_lgt i) (eval_expr e)

  | tc_Zle e z => `(denote_tc_Zge z) (eval_expr e)

  | tc_Zge e z => `(denote_tc_Zle z) (eval_expr e)

  | tc_samebase e1 e2 => `denote_tc_samebase (eval_expr e1) (eval_expr e2)

  | tc_nodivover' v1 v2 => `denote_tc_nodivover (eval_expr v1) (eval_expr v2)

  | tc_initialized id ty => denote_tc_initialized id ty

  | tc_iszero' e => `denote_tc_iszero (eval_expr e)

  | tc_nosignedover op e1 e2 => `(denote_tc_nosignedover op) (eval_expr e1) (eval_expr e2)

 end.



Definition fool' := @map _ Type (fun it : ident * type => mpred).



Opaque mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric CSLveric CIveric SRveric Bveric.



Definition cast_pointer_to_bool t1 t2 :=

 match t1 with (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) => 

           match t2 with Tint IBool _ _ => true | _ => false end

 | _ => false

end.



Fixpoint ext_link_prog' (dl: list (ident * globdef fundef type)) (s: String.string) : option ident :=

 match dl with

 | (id, Gfun (External EF_malloc _ _ _)) :: dl' =>

      if String.string_dec s "_malloc" then Some id else ext_link_prog' dl' s

 | (id, Gfun (External EF_free _ _ _)) :: dl' =>

      if String.string_dec s "_free" then Some id else ext_link_prog' dl' s

 | (id, Gfun (External (EF_external s' _) _ _ _)) :: dl' =>

      if String.string_dec s s' then Some id else ext_link_prog' dl' s

 | (id, Gfun (External (EF_builtin s' _) _ _ _)) :: dl' =>

      if String.string_dec s s' then Some id else ext_link_prog' dl' s

 | _ :: dl' =>

     ext_link_prog' dl' s

 | nil => None

 end.



Definition ext_link_prog (p: program) (s: String.string) : ident :=

  match ext_link_prog' (prog_defs p) s with Some id => id | None => 1%positive end.



Definition closed_wrt_vars {B} (S: ident -> Prop) (F: environ -> B) : Prop :=

  forall rho te',

     (forall i, S i \/ Map.get (te_of rho) i = Map.get te' i) ->

     F rho = F (mkEnviron (ge_of rho) (ve_of rho) te').



Definition closed_wrt_lvars {B} (S: ident -> Prop) (F: environ -> B) : Prop :=

  forall rho ve',

     (forall i, S i \/ Map.get (ve_of rho) i = Map.get ve' i) ->

     F rho = F (mkEnviron (ge_of rho) ve' (te_of rho)).



Definition not_a_param (params: list (ident * type)) (i : ident) : Prop :=

  ~ In i (map (@fst _ _) params).



Definition is_a_local (vars: list (ident * type)) (i: ident) : Prop :=

  In  i (map (@fst _ _) vars) .



Definition precondition_closed (f: function) {A: rmaps.TypeTree}

  (P: forall ts, functors.MixVariantFunctor._functor (rmaps.dependent_type_functor_rec ts (AssertTT A)) mpred) : Prop :=

 forall ts x,

  closed_wrt_vars (not_a_param (fn_params f)) (P ts x) /\

  closed_wrt_lvars (is_a_local (fn_vars f)) (P ts x).



Definition typed_true (t: type) (v: val)  : Prop :=  strict_bool_val v t

= Some true.



Definition typed_false (t: type)(v: val) : Prop :=  strict_bool_val v t =

Some false.



Definition subst {A} (x: ident) (v: environ -> val) (P: environ -> A) : environ -> A :=

   fun s => P (env_set s x (v s)).



Definition substopt {A} (ret: option ident) (v: environ -> val) (P: environ -> A)  : environ -> A :=

   match ret with

   | Some id => subst id v P

   | None => P

   end.



Definition cast_expropt {CS: compspecs} (e: option expr) t : environ -> option val :=

 match e with Some e' => `Some (eval_expr (Ecast e' t))  | None => `None end.



Definition typecheck_tid_ptr_compare

Delta id :=

match (temp_types Delta) ! id with

| Some t => is_int_type t

| None => false

end.



Definition mapsto (sh: Share.t) (t: type) (v1 v2 : val): mpred :=

  match access_mode t with

  | By_value ch =>

   match type_is_volatile t with

   | false =>

    match v1 with

     | Vptr b ofs =>

       if readable_share_dec sh

       then (!!tc_val t v2 &&

             res_predicates.address_mapsto ch v2 sh (b, Ptrofs.unsigned ofs)) ||

            (!! (v2 = Vundef) &&

             EX v2':val, res_predicates.address_mapsto ch v2' sh (b, Ptrofs.unsigned ofs))

       else !! (tc_val' t v2 /\ (Memdata.align_chunk ch | Ptrofs.unsigned ofs)) && res_predicates.nonlock_permission_bytes sh (b, Ptrofs.unsigned ofs) (Memdata.size_chunk ch)

     | _ => FF

    end

    | _ => FF

    end

  | _ => FF

  end.



Definition mapsto_ sh t v1 := mapsto sh t v1 Vundef.



Definition mapsto_zeros (n: Z) (sh: share) (a: val) : mpred :=

 match a with

  | Vptr b z => 

    !! (0 <= Ptrofs.unsigned z  /\ n + Ptrofs.unsigned z < Ptrofs.modulus)%Z &&

    mapsto_memory_block.address_mapsto_zeros sh (nat_of_Z n) (b, Ptrofs.unsigned z)

  | _ => FF

  end.



Definition init_data2pred (d: init_data)  (sh: share) (a: val) (rho: environ) : mpred :=

 match d with

  | Init_int8 i => mapsto sh (Tint I8 Unsigned noattr) a (Vint (Int.zero_ext 8 i))

  | Init_int16 i => mapsto sh (Tint I16 Unsigned noattr) a (Vint (Int.zero_ext 16 i))

  | Init_int32 i => mapsto sh (Tint I32 Unsigned noattr) a (Vint i)

  | Init_int64 i => mapsto sh (Tlong Unsigned noattr) a (Vlong i)

  | Init_float32 r =>  mapsto sh (Tfloat F32 noattr) a (Vsingle r)

  | Init_float64 r =>  mapsto sh (Tfloat F64 noattr) a (Vfloat r)

  | Init_space n => mapsto_zeros n sh a

  | Init_addrof symb ofs =>

       match Map.get (ge_of rho) symb with

       | Some b => mapsto sh (Tpointer Tvoid noattr) a (Vptr b ofs)

       | _ => mapsto_ sh (Tpointer Tvoid noattr) a

       end

 end.



Definition init_data_size (i: init_data) : Z :=

  match i with

  | Init_int8 _ => 1

  | Init_int16 _ => 2

  | Init_int32 _ => 4

  | Init_int64 _ => 8

  | Init_float32 _ => 4

  | Init_float64 _ => 8

  | Init_addrof _ _ => if Archi.ptr64 then 8 else 4

  | Init_space n => Z.max n 0

  end.



Fixpoint init_data_list_size (il: list init_data) {struct il} : Z :=

  match il with

  | nil => 0

  | i :: il' => init_data_size i + init_data_list_size il'

  end.



Fixpoint init_data_list2pred  (dl: list init_data)

                           (sh: share) (v: val)  : environ -> mpred :=

  match dl with

  | d::dl' => 

      sepcon (init_data2pred d sh v) 

                  (init_data_list2pred dl' sh (offset_val (init_data_size d) v))

  | nil => emp

 end.



Definition readonly2share (rdonly: bool) : share :=

  if rdonly then Ers else Ews.



Definition globals := ident -> val.



Definition globvar2pred (gv: globals) (idv: ident * globvar type) : environ->mpred :=

   if (gvar_volatile (snd idv))

                       then  lift0 TT

                       else    init_data_list2pred (gvar_init (snd idv))

                                   (readonly2share (gvar_readonly (snd idv))) (gv (fst idv)).



Definition globals_of_env (rho: environ) (i: ident) : val := 

  match Map.get (ge_of rho) i with Some b => Vptr b Ptrofs.zero | None => Vundef end.



Definition globvars2pred  (gv: globals)  (vl: list (ident * globvar type)) : environ->mpred :=

  (lift2 andp) (fun rho => prop (gv = globals_of_env rho))

  (fold_right sepcon emp (map (globvar2pred gv) vl)).



Definition initializer_aligned (z: Z) (d: init_data) : bool :=

  match d with

  | Init_int16 n => Zeq_bool (z mod 2) 0

  | Init_int32 n => Zeq_bool (z mod 4) 0

  | Init_int64 n => Zeq_bool (z mod 8) 0

  | Init_float32 n =>  Zeq_bool (z mod 4) 0

  | Init_float64 n =>  Zeq_bool (z mod 8) 0

  | Init_addrof symb ofs =>  Zeq_bool (z mod (size_chunk Mptr)) 0

  | _ => true

  end.



Fixpoint initializers_aligned (z: Z) (dl: list init_data) : bool :=

  match dl with

  | nil => true

  | d::dl' => andb (initializer_aligned z d) (initializers_aligned (z + init_data_size d) dl')

  end.



Definition funsig := (list (ident*type) * type)%type. 



Definition memory_block (sh: share) (n: Z) (v: val) : mpred :=

 match v with

 | Vptr b ofs => (!! (Ptrofs.unsigned ofs + n < Ptrofs.modulus)) && mapsto_memory_block.memory_block' sh (nat_of_Z n) b (Ptrofs.unsigned ofs)

 | _ => FF

 end.



Lemma memory_block_zero_Vptr: forall sh b z, memory_block sh 0 (Vptr b z) = emp.

Proof. exact mapsto_memory_block.memory_block_zero_Vptr. Qed.



Lemma mapsto_mapsto_: forall sh t v v', mapsto sh t v v' |-- mapsto_ sh t v.

Proof. exact mapsto_memory_block.mapsto_mapsto_. Qed.



Lemma mapsto_tc_val': forall sh t p v, mapsto sh t p v |-- !! tc_val' t v.

Proof. exact mapsto_memory_block.mapsto_tc_val'. Qed.



Lemma memory_block_split:

  forall (sh : share) (b : block) (ofs n m : Z),

  0 <= n ->

  0 <= m ->

  n + m <= n + m + ofs < Ptrofs.modulus ->

  memory_block sh (n + m) (Vptr b (Ptrofs.repr ofs)) =

  memory_block sh n (Vptr b (Ptrofs.repr ofs)) *

  memory_block sh m (Vptr b (Ptrofs.repr (ofs + n))).

Proof. exact mapsto_memory_block.memory_block_split. Qed.



Lemma mapsto_share_join:

 forall sh1 sh2 sh t p v,

   sepalg.join sh1 sh2 sh ->

   mapsto sh1 t p v * mapsto sh2 t p v = mapsto sh t p v.

Proof.

intros.

apply  mapsto_memory_block.mapsto_share_join; auto.

Qed.



Lemma memory_block_share_join:

  forall sh1 sh2 sh n p,

   sepalg.join sh1 sh2 sh ->

   memory_block sh1 n p * memory_block sh2 n p = memory_block sh n p.

Proof.

intros.

apply  mapsto_memory_block.memory_block_share_join; auto.

Qed.



Lemma mapsto_conflict:

  forall sh t v v2 v3,

  sepalg.nonunit sh ->

  mapsto sh t v v2 * mapsto sh t v v3 |-- FF.

Proof.

intros.

apply mapsto_memory_block.mapsto_conflict; auto.

Qed.



Lemma memory_block_conflict: forall sh n m p,

  sepalg.nonunit sh ->

  0 < n <= Ptrofs.max_unsigned -> 0 < m <= Ptrofs.max_unsigned ->

  memory_block sh n p * memory_block sh m p |-- FF.

Proof.

intros.

apply mapsto_memory_block.memory_block_conflict; auto.

Qed.



Definition align_compatible {C: compspecs} t p :=

  match p with

  | Vptr b i_ofs => align_compatible_rec cenv_cs t (Ptrofs.unsigned i_ofs)

  | _ => True

  end.



Definition size_compatible {C: compspecs} t p :=

  match p with

  | Vptr b i_ofs => Ptrofs.unsigned i_ofs + sizeof t < Ptrofs.modulus

  | _ => True

  end.



Lemma mapsto_valid_pointer: forall {cs: compspecs} sh t p v i,

  size_compatible t p ->

  0 <= i < sizeof t ->

  sepalg.nonidentity sh ->

  mapsto sh t p v |-- valid_pointer (offset_val i p).

Proof. exact @mapsto_valid_pointer. Qed.



Lemma memory_block_valid_pointer: forall {cs: compspecs} sh n p i,

  0 <= i < n ->

  sepalg.nonidentity sh ->

  memory_block sh n p |-- valid_pointer (offset_val i p).

Proof. exact @memory_block_valid_pointer. Qed.



Lemma memory_block_weak_valid_pointer: forall {cs: compspecs} sh n p i,

  0 <= i <= n -> 0 < n -> sepalg.nonidentity sh ->

  memory_block sh n p |-- weak_valid_pointer (offset_val i p).

Proof. exact @memory_block_weak_valid_pointer. Qed.



Lemma mapsto_zeros_memory_block: forall sh n p,

  readable_share sh ->

  mapsto_zeros n sh p |--

  memory_block sh n p.

Proof. exact mapsto_memory_block.mapsto_zeros_memory_block. Qed.



Lemma mapsto_pointer_void:

  forall sh t a, 

    eqb_type (Tpointer t a) int_or_ptr_type = false ->

    eqb_type (Tpointer Tvoid a) int_or_ptr_type = false ->

    mapsto sh (Tpointer t a) = mapsto sh (Tpointer Tvoid a).

Proof. exact mapsto_memory_block.mapsto_pointer_void. Qed.



Lemma mapsto_unsigned_signed:

 forall sign1 sign2 sh sz v i,

  mapsto sh (Tint sz sign1 noattr) v (Vint (Cop.cast_int_int sz sign1 i)) =

  mapsto sh (Tint sz sign2 noattr) v (Vint (Cop.cast_int_int sz sign2 i)).

Proof. exact Clight_mapsto_memory_block.mapsto_unsigned_signed. Qed.



Lemma mapsto_tuint_tint:

  forall sh, mapsto sh tuint = mapsto sh tint.

Proof. exact Clight_mapsto_memory_block.mapsto_tuint_tint. Qed.



Lemma mapsto_tuint_tptr_nullval:

  forall sh p t, 

  mapsto sh (Tpointer t noattr) p nullval = mapsto sh size_t p nullval.

Proof.  exact mapsto_memory_block.mapsto_tuint_tptr_nullval. Qed.



Lemma mapsto_size_t_tptr_nullval:

  forall sh p t, mapsto sh (Tpointer t noattr) p nullval = mapsto sh size_t p nullval.

Proof. exact mapsto_memory_block.mapsto_tuint_tptr_nullval. Qed.



Definition is_int32_noattr_type t :=

 match t with

 | Tint I32 _ {| attr_volatile := false; attr_alignas := None |} => True

 | _ => False

 end.



Lemma mapsto_mapsto_int32:

  forall sh t1 t2 p v,

   is_int32_noattr_type t1 ->

   is_int32_noattr_type t2 ->

   mapsto sh t1 p v |-- mapsto sh t2 p v.

Proof. exact mapsto_memory_block.mapsto_mapsto_int32. Qed.



Lemma mapsto_mapsto__int32:

  forall sh t1 t2 p v,

   is_int32_noattr_type t1 ->

   is_int32_noattr_type t2 ->

   mapsto sh t1 p v |-- mapsto_ sh t2 p.

Proof. exact mapsto_memory_block.mapsto_mapsto__int32. Qed.



Lemma mapsto_null_mapsto_pointer:

  forall t sh v,

       Archi.ptr64 = false ->

             mapsto sh tint v nullval =

             mapsto sh (tptr t) v nullval.

Proof. exact Clight_mapsto_memory_block.mapsto_null_mapsto_pointer. Qed.



Definition eval_lvar (id: ident) (ty: type) (rho: environ) :=

 match Map.get (ve_of rho) id with

| Some (b, ty') => if eqb_type ty ty' then Vptr b Ptrofs.zero else Vundef

| None => Vundef

end.



Definition var_block (sh: Share.t) {cs: compspecs} (idt: ident * type) : environ -> mpred :=

  !! (sizeof (snd idt) <= Ptrofs.max_unsigned) &&

  `(memory_block sh (sizeof (snd idt)))

             (eval_lvar (fst idt) (snd idt)).



Definition stackframe_of {cs: compspecs} (f: Clight.function) : environ->mpred :=

  fold_right sepcon emp (map (var_block Tsh) (fn_vars f)).



Lemma  subst_derives {A}{NA: NatDed A}:

 forall a v (P Q: environ -> A), P |-- Q -> subst a v P |-- subst a v Q.

Proof.

unfold subst, derives.

simpl;

auto.

Qed.



Definition func_ptr (f: funspec) (v: val): mpred :=

  EX b: block, !! (v = Vptr b Ptrofs.zero) && seplog.func_at f (b, 0).



Lemma corable_func_ptr: forall f v, corable (func_ptr f v).

Proof.

  intros.

  unfold func_ptr.

  apply corable_exp; intro.

  apply corable_andp; auto.

  apply assert_lemmas.corable_func_at.

Qed.



Lemma func_ptr_isptr: forall spec f, func_ptr spec f |-- !! isptr f.

Proof.

  intros.

  unfold func_ptr.

  destruct spec.

  normalize.

Qed.



Definition NDmk_funspec (f: funsig) (cc: calling_convention)

  (A: Type) (Pre Post: A -> environ -> mpred): funspec :=

  mk_funspec f cc (rmaps.ConstType A) (fun _ => Pre) (fun _ => Post)

    (const_super_non_expansive _ _) (const_super_non_expansive _ _).



Lemma approx_func_ptr: forall (A: Type) fsig0 cc (P Q: A -> environ -> mpred) (v: val) (n: nat),

  compcert_rmaps.RML.R.approx n (func_ptr (NDmk_funspec fsig0 cc A P Q) v) = compcert_rmaps.RML.R.approx n (func_ptr (NDmk_funspec fsig0 cc A (fun a rho => compcert_rmaps.RML.R.approx n (P a rho)) (fun a rho => compcert_rmaps.RML.R.approx n (Q a rho))) v).

Proof.

  exact seplog.approx_func_ptr.

Qed.



Definition allp_fun_id (Delta : tycontext): environ -> mpred :=

(ALL id : ident ,

 (ALL fs : funspec ,

  !! ((glob_specs Delta) ! id = Some fs) -->

  (EX b : block, local (`eq (fun rho => Map.get (ge_of rho) id) `(Some b)) && `(seplog.func_at fs (b, 0))))).



Lemma corable_allp_fun_id: forall Delta rho,

  corable (allp_fun_id Delta rho).

Proof.

  intros.

  unfold allp_fun_id; simpl.

  apply corable_allp; intros id.

  apply corable_allp; intros fs.

  apply corable_imp; [apply corable_prop |].

  apply corable_exp; intros b.

  apply corable_andp; [apply corable_prop |].

  apply assert_lemmas.corable_func_at.

Qed.



Definition type_of_funsig (fsig: funsig) :=

   Tfunction (type_of_params (fst fsig)) (snd fsig) cc_default.

Definition fn_funsig (f: function) : funsig := (fn_params f, fn_return f).



Definition tc_fn_return (Delta: tycontext) (ret: option ident) (t: type) :=

 match ret with

 | None => True

 | Some i => match (temp_types Delta) ! i with Some t' => t=t' | _ => False end

 end.



Definition globals_only (rho: environ) : environ :=

    mkEnviron (ge_of rho) (Map.empty _) (Map.empty _).



Fixpoint make_args (il: list ident) (vl: list val) (rho: environ)  :=

  match il, vl with

  | nil, nil => globals_only rho

  | i::il', v::vl' => env_set (make_args il' vl' rho) i v

   | _ , _ => rho

 end.

Definition make_args' (fsig: funsig) args rho :=

   make_args (map (@fst _ _) (fst fsig)) (args rho) rho.



Definition ret_temp : ident := 1%positive.



Definition get_result1 (ret: ident) (rho: environ) : environ :=

   make_args (ret_temp::nil) (eval_id ret rho :: nil) rho.



Definition get_result (ret: option ident) : environ -> environ :=

 match ret with

 | None => make_args nil nil

 | Some x => get_result1 x

 end.



Definition maybe_retval (Q: environ -> mpred) retty ret :=

 match ret with

 | Some id => fun rho => Q (get_result1 id rho)

 | None =>

    match retty with

    | Tvoid => (fun rho => Q (globals_only rho))

    | _ => fun rho => EX v: val, Q (make_args (ret_temp::nil) (v::nil) rho)

    end

 end.



Definition bind_ret (vl: option val) (t: type) (Q: environ -> mpred) : environ -> mpred :=

     match vl, t with

     | None, Tvoid =>`Q (make_args nil nil)

     | Some v, _ => @andp (environ->mpred) _ (!! tc_val t v)

                             (`Q (make_args (ret_temp::nil) (v::nil)))

     | _, _ => FF

     end.



Definition overridePost  (Q: environ->mpred)  (R: ret_assert) :=

 match R with 

  {| RA_normal := _; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := Q; RA_break := b; RA_continue := c; RA_return := r |}

 end.



Definition existential_ret_assert {A: Type} (R: A -> ret_assert) :=

  {| RA_normal := fun rho => EX x:A, (R x).(RA_normal) rho;

     RA_break := fun rho => EX x:A, (R x).(RA_break) rho;

     RA_continue := fun rho => EX x:A, (R x).(RA_continue) rho;

     RA_return := fun vl rho => EX x:A, (R x).(RA_return) vl rho

   |}.



Definition normal_ret_assert (Q: environ->mpred) : ret_assert :=

  {| RA_normal := Q; RA_break := seplog.FF; RA_continue := seplog.FF; RA_return := fun _ => seplog.FF |}.



Definition frame_ret_assert (R: ret_assert) (F: environ->mpred) : ret_assert :=

 match R with 

  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := n * F; 

     RA_break := b * F; 

     RA_continue := c * F;

     RA_return := fun vl => r vl * F |}

 end.



Definition switch_ret_assert (R: ret_assert) : ret_assert :=

 match R with 

  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := FF; 

     RA_break := n; 

     RA_continue := c;

     RA_return := r |}

 end.



Definition with_ge (ge: genviron) (G: environ->mpred) : mpred :=

     G (mkEnviron ge (Map.empty _) (Map.empty _)).



Fixpoint prog_funct' {F V} (l: list (ident * globdef F V)) : list (ident * F) :=

 match l with nil => nil | (i,Gfun f)::r => (i,f):: prog_funct' r | _::r => prog_funct' r

 end.



Definition prog_funct (p: program) := prog_funct' (prog_defs p).



Fixpoint prog_vars' {F V} (l: list (ident * globdef F V)) : list (ident * globvar V) :=

 match l with nil => nil | (i,Gvar v)::r => (i,v):: prog_vars' r | _::r => prog_vars' r

 end.



Definition prog_vars (p: program) := prog_vars' (prog_defs p).



Definition all_initializers_aligned (prog: program) :=

  forallb (fun idv => andb (initializers_aligned 0 (gvar_init (snd idv)))

                                 (Zlt_bool (init_data_list_size (gvar_init (snd idv))) Ptrofs.modulus))

                      (prog_vars prog) = true.



Definition loop1_ret_assert (Inv: environ->mpred) (R: ret_assert) : ret_assert :=

 match R with 

  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := Inv;

     RA_break := n; 

     RA_continue := Inv;

     RA_return := r |}

 end.



Definition loop2_ret_assert (Inv: environ->mpred) (R: ret_assert) : ret_assert :=

 match R with 

  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := Inv;

     RA_break := n;

     RA_continue := seplog.FF;

     RA_return := r |}

 end.



Definition function_body_ret_assert (ret: type) (Q: environ->mpred) : ret_assert :=

 {| RA_normal := seplog.FF;

    RA_break := seplog.FF; 

    RA_continue := seplog.FF;

    RA_return := fun vl => bind_ret vl ret Q |}.



Definition loop_nocontinue_ret_assert (Inv: environ->mpred) (R: ret_assert) : ret_assert :=

 match R with 

  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>

  {| RA_normal := Inv;

     RA_break := n; 

     RA_continue := seplog.FF;

     RA_return := r |}

 end.



Definition tc_environ (Delta: tycontext) : environ -> Prop :=

   fun rho => typecheck_environ Delta rho.



Definition tc_temp_id  (id: ident)  (ty: type) {CS: compspecs} (Delta: tycontext)

                       (e:expr): environ -> mpred :=

      denote_tc_assert (typecheck_temp_id id ty Delta e).



Definition typeof_temp (Delta: tycontext) (id: ident) : option type :=

 match (temp_types Delta) ! id with

 | Some t => Some t

 | None => None

 end.



Definition tc_expr {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred :=

    denote_tc_assert (typecheck_expr Delta e).



Definition tc_exprlist {CS: compspecs} (Delta: tycontext) (t: list type) (e: list expr)  : environ -> mpred :=

      denote_tc_assert (typecheck_exprlist Delta t e).



Definition tc_lvalue {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred :=

     denote_tc_assert (typecheck_lvalue Delta e).



Definition tc_expropt {CS: compspecs} Delta (e: option expr) (t: type) : environ -> mpred :=

   match e with None => `!!(t=Tvoid)

                     | Some e' => tc_expr Delta (Ecast e' t)

   end.



Definition is_comparison op :=

match op with

  | Cop.Oeq | Cop.One | Cop.Olt | Cop.Ogt | Cop.Ole | Cop.Oge => true

  | _ => false

end.



Definition blocks_match op v1 v2  :=

match op with Cop.Olt | Cop.Ogt | Cop.Ole | Cop.Oge =>

  match v1, v2 with

    Vptr b _, Vptr b2 _ => b=b2

    | _, _ => False

  end

| _ => True

end.



Definition cmp_ptr_no_mem c v1 v2  :=

match v1, v2 with

Vptr b o, Vptr b1 o1 =>

  if peq b b1 then

    Val.of_bool (Ptrofs.cmpu c o o1)

  else

    match Val.cmp_different_blocks c with

    | Some b => Val.of_bool b

    | None => Vundef

    end

| _, _ => Vundef

end.



Definition op_to_cmp cop :=

match cop with

| Cop.Oeq => Ceq | Cop.One =>  Cne

| Cop.Olt => Clt | Cop.Ogt =>  Cgt

| Cop.Ole => Cle | Cop.Oge =>  Cge

| _ => Ceq 

end.



Fixpoint arglist (n: positive) (tl: typelist) : list (ident*type) :=

 match tl with

  | Tnil => nil

  | Tcons t tl' => (n,t):: arglist (n+1)%positive tl'

 end.



Definition closed_wrt_modvars c (F: environ->mpred) : Prop :=

    closed_wrt_vars (modifiedvars c) F.



Definition initblocksize (V: Type)  (a: ident * globvar V)  : (ident * Z) :=

 match a with (id,l) => (id , init_data_list_size (gvar_init l)) end.



Definition main_pre (prog: program) : list Type -> globals -> environ -> mpred :=

(fun nil gv => globvars2pred gv (prog_vars prog)).



Definition main_pre_ext {Espec: OracleKind} (prog: program) (ora: OK_ty) : list Type -> globals -> environ -> mpred :=

(fun nil gv rho => globvars2pred gv (prog_vars prog) rho * has_ext ora).



Definition main_post (prog: program) : list Type -> (ident->val) -> environ->mpred :=

  (fun nil _ _ => TT).



Definition main_spec' (prog: program) 

    (post: list Type -> globals -> environ -> mpred): funspec :=

  mk_funspec (nil, tint) cc_default

     (rmaps.ConstType globals) (main_pre prog) post

       (const_super_non_expansive _ _) (const_super_non_expansive _ _).



Definition main_spec (prog: program): funspec :=

  mk_funspec (nil, tint) cc_default

     (rmaps.ConstType globals) (main_pre prog) (main_post prog)

       (const_super_non_expansive _ _) (const_super_non_expansive _ _).



Definition main_spec_ext' {Espec: OracleKind} (prog: program) (ora: OK_ty)

    (post: list Type -> globals -> environ -> mpred): funspec :=

  mk_funspec (nil, tint) cc_default

     (rmaps.ConstType globals) (main_pre_ext prog ora) post

       (const_super_non_expansive _ _) (const_super_non_expansive _ _).



Definition main_spec_ext {Espec: OracleKind} (prog: program) (ora: OK_ty) : funspec :=

  mk_funspec (nil, tint) cc_default

     (rmaps.ConstType globals) (main_pre_ext prog ora) (main_post prog)

       (const_super_non_expansive _ _) (const_super_non_expansive _ _).



Fixpoint match_globvars (gvs: list (ident * globvar type)) (V: varspecs) : bool :=

 match V with

 | nil => true

 | (id,t)::V' => match gvs with

                       | nil => false

                       | (j,g)::gvs' => if eqb_ident id j

                                              then andb (eqb_type t (gvar_info g)) (match_globvars gvs' V')

                                              else match_globvars gvs' V

                      end

  end.



Definition int_range (sz: intsize) (sgn: signedness) (i: int) :=

 match sz, sgn with

 | I8, Signed => -128 <= Int.signed i < 128

 | I8, Unsigned => 0 <= Int.unsigned i < 256

 | I16, Signed => -32768 <= Int.signed i < 32768

 | I16, Unsigned => 0 <= Int.unsigned i < 65536

 | I32, Signed => -2147483648 <= Int.signed i < 2147483648

 | I32, Unsigned => 0 <= Int.unsigned i < 4294967296

 | IBool, _ => 0 <= Int.unsigned i < 256

end.



Lemma mapsto_value_range:

 forall sh v sz sgn i,

   readable_share sh ->

   mapsto sh (Tint sz sgn noattr) v (Vint i) =

    !! int_range sz sgn i && mapsto sh (Tint sz sgn noattr) v (Vint i).

Proof. exact mapsto_memory_block.mapsto_value_range. Qed.



Definition semax_body_params_ok f : bool :=

   andb

        (compute_list_norepet (map (@fst _ _) (fn_params f) ++ map (@fst _ _) (fn_temps f)))

        (compute_list_norepet (map (@fst _ _) (fn_vars f))).



Definition var_sizes_ok {cs: compspecs} (vars: list (ident*type)) :=

   Forall (fun var : ident * type => sizeof (snd var) <= Ptrofs.max_unsigned)%Z vars.



Definition make_ext_rval  (gx: genviron) (v: option val):=

  match v with

  | Some v' =>  mkEnviron gx (Map.empty _)

                              (Map.set 1%positive v' (Map.empty _))

  | None => mkEnviron gx (Map.empty _) (Map.empty _)

  end.



Definition tc_option_val (sig: type) (ret: option val) :=

  match sig, ret with

    | Tvoid, None => True

    | Tvoid, Some _ => False

    | ty, Some v => tc_val ty v

    | _, _ => False

  end.



Fixpoint zip_with_tl {A : Type} (l1 : list A) (l2 : typelist) : list (A*type) :=

  match l1, l2 with

    | a::l1', Tcons b l2' => (a,b)::zip_with_tl l1' l2'

    | _, _ => nil

  end.



Definition  funspecs_norepeat (fs : funspecs) := list_norepet (map fst fs).



Require VST.veric.semax_ext.



Definition add_funspecs (Espec : OracleKind)

         (ext_link: Strings.String.string -> ident)

         (fs : funspecs) : OracleKind :=

   veric.semax_ext.add_funspecs Espec ext_link fs.



Definition funsig2signature (s : funsig) cc : signature :=

  mksignature (map typ_of_type (map snd (fst s))) (opttyp_of_type (snd s)) cc.



Transparent mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric SRveric Bveric.



Lemma typecheck_lvalue_sound {CS: compspecs} :

  forall Delta rho e,

    typecheck_environ Delta rho ->

    tc_lvalue Delta e rho |-- !! is_pointer_or_null (eval_lvalue e rho).

Proof.

intros.

intros ? ?.

eapply expr_lemmas4.typecheck_lvalue_sound; eauto.

Qed.



Lemma typecheck_expr_sound {CS: compspecs} :

  forall Delta rho e,

    typecheck_environ Delta rho ->

    tc_expr Delta e rho |-- !! tc_val (typeof e) (eval_expr e rho).

Proof.

intros.

intros ? ?.

simpl.

eapply expr_lemmas4.typecheck_expr_sound; eauto.

Qed.



Lemma rel_expr_const_int: forall {CS: compspecs} i ty P rho,

              P |-- rel_expr (Econst_int i ty) (Vint i) rho.

Proof. intros. intros ? ?; constructor. Qed.



Lemma rel_expr_const_float: forall {CS: compspecs}  f ty P rho,

              P |-- rel_expr (Econst_float f ty) (Vfloat f) rho.

Proof. intros. intros ? ?; constructor. Qed.



Lemma rel_expr_const_single: forall {CS: compspecs}   f ty P rho,

              P |-- rel_expr (Econst_single f ty) (Vsingle f) rho.

Proof. intros. intros ? ?; constructor. Qed.



Lemma rel_expr_const_long: forall {CS: compspecs}  i ty P rho,

             P |--  rel_expr (Econst_long i ty) (Vlong i) rho.

Proof. intros. intros ? ?; constructor. Qed.



Lemma rel_expr_tempvar: forall {CS: compspecs}  id ty v P rho,

          Map.get (te_of rho) id = Some v ->

          P |-- rel_expr (Etempvar id ty) v rho.

Proof. intros. intros ? ?. constructor; auto. Qed.



Lemma rel_expr_addrof: forall {CS: compspecs} a ty v P rho,

               P |-- rel_lvalue a v rho ->

               P |-- rel_expr (Eaddrof a ty) v rho.

Proof. intros. intros ? ?. constructor; auto. apply H; auto. Qed.



Lemma rel_expr_unop: forall {CS: compspecs}  P a1 v1 v ty op rho,

                 P |-- rel_expr a1 v1 rho ->

                 (forall m, Cop.sem_unary_operation op v1 (typeof a1) m = Some v) ->

                 P |-- rel_expr (Eunop op a1 ty) v rho.

Proof.

intros. intros ? ?. econstructor; eauto. apply H; auto. Qed.



Lemma rel_expr_binop: forall {CS: compspecs}  a1 a2 v1 v2 v ty op P rho,

                 P |-- rel_expr a1 v1 rho ->

                 P |-- rel_expr  a2 v2 rho ->

                 binop_stable cenv_cs op a1 a2 = true ->

                 (forall m, Cop.sem_binary_operation cenv_cs op v1 (typeof a1) v2 (typeof a2) m = Some v) ->

                 P |-- rel_expr (Ebinop op a1 a2 ty) v rho.

Proof.

intros. intros ? ?. econstructor; eauto. apply H; auto. apply H0; auto. Qed.



Lemma rel_expr_cast: forall {CS: compspecs}  a1 v1 v ty P rho,

                 P |-- rel_expr a1 v1 rho ->

                 (forall m, Cop.sem_cast v1 (typeof a1) ty m = Some v) ->

                 P |-- rel_expr (Ecast a1 ty) v rho.

Proof.

intros. intros ? ?. econstructor; eauto. apply H; auto. Qed.



Lemma rel_expr_lvalue_By_value: forall {CS: compspecs} ch a sh v1 v2 P rho,

           access_mode (typeof a) = By_value ch ->

           P |-- rel_lvalue a v1 rho ->

           P |-- mapsto sh (typeof a) v1 v2 * TT  ->

           v2 <> Vundef ->

           readable_share sh ->

           P |-- rel_expr a v2 rho.

Proof.

intros. intros ? ?.

econstructor; eauto.

+ apply H0; auto.

+ apply H1; auto.

Qed.



Lemma rel_expr_lvalue_By_reference: forall {CS: compspecs} a v1 P rho,

           access_mode (typeof a) = By_reference ->

           P |-- rel_lvalue a v1 rho ->

           P |-- rel_expr a v1 rho.

Proof.

intros. intros ? ?.

hnf.

eapply rel_expr'_lvalue_By_reference; eauto.

apply H0; auto.

 Qed.



Lemma rel_lvalue_local: forall {CS: compspecs} id ty b P rho,

                 P |-- !! (Map.get (ve_of rho) id = Some (b,ty)) ->

                 P |-- rel_lvalue (Evar id ty) (Vptr  b Ptrofs.zero) rho.

Proof.

intros. intros ? ?. constructor.  specialize (H _ H0). apply H.

Qed.



Lemma rel_lvalue_global: forall {CS: compspecs} id ty b P rho,

              P |-- !! (Map.get (ve_of rho) id = None /\ Map.get (ge_of rho) id = Some b) ->

              P |-- rel_lvalue (Evar id ty) (Vptr b Ptrofs.zero) rho.

Proof.

intros. intros ? ?. specialize (H _ H0). destruct H. constructor 2; auto.

Qed.



Lemma rel_lvalue_deref: forall {CS: compspecs} a b z ty P rho,

              P |-- rel_expr a (Vptr b z) rho->

              P |-- rel_lvalue (Ederef a ty) (Vptr b z) rho.

Proof. intros. intros ? ?. constructor. apply H. auto. Qed.



Lemma rel_lvalue_field_struct: forall {CS: compspecs}  i ty a b z id att delta co P rho,

               typeof a = Tstruct id att ->

               cenv_cs ! id = Some co ->

               field_offset cenv_cs i (co_members co) = Errors.OK delta ->

               P |-- rel_lvalue a (Vptr b z) rho ->

               P |-- rel_lvalue (Efield a i ty) (Vptr b (Ptrofs.add z (Ptrofs.repr delta))) rho.

Proof.

intros. intros ? ?. econstructor; eauto. apply H2; auto. Qed.



Global Opaque mpred Nveric Sveric Cveric Iveric Rveric Sveric SIveric SRveric Bveric.

Global Opaque rel_expr.

Global Opaque rel_lvalue.



Hint Resolve (@subp_sepcon mpred Nveric Iveric Sveric SIveric Rveric SRveric): contractive.



Fixpoint unfold_Ssequence c :=

  match c with

  | Ssequence c1 c2 => unfold_Ssequence c1 ++ unfold_Ssequence c2

  | _ => c :: nil

  end.



Fixpoint nocontinue s :=

 match s with

 | Ssequence s1 s2 => if nocontinue s1 then nocontinue s2 else false

 | Sifthenelse _ s1 s2 => if nocontinue s1 then nocontinue s2 else false

 | Sswitch _ sl => nocontinue_ls sl

 | Sgoto _ => false

 | Scontinue => false

 | Slabel _ s => nocontinue s

 | _ => true

end

with nocontinue_ls sl :=

 match sl with LSnil => true | LScons _ s sl' => if nocontinue s then nocontinue_ls sl' else false

 end.



Module Type CLIGHT_SEPARATION_HOARE_LOGIC_DEF.



Parameter semax: forall {CS: compspecs} {Espec: OracleKind},

    tycontext -> (environ->mpred) -> statement -> ret_assert -> Prop.



Parameter semax_func:

    forall {Espec: OracleKind},

    forall (V: varspecs) (G: funspecs) {C: compspecs} (fdecs: list (ident * fundef)) (G1: funspecs), Prop.



Parameter semax_external:

  forall {Hspec: OracleKind} (ids: list ident) (ef: external_function)

  (A: rmaps.TypeTree)

  (P Q: forall ts, functors.MixVariantFunctor._functor (rmaps.dependent_type_functor_rec ts (AssertTT A)) mpred),

     Prop.



End CLIGHT_SEPARATION_HOARE_LOGIC_DEF.



Module DerivedDefs (Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF).



Local Open Scope pred.



Definition semax_body

       (V: varspecs) (G: funspecs) {C: compspecs} (f: function) (spec: ident * funspec): Prop :=

  match spec with (_, mk_funspec _ cc A P Q NEP NEQ) =>

    forall Espec ts x, 

      @Def.semax C Espec (func_tycontext f V G nil )

          (P ts x *  stackframe_of f)

          (Ssequence f.(fn_body) (Sreturn None))

          (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of f))

 end.



Definition semax_prog

    {Espec: OracleKind} {C: compspecs}

     (prog: program)  (V: varspecs) (G: funspecs) : Prop :=

  compute_list_norepet (prog_defs_names prog) = true  /\

  all_initializers_aligned prog /\

  cenv_cs = prog_comp_env prog /\

  @Def.semax_func Espec V G C (prog_funct prog) G /\

  match_globvars (prog_vars prog) V = true /\

  match initial_world.find_id prog.(prog_main) G with

  | Some s => exists post, s = main_spec' prog post

  | None => False

  end.



Definition semax_prog_ext

    {Espec: OracleKind} {C: compspecs}

     (prog: program) (z : OK_ty) (V: varspecs) (G: funspecs) : Prop :=

  compute_list_norepet (prog_defs_names prog) = true  /\

  all_initializers_aligned prog /\

  cenv_cs = prog_comp_env prog /\

  @Def.semax_func Espec V G C (prog_funct prog) G /\

  match_globvars (prog_vars prog) V = true /\

  match initial_world.find_id prog.(prog_main) G with

  | Some s => exists post, s = main_spec_ext' prog z post

  | None => False

  end.



End DerivedDefs.



Module Type MINIMUM_CLIGHT_SEPARATION_HOARE_LOGIC.



Declare Module CSHL_Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF.



Module CSHL_Defs := DerivedDefs(CSHL_Def).



Import CSHL_Def.

Import CSHL_Defs.



Axiom semax_extract_exists:

  forall {CS: compspecs} {Espec: OracleKind},

  forall (A : Type) (P : A -> environ->mpred) c (Delta: tycontext) (R: ret_assert),

  (forall x, @semax CS Espec Delta (P x) c R) ->

   @semax CS Espec Delta (EX x:A, P x) c R.



Axiom semax_func_nil:   forall {Espec: OracleKind},

        forall V G C, @semax_func Espec V G C nil nil.



Axiom semax_func_cons:

  forall {Espec: OracleKind},

     forall fs id f cc A P Q NEP NEQ (V: varspecs) (G G': funspecs) {C: compspecs},

      andb (id_in_list id (map (@fst _ _) G))

      (andb (negb (id_in_list id (map (@fst ident fundef) fs)))

        (semax_body_params_ok f)) = true ->

      Forall

         (fun it : ident * type =>

          complete_type cenv_cs (snd it) =

          true) (fn_vars f) ->

       var_sizes_ok (f.(fn_vars)) ->

       f.(fn_callconv) = cc ->

       precondition_closed f P ->

      semax_body V G f (id, mk_funspec (fn_funsig f) cc A P Q NEP NEQ)->

      semax_func V G fs G' ->

      semax_func V G ((id, Internal f)::fs)

           ((id, mk_funspec (fn_funsig f) cc A P Q NEP NEQ)  :: G').



Axiom semax_func_cons_ext:

  forall {Espec: OracleKind},

   forall (V: varspecs) (G: funspecs) {C: compspecs} fs id ef argsig retsig A P Q NEP NEQ

          argsig'

          (G': funspecs) cc (ids: list ident),

      ids = map fst argsig' -> 


      argsig' = zip_with_tl ids argsig ->

      ef_sig ef =

      mksignature

        (typlist_of_typelist (type_of_params argsig'))

        (opttyp_of_type retsig) cc ->

      id_in_list id (map (@fst _ _) fs) = false ->

      length ids = length (typelist2list argsig) ->

      (forall gx ts x (ret : option val),

         (Q ts x (make_ext_rval gx ret)

            && !!step_lemmas.has_opttyp ret (opttyp_of_type retsig)

            |-- !!tc_option_val retsig ret)) ->

      @semax_external Espec ids ef A P Q ->

      semax_func V G fs G' ->

      semax_func V G ((id, External ef argsig retsig cc)::fs)

           ((id, mk_funspec (argsig', retsig) cc A P Q NEP NEQ)  :: G').



Axiom semax_ifthenelse :

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta P (b: expr) c d R,

      bool_type (typeof b) = true ->

     @semax CS Espec Delta (P && local (`(typed_true (typeof b)) (eval_expr b))) c R ->

     @semax CS Espec Delta (P && local (`(typed_false (typeof b)) (eval_expr b))) d R ->

     @semax CS Espec Delta (tc_expr Delta (Eunop Cop.Onotbool b (Tint I32 Signed noattr)) && P) (Sifthenelse b c d) R.



Axiom semax_seq:

  forall{CS: compspecs} {Espec: OracleKind},

forall Delta R P Q h t,

    @semax CS Espec Delta P h (overridePost Q R) ->

    @semax CS Espec Delta Q t R ->

    @semax CS Espec Delta P (Ssequence h t) R.



Axiom semax_break:

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta Q,    @semax CS Espec Delta (RA_break Q) Sbreak Q.



Axiom semax_continue:

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta Q,    @semax CS Espec Delta (RA_continue Q) Scontinue Q.



Axiom semax_loop :

  forall{CS: compspecs} {Espec: OracleKind},

forall Delta Q Q' incr body R,

     @semax CS Espec Delta  Q body (loop1_ret_assert Q' R) ->

     @semax CS Espec Delta Q' incr (loop2_ret_assert Q R) ->

     @semax CS Espec Delta Q (Sloop body incr) R.



Axiom semax_switch: 

  forall{CS: compspecs} {Espec: OracleKind},

  forall Delta (Q: environ->mpred) a sl R,

     is_int_type (typeof a) = true ->

     (forall rho, Q rho |-- tc_expr Delta a rho) ->

     (forall n,

     @semax CS Espec Delta 

               (local (`eq (eval_expr a) `(Vint n)) &&  Q)

               (seq_of_labeled_statement (select_switch (Int.unsigned n) sl))

               (switch_ret_assert R)) ->

     @semax CS Espec Delta Q (Sswitch a sl) R.



Axiom semax_call :

  forall {CS: compspecs} {Espec: OracleKind},

    forall Delta A P Q NEP NEQ ts x (F: environ -> mpred) ret argsig retsig cc a bl,

           Cop.classify_fun (typeof a) =

           Cop.fun_case_f (type_of_params argsig) retsig cc ->

           (retsig = Tvoid -> ret = None) ->

          tc_fn_return Delta ret retsig ->

  @semax CS Espec Delta

          ((|>((tc_expr Delta a) && (tc_exprlist Delta (snd (split argsig)) bl)))  &&

         (`(func_ptr (mk_funspec  (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) &&

          |>(F * `(P ts x: environ -> mpred) (make_args' (argsig,retsig) (eval_exprlist (snd (split argsig)) bl)))))

         (Scall ret a bl)

         (normal_ret_assert

          (EX old:val, substopt ret (`old) F * maybe_retval (Q ts x) retsig ret)).



Axiom  semax_return :

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta (R: ret_assert) ret ,

      @semax CS Espec Delta

                ( (tc_expropt Delta ret (ret_type Delta)) &&

                `(RA_return R : option val -> environ -> mpred) (cast_expropt ret (ret_type Delta)) (@id environ))

                (Sreturn ret)

                R.



Axiom semax_set_forward :

  forall {CS: compspecs} {Espec: OracleKind},

forall (Delta: tycontext) (P: environ->mpred) id e,

    @semax CS Espec Delta

        (|> ( (tc_expr Delta e) &&

             (tc_temp_id id (typeof e) Delta e) &&

          P))

          (Sset id e)

        (normal_ret_assert

          (EX old:val, local (`eq (eval_id id) (subst id (`old) (eval_expr e))) &&

                            subst id (`old) P)).



Axiom semax_ptr_compare :

forall{CS: compspecs} {Espec: OracleKind},

forall (Delta: tycontext) P id cmp e1 e2 ty sh1 sh2,

    sepalg.nonidentity sh1 -> sepalg.nonidentity sh2 ->

   is_comparison cmp = true  ->

   eqb_type (typeof e1) int_or_ptr_type = false ->

   eqb_type (typeof e2) int_or_ptr_type = false ->

   typecheck_tid_ptr_compare Delta id = true ->

   @semax CS Espec Delta

        ( |> ( (tc_expr Delta e1) &&

              (tc_expr Delta e2)  &&



          local (`(blocks_match cmp) (eval_expr e1) (eval_expr e2)) &&

          (`(mapsto_ sh1 (typeof e1)) (eval_expr e1) * TT) &&

          (`(mapsto_ sh2 (typeof e2)) (eval_expr e2) * TT) &&

          P))

          (Sset id (Ebinop cmp e1 e2 ty))

        (normal_ret_assert

          (EX old:val,

                 local (`eq (eval_id id)  (subst id `(old)

                     (eval_expr (Ebinop cmp e1 e2 ty)))) &&

                            subst id `(old) P)).



Axiom semax_load :

  forall {CS: compspecs} {Espec: OracleKind},

forall (Delta: tycontext) sh id P e1 t2 (v2: val),

    typeof_temp Delta id = Some t2 ->

    is_neutral_cast (typeof e1) t2 = true ->

    readable_share sh ->

    local (tc_environ Delta) && P |-- `(mapsto sh (typeof e1)) (eval_lvalue e1) (`v2) * TT ->

    @semax CS Espec Delta

       (|> ( (tc_lvalue Delta e1) &&

       local (`(tc_val (typeof e1) v2)) &&

          P))

       (Sset id e1)

       (normal_ret_assert (EX old:val, local (`eq (eval_id id) (`v2)) &&

                                          (subst id (`old) P))).



Axiom semax_cast_load :

  forall {CS: compspecs} {Espec: OracleKind},

forall (Delta: tycontext) sh id P e1 t1 (v2: val),

    typeof_temp Delta id = Some t1 ->

   cast_pointer_to_bool (typeof e1) t1 = false ->

    readable_share sh ->

    local (tc_environ Delta) && P |-- `(mapsto sh (typeof e1)) (eval_lvalue e1) (`v2) * TT ->

    @semax CS Espec Delta

       (|> ( (tc_lvalue Delta e1) &&

       local (`(tc_val t1) (`(eval_cast (typeof e1) t1 v2))) &&

          P))

       (Sset id (Ecast e1 t1))

       (normal_ret_assert (EX old:val, local (`eq (eval_id id) (`(eval_cast (typeof e1) t1 v2))) &&

                                          (subst id (`old) P))).



Axiom semax_store:

  forall {CS: compspecs} {Espec: OracleKind},

 forall Delta e1 e2 sh P,

   writable_share sh ->

   @semax CS Espec Delta

          (|> ( (tc_lvalue Delta e1) &&  (tc_expr Delta (Ecast e2 (typeof e1)))  &&

             (`(mapsto_ sh (typeof e1)) (eval_lvalue e1) * P)))

          (Sassign e1 e2)

          (normal_ret_assert

               (`(mapsto sh (typeof e1)) (eval_lvalue e1) (`force_val (`(sem_cast (typeof e2) (typeof e1)) (eval_expr e2))) * P)).



Axiom semax_skip:

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta P, @semax CS Espec Delta P Sskip (normal_ret_assert P).



Axiom semax_conseq:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta P' (R': ret_assert) P c (R: ret_assert) ,

    local (tc_environ Delta) && ((allp_fun_id Delta) && P) |-- |==> |> FF || P' ->

    local (tc_environ Delta) && ((allp_fun_id Delta) && RA_normal R') |-- |==> |> FF || RA_normal R ->

    local (tc_environ Delta) && ((allp_fun_id Delta) && RA_break R') |-- |==> |> FF || RA_break R ->

    local (tc_environ Delta) && ((allp_fun_id Delta) && RA_continue R') |-- |==> |> FF || RA_continue R ->

    (forall vl, local (tc_environ Delta) && ((allp_fun_id Delta) && RA_return R' vl) |-- |==> |> FF || RA_return R vl) ->

   @semax CS Espec Delta P' c R' -> @semax CS Espec Delta P c R.



Axiom semax_Slabel:

   forall {cs:compspecs} {Espec: OracleKind},

     forall Delta (P:environ -> mpred) (c:statement) (Q:ret_assert) l,

   @semax cs Espec Delta P c Q -> @semax cs Espec Delta P (Slabel l c) Q.



Axiom semax_ext:

  forall  (Espec : OracleKind)

         (ext_link: Strings.String.string -> ident)

         (id : Strings.String.string) (ids : list ident) (sig : funsig) (sig' : signature)

         cc A P Q NEP NEQ (fs : funspecs),

  let f := mk_funspec sig cc A P Q NEP NEQ in

  In (ext_link id,f) fs ->

  funspecs_norepeat fs ->

  ids = fst (split (fst sig)) ->

  sig' = funsig2signature sig cc ->

  @semax_external (add_funspecs Espec ext_link fs) ids (EF_external id sig') _ P Q.



Axiom semax_ext_void:

  forall  (Espec : OracleKind)

         (ext_link: Strings.String.string -> ident)

         (id : Strings.String.string) (ids : list ident) sig (sig' : signature)

         cc A P Q NEP NEQ (fs : funspecs),

  let f := mk_funspec (sig, tvoid) cc A P Q NEP NEQ in

  In (ext_link id,f) fs ->

  funspecs_norepeat fs ->

  ids = fst (split sig) ->

  sig' = mksignature (map typ_of_type (map snd sig)) None cc ->

  @semax_external (add_funspecs Espec ext_link fs) ids (EF_external id sig') _ P Q.



Axiom semax_external_FF:

 forall Espec ids ef A,

  @semax_external Espec ids ef A (fun _ _ => FF) (fun _ _ => FF).



End MINIMUM_CLIGHT_SEPARATION_HOARE_LOGIC.



Module Type PRACTICAL_CLIGHT_SEPARATION_HOARE_LOGIC.



Declare Module CSHL_MinimumLogic: MINIMUM_CLIGHT_SEPARATION_HOARE_LOGIC.



Import CSHL_MinimumLogic.CSHL_Def.

Import CSHL_MinimumLogic.CSHL_Defs.



Axiom semax_set :

  forall {CS: compspecs} {Espec: OracleKind},

forall (Delta: tycontext) (P: environ->mpred) id e,

    @semax CS Espec Delta

        (|> ( (tc_expr Delta e) &&

             (tc_temp_id id (typeof e) Delta e) &&

             subst id (eval_expr e) P))

          (Sset id e) (normal_ret_assert P).



Axiom semax_fun_id:

  forall {CS: compspecs} {Espec: OracleKind},

      forall id f Delta P Q c,

    (var_types Delta) ! id = None ->

    (glob_specs Delta) ! id = Some f ->

    (glob_types Delta) ! id = Some (type_of_funspec f) ->

    @semax CS Espec Delta (P && `(func_ptr f) (eval_var id (type_of_funspec f)))

                  c Q ->

    @semax CS Espec Delta P c Q.



Axiom semax_extensionality_Delta:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta Delta' P c R,

       tycontext_sub Delta Delta' ->

     @semax CS Espec Delta P c R -> @semax CS Espec Delta' P c R.



Axiom semax_unfold_Ssequence: forall {CS: compspecs} {Espec: OracleKind} c1 c2,

  unfold_Ssequence c1 = unfold_Ssequence c2 ->

  (forall P Q Delta, @semax CS Espec Delta P c1 Q -> @semax CS Espec Delta P c2 Q).



Axiom seq_assoc:

  forall {CS: compspecs} {Espec: OracleKind},

   forall Delta P s1 s2 s3 R,

        @semax CS Espec Delta P (Ssequence s1 (Ssequence s2 s3)) R <->

        @semax CS Espec Delta P (Ssequence (Ssequence s1 s2) s3) R.



Axiom semax_seq_skip:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta P s Q,

    @semax CS Espec Delta P s Q <-> @semax CS Espec Delta P (Ssequence s Sskip) Q.



Axiom semax_skip_seq:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta P s Q,

    @semax CS Espec Delta P s Q <-> @semax CS Espec Delta P (Ssequence Sskip s) Q.



Axiom semax_loop_nocontinue1:

  forall CS Espec Delta Pre s1 s2 s3 Post,

  nocontinue s1 = true ->

  nocontinue s2 = true ->

  nocontinue s3 = true ->

   @semax CS Espec Delta Pre (Sloop (Ssequence s1 (Ssequence s2 s3)) Sskip) Post ->

    @semax CS Espec Delta Pre (Sloop (Ssequence s1 s2) s3) Post.



Axiom semax_loop_nocontinue:

  forall {CS: compspecs} {Espec: OracleKind},

 forall Delta P body incr R,

 @semax CS Espec Delta P (Ssequence body incr) (loop_nocontinue_ret_assert P R) ->

 @semax CS Espec Delta P (Sloop body incr) R.



Axiom semax_convert_for_while':

 forall CS Espec Delta Pre s1 e2 s3 s4 s5 Post,

  nocontinue s4 = true ->

  nocontinue s3 = true -> 

  @semax CS Espec Delta Pre 

    (Ssequence s1 (Ssequence (Swhile e2 (Ssequence s4 s3)) s5)) Post ->

  @semax CS Espec Delta Pre (Ssequence (Sfor s1 e2 s4 s3) s5) Post.



Axiom semax_loop_unroll1:

  forall {CS: compspecs} {Espec: OracleKind} Delta P P' Q body incr R,

  @semax CS Espec Delta P body (loop1_ret_assert P' R) ->

  @semax CS Espec Delta P' incr (loop2_ret_assert Q R) ->

  @semax CS Espec Delta Q (Sloop body incr) R ->

  @semax CS Espec Delta P (Sloop body incr) R.



Axiom semax_if_seq:

 forall {CS: compspecs} {Espec: OracleKind} Delta P e c1 c2 c Q,

 semax Delta P (Sifthenelse e (Ssequence c1 c) (Ssequence c2 c)) Q ->

 semax Delta P (Ssequence (Sifthenelse e c1 c2) c) Q.



Axiom semax_seq_Slabel:

   forall {cs:compspecs} {Espec: OracleKind},

     forall Delta (P:environ -> mpred) (c1 c2:statement) (Q:ret_assert) l,

   @semax cs Espec Delta P (Ssequence (Slabel l c1) c2) Q <-> 

   @semax cs Espec Delta P (Slabel l (Ssequence c1 c2)) Q.



Axiom semax_frame:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta P s R F,

   closed_wrt_modvars s F ->

  @semax CS Espec Delta P s R ->

    @semax CS Espec Delta (P * F) s (frame_ret_assert R F).



Axiom semax_extract_prop:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta (PP: Prop) P c Q,

           (PP -> @semax CS Espec Delta P c Q) ->

           @semax CS Espec Delta (!!PP && P) c Q.



Axiom semax_extract_later_prop:

  forall {CS: compspecs} {Espec: OracleKind},

  forall Delta (PP: Prop) P c Q,

           (PP -> @semax CS Espec Delta P c Q) ->

           @semax CS Espec Delta ((|> !!PP) && P) c Q.



End PRACTICAL_CLIGHT_SEPARATION_HOARE_LOGIC.



Require Import Coq.Classes.Morphisms.



Instance prop_Proper:

  Proper (iff ==> (@eq mpred)) (prop).

Proof.

  intros ? ? ?.

  apply ND_prop_ext.

  auto.

Defined.

