

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.sig_isomorphism.
(* VST.msl.sig_isomorphism:
Require Import VST.msl.base.

Program Definition sig_sig_iff {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a) (x: sig P): sig Q := x.

Program Definition sig_sig_iff' {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a) (x: sig Q): sig P := x.

Program Definition sig_sig_eq {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a) (x: sig P): sig Q := x.

Program Definition sig_sig_eq' {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a) (x: sig Q): sig P := x.

Program Definition sigsig_sig {A: Type} {P Q: A -> Prop}
  (x: sig (fun x: sig P => Q (proj1_sig x))): sig (fun x => P x /\ Q x) := x.

Program Definition sig_sigsig {A: Type} {P Q: A -> Prop}
  (x: sig (fun x => P x /\ Q x)): sig (fun x: sig P => Q (proj1_sig x)) := x.

Program Definition bij_f_sig {A B} (f: bijection A B) (P: A -> Prop)
  (x: sig P): sig (fun b => P (bij_g _ _ f b)) := bij_f _ _ f x.

Program Definition bij_g_sig {A B} (f: bijection A B) (P: A -> Prop)
  (x: sig (fun b => P (bij_g _ _ f b))): sig P := bij_g _ _ f x.

Lemma sig_sig_iff_iff': forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a) x,
  (sig_sig_iff H) (sig_sig_iff' H x) = x.

Lemma sig_sig_iff'_iff: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a) x,
  (sig_sig_iff' H) (sig_sig_iff H x) = x.

Lemma sig_sig_eq_eq': forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a) x,
  (sig_sig_eq H) (sig_sig_eq' H x) = x.

Lemma sig_sig_eq'_eq: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a) x,
  (sig_sig_eq' H) (sig_sig_eq H x) = x.

Lemma sig_sigsig_sig: forall {A: Type} {P Q: A -> Prop} x,
  @sig_sigsig A P Q (@sigsig_sig A P Q x) = x.

Lemma sigsig_sig_sigsig: forall {A: Type} {P Q: A -> Prop} x,
  @sigsig_sig A P Q (@sig_sigsig A P Q x) = x.

Lemma sig_sig_iff_iff'_id: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a),
  (sig_sig_iff H) oo (sig_sig_iff' H) = id _.

Lemma bij_fg_sig: forall {A B} (f: bijection A B) (P: A -> Prop) x,
  bij_f_sig f P (bij_g_sig f P x) = x.

Lemma bij_gf_sig: forall {A B} (f: bijection A B) (P: A -> Prop) x,
  bij_g_sig f P (bij_f_sig f P x) = x.

Lemma sig_sig_iff'_iff_id: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a <-> Q a),
  (sig_sig_iff' H) oo (sig_sig_iff H) = id _.

Lemma sig_sig_eq_eq'_id: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a),
  (sig_sig_eq H) oo (sig_sig_eq' H) = id _.

Lemma sig_sig_eq'_eq_id: forall {A: Type} {P Q: A -> Prop}
  (H: forall a, P a = Q a),
  (sig_sig_eq' H) oo (sig_sig_eq H) = id _.

Lemma sig_sigsig_sig_id: forall {A: Type} {P Q: A -> Prop},
  sig_sigsig oo (@sigsig_sig A P Q) = id _.

Lemma sigsig_sig_sigsig_id: forall {A: Type} {P Q: A -> Prop},
  sigsig_sig oo (@sig_sigsig A P Q) = id _.

Lemma bij_fg_sig_id: forall {A B} (f: bijection A B) (P: A -> Prop),
  (bij_f_sig f P) oo (bij_g_sig f P) = id _.

Lemma bij_gf_sig_id: forall {A B} (f: bijection A B) (P: A -> Prop),
  (bij_g_sig f P) oo (bij_f_sig f P) = id _.

Definition sig_sig_iff_bij {A} {P Q: A -> Prop} (H: forall a, P a <-> Q a):
  bijection (sig P) (sig Q).

Definition sig_sig_eq_bij {A} {P Q: A -> Prop} (H: forall a, P a = Q a):
  bijection (sig P) (sig Q).

Definition sig_sigsig_bij {A} (P Q: A -> Prop):
  bijection (sig (fun a => P a /\ Q a)) (sig (fun a: sig P => Q (proj1_sig a))).

Definition bij_sig {A B} (f: bijection A B) (P: A -> Prop):
  bijection (sig P) (sig (fun b => P (bij_g _ _ f b))). *)

Require Import VST.msl.functors.
(* VST.msl.functors:
Require Import VST.msl.base.

Set Implicit Arguments.

Module CovariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : A -> B), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : B -> C) (g : A -> B),
fmap _ _ f oo fmap _ _ g = fmap _ _ (f oo g)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : A -> B), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End CovariantFunctor.

Module ContraVariantFunctor.

Record functorFacts (PS : Type -> Type)
  (fmap : forall A B (f : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) = id (PS A);
  ff_comp : forall A B C (f : C -> B) (g : B -> A),
fmap _ _ f oo fmap _ _ g = fmap _ _ (g oo f)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End ContraVariantFunctor.

Module MixVariantFunctor.

Record functorFacts (PS : Type -> Type)
 (fmap : forall A B (f1 : A -> B) (f2 : B -> A), PS A -> PS B) : Type :=
FunctorFacts {
  ff_id : forall A, fmap _ _ (id A) (id A) = id (PS A);
  ff_comp : forall A B C (f1 : B -> C) (f2 : C -> B) (g1 : A -> B)
(g2 : B -> A), fmap _ _ f1 f2 oo fmap _ _ g1 g2 = fmap _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type;
  fmap : forall A B (f1 : A -> B) (f2 : B -> A), _functor A -> _functor B;
  functor_facts : functorFacts _functor fmap
}.

End MixVariantFunctor.

Module CovariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : B2 -> C2)
(g1 : A1 -> B1) (g2 : A2 -> B2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (f2 oo g2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : A2 -> B2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CovariantBiFunctor.

Module CoContraVariantBiFunctor.

Record functorFacts (PS : Type -> Type -> Type)
 (fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    PS A1 A2 -> PS B1 B2) : Type :=
FunctorFacts {
  ff_id : forall A1 A2, fmap _ _ _ _ (id A1) (id A2) = id (PS A1 A2);
  ff_comp : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1) (f2 : C2 -> B2)
(g1 : A1 -> B1) (g2 : B2 -> A2),
  fmap _ _ _ _ f1 f2 oo fmap _ _ _ _ g1 g2 = fmap _ _ _ _ (f1 oo g1) (g2 oo f2)
}.

Record functor : Type := Functor {
  _functor: Type -> Type -> Type;
  fmap : forall A1 B1 A2 B2 (f1 : A1 -> B1) (f2 : B2 -> A2),
    _functor A1 A2 -> _functor B1 B2;
  functor_facts : functorFacts _functor fmap
}.

End CoContraVariantBiFunctor.

Coercion CovariantFunctor._functor:
  CovariantFunctor.functor >-> Funclass.
Coercion ContraVariantFunctor._functor:
  ContraVariantFunctor.functor >-> Funclass.
Coercion MixVariantFunctor._functor:
  MixVariantFunctor.functor >-> Funclass.
Coercion CovariantBiFunctor._functor:
  CovariantBiFunctor.functor >-> Funclass.
Coercion CoContraVariantBiFunctor._functor:
  CoContraVariantBiFunctor.functor >-> Funclass.

Module CovariantFunctorLemmas.

Import CovariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : B -> C) (g : A -> B),
  fmap F f oo fmap F g = fmap F (f oo g).

Lemma fmap_app {F: functor} : forall A B C (f : B -> C) (g : A -> B) x,
  fmap F f (fmap F g x) = fmap F (f oo g) x.

End CovariantFunctorLemmas.

Module ContraVariantFunctorLemmas.

Import ContraVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f : C -> B) (g : B -> A),
  fmap F f oo fmap F g = fmap F (g oo f).

Lemma fmap_app {F: functor} : forall A B C (f : C -> B) (g : B -> A) x,
  fmap F f (fmap F g x) = fmap F (g oo f) x.

End ContraVariantFunctorLemmas.

Module MixVariantFunctorLemmas.

Import MixVariantFunctor.

Lemma fmap_id {F: functor} : forall A, fmap F (id A) (id A) = id (F A).

Lemma fmap_comp {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A B C (f1 : B -> C) (f2: C -> B)
(g1 : A -> B) (g2: B -> A) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End MixVariantFunctorLemmas.

Module CovariantBiFunctorLemmas.

Import CovariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (f2 oo g2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: B2 -> C2) (g1 : A1 -> B1) (g2: A2 -> B2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (f2 oo g2) x.

End CovariantBiFunctorLemmas.

Module CoContraVariantBiFunctorLemmas.

Import CoContraVariantBiFunctor.

Lemma fmap_id {F: functor} : forall A1 A2, fmap F (id A1) (id A2) = id (F A1 A2).

Lemma fmap_comp {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2),
  fmap F f1 f2 oo fmap F g1 g2 = fmap F (f1 oo g1) (g2 oo f2).

Lemma fmap_app {F: functor} : forall A1 A2 B1 B2 C1 C2 (f1 : B1 -> C1)
(f2: C2 -> B2) (g1 : A1 -> B1) (g2: B2 -> A2) x,
  fmap F f1 f2 (fmap F g1 g2 x) = fmap F (f1 oo g1) (g2 oo f2) x.

End CoContraVariantBiFunctorLemmas.

Module GeneralFunctorGenerator.

Definition CovariantFunctor_MixVariantFunctor (F: CovariantFunctor.functor):

Definition ContraVariantFunctor_MixVariantFunctor
 (F: ContraVariantFunctor.functor):

Definition CovariantFunctor_CoContraVariantBiFunctor
 (F: CovariantFunctor.functor):

Definition CoContraVariantBiFunctor_MixVariantFunctor
 (F: CoContraVariantBiFunctor.functor):

Definition CovariantFunctor_CovariantFunctor_compose
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f => CovariantFunctor.fmap F1 (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantFunctor_MixVariantFunctor_compose
(F1: CovariantFunctor.functor) (F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F1 (F2 T))
   (fun A B f g => CovariantFunctor.fmap F1 (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite MixVariantFunctorLemmas.fmap_id, CovariantFunctorLemmas.fmap_id; auto.
  + rewrite !CovariantFunctorLemmas.fmap_comp, MixVariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_CovariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: CovariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CovariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (CovariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite !CovariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !CovariantFunctorLemmas.fmap_comp; auto.

Definition CovariantBiFunctor_MixVariantFunctor_compose
(F: CovariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CovariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 f g)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CovariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CovariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_CoContraVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1: CovariantFunctor.functor)
(F2: ContraVariantFunctor.functor):
  CovariantFunctor.functor.
  refine (@CovariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f => CoContraVariantBiFunctor.fmap F
      (CovariantFunctor.fmap F1 f) (ContraVariantFunctor.fmap F2 f)) _).
  constructor; intros; simpl.
  + rewrite CovariantFunctorLemmas.fmap_id, ContraVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, CovariantFunctorLemmas.fmap_comp, ContraVariantFunctorLemmas.fmap_comp; auto.

Definition CoContraVariantBiFunctor_MixVariantFunctor_compose
(F: CoContraVariantBiFunctor.functor)
(F1 F2: MixVariantFunctor.functor):
  MixVariantFunctor.functor.
  refine (@MixVariantFunctor.Functor
   (fun T => F (F1 T) (F2 T))
   (fun A B f g => CoContraVariantBiFunctor.fmap F
      (MixVariantFunctor.fmap F1 f g) (MixVariantFunctor.fmap F2 g f)) _).
  constructor; intros; simpl.
  + rewrite !MixVariantFunctorLemmas.fmap_id, CoContraVariantBiFunctorLemmas.fmap_id; auto.
  + rewrite CoContraVariantBiFunctorLemmas.fmap_comp, !MixVariantFunctorLemmas.fmap_comp; auto.

End GeneralFunctorGenerator.

Module CovariantBiFunctorGenerator.

Import CovariantBiFunctor.
Import CovariantBiFunctorLemmas.

Definition Fpair: functor.

Definition Fchoice: functor.

End CovariantBiFunctorGenerator.

Module CoContraVariantBiFunctorGenerator.

Import CoContraVariantBiFunctor.
Import CoContraVariantBiFunctorLemmas.

Definition Ffunc: functor.

End CoContraVariantBiFunctorGenerator.

Module CovariantFunctorGenerator.

Import CovariantFunctor.
Import CovariantFunctorLemmas.

Definition fconst (T : Type): functor.

Definition fidentity: functor.

Definition Foption: functor.

Definition Flist: functor.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Goal forall (F1 F2: functor) (T: Type), fpair F1 F2 T = prod (F1 T) (F2 T).

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_CovariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_CovariantFunctor_compose
  Flist
  F.

Goal forall (F : functor) (T: Type), foption F T = option (F T).

Definition ffunc (F1: ContraVariantFunctor.functor) (F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_CoContraVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Goal forall (F1 : ContraVariantFunctor.functor) (F2: functor) (T: Type),

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B (f: A -> B) x, P A x -> P B (fmap F f x)): functor.

End CovariantFunctorGenerator.

Module MixVariantFunctorGenerator.

Import MixVariantFunctor.
Import MixVariantFunctorLemmas.

Definition fconst (T : Type): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  (CovariantFunctorGenerator.fconst T).

Definition fidentity: functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
  CovariantFunctorGenerator.fidentity.

Definition fpair (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fpair
  F1
  F2.

Definition fchoice (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
  CovariantBiFunctorGenerator.Fchoice
  F1
  F2.

Definition foption (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Foption
  F.

Definition flist (F: functor): functor :=
  GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor_compose
  CovariantFunctorGenerator.Flist
  F.

Definition ffunc (F1 F2: functor): functor :=
  GeneralFunctorGenerator.CoContraVariantBiFunctor_MixVariantFunctor_compose
  CoContraVariantBiFunctorGenerator.Ffunc
  F2
  F1.

Definition fsig {I: Type} (F: I -> functor): functor.

Definition fpi {I: Type} (F: I -> functor): functor.

Definition fsubset (F: functor) (P: forall A, F A -> Prop)
  (Pfmap: forall A B f g x, P A x -> P B (fmap F f g x)): functor.

End MixVariantFunctorGenerator.

Unset Implicit Arguments. *)

Require VST.msl.knot.

Require VST.msl.knot_full_variant.



Require Import VST.msl.ageable.
(* VST.msl.ageable:
Require Import VST.msl.base.
  Require Coq.funind.Recdef.

Local Open Scope nat_scope.

Record ageable_facts (A:Type) (level: A -> nat) (age1:A -> option A)  :=
{ af_unage : forall x':A, exists x, age1 x = Some x'
; af_level1 : forall x, age1 x = None <-> level x = 0
; af_level2 : forall x y, age1 x = Some y -> level x = S (level y)
}.

Arguments af_unage [A] [level] [age1] _ _.
Arguments af_level1 [A] [level] [age1] _ _.
Arguments af_level2 [A] [level] [age1] _ _ _ _.

Class ageable (A:Type) := mkAgeable
{ level : A -> nat
; age1 : A -> option A
; age_facts : ageable_facts A level age1
}.

Definition age {A} `{ageable A} (x y:A) := age1 x = Some y.

Lemma af_wf {A} `{ageable A} :
 well_founded (fun x y => age y x).
Arguments af_wf [A] _ _.

Definition age_induction {A} `{ageable A} :=
  well_founded_induction (af_wf _).

Definition fashionR {A1} `{ageable A1} {A2}`{ageable A2} (x:A1) (y: A2) : Prop :=
  level x = level y.

Lemma fashionR_refl {A} `{ageable A} : reflexive _ fashionR.

Lemma fashionR_trans {A} `{ageable A} {B} `{ageable B} {C} `{ageable C} :
    forall (x: A) (y: B) (z: C), fashionR x y -> fashionR y z -> fashionR x z.

Lemma fashionR_sym {A} `{ageable A} {B} `{ageable B}:
   forall (x: A) (y: B), fashionR x y -> fashionR y x.

Lemma age_level {A} `{ageable A} : forall (x y:A),
  age x y -> level x = S (level y).

Lemma age1_level0 {A} `{ageable A} : forall (x:A),
  age1 x = None <-> level x = 0.

  Theorem level_level' : forall x:A, level x = level' x.
End level'.

Lemma levelS_age1 {A} `{ageable A} : forall (x:A) n,
  level x = S n ->
  exists y, age1 x = Some y.

Lemma age1_levelS {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  exists n, level x = S n.

Lemma age1_level0_absurd {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  level x = 0 ->
  False.

Lemma age1None_levelS_absurd {A} `{ageable A} : forall (x:A) n,
  age1 x = None ->
  level x = S n ->
  False.

Section RtRft.
  Variable A:Type.
  Variable R:relation A.

  Let Rt := clos_trans A R.
  Let Rft := clos_refl_trans A R.

  Lemma Rt_Rft : forall x y, Rt x y -> Rft x y.

  Lemma Rt_Rft_trans : forall x y z, Rt x y -> Rft y z -> Rt x z.

  Lemma Rft_Rt_trans : forall x y z, Rft x y -> Rt y z -> Rt x z.

  Lemma transpose_clos_trans : forall A R x y,
    clos_trans A (transp A R) x y <-> transp A (clos_trans A R) x y.
End RtRft.

Hint Resolve rt_refl.

Definition laterR {A} `{ageable A} : relation A := clos_trans A age.
Definition necR   {A} `{ageable A} : relation A := clos_refl_trans A age.

Require Coq.Wellfounded.Wellfounded.
Lemma laterR_wf {A} `{ageable A} :
  well_founded (transp _ laterR).

Definition laterR_induction {A} `{ageable A} :=
  @well_founded_induction A (transp A laterR) laterR_wf.

Lemma age_irreflexive {A}  `{ageable A}: forall x, age x x -> False.

Lemma laterR_irreflexive {A} `{HA: ageable A} : forall x, laterR x x -> False.

Lemma nec_refl_or_later {A} `{ageable A} : forall x y,
  necR x y -> x = y \/ laterR x y.

Lemma necR_antisym {A} `{ageable A} : forall x y,
  necR x y -> necR y x -> x = y.

Lemma age_later_nec {A} `{HA: ageable A} : forall x y z,
  age x y ->
  laterR x z ->
  necR y z.

Lemma necR_level {A} `{X: ageable A} : forall (x y:A),
  necR x y ->
  level x >= level y.

Lemma laterR_level {A} `{X: ageable A} : forall (x y:A),
  laterR x y ->
  level x > level y.

Section NAT_AGEABLE.

  Definition natLevel (x:nat) : nat := x.
  Definition natAge1 (x:nat) : option nat :=
    match x with
    | 0 => None
    | S n => Some n
    end.
  Definition natUnage (x:nat) : nat := S x.

  Lemma ag_nat_facts :
    ageable_facts nat natLevel natAge1.

  Definition ag_nat : ageable nat :=
    mkAgeable nat natLevel natAge1 ag_nat_facts.

  Lemma nec_nat : forall (n n':nat),
    @necR _ ag_nat n n' <-> n' <= n.

  Lemma later_nat : forall (n n':nat),
    @laterR _ ag_nat n n' <-> n' < n.

End NAT_AGEABLE.

Lemma laterR_level' {A} `{H : ageable A}: forall {w1 w2: A}, laterR w1 w2 -> @laterR _ ag_nat (level w1) (level w2).

Lemma necR_nat {A} `{H : ageable A}:
    forall {x y: A}, necR x y -> @necR nat ag_nat (level x) (level y).

Section BIJECTION.
  Variable A B : Type.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.

  Let levelB (x:B) : nat :=
    level (bij_g _ _ bijAB x).

  Let age1B  (x: B) : option B :=
     match age1 (bij_g _ _ bijAB x) with
     | Some y => Some (bij_f _ _ bijAB y)
     | None => None
     end.

  Let ageB (x y: B) :=age1B x = Some y.

  Lemma age_bij_unage :
    forall x', exists x, age1B x = Some x'.

  Lemma age_bij_level1 :
    forall x, age1B x = None <-> levelB x = 0.

  Lemma age_bij_level2 :
    forall x y, age1B x = Some y -> levelB x = S (levelB y).

  Lemma ag_bij_facts : ageable_facts B levelB age1B.

  Definition ag_bij : ageable B :=
    mkAgeable B levelB age1B ag_bij_facts.
End BIJECTION.

Section PROD.
  Variable A B : Type.
  Variable agA: ageable A.

  Let levelAB (x:prod A B) := level (fst x).
  Let age1AB (x:prod A B) :=
    match age1 (fst x) with
    | None => None
    | Some a' => Some (a',snd x)
    end.

  Lemma ag_prod_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod :=
    mkAgeable (prod A B) levelAB age1AB ag_prod_facts.

  Lemma prod_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod (n,x) (n',x') <-> necR n n' /\ x = x'.

  Lemma prod_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod (n,x) (n',x') <-> laterR n n' /\ x = x'.

End PROD.

Section PROD'.
  Variable A B : Type.
  Variable agB: ageable B.

  Let levelAB (x:prod A B) := level (snd x).
  Let age1AB (x:prod A B) :=
    match age1 (snd x) with
    | None => None
    | Some a' => Some (fst x, a')
    end.

  Lemma ag_prod'_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod' :=
    mkAgeable (prod A B) levelAB age1AB ag_prod'_facts.

  Lemma prod'_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod' (x,n) (x',n') <-> necR n n' /\ x = x'.

  Lemma prod'_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod' (x,n) (x',n') <-> laterR n n' /\ x = x'.

End PROD'.

Fixpoint composeOptN (A: Type) (f: A -> option A)
         (n: nat) (w: A) {struct n} : option A :=
 match n  with
 | S n' => match f w with Some w' => composeOptN A f n' w' | None => None end
 | O => Some w
 end.
Arguments composeOptN [A] _ _ _.

Definition ageN {A} `{ageable A}: nat -> A -> option A := composeOptN age1.

Lemma ageN1  {A} `{ageable A}: ageN 1 = age1.

Lemma ageN_compose {A} `{agA : ageable A}:
 forall a b c phi1 phi2 phi3,ageN a phi1 = Some phi2 ->
       ageN b phi2 = Some phi3 ->  (a+b=c)%nat ->  ageN c phi1 = Some phi3.

Lemma ageN_compose' {A} `{agA : ageable A}:
  forall a b phi1 phi3,
   ageN (a+b)%nat phi1 = Some phi3 -> exists phi2, ageN a phi1 = Some phi2 /\ ageN b phi2 = Some phi3.

Lemma necR_evolve {A} `{agA : ageable A}:
    necR = fun (phi phi': A) => exists n, ageN n phi = Some phi'.

Lemma age_noetherian  {A} `{ageable A}: forall phi, exists n, ageN n phi = None.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma age_noetherian'  {A} `{agA : ageable A}:
       forall phi, exists! n, exists phi', ageN n phi = Some phi' /\ age1 phi' = None.

Lemma ageable_ext:
   forall A (B C: ageable A),
      @age1 _ B = @age1 _ C -> @level _ B = @level _ C -> B=C.

Lemma necR_linear {A} `{H : ageable A}:
  forall {a b c}, necR a b -> necR a c -> necR b c \/ necR c b.

Lemma necR_linear' {A} `{H : ageable A}:
   forall {a b c}, necR a b -> necR a c -> level b = level c -> b=c.

Lemma laterR_necR {A} `{agA : ageable A}:
  forall {x y}, laterR x y -> necR x y.

Lemma necR_refl {A} `{H : ageable A}:
  forall phi, necR phi phi.

Hint Resolve @necR_refl.

Lemma necR_trans  {A} `{H : ageable A}:
  forall phi1 phi2 phi3, necR phi1 phi2 -> necR phi2 phi3 -> necR phi1 phi3.

Lemma necR_laterR {A} `{agA : ageable A}:
  forall w1 w2 w3, necR w1 w2 -> laterR w2 w3 -> laterR w1 w3. *)

Require Import VST.msl.predicates_hered.
(* VST.msl.predicates_hered:
Require Import VST.msl.base.
Require Import VST.msl.ageable.

Delimit Scope pred with pred.
Local Open Scope pred.

Definition hereditary {A} (R:A->A->Prop) (p:A->Prop) :=
  forall a a':A, R a a' -> p a -> p a'.

Definition pred (A:Type) {AG:ageable A} :=
  { p:A -> Prop | hereditary age p }.

Bind Scope pred with pred.

Definition app_pred {A} `{ageable A} (p:pred A) : A -> Prop := proj1_sig p.
Definition pred_hereditary `{ageable} (p:pred A) := proj2_sig p.
Coercion app_pred : pred >-> Funclass.
Global Opaque pred.

Hint Resolve @pred_hereditary.

Lemma nec_hereditary {A} `{ageable A} (p: A -> Prop) : hereditary age p ->
  forall a a':A, necR a a' -> p a -> p a'.

Lemma pred_nec_hereditary {A} `{ageable A} (p:pred A) :
  forall a a':A, necR a a' -> p a -> p a'.

Program Definition mkPred {A} `{ageable A} (p:A -> Prop) : pred A :=
  fun x => forall x', necR x x' -> p x'.

Definition derives {A} `{ageable A} (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] [H] _ _.

Definition valid_rel {A} `{ageable A} (R:relation A) : Prop :=
  commut A age R /\ commut A R age.

Definition modality {A} `{ageable A} := { R:relation A | valid_rel R }.

Definition app_mode {A} `{ageable A} (m:modality) : A -> A -> Prop := proj1_sig m.
Definition mode_valid {A} `{ageable A} (m:modality) := proj2_sig m.
Global Opaque modality.
Coercion app_mode : modality >-> Funclass.

Lemma valid_rel_commut_later1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A laterR R.

Lemma valid_rel_commut_later2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R laterR.

Lemma valid_rel_commut_nec1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A necR R.

Lemma valid_rel_commut_nec2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R necR.

Lemma valid_rel_age {A} `{ageable A} : valid_rel age.

Lemma valid_rel_later {A} `{ageable A} : valid_rel laterR.

Lemma valid_rel_nec {A} `{ageable A} : valid_rel necR.

Definition ageM {A} `{ageable A} : modality
  := exist _ age valid_rel_age.
Definition laterM {A} `{ageable A} : modality
  := exist _ laterR valid_rel_later.

Hint Resolve rt_refl rt_trans t_trans.
Hint Unfold necR.
Obligation Tactic := unfold hereditary; intuition;
    first [eapply pred_hereditary; eauto; fail | eauto ].

Program Definition prop {A} `{ageable A}  (P: Prop) : pred A := (fun _  => P).

Definition TT {A} `{ageable A}: pred A := prop True.
Definition FF  {A} `{ageable A}: pred A := prop False.

Program Definition imp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => forall a':A, necR a a' -> P a' -> Q a'.
Program Definition orp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a \/ Q a.

Program Definition andp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a /\ Q a.

Program Definition allp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.

Program Definition exp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Program Definition box {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => forall a', M a a' -> P a'.

Program Definition diamond {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => exists a', M a' a /\ P a'.

Definition boxy {A} `{ageable A} (m: modality) (p: pred A): Prop :=  box m p = p.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.

Notation "'|>' e" := (box laterM e) (at level 30, right associativity): pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Lemma modus_ponens {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma andp_right {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

  Lemma pred_ext' {A} `{ageable A}: forall (p1 p2:pred A),
    app_pred p1 = app_pred p2 ->
    p1 = p2.

Lemma pred_ext : forall A `{ageable A} (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma andp_dup {A}{agA: ageable A}: forall P: pred A, P && P = P.

Lemma andp_left1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}{agA: ageable A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma derives_trans {A}`{ageable A}:
    forall P Q R: pred A, P |-- Q -> Q |-- R -> P |-- R.

Lemma exp_right:
  forall {B A: Type}{agA: ageable A}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}{agA: ageable A}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma and1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A} `{ageable A} : forall X P,
  X |-- P --> TT.

Lemma FFrule {A} `{ageable A} : forall X P,
  X |-- FF --> P.

Lemma distribution {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma imp_andp_adjoint {A} `{ageable A} : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma box_e0 {A} `{ageable A}: forall (M: modality) Q,
            reflexive _ M -> box M Q  |-- Q.
Arguments box_e0 [A] _ _ _ _ _ _.

Lemma boxy_i {A} `{ageable A}:
  forall (Q: pred A) (M: modality),
    reflexive _ M ->
    (forall w w', M w w' -> Q w -> Q w') ->
    boxy M Q.

Lemma box_diamond {A} `{ageable A} : forall M (P Q:pred A),
  (diamond M P) |-- Q <-> P |-- (box M Q).

Lemma ruleNec {A} `{ageable A} : forall M (P:pred A),
  derives TT P ->
  derives TT (box M P).

Lemma axiomK {A} `{ageable A}: forall M (P Q:pred A),
  (box M (P --> Q)) |-- (box M P --> box M Q).

Lemma box_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  box M P |-- box M Q.

Lemma diamond_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  diamond M P |-- diamond M Q.

Lemma box_refl_trans {A} `{ageable A}: forall (m:modality) p,
  reflexive _ m ->
  transitive _ m ->
  box m (box m p) = box m p.

Lemma box_and {A} `{ageable A}: forall R (P Q:pred A),
  box R (P && Q) = box R P && box R Q.

Lemma box_all {A} `{ageable A} : forall B R (F:B -> pred A),
  box R (allp F) = ALL x:B, box R (F x).

Lemma box_ex {A} `{ageable A} : forall B R (F:B->pred A),
  EX x:B, box R (F x) |-- box R (exp F).

Lemma box_or {A} `{ageable A} : forall R (P Q:pred A),
   box R P || box R Q |-- box R (P || Q).

Lemma diamond_or {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P || Q) = diamond R P || diamond R Q.

Lemma diamond_ex {A} `{ageable A} : forall B R (F:B -> pred A),
  diamond R (exp F) = EX x:B, diamond R (F x).

Lemma diamond_and {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P && Q) |-- diamond R P && diamond R Q.

Lemma diamond_all {A} `{ageable A} : forall B R (F:B->pred A),
  diamond R (allp F) |-- ALL x:B, diamond R (F x).

Lemma later_age {A} `{ageable A} : forall P,
  |>P = box ageM P.

Lemma now_later {A} `{ageable A} : forall P,
  P |-- |>P.

Lemma now_later2 {A} `{ageable A} : forall G P,
  G |-- P ->
  G |-- |>P.

Lemma goedel_loeb {A} `{ageable A} : forall (P Q:pred A),
  Q && |>P |-- P ->
  Q |-- P.

Lemma loeb {A} `{ageable A} : forall (P:pred A),
     |>P |-- P    ->     TT |-- P.

Lemma later_commute_dia {A} `{ageable A} : forall M (P:pred A),
  diamond M (|> P) |-- |> (diamond M P).

Lemma later_commute {A} `{ageable A} : forall M (P:pred A),
  box M (|>P) = |>(box M P).

Lemma later_and {A} `{ageable A} : forall P Q,
  |>(P && Q) = |>P && |> Q.

Lemma later_or {A} `{ageable A} : forall (P Q:pred A),
  |>(P || Q) = |>P || |>Q.

Lemma later_ex {A} `{ageable A} : forall B (F:B->pred A),
  B ->
  |>(exp F) = EX x:B, |>(F x).

Lemma later_ex'' {A} `{ageable A} : forall B (F:B->pred A),
  |>(exp F) |-- (EX x:B, |>(F x)) || |> FF.

Lemma later_imp {A} `{ageable A} : forall P Q,
  |>(P --> Q) = |>P --> |>Q.

Lemma TT_boxy {A} `{ageable A} : forall M,
  boxy M TT.

Lemma positive_boxy {A} `{ageable A} : forall P Q M,
  boxy M P ->
  P |-- Q ->
  P |-- box M Q.

Lemma forallI {A} `{ageable A} : forall A G X,
  (forall x:A, G |-- X x) ->
  G |-- allp X.

Lemma TT_and {A} `{ageable A} : forall P,
  TT && P = P.

Lemma andp_comm {A} `{ageable A} : forall P Q,
  P && Q = Q && P.

Lemma andp_assoc {A} `{ageable A} : forall P Q R,
  (P && Q) && R = P && (Q && R).

Lemma ex_and : forall {A} `{ageable A} B (P:B->pred A) Q,
  (exp P) && Q = EX x:B, P x && Q.

Lemma FF_and : forall {A} `{ageable A} (P:pred A),
  FF && P = FF.

Lemma boxy_e {A} `{H : ageable A}: forall (M: modality) P,  boxy M P ->
           forall w w', app_mode M w w' -> P w -> P w'.

Lemma boxy_andp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P && Q).

Hint Resolve @boxy_andp.

Lemma boxy_disjunction {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Hint Resolve @boxy_disjunction.

Lemma boxy_exp {A} `{agA : ageable A}:
    forall (M: modality) T (P: T -> pred A),
     reflexive _ (app_mode M) ->
     (forall x, boxy M (P x)) -> boxy M (exp P).

Hint Resolve @boxy_exp.

Lemma boxy_prop {A} `{H : ageable A}:  forall (M: modality) P, reflexive _ (app_mode M) -> boxy M (prop P).

Lemma boxy_TT {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M TT.

Lemma boxy_FF {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M FF.

Hint Resolve @boxy_TT.
Hint Resolve @boxy_FF.

Lemma TT_i  {A} `{ageable A}: forall w: A,  app_pred TT w.

Hint Resolve @TT_i.

Lemma prop_andp_left {A}{agA: ageable A}: forall (P: Prop) Q R, (P -> Q |-- R) -> !!P && Q |-- R.

Lemma prop_andp_right {A}{agA: ageable A}: forall (P: Prop) Q R, P -> Q |-- R -> Q |-- !!P && R.

Lemma prop_true_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_false_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A),
   ~P -> !! P && Q = FF.

Lemma prop_andp_e {A} `{ageable A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A} `{ageable A}:  forall P Q (w:A), P /\ app_pred Q w -> (!! P && Q) w.

Lemma later_derives {A} `{agA : ageable A}: forall {P Q}, (P |-- Q) -> (|> P |-- |> Q).

Lemma boxy_allp {A} `{agA : ageable A}:
  forall (M: modality) (B: Type) F,
     reflexive _ (app_mode M) ->
     (forall (x:B), boxy M (F x)) -> boxy M (allp F).
Hint Resolve @boxy_allp.

Lemma later_allp {A} `{agA : ageable A}:
       forall B P, |> (allp P) = allp (fun x:B => |> (P x)).

Lemma later_prop {A} `{agA : ageable A}:
       forall P: Prop, |> (prop P) |-- prop P || |> FF.

Lemma box_derives {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->  box M P |-- box M Q.

Lemma allp_derives:
       forall {A: Type} `{agA: ageable A} (B: Type) (P Q: B -> pred A),
               (forall x:B, P x |-- Q x) -> (allp P |-- allp Q).

Lemma forall_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (ALL x : B, P x) <--> (ALL x: B, Q x) .

Lemma exists_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (EX x : B, P x) <--> (EX x: B, Q x) .

Lemma imp_pred_ext  {A} `{agA : ageable A}: forall B B' P Q,
       (B <--> B') && (B --> (P <--> Q))
 |-- (B --> P) <-->  (B' --> Q).

Lemma derives_refl {A: Type} `{ageable A}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma andp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma orp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P || Q |-- P' || Q'.

Lemma exp_derives {A} `{HA : ageable A}:
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma box_ext {A} `{agA : ageable A}: forall (M: modality) P Q,
    box M (P <--> Q) |--  box M P <--> box M Q.

Lemma andp_pred_ext {A} `{agA : ageable A}: forall P Q P' Q',
       (P <--> P') && (Q <--> Q') |--  (P && Q) <--> (P' && Q').

Program Definition exactly {A} `{ageable A} (x: A) : pred A := necR x.

Lemma derives_TT {A} `{ageable A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma FF_derives {A} `{ageable A}: forall P, FF |-- P.
Hint Immediate @FF_derives.

Lemma necR_level' {A} `{H : ageable A}: forall {w w': A}, necR w w' ->
       @necR _ ag_nat (level w) (level w').

Lemma derives_imp {A} `{agA : ageable A}:
  forall P Q w, (P |-- Q) -> (P --> Q) w.

Lemma exp_andp1 {A} `{ageable A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_andp2 {A} `{HA: ageable A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma exp_imp_left {A} `{agA : ageable A}:  forall B (p: B -> pred A) q,
     (exp p --> q)%pred = allp (fun x => p x --> q)%pred.

Lemma app_ext  {A: Type} `{ageable A} : forall (F G: A -> Prop) p1 p2 w,
         (F w = G w) ->
         app_pred (exist (hereditary age) F p1) w = app_pred (exist (hereditary age) G p2) w.

Lemma imp_derives {A} `{agA : ageable A}:
  forall P P' Q Q',
    P' |-- P ->
    Q |-- Q' ->
    P --> Q |-- P' --> Q'.

Lemma imp_lem0  {A} `{agA : ageable A}:  forall P st, (TT --> P) st -> P st.

Lemma conjoin_hyp0  {A} `{H : ageable A}:
      forall (P Q: pred A) w,  P w -> (P --> Q) w -> (TT --> Q) w.

Lemma conjoin_hyp1 {A} `{agA : ageable A}: forall (P Q R: pred A)  w,
            P w -> (P&&Q --> R) w -> (Q --> R) w.

Lemma derives_e {A: Type} `{agA : ageable A}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Ltac slurp :=
 apply imp_lem0;
  match goal with |-  app_pred (_ --> _)  ?st =>
        repeat match goal with
                   | H: app_pred ?P st |- app_pred (?b --> ?c) st =>
                       (apply (@conjoin_hyp0 _ _ P c st H) ||
                        (apply (@conjoin_hyp1 _ _ P b c st H)));
                       clear H
                   end;
        try (revert st; apply derives_e)
  end.

Lemma test_slurp {A} `{agA : ageable A} :  forall  (P Q R S : pred A) w ,
        (P && (Q && R) --> S) w -> P w -> Q w -> R w -> S w.

Lemma later_andp {A} `{H : ageable A}:
  forall P Q, |> (P && Q) = |>P && |>Q.

Lemma True_andp_eq {A}`{ageable A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma distrib_orp_andp {A}{agA: ageable A}:
   forall P Q R, (P||Q)&&R = (P&&R)||(Q&&R).

Lemma allp_right {B A: Type}{agA: ageable A}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}{agA: ageable A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma later_imp2 {A}{agA: ageable A}: forall P Q: pred A,
                 |> (P <--> Q) = |> P <--> |> Q. *)



Module Type KNOT_INPUT__COCONTRAVARIANT_HERED_T_OTH_REL.

  Import CoContraVariantBiFunctor.

  Parameter F : functor.



  Parameter other : Type.



  Parameter Rel : forall A B, F A B -> F A B -> Prop.



  Parameter Rel_fmap : forall A B C D (f:A->B) (s:C->D) x y,

    Rel A D x y ->

    Rel B C (fmap F f s x) (fmap F f s y).

  Axiom Rel_refl : forall A B x, Rel A B x x.

  Axiom Rel_trans : forall A B x y z,

    Rel A B x y -> Rel A B y z -> Rel A B x z.



  Parameter ORel : other -> other -> Prop.

  Axiom ORel_refl : reflexive other ORel.

  Axiom ORel_trans : transitive other ORel.



  Parameter T:Type.

  Parameter T_bot:T.



  Parameter T_rel : T -> T -> Prop.

  Parameter T_rel_bot : forall x, T_rel T_bot x.

  Parameter T_rel_refl : forall x, T_rel x x.

  Parameter T_rel_trans : transitive T T_rel.



End KNOT_INPUT__COCONTRAVARIANT_HERED_T_OTH_REL.



Module Type KNOT__COCONTRAVARIANT_HERED_T_OTH_REL.

  Import CoContraVariantBiFunctor.

  Declare Module KI: KNOT_INPUT__COCONTRAVARIANT_HERED_T_OTH_REL.

  Import KI.



  Parameter knot:Type.

  Parameter ageable_knot : ageable knot.

  Existing Instance ageable_knot.



  Parameter hered : (knot * other -> T) -> Prop.

  Definition predicate := { p:knot * other -> T | hered p }.



  Parameter squash : (nat * F predicate predicate) -> knot.

  Parameter unsquash : knot -> (nat * F predicate predicate).



  Parameter approx : nat -> predicate -> predicate.



  Axiom squash_unsquash : forall k:knot, squash (unsquash k) = k.

  Axiom unsquash_squash : forall (n:nat) (f:F predicate predicate),

    unsquash (squash (n,f)) = (n, fmap F (approx n) (approx n) f).



  Axiom approx_spec : forall n p ko,

    proj1_sig (approx n p) ko =

     if (le_gt_dec n (level (fst ko))) then T_bot else proj1_sig p ko.



  Definition knot_rel (k1 k2:knot) :=

    let (n,f) := unsquash k1 in

    let (n',f') := unsquash k2 in

    n = n' /\ Rel predicate predicate f f'.



  Axiom knot_age1 : forall k:knot,

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



  Axiom knot_level : forall k:knot,

    level k = fst (unsquash k).



  Axiom hered_spec : forall p,

    hered p =

    (forall k k' k'' o o',

      clos_refl_trans _ age k k' ->

      knot_rel  k' k'' ->

      ORel o o' ->

      T_rel (p (k,o)) (p (k'',o'))).



End KNOT__COCONTRAVARIANT_HERED_T_OTH_REL.



Module Type KNOT_INPUT__COVARIANT_HERED_PROP_OTH_REL.



  Import CovariantFunctor.

  Parameter F : functor.



  Parameter other : Type.



  Parameter Rel : forall A, F A -> F A -> Prop.

  Parameter Rel_fmap : forall A B (f:A->B) x y,

    Rel A x y -> Rel B (fmap F f x) (fmap F f y).



  Parameter Rel_unfmap : forall A B (f:A->B) x y,

    Rel B (fmap F f x) y ->

      exists y', Rel A x y' /\ fmap F f y' = y.



  Axiom Rel_refl : forall A x, Rel A x x.

  Axiom Rel_trans : forall A x y z,

    Rel A x y -> Rel A y z -> Rel A x z.



  Parameter ORel : other -> other -> Prop.

  Axiom ORel_refl : reflexive other ORel.

  Axiom ORel_trans : transitive other ORel.



End KNOT_INPUT__COVARIANT_HERED_PROP_OTH_REL.



Module Type KNOT__COVARIANT_HERED_PROP_OTH_REL.

  Import CovariantFunctor.

  Declare Module KI : KNOT_INPUT__COVARIANT_HERED_PROP_OTH_REL.

  Import KI.



  Parameter knot : Type.



  Parameter ageable_knot : ageable knot.

  Existing Instance ageable_knot.



  Definition ag_knot_other := ag_prod knot other ageable_knot.

  Existing Instance ag_knot_other.



  Parameter expandM : @modality (knot * other) ag_knot_other.

  Definition assert := { p:pred (knot * other) | boxy expandM p }.



  Parameter squash : (nat * F assert) -> knot.

  Parameter unsquash : knot -> (nat * F assert).



  Parameter approx : nat -> assert -> assert.

  Axiom approx_spec : forall n p k,

    proj1_sig (approx n p) k = (level (fst k) < n /\ proj1_sig p k).



  Axiom squash_unsquash : forall x,

    squash (unsquash x) = x.

  Axiom unsquash_squash : forall n x',

    unsquash (squash (n,x')) = (n, fmap F (approx n) x').



  Definition knot_rel (k1 k2:knot) :=

    let (n,f) := unsquash k1 in

    let (n',f') := unsquash k2 in

    n = n' /\ Rel assert f f'.



  Axiom expandM_spec : forall k k' o o',

    expandM (k,o) (k',o') = (knot_rel k k' /\ ORel o o').



  Axiom expandM_refl : reflexive _ expandM.

  Axiom expandM_trans : transitive _ expandM.

  Hint Resolve expandM_refl expandM_trans.



  Axiom knot_level : forall (k:knot),

    level k = fst (unsquash k).



  Axiom knot_age1 : forall (k:knot),

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



End KNOT__COVARIANT_HERED_PROP_OTH_REL.



Module Type KNOT_INPUT__COVARIANT_HERED_PROP_OTH.



  Import CovariantFunctor.

  Parameter F : functor.

  Parameter other : Type.



End KNOT_INPUT__COVARIANT_HERED_PROP_OTH.



Module Type KNOT__COVARIANT_HERED_PROP_OTH.

  Declare Module KI : KNOT_INPUT__COVARIANT_HERED_PROP_OTH.

  Import CovariantFunctor.

  Import CovariantFunctorLemmas.

  Import KI.



  Parameter knot : Type.



  Parameter ageable_knot : ageable knot.

  Existing Instance ageable_knot.



  Definition ag_knot_other := ag_prod knot other ageable_knot.

  Existing Instance ag_knot_other.



  Parameter squash : (nat * F (pred (knot * other))) -> knot.

  Parameter unsquash : knot -> (nat * F (pred (knot * other))).



  Parameter approx : nat -> pred (knot * other) -> pred (knot * other).

  Axiom approx_spec : forall n p k,

    approx n p k = (level (fst k) < n /\ p k).



  Axiom squash_unsquash : forall x,

    squash (unsquash x) = x.

  Axiom unsquash_squash : forall n x',

    unsquash (squash (n,x')) = (n, fmap F (approx n) x').



  Axiom knot_level : forall (k:knot),

    level k = fst (unsquash k).



  Axiom knot_age1 : forall (k:knot),

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



End KNOT__COVARIANT_HERED_PROP_OTH.



Module Type KNOT_INPUT__COVARIANT_HERED_PROP.



  Import CovariantFunctor.

  Parameter F : functor.



End KNOT_INPUT__COVARIANT_HERED_PROP.



Module Type KNOT__COVARIANT_HERED_PROP.

  Declare Module KI : KNOT_INPUT__COVARIANT_HERED_PROP.

  Import CovariantFunctor.

  Import CovariantFunctorLemmas.

  Import KI.



  Parameter knot : Type.



  Parameter ageable_knot : ageable knot.

  Existing Instance ageable_knot.



  Parameter squash : (nat * F (pred knot)) -> knot.

  Parameter unsquash : knot -> (nat * F (pred knot)).



  Parameter approx : nat -> pred knot -> pred knot.

  Axiom approx_spec : forall n p k,

    approx n p k = (level k < n /\ p k).



  Axiom squash_unsquash : forall x,

    squash (unsquash x) = x.

  Axiom unsquash_squash : forall n x',

    unsquash (squash (n,x')) = (n, fmap F (approx n) x').



  Axiom knot_level : forall (k:knot),

    level k = fst (unsquash k).



  Axiom knot_age1 : forall (k:knot),

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



End KNOT__COVARIANT_HERED_PROP.



Module Type KNOT_INPUT__MIXVARIANT_HERED_PROP.



  Import MixVariantFunctor.

  Parameter F : functor.



End KNOT_INPUT__MIXVARIANT_HERED_PROP.



Module Type KNOT__MIXVARIANT_HERED_PROP.

  Declare Module KI : KNOT_INPUT__MIXVARIANT_HERED_PROP.

  Import MixVariantFunctor.

  Import MixVariantFunctorLemmas.

  Import KI.



  Parameter knot : Type.



  Parameter ageable_knot : ageable knot.

  Existing Instance ageable_knot.



  Definition predicate := pred knot.

  Parameter squash : (nat * F (pred knot)) -> knot.

  Parameter unsquash : knot -> (nat * F (pred knot)).



  Parameter approx : nat -> pred knot -> pred knot.

  Axiom approx_spec : forall n p k,

    approx n p k = (level k < n /\ p k).



  Axiom squash_unsquash : forall x,

    squash (unsquash x) = x.

  Axiom unsquash_squash : forall n x',

    unsquash (squash (n,x')) = (n, fmap F (approx n) (approx n) x').



  Axiom knot_level : forall (k:knot),

    level k = fst (unsquash k).



  Axiom knot_age1 : forall (k:knot),

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



End KNOT__MIXVARIANT_HERED_PROP.



Module Knot_CoContraVariantHeredTOthRel

  (KI': KNOT_INPUT__COCONTRAVARIANT_HERED_T_OTH_REL):

  KNOT__COCONTRAVARIANT_HERED_T_OTH_REL with Module KI:=KI'.



  Import MixVariantFunctor.

  Import MixVariantFunctorLemmas.

  Import GeneralFunctorGenerator.

  Module KI:=KI'.



  Module Input.



    Definition F : functor :=

      CoContraVariantBiFunctor_MixVariantFunctor KI.F.



    Definition other := KI.other.



    Definition Rel (A: Type): F A -> F A -> Prop :=

      KI.Rel A A.



    Definition Rel_fmap (A B: Type): forall (f1: A->B) (f2:B->A) x y,

      Rel A x y ->

      Rel B (fmap F f1 f2 x) (fmap F f1 f2 y) :=

    KI.Rel_fmap A B B A.



    Definition Rel_refl (A: Type): forall x, Rel A x x :=

      KI.Rel_refl A A.



    Definition Rel_trans (A: Type): forall x y z,

      Rel A x y -> Rel A y z -> Rel A x z :=

      KI.Rel_trans A A.



    Definition ORel: other -> other -> Prop := KI.ORel.

    Definition ORel_refl := KI.ORel_refl.

    Definition ORel_trans := KI.ORel_trans.



    Definition T := KI.T.

    Definition T_bot := KI.T_bot.



    Definition T_rel := KI.T_rel.

    Definition T_rel_bot := KI.T_rel_bot.

    Definition T_rel_refl := KI.T_rel_refl.

    Definition T_rel_trans := KI.T_rel_trans.



  End Input.



  Module K := knot_full_variant.Knot_MixVariantHeredTOthRel(Input).



  Definition knot: Type := K.knot.

  Definition ageable_knot: ageable knot := K.ageable_knot.

  Existing Instance ageable_knot.



  Definition hered : (knot * KI.other -> KI.T) -> Prop := K.hered.

  Definition predicate := { p:knot * KI.other -> KI.T | hered p }.



  Definition squash : (nat * KI.F predicate predicate) -> knot := K.squash.

  Definition unsquash : knot -> (nat * KI.F predicate predicate) := K.unsquash.



  Definition approx : nat -> predicate -> predicate := K.approx.



  Definition squash_unsquash : forall k:knot, squash (unsquash k) = k

    := K.squash_unsquash.

  Definition unsquash_squash : forall (n:nat) (f:KI.F predicate predicate),

    unsquash (squash (n,f)) =

     (n, CoContraVariantBiFunctor.fmap KI.F (approx n) (approx n) f)

    := K.unsquash_squash.



  Definition approx_spec : forall n p ko,

    proj1_sig (approx n p) ko =

     if (le_gt_dec n (level (fst ko))) then KI.T_bot else proj1_sig p ko

    := K.approx_spec.



  Definition knot_rel (k1 k2:knot) :=

    let (n,f) := unsquash k1 in

    let (n',f') := unsquash k2 in

    n = n' /\ KI.Rel predicate predicate f f'.



  Definition knot_age1 : forall k:knot,

    age1 k =

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end

    := K.knot_age1.



  Definition knot_level : forall k:knot,

    level k = fst (unsquash k)

    := K.knot_level.



  Definition hered_spec : forall p,

    hered p =

    (forall k k' k'' o o',

      clos_refl_trans _ age k k' ->

      knot_rel  k' k'' ->

      KI.ORel o o' ->

      KI.T_rel (p (k,o)) (p (k'',o')))

    := K.hered_spec.



End Knot_CoContraVariantHeredTOthRel.



Module KnotLemmas_CoContraVariantHeredTOthRel

  (K: KNOT__COCONTRAVARIANT_HERED_T_OTH_REL).

  Import CoContraVariantBiFunctor.

  Import K.KI.

  Import K.



  Lemma unsquash_inj : forall k1 k2,

    unsquash k1 = unsquash k2 ->

    k1 = k2.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_inj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_inj [k1 k2] _.



  Lemma squash_surj : forall k, exists n, exists Fp,

    squash (n, Fp) = k.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.squash_surj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.



  Lemma unsquash_approx : forall k n Fp,

    unsquash k = (n, Fp) ->

    Fp = fmap F (approx n) (approx n) Fp.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_approx

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_approx [k n Fp] _.



  Lemma pred_ext : forall (p1 p2:predicate),

    (forall x, proj1_sig p1 x = proj1_sig p2 x) ->

    p1 = p2.

  Proof.

    intros.

    destruct p1 as [p1 Hp1]; destruct p2 as [p2 Hp2].

    simpl in *.

    assert (p1 = p2).

    extensionality x; auto.

    subst p2.

    replace Hp2 with Hp1; auto.

    apply proof_irr.

  Qed.



  Lemma approx_approx1 : forall m n,

    approx n = approx n oo approx (m+n).

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx1

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _ _ _

          pred_ext approx_spec)),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



  Lemma approx_approx2 : forall m n,

    approx n = approx (m+n) oo approx n.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx2

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _ _ _

          pred_ext approx_spec)),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



End KnotLemmas_CoContraVariantHeredTOthRel.



Module Knot_CovariantHeredPropOthRel (KI':KNOT_INPUT__COVARIANT_HERED_PROP_OTH_REL)

  : KNOT__COVARIANT_HERED_PROP_OTH_REL with Module KI:=KI'.



  Module KI:=KI'.



  Module Input.

    Import MixVariantFunctor.

    Import MixVariantFunctorLemmas.

    Import GeneralFunctorGenerator.

    Definition F: functor :=

      GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor KI.F.



    Definition other := KI.other.



    Definition Rel (A: Type): F A -> F A -> Prop := KI.Rel A.



    Definition Rel_fmap (A B: Type): forall (f1: A->B) (f2:B->A) x y,

      Rel A x y ->

      Rel B (fmap F f1 f2 x) (fmap F f1 f2 y) :=

    fun f s => KI.Rel_fmap A B f.



    Definition Rel_refl (A: Type): forall x, Rel A x x := KI.Rel_refl A.



    Definition Rel_trans (A: Type): forall x y z,

      Rel A x y -> Rel A y z -> Rel A x z

      := KI.Rel_trans A.



    Definition ORel := KI.ORel.

    Definition ORel_refl := KI.ORel_refl.

    Definition ORel_trans := KI.ORel_trans.



    Definition T := Prop.

    Definition T_bot := False.



    Definition T_rel (x y:T) := x -> y.

    Lemma T_rel_bot : forall x, T_rel T_bot x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_refl : forall x, T_rel x x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_trans : transitive T T_rel.

    Proof.

      repeat intro; intuition.

    Qed.

  End Input.



  Import CovariantFunctor.

  Import CovariantFunctorLemmas.



  Module K0 := knot_full_variant.Knot_MixVariantHeredTOthRel(Input).

  Module KL0 := knot_full_variant.KnotLemmas_MixVariantHeredTOthRel(K0).



  Existing Instance K0.ageable_knot.



  Definition ag_knot_other := ag_prod K0.knot KI.other K0.ageable_knot.

  Existing Instance ag_knot_other.



  Definition expandR : relation (K0.knot * KI.other) :=

    fun x y => K0.knot_rel (fst x) (fst y) /\ KI.ORel (snd x) (snd y).



  Lemma valid_rel_expandR : valid_rel expandR.

  Proof.

    split; hnf; intros.

    destruct H0.

    destruct x as [xk xo].

    destruct y as [yk yo].

    simpl in *.

    hnf in H.

    hnf in H0.

    simpl in H.

    rewrite K0.knot_age1 in H.

    destruct (K0.unsquash yk) as [n f] eqn:?H; intros.

    destruct n; try discriminate.

    inv H.

    destruct z as [zk zo].

    simpl in H0.

    destruct (K0.unsquash zk) as [n0 f0] eqn:?H; intros.

    destruct H0; subst n0.

    simpl in H1.

    exists (K0.squash (n,f0),zo).

    split; simpl; auto.

    hnf; repeat rewrite K0.unsquash_squash; split; auto.

    apply Input.Rel_fmap; auto.

    hnf; simpl.

    rewrite K0.knot_age1.

    rewrite H.

    auto.



    destruct x as [xk xo].

    destruct y as [yk yo].

    destruct H.

    simpl in *.

    hnf in H0; simpl in H0.

    rewrite K0.knot_age1 in H0.

    destruct z as [zk zo]; simpl in *.

    destruct (K0.unsquash zk) as [n f] eqn:?H; intros.

    destruct n; try discriminate.

    inv H0.

    hnf in H.

    rewrite K0.unsquash_squash in H.

    destruct (K0.unsquash xk) as [n0 f0] eqn:?H; intros.

    destruct H; subst.

    destruct (KI.Rel_unfmap _ _ _ _ _ H3)

      as [z [? ?]].

    subst f0.

    exists (K0.squash (S n0,z),xo).

    hnf; simpl.

    rewrite K0.knot_age1.

    rewrite K0.unsquash_squash.

    f_equal.

    f_equal.

    apply KL0.unsquash_inj.

    rewrite K0.unsquash_squash.

    rewrite H0.

    f_equal.

    rewrite MixVariantFunctorLemmas.fmap_app.

    change (S n0) with (1 + n0).

    rewrite <- KL0.approx_approx1.

    auto.

    split; simpl; auto.

    hnf.

    rewrite H2.

    rewrite K0.unsquash_squash; split; auto.

    hnf.

    rewrite (KL0.unsquash_approx H2).

    apply KI.Rel_fmap; auto.

  Qed.



  Definition expandM : @modality (K0.knot * KI.other) ag_knot_other

    := exist _ expandR valid_rel_expandR.



  Lemma expandM_refl : reflexive _ expandM.

  Proof.

    repeat intro.

    split.

    hnf.

    destruct (K0.unsquash (fst x)); split; auto.

    apply KI.Rel_refl.

    apply KI.ORel_refl.

  Qed.



  Lemma expandM_trans : transitive _ expandM.

  Proof.

    simpl; unfold expandR;

      repeat intro; intuition.

    unfold K0.knot_rel in *.

    destruct (K0.unsquash (fst x)).

    destruct (K0.unsquash (fst y)).

    destruct (K0.unsquash (fst z)).

    intuition.

    eapply KI.Rel_trans; eauto.

    eapply KI.ORel_trans; eauto.

  Qed.



  Hint Resolve expandM_refl expandM_trans.



  Definition assert := { p:pred (K0.knot * KI.other) | boxy expandM p }.



  Module Output <: knot_full_variant.KNOT_FULL_OUTPUT with Module KI := Input.

    Module KI := Input.

    Module K0 := K0.

    Definition predicate: Type := assert.



    Lemma boxy_expand_spec: forall (p: pred (K0.knot*KI.other)),

      boxy expandM p <->

      (fun p: pred (K0.knot*KI.other) =>

         forall x y, expandR x y -> proj1_sig p x -> proj1_sig p y) p.

    Proof.

      intros.

      split; intro.

      + pose proof boxy_e _ _ H; auto.

      + pose proof boxy_i _ expandM expandM_refl H; auto.

    Qed.



    Lemma hered_hereditary : forall (p:K0.knot*KI.other -> Prop),

      K0.hered p <->

      (hereditary age p /\ (fun p:K0.knot*KI.other -> Prop => forall x y, expandR x y -> p x -> p y) p).

    Proof.

      intros; split; repeat intro.

      split; repeat intro.

      rewrite K0.hered_spec in H.

      revert H1.

      destruct a; destruct a'.

      hnf in H0; simpl in H0.

      case_eq (age1 k); intros;

        rewrite H1 in H0; try discriminate.

      inv H0.

      apply (H k k0 k0 o0 o0).

      apply rt_step; auto.

      hnf.

      destruct (K0.unsquash k0); split; auto.

      apply Input.Rel_refl.

      apply Input.ORel_refl.

      auto.



      rewrite K0.hered_spec in H.

      destruct H0.

      destruct x as [xk xo].

      destruct y as [yk yo].

      simpl in *.

      revert H1; apply (H xk xk yk xo yo); auto.



      rewrite K0.hered_spec; repeat intro.

      destruct H.

      cut (p (k',o)).

      apply H4.

      split; auto.

      revert H3.

      clear -H0 H; induction H0.

      apply H; hnf; simpl; auto.

      hnf in H0.

      rewrite H0; auto.

      auto.

      intuition.

    Qed.



    Definition pkp: bijection predicate K0.predicate :=

      (bij_sym (sig_sig_iff_bij hered_hereditary)) ooo

      (bij_sym (sig_sigsig_bij (hereditary age) _)) ooo

      (sig_sig_iff_bij boxy_expand_spec).



  End Output.



  Module K := knot_full_variant.KnotFull(Input)(Output).



  Definition knot := K.knot.

  Definition ageable_knot := K.ageable_knot.

  Definition squash: (nat * KI.F assert) -> knot := K.squash.

  Definition unsquash: knot -> (nat * KI.F assert) := K.unsquash.

  Definition approx: nat -> assert -> assert := K.approx.



  Lemma approx_spec : forall n p k,

    proj1_sig (approx n p) k = (level (fst k) < n /\ proj1_sig p k).

  Proof.

    intros.

    apply prop_ext.

    pose proof K.approx_spec n p k.

    match goal with

    | _: ?A = _ |- ?B <-> _ => change B with A

    end.

    rewrite H.

    match goal with

    | |- (if le_gt_dec _ ?A then _ else _) <-> (?B < _ /\ _) =>

            change B with A; remember A as TMP eqn:HHH; clear HHH

    end.

    destruct (le_gt_dec n TMP).

    + split.

      - intros [].

      - intros [? ?]; omega.

    + split.

      - intros; split; [omega | auto].

      - intros [? ?]; auto.

  Qed.



  Definition squash_unsquash := K.squash_unsquash.



  Definition unsquash_squash := K.unsquash_squash.



  Definition knot_age1 := K.knot_age1.



  Definition knot_level := K.knot_level.



  Definition knot_rel (k1 k2:knot) :=

    let (n,f) := unsquash k1 in

    let (n',f') := unsquash k2 in

    n = n' /\ KI.Rel assert f f'.



  Lemma expandM_spec : forall k k' o o',

    expandM (k,o) (k',o') = (K.knot_rel k k' /\ KI.ORel o o').

  Proof.

    intros.

    rewrite K.knot_rel_spec.

    apply prop_ext; intuition.

    + destruct H; simpl in *; auto.

    + destruct H; auto.

    + split; simpl; auto.

  Qed.



End Knot_CovariantHeredPropOthRel.



Module KnotLemmas_CovariantHeredPropOthRel

  (K: KNOT__COVARIANT_HERED_PROP_OTH_REL).



  Import CovariantFunctor.

  Import K.KI.

  Import K.



  Lemma unsquash_inj : forall k1 k2,

    unsquash k1 = unsquash k2 ->

    k1 = k2.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_inj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_inj [k1 k2] _.



  Lemma squash_surj : forall k, exists n, exists Fp,

    squash (n, Fp) = k.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.squash_surj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.



  Lemma unsquash_approx : forall k n Fp,

    unsquash k = (n, Fp) ->

    Fp = fmap KI.F (approx n) Fp.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_approx

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_approx [k n Fp] _.



  Lemma pred_ext : forall (p1 p2: assert),

    (forall x, proj1_sig p1 x = proj1_sig p2 x) ->

    p1 = p2.

  Proof.

    intros.

    apply exist_ext'.

    apply pred_ext'.

    extensionality; auto.

  Qed.



  Lemma approx_spec': forall n p ko,

    proj1_sig (approx n p) ko =

    if (le_gt_dec n (level (fst ko))) then False else proj1_sig p ko.

  Proof.

    intros.

    rewrite approx_spec.

    apply prop_ext.

    destruct (le_gt_dec n (level (fst ko))).

    + split; [intros [? ?]; omega | intros []].

    + tauto.

  Qed.



  Lemma approx_approx1 : forall m n,

    approx n = approx n oo approx (m+n).

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx1

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ assert

         (@proj1_sig _ _) _ pred_ext approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



  Lemma approx_approx2 : forall m n,

    approx n = approx (m+n) oo approx n.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx2

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ assert

         (@proj1_sig _ _) _ pred_ext approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



End KnotLemmas_CovariantHeredPropOthRel.



Module Knot_CovariantHeredPropOth (KI':KNOT_INPUT__COVARIANT_HERED_PROP_OTH)

  : KNOT__COVARIANT_HERED_PROP_OTH with Module KI:=KI'.



  Import MixVariantFunctor.

  Import MixVariantFunctorLemmas.

  Import GeneralFunctorGenerator.

  Module KI:=KI'.



  Module Input.

    Definition F: functor := CovariantFunctor_MixVariantFunctor KI.F.

    Definition other := KI.other.



    Definition Rel A := @eq (F A).

    Lemma Rel_fmap : forall A B (f:A -> B) (s:B -> A) x y,

      Rel A x y ->

      Rel B (fmap F f s x) (fmap F f s y).

    Proof.

      unfold Rel; intuition; subst; auto.

    Qed.



    Lemma Rel_refl : forall A x, Rel A x x.

    Proof.

      intros; hnf; auto.

    Qed.



    Lemma Rel_trans : forall A x y z,

      Rel A x y -> Rel A y z -> Rel A x z.

    Proof.

      unfold Rel; intuition congruence.

    Qed.



    Definition ORel := @eq other.

    Lemma ORel_refl : reflexive other ORel.

    Proof.

      hnf; unfold ORel; auto.

    Qed.

    Lemma ORel_trans : transitive other ORel.

    Proof.

      hnf; unfold ORel; intros; congruence.

    Qed.



    Definition T := Prop.

    Definition T_bot := False.



    Definition T_rel (x y:T) := x -> y.

    Lemma T_rel_bot : forall x, T_rel T_bot x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_refl : forall x, T_rel x x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_trans : transitive _ T_rel.

    Proof.

      hnf; unfold T_rel; intuition.

    Qed.

  End Input.



  Module K0 := knot_full_variant.Knot_MixVariantHeredTOthRel(Input).

  Module KL0 := knot_full_variant.KnotLemmas_MixVariantHeredTOthRel(K0).

  Existing Instance K0.ageable_knot.

  Definition ag_knot_other := ag_prod K0.knot KI.other K0.ageable_knot.

  Existing Instance ag_knot_other.



  Lemma hered_hereditary : forall (p: K0.knot*KI.other -> Prop),

    K0.hered p <-> hereditary age p.

  Proof.

    intros; split; repeat intro.

    rewrite K0.hered_spec in H.

    hnf in H0.

    simpl in H0.

    destruct a; destruct a'.

    simpl in *.

    case_eq (age1 k); intros.

    rewrite H2 in H0.

    inv H0.

    specialize ( H k k0 k0).

    specialize ( H o0 o0).

    spec H.

    apply rt_step; auto.

    spec H.

    hnf.

    destruct (K0.unsquash k0); split; auto.

    hnf; auto.

    apply H; auto.

    hnf; auto.

    rewrite H2 in H0; discriminate.



    rewrite K0.hered_spec; intros.

    assert (k' = k'').

    apply KL0.unsquash_inj.

    hnf in H1.

    hnf in H2; subst o'.

    destruct (K0.unsquash k').

    destruct (K0.unsquash k'').

    destruct H1; hnf in H2.

    subst; auto.

    subst k''.

    hnf in H.



    hnf.

    hnf in H2; subst.

    clear H1.

    induction H0.

    eapply H; eauto.

    hnf; simpl.

    hnf in H0.

    rewrite H0; auto.

    auto.

    eauto.

  Qed.



  Module Output <: knot_full_variant.KNOT_FULL_OUTPUT with Module KI := Input.

    Module KI := Input.

    Module K0 := K0.



    Definition predicate : Type := pred (K0.knot * KI.other).

    Definition pkp: bijection predicate K0.predicate :=

      bij_sym (sig_sig_iff_bij hered_hereditary).

  End Output.



  Module K := knot_full_variant.KnotFull(Input)(Output).



  Definition knot := K.knot.

  Definition ageable_knot := K.ageable_knot.

  Definition squash: (nat * KI.F (pred (knot*KI.other))) -> knot := K.squash.

  Definition unsquash: knot -> (nat * KI.F (pred (knot*KI.other))) := K.unsquash.

  Definition approx: nat -> pred (knot*KI.other) -> pred (knot*KI.other) :=

    K.approx.



  Lemma approx_spec : forall n p k,

    approx n p k = (level (fst k) < n /\ p k).

  Proof.

    intros.

    apply prop_ext.

    pose proof K.approx_spec n p k.

    match goal with

    | _: ?A = _ |- ?B <-> _ => change B with A

    end.

    rewrite H.

    match goal with

    | |- (if le_gt_dec _ ?A then _ else _) <-> (?B < _ /\ _) =>

            change B with A; remember A as TMP eqn:HHH; clear HHH

    end.

    destruct (le_gt_dec n TMP).

    + split.

      - intros [].

      - intros [? ?]; omega.

    + split.

      - intros; split; [omega | auto].

      - intros [? ?]; auto.

  Qed.



  Definition squash_unsquash := K.squash_unsquash.



  Definition unsquash_squash := K.unsquash_squash.



  Definition knot_age1 := K.knot_age1.



  Definition knot_level := K.knot_level.



End Knot_CovariantHeredPropOth.



Module KnotLemmas_CovariantHeredPropOth (K: KNOT__COVARIANT_HERED_PROP_OTH).



  Import CovariantFunctor.

  Import K.KI.

  Import K.



  Lemma unsquash_inj : forall k1 k2,

    unsquash k1 = unsquash k2 ->

    k1 = k2.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_inj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_inj [k1 k2] _.



  Lemma squash_surj : forall k, exists n, exists Fp,

    squash (n, Fp) = k.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.squash_surj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.



  Lemma unsquash_approx : forall k n Fp,

    unsquash k = (n, Fp) ->

    Fp = fmap KI.F (approx n) Fp.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_approx

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_approx [k n Fp] _.



  Lemma pred_ext : forall (p1 p2: pred (knot * other)),

    (forall x, p1 x = p2 x) ->

    p1 = p2.

  Proof.

    intros.

    apply pred_ext'.

    extensionality; auto.

  Qed.



  Lemma approx_spec': forall n p ko,

    (approx n p) ko =

    if (le_gt_dec n (level (fst ko))) then False else proj1_sig p ko.

  Proof.

    intros.

    rewrite approx_spec.

    apply prop_ext.

    destruct (le_gt_dec n (level (fst ko))).

    + split; [intros [? ?]; omega | intros []].

    + tauto.

  Qed.



  Lemma approx_approx1 : forall m n,

    approx n = approx n oo approx (m+n).

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx1

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         (@proj1_sig _ _) _ pred_ext approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



  Lemma approx_approx2 : forall m n,

    approx n = approx (m+n) oo approx n.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx2

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         (@proj1_sig _ _) _ pred_ext approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



End KnotLemmas_CovariantHeredPropOth.



Module Knot_CovariantHeredProp (KI':KNOT_INPUT__COVARIANT_HERED_PROP)

  : KNOT__COVARIANT_HERED_PROP with Module KI:=KI'.



  Import MixVariantFunctor.

  Import MixVariantFunctorLemmas.

  Import GeneralFunctorGenerator.

  Module KI:=KI'.



  Module Input.

    Definition F: functor := CovariantFunctor_MixVariantFunctor KI.F.

    Definition other := unit.



    Definition Rel A := @eq (F A).

    Lemma Rel_fmap : forall A B (f:A -> B) (s:B -> A) x y,

      Rel A x y ->

      Rel B (fmap F f s x) (fmap F f s y).

    Proof.

      unfold Rel; intuition; subst; auto.

    Qed.



    Lemma Rel_refl : forall A x, Rel A x x.

    Proof.

      intros; hnf; auto.

    Qed.



    Lemma Rel_trans : forall A x y z,

      Rel A x y -> Rel A y z -> Rel A x z.

    Proof.

      unfold Rel; intuition congruence.

    Qed.



    Definition ORel := @eq other.

    Lemma ORel_refl : reflexive other ORel.

    Proof.

      hnf; unfold ORel; auto.

    Qed.

    Lemma ORel_trans : transitive other ORel.

    Proof.

      hnf; unfold ORel; intros; congruence.

    Qed.



    Definition T := Prop.

    Definition T_bot := False.



    Definition T_rel (x y:T) := x -> y.

    Lemma T_rel_bot : forall x, T_rel T_bot x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_refl : forall x, T_rel x x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_trans : transitive _ T_rel.

    Proof.

      hnf; unfold T_rel; intuition.

    Qed.

  End Input.



  Module K0 := knot_full_variant.Knot_MixVariantHeredTOthRel(Input).

  Module KL0 := knot_full_variant.KnotLemmas_MixVariantHeredTOthRel(K0).

  Existing Instance K0.ageable_knot.



  Lemma hered_hereditary : forall (p: K0.knot -> Prop),

    K0.hered (fun ko => p (fst ko)) <-> hereditary age p.

  Proof.

    intros; split; repeat intro.

    rewrite K0.hered_spec in H.

    hnf in H0.

    simpl in H0.

    specialize ( H a a' a').

    specialize ( H tt tt).

    spec H.

    apply rt_step; auto.

    spec H.

    hnf.

    destruct (K0.unsquash a'); split; auto.

    hnf; auto.

    apply H; auto.

    hnf; auto.



    rewrite K0.hered_spec; intros.

    assert (k' = k'').

    apply KL0.unsquash_inj.

    hnf in H1.

    destruct (K0.unsquash k').

    destruct (K0.unsquash k'').

    destruct H1; hnf in H3.

    subst; auto.

    subst k''.

    hnf in H.



    hnf.

    simpl.

    clear -H H0.

    induction H0; auto.

    eapply H; eauto.

  Qed.



  Module Output <: knot_full_variant.KNOT_FULL_OUTPUT with Module KI := Input.

    Module KI := Input.

    Module K0 := K0.



    Definition predicate : Type := pred K0.knot.



    Definition pkp: bijection predicate K0.predicate :=

      bij_sym

        ((sig_sig_iff_bij hered_hereditary) ooo

         (bij_sig

           (bij_sym (func_bij (unit_unit1 K0.knot) (bij_refl Prop)))

           K0.hered)).

  End Output.



  Module K := knot_full_variant.KnotFull(Input)(Output).



  Definition knot := K.knot.

  Definition ageable_knot := K.ageable_knot.

  Definition squash: (nat * KI.F (pred knot)) -> knot := K.squash.

  Definition unsquash: knot -> (nat * KI.F (pred knot)) := K.unsquash.

  Definition approx: nat -> pred knot -> pred knot := K.approx.



  Lemma approx_spec : forall n p k,

    approx n p k = (level k < n /\ p k).

  Proof.

    intros.

    apply prop_ext.

    pose proof K.approx_spec n p (k, tt).

    match goal with

    | _: ?A = _ |- ?B <-> _ => change B with A

    end.

    rewrite H.

    match goal with

    | |- (if le_gt_dec _ ?A then _ else _) <-> (?B < _ /\ _) =>

            change B with A; remember A as TMP eqn:HHH; clear HHH

    end.

    destruct (le_gt_dec n TMP).

    + split.

      - intros [].

      - intros [? ?]; omega.

    + split.

      - intros; split; [omega | auto].

      - intros [? ?]; auto.

  Qed.



  Definition squash_unsquash := K.squash_unsquash.



  Definition unsquash_squash := K.unsquash_squash.



  Definition knot_age1 := K.knot_age1.



  Definition knot_level := K.knot_level.



End Knot_CovariantHeredProp.



Module KnotLemmas_CovariantHeredProp (K: KNOT__COVARIANT_HERED_PROP).



  Import CovariantFunctor.

  Import K.KI.

  Import K.



  Lemma unsquash_inj : forall k1 k2,

    unsquash k1 = unsquash k2 ->

    k1 = k2.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_inj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_inj [k1 k2] _.



  Lemma squash_surj : forall k, exists n, exists Fp,

    squash (n, Fp) = k.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.squash_surj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.



  Lemma unsquash_approx : forall k n Fp,

    unsquash k = (n, Fp) ->

    Fp = fmap KI.F (approx n) Fp.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_approx

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_approx [k n Fp] _.



  Lemma pred_ext : forall (p1 p2: pred knot),

    (forall x, p1 x = p2 x) ->

    p1 = p2.

  Proof.

    intros.

    apply pred_ext'.

    extensionality; auto.

  Qed.



  Lemma pred_ext': forall (p1 p2: pred knot),

    (forall x: knot * unit,

      ((fun (p: knot -> Prop) ko => p (fst ko)) oo app_pred) p1 x =

      ((fun (p: knot -> Prop) ko => p (fst ko)) oo app_pred) p2 x) ->

    p1 = p2.

  Proof.

    intros.

    unfold compose in H; simpl in H.

    apply pred_ext'.

    extensionality; apply (H (x, tt)).

  Qed.



  Lemma approx_spec': forall n p k,

    ((fun (p: knot -> Prop) ko => p (@fst _ unit ko)) oo app_pred) (approx n p) k =

    if (le_gt_dec n (level (fst k))) then False else

    ((fun (p: knot -> Prop) ko => p (@fst _ unit ko)) oo app_pred) p k.

  Proof.

    intros.

    unfold compose; simpl.

    rewrite approx_spec.

    apply prop_ext.

    destruct (le_gt_dec n (level (fst k))).

    + split; [intros [? ?]; omega | intros []].

    + tauto.

  Qed.



  Lemma approx_approx1 : forall m n,

    approx n = approx n oo approx (m+n).

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx1

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         _ _ pred_ext' approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



  Lemma approx_approx2 : forall m n,

    approx n = approx (m+n) oo approx n.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx2

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         _ _ pred_ext' approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



End KnotLemmas_CovariantHeredProp.



Module Knot_MixVariantHeredProp (KI':KNOT_INPUT__MIXVARIANT_HERED_PROP)

  : KNOT__MIXVARIANT_HERED_PROP with Module KI:=KI'.



  Import MixVariantFunctor.

  Import MixVariantFunctorLemmas.

  Import GeneralFunctorGenerator.

  Module KI:=KI'.



  Module Input.

    Definition F: functor := KI.F.

    Definition other := unit.



    Definition Rel A := @eq (F A).

    Lemma Rel_fmap : forall A B (f:A -> B) (s:B -> A) x y,

      Rel A x y ->

      Rel B (fmap F f s x) (fmap F f s y).

    Proof.

      unfold Rel; intuition; subst; auto.

    Qed.



    Lemma Rel_refl : forall A x, Rel A x x.

    Proof.

      intros; hnf; auto.

    Qed.



    Lemma Rel_trans : forall A x y z,

      Rel A x y -> Rel A y z -> Rel A x z.

    Proof.

      unfold Rel; intuition congruence.

    Qed.



    Definition ORel := @eq other.

    Lemma ORel_refl : reflexive other ORel.

    Proof.

      hnf; unfold ORel; auto.

    Qed.

    Lemma ORel_trans : transitive other ORel.

    Proof.

      hnf; unfold ORel; intros; congruence.

    Qed.



    Definition T := Prop.

    Definition T_bot := False.



    Definition T_rel (x y:T) := x -> y.

    Lemma T_rel_bot : forall x, T_rel T_bot x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_refl : forall x, T_rel x x.

    Proof.

      compute; intuition.

    Qed.



    Lemma T_rel_trans : transitive _ T_rel.

    Proof.

      hnf; unfold T_rel; intuition.

    Qed.

  End Input.



  Module K0 := knot_full_variant.Knot_MixVariantHeredTOthRel(Input).

  Module KL0 := knot_full_variant.KnotLemmas_MixVariantHeredTOthRel(K0).

  Existing Instance K0.ageable_knot.



  Lemma hered_hereditary : forall (p: K0.knot -> Prop),

    K0.hered (fun ko => p (fst ko)) <-> hereditary age p.

  Proof.

    intros; split; repeat intro.

    rewrite K0.hered_spec in H.

    hnf in H0.

    simpl in H0.

    specialize ( H a a' a').

    specialize ( H tt tt).

    spec H.

    apply rt_step; auto.

    spec H.

    hnf.

    destruct (K0.unsquash a'); split; auto.

    hnf; auto.

    apply H; auto.

    hnf; auto.



    rewrite K0.hered_spec; intros.

    assert (k' = k'').

    apply KL0.unsquash_inj.

    hnf in H1.

    destruct (K0.unsquash k').

    destruct (K0.unsquash k'').

    destruct H1; hnf in H3.

    subst; auto.

    subst k''.

    hnf in H.



    hnf.

    simpl.

    clear -H H0.

    induction H0; auto.

    eapply H; eauto.

  Qed.



  Module Output <: knot_full_variant.KNOT_FULL_OUTPUT with Module KI := Input.

    Module KI := Input.

    Module K0 := K0.



    Definition predicate : Type := pred K0.knot.



    Definition pkp: bijection predicate K0.predicate :=

      bij_sym

        ((sig_sig_iff_bij hered_hereditary) ooo

         (bij_sig

           (bij_sym (func_bij (unit_unit1 K0.knot) (bij_refl Prop)))

           K0.hered)).

  End Output.



  Module K := knot_full_variant.KnotFull(Input)(Output).



  Definition knot := K.knot.

  Definition ageable_knot := K.ageable_knot.

  Definition predicate := pred knot.

  Definition squash: (nat * KI.F (pred knot)) -> knot := K.squash.

  Definition unsquash: knot -> (nat * KI.F (pred knot)) := K.unsquash.

  Definition approx: nat -> pred knot -> pred knot := K.approx.



  Lemma approx_spec : forall n p k,

    approx n p k = (level k < n /\ p k).

  Proof.

    intros.

    apply prop_ext.

    pose proof K.approx_spec n p (k, tt).

    match goal with

    | _: ?A = _ |- ?B <-> _ => change B with A

    end.

    rewrite H.

    match goal with

    | |- (if le_gt_dec _ ?A then _ else _) <-> (?B < _ /\ _) =>

            change B with A; remember A as TMP eqn:HHH; clear HHH

    end.

    destruct (le_gt_dec n TMP).

    + split.

      - intros [].

      - intros [? ?]; omega.

    + split.

      - intros; split; [omega | auto].

      - intros [? ?]; auto.

  Qed.



  Definition squash_unsquash := K.squash_unsquash.



  Definition unsquash_squash := K.unsquash_squash.



  Definition knot_age1 := K.knot_age1.



  Definition knot_level := K.knot_level.



End Knot_MixVariantHeredProp.



Module KnotLemmas_MixVariantHeredProp (K': KNOT__MIXVARIANT_HERED_PROP).



  Import MixVariantFunctor.

  Module K := K'.

  Import K.KI.

  Import K.



  Lemma unsquash_inj : forall k1 k2,

    unsquash k1 = unsquash k2 ->

    k1 = k2.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_inj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_inj [k1 k2] _.



  Lemma squash_surj : forall k, exists n, exists Fp,

    squash (n, Fp) = k.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.squash_surj

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.



  Lemma unsquash_approx : forall k n Fp,

    unsquash k = (n, Fp) ->

    Fp = fmap KI.F (approx n) (approx n) Fp.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas1.unsquash_approx

       (knot_full_variant.KnotLemmas1.Build_Input _ _ _ _ _ squash_unsquash unsquash_squash)),

     (knot_full_variant.KnotLemmas1.Proof).

  Qed.

  Arguments unsquash_approx [k n Fp] _.



  Lemma pred_ext : forall (p1 p2: pred knot),

    (forall x, p1 x = p2 x) ->

    p1 = p2.

  Proof.

    intros.

    apply pred_ext'.

    extensionality; auto.

  Qed.



  Lemma pred_ext': forall (p1 p2: pred knot),

    (forall x: knot * unit,

      ((fun (p: knot -> Prop) ko => p (fst ko)) oo app_pred) p1 x =

      ((fun (p: knot -> Prop) ko => p (fst ko)) oo app_pred) p2 x) ->

    p1 = p2.

  Proof.

    intros.

    unfold compose in H; simpl in H.

    apply pred_ext'.

    extensionality; apply (H (x, tt)).

  Qed.



  Lemma approx_spec': forall n p k,

    ((fun (p: knot -> Prop) ko => p (@fst _ unit ko)) oo app_pred) (approx n p) k =

    if (le_gt_dec n (level (fst k))) then False else

    ((fun (p: knot -> Prop) ko => p (@fst _ unit ko)) oo app_pred) p k.

  Proof.

    intros.

    unfold compose; simpl.

    rewrite approx_spec.

    apply prop_ext.

    destruct (le_gt_dec n (level (fst k))).

    + split; [intros [? ?]; omega | intros []].

    + tauto.

  Qed.



  Lemma approx_approx1 : forall m n,

    approx n = approx n oo approx (m+n).

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx1

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         _ _ pred_ext' approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



  Lemma approx_approx2 : forall m n,

    approx n = approx (m+n) oo approx n.

  Proof.

    apply

     (@knot_full_variant.KnotLemmas2.approx_approx2

       (knot_full_variant.KnotLemmas2.Build_Input _ _ _ _ _ _

         _ _ pred_ext' approx_spec')),

     (knot_full_variant.KnotLemmas2.Proof).

  Qed.



End KnotLemmas_MixVariantHeredProp.



