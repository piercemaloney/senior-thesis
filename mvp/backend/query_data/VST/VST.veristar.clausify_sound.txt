Load loadpath.
Require Import Coq.ZArith.ZArith Coq.Lists.List Coq.Sorting.Permutation
               Coq.Logic.Classical.
Require Import VST.msl.Axioms VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.list_denote
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)
(* veristar.list_denote:
Load loadpath.
Require Import Coq.Lists.List Permutation veric.Coqlib2.
Require Import VST.msl.Axioms msl.sepalg VST.msl.predicates_sa msl.base
               veristar.variables veristar.datatypes
               veristar.clauses veristar.basic veristar.compare.

Section ListDenote.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Fixpoint list_denote l : T :=
  match l with nil => b | x :: l' => g (f x) (list_denote l')
  end.

Local Notation "'listd'" := (list_denote).

Lemma listd_fold_right l :
  listd l = fold_right (fun x y  => g (f x) y) b l.

End ListDenote.

Notation "'listd'" := (list_denote).

Lemma listd_app {A T} f g (b : T) (l l' : list A) :
  listd f g b (l ++ l') =
  listd f g (listd f g b l') l.

Section ListDenoteLems.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Lemma listd_nil : listd f g b nil = b.

Lemma listd_cons a l :
  listd f g b (a :: l) = g (f a) (listd f g b l).

Lemma listd_map h l (Hgh_eq : forall a b', g (f (h a)) b' = g (f a) b') :
  listd f g b (map h l) = listd f g b l.

Lemma listd_filter h l (H : forall a b', false=h a -> g (f a) b' = b') :
  listd f g b (filter h l) = listd f g b l.

Lemma listd_flat_map h l (H : forall a b', g (f a) b' = listd f g b' (h a)) :
  listd f g b l = listd f g b (flat_map h l).

Lemma listd_compose h1 h2 l
  (Hh1 : forall l, listd f g b l = listd f g b (h1 l))
  (Hh2 : forall l, listd f g b l = listd f g b (h2 l)) :
  listd f g b l = listd f g b ((h1 oo h2) l).

End ListDenoteLems.

Section ListDenoteAS.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma fgAS b' (t t' : T) : g t (g t' b') = g t' (g t b').

Lemma listdAS a l : listd f g (g (f a) b) l = g (f a) (listd f g b l).

Lemma listd_AS_unit un l (un_unit : forall x, g x un = x) :
  listd f g b l = g b (listd f g un l).

Lemma listd_perm l l' (Hperm : Permutation l l') :
  listd f g b l = listd f g b l'.

End ListDenoteAS.

Section ListDenoteConj.
Context {A : Type}.
Variables (f : A -> Prop) (g : Prop -> Prop -> Prop) (b : Prop).
Variable (gconj : forall x y, g x y -> y).

Lemma listd_conj a l : listd f g b (a :: l) -> listd f g b l.

Context {B : Type}.
Variables (h : A -> pred B) (k : pred B -> pred B -> pred B) (b0 : pred B).
Variable (hconj : forall x y b, k x y b -> y b).

Lemma listd_conjP a l : forall b, listd h k b0 (a :: l) b -> listd h k b0 l b.

End ListDenoteConj.

Section ListDenoteProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).

Lemma andS (x y : Prop) : and x y = and y x.

Lemma andA x y z : and x (and y z) = and (and x y) z.

Lemma orS (x y : Prop) : or x y = or y x.

Lemma orA x y z : or x (or y z) = or (or x y) z.

Lemma listd_conj_and a l : listd f and True (a :: l) -> listd f and True l.

Lemma listd_unfold_and l : listd f and b l = (listd f and True l /\ b).

Lemma listd_unfold_or l : listd f or b l = (listd f or False l \/ b).

Lemma listd_flat_map_and h l
  (H : forall a b', and (f a) b' -> listd f and b' (h a)) :
  listd f and b l -> listd f and b (flat_map h l).

Lemma listd_In_prop l : (forall a, In a l -> f a) -> listd f and True l.

Lemma listd_In_inv_prop a l : listd f and True l -> In a l -> f a.

End ListDenoteProp.

Section ListDenoteProp1.
Context {A : Type}.
Variables (f : A -> Prop).

Lemma listd_unfold_app_and b l l' :
  listd f and b (l ++ l') = (listd f and True l /\ listd f and b l').

Lemma listd_unfold_app_or b l l' :
  listd f or b (l ++ l') = (listd f or False l \/ listd f or b l').

End ListDenoteProp1.

Lemma union_com {A} : forall (P Q: pred A), ((P || Q) = (Q || P))%pred.

Lemma union_assoc {A} : forall (P Q R: pred A),
  ((P || Q) || R = P || (Q || R))%pred.

Notation "'inter'" := (@andp _).
Notation "'un'" := (@orp _).

Section ListDenotePred.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).

Lemma listd_conj_inter a l :
  forall b', listd f inter TT (a :: l) b' -> listd f inter TT l b'.

Lemma listd_unfold_inter l : listd f inter b l = (listd f inter TT l && b)%pred.

Lemma listd_unfold_un l : listd f un b l = (listd f un FF l || b)%pred.

Lemma listd_flat_map_inter h l s
  (H : forall a b', inter (f a) b' s -> listd f inter b' (h a) s) :
  listd f inter b l s -> listd f inter b (flat_map h l) s.

Lemma listd_In_pred l s :
  (forall a, In a l -> f a s) -> b s -> listd f inter b l s.

Lemma listd_In_inv_pred a l s : listd f inter TT l s -> In a l -> f a s.

Lemma listd_In_pred_un l s :
  (exists a, In a l /\ f a s) \/ b s -> listd f un b l s.

Lemma listd_In_inv_pred_un l s :
  listd f un b l s -> (exists a, In a l /\ f a s) \/ b s.

Lemma listd_map_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> g (h a) s) :
  listd f inter TT l s -> listd g inter TT (map h l) s.

Lemma listd_omapl_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> match h a with Some a' => g a' s | None => True end) :
  listd f inter TT l s -> listd g inter TT (omapl h l) s.

Lemma listd_foldr_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h a x) s) :
  f c0 s -> listd f inter TT l s -> f (fold_right h c0 l) s.

Lemma listd_foldl_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h x a) s) :
  f c0 s -> listd f inter TT l s -> f (fold_left h l c0) s.

Lemma listd_filter_pred h l s :
  listd f inter TT l s -> listd f inter TT (filter h l) s.

Lemma listd_partition_pred h l xs ys s (H : partition h l = (xs, ys)) :
  listd f inter TT l s ->
    listd f inter TT xs s /\ listd f inter TT ys s.

End ListDenotePred.

Section ListDenotePred1.
Context {A B : Type}.
Variables (f : A -> pred B).

Lemma listd_unfold_app_inter b l l' :
  listd f inter b (l ++ l') = (listd f inter TT l && listd f inter b l')%pred.

Lemma listd_unfold_app_un b l l' :
  listd f un b (l ++ l') = (listd f un FF l || listd f un b l')%pred.

End ListDenotePred1.

Section ListDenoteInsert.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma listd_insert cmp a l :
  listd f g b (insert cmp a l) = g (f a) (listd f g b l).

Lemma listd_sort cmp l : listd f g b (rsort cmp l) = listd f g b l.

End ListDenoteInsert.

Section ListDenoteInsertUniq.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y ->
  forall b, g (f x) (g (f y) b) = g (f y) b).

Lemma listd_insert_uniq a l :
  listd f g b (insert_uniq cmp a l) = g (f a) (list_denote f g b l).

Lemma listd_sort_uniq l : listd f g b (rsort_uniq cmp l) = listd f g b l.

End ListDenoteInsertUniq.

Section ListDenoteSortProp.
Context {A : Type}.
Variable (f : A -> Prop) (b : Prop).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_and cmp a l :
  listd f and b (insert cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_and cmp l :
  listd f and b (rsort cmp l) = listd f and b l.

Lemma listd_insert_or cmp a l :
  listd f or b (insert cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_or cmp l :
  listd f or b (rsort cmp l) = listd f or b l.

End ListDenoteSortProp.

Section ListDenoteInsertPred.

Context {A B : Type}.
Variable (f : A -> pred B) (b : pred B).

Lemma interS (x y : pred B) : inter x y = inter y x.

Lemma interA (x y z : pred B) : inter x (inter y z) = inter (inter x y) z.

Lemma unS (x y : pred B) : un x y = un y x.

Lemma unA (x y z : pred B) : un x (un y z) = un (un x y) z.

Variables (JB: Join B) (PB: Perm_alg B)(SB: Sep_alg B).

Lemma sepconS (x y : pred B) : sepcon x y = sepcon y x.

Lemma sepconA (x y z : pred B) :
  sepcon x (sepcon y z) = sepcon (sepcon x y) z.

Local Hint Resolve interS interA unS unA sepconS sepconA.

Lemma listd_insert_inter cmp a l :
  listd f inter b (insert cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_inter cmp l :
  listd f inter b (rsort cmp l) = listd f inter b l.

Lemma listd_insert_un cmp a l :
  listd f un b (insert cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_un cmp l : listd f un b (rsort cmp l) = listd f un b l.

Lemma listd_insert_sepcon cmp a l :
  listd f sepcon b (insert cmp a l) = sepcon (f a) (listd f sepcon b l).

Lemma listd_sort_sepcon cmp l :
  listd f sepcon b (rsort cmp l) = listd f sepcon b l.

End ListDenoteInsertPred.

Section ListDenoteSortUniqProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_uniq_and a l :
  listd f and b (insert_uniq cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_uniq_and l :
  listd f and b (rsort_uniq cmp l) = listd f and b l.

Lemma listd_insert_uniq_or a l :
  listd f or b (insert_uniq cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_uniq_or l :
  listd f or b (rsort_uniq cmp l) = listd f or b l.

End ListDenoteSortUniqProp.

Section ListDenoteSortUniqPreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve (@interS B) (@interA B) (@unS B) (@unA B).

Lemma listd_insert_uniq_inter a l :
  listd f inter b (insert_uniq cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_uniq_inter l :
  listd f inter b (rsort_uniq cmp l) = listd f inter b l.

Lemma listd_insert_uniq_un a l :
  listd f un b (insert_uniq cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_uniq_un l :
  listd f un b (rsort_uniq cmp l) = listd f un b l.

End ListDenoteSortUniqPreds.

Section ListDenoteMergePreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Lemma listd_merge_inter l1 l2 s :
  listd f inter TT l1 s -> listd f inter TT l2 s ->
  listd f inter TT (merge cmp l1 l2) s.

Lemma merge_nil l : merge cmp l nil = l.

Lemma merge_nil' l : merge cmp nil l = l.

Lemma merge_cons_unfold a1 a2 l1 l2 :
  merge cmp (a1 :: l1) (a2 :: l2) = match cmp a1 a2 with
                                      | Eq => a1 :: merge cmp l1 l2
                                      | Gt => a1 :: merge cmp l1 (a2 :: l2)
                                      | Lt => a2 :: merge cmp (a1 :: l1) l2
                                    end.

Lemma merge_elems a l1 l2 : In a l1 \/ In a l2 <-> In a (merge cmp l1 l2).

Lemma listd_merge_inter' l1 l2 s :
  listd f inter TT (merge cmp l1 l2) s ->
  listd f inter TT l1 s /\ listd f inter TT l2 s.

Lemma listd_merge_un1 l1 l2 s :
  listd f un FF l1 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un2 l1 l2 s :
  listd f un FF l2 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un' l1 l2 s :
  listd f un FF (merge cmp l1 l2) s ->
  listd f un FF l1 s \/ listd f un FF l2 s.

End ListDenoteMergePreds.

Section ListDenoteSeparate.
Context {X Y B : Type}.
Variables (f : X -> pred B) (g : Y -> pred B) (b : pred B) (l1 : list X)
          (l2 : list Y).

Lemma listd_separate :
  listd f inter (listd g inter b l2) l1 =
  andp (listd f inter TT l1) (andp (listd g inter TT l2) b).

Lemma listd_prop:
listd f inter b l1 =
(andp (listd f inter TT l1) b).

End ListDenoteSeparate.

Section SetDenote.

Definition setd {T} (f : M.elt -> T) (g : T -> T -> T) (b : T) (s : M.t) :=
  listd f g b (M.elements s).

End SetDenote.

Section SetLems.
Variables (s : M.t) (x y : clause).

Lemma setd_add_In_refl : M.In x (M.add x s).

Lemma setd_add_In_refl_elems : In x (M.elements (M.add x s)).

Lemma setd_add_In : x = y \/ M.In y s -> M.In y (M.add x s).

Lemma setd_add_In_inv : M.In y (M.add x s) -> x = y \/ M.In y s.

Lemma elements_In {s0} : In y (M.elements s0) = M.In y s0.

Lemma empty_set_elems : M.elements M.empty = nil. 

Lemma setd_add_In_inv_elems :
  In y (M.elements (M.add x s)) -> x = y \/ M.In y s.

Lemma setd_rem_In_inv : M.In y (M.remove x s) -> M.In y s.

Lemma setd_rem_In_inv_elems :
  In y (M.elements (M.remove x s)) -> In y (M.elements s).

End SetLems.

Section SetDenoteLems.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : M.t -> clause -> M.t).
Variable (H : forall c cls s, setd f inter b cls s -> f c s ->
                              setd f inter b (h cls c) s).

Lemma setd_fold_left cls0 l s :
  listd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (fold_left h l cls0) s.

Lemma setd_fold cls0 l s :
  setd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (M.fold (Basics.flip h) cls0 l) s.

Lemma setd_un cls1 cls2 s :
  setd f inter TT cls1 s -> setd f inter TT cls2 s ->
  setd f inter TT (M.union cls1 cls2) s.

Lemma setd_base_separate:
   forall {A} f (b: pred A) cls,
    setd f inter b cls = andp b (setd f inter (@TT A) cls).

Lemma setd_add c cls s :
  setd f inter b cls s -> f c s -> setd f inter b (M.add c cls) s.

Lemma setd_remove c cls s :
  setd f inter TT cls s -> setd f inter TT (M.remove c cls) s.

Lemma setd_empty_set s : setd f inter TT M.empty s.

Require Import MSetFacts Logic.

Lemma setd_filter bf cls s :
  setd f inter TT cls s -> setd f inter TT (M.filter bf cls) s.

End SetDenoteLems.

Section FoldLem.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).

Lemma listd_fold_left cls0 l s
  (H : forall c cls, listd f inter b cls s -> f c s ->
                     listd f inter b (h cls c) s) :
  listd f inter b l s -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLem.

Section FoldLemWeak.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).
Variable (H : forall c cls s, listd f inter b cls s -> (forall s, f c s) ->
                              listd f inter b (h cls c) s).

Lemma listd_fold_left_wk cls0 l s :
  listd (fun c => forall s, f c s) and True l -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLemWeak.

Lemma listd_inter_map: forall {A B C} (l:list A) (f:B -> C -> Prop) h s,
(forall x, In x l -> f (h x) s) ->
inter
  (listd f inter TT (map h l)) TT s.

Lemma listd_inter_rev: forall {A B} (f: A -> B -> Prop) l,
  listd f inter TT (rev  l) = listd f inter TT l.

Lemma orp_FF {A} (p : pred A) : orp p FF = p.

Lemma listd_un_rev:
  forall {A B} (f: A -> B -> Prop) l, listd f un FF (rev  l) = listd f un FF l.

Lemma setd_filter_pred:
  forall {B: Type} (f: M.elt -> pred B) (h: M.elt -> bool) (s: M.t), *)
               veristar.model_type veristar.model veristar.spred_lemmas
               veristar.basic.

Module Type CLAUSIFY_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM VeriStarLogic.

Axiom cnf_correct : forall (e : entailment),
  entailment_denote e =
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.

End CLAUSIFY_SOUND.

Module Clausify_Sound (VSM : VERISTAR_MODEL) : CLAUSIFY_SOUND
  with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic.

Module SPredLems := SPredLemmas VSM. Import SPredLems.

Lemma clausify_single_purepos : forall purea,
  listd pure_atom_denote (@andp state) TT (purea :: nil) =
  clause_denote (mkPureClause nil (order_eqv_pure_atom purea :: nil)).
Proof.
intros; extensionality s; simpl.
apply prop_ext; split; intros.
destruct H. left.
rewrite <- pure_atom_denote_order_eqv_pure_atom. auto.
destruct H. auto.
repeat split; auto.
rewrite <- pure_atom_denote_order_eqv_pure_atom in H. auto.
destruct H.
Qed.

Lemma clausify_single_pureneg : forall purea,
  list_denote (neg oo pure_atom_denote) (@andp state) TT (purea :: nil) =
  clause_denote (mkPureClause (order_eqv_pure_atom purea :: nil) nil).
Proof.
intros. extensionality s. simpl.
apply prop_ext; split; intros.
destruct H. destruct H0. destruct H.
rewrite <- pure_atom_denote_order_eqv_pure_atom in H0. auto.
repeat split; auto. unfold neg,compose. intro Contra.
destruct H.
rewrite <- pure_atom_denote_order_eqv_pure_atom.
split; auto.
Qed.

Lemma clausify_purepos : forall l : list pure_atom,
  list_denote pure_atom_denote (@andp state) TT l =
  list_denote clause_denote (@andp state) TT
    (map (fun a => mkPureClause nil (order_eqv_pure_atom a::nil)) l).
Proof.
intros. extensionality s.
induction l; simpl; apply prop_ext; split; intros; auto.
split. rewrite <- clausify_single_purepos. simpl.
destruct H as [H _]. repeat split; auto.
rewrite <- IHl.
destruct H as [_ H]. repeat split; auto.
destruct H. rewrite <- clausify_single_purepos in H. simpl in H.
destruct H. rewrite <- IHl in H0.
repeat split; auto.
Qed.

Lemma clausify_pureposP : forall (l : list pure_atom) P,
  list_denote pure_atom_denote (@andp state) P l =
  list_denote clause_denote (@andp state) P
    (map (fun a => mkPureClause nil (order_eqv_pure_atom a::nil)) l).
Proof.
intros. extensionality s.
induction l; simpl; apply prop_ext; split; intros; auto.
split. rewrite <- clausify_single_purepos. simpl.
destruct H as [H _]. repeat split; auto.
rewrite <- IHl.
destruct H as [_ H]. repeat split; auto.
destruct H. rewrite <- clausify_single_purepos in H. simpl in H.
destruct H. rewrite <- IHl in H0.
repeat split; auto.
Qed.

Lemma clausify_pureneg : forall l : list pure_atom,
  list_denote (neg oo pure_atom_denote) (@andp state) TT l =
  list_denote clause_denote (@andp state) TT
    (map (fun a => mkPureClause (order_eqv_pure_atom a::nil) nil) l).
Proof.
intros. extensionality s.
induction l; simpl; apply prop_ext; split; intros; auto.
split. rewrite <- clausify_single_pureneg. simpl.
destruct H as [H _]. split; auto.
rewrite <- IHl. simpl. destruct H; auto.
destruct H. rewrite <- clausify_single_pureneg in H.
destruct H. rewrite <- IHl in H0. split; auto.
Qed.

Lemma clausify_space : forall l : list space_atom,
  space_denote l = clause_denote (PosSpaceClause nil nil l).
Proof.
intros. extensionality s.
apply prop_ext; split; intros.
simpl in *; auto.
simpl in *. apply H; auto.
Qed.

Lemma pure_atom_list_neg2 : forall (l: list pure_atom) s,
  (~(list_denote pure_atom_denote (@orp state) FF l s)) =
  list_denote (neg oo pure_atom_denote) (@andp state) TT l s.
Proof.
intros. apply prop_ext; split; intros.
induction l; simpl in *; auto.
unfold neg,compose in * |-.
assert (~pure_atom_denote a s /\
        ~list_denote pure_atom_denote (@orp state) FF l s).
  clear IHl. firstorder.
  destruct H0; split; auto.
intro Contra. induction l; simpl in *; auto. apply H; auto.
destruct Contra; auto.
exfalso. destruct H. apply IHl; auto.
Qed.

Lemma mk_pureR_denote1: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pn_atom_denote inter P pnatoms s ->
  (listd pure_atom_denote inter P purepos s /\
    ~listd pure_atom_denote (@orp state) FF pureneg s).
Proof.
intros pnatoms.
induction pnatoms; intros.
  inversion H; subst. simpl. split. trivial.
  intros N. apply N.
destruct H0 as [HD TL].
  simpl in *.
  remember (mk_pureR pnatoms) as mkP. destruct mkP.
  destruct (IHpnatoms _ _ _ _ (eq_refl _) TL) as [IHP IHN]. clear IHpnatoms TL.
  destruct a. inversion H; subst. clear H.
    simpl. split; trivial.
    split. generalize (pure_atom_denote_order_eqv_pure_atom (Eqv e e0)) as H1; intro.
           unfold order_eqv_pure_atom in H1. rewrite <-H1.
           apply HD. apply IHP.
  inversion H; subst. clear H.
    simpl. split; trivial.
     intros N. destruct N. simpl in HD. apply HD.
         generalize (pure_atom_denote_order_eqv_pure_atom (Eqv e e0)) as H1; intro.
         unfold order_eqv_pure_atom in H1. rewrite <-H1 in H; auto.
         apply IHN. apply H.
Qed.

Lemma mk_pureR_denote2: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pure_atom_denote inter P purepos s ->
  ~ listd pure_atom_denote (@orp state) FF pureneg s ->
  listd pn_atom_denote inter P pnatoms s.
Proof.
intros pnatoms.
induction pnatoms; simpl; intros.
  inversion H; subst. trivial.
remember (mk_pureR pnatoms) as mkP. destruct mkP.
destruct a. inversion H; subst. clear H. simpl in *.
  destruct H0. split.
  generalize (pure_atom_denote_order_eqv_pure_atom (Eqv e e0)) as H2; intro.
    unfold order_eqv_pure_atom in H2. rewrite <-H2 in H; auto.
  eapply  IHpnatoms. reflexivity. assumption.
  apply H1.
inversion H; subst. clear H.
  rewrite pure_atom_list_neg2 in H1.
  simpl in *. destruct H1.
  split. unfold compose in H.
    generalize (pure_atom_denote_order_eqv_pure_atom (Eqv e e0)) as H2; intro.
    unfold order_eqv_pure_atom in H2. rewrite <-H2 in H; auto.
  eapply IHpnatoms; clear IHpnatoms. reflexivity. apply H0.
  rewrite pure_atom_list_neg2. apply H1.
Qed.

Lemma mk_pureR_denote: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pn_atom_denote inter P pnatoms s =
  (listd pure_atom_denote inter P purepos s /\
    ~listd pure_atom_denote (@orp state) FF pureneg s).
Proof.
intros.
apply prop_ext.
split; intros.
  eapply (mk_pureR_denote1 _ _ _ _ _ H H0).
destruct H0.
  eapply (mk_pureR_denote2 _ _ _ _ _ H H0 H1).
Qed.

Lemma mk_pureR_denote3: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pure_atom_denote inter P purepos s ->
  ~ listd pn_atom_denote inter P pnatoms s ->
  listd pure_atom_denote (@orp state) FF pureneg s.
Proof.
intros.
rewrite (mk_pureR_denote _ _ _ _ s H) in H1.
apply not_and_or in H1.
destruct H1.
apply Decidable.not_not; auto.
apply classic.
apply Decidable.not_not; auto.
apply classic.
Qed.

Lemma clausify_succ : forall pnatoms (purepos pureneg : list pure_atom)
  (space : list space_atom) (s : state)
  (Hyp: mk_pureR pnatoms = (purepos, pureneg)),
  (~assertion_denote (Assertion pnatoms space) s) =
  (clause_denote (NegSpaceClause purepos space pureneg) s).
Proof.
intros. simpl.
rewrite (@listd_unfold_inter _ state).
pattern (list_denote (neg oo pure_atom_denote) (@andp state)
  (space_denote space) pureneg).
rewrite (@listd_unfold_inter _ state).
pattern (list_denote pure_atom_denote (@andp state) (space_denote space) purepos).
rewrite (@listd_unfold_inter _ state).
apply prop_ext; split; intros.
destruct H0.
apply Decidable.not_and in H.
2: apply classic.
destruct H.
  eapply mk_pureR_denote3. apply Hyp. apply H0. apply H.
destruct (H H1).

intros N. destruct N.
  destruct (mk_pureR_denote1 _ _ _ _ s Hyp H0). clear H0.
  apply H3. apply H. split; assumption.
Qed.

Lemma clausify_succClassic : forall pnatoms (purepos pureneg : list pure_atom)
  (space : list space_atom) (s : state)
  (Hyp: mk_pureR pnatoms = (purepos, pureneg)),
   (assertion_denote (Assertion pnatoms space) s) =
  (~clause_denote (NegSpaceClause purepos space pureneg) s).
Proof.
intros. rewrite <- (clausify_succ pnatoms).
apply prop_ext; split; intros.
  intros N. apply (N H).
apply Decidable.not_not; auto.
 apply classic.
assumption.
Qed.

Lemma mk_pureL_denote: forall a s,
  clause_denote (mk_pureL a) s -> pn_atom_denote a s.
Proof.
intros.
destruct a; simpl in *.
  assert (T : TT s). trivial.
  assert (HH := H T). clear H T.
  remember (expr_cmp e e0) as b; destruct b; simpl in *.
    destruct HH. assumption. contradiction.
    destruct HH. apply var_eq_sym. apply H. contradiction.
    destruct HH. assumption. contradiction.
intros N. apply H. clear H.
  remember (expr_cmp e e0) as b; destruct b; simpl in *.
    split; trivial.
    split; trivial. apply var_eq_sym. assumption.
    split; trivial.
Qed.

Lemma mk_pureL_denoteInv: forall a s,
  pn_atom_denote a s -> clause_denote (mk_pureL a) s.
Proof.
intros.
destruct a; simpl in *. intros X. clear X.
  remember (expr_cmp e e0) as b; destruct b; simpl in *.
    left; trivial.
    left. apply var_eq_sym. assumption.
    left. trivial.
  intros HH. apply H. clear H.
  remember (expr_cmp e e0) as b; destruct b; simpl in *.
    destruct HH. assumption.
    destruct HH. apply var_eq_sym. apply H.
    destruct HH. assumption.
Qed.

Lemma mk_pureL_denoteEq: forall a,
  pn_atom_denote a = clause_denote (mk_pureL a).
Proof.
intros.
apply extensionality. intros s.
apply prop_ext; split; intros.
 apply mk_pureL_denoteInv. apply H.
  apply mk_pureL_denote. apply H.
Qed.

Lemma mk_pureL_clause_denote: forall pi P s,
  listd clause_denote inter P (map mk_pureL pi) s ->
  listd pn_atom_denote inter P pi s.
Proof.
intros pi.
induction pi; intros; simpl in *. trivial.
destruct H.
split. apply (mk_pureL_denote _ _ H).
apply IHpi. apply H0.
Qed.

Lemma mk_pureL_clause_denoteInv: forall pi P s,
  listd pn_atom_denote inter P pi s ->
  listd clause_denote inter P (map mk_pureL pi) s.
Proof.
intros pi.
induction pi; intros; simpl in *. trivial.
destruct H.
split. apply (mk_pureL_denoteInv _ _ H).
apply IHpi. apply H0.
Qed.

Lemma mk_pureL_clause_denoteEq:forall pi P,
  listd pn_atom_denote inter P pi =
  listd clause_denote inter P (map mk_pureL pi).
Proof.
intros.
apply extensionality. intros s.
apply prop_ext; split; intros.
 apply mk_pureL_clause_denoteInv. apply H.
  apply mk_pureL_clause_denote. apply H.
Qed.

Lemma listd_pure_atoms_heap_expand atms :
  listd pure_atom_denote inter emp atms |--
  listd pure_atom_denote inter TT atms.
Proof with simpl; auto.
induction atms... intros s [H1 H2]. split...
Qed.

Theorem cnf_correct1 : forall (e : entailment),
  entailment_denote e ->
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.
Proof.
intros.
destruct e. unfold entailment_denote.
intro.
unfold cnf in H0.
destruct a. destruct a0 as [pi' sigma'].
remember (mk_pureR pi') as mkR. destruct mkR as[purepos pureneg].
repeat rewrite listd_app in H0.
repeat rewrite (@listd_separate _ _ state) in H0.
destruct H0.
destruct H1. simpl in H1.
destruct H1. simpl in H1.
destruct sigma' as [|s0' sigma'].

destruct sigma as [|s0 sigma].
destruct H2. simpl in H2.
assert (H5 : assertion_denote (Assertion pi' nil) s).
  apply H. unfold assertion_denote; simpl.
  rewrite (@listd_unfold_inter _ state); split; auto.
  rewrite mk_pureL_clause_denoteEq; auto. apply H1; auto.
rewrite clausify_succClassic with (purepos:=purepos)(pureneg:=pureneg) in H5; auto.
apply H5; simpl in H5; simpl; intro H6. apply H2.
apply listd_pure_atoms_heap_expand; auto.
destruct H2.
assert (H11 := H1 H3). clear H1.
clear H3 H4.
apply eq_sym in HeqmkR.
rewrite <- (clausify_succ _ _ _ nil s HeqmkR) in H2.
apply H2. apply H. clear H2 H.
simpl.
assert (Q: (andp (listd pn_atom_denote inter TT pi) (space_denote (s0::sigma)))%pred s).
  split. apply (mk_pureL_clause_denote _ _ _ H0).
  apply H11.
assert (XX: ((listd pn_atom_denote inter (space_denote (s0::sigma)) pi s) =
    (listd pn_atom_denote inter TT pi && space_denote (s0::sigma))%pred s)).
  assert (X:= (@listd_unfold_inter pn_atom state pn_atom_denote (space_denote (s0::sigma)) pi)).
  unfold pred in X. rewrite X.
  trivial.
simpl in XX. rewrite XX. apply Q.

destruct sigma as [|s0 sigma].
destruct H2.
assert (H11 := H1 H3). clear H1.
clear H3 H4.
apply eq_sym in HeqmkR.
rewrite <- (clausify_succ _ _ _ (s0'::sigma') s HeqmkR) in H2.
apply H2. apply H. clear H2 H.
simpl.
assert (Q: (andp (listd pn_atom_denote inter TT pi) (space_denote nil))%pred s).
  split. apply (mk_pureL_clause_denote _ _ _ H0).
  apply H11.
assert (XX: ((listd pn_atom_denote inter (space_denote nil) pi s) =
    (listd pn_atom_denote inter TT pi && space_denote nil)%pred s)).
  assert (X:= (@listd_unfold_inter pn_atom state pn_atom_denote (space_denote nil) pi)).
  unfold pred in X. rewrite X.
  trivial.
simpl in XX. rewrite XX. apply Q.
  
destruct H2.
assert (H11 := H1 H3). clear H1.
clear H3 H4.
apply eq_sym in HeqmkR.
rewrite <- (clausify_succ _ _ _ (s0'::sigma') s HeqmkR) in H2.
apply H2. apply H. clear H2 H.
simpl.
assert (Q: (andp (listd pn_atom_denote inter TT pi) (space_denote (s0::sigma)))%pred s).
  split. apply (mk_pureL_clause_denote _ _ _ H0).
  apply H11.
assert (XX: ((listd pn_atom_denote inter (space_denote (s0::sigma)) pi s) =
    (listd pn_atom_denote inter TT pi && space_denote (s0::sigma))%pred s)).
  assert (X:= (@listd_unfold_inter pn_atom state pn_atom_denote (space_denote (s0::sigma)) pi)).
  unfold pred in X. rewrite X.
  trivial.
simpl in XX; rewrite XX. apply Q.
Qed.

Theorem cnf_correct2 : forall (e : entailment),
  (forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s) ->
   entailment_denote e.
Proof.
intros.
destruct e; simpl.
intros s K. specialize (H s).
destruct (classic (assertion_denote a0 s)); auto.
contradict H.
unfold cnf.
destruct a. destruct a0 as [pi' sigma'].
remember (mk_pureR pi') as mkR. destruct mkR as[purepos' pureneg'].
repeat rewrite listd_app.
repeat rewrite (@listd_separate _ _ state).
simpl in H0.
assert (XL : ~ listd clause_denote inter (space_denote sigma') (map mk_pureL pi') s).
  rewrite (mk_pureL_clause_denoteEq) in H0. assumption.
apply eq_sym in HeqmkR.
rewrite (mk_pureR_denote _ _ _ _ _ HeqmkR) in H0.
simpl in *.
repeat rewrite andp_TT.
rewrite (mk_pureL_clause_denoteEq) in K.
rewrite (@listd_prop clause state clause_denote) in K.
destruct K as [K1 K2].
split. assumption.
split. rewrite clausify_space in K2. apply K2.

destruct sigma. destruct sigma'.
  simpl. split; auto. intros HH.
assert (H1: listd pure_atom_denote inter emp purepos' s).
  simpl in K2. rewrite (@listd_unfold_inter _ state). split; auto.
apply Decidable.not_and in H0.
destruct H0. destruct (H H1).
   apply Decidable.not_not in H. apply H.
   apply classic.
apply classic.
remember (s0 :: sigma') as sigma''.
simpl. split; auto. intros HH.
apply Decidable.not_and in H0.
destruct H0. destruct (H HH).
   apply Decidable.not_not in H. apply H.
   apply classic.
apply classic.
apply Decidable.not_and in H0.
destruct H0. simpl. split; auto. intros HH. destruct (H HH).
   apply Decidable.not_not in H.
   split; simpl; auto.
   apply classic.
apply classic.
Qed.

Theorem cnf_correct : forall (e : entailment),
  entailment_denote e =
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.
Proof.
intros.
apply prop_ext.
split; intros.
  eapply cnf_correct1. apply H.
 eapply cnf_correct2. apply H.
Qed.

End Clausify_Sound.

