Require Import mailbox.general_atomics.
Require Import VST.progs.conclib.
Require Import VST.progs.ghost.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.mailbox_bad.
(* mailbox.mailbox_bad:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition ___builtin_annot : ident := 5%positive.
Definition ___builtin_annot_intval : ident := 6%positive.
Definition ___builtin_bswap : ident := 31%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_bswap64 : ident := 32%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 3%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 7%positive.
Definition ___builtin_memcpy_aligned : ident := 4%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 9%positive.
Definition ___builtin_va_copy : ident := 10%positive.
Definition ___builtin_va_end : ident := 11%positive.
Definition ___builtin_va_start : ident := 8%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 15%positive.
Definition ___compcert_va_float64 : ident := 14%positive.
Definition ___compcert_va_int32 : ident := 12%positive.
Definition ___compcert_va_int64 : ident := 13%positive.
Definition ___i64_dtos : ident := 16%positive.
Definition ___i64_dtou : ident := 17%positive.
Definition ___i64_sar : ident := 28%positive.
Definition ___i64_sdiv : ident := 22%positive.
Definition ___i64_shl : ident := 26%positive.
Definition ___i64_shr : ident := 27%positive.
Definition ___i64_smod : ident := 24%positive.
Definition ___i64_smulh : ident := 29%positive.
Definition ___i64_stod : ident := 18%positive.
Definition ___i64_stof : ident := 20%positive.
Definition ___i64_udiv : ident := 23%positive.
Definition ___i64_umod : ident := 25%positive.
Definition ___i64_umulh : ident := 30%positive.
Definition ___i64_utod : ident := 19%positive.
Definition ___i64_utof : ident := 21%positive.
Definition _arg : ident := 90%positive.
Definition _atomic_exchange_SC : ident := 59%positive.
Definition _avail : ident := 86%positive.
Definition _available : ident := 83%positive.
Definition _b : ident := 71%positive.
Definition _buf : ident := 91%positive.
Definition _buffer : ident := 2%positive.
Definition _bufs : ident := 67%positive.
Definition _c : ident := 64%positive.
Definition _comm : ident := 68%positive.
Definition _d : ident := 95%positive.
Definition _data : ident := 1%positive.
Definition _exit : ident := 54%positive.
Definition _finish_read : ident := 78%positive.
Definition _finish_write : ident := 89%positive.
Definition _i : ident := 65%positive.
Definition _i__1 : ident := 85%positive.
Definition _initialize_channels : ident := 73%positive.
Definition _initialize_reader : ident := 76%positive.
Definition _initialize_writer : ident := 82%positive.
Definition _last : ident := 84%positive.
Definition _last_given : ident := 81%positive.
Definition _last_read : ident := 70%positive.
Definition _last_taken : ident := 79%positive.
Definition _load_SC : ident := 57%positive.
Definition _lr : ident := 75%positive.
Definition _main : ident := 96%positive.
Definition _malloc : ident := 55%positive.
Definition _memset : ident := 66%positive.
Definition _n : ident := 60%positive.
Definition _p : ident := 61%positive.
Definition _r : ident := 72%positive.
Definition _reader : ident := 93%positive.
Definition _reading : ident := 69%positive.
Definition _rr : ident := 74%positive.
Definition _s : ident := 63%positive.
Definition _spawn : ident := 56%positive.
Definition _start_read : ident := 77%positive.
Definition _start_write : ident := 87%positive.
Definition _store_SC : ident := 58%positive.
Definition _surely_malloc : ident := 62%positive.
Definition _v : ident := 92%positive.
Definition _w : ident := 88%positive.
Definition _writer : ident := 94%positive.
Definition _writing : ident := 80%positive.
Definition _t'1 : ident := 97%positive.
Definition _t'2 : ident := 98%positive.
Definition _t'3 : ident := 99%positive.
Definition _t'4 : ident := 100%positive.

Definition f_surely_malloc := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tvoid)) :: (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid) cc_default))
      ((Etempvar _n tuint) :: nil))
    (Sset _p (Etempvar _t'1 (tptr tvoid))))
  (Ssequence
    (Sifthenelse (Eunop Onotbool (Etempvar _p (tptr tvoid)) tint)
      (Scall None (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
        ((Econst_int (Int.repr 1) tint) :: nil))
      Sskip)
    (Sreturn (Some (Etempvar _p (tptr tvoid))))))
|}.

Definition f_memset := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_s, (tptr tvoid)) :: (_c, tint) :: (_n, tuint) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr tint)) :: (_i, tuint) :: nil);
  fn_body :=
(Ssequence
  (Sset _p (Ecast (Etempvar _s (tptr tvoid)) (tptr tint)))
  (Ssequence
    (Ssequence
      (Sset _i (Econst_int (Int.repr 0) tint))
      (Sloop
        (Ssequence
          (Sifthenelse (Ebinop Olt (Etempvar _i tuint)
                         (Ebinop Odiv (Etempvar _n tuint)
                           (Econst_int (Int.repr 4) tint) tuint) tint)
            Sskip
            Sbreak)
          (Sassign
            (Ederef
              (Ebinop Oadd (Etempvar _p (tptr tint)) (Etempvar _i tuint)
                (tptr tint)) tint) (Etempvar _c tint)))
        (Sset _i
          (Ebinop Oadd (Etempvar _i tuint) (Econst_int (Int.repr 1) tint)
            tuint))))
    (Sreturn (Some (Etempvar _s (tptr tvoid))))))
|}.

Definition v_bufs := {|
  gvar_info := (tarray (tptr (Tstruct _buffer noattr)) 5);
  gvar_init := (Init_space 20 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_comm := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_reading := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_last_read := {|
  gvar_info := (tarray (tptr tint) 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_initialize_channels := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_b, (tptr (Tstruct _buffer noattr))) ::
               (_r, tint) :: (_c, (tptr tint)) :: (_t'4, (tptr tvoid)) ::
               (_t'3, (tptr tvoid)) :: (_t'2, (tptr tvoid)) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                       (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                         (Econst_int (Int.repr 2) tint) tint) tint)
          Sskip
          Sbreak)
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                     cc_default))
              ((Esizeof (Tstruct _buffer noattr) tuint) :: nil))
            (Sset _b (Etempvar _t'1 (tptr tvoid))))
          (Ssequence
            (Scall None
              (Evar _memset (Tfunction
                              (Tcons (tptr tvoid)
                                (Tcons tint (Tcons tuint Tnil))) (tptr tvoid)
                              cc_default))
              ((Etempvar _b (tptr (Tstruct _buffer noattr))) ::
               (Econst_int (Int.repr 0) tint) ::
               (Esizeof (Tstruct _buffer noattr) tuint) :: nil))
            (Sassign
              (Ederef
                (Ebinop Oadd
                  (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                  (Etempvar _i tint) (tptr (tptr (Tstruct _buffer noattr))))
                (tptr (Tstruct _buffer noattr)))
              (Etempvar _b (tptr (Tstruct _buffer noattr)))))))
      (Sset _i
        (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
  (Ssequence
    (Sset _r (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                       (Econst_int (Int.repr 3) tint) tint)
          Sskip
          Sbreak)
        (Ssequence
          (Ssequence
            (Scall (Some _t'2)
              (Evar _surely_malloc (Tfunction (Tcons tuint Tnil) (tptr tvoid)
                                     cc_default))
              ((Esizeof tint tuint) :: nil))
            (Sset _c (Etempvar _t'2 (tptr tvoid))))
          (Ssequence
            (Sassign (Ederef (Etempvar _c (tptr tint)) tint)
              (Econst_int (Int.repr 0) tint))
            (Ssequence
              (Sassign
                (Ederef
                  (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3))
                    (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                (Etempvar _c (tptr tint)))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'3)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof tint tuint) :: nil))
                  (Sset _c (Etempvar _t'3 (tptr tvoid))))
                (Ssequence
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3))
                        (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                    (Etempvar _c (tptr tint)))
                  (Ssequence
                    (Ssequence
                      (Scall (Some _t'4)
                        (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                               (tptr tvoid) cc_default))
                        ((Esizeof tint tuint) :: nil))
                      (Sset _c (Etempvar _t'4 (tptr tvoid))))
                    (Sassign
                      (Ederef
                        (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
                          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint))
                      (Etempvar _c (tptr tint))))))))))
      (Sset _r
        (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint) tint)))))
|}.

Definition f_initialize_reader := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_rr, (tptr tint)) :: (_lr, (tptr tint)) :: nil);
  fn_body :=
(Ssequence
  (Sset _rr
    (Ederef
      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Ssequence
    (Sset _lr
      (Ederef
        (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
    (Ssequence
      (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
        (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))
      (Sassign (Ederef (Etempvar _lr (tptr tint)) tint)
        (Econst_int (Int.repr 1) tint)))))
|}.

Definition f_start_read := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_b, tint) :: (_c, (tptr tint)) :: (_rr, (tptr tint)) ::
               (_lr, (tptr tint)) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _c
    (Ederef
      (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Ssequence
    (Sset _rr
      (Ederef
        (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3))
          (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
    (Ssequence
      (Sset _lr
        (Ederef
          (Ebinop Oadd (Evar _last_read (tarray (tptr tint) 3))
            (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _atomic_exchange_SC (Tfunction
                                        (Tcons (tptr tint) (Tcons tint Tnil))
                                        tint cc_default))
            ((Etempvar _c (tptr tint)) ::
             (Eunop Oneg (Econst_int (Int.repr 1) tint) tint) :: nil))
          (Sset _b (Etempvar _t'1 tint)))
        (Ssequence
          (Ssequence
            (Sifthenelse (Ebinop Oge (Etempvar _b tint)
                           (Econst_int (Int.repr 0) tint) tint)
              (Sset _t'2
                (Ecast
                  (Ebinop Olt (Etempvar _b tint)
                    (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                      (Econst_int (Int.repr 2) tint) tint) tint) tbool))
              (Sset _t'2 (Econst_int (Int.repr 0) tint)))
            (Sifthenelse (Etempvar _t'2 tint)
              (Sassign (Ederef (Etempvar _lr (tptr tint)) tint)
                (Etempvar _b tint))
              (Sset _b (Ederef (Etempvar _lr (tptr tint)) tint))))
          (Ssequence
            (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
              (Etempvar _b tint))
            (Sreturn (Some (Etempvar _b tint)))))))))
|}.

Definition f_finish_read := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_r, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_rr, (tptr tint)) :: nil);
  fn_body :=
(Ssequence
  (Sset _rr
    (Ederef
      (Ebinop Oadd (Evar _reading (tarray (tptr tint) 3)) (Etempvar _r tint)
        (tptr (tptr tint))) (tptr tint)))
  (Sassign (Ederef (Etempvar _rr (tptr tint)) tint)
    (Eunop Oneg (Econst_int (Int.repr 1) tint) tint)))
|}.

Definition v_last_taken := {|
  gvar_info := (tarray tint 3);
  gvar_init := (Init_space 12 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_writing := {|
  gvar_info := tint;
  gvar_init := (Init_space 4 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition v_last_given := {|
  gvar_info := tint;
  gvar_init := (Init_space 4 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_initialize_writer := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: nil);
  fn_body :=
(Ssequence
  (Sassign (Evar _last_given tint) (Econst_int (Int.repr 0) tint))
  (Ssequence
    (Sassign (Evar _writing tint)
      (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))
    (Ssequence
      (Sset _i (Econst_int (Int.repr 0) tint))
      (Sloop
        (Ssequence
          (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                         (Econst_int (Int.repr 3) tint) tint)
            Sskip
            Sbreak)
          (Sassign
            (Ederef
              (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                (Etempvar _i tint) (tptr tint)) tint)
            (Econst_int (Int.repr 1) tint)))
        (Sset _i
          (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
            tint))))))
|}.

Definition f_start_write := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_available, (tarray tint 5)) :: nil);
  fn_temps := ((_i, tint) :: (_last, tint) :: (_r, tint) :: (_i__1, tint) ::
               (_avail, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Sloop
      (Ssequence
        (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                       (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                         (Econst_int (Int.repr 2) tint) tint) tint)
          Sskip
          Sbreak)
        (Sassign
          (Ederef
            (Ebinop Oadd (Evar _available (tarray tint 5)) (Etempvar _i tint)
              (tptr tint)) tint) (Econst_int (Int.repr 1) tint)))
      (Sset _i
        (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint) tint))))
  (Ssequence
    (Sset _last (Evar _last_given tint))
    (Ssequence
      (Sassign
        (Ederef
          (Ebinop Oadd (Evar _available (tarray tint 5))
            (Etempvar _last tint) (tptr tint)) tint)
        (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Ssequence
          (Sset _r (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Sset _last
                  (Ederef
                    (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                      (Etempvar _r tint) (tptr tint)) tint))
                (Sifthenelse (Ebinop One (Etempvar _last tint)
                               (Eunop Oneg (Econst_int (Int.repr 1) tint)
                                 tint) tint)
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _available (tarray tint 5))
                        (Etempvar _last tint) (tptr tint)) tint)
                    (Econst_int (Int.repr 0) tint))
                  Sskip)))
            (Sset _r
              (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Ssequence
          (Ssequence
            (Sset _i__1 (Econst_int (Int.repr 0) tint))
            (Sloop
              (Ssequence
                (Sifthenelse (Ebinop Olt (Etempvar _i__1 tint)
                               (Ebinop Oadd (Econst_int (Int.repr 3) tint)
                                 (Econst_int (Int.repr 2) tint) tint) tint)
                  Sskip
                  Sbreak)
                (Ssequence
                  (Sset _avail
                    (Ederef
                      (Ebinop Oadd (Evar _available (tarray tint 5))
                        (Etempvar _i__1 tint) (tptr tint)) tint))
                  (Sifthenelse (Etempvar _avail tint)
                    (Ssequence
                      (Sassign (Evar _writing tint) (Etempvar _i__1 tint))
                      (Sreturn (Some (Etempvar _i__1 tint))))
                    Sskip)))
              (Sset _i__1
                (Ebinop Oadd (Etempvar _i__1 tint)
                  (Econst_int (Int.repr 1) tint) tint))))
          (Scall None
            (Evar _exit (Tfunction (Tcons tint Tnil) tvoid cc_default))
            ((Econst_int (Int.repr 1) tint) :: nil)))))))
|}.

Definition f_finish_write := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_last, tint) :: (_w, tint) :: (_r, tint) ::
               (_c, (tptr tint)) :: (_b, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _last (Evar _last_given tint))
  (Ssequence
    (Sset _w (Evar _writing tint))
    (Ssequence
      (Ssequence
        (Sset _r (Econst_int (Int.repr 0) tint))
        (Sloop
          (Ssequence
            (Sifthenelse (Ebinop Olt (Etempvar _r tint)
                           (Econst_int (Int.repr 3) tint) tint)
              Sskip
              Sbreak)
            (Ssequence
              (Sset _c
                (Ederef
                  (Ebinop Oadd (Evar _comm (tarray (tptr tint) 3))
                    (Etempvar _r tint) (tptr (tptr tint))) (tptr tint)))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _atomic_exchange_SC (Tfunction
                                                (Tcons (tptr tint)
                                                  (Tcons tint Tnil)) tint
                                                cc_default))
                    ((Etempvar _c (tptr tint)) :: (Etempvar _w tint) :: nil))
                  (Sset _b (Etempvar _t'1 tint)))
                (Sifthenelse (Ebinop Oeq (Etempvar _b tint)
                               (Eunop Oneg (Econst_int (Int.repr 1) tint)
                                 tint) tint)
                  (Sassign
                    (Ederef
                      (Ebinop Oadd (Evar _last_taken (tarray tint 3))
                        (Etempvar _r tint) (tptr tint)) tint)
                    (Etempvar _last tint))
                  Sskip))))
          (Sset _r
            (Ebinop Oadd (Etempvar _r tint) (Econst_int (Int.repr 1) tint)
              tint))))
      (Ssequence
        (Sassign (Evar _last_given tint) (Etempvar _w tint))
        (Sassign (Evar _writing tint)
          (Eunop Oneg (Econst_int (Int.repr 1) tint) tint))))))
|}.

Definition f_reader := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_r, tint) :: (_b, tint) ::
               (_buf, (tptr (Tstruct _buffer noattr))) :: (_v, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _r (Ederef (Ecast (Etempvar _arg (tptr tvoid)) (tptr tint)) tint))
  (Ssequence
    (Scall None
      (Evar _initialize_reader (Tfunction (Tcons tint Tnil) tvoid cc_default))
      ((Etempvar _r tint) :: nil))
    (Ssequence
      (Sloop
        (Ssequence
          Sskip
          (Ssequence
            (Ssequence
              (Scall (Some _t'1)
                (Evar _start_read (Tfunction (Tcons tint Tnil) tint
                                    cc_default)) ((Etempvar _r tint) :: nil))
              (Sset _b (Etempvar _t'1 tint)))
            (Ssequence
              (Sset _buf
                (Ederef
                  (Ebinop Oadd
                    (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                    (Etempvar _b tint)
                    (tptr (tptr (Tstruct _buffer noattr))))
                  (tptr (Tstruct _buffer noattr))))
              (Ssequence
                (Ssequence
                  (Scall (Some _t'2)
                    (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                     cc_default))
                    ((Eaddrof
                       (Efield
                         (Ederef
                           (Etempvar _buf (tptr (Tstruct _buffer noattr)))
                           (Tstruct _buffer noattr)) _data tint) (tptr tint)) ::
                     nil))
                  (Sset _v (Etempvar _t'2 tint)))
                (Scall None
                  (Evar _finish_read (Tfunction (Tcons tint Tnil) tvoid
                                       cc_default))
                  ((Etempvar _r tint) :: nil))))))
        Sskip)
      (Sreturn (Some (Econst_int (Int.repr 0) tint))))))
|}.

Definition f_writer := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_arg, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_v, tint) :: (_b, tint) ::
               (_buf, (tptr (Tstruct _buffer noattr))) :: (_t'1, tint) ::
               nil);
  fn_body :=
(Ssequence
  (Scall None (Evar _initialize_writer (Tfunction Tnil tvoid cc_default))
    nil)
  (Ssequence
    (Sset _v (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Sloop
        (Ssequence
          Sskip
          (Ssequence
            (Ssequence
              (Scall (Some _t'1)
                (Evar _start_write (Tfunction Tnil tint cc_default)) nil)
              (Sset _b (Etempvar _t'1 tint)))
            (Ssequence
              (Sset _buf
                (Ederef
                  (Ebinop Oadd
                    (Evar _bufs (tarray (tptr (Tstruct _buffer noattr)) 5))
                    (Etempvar _b tint)
                    (tptr (tptr (Tstruct _buffer noattr))))
                  (tptr (Tstruct _buffer noattr))))
              (Ssequence
                (Scall None
                  (Evar _store_SC (Tfunction
                                    (Tcons (tptr tint) (Tcons tint Tnil))
                                    tvoid cc_default))
                  ((Eaddrof
                     (Efield
                       (Ederef
                         (Etempvar _buf (tptr (Tstruct _buffer noattr)))
                         (Tstruct _buffer noattr)) _data tint) (tptr tint)) ::
                   (Etempvar _v tint) :: nil))
                (Ssequence
                  (Scall None
                    (Evar _finish_write (Tfunction Tnil tvoid cc_default))
                    nil)
                  (Sset _v
                    (Ebinop Oadd (Etempvar _v tint)
                      (Econst_int (Int.repr 1) tint) tint)))))))
        Sskip)
      (Sreturn (Some (Econst_int (Int.repr 0) tint))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_i, tint) :: (_d, (tptr tint)) :: (_t'1, (tptr tvoid)) ::
               nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall None (Evar _initialize_channels (Tfunction Tnil tvoid cc_default))
      nil)
    (Ssequence
      (Scall None
        (Evar _spawn (Tfunction
                       (Tcons
                         (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                 (tptr tvoid) cc_default))
                         (Tcons (tptr tvoid) Tnil)) tvoid cc_default))
        ((Ecast
           (Eaddrof
             (Evar _writer (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid)
                             cc_default))
             (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid)
                     cc_default))) (tptr tvoid)) ::
         (Econst_int (Int.repr 0) tint) :: nil))
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 3) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'1)
                    (Evar _surely_malloc (Tfunction (Tcons tuint Tnil)
                                           (tptr tvoid) cc_default))
                    ((Esizeof tint tuint) :: nil))
                  (Sset _d (Etempvar _t'1 (tptr tvoid))))
                (Ssequence
                  (Sassign (Ederef (Etempvar _d (tptr tint)) tint)
                    (Etempvar _i tint))
                  (Scall None
                    (Evar _spawn (Tfunction
                                   (Tcons
                                     (tptr (Tfunction
                                             (Tcons (tptr tvoid) Tnil)
                                             (tptr tvoid) cc_default))
                                     (Tcons (tptr tvoid) Tnil)) tvoid
                                   cc_default))
                    ((Ecast
                       (Eaddrof
                         (Evar _reader (Tfunction (Tcons (tptr tvoid) Tnil)
                                         (tptr tvoid) cc_default))
                         (tptr (Tfunction (Tcons (tptr tvoid) Tnil)
                                 (tptr tvoid) cc_default))) (tptr tvoid)) ::
                     (Ecast (Etempvar _d (tptr tint)) (tptr tvoid)) :: nil)))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Sloop Sskip Sskip))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _buffer Struct ((_data, tint) :: nil) noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_smulh,
   Gfun(External (EF_runtime "__i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umulh,
   Gfun(External (EF_runtime "__i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_exit,
   Gfun(External (EF_external "exit"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons tint Tnil) tvoid cc_default)) ::
 (_malloc,
   Gfun(External EF_malloc (Tcons tuint Tnil) (tptr tvoid) cc_default)) ::
 (_spawn,
   Gfun(External (EF_external "spawn"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons
       (tptr (Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default))
       (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_atomic_exchange_SC,
   Gfun(External (EF_external "atomic_exchange_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tint
     cc_default)) :: (_surely_malloc, Gfun(Internal f_surely_malloc)) ::
 (_memset, Gfun(Internal f_memset)) :: (_bufs, Gvar v_bufs) ::
 (_comm, Gvar v_comm) :: (_reading, Gvar v_reading) ::
 (_last_read, Gvar v_last_read) ::
 (_initialize_channels, Gfun(Internal f_initialize_channels)) ::
 (_initialize_reader, Gfun(Internal f_initialize_reader)) ::
 (_start_read, Gfun(Internal f_start_read)) ::
 (_finish_read, Gfun(Internal f_finish_read)) ::
 (_last_taken, Gvar v_last_taken) :: (_writing, Gvar v_writing) ::
 (_last_given, Gvar v_last_given) ::
 (_initialize_writer, Gfun(Internal f_initialize_writer)) ::
 (_start_write, Gfun(Internal f_start_write)) ::
 (_finish_write, Gfun(Internal f_finish_write)) ::
 (_reader, Gfun(Internal f_reader)) :: (_writer, Gfun(Internal f_writer)) ::
 (_main, Gfun(Internal f_main)) :: nil);
prog_public :=
(_main :: _writer :: _reader :: _finish_write :: _start_write ::
 _initialize_writer :: _last_given :: _writing :: _last_taken ::
 _finish_read :: _start_read :: _initialize_reader :: _initialize_channels ::
 _last_read :: _reading :: _comm :: _bufs :: _memset :: _surely_malloc ::
 _atomic_exchange_SC :: _store_SC :: _load_SC :: _spawn :: _malloc ::
 _exit :: ___builtin_debug :: ___builtin_nop ::
 ___builtin_write32_reversed :: ___builtin_write16_reversed ::
 ___builtin_read32_reversed :: ___builtin_read16_reversed ::
 ___builtin_fnmsub :: ___builtin_fnmadd :: ___builtin_fmsub ::
 ___builtin_fmadd :: ___builtin_fmin :: ___builtin_fmax ::
 ___builtin_fsqrt :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap16 :: ___builtin_bswap32 :: ___builtin_bswap64 ::
 ___builtin_bswap :: ___i64_umulh :: ___i64_smulh :: ___i64_sar ::
 ___i64_shr :: ___i64_shl :: ___i64_umod :: ___i64_smod :: ___i64_udiv ::
 ___i64_sdiv :: ___i64_utof :: ___i64_stof :: ___i64_utod :: ___i64_stod ::
 ___i64_dtou :: ___i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)
Require Import mailbox.verif_mailbox_bad_specs.
(* mailbox.verif_mailbox_bad_specs:
Definition spawn_spec := DECLARE _spawn spawn_spec.
Definition load_SC_spec := DECLARE _load_SC load_SC_spec.
Definition store_SC_spec := DECLARE _store_SC store_SC_spec.
Definition AEX_SC_spec := DECLARE _atomic_exchange_SC AEX_SC_spec.

Definition surely_malloc_spec :=
 DECLARE _surely_malloc
   WITH n:Z
   PRE [ _n OF tuint ]
       PROP (0 <= n <= Int.max_unsigned)
       LOCAL (temp _n (Vint (Int.repr n)))
       SEP ()
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (malloc_token Tsh n p * memory_block Tsh n p).

Definition memset_spec :=
 DECLARE _memset
  WITH sh : share, t : type, p : val, c : Z, n : Z
  PRE [ _s OF tptr tvoid, _c OF tint, _n OF tuint ]
   PROP (writable_share sh; sizeof t = (4 * n)%Z; 4 * n <= Int.max_unsigned; (4 | alignof t))
   LOCAL (temp _s p; temp _c (vint c); temp _n (vint (4 * n)%Z))
   SEP (data_at_ sh t p)
  POST [ tptr tvoid ]
   PROP ()
   LOCAL (temp ret_temp p)
   SEP (data_at sh (tarray tint n) (repeat (vint c) (Z.to_nat n)) p).

Definition N := 3.
Definition B := N + 2.

Definition tbuffer := Tstruct _buffer noattr.

Definition Empty := vint (-1).

Fixpoint find_read h d :=
  match h with
  | [] => (d, [])
  | AE r w :: rest => if eq_dec w Empty then if eq_dec r Empty then find_read rest d
                      else (r, rest) else find_read rest d
  end.

Definition last_two_reads h := let '(b1, rest) := find_read h (vint 1) in (b1, fst (find_read rest (vint 1))).

Fixpoint find_write h d :=
  match h with
  | [] => (d, [])
  | AE r w :: rest => if eq_dec w Empty then find_write rest d else (w, rest)
  end.

Definition prev_taken h := fst (find_read (snd (find_write h (vint 0))) (vint 1)).

Definition last_write h := fst (find_write h (vint 0)).

Definition comm_R bufs sh gsh g g0 g1 g2 h b := EX b1 : Z, EX b2 : Z,
  !!(-1 <= b < B /\ Forall (fun a => match a with AE v1 v2 =>
       exists r w, v1 = vint r /\ v2 = vint w /\ -1 <= r < B /\ -1 <= w < B end) h /\
     apply_hist (vint 0) h = Some (vint b) /\
     last_two_reads (rev h) = (vint b1, vint b2) /\ repable_signed b1 /\ repable_signed b2) &&
  ghost_ref h g * ghost_var gsh (vint b1) g0 * ghost_var gsh (last_write (rev h)) g1 *
  ghost_var gsh (prev_taken (rev h)) g2 *
  if eq_dec b (-1) then EX v : _, data_at sh tbuffer (Vint v) (Znth b2 bufs Vundef)
  else EX v : _, data_at sh tbuffer (Vint v) (Znth b bufs Vundef).

Definition comm_inv (good : bool) comm bufs sh g g0 g1 g2 gsh :=
  EX v : Z, data_at Tsh tint (vint v) comm *
    if good then EX h : _, comm_R bufs sh gsh g g0 g1 g2 h v
        else (EX h : list AE_hist_el, ghost_ref h g) * (EX v : val, ghost_var gsh v g0) *
      (EX v : val, ghost_var gsh v g1) * (EX v : val, ghost_var gsh v g2) *
      fold_right sepcon emp (map (fun p => EX v : _, data_at sh tbuffer (Vint v) p) bufs).

Notation hist := (list (nat * AE_hist_el)).

Definition comm_loc good lsh comm g g0 g1 g2 bufs sh gsh h :=
  invariant (comm_inv good comm bufs sh g g0 g1 g2 gsh) * ghost_hist lsh (h : hist) g.

Definition initialize_channels_spec :=
 DECLARE _initialize_channels
  WITH lgood : list bool, comm : val, buf : val, reading : val, last_read : val,
       sh1 : share, shs : list share, shg : share
  PRE [ ]
   PROP (Zlength lgood = N; Zlength shs = N; sepalg_list.list_join sh1 shs Tsh;
         
         sepalg_list.list_join sh1 (map snd (filter fst (combine lgood shs))) shg)
   LOCAL (gvar _comm comm; gvar _bufs buf; gvar _reading reading; gvar _last_read last_read)
   SEP (data_at_ Ews (tarray (tptr tint) N) comm; data_at_ Ews (tarray (tptr tbuffer) B) buf;
        data_at_ Ews (tarray (tptr tint) N) reading; data_at_ Ews (tarray (tptr tint) N) last_read)
  POST [ tvoid ]
   EX comms : list val, EX bufs : list val, EX reads : list val, EX lasts : list val,
     EX g : list val, EX g0 : list val, EX g1 : list val, EX g2 : list val,
   PROP (Forall isptr comms; Forall isptr bufs;
         Zlength g = N; Zlength g0 = N; Zlength g1 = N; Zlength g2 = N)
   LOCAL ()
   SEP (data_at Ews (tarray (tptr tint) N) comms comm;
        data_at Ews (tarray (tptr tbuffer) B) bufs buf;
        data_at Ews (tarray (tptr tint) N) reads reading;
        data_at Ews (tarray (tptr tint) N) lasts last_read;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) Tsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 ([] : hist)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g0);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) comms);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tbuffer)) bufs);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) reads);
        fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) lasts);
        
        data_at sh1 tbuffer (vint 0) (Znth 0 bufs Vundef);
        fold_right sepcon emp (map (data_at shg tbuffer (vint 0)) (sublist 1 (Zlength bufs) bufs));
        fold_right sepcon emp (map (data_at_ Tsh tint) reads);
        fold_right sepcon emp (map (data_at_ Tsh tint) lasts)).

Definition initialize_reader_spec :=
 DECLARE _initialize_reader
  WITH r : Z, reading : val, last_read : val, reads : list val, lasts : list val, sh : share
  PRE [ _r OF tint ]
   PROP (readable_share sh)
   LOCAL (temp _r (vint r); gvar _reading reading; gvar _last_read last_read)
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at sh (tarray (tptr tint) N) lasts last_read;
        data_at_ Tsh tint (Znth r reads Vundef); data_at_ Tsh tint (Znth r lasts Vundef))
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at sh (tarray (tptr tint) N) lasts last_read;
        data_at Tsh tint Empty (Znth r reads Vundef); data_at Tsh tint (vint 1) (Znth r lasts Vundef)).

Definition latest_read (h : hist) v :=
  
  (Forall (fun x => let '(_, AE r w) := x in w = Empty ->
    match r with Vint i => Int.signed i < 0 \/ Int.signed i >= B | _ => True end) h /\ v = 1) \/
  0 <= v < B /\ exists n, In (n, AE (vint v) Empty) h /\
  Forall (fun x => let '(m, AE r w) := x in w = Empty -> forall v', r = vint v' -> 0 <= v' < B ->
    (m <= n)%nat) h.

Definition start_read_spec :=
 DECLARE _start_read
  WITH r : Z, reading : val, last_read : val, comm : val, reads : list val, lasts : list val,
    good : bool, comms : list val, bufs : list val, sh : share, sh1 : share, sh2 : share, b0 : Z,
    g : val, g0 : val, g1 : val, g2 : val, h : hist
  PRE [ _r OF tint ]
   PROP (0 <= b0 < B; readable_share sh; readable_share sh1; readable_share sh2; isptr (Znth r comms Vundef);
        latest_read h b0)
   LOCAL (temp _r (vint r); gvar _reading reading; gvar _last_read last_read; gvar _comm comm)
   SEP (data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at_ Tsh tint (Znth r reads Vundef); data_at Tsh tint (vint b0) (Znth r lasts Vundef);
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 h;
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth b0 bufs Vundef) else emp;
        ghost_var gsh1 (vint b0) g0)
  POST [ tint ]
   EX b : Z, EX t : nat, EX v0 : Z,
   PROP (0 <= b < B; b = if (Z.leb 0 v0 && Z.ltb v0 B)%bool then v0 else b0;
         latest_read (h ++ [(t, AE (vint v0) Empty)]) b)
   LOCAL (temp ret_temp (vint b))
   SEP (data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at Tsh tint (vint b) (Znth r reads Vundef); data_at Tsh tint (vint b) (Znth r lasts Vundef);
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 (h ++ [(t, AE (vint v0) Empty)]);
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth b bufs Vundef) else emp;
        ghost_var gsh1 (vint b) g0).

Definition finish_read_spec :=
 DECLARE _finish_read
  WITH r : Z, reading : val, reads : list val, sh : share
  PRE [ _r OF tint ]
   PROP (readable_share sh)
   LOCAL (temp _r (vint r); gvar _reading reading)
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at_ Tsh tint (Znth r reads Vundef))
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at sh (tarray (tptr tint) N) reads reading; data_at Tsh tint Empty (Znth r reads Vundef)).

Definition initialize_writer_spec :=
 DECLARE _initialize_writer
  WITH writing : val, last_given : val, last_taken : val
  PRE [ ]
   PROP ()
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (data_at_ Ews tint writing; data_at_ Ews tint last_given;
        data_at_ Ews (tarray tint N) last_taken)
  POST [ tvoid ]
   PROP ()
   LOCAL ()
   SEP (data_at Ews tint Empty writing; data_at Ews tint (vint 0) last_given;
        data_at Ews (tarray tint N) (repeat (vint 1) (Z.to_nat N)) last_taken).

Definition start_write_spec :=
 DECLARE _start_write
  WITH writing : val, last_given : val, last_taken : val, b0 : Z, lasts : list Z
  PRE [ ]
   PROP (0 <= b0 < B; Forall (fun x => 0 <= x < B) lasts)
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken)
   SEP (data_at_ Ews tint writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken)
  POST [ tint ]
   EX b : Z,
   PROP (0 <= b < B; b <> b0; ~In b lasts)
   LOCAL (temp ret_temp (vint b))
   SEP (data_at Ews tint (vint b) writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken).

Fixpoint make_shares shs lasts i : list share :=
  match lasts with
  | [] => []
  | (g, b) :: rest => if (negb g || Z.eqb b i)%bool then make_shares (tl shs) rest i
                 else hd Share.bot shs :: make_shares (tl shs) rest i
  end.

Definition finish_write_spec :=
 DECLARE _finish_write
  WITH writing : val, last_given : val, last_taken : val, comm : val, comms : list val, bufs : list val,
    lgood : list bool, b : Z, b0 : Z, lasts : list Z,
    sh1 : share, lsh : share, shs : list share, g : list val, g0 : list val, g1 : list val, g2 : list val,
    h : list hist, sh0 : share
  PRE [ ]
   PROP (0 <= b < B; 0 <= b0 < B; Forall (fun x => 0 <= x < B) lasts; Zlength h = N;
         Zlength lgood = N; Zlength shs = N;
         readable_share sh1; readable_share lsh; Forall readable_share shs;
         sepalg_list.list_join sh0 shs Tsh; Forall isptr comms; b <> b0; ~In b lasts; ~In b0 lasts)
   LOCAL (gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken; gvar _comm comm)
   SEP (data_at Ews tint (vint b) writing; data_at Ews tint (vint b0) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 (Znth r h [])) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun r => ghost_var gsh1 (vint b0) (Znth r g1 Vundef) *
          ghost_var gsh1 (vint (Znth r lasts (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i b0 then sh = sh0 else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts) i) sh) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B))))
  POST [ tvoid ]
   EX lasts' : list Z, EX h' : list hist,
   PROP (Forall (fun x => 0 <= x < B) lasts';
         Forall2 (fun h1 h2 => exists t v, h2 = h1 ++ [(t, AE v (vint b))]) h h';
         ~In b lasts')
   LOCAL ()
   SEP (data_at Ews tint Empty writing; data_at Ews tint (vint b) last_given;
        data_at Ews (tarray tint N) (map (fun x => vint x) lasts') last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 (Znth r h' [])) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun r => ghost_var gsh1 (vint b) (Znth r g1 Vundef) *
          ghost_var gsh1 (vint (Znth r lasts' (-1))) (Znth r g2 Vundef)) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i b then sh = sh0 else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts') i) sh) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B)))).

Definition reader_spec :=
 DECLARE _reader
  WITH arg : val, x : Z * bool * val * val * val * val * list val * list val * list val * list val *
                      share * share * share * val * val * val * val
  PRE [ _arg OF tptr tvoid ]
   let '(r, good, reading, last_read, comm, buf, reads, lasts, comms, bufs, sh1, sh2, sh, g, g0, g1, g2) := x in
   PROP (readable_share sh; readable_share sh1; readable_share sh2; isptr (Znth r comms Vundef);
         Forall isptr bufs)
   LOCAL (temp _arg arg; gvar _reading reading; gvar _last_read last_read;
          gvar _comm comm; gvar _bufs buf)
   SEP (data_at Tsh tint (vint r) arg; malloc_token Tsh (sizeof tint) arg;
        data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at_ Tsh tint (Znth r reads Vundef); data_at_ Tsh tint (Znth r lasts Vundef);
        data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
        comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 [];
        if good then EX v : _, data_at sh tbuffer (Vint v) (Znth 1 bufs Vundef) else emp;
        ghost_var gsh1 (vint 1) g0)
  POST [ tptr tvoid ] PROP () LOCAL () SEP ().

Definition writer_spec :=
 DECLARE _writer
  WITH arg : val, x : list bool * val * val * val * val * val * list val * list val * share * share *
                      share * list share * share * list val * list val * list val * list val
  PRE [ _arg OF tptr tvoid ]
   let '(lgood, writing, last_given, last_taken, comm, buf, comms, bufs, sh1, lsh, sh0, shs, shg, g, g0, g1, g2) := x in
   PROP (Zlength lgood = N; Zlength shs = N; readable_share sh1; readable_share lsh;
         readable_share sh0; Forall readable_share shs;
         sepalg_list.list_join sh0 shs Tsh;
         sepalg_list.list_join sh0 (map snd (filter fst (combine lgood shs))) shg;
         Zlength g1 = N; Zlength g2 = N; Forall isptr comms)
   LOCAL (temp _arg arg; gvar _writing writing; gvar _last_given last_given; gvar _last_taken last_taken;
          gvar _comm comm; gvar _bufs buf)
   SEP (data_at_ Ews tint writing; data_at_ Ews tint last_given; data_at_ Ews (tarray tint N) last_taken;
        data_at sh1 (tarray (tptr tint) N) comms comm;
        data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
        fold_right sepcon emp (map (fun r =>
          comm_loc (Znth r lgood false) lsh (Znth r comms Vundef) (Znth r g Vundef) (Znth r g0 Vundef)
            (Znth r g1 Vundef) (Znth r g2 Vundef) bufs (Znth r shs Tsh) gsh2 []) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2);
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i 0 then sh = sh0 else if eq_dec i 1 then sh = sh0 else sh = shg) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B))))
  POST [ tptr tvoid ] PROP () LOCAL () SEP ().

Definition main_spec :=
 DECLARE _main
  WITH u : unit
  PRE  [] main_pre prog [] u
  POST [ tint ] main_post prog [] u.

Definition Gprog : funspecs := ltac:(with_library prog [spawn_spec;
  surely_malloc_spec; memset_spec; AEX_SC_spec; load_SC_spec; store_SC_spec;
  initialize_channels_spec; initialize_reader_spec;
  start_read_spec; finish_read_spec; initialize_writer_spec; start_write_spec; finish_write_spec;
  reader_spec; writer_spec; main_spec]).

Lemma Empty_inj : forall i, vint i = Empty -> repable_signed i -> i = -1.

Lemma repable_buf : forall a, -1 <= a < B -> repable_signed a.

Opaque upto.

Lemma list_join_minus : forall l (sh : share) shs sh1 sh2 (Hl : Zlength l = Zlength shs)
  (Hall : sepalg_list.list_join sh shs sh1)

Lemma fold_right_emp : forall l (Hemp : Forall (eq emp) l), fold_right sepcon emp l = emp.

Lemma last_two_reads_cons : forall r w h, last_two_reads (AE r w :: h) =
  if eq_dec w Empty then if eq_dec r Empty then last_two_reads h else (r, fst (last_two_reads h))
  else last_two_reads h.

Lemma prev_taken_cons : forall r w h, prev_taken (AE r w :: h) =
  if eq_dec w Empty then prev_taken h else fst (find_read h (vint 1)).

Lemma find_read_pos : forall d h, d <> Empty -> fst (find_read h d) <> Empty.

Corollary last_two_reads_fst : forall h, fst (last_two_reads h) <> Empty.

Lemma find_read_In : forall d h, In (AE (fst (find_read h d)) Empty) (AE d Empty :: h).

Corollary last_two_reads_In1 : forall h, In (AE (fst (last_two_reads h)) Empty) (AE (vint 1) Empty :: h).

Lemma find_read_incl : forall a d h, In a (snd (find_read h d)) -> In a h.

Corollary last_two_reads_In2 : forall h, In (AE (snd (last_two_reads h)) Empty) (AE (vint 1) Empty :: h).

Lemma latest_read_bad : forall h n r v, repable_signed r -> r < 0 \/ r >= B ->
  latest_read (h ++ [(n, AE (vint r) Empty)]) v <-> latest_read h v.

Corollary latest_read_Empty : forall h n v,
  latest_read (h ++ [(n, AE Empty Empty)]) v <-> latest_read h v.

Lemma latest_read_new : forall h n v, newer h n -> 0 <= v < B ->
  latest_read (h ++ [(n, AE (vint v) Empty)]) v. *)
Require Import mailbox.verif_mailbox_bad_read.
(* mailbox.verif_mailbox_bad_read:
Require Import mailbox.general_atomics.
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.mailbox_bad.
Require Import mailbox.verif_mailbox_bad_specs.

Set Bullet Behavior "Strict Subproofs".

Lemma body_initialize_reader : semax_body Vprog Gprog f_initialize_reader initialize_reader_spec.

Lemma body_start_read : semax_body Vprog Gprog f_start_read start_read_spec.

Lemma body_finish_read : semax_body Vprog Gprog f_finish_read finish_read_spec. *)
Require Import mailbox.verif_mailbox_bad_write.
(* mailbox.verif_mailbox_bad_write:
Require Import mailbox.general_atomics.
Require Import VST.progs.conclib.
Require Import VST.progs.ghost.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import mailbox.mailbox_bad.
Require Import mailbox.verif_mailbox_bad_specs.

Set Bullet Behavior "Strict Subproofs".

Opaque upto.

Lemma body_initialize_writer : semax_body Vprog Gprog f_initialize_writer initialize_writer_spec.

Lemma body_start_write : semax_body Vprog Gprog f_start_write start_write_spec.

Lemma find_write_rest : forall d h, exists n, snd (find_write h d) = skipn n h.

Corollary prev_taken_In : forall h, prev_taken h = vint 1 \/ In (AE (prev_taken h) Empty) h.

Lemma write_val : forall h i v (Hh : apply_hist i (rev h) = Some v), v = Empty \/ v = fst (find_write h i).

Lemma find_write_read : forall i d h (Hread : apply_hist i (rev h) = Some Empty) (Hi : i <> Empty),
  fst (find_read h d) = fst (find_write h i).

Lemma take_read : forall h v, apply_hist (vint 0) (rev h) = Some v ->
  prev_taken h = if eq_dec v Empty then snd (last_two_reads h)
                 else fst (last_two_reads h).

Lemma find_write_In : forall d h, fst (find_write h d) = d \/ exists r, In (AE r (fst (find_write h d))) h.

Lemma make_shares_app : forall i l1 l2 shs, Zlength l1 + Zlength l2 <= Zlength shs ->
  make_shares shs (l1 ++ l2) i =
  make_shares shs l1 i ++ make_shares (sublist (Zlength l1) (Zlength shs) shs) l2 i.

Lemma make_shares_out : forall b lgood lasts shs (Hb : ~In b lasts)
  (Hlen1 : Zlength lgood = Zlength shs) (Hlen2 : Zlength lasts = Zlength shs),
  make_shares shs (combine lgood lasts) b = map snd (filter fst (combine lgood shs)).

Lemma make_shares_ext : forall i d l l' lgood shs (Hlen : Zlength l = Zlength l')
  (Hi : forall j, 0 <= j < Zlength l -> Znth j l d = i <-> Znth j l' d = i),
  make_shares shs (combine lgood l) i = make_shares shs (combine lgood l') i.

Lemma make_shares_add : forall i i' d lasts lgood j shs (Hj : 0 <= j < Zlength lasts)
  (Hi : Znth j lasts d = i) (Hgood : Znth j lgood false = true) (Hi' : i' <> i)
  (Hlen : Zlength shs >= Zlength lasts),
  exists shs1 shs2, make_shares shs (combine lgood lasts) i = shs1 ++ shs2 /\
    make_shares shs (combine lgood (upd_Znth j lasts i')) i = shs1 ++ Znth j shs Tsh :: shs2.

Lemma make_shares_In : forall i lasts lgood x shs (Hx : 0 <= x < Zlength lasts)
  (Hi : Znth x lasts 0 <> i) (Hgood : Znth x lgood false = true)
  (Hlen : Zlength shs >= Zlength lasts),
  In (Znth x shs Tsh) (make_shares shs (combine lgood lasts) i).

Lemma make_shares_sub : forall i lasts shs sh0 sh1 sh2 (Hlen : Zlength shs >= Zlength lasts)
  (Hsh1 : sepalg_list.list_join sh0 shs sh1) (Hsh2 : sepalg_list.list_join sh0 (make_shares shs lasts i) sh2),

Lemma combine_nil : forall {A B} (l : list A), combine l (@nil B) = [].

Lemma make_shares_join : forall i d lasts lgood shs sh0 j sh1 sh2
  (Hlen : Zlength shs >= Zlength lasts)
  (Hsh1 : sepalg_list.list_join sh0 shs sh1)

Lemma data_at_buffer_cohere : forall sh1 sh2 v1 v2 p, readable_share sh1 ->
  data_at sh1 tbuffer v1 p * data_at sh2 tbuffer v2 p |--
  data_at sh1 tbuffer v1 p * data_at sh2 tbuffer v1 p.

Lemma make_shares_add' : forall i i' d lasts lgood j shs (Hj : 0 <= j < Zlength lasts)
  (Hi : Znth j lasts d = i) (Hgood : Znth j lgood false = false)
  (Hlen : Zlength shs >= Zlength lasts),
  make_shares shs (combine lgood (upd_Znth j lasts i')) i = make_shares shs (combine lgood lasts) i.

Lemma make_shares_ext' : forall i d l l' lgood shs (Hlen : Zlength l = Zlength l')
  (Hi : forall j, 0 <= j < Zlength l -> Znth j lgood false = true -> Znth j l d = i <-> Znth j l' d = i),
  make_shares shs (combine lgood l) i = make_shares shs (combine lgood l') i.

Lemma upd_write_shares : forall bufs b b0 lgood lasts shs sh0 (Hb : 0 <= b < B) (Hb0 : 0 <= b0 < B)
  (Hlasts : Forall (fun x : Z => 0 <= x < B) lasts) (Hshs : Zlength shs = N)
  (Hread : Forall readable_share shs) (Hsh0 : sepalg_list.list_join sh0 shs Tsh)

Lemma body_finish_write : semax_body Vprog Gprog f_finish_write finish_write_spec. *)

Set Bullet Behavior "Strict Subproofs".

Lemma body_surely_malloc: semax_body Vprog Gprog f_surely_malloc surely_malloc_spec.
Proof.
  start_function.
  forward_call n.
  Intros p.
  forward_if
  (PROP ( )
   LOCAL (temp _p p)
   SEP (malloc_token Tsh n p * memory_block Tsh n p)).
  - if_tac; entailer!.
  - forward_call tt.
    contradiction.
  - if_tac.
    + forward. subst p. discriminate.
    + Intros. forward. entailer!.
  - forward. Exists p; entailer!.
Qed.

Lemma body_memset : semax_body Vprog Gprog f_memset memset_spec.
Proof.
  start_function.
  forward.
  rewrite data_at__isptr; Intros.
  rewrite sem_cast_neutral_ptr; auto.
  pose proof (sizeof_pos t).
  assert (vint n = force_val (sem_div tuint tint (vint (4 * n)) (vint 4))) as H4.
  { unfold sem_div; simpl.
    unfold Int.divu.
    rewrite !Int.unsigned_repr; auto; try (split; auto; try computable; omega).
    rewrite Z.mul_comm, Z_div_mult; auto; computable. }
  forward_for_simple_bound n (EX i : Z, PROP ()
    LOCAL (temp _p p; temp _s p; temp _c (vint c); temp _n (vint (4 * n)))
    SEP (data_at sh (tarray tint n) (repeat (vint c) (Z.to_nat i) ++ repeat Vundef (Z.to_nat (n - i))) p)).
  { entailer!.
    { rewrite H4; auto. }
    apply derives_trans with (Q := data_at_ sh (tarray tint n) p).
    - rewrite !data_at__memory_block; simpl.
      assert ((4 * Z.max 0 n)%Z = sizeof t) as Hsize.
      { rewrite Z.max_r; auto; omega. }
      setoid_rewrite Hsize; Intros; apply andp_right; [|simpl; apply derives_refl].
      apply prop_right; match goal with H : field_compatible _ _ _ |- _ =>
        destruct H as (? & ? & ? & ? & ? & ? & ? & ?) end; repeat split; simpl; auto.
      + unfold legal_alignas_type, tarray, nested_pred, local_legal_alignas_type; simpl.
        rewrite andb_true_r, Z.leb_le; omega.
      + setoid_rewrite Hsize; auto.
      + unfold size_compatible in *; simpl.
        destruct p; try contradiction.
        setoid_rewrite Hsize; auto.
      + unfold align_compatible in *; simpl.
        unfold align_attr in *; simpl.
        destruct p; try contradiction.
        etransitivity; eauto.
    - rewrite data_at__eq.
      unfold default_val, reptype_gen; simpl.
      rewrite repeat_list_repeat, Z.sub_0_r; apply derives_refl. }
  - forward.
    rewrite upd_init_const; [|omega].
    entailer!.
    rewrite H4; auto.
  - forward.
    rewrite Zminus_diag, app_nil_r; apply derives_refl.
Qed.

Opaque upto.

Lemma body_initialize_channels : semax_body Vprog Gprog f_initialize_channels initialize_channels_spec.
Proof.
  start_function.
  rewrite <- seq_assoc.
  forward_for_simple_bound B (EX i : Z, PROP ()
    LOCAL (gvar _comm comm; gvar _bufs buf; gvar _reading reading; gvar _last_read last_read)
    SEP (data_at_ Ews (tarray (tptr tint) N) comm;
         data_at_ Ews (tarray (tptr tint) N) reading; data_at_ Ews (tarray (tptr tint) N) last_read;
         EX bufs : list val, !!(Zlength bufs = i /\ Forall isptr bufs) &&
           data_at Ews (tarray (tptr tbuffer) B) (bufs ++ repeat Vundef (Z.to_nat (B - i))) buf *
           fold_right sepcon emp (map (@data_at CompSpecs Tsh tbuffer (vint 0)) bufs) *
           fold_right sepcon emp (map (malloc_token Tsh (sizeof tbuffer)) bufs))).
  { unfold B, N; computable. }
  { unfold B, N; computable. }
  { entailer!.
    Exists ([] : list val); simpl; entailer!. }
  { forward_call (sizeof tbuffer).
    { simpl; computable. }
    Intros b bufs.
    rewrite malloc_compat; auto; Intros.
    rewrite memory_block_data_at_; auto.
    assert_PROP (field_compatible tbuffer [] b) by entailer!.
    forward_call (Tsh, tbuffer, b, 0, 1).
    { repeat split; simpl; auto; try computable.
      apply Z.divide_refl. }
    forward.
    rewrite upd_init; auto; try omega.
    entailer!.
    Exists (bufs ++ [b]); rewrite Zlength_app, <- app_assoc, !map_app, !sepcon_app, Forall_app; simpl; entailer!.
    clear; unfold data_at, field_at, at_offset; Intros.
    rewrite !data_at_rec_eq; unfold withspacer; simpl.
    unfold array_pred, aggregate_pred.array_pred, unfold_reptype; simpl.
    entailer!.
    { exists 2; auto. } }
  Intros bufs; rewrite Zminus_diag, app_nil_r.
  forward_for_simple_bound N (EX i : Z, EX shi : share,
    PROP (sepalg_list.list_join shg (map snd (filter (fun '(b, _) => negb b)
      (sublist i N (combine lgood shs)))) shi)
    LOCAL (gvar _comm comm; gvar _bufs buf; gvar _reading reading; gvar _last_read last_read)
    SEP (EX comms : list val, EX g : list val, EX g0 : list val, EX g1 : list val,
         EX g2 : list val, !!(Zlength comms = i /\ Forall isptr comms /\ Forall isptr bufs /\
           Zlength g = i /\ Zlength g0 = i /\ Zlength g1 = i /\ Zlength g2 = i) &&
          (data_at Ews (tarray (tptr tint) N) (comms ++ repeat Vundef (Z.to_nat (N - i))) comm *
           fold_right sepcon emp (map (fun r => comm_loc (Znth r lgood false) Tsh (Znth r comms Vundef)
             (Znth r g Vundef) (Znth r g0 Vundef) (Znth r g1 Vundef) (Znth r g2 Vundef) bufs
             (Znth r shs Tsh) gsh2 []) (upto (Z.to_nat i))) *
           fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g0) *
           fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1) *
           fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2) *
           fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) comms));
         EX reads : list val, !!(Zlength reads = i) &&
           data_at Ews (tarray (tptr tint) N) (reads ++ repeat Vundef (Z.to_nat (N - i))) reading *
           fold_right sepcon emp (map (data_at_ Tsh tint) reads) *
           fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) reads);
         EX lasts : list val, !!(Zlength lasts = i) &&
           data_at Ews (tarray (tptr tint) N) (lasts ++ repeat Vundef (Z.to_nat (N - i))) last_read *
           fold_right sepcon emp (map (data_at_ Tsh tint) lasts) *
           fold_right sepcon emp (map (malloc_token Tsh (sizeof tint)) lasts);
         @data_at CompSpecs Ews (tarray (tptr tbuffer) B) bufs buf;
         EX sh : share, !!(sepalg_list.list_join sh1 (sublist i N shs) sh) &&
           @data_at CompSpecs sh tbuffer (vint 0) (Znth 0 bufs Vundef);
         fold_right sepcon emp (map (@data_at CompSpecs shi tbuffer (vint 0)) (sublist 1 (Zlength bufs) bufs));
         fold_right sepcon emp (map (malloc_token Tsh (sizeof tbuffer)) bufs))).
  { unfold N; computable. }
  { unfold N; computable. }
  { rewrite !sublist_same by (auto; rewrite Zlength_combine, Z.min_l; omega).
    Exists Tsh ([] : list val) ([] : list val) ([] : list val) ([] : list val) ([] : list val)
      ([] : list val) ([] : list val) Tsh; rewrite !data_at__eq; entailer!.
    - eapply list_join_minus; eauto; omega.
    - erewrite <- sublist_same with (al := bufs), sublist_next at 1; eauto; try (unfold B, N in *; omega).
      simpl; cancel. }
  { Intros comms g g0 g1 g2 reads lasts sh.
    forward_malloc tint c.
    forward.
    forward.
    forward_malloc tint rr.
    forward.
    forward_malloc tint ll.
    eapply (ghost_alloc (Tsh, vint 1)); auto with init.
    eapply (ghost_alloc (Tsh, vint 0)); auto with init.
    eapply (ghost_alloc (Tsh, vint 1)); auto with init.
    eapply (ghost_alloc (Some (Tsh, [] : hist), Some ([] : hist))); auto with init.
    Intros g' g0' g1' g2'.
    rewrite <- hist_ref_join_nil by apply Share.nontrivial.
    repeat match goal with |-context[ghost (Tsh, ?v) ?g] => fold (ghost_var Tsh v g) end.
    erewrite <- !ghost_var_share_join with (sh0 := Tsh) by eauto.
    match goal with H : sepalg_list.list_join sh1 (sublist i N shs) sh |- _ =>
      erewrite sublist_next in H; try omega; inversion H as [|????? Hj1 Hj2] end.
    apply sepalg.join_comm in Hj1; eapply sepalg_list.list_join_assoc1 in Hj2; eauto.
    destruct Hj2 as (sh' & ? & Hsh').
    erewrite <- data_at_share_join with (sh0 := sh) by (apply Hsh').
    assert (Zlength (combine lgood shs) = N) by (rewrite Zlength_combine, Z.min_l; omega).
    assert (exists sha x', sepalg_list.list_join shg
      (map snd (filter (fun '(b, _) => negb b) (sublist (i + 1) N (combine lgood shs)))) x' /\
      sepalg.join sha x' x /\ if Znth i lgood false then x' = x /\ sha = Share.bot else sha = a)
      as (sha & x' & ? & Hx & Hcase).
    { match goal with H : sepalg_list.list_join shg _ _ |- _ =>
        rewrite sublist_next with (d := (false, Tsh)), Znth_combine in H by omega; simpl in H end.
      destruct (Znth i lgood false); simpl in *; eauto 6.
      match goal with H : sepalg_list.list_join shg _ _ |- _ => inversion H as [|????? Hx1 Hx2]; subst end.
      destruct (sepalg_list.list_join_assoc1 (sepalg.join_comm Hx1) Hx2) as (? & ? & ?).
      do 3 eexists; eauto; split; eauto; discriminate. }
    replace (map (@data_at CompSpecs x tbuffer (vint 0)) (sublist 1 (Zlength bufs) bufs)) with
      (map (fun p => (if Znth i lgood false then emp else data_at sha tbuffer (vint 0) p) *
        data_at x' tbuffer (vint 0) p) (sublist 1 (Zlength bufs) bufs)).
    rewrite sepcon_map; Intros.
    gather_SEP 1 3 5 7 13 27 29; eapply make_inv with (Q := comm_inv (Znth i lgood false)
      c bufs (Znth i shs Tsh) g' g0' g1' g2' gsh2).
    { unfold comm_inv.
      Exists 0; cancel.
      destruct (Znth _ lgood false) eqn: Hgood.
      - Exists (@nil AE_hist_el); unfold comm_R.
        Exists 1 1; unfold last_two_reads, last_write, prev_taken; simpl; entailer!.
        Exists Int.zero; entailer!.
        rewrite fold_right_emp; auto.
        rewrite Forall_map, Forall_forall; auto.
      - Exists (@nil AE_hist_el) (vint 1) (vint 0) (vint 1); entailer!.
        assert (Zlength (data_at (Znth (Zlength comms) shs Tsh) tbuffer (vint 0) (Znth 0 bufs Vundef)
          :: map (fun x0 : val => data_at (Znth (Zlength comms) shs Tsh) tbuffer (vint 0) x0)
          (sublist 1 (Zlength bufs) bufs)) = B).
        { rewrite Zlength_cons, Zlength_map, Zlength_sublist; try omega.
          unfold B, N in *; omega. }
        apply sepcon_list_derives with (l1 := _ :: _).
        { rewrite Zlength_map; omega. }
        intros; erewrite Znth_map by omega.
        Exists Int.zero; destruct (eq_dec i 0).
        + subst; rewrite Znth_0_cons; auto.
        + rewrite Znth_pos_cons by omega.
          erewrite Znth_map, Znth_sublist, Z.sub_simpl_r; auto; try omega.
          rewrite Zlength_cons, Zlength_map in *; omega. }
    { unfold comm_inv, comm_R; prove_objective. }
    forward.
    Exists x' (comms ++ [c]) (g ++ [g']) (g0 ++ [g0']) (g1 ++ [g1']) (g2 ++ [g2'])
      (reads ++ [rr]) (lasts ++ [ll]) sh'; rewrite !upd_init; try omega.
    rewrite !Zlength_app, !Zlength_cons, !Zlength_nil; rewrite <- !app_assoc.
    go_lower.
    apply andp_right; [apply prop_right; split; auto; omega|].
    apply andp_right; [apply prop_right; repeat split; auto|].
    rewrite !sepcon_andp_prop'; apply andp_right; [apply prop_right; rewrite Forall_app; repeat split; auto;
      omega|].
    rewrite !sepcon_andp_prop; repeat (apply andp_right; [apply prop_right; auto; try omega|]).
    rewrite Z2Nat.inj_add, upto_app, !map_app, !sepcon_app; try omega; simpl.
    change (upto 1) with [0]; simpl.
    rewrite Z2Nat.id, Z.add_0_r by omega.
    rewrite !Znth_app1 by auto.
    subst; rewrite Zlength_correct, Nat2Z.id.
    rewrite !sem_cast_neutral_ptr by auto.
    erewrite map_ext_in; [unfold comm_loc; cancel|].
    intros; rewrite In_upto, <- Zlength_correct in *.
    rewrite !app_Znth1; try omega; reflexivity. 
    { apply map_ext; intro.
      if_tac.
      - rewrite emp_sepcon; f_equal; tauto.
      - subst; apply data_at_share_join; auto. } }
  Intros x comms g g0 g1 g2 reads lasts sh.
  match goal with H : sepalg_list.list_join _ (sublist N N shs) _ |- _ =>
    rewrite sublist_nil in H; inv H end.
  match goal with H : sepalg_list.list_join shg _ _ |- _ =>
    rewrite sublist_nil in H; inv H end.
  forward.
  rewrite !app_nil_r.
  Exists comms bufs reads lasts g g0 g1 g2; entailer!.
Qed.

Lemma body_reader : semax_body Vprog Gprog f_reader reader_spec.
Proof.
  start_function.
  rewrite (data_at_isptr _ tint); Intros.
  replace_SEP 0 (data_at Tsh tint (vint r) (force_val (sem_cast_neutral arg))).
  { rewrite sem_cast_neutral_ptr; auto; go_lowerx; cancel. }
  forward.
  forward_call (r, reading, last_read, reads, lasts, sh1).
  eapply semax_seq'; [|apply semax_ff].
  set (c := Znth r comms Vundef).
  eapply semax_pre with (P' := EX b0 : Z, EX h : hist, PROP (0 <= b0 < B; latest_read h b0)
    LOCAL (temp _r (vint r); temp _arg arg; gvar _reading reading; gvar _last_read last_read; 
           gvar _comm comm; gvar _bufs buf)
    SEP (data_at sh1 (tarray (tptr tint) N) reads reading; data_at sh1 (tarray (tptr tint) N) lasts last_read;
         data_at Tsh tint Empty (Znth r reads Vundef); data_at Tsh tint (vint b0) (Znth r lasts Vundef);
         data_at Tsh tint (vint r) (force_val (sem_cast_neutral arg)); malloc_token Tsh (sizeof tint) arg;
         data_at sh1 (tarray (tptr tint) N) comms comm;
         data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
         comm_loc good sh2 c g g0 g1 g2 bufs sh gsh2 h;
         if good then EX v : _, @data_at CompSpecs sh tbuffer (Vint v) (Znth b0 bufs Vundef) else emp;
         ghost_var gsh1 (vint b0) g0)).
  { Exists 1 ([] : hist); entailer!.
    unfold latest_read; auto. }
  eapply semax_loop; [|forward; apply ENTAIL_refl].
  Intros b0 h.
  forward.
  subst c; subst; forward_call (r, reading, last_read, comm, reads, lasts, good, comms, bufs,
    sh, sh1, sh2, b0, g, g0, g1, g2, h).
  { repeat (split; auto). }
  Intros x; destruct x as ((b, t), e); simpl in *.
  assert_PROP (Zlength bufs = B) as Hlen by entailer!.
  assert (isptr (Znth (if ((0 <=? e) && (e <? B))%bool then e else b0) bufs Vundef)).
  { apply Forall_Znth; auto; omega. }
  forward.
  forward_call (load_SC_witness (Znth b bufs Vundef)
    (if good then EX v : _, data_at sh tbuffer (Vint v) (Znth b bufs Vundef) else emp)
    (fun _ : Z => comm_inv good (Znth r comms Vundef) bufs sh g g0 g1 g2 gsh2) [0]
    (fun v' => if good then data_at sh tbuffer (vint v') (Znth b bufs Vundef) else emp)).
  { entailer!. }
  { simpl; unfold comm_loc; cancel. }
  { apply wand_view_shifts2.
    apply derives_view_shift.
    simpl; unfold comm_inv.
    Exists sh; Intros b'; destruct good.
    - Intros v; Exists (Int.signed v).
      unfold_data_at 2%nat.
      rewrite field_at_data_at'; simpl; rewrite Int.repr_signed, sepcon_andp_prop'; apply andp_right.
      { entailer!.
        apply Int.signed_range; auto. }
      entailer!.
      rewrite <- wand_sepcon_adjoint.
      Exists b' x; entailer!.
      unfold_data_at 2%nat.
      rewrite field_at_data_at'; simpl; entailer!; auto.
    - rewrite !sepcon_emp, <- !sepcon_assoc, sepcon_comm.
      rewrite extract_nth_sepcon with (i := b) by (rewrite Zlength_map; omega).
      erewrite Znth_map by omega; Intro v.
      Exists (Int.signed v); rewrite Int.repr_signed.
      rewrite !sepcon_assoc; apply sepcon_derives.
      { unfold_data_at 1%nat.
        rewrite field_at_data_at'; entailer!; eauto.
        apply Int.signed_range; auto. }
      rewrite <- wand_sepcon_adjoint.
      rewrite <- !exp_sepcon1; cancel.
      Exists b' v; entailer!.
      unfold_data_at 2%nat.
      rewrite field_at_data_at'; simpl; entailer!; auto. }
  Intros d.
  forward_call (r, reading, reads, sh1).
  go_lower.
  Exists b (h ++ [(t, AE (vint e) Empty)]); unfold comm_loc; entailer!.
  if_tac; auto; Exists (Int.repr d); auto.
Qed.

Lemma sepcon_filter_combine : forall {A} P (l : list A) l', Zlength l' = Zlength l ->
  fold_right sepcon emp (map P l) =
  fold_right sepcon emp (map P (map snd (filter fst (combine l' l)))) *
  fold_right sepcon emp (map P (map snd (filter (fun '(b, _) => negb b) (combine l' l)))).
Proof.
  induction l; intros.
  { rewrite combine_nil; simpl; rewrite sepcon_emp; auto. }
  destruct l'; [symmetry in H; apply Zlength_nil_inv in H; discriminate|].
  simpl.
  rewrite !Zlength_cons in *; rewrite (IHl l') by omega.
  destruct b; simpl; apply mpred_ext; cancel.
Qed.

Lemma data_at_shares_join' : forall {cs} sh v p shs sh1
  (Hsplit : sepalg_list.list_join sh1 shs sh), readable_share sh1 ->
  @data_at cs sh1 tint (Vint v) p *
    fold_right_sepcon (map (fun sh => EX v : _, data_at sh tint (Vint v) p) shs) =
  data_at sh tint (Vint v) p.
Proof.
  induction shs; intros; simpl.
  - inv Hsplit.
    rewrite sepcon_emp; auto.
  - inv Hsplit.
    erewrite <- IHshs; eauto.
    apply mpred_ext; cancel; rewrite <- (data_at_share_join sh1 a w1) by auto.
    + Intro v'; apply data_at_value_cohere; auto.
    + Exists v; auto.
    + eapply readable_share_join; eauto.
Qed.

Lemma map_snd_filter_fst : forall {A B C} f (g : B -> C) (l : list (A * B)),
  filter (fun '(a, _) => f a) (map (fun '(a, b) => (a, g b)) l) =
  map (fun '(a, b) => (a, g b)) (filter (fun '(a, _) => f a) l).
Proof.
  induction l; auto; simpl.
  destruct a.
  rewrite IHl; if_tac; auto.
Qed.

Lemma body_writer : semax_body Vprog Gprog f_writer writer_spec.
Proof.
  start_function.
  forward_call (writing, last_given, last_taken).
  forward.
  eapply semax_seq'; [|apply semax_ff].
  eapply semax_pre with (P' := EX v : Z, EX b0 : Z, EX lasts : list Z, EX h : list hist,
   PROP (0 <= b0 < B; Forall (fun x => 0 <= x < B) lasts; Zlength h = N; ~In b0 lasts)
   LOCAL (temp _v (vint v); temp _arg arg; gvar _writing writing; gvar _last_given last_given;
   gvar _last_taken last_taken; gvar _comm comm; gvar _bufs buf)
   SEP (data_at Ews tint Empty writing; data_at Ews tint (vint b0) last_given;
   data_at Ews (tarray tint N) (map (fun x => vint x) lasts) last_taken;
   data_at sh1 (tarray (tptr tint) N) comms comm; data_at sh1 (tarray (tptr tbuffer) B) bufs buf;
   fold_right sepcon emp (map (fun r0 => comm_loc (Znth r0 lgood false) lsh (Znth r0 comms Vundef)
     (Znth r0 g Vundef) (Znth r0 g0 Vundef) (Znth r0 g1 Vundef) (Znth r0 g2 Vundef) bufs
     (Znth r0 shs Tsh) gsh2 (Znth r0 h [])) (upto (Z.to_nat N)));
   fold_right sepcon emp (map (fun r0 => ghost_var gsh1 (vint b0) (Znth r0 g1 Vundef) *
     ghost_var gsh1 (vint (Znth r0 lasts (-1))) (Znth r0 g2 Vundef)) (upto (Z.to_nat N)));
   fold_right sepcon emp (map (fun i => EX sh : share, !! (if eq_dec i b0 then sh = sh0
     else sepalg_list.list_join sh0 (make_shares shs (combine lgood lasts) i) sh) &&
     (EX v : _, @data_at CompSpecs sh tbuffer (Vint v) (Znth i bufs Vundef))) (upto (Z.to_nat B))))).
  { Exists 0 0 (repeat 1 (Z.to_nat N)) (repeat ([] : hist) (Z.to_nat N)); entailer!.
    { split; [repeat constructor; computable | omega]. }
    rewrite sepcon_map.
    apply derives_refl'.
    rewrite !sepcon_assoc; f_equal; f_equal; [|f_equal].
    - rewrite list_Znth_eq with (l := g1) at 1.
      replace (length g1) with (Z.to_nat N) by (symmetry; rewrite <- Zlength_length; auto; unfold N; computable).
      rewrite map_map; auto.
    - rewrite list_Znth_eq with (l := g2) at 1.
      replace (length g2) with (Z.to_nat N) by (symmetry; rewrite <- Zlength_length; auto; unfold N; computable).
      erewrite map_map, map_ext_in; eauto.
      intros; rewrite In_upto in *.
      match goal with |- context[Znth a ?l (-1)] => replace (Znth a l (-1)) with 1; auto end.
      apply Forall_Znth; auto.
    - erewrite map_ext_in; eauto.
      intros; rewrite In_upto in *.
      destruct (eq_dec a 0); auto.
      replace (make_shares _ _ _) with
        (if eq_dec a 1 then [] else map snd (filter fst (combine lgood shs))).
      destruct (eq_dec a 1), (eq_dec 1 a); auto; try omega; apply mpred_ext; Intros sh; Exists sh;
        entailer!.
      + constructor.
      + match goal with H : sepalg_list.list_join sh0 [] sh |- _ => inv H; auto end.
      + eapply list_join_eq; eauto.
      + if_tac.
        * subst; destruct lgood; auto; simpl.
          rewrite orb_true_r; destruct lgood; auto; simpl.
          rewrite orb_true_r; destruct lgood; auto; simpl.
          rewrite orb_true_r, combine_nil; auto.
        * symmetry; apply make_shares_out; auto; [|unfold share in *; omega].
          intros [|[|[|]]]; auto. }
  eapply semax_loop; [|forward; apply ENTAIL_refl].
  Intros v b0 lasts h.
  rewrite sepcon_map; Intros.
  forward.
  forward_call (writing, last_given, last_taken, b0, lasts).
  Intros b.
  rewrite (extract_nth_sepcon (map _ (upto (Z.to_nat B))) b); [|rewrite Zlength_map; auto].
  erewrite Znth_map, Znth_upto; auto; rewrite ?Z2Nat.id; try omega.
  Intros sh v0.
  rewrite (data_at_isptr _ tbuffer); Intros.
  forward.
  destruct (eq_dec b b0); [absurd (b = b0); auto|].
  assert_PROP (Zlength lasts = N).
  { gather_SEP 2; go_lowerx; apply sepcon_derives_prop.
    eapply derives_trans; [apply data_array_at_local_facts|].
    apply prop_left; intros (_ & ? & _); apply prop_right.
    unfold unfold_reptype in *; simpl in *.
    rewrite Zlength_map in *; auto. }
  rewrite make_shares_out in *; auto; unfold share in *; try omega.
  assert (sh = shg) by (eapply list_join_eq; eauto); subst.
  assert_PROP (Zlength bufs = B) by entailer!.
  forward_call (store_SC_witness (Znth b bufs Vundef) (Int.signed (Int.repr v))
    (data_at shg tbuffer (Vint v0) (Znth b bufs Vundef))
    (fun r => comm_inv (Znth r lgood false) (Znth r comms Vundef) bufs (Znth r shs Tsh)
      (Znth r g Vundef) (Znth r g0 Vundef) (Znth r g1 Vundef) (Znth r g2 Vundef) gsh2)
    (map snd (filter (fun '(b, _) => negb b) (combine lgood (upto (Z.to_nat N)))))
    (data_at shg tbuffer (vint v) (Znth b bufs Vundef))).
  { entailer!.
    rewrite Int.repr_signed; auto. }
  { unfold comm_loc; rewrite sepcon_map.
    rewrite sepcon_filter_combine with (l' := lgood) by auto; cancel. }
  { split; [apply Int.signed_range; auto|].
    apply wand_view_shifts.
    apply derives_view_shift.
    Exists Tsh; rewrite Int.repr_signed, !prop_true_andp by auto.
    unfold_data_at 1%nat.
    rewrite field_at_data_at'; simpl; Intros.
    erewrite wand_sepcon_map with
      (P := fun r => EX v : _, data_at (Znth r shs Tsh) tint (Vint v) (Znth b bufs Vundef)) at 1.
    rewrite data_at__eq.
    assert (Zlength lgood = Zlength shs) by omega.
    assert (readable_share shg) by (eapply readable_share_list_join; eauto).
    assert (map (fun sh => EX v1 : _, data_at sh tint (Vint v1) (Znth b bufs Vundef))
     (map snd (filter (fun '(b1, _) => negb b1) (combine lgood shs))) =
     map (fun r => EX v1 : _, data_at (Znth r shs Tsh) tint (Vint v1) (Znth b bufs Vundef))
     (map snd (filter (fun '(b1, _) => negb b1) (combine lgood (upto 3))))) as Heq.
    { setoid_rewrite (list_Znth_eq Tsh shs) at 1.
      rewrite <- ZtoNat_Zlength; unfold share in *; replace (Zlength shs) with N; unfold N; simpl.
      rewrite combine_map_snd, map_snd_filter_fst, !map_map.
      apply map_ext; intros (?, ?); auto. }
    rewrite sepcon_comm, <- sepcon_assoc; apply sepcon_derives.
    - apply derives_trans with (Q := data_at Tsh tint (Vint v0) (Znth b bufs Vundef)); [|cancel].
      erewrite <- data_at_shares_join' with (sh := Tsh) by (try eapply list_join_minus; eauto).
      unfold share; rewrite <- data_at_offset_zero, Heq; auto.
    - erewrite <- data_at_shares_join' with (sh := Tsh) by (try eapply list_join_minus; eauto).
      unfold_data_at 4%nat.
      rewrite field_at_data_at'; simpl.
      rewrite <- data_at_offset_zero, prop_true_andp by auto.
      unfold share; rewrite Heq, sepcon_comm; apply wand_frame.
    - intro; rewrite in_map_iff.
      intros ((good, ?) & ? & Hi); rewrite filter_In in Hi.
      destruct Hi as (Hi & ?); simpl in *; subst; destruct good; try discriminate.
      eapply In_Znth in Hi.
      destruct Hi as (? & Hrange & Hi).
      assert (Zlength lgood = Zlength (upto 3)) by auto.
      rewrite Zlength_combine, Z.min_r, Zlength_upto in Hrange by omega.
      rewrite Znth_combine with (a := false)(b1 := 3) in Hi by auto; inversion Hi as [Hbad].
      rewrite Znth_upto in * by omega; subst.
      rewrite !Hbad.
      unfold comm_inv.
      rewrite <- exp_sepcon1.
      rewrite sepcon_comm, (sepcon_comm _ (fold_right _ _ _)).
      rewrite extract_nth_sepcon with (i := b) by (rewrite Zlength_map; omega).
      erewrite Znth_map by omega.
      rewrite 2sepcon_assoc; f_equal; [|reflexivity].
      f_equal; extensionality.
      unfold_data_at 1%nat.
      rewrite field_at_data_at'; simpl.
      rewrite <- data_at_offset_zero, prop_true_andp by eauto; auto. }
  forward_call (writing, last_given, last_taken, comm, comms, bufs, lgood, b, b0, lasts,
    sh1, lsh, shs, g, g0, g1, g2, h, sh0).
  { unfold comm_loc; rewrite !sepcon_map; cancel.
    rewrite sepcon_filter_combine with (l := upto (Z.to_nat N))(l' := lgood) by auto; cancel.
    rewrite sepcon_assoc, (sepcon_comm (data_at sh1 _ _ _)), <- sepcon_assoc.
    apply sepcon_derives; [|cancel_frame].
    rewrite replace_nth_sepcon; apply sepcon_list_derives; rewrite upd_Znth_Zlength; auto.
    rewrite Zlength_map; intros.
    destruct (eq_dec i b); [|rewrite upd_Znth_diff'; auto].
    subst; rewrite upd_Znth_same by auto.
    erewrite Znth_map, Znth_upto by (auto; simpl; unfold B, N in *; omega).
    if_tac; [contradiction|].
    rewrite make_shares_out by (auto; omega).
    Exists shg (Int.repr v); entailer!. }
  { repeat (split; auto). }
  Intros x; destruct x as (lasts', h').
  rewrite sepcon_map; Intros.
  forward.
  unfold loop2_ret_assert; Exists (v + 1) b lasts' h'; rewrite sepcon_map; entailer!.
  replace N with (Zlength h) by auto; symmetry; eapply mem_lemmas.Forall2_Zlength; eauto.
Qed.

Lemma comm_loc_share_join : forall good lsh1 lsh2 lsh comm g g0 g1 g2 bufs sh gsh h1 h2 h
  (Hsh : sepalg.join lsh1 lsh2 lsh) (Hh : Permutation.Permutation (h1 ++ h2) h)
  (Hsh1 : lsh1 <> Share.bot) (Hsh2 : lsh2 <> Share.bot) (Hdisj : disjoint h1 h2),
  comm_loc good lsh1 comm g g0 g1 g2 bufs sh gsh h1 *
  comm_loc good lsh2 comm g g0 g1 g2 bufs sh gsh h2 =
  comm_loc good lsh comm g g0 g1 g2 bufs sh gsh h.
Proof.
  intros; unfold comm_loc.
  rewrite !sepcon_assoc, (sepcon_comm _ (invariant _ * _)).
  rewrite <- !sepcon_assoc, <- invariant_duplicable.
  erewrite sepcon_assoc, (sepcon_comm (ghost_hist _ _ _)), ghost_hist_join by eauto.
  rewrite prop_true_andp; auto.
Qed.

Lemma body_main : semax_body Vprog Gprog f_main main_spec.
Proof.
  start_function.
  exploit (split_shares (Z.to_nat N) Tsh); auto; intros (sh0 & shs & ? & ? & ? & Hshs).
  rewrite Z2Nat.id in H by (unfold N; omega).
  
  destruct (eq_dec shs nil).
  { subst; unfold N in *; rewrite Zlength_nil in *; omega. }
  destruct (exists_last n) as (shs' & sh2 & ?); subst.
  destruct (sepalg_list.list_join_unapp Hshs) as (shg & ? & ?).
  set (shs := shs' ++ [sh2]) in *.
  assert (shs' = map snd (filter fst (combine [true; true; false] shs))) as Hshg.
  { simpl.
    destruct shs eqn: Hshs'; [contradiction | simpl].
    unfold N in *; rewrite Zlength_cons in *; destruct l; [rewrite Zlength_nil in *; omega | simpl].
    rewrite Zlength_cons in *; destruct l; [rewrite Zlength_nil in *; omega | simpl].
    rewrite Zlength_cons in *; destruct l; [|rewrite Zlength_cons in *; pose proof (Zlength_nonneg l); omega].
    subst shs.
    destruct shs'; [discriminate | inv Hshs'].
    destruct shs'; [discriminate | match goal with H : _ = _ |- _ => inv H end].
    destruct shs'; match goal with H : _ ++ _ = _ |- _ => inv H; auto end.
    destruct shs'; discriminate. }
  rewrite Hshg in *.
  set (lgood := [true; true; false]) in *.
  forward_call (lgood, v_comm, v_bufs, v_reading, v_last_read, sh0, shs, shg).
  { unfold B, N, tbuffer, _buffer; simpl; cancel. }
  Intros x; destruct x as (((((((comms, bufs), reads), lasts), g), g0), g1), g2); simpl fst in *; simpl snd in *.
  assert_PROP (Zlength comms = N) by entailer!.
  get_global_function'' _writer; Intros.
  apply extract_exists_pre; intros writer_.
  exploit (split_shares (Z.to_nat N) Ews); auto; intros (sh1 & shs1 & ? & ? & ? & ?).
  assert_PROP (Zlength bufs = B) by entailer!.
  forward_spawn (list bool * val * val * val * val * val * list val * list val * share * share *
                      share * list share * share * list val * list val * list val * list val)%type
    (writer_, vint 0, fun x : (list bool * val * val * val * val * val * list val * list val * share * share *
                      share * list share * share * list val * list val * list val * list val) =>
      let '(lgood, v_writing, v_last_given, v_last_taken, v_comm, v_bufs, comms, bufs, sh1, lsh, sh0, shs, shg,
            g, g0, g1, g2) := x in
      [(_writing, v_writing); (_last_given, v_last_given); (_last_taken, v_last_taken); (_comm, v_comm); (_bufs, v_bufs)],
    (lgood, v_writing, v_last_given, v_last_taken, v_comm, v_bufs, comms, bufs, sh1, gsh1, sh0, shs, shg,
                       g, g0, g1, g2),
    fun (x : (list bool * val * val * val * val * val * list val * list val * share * share *
                      share * list share * share * list val * list val * list val * list val)%type)
        (arg : val) =>
    let '(lgood, v_writing, v_last_given, v_last_taken, v_comm, v_bufs, comms, bufs, sh1, lsh, sh0, shs, shg,
          g, g0, g1, g2) := x in
      fold_right sepcon emp [!!(fold_right and True [Zlength lgood = N; Zlength shs = N;
        readable_share sh1; readable_share lsh; readable_share sh0;
        Forall readable_share shs; sepalg_list.list_join sh0 shs Tsh;
        sepalg_list.list_join sh0 (map snd (filter fst (combine lgood shs))) shg;
        Zlength g1 = N; Zlength g2 = N; Forall isptr comms]) && emp;
        data_at_ Ews tint v_writing; data_at_ Ews tint v_last_given; data_at_ Ews (tarray tint N) v_last_taken;
        data_at sh1 (tarray (tptr tint) N) comms v_comm; data_at sh1 (tarray (tptr tbuffer) B) bufs v_bufs;
        fold_right sepcon emp (map (fun r => comm_loc (Znth r lgood false) lsh (Znth r comms Vundef)
          (Znth r g Vundef) (Znth r g0 Vundef) (Znth r g1 Vundef) (Znth r g2 Vundef) bufs
          (Znth r shs Tsh) gsh2 []) (upto (Z.to_nat N)));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 0)) g1);
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) g2);
        fold_right sepcon emp (map (fun i => EX sh : share,
          !!(if eq_dec i 0 then sh = sh0 else if eq_dec i 1 then sh = sh0 else sh = shg) &&
          EX v : _, data_at sh tbuffer (Vint v) (Znth i bufs Vundef)) (upto (Z.to_nat B)))]).
  { apply andp_right.
    { entailer!. }
    unfold spawn_pre, PROPx, LOCALx, SEPx.
    go_lowerx.
    rewrite !sepcon_andp_prop, !sepcon_andp_prop'.
    apply andp_right; [apply prop_right; auto|].
    apply andp_right; [apply prop_right; repeat split; auto|].
    apply andp_right; [apply prop_right; repeat split; auto|].
    apply andp_right; [apply prop_right|].
    { unfold liftx; simpl; unfold lift, make_args'; simpl.
      erewrite gvar_eval_var, !(force_val_sem_cast_neutral_gvar' _ writer_) by eauto.
      rewrite eval_id_same, eval_id_other, eval_id_same; [|discriminate].
      repeat split; auto; apply gvar_denote_global; auto. }
    Exists _arg.
    rewrite !sepcon_assoc; apply sepcon_derives.
    { apply derives_refl'.
      f_equal; f_equal; extensionality; destruct x as (?, x); repeat destruct x as (x, ?); simpl.
      rewrite !sepcon_andp_prop'; extensionality.
      rewrite <- andp_assoc, prop_true_andp with (P := True); auto.
      rewrite (andp_comm (!! _) (!! _)), andp_assoc; f_equal; f_equal.
      rewrite emp_sepcon, !sepcon_emp; auto. }
    rewrite sepcon_andp_prop'.
    apply andp_right; [apply prop_right; repeat (split; auto)|].
    erewrite map_ext by (intro; erewrite <- comm_loc_share_join with (h1 := [])(h2 := []); eauto; reflexivity).
    rewrite !sepcon_map.
    do 2 (erewrite <- (data_at_shares_join Ews); eauto).
    rewrite (extract_nth_sepcon (map (data_at _ _ _) (sublist 1 _ bufs)) 0), Znth_map with (d' := Vundef);
      rewrite ?Zlength_map, ?Zlength_sublist; try (unfold B, N in *; omega).
    erewrite <- (data_at_shares_join shg) by eauto.
    rewrite (sepcon_comm (data_at sh0 _ _ (Znth 0  (sublist _ _ bufs) Vundef))),
      (sepcon_assoc _ (data_at sh0 _ _ _)).
    rewrite replace_nth_sepcon.
    fast_cancel.
    rewrite <- !sepcon_assoc, (sepcon_comm _ (data_at sh0 _ _ _)).
    rewrite <- !sepcon_assoc, (sepcon_comm _ (fold_right sepcon emp (upd_Znth 0 _ _))), !sepcon_assoc.
    rewrite <- sepcon_assoc; apply sepcon_derives; [|cancel_frame].
    assert (Zlength (data_at sh0 tbuffer (vint 0) (Znth 0 bufs Vundef)
         :: upd_Znth 0 (map (data_at shg tbuffer (vint 0)) (sublist 1 (Zlength bufs) bufs))
              (data_at sh0 tbuffer (vint 0) (Znth 0 (sublist 1 (Zlength bufs) bufs) Vundef))) = B) as Hlen.
    { rewrite Zlength_cons, upd_Znth_Zlength; rewrite Zlength_map, Zlength_sublist, ?Zlength_upto;
        simpl; unfold B, N in *; omega. }
    rewrite sepcon_comm; apply sepcon_list_derives with (l1 := _ :: _).
    { rewrite Zlength_map; auto. }
    intros; rewrite Hlen in *.
    erewrite Znth_map, Znth_upto; rewrite ?Zlength_upto; auto; simpl; try (unfold B, N in *; omega).
    destruct (eq_dec i 0); [|destruct (eq_dec i 1)].
    - subst i; rewrite Znth_0_cons.
      Exists sh0 Int.zero; entailer!.
    - subst i; rewrite Znth_pos_cons, Zminus_diag, upd_Znth_same; rewrite ?Zlength_map, ?Zlength_sublist; try omega.
      rewrite Znth_sublist; try omega.
      Exists sh0 Int.zero; entailer!.
    - rewrite Znth_pos_cons, upd_Znth_diff; rewrite ?Zlength_map, ?Zlength_sublist; try omega.
      erewrite Znth_map; [|rewrite Zlength_sublist; omega].
      rewrite Znth_sublist; try omega.
      rewrite Z.sub_simpl_r.
      Exists shg Int.zero; entailer!. }
  rewrite Znth_sublist; try (unfold B, N in *; omega).
  rewrite <- seq_assoc.
  assert_PROP (Zlength reads = N) by entailer!.
  assert_PROP (Zlength lasts = N) by entailer!.
  assert (Zlength lgood = N) by auto.
  clearbody lgood.
  forward_for_simple_bound N (EX i : Z, PROP ( )
   LOCAL (gvar _last_given v_last_given; gvar _writing v_writing; gvar _last_taken v_last_taken;
          gvar _last_read v_last_read; gvar _reading v_reading; gvar _comm v_comm; gvar _bufs v_bufs)
   SEP (EX sh' : share, !!(sepalg_list.list_join sh1 (sublist i N shs1) sh') &&
          data_at sh' (tarray (tptr tint) N) lasts v_last_read * data_at sh' (tarray (tptr tint) N) reads v_reading;
        fold_right sepcon emp (map (fun sh => data_at sh (tarray (tptr tint) N) comms v_comm) (sublist i N shs1));
        fold_right sepcon emp (map (fun sh => data_at sh (tarray (tptr tbuffer) B) bufs v_bufs) (sublist i N shs1));
        fold_right sepcon emp (map (fun x => comm_loc (Znth x lgood false) gsh2 (Znth x comms Vundef)
          (Znth x g Vundef) (Znth x g0 Vundef) (Znth x g1 Vundef) (Znth x g2 Vundef) bufs (Znth x shs Tsh) gsh2
          []) (sublist i N (upto (Z.to_nat N))));
        fold_right sepcon emp (map (ghost_var gsh1 (vint 1)) (sublist i N g0));
        fold_right sepcon emp (map (data_at_ Tsh tint) (sublist i N reads));
        fold_right sepcon emp (map (data_at_ Tsh tint) (sublist i N lasts));
        fold_right sepcon emp (map (malloc_token Tsh 4) comms);
        fold_right sepcon emp (map (malloc_token Tsh 4) bufs);
        fold_right sepcon emp (map (malloc_token Tsh 4) reads);
        fold_right sepcon emp (map (malloc_token Tsh 4) lasts);
        fold_right sepcon emp (map (fun sh => @data_at CompSpecs sh tbuffer (vint 0) (Znth 1 bufs Vundef))
          (map snd (filter fst (sublist i N (combine lgood shs))))))).
  { unfold N; computable. }
  { unfold N; computable. }
  { Exists Ews; rewrite !sublist_same by (auto; rewrite Zlength_combine, Z.min_l; auto; omega).
    entailer!. }
  { Intros sh'.
    forward_malloc tint d.
    forward.
    get_global_function'' _reader; Intros.
    apply extract_exists_pre; intros reader_.
    rewrite Z2Nat.id in * by omega.
    match goal with H : sepalg_list.list_join sh1 _ sh' |- _ =>
      rewrite sublist_next with (d0 := Tsh) in H by (auto; omega); inversion H as [|????? Hj1 Hj2] end.
    apply sepalg.join_comm in Hj1; destruct (sepalg_list.list_join_assoc1 Hj1 Hj2) as (sh1' & ? & Hj').
    forward_spawn (Z * bool * val * val * val * val * list val * list val * list val * list val *
                      share * share * share * val * val * val * val)%type
      (reader_, d, fun x : (Z * bool * val * val * val * val * list val * list val * list val * list val *
                      share * share * share * val * val * val * val) =>
        let '(r, good, v_reading, v_last_read, v_comm, v_bufs, reads, lasts, comms, bufs, sh1, sh2, sh,
              g, g0, g1, g2) := x in
        [(_reading, v_reading); (_last_read, v_last_read); (_comm, v_comm); (_bufs, v_bufs)],
      (i, Znth i lgood false, v_reading, v_last_read, v_comm, v_bufs, reads, lasts, comms, bufs,
                    Znth i shs1 Tsh, gsh2, Znth i shs Tsh, Znth i g Vundef, Znth i g0 Vundef, Znth i g1 Vundef,
                    Znth i g2 Vundef),
      fun (x : (Z * bool * val * val * val * val * list val * list val * list val * list val *
                      share * share * share * val * val * val * val)%type) (arg : val) =>
        let '(r, good, v_reading, v_last_read, v_comm, v_bufs, reads, lasts, comms, bufs, sh1, sh2, sh,
              g, g0, g1, g2) := x in
        fold_right sepcon emp [!!(fold_right and True [readable_share sh; readable_share sh1;
          readable_share sh2; isptr (Znth r comms Vundef); Forall isptr bufs]) && emp;
          data_at Tsh tint (vint r) arg; malloc_token Tsh (sizeof tint) arg;
          data_at sh1 (tarray (tptr tint) N) reads v_reading; data_at sh1 (tarray (tptr tint) N) lasts v_last_read;
          data_at sh1 (tarray (tptr tint) N) comms v_comm;
          data_at_ Tsh tint (Znth r reads Vundef); data_at_ Tsh tint (Znth r lasts Vundef);
          data_at sh1 (tarray (tptr tbuffer) B) bufs v_bufs;
          comm_loc good sh2 (Znth r comms Vundef) g g0 g1 g2 bufs sh gsh2 [];
          if good then EX v : _, data_at sh tbuffer (Vint v) (Znth 1 bufs Vundef) else emp;
          ghost_var gsh1 (vint 1) g0]).
    - apply andp_right.
      { entailer!. }
      unfold spawn_pre, PROPx, LOCALx, SEPx.
      go_lowerx.
      rewrite !sepcon_andp_prop, !sepcon_andp_prop'.
      apply andp_right; [apply prop_right; auto|].
      apply andp_right; [apply prop_right; repeat split; auto|].
      apply andp_right; [apply prop_right; repeat split; auto|].
      apply andp_right; [apply prop_right|].
      { unfold liftx; simpl; unfold lift, make_args'; simpl.
        erewrite gvar_eval_var, !(force_val_sem_cast_neutral_gvar' _ reader_) by eauto.
        rewrite eval_id_same, eval_id_other, eval_id_same; [|discriminate].
        replace (eval_id _d rho) with d.
        rewrite force_val_sem_cast_neutral_isptr'; rewrite force_val_sem_cast_neutral_isptr'; auto.
        repeat split; auto; apply gvar_denote_global; auto. }
      Exists _arg.
      rewrite !sepcon_assoc; apply sepcon_derives.
      { apply derives_refl'.
        f_equal; f_equal; extensionality; destruct x as (?, x); repeat destruct x as (x, ?); simpl.
        rewrite !sepcon_andp_prop'; extensionality.
        rewrite <- andp_assoc, prop_true_andp with (P := True); auto.
        rewrite (andp_comm (!! _) (!! _)), andp_assoc; f_equal; f_equal.
        rewrite emp_sepcon, !sepcon_emp; auto. }
      rewrite sepcon_andp_prop'.
      apply andp_right; [apply prop_right; repeat (split; auto)|].
      { apply Forall_Znth; auto; match goal with H : Zlength shs = _ |- _ => setoid_rewrite H; auto end. }
      { apply Forall_Znth; auto; match goal with H : Zlength shs1 = _ |- _ => setoid_rewrite H; auto end. }
      { apply Forall_Znth; auto; match goal with H : Zlength comms = _ |- _ => setoid_rewrite H; auto end. }
      rewrite <- !(data_at_share_join _ _ _ _ _ _ Hj').
      rewrite sublist_next with (d0 := Tsh) by (auto; omega).
      rewrite sublist_next with (d0 := (false, Tsh)) by (auto; rewrite Zlength_combine, Z.min_l; omega).
      rewrite !sublist_next with (i0 := i)(d0 := Vundef) by (auto; omega).
      rewrite sublist_next with (d0 := N); simpl; rewrite ?Znth_upto; auto; rewrite ?Zlength_upto;
        simpl; try (unfold N in *; omega).
      fast_cancel.
      rewrite Znth_combine by omega.
      destruct (Znth i lgood false); simpl.
      + Exists Int.zero; cancel.
      + subst Frame; simpl; cancel.
    - Exists sh1'; entailer!. }
  eapply semax_seq'; [|apply semax_ff].
  eapply semax_loop; [|forward; apply ENTAIL_refl].
  forward.
  entailer!.
Qed.

Definition extlink := ext_link_prog prog.

Definition Espec := add_funspecs (Concurrent_Espec unit _ extlink) extlink Gprog.
Existing Instance Espec.

Lemma all_funcs_correct:
  semax_func Vprog Gprog (prog_funct prog) Gprog.
Proof.
unfold Gprog, prog, prog_funct, main_pre, main_post, prog_vars; simpl.
repeat (apply semax_func_cons_ext_vacuous; [reflexivity | reflexivity | ]).
repeat semax_func_cons_ext.
semax_func_cons body_malloc. apply semax_func_cons_malloc_aux.
assert (forall m0 l m2 gx ret, step_lemmas.has_opttyp ret (opttyp_of_type tint) ->
 EX x : Z, (PROP (repable_signed x) LOCAL (temp ret_temp (vint x))
   SEP (fold_right sepcon emp (map (fun p : Z => invariant (m0 p)) l); m2 x)) 
  (make_ext_rval gx ret) |-- !! is_int I32 Signed (force_val ret)).
{ intros; unfold PROPx, LOCALx, local, lift1, liftx; simpl; unfold liftx, lift; simpl.
  Intros x; apply prop_right.
  unfold make_ext_rval, eval_id in *; simpl in *.
  destruct ret; auto; simpl in *.
  subst; auto. }
repeat semax_func_cons_ext.
{ simpl; auto. }
{ simpl; auto. }
semax_func_cons body_surely_malloc.
semax_func_cons body_memset.
semax_func_cons body_initialize_channels.
semax_func_cons body_initialize_reader.
semax_func_cons body_start_read.
semax_func_cons body_finish_read.
semax_func_cons body_initialize_writer.
eapply semax_func_cons; [ reflexivity
           | repeat apply Forall_cons; try apply Forall_nil; simpl; auto; computable
           | unfold var_sizes_ok; repeat constructor; simpl; computable | reflexivity | precondition_closed
           | apply body_start_write |].
{ apply closed_wrtl_PROPx, closed_wrtl_LOCALx, closed_wrtl_SEPx.
  repeat constructor; apply closed_wrtl_gvar; unfold is_a_local; simpl; intros [? | ?];
    try contradiction; discriminate. }
semax_func_cons body_finish_write.
semax_func_cons body_reader.
semax_func_cons body_writer.
semax_func_cons body_main.
Qed.
