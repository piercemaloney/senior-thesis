
Set Implicit Arguments.

Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)
Require Import FCF.CompFold.
(* FCF.CompFold:
Set Implicit Arguments.
Require Import FCF.FCF.

Local Open Scope list_scope.

Fixpoint compFold(A B : Set)(eqd : EqDec B)(f : B -> A -> Comp B)(init : B)(ls : list A) :=
  match ls with
      | nil => ret init 
      | a :: ls' =>
        init' <-$ f init a;
          compFold  _ f init' ls'
  end.

Definition foldBody_option(A B : Set)(eqd : EqDec B)(f : B -> A -> Comp (option B))(b_opt : option B)(a : A) :=
  match b_opt with
      | None => ret None
      | Some b =>
        f b a
  end.

Definition opt_pred(A B : Set)(P : A -> B -> Prop)(opt_a : option A)(opt_b : option B) :=
  match opt_a with
    | Some a =>
      match opt_b with
        | Some b => P a b
        | None => False
      end
    | None =>
      match opt_b with
        | Some _ => False
        | None => True
      end
  end.

Theorem foldBody_option_spec : 
  forall (A B C D: Set)(eqda : EqDec A)(eqdb : EqDec B) (c1 : A -> C -> Comp (option A)) (c2 : B -> D -> Comp (option B)) (post : A -> B -> Prop) (pre1 : A -> B -> Prop) (pre2 : C -> D -> Prop), 
    (forall a b c d, 
         pre1 a b -> pre2 c d -> comp_spec (opt_pred post) (c1 a c) (c2 b d)) ->
    forall opt_a opt_b c d,
      opt_pred pre1 opt_a opt_b ->
      pre2 c d ->
      comp_spec
        (opt_pred post)
        (foldBody_option _ c1 opt_a c)
        (foldBody_option _ c2 opt_b d).

Theorem compFold_option_spec : 
  forall (A B : Set)(lsa : list A)(lsb : list B)(pre : A -> B -> Prop),
    list_pred pre lsa lsb ->
    forall (C D : Set){eqdc : EqDec C}{eqdd : EqDec D}(c1 : C -> A -> Comp (option C))(c2 : D -> B -> Comp (option D))(post : C -> D -> Prop) c d,
      (forall c d a b, post c d -> pre a b -> comp_spec (opt_pred post) (c1 c a) (c2 d b)) ->
      opt_pred post c d ->
      comp_spec 
        (opt_pred post) 
        (compFold _ (foldBody_option _ c1) c lsa) 
        (compFold _ (foldBody_option _ c2) d lsb).

Fixpoint compMap (A B : Set)(eqdb : EqDec B)(c : A -> Comp B)(ls : list A) : Comp (list B) :=
  match ls with
      | nil => ret nil
      | a :: lsa' =>
        b <-$ c a;
          lsb' <-$ compMap _ c lsa';
          ret (b :: lsb')
  end.

Theorem compMap_cons: 
  forall (A B : Set)(eqdb : EqDec B) (ls : list A)(c : A -> Comp B) (a : A) x,
    evalDist (compMap _ c (a :: ls)) x ==
    evalDist (b <-$ c a; lsb <-$ compMap _ c ls; ret (b :: lsb)) x.

Theorem compMap_nil : 
  forall (A B : Set)(eqdb : EqDec B)(c : A -> Comp B),
    compMap _ c nil = ret nil.

Theorem list_inhabited : 
  forall (A : Set), list A.

Theorem compMap_fission_eq:
  forall (A B C D : Set){eqdb : EqDec B}{eqdd : EqDec D}{eqdc : EqDec C}(ls : list A)(f1 : A -> Comp B)(f2 : A -> Comp C)(f3 : list B -> Comp (list D))(f4 : C -> Comp D) P,
    (comp_spec eq (f3 nil) (ret nil)) -> 
    (forall a, comp_spec P (f1 a) (f2 a)) -> 
    (forall r1 r2 r3, P r1 r2 ->
      comp_spec eq (f3 (r1 :: r3)) (r0 <-$ f3 r3; a0 <-$ f4 r2; ret a0 :: r0)) ->
    comp_spec eq 
    (lsb <-$ compMap _ f1 ls; f3 lsb)
    (compMap _ (fun a => b <-$ f2 a; f4 b) ls).
  
Theorem compMap_map_fission_eq :
  forall (A B C D : Set){eqdb : EqDec B}{eqdd : EqDec D}{eqdc : EqDec C}(ls : list A)(f1 : A -> Comp B)(f2 : A -> Comp C)(f3 : B -> D)(f4 : C -> D),
    (forall a, comp_spec (fun b c => f3 b = f4 c)
              (f1 a) (f2 a)) -> 
    comp_spec eq (lsb <-$ compMap _ f1 ls; ret (map f3 lsb))
     (compMap _ (fun a => b <-$ f2 a; ret (f4 b)) ls).

Theorem fold_map_fission_spec_eq : 
  forall (A B C: Set)(eqdB : EqDec B)(eqdC : EqDec C) ls c init (ca : A -> Comp B) cb,
    (forall a init, comp_spec eq (c init a) (x <-$ ca a; cb init x)) ->
    comp_spec eq (compFold _ c init ls) 
    (lsa <-$ (compMap _ ca ls); compFold _ cb init lsa).

Theorem fold_map_fission_spec : 
  forall (A E : Set)(P : A -> E -> Prop)(B D : Set)(eqdA : EqDec A)(c1 : A -> B -> Comp A)(ls_b : list B)(init_a : A)
    (eqdD : EqDec D)(eqdE : EqDec E)(c2 : B -> Comp D)(c3 : E -> D -> Comp E)(init_e : E),
    P init_a init_e ->
    (forall a b e, P a e -> comp_spec P (c1 a b) (a0 <-$ c2 b; c3 e a0)) ->
    comp_spec P 
    (compFold _ c1 init_a ls_b)
    (ls_d <-$ (compMap _ c2 ls_b); compFold _ c3 init_e ls_d).

Definition repeatMax(A : Set)(eqd : EqDec A)(c : Comp A)(P : A -> bool) def (n : nat):=
  compFold _ (fun a' i => if (P a') then (ret a') else c) def (allNatsLt n).
  
Lemma repeatMax_fold_true :
  forall (A B: Set)(ls : list B)(eqd : EqDec A)(c : B -> Comp A)(P : A -> bool)(a : A),
    P a = true ->
    comp_spec eq 
    (compFold _ (fun acc b => if (P acc) then (ret acc) else (c b)) a ls)  
    (ret a).

Lemma repeatMax_fold_in_support_false : 
  forall (A B : Set)(ls : list B)(eqd : EqDec A)(c : B -> Comp A)(P : A -> bool)(a : A),
    (forall b, In b ls -> In a (getSupport (c b))) ->
    P a = false ->
    In a
       (getSupport
          (compFold eqd
                    (fun (a' : A) b => if P a' then ret a' else (c b)) a ls)).

Theorem compFold_repeat_spec : 
  forall (C D: Set)(ls1 : list C)(ls2 : list D)(pre : C -> D -> Prop),
    list_pred pre ls1 ls2 ->
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(post : A -> B -> Prop)(c1 : C -> Comp A)(P1 : A -> bool)(c2 : D -> Comp B)(P2 : B -> bool) a b,
    post a b -> 
    (forall a b, pre a b -> comp_spec post (c1 a) (c2 b)) ->
    (forall a b, post a b -> (P1 a = true <-> P2 b = true)) ->
    comp_spec 
      post 
      (compFold _ (fun acc v => if (P1 acc) then (ret acc) else (c1 v)) a ls1) 
      (compFold _ (fun acc v => if (P2 acc) then (ret acc) else (c2 v)) b ls2).

Theorem compFold_eq : 
  forall (A1 A2 : Set) P (ls1 : list A1) (ls2 : list A2),
    list_pred P ls1 ls2 ->
    forall (B : Set)(eqd : EqDec B) (c1 : B -> A1 -> Comp B) (c2: B -> A2 -> Comp B),
      (forall acc a1 a2, P a1 a2 -> In a1 ls1 -> In a2 ls2 ->
        comp_spec eq (c1 acc a1) (c2 acc a2) ) ->
      forall init, 
        comp_spec eq (compFold _ c1 init ls1) (compFold _ c2 init ls2).

Lemma list_pred_zip_l : 
  forall (A B: Set)(lsa : list A)(lsb : list B)(P : A -> B -> Prop),
    list_pred P lsa lsb ->
    forall (C : Set)(lsc : list C)(P1 : A -> C -> Prop)(P2 : B -> C -> Prop),
      list_pred P1 lsa lsc ->
      list_pred P2 lsb lsc ->
      list_pred (fun (p : A * B) c => P (fst p) (snd p) /\ P1 (fst p) c /\ P2 (snd p) c) (zip lsa lsb) lsc.

Lemma list_pred_eq : 
  forall (A : Set)(lsa : list A),
    list_pred eq lsa lsa.

Lemma list_pred_I : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    (length lsa = length lsb) ->
    list_pred (fun a b => True) lsa lsb.

Lemma list_pred_length_eq : 
  forall (A B : Set)(lsa : list A)(lsb : list B)(P : A -> B -> Prop),
       list_pred P lsa lsb ->
       length lsa = length lsb.

Lemma list_pred_zip_l_eq : 
  forall (A B: Set)(lsa : list A)(lsb : list B)(P : A -> B -> Prop),
    list_pred P lsa lsb ->
    list_pred (fun p a => (fst p) = a /\ P (fst p) (snd p)) (zip lsa lsb) lsa.

Lemma list_pred_map_r_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    list_pred (fun a b => f a = b) ls (map f ls).

Lemma list_pred_map_r : 
  forall (A B : Set)(lsa : list A)(lsb : list B)(P : A -> B -> Prop),
    list_pred P lsa lsb ->
    forall (C : Set)(f : B -> C),
           list_pred (fun a c => exists b, P a b /\ c = f b) lsa (map f lsb).

Lemma list_pred_zip_r : 
  forall (A B: Set)(lsa : list A)(lsb : list B)(P : A -> B -> Prop),
    list_pred P lsa lsb ->
    forall (C : Set)(lsc : list C)(P1 : A -> C -> Prop)(P2 : B -> C -> Prop),
      list_pred P1 lsa lsc ->
      list_pred P2 lsb lsc ->
      list_pred (fun c (p : A * B) => P (fst p) (snd p) /\ P1 (fst p) c /\ P2 (snd p) c) lsc (zip lsa lsb).

Lemma list_pred_map_l_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    list_pred (fun b a => f a = b) (map f ls) ls.

Definition compMap_fold (A B : Set)(eqd : EqDec B)(c : A -> Comp B)(ls : list A) :=
  compFold _ (fun (acc : list B)(a : A) => b <-$ c a; ret (acc ++ (b :: nil))) nil ls.

Lemma compFold_spec : 
  forall (A C D : Set)(P2 : list A -> C -> D -> Prop)(eqdc : EqDec C)(eqdd : EqDec D)(lsa : list A)(c1 : C -> A -> Comp C)(c2 : D -> A -> Comp D) init1 init2,
    P2 lsa init1 init2 ->
    (forall a lsa c d, P2 (a :: lsa) c d -> comp_spec (P2 lsa) (c1 c a) (c2 d a)) ->
    comp_spec (P2 nil) (compFold _ c1 init1 lsa) (compFold _ c2 init2 lsa).

Theorem compMap_fold_equiv : 
  forall (A B : Set)(eqd : EqDec B)(c : A -> Comp B)(ls : list A),
    comp_spec eq (compMap eqd c ls) (compMap_fold eqd c ls).

Lemma compFold_wf : 
  forall (A B : Set)(eqd : EqDec A)(c : A -> B -> Comp A)(ls : list B) init,
    (forall a b, well_formed_comp (c a b)) ->
    well_formed_comp (compFold _ c init ls).

Lemma compMap_map : 
  forall (A B : Set)(eqd : EqDec B)(f : A -> B) ls,
    comp_spec eq (compMap _ (fun a => ret (f a)) ls) (ret (map f ls)).

Lemma compFold_nop : 
  forall (A B : Set)(eqd : EqDec A)(c : A -> B -> Comp A)(ls : list B) init x, 
    In x (getSupport (compFold _ c init ls)) ->
    (forall b a, In b ls -> In a (getSupport (c init b)) -> a = init) ->
    x = init.

Lemma compFold_app : 
  forall (A B : Set)(eqd : EqDec A)(c : A -> B -> Comp A)(ls1 ls2 : list B) init x,
    evalDist (compFold _ c init (ls1 ++ ls2)) x ==
    evalDist (init' <-$ compFold _ c init ls1; compFold _ c init' ls2) x.

Theorem comp_fold_ext : 
  forall (A B : Set)(eqd : EqDec A)(c1 c2 : A -> B -> Comp A)(ls : list B)(init : A),
    (forall a b,
       comp_spec eq (c1 a b) (c2 a b)) ->
    comp_spec eq (compFold _ c1 init ls) (compFold _ c2 init ls).

Lemma list_pred_app : 
  forall (A B : Set)(P : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb : list B),
    list_pred P (lsa1 ++ lsa2) lsb ->
    list_pred P lsa1 (firstn (length lsa1) lsb) *
    list_pred P lsa2 (skipn (length lsa1) lsb).

Theorem list_pred_map_l_inv :
  forall (A B C : Set) (lsa : list A) (lsb : list B) (f : A -> C)(P : C -> B -> Prop),
    list_pred P (map f lsa) lsb ->
    list_pred (fun a b => P (f a) b) lsa lsb.

Definition flatten_prep
           (A B : Set)(ls : list (A * (list B))) : list (list (nat * nat * A * B)) :=
  map (fun p => [a, lsb] <-2 p; map (fun p' => [i, b] <-2 p'; (i, length lsb, a, b)) (zip (allNatsLt (length lsb)) lsb)) ls.

Theorem compFold_flatten : 
  forall (A B C D: Set) P (eqd1 eqd2 : EqDec C)(c1 : C -> (D * list A) -> Comp C)(c2 : C -> B -> Comp C)(ls1 : list (D * (list A)))(ls2 : list B) init x,
    list_pred P (flatten (flatten_prep ls1)) ls2 ->
    (forall d lsa lsb init x, list_pred P (map (fun p => [i, a] <-2 p; (i, (length lsa), d, a)) (zip (allNatsLt (length lsa)) lsa)) lsb -> evalDist (c1 init (d, lsa)) x == evalDist (compFold eqd2 c2 init lsb) x) ->
    evalDist (compFold eqd1 c1 init ls1) x ==
    evalDist (compFold eqd2 c2 init ls2) x.

Lemma compMap_eq : 
  forall (A B : Set)(P : A -> B -> Prop)(C : Set)(eqd : EqDec C)(c1 : A -> Comp C)(c2 : B -> Comp C)(lsa : list A)(lsb : list B),
    list_pred P lsa lsb ->
    (forall a b, P a b -> forall x, evalDist (c1 a) x == evalDist (c2 b) x) ->
    forall x, 
      evalDist (compMap _ c1 lsa) x == evalDist (compMap _ c2 lsb) x.

Require Import Permutation.

Theorem compFold_perm : 
  forall (A B : Set)(inv : B -> Prop)(ls1 ls2 : list A),
    Permutation ls1 ls2 ->
    forall (eqd : EqDec B) (c : B -> A -> Comp B) init x,
      (forall b a1 a2 x,
           In a1 ls1 ->
           In a2 ls2 ->
           inv b -> 
           evalDist (b' <-$ c b a1; c b' a2) x ==
           evalDist (b' <-$ c b a2; c b' a1) x) ->
      (forall a b b',
         In a ls1 ->
         inv b ->
         In b' (getSupport (c b a)) ->
         inv b') ->
      inv init -> 
      evalDist (compFold _ c init ls1) x ==
      evalDist (compFold _ c init ls2) x.

Lemma list_pred_app_both : 
  forall (A B : Set)(P : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
    list_pred P lsa1 lsb1 ->
    list_pred P lsa2 lsb2 ->
    list_pred P (lsa1 ++ lsa2) (lsb1 ++ lsb2).

Lemma list_pred_map_both : 
  forall (A B C D : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> D),
    list_pred P lsa lsb ->
    list_pred (fun c d => exists a b, P a b /\ c = (f1 a) /\ d = (f2 b)) (map f1 lsa) (map f2 lsb).

Lemma compMap_spec : 
  forall (A B C D : Set)(eqdc : EqDec C)(eqdd : EqDec D)(P1 : A -> B -> Prop)(P2 : C -> D -> Prop)(lsa : list A)(lsb : list B)(c1 : A -> Comp C)(c2 : B -> Comp D),
    list_pred P1 lsa lsb ->
    (forall a b, In a lsa -> In b lsb -> P1 a b -> comp_spec P2 (c1 a) (c2 b)) ->
    comp_spec (list_pred P2)
                   (compMap _ c1 lsa) 
                   (compMap _ c2 lsb).

Theorem compMap_fission_ex : 
  forall (A B C : Set)(eqdb : EqDec B)(eqdc : EqDec C)
         (c1 : A -> Comp B)(c2 : B -> Comp C)(ls : list A),
    comp_spec eq 
              (compMap _ (fun a => b <-$ c1 a; c2 b) ls)
              (ls' <-$ compMap _ c1 ls; compMap _ c2 ls').

Lemma list_pred_eq_gen : 
  forall (A : Set)(ls1 ls2 : list A),
    ls1 = ls2 ->
    list_pred eq ls1 ls2.

Lemma compMap_support : 
  forall (A B : Set)(P : A -> B -> Prop)(eqd : EqDec B)(c : A -> Comp B)(lsa : list A)(lsb : list B),
    In lsb (getSupport (compMap _ c lsa)) ->
    (forall a b, In a lsa -> In b (getSupport (c a)) -> P a b) ->
    list_pred P lsa lsb.

Lemma In_zip : 
  forall (A B : Set)(a : A)( b : B) lsa lsb, 
    In (a, b) (zip lsa lsb) ->
    In a lsa /\ In b lsb.

Lemma list_pred_map_l
: forall (A B : Set) (lsa : list A) (lsb : list B) (P : A -> B -> Prop),
    list_pred P lsa lsb ->
    forall (C : Set) (f : A -> C),
      list_pred 
        (fun (c : C) (b : B) => exists a : A, P a b /\ c = f a) (map f lsa)
        lsb.

Lemma list_pred_map_l_if : 
  forall (A B C : Set) (P  : C -> B -> Prop)(lsa : list A)(lsb : list B)(f : A -> C),
    list_pred P (map f lsa) lsb ->
    list_pred (fun a b => P (f a) b) lsa lsb.

Lemma list_pred_map_r_if : 
  forall (A B C : Set) (P  : A -> C -> Prop)(lsb : list B)(lsa : list A)(f : B -> C),
    list_pred P lsa (map f lsb) ->
    list_pred (fun a b => P a (f b)) lsa lsb.

Lemma list_pred_map_r'
: forall (A B C : Set) (lsa : list A) (lsb : list B) (P : A -> C -> Prop) (f : B -> C),
    list_pred (fun a b => P a (f b)) lsa lsb ->
    list_pred P lsa (map f lsb).

Lemma list_pred_map_l'
: forall (A B C : Set) (lsa : list A) (lsb : list B) (P : C -> B -> Prop) (f : A -> C),
    list_pred (fun a b => P (f a) b) lsa lsb ->
    list_pred P (map f lsa) lsb.

Theorem list_pred_rev : 
  forall (A B : Set)(lsa : list A)(lsb : list B) P,
    list_pred P lsa lsb ->
    forall a b,
    P a b ->
    list_pred P (lsa ++ (a :: nil)) (lsb ++ (b :: nil)).

Theorem list_pred_impl'
     : forall (A B : Set) (lsa : list A) (lsb : list B) (P1 : A -> B -> Prop),
       list_pred P1 lsa lsb ->
       forall P2 : A -> B -> Prop,
       (forall (a : A) (b : B), In a lsa -> In b lsb -> P1 a b -> P2 a b) -> list_pred P2 lsa lsb.

Lemma list_pred_allNatsLt : 
  forall (A : Set)(ls : list A),
    list_pred (fun i a => forall a', nth i ls a' = a) (allNatsLt (length ls)) ls.

Lemma compMap_length :
  forall (A B : Set)(eqd : EqDec B)(ls : list A) x (c : A -> Comp B) ,
    In x (getSupport (compMap _ c ls)) ->
    length x = length ls.

Lemma map_eq : 
  forall (A B C : Set)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> C),
    list_pred (fun a b => f1 a = f2 b) lsa lsb ->
    map f1 lsa = map f2 lsb.

Lemma zip_length : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    length (zip lsa lsb) = length lsa.

Definition numberedMap(A B : Set)(f : nat -> nat -> A -> B)(ls : list A) :=
  map (fun p => [i, a] <-2 p; f i (length ls) a) (zip (allNatsLt (length ls)) ls).

Lemma numberedMap_length : 
  forall (A B : Set)(ls : list A)(f : nat -> nat -> A -> B),
    length (numberedMap f ls) = length ls.

Lemma nth_zip : 
  forall (A B : Set)(lsa : list A)(lsb : list B) n a b defa defb,
    length lsa = length lsb ->
    nth n (zip lsa lsb) (defa, defb) = (a, b) ->
    nth n lsa defa = a /\ nth n lsb defb = b.

Lemma compFold_spec' : 
  forall (A B C D : Set)(P2 : list A -> list B -> C -> D -> Prop)(eqdc1 eqdc2  : EqDec C)(eqdd1 eqdd2 : EqDec D)(lsa : list A)(lsb : list B)(c1 : C -> A -> Comp C)(c2 : D -> B -> Comp D) init1 init2,
    length lsa = length lsb ->
    P2 lsa lsb init1 init2 ->
    (forall a lsa b lsb c d, P2 (a :: lsa) (b :: lsb) c d -> comp_spec (P2 lsa lsb) (c1 c a) (c2 d b)) ->
    @comp_spec _ _ eqdc1 eqdd1 (P2 nil nil) (compFold eqdc2 c1 init1 lsa) (compFold eqdd2 c2 init2 lsb).
  
Lemma compMap_support_app : 
  forall (A B : Set)(eqd : EqDec B)(c : A -> Comp B)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
    In lsb1 (getSupport (compMap _ c lsa1)) ->
    In lsb2 (getSupport (compMap _ c lsa2)) ->
    In (lsb1 ++ lsb2) (getSupport (compMap _ c (lsa1 ++ lsa2))).

Lemma list_pred_single : 
  forall (A : Set) (P : A -> A -> Prop) (lsa : list A),
    (forall a, In a lsa -> P a a) ->
    list_pred P lsa lsa.

Lemma flatten_map_eq : 
  forall (A B : Set)(ls : list (list A))(f : A -> B),
    map f (flatten ls) = flatten (map (fun ls' => map f ls') ls).

Lemma zip_app : 
  forall (A B : Set)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
    length lsa1 = length lsb1 ->
    length lsa2 = length lsb2 ->
    (zip lsa1 lsb1) ++ (zip lsa2 lsb2) =
    (zip (lsa1 ++ lsa2) (lsb1 ++ lsb2)).

Lemma length_flatten_eq : 
  forall (A B : Set)(lsa : list (list A))(lsb : list (list B)),
    list_pred (fun a1 a2 => length a1 = length a2) lsa lsb ->
    length (flatten lsa) = length (flatten lsb).

Lemma flatten_map_pair_eq : 
  forall (A B C : Set)(ls : list (list A * list B))(f : A * B -> C),
    (forall ls1 ls2, In (ls1, ls2) ls -> length ls1 = length ls2) ->
    flatten (map (fun p => [ls1, ls2] <-2 p; map f (zip ls1 ls2)) ls) = 
    map f (zip (flatten (fst (unzip ls))) (flatten (snd (unzip ls)))).

Lemma compMap_app : 
  forall (A B : Set)(eqd : EqDec B)(ls1 ls2 : list A)(c : A -> Comp B) x,
    evalDist (compMap _ c (ls1 ++ ls2)) x ==
    evalDist (r1 <-$ compMap _ c ls1; r2 <-$ compMap _ c ls2; ret (r1 ++ r2)) x.

Lemma compMap_flatten :
  forall (A B : Set)(eqd : EqDec B)(c : A -> Comp B)(ls : list (list A)),
    comp_spec
      (fun ls1 ls2 => ls2 = flatten ls1)
      (compMap _ (fun ls' => compMap _ c ls') ls)
      (compMap _ c (flatten ls)).

Lemma map_f_equal : 
  forall (A B : Set)(f1 f2 : A -> B)(ls1 ls2 : list A),
    (forall a, f1 a = f2 a) ->
    ls1 = ls2 ->
    map f1 ls1 = map f2 ls2.

Lemma list_pred_zip_eq_rev : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    (length lsa = length lsb) ->
    list_pred (fun p1 p2 => [a1, b1] <-2 p1; [b2, a2] <-2 p2; a1 = a2 /\ b1 = b2) (zip lsa lsb) (zip lsb lsa).

Lemma list_pred_zip_in : 
  forall (A B : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B),
    list_pred P lsa lsb ->
    forall a b, 
      In (a, b) (zip lsa lsb) ->
      P a b.

Lemma in_zip_swap : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a b,
    length lsa = length lsb ->
    In (a, b) (zip lsa lsb) ->
    In (b, a) (zip lsb lsa).

Lemma unzip_zip_inv : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    unzip (zip lsa lsb) = (lsa, lsb).

Notation "'foreach' '(' x 'in' ls ')' c " := (compMap _ (fun x => c) ls) (right associativity, at level 85, only parsing) : comp_scope.
Notation "'foreach' '(' x 'in' ls ')' c " := (map (fun x => c) ls) (right associativity, at level 85, only parsing).
Notation "'for' '(' x ''<' n ')' c " := (map (fun x => c) (allNatsLt n)) (right associativity, at level 86, only parsing).

Fixpoint removePresent (A : Set)(eqd : eq_dec A)(u ls : list A) :=
  match ls with
    | nil => nil
    | a' :: ls' =>
      ls'' <- removePresent eqd u ls'; 
        if (in_dec eqd a' u) then ls'' else (a' :: ls'')
  end.

Lemma removePresent_not_in : 
  forall (A : Set)(eqd : eq_dec A)(a : A) ls1 ls2,
    In a (removePresent eqd ls1 ls2) ->
    In a ls1 -> 
    False.
  
  induction ls2; intuition; simpl in *.
  unfold setLet in *.

Ltac hypInv :=
      try (match goal with
          | [H: Some _ = Some _ |-_ ] => inversion H; clear H; subst
      end); try pairInv.

Fixpoint lookupIndex (A : Set)(eqd : eq_dec A)(ls : list A)(a : A) def :=
  match ls with
    | nil => def
    | a' :: ls' =>
      if (eqd a a') then O else S (lookupIndex eqd ls' a def)
  end.

Lemma nth_lookupIndex : 
  forall (A : Set)(eqd : eq_dec A)(ls : list A) n (a a': A),
    In a ls ->
    nth (lookupIndex eqd ls a n ) ls a' = a.

Theorem map_ext_in : 
  forall (A B : Set)(ls : list A)(f1 f2 : A -> B),
    (forall a, In a ls -> f1 a = f2 a) ->
    map f1 ls = map f2 ls.

Lemma nth_map_In : 
  forall (A B : Set)(ls : list A)(f : A -> B) i defa defb,
    i < length ls ->
    nth i (map f ls) defa = f (nth i ls defb).

Lemma removePresent_In : 
  forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
    In a ls2 ->
    (~ In a ls1) ->
    In a (removePresent eqd ls1 ls2).
  
  induction ls2; intuition; simpl in *.
  intuition; subst.
  unfold setLet.
  destruct (in_dec eqd a0 ls1); intuition.
  
  unfold setLet.

Lemma lookupIndex_lt_length :
  forall (A : Set)(eqd : eq_dec A)(ls : list A) a def,
    In a ls -> 
    lookupIndex eqd ls a def < length ls.

Lemma skipn_app : 
  forall (A : Set)(ls1 ls2 : list A),
    skipn (length ls1) (ls1 ++ ls2) = ls2.

Lemma fold_add_init_nat_h : 
  forall (A : Set)(f : A -> nat)(ls : list A)(init1 init2 : nat),
    (fold_left (fun acc a => acc + (f a))%nat ls (init1 + init2) = 
     init1 + fold_left (fun acc a => acc + (f a))%nat ls init2)%nat.

Lemma fold_add_init_nat : 
  forall (A : Set)(f : A -> nat)(ls : list A)(init : nat),
    (fold_left (fun acc a => acc + (f a))%nat ls init = 
     init + fold_left (fun acc a => acc + (f a))%nat ls O)%nat.

Lemma length_flatten : 
  forall (A : Set)(ls : list (list A)),
    length (flatten ls) =
    fold_left (fun acc a => (acc + (length a))%nat) ls O.

Lemma fold_left_map_eq : 
  forall (A B C : Set)(ls : list A)(f1 : A -> B)(f2 : C -> B -> C)(init : C),
    fold_left (fun acc b => f2 acc b) (map f1 ls) init = 
    fold_left (fun acc a => f2 acc (f1 a)) ls init.

Lemma fold_add_nat_Permutation : 
  forall (A : Set)(f : A -> nat)(ls1 ls2 : list A),
    Permutation ls1 ls2 ->
    fold_left (fun acc a => acc + (f a))%nat ls1 O = 
    fold_left (fun acc a => acc + (f a))%nat ls2 O.

Lemma intersect_NoDup : 
  forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
    NoDup ls2 ->
    NoDup (intersect eqd ls1 ls2).

Lemma intersect_comm_Permutation : 
  forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
    NoDup ls1 ->
    NoDup ls2 ->
    Permutation
      (intersect eqd ls1 ls2)
      (intersect eqd ls2 ls1).

Lemma fold_add_nat_filter_partition : 
  forall (A : Set)(P : A -> bool)(f : A -> nat)(ls : list A),
    fold_left (fun acc a => acc + (f a))%nat ls O = 
    (plus
       (fold_left (fun acc a => acc + (f a))%nat (filter P ls) O)
       (fold_left (fun acc a => acc + (f a))%nat (filter (fun a => negb (P a)) ls) O)
    ).

Lemma fold_left_add_removePresent : 
  forall (B : Set)(eqd : eq_dec B)(f : B -> nat)(ls u : list B),
    NoDup ls ->
    NoDup u ->
    fold_left (fun acc b => (acc + (f b))%nat) (removePresent eqd u ls) O = 
    minus 
      (fold_left (fun acc b => (acc + (f b))%nat) ls O)
      (fold_left (fun acc b => (acc + (f b))%nat) (intersect eqd ls u) O).
  
  induction ls; intuition; simpl in *.
  
  inversion H; clear H; subst.
  destruct (in_dec eqd a u).
  unfold setLet.
  rewrite IHls; trivial.
  rewrite (@fold_add_nat_Permutation _ _ (intersect eqd (a :: ls) u) (intersect eqd u (a :: ls))).
  
  simpl.
  destruct (in_dec eqd a u); intuition.
  simpl.
  
  repeat rewrite (@fold_add_init_nat _ _ _ (f a)).
  rewrite <- minus_plus_simpl_l_reverse.
  f_equal.
  eapply fold_add_nat_Permutation.
  eapply intersect_comm_Permutation; intuition.
  eapply intersect_comm_Permutation; intuition.
  econstructor; eauto.
  
  unfold setLet.

Lemma fold_add_nat_0 : 
  forall (A : Set)(ls : list A)(f : A -> nat), 
    (forall a, In a ls -> f a = O) ->
    fold_left (fun acc a => acc + (f a))%nat ls O = O.

Lemma map_snd_zip : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    map (fun p => snd p) (zip lsa lsb) = lsb.

Theorem Permutation_flatten :
  forall (A : Set)(ls1 ls2 : list (list A)),
    Permutation ls1 ls2 ->
    Permutation (flatten ls1) (flatten ls2).

Theorem zip_map_eq :
  forall (A B C : Set)(ls : list A)(f1 : A -> B)(f2 : A -> C),
    zip (map f1 ls) (map f2 ls) = map (fun a => (f1 a, f2 a)) ls.

Theorem removePresent_in_only_if : 
  forall (A : Set)(eqd : eq_dec A)(u ls : list A) a,
    In a (removePresent eqd u ls) ->
    In a ls.
  
  induction ls; intuition; simpl in *.
  unfold setLet in *.

Theorem removePresent_correct : 
  forall (A : Set)(eqd : eq_dec A)(u ls : list A) a,
    In a u ->
    In a (removePresent eqd u ls) ->
    False.
  
  induction ls; intuition; simpl in *.
  unfold setLet in *.

Theorem removePresent_NoDup :
  forall (A : Set)(eqd : eq_dec A)(u ls : list A),
    NoDup ls ->
    NoDup (removePresent eqd u ls).
  
  induction ls; intuition; simpl in *.
  unfold setLet.

Theorem removePresent_correct2 : 
  forall (A : Set)(eqd : eq_dec A)(u ls : list A) a,
    (~In a u) ->
    In a ls ->
    In a (removePresent eqd u ls).
  
  induction ls; intuition; simpl in *.
  unfold setLet in *.

Definition optSwap (A : Set)(opt : option (A * A)) :=
  match opt with
    | None => None
    | Some (a1, a2) =>
      Some (a2, a1)
  end.

Theorem optSwap_involutive : 
  forall (A : Set)(opt : option (A * A)),
    optSwap (optSwap opt) = opt.

Theorem nth_listReplace_nil_eq : 
  forall (A : Set) i (a def1 def2 : A),
    nth i (listReplace nil i a def1) def2 = a.

Theorem nth_listReplace_eq : 
  forall (A : Set) i (ls : list A) a def1 def2,
    nth i (listReplace ls i a def1) def2 = a.

Theorem nth_NoDup : 
  forall (A : Set)(ls : list (list A)) i,
    (forall e, In e ls -> NoDup e) ->
    NoDup (nth i ls nil).

Lemma listReplace_twice_nil : 
  forall (A : Set)(n : nat) (a1 a2 def : A),
    listReplace (listReplace nil n a1 def) n a2 def =
    listReplace nil n a2 def.

Lemma listReplace_twice : 
  forall (A : Set)(n : nat)(ls : list A) a1 a2 def,
    listReplace (listReplace ls n a1 def) n a2 def =
    listReplace ls n a2 def.

Lemma compFold_foldBodyOption_None : 
  forall (A B : Set)(eqd : EqDec A)(c : A -> B -> Comp (option A))(ls : list B) x,
    evalDist (compFold _ (foldBody_option _ c) None ls) x ==
    evalDist (ret None) x.

 Lemma Bvector_ne_exists : 
      forall (n : nat)(v : Bvector n),
        n > 0 ->
        exists v', v <> v'.

Lemma map_eq_inv : 
      forall (A B : Set)(f1 f2 : A -> B)(ls : list A),
        map f1 ls = map f2 ls ->
        forall a, In a ls -> f1 a = f2 a.

Lemma nth_lt_length : 
  forall (A : Set)(ls : list A)(i : nat) a def,
    nth i ls def = a ->
    def <> a ->
    i < length ls.

Lemma map_eq_nth_h : 
  forall (A B C : Set) (f1 : A -> C)(f2 : B -> C)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    map f1 lsa = map f2 lsb ->
    forall i def1 def2, 
      i < length lsa ->
      f1 (nth i lsa def1) = f2 (nth i lsb def2).

Lemma map_eq_nth : 
  forall (A B C : Set) i def1 def2 (f1 : A -> C)(f2 : B -> C)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    map f1 lsa = map f2 lsb ->
    i < length lsa ->
    f1 (nth i lsa def1) = f2 (nth i lsb def2).

Theorem compFold_eq' : 
  forall (A1 A2 : Set) P (ls1 : list A1) (ls2 : list A2),
    list_pred P ls1 ls2 ->
    forall (B : Set)(eqd1 eqd2 : EqDec B) (c1 : B -> A1 -> Comp B) (c2: B -> A2 -> Comp B),
      (forall acc a1 a2 x, P a1 a2 -> In a1 ls1 -> In a2 ls2 ->evalDist (c1 acc a1) x == evalDist (c2 acc a2) x) ->
      forall init x, 
        evalDist (compFold eqd1 c1 init ls1) x == evalDist (compFold eqd2 c2 init ls2) x.

Lemma list_pred_flatten_both : 
  forall (A B : Set)(P : A -> B -> Prop)(lsa : list (list A))(lsb : list (list B)),
    list_pred (list_pred P) lsa lsb ->
    list_pred P (flatten lsa) (flatten lsb).

Theorem compMap_wf :
  forall (A B : Set){eqdb : EqDec B}(c : A -> Comp B)(ls : list A),
    (forall a, In a ls -> well_formed_comp (c a)) ->
    well_formed_comp (compMap _ c ls).

Theorem list_pred_listReplace : 
  forall n (A B : Set) P (lsa : list A)(lsb : list B),
    list_pred P lsa lsb ->
    forall a b defa defb,
      P a b -> 
      P defa defb ->
      list_pred P (listReplace lsa n a defa) (listReplace lsb n b defb).

Theorem list_pred_nth : 
  forall n (A B : Set) P (lsa : list A)(lsb : list B) defa defb,
    list_pred P lsa lsb ->
    P defa defb ->
    P (nth n lsa defa) (nth n lsb defb).

Theorem compFold_cons : 
  forall (A B : Set)(eqda : EqDec A)(c : A -> B -> Comp A)(ls : list B) b (a : A),
    comp_spec eq (compFold _ c a (b :: ls)) (a' <-$ c a b; compFold _ c a' ls).

Theorem compFold_support_h : 
  forall (A B : Set)(eqda : EqDec A)(P : A -> list B -> list B -> Prop)(c : A -> B -> Comp A) (ls1 ls2 ls3 : list B)(a z : A),
    In z (getSupport (compFold _ c a ls1)) ->
    P a ls2 (ls1 ++ ls3) ->
    (forall a1 a2 b ls1 ls2,
       In a2 (getSupport (c a1 b)) ->
       P a1 ls1 (b :: ls2) ->
       P a2 (ls1 ++ (b :: nil)) ls2
    ) ->
    P z (ls2 ++ ls1) ls3.

Theorem compFold_support : 
  forall (A B : Set)(eqda : EqDec A)(P : A -> list B -> list B -> Prop)(c : A -> B -> Comp A) (ls1 : list B)(a z : A),
    In z (getSupport (compFold _ c a ls1)) ->
    P a nil ls1 ->
    (forall a1 a2 b ls1 ls2,
       In a2 (getSupport (c a1 b)) ->
       P a1 ls1 (b :: ls2) ->
       P a2 (ls1 ++ (b :: nil)) ls2
    ) ->
    P z ls1 nil.

Theorem list_pred_app_both_if : 
   forall (A B : Set) P (x y : list A)(z q : list B),
     length x = length z ->
     list_pred P (x ++ y) (z ++ q) ->
     list_pred P x z /\ list_pred P y q.

Theorem compMap_seq_map :
  forall (A B C : Set)(eqdc : EqDec C)(ls : list A)(f : A -> B)(c : B -> Comp C),
    comp_spec eq
              (compMap _ c (map f ls))
              (compMap _ (fun x => c (f x)) ls).

Lemma compMap_Repeat_close : 
  forall n (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(c : Comp A)(P : A -> bool)(f : A -> B) x,
    well_formed_comp c ->
    (exists a, In a (filter P (getSupport c))) ->
    | (evalDist 
      (a <-$ compMap eqda (fun _ : nat => c) (forNats n);
       ret hd_error (map f (filter P a))) x) - 
      (evalDist 
         (a <-$ Repeat c P; ret Some (f a)) x) | <= 
     expRat (Pr[a <-$ c; ret (negb (P a))]) n.

Theorem compMap_head : 
  forall (A B : Set)(eqd : EqDec B)(f : A -> Comp B)(ls : list A) x,
    (forall a, In a ls -> well_formed_comp (f a)) ->
    evalDist (ls' <-$ compMap _ f ls; ret (head ls')) x ==
    evalDist (match (head ls) with
                  | None => ret None
                  | Some a => b <-$ f a; ret (Some b)
              end) x.

Theorem compMap_filter : 
  forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list A)(c : A -> Comp B)(P : A -> bool) x,  
    (forall a, In a ls -> well_formed_comp (c a)) ->
    evalDist (compMap _ c (filter P ls)) x ==
    evalDist (ps <-$ compMap _ (fun a => b <-$ (c a); ret (a, b)) ls; ret (snd (unzip (filter (fun p => P (fst p)) ps)))) x.

Theorem prob_sum_le : 
  forall (A : Set)(ls : list A)(c : A -> Comp bool),
    Pr 
      [compFold _ (fun b a => x <-$ c a; ret (b || x)) false ls] <=
    sumList ls (fun a => Pr [c a]).

Theorem prob_sum_le_mult : 
  forall (n : nat)(c : Comp bool),
    Pr 
      [compFold _ (fun b a => x <-$ c; ret (b || x)) false (forNats n)] <=
    n/1 * Pr [c].

Theorem compMap_Q_eq_compFold : 
  forall (B : Set)(eqdb : EqDec B)(Q : B -> bool) n1  (c : Comp B) z,
    Pr[ls <-$ compMap _ (fun _ => c) (forNats n1); ret (fold_left (fun b x => b || (Q x)) ls z)] == 
    Pr[compFold _ (fun b _ => z <-$ (x <-$ c; ret Q x); ret b || z) z (forNats n1)].

Theorem Repeat_unroll_n : 
  forall n (A : Set)(eqda : EqDec A)(c : Comp A)(P : A -> bool) a,
    well_formed_comp c ->
    (exists x, In x (filter P (getSupport c))) ->
    evalDist (Repeat c P) a == 
    evalDist (x <-$ compMap _ (fun _ => c) (forNats n);
              match (hd_error (filter P x)) with
                | None => Repeat c P
                | Some z => ret z
              end) a.

Theorem compFold_ret_eq : 
  forall (A B : Set)(eqdb : EqDec B)(ls : list A)(f : B -> A -> B) init,
    comp_spec eq
              (compFold _ (fun b a => ret (f b a)) init ls)
              (ret (fold_left f ls init)).

Theorem prob_fold_add_false_0 :
  forall (A B : Set)(c : Comp A)(ls : list B)(P : A -> bool),
    Pr[compFold _ (fun b _ => x <-$ c; ret b && (P x)) false ls] == 0.

Theorem sumList_support_bool':
  forall (c : Comp bool) (f : bool -> Rat),
    sumList (getSupport c) (fun x => evalDist c x * f x) == 
    Pr  [c ] * (f true) + (evalDist c false * (f false)).

Theorem prob_fold_and_eq_exp_h : 
  forall (A B : Set)(c : Comp A)(ls : list B)(P : A -> bool),
    Pr[compFold _ (fun b _ => x <-$ c; ret b && (P x)) true ls] ==
    expRat (Pr[x <-$c; ret (P x)]) (length ls).

Theorem prob_fold_and_eq_exp : 
  forall (A : Set)(c : Comp A)(n : nat)(P : A -> bool),
    Pr[compFold _ (fun b _ => x <-$ c; ret b && (P x)) true (forNats n)] ==
    expRat (Pr[x <-$c; ret (P x)]) n. *)
Require Import FCF.RndNat.
(* FCF.RndNat:
Set Implicit Arguments.

Require Import FCF.Crypto.
Require Import Permutation.
Require Import FCF.NotationV1.
  
Definition RndNat_unchecked(n : nat) :=
  v <-$ {0,1} ^ (lognat n);
  let n := (bvToNat v) in
    ret n.

Definition ltNatBool := fun x1 x2 => if (lt_dec x1 x2) then true else false.

Definition RndNat(n : nat) :=
    (Repeat (RndNat_unchecked n) (fun x => (ltNatBool x n))).

Notation "[ 0 '..' n )" := (RndNat n)
  (right associativity, at level 77) : comp_scope.

Lemma well_formed_RndNat : forall n,
  n > O ->
  well_formed_comp (RndNat n).

Lemma RndNat_support_lt : forall n x,
  In x (getSupport (RndNat n)) ->
  x < n.

Hint Resolve well_formed_RndNat : wftac.

Lemma RndNat_unchecked_lt_support : forall n v,
  v < n ->
  In v (getSupport (RndNat_unchecked n)).

Local Open Scope rat_scope.

Lemma RndNat_uniform : forall v1 v2 n,
  v1 < n ->
  v2 < n -> 
  evalDist (RndNat n) v1 == evalDist (RndNat n) v2.

Lemma in_getSupport_RndNat : forall x k,
  x < k ->
  In x (getSupport (RndNat k)).

Lemma RndNat_support_length : 
  forall n, 
    length (getSupport (RndNat n)) = n.

Theorem RndNat_prob : 
  forall n i (nzn : nz n),
    i < n ->
    evalDist (RndNat n) i == 1 / n.

Theorem RndNat_seq : 
  forall (n : posnat)(A : Set)(c : nat -> Comp A) a,
    evalDist (x <-$ RndNat n; c x) a ==
    (1 / n) * sumList (allNatsLt n) (fun z => evalDist (c z) a).

Lemma rndNat_sumList : 
  forall (A : Set)(f : nat -> Comp A) n (nzn : nz n) x,
    evalDist (i <-$ RndNat n; f i) x == 
    sumList (forNats n) (fun i => (1 / n) * (evalDist (f i) x)). *)
Require Export FCF.Hybrid.
(* FCF.Hybrid:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import FCF.CompFold.

Open Scope list_scope.

Section DistSingle.

  Variable A B : Set.
  Hypothesis B_EqDec : EqDec B.
  Variable c1 c2 : A -> Comp B.
  Variable A_State : Set.
  Variable A1 : Comp (A * A_State).
  Variable A2 : A_State -> B -> Comp bool.

  Definition DistSingle_G(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    b <-$ c a;
    A2 s_A b.

  Definition DistSingle_Adv :=
    | Pr[DistSingle_G c1] - Pr[DistSingle_G c2] |.

End DistSingle.

Section ListHybrid.

  Variable A B State : Set.
  Variable defA : A.
  Variable c1 c2 : A -> Comp B.
  Hypothesis c1_wf : forall a, well_formed_comp (c1 a).
  Hypothesis c2_wf : forall a, well_formed_comp (c2 a).
  Hypothesis A_EqDec : EqDec A.
  Hypothesis B_EqDec : EqDec B.
  Hypothesis State_EqDec : EqDec State.
  Variable A1 : Comp ((list A) * State).
  Variable A2 : State -> list B -> Comp bool.

  Variable maxA : nat.
  Hypothesis maxA_correct : 
    forall ls s_A, 
      In (ls, s_A) (getSupport A1) ->
      (length ls <= maxA)%nat.

  Definition ListHybrid_G (c : A -> Comp B) :=
    [lsA, s_A] <-$2 A1;
    lsB <-$ compMap _ c lsA;
    A2 s_A lsB.

  Definition ListHybrid_Advantage :=
    | Pr[ListHybrid_G c1] - Pr[ListHybrid_G c2] |.

  Definition G_hybrid i :=
    [lsA, s_A] <-$2 A1;
    lsA1 <- firstn i lsA;
    lsA2 <- skipn i lsA;
    lsB1 <-$ compMap _ c1 lsA1;
    lsB2 <-$ compMap _ c2 lsA2;
    A2 s_A (lsB1 ++ lsB2).
  
  Theorem G_2_hybrid_eq : 
    Pr[ListHybrid_G c2] == Pr[G_hybrid 0].

  Theorem skipn_ge_nil : 
    forall (A : Type)(ls : list A)(n : nat),
      n >= length ls ->
      skipn n ls = nil.

  Theorem G_1_hybrid_eq : 
    Pr[ListHybrid_G c1] == Pr[G_hybrid maxA].

  Definition B1 i :=
    [lsA, s_A] <-$2 A1;
    lsA1 <- firstn i lsA;
    a <- nth i lsA defA;
    lsA2 <- skipn (S i) lsA;
    incla <- if (lt_dec i (length lsA)) then true else false;
    ret (a, (incla, lsA1, lsA2, s_A)).                                                

  Definition B2 (e : bool * _ * _ * _) b :=
      let '(incla, lsA1, lsA2, s_A) := e in 
      lsB1 <-$ compMap _ c1 lsA1;
        lsB2 <-$ compMap _ c2 lsA2;
        lsB <- if incla then (lsB1 ++ (b :: lsB2)) else lsB1;
      A2 s_A lsB.

  Local Open Scope list_scope.

  Theorem compMap_unroll : 
    forall (A B : Set)(eqdb : EqDec B)(c : A -> Comp B)(ls : list A)(def : A),
      ls <> nil ->
      comp_spec eq (compMap _ c ls) (x <-$ c (hd def ls); y <-$ compMap _ c (tl ls); ret (x :: y)).

  Theorem skipn_lt_nil_false : 
    forall (A : Type)(ls : list A)(n : nat),
      n < length ls ->
      skipn n ls = nil ->
      False.

  Theorem hd_skip_eq_nth : 
    forall (A : Type)(def : A)(ls : list A)(n : nat),
      hd def (skipn n ls) = nth n ls def.

  Theorem tl_skipn_eq : 
    forall (A : Type)(ls : list A)(n : nat),
      tl (skipn n ls) = skipn (S n) ls.

  Theorem skipn_gt_nil : 
    forall (A : Type)(ls : list A)(n : nat),
      n >= length ls ->
      skipn n ls = nil.

  Theorem G_hybrid_DistSingle_eq : 
    forall i,
      Pr[G_hybrid i] == Pr[DistSingle_G (B1 i) B2 c2].
     
  Theorem compMap_unroll_tl : 
    forall (A B : Set)(def : A)(eqdb : EqDec B)(c : A -> Comp B)(ls : list A) n,
      length ls = S n ->
      comp_spec eq (compMap _ c ls) (y <-$ compMap _ c (firstn n ls); x <-$ c (nth n ls def); ret (y ++ x :: nil)).
             
  Theorem firstn_firstn : 
    forall (A : Type)(ls : list A)(n1 n2 : nat),
      (n1 <= n2)%nat ->
      firstn n1 (firstn n2 ls) = firstn n1 ls.

  Theorem nth_firstn : 
    forall (A : Set)(def : A)(ls : list A)(n1 n2 : nat),
      (n1 < n2)%nat ->
      nth n1 (firstn n2 ls) def = nth n1 ls def.

  Theorem G_hybrid_DistSingle_S_eq : 
    forall i,
      Pr[G_hybrid (S i)] == Pr[DistSingle_G (B1 i) B2 c1].
        
  Theorem hybrid_incr_close : 
    forall i,
  | Pr[G_hybrid i] - Pr[G_hybrid (S i)] | == DistSingle_Adv c1 c2 (B1 i) B2. 
         
  Theorem ratDistance_sequence_sum : 
    forall (f : nat -> Rat)(n : nat),
  | f O - f n | <= sumList (forNats n) (fun i => | f i - f (S i) |).
  
  Theorem Single_impl_ListHybrid_sum :
    ListHybrid_Advantage
    <=
    sumList (forNats maxA) (fun i => DistSingle_Adv c1 c2 (B1 i) B2).

  Variable maxDistance : Rat.
  Hypothesis maxDistance_correct : 
    forall i, DistSingle_Adv c1 c2 (B1 i) B2 <= maxDistance.

  Theorem Single_impl_ListHybrid : 
    ListHybrid_Advantage <= maxA / 1 * maxDistance.
End ListHybrid. *)

Local Open Scope list_scope.

Section DistMult.

  Variable A B : Set.
  Hypothesis B_EqDec : EqDec B.
  Variable c1 c2 : A -> Comp B.
  Variable A_State : Set.
  Variable A1 : Comp (A * A_State).
  Variable A2 : A_State -> list B -> Comp bool.

  Variable n : nat.

  Definition DistMult_G(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    b <-$ compMap _ (fun _ => (c a)) (forNats n);
    A2 s_A b.

  Definition DistMult_Adv :=
    | Pr[DistMult_G c1] - Pr[DistMult_G c2] |.

End DistMult.

Section DistSingle_impl_Mult.

  Variable A B : Set.
  Variable A_EqDec : EqDec A.
  Variable B_EqDec : EqDec B.
  Variable c1 c2 : A -> Comp B.
  Variable A_State : Set.
  Variable A_State_EqDec : EqDec A_State.
  Variable A1 : Comp (A * A_State).
  Variable A2 : A_State -> list B -> Comp bool.
  
  Hypothesis c1_wf : forall a, well_formed_comp (c1 a).
  Hypothesis c2_wf : forall a, well_formed_comp (c2 a).

  Definition computeHybrid(n i : nat) a : Comp (list B) :=
    b1 <-$ compMap _ (fun _ => (c1 a)) (forNats i);
    b2 <-$ compMap _ (fun _ => (c2 a)) (forNats (minus n i));
    ret (b1 ++ b2).

  Variable n : nat.
  Hypothesis n_pos : n > 0.

  Theorem hybrid_replace_c1_equiv : 
    forall i x a,
      i < n ->
      evalDist 
        (b <-$ (c1 a);
         hybrid <-$ computeHybrid n i a;
         ret (listReplace hybrid i b b)) x ==
      evalDist (computeHybrid n (S i) a) x.

    induction n; destruct i; intuition; try omega.
    unfold computeHybrid.
    unfold minus.
    fold minus.
    rewrite <- minus_n_O.
    unfold forNats.
    fold forNats.
    unfold compMap.
    fold compMap.
    inline_first.
    comp_skip.
    inline_first.
    comp_simp.
    comp_irr_l.
    inline_first.
    comp_skip.
    simpl.
    intuition.

    unfold computeHybrid.
    unfold minus.
    fold minus.
    unfold forNats.
    fold forNats.
    unfold compMap.
    fold compMap.

    inline_first.
    do 2 comp_at comp_inline leftc 1%nat.
    comp_swap_l.
    comp_skip.

    assert 
      (evalDist
     (a1 <-$
      (lsb' <-$
       (b <-$ (c1 a);
        lsb' <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats i);
        ret b :: lsb'); ret x0 :: lsb');
      a2 <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats (n0 - S i));
      ret a1 ++ a2) x == 
       evalDist
     (ls <-$ (computeHybrid n0 (S i) a);
      ret (x0 :: ls)) x).

    unfold computeHybrid.
    unfold forNats.
    fold forNats.
    unfold compMap.
    fold compMap.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    comp_simp.
    inline_first.
    comp_skip.
    comp_simp.
    simpl.
    intuition.
    rewrite H1.
    clear H1.
    eapply eqRat_trans.
    2:{
      comp_skip.
      eapply eqRat_refl.
    }
    unfold computeHybrid.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    comp_simp.
    simpl.
    intuition.

  Qed.

  Theorem hybrid_replace_c2_equiv : 
    forall i x a,
      i < n ->
      evalDist 
        (b <-$ (c2 a);
         hybrid <-$ computeHybrid n i a;
         ret (listReplace hybrid i b b)) x ==
      evalDist (computeHybrid n i a) x.

    induction n; destruct i; intuition; try omega.

    unfold computeHybrid.
    unfold minus.
    unfold forNats.
    fold forNats.
    unfold compMap.
    fold compMap.
    comp_simp.
    inline_first.
    comp_skip.
    inline_first.
    comp_irr_l.
    inline_first.
    comp_skip.
    comp_simp.
    simpl.
    intuition.
   
    unfold computeHybrid.
    unfold minus.
    fold minus.
    unfold forNats.
    fold forNats.
    unfold compMap.
    fold compMap.
    inline_first.
    do 2 comp_at comp_inline leftc 1%nat.
    comp_swap_l.
    comp_skip.

    assert (evalDist
     (a1 <-$
      (lsb' <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats i);
       ret x0 :: lsb');
      a2 <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats (n0 - i));
      ret a1 ++ a2) x == 
            evalDist
     (ls <-$ 
         (a1 <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats i);
          a2 <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats (n0 - i));
          ret a1 ++ a2);
         ret (x0 :: ls)) x).

    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    comp_simp.
    rewrite app_comm_cons.
    intuition.
    rewrite H1.
    clear H1.
    eapply eqRat_trans.
    2:{
      comp_skip.
      eapply IHn0.
      omega.
      omega.
      eapply eqRat_refl.
    }
    unfold computeHybrid.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    inline_first.
    comp_skip.
    comp_simp.
    simpl.
    intuition.
  Qed.

  Definition B1 : Comp (A * (A * A_State)) :=
    [a, s_A] <-$2 A1;
    ret (a, (a, s_A)). 

  Definition B2(s : A * A_State)(b : B) : Comp bool :=
    [a, s_A] <-2 s;
    i <-$ [0 .. n);
    rndHybrid <-$ computeHybrid n i a;
    distHybrid <- listReplace rndHybrid i b b;
    A2 s_A distHybrid.

  Definition DistSingle_G1(c : A -> Comp B) :=
    [a, s_A] <-$2 B1; 
    b <-$ (c a); 
    B2 s_A b.

  Theorem DistSingle_G1_equiv : 
      DistSingle_Adv c1 c2 B1 B2 ==
      (| Pr[DistSingle_G1 c1] - Pr[DistSingle_G1 c2] |).

    unfold DistSingle_Adv, DistSingle_G1, DistSingle_G.
    intuition.

  Qed.

  Definition DistSingle_G2(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    i <-$ [ 0  .. n);
    distHybrid <-$
               (b <-$ c a;
                rndHybrid <-$ computeHybrid n i a;
                ret (listReplace rndHybrid i b b)); 
    A2 s_A distHybrid.

  Theorem DistSingle_G2_equiv : 
    forall c, 
      Pr[DistSingle_G1 c] == Pr[DistSingle_G2 c].

    intuition.
    unfold DistSingle_G1, DistSingle_G2.
    unfold B1, B2.
    inline_first.
    comp_skip.
    comp_simp.
    comp_swap_l.
    comp_skip.
    inline_first.
    comp_skip.
    comp_inline_r.
    comp_skip.
    comp_simp.
    intuition.

  Qed.

  Definition DistSingle_G3_c2 :=
    i <-$ [ 0  .. n);
    [a, s_A] <-$2 A1;
    distHybrid <-$ computeHybrid n i a;
    A2 s_A distHybrid.

  Definition DistSingle_G3_c1 :=
    i <-$ [ 0  .. n);
    [a, s_A] <-$2 A1;
    distHybrid <-$ computeHybrid n (S i) a;
    A2 s_A distHybrid.

  Theorem DistSingle_G3_c2_equiv : 
    Pr[DistSingle_G2 c2] == Pr[DistSingle_G3_c2].

    unfold DistSingle_G2, DistSingle_G3_c2.
    comp_swap_r.
    comp_skip.
    comp_simp.
    comp_skip.
    comp_skip.
    eapply hybrid_replace_c2_equiv.
    eapply RndNat_support_lt; intuition.
    
  Qed.

  Theorem DistSingle_G3_c1_equiv : 
    Pr[DistSingle_G2 c1] == Pr[DistSingle_G3_c1].

    unfold DistSingle_G2, DistSingle_G3_c1.
    comp_swap_r.
    comp_skip.
    comp_simp.
    comp_skip.
    comp_skip.
    eapply hybrid_replace_c1_equiv.
    eapply RndNat_support_lt; intuition.
    
  Qed.

  Theorem compMap_computeHybrid_0_equiv : 
    forall s_A a, 
      Pr  [b <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats n); A2 s_A b ] ==
      Pr  [x <-$ computeHybrid n 0 a; A2 s_A x ].
    
    intuition.
    unfold computeHybrid.
    unfold forNats.
    fold forNats.
    inline_first.
    unfold compMap.
    fold compMap.
    comp_simp.
    inline_first.
    rewrite <- minus_n_O.
    comp_skip.
    comp_simp.
    simpl.
    intuition.
  Qed.
  
  Theorem compMap_computeHybrid_n_equiv : 
    forall s_A a,
    Pr  [b <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats n); A2 s_A b ] ==
    Pr  [x <-$ computeHybrid n n a; A2 s_A x ].

    intuition.
    unfold computeHybrid.
    inline_first.
    comp_skip.
    
    inline_first.
    rewrite minus_diag.
    unfold forNats.
    unfold compMap.
    comp_simp.
    rewrite app_nil_r.
    intuition.
  Qed.

  Theorem DistSingle_impl_Mult : 
    DistMult_Adv _ c1 c2 A1 A2 n <= (n / 1) * (DistSingle_Adv c1 c2 B1 B2).

    eapply leRat_trans.
    2:{
      eapply eqRat_impl_leRat.
      rewrite DistSingle_G1_equiv.
      rewrite DistSingle_G2_equiv.
      rewrite DistSingle_G2_equiv.
      rewrite DistSingle_G3_c1_equiv.
      rewrite DistSingle_G3_c2_equiv.
      eapply eqRat_refl.
    }
    
    eapply leRat_trans.
    2:{
      eapply eqRat_impl_leRat.
      unfold DistSingle_G3_c1, DistSingle_G3_c2.
      rewrite rndNat_sumList.
      rewrite rndNat_sumList.
      rewrite sumList_factor_constant_l.
      rewrite sumList_factor_constant_l.
      rewrite ratMult_ratDistance_factor_l.
      eapply eqRat_refl.
    }

    eapply leRat_trans.
    2:{
      eapply eqRat_impl_leRat.
      rewrite <-ratMult_assoc.
      rewrite ratMult_eq_rat1.
      rewrite ratMult_1_l.
      rewrite ratDistance_comm.
      rewrite sumList_forNats_distance.
      eapply eqRat_refl.
    }

    unfold DistMult_Adv.
    unfold DistMult_G.
    rewrite ratDistance_comm.
    eapply eqRat_impl_leRat.
    eapply ratDistance_eqRat_compat.

    eapply evalDist_seq; intuition.
    comp_simp.

    eapply compMap_computeHybrid_0_equiv.

    eapply evalDist_seq; intuition.
    comp_simp.
    eapply compMap_computeHybrid_n_equiv.

    Grab Existential Variables.
    econstructor; intuition.

  Qed.

End DistSingle_impl_Mult.

Section RepeatCore.

  Variable A B : Set.
  Hypothesis B_EqDec : EqDec B.
  Variable P : B -> bool.
  Variable c1 c2 : A -> Comp B.

  Variable A_State : Set.
  Variable A1 : Comp (A * A_State ).
  Variable A2 : A_State -> B -> Comp bool.
  
  Definition RepeatCore_G(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    b <-$ Repeat (c a) P;
    A2 s_A b.

  Definition RepeatCore_Adv :=
    | Pr[RepeatCore_G c1] - Pr[RepeatCore_G c2] |.

End RepeatCore.

Section DistMult_impl_RepeatCore.

  Variable A B : Set.
  Hypothesis B_EqDec : EqDec B.
  Variable P : B -> bool.
  Variable c1 c2 : A -> Comp B.

  Variable A_State : Set.
  Variable A1 : Comp (A * A_State).
  Variable A2 : A_State -> B -> Comp bool.
  Hypothesis A1_wf : well_formed_comp A1.
  Hypothesis A2_wf : forall s_A b, well_formed_comp (A2 s_A b).

  Hypothesis c1_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c1 a).
  Hypothesis c1_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c1 a))).

  Hypothesis c2_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c2 a).
  Hypothesis c2_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c2 a))).

  Variable n : nat.

  Definition DM_RC_G1(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    p <-$ Repeat (b <-$ (c a); g <-$ (A2 s_A b); ret (b, g)) (fun p => P (fst p)); 
    ret (snd p).

  Theorem DM_RC_G1_equiv :
    forall c x,
      (forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c a)) ->
      (forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c a)))) ->
      evalDist (RepeatCore_G P A1 A2 c) x == evalDist (DM_RC_G1 c) x.

    intuition.
    unfold RepeatCore_G, DM_RC_G1.
    comp_skip.

    comp_simp.
    assert (evalDist (b0 <-$ Repeat (c a) P; A2 a0 b0) x 
                      ==
                      evalDist (p <-$ (b0 <-$ Repeat (c a) P; b <-$ A2 a0 b0; ret (b0, b)); ret (snd p)) x).
    inline_first.
    comp_skip.
    inline_first.
    rewrite <- evalDist_right_ident.
    comp_skip.
    comp_simp.
    simpl.
    reflexivity.
    rewrite H2.
    comp_skip.
    
    eapply repeat_fission; intuition.
    eauto.
    eauto.
  Qed.

  Definition DM_RC_G2(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    p <-$ Repeat (b <-$ (c a); g <-$ (A2 s_A b); ret (b, g)) (fun p => P (fst p));
    ret (Some (snd p)).

  Theorem DM_RC_G2_equiv :
     forall c x,
       evalDist (DM_RC_G1 c) x == evalDist (DM_RC_G2 c) (Some x).

     intuition.
     unfold DM_RC_G1, DM_RC_G2.
     comp_skip.
     comp_simp.
     comp_skip.
     dist_compute.
   Qed.

  Definition DM_RC_G3(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    ls <-$ compMap _ (fun _ => b <-$ c a; g <-$ (A2 s_A b); ret (b, g)) (forNats n);
    ret hd_error (map (fun x => snd x) (filter (fun p => P (fst p)) ls)).

  Theorem DM_RC_G2_G3_close : 
     forall (c : A -> Comp B) k x,
       (forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c a)) ->
       (forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c a)))) ->
       (forall a s_A, In (a, s_A) (getSupport A1) -> Pr[b <-$ c a; ret (negb (P b))] <= k) ->
       | evalDist (DM_RC_G2 c) x - evalDist (DM_RC_G3 c) x | <= expRat k n.

     intuition.
     unfold DM_RC_G2, DM_RC_G3.

     eapply evalDist_bind_distance; intuition.

     rewrite ratDistance_comm.
     eapply leRat_trans.

     eapply compMap_Repeat_close.
     wftac.

     edestruct H0.
     eauto.
     apply filter_In in H3.
     intuition.
     specialize (A2_wf b0 x0).
     apply well_formed_val_exists in A2_wf.
     destruct A2_wf.
     econstructor.
     eapply filter_In.
     intuition.
     eapply getSupport_In_Seq.
     eauto.
     eapply getSupport_In_Seq.
     eauto.
     simpl.
     intuition.
     simpl.
     trivial.

     eapply expRat_leRat_compat.
     eapply leRat_trans.
     2:{
      eapply H1.
      eauto.
     }
     comp_inline_l.
     comp_skip.
     inline_first.
     comp_irr_l.
     simpl.
     intuition.
  Qed.

  Definition DM_RC_G4(c : A -> Comp B) :=
     [a, s_A] <-$2 A1;
     allB <-$ compMap _ (fun _ => (c a)) (forNats n);
     allB_G <-$ compMap _ (fun b => g <-$ (A2 s_A b); ret (b, g)) allB;
     ret hd_error (map (fun x => snd x) (filter (fun p => P (fst p)) allB_G)).

  Theorem DM_RC_G4_equiv : 
     forall c x, 
     evalDist (DM_RC_G3 c) x == evalDist (DM_RC_G4 c) x.

     intuition.
     unfold DM_RC_G3, DM_RC_G4.
     comp_skip.
     symmetry.
     comp_simp.
     rewrite <- evalDist_assoc; intuition.
     comp_skip.
     eapply comp_spec_eq_impl_eq.
     eapply (@compMap_fission_eq _ _ _ _ _ _ _ _ _ _ _ _ eq); intuition.
     simpl.
     eapply comp_spec_eq_refl.

     subst.
     simpl.
     eapply eq_impl_comp_spec_eq.
     intuition.
     comp_at comp_inline rightc 1%nat.
     comp_swap_r.
     inline_first.
     comp_skip.
     comp_skip.
     comp_simp.
     intuition.
   Qed.
   
   Definition DM_RC_G5(c : A -> Comp B) :=
     [a, s_A] <-$2 A1;
     allB <-$ compMap _ (fun _ => (c a)) (forNats n);
     allG <-$ compMap _ (A2 s_A) (filter P allB);
     ret hd_error allG.

   Theorem DM_RC_G5_equiv : 
     forall (c : A -> Comp B) x,
       evalDist (DM_RC_G4 c) x ==
     evalDist (DM_RC_G5 c) x.

     intuition.
     unfold DM_RC_G4, DM_RC_G5.
     comp_skip.
     comp_simp.
     comp_skip.
     symmetry.
     eapply eqRat_trans.
     comp_skip.
     eapply compMap_filter.
     intuition.
     eapply eqRat_refl.
     inline_first.
     comp_skip.

     dist_compute.
   Qed.

   Definition DM_RC_G6(c : A -> Comp B) :=
    [a, s_A] <-$2 A1;
    opt_b' <-$ (
             b <-$ compMap B_EqDec (fun _ : nat => (c a)) (forNats n);
             ret head (filter P b));
    match opt_b' with
      | Some b' => A2 s_A b'
      | None => ret false
    end.

   Theorem DM_RC_G6_equiv : 
     forall (c : A -> Comp B),
       evalDist (DM_RC_G5 c) (Some true) ==
     evalDist (DM_RC_G6 c) true.

     unfold DM_RC_G5, DM_RC_G6.
     intuition.
     comp_skip.
     comp_simp.
     inline_first.
     comp_skip.
     rewrite compMap_head.
     comp_simp.
     destruct (hd_error (filter P x)).
     symmetry.
     rewrite <- evalDist_right_ident.
     comp_skip.
     dist_compute.
     dist_compute.
     intuition.     

     Grab Existential Variables.
     intuition.

   Qed.

   Definition DM_RC_B2 s_A (b : list B) :=
    core_b <- filter P b;
    opt_b' <- head core_b;
    match opt_b' with
        | None => ret false
        | Some b' => A2 s_A b'
    end.

  Theorem DistMult_G_equiv : 
    forall c, 
      Pr[DM_RC_G6 c] == Pr[DistMult_G _ A1 DM_RC_B2 n c] .

    intuition.
    unfold DistMult_G, DM_RC_G6, DM_RC_B2.
    comp_skip.
    comp_simp.
    inline_first.
    comp_skip.
  Qed.

  Variable k1 : Rat.
   Hypothesis c1_fail_prob : 
     forall a s_A, In (a, s_A) (getSupport A1) -> Pr[b <-$ c1 a; ret (negb (P b))] <= k1.
   Variable k2 : Rat.
   Hypothesis c2_fail_prob : 
     forall a s_A, In (a, s_A) (getSupport A1) -> Pr[b <-$ c2 a; ret (negb (P b))] <= k2.

  Theorem DistMult_impl_RepeatCore :
    RepeatCore_Adv P c1 c2 A1 A2 <= 
    DistMult_Adv _ c1 c2 A1 DM_RC_B2 n + 
    expRat k1 n +
    expRat k2 n.

    unfold RepeatCore_Adv, DistMult_Adv.
    repeat rewrite DM_RC_G1_equiv.
    repeat rewrite DM_RC_G2_equiv.

    eapply leRat_trans.
    eapply ratDistance_le_trans.
    eapply DM_RC_G2_G3_close; intuition.
    eauto.
    rewrite ratDistance_comm.
    eapply ratDistance_le_trans.
    eapply DM_RC_G2_G3_close; intuition.
    eauto.
    repeat rewrite DM_RC_G4_equiv.
    repeat rewrite DM_RC_G5_equiv.
    repeat rewrite DM_RC_G6_equiv.
    repeat rewrite DistMult_G_equiv.
    eapply leRat_refl.

    rewrite <- ratAdd_assoc.
    rewrite ratAdd_comm.
    rewrite <- ratAdd_assoc.
    rewrite ratDistance_comm.
    intuition.

    intuition.
    intuition.
    intuition.
    intuition.

  Qed.

End DistMult_impl_RepeatCore.

Section TrueSingle_impl_Mult.

  Variable A B : Set.
  Hypothesis B_EqDec : EqDec B.
  Variable c : A -> Comp B.
  Variable A1 : Comp A.
  Variable Q : B -> bool.

  Definition TrueSingle_G := 
    a <-$ A1;
    b <-$ c a;
    ret (Q b).

  Variable n : nat.

  Definition TrueMult_G :=
    a <-$ A1;
    bs <-$ compMap _ (fun _ => (c a)) (forNats n);
    ret (fold_left (fun b x => b || (Q x)) bs false).

  Theorem TrueSingle_impl_Mult :
    Pr[TrueMult_G] <= (n / 1) * Pr[TrueSingle_G].

    unfold TrueMult_G, TrueSingle_G.

    simpl in *.
    
    eapply leRat_trans.
    2:{
      eapply eqRat_impl_leRat.
      eapply sumList_factor_constant_l.
    }
    eapply sumList_le.
    intuition.

    eapply leRat_trans.
    2:{
      eapply eqRat_impl_leRat.
      symmetry.
      rewrite ratMult_comm.
      eapply ratMult_assoc.
    }
    eapply ratMult_leRat_compat.
    intuition.

    specialize (@compMap_Q_eq_compFold _ _ Q n (c a) false); intuition.
    rewrite H0.
    rewrite prob_sum_le_mult.
    rewrite ratMult_comm.
    eapply ratMult_leRat_compat; intuition.

    Local Transparent evalDist.
    simpl.
    reflexivity.

  Qed.

End TrueSingle_impl_Mult.

Section TrueMult_impl_Repeat.

  Variable A B : Set.
  Hypothesis eqdb : EqDec B.
  Variable A1 : Comp A.
  Hypothesis A1_wf : 
    well_formed_comp A1.
  Variable c : A -> Comp B.
  Variable f P : B -> bool.

  Hypothesis c_wf :
    forall x, In x (getSupport A1) -> well_formed_comp (c x).       

  Hypothesis Repeat_c_terminating : 
    forall x, In x (getSupport A1) -> 
              exists x1 : B, In x1 (filter P (getSupport (c x))).

  Definition TrueRepeat_G :=
    a <-$ A1;
    b <-$ Repeat (c a) P;
    ret (f b).

  Variable n : nat.
  Variable failProb : Rat.
  Hypothesis failProb_correct : 
    forall (a : A), 
      In a (getSupport A1) ->
      Pr[x <-$ c a; ret negb (P x)] <= failProb.

  Definition TrueRepeat_G1 :=
    a <-$ A1;
    bs <-$ compMap _ (fun _ => c a) (forNats n);
    b_opt <- hd_error (filter P bs);
    b' <-$ Repeat (c a) P;
    b <- match b_opt with
           | None => b'
           | Some x => x
         end;
    ret (f b).

   Theorem  TrueRepeat_G_G1_equiv :
     Pr[ TrueRepeat_G] == Pr[TrueRepeat_G1].

     unfold TrueRepeat_G, TrueRepeat_G1.
     inline_first.
     comp_skip.
     
     assert (Pr  [b <-$ Repeat (c x) P; ret f b ] ==
             Pr  [b <-$ (y <-$ compMap _ (fun _ => (c x)) (forNats n);
                   match (hd_error (filter P y)) with
                     | None => Repeat (c x) P
                     | Some z => ret z
                   end); ret f b ]).

     comp_skip.
     eapply Repeat_unroll_n.
     eauto.
     eauto.

     rewrite H0.
     clear H0.
     inline_first.
     comp_skip.
     case_eq (hd_error (filter P x0)); intuition.
     comp_irr_r.
     edestruct Repeat_c_terminating; eauto.
     eapply well_formed_Repeat.
     unfold eq_dec.
     intuition.
     eapply (EqDec_dec _).
     eauto.
     eauto.

     reflexivity.

   Qed.

   Definition TrueRepeat_G2 :=
     a <-$ A1;
     bs <-$ compMap _ (fun _ => c a) (forNats n);
     b_opt <- hd_error (filter P bs);
     b' <-$ Repeat (c a) P;
     b <- match b_opt with
           | None => b'
           | Some x => x
          end;
     ret (f b, if b_opt then false else true).

   Theorem TrueRepeat_G1_G2_equiv : 
     Pr [TrueRepeat_G1] <= Pr[x <-$ TrueRepeat_G2; ret (fst x || snd x)].

     unfold TrueRepeat_G1, TrueRepeat_G2.
     repeat (inline_first; comp_skip).
     destruct (hd_error (filter P x0)).
     comp_simp.
     dist_compute.
     rewrite e in n0.
     simpl in *.
     intuition.
     eapply rat0_le_all.

     comp_simp.
     dist_compute.
     rewrite e in n0.
     simpl in *.
     intuition.
     eapply rat0_le_all.
    
   Qed.

   Definition TrueRepeat_G3 :=
     a <-$ A1;
     bs <-$ compMap _ (fun _ => c a) (forNats n);
     b_opt <- hd_error (filter P bs);
     b' <-$ Repeat (c a) P;
     b <- match b_opt with
           | None => b'
           | Some x => x
          end;
     ret (fold_left (fun b x => b || (f x)) bs false, if b_opt then false else true).

   Theorem TrueRepeat_G2_G3_equiv : 
     Pr[x <-$ TrueRepeat_G2; ret (fst x || snd x)] <= 
     Pr[x <-$ TrueRepeat_G3; ret (fst x || snd x)].

     unfold TrueRepeat_G2, TrueRepeat_G3.
     repeat (inline_first; comp_skip).
     comp_simp.
     eapply comp_spec_impl_le.
     eapply 
       comp_spec_ret.
     simpl.
     
     case_eq ( hd_error (filter P x0)); intuition.
     rewrite orb_false_r in *.

     eapply fold_left_orb_true_in.
     eapply filter_In.

     eapply hd_error_Some_In.
     eauto.
     trivial.
     
   Qed.

   Definition TrueRepeat_G3_bad :=
      a <-$ A1;
     compFold _ (fun b _ => x <-$ c a; ret b && negb (P x)) true (forNats n).

   Theorem G3_TrueMult_equiv : 
     Pr[x <-$ TrueRepeat_G3; ret (fst x)] ==
     Pr[TrueMult_G _ c A1 f n].

     unfold TrueRepeat_G3, TrueMult_G.
     inline_first.
     comp_skip.
     inline_first.
     comp_skip.
     inline_first.
     comp_irr_l.
     edestruct Repeat_c_terminating; eauto.
     eapply well_formed_Repeat.
     unfold eq_dec; intuition.
     eapply (EqDec_dec _).
     eauto.
     eauto.

     simpl.
     intuition.
   Qed.

   Theorem TrueRepeat_G1_bad_equiv :
      Pr  [x <-$ TrueRepeat_G3; ret snd x ] == 
      Pr[TrueRepeat_G3_bad].

     unfold TrueRepeat_G3, TrueRepeat_G3_bad.

     inline_first.
     comp_skip.
     
     assert(
         Pr 
   [x0 <-$
    (bs <-$ compMap eqdb (fun _ : nat => c x) (forNats n);
     _ <-$ Repeat (c x) P;
     ret (fold_left (fun (b : bool) (x0 : B) => b || f x0) bs false,
         if hd_error (filter P bs) then false else true)); 
    ret snd x0 ]
   ==
   Pr 
   [x0 <-$
    (_ <-$ Repeat (c x) P;
      bs <-$ compMap eqdb (fun _ : nat => c x) (forNats n);
     
     ret (fold_left (fun (b : bool) (x0 : B) => b || f x0) bs false,
         if hd_error (filter P bs) then false else true)); 
    ret snd x0 ]
   ).
     
     comp_skip.
     comp_swap_r.
     comp_skip.
     rewrite H0.
     clear H0.

     inline_first.
     comp_irr_l.
     edestruct Repeat_c_terminating.
     eauto.
     eapply well_formed_Repeat.
     unfold eq_dec; intuition.
     eapply (EqDec_dec _).
     eauto.
     eauto.

     assert (
         Pr 
   [x1 <-$
    (bs <-$ compMap eqdb (fun _ : nat => c x) (forNats n);
     ret (fold_left (fun (b : bool) (x1 : B) => b || f x1) bs false,
         if hd_error (filter P bs) then false else true)); 
    ret snd x1 ]
   ==
   Pr 
   [bs <-$ compMap eqdb (fun _ : nat => c x) (forNats n);
     ret (fold_left (fun b z => b && negb (P z)) bs true)]
   ).

     inline_first.
     comp_skip.
     eapply comp_spec_eq_impl_eq.
     simpl.
     eapply comp_spec_ret.

     eapply hd_filter_false_eq_and_false.
 
     rewrite H1.
     clear H1.

     symmetry.
     eapply comp_spec_eq_impl_eq.
     eapply comp_spec_eq_trans.
     eapply fold_map_fission_spec_eq.
     intros.
     eapply comp_spec_eq_refl.
     comp_skip.

     eapply compFold_ret_eq.

   Qed.

   Theorem TrueRepeat_G2_bad_small :
      Pr[TrueRepeat_G3_bad] <= expRat failProb n.

      unfold TrueRepeat_G3_bad.
      comp_irr_l.

      rewrite prob_fold_and_eq_exp.
      eapply expRat_leRat_compat.
      intuition.
    Qed.

   Theorem TrueRepeat_G3_eq_sum : 
     Pr[x <-$ TrueRepeat_G3; ret (fst x || snd x)] <=
     Pr[TrueMult_G _ c A1 f n] + expRat failProb n.

     rewrite  evalDist_orb_le.
     rewrite G3_TrueMult_equiv.
     rewrite TrueRepeat_G1_bad_equiv .
     rewrite TrueRepeat_G2_bad_small.
     intuition.
   Qed.

    Theorem TrueMult_impl_Repeat :
      Pr[TrueRepeat_G] <= 
      Pr[TrueMult_G _ c A1 f n] + (expRat failProb n). 

      rewrite TrueRepeat_G_G1_equiv.
      rewrite TrueRepeat_G1_G2_equiv.
      rewrite TrueRepeat_G2_G3_equiv.
      eapply TrueRepeat_G3_eq_sum.

    Qed.

End TrueMult_impl_Repeat.

