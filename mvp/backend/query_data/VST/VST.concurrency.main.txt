

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.



Require Import compcert.common.Globalenvs.
(* compcert.common.Globalenvs:
Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Senv.

Record t: Type := mksenv {
  
  find_symbol: ident -> option block;
  public_symbol: ident -> bool;
  invert_symbol: block -> option ident;
  block_is_volatile: block -> bool;
  nextblock: block;
  
  find_symbol_injective:
    forall id1 id2 b, find_symbol id1 = Some b -> find_symbol id2 = Some b -> id1 = id2;
  invert_find_symbol:
    forall id b, invert_symbol b = Some id -> find_symbol id = Some b;
  find_invert_symbol:
    forall id b, find_symbol id = Some b -> invert_symbol b = Some id;
  public_symbol_exists:
    forall id, public_symbol id = true -> exists b, find_symbol id = Some b;
  find_symbol_below:
    forall id b, find_symbol id = Some b -> Plt b nextblock;
  block_is_volatile_below:
    forall b, block_is_volatile b = true -> Plt b nextblock
}.

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Definition equiv (se1 se2: t) : Prop :=
     (forall id, find_symbol se2 id = find_symbol se1 id)
  /\ (forall id, public_symbol se2 id = public_symbol se1 id)
  /\ (forall b, block_is_volatile se2 b = block_is_volatile se1 b).

End Senv.

Module Genv.

Section GENV.

Variable F: Type.  
Variable V: Type.  

Record t: Type := mkgenv {
  genv_public: list ident;              
  genv_symb: PTree.t block;             
  genv_defs: PTree.t (globdef F V);     
  genv_next: block;                     
  genv_symb_range: forall id b, PTree.get id genv_symb = Some b -> Plt b genv_next;
  genv_defs_range: forall b g, PTree.get b genv_defs = Some g -> Plt b genv_next;
  genv_vars_inj: forall id1 id2 b,
    PTree.get id1 genv_symb = Some b -> PTree.get id2 genv_symb = Some b -> id1 = id2
}.

Definition find_symbol (ge: t) (id: ident) : option block :=
  PTree.get id ge.(genv_symb).

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Definition public_symbol (ge: t) (id: ident) : bool :=
  match find_symbol ge id with
  | None => false
  | Some _ => In_dec ident_eq id ge.(genv_public)
  end.

Definition find_def (ge: t) (b: block) : option (globdef F V) :=
  PTree.get b ge.(genv_defs).

Definition find_funct_ptr (ge: t) (b: block) : option F :=
  match find_def ge b with Some (Gfun f) => Some f | _ => None end.

Definition find_funct (ge: t) (v: val) : option F :=
  match v with
  | Vptr b ofs => if Ptrofs.eq_dec ofs Ptrofs.zero then find_funct_ptr ge b else None
  | _ => None
  end.

Definition invert_symbol (ge: t) (b: block) : option ident :=
  PTree.fold
    (fun res id b' => if eq_block b b' then Some id else res)
    ge.(genv_symb) None.

Definition find_var_info (ge: t) (b: block) : option (globvar V) :=
  match find_def ge b with Some (Gvar v) => Some v | _ => None end.

Definition block_is_volatile (ge: t) (b: block) : bool :=
  match find_var_info ge b with
  | None => false
  | Some gv => gv.(gvar_volatile)
  end.

Program Definition add_global (ge: t) (idg: ident * globdef F V) : t :=
  @mkgenv
    ge.(genv_public)

Definition add_globals (ge: t) (gl: list (ident * globdef F V)) : t :=
  List.fold_left add_global gl ge.

Lemma add_globals_app:
  forall gl2 gl1 ge,
  add_globals ge (gl1 ++ gl2) = add_globals (add_globals ge gl1) gl2.

Program Definition empty_genv (pub: list ident): t :=
  @mkgenv pub (PTree.empty _) (PTree.empty _) 1%positive _ _ _.

Definition globalenv (p: program F V) :=
  add_globals (empty_genv p.(prog_public)) p.(prog_defs).

Section GLOBALENV_PRINCIPLES.

Variable P: t -> Prop.

Lemma add_globals_preserves:
  forall gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  P ge -> P (add_globals ge gl).

Lemma add_globals_ensures:
  forall id g gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> P (add_globals ge gl).

Lemma add_globals_unique_preserves:
  forall id gl ge,
  (forall ge id1 g, P ge -> In (id1, g) gl -> id1 <> id -> P (add_global ge (id1, g))) ->
  ~In id (map fst gl) -> P ge -> P (add_globals ge gl).

Lemma add_globals_unique_ensures:
  forall gl1 id g gl2 ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  ~In id (map fst gl2) -> P (add_globals ge (gl1 ++ (id, g) :: gl2)).

Remark in_norepet_unique:
  forall id g (gl: list (ident * globdef F V)),
  In (id, g) gl -> list_norepet (map fst gl) ->
  exists gl1 gl2, gl = gl1 ++ (id, g) :: gl2 /\ ~In id (map fst gl2).

Lemma add_globals_norepet_ensures:
  forall id g gl ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> list_norepet (map fst gl) -> P (add_globals ge gl).

End GLOBALENV_PRINCIPLES.

Theorem public_symbol_exists:
  forall ge id, public_symbol ge id = true -> exists b, find_symbol ge id = Some b.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Theorem find_funct_inv:
  forall ge v f,
  find_funct ge v = Some f -> exists b, v = Vptr b Ptrofs.zero.

Theorem find_funct_find_funct_ptr:
  forall ge b,
  find_funct ge (Vptr b Ptrofs.zero) = find_funct_ptr ge b.

Theorem find_funct_ptr_iff:
  forall ge b f, find_funct_ptr ge b = Some f <-> find_def ge b = Some (Gfun f).

Theorem find_var_info_iff:
  forall ge b v, find_var_info ge b = Some v <-> find_def ge b = Some (Gvar v).

Theorem find_def_symbol:
  forall p id g,
  (prog_defmap p)!id = Some g <-> exists b, find_symbol (globalenv p) id = Some b /\ find_def (globalenv p) b = Some g.

Theorem find_symbol_exists:
  forall p id g,
  In (id, g) (prog_defs p) ->
  exists b, find_symbol (globalenv p) id = Some b.

Theorem find_symbol_inversion : forall p x b,
  find_symbol (globalenv p) x = Some b ->
  In x (prog_defs_names p).

Theorem find_def_inversion:
  forall p b g,
  find_def (globalenv p) b = Some g ->
  exists id, In (id, g) (prog_defs p).

Corollary find_funct_ptr_inversion:
  forall p b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Corollary find_funct_inversion:
  forall p v f,
  find_funct (globalenv p) v = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Theorem find_funct_ptr_prop:
  forall (P: F -> Prop) p b f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct_ptr (globalenv p) b = Some f ->
  P f.

Theorem find_funct_prop:
  forall (P: F -> Prop) p v f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct (globalenv p) v = Some f ->
  P f.

Theorem global_addresses_distinct:
  forall ge id1 id2 b1 b2,
  id1 <> id2 ->
  find_symbol ge id1 = Some b1 ->
  find_symbol ge id2 = Some b2 ->
  b1 <> b2.

Theorem invert_find_symbol:
  forall ge id b,
  invert_symbol ge b = Some id -> find_symbol ge id = Some b.

Theorem find_invert_symbol:
  forall ge id b,
  find_symbol ge id = Some b -> invert_symbol ge b = Some id.

Definition advance_next (gl: list (ident * globdef F V)) (x: positive) :=
  List.fold_left (fun n g => Pos.succ n) gl x.

Remark genv_next_add_globals:
  forall gl ge,
  genv_next (add_globals ge gl) = advance_next gl (genv_next ge).

Remark genv_public_add_globals:
  forall gl ge,
  genv_public (add_globals ge gl) = genv_public ge.

Theorem globalenv_public:
  forall p, genv_public (globalenv p) = prog_public p.

Theorem block_is_volatile_below:
  forall ge b, block_is_volatile ge b = true ->  Plt b ge.(genv_next).

Definition to_senv (ge: t) : Senv.t :=
 @Senv.mksenv
    (find_symbol ge)
    (public_symbol ge)
    (invert_symbol ge)
    (block_is_volatile ge)
    ge.(genv_next)
    ge.(genv_vars_inj)
    (invert_find_symbol ge)
    (find_invert_symbol ge)
    (public_symbol_exists ge)
    ge.(genv_symb_range)
    (block_is_volatile_below ge).

Section INITMEM.

Variable ge: t.

Definition store_init_data (m: mem) (b: block) (p: Z) (id: init_data) : option mem :=
  match id with
  | Init_int8 n => Mem.store Mint8unsigned m b p (Vint n)
  | Init_int16 n => Mem.store Mint16unsigned m b p (Vint n)
  | Init_int32 n => Mem.store Mint32 m b p (Vint n)
  | Init_int64 n => Mem.store Mint64 m b p (Vlong n)
  | Init_float32 n => Mem.store Mfloat32 m b p (Vsingle n)
  | Init_float64 n => Mem.store Mfloat64 m b p (Vfloat n)
  | Init_addrof symb ofs =>
      match find_symbol ge symb with
      | None => None
      | Some b' => Mem.store Mptr m b p (Vptr b' ofs)
      end
  | Init_space n => Some m
  end.

Fixpoint store_init_data_list (m: mem) (b: block) (p: Z) (idl: list init_data)
                              {struct idl}: option mem :=
  match idl with
  | nil => Some m
  | id :: idl' =>
      match store_init_data m b p id with
      | None => None
      | Some m' => store_init_data_list m' b (p + init_data_size id) idl'
      end
  end.

Definition perm_globvar (gv: globvar V) : permission :=
  if gv.(gvar_volatile) then Nonempty
  else if gv.(gvar_readonly) then Readable
  else Writable.

Definition alloc_global (m: mem) (idg: ident * globdef F V): option mem :=
  match idg with
  | (id, Gfun f) =>
      let (m1, b) := Mem.alloc m 0 1 in
      Mem.drop_perm m1 b 0 1 Nonempty
  | (id, Gvar v) =>
      let init := v.(gvar_init) in
      let sz := init_data_list_size init in
      let (m1, b) := Mem.alloc m 0 sz in
      match store_zeros m1 b 0 sz with
      | None => None
      | Some m2 =>
          match store_init_data_list m2 b 0 init with
          | None => None
          | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)
          end
      end
  end.

Fixpoint alloc_globals (m: mem) (gl: list (ident * globdef F V))
                       {struct gl} : option mem :=
  match gl with
  | nil => Some m
  | g :: gl' =>
      match alloc_global m g with
      | None => None
      | Some m' => alloc_globals m' gl'
      end
  end.

Lemma alloc_globals_app : forall gl1 gl2 m m1,
  alloc_globals m gl1 = Some m1 ->
  alloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2).

Remark store_zeros_nextblock:
  forall m b p n m', store_zeros m b p n = Some m' -> Mem.nextblock m' = Mem.nextblock m.

Remark store_init_data_list_nextblock:
  forall idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  Mem.nextblock m' = Mem.nextblock m.

Remark alloc_global_nextblock:
  forall g m m',
  alloc_global m g = Some m' ->
  Mem.nextblock m' = Pos.succ(Mem.nextblock m).

Remark alloc_globals_nextblock:
  forall gl m m',
  alloc_globals m gl = Some m' ->
  Mem.nextblock m' = advance_next gl (Mem.nextblock m).

Remark store_zeros_perm:
  forall k prm b' q m b p n m',
  store_zeros m b p n = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_perm:
  forall k prm b' q i b m p m',
  store_init_data m b p i = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_list_perm:
  forall k prm b' q idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark alloc_global_perm:
  forall k prm b' q idg m m',
  alloc_global m idg = Some m' ->
  Mem.valid_block m b' ->

Remark alloc_globals_perm:
  forall k prm b' q gl m m',
  alloc_globals m gl = Some m' ->
  Mem.valid_block m b' ->

Remark store_zeros_unchanged:
  forall (P: block -> Z -> Prop) m b p n m',
  store_zeros m b p n = Some m' ->
  (forall i, p <= i < p + n -> ~ P b i) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_unchanged:
  forall (P: block -> Z -> Prop) b i m p m',
  store_init_data m b p i = Some m' ->
  (forall ofs, p <= ofs < p + init_data_size i -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_list_unchanged:
  forall (P: block -> Z -> Prop) b il m p m',
  store_init_data_list m b p il = Some m' ->
  (forall ofs, p <= ofs -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Definition readbytes_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall p n,
  ofs <= p -> p + Z.of_nat n <= ofs + len ->
  Mem.loadbytes m b p (Z.of_nat n) = Some (list_repeat n (Byte Byte.zero)).

Lemma store_zeros_loadbytes:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  readbytes_as_zero m' b p n.

Definition bytes_of_init_data (i: init_data): list memval :=
  match i with
  | Init_int8 n => inj_bytes (encode_int 1%nat (Int.unsigned n))
  | Init_int16 n => inj_bytes (encode_int 2%nat (Int.unsigned n))
  | Init_int32 n => inj_bytes (encode_int 4%nat (Int.unsigned n))
  | Init_int64 n => inj_bytes (encode_int 8%nat (Int64.unsigned n))
  | Init_float32 n => inj_bytes (encode_int 4%nat (Int.unsigned (Float32.to_bits n)))
  | Init_float64 n => inj_bytes (encode_int 8%nat (Int64.unsigned (Float.to_bits n)))
  | Init_space n => list_repeat (Z.to_nat n) (Byte Byte.zero)
  | Init_addrof id ofs =>
      match find_symbol ge id with
      | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b ofs)
      | None   => list_repeat (if Archi.ptr64 then 8%nat else 4%nat) Undef
      end
  end.

Remark init_data_size_addrof:
  forall id ofs, init_data_size (Init_addrof id ofs) = size_chunk Mptr.

Lemma store_init_data_loadbytes:
  forall m b p i m',
  store_init_data m b p i = Some m' ->
  readbytes_as_zero m b p (init_data_size i) ->
  Mem.loadbytes m' b p (init_data_size i) = Some (bytes_of_init_data i).

Fixpoint bytes_of_init_data_list (il: list init_data): list memval :=
  match il with
  | nil => nil
  | i :: il => bytes_of_init_data i ++ bytes_of_init_data_list il
  end.

Lemma store_init_data_list_loadbytes:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  readbytes_as_zero m b p (init_data_list_size il) ->
  Mem.loadbytes m' b p (init_data_list_size il) = Some (bytes_of_init_data_list il).

Definition read_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall chunk p,
  ofs <= p -> p + size_chunk chunk <= ofs + len ->
  (align_chunk chunk | p) ->
  Mem.load chunk m b p =
  Some (match chunk with
        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 => Vint Int.zero
        | Mint64 => Vlong Int64.zero
        | Mfloat32 => Vsingle Float32.zero
        | Mfloat64 => Vfloat Float.zero
        | Many32 | Many64 => Vundef
        end).

Remark read_as_zero_unchanged:
  forall (P: block -> Z -> Prop) m b ofs len m',
  read_as_zero m b ofs len ->
  Mem.unchanged_on P m m' ->

Lemma store_zeros_read_as_zero:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  read_as_zero m' b p n.

Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | Init_int8 n :: il' =>
      Mem.load Mint8unsigned m b p = Some(Vint(Int.zero_ext 8 n))
      /\ load_store_init_data m b (p + 1) il'
  | Init_int16 n :: il' =>
      Mem.load Mint16unsigned m b p = Some(Vint(Int.zero_ext 16 n))
      /\ load_store_init_data m b (p + 2) il'
  | Init_int32 n :: il' =>
      Mem.load Mint32 m b p = Some(Vint n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_int64 n :: il' =>
      Mem.load Mint64 m b p = Some(Vlong n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_float32 n :: il' =>
      Mem.load Mfloat32 m b p = Some(Vsingle n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_float64 n :: il' =>
      Mem.load Mfloat64 m b p = Some(Vfloat n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_addrof symb ofs :: il' =>
      (exists b', find_symbol ge symb = Some b' /\ Mem.load Mptr m b p = Some(Vptr b' ofs))
      /\ load_store_init_data m b (p + size_chunk Mptr) il'
  | Init_space n :: il' =>
      read_as_zero m b p n
      /\ load_store_init_data m b (p + Z.max n 0) il'
  end.

Lemma store_init_data_list_charact:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  read_as_zero m b p (init_data_list_size il) ->
  load_store_init_data m' b p il.

Remark alloc_global_unchanged:
  forall (P: block -> Z -> Prop) m id g m',
  alloc_global m (id, g) = Some m' ->
  Mem.unchanged_on P m m'.

Remark alloc_globals_unchanged:
  forall (P: block -> Z -> Prop) gl m m',
  alloc_globals m gl = Some m' ->
  Mem.unchanged_on P m m'.

Remark load_store_init_data_invariant:
  forall m m' b,
  (forall chunk ofs, Mem.load chunk m' b ofs = Mem.load chunk m b ofs) ->

Definition globals_initialized (g: t) (m: mem) :=
  forall b gd,
  find_def g b = Some gd ->
  match gd with
  | Gfun f =>
         Mem.perm m b 0 Cur Nonempty
      /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty)
  | Gvar v =>
         Mem.range_perm m b 0 (init_data_list_size v.(gvar_init)) Cur (perm_globvar v)
      /\ (forall ofs k p, Mem.perm m b ofs k p ->
            0 <= ofs < init_data_list_size v.(gvar_init) /\ perm_order (perm_globvar v) p)
      /\ (v.(gvar_volatile) = false -> load_store_init_data m b 0 v.(gvar_init))
      /\ (v.(gvar_volatile) = false -> Mem.loadbytes m b 0 (init_data_list_size v.(gvar_init)) = Some (bytes_of_init_data_list v.(gvar_init)))
  end.

Lemma alloc_global_initialized:
  forall g m id gd m',
  genv_next g = Mem.nextblock m ->

Lemma alloc_globals_initialized:
  forall gl ge m m',
  alloc_globals m gl = Some m' ->
  genv_next ge = Mem.nextblock m ->

End INITMEM.

Definition init_mem (p: program F V) :=
  alloc_globals (globalenv p) Mem.empty p.(prog_defs).

Lemma init_mem_genv_next: forall p m,
  init_mem p = Some m ->
  genv_next (globalenv p) = Mem.nextblock m.

Theorem find_symbol_not_fresh:
  forall p id b m,
  init_mem p = Some m ->
  find_symbol (globalenv p) id = Some b -> Mem.valid_block m b.

Theorem find_def_not_fresh:
  forall p b g m,
  init_mem p = Some m ->
  find_def (globalenv p) b = Some g -> Mem.valid_block m b.

Theorem find_funct_ptr_not_fresh:
  forall p b f m,
  init_mem p = Some m ->
  find_funct_ptr (globalenv p) b = Some f -> Mem.valid_block m b.

Theorem find_var_info_not_fresh:
  forall p b gv m,
  init_mem p = Some m ->
  find_var_info (globalenv p) b = Some gv -> Mem.valid_block m b.

Lemma init_mem_characterization_gen:
  forall p m,
  init_mem p = Some m ->
  globals_initialized (globalenv p) (globalenv p) m.

Theorem init_mem_characterization:
  forall p b gv m,
  find_var_info (globalenv p) b = Some gv ->
  init_mem p = Some m ->
  Mem.range_perm m b 0 (init_data_list_size gv.(gvar_init)) Cur (perm_globvar gv)

Theorem init_mem_characterization_2:
  forall p b fd m,
  find_funct_ptr (globalenv p) b = Some fd ->
  init_mem p = Some m ->
  Mem.perm m b 0 Cur Nonempty

Section INITMEM_INJ.

Variable ge: t.
Variable thr: block.
Hypothesis symb_inject: forall id b, find_symbol ge id = Some b -> Plt b thr.

Lemma store_zeros_neutral:
  forall m b p n m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_neutral:
  forall m b p id m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_list_neutral:
  forall b idl m p m',
  Mem.inject_neutral thr m ->

Lemma alloc_global_neutral:
  forall idg m m',
  alloc_global ge m idg = Some m' ->
  Mem.inject_neutral thr m ->

Remark advance_next_le: forall gl x, Ple x (advance_next gl x).

Lemma alloc_globals_neutral:
  forall gl m m',
  alloc_globals ge m gl = Some m' ->
  Mem.inject_neutral thr m ->

End INITMEM_INJ.

Theorem initmem_inject:
  forall p m,
  init_mem p = Some m ->
  Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m.

Definition init_data_alignment (i: init_data) : Z :=
  match i with
  | Init_int8 n => 1
  | Init_int16 n => 2
  | Init_int32 n => 4
  | Init_int64 n => 8
  | Init_float32 n => 4
  | Init_float64 n => 4
  | Init_addrof symb ofs => if Archi.ptr64 then 8 else 4
  | Init_space n => 1
  end.

Fixpoint init_data_list_aligned (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | i1 :: il => (init_data_alignment i1 | p) /\ init_data_list_aligned (p + init_data_size i1) il
  end.

Section INITMEM_INVERSION.

Variable ge: t.

Lemma store_init_data_aligned:
  forall m b p i m',
  store_init_data ge m b p i = Some m' ->
  (init_data_alignment i | p).

Lemma store_init_data_list_aligned:
  forall b il m p m',
  store_init_data_list ge m b p il = Some m' ->
  init_data_list_aligned p il.

Lemma store_init_data_list_free_idents:
  forall b i o il m p m',
  store_init_data_list ge m b p il = Some m' ->
  In (Init_addrof i o) il ->
  exists b', find_symbol ge i = Some b'.

End INITMEM_INVERSION.

Theorem init_mem_inversion:
  forall p m id v,
  init_mem p = Some m ->
  In (id, Gvar v) p.(prog_defs) ->

Section INITMEM_EXISTS.

Variable ge: t.

Lemma store_zeros_exists:
  forall m b p n,
  Mem.range_perm m b p (p + n) Cur Writable ->

Lemma store_init_data_exists:
  forall m b p i,
  Mem.range_perm m b p (p + init_data_size i) Cur Writable ->

Lemma store_init_data_list_exists:
  forall b il m p,
  Mem.range_perm m b p (p + init_data_list_size il) Cur Writable ->

Lemma alloc_global_exists:
  forall m idg,
  match idg with
  | (id, Gfun f) => True
  | (id, Gvar v) =>
        init_data_list_aligned 0 v.(gvar_init)

End INITMEM_EXISTS.

Theorem init_mem_exists:
  forall p,
  (forall id v, In (id, Gvar v) (prog_defs p) ->
        init_data_list_aligned 0 v.(gvar_init)

End GENV.

Section MATCH_GENVS.

Context {A B V W: Type} (R: globdef A V -> globdef B W -> Prop).

Record match_genvs (ge1: t A V) (ge2: t B W): Prop := {
  mge_next:
    genv_next ge2 = genv_next ge1;
  mge_symb:
    forall id, PTree.get id (genv_symb ge2) = PTree.get id (genv_symb ge1);
  mge_defs:
    forall b, option_rel R (PTree.get b (genv_defs ge1)) (PTree.get b (genv_defs ge2))
}.

Lemma add_global_match:
  forall ge1 ge2 id g1 g2,
  match_genvs ge1 ge2 ->
  R g1 g2 ->
  match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).

Lemma add_globals_match:
  forall gl1 gl2,
  list_forall2 (fun idg1 idg2 => fst idg1 = fst idg2 /\ R (snd idg1) (snd idg2)) gl1 gl2 ->
  forall ge1 ge2, match_genvs ge1 ge2 ->
  match_genvs (add_globals ge1 gl1) (add_globals ge2 gl2).

End MATCH_GENVS.

Section MATCH_PROGRAMS.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.
Variable ctx: C.
Variable p: program F1 V1.
Variable tp: program F2 V2.
Hypothesis progmatch: match_program_gen match_fundef match_varinfo ctx p tp.

Lemma globalenvs_match:
  match_genvs (match_globdef match_fundef match_varinfo ctx) (globalenv p) (globalenv tp).

Theorem find_def_match_2:
  forall b, option_rel (match_globdef match_fundef match_varinfo ctx)
                       (find_def (globalenv p) b) (find_def (globalenv tp) b).
Proof (mge_defs globalenvs_match).

Theorem find_def_match:
  forall b g,
  find_def (globalenv p) b = Some g ->
  exists tg,
  find_def (globalenv tp) b = Some tg /\ match_globdef match_fundef match_varinfo ctx g tg.

Theorem find_funct_ptr_match:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists cunit tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_funct_match:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists cunit tf,
  find_funct (globalenv tp) v = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_var_info_match:
  forall b v,
  find_var_info (globalenv p) b = Some v ->
  exists tv,
  find_var_info (globalenv tp) b = Some tv /\ match_globvar match_varinfo v tv.

Theorem find_symbol_match:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_match:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Lemma store_init_data_list_match:
  forall idl m b ofs m',
  store_init_data_list (globalenv p) m b ofs idl = Some m' ->
  store_init_data_list (globalenv tp) m b ofs idl = Some m'.

Lemma alloc_globals_match:
  forall gl1 gl2, list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) gl1 gl2 ->
  forall m m',
  alloc_globals (globalenv p) m gl1 = Some m' ->
  alloc_globals (globalenv tp) m gl2 = Some m'.

Theorem init_mem_match:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End MATCH_PROGRAMS.

Section TRANSFORM_PARTIAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> res B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => transf f = OK tf) eq p tp.

Theorem find_funct_ptr_transf_partial:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ transf f = OK tf.

Theorem find_funct_transf_partial:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists tf,
  find_funct (globalenv tp) v = Some tf /\ transf f = OK tf.

Theorem find_symbol_transf_partial:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf_partial:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf_partial:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_PARTIAL.

Section TRANSFORM_TOTAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => tf = transf f) eq p tp.

Theorem find_funct_ptr_transf:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  find_funct_ptr (globalenv tp) b = Some (transf f).

Theorem find_funct_transf:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  find_funct (globalenv tp) v = Some (transf f).

Theorem find_symbol_transf:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_TOTAL.

End Genv.

Coercion Genv.to_senv: Genv.t >-> Senv.t. *)



Require Import compcert.cfrontend.Clight.
(* compcert.cfrontend.Clight:
Require Import Coqlib.
Require Import Errors.
Require Import Maps.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import AST.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Ctypes.
Require Import Cop.

Inductive expr : Type :=
  | Econst_int: int -> type -> expr       
  | Econst_float: float -> type -> expr   
  | Econst_single: float32 -> type -> expr 
  | Econst_long: int64 -> type -> expr    
  | Evar: ident -> type -> expr           
  | Etempvar: ident -> type -> expr       
  | Ederef: expr -> type -> expr          
  | Eaddrof: expr -> type -> expr         
  | Eunop: unary_operation -> expr -> type -> expr  
  | Ebinop: binary_operation -> expr -> expr -> type -> expr 
  | Ecast: expr -> type -> expr   
  | Efield: expr -> ident -> type -> expr 
  | Esizeof: type -> type -> expr         
  | Ealignof: type -> type -> expr.       

Definition typeof (e: expr) : type :=
  match e with
  | Econst_int _ ty => ty
  | Econst_float _ ty => ty
  | Econst_single _ ty => ty
  | Econst_long _ ty => ty
  | Evar _ ty => ty
  | Etempvar _ ty => ty
  | Ederef _ ty => ty
  | Eaddrof _ ty => ty
  | Eunop _ _ ty => ty
  | Ebinop _ _ _ ty => ty
  | Ecast _ ty => ty
  | Efield _ _ ty => ty
  | Esizeof _ ty => ty
  | Ealignof _ ty => ty
  end.

Definition label := ident.

Inductive statement : Type :=
  | Sskip : statement                   
  | Sassign : expr -> expr -> statement 
  | Sset : ident -> expr -> statement   
  | Scall: option ident -> expr -> list expr -> statement 
  | Sbuiltin: option ident -> external_function -> typelist -> list expr -> statement 
  | Ssequence : statement -> statement -> statement  
  | Sifthenelse : expr  -> statement -> statement -> statement 
  | Sloop: statement -> statement -> statement 
  | Sbreak : statement                      
  | Scontinue : statement                   
  | Sreturn : option expr -> statement      
  | Sswitch : expr -> labeled_statements -> statement  
  | Slabel : label -> statement -> statement
  | Sgoto : label -> statement

with labeled_statements : Type :=            
  | LSnil: labeled_statements
  | LScons: option Z -> statement -> labeled_statements -> labeled_statements.
                      
Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
  Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).

Record function : Type := mkfunction {
  fn_return: type;
  fn_callconv: calling_convention;
  fn_params: list (ident * type);
  fn_vars: list (ident * type);
  fn_temps: list (ident * type);
  fn_body: statement
}.

Definition var_names (vars: list(ident * type)) : list ident :=
  List.map (@fst ident type) vars.

Definition fundef := Ctypes.fundef function.

Definition type_of_function (f: function) : type :=
  Tfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f).

Definition type_of_fundef (f: fundef) : type :=
  match f with
  | Internal fd => type_of_function fd
  | External id args res cc => Tfunction args res cc
  end.

Definition program := Ctypes.program function.

Record genv := { genv_genv :> Genv.t fundef type; genv_cenv :> composite_env }.

Definition globalenv (p: program) :=
  {| genv_genv := Genv.globalenv p; genv_cenv := p.(prog_comp_env) |}.

Definition env := PTree.t (block * type). 

Definition empty_env: env := (PTree.empty (block * type)).

Definition temp_env := PTree.t val.

Inductive deref_loc (ty: type) (m: mem) (b: block) (ofs: ptrofs) : val -> Prop :=
  | deref_loc_value: forall chunk v,
      access_mode ty = By_value chunk ->
      Mem.loadv chunk m (Vptr b ofs) = Some v ->
      deref_loc ty m b ofs v
  | deref_loc_reference:
      access_mode ty = By_reference ->
      deref_loc ty m b ofs (Vptr b ofs)
  | deref_loc_copy:
      access_mode ty = By_copy ->
      deref_loc ty m b ofs (Vptr b ofs).

Inductive assign_loc (ce: composite_env) (ty: type) (m: mem) (b: block) (ofs: ptrofs):
                                            val -> mem -> Prop :=
  | assign_loc_value: forall v chunk m',
      access_mode ty = By_value chunk ->
      Mem.storev chunk m (Vptr b ofs) v = Some m' ->
      assign_loc ce ty m b ofs v m'
  | assign_loc_copy: forall b' ofs' bytes m',
      access_mode ty = By_copy ->
      (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs')) ->
      (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs)) ->
      b' <> b \/ Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs
              \/ Ptrofs.unsigned ofs' + sizeof ce ty <= Ptrofs.unsigned ofs
              \/ Ptrofs.unsigned ofs + sizeof ce ty <= Ptrofs.unsigned ofs' ->
      Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ce ty) = Some bytes ->
      Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m' ->
      assign_loc ce ty m b ofs (Vptr b' ofs') m'.

Section SEMANTICS.

Variable ge: genv.

Inductive alloc_variables: env -> mem ->
                           list (ident * type) ->
                           env -> mem -> Prop :=
  | alloc_variables_nil:
      forall e m,
      alloc_variables e m nil e m
  | alloc_variables_cons:
      forall e m id ty vars m1 b1 m2 e2,
      Mem.alloc m 0 (sizeof ge ty) = (m1, b1) ->
      alloc_variables (PTree.set id (b1, ty) e) m1 vars e2 m2 ->
      alloc_variables e m ((id, ty) :: vars) e2 m2.

Inductive bind_parameters (e: env):
                           mem -> list (ident * type) -> list val ->
                           mem -> Prop :=
  | bind_parameters_nil:
      forall m,
      bind_parameters e m nil nil m
  | bind_parameters_cons:
      forall m id ty params v1 vl b m1 m2,
      PTree.get id e = Some(b, ty) ->
      assign_loc ge ty m b Ptrofs.zero v1 m1 ->
      bind_parameters e m1 params vl m2 ->
      bind_parameters e m ((id, ty) :: params) (v1 :: vl) m2.

Fixpoint create_undef_temps (temps: list (ident * type)) : temp_env :=
  match temps with
  | nil => PTree.empty val
  | (id, t) :: temps' => PTree.set id Vundef (create_undef_temps temps')
 end.

Fixpoint bind_parameter_temps (formals: list (ident * type)) (args: list val)
                              (le: temp_env) : option temp_env :=
 match formals, args with
 | nil, nil => Some le
 | (id, t) :: xl, v :: vl => bind_parameter_temps xl vl (PTree.set id v le)
 | _, _ => None
 end.

Definition block_of_binding (id_b_ty: ident * (block * type)) :=
  match id_b_ty with (id, (b, ty)) => (b, 0, sizeof ge ty) end.

Definition blocks_of_env (e: env) : list (block * Z * Z) :=
  List.map block_of_binding (PTree.elements e).

Definition set_opttemp (optid: option ident) (v: val) (le: temp_env) :=
  match optid with
  | None => le
  | Some id => PTree.set id v le
  end.

Fixpoint select_switch_default (sl: labeled_statements): labeled_statements :=
  match sl with
  | LSnil => sl
  | LScons None s sl' => sl
  | LScons (Some i) s sl' => select_switch_default sl'
  end.

Fixpoint select_switch_case (n: Z) (sl: labeled_statements): option labeled_statements :=
  match sl with
  | LSnil => None
  | LScons None s sl' => select_switch_case n sl'
  | LScons (Some c) s sl' => if zeq c n then Some sl else select_switch_case n sl'
  end.

Definition select_switch (n: Z) (sl: labeled_statements): labeled_statements :=
  match select_switch_case n sl with
  | Some sl' => sl'
  | None => select_switch_default sl
  end.

Fixpoint seq_of_labeled_statement (sl: labeled_statements) : statement :=
  match sl with
  | LSnil => Sskip
  | LScons _ s sl' => Ssequence s (seq_of_labeled_statement sl')
  end.

Section EXPR.

Variable e: env.
Variable le: temp_env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Econst_int:   forall i ty,
      eval_expr (Econst_int i ty) (Vint i)
  | eval_Econst_float:   forall f ty,
      eval_expr (Econst_float f ty) (Vfloat f)
  | eval_Econst_single:   forall f ty,
      eval_expr (Econst_single f ty) (Vsingle f)
  | eval_Econst_long:   forall i ty,
      eval_expr (Econst_long i ty) (Vlong i)
  | eval_Etempvar:  forall id ty v,
      le!id = Some v ->
      eval_expr (Etempvar id ty) v
  | eval_Eaddrof: forall a ty loc ofs,
      eval_lvalue a loc ofs ->
      eval_expr (Eaddrof a ty) (Vptr loc ofs)
  | eval_Eunop:  forall op a ty v1 v,
      eval_expr a v1 ->
      sem_unary_operation op v1 (typeof a) m = Some v ->
      eval_expr (Eunop op a ty) v
  | eval_Ebinop: forall op a1 a2 ty v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      sem_binary_operation ge op v1 (typeof a1) v2 (typeof a2) m = Some v ->
      eval_expr (Ebinop op a1 a2 ty) v
  | eval_Ecast:   forall a ty v1 v,
      eval_expr a v1 ->
      sem_cast v1 (typeof a) ty m = Some v ->
      eval_expr (Ecast a ty) v
  | eval_Esizeof: forall ty1 ty,
      eval_expr (Esizeof ty1 ty) (Vptrofs (Ptrofs.repr (sizeof ge ty1)))
  | eval_Ealignof: forall ty1 ty,
      eval_expr (Ealignof ty1 ty) (Vptrofs (Ptrofs.repr (alignof ge ty1)))
  | eval_Elvalue: forall a loc ofs v,
      eval_lvalue a loc ofs ->
      deref_loc (typeof a) m loc ofs v ->
      eval_expr a v

with eval_lvalue: expr -> block -> ptrofs -> Prop :=
  | eval_Evar_local:   forall id l ty,
      e!id = Some(l, ty) ->
      eval_lvalue (Evar id ty) l Ptrofs.zero
  | eval_Evar_global: forall id l ty,
      e!id = None ->
      Genv.find_symbol ge id = Some l ->
      eval_lvalue (Evar id ty) l Ptrofs.zero
  | eval_Ederef: forall a ty l ofs,
      eval_expr a (Vptr l ofs) ->
      eval_lvalue (Ederef a ty) l ofs
 | eval_Efield_struct:   forall a i ty l ofs id co att delta,
      eval_expr a (Vptr l ofs) ->
      typeof a = Tstruct id att ->
      ge.(genv_cenv)!id = Some co ->
      field_offset ge i (co_members co) = OK delta ->
      eval_lvalue (Efield a i ty) l (Ptrofs.add ofs (Ptrofs.repr delta))
 | eval_Efield_union:   forall a i ty l ofs id co att,
      eval_expr a (Vptr l ofs) ->
      typeof a = Tunion id att ->
      ge.(genv_cenv)!id = Some co ->
      eval_lvalue (Efield a i ty) l ofs.

Scheme eval_expr_ind2 := Minimality for eval_expr Sort Prop
  with eval_lvalue_ind2 := Minimality for eval_lvalue Sort Prop.
Combined Scheme eval_expr_lvalue_ind from eval_expr_ind2, eval_lvalue_ind2.

Inductive eval_exprlist: list expr -> typelist -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil Tnil nil
  | eval_Econs:   forall a bl ty tyl v1 v2 vl,
      eval_expr a v1 ->
      sem_cast v1 (typeof a) ty m = Some v2 ->
      eval_exprlist bl tyl vl ->
      eval_exprlist (a :: bl) (Tcons ty tyl) (v2 :: vl).

End EXPR.

Inductive cont: Type :=
  | Kstop: cont
  | Kseq: statement -> cont -> cont       
  | Kloop1: statement -> statement -> cont -> cont 
  | Kloop2: statement -> statement -> cont -> cont 
  | Kswitch: cont -> cont       
  | Kcall: option ident ->                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont -> cont.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kloop1 s1 s2 k => call_cont k
  | Kloop2 s1 s2 k => call_cont k
  | Kswitch k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Inductive state: Type :=
  | State
      (f: function)
      (s: statement)
      (k: cont)
      (e: env)
      (le: temp_env)
      (m: mem) : state
  | Callstate
      (fd: fundef)
      (args: list val)
      (k: cont)
      (m: mem) : state
  | Returnstate
      (res: val)
      (k: cont)
      (m: mem) : state.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option (statement * cont) :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 s2 =>
      match find_label lbl s1 (Kloop1 s1 s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 (Kloop2 s1 s2 k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option (statement * cont) :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Variable function_entry: function -> list val -> mem -> env -> temp_env -> mem -> Prop.

Inductive step: state -> trace -> state -> Prop :=

  | step_assign:   forall f a1 a2 k e le m loc ofs v2 v m',
      eval_lvalue e le m a1 loc ofs ->
      eval_expr e le m a2 v2 ->
      sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      assign_loc ge (typeof a1) m loc ofs v m' ->
      step (State f (Sassign a1 a2) k e le m)
        E0 (State f Sskip k e le m')

  | step_set:   forall f id a k e le m v,
      eval_expr e le m a v ->
      step (State f (Sset id a) k e le m)
        E0 (State f Sskip k e (PTree.set id v le) m)

  | step_call:   forall f optid a al k e le m tyargs tyres cconv vf vargs fd,
      classify_fun (typeof a) = fun_case_f tyargs tyres cconv ->
      eval_expr e le m a vf ->
      eval_exprlist e le m al tyargs vargs ->
      Genv.find_funct ge vf = Some fd ->
      type_of_fundef fd = Tfunction tyargs tyres cconv ->
      step (State f (Scall optid a al) k e le m)
        E0 (Callstate fd vargs (Kcall optid f e le k) m)

  | step_builtin:   forall f optid ef tyargs al k e le m vargs t vres m',
      eval_exprlist e le m al tyargs vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef tyargs al) k e le m)
         t (State f Sskip k e (set_opttemp optid vres le) m')

  | step_seq:  forall f s1 s2 k e le m,
      step (State f (Ssequence s1 s2) k e le m)
        E0 (State f s1 (Kseq s2 k) e le m)
  | step_skip_seq: forall f s k e le m,
      step (State f Sskip (Kseq s k) e le m)
        E0 (State f s k e le m)
  | step_continue_seq: forall f s k e le m,
      step (State f Scontinue (Kseq s k) e le m)
        E0 (State f Scontinue k e le m)
  | step_break_seq: forall f s k e le m,
      step (State f Sbreak (Kseq s k) e le m)
        E0 (State f Sbreak k e le m)

  | step_ifthenelse:  forall f a s1 s2 k e le m v1 b,
      eval_expr e le m a v1 ->
      bool_val v1 (typeof a) m = Some b ->
      step (State f (Sifthenelse a s1 s2) k e le m)
        E0 (State f (if b then s1 else s2) k e le m)

  | step_loop: forall f s1 s2 k e le m,
      step (State f (Sloop s1 s2) k e le m)
        E0 (State f s1 (Kloop1 s1 s2 k) e le m)
  | step_skip_or_continue_loop1:  forall f s1 s2 k e le m x,
      x = Sskip \/ x = Scontinue ->
      step (State f x (Kloop1 s1 s2 k) e le m)
        E0 (State f s2 (Kloop2 s1 s2 k) e le m)
  | step_break_loop1:  forall f s1 s2 k e le m,
      step (State f Sbreak (Kloop1 s1 s2 k) e le m)
        E0 (State f Sskip k e le m)
  | step_skip_loop2: forall f s1 s2 k e le m,
      step (State f Sskip (Kloop2 s1 s2 k) e le m)
        E0 (State f (Sloop s1 s2) k e le m)
  | step_break_loop2: forall f s1 s2 k e le m,
      step (State f Sbreak (Kloop2 s1 s2 k) e le m)
        E0 (State f Sskip k e le m)

  | step_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn None) k e le m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k e le m v v' m',
      eval_expr e le m a v ->
      sem_cast v (typeof a) f.(fn_return) m = Some v' ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn (Some a)) k e le m)
        E0 (Returnstate v' (call_cont k) m')
  | step_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f Sskip k e le m)
        E0 (Returnstate Vundef k m')

  | step_switch: forall f a sl k e le m v n,
      eval_expr e le m a v ->
      sem_switch_arg v (typeof a) = Some n ->
      step (State f (Sswitch a sl) k e le m)
        E0 (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch k) e le m)
  | step_skip_break_switch: forall f x k e le m,
      x = Sskip \/ x = Sbreak ->
      step (State f x (Kswitch k) e le m)
        E0 (State f Sskip k e le m)
  | step_continue_switch: forall f k e le m,
      step (State f Scontinue (Kswitch k) e le m)
        E0 (State f Scontinue k e le m)

  | step_label: forall f lbl s k e le m,
      step (State f (Slabel lbl s) k e le m)
        E0 (State f s k e le m)

  | step_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some (s', k') ->
      step (State f (Sgoto lbl) k e le m)
        E0 (State f s' k' e le m)

  | step_internal_function: forall f vargs k m e le m1,
      function_entry f vargs m e le m1 ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k e le m1)

  | step_external_function: forall ef targs tres cconv vargs k m vres t m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef targs tres cconv) vargs k m)
         t (Returnstate vres k m')

  | step_returnstate: forall v optid f e le k m,
      step (Returnstate v (Kcall optid f e le k) m)
        E0 (State f Sskip k e (set_opttemp optid v le) m).

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

End SEMANTICS.

Inductive function_entry1 (ge: genv) (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry1_intro: forall m1,
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
      bind_parameters ge e m1 f.(fn_params) vargs m' ->
      le = create_undef_temps f.(fn_temps) ->
      function_entry1 ge f vargs m e le m'.

Definition step1 (ge: genv) := step ge (function_entry1 ge).

Inductive function_entry2 (ge: genv)  (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry2_intro:
      list_norepet (var_names f.(fn_vars)) ->
      list_norepet (var_names f.(fn_params)) ->
      list_disjoint (var_names f.(fn_params)) (var_names f.(fn_temps)) ->
      alloc_variables ge empty_env m f.(fn_vars) e m' ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      function_entry2 ge f vargs m e le m'.

Definition step2 (ge: genv) := step ge (function_entry2 ge).

Definition semantics1 (p: program) :=
  let ge := globalenv p in
  Semantics_gen step1 (initial_state p) final_state ge ge.

Definition semantics2 (p: program) :=
  let ge := globalenv p in
  Semantics_gen step2 (initial_state p) final_state ge ge.

Lemma semantics_receptive:
  forall (p: program), receptive (semantics1 p). *)

Require Import VST.concurrency.juicy.erasure_safety.
(* VST.concurrency.juicy.erasure_safety:
Require Import ProofIrrelevance.

Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.juicy.juicy_machine. Import Concur.
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.juicy.erasure_signature.
Require Import VST.concurrency.juicy.erasure_proof.
Require Import VST.concurrency.juicy.Clight_safety.
Import addressFiniteMap.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Require Import VST.concurrency.common.ssromega. 
From mathcomp.ssreflect Require Import ssreflect seq.

Set Bullet Behavior "Strict Subproofs".

Module ErasureSafety.

  Module ErasureProof := erasure_proof.Parching.
  Module Erasure := ErasureFnctr ErasureProof.
  Import ErasureProof.
  Import Erasure.

  Section ErasureSafety.

  Context (initU: HybridMachineSig.schedule).
  Context (init_rmap : @res JR).
  Context (init_pmap : @res DR).
  Context (init_rmap_perm:  match_rmap_perm init_rmap init_pmap).

  Definition step_diagram:= ErasureProof.core_diagram.

  Import JuicyMachineModule.THE_JUICY_MACHINE.
  Import ClightMachine.Clight_newMachine.DMS.

  Existing Instance DMS.

  Lemma erasure_safety': forall n ge sch js jtr ds dtr m,
      ErasureProof.match_st ge js ds ->

  Theorem erasure_safety: forall ge cd j js ds m n,
      Erasure.match_state ge cd j js m ds m ->

  End ErasureSafety.

End ErasureSafety.

Require Import VST.concurrency.juicy.semax_to_juicy_machine.

Lemma no_locks_no_locks_perm : forall r, Parching.no_locks_perm r <-> initial_world.no_locks r.

Lemma juice2Perm_match : forall m r, access_cohere' m r ->
  Parching.match_rmap_perm r (juice2Perm r m, empty_map).

Section DrySafety.

  Variable (CPROOF : CSL_proof).

  Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem (Clight.globalenv CPROOF.(CSL_prog)).
  Definition ge := Clight.globalenv CPROOF.(CSL_prog).
  Instance DTP : threadPool.ThreadPool.ThreadPool := Parching.DTP ge.
  Instance DMS : HybridMachineSig.MachineSig := Parching.DMS ge.
  Definition init_mem := proj1_sig (init_mem CPROOF).
  Definition init_rmap n := m_phi (initial_jm CPROOF n).

  Lemma init_match n : Parching.match_rmap_perm (init_rmap n) (getCurPerm init_mem, empty_map).

  Lemma init_no_locks n : Parching.no_locks_perm (init_rmap n).

  Theorem dry_safety_initial_state (sch : HybridMachineSig.schedule) (n : nat) :

  Context {SW : spawn_wrapper CPROOF}.

  Notation ClightSem:= ClightSemanticsForMachines.ClightSem.
  Theorem Clight_initial_safe (sch : HybridMachineSig.schedule) (n : nat) :

End DrySafety. *)



Require Import VST.concurrency.compiler.concurrent_compiler_safety_proof.
(* VST.concurrency.compiler.concurrent_compiler_safety_proof:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype.

Require Import compcert.common.Globalenvs.
Require Import VST.concurrency.paco.src.paco.

Require Import VST.concurrency.common.HybridMachineSig.
Import HybridMachineSig.
Set Bullet Behavior "Strict Subproofs".
  
Require Import VST.concurrency.compiler.concurrent_compiler_simulation.
Require Import VST.concurrency.compiler.concurrent_compiler_simulation_proof.
Require Import VST.concurrency.compiler.sequential_compiler_correct.
Require Import VST.concurrency.compiler.concurrent_compiler_safety.
Require Import VST.concurrency.compiler.concurrent_compiler_simulation_proof.
Require Import VST.concurrency.compiler.safety_equivalence.
Require Import VST.concurrency.compiler.HybridMachine_simulation.
Require Import VST.concurrency.common.HybridMachine.
Require Import Omega.
            
Require Import VST.concurrency.common.ClightMachine.

Require Import VST.concurrency.common.x86_context.

Module Concurrent_Safety (CC_correct: CompCert_correctness).
  
  Import ClightMachine.
  Import DMS.
  
  Import X86Context.

  Module ConcurCC_correct:= (Concurrent_correctness CC_correct).
  Import ConcurCC_correct.
  
  Definition Clight_init_state (p: Clight.program):=
    Clight.start_stack (Clight.globalenv p).
  
  Definition Asm_init_state (p: Asm.program):=
    Asm.start_stack (@the_ge p).

  Notation valid Sem:=
    (valid dryResources Sem OrdinalPool.OrdinalThreadPool).

  Definition opt_init_mem_source (p : Clight.program):=
      (Genv.init_mem (Ctypes.program_of_program p)).
  Definition opt_init_mem_target {F V} (tp:AST.program F V ):=
    (Genv.init_mem tp).
  Lemma explicit_safety_step:
    forall (p : Clight.program) (tp : Asm.program) (asm_genv_safety : Asm_core.safe_genv the_ge),

    Lemma match_valid_equiv:
      forall U (p : Clight.program) (tp : Asm.program) (asm_genv_safety : Asm_core.safe_genv the_ge),

    Lemma thread_stepN_schedule_irr:
      forall (tp : Asm.program)
  
    Lemma explicit_safety_step':
      forall (p : Clight.program) (tp : Asm.program) (asm_genv_safety : Asm_core.safe_genv the_ge),
        
    Lemma Clight_finite_branching:
      let ClightSem:= ClightSemanticsForMachines.ClightSem in 
    Lemma csafety_step:
      forall (p : Clight.program) (tp : Asm.program) (asm_genv_safety : Asm_core.safe_genv the_ge),

    Lemma initial_csafe_all_schedule:
      forall  prog asm_genv_safety tr c m r,
        let SemTarget:= @X86Sem prog asm_genv_safety in
        let tp:=OrdinalPool.mkPool (Krun c) r in

    Lemma ConcurrentCompilerSafety:
      forall (p : Clight.program) (tp : Asm.program),
    
End Concurrent_Safety. *)

Require Import VST.concurrency.compiler.sequential_compiler_correct.
(* VST.concurrency.compiler.sequential_compiler_correct:
Require Import compcert.common.ExposedSimulations.
Require Import compcert.cfrontend.Clight.
Require Import compcert.x86.Asm.

Module Type CompCert_correctness.

Parameter CompCert_compiler: Clight.program -> option Asm.program.
Hypothesis simpl_clight_semantic_preservation:
  forall (p:Clight.program) (tp:Asm.program),
  CompCert_compiler p = Some tp ->
  fsim_properties_inj (Clight.semantics2 p) (Asm.semantics tp) Clight.get_mem Asm.get_mem.

End CompCert_correctness. *)



Require Import VST.concurrency.sc_drf.mem_obs_eq.
(* VST.concurrency.sc_drf.mem_obs_eq:
Require Import compcert.lib.Axioms.
Require Import VST.concurrency.common.sepcomp. Import SepComp.

Require Import VST.concurrency.common.pos.

Require Import compcert.lib.Coqlib.
Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.
Require Import compcert.common.Values. 
Require Import compcert.common.Memory.
Require Import VST.concurrency.memory_lemmas.
Require Import compcert.lib.Integers.

Require Import Coq.ZArith.ZArith.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.semantics.
Require Import VST.sepcomp.mem_wd.

Module Renamings.
  Definition memren := block -> option block.

  Definition ren_incr f1 f2 :=
    forall (b b' : block),
      f1 b = Some b' -> f2 b = Some b'.

  Definition ren_separated (f f' : memren) m1 m2 :=
    forall (b1 b2 : block),
      f b1 = None ->
      f' b1 = Some b2 ->
      ~ Mem.valid_block m1 b1 /\ ~ Mem.valid_block m2 b2.

  Definition ren_domain_incr (f1 f2: memren) :=
    forall b,
      f1 b -> f2 b.

  Definition domain_memren (f: memren) m :=
    forall b, Mem.valid_block m b <-> isSome (f b).

  Lemma restrPermMap_domain:
    forall f m p (Hlt: permMapLt p (getMaxPerm m)),
      domain_memren f m <-> domain_memren f (restrPermMap Hlt).

  Lemma domain_memren_incr:
    forall f f' f'' m,
      domain_memren f' m ->
      domain_memren f'' m ->
      ren_domain_incr f f' <-> ren_domain_incr f f''.

  Lemma domain_memren_trans:
    forall f f' m m',
      domain_memren f m ->
      domain_memren f m' ->
      domain_memren f' m' ->
      domain_memren f' m.

  Lemma ren_incr_domain_incr:
    forall f f',
      ren_incr f f' ->
      ren_domain_incr f f'.

  Lemma ren_domain_incr_refl:
    forall f,
      ren_domain_incr f f.

  Lemma ren_domain_incr_trans:
    forall f f' f'',
      ren_domain_incr f f' ->
      ren_domain_incr f' f'' ->
      ren_domain_incr f f''.

  Lemma ren_incr_trans:
    forall f f' f'',
      ren_incr f f' ->
      ren_incr f' f'' ->
      ren_incr f f''.

  Lemma ren_incr_refl:
    forall f,
      ren_incr f f.

  Lemma ren_separated_refl:
    forall f m m',
      ren_separated f f m m'.

  Definition id_ren m :=
    fun b => if is_left (valid_block_dec m b) then Some b else None.

  Hint Unfold id_ren.

  Lemma id_ren_correct:
    forall m (b1 b2 : block), (id_ren m) b1 = Some b2 -> b1 = b2.

  Lemma id_ren_domain:
    forall m, domain_memren (id_ren m) m.

  Lemma id_ren_validblock:
    forall m b
      (Hvalid: Mem.valid_block m b),

  Lemma id_ren_invalidblock:
    forall m b
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma is_id_ren :
    forall f m
      (Hdomain: domain_memren f m)
      (Hf_id: forall b1 b2, f b1 = Some b2 -> b1 = b2),
      f = id_ren m.

  Lemma id_ren_restr:
    forall pmap m (Hlt: permMapLt pmap (getMaxPerm m)),
      id_ren m = id_ren (restrPermMap Hlt).

  Lemma incr_domain_id:
    forall m f f'
      (Hincr: ren_incr f f')
      (Hf_id: forall b b', f b = Some b' -> b = b')
      (Hdomain_f: domain_memren f' m),
      ren_incr f (id_ren m).

  Hint Immediate ren_incr_refl ren_separated_refl : renamings.

  Hint Resolve id_ren_correct id_ren_domain id_ren_validblock
       id_ren_invalidblock : id_renamings.

End Renamings.

Module ValueWD.

  Import Renamings.

  Hint Immediate ren_domain_incr_refl : wd.

  Definition valid_val (f: memren) (v : val) : Prop :=
    match v with
    | Vptr b _ =>
      exists b', f b = Some b'
    | _ => True
    end.

  Inductive valid_val_list (f: memren) : seq val -> Prop :=
  | vs_nil: valid_val_list f [::]
  | vs_cons: forall v vs,
      valid_val f v ->
      valid_val_list f vs ->
      valid_val_list f (v :: vs).

  Definition valid_memval (f: memren) (mv : memval) : Prop :=
    match mv with
    | Fragment v _ _ =>
      valid_val f v
    | _ => True
    end.

  Inductive valid_memval_list (f : memren) : seq memval -> Prop :=
  |  mvs_nil : valid_memval_list f [::]
  | mvs_cons : forall (v : memval) (vs : seq memval),
      valid_memval f v ->
      valid_memval_list f vs -> valid_memval_list f (v :: vs).

  Lemma valid_val_incr:
    forall f f' v
      (Hvalid: valid_val f v)
      (Hincr: ren_domain_incr f f'),
      valid_val f' v.

  Lemma valid_val_list_incr:
    forall f f' vs
      (Hvalid: valid_val_list f vs)
      (Hincr: ren_domain_incr f f'),
      valid_val_list f' vs.

  Lemma valid_val_domain:
    forall f f' m v,
      valid_val f v ->
      domain_memren f m ->
      domain_memren f' m ->
      valid_val f' v.

  Lemma valid_val_list_domain:
    forall f f' m vs
      (Hvalid: valid_val_list f vs)
      (Hdomain: domain_memren f m)
      (Hdomain': domain_memren f' m),
      valid_val_list f' vs.

  Lemma ofs_val_lt :
    forall ofs chunk v,
      ofs < ofs + Z.of_nat (length (encode_val chunk v)).

  Lemma valid_val_int:
    forall f n,
      valid_val f (Vint n).

  Lemma valid_val_long:
    forall f n,
      valid_val f (Vlong n).

  Lemma valid_val_one:
    forall f, valid_val f Vone.

  Lemma valid_val_single:
    forall f n,
      valid_val f (Vsingle n).

  Lemma valid_val_float:
    forall f n,
      valid_val f (Vfloat n).

  Lemma valid_val_hiword:
    forall f v,
      valid_val f (Val.hiword v).

  Lemma valid_val_loword:
    forall f v,
      valid_val f (Val.loword v).

  Lemma valid_val_add:
    forall f v1 v2,
      valid_val f v1 ->
      valid_val f v2 ->
      valid_val f (Val.add v1 v2).

  Lemma valid_val_addl:
    forall f v1 v2,
      valid_val f v1 ->
      valid_val f v2 ->
      valid_val f (Val.addl v1 v2).

  Lemma valid_val_offset_ptr:
    forall f v ofs,
      valid_val f v ->
      valid_val f (Val.offset_ptr v ofs).

  Lemma valid_val_sub:
    forall f v1 v2,
      valid_val f v1 ->
      valid_val f v2 ->
      valid_val f (Val.sub v1 v2).

  Lemma valid_val_subl:
    forall f v1 v2,
      valid_val f v1 ->
      valid_val f v2 ->
      valid_val f (Val.subl v1 v2).

  Lemma valid_val_mul:
    forall f v1 v2,
      valid_val f (Val.mul v1 v2).

  Lemma valid_val_mulhu:
    forall f v1 v2,
      valid_val f (Val.mulhu v1 v2).

  Lemma valid_val_mull:
    forall f v1 v2,
      valid_val f (Val.mull v1 v2).

  Lemma valid_val_mullhu:
    forall f v1 v2,
      valid_val f (Val.mullhu v1 v2).

  Lemma valid_val_and:
    forall f v1 v2,
      valid_val f (Val.and v1 v2).

  Lemma valid_val_or:
    forall f v1 v2,
      valid_val f (Val.or v1 v2).

  Lemma valid_val_xor:
    forall f v1 v2,
      valid_val f (Val.xor v1 v2).

  Lemma valid_val_andl:
    forall f v1 v2,
      valid_val f (Val.andl v1 v2).

  Lemma valid_val_orl:
    forall f v1 v2,
      valid_val f (Val.orl v1 v2).

  Lemma valid_val_xorl:
    forall f v1 v2,
      valid_val f (Val.xorl v1 v2).

  Lemma valid_intoffloat:
    forall f v,
      valid_val f (Val.maketotal (Val.intoffloat v)).

  Lemma valid_intofsingle:
    forall f v,
      valid_val f (Val.maketotal (Val.intofsingle v)).

  Lemma valid_singleofint:
    forall f v,
      valid_val f (Val.maketotal (Val.singleofint v)).

  Lemma valid_floatofint:
    forall f v,
      valid_val f (Val.maketotal (Val.floatofint v)).

  Lemma valid_longoffloat:
    forall f v,
      valid_val f (Val.maketotal (Val.longoffloat v)).

  Lemma valid_longofsingle:
    forall f v,
      valid_val f (Val.maketotal (Val.longofsingle v)).

  Lemma valid_singleoflong:
    forall f v,
      valid_val f (Val.maketotal (Val.singleoflong v)).

  Lemma valid_floatoflong:
    forall f v,
      valid_val f (Val.maketotal (Val.floatoflong v)).

  Lemma valid_val_singleoffloat:
    forall f v,
      valid_val f (Val.singleoffloat v).

  Lemma valid_val_floatofsingle:
    forall f v,
      valid_val f (Val.floatofsingle v).

  Lemma valid_val_neg:
    forall f v,
      valid_val f (Val.neg v).

  Lemma valid_val_negl:
    forall f v,
      valid_val f (Val.negl v).

  Lemma valid_val_sign_ext:
    forall f v n,
      valid_val f (Val.sign_ext n v).

  Lemma valid_val_longofintu:
    forall f v,
      valid_val f (Val.longofintu v).

  Lemma valid_val_longofint:
    forall f v,
      valid_val f (Val.longofint v).

  Lemma valid_val_zero_ext:
    forall f v n,
      valid_val f (Val.zero_ext n v).

  Lemma valid_val_mulhs:
    forall f v1 v2,
      valid_val f (Val.mulhs v1 v2).

  Lemma valid_val_mullhs:
    forall f v1 v2,
      valid_val f (Val.mullhs v1 v2).

  Lemma valid_val_undef:
    forall f,
      valid_val f Vundef.

  Lemma valid_val_shl:
    forall f v1 v2,
      valid_val f (Val.shl v1 v2).

  Lemma valid_val_shru:
    forall f v1 v2,
      valid_val f (Val.shru v1 v2).

  Lemma valid_val_shr:
    forall f v1 v2,
      valid_val f (Val.shr v1 v2).

  Lemma valid_val_ror:
    forall f v1 v2,
      valid_val f (Val.ror v1 v2).

  Lemma valid_val_shll:
    forall f v1 v2,
      valid_val f (Val.shll v1 v2).

  Lemma valid_val_shrlu:
    forall f v1 v2,
      valid_val f (Val.shrlu v1 v2).

  Lemma valid_val_shrl:
    forall f v1 v2,
      valid_val f (Val.shrl v1 v2).

  Lemma valid_val_rorl:
    forall f v1 v2,
      valid_val f (Val.rorl v1 v2).

  Lemma valid_val_addf:
    forall f v1 v2,
      valid_val f (Val.addf v1 v2).

  Lemma valid_val_mulf:
    forall f v1 v2,
      valid_val f (Val.mulf v1 v2).

  Lemma valid_val_subf:
    forall f v1 v2,
      valid_val f (Val.subf v1 v2).

  Lemma valid_val_divf:
    forall f v1 v2,
      valid_val f (Val.divf v1 v2).

  Lemma valid_val_addfs:
    forall f v1 v2,
      valid_val f (Val.addfs v1 v2).

  Lemma valid_val_mulfs:
    forall f v1 v2,
      valid_val f (Val.mulfs v1 v2).

  Lemma valid_val_subfs:
    forall f v1 v2,
      valid_val f (Val.subfs v1 v2).

  Lemma valid_val_divfs:
    forall f v1 v2,
      valid_val f (Val.divfs v1 v2).

  Lemma valid_val_negf:
    forall f v,
      valid_val f (Val.negf v).

  Lemma valid_val_absf:
    forall f v,
      valid_val f (Val.absf v).

  Lemma valid_val_negfs:
    forall f v,
      valid_val f (Val.negfs v).

  Lemma valid_val_absfs:
    forall f v,
      valid_val f (Val.absfs v).

  Lemma valid_val_divu:
    forall f v1 v2 v,
      Val.divu v1 v2 = Some v ->

  Lemma valid_val_modu:
    forall f v1 v2 v,
      Val.modu v1 v2 = Some v ->

  Lemma valid_val_divs:
    forall f v1 v2 v,
      Val.divs v1 v2 = Some v ->

  Lemma valid_val_mods:
    forall f v1 v2 v,
      Val.mods v1 v2 = Some v ->

  Lemma valid_val_divlu:
    forall f v1 v2 v,
      Val.divlu v1 v2 = Some v ->

  Lemma valid_val_modlu:
    forall f v1 v2 v,
      Val.modlu v1 v2 = Some v ->

  Lemma valid_val_divls:
    forall f v1 v2 v,
      Val.divls v1 v2 = Some v ->

  Lemma valid_val_modls:
    forall f v1 v2 v,
      Val.modls v1 v2 = Some v ->

  Lemma valid_val_notint:
    forall f v,
      valid_val f (Val.notint v).

  Lemma valid_val_notl:
    forall f v,
      valid_val f (Val.notl v).

  Lemma valid_val_vzero:
    forall f,
      valid_val f (Vzero).

  Lemma valid_val_of_optbool:
    forall f b,
      valid_val f (Val.of_optbool b).

  Lemma valid_val_offset:
    forall f b ofs ofs',
      valid_val f (Vptr b ofs) ->
      valid_val f (Vptr b ofs').

  Lemma valid_val_sub_overflow:
    forall f v1 v2,
      valid_val f (Val.sub_overflow v1 v2).

  Lemma valid_val_subl_overflow:
    forall f v1 v2,
      valid_val f (Val.subl_overflow v1 v2).

  Lemma valid_val_negative:
    forall f v,
      valid_val f (Val.negative v).

  Lemma valid_val_negativel:
    forall f v,
      valid_val f (Val.negativel v).

  Lemma valid_val_of_bool:
    forall f b,
      valid_val f (Val.of_bool b).

  Hint Resolve valid_val_sub valid_val_subl : wd.
  Hint Immediate  valid_val_int valid_val_long valid_val_one valid_val_undef
       valid_val_single valid_val_float valid_val_hiword valid_val_loword
       valid_val_add valid_val_addl valid_val_offset_ptr
       valid_val_mul valid_val_mulhu valid_val_mulhs
       valid_val_mull valid_val_mullhu valid_val_mullhs
       valid_val_and valid_val_or valid_val_xor
       valid_val_andl valid_val_orl valid_val_xorl
       valid_intoffloat valid_intofsingle
       valid_singleofint valid_floatofint
       valid_longoffloat valid_longofsingle
       valid_singleoflong valid_floatoflong
       valid_val_singleoffloat valid_val_floatofsingle
       valid_val_neg valid_val_negl valid_val_longofintu valid_val_longofint valid_val_sign_ext valid_val_zero_ext
       valid_val_divu valid_val_modu
       valid_val_divs valid_val_mods
       valid_val_divlu valid_val_modlu
       valid_val_divls valid_val_modls
       valid_val_notint valid_val_notl valid_val_vzero
       valid_val_shl valid_val_shru valid_val_shr
       valid_val_shll valid_val_shrlu valid_val_shrl
       valid_val_ror valid_val_rorl valid_val_addf valid_val_mulf
       valid_val_subf valid_val_divf
       valid_val_addfs valid_val_mulfs
       valid_val_subfs valid_val_divfs
       valid_val_negf valid_val_absf
       valid_val_negfs valid_val_absfs
       valid_val_of_optbool valid_val_sub_overflow valid_val_subl_overflow
       valid_val_negative valid_val_negativel valid_val_of_bool : wd.
End ValueWD.

Module MemoryWD.

  Import Renamings MemoryLemmas ValueWD.
  
  Definition valid_mem m :=
    forall b,
      Mem.valid_block m b ->
      forall ofs mv,
        Maps.ZMap.get ofs (Mem.mem_contents m) # b = mv ->
        match mv with
        | Fragment v q n =>
          mem_wd.val_valid v m
        | _ => True
        end.

  Lemma wd_val_valid:
    forall v m f
      (Hdomain: domain_memren f m),
      mem_wd.val_valid v m <-> valid_val f v.

  Lemma restrPermMap_val_valid:
    forall m p (Hlt: permMapLt p (getMaxPerm m)) v,
      mem_wd.val_valid v m <-> mem_wd.val_valid v (restrPermMap Hlt).

  Lemma restrPermMap_mem_valid :
    forall m p (Hlt: permMapLt p (getMaxPerm m)),
      valid_mem m <-> valid_mem (restrPermMap Hlt).

  Lemma inj_bytes_type:
    forall bs mv,
      In mv (inj_bytes bs) ->
      match mv with
      | Byte _ => True
      | _ => False
      end.

  Lemma decode_val_wd:
    forall f (vl : seq memval) (chunk : memory_chunk),
      valid_memval_list f vl ->
      valid_val f (decode_val chunk vl).

  Lemma getN_wd :
    forall (f : memren) (m : mem) b,
      Mem.valid_block m b ->

  Lemma valid_val_encode:
    forall v m chunk
      (Hval_wd: mem_wd.val_valid v m),

  Lemma valid_val_store:
    forall v m m' chunk b ofs v'
      (Hvalid: mem_wd.val_valid v m)

  Transparent  Mem.storebytes.
  Lemma valid_val_storebytes:
    forall v m m' b ofs mv
      (Hmem: mem_wd.val_valid v m)

  Lemma storebytes_wd_domain:
    forall (m m' : mem) mv b ofs f
      (Hdomain: domain_memren f m)
      (Hmval_wd: valid_memval_list f mv)
      (Hstore: Mem.storebytes m b ofs mv = Some m')
      (Hmem_wd: valid_mem m),
      valid_mem m' /\ domain_memren f m'.
  Proof.
    intros.
    unfold valid_mem in *.
    destruct mv.
    - unfold Mem.storebytes in Hstore.
      destruct (Mem.range_perm_dec m b ofs (ofs + Z.of_nat (length [::]))); try discriminate.
      inv Hstore.
      unfold domain_memren, mem_wd.val_valid, Mem.valid_block in *. simpl.
      split; eauto.
      intros.
      eapply Hmem_wd with (ofs := ofs0); eauto.
      rewrite <- H0.
      destruct (Pos.eq_dec b b0); subst.
      rewrite Maps.PMap.gss.
      reflexivity.
      rewrite Maps.PMap.gso;
        now eauto.
    - split.
      { intros b0 Hvalid ofs0 mv0 Hget; subst.
        eapply Mem.storebytes_valid_block_2 in Hvalid; eauto.
        rewrite (Mem.storebytes_mem_contents _ _ _ _ _ Hstore).
        destruct (Pos.eq_dec b b0) as [Heq | Hneq].
        - 
          subst.
          rewrite Maps.PMap.gss.
          destruct (Intv.In_dec ofs0
                                (ofs,
                                 (ofs + Z.of_nat (length (m0 ::mv)))%Z)).
          
          + apply Mem.setN_in with (c:= (Mem.mem_contents m) # b0) in i.
            destruct (ZMap.get ofs0
                               (Mem.setN (m0 :: mv) ofs (Mem.mem_contents m) # b0));
              simpl; auto.
            
            Lemma In_valid_memval_list:
            forall f mvs mv,
              valid_memval_list f mvs ->
              In mv mvs ->
              valid_memval f mv.

  Lemma store_wd_domain:
    forall (m m' : mem) (chunk : memory_chunk) (v : val) b ofs f
      (Hdomain: domain_memren f m)
      (Hstore: Mem.store chunk m b ofs v = Some m')

  Lemma storev_wd_domain:
    forall (m m' : mem) (chunk : memory_chunk) (vptr v : val) f,
      domain_memren f m ->
      Mem.storev chunk m vptr v = Some m' ->

  Lemma valid_mem_load:
    forall chunk m b ofs v f
      (Hwd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Hload: Mem.load chunk m b ofs = Some v),

  Transparent Mem.loadbytes.
  Lemma valid_mem_loadbytes:
    forall m b ofs sz mv f
      (Hwd: valid_mem m)
      (Hsz: sz >= 0)
      (Hdomain: domain_memren f m)
      (Hload: Mem.loadbytes m b ofs sz = Some mv),

  Lemma loadv_wd:
    forall chunk m vptr v f
      (Hwd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Hload: Mem.loadv chunk m vptr = Some v),

  Lemma domain_memren_store:
    forall chunk m m' b ofs v f
      (Hdomain: domain_memren f m)
      (Hstore: Mem.store chunk m b ofs v = Some m'),

  Lemma domain_memren_storev:
    forall chunk m m' vptr v f
      (Hdomain: domain_memren f m)
      (Hstore: Mem.storev chunk m vptr v = Some m'),

End MemoryWD.

Module ValObsEq.

  Import ValueWD MemoryWD Renamings MemoryLemmas.

  Inductive val_obs (mi : memren) : val -> val -> Prop :=
    obs_int : forall i : int, val_obs mi (Vint i) (Vint i)
  | obs_long : forall i : int64, val_obs mi (Vlong i) (Vlong i)
  | obs_float : forall f : Floats.float,
      val_obs mi (Vfloat f) (Vfloat f)
  | obs_single : forall f : Floats.float32,
      val_obs mi (Vsingle f) (Vsingle f)
  | obs_ptr : forall (b1 b2 : block) (ofs : ptrofs),
      mi b1 = Some b2 ->
      val_obs mi (Vptr b1 ofs) (Vptr b2 ofs)
  | obs_undef : val_obs mi Vundef Vundef.

  Inductive memval_obs_eq (f : memren) : memval -> memval -> Prop :=
  | memval_obs_byte : forall n : byte,
      memval_obs_eq f (Byte n) (Byte n)
  | memval_obs_frag : forall (v1 v2 : val) (q : quantity) (n : nat)
                        (Hval_obs: val_obs f v1 v2),
      memval_obs_eq f (Fragment v1 q n) (Fragment v2 q n)
  | memval_obs_undef : memval_obs_eq f Undef Undef.

  Inductive val_obs_list (mi : memren) : seq val -> seq val -> Prop :=
    val_obs_list_nil : val_obs_list mi [::] [::]
  | val_obs_list_cons : forall (v v' : val) (vl vl' : seq val),
                       val_obs mi v v' ->
                       val_obs_list mi vl vl' ->
                       val_obs_list mi (v :: vl) (v' :: vl').

  Hint Constructors val_obs : val_renamings.

  Lemma val_obs_incr:
    forall f f' v v'
      (Hval_obs: val_obs f v v')
      (Hincr: ren_incr f f'),
      val_obs f' v v'.

  Lemma val_obs_trans:
    forall (v v' v'' : val) (f f' f'' : memren),
      val_obs f v v'' ->
      val_obs f' v v' ->
      (forall b b' b'' : block,
          f b = Some b'' ->
          f' b = Some b' ->
          f'' b' = Some b'') ->
      val_obs f'' v' v''.

  Lemma memval_obs_trans:
    forall (v v' v'' : memval) (f f' f'' : memren),
      memval_obs_eq f v v'' ->
      memval_obs_eq f' v v' ->
      (forall b b' b'' : block,
          f b = Some b'' ->
          f' b = Some b' ->
          f'' b' = Some b'') ->
      memval_obs_eq f'' v' v''.

  Lemma val_obs_list_trans:
    forall (vs vs' vs'' : seq val) (f f' f'' : memren),
      val_obs_list f vs vs'' ->
      val_obs_list f' vs vs' ->
      (forall b b' b'' : block,
          f b = Some b'' ->
          f' b = Some b' ->
          f'' b' = Some b'') ->
      val_obs_list f'' vs' vs''.

  Lemma val_obs_list_incr:
    forall (vs vs' : seq val) (f f' : memren),
      val_obs_list f vs vs' ->
      ren_incr f f' ->
      val_obs_list f' vs vs'.

  Lemma val_obs_id:
    forall f v
      (Hvalid: valid_val f v)
      (Hid: forall b b', f b = Some b' -> b = b'),
      val_obs f v v.

  Lemma val_obs_list_id :
    forall f vs
      (Hvalid: valid_val_list f vs)
      (Hf: forall b1 b2, f b1 = Some b2 -> b1 = b2),
      val_obs_list f vs vs.

  Lemma memval_obs_eq_id:
    forall f mv
      (Hvalid: valid_memval f mv)
      (Hid: forall b b', f b = Some b' -> b = b'),
                    memval_obs_eq f mv mv.

  Lemma ren_cmp_bool:
    forall f v v' v0 cmp,
      val_obs f v v' ->
      Val.cmp_bool cmp v v0 = Val.cmp_bool cmp v' v0.

  Lemma val_obs_hiword:
    forall f v v',
      val_obs f v v' ->
      val_obs f (Val.hiword v) (Val.hiword v').

  Lemma val_obs_loword:
    forall f v v',
      val_obs f v v' ->
      val_obs f (Val.loword v) (Val.loword v').

  Lemma val_obs_longofwords:
    forall f vhi vhi' vlo vlo'
      (Hobs_hi: val_obs f vhi vhi')
      (Hobs_lo: val_obs f vlo vlo'),
      val_obs f (Val.longofwords vhi vlo) (Val.longofwords vhi' vlo').

  Lemma val_obs_load_result:
    forall f v v' chunk
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.load_result chunk v) (Val.load_result chunk v').

  Lemma val_obs_ext:
    forall f v v' n
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.zero_ext n v) (Val.zero_ext n v').

  Definition val_obsC f v :=
    match v with
    | Vptr b n => match f b with
                 | Some b' => Vptr b' n
                 | None => Vundef
                 end
    | _ => v
    end.

  Lemma val_obsC_correct:
    forall f v,
      valid_val f v ->
      val_obs f v (val_obsC f v).

  Lemma zlength_obs:
    forall f v v'
      (Hval_obs: val_obs_list f v v'),
      Zlength v = Zlength v'.

  Lemma val_obs_add:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.add v1 v1') (Val.add v2 v2').

  Lemma val_obs_addl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.addl v1 v1') (Val.addl v2 v2').

  Lemma val_obs_offset_ptr:
    forall f v1 v2 ofs
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.offset_ptr v1 ofs) (Val.offset_ptr v2 ofs).

  Lemma val_obs_sign_ext:
    forall f v v' n
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.sign_ext n v) (Val.sign_ext n v').

  Lemma val_obs_longofintu:
    forall f v v'
      (Hobs: val_obs f v v'),
      val_obs f (Val.longofintu v) (Val.longofintu v').

  Lemma val_obs_longofint:
    forall f v v'
      (Hobs: val_obs f v v'),
      val_obs f (Val.longofint v) (Val.longofint v').

  Lemma val_obs_singleoffloat:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.singleoffloat v) (Val.singleoffloat v').

  Lemma val_obs_floatofsingle:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.floatofsingle v) (Val.floatofsingle v').

  Lemma val_obs_intoffloat:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.intoffloat v))

  Lemma val_obs_floatofint:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.floatofint v))

  Lemma val_obs_intofsingle:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.intofsingle v))

  Lemma val_obs_singleofint:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.singleofint v))

  Lemma val_obs_longoffloat:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.longoffloat v))

  Lemma val_obs_floatoflong:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.floatoflong v))

  Lemma val_obs_longofsingle:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.longofsingle v))

  Lemma val_obs_singleoflong:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      val_obs f (Val.maketotal (Val.singleoflong v))

  Lemma val_obs_mul:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mul v1 v1') (Val.mul v2 v2').

  Lemma val_obs_mull:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mull v1 v1') (Val.mull v2 v2').

  Lemma val_obs_mulhs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mulhs v1 v1') (Val.mulhs v2 v2').

  Lemma val_obs_mulhu:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mulhu v1 v1') (Val.mulhu v2 v2').

  Lemma val_obs_mullhs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mullhs v1 v1') (Val.mullhs v2 v2').

  Lemma val_obs_mullhu:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mullhu v1 v1') (Val.mullhu v2 v2').

  Lemma val_obs_and:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.and v1 v1') (Val.and v2 v2').

  Lemma val_obs_or:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.or v1 v1') (Val.or v2 v2').

  Lemma val_obs_xor:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.xor v1 v1') (Val.xor v2 v2').

  Lemma val_obs_andl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.andl v1 v1') (Val.andl v2 v2').

  Lemma val_obs_orl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.orl v1 v1') (Val.orl v2 v2').

  Lemma val_obs_xorl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.xorl v1 v1') (Val.xorl v2 v2').

  Lemma val_obs_notint:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.notint v1) (Val.notint v2).

  Lemma val_obs_notl:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.notl v1) (Val.notl v2).

  Lemma val_obs_shl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shl v1 v1') (Val.shl v2 v2').

  Lemma val_obs_shr:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shr v1 v1') (Val.shr v2 v2').

  Lemma val_obs_shru:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shru v1 v1') (Val.shru v2 v2').

  Lemma val_obs_ror:
  forall f v1 v2 ofs
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.ror v1 (Vint ofs)) (Val.ror v2 (Vint ofs)).

  Lemma val_obs_shll:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shll v1 v1') (Val.shll v2 v2').

  Lemma val_obs_shrl:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shrl v1 v1') (Val.shrl v2 v2').

  Lemma val_obs_shrlu:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.shrlu v1 v1') (Val.shrlu v2 v2').

  Lemma val_obs_rorl:
  forall f v1 v2 ofs
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.rorl v1 (Vint ofs)) (Val.rorl v2 (Vint ofs)).

  Lemma val_obs_suboverflow:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.sub_overflow v1 v1') (Val.sub_overflow v2 v2').

  Lemma val_obs_subloverflow:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.subl_overflow v1 v1') (Val.subl_overflow v2 v2').

  Lemma val_obs_negative:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.negative v1) (Val.negative v2).

  Lemma val_obs_neg:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.neg v1) (Val.neg v2).

  Lemma val_obs_negativel:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.negativel v1) (Val.negativel v2).

  Lemma val_obs_negl:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.negl v1) (Val.negl v2).

  Lemma val_obs_sub:
    forall f v1 v2 v1' v2'
      (Hinjective: forall b1 b1' b2,
          f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.sub v1 v1') (Val.sub v2 v2').

  Lemma val_obs_subl:
    forall f v1 v2 v1' v2'
      (Hinjective: forall b1 b1' b2,
          f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.subl v1 v1') (Val.subl v2 v2').

  Lemma val_obs_addf:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.addf v1 v1') (Val.addf v2 v2').

  Lemma val_obs_addfs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.addfs v1 v1') (Val.addfs v2 v2').

  Lemma val_obs_mulf:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mulf v1 v1') (Val.mulf v2 v2').

  Lemma val_obs_mulfs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.mulfs v1 v1') (Val.mulfs v2 v2').

  Lemma val_obs_negf:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.negf v1) (Val.negf v2).

  Lemma val_obs_negfs:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.negfs v1) (Val.negfs v2).

  Lemma val_obs_absf:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.absf v1) (Val.absf v2).

  Lemma val_obs_absfs:
    forall f v1 v2
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.absfs v1) (Val.absfs v2).

  Lemma val_obs_subf:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.subf v1 v1') (Val.subf v2 v2').

  Lemma val_obs_subfs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.subfs v1 v1') (Val.subfs v2 v2').

  Lemma val_obs_divf:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.divf v1 v1') (Val.divf v2 v2').

  Lemma val_obs_divfs:
    forall f v1 v2 v1' v2'
      (Hval_obs': val_obs f v1' v2')
      (Hval_obs: val_obs f v1 v2),
      val_obs f (Val.divfs v1 v1') (Val.divfs v2 v2').

  Lemma divu_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.divu v1 v2 = Val.divu v1' v2'.

  Lemma modu_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.modu v1 v2 = Val.modu v1' v2'.

  Lemma val_obs_divu_id:
    forall f v1 v2 v,
      Val.divu v1 v2 = Some v ->

  Lemma val_obs_modu_id:
    forall f v1 v2 v,
      Val.modu v1 v2 = Some v ->

  Lemma divs_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.divs v1 v2 = Val.divs v1' v2'.

  Lemma mods_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.mods v1 v2 = Val.mods v1' v2'.

  Lemma val_obs_divs_id:
    forall f v1 v2 v,
      Val.divs v1 v2 = Some v ->

  Lemma val_obs_mods_id:
    forall f v1 v2 v,
      Val.mods v1 v2 = Some v ->

  Lemma divlu_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.divlu v1 v2 = Val.divlu v1' v2'.

  Lemma modlu_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.modlu v1 v2 = Val.modlu v1' v2'.

  Lemma val_obs_divlu_id:
    forall f v1 v2 v,
      Val.divlu v1 v2 = Some v ->

  Lemma val_obs_modlu_id:
    forall f v1 v2 v,
      Val.modlu v1 v2 = Some v ->

  Lemma divls_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.divls v1 v2 = Val.divls v1' v2'.

  Lemma modls_ren:
    forall f v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2'),
      Val.modls v1 v2 = Val.modls v1' v2'.

  Lemma val_obs_divls_id:
    forall f v1 v2 v,
      Val.divls v1 v2 = Some v ->

  Lemma val_obs_modls_id:
    forall f v1 v2 v,
      Val.modls v1 v2 = Some v ->

  Lemma val_obs_of_bool:
    forall f b,
      val_obs f (Val.of_bool b) (Val.of_bool b).

  Hint Resolve
       val_obs_add val_obs_addl val_obs_offset_ptr valid_val_incr val_obs_incr val_obsC_correct
       val_obs_load_result val_obs_hiword val_obs_loword
       val_obs_longofwords val_obs_load_result val_obs_ext
       val_obs_sign_ext val_obs_longofintu val_obs_longofint val_obs_singleoffloat val_obs_floatofsingle
       val_obs_intoffloat val_obs_floatofint val_obs_intofsingle
       val_obs_singleofint val_obs_longoffloat val_obs_floatoflong val_obs_longofsingle val_obs_singleoflong
       val_obs_neg val_obs_negl val_obs_mul val_obs_mull val_obs_mulhs val_obs_mulhu val_obs_mullhs val_obs_mullhu
       val_obs_and val_obs_sub val_obs_andl val_obs_subl
       val_obs_or val_obs_xor val_obs_orl val_obs_xorl val_obs_notint val_obs_notl
       val_obs_shl val_obs_shr val_obs_shru
       val_obs_shll val_obs_shrl val_obs_shrlu
       val_obs_ror val_obs_suboverflow val_obs_negative
       val_obs_rorl val_obs_subloverflow val_obs_negativel
       val_obs_addf val_obs_addfs val_obs_mulf
       val_obs_mulfs val_obs_negf val_obs_negfs
       val_obs_absf val_obs_absfs val_obs_subf
       val_obs_subfs val_obs_divf val_obs_divfs
       val_obs_divu_id val_obs_modu_id
       val_obs_divs_id val_obs_mods_id
       val_obs_divlu_id val_obs_modlu_id
       val_obs_divls_id val_obs_modls_id val_obs_of_bool : val_renamings.

End ValObsEq.

Module MemObsEq.

  Import ValObsEq ValueWD MemoryWD Renamings MemoryLemmas.

  Record weak_mem_obs_eq (f : memren) (mc mf : mem) :=
    {
      domain_invalid: forall b, ~(Mem.valid_block mc b) -> f b = None;
      domain_valid: forall b, Mem.valid_block mc b -> exists b', f b = Some b';
      codomain_valid: forall b1 b2, f b1 = Some b2 -> Mem.valid_block mf b2;
      injective: forall b1 b1' b2, f b1 = Some b2 ->
                              f b1' = Some b2 ->
                              b1 = b1';
      perm_obs_weak :
        forall b1 b2 ofs (Hrenaming: f b1 = Some b2),
          Mem.perm_order''
            (permission_at mc b1 ofs Cur)
            (permission_at mf b2 ofs Cur)}.

  Record strong_mem_obs_eq (f : memren) (mc mf : mem) :=
    { perm_obs_strong :
        forall b1 b2 ofs (Hrenaming: f b1 = Some b2),
            permission_at mf b2 ofs Cur =
            (permission_at mc b1 ofs Cur);
      val_obs_eq :
        forall b1 b2 ofs (Hrenaming: f b1 = Some b2)
          (Hperm: Mem.perm mc b1 ofs Cur Readable),
          memval_obs_eq f (Maps.ZMap.get ofs mc.(Mem.mem_contents)#b1)
                        (Maps.ZMap.get ofs mf.(Mem.mem_contents)#b2)}.

  Record mem_obs_eq (f : memren) (mc mf : mem) :=
    { weak_obs_eq : weak_mem_obs_eq f mc mf;
      strong_obs_eq : strong_mem_obs_eq f mc mf }.

  Lemma weak_obs_eq_domain_ren:
    forall f m m',
      weak_mem_obs_eq f m m' ->
      domain_memren f m.

  Corollary mem_obs_eq_domain_ren:
    forall f m m',
      mem_obs_eq f m m' ->
      domain_memren f m.

  Lemma mem_obs_eq_setMaxPerm :
    forall m,
      valid_mem m ->
      mem_obs_eq (id_ren m) m (setMaxPerm m).

  Lemma mem_obs_eq_id :
    forall m,
      valid_mem m ->
      mem_obs_eq (id_ren m) m m.

  Lemma mem_obs_eq_extend:
    forall m1 m1' m2' f pmap pmap'
      (Hlt1: permMapLt pmap (getMaxPerm m1))
      (Hlt1': permMapLt pmap' (getMaxPerm m1'))
      (Hlt2': permMapLt pmap' (getMaxPerm m2'))
      (Hmem_obs_eq: mem_obs_eq f (restrPermMap Hlt1) (restrPermMap Hlt1'))
      (Hextend': forall b, Mem.valid_block m1' b -> Mem.valid_block m2' b)

  Lemma mapped_dec :
    forall (f : positive -> option positive) m j
      (Hdomain_invalid : forall b, ~ (b < m)%positive -> f b = None)
      (Hdomain_valid : forall b, (b < m)%positive -> exists b', f b = Some b'),
      (exists i, f i = Some j) \/ ~ exists i, f i = Some j.

  Lemma pigeon_positive:
    forall (n m: positive) (f: positive -> option positive),
      (forall i, (i < n)%positive ->
            exists j, (j < m)%positive /\ f i = Some j) ->
      (forall i i' j j',
          f i = Some j -> f i' = Some j' ->
          i<>i' -> j<>j') ->
      (n <= m)%positive.

  Lemma weak_mem_obs_eq_nextblock:
    forall f m m'
      (Hobs_eq: weak_mem_obs_eq f m m'),
      (Mem.nextblock m <= Mem.nextblock m')%positive.

  Lemma mf_align :
    forall (m : mem) (f : memren) (b1 b2 : block) (delta : Z) (chunk : memory_chunk)
      (ofs : Z) (p : permission),
      f b1 = Some b2 ->
      Mem.range_perm m b1 ofs (ofs + size_chunk chunk) Max p ->

  Lemma memval_obs_eq_incr:
    forall (mc mf : mem) (f f': memren)
      (b1 b2 : block) (ofs : Z)
      (Hf': f' b1 = Some b2)
      (Hincr: ren_incr f f')
      (Hobs_eq: memval_obs_eq f (Maps.ZMap.get ofs (Mem.mem_contents mc) # b1)

  Lemma proj_bytes_obs:
    forall (f : memren) (vl vl' : seq memval),
      Coqlib.list_forall2 (memval_obs_eq f) vl vl' ->

  Lemma proj_bytes_obs_none:
    forall (f : memren) (vl vl' : seq memval),
      Coqlib.list_forall2 (memval_obs_eq f) vl vl' ->

  Lemma val_obs_equal:
    forall f v1 v1' v2 v2'
      (Hinjective: forall b1 b1' b2, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hval1: val_obs f v1 v1')
      (Hval2: val_obs f v2 v2'),
      Val.eq v1 v2 <-> Val.eq v1' v2'.

  Lemma check_value_obs:
    forall f n vl vl' v v' q
      (Hf: forall b1 b1' b2, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1'),
      Coqlib.list_forall2 (memval_obs_eq f) vl vl' ->

  Lemma proj_value_obs:
    forall f q vl1 vl2,
      (forall b1 b1' b2 : block, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1') ->
      Coqlib.list_forall2 (memval_obs_eq f) vl1 vl2 ->

  Lemma load_result_obs:
    forall f chunk v1 v2,
      val_obs f v1 v2 ->
      val_obs f (Val.load_result chunk v1) (Val.load_result chunk v2).

  Lemma decode_val_obs:
    forall f vl1 vl2 chunk,
      (forall b1 b1' b2 : block, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1') ->
      Coqlib.list_forall2 (memval_obs_eq f) vl1 vl2 ->

  Lemma valid_access_obs_eq:
    forall f m1 m2 b1 b2 chunk ofs p,
      strong_mem_obs_eq f m1 m2 ->
      f b1 = Some b2 ->
      Mem.valid_access m1 chunk b1 ofs p ->

  Lemma valid_access_obs_eq':
    forall f m1 m2 b1 b2 chunk ofs p,
      strong_mem_obs_eq f m1 m2 ->
      f b1 = Some b2 ->
      Mem.valid_access m2 chunk b2 ofs p ->

  Lemma getN_obs:
    forall f m1 m2 b1 b2,
      strong_mem_obs_eq f m1 m2 ->
      f b1 = Some b2 ->
      forall n ofs,
        Mem.range_perm m1 b1 ofs (ofs + Z_of_nat n) Cur Readable ->

  Transparent Mem.load.
  Lemma load_val_obs:
    forall (mc mf : mem) (f:memren)
      (b1 b2 : block) chunk (ofs : Z) v1
      (Hload: Mem.load chunk mc b1 ofs = Some v1)

  Lemma load_None_obs:
    forall (mc mf : mem) (f:memren)
      (b1 b2 : block) chunk (ofs : Z)
      (Hload: Mem.load chunk mc b1 ofs = None)
  Opaque Mem.load.

  Lemma loadv_val_obs:
    forall (mc mf : mem) (f:memren)
      (vptr1 vptr2 : val) chunk v1
      (Hload: Mem.loadv chunk mc vptr1 = Some v1)

  Lemma loadv_None_obs:
    forall (mc mf : mem) (f:memren)
      (vptr1 vptr2 : val) chunk
      (Hload: Mem.loadv chunk mc vptr1 = None)

  Transparent Mem.loadbytes.
  Lemma loadbytes_val_obs:
    forall (mc mf : mem) (f:memren)
      (b1 b2 : block) (ofs sz : Z) mv
      (Hsz: sz >= 0)
      (Hload: Mem.loadbytes mc b1 ofs sz = Some mv)
  Opaque Mem.loadbytes.
  
  Lemma encode_val_obs_eq:
    forall (f : memren) (v1 v2 : val) (chunk : memory_chunk),
      val_obs f v1 v2 ->
      list_forall2 (memval_obs_eq f) (encode_val chunk v1)
                   (encode_val chunk v2).

  Lemma setN_obs_eq :
    forall (access : Z -> Prop) (f : memren) (vl1 vl2 : seq memval),
      list_forall2 (memval_obs_eq f) vl1 vl2 ->
      forall (p : Z) (c1 c2 : ZMap.t memval),

  Transparent Mem.store.
  Lemma store_val_obs:
    forall (mc mc' mf : mem) (f:memren)
      (b1 b2 : block) chunk (ofs: Z) v1 v2
      (Hstore: Mem.store chunk mc b1 ofs v1 = Some mc')
  Opaque Mem.store.

  Lemma storev_val_obs:
    forall (mc mc' mf : mem) (f:memren)
      (vptr1 vptr2: val) chunk v1 v2
      (Hstore: Mem.storev chunk mc vptr1 v1 = Some mc')

  Transparent Mem.storebytes.
  Lemma storebytes_val_obs:
    forall (mc mc' mf : mem) (f:memren)
      (b1 b2 : block) (ofs: Z) mv1 mv2
      (Hstore: Mem.storebytes mc b1 ofs mv1 = Some mc')
  Opaque Mem.storebytes.

  Lemma mem_obs_eq_storeF:
    forall f mc mf mf' chunk b ofs v pmap pmap2
      (Hlt: permMapLt pmap (getMaxPerm mf))
      (Hlt': permMapLt pmap (getMaxPerm mf'))
      (Hlt2: permMapLt pmap2 (getMaxPerm mf))
      (Hstore: Mem.store chunk (restrPermMap Hlt2) b ofs v = Some mf')

  Lemma mem_obs_eq_disjoint_lock:
    forall f  mc mf mc' mf' pmap pmapF bl1 bl2 ofsl sz
      (Hf: f bl1 = Some bl2)
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (Hlt': permMapLt pmap (getMaxPerm mc'))
      (HltF': permMapLt pmapF (getMaxPerm mf'))
      (Hvb : forall b : block, Mem.valid_block mc b <-> Mem.valid_block mc' b)

  Lemma mem_obs_eq_changePerm:
    forall mc mf rmap rmapF rmap' rmapF' f
      (Hlt: permMapLt rmap (getMaxPerm mc))
      (HltF: permMapLt rmapF (getMaxPerm mf))
      (Hlt': permMapLt rmap' (getMaxPerm mc))
      (HltF': permMapLt rmapF' (getMaxPerm mf))
      (Hrmap: forall b1 b2 ofs,
          f b1 = Some b2 ->
          rmap' # b1 ofs = rmapF' # b2 ofs)
      (Hobs_eq: mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hnew: forall b ofs, Mem.perm_order' (rmap' # b ofs) Readable ->

  Lemma weak_mem_obs_eq_store:
    forall mc mf mc' mf' rmap rmapF bl1 bl2 f
      (Hlt: permMapLt rmap (getMaxPerm mc))
      (HltF: permMapLt rmapF (getMaxPerm mf))
      (Hlt2: permMapLt rmap (getMaxPerm mc'))
      (Hlt2F: permMapLt rmapF (getMaxPerm mf'))
      (Hf: f bl1 = Some bl2)
      (Hinjective: forall b1 b1' b2 : block, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hobs_eq: weak_mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b)

  Lemma strong_mem_obs_eq_store:
    forall mc mf mc' mf' rmap rmapF bl1 bl2 ofsl f v
      (Hlt: permMapLt rmap (getMaxPerm mc))
      (HltF: permMapLt rmapF (getMaxPerm mf))
      (Hlt2: permMapLt rmap (getMaxPerm mc'))
      (Hlt2F: permMapLt rmapF (getMaxPerm mf'))
      (Hf: f bl1 = Some bl2)
      (Hinjective: forall b1 b1' b2 : block, f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hobs_eq: strong_mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hstore: Mem.mem_contents mc' = PMap.set bl1 (Mem.setN (encode_val Mint32 (Vint v)) ofsl (Mem.mem_contents mc) # bl1)

  Corollary mem_obs_eq_store :
    forall (mc mf mc' mf' : mem) (rmap rmapF : access_map) (bl1 bl2 : block) (ofsl : Z) f v
      (Hlt : permMapLt rmap (getMaxPerm mc)) (HltF : permMapLt rmapF (getMaxPerm mf))
      (Hlt2 : permMapLt rmap (getMaxPerm mc'))
      (Hlt2F : permMapLt rmapF (getMaxPerm mf'))
      (Hfl: f bl1 = Some bl2)
      (Hinjective: forall b1 b1' b2 : block,
          f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hmem_obs_eq: mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hcontents: Mem.mem_contents mc' =

  Lemma alloc_perm_eq:
    forall f m m' lo hi m2 m2' b b'
      (Hobs_eq: mem_obs_eq f m m')
      (Halloc: Mem.alloc m lo hi = (m2, b))

Lemma setPermBlock_var_eq:
    forall f bl1 bl2 ofsl b1 b2 ofs pmap pmap' p
      (Hf: f b1 = Some b2)
      (Hfl: f bl1 = Some bl2)
      (Hinjective: forall b1 b1' b2 : block,
          f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1')
      (Hperm: pmap # b1 ofs = pmap' # b2 ofs),
      (setPermBlock_var p bl1 ofsl pmap
                    lksize.LKSIZE_nat) # b1 ofs =

  Lemma setPermBlock_var_weak_obs_eq:
    forall (f : block -> option block) (bl1 bl2 : block) (ofsl : Z)
      (pmap pmapF : access_map) (mc mf : mem) p (Hlt : permMapLt pmap (getMaxPerm mc))
      (HltF : permMapLt pmapF (getMaxPerm mf))
      (Hfl: f bl1 = Some bl2)
      (Hweak_obs_eq: weak_mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hlt' : permMapLt (setPermBlock_var p bl1 ofsl pmap lksize.LKSIZE_nat) (getMaxPerm mc))

  Lemma setPermBlock_var_obs_eq:
    forall f bl1 bl2 ofsl pmap pmapF mc mf p
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (Hfl: f bl1 = Some bl2)
      (Hval_obs_eq: forall ofs0, (ofsl <= ofs0 < ofsl + Z.of_nat (lksize.LKSIZE_nat))%Z ->

  Lemma setPermBlock_weak_obs_eq:
    forall (f : block -> option block) (bl1 bl2 : block) (ofsl : Z)
      (pmap pmapF : access_map) (mc mf : mem) (p : option permission) (Hlt : permMapLt pmap (getMaxPerm mc))
      (HltF : permMapLt pmapF (getMaxPerm mf))
      (Hfl: f bl1 = Some bl2)
      (Hweak_obs_eq: weak_mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hlt' : permMapLt (setPermBlock p bl1 ofsl pmap lksize.LKSIZE_nat) (getMaxPerm mc))

  Lemma setPermBlock_obs_eq:
    forall f bl1 bl2 ofsl pmap pmapF mc mf p
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (Hfl: f bl1 = Some bl2)
      (Hval_obs_eq: forall ofs0, (ofsl <= ofs0 < ofsl + Z.of_nat (lksize.LKSIZE_nat))%Z ->

  Lemma mem_free_obs_perm:
    forall f m m' m2 m2' lo hi b1 b2
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hf: f b1 = Some b2)
      (Hfree: Mem.free m b1 lo hi = Some m2)

  Transparent Mem.free.

  Lemma mem_free_obs:
    forall f m m' lo hi b1 b2 m2
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hf: f b1 = Some b2)
      (Hfree: Mem.free m b1 lo hi = Some m2),
  Opaque Mem.free.

  Lemma alloc_obs_eq:
    forall f m m' lo hi m2 m2' b b'
      (Hobs_eq: mem_obs_eq f m m')
      (Halloc: Mem.alloc m lo hi = (m2, b))
  
  Lemma valid_pointer_ren:
    forall f m m' b1 b2 ofs
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hf: f b1 = Some b2),
      Mem.valid_pointer m b1 ofs = Mem.valid_pointer m' b2 ofs.

  Lemma val_obs_cmpu:
    forall f v1 v2 v1' v2' m m' (comp : comparison)
      (Hval_obs': val_obs f v2 v2')
      (Hval_obs: val_obs f v1 v1')
      (Hmem_obs_eq: mem_obs_eq f m m'),
      val_obs f (Val.cmpu (Mem.valid_pointer m) comp v1 v2)

  Hint Resolve val_obs_cmpu : val_renamings.

  Lemma val_obs_cmplu:
    forall f v1 v2 v1' v2' m m' (comp : comparison)
      (Hval_obs': val_obs f v2 v2')
      (Hval_obs: val_obs f v1 v1')
      (Hmem_obs_eq: mem_obs_eq f m m'),
      val_obs f (Val.maketotal (Val.cmplu (Mem.valid_pointer m) comp v1 v2))

  Hint Resolve val_obs_cmplu : val_renamings.

  Lemma mem_obs_eq_of_weak_strong:
    forall m m' f pmap1 pmap1' pmap2 pmap2'
      (Hlt1: permMapLt pmap1 (getMaxPerm m))
      (Hlt2: permMapLt pmap2 (getMaxPerm m'))
      (Hlt1': permMapLt pmap1' (getMaxPerm m))
      (Hlt2': permMapLt pmap2' (getMaxPerm m'))
      (Hstrong_obs: strong_mem_obs_eq f (restrPermMap Hlt1) (restrPermMap Hlt2))
      (Hweak: weak_mem_obs_eq f (restrPermMap Hlt1') (restrPermMap Hlt2')),
      mem_obs_eq f (restrPermMap Hlt1) (restrPermMap Hlt2).

End MemObsEq.

Module CoreInjections.

  Import ValObsEq ValueWD MemoryWD Renamings MemObsEq event_semantics.

  Section CoreInjections.

    Context {Sem : Semantics}.

    Class CoreInj :=
      { 
        core_wd : memren -> semC -> Prop;
        
        ge_wd : memren -> semG -> Prop;

        ge_wd_incr: forall f f' (g : semG),
            ge_wd f g ->
            ren_domain_incr f f' ->
            ge_wd f' g;

        ge_wd_domain : forall f f' m (g : semG),
            ge_wd f g ->
            domain_memren f m ->
            domain_memren f' m ->
            ge_wd f' g;

        core_wd_incr : forall f f' c,
            core_wd f c ->
            ren_domain_incr f f' ->
            core_wd f' c;

        core_wd_domain : forall f f' m c,
            core_wd f c ->
            domain_memren f m ->
            domain_memren f' m ->
            core_wd f' c;

        at_external_wd:
          forall m (f : memren) c
            (ef : external_function)
            (args : seq val),
            valid_mem m ->
            domain_memren f m ->
            core_wd f c ->
            at_external semSem c m = Some (ef, args) -> 
            valid_val_list f args;

        after_external_wd:
          forall m (c c' : semC) (f : memren) (ef : external_function)
            (args : seq val) (ov : option val)
            (Hat_external: at_external semSem c m = Some (ef, args))
            (Hcore_wd: core_wd f c)
            (Hvalid_list: valid_val_list f args)
            (Hafter_external: after_external semSem ov c m = Some c')
            (Hov: match ov with
                  | Some v => valid_val f v
                  | None => True
                  end),
            core_wd f c';

        initial_core_wd :
          forall m m' (f fg : memren) (vf : val) args (c_new:semC) h,
            valid_mem m ->
            domain_memren f m ->
            initial_core semSem h m c_new m' vf args ->
            valid_val_list f args ->
            ge_wd fg the_ge ->
            ren_domain_incr fg f ->
            valid_mem m' /\
            (exists f', ren_domain_incr f f' /\ domain_memren f' m') /\
            forall f', domain_memren f' m' ->
                  core_wd f' c_new;

        core_inj: memren -> semC -> semC -> Prop;

        core_inj_ext:
          forall m m' c c' (f fg : memren)
            (Hfg: (forall b1 b2, fg b1 = Some b2 -> b1 = b2))
            (Hge_wd: ge_wd fg the_ge)
            (Hincr: ren_incr fg f),
            valid_mem m ->
            
            core_inj f c c' ->
            mem_obs_eq f m m' ->
            match at_external semSem c m with
            | Some (ef, vs) =>
              match at_external semSem c' m' with
              | Some (ef', vs') =>
                ef = ef' /\ val_obs_list f vs vs'
              | None => False
              end
            | None =>
              match at_external semSem c' m' with
              | Some _ => False
              | None => True
              end
            end;

        core_inj_after_ext:
          forall c cc c' (ov1 : option val) m m'
            (f fg : memren)
            (Hfg: (forall b1 b2, fg b1 = Some b2 -> b1 = b2))
            (Hge_wd: ge_wd fg the_ge)
            (Hincr: ren_incr fg f),
            core_inj f c c' ->
            mem_obs_eq f m m' -> 
            match ov1 with
            | Some v1 => valid_val f v1
            | None => True
            end ->
            after_external semSem ov1 c m = Some cc ->
            exists (ov2 : option val) (cc' : semC),
              after_external semSem ov2 c' m' = Some cc' /\
              core_inj f cc cc' /\
              match ov1 with
              | Some v1 =>
                match ov2 with
                | Some v2 => val_obs f v1 v2
                | None => False
                end
              | None => match ov2 with
                       | Some _ => False
                       | None => True
                       end
              end;

        core_inj_halted:
          forall c c' f (Hinj: core_inj f c c') v,
            halted semSem c v <-> halted semSem c' v;

        core_inj_init:
          forall m1 m1' m2 vf vf' arg arg' c_new f fg h
            (Hge_wd: ge_wd fg the_ge)
            (Hfg: (forall b1 b2, fg b1 = Some b2 -> b1 = b2))
            (Hincr: ren_incr fg f)
            (Harg: val_obs_list f arg arg')
            (Hvf: val_obs f vf vf')
            (Hmem: mem_obs_eq f m1 m1')
            (Hinit: initial_core semSem h m1 c_new m2 vf arg),
          
          exists c_new' m2' f',
            initial_core semSem h m1' c_new' m2' vf' arg'
            /\ core_inj f' c_new c_new'
            /\ mem_obs_eq f' m2 m2'
            /\ ren_incr f f'
            /\ ren_separated f f' m1 m1'
            /\ ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
                      (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive)))
            /\ (forall b,
                  Mem.valid_block m2' b ->
                  ~ Mem.valid_block m1' b ->
                  let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                         (Zpos (Mem.nextblock m1))))%Z in
                  f' (Z.to_pos bz) = Some b /\
                  f (Z.to_pos bz) = None)
            /\ (Mem.nextblock m1 = Mem.nextblock m1' ->
               (forall b1 b2, f b1 = Some b2 -> b1 = b2) ->
               forall b1 b2, f' b1 = Some b2 -> b1 = b2)
            /\ (forall b2, (~exists b1, f' b1 = Some b2) ->
                     forall ofs, permission_at m1' b2 ofs Cur = permission_at m2' b2 ofs Cur);

        core_inj_id: forall c f,
            core_wd f c ->
            (forall b1 b2, f b1 = Some b2 -> b1 = b2) ->
            core_inj f c c;

        core_inj_trans:
          forall c c' c'' (f f' f'' : memren)
            (Hcore_inj: core_inj f c c'')
            (Hcore_inj': core_inj f' c c')
            (Hf: forall b b' b'',
                f b = Some b'' ->
                f' b = Some b' ->
                f'' b' = Some b''),
            core_inj f'' c' c'';

        corestep_obs_eq:
          forall cc cf cc' mc mf mc' f fg
            (Hobs_eq: mem_obs_eq f mc mf)
            (Hcode_eq: core_inj f cc cf)
            (Hfg: (forall b1 b2, fg b1 = Some b2 -> b1 = b2))
            (Hge_wd: ge_wd fg the_ge)
            (Hincr: ren_incr fg f)
            (Hstep: corestep semSem cc mc cc' mc'),
          exists cf' mf' f',
            corestep semSem cf mf cf' mf'
            /\ core_inj f' cc' cf'
            /\ mem_obs_eq f' mc' mf'
            /\ ren_incr f f'
            /\ ren_separated f f' mc mf
            /\ ((exists p, ((Mem.nextblock mc' = Mem.nextblock mc + p)%positive /\
                      (Mem.nextblock mf' = Mem.nextblock mf + p)%positive))
               \/ ((Mem.nextblock mc' = Mem.nextblock mc) /\
                  (Mem.nextblock mf' = Mem.nextblock mf)))
            /\ (forall b,
                  Mem.valid_block mf' b ->
                  ~ Mem.valid_block mf b ->
                  let bz := ((Zpos b) - ((Zpos (Mem.nextblock mf)) -
                                         (Zpos (Mem.nextblock mc))))%Z in
                  f' (Z.to_pos bz) = Some b /\
                  f (Z.to_pos bz) = None)
            /\ (Mem.nextblock mc = Mem.nextblock mf ->
               (forall b1 b2, f b1 = Some b2 -> b1 = b2) ->
               forall b1 b2, f' b1 = Some b2 -> b1 = b2)
            /\ (forall b2, (~exists b1, f' b1 = Some b2) ->
                     forall ofs, permission_at mf b2 ofs Cur = permission_at mf' b2 ofs Cur);

        corestep_wd:
          forall c m c' m' f fg
            (Hwd: core_wd f c)
            (Hmem_wd: valid_mem m)
            (Hge_wd: ge_wd fg the_ge)
            (Hincr: ren_domain_incr fg f)
            (Hdomain: domain_memren f m)
            (Hcorestep: corestep semSem c m c' m'),
            valid_mem m' /\
            (exists f', ren_domain_incr f f' /\ domain_memren f' m') /\
            forall f', domain_memren f' m' ->
                  core_wd f' c'
      }.

End CoreInjections.

End CoreInjections.

Module ThreadPoolInjections.

  Import ValObsEq ValueWD MemoryWD Renamings CoreInjections.
  Import ThreadPool HybridMachine DryHybridMachine.

  Section ThreadPoolInjections.
    Existing Instance dryResources.
    Context {asmSem : Semantics}
            {tpool : ThreadPool.ThreadPool}
            {CI: CoreInj}.

  Definition ctl_inj f cc cf : Prop :=
    match cc, cf with
    | Kinit vf arg, Kinit vf' arg' =>
      val_obs f vf vf' /\ val_obs f arg arg'
    | Krun c, Krun c' => core_inj f c c'
    | Kblocked c, Kblocked c' => core_inj f c c'
    | Kresume c arg, Kresume c' arg' => core_inj f c c' /\ val_obs f arg arg'
    | _, _  => False
    end.

  Definition ctl_wd f t : Prop :=
    match t with
    | Krun c => core_wd f c
    | Kblocked c => core_wd f c
    | Kresume c v => core_wd f c /\ valid_val f v
    | Kinit vf v => valid_val f vf /\ valid_val f v
    end.

  Lemma ctl_wd_incr : forall f f' c,
      ctl_wd f c ->
      ren_domain_incr f f' ->
      ctl_wd f' c.

  Lemma ctl_inj_trans:
    forall c c' c'' (f f' f'' : memren)
      (Hcore_inj: ctl_inj f c c'')
      (Hcore_inj': ctl_inj f' c c')
      (Hf: forall b b' b'',
          f b = Some b'' ->
          f' b = Some b' ->
          f'' b' = Some b''),
      ctl_inj f'' c' c''.

  Definition tp_wd (f: memren) (tp : t) : Prop :=
    forall i (cnti: containsThread tp i),
      ctl_wd f (getThreadC cnti).

  Lemma tp_wd_incr : forall f f' tp,
      tp_wd f tp ->
      ren_domain_incr f f' ->
      tp_wd f' tp.

  Lemma ctl_wd_domain:
    forall f f' m (c : ctl),
      ctl_wd f c ->
      domain_memren f m ->
      domain_memren f' m ->
      ctl_wd f' c.

  Lemma tp_wd_domain:
    forall f f' m (tp : t),
      tp_wd f tp ->
      domain_memren f m ->
      domain_memren f' m ->
      tp_wd f' tp.

  Lemma tp_wd_lockSet:
    forall tp f addr rmap
      (Htp_wd: tp_wd f tp),
      tp_wd f (updLockSet tp addr rmap).

  Lemma tp_wd_remLock :
    forall (tp : t) (f : memren) (addr : address)
      (Htp_wd: tp_wd f tp),
      tp_wd f (remLockSet tp addr).

  Lemma ctl_inj_id:
    forall f c,
      ctl_wd f c ->
      (forall b1 b2, f b1 = Some b2 -> b1 = b2) ->
      ctl_inj f c c.

End ThreadPoolInjections.

End ThreadPoolInjections. *)

Require Import VST.concurrency.sc_drf.x86_inj.
(* VST.concurrency.sc_drf.x86_inj:
Require Import VST.sepcomp.semantics.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.semantics_lemmas.

Require Import VST.concurrency.common.pos.

Require Import compcert.lib.Coqlib.
Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import compcert.lib.Integers.

Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.sc_drf.mem_obs_eq.
Require Import VST.concurrency.memory_lemmas.
Require Import compcert.x86.Asm.
Require Import VST.concurrency.common.Asm_core VST.concurrency.common.Asm_event.
Require Import VST.concurrency.common.x86_context.
Require Import VST.concurrency.common.core_semantics.

Import ValObsEq Renamings MemObsEq event_semantics.

Set Bullet Behavior "Strict Subproofs".

Module X86WD.
  Import MemoryWD Genv ValueWD.
  Section X86WD.
    Variable f: memren.

    Definition regset_wd rs : Prop :=
      forall r, valid_val f (Pregmap.get r rs).

    Definition core_wd c : Prop :=
      match c with State rs _ => regset_wd rs end.

    Definition ge_wd (the_ge: genv) : Prop :=
      (forall b, Maps.PTree.get b (genv_defs the_ge) ->
            f b) /\
      (forall id ofs v, Senv.symbol_address the_ge id ofs = v ->
                   valid_val f v).

  End X86WD.

  Lemma regset_wd_incr :
    forall f1 f2 rs
      (Hincr: ren_domain_incr f1 f2)
      (Hwd: regset_wd f1 rs),
      regset_wd f2 rs.

  Lemma core_wd_incr :
    forall f1 f2 rs
      (Hwd: core_wd f1 rs)
      (Hincr: ren_domain_incr f1 f2),
      core_wd f2 rs.

  Lemma regset_wd_set:
    forall f rs r v
      (H: valid_val f v)
      (Hrs: regset_wd f rs),
      regset_wd f (rs # r <- v).

  Lemma regset_wd_set_res:
    forall f br rs v
      (H: valid_val f v)
      (Hrs: regset_wd f rs),
      regset_wd f (set_res br v rs).

  Lemma regset_wd_domain :
    forall f1 f2 m rs
      (Hdomain1: domain_memren f1 m)
      (Hdomain2: domain_memren f2 m)
      (Hwd: regset_wd f1 rs),
      regset_wd f2 rs.

  Lemma core_wd_domain :
    forall f1 f2 m rs
      (Hwd: core_wd f1 rs)
      (Hdomain1: domain_memren f1 m)
      (Hdomain2: domain_memren f2 m),
      core_wd f2 rs.

  Lemma longofwords_valid_val:
    forall f v1 v2,
      valid_val f v1 -> valid_val f v2 ->
      valid_val f (Val.longofwords v1 v2).

  Hint Extern 1 (valid_val _ (@Pregmap.set _ _ _ _ _)) => eapply regset_wd_set : wd.
  Hint Resolve regset_wd_set regset_wd_set_res : wd.

  Lemma valid_val_reg_set:
    forall f rs r r' v,
      valid_val f v ->
      regset_wd f rs ->
      valid_val f (rs # r <- v r').

  Lemma regset_comm:
    forall (rs: Pregmap.t val) r r' v,

  Lemma undef_regs_comm:
    forall regs rs r,
      undef_regs regs (rs # r <- Vundef) =
      (undef_regs regs rs) # r <- Vundef.

  Lemma regset_wd_undef:
    forall f rs regs
      (Hrs_wd: regset_wd f rs),
      regset_wd f (undef_regs regs rs).

  Hint Extern 0 (valid_val _ (undef_regs _ _ # _ <- _ _)) => eapply regset_wd_set : wd.

  Hint Resolve regset_wd_domain
       valid_val_list_incr valid_val_domain
       valid_val_list_domain regset_wd_undef : wd.

  Lemma valid_symb:
    forall f fg g id i
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_domain_incr fg f),
      valid_val f (symbol_address g id i).

  Hint Resolve valid_symb : wd.

  Lemma valid_val_cmpu:
    forall f ptr c v1 v2,
      valid_val f (Val.cmpu ptr c v1 v2).

  Hint Immediate valid_val_cmpu :wd.

  Lemma valid_val_cmplu:
    forall f ptr c v1 v2,
      valid_val f (Val.maketotal (Val.cmplu ptr c v1 v2)).

  Hint Immediate valid_val_cmplu :wd.

  Lemma valid_val_addrmode64:
    forall ge rs f fg a,
      ren_domain_incr fg f ->
      ge_wd fg ge ->
      regset_wd f rs ->
      valid_val f (eval_addrmode64 ge a rs).

  Lemma valid_val_addrmode:
    forall ge rs f fg a,
      ren_domain_incr fg f ->
      ge_wd fg ge ->
      regset_wd f rs ->
      valid_val f (eval_addrmode ge a rs).

  Lemma valid_val_compare_ints:
    forall f rs m v1 v2 r,
      regset_wd f rs ->
      valid_val f (compare_ints v1 v2 rs m r).

  Hint Resolve valid_val_compare_ints : wd.

  Lemma valid_val_compare_longs:
    forall f rs m v1 v2 r,
      regset_wd f rs ->
      valid_val f (compare_longs v1 v2 rs m r).

  Hint Resolve valid_val_compare_longs : wd.

  Lemma regset_wd_compare_ints:
    forall f rs m v1 v2,
      regset_wd f rs ->
      regset_wd f (compare_ints v1 v2 rs m).

  Lemma regset_wd_compare_longs:
    forall f rs m v1 v2,
      regset_wd f rs ->
      regset_wd f (compare_longs v1 v2 rs m).

  Lemma valid_val_compare_floats:
    forall f rs v1 v2 r,
      regset_wd f rs ->
      valid_val f (compare_floats v1 v2 rs r).

  Hint Resolve valid_val_compare_floats : wd.

  Lemma regset_wd_compare_floats:
    forall f rs v1 v2,
      regset_wd f rs ->
      regset_wd f (compare_floats v1 v2 rs).

  Lemma valid_val_compare_floats32:
    forall f rs v1 v2 r,
      regset_wd f rs ->
      valid_val f (compare_floats32 v1 v2 rs r).

  Hint Resolve valid_val_compare_floats32 : wd.

  Lemma regset_wd_compare_floats32:
    forall f rs v1 v2,
      regset_wd f rs ->
      regset_wd f (compare_floats32 v1 v2 rs).

  Hint Resolve valid_val_addrmode valid_val_addrmode64
       regset_wd_compare_floats regset_wd_compare_floats32
       regset_wd_compare_ints regset_wd_compare_longs : wd.

End X86WD.

Module X86Inj.

  Import CoreInjections.

  Definition reg_ren f (r:PregEq.t) (rs rs' : regset) : Prop :=
    val_obs f (Pregmap.get r rs) (Pregmap.get r rs').

  Definition regset_ren f rs rs' : Prop :=
    forall r, reg_ren f r rs rs'.

  Definition core_inj f c c' :=
    match c, c' with State rs _, State rs' _ => regset_ren f rs rs' end.

  Import ValueWD MemoryWD Genv.
  Include X86WD.

  Lemma get_reg_renC:
    forall f r rs rs',
      regset_ren f rs rs' ->
      rs' r = val_obsC f (rs r).

  Lemma get_reg_ren:
    forall f r rs rs' v,
      regset_ren f rs rs' ->
      rs r = v ->
      exists v', rs' r = v' /\ val_obs f v v'.

  Lemma val_obs_reg:
    forall f r rs rs',
      regset_ren f rs rs' ->
      val_obs f (rs r) (rs' r).

  Lemma regset_ren_trans:
    forall f f' f'' rs rs' rs'',
      regset_ren f rs rs'' ->
      regset_ren f' rs rs' ->
      (forall b b' b'' : block,
          f b = Some b'' -> f' b = Some b' -> f'' b' = Some b'') ->
      regset_ren f'' rs' rs''.

  Lemma regset_ren_id:
    forall f rs
      (Hregset_wd: regset_wd f rs)
      (Hf: forall b1 b2, f b1 = Some b2 -> b1 = b2),
      regset_ren f rs rs.

  Lemma regset_ren_incr:
    forall f f' rs rs'
      (Hrs_ren: regset_ren f rs rs')
      (Hincr: ren_incr f f'),
      regset_ren f' rs rs'.

  Lemma regset_ren_set:
    forall f rs rs' v v' r
      (Hrs_ren: regset_ren f rs rs')
      (Hval_obs: val_obs f v v'),
      regset_ren f (rs # r <- v) (rs' # r <- v').

  Lemma regset_ren_init:
    forall f v v'
      (Hval_obs: val_obs f v v'),
      regset_ren f (Pregmap.init v) (Pregmap.init v').

  Lemma regset_ren_set_res:
    forall f br rs rs' v v'
      (Hrs_ren: regset_ren f rs rs')
      (Hval_obs: val_obs f v v'),
      regset_ren f (set_res br v rs) (set_res br v' rs').

  Lemma gso_undef_regs:
    forall (rs : regset) r regs,
      ~ List.In r regs ->

  Lemma valid_val_ge_id:
    forall fg f b i
      (Hvalid: valid_val fg (Vptr b i))
      (Hincr: ren_incr fg f)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2),
      f b = Some b.

  Hint Resolve
       val_obs_reg regset_ren_set regset_ren_set_res : reg_renamings.
  Hint Rewrite gso_undef_regs : reg_renamings.

  Hint Resolve valid_val_ge_id  : ge_renamings.
  Hint Constructors eval_builtin_arg : renamings.
  Hint Unfold Vone Vzero nextinstr nextinstr_nf : renamings.

  Lemma val_obs_symb:
    forall f fg g id i
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2),
      val_obs f (symbol_address g id i) (symbol_address g id i).

  Hint Resolve val_obs_symb : ge_renamings.

  Lemma regset_ren_undef:
    forall f rs rs' regs
      (Hrs_ren: regset_ren f rs rs'),
      regset_ren f (undef_regs regs rs) (undef_regs regs rs').

  Hint Resolve regset_ren_undef : reg_renamings.

  Lemma ge_wd_incr :
    forall (f f' : memren) (g : genv),
      ge_wd f g -> ren_domain_incr f f' -> ge_wd f' g.

  Lemma ge_wd_domain :
    forall (f f' : memren) (m : mem) (g : genv),
      ge_wd f g -> domain_memren f m -> domain_memren f' m -> ge_wd f' g.

  Lemma get_extcall_arg_wd : forall f rs m l v
    (Hm : valid_mem m)
    (Hdom : domain_memren f m)
    (Hrs : regset_wd f rs)
    (Hv : get_extcall_arg rs m l = Some v),
    valid_val f v.

  Lemma get_extcall_arguments_wd : forall f rs m l v
    (Hm : valid_mem m)
    (Hdom : domain_memren f m)
    (Hrs : regset_wd f rs)
    (Hv : get_extcall_arguments rs m l = Some v),
    valid_val_list f v.

  Lemma at_external_wd :
    forall the_ge m (f : memren) c
      (ef : external_function)
      (args : seq val),
      valid_mem m ->
      domain_memren f m ->
      core_wd f c ->
      semantics.at_external (Asm_core_sem the_ge) c m = Some (ef, args) -> valid_val_list f args.

  Lemma valid_val_hiword:
    forall f v,
      valid_val f v ->
      valid_val f (Val.hiword v).

  Lemma valid_val_loword:
    forall f v,
      valid_val f v ->
      valid_val f (Val.loword v).

  Hint Resolve valid_val_loword valid_val_loword : wd.

  Lemma after_external_wd :
    forall the_ge m (c c' : state) (f : memren) (ef : external_function)
      (args : seq val) (ov : option val)
      (Hat_external: semantics.at_external (Asm_core_sem the_ge) c m = Some (ef, args))

  Lemma valid_val_nullptr : forall f, valid_val f Vnullptr.

  Lemma make_arg_wd:
    forall f rs rs' m m' loc arg
      (Hrs_wd: regset_wd f rs)
      (Hmem_wd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Hvalid_val: valid_val f arg)
      (Hmake_args: make_arg rs m loc arg = Some (rs', m')),
      regset_wd f rs' /\ valid_mem m' /\ domain_memren f m'.
  
  Lemma make_arguments_wd:
    forall f rs rs' m m' loc args
      (Hrs_wd: regset_wd f rs)
      (Hmem_wd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Hvalid_val: valid_val_list f args)
      (Hmake_args: make_arguments rs m loc args = Some (rs', m')),
      regset_wd f rs' /\ valid_mem m' /\ domain_memren f m'.

  Lemma mem_valid_alloc:
    forall m m' b lo hi f
      (Hdomain: domain_memren f m)
      (Hvalid_mem: valid_mem m)
      (Halloc: Mem.alloc m lo hi = (m', b)),
      valid_mem m' /\
      (exists f', ren_domain_incr f f' /\ domain_memren f' m').
  Proof.
    intros.
    split.
    - unfold valid_mem.
      intros b0 Hvalid0 ofs mv Hget.
      pose proof (Mem.valid_block_alloc_inv _ _ _ _ _ Halloc _ Hvalid0) as H.
      destruct H.
      + subst.
        erewrite MemoryLemmas.val_at_alloc_2; eauto.
      + unfold valid_mem in Hvalid_mem.
        specialize (Hvalid_mem _ H ofs _ ltac:(reflexivity)).
        erewrite MemoryLemmas.val_at_alloc_1 in Hvalid_mem; eauto.

  Lemma initial_core_wd :
    forall the_ge m m' (f fg : memren) (vf : val) args (c_new : state) h,
      valid_mem m ->
      domain_memren f m ->
      initial_core (Asm_core_sem the_ge) h m c_new m' vf args ->
      valid_val_list f args -> ge_wd fg the_ge ->
      ren_domain_incr fg f ->
      valid_mem m' /\
      (exists f', ren_domain_incr f f' /\ domain_memren f' m') /\
      forall f', domain_memren f' m' ->
            core_wd f' c_new.

  Lemma get_extcall_arg_inj : forall f rs rs' m m' l v,
    regset_ren f rs rs' -> mem_obs_eq f m m' ->
    get_extcall_arg rs m l = Some v ->
    exists v', get_extcall_arg rs' m' l = Some v' /\ val_obs f v v'.

  Lemma get_extcall_arguments_inj : forall f rs rs' m m' l v,
    regset_ren f rs rs' -> mem_obs_eq f m m' ->
    get_extcall_arguments rs m l = Some v ->
    exists v', get_extcall_arguments rs' m' l = Some v' /\ val_obs_list f v v'.

  Lemma get_extcall_arg_inj' : forall f rs rs' m m' l,
    regset_ren f rs rs' -> mem_obs_eq f m m' ->
    get_extcall_arg rs m l = None ->
    get_extcall_arg rs' m' l = None.

  Lemma get_extcall_arguments_inj' : forall f rs rs' m m' l,
    regset_ren f rs rs' -> mem_obs_eq f m m' ->
    get_extcall_arguments rs m l = None ->
    get_extcall_arguments rs' m' l = None.

  Lemma find_funct_ptr_inj : forall g (f fg : memren) b b' h
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f),
    find_funct_ptr g b = Some h -> f b = Some b' -> b' = b.

  Lemma find_funct_ptr_inj' : forall g (f fg : memren) m m' b b' h
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Hmem : mem_obs_eq f m m'),
    find_funct_ptr g b' = Some h -> f b = Some b' -> b' = b.

  Lemma core_inj_ext :
    forall the_ge m m' c c' (f fg : memren)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hincr: ren_incr fg f)
      (Hc : core_wd f c)
      (Hinj : core_inj f c c')
      (Hmem : mem_obs_eq f m m'),
      match semantics.at_external (Asm_core_sem the_ge) c m with

  Lemma core_inj_after_ext :
    forall the_ge c cc c' (ov1 : option val) m m'
      (f fg : memren)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hincr: ren_incr fg f),
      core_inj f c c' ->
      mem_obs_eq f m m' ->
      match ov1 with
      | Some v1 => valid_val f v1
      | None => True
      end ->
      semantics.after_external (Asm_core_sem the_ge) ov1 c m = Some cc ->

  Lemma core_inj_halted :
    forall the_ge c c' (f : memren),
      core_inj f c c' -> forall v,
      halted (Asm_core_sem the_ge) c v <-> halted (Asm_core_sem the_ge) c' v.

  Lemma val_obs_inj : forall f v v1 v2, val_obs f v v1 -> val_obs f v v2 -> v1 = v2.

  Lemma val_obs_list_inj : forall f v v1 v2, val_obs_list f v v1 -> val_obs_list f v v2 -> v1 = v2.

  Lemma make_arg_inj:
    forall (f : memren) (rs rs1 rs' : regset) (m m1 m' : mem) l
      (arg arg' : val)
      (Hrs: regset_ren f rs rs')
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hval_obs_list: val_obs f arg arg')
      (Hmake: make_arg rs m l arg = Some (rs1, m1)),
    exists rs1' m1',
      make_arg rs' m' l arg' = Some (rs1', m1') /\
      regset_ren f rs1 rs1' /\
      mem_obs_eq f m1 m1'.

  Lemma make_arguments_inj:
    forall (f : memren) (l : seq (rpair Locations.loc)) (rs rs1 rs' : regset) (m m1 m' : mem) 

  Lemma nextblock_storev :
    forall chunk  (m1 : mem) (vptr v : val) (m2 : mem),
      Mem.storev chunk m1 vptr v = Some m2 ->
  
  Lemma core_inj_init :
    forall the_ge m1 m1' m2 vf vf' arg arg' c_new f fg h
      (Hge_wd: ge_wd fg the_ge)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hincr: ren_incr fg f)
      (Harg: val_obs_list f arg arg')
      (Hvf: val_obs f vf vf')
      (Hmem_obs_eq: mem_obs_eq f m1 m1')
      (Hinit: initial_core (Asm_core_sem the_ge) h m1 c_new m2 vf arg),
    exists c_new' m2' f',
            initial_core (Asm_core_sem the_ge) h m1' c_new' m2' vf' arg'
            /\ core_inj f' c_new c_new'
            /\ mem_obs_eq f' m2 m2'
            /\ ren_incr f f'
            /\ ren_separated f f' m1 m1'
            /\ ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
                      (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive)))
            /\ (forall b,
                  Mem.valid_block m2' b ->
                  ~ Mem.valid_block m1' b ->
                  let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                         (Zpos (Mem.nextblock m1))))%Z in
                  f' (Z.to_pos bz) = Some b /\
                  f (Z.to_pos bz) = None)
            /\ (Mem.nextblock m1 = Mem.nextblock m1' ->
               (forall b1 b2, f b1 = Some b2 -> b1 = b2) ->
               forall b1 b2, f' b1 = Some b2 -> b1 = b2)
            /\ (forall b2, (~exists b1, f' b1 = Some b2) ->
                     forall ofs, permissions.permission_at m1' b2 ofs Cur =
                            permissions.permission_at m2' b2 ofs Cur).
  Proof.
    intros.
    simpl in Hinit.
    destruct Hinit as [Hinit ?]; subst.
    inv Hinit.
    inv Hvf.
    exploit find_funct_ptr_inj; eauto; intro; subst.
    assert (Hnext23: Mem.nextblock m2 = Mem.nextblock m3)
      by(eapply nextblock_storev in H1; eauto).
    assert (Hnext34: Mem.nextblock m3 = Mem.nextblock m4)
      by (eapply nextblock_storev in H2; eauto).
    assert (Hnext4: Mem.nextblock m4 = Mem.nextblock m).
    { eapply X86SEMAxioms.make_arguments_unchanged_on in H3.
      destruct H3 as [_ [_ Hvalid_eq]].
      unfold Mem.valid_block, Plt in Hvalid_eq.
      destruct (Pos.lt_total (Mem.nextblock m4) (Mem.nextblock m)); auto.
      exfalso.
      pose proof (proj1 (Hvalid_eq (Mem.nextblock m4)) H3).
      zify; omega.
      destruct H3; auto.
      exfalso.
      pose proof (proj2 (Hvalid_eq (Mem.nextblock m)) H3).
      zify; omega.
    }

    remember (Mem.alloc m1' 0 (3 * size_chunk Mptr)) eqn:Halloc'.
    destruct p as [m2' stk'].
    symmetry in Halloc'.
    destruct (alloc_obs_eq Hmem_obs_eq H0 Halloc') as
        (f' & Hf' & Hmem_obs_eq1' & Hincr' & Hsep & Hnextblock & Hinverse & Hid).
    pose (Vptr stk' Ptrofs.zero) as sp'.
    assert (Hval_sp: val_obs f' sp sp')
      by (subst sp sp';
          econstructor; now eauto).
    assert(Hvnull: val_obs f' Vnullptr Vnullptr)
      by (unfold Vnullptr; destruct (Archi.ptr64); econstructor).
    eapply storev_val_obs with (vptr2 := Val.offset_ptr sp' (Ptrofs.repr (2 * size_chunk Mptr)))
                               (v2 := Vnullptr) in H1; eauto with val_renamings.
    destruct H1 as [m3' [Hstorev3' Hmem_obs_eq3']].
    eapply storev_val_obs with (vptr2 := (Val.offset_ptr sp' Ptrofs.zero))
                               (v2 := Vnullptr) in H2; eauto with val_renamings.
    destruct H2 as [m4'  [Hstorev4' Hmem_obs_eq4']].
    pose ((((Pregmap.init Vundef) # PC <- (Vptr b Ptrofs.zero)) # RA <- Vnullptr) # RSP <- sp') as rs0'.
    assert (Hregset: regset_ren f' rs0 rs0').
    { subst rs0 rs0'.
      eapply regset_ren_set; subst sp sp'; eauto.
      eapply regset_ren_set; eauto.
      eapply regset_ren_set; eauto;
        econstructor;
        now eauto.
    }
    eapply make_arguments_inj in H3; eauto using val_obs_list_incr.
    destruct H3 as [rs' [m' [Hmake_args' [Hregs' Hmem_obs_eq']]]].
    assert (Hnext23': Mem.nextblock m2' = Mem.nextblock m3')
      by(eapply nextblock_storev in Hstorev3'; eauto).
    assert (Hnext34': Mem.nextblock m3' = Mem.nextblock m4')
      by (eapply nextblock_storev in Hstorev4'; eauto).
    assert (Hnext4': Mem.nextblock m4' = Mem.nextblock m').
    { eapply X86SEMAxioms.make_arguments_unchanged_on in Hmake_args'.
      destruct Hmake_args' as [_ [_ Hvalid_eq]].
      unfold Mem.valid_block, Plt in Hvalid_eq.
      destruct (Pos.lt_total (Mem.nextblock m4') (Mem.nextblock m')); auto.
      exfalso.
      pose proof (proj1 (Hvalid_eq (Mem.nextblock m4')) H1).
      zify; omega.
      destruct H1; auto.
      exfalso.
      pose proof (proj2 (Hvalid_eq (Mem.nextblock m')) H1).
      zify; omega.
    }
    exists (State rs' m'), m', f'.
    simpl.
    repeat match goal with
           | [ |- _ /\ _] =>
             split; simpl; eauto with renamings reg_renamings
           end; try (econstructor; now eauto).
    rewrite <- Hnext4', <- Hnext34', <- Hnext23'.
    rewrite <- Hnext4, <- Hnext34, <- Hnext23.
    eassumption.
    intros b0 Hvalidm' Hinvalidm1'.
    unfold Mem.valid_block in *.
    rewrite <- Hnext4', <- Hnext34', <- Hnext23' in Hvalidm'.
    now eauto.
    intros b2 Hunmapped ofs.
    eapply X86SEMAxioms.make_arguments_unchanged_on in Hmake_args'.
    destruct Hmake_args' as [_ [Hperm_Eq _]].
    erewrite <- Hperm_Eq.
    eapply MemoryLemmas.mem_storev_store in Hstorev4'.
    destruct Hstorev4' as [? [? [? Hstore4']]].
    eapply Mem.store_access in Hstore4'.
    eapply MemoryLemmas.mem_storev_store in Hstorev3'.
    destruct Hstorev3' as [? [? [? Hstore3']]].
    eapply Mem.store_access in Hstore3'.
    unfold permissions.permission_at in *.
    erewrite Hstore4', Hstore3'.
    pose proof (MemoryLemmas.permission_at_alloc_4 _ _ _ _ _ b2 ofs Halloc') as Hperm_alloc.

  Lemma core_inj_id :
    forall c (f : memren),
      core_wd f c ->
      (forall b1 b2 : block, f b1 = Some b2 -> b1 = b2) -> core_inj f c c.

  Lemma core_inj_trans :
    forall c c' c'' (f f' f'' : memren),
      core_inj f c c'' ->
      core_inj f' c c' ->
      (forall b b' b'' : block,
          f b = Some b'' -> f' b = Some b' -> f'' b' = Some b'') ->
      core_inj f'' c' c''.

  Import MemObsEq MemoryLemmas.

  Lemma find_funct_ptr_ren:
    forall (g : genv) b1 b2 ofs (f fg : memren) fn
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Hobs_eq: val_obs f (Vptr b1 ofs) (Vptr b2 ofs))
      (Hget: Genv.find_funct_ptr g b1 = Some fn),

  Lemma symb_val_obs:
    forall f fg g id ofs
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f),
      val_obs f (Senv.symbol_address g id ofs) (Senv.symbol_address g id ofs).

  Lemma eval_builtin_arg_ren:
    forall (g : genv) (rs rs' : regset) (f fg: memren) (m m' : mem)
      (arg : builtin_arg preg) (varg : val)
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hrs_ren: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Heval: eval_builtin_arg g rs (rs RSP) m arg varg),
    exists varg',
      eval_builtin_arg g rs' (rs' RSP) m' arg varg' /\
      val_obs f varg varg'.

  Lemma eval_builtin_args_ren:
    forall (g : genv) (rs rs' : regset) (f fg: memren) (m m' : mem)
      (args : seq (builtin_arg preg)) (vargs : seq val)
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hrs_ren: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Heval: eval_builtin_args g rs (rs RSP) m args vargs),
    exists vargs',
      eval_builtin_args g rs' (rs' RSP) m' args vargs' /\
      val_obs_list f vargs vargs'.

  Lemma block_is_volatile_ren:
    forall g fg f b1 b2
      (Hfg: forall b1 b2 : block, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Hf: f b1 = Some b2)
      (Hinjective: forall b1 b1' b2, f b1 = Some b2 -> f b1' = Some b2 ->
                                b1 = b1')
      (Hvolatile: Senv.block_is_volatile g b1 = false),

  Lemma val_obs_addrmode32:
    forall f fg g (a : addrmode) rs rs'
      (Hrs_ren: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f),
      val_obs f (eval_addrmode32 g a rs) (eval_addrmode32 g a rs').

  Lemma val_obs_addrmode64:
    forall f fg g (a : addrmode) rs rs'
      (Hrs_ren: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f),
      val_obs f (eval_addrmode64 g a rs) (eval_addrmode64 g a rs').

  Lemma val_obs_addrmode:
    forall f fg g (a : addrmode) rs rs'
      (Hrs_ren: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f),
      val_obs f (eval_addrmode g a rs) (eval_addrmode g a rs').

  Lemma compare_ints_ren:
    forall f v1 v2 v1' v2' rs rs' m m'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2')
      (Hrs_ren: regset_ren f rs rs')
      (Hmem_obs_eq: mem_obs_eq f m m'),
      regset_ren f (compare_ints v1 v2 rs m)
                 (compare_ints v1' v2' rs' m').

  Lemma compare_longs_ren:
    forall f v1 v2 v1' v2' rs rs' m m'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2')
      (Hrs_ren: regset_ren f rs rs')
      (Hmem_obs_eq: mem_obs_eq f m m'),
      regset_ren f (compare_longs v1 v2 rs m)
                 (compare_longs v1' v2' rs' m').

  Lemma compare_floats32_ren:
    forall f rs rs' v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2')
      (Hrs_ren: regset_ren f rs rs'),
      regset_ren f (compare_floats32 v1 v2 rs)
                 (compare_floats32 v1' v2' rs').

  Lemma compare_floats_ren:
    forall f rs rs' v1 v2 v1' v2'
      (Hval_obs: val_obs f v1 v1')
      (Hval_obs': val_obs f v2 v2')
      (Hrs_ren: regset_ren f rs rs'),
      regset_ren f (compare_floats v1 v2 rs)
                 (compare_floats v1' v2' rs').

  Lemma eval_testcond_ren:
    forall f (c : testcond) rs rs'
      (Hrs_ren: regset_ren f rs rs'),
      eval_testcond c rs = eval_testcond c rs'.

  Lemma val_obs_testcond:
    forall f c rs rs'
      (Hrs_ren: regset_ren f rs rs'),
      val_obs f (Val.of_optbool (eval_testcond c rs))

  Hint Resolve compare_floats_ren compare_floats32_ren
       compare_ints_ren compare_longs_ren : reg_renamings.
  Hint Resolve val_obs_addrmode32 val_obs_addrmode64 val_obs_addrmode val_obs_testcond : val_renamings.

  Lemma exec_instr_ren:
    forall (g : genv) (fn : function) (i : instruction) (rs rs' rs2: regset)
      (m m' m2 : mem) (f fg: memren)
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hrs_eq: regset_ren f rs rs')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_incr fg f)
      (Hexec: exec_instr g fn i rs m = Next rs2 m2),
    exists f' rs2' m2',
      exec_instr g fn i rs' m' = Next rs2' m2' /\
      regset_ren f' rs2 rs2' /\
      mem_obs_eq f' m2 m2' /\
      ren_incr f f' /\
      ren_separated f f' m m' /\
      ((exists p : positive,
           Mem.nextblock m2 = (Mem.nextblock m + p)%positive /\

  Lemma extcall_arg_reg:
    forall f rs rs' m m' locs arg
      (Hrs_ren: regset_ren f rs rs')
      (Hobs_eq: mem_obs_eq f m m')
      (Harg: extcall_arg rs m locs arg),
    exists arg',
      extcall_arg rs' m' locs arg' /\
      val_obs f arg arg'.

  Lemma extcall_arg_pair_ren:
    forall f rs rs' m m' locs arg
      (Hrs_ren: regset_ren f rs rs')
      (Hobs_eq: mem_obs_eq f m m')
      (Harg: extcall_arg_pair rs m locs arg),
    exists arg',
      extcall_arg_pair rs' m' locs arg' /\
      val_obs f arg arg'.

  Lemma extcall_arguments_ren:
    forall f m m' ef args rs rs'
      (Hexternal: extcall_arguments rs m (ef_sig ef) args)
      (Hmem_obs_eq: mem_obs_eq f m m')
      (Hrs_ren: regset_ren f rs rs'),
    exists args',
      extcall_arguments rs' m' (ef_sig ef) args' /\
      val_obs_list f args args'.

  Lemma core_inj_wd:
    forall f c c',
      core_inj f c c' ->
      core_wd f c.

  Lemma corestep_obs_eq:
    forall the_ge (Hsafe : safe_genv the_ge) (cc cf cc' : state) (mc mf mc' : mem) f fg,
      mem_obs_eq f mc mf ->
      core_inj f cc cf ->
      (forall b1 b2, fg b1 = Some b2 -> b1 = b2) ->
      ge_wd fg the_ge ->
      ren_incr fg f ->
      corestep (Asm_core_sem the_ge) cc mc cc' mc' ->
      exists (cf' : state) (mf' : mem) (f' : Renamings.memren),

  Lemma extcall_arg_valid:
    forall f rs m locs arg
      (Hrs_wd: regset_wd f rs)
      (Hmem_wd : valid_mem m)
      (Hobs_eq: domain_memren f m)
      (Harg: extcall_arg rs m locs arg),
      valid_val f arg.

  Lemma valid_val_longofwords:
    forall f hi lo,
      valid_val f hi ->
      valid_val f lo ->
      valid_val f (Val.longofwords hi lo).

  Hint Resolve valid_val_longofwords : wd.

  Lemma extcall_arg_pair_valid:
    forall f rs m locs arg
      (Hrs_wd: regset_wd f rs)
      (Hmem_wd : valid_mem m)
      (Hobs_eq: domain_memren f m)
      (Harg: extcall_arg_pair rs m locs arg),
      valid_val f arg.

  Lemma extcall_arguments_valid:
    forall f m ef args rs
      (Hexternal: extcall_arguments rs m (ef_sig ef) args)
      (Hrs_wd: regset_wd f rs)
      (Hmem_wd : valid_mem m)
      (Hobs_eq: domain_memren f m),
      valid_val_list f args.

  Lemma free_wd_domain :
  forall (m m' : mem) b lo hi (f : memren),
    domain_memren f m ->
    Mem.free m b lo hi = Some m' ->

 Lemma exec_instr_wd:
    forall (g : genv) (fn : function) (i : instruction) (rs rs': regset)
      (m m' : mem) (f fg: memren) loader
      (Hmem_wd: valid_mem m)
      (Hrs_wd: regset_wd f rs)
      (Hge_wd: ge_wd fg g)
      (Hincr: ren_domain_incr fg f)
      (Hdomain: domain_memren f m)
      (Hexec: exec_instr g fn i rs m = Next rs' m'),
      valid_mem m' /\
      (exists f' : memren, ren_domain_incr f f' /\ domain_memren f' m') /\
      (forall f' : memren,
          domain_memren f' m' -> core_wd f' (State rs' loader)).

  Lemma corestep_wd:
    forall the_ge (Hsafe : safe_genv the_ge) c m c' m' f fg
      (Hwd: core_wd f c)
      (Hmem_wd: valid_mem m)
      (Hge_wd: ge_wd fg the_ge)
      (Hincr: ren_domain_incr fg f)
      (Hdomain: domain_memren f m)
      (Hcorestep: corestep (Asm_core_sem the_ge) c m c' m'),
      valid_mem m' /\
      (exists f', ren_domain_incr f f' /\ domain_memren f' m') /\
      forall f', domain_memren f' m' ->
            core_wd f' c'.

  End Inj.

End X86Inj. *)

Require Import VST.concurrency.sc_drf.x86_safe.
(* VST.concurrency.sc_drf.x86_safe:
Require Import compcert.lib.Axioms.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.
Require Import VST.concurrency.common.pos.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Require Import FunInd.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.lib.Integers.
Require Import compcert.x86.Asm.

Require Import Coq.ZArith.ZArith.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.erased_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.x86_context.
Require Import VST.concurrency.common.Asm_core.
Require Import VST.concurrency.sc_drf.mem_obs_eq.
Require Import VST.concurrency.sc_drf.x86_erasure.
Require Import VST.concurrency.sc_drf.x86_inj.
Require Import VST.concurrency.sc_drf.fineConc_safe.
Require Import VST.concurrency.sc_drf.executions.
Require Import VST.concurrency.sc_drf.SC_erasure.
Require Import VST.concurrency.sc_drf.SC_spinlock_safe.
Require Import VST.concurrency.sc_drf.spinlocks.

Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.

Module InitialMemWD.

  Import Memory CoreInjections Renamings ValueWD.

  Lemma valid_genv_alloc: forall ge (m m1:mem) lo hi b
                            (ALLOC: Mem.alloc m lo hi = (m1,b))
  
Lemma valid_genv_store: forall ge m m1 b ofs v chunk
    (STORE: Mem.store chunk m b ofs v = Some m1)

Lemma valid_genv_store_zeros: forall ge m m1 b y z
    (STORE_ZERO: store_zeros m b y z = Some m1)
    (G: X86WD.ge_wd (id_ren m) ge), X86WD.ge_wd (id_ren m1) ge.

Lemma mem_wd_store_zeros: forall m b p n m1
                            (STORE_ZERO: store_zeros m b p n = Some m1)
                            (WD: MemoryWD.valid_mem m),

    Lemma validblock_id_ren : forall (m : mem) (b : block),
        id_ren m b ->  Mem.valid_block m b.

Lemma valid_genv_drop: forall ge (m m1:mem) b lo hi p
    (DROP: Mem.drop_perm m b lo hi p = Some m1) (G: X86WD.ge_wd (id_ren m) ge),

Lemma mem_wd_store_init_data: forall ge a (b:block) (z:Z)
  m1 m2 (SID:Genv.store_init_data ge m1 b z a = Some m2),

Lemma valid_genv_store_init_data:
  forall ge a (b:block) (z:Z) m1 m2
    (SID: Genv.store_init_data ge m1 b z a = Some m2),

Lemma mem_wd_store_init_datalist: forall ge l (b:block)
  (z:Z) m1 m2 (SID: Genv.store_init_data_list ge m1 b z l = Some m2),

Lemma valid_genv_store_init_datalist: forall ge l (b:block)
  (z:Z) m1 m2 (SID: Genv.store_init_data_list ge m1 b z l = Some m2),

Lemma mem_valid_drop :
  forall (m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem),
    Mem.drop_perm m b lo hi p = Some m' ->

Lemma mem_wd_alloc_global: forall ge a m0 m1
   (GA: Genv.alloc_global ge m0 a = Some m1),

Lemma valid_genv_alloc_global: forall ge a m0 m1
   (GA: Genv.alloc_global ge m0 a = Some m1),

Lemma valid_genv_alloc_globals:
   forall ge init_list m0 m
   (GA: Genv.alloc_globals ge m0 init_list = Some m),

Lemma mem_wd_alloc_globals:
   forall ge init_list m0 m
   (GA: Genv.alloc_globals ge m0 init_list = Some m),

End InitialMemWD.

Module X86Safe.

  Import AsmContext SCErasure X86Context X86SEMAxioms HybridMachine
         HybridMachineSig HybridCoarseMachine HybridFineMachine
         FineConcSafe FineConcInitial Executions SpinLocks.

  Section X86Safe.

    Context {U: seq.seq nat}
            {the_program: Asm.program}
            {Hsafe: Asm_core.safe_genv (@the_ge the_program)}.
    
    Instance X86Sem : Semantics := @X86Sem the_program Hsafe.
    Instance X86Axioms : CoreLanguage.SemAxioms := @X86Axioms the_program Hsafe.
    Instance X86Det : CoreLanguage.SemDet := @X86Det the_program Hsafe.
    Existing Instance X86CoreErasure.X86Erasure.
    Existing Instance X86Inj.X86Inj.
        Context {FI : FineInit}. 
    Variable em : ClassicalFacts.excluded_middle.
    Existing Instance dryCoarseMach.
    Existing Instance dryFineMach.
    Existing Instance bareMach.

    Notation fexecution := (@fine_execution _ FineDilMem DryHybridMachine.dryResources DryHybridMachine.DryHybridMachineSig).
    Notation sc_execution := (@fine_execution _ BareDilMem BareMachine.resources BareMachine.BareMachineSig).
    Notation fsafe := (@HybridFineMachine.fsafe DryHybridMachine.dryResources _
                                                OrdinalPool.OrdinalThreadPool
                                                DryHybridMachine.DryHybridMachineSig FineDilMem).
    Notation sc_safe := (@HybridFineMachine.fsafe BareMachine.resources _
                                                  OrdinalPool.OrdinalThreadPool
                                                  BareMachine.BareMachineSig BareDilMem).

    Lemma x86SC_safe:
      forall Main_ptr init_thread_target new_mem_target,
        initial_core (event_semantics.msem semSem) 0 init_mem init_thread_target new_mem_target Main_ptr nil ->

  End X86Safe.
End X86Safe. *)

Require Import VST.concurrency.sc_drf.executions.
(* VST.concurrency.sc_drf.executions:
Require Import compcert.lib.Axioms.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.
Require Import VST.sepcomp.event_semantics.

Require Import VST.concurrency.common.pos.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Memory.
Require Import compcert.lib.Integers.

Require Import Coq.ZArith.ZArith.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.permjoin_def.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.memory_lemmas.

Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.dry_machine_step_lemmas.
Require Import VST.concurrency.common.erased_machine.
Require Import VST.concurrency.common.tactics.
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Import Tactics.

Set Bullet Behavior "None".
Set Bullet Behavior "Strict Subproofs".

Module Executions.

  Import  HybridMachine.DryHybridMachine HybridMachineSig StepLemmas StepType ThreadPool AsmContext.
  Import event_semantics threads_lemmas.
  Import Events.

  Section Executions.

    Context
      {Sem : Semantics}
      {initU : seq.seq nat}
      {SemAx : CoreLanguage.SemAxioms}
      {SemD : CoreLanguage.SemDet}
      {DilMem : DiluteMem}
      {Res: Resources}.
    
    Existing Instance HybridFineMachine.scheduler.
    Existing Instance OrdinalPool.OrdinalThreadPool.
    Context {Hbs : MachineSig}.

    Inductive multi_step :
      MachState -> mem -> MachState -> mem -> Prop :=
    | Step_refl : forall ms (m : mem),
        multi_step ms m ms m
    | Step_trans : forall i U U'
                     (tp tp' tp'' : t)
                     tr tr' tr''
                     (m m' m'' : mem),
        MachStep (i :: U, tr, tp) m (U, tr ++ tr', tp') m' ->
        multi_step (U, tr ++ tr', tp') m' (U', tr ++ tr' ++ tr'', tp'') m'' ->
        multi_step (i :: U,tr,tp) m (U',tr ++ tr' ++ tr'',tp'') m''.

    Inductive fine_execution :
      MachState -> mem -> MachState -> mem -> Prop :=
    | fine_completed : forall ms (m : mem),
        halted_machine ms ->
        fine_execution ms m ms m
    | fine_exec : forall i U U'
                    tp tp' tp''
                    tr tr' tr''
                    (m m' m'' : mem),
        MachStep (i :: U, tr, tp) m (U, tr ++ tr', tp') m' ->
        fine_execution (U, tr ++ tr', tp') m' (U', tr ++ tr' ++ tr'', tp'') m'' ->
        fine_execution (i :: U,tr,tp) m (U',tr ++ tr' ++ tr'',tp'') m''.

    Lemma fine_execution_multi_step:
      forall U  tr tr' tp m tp' m',
        fine_execution (U, tr, tp) m ([::], tr', tp') m' ->
        multi_step (U, tr, tp) m ([::], tr', tp') m'.

    Lemma fine_execution_schedule:
      forall U U' tr tr' tp m tp' m',
        fine_execution (U, tr, tp) m (U', tr', tp') m' ->
        U' = [::].

    Lemma step_ext_trace:
      forall a U
        (i : nat) tr tr' tp tp'
        (m m' : mem) (ev : machine_event),
        is_external ev ->
        nth_error tr' i = Some ev ->
        MachStep ((a :: U)%SEQ, tr, tp) m
                 (U, tr ++ tr', tp') m' ->
        tr' = [:: ev].

    Lemma step_event_tid:
      forall U tr tp m U' tr' tp' m'
        (Hstep: MachStep (U, tr, tp) m
                         (U', tr ++ tr', tp') m'),
      forall ev ev', List.In ev tr' ->

    Lemma step_trace_monotone:
      forall U tp m tr U' tp' m' tr'
        (Hstep: MachStep (U, tr, tp) m
                         (U', tr', tp') m'),
      exists tr'',
        tr' = tr ++ tr''.

    Lemma multi_step_trace_monotone:
      forall U tr tp m U' tr' tp' m'
        (Hexec: multi_step (U, tr, tp) m (U', tr', tp') m'),
      exists tr'',
        tr' = tr ++ tr''.

    Lemma multi_step_inv_ext:
      forall U U' i tr tr' tp m tp' m' ev
        (Hext: is_external ev)
        (Hi: nth_error tr' i = Some ev)
        (Hexec: multi_step (U, tr, tp) m (U', tr ++ tr', tp') m'),
      exists U'' U''' tp'' m'' tr'' tp''' m''',
        multi_step (U, tr, tp) m (U'', tr ++ tr'', tp'') m'' /\
        MachStep (U'', tr ++ tr'', tp'') m''
                 (U''', tr ++ tr'' ++ [:: ev], tp''') m''' /\
        multi_step (U''', tr ++ tr'' ++ [:: ev], tp''') m'''
                   (U', tr ++ tr', tp') m' /\
        length tr'' = i.

    Lemma multi_step_inv:
      forall U U' i tr tr' tp m tp' m' ev
        (Hi: nth_error tr' i = Some ev)
        (Hexec: multi_step (U, tr, tp) m (U', tr ++ tr', tp') m'),
      exists U'' U''' tp'' m'' tr'' pre_ev post_ev  tp''' m''',
        multi_step (U, tr, tp) m (U'', tr ++ tr'', tp'') m'' /\
        MachStep (U'', tr ++ tr'', tp'') m''
                 (U''', tr ++ tr'' ++ pre_ev ++ [:: ev] ++ post_ev, tp''') m''' /\
        multi_step (U''', tr ++ tr'' ++ pre_ev ++ [:: ev] ++ post_ev , tp''') m'''
                   (U', tr ++ tr', tp') m' /\
        length (tr'' ++ pre_ev) = i.

    Lemma step_sched_inv:
      forall i U tp m tr U' tp' m' tr'
        (Hstep: MachStep (i :: U, tr, tp) m
                         (U', tr', tp') m'),
        U' = U.

    Lemma multi_step_snoc:
      forall U U' U'' tr tr' tr'' tp m tp' m' tp'' m''
        (Hexec: multi_step (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hstep: MachStep (U', tr ++ tr', tp') m' (U'', tr ++ tr' ++ tr'', tp'') m''),
        multi_step (U, tr, tp) m (U'', tr ++ tr' ++ tr'', tp'') m''.

    Lemma step_trace_irr:
      forall U i tp m tp' m' tr tr'
        (Hstep: MachStep (i :: U, tr, tp) m (U, tr', tp') m'),
      forall tr'', exists ev,
          MachStep (i :: U, tr'', tp) m (U, tr'' ++ ev, tp') m'.

    Lemma  multi_step_contra:
      forall U U' tr tp m tr' tp' m'
        (HU': U' <> [::])
        (Hexec: multi_step (U, tr, tp) m (U' ++ U, tr', tp') m'),
        False.

    Lemma  multi_step_refl:
      forall U tr tp m tr' tp' m'
        (Hexec: multi_step (U, tr, tp) m (U, tr', tp') m'),
        tp = tp' /\ m = m' /\ tr = tr'.
  End Executions.

  Section FineGrainedExecutions.

    Context
      {Sem : Semantics}
      {initU : seq.seq nat}
      {SemAx : CoreLanguage.SemAxioms}.

    Existing Instance dryResources.
    Existing Instance HybridFineMachine.scheduler.
    Existing Instance OrdinalPool.OrdinalThreadPool.
    Existing Instance DryHybridMachineSig.
    Existing Instance FineDilMem.
    Existing Instance dryFineMach.

     Lemma step_event_sched:
      forall U tr tp m U' ev tr_pre tr_post tp' m'
        (Hstep: MachStep (U, tr, tp) m
                         (U', tr ++ tr_pre ++ [:: ev] ++ tr_post, tp') m'),
        U = (thread_id ev) :: U'.

    Lemma step_ev_contains:
      forall U tr tp m U' ev
        tr_pre tr_post tp' m'
        (Hstep: MachStep (U, tr, tp) m
                         (U', tr ++ tr_pre ++ [:: ev] ++ tr_post, tp') m'),
        containsThread tp (thread_id ev) /\ containsThread tp' (thread_id ev).

        Lemma multi_step_mem_compatible :
      forall U tr tp m U' tr' tp' m'
        (Hexec: multi_step (U, tr, tp) m (U', tr', tp') m'),
        mem_compatible tp m \/ tp = tp' /\ m = m' /\ U = U' /\ tr = tr'.

    Lemma multi_step_invariant :
      forall U tr tp m U' tr' tp' m'
        (Hexec: multi_step (U, tr, tp) m (U', tr', tp') m'),
        invariant tp \/ tp = tp' /\ m = m' /\ U = U' /\ tr = tr'.

    Lemma multi_step_containsThread :
      forall U tp tr m U' tp' tr' m' i
        (Hexec: multi_step (U, tr, tp) m (U', tr', tp') m'),
        containsThread tp i -> containsThread tp' i.

    Lemma multi_step_valid_block:
      forall U tr tp m U' tr' tp' m' b
        (Hexec: multi_step (U, tr, tp) m (U', tr', tp') m')
        (Hvalid: Mem.valid_block m b),

    Inductive deadLocation tp m b ofs : Prop :=
    | Dead: forall
        (Hvalid: Mem.valid_block m b)
        (Hthreads: forall i (cnti: containsThread tp i),
            (getThreadR cnti).1 !! b ofs = None /\ (getThreadR cnti).2 !! b ofs = None)
        (Hresources: forall l pmap,
            lockRes tp l = Some pmap ->
            pmap.1 !! b ofs = None /\ pmap.2 !! b ofs = None),
        deadLocation tp m b ofs.

    Lemma updThreadC_deadLocation:
      forall tp m b ofs i (cnti: containsThread tp i) c,
        deadLocation tp m b ofs ->
        deadLocation (updThreadC cnti c) m b ofs.

    Lemma step_deadLocation:
      forall U U' tr tp m tr' tp' m' b ofs
        (Hdead: deadLocation tp m b ofs)
        (Hstep: MachStep (U, tr, tp) m (U',tr ++ tr', tp') m'),
        deadLocation tp' m' b ofs.

    Lemma multi_step_deadLocation:
      forall U U' tr tp m tr' tp' m' b ofs
        (Hdead: deadLocation tp m b ofs)
        (Hexec: multi_step (U, tr, tp) m (U',tr ++ tr', tp') m'),
        deadLocation tp' m' b ofs.

    Lemma Mklock_lockRes:
      forall i U tr tp m tp' m' addr
        (Hstep: MachStep (i :: U, tr, tp) m
                         (U, tr ++ [:: external i (Events.mklock addr)], tp') m'),

    Definition isLock tp laddr :=
      forall ofs, Intv.In ofs (laddr.2, laddr.2 + lksize.LKSIZE)%Z ->
             (exists i (cnti: containsThread tp i),
                 Mem.perm_order'' ((getThreadR cnti).2 !! (laddr.1) ofs) (Some Readable)) \/
             (exists laddr' rmap, lockRes tp laddr' = Some rmap /\
                             Mem.perm_order'' (rmap.2 !! (laddr.1) ofs) (Some Readable)).

    Lemma remLockRes_Freelock:
      forall i U tr tr' tp m tp' m' addr
        (Hlock: lockRes tp addr)
        (HisLock: isLock tp addr)
        (Hstep: MachStep (i :: U, tr, tp) m
                         (U, tr ++ tr', tp') m')
        (Hev: forall u ev, nth_error tr' u = Some ev ->
                      action ev <> Freelock \/
                      location ev <> Some (addr, lksize.LKSIZE_nat)),

    Lemma remLockRes_Freelock_execution:
      forall U U' tr tr' tp m tp' m' addr
        (Hlock: lockRes tp addr)
        (HisLock: isLock tp addr)
        (Hstep: multi_step (U, tr, tp) m
                           (U', tr ++ tr', tp') m')
        (Hfreelock: forall (u : nat) (evu : machine_event),
            nth_error tr' u = Some evu ->
            action evu <> Freelock \/
            location evu <> Some (addr, lksize.LKSIZE_nat)),

    Lemma ev_elim_stable:
      forall m m' b ofs es
        (Hvalid: Mem.valid_block m b)
        (Hperm: Mem.perm_order'' (Some Writable)
                                 (permission_at m b ofs Cur))
        (Helim: ev_elim m es m'),
        permission_at m b ofs Cur = permission_at m' b ofs Cur.
    Proof.
      intros.
      generalize dependent m.
      induction es as [|ev es]; intros.
      - inversion Helim; subst; auto.
      - simpl in Helim.
        destruct ev;
          try (destruct Helim as [m'' [Haction Helim']]).
        + pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Haction b ofs) as Heq.
          do 2 rewrite getCurPerm_correct in Heq.
          rewrite Heq.
          rewrite Heq in Hperm.
          eapply IHes; eauto.
          eapply Mem.storebytes_valid_block_1; eauto.
        + destruct Helim; eauto.
        + pose proof (MemoryLemmas.permission_at_alloc_1
                        _ _ _ _ _ _ ofs Haction Hvalid Cur) as Heq.
          rewrite Heq. rewrite Heq in Hperm.
          eapply IHes; eauto.
          eapply Mem.valid_block_alloc; eauto.
        + assert (Hlt: ~ Mem.perm m b ofs Cur Freeable).
          { intros Hcontra.
            unfold Mem.perm in Hcontra.
            simpl in Hperm. unfold permission_at in *.
            destruct ((Mem.mem_access m) !! b ofs Cur); inv Hperm;
              simpl in Hcontra; inversion Hcontra.
          }
          pose proof (MemoryLemmas.permission_at_free_list_1 _ _ _ _ _

    Definition in_free_list (b : block) ofs xs :=
      exists x, List.In x xs /\
           let '(b', lo, hi) := x in
           b = b' /\
           (lo <= ofs < hi)%Z.

    Fixpoint in_free_list_trace (b : block) ofs es :=
      match es with
      | event_semantics.Free l :: es =>
        in_free_list b ofs l \/ in_free_list_trace b ofs es
      | _ :: es =>
        in_free_list_trace b ofs es
      | [:: ] =>
        False
      end.

    Lemma ev_elim_free_1:
      forall m ev m' b ofs,
        ev_elim m ev m' ->
        in_free_list_trace b ofs ev ->
        (permission_at m b ofs Cur = Some Freeable \/
         ~ Mem.valid_block m b) /\

    Lemma ev_elim_free_2:
      forall m ev m' b ofs,
        ev_elim m ev m' ->
        ~ in_free_list_trace b ofs ev ->
        Mem.perm_order'' (permission_at m' b ofs Cur) (permission_at m b ofs Cur).

    Lemma free_list_cases:
      forall l m m' b ofs
        (Hfree: Mem.free_list m l = Some m'),

    Lemma elim_perm_valid_block:
      forall m T m' b ofs ofs' bytes
        (Hintv: Intv.In ofs' (ofs, (ofs + Z.of_nat (length bytes))%Z))
        (Helim: ev_elim m T m')
        (Hvalid: Mem.valid_block m b),
        
        (permission_at m b ofs' Cur = Some Freeable /\ permission_at m' b ofs' Cur = None) \/
        
        ((List.In (event_semantics.Write b ofs bytes) T ->
          Mem.perm_order'' (permission_at m b ofs' Cur) (Some Writable) /\
          Mem.perm_order'' (permission_at m' b ofs' Cur) (Some Writable)) /\
         (forall n,
             List.In (event_semantics.Read b ofs n bytes) T ->
             Mem.perm_order'' (permission_at m b ofs' Cur) (Some Readable) /\
             Mem.perm_order'' (permission_at m' b ofs' Cur) (Some Readable))).
    Proof.
      intros.
      generalize dependent m'.
      generalize dependent m.
      induction T as [| ev]; intros.
      - inversion Helim; subst.
        right; split; intros; simpl in H; by exfalso.
      - simpl in Helim.
        destruct ev.
        + destruct Helim as [m'' [Hstore Helim']].
          eapply Mem.storebytes_valid_block_1 in Hvalid; eauto.
          destruct (IHT _ Hvalid _ Helim') as [? | [Hwrite Hread]].
          * pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Hstore b ofs') as Heq.
            rewrite! getCurPerm_correct in Heq.
            rewrite Heq.
            left; assumption.
          * destruct (event_semantics.in_free_list_trace_dec b ofs' T) as [Hfree | HnotFree].
            { 
              eapply ev_elim_free_1 in Hfree; eauto.
              destruct Hfree as [[? | ?] [? [? ?]]]; try (by exfalso).
              left.
              pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Hstore b ofs') as Heq.
              rewrite! getCurPerm_correct in Heq.
              rewrite Heq. now eauto.
            }
            { 
              right.
              eapply ev_elim_free_2 in HnotFree; eauto.
              pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Hstore b ofs') as Heq.
              rewrite! getCurPerm_correct in Heq.
              rewrite <- Heq in HnotFree.
              clear Heq.
              split.
              - intros Hin.
                simpl in Hin.
                destruct Hin as [Heq | Hin].
                + inv Heq.
                  apply Mem.storebytes_range_perm in Hstore.
                  specialize (Hstore _ Hintv).
                  unfold Mem.perm, permission_at in *.
                  rewrite <- po_oo.
                  split;
                    now eauto using po_trans.
                + specialize (Hwrite Hin).
                  pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Hstore b ofs') as Heq.
                  rewrite! getCurPerm_correct in Heq.
                  rewrite Heq.
                  destruct Hwrite;
                    split;
                    now assumption.
              - intros n Hin.
                simpl in Hin.
                destruct Hin as [Heq | Hin].
                discriminate.
                specialize (Hread _ Hin).
                pose proof (MemoryLemmas.mem_storebytes_cur _ _ _ _ _ Hstore b ofs') as Heq.
                rewrite! getCurPerm_correct in Heq.
                rewrite Heq.
                destruct Hread; split;
                  now assumption.
            }
        + 
          destruct Helim as [Hload Helim'].
          destruct (IHT _ Hvalid _ Helim') as [? | [Hwrite Hread]].
          * left; assumption.
          * destruct (event_semantics.in_free_list_trace_dec b ofs' T) as [Hfree | HnotFree].
            { 
              eapply ev_elim_free_1 in Hfree; eauto.
              destruct Hfree as [[? | ?] [? [? ?]]]; try (by exfalso).
              left.
              now eauto.
            }
            { 
              right.
              eapply ev_elim_free_2 in HnotFree; eauto.
              split.
              - intros Hin.
                simpl in Hin.
                destruct Hin as [Heq | Hin];
                  first by discriminate.
                destruct (Hwrite Hin).
                split;
                  now assumption.
              - intros n0 Hin.
                simpl in Hin.
                destruct Hin as [Heq | Hin].
                + inv Heq.
                  pose proof (Mem.loadbytes_length _ _ _ _ _ Hload) as Hlength.
                  destruct (zle n0 0).
                  * exfalso.
                    eapply Mem.loadbytes_empty with (m := m) (b := b) (ofs := ofs) in l.
                    rewrite Hload in l. inv l.
                    unfold Intv.In in Hintv. simpl in Hintv.
                    rewrite Z.add_0_r in Hintv.
                    ssromega.
                  * rewrite Hlength in Hintv.
                    erewrite nat_of_Z_eq in Hintv by omega.
                    apply Mem.loadbytes_range_perm in Hload.
                    specialize (Hload _ Hintv).
                    unfold Mem.perm, permission_at in *.
                    split;
                      now eauto using po_trans.
                + split; eapply Hread;
                    now eauto.
            }
        + 
          destruct Helim as [m'' [Halloc Helim']].
          pose proof (Mem.valid_block_alloc _ _ _ _ _ Halloc _ Hvalid) as Hvalid'.
          destruct (IHT _ Hvalid' _ Helim') as [Heq | [Hwrite Hread]].
          * erewrite <- MemoryLemmas.permission_at_alloc_1 in Heq by eauto.
            left; eauto.
          * destruct (event_semantics.in_free_list_trace_dec b ofs' T) as [Hfree | HnotFree].
            { 
              eapply ev_elim_free_1 in Hfree; eauto.
              destruct Hfree as [[? | ?] [? [? ?]]]; try (by exfalso).
              left.
              erewrite MemoryLemmas.permission_at_alloc_1 by eauto.
              now eauto using po_trans.
            }
            { 
              right.
              eapply ev_elim_free_2 in HnotFree; eauto.
              split; intros; simpl in H;
                destruct H; try (discriminate);
                  erewrite MemoryLemmas.permission_at_alloc_1 by eauto;

    Lemma free_list_valid_block:
      forall m m' l b,
        Mem.free_list m l = Some m' ->

    Lemma elim_perm_invalid_block:
      forall m T m' b ofs ofs' bytes
        (Hintv: Intv.In ofs' (ofs, (ofs + Z.of_nat (length bytes))%Z))
        (Helim: ev_elim m T m')
        (Hinvalid: ~ Mem.valid_block m b),
        
        (List.In (event_semantics.Write b ofs bytes) T ->
         (permission_at m' b ofs' Cur = Some Freeable \/ permission_at m' b ofs' Cur = None)
         /\ Mem.valid_block m' b) /\
        (forall n,
            List.In (event_semantics.Read b ofs n bytes) T ->
            (permission_at m' b ofs' Cur = Some Freeable \/ permission_at m' b ofs' Cur =  None) /\ Mem.valid_block m' b).
    Proof.
      intros.
      generalize dependent m'.
      generalize dependent m.
      induction T as [| ev]; intros.
      - inversion Helim; subst.
        split; intros; simpl in H; by exfalso.
      - simpl in Helim.
        destruct ev.
        + destruct Helim as [m'' [Hstore Helim']].
          assert (Hinvalid'': ~ Mem.valid_block m'' b)
            by (intro Hcontra;
                eapply Mem.storebytes_valid_block_2 in Hcontra; eauto).
          destruct (IHT _ Hinvalid'' _ Helim') as [Hwrite Hread].
          split; [intros Hin | intros n Hin].
          * simpl in Hin.
            destruct Hin as [Heq | Hin]; eauto.
            inv Heq.
            exfalso.
            apply Mem.storebytes_range_perm in Hstore.
            unfold Mem.range_perm in Hstore.
            specialize (Hstore _ Hintv).
            apply Mem.nextblock_noaccess with (k := Cur) (ofs := ofs') in Hinvalid.
            unfold Mem.perm in Hstore.
            rewrite Hinvalid in Hstore.
            simpl in Hstore.
            now assumption.
          * simpl in Hin; destruct Hin; [discriminate | now eauto].
        + destruct Helim as [Hload Helim'].
          destruct (IHT _ Hinvalid _ Helim') as [Hwrite Hread].
          split.
          * intros Hin; simpl in Hin.
            destruct Hin as [Heq | Hin];
              [discriminate | now eauto].
          * intros ? Hin; simpl in Hin.
            destruct Hin as [Heq | Hin].
            exfalso.
            inv Heq.
            assert (Hlength: nat_of_Z n0 = length bytes)
              by (apply Mem.loadbytes_length in Hload; auto).
            apply Mem.loadbytes_range_perm in Hload.
            rewrite <- Hlength in Hintv.
            specialize (Hload ofs').
            assert (Hintv': (ofs <= ofs' < ofs + n0)%Z).
            { rewrite nat_of_Z_max in Hintv.
              destruct (Z.max_dec n0 0);
                erewrite e in *;
                eauto.
              destruct Hintv.
              simpl in *. ssromega.
            }
            specialize (Hload Hintv').
            apply Mem.nextblock_noaccess with (k := Cur) (ofs := ofs') in Hinvalid.
            unfold Mem.perm in Hload.
            rewrite Hinvalid in Hload. simpl in Hload; now auto.
            now eauto.
        + destruct Helim as [m'' [Halloc Helim']].
          destruct (Pos.eq_dec b b0); subst.
          { destruct (zle lo ofs').
            - destruct (zlt ofs' hi).
              + assert (Hfreeable:permission_at m'' b0 ofs' Cur = Some Freeable)
                  by (eapply MemoryLemmas.permission_at_alloc_2; eauto).
                destruct (event_semantics.in_free_list_trace_dec b0 ofs' T) as [Hfree | HnotFree].
                * eapply ev_elim_free_1 in Hfree; eauto.
                  destruct Hfree as [[? | ?] [Hfreed [? ?]]]; try (by exfalso);
                    split; intros; eauto.
                * eapply ev_elim_free_2 in HnotFree; eauto.
                  rewrite Hfreeable in HnotFree.
                  destruct (permission_at m' b0 ofs' Cur) eqn:Hfreeable'; simpl in HnotFree;
                    try by exfalso.
                  assert (p = Freeable)
                    by (inv HnotFree; auto); subst.
                  split; intros; split;
                    now eauto using ev_elim_valid_block, Mem.valid_new_block.
              + assert (Hfreeable:permission_at m'' b0 ofs' Cur = None)
                  by (eapply MemoryLemmas.permission_at_alloc_3; eauto).
                pose proof (Mem.valid_new_block _ _ _ _ _ Halloc) as Hvalid.
                pose proof (ev_elim_stable _ ofs' _ Hvalid ltac:(rewrite Hfreeable; simpl; now constructor) Helim') as Heq.
                rewrite <- Heq.
                rewrite Hfreeable.
                split; intros; now eauto using ev_elim_valid_block.
            - assert (Hfreeable:permission_at m'' b0 ofs' Cur = None).
                by (eapply MemoryLemmas.permission_at_alloc_3; eauto; left; omega).

    Lemma data_permission_decrease_step:
      forall U tr tp m U' tp' m' tr' tidn b ofs
        (cnt: containsThread tp tidn)
        (cnt': containsThread tp' tidn)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: Mem.perm_order'' ((getThreadR cnt).1 !! b ofs) (Some Readable))

    Lemma data_permission_decrease_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: Mem.perm_order'' ((getThreadR cnti).1 !! b ofs) (Some Readable))

    Lemma lock_permission_decrease_step:
      forall U tr tp m U' tp' m' tr' tidn b ofs
        (cnt: containsThread tp tidn)
        (cnt': containsThread tp' tidn)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: Mem.perm_order'' ((getThreadR cnt).2 !! b ofs) (Some Readable))

    Lemma lock_permission_decrease_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: Mem.perm_order'' ((getThreadR cnti).2 !! b ofs) (Some Readable))

    Lemma permission_decrease_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: (Mem.perm_order'' ((getThreadR cnti).1 !! b ofs) (Some Readable) /\

    Lemma data_permission_increase_step:
      forall U tr tp m U' tp' m' tr' tidn b ofs
        (cnt: containsThread tp tidn)
        (cnt': containsThread tp' tidn)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm': Mem.perm_order'' ((getThreadR cnt').1 !! b ofs) (Some Readable))

    Lemma data_permission_increase_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm': Mem.perm_order'' ((getThreadR cntj).1 !! b ofs) (Some Readable))

    Lemma lock_permission_increase_step:
      forall U tr tp m U' tp' m' tr' tidn b ofs
        (cnt: containsThread tp tidn)
        (cnt': containsThread tp' tidn)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm': Mem.perm_order'' ((getThreadR cnt').2 !! b ofs) (Some Readable))

    Lemma lock_permission_increase_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm': Mem.perm_order'' ((getThreadR cntj).2 !! b ofs) (Some Readable))

    Lemma permission_increase_execution:
      forall U tr tpi mi U' tr' tpj mj
        b ofs tidn
        (cnti: containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: (Mem.perm_order'' ((getThreadR cntj).1 !! b ofs) (Some Readable) /\

    Lemma lockRes_mklock_step:
      forall U tr tp m U' tp' m' tr' laddr rmap
        (Hres: lockRes tp laddr = None)
        (Hres': lockRes tp' laddr = Some rmap)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m'),
      exists ev,
        tr' = [:: ev] /\ action ev = Mklock /\
        location ev = Some (laddr, lksize.LKSIZE_nat) /\

    Lemma lockRes_mklock_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapj
        (Hres: lockRes tpi laddr = None)
        (Hres': lockRes tpj laddr = Some rmapj)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj),
      exists tr_pre evu U'' U''' tp_pre m_pre tp_mk m_mk,
        multi_step (U, tr, tpi) mi (U'', tr ++ tr_pre, tp_pre) m_pre /\
        MachStep (U'', tr ++ tr_pre, tp_pre) m_pre
                 (U''', tr ++ tr_pre ++ [:: evu], tp_mk) m_mk /\
        multi_step (U''', tr ++ tr_pre ++ [:: evu], tp_mk) m_mk
                   (U', tr ++ tr',tpj) mj /\
        action evu = Mklock /\
        location evu = Some (laddr, lksize.LKSIZE_nat) /\

    Lemma lockRes_freelock_step:
      forall U tr tp m U' tp' m' tr' laddr rmap
        (Hres: lockRes tp laddr = Some rmap)
        (Hres': lockRes tp' laddr = None)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m'),
      exists ev,
        tr' = [:: ev] /\ action ev = Freelock /\
        location ev = Some (laddr, lksize.LKSIZE_nat) /\

    Lemma lockRes_freelock_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapi
        (Hres: lockRes tpi laddr = Some rmapi)
        (Hres': lockRes tpj laddr = None)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj),
      exists tr_pre evu U'' U''' tp_pre m_pre tp_mk m_mk,
        multi_step (U, tr, tpi) mi (U'', tr ++ tr_pre, tp_pre) m_pre /\
        MachStep (U'', tr ++ tr_pre, tp_pre) m_pre
                 (U''', tr ++ tr_pre ++ [:: evu], tp_mk) m_mk /\
        multi_step (U''', tr ++ tr_pre ++ [:: evu], tp_mk) m_mk
                   (U', tr ++ tr',tpj) mj /\
        action evu = Freelock /\
        location evu = Some (laddr, lksize.LKSIZE_nat) /\

    Lemma lockRes_data_permission_decrease_step:
      forall U tr tp m U' tp' m' tr' laddr rmap rmap' b ofs
        (Hres: lockRes tp laddr = Some rmap)
        (Hres': lockRes tp' laddr = Some rmap')
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: Mem.perm_order'' (rmap.1 !! b ofs) (Some Readable))

    Lemma lockRes_data_permission_decrease_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapi rmapj b ofs
        (Hres: lockRes tpi laddr = Some rmapi)
        (Hres': lockRes tpj laddr = Some rmapj)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: Mem.perm_order'' (rmapi.1 !! b ofs) (Some Readable))

    Lemma lockRes_lock_permission_decrease_step:
      forall U tr tp m U' tp' m' tr' laddr rmap rmap' b ofs
        (Hres: lockRes tp laddr = Some rmap)
        (Hres': lockRes tp' laddr = Some rmap')
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: Mem.perm_order'' (rmap.2 !! b ofs) (Some Readable))

    Lemma lockRes_lock_permission_decrease_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapi rmapj b ofs
        (Hres: lockRes tpi laddr = Some rmapi)
        (Hres': lockRes tpj laddr = Some rmapj)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: Mem.perm_order'' (rmapi.2 !! b ofs) (Some Readable))

    Lemma lockRes_permission_decrease_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapi rmapj b ofs
        (Hres: lockRes tpi laddr = Some rmapi)
        (Hres': lockRes tpj laddr = Some rmapj)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: (Mem.perm_order'' (rmapi.1 !! b ofs) (Some Readable) /\

    Lemma lockRes_data_permission_increase_step:
      forall U tr tp m U' tp' m' tr' laddr rmap rmap' b ofs
        (Hres: lockRes tp laddr = Some rmap)
        (Hres': lockRes tp' laddr = Some rmap')
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: ~ Mem.perm_order'' (rmap.1 !! b ofs) (Some Readable))

    Lemma lockRes_lock_permission_increase_step:
      forall U tr tp m U' tp' m' tr' laddr rmap rmap' b ofs
        (Hres: lockRes tp laddr = Some rmap)
        (Hres': lockRes tp' laddr = Some rmap')
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hperm: ~ Mem.perm_order'' (rmap.2 !! b ofs) (Some Readable))

    Fixpoint lockRes_data_permission_add_execution U
             U' tr tpi mi tpj mj tr' laddr rmapj b ofs
             (Hres: lockRes tpi laddr = None)
             (Hres': lockRes tpj laddr = Some rmapj)
             (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
             (Hperm': Mem.perm_order'' (rmapj.1 !! b ofs) (Some Readable)) {struct U}:

    Fixpoint lockRes_lock_permission_add_execution U
             U' tr tpi mi tpj mj tr' laddr rmapj b ofs
             (Hres: lockRes tpi laddr = None)
             (Hres': lockRes tpj laddr = Some rmapj)
             (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
             (Hperm': Mem.perm_order'' (rmapj.2 !! b ofs) (Some Readable)) {struct U}:

    Lemma lockRes_permission_increase_execution:
      forall U tr tpi mi U' tpj mj tr' laddr rmapi rmapj b ofs
        (Hres: lockRes tpi laddr = Some rmapi)
        (Hres': lockRes tpj laddr = Some rmapj)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj)
        (Hperm: (~ Mem.perm_order'' (rmapi.1 !! b ofs) (Some Readable) /\

    Lemma thread_spawn_step:
      forall U tr tp m U' tp' m' tr' tidn
        (cnt: ~ containsThread tp tidn)
        (cnt': containsThread tp' tidn)
        (Hstep: MachStep (U, tr, tp) m (U', tr ++ tr', tp') m'),
      exists ev,
        tr' = [:: ev] /\ action ev = Spawn.

    Lemma thread_spawn_execution:
      forall U tr tpi mi U' tr' tpj mj
        tidn
        (cnti: ~ containsThread tpi tidn)
        (cntj: containsThread tpj tidn)
        (Hexec: multi_step (U, tr, tpi) mi (U', tr ++ tr', tpj) mj),
      exists tr_pre evu U'' U''' tp_pre m_pre tp_inc m_inc,
        multi_step (U, tr, tpi) mi (U'', tr ++ tr_pre, tp_pre) m_pre /\
        MachStep (U'', tr ++ tr_pre, tp_pre) m_pre
                 (U''', tr ++ tr_pre ++ [:: evu], tp_inc) m_inc /\
        multi_step (U''', tr ++ tr_pre ++ [:: evu], tp_inc) m_inc
                   (U', tr ++ tr',tpj) mj /\
        action evu = Spawn.
  End FineGrainedExecutions.

  Section SCExecutions.

    Context
      {Sem : Semantics}
      {initU : seq.seq nat}
      {SemAx : CoreLanguage.SemAxioms}
      {SemD : CoreLanguage.SemDet}.

    Existing Instance BareMachine.resources.
    Existing Instance HybridFineMachine.scheduler.
    Existing Instance OrdinalPool.OrdinalThreadPool.
    Existing Instance BareMachine.BareMachineSig.
    Existing Instance BareDilMem.
    Existing Instance bareMach.

    Opaque containsThread mem_compatible.
    Lemma start_thread_det:
      forall tp m tid (cnt: containsThread tp tid) tp' m' tp'' m''
        (Hstart: start_thread m cnt tp' m')
        (Hstart': start_thread m cnt tp'' m''),
        tp' = tp'' /\ m' = m''.
    
    Lemma sync_step_det:
      forall tp m tid (cnt: containsThread tp tid) tp' m' tp'' m'' ev ev'
        (Hcmpt: mem_compatible tp m)
        (Hstep: @BareMachine.syncStep _ false _ tp m cnt Hcmpt tp' m' ev)
    
    Lemma suspend_thread_det:
      forall tp m tid (cnt: containsThread tp tid) tp' tp''
        (Hsuspend: suspend_thread m cnt tp')
        (Hsuspend': suspend_thread m cnt tp''),
        tp' = tp''.

    Lemma step_thread_det:
      forall tp m tid (cnt: containsThread tp tid) tp' m' tp'' m'' ev ev'
        (Hcmpt: mem_compatible tp m)
        (Hstep: threadStep cnt Hcmpt tp' m' ev)
        (Hstep': threadStep cnt Hcmpt tp'' m'' ev'),
        tp' = tp'' /\ m' = m'' /\ ev = ev'.
    
    Lemma resume_thread_det:
      forall tp m tid (cnt: containsThread tp tid) tp' tp''
        (Hresume: resume_thread m cnt tp')
        (Hresume': resume_thread m cnt tp''),
        tp' = tp''.
    
    Lemma bareStep_det:
      forall U tr tp m U' tr' tp' m' U'' tr'' tp'' m''
        (Hstep: MachStep (U, tr, tp) m
                         (U', tr', tp') m')
        (Hstep': MachStep (U, tr, tp) m
                          (U'', tr'', tp'') m''),
        U' = U'' /\ tr' = tr'' /\ tp' = tp'' /\ m' = m''.

    Lemma bare_execution_det:
      forall st m st' m' st'' m''
        (Hstep: fine_execution st m st' m')
        (Hstep': fine_execution st m st'' m''),
        st' = st'' /\ m' = m''.

    End SCExecutions.
    
End Executions. *)

Require Import VST.concurrency.sc_drf.spinlocks.
(* VST.concurrency.sc_drf.spinlocks:
Require Import compcert.lib.Axioms.
Require Import compcert.lib.Coqlib.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.

Require Import VST.concurrency.common.pos.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Events.
Require Import compcert.common.Memory.
Require Import compcert.lib.Integers.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.tactics.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.permjoin_def.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.memory_lemmas.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.dry_machine_step_lemmas.
Require Import VST.concurrency.sc_drf.executions.
Require Import VST.msl.Coqlib2.

Set Bullet Behavior "None".
Set Bullet Behavior "Strict Subproofs".

Module SpinLocks.
  Import HybridMachine HybridMachineSig ThreadPool ThreadPoolWF
         CoreLanguage CoreLanguageDry AsmContext StepLemmas Executions.
  Import event_semantics.
  Import Events.
  
  Section SpinLocks.
    Context {Sem : Semantics}
            {SemAxioms: SemAxioms}
            {initU: seq nat}.
    Variable EM: ClassicalFacts.excluded_middle.

    Existing Instance OrdinalPool.OrdinalThreadPool.
    Existing Instance DryHybridMachine.DryHybridMachineSig.
    Existing Instance dryFineMach.
    Existing Instance bareMach.

    Existing Instance FineDilMem.
    Open Scope nat.
    
    Definition sameLocation ev1 ev2 :=
      match Events.location ev1, Events.location ev2 with
      | Some (b1, ofs1, size1), Some (b2, ofs2, size2) =>
        b1 = b2 /\ exists ofs, Intv.In ofs (ofs1, (ofs1 + Z.of_nat size1)%Z) /\
                         Intv.In ofs (ofs2, (ofs2 + Z.of_nat size2)%Z)
      | _,_ => False
      end.

    Definition caction (ev : Events.machine_event) :=
      match ev with
      | internal _ (event_semantics.Write _ _ _) => Some Write
      | internal _ (event_semantics.Read _ _ _ _) => Some Read
      | internal _ (event_semantics.Alloc _ _ _) => None
      | internal _ (event_semantics.Free _) => None
      | external _ (release _ _) => Some Release
      | external _ (acquire _ _) => Some Acquire
      | external _ (mklock _) => Some Mklock
      | external _ (freelock _) => Some Freelock
      | external _ (spawn _ _ _) => None
      | external _ (failacq _) => Some Failacq
      end.

    Definition competes (ev1 ev2 : Events.machine_event) : Prop :=
      thread_id ev1 <> thread_id ev2 /\ 
      sameLocation ev1 ev2 /\ 
      caction ev1 /\ 
      caction ev2 /\
      (is_internal ev1 ->
       is_internal ev2 ->
       
       action ev1 = Write \/ action ev2 =  Write) /\
      (is_external ev1 \/ is_external ev2 ->
              action ev1 = Mklock \/ action ev1 = Freelock
       \/ action ev2 = Mklock \/ action ev2 = Freelock).

    Definition spinlock_synchronized (tr : event_trace) :=
      forall (i j : nat) ev1 ev2,
        i < j ->
        List.nth_error tr i = Some ev1 ->
        List.nth_error tr j = Some ev2 ->
        competes ev1 ev2 ->
        (exists u v eu ev,
          i <= u < v /\ v < j /\
          List.nth_error tr u = Some eu /\
          List.nth_error tr v = Some ev /\
          action eu = Release /\ action ev = Acquire /\
          location eu = location ev) \/
        
        (exists u eu,
            i < u < j /\
            List.nth_error tr u = Some eu /\
            action eu = Spawn).

    Definition spinlock_clean (tr : event_trace) :=
      forall i j evi evj
        (Hij: i < j)
        (Hi: List.nth_error tr i = Some evi)
        (Hj: List.nth_error tr j = Some evj)
        (Hmklock: action evi = Mklock)
        (Hfreelock: forall u evu, i < u < j ->
                             List.nth_error tr u = Some evu ->
                             action evu <> Freelock \/
                             location evu <> location evi)
        (Hlocation: sameLocation evj evi),
        action evj <> Write /\ action evj <> Read.

    Notation fstep := ((corestep (AsmContext.fine_semantics initU))).

    Opaque containsThread getThreadR getThreadC t lockRes.
    
    Lemma fstep_clean:
      forall U U' tp m addr tr pre ev post tp' m' tidi
        (Hlock: lockRes tp addr)
        (HisLock: isLock tp addr)
        (Hlocation: sameLocation ev (external tidi (mklock addr)))
        (Hstep: fstep (U, tr, tp) m
                                  (U', tr ++ pre ++ [:: ev] ++ post, tp') m'),
        action ev <> Write /\ action ev <> Read.

    Notation multi_fstep := (@multi_step Sem FineDilMem _ DryHybridMachine.DryHybridMachineSig).
    
    Theorem fineConc_clean:
      forall U tr tp m tp' m'
        (Hexec: multi_fstep (U, [::], tp) m ([::], tr, tp') m'),
        spinlock_clean tr.

    Lemma maximal_competing:
      forall i j tr evi evj
        (Hij: i < j)
        (Hi: nth_error tr i = Some evi)
        (Hj: nth_error tr j = Some evj)
        (Hcompetes: competes evi evj),
      exists k evk, i <= k < j /\
               nth_error tr k = Some evk /\
               competes evk evj /\
               (forall k' evk', k < k' < j ->
                           nth_error tr k' = Some evk' ->
                           ~ competes evk' evj).

    Inductive raction ev : Prop :=
    | read: action ev = Read ->
            raction ev
    | acq: action ev = Acquire ->
           raction ev
    | rel: action ev = Release ->
           raction ev
    | facq: action ev = Failacq ->
            raction ev.

    Inductive waction ev : Prop:=
    | write: action ev = Write ->
             waction ev
    | mk: action ev = Mklock ->
          waction ev
    | fl: action ev = Freelock ->
          waction ev.

    Lemma compete_cases:
      forall evi evj
        (Hcompetes: competes evi evj),
        (raction evi /\ waction evj) \/
        (waction evi /\ caction evj).

    Lemma fstep_ev_perm:
      forall U tr tp m U' tr_pre tr_post tp' m' ev
        (Hstep: fstep (U, tr, tp) m (U', tr ++ tr_pre ++ [:: ev] ++ tr_post , tp') m'),
        (waction ev ->
         forall (cnt: containsThread tp (thread_id ev)) (cnt': containsThread tp' (thread_id ev)),
           match location ev with
           | Some (b, ofs, sz) =>
             forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat sz)%Z ->

    Lemma waction_caction:
      forall ev,
        waction ev -> caction ev.

    Lemma raction_caction:
      forall ev,
        raction ev -> caction ev.

    Lemma raction_waction:
      forall ev,
        raction ev -> ~ waction ev.

    Lemma waction_raction:
      forall ev,
        waction ev -> ~ raction ev.

    Lemma caction_location:
      forall ev,
        caction ev ->
        exists b ofs sz, location ev = Some (b, ofs, sz).

    Opaque containsThread.
    
    Lemma fineConc_step_synchronized:
      forall U0 U U'  tr tp0 m0 tp m tp' m' tr'
        (Hexec: multi_fstep (U0, [::], tp0) m0 (U, tr, tp) m)
        (Hstep: fstep (U, tr, tp) m (U', tr ++ tr', tp') m')
        (Hsynchronized: spinlock_synchronized tr),
        spinlock_synchronized (tr ++ tr').

     Theorem fineConc_spinlock_strong:
      forall U U0 U' tr tr' tp m tp0 m0 tp' m'
        (Hsynced: spinlock_synchronized tr)
        (Hexec0: multi_fstep (U0, [::], tp0) m0 (U, tr, tp) m)
        (Hexec: multi_fstep (U, tr, tp) m (U', tr ++ tr', tp') m'),
        spinlock_synchronized (tr ++ tr').

    Corollary fineConc_spinlock:
      forall U tr tp m tp' m'
        (Hexec: multi_fstep (U, [::], tp) m ([::], tr, tp') m'),
        spinlock_synchronized tr.

  End SpinLocks.
End SpinLocks. *)



Require Import VST.concurrency.common.threadPool.
(* VST.concurrency.common.threadPool:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.

Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.threads_lemmas.
Require Import compcert.lib.Axioms.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
Require Import VST.msl.Coqlib2.

Require Import VST.concurrency.common.lksize.

Set Implicit Arguments.

Inductive ctl {cT:Type} : Type :=
| Krun : cT -> ctl
| Kblocked : cT -> ctl
| Kresume : cT -> val -> ctl 
| Kinit : val -> val -> ctl. 

Definition EqDec: Type -> Type :=
  fun A : Type => forall a a' : A, {a = a'} + {a <> a'}.

Module ThreadPool.
  Section ThreadPool.

    Context {resources: Resources}.
    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Class ThreadPool :=
      { t : Type;
        mkPool : ctl -> res -> t;
        containsThread : t -> tid -> Prop;
        getThreadC : forall {tid tp}, containsThread tp tid -> ctl;
        getThreadR : forall {tid tp}, containsThread tp tid -> res;
        resourceList : t -> seq.seq res;
        lockGuts : t -> AMap.t lock_info;  
        lockSet : t -> access_map;         
        lockRes : t -> address -> option lock_info;
        addThread : t -> val -> val -> res -> t;
        updThreadC : forall {tid tp}, containsThread tp tid -> ctl -> t;
        updThreadR : forall {tid tp}, containsThread tp tid -> res -> t;
        updThread : forall {tid tp}, containsThread tp tid -> ctl -> res -> t;
        updLockSet : t -> address -> lock_info -> t;
        remLockSet : t -> address -> t;
        latestThread : t -> tid;
        lr_valid : (address -> option lock_info) -> Prop;
                find_thread_: t -> (ctl -> bool) -> option tid
        ; resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti)          
        ;  containsThread_dec_:
             forall i tp, {containsThread tp i} + { ~ containsThread tp i}

        ;  cnt_irr: forall t tid
                      (cnt1 cnt2: containsThread t tid),
            cnt1 = cnt2

        ;  cntAdd:
             forall {j tp} vf arg p,
               containsThread tp j ->
               containsThread (addThread tp vf arg p) j

        ;  cntAddLatest:
             forall {tp} vf arg p,
               containsThread (addThread tp vf arg p) (latestThread tp)

        ;  cntAdd':
             forall {j tp} vf arg p,
               containsThread (addThread tp vf arg p) j ->
               (containsThread tp j /\ j <> latestThread tp) \/ j = latestThread tp

        ;  cntUpdateC:
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread tp tid0->
               containsThread (updThreadC cnt c) tid0
        ;  cntUpdateC':
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread (updThreadC cnt c) tid0 ->
               containsThread tp tid0

        ;  cntUpdateR:
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread tp j->
               containsThread (updThreadR cnti r) j
        ;  cntUpdateR':
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread (updThreadR cnti r) j ->
               containsThread tp j

        ;  cntUpdate:
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread tp j ->
               containsThread (updThread cnti c p) j
        ;  cntUpdate':
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread (updThread cnti c p) j ->
               containsThread tp j

        ;  cntUpdateL:
             forall {j tp} add lf,
               containsThread tp j ->
               containsThread (updLockSet tp add lf) j
        ;  cntRemoveL:
             forall {j tp} add,
               containsThread tp j ->
               containsThread (remLockSet tp add) j

        ;  cntUpdateL':
             forall {j tp} add lf,
               containsThread (updLockSet tp add lf) j ->
               containsThread tp j
        ;  cntRemoveL':
             forall {j tp} add,
               containsThread (remLockSet tp add) j ->
               containsThread tp j

        ;  gsoThreadLock:
             forall {i tp} c p (cnti: containsThread tp i),
               lockSet (updThread cnti c p) = lockSet tp

        ;  gsoThreadCLock :
             forall {i tp} c (cnti: containsThread tp i),
               lockSet (updThreadC cnti c) = lockSet tp

        ;  gsoThreadRLock :
             forall {i tp} p (cnti: containsThread tp i),
               lockSet (updThreadR cnti p) = lockSet tp

        ;  gsoAddLock :
             forall tp vf arg p,
               lockSet (addThread tp vf arg p) = lockSet tp

        ;  gssAddRes :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadR cnt' = pmap

        ;  gssThreadCode :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCode :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadC cntj' = getThreadC cntj

        ;  gssThreadRes :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRes :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) (Hneq: i <> j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadR cntj' = getThreadR cntj

        ;  gssThreadCC :
             forall {tid tp} (cnt: containsThread tp tid) c'
               (cnt': containsThread (updThreadC cnt c') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCC :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadC cntj = getThreadC cntj'

        ;  getThreadCC :
             forall {tp} i j
               (cnti : containsThread tp i) (cntj : containsThread tp j)
               c' (cntj' : containsThread (updThreadC cnti c') j),
               getThreadC cntj' = if Nat.eq_dec i j then c' else getThreadC cntj

        ;  gssThreadRR :
             forall {tid tp} (cnt: containsThread tp tid) p'
               (cnt': containsThread (updThreadR cnt p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRR :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) p'
               (cntj': containsThread (updThreadR cnti p') j),
               getThreadR cntj = getThreadR cntj'

        ;  gThreadCR :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadR cntj' = getThreadR cntj

        ;  gThreadRC :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) p
               (cntj': containsThread (updThreadR cnti p) j),
               getThreadC cntj' = getThreadC cntj

        ;  gsoThreadCLPool :
             forall {i tp} c (cnti: containsThread tp i) addr,
               lockRes (updThreadC cnti c) addr = lockRes tp addr

        ;  gsoThreadLPool :
             forall {i tp} c p (cnti: containsThread tp i) addr,
               lockRes (updThread cnti c p) addr = lockRes tp addr

        ;  gsoAddLPool :
             forall tp vf arg p (addr : address),
               lockRes (addThread tp vf arg p) addr = lockRes tp addr

        ;  gLockSetRes :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadR cnti' = getThreadR cnti

        ;  gLockSetCode :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadC cnti' = getThreadC cnti

        ;  gssLockRes :
             forall tp addr pmap,
               lockRes (updLockSet tp addr pmap) addr = Some pmap

        ;  gsoLockRes:
             forall tp addr addr' pmap
               (Hneq: addr <> addr'),
               lockRes (updLockSet tp addr pmap) addr' =
               lockRes tp addr'

        ;  gssLockSet :
             forall tp b ofs rmap ofs',
               (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               (Maps.PMap.get b (lockSet (updLockSet tp (b, ofs) rmap)) ofs') = Some Writable

        ;  gsoLockSet_1 :
             forall tp b ofs ofs'  pmap
               (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),
               (Maps.PMap.get b (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b (lockSet tp)) ofs'
        ;  gsoLockSet_2 :
             forall tp b b' ofs ofs' pmap,
               b <> b' ->
               (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b' (lockSet tp)) ofs'

        ;  lockSet__updLockSet:
             forall tp i (pf: containsThread tp i) c pmap addr rmap,
               lockSet (updLockSet tp addr rmap) =
               lockSet (updLockSet (updThread pf c pmap) addr rmap)

        ;  updThread_updThreadC__comm :
             forall tp i j c pmap' c'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThreadC cnti c) j),
               updThreadC cnti' c = updThread cntj' c' pmap'

        ;  updThread_comm :
             forall tp i j c pmap c' pmap'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThread cnti c pmap) j),
               updThread cnti' c pmap = updThread cntj' c' pmap'

        ;  add_updateC_comm :
             forall tp i vf arg pmap c'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThreadC cnti c') vf arg pmap =
               updThreadC cnti' c'

        ;  add_update_comm :
             forall tp i vf arg pmap c' pmap'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThread cnti c' pmap') vf arg pmap =
               updThread cnti' c' pmap'

        ;  updThread_lr_valid :
             forall tp i (cnti: containsThread tp i) c' m',
               lr_valid (lockRes tp) ->
               lr_valid (lockRes (updThread cnti c' m'))

        ; lockSet_spec_2 :
            forall (js : t) (b : block) (ofs ofs' : Z),
              Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->
              lockRes js (b, ofs) -> (lockSet js) !! b ofs' = Some Memtype.Writable

        ;  lockSet_spec_3 :
             forall ds b ofs,
               (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
               (lockSet ds) !! b ofs = None

        ;  gsslockSet_rem : forall ds b ofs ofs0,
            lr_valid (lockRes ds) ->
            Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->
            isSome ((lockRes ds) (b,ofs)) ->  
            (lockSet (remLockSet ds (b, ofs))) !! b ofs0 =
            None

        ;  gsolockSet_rem1 : forall ds b ofs b' ofs',
            b  <> b' ->
            (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
            (lockSet ds)  !! b' ofs'

        ;  gsolockSet_rem2 : forall ds b ofs ofs',
            lr_valid (lockRes ds) ->
            ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->
            (lockSet (remLockSet ds (b, ofs))) !! b ofs' =
            (lockSet ds)  !! b ofs'
        ;  gsslockResUpdLock: forall js a res,
            lockRes (updLockSet js a res) a =
            Some res
        ;  gsolockResUpdLock : forall js loc a res,
            loc <> a ->
            lockRes (updLockSet js loc res) a =
            lockRes js a

        ;  gsslockResRemLock : forall js a,
            lockRes (remLockSet js a) a =
            None
        ;  gsolockResRemLock : forall js loc a,
            loc <> a ->
            lockRes (remLockSet js loc) a =
            lockRes js a

        ;  gRemLockSetCode :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadC cnti' = getThreadC cnti

        ;  gRemLockSetRes :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadR cnti' = getThreadR cnti

        ;  gsoAddCode :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j)
               (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadC cntj' = getThreadC cntj

        ;  gssAddCode :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadC cnt' = Kinit vf arg

        ;  gsoAddRes :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadR cntj' = getThreadR cntj

        ;  updLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l lmap,
             forall (cnti': containsThread (updLockSet ds l lmap) i),
               updLockSet
                 (@updThread _ ds cnti c map) l lmap =
               @updThread  _ (updLockSet ds l lmap) cnti' c map

        ;  remLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet
                 (updThread cnti c map)
                 l =
               updThread cnti' c map
        ;  remLock_updThreadC_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet (updThreadC cnti c) l = updThreadC cnti' c
      }.

  End ThreadPool.
End ThreadPool.

Module OrdinalPool.

  Definition empty_lset {lock_info}:AMap.t lock_info:=
    AMap.empty lock_info.

  Lemma find_empty:
    forall a l,
      @AMap.find a l empty_lset = None.

  Section OrdinalThreadPool.

    Context {resources: Resources}.

    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Record t := mk
                  { num_threads : pos
                    ; pool :> 'I_num_threads -> ctl
                    ; perm_maps : 'I_num_threads -> res
                    ; lset : AMap.t lock_info
                  }.

    Definition one_pos : pos.pos := pos.mkPos NPeano.Nat.lt_0_1.
    
    Definition mkPool c res :=
      mk one_pos
        (fun _ =>  c)
        (fun _ => res) 
        empty_lset.
    
    Definition lockGuts := lset.
    Definition lockSet (tp:t) := A2PMap (lset tp).

    Definition lockRes t : address -> option lock_info:=
      AMap.find (elt:=lock_info)^~ (lockGuts t).

    Definition lr_valid (lr: address -> option lock_info):=
      forall b ofs,
        match lr (b,ofs) with
        | Some r => forall ofs0:Z, (ofs < ofs0 < ofs+LKSIZE)%Z -> lr (b, ofs0) = None
        | _ => True
        end.

    Lemma is_pos: forall n, (0 < S n)%coq_nat.
    Definition mk_pos_S (n:nat):= mkPos (is_pos n).
    Lemma lt_decr: forall n m: nat, S n < m -> n < m.
    Program Fixpoint find_thread' {st:t}{filter:ctl -> bool} n (P: n < num_threads st) {struct n}:=
      if filter (@pool st (@Ordinal (num_threads st) n P))
      then Some n
      else match n with
           | S n' =>  find_thread' n' (lt_decr  n' _ P)
           | O => None
           end.
    Definition pos_pred (n:pos): nat.

    Program Definition find_thread (st:t)(filter:ctl -> bool): option tid:=
      @find_thread' st filter (pos_pred (num_threads st)) _ .

    Import Coqlib.

    Lemma lockSet_WorNE: forall js b ofs,
        (lockSet js) !! b ofs = Some Memtype.Writable \/

    Lemma lockSet_spec_2 :
      forall (js : t) (b : block) (ofs ofs' : Z),
        Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->

    Lemma lockSet_spec_1: forall js b ofs,
        lockRes js (b,ofs) ->
        (lockSet js) !! b ofs = Some Memtype.Writable.

    Open Scope nat_scope.

    Definition containsThread (tp : t) (i : NatTID.tid) : Prop:=
      i < num_threads tp.

    Definition containsThread_dec:
      forall i tp, {containsThread tp i} + { ~ containsThread tp i}.

    Definition getThreadC {i tp} (cnt: containsThread tp i) : ctl :=
      tp (Ordinal cnt).

    Definition unique_Krun' tp i :=
      ( forall j cnti q,
          @getThreadC j tp cnti = Krun q ->
          eq_nat_dec i j ).

    Definition is_running tp i:=
      exists cnti q, @getThreadC i tp cnti = Krun q.

    Lemma unique_runing_not_running:
      forall tp i,
        unique_Krun' tp i ->
        ~ is_running tp i ->
        forall j, unique_Krun' tp j.

    Definition getThreadR {i tp} (cnt: containsThread tp i) : res :=
      (perm_maps tp) (Ordinal cnt).

    Definition latestThread tp := n (num_threads tp).

    Definition addThread (tp : t) (vf arg : val) (pmap : res) : t :=
      let: new_num_threads := pos_incr (num_threads tp) in
      let: new_tid := ordinal_pos_incr (num_threads tp) in
      mk new_num_threads
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => Kinit vf arg
            | Some n' => tp n'
            end)
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => pmap
            | Some n' => (perm_maps tp) n'
            end)
         (lset tp).

    Definition updLockSet tp (add:address) (lf:lock_info) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.add add lf (lockGuts tp)).

    Definition remLockSet tp  (add:address) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.remove add (lockGuts tp)).

    Definition updThreadC {tid tp} (cnt: containsThread tp tid) (c' : ctl) : t :=
      mk (num_threads tp)
         (fun n => if n == (Ordinal cnt) then c' else (pool tp)  n)
         (perm_maps tp)
         (lset tp).

    Definition updThreadR {tid tp} (cnt: containsThread tp tid)
               (pmap' : res) : t :=
      mk (num_threads tp) (pool tp)
         (fun n =>
            if n == (Ordinal cnt) then pmap' else (perm_maps tp) n)
         (lset tp).

    Definition updThread {tid tp} (cnt: containsThread tp tid) (c' : ctl)
               (pmap : res) : t :=
      mk (num_threads tp)
         (fun n =>
            if n == (Ordinal cnt) then c' else tp n)
         (fun n =>
            if n == (Ordinal cnt) then pmap else (perm_maps tp) n)
         (lset tp).

    Lemma cnt_irr: forall t tid
                     (cnt1 cnt2: containsThread t tid),
        cnt1 = cnt2.

    Lemma numUpdateC :
      forall {tid tp} (cnt: containsThread tp tid) c,
        num_threads tp =  num_threads (updThreadC cnt c).

    Lemma cntUpdateC :
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread tp tid0 ->
        containsThread (updThreadC cnt c) tid0.
    Lemma cntUpdateC':
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread (updThreadC cnt c) tid0 ->
        containsThread tp tid0.

    Lemma cntUpdateR:
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread tp j->
        containsThread (updThreadR cnti r) j.

    Lemma cntUpdateR':
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread (updThreadR cnti r) j ->
        containsThread tp j.

    Lemma cntUpdate :
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread tp j ->
        containsThread (updThread cnti c p) j.

    Lemma cntUpdate':
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread (updThread cnti c p) j ->
        containsThread tp j.

    Lemma cntUpdateL:
      forall {j tp} add lf,
        containsThread tp j ->
        containsThread (updLockSet tp add lf) j.
    Lemma cntRemoveL:
      forall {j tp} add,
        containsThread tp j ->
        containsThread (remLockSet tp add) j.

    Lemma cntUpdateL':
      forall {j tp} add lf,
        containsThread (updLockSet tp add lf) j ->
        containsThread tp j.
    Lemma cntRemoveL':
      forall {j tp} add,
        containsThread (remLockSet tp add) j ->
        containsThread tp j.

    Lemma cntAdd:
      forall {j tp} vf arg p,
        containsThread tp j ->
        containsThread (addThread tp vf arg p) j.

    Lemma cntAddLatest:
      forall {tp} vf arg p,
        containsThread (addThread tp vf arg p) (latestThread tp).

    Lemma cntAdd':
      forall {j tp} vf arg p,
        containsThread (addThread tp vf arg p) j ->
        (containsThread tp j /\ j <> num_threads tp) \/ j = num_threads tp.

    Lemma contains_add_latest: forall ds p a r,
        containsThread (addThread ds p a r)
                       (latestThread ds).

    Lemma updLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l lmap,
      forall (cnti': containsThread (updLockSet ds l lmap) i),
        updLockSet
          (@updThread _ ds cnti c map) l lmap =
        @updThread _ (updLockSet ds l lmap) cnti' c map.
    Lemma remLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l,
      forall (cnti': containsThread (remLockSet ds l) i),
        remLockSet
          (updThread cnti c map)
          l =
        updThread cnti' c map.

    Lemma remLock_updThreadC_comm :
      forall ds i (cnti: containsThread ds i) c l
        (cnti': containsThread (remLockSet ds l) i),
        remLockSet (updThreadC cnti c) l = updThreadC cnti' c.

    Set Bullet Behavior "None".
    Set Bullet Behavior "Strict Subproofs".

    Lemma gsslockResUpdLock: forall js a res,
        lockRes (updLockSet js a res) a =
        Some res.

    Ltac address_ordered_auto :=
      auto; repeat match goal with
                   | H: AddressOrdered.eq ?A ?A |- _ => clear H
                   | H: AddressOrdered.eq ?A ?B |- _ => hnf in H; subst A
                   | H: ?A <> ?A |- _ => contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?A |- _ =>
                     apply AddressOrdered.lt_not_eq in H; contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?B, H': AddressOrdered.lt ?B ?A |- _ =>
                     contradiction (AddressOrdered.lt_not_eq (AddressOrdered.lt_trans H H')); reflexivity
                   end.

    Lemma gsolockResUpdLock: forall js loc a res,
        loc <> a ->
        lockRes (updLockSet js loc res) a =
        lockRes js a.

    Lemma gsslockResRemLock: forall js a,
        lockRes (remLockSet js a) a =
        None.

    Lemma gsolockResRemLock: forall js loc a,
        loc <> a ->
        lockRes (remLockSet js loc) a =
        lockRes js a.

    Lemma gsoThreadLock:
      forall {i tp} c p (cnti: containsThread tp i),
        lockSet (updThread cnti c p) = lockSet tp.

    Lemma gsoThreadCLock:
      forall {i tp} c (cnti: containsThread tp i),
        lockSet (updThreadC cnti c) = lockSet tp.

    Lemma gsoThreadRLock:
      forall {i tp} p (cnti: containsThread tp i),
        lockSet (updThreadR cnti p) = lockSet tp.

    Lemma gsoAddLock:
      forall tp vf arg p,
        lockSet (addThread tp vf arg p) = lockSet tp.

    Lemma PX_in_rev:
      forall elt a m, AMap.Raw.PX.In (elt:=elt) a m <-> AMap.Raw.PX.In a (rev m).

    Import SetoidList.
    Arguments InA {A}{eqA} x _.
    Arguments AMap.In {elt} x m.

    Lemma lockRes_range_dec: forall tp b ofs,
        { (exists z, z <= ofs < z+LKSIZE /\ lockRes tp (b,z) )%Z  } + {(forall z, z <= ofs < z+LKSIZE -> lockRes tp (b,z) = None)%Z }.

    Lemma lockSet_spec_3:
      forall ds b ofs,
        (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
        (lockSet ds) !! b ofs = None.

    Lemma gsslockSet_rem: forall ds b ofs ofs0,
        lr_valid (lockRes ds) ->
        Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gsolockSet_rem1: forall ds b ofs b' ofs',
        b  <> b' ->
        (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
        (lockSet ds)  !! b' ofs'.

    Lemma gsolockSet_rem2: forall ds b ofs ofs',
        lr_valid (lockRes ds) ->
        ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gssThreadCode {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadC cnt' = c'.

    Lemma eq_op_false: forall A i j, i <>j -> @eq_op A i j = false.

    Lemma gsoThreadCode:
      forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
        (cntj: containsThread tp j) c' p'
        (cntj': containsThread (updThread cnti c' p') j),
        getThreadC cntj' = getThreadC cntj.

    Lemma gssThreadRes {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRes {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) (Hneq: i <> j) c' p'
          (cntj': containsThread (updThread cnti c' p') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gssThreadCC {tid tp} (cnt: containsThread tp tid) c'
          (cnt': containsThread (updThreadC cnt c') tid) :
      getThreadC cnt' = c'.

    Lemma gsoThreadCC {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadC cntj = getThreadC cntj'.

    Lemma getThreadCC
          {tp} i j
          (cnti : containsThread tp i) (cntj : containsThread tp j)
          c' (cntj' : containsThread (updThreadC cnti c') j):
      getThreadC cntj' = if eq_nat_dec i j then c' else getThreadC cntj.

    Lemma gssThreadRR {tid tp} (cnt: containsThread tp tid) p'
          (cnt': containsThread (updThreadR cnt p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRR {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) p'
          (cntj': containsThread (updThreadR cnti p') j) :
      getThreadR cntj = getThreadR cntj'.

    Lemma gThreadCR {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gThreadRC {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) p
          (cntj': containsThread (updThreadR cnti p) j) :
      getThreadC cntj' = getThreadC cntj.

    Lemma unlift_m_inv :
      forall tp i (Htid : i < (num_threads tp).+1) ord

    Lemma gssAddRes:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadR cnt' = pmap.

    Lemma gsoAddRes:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadR cntj' = getThreadR cntj.

    Lemma gssAddCode:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadC cnt' = Kinit vf arg.

    Lemma gsoAddCode:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j)
        (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadC cntj' = getThreadC cntj.

    Lemma add_update_comm:
      forall tp i vf arg pmap c' pmap'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThread cnti c' pmap') vf arg pmap =
        updThread cnti' c' pmap'.

    Lemma add_updateC_comm:
      forall tp i vf arg pmap c'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThreadC cnti c') vf arg pmap =
        updThreadC cnti' c'.

    Lemma updThread_comm :
      forall tp  i j c pmap c' pmap'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThread cnti c pmap) j),
        updThread cnti' c pmap = updThread cntj' c' pmap'.

    Lemma updThread_updThreadC_comm :
      forall tp i j c pmap' c'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThreadC cnti c) j),
        updThreadC cnti' c = updThread cntj' c' pmap'.

    Lemma updThread_same :
      forall tp i (cnti : containsThread tp i),
      updThread cnti (getThreadC cnti) (getThreadR cnti) = tp.

    Lemma updThread_twice :
      forall tp i (cnti : containsThread tp i) c c' r r'
        (cnti' : containsThread (updThread cnti c r) i),
      updThread cnti' c' r' = updThread cnti c' r'.

    Lemma updThreadRC : forall tp i (cnti : containsThread tp i) c,
      updThread cnti c (getThreadR cnti) = updThreadC cnti c.

    Lemma gsoThreadCLPool:
      forall {i tp} c (cnti: containsThread tp i) addr,
        lockRes (updThreadC cnti c) addr = lockRes tp addr.

    Lemma gsoThreadLPool:
      forall {i tp} c p (cnti: containsThread tp i) addr,
        lockRes (updThread cnti c p) addr = lockRes tp addr.

    Lemma gsoAddLPool:
      forall tp vf arg p (addr : address),
        lockRes (addThread tp vf arg p) addr = lockRes tp addr.

    Lemma gLockSetRes:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gLockSetCode:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetCode:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetRes:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gssLockRes:
      forall tp addr pmap,
        lockRes (updLockSet tp addr pmap) addr = Some pmap.

    Lemma gsoLockRes:
      forall tp addr addr' pmap
        (Hneq: addr <> addr'),
        lockRes (updLockSet tp addr pmap) addr' =
        lockRes tp addr'.

    Lemma gssLockSet:
      forall tp b ofs rmap ofs',
        (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->

    Lemma gsoLockSet_12 :
      forall tp b b' ofs ofs' pmap,
        ~ adr_range (b,ofs) LKSIZE (b',ofs') ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma gsoLockSet_1:
      forall tp b ofs ofs'  pmap
        (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),

    Lemma gsoLockSet_2 :
      forall tp b b' ofs ofs' pmap,
        b <> b' ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma lockSet_updLockSet:
      forall tp i (pf: containsThread tp i) c pmap addr rmap,
        lockSet (updLockSet tp addr rmap) =
        lockSet (updLockSet (updThread pf c pmap) addr rmap).

    Lemma updThread_lr_valid:
      forall tp i (cnti: containsThread tp i) c' m',
        lr_valid (lockRes tp) ->
        lr_valid (lockRes (updThread cnti c' m')).

    Lemma contains_iff_num:
      forall tp tp'
        (Hcnt: forall i, containsThread tp i <-> containsThread tp' i),
        num_threads tp = num_threads tp'.

    Lemma leq_stepdown:
      forall {m n},
        S n <= m -> n <= m.
    
    Lemma lt_sub:
      forall {m n},
        S n <= m ->
        m - (S n) <  m.

    Fixpoint containsList_upto_n (n m:nat): n <= m -> seq.seq (sigT (fun i => i < m)):=
      match n with
      | O => fun _ => nil
      | S n' => fun (H: S n' <= m) =>
                 (existT (fun i => i < m) (m-(S n')) (lt_sub H)) ::
                 (containsList_upto_n n' m) (leq_stepdown H)                                  
      end.

    Lemma containsList_upto_n_spec:
      forall m n (H: n <= m)
        i (cnti:  (fun i => i < m) (m - n + i)),
        i < n ->
        nth_error (containsList_upto_n n m H) i = Some (existT _ (m - n + i) (cnti)). 
    
    Definition containsList' (n:nat): seq.seq (sigT (fun i => i < n)):=
      containsList_upto_n n n (leq_refl n).

    Definition contains_from_ineq (tp:t):
        {i : tid & i < num_threads tp } -> {i : tid & containsThread tp i}:=
       fun (H : {i : tid & i < num_threads tp}) =>
         let (x, i) := H in existT (containsThread tp) x i.

    Definition containsList (tp:t): seq.seq (sigT (containsThread tp)):=
      map (contains_from_ineq tp) (containsList' (num_threads tp)).

    Lemma containsList'_spec: forall i n
            (cnti: (fun i => i < n) i),
            List.nth_error (containsList' n) i = Some (existT _ i (cnti)).

    Lemma containsList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (containsList tp) i = Some (existT _ i cnti).
      
    Definition indexed_contains tp:= (fun Ncontained: (sigT (containsThread tp)) =>
             let (i, cnti) := Ncontained in getThreadR cnti).
    
    Definition resourceList (tp:t): seq.seq res:=
      map (@indexed_contains tp)
          (containsList tp).

    Lemma resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti).
        
    Definition OrdinalThreadPool: ThreadPool.ThreadPool :=
      (@ThreadPool.Build_ThreadPool _ _
                                    t
                                    mkPool
                                    containsThread
                                    (@getThreadC) 
                                    (@getThreadR) 
                                    resourceList
                                    lockGuts
                                    lockSet
                                    (@lockRes) 
                                    addThread
                                    (@updThreadC) 
                                    (@updThreadR)
                                    (@updThread) 
                                    updLockSet 
                                    remLockSet 
                                    latestThread 
                                    lr_valid 
                                    
                                    find_thread
                                    resourceList_spec
                                    containsThread_dec
                                    
                                    cnt_irr
                                    (@cntAdd)
                                    (@cntAddLatest)
                                    (@cntAdd')
                                    (@cntUpdateC)
                                    (@cntUpdateC')
                                    (@cntUpdateR)
                                    (@cntUpdateR')
                                    (@cntUpdate)
                                    (@cntUpdate')
                                    (@cntUpdateL)
                                    (@cntRemoveL)
                                    (@cntUpdateL')
                                    (@cntRemoveL')
                                    (@gsoThreadLock)
                                    (@gsoThreadCLock)
                                    (@gsoThreadRLock)
                                    (@gsoAddLock)
                                    (@gssAddRes)
                                    (@gssThreadCode)
                                    (@gsoThreadCode)
                                    (@gssThreadRes)
                                    (@gsoThreadRes)
                                    (@gssThreadCC)
                                    (@gsoThreadCC)
                                    (@getThreadCC)
                                    (@gssThreadRR)
                                    (@gsoThreadRR)
                                    (@gThreadCR)
                                    (@gThreadRC)
                                    (@gsoThreadCLPool)
                                    (@gsoThreadLPool)
                                    (@gsoAddLPool)
                                    (@gLockSetRes)
                                    (@gLockSetCode)
                                    (@gssLockRes)
                                    (@gsoLockRes)
                                    (@gssLockSet)
                                    (@gsoLockSet_1)
                                    gsoLockSet_2
                                    lockSet_updLockSet
                                    updThread_updThreadC_comm
                                    updThread_comm
                                    add_updateC_comm
                                    add_update_comm
                                    updThread_lr_valid
                                    lockSet_spec_2
                                    lockSet_spec_3
                                    gsslockSet_rem
                                    gsolockSet_rem1
                                    gsolockSet_rem2
                                    gsslockResUpdLock
                                    gsolockResUpdLock
                                    gsslockResRemLock
                                    gsolockResRemLock
                                    (@ gRemLockSetCode)
                                    (@gRemLockSetRes)
                                    (@gsoAddCode)
                                    (@gssAddCode)
                                    (@gsoAddRes)
                                    updLock_updThread_comm
                                    remLock_updThread_comm
                                    remLock_updThreadC_comm
      ).

  End OrdinalThreadPool.
End OrdinalPool. *)

Require Import VST.concurrency.common.erased_machine.
(* VST.concurrency.common.erased_machine:
Require Import compcert.lib.Axioms.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.addressFiniteMap. 
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.lib.Integers.
Require Import VST.concurrency.common.threads_lemmas.
Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.common.threadPool.

Module BareMachine.

  Import event_semantics Events ThreadPool.

  Section BareMachine.
    
    Context {Sem: Semantics}.

    Instance resources : Resources :=
      {| res := unit; lock_info := unit |}.

    Notation C:= (@semC Sem).
    Notation G:= (@semG Sem).
    Notation semSem:= (@semSem Sem).

    Existing Instance OrdinalPool.OrdinalThreadPool.
    
    Definition richMem: Type := mem.
    Definition dryMem: richMem -> mem:= id.
    
    Notation thread_pool := (@t resources Sem).

    Definition mem_compatible (tp : thread_pool) (m : mem) : Prop := True.
    Definition invariant (tp : thread_pool) := True.

    Inductive thread_step {tid0 tp m} (cnt: containsThread tp tid0)
              (Hcompatible: mem_compatible tp m) :
      thread_pool -> mem -> seq mem_event -> Prop :=
    | step_thread :
        forall (tp':thread_pool) c m' (c' : C) ev
          (Hcode: getThreadC cnt = Krun c)
          (Hcorestep: ev_step semSem c m ev c' m')
          (Htp': tp' = updThreadC cnt (Krun c')),
          thread_step cnt Hcompatible tp' m' ev.

    Inductive ext_step {tid0 tp m} 
              (cnt0:containsThread tp tid0)(Hcompat:mem_compatible tp m):
      thread_pool -> mem -> sync_event -> Prop :=
    | step_acquire :
        forall (tp' : thread_pool) c m' b ofs
          (Hcode: getThreadC cnt0 = Kblocked c)
          (Hat_external: at_external semSem c m =
                         Some (LOCK, Vptr b ofs::nil))
          (Hload: Mem.load Mint32 m b (Ptrofs.intval ofs) = Some (Vint Int.one))
          (Hstore: Mem.store Mint32 m b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
          (Htp': tp' = updThreadC cnt0 (Kresume c Vundef)),
          ext_step cnt0 Hcompat tp' m' (acquire (b, Ptrofs.intval ofs) None)

    | step_release :
        forall (tp':thread_pool) c m' b ofs
          (Hcode: getThreadC cnt0 = Kblocked c)
          (Hat_external: at_external semSem c m =
                         Some (UNLOCK, Vptr b ofs::nil))
          (Hstore: Mem.store Mint32 m b (Ptrofs.intval ofs) (Vint Int.one) = Some m')
          (Htp': tp' = updThreadC cnt0 (Kresume c Vundef)),
          ext_step cnt0 Hcompat tp' m' (release (b, Ptrofs.intval ofs) None)

    | step_create :
        forall (tp_upd tp':thread_pool) c b ofs arg
          (Hcode: getThreadC cnt0 = Kblocked c)
          (Hat_external: at_external semSem c m =
                         Some (CREATE, Vptr b ofs::arg::nil))
          (Htp_upd: tp_upd = updThreadC cnt0 (Kresume c Vundef))
          (Htp': tp' = addThread tp_upd (Vptr b ofs) arg tt),
          ext_step cnt0 Hcompat tp' m (spawn (b, Ptrofs.intval ofs) None None)

    | step_mklock :
        forall  (tp': thread_pool) c m' b ofs
           (Hcode: getThreadC cnt0 = Kblocked c)
           (Hat_external: at_external semSem c m =
                          Some (MKLOCK, Vptr b ofs::nil))
           (Hstore: Mem.store Mint32 m b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
           (Htp': tp' = updThreadC cnt0 (Kresume c Vundef)),
          ext_step cnt0 Hcompat tp' m' (mklock (b, Ptrofs.intval ofs))

    | step_freelock :
        forall (tp' tp'': thread_pool) c b ofs
          (Hcode: getThreadC cnt0 = Kblocked c)
          (Hat_external: at_external semSem c m =
                         Some (FREE_LOCK, Vptr b ofs::nil))
          (Htp': tp' = updThreadC cnt0 (Kresume c Vundef)),
          ext_step cnt0 Hcompat  tp' m (freelock (b,Ptrofs.intval ofs))

    | step_acqfail :
        forall  c b ofs
           (Hcode: getThreadC cnt0 = Kblocked c)
           (Hat_external: at_external semSem c m =
                          Some (LOCK, Vptr b ofs::nil))
           (Hload: Mem.load Mint32 m b (Ptrofs.intval ofs) = Some (Vint Int.zero)),
          ext_step cnt0 Hcompat tp m (failacq (b, Ptrofs.intval ofs)).

    Definition threadStep: forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> seq mem_event -> Prop:=
      @thread_step.

    Definition syncStep (isCoarse:bool) :
      forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> sync_event -> Prop:=
      @ext_step.

    Lemma threadStep_at_Krun:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        (exists q, @getThreadC _ _ _ i tp cnt = Krun q).

   Lemma threadStep_equal_run:
    forall i tp m cnt cmpt tp' m' tr,
      @threadStep i tp m cnt cmpt tp' m' tr ->
      forall j,
        (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
        (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Lemma syncstep_equal_run:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall j,
          (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
          (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Lemma syncstep_not_running:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q.
    
    Definition init_mach (_ : option unit) (m: mem)
               (tp:thread_pool)(m':mem)(v:val)(args:list val) : Prop :=
      exists c, initial_core semSem 0 m c m' v args /\ tp = mkPool (Krun c) tt.

    Definition install_perm tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) m' :=
      m = m'.

    Definition add_block tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) (m': mem) := tt.

    Instance BareMachineSig: HybridMachineSig.MachineSig :=
      (HybridMachineSig.Build_MachineSig
                                       richMem
                                       dryMem
                                       mem_compatible
                                       invariant
                                       install_perm
                                       add_block
                                       (@threadStep)
                                       threadStep_at_Krun
                                       threadStep_equal_run
                                       (@syncStep)
                                       syncstep_equal_run
                                       syncstep_not_running
                                       init_mach
      ).

  End BareMachine.
  Set Printing All.
End BareMachine. *)

Require Import VST.concurrency.common.HybridMachineSig.
(* VST.concurrency.common.HybridMachineSig:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.

Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.event_semantics.
Require Export VST.concurrency.common.semantics.
Require Import VST.concurrency.common.threadPool.

Require Import VST.concurrency.common.machine_semantics.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.common.addressFiniteMap.
Require Import Coq.Program.Program.

Notation EXIT :=
  (EF_external "EXIT" (mksignature (AST.Tint::nil) None)).
Notation CREATE_SIG := (mksignature (AST.Tint::AST.Tint::nil) None cc_default).
Notation CREATE := (EF_external "spawn" CREATE_SIG).
Notation MKLOCK :=
  (EF_external "makelock" (mksignature (AST.Tptr::nil) None cc_default)).
Notation FREE_LOCK :=
  (EF_external "freelock" (mksignature (AST.Tptr::nil) None cc_default)).
Notation LOCK_SIG := (mksignature (AST.Tptr::nil) None cc_default).
Notation LOCK := (EF_external "acquire" LOCK_SIG).
Notation UNLOCK_SIG := (mksignature (AST.Tptr::nil) None cc_default).
Notation UNLOCK := (EF_external "release" UNLOCK_SIG).

Module Events.
    Definition evRes := (access_map * access_map)%type.
  Definition evDelta := (delta_map * delta_map)%type.

  Definition delta_content := (Maps.PTree.t (Z -> option memval)).
  Inductive sync_event : Type :=
  | release : address -> option delta_content -> sync_event
  | acquire : address -> option delta_content -> sync_event
  | mklock :  address -> sync_event
  | freelock : address -> sync_event
  | spawn : address -> option delta_content -> option delta_content -> sync_event
  | failacq: address -> sync_event.
  
  Inductive machine_event : Type :=
  | internal: nat -> mem_event -> machine_event
  | external : nat -> sync_event -> machine_event.

  Definition thread_id ev : nat :=
    match ev with
    | internal i _ => i
    | external i _ => i
    end.

  Inductive act : Type :=
  | Read : act
  | Write : act
  | Alloc : act
  | Free : act
  | Release : act
  | Acquire : act
  | Mklock : act
  | Freelock : act
  | Failacq : act
  | Spawn : act.

  Definition is_internal ev :=
    match ev with
    | internal _ _ => true
    | _ => false
    end.

  Definition is_external ev :=
    match ev with
    | external _ _ => true
    | _ => false
    end.

  Definition action ev : act :=
    match ev with
    | internal _ mev =>
      match mev with
      | event_semantics.Write _ _ _ => Write
      | event_semantics.Read _ _ _ _ => Read
      | event_semantics.Alloc _ _ _ => Alloc
      | event_semantics.Free _ => Free
      end
    | external _ sev =>
      match sev with
      | release _ _ => Release
      | acquire _ _ => Acquire
      | mklock _ => Mklock
      | freelock _ => Freelock
      | failacq _ => Failacq
      | spawn _ _ _ => Spawn
      end
    end.

  Definition location ev : option (address*nat) :=
    match ev with
    | internal _ mev =>
      match mev with
      | event_semantics.Write b ofs vs => Some ((b, ofs), length vs)
      | event_semantics.Read b ofs _ vs => Some ((b, ofs), length vs)
      | _ => None
      end
    | external _ sev =>
      match sev with
      | release addr _ => Some (addr, lksize.LKSIZE_nat)
      | acquire addr _ => Some (addr, lksize.LKSIZE_nat)
      | mklock addr => Some (addr, lksize.LKSIZE_nat)
      | freelock addr => Some (addr, lksize.LKSIZE_nat)
      | spawn addr _ _ => Some (addr, lksize.LKSIZE_nat)
      | failacq addr => Some (addr, lksize.LKSIZE_nat)
      end
    end.

End Events.

Module HybridMachineSig.
  Import Events ThreadPool.

  Class DiluteMem :=
    { diluteMem: mem -> mem;
      diluteMem_valid: forall m,
          forall b, Memory.Mem.valid_block (diluteMem m) b <-> Memory.Mem.valid_block m b
    }.
  
  Section HybridMachineSig.
    
    Variable n: option nat.
    Context {resources: Resources}
            {Sem: Semantics}
            {ThreadPool : ThreadPool.ThreadPool}
            {DilMem : DiluteMem}.
    Definition thread_pool := ThreadPool.t.
    Definition C:= (@semC Sem).
    Definition G:= (@semG Sem).
    Local Notation ctl := (@ctl C).

    Class MachineSig :=
      {
        richMem: Type
        ; dryMem: richMem -> mem

        ; mem_compatible: thread_pool -> mem -> Prop
        ; invariant: thread_pool -> Prop
        ; install_perm: forall {ms m tid},
            mem_compatible ms m -> containsThread ms tid -> mem -> Prop
        ; add_block: forall {ms m tid},
            mem_compatible ms m -> containsThread ms tid -> mem -> res
                                     
        ; threadStep:
            forall {tid0 ms m},
              containsThread ms tid0 -> mem_compatible ms m ->
              thread_pool -> mem -> seq mem_event -> Prop

        ; threadStep_at_Krun:
            forall i tp m cnt cmpt tp' m' tr,
              @threadStep i tp m cnt cmpt tp' m' tr ->
              (exists q, @getThreadC _ _ _ i tp cnt = Krun q)                                        
                                                    
        ;  threadStep_equal_run:
             forall i tp m cnt cmpt tp' m' tr,
               @threadStep i tp m cnt cmpt tp' m' tr ->
               forall (j: nat),
                 (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
                 (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q')

        ; syncStep:
            bool -> 
            forall {tid0 ms m},
                containsThread ms tid0 -> mem_compatible ms m ->
                thread_pool -> mem -> sync_event -> Prop
                                                   
        ;  syncstep_equal_run:
             forall b i tp m cnt cmpt tp' m' tr,
               @syncStep b i tp m cnt cmpt tp' m' tr ->
               forall j,
                 (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
                 (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q')
                   
        ;  syncstep_not_running:
             forall b i tp m cnt cmpt tp' m' tr,
               @syncStep b i tp m cnt cmpt tp' m' tr ->
               forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q

        ; init_mach : option res -> mem -> thread_pool -> mem -> val -> list val -> Prop}.

    Context {machineSig: MachineSig}.

    Definition event_trace := (seq machine_event).
    Definition schedule := (seq nat).
    Definition MachState : Type:= (schedule * event_trace * t)%type.
  
    Definition schedPeek sch: option nat:=
      match sch with
        nil => None
      | cons hd tl => Some hd
      end.
  
  Definition schedSkip sch: (seq nat):= List.tl sch.
  Definition machine_state := thread_pool.

   Inductive start_thread : forall (m: mem) {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> mem -> Prop:=
  | StartThread: forall m m' m_new tid0 ms ms' c_new vf arg
                    (ctn: containsThread ms tid0)
                    (Hcode: getThreadC ctn = Kinit vf arg)
                    (Hcmpt: mem_compatible ms m)
                    (Hperm: install_perm Hcmpt ctn m')
                    (Hinitial: initial_core semSem tid0
                                            m' c_new m_new vf (arg::nil))
                    (Hinv: invariant ms)
                    (Hms': updThread ctn (Krun c_new) (add_block Hcmpt ctn m_new) = ms'),
                    
      start_thread m ctn ms' m_new.

   Inductive resume_thread' : forall (m: mem) {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> Prop:=
  | ResumeThread: forall m tid0 ms ms' c c' X m'
                    (ctn: containsThread ms tid0)
                    (Hcmpt: mem_compatible ms m)
                    (Hperm: install_perm Hcmpt ctn m')
                    (Hat_external: at_external semSem c m' = Some X)
                    (Hafter_external: after_external semSem None c m' = Some c')
                    (Hcode: getThreadC ctn = Kresume c Vundef)
                    (Hinv: invariant ms)
                    (Hms': updThreadC ctn (Krun c')  = ms'),
      resume_thread' m ctn ms'.
  Definition resume_thread: forall m {tid0 ms},
      containsThread ms tid0 -> machine_state -> Prop:=
    @resume_thread'.

  Inductive suspend_thread': forall m {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> Prop:=
  | SuspendThread: forall m tid0 ms ms' c X m'
                     (ctn: containsThread ms tid0)
                     (Hcmpt: mem_compatible ms m)
                     (Hcode: getThreadC ctn = Krun c)
                     (Hperm: install_perm Hcmpt ctn m')
                     (Hat_external: at_external semSem c m'  = Some X)
                     (Hinv: invariant ms)
                     (Hms': updThreadC ctn (Kblocked c) = ms'),
      suspend_thread' m ctn ms'.
  Definition suspend_thread: forall (m: mem) {tid0 ms},
      containsThread ms tid0 -> machine_state -> Prop:=
    @suspend_thread'.
      Class Scheduler :=
    { isCoarse : bool;
      yield: schedule -> schedule}.
  Context {scheduler : Scheduler}.

  Inductive machine_step:
    schedule -> event_trace -> machine_state -> mem -> schedule ->
    event_trace -> machine_state -> mem -> Prop :=
  | start_step:
        forall tid U ms ms' m m' tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Htstep: start_thread m Htid ms' m'),
          machine_step U tr ms m (yield U) tr ms' (diluteMem m')
    | resume_step:
        forall tid U ms ms' m tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Htstep: resume_thread m Htid ms'),
          machine_step U tr ms m (yield U) tr ms' m
    | thread_step:
        forall tid U ms ms' m m' ev tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Hcmpt: mem_compatible ms m)
          (Htstep: threadStep Htid Hcmpt ms' m' ev),
          machine_step U tr ms m (yield U)
                       (tr ++ (List.map (fun mev => internal tid mev) ev)) ms' (diluteMem m')
    | suspend_step:
        forall tid U U' ms ms' m tr
          (HschedN: schedPeek U = Some tid)
          (HschedS: schedSkip U = U')        
          (Htid: containsThread ms tid)
          (Htstep:suspend_thread m Htid ms'),
          machine_step U tr ms m U' tr ms' m
    | sync_step:
        forall tid U U' ms ms' m m' ev tr
          (HschedN: schedPeek U = Some tid)
          (HschedS: schedSkip U = U')        
          (Htid: containsThread ms tid)
          (Hcmpt: mem_compatible ms m)
          (Htstep: syncStep isCoarse Htid Hcmpt ms' m' ev),
          machine_step U tr ms m U' (tr ++ [:: external tid ev]) ms' m'
    | schedfail :
        forall tid U U' ms m tr
          (HschedN: schedPeek U = Some tid)
          (Htid: ~ containsThread ms tid)
          (Hinv: invariant ms)
          (Hcmpt: mem_compatible ms m)
          (HschedS: schedSkip U = U'),        
          machine_step U tr ms m U' tr ms m.

    Definition MachStep (c:MachState) (m:mem)
               (c':MachState) (m':mem) :=
      @machine_step (fst (fst c)) (snd (fst c)) (snd c)  m
                    (fst (fst c')) (snd (fst c')) (snd c')  m'.

    Definition at_external_mach (st : MachState) (m: mem)
      : option (external_function * list val) := None.
    
    Definition after_external_mach (ov : option val) (st : MachState) (m : mem) :
      option (MachState) := None.
    
    Definition halted_machine (st : MachState) : option val :=
      match schedPeek (fst (fst st)) with
      | Some _ => None
      | _ => Some Vundef
      end.

    Definition init_machine (U:schedule) (r : option res) (m: mem)
               (st : MachState) (m': mem) (f : val) (args : list val)
      : Prop :=
      match st with (U', [::], c) => U' = U /\ init_mach r m c m' f args | _ => False end.

    Program Definition MachineCoreSemantics (U:schedule) (r : option res):
      CoreSemantics MachState mem.

    Definition make_init_machine c r:= 
        mkPool (Krun c) r.
    Definition init_machine' (the_ge : semG) m
               c m' (f : val) (args : list val) 
      : option res -> Prop := fun op_r =>
                            if op_r is Some r then 
                              init_mach op_r m (make_init_machine c r) m' f args
                            else False.
    Definition init_machine'' (op_m: option mem)(op_r : option res)(m: mem)
               (tp : thread_pool) (m': mem) (f : val) (args : list val)
      : Prop :=
      op_m = Some m /\
      if op_r is Some r then 
        init_mach op_r m tp m' f args
      else False.
    
    Definition unique_Krun tp i :=
      forall j cnti q, 
        @getThreadC _ _ _ j tp cnti = Krun q ->
        eq_nat_dec i j.

    Lemma hybrid_initial_schedule: forall m m' main vals U p st n,
        initial_core (MachineCoreSemantics U p) n m st m' main vals ->
        exists c, st = (U, nil, c).

    Inductive internal_step:
      schedule -> machine_state -> mem -> machine_state -> mem -> Prop :=
      | thread_step':
          forall tid U ms ms' m m' ev
            (HschedN: schedPeek U = Some tid)
            (Htid: containsThread ms tid)
            (Hcmpt: mem_compatible ms m)
            (Htstep: threadStep Htid Hcmpt ms' m' ev),
            internal_step U ms m ms' (diluteMem m').

      Inductive external_step:
        schedule -> event_trace -> machine_state -> mem -> schedule ->
        event_trace -> machine_state -> mem -> Prop :=
      | start_state': forall tid U ms ms' m m' tr
                        (HschedN: schedPeek U = Some tid)
                        (Htid: containsThread ms tid)
                        (Htstep: start_thread m Htid ms' m'),
          external_step U tr ms m (yield U) tr ms' (diluteMem m')
      | resume_step':
          forall tid U ms ms' m tr
            (HschedN: schedPeek U = Some tid)
            (Htid: containsThread  ms tid)
            (Htstep: resume_thread m Htid ms'),
            external_step U tr ms m (yield U) tr ms' m
      | suspend_step':
          forall tid U U' ms ms' m tr
            (HschedN: schedPeek U = Some tid)
            (HschedS: schedSkip U = U')        
            (Htid: containsThread ms tid)
            (Htstep:suspend_thread m Htid ms'),
            external_step U tr ms m U' tr ms' m
      | sync_step':
          forall tid U U' ms ms' m m' ev tr
            (HschedN: schedPeek U = Some tid)
            (HschedS: schedSkip U = U')        
            (Htid: containsThread ms tid)
            (Hcmpt: mem_compatible ms m)
            (Htstep: syncStep isCoarse Htid Hcmpt ms' m' ev),
            external_step U tr ms m  U' (tr ++ [:: external tid ev]) ms' m'
      | schedfail':
          forall tid U U' ms m tr
            (HschedN: schedPeek U = Some tid)
            (Htid: ~ containsThread ms tid)
            (Hinv: invariant ms)
            (Hcmpt: mem_compatible ms m)
            (HschedS: schedSkip U = U'),        
            external_step U tr ms m U' tr ms m.

      Lemma step_equivalence1: forall U tr st m U' tr' st' m',
          @machine_step U tr st m U' tr' st' m' ->
          (U' = yield U /\ @internal_step U st m st' m') \/
          @external_step U tr st m U' tr' st' m'.

      Lemma step_equivalence2: forall U st m st' m' tr,
          @internal_step U st m st' m' ->
          exists tr',
            @machine_step U tr st m (yield U) (tr ++ tr') st' m'.
      Lemma step_equivalence3: forall U tr st m U' tr' st' m',
          @external_step U tr st m U' tr' st' m' ->
          exists tr1, tr' = tr ++ tr1 /\ @machine_step U tr st m U' tr' st' m'.

      Set Printing Implicit.
      Program Definition new_MachineSemantics (op_m:option Mem.mem):
      
      Instance scheduler : Scheduler :=
        {| isCoarse := true;
           yield := fun x => x |}.

      Notation thread_pool := t.
      Notation C:= (semC).
      Notation G:= (semG).
      Local Notation ctl := (@ctl C).
      Notation machine_state := thread_pool.
      Notation schedule := (seq nat).
      Notation event_trace := (seq machine_event).

      Definition HybridCoarseMachine : HybridMachine :=
        @Build_HybridMachine resources Sem ThreadPool _ _ _
                             (MachineCoreSemantics)
                             (new_MachineSemantics)
                             (hybrid_initial_schedule).

      Inductive csafe (st : MachState) (m : mem) : nat -> Prop :=
      | Safe_0: csafe st m 0
      | HaltedSafe: forall n, halted_machine st -> csafe st m n
      | CoreSafe : forall tp' m' n tr
                     (Hstep: MachStep st m (fst (fst st),(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: csafe (fst (fst st),(snd (fst st)) ++ tr,tp') m' n),
          csafe st m (S n)
      | AngelSafe: forall tp' m' n (tr: event_trace)
                     (Hstep: MachStep st m (schedSkip (fst (fst st)),(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: forall U'', csafe (U'',(snd (fst st)) ++ tr,tp') m' n),
          csafe st m (S n).

      Inductive concur_safe U tp (m : mem) : nat -> Prop :=
      | concur_Safe_0: concur_safe U tp m 0
      | concur_HaltedSafe: forall n, halted_machine (U, nil, tp) -> concur_safe U tp m n
      | concur_Internal : forall tp' m' n
                     (Hstep: internal_step U tp m tp' m')
                     (Hsafe: concur_safe U tp' m' n),
          concur_safe U tp m (S n)
      | concur_External: forall tp' m' n (tr tr': event_trace)
                     (Hstep: external_step U tr tp m U tr' tp' m')
                     (Hsafe: concur_safe U tp' m' n),
          concur_safe U tp m (S n)
      | concur_External_Angel: forall tp' m' n (tr tr': event_trace)
                     (Hstep: external_step U tr tp m (schedSkip U) tr' tp' m')
                     (Hsafe: forall U'', concur_safe U'' tp' m' n),
          concur_safe U tp m (S n).
      
      Lemma csafe_reduce:
        forall sched tp tr mem n m,
          csafe (sched, tr, tp) mem n ->
          m <= n ->
          csafe (sched, tr, tp) mem m.

      Lemma schedSkip_id: forall U, schedSkip U = U -> U = nil.

      Lemma csafe_trace: forall n U tr tp m,
        csafe (U, tr, tp) m n ->
        forall tr', csafe (U, tr', tp) m n.

      Lemma csafe_concur_safe: forall U tr tp m n, csafe (U, tr, tp) m n -> concur_safe U tp m n.

      Lemma concur_safe_csafe: forall U tr tp m n, concur_safe U tp m n -> csafe (U, tr, tp) m n.

      Inductive ctrace (st : MachState) (m : mem) : event_trace -> Prop :=
      | Trace_0: ctrace st m nil 
      | Trace_Step : forall tp' m' U' tr tr'
                     (Hstep: MachStep st m (U',(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: ctrace (U',(snd (fst st)) ++ tr,tp') m' tr'),
          ctrace st m (tr ++ tr').

    End HybridCoarseMachine.
  End HybridCoarseMachine.
  
  Module HybridFineMachine.
    Section HybridFineMachine.

      Variable n: nat.
      Context {resources: Resources}
              {Sem: Semantics}
              {ThreadPool : ThreadPool.ThreadPool}
              {machineSig: MachineSig}.

      Notation thread_pool := t.
      Notation C:= (semC).
      Notation G:= (semG).
      Local Notation ctl := (@ctl C).
      Notation machine_state := thread_pool.
      Notation schedule := (seq nat).  
      Notation event_trace := (seq machine_event).

      Context {dilMem : DiluteMem}.
      
      Instance scheduler : Scheduler :=
        {| isCoarse := false;
           yield := fun x => schedSkip x |}.

      Definition HybridFineMachine : HybridMachine:=
        @Build_HybridMachine resources Sem ThreadPool _ _ _
                             (MachineCoreSemantics)
                             (new_MachineSemantics)
                             (hybrid_initial_schedule).

      Inductive fsafe (tp : thread_pool) (m : mem) (U : schedule)
        : nat -> Prop :=
      | Safe_0: fsafe tp m U 0
      | HaltedSafe : forall n tr, halted_machine (U, tr, tp) -> fsafe tp m U n
      | StepSafe : forall (tp' : thread_pool) (m' : mem)
                     (tr tr': event_trace) n,
          MachStep (U, tr, tp) m (schedSkip U, tr', tp') m' ->
          fsafe tp' m' (schedSkip U) n ->
          fsafe tp m U (S n).

      Inductive ftrace (tp : thread_pool) (m : mem) (U : schedule)
        : event_trace -> Prop :=
      | Trace_0: ftrace tp m U nil
      | StepTrace : forall (tp' : thread_pool) (m' : mem)
                     (tr tr' tr'': event_trace),
          MachStep (U, tr, tp) m (schedSkip U, tr ++ tr', tp') m' ->
          ftrace tp' m' (schedSkip U) tr'' ->
          ftrace tp m U (tr' ++ tr'').
    End HybridFineMachine.
End HybridFineMachine.

End HybridMachineSig. *)



Set Bullet Behavior "Strict Subproofs".



Module Main (CC_correct: CompCert_correctness).

  

  Module ConcurCC_safe := (Concurrent_Safety CC_correct).

  Import ConcurCC_safe.



  Import dry_context.AsmContext.



  Section MainTheorem.

  

  Context (CPROOF : semax_to_juicy_machine.CSL_proof).

  Definition Clight_prog:= semax_to_juicy_machine.CSL_prog CPROOF.

  Definition Main_ptr:=Values.Vptr (Ctypes.prog_main Clight_prog) Integers.Ptrofs.zero.

  Context (Asm_prog: Asm.program).

  Context (compilation : CC_correct.CompCert_compiler Clight_prog = Some Asm_prog).

  Context (asm_genv_safe: Asm_core.safe_genv (@x86_context.X86Context.the_ge Asm_prog)).

  Instance SemTarget : Semantics:= @x86_context.X86Context.X86Sem Asm_prog asm_genv_safe.

  Existing Instance X86Inj.X86Inj.



  Variable init_mem_wd:

    forall m,

      Genv.init_mem Asm_prog = Some m ->

      mem_obs_eq.MemoryWD.valid_mem m /\

      mem_obs_eq.CoreInjections.ge_wd (Renamings.id_ren m) the_ge.

        

  Context (CPROOF_initial:

             Clight.start_stack (Clight.globalenv Clight_prog)

                                (init_mem CPROOF)

                                (Clight_safety.initial_Clight_state CPROOF)

                                Main_ptr nil).



  Lemma CPROOF_initial_mem:  Genv.init_mem (Ctypes.program_of_program Clight_prog) = Some (init_mem CPROOF).

  Proof.

  unfold Clight_prog, init_mem, semax_to_juicy_machine.init_mem, 

    semax_initial.init_m, semax_to_juicy_machine.prog, Ctypes.program_of_program.

  clear.

  set (H := (semax_to_juicy_machine.init_mem_not_none CPROOF)).

  clearbody H.

  set (p := semax_to_juicy_machine.CSL_prog CPROOF) in *.

  unfold Ctypes.program_of_program in H.

  clearbody p.

  set (m := Genv.init_mem

          {|

          AST.prog_defs := Ctypes.prog_defs p;

          AST.prog_public := Ctypes.prog_public p;

          AST.prog_main := Ctypes.prog_main p |}) in *.

 clearbody m.

 destruct m. reflexivity. contradiction H; auto.

Qed. 



  Definition SemSource p:= (ClightSemanticsForMachines.ClightSem (Clight.globalenv p)).

  Definition THM m:=

    (HybridMachineSig.HybridMachineSig.ConcurMachineSemantics

       (Sem:=SemTarget)

       (ThreadPool:= threadPool.OrdinalPool.OrdinalThreadPool(Sem:=SemTarget))

       (HybridMachine:=concurrent_compiler_safety.TargetHybridMachine)

       (machineSig:= HybridMachine.DryHybridMachine.DryHybridMachineSig) m).



  Definition EHM m:=

    (HybridMachineSig.HybridMachineSig.ConcurMachineSemantics

       (Sem:=SemTarget)

       (ThreadPool:= threadPool.OrdinalPool.OrdinalThreadPool(Sem:=SemTarget))

       (HybridMachine:=@bareMach SemTarget)

       (machineSig:= BareMachine.BareMachineSig) m).



  Context {SW : Clight_safety.spawn_wrapper CPROOF}.

  

  Lemma CSL2CoarseAsm_safety:

    forall U,

    exists init_mem_target init_mem_target' init_thread_target,

      let res_target := permissions.getCurPerm init_mem_target' in

      let res:=(res_target, permissions.empty_map) in

  let init_tp_target :=

      threadPool.ThreadPool.mkPool

        (Sem:=SemTarget)

        (resources:=erasure_proof.Parching.DR)

        (Krun init_thread_target)

      res in

  let init_MachState_target := (U, nil, init_tp_target) in  

      machine_semantics.initial_machine (THM (Genv.init_mem Asm_prog)) (Some res) init_mem_target init_tp_target init_mem_target' Main_ptr nil /\

  forall n,

    HybridMachineSig.HybridMachineSig.HybridCoarseMachine.csafe

      (ThreadPool:=threadPool.OrdinalPool.OrdinalThreadPool

                     (Sem:=SemTarget))

      (machineSig:= HybridMachine.DryHybridMachine.DryHybridMachineSig)

      init_MachState_target init_mem_target' n.

  Proof.

    intros.

    pose proof (@ConcurrentCompilerSafety _ _ compilation asm_genv_safe) as H.

    unfold concurrent_compiler_safety.concurrent_simulation_safety_preservation in *.

    specialize (H U (init_mem CPROOF) (init_mem CPROOF) (Clight_safety.initial_Clight_state CPROOF) Main_ptr nil).

    match type of H with

      | ?A -> _ => cut A

    end.

    intros HH; specialize (H HH);

    match type of H with

      | ?A -> _ => cut A

    end.

    intros HH'; specialize (H HH');

      match type of H with

      | ?A -> _ => cut A; try (intros; eapply Clight_initial_safe; auto)  

      end.

    intros HH''; specialize (H HH'').



    - destruct H as (mem_t& mem_t' & thread_target & INIT_mem & INIT & SAFE).

      exists mem_t, mem_t', thread_target; split .

      + eauto. 

        
      + eapply SAFE.



    - clear H. split; eauto; econstructor; repeat split; try reflexivity; eauto.

    - apply CPROOF_initial_mem.

  Qed.



  Notation sc_execution := (@Executions.fine_execution _ BareDilMem BareMachine.resources

                                            BareMachine.BareMachineSig).

  Theorem CSL2FineBareAsm_safety:

    forall U,

    exists init_mem_target init_mem_target' init_thread_target,

      let init_tp_target :=

          threadPool.ThreadPool.mkPool

            (Sem:=SemTarget)

            (resources:=BareMachine.resources)

            (Krun init_thread_target) tt in  

      machine_semantics.initial_machine (EHM (Genv.init_mem Asm_prog)) (Some tt) init_mem_target

                                        init_tp_target init_mem_target' Main_ptr nil /\



      (forall n,

        HybridMachineSig.HybridMachineSig.HybridFineMachine.fsafe

          (dilMem:= BareDilMem)

          (ThreadPool:=threadPool.OrdinalPool.OrdinalThreadPool

                         (resources:=BareMachine.resources)

                         (Sem:=SemTarget))

          (machineSig:= BareMachine.BareMachineSig)

          init_tp_target (@HybridMachineSig.diluteMem BareDilMem init_mem_target') U n) /\

      (forall final_state final_mem tr,

          sc_execution (U, [::], init_tp_target)

                       (@HybridMachineSig.diluteMem BareDilMem init_mem_target')

                       ([::], tr, final_state) final_mem ->

          SpinLocks.spinlock_synchronized tr).

  Proof.

    intros U.

    destruct (CSL2CoarseAsm_safety U) as

        (init_mem_target & init_mem_target' & init_thread_target & INIT & Hsafe).

    simpl in INIT.

    unfold HybridMachineSig.init_machine'' in INIT.

    destruct INIT as [Hinit_mem Hinit].

    simpl in Hinit.

    unfold HybridMachine.DryHybridMachine.init_mach in Hinit.

    destruct Hinit as [c [Hinit Heq]].

    exists init_mem_target, init_mem_target',

    init_thread_target.

    assert (init_thread_target = c).

    { inversion Heq.

      assert (0 < 1)%nat by auto.

      eapply Extensionality.EqdepTh.inj_pair2 in H0.

      apply equal_f in H0.

      inversion H0; subst.

      reflexivity.

      simpl.

      econstructor;

        now eauto.

    }

    subst.

    split.

    - simpl.

      unfold HybridMachineSig.init_machine''.

      split; auto.

      simpl.

      unfold BareMachine.init_mach.

      exists c.

      split; auto.

    - intros.

      destruct (init_mem_wd  Hinit_mem ) as [Hvalid_mem Hvalid_ge].

      pose (fineConc_safe.FineConcInitial.Build_FineInit Hvalid_mem Hvalid_ge).

      eapply @X86Safe.x86SC_safe with (Main_ptr := Main_ptr) (FI := f); eauto.

      intro; apply Classical_Prop.classic.

      

      intros.

      pose proof (CSL2CoarseAsm_safety sched) as

          (init_mem_target2 & init_mem_target2' & init_thread_target2 & INIT2 & Hsafe2).

      simpl in INIT2.

      unfold HybridMachineSig.init_machine'' in INIT2.

      destruct INIT2 as [Hinit_mem2 Hinit2].

      rewrite Hinit_mem2 in Hinit_mem.

      inversion Hinit_mem; subst.

      simpl in Hinit2.

      unfold HybridMachine.DryHybridMachine.init_mach in Hinit2.

      destruct Hinit2 as [c2 [Hinit2 Heq2]].

      destruct (Asm.semantics_determinate Asm_prog).

      simpl in sd_initial_determ.

      simpl in Hinit, Hinit2.

      destruct Hinit as [Hinit ?], Hinit2 as [Hinit2 ?]; subst.

      specialize (sd_initial_determ _ _ _ _ _ Hinit Hinit2); subst.

      now eauto.

  Qed.

    

  End MainTheorem.

  

End Main.



Module CC_correct: CompCert_correctness.

  Axiom CompCert_compiler : Clight.program -> option Asm.program.

  Axiom simpl_clight_semantic_preservation :

    forall (p : Clight.program) (tp : Asm.program),

      CompCert_compiler p = Some tp ->

      ExposedSimulations.fsim_properties_inj (Clight.semantics2 p) (Asm.semantics tp)

                                             Clight.get_mem Asm.get_mem.



End CC_correct.



Module Test_Main:= (Main CC_correct).

Import Test_Main.



Check CSL2FineBareAsm_safety.

Print Assumptions CSL2FineBareAsm_safety.

