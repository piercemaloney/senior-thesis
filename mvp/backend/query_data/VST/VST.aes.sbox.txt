Require Import List. Import ListNotations.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)

Require Import ZArith.

Local Open Scope Z_scope.



Definition sbox := [

  

  99; 124; 119; 123; 242; 107; 111; 197; 48; 1; 103; 43; 254; 215; 171; 118;

  

  202; 130; 201; 125; 250; 89; 71; 240; 173; 212; 162; 175; 156; 164; 114; 192;

  

  183; 253; 147; 38; 54; 63; 247; 204; 52; 165; 229; 241; 113; 216; 49; 21;

  

  4; 199; 35; 195; 24; 150; 5; 154; 7; 18; 128; 226; 235; 39; 178; 117;

  

  9; 131; 44; 26; 27; 110; 90; 160; 82; 59; 214; 179; 41; 227; 47; 132;

  

  83; 209; 0; 237; 32; 252; 177; 91; 106; 203; 190; 57; 74; 76; 88; 207;

  

  208; 239; 170; 251; 67; 77; 51; 133; 69; 249; 2; 127; 80; 60; 159; 168;

  

  81; 163; 64; 143; 146; 157; 56; 245; 188; 182; 218; 33; 16; 255; 243; 210;

  

  205; 12; 19; 236; 95; 151; 68; 23; 196; 167; 126; 61; 100; 93; 25; 115;

  

  96; 129; 79; 220; 34; 42; 144; 136; 70; 238; 184; 20; 222; 94; 11; 219;

  

  224; 50; 58; 10; 73; 6; 36; 92; 194; 211; 172; 98; 145; 149; 228; 121;

  

  231; 200; 55; 109; 141; 213; 78; 169; 108; 86; 244; 234; 101; 122; 174; 8;

  

  186; 120; 37; 46; 28; 166; 180; 198; 232; 221; 116; 31; 75; 189; 139; 138;

  

  112; 62; 181; 102; 72; 3; 246; 14; 97; 53; 87; 185; 134; 193; 29; 158;

  

  225; 248; 152; 17; 105; 217; 142; 148; 155; 30; 135; 233; 206; 85; 40; 223;

  

  140; 161; 137; 13; 191; 230; 66; 104; 65; 153; 45; 15; 176; 84; 187; 22

].

Definition inv_sbox := [

  

  82; 9; 106; 213; 48; 54; 165; 56; 191; 64; 163; 158; 129; 243; 215; 251;

  

  124; 227; 57; 130; 155; 47; 255; 135; 52; 142; 67; 68; 196; 222; 233; 203;

  

  84; 123; 148; 50; 166; 194; 35; 61; 238; 76; 149; 11; 66; 250; 195; 78;

  

  8; 46; 161; 102; 40; 217; 36; 178; 118; 91; 162; 73; 109; 139; 209; 37;

  

  114; 248; 246; 100; 134; 104; 152; 22; 212; 164; 92; 204; 93; 101; 182; 146;

  

  108; 112; 72; 80; 253; 237; 185; 218; 94; 21; 70; 87; 167; 141; 157; 132;

  

  144; 216; 171; 0; 140; 188; 211; 10; 247; 228; 88; 5; 184; 179; 69; 6;

  

  208; 44; 30; 143; 202; 63; 15; 2; 193; 175; 189; 3; 1; 19; 138; 107;

  

  58; 145; 17; 65; 79; 103; 220; 234; 151; 242; 207; 206; 240; 180; 230; 115;

  

  150; 172; 116; 34; 231; 173; 53; 133; 226; 249; 55; 232; 28; 117; 223; 110;

  

  71; 241; 26; 113; 29; 41; 197; 137; 111; 183; 98; 14; 170; 24; 190; 27;

  

  252; 86; 62; 75; 198; 210; 121; 32; 154; 219; 192; 254; 120; 205; 90; 244;

  

  31; 221; 168; 51; 136; 7; 199; 49; 177; 18; 16; 89; 39; 128; 236; 95;

  

  96; 81; 127; 169; 25; 181; 74; 13; 45; 229; 122; 159; 147; 201; 156; 239;

  

  160; 224; 59; 77; 174; 42; 245; 176; 200; 235; 187; 60; 131; 83; 153; 97;

  

  23; 43; 4; 126; 186; 119; 214; 38; 225; 105; 20; 99; 85; 33; 12; 125

].

