Require Import VST.msl.msl_standard.
(* VST.msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Require Import VST.veric.shares.
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)



Section UNPROVABLE.



Variable wishes_eq_horses : False.



Lemma unrel_glb:

 forall a b,

    Share.unrel a b = Share.unrel a (Share.glb a b).

contradiction wishes_eq_horses.

Qed.



Lemma share_rel_unrel':

  forall r sh,

    Share.rel r (Share.unrel r sh) = Share.glb r sh.

Proof.

contradiction wishes_eq_horses.

Qed.



Lemma share_sub_Lsh:

forall sh, identity (Share.unrel Share.Rsh sh) -> join_sub sh Share.Lsh.

Proof.

 intros.

 rewrite (Share.decompose_Rsh sh) in H.

 remember (decompose sh).

 symmetry in Heqp. destruct p as [sh1 sh2].

 simpl in H.

 apply identity_share_bot in H. subst.

 generalize (top_correct' sh1);intro.

 destruct H.

 exists (Share.recompose (x, Share.bot)).

 rewrite Share.Lsh_recompose.

 assert (sh = Share.recompose (sh1, Share.bot)).

  rewrite <- Heqp. rewrite Share.recompose_decompose. trivial.

 rewrite H0.

 eapply Share.decompose_join.

 rewrite Share.decompose_recompose. f_equal.

 rewrite Share.decompose_recompose. f_equal.

 rewrite Share.decompose_recompose. f_equal.

 split. trivial.

 split. apply Share.glb_bot. apply Share.lub_bot.

Qed.



Lemma join_splice2_aux:

forall a1 a2 a3 b1 b2 b3,

Share.lub (Share.rel Share.Lsh (Share.lub a1 a2)) (Share.rel Share.Rsh (Share.lub b1 b2))

= Share.lub (Share.rel Share.Lsh a3) (Share.rel Share.Rsh b3) ->

Share.lub a1 a2 = a3 /\ Share.lub b1 b2 = b3.

Proof with try tauto.

 intros. rewrite Share.lub_rel_recompose in H.

 generalize (Share.decompose_recompose (Share.lub a1 a2, Share.lub b1 b2));intro.

 rewrite H in H0.

 rewrite Share.lub_rel_recompose in H0.

 rewrite Share.decompose_recompose in H0.

 split;congruence.

Qed.



Lemma share_rel_unrel:

  forall r sh,

    join_sub sh r ->

    Share.rel r (Share.unrel r sh) = sh.

Proof.

intros.

rewrite share_rel_unrel'.

destruct H as [a [H H0]].

subst r.

rewrite Share.glb_commute.

rewrite Share.distrib1.

rewrite H.

rewrite Share.lub_bot.

apply Share.glb_idem.

Qed.



Lemma glb_rel_Lsh_Rsh:

 forall a b, Share.glb (Share.rel Share.Lsh a) (Share.rel Share.Rsh b) = Share.bot.

Proof.

intros.

assert (H := rel_leq Share.Lsh a).

assert (H0 := rel_leq Share.Rsh b).

apply leq_join_sub in H.

apply leq_join_sub in H0.

forget (Share.rel Share.Lsh a) as aL.

forget (Share.rel Share.Rsh b) as bR.

apply Share.ord_antisym; [ | apply Share.bot_correct].

rewrite <- glb_Lsh_Rsh.

forget Share.Lsh as L.

forget Share.Rsh as R.

apply glb_less_both; auto.

Qed.



Lemma glb_Rsh_rel_Lsh_sh:

 forall sh,

  Share.glb Share.Rsh (Share.rel Share.Lsh sh) = Share.bot.

Proof.

intros.

destruct (Share.split Share.top) eqn:?.

unfold Share.Rsh, Share.Lsh. rewrite Heqp; simpl.

rewrite Share.glb_commute.

destruct (rel_join t t t0 _ (split_join _ _ _ Heqp)).

clear - H Heqp.

pose proof (rel_leq t t0).

rewrite <- leq_join_sub in H0.

rewrite Share.ord_spec1 in H0.

rewrite H0 in H.

rewrite <- Share.glb_assoc in H.

rewrite <- Share.rel_preserves_glb in H.

pose proof (rel_leq t (Share.glb t t0)).

apply leq_join_sub in H1.

apply Share.ord_spec1 in H1. rewrite <- H1 in H.

clear H1.

pose proof bot_identity. rewrite <- H in H1.

apply (rel_nontrivial) in H1.

destruct H1.

apply split_nontrivial' in Heqp; auto.

apply identity_share_bot in Heqp.

apply Share.nontrivial in Heqp; contradiction.

clear H.

apply identity_share_bot in H1.

clear - H1.

pose proof (rel_leq t sh).

forget (Share.rel t sh) as b.

destruct H as [a [? ?]].

subst t.

rewrite Share.glb_commute in H1; rewrite Share.distrib1 in H1.

rewrite Share.glb_commute in H1.

pose proof (Share.lub_upper1 (Share.glb b t0) (Share.glb t0 a)).

rewrite H1 in H0.

apply Share.ord_antisym; auto.

apply Share.bot_correct.

Qed.



Lemma right_nonempty_readable:

  forall rsh sh, sepalg.nonidentity sh <->

     readable_share (Share.splice rsh sh).

Proof.

intros.

unfold readable_share, Share.splice.

unfold nonempty_share,nonidentity.

assert (identity sh <-> identity (Share.glb Share.Rsh (Share.lub (Share.rel Share.Lsh rsh) (Share.rel Share.Rsh sh))));

  [ | intuition].

split; intro.

*

apply identity_share_bot in H. subst.

rewrite Share.rel_bot1.

rewrite Share.lub_bot.

rewrite glb_Rsh_rel_Lsh_sh.

apply bot_identity.

*

rewrite Share.distrib1 in H.

rewrite glb_Rsh_rel_Lsh_sh in H.

rewrite Share.lub_commute, Share.lub_bot in H.

assert (identity (Share.glb (Share.rel Share.Rsh Share.top) (Share.rel Share.Rsh sh)))

  by (rewrite Share.rel_top1; auto).

clear H.

rewrite <- Share.rel_preserves_glb in H0.

rewrite Share.glb_commute, Share.glb_top in H0.

apply rel_nontrivial in H0.

destruct H0; auto.

unfold Share.Rsh in H.

destruct (Share.split Share.top) eqn:?; simpl in *.

apply split_nontrivial' in Heqp; auto.

apply top_share_nonidentity in Heqp.

contradiction.

Qed.



Lemma writable_share_right: forall sh, writable_share sh -> Share.unrel Share.Rsh sh = Share.top.

Proof.

 intros.

 apply Share.contains_Rsh_e.

 apply H.

Qed.



Lemma unrel_bot:

 forall sh, nonidentity sh -> Share.unrel sh Share.bot = Share.bot.

Proof.

intros.

rewrite <- (Share.rel_bot1 sh) at 1.

rewrite Share.unrel_rel; auto.

Qed.



Lemma join_splice2_aux1:

  forall a1 a2 b1 b2,

  Share.lub (Share.rel Share.Lsh (Share.glb a1 a2)) (Share.rel Share.Rsh (Share.glb b1 b2)) = Share.bot ->

  Share.glb a1 a2 = Share.bot /\ Share.glb b1 b2 = Share.bot.

Proof. intros.

  rewrite !Share.rel_preserves_glb in H.

  apply lub_bot_e in H; destruct H.

  rewrite <- Share.rel_preserves_glb in H, H0.

  pose proof (rel_nontrivial Share.Lsh (Share.glb a1 a2)).

  rewrite H in H1. specialize (H1 bot_identity). clear H.

  pose proof (rel_nontrivial Share.Rsh (Share.glb b1 b2)).

  rewrite H0 in H. specialize (H bot_identity). clear H0.

  destruct H1. contradiction (Lsh_nonidentity H0).

  destruct H. contradiction (Rsh_nonidentity H).

  apply identity_share_bot in H.

  apply identity_share_bot in H0.

  auto.

Qed.



Lemma join_splice:

  forall a1 a2 a3 b1 b2 b3,

 sepalg.join a1 a2 a3 ->

 sepalg.join b1 b2 b3 ->

 sepalg.join (Share.splice a1 b1)  (Share.splice a2 b2)  (Share.splice a3 b3).

Proof.

intros.

unfold Share.splice.

destruct H, H0.

split.

*

rewrite Share.distrib1.

do 2 rewrite (Share.glb_commute (Share.lub _ _)).

rewrite Share.distrib1.

rewrite Share.distrib1.

rewrite !(Share.glb_commute (Share.rel _ a2)).

rewrite !(Share.glb_commute (Share.rel _ b2)).

rewrite <- !Share.rel_preserves_glb.

rewrite H,H0.

rewrite !Share.rel_bot1.

rewrite (Share.lub_commute Share.bot).

rewrite !Share.lub_bot.

rewrite Share.glb_commute.

rewrite !glb_rel_Lsh_Rsh.

apply Share.lub_bot.

*

subst a3 b3.

rewrite !Share.rel_preserves_lub.

forget (Share.rel Share.Lsh a1) as La1.

forget (Share.rel Share.Rsh b1) as Rb1.

forget (Share.rel Share.Lsh a2) as La2.

forget (Share.rel Share.Rsh b2) as Rb2.

rewrite !Share.lub_assoc.

f_equal.

rewrite Share.lub_commute.

rewrite !Share.lub_assoc.

f_equal.

apply Share.lub_commute.

Qed.



Lemma splice_bot2:

 forall sh, Share.splice sh Share.bot = Share.rel Share.Lsh sh.

Proof.

intros.

unfold Share.splice.

rewrite Share.rel_bot1.

rewrite Share.lub_bot.

auto.

Qed.



Lemma splice_unrel_unrel:

  forall sh,

   Share.splice (Share.unrel Share.Lsh sh) (Share.unrel Share.Rsh sh) = sh.

Proof.

intros.

unfold Share.splice.

rewrite !share_rel_unrel'.

rewrite share_distrib2'.

rewrite Share.lub_idem.

rewrite lub_Lsh_Rsh.

rewrite (Share.glb_commute Share.top).

rewrite Share.glb_top.

rewrite <- Share.glb_assoc.

rewrite (Share.lub_commute sh).

rewrite share_distrib1'.

rewrite (Share.glb_commute Share.Rsh).

rewrite glb_Lsh_Rsh.

rewrite (Share.lub_commute Share.bot), Share.lub_bot.

rewrite Share.glb_idem.

rewrite (Share.glb_commute sh).

rewrite <- Share.lub_assoc.

rewrite Share.glb_commute.

rewrite Share.lub_commute.

rewrite Share.glb_absorb.

auto.

Qed.



Lemma join_splice2:

  forall a1 a2 a3 b1 b2 b3 : Share.t,

  join (Share.splice a1 b1) (Share.splice a2 b2) (Share.splice a3 b3) ->

  join a1 a2 a3 /\ join b1 b2 b3.

Proof.

intros.

unfold Share.splice in H.

destruct H.

unfold join, Share.Join_ba.

assert ((Share.glb a1 a2 = Share.bot /\ Share.glb b1 b2 = Share.bot)

         /\ (Share.lub a1 a2 = a3 /\ Share.lub b1 b2 = b3)); [ | intuition].

split.

*

clear - H.

rewrite share_distrib1' in H.

rewrite (Share.lub_commute (Share.glb _ _)) in H.

rewrite Share.lub_assoc in H.

rewrite <- (Share.lub_assoc (Share.glb (Share.rel Share.Lsh _) _)) in H.

rewrite (Share.lub_commute (Share.lub _ _)) in H.

rewrite <- Share.lub_assoc in H.

rewrite <- !Share.rel_preserves_glb in H.

rewrite (Share.glb_commute (Share.rel Share.Rsh _)) in H.

rewrite !glb_rel_Lsh_Rsh in H.

rewrite (Share.lub_commute Share.bot), !Share.lub_bot in H.

rewrite Share.lub_commute in H.

apply join_splice2_aux1; auto.

*

clear - H0.

rewrite Share.lub_assoc in H0.

rewrite (Share.lub_commute (Share.rel Share.Rsh _)) in H0.

rewrite <- !Share.lub_assoc in H0.

rewrite <- Share.rel_preserves_lub in H0.

rewrite Share.lub_assoc in H0.

rewrite <- Share.rel_preserves_lub in H0.

rewrite (Share.lub_commute b2) in H0.

apply join_splice2_aux; auto.

Qed.



Lemma nonidentity_rel_Lsh: forall t, nonidentity (Share.rel Share.Lsh t) -> nonidentity t.

Proof.

  intros.

  rewrite <- splice_bot2 in H.

  intro.

  apply H; clear H.

  intros ? ? ?.

  rewrite <- (splice_unrel_unrel a), <- (splice_unrel_unrel b) in H |- *.

  forget (Share.unrel Share.Lsh a) as sh0.

  forget (Share.unrel Share.Rsh a) as sh1.

  forget (Share.unrel Share.Lsh b) as sh2.

  forget (Share.unrel Share.Rsh b) as sh3.

  apply join_splice2 in H.

  destruct H.

  apply H0 in H.

  apply bot_identity in H1.

  subst.

  auto.

Qed.



Lemma readable_share_unrel_Rsh: forall sh, readable_share sh <-> nonunit (Share.unrel Share.Rsh sh).

unfold readable_share in *.

Proof.

intros.

unfold nonempty_share.

transitivity (nonidentity (Share.unrel Share.Rsh sh)).

unfold nonidentity.

split; intro; contradict H.

apply identity_share_bot in H.

rewrite <- share_rel_unrel'.

rewrite H.

rewrite Share.rel_bot1.

apply bot_identity.

rewrite <- share_rel_unrel' in H.

apply rel_nontrivial in H.

destruct H; auto.

elimtype False.

apply identity_share_bot in H.

unfold Share.Rsh in H.

destruct (Share.split Share.top) eqn:?. simpl in H. subst.

apply split_nontrivial' in Heqp.

apply identity_share_bot in Heqp.

apply Share.nontrivial; auto.

right.

apply bot_identity.

split.

apply nonidentity_nonunit.

intro.

hnf in H|-*; intro.

apply identity_share_bot in H0.

rewrite H0 in H.

apply (H Share.top).

red.

apply bot_join_eq.

Qed.



End UNPROVABLE.



