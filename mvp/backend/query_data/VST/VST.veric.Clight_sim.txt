Require Import VST.sepcomp.mem_lemmas.
(* VST.sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import VST.sepcomp.semantics.
(* VST.sepcomp.semantics:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.

Require Import VST.sepcomp.mem_lemmas.

Record CoreSemantics {C M : Type} : Type :=
  { initial_core : nat -> M -> C -> M -> val -> list val -> Prop
  ; at_external : C -> M -> option (external_function * list val)
  ; after_external : option val -> C -> M -> option C
  ; halted : C -> int -> Prop
  ; corestep : C -> M -> C -> M -> Prop
  ; corestep_not_halted:
      forall m q m' q' i, corestep q m q' m' -> ~ halted q i
  ; corestep_not_at_external:
      forall m q m' q', corestep q m q' m' -> at_external q m = None }.

Arguments CoreSemantics : clear implicits.

Inductive mem_step m m' : Prop :=
    mem_step_storebytes: forall b ofs bytes,
       Mem.storebytes m b ofs bytes = Some m' -> mem_step m m'
  | mem_step_alloc: forall lo hi b',
       Mem.alloc m lo hi = (m',b') -> mem_step m m'
  | mem_step_freelist: forall l,
       Mem.free_list m l = Some m' -> mem_step m m'
  
  | mem_step_trans: forall m'',
       mem_step m m'' -> mem_step m'' m' -> mem_step m m'.

Local Notation "a # b" := (PMap.get b a) (at level 1).
Record perm_lesseq (m m': mem):= {
  perm_le_Cur:
    forall b ofs, Mem.perm_order'' ((Mem.mem_access m')#b ofs Cur) ((Mem.mem_access m)#b ofs Cur)
; perm_le_Max:
    forall b ofs, Mem.perm_order'' ((Mem.mem_access m')#b ofs Max) ((Mem.mem_access m)#b ofs Max)
; perm_le_cont:
    forall b ofs, Mem.perm m b ofs Cur Readable ->
     ZMap.get ofs (Mem.mem_contents m') !! b= ZMap.get ofs (Mem.mem_contents m) !! b
; perm_le_nb: Mem.nextblock m = Mem.nextblock m'
}.

Record MemSem {C} :=
  { csem :> @CoreSemantics C mem

  ; corestep_mem : forall c m c' m' (CS: corestep csem c m c' m'), mem_step m m'
    }.

Arguments MemSem : clear implicits. *)

Require Import VST.veric.Clight_base.
(* VST.veric.Clight_base:
Require Export compcert.exportclight.Clightdefs.

Require Export VST.veric.base.
Require Export compcert.cfrontend.Ctypes.
Require Export compcert.cfrontend.Cop. 
Require Export compcert.cfrontend.Clight. 

Require Export EqNat.  

Require Export VST.veric.Memory. *)

Require Import VST.veric.Clight_lemmas.
(* VST.veric.Clight_lemmas:
Require Import VST.veric.Clight_base.
Require Import compcert.cfrontend.Clight.

Definition var_name (V: Type) (bdec: ident * globvar V) : ident :=
   fst bdec.

Definition no_dups (F V: Type) (fdecs: list (ident * F)) (bdecs: list (ident * globvar V)) : Prop :=
  list_norepet (map (@fst ident F) fdecs ++ map (@var_name V) bdecs).
Arguments no_dups [F V] _ _.

Lemma no_dups_inv:
  forall  (A V: Type) id f fdecs bdecs,
    no_dups ((id,f)::fdecs) bdecs ->
    no_dups fdecs bdecs /\
     ~ In id (map (@fst ident A) fdecs) /\
     ~ In id (map (@var_name V) bdecs).
Arguments no_dups_inv [A V] _ _ _ _ _.

Lemma of_bool_Int_eq_e:
  forall i j, Val.of_bool (Int.eq i j) = Vtrue -> i = j.

Lemma eq_block_lem:
    forall (A: Set) a (b: A) c, (if eq_block a a then b else c) = b.

Lemma signed_zero: Int.signed Int.zero = 0.

Lemma equiv_e1 : forall A B: Prop, A=B -> A -> B.
Arguments equiv_e1 [A B] _ _.

Lemma deref_loc_fun: forall {ty m b z v v'},
   Clight.deref_loc ty m b z v -> Clight.deref_loc ty m b z v' -> v=v'.

Lemma eval_expr_lvalue_fun:
  forall ge e le m,
    (forall a v v', Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v') /\

Lemma eval_expr_fun:   forall {ge e le m a v v'},
    Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v'.

Lemma eval_exprlist_fun:   forall {ge e le m a ty v v'},
    Clight.eval_exprlist ge e le m a ty v -> Clight.eval_exprlist ge e le m a ty v' -> v=v'.

Lemma eval_lvalue_fun:   forall {ge e le m a b b' z z'},
    Clight.eval_lvalue ge e le m a b z -> Clight.eval_lvalue ge e le m a b' z' -> (b,z)=(b',z').

Lemma inv_find_symbol_fun:
  forall {ge id id' b},
    Senv.find_symbol ge id = Some b ->

Lemma assign_loc_fun:
  forall {cenv ty m b ofs v m1 m2},
   assign_loc cenv ty m b ofs v m1 ->
   assign_loc cenv ty m b ofs v m2 ->
   m1=m2.

Lemma alloc_variables_fun:
  forall {ge e m vl e1 m1 e2 m2},
     Clight.alloc_variables ge e m vl e1 m1 ->

Lemma bind_parameters_fun:
  forall {ge e m p v m1 m2},
    Clight.bind_parameters ge e m p v m1 ->

Lemma eventval_list_match_fun:
  forall {se a a' t v},
    Events.eventval_list_match se a t v ->

Ltac fun_tac :=
  match goal with
  | H: ?A = Some _, H': ?A = Some _ |- _ => inversion2 H H'
  | H: Clight.eval_expr ?ge ?e ?le ?m ?A _,
    H': Clight.eval_expr ?ge ?e ?le ?m ?A _ |- _ =>
        apply (eval_expr_fun H) in H'; subst
  | H: Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _,
    H': Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _ |- _ =>
        apply (eval_exprlist_fun H) in H'; subst
  | H: Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _,
    H': Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _ |- _ =>
        apply (eval_lvalue_fun H) in H'; inv H'
  | H: Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _,
    H': Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _ |- _ =>
        apply (assign_loc_fun H) in H'; inv H'
  | H: Clight.deref_loc ?ty ?m ?b ?ofs _,
    H': Clight.deref_loc ?ty ?m ?b ?ofs _ |- _ =>
        apply (deref_loc_fun H) in H'; inv H'
  | H: Clight.alloc_variables ?ge ?e ?m ?vl _ _,
    H': Clight.alloc_variables ?ge ?e ?m ?vl _ _ |- _ =>
        apply (alloc_variables_fun H) in H'; inv H'
  | H: Clight.bind_parameters ?ge ?e ?m ?p ?vl _,
    H': Clight.bind_parameters ?ge ?e ?m ?p ?vl _ |- _ =>
        apply (bind_parameters_fun H) in H'; inv H'
  | H: Senv.find_symbol ?ge _ = Some ?b,
    H': Senv.find_symbol ?ge _ = Some ?b |- _ =>
       apply (inv_find_symbol_fun H) in H'; inv H'
  | H: Events.eventval_list_match ?ge _ ?t ?v,
    H': Events.eventval_list_match ?ge _ ?t ?v |- _ =>
       apply (eventval_list_match_fun H) in H'; inv H'
 end. *)

Require Import VST.veric.Clight_new.
(* VST.veric.Clight_new:
Require Import VST.sepcomp.semantics.
Require Import VST.veric.Clight_base.
Require Import VST.veric.Clight_lemmas.
Require compcert.common.Globalenvs.

Inductive cont': Type :=
  | Kseq: statement -> cont'       
  | Kloop1: statement -> statement -> cont'
  | Kloop2: statement -> statement  -> cont'
  | Kswitch: cont'       
  | Kcall: forall (l: option ident),                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont'.

Definition cont := list cont'.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k => call_cont k
  | Kloop1 _ _ :: k => call_cont k
  | Kloop2 _ _ :: k => call_cont k
  | Kswitch :: k => call_cont k
  | _ => k
  end.

Fixpoint current_function (k: cont) : option function :=
 match k with
  | Kseq s :: k => current_function k
  | Kloop1 _ _ :: k => current_function k
  | Kloop2 _ _:: k =>current_function k
  | Kswitch :: k => current_function k
  | Kcall _ f _ _ :: _ => Some f
  | _ => None
  end.

Fixpoint continue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => continue_cont k'
  | Kloop1 s1 s2 :: k' => Kseq s2 :: Kloop2 s1 s2 :: k'
  | Kswitch :: k' => continue_cont k'
  | _ => nil 
  end.

Lemma call_cont_nonnil: forall k f, current_function k = Some f -> call_cont k <> nil.

Fixpoint precontinue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => precontinue_cont k'
  | Kloop1 _ _ :: _ => k
  | Kswitch :: k' => precontinue_cont k'
  | _ => nil 
  end.

Fixpoint break_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => break_cont k'
  | Kloop1 _ _ :: k' => k'
  | Kloop2 _ _ :: k' => k'
  | Kswitch :: k' => k'
  | _ =>  nil 
  end.

Inductive corestate :=
 | State: forall (ve: env) (te: temp_env) (k: cont), corestate
 | ExtCall: forall (ef: external_function) (args: list val)
                   (lid: option ident) (ve: env) (te: temp_env) (k: cont),
                corestate.

Fixpoint strip_skip (k: cont) : cont :=
 match k with Kseq Sskip :: k' => strip_skip k' | _ => k end.

Definition cl_at_external (c: corestate) : option (external_function * list val) :=
  match c with
  | State _ _ k => None
  | ExtCall ef args lid ve te k => Some (ef, args)
 end.

Definition cl_after_external (vret: option val) (c: corestate) : option corestate :=
  match vret, c with
  | Some v, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id v te) k)
  | None, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id Vundef te) k)
  | Some v, ExtCall ef args None ve te k => Some (State ve te k)
  | None, ExtCall ef args None ve te k => Some (State ve te k)
  | _, _ => None
  end.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option cont :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 :: k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 a3 =>
      match find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 a3 :: k) with
      | Some sk => Some sk
      | None => find_label lbl a3 (Kloop2 s1 a3 :: k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch :: k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(Kseq s' :: k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option cont :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') :: k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Inductive cl_step (ge: Clight.genv): forall (q: corestate) (m: mem) (q': corestate) (m': mem), Prop :=

  | step_assign: forall ve te k m a1 a2 loc ofs v2 v m',
     type_is_volatile (typeof a1) = false ->
      Clight.eval_lvalue ge ve te m a1 loc ofs ->
      Clight.eval_expr ge ve te m a2 v2 ->
      Cop.sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      Clight.assign_loc ge (typeof a1) m loc ofs v m' ->
      cl_step ge (State ve te (Kseq (Sassign a1 a2):: k)) m (State ve te k) m'

  | step_set:   forall ve te k m id a v,
      Clight.eval_expr ge ve te m a v ->
      cl_step ge (State ve te (Kseq (Sset id a) :: k)) m (State ve (PTree.set id v te) k) m

  | step_call_internal:   forall ve te k m optid a al tyargs tyres cc vf vargs f m1 ve' le',
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (Internal f) ->
      type_of_function f = Tfunction tyargs tyres cc ->
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_temps)) ->
      forall (NRV: list_norepet (var_names f.(fn_vars))),
      Clight.alloc_variables ge empty_env m (f.(fn_vars)) ve' m1 ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some
le' ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m
                   (State ve' le' (Kseq f.(fn_body) :: Kseq (Sreturn None) :: Kcall optid f ve te :: k)) m1

  | step_call_external:   forall ve te k m optid a al tyargs tyres cc vf vargs ef,
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (External ef tyargs tyres cc) ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m (ExtCall ef vargs optid ve te k) m

  | step_seq: forall ve te k m s1 s2 st' m',
          cl_step ge (State ve te (Kseq s1 :: Kseq s2 :: k)) m st' m' ->
          cl_step ge (State ve te (Kseq (Ssequence s1 s2) :: k)) m st' m'

  | step_skip: forall ve te k m st' m',
          cl_step ge (State ve te k) m st' m' ->
          cl_step ge (State ve te (Kseq Sskip :: k)) m st' m'

  | step_continue: forall ve te k m st' m',
           cl_step ge (State ve te (continue_cont k)) m st' m' ->
           cl_step ge (State ve te (Kseq Scontinue :: k)) m st' m'

  | step_break: forall ve te k m st' m',
                   cl_step ge (State ve te (break_cont k)) m st' m' ->
                   cl_step ge (State ve te (Kseq Sbreak :: k)) m st' m'

  | step_ifthenelse:  forall ve te k m a s1 s2 v1 b,
      Clight.eval_expr ge ve te m a v1 ->
      Cop.bool_val v1 (typeof a) m = Some b ->
      cl_step ge (State ve te (Kseq (Sifthenelse a s1 s2) :: k)) m (State ve te  (Kseq (if b then s1 else s2) :: k)) m

  | step_for: forall ve te k m s1 s2,
      cl_step ge (State ve te (Kseq (Sloop s1 s2) :: k)) m
              (State ve te (Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: k)) m

  | step_loop2: forall ve te k m a3 s,
      cl_step ge (State ve te (Kloop2 s a3 :: k)) m
             (State ve te (Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: k)) m

  | step_return: forall f ve te optexp optid k m v' m' ve' te' te'' k',
      call_cont k = Kcall optid f ve' te' :: k' ->
      Mem.free_list m (Clight.blocks_of_env ge ve) = Some m' ->
      match optexp with None => v' = Vundef
                                  | Some a => exists v, Clight.eval_expr ge ve te m a v
                                     /\ Cop.sem_cast v (typeof a) f.(fn_return) m = Some v'
                            end ->
      match optid with None => True /\ te''=te'
                                | Some id => True /\ te'' = PTree.set id v' te'
      end ->
      cl_step ge (State ve te (Kseq (Sreturn optexp) :: k)) m (State ve' te'' k') m'

  | step_switch: forall ve te k m a sl v n,
      Clight.eval_expr ge ve te m a v ->
      Cop.sem_switch_arg v (typeof a) = Some n ->
      cl_step ge (State ve te (Kseq (Sswitch a sl) :: k)) m
              (State ve te (Kseq (seq_of_labeled_statement (select_switch n sl)) :: Kswitch :: k)) m

  | step_label: forall ve te k m lbl s st' m',
       cl_step ge (State ve te (Kseq s :: k)) m st' m' ->
       cl_step ge (State ve te (Kseq (Slabel lbl s) :: k)) m st' m'

  | step_goto: forall f ve te k m lbl k'
                     
      (CUR: current_function k = Some f),
      find_label lbl f.(fn_body) (Kseq (Sreturn None) :: (call_cont k)) = Some k' ->
      cl_step ge (State ve te (Kseq (Sgoto lbl) :: k)) m (State ve te k') m.

Definition vret2v (vret: list val) : val :=
  match vret with v::nil => v | _ => Vundef end.

Definition cl_halted (c: corestate) : option val := None.

Definition empty_function : function := mkfunction Tvoid cc_default nil nil nil Sskip.

Fixpoint temp_bindings (i: positive) (vl: list val) :=
 match vl with
 | nil => PTree.empty val
 | v::vl' => PTree.set i v (temp_bindings (i+1)%positive vl')
 end.

Definition Tint32s := Tint I32 Signed noattr.
Definition true_expr : Clight.expr := Clight.Econst_int Int.one Tint32s.

Fixpoint typed_params (i: positive) (n: nat) : list (ident * type) :=
  match n with
  | O => nil
  | S n' => (i, Tint32s) :: typed_params (i+1)%positive n'
  end.

Fixpoint params_of_types (i: positive) (l : list type) : list (ident * type) :=
  match l with
  | nil => nil
  | t :: l => (i, t) :: params_of_types (i+1)%positive l
  end.

Fixpoint typelist2list (tl: typelist) : list type :=
  match tl with
  | Tcons t r => t::typelist2list r
  | Tnil => nil
  end.

Definition params_of_fundef (f: fundef) : list type :=
  match f with
  | Internal {| fn_params := fn_params |} => map snd fn_params
  | External _ t _ _ => typelist2list t
  end.

Inductive val_casted_list: list val -> typelist -> Prop :=
  | vcl_nil:
      val_casted_list nil Tnil
  | vcl_cons: forall v1 vl ty1 tyl,
      val_casted v1 ty1 -> val_casted_list vl tyl ->
      val_casted_list (v1 :: vl) (Tcons  ty1 tyl).

Definition cl_initial_core (ge: genv) (v: val) (args: list val) (q: corestate) : Prop :=
  match v with
    Vptr b i =>
    if Ptrofs.eq_dec i Ptrofs.zero then
      match Genv.find_funct_ptr ge b with
        Some f =>
        match type_of_fundef f with Tfunction targs _ c =>
        c = cc_default /\
        val_casted_list args targs /\
        Val.has_type_list args (Ctypes.typlist_of_typelist targs) /\
        q = State empty_env (temp_bindings 1%positive (v::args))
                    (Kseq (Scall None
                                 (Etempvar 1%positive (type_of_fundef f))
                                 (map (fun x => Etempvar (fst x) (snd x))
                                      (params_of_types 2%positive
                                                       (params_of_fundef f)))) ::
                          Kseq (Sloop Sskip Sskip) :: nil)
        | _ => False end
      | _ => False end
    else False
  | _ => False
end.

Lemma cl_corestep_not_at_external:
  forall ge m q m' q', cl_step ge q m q' m' -> cl_at_external q = None.

Lemma cl_corestep_not_halted :
  forall ge m q m' q', cl_step ge q m q' m' -> cl_halted q = None.

Lemma cl_after_at_external_excl :
  forall retv q q', cl_after_external retv q = Some q' -> cl_at_external q' = None.

Definition arg_well_formed args m0:=
  Val.inject_list (Mem.flat_inj (Mem.nextblock m0)) args args.

Program Definition cl_core_sem  (ge: genv):
  @CoreSemantics corestate mem :=
  @Build_CoreSemantics _ _
    
    (fun _ m c m' v args => cl_initial_core ge v args c /\ arg_well_formed args m /\ m' = m)
    (fun c _ => cl_at_external c)
    (fun ret c _ => cl_after_external ret c)
    (fun c _ =>  False )
    (cl_step ge)
    _
    (cl_corestep_not_at_external ge).

Lemma cl_corestep_fun: forall ge m q m1 q1 m2 q2,
    cl_step ge q m q1 m1 ->
    cl_step ge q m q2 m2 ->
    (q1,m1)=(q2,m2). *)

Require compcert.cfrontend.Clight.

Module CC := Clight.

Require VST.veric.Clight_core.

Module CC' := Clight_core.

Section GE.

Variable ge : genv.

Definition CCstep s1 s2 := 

  Clight_core.at_external s1 = None /\

  Clight.step ge (Clight.function_entry2 ge) s1 Events.E0 s2.



Fixpoint strip_skip' (k: CC.cont) : CC.cont :=

 match k with

 | CC.Kseq Sskip k' => strip_skip' k'

 | _ => k

 end.



Inductive match_cont:  cont -> CC.cont -> Prop :=

  | match_cont_nil: match_cont nil CC.Kstop

  | match_cont_seq: forall s k k',

         match_cont (strip_skip k) (strip_skip' k') ->

          match_cont (Kseq s :: k) (CC.Kseq s k')

  | match_cont_loop1: forall e3 s k k',

         match_cont (strip_skip k) (strip_skip' k') ->

          match_cont (Kseq Scontinue :: Kloop1 s e3 :: k) (CC.Kloop1 s e3 k')

  | match_cont_loop2: forall e3 s k k',

         match_cont (strip_skip k) (strip_skip' k') ->

          match_cont (Kloop2 s e3 :: k) (CC.Kloop2 s e3 k')

  | match_cont_switch: forall k k',

         match_cont (strip_skip k) (strip_skip' k') ->

          match_cont (Kswitch :: k) (CC.Kswitch k')

  | match_cont_call: forall lid fd f ve te k k'

         (CUR: match current_function k with Some f' => f'=f | _ => True end),

         match_cont (strip_skip k) (strip_skip' k') ->

          match_cont (Kseq (Sreturn None) :: Kcall lid fd ve te :: k) (CC.Kcall lid f ve te k').



Inductive star: state -> state -> Prop :=

  | star_refl: forall s,

      star s s

  | star_step: forall s1 s2 s3,

      CCstep s1 s2 -> star s2 s3 -> star s1 s3.



Lemma star_one:

  forall s1 s2, CCstep s1 s2 -> star s1 s2.

Proof.

  intros. eapply star_step; eauto. apply star_refl.

Qed.



Lemma star_two:

  forall s1 s2 s3,

  CCstep s1 s2 -> CCstep s2 s3 ->

  star s1 s3.

Proof.

  intros. eapply star_step; eauto. apply star_one; auto.

Qed.



Lemma star_trans:

  forall {s1 s2}, star s1 s2 ->

  forall {s3}, star s2 s3 -> star s1 s3.

Proof.

  induction 1; intros; auto.

  eapply star_step; eauto.

Qed.



Inductive plus: state -> state -> Prop :=

  | plus_left: forall s1 s2 s3,

      CCstep s1 s2 -> star s2 s3 -> plus s1 s3.



Lemma plus_one:

  forall s1 s2, CCstep s1 s2 -> plus s1 s2.

Proof.

  intros. eapply plus_left; eauto. apply star_refl.

Qed.



Lemma plus_two:

  forall s1 s2 s3, CCstep s1 s2 -> CCstep s2 s3 -> plus s1 s3.

Proof.

  intros. eapply plus_left; eauto. apply star_one; auto.

Qed.



Lemma plus_star: forall s1 s2, plus s1 s2 -> star s1 s2.

Proof.

  intros. inv H. eapply star_step; eauto.

Qed.



Lemma plus_trans: forall {s1 s2 s3},

   plus s1 s2 -> plus s2 s3 -> plus s1 s3.

Proof.

 intros.

  inv H. eapply plus_left. eauto.

  apply @star_trans with (s2:=s2); eauto.

  apply plus_star. auto.

Qed.



Lemma star_plus_trans: forall {s1 s2 s3},

   star s1 s2 -> plus s2 s3 -> plus s1 s3.

Proof.

 intros. inv H. auto. eapply plus_left; eauto.

 eapply star_trans; eauto. apply plus_star; auto.

Qed.



Lemma plus_star_trans: forall {s1 s2 s3},

   plus s1 s2 -> star s2 s3 -> plus s1 s3.

Proof.

 intros.

 inv H. eapply plus_left; eauto. eapply star_trans; eauto.

Qed.



Lemma exec_skips:

 forall {s0 k s k'}

   (H1: match_cont (Kseq s0 :: k) (strip_skip' (CC.Kseq s k')))

   f ve te m,

   match s0 with Sskip => False | Scontinue => False | Sloop _ _ => False

            | Sifthenelse _ _ _ => False | Sreturn _ => False

            | _ => True end ->

   exists k2, strip_skip' (CC.Kseq s k') = CC.Kseq s0 k2 /\

     star (CC.State f s k' ve te m) (CC.State f s0 k2 ve te m).

Proof.

 intros.

 remember (CC.Kseq s k') as k0.

 revert k s k' H1 Heqk0; induction k0; intros; inv Heqk0.

 assert ({s1=Sskip}+{s1<>Sskip}) by (destruct s1; try (left; congruence); right; congruence).

 destruct H0. subst s1.

 destruct k'; try solve [inv H1].

 specialize (IHk0 _ s k' H1 (eq_refl _)).

 destruct IHk0 as [k2 [? ?]].

 exists k2. split; simpl; auto.

 econstructor 2. split;[reflexivity|]. constructor. auto.

 inv H1; contradiction. simpl in *. inv H1. contradiction.

  replace (strip_skip' (CC.Kseq s1 k')) with (CC.Kseq s1 k')  in *

     by (destruct s1; try congruence; auto).

 inv H1.

 exists k'; split; auto.

 constructor 1.

Qed.



Lemma strip_skip_not:

  forall s k, s<>Sskip -> strip_skip (Kseq s :: k) = (Kseq s :: k).

Proof.

 destruct s; intros; auto. congruence.

Qed.

Lemma strip_skip'_not:

  forall s k, s<>Sskip -> strip_skip' (CC.Kseq s k) = (CC.Kseq s k).

Proof.

 destruct s; intros; auto. congruence.

Qed.



Lemma dec_skip: forall s, {s=Sskip}+{s<>Sskip}.

Proof.

 destruct s; try (left; congruence); right; congruence.

Qed.



Lemma dec_continue: forall s, {s=Scontinue}+{s<>Scontinue}.

Proof.

 destruct s; try (left; congruence); right; congruence.

Qed.



Lemma strip_step:

  forall ge ve te k m st' m',

     cl_step ge (State ve te (strip_skip k)) m st' m' <->

    cl_step ge (State ve te k) m st' m'.

Proof.

intros.

 induction k; intros; split; simpl; intros; try destruct IHk; auto.

 destruct a; try destruct s; auto.

  constructor; auto.

 destruct a; try destruct s; auto.

 inv H. auto.

Qed.



Lemma continue_cont_skip:

  forall k, continue_cont k = continue_cont (strip_skip k).

Proof.

 induction k; simpl; intros; auto.

 destruct a; auto. destruct s; auto.

Qed.



Lemma break_cont_skip:

    forall k, break_cont (strip_skip k) = break_cont k.

Proof. induction k; try destruct a; simpl; auto; destruct s; simpl; auto.

Qed.



Lemma continue_cont_is:

 forall k, match (continue_cont k) with nil => True | Kseq e3 :: Kloop2 s e3' :: _ => e3=e3' | _ => False end.

Proof.

 induction k; simpl; auto; try contradiction.

  destruct a; auto.

Qed.



Lemma match_cont_strip:

   forall s k k', match_cont (strip_skip k) (strip_skip' k') ->

           match_cont (strip_skip (Kseq s :: k)) (strip_skip' (CC.Kseq s k')).

 Proof.

 intros.  destruct (dec_skip s). subst. simpl; auto.

  rewrite strip_skip_not by auto. rewrite strip_skip'_not by auto.

  constructor; auto.

 Qed.



Lemma exec_skips':

  forall f s k' s0 k0' ve te m,

        strip_skip' (CC.Kseq s k') = CC.Kseq s0 k0' ->

        star (CC.State f s k' ve te m) (CC.State f s0 k0' ve te m).

Proof.

 intros.

 destruct (dec_skip s). subst. simpl in *.

 induction k'; try solve [inv H].

 destruct (dec_skip s). subst. simpl in *.

 econstructor 2; eauto. split;[reflexivity|]. constructor. auto. rewrite strip_skip'_not in * by auto.

 inv H. econstructor 2; eauto. split;[reflexivity|]. constructor. constructor 1. auto.

 rewrite strip_skip'_not in H by auto. inv H. constructor 1.

Qed.



Lemma break_strip:

 forall f ve te m k,

     star (CC.State f Sbreak k ve te m) (CC.State f Sbreak (strip_skip' k) ve te m).

 Proof. induction k; try solve [constructor 1].

    destruct (dec_skip s). subst. simpl.

     econstructor 2. split;[reflexivity|]. constructor. eauto. auto.

  rewrite strip_skip'_not; auto. constructor 1.

Qed.



Lemma strip_skip'_loop2:

  forall f ve te m a3 s k1 k, CC.Kloop2 a3 s k1 = strip_skip' k ->

  star (CC.State f Sskip k ve te m) (CC.State f Sskip (CC.Kloop2 a3 s k1) ve te m).

Proof.

 induction k; intros; try solve [inv H].

 destruct (dec_skip s0). subst. eapply star_trans; try apply IHk; auto. apply star_one.

 split;[reflexivity|]. constructor. auto.

 rewrite strip_skip'_not in * by auto.

 rewrite <- H. constructor 1. simpl in H. inv H. constructor 1.

Qed.



Lemma call_strip: forall k, call_cont (strip_skip k) = call_cont k.

Proof.

 induction k; simpl; intros; auto. destruct a; simpl; auto. destruct s; simpl; auto.

Qed.



Lemma strip_call: forall k, strip_skip (call_cont k) = call_cont k.

Proof.

 induction k; simpl; intros; auto. destruct a; simpl; auto.

Qed.



Lemma call_strip': forall k, CC.call_cont (strip_skip' k) = CC.call_cont k.

Proof.

 induction k; simpl; intros; auto. destruct s; simpl; auto.

Qed.



Lemma strip_call': forall k, strip_skip' (CC.call_cont k) = CC.call_cont k.

Proof.

 induction k; simpl; intros; auto.

Qed.



Lemma strip_skip'_loop1:

  forall f ve te m a3 s k1 k, CC.Kloop1 a3 s k1 = strip_skip' k ->

  star (CC.State f Sskip k ve te m) (CC.State f Sskip (CC.Kloop1 a3 s k1) ve te m).

Proof.

 induction k; intros; try solve [inv H].

 destruct (dec_skip s0). subst. eapply star_trans; try apply IHk; auto. apply star_one.

 split;[reflexivity|]. constructor. auto.

 rewrite strip_skip'_not in * by auto.

 rewrite <- H. constructor 1. simpl in H. inv H. constructor 1.

Qed.



Lemma strip_skip'_call:

  forall f ve te m lid f' ve' te' k1 k, CC.Kcall lid f' ve' te' k1 = strip_skip' k ->

  star (CC.State f Sskip k ve te m) (CC.State f Sskip (CC.Kcall lid f' ve' te' k1) ve te m).

Proof.

 induction k; intros; try solve [inv H].

 destruct (dec_skip s). subst. eapply star_trans; try apply IHk; auto. apply star_one.

 split;[reflexivity|]. constructor. auto.

 rewrite strip_skip'_not in * by auto.

 rewrite <- H. constructor 1. simpl in H. inv H. constructor 1.

Qed.



Lemma match_cont_call_strip:

 forall k k',

    call_cont k <> nil ->

    match_cont (strip_skip k) (strip_skip' k') ->

   match_cont (Kseq (Sreturn None) :: call_cont k) (CC.call_cont k').

Proof.

 intros.

 rewrite <- call_strip in *. rewrite <- call_strip'.

 forget (strip_skip k) as k1. forget (strip_skip' k') as k1'.

 revert H; induction H0; simpl; intros; try rewrite call_strip in *; try rewrite call_strip' in *; auto.

 congruence.

 constructor; auto.

Qed.



Lemma match_cont_strip1:

  forall k k', match_cont k k' -> match_cont (strip_skip k) (strip_skip' k').

 Proof. induction 1; try solve [constructor; auto].

 apply match_cont_strip. auto.

Qed.



Lemma match_find_label_None:

  forall lbl s1 k0 k0',      match_cont (strip_skip k0)  (strip_skip' k0') ->

     find_label lbl s1 k0 = None -> CC.find_label lbl s1 k0' = None

 with match_find_ls_None:

   forall lbl ls k0 k0',  match_cont (strip_skip k0)  (strip_skip' k0') ->

     find_label_ls lbl ls k0 = None -> CC.find_label_ls lbl ls k0' = None.

Proof. induction s1; intros; simpl in *; auto.

 revert H0; case_eq (find_label lbl s1_1 (Kseq s1_2 :: k0)); intros. inv H1.

 erewrite IHs1_1; eauto. apply match_cont_strip. auto.

 revert H0; case_eq (find_label lbl s1_1 k0); intros. inv H1.

 erewrite IHs1_1; eauto.

 revert H0; case_eq (find_label lbl s1_1 (Kseq Scontinue :: Kloop1 s1_1 s1_2 :: k0)); intros. inv H1.

 erewrite IHs1_1; eauto. erewrite IHs1_2; eauto. simpl. constructor. auto.

 simpl. constructor; auto.

 eapply match_find_ls_None; eauto. constructor. auto.

 if_tac. subst. inv H0. eapply match_find_label_None; eauto.

 induction ls; intros; simpl in *; auto.

 revert H0; case_eq (find_label lbl s (Kseq (seq_of_labeled_statement ls) :: k0)); intros.

 inv H1.

 erewrite match_find_label_None; eauto. apply match_cont_strip. auto.

Qed.



Lemma match_find_label: forall lbl k' s1 k0 k0',

     match_cont (strip_skip k0) (strip_skip' k0') ->

     (find_label lbl s1 k0 = Some k' ->

      exists s2 : statement, exists k2' : CC.cont,

       CC.find_label lbl s1 k0' = Some (s2, k2') /\

       match_cont k' (CC.Kseq s2 k2'))

 with match_find_label_ls: forall lbl k' s1 k0 k0',

     match_cont (strip_skip k0) (strip_skip' k0') ->

     (find_label_ls lbl s1 k0 = Some k' ->

      exists s2 : statement, exists k2' : CC.cont,

       CC.find_label_ls lbl s1 k0' = Some (s2, k2') /\

       match_cont k' (CC.Kseq s2 k2')).

Proof.

 induction s1; intros; simpl in *; intuition; try discriminate.

 revert H0; case_eq (find_label lbl s1_1 (Kseq s1_2 :: k0)); intros.

 inv H1.

 destruct (IHs1_1 (Kseq s1_2 :: k0) (CC.Kseq s1_2 k0')) as [s2 [k2' [? ?]]]; clear IHs1_1.

 apply match_cont_strip. auto. auto.

 exists s2; exists k2'; split; auto. rewrite H1; auto.

  destruct (IHs1_2 k0 k0') as [s2 [k2' [? ?]]]; clear IHs1_1 IHs1_2; auto.

 exists s2, k2'; split; auto.

 erewrite match_find_label_None; eauto.

  apply match_cont_strip. auto.

 revert H0; case_eq (find_label lbl s1_1 k0); intros. inv H1.

 destruct (IHs1_1 k0 k0') as [s2 [k2' [? ?]]]; clear IHs1_1; auto.

 exists s2, k2'; split; auto.

 rewrite H1. auto.

  destruct (IHs1_2 k0 k0') as [s2 [k2' [? ?]]]; clear IHs1_1 IHs1_2; auto.

 exists s2, k2'; split; auto.

 erewrite match_find_label_None; eauto.

 revert H0; case_eq (find_label lbl s1_1 (Kseq Scontinue :: Kloop1 s1_1 s1_2 :: k0)); intros.

 inv H1.

 destruct (IHs1_1 (Kseq Scontinue :: Kloop1 s1_1 s1_2 :: k0) (CC.Kloop1 s1_1 s1_2 k0')) as [s2 [k2' [? ?]]]; clear IHs1_1; auto.

 simpl. constructor; auto.

 exists s2, k2'; split; auto. rewrite H1. auto.

 destruct (IHs1_2 (Kloop2 s1_1 s1_2 :: k0) (CC.Kloop2 s1_1 s1_2 k0')) as [s2 [k2' [? ?]]]; clear IHs1_1; auto.

 constructor; auto.

 exists s2, k2'; split; auto.

 erewrite match_find_label_None; eauto.  simpl. constructor; auto.

 destruct (match_find_label_ls lbl k' l (Kswitch :: k0) (CC.Kswitch k0')) as [s2 [k2' [? ?]]]; auto.

 constructor; auto.

 exists s2, k2'; split; auto.

 if_tac. subst l.

 exists s1, k0'; split; auto. inv H0; constructor; auto.

 destruct (IHs1 k0 k0') as [s2 [k2' [? ?]]]; auto.

 exists s2, k2'; split; auto.



 clear match_find_label_ls.

 induction s1; intros. simpl in *.

 inv H0.

 simpl in H0.

 destruct (find_label lbl s (Kseq (seq_of_labeled_statement s1) :: k0))

   eqn:?; auto.

 *

  destruct (match_find_label lbl k' s (Kseq (seq_of_labeled_statement s1) :: k0) (CC.Kseq (seq_of_labeled_statement s1)  k0')) as [s2 [k2' [? ?]]]; auto.

  apply match_cont_strip. auto.

  inv H0.

  auto.

  inv H0.

 exists s2, k2'; split; auto.

 simpl.

 rewrite H1. auto.

 *

  simpl.

 destruct (IHs1 _ _ H H0) as [s3 [k3' [? ?]]].

 exists s3, k3'; split; auto.

 erewrite match_find_label_None; try eassumption.

 apply match_cont_strip. auto.

Qed.



Lemma current_function_strip: forall k, current_function (strip_skip k) = current_function k.

Proof.

 induction k; try destruct a; try destruct s; simpl; auto.

Qed.



 Lemma current_function_call_cont:

   forall k, current_function (call_cont k) = current_function k.

 Proof. induction k; try destruct a; simpl; auto. Qed.



 Lemma current_function_find_label:

  forall lbl f s k k', current_function k = Some f ->

              find_label lbl s k = Some k' ->

              current_function k' = Some f

 with current_function_find_label_ls:

  forall lbl f s k k', current_function k = Some f ->

              find_label_ls lbl s k = Some k' ->

              current_function k' = Some f.

 Proof.

   induction s; simpl; intros; try discriminate.

   revert H0; case_eq (find_label lbl s1 (Kseq s2 :: k)); intros. inv H1.

   eapply IHs1; [ | eauto]. simpl; auto.

   eapply IHs2; [ | eauto]. simpl; auto.

 revert H0; case_eq (find_label lbl s1 k); intros. inv H1.

   eapply IHs1; [ | eauto]. simpl; auto.

   eapply IHs2; [ | eauto]. simpl; auto.

 revert H0; case_eq (find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 s2 :: k)); intros. inv H1.

   eapply IHs1; [ | eauto]. simpl; auto.

   eapply IHs2; [ | eauto]. simpl; auto.

  eapply current_function_find_label_ls; [ | eauto]. simpl; auto.

  if_tac in H0. inv H0. simpl. auto.

   eapply IHs; [ | eauto]. simpl; auto.



   induction s; simpl; intros; try discriminate.

  revert H0; case_eq (find_label lbl s (Kseq (seq_of_labeled_statement s0) :: k)); intros.

 inv H1.

  eapply current_function_find_label; [ | eauto]. simpl; auto.

   eapply IHs; [ | eauto]. simpl; auto.

 Qed.



Lemma step_continue_strip:

  forall f k ve te m,

           star (CC.State f Scontinue k ve te m)

               (CC.State f Scontinue (strip_skip' k) ve te m).

Proof.

intros.

induction k; simpl; try constructor 1.

destruct (dec_skip s).

subst.

eapply star_trans.

  apply @star_one. split;[reflexivity|]. apply CC.step_continue_seq.

  apply IHk.

auto.

destruct s; try congruence; constructor 1.

Qed.



Inductive match_states: forall (qm: corestate) (st: CC'.CC_core), Prop :=

 | match_states_seq: forall f ve te s k k'

      (CUR: match current_function k with Some f' => f'=f | _ => True end),

      match_cont (strip_skip k) (strip_skip' (CC.Kseq s k')) ->

      match_states (State ve te k) (CC'.CC_core_State f s k' ve te)

 | match_states_ext: forall k f ef tyargs tyres cc args lid ve te k'

      (CUR: match current_function k with Some f' => f'=f | _ => True end),

      match_cont (strip_skip k) (strip_skip' k') ->

      match_states (ExtCall ef args lid ve te k)

           (CC'.CC_core_Callstate (External ef tyargs tyres cc) args (CC.Kcall lid f ve te k')).



Lemma Clightnew_Clight_sim_eq_noOrder_SSplusConclusion:

forall (c1 : corestate) (m : mem) (c1' : corestate) (m' : mem),

corestep (cl_core_sem ge) c1 m c1' m' ->

forall (c2 : CC'.CC_core),

 match_states c1 c2 ->

exists c2' : CC'.CC_core,

    plus (CC'.CC_core_to_CC_state c2 m) (CC'.CC_core_to_CC_state c2' m') /\

    match_states c1' c2'.

Proof.

intros.

simpl in H.



revert c2 H0. induction H; intros.



* 

inv H4.

simpl strip_skip in H9.

destruct (exec_skips H9 f ve te m) as [k2 [? ?]]; simpl; auto.

exists (CC'.CC_core_State f Sskip k2 ve te); split.

    eapply star_plus_trans. eassumption.

          apply plus_one. split;[reflexivity|]. econstructor; eauto.

    constructor. apply CUR.  rewrite  H4 in H9.  inv H9.  simpl in *. apply H7.



*  

inv H0.

destruct (exec_skips H5 f ve te m) as [k2 [? ?]]; simpl; auto.

exists (CC'.CC_core_State f Sskip k2 ve (PTree.set id v te)); split.

  eapply star_plus_trans. eassumption. apply plus_one.

  split;[reflexivity|]. econstructor; eauto.

  rewrite H0 in H5. inv H5; constructor; auto.



* 

inv H7.

 destruct (exec_skips H12 f0 ve te m) as [k2 [? ?]]; simpl; auto.

 rewrite H7 in *. inv H12. simpl in CUR.

  exists (CC'.CC_core_State f (fn_body f) (CC.Kcall optid f0 ve te k2) ve' le').

  split.

  + eapply star_plus_trans. apply H8.

               eapply plus_two. split;[reflexivity|]. econstructor; eauto.

               split;[reflexivity|]. econstructor; eauto.

               apply list_norepet_app in H4. destruct H4 as [? [? ?]].

               econstructor; auto.

  + constructor.

     simpl; auto.

     apply match_cont_strip. simpl. constructor; auto.



* 

inv H3.

 destruct (exec_skips H8 f ve te m) as [k2 [? ?]]; simpl; auto.

 rewrite H3 in *. inv H8. simpl in CUR.

  exists (CC'.CC_core_Callstate (External ef tyargs tyres cc) vargs (CC.Kcall optid f ve te k2)).

  split.

  + eapply star_plus_trans. eassumption. eapply plus_one.

    split;[reflexivity|]. econstructor; eauto.

  + econstructor; eauto.



* 

 inv H0.

 destruct (exec_skips H5 f ve te m) as [k2 [? ?]]; simpl; auto.

 rewrite H0 in *. inv H5.

 destruct (IHcl_step (CC'.CC_core_State f s1 (CC.Kseq s2 k2) ve te))

                as [st2 [? ?]]; clear  IHcl_step.

 repeat constructor; auto.

 apply match_cont_strip.  apply match_cont_strip.  auto.

 exists st2; split; auto.

 eapply star_plus_trans; [ eassumption | ].

 eapply plus_trans. apply @plus_one.

 split;[reflexivity|]. constructor. eassumption.



* 

 inv H0.

 simpl strip_skip in H5.

 remember (strip_skip k) as k0.

 destruct k0.

 elimtype False; clear - H Heqk0.

 revert H; induction k; intros. inv H.

 forget (a::k) as k';  clear - Heqk0 H.

 remember (State ve te k') as s.

 revert ve te k' Heqs Heqk0; induction H; intros; inv Heqs; simpl in *; try congruence.

 eapply IHcl_step. reflexivity. auto.

 remember (strip_skip' (CC.Kseq s k')) as k0'.

 destruct k0'; inv H5;

  try solve [rewrite <- strip_step in H; rewrite <- Heqk0 in H; inv H].

 +

 assert (s0<>Sskip).

 clear- Heqk0; intro; subst.

 revert Heqk0; induction k; simpl; intros. inv Heqk0. destruct a; try solve [inv Heqk0]; auto. destruct s; inv Heqk0; auto.

 destruct (IHcl_step (CC'.CC_core_State f s k' ve te))

                 as [st2 [? ?]]; clear  IHcl_step.

 constructor; auto. rewrite <- Heqk0. rewrite <- Heqk0'.

 constructor 2; auto.

 exists st2; split; auto.

 +

 destruct (IHcl_step (CC'.CC_core_State f Sskip (CC.Kloop1 s0 s1 k0') ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

 constructor; auto. simpl. rewrite <- Heqk0. constructor. auto.

  exists st2; split; auto.

 inv H0.

 eapply plus_star_trans; try apply H4.

 clear - H3 Heqk0'.

 destruct s; inv Heqk0'.

 rewrite H0 in H3.

 eapply star_plus_trans; [ | apply plus_one; eauto ].

 rewrite <- H0;

 apply strip_skip'_loop1; auto.

 +

 destruct (IHcl_step (CC'.CC_core_State f Sskip (CC.Kloop2 s0 s1 k0') ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

 destruct (dec_skip s). subst.

 econstructor; eauto. rewrite <- Heqk0. constructor. auto.

 rewrite strip_skip'_not in Heqk0' by auto. inv Heqk0'.

  exists st2; split; auto.

  destruct s; inv Heqk0'.

 eapply star_plus_trans; try apply H0.

 clear - H4; revert H4; induction k'; intros; inv H4.

 destruct (dec_skip s). subst.

 specialize (IHk' H0). econstructor 2.

 split;[reflexivity|]. constructor. apply IHk'. auto.

 replace (CC.Kloop2 s0 s1 k0') with (CC.Kseq s k') by  (destruct s; auto; congruence).

 constructor 1.

 constructor 1.

 +

 destruct s; inv Heqk0'.

 destruct (IHcl_step (CC'.CC_core_State f Sskip (CC.Kcall o f0 e t k0') ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

 constructor; auto. rewrite <- Heqk0. constructor; auto.

  exists st2; split; auto.

  inv H0.

 eapply plus_star_trans; [ | apply H5].

 destruct H4 as [H4' H4].

 inv H4.

 eapply star_plus_trans; [eapply strip_skip'_call; eauto | ].

 apply plus_one. split;[reflexivity|]. constructor; auto.



* 

 inv H0.

 simpl strip_skip in H5.

 inv H5.

 +

 change (CC.Kseq Scontinue k'0 = strip_skip' (CC.Kseq s k')) in H3.

 symmetry in H3.

 rewrite continue_cont_skip in *.

 simpl in CUR.

 rewrite <- current_function_strip in CUR.

 forget (strip_skip k) as k0. clear k. rename k0 into k.

 generalize (continue_cont_is k); case_eq (continue_cont k); intros; try contradiction.

 rewrite H0 in H; inv H.

 destruct c; try contradiction. destruct l; try contradiction. destruct c; try contradiction.

 subst s0.



 assert (star (CC.State f s k' ve te m)

              (CC.State f Scontinue k'0 ve te m)).

 clear - H3.

 destruct (dec_skip s). subst. simpl in H3.

 eapply exec_skips'; auto.

 rewrite strip_skip'_not in H3 by auto. inv H3. constructor.

 assert (star (CC.State f Scontinue k'0 ve te m)

              (CC.State f Scontinue (strip_skip' k'0) ve te m)).

clear.

  induction k'0; try solve [constructor 1].

 destruct (dec_skip s). subst.  simpl in *. econstructor 2.

 split;[reflexivity|]. constructor. eassumption. auto.

  rewrite strip_skip'_not; auto. constructor 1.

 generalize (star_trans H2 H4); clear H2 H4; intro.

 clear H3.

 forget (strip_skip' k'0) as k0'; clear k'0.

 assert (precontinue_cont k = Kloop1 s1 s2 :: l).

 revert H0; clear; induction k; simpl; try congruence.  destruct a; try congruence; auto.

 assert (exists k1',

               star (CC.State f Scontinue k0' ve te m)

                    (CC.State f Scontinue k1' ve te m) /\

               match_cont (Kseq Scontinue :: Kloop1 s1 s2 :: l) k1'). {

   clear - H1 H0.

   revert H0; induction H1; simpl; intros; try congruence.

   destruct IHmatch_cont as [k1' [? ?]].

   rewrite <- continue_cont_skip; auto.

   econstructor. split; [ | eassumption].

   eapply star_trans; try apply H.

   clear.

   eapply star_trans. apply star_one.

   split;[reflexivity|].

   apply CC.step_continue_seq.

   apply step_continue_strip.

   inv H0.

   econstructor; split. constructor 1.  constructor.  auto.

   destruct IHmatch_cont as [k1' [? ?]].

   rewrite <- continue_cont_skip; auto.

   econstructor. split; [ | eassumption].

   eapply star_trans; try apply H.

   eapply star_trans. apply star_one.

   split;[reflexivity|].

   apply CC.step_continue_switch.

   apply step_continue_strip.

 }

 destruct H4 as [k1' [? ?]].

 generalize (star_trans H2 H4); clear H2 H4; intro H2.

 rewrite H0 in *.

 assert (CUR': match current_function l with

      | Some f' => f' = f

      | None => True

      end). {

   clear - CUR H0. revert CUR H0; induction k; simpl; intros.

   inv H0.

   destruct a; try discriminate; auto.

   apply IHk. auto. auto. inv H0. auto.

   apply IHk; auto.

 }

 clear H1 CUR k H0 H3.

 inv H5. inv H4. simpl in *.

 destruct (IHcl_step (CC'.CC_core_State f s2 (CC.Kloop2 s1 s2 k'0) ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

 constructor; auto. apply match_cont_strip. constructor. auto.

 exists st2; split; auto.

 eapply star_plus_trans; [apply H2 | ].

 eapply star_plus_trans; [ | apply H0].

 apply star_one. split;[reflexivity|]. constructor. auto.

 +

   change (CC.Kloop1 s0 e3 k'0 = strip_skip' (CC.Kseq s k')) in H1.

 destruct (dec_skip s); [ | destruct s; try congruence; inv H1].

 subst s.

 simpl in H.

 simpl in H1.

 simpl in *.

 assert (star (CC.State f Sskip k' ve te m)

             (CC.State f Sskip (CC.Kloop1 s0 e3 k'0) ve te m)).

 rewrite H1; clear.

 induction k'; intros; try solve [constructor 1].

  destruct (dec_skip s). subst. simpl in *. econstructor 2.

  split;[reflexivity|]. constructor.

  apply IHk'. auto.

 rewrite strip_skip'_not; auto. constructor 1.

 forget (CC.State f Sskip k' ve te m) as st1.

 clear k' H1.

 assert (plus st1 (CC.State f e3 (CC.Kloop2 s0 e3 k'0) ve te m)).

 eapply star_plus_trans; try apply H0.

 econstructor. split;[reflexivity|]. constructor. auto. constructor 1.

 clear H0.

 destruct (IHcl_step (CC'.CC_core_State f e3 (CC.Kloop2  s0 e3 k'0) ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

 constructor; auto. apply match_cont_strip; constructor; auto.

 exists st2; split; auto.

 eapply plus_trans; eauto.



* 

 inv H0. simpl strip_skip in H5.



 inv H5.

 change (CC.Kseq Sbreak k'0 = strip_skip' (CC.Kseq s k')) in H3.

 symmetry in H3.

 rewrite <- break_cont_skip in *.

 simpl in CUR.

 rewrite <- current_function_strip in CUR.

 forget (strip_skip k) as k0. clear k. rename k0 into k.

 simpl.

 pose proof (exec_skips' f s k' Sbreak k'0 ve te m H3).

 forget (CC.State f s k' ve te m) as st1.

 clear k' H3. 

 pose proof (break_strip f ve te m k'0).

 pose proof (star_trans H0 H2); clear H0 H2.

 forget (strip_skip' k'0) as k0'; clear k'0.

 assert (X:exists k1',

             plus (CC.State f Sbreak k0' ve te m)

                       (CC.State f Sskip k1' ve te m)

               /\ match_cont (strip_skip (break_cont k)) (strip_skip' k1')). {

       clear - H H1. rename H1 into H2.

       revert H; induction H2; intros; try solve [inv H].

            rewrite break_cont_skip in *. simpl in H.

               destruct (IHmatch_cont H) as [k1' [? ?]]; clear IHmatch_cont. simpl.

               exists k1'; split; auto.

               eapply star_plus_trans; try eassumption.

               econstructor 2. split;[reflexivity|]. constructor.

              apply break_strip.



            simpl  in *. exists k'; split. econstructor.

               split;[reflexivity|].  eapply CC.step_break_loop1. constructor 1. auto.



            simpl  in *. exists k'; split. econstructor.

               split;[reflexivity|].  eapply CC.step_break_loop2. constructor 1. auto.



            simpl in *. exists k'; split.

                  econstructor. split;[reflexivity|]. eapply CC.step_skip_break_switch. auto.

                  constructor 1; auto.

                  auto.

  }



 destruct X as [k1' [? ?]].

 destruct (IHcl_step (CC'.CC_core_State f Sskip k1' ve te))

                      as [st2 [? ?]]; clear  IHcl_step.

       constructor; auto.

       clear - H CUR.

       revert CUR; induction  k; intros. apply I.

       destruct a; simpl in *; auto. apply IHk; auto.

 exists st2; split; auto.

 simpl in H4.

 eapply star_plus_trans; [ | eassumption].

 eapply star_trans; [eassumption | apply plus_star; eassumption].

* 

 inv H1. simpl strip_skip in H6.

 inv H6.

 change (CC.Kseq (Sifthenelse a s1 s2) k'0 = strip_skip' (CC.Kseq s k')) in H4.

 assert (star (CC.State f s k' ve te m) (CC.State f (Sifthenelse a s1 s2) k'0 ve te m)). {

     clear - H4.

     revert H4; induction k'; intros; try solve [ destruct s; inv H4; constructor 1].

     destruct (dec_skip s). subst s.

     destruct (dec_skip s0). subst s0. simpl in *.

     eapply star_trans; try apply IHk'; eauto. apply star_one.

       split;[reflexivity|]. constructor. auto.

      change (strip_skip' (CC.Kseq Sskip (CC.Kseq s0 k'))) with

               (strip_skip' (CC.Kseq s0 k')) in H4.

      rewrite strip_skip'_not in H4 by auto.

      inv H4. apply star_one.

     split;[reflexivity|]. constructor. rewrite strip_skip'_not in * by auto.

      inv H4. constructor 1.

 }

 exists (CC'.CC_core_State f (if b then s1 else s2) k'0 ve te); split; auto.

 eapply star_plus_trans; try apply H1.

 apply plus_one. split;[reflexivity|]. econstructor; eauto. auto. constructor; auto.

 apply match_cont_strip; auto.



* 

 inv H0. inv H4.

 change (CC.Kseq (Sloop s1 s2) k'0 = strip_skip' (CC.Kseq s k')) in H2.

 generalize (exec_skips' f _ _ _ _ ve te m (@eq_sym _ _ _ H2)); intro.

 exists ( (CC'.CC_core_State f s1 (CC.Kloop1 s1 s2 k'0) ve te)); split.

 eapply star_plus_trans; try apply H.

 apply plus_one. split;[reflexivity|]. eapply CC.step_loop; eauto.

 constructor; auto. apply match_cont_strip; constructor; auto.



* 

  inv H0. inv H4.

 destruct s0; inv H3.

 generalize (strip_skip'_loop2 f ve te m _ _ _ _ H1); intro.

 exists (CC'.CC_core_State f s (CC.Kloop1 s a3 k'0) ve te); split.

 + eapply star_plus_trans; try apply H.

               econstructor. split;[reflexivity|].

                            eapply CC.step_skip_loop2; eauto.

                            apply star_one. split;[reflexivity|]. eapply CC.step_loop; eauto.

 + constructor; auto. apply match_cont_strip. constructor. auto.



*  {

 inv H3.

  remember (strip_skip' (CC.Kseq s k'0)) as k3. simpl in CUR, H8.

 inv H8.

 * 

 generalize (exec_skips' f0 _ _ _ _ ve te m (@eq_sym _ _ _ H4)); intro H99.

 assert (f0=f).

   simpl in CUR; clear - CUR H.

   revert H CUR; induction k; intros. inv H. simpl in *. destruct a; auto. inv CUR; auto. inv H; auto.

 subst f.

 generalize (match_cont_call_strip k k'1); intro.

 spec H3; [congruence |]. spec H3; [auto |].

 generalize H3; rewrite H; intro.

 inv H5.

  +  elimtype False; clear - H10.

         revert H10; induction k'1; simpl; intros; congruence.

  + destruct optexp;  [destruct H1 as [v [? ?]] | ]; (destruct optid; destruct H2 as [H2 H2'];

               try solve [contradiction H2; auto]; subst te'' ).

    -   eexists (CC'.CC_core_State f Sskip k'2 ve' (PTree.set i v' te')).

                split.

                     apply (star_plus_trans H99). 

                     eapply @plus_trans with (s2:=CC.Returnstate v' (CC.call_cont k'1) m').

                                         eapply plus_one. split;[reflexivity|]. simpl. econstructor; eauto.

                                         eapply plus_one. split;[reflexivity|]. simpl. rewrite <- H13.

                                         eapply CC.step_returnstate.

                    constructor; auto.

    -   eexists (CC'.CC_core_State f Sskip k'2 ve' te').

                split.

                     eapply (star_plus_trans H99). 

                          eapply @plus_trans with (s2:=CC.Returnstate v' (CC.call_cont k'1) m').

                                         eapply plus_one. split;[reflexivity|]. simpl. econstructor; eauto.

                                         eapply plus_one. split;[reflexivity|]. simpl. rewrite <- H13. eapply CC.step_returnstate.

                    constructor; auto.

    -   eexists (CC'.CC_core_State f Sskip k'2 ve' (CC.set_opttemp (Some i) Vundef te')).

                split.

                     eapply (star_plus_trans H99).  

                          eapply @plus_trans with (s2:=CC.Returnstate Vundef (CC.call_cont k'1) m').

                                         eapply plus_one. split;[reflexivity|]. simpl. econstructor; eauto.

                                         eapply plus_one. split;[reflexivity|]. simpl. rewrite <- H13.

                apply CC.step_returnstate. subst.

                 simpl. constructor 1. auto. simpl.  auto.

   - eexists (CC'.CC_core_State f Sskip k'2 ve' te').

                split.

                     eapply (star_plus_trans H99).

                          eapply @plus_trans with (s2:=CC.Returnstate Vundef (CC.call_cont k'1) m').

                                         eapply plus_one. split;[reflexivity|]. simpl. econstructor; eauto.

                                         eapply plus_one. split;[reflexivity|]. simpl. rewrite <- H13.

                apply CC.step_returnstate. subst.

                 simpl. constructor 1. auto. simpl.  auto.

 * 

 destruct optid; destruct H2 as [_ H2]; subst te''.

  + simpl in H. inv H. simpl in CUR. symmetry in CUR; inv CUR.

    destruct s; inv H4.

    assert (star (CC.State f Sskip k'0 ve te m)

                 (CC.State f Sskip (CC.Kcall (Some i) f1 ve' te' k'1) ve te m)).

     clear - H1.

     revert H1; induction k'0; intros; try solve [inv H1].

           destruct (dec_skip s). subst s. simpl in H1.

               eapply star_trans; try apply IHk'0; auto. 

               apply star_one. split;[reflexivity|]. constructor; auto.

          rewrite strip_skip'_not in H1 by auto. rewrite <- H1. constructor 1.

          simpl in H1. inv H1. constructor 1.

 (econstructor; split; [eapply star_plus_trans; [ apply H  | eapply plus_two ] | ]).

     split;[reflexivity|]. eapply CC.step_skip_call; simpl; eauto.

     assert (X: CCstep (CC.Returnstate Vundef (CC.Kcall (Some i) f1 ve' te' k'1) m')

                       (CC'.CC_core_to_CC_state (CC'.CC_core_State f1 Sskip k'1 ve'  (CC.set_opttemp (Some i) Vundef te')) m')).

           split;[reflexivity|]. econstructor; eauto.

       apply X.

    auto.

    econstructor; eauto.

 +

   simpl in H. inv H. simpl in CUR. symmetry in CUR; inv CUR.

 destruct s; inv H4.

 assert (star (CC.State f Sskip k'0 ve te m)

             (CC.State f Sskip (CC.Kcall None f1 ve' te' k'1) ve te m)).

     clear - H1.

     revert H1; induction k'0; intros; try solve [inv H1].

           destruct (dec_skip s). subst s. simpl in H1.

               eapply star_trans; try apply IHk'0; auto.

          apply star_one. split;[reflexivity|]. constructor; auto.

          rewrite strip_skip'_not in H1 by auto. rewrite <- H1. constructor 1.

          simpl in H1. inv H1. constructor 1.

 (econstructor; split; [eapply star_plus_trans; [ apply H  | eapply plus_two ] | ]).

     split;[reflexivity|]. eapply CC.step_skip_call; simpl; eauto.

     assert (X: CCstep (CC.Returnstate Vundef (CC.Kcall None f1 ve' te' k'1) m')

                       (CC'.CC_core_to_CC_state (CC'.CC_core_State f1 Sskip k'1 ve' te') m')).

            split;[reflexivity|]. econstructor; eauto.

       apply X.

    auto.

    econstructor; eauto.

}



* 

 inv H1. simpl strip_skip in H6.

 remember (CC.Kseq s k') as k0'.

 inv H6.

 evar (c2': CC'.CC_core).

 exists c2'; split.

 2:{ constructor; eauto. apply match_cont_strip. simpl.

                    instantiate (1:= CC.Kswitch k'0). constructor. auto.

   }

     generalize (exec_skips' f _ _ _ _ ve te m (@eq_sym _ _ _ H4)); intro H99.

        eapply star_plus_trans; try apply H99.

        unfold c2'. apply plus_one. split;[reflexivity|]. simpl. econstructor; eauto.



* 

 inv H0.  remember (CC.Kseq s0 k') as k0'. inv H5.

 destruct (IHcl_step (CC'.CC_core_State f s k'0 ve te)) as [st2 [? ?]]; clear IHcl_step.

 constructor; auto. apply match_cont_strip. auto.

 exists st2; split; auto.

   eapply star_plus_trans; try eassumption.

   generalize (exec_skips' f _ _ _ _ ve te m (@eq_sym _ _ _ H3)); intro H99.

     eapply star_trans; try apply H99.

     apply star_one. split;[reflexivity|]. constructor.



* 

 inv H0. remember (CC.Kseq s k'0) as k0'. inv H5.

  generalize (match_cont_call_strip k k'1); intro.

 spec H0.

 clear - CUR. apply (call_cont_nonnil _ _ CUR).

 specialize (H0 H1).

  rewrite <- strip_call' in H0.

 change (Kseq (Sreturn None) :: call_cont k) with (strip_skip (Kseq (Sreturn None) :: call_cont k)) in H0.

 destruct (match_find_label _ _ _ _ _ H0 H) as [s2 [k2' [? ?]]].

 exists (CC'.CC_core_State f s2 k2' ve te); split.

    simpl in CUR0. inversion2 CUR CUR0.

     generalize (exec_skips' f _ _ _ _ ve te m (@eq_sym _ _ _ H3)); intro H99.

     eapply star_plus_trans; try apply H99.

         apply plus_one. split;[reflexivity|]. constructor; auto.

         constructor; auto.

   clear - CUR H. forget (fn_body f) as s.

       rewrite <- current_function_call_cont in CUR.

       change (current_function (Kseq (Sreturn None) :: call_cont k) = Some f) in CUR.

        forget (Kseq (Sreturn None) :: call_cont k) as k0. clear - CUR H.

        rewrite (current_function_find_label _ _ _ _ _ CUR H). auto.

 apply match_cont_strip1. auto.

Qed.



End GE.



Definition coresem_extract_cenv {M} {core} (CS: @CoreSemantics core M)

                         (cenv: composite_env) :

            @CoreSemantics core M :=

  Build_CoreSemantics _ _

             (CS.(initial_core))

             (CS.(semantics.at_external))

             (CS.(semantics.after_external))

             CS.(halted)

            (CS.(corestep) )

            (CS.(corestep_not_halted) )

            CS.(corestep_not_at_external).



Require Import VST.sepcomp.step_lemmas.
(* VST.sepcomp.step_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.

Require Import compcert.common.AST.
Require Import compcert.common.Values.

Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Definition has_opttyp (v : option val) (t : option typ) :=
  match v, t with
    None, None => True
  | Some v, Some t => Val.has_type v t
  | _, _ => False
  end.

Section safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context {Hrel: nat -> M -> M -> Prop}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).

  Variable ge : G.

  Inductive safeN_ : nat -> Z -> C -> M -> Prop :=
  | safeN_0: forall z c m, safeN_ O z c m
  | safeN_step:
      forall n z c m c' m',
      corestep Hcore c m c' m' ->
      safeN_ n z c' m' ->
      safeN_ (S n) z c m
  | safeN_external:
      forall n z c m e args x,
      at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           after_external Hcore ret c m' = Some c' /\
           safeN_ n' z' c' m') ->
      safeN_ (S n) z c m
  | safeN_halted:
      forall n z c m i,
      halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      safeN_ n z c m.

  Definition corestep_fun  :=
       forall m q m1 q1 m2 q2 ,
       corestep Hcore q m q1 m1 ->
       corestep Hcore q m q2 m2 ->
       (q1, m1) = (q2, m2).

  Lemma safe_corestep_forward:
     corestep_fun ->
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ (S n) z c m -> safeN_ n z c' m'.

  Lemma safe_corestep_backward:
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ n z c' m' -> safeN_ (S n) z c m.

  Lemma safe_downward1 :
    forall n c m z,
      safeN_ (S n) z c m -> safeN_ n z c m.

  Lemma safe_downward :
    forall n n' c m z,
      le n' n ->
      safeN_ n z c m -> safeN_ n' z c m.

  Lemma safe_corestepN_forward:
    corestep_fun ->
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n + S n0) z c m ->
      safeN_ n z c' m'.

  Lemma safe_step'_back2 :
    forall
      {ora st m st' m' n},
      corestep Hcore st m st' m' ->
      safeN_ (n-1) ora st' m' ->
      safeN_ n ora st m.

  Lemma safe_corestepN_backward:
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n - n0) z c' m' ->
      safeN_ n z c m.

  Lemma convergent_controls_safe :
    forall m q1 q2,
      (at_external Hcore q1 m = at_external Hcore q2 m) ->
      (forall ret m q', after_external Hcore ret q1 m = Some q' ->
                      after_external Hcore ret q2 m = Some q') ->
      (halted Hcore q1 = halted Hcore q2) ->
      (forall q' m', corestep Hcore q1 m q' m' ->
                     corestep Hcore q2 m q' m') ->
      (forall n z, safeN_ n z q1 m -> safeN_ n z q2 m).

  Lemma wlog_safeN_gt0 : forall
    n z q m,
    (lt 0 n -> safeN_ n z q m) ->
    safeN_ n z q m.

End safety.

Section dry_safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).
  Definition dry_safeN := @safeN_ G C M Z genv_symb (fun n' m m' => True) Hcore Hspec.
End dry_safety. *)



Definition genv_symb_injective {F V} (ge: Genv.t F V) : extspec.injective_PTree block.

Proof.

exists (Genv.genv_symb ge).

hnf; intros.

eapply Genv.genv_vars_inj; eauto.

Defined.

