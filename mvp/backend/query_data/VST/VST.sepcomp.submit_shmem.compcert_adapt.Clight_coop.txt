Require Import Coqlib.

Require Import Errors.

Require Import Maps.

Require Import Integers.

Require Import Floats.

Require Import Values.

Require Import AST.

Require Import Memory.

Require Import Events.

Require Import Globalenvs.

Require Import Smallstep.

Require Import Ctypes.

Require Import Cop.



Require Import Clight.

Require Import sepcomp.mem_lemmas. 
(* sepcomp.mem_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Axioms.

Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.

Require Import VST.msl.Extensionality.

Require Import VST.sepcomp.Address.

Notation val_inject:= Val.inject.

Lemma valid_block_dec: forall m b, {Mem.valid_block m b} +  {~Mem.valid_block m b}.

Lemma Forall2_length {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): length l1 = length l2.

Lemma Forall2_Zlength {A B} {f:A -> B -> Prop} {l1 l2} (F:Forall2 f l1 l2): Zlength l1 = Zlength l2.

Lemma pos_succ_plus_assoc: forall n m,
    (Pos.succ n + m = n + Pos.succ m)%positive.

Lemma mem_unchanged_on_sub: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma mem_unchanged_on_sub_strong: forall (P Q: block -> BinInt.Z -> Prop) m m',

Lemma inject_separated_same_meminj: forall j m m',
  Events.inject_separated j j m m'.

Lemma compose_meminj_idR: forall j, j = compose_meminj j inject_id.

Lemma compose_meminj_idL: forall j, j = compose_meminj inject_id j.

Theorem drop_extends:
  forall m1 m2 lo hi b p m1',
  Mem.extends m1 m2 ->

Lemma mem_inj_id_trans: forall m1 m2 (Inj12: Mem.mem_inj inject_id m1 m2) m3

Lemma extends_trans: forall m1 m2
  (Ext12: Mem.extends m1 m2) m3 (Ext23: Mem.extends m2 m3), Mem.extends m1 m3.

Lemma memval_inject_id_refl: forall v, memval_inject inject_id v v.

Lemma extends_refl: forall m, Mem.extends m m.

Lemma perm_decE:
  forall m b ofs k p PF,
  (Mem.perm_dec m b ofs k p = left PF <-> Mem.perm m b ofs k p).

Lemma flatinj_E: forall b b1 b2 delta (H:Mem.flat_inj b b1 = Some (b2, delta)),

Lemma flatinj_I: forall bb b, Plt b bb -> Mem.flat_inj bb b = Some (b, 0).

Lemma flatinj_mono: forall b b1 b2 b' delta
  (F: Mem.flat_inj b1 b = Some (b', delta)),

Definition readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Cur Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Cur Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Definition max_readonlyLD m1 b m2 :=
    forall chunk ofs
    (NWR: forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
                          ~(Mem.perm m1 b ofs' Max Writable)),
     Mem.load chunk m2 b ofs = Mem.load chunk m1 b ofs /\
     (forall ofs', ofs <= ofs' < ofs + size_chunk chunk ->
        (forall k p, Mem.perm m1 b ofs' k p <-> Mem.perm m2 b ofs' k p)).

Definition max_readonly m1 b m2 :=
    forall n ofs
    (NWR: forall i, 0 <= i < n ->
                          ~(Mem.perm m1 b (ofs + i) Max Writable)),
     Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n /\
     (forall i, 0 <= i < n ->
        (forall k p, Mem.perm m1 b (ofs+i) k p <-> Mem.perm m2 b (ofs+i) k p)).

Lemma readonlyLD_max_readonlyLD m1 b m2: readonlyLD m1 b m2 -> max_readonlyLD m1 b m2.

Lemma readonly_max_readonly m1 b m2: readonly m1 b m2 -> max_readonly m1 b m2.

Lemma readonly_readonlyLD m1 b m2: readonly m1 b m2 -> readonlyLD m1 b m2.

Lemma readonly_refl m b: readonly m b m.

Lemma readonlyLD_refl m b: readonlyLD m b m.

Lemma readonlyLD_trans m1 m2 m3 b: readonlyLD m1 b m2 -> readonlyLD m2 b m3 -> readonlyLD m1 b m3.

Lemma readonly_trans m1 m2 m3 b: readonly m1 b m2 -> readonly m2 b m3 -> readonly m1 b m3.

Definition mem_forward (m1 m2:mem) :=
  forall b, Mem.valid_block m1 b ->
    (Mem.valid_block m2 b
     /\ (forall ofs p, Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p)
     ).

Lemma mem_forward_refl: forall m, mem_forward m m.

Lemma mem_forward_trans: forall m1 m2 m3,
  mem_forward m1 m2 -> mem_forward m2 m3 -> mem_forward m1 m3.

Lemma forward_unchanged_trans: forall P m1 m2 m3,
Mem.unchanged_on P m1 m2 -> Mem.unchanged_on P m2 m3 ->

Lemma matchOptE: forall {A} (a:option A) (P: A -> Prop),
   match a with Some b => P b | None => False end ->
   exists b, a = Some b /\ P b.

Lemma compose_meminjD_None: forall j jj b,
  (compose_meminj j jj) b = None ->
  j b = None \/
  (exists b', exists ofs, j b = Some(b',ofs) /\ jj b' = None).

Lemma compose_meminjD_Some: forall j jj b b2 ofs2,
       (compose_meminj j jj) b = Some(b2,ofs2) ->
       exists b1, exists ofs1, exists ofs,
       j b = Some(b1,ofs1) /\ jj b1 = Some(b2,ofs) /\ ofs2=ofs1+ofs.

Lemma compose_meminj_inject_incr: forall j12 j12' j23 j23'
  (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23'),
  inject_incr (compose_meminj j12 j23) (compose_meminj j12' j23').

Lemma compose_meminj_inject_separated: forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (BV12: forall b1 b2 ofs, j12 b1 = Some (b2,ofs) -> Mem.valid_block m1 b1 /\ Mem.valid_block m2 b2)

Lemma compose_meminj_inject_separated': forall j12 j12' j23 j23' m1 m2 m3
   (InjSep12 : inject_separated j12 j12' m1 m2)
   (InjSep23 : inject_separated j23 j23' m2 m3)
   (InjIncr12: inject_incr j12 j12') (InjIncr23: inject_incr j23 j23')
   (MInj12: Mem.inject j12 m1 m2)

Lemma forall_lessdef_refl: forall vals,  Forall2 Val.lessdef vals vals.

Lemma lessdef_hastype: forall v v' (V:Val.lessdef v v') T,

Lemma forall_lessdef_hastype: forall vals vals'
          (V:Forall2 Val.lessdef vals vals') Ts

Lemma valinject_hastype:  forall j v v'
       (V: (val_inject j) v v') T,
       Val.has_type v' T -> Val.has_type v T.

Lemma forall_valinject_hastype:  forall j vals vals'
            (V:  Forall2 (val_inject j) vals vals')
            Ts (HTs: Forall2 Val.has_type vals' Ts),

Definition val_inject_opt (j: meminj) (v1 v2: option val) :=
  match v1, v2 with Some v1', Some v2' => val_inject j v1' v2'
  | None, None => True
  | _, _ => False
  end.

Lemma val_inject_split:
  forall v1 v3 j12 j23 (V: val_inject (compose_meminj j12 j23) v1 v3),
    exists v2, val_inject j12 v1 v2 /\ val_inject j23 v2 v3.

Lemma forall_lessdef_trans:
  forall vals1 vals2 (V12: Forall2 Val.lessdef vals1 vals2)

Lemma extends_loc_out_of_bounds:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs,

Lemma extends_loc_out_of_reach:
  forall m1 m2 (Ext: Mem.extends m1 m2) b ofs j

Lemma valinject_lessdef:
  forall v1 v2 v3 j (V12:val_inject j v1 v2) (V23 : Val.lessdef v2 v3),

Lemma forall_valinject_lessdef:
  forall vals1 vals2 j (VInj12 : Forall2 (val_inject j) vals1 vals2) vals3
    (LD23 : Forall2 Val.lessdef vals2 vals3), Forall2 (val_inject j) vals1 vals3.

Lemma val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Val.lessdef v1 v2) j v3

Lemma forall_val_lessdef_inject_compose:
  forall v1 v2 (LD12 : Forall2 Val.lessdef v1 v2) j v3

Lemma forall_val_inject_compose:
  forall vals1 vals2 j1 (ValsInj12 : Forall2 (val_inject j1) vals1 vals2)
     vals3 j2 (ValsInj23 : Forall2 (val_inject j2) vals2 vals3),
     Forall2 (val_inject (compose_meminj j1 j2)) vals1 vals3.

Lemma val_inject_flat:
  forall m1 m2 j (Inj: Mem.inject j m1 m2) v1 v2 (V: val_inject j v1 v2),

Lemma forall_val_inject_flat: forall m1 m2 j (Inj: Mem.inject j m1 m2) vals1 vals2

Lemma po_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Lemma extends_perm: forall m1 m2 (Ext: Mem.extends m1 m2) b ofs k p,

Lemma extends_permorder: forall m1 m2 (Ext: Mem.extends m1 m2) (b:block) ofs k,

Lemma fwd_maxperm: forall m1 m2 (FWD: mem_forward m1 m2) b
  (V:Mem.valid_block m1 b) ofs p,

Lemma fwd_maxpermorder: forall m1 m2 (FWD: mem_forward m1 m2) (b:block)
  (V:Mem.valid_block m1 b) ofs,

Lemma po_oo: forall p q, Mem.perm_order' p q = Mem.perm_order'' p (Some q).

Lemma inject_permorder:
  forall j m1 m2 (Inj : Mem.inject j m1 m2) (b b':block) ofs'

Lemma PermExtNotnonempty:
  forall m1 m2
    (Inj: Mem.extends m1 m2) b ofs p

Lemma PermInjNotnonempty:
  forall j m1 m2
    (Inj: Mem.inject j m1 m2) b b2 delta (J:j b = Some(b2,delta)) ofs p

Lemma inject_LOOR_LOOB:
  forall m1 m2 j (Minj12 : Mem.inject j m1 m2) m3 m3',

Lemma free_neutral:
  forall (thr : block) (m : mem) (lo hi : Z) (b : block) (m' : Mem.mem')

Lemma getN_aux: forall n p c B1 v B2, Mem.getN n p c = B1 ++ v::B2 ->

Lemma getN_range: forall n ofs M bytes1 v bytes2,
  Mem.getN n ofs M = bytes1 ++ v::bytes2 ->

Lemma loadbytes_D: forall m b ofs n bytes
      (LD: Mem.loadbytes m b ofs n = Some bytes),

Lemma load_ptr_is_fragment ch m b ofs b0 i
      (LD: Mem.load ch m b ofs = Some (Vptr b0 i)):

Lemma load_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma loadbytes_storebytes_nil m b ofs m': Mem.storebytes m b ofs nil = Some m' ->

Lemma storebytes_forward: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonlyLD: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma storebytes_readonly: forall m b ofs bytes m'
      (M: Mem.storebytes m b ofs bytes = Some m'),

Lemma store_forward: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma store_readonly: forall m b ofs v ch m'
      (M:Mem.store ch m b ofs v = Some m'),

Lemma alloc_forward:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma loadbytes_unchanged_on (P : block -> Z -> Prop) m m' b ofs n:
  Mem.unchanged_on P m m' -> Mem.valid_block m b ->

Lemma loadbytes_alloc_unchanged m1 lo hi m2 b :
  Mem.alloc m1 lo hi = (m2, b) ->

Lemma alloc_readonly:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma alloc_readonlyLD:
      forall m lo hi m' b
      (A: Mem.alloc m lo hi = (m',b)),

Lemma free_forward: forall b z0 z m m'
      (M: Mem.free m b z0 z = Some m'),

Lemma loadbytes_free m1 bf lo hi m2:
  Mem.free m1 bf lo hi = Some m2 ->

Lemma free_readonlyLD: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma free_readonly: forall b lo hi m m'
      (M: Mem.free m b lo hi = Some m'),

Lemma freelist_forward: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonly: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma freelist_readonlyLD: forall l m m'
      (M: Mem.free_list m l = Some m'),

Lemma forward_nextblock: forall m m',
  mem_forward m m' ->
  (Mem.nextblock m <= Mem.nextblock m')%positive.

Lemma inject_separated_incr_fwd:
  forall j j' m1 m2 j'' m2'
    (InjSep : inject_separated j j' m1 m2)
    (InjSep' : inject_separated j' j'' m1 m2')
    (InjIncr' : inject_incr j' j'')
    (Fwd: mem_forward m2 m2'),
    inject_separated j j'' m1 m2.

Lemma inject_separated_incr_fwd2:
  forall j0 j j' m10 m20 m1 m2,
  inject_incr j j' ->
  inject_separated j j' m1 m2 ->
  inject_incr j0 j ->
  mem_forward m10 m1 ->
  inject_separated j0 j m10 m20 ->
  mem_forward m20 m2 ->
  inject_separated j0 j' m10 m20.

Lemma forall_inject_val_list_inject:
  forall j args args' (H:Forall2 (val_inject j) args args' ),
    Val.inject_list j args args'.

Lemma val_list_inject_forall_inject:
  forall j args args' (H:Val.inject_list j args args'),

Lemma forall_lessdef_val_listless:
  forall args args' (H: Forall2 Val.lessdef args args'),

Lemma val_listless_forall_lessdef:
  forall args args' (H:Val.lessdef_list args args'),

Lemma storev_valid_block_1:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Lemma storev_valid_block_2:
forall ch m addr v m',
Mem.storev ch m addr v = Some m' ->

Definition meminj_preserves_globals_ind (globals: (block->Prop)*(block->Prop)) f :=
  (forall b, fst globals b -> f b = Some (b, 0)) /\
  (forall b, snd globals b -> f b = Some (b, 0)) /\
  (forall b1 b2 delta, snd globals b2 -> f b1 = Some (b2, delta) -> b1=b2).

Definition genv2blocks {F V: Type} (ge: Genv.t F V) :=
  (fun b => exists id, Genv.find_symbol ge id = Some b,
   fun b => exists gv, Genv.find_var_info ge b = Some gv).

Lemma meminj_preserves_genv2blocks:
  forall {F V: Type} (ge: Genv.t F V) j,

Definition genvs_domain_eq {F1 F2 V1 V2: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) :=
    (forall b, fst (genv2blocks ge1) b <-> fst (genv2blocks ge2) b) /\
    (forall b, snd (genv2blocks ge1) b <-> snd (genv2blocks ge2) b) /\
    (forall b, (exists f, Genv.find_funct_ptr ge1 b = Some f)
           <-> (exists f, Genv.find_funct_ptr ge2 b = Some f)).

Lemma genvs_domain_eq_preserves:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) j,

Lemma genvs_domain_eq_sym:
  forall {F1 F2 V1 V2: Type} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma genvs_domain_eq_refl:
  forall F V (ge: Genv.t F V), genvs_domain_eq ge ge.

Lemma genvs_domain_eq_trans: forall {F1 F2 F3 V1 V2 V3: Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) (ge3: Genv.t F3 V3),

Lemma genvs_domain_eq_match_genvs: forall {F1 V1 F2 V2:Type}
  (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2),

Lemma meminj_preserves_globals_ind_compose:
   forall {F1 V1 F2 V2} (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2)

Lemma meminj_preserves_incr_sep:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm (MINJ : Mem.inject j m tm)

Lemma meminj_preserves_incr_sep_vb:
  forall {F V:Type} ge j (PG: @meminj_preserves_globals F V ge j)
         m tm
         (VB: forall b1 b2 ofs, j b1 = Some(b2,ofs) ->
               (Mem.valid_block m b1 /\ Mem.valid_block tm b2))

Lemma mem_forward_nextblock:
  forall m m', mem_forward m m' -> Ple  (Mem.nextblock m) (Mem.nextblock m').

Lemma forward_unchanged_on: forall m m' (FWD: mem_forward m m')
           b ofs (NP: ~ Mem.perm m b ofs Max Nonempty),

Lemma unchanged_on_union:
      forall m m' P Q (HP: Mem.unchanged_on P m m') (HQ: Mem.unchanged_on Q m m')

Lemma unchanged_on_validblock: forall m m' (U V: Values.block -> Z -> Prop)

Lemma unchanged_on_validblock_invariant: forall m m' U V
   (UV: forall b ofs, Mem.valid_block m b -> (U b ofs <-> V b ofs)),

Lemma unchanged_on_perm_intersection: forall m m' U (Fwd: mem_forward m m'),
   Mem.unchanged_on U m m' <->

Lemma unchanged_on_trans: forall m1 m2 m3 U
      (U1: Mem.unchanged_on U m1 m2)

Lemma external_call_mem_forward:
  forall (ef : external_function) (F V : Type) (ge : Genv.t F V)

Definition val_has_type_opt' (v: option val) (ty: typ) :=
 match v with
 | None => True
 | Some v' => Val.has_type v' ty
 end.

Definition val_has_type_opt (v: option val) (sig: signature) :=
  val_has_type_opt' v (proj_sig_res sig).

Definition is_vundef (v : val) : bool :=
  match v with
    | Vundef => true
    | _ => false
  end.

Definition vals_def (vs : list val) :=
  List.forallb (fun v => negb (is_vundef v)) vs.

Definition genv2blocksBool {F V : Type} (ge : Genv.t F V):=
  (fun b =>
      match Genv.invert_symbol ge b with
        Some id => true
      | None => false
      end,
   fun b => match Genv.find_var_info ge b with
                  Some gv => true
                | None => false
            end).

Definition isGlobalBlock {F V : Type} (ge : Genv.t F V) :=
  fun b => (fst (genv2blocksBool ge)) b || (snd (genv2blocksBool ge)) b.

Lemma invert_symbol_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Lemma find_symbol_isGlobal: forall {V F} (ge : Genv.t F V) x b

Lemma symbol_address_isGLobalBlock {V F} (ge : Genv.t F V) i1 i2 b i3:

Lemma find_var_info_isGlobal: forall {V F} (ge : Genv.t F V) b x,

Definition ReadOnlyBlocks {F V} (ge: Genv.t F V) (b:block): bool :=
  match Genv.find_var_info ge b with
          None => false
        | Some gv => gvar_readonly gv && negb (gvar_volatile gv)
  end.

Lemma ReadOnlyBlocks_global {F V} (g:Genv.t F V) b:

Definition RDOnly_fwd (m1 m1':mem) B :=
  forall b (Hb: B b = true), readonly m1 b m1'.

Lemma RDOnly_fwd_trans m1 m2 m3 B:
  RDOnly_fwd m1 m2 B -> RDOnly_fwd m2 m3 B -> RDOnly_fwd m1 m3 B.

Definition mem_respects_readonly {F V} (ge : Genv.t F V) m :=
    forall b gv, Genv.find_var_info ge b = Some gv ->
                 gvar_readonly gv && negb (gvar_volatile gv) = true ->
           Genv.load_store_init_data ge m b 0 (gvar_init gv) /\
           Mem.valid_block m b /\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).

Lemma mem_respects_readonly_fwd {F V} (g : Genv.t F V) m m'

Lemma mem_respects_readonly_forward {F V} (ge : Genv.t F V) m m'

Lemma mem_respects_readonly_forward' {F V} (ge : Genv.t F V) m m'

Lemma nextblock_storev:
  forall chunk m addr v m',
  Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
Lemma nextblock_freelist:
  forall fbl m m',
  Mem.free_list m fbl = Some m' ->
Lemma perm_freelist:
  forall fbl m m' b ofs k p,
  Mem.free_list m fbl = Some m' ->

Lemma get_freelist:
  forall fbl m m' (FL: Mem.free_list m fbl = Some m') b

Lemma free_contents:
 forall m b lo hi m' b' ofs,
    Mem.free m b lo hi = Some m' ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: Values.block.
Hypothesis ALLOC: Mem.alloc m1 lo hi = (m2, b).

Transparent Mem.alloc.
Lemma AllocContentsUndef:
     (Mem.mem_contents m2) !! b = ZMap.init Undef.
Lemma AllocContentsOther: forall b', b' <> b ->
     (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.
Opaque Mem.alloc.

Lemma AllocContentsUndef1: forall z,
     ZMap.get z (Mem.mem_contents m2) !! b = Undef.

Lemma AllocContentsOther1: forall b', b' <> b ->
      (Mem.mem_contents m2) !! b' = (Mem.mem_contents m1) !! b'.

Lemma alloc_contents:
 forall b1 ofs,
    Mem.valid_block m1 b1 ->

End ALLOC.

Definition gvar_info_eq {V1 V2} (v1: option (globvar V1)) (v2: option (globvar V2)) :=
  match v1, v2 with
    None, None => True
  | Some i1, Some i2 => gvar_init i1 = gvar_init i2 /\
                        gvar_readonly i1 = gvar_readonly i2 /\ gvar_volatile i1 = gvar_volatile i2
  | _, _ => False
  end.

Definition gvar_infos_eq {F1 V1 F2 V2}
  (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall b, gvar_info_eq (Genv.find_var_info g1 b) (Genv.find_var_info g2 b).

Lemma gvar_info_refl V v: @gvar_info_eq V V v v.

Lemma gvar_infos_eqD {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eqD2 {F1 V1 F2 V2} (ge1 : Genv.t F1 V1) (ge2 : Genv.t F2 V2)

Lemma gvar_infos_eq_ReadOnlyBlocks {F1 V1 F2 V2} (g1: Genv.t F1 V1) (g2:Genv.t F2 V2):

Definition gvars_included {V1 V2} (gv1:option (globvar V1)) (gv2: option (globvar V2)): Prop :=
  match gv1, gv2 with
   None, None => True
 | None, Some x2 => True
 | Some x1, None => False
 | Some x1, Some x2 => gvar_init x1 = gvar_init x2 /\
                       gvar_readonly x1 = gvar_readonly x2 /\
                       gvar_volatile x1 = gvar_volatile x2
 end.

Lemma gvars_cohereD {F1 V1 F2 V2} (ge1:Genv.t F1 V1) (ge2:Genv.t F2 V2)

Definition findsymbols_preserved {F1 V1 F2 V2}
           (g1 : Genv.t F1 V1) (g2 : Genv.t F2 V2) :=
  forall i b, Genv.find_symbol g1 i = Some b -> Genv.find_symbol g2 i = Some b. *)

Require Import sepcomp.core_semantics.



Inductive CL_core: Type :=

  | CL_State

      (f: function)

      (s: statement)

      (k: cont)

      (e: env)

      (le: temp_env): CL_core

  | CL_Callstate

      (fd: fundef)

      (args: list val)

      (k: cont): CL_core

  | CL_Returnstate

      (res: val)

      (k: cont): CL_core.



Definition CL_at_external (c: CL_core) : option (external_function * signature * list val) :=

  match c with

  | CL_State _ _ _ _ _ => None

  | CL_Callstate fd args k => match fd with

                                  Internal f => None

                                | External ef targs tres => Some (ef, ef_sig ef, args)

                              end

  | CL_Returnstate v k => None

 end.



Definition CL_after_external (rv: option val) (c: CL_core) : option CL_core :=

  match c with

     CL_Callstate fd vargs k =>

        match fd with

          Internal _ => None

        | External ef tps tp =>

            match rv with

              Some v => Some(CL_Returnstate v k)

            | None  => Some(CL_Returnstate Vundef k)

            end

        end

   | _ => None

  end.



Definition CL_halted (q : CL_core): option val :=

    match q with

       CL_Returnstate v Kstop => Some v

     | _ => None

    end.



Section SEMANTICS.

Variable function_entry: function -> list val -> mem -> env -> temp_env -> mem -> Prop.



Variable ge: genv.

Inductive clight_corestep: CL_core -> mem-> CL_core -> mem -> Prop :=



  | clight_corestep_assign:   forall f a1 a2 k e le m loc ofs v2 v m',

      eval_lvalue ge e le m a1 loc ofs ->

      eval_expr ge e le m a2 v2 ->

      sem_cast v2 (typeof a2) (typeof a1) = Some v ->

      assign_loc (typeof a1) m loc ofs v m' ->

      clight_corestep (CL_State f (Sassign a1 a2) k e le) m

        (CL_State f Sskip k e le) m'



  | clight_corestep_set:   forall f id a k e le m v,

      eval_expr ge e le m a v ->

      clight_corestep (CL_State f (Sset id a) k e le) m

        (CL_State f Sskip k e (PTree.set id v le)) m



  | clight_corestep_call:   forall f optid a al k e le m tyargs tyres vf vargs fd,

      classify_fun (typeof a) = fun_case_f tyargs tyres ->

      eval_expr ge e le m a vf ->

      eval_exprlist ge e le m al tyargs vargs ->

      Genv.find_funct ge vf = Some fd ->

      type_of_fundef fd = Tfunction tyargs tyres ->

      clight_corestep (CL_State f (Scall optid a al) k e le) m

        (CL_Callstate fd vargs (Kcall optid f e le k)) m



  | clight_corestep_seq:  forall f s1 s2 k e le m,

      clight_corestep (CL_State f (Ssequence s1 s2) k e le) m

        (CL_State f s1 (Kseq s2 k) e le) m

  | clight_corestep_skip_seq: forall f s k e le m,

      clight_corestep (CL_State f Sskip (Kseq s k) e le) m

        (CL_State f s k e le) m

  | clight_corestep_continue_seq: forall f s k e le m,

      clight_corestep (CL_State f Scontinue (Kseq s k) e le) m

        (CL_State f Scontinue k e le) m

  | clight_corestep_break_seq: forall f s k e le m,

      clight_corestep (CL_State f Sbreak (Kseq s k) e le) m

        (CL_State f Sbreak k e le) m



  | clight_corestep_ifthenelse:  forall f a s1 s2 k e le m v1 b,

      eval_expr ge e le m a v1 ->

      bool_val v1 (typeof a) = Some b ->

      clight_corestep (CL_State f (Sifthenelse a s1 s2) k e le) m

        (CL_State f (if b then s1 else s2) k e le) m



  | clight_corestep_loop: forall f s1 s2 k e le m,

      clight_corestep (CL_State f (Sloop s1 s2) k e le) m

        (CL_State f s1 (Kloop1 s1 s2 k) e le) m

  | clight_corestep_skip_or_continue_loop1:  forall f s1 s2 k e le m x,

      x = Sskip \/ x = Scontinue ->

      clight_corestep (CL_State f x (Kloop1 s1 s2 k) e le) m

        (CL_State f s2 (Kloop2 s1 s2 k) e le) m

  | clight_corestep_break_loop1:  forall f s1 s2 k e le m,

      clight_corestep (CL_State f Sbreak (Kloop1 s1 s2 k) e le) m

        (CL_State f Sskip k e le) m

  | clight_corestep_skip_loop2: forall f s1 s2 k e le m,

      clight_corestep (CL_State f Sskip (Kloop2 s1 s2 k) e le) m

        (CL_State f (Sloop s1 s2) k e le) m

  | clight_corestep_break_loop2: forall f s1 s2 k e le m,

      clight_corestep (CL_State f Sbreak (Kloop2 s1 s2 k) e le) m

        (CL_State f Sskip k e le) m



  | clight_corestep_return_0: forall f k e le m m',

      Mem.free_list m (blocks_of_env e) = Some m' ->

      clight_corestep (CL_State f (Sreturn None) k e le) m

        (CL_Returnstate Vundef (call_cont k)) m'

  | clight_corestep_return_1: forall f a k e le m v v' m',

      eval_expr ge e le m a v ->

      sem_cast v (typeof a) f.(fn_return) = Some v' ->

      Mem.free_list m (blocks_of_env e) = Some m' ->

      clight_corestep (CL_State f (Sreturn (Some a)) k e le) m

        (CL_Returnstate v' (call_cont k)) m'

  | clight_corestep_skip_call: forall f k e le m m',

      is_call_cont k ->

      Mem.free_list m (blocks_of_env e) = Some m' ->

      clight_corestep (CL_State f Sskip k e le) m

        (CL_Returnstate Vundef k) m'



  | clight_corestep_switch: forall f a sl k e le m n,

      eval_expr ge e le m a (Vint n) ->

      clight_corestep (CL_State f (Sswitch a sl) k e le) m

        (CL_State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch k) e le) m

  | clight_corestep_skip_break_switch: forall f x k e le m,

      x = Sskip \/ x = Sbreak ->

      clight_corestep (CL_State f x (Kswitch k) e le) m

        (CL_State f Sskip k e le) m

  | clight_corestep_continue_switch: forall f k e le m,

      clight_corestep (CL_State f Scontinue (Kswitch k) e le) m

        (CL_State f Scontinue k e le) m



  | clight_corestep_label: forall f lbl s k e le m,

      clight_corestep (CL_State f (Slabel lbl s) k e le) m

        (CL_State f s k e le) m



  | clight_corestep_goto: forall f lbl k e le m s' k',

      find_label lbl f.(fn_body) (call_cont k) = Some (s', k') ->

      clight_corestep (CL_State f (Sgoto lbl) k e le) m

        (CL_State f s' k' e le) m



  | clight_corestep_internal_function: forall f vargs k m e le m',

      function_entry f vargs m e le m' ->

      clight_corestep (CL_Callstate (Internal f) vargs k) m

        (CL_State f f.(fn_body) k e le) m'



  | clight_corestep_returnstate: forall v optid f e le k m,

      clight_corestep (CL_Returnstate v (Kcall optid f e le k)) m

        (CL_State f Sskip k e (set_opttemp optid v le)) m.



Lemma CL_corestep_not_at_external:

       forall m q m' q', clight_corestep q m q' m' -> CL_at_external q = None.

  Proof. intros. inv H; reflexivity. Qed.



Lemma CL_corestep_not_halted : forall m q m' q',

       clight_corestep q m q' m' -> CL_halted q = None.

  Proof. intros. inv H; reflexivity. Qed.



Lemma CL_at_external_halted_excl :

       forall q, CL_at_external q = None \/ CL_halted q = None.

   Proof. intros. destruct q; auto. Qed.



Lemma CL_after_at_external_excl : forall retv q q',

      CL_after_external retv q = Some q' -> CL_at_external q' = None.

  Proof. intros.

       destruct q; simpl in *; try inv H.

       destruct fd; inv H1.

       destruct retv; inv H0; simpl; trivial.



Qed.



Definition CL_initial_core (v: val) (args:list val): option CL_core :=

   match v with

     | Vptr b i =>

          if Int.eq_dec i Int.zero

          then match Genv.find_funct_ptr ge b with

                 | None => None

                 | Some f => Some (CL_Callstate f args Kstop)

               end

          else None

     | _ => None

    end.

End SEMANTICS.



Definition CL_core_sem (FE:function -> list val -> mem -> env -> temp_env -> mem -> Prop)

         : CoreSemantics genv CL_core mem.

  eapply @Build_CoreSemantics with (at_external:=CL_at_external)

                  (after_external:=CL_after_external)

                  (corestep:=clight_corestep FE)

                  (halted:=CL_halted).

    apply CL_initial_core.

    apply CL_corestep_not_at_external.

    apply CL_corestep_not_halted.

    apply CL_at_external_halted_excl.

    apply CL_after_at_external_excl.

Defined.



Lemma CL_forward :

  forall (FE: function -> list val -> mem -> env -> temp_env -> mem -> Prop)

         (HFE: forall f vargs m e le m', FE f vargs m e le m'-> mem_forward m m')

         g c m c' m' (CS: clight_corestep FE g c m c' m'),

                     mem_forward m m'.

  Proof. intros.

     inv CS; simpl in *; try apply mem_forward_refl.

         

          inv H2.

          eapply store_forward. eassumption.

          eapply storebytes_forward. eassumption.

         

         eapply freelist_forward; eassumption.

         eapply freelist_forward; eassumption.

         eapply freelist_forward; eassumption.

       eapply HFE. apply H.

Qed.



Definition CL_coop_sem

           (FE:function -> list val -> mem -> env -> temp_env -> mem -> Prop)

           (HFE: forall f vargs m e le m', FE f vargs m e le m'-> mem_forward m m')

           : CoopCoreSem genv CL_core.

apply Build_CoopCoreSem with (coopsem := CL_core_sem FE).

  apply CL_forward. apply HFE.

Defined.



Lemma alloc_variables_forward: forall vars m e e2 m'

      (M: alloc_variables e m vars e2 m'),

      mem_forward m m'.

Proof. intros.

  induction M.

  apply mem_forward_refl.

  apply alloc_forward in H.

  eapply mem_forward_trans; eassumption.

Qed.



Lemma bind_parameter_forward: forall e m pars vargs m'

      (M: bind_parameters e m pars vargs m'),

      mem_forward m m'.

Proof. intros.

  induction M.

  apply mem_forward_refl.

  eapply mem_forward_trans; try eassumption.

  inv H0.

  eapply store_forward. eassumption.

  eapply storebytes_forward. eassumption.

Qed.



Inductive function_entry1 (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=

  | function_entry1_intro: forall m1,

      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->

      alloc_variables empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->

      bind_parameters e m1 f.(fn_params) vargs m' ->

      le = create_undef_temps f.(fn_temps) ->

      function_entry1 f vargs m e le m'.



Lemma function_entry1_forward: forall f vargs m e le m',

      function_entry1 f vargs m e le m'-> mem_forward m m'.

Proof. intros. inv H.

  eapply mem_forward_trans.

    eapply alloc_variables_forward; try eassumption.

    eapply bind_parameter_forward; eassumption.

Qed.



Definition CL_core_sem1 := CL_core_sem function_entry1.

Definition CL_coop_sem1 : CoopCoreSem genv CL_core.

  eapply (CL_coop_sem function_entry1).

  apply function_entry1_forward.

Defined.



Inductive function_entry2 (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=

  | function_entry2_intro:

      list_norepet (var_names f.(fn_vars)) ->

      list_norepet (var_names f.(fn_params)) ->

      list_disjoint (var_names f.(fn_params)) (var_names f.(fn_temps)) ->

      alloc_variables empty_env m f.(fn_vars) e m' ->

      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->

      function_entry2 f vargs m e le m'.



Lemma function_entry2_forward: forall f vargs m e le m',

      function_entry2 f vargs m e le m'-> mem_forward m m'.

Proof. intros. inv H.

    eapply alloc_variables_forward; try eassumption.

Qed.



Definition CL_core_sem2 := CL_core_sem function_entry2.

Definition CL_coop_sem2 : CoopCoreSem genv CL_core.

  eapply (CL_coop_sem function_entry2).

  apply function_entry2_forward.

Defined.



