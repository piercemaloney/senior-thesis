

Set Implicit Arguments.



Require Import FCF.Comp.
(* FCF.Comp:
Set Implicit Arguments.

Require Export Bvector.
Require Export List.
Require Export FCF.Blist.
Require Export FCF.EqDec.
Require Import FCF.Fold.

Inductive Comp : Set -> Type :=
| Ret : forall (A : Set), eq_dec A -> A -> Comp A
| Bind : forall (A B : Set), Comp B -> (B -> Comp A) -> Comp A
| Rnd : forall n, Comp (Bvector n)
| Repeat : forall (A : Set), Comp A -> (A -> bool) -> Comp A.

Inductive Comp_eq : forall (A : Set), Comp A -> Comp A -> Prop :=
  | Comp_eq_Ret : forall (A : Set)(pf1 pf2 : eq_dec A)(a : A),
    Comp_eq (Ret pf1 a) (Ret pf2 a)
  | Comp_eq_Bind : forall (A B : Set)(c1x c1y : Comp B)(c2x c2y : B -> Comp A),
    Comp_eq c1x c1y ->
    (forall b, (Comp_eq (c2x b) (c2y b))) ->
    Comp_eq (Bind c1x c2x) (Bind c1y c2y)
  | Comp_eq_Rnd : forall n,
    Comp_eq (Rnd n) (Rnd n)
  | Comp_eq_Repeat : forall (A : Set)(c1 c2 : Comp A)(P1 P2 : A -> bool),
    Comp_eq c1 c2 ->
    (forall a, P1 a = P2 a) ->
    Comp_eq (Repeat c1 P1) (Repeat c2 P2).

Hint Constructors Comp_eq : comp.

Theorem Comp_eq_refl : forall (A : Set)(c : Comp A),
  Comp_eq c c.

Lemma Bvector_exists : forall n,
  Bvector n.

Lemma comp_base_exists : forall (A : Set),
  Comp A ->
  A.

Require Import FCF.EqDec. 

Lemma comp_EqDec : forall (A : Set),
  Comp A ->
  EqDec A.

Lemma comp_eq_dec : forall (A : Set),
  Comp A ->
  eq_dec A.

Lemma bind_EqDec : forall (A B : Set),
  Comp B ->
  (B -> Comp A) ->
  EqDec A.

Lemma bind_eq_dec : forall (A B : Set),
  Comp B ->
  (B -> Comp A) ->
  eq_dec A.

Fixpoint getSupport(A : Set)(c : Comp A) : list A :=
  match c with
    | Ret _ a => a :: nil
    | Bind c1 c2 => getUnique (flatten (map (fun b => (getSupport (c2 b))) (getSupport c1))) (bind_eq_dec c1 c2)
    | Rnd n => getAllBvectors n
    | Repeat c1 P => (filter P (getSupport c1))
  end.

Inductive well_formed_comp : forall (A : Set), Comp A -> Prop :=
  | well_formed_Ret :
    forall (A : Set)(pf : eq_dec A)(a : A),
      well_formed_comp (Ret pf a)
  | well_formed_Bind : 
    forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A),
      well_formed_comp c1 ->
      (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
      well_formed_comp (Bind c1 c2)
   | well_formed_Rnd : forall n,
     well_formed_comp (Rnd n)
   | well_formed_Repeat :
     forall (A : Set)(eqd : eq_dec A)(c : Comp A) P b,
      well_formed_comp c ->
      In b (filter P (getSupport c)) ->
      well_formed_comp (Repeat c P).

Delimit Scope comp_scope with comp.

Theorem lt_eq_false : 
  forall n,
    n < n -> False.

Lemma length_nz_exists : forall (A : Type)(ls : list A),
                           length ls > 0 ->
                           exists a, In a ls.

Theorem getSupport_length_nz : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  length (getSupport c) > 0.

Lemma filter_NoDup : forall (A : Set)(ls : list A)(P : A -> bool),
  NoDup ls ->
  NoDup (filter P ls).

Lemma getSupport_NoDup : forall (A : Set)(c : Comp A),
  NoDup (getSupport c).

Lemma getSupport_Bind_In : forall (A B : Set) (c : Comp B)(f : B -> Comp A) a,
  In a (getSupport (Bind c f)) ->
  exists b, 
    In b (getSupport c) /\
    In a (getSupport (f b)).

Ltac pairInv :=
  match goal with 
    | [H : (_, _) = (_, _) |-_ ] => inversion H; clear H; subst
  end.

Ltac destruct_exists :=
  match goal with
    | [H : exists x, _ |- _ ] =>
      destruct H
  end.

Theorem getSupport_In_Ret : 
  forall (A : Set)(eqd : eq_dec A) x a,
    In x (getSupport (Ret eqd a)) ->
    x = a.

Theorem getSupport_In_Seq :
  forall (A B : Set)(c : Comp A)(f : A -> Comp B) b a,
    In a (getSupport c) ->
    In b (getSupport (f a)) ->
    In b (getSupport (Bind c f)).

Local Open Scope comp_scope.

Definition maybeBind(A B : Type)(opt_a : option A)(f : A -> B) : option B :=
  match opt_a with
    | None => None
    | Some a => Some (f a)
  end.

Inductive OracleComp : Set -> Set -> Set -> Type :=
| OC_Query : forall (A B : Set), A -> OracleComp A B B
| OC_Run : forall (A B C A' B' S : Set), 
  EqDec S ->
  EqDec B ->
  EqDec A ->
  OracleComp A B C ->
  (S -> A -> OracleComp A' B' (B * S)) ->
  S ->
  OracleComp A' B' (C * S)
| OC_Ret : forall A B C, Comp C -> OracleComp A B C
| OC_Bind : forall A B C C', OracleComp A B C -> (C -> OracleComp A B C') -> OracleComp A B C'.

Theorem oc_base_exists : forall (A B C : Set), OracleComp A B C -> (A -> B) -> C.

Theorem oc_EqDec : forall (A B C: Set),  OracleComp A B C -> (A -> B) -> (A -> EqDec B) -> EqDec C.

Lemma well_formed_val_exists : 
  forall (A : Set)(c : Comp A),
    well_formed_comp c ->
    exists x, In x (getSupport c). *)

Require Import FCF.DetSem.
(* FCF.DetSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Import FCF.Blist.
Require Import FCF.Fold.
Require Import Permutation.
Require Import Omega.

Local Open Scope list_scope. 
Local Open Scope comp_scope.

Inductive comp_state(A : Set) :=
  | cs_done : A -> Blist -> comp_state A
  | cs_eof : comp_state A
  | cs_more : Comp A -> Blist -> comp_state A.

Inductive comp_answer(A : Set) :=
  | ca_done : A -> comp_answer A
  | ca_eof : comp_answer A.

Lemma comp_answer_eq_dec : forall (A : Set),
      eq_dec A ->
      eq_dec (comp_answer A).

Fixpoint evalDet_step(A : Set)(c : Comp A)(s : Blist) : comp_state A :=
  match c in Comp A return comp_state A with
    | Ret pf a => cs_done a s
    | Rnd n  => 
      match (shiftOut s n) with
        | Some (v, s') => cs_more (Ret (@Bvector_eq_dec n) v) s'
        | None => (@cs_eof (Bvector n))
      end
    | Bind c1 c2 =>     
      match (evalDet_step c1 s) with
        | cs_eof _ => (@cs_eof _)
        | cs_done b s' => cs_more (c2 b) s'
        | cs_more c1' s' => cs_more (Bind c1' c2) s'
      end
    | Repeat c P =>
      cs_more (Bind c (fun a => if (P a) then (Ret (comp_eq_dec c) a) else (Repeat c P))) s
   end.

Inductive evalDet_steps(A : Set) : comp_state A -> comp_state A -> Prop :=
  | evalDet_steps_refl : forall ans,
    evalDet_steps ans ans
  | evalDet_steps_step : 
    forall c s ans ans',
      (evalDet_step c s) = ans ->
      evalDet_steps ans ans' ->
      evalDet_steps (cs_more c s) ans'.

Hint Constructors evalDet_steps : evalDet.

Inductive evalDet(A : Set)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_done : forall a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    evalDet c s (ca_done a)
  | evalDet_eof :
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet c s (@ca_eof A).
    
Theorem evalDet_steps_trans : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall z, 
  evalDet_steps y z ->
  evalDet_steps x z.

Theorem evalDet_steps_bind_more_h : forall(A B : Set) x y,
  evalDet_steps x y ->
  forall (c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  x = (cs_more c1 s) ->
  y =  (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Theorem evalDet_steps_bind_more : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  evalDet_steps (cs_more c1 s) (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Lemma evalDet_steps_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a : A) s s',
  x = (cs_more c s) -> 
  y = (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_done_inv : forall (A : Set)(c : Comp A)(a : A) s s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s,
  x = (cs_more c s) -> 
  y = (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Lemma evalDet_steps_eof_inv : forall (A : Set)(c : Comp A) s,
  evalDet_steps (cs_more c s) (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Theorem evalDet_steps_bind_done : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a s s',
  evalDet_steps (cs_more c1 s) (cs_done a s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (c2 a) s').

Theorem evalDet_bind_eof : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more c1 s) (@cs_eof B) ->
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A).

Inductive comp_state_eq(A : Set) : comp_state A -> comp_state A -> Prop :=
  | cse_done : 
    forall a s, 
      comp_state_eq (cs_done a s) (cs_done a s)
  | cse_eof : 
    comp_state_eq (@cs_eof A) (@cs_eof A)
  | cse_more : 
    forall c1 c2 s,
      Comp_eq c1 c2 ->
      comp_state_eq (cs_more c1 s) (cs_more c2 s).

Theorem comp_state_eq_refl : forall (A : Set)(c : comp_state A),
  comp_state_eq c c.

Lemma evalDet_steps_done_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a a' s s',
  y1 = (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Theorem evalDet_steps_done_func : forall (A : Set) x (a a' : A) s s',
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Lemma evalDet_steps_done_eof_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a s,
  y1 = (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_steps_done_eof_func : forall (A : Set) x (a : A) s,
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_func : forall (A : Set)(c : Comp A)(s : Blist)(y1 y2 : comp_answer A),
  evalDet c s y1 ->
  evalDet c s y2 ->
  y1 = y2.

Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) :=
  (forall s y, evalDet c1 s y <-> evalDet c2 s y).

Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A),
  evalDet_equiv c1 c2 ->
  evalDet_equiv c2 c1.

Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
    x = (cs_more (Bind c1 c2) s) ->
    y = (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_eof_inv_h : 
  forall (A : Set)(x y : comp_state A),
    evalDet_steps x y ->
    forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
      x = (cs_more (Bind c1 c2) s) ->
      y = (@cs_eof A) ->
      evalDet_steps (cs_more c1 s) (@cs_eof B) \/
      exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
        evalDet_steps (cs_more (c2 b) s') (@cs_eof A).
  
Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) ->
  evalDet_steps (cs_more c1 s) (@cs_eof B) \/
  exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
    evalDet_steps (cs_more (c2 b) s') (@cs_eof A).

Theorem evalDet_bind_assoc : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),
  evalDet_equiv (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).

Theorem evalDet_done_eof_func:
  forall (A : Set) (c : Comp A) (a : A) (s : Blist),
    evalDet c s (ca_done a) -> evalDet c s (@ca_eof A) -> False.

Lemma getSupport_In_evalDet_step_done : forall (A : Set)(c : Comp A) a s s',
  evalDet_step c s = cs_done a s' ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_step_more : forall (A : Set)(c c' : Comp A) s s' a,
  evalDet_step c s = cs_more c' s' ->
  In a (getSupport c') ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_steps_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a s s',
    x = (cs_more c s)  ->
    y = (cs_done a s') -> 
    In a (getSupport c).

Lemma getSupport_In_evalDet_steps : forall (A : Set)(c : Comp A) a s s',
  evalDet_steps (cs_more c s) (cs_done a s') -> 
  In a (getSupport c).

Theorem getSupport_In_evalDet : forall (A : Set)(c : Comp A) a s,
  evalDet c s (ca_done a) -> 
  In a (getSupport c).

Inductive evalDet_repeat_steps (A : Set)(P : A -> bool) : comp_state A -> comp_state A -> Prop :=
| evalDet_repeat_steps_done : 
  forall c s a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = true ->
    evalDet_repeat_steps P (cs_more c s) (cs_done a s')
| evalDet_repeat_steps_eof :
  forall c s,
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A)
| evalDet_repeat_steps_step :
  forall c s a s' y,
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = false ->
    evalDet_repeat_steps P (cs_more c s') y ->
    evalDet_repeat_steps P (cs_more c s) y.

Inductive evalDet_repeat(A : Set)(P : A -> bool)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_repeat_done : forall a s',
    evalDet_repeat_steps P (cs_more c s) (cs_done a s') ->
    evalDet_repeat P c s (ca_done a)
  | evalDet_repeat_eof :
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A) ->
    evalDet_repeat P c s (@ca_eof A).

Lemma list_skipn_strong_ind_h : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  (forall n, P (skipn n l)).

Lemma list_skipn_strong_ind : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  P l.

Lemma evalDet_step_nil_inv : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_step c nil = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_step c nil = (cs_done a ls) ->
  ls = nil.

Lemma evalDet_step_more_nil_inv : forall (A : Set)(c c' : Comp A) ls,
  evalDet_step c nil = (cs_more c' ls) ->
  ls = nil.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) s a,
  evalDet_step c s = cs_done a s ->
  getSupport c = (a :: nil).

Lemma getUnique_NoDup_eq : forall (A : Set)(eqd : eq_dec A)(ls : list A),
  NoDup ls ->
  getUnique ls eqd = ls.

Lemma getUnique_Permutation : forall (A : Set)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  Permutation (getUnique ls1 eqd1) (getUnique ls2 eqd2).

Lemma flatten_Permutation : forall (A : Type)(ls1 ls2 : list (list A)),
  Permutation ls1 ls2 ->
  Permutation (flatten ls1) (flatten ls2).

Lemma to_list_nil_inv : forall (A : Type)(n : nat)(v : Vector.t A n),

Lemma app_second_eq :
  forall (A : Type) (ls2 ls1 ls3 : list A),
    ls1 = ls2 ++ ls3 -> length ls1 = length ls3 -> ls1 = ls3 /\ ls2 = nil.

Lemma shiftOut_same_inv : forall s n v,
  shiftOut s n = Some (v, s) ->
  n = O.

Lemma filter_Permutation : forall (A : Set)(ls1 ls2 : list A)(P : A -> bool),
  Permutation ls1 ls2 ->
  Permutation (filter P ls1) (filter P ls2).

Lemma evalDet_step_more_support_preserved : forall (A : Set)(c c' : Comp A) s,
  evalDet_step c s = (cs_more c' s) ->
  Permutation (getSupport c) (getSupport c').

Lemma evalDet_steps_nil_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a1 a2 : A) s2,
  x = (cs_more c nil) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_steps_nil_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_steps (cs_more c nil) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_val_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_ls_eq : forall (A : Set)(c : Comp A)(a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  s1 = s2.

Lemma shiftOut_skipn : forall n (v : Bvector n) s s',
  shiftOut s n = Some (v, s') ->
  s' = skipn n s.

Lemma evalDet_step_more_skipn_eq : forall (A : Set)(c c' : Comp A)(a1 : A) s1 s2,
  evalDet_step c s1 = (cs_more c' s2) ->
  In a1 (getSupport c) ->
  (s1 = s2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_step_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_step  c s = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma skipn_sum : forall (A : Type)(n2 n1 : nat)(ls : list A),
  skipn n1 (skipn n2 ls) = skipn (n2 + n1) ls.

Lemma evalDet_step_more_skipn : forall (A : Set)(c c' : Comp A) s s',
  evalDet_step  c s = (cs_more c' s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s a s', 
    x = (cs_more c s) ->
    y = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_skipn_h : forall (A : Set) a1 (x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a2 : A) s1 s2,
  x = (cs_more c s1) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_steps_skipn : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_steps (cs_more c s1) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_repeat_steps_dec : forall (s : Blist)(A : Set)(c : Comp A)(P : A -> bool),
  (exists a, In a (getSupport c) /\ P a = true) ->
  (forall s', (exists a s'', evalDet_steps (cs_more c s') (cs_done a s'')) \/ evalDet_steps (cs_more c s') (@cs_eof A)) ->
  exists y, evalDet_repeat_steps P (cs_more c s) y.

Lemma evalDet_repeat_steps_done_inv_h : forall (A : Set)(P : A -> bool) x y,
  evalDet_repeat_steps P x y ->
  forall c s,
  x = (cs_more c s) -> 
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_done_inv : forall (A : Set)(c : Comp A)(P : A -> bool) s y,
  evalDet_repeat_steps P (cs_more c s) y ->
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_more_inv_h : forall (A : Set)(x y : comp_state A) P,
  evalDet_repeat_steps P x y ->
  forall (c: Comp A)(P : A -> bool) s,
  y = (cs_more c s) ->
  False.

Lemma evalDet_repeat_steps_more_inv : forall (A : Set) x (c : Comp A)(P : A -> bool) s,
  evalDet_repeat_steps P x (cs_more c s) ->
  False.

Lemma evalDet_steps_dec : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall s, 
  (exists a s', evalDet_steps (cs_more c s) (cs_done a s')) \/ 
  (evalDet_steps (cs_more c s) (@cs_eof A)).

Lemma evalDet_dec : forall (A : Set)(c : Comp A)(s : Blist),
  well_formed_comp c ->
  (exists a, evalDet c s (ca_done a)) \/ (evalDet c s (@ca_eof A)).

Lemma evalDet_step_app_done_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_step c s = (cs_done a s'') ->
  evalDet_step c (s ++ s') = (cs_done a (s'' ++ s')).

Lemma evalDet_step_app_more_eq : forall (A : Set)(c c': Comp A) s s' s'',
  evalDet_step c s = (cs_more c' s'') ->
  evalDet_step c (s ++ s') = (cs_more c' (s'' ++ s')).

Lemma evalDet_steps_app_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s s' s'' a,
    x = (cs_more c s) ->
    y = (cs_done a s'') ->
    evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_steps_app_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_steps (cs_more c s) (cs_done a s'') ->
  evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_app_eq : forall (A : Set)(c : Comp A) s s' a,
  evalDet c s (ca_done a) ->
  evalDet c (s ++ s') (ca_done a).

Lemma evalDet_steps_done_nil_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls,
    x = (cs_more c nil) ->
    y = (cs_done a ls) ->
    ls = nil.

Lemma evalDet_steps_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma app_eq_nil_inv : forall (A : Set)(ls2 ls1 ls3 : list A),
  ls1 = ls2 ++ ls3 ->
  length ls1 = length ls2 ->
  ls3 = nil.

Lemma evalDet_steps_repeat_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s a s',
  evalDet_steps x (cs_more (Repeat c P) s) ->
  y = (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_done_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s a s',
  evalDet_steps (cs_more (Repeat c P) s) (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s,
    evalDet_steps x (cs_more (Repeat c P) s) ->
    y = (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_steps_repeat_eof_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s,
  evalDet_steps (cs_more (Repeat c P) s) (cs_eof A)->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_repeat_steps_nil_inv_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall (P : A -> bool) c a ls',
  x = (cs_more c nil) ->
  y = (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_nil_inv : forall (A : Set)(P : A -> bool) c a ls',
  evalDet_repeat_steps P (cs_more c nil) (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_app_nil_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall c ls1 ls2 b a,
    x = (cs_more c ls1) ->
    y = (cs_eof A) ->
    evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2)->
    (forall s s' b a,
      evalDet_steps (cs_more c s) (cs_eof A) ->
      evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
      s' = nil) ->
    ls2 = nil.

Lemma evalDet_repeat_steps_app_nil : forall (A : Set)(c : Comp A) P ls1 ls2 b a,
  evalDet_repeat_steps P (cs_more c ls1) (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  (forall s s' b a,
    evalDet_steps (cs_more c s) (cs_eof A) ->
    evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
    s' = nil) ->
  ls2 = nil.

Lemma evalDet_app_nil : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall ls1 ls2 b a,
  evalDet c ls1 (ca_eof A) ->
  evalDet_steps (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  ls2 = nil.

Lemma evalDet_step_done_inv : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_step c ls = cs_done a ls' ->
  exists eqd, 
    c = Ret eqd a.

Lemma evalDet_step_more_sublist : forall (A : Set)(c : Comp A) c' ls ls',
  evalDet_step c ls = (cs_more c' ls') ->
  exists ls'', ls = ls'' ++ ls'.
    
Lemma evalDet_sublist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls ls' ,
    x = (cs_more c ls) ->
    y = (cs_done a ls') ->
    exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_sublist : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_steps (cs_more c ls) (cs_done a ls') ->
  exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_nil : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma evalDet_left_total : forall (A : Set)(c : Comp A) s,
  well_formed_comp c ->
  exists ans, evalDet c s ans.
  
Lemma evalDet_steps_done_support_singleton_h : forall (A : Set)(x1 x2 : comp_state A),
  evalDet_steps x1 x2 ->
  forall (c : Comp A) a s,
    x1 = (cs_more c nil) ->
    x2 = (cs_done a s) ->
    getSupport c = a :: nil.

Lemma evalDet_steps_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  getSupport c = a :: nil.

Lemma evalDet_step_well_formed_comp_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' s s',
    evalDet_step c s = (cs_more c' s') ->
    well_formed_comp c'. *)

Require Import FCF.DistSem.
(* FCF.DistSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Export FCF.Rat.
Require Import FCF.Fold.
Require Import List.
Require Import FCF.Blist.
Require Import Omega.
Require Import FCF.StdNat.
Require Import FCF.NotationV1.
 
Local Open Scope list_scope.
Local Open Scope rat_scope.

Ltac simp_in_support := 
  unfold setLet in *;
  match goal with
    | [H : In _ (getSupport (Bind _ _)) |- _ ] =>
      apply getSupport_Bind_In in H; destruct_exists; intuition
    | [H : In _ (getSupport (if ?t then _ else _)) |- _ ] => let x := fresh "x" in remember t as x; destruct x
    | [H : In _ (getSupport (ret _)) |- _ ] => apply getSupport_In_Ret in H; try pairInv; subst

    | [H : true = negb ?t |- _ ] => let x := fresh "x" in remember t as x; destruct x; simpl in H; try discriminate
  end.

Definition Distribution(A : Set) := A -> Rat.

Definition indicator(A : Set)(P : A -> bool) :=
  fun a => if (P a) then rat1 else rat0.

Fixpoint evalDist(A : Set)(c : Comp A) : Distribution A :=
  match c with
    | Ret eqd a => fun a' => if (eqd a a') then 1 else 0
    | Bind c1 c2 => fun a => 
      sumList (getSupport c1) (fun b => (evalDist c1 b) * (evalDist (c2 b) a))
    | Rnd n => fun v => 1 / (expnat 2 n)
    | Repeat c P => fun a => (indicator P a) * (ratInverse (sumList (filter P (getSupport c)) (evalDist c))) * (evalDist c a)
  end.

Definition dist_sem_eq(A : Set)(c1 c2 : Comp A) :=
  forall a, (evalDist c1 a) == (evalDist c2 a).

Definition Support(A : Set)(ls : list A)(d : Distribution A) :=
  NoDup ls /\
  (forall a, In a ls <-> ~((d a) == 0)).

Lemma getSupport_NoDup : forall (A : Set)(c : Comp A),
  NoDup (getSupport c).

Lemma filter_not_In : forall (A : Set)(ls : list A)(P : A -> bool) a,
                        (~In a ls) \/ P a = false <->
                        ~In a (filter P ls).

Theorem getSupport_In_evalDist : forall (A : Set)(c : Comp A)(a : A),
  In a (getSupport c) <-> ~(evalDist c a == 0).

Theorem getSupport_not_In_evalDist_h : forall (A : Set)(c : Comp A)(a : A),
~In a (getSupport c) -> (evalDist c a == 0).

Theorem getSupport_not_In_evalDist : forall (A : Set)(c : Comp A)(a : A),
  ~In a (getSupport c) <-> (evalDist c a == 0).

Theorem getSupport_correct : forall (A : Set)(c : Comp A),
  Support (getSupport c)(evalDist c).

Notation "'Pr' [ c  ] " := (evalDist c true) (at level 20).

Lemma evalDist_sum_bind_eq : forall (A B : Set)(eqdb : eq_dec B)(eqda : eq_dec A)(c1 : Comp B)(c2 : B -> Comp A),
  sumList (getSupport (Bind c1 c2)) (evalDist (Bind c1 c2)) ==
  sumList (getSupport c1) (fun b => evalDist c1 b * (sumList (getSupport (c2 b)) (evalDist (c2 b)))).
  
Lemma ratInverse_scale_sum_1 : forall (A : Set)(ls : list A)(f : A -> Rat),
  (forall a, In a ls -> ~f a == 0) ->
  length ls > O ->
  sumList ls (fun a => (ratInverse (sumList ls f)) * (f a)) == 1.

Lemma evalDist_lossless : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  sumList (getSupport c) (evalDist c) == 1.

Lemma sumList_filter_evalDist_le_1 : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  In a (filter P (getSupport c)) ->
  1 <= sumList (filter (fun a' => negb (P a')) (getSupport c)) (evalDist c) ->
  False.

Theorem sumList_support_bool : 
  forall (c : Comp bool),
    sumList (getSupport c) (evalDist c) ==
    evalDist c true + evalDist c false.
  
Lemma evalDist_sum_le_1 : forall (A : Set)(c : Comp A),
  sumList (getSupport c) (evalDist c) <= 1.

Lemma evalDist_le_1 : forall (A : Set)(c : Comp A) a,
  evalDist c a <= 1.

Theorem evalDist_complement : 
  forall (c : Comp bool),
    well_formed_comp c ->
    evalDist c false == ratSubtract 1 (Pr[c]).

Theorem evalDist_le_1_gen : 
  forall (A : Set)(eqd : EqDec A)(c : Comp A)(ls : list A),
    NoDup ls ->
    sumList ls (evalDist c) <= 1.

Theorem evalDist_1_0 : 
  forall (A : Set){eqd : EqDec A}(c : Comp A) a,
    well_formed_comp c ->
    evalDist c a == 1 ->
      (forall b, b <> a -> evalDist c b == 0).
   
Local Open Scope comp_scope.

Theorem EqDec_pair_l 
  : forall (A B : Set)(eqd : EqDec (A * B))(b : B),
    EqDec A.

Fixpoint evalDist_OC(A B C: Set)(c : OracleComp A B C): forall(S : Set), EqDec S -> (S -> A -> Comp (B * S)) -> S -> Comp (C * S) :=
  match c in (OracleComp A B C) return (forall(S : Set), EqDec S -> (S -> A -> Comp (B * S)) -> S -> Comp (C * S))
    with
    | @OC_Query A' B' a => 
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>  
        o s a
    | @OC_Run A'' B'' C' A' B' S' eqds' eqda'' eqdb'' c' o' s' =>
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      p <-$ evalDist_OC c' (pair_EqDec eqds' eqds) (fun x y => p <-$ evalDist_OC (o' (fst x) y) _ o (snd x); ret (fst (fst p), (snd (fst p), snd p))) (s', s);
      Ret 
      (EqDec_dec (pair_EqDec (pair_EqDec 
        (oc_EqDec c' (fun x => fst (oc_base_exists (o' s' x) (fun y => fst (comp_base_exists (o s y))))) (fun x => EqDec_pair_l (oc_EqDec (o' s' x) (fun y => fst (comp_base_exists (o s y))) (fun y => EqDec_pair_l (comp_EqDec (o s y)) s)) s' ))
        _) _ ))
      (fst p, fst (snd p), snd (snd p))

    | @OC_Ret A' B' C' c => 
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      x <-$ c; Ret 
      (EqDec_dec (pair_EqDec (comp_EqDec c) _ ))
      (x, s)
    | @OC_Bind A' B' C' C'' c' f' =>
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      [z, s'] <-$2 evalDist_OC c' _ o s;
      evalDist_OC (f' z) _ o s'
  end.

Coercion evalDist_OC : OracleComp >-> Funclass.

Inductive well_formed_oc : forall (A B C : Set), OracleComp A B C -> Prop :=
| well_formed_OC_Query :
  forall (A B : Set)(a : A),
    well_formed_oc (OC_Query B a)
| well_formed_OC_Run : 
  forall (A B C A' B' S : Set)
  (eqds : EqDec S)(eqdb : EqDec B)(eqda : EqDec A)(c : OracleComp A B C)
  (o : S -> A -> OracleComp A' B' (B * S))(s : S),
  well_formed_oc c ->
  (forall s a, well_formed_oc (o s a)) ->
  well_formed_oc (OC_Run eqds eqdb eqda c o s)
| well_formed_OC_Ret : 
  forall (A B C : Set)(c : Comp C),
      well_formed_comp c ->
      well_formed_oc (OC_Ret A B c)
| well_formed_OC_Bind : 
  forall (A B C C' : Set)(c : OracleComp A B C)(f : C -> OracleComp A B C'),
    well_formed_oc c ->
    (forall c, well_formed_oc (f c)) ->
    well_formed_oc (OC_Bind c f).

Local Open Scope nat_scope.

Definition in_oc_support(A B C : Set)(x : C)(c : OracleComp A B C) :=
  exists (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s s' : S),
    In (x, s') (getSupport (c _ _ o s)).

Inductive queries_at_most : forall (A B C : Set), OracleComp A B C -> nat -> Prop :=
| qam_Bind : 
  forall (A B C C' : Set)(c : OracleComp A B C')(f : C' -> OracleComp A B C) q1 q2,
    queries_at_most c q1 ->
    (forall c',
      in_oc_support c' c ->
       queries_at_most (f c') q2) ->
    queries_at_most (OC_Bind c f) (q1 + q2)
| qam_Query : 
  forall (A B : Set)(a : A),
  queries_at_most (OC_Query B a) 1
| qam_Ret : 
  forall (A B C : Set)(c : Comp C),
    queries_at_most (OC_Ret A B c) 0
| qam_Run :
  forall (A A' B B' C S : Set)(eqds : EqDec S)(eqda : EqDec A)(eqdb : EqDec B)
    (c : OracleComp A B C)(oc : S -> A -> OracleComp A' B' (B * S)) s q1 q2,
    queries_at_most c q1 ->
    (forall s a, queries_at_most (oc s a) q2) ->
    queries_at_most (OC_Run _ _ _ c oc s) (q1 * q2)
| qam_le : 
  forall (A B C : Set)(c : OracleComp A B C) q1 q2,
    queries_at_most c q1 ->
    q1 <= q2 ->
    queries_at_most c q2. *)

Require Import FCF.Rat.
(* FCF.Rat:
Set Implicit Arguments.

Require Import Omega.
Require Import List.
Require Import FCF.StdNat.
Require Import Arith.
Require Import Lia.

Inductive Rat :=
    RatIntro : nat -> posnat -> Rat.

Definition ratCD(r1 r2 : Rat) : (nat * nat * posnat) :=
  match (r1, r2) with
    | (RatIntro n1 d1, RatIntro n2 d2) =>
      ((n1 * d2), (n2 * d1), (posnatMult d1 d2))
  end.

Definition ratMult(r1 r2 : Rat) : Rat :=
  match (r1, r2) with
    | (RatIntro n1 d1, RatIntro n2 d2) =>
      RatIntro (n1 * n2) (posnatMult d1 d2)
  end.

Definition rat1 := (RatIntro 1 (pos 1)).
Definition rat0 := (RatIntro 0 (pos 1)).

Definition ratAdd(r1 r2 : Rat) : Rat :=
  match ratCD r1 r2 with
    | (n1, n2, d) => 
      RatIntro (n1 + n2) d
  end.

Definition ratSubtract(r1 r2: Rat) : Rat :=
  match ratCD r1 r2 with
    | (n1, n2, d) =>
      RatIntro (n1 - n2) d
  end.

Definition beqRat(r1 r2 : Rat) :=
  match (ratCD r1 r2) with
    | (n1, n2, _) => 
      if (eq_nat_dec n1 n2) then true else false
  end.

Definition bleRat(r1 r2 : Rat) :=
  match (ratCD r1 r2) with
    | (n1, n2, _) => 
      if (le_gt_dec n1 n2) then true else false
  end.

Definition eqRat(r1 r2 : Rat) :=
  beqRat r1 r2 = true.

Definition leRat(r1 r2 : Rat) := 
  bleRat r1 r2 = true.

Definition maxRat(r1 r2 : Rat) :=
  if (bleRat r1 r2) then r2 else r1.

Definition minRat(r1 r2 : Rat) :=
  if (bleRat r1 r2) then r1 else r2.

Definition ratDistance(r1 r2 : Rat) :=
  ratSubtract (maxRat r1 r2) (minRat r1 r2).

Ltac rattac_one := 
  match goal with 
    
    | [|- posnatMult ?x1 ?x2 = posnatMult ?x2 ?x1] => apply posnatMult_comm
    | [|- posnatToNat (posnatMult ?x1 ?x2) = posnatToNat (posnatMult ?x2 ?x1)] => rewrite posnatMult_comm; trivial
    | [|- ?x1 * ?x2 = ?x2 * ?x1 ] => apply mult_comm
    | [|- (mult (?x1 + ?x2) _)  = (mult (?x2 + ?x1) _ )] => f_equal
    | [|- ?x1 * ?x2 * _ = ?x2 * ?x1 * _ ] => f_equal
    | [ |- posnatToNat ?p > 0 ] => destruct p; unfold posnatToNat; omega
      
    | [H1 : ?n * ?x = ?n0 * ?x1, H2: ?n1 * ?x1 = ?n * ?x0 |- ?n1 * ?x = ?n0 * ?x0 ] => eapply (@mult_same_l x1) 
    | [H : ?x = ?n * (posnatToNat ?p) |- ?x = (posnatToNat ?p) * ?n ] => rewrite H
    | [H : RatIntro _ _ = RatIntro _ _ |- _ ] => inversion H; clear H; subst
    | [H : (eqRat _ _) |- _ ] => unfold eqRat, beqRat in H
    | [H : (leRat _ _) |- _ ] => unfold leRat, bleRat in H
    | [H : ?r = RatIntro _ _ |- context[match ?r with | RatIntro _ _ => _ end] ] => rewrite r
    
    | [|- context[match ?r with | RatIntro _ _ => _ end] ] => case_eq r; intuition
    | [H : (_ , _) = (_ , _) |- _ ] => inversion H; clear H; subst
    | [|- (_, _) = (_, _) ] => f_equal
    | [H: context[ratCD _ _] |- _ ] => unfold ratCD in *
    | [H : context[match rat0 with | RatIntro _ _ => _ end ] |- _ ] => unfold rat0 in H
    | [H1 : context[match ?r with | RatIntro _ _ => _ end], H2 : ?r = RatIntro _ _ |- _ ] => rewrite H2 in H1
    | [H : context[match ?r with | RatIntro _ _ => _ end ] |- _ ] => case_eq r; intuition
    | [|- context[let (_, _) := ?x in _] ] => case_eq x; intuition
    | [H : context[ratAdd _ _] |- _ ] => unfold ratAdd in H    
    | [H : context[ratMult _ _] |- _ ] => unfold ratMult in H   
    | [H: context [eq_nat_dec ?x ?y] |- _] => destruct (eq_nat_dec x y)
    | [H: context [le_gt_dec ?x ?y] |- _] => destruct (le_gt_dec x y)
    | [|- (if (eq_nat_dec ?x ?y) then true else false) = true ] => assert (x = y); destruct (eq_nat_dec x y); trivial
     | [|- (if (le_gt_dec ?x ?y) then true else false) = true ] => assert (x <= y); [idtac | destruct (le_gt_dec x y); trivial]
    | [|- context[posnatMult _ _ ] ] => unfold posnatMult
    | [|- (eqRat _ _) ] => unfold eqRat, beqRat
    | [|- (leRat _ _) ] => unfold leRat, bleRat
    | [|- (posnatEq _ _ ) ] => econstructor
    | [|- context[(posnatToNat _)] ] => unfold posnatToNat in *
    | [H : context[let (_, _) := ?p in _] |- _] => destruct p
    end.
Ltac rattac :=
  intuition; unfold ratCD in *; 
    repeat (rattac_one; subst); repeat rewrite mult_1_r; repeat rewrite plus_0_r; trivial; try congruence; try omega.

Lemma ratCD_comm : forall r1 r2 n1 n2 d n1' n2' d',
  ratCD r1 r2 = (n1, n2, d) ->
  ratCD r2 r1 = (n1', n2', d') ->
  n1 = n2' /\ n1' = n2 /\ (posnatEq d d').

Infix "*" := ratMult : rat_scope.
Local Open Scope rat_scope.

Notation "n / d" := (RatIntro n (pos d)) : rat_scope.

Notation "0" := rat0 : rat_scope.
Notation "1" := rat1 : rat_scope.

Infix "+" := ratAdd : rat_scope.

Delimit Scope rat_scope with rat.

Notation " |  a - b |" := (ratDistance a%rat b%rat) (at level 30, a at next level, b at next level) : rat_scope.

Infix "<=" := leRat : rat_scope.
Infix "==" := eqRat (at level 70) : rat_scope.

Theorem le_Rat_dec : forall r1 r2,
  {r1 <= r2} + {~r1 <= r2}.

Theorem eq_Rat_dec : forall r1 r2,
  {r1 == r2} + {~r1 == r2}.

Theorem eqRat_refl : forall r,
  eqRat r r.

Theorem eqRat_symm : forall r1 r2,
  eqRat r1 r2 ->
  eqRat r2 r1.

Theorem eqRat_trans : forall r1 r2 r3,
  eqRat r1 r2 ->
  eqRat r2 r3 ->
  eqRat r1 r3.

Theorem leRat_refl : forall r,
  leRat r r.

Lemma mult_le_compat_r_iff_h : forall n2 n3 n1,
    n1 > O ->
    (n2 * n1 <= n3 * n1)%nat ->
    (n2 <= n3)%nat.

Lemma mult_le_compat_r_iff : forall n1 n2 n3,
    n1 > O ->
    (n2 * n1 <= n3 * n1)%nat ->
    (n2 <= n3)%nat.

Theorem leRat_trans : forall r1 r2 r3,
  leRat r1 r2 ->
  leRat r2 r3 ->
  leRat r1 r3.

Theorem eqRat_impl_leRat : forall r1 r2,
  eqRat r1 r2 ->
  leRat r1 r2.

Theorem leRat_impl_eqRat : forall r1 r2,
  leRat r1 r2 ->
  leRat r2 r1 ->
  eqRat r1 r2.

Require Import Setoid.

Add Parametric Relation : Rat leRat
  reflexivity proved by leRat_refl
  transitivity proved by leRat_trans
    as leRat_rel.

Add Parametric Relation : Rat eqRat 
  reflexivity proved by eqRat_refl
  symmetry proved by eqRat_symm
  transitivity proved by eqRat_trans
  as eqRat_rel.

Require Import RelationClasses.
Require Import Coq.Classes.Morphisms.

Global Instance Subrelation_eq_le : subrelation eqRat leRat.

Global Instance eqRat_resp_leRat : 
  forall x,
    Proper (eqRat ==> Basics.flip Basics.impl)

Local Open Scope rat_scope.
Theorem rat0_le_all : forall r,
  0 <= r.

Theorem rat1_ne_rat0 : ~ (eqRat 1 0).

Theorem rat0_ne_rat1 : ~ (eqRat 0 1).

Theorem ratAdd_comm : forall r1 r2,
  r1 + r2 == r2 + r1.

Theorem ratAdd_0_r : forall r,
  r == r + 0.

Theorem ratAdd_0_l : forall r,
  r == 0 + r.

Theorem ratMult_comm : forall (r1 r2 : Rat),
  eqRat (ratMult r1 r2) (ratMult r2 r1).

Theorem ratAdd_assoc : forall r1 r2 r3,
  r1 + r2 + r3 == r1 + (r2 + r3).

Local Open Scope rat_scope.
Theorem ratMult_assoc : forall r1 r2 r3,
  r1 * r2 * r3 == r1 * (r2 * r3).

Lemma ratAdd_eqRat_compat_l : forall r1 r2 r3,
  eqRat r1 r2 ->
  r1 + r3 == r2 + r3.

Theorem ratAdd_eqRat_compat : forall r1 r2 r3 r4,
  eqRat r1 r2 ->
  eqRat r3 r4 ->
  r1 + r3 == r2 + r4.

Lemma ratAdd_leRat_compat_l : forall r1 r2 r3,
  leRat r1 r2 ->
  r1 + r3 <= r2 + r3.

Theorem ratAdd_leRat_compat : forall r1 r2 r3 r4,
  leRat r1 r2 ->
  leRat r3 r4 ->
  r1 + r3 <= r2 + r4.

Theorem ratMult_leRat_compat : forall (r1 r2 r3 r4 : Rat),
  leRat r1 r2 ->
  leRat r3 r4 ->
  leRat (ratMult r1 r3) (ratMult r2 r4).

Theorem ratMult_eqRat_compat : forall (r1 r2 r3 r4 : Rat),
  eqRat r1 r2 ->
  eqRat r3 r4 ->
  eqRat (ratMult r1 r3) (ratMult r2 r4).

Theorem ratAdd_0 : forall r1 r2,
  r1 + r2 == 0 <->
  r1 == 0 /\ r2 == 0.

Theorem ratAdd_nz : forall r1 r2,
  ~(r1 + r2 == 0) <->
  (~r1 == 0) \/ (~r2 == 0).

Theorem rat_num_0 : forall d,
  (RatIntro O d) == 0.

Lemma ratMult_0_l : forall r,
  0 * r == 0.

Lemma ratMult_0_r : forall r,
  r * 0 == 0.

Lemma ratMult_1_l : forall r,
  1 * r == r.

Theorem ratMult_0 : forall r1 r2,
  r1 * r2 == 0 <-> 
  r1 == 0 \/ r2 == 0.

Theorem ratMult_nz : forall r1 r2,
  (~r1 * r2 == 0) <->
  (~r1 == 0) /\ (~r2 == 0).

Theorem leRat_num : forall n1 n2 d,
  le n1 n2 ->
  leRat (RatIntro n1 d) (RatIntro n2 d).

Theorem eqRat_terms : forall n1 d1 n2 d2,
  n1 = n2 ->
  posnatToNat d1 = posnatToNat d2 ->
  eqRat (RatIntro n1 d1) (RatIntro n2 d2).

Lemma leRat_mult : forall n1 n2 d1 d2 (pf1 : d1 > 0) (pf2 : d2 > 0),
                     RatIntro n1 (exist (fun d => d > 0) _ pf1) <= RatIntro n2 (exist (fun d => d > 0) _ pf2) ->
                     (n1 * d2 <= n2 * d1)%nat.

Lemma nat_minus_eq : forall (n1 n2 : nat),
                       (n1 <= n2)%nat ->
                       n2 - n1 = O ->
                       n1 = n2.

Lemma bleRat_total : forall r1 r2,
                       bleRat r1 r2 = false -> bleRat r2 r1 = true.

Theorem ratIdentityIndiscernables : forall r1 r2,
  r1 == r2 <->
  ratDistance r1 r2 == rat0.

Lemma ratSubtract_partition : forall r1 r2 r3,
  r1 <= r2 ->
  r2 <= r3 ->
  (ratSubtract r3 r1) == (ratSubtract r2 r1) + (ratSubtract r3 r2).

Lemma ratAdd_any_leRat_l : forall r1 r2 r3,
  r1 <= r3 ->
  r1 <= r3 + r2.

Lemma ratAdd_any_leRat_r : forall r1 r2 r3,
  r1 <= r2 ->
  r1 <= r3 + r2.

Lemma ratAdd_eq_impl_leRat_l : forall r1 r2 r3,
  r1 == r2 + r3 ->
  r2 <= r1.

Lemma ratAdd_eq_impl_leRat_r : forall r1 r2 r3,
  r1 == r2 + r3 ->
  r3 <= r1.

Lemma ratSubtract_leRat_r : forall r1 r2 r3,
  r1 <= r2 ->
  ratSubtract r3 r2 <= ratSubtract r3 r1.

Lemma ratSubtract_leRat_l:
  forall r1 r2 r3 : Rat, r1 <= r2 -> ratSubtract r1 r3 <= ratSubtract r2 r3.

Lemma ratSubtract_leRat : forall r1 r2 r3 r4,
  r1 <= r2 ->
  r3 <= r4 ->
  ratSubtract r1 r4 <= ratSubtract r2 r3.

Lemma ratSubtract_0 : forall r1 r2,
  r1 <= r2 ->
  ratSubtract r1 r2 == 0.

Lemma ratSubtract_partition_leRat : forall r3 r1 r2 d1 d2,
  ratSubtract r1 r3 <= d1 ->
  ratSubtract r3 r2 <= d2 -> 
  ratSubtract r1 r2 <= d1 + d2.

Theorem ratTriangleInequality : forall r1 r2 r3,
  (ratDistance r1 r2) <= (ratDistance r1 r3) + (ratDistance r3 r2).

Theorem ratMult_1_r : forall r,
  r * 1 == r.

Lemma minus_le : forall n1 n2 n3,
    (n1 <= n3 ->
     n1 - n2 <= n3)%nat.

Theorem ratSubtract_le : forall r1 r2 d,
  r1 <= d ->
  ratSubtract r1 r2 <= d.

Theorem ratDistance_le_trans : forall r1 r2 r3 d1 d2,
  ratDistance r1 r2 <= d1 ->
  ratDistance r2 r3 <= d2 ->
  ratDistance r1 r3 <= d1 + d2.

Theorem ratDistance_le : forall r1 r2 d,
  r1 <= d ->
  r2 <= d ->
  (ratDistance r1 r2) <= d.

Lemma ratSubtract_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  ratSubtract r1 r2 == ratSubtract r3 r4.

Theorem leRat_antisymm : forall r1 r2,
  r1 <= r2 ->
  r2 <= r1 ->
  r1 == r2.

Lemma maxRat_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  maxRat r1 r2 == maxRat r3 r4.

Lemma minRat_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  minRat r1 r2 == minRat r3 r4.

Theorem ratDistance_eqRat_compat : forall r1 r2 r3 r4,
  r1 == r3 ->
  r2 == r4 ->
  ratDistance r1 r2 == ratDistance r3 r4.

Lemma ratSubtract_add_same_r : forall r1 r2 r3,
  r1 <= r3 ->
  ratSubtract (r3 + r2) (r1 + r2) == ratSubtract r3 r1.

Lemma ratSubtract_add_same_l : forall r1 r2 r3,
  r1 <= r3 ->
  ratSubtract (r2 + r3) (r2 + r1) == ratSubtract r3 r1.

Lemma minus_plus_assoc : forall n1 n2 n3,
  (n3 <= n2 ->
    (n1 + n2) - n3 = n1 + (n2 - n3))%nat.

Lemma ratSubtract_ratAdd_assoc: forall r1 r2 r3,
  r3 <= r2 ->
  ratSubtract (r1 + r2) r3 == r1 + (ratSubtract r2 r3).

Lemma ratAdd_add_same_r : forall r1 r2 r3,
  r1 + r2 == r3 + r2 ->
  r1 == r3.

Lemma ratAdd_add_same_l : forall r1 r2 r3,
  r2 + r1 == r2 + r3 ->
  r1 == r3.

Lemma ratDistance_add_same_r : forall r1 r2 r3,
  (ratDistance (r1 + r2) (r3 + r2)) == (ratDistance r1 r3).

Lemma ratDistance_add_same_l : forall r1 r2 r3,
  (ratDistance (r2 + r3) (r2 + r1)) == (ratDistance r3 r1).

Theorem rat_distance_of_sum : forall r1 r2 r3 r4,
  ratDistance (r1 + r2) (r3 + r4) <= (ratDistance r1 r3) + (ratDistance r2 r4).

Theorem ratMult_distrib : forall r1 r2 r3,
  r1 * (r2 + r3) == r1 * r2 + r1 * r3.

Theorem num_dem_same_rat1 : forall n d,
  n = posnatToNat d ->
  RatIntro n  d == rat1.

Lemma ratAdd_num : forall n1 n2 d,
  RatIntro (n1 + n2) d == (ratAdd (RatIntro n1 d) (RatIntro n2 d)).

Lemma ratMult_denom : forall n d1 d2,
  (RatIntro n (posnatMult d1 d2)) == (ratMult (RatIntro 1 d1) (RatIntro n d2)).

Lemma ratMult_num_den : forall n1 n2 d1 d2,
  (RatIntro (n1 * n2)%nat (posnatMult d1 d2)) == (RatIntro n1 d1) * (RatIntro n2 d2).

Theorem ratAdd_den_same : forall n1 n2 d,
  RatIntro (n1 + n2)%nat d == (RatIntro n1 d) + (RatIntro n2 d).

Lemma rat_mult_den : forall n d1 d2,
  (RatIntro n (posnatMult d1 d2)) == (RatIntro 1 d1) * (RatIntro n d2).

Lemma ratOneHalf_add: 
  1 / 2 + 1 / 2 == 1.

Theorem ratS_num : forall n,
  (S n) / (S O) == 1 + (n / (S O)).

Theorem ratDistance_comm : forall r1 r2,
  eqRat (ratDistance r1 r2) (ratDistance r2 r1).

Theorem ratMult_distrib_r : forall r1 r2 r3,
  ratMult (ratAdd r2 r3) r1  == ratAdd (ratMult r2 r1) (ratMult r3 r1).

Lemma ratSubtract_ratAdd_inverse : forall r1 r2,
  ratSubtract (r1 + r2) r1 == r2.

Lemma ratSubtract_ratAdd_inverse_2 : forall r1 r2,
  r2 <= r1 ->
  r2 + ratSubtract r1 r2 == r1.

Lemma leRat_difference_exists : forall r1 r2,
  r2 <= r1 ->
  exists r3, r1 == r2 + r3.

Lemma ratSubtract_ratMult_le : forall r1 r2 r3 r4,
  r1 <= r2 ->
  r3 <= r4 ->
  ratSubtract (r2 * r4) (r1 * r3) == (ratSubtract r2 r1) * r3 + (ratSubtract r4 r3) * r1 + (ratSubtract r2 r1) * (ratSubtract r4 r3).

Lemma ratSubtract_eq_r : forall r1 r2 r3,
  r2 <= r1 ->
  r3 <= r1 ->
  (ratSubtract r1 r2) == (ratSubtract r1 r3) ->
  r2 == r3.

Lemma ratDistance_le_max : forall r1 r2 r3 v,
  r1 <= r2 ->
  r2 <= r3 ->
  (ratDistance r2 v) <= (maxRat (ratDistance r1 v) (ratDistance r3 v)).

Lemma maxRat_leRat_same : forall r1 r2 r3,
  r1 <= r3 ->
  r2 <= r3 ->
  maxRat r1 r2 <= r3.

Lemma ratMult_3_ratAdd : forall r,
  (3 / 1) * r == r + r + r.

Lemma ratMult_small_le : forall r1 r2,
  r2 <= 1 ->
  r1 * r2 <= r1.

Lemma ratDistance_ratMult_le : forall r1 r2 r3 r4 d,
  (ratDistance r1 r3) <= d ->
  (ratDistance r2 r4) <= d ->
  r1 <= 1 ->
  r2 <= 1 ->
  r3 <= 1 ->
  r4 <= 1 ->
  (ratDistance (r1 * r2) (r3 * r4)) <= (3 / 1) * d.

Lemma ratAdd_any_le : forall r1 r2 r3,
  r1 + r2 <= r3 ->
  r1 <= r3.

Lemma posnatMult_1_r : forall p,
  posnatToNat (posnatMult p (pos 1)) = posnatToNat p.

Lemma rat_num_nz : forall n d,
  n > 0 ->
  RatIntro n d == 0 ->
  False.

Lemma ratMult_inverse : forall r1 r2 (p1 p2 : posnat),
  r1 == r2 * (RatIntro p1 p2) ->
  r1 * (RatIntro p2 p1) == r2.

Lemma ratMult_inverse_nat : forall r1 r2 n d (nzn : nz n), 
  r1 == r2 * (RatIntro n d) ->
  r1 * (RatIntro d (natToPosnat nzn)) == r2.

Lemma ratMult_same_r_inv : forall r1 r2 r3,
  r1 * r2 == r3 * r2 ->
  ~ r2 == 0 ->
  r1 == r3.

Lemma rat_le_1 : forall n (d : posnat),
  (n <= d)%nat -> (RatIntro n d) <= 1.

Lemma rat_remove_common_factor : forall (n num : nat)(nzn : nz n) den,
  RatIntro (n * num) (posnatMult (natToPosnat nzn) den) == RatIntro num den.

Lemma ratMult_2 : forall r,
  r + r == r * (2/1).

Definition ratInverse (r : Rat) :=
  match r with
    | RatIntro n d =>
      match n with
        | O => RatIntro d (pos (S O))
        | S n' => RatIntro d (pos (S n'))
      end
  end.

Lemma ratInverse_prod_1 : forall r,
  ~ r == 0 ->
  (ratInverse r) * r == 1.

Fixpoint expRat r n :=
  match n with
    | O => rat1 
    | S n' => r * (expRat r n')
  end.

Lemma ratInverse_nz : forall (r : Rat),
  ratInverse r == 0 ->
  False.

Lemma ratInverse_1_swap : forall r,
  ~ r == 0 ->
  r <= 1 ->
  1 <= ratInverse r.

Lemma ratInverse_1 : 
  ratInverse 1 == 1.

Lemma ratInverse_leRat : forall r1 r2,
  ~ r2 == 0 ->
  r2 <= r1 ->
  ratInverse r1 <= ratInverse r2.

Lemma ratAdd_not_leRat : forall r1 r2,
  r1 + r2 <= r1 ->
  (~r2 == 0) ->
  False.

Definition ratSubtract_rel (r1 r2 : Rat -> Prop) d :=
  forall r1' r2', r1 r1' -> r2 r2' -> d == ratSubtract r1' r2'.
  
Definition ratAdd_rel(r1 r2 : Rat -> Prop) r :=
  forall r1' r2', r1 r1' -> r2 r2' -> r == r1' + r2'.

Definition ratMult_rel (r1 r2 : Rat -> Prop)(r : Rat) :=
  forall r1' r2', r1 r1' -> r2 r2' -> r == r1' * r2'.

Definition expRat_rel (r1 : Rat -> Prop) n r :=
  forall r1', r1 r1' -> r == expRat r1' n.

Definition ratInverse_rel (r : Rat -> Prop) v :=
  forall r',
    r r' -> v == ratInverse r'.

Lemma eqRat_flip : forall (p1 p2 p3 p4 : posnat),
  RatIntro p1 p2 == RatIntro p3 p4 ->
  RatIntro p2 p1 == RatIntro p4 p3.

Lemma ratInverse_eqRat_compat : forall r1 r2,
  ~ r1 == 0 ->
  r1 == r2 ->
  ratInverse r1 == ratInverse r2.

Lemma ratSubtract_ratAdd_distr : forall r1 r2 r3,
  ratSubtract r1 (r2 + r3) == ratSubtract (ratSubtract r1 r2) r3.

Lemma ratSubtract_ratAdd_assoc_1 : forall r1 r2 r3,
  r3 <= r2 ->
  ratSubtract (r1 + r2) r3 == r1 + (ratSubtract r2 r3).

Lemma eqRat_ratMult_same_r : forall r1 r2 r3,
  ~r1 == 0 ->
  r2 * r1 == r3 * r1 ->
  r2 == r3.

Lemma expRat_le_1 : forall n x,
  x <= 1 ->
  expRat x n <= 1.

Lemma expRat_le : forall n1 n2 x,
  x <= 1 ->
  n2 >= n1 ->
  expRat x n2 <= expRat x n1.

Lemma expRat_leRat_compat : forall n r1 r2,
  r1 <= r2 ->
  expRat r1 n <= expRat r2 n.

Lemma expRat_le' : forall n1 n2 r v,
  expRat r n1 <= v ->
  ~ (1 <= r) ->
  n2 >= n1 ->
  expRat r n2 <= v.

Lemma ratSubtract_sum_1 : forall r1 r2,
  ~ r1 <= r2 ->
  r2 + (ratSubtract r1 r2) == r1.

Lemma rat_ge_1 : forall n (d : posnat),
  n >= d ->
  1 <= RatIntro n d.

Lemma leRat_ratAdd_same_r : forall r1 r2 r3,
  r2 + r1 <= r3 + r1 ->
  r2 <= r3.

Lemma leRat_ratMult_same_r : forall r1 r2 r3,
  (~r1 == 0) ->
  r2 * r1 <= r3 * r1 ->
  r2 <= r3.

Lemma ratMult_eq_rat1 : forall n1 n2 (nz1 : nz n1)(nz2 : nz n2),
  (n1 / n2) * (n2 / n1) == 1.

Lemma half_distance_1_le : forall r,
  ~ 1 <= r ->
  ~ 1 <= r + (1 / 2) * (ratSubtract 1 r).

Lemma leRat_terms : forall n1 n2 (d1 d2 : posnat),
  (n1 <= n2)%nat ->
  (d2 <= d1)%nat ->
  RatIntro n1 d1 <= RatIntro n2 d2.

Lemma posnatMult_eq : forall p1 p2,
  posnatToNat (posnatMult p1 p2) = (p1 * p2)%nat.

Theorem mult_gt_zero_if : 
  forall (a b : nat),
    a * b > 0 -> (a > 0  /\ b > 0).

Lemma expRat_terms : forall k n (d : posnat)(p : nz (expnat d k)),
  expRat (RatIntro n d) k == (expnat n k) / (expnat d k).
  
Lemma expRat_le_half_exists : forall r,
  ~ 1 <= r ->
  exists n, expRat r n <= (1/2).

Lemma expRat_half_le_exp_exists : forall d,
  ~ d == 0 ->
  exists n,
    expRat (1/2) n <= d.

Lemma expRat_1 : forall n,
  expRat 1 n == 1.

Lemma expRat_exp_sum  : forall n1 n2 r,
  expRat r (n1 + n2)%nat == (expRat r n1) * (expRat r n2).

Lemma expRat_base_prod : forall n r1 r2,
  expRat (r1 * r2) n == (expRat r1 n) * (expRat r2 n).

Lemma expRat_exp_prod : forall n1 n2 r,
  expRat r (n1 * n2)%nat == expRat (expRat r n1) n2.

Lemma expRat_le_exp_exists : forall r d, 
  ~ 1 <= r ->
  ~ d == 0 ->
  exists n,
    expRat r n <= d.

Lemma eqRat_ratAdd_same_r : forall r1 r2 r3,
  r2 + r1 == r3 + r1 ->
  r2 == r3.

Lemma ratAdd_arg_0 : forall a b,
  a + b == a ->
  b == 0.

Definition ratHalf(r : Rat) :=
  r * (1 / 2).

Theorem ratHalf_ne_0 : forall r,
  ~ r == 0 ->
  ~ (ratHalf r) == 0.

Theorem ratHalf_add : forall r,
  ratHalf r + ratHalf r == r.

Theorem le_ratHalf_0 : forall r,
  r <= (ratHalf r) -> r == 0.

Lemma ratSubtract_0_r : forall r,
  ratSubtract r 0 == r.

Lemma ratDistance_0_r_le : forall r d,
  r <= d ->
  ratDistance r 0 <= d.

Lemma ratSubtract_0_inv : forall r1 r2,
  ratSubtract r1 r2 == 0 ->
  r1 <= r2.

Lemma ratSubtract_le_sum : forall r1 r2 d,
  r2 <= r1 ->
  ratSubtract r1 r2 <= d ->
  r1 <= r2 + d.

Lemma ratDistance_le_sum : forall r1 r2 d,
  ratDistance r1 r2 <= d ->
  r1 <= r2 + d.

Lemma ratSubtract_ratDistance_le : forall r1 r2,
  ratSubtract r1 r2 <= ratDistance r1 r2.

Lemma minRat_le_r : forall r1 r2,
  minRat r1 r2 <= r2.

Lemma minRat_le_l : forall r1 r2,
  minRat r1 r2 <= r1.

Lemma ratDistance_ge_difference: forall r1 r2 d,
  ratDistance r1 r2 <= d ->
  ratSubtract r1 d <= r2.

Lemma ratSubtract_ratAdd_assoc_le : forall r1 r2 r3,
  ratSubtract (r1 + r2) r3 <= r1 + (ratSubtract r2 r3).

Lemma ratSubtract_assoc_le : forall r1 r2 r3,
  ratSubtract r1 (ratSubtract r2 r3) <= (ratSubtract r1 r2) + r3.

Lemma ratDistance_leRat_both : forall r1 r2 d,
  ratSubtract r1 r2 <= d ->
  ratSubtract r2 r1 <= d ->
  ratDistance r1 r2 <= d.

Lemma rat_distance_of_difference : forall r1 r2 r3 r4 d1 d2,
  r2 <= r1 ->
  r4 <= r3 ->
  ratDistance r1 r3 <= d1 ->
  ratDistance r2 r4 <= d2 ->
  ratDistance (ratSubtract r1 r2) (ratSubtract r3 r4) <= (d1 + d2).

Lemma ratMult_ratSubtract_distrib_r : forall f r1 r2,
  (ratSubtract r1 r2) * f  == ratSubtract (r1 * f) (r2 * f).

Lemma ratMult_ratDistance_factor_r : forall r1 r2 r3,
  ratDistance (r1 * r3) (r2 * r3) == (ratDistance r1 r2) * r3.

Lemma ratMult_ratDistance_factor_l : forall r1 r2 r3,
  ratDistance (r3 * r1) (r3 * r2) == r3 * (ratDistance r1 r2).

Lemma ratAdd_rel_left_total : forall (r1 r2: Rat -> Prop),
  (exists r1', r1 r1') ->
  (exists r2', r2 r2') ->
  (forall x1 x2, r1 x1 -> r1 x2 -> x1 == x2) ->
  (forall x1 x2, r2 x1 -> r2 x2 -> x1 == x2) ->
  exists r3, ratAdd_rel r1 r2 r3.

Lemma expRat_eqRat_compat : forall n r1 r2,
  r1 == r2 ->
  expRat r1 n == expRat r2 n.

Lemma expRat_rel_left_total : forall (r1 : Rat -> Prop) n,
  (exists r1', r1 r1') ->
  (forall x1 x2, r1 x1 -> r1 x2 -> x1 == x2) ->
  exists r3, expRat_rel r1 n r3.

Lemma expRat_rel_func : forall (r : Rat -> Prop) v1 v2 n,
  expRat_rel r n v1 ->
  expRat_rel r n v2 ->
  (forall x1 x2, r x1 -> r x2 -> x1 == x2) ->
  (exists r', r r') ->
  v1 == v2.

Lemma ratInverse_involutive : forall r,
  ~ r == 0 ->
  ratInverse (ratInverse r) == r.

Lemma ratInverse_ratMult : forall r1 r2,
  ~ r1 == 0 ->
  ~ r2 == 0 ->
  ratInverse (r1 * r2) == ratInverse r1 * ratInverse r2.

Lemma ratDistance_ratInverse : forall r1 r2,
  ~ r1 == 0 ->
  ~ r2 == 0 -> 
  ratDistance (ratInverse r1) (ratInverse r2) == (ratDistance r1 r2) * ratInverse (r1 * r2).

Lemma ratSubtract_half : forall x,
  ratSubtract x (x * (1/2)) == x * (1/2).

Lemma ratMult_ratAdd_cd : forall r n (d : posnat),
  r + r * (RatIntro n d) == r * (RatIntro (d + n)%nat d).

Definition numerator r :=
  match r with
    | RatIntro n d => n
  end.

Lemma ratDistance_add_same_l_gen : forall r1 r2 r3 r4,
  r1 == r3 ->
  ratDistance (r1 + r2) (r3 + r4) == ratDistance r2 r4.

Lemma ratDistance_add_same_r_gen : forall r1 r2 r3 r4,
  r2 == r4 ->
  ratDistance (r1 + r2) (r3 + r4) == ratDistance r1 r3.

Lemma ratDistance_from_0 : forall r,
  ratDistance 0 r == r.

Lemma maxRat_comm : forall r1 r2,
  maxRat r1 r2 == maxRat r2 r1.

Lemma ratDistance_le_max_triv : forall r1 r2,
  ratDistance r1 r2 <= maxRat r1 r2.

Lemma ratAdd_2_ratMax : 
  forall r1 r2,
    (r1 + r2 <= 2 / 1 * (maxRat r1 r2))%rat.

Theorem rat_num_not_le : 
  forall (d1 d2 : posnat),
    (RatIntro 1 d1 <= RatIntro 1 d2)%rat ->
    d1 < d2 ->
    False.

Lemma leRat_0_eq : 
  forall r, 
    (r <= 0 ->
      r == 0)%rat.

Lemma rat_le_1_if : 
  forall n d,
    RatIntro n d <= 1 ->
    (n <= d)%nat.

Theorem ratFraction_le_1 : 
  forall r1 r2,
    r1 <= r2 ->
    r1 * (ratInverse r2) <= 1.

Theorem ratFraction_ge_1_inv : 
  forall r1 r2,
    1 <= r1 * (ratInverse r2) ->
    r2 <= r1.

Theorem eqRat_refl_eq : 
  forall x y,
    x = y ->
    x == y.

Theorem rat_num_S : 
  forall n d,
    (RatIntro (S n) d == (RatIntro 1 d) + RatIntro n d)%rat.

Theorem distance_le_prod_f :
  forall (f : nat -> Rat) k,
    (forall i, | (f i) - (f (S i)) | <= k) ->
    forall q0,
| (f 0%nat) - (f q0) | <= q0/1 * k. *)

Require Import Arith.

Require Import FCF.StdNat.
(* FCF.StdNat:
Set Implicit Arguments.

Require Export Arith.
Require Export Omega.
Require Export Arith.Div2.
Require Export Coq.Numbers.Natural.Peano.NPeano. 
Require Import Coq.NArith.BinNat.

Lemma mult_same_r : forall n1 n2 n3,
  n3 > 0 ->
  n1 * n3 = n2 * n3 ->
  n1 = n2.

Lemma mult_same_l : forall n3 n1 n2,
  n3 > 0 ->
  n3 * n1 = n3 * n2 ->
  n1 = n2.

Lemma mult_gt_0 : forall n1 n2,
  n1 > 0 ->
  n2 > 0 ->
  n1 * n2 > 0.

Lemma minus_eq_compat : forall n1 n2 n3 n4,
  n1 = n2 ->
  n3 = n4 ->
  n1 - n3 = n2 - n4.

Lemma plus_eq_compat : forall n1 n2 n3 n4,
  n1 = n2 ->
  n3 = n4 ->
  n1 + n3 = n2 + n4.

Lemma minus_diag_eq : forall n1 n2,
  n1 = n2 ->
  n1 - n2 = 0.

Lemma le_eq : forall n1 n2,
  n1 = n2 ->
  n1 <= n2.

Lemma minus_add_assoc : forall n1 n2 n3,
  (n3 <= n2)%nat ->
  (n1 + (n2 - n3) = n1 + n2 - n3)%nat.

Definition posnat := {n : nat | n > 0}.

Definition posnatToNat(p : posnat) :=
  match p with
    | exist _ n _ => n
  end.

Inductive posnatEq : posnat -> posnat -> Prop :=
  | posnatEq_intro : 
    forall (n1 n2 : nat) pf1 pf2,
      n1 = n2 ->
      posnatEq (exist _ n1 pf1) (exist _ n2 pf2).

Definition posnatMult(p1 p2 : posnat) : posnat :=
    match (p1, p2) with
      | (exist _ n1 pf1, exist _ n2 pf2) =>
        (exist (fun n => n > 0) (n1 * n2) (mult_gt_0 pf1 pf2))
    end.

Lemma posnatMult_comm : forall p1 p2,
  (posnatEq (posnatMult p1 p2) (posnatMult p2 p1)).

Coercion posnatToNat : posnat >-> nat.

Lemma posnat_pos : forall (p : posnat),
  p > 0.

Definition natToPosnat(n : nat)(pf : nz n) :=
  (exist (fun x => x > 0) n agz).

Notation "'pos' x" := (@natToPosnat x _) (at level 40).

Fixpoint expnat n1 n2 :=
  match n2 with
    | 0 => 1
    | S n2' =>
      n1 * (expnat n1 n2')
  end.

Theorem expnat_pos : forall x n,
  x > 0 ->
  expnat x n > 0.

Lemma div2_le : forall n,
  le (div2 n) n.

Lemma div2_ge_double : forall n, 
  n >= (div2 n) + (div2 n).

Local Open Scope N_scope.
Definition modNat (n : nat)(p : posnat) : nat :=
  N.to_nat ((N.of_nat n) mod (N.of_nat p)).

Lemma Npos_nz : forall p, 
  Npos p <> N0.

Lemma modNat_plus : forall n1 n2 p,
    (modNat (n1 + n2) p = modNat ((modNat n1 p) + n2) p)%nat.

Lemma modNat_arg_eq : forall (p : posnat),
  modNat p p = O.

Lemma of_nat_ge_0 : forall n,
  0 <= N.of_nat n.

Lemma of_posnat_gt_0 : forall (p : posnat),
  0 < N.of_nat p.

Lemma modNat_lt : forall x p, (modNat x p < p)%nat.

Lemma modNat_eq : forall (n : posnat) x, (x < n -> modNat x n = x)%nat.

Definition modNatAddInverse (n : nat)(p : posnat) :=
  (p - (modNat n p))%nat.

Lemma modNatAddInverse_correct_gen : forall x y p,
  modNat x p = modNat y p ->
  modNat (x + modNatAddInverse y p) p = O.

Lemma modNatAddInverse_correct : forall n p,
    modNat (n + modNatAddInverse n p) p = O.

Lemma modNat_correct : forall x (p : posnat),
  exists k, (x = k * p + modNat x p)%nat.

Lemma modNat_divides : forall x p,
  modNat x p = O ->
  exists k, (x = k * p)%nat.

Local Open Scope nat_scope.
Lemma modNatAddInverse_sum_0 : forall x y p,
  modNat (x + (modNatAddInverse y p)) p = O ->
  modNat x p = modNat y p.

Lemma modNat_correct_if : forall x y z (p : posnat),
  x * p + y = z ->
  modNat z p = modNat y p.

Lemma modNat_mult : forall x (p : posnat),
  modNat (x * p) p = 0.

Lemma modNat_add_same_l : forall x y z p,
  modNat (x + y) p = modNat (x + z) p ->
  modNat y p = modNat z p.

Lemma modNat_add_same_r : forall x y z p,
  modNat (y + x) p = modNat (z + x) p ->
  modNat y p = modNat z p.

Lemma expnat_base_S : forall n k,
  ((expnat k n) + n * (expnat k (pred n)) <= expnat (S k) n)%nat.

Lemma expnat_base_S_same : forall n,
  n > 0 ->
  (2 * (expnat n n) <= expnat (S n) n)%nat.

Lemma sqrt_le_lin_gen : forall a b,
  (a <= b ->
    Nat.sqrt a <= b)%nat.

Lemma div2_le_mono : forall n1 n2,
  (n1 <= n2 -> 
    div2 n1 <= div2 n2)%nat.

Lemma div2_ge : forall n n',
  n >= n' ->
  forall x,
    (n' = 2 * x)%nat ->
    div2 n >= x.
  
Lemma expnat_2_ge_1 : forall n,
  (1 <= expnat 2 n)%nat.

Lemma le_expnat_2 : forall n,
  (n <= expnat 2 n)%nat.

Lemma expnat_1 : forall k,
  expnat 1%nat k = 1%nat.

Theorem expnat_base_le : 
  forall k n1 n2,
    n1 <= n2 ->
    expnat n1 k <=
    expnat n2 k.

Theorem expnat_double_le : 
  forall k n,
    n >= 2 ->
    expnat n (S k) >= 2 * expnat n k.

Theorem nat_half_plus : 
  forall x, 
    x > 1 ->
    exists a b,
      a > 0 /\ b <= 1 /\ x = 2 * a + b.

Theorem log2_div2 : 
  forall x y,
    S y = Nat.log2 x ->

Lemma log2_0 : 
  Nat.log2 0 = 0.

Theorem expnat_0 : 
  forall k,
    k > 0 ->
    expnat 0 k = 0.

Theorem expnat_plus : 
  forall k1 k2 n,
    expnat n (k1 + k2) = expnat n k1 * expnat n k2.

Theorem expnat_ge_1 :
  forall k n,
    n > 0 ->
    1 <= expnat n k.

Theorem expnat_exp_le : 
  forall n2 n4 n,
    (n2 > 0 \/ n > 0) ->
    n2 <= n4 ->
    expnat n n2 <= expnat n n4.

Lemma mult_lt_compat : 
  forall a b c d,
    a < b ->
    c < d ->
    a * c < b * d.

Theorem orb_same_eq_if : 
  forall a b c,
    (a = false -> b = c) ->
    orb a b = orb a c. *)

Require Import FCF.Fold.
(* FCF.Fold:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import List.
Require Import Permutation.
Require Import Arith.
Require Import FCF.EqDec.
Require Import FCF.StdNat.
Require Import Bool.

Local Open Scope rat_scope.

Definition unzip(A B : Set)(ls : list (A * B)) :=
  (map (@fst _ _) ls, map (@snd _ _) ls).

Fixpoint zip(A B : Set)(lsa : list A)(lsb : list B) :=
  match lsa with
    | nil => nil
    | a :: lsa' =>
      match lsb with
        | nil => nil
        | b :: lsb' =>
          (a, b) :: (zip lsa' lsb')
      end
  end.

Ltac pairInv := 
  match goal with
    | [H : (_, _) = (_, _) |- _] => 
      inversion H; clear H; subst
  end.

Section RemoveDups.

  Variable A : Set.
  Variable eqd : EqDec A.

  Fixpoint removeDups(ls : list A) :=
    match ls with
      | nil => nil
      | a' :: ls' =>
        if (in_dec (EqDec_dec _) a' ls') then (removeDups ls') else (a' :: (removeDups ls'))
    end.

  Theorem removeDups_in : 
    forall (ls : list A) a,
      In a (removeDups ls) ->
      In a ls.
  
  Theorem removeDups_NoDup :
    forall (ls : list A),
      NoDup (removeDups ls).

  Lemma in_removeDups : 
    forall (ls : list A) a,
      In a ls -> 
      In a (removeDups ls).
     
End RemoveDups.

Section ListReplace.

  Variable A : Set.

  Fixpoint listReplace (ls : list A)(i : nat)(a def : A) :=
    match i with
      | O => 
        match ls with
        | nil => a :: nil
        | a' :: ls' => a :: ls'
        end
      | S i' => 
        match ls with
        | nil => def :: (listReplace nil i' a def)
        | a' :: ls' =>
          a' :: (listReplace ls' i' a def)
        end
    end.

End ListReplace.

Section SumList.

  Variable A : Set.

  Definition sumList(ls : list A)(f : A -> Rat) := fold_left (fun a b => a + (f b)) ls 0.

  Theorem sumList_ne_0 : forall (ls : list A)(f : A -> Rat),
    ~ (sumList ls f) == 0 ->
    exists b : _,
      In b ls /\
      ~ ((f b) == 0).
  Abort.

  Theorem sumList_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    (forall b, (f1 b) == (f2 b)) ->
    (sumList ls1 f1) == (sumList ls2 f2).
  Abort.

  Lemma fold_add_init : forall (ls : list A)(f : A -> Rat) init1 init2,
    fold_left (fun (r : Rat) (a : A) => r + (f a)) ls (init1 + init2) == 
    init1 + (fold_left (fun (r : Rat) (a : A) => r + (f a)) ls init2).

  Lemma fold_add_body_eq : forall (ls : list A)(f1 f2 : A -> Rat) init1 init2,
    init1 == init2 ->
    (forall a, In a ls -> f1 a == f2 a) ->
    fold_left (fun r a => r + (f1 a)) ls init1 == fold_left (fun r a => r + (f2 a)) ls init2.

  Lemma fold_add_rat_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    forall init1 init2, 
      init1 == init2 ->
      (forall (a : A), In a ls1 -> (f1 a) == (f2 a)) ->
      fold_left (fun r a => r + (f1 a)) ls1 init1 == fold_left (fun r a => r + (f2 a)) ls2 init2.

  Lemma fold_add_f_inverse : forall (B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A) fa init1 init2,
    (init1 == init2) ->
    (forall a, In a ls -> f_inv (f a) = a) ->
    fold_left (fun r b => r + fa (f_inv b)) (map f ls) init1 ==
    fold_left (fun r a => r + (fa a)) ls init2.

   Lemma sumList_0 : forall (ls : list A) f,
    (sumList ls f == 0) <-> (forall a, In a ls -> (f a) == 0).

  Lemma sumList_nz : forall (ls : list A) f,
    (~sumList ls f == 0) <-> exists a : _, In a ls /\ (~f a == 0).

End SumList.

Lemma fold_add_init_0 : forall (A : Set)(ls : list A) f init,
  fold_left (fun r a => r + (f a)) ls init == init + fold_left (fun r a => r + (f a)) ls 0.

Lemma fold_add_eq_init : forall (A : Set)(ls : list A) init,
  fold_left (fun r a => r + 0) ls init == init.

Lemma fold_add_eq_init_f : forall (A : Set)(ls : list A) f init,
  (forall a, In a ls -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls init == init.

Lemma fold_add_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat) init1 init2,
  fold_left (fun r a => r + (f1 a)) ls init1 + 
  fold_left (fun r a => r + (f2 a)) ls init2 ==
  fold_left (fun r a => r + (f1 a + f2 a)) ls (init1 + init2).

Lemma fold_add_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  fold_left (fun r1 a => r1 + (fold_left (fun r2 b => r2 + (f a b)) lsb 0)) lsa 0  == 
  fold_left (fun r1 b => r1 + (fold_left (fun r2 a => r2 + (f a b)) lsa 0)) lsb 0.

Lemma sumList_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) == 
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma sumList_body_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a == f2 a) ->
  sumList ls f1 == sumList ls f2.

Lemma fold_add_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) init c,
  fold_left (fun r a => r + (f a) * c) ls (init * c) == 
  (fold_left (fun r a => r + (f a)) ls init) * c.
    
Lemma sumList_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) c,
  sumList ls (fun a => (f a) * c) == (sumList ls f) * c.
    
Lemma sumList_factor_constant_l:
  forall (A : Set) (ls : list A) (f : A -> Rat) (c : Rat),
    sumList ls (fun a : A => c * f a) == c * sumList ls f.

Lemma fold_add_body_const : forall (A : Set)(ls : list A) c init,
  fold_left (fun r a => r + c) ls init == c * (length ls / 1) + init.

Lemma sumList_body_const : forall (A : Set)(ls : list A) c,
  sumList ls (fun a => c) == c * (length ls / 1).

Lemma fold_add_iter_le : forall (A : Set)(ls : list A) f r init,
  fold_left (fun r a => r + (f a)) ls init <= r ->
  init <= r /\ 
  (forall a, In a ls -> f a <= r).

Lemma sumList_iter_le : forall (A : Set)(ls : list A) f r a,
  sumList ls f <= r ->
  In a ls ->
  f a <= r.

Fixpoint removeFirst(A : Set)(eqd : eq_dec A)(ls : list A) a :=
  match ls with
    | nil => nil
    | a' :: ls' =>
      if (eqd a a') then ls' else a' :: (removeFirst eqd ls' a)
  end.

Lemma removeFirst_permutation : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  In a ls ->
  Permutation ls (a :: (removeFirst eqd ls a)).

Lemma removeFirst_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  ~In a1 ls ->
  ~In a1 (removeFirst eqd ls a2).

Lemma removeFirst_NoDup_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a : A),
  NoDup ls ->
  ~In a (removeFirst eqd ls a).

Lemma removeFirst_NoDup : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  NoDup ls ->
  NoDup (removeFirst eqd ls a).

Lemma removeFirst_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a1 a2 : A),
  In a1 ls ->
  a1 <> a2 ->
  In a1 (removeFirst eqd ls a2).

Lemma removeFirst_in_iff : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  In a1 (removeFirst eqd ls a2) ->
  In a1 ls.

Fixpoint matchOrder (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) :=
  match ls1 with
    | nil => ls2
    | a :: ls1' => 
      a :: (matchOrder eqd ls1' (removeFirst eqd ls2 a))
  end.

Lemma matchOrder_In : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 <-> In a (matchOrder eqd ls1 ls2)).

Lemma matchOrder_not_in_h : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  ~In a ls1 -> 
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_not_in : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  (forall a, In a ls1 -> In a ls2) ->
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_NoDup : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  (forall a, In a ls1 -> In a ls2) ->
  NoDup ls2 ->
  NoDup ls1 ->
  NoDup (matchOrder eqd ls1 ls2).

Require Import Permutation.

Lemma matchOrder_permutation : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  Permutation ls2 (matchOrder eqd ls1 ls2).

Lemma matchOrder_firstn : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  firstn (length ls1) (matchOrder eqd ls1 ls2) = ls1.

Lemma fold_add_matchOrder : forall (A : Set)(ls : list A)(f : A -> Rat) n init1 init2,
  init1 == init2 ->
  NoDup ls ->
  (forall a, In a ls -> (~In a (firstn n ls)) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) (firstn n ls) init1 == fold_left (fun r a => r + (f a)) ls init2.

Lemma permutation_NoDup : forall (A : Type)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  NoDup ls1 ->
  NoDup ls2.

Lemma fold_add_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  sumList ls1 f == sumList ls2 f.

Fixpoint flatten(A : Type)(ls : list (list A)) :=
  match ls with
    | nil => nil
    | a :: ls' => a ++ (flatten ls')
  end.

Theorem in_flatten : forall (A : Set)(ls : list (list A)) a,
  In a (flatten ls) <->
  exists x : _, In x ls /\ In a x.

Theorem length_flatten_nz : forall (A : Type)(ls : list (list A)) ls',
  In ls' ls ->
  length ls' > 0 ->
  length (flatten ls) > 0.

Fixpoint getUnique(A : Set)(ls : list A)(pf : eq_dec A) : list A :=
  match ls with
    | nil => nil
    | a :: ls' => 
      let ls'' := (getUnique ls' pf) in
        if (in_dec pf a ls'') 
          then ls''
          else a :: ls''
  end.

Theorem in_getUnique_if : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a (getUnique ls eqd) ->
  In a ls.

Theorem in_getUnique : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a ls ->
  In a (getUnique ls eqd).

Lemma getUnique_NoDup : forall (A : Set)(ls : list A)(eqd: eq_dec A),
  NoDup (getUnique ls eqd).

Theorem length_getUnique_nz : forall (A :Set)(eqd : eq_dec A)(ls : list A),
  length ls > 0 ->
  length (getUnique ls eqd) > 0.

Definition maxList(ls : list nat) : nat :=
  fold_left max ls O.

Lemma fold_left_max_ge_init : forall (ls : list nat)(n : nat),
  fold_left max ls n >= n.

Lemma maxList_correct_h : forall (ls : list nat)(n init : nat),
  In n ls ->
  fold_left max ls init >= n.

Theorem maxList_correct : forall (ls : list nat) n,
  In n ls ->
  maxList ls >= n.

Inductive pred_count(A : Type)(p : A -> Prop) : list A -> nat -> Prop :=
  | pc_nil : 
    pred_count p nil 0
  | pc_yes : 
    forall ls n a,
    pred_count p ls n ->
    p a ->
    pred_count p (a :: ls) (S n)
  | pc_no : forall ls n a,
    pred_count p ls n ->
    ~p a ->
    pred_count p (a :: ls) n.

Lemma pred_count_le_length : forall (A : Type)(P : A -> Prop) ls c,
  pred_count P ls c ->
  (c <= length ls)%nat.

Fixpoint listRepeat(A : Type)(a : A) n :=
  match n with
    | 0 => nil
    | S n' => a :: (listRepeat a n')
  end.

Lemma listRepeat_length : forall n (A : Type) (a : A),
  length (listRepeat a n) = n.

Lemma pred_count_listRepeat_eq_inv : forall n (A : Type)(a : A) count,
  pred_count (eq a) (listRepeat a n) count ->
  count = n.

Lemma pred_count_listRepeat_ne_inv : forall n (A : Type)(a1 a2 : A) count,
  a1 <> a2 ->
  pred_count (eq a1) (listRepeat a2 n) count ->
  count = O.

Lemma pred_count_func : forall (A : Type)(P : A -> Prop)(ls : list A) n1 n2,
  pred_count P ls n1 ->
  pred_count P ls n2 ->
  n1 = n2.

Lemma pred_count_eq_all_inv : forall (A : Type)(ls : list A)(P : A -> Prop) c,
  pred_count P ls c ->
  (forall a, In a ls -> P a) ->
  c = length ls.

Lemma pred_count_first_skip : forall (A : Type)(P : A -> Prop)(ls : list A)(c : nat),
  pred_count P ls c ->
  forall n,
    exists c1 c2,
      pred_count P (firstn n ls) c1 /\
      pred_count P (skipn n ls) c2 /\
      (c1 + c2 = c)%nat.

Lemma pred_count_eq_all : forall (A : Type)(P : A -> Prop)(ls : list A) n,
  (forall a, In a ls -> P a) ->
  n = length ls ->
  pred_count P ls n.

Lemma pred_count_eq_none : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, In a ls -> ~P a) ->
  pred_count P ls 0.

Lemma in_listRepeat_inv : forall n (A : Type)(a1 a2 : A),
  In a1 (listRepeat a2 n) ->
  a1 = a2.

Lemma pred_count_app : forall (A : Type)(P : A -> Prop)(ls1 ls2 : list A) n1 n2,
  pred_count P ls1 n1 ->
  pred_count P ls2 n2 ->
  pred_count P (ls1 ++ ls2) (n1 + n2).

Lemma pred_count_permutation : forall (A : Set)(P : A -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall c, 
    pred_count P ls1 c ->
    pred_count P ls2 c.

Lemma pred_count_eq_none_inv : forall (A : Set)(P : A -> Prop)(ls : list A) c,
  pred_count P ls c ->
  (forall a, In a ls -> ~P a) ->
  c = O.

Lemma pred_count_eq_1_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> Prop)(ls : list A) c a,
  pred_count P ls c ->
  NoDup ls ->
  P a ->
  In a ls ->
  (forall a', In a' ls -> a <> a' -> ~P a') ->
  c = (S O).

Lemma pred_count_left_total : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, P a \/ ~P a) ->
  exists c, pred_count P ls c.

Inductive rel_map(A B : Type)(r : A -> B -> Prop) : list A -> list B -> Prop :=
| rm_nil : 
  rel_map r nil nil
| rm_step : 
  forall lsa lsb a b,
    rel_map r lsa lsb ->
    r a b ->
    rel_map r (a :: lsa) (b :: lsb).

Theorem rel_map_map2 : forall (A B C D : Type)(ls_c : list C)(ls_d: list D)(P : A -> B -> Prop)(f1 : C -> A)(f2 : D -> B),
  rel_map (fun a b => P (f1 a) (f2 b)) ls_c ls_d ->
  rel_map P (map f1 ls_c) (map f2 ls_d).

Lemma rel_map_length : forall (A B : Type)(lsa : list A)(P : A -> B -> Prop)(lsb : list B),
  rel_map P lsa lsb ->
  length lsa = length lsb.

Lemma rel_map_unary_pred : forall (A B : Type)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(P' : B -> Prop),
  rel_map P lsa lsb ->
  (forall a b, P a b -> P' b) ->
  forall b, In b lsb -> P' b.

Lemma rel_map_eq_inv : forall (A B : Type)(ls1 ls2 : list A)(rel1 rel2 : A -> B -> Prop) ls1' ls2',
  ls1 = ls2 ->
  (forall a b1 b2, rel1 a b1 -> rel2 a b2 -> b1 = b2) ->
  rel_map rel1 ls1 ls1' ->
  rel_map rel2 ls2 ls2' ->
  ls1' = ls2'.

Lemma rel_map_eq : forall (A B : Type)(ls1 : list A)(rel1 : A -> B -> Prop) ls',
  rel_map rel1 ls1 ls' ->
  forall ls2 (rel2 : A -> B -> Prop), 
    ls1 = ls2 ->
    (forall a b, In a ls1 -> In b ls' -> rel1 a b -> rel2 a b) ->
    rel_map rel2 ls2 ls'.

Theorem pred_count_eq_0 : forall (A B : Set)(ls : list B)(ls' : list A)(f : B -> A -> Prop)(P : A -> Prop) v,
  (forall a b, In b ls -> f b a -> ~ P a) ->
  rel_map f ls ls' ->
  pred_count P ls' v ->
  v = O.

Lemma rel_map_app_inv : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb : list B),
  rel_map rel (lsa1 ++ lsa2) lsb ->
  (rel_map rel lsa1 (firstn (length lsa1) lsb) /\ rel_map rel lsa2 (skipn (length lsa1) lsb)).

Lemma rel_map_map_inv : forall (A B C : Type)(rel : B -> C -> Prop)(f : A -> B)(lsa : list A)(lsc : list C),
  rel_map rel (map f lsa) lsc ->
  rel_map (fun a c => rel (f a) c) lsa lsc.

Lemma rel_map_listRepeat : forall (A B : Set)(lsa : list A)(rel : A -> B -> Prop) b,
  (forall a, In a lsa -> rel a b) ->
  rel_map rel lsa (listRepeat b (length lsa)).

Lemma rel_map_app : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
  rel_map rel lsa1 lsb1 ->
  rel_map rel lsa2 lsb2 ->
  rel_map rel (lsa1 ++ lsa2) (lsb1 ++ lsb2).

Lemma rel_map_map : forall (A B C : Type)(f : A -> B)(rel : B -> C -> Prop) lsa lsc,
  rel_map (fun a c => rel (f a) c) lsa lsc ->
  rel_map rel (map f lsa) lsc.

Lemma rel_map_inverse : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb -> 
  forall b, 
    In b lsb ->
    exists a, In a lsa /\ rel a b.

Lemma ne_all_not_in : forall (A : Type)(ls : list A) a,
  (forall a', In a' ls -> a <> a') ->
  ~In a ls.

Lemma rel_map_NoDup : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  NoDup lsa ->
  (forall a1 a2 b1 b2, In a1 lsa -> In a2 lsa -> a1 <> a2 -> rel a1 b1 -> rel a2 b2 -> b1 <> b2) ->
  NoDup lsb.

Lemma rel_map_in : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
  forall b a,
    In a lsa ->
    rel a b ->
    In b lsb.

Lemma rel_map_left_total : forall (A B : Type)(rel : A -> B -> Prop)(lsa : list A),
  (forall a, exists b, rel a b) ->
  exists lsb, rel_map rel lsa lsb.

Lemma rel_map_func : forall (A B : Type) (rel : A -> B -> Prop) lsa lsb1,
  rel_map rel lsa lsb1 ->
  forall lsb2,
    rel_map rel lsa lsb2 ->
    (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
    lsb1 = lsb2.

Lemma rel_map_permutation : forall (A B : Type) lsa1 lsa2,
  Permutation lsa1 lsa2 ->
  forall (rel : A -> B -> Prop),
    (forall a b1 b2, rel a b1 -> rel a b2 -> b1 = b2) ->
    (forall a, exists b, rel a b) ->
    forall lsb1 lsb2,
      rel_map rel lsa1 lsb1 ->
      rel_map rel lsa2 lsb2 ->     
      Permutation lsb1 lsb2.

Lemma rel_map_impl : forall (A B : Type)(rel1 rel2 : A -> B -> Prop) lsa lsb,
  rel_map rel1 lsa lsb ->
  (forall a b, In a lsa -> rel1 a b -> rel2 a b) ->
  rel_map rel2 lsa lsb.

Lemma rel_map_in_inv : forall (A B : Type)(rel : A -> B -> Prop) lsa lsb,
  rel_map rel lsa lsb ->
  forall a, In a lsa -> exists b, In b lsb /\ rel a b.

Inductive sumList_rel(A : Type)(rel : A -> Rat -> Prop) : list A -> Rat -> Prop :=
| slr_nil :
  forall r, 
    r == rat0 ->
    sumList_rel rel nil r
| slr_cons : 
  forall (ls : list A)(a : A) r1 r2 r3,
    sumList_rel rel ls r1 ->
    rel a r2 ->
    r3 == r2 + r1 ->
    sumList_rel rel (a :: ls) r3.

Lemma sumList_rel_distance : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r r1 r2,
  (forall a r1 r2, In a ls -> f1 a r1 -> f2 a r2 -> (ratDistance r1 r2) <= r) ->
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  ratDistance r1 r2 <= (r * (length ls / 1)).

Lemma sumList_rel_all_0_inv : forall (A : Set)(ls : list A)(r  : Rat)(rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a' v, In a' ls -> rel a' v -> v == 0) ->
  r == 0.

Lemma sumList_rel_only_one_inv : forall (A : Set)(rel : A -> Rat -> Prop)(ls : list A)(a : A) r r',
  sumList_rel rel ls r' ->
  In a ls ->
  NoDup ls -> 
  (forall a', In a' ls -> a <> a' -> forall v, rel a' v -> v == 0) ->
  (forall v, rel a v -> v == r) ->
  r' == r.

Lemma sumList_rel_body_eq : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma sumList_rel_plus_inv : forall (A : Type)(ls : list A) r (rel1 rel2 rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a r, In a ls -> rel a r -> forall r1 r2, rel1 a r1 -> rel2 a r2 -> r == r1 + r2) ->
  forall r1 r2, sumList_rel rel1 ls r1 -> sumList_rel rel2 ls r2 -> r == r1 + r2.

Lemma sumList_rel_left_total : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> exists r, rel a r) ->
  exists r, sumList_rel rel ls r.

Lemma sumList_rel_factor_constant : forall (p1 p2 : posnat) (A : Type)(rel : A -> Rat -> Prop)(ls : list A) r,
  sumList_rel (fun a r' => rel a (r' * (RatIntro p1 p2))) ls (r * (RatIntro p2 p1)) ->
  sumList_rel rel ls r.

Lemma sumList_rel_permutation : forall (A : Type)(rel : A -> Rat -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall r, 
    sumList_rel rel ls1 r ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_all_0 : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> rel a 0) ->
  sumList_rel rel ls 0.

Lemma sumList_rel_ls_intersect: forall (A : Set)(rel : A -> Rat -> Prop)(ls1 : list A) r,
  sumList_rel rel ls1 r ->
  forall ls2, 
    NoDup ls1 ->
    NoDup ls2 ->
    eq_dec A ->
    (forall a r1 r2, In a ls1 -> rel a r1 -> rel a r2 -> r1 == r2) -> 
    (forall a, In a ls1 -> ~In a ls2 -> rel a 0) ->
    (forall a, In a ls2 -> ~In a ls1 -> rel a 0) ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_sumList : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a = r) ls
  (sumList ls f).

Lemma sumList_cons : forall (A : Set)(ls : list A) a f,
  sumList (a :: ls) f == f a + (sumList ls f).

Lemma sumList_sum : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  sumList ls (fun a => f1 a + f2 a) ==
  sumList ls f1 + sumList ls f2.

Lemma sumList_summation : forall (A B : Set) f (lsa : list A)(lsb : list B),
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) ==
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma fold_add_subset' : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 -> (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset'
  : forall A : Set,
    eq_dec A ->
    forall (ls1 ls2 : list A) (f : A -> Rat),
      NoDup ls1 ->
      NoDup ls2 ->
      (forall a : A, In a ls1 -> In a ls2) ->
      (forall a : A, In a ls2 -> ~ In a ls1 -> f a == 0) ->
      sumList ls1 f == sumList ls2 f.

Lemma sumList_exactly_one : forall (A : Set) a (ls : list A) f,
  NoDup ls ->
  In a ls ->
  (forall b, In b ls -> a <> b -> f b == 0) ->
  sumList ls f == f a.

Lemma fold_add_permutation : forall (A : Set) ls1 ls2,
  Permutation ls1 ls2 ->
  forall (f : A -> Rat) init1 init2,
    init1 == init2 ->
    fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_permutation : forall (A : Set)(f : A -> Rat) ls1 ls2,
  Permutation ls1 ls2 ->
  sumList ls1 f == sumList ls2 f.

Lemma sumList_rel_body_eq_strong : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', In a ls1 -> rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma rel_map_left_total_strong' : forall (A B : Type)(lsa : list A)(P : A -> Prop)(rel : A -> B -> Prop),
  (forall a, P a -> exists b, rel a b) ->
  (forall a, In a lsa -> P a) ->
  exists lsb, rel_map rel lsa lsb.

Lemma firstn_eq_all_gen : forall (A : Type)(ls : list A) n,
  n = length ls ->
  firstn n ls = ls.

Fixpoint getNats s n :=
  match n with 
    | O => nil
    | S n' => (s + n')%nat :: (getNats s n')
  end.

Lemma ratMult_sumList_rel_distrib : forall (A : Set)(ls : list A) f (x : Rat -> Prop) x' a,
  sumList_rel f ls a ->
  (forall i v1 v2, f i v1 -> f i v2 -> v1 == v2) ->
  (forall x1 x2, x x1 -> x x2 -> x1 == x2) ->
  x x' -> 
  sumList_rel (fun i => ratMult_rel x (f i)) ls (x' * a).

Lemma series_le : forall n (f1 f2 : nat -> Rat -> Prop) r1 r2,
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->
  sumList_rel f1 (getNats O n) r1 ->
  sumList_rel f2 (getNats O n) r2 ->
  r2 <= r1.

Lemma ratSubtract_series_map : forall n f1 f2 a1 a2,
  n > 0 ->
  sumList_rel f1 (getNats O n) a1 ->
  sumList_rel f2 (getNats O n) a2 ->
  (forall i x1 x2, f1 (S i) x1 -> f2 i x2 -> x1 == x2) ->
  (forall i v1 v2, f1 i v1 -> f1 i v2 -> v1 == v2) ->
  (forall i v1 v2, f2 i v1 -> f2 i v2 -> v1 == v2) ->
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->  
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f1 i1 v1 -> f1 i2 v2 -> v2 <= v1) ->
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f2 i1 v1 -> f2 i2 v2 -> v2 <= v1) ->
  forall x1 x2,
    f1 O x1 -> f2 (pred n) x2 ->
    ratSubtract a1 a2 == ratSubtract x1 x2.

Lemma sum_power_series : forall n (f : Rat -> Prop) a a',
  n > 0 ->
  (exists v, f v) ->
  (forall v1 v2, f v1 -> f v2 -> v1 == v2) ->
  (forall v, f v -> ~1 <= v) ->
  sumList_rel (fun i : nat => expRat_rel f i) (getNats 0 n) a ->
  ratMult_rel (ratSubtract_rel (eqRat 1) (expRat_rel f n))
         (ratInverse_rel (ratSubtract_rel (eqRat 1) f)) a' ->
         a == a'.

Lemma sumList_rel_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r1 r2,
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  (forall a v1 v2, In a ls -> f1 a v1 -> f2 a v2 -> v1 <= v2) ->
  r1 <= r2.

Lemma sumList_filter_le : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool),
  sumList (filter P ls) f <= sumList ls f.

Lemma sumList_filter_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f == (sumList (filter P ls) f + (sumList (filter (fun a => negb (P a)) ls) f)).

Lemma sumList_rel_sumList_eqRat : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a == r) ls
  (sumList ls f).

Lemma sumList_series_incr : forall n2 n1 (f f' : nat -> Rat),
  (forall n, (f n) == (f' (S n))) ->
  sumList (getNats n1 n2) f == sumList (getNats (S n1) n2) f'.

Lemma sumList_series_split_first : forall n f, 
  sumList (n :: getNats O n) f == f O + (sumList (getNats 1 n) f).

Lemma firstn_nil : forall (A : Set) n, 
  firstn n nil = (@nil A).

Lemma firstn_ge_all : forall n (A : Set) (ls : list A),
  n >= length ls ->
  firstn n ls = ls.

Lemma firstn_app : forall n (A : Set) (ls1 ls2 : list A),
  (n <= length ls1)%nat ->
  firstn n (ls1 ++ ls2) = firstn n ls1.

Lemma sumList_rel_func : forall (A : Set)(f : A -> Rat -> Prop) ls r1,
  sumList_rel f ls r1 ->
  forall r2,
  sumList_rel f ls r2 ->
  (forall a v1 v2, f a v1 -> f a v2 -> v1 == v2) ->
  r1 == r2.

Lemma sumList_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f ==
  sumList ls (fun a => (f a) * (if (P a) then 1 else 0)) + 
  sumList ls (fun a => (f a) * (if (P a) then 0 else 1)).

Lemma sumList_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a <= f2 a) ->
  sumList ls f1 <= sumList ls f2.

Lemma sumList_distance_prod : forall (A : Set)(ls : list A)(f f1 f2 : A -> Rat),
  | (sumList ls (fun a => (f a) * (f1 a))) - (sumList ls (fun a => (f a) * (f2 a))) | <= sumList ls (fun a => (f a) * | (f1 a) - (f2 a) |).

Theorem sumList_all : 
  forall (A : Set)(ls : list A)(f : A -> Rat) c,
    (forall a, In a ls -> (f a) == c) ->
    sumList ls f == (length ls)/1 * c.

Theorem filter_app : 
  forall (A : Set)(ls1 ls2 : list A)(f : A -> bool),
    filter f (ls1 ++ ls2) = filter f ls1 ++ filter f ls2.

Theorem filter_true : 
  forall (A : Set)(ls : list A)(f : A -> bool),
    (forall a, In a ls -> (f a) = true) ->
    filter f ls = ls.

Theorem sumList_subset_le : 
  forall (A : Set){eqd: EqDec A}(ls1 ls2 : list A)(f : A -> Rat),
    NoDup ls1 ->
    NoDup ls2 ->
    (forall a, In a ls1 -> In a ls2) ->
    sumList ls1 f <= sumList ls2 f.

Fixpoint allNatsLt (n : nat) :=
  match n with
    | 0 => nil
    | S n' => allNatsLt n' ++ (n' :: nil)
  end.

Lemma allNatsLt_length : 
  forall n, 
    length (allNatsLt n) = n.

Lemma allNatsLt_lt : 
  forall n v,
    In v (allNatsLt n) ->
    v < n.

Lemma app_NoDup : forall(A : Set)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> ~In a ls2) ->
  (forall a, In a ls2 -> ~In a ls1) ->
  NoDup (ls1 ++ ls2).

Lemma allNatsLt_NoDup : 
  forall (n : nat),
    NoDup (allNatsLt n).

Lemma allNatsLt_lt_if : 
  forall (n i : nat), 
    i < n ->
    In i (allNatsLt n).

Lemma nth_allNatsLt_lt : 
  forall k n,
    n < k ->
    nth n (allNatsLt k) n = n.

Lemma nth_allNatsLt : 
  forall k n,
    nth n (allNatsLt k) n = n.

Theorem allNatsLt_filter_lt : 
  forall (p n : nat),
    (n <= p)%nat->
    filter (fun z => if (lt_dec z n) then true else false) (allNatsLt p) = 
    allNatsLt n.

Theorem map_eq_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    map f1 ls = map f2 ls ->
    (forall a, In a ls -> f1 a = f2 a).

Theorem map_eq_if_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    (forall a, In a ls -> f1 a = f2 a) ->
    map f1 ls = map f2 ls.

Theorem map_eq_subset : 
  forall (A B : Type)(ls2 ls1 : list A)(f1 f2 : A -> B),
    map f1 ls1 = map f2 ls1 ->
    (forall a, In a ls2 -> In a ls1) ->
    map f1 ls2 = map f2 ls2.

Fixpoint getSomes(A : Type)(ls : list (option A)) :=
  match ls with
    | nil => nil
    | o :: ls' =>
      match o with
        | None => getSomes ls'
        | Some x => x :: (getSomes ls')
      end
  end.

Lemma nth_nil:
  forall (A : Set)(i : nat)(def : A),
    nth i nil def = def.

Theorem listReplace_None_Permutation : 
  forall (A : Set) n ls (y : A),
    nth n ls None = None ->
    Permutation (getSomes (listReplace ls n (Some y) None)) (y :: (getSomes ls)).

Theorem listReplace_getSomes_Permutation_h : 
  forall (A : Set) l1' l2,
    Permutation l1' l2 ->
    forall l1 n2 (y : A),
      l1' = getSomes l1 ->
      nth n2 l1 None = None ->
      Permutation
        (getSomes
           (listReplace l1 n2
                        (Some y) None))
        (y :: l2).

Theorem listReplace_getSomes_Permutation : 
  forall (A : Set) l1 l2 n2 (y : A),
    nth n2 l1 None = None ->
    Permutation (getSomes l1) l2 ->
    Permutation
      (getSomes
         (listReplace l1 n2
                      (Some y) None))
      (y :: l2).

Lemma nth_listReplace_ne : 
  forall (i1 i2 : nat)(A : Set)(ls : list A)(a def : A),
    i1 <> i2 ->
    nth i1 (listReplace ls i2 a def) def = 
    nth i1 ls def.

Theorem listReplace_length :
  forall (A : Set)(ls : list A)(i : nat)(a def : A),
    i < length ls ->
    length (listReplace ls i a def) = length ls.

Lemma listReplace_in_nil : 
  forall (A : Set)(i : nat)(a1 a2 def : A),
    In a1 (listReplace nil i a2 def) ->
    a1 = a2 \/ a1 = def.

Lemma listReplace_in : 
  forall (A : Set)(ls : list A)(a1 a2 def : A)(i : nat),
    In a1 (listReplace ls i a2 def) ->
    (In a1 ls \/ a1 = a2 \/ a1 = def).

Theorem firstn_map : 
  forall (A B : Set)(f : A -> B)(ls : list A) n,
    firstn n (map f ls) = map f (firstn n ls).

Lemma firstn_app_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    firstn (length ls1) (ls1 ++ ls2) = ls1.

Theorem map_nth_in : 
  forall (A B : Set)(ls : list A)(f : A -> B) i defa defb,
    i < length ls ->
    nth i (map f ls) defb = f (nth i ls defa).

Lemma flatten_app : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    flatten (ls1 ++ ls2) = flatten ls1 ++ flatten ls2.

Inductive list_pred(A B : Set)(pred : A -> B -> Prop) : list A -> list B -> Prop :=
| list_pred_nil : 
    list_pred pred nil nil
| list_pred_cons : 
    forall a1 a2 ls1 ls2,
      pred a1 a2 ->
      list_pred pred ls1 ls2 ->
      list_pred pred (a1 :: ls1) (a2 :: ls2).

Lemma list_pred_eq_impl_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    list_pred eq ls1 ls2 ->
    ls1 = ls2.

Lemma flatten_eq : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred eq ls1 ls2 ->
    flatten ls1 = flatten ls2.

Theorem app_cons_eq : 
  forall (A : Type) ls2 ls1 (a : A),
    ls2 ++ (a :: ls1) = (ls2 ++ (a :: nil)) ++ ls1.

Theorem skipn_nil : 
  forall (A : Type) n,
    skipn n (@nil A) = nil.

Theorem nth_In_exists : 
  forall (A : Type)(ls : list A) a def,
    In a ls ->
    exists n, nth n ls def = a.

Theorem nth_skipn_eq : 
  forall (A : Set)(y x: nat)(ls : list A)(def : A),
    nth x (skipn y ls) def = nth (x + y) ls def.

Theorem perm_flatten_listReplace_nil : 
  forall b (A : Set)(a : A),
    Permutation (flatten (listReplace nil b (a :: nil) nil)) (a :: nil).

Theorem perm_flatten_listReplace : 
  forall b (A : Set)(ls1 : list (list A))(ls2 : list A) (a : A),
    Permutation (flatten ls1) ls2 ->
    Permutation (flatten (listReplace ls1 b (nth b ls1 nil ++ (a :: nil)) nil))
                (a :: ls2).

Theorem map_cons : 
  forall (A B : Type)(f : A -> B)(ls : list A)(a : A),
    map f (a :: ls) = (f a) :: map f ls.

Theorem app_eq_inv : 
  forall (A : Type)(ls1 ls2 ls3 ls4 : list A),
    length ls1 = length ls3 ->
    (ls1 ++ ls2) = (ls3 ++ ls4) ->
    ls1 = ls3 /\ ls2 = ls4.

Theorem NoDup_app : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1 /\
    NoDup ls2 /\
    (forall a1 a2,
       In a1 ls1 ->
       In a2 ls2 ->
       a1 <> a2).

Theorem firstn_In : 
  forall (A : Type) n (ls : list A)(a : A),
             In a (firstn n ls) ->
             In a ls.

Theorem pred_firstn_In :
  forall (A : Set) ls1 ls2,
    list_pred (fun x0 y : list A => exists n : nat, y = firstn n x0) ls1 ls2 ->
    forall a,
      In a (flatten ls2) -> In a (flatten ls1).

Theorem firstn_NoDup : 
  forall (A : Type) n (ls : list A),
    NoDup ls ->
    NoDup (firstn n ls).
 
Theorem NoDup_flatten_subset : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred (fun x y => exists n, y = firstn n x) ls1 ls2 ->
    NoDup (flatten ls1) ->
    NoDup (flatten ls2).

Theorem allNatsLt_nil_inv :
  forall n,
    allNatsLt n = nil ->
    n = O.
  
Theorem firstn_allNatsLt_h : 
  forall ls n1 n2,
    n2 >= n1 ->
    ls = (allNatsLt n2) ->
    firstn n1 ls = allNatsLt n1.

Theorem firstn_allNatsLt : 
  forall n1 n2,
    n2 >= n1 ->
    firstn n1 (allNatsLt n2) = allNatsLt n1.

Theorem NoDup_app_l : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1.

Theorem NoDup_map : 
  forall (A B : Type)(f : A -> B)(ls : list A),
    NoDup (map f ls) ->
    (NoDup ls /\ (forall b1 b2, In b1 ls -> In b2 ls -> f b1 = f b2 -> b1 = b2)).

Theorem map_fst_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (fst x)) (combine ls lsc).

Theorem map_snd_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (snd x)) (combine lsc ls).

Theorem In_combine_NoDup_eq_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a1 a2 b,
    NoDup lsb ->
    In (a1, b) (combine lsa lsb) ->
    In (a2, b) (combine lsa lsb) ->
    a1 = a2.

Theorem In_combine_NoDup_eq_r : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a b1 b2,
    NoDup lsa ->
    In (a, b1) (combine lsa lsb) ->
    In (a, b2) (combine lsa lsb) ->
    b1 = b2.

Theorem zip_eq_nil_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = nil ->
    length lsa = length lsb ->
    lsa = nil.

Theorem fst_split_app_eq : 
  forall (A B : Type)(ls1 ls2 : list (A * B)),
    fst (split (ls1 ++ ls2)) = 
    fst (split ls1) ++ fst (split ls2).

Theorem fst_split_flatten_eq : 
  forall (A B : Type)(ls : list (list (A * B))),
    fst (split (flatten ls)) = 
    flatten (map (fun x => fst (split x)) ls).

Theorem fst_split_map_eq : 
  forall (A B C : Type)(ls : list A)(f : A -> B * C),
    fst (split (map f ls)) = 
    map (fun a => fst (f a)) ls.

Theorem in_split_l_if : 
  forall (A B : Type)(ls : list (A * B)) a,  
    In a (fst (split ls)) -> 
    exists b,
      In (a, b) ls.

Theorem in_fst_split_if : 
  forall (A B : Type)(ls : list (A * B)) a b,
    In (a, b) ls ->
    In a (fst (split ls)).

Theorem map_pair_fst_eq : 
  forall (A B C D: Type)(f1 : B -> D)(f2 : C -> D)(ls1 : list B)(ls2 : list C)(a1 a2 : A),
    map (fun x => (a1, f1 x)) ls1 = map (fun x => (a2, f2 x)) ls2 ->
    ls1 <> nil ->
    a1 = a2.

Theorem In_zip_strong : 
  forall (A B : Set)(ls : list A) f a (b : B),
    In (a, b) (zip ls (map f ls)) ->
    (In a ls /\ b = f a).

Lemma list_pred_impl : 
  forall (A B : Set)(lsa : list A)(lsb : list B) (P1 : A -> B -> Prop),
       list_pred P1 lsa lsb ->
       forall (P2 : A -> B -> Prop), 
         (forall a b, P1 a b -> P2 a b) ->
         list_pred P2 lsa lsb.

Theorem list_pred_eq_in : 
  forall (A : Set)(ls : list A),
    list_pred (fun a b => a = b /\ In a ls /\ In b ls) ls ls.

Theorem zip_combine_eq : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = combine lsa lsb.

Theorem list_pred_fst_split_eq : 
  forall (A B C : Set)(ls1 : list (A * B))(ls2 : list (A * C)),
    list_pred (fun a b => fst a = fst b) ls1 ls2 ->
    fst (split ls1)  = fst (split ls2).

Theorem unzip_eq_split : 
  forall (A B : Set)(ls : list (A * B)),
    unzip ls = split ls.

Theorem in_split_r_if:
  forall (A B : Type) (ls : list (A * B)) (b : B),
    In b (snd (split ls)) -> exists a : A, In (a, b) ls.

Fixpoint nth_option(A : Set)(ls : list A)(i : nat) :=
  match ls with 
    | nil => None
    | a :: ls' =>
      match i with
        | O => Some a
        | S i' =>
          nth_option ls' i'
          end
  end.

Theorem nth_option_app_Some : 
  forall (A : Set)(ls1 ls2 : list A) i a,
    nth_option ls1 i = Some a ->
    nth_option (ls1 ++ ls2) i = Some a.

Theorem nth_option_Some_lt : 
  forall (A : Set)(ls : list A) i a,
    nth_option ls i = Some a ->
    i < length ls.

Theorem nth_option_app_None : 
  forall (A : Set)(ls1 ls2 : list A) i,
    nth_option ls1 i = None ->
    nth_option (ls1 ++ ls2) i = nth_option ls2 (i - length ls1).

Theorem nth_option_None_ge : 
  forall (A : Set)(ls : list A) i,
    nth_option ls i = None ->
    i >= length ls.

Theorem skipn_S_eq : 
  forall (A : Set)(ls : list A) n a,
    nth_option ls n = Some a -> 
    skipn n ls = a :: (skipn (S n) ls).

Theorem nth_option_snd_split : 
  forall (A B : Set)(ls : list (A * B)) n a b,
    nth_option ls n = Some (a, b) ->
    nth_option (snd (split ls)) n = Some b.

Theorem snd_split_map_eq :
  forall (A B C : Set)(ls : list A)(f : A -> B * C),
    snd (split (map f ls)) =
    map (fun p => snd (f p)) ls.

Theorem cons_ne : 
  forall (A : Set)(eqda : eq_dec A)(a1 a2 : A)(ls1 ls2 : list A),
    ((a1 :: ls1) = (a2 :: ls2) -> False) ->
    (a1 <> a2) \/ (ls1 <> ls2).

Theorem map_ne_same_ex : 
  forall (A B : Set)(f1 f2 : A -> B)(ls : list A),
    eq_dec B ->
    map f1 ls <> map f2 ls ->
    exists a, In a ls /\ f1 a <> f2 a.

Theorem list_pred_I_in : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    list_pred (fun a b => In a lsa /\ In b lsb) lsa lsb.

Theorem list_pred_fst_split_eq_l : 
  forall (A B : Set)(a : list (A * B))(b : list A),
    list_pred (fun a0 b0 => fst a0 = b0) a b ->
    b = fst (split a).

Theorem list_pred_fst_split_flatten_eq_l : 
  forall (A B : Set)(a : list (list (A * B)))(b : list (list A)),
    list_pred
      (list_pred
         (fun a0 b0 => fst a0 = b0)) a b ->
    flatten b = fst (split (flatten a)).

Theorem fold_add_const_mult : 
  forall (A : Type)(ls : list A)(c : nat) init,
    (fold_left (fun acc _ => acc + c) ls init = 
     (length ls) * c + init)%nat.

Theorem list_pred_snd_split_eq_l:
  forall (A B : Set) (a : list (B * A)) (b : list A),
    list_pred (fun (a0 : B * A) (b0 : A) => snd a0 = b0) a b ->
    b = snd (split a).

Theorem NoDup_snd_split_if : 
  forall (A B : Type)(ls : list (A * B)),
    NoDup (snd (split ls)) ->
    NoDup ls.

Fixpoint forNats(n : nat) :=
  match n with
      | 0 => nil
      | S n' =>
        cons n' (forNats n')
  end.

Lemma forNats_In : 
  forall n i,
    i < n <->
    In i (forNats n).

Lemma forNats_NoDup : 
  forall n,
    NoDup (forNats n).

Lemma forNats_length : 
  forall n,
    length (forNats n) = n.

Lemma sumList_forNats_first_ls : 
  forall (n : nat)(f : nat -> Rat),
    n <> O ->
    f O <= sumList (forNats n) f.

Lemma sumList_forNats_distance : 
  forall (n : nat)(f : nat -> Rat), 
    (| sumList (forNats n) f - sumList (forNats n) (fun i => f (S i)) |) == (| (f O) - (f n) |).

Lemma flatten_map_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    flatten (map (fun a => (f a) :: nil) ls) =
    map f ls.

Lemma app_NoDup_inv : 
    forall (A : Set)(ls1 ls2 : list A), 
      NoDup (ls1 ++ ls2) ->
      (forall a, In a ls1 -> In a ls2 -> False).

Lemma flatten_NoDup : 
  forall (A : Set)(ls : list (list A)),
    NoDup ls ->
    (forall x, In x ls -> NoDup x) ->
    (forall x1 x2, In x1 ls -> In x2 ls -> x1 <> x2 -> NoDup (x1 ++ x2)) ->
    NoDup (flatten ls).

Lemma map_NoDup'
: forall (A B : Set) (ls : list A) (f : A -> B),
    NoDup ls ->
    (forall a1 a2 : A, In a1 ls -> In a2 ls ->a1 <> a2 -> f a1 <> f a2) -> 
    NoDup (map f ls).

Lemma getUnique_cons : 
  forall (A : Set)(eqd : eq_dec A)(ls2 ls1 : list A) a,
    a :: ls1 = (getUnique ls2 eqd) ->
    exists ls3 ls4, 
      ls2 = ls3 ++ (a :: ls4) /\
      ls1 = (getUnique ls4 eqd).

Lemma getUnique_eq_inv : 
  forall (A : Set)(a : A)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
    getUnique ls1 eqd1 = getUnique ls2 eqd2 ->
    In a ls1 -> 
    In a ls2.

Lemma sumList_app :
  forall (A : Set)(ls1 ls2 : list A)(f : A -> Rat),
    sumList (ls1 ++ ls2) f == (sumList ls1 f) + (sumList ls2 f).

Lemma filter_all_true : 
  forall (A : Set)(ls : list A)(P : A -> bool), 
    (forall a, In a ls -> P a = true) ->
    filter P ls = ls.

Lemma sumList_map : 
  forall (A B : Set)(ls : list A)(f1 : A -> B)(f : B -> Rat),
    sumList (map f1 ls) f == 
    sumList ls (fun a => f (f1 a)).

Lemma sumList_filter_twice : 
  forall (A B : Set)(P : A -> bool)(ls : list A)(lsf : A -> list B)(f : A * B -> Rat),
    sumList (filter (fun p => P (fst p)) (flatten (map (fun a => map (fun b => (a, b)) (lsf a)) ls))) f ==  
    sumList (filter P ls) (fun a => sumList (lsf a) (fun b => f (a, b))).

Lemma filter_cons : 
  forall (A : Set)(P : A -> bool)(ls : list A) a,
    filter P (a :: ls) = 
    if (P a) then (a :: (filter P ls)) else (filter P ls).

Theorem sumList_1_mult : 
  forall (A : Set)(ls : list A),
    sumList ls (fun _ => 1) == length ls / 1.

Theorem fold_left_orb_true_init : 
  forall (A : Type)(f : A -> bool)(ls : list A),
    fold_left (fun b x => orb b (f x)) ls true = true.

Theorem fold_left_orb_true_in : 
  forall (A : Type)(f : A -> bool)(ls : list A) a init,
    In a ls ->
    f a = true ->
    fold_left (fun b x => orb b (f x)) ls init = true.

Theorem hd_error_Some_In : 
  forall (A : Type)(ls : list A) a,
    hd_error ls = Some a ->
    In a ls.

Theorem fold_and_false_init :
  forall (A : Type)(ls : list A) P,
    fold_left (fun b z => b && negb (P z)) ls false = false.

Theorem hd_filter_false_eq_and_false : 
  forall (A : Type)(ls : list A)(P : A -> bool),
    (if hd_error (filter P ls) then false else true) =
    fold_left (fun (b : bool) (z : A) => b && negb (P z)) ls true.

Theorem fst_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (A * B))(ls2 : list A),
    list_pred (fun a b => fst a = b) ls1 ls2 ->
    fst (split ls1) = ls2.

Theorem snd_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (B * A))(ls2 : list A),
    list_pred (fun a b => snd a = b) ls1 ls2 ->
    snd (split ls1) = ls2.

Theorem combine_map_eq : 
  forall (A B C : Type)(lsa : list A)(lsb : list B)(f : B -> C),
    combine lsa (map f lsb) = map (fun p => (fst p, f (snd p))) (combine lsa lsb).

Theorem map_ext_pred : 
  forall (A B C : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> C),
    list_pred P lsa lsb ->
    (forall a b, P a b -> (f1 a) = (f2 b)) ->
    map f1 lsa = map f2 lsb.

Theorem list_pred_combine_l_h : 
  forall (A C : Set)(lsa : list A)(lsc : list C) P1,
    list_pred P1 lsa lsc ->
    forall (B : Set)(lsb : list B) P2, 
      list_pred P2 lsb lsc ->
      list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Theorem list_pred_combine_l : 
  forall (A B C : Set)P1 P2 (lsa : list A)(lsb : list B)(lsc : list C),
    list_pred P1 lsa lsc -> 
    list_pred P2 lsb lsc ->
    list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Lemma list_pred_symm : 
  forall (A B : Set)(P : A -> B -> Prop) lsa lsb,
    list_pred (fun b a => P a b) lsb lsa ->
    list_pred P lsa lsb.

Theorem list_pred_combine_r
: forall (A B C : Set) (P1 : A -> B -> Prop) (P2 : A -> C -> Prop)
         (lsa : list A) (lsb : list B) (lsc : list C),
    list_pred P1 lsa lsb ->
    list_pred P2 lsa lsc ->
    list_pred (fun a p => P1 a (fst p) /\ P2 a (snd p))
              lsa (combine lsb lsc). *)

Require Import FCF.Limit.
(* FCF.Limit:
Set Implicit Arguments.

Require Import Arith.
Require Import FCF.Fold.
Require Import List.

Require Import FCF.StdNat.
Require Import FCF.Rat.

Section Limit.

  Variable A : Set.
  Variable eq : A -> A -> Prop.
  Hypothesis eq_dec : forall (a1 a2 : A), 
    {eq a1 a2} + {~eq a1 a2}.
  Hypothesis eq_refl : forall (a : A),
    eq a a.
  Hypothesis eq_symm : forall a1 a2,
    eq a1 a2 ->
    eq a2 a1.

  Variable distance : A -> A -> A.
  Hypothesis distance_comm : forall a1 a2,
    eq (distance a1 a2) (distance a2 a1).
  Variable half : A -> A.
  Variable zero : A.
  Hypothesis half_nz : forall (a : A),
    ~eq a zero ->
    ~eq (half a) zero.

  Hypothesis distance_eq_zero : forall (a1 a2 : A),
    eq a1 a2 <->
    eq (distance a1 a2) zero.
  Hypothesis distance_eq_compat : forall a1 a2 a3 a4,
    eq a1 a3 ->
    eq a2 a4 ->
    eq (distance a1 a2) (distance a3 a4).
 
  Variable le : A -> A -> Prop.
  Hypothesis le_eq : forall (a1 a2 : A),
    eq a1 a2 ->
    le a1 a2.
  Hypothesis le_trans : forall (a1 a2 a3 : A),
    le a1 a2 ->
    le a2 a3 ->
    le a1 a3.
  
  Hypothesis all_pos : forall (a : A),
    le zero a.
  Hypothesis le_impl_eq : forall (a1 a2 : A),
    le a1 a2 ->
    le a2 a1 ->
    eq a1 a2.

  Variable plus : A -> A -> A.
  Variable plus_0_eq : forall (a1 a2 : A),
    eq a2 zero ->
    eq a1 (plus a1 a2).
  Variable plus_le_compat : forall a1 a2 a3 a4,
    le a1 a2 ->
    le a3 a4 ->
    le (plus a1 a3) (plus a2 a4).

  Hypothesis triangle_inequality : forall (a1 a2 a3 : A),
    le (distance a1 a2) (plus (distance a1 a3) (distance a3 a2)).
  Hypothesis half_plus : forall (a : A),
    eq (plus (half a) (half a)) a.
  Hypothesis le_half : forall (a : A),
    le a (half a) ->
    eq a zero.

  Theorem le_epsilon_zero : forall (a : A),
    (forall (epsilon : A), ~eq epsilon zero -> le a epsilon) ->
    eq a zero.

  Definition left_total(r : nat -> A -> Prop) :=
    forall n, exists a, r n a.

  Definition functional(r : nat -> A -> Prop) :=
    forall n a1 a2,
      r n a1 ->
      r n a2 ->
      eq a1 a2.
    
  Definition inf_limit(f : nat -> A -> Prop)(a : A) :=
    forall (epsilon : A),
      ~eq epsilon zero -> 
      exists n : nat,
        forall (n' : nat),
          n' >= n ->
          forall a',
            f n' a' ->
            le (distance a' a) epsilon.

  Definition inf_limit_2(f f' : nat -> A -> Prop) :=
    forall (epsilon : A),
      ~eq epsilon zero -> 
      exists n : nat,
        forall (n' : nat),
          n' >= n ->
          forall a a',
            f n' a ->
            f' n' a' ->
            le (distance a a') epsilon.
  
  Theorem inf_limit_2_const : forall (f : nat -> A -> Prop)(a : A),
    inf_limit_2 f (fun x => eq a) <->
    inf_limit f a.

    intuition.
  Abort.

  Theorem limit_eq_h : forall f epsilon a1 a2,
    left_total f ->
    ~eq epsilon zero ->
    inf_limit f a1 ->
    inf_limit f a2 ->
    le (distance a1 a2) epsilon.

  Theorem limits_eq : forall f a1 a2,
    left_total f ->
    inf_limit f a1 ->
    inf_limit f a2 ->
    eq a1 a2.

  Theorem limit_f_eq : forall f1 f2 a,
    inf_limit f1 a ->
    (forall n a', (f1 n a' <-> f2 n a')) ->
    inf_limit f2 a.

End Limit.

Local Open Scope rat_scope.

Definition rat_inf_limit(f : nat -> Rat -> Prop)(r : Rat) :=
  inf_limit eqRat ratDistance rat0 leRat f r.

Definition rat_inf_limit_2(f1 f2 : nat -> Rat -> Prop) :=
  inf_limit_2 eqRat ratDistance rat0 leRat f1 f2.

Definition rat_limits_eq :=
  limits_eq eq_Rat_dec ratDistance_comm ratHalf ratHalf_ne_0 ratIdentityIndiscernables eqRat_impl_leRat leRat_trans ratAdd ratAdd_leRat_compat ratTriangleInequality ratHalf_add le_ratHalf_0.

Require Import Arith.

Theorem rat_inf_limit_2_trans : forall f1 f2 f3,
  rat_inf_limit_2 f1 f2 ->
  rat_inf_limit_2 f2 f3 ->
  left_total f2 ->
  rat_inf_limit_2 f1 f3.

Lemma rat_inf_limit_squeeze : forall (f1 f2 f: nat -> Rat -> Prop) c (v : Rat),
  rat_inf_limit f1 v ->
  rat_inf_limit f2 v ->
  (forall n a a1, n >= c -> f n a -> f1 n a1 -> a1 <= a) ->
  (forall n a a2, n >= c -> f n a -> f2 n a2 -> a <= a2) ->
  left_total f1 ->
  left_total f2 ->
  rat_inf_limit f v.

Lemma rat_inf_limit_div_2 : forall (f : nat -> Rat -> Prop)(v : Rat),
  rat_inf_limit f v ->
  rat_inf_limit (fun n => (f (div2 n))) v.

Lemma rat_inf_limit_sum : forall (f1 f2 : nat -> Rat -> Prop) v1 v2,
  left_total f1 ->
  left_total f2 ->
  rat_inf_limit f1 v1 ->
  rat_inf_limit f2 v2 ->
  rat_inf_limit (fun n => (ratAdd_rel (f1 n) (f2 n))) (v1 + v2).

Lemma rat_inf_limit_difference : forall (f1 f2 : nat -> Rat -> Prop) c1 c2,
  left_total f1 ->
  left_total f2 ->
  rat_inf_limit f1 c1 ->
  rat_inf_limit f2 c2 -> 
  rat_inf_limit (fun n => (ratSubtract_rel (f1 n) (f2 n))) (ratSubtract c1 c2).

Lemma rat_inf_limit_product : forall (f1 f2 : nat -> Rat -> Prop) c1 c2,
  left_total f1 ->
  left_total f2 ->
  rat_inf_limit f1 c1 ->
  rat_inf_limit f2 c2 -> 
  rat_inf_limit (fun n => (ratMult_rel (f1 n) (f2 n))) (c1 * c2).

Definition rat_limit(f : Rat -> Rat -> Prop)(p L : Rat) :=
  forall epsilon, 
    ~ (epsilon == 0) ->
    exists delta, (~delta == 0) /\
      forall x v,
        f x v ->
        (ratDistance x p) <= delta ->
        (ratDistance v L) <= epsilon.

Definition continuous_at(f : Rat -> Rat -> Prop)(c : Rat) :=
  forall v, f c v ->
    rat_limit f c v.

Lemma rat_inf_limit_comp : forall (f : nat -> Rat -> Prop)(g : Rat -> Rat -> Prop) a v,
  rat_inf_limit f a ->
  g a v ->
  continuous_at g a ->
  left_total f ->
  rat_inf_limit (fun n r => forall v', (f n v' -> g v' r)) v.

Lemma rat_inf_limit_trans : forall (f1 f2 : nat -> Rat -> Prop) a,
  rat_inf_limit_2 f1 f2 ->
  rat_inf_limit f2 a ->
  left_total f2 ->
  rat_inf_limit f1 a.

Lemma rat_inf_limit_eq : forall f a1 a2,
  rat_inf_limit f a1 ->
  a1 == a2 ->
  rat_inf_limit f a2.

Lemma rat_inf_limit_const : forall (f : Rat -> Prop) a,
  f a ->
  (forall a1 a2, f a1 -> f a2 -> a1 == a2) ->
  rat_inf_limit (fun _ => f) a.

Lemma rat_inf_limit_summation : forall (A : Set)(f1 : A -> nat -> Rat -> Prop)(f2 : A -> Rat)(ls : list A),
  (forall a, rat_inf_limit (f1 a) (f2 a)) ->
  (forall a, left_total (f1 a)) ->
  (forall a n r1 r2, f1 a n r1 -> f1 a n r2 -> r1 == r2) ->
  rat_inf_limit
  (fun n : nat => sumList_rel (fun a0 : A => f1 a0 n) ls)
  (sumList ls f2).
  
Lemma ratInverse_continuous : forall c,
  ~ c == 0 ->
  continuous_at (fun v' r : Rat => r == ratInverse v') c.

Lemma rat_inf_limit_ratInverse : forall (f : nat -> Rat -> Prop) a v,
  rat_inf_limit f a ->
  ~ a == 0 ->
  ratInverse a == v ->
  left_total f ->
  rat_inf_limit (fun n => ratInverse_rel (f n)) v.

Lemma rat_inf_limit_exp_0 : forall (f : nat -> Rat -> Prop) a,
  rat_inf_limit f a ->
  ~ 1 <= a ->
  (forall n, exists r, f n r) ->
  rat_inf_limit (fun n => (expRat_rel (f n) n)) 0.

Lemma power_series_limit_2 : forall (f : nat -> Rat -> Prop) a,
  rat_inf_limit f a ->
  (forall n v, f n v -> ~ 1 <= v) ->
  ~ 1 <= a ->
  (forall n, exists v, f n v) ->
  (forall n v1 v2, f n v1 -> f n v2 -> v1 == v2) ->
  rat_inf_limit 
  (fun n => sumList_rel 
    (fun i => expRat_rel (f n) i)
    (getNats O n))
  (ratInverse (ratSubtract 1 a)).

Lemma rat_inf_limit_mono  : forall (f : nat -> Rat -> Prop) (g : nat -> nat)(v : Rat),
    rat_inf_limit f v -> 
    (forall n1 n2, n1 <= n2 -> g n1 <= g n2)%nat ->
    (forall y, exists x, g x = y) ->
    rat_inf_limit (fun n => f (g n)) v.

Lemma rat_inf_limit_sqrt:
  forall (f : nat -> Rat -> Prop) (v : Rat),
    rat_inf_limit f v -> 
    rat_inf_limit (fun n => f (Nat.sqrt n)) v. *)

Require Import Permutation.



Local Open Scope rat_scope.

Local Open Scope list_scope.



Lemma evalDet_step_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,

  evalDet_step c nil = (cs_done a s) ->

  evalDist c a' == if (eqd a a') then 1 else 0.

  

  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  destruct (e a0 a'); subst.

  destruct (eqd a' a').

  intuition.

  congruence.

  destruct (eqd a0 a'); subst.

  congruence.

  intuition.

  

  destruct (evalDet_step c nil); discriminate.

  

  destruct n; discriminate.

  

  congruence.

  

Qed.



Lemma evalDet_step_nil_dist_preserved : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  forall c' a, 

    evalDet_step c nil = cs_more c' nil ->

    evalDist c a == evalDist c' a.

  

  induction 1; intuition; simpl in *.

  discriminate.

  case_eq (evalDet_step c1 nil); intuition;

    rewrite H3 in H2; try discriminate.

  inversion H2; clear H2; subst.

  erewrite evalDet_step_done_support_singleton; eauto.

  unfold sumList. simpl.

  rewrite <- ratAdd_0_l.

  rewrite (@evalDet_step_done_evalDist _ (comp_eq_dec c1)); eauto.

  destruct (comp_eq_dec c1 b b).

  eapply ratMult_1_l.

  congruence.

  

  inversion H2; clear H2; subst.

  simpl.

  rewrite sumList_permutation.

  2:{

    eapply evalDet_step_more_support_preserved.

    eauto.

  }

  eapply sumList_body_eq.

  intuition.

  eapply ratMult_eqRat_compat; intuition.

  

  destruct n.

  inversion H; clear H; subst.

  simpl.

  

  rewrite (vector_0 a).

  destruct (Bvector_eq_dec [] [] ).

  eapply eqRat_terms; intuition.

  congruence.

  

  discriminate.

  

  inversion H1; clear H1; subst.

  simpl.

  

  destruct (in_dec (comp_eq_dec c) a (getSupport c)).

  

  symmetry.

  eapply eqRat_trans.

  eapply (sumList_filter_partition P).

  eapply eqRat_trans.

  eapply ratAdd_eqRat_compat.

  eapply sumList_body_eq.

  intuition.

  assert (P a0 = true).

  eapply filter_In; eauto.

  rewrite H2.

  simpl.

  eapply eqRat_refl.

  eapply sumList_body_eq.

  intuition.

  assert (P a0 = false).

  assert (negb (P a0) = true).

  apply filter_In in H1.

  intuition.

  eapply negb_true_iff.

  trivial.

  rewrite H2.

  simpl.

  eapply eqRat_refl.

  

  case_eq (P a); intuition.

  unfold indicator.

  rewrite H1.

  rewrite ratMult_1_l.

  assert (sumList (filter P (getSupport c))

    (fun a0 : A => evalDist c a0 * (if comp_eq_dec c a0 a then 1 else 0)) == evalDist c a).

  

  rewrite (@sumList_exactly_one _ a).

  destruct (comp_eq_dec c a a); try congruence.

  eapply ratMult_1_r.

  eapply filter_NoDup.

  eapply getSupport_NoDup.

  eapply filter_In; eauto.

  intuition.

  destruct (comp_eq_dec c b0 a); subst; intuition.

  eapply ratMult_0_r.

  rewrite H2.

  rewrite sumList_factor_constant_r.

  rewrite ratMult_1_l.

  assert (sumList (filter (fun a0 : A => negb (P a0)) (getSupport c)) (evalDist c) == (ratSubtract 1 (sumList (filter P (getSupport c)) (evalDist c)))).

  rewrite <- evalDist_lossless.

  rewrite (sumList_filter_partition P (getSupport c)).

  rewrite ratSubtract_ratAdd_inverse.

  intuition.

  trivial.



  rewrite H3.

  rewrite ratMult_ratSubtract_distrib_r.

  rewrite ratMult_1_l.

  rewrite <- (ratMult_assoc (sumList (filter P (getSupport c)) (evalDist c))).

  rewrite (ratMult_comm (sumList (filter P (getSupport c)) (evalDist c))).

  rewrite ratInverse_prod_1.

  rewrite ratMult_1_l.

  rewrite ratSubtract_ratAdd_inverse_2.

  intuition.

  eapply leRat_trans.

  rewrite <- ratMult_1_l.

  eapply leRat_refl.

  eapply ratMult_leRat_compat; intuition.



  eapply ratInverse_1_swap.

  

  intuition.

  eapply sumList_0 in H4.

  eapply getSupport_In_evalDist.

  eapply filter_In.

  eapply H0.

  eapply H4.

  trivial.

  

  eapply leRat_trans.

  eapply sumList_filter_le.

  rewrite evalDist_lossless.

  intuition.

  trivial.

  

  intuition.

  eapply sumList_0 in H4.

  eapply getSupport_In_evalDist.

  eapply filter_In.

  eapply H0.

  eapply H4.

  trivial.



  unfold indicator.

  rewrite H1.

  rewrite ratMult_0_l.

  assert (sumList (filter P (getSupport c))

    (fun a0 : A => evalDist c a0 * (if comp_eq_dec c a0 a then 1 else 0)) == 0).

  eapply sumList_0.

  intuition.

  destruct (comp_eq_dec c a0 a); subst.

  assert (P a = true).

  eapply filter_In; eauto.

  congruence.

  eapply ratMult_0_r.

  rewrite H2.

  assert (sumList (filter (fun a0 : A => negb (P a0)) (getSupport c))

    (fun a0 : A =>

      evalDist c a0 *

      (0 * ratInverse (sumList (filter P (getSupport c)) (evalDist c)) *

        evalDist c a)) == 0).

  eapply sumList_0.

  intuition.

  repeat rewrite ratMult_0_l.

  eapply ratMult_0_r.

  rewrite H3.

  rewrite <- ratAdd_0_l.

  symmetry.

  eapply ratMult_0_l.

  

  assert (evalDist c a == 0).

  eapply getSupport_not_In_evalDist.

  trivial.

  rewrite H1.

  rewrite ratMult_0_r.

  symmetry.

  eapply sumList_0.

  intuition.

  case_eq (P a0); intuition.

  simpl.

  destruct (comp_eq_dec c a0 a); subst.

  intuition.

  eapply ratMult_0_r.

  simpl.

  rewrite H1.

  repeat rewrite ratMult_0_r.

  intuition.

Qed.



Lemma evalDet_steps_done_evalDist_h : forall (A : Set)(x y : comp_state A),

  evalDet_steps x y ->

  forall (eqd : eq_dec A)(c : Comp A) a a' s,

    x = (cs_more c nil) -> 

    y = (cs_done a s) -> 

    well_formed_comp c ->

    evalDist c a' == if (eqd a a') then 1 else 0.

  

  induction 1; intuition; subst.

  discriminate.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  

  eapply evalDet_step_done_evalDist; eauto.

  

  assert (s = nil).

  eapply evalDet_step_more_nil_inv.

  eauto.

  subst.

  rewrite <- IHevalDet_steps; eauto.

  erewrite evalDet_step_nil_dist_preserved; eauto.

  intuition.

  

  eapply evalDet_step_well_formed_comp_preserved;

    eauto.

  

Qed.

  

Lemma evalDet_steps_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,

  well_formed_comp c ->

  evalDet_steps (cs_more c nil) (cs_done a s) ->

  evalDist c a' == if (eqd a a') then 1 else 0.

  

  intuition.

  eapply evalDet_steps_done_evalDist_h; eauto.

Qed.



Definition lowDistApprox (A : Set)(c : Comp A)(a : A)(n : nat)(v : Rat) :=

  exists vals count,

    rel_map (evalDet c) (getAllBlists n) vals /\

    pred_count (eq (ca_done a)) vals count  /\

    v == (count / expnat 2 n).



Lemma map_Ret_repeat : forall (A : Set)(eqd : eq_dec A)(a : A) ls ls',

  rel_map (evalDet (Ret eqd a)) ls ls' ->

  ls' = listRepeat (ca_done a) (length ls).

  

  induction ls; inversion 1; intuition; subst; simpl in *.

  f_equal.

  inversion H4; clear H4; subst.

  inversion H0; clear H0; subst.

  simpl in *.

  inversion H6; clear H6; subst.

  trivial.

  

  inversion H0; clear H0; subst; simpl in *.

  inversion H6.

  

  inversion H; clear H; subst.

  eapply IHls.

  trivial.

Qed.



Theorem lowDistApprox_Ret_inv : forall (A : Set)(eqd : eq_dec A)(a a' : A) n v,

  lowDistApprox (Ret eqd a) a' n v ->

  v == (if (eqd a a') then 1 else 0).



  intuition.

  destruct H.

  destruct H.

  intuition. 



  specialize (map_Ret_repeat H0); intuition.

  subst.



  destruct (eqd a a'); subst.



  specialize (pred_count_listRepeat_eq_inv _ H); intuition.

  subst.

  rewrite H2.

  rewrite getAllBlists_length.

  eapply num_dem_same_rat1.

  trivial.



  specialize (@pred_count_listRepeat_ne_inv (length (getAllBlists n)) _ (ca_done a') (ca_done a) x0); intuition.

  rewrite H1 in H2.

  rewrite H2.

  apply rat_num_0.

  intuition.

  inversion H3.

  intuition.

  trivial.



Qed. 



Inductive lowDistApprox_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(a : A)(n : nat) : Rat -> Prop :=

| lda_b_intro : 

  forall v,

    sumList_rel (fun (b : B) r => forall r1 r2, lowDistApprox c1 b n r1 -> lowDistApprox (c2 b) a n r2 -> r == r1 * r2) (getSupport c1) v ->

    lowDistApprox_bind c1 c2  a n v.



Inductive DistApproxTree(A : Set) :=

| dat_leaf : option A -> DistApproxTree A

| dat_internal : DistApproxTree A -> DistApproxTree A -> DistApproxTree A.



Inductive dat_correct_h(A : Set)(c : Comp A)(s : Blist) : nat -> DistApproxTree A -> Prop :=

    | dat_correct_h_leaf_Some :

      forall a n, 

        evalDet c s (ca_done a) ->

        dat_correct_h c s n (dat_leaf (Some a))

    | dat_correct_h_leaf_None :

        (forall a, ~ evalDet c s (ca_done a)) ->

        dat_correct_h c s 0 (dat_leaf None)

    | dat_correct_h_internal :

      forall t1 t2 n, 

        (forall a, ~ evalDet c s (ca_done a)) ->

        dat_correct_h c (s ++ (true :: nil)) n t1 ->

        dat_correct_h c (s ++ (false :: nil)) n t2 ->

        dat_correct_h c s (S n) (dat_internal t1 t2).



Definition dat_correct(A : Set)(c : Comp A)(n : nat) :=

    dat_correct_h c nil n.



Lemma dat_correct_func : forall (A : Set)(c : Comp A) ls n t1,

  dat_correct_h c ls n t1 ->

  forall t2, 

    dat_correct_h c ls n t2 ->

    t1 = t2.

  

  induction 1; intuition.

  inversion H0; clear H0; subst.

  assert (ca_done a = ca_done a0).

  eapply evalDet_func; eauto.

  inversion H0.

  subst.

  trivial.

  specialize (H1 a).

  intuition.

  specialize (H1 a).

  intuition.

  

  inversion H0; clear H0; subst.

  specialize (H a).

  intuition.

  trivial.

  

  inversion H2; clear H2; subst.

  specialize (H a).

  intuition.

  f_equal; eauto.

Qed.



Fixpoint getTreeSupport_dups(A : Set)(t : DistApproxTree A) :=

  match t with

    | dat_leaf o =>

      match o with

        | None => nil

        | Some a => a :: nil

      end

    | dat_internal t1 t2 =>

      getTreeSupport_dups t1 ++ getTreeSupport_dups t2

  end.



Definition getTreeSupport(A : Set)(eqd : eq_dec A)(t : DistApproxTree A) : list A :=

  getUnique (getTreeSupport_dups t) eqd.



Lemma getTreeSupport_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n,

  dat_correct c n t ->

  forall a,

    In a (getTreeSupport eqd t) ->

    In a (getSupport c).

  

  induction 1; intuition; simpl in *.

  intuition; subst.

  eapply getSupport_In_evalDet; eauto.

  intuition.

  

  unfold getTreeSupport in *.

  eapply in_getUnique_if in H2.

  simpl in *.

  eapply in_app_or in H2.

  intuition.

  

  eapply IHdat_correct_h1.

  eapply in_getUnique.

  eauto.

  

  eauto using in_getUnique.

Qed.



Lemma getTreeSupport_not_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n a,

  dat_correct c n t ->

  ~In a (getSupport c) ->

  ~In a (getTreeSupport eqd t).

  

  intuition.

  eapply H0.

  eauto using getTreeSupport_in.

Qed.



Lemma dat_exists_h : forall n s (A : Set)(c : Comp A),

  well_formed_comp c ->

  exists t : DistApproxTree A,

    dat_correct_h c s n t.

  

  induction n; intuition.



  destruct (@evalDet_dec _ c s).

  trivial.

  destruct H0.

  exists (dat_leaf (Some x)).

  econstructor; eauto.

  exists (dat_leaf None).

  econstructor.

  intuition.



  eapply evalDet_done_eof_func; eauto.

  

  destruct (@evalDet_dec _ c s).

  trivial.

  destruct H0.

  exists (dat_leaf (Some x)).

  econstructor.

  trivial.

  

  destruct (IHn (s ++ (true :: nil)) _ c).

  trivial.

  destruct (IHn (s ++ (false :: nil)) _ c).

  trivial.

  exists (dat_internal x x0).

  econstructor; eauto.

  intuition.

  eapply evalDet_done_eof_func; eauto.

  

Qed.



Theorem dat_exists : forall n (A : Set)(c : Comp A),

  well_formed_comp c ->

  exists t : DistApproxTree A,

    dat_correct c n t.

  

  intuition.

  eapply dat_exists_h.

  trivial.

Qed.



Fixpoint lowDistApproxFromTree(A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(a : A) :=

  match t with

    | dat_leaf o =>

      match o with

        | None => 0

        | Some a' => if (eqd a a') then 1 else 0

      end

    | dat_internal t1 t2 =>

      (lowDistApproxFromTree eqd t1 a) * (1 / 2) + (lowDistApproxFromTree eqd t2 a) * (1 / 2)

  end.



Definition lowDistApprox_ls (A : Set)(c : Comp A) a n (ls : Blist) r :=

  exists vals count,

    rel_map (fun s v => (evalDet c (ls ++ s) v)) (getAllBlists n) vals /\

    pred_count (eq (ca_done a)) vals count /\

    count /expnat 2 n == r.



Lemma lowDistApprox_ls_impl : forall n (A : Set)(c : Comp A) a r,

  lowDistApprox c a n r ->

  lowDistApprox_ls c a n nil r.

  

  intuition.

  destruct H.

  destruct H.

  intuition.

  econstructor.

  econstructor. 

  intuition.

  simpl.

  eapply rel_map_eq.

  eapply H0.

  eauto.

  intuition.

  eauto.

  intuition.

Qed.



Lemma evalDet_lowDistApprox_ls_done_inv : forall (A : Set)(eqd : eq_dec A)(c : Comp A) s a1 a2 n r,

  evalDet c s (ca_done a1) ->

  lowDistApprox_ls c a2 n s r ->

  r == if (eqd a2 a1) then 1 else 0.

  

  intuition.

  destruct H0.

  destruct H0.

  intuition.

  

  destruct (eqd a2 a1); subst.

  rewrite <- H3.

  erewrite pred_count_eq_all_inv at 1.

  erewrite <- rel_map_length.

  rewrite getAllBlists_length.

  apply num_dem_same_rat1.

  unfold posnatToNat.

  unfold natToPosnat.

  eauto.

  eapply H1.

  eauto.

  

  intuition.

  

  eapply rel_map_unary_pred.

  eapply H1.

  intuition.

  

  eapply evalDet_app_eq in H.

  eapply evalDet_func; eauto.

  trivial.

  

  rewrite <- H3.

  erewrite pred_count_eq_0 at 1.

  apply rat_num_0.

  2:{

    eapply H1.

  }

  2:{

    eapply H0.

  }

  intuition.

  subst.

  eapply n0.

  assert (ca_done a1 = ca_done a2).

  eapply evalDet_func.

  eapply evalDet_app_eq.

  eauto.

  eauto.

  inversion H5.

  trivial.

  

Qed.

 

Lemma low_tree_approx_same_inv_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A) ls t,

  dat_correct_h c ls n t -> 

  forall a r, 

    lowDistApprox_ls c a n ls r ->

    lowDistApproxFromTree eqd t a == r.

  

  induction 1; intuition; simpl in *.

  

  symmetry.

  eapply evalDet_lowDistApprox_ls_done_inv; eauto.

  

  inversion H0; clear H0; subst.

  destruct H1; intuition.

  simpl in *.

  

  rewrite <- H3.

  erewrite pred_count_eq_0 at 1.

  apply eqRat_symm.

  apply rat_num_0.

  2:{

    eapply H1.

  }

  2:{

    eapply H0.

  }

  intuition.

  simpl in *.

  intuition.

  subst.

  rewrite app_nil_r in *.

  eapply H; eauto.

  

  destruct H2.

  destruct H2.

  intuition.

  simpl in *.

  

  apply rel_map_app_inv in H3.

  intuition.

  

  apply rel_map_map_inv in H4.

  apply rel_map_map_inv in H6.

  

  eapply (pred_count_first_skip) in H2.

  destruct H2.

  destruct H2.

  intuition.

  

  rewrite IHdat_correct_h1.

  2:{

    econstructor.

    econstructor.

    intuition.

    eapply rel_map_eq.

    eapply H4.

    trivial.

    intuition.

    rewrite <- app_assoc.

    simpl.

    trivial.

    eapply H3.

    eapply eqRat_refl.

  }

  

  rewrite IHdat_correct_h2.

  2:{

    econstructor.

    econstructor.

    intuition.

    eapply rel_map_eq.

    eapply H6.

    trivial.

    intuition.

    rewrite <- app_assoc.

    simpl.

    trivial.

    eapply H2.

    eapply eqRat_refl.

  }

  rewrite <- ratMult_distrib_r.

  rewrite <- ratAdd_den_same.

  rewrite H8.

  rewrite <- ratMult_num_den.

  rewrite mult_1_r.

  unfold posnatMult.

  unfold natToPosnat.

  rewrite <- H5.

  eapply eqRat_terms; trivial.

  unfold natToPosnat, posnatToNat.

  rewrite mult_comm.

  simpl.

  trivial.

Qed.    



Theorem low_tree_approx_same_inv : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) (a : A) r,

    dat_correct c n t -> 

    lowDistApprox c a n r ->

    lowDistApproxFromTree eqd t a == r.   



  intuition.

  eapply low_tree_approx_same_inv_h.

  eauto.

  

  eapply lowDistApprox_ls_impl.

  trivial.

  

Qed.



Theorem getSupport_not_In_lowDistApprox : forall n (A : Set)(c : Comp A)(a : A) r,

  ~In a (getSupport c) ->

  lowDistApprox c a n r ->

  r == 0.

  

  intuition.

  destruct H0.

  destruct H0.

  intuition.

  

  specialize (@pred_count_eq_0 (comp_answer A) Blist (getAllBlists n) x (evalDet c) (eq (ca_done a)) x0); intuition.

  rewrite H2 in H3.

  rewrite H3.

  apply rat_num_0.

  intuition.

  subst.

  

  eapply H.

  eapply getSupport_In_evalDet; eauto.

  trivial.

  trivial.

  

Qed.



Definition getSupport_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * (list A)) :=

  (map (fun b => (b , (getSupport (c2 b)))) (getSupport c1)).



Fixpoint flattenPair (A B : Type)(ls : list (A * list B)) :=

  match ls with

    | nil => nil

    | (a, ls_b) :: ls' =>

      (map (fun b => (a, b)) ls_b) ++ (flattenPair ls')

  end.



Theorem in_flattenPair : forall (A B : Type)(ls : list (A * (list B))) a b entryList,

  In (a, entryList) ls ->

  In b entryList ->

  In (a, b) (flattenPair ls).

  

  induction ls; intuition; simpl in *.

  

  intuition.

  inversion H1; clear H1; subst.

  eapply in_or_app.

  left.

  eapply in_map_iff.

  econstructor.

  intuition.

  

  eapply in_or_app.

  right.

  eapply IHls; eauto.

Qed.



Definition getSupport_bind_cp (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * A) :=

  flattenPair (getSupport_bind c1 c2).



Lemma In_getSupport_bind_cp : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) b a,

  In b (getSupport c1) ->

  In a (getSupport (c2 b)) ->

  In (b, a) (getSupport_bind_cp c1 c2).

  

  intuition.

  unfold getSupport_bind_cp, getSupport_bind.

 

  eapply in_flattenPair.

  eapply in_map_iff.

  econstructor; intuition.

  trivial.

  

Qed.



Lemma not_In_getSupport_bind_cp : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(c1 : Comp B)(c2 : B -> Comp A) b a,

  ~ In (b, a) (getSupport_bind_cp c1 c2) ->

  ~ In b (getSupport c1) \/ 

  ~ In a (getSupport (c2 b)).

  

  intuition.

  

  destruct (in_dec eqdb b (getSupport c1)); intuition.

  destruct (in_dec eqda a (getSupport (c2 b))); intuition.

  exfalso.

  eapply H.

  eapply In_getSupport_bind_cp; eauto.

Qed.



Instance length_getSupport_nz : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  nz (length (getSupport c)).

intuition.

econstructor.

eapply getSupport_length_nz.

trivial.

Qed.



Lemma evalDet_lowDistApprox_ls_done:

  forall (A : Set) (eqd : eq_dec A) (c : Comp A) (s : Blist) 

    (a1 a2 : A) (n : nat),

    evalDet c s (ca_done a1) ->

    lowDistApprox_ls c a2 n s (if eqd a2 a1 then 1 else 0).

  

  unfold lowDistApprox_ls.

  intuition.

  exists (listRepeat (ca_done a1) (length (getAllBlists n))).

  

  destruct (eqd a1 a2); subst.

  exists (length (getAllBlists n)).

  intuition.

  eapply rel_map_listRepeat.

  intuition.

  eapply evalDet_app_eq.

  trivial.

  

  eapply pred_count_eq_all; intuition.

  symmetry.

  eapply in_listRepeat_inv.

  eauto.

  rewrite listRepeat_length.

  trivial.

  destruct (eqd a2 a2); try congruence.

  rewrite getAllBlists_length.

  apply num_dem_same_rat1.

  unfold natToPosnat, posnatToNat.

  trivial.

  

  exists O.

  intuition.

  

  eapply rel_map_listRepeat.

  intuition.

  eapply evalDet_app_eq.

  trivial.

  

  eapply pred_count_eq_none; intuition.

  subst.

  assert (ca_done a2 = ca_done a1).

  eapply in_listRepeat_inv.

  eauto.

  inversion H1; subst; clear H1.

  intuition.

  

  destruct (eqd a2 a1); subst; try congruence.

  apply rat_num_0.

Qed.



Lemma evalDet_lowDistApprox_ls_not_done:

  forall (A : Set) (c : Comp A) (s : Blist) 

    (a2 : A) (n : nat),

    well_formed_comp c ->

    (forall s' (a : A), In s' (getAllBlists n) -> evalDet c (s ++ s') (ca_done a) -> False) ->

    lowDistApprox_ls c a2 n s 0.

  

  intuition.

  unfold lowDistApprox_ls.

  exists (listRepeat (@ca_eof A) (length (getAllBlists n))).

  exists O.

  intuition.

  eapply rel_map_listRepeat; intuition.

  destruct (@evalDet_dec _ c (s ++ a)).

  trivial.

  destruct H2.

  exfalso.

  eapply H0.

  eauto.

  eauto.

  trivial.

  

  eapply pred_count_eq_none; intuition.

  assert (a = (ca_eof A)).

  eapply in_listRepeat_inv.

  eauto.

  subst.

  discriminate.

  eapply rat_num_0.

  

Qed.



Lemma low_tree_approx_same_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) ls,

                                 dat_correct_h c ls n t ->

                                 forall a, 

                                   well_formed_comp c ->

                                   lowDistApprox_ls c a n ls (lowDistApproxFromTree eqd t a).

  

  induction 1; intuition; simpl in *.

  

  eapply evalDet_lowDistApprox_ls_done.

  trivial.

  

  eapply evalDet_lowDistApprox_ls_not_done.

  trivial.

  intuition.

  simpl in *.

  intuition.

  subst.

  rewrite app_nil_r in *.

  eauto.

  

  destruct (IHdat_correct_h1 a).

  trivial.

  destruct H3.

  

  destruct (IHdat_correct_h2 a).

  trivial.

  destruct H4.

  

  intuition.

  

  unfold lowDistApprox_ls.

  econstructor. econstructor.

  intuition.

  simpl.

  

  eapply rel_map_app.

  eapply rel_map_map.

  eapply rel_map_eq.

  eapply H5.

  trivial.

  intuition.

  rewrite <- app_assoc in H11.

  simpl in *.

  trivial.

  eapply rel_map_map.

  eapply rel_map_eq.

  eapply H3.

  trivial.

  intuition.

  rewrite <- app_assoc in H11.

  simpl in *.

  trivial.

  

  eapply pred_count_app; eauto.

  simpl.

  rewrite <- H8.

  rewrite <- H9.

  repeat rewrite <- ratMult_num_den.

  rewrite <- ratAdd_den_same.

  eapply eqRat_terms.

  repeat rewrite mult_1_r.

  trivial.

  unfold posnatMult, natToPosnat, posnatToNat.

  rewrite mult_comm.

  simpl.

  trivial.

Qed.



Theorem low_tree_approx_same : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A),

  well_formed_comp c ->

  dat_correct c n t -> 

  forall a, 

    lowDistApprox c a n (lowDistApproxFromTree eqd t a).

  

  intuition.

  

  unfold dat_correct in *.

  edestruct low_tree_approx_same_h.

  eauto.

  trivial.

  destruct H1.

  econstructor.

  econstructor.

  intuition.

  simpl in *.

  eauto.

  eauto.

  rewrite H4.

  eapply eqRat_refl.

  

Qed.



Lemma lowDistApprox_left_total : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a,

  well_formed_comp c ->

  left_total (lowDistApprox c a).

  

  unfold left_total.

  intuition.

  

  destruct (@dat_exists n _ c).

  trivial.

  exists (lowDistApproxFromTree eqd x a).

  eapply low_tree_approx_same.

  trivial.

  trivial.

Qed.



Inductive datMap(A B : Set)(f : A -> DistApproxTree B -> Prop) : DistApproxTree A -> DistApproxTree B  -> Prop :=

| datMap_leaf_None :

    datMap f (dat_leaf None) (dat_leaf None)

| datMap_leaf_Some : 

  forall a t,

    f a t ->

    datMap f (dat_leaf (Some a)) t

| datMap_internal : 

  forall t1a t2a t1b t2b,

    datMap f t1a t1b ->

    datMap f t2a t2b ->

    datMap f (dat_internal t1a t2a) (dat_internal t1b t2b).



Inductive datMap_depth(A B : Set)(f : nat -> A -> DistApproxTree B -> Prop) : nat -> DistApproxTree A -> DistApproxTree B -> Prop :=

| datMap_depth_leaf_None :

  forall n, 

    datMap_depth f n (dat_leaf None) (dat_leaf None)

| datMap_depth_leaf_Some :

  forall n a t,

    f n a t ->

    datMap_depth f n (dat_leaf (Some a)) t

| datMap_depth_internal :

  forall n t1a t2a t1b t2b,

    datMap_depth f n t1a t1b ->

    datMap_depth f n t2a t2b ->

    datMap_depth f (S n) (dat_internal t1a t2a) (dat_internal t1b t2b).



Definition dat_correct_bind(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=

  exists tb, dat_correct c1 n tb /\

    (datMap_depth (fun n' b ta => (dat_correct (c2 b) n' ta)) n tb t).



Definition dat_correct_bind2(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=

  exists tb, dat_correct c1 n tb /\

    (datMap (fun b ta => (dat_correct (c2 b) n ta)) tb t).



Lemma lowDistApproxFromTree_eq_0 : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,

  ~In a (getTreeSupport eqd t) ->

  lowDistApproxFromTree eqd t a == 0.

  

  induction t; intuition; simpl in *.

  destruct o.

  

  destruct (eqd a a0); subst.

  exfalso.

  eapply H.

  simpl.

  intuition.

  intuition.

  intuition.

  

  rewrite IHt1.

  rewrite IHt2.

  rewrite ratMult_0_l.

  rewrite <- ratAdd_0_r.

  intuition.

  

  intuition.

  eapply H.

  unfold getTreeSupport in *.

  simpl.

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.

  

  intuition.

  eapply H.

  unfold getTreeSupport in *.

  simpl.

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.

  

Qed.



Lemma lowDistApproxFromTree_datMap_inv : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(tb : DistApproxTree B)(ta : DistApproxTree A)(mapRel : B -> DistApproxTree A -> Prop),

  datMap mapRel tb ta ->

  (forall b, In b (getTreeSupport eqdb tb) -> exists t,  mapRel b t) ->

  (forall b t1 t2, mapRel b t1 -> mapRel b t2 -> t1 = t2) -> 

  forall a r, 

    sumList_rel 

    (fun b r' => 

      forall ta', mapRel b ta' ->  

        lowDistApproxFromTree eqdb tb b * lowDistApproxFromTree eqda ta' a == r')

    (getTreeSupport eqdb tb)

    r ->

    lowDistApproxFromTree eqda ta a == r.

  

  induction 1; intuition; simpl in *.

  

  apply sumList_rel_all_0_inv in H1;

    intuition.

  simpl in *.

  intuition.



  eapply sumList_rel_only_one_inv in H2.

  rewrite H2.

  eapply eqRat_refl.

  unfold getTreeSupport.

  simpl.

  eauto.

  unfold getTreeSupport.

  simpl.

  econstructor.

  intuition.

  econstructor.

  intuition.

  simpl in *.

  intuition.



  intuition.

  rewrite <- H3.

  destruct (eqdb a a); intuition.

  rewrite ratMult_1_l.

  eapply eqRat_refl.

  intuition.

  trivial.



  unfold getTreeSupport in *.

  simpl in *.

  assert (sumList_rel

    (fun (b : B) (r' : Rat) =>

      forall ta' : DistApproxTree A,

        mapRel b ta' ->

        ((lowDistApproxFromTree eqdb t1a b * (1 / 2) * lowDistApproxFromTree eqda ta' a) +

          (lowDistApproxFromTree eqdb t2a b * (1 / 2) * lowDistApproxFromTree eqda ta' a) 

          == r'))

    (getUnique (getTreeSupport_dups t1a ++ getTreeSupport_dups t2a) eqdb)

    r).

  

  eapply sumList_rel_body_eq.

  eapply H3.

  intuition.

  rewrite <- ratMult_distrib_r.

  eapply H4; eauto.

  intuition.

  trivial.

  clear H3.

  

  remember (fun b r' => forall ta', 

    (mapRel b ta' -> lowDistApproxFromTree eqdb t1a b * lowDistApproxFromTree eqda ta' a == r')) as rel1.

  remember (fun b r' => forall ta', 

    (mapRel b ta' -> lowDistApproxFromTree eqdb t2a b * lowDistApproxFromTree eqda ta' a == r')) as rel2.

  

  edestruct (sumList_rel_left_total rel1).

  intuition.

  destruct (H1 a0).

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eapply H3.

  exists (lowDistApproxFromTree eqdb t1a a0 * lowDistApproxFromTree eqda x a).

  subst.

  intuition.

  assert (x = ta').

  eauto.

  subst.

  intuition.

  

  edestruct (sumList_rel_left_total rel2).

  intuition.

  subst.

  destruct (H1 a0).

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eapply H5.

  exists (lowDistApproxFromTree eqdb t2a a0 * lowDistApproxFromTree eqda x0 a).

  intuition.

  assert (x0 = ta').

  eauto.

  subst.

  intuition.



  rewrite IHdatMap1; subst; eauto.

  rewrite IHdatMap2; subst; eauto.



  assert (sumList_rel

    (fun (b : B) (r' : Rat) =>

      forall ta' : DistApproxTree A,

        mapRel b ta' ->

        lowDistApproxFromTree eqdb t1a b * lowDistApproxFromTree eqda ta' a ==

        r' * (2/1)) (getUnique (getTreeSupport_dups t1a) eqdb) (x * (1/2))).

  eapply (sumList_rel_factor_constant (pos 1) (pos 2)).

  eapply sumList_rel_body_eq.

  eapply H3.

  intuition.

  specialize (H6 ta').

  rewrite H6.

  intuition.

  rewrite ratMult_assoc.

  rewrite <- ratMult_1_r at 1.

  eapply ratMult_eqRat_compat; intuition.

  rewrite <- ratMult_num_den.

  symmetry.

  eapply num_dem_same_rat1.

  unfold posnatMult, posnatToNat, natToPosnat.

  trivial.

  trivial.

  rewrite ratMult_assoc.

  rewrite <- ratMult_1_r at 1.

  eapply ratMult_eqRat_compat; intuition.

  rewrite <- ratMult_num_den.

  symmetry.

  eapply num_dem_same_rat1.

  trivial.

  trivial.

  

  clear H3.



  assert (sumList_rel

    (fun (b : B) (r' : Rat) =>

      forall ta' : DistApproxTree A,

        mapRel b ta' ->

        lowDistApproxFromTree eqdb t2a b * lowDistApproxFromTree eqda ta' a ==

        r' * (2/1)) (getUnique (getTreeSupport_dups t2a) eqdb) (x0 * (1/2))).

  eapply (sumList_rel_factor_constant (pos 1) (pos 2)).

  eapply sumList_rel_body_eq.

  eapply H5.

  intuition.

  specialize (H3 ta').

  intuition.

  rewrite H8.

  rewrite ratMult_assoc.

  rewrite <- ratMult_1_r at 1.

  eapply ratMult_eqRat_compat; intuition.

  rewrite <- ratMult_num_den.

  symmetry.

  eapply num_dem_same_rat1.

  unfold posnatMult, posnatToNat, natToPosnat.

  trivial.

  rewrite ratMult_assoc.

  rewrite <- ratMult_1_r at 1.

  eapply ratMult_eqRat_compat; intuition.

  rewrite <- ratMult_num_den.

  symmetry.

  eapply num_dem_same_rat1.

  trivial.

  trivial.



  clear H5.

  

  assert (sumList_rel

    (fun (b : B) (r' : Rat) =>

      forall ta' : DistApproxTree A,

        mapRel b ta' ->

        lowDistApproxFromTree eqdb t1a b * lowDistApproxFromTree eqda ta' a ==

        r' * (2 / 1)) (getUnique (getTreeSupport_dups t1a ++ getTreeSupport_dups t2a) eqdb)

    (x * (1 / 2))).



  eapply sumList_rel_ls_intersect.

  eapply H6.

  eapply getUnique_NoDup.

  eapply getUnique_NoDup.

  trivial.



  intuition.

  destruct (H1 a0). 

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.



  assert (r1 * (2/1) == r2 * (2/1)).

  rewrite <- H7.

  rewrite <- H8.

  eapply eqRat_refl.

  eauto.

  eauto.

  

  eapply ratMult_same_r_inv.

  eauto.

  intuition.



  intuition.

  exfalso.

  eapply H7.

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.

  

  intuition.

  rewrite ratMult_0_l.

  eapply ratMult_0.

  left.



  eapply lowDistApproxFromTree_eq_0.

  unfold getTreeSupport.

  intuition.

  

  clear H6.

  

  assert (sumList_rel

    (fun (b : B) (r' : Rat) =>

      forall ta' : DistApproxTree A,

        mapRel b ta' ->

        lowDistApproxFromTree eqdb t2a b * lowDistApproxFromTree eqda ta' a ==

        r' * (2 / 1)) (getUnique (getTreeSupport_dups t1a ++ getTreeSupport_dups t2a) eqdb)

    (x0 * (1 / 2))).

  

  eapply sumList_rel_ls_intersect.

  eapply H3.

  eapply getUnique_NoDup.

  eapply getUnique_NoDup.

  trivial.

  

  intuition.

  destruct (H1 a0).

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.



  assert (r1 * (2/1) == r2 * (2/1)).

  rewrite <- H7.

  rewrite <- H8.

  eapply eqRat_refl.

  eauto.

  trivial.

  

  eapply ratMult_same_r_inv.

  eauto.

  intuition.

  

  intuition.

  exfalso.

  eapply H7.

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.

  

  intuition.

  rewrite ratMult_0_l.

  eapply ratMult_0.

  left.

  eapply lowDistApproxFromTree_eq_0.

  intuition.

  

  clear H3.

 

  symmetry.

  eapply sumList_rel_plus_inv.

  3:{

    eapply H5.

  }

  3:{

    eapply H6.

  }

  eapply H4.

  intuition.

  destruct (H1 a0).

  trivial.

  rewrite <- H7; eauto.

  specialize (H8 _ H10).

  specialize (H9 _ H10).

  eapply ratMult_inverse_nat in H8.

  eapply ratMult_inverse_nat in H9.

  eapply ratAdd_eqRat_compat.

  

  rewrite ratMult_assoc.

  rewrite (ratMult_comm (1/2)).

  rewrite <- ratMult_assoc.

  eapply H8.

  

  rewrite ratMult_assoc.

  rewrite (ratMult_comm (1/2)).

  rewrite <- ratMult_assoc.

  eauto.



  intuition.

  destruct (H1 b).

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.

  econstructor.

  eauto.



  intuition.

  destruct (H1 b).

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.

  econstructor.

  eauto.

Qed.



Lemma getTreeSupport_approx_0: forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,

  ~In a (getTreeSupport eqd t) ->

  lowDistApproxFromTree eqd t a == 0.

  

  induction t; intuition; simpl in *.

  destruct o.

  simpl in *.

  intuition.

  destruct (eqd a a0); subst; intuition.

  intuition.

  

  rewrite IHt1.

  rewrite IHt2.

  rewrite ratMult_0_l.

  rewrite <- ratAdd_0_r.

  intuition.

  

  intuition.

  eapply H.

  unfold getTreeSupport in *.

  eapply in_getUnique.

  simpl.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.

  

  intuition.

  eapply H.

  unfold getTreeSupport in *.

  eapply in_getUnique.

  simpl.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.

  

Qed.



Lemma lowDistApprox_le_1 : forall (A : Set)(c : Comp A) a n r,

  lowDistApprox c a n r ->

  r <= 1.

  

  intuition.

  unfold lowDistApprox in *.

  destruct H.

  destruct H.

  intuition.

  rewrite H2.

  eapply rat_le_1.

  

  eapply le_trans.

  eapply pred_count_le_length.

  eapply H.

  

  erewrite <- rel_map_length; eauto.

  rewrite getAllBlists_length.

  rattac.

Qed.



Theorem bind_low_tree_approx_same_inv : forall (A B : Set)(eqda : eq_dec A)(c1 : Comp B)(c2 : B -> Comp A) n a t r,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b))->

  lowDistApprox_bind c1 c2 a n r ->

  dat_correct_bind2 c1 c2 n t ->

  r == lowDistApproxFromTree eqda t a.

  

  intuition.

  

  destruct H2. 

  intuition.

  inversion H1; clear H1; subst. 

  unfold dat_correct in *.

  symmetry.

  eapply lowDistApproxFromTree_datMap_inv; intuition.

  eapply H4.

  destruct (@dat_exists n _ (c2 b)).

  eapply H0.

  eapply getTreeSupport_in.

  eauto.

  eauto.

  econstructor.

  eauto.

  

  simpl in *.

  eapply dat_correct_func; eauto.

  

  eapply sumList_rel_ls_intersect.

  eapply sumList_rel_body_eq_strong.

  eapply H2.

  intuition.

  erewrite H5.

  eapply eqRat_refl.

  

  eapply low_tree_approx_same.

  trivial.

  eapply H3.

  eapply low_tree_approx_same.

  eapply H0.

  eapply H1.

  eapply H6.

  intuition.

  eauto.

  

  eapply getSupport_NoDup.

  eapply getUnique_NoDup.

  eapply comp_eq_dec; eauto.

  

  intuition.

  destruct (@dat_exists n _ (c2 a0)).

  eapply H0.

  trivial.

  rewrite <- H5.

  rewrite H6.

  intuition.

  eauto.

  eauto.

  

  intuition.

  eapply ratMult_0.

  left.

  

  eapply getTreeSupport_approx_0.

  eauto.

  

  intuition.

  eapply ratMult_0.

  left.

  eapply getTreeSupport_approx_0.

  intuition.

  eapply H5.

  eapply getTreeSupport_in; eauto.

  

  Grab Existential Variables.

  eapply comp_eq_dec; eauto.

Qed.



Lemma in_flattenPair_inv : forall (A B : Set)(ls : list (A * list B)) a b,

  In (a, b) (flattenPair ls) ->

  exists lsb,

    In b lsb /\ In (a , lsb) ls.

  

  induction ls; intuition; simpl in *.

  intuition.

  

  apply in_app_or in H.

  intuition.

  apply in_map_iff in H0.

  destruct H0.

  intuition.

  inversion H0; clear H0; subst.

  econstructor.

  split.

  eauto.

  left.

  trivial.

  

  edestruct IHls.

  eauto.

  intuition.

  econstructor.

  split.

  eauto.

  right.

  trivial.

Qed.



Lemma in_getSupport_bind_cp_fst : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a0,

  In a0 (getSupport_bind_cp c1 c2) -> 

  In (fst a0) (getSupport c1).

  

  intuition.

  unfold getSupport_bind_cp, getSupport_bind in *.

  

  destruct a0.

  eapply in_flattenPair_inv in H.

  destruct H.

  intuition.

  simpl.

  eapply in_map_iff in H1.

  destruct H1.

  intuition.

  inversion H1; clear H1; subst.

  trivial.

  

Qed.



Lemma lowDistApprox_bind_evalDist_limit : forall (A B :Set)(c1 : Comp B)(c2 : B -> Comp A) a,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->

  (forall (a : B),

    rat_inf_limit (lowDistApprox c1 a) (evalDist c1 a)) ->

  (forall (b : B) (a : A),

    In b (getSupport c1) ->

    rat_inf_limit (lowDistApprox (c2 b) a) (evalDist (c2 b) a)) ->

  rat_inf_limit (lowDistApprox_bind c1 c2 a) (evalDist (Bind c1 c2) a).

  

  unfold rat_inf_limit, inf_limit.

  intuition.

  

  assert (forall (epsilon : Rat),

    ~ epsilon == 0 ->

    exists n : nat,

      forall n': nat,

        n' >= n -> 

        (forall (b : B) r,

          lowDistApprox c1 b n' r ->

          (ratDistance r (evalDist c1 b)) <= epsilon)).

  

  assert (forall (epsilon : Rat),

    (epsilon == 0 -> False) ->

    forall (a : B),

      exists n : nat,

        forall n' : nat,

          n' >= n -> 

          forall r,

            lowDistApprox c1 a n' r ->

            (ratDistance r (evalDist c1 a) <= epsilon)).

  

  intuition.

  intuition.

  specialize (H4 _ H5).



  edestruct (rel_map_left_total _ (getSupport c1) H4).



  Local Open Scope rat_scope.



  econstructor.

  intuition.

  

  assert (n' >= (maxList x)).

  eapply H7.



  edestruct (in_dec (comp_eq_dec c1) b (getSupport c1)).

  edestruct (rel_map_in_inv H6); eauto.

  intuition.

  eapply H12.



  eapply le_trans.

  eapply maxList_correct; eauto.

  eauto.

  trivial.



  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply (ratIdentityIndiscernables r).  

  eapply eqRat_trans.

  eapply getSupport_not_In_lowDistApprox; eauto.

  eapply eqRat_symm.

  eapply getSupport_not_In_evalDist; eauto.

  eapply rat0_le_all.



  clear H1.



  assert (forall (epsilon : Rat),

      ~ epsilon == 0 ->

      exists n : nat,

        forall n' : nat,

          n' >= n ->

          (forall a b r,

            In b (getSupport c1) ->

            lowDistApprox (c2 b) a n' r ->

            (ratDistance r (evalDist (c2 b) a)) <= epsilon)).



  assert (forall (epsilon : Rat),

    (epsilon == 0 -> False) ->

    forall (x : (B * A)),

      In (fst x) (getSupport c1) ->

      exists n : nat,

        forall n' : nat,

          n' >= n -> 

          forall r,

            lowDistApprox (c2 (fst x)) (snd x) n' r -> 

            (ratDistance r (evalDist (c2 (fst x)) (snd x)) <= epsilon)).



  intuition.



  intuition.

  specialize (H1 epsilon0).

  intuition.

  edestruct (@rel_map_left_total_strong' _ nat (getSupport_bind_cp c1 c2) (fun y => In (fst y) (getSupport c1)) (fun x n => forall n',

         n' >= n ->

         forall r : Rat,

         lowDistApprox (c2 (fst x)) (snd x) n' r ->

         (ratDistance r (evalDist (c2 (fst x)) (snd x))) <= epsilon0)).

  eapply H6.



  eapply in_getSupport_bind_cp_fst.



  exists (maxList x).

  intuition.

  edestruct (in_dec (EqDec_dec (pair_EqDec (comp_EqDec c1) (bind_EqDec c1 c2))) (b, a0) (getSupport_bind_cp c1 c2)).

  edestruct (rel_map_in_inv H1); eauto.

  intuition.

  simpl in *.

  eapply H12.

  eapply le_trans.

  eapply maxList_correct; eauto.

  eauto.

  trivial.



  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply (ratIdentityIndiscernables r).

  apply not_In_getSupport_bind_cp in n.

  edestruct n.

  intuition.



  eapply eqRat_trans.

  eapply getSupport_not_In_lowDistApprox; eauto.

  eapply eqRat_symm.

  eapply getSupport_not_In_evalDist; eauto.

  eauto.

  eapply comp_eq_dec; eauto.

  eapply bind_eq_dec; eauto.

  eapply rat0_le_all.



  clear H2.



  assert (nz (length (getSupport c1))).

  econstructor.

  eapply getSupport_length_nz.

  trivial.



  specialize (H4 ((1 / 3 ) * (epsilon * (RatIntro 1 (natToPosnat H2))))).

  specialize (H1 ((1 / 3 ) * (epsilon * (RatIntro 1 (natToPosnat H2))))).

  

  edestruct H4.

  eapply ratMult_nz;

  econstructor.

  rattac.

  eapply ratMult_nz; econstructor; intuition.

  clear H4.

  

  edestruct H1.

  eapply ratMult_nz; econstructor.

  rattac.

  eapply ratMult_nz; econstructor; intuition.

  clear H1.



  exists (max x x0).

  intuition.



  inversion H6; clear H6; subst.



  eapply (@leRat_trans _ (epsilon * (RatIntro 1 (natToPosnat H2)) * (length (getSupport c1) / 1))).



  simpl.

  eapply sumList_rel_distance; eauto.

  intuition.



  2:{

    eapply sumList_rel_sumList.

  }

  simpl in *.

  subst.



  assert (well_formed_comp (c2 a0)).

  eapply H0.

  trivial.



  destruct (@lowDistApprox_left_total _ (comp_eq_dec c1) c1 a0 H n').

  destruct (@lowDistApprox_left_total _ (bind_eq_dec c1 c2) (c2 a0) a H9 n').



  erewrite H8; eauto.



  eapply leRat_trans.

  eapply ratDistance_ratMult_le.



  eapply H5.

  eapply Max.max_lub_l.

  eapply H1.

  trivial.

  eapply H4.

  eapply Max.max_lub_r.

  eapply H1.

  trivial.

  trivial.

  

  eapply lowDistApprox_le_1; eauto.

  eapply lowDistApprox_le_1; eauto.



  eapply evalDist_le_1.

  eapply evalDist_le_1.



  rewrite <- ratMult_assoc.

  rewrite <- ratMult_num_den.



  rewrite num_dem_same_rat1.

  rewrite ratMult_1_l.

  eapply leRat_refl.

  unfold posnatMult, natToPosnat, posnatToNat.

  trivial.



  rewrite ratMult_assoc.

  rewrite ratMult_comm.

  rewrite <- ratMult_num_den.

  rewrite num_dem_same_rat1.

  rewrite ratMult_1_l.

  eapply leRat_refl.

  unfold posnatMult, natToPosnat, posnatToNat.

  rewrite mult_comm.

  trivial.



Qed.



Lemma datMap_left_total : forall (A B : Set)(eqdb : eq_dec A)(t : DistApproxTree A)(f : A -> DistApproxTree B -> Prop),

  (forall a, In a (getTreeSupport eqdb t) -> exists b, f a b) ->

  exists t',

    datMap f t t'.

  

  induction t; intuition; simpl in *.

  destruct o.

  destruct (H a).

  simpl.

  intuition.

  econstructor.

  econstructor.

  eauto.

  

  econstructor.

  econstructor.

  

  edestruct IHt1; eauto.

  intuition.

  edestruct H.

  unfold getTreeSupport in *.

  simpl in *.

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eauto.

  econstructor; eauto.



  edestruct IHt2; eauto.

  intuition.

  edestruct H.

  unfold getTreeSupport in *.

  simpl in *.

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eauto.

  econstructor; eauto.



  econstructor.

  econstructor; eauto.

  

Qed.

    

Lemma dat_exists_bind2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->

  exists t, dat_correct_bind2 c1 c2 n t.

  

  intuition.

  destruct (@dat_exists n _ c1).

  trivial.

  edestruct (@datMap_left_total B A (comp_eq_dec c1) x).

  2:{

    econstructor.

    econstructor.

    intuition.

    eauto.

    eauto.

  }



  intuition.

  destruct (@dat_exists n _ (c2 a)).

  eapply H0.

  eapply getTreeSupport_in.

  eauto.

  eauto.

  econstructor.

  eauto.

  

Qed.



Inductive dat_better(A : Set) : DistApproxTree A -> DistApproxTree A -> Prop :=

| dat_better_leaf_None : forall t,

  dat_better t (dat_leaf None)

| dat_better_leaf_Some : forall a,

  dat_better (dat_leaf (Some a)) (dat_leaf (Some a))

| dat_better_internal : forall ta1 ta2 tb1 tb2,

  dat_better ta1 tb1 ->

  dat_better ta2 tb2 ->

  dat_better (dat_internal ta1 ta2) (dat_internal tb1 tb2).



Hint Constructors dat_better : dat.



Lemma dat_better_refl : forall (A : Set)(t : DistApproxTree A),

  dat_better t t.

  

  induction t; intuition.

  destruct o; econstructor.

Qed.



Lemma dat_better_trans : forall (A : Set)(t1 t2 : DistApproxTree A),

  dat_better t1 t2 ->

  forall t3, 

    dat_better t2 t3 ->

    dat_better t1 t3.

  

  induction 1; intuition.

  inversion H; clear H; subst; eauto with  dat.

  inversion H1; clear H1; subst.

  econstructor.

  econstructor; eauto.

Qed.



Lemma dat_correct_dat_better : forall (A : Set)(c : Comp A) ls n1 t1,

  dat_correct_h c ls n1 t1 ->

  forall n2 t2,

    dat_correct_h c ls n2 t2 ->

    n1 >= n2 ->

    dat_better t1 t2.

  

  induction 1; intuition.

  

  inversion H0; clear H0; subst.

  assert (ca_done a = ca_done a0).

  eapply evalDet_func; eauto.

  inversion H0.

  econstructor.

  econstructor.

  specialize (H2 a).

  intuition.

  

  inversion H0; clear H0; subst.

  specialize (H a).

  intuition.

  econstructor.

  omega.

  

  inversion H2; clear H2; subst.

  specialize (H a).

  intuition.

  econstructor.

  assert (n >= n0).

  omega.

  eauto with dat.

Qed.



Lemma lowDistApprox_dat_better_le : forall (A : Set)(eqd : eq_dec A)(t1 t2 : DistApproxTree A),

  dat_better t1 t2 ->

  forall (a : A), 

    lowDistApproxFromTree eqd t2 a <= lowDistApproxFromTree eqd t1 a.

  

  induction 1; intuition; simpl in *.

  apply rat0_le_all.

  rewrite <- IHdat_better1.

  rewrite <- IHdat_better2.

  eapply leRat_refl.

Qed.



Lemma datMap_better : forall (A B : Set)(t : DistApproxTree B) n (rel : nat -> B -> DistApproxTree A -> Prop) t1 t2,

  (forall n b t1 t2, rel n b t1 -> rel (pred n) b t2 -> dat_better t1 t2) ->

  datMap (rel n) t t1 ->

  datMap (rel (pred n)) t t2 ->

  dat_better t1 t2.

  

  induction t; intuition; simpl in *.

  inversion H0; clear H0; subst.

  inversion H1; clear H1; subst.

  econstructor.

  inversion H1; clear H1; subst.

  eapply H; eauto.

  

  inversion H0; clear H0; subst.

  inversion H1; clear H1; subst.

  econstructor; eauto.

  

Qed.



Lemma datMap_depth_better : forall (A B : Set)(tb1 tb2 : DistApproxTree B),

  dat_better tb1 tb2 ->

  forall  n1 n2 (f : nat -> B -> DistApproxTree A -> Prop) t1 t2,

    (forall n1 n2 b t1 t2, n1 >= n2 -> f n1 b t1 -> f n2 b t2 -> dat_better t1 t2) ->

    datMap (f n1) tb1 t1 ->

    datMap_depth f n2 tb2 t2 ->

    n1 >= n2 ->

    dat_better t1 t2.

  

  induction 1; intuition; simpl in *.

  inversion H1; clear H1; subst.

  econstructor.

  

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  eauto.

  

  inversion H2; clear H2; subst.

  inversion H3; clear H3; subst.

  econstructor.

  eapply IHdat_better1; eauto; omega.

  eapply IHdat_better2; eauto; omega.

Qed.



Lemma dat_bind_2_better : forall (n : nat) (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1 t2,

  dat_correct_bind2 c1 c2 n t1 ->

  dat_correct_bind c1 c2 n t2 ->

  dat_better t1 t2.

  

  intuition.

  unfold dat_correct_bind, dat_correct_bind2 in *.

  destruct H.

  destruct H0.

  

  intuition.

  eapply datMap_depth_better.

  4:{

    eauto.

  }

  3:{

    simpl.

    eauto.

  }



  eapply dat_correct_dat_better; eauto.

  

  intuition.

  eapply dat_correct_dat_better; eauto.

  omega.

Qed.



Lemma dat_correct_h_bind_app : forall (A B : Set) t (c1 : Comp B)(c2 : B -> Comp A) n ls1 ls2 a,

  evalDet_steps (cs_more c1 ls1) (cs_done a nil) ->

  dat_correct_h (Bind c1 c2) (ls1 ++ ls2) n t ->

  dat_correct_h (c2 a) ls2 n t.

  

  induction t; intuition; simpl in *.

  inversion H0; clear H0; subst.

  inversion H3; clear H3; subst.

  apply evalDet_steps_bind_done_inv in H1.

  destruct H1. destruct H0.

  intuition.

  assert (evalDet_steps (cs_more c1 (ls1 ++ ls2)) (cs_done a (nil ++ ls2))).

  eapply evalDet_steps_app_eq.

  eauto.

  simpl in *.

  specialize (evalDet_steps_done_func H1 H0); intuition; subst.

  econstructor.

  econstructor.

  eauto.

  

  econstructor.

  intuition.

  inversion H0; clear H0; subst.

  eapply H3.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eapply evalDet_steps_app_eq.

  eauto.

  simpl.

  eauto.

  

  inversion H0; clear H0; subst.

  econstructor.

  intuition.

  inversion H0; clear H0; subst.

  eapply H3.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eapply evalDet_steps_app_eq.

  eauto.

  simpl.

  eauto.

  

  eapply IHt1.

  eauto.

  rewrite app_assoc.

  eauto.

  eapply IHt2.

  eauto.

  rewrite app_assoc.

  eauto.

      

Qed.



Lemma dat_correct_bind_same_h : forall n (A : Set)(c : Comp A) ls t,

  dat_correct_h c ls n t ->

  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1,

    c = Bind c1 c2 ->

    well_formed_comp c1 ->

    (forall a ls', evalDet_steps (cs_more c1 ls) (cs_done a ls') -> ls' = nil) -> 

    dat_correct_h c1 ls n t1 ->  

    datMap_depth

    (fun (depth : nat) (b : B) t2 => dat_correct_h (c2 b) nil depth t2) 

    n t1 t.

  

  induction 1; intuition; subst; simpl in *.

  inversion H; clear H; subst. 

  inversion H3; clear H3; subst. 

  inversion H; clear H; subst. 

  apply evalDet_steps_bind_done_inv in H4.

  destruct H4. destruct H. intuition.



  econstructor.

  econstructor.

  specialize (evalDet_steps_done_func H3 H0); intuition; subst.

  assert (x0 = nil); eauto; subst.

  econstructor.

  eauto.

  

  apply evalDet_steps_bind_done_inv in H4.

  destruct H4. destruct H0. intuition.

  exfalso.

  eapply H.

  econstructor. 

  eauto.

  apply evalDet_steps_bind_done_inv in H4.

  destruct H4. destruct H3. intuition.

  exfalso.

  eapply H.

  econstructor. 

  eauto.

  

  inversion H3; clear H3; subst.

  inversion H0; clear H0; subst.

  econstructor.

  econstructor.

  intuition.

  inversion H0; clear H0; subst.

  assert (s' = nil); eauto; subst.

  eapply H.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.      

  eauto.

  eauto.

  

  econstructor.

  

  inversion H5; clear H5; subst.

  inversion H2; clear H2; subst.

  assert (s' = nil); eauto; subst.

  econstructor.

  econstructor.

  intuition.

  inversion H2; clear H2; subst.

  eapply H.

  econstructor.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  eauto.

  simpl.  



  eapply dat_correct_h_bind_app; eauto.

  eapply dat_correct_h_bind_app; eauto.



  econstructor.

  eapply IHdat_correct_h1; eauto.

  intuition.

  

  eapply evalDet_app_nil; eauto.

  edestruct (@evalDet_dec _ c1 s); trivial.

  destruct H5.

  exfalso. 

  eauto.

  

  eapply IHdat_correct_h2; eauto.

  intuition.

  eapply evalDet_app_nil; eauto.

  edestruct (@evalDet_dec _ c1 s); trivial.

  destruct H5.

  exfalso.

  eauto.

Qed.



Lemma lowDistApprox_le_bind : forall n (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a r1 r2,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->

  lowDistApprox (Bind c1 c2) a n r1 -> 

  lowDistApprox_bind c1 c2 a n r2 ->

  r1 <= r2.

  

  intuition.

  edestruct dat_exists_bind2.

  eauto.

  eauto.

  eapply leRat_trans.

  2:{

    eapply eqRat_impl_leRat.

    symmetry.

    eapply (bind_low_tree_approx_same_inv).

    eauto.

    eauto.

    eauto.

    eauto.

  }



  edestruct dat_exists.

  eapply well_formed_Bind; eauto.



  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  symmetry.

  eapply low_tree_approx_same_inv.

  eauto.

  eauto.

  

  apply lowDistApprox_dat_better_le.

  

  inversion H3; clear H3; subst.

  intuition.

  eapply datMap_depth_better.

  4:{

    eapply dat_correct_bind_same_h.

    eapply H4.

    eauto.

    trivial.

    intuition.

    eapply evalDet_steps_done_nil_inv; eauto.

    eauto.

  }



  eapply dat_better_refl.

  intuition.

  eapply dat_correct_dat_better.

  eapply H7.

  eapply H8.

  trivial.

  eapply H6.

  auto.

  

  Grab Existential Variables.

  eapply bind_eq_dec; eauto.

  

Qed.



Lemma dat_correct_bind_same: forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t,

  well_formed_comp c1 ->

  dat_correct (Bind c1 c2) n t ->

  dat_correct_bind c1 c2 n t.

  

  intuition.

  unfold dat_correct_bind in *.

  edestruct (dat_exists).

  eauto.

  econstructor.

  intuition.

  eauto.

  eapply dat_correct_bind_same_h.

  eauto.

  eauto.

  trivial.

  intuition.

  eapply evalDet_nil; eauto.

  

  eauto.

Qed.

    

Fixpoint datDepth (A : Set)(t : DistApproxTree A) : nat :=

  match t with

    | dat_leaf o => O

    | dat_internal t1 t2 =>

      S (max (datDepth t1) (datDepth t2))

  end.



Lemma datMap_depth_better' : forall (B : Set)(tb1 tb2 : DistApproxTree B),

  dat_better tb1 tb2 ->

  forall (A : Set)(rel : nat -> B -> DistApproxTree A -> Prop) n n' t1 t2,

    datMap_depth rel n tb1 t1 ->

    datMap (rel n') tb2 t2 ->

    n >= n' + (datDepth tb2) ->

    (forall b n1 n2 t1 t2, rel n1 b t1 -> rel n2 b t2 -> n1 >= n2 -> dat_better t1 t2) -> 

    dat_better t1 t2.

  

  induction 1; intuition; simpl in *.

  inversion H0; clear H0; subst.

  econstructor.

  

  inversion H0; clear H0; subst.

  inversion H; clear H; subst.

  eapply H2; eauto.

  omega.

  

  inversion H2; clear H2; subst.

  inversion H1; clear H1; subst.

  econstructor.

  eapply IHdat_better1.

  eauto.

  eauto.

  destruct (le_dec (datDepth tb1) (datDepth tb2)).

  rewrite Max.max_r in H3; eauto.

  omega.

  rewrite Max.max_l in H3; omega.

  eauto.

  

  eapply IHdat_better2.

  eauto.

  eauto.

  destruct (le_dec (datDepth tb1) (datDepth tb2)).

  rewrite Max.max_r in H3; omega.

  rewrite Max.max_l in H3; omega.

  eauto.

  

Qed.



Lemma datCorrect_datDepth : forall (A : Set)(c : Comp A) n t,

  dat_correct c n t ->

  (datDepth t <= n)%nat.

  

  induction 1; intuition; simpl in *.

  

  destruct (le_dec (datDepth t1) (datDepth t2)).

  rewrite Max.max_r; eauto.

  omega.

  rewrite Max.max_l; omega.

Qed.



Lemma dat_better_bind_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t1 t2,

  dat_correct_bind c1 c2 n t1 ->

  dat_correct_bind2 c1 c2 (div2 n) t2 ->

  dat_better t1 t2.

  

  intuition.

  unfold dat_correct_bind, dat_correct_bind2 in *.

  destruct H.

  destruct H0.

  intuition.

  

  eapply datMap_depth_better'.

  eapply dat_correct_dat_better.

  eapply H1.

  eapply H.

  eapply div2_le.

  eauto.

  simpl.

  eauto.

  

  eapply le_trans.

  2:{

    eapply div2_ge_double.

  }

  eapply plus_le_compat.

  auto.

  eapply datCorrect_datDepth.

  eauto.

  

  intuition.

  eapply dat_correct_dat_better; eauto.

  

Qed.



Lemma lowDistApprox_bind_le_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a n r1 r2,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->

  lowDistApprox_bind c1 c2 a (div2 n) r1 ->

  lowDistApprox (Bind c1 c2) a n r2 ->

  r1 <= r2.

  

  intuition.

  

  edestruct (dat_exists_bind2).

  eauto.

  eauto.

  rewrite bind_low_tree_approx_same_inv; eauto.

  edestruct dat_exists.

  eapply well_formed_Bind; eauto.

  eapply leRat_trans.

  2:{

    eapply eqRat_impl_leRat.

    eapply low_tree_approx_same_inv.

    eapply H4.

    eapply H2.

  }

  

  eapply lowDistApprox_dat_better_le.

  apply dat_correct_bind_same in H4.

  eapply dat_better_bind_div2; eauto.

  trivial.

  

  Grab Existential Variables.

  eapply bind_eq_dec; eauto.

  

Qed.



Lemma lowDistApprox_func : forall (A : Set)(c : Comp A) a n r1 r2,

  well_formed_comp c ->

  lowDistApprox c a n r1 ->

  lowDistApprox c a n r2 ->

  r1 == r2.

  

  intuition.

  edestruct (dat_exists).

  eauto.

  rewrite <- low_tree_approx_same_inv; eauto.

  eapply low_tree_approx_same_inv; eauto.

  

  Grab Existential Variables.

  eapply comp_eq_dec; eauto.

  

Qed.



Lemma lowDistApprox_bind_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) -> 

  left_total (lowDistApprox_bind c1 c2 a).

  

  intuition.

  unfold left_total.

  intuition.

  

  edestruct (sumList_rel_left_total).

  intuition.

  2:{

    econstructor.

    econstructor.

    eauto.

  }

  

  simpl.

  edestruct lowDistApprox_left_total.

  eapply bind_eq_dec; eauto.

  eauto.

  edestruct lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  eapply H.

  

  exists (x0 * x).

  intuition.

  

  eapply ratMult_eqRat_compat.

  eapply lowDistApprox_func; eauto.

  eapply lowDistApprox_func.

  eapply H0.

  eauto.

  eauto.

  eauto.

Qed.



Lemma lowDistApprox_bind_div2_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,

  well_formed_comp c1 ->

  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->

  left_total (fun n => lowDistApprox_bind c1 c2 a (div2 n)).

  

  intuition.

  unfold left_total.

  intuition.

  eapply lowDistApprox_bind_left_total; eauto.

Qed.



Lemma rel_map_Rnd_NoDup : forall n ls,

  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->

  NoDup ls.

  

  intuition.

  eapply rel_map_NoDup.

  eauto.

  eapply getAllBlists_NoDup.

  intuition.

  subst.

  

  inversion H4; clear H4; subst.

  inversion H5; clear H5; subst.

  inversion H3; clear H3; subst.

  inversion H5; clear H5; subst.

  simpl in *.

  

  edestruct shiftOut_Some.

  

  eapply le_refl_gen.

  symmetry.

  eapply getAllBlists_In_length.

  eauto.

  rewrite H3 in H9.

  

  edestruct shiftOut_Some.

  eapply le_refl_gen.

  symmetry.

  eapply getAllBlists_In_length.

  eapply H0.

  rewrite H4 in H8.

  destruct x.

  destruct x0.

  

  inversion H9; clear H9; subst.

  inversion H8; clear H8; subst.

  simpl in *.

  inversion H11; clear H11; subst.

  inversion H10; clear H10; subst.

  

  eapply H2.

  specialize (shiftOut_ls_eq _ _ H3 H4); intuition; eauto.

  

  erewrite <- (firstn_eq_all_gen a1).

  erewrite <- (firstn_eq_all_gen a2).

  eauto.

  symmetry.

  eapply getAllBlists_In_length.

  trivial.

  symmetry.

  eapply getAllBlists_In_length.

  trivial.

  

  inversion H5; clear H5; subst.

  simpl in *.

  edestruct shiftOut_Some.

  eapply le_refl_gen.

  symmetry.

  eapply getAllBlists_In_length.

  eapply H1.

  rewrite H4 in H9.

  destruct x.

  inversion H9; clear H9; subst.

  simpl in *.

  inversion H10.

  

Qed.



Lemma rel_map_Rnd_any_in : forall n ls (a : Bvector n),

  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->

  In (ca_done a) ls.

  

  intuition.

  eapply (rel_map_in H _ _ (VectorDef.to_list a)).

  eapply getAllBlists_length_In.

  eapply to_list_length.

  

  econstructor.

  econstructor.

  eauto.

  simpl.

  

  rewrite shiftOut_to_list.

  econstructor.

  eauto.

  simpl.

  econstructor.

  

  Grab Existential Variables.

  intuition.

  eapply evalDet_func; eauto.

  

Qed.



Theorem lowDistApprox_Rnd: forall n2 n1 (a : Bvector n1) r,

  lowDistApprox (Rnd n1) a (n1 + n2) r ->

  r == (1 / (expnat 2 n1)).

  

  induction n2; intuition; simpl in *.

  

  rewrite plus_0_r in *.

  unfold lowDistApprox in *.

  destruct H.

  destruct H.

  intuition.

  rewrite H2.

  eapply eqRat_terms.

  

  eapply pred_count_eq_1_inv; eauto.

  eapply comp_answer_eq_dec.

  unfold eq_dec.

  intuition.

  eapply Bvector_eq_dec.

  

  eapply rel_map_Rnd_NoDup.

  trivial.

  trivial.

  

  eapply rel_map_Rnd_any_in.

  trivial.

  trivial.



  unfold lowDistApprox in H.

  destruct H. 

  destruct H.

  intuition.

  

  edestruct (rel_map_left_total (evalDet (Rnd n1))). 

  intuition.

  eapply evalDet_left_total.

  eapply well_formed_Rnd.

  

  assert (pred_count (eq (ca_done a)) x1 x0).

  eapply pred_count_permutation.

  

  eapply rel_map_permutation.

  eapply getAllBlists_perm.

  intuition.

  eapply evalDet_func; eauto.

  

  2:{

    eapply H0.

  }

    

  intuition.

  eapply evalDet_left_total.

  eapply well_formed_Rnd.

  

  eauto.

  eauto.

  

  assert ((n1 + S n2) = (S (n1 + n2)))%nat.

  omega.

  rewrite H4 in H1.

  simpl in *.

  

  apply rel_map_app_inv in H1.

  intuition.

  rewrite map_length in H5.

  rewrite map_length in H6.

  

  unfold lowDistApprox in *.

  apply rel_map_map_inv in H5.

  apply rel_map_map_inv in H6.

  

  assert (rel_map (evalDet (Rnd n1)) (getAllBlists_app (n1 + n2)) (firstn (length (getAllBlists_app (n1 + n2))) x1)).

  eapply rel_map_eq.

  eapply H5.

  trivial.

  intuition.

  

  assert (length a0 = (n1 + n2)%nat).

  eapply getAllBlists_app_In_length.

  eauto.

  inversion H8; clear H8; subst.

  inversion H10; clear H10; subst.

  simpl in *.

  

  edestruct shiftOut_Some.

  assert (length a0 >= n1)%nat.

  omega.

  eapply H8.

  destruct x2.

  erewrite shiftOut_app in H14; eauto.

  inversion H14; clear H14; subst.

  simpl in *.

  inversion H15; clear H15; subst.

  

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H8.

  econstructor.

  eauto.

  simpl.

  econstructor.

  

  inversion H10; clear H10; subst.

  simpl in *.

  case_eq (shiftOut (a0 ++ true :: nil) n1); intuition.

  rewrite H8 in H14.

  destruct p.

  inversion H14; clear H14; subst.

  simpl in *.

  inversion H15.

  rewrite H8 in H14.

  

  econstructor.

  econstructor.

  eauto.

  simpl.

  erewrite shiftOut_app_None.

  econstructor.

  eauto.

  clear H5.

  

  assert (rel_map (evalDet (Rnd n1)) (getAllBlists_app (n1 + n2)) (skipn (length (getAllBlists_app (n1 + n2))) x1)).

  eapply rel_map_eq.

  eapply H6.

  trivial.

  intuition.

  

  assert (length a0 = (n1 + n2)%nat).

  eapply getAllBlists_app_In_length.

  eauto.

  inversion H8; clear H8; subst.

  inversion H10; clear H10; subst.

  simpl in *.

  

  edestruct shiftOut_Some.

  assert (length a0 >= n1)%nat.

  omega.

  eapply H8.

  destruct x2.

  erewrite shiftOut_app in H14; eauto.

  inversion H14; clear H14; subst.

  simpl in *.

  inversion H15; clear H15; subst.

    

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H8.

  econstructor.

  eauto.

  simpl.

  econstructor.

  

  inversion H10; clear H10; subst.

  simpl in *.

  case_eq (shiftOut (a0 ++ false :: nil) n1); intuition.

  rewrite H8 in H14.

  destruct p.

  inversion H14; clear H14; subst.

  simpl in *.

  inversion H15.

  rewrite H8 in H14.

  

  econstructor.

  econstructor.

  eauto.

  simpl.

  erewrite shiftOut_app_None.

  econstructor.

  eauto.

  

  clear H6.    

  

  eapply (pred_count_first_skip) in H3.

  destruct H3. destruct H3. intuition.

  

  edestruct (rel_map_left_total (evalDet (Rnd n1)) (getAllBlists (n1 + n2))).

  intuition.

  eapply evalDet_left_total.

  eapply well_formed_Rnd.

  

  rewrite H4 in H2.

  simpl in *.

  rewrite <- H8 in H2.

  assert (r * (2/1) == (x2 + x3) / (expnat 2 (n1 + n2))).

  rewrite H2.



  assert (nz (expnat 2 (n1 + n2))%nat).

  econstructor.

  eapply expnat_pos.

  omega.

  

  assert (nz 2)%nat.

  econstructor. omega.

  

  eapply eqRat_trans.

  eapply ratMult_eqRat_compat.

  eapply (@eqRat_terms _ _ (x2 + x3)%nat (posnatMult (natToPosnat H10) (natToPosnat H9))).

  trivial.

  simpl.

  trivial.

  eapply eqRat_refl.

  rewrite <- ratMult_num_den.

  eapply eqRat_trans.

  eapply eqRat_terms.

  eapply mult_comm.

  eapply posnatMult_1_r.

  

  rewrite rat_remove_common_factor.

  eapply eqRat_terms; eauto.

  

  rewrite ratAdd_den_same in H9.



  assert (x2 / (expnat 2 (n1 + n2)) == 1 / expnat 2 n1).

  eapply IHn2.

  econstructor. econstructor.

  intuition.

  eauto.

  eapply pred_count_permutation.

  eapply Permutation_sym.

  eapply rel_map_permutation.

  eapply getAllBlists_perm.

  intuition.

  eapply evalDet_func; eauto.

  2:{

    eauto.

  }

  intuition.

  eapply evalDet_left_total.

  eapply well_formed_Rnd.

  eapply H1.

  eauto.

  eapply eqRat_terms; eauto.

  

  assert (x3 / expnat 2 (n1 + n2) == 1 / expnat 2 n1).

  eapply IHn2.

  econstructor. econstructor.

  intuition.

  eauto.

  eapply pred_count_permutation.

  eapply Permutation_sym.

  eapply rel_map_permutation.

  eapply getAllBlists_perm.

  intuition.

  eapply evalDet_func; eauto.

  2:{

    eapply H7.

  }

  intuition.

  eapply evalDet_left_total.

  eapply well_formed_Rnd.

  eapply H5.

  eauto.

  eapply eqRat_terms; eauto.

  

  rewrite H10 in H9.

  rewrite H11 in H9.

  rewrite ratMult_2 in H9.   

  eapply ratMult_same_r_inv.

  eauto.

  rattac.

Qed.



Definition indicator_rel (A : Set)(P : A -> bool) a (r : Rat) :=

  (P a = true /\ r == 1) \/ (P a = false /\ r == 0).



Definition lowDistApprox_repeat (A : Set)(c : Comp A)(P : A -> bool) a n : Rat -> Prop := 

  let approx := lowDistApprox c a n in

    let empty := sumList_rel (fun a => lowDistApprox c a n) (filter (fun a => negb (P a)) (getSupport c)) in

  ratMult_rel (ratMult_rel (indicator_rel P a)

    (sumList_rel (fun i => (expRat_rel empty i)) (getNats O (S n)))) 

  approx.



Lemma lowDistApprox_repeat_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,

  well_formed_comp c ->

  left_total (lowDistApprox_repeat c P a).



  unfold left_total; intuition.

  edestruct (sumList_rel_left_total

    (fun (i : nat) (r : Rat) =>

       forall r1'1 : Rat,

       sumList_rel (fun a0 : A => lowDistApprox c a0 n)

         (filter (fun a0 : A => negb (P a0)) (getSupport c)) r1'1 ->

       r == expRat r1'1 i)

    (getNats O (S n))).  

  intuition.



  edestruct (sumList_rel_left_total

    (fun a1 : A => lowDistApprox c a1 n)

    (filter (fun a1 : A => negb (P a1)) (getSupport c)) ).

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  econstructor.

  intuition.

  eapply expRat_eqRat_compat.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func;

  eauto.

  

  edestruct (@lowDistApprox_left_total).

  eapply comp_eq_dec; eauto.

  eauto.



  unfold lowDistApprox_repeat, ratMult_rel, expRat_rel, indicator_rel.

  econstructor.

  intuition.

  eapply ratMult_eqRat_compat.

  symmetry.

  eapply H2; eauto.

  case_eq (P a); intuition.

  left.

  intuition.

  assert (indicator P a == 1).

  unfold indicator.

  rewrite H4.

  intuition.

  eapply H5.

  right.

  intuition.

  unfold indicator.

  rewrite H4.

  intuition.

  eapply lowDistApprox_func; eauto.

  

Qed.



Lemma lowDistApprox_repeat_sqrt_div2_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,

  well_formed_comp c ->

  left_total (fun n => (lowDistApprox_repeat c P a (Nat.sqrt (div2 n)))).



  unfold left_total.

  intuition.

  edestruct lowDistApprox_repeat_left_total; eauto.



Qed.



Inductive datRepeat (A : Set)(f : DistApproxTree A -> Prop)(P : A -> bool) : nat -> DistApproxTree A -> DistApproxTree A -> Prop :=

  | datRepeat_leaf_None : forall n,

    datRepeat f P n (dat_leaf None) (dat_leaf None)

  | datRepeat_leaf_Some_yes : forall a n,

    P a = true ->

    datRepeat f P n (dat_leaf (Some a)) (dat_leaf (Some a))

  | datRepeat_leaf_Some_no : forall a,

    P a = false ->

    datRepeat f P O (dat_leaf (Some a)) (dat_leaf None)

  | datRepeat_leaf_Some_repeat : forall a t t' n,

    f t ->

    P a = false ->

    datRepeat f P n t t' ->

    datRepeat f P (S n) (dat_leaf (Some a)) t'

  | datRepeat_internal : forall n t1 t2 t1' t2',

    datRepeat f P n t1 t1' ->

    datRepeat f P n t2 t2' ->

    datRepeat f P n (dat_internal t1 t2) (dat_internal t1' t2').



Definition dat_correct_repeat2(A : Set)(c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=

exists t1 : DistApproxTree A,

  dat_correct c n t1 /\

  datRepeat (dat_correct c n) P n t1 t. 



Lemma datRepeat_left_total : forall n (A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(f : DistApproxTree A -> Prop) P,

   (exists b : DistApproxTree A, f b) ->

   exists t', datRepeat f P n t t'.

  

  induction n.

  induction t; intuition.

  destruct o.

  case_eq (P a); intuition.

  econstructor.

  econstructor.

  trivial.

  econstructor.

  eapply datRepeat_leaf_Some_no.

  trivial.

  econstructor.

  econstructor.

  edestruct IHt1.

  eauto.



  edestruct IHt2.

  eauto.



  econstructor.

  econstructor; eauto.



  induction t; intuition.

  destruct o.

  destruct H.

  edestruct (IHn _ eqd x).

  eauto.

  

  case_eq (P a); intuition.

  econstructor.  

  econstructor.

  trivial.

  

  edestruct IHn; eauto.

  econstructor.

  eapply datRepeat_leaf_Some_repeat.

  eauto.

  trivial.

  eauto.



  econstructor.

  econstructor.



  edestruct IHt1; eauto.

  edestruct IHt2; eauto.

  econstructor.

  econstructor; eauto.



  Grab Existential Variables.

  eapply P.



  trivial.



Qed.



Lemma dat_exists_repeat2 : forall (A : Set)(c : Comp A)(P : A -> bool)(n : nat),

  well_formed_comp c ->

  exists t : DistApproxTree A, dat_correct_repeat2 c P n t.



  intuition.

  destruct (@dat_exists n _ c).

  trivial.

  edestruct (@datRepeat_left_total n A (comp_eq_dec c) x  

  (dat_correct c n) P).

  eapply dat_exists; eauto.



  econstructor.

  unfold dat_correct_repeat2.

  econstructor.

  intuition.

  eauto.

  eauto.

Qed.



Fixpoint computeEmptySpace(A : Set)(t : DistApproxTree A)(P : A -> bool) :=

  match t with

    | dat_leaf o =>

      match o with

        | Some a => indicator (fun a' => (negb (P a'))) a 

        | None => 0

      end

    | dat_internal t1 t2 =>

      (1 / 2) * (computeEmptySpace t1 P)  + (1 / 2) * (computeEmptySpace t2 P)

  end.



Lemma computeEmptySpace_correct : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) P,

  sumList (filter (fun a => negb (P a)) (getTreeSupport eqd t)) (lowDistApproxFromTree eqd t) == (computeEmptySpace t P).

  

  induction t; intuition; simpl in *.

  destruct o.

  simpl.

  unfold indicator.

  unfold sumList.

  case_eq (P a); intuition.

  simpl.

  intuition.

  simpl.

  destruct (eqd a a); intuition; subst.

  rewrite <- ratAdd_0_l.

  intuition.

  unfold sumList.

  simpl.

  intuition.

  

  rewrite sumList_sum.

  unfold getTreeSupport.

  simpl.

  eapply ratAdd_eqRat_compat.

  rewrite sumList_factor_constant_r.

  

  rewrite <- sumList_subset'.

  rewrite IHt1.

  eapply ratMult_comm.

  trivial.

  eapply filter_NoDup.

  eapply getUnique_NoDup.

  eapply filter_NoDup.

  eapply getUnique_NoDup.

  intuition.

  eapply filter_In; intuition.

  eapply in_getUnique.

  eapply in_or_app.

  left.

  eapply in_getUnique_if.

  eapply filter_In.

  eauto.

  apply filter_In in H.

  intuition.

  intuition.

  eapply getTreeSupport_approx_0.

  intuition.

  eapply H0.

  eapply filter_In.

  intuition.

  apply filter_In in H.

  intuition.

  

  rewrite sumList_factor_constant_r.

  rewrite <- sumList_subset'.

  rewrite IHt2.

  eapply ratMult_comm.

  trivial.

  eapply filter_NoDup.

  eapply getUnique_NoDup.

  eapply filter_NoDup.

  eapply getUnique_NoDup.

  intuition.

  eapply filter_In; intuition.

  eapply in_getUnique.

  eapply in_or_app.

  right.

  eapply in_getUnique_if.

  eapply filter_In.

  eauto.

  apply filter_In in H.

  intuition.

  intuition.

  eapply getTreeSupport_approx_0.

  intuition.

  eapply H0.

  eapply filter_In.

  intuition.

  apply filter_In in H.

  intuition.

Qed.



Lemma lowDistApprox_val_eq : forall (A : Set)(c : Comp A) a n r1 r2,

  lowDistApprox c a n r1 ->

  r1 == r2 ->

  lowDistApprox c a n r2.

 

  intuition.

  unfold lowDistApprox in *.

  destruct H. destruct H. intuition.

  econstructor. econstructor. intuition.

  eauto.

  eauto.

  rewrite <- H0.

  trivial.

Qed.



Lemma repeat_low_tree_approx_same_tree_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> bool)(t1 t2 t3 : DistApproxTree A) n a,

  datRepeat (eq t3) P n t1 t2 ->

  lowDistApproxFromTree eqd t2 a == 

  indicator P a * 

  ((lowDistApproxFromTree eqd t1 a) + 

    (computeEmptySpace t1 P) * 

    sumList (getNats 0 n) (expRat (computeEmptySpace t3 P)) * (lowDistApproxFromTree eqd t3 a)).

  

  induction 1; intuition; simpl in *.

  repeat rewrite ratMult_0_l.

  rewrite <- ratAdd_0_l.

  rewrite ratMult_0_r.

  intuition.

  

  destruct (eqd a a0); subst.

  unfold indicator.

  rewrite H.

  simpl.

  repeat rewrite ratMult_0_l.

  repeat rewrite ratMult_1_l.

  rewrite <- ratAdd_0_r.

  intuition.

  rewrite <- ratAdd_0_l.

  unfold indicator.

  rewrite H.

  simpl.

  repeat rewrite ratMult_0_l.

  rewrite ratMult_0_r.

  intuition.

  

  destruct (eqd a a0); subst.

  unfold indicator.

  rewrite H.

  repeat rewrite ratMult_0_l.

  intuition.

  rewrite <- ratAdd_0_l.

  unfold indicator.

  rewrite H.

  simpl.

  unfold sumList; simpl.

  rewrite ratMult_0_r.

  rewrite ratMult_0_l.

  rewrite ratMult_0_r.

  intuition.

  

  rewrite IHdatRepeat.

  destruct (eqd a a0); subst.

  unfold indicator.

  rewrite H0.

  repeat rewrite ratMult_0_l.

  intuition.

  repeat rewrite <- ratAdd_0_l.

  eapply ratMult_eqRat_compat; intuition.

  unfold indicator.

  rewrite H0.

  simpl.

  rewrite ratMult_1_l.

  

  rewrite <- sumList_factor_constant_l.

  

  rewrite sumList_series_incr.

  

  2:{

    intuition.

    assert (computeEmptySpace t P * expRat (computeEmptySpace t P) n1 == expRat (computeEmptySpace t P) (S n1)).

    simpl.

    intuition.

    eauto.

  }

  

  rewrite sumList_series_split_first.

  simpl.

  rewrite ratMult_distrib_r.

  rewrite ratMult_1_l.

  intuition.

 

  rewrite IHdatRepeat1.

  rewrite IHdatRepeat2.

  

  remember (sumList (getNats 0 n) (expRat (computeEmptySpace t3 P))) as v1.

  remember (lowDistApproxFromTree eqd t1 a) as v2.

  remember (computeEmptySpace t1 P) as v3.

  remember (indicator P a) as v4.

  remember (lowDistApproxFromTree eqd t3 a) as v5.

  remember (lowDistApproxFromTree eqd t2 a) as v6.

  remember (computeEmptySpace t2 P) as v7.

  

  rewrite ratMult_assoc.

  rewrite (ratMult_assoc v4 (v6 + v7 * v1 * v5) (1 / 2)).

  rewrite <- ratMult_distrib.

  eapply ratMult_eqRat_compat; intuition.

  repeat rewrite ratMult_distrib_r.

  repeat rewrite <- ratAdd_assoc.

  eapply ratAdd_eqRat_compat.

  repeat rewrite ratAdd_assoc.

  eapply ratAdd_eqRat_compat; intuition.

  rewrite ratAdd_comm.

  eapply ratAdd_eqRat_compat.

  intuition.

  rewrite ratMult_comm.

  repeat rewrite <- ratMult_assoc.

  intuition.

  rewrite ratMult_comm.

  repeat rewrite <- ratMult_assoc.

  intuition.

  

Qed.



Lemma datRepeat_func_eq : forall n (A : Set)(t1 t2 : DistApproxTree A) f P (P' : DistApproxTree A -> Prop),

  datRepeat f P n t1 t2 ->

  (forall t, f t -> P' t) ->

  datRepeat P' P n t1 t2.

  

  induction 1; intuition; simpl in *.

  econstructor.

  econstructor.

  trivial.

  econstructor.

  trivial.

  econstructor.

  eapply H2.

  eauto.

  trivial.

  trivial.

  econstructor; trivial.

Qed.



Lemma repeat_low_tree_approx_same_inv

  : forall (A : Set) (eqd : eq_dec A)(c : Comp A)(P : A -> bool) (n : nat) (a : A) (t : DistApproxTree A) (r : Rat),

    well_formed_comp c ->

    (exists a, In a (filter P (getSupport c))) ->

    lowDistApprox_repeat c P a n r ->

    dat_correct_repeat2 c P n t -> 

    n > 0 ->

    r == lowDistApproxFromTree eqd t a.

  

  intuition.

  

  destruct H2. 

  intuition.

  unfold lowDistApprox_repeat, ratMult_rel, expRat_rel, indicator_rel in *.

  unfold dat_correct in *.

  symmetry.



  edestruct (sumList_rel_left_total 

    (fun (i : nat) (r : Rat) =>

           forall r1'1 : Rat,

           sumList_rel (fun a : A => lowDistApprox c a n)

             (filter (fun a : A => negb (P a)) (getSupport c)) r1'1 ->

           r == expRat r1'1 i)

    (getNats O (S n))). 

  intuition.

  

  edestruct (sumList_rel_left_total (fun a : A => lowDistApprox c a n) (filter (fun a : A => negb (P a)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total.

  trivial.

  trivial.



  exists (expRat x0 a0).

  intuition.

  eapply expRat_eqRat_compat.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.



  edestruct lowDistApprox_left_total; eauto.

  rewrite (H1 (indicator P a * x0) x1); eauto.



  edestruct (sumList_rel_left_total (fun a : A => lowDistApprox c a n)

            (filter (fun a : A => negb (P a)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total; eauto.



  assert (sumList_rel (fun a : A => lowDistApprox c a n)

         (filter (fun a : A => negb (P a)) (getTreeSupport eqd x)) x2).

  eapply sumList_rel_ls_intersect.

  eauto.

  eapply filter_NoDup.

  eapply getSupport_NoDup.

  eapply filter_NoDup.

  eapply getUnique_NoDup.

  trivial.

  intuition.

  eapply lowDistApprox_func; eauto.

  intuition.



  eapply lowDistApprox_val_eq.

  eapply low_tree_approx_same.

  trivial.

  eapply H4.

  eapply lowDistApproxFromTree_eq_0.

  intuition.

  eapply H9.

  eapply filter_In; intuition; eauto.

  apply filter_In in H8.

  intuition.

  

  intuition.

  exfalso.

  eapply H9.

  eapply filter_In; intuition.

  eapply getTreeSupport_in.

  eauto.

  eapply filter_In.

  eauto.

  apply filter_In in H8.

  intuition.

  

  assert (sumList_rel (fun i => expRat_rel (eqRat x2) i) (getNats O (S n)) x0).

  eapply sumList_rel_body_eq.

  eapply H2.

  intuition.

  unfold expRat_rel in *.

  intuition.

  rewrite H9.

  eapply expRat_eqRat_compat.

  eapply H10.

  trivial.

  intuition.

  trivial.

  clear H2.

  clear H7.



  assert (sumList (getNats O (S n)) (expRat x2) == x0).

  rewrite sumList_rel_func.

  eapply eqRat_refl.

  eapply sumList_rel_sumList_eqRat.

  eapply sumList_rel_body_eq.

  eapply H9.

  intuition.

  unfold expRat_rel in *.

  rewrite H2.

  eapply eqRat_refl.

  intuition.

  intuition.

  intuition.

  intuition.

  rewrite <- H2.

  rewrite H7.

  intuition.

  rewrite <- H2.

  clear H9.

  clear H2.

  

  assert (x1 == (lowDistApproxFromTree eqd x a)).

  eapply lowDistApprox_func.

  eauto.

  eauto.

  eapply low_tree_approx_same; eauto.

  rewrite H2.



  assert (x2 == (computeEmptySpace x P)).

  assert (sumList 

         (filter (fun a : A => negb (P a)) (getTreeSupport eqd x)) 

         (fun a : A => lowDistApproxFromTree eqd x a) == x2).

  eapply sumList_rel_func.

  eapply sumList_rel_sumList_eqRat.

  eapply sumList_rel_body_eq.

  eapply H8.

  intuition.

  eapply lowDistApprox_func.

  eauto.

  eapply low_tree_approx_same.

  trivial.

  eauto.

  trivial.

  intuition.

  trivial.

  intuition.

  rewrite <- H7.

  rewrite H9.

  intuition.

  rewrite <- H7.

  eauto. 



  eapply computeEmptySpace_correct; eauto.



  eapply eqRat_trans.

  2:{

    eapply ratMult_eqRat_compat.

    eapply ratMult_eqRat_compat.

    eapply eqRat_refl.

    eapply sumList_body_eq.

    intuition.

    eapply expRat_eqRat_compat.

    symmetry.

    eapply H7.

    eapply eqRat_refl.

  }



  eapply eqRat_trans.

  eapply repeat_low_tree_approx_same_tree_inv; eauto.



  eapply datRepeat_func_eq.

  eauto.

  intuition.

  eapply dat_correct_func; eauto.



  rewrite (ratMult_assoc (indicator P a) (sumList (getNats 0 (S n)) (fun a0 : nat => expRat (computeEmptySpace x P) a0))).

  eapply ratMult_eqRat_compat.

  intuition.

  rewrite <- sumList_factor_constant_l.

  rewrite sumList_series_incr.

  2:{

    intuition.

    assert (computeEmptySpace x P * expRat (computeEmptySpace x P) n0 == expRat (computeEmptySpace x P) (S n0)).

    simpl.

    intuition.

    eapply H9.

  }

  remember (lowDistApproxFromTree eqd x a) as v.

  rewrite <- (ratMult_1_l v) at 1.

  rewrite <- ratMult_distrib_r.

  assert ((expRat (computeEmptySpace x P)) O = 1).

  simpl.

  intuition.

  rewrite <- H9 at 1.

  rewrite <- sumList_series_split_first.

  simpl.

  eapply eqRat_refl.



  unfold indicator.

  intuition.

  rewrite H7.

  rewrite H10.

  repeat rewrite ratMult_1_l.

  eapply sumList_rel_func; eauto.

  intuition.

  edestruct (sumList_rel_left_total (fun a : A => lowDistApprox c a n) (filter (fun a : A => negb (P a)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total; eauto.

  rewrite H9; eauto.

  rewrite H11; eauto.

  intuition.



  rewrite H7.

  rewrite H10.

  repeat rewrite ratMult_0_l.

  intuition.



Qed.



Lemma dat_better_antisymm : forall (A : Set)(t1 t2 : DistApproxTree A),

  dat_better t1 t2 ->

  dat_better t2 t1 ->

  t1 = t2.

  

  induction 1; inversion 1; intuition; subst; trivial.

Qed.



Lemma dat_correct_h_repeat_app : forall (A : Set) t (c : Comp A)(P : A -> bool) n ls1 ls2 a,

  evalDet_steps (cs_more c ls1) (cs_done a nil) ->

  P a = false ->

  dat_correct_h (Repeat c P) (ls1 ++ ls2) n t ->

  dat_correct_h (Repeat c P) ls2 n t.



  induction t; intuition.

  inversion H1; clear H1; subst.

  inversion H4; clear H4; subst.

  inversion H2; clear H2; subst.

  simpl in *.

  apply evalDet_steps_bind_done_inv in H6.

  destruct H6. destruct H1.

  intuition.

  assert (evalDet_steps (cs_more c (ls1 ++ ls2)) (cs_done a (nil ++ ls2))).

  eapply evalDet_steps_app_eq.

  eauto.

  simpl in *.

  specialize (evalDet_steps_done_func H1 H2); intuition; subst.

  clear H1.

  econstructor.

  econstructor.

  rewrite H0 in H3.

  eauto.

 

  econstructor.

  intuition.

  inversion H1; clear H1; subst.

  eapply H4.

  econstructor.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eapply evalDet_steps_app_eq.

  eauto.

  rewrite H0.

  simpl.

  eauto.

  

  inversion H1; clear H1; subst.

  econstructor.

  intuition.

  inversion H1; clear H1; subst.

  eapply H4.

  econstructor.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eapply evalDet_steps_app_eq.

  eauto.

  rewrite H0.

  simpl.

  eauto.

  eapply IHt1.

  eauto.

  trivial.

  rewrite app_assoc.

  trivial.

  eapply IHt2.

  eauto.

  trivial.

  rewrite app_assoc.

  trivial.



Qed.



Inductive datRepeat_depth (A : Set)(f : nat -> DistApproxTree A -> Prop)(P : A -> bool) : nat -> nat -> DistApproxTree A -> DistApproxTree A -> Prop :=

  | datRepeat_depth_leaf_None : forall n depth,

    datRepeat_depth f P n depth (dat_leaf None) (dat_leaf None)

  | datRepeat_depth_leaf_Some_yes : forall a n depth,

    P a = true ->

    datRepeat_depth f P n depth (dat_leaf (Some a)) (dat_leaf (Some a))

  | datRepeat_depth_leaf_Some_no : forall a depth,

    P a = false ->

    datRepeat_depth f P O depth (dat_leaf (Some a)) (dat_leaf None)

  | datRepeat_depth_leaf_Some_repeat : forall a t t' n depth,

    P a = false ->

    f depth t ->

    datRepeat_depth f P n depth t t' ->

    datRepeat_depth f P (S n) depth (dat_leaf (Some a)) t'

  | datRepeat_depth_internal : forall n depth t1 t2 t1' t2',

    datRepeat_depth f P n depth t1 t1' ->

    datRepeat_depth f P n depth t2 t2' ->

    datRepeat_depth f P n (S depth) (dat_internal t1 t2) (dat_internal t1' t2').



Definition dat_correct_repeat(A : Set) (c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=

exists t1 : DistApproxTree A,

  dat_correct c n t1 /\

  datRepeat_depth (dat_correct c) P n n t1 t.



Lemma datRepeat_depth_0 : forall n2 n1 (A : Set)(f : nat -> DistApproxTree A -> Prop) P t1 t2,

  datRepeat_depth f P n1 O t1 t2 ->

  n2 >= n1 ->

  f O (dat_leaf None) ->

  datRepeat_depth f P n2 O t1 t2.

  

  induction n2; intuition; subst.

  

  inversion H; clear H; subst.

  econstructor.

  econstructor.

  trivial.

  econstructor.

  trivial.

  trivial.

  

  omega.

  

  inversion H; clear H; subst.

  econstructor.

  econstructor; trivial.

  econstructor.

  trivial.

  eauto.

  econstructor.

  

  econstructor; eauto.

  eapply IHn2; eauto.

  omega.

Qed.



Lemma dat_correct_repeat_same_h : forall depth repeats (A : Set)(c : Comp A) P ls t a t1,

  dat_correct_h (Repeat c P) ls depth t ->

  well_formed_comp c ->

  In a (filter P (getSupport c)) ->

  (forall a' n' ls', 

    evalDet_steps (cs_more c (firstn n' ls)) (cs_done a' ls') -> 

    ls' = nil)  -> 

  dat_correct_h c ls depth t1 ->  

  repeats >= depth ->

  datRepeat_depth (dat_correct_h c nil) P repeats depth t1 t.



  induction depth; intuition.

  

  inversion H; clear H; subst.

  inversion H5; clear H5; subst.

  inversion H6; clear H6; subst.

  simpl in *.

  apply evalDet_steps_bind_done_inv in H9.

  destruct H9.

  destruct H.

  intuition.

  inversion H3; clear H3; subst.

  inversion H; clear H; subst.

  case_eq (P x); intuition;

  rewrite H in H6.

  inversion H6; clear H6; subst.

  simpl in *.

  inversion H11; clear H11; subst.

  assert (a1 = a0 /\ s'0 = s').

  eapply evalDet_steps_done_func; eauto.

  intuition.

  subst.

  econstructor.

  rewrite H.

  trivial.

  assert (x0 = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  inversion H6; clear H6; subst.

  simpl in *.

  apply evalDet_steps_bind_done_inv in H11.

  destruct H11.

  destruct H3.

  intuition.

  assert (x1 = nil).

  eapply evalDet_nil.

  eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done x0 (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  trivial.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  assert (a = x).

  eapply evalDet_steps_nil_eq; eauto.

  eapply filter_In; eauto.

  subst.

  assert (P x = true).

  eapply filter_In; eauto.

  congruence.

  exfalso.

  eapply H.

  econstructor.

  eauto.



  inversion H3; clear H3; subst.

  inversion H; clear H; subst.

  case_eq (P a0); intuition.

  exfalso.

  eapply H5.

  econstructor.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H.

  econstructor.

  eauto.

  simpl.

  econstructor.

  eapply datRepeat_depth_0.

  econstructor.

  trivial.

  trivial.

  econstructor.

  intuition.

  inversion H3; clear H3; subst.

  assert (s'0 = nil).

  eapply evalDet_nil; eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done a1 (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  trivial.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  assert (a0 = a1 /\ s' = nil).

  eapply evalDet_steps_done_func; eauto.

  intuition. subst.

  assert (a = a1).

  eapply evalDet_steps_nil_eq; eauto.

  eapply filter_In; eauto.

  subst.

  assert (P a1 = true).

  eapply filter_In; eauto.

  congruence.



  econstructor.



  inversion H; clear H; subst.

  inversion H5; clear H5; subst.

  inversion H6; clear H6; subst.

  simpl in *.

  apply evalDet_steps_bind_done_inv in H9.

  destruct H9.

  destruct H.

  intuition.



  inversion H3; clear H3; subst.

  inversion H; clear H; subst.

  assert (x = a1 /\ x0 = s'0).

  eapply evalDet_steps_done_func; eauto.

  intuition; subst.

  assert (s'0 = nil).

  eapply H2.

  rewrite firstn_eq_all_gen.

  eauto.

  eauto.

  subst.

  case_eq (P a1); intuition.

  rewrite H in H6.

  inversion H6; clear H6; subst.

  simpl in *.

  inversion H11; clear H11; subst.

  econstructor.

  trivial.



  rewrite H in H6.

  inversion H6; clear H6; subst.

  simpl in *.

  apply evalDet_steps_bind_done_inv in H11.

  destruct H11.

  destruct H3.

  intuition.

  assert (x0 = nil).

  eapply evalDet_nil.

  eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done x (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  eauto.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen;

  eauto.

  subst.

  assert (a = a1).

  eapply evalDet_steps_nil_eq.

  eauto.

  eapply filter_In; eauto.

  subst.

  assert (P a1 = true).

  eapply filter_In; eauto.

  congruence.



  exfalso.

  eapply H7.

  econstructor.

  eauto.



  edestruct (dat_exists_h depth (true::nil)); eauto.

  edestruct (dat_exists_h depth (false::nil)); eauto.

  inversion H3; clear H3; subst.

  inversion H9; clear H9; subst.

  case_eq (P a0); intuition.

  exfalso.

  eapply H6.

  econstructor.

  econstructor.

  eauto.

  simpl.

  eapply evalDet_steps_trans.

  eapply evalDet_steps_bind_done.

  eauto.

  rewrite H3.

  econstructor.

  eauto.

  simpl.

  econstructor.

  

  destruct repeats.

  omega.



  eapply datRepeat_depth_leaf_Some_repeat.

  trivial.

  eapply dat_correct_h_internal; simpl.

  intuition.

  inversion H9; clear H9; subst.

  assert (s'0 = nil).

  eapply evalDet_nil.

  eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done a1 (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  trivial.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen;

    eauto.

  subst.

  assert (a = a0).

  eapply evalDet_steps_nil_eq.

  eauto.

  eapply filter_In; eauto.

  subst.

  assert (P a0 = true).

  eapply filter_In; eauto.

  congruence.



  eauto.

  eauto.

  assert (s' = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  eapply datRepeat_depth_internal.



  eapply IHdepth.

  eapply dat_correct_h_repeat_app.

  eauto.

  trivial.

  eauto.

  trivial.

  eauto.

  intuition.

  destruct n'; simpl in *.

  eapply evalDet_nil; eauto.

  edestruct (@evalDet_dec _ c nil); eauto.

  destruct H11.

  inversion H11; clear H11; subst.

  assert (s' = nil).

  eapply evalDet_nil.

  eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done x1 (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  trivial.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  assert (a = a0).

  eapply evalDet_steps_nil_eq.

  eauto.

  eapply filter_In; eauto.

  subst.

  assert (P a0 = true).

  eapply filter_In; eauto.

  congruence.

  rewrite firstn_nil in H9.

  eapply evalDet_app_nil;

  eauto.

  trivial.

  omega.



  eapply IHdepth.

  eapply dat_correct_h_repeat_app.

  eauto.

  trivial.

  eauto.

  trivial.

  eauto.

  intuition.

  destruct n'; simpl in *.

  eapply evalDet_nil; eauto.

  edestruct (@evalDet_dec _ c nil); eauto.

  destruct H11.

  inversion H11; clear H11; subst.

  assert (s' = nil).

  eapply evalDet_nil.

  eauto.

  subst.

  assert (evalDet_steps (cs_more c (nil ++ ls)) (cs_done x1 (nil ++ ls))).

  eapply evalDet_steps_app_eq.

  trivial.

  simpl in *.

  assert (ls = nil).

  eapply H2.

  rewrite firstn_eq_all_gen; eauto.

  subst.

  assert (a = a0).

  eapply evalDet_steps_nil_eq.

  eauto.

  eapply filter_In; eauto.

  subst.

  assert (P a0 = true).

  eapply filter_In; eauto.

  congruence.

  rewrite firstn_nil in H9.

  eapply evalDet_app_nil;

  eauto.

  trivial.

  omega.



  eapply datRepeat_depth_internal.



  eapply IHdepth;

  eauto.

  intuition.

  edestruct evalDet_steps_dec; eauto.

  destruct H9.

  destruct H9.

  exfalso.

  eapply H10.

  econstructor.

  eauto.

  eapply evalDet_app_nil.

  eauto.

  econstructor.

  eauto.

  destruct (ge_dec n' (length (ls ++ true :: nil))).

  rewrite firstn_ge_all in H3.

  eauto.

  trivial.

  apply not_ge in n.

  exfalso.

  assert (n' <= length ls)%nat.

  rewrite app_length in n.

  simpl in *.

  omega. 

  rewrite firstn_app in H3.

  assert (ls = firstn n' ls ++ skipn n' ls).

  symmetry.

  eapply firstn_skipn.

  assert (evalDet_steps (cs_more c ((firstn n' ls) ++ (skipn n' ls))) (cs_done a' (ls' ++ (skipn n' ls)))).

  eapply evalDet_steps_app_eq.

  trivial.

  specialize (H10 a').

  eapply H10.

  eapply (@evalDet_done _ _ _ a' (ls' ++ skipn n' ls)).

  rewrite H14 at 1.

  eapply H15.

  trivial.

  omega.



  eapply IHdepth;

  eauto.

  intuition.

  edestruct evalDet_steps_dec; eauto.

  destruct H9.

  destruct H9.

  exfalso.

  eapply H10.

  econstructor.

  eauto.

  eapply evalDet_app_nil.

  eauto.

  econstructor.

  eapply H9.

  destruct (ge_dec n' (length (ls ++ false :: nil))).

  rewrite firstn_ge_all in H3.

  eauto.

  trivial.

  apply not_ge in n.

  exfalso.

  assert (n' <= length ls)%nat.

  rewrite app_length in n.

  simpl in *.

  omega. 

  rewrite firstn_app in H3.

  assert (ls = firstn n' ls ++ skipn n' ls).

  symmetry.

  eapply firstn_skipn.

  assert (evalDet_steps (cs_more c ((firstn n' ls) ++ (skipn n' ls))) (cs_done a' (ls' ++ (skipn n' ls)))).

  eapply evalDet_steps_app_eq.

  trivial.

  specialize (H10 a').

  eapply H10.

  eapply (@evalDet_done _ _ _ a' (ls' ++ skipn n' ls)).

  rewrite H14 at 1.

  eapply H15.

  trivial.

  omega.

 Qed.



Lemma dat_correct_repeat_same:

  forall n (A : Set) (t : DistApproxTree A) (c : Comp A) (P : A -> bool),

  well_formed_comp c ->

  (exists a, In a (filter P (getSupport c))) ->

  dat_correct (Repeat c P) n t -> 

  dat_correct_repeat c P n t.



  intuition.

  edestruct (dat_exists); eauto.

  econstructor.

  intuition.

  eauto.

  destruct H0.

  eapply dat_correct_repeat_same_h; eauto.



  intuition.

  rewrite firstn_nil in H3.

  eapply evalDet_nil.

  eauto.



Qed.



Lemma datRepeat_depth_better: forall (n2 : nat) (A : Set) (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),

  datRepeat_depth rel P reps depth t1 t1' ->

  forall n1 (t2' : DistApproxTree A),

    reps >= n2 ->

    datRepeat (rel n1) P n2 t2 t2' ->

    dat_better t1 t2 ->

    depth >= n1 * n2 + datDepth t2 -> 

    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),

      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->

    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->

    (forall n t, rel n t -> datDepth t <= n)%nat ->

    dat_better t1' t2'.



  induction n2; induction t2; intuition.

  inversion H2; clear H2; subst.

  inversion H1; clear H1; subst.

  econstructor.

  inversion H1; clear H1; subst.

  inversion H; clear H; subst.

  econstructor.

  congruence.

  congruence.

  econstructor.



  inversion H2; clear H2; subst.

  inversion H1; clear H1; subst.

  inversion H; clear H; subst.

  simpl in *.

  rewrite mult_0_r in *.

  simpl in *.

  assert (depth0  >= (max (datDepth t2_1) (datDepth t2_2))).

  omega.



  econstructor.

  eapply IHt2_1.

  eauto.

  omega.

  eauto.

  eauto.

  rewrite mult_0_r; simpl. 

  eapply Max.max_lub_l.

  eauto.

  trivial.

  trivial.

  trivial.

  trivial.



  eapply IHt2_2.

  eauto.

  omega.

  eauto.

  trivial.

  rewrite mult_0_r; simpl. 

  eapply Max.max_lub_r.

  eauto.

  trivial.

  trivial.

  trivial.

  trivial.



  inversion H2; clear H2; subst.

  inversion H1; clear H1; subst.

  econstructor.

  inversion H1; clear H1; subst.

  inversion H; clear H; subst.

  econstructor.

  congruence.

  congruence.



  inversion H; clear H; subst.

  congruence.

  omega.

  

  rewrite mult_comm in H3.

  simpl in *.



  eapply IHn2.

  eauto.

  omega.

  eauto.

  eapply H4; eauto.

  remember (n2 * n1)%nat as x.

  omega.



  eapply le_trans.

  2:{

    eapply H3.

  }

  rewrite plus_0_r.

  rewrite plus_comm.

  eapply plus_le_compat.

  eauto.

  rewrite mult_comm.

  trivial.

  trivial.

  trivial.

  trivial.



  inversion H2; clear H2; subst.

  inversion H1; clear H1; subst.

  inversion H; clear H; subst.

  simpl in *.

  econstructor.

  eapply IHt2_1.

  eauto.

  trivial.

  eauto.

  trivial.

  eapply le_trans.

  eapply plus_le_compat.

  eapply le_refl.

  eapply (Max.max_lub_l (datDepth t2_1) (datDepth t2_2)).

  eapply le_refl.

  omega.

  trivial.

  trivial.

  trivial.

  

  eapply IHt2_2.

  eauto.

  trivial.

  eauto.

  trivial.

  eapply le_trans.

  eapply plus_le_compat.

  eapply le_refl.

  eapply (Max.max_lub_r (datDepth t2_1) (datDepth t2_2)).

  eapply le_refl.

  omega.

  trivial.

  trivial.

  trivial.

Qed.



Lemma dat_better_repeat_sqrt : forall (A : Set) (c : Comp A)(P : A -> bool)(n : nat) (t1 t2 : DistApproxTree A),

  (exists a, In a (filter P (getSupport c))) ->

  dat_correct_repeat c P n t1 ->

  dat_correct_repeat2 c P (Nat.sqrt (div2 n)) t2 -> 

  well_formed_comp c ->

  dat_better t1 t2.



  intuition.

  unfold dat_correct_repeat, dat_correct_repeat2 in *.

  destruct H0.

  destruct H1.

  intuition.

  

  eapply datRepeat_depth_better.

  eauto.

  2:{

    eauto.

  }



  eapply sqrt_le_lin_gen.

  eapply div2_le.

  eapply dat_correct_dat_better.

  eauto.

  eauto.

  eapply sqrt_le_lin_gen.

  eapply div2_le.

  

  eapply le_trans.

  eapply plus_le_compat.

  eapply Nat.sqrt_spec.

  omega.

  eapply le_trans.

  eapply datCorrect_datDepth.

  eauto.

  eapply Nat.sqrt_le_lin.

  eapply div2_ge_double.



  intuition.

  eapply dat_correct_dat_better; eauto.



  intuition.

  inversion H1; clear H1; subst.

  inversion H8; clear H8; subst.

  destruct H.

  assert (x1 = a).

  eapply evalDet_steps_nil_eq; eauto.

  eapply filter_In; eauto.

  subst.

  eapply filter_In; eauto.



  intuition.

  eapply datCorrect_datDepth; eauto.

  

Qed.



Lemma lowDistApprox_repeat_sqrt_le : forall n (A : Set)(c : Comp A)(P : A -> bool) a v1 v2,

  well_formed_comp c ->

  (exists a, In a (filter P (getSupport c))) ->

  lowDistApprox (Repeat c P) a n v1 ->

  lowDistApprox_repeat c P a (Nat.sqrt (div2 n)) v2 -> 

  n > 1 ->

  v2 <= v1.



  intuition.

  

  edestruct (dat_exists_repeat2).

  eauto.

  rewrite repeat_low_tree_approx_same_inv; eauto.

  destruct H0.

  edestruct dat_exists.

  eapply well_formed_Repeat.

  eapply comp_eq_dec; eauto.

  eauto.

  eauto.

  eapply leRat_trans.

  2:{

    eapply eqRat_impl_leRat.

    eapply low_tree_approx_same_inv.

    eapply H0.

    eapply H1.

  }

  

  eapply lowDistApprox_dat_better_le.

  eapply dat_correct_repeat_same in H0.

  eapply dat_better_repeat_sqrt; eauto.

  eauto.

  econstructor; eauto.



  destruct n.

  omega.

  destruct n.

  omega.

  simpl.

  

  eapply lt_le_trans.

  econstructor.

  eapply le_trans.

  rewrite <- Nat.sqrt_1.

  eauto.

  eapply Nat.sqrt_le_mono.

  omega.



  Grab Existential Variables.

  eapply comp_eq_dec; eauto.

  

Qed.



Lemma datRepeat_better_depth: forall (A : Set) n2 (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),

  forall n1 (t2' : DistApproxTree A),

    datRepeat (rel n1) P n2 t2 t2' ->

    datRepeat_depth rel P reps depth t1 t1' ->

    dat_better t2 t1 ->

    n1 >= depth ->

    n2 >= reps ->  

    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),

      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->

    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->

    (forall n t, rel n t -> datDepth t <= n)%nat ->

    dat_better t2' t1'.



  induction n2; induction t2; intuition.

  assert (reps = O).

  omega.

  subst.

  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor.

  inversion H0; clear H0; subst.

  inversion H; clear H; subst.

  econstructor.

  congruence.

  econstructor.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor.

  inversion H0; clear H0; subst.

  inversion H; clear H; subst.

  econstructor.

  eapply IHt2_1; eauto; omega.

  eapply IHt2_2; eauto; omega.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor.

  inversion H0; clear H0; subst.

  inversion H; clear H; subst.

  econstructor.

  congruence.

  econstructor.

  inversion H; clear H; subst.

  congruence.

  eapply IHn2.

  eauto.

  eauto.

  eapply H4; eauto.

  trivial.

  omega.

  trivial.

  trivial.

  trivial.



  inversion H1; clear H1; subst.

  inversion H0; clear H0; subst.

  econstructor.

  inversion H; clear H; subst.

  inversion H0; clear H0; subst.

  econstructor.

  eapply IHt2_1; eauto; omega.

  eapply IHt2_2; eauto; omega.

Qed.



Lemma dat_repeat_better:

  forall (A : Set) n (c : Comp A) (P : A -> bool)

    (t1 t2 : DistApproxTree A),

    (exists a : A, In a (filter P (getSupport c))) ->

    dat_correct_repeat c P n t1 ->

    dat_correct_repeat2 c P n t2 -> 

    dat_better t2 t1.



  intuition.

  unfold dat_correct_repeat, dat_correct_repeat2 in *.

  destruct H0.

  destruct H1.

  intuition.

  

  eapply datRepeat_better_depth.

  eauto.

  eauto.

  eapply dat_correct_dat_better.

  eauto.

  eauto.

  omega.

  omega.

  omega.

  

  intuition.

  eapply dat_correct_dat_better; eauto.



  intuition.

  inversion H1; clear H1; subst.

  inversion H7; clear H7; subst.

  destruct H.

  assert (x1 = a).

  eapply evalDet_steps_nil_eq; eauto.

  eapply filter_In; eauto.

  subst.

  eapply filter_In; eauto.

  

  intuition.

  destruct H.

  eapply datCorrect_datDepth.

  eauto.

Qed.



Lemma lowDistApprox_le_repeat:

  forall (n : nat) (A : Set) (c : Comp A) (P : A -> bool)(a : A) (v1 v2 : Rat),

    well_formed_comp c ->

    (exists a0 : A, In a0 (filter P (getSupport c))) ->

    lowDistApprox (Repeat c P) a n v1 ->

    lowDistApprox_repeat c P a n v2 -> 

    n > O ->

    v1 <= v2.



  intuition.

  edestruct dat_exists_repeat2.

  eauto.

  eapply leRat_trans.

  2:{

    eapply eqRat_impl_leRat.

    symmetry.

    eapply (repeat_low_tree_approx_same_inv); eauto.

  }



  destruct H0.

  edestruct dat_exists.

  eapply well_formed_Repeat; eauto.

  eapply comp_eq_dec; eauto.



  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  symmetry.

  eapply low_tree_approx_same_inv.

  eauto.

  eauto.

  

  apply lowDistApprox_dat_better_le.



  eapply dat_repeat_better.

  econstructor; eauto.

  eapply dat_correct_repeat_same; eauto.

  trivial.

  

  Grab Existential Variables.

  eapply comp_eq_dec; eauto.

Qed.



Lemma lowDistApprox_Rnd_lt : forall n1 n2 a r,

  lowDistApprox (Rnd n1) a n2 r ->

  n2 < n1 ->

  r == 0.

  

  intuition.

  unfold lowDistApprox in *.

  destruct H.

  destruct H.

  intuition.

  rewrite H3.

  assert (x0 = O).

  eapply pred_count_func.

  eauto.

  eapply pred_count_eq_none; intuition.

  subst.

  assert (x = (listRepeat (@ca_eof (Bvector n1)) (length (getAllBlists n2)))).

  eapply rel_map_func.

  eauto.

  eapply rel_map_listRepeat.

  intuition.

  econstructor.

  econstructor.

  eauto.

  simpl.

  

  rewrite shiftOut_lt.

  econstructor.

  erewrite getAllBlists_In_length.

  eauto.

  trivial.

  

  intuition.

  eapply evalDet_func; eauto.

  subst.

  apply in_listRepeat_inv in H2.

  discriminate.

  

  subst.

  eapply rat_num_0.

Qed.



Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) a s,

  evalDet_step c nil = (cs_done a s) ->

  getSupport c = a :: nil.

  

  induction c; intuition; simpl in *.

  inversion H; clear H; subst.

  trivial.

  

  case_eq (evalDet_step c nil); intuition;

    rewrite H1 in H0;

      try discriminate.

  

  destruct n; simpl.

  discriminate.

  discriminate.

  

  discriminate.

  

Qed.



Lemma lowDistApprox_low : forall (A : Set)(c : Comp A),

  well_formed_comp c -> 

  forall n a r, 

  lowDistApprox c a n r ->

  r <= evalDist c a.



  induction 1; intuition; simpl in *.

  

  rewrite lowDistApprox_Ret_inv; eauto.

  eapply leRat_refl.



  edestruct (lowDistApprox_bind_left_total); eauto.

  eapply leRat_trans.

  eapply lowDistApprox_le_bind;

  eauto.

  inversion H3; clear H3; subst.

  eapply sumList_rel_le.

  eauto.

  eapply sumList_rel_sumList.

  intuition.

  edestruct lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  eauto.

  edestruct lowDistApprox_left_total.

  eapply bind_eq_dec; eauto.

  eauto.

  rewrite H5; eauto.

  rewrite <- H6; eauto.

  eapply ratMult_leRat_compat; eauto.



  destruct (le_dec n n0).

  assert (exists n1, n0 = n + n1)%nat.

  exists (minus n0 n).

  omega.

  destruct H0.

  subst.

  rewrite lowDistApprox_Rnd; eauto.

  eapply leRat_terms; intuition.



  rewrite lowDistApprox_Rnd_lt.

  eapply rat0_le_all.

  eauto.

  omega.



  destruct n. 

  destruct H1.

  destruct H1.

  intuition.

  simpl in *.

  inversion H2; clear H2; subst.

  inversion H6; clear H6; subst.

  inversion H8; clear H8; subst.

  inversion H2; clear H2; subst.

  apply evalDet_steps_bind_done_inv in H8.

  destruct H8.

  destruct H2.

  intuition.

  apply filter_In in H0.

  intuition.

  assert (b = x).

  eapply evalDet_steps_nil_eq; eauto.

  subst.

  rewrite H6 in H5.

  inversion H5; clear H5; subst.

  simpl in *.

  inversion H10; clear H10; subst.

  inversion H1; clear H1; subst.

  inversion H9; clear H9; subst.

  inversion H7; clear H7; subst.

  rewrite H4.

  unfold indicator.

  rewrite H6.

  rewrite ratMult_1_l.



  erewrite evalDet_steps_done_support_singleton; eauto.

  unfold sumList; simpl.

  rewrite H6.

  simpl.



  rewrite <- ratMult_1_l.

  eapply ratMult_leRat_compat.



  rewrite <- ratInverse_1.

  eapply eqRat_impl_leRat.

  eapply ratInverse_eqRat_compat.

  eapply rat1_ne_rat0.

  rewrite <- ratAdd_0_l.

  rewrite (evalDet_steps_done_evalDist eqd); eauto.

  destruct (eqd a0 a0).

  intuition.

  congruence.

  eapply eqRat_impl_leRat.

  rewrite (evalDet_steps_done_evalDist eqd); eauto.

  destruct (eqd a0 a0).

  eapply num_dem_same_rat1.

  unfold natToPosnat, posnatToNat.

  trivial.

  congruence.

  inversion H7; clear H7; subst.

  rewrite H4.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply rat_num_0.

  eapply rat0_le_all.

  inversion H1; clear H1; subst.

  discriminate.

  inversion H6; clear H6; subst.

  rewrite H4.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply rat_num_0.

  eapply rat0_le_all.



  edestruct lowDistApprox_repeat_left_total; eauto.

  eapply leRat_trans.

  eapply lowDistApprox_le_repeat; eauto.

  omega.

  unfold lowDistApprox_repeat in *.

  unfold ratMult_rel, expRat_rel, indicator_rel in *.

  edestruct lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  eauto.



  edestruct (sumList_rel_left_total

    (fun a1 : A => lowDistApprox c a1 (S n))

       (filter (fun a1 : A => negb (P a1)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total; eauto.



  edestruct (sumList_rel_left_total

     (fun (i : nat) (r : Rat) =>

          forall r1' : Rat,

          sumList_rel (fun a : A => lowDistApprox c a (S n))

            (filter (fun a : A => negb (P a)) (getSupport c)) r1' ->

          r == expRat r1' i) 

     (getNats 0 (S (S n)))).

  intuition.  

  econstructor.

  intuition.

  eapply expRat_eqRat_compat; eauto.

  eapply sumList_rel_func.

  eapply H4.

  trivial.

  intuition.

  eapply lowDistApprox_func; eauto.



  case_eq (P a); intuition.

  rewrite H2; eauto.

  2:{

    intuition.

    eapply ratMult_eqRat_compat.

    symmetry.

    eauto.

    eapply sumList_rel_func.

    eapply H5.

    eapply H8.

    intuition.

    rewrite H9.

    rewrite H11.

    eapply eqRat_refl.

    eauto.

    trivial.

    congruence.

  }

  eapply ratMult_leRat_compat.

  eapply ratMult_leRat_compat.

  unfold indicator.

  rewrite H6.

  intuition.



  rewrite (@sum_power_series (S (S n)) (sumList_rel (fun a : A => lowDistApprox c a (S n))

            (filter (fun a : A => negb (P a)) (getSupport c)))); eauto; try omega.

  2:{

    intuition.

    eapply sumList_rel_func; eauto.

    intuition.

    eapply lowDistApprox_func;

    eauto.

  }

 

  3:{

    unfold ratMult_rel, ratSubtract_rel, expRat_rel, ratInverse_rel.

    intuition.

    rewrite H7.

    rewrite H8.

    eapply eqRat_refl.

    intuition.

    eapply ratSubtract_eqRat_compat.

    eauto.

    eapply sumList_rel_func.

    eapply H4.

    trivial.

    intuition.

    eapply lowDistApprox_func; eauto.

    eapply eqRat_refl.

    intuition.

    eapply expRat_eqRat_compat.

    eapply sumList_rel_func.

    eapply H4.

    trivial.

    intuition.

    eapply lowDistApprox_func; eauto.

  }

  eapply leRat_trans.

  eapply ratMult_leRat_compat.

  eapply ratSubtract_le.

  eapply leRat_refl.

  

  eapply ratInverse_leRat.

  2:{

    eapply ratSubtract_leRat.

    eapply leRat_refl.

    eapply sumList_rel_le.

    eauto.

    eapply sumList_rel_sumList.

    intuition.

    rewrite <- H9.

    eapply IHwell_formed_comp.

    eauto.

  }

  intuition.

  eapply getSupport_In_evalDist.

  eapply filter_In; eauto.

  eapply sumList_0.

  rewrite <- evalDist_lossless in H7.

  rewrite sumList_filter_partition in H7.

  rewrite ratAdd_comm in H7.

  rewrite ratSubtract_ratAdd_inverse in H7.

  eapply H7.

  trivial.

  trivial.



  rewrite ratMult_1_l.

  eapply eqRat_impl_leRat.

  eapply ratInverse_eqRat_compat.

  

  intuition.

  eapply getSupport_In_evalDist.

  eapply filter_In; eauto.

  eapply sumList_0.

  rewrite <- evalDist_lossless in H7.

  rewrite sumList_filter_partition in H7.

  rewrite ratAdd_comm in H7.

  rewrite ratSubtract_ratAdd_inverse in H7.

  eapply H7.

  trivial.

  trivial.



  rewrite <- (evalDist_lossless); eauto.

  rewrite (sumList_filter_partition).

  rewrite ratAdd_comm.

  rewrite ratSubtract_ratAdd_inverse.

  intuition.

 

  intuition.



  eapply ratAdd_not_leRat.

  erewrite <- sumList_filter_partition.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply evalDist_lossless.

  eauto.

  eapply leRat_trans.

  eapply H8.

  eapply sumList_rel_le.

  eauto.

  eapply sumList_rel_sumList.

  intuition.

  rewrite <- H11.

  eapply IHwell_formed_comp.

  eauto.

  intuition.



  eapply sumList_0 in H9.

  eapply getSupport_In_evalDist; eauto.

  eapply filter_In; eauto.

  eapply filter_In.

  intuition.

  eapply filter_In; eauto.

  rewrite negb_involutive.

  eapply filter_In; eauto.

  

  eapply IHwell_formed_comp; eauto.



  rewrite H2; eauto.

  2:{

    intuition.

    congruence.

    eapply ratMult_eqRat_compat.

    symmetry.

    eauto.

    eapply sumList_rel_func.

    eapply H5.

    trivial.

    intuition.

    rewrite H9; eauto.

    rewrite H11; eauto.

    intuition.

  }

  repeat rewrite ratMult_0_l.

  eapply rat0_le_all.

Qed.



Lemma lowDistApprox_repeat_scale_limit : forall (A : Set)(c : Comp A)(P : A -> bool),

  well_formed_comp c ->

  (exists a, In a (filter P (getSupport c))) ->

  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) -> 

  rat_inf_limit

     (fun n : nat =>

      sumList_rel

        (fun i : nat =>

         expRat_rel

           (sumList_rel (fun a0 : A => lowDistApprox c a0 n)

              (filter (fun a0 : A => negb (P a0)) (getSupport c))) i)

        (getNats O n))

     (ratInverse (sumList (filter P (getSupport c)) (evalDist c))).



  intuition.



  eapply rat_inf_limit_eq.

  eapply power_series_limit_2.

  eapply rat_inf_limit_summation.

  eauto.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply lowDistApprox_func; eauto.



  intuition.

  destruct H0.



  assert (sumList (filter (fun a0 : A => negb (P a0)) (getSupport c)) (evalDist c) == 1).

  eapply leRat_impl_eqRat.

  eapply leRat_trans.

  

  eapply sumList_filter_le.

  rewrite evalDist_lossless.

  intuition.

  trivial.

  eapply leRat_trans.

  eapply H3.



  eapply sumList_rel_le.

  eapply H2.

  eapply sumList_rel_sumList.

  intuition.

  rewrite <- H6.

  eapply lowDistApprox_low.

  eauto.

  eauto. 

  

  rewrite <- evalDist_lossless in H4; eauto.

  rewrite (sumList_filter_partition P (getSupport c)) in H4.

 

  symmetry in H4.

  rewrite ratAdd_comm in H4.

  apply ratAdd_arg_0 in H4.

  eapply sumList_0 in H4; eauto.

  eapply getSupport_In_evalDist.

  eapply filter_In; eauto.

  trivial.



  destruct H0.

  intuition.



  eapply sumList_filter_evalDist_le_1; eauto.

    

  intuition.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  

  eapply ratInverse_eqRat_compat.

  intuition.

  apply ratSubtract_0_inv in H2.

  destruct H0.

  eapply sumList_filter_evalDist_le_1; eauto.



  eapply (@eqRat_ratAdd_same_r (sumList (filter (fun a => negb (P a)) (getSupport c)) (evalDist c))).

  rewrite <- sumList_filter_partition.

  rewrite evalDist_lossless.



  rewrite ratAdd_comm.

  rewrite ratSubtract_ratAdd_inverse_2.

  intuition.

  eapply leRat_trans.

  eapply sumList_filter_le.

  rewrite evalDist_lossless.

  intuition.

  trivial.

  trivial.



Qed.



Lemma lowDistApprox_repeat_limit : forall (A : Set)(c : Comp A)(P : A -> bool) a,

  well_formed_comp c ->

  (exists b, In b (filter P (getSupport c))) ->

  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) ->

  rat_inf_limit (lowDistApprox_repeat c P a) (evalDist (Repeat c P) a).



  intuition.



  unfold lowDistApprox_repeat.

  simpl.

  eapply rat_inf_limit_product; trivial.

  unfold left_total.

  intuition.

  edestruct (sumList_rel_left_total (fun a1 => lowDistApprox c a1 n)  (filter (fun a1 : A => negb (P a1)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  edestruct (sumList_rel_left_total (fun i : nat =>

           expRat_rel

             (sumList_rel (fun a1 : A => lowDistApprox c a1 n)

                (filter (fun a1 : A => negb (P a1)) (getSupport c))) i)

          (getNats 0 (S n))).

  intuition.

  unfold expRat_rel.

  exists (expRat x a0).

  intuition.



  eapply expRat_eqRat_compat.



  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.



  unfold ratMult_rel, indicator_rel.

  exists ((if (P a) then 1 else 0) * x0).

  intuition.

  rewrite H4.

  rewrite H7.

  repeat rewrite ratMult_1_l.

  eapply sumList_rel_func; eauto.

  intuition.

  unfold expRat_rel in *.

  edestruct (sumList_rel_left_total (fun a1 : A => lowDistApprox c a1 n)

         (filter (fun a1 : A => negb (P a1)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  rewrite H6; eauto.

  rewrite H8; eauto.

  intuition.

  

  rewrite H4.

  rewrite H7.

  repeat rewrite ratMult_0_l.

  intuition.



  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.



  eapply rat_inf_limit_product.

  unfold left_total, indicator_rel.

  intuition.

  exists (if (P a) then 1 else 0).

  destruct (P a); intuition.

  

  unfold left_total.

  intuition.

  edestruct (sumList_rel_left_total (fun a0 : A => lowDistApprox c a0 n)

              (filter (fun a0 : A => negb (P a0)) (getSupport c))).

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.



  eapply sumList_rel_left_total.

  intuition.

  unfold expRat_rel.

  exists (expRat x a0).

  intuition.

  eapply expRat_eqRat_compat.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.



  unfold rat_inf_limit, inf_limit, indicator_rel. intuition.

  exists O.

  intuition;

  unfold indicator.

  rewrite H6.

  rewrite H4.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  rewrite <- ratIdentityIndiscernables.

  intuition.

  eapply rat0_le_all.

  rewrite H6.

  rewrite H4.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  rewrite <- ratIdentityIndiscernables.

  intuition.

  eapply rat0_le_all.



  eapply (@rat_inf_limit_trans _ (fun n : nat =>

    (ratAdd_rel (expRat_rel

           (sumList_rel (fun a0 : A => lowDistApprox c a0 n)

              (filter (fun a0 : A => negb (P a0)) (getSupport c))) n)

      (sumList_rel

        (fun i : nat =>

         expRat_rel

           (sumList_rel (fun a0 : A => lowDistApprox c a0 n)

              (filter (fun a0 : A => negb (P a0)) (getSupport c))) i)

        (getNats 0 n))))).



  unfold rat_inf_limit_2, inf_limit_2.

  intuition.

  exists O.

  intuition.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  rewrite <- ratIdentityIndiscernables.

  inversion H4; clear H4; subst.

  unfold ratAdd_rel in *.

  rewrite H11.

  rewrite H5; eauto.

  intuition.

  eapply rat0_le_all.



  eapply rat_inf_limit_eq.

  eapply rat_inf_limit_sum.

  unfold left_total. intuition.

  eapply expRat_rel_left_total.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  

  unfold left_total. intuition.

  eapply sumList_rel_left_total.

  intuition.

  eapply expRat_rel_left_total.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.



  eapply rat_inf_limit_exp_0.

  eapply rat_inf_limit_summation.

  eapply H1.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply lowDistApprox_func; eauto.

  intuition.



  assert (sumList (filter (fun a0 : A => negb (P a0)) (getSupport c)) (evalDist c) == 1).

  eapply leRat_impl_eqRat.

  eapply leRat_trans.

  

  eapply sumList_filter_le.

  rewrite evalDist_lossless.

  intuition.

  trivial.

  eapply H2.

  clear H2.

  

  rewrite <- evalDist_lossless in H3; eauto.

  rewrite (sumList_filter_partition P (getSupport c)) in H3.

 

  destruct H0.

  symmetry in H3.

  rewrite ratAdd_comm in H3.

  apply ratAdd_arg_0 in H3.

  eapply sumList_0 in H3; eauto.

  eapply getSupport_In_evalDist.

  eapply filter_In; eauto.

  trivial.



  intuition.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  

  eapply lowDistApprox_repeat_scale_limit.

  trivial.

  trivial.

  trivial.

  rewrite <- ratAdd_0_l.

  intuition.



  unfold left_total. 

  intuition.

  eapply ratAdd_rel_left_total.

  eapply expRat_rel_left_total.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  eapply sumList_rel_left_total.

  intuition.

  eapply expRat_rel_left_total.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  intuition.



  eapply expRat_rel_func; eauto.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  eapply sumList_rel_left_total.

  intuition.

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; eauto.

  trivial.

  

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply expRat_rel_func; eauto.

  intuition.

  eapply sumList_rel_func; eauto.

  intuition.

  eapply lowDistApprox_func; eauto.

  eapply sumList_rel_left_total; eauto.

  intuition.

  eapply lowDistApprox_left_total; eauto.

  eapply comp_eq_dec; eauto.

Qed.



Lemma lowDistApprox_limit_repeat : forall (A : Set)(c : Comp A)(P : A -> bool) a,

  well_formed_comp c ->

  (exists a, In a (filter P (getSupport c))) ->

  (forall a', rat_inf_limit (lowDistApprox c a') (evalDist c a')) ->

  rat_inf_limit (lowDistApprox (Repeat c P) a) (evalDist (Repeat c P) a).



  intuition.

  eapply (@rat_inf_limit_squeeze (fun n => (lowDistApprox_repeat c P a (Nat.sqrt (div2 n)))) (fun n => eqRat (evalDist (Repeat c P) a))).



  eapply rat_inf_limit_mono.

  eapply lowDistApprox_repeat_limit; trivial.

  intuition.

  eapply Nat.sqrt_le_mono.



  eapply div2_le_mono.

  trivial.



  intuition.

  exists (2 * (y * y))%nat.

  rewrite div2_double.

  rewrite Nat.sqrt_square.

  trivial.



  eapply rat_inf_limit_const.

  intuition.

  intuition.

  rewrite <- H2.

  rewrite H3.

  intuition.



  intuition.

  eapply lowDistApprox_repeat_sqrt_le; eauto.

  intuition.

  eapply leRat_trans.

  2:{

    eapply eqRat_impl_leRat.

    eapply H4.

  }

  eapply lowDistApprox_low.

  destruct H0.

  eapply well_formed_Repeat; eauto.

  eapply comp_eq_dec; eauto.

  eauto.

  

  eapply lowDistApprox_repeat_sqrt_div2_left_total. 



  unfold left_total; intuition.

  econstructor.

  eapply eqRat_refl.



Qed.



Theorem evalDet_evalDist_equiv : forall (A : Set)(c : Comp A),

  well_formed_comp c ->

  forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a).



  induction 1; intuition.

  unfold rat_inf_limit, inf_limit in *; intuition.

  exists O.

  intuition.

  simpl.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  

  eapply (ratIdentityIndiscernables a').

  eapply lowDistApprox_Ret_inv. eauto.

  eapply rat0_le_all.

 

  eapply (@rat_inf_limit_squeeze (fun n => lowDistApprox_bind c1 c2 a (div2 n)) (lowDistApprox_bind c1 c2 a)); intuition.

  eapply rat_inf_limit_div_2.

  eapply lowDistApprox_bind_evalDist_limit; eauto.

  eapply lowDistApprox_bind_evalDist_limit; eauto.

    

  eapply lowDistApprox_bind_le_div2; eauto.

  eapply lowDistApprox_le_bind; eauto.



  eapply lowDistApprox_bind_div2_left_total; trivial.

  eapply lowDistApprox_bind_left_total; trivial.



  exists n.

  intuition.

  simpl.

  eapply leRat_trans.

  eapply eqRat_impl_leRat.

  eapply (ratIdentityIndiscernables a').

  assert (exists n'', n' = n + n'')%nat.

  exists (n' - n).

  omega.

  destruct H2.

  subst.



  rewrite lowDistApprox_Rnd.

  eapply eqRat_terms; intuition.

  eauto.

  eapply rat0_le_all.



  eapply lowDistApprox_limit_repeat.

  trivial.

  econstructor; eauto.

  trivial.



  Grab Existential Variables.

  

  eapply O.

  

Qed.



Lemma evalDet_equiv_impl_lowDistApprox_equiv : 

  forall (A : Set)(c1 c2 : Comp A), 

    evalDet_equiv c1 c2 ->

    forall a n r,

      lowDistApprox c1 a n r <-> lowDistApprox c2 a n r.

  

  intuition.

  unfold lowDistApprox, evalDet_equiv in *.

  destruct H0. destruct H0. intuition.

  exists x.

  exists x0.

  intuition.

  

  eapply rel_map_impl.

  eapply H1.

  intuition.

  eapply H.

  trivial.

  

  unfold lowDistApprox, evalDet_equiv in *.

  destruct H0. destruct H0. intuition.

  exists x.

  exists x0.

  intuition.

  

  eapply rel_map_impl.

  eapply H1.

  intuition.

  eapply H.

  trivial.    

  

Qed.



Theorem det_eq_impl_dist_sem_eq : forall (A : Set)(c1 c2 : Comp A),

  well_formed_comp c1 ->

  well_formed_comp c2 -> 

  evalDet_equiv c1 c2 -> 

  dist_sem_eq c1 c2.



  unfold dist_sem_eq.

  intuition.



  eapply rat_limits_eq.

  2:{

    eapply evalDet_evalDist_equiv.

    trivial.

  }

  eapply lowDistApprox_left_total.

  eapply comp_eq_dec; trivial.

  trivial.

  eapply limit_f_eq.

  eapply evalDet_evalDist_equiv.

  trivial.

  eapply evalDet_equiv_impl_lowDistApprox_equiv.

  eapply evalDet_equiv_symm. trivial.



Qed.



Print Assumptions det_eq_impl_dist_sem_eq.
