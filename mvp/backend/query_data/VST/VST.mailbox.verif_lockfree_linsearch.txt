Require Import mailbox.verif_atomics.

Require Import VST.progs.conclib.
(* VST.progs.conclib:
Require Import VST.veric.ghost_PCM.
Require Export VST.msl.iter_sepcon.
Require Export VST.concurrency.semax_conc_pred.
Require Export VST.concurrency.semax_conc.
Require Export VST.floyd.proofauto.
Require Import VST.floyd.library.
Require Export VST.floyd.sublist.

Notation vint z := (Vint (Int.repr z)).
Notation vptrofs z := (Vptrofs (Ptrofs.repr z)).

Lemma app_cons_assoc : forall {A} l1 (x : A) l2, l1 ++ x :: l2 = (l1 ++ [x]) ++ l2.

Lemma Forall_forall_Znth : forall {A}{d: Inhabitant A} (P : A -> Prop) l,
  Forall P l <-> forall i, 0 <= i < Zlength l -> P (Znth i l).

Lemma Zmod_smallish : forall x y, y <> 0 -> 0 <= x < 2 * y ->
  x mod y = x \/ x mod y = x - y.

Lemma Zmod_plus_inv : forall a b c d (Hc : c > 0) (Heq : (a + b) mod c = (d + b) mod c),
  a mod c = d mod c.

Lemma Znth_app : forall {A}{d: Inhabitant A} (l1 l2 : list A) i,
      Zlength l1 = i -> Znth i (l1 ++ l2) = Znth 0 l2.

Corollary Znth_app1 : forall {A}{d: Inhabitant A} l1 (x : A) l2 i,
     Zlength l1 = i -> Znth i (l1 ++ x :: l2) = x.

Lemma repable_0 : repable_signed 0.
Hint Resolve repable_0.

Definition complete MAX l := l ++ repeat (vptrofs 0) (Z.to_nat MAX - length l).

Lemma upd_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX l) x = complete MAX (l ++ [x]).

Lemma Znth_complete : forall n l MAX, n < Zlength l -> 
     Znth n (complete MAX l) = Znth n l.

Lemma remove_complete : forall l x MAX, Zlength l < MAX ->
  upd_Znth (Zlength l) (complete MAX (l ++ [x])) (vptrofs 0) = complete MAX l.

Lemma Forall_app : forall {A} (P : A -> Prop) l1 l2,
  Forall P (l1 ++ l2) <-> Forall P l1 /\ Forall P l2.

Lemma Forall_incl : forall {A} (P : A -> Prop) l1 l2 (Hall : Forall P l2) (Hincl : incl l1 l2),
  Forall P l1.

Lemma repeat_plus : forall {A} (x : A) i j, repeat x (i + j) = repeat x i ++ repeat x j.

Lemma in_insert_iff : forall {A} (x y : A) l1 l2, In x (l1 ++ y :: l2) <-> x = y \/ In x (l1 ++ l2).

Definition remove_at {A} i (l : list A) := firstn i l ++ skipn (S i) l.

Lemma Forall_firstn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (firstn i l).

Lemma Forall_skipn : forall {A} (P : A -> Prop) l i, Forall P l ->
  Forall P (skipn i l).

Lemma Forall_upd_Znth : forall {A} (P : A -> Prop) x l i, Forall P l -> P x ->
  Forall P (upd_Znth i l x).

Lemma last_cons : forall {A} (d : A) l x, l <> [] -> last (x :: l) d = last l d.

Lemma nth_last : forall {A} (d : A) l, nth (length l - 1) l d = last l d.

Lemma Znth_last : forall {A}{d: Inhabitant A} l, Znth (Zlength l - 1) l = last l default.

Lemma last_app : forall {A} l1 l2 (d : A), l2 <> [] -> last (l1 ++ l2) d = last l2 d.

Lemma nat_sorted_list_eq : forall d n l (Hl : forall i, (i < n)%nat <-> In i l) (Hlen : length l = n)
  (Hsorted : forall i j, (i < j < n -> nth i l d < nth j l d)%nat) i (Hi : (i < n)%nat), nth i l d = i.

Lemma Forall2_In_l : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l1 ->
  exists y, In y l2 /\ P x y.

Lemma Forall2_In_r : forall {A B} (P : A -> B -> Prop) x l1 l2, Forall2 P l1 l2 -> In x l2 ->
  exists y, In y l1 /\ P y x.

Lemma last_snoc : forall {A} (d : A) x l, last (l ++ [x]) d = x.

Lemma iter_sepcon_sepcon: forall {A} f g1 g2 l, (forall b : A, f b = g1 b * g2 b) ->
  iter_sepcon f l = iter_sepcon g1 l * iter_sepcon g2 l.

Lemma sepcon_app : forall l1 l2, fold_right sepcon emp (l1 ++ l2) =
  fold_right sepcon emp l1 * fold_right sepcon emp l2.

Definition rotate {A} (l : list A) n m := sublist (m - n) (Zlength l) l ++
  sublist 0 (m - n) l.

Lemma sublist_of_nil : forall {A} i j, sublist i j (@nil A) = [].

Lemma sublist_0_cons : forall {A} j x (l : list A), j > 0 ->
  sublist 0 j (x :: l) = x :: sublist 0 (j - 1) l.

Lemma sublist_S_cons : forall {A} i j x (l : list A), i > 0 ->
  sublist i j (x :: l) = sublist (i - 1) (j - 1) l.

Lemma upd_rotate : forall {A} i (l : list A) n m x (Hl : Zlength l = m) (Hlt : 0 <= n <= m)
  (Hi : 0 <= i < Zlength l),
  upd_Znth i (rotate l n m) x = rotate (upd_Znth ((i - n) mod m) l x) n m.

Lemma Znth_cons_eq : forall {A}{d : Inhabitant A} i x l, 
   Znth i (x :: l) = if eq_dec i 0 then x else Znth (i - 1) l.

Lemma Znth_rotate : forall {A} {d : Inhabitant A} i l n, 
    0 <= n <= Zlength l -> 0 <= i < Zlength l ->
  Znth i (rotate l n (Zlength l)) = Znth ((i - n) mod Zlength l) l.

Lemma rotate_nil : forall {A} n m, rotate (@nil A) n m = [].

Lemma Forall_sublist_le : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i) (Hrangej : j <= Zlength l) (Hi : ~P (Znth i l)) (Hj : Forall P (sublist 0 j l)),
  j <= i.

Corollary Forall_sublist_first : forall {A} {d : Inhabitant A} (P : A -> Prop) i j l
  (Hrangei : 0 <= i <= Zlength l) (Hi : Forall P (sublist 0 i l)) (Hi' : ~P (Znth i l))
  (Hrangej : 0 <= j <= Zlength l) (Hj : Forall P (sublist 0 j l)) (Hj' : ~P (Znth j l)),
  i = j.

Lemma NoDup_Znth_inj : forall {A} {d : Inhabitant A} l i j (HNoDup : NoDup l)
  (Hi : 0 <= i < Zlength l) (Hj : 0 <= j < Zlength l) (Heq : Znth i l = Znth j l ),
  i = j.

Lemma rotate_In : forall {A} (x : A) n m l, 0 <= m - n <= Zlength l -> In x (rotate l n m) <-> In x l.

Lemma rotate_map : forall {A B} (f : A -> B) n m l, rotate (map f l) n m = map f (rotate l n m).

Lemma combine_app : forall {A B} (l1 l2 : list A) (l1' l2' : list B), length l1 = length l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma combine_app' : forall {A B} (l1 l2 : list A) (l1' l2' : list B), Zlength l1 = Zlength l1' ->
  combine (l1 ++ l2) (l1' ++ l2') = combine l1 l1' ++ combine l2 l2'.

Lemma Forall_rotate : forall {A} P (l : list A) n m, Forall P l ->
  Forall P (rotate l m n).

Lemma Forall_repeat : forall {A} (P : A -> Prop) x n, P x -> Forall P (repeat x n).

Lemma Forall_complete : forall P l m, Forall P l -> P (vptrofs 0) ->
  Forall P (complete m l).

Lemma app_eq_inv : forall {A} (l1 l2 l3 l4 : list A)
  (Heq : l1 ++ l2 = l3 ++ l4) (Hlen : length l1 = length l3), l1 = l3 /\ l2 = l4.

Lemma rotate_inj : forall {A} (l1 l2 : list A) n m, rotate l1 n m = rotate l2 n m ->
  length l1 = length l2 -> 0 <= n <= m -> m <= Zlength l1 -> l1 = l2.

Lemma complete_inj : forall l1 l2 m, complete m l1 = complete m l2 ->
  length l1 = length l2 -> l1 = l2.

Lemma length_complete : forall l m, Zlength l <= m -> length (complete m l) = Z.to_nat m.

Lemma Zlength_rotate : forall {A} (l : list A) n m, 0 <= n <= m -> m <= Zlength l ->
  Zlength (rotate l n m) = Zlength l.

Lemma Zlength_repeat : forall {A} (x : A) n, Zlength (repeat x n) = Z.of_nat n.

Lemma Zlength_complete : forall l m, Zlength l <= m -> Zlength (complete m l) = m.

Lemma combine_eq : forall {A B} (l : list (A * B)), combine (map fst l) (map snd l) = l.

Lemma signed_inj : forall i1 i2, Int.signed i1 = Int.signed i2 -> i1 = i2.

Lemma mods_repr : forall a b, 0 <= a <= Int.max_signed -> 0 < b <= Int.max_signed ->

Lemma repeat_list_repeat : forall {A} n (x : A), repeat x n = list_repeat n x.

Lemma sublist_repeat : forall {A} i j k (v : A), 0 <= i -> i <= j <= k ->
  sublist i j (repeat v (Z.to_nat k)) = repeat v (Z.to_nat (j - i)).

Lemma Znth_head : forall reqs head m, Zlength reqs <= m -> 0 <= head < m ->
  Zlength reqs > 0 ->
  Znth head (rotate (complete m reqs) head m) = Znth 0 reqs.

Lemma Znth_repeat : forall {A} {x : Inhabitant A} n i, Znth i (repeat default n) = default.

Lemma Znth_repeat' : forall {A} {d: Inhabitant A} (x : A) n i, 
    0 <= i < Z.of_nat n -> Znth i (repeat x n)  = x.

Lemma rotate_1 : forall v l n m, 0 <= n < m -> Zlength l < m ->
  rotate (upd_Znth 0 (complete m (v :: l)) (vptrofs 0)) n m =
  rotate (complete m l) ((n + 1) mod m) m.

Lemma upd_complete_gen : forall {A} (l : list A) x n y, Zlength l < n ->
  upd_Znth (Zlength l) (l ++ repeat y (Z.to_nat (n - Zlength l))) x =

Lemma upd_complete' : forall l x n, (length l < n)%nat ->
  upd_Znth (Zlength l) (map Vint (map Int.repr l) ++ repeat Vundef (n - length l)) (Vint (Int.repr x)) =

Fixpoint upto n :=
  match n with
  | O => []
  | S n' => 0 :: map Z.succ (upto n')
  end.

Opaque Z.of_nat.

Lemma upto_app : forall n m, upto (n + m) = upto n ++ map (fun i => Z.of_nat n + i) (upto m).

Lemma upto_length : forall n, length (upto n) = n.

Corollary Zlength_upto : forall n, Zlength (upto n) = Z.of_nat n.

Lemma skipn_cons : forall {A}{d: Inhabitant A} n (l : list A), (length l > n)%nat ->
  skipn n l = Znth (Z.of_nat n) l :: skipn (S n) l.

Lemma Znth_upto : forall d m n, 
  0 <= n < Z.of_nat m -> @Znth _ d n (upto m) = n.

Transparent Z.of_nat.

Lemma In_Znth : forall {A} {d: Inhabitant A} (l : list A) x,
    In x l ->
    exists i, 0 <= i < Zlength l /\ Znth i l = x.

Lemma In_upd_Znth_old : forall {A}{d: Inhabitant A} i (x y : A) l, In x l -> x <> Znth i l -> 0 <= i <= Zlength l ->
  In x (upd_Znth i l y).

Lemma Znth_combine : forall {A B} {a: Inhabitant A} {b: Inhabitant B} i (l1: list A) (l2: list B), 
   Zlength l1 = Zlength l2 ->
  Znth i (combine l1 l2) = (Znth i l1, Znth i l2).

Lemma Zlength_combine : forall {A B} (l : list A) (l' : list B),
  Zlength (combine l l') = Z.min (Zlength l) (Zlength l').

Lemma nth_Znth : forall {A}{d: Inhabitant A} i l, nth i l default = Znth (Z.of_nat i) l.

Lemma upd_Znth_cons : forall {A} i a l (x : A), i > 0 ->
  upd_Znth i (a :: l) x = a :: upd_Znth (i - 1) l x.

Lemma upd_Znth_triv : forall {A}{d: Inhabitant A} i (l : list A) x (Hi : 0 <= i < Zlength l),
  Znth i l = x -> upd_Znth i l x = l.

Lemma combine_upd_Znth : forall {A B} (l1 : list A) (l2 : list B) i x1 x2, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine (upd_Znth i l1 x1) (upd_Znth i l2 x2) = upd_Znth i (combine l1 l2) (x1, x2).

Corollary combine_upd_Znth1 : forall {A B}{d: Inhabitant B} (l1 : list A) (l2 : list B) i x,
   0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 ->
   combine (upd_Znth i l1 x) l2 = upd_Znth i (combine l1 l2) (x, Znth i l2).

Corollary combine_upd_Znth2 : forall {A B}{d: Inhabitant A} (l1 : list A) (l2 : list B) i x, 0 <= i < Zlength l1 ->
  Zlength l1 = Zlength l2 -> combine l1 (upd_Znth i l2 x) = upd_Znth i (combine l1 l2) (Znth i l1, x).

Lemma in_concat : forall {A} (l : list (list A)) x, In x (concat l) <-> exists l1, In x l1 /\ In l1 l.

Lemma length_concat : forall {A} (l : list (list A)), length (concat l) = fold_right plus O (map (@length A) l).

Lemma length_concat_min : forall {A}{d: Inhabitant A} (l : list (list A)) i (Hi : 0 <= i < Zlength l),
  (length (Znth i l) <= length (concat l))%nat.

Lemma length_concat_upd : forall {A} {d: Inhabitant A} l i (l' : list A) (Hi : 0 <= i < Zlength l),
  length (concat (upd_Znth i l l')) = (length (concat l) + length l' - length (Znth i l))%nat.

Lemma sepcon_rev : forall l, fold_right sepcon emp (rev l) = fold_right sepcon emp l.

Lemma incl_nil : forall {A} (l : list A), incl [] l.
Hint Resolve incl_nil.

Lemma incl_cons_out : forall {A} (a : A) l1 l2, incl l1 (a :: l2) -> ~In a l1 -> incl l1 l2.

Lemma In_upto : forall n i, In i (upto n) <-> 0 <= i < Z.of_nat n.

Lemma combine_fst : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map fst (combine l l') = l.

Lemma combine_snd : forall {A B} (l : list A) (l' : list B), length l = length l' ->
  map snd (combine l l') = l'.

Lemma rev_combine : forall {A B} (l1 : list A) (l2 : list B), length l1 = length l2 ->
  rev (combine l1 l2) = combine (rev l1) (rev l2).

Lemma combine_map_snd : forall {A B C} (l1 : list A) (l2 : list B) (f : B -> C),
  combine l1 (map f l2) = map (fun x => let '(a, b) := x in (a, f b)) (combine l1 l2).

Lemma combine_const1 : forall {A B} (l1 : list A) (x : B) n, Z.of_nat n >= Zlength l1 ->

Lemma combine_const2 : forall {A B} (x : A) n (l2 : list B), Z.of_nat n >= Zlength l2 ->

Lemma map_const: forall {A B} (c : A) (l : list B), map (fun _ => c) l = repeat c (length l).

Lemma In_upd_Znth : forall {A} i l (x y : A), In x (upd_Znth i l y) -> x = y \/ In x l.

Lemma upd_Znth_In : forall {A} i l (x : A), In x (upd_Znth i l x).

Lemma NoDup_Znth_iff : forall {A}{d: Inhabitant A} (l : list A),
  NoDup l <-> forall i j (Hi : 0 <= i < Zlength l)
                            (Hj : 0 <= j < Zlength l), Znth i l = Znth j l -> i = j.

Lemma concat_less_incl : forall {A} l i (l1 l2 : list A) (Hi : 0 <= i < Zlength l)
  (Hless : Znth i l = l1 ++ l2), incl (concat (upd_Znth i l l1)) (concat l).

Lemma NoDup_app : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) ->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Lemma NoDup_app_iff : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <->
  NoDup l1 /\ NoDup l2 /\ forall x, In x l1 -> ~In x l2.

Corollary NoDup_app_swap : forall {A} (l1 l2 : list A), NoDup (l1 ++ l2) <-> NoDup (l2 ++ l1).

Lemma NoDup_concat_less : forall {A} l i (l1 l2 : list A) (Hl : NoDup (concat l))
  (Hi : 0 <= i < Zlength l) (Hless : Znth i l = l1 ++ l2),
  NoDup (concat (upd_Znth i l l1)).

Lemma Forall2_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2 (Hall : Forall2 P l1 l2) i
  (Hi : 0 <= i < Zlength l1), P (Znth i l1) (Znth i l2).

Lemma Forall2_app_inv : forall {A B} (P : A -> B -> Prop) l1 l2 l3 l4 (Hlen : length l1 = length l3),
  Forall2 P (l1 ++ l2) (l3 ++ l4) -> Forall2 P l1 l3 /\ Forall2 P l2 l4.

Lemma Forall2_firstn : forall {A B} (P : A -> B -> Prop) l1 l2 n, Forall2 P l1 l2 ->
  Forall2 P (firstn n l1) (firstn n l2).

Lemma Forall2_upd_Znth : forall {A B} (P : A -> B -> Prop) l1 l2 i x1 x2, Forall2 P l1 l2 ->
  P x1 x2 -> 0 <= i <= Zlength l1 -> Forall2 P (upd_Znth i l1 x1) (upd_Znth i l2 x2).

Lemma Forall2_impl' : forall {A B} (P Q : A -> B -> Prop) l1 l2,
  (forall a b, In a l1 -> In b l2 -> P a b -> Q a b) -> Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma Forall2_impl : forall {A B} (P Q : A -> B -> Prop), (forall a b, P a b -> Q a b) ->
  forall l1 l2, Forall2 P l1 l2 -> Forall2 Q l1 l2.

Lemma map_id_eq : forall {A} (l : list A), map (@id A) l = l.

Lemma Forall2_map : forall {A B C D} (P : A -> B -> Prop) (f1 : C -> A) (f2 : D -> B) l1 l2,
  Forall2 P (map f1 l1) (map f2 l2) <-> Forall2 (fun a b => P (f1 a) (f2 b)) l1 l2.

Corollary Forall2_map1 : forall {A B C} (P : A -> B -> Prop) (f : C -> A) l1 l2, Forall2 P (map f l1) l2 <->
  Forall2 (fun a b => P (f a) b) l1 l2.

Corollary Forall2_map2 : forall {A B C} (P : A -> B -> Prop) (f : C -> B) l1 l2, Forall2 P l1 (map f l2) <->
  Forall2 (fun a b => P a (f b)) l1 l2.

Lemma sublist_max_length : forall {A} i j (al : list A), Zlength (sublist i j al) <= Zlength al.

Lemma Forall2_sublist : forall {A B} (P : A -> B -> Prop) l1 l2 i j, Forall2 P l1 l2 -> 0 <= i ->
  Forall2 P (sublist i j l1) (sublist i j l2).

Lemma Forall_last : forall {A} (P : A -> Prop) d l, Forall P l -> P d -> P (last l d).

Lemma last_map : forall {A B} (f : A -> B) d l, f (last l d) = last (map f l) (f d).

Lemma In_removelast : forall {A} (l : list A) x, In x (removelast l) -> In x l.

Definition nil_dec {A} (l : list A) : {l = []} + {l <> []}.

Lemma Forall2_upd_Znth_l : forall {A B}{d: Inhabitant B} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P x (Znth i l2) -> 0 <= i < Zlength l1 -> Forall2 P (upd_Znth i l1 x) l2.

Lemma Forall2_upd_Znth_r : forall {A B}{d: Inhabitant A} (P : A -> B -> Prop) l1 l2 i x, Forall2 P l1 l2 ->
  P (Znth i l1) x -> 0 <= i < Zlength l1 -> Forall2 P l1 (upd_Znth i l2 x).

Lemma Forall2_eq_upto : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B} (P : A -> B -> Prop) l1 l2, Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ Forall (fun i => P (Znth i l1) (Znth i l2)) (upto (Z.to_nat (Zlength l1))).

Lemma Forall2_forall_Znth : forall {A B}{d1: Inhabitant A}{d2: Inhabitant B}  (P : A -> B -> Prop) l1 l2,
  Forall2 P l1 l2 <->
  Zlength l1 = Zlength l2 /\ (forall i, 0 <= i < Zlength l1 -> P (Znth i l1) (Znth i l2)).

Lemma Znth_inbounds : forall {A}{d: Inhabitant A} i (l : list A), 
    Znth i l <> default -> 0 <= i < Zlength l.

Lemma sublist_next : forall {A}{d: Inhabitant A} i j l,
      0 <= i < j -> j <= Zlength l ->
  sublist i j l = Znth i l :: sublist (i + 1) j l.

Lemma upd_init : forall {A} (l : list A) i b v v', i < b -> Zlength l = i ->
  upd_Znth i (l ++ repeat v (Z.to_nat (b - i))) v' = l ++ v' :: repeat v (Z.to_nat (b - (i + 1))).

Corollary upd_init_const : forall {A} i b (v v' : A), 0 <= i < b ->
  upd_Znth i (repeat v' (Z.to_nat i) ++ repeat v (Z.to_nat (b - i))) v' =

Lemma list_Znth_eq : forall {A}{d: Inhabitant A} (l : list A),
    l = map (fun j => Znth j l) (upto (length l)).

Arguments eq_dec _ _ _ _ : simpl never.

Lemma upd_Znth_eq : forall {A} {EqDec : EqDec A} {d: Inhabitant A} (x : A) (l : list A) i, 0 <= i < Zlength l ->
  upd_Znth i l x = map (fun j => if eq_dec j i then x else Znth j l) (upto (length l)).

Lemma upd_Znth_diff' : forall {A}{d: Inhabitant A} i j l (u : A),
    0 <= j < Zlength l -> i <> j ->
  Znth i (upd_Znth j l u) = Znth i l.

Lemma list_nth_error_eq : forall {A} (l1 l2 : list A)
  (Heq : forall j, nth_error l1 j = nth_error l2 j), l1 = l2.

Lemma list_Znth_eq' : forall {A} {d: Inhabitant A} (l1 l2 : list A)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> Znth j l1 = Znth j l2), l1 = l2.

Corollary upd_Znth_eq' : forall {A}{d: Inhabitant A} x (l1 l2 : list A) i (Hi : 0 <= i < Zlength l1)
  (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall j, 0 <= j < Zlength l1 -> j <> i -> Znth j l1 = Znth j l2),
  upd_Znth i l1 x = upd_Znth i l2 x.

Lemma upd_Znth_twice : forall {A} i l (x y : A), 0 <= i < Zlength l ->
  upd_Znth i (upd_Znth i l x) y = upd_Znth i l y.

Lemma hd_Znth : forall {A}{d: Inhabitant A} (l : list A), hd default l = Znth 0 l.

Lemma NoDup_filter : forall {A} (f : A -> bool) l, NoDup l -> NoDup (filter f l).

Lemma Permutation_Zlength : forall {A} (l1 l2 : list A), Permutation.Permutation l1 l2 ->

Lemma Permutation_filter : forall {A} (f : A -> bool) l1 l2, Permutation.Permutation l1 l2 ->

Lemma NoDup_add : forall {A} l1 l2 (x : A), NoDup (l1 ++ l2) -> ~In x (l1 ++ l2) -> NoDup (l1 ++ x :: l2).

Lemma list_in_count : forall {A} {A_eq : EqDec A} (l l' : list A), NoDup l' ->
  (length (filter (fun x => if in_dec eq_dec x l then true else false) l') <= length l)%nat.

Lemma filter_length : forall {A} (f : A -> bool) l,
  length l = (length (filter f l) + length (filter (fun x => negb (f x)) l))%nat.

Lemma Zlength_filter : forall {A} f (l : list A), Zlength (filter f l) <= Zlength l.

Lemma Zlength_concat : forall {A} (l : list (list A)),
  Zlength (concat l) = fold_right Z.add 0 (map (@Zlength A) l).

Lemma Zlength_concat_le : forall {A} (l : list (list A)) n,
  Forall (fun l => Zlength l <= n) l -> Zlength (concat l) <= n * Zlength l.

Lemma filter_app : forall {A} (f : A -> bool) l1 l2, filter f (l1 ++ l2) = filter f l1 ++ filter f l2.

Lemma filter_concat : forall {A} f (l : list (list A)),
  filter f (concat l) = concat (map (filter f) l).

Lemma NoDup_upto : forall n, NoDup (upto n).

Lemma In_remove : forall {A} {A_eq : EqDec A} (x y : A) l, In x (remove A_eq y l) <-> In x l /\ x <> y.

Lemma remove_NoDup : forall {A} {A_eq : EqDec A} (x : A) l, NoDup l -> NoDup (remove A_eq x l).

Lemma remove_out : forall {A} {A_eq : EqDec A} (x : A) l, ~In x l -> remove A_eq x l = l.

Lemma remove_from_NoDup : forall {A} {A_eq : EqDec A} (x : A) l1 l2, NoDup (l1 ++ x :: l2) ->
  remove A_eq x (l1 ++ x :: l2) = l1 ++ l2.

Lemma incl_remove_add : forall {A} {A_eq : EqDec A} (x : A) l1 l2, incl l1 l2 -> incl l1 (x :: remove A_eq x l2).

Lemma list_pigeonhole : forall l n, Zlength l < n -> exists a, 0 <= a < n /\ ~In a l.

Lemma In_sublist_upto : forall n x i j, In x (sublist i j (upto n)) -> 0 <= i ->
  i <= x < j /\ x < Z.of_nat n.

Lemma incl_cons_iff : forall {A} (a : A) b c, incl (a :: b) c <-> In a c /\ incl b c.

Lemma lt_le_1 : forall i j, i < j <-> i + 1 <= j.

Lemma firstn_all : forall {A} n (l : list A), (length l <= n)%nat -> firstn n l = l.

Lemma sublist_all : forall {A} i (l : list A), Zlength l <= i -> sublist 0 i l = l.

Lemma sublist_prefix : forall {A} i j (l : list A), sublist 0 i (sublist 0 j l) = sublist 0 (Z.min i j) l.

Lemma sublist_suffix : forall {A} i j (l : list A), 0 <= i -> 0 <= j ->
  sublist i (Zlength l - j) (sublist j (Zlength l) l) = sublist (i + j) (Zlength l) l.

Lemma sublist_parts1 : forall {A} i j (l : list A), 0 <= i -> sublist i j l = sublist i j (sublist 0 j l).

Lemma sublist_parts2 : forall {A} i j (l : list A), 0 <= i -> j <= Zlength l ->
  sublist i j l = sublist 0 (j - i) (sublist i (Zlength l) l).

Lemma Forall_Forall2 : forall {A} (P : A -> Prop) Q l1 l2 (HP : Forall P l1) (HQ : Forall2 Q l1 l2)
  (Htransfer : forall x y, P x -> Q x y -> P y), Forall P l2.

Lemma Forall_suffix_max : forall {A} (P : A -> Prop) l1 l2 i j
  (Hi : 0 <= i <= Zlength l1) (Hj : 0 <= j <= Zlength l1)
  (Hl1 : Forall P (sublist j (Zlength l1) l1))
  (Hl2 : sublist i (Zlength l1) l1 = sublist i (Zlength l2) l2),
  Forall P (sublist (Z.max i j) (Zlength l2) l2).

Fixpoint extend {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (x :: y) :: extend xs ys
  | _, _ => ls
  end.

Lemma Zlength_extend : forall {A} (l : list A) ls, Zlength (extend l ls) = Zlength ls.

Lemma Znth_extend_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extend l ls) = Znth i l :: Znth i ls.

Lemma Znth_extend_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extend l ls) = Znth i ls.

Fixpoint extendr {A} (l : list A) ls :=
  match l, ls with
  | x :: xs, y :: ys => (y ++ [x]) :: extendr xs ys
  | _, _ => ls
  end.

Lemma Zlength_extendr : forall {A} (l : list A) ls, Zlength (extendr l ls) = Zlength ls.

Lemma Znth_extendr_in : forall {A}{d: Inhabitant A}  (l : list A) ls i, 0 <= i < Zlength l -> Zlength l <= Zlength ls ->
  Znth i (extendr l ls) = Znth i ls ++ [Znth i l].

Lemma Znth_extendr_ge : forall {A}{d: Inhabitant A}  (l : list A) ls i, Zlength l <= i ->
  Znth i (extendr l ls) = Znth i ls.

Lemma list_join_eq : forall (b : list share) a c c'
  (Hc : sepalg_list.list_join a b c) (Hc' : sepalg_list.list_join a b c'), c = c'.

Lemma readable_share_list_join : forall sh shs sh', sepalg_list.list_join sh shs sh' ->

Lemma sublist_0_cons' : forall {A} i j (x : A) l, i <= 0 -> j > i -> sublist i j (x :: l) =
  x :: sublist i (j - 1) l.

Lemma sublist_combine : forall {A B} (l1 : list A) (l2 : list B) i j,
  sublist i j (combine l1 l2) = combine (sublist i j l1) (sublist i j l2).

Lemma extend_nil : forall {A} (l : list A), extend l [] = [].

Lemma extend_cons : forall {A} (l : list A) l1 ls, extend l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (a :: l1) :: extend l' ls end.

Lemma sublist_extend : forall {A} (l : list A) ls i j,
  sublist i j (extend l ls) = extend (sublist i j l) (sublist i j ls).

Lemma extendr_nil : forall {A} (l : list A), extendr l [] = [].

Lemma extendr_cons : forall {A} (l : list A) l1 ls, extendr l (l1 :: ls) =
  match l with [] => l1 :: ls | a :: l' => (l1 ++ [a]) :: extendr l' ls end.

Lemma sublist_extendr : forall {A} (l : list A) ls i j,
  sublist i j (extendr l ls) = extendr (sublist i j l) (sublist i j ls).

Lemma sublist_over : forall {A} (l : list A) i j, Zlength l <= i -> sublist i j l = [].

Lemma make_tycontext_s_distinct : forall a l (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (make_tycontext_s l) ! (fst a) = Some (snd a).

Lemma lookup_distinct : forall {A B} (f : A -> B) a l t (Ha : In a l) (Hdistinct : NoDup (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! (fst a) =

Lemma lookup_out : forall {A B} (f : A -> B) a l t (Ha : ~In a (map fst l)),
  (fold_right (fun v : ident * A => PTree.set (fst v) (f (snd v))) t l) ! a = t ! a.

Lemma data_at__eq : forall {cs : compspecs} sh t p, data_at_ sh t p = data_at sh t (default_val t) p.

Lemma func_tycontext_sub : forall f V G A V2 G2 (HV : incl V V2) (HG : incl G G2)
  (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  tycontext_sub (func_tycontext f V G A) (func_tycontext f V2 G2 A).

Lemma semax_body_mono : forall V G {cs : compspecs} f s V2 G2
  (HV : incl V V2) (HG : incl G G2) (Hdistinct : NoDup (map fst V2 ++ map fst G2)),
  semax_body V G f s -> semax_body V2 G2 f s.

Lemma weak_exclusive_conflict : forall P,
  predicates_hered.derives ((weak_exclusive_mpred P && emp) * P * P) FF.

Lemma exclusive_sepcon1 : forall (P Q : mpred) (HP : exclusive_mpred P), exclusive_mpred (P * Q).

Lemma exclusive_sepcon2 : forall (P Q : mpred) (HP : exclusive_mpred Q), exclusive_mpred (P * Q).

Lemma exclusive_andp1 : forall P Q (HP : exclusive_mpred P), exclusive_mpred (P && Q).

Lemma exclusive_andp2 : forall P Q (HQ : exclusive_mpred Q), exclusive_mpred (P && Q).

Lemma lock_inv_exclusive : forall v sh R, exclusive_mpred (lock_inv sh v R).

Lemma selflock_exclusive : forall R sh v, exclusive_mpred R -> exclusive_mpred (selflock R v sh).

Lemma exclusive_FF : exclusive_mpred FF.

Lemma derives_exclusive : forall P Q (Hderives : P |-- Q) (HQ : exclusive_mpred Q),
  exclusive_mpred P.

Lemma mapsto_exclusive : forall (sh : Share.t) (t : type) (v : val),

Lemma field_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Lemma ex_field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) (p : val),

Corollary field_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (fld : list gfield) v (p : val),

Lemma ex_data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Corollary data_at_exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) v (p : val),

Corollary data_at__exclusive : forall (cs : compspecs) (sh : Share.t) (t : type) (p : val),

Lemma cond_var_exclusive : forall {cs} sh p, sepalg.nonidentity sh ->

Lemma lock_inv_isptr : forall sh v R, lock_inv sh v R = !!isptr v && lock_inv sh v R.

Lemma cond_var_isptr : forall {cs} sh v, @cond_var cs sh v = !! isptr v && cond_var sh v.
Hint Resolve lock_inv_isptr cond_var_isptr : saturate_local.

Lemma cond_var_share_join : forall {cs} sh1 sh2 sh v (Hjoin : sepalg.join sh1 sh2 sh),

Hint Resolve lock_inv_exclusive selflock_exclusive cond_var_exclusive data_at_exclusive
  data_at__exclusive field_at_exclusive field_at__exclusive selflock_rec.

Lemma eq_dec_refl : forall {A B} {A_eq : EqDec A} (a : A) (b c : B), (if eq_dec a a then b else c) = b.

Lemma LKspec_readable lock_size :
  0 < lock_size ->
  forall R sh p, predicates_hered.derives (res_predicates.LKspec lock_size R sh p)

Lemma lock_inv_share_join : forall sh1 sh2 sh v R (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (Hjoin : sepalg.join sh1 sh2 sh),

Lemma comp_join_top : forall sh, sepalg.join sh (Share.comp sh) Tsh.

Lemma unreadable_bot : ~readable_share Share.bot.
Hint Resolve unreadable_bot.

Definition join_Bot := join_Bot.

Lemma join_Tsh : forall a b, sepalg.join Tsh a b -> b = Tsh /\ a = Share.bot.

Definition gsh1 := fst (slice.cleave Tsh).
Definition gsh2 := snd (slice.cleave Tsh).

Lemma readable_gsh1 : readable_share gsh1.

Lemma readable_gsh2 : readable_share gsh2.

Lemma gsh1_gsh2_join : sepalg.join gsh1 gsh2 Tsh.

Hint Resolve readable_gsh1 readable_gsh2 gsh1_gsh2_join.

Lemma gsh1_not_bot : gsh1 <> Share.bot.

Lemma gsh2_not_bot : gsh2 <> Share.bot.
Hint Resolve gsh1_not_bot gsh2_not_bot.

Lemma split_readable_share sh :
  readable_share sh ->
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 sh.

Lemma split_Ews :
  exists sh1, exists sh2,
    readable_share sh1 /\
    readable_share sh2 /\
    sepalg.join sh1 sh2 Ews.

Definition remove_Znth {A} i (al : list A) := sublist 0 i al ++ sublist (i + 1) (Zlength al) al.

Lemma remove_Znth0 : forall {A} (l : list A), remove_Znth 0 l = sublist 1 (Zlength l) l.

Lemma remove_Znth_cons : forall {A} i a (l : list A), i > 0 ->
  remove_Znth i (a :: l) = a :: remove_Znth (i - 1) l.

Lemma Zlength_remove_Znth : forall {A} i (l : list A), 0 <= i < Zlength l ->
  Zlength (remove_Znth i l) = Zlength l - 1.

Lemma remove_upd_Znth: forall {A} i l (a : A), 0 <= i < Zlength l ->
  remove_Znth i (upd_Znth i l a) = remove_Znth i l.

Lemma remove_Znth_map: forall {A B} (f : A -> B) i l,
  remove_Znth i (map f l) = map f (remove_Znth i l).

Lemma remove_Znth_combine: forall {A B} i (l1 : list A) (l2 : list B),
  0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  remove_Znth i (combine l1 l2) = combine (remove_Znth i l1) (remove_Znth i l2).

Lemma iter_sepcon_Znth: forall {A} {d : Inhabitant A} f (l : list A) i, 0 <= i < Zlength l ->
  iter_sepcon f l = f (Znth i l) * iter_sepcon f (remove_Znth i l).

Lemma iter_sepcon2_Znth: forall {A B} {d1 : Inhabitant A} {d2 : Inhabitant B}
  f (l1 : list A) (l2 : list B) i, 0 <= i < Zlength l1 -> Zlength l1 = Zlength l2 ->
  iter_sepcon2 f l1 l2 =
  f (Znth i l1) (Znth i l2) * iter_sepcon2 f (remove_Znth i l1) (remove_Znth i l2).

Instance Inhabitant_share : Inhabitant share := Share.bot.  
Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.  

Lemma join_shares_nth : forall shs sh1 sh i, sepalg_list.list_join sh1 shs sh -> 0 <= i < Zlength shs ->

Lemma list_join_comm : forall (l1 l2 : list share) a b, sepalg_list.list_join a (l1 ++ l2) b ->

Lemma split_shares : forall n sh, readable_share sh ->
  exists sh1 shs, Zlength shs = Z.of_nat n /\ readable_share sh1 /\ Forall readable_share shs /\

Lemma data_at_shares_join : forall {cs} sh t v p shs sh1 (Hsplit : sepalg_list.list_join sh1 shs sh),

Lemma exp_comm : forall {A B} P,
  (EX x : A, EX y : B, P x y) = EX y : B, EX x : A, P x y.

Lemma mapsto_value_eq: forall sh1 sh2 t p v1 v2, readable_share sh1 -> readable_share sh2 ->
  v1 <> Vundef -> v2 <> Vundef -> mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- !!(v1 = v2).

Lemma mapsto_value_cohere: forall sh1 sh2 t p v1 v2, readable_share sh1 ->
  mapsto sh1 t p v1 * mapsto sh2 t p v2 |-- mapsto sh1 t p v1 * mapsto sh2 t p v1.

Lemma struct_pred_value_cohere : forall {cs : compspecs} m sh1 sh2 p t f off v1 v2
  (Hsh1 : readable_share sh1) (Hsh2 : readable_share sh2)
  (IH : Forall (fun it : ident * type => forall v1 v2 (p : val),
        readable_share sh1 -> readable_share sh2 ->
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v2 p |--
        data_at_rec sh1 (t it) v1 p * data_at_rec sh2 (t it) v1 p) m),
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v2 p |--
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh1 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh1 (t it) v) (f it))) v1 p *
  struct_pred m (fun (it : ident * type) v =>
    withspacer sh2 (f it + sizeof (t it)) (off it) (at_offset (data_at_rec sh2 (t it) v) (f it))) v1 p.

Lemma data_at_value_cohere : forall {cs : compspecs} sh1 sh2 t v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 t v1 p * data_at sh2 t v2 p |--
  data_at sh1 t v1 p * data_at sh2 t v1 p.

Lemma data_at_array_value_cohere : forall {cs : compspecs} sh1 sh2 t z a v1 v2 p, readable_share sh1 ->
  type_is_by_value t = true -> type_is_volatile t = false ->
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v2 p |--
  data_at sh1 (Tarray t z a) v1 p * data_at sh2 (Tarray t z a) v1 p.

Lemma extract_nth_sepcon : forall l i, 0 <= i < Zlength l ->
  fold_right sepcon emp l = Znth i l * fold_right sepcon emp (upd_Znth i l emp).

Lemma replace_nth_sepcon : forall P l i, P * fold_right sepcon emp (upd_Znth i l emp) =
  fold_right sepcon emp (upd_Znth i l P).

Lemma sepcon_derives_prop : forall P Q R, P |-- !!R -> P * Q |-- !!R.

Lemma sepcon_map : forall {A} P Q (l : list A), fold_right sepcon emp (map (fun x => P x * Q x) l) =
  fold_right sepcon emp (map P l) * fold_right sepcon emp (map Q l).

Lemma sepcon_list_derives : forall l1 l2 (Hlen : Zlength l1 = Zlength l2)
  (Heq : forall i, 0 <= i < Zlength l1 -> Znth i l1 |-- Znth i l2),
  fold_right sepcon emp l1 |-- fold_right sepcon emp l2.

Lemma sepcon_rotate : forall lP m n, 0 <= n - m < Zlength lP ->
  fold_right sepcon emp lP = fold_right sepcon emp (rotate lP m n).

Lemma wand_eq : forall P Q R, P = Q * R -> P = Q * (Q -* P).

Lemma wand_twice : forall P Q R, P -* Q -* R = P * Q -* R.

Lemma sepcon_In : forall l P, In P l -> exists Q, fold_right sepcon emp l = P * Q.

Lemma extract_wand_sepcon : forall l P, In P l ->
  fold_right sepcon emp l = P * (P -* fold_right sepcon emp l).

Lemma wand_sepcon_map : forall {A} (R : A -> mpred) l P Q
  (HR : forall i, In i l -> R i = P i * Q i),
  fold_right sepcon emp (map R l) = fold_right sepcon emp (map P l) *
    (fold_right sepcon emp (map P l) -* fold_right sepcon emp (map R l)).

Lemma wand_frame : forall P Q R, P -* Q |-- P * R -* Q * R.

Lemma semax_extract_later_prop'':
  forall {CS : compspecs} {Espec: OracleKind},
    forall (Delta : tycontext) (PP : Prop) P Q R c post P1 P2,
      P2 |-- !!PP ->
      (PP -> semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post) ->
      semax Delta (PROPx P (LOCALx Q (SEPx (P1 && |>P2 :: R)))) c post.

Lemma field_at_array_inbounds : forall {cs : compspecs} sh t z a i v p,
  field_at sh (Tarray t z a) [ArraySubsc i] v p |-- !!(0 <= i < z).

Lemma valid_pointer_isptr : forall v, valid_pointer v |-- !!(is_pointer_or_null v).

Hint Resolve valid_pointer_isptr : saturate_local.

Lemma approx_imp : forall n P Q, compcert_rmaps.RML.R.approx n (predicates_hered.imp P Q) =

Definition super_non_expansive' {A} P := forall n ts x, compcert_rmaps.RML.R.approx n (P ts x) =
  compcert_rmaps.RML.R.approx n (P ts (functors.MixVariantFunctor.fmap (rmaps.dependent_type_functor_rec ts A)
        (compcert_rmaps.RML.R.approx n) (compcert_rmaps.RML.R.approx n) x)).

Lemma approx_sepcon_list: forall n lP, lP <> [] ->
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP) =

Corollary approx_sepcon_list' : forall n lP P,
  compcert_rmaps.RML.R.approx n (fold_right sepcon emp lP)  * compcert_rmaps.RML.R.approx n P =

Lemma approx_FF : forall n, compcert_rmaps.RML.R.approx n FF = FF.

Lemma later_nonexpansive : nonexpansive (@later mpred _ _).

Lemma eqp_refl : forall (G : Triv) P, G |-- P <=> P.

Lemma eqp_sepcon : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P * Q <=> P' * Q'.

Lemma eqp_andp : forall (G : Triv) (P P' Q Q' : mpred)
  (HP : G |-- P <=> P') (HQ : G |-- Q <=> Q'), G |-- P && Q <=> P' && Q'.

Lemma eqp_exp : forall (A : Type) (NA : NatDed A) (IA : Indir A) (RecIndir : RecIndir A)
    (G : Triv) (B : Type) (X Y : B -> A),
  (forall x : B, G |-- X x <=> Y x) ->
  G |-- (EX x : _, X x) <=> (EX x : _, Y x).

Lemma fold_right_sepcon_nonexpansive : forall lP1 lP2, Zlength lP1 = Zlength lP2 ->
  (ALL i : Z, Znth i lP1 <=> Znth i lP2) |--
  fold_right sepcon emp lP1 <=> fold_right sepcon emp lP2.

Lemma void_ret : ifvoid tvoid (` (PROP ( )  LOCAL ()  SEP ()) (make_args [] []))
  (EX v : val, ` (PROP ( )  LOCAL ()  SEP ()) (make_args [ret_temp] [v])) = emp.

Ltac lock_props := rewrite ?sepcon_assoc; rewrite <- sepcon_emp at 1; rewrite sepcon_comm; apply sepcon_derives;
  [repeat apply andp_right; auto; eapply derives_trans;
   try (apply exclusive_weak_exclusive || (apply rec_inv_weak_rec_inv; try apply selflock_rec)); auto |
   try timeout 20 cancel].

Ltac join_sub := repeat (eapply sepalg.join_sub_trans;
  [eexists; first [eassumption | simple eapply sepalg.join_comm; eassumption]|]); eassumption.

Ltac join_inj := repeat match goal with H1 : sepalg.join ?a ?b ?c, H2 : sepalg.join ?a ?b ?d |- _ =>
    pose proof (sepalg.join_eq H1 H2); clear H1 H2; subst; auto end.

Ltac fast_cancel := rewrite ?sepcon_emp, ?emp_sepcon; rewrite ?sepcon_assoc;
  repeat match goal with
    | |- ?P |-- ?P => apply derives_refl
    | |- ?P * _ |-- ?P * _ => apply sepcon_derives; [apply derives_refl|]
    | |- _ |-- ?P * _ => rewrite <- !sepcon_assoc, (sepcon_comm _ P), !sepcon_assoc end;
  try cancel_frame.

Lemma semax_fun_id'' id f gv Espec {cs} Delta P Q R Post c :
  (var_types Delta) ! id = None ->
  (glob_specs Delta) ! id = Some f ->
  (glob_types Delta) ! id = Some (type_of_funspec f) ->
  snd (local2ptree Q) = Some gv ->
  @semax cs Espec Delta
    (PROPx P
      (LOCALx Q
      (SEPx ((func_ptr' f (gv id)) :: R)))) c Post ->
  @semax cs Espec Delta (PROPx P (LOCALx Q (SEPx R))) c Post.

Ltac get_global_function'' _f :=
eapply (semax_fun_id'' _f); try reflexivity.

Ltac start_dep_function := 
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH _ : globals
               PRE  [] main_pre _ nil _
               POST [ tint ] main_post _ nil _) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match _ with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList i
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax.

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => P%assert end)
  (fun (ts: list Type) (x: t1*t2) =>
     match x with (x1,x2) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3) =>
     match x with (x1,x2,x3) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4) =>
     match x with (x1,x2,x3,x4) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5) =>
     match x with (x1,x2,x3,x4,x5) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6) =>
     match x with (x1,x2,x3,x4,x5,x6) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0, 
             x5 at level 0, x6 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7) =>
     match x with (x1,x2,x3,x4,x5,x6,x7) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0, x10 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0,
             P at level 100, Q at level 100).

Notation "'TYPE' A 'WITH'  x1 : t1 , x2 : t2 , x3 : t3 , x4 : t4 , x5 : t5 , x6 : t6 , x7 : t7 , x8 : t8 , x9 : t9 , x10 : t10 , x11 : t11 , x12 : t12 , x13 : t13 , x14 : t14 'PRE'  [ u , .. , v ] P 'POST' [ tz ] Q" :=
     (mk_funspec ((cons u%formals .. (cons v%formals nil) ..), tz) cc_default A
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => P%assert end)
  (fun (ts: list Type) (x: t1*t2*t3*t4*t5*t6*t7*t8*t9*t10*t11*t12*t13*t14) =>
     match x with (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14) => Q%assert end) _ _)
            (at level 200, x1 at level 0, x2 at level 0, x3 at level 0, x4 at level 0,
             x5 at level 0, x6 at level 0, x7 at level 0, x8 at level 0, x9 at level 0,
              x10 at level 0, x11 at level 0, x12 at level 0, x13 at level 0, x14 at level 0,
             P at level 100, Q at level 100).

Definition call_setup2'
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost
  (bl: list expr) (vl : list val)
  (Qactuals : PTree.t _)
  (witness: functors.MixVariantFunctor._functor (rmaps.dependent_type_functor_rec ts A) mpred)
  (Frame: list mpred)
  (Ppre: list Prop) (Qpre : list localdef) (Rpre: list mpred)
  (Qpre_temp : PTree.t _) GV' :=
 call_setup1 cs Qtemp Qvar GV a Delta P Q R R' fs argsig retty cc A Pre Post NEPre NEPost bl vl Qactuals /\
  Pre ts witness = PROPx Ppre (LOCALx Qpre (SEPx Rpre)) /\
  local2ptree Qpre = (Qpre_temp, PTree.empty _, nil, GV') /\
  ENTAIL Delta, PROPx P (LOCALx Q (SEPx R))
           |-- !! Forall (check_one_temp_spec Qactuals) (PTree.elements Qpre_temp) /\
  check_gvars_spec GV GV' /\
  fold_right_sepcon R |-- fold_right_sepcon Rpre * fold_right_sepcon Frame.

Lemma call_setup2'_i:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree) Pre Post NEPre NEPost

Ltac check_witness_type' ts A witness :=
  (unify A (rmaps.ConstType Ridiculous); 
             elimtype False)
 ||
 let TA := constr:(functors.MixVariantFunctor._functor
     (rmaps.dependent_type_functor_rec ts A) mpred) in
  let TA' := eval cbv 
     [functors.MixVariantFunctor._functor
      functors.MixVariantFunctorGenerator.fpair
      functors.MixVariantFunctorGenerator.fconst
      functors.MixVariantFunctorGenerator.fidentity
      rmaps.dependent_type_functor_rec
      functors.GeneralFunctorGenerator.CovariantBiFunctor_MixVariantFunctor_compose
      functors.CovariantFunctorGenerator.fconst
      functors.CovariantFunctorGenerator.fidentity
      functors.CovariantBiFunctor._functor
      functors.CovariantBiFunctorGenerator.Fpair
      functors.GeneralFunctorGenerator.CovariantFunctor_MixVariantFunctor
      functors.CovariantFunctor._functor
      functors.MixVariantFunctor.fmap
      ] in TA
 in let TA'' := eval simpl in TA'
  in match type of witness with ?T => 
       unify T TA''
      + (fail "Type of witness does not match type required by funspec WITH clause.
Witness value: " witness "
Witness type: " T "
Funspec type: " TA'')
     end.

Ltac prove_call_setup' ts witness :=
 prove_call_setup1 subsume_funspec_refl;
 [ .. | 
 match goal with |- call_setup1  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?A _ _ _ _ _ _ _ -> _ =>
      check_witness_type' ts A witness
 end;
 let H := fresh in
 intro H;
 match goal with | |- @semax ?CS _ _ _ _ _ =>
 let Frame := fresh "Frame" in evar (Frame: list mpred);
 exploit (call_setup2'_i _ _ _ _ _ _ _ _ _ _ _ _ _ _ ts _ _ _ _ _ _ _ _ H witness Frame); clear H;
 simpl functors.MixVariantFunctor._functor;
 [ reflexivity
 | check_prove_local2ptree
 | Forall_pTree_from_elements
 | unfold check_gvars_spec; solve [exact I | reflexivity]
 | try change_compspecs CS; cancel_for_forward_call
 | 
 ]
 end].

Lemma semax_call_aux55:
 forall (cs: compspecs) (Qtemp: PTree.t val) (Qvar: PTree.t (type * val)) GV (a: expr)

Lemma semax_call_id00_wow:
 forall  
  (cs: compspecs) Qtemp Qvar a GV Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_x_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id1_y_wow:
 forall  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty' cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Lemma semax_call_id01_wow:
 forall  
  (cs: compspecs) Qtemp Qvar GV a Delta P Q R R'
   fs argsig retty cc ts (A: rmaps.TypeTree)  Pre Post NEPre NEPost

Ltac  forward_call_id1_wow' := 
let H := fresh in intro H;
eapply (semax_call_id1_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H);
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [check_result_type
 |apply Logic.I
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_x_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_x_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id1_y_wow' :=
let H := fresh in intro H;
eapply (semax_call_id1_y_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type | check_result_type
 | apply Coq.Init.Logic.I | apply Coq.Init.Logic.I | reflexivity
 | (clear; let H := fresh in intro H; inversion H)
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | prove_delete_temp
 | prove_delete_temp
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id01_wow' :=
let H := fresh in intro H;
eapply (semax_call_id01_wow 
             _ _ _ _ _ _ _ _ _ _
             _ _ _ _ _ _ _ _ _ _ 
             _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ apply Coq.Init.Logic.I 
 | cbv beta iota zeta; unfold_post; extensionality rho;
   repeat rewrite exp_uncurry;
   try rewrite no_post_exists; repeat rewrite exp_unfold;
   first [apply exp_congr; intros ?vret; reflexivity
           | give_EX_warning
           ]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac forward_call_id00_wow'  :=
let H := fresh in intro H;
eapply (semax_call_id00_wow _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H); 
 clear H;
 lazymatch goal with Frame := _ : list mpred |- _ => try clear Frame end;
 [ check_result_type 
 | cbv beta iota zeta; unfold_post; extensionality rho;
    repeat rewrite exp_uncurry;
    try rewrite no_post_exists0;
    repeat rewrite exp_unfold;
    first [reflexivity | extensionality; simpl; reflexivity | give_EX_warning]
 | unify_postcondition_exps
 | unfold fold_right_and; repeat rewrite and_True; auto
 ].

Ltac fwd_call'_dep ts witness :=
lazymatch goal with
| |- semax _ _ (Ssequence (Scall _ _ _) _) _ =>
  eapply semax_seq';
    [prove_call_setup' ts witness;
     clear_Delta_specs; clear_MORE_POST;
     [ .. |
      lazymatch goal with
      | |- _ -> semax _ _ (Scall (Some _) _ _) _ =>
         forward_call_id1_wow'
      | |- call_setup2' _ _ _ _ _ _ _ _ _ _ _ _ ?retty _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ -> 
                semax _ _ (Scall None _ _) _ =>
        tryif (unify retty Tvoid)
        then forward_call_id00_wow'
        else forward_call_id01_wow'
     end]
   | after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Ecast (Etempvar ?ret'2 _) _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_x_wow' ]
         |  after_forward_call ]
| |- semax _ _ (Ssequence (Ssequence (Scall (Some ?ret') _ _)
                                       (Sset _ (Etempvar ?ret'2 _))) _) _ =>
       unify ret' ret'2;
       eapply semax_seq';
         [prove_call_setup' ts witness;
          clear_Delta_specs; clear_MORE_POST;
             [ .. | forward_call_id1_y_wow' ]
         |  after_forward_call ]
| |- _ => rewrite <- seq_assoc; fwd_call'_dep ts witness
end.

Ltac fwd_call_dep ts witness :=
 try lazymatch goal with
      | |- semax _ _ (Scall _ _ _) _ => rewrite -> semax_seq_skip
      end;
 repeat lazymatch goal with
  | |- semax _ _ (Ssequence (Ssequence (Ssequence _ _) _) _) _ =>
      rewrite <- seq_assoc
 end;
lazymatch goal with |- @semax ?CS _ ?Delta _ (Ssequence ?C _) _ =>
  lazymatch C with context [Scall _ _ _] =>
         fwd_call'_dep ts witness
    end
end.

Tactic Notation "forward_call_dep" constr(ts) constr(witness) := fwd_call_dep ts witness.

Lemma PROP_into_SEP : forall P Q R, PROPx P (LOCALx Q (SEPx R)) =
  PROPx [] (LOCALx Q (SEPx (!!fold_right and True P && emp :: R))).

Ltac cancel_for_forward_spawn :=
  eapply symbolic_cancel_setup;
   [ construct_fold_right_sepcon
   | construct_fold_right_sepcon
   | fold_abnormal_mpred
   | cbv beta iota delta [before_symbol_cancel]; cancel_for_forward_call].

Ltac forward_spawn id arg wit :=
  match goal with gv : globals |- _ =>
  make_func_ptr id; let f := fresh "f_" in set (f := gv id);
  match goal with |- context[func_ptr' (NDmk_funspec _ _ (val * ?A) ?Pre _) f] =>
    let y := fresh "y" in let Q := fresh "Q" in let R := fresh "R" in
    evar (y : ident); evar (Q : A -> globals); evar (R : A -> val -> mpred);
    replace Pre with (fun '(a, w) => PROPx [] (LOCALx (temp y a :: gvars (Q w) :: nil) (SEPx [R w a])));
    [|let x := fresh "x" in extensionality x; destruct x as (?, x);
      instantiate (1 := fun w a => _ w) in (Value of R);
      repeat (destruct x as (x, ?);
        instantiate (1 := fun '(a, b) => _ a) in (Value of Q);
        instantiate (1 := fun '(a, b) => _ a) in (Value of R));
      etransitivity; [|symmetry; apply PROP_into_SEP]; f_equal; f_equal ; [instantiate (1 := fun _ => _) in (Value of Q); subst y Q; f_equal; simpl; f_equal |
       unfold SEPx; extensionality; simpl; rewrite sepcon_emp; instantiate (1 := fun _ => _); reflexivity]];
  forward_call_dep [A] (f, arg, Q, wit, R); subst Q R; [ .. | subst y f]; try (Exists y; subst y f; simpl; cancel_for_forward_spawn) end end. *)

Require Import VST.progs.ghost.

Require Import VST.floyd.library.
(* VST.floyd.library:
Require Import VST.floyd.base2.
Require Import VST.floyd.sublist.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.closed_lemmas.
Require Import VST.floyd.compare_lemmas.
Require Import VST.floyd.semax_tactics.
Require Import VST.floyd.forward.
Require Import VST.floyd.call_lemmas.
Require Import VST.floyd.forward_lemmas.
Require Import VST.floyd.for_lemmas.
Require Import VST.floyd.nested_pred_lemmas.
Require Import VST.floyd.nested_field_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import VST.floyd.mapsto_memory_block.
Require Import VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Import VST.floyd.aggregate_pred.aggregate_pred.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.data_at_rec_lemmas.
Require Import VST.floyd.field_at.
Require Import VST.floyd.field_compat.
Require Import VST.floyd.stronger.
Require Import VST.floyd.loadstore_mapsto.
Require Import VST.floyd.loadstore_field_at.
Require Import VST.floyd.nested_loadstore.
Require Import VST.floyd.local2ptree_denote.
Require Import VST.floyd.local2ptree_eval.
Require Import VST.floyd.proj_reptype_lemmas.
Require Import VST.floyd.replace_refill_reptype_lemmas.
Require Import VST.floyd.sc_set_load_store.

Require Import VST.floyd.entailer.
Require Import VST.floyd.globals_lemmas.
Require Import VST.floyd.diagnosis.
Require Import VST.floyd.freezer.
Import ListNotations.
Import String.

Definition body_lemma_of_funspec  {Espec: OracleKind} (ef: external_function) (f: funspec) :=
  match f with mk_funspec sig _ A P Q _ _ =>
    semax_external (map fst (fst sig)) ef A P Q
  end.

Definition try_spec  (name: string) (spec: funspec) : 
   list (ident * globdef Clight.fundef type) -> list (ident*funspec) :=
fun defs => 
 match ext_link_prog' defs name with
 | Some id => [(id,spec)]
 | None => nil
 end.
Arguments try_spec name spec defs / .

Definition exit_spec' :=
 WITH u: unit
 PRE [1%positive OF tint]
   PROP () LOCAL() SEP()
 POST [ tvoid ]
   PROP(False) LOCAL() SEP().

Definition exit_spec := try_spec "exit" exit_spec'.

Parameter body_exit:
 forall {Espec: OracleKind},
  body_lemma_of_funspec
    (EF_external "exit"
       {| sig_args := AST.Tint :: nil; sig_res := None; sig_cc := cc_default |})
   exit_spec'.

Parameter mem_mgr: globals -> mpred.
Axiom create_mem_mgr: forall gv, emp |-- mem_mgr gv.

Parameter malloc_token : forall {cs: compspecs}, share -> type -> val -> mpred.
Parameter malloc_token_valid_pointer:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- valid_pointer p.
Hint Resolve malloc_token_valid_pointer : valid_pointer.

Parameter malloc_token_local_facts:
  forall {cs: compspecs} sh t p, malloc_token sh t p |-- !! malloc_compatible (sizeof t) p.
Hint Resolve malloc_token_local_facts : saturate_local.
Parameter malloc_token_change_composite: forall {cs_from cs_to} {CCE : change_composite_env cs_from cs_to} sh t,
  cs_preserve_type cs_from cs_to (coeq cs_from cs_to) t = true ->
  @malloc_token cs_from sh t = @malloc_token cs_to sh t.
Ltac change_compspecs' cs cs' ::=
  match goal with
  | |- context [@data_at cs' ?sh ?t ?v1] => erewrite (@data_at_change_composite cs' cs _ sh t); [| apply JMeq_refl | reflexivity]
  | |- context [@field_at cs' ?sh ?t ?gfs ?v1] => erewrite (@field_at_change_composite cs' cs _ sh t gfs); [| apply JMeq_refl | reflexivity]
  | |- context [@data_at_ cs' ?sh ?t] => erewrite (@data_at__change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [@field_at_ cs' ?sh ?t ?gfs] => erewrite (@field_at__change_composite cs' cs _ sh t gfs); [| reflexivity]
  | |- context [@malloc_token cs' ?sh ?t] => erewrite (@malloc_token_change_composite cs' cs _ sh t); [| reflexivity]
  | |- context [?A cs'] => change (A cs') with (A cs)
  | |- context [?A cs' ?B] => change (A cs' B) with (A cs B)
  | |- context [?A cs' ?B ?C] => change (A cs' B C) with (A cs B C)
  | |- context [?A cs' ?B ?C ?D] => change (A cs' B C D) with (A cs B C D)
  | |- context [?A cs' ?B ?C ?D ?E] => change (A cs' B C D E) with (A cs B C D E)
  | |- context [?A cs' ?B ?C ?D ?E ?F] => change (A cs' B C D E F) with (A cs B C D E F)
 end.

Definition malloc_spec'  {cs: compspecs} :=
   WITH t:type, gv: globals
   PRE [ 1%positive OF size_t ]
       PROP (0 <= sizeof t <= Ptrofs.max_unsigned;
                complete_legal_cosu_type t = true;
                natural_aligned natural_alignment t = true)
       LOCAL (temp 1%positive (Vptrofs (Ptrofs.repr (sizeof t))); gvars gv)
       SEP (mem_mgr gv)
    POST [ tptr tvoid ] EX p:_,
       PROP ()
       LOCAL (temp ret_temp p)
       SEP (mem_mgr gv;
             if eq_dec p nullval then emp
            else (malloc_token Ews t p * data_at_ Ews t p)).

Parameter body_malloc:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_malloc malloc_spec'.

Definition free_spec'  {cs: compspecs} :=
   WITH t: type, p:val, gv: globals
   PRE [ 1%positive OF tptr tvoid ]
       PROP ()
       LOCAL (temp 1%positive p; gvars gv)
       SEP (mem_mgr gv;
              if eq_dec p nullval then emp
              else (malloc_token Ews t p * data_at_ Ews t p))
    POST [ Tvoid ]
       PROP ()
       LOCAL ()
       SEP (mem_mgr gv).

Parameter body_free:
 forall {Espec: OracleKind} {cs: compspecs} ,
  body_lemma_of_funspec EF_free free_spec'.

Definition library_G  {cs: compspecs} prog :=
 let defs := prog_defs prog in 
  try_spec "exit" exit_spec' defs ++
  try_spec "_malloc" malloc_spec' defs ++
  try_spec "_free" free_spec' defs.

Ltac with_library prog G :=
  let pr := eval unfold prog in prog in  
 let x := constr:(library_G pr ++ G) in
  let x := eval cbv beta delta [app library_G] in x in
  let x := simpl_prog_defs x in 
  let x := eval cbv beta iota zeta delta [try_spec] in x in 
  let x := eval simpl in x in 
    with_library' pr x.

Lemma semax_func_cons_malloc_aux:
  forall {cs: compspecs} (gv: globals) (gx : genviron) (t :type) (ret : option val),
(EX p : val,
 PROP ( )
 LOCAL (temp ret_temp p)
 SEP (mem_mgr gv;
      if eq_dec p nullval
      then emp
      else malloc_token Ews t p * data_at_ Ews t p))%assert
  (make_ext_rval gx ret) |-- !! is_pointer_or_null (force_val ret). *)

Require Import VST.floyd.sublist.
(* VST.floyd.sublist:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.Coqlib2.
Require Import Coq.Lists.List.
Import ListNotations.

Class Inhabitant (A: Type) := default : A.

Instance Inhabitant_Z : Inhabitant Z := 0.
Instance Inhabitant_nat : Inhabitant nat := O.
Instance Inhabitant_positive : Inhabitant positive := 1%positive.
Instance Inhabitant_list {T: Type} : Inhabitant (list T) := @nil T.
Instance Inhabitant_fun {T1 T2: Type} {H: Inhabitant T2} : Inhabitant (T1->T2) := fun _ => H.
Instance Inhabitant_Prop : Inhabitant Prop := False.
Instance Inhabitant_bool : Inhabitant bool := false.
Instance Inhabitant_pair {T1 T2 : Type} {x1: Inhabitant T1} {x2: Inhabitant T2} : Inhabitant (T1*T2)%type := (x1,x2).

Lemma Zlength_length:
  forall A (al: list A) (n: Z),
    0 <= n ->
    (Zlength al = n <-> length al = Z.to_nat n).

Lemma firstn_app1: forall {A} n (p l: list A),
  (n <= Datatypes.length p)%nat ->

Lemma firstn_app2: forall {A} (n: nat) (al bl: list A),
 (n >= length al)%nat ->
 firstn n (al++bl) = al ++ firstn (n - length al) bl.

Lemma firstn_list_repeat {A} (v:A): forall i k, (i<=k)%nat ->
      firstn i (list_repeat k v) = list_repeat i v.

Lemma firstn_app:
 forall {A} n m (al: list A), firstn n al ++ firstn m (skipn n al) =
  firstn (n+m) al.

Lemma nth_skipn:
  forall {A} i n data (d:A),
       nth i (skipn n data) d = nth (i+n) data d.

Lemma skipn_skipn: forall {A} n m (xs: list A),
  skipn n (skipn m xs) = skipn (m + n) xs.

Lemma firstn_exact_length: forall {A} (xs: list A), firstn (length xs) xs = xs.

Lemma skipn_exact_length: forall {A} (xs: list A), skipn (length xs) xs = nil.

Lemma len_le_1_rev: forall {A} (contents: list A),
  (length contents <= 1)%nat ->
  contents = rev contents.

Lemma firstn_firstn: forall {A} (contents: list A) n m,
  (n <= m)%nat ->
  firstn n (firstn m contents) = firstn n contents.

Lemma firstn_1_skipn: forall {A} n (ct: list A) d,
  (n < length ct)%nat ->
  nth n ct d :: nil = firstn 1 (skipn n ct).

Lemma skipn_length: forall {A} (contents: list A) n,
  length (skipn n contents) = (length contents - n)%nat.

Lemma nth_firstn: forall {A} (contents: list A) n m d,
  (n < m)%nat ->
  nth n (firstn m contents) d = nth n contents d.

Lemma skipn_length_short:
  forall {A} n (al: list A),
    (length al <= n)%nat ->
    (length (skipn n al) = 0)%nat.

Lemma skipn_short:
   forall {A} n (al: list A), (n >= length al)%nat -> skipn n al = nil.

Lemma nth_map':
  forall {A B} (f: A -> B) d d' i al,
  (i < length al)%nat ->
   nth i (map f al) d = f (nth i al d').

Lemma skipn_nil: forall A n, skipn n (@nil A) = nil.

Lemma skipn_drop:
 forall A n m (al: list A), skipn n (skipn m al) = skipn (n+m) al.

Lemma skipn_app1:
 forall A n (al bl: list A),
  (n <= length al)%nat ->
  skipn n (al++bl) = skipn n al ++ bl.

Lemma skipn_app2:
 forall A n (al bl: list A),
  (n >= length al)%nat ->
  skipn n (al++bl) = skipn (n-length al) bl.

Lemma list_repeat_app: forall A a b (x:A),
  list_repeat a x ++ list_repeat b x = list_repeat (a+b) x.

Lemma firstn_same:
  forall A n (b: list A), (n >= length b)%nat -> firstn n b = b.

Lemma nth_firstn_low:
 forall A i n al (d: A),
  (i < n <= length al)%nat -> nth i (firstn n al) d = nth i al d.

Lemma nth_error_nth:
  forall A (d: A) i al, (i < length al)%nat -> nth_error al i = Some (nth i al d).

Lemma skipn_rev:
  forall {A} n (vl: list A),
   skipn n (rev vl) = rev (firstn (length vl - n) vl).

Lemma Forall_list_repeat:
  forall {A} (P: A -> Prop) (n: nat) (a: A),
    P a -> Forall P (list_repeat n a).

Lemma skipn_firstn: forall {A} n m (xs: list A),
  skipn n (firstn m xs) = firstn (m-n) (skipn n xs).

Lemma rev_skipn:
 forall {A} n (vl: list A),
  rev (skipn n vl) = firstn (length vl -n) (rev vl).

Lemma firstn_skipn_rev:
  forall {A} lo n (vl: list A),
  (n+lo <= length vl)%nat ->
  firstn n (skipn lo (rev vl)) =
  rev (firstn n (skipn (length vl - (lo+n))%nat vl)).

Lemma map_firstn:
  forall A B (F: A -> B) n (al: list A),
  map F (firstn n al) = firstn n (map F al).

Lemma map_skipn:
  forall A B (F: A -> B) n (al: list A),
  map F (skipn n al) = skipn n (map F al).

Lemma Zlength_app: forall T (al bl: list T),
    Zlength (al++bl) = Zlength al + Zlength bl.

Lemma Zlength_rev: forall T (vl: list T), Zlength (rev vl) = Zlength vl.

Lemma Zlength_map: forall A B (f: A -> B) l, Zlength (map f l) = Zlength l.

Lemma ZtoNat_Zlength:
 forall {A} (l: list A), Z.to_nat (Zlength l) = length l.
Hint Rewrite @ZtoNat_Zlength : norm.

Lemma Zlength_nonneg:
 forall {A} (l: list A), 0 <= Zlength l.

Definition Zlength' := @Zlength.

Ltac pose_Zlength_nonneg1 T A :=
     lazymatch goal with
      | H:  0 <= @Zlength T A |- _ => idtac
      | H:  0 <= @Zlength T A /\ _ |- _ => idtac
      | |- _ => pose proof (@Zlength_nonneg T A)
     end;
     
     let x := fresh "x" in set (x:= @Zlength T A) in *;
     let y := fresh "y" in set (y := @Zlength) in x;
     fold @Zlength' in y; subst y; subst x.

Ltac pose_Zlength_nonneg :=
 repeat
  match goal with
  | |- context [@Zlength ?T ?A] => pose_Zlength_nonneg1 T A
  | H: context [@Zlength ?T ?A] |- _ => pose_Zlength_nonneg1 T A
 end;
  unfold Zlength' in *.

Ltac list_solve := autorewrite with sublist; pose_Zlength_nonneg; omega.

Definition Znth {X}{d: Inhabitant X} n (xs: list X) :=
  if (zlt n 0) then default else nth (Z.to_nat n) xs d.

Lemma Znth_map:
  forall {A:Type} {da: Inhabitant A}{B:Type}{db: Inhabitant B} i (f: A -> B) (al: list A),
  0 <= i < Zlength al ->
  Znth i (map f al)  = f (Znth i al).

Hint Rewrite 
   (@Znth_map Z _) (@Znth_map nat _) (@Znth_map positive _)
    using (auto; rewrite ?Zlength_map in *; omega) : sublist.

Lemma Znth_succ: forall {A}{a: Inhabitant A} i lo (v: list A), Z.succ lo <= i -> Znth (i - lo) v = Znth (i - (Z.succ lo)) (skipn 1 v).

Lemma Znth_0_cons {A}{a: Inhabitant A} l (v:A): Znth 0 (v::l) = v.
Hint Rewrite @Znth_0_cons : sublist.

Lemma Znth_pos_cons {A}{a: Inhabitant A} i l (v:A): 0<i -> Znth i (v::l) = Znth (i-1) l.

Lemma Znth_In : forall {A}{a: Inhabitant A} i l, 0 <= i < Zlength l -> In (Znth i l) l.

Lemma split3_full_length_list: forall {A}{a: Inhabitant A} lo mid hi (ct: list A),
  lo <= mid < hi ->
  Zlength ct = hi - lo ->
  ct = firstn (Z.to_nat (mid - lo)) ct ++

Lemma Forall_Znth:
 forall {A}{a: Inhabitant A} (F: A -> Prop) (al: list A) i,
   0 <= i < Zlength al ->
   Forall F al ->
   F (Znth i al).

Hint Rewrite @app_nil_l @app_nil_r : sublist.

Lemma app_Znth1:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i < Zlength l -> Znth i (l++l') = Znth i l.

Lemma app_Znth2:
  forall A (a: Inhabitant A) (l l': list A) (i:Z),
  i >= Zlength l -> Znth i (l++l') = Znth (i-Zlength l) l'.

Lemma Znth_firstn:
  forall {A}{a: Inhabitant A} (al: list A) (n m : Z),
  n<m -> Znth n (firstn (Z.to_nat m) al) = Znth n al.

Lemma Znth_skipn: forall {A}{a: Inhabitant A}  i n xs,
  0 <= i ->
  0 <= n ->
  Znth i (skipn (nat_of_Z n) xs) = Znth (i+n) xs.

Lemma Z2Nat_neg: forall i, i < 0 -> Z.to_nat i = 0%nat.

Lemma Zlength_firstn:
  forall {A} n (v: list A), Zlength (firstn (Z.to_nat n) v) = Z.min (Z.max 0 n) (Zlength v).

Lemma Zlength_skipn:
  forall {A} n (v: list A),
  Zlength (skipn (Z.to_nat n) v) = Z.max 0 (Zlength v - (Z.max 0n)).

Lemma Znth_cons:
 forall {A}(a: Inhabitant A)  i (al: list A) bl,
  0 <= i < Zlength al  ->
  Znth i al :: bl = firstn (Z.to_nat 1) (skipn (Z.to_nat i) al) ++ bl.

Lemma Zfirstn_app1:
 forall A n (al bl: list A),
  n <= Zlength al -> firstn (Z.to_nat n) (al++bl) = firstn (Z.to_nat n) al.

Lemma Zfirstn_same:
  forall A n (b: list A), n >= Zlength b -> firstn (Z.to_nat n) b = b.

Lemma Zfirstn_app2: forall {A} n (al bl: list A),
 n >= Zlength al ->
 firstn (Z.to_nat n) (al++bl) = al ++ firstn (Z.to_nat (n - Zlength al)) bl.

Lemma Zfirstn_firstn: forall {A} (contents: list A) n m,
  n <= m ->
  firstn (Z.to_nat n) (firstn (Z.to_nat m) contents) = firstn (Z.to_nat n) contents.
Lemma Zskipn_app1:
 forall A n (al bl: list A),
  n <= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat n) al ++ bl.

Lemma Zskipn_app2:
 forall A n (al bl: list A),
  n >= Zlength al ->
  skipn (Z.to_nat n) (al++bl) = skipn (Z.to_nat (n-Zlength al)) bl.

Lemma Znth_rev:
  forall {A}{d: Inhabitant A} i (al:list A),
  0 <= i < Zlength al ->
  Znth i (rev al) = Znth (Zlength al - i - 1) al.

Lemma Zskipn_firstn: forall {A} n m (xs: list A),
 0 <= n ->
 skipn (Z.to_nat n) (firstn (Z.to_nat m) xs) =

Lemma Zskipn_skipn: forall {A} n m (xs: list A),
  0 <= n -> 0 <= m ->
  skipn (Z.to_nat n) (skipn (Z.to_nat m) xs) = skipn (Z.to_nat (m + n)) xs.

Lemma Zfirstn_app:
 forall {A} n m (al: list A),
  0 <= n -> 0 <= m ->
  firstn (Z.to_nat n) al ++ firstn (Z.to_nat m) (skipn (Z.to_nat n) al) =

Lemma Zfirstn_exact_length:
  forall {A} n (al: list A),
  n = Zlength al ->
  firstn (Z.to_nat n) al = al.

Definition sublist {A} (lo hi: Z) (al: list A) : list A :=
  firstn (Z.to_nat (hi-lo)) (skipn (Z.to_nat lo) al).

Definition upd_Znth {A} (i: Z) (al: list A) (x: A): list A :=
   sublist 0 i al ++ x :: sublist (i+1) (Zlength al) al.

Lemma sublist_sublist {A} i j k m (l:list A): 0<=m -> 0<=k <=i -> i <= j-m ->
  sublist k i (sublist m j l) = sublist (k+m) (i+m) l.

Lemma sublist_rejoin:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid hi al = sublist lo hi al.

Lemma sublist_map:
  forall {A B} (F: A -> B) lo hi (al: list A),
  sublist lo hi (map F al) = map F (sublist lo hi al).

Lemma map_sublist:
  forall {A B} (F: A -> B) lo hi (al: list A),
  map F (sublist lo hi al) = sublist lo hi (map F al).

Lemma sublist_len_1:
  forall {A}{d: Inhabitant A} i (al: list A),
  0 <= i < Zlength al ->
  sublist i (i+1) al = Znth i al :: nil.

Lemma Znth_cons_sublist:
  forall {A}{d: Inhabitant A} i (al: list A) bl,
  0 <= i < Zlength al ->
  Znth i al :: bl = sublist i (i+1) al ++ bl.

Lemma Zlength_sublist:
  forall {A} lo hi (al: list A),
 0 <= lo <= hi -> hi <= Zlength al ->
 Zlength (sublist lo hi al) = hi-lo.

Lemma sublist_same_gen:
forall {A} lo hi (al: list A),
  lo = 0 -> hi >= Zlength al ->
  sublist lo hi al = al.

Lemma sublist_same:
forall {A} lo hi (al: list A),
  lo = 0 -> hi = Zlength al ->
  sublist lo hi al = al.

Lemma Znth_sublist:
  forall {A}{d: Inhabitant A} lo i hi (al: list A),
 0 <= lo ->
 0 <= i < hi-lo ->
 Znth i (sublist lo hi al) = Znth (i+lo) al.

Lemma rev_sublist:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  rev (sublist lo hi al) = sublist (Zlength al - hi) (Zlength al - lo) (rev al).

Lemma sublist_nil:
  forall {A} lo (al: list A),
  sublist lo lo al = nil.

Lemma sublist_nil_gen : forall {A} (l : list A) i j, j <= i -> sublist i j l = [].

Lemma sublist_rev:
  forall {A} lo hi (al: list A),
  0 <= lo <= hi -> hi <= Zlength al ->
  sublist lo hi (rev al) = rev (sublist (Zlength al - hi) (Zlength al - lo) al).

Lemma sublist_app:
  forall {A} lo hi (al bl: list A),
  0 <= lo <= hi -> hi <= Zlength al + Zlength bl ->
  sublist lo hi (al++bl) =
  sublist (Z.min lo (Zlength al)) (Z.min hi (Zlength al)) al ++

Lemma sublist_split:
  forall {A} lo mid hi (al: list A),
  0 <= lo <= mid ->
  mid <= hi <= Zlength al ->
  sublist lo hi al = sublist lo mid al ++ sublist mid hi al.

Lemma sublist_last_1 : forall {A}{d: Inhabitant A} lo hi (al : list A), 0 <= lo <= hi -> hi + 1 <= Zlength al ->
  sublist lo (hi + 1) al = sublist lo hi al ++ [Znth hi al].

Lemma Zlen_le_1_rev:
 forall {A} (al: list A),
  Zlength al <= 1 -> rev al = al.

Lemma skipn_0:
  forall A (l: list A), skipn 0 l = l.

Lemma sublist_1_cons {A} l (v:A) n: sublist 1 n (v::l) = sublist 0 (n-1) l.

Lemma sublist_nil': forall (A : Type) (lo lo': Z) (al : list A), lo=lo' -> sublist lo lo' al = [].

Lemma sublist_skip {A} (l:list A) i : 0<=i ->  sublist i (Zlength l) l = skipn (Z.to_nat i) l.

Lemma sublist_firstn {A} (l:list A) i: sublist 0 i l = firstn (Z.to_nat i) l.

Lemma sublist_app1:
  forall (A : Type) (k i : Z) (al bl : list A),
  0 <= k <= i -> i <= Zlength al -> sublist k i (al ++ bl) = sublist k i al.

Lemma sublist0_app1 {A} i (al bl:list A): 0<= i <= Zlength al ->
  sublist 0 i (al ++ bl) = sublist 0 i al.

Lemma sublist_app2 {A} i j (al bl:list A): 0<=Zlength al <= i->
  sublist i j (al ++ bl) = sublist (i-Zlength al) (j-Zlength al) bl.

Lemma sublist_sublist0 {A} i j k (l:list A): 0<=k -> k<=i<=j ->
  sublist k i (sublist 0 j l) = sublist k i l.

Lemma sublist_sublist00 {A} i j (l:list A): 0<=i<=j ->
  sublist 0 i (sublist 0 j l) = sublist 0 i l.

Lemma skipn_list_repeat:
   forall A k n (a: A),
     (k <= n)%nat -> skipn k (list_repeat n a) = list_repeat (n-k) a.

Lemma sublist_list_repeat {A} i j k (v:A) (I: 0<=i)
          (IJK: i <= j <= k):
      sublist i j (list_repeat (Z.to_nat k) v) = list_repeat (Z.to_nat (j-i)) v.

Lemma Zlength_list_repeat:
  forall {A} n (x: A),
  0 <= n ->
  Zlength (list_repeat (Z.to_nat n) x) = n.

Lemma list_repeat_0:
  forall {A} (x:A), list_repeat (Z.to_nat 0) x = nil.

Lemma Znth_list_repeat_inrange:
  forall {A}{d: Inhabitant A} i n (a: A),
   (0 <= i < n)%Z ->
   Znth i (list_repeat (Z.to_nat n) a) = a.

Lemma firstn_nil {A} n: firstn n (nil:list A) = nil.

Lemma firstn_In {A} (x:A): forall l n, In x (firstn n l) -> In x l.
Lemma skipn_In {A} (x:A): forall l n, In x (skipn n l) -> In x l.

Lemma sublist_In {A} lo hi data (x:A) (I:In x (sublist lo hi data)): In x data.

Lemma Zlength_list_repeat' {A} n (v:A): Zlength (list_repeat n v) = Z.of_nat n.

Lemma sublist0_app2 {A : Type} i (al bl : list A):
  Zlength al <= i <= Zlength al + Zlength bl ->
  sublist 0 i (al ++ bl) = al ++ sublist 0 (i - Zlength al) bl.

Lemma sublist_rejoin':
  forall {A} lo mid mid' hi (al: list A),
  mid=mid' ->
  0 <= lo <= mid ->
  mid' <= hi <= Zlength al ->
  sublist lo mid al ++ sublist mid' hi al = sublist lo hi al.

Hint Rewrite @sublist_nil' using list_solve: sublist.
Hint Rewrite @app_nil_l : sublist.
Hint Rewrite @Zlength_rev : sublist.
Hint Rewrite @sublist_rejoin' using list_solve : sublist.

Lemma subsub1:
 forall a b : Z, (a-(a-b)) = b.
Hint Rewrite subsub1 : sublist.

Lemma sublist_app':
  forall {A} lo hi (al bl: list A),
  0 <= lo <= Zlength al ->
  0 <= hi-Zlength al <= Zlength bl ->
  sublist lo hi (al++bl) =
  sublist lo (Zlength al) al ++
  sublist 0 (hi-Zlength al) bl.

Lemma upd_Znth_Zlength {A} i (l:list A) v: 0<=i < Zlength l ->
      Zlength (upd_Znth i l v) = Zlength l.

Lemma upd_Znth_map {A B} (f:A -> B) i l v:
      upd_Znth i (map f l) (f v) =
      map f (upd_Znth i l v).

Lemma upd_Znth_lookup K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i j (v:A) (I: 0<=i<K) (J: 0<=j<K),
   (i=j /\ Znth i (upd_Znth j l v) = v) \/
   (i<>j /\ Znth i (upd_Znth j l v) = Znth i l).

Lemma upd_Znth_lookup' K {A}{d: Inhabitant A}: forall l (L:Zlength l = K) i (I: 0<=i<K) j (J: 0<=j<K) (v:A),
    Znth i (upd_Znth j l v) = if zeq i j then v else Znth i l.

Lemma upd_Znth_char {A} n l1 (v:A) l2 w: Zlength l1=n ->
      upd_Znth n (l1 ++ v :: l2) w = l1 ++ w :: l2.

Lemma upd_Znth_same {A}{d: Inhabitant A}: forall i l u, 0<= i< Zlength l -> Znth i (upd_Znth i l u) = u.

Lemma upd_Znth_diff {A}{d: Inhabitant A}: forall i j l u, 0<= i< Zlength l -> 0<= j< Zlength l -> i<>j ->
      Znth i (upd_Znth j l u) = Znth i l.

Lemma upd_Znth_app1 {A} i l1 l2 (I: 0 <= i < Zlength l1) (v:A):
      upd_Znth i (l1++l2) v = upd_Znth i l1 v ++ l2.

Lemma upd_Znth_app2 {A} (l1 l2:list A) i v:
  Zlength l1 <= i <= Zlength l1 + Zlength l2 ->
  upd_Znth i (l1 ++ l2) v = l1 ++ upd_Znth (i-Zlength l1) l2 v.

Lemma upd_Znth0 {A} (l:list A) v:
upd_Znth 0 l v = v :: sublist 1 (Zlength l) l.

Lemma sublist_upd_Znth_l: forall {A} (l: list A) i lo hi v,
  0 <= lo <= hi ->
  hi <= i < Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_r: forall {A} (l: list A) i lo hi v,
  0 <= i < lo ->
  lo <= hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = sublist lo hi l.

Lemma sublist_upd_Znth_lr: forall {A} (l: list A) i lo hi v,
  0 <= lo <= i->
  i < hi <= Zlength l ->
  sublist lo hi (upd_Znth i l v) = upd_Znth (i - lo) (sublist lo hi l) v.

Hint Rewrite @Znth_list_repeat_inrange : sublist.
Hint Rewrite @Zlength_cons @Zlength_nil: sublist.
Hint Rewrite @list_repeat_0: sublist.
Hint Rewrite <- @app_nil_end : sublist.
Hint Rewrite @Zlength_app: sublist.
Hint Rewrite @Zlength_map: sublist.
Hint Rewrite @Zlength_list_repeat using list_solve: sublist.
Hint Rewrite Z.sub_0_r Z.add_0_l Z.add_0_r : sublist.
Hint Rewrite @Zlength_sublist using list_solve: sublist.
Hint Rewrite Z.max_r Z.max_l using omega : sublist.
Hint Rewrite Z.min_r Z.min_l using omega : sublist.
Hint Rewrite Z.add_simpl_r Z.sub_add Z.sub_diag : sublist.
Hint Rewrite @sublist_sublist using list_solve : sublist.
Hint Rewrite @sublist_app1 using list_solve : sublist.
Hint Rewrite @sublist_app2 using list_solve : sublist.
Hint Rewrite @sublist_list_repeat  using list_solve : sublist.
Hint Rewrite @sublist_same using list_solve : sublist.
Hint Rewrite Z.add_simpl_l : sublist.
Hint Rewrite Z.add_add_simpl_l_l Z.add_add_simpl_l_r
     Z.add_add_simpl_r_l Z.add_add_simpl_r_r : sublist.
Hint Rewrite Z.add_0_r : sublist.
Hint Rewrite @app_Znth1 using list_solve : sublist.
Hint Rewrite @app_Znth2 using list_solve : sublist.
Hint Rewrite @Znth_sublist using list_solve : sublist.
Hint Rewrite @upd_Znth_Zlength using list_solve : sublist.

Hint Rewrite @sublist_nil : sublist.

Lemma list_repeat_app':
 forall {A: Type} a b (x:A), 
    0 <= a -> 0 <= b ->
    list_repeat (Z.to_nat a) x ++ list_repeat (Z.to_nat b) x = list_repeat (Z.to_nat (a+b)) x.

Lemma Znth_overflow:
  forall {A}{d: Inhabitant A} i (al: list A), i >= Zlength al -> Znth i al = d.

Lemma Znth_underflow:
  forall {A}{d: Inhabitant A} i (al: list A),  i < 0 -> Znth i al = d.

Lemma Znth_outofbounds:
  forall {A}{d: Inhabitant A} i (al: list A),  (i < 0 \/ i >= Zlength al) -> Znth i al = d.

Lemma sublist_one:
  forall {A}{d: Inhabitant A} lo hi (al: list A),
    0 <= lo -> hi <= Zlength al ->
    lo+1=hi -> sublist lo hi al = Znth lo al :: nil.

Lemma Forall_app :
forall {A} P (l1 l2 :list A),
Forall P (l1 ++ l2) <->
Forall P l1 /\ Forall P l2.

Lemma Forall_firstn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (firstn n l).

Lemma Forall_skipn:
  forall A (f: A -> Prop) n l, Forall f l -> Forall f (skipn n l).

Lemma Forall_map:
  forall {A B} (f: B -> Prop) (g: A -> B) al,
   Forall f (map g al) <-> Forall (Basics.compose f g) al.

Lemma Forall_sublist:
  forall {A} (f: A -> Prop) lo hi al,
   Forall f al -> Forall f (sublist lo hi al).

Hint Rewrite @upd_Znth_app1 using list_solve : sublist.
Hint Rewrite @upd_Znth_app2 using list_solve : sublist.

Lemma map_list_repeat: forall {A B} (f: A->B) n (x:A), map f (list_repeat n x) = list_repeat n (f x).
Hint Rewrite @map_list_repeat : sublist.

Lemma Zlength_sublist_correct: forall {A} (l: list A) (lo hi: Z),
  0 <= lo <= hi ->
  hi <= Zlength l ->
  Zlength (sublist lo hi l) = hi - lo.

Lemma Zlength_sublist_incorrect: forall {A} (l: list A) (lo hi: Z),
  0 <= lo < hi ->
  hi > Zlength l ->
  Zlength (sublist lo hi l) < hi - lo.

Lemma nth_Znth {A} {d: Inhabitant A}:
forall n (xs:list A), 0 <= n < Zlength xs -> (nth (Z.to_nat n) xs d) = (Znth n xs). *)

Require Import mailbox.lockfree_linsearch.
(* mailbox.lockfree_linsearch:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition _CAS_SC : ident := 74%positive.
Definition ___builtin_annot : ident := 8%positive.
Definition ___builtin_annot_intval : ident := 9%positive.
Definition ___builtin_bswap : ident := 32%positive.
Definition ___builtin_bswap16 : ident := 34%positive.
Definition ___builtin_bswap32 : ident := 33%positive.
Definition ___builtin_clz : ident := 35%positive.
Definition ___builtin_clzl : ident := 36%positive.
Definition ___builtin_clzll : ident := 37%positive.
Definition ___builtin_ctz : ident := 38%positive.
Definition ___builtin_ctzl : ident := 39%positive.
Definition ___builtin_ctzll : ident := 40%positive.
Definition ___builtin_debug : ident := 53%positive.
Definition ___builtin_fabs : ident := 6%positive.
Definition ___builtin_fmadd : ident := 44%positive.
Definition ___builtin_fmax : ident := 42%positive.
Definition ___builtin_fmin : ident := 43%positive.
Definition ___builtin_fmsub : ident := 45%positive.
Definition ___builtin_fnmadd : ident := 46%positive.
Definition ___builtin_fnmsub : ident := 47%positive.
Definition ___builtin_fsqrt : ident := 41%positive.
Definition ___builtin_membar : ident := 10%positive.
Definition ___builtin_memcpy_aligned : ident := 7%positive.
Definition ___builtin_nop : ident := 52%positive.
Definition ___builtin_read16_reversed : ident := 48%positive.
Definition ___builtin_read32_reversed : ident := 49%positive.
Definition ___builtin_va_arg : ident := 12%positive.
Definition ___builtin_va_copy : ident := 13%positive.
Definition ___builtin_va_end : ident := 14%positive.
Definition ___builtin_va_start : ident := 11%positive.
Definition ___builtin_write16_reversed : ident := 50%positive.
Definition ___builtin_write32_reversed : ident := 51%positive.
Definition ___compcert_va_composite : ident := 18%positive.
Definition ___compcert_va_float64 : ident := 17%positive.
Definition ___compcert_va_int32 : ident := 15%positive.
Definition ___compcert_va_int64 : ident := 16%positive.
Definition ___i64_dtos : ident := 19%positive.
Definition ___i64_dtou : ident := 20%positive.
Definition ___i64_sar : ident := 31%positive.
Definition ___i64_sdiv : ident := 25%positive.
Definition ___i64_shl : ident := 29%positive.
Definition ___i64_shr : ident := 30%positive.
Definition ___i64_smod : ident := 27%positive.
Definition ___i64_stod : ident := 21%positive.
Definition ___i64_stof : ident := 23%positive.
Definition ___i64_udiv : ident := 26%positive.
Definition ___i64_umod : ident := 28%positive.
Definition ___i64_utod : ident := 22%positive.
Definition ___i64_utof : ident := 24%positive.
Definition _a : ident := 1%positive.
Definition _acquire : ident := 59%positive.
Definition _atomic_loc : ident := 5%positive.
Definition _c : ident := 73%positive.
Definition _entry : ident := 79%positive.
Definition _exit : ident := 54%positive.
Definition _free : ident := 55%positive.
Definition _free_atomic : ident := 68%positive.
Definition _freelock : ident := 58%positive.
Definition _get_item : ident := 86%positive.
Definition _i : ident := 64%positive.
Definition _idx : ident := 81%positive.
Definition _key : ident := 77%positive.
Definition _l : ident := 65%positive.
Definition _load_SC : ident := 70%positive.
Definition _load_relaxed : ident := 75%positive.
Definition _lock : ident := 4%positive.
Definition _lock_t : ident := 2%positive.
Definition _m_entries : ident := 80%positive.
Definition _main : ident := 76%positive.
Definition _make_atomic : ident := 66%positive.
Definition _makelock : ident := 57%positive.
Definition _malloc : ident := 56%positive.
Definition _n : ident := 61%positive.
Definition _p : ident := 62%positive.
Definition _prev_key : ident := 83%positive.
Definition _probed_key : ident := 85%positive.
Definition _release : ident := 60%positive.
Definition _result : ident := 82%positive.
Definition _set_item : ident := 84%positive.
Definition _store_SC : ident := 72%positive.
Definition _surely_malloc : ident := 63%positive.
Definition _tgt : ident := 67%positive.
Definition _v : ident := 71%positive.
Definition _val : ident := 3%positive.
Definition _value : ident := 78%positive.
Definition _x : ident := 69%positive.
Definition _t'1 : ident := 87%positive.
Definition _t'2 : ident := 88%positive.

Definition v_m_entries := {|
  gvar_info := (tarray (Tstruct _entry noattr) 16384);
  gvar_init := (Init_space 131072 :: nil);
  gvar_readonly := false;
  gvar_volatile := false
|}.

Definition f_set_item := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: (_value, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr (Tstruct _atomic_loc noattr))) ::
               (_result, tint) :: (_prev_key, tint) :: (_t'2, tint) ::
               (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _idx (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _i
          (Efield
            (Ederef
              (Ebinop Oadd
                (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
              (Tstruct _entry noattr)) _key
            (tptr (Tstruct _atomic_loc noattr))))
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _CAS_SC (Tfunction
                              (Tcons (tptr (Tstruct _atomic_loc noattr))
                                (Tcons tint (Tcons tint Tnil))) tint
                              cc_default))
              ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
               (Econst_int (Int.repr 0) tint) :: (Etempvar _key tint) :: nil))
            (Sset _result (Etempvar _t'1 tint)))
          (Ssequence
            (Sifthenelse (Eunop Onotbool (Etempvar _result tint) tint)
              (Ssequence
                (Ssequence
                  (Scall (Some _t'2)
                    (Evar _load_SC (Tfunction
                                     (Tcons
                                       (tptr (Tstruct _atomic_loc noattr))
                                       Tnil) tint cc_default))
                    ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                     nil))
                  (Sset _prev_key (Etempvar _t'2 tint)))
                (Sifthenelse (Ebinop One (Etempvar _prev_key tint)
                               (Etempvar _key tint) tint)
                  Scontinue
                  Sskip))
              Sskip)
            (Ssequence
              (Sset _i
                (Efield
                  (Ederef
                    (Ebinop Oadd
                      (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                      (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                    (Tstruct _entry noattr)) _value
                  (tptr (Tstruct _atomic_loc noattr))))
              (Scall None
                (Evar _store_SC (Tfunction
                                  (Tcons (tptr (Tstruct _atomic_loc noattr))
                                    (Tcons tint Tnil)) tvoid cc_default))
                ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                 (Etempvar _value tint) :: nil)))))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition f_get_item := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := ((_key, tint) :: nil);
  fn_vars := nil;
  fn_temps := ((_idx, tint) :: (_i, (tptr (Tstruct _atomic_loc noattr))) ::
               (_probed_key, tint) :: (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _idx (Econst_int (Int.repr 0) tint))
  (Sloop
    (Ssequence
      Sskip
      (Ssequence
        (Sset _i
          (Efield
            (Ederef
              (Ebinop Oadd
                (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
              (Tstruct _entry noattr)) _key
            (tptr (Tstruct _atomic_loc noattr))))
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _load_SC (Tfunction
                               (Tcons (tptr (Tstruct _atomic_loc noattr))
                                 Tnil) tint cc_default))
              ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) :: nil))
            (Sset _probed_key (Etempvar _t'1 tint)))
          (Ssequence
            (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                           (Etempvar _key tint) tint)
              (Ssequence
                (Sset _i
                  (Efield
                    (Ederef
                      (Ebinop Oadd
                        (Evar _m_entries (tarray (Tstruct _entry noattr) 16384))
                        (Etempvar _idx tint) (tptr (Tstruct _entry noattr)))
                      (Tstruct _entry noattr)) _value
                    (tptr (Tstruct _atomic_loc noattr))))
                (Ssequence
                  (Scall (Some _t'2)
                    (Evar _load_SC (Tfunction
                                     (Tcons
                                       (tptr (Tstruct _atomic_loc noattr))
                                       Tnil) tint cc_default))
                    ((Etempvar _i (tptr (Tstruct _atomic_loc noattr))) ::
                     nil))
                  (Sreturn (Some (Etempvar _t'2 tint)))))
              Sskip)
            (Sifthenelse (Ebinop Oeq (Etempvar _probed_key tint)
                           (Econst_int (Int.repr 0) tint) tint)
              (Sreturn (Some (Econst_int (Int.repr 0) tint)))
              Sskip)))))
    (Sset _idx
      (Ebinop Oadd (Etempvar _idx tint) (Econst_int (Int.repr 1) tint) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _entry Struct
   ((_key, (tptr (Tstruct _atomic_loc noattr))) ::
    (_value, (tptr (Tstruct _atomic_loc noattr))) :: nil)
   noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr)) (Tcons tint Tnil)) tvoid
     cc_default)) ::
 (_CAS_SC,
   Gfun(External (EF_external "CAS_SC"
                   (mksignature (AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     (Some AST.Tint) cc_default))
     (Tcons (tptr (Tstruct _atomic_loc noattr))
       (Tcons tint (Tcons tint Tnil))) tint cc_default)) ::
 (_m_entries, Gvar v_m_entries) :: (_set_item, Gfun(Internal f_set_item)) ::
 (_get_item, Gfun(Internal f_get_item)) :: nil);
prog_public :=
(_get_item :: _set_item :: _m_entries :: _CAS_SC :: _store_SC :: _load_SC ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_fsqrt :: ___builtin_ctzll ::
 ___builtin_ctzl :: ___builtin_ctz :: ___builtin_clzll :: ___builtin_clzl ::
 ___builtin_clz :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod ::
 ___i64_smod :: ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof ::
 ___i64_utod :: ___i64_stod :: ___i64_dtou :: ___i64_dtos ::
 ___compcert_va_composite :: ___compcert_va_float64 ::
 ___compcert_va_int64 :: ___compcert_va_int32 :: ___builtin_va_end ::
 ___builtin_va_copy :: ___builtin_va_arg :: ___builtin_va_start ::
 ___builtin_membar :: ___builtin_annot_intval :: ___builtin_annot ::
 ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)



Set Bullet Behavior "Strict Subproofs".



Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.



Definition surely_malloc_spec :=

 DECLARE _surely_malloc

   WITH n:Z

   PRE [ _n OF tuint ]

       PROP (0 <= n <= Int.max_unsigned)

       LOCAL (temp _n (Vint (Int.repr n)))

       SEP ()

    POST [ tptr tvoid ] EX p:_,

       PROP ()

       LOCAL (temp ret_temp p)

       SEP (malloc_token Tsh n p * memory_block Tsh n p).



Definition tentry := Tstruct _entry noattr.



Definition entry_hists entries hists := fold_right_sepcon (map (fun i =>

  let '(hp, e) := (Znth i hists ([], []), Znth i entries Vundef) in

    ghost_hist (fst hp) (field_address tentry [StructField _key] e) *

    ghost_hist (snd hp) (field_address tentry [StructField _value] e)) (upto 20)).



Fixpoint index_of (m : list (Z * Z)) (k : Z) :=

  match m with

  | [] => None

  | (k1, v1) :: rest => if eq_dec k1 k then Some 0

                        else option_map Z.succ (index_of rest k)

  end.



Lemma index_of_spec : forall k m, match index_of m k with

  | Some i => 0 <= i < Zlength m /\ fst (Znth i m (0, 0)) = k

  | None => ~In k (map fst m) end.

Proof.

  induction m; simpl; auto; intros.

  destruct a.

  rewrite Zlength_cons.

  pose proof (Zlength_nonneg m).

  destruct (eq_dec z k); [split; auto; omega|].

  destruct (index_of m k); simpl.

  - destruct IHm; unfold Z.succ; rewrite Znth_pos_cons, Z.add_simpl_r; [split|]; auto; omega.

  - tauto.

Qed.



Definition set m k v :=

  match index_of m k with

  | Some i => upd_Znth i m (k, v)

  | None => m ++ [(k, v)]

  end.



Definition get m k := option_map (fun i => snd (Znth i m (0, 0))) (index_of m k).



Definition value_of e :=

  match e with

  | Load v => v

  | Store v => v

  | CAS r c w => if eq_dec r c then w else r

  end.



Definition last_value (h : hist) v :=

  

  (h = [] /\ v = vint 0) \/

  exists n e, In (n, e) h /\ value_of e = v /\ Forall (fun x => let '(m, _) := x in m <= n)%nat h.



Lemma last_value_new : forall h n e, Forall (fun x => fst x < n)%nat h ->

  last_value (h ++ [(n, e)]) (value_of e).

Proof.

  right.

  do 3 eexists; [rewrite in_app; simpl; eauto|].

  rewrite Forall_app; repeat constructor.

  eapply Forall_impl; [|eauto]; intros.

  destruct a; simpl in *; omega.

Qed.



Definition ordered_hist h := forall i j (Hi : 0 <= i < j) (Hj : j < Zlength h),

  (fst (Znth i h (O, Store (vint 0))) < fst (Znth j h (O, Store (vint 0))))%nat.



Lemma ordered_cons : forall t e h, ordered_hist ((t, e) :: h) ->

  Forall (fun x => let '(m, _) := x in t < m)%nat h /\ ordered_hist h.

Proof.

  unfold ordered_hist; split.

  - rewrite Forall_forall; intros (?, ?) Hin.

    apply In_Znth with (d := (O, Store (vint 0))) in Hin.

    destruct Hin as (j & ? & Hj).

    exploit (H 0 (j + 1)); try omega.

    { rewrite Zlength_cons; omega. }

    rewrite Znth_0_cons, Znth_pos_cons, Z.add_simpl_r, Hj by omega; auto.

  - intros; exploit (H (i + 1) (j + 1)); try omega.

    { rewrite Zlength_cons; omega. }

    rewrite !Znth_pos_cons, !Z.add_simpl_r by omega; auto.

Qed.



Lemma ordered_last : forall t e h (Hordered : ordered_hist h) (Hin : In (t, e) h)

  (Ht : Forall (fun x => let '(m, _) := x in m <= t)%nat h), last h (O, Store (vint 0)) = (t, e).

Proof.

  induction h; [contradiction | simpl; intros].

  destruct a; apply ordered_cons in Hordered; destruct Hordered as (Ha & ?).

  inversion Ht as [|??? Hp]; subst.

  destruct Hin as [Hin | Hin]; [inv Hin|].

  - destruct h; auto.

    inv Ha; inv Hp; destruct p; omega.

  - rewrite IHh; auto.

    destruct h; auto; contradiction.

Qed.



Definition value_of_hist (h : hist) := value_of (snd (last h (O, Store (vint 0)))).



Lemma ordered_last_value : forall h v (Hordered : ordered_hist h), last_value h v <-> value_of_hist h = v.

Proof.

  unfold last_value, value_of_hist; split; intro.

  - destruct H as [(? & ?) | (? & ? & ? & ? & ?)]; subst; auto.

    erewrite ordered_last; eauto; auto.

  - destruct h; [auto | right].

    destruct (last (p :: h) (O, Store (vint 0))) as (t, e) eqn: Hlast.

    exploit (@app_removelast_last _ (p :: h)); [discriminate | intro Heq].

    rewrite Hlast in Heq.

    exists t; exists e; repeat split; auto.

    + rewrite Heq, in_app; simpl; auto.

    + unfold ordered_hist in Hordered.

      rewrite Forall_forall; intros (?, ?) Hin.

      apply In_Znth with (d := (O, Store (vint 0))) in Hin.

      destruct Hin as (i & ? & Hi).

      rewrite <- Znth_last in Hlast.

      destruct (eq_dec i (Zlength (p :: h) - 1)).

      * subst; rewrite Hlast in Hi; inv Hi; auto.

      * exploit (Hordered i (Zlength (p :: h) - 1)); try omega.

        rewrite Hlast, Hi; simpl; omega.

Qed.



Definition wf_map (m : list (Z * Z)) := Forall (fun i => repable_signed i /\ i <> 0) (map fst m).



Definition int_op e :=

  match e with

  | Load v | Store v => tc_val tint v

  | CAS r c w => tc_val tint r /\ tc_val tint c /\ tc_val tint w

  end.



Definition k_R (h : list hist_el) (v : val) := !!(Forall int_op h /\

  forall e, In e h -> value_of e <> vint 0 -> v = value_of e) && emp.



Definition v_R (h : list hist_el) (v : val) := emp.



Definition atomic_entry sh p := !!(field_compatible tentry [] p) && EX lkey : val, EX lval : val,

  field_at sh tentry [StructField _lkey] lkey p *

  atomic_loc sh lkey (field_address tentry [StructField _key] p) (vint 0) Tsh k_R *

  field_at sh tentry [StructField _lvalue] lval p *

  atomic_loc sh lval (field_address tentry [StructField _value] p) (vint 0) Tsh v_R.



Definition failed_CAS k (a b : hist * hist) := exists t r, Forall (fun x => fst x < t)%nat (fst a) /\

  fst b = fst a ++ [(t, CAS (Vint r) (vint 0) (vint k))] /\

  r <> Int.zero /\ r <> Int.repr k /\ snd b = snd a /\

  (let v := value_of_hist (fst a) in v <> vint 0 -> v = Vint r).



Definition wf_hists h l := Forall (fun x => ordered_hist (fst x) /\ ordered_hist (snd x) /\

  Forall int_op (map snd (fst x)) /\ Forall int_op (map snd (snd x))) h /\ 0 <= l <= Zlength h /\

    Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 l h) /\

    Forall (fun x => value_of_hist (fst x) = vint 0) (sublist l (Zlength h) h).



Definition make_int v := match v with Vint i => Int.signed i | _ => 0 end.



Lemma make_int_spec : forall v, tc_val tint v -> vint (make_int v) = v.

Proof.

  destruct v; try contradiction; simpl.

  rewrite Int.repr_signed; auto.

Qed.



Fixpoint make_map h :=

  match h with

  | [] => []

  | (hk, hv) :: rest => let k := make_int (value_of_hist hk) in

      if eq_dec k 0 then [] else (k, make_int (value_of_hist hv)) :: make_map rest

  end.



Lemma ordered_snoc : forall h t e, ordered_hist h -> Forall (fun x => fst x < t)%nat h ->

  ordered_hist (h ++ [(t, e)]).

Proof.

  repeat intro.

  rewrite Zlength_app, Zlength_cons, Zlength_nil in Hj.

  rewrite app_Znth1 by omega.

  destruct (eq_dec j (Zlength h)).

  - rewrite Znth_app1; auto.

    apply Forall_Znth; auto; omega.

  - specialize (H i j).

    rewrite app_Znth1 by omega; apply H; auto; omega.

Qed.



Lemma Forall_set : forall P m k v, Forall P m -> P (k, v) -> Forall P (set m k v).

Proof.

  intros; unfold set.

  destruct (index_of m k).

  - apply Forall_upd_Znth; auto.

  - rewrite Forall_app; split; auto.

Qed.



Lemma wf_make_map : forall h, wf_map (make_map h).

Proof.

  unfold wf_map; induction h; simpl; auto.

  destruct a.

  if_tac; simpl; auto.

  constructor; auto.

  split; auto.

  destruct (value_of_hist _); simpl; try (split; computable).

  apply Int.signed_range.

Qed.



Lemma make_map_eq : forall h h', Forall2 (fun a b => value_of_hist (fst a) = value_of_hist (fst b) /\

  value_of_hist (snd a) = value_of_hist (snd b)) h h' -> make_map h = make_map h'.

Proof.

  induction 1; auto; simpl.

  destruct x, y; simpl in *.

  destruct H as (-> & ->); rewrite IHForall2; auto.

Qed.



Lemma int_op_value : forall e, int_op e -> tc_val tint (value_of e).

Proof.

  destruct e; auto; simpl.

  intros (? & ? & ?); destruct (eq_dec r c); auto.

Qed.



Corollary int_op_value_of_hist : forall h, Forall int_op (map snd h) -> tc_val tint (value_of_hist h).

Proof.

  intros; unfold value_of_hist.

  apply Forall_last; simpl; auto.

  rewrite Forall_map in H; eapply Forall_impl; [|eauto].

  simpl; intros; apply int_op_value; auto.

Qed.



Lemma make_map_app : forall h1 h2 (Hnz : Forall (fun x => value_of_hist (fst x) <> vint 0) h1)

  (Hint : Forall (fun x => Forall int_op (map snd (fst x))) h1),

  make_map (h1 ++ h2) = make_map h1 ++ make_map h2.

Proof.

  induction 1; auto; simpl; intros.

  inv Hint.

  destruct x as (h, ?).

  rewrite IHHnz; auto.

  if_tac; auto.

  exploit int_op_value_of_hist; eauto; simpl.

  destruct (value_of_hist h) eqn: Hval; try contradiction; simpl in *.

  contradiction H; rewrite Hval.

  f_equal; apply signed_inj; auto.

Qed.



Lemma make_map_drop : forall h1 h2 (Hz : Forall (fun x => value_of_hist (fst x) = vint 0) h2),

  make_map (h1 ++ h2) = make_map h1.

Proof.

  induction h1; simpl; intros.

  - destruct h2; auto; simpl.

    destruct p as (h, ?).

    if_tac; auto.

    inv Hz.

    contradiction H; simpl in *.

    replace (value_of_hist h) with (vint 0); auto.

  - rewrite IHh1; auto.

Qed.



Lemma index_of_app : forall k m1 m2, index_of (m1 ++ m2) k =

  match index_of m1 k with Some i => Some i | None => option_map (Z.add (Zlength m1)) (index_of m2 k) end.

Proof.

  induction m1; simpl; intros.

  - destruct (index_of m2 k); auto.

  - destruct a.

    destruct (eq_dec z k); auto.

    rewrite IHm1; destruct (index_of m1 k); auto; simpl.

    destruct (index_of m2 k); auto; simpl.

    rewrite Zlength_cons; f_equal; omega.

Qed.



Lemma index_of_out : forall k m, Forall (fun x => fst x <> k) m -> index_of m k = None.

Proof.

  intros.

  pose proof (index_of_spec k m) as Hk.

  destruct (index_of m k); auto.

  destruct Hk; eapply Forall_Znth in H; eauto.

  subst; contradiction H; eauto.

Qed.



Lemma make_map_length : forall h (Hnz : Forall (fun x => value_of_hist (fst x) <> vint 0) h)

  (Hint : Forall (fun x => Forall int_op (map snd (fst x))) h),

  Zlength (make_map h) = Zlength h.

Proof.

  induction h; auto; simpl; intros.

  inv Hnz; inv Hint.

  destruct a as (hk, ?); simpl in *.

  exploit int_op_value_of_hist; eauto.

  destruct (value_of_hist hk); try contradiction; simpl.

  if_tac; [|rewrite !Zlength_cons, IHh; auto].

  absurd (Vint i = vint 0); auto; f_equal; apply signed_inj; auto.

Qed.



Lemma make_map_no_key : forall h k (Hout : Forall (fun x => make_int (value_of_hist (fst x)) <> k) h),

  Forall (fun x => fst x <> k) (make_map h).

Proof.

  induction h; simpl; auto; intros.

  destruct a.

  inv Hout.

  if_tac; auto.

Qed.



Lemma make_map_nil : forall h, Forall (fun x => value_of_hist (fst x) = vint 0) h -> make_map h = [].

Proof.

  destruct h; auto; simpl.

  destruct p.

  intro H; inversion H as [|?? Heq]; subst.

  simpl in *; rewrite Heq; auto.

Qed.



Definition set_item_trace (h : list (hist * hist)) k v i h' := 0 <= i < Zlength h /\

  Forall2 (failed_CAS k) (sublist 0 i h) (sublist 0 i h') /\

  (let '(hk, hv) := Znth i h ([], []) in exists t r tv, Forall (fun x => fst x < t)%nat hk /\

     Forall (fun x => fst x < tv)%nat hv /\

      Znth i h' ([], []) = (hk ++ [(t, CAS r (vint 0) (vint k))], hv ++ [(tv, Store (vint v))]) /\

      (r = vint 0 \/ r = vint k) /\ (let v := value_of_hist hk in v <> vint 0 -> v = r)) /\

  sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h'.



Lemma set_item_trace_map : forall h k v i h' l (Hwf : wf_hists h l) (Htrace : set_item_trace h k v i h')

  (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),

  wf_hists h' (Z.max (i + 1) l) /\ let m' := make_map (sublist 0 i h' ++ sublist i (Zlength h) h) in

    wf_map (set m' k v) /\ incl (make_map h) m' /\ make_map h' = set m' k v.

Proof.

  intros.

  destruct Htrace as (Hbounds & Hfail & Hi & Hrest).

  destruct (Znth i h ([], [])) as (hk, hv) eqn: Hhi.

  destruct Hi as (t & r & tv & Ht & Htv & Hi & Hr & Hr0).

  assert (Zlength h' = Zlength h) as Hlen.

  { exploit (Znth_inbounds i h' ([], [])).

    { rewrite Hi; intro X; inversion X as [Heq].

      symmetry in Heq; apply app_cons_not_nil in Heq; auto. }

    intro.

    assert (Zlength (sublist (i + 1) (Zlength h) h) = Zlength (sublist (i + 1) (Zlength h') h')) as Heq

      by (rewrite Hrest; auto).

    rewrite !Zlength_sublist in Heq; omega. }

  assert (i <= Zlength h') by (rewrite Hlen; destruct Hbounds; apply Z.lt_le_incl; auto).

  assert (0 <= i + 1 <= Zlength h').

  { rewrite Hlen; destruct Hbounds; split; [|rewrite <- lt_le_1]; auto; omega. }

  destruct Hwf as (Hwf & ? & Hl1 & Hl2).

  assert (vint k <> vint 0).

  { intro; contradiction Hk; apply repr_inj_signed; auto.

    { split; computable. }

    { congruence. }}

  assert (Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 i h')).

  { rewrite Forall_forall; intros (?, ?) Hin.

    exploit (Forall2_In_r (failed_CAS k)); eauto.

    intros ((?, ?) & ? & ? & r1 & ? & ? & ? & ? & ? & ?); simpl in *; subst.

    unfold value_of_hist; rewrite last_snoc; simpl.

    destruct (eq_dec (Vint r1) (vint 0)); auto. }

  assert (h' = sublist 0 i h' ++ Znth i h' ([], []) :: sublist (i + 1) (Zlength h') h') as Hh'.

  { rewrite <- sublist_next, sublist_rejoin, sublist_same; auto; try omega; rewrite Hlen; auto. }

  assert ((if eq_dec r (vint 0) then vint k else r) = vint k) as Hif.

  { if_tac; auto.

    destruct Hr; [absurd (r = vint 0)|]; auto. }

  assert (value_of_hist (fst (Znth i h' ([], []))) = vint k) as Hk'.

  { unfold value_of_hist; rewrite Hi; simpl; rewrite last_snoc; auto. }

  assert (wf_hists h' (Z.max (i + 1) l)) as Hwf'; [|split; auto; split; [|split]].

  - split.

    + rewrite Hh'; clear Hh'; rewrite Forall_app; split; [|constructor].

      * rewrite Forall_forall; intros (?, ?) Hin.

        exploit (Forall2_In_r (failed_CAS k)); eauto.

        intros ((?, ?) & Hin' & ? & ? & ? & ? & ? & ? & ? & ?); simpl in *; subst.

        apply sublist_In in Hin'; rewrite Forall_forall in Hwf; destruct (Hwf _ Hin') as (? & ? & ? & ?).

        rewrite map_app, Forall_app; repeat constructor; auto; apply ordered_snoc; auto.

      * rewrite Hi; simpl.

        eapply Forall_Znth with (i0 := i) in Hwf; auto.

        rewrite Hhi in Hwf; destruct Hwf as (? & ? & ? & ?); rewrite !map_app, !Forall_app; repeat constructor;

          auto; try (apply ordered_snoc; auto).

        destruct Hr; subst; simpl; auto.

      * rewrite <- Hrest; apply Forall_sublist; auto.

    + assert (0 <= Z.max (i + 1) l <= Zlength h'); [|split; auto].

      { destruct (Z.max_spec (i + 1) l) as [(? & ->) | (? & ->)]; auto; omega. }

      split; [|apply Forall_suffix_max with (l1 := h); auto; omega].

      rewrite Hh'; clear Hh'.

      assert (Zlength h' <= i - 0 + Z.succ (Zlength h' - (i + 1))) by omega.

      assert (0 <= Zlength h' - i) by omega.

      destruct (Z.max_spec (i + 1) l) as [(? & ->) | (? & ->)].

      * rewrite !sublist_app; rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega.

        rewrite Z.min_l, Z.min_r, Z.max_r, Z.max_l by omega.

        rewrite !Z.sub_0_r.

        rewrite sublist_sublist, !Z.add_0_r by omega.

        rewrite Forall_app; split; auto.

        rewrite sublist_0_cons by omega.

        constructor; [rewrite Hk'; auto|].

        rewrite sublist_sublist by omega.

        rewrite <- Z.sub_add_distr, Z.sub_simpl_r.

        rewrite Z.add_0_l, sublist_parts2; try omega.

        rewrite <- Hrest.

        rewrite <- sublist_parts2 by omega.

        rewrite sublist_parts1 by omega; apply Forall_sublist; auto.

      * rewrite !sublist_app; rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega.

        rewrite !Z.sub_0_r, Z.min_l, Z.min_r, Z.max_r, Z.max_l; auto; try omega.

        rewrite Z.add_simpl_l.

        rewrite sublist_same, sublist_len_1 with (d := ([], [])), Znth_0_cons;

          rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega; simpl.

        rewrite Forall_app; split; auto.

        constructor; auto; rewrite Hk'; auto.

  - unfold wf_map; rewrite Forall_map; apply Forall_set; auto.

    rewrite <- Forall_map; apply wf_make_map.

  - clear Hh'; match goal with H : 0 <= l <= _ |- _ => destruct H end.

    assert (Forall2 (fun a b => value_of_hist (fst a) = value_of_hist (fst b) /\

      value_of_hist (snd a) = value_of_hist (snd b)) (sublist 0 (Z.min i l) h) (sublist 0 (Z.min i l) h')) as Heq.

    { rewrite Forall2_eq_upto with (d1 := ([] : hist, [] : hist))(d2 := ([] : hist, [] : hist)).

      assert (0 <= Z.min i l <= Zlength h) as (? & ?).

      { split; [rewrite Z.min_glb_iff | rewrite Z.min_le_iff]; auto; omega. }

      split; [rewrite !Zlength_sublist; auto; omega|].

      rewrite Forall_forall; intros ? Hin.

      rewrite In_upto, Z2Nat.id in Hin by (apply Zlength_nonneg).

      assert (value_of_hist (fst (Znth x (sublist 0 (Z.min i l) h) ([], []))) <> vint 0) as Hnz.

      { apply Forall_Znth; auto.

        rewrite <- sublist_prefix; apply Forall_sublist; auto. }

      rewrite Zlength_sublist, Z.sub_0_r in Hin by (auto; omega).

      assert (x < i).

      { destruct Hin; eapply Z.lt_le_trans; eauto.

        apply Z.le_min_l. }

      exploit (Forall2_Znth _ _ _ ([], []) ([], []) Hfail x); auto.

      { rewrite Zlength_sublist; omega. }

      intros (? & r1 & ? & Heq1 & ? & ? & Heq2 & Hv).

      rewrite !Znth_sublist, Z.add_0_r in Heq1, Heq2, Hv, Hnz; auto; try omega.

      rewrite !Znth_sublist, Z.add_0_r in Heq2 by omega.

      rewrite !Znth_sublist, Z.add_0_r by omega.

      rewrite Heq1, Heq2; simpl; split; auto.

      unfold value_of_hist in *; rewrite last_snoc; simpl.

      destruct (eq_dec (Vint r1) (vint 0)); [absurd (r1 = Int.zero); auto; inv e; auto | auto]. }

    replace h with (sublist 0 l h ++ sublist l (Zlength h) h) at 1

      by (rewrite sublist_rejoin, sublist_same; auto; omega).

    rewrite make_map_drop; auto.

    assert (Forall (fun x => Forall int_op (map snd (fst x))) h').

    { destruct Hwf'; eapply Forall_impl; [|eauto]; tauto. }

    destruct (Z.min_spec i l) as [(? & Hmin) | (? & Hmin)]; rewrite Hmin in *; clear Hmin.

    + assert (Forall (fun x : hist * hist => value_of_hist (fst x) <> vint 0) (sublist 0 i h')).

      { eapply Forall_Forall2; try apply Heq.

        { replace i with (Z.min i l) by (apply Z.min_l; omega).

          rewrite <- sublist_prefix; apply Forall_sublist; auto. }

        intros ??? (<- & _); auto. }

      assert (Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 i h'))

        by (apply Forall_sublist; auto).

      rewrite make_map_app; auto.

      rewrite sublist_split with (lo := i)(mid := l) by omega.

      rewrite make_map_app, app_assoc.

      apply incl_appl.

      rewrite <- make_map_app; auto.

      erewrite make_map_eq; [apply incl_refl|].

      rewrite sublist_split with (mid := i) by omega.

      apply Forall2_app; auto.

      rewrite Forall2_eq_upto with (d1 := ([] : hist, [] : hist))(d2 := ([] : hist, [] : hist)).

      split; auto; rewrite Forall_forall; intros; auto.

      * rewrite sublist_parts1 by omega; apply Forall_sublist; auto.

      * apply Forall_sublist; eapply Forall_impl, Hwf; tauto.

    + rewrite sublist_split with (mid := l)(hi := i) by omega.

      rewrite <- app_assoc, make_map_app.

      apply incl_appl.

      erewrite make_map_eq; [apply incl_refl | auto].

      * eapply Forall_Forall2; try apply Heq; auto.

        intros ??? (<- & _); auto.

      * apply Forall_sublist; auto.

  - unfold set.

    destruct Hwf' as (? & ? & Hl1' & ?).

    assert (Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 i h')).

    { eapply Forall_sublist, Forall_impl; [|eauto]; tauto. }

    rewrite Hh' at 1; clear Hh'.

    rewrite make_map_app by auto.

    assert (Forall (fun x => make_int (value_of_hist (fst x)) <> k) (sublist 0 i h')) as Hmiss.

    { rewrite Forall_forall; intros (hk', hv') Hin.

      exploit (Forall2_In_r _ (hk', hv') _ _ Hfail); auto.

      intros (? & ? & ? & r1 & ? & Heqi & ? & ? & ? & ?); subst.

      unfold value_of_hist; rewrite Heqi, last_snoc; simpl.

      destruct (eq_dec (Vint r1) (vint 0)); simpl.

      { absurd (r1 = Int.zero); auto; inv e; auto. }

      intro; absurd (r1 = Int.repr k); subst; auto.

      rewrite Int.repr_signed; auto. }

    rewrite make_map_app at 1 by auto.

    rewrite index_of_app, index_of_out, make_map_length by (auto; apply make_map_no_key; auto); simpl.

    rewrite Hi; simpl.

    unfold value_of_hist; rewrite !last_snoc; simpl.

    rewrite Hif; simpl.

    rewrite !Int.signed_repr; auto.

    destruct (eq_dec k 0); [contradiction Hk; auto|].

    destruct (zlt i l).

    + destruct (eq_dec (value_of_hist hk) (vint 0)).

      { eapply Forall_Znth with (i0 := i) in Hl1; [|rewrite Zlength_sublist; omega].

        rewrite Znth_sublist, Z.add_0_r, Hhi in Hl1 by omega; contradiction Hl1. }

      assert (value_of_hist hk = vint k) as Hik.

      { rewrite Hr0; auto.

        rewrite Hr0 in n0; auto.

        destruct Hr; [contradiction n0; auto | auto]. }

      erewrite sublist_next with (i0 := i), Hhi by omega; simpl.

      rewrite Hik; simpl.

      rewrite Int.signed_repr; auto.

      destruct (eq_dec k 0); [contradiction Hk; auto | simpl].

      rewrite eq_dec_refl; simpl.

      rewrite make_map_app, Z.add_0_r by auto.

      rewrite upd_Znth_app2; rewrite make_map_length; auto.

      rewrite Zminus_diag, upd_Znth0; simpl.

      rewrite Hik; simpl.

      rewrite Int.signed_repr; auto.

      destruct (eq_dec k 0); [contradiction Hk; auto | simpl].

      rewrite sublist_1_cons, Zlength_cons.

      unfold Z.succ; rewrite Z.add_simpl_r.

      rewrite sublist_same with (hi := Zlength (make_map _)), Hrest; auto.

      { pose proof (Zlength_nonneg (make_map ((hk, hv) :: sublist (i + 1) (Zlength h) h))); omega. }

    + erewrite sublist_next with (i0 := i) at 1 by omega; simpl.

      exploit (Forall_Znth (fun x => value_of_hist (fst x) = vint 0) (sublist l (Zlength h) h) (i - l)); auto.

      { rewrite Zlength_sublist; omega. }

      rewrite Znth_sublist, Z.sub_simpl_r, Hhi by omega; simpl.

      rewrite Hhi; intros ->; simpl.

      rewrite make_map_nil with (h := sublist (i + 1) _ _).

      rewrite make_map_drop; auto.

      { replace i with (i - l + l) by (apply Z.sub_simpl_r).

        rewrite <- sublist_suffix by omega; apply Forall_sublist; auto. }

      { rewrite <- Hrest; replace (i + 1) with (i + 1 - l + l) by (apply Z.sub_simpl_r).

        rewrite <- sublist_suffix by omega; apply Forall_sublist; auto. }

Qed.



Definition set_item_spec :=

 DECLARE _set_item

  WITH key : Z, value : Z, p : val, sh : share, entries : list val, h : list (hist * hist), l : Z

  PRE [ _key OF tint, _value OF tint ]

   PROP (repable_signed key; repable_signed value; readable_share sh; key <> 0; Forall isptr entries;

         Zlength h = 20; wf_hists h l)

   LOCAL (temp _key (vint key); temp _value (vint value); gvar _m_entries p)

   SEP (data_at sh (tarray (tptr tentry) 20) entries p;

        fold_right_sepcon (map (atomic_entry sh) entries);

        entry_hists entries h)

  POST [ tvoid ]

   EX i : Z, EX h' : list (hist * hist),

   PROP (set_item_trace h key value i h')

   LOCAL ()

   SEP (data_at sh (tarray (tptr tentry) 20) entries p;

        fold_right_sepcon (map (atomic_entry sh) entries);

        entry_hists entries h').



Definition failed_load k (a b : hist * hist) := exists t r, Forall (fun x => fst x < t)%nat (fst a) /\

  fst b = fst a ++ [(t, Load (Vint r))] /\ r <> Int.zero /\ r <> Int.repr k /\ snd b = snd a /\

  (let v := value_of_hist (fst a) in v <> vint 0 -> v = Vint r).



Definition get_item_trace (h : list (hist * hist)) k v i h' := 0 <= i < Zlength h /\

  Forall2 (failed_load k) (sublist 0 i h) (sublist 0 i h') /\

  (let '(hk, hv) := Znth i h ([], []) in exists t r, Forall (fun x => fst x < t)%nat hk /\

     fst (Znth i h' ([], [])) = hk ++ [(t, Load (vint r))] /\

     (v = 0 /\ r = 0 /\ snd (Znth i h' ([], [])) = hv \/

      r = k /\ exists tv, Forall (fun x => fst x < tv)%nat hv /\

        snd (Znth i h' ([], [])) = hv ++ [(tv, Load (vint v))]) /\

    (let v := value_of_hist hk in v <> vint 0 -> v = vint r)) /\

  sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h'.



Lemma index_of_iff_out : forall m k, index_of m k = None <-> ~In k (map fst m).

Proof.

  split; intro.

  - induction m; auto; simpl in *.

    destruct a.

    destruct (eq_dec z k); [discriminate|].

    destruct (index_of m k); [discriminate|].

    intros [? | ?]; auto.

    contradiction IHm.

  - apply index_of_out.

    rewrite Forall_forall; repeat intro; contradiction H.

    rewrite in_map_iff; eauto.

Qed.



Corollary get_fail_iff : forall m k, get m k = None <-> ~In k (map fst m).

Proof.

  intros; unfold get; rewrite <- index_of_iff_out.

  destruct (index_of m k); simpl; split; auto; discriminate.

Qed.



Lemma Znth_make_map : forall d h i (Hi : 0 <= i < Zlength h)

  (Hnz : Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 (i + 1) h))

  (Hint : Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 (i + 1) h)),

  Znth i (make_map h) d = (make_int (value_of_hist (fst (Znth i h ([], [])))),

                           make_int (value_of_hist (snd (Znth i h ([], []))))).

Proof.

  induction h; simpl; intros.

  { rewrite Zlength_nil in *; omega. }

  destruct a.

  rewrite Zlength_cons in *.

  rewrite sublist_0_cons, Z.add_simpl_r in Hnz, Hint by omega.

  inv Hnz; inv Hint.

  exploit int_op_value_of_hist; eauto; intro; simpl in *.

  destruct (value_of_hist l) eqn: Hfst; try contradiction; simpl.

  if_tac; [absurd (Vint i0 = vint 0); auto; f_equal; apply signed_inj; auto|].

  destruct (eq_dec i 0).

  - subst; rewrite !Znth_0_cons; simpl; auto.

    rewrite Hfst; auto.

  - rewrite !Znth_pos_cons by omega; apply IHh; rewrite ?Z.sub_simpl_r; auto; omega.

Qed.



Lemma get_item_trace_map : forall h k v i h' l (Hwf : wf_hists h l) (Htrace : get_item_trace h k v i h')

  (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),

  match get (make_map h') k with

  | Some v' => v' = v /\ wf_hists h' (Z.max (i + 1) l) /\ incl (set (make_map h) k v) (make_map h')

  | None => l <= i /\ wf_hists h' i /\ v = 0 /\ incl (make_map h) (make_map h') end.

Proof.

  intros.

  destruct Htrace as (Hbounds & Hfail & Hi & Hrest).

  destruct (Znth i h ([], [])) as (hk, hv) eqn: Hhi.

  destruct Hi as (t & r & Ht & Hi1 & Hi2 & Hr0).

  assert (Zlength h' = Zlength h) as Hlen.

  { exploit (Znth_inbounds i h' ([], [])).

    { destruct (Znth i h' ([], [])) as (hk', hv'); intro X; inv X.

      apply app_cons_not_nil in Hi1; auto. }

    intro.

    assert (Zlength (sublist (i + 1) (Zlength h) h) = Zlength (sublist (i + 1) (Zlength h') h')) as Heq

      by (rewrite Hrest; auto).

    rewrite !Zlength_sublist in Heq; omega. }

  assert (i <= Zlength h') by (rewrite Hlen; destruct Hbounds; apply Z.lt_le_incl; auto).

  assert (0 <= i + 1 <= Zlength h').

  { rewrite Hlen; destruct Hbounds; split; [|rewrite <- lt_le_1]; auto; omega. }

  destruct Hwf as (Hwf & ? & Hl1 & Hl2).

  assert (vint k <> vint 0).

  { intro; contradiction Hk; apply repr_inj_signed; auto.

    { split; computable. }

    { congruence. }}

  assert (Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 i h')).

  { rewrite Forall_forall; intros (?, ?) Hin.

    exploit (Forall2_In_r (failed_load k)); eauto.

    intros ((?, ?) & ? & ? & r1 & ? & ? & ? & ? & ? & ?); simpl in *; subst.

    unfold value_of_hist; rewrite last_snoc; simpl.

    intro X; absurd (r1 = Int.zero); auto; inv X; auto. }

  assert (h' = sublist 0 i h' ++ Znth i h' ([], []) :: sublist (i + 1) (Zlength h') h') as Hh'.

  { rewrite <- sublist_next, sublist_rejoin, sublist_same; auto; try omega; rewrite Hlen; auto. }

  assert (Forall (fun x => ordered_hist (fst x) /\ ordered_hist (snd x) /\ Forall int_op (map snd (fst x)) /\

    Forall int_op (map snd (snd x))) h') as Hwf'.

  { rewrite Hh'; clear Hh'; rewrite Forall_app; split; [|constructor].

    - eapply Forall_Forall2; try apply Hfail; [apply Forall_sublist; auto|].

      intros (?, ?) (?, ?) (? & ? & ? & ?) (? & ? & ? & ? & ? & ? & ? & ?); simpl in *; subst.

      rewrite map_app, Forall_app; repeat constructor; auto; apply ordered_snoc; auto.

    - eapply Forall_Znth with (i0 := i) in Hwf; auto.

      rewrite Hhi in Hwf; destruct Hwf as (? & ? & ? & ?).

      rewrite Hi1; split; [apply ordered_snoc; auto|].

      destruct Hi2 as [(? & ? & ->) | (? & ? & ? & ->)]; rewrite !map_app, !Forall_app;

        repeat constructor; auto; try (apply ordered_snoc; auto).

    - rewrite <- Hrest; apply Forall_sublist; auto. }

  assert (Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 i h')).

  { eapply Forall_sublist, Forall_impl, Hwf'; tauto. }

  assert (Forall (fun x => make_int (value_of_hist (fst x)) <> k) (sublist 0 i h')) as Hmiss.

  { clear Hh'; rewrite Forall_forall; intros (hk', hv') Hin.

    exploit (Forall2_In_r _ (hk', hv') _ _ Hfail); auto.

    intros (? & ? & ? & r1 & ? & Heqi & ? & ? & ? & ?); subst.

    unfold value_of_hist; rewrite Heqi, last_snoc; simpl.

    intro; absurd (r1 = Int.repr k); subst; auto.

    rewrite Int.repr_signed; auto. }

  unfold get; destruct (index_of (make_map h') k) eqn: Hindex; simpl.

  - rewrite Hh', make_map_app, index_of_app, index_of_out in Hindex

      by (auto; apply make_map_no_key; auto).

    simpl in Hindex.

    destruct (Znth i h' ([], [])) as (hk', hv') eqn: Hhi'; simpl in *; subst hk'.

    unfold value_of_hist in Hindex; rewrite last_snoc in Hindex; simpl in Hindex.

    destruct Hi2 as [(? & ? & ?) | (? & tv & ? & ?)]; subst r hv'; [discriminate|].

    rewrite Int.signed_repr in Hindex by auto.

    destruct (eq_dec k 0); [contradiction Hk; auto|].

    simpl in Hindex.

    rewrite eq_dec_refl in Hindex; simpl in Hindex.

    inversion Hindex; subst z.

    rewrite make_map_length, Zlength_sublist, Z.sub_simpl_r by (auto; omega).

    assert (0 <= Z.max (i + 1) l <= Zlength h' /\

      Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 (Z.max (i + 1) l) h') /\

      Forall (fun x => value_of_hist (fst x) = vint 0) (sublist (Z.max (i + 1) l) (Zlength h') h'))

      as (? & Hl1' & Hl2'); [|split; [|split; [split; auto|]]].

    + assert (0 <= Z.max (i + 1) l <= Zlength h'); [|split; auto].

      { destruct (Z.max_spec (i + 1) l) as [(? & ->) | (? & ->)]; auto; omega. }

      split; [|apply Forall_suffix_max with (l1 := h); auto; omega].

      rewrite Hh'; clear Hh'.

      assert (Zlength h' <= i - 0 + Z.succ (Zlength h' - (i + 1))) by omega.

      assert (0 <= Zlength h' - i) by omega.

      destruct (Z.max_spec (i + 1) l) as [(? & ->) | (? & ->)].

      * rewrite !sublist_app; rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega.

        rewrite Z.min_l, Z.min_r, Z.max_r, Z.max_l by omega.

        rewrite !Z.sub_0_r.

        rewrite sublist_sublist, !Z.add_0_r by omega.

        rewrite Forall_app; split; auto.

        rewrite sublist_0_cons by omega.

        constructor; [unfold value_of_hist; simpl; rewrite last_snoc; auto|].

        rewrite sublist_sublist by omega.

        rewrite <- Z.sub_add_distr, Z.sub_simpl_r.

        rewrite Z.add_0_l, sublist_parts2; try omega.

        rewrite <- Hrest.

        rewrite <- sublist_parts2 by omega.

        rewrite sublist_parts1 by omega; apply Forall_sublist; auto.

      * rewrite !sublist_app; rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega.

        rewrite !Z.sub_0_r, Z.min_l, Z.min_r, Z.max_r, Z.max_l; auto; try omega.

        rewrite Z.add_simpl_l.

        rewrite sublist_same, sublist_len_1 with (d := ([], [])), Znth_0_cons;

          rewrite ?Zlength_cons, ?Zlength_sublist; auto; try omega; simpl.

        rewrite Forall_app; split; auto.

        constructor; auto; unfold value_of_hist; simpl; rewrite last_snoc; auto.

    + rewrite Znth_make_map, Hhi'; simpl.

      unfold value_of_hist; rewrite last_snoc; simpl.

      apply Int.signed_repr; auto.

      { omega. }

      { rewrite sublist_split with (mid := i), Forall_app by omega; split; auto.

        erewrite sublist_len_1, Hhi' by omega; repeat constructor; simpl.

        unfold value_of_hist; rewrite last_snoc; auto. }

      { eapply Forall_sublist, Forall_impl, Hwf'; tauto. }

    + unfold set.

      rewrite Hh'; clear Hh'.

      rewrite make_map_app by auto; simpl.

      unfold value_of_hist; rewrite !last_snoc; simpl.

      rewrite !Int.signed_repr by auto.

      destruct (eq_dec k 0); [contradiction Hk; auto|].

      assert (0 <= Z.min i l <= Zlength h) as (? & ?).

      { split; [rewrite Z.min_glb_iff | rewrite Z.min_le_iff]; auto; omega. }

      replace h with (sublist 0 (Z.min i l) h ++ sublist (Z.min i l) (Zlength h) h)

        by (rewrite sublist_rejoin, sublist_same; auto; omega).

      assert (Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 (Z.min i l) h)).

      { rewrite <- sublist_prefix; apply Forall_sublist; auto. }

      assert (Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 (Z.min i l) h)).

      { eapply Forall_sublist, Forall_impl, Hwf; tauto. }

      rewrite make_map_app, index_of_app, index_of_out; auto.

      assert (incl (make_map (sublist 0 (Z.min i l) h)) (make_map (sublist 0 (Z.min i l) h'))).

      { erewrite make_map_eq; [apply incl_refl|].

        rewrite Forall2_eq_upto with (d1 := ([] : hist, [] : hist))(d2 := ([] : hist, [] : hist)).

        split; [rewrite !Zlength_sublist; auto; omega|].

        rewrite Forall_forall; intros ? Hin.

        rewrite In_upto, Z2Nat.id in Hin by (apply Zlength_nonneg).

        assert (value_of_hist (fst (Znth x (sublist 0 (Z.min i l) h) ([], []))) <> vint 0) as Hnz.

        { apply Forall_Znth; auto. }

        rewrite Zlength_sublist, Z.sub_0_r in Hin by (auto; omega).

        assert (x < i).

        { destruct Hin; eapply Z.lt_le_trans; eauto.

          apply Z.le_min_l. }

        exploit (Forall2_Znth _ _ _ ([], []) ([], []) Hfail x); auto.

        { rewrite Zlength_sublist; omega. }

        intros (? & r1 & ? & Heq1 & ? & ? & Heq2 & Hv).

        rewrite !Znth_sublist, Z.add_0_r in Heq1, Heq2, Hv, Hnz; auto; try omega.

        rewrite !Znth_sublist, Z.add_0_r in Heq1, Heq2 by omega.

        rewrite !Znth_sublist, Z.add_0_r by omega.

        rewrite Heq1, Heq2; simpl; split; auto.

        unfold value_of_hist in *; rewrite last_snoc; simpl.

        destruct (eq_dec (Vint r1) (vint 0)); [absurd (r1 = Int.zero); auto; inv e; auto | auto]. }

      destruct (Z.min_spec i l) as [(? & Hmin) | (? & Hmin)]; rewrite Hmin in *.

      * erewrite sublist_next with (i0 := i) by omega.

        rewrite Hhi; simpl.

        rewrite Hr0; simpl.

        rewrite Int.signed_repr by auto; simpl.

        destruct (eq_dec k 0); [contradiction Hk; auto | simpl].

        rewrite eq_dec_refl; simpl.

        rewrite Z.add_0_r, upd_Znth_app2; rewrite make_map_length; auto.

        rewrite Zminus_diag, upd_Znth0, sublist_1_cons, Zlength_cons.

        unfold Z.succ; rewrite Z.add_simpl_r, sublist_same with (hi := Zlength _) by auto.

        rewrite Hrest; apply incl_app; [apply incl_appl; auto | apply incl_appr, incl_refl].

        { pose proof (Zlength_nonneg

            ((k, make_int (value_of_hist hv)) :: make_map (sublist (i + 1) (Zlength h) h))); omega. }

        { eapply Forall_Znth with (i0 := i) in Hl1; [|rewrite Zlength_sublist; omega].

          rewrite Znth_sublist, Z.add_0_r, Hhi in Hl1 by omega; auto. }

      * rewrite make_map_nil with (h := sublist l _ _), app_nil_r; auto; simpl.

        apply incl_app; [apply incl_appl | apply incl_appr; constructor; simpl in *; tauto].

        rewrite sublist_split with (mid := l)(hi := i) by omega.

        rewrite make_map_app.

        apply incl_appl; auto.

        { replace l with (Z.min l (Z.max (i + 1) l)).

          rewrite <- sublist_prefix; apply Forall_sublist; auto.

          { apply Z.min_l, Zmax_bound_r, Z.le_refl. } }

        { eapply Forall_sublist, Forall_impl, Hwf'; tauto. }

      * apply make_map_no_key.

        rewrite Forall_forall; intros ? Hin.

        rewrite Forall_forall in Hl1; specialize (Hl1 x).

        exploit (Forall2_In_l _ x _ _ Hfail).

        { rewrite Z.min_comm, <- sublist_prefix in Hin; eapply sublist_In; eauto. }

        intros (? & ? & ? & r1 & ? & ? & ? & ? & ? & Heq); simpl in *; subst.

        rewrite Heq; simpl.

        intro; absurd (r1 = Int.repr k); auto.

        apply signed_inj; auto.

        rewrite Int.signed_repr; auto.

        { apply Hl1.

          rewrite <- sublist_prefix in Hin; eapply sublist_In; eauto. }

  - rewrite index_of_iff_out in Hindex.

    destruct Hi2 as [(? & ? & Hi2) | (? & ? & ? & Hi2)]; subst r.

    clear Hh'.

    assert (value_of_hist hk = vint 0) as Hz.

    { destruct (eq_dec (value_of_hist hk) (vint 0)); auto. }

    destruct (zlt i l).

    { eapply Forall_Znth with (i0 := i) in Hl1; [|rewrite Zlength_sublist; omega].

      rewrite Znth_sublist, Z.add_0_r, Hhi in Hl1 by omega; contradiction Hl1. }

    split; [omega|].

    assert (0 <= i <= Zlength h' /\

      Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 i h') /\

      Forall (fun x => value_of_hist (fst x) = vint 0) (sublist i (Zlength h') h'))

      as (? & Hl1' & Hl2'); [|split; split; auto].

    + split; [omega|]; split.

      * rewrite Forall_forall; intros.

        exploit (Forall2_In_r (failed_load k)); eauto.

        intros ((?, ?) & ? & ? & r1 & ? & -> & ? & ? & ? & ?); simpl in *; subst.

        unfold value_of_hist; rewrite last_snoc; simpl.

        intro X; absurd (r1 = Int.zero); auto; inv X; auto.

      * erewrite sublist_next by omega; constructor;

          [rewrite Hi1; unfold value_of_hist; rewrite last_snoc; auto|].

        rewrite <- Hrest.

        replace (i + 1) with (i + 1 - l + l) by (apply Z.sub_simpl_r).

        rewrite <- sublist_suffix by omega; apply Forall_sublist; auto.

    + replace h with (sublist 0 l h ++ sublist l (Zlength h) h)

        by (rewrite sublist_rejoin, sublist_same; auto; omega).

      replace h' with (sublist 0 l h' ++ sublist l (Zlength h') h')

        by (rewrite sublist_rejoin, sublist_same; auto; omega).

      rewrite make_map_drop, make_map_app; auto.

      apply incl_appl; erewrite make_map_eq; [apply incl_refl|].

      rewrite Forall2_eq_upto with (d1 := ([] : hist, [] : hist))(d2 := ([] : hist, [] : hist)).

      split; [rewrite !Zlength_sublist; auto; omega|].

      rewrite Forall_forall; intros ? Hin.

      rewrite In_upto, Z2Nat.id in Hin by (apply Zlength_nonneg).

      assert (value_of_hist (fst (Znth x (sublist 0 l h) ([], []))) <> vint 0) as Hnz.

      { apply Forall_Znth; auto. }

      rewrite Zlength_sublist, Z.sub_0_r in Hin by (auto; omega).

      assert (x < i) by omega.

      exploit (Forall2_Znth _ _ _ ([], []) ([], []) Hfail x); auto.

      { rewrite Zlength_sublist; omega. }

      intros (? & r1 & ? & Heq1 & ? & ? & Heq2 & Hv).

      rewrite !Znth_sublist, Z.add_0_r in Heq1, Heq2, Hv, Hnz; auto; try omega.

      rewrite !Znth_sublist, Z.add_0_r in Heq1, Heq2 by omega.

      rewrite !Znth_sublist, Z.add_0_r by omega.

      rewrite Heq1, Heq2; simpl; split; auto.

      unfold value_of_hist at 2; rewrite last_snoc; auto.

      { replace l with (Z.min l i) by (apply Z.min_l; omega).

        rewrite <- sublist_prefix; apply Forall_sublist; auto. }

      { eapply Forall_sublist, Forall_impl, Hwf'; tauto. }

    + contradiction Hindex.

      assert (Forall (fun x => value_of_hist (fst x) <> vint 0) (sublist 0 i h' ++ [Znth i h' ([], [])])).

      { rewrite Forall_app; split; auto; repeat constructor.

        rewrite Hi1; unfold value_of_hist; rewrite last_snoc; auto. }

      assert (Forall (fun x => Forall int_op (map snd (fst x))) (sublist 0 (i + 1) h')) as Hints.

      { eapply Forall_sublist, Forall_impl, Hwf'; tauto. }

      rewrite in_map_iff; exists (Znth i (make_map h') (0, 0)); split.

      * rewrite Znth_make_map; auto; simpl.

        rewrite Hi1; unfold value_of_hist; rewrite last_snoc; simpl.

        rewrite Int.signed_repr; auto.

        { omega. }

        { erewrite sublist_split with (mid := i), sublist_len_1 by omega; eauto. }

      * apply Znth_In.

        rewrite Hh'.

        change (Znth i h' ([], []) :: _) with ([Znth i h' ([], [])] ++ sublist (i + 1) (Zlength h') h').

        erewrite sublist_split with (mid := i), sublist_len_1 in Hints by omega.

        rewrite app_assoc, make_map_app, Zlength_app, make_map_length, Zlength_app, Zlength_sublist,

          Zlength_cons, Zlength_nil by (eauto; omega).

        pose proof (Zlength_nonneg (make_map (sublist (i + 1) (Zlength h') h'))); omega.

Qed.



Definition get_item_spec :=

 DECLARE _get_item

  WITH key : Z, p : val, sh : share, entries : list val, h : list (hist * hist), l : Z

  PRE [ _key OF tint, _value OF tint ]

   PROP (repable_signed key; readable_share sh; key <> 0; Forall isptr entries; Zlength h = 20; wf_hists h l)

   LOCAL (temp _key (vint key); gvar _m_entries p)

   SEP (data_at sh (tarray (tptr tentry) 20) entries p;

        fold_right_sepcon (map (atomic_entry sh) entries);

        entry_hists entries h)

  POST [ tint ]

   EX value : Z, EX i : Z, EX h' : list (hist * hist),

   PROP (repable_signed value; get_item_trace h key value i h')

   LOCAL (temp ret_temp (vint value))

   SEP (data_at sh (tarray (tptr tentry) 20) entries p;

        fold_right_sepcon (map (atomic_entry sh) entries);

        entry_hists entries h').



Definition Gprog : funspecs := ltac:(with_library prog [surely_malloc_spec; atomic_CAS_spec; atomic_load_spec;

  atomic_store_spec; set_item_spec; get_item_spec]).



Lemma body_surely_malloc: semax_body Vprog Gprog f_surely_malloc surely_malloc_spec.

Proof.

  start_function.

  forward_call n.

  Intros p.

  forward_if

  (PROP ( )

   LOCAL (temp _p p)

   SEP (malloc_token Tsh n p * memory_block Tsh n p)).

  - if_tac; entailer!.

  - forward_call tt.

    contradiction.

  - if_tac.

    + forward. subst p. discriminate.

    + Intros. forward. entailer!.

  - forward. Exists p; entailer!.

Qed.



Opaque upto.



Ltac cancel_for_forward_call ::= repeat (rewrite ?sepcon_andp_prop', ?sepcon_andp_prop);

  repeat (apply andp_right; [auto; apply prop_right; auto|]); fast_cancel.



Ltac entailer_for_return ::= go_lower; entailer'.



Lemma apply_int_ops : forall v h i (Hv : verif_atomics.apply_hist (Vint i) h = Some v)

  (Hints : Forall int_op h), tc_val tint v.

Proof.

  induction h; simpl; intros.

  - inv Hv; eauto.

  - inversion Hints as [|?? Ha]; subst.

    destruct a.

    + destruct (eq_dec v0 (Vint i)); [eapply IHh; eauto | discriminate].

    + destruct v0; try contradiction; eapply IHh; eauto.

    + destruct (eq_dec r (Vint i)); [|discriminate].

      destruct Ha as (? & ? & ?).

      destruct w; try contradiction.

      destruct (eq_dec c (Vint i)); eapply IHh; eauto.

Qed.



Lemma failed_CAS_fst : forall v h h', Forall2 (failed_CAS v) h h' -> map snd h' = map snd h.

Proof.

  induction 1; auto.

  destruct H as (? & ? & ? & ? & ? & ? & ? & ?); simpl; f_equal; auto.

Qed.



Lemma body_set_item : semax_body Vprog Gprog f_set_item set_item_spec.

Proof.

  start_function.

  forward.

  eapply semax_pre with (P' := EX i : Z, EX h' : list (hist * hist),

    PROP (0 <= i < 20; Forall2 (failed_CAS key) (sublist 0 i h) (sublist 0 i h');

          sublist i (Zlength h) h = sublist i (Zlength h') h')

    LOCAL (temp _idx (vint i); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

    SEP (data_at sh (tarray (tptr tentry) 20) entries p; fold_right_sepcon (map (atomic_entry sh) entries);

         entry_hists entries h')).

  { Exists 0 h; rewrite sublist_nil; entailer!. }

  eapply semax_loop.

  - Intros i h'; forward.

    assert (Zlength h' = Zlength h) as Hlen.

    { assert (Zlength (sublist i (Zlength h) h) = Zlength (sublist i (Zlength h') h')) as Heq

        by (replace (sublist i (Zlength h) h) with (sublist i (Zlength h') h'); auto).

      rewrite !Zlength_sublist in Heq; try omega.

      destruct (Z_le_dec i (Zlength h')); [omega|].

      unfold sublist in Heq.

      rewrite Z2Nat_neg in Heq by omega.

      simpl in Heq; rewrite Zlength_nil in Heq; omega. }

    assert (i <= Zlength h') by omega.

    assert (map snd h' = map snd h) as Hsnd.

    { erewrite <- sublist_same with (al := h') by eauto.

      erewrite <- sublist_same with (al := h) by eauto.

      rewrite sublist_split with (al := h')(mid := i) by omega.

      rewrite sublist_split with (al := h)(mid := i) by omega.

      rewrite Hlen in *; rewrite !map_app; f_equal; [|congruence].

      eapply failed_CAS_fst; eauto. }

    assert_PROP (Zlength entries = 20) by entailer!.

    assert (0 <= i < Zlength entries) by (replace (Zlength entries) with 20; auto).

    forward.

    { entailer!.

      apply isptr_is_pointer_or_null, Forall_Znth; auto. }

    rewrite extract_nth_sepcon with (i := i), Znth_map with (d' := Vundef); try rewrite Zlength_map; auto.

    unfold entry_hists; erewrite extract_nth_sepcon with (i := i)(l := map _ _), Znth_map, Znth_upto; simpl;

      auto; try omega.

    unfold atomic_entry; Intros lkey lval.

    rewrite atomic_loc_isptr.

    forward.

    forward.

    destruct (Znth i h' ([], [])) as (hki, hvi) eqn: Hhi.

    forward_call (Tsh, sh, field_address tentry [StructField _key] (Znth i entries Vundef), lkey, vint 0,

      vint key, vint 0, hki,

      fun (h : hist) c v => !!(c = vint 0 /\ v = vint key /\ h = hki) && emp,

      k_R,

      fun (h : hist) (v : val) => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> v = v0) && emp).



    { entailer!.

      rewrite field_address_offset; simpl.

      rewrite isptr_offset_val_zero; auto.

      { rewrite field_compatible_cons; simpl.

        split; [unfold in_members; simpl|]; auto. } }

    { repeat (split; auto).

      intros ?????????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

        apply apply_int_ops in Hvx; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; [| |contradiction].

        * intros.

          replace vx with (value_of e) by (symmetry; auto).

          if_tac; auto; absurd (value_of e = vint 0); auto.

        * subst; simpl; intros.

          if_tac; if_tac; auto; absurd (vx = vint 0); auto.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        specialize (Hhist _ _ Hin); apply nth_error_In in Hhist; subst; auto.

      + apply andp_right; auto.

        eapply derives_trans, precise_weak_precise, precise_andp2; auto. }

    Intros x; destruct x as (t, v); simpl in *.

    destruct v; try contradiction.

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP () (LOCALx (temp _t'2 (vint (if eq_dec i0 Int.zero then 1

        else if eq_dec i0 (Int.repr key) then 1 else 0)) :: Q) (SEPx R))) end.

    { forward.

      subst; rewrite eq_dec_refl; apply ENTAIL_refl. }

    { forward.

      destruct (eq_dec i0 Int.zero); [absurd (i0 = Int.repr 0); auto|].

      simpl force_val.

      destruct (eq_dec i0 (Int.repr key)).

      + subst; rewrite Int.eq_true; apply ENTAIL_refl.

      + rewrite Int.eq_false; [apply ENTAIL_refl | auto]. }

    assert (Znth i h ([], []) = Znth i h' ([], []) /\

      sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h') as (Heq & Hi1).

    { match goal with H : sublist _ _ h = sublist _ _ h' |- _ =>

        erewrite sublist_next with (d := ([] : hist, [] : hist)),

                 sublist_next with (l0 := h')(d := ([] : hist, [] : hist)) in H by omega; inv H; auto end. }

    assert (ordered_hist hki).

    { match goal with H : wf_hists h l |- _ => destruct H as (Hwf & _) end.

      eapply Forall_Znth with (i1 := i) in Hwf; [|omega].

      rewrite Heq, Hhi in Hwf; tauto. }

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (i0 <> Int.zero /\ i0 <> Int.repr key) (LOCALx Q (SEPx R))) end.

    + rewrite (atomic_loc_isptr _ lval).

      forward.

      forward.

      forward_call (Tsh, sh, field_address tentry [StructField _value] (Znth i entries Vundef), lval,

        vint value, vint 0, hvi, fun (h : hist) v => !!(v = vint value) && emp,

        v_R, fun (h : hist) => emp).

      { entailer!.

        rewrite field_address_offset; auto.

        { rewrite field_compatible_cons; simpl.

          split; [unfold in_members; simpl|]; auto. } }

      { repeat (split; auto).

        intros ????????????? Ha.

        unfold v_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!.

        apply andp_right; auto.

        eapply derives_trans, precise_weak_precise; auto. }

      Intros t'.

      forward.

      Exists i (upd_Znth i h' (fst (Znth i h' ([], [])) ++ [(t, CAS (Vint i0) (vint 0) (vint key))],

        snd (Znth i h' ([], [])) ++ [(t', Store (vint value))])).

      apply andp_right; auto.

      apply andp_right.

      { apply prop_right; split; auto.

        split; [omega|].

        rewrite Heq, Hhi; simpl.

        split; [rewrite sublist_upd_Znth_l; auto; omega|].

        split.

        - rewrite upd_Znth_same by omega.

          repeat eexists; eauto.

          + destruct (eq_dec i0 Int.zero); subst; auto.

            destruct (eq_dec i0 (Int.repr key)); subst; auto.

            absurd (Int.zero = Int.zero); auto.

          + match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> Vint i0 = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

        - rewrite upd_Znth_Zlength by omega.

          rewrite sublist_upd_Znth_r; auto; omega. }

      apply andp_right; auto.

      fast_cancel.

      rewrite (sepcon_comm (ghost_hist _ _)).

      rewrite (sepcon_comm (ghost_hist _ _)).

      rewrite !sepcon_assoc, <- 4sepcon_assoc; apply sepcon_derives.

      * rewrite replace_nth_sepcon; apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i1 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        rewrite Znth_map with (d' := Vundef) by auto.

        unfold atomic_entry.

        Exists lkey lval; entailer!.

        { rewrite upd_Znth_diff; rewrite ?Zlength_map; auto. }

      * rewrite sepcon_comm, replace_nth_sepcon.

        assert (0 <= i < Zlength h') by omega.

        apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i1 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        erewrite Znth_map, Znth_upto; simpl; auto; try omega.

        rewrite upd_Znth_same, Hhi; auto; simpl.

        { rewrite upd_Znth_diff; auto.

          rewrite Zlength_upto in *.

          erewrite !Znth_map, !Znth_upto; auto; try omega.

          rewrite upd_Znth_diff; auto.

          match goal with H : Zlength h' = _ |- _ => setoid_rewrite H; simpl in *; omega end. }

    + forward.

      destruct (eq_dec i0 Int.zero); [discriminate|].

      destruct (eq_dec i0 (Int.repr key)); [discriminate|].

      entailer!.

    + intros.

      unfold exit_tycon, overridePost.

      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

      Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert.

      instantiate (1 := EX i : Z, EX h' : list (hist * hist),

        PROP (0 <= i < 20; Forall2 (failed_CAS key) (sublist 0 (i + 1) h) (sublist 0 (i + 1) h');

              sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h')

        LOCAL (temp _idx (vint i); temp _key (vint key); temp _value (vint value); gvar _m_entries p)

        SEP (data_at sh (tarray (tptr tentry) 20) entries p; fold_right_sepcon (map (atomic_entry sh) entries);

             entry_hists entries h')).

      Exists i (upd_Znth i h' (fst (Znth i h' ([], [])) ++ [(t, CAS (Vint i0) (vint 0) (vint key))],

        snd (Znth i h' ([], [])))).

      go_lower.

      apply andp_right.

      { assert (0 <= i < Zlength h') by (rewrite Hlen; omega).

        apply prop_right; repeat (split; auto).

        * erewrite sublist_split, sublist_len_1 with (i1 := i); try omega.

          erewrite sublist_split with (hi := i + 1), sublist_len_1 with (i1 := i)(d := ([] : hist, [] : hist));

            rewrite ?upd_Znth_Zlength; try omega.

          rewrite sublist_upd_Znth_l by omega.

          rewrite upd_Znth_same by omega.

          apply Forall2_app; auto.

          constructor; auto.

          unfold failed_CAS; simpl.

          rewrite Heq, Hhi; repeat eexists; eauto.

          match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> Vint i0 = v0 |- _ =>

            symmetry; apply H; auto end.

          rewrite ordered_last_value; auto.

        * rewrite upd_Znth_Zlength by omega.

          rewrite sublist_upd_Znth_r by omega; auto. }

      apply andp_right; [apply prop_right; auto|].

      fast_cancel.

      rewrite (sepcon_comm (ghost_hist _ _)).

      rewrite !sepcon_assoc, <- 4sepcon_assoc; apply sepcon_derives.

      * rewrite replace_nth_sepcon; apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i1 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        rewrite Znth_map with (d' := Vundef) by auto.

        unfold atomic_entry.

        Exists lkey lval; entailer!.

        { rewrite upd_Znth_diff; rewrite ?Zlength_map; auto. }

      * rewrite (sepcon_comm _ (ghost_hist _ _)), <- sepcon_assoc, replace_nth_sepcon.

        assert (0 <= i < Zlength h') by omega.

        apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i1 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        erewrite Znth_map, Znth_upto; simpl; auto; try omega.

        rewrite upd_Znth_same; auto; simpl.

        setoid_rewrite Hhi.

        rewrite sepcon_comm; auto.

        { rewrite upd_Znth_diff; auto.

          rewrite Zlength_upto in *.

          erewrite !Znth_map, !Znth_upto; auto; try omega.

          rewrite upd_Znth_diff; auto.

          setoid_rewrite Hlen; simpl in *; omega. }

  - Intros i h'.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) h'; entailer!.

    admit. 

Admitted.



Lemma failed_load_fst : forall v h h', Forall2 (failed_load v) h h' -> map snd h' = map snd h.

Proof.

  induction 1; auto.

  destruct H as (? & ? & ? & ? & ? & ? & ? & ?); simpl; f_equal; auto.

Qed.



Lemma body_get_item : semax_body Vprog Gprog f_get_item get_item_spec.

Proof.

  start_function.

  forward.

  eapply semax_pre with (P' := EX i : Z, EX h' : list (hist * hist),

    PROP (0 <= i < 20; Forall2 (failed_load key) (sublist 0 i h) (sublist 0 i h');

          sublist i (Zlength h) h = sublist i (Zlength h') h')

    LOCAL (temp _idx (vint i); temp _key (vint key); gvar _m_entries p)

    SEP (data_at sh (tarray (tptr tentry) 20) entries p; fold_right_sepcon (map (atomic_entry sh) entries);

         entry_hists entries h')).

  { Exists 0 h; rewrite sublist_nil; entailer!. }

  eapply semax_loop.

  - Intros i h'; forward.

    assert_PROP (Zlength entries = 20) by entailer!.

    assert (0 <= i < Zlength entries) by (replace (Zlength entries) with 20; auto).

    forward.

    { entailer!.

      apply isptr_is_pointer_or_null, Forall_Znth; auto. }

    rewrite extract_nth_sepcon with (i := i), Znth_map with (d' := Vundef); try rewrite Zlength_map; auto.

    unfold entry_hists; erewrite extract_nth_sepcon with (i := i)(l := map _ _), Znth_map, Znth_upto; simpl; auto;

      try omega.

    unfold atomic_entry; Intros lkey lval.

    rewrite atomic_loc_isptr.

    forward.

    forward.

    assert (Zlength h' = Zlength h) as Hlen.

    { assert (Zlength (sublist i (Zlength h) h) = Zlength (sublist i (Zlength h') h')) as Heq

        by (replace (sublist i (Zlength h) h) with (sublist i (Zlength h') h'); auto).

      rewrite !Zlength_sublist in Heq; try omega.

      destruct (Z_le_dec i (Zlength h')); [omega|].

      unfold sublist in Heq.

      rewrite Z2Nat_neg in Heq by omega.

      simpl in Heq; rewrite Zlength_nil in Heq; omega. }

    assert (i < Zlength h') by omega.

    assert (map snd h' = map snd h) as Hsnd.

    { erewrite <- sublist_same with (al := h') by eauto.

      erewrite <- sublist_same with (al := h) by eauto.

      rewrite sublist_split with (al := h')(mid := i) by omega.

      rewrite sublist_split with (al := h)(mid := i) by omega.

      rewrite Hlen in *; rewrite !map_app; f_equal; [|congruence].

      eapply failed_load_fst; eauto. }

    destruct (Znth i h' ([], [])) as (hki, hvi) eqn: Hhi.

    forward_call (Tsh, sh, field_address tentry [StructField _key] (Znth i entries Vundef), lkey, vint 0,

      hki, fun h => !!(h = hki) && emp, k_R,

      fun (h : hist) (v : val) => !!(forall v0, last_value hki v0 -> v0 <> vint 0 -> v = v0) && emp).

    { entailer!.

      rewrite field_address_offset; simpl.

      rewrite isptr_offset_val_zero; auto.

      { rewrite field_compatible_cons; simpl.

        split; [unfold in_members; simpl|]; auto. } }

    { repeat (split; auto).

      intros ???????????? Ha.

      unfold k_R in *; simpl in *.

      eapply semax_pre, Ha.

      go_lowerx; entailer!.

      repeat split.

      + rewrite Forall_app; repeat constructor; auto.

        apply apply_int_ops in Hvx; auto.

      + intros ? Hin; rewrite in_app in Hin.

        destruct Hin as [? | [? | ?]]; subst; auto; contradiction.

      + intros ? [(? & ?) | (? & ? & Hin & ? & ?)] Hn; [contradiction Hn; auto|].

        specialize (Hhist _ _ Hin); apply nth_error_In in Hhist; subst; auto.

      + apply andp_right; auto.

        eapply derives_trans, precise_weak_precise, precise_andp2; auto. }

    Intros x; destruct x as (t, v); simpl in *.

    destruct v; try contradiction.

    assert (Zlength h' = Zlength h).

    { assert (Zlength (sublist i (Zlength h) h) = Zlength (sublist i (Zlength h') h')) as Heq

        by (replace (sublist i (Zlength h) h) with (sublist i (Zlength h') h'); auto).

      rewrite !Zlength_sublist in Heq; omega. }

    assert (Znth i h ([], []) = Znth i h' ([], []) /\

      sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h') as (Heq & Hi1).

    { match goal with H : sublist _ _ h = sublist _ _ h' |- _ =>

        erewrite sublist_next with (d := ([] : hist, [] : hist)),

                 sublist_next with (l0 := h')(d := ([] : hist, [] : hist)) in H by omega; inv H; auto end. }

    assert (ordered_hist hki).

    { match goal with H : wf_hists h l |- _ => destruct H as (Hwf & _) end.

      eapply Forall_Znth with (i1 := i) in Hwf; [|omega].

      rewrite Heq, Hhi in Hwf; tauto. }

    match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

      forward_if (PROP (i0 <> Int.repr key) (LOCALx Q (SEPx R))) end.

    + rewrite (atomic_loc_isptr _ lval).

      forward.

      forward.

      forward_call (Tsh, sh, field_address tentry [StructField _value] (Znth i entries Vundef), lval, vint 0,

        snd (Znth i h' ([], [])), fun (h : hist) => emp, v_R, fun (h : hist) (v : val) => emp).

      { entailer!.

        rewrite field_address_offset; auto.

        { rewrite field_compatible_cons; simpl.

          split; [unfold in_members; simpl|]; auto. } }

      { rewrite Hhi; fast_cancel. }

      { repeat (split; auto).

        intros ???????????? Ha.

        unfold v_R in *; simpl in *.

        eapply semax_pre, Ha.

        go_lowerx; entailer!.

        apply andp_right; auto.

        eapply derives_trans, precise_weak_precise; auto. }

      Intros x; destruct x as (t', v); simpl in *.

      forward.

      Exists (Int.signed v) i (upd_Znth i h' (fst (Znth i h' ([], [])) ++ [(t, Load (vint key))],

        snd (Znth i h' ([], [])) ++ [(t', Load (Vint v))])).

      apply andp_right.

      { apply prop_right.

        split; [apply Int.signed_range|].

        split; auto.

        split; [omega|].

        split; [|split].

        - rewrite sublist_upd_Znth_l; auto; omega.

        - rewrite upd_Znth_same by omega.

          rewrite Heq, Hhi in *; simpl in *.

          rewrite Int.repr_signed.

          do 3 eexists; eauto.

          split; eauto.

          split; eauto.

          match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint key = v0 |- _ =>

            symmetry; apply H; auto end.

          rewrite ordered_last_value; auto.

        - rewrite upd_Znth_Zlength by omega.

          rewrite sublist_upd_Znth_r by omega; auto. }

      apply andp_right; [apply prop_right; rewrite Int.repr_signed; auto|].

      fast_cancel.

      rewrite (sepcon_comm (ghost_hist _ _)).

      rewrite (sepcon_comm (ghost_hist _ _)).

      rewrite !sepcon_assoc, <- 4sepcon_assoc; apply sepcon_derives.

      * rewrite replace_nth_sepcon; apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i0 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        rewrite Znth_map with (d' := Vundef) by auto.

        unfold atomic_entry.

        Exists lkey lval; entailer!.

        { rewrite upd_Znth_diff; rewrite ?Zlength_map; auto. }

      * rewrite sepcon_comm, replace_nth_sepcon.

        assert (0 <= i < Zlength h') by omega.

        rewrite Hhi; apply sepcon_list_derives.

        { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

        rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

        destruct (eq_dec i0 i).

        subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

        erewrite Znth_map, Znth_upto; simpl; auto; try omega.

        rewrite upd_Znth_same; auto; simpl.

        { rewrite upd_Znth_diff; auto.

          rewrite Zlength_upto in *.

          erewrite !Znth_map, !Znth_upto; auto; try omega.

          rewrite upd_Znth_diff; auto.

          simpl in *; omega. }

    + forward.

      entailer!.

    + Intros; match goal with |- semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>

        forward_if (PROP (i0 <> Int.zero) (LOCALx Q (SEPx R))) end.

      * forward.

        Exists 0 i (upd_Znth i h' (fst (Znth i h' ([], [])) ++ [(t, Load (vint 0))], snd (Znth i h' ([], [])))).

        apply andp_right.

        { apply prop_right.

          split; [split; computable|].

          split; auto.

          split; [omega|].

          split; [|split].

          * rewrite sublist_upd_Znth_l; auto; omega.

          * rewrite upd_Znth_same by omega.

            rewrite Heq, Hhi in *; simpl in *.

            do 3 eexists; eauto.

            split; eauto.

            split; eauto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> vint 0 = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          * rewrite upd_Znth_Zlength by omega.

            rewrite sublist_upd_Znth_r; auto; omega. }

        apply andp_right; [apply prop_right; auto|].

        fast_cancel.

        rewrite (sepcon_comm (ghost_hist _ _)).

        rewrite (sepcon_comm (ghost_hist _ _)).

        rewrite !sepcon_assoc, <- 4sepcon_assoc; apply sepcon_derives.

        -- rewrite replace_nth_sepcon; apply sepcon_list_derives.

           { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

           rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

           destruct (eq_dec i0 i).

           subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

           rewrite Znth_map with (d' := Vundef) by auto.

           unfold atomic_entry.

           Exists lkey lval; entailer!.

           { rewrite upd_Znth_diff; rewrite ?Zlength_map; auto. }

        -- rewrite sepcon_comm, replace_nth_sepcon.

           assert (0 <= i < Zlength h') by omega.

           rewrite Hhi; apply sepcon_list_derives.

           { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

           rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

           destruct (eq_dec i0 i).

           subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

           erewrite Znth_map, Znth_upto; simpl; auto; try omega.

           rewrite upd_Znth_same; auto; simpl.

           rewrite sepcon_comm; auto.

           { rewrite upd_Znth_diff; auto.

             rewrite Zlength_upto in *.

             erewrite !Znth_map, !Znth_upto; auto; try omega.

             rewrite upd_Znth_diff; auto.

             simpl in *; omega. }

      * forward.

        entailer!.

      * intros.

        unfold exit_tycon, overridePost.

        destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].

        Intros; unfold POSTCONDITION, abbreviate, normal_ret_assert, loop1_ret_assert.

        instantiate (1 := EX i : Z, EX h' : list (hist * hist),

          PROP (0 <= i < 20; Forall2 (failed_load key) (sublist 0 (i + 1) h) (sublist 0 (i + 1) h');

                sublist (i + 1) (Zlength h) h = sublist (i + 1) (Zlength h') h')

          LOCAL (temp _idx (vint i); temp _key (vint key); gvar _m_entries p)

          SEP (data_at sh (tarray (tptr tentry) 20) entries p; fold_right_sepcon (map (atomic_entry sh) entries);

               entry_hists entries h')).

        Exists i (upd_Znth i h' (fst (Znth i h' ([], [])) ++ [(t, Load (Vint i0))], snd (Znth i h' ([], [])))).

        go_lower.

        apply andp_right.

        { apply prop_right; repeat (split; auto).

          * erewrite sublist_split, sublist_len_1 with (i1 := i); try omega.

            erewrite sublist_split with (hi := i + 1), sublist_len_1 with (i1 := i)(d := ([] : hist, [] : hist));

              rewrite ?upd_Znth_Zlength; try omega.

            rewrite sublist_upd_Znth_l by omega.

            rewrite upd_Znth_same by omega.

            apply Forall2_app; auto.

            constructor; auto.

            unfold failed_load; simpl.

            rewrite Heq, Hhi; repeat eexists; eauto.

            match goal with H : forall v0, last_value hki v0 -> v0 <> vint 0 -> Vint i0 = v0 |- _ =>

              symmetry; apply H; auto end.

            rewrite ordered_last_value; auto.

          * rewrite upd_Znth_Zlength by omega.

            rewrite sublist_upd_Znth_r by omega; auto. }

        apply andp_right; [apply prop_right; auto|].

        fast_cancel.

        rewrite (sepcon_comm (ghost_hist _ _)).

        rewrite !sepcon_assoc, <- 4sepcon_assoc; apply sepcon_derives.

        -- rewrite replace_nth_sepcon; apply sepcon_list_derives.

           { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

          rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

          destruct (eq_dec i1 i).

          subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

           rewrite Znth_map with (d' := Vundef) by auto.

          unfold atomic_entry.

          Exists lkey lval; entailer!.

          { rewrite upd_Znth_diff; rewrite ?Zlength_map; auto. }

        -- rewrite (sepcon_comm _ (ghost_hist _ _)), <- sepcon_assoc, replace_nth_sepcon.

           assert (0 <= i < Zlength h') by omega.

           rewrite Hhi; apply sepcon_list_derives.

           { rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto. }

           rewrite upd_Znth_Zlength; rewrite !Zlength_map; auto; intros.

           destruct (eq_dec i1 i).

           subst; rewrite upd_Znth_same by (rewrite Zlength_map; auto).

           erewrite Znth_map, Znth_upto; simpl; auto; try omega.

           rewrite upd_Znth_same; auto; simpl.

           rewrite sepcon_comm; auto.

           { rewrite upd_Znth_diff; auto.

             rewrite Zlength_upto in *.

             erewrite !Znth_map, !Znth_upto; auto; try omega.

             rewrite upd_Znth_diff; auto.

             match goal with H : Zlength h' = _ |- _ => setoid_rewrite H; simpl in *; omega end. }

  - Intros i h'.

    forward.

    unfold loop2_ret_assert.

    Exists (i + 1) h'; entailer!.

    admit. 

Admitted.

