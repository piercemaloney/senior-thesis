Require Import VST.msl.msl_standard.
(* VST.msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import VST.msl.ghost.
(* VST.msl.ghost:
Require Import VST.msl.sepalg.

Class Ghost := { G : Type; valid : G -> Prop;
  Join_G :> Join G; Sep_G :> Sep_alg G; Perm_G :> Perm_alg G;
  join_valid : forall a b c, join a b c -> valid c -> valid a }.

Section Update.

Context {RA: Ghost}.

Lemma core_valid: forall a, valid a -> valid (core a).

Definition valid_2 a b := exists c, join a b c /\ valid c.

Definition fp_update_ND a B := forall c, valid_2 a c -> exists b, B b /\ valid_2 b c.

Definition fp_update a b := forall c, valid_2 a c -> valid_2 b c.

Lemma fp_update_equiv: forall a b, fp_update a b <-> fp_update_ND a (eq b).

End Update. *)

Require Import VST.msl.Coqlib2.
(* VST.msl.Coqlib2:
Require Import compcert.lib.Coqlib.
Require Import VST.msl.base.
Require Export VST.msl.Extensionality.

Hint Extern 1 (@eq _ _ _) => exact (proof_irr _ _) : extensionality.

Hint Extern 2 (eq _ _)  => apply exist_ext : extensionality.

Hint Extern 2 (@eq _ (@existT _ _ _ _) (@existT _ _ _ _))  => apply existT_ext : extensionality.

Tactic Notation "forget" constr(X) "as" ident(y) :=
   set (y:=X) in *; clearbody y.

Ltac proof_irr := match goal with H: ?A, H' : ?A |- _ => generalize (proof_irr H H'); intro; subst H' end.

Ltac inversion2 H1 H2 :=
 rewrite H1 in H2; symmetry in H2; inv H2.

Ltac invT H :=
match type of H  with
  | existT _ ?a ?b = existT _ ?a ?c =>
     generalize (inj_pair2 _ _ a b c H); clear H; intro H; invT H
  | existT _ _ _ = existT _ _ _ =>
       let HH := fresh in (injection H; intros _ HH; invT HH; invT H)
  | _ => inv H
 end.

Ltac invSome :=
 match goal with
 | H: match ?A with Some _ =>  _ | None => None end = Some _ |- _ =>
        let Hx := fresh in
               (revert H; case_eq A; [intros ? H Hx | intros H Hx]; inv Hx)
 | H: match ?A with Some _ => _  | None => False end |- _ =>
             (revert H; case_eq A; [intros ? H ? | intros; contradiction])

 | H: match ?A return _ with Some _ =>  _ | None => _ end eq_refl = Some _ |- _ =>
 let Hx := fresh in
           (revert H; generalize (eq_refl A); pattern A at 1 3; destruct A;
            [ intros Hx H | intros ? H; discriminate H])
 end.

Ltac split3 := split; [|split].

Lemma if_true: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), A -> (if E then B else C) = B.

Lemma if_false: forall (A: Prop) (E: {A}+{~A}) (T: Type) (B C: T), ~A -> (if E then B else C) = C.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Lemma f_equal_Some: forall A (x y: A), x=y -> Some x = Some y.

Lemma f_equal_prod: forall A B (x1 x2: A) (y1 y2: B), x1=x2 -> y1=y2 -> (x1,y1) = (x2,y2).

Hint Resolve f_equal_Some f_equal_prod.

Unset Implicit Arguments.

Lemma list_norepet_append_inv:
  forall (A : Set) (l1 l2 : list A),
   list_norepet (l1 ++ l2) ->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Set Implicit Arguments.

Ltac simple_if_tac := 
  match goal with |- context [if ?A then _ else _] => 
    lazymatch type of A with
    | bool => destruct A 
    | sumbool _ _ => fail "Use if_tac instead of simple_if_tac, since your expression "A" has type sumbool"
    | ?t => fail "Use simple_if_tac only for bool; your expression"A" has type" t
  end end.

Tactic Notation "if_tac" := 
  match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H)
   := match goal with |- context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" "in" hyp(H0)
 := match type of H0 with context [if ?a then _ else _] =>
    lazymatch type of a with
    | sumbool _ _ =>destruct a as [?H | ?H]
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Tactic Notation "if_tac" simple_intropattern(H) "in" hyp(H1)
 := match type of H1 with context [if ?a then _ else _] => 
    lazymatch type of a with
    | sumbool _ _ =>destruct a as H
    | bool => fail "Use simple_if_tac instead of if_tac, since your expression"a" has type bool"
    | ?t => fail "Use if_tac only for sumbool; your expression"a" has type" t
   end end.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma sumbool_dec_iff: forall A B, {A} + {~A} -> (A <-> B) -> {B} + {~B}.

Lemma sumbool_dec_and: forall A B, {A} + {~A} -> {B} + {~B} -> {A /\ B} + {~(A /\ B)}.

Lemma sumbool_dec_or: forall A B, {A} + {~A} -> {B} + {~B} -> {A \/ B} + {~(A \/ B)}.

Ltac super_pattern t x :=
  let t0 := fresh "t" in
  set (t0 := t);
  pattern x in t0;
  cbv beta in (type of t0);
  subst t0.

Ltac super_pattern_in_func t x :=
  let t0 := fresh "t" in
  let a := fresh "a" in
  match type of t with
  | ?type_of_t =>
    evar (t0 : type_of_t)
  end;
  assert (t = t0) as _;
  [
    extensionality a;
    cbv beta;
    match goal with
    | |- ?left = _ =>
      super_pattern left x
    end;
    match goal with
    | |- ?left _ = _ =>
      super_pattern left a
    end;
    match goal with
    | |- ?left _ _ = _ =>
      instantiate (1 := fun a => left a x) in (Value of t0)
    end;
    reflexivity
  |
    change t with t0;
    subst t0
  ].

Ltac build_func_abs_right :=
match goal with
| |- @eq ?typ_expr (_ ?arg) ?expr =>
     match type of arg with
     | ?typ_arg =>
       super_pattern expr arg;
       match goal with
       | |- @eq typ_expr _ (?func arg) =>
            exact (@eq_refl typ_expr
                    ((ltac:(clear arg; intros arg;
                            let res := eval cbv beta in (func arg) in
                            exact res): (typ_arg -> typ_expr))
                     arg)
                  )

       end
     end
end. *)

Require Import VST.veric.shares.
(* VST.veric.shares:
Require Import VST.msl.msl_standard.
Require Import VST.msl.Coqlib2.

Set Implicit Arguments.

Lemma share_lemma87:
  forall a b, Share.glb a b = Share.bot -> Share.glb (Share.comp a) b = b.

Lemma join_top_comp:
  forall a b, join a b Share.top -> Share.comp a = b.

Lemma comp_bot: Share.comp Share.bot = Share.top.

Lemma share_distrib1':
      forall w x y z : Share.t,

Lemma share_distrib2':
   forall w x y z : Share.t,

Lemma lub_bot_e:
  forall x y, Share.lub x y = Share.bot -> x = Share.bot /\ y = Share.bot.

Lemma glb_less_both:
  forall a L b R,
   Share.Ord a L -> Share.Ord b R ->

Lemma comp_Lsh_Rsh:
  Share.comp Share.Lsh = Share.Rsh.

Lemma share_lemma88:
   forall sh, Share.glb sh Share.Rsh = Share.bot ->

Definition Tsh : share := Share.top.

Definition nonempty_share (sh: share) :=
       sepalg.nonidentity sh.
Definition readable_share (sh: share) :=
       nonempty_share (Share.glb Share.Rsh sh).
Definition writable_share (sh: share) :=
    nonempty_share (Share.glb Share.Lsh sh) /\ join_sub Share.Rsh sh.

Lemma lub_Lsh_Rsh:
 Share.lub Share.Lsh Share.Rsh = Share.top.

Lemma glb_Lsh_Rsh:
 Share.glb Share.Lsh Share.Rsh = Share.bot.

Lemma readable_share_dec:
  forall sh, {readable_share sh}+{~ readable_share sh}.

Lemma writable_share_dec: forall sh, {writable_share sh} + {~ writable_share sh}.

Lemma writable_readable:
 forall sh, writable_share sh -> readable_share sh.

Lemma readable_share_top:
  readable_share Share.top.
Hint Resolve writable_readable.

Lemma top_pfullshare: forall psh, pshare_sh psh = Share.top -> psh = pfullshare.

Lemma fst_split_fullshare_not_bot: fst (Share.split fullshare) <> Share.bot.

Lemma fst_split_fullshare_not_top: fst (Share.split fullshare) <> Share.top.

Lemma glb_Rsh_not_top:
   forall sh, Share.glb Share.Rsh sh <> Share.top.
Arguments glb_Rsh_not_top sh _ : clear implicits.

Lemma writable_share_top: writable_share Tsh.
Hint Resolve writable_share_top.

Lemma writable_readable_share:
 forall sh, writable_share sh -> readable_share sh.
Hint Resolve writable_readable_share.

Definition extern_retainer := fst (Share.split Share.Lsh).

Definition Ews  := 
  Share.lub extern_retainer Share.Rsh.

Lemma writable_Ews: writable_share Ews.

Lemma writable_Rsh: writable_share Share.Rsh.
Proof.
  unfold writable_share.
Abort.  

Hint Resolve writable_Ews.

Definition Ers  := 
  Share.lub extern_retainer (fst (Share.split Share.Rsh)).

Lemma readable_nonidentity: forall sh, readable_share sh -> sepalg.nonidentity sh.

Hint Resolve readable_nonidentity.

Lemma sub_glb_bot:
  forall r a c : share,
   sepalg.join_sub a c ->

Lemma glb_split: forall sh,
 Share.glb (fst (Share.split sh)) (snd (Share.split sh)) = Share.bot.

Lemma Lsh_nonidentity:   sepalg.nonidentity Share.Lsh.

Lemma Rsh_nonidentity:   sepalg.nonidentity Share.Rsh.

Lemma nonidentity_extern_retainer: ~identity extern_retainer.

Lemma glb_split_x:
  forall a, Share.glb a (fst (Share.split a)) = fst (Share.split a).

Lemma readable_Ers: readable_share Ers.

Lemma join_sub_readable:
  forall sh sh', sepalg.join_sub sh sh' -> readable_share sh -> readable_share sh'.

Lemma join_unreadable_shares:
 forall sh1 sh2 sh,
  sepalg.join sh1 sh2 sh ->

Lemma readable_share_join_left:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma readable_share_join:
  forall sh1 sh2 sh,
    sepalg.join sh1 sh2 sh ->

Lemma Lsh_bot_neq: Share.Lsh <> Share.bot.

Lemma not_nonunit_bot: forall sh, ~ nonunit sh <-> sh = Share.bot.

Lemma join_readable1:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh1 -> readable_share sh3.

Lemma join_readable2:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    readable_share sh2 -> readable_share sh3.

Lemma bot_unreadable: ~readable_share Share.bot.

Definition pure_readable_share (sh: Share.t) :=
  Share.glb Share.Lsh sh = Share.bot /\ readable_share sh.

Definition rshare := sig pure_readable_share.

Definition readable_part: forall (sh: Share.t) (rsh: readable_share sh), rshare.

Lemma readable_not_identity: forall sh P,
  readable_share sh -> identity sh -> P.
Arguments readable_not_identity sh P _ _ : clear implicits.

Lemma comp_parts:  
  forall L R : Share.t,

Lemma join_comp_parts:  
  forall L R : Share.t,

Lemma join_pure_readable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    pure_readable_share sh1 -> 
    pure_readable_share sh2 -> 
    pure_readable_share sh3.

Lemma dec_readable sh : {readable_share sh}+{~readable_share sh}.

Lemma dec_pure_readable sh : {pure_readable_share sh}+{~pure_readable_share sh}.

Lemma dec_share_identity': forall sh: Share.t, Decidable.decidable (identity sh).

Lemma not_not_share_identity: forall sh: Share.t,

Lemma join_readable_part_eq:
  forall sh1 (rsh1: readable_share sh1)
         sh2 (nsh2: ~readable_share sh2)
         sh3 (rsh3: readable_share sh3),
        join sh1 sh2 sh3 -> 
        readable_part rsh1 = readable_part rsh3.

Lemma join_readable_part:
  forall sh1 (rsh1: readable_share sh1) sh2 (rsh2: readable_share sh2) sh3 (rsh3: readable_share sh3),
   join sh1 sh2 sh3 ->
  join (readable_part rsh1) (readable_part rsh2)(readable_part rsh3).

Lemma share_self_join_bot:
  forall sh: Share.t, join sh sh sh -> sh = Share.bot.

Definition retainer_part (sh: Share.t) := Share.glb Share.Lsh sh.

Lemma retainer_part_nonreadable:
  forall sh, ~readable_share (retainer_part sh).
Arguments retainer_part_nonreadable: clear implicits.

Lemma readable_share_lub:
 forall a b: Share.t, readable_share b -> readable_share (Share.lub a b).

Lemma retainer_part_join: forall sh1 sh2 sh3, 
  join sh1 sh2 sh3 -> join (retainer_part sh1) (retainer_part sh2) (retainer_part sh3).

Lemma not_readable_Rsh_part:
 forall sh, ~ readable_share sh -> Share.glb Share.Rsh sh = Share.bot.

Lemma join_parts1:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma join_parts:
  forall L R (HC: Share.comp L = R) sh1 sh2 sh,         

Lemma comp_Rsh_Lsh: Share.comp Share.Rsh = Share.Lsh.

Lemma glb_twice: forall a b, Share.glb a (Share.glb a b) = Share.glb a b.

Lemma glb_Lsh_Rsh':
  forall sh, Share.glb Share.Lsh (Share.glb Share.Rsh sh) = Share.bot.

Lemma comp_parts_join:
 forall L R (HC: Share.comp L = R) a b c,

Lemma left_right_join:
 forall a b c,
  join (Share.glb Share.Lsh a) (Share.glb Share.Lsh b) (Share.glb Share.Lsh c) ->

Lemma lub_bot': forall sh, Share.lub Share.bot sh = sh.

Lemma glb_Rsh_Lsh: Share.glb Share.Rsh Share.Lsh = Share.bot.

Lemma join_writable1: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable_share sh1 -> writable_share sh.

Lemma join_writable_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable_share sh1 -> readable_share sh2 -> False.

Definition writable0_share (sh: share) :=
    join_sub Share.Rsh sh.

Lemma writable_writable0: forall sh,
  writable_share sh -> writable0_share sh.
Hint Resolve writable_writable0.

Lemma writable0_readable: forall sh,
  writable0_share sh -> readable_share sh.
Hint Resolve writable0_readable.

Lemma writable0_Rsh: writable0_share Share.Rsh.

Lemma join_writable0_readable:
  forall {sh1 sh2 sh}, 
   join sh1 sh2 sh -> writable0_share sh1 -> readable_share sh2 -> False.

Lemma join_writable01: forall sh1 sh2 sh,
   join sh1 sh2 sh -> writable0_share sh1 -> writable0_share sh.

Lemma writable0_share_dec: forall sh, {writable0_share sh} + {~ writable0_share sh}.

Lemma writable0_share_glb_Rsh:
  forall sh, writable0_share sh -> writable0_share (Share.glb Share.Rsh sh).

Lemma glb_split_lemma1:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (fst (Share.split a)) =
     Share.glb Share.Rsh (fst (Share.split b)).
Proof.
intros.
Abort.  

Lemma glb_split_lemma2:
  forall a b, Share.glb Share.Rsh a = Share.glb Share.Rsh b ->
     Share.glb Share.Rsh (snd (Share.split a)) =
     Share.glb Share.Rsh (snd (Share.split b)).
Proof.
Abort.  

Lemma fst_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (fst (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Proof.
Abort. 

Lemma snd_split_glb_orthogonal: forall sh : share,
identity (Share.glb Share.Rsh (snd (Share.split sh))) ->
identity (Share.glb Share.Rsh sh).
Abort.  

  Lemma writable_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ readable_share sh2.

  Lemma writable_not_join_writable :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable_share sh1 ->
      ~ writable_share sh2.

  Lemma only_bot_joins_top:
    forall sh, joins Share.top sh -> sh = Share.bot.

  Lemma writable0_right:
    forall sh,  writable0_share (Share.glb Share.Rsh sh) ->

Lemma join_readable_unreadable:
  forall sh1 sh2 sh3,
    join sh1 sh2 sh3 ->
    ~ writable0_share sh1 ->
    ~ readable_share sh2 ->
    ~ writable0_share sh3.

Lemma readable_glb:
   forall sh,
     readable_share sh ->
     readable_share (Share.glb Share.Rsh sh).

 Lemma unreadable_glb:
   forall sh,
     ~readable_share sh ->
     ~readable_share (Share.glb Share.Rsh sh).

  Lemma nonreadable_emptyshare: ~ readable_share emptyshare.
  
Lemma join_comp_Tsh:
  forall sh, sepalg.join sh (Share.comp sh) Tsh. *)



Module Type ADR_VAL.

Parameter address : Type.

Parameter some_address:address.



Parameter kind: Type.

End ADR_VAL.



Inductive TypeTree: Type :=

  | ConstType: Type -> TypeTree

  | Mpred: TypeTree

  | DependentType: nat -> TypeTree

  | ProdType: TypeTree -> TypeTree -> TypeTree

  | ArrowType: TypeTree -> TypeTree -> TypeTree

  | PiType: forall (I : Type), (I -> TypeTree) -> TypeTree

  | ListType: TypeTree -> TypeTree.



Definition dependent_type_functor_rec (ts: list Type): TypeTree -> functor :=

  fix dtfr (T: TypeTree): functor :=

  match T with

  | ConstType A => fconst A

  | Mpred => fidentity

  | DependentType n => fconst (nth n ts unit)

  | ProdType T1 T2 => fpair (dtfr T1) (dtfr T2)

  | ArrowType T1 T2 => ffunc (dtfr T1) (dtfr T2)

  | PiType _ f => fpi (fun i => dtfr (f i))

  | ListType T => flist (dtfr T)

  end.

Opaque dependent_type_functor_rec.



Definition dependent_type_function_rec (ts: list Type) (mpred': Type): TypeTree -> Type :=

  fix dtfr (T: TypeTree): Type :=

  match T with

  | ConstType A => A

  | Mpred => mpred'

  | DependentType n => nth n ts unit

  | ProdType T1 T2 => (dtfr T1 * dtfr T2)%type

  | ArrowType T1 T2 => dtfr T1 -> dtfr T2

  | PiType A f => forall a, dtfr (f a)

  | ListType T => list (dtfr T)

  end.



Definition fpreds: functor :=

  fsig (fun T: TypeTree =>

    fpi (fun ts: list Type => dependent_type_functor_rec ts T)).



Lemma realize_eq: forall {A} (a b: A) P, (exists H: a = b, P H) -> {H: a = b & P H}.

Proof.

  intros ???? []; subst; exists eq_refl; auto.

Qed.



Lemma lower_join_inv : forall {A} {J: Join A} a b c, lower_join J a b c <->

  match a, b, c with

  | Some a, Some b, Some c => join a b c

  | Some a, None, Some c | None, Some a, Some c => a = c

  | None, None, None => True

  | _, _, _ => False

  end.

Proof.

  split.

  - inversion 1; subst; auto; destruct c; auto.

  - destruct a, b, c; intros; subst; try contradiction; try constructor; auto.

Qed.



Module Type STRAT_MODEL.

  Declare Module AV : ADR_VAL.

  Import AV.



  Inductive res (PRED : Type) : Type :=

    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED

    | YES': forall sh: Share.t, readable_share sh -> kind -> fpreds PRED -> res PRED

    | PURE': kind -> fpreds PRED -> res PRED.



  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=

    match x with

      | NO' rsh nsh => NO' B rsh nsh

      | YES' sh rsh k pds => YES' B sh rsh k (fmap fpreds f g pds)

      | PURE' k pds => PURE' B k (fmap fpreds f g pds)

    end.

  Axiom ff_res : functorFacts res res_fmap.

  Definition f_res : functor := Functor ff_res.



  Inductive res_join (PRED : Type) : f_res PRED -> f_res PRED -> f_res PRED -> Prop :=

    | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3,

                               join sh1 sh2 sh3 ->

                               res_join PRED (NO' PRED sh1 nsh1) (NO' PRED sh2 nsh2) 

                                     (NO' PRED sh3 nsh3)

    | res_join_NO2 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p,

                               join sh1 sh2 sh3 ->

                               res_join PRED (NO' PRED sh1 nsh1) (YES' PRED sh2 rsh2 k p) 

                                   (YES' PRED sh3 rsh3 k p)

    | res_join_NO3 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p,

                               join sh1 sh2 sh3 ->

                               res_join PRED (YES' PRED sh1 rsh1 k p) (NO' PRED sh2 nsh2) 

                                   (YES' PRED sh3 rsh3 k p)

    | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p,

                              join sh1 sh2 sh3 ->

              res_join PRED (YES' PRED sh1 rsh1 k p) (YES' PRED sh2 rsh2 k p) (YES' PRED sh3 rsh3 k p)

    | res_join_PURE : forall k p, res_join PRED (PURE' PRED k p) (PURE' PRED k p) (PURE' PRED k p).

  Axiom pa_rj : forall PRED, @Perm_alg _ (res_join PRED).

  Instance sa_rj : forall PRED, @Sep_alg _ (res_join PRED).

  Proof. intros.

            apply mkSep 

             with (fun x => match x 

                             with NO' _ _ => NO' _ Share.bot bot_unreadable

                               | YES' _ _ _ _ => NO' _ Share.bot bot_unreadable

                               | PURE' k pds => PURE' _ k pds end).

            intro. destruct t; constructor; try apply join_unit1; auto.

            intros. inversion H; auto.

  Defined.



  Axiom paf_res : @pafunctor f_res res_join.



  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=

    match r with

      | NO' _ _ => None

      | YES' sh rsh k _ => Some (readable_part rsh,k)

      | PURE' _ _ => None 

    end.



  Definition ghost (PRED : Type) : Type :=

    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).



  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=

    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.



  Axiom ff_ghost : functorFacts ghost ghost_fmap.

  Definition f_ghost : functor := Functor ff_ghost.



  Instance preds_join PRED : Join _ := Join_equiv (fpreds PRED).



  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=

  | elem_join_I g a b c va vb vc: join a b c ->

    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))

                    (existT _ g (exist _ c vc)).

  Existing Instance ghost_elem_join.



  Inductive ghost_join PRED : Join (ghost PRED) :=

  | ghost_join_nil_l m: ghost_join PRED nil m m

  | ghost_join_nil_r m: ghost_join PRED m nil m

  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join PRED m1 m2 m3 ->

      ghost_join PRED (a1 :: m1) (a2 :: m2) (a3 :: m3).

  Existing Instance ghost_join.



  Axiom pa_gj : forall PRED, @Perm_alg _ (ghost_join PRED).



  Instance sa_gj : forall PRED, @Sep_alg _ (ghost_join PRED).

  Proof.

    intros; exists (fun _ => nil); auto; constructor.

  Defined.

  Axiom paf_ghost : @pafunctor f_ghost ghost_join.



  Definition f_pre_rmap : functor :=

    fpair (ffunc (fconst address) f_res) f_ghost.



  Instance Join_pre_rmap (A: Type) : Join (f_pre_rmap A) :=

            Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A).



  Declare Instance Perm_pre_rmap: forall (A: Type), Perm_alg (f_pre_rmap A).

  Declare Instance Sep_pre_rmap: forall (A: Type), Sep_alg (f_pre_rmap A).

  Parameter paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap.



  Existing Instance ghost_join.

  Instance Join_res A : Join (f_res A) := res_join A.



Axiom pre_rmap_core:

forall (A : Type) (m : f_pre_rmap A),

  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =

 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)

           (Join_prod ((ffunc (fconst address) f_res) A)

              (Join_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A))

              (f_ghost A) (ghost_join A))

           (@Sep_prod ((ffunc (fconst address) f_res) A)

              (Join_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A))

              (f_ghost A) (ghost_join A)

              (Sep_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A)

                 (fun _ : (fconst address) A => sa_rj A)) 

              (sa_gj A)) m).



End STRAT_MODEL.



Module StratModel (AV' : ADR_VAL) : STRAT_MODEL with Module AV:=AV'.

  Module AV := AV'.

  Import AV.



  Definition preds: functor :=

    fsig (fun T: TypeTree =>

      fpi (fun ts: list Type => dependent_type_functor_rec ts T)).



  Inductive res (PRED : Type) : Type :=

    | NO':  forall sh: Share.t, ~(readable_share sh) -> res PRED

    | YES': forall sh: Share.t, readable_share sh -> kind -> preds PRED -> res PRED

    | PURE': kind -> preds PRED -> res PRED.



  Definition res_fmap (A B:Type) (f:A->B) (g:B->A)(x:res A) : res B :=

    match x with

      | NO' rsh nsh => NO' B rsh nsh

      | YES' sh rsh k pds => YES' B sh rsh k (fmap preds f g pds)

      | PURE' k pds => PURE' B k (fmap preds f g pds)

    end.



  Lemma ff_res : functorFacts res res_fmap.

  Proof with auto.

    constructor; intros; extensionality rs; icase rs; unfold res_fmap.

    rewrite fmap_id... rewrite fmap_id...

    rewrite <- fmap_comp... rewrite <- fmap_comp...

  Qed.



  Definition f_res : functor := Functor ff_res.



  Inductive res_join (PRED : Type) : f_res PRED -> f_res PRED -> f_res PRED -> Prop :=

    | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3,

                               join sh1 sh2 sh3 ->

                               res_join PRED (NO' PRED sh1 nsh1) (NO' PRED sh2 nsh2) 

                                     (NO' PRED sh3 nsh3)

    | res_join_NO2 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p,

                               join sh1 sh2 sh3 ->

                               res_join PRED (NO' PRED sh1 nsh1) (YES' PRED sh2 rsh2 k p) 

                                   (YES' PRED sh3 rsh3 k p)

    | res_join_NO3 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p,

                               join sh1 sh2 sh3 ->

                               res_join PRED (YES' PRED sh1 rsh1 k p) (NO' PRED sh2 nsh2) 

                                   (YES' PRED sh3 rsh3 k p)

    | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p,

                              join sh1 sh2 sh3 ->

              res_join PRED (YES' PRED sh1 rsh1 k p) (YES' PRED sh2 rsh2 k p) (YES' PRED sh3 rsh3 k p)

    | res_join_PURE : forall k p, res_join PRED (PURE' PRED k p) (PURE' PRED k p) (PURE' PRED k p).



  Instance Join_res (PRED: Type) : Join (res PRED) := res_join PRED.



  Instance pa_rj : forall PRED, @Perm_alg _ (res_join PRED).

  Proof. intros. constructor.

*      

      intros x y z z' H1 H2; inv H1; inv H2;

      repeat match goal with H: join ?A ?B _, H': join ?A ?B ?C |- _ => pose proof (join_eq H H'); subst C end;

      repeat proof_irr; auto.

*     

      intros a b c d e H1 H2.

      destruct d as [rd | rd sd kd pd | kd pd].

      destruct a as [ra | | ]; try solve [elimtype False; inv H1].

      destruct b as [rb| | ]; try solve [elimtype False; inv H1].

      assert (join ra rb rd) by (inv H1; auto).

      destruct c as [rc | rc sc kc pc | kc pc]; try solve [elimtype False; inv H2].

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (join rd rc re) by (inv H2; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (NO' _ rf (join_unreadable_shares H3 n1 n2)); split; constructor; auto.

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (join rd rc re) by (inv H2; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable2 H3 sc) kc pc).

      inv H2. split; constructor; auto.

      destruct c as [rc | rc sc kc pc | kc pc]; try solve [elimtype False; inv H2].

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (H0: join rd rc re) by (inv H2; auto).

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      destruct b as [ | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable1 H3 sb) kd pd).  inv H1; inv H2; split; constructor; auto.

      destruct b as [ rb | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (NO' _ rf (join_unreadable_shares H3 n0 n)).  inv H1; inv H2; split; constructor; auto.

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; constructor; auto.

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (H0: join rd rc re) by (inv H2; auto).

      destruct b as [ rb | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable2 H3 sc) kc pc).  inv H1; inv H2; split; constructor; auto.

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; try constructor; auto.

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES' _ rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; try constructor; auto.

      exists (PURE' _ kd pd). inv H1; inv H2; split; constructor.



*      

      intros a b c H; inv H; econstructor;  apply join_comm; auto.



*     

     intros; inv H; inv H0; 

      repeat match goal with H: join ?A ?B ?C, H': join ?C ?D ?A |- _ => 

                    pose proof (join_positivity H H'); subst C 

      end; 

      repeat proof_irr; auto.

 Qed.



  Instance sa_rj : forall PRED, @Sep_alg _ (res_join PRED).

  Proof. intros.

            apply mkSep 

             with (fun x => match x 

                             with NO' _ _ => NO' _ Share.bot bot_unreadable

                               | YES' _ _ _ _ => NO' _ Share.bot bot_unreadable

                               | PURE' k pds => PURE' _ k pds end).

            intro. destruct t; constructor; try apply join_unit1; auto.

            intros. inversion H; auto.

  Defined.



  Definition paf_res : @pafunctor f_res res_join.

  Proof. constructor; repeat intro.

  
   inv H; simpl; constructor; trivial.

   destruct z as [ rz | rz sz kz pz | kz pz ].

   destruct x' as [ rx' | rx' sx' kx' px' | kx' px' ]; try solve [elimtype False; inv H].

   destruct y as [ ry | ry sy ky py | ky py ]; try solve [elimtype False; inv H].

   exists (NO' _ rx' n0); exists (NO' _ ry n1); inv H; split; constructor; tauto.

   destruct x' as [ rx' | rx' sx' kx' px' | kx' px' ]; try solve [elimtype False; inv H].

   destruct y as [ ry | ry sy ky py | ky py ]; try solve [elimtype False; inv H].

   exists (NO' _ rx' n); exists (YES' _ ry sy kz pz); inv H; split; constructor; auto. simpl in *; f_equal; auto.

   destruct y as [ ry | ry sy ky py | ky py ]; try solve [elimtype False; inv H].

   exists (YES' _ rx' sx' kx' pz); exists (NO' _ ry n); inv H; split; constructor; auto.

   exists (YES' _ rx' sx' kx' pz); exists (YES' _ ry sy ky pz); inv H; split; constructor; auto; simpl; f_equal; auto.

   exists (PURE' _ kz pz); exists (PURE' _ kz pz); simpl in *; inv H; split; [constructor | tauto].



   destruct x as [ rx | rx sx kx px | kx px ]; try solve [elimtype False; inv H].

   destruct y as [ ry | ry sy ky py | ky py ]; try solve [elimtype False; inv H].

   destruct z' as [ rz | rz sz kz pz | kz pz ]; try solve [elimtype False; inv H].

   exists (NO' _ ry n0); exists (NO' _ rz n1); inv H; split; constructor; auto.

   destruct z' as [ rz | rz sz kz pz | kz pz ]; try solve [elimtype False; inv H].

   exists (YES' _ ry sy ky py); exists (YES' _ rz sz ky py); inv H; split; constructor; auto.

   destruct y as [ ry | ry sy ky py | ky py ]; try solve [elimtype False; inv H].

   destruct z' as [ rz | rz sz kz pz | kz pz ]; try solve [elimtype False; inv H].

   exists (NO' _ ry n); exists (YES' _ rz sz kx px); inv H; split; constructor; auto.

   destruct z' as [ rz | rz sz kz pz | kz pz ]; try solve [elimtype False; inv H].

   exists (YES' _ ry sy kx px); exists (YES' _ rz sz kx px); inv H; split; constructor; auto. simpl; f_equal; auto.

   exists (PURE' _ kx px); exists (PURE' _ kx px); inv H; split; constructor; auto.

  Qed.



  Definition res_option (PRED : Type) (r: res PRED) : option (rshare * kind):=

    match r with

      | NO' _ _ => None

      | YES' sh rsh k _ => Some (readable_part rsh,k)

      | PURE' _ _ => None 

    end.



  Definition ghost (PRED : Type) : Type :=

    list (option ({g: Ghost & {a: @G g | ghost.valid a}} * fpreds PRED)%type).



  Definition ghost_fmap (A B:Type) (f:A->B) (g:B->A)(x:ghost A) : ghost B :=

    fmap (flist (foption (fpair (fconst _) fpreds))) f g x.



  Lemma ff_ghost : functorFacts ghost ghost_fmap.

  Proof.

    constructor; intros; extensionality x; unfold ghost_fmap.

    - rewrite fmap_id; auto.

    - rewrite <- fmap_comp; auto.

  Qed.



  Definition f_ghost : functor := Functor ff_ghost.



  Instance preds_join PRED : Join _ := Join_equiv (fpreds PRED).



  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=

  | elem_join_I g a b c va vb vc: join a b c ->

    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))

                    (existT _ g (exist _ c vc)).

  Existing Instance ghost_elem_join.



  Inductive ghost_join PRED : Join (ghost PRED) :=

  | ghost_join_nil_l m: ghost_join PRED nil m m

  | ghost_join_nil_r m: ghost_join PRED m nil m

  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join PRED m1 m2 m3 ->

      ghost_join PRED (a1 :: m1) (a2 :: m2) (a3 :: m3).

  Hint Constructors ghost_join.

  Existing Instance ghost_join.



  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->

  match a1, a2, a3 with

  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>

      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')

  end.

  Proof.

    inversion 1; subst.

    exists eq_refl, eq_refl; auto.

  Qed.



  Lemma ghost_join_inv: forall PRED m1 m2 m3, ghost_join PRED m1 m2 m3 ->

  match m1, m2 with

  | nil, _ => m3 = m2

  | _, nil => m3 = m1

  | a1 :: m1, a2 :: m2 => match m3 with nil => False

                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join PRED m1 m2 m3 end

  end.

  Proof.

    induction 1; simpl; auto.

    destruct m; simpl; auto.

  Qed.



  Instance pa_gej : @Perm_alg _ ghost_elem_join.

  Proof.

    constructor.

    - inversion 1; inversion 1; subst.

      inv H.

      repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

          subst).

      f_equal; eapply exist_ext, join_eq; eauto.

    - intros ????? J1%elem_join_inv J2%elem_join_inv.

      destruct a as (ga & a & ?), b as (gb & b & ?), c as (gc & c & ?), d as (gd & d & ?),

        e as (ge & e & ?).

      repeat (apply realize_eq in J1; destruct J1 as [? J1]).

      repeat (apply realize_eq in J2; destruct J2 as [? J2]); subst.

      destruct (join_assoc J1 J2) as (f & ? & J).

      exists (existT _ ga (exist _ f (join_valid _ _ _ (join_comm J) v3))).

      split; constructor; auto.

    - inversion 1; constructor; auto.

    - inversion 1; subst; inversion 1; subst; auto.

      inv H.

      repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

          subst).

      f_equal; eapply exist_ext, join_positivity; eauto.

  Qed.



  Instance pa_gj : forall PRED, @Perm_alg _ (ghost_join PRED).

  Proof.

    constructor.

    - intros until 1; revert z'; induction H; inversion 1; subst; auto.

      f_equal; auto.

      eapply join_eq; eauto.

    - induction a; intros ???? J1 J2; apply ghost_join_inv in J1; subst.

      { exists e; split; auto; constructor. }

      destruct b; subst; [eexists; split; eauto; constructor|].

      destruct d; [contradiction|].

      destruct J1 as [Jc1 J1].

      apply ghost_join_inv in J2.

      destruct c; subst; [eexists; split; eauto; constructor; auto|].

      destruct e; [contradiction|].

      destruct J2 as [Jc2 J2].

      destruct (join_assoc Jc1 Jc2) as (f & ? & ?).

      destruct (IHa _ _ _ _ J1 J2) as (f' & ? & ?).

      exists (f :: f'); split; constructor; auto.

    - induction 1; constructor; auto.

    - intros until 1; revert b'; induction H; inversion 1; subst; auto.

      f_equal; eauto.

      eapply join_positivity; eauto.

  Qed.



  Instance sa_gj : forall PRED, @Sep_alg _ (ghost_join PRED).

  Proof.

    intros; exists (fun _ => nil); auto; constructor.

  Defined.



  Opaque fpreds.



  Definition paf_ghost : @pafunctor f_ghost ghost_join.

  Proof.

    constructor; repeat intro.

    - induction H; constructor; auto.

      inv H; constructor; auto.

      inv H1; constructor; auto.

      inv H2; constructor; auto; simpl; congruence.

    - revert dependent z; revert y; induction x'; intros; apply ghost_join_inv in H.

      { exists nil, z; split; auto; constructor. }

      destruct y; simpl in *.

      { exists z, nil; split; auto; constructor. }

      destruct z; [contradiction | simpl in *].

      destruct H as [J1 J2].

      destruct (IHx' _ _ J2) as (x & y' & ? & ? & ?); subst.

      apply lower_join_inv in J1.

      destruct a as [[[? []]]|].

      + destruct o as [[[? []]]|].

        * destruct o0 as [[[? []]]|]; [|contradiction].

          destruct J1 as [J1%elem_join_inv J1']; simpl in *.

          repeat (apply realize_eq in J1 as [? J1]); subst; simpl in *.

          exists (Some (existT _ x0 (exist _ _ v), _f1) :: x),

            (Some (existT _ x0 (exist _ _ v0), _f1) :: y').

          split; [repeat constructor; auto|].

          unfold ghost_fmap in *; simpl in *.

          inv J1'.

          rewrite <- H1, <- H2; auto.

        * destruct o0 as [[[? []]]|]; [|contradiction].

          inv J1.

          match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

            subst.

          exists (Some (existT _ x2 (exist _ _ v0), _f0) :: x), (None :: y').

          split; [repeat constructor; auto|].

          unfold ghost_fmap in *; simpl in *.

          rewrite <- H1; split; f_equal; f_equal; f_equal; f_equal.

          apply exist_ext; auto.

      + exists (None :: x), (o0 :: y').

        split; [repeat constructor; auto|].

        split; auto.

        unfold ghost_fmap in *; simpl in *.

        rewrite <- H1; f_equal.

        destruct o, o0; inv J1; auto.

    - revert dependent z'; revert y; induction x; intros; apply ghost_join_inv in H; simpl in H.

      { exists y, y; split; auto; constructor. }

      destruct y; simpl in *.

      { exists nil, (a :: x); split; auto; constructor. }

      destruct z'; [contradiction | simpl in *].

      destruct H as [J1 J2].

      destruct (IHx _ _ J2) as (y' & z & ? & ? & ?); subst.

      apply lower_join_inv in J1.

      destruct a as [[[? []]]|].

      + destruct o as [[[? []]]|].

        * destruct o0 as [[[? []]]|]; [|contradiction].

          destruct J1 as [J1%elem_join_inv J1']; simpl in *.

          repeat (apply realize_eq in J1 as [? J1]); subst; simpl in *.

          exists (Some (existT _ x0 (exist _ _ v0), _f) :: y'),

            (Some (existT _ x0 (exist _ _ v1), _f) :: z).

          split; [repeat constructor; auto|].

          unfold ghost_fmap in *; simpl in *.

          inv J1'.

          rewrite <- H0, <- H1; auto.

        * destruct o0 as [[[? []]]|]; [|contradiction].

          inv J1.

          match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

            subst.

          exists (None :: y'), (Some (existT _ x2 (exist _ _ v), _f) :: z).

          split; [repeat constructor; auto|].

          unfold ghost_fmap in *; simpl in *.

          rewrite <- H0; split; f_equal; f_equal; f_equal; f_equal.

          apply exist_ext; auto.

      + exists (o :: y'), (o :: z).

        split; [repeat constructor; auto|].

        unfold ghost_fmap in *; simpl in *; rewrite <- H0; split; f_equal.

        destruct o, o0; auto; contradiction.

  Qed.



  Definition pre_rmap (A:Type) := ((address -> res A) * ghost A)%type.

  Definition f_pre_rmap : functor :=

    fpair (ffunc (fconst address) f_res) f_ghost.



  Notation Join_obj A := (Join_prod _ (Join_fun address (res A) (res_join A)) _ (ghost_join A)).



  Instance Join_pre_rmap (A: Type) : Join (pre_rmap A) :=

    Join_obj A.



  Definition paf_pre_rmap : @pafunctor f_pre_rmap Join_pre_rmap :=

    paf_pair (paf_fun address paf_res) paf_ghost.



  Definition Perm_pre_rmap (A: Type): Perm_alg (pre_rmap A) :=

    Perm_prod (Perm_fun address _ _ _) (pa_gj A).



  Definition Sep_pre_rmap (A: Type): Sep_alg (pre_rmap A) :=

    Sep_prod (Sep_fun address _ _ _) (sa_gj A).



Lemma pre_rmap_core:

forall (A : Type) (m : f_pre_rmap A),

  @core (f_pre_rmap A) (Join_pre_rmap A) (Sep_pre_rmap A) m =

 (@core ((fpair (ffunc (fconst address) f_res) f_ghost) A)

           (Join_prod ((ffunc (fconst address) f_res) A)

              (Join_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A))

              (f_ghost A) (ghost_join A))

           (@Sep_prod ((ffunc (fconst address) f_res) A)

              (Join_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A))

              (f_ghost A) (ghost_join A)

              (Sep_pi ((fconst address) A)

                 (fun _ : (fconst address) A => f_res A)

                 (fun _ : (fconst address) A => Join_res A)

                 (fun _ : (fconst address) A => sa_rj A)) 

              (sa_gj A)) m).

Proof.

intros. reflexivity.

Qed.



End StratModel.



Local Open Scope nat_scope.



Module Type RMAPS.

  Declare Module AV:ADR_VAL.

  Import AV.



  Parameter rmap : Type.

  Axiom Join_rmap: Join rmap. Existing Instance Join_rmap.

  Axiom Perm_rmap: Perm_alg rmap. Existing Instance Perm_rmap.

  Axiom Sep_rmap: Sep_alg rmap. Existing Instance Sep_rmap.

  Axiom ag_rmap: ageable rmap.  Existing Instance ag_rmap.

  Axiom Age_rmap: Age_alg rmap.  Existing Instance Age_rmap.



  Inductive preds : Type :=

    SomeP : forall A : TypeTree,

      (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.



  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).



  Inductive resource : Type :=

    | NO: forall sh: Share.t, ~(readable_share sh) -> resource

    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource

    | PURE: kind -> preds -> resource.



  Definition res_option (r:resource) : option (rshare * kind) :=

    match r with

      | NO _ _ => None

      | YES sh rsh k _ => Some (readable_part rsh,k)

      | PURE k _ => None

    end.



  Inductive res_join : resource -> resource -> resource -> Prop :=

   | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3

                 (RJ: join sh1 sh2 sh3),

                 res_join (NO sh1 nsh1) (NO sh2 nsh2) (NO sh3 nsh3)

   | res_join_NO2 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3), 

                 res_join (YES sh1 rsh1 k p) (NO sh2 nsh2) (YES sh3 rsh3 k p) 

   | res_join_NO3 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3),

                 res_join (NO sh1 nsh1) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p) 

   | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3),

        res_join (YES sh1 rsh1 k p) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p)

   | res_join_PURE : forall k p, res_join (PURE k p) (PURE k p) (PURE k p). 



  Instance Join_resource: Join resource := res_join.

  Axiom Perm_resource: Perm_alg resource. Existing Instance Perm_resource.

  Axiom Sep_resource: Sep_alg resource. Existing Instance Sep_resource.



  Definition preds_fmap (f g: pred rmap -> pred rmap) (x:preds) : preds :=

    match x with SomeP A Q => SomeP A (fmap (fpi _) f g Q)

    end.

  

  Axiom preds_fmap_id : preds_fmap (id _) (id _) = id preds.

  Axiom preds_fmap_comp : forall f1 f2 g1 g2,

    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).



  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=

    match x with

    | NO sh nsh => NO sh nsh

    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)

    | PURE k p => PURE k (preds_fmap f g p)

    end.

  Axiom resource_fmap_id : resource_fmap (id _) (id _) = id resource.

  Axiom resource_fmap_comp : forall f1 f2 g1 g2,

    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).



  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).



  Instance preds_join : Join _ := Join_equiv preds.



  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=

  | elem_join_I g a b c va vb vc: join a b c ->

    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))

                    (existT _ g (exist _ c vc)).

  Existing Instance ghost_elem_join.



  Inductive ghost_join : Join ghost :=

  | ghost_join_nil_l m: ghost_join nil m m

  | ghost_join_nil_r m: ghost_join m nil m

  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->

      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).

  Existing Instance ghost_join.



  Axiom Perm_ghost: Perm_alg ghost. Existing Instance Perm_ghost.

  Axiom Sep_ghost: Sep_alg ghost. Existing Instance Sep_ghost.

  Axiom ghost_core: forall (g: ghost), core g = nil.



  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=

    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.



  Axiom ghost_fmap_id : ghost_fmap (id _) (id _) = id ghost.

  Axiom ghost_fmap_comp : forall f1 f2 g1 g2,

    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).



  Definition rmap' := ((address -> resource) * ghost)%type.



  Definition rmap_fmap (f g: pred rmap -> pred rmap) (x:rmap') : rmap' :=

    (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).



  Axiom rmap_fmap_id : rmap_fmap (id _) (id _) = id rmap'.

  Axiom rmap_fmap_comp : forall f1 f2 g1 g2,

   rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).



  Parameter squash : (nat * rmap') -> rmap.

  Parameter unsquash : rmap -> (nat * rmap').



  Axiom rmap_level_eq: @level rmap _ = fun x => fst (unsquash x).

  Axiom rmap_age1_eq: @age1 _ _ =

     fun k => match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).

  Infix "@" := resource_at (at level 50, no associativity).

  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).



  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.



  Axiom join_unsquash : forall phi1 phi2 phi3,

    join phi1 phi2 phi3 <->

    join (unsquash phi1) (unsquash phi2) (unsquash phi3).



  Definition rmap_unage (k:rmap) : rmap :=

    match unsquash k with

    | (n,x) => squash (S n, x)

    end.



  Program Definition approx (n:nat) (p: pred rmap) : pred rmap :=

    fun w => level w < n /\ p w.

  Next Obligation.

  destruct H0.

  split.

  apply age_level in H. omega.

  apply pred_hereditary with a; auto.

  Qed.



  Axiom squash_unsquash : forall phi, squash (unsquash phi) = phi.

  Axiom unsquash_squash : forall n rm, unsquash (squash (n,rm)) = (n,rmap_fmap (approx n) (approx n) rm).

  Axiom ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).



End RMAPS.



Module Rmaps (AV':ADR_VAL): RMAPS with Module AV:=AV'.

  Module AV:=AV'.

  Import AV.



  Module SM := StratModel(AV).

  Import SM.



  Module TyF. 

    Definition F := f_pre_rmap.

  End TyF.



  Module TyFSA <: KNOT_FULL_SA_INPUT with Module KI:=TyF.

    Module KI := TyF.

    Import KI.



    Instance Join_F: forall A, Join (F A) := _.

    Definition Perm_F : forall A, Perm_alg (F A) := Perm_pre_rmap.

    Definition Sep_F := Sep_pre_rmap.

    Definition paf_F := paf_pre_rmap.

  End TyFSA.



  Module K := Knot_MixVariantHeredProp(TyF).

  Module KL := KnotLemmas_MixVariantHeredProp(K).

  Module KSa := KnotFullSa(TyFSA)(K)(KL).



  Definition rmap := K.knot.

  Instance Join_rmap: Join rmap := KSa.Join_knot.

  Instance Perm_rmap : Perm_alg rmap:= KSa.Perm_knot.

  Instance Sep_rmap : Sep_alg rmap:= KSa.Sep_knot.

  Instance ag_rmap : ageable rmap := K.ageable_knot.

  Instance Age_rmap: Age_alg rmap := KSa.asa_knot.



  Inductive preds : Type :=

    SomeP : forall A : TypeTree,

    (forall ts: list Type, dependent_type_functor_rec ts A (pred rmap)) -> preds.



  Definition NoneP := SomeP (ConstType unit) (fun _ => tt).



  Inductive resource : Type :=

    | NO: forall sh: Share.t, ~ readable_share sh -> resource

    | YES: forall sh: Share.t, readable_share sh -> kind -> preds -> resource

    | PURE: kind -> preds -> resource.



  Definition resource2res (r: resource): res (pred rmap) :=

    match r with

      | NO sh nsh => NO' (pred rmap) sh nsh

      | YES sh rsh k (SomeP A l) => YES' (pred rmap) sh rsh k (existT _ A l)

      | PURE k (SomeP A l) => PURE' (pred rmap) k (existT _ A l)

    end.



  Definition res2resource (r: res (pred rmap)) : resource :=

    match r with

      | NO' sh nsh => NO sh nsh

      | YES' sh rsh k (existT A l) => YES sh rsh k (SomeP A l)

      | PURE' k (existT A l) => PURE k (SomeP A l)

    end.



  Lemma res2resource2res: forall x, resource2res (res2resource x) = x.

  Proof. unfold resource2res, res2resource; destruct x as [? | ? ? ? [? ?] | ? [? ?]]; auto. Qed.



  Lemma resource2res2resource: forall x, res2resource (resource2res x) = x.

  Proof. unfold resource2res, res2resource; destruct x; try destruct p0; try destruct p; auto. Qed.



  Definition res_option (r:resource) : option (rshare * kind) :=

    match r with

      | NO _ _ => None

      | YES sh rsh k _ => Some (readable_part rsh,k)

      | PURE k _ => None

    end.



  Lemma res_option_rewrite: res_option = SM.res_option (pred rmap) oo resource2res.

  Proof.

    unfold SM.res_option, res_option, compose.

    extensionality r; destruct r; simpl; auto; destruct p; auto.

  Qed.



  Definition ghost : Type := list (option ({g: Ghost & {a: @G g | ghost.valid a}} * preds)%type).



  Definition pred2p (p: preds) : fpreds (pred rmap) :=

    match p with SomeP A P => existT _ A P end.



  Definition p2pred (p: fpreds (pred rmap)) : preds :=

    match p with existT A P => SomeP A P end.



  Definition ghost2g (r: ghost): SM.ghost (pred rmap) :=

    map (option_map (fun '(a, b) => (a, pred2p b))) r.



  Definition g2ghost (r: SM.ghost (pred rmap)) : ghost :=

    map (option_map (fun '(a, b) => (a, p2pred b))) r.



  Lemma g2ghost2g: forall x, ghost2g (g2ghost x) = x.

  Proof.

    induction x; auto; simpl.

    rewrite IHx; destruct a as [[]|]; auto; simpl.

    destruct _f; auto.

  Qed.



  Lemma ghost2g2ghost: forall x, g2ghost (ghost2g x) = x.

  Proof.

    induction x; auto; simpl.

    rewrite IHx; destruct a as [[]|]; auto; simpl.

    destruct p; auto.

  Qed.



  Inductive res_join : resource -> resource -> resource -> Prop :=

   | res_join_NO1 : forall sh1 nsh1 sh2 nsh2 sh3 nsh3

                 (RJ: join sh1 sh2 sh3),

                 res_join (NO sh1 nsh1) (NO sh2 nsh2) (NO sh3 nsh3)

   | res_join_NO2 : forall sh1 rsh1 sh2 nsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3), 

                 res_join (YES sh1 rsh1 k p) (NO sh2 nsh2) (YES sh3 rsh3 k p) 

   | res_join_NO3 : forall sh1 nsh1 sh2 rsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3),

                 res_join (NO sh1 nsh1) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p) 

   | res_join_YES : forall sh1 rsh1 sh2 rsh2 sh3 rsh3 k p

                 (RJ: join sh1 sh2 sh3),

        res_join (YES sh1 rsh1 k p) (YES sh2 rsh2 k p) (YES sh3 rsh3 k p)

   | res_join_PURE : forall k p, res_join (PURE k p) (PURE k p) (PURE k p).



  Instance Join_resource: Join resource := res_join.

  Instance Perm_resource: Perm_alg resource.

  Proof. constructor.

  * 

      intros x y z z' H1 H2; inv H1; inv H2;

      repeat match goal with H: join ?A ?B _, H': join ?A ?B ?C |- _ => pose proof (join_eq H H'); subst C end;

      repeat proof_irr; auto.

  * 

      intros a b c d e H1 H2.

      destruct d as [rd | rd sd kd pd | kd pd].

      destruct a as [ra | | ]; try solve [elimtype False; inv H1].

      destruct b as [rb| | ]; try solve [elimtype False; inv H1].

      assert (join ra rb rd) by (inv H1; auto).

      destruct c as [rc | rc sc kc pc | kc pc]; try solve [elimtype False; inv H2].

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (join rd rc re) by (inv H2; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (NO rf (join_unreadable_shares H3 n1 n2)); split; constructor; auto.

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (join rd rc re) by (inv H2; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable2 H3 sc) kc pc).

      inv H2. split; constructor; auto.

      destruct c as [rc | rc sc kc pc | kc pc]; try solve [elimtype False; inv H2].

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (H0: join rd rc re) by (inv H2; auto).

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      destruct b as [ | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable1 H3 sb) kd pd).  inv H1; inv H2; split; constructor; auto.

      destruct b as [ rb | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (NO rf (join_unreadable_shares H3 n0 n)).  inv H1; inv H2; split; constructor; auto.

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; constructor; auto.

      destruct e as [re | re se ke pe | ke pe]; try solve [elimtype False; inv H2].

      assert (H0: join rd rc re) by (inv H2; auto).

      destruct b as [ rb | rb sb kb pb | ]; try solve [elimtype False; inv H1].

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable2 H3 sc) kc pc).  inv H1; inv H2; split; constructor; auto.

      destruct a as [ra | ra sa ka pa | ka pa ]; try solve [elimtype False; inv H1].

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; try constructor; auto.

      assert (H: join ra rb rd) by (inv H1; auto).

      destruct (join_assoc H H0) as [rf [? ?]].

      exists (YES rf (join_readable1 H3 sb) kb pb).  inv H1; inv H2; split; try constructor; auto.

      exists (PURE kd pd). inv H1; inv H2; split; constructor.



*      

      intros a b c H; inv H; econstructor;  apply join_comm; auto.



*     

     intros; inv H; inv H0; 

      repeat match goal with H: join ?A ?B ?C, H': join ?C ?D ?A |- _ => 

                    pose proof (join_positivity H H'); subst C 

      end; 

      repeat proof_irr; auto.

 Qed.



  Instance Sep_resource: Sep_alg resource.

  Proof.

  apply mkSep 

    with (fun x => match x 

                   with NO _ _ => NO Share.bot bot_unreadable

                      | YES _ _ _ _ => NO Share.bot bot_unreadable

                      | PURE k pds => PURE k pds end).

  intro. destruct t; constructor; try apply join_unit1; auto.

  intros. inversion H; auto.

  Defined.



  Instance preds_join : Join _ := Join_equiv preds.



  Inductive ghost_elem_join : Join {g: Ghost & {a: @G g | ghost.valid a}} :=

  | elem_join_I g a b c va vb vc: join a b c ->

    ghost_elem_join (existT _ g (exist _ a va)) (existT _ g (exist _ b vb))

                    (existT _ g (exist _ c vc)).

  Existing Instance ghost_elem_join.



  Inductive ghost_join : Join ghost :=

  | ghost_join_nil_l m: ghost_join nil m m

  | ghost_join_nil_r m: ghost_join m nil m

  | ghost_join_cons a1 a2 m1 m2 a3 m3: join a1 a2 a3 -> ghost_join m1 m2 m3 ->

      ghost_join (a1 :: m1) (a2 :: m2) (a3 :: m3).

  Existing Instance ghost_join.



  Lemma elem_join_inv: forall a1 a2 a3, ghost_elem_join a1 a2 a3 ->

  match a1, a2, a3 with

  | existT g1 (exist x1 _), existT g2 (exist x2 _), existT g3 (exist x3 _) =>

      exists H: g2 = g1, exists H': g3 = g1, join x1 (eq_rect _ _ x2 _ H) (eq_rect _ _ x3 _ H')

  end.

  Proof.

    inversion 1; subst.

    exists eq_refl, eq_refl; auto.

  Qed.



  Lemma ghost_join_inv: forall m1 m2 m3, ghost_join m1 m2 m3 ->

  match m1, m2 with

  | nil, _ => m3 = m2

  | _, nil => m3 = m1

  | a1 :: m1, a2 :: m2 => match m3 with nil => False

                          | a3 :: m3 => join a1 a2 a3 /\ ghost_join m1 m2 m3 end

  end.

  Proof.

    induction 1; simpl; auto.

    destruct m; simpl; auto.

  Qed.



  Instance pa_gej : @Perm_alg _ ghost_elem_join.

  Proof.

    constructor.

    - inversion 1; inversion 1; subst.

      inv H.

      repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

          subst).

      f_equal; eapply exist_ext, join_eq; eauto.

    - intros ????? J1%elem_join_inv J2%elem_join_inv.

      destruct a as (ga & a & ?), b as (gb & b & ?), c as (gc & c & ?), d as (gd & d & ?),

        e as (ge & e & ?).

      repeat (apply realize_eq in J1; destruct J1 as [? J1]).

      repeat (apply realize_eq in J2; destruct J2 as [? J2]); subst.

      destruct (join_assoc J1 J2) as (f & ? & J).

      exists (existT _ ga (exist _ f (join_valid _ _ _ (join_comm J) v3))).

      split; constructor; auto.

    - inversion 1; constructor; auto.

    - inversion 1; subst; inversion 1; subst; auto.

      inv H.

      repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

          subst).

      f_equal; eapply exist_ext, join_positivity; eauto.

  Qed.



  Instance Perm_ghost : Perm_alg ghost.

  Proof.

    constructor.

    - intros until 1; revert z'; induction H; inversion 1; subst; auto.

      f_equal; auto.

      eapply join_eq; eauto.

    - induction a; intros ???? J1 J2; apply ghost_join_inv in J1; subst.

      { exists e; split; auto; constructor. }

      destruct b; subst; [eexists; split; eauto; constructor|].

      destruct d; [contradiction|].

      destruct J1 as [Jc1 J1].

      apply ghost_join_inv in J2.

      destruct c; subst; [eexists; split; eauto; constructor; auto|].

      destruct e; [contradiction|].

      destruct J2 as [Jc2 J2].

      destruct (join_assoc Jc1 Jc2) as (f & ? & ?).

      destruct (IHa _ _ _ _ J1 J2) as (f' & ? & ?).

      exists (f :: f'); split; constructor; auto.

    - induction 1; constructor; auto.

    - intros until 1; revert b'; induction H; inversion 1; subst; auto.

      f_equal; eauto.

      eapply join_positivity; eauto.

  Qed.



  Instance Sep_ghost : Sep_alg ghost.

  Proof.

    intros; exists (fun _ => nil); auto; constructor.

  Defined.



  Lemma ghost_core : forall (g: ghost), core g = nil.

  Proof.

    auto.

  Qed.



  Definition rmap' := ((address->resource) * ghost)%type.

  Definition preds_fmap (f g:(pred rmap)->(pred rmap)) (x:preds) : preds :=

    match x with SomeP A ls => SomeP A (fmap (fpi _) f g ls) end.



  Lemma preds_fmap_id : preds_fmap (id (pred rmap)) (id (pred rmap)) = id preds.

  Proof.

    intros; apply extensionality; intro x; destruct x; simpl; auto.

    unfold id at 3.

    f_equal.

    extensionality i.

    rewrite fmap_id; auto.

  Qed.



  Lemma preds_fmap_comp : forall f1 f2 g1 g2,

    preds_fmap g1 g2 oo preds_fmap f1 f2 = preds_fmap (g1 oo f1) (f2 oo g2).

  Proof.

    intros; apply extensionality; intro x; destruct x; simpl.

    unfold preds_fmap, compose at 1; simpl.

    f_equal.

    extensionality i.

    rewrite <- fmap_comp; auto.

  Qed.



  Definition resource_fmap (f g:pred rmap -> pred rmap) (x:resource) : resource :=

    match x with

    | NO sh nsh => NO sh nsh

    | YES sh rsh k p => YES sh rsh k (preds_fmap f g p)

    | PURE k p => PURE k (preds_fmap f g p)

    end.



  Definition ghost_fmap (f g:pred rmap -> pred rmap)(x:ghost) : ghost :=

    map (option_map (fun '(a, b) => (a, preds_fmap f g b))) x.



  Lemma resource_fmap_id :

    resource_fmap (id (pred rmap)) (id (pred rmap)) = id resource.

  Proof.

    intros; apply extensionality; intro x.

    unfold resource_fmap.

    destruct x; simpl; auto.

    rewrite preds_fmap_id; auto.

    rewrite preds_fmap_id; auto.

  Qed.



  Lemma ghost_fmap_id : ghost_fmap (id (pred rmap)) (id (pred rmap)) = id ghost.

  Proof.

    extensionality x; induction x; auto; simpl.

    rewrite IHx; destruct a as [[]|]; auto; simpl.

    rewrite preds_fmap_id; auto.

  Qed.



  Lemma resource_fmap_comp : forall f1 f2 g1 g2,

    resource_fmap g1 g2 oo resource_fmap f1 f2 = resource_fmap (g1 oo f1) (f2 oo g2).

  Proof.

    intros f1 f2 g1 g2.

    apply extensionality; intro x; destruct x; simpl; auto.

    unfold compose at 1; simpl.

    rewrite <- preds_fmap_comp; auto.

    rewrite <- preds_fmap_comp; auto.

  Qed.



  Lemma ghost_fmap_comp : forall f1 f2 g1 g2,

    ghost_fmap g1 g2 oo ghost_fmap f1 f2 = ghost_fmap (g1 oo f1) (f2 oo g2).

  Proof.

    intros; extensionality x; induction x; auto; simpl.

    rewrite <- IHx; destruct a as [[]|]; auto; simpl.

    rewrite <- preds_fmap_comp; auto.

  Qed.



  Definition rmap_fmap (f g:(pred rmap)->(pred rmap)) (x:rmap') : rmap' :=

              (resource_fmap f g oo fst x, ghost_fmap f g (snd x)).



  Lemma rmap_fmap_id : rmap_fmap (id (pred rmap)) (id (pred rmap)) = id rmap'.

  Proof.

    intros; apply extensionality; intro x.

    unfold rmap_fmap; destruct x.

    simpl.

    rewrite resource_fmap_id, ghost_fmap_id.

    rewrite (id_unit2 _ (resource) r).

    f_equal; auto.

  Qed.



  Lemma rmap_fmap_comp : forall f1 f2 g1 g2,

    rmap_fmap g1 g2 oo rmap_fmap f1 f2 = rmap_fmap (g1 oo f1) (f2 oo g2).

  Proof.

    intros f1 f2 g1 g2.

    unfold rmap_fmap.

    apply extensionality; intro x.

    unfold compose at 1.

    destruct x as (r,g). simpl.

    rewrite <- compose_assoc.

    rewrite resource_fmap_comp; auto.

    f_equal; auto.

    pose proof ghost_fmap_comp as HG.

    unfold compose in HG at 1; rewrite <- HG.

    intros.

    f_equal; proof_irr; auto.

  Qed.



  Definition rmap'2pre_rmap (f: rmap') : f_pre_rmap (pred rmap) :=

      (fun x : address => resource2res (fst f x), ghost2g (snd f)).



  Definition pre_rmap2rmap' (f: f_pre_rmap (pred rmap)) : rmap' :=

      (fun l : address => res2resource (fst f l), g2ghost (snd f)).



  Lemma rmap'2pre_rmap2rmap' :

    forall x, rmap'2pre_rmap (pre_rmap2rmap' x) = x.

  Proof.

    intro. unfold rmap'2pre_rmap, pre_rmap2rmap'. simpl.

    destruct x; simpl; f_equal.

    extensionality x; rewrite res2resource2res; auto.

    rewrite g2ghost2g; auto.

  Qed.



  Lemma pre_rmap2rmap'2pre_rmap :

    forall x,  pre_rmap2rmap' (rmap'2pre_rmap x) = x.

  Proof.

    intro.

    unfold rmap'2pre_rmap, pre_rmap2rmap'. simpl.

    destruct x; simpl; f_equal.

    extensionality x; rewrite resource2res2resource; auto.

    rewrite ghost2g2ghost; auto.

  Qed.



  Definition squash (n_rm:nat * rmap') : rmap :=

    match n_rm with (n,rm) => K.squash (n, rmap'2pre_rmap rm) end.



  Definition unsquash (phi:rmap) : (nat * rmap') :=

    match K.unsquash phi with (n,rm) => (n, pre_rmap2rmap' rm) end.



  Definition rmap_level (phi:rmap) : nat := fst (unsquash phi).

  Definition resource_at (phi:rmap) : address -> resource := fst (snd (unsquash phi)).

  Infix "@" := resource_at (at level 50, no associativity).

  Definition ghost_of (phi:rmap) : ghost := snd (snd (unsquash phi)).



  Lemma pred_ext': forall {A} `{agA: ageable A} P Q,

                (forall x, app_pred P x <-> app_pred Q x) -> P = Q.

  Proof. intros; apply pred_ext; intro; apply H; auto. Qed.



  Lemma squash_unsquash : forall phi, squash (unsquash phi) = phi.

  Proof.

    intros.

    unfold squash, unsquash; simpl.

    destruct (K.unsquash phi) eqn:?H; simpl; intros.

    rewrite rmap'2pre_rmap2rmap'.

    unfold K.KI.F in *.

    unfold f_pre_rmap in H.

    match goal with

    | |- K.squash ?A = _ => replace A with (K.unsquash phi)

    end.

    rewrite K.squash_unsquash; auto.

  Qed.



  Program Definition approx (n:nat) (p: (pred rmap)) : (pred rmap) :=

    fun w => level w < n /\ p w.

  Next Obligation.

  destruct H0.

  split.

  apply age_level in H.

  simpl in *. omega.

  apply pred_hereditary with a; auto.

  Qed.



  Lemma approx_K_approx: approx = K.approx.

  Proof.

    extensionality n p.

    apply pred_ext'; intros w.

    unfold approx, compose; simpl.

    rewrite K.approx_spec.

    unfold rmap_level, unsquash; simpl;

    repeat rewrite K.knot_level;

    repeat rewrite setset, setget;     intuition.

  Qed.



  Lemma unsquash_squash : forall n rm, (unsquash (squash (n,rm))) = (n,rmap_fmap (approx n) (approx n) rm).

  Proof.

    intros.

    unfold unsquash, squash.

    rewrite K.unsquash_squash. unfold K.KI.F, f_pre_rmap.

    match goal with [|- (_,?X) = (_,?Y) ] =>

      replace Y with X; auto

    end.

    match goal with [|- pre_rmap2rmap' ?X = _ ] =>

      replace X with

        (fmap f_pre_rmap (K.approx n) (K.approx n) (rmap'2pre_rmap rm))

    end.

    2: repeat rewrite <- fmap_comp.

    2: unfold compose; auto.

    destruct rm; simpl. unfold pre_rmap2rmap', rmap_fmap. simpl; f_equal.

    extensionality l.

    unfold compose.

    destruct (r l); simpl; auto.

    

    destruct p; simpl.

    rewrite approx_K_approx; auto.

    

    destruct p; simpl.

    rewrite approx_K_approx; auto.

    

    induction g; auto; simpl.

    setoid_rewrite IHg; destruct a as [[]|]; auto; simpl.

    repeat f_equal.

    rewrite approx_K_approx; destruct p; auto.

  Qed.



  Instance Join_nat_rmap': Join (nat * rmap') := Join_prod _ (Join_equiv nat) _ _.



  Lemma g2ghost_inv: forall g1 g2, g2ghost g1 = g2ghost g2 -> g1 = g2.

  Proof.

    induction g1; destruct g2; inversion 1; auto.

    f_equal; auto.

    destruct a as [[]|], o as [[]|]; inv H1; auto.

    destruct _f, _f0; inv H4; auto.

  Qed.



  Lemma join_unsquash : forall phi1 phi2 phi3,

    join phi1 phi2 phi3 <->

    join (unsquash phi1) (unsquash phi2) (unsquash phi3).

  Proof.

    intros.

    unfold unsquash.

    rewrite KSa.join_unsquash.

    destruct (K.unsquash phi1) as [n f].

    destruct (K.unsquash phi2) as [n0 f0].

    destruct (K.unsquash phi3) as [n1 f1].

    simpl; intuition.

    destruct H; simpl in *; split; simpl; auto.

    inversion H0.

    constructor.

    intro l; specialize ( H1 l).

    simpl in *.

    unfold compose.

    destruct f, f0, f1; simpl in *.

    inv H1; simpl.

    constructor; auto.

    destruct p. simpl in *. constructor; auto. destruct p. simpl in *. constructor; auto.

    destruct p; simpl in *.

    constructor; auto.

    destruct p; simpl in *.

    constructor; auto.



    destruct f, f0, f1; simpl in *. 

    clear - H2; induction H2; constructor; auto.

    inv H; constructor; auto.

    destruct a0, a4, a5; inv H0; simpl in *.

    inv H; inv H1; constructor; constructor; auto.



    destruct H; simpl in *; split; simpl; auto.

    inversion H0.

    hnf in H1. simpl proj1_sig in H1.

    constructor; auto.

    intro l; specialize ( H1 l).

    simpl proj1_sig.

    clear - H1.

    destruct f, f0, f1; simpl in *.

    forget (r l) as a; forget (r0 l) as b; forget (r1 l) as c.

    clear - H1.

    unfold res2resource in *. unfold res_fmap in *.

    destruct a as [ra | ra sha ka pa| ka pa]; try destruct pa as [? ?p];

    destruct b as [rb | rb shb kb pb|kb pb]; try destruct pb as [? ?p];

    destruct c as [rc | rc shc kc pc|kc pc]; try destruct pc as [? ?p];

    inv H1.

    + constructor; auto.

    + apply inj_pair2 in H8. subst p0. constructor; auto.

    + apply inj_pair2 in H8. subst p0. constructor; auto.

    + subst. apply inj_pair2 in H11. subst p1. apply inj_pair2 in H7; subst p0.

      constructor; auto.

    + subst ; apply inj_pair2 in H8. subst p1. apply inj_pair2 in H5. subst p0.

      constructor; auto.

    + simpl in *.

      destruct f, f0, f1; simpl in *.

      clear - H2.

      remember (g2ghost g) as a; remember (g2ghost g0) as b; remember (g2ghost g1) as c.

      revert dependent g1; revert dependent g0; revert dependent g; induction H2; intros; subst.

      * apply g2ghost_inv in Heqc; subst; destruct g; [constructor | discriminate].

      * apply g2ghost_inv in Heqc; subst; destruct g0; [constructor | discriminate].

      * destruct g, g0, g1; inv Heqa; inv Heqb; inv Heqc.

        constructor; [|apply IHghost_join; auto].

        destruct o as [[]|], o0 as [[]|], o1 as [[]|]; inv H; try constructor.

        -- destruct _f, _f0, _f1; inv H4; simpl in *.

           inv H; inv H0.

           inv H; inv H3.

           repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

             subst); constructor; constructor; auto.

        -- destruct _f, _f0; inv H4.

           repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

             subst); constructor; auto.

        -- destruct _f, _f0; inv H4.

           repeat (match goal with H : existT _ _ _ = existT _ _ _ |- _ => apply inj_pair2 in H end;

             subst); constructor; auto.

  Qed.



  Lemma ghost_of_core : forall phi, ghost_of (core phi) = core (ghost_of phi).

  Proof.

    intro; rewrite KSa.core_unsquash.

    unfold ghost_of, KSa.K.unsquash, KSa.K.squash, unsquash, squash.

    destruct (K.unsquash phi); simpl.

    rewrite K.unsquash_squash; simpl.

    setoid_rewrite (pre_rmap_core _ _f). auto.

Qed.



  Definition rmap_age1 (k:rmap) : option rmap :=

    match unsquash k with

    | (O,_) => None

    | (S n,x) => Some (squash (n,x))

    end.



  Definition rmap_unage (k:rmap) : rmap :=

    match unsquash k with

    | (n,x) => squash (S n, x)

    end.



  Lemma rmap_age1_knot_age1 :

    rmap_age1 = @age1 _ K.ageable_knot.

  Proof.

    extensionality x.

    unfold rmap_age1.

    rewrite  K.knot_age1.

    unfold unsquash, squash.

    case (K.unsquash x); simpl; intros.

    destruct n; auto.

    rewrite rmap'2pre_rmap2rmap'.

    f_equal.

  Qed.



  Lemma rmap_age1_eq: @age1 _ ag_rmap = rmap_age1.

  Proof.

   unfold age1. unfold ag_rmap; simpl; auto.

   rewrite rmap_age1_knot_age1; reflexivity.

  Qed.



  Lemma rmap_level_eq: @level rmap ag_rmap = fun x => fst (unsquash x).

  Proof.

    intros.

   extensionality x.  unfold level.  unfold ag_rmap.

   unfold KSa.K.ageable_knot. unfold unsquash.

   rewrite K.knot_level. destruct (K.unsquash x); simpl. auto.

  Qed.



End Rmaps.

Local Close Scope nat_scope.



