Require Import MirrorCore.Lambda.ExprDsimul.

Require Import MirrorCore.Lemma.

Require Import MirrorCharge.RTac.ReifyLemma.

Require Export MirrorCore.RTac.Repeat.

Require Import MirrorCore.RTac.Then.

Require Export MirrorCore.RTac.Try.

Require Export MirrorCore.RTac.First.

Require Import MirrorCore.RTac.Fail.

Require Import MirrorCore.RTac.Simplify.

Require Import MirrorCore.Lambda.RedAll.

Require Import MirrorCore.Lambda.ExprUnify_simul.

Require Import MirrorCore.RTac.RTac.

Require Import MirrorCharge.RTac.Instantiate.

Require Import MirrorCharge.RTac.Intro.

Require Import MirrorCharge.RTac.Apply.

Require Import MirrorCharge.RTac.EApply.

Require Export mc_reify.funcs.

Require Import mc_reify.types.
(* mc_reify.types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)

Require Import MirrorCharge.RTac.Tactics.

Import ExprDenote.

Require Import MirrorCharge.ModularFunc.ILogicFunc.

Require Import MirrorCharge.ModularFunc.BILogicFunc.

Require Import func_defs.
(* func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)

Require Import funcs.

Require Import types.



Ltac cbv_denote g' e :=

eval cbv [

              g'

          reflect_prop reflect Expr_expr_fs RType_typ Typ2_tyArr RSym_sym

                      RSym_Func'



          ExprI.exprD' funcAs  typeof_sym typeof_func

          typeof_func_opt

          type_cast 

          exprD'_simul func_simul

          ExprD.Expr_expr

          ExprDsimul.ExprDenote.exprD'

          

          SymSum.RSym_sum Rcast Relim Rsym eq_sym symD 

          Rcast_val eq_rect_r eq_rect Datatypes.id



          Monad.bind Monad.ret



          OptionMonad.Monad_option



          HList.hlist_hd HList.hlist_tl



          TypesI.typD

          typ2_match typ2 typ2_cast

          typ0_match typ0 typ0_cast 

          

          MirrorCore.VariablesI.Var ExprVariables.ExprVar_expr

          MirrorCore.VariablesI.UVar

          MirrorCore.Lambda.ExprVariables.ExprUVar_expr

          ExprI.exprT_Inj ExprI.exprT_UseV ExprI.exprT_UseU

          exprT_App ExprI.exprT OpenT

          nth_error_get_hlist_nth



          exprT_GetVAs exprT_GetUAs



          ILogicFunc.mkEntails ILogicFunc.mkTrue ILogicFunc.mkFalse

          ILogicFunc.mkAnd ILogicFunc.mkOr ILogicFunc.mkImpl

          ILogicFunc.mkExists ILogicFunc.mkForall



          ILogicFunc.fEntails ILogicFunc.fTrue ILogicFunc.fFalse ILogicFunc.fAnd

          ILogicFunc.fOr ILogicFunc.fImpl ILogicFunc.fExists ILogicFunc.fForall

          ILogicFuncSumL ILogicFuncSumR ILogicFuncExpr

          ILogicFunc.RSym_ilfunc

          MirrorCharge.ModularFunc.ILogicFunc.ILogicFuncInst



          ILogicFunc.funcD ILogicFunc.typ2_cast_quant ILogicFunc.typ2_cast_bin



          BILogicFunc.mkEmp BILogicFunc.mkStar BILogicFunc.mkWand



          BILogicFunc.fEmp BILogicFunc.fStar BILogicFunc.fWand



          BILogicFuncSumL BILogicFuncSumR BILogicFuncExpr

          BILogicFunc.RSym_bilfunc BILogicFunc.BILogicFuncInst



          BILogicFunc.funcD BILogicFunc.typ2_cast_bin



          BILogicFunc.typeof_bilfunc



          LaterFunc.mkLater



          LaterFunc.fLater



          LaterFunc.LaterFuncSumL LaterFunc.LaterFuncSumR LaterFunc.LaterFuncExpr

          LaterFunc.RSym_later_func LaterFunc.LaterFuncInst



          LaterFunc.funcD LaterFunc.typ2_cast'



          LaterFunc.typeof_later_func



          EmbedFunc.mkEmbed



          EmbedFunc.fEmbed



          EmbedFunc.EmbedFuncSumL EmbedFunc.EmbedFuncSumR EmbedFunc.EmbedFuncExpr

          EmbedFunc.RSym_embed_func EmbedFunc.EmbedFuncInst



          EmbedFunc.funcD EmbedFunc.typ2_cast_bin



          EmbedFunc.typeof_embed_func



          BaseFunc.BaseFuncSumL BaseFunc.BaseFuncSumR BaseFunc.BaseFuncExpr



          BaseFunc.BaseFuncInst

          BaseFunc.mkNat BaseFunc.mkString BaseFunc.mkBool

          BaseFunc.mkEq BaseFunc.mkPair



          BaseFunc.fNat BaseFunc.fString BaseFunc.fBool

          BaseFunc.fEq BaseFunc.fPair



          BaseFunc.RSym_BaseFunc



          BaseFunc.typeof_base_func BaseFunc.base_func_eq BaseFunc.base_func_symD

          BaseFunc.RelDec_base_func



          ListFunc.ListFuncSumL ListFunc.ListFuncSumR ListFunc.ListFuncExpr



          ListFunc.ListFuncInst

          ListFunc.mkNil ListFunc.mkCons ListFunc.mkLength

          ListFunc.mkZip ListFunc.mkMap ListFunc.mkFold



          ListFunc.fNil ListFunc.fCons ListFunc.fLength

          ListFunc.fZip ListFunc.fMap ListFunc.fFold



          ListFunc.typeof_list_func ListFunc.list_func_eq ListFunc.list_func_symD

          ListFunc.RelDec_list_func



		  OpenFunc.mkConst OpenFunc.mkAp OpenFunc.mkVar OpenFunc.mkNull OpenFunc.mkStackGet

		  OpenFunc.mkStackSet OpenFunc.mkApplySubst OpenFunc.mkSingleSubst OpenFunc.mkSubst

		  OpenFunc.mkTruncSubst

		

		  OpenFunc.fConst OpenFunc.fAp OpenFunc.fVar OpenFunc.fNull OpenFunc.fStackGet

		  OpenFunc.fApplySubst OpenFunc.fSingleSubst OpenFunc.fSubst OpenFunc.fTruncSubst

		

		  OpenFunc.OpenFuncSumL OpenFunc.OpenFuncSumR OpenFunc.OpenFuncExpr

		  OpenFunc.OpenFuncInst

		

		  OpenFunc.typeof_open_func OpenFunc.RSym_OpenFunc

		  OpenFunc.typ2_cast_bin OpenFunc.typ3_cast_bin

		  OpenFunc.RelDec_open_func

		

		  OpenFunc.RSym_OpenFunc_obligation_1



          BaseType.tyPair BaseType.tyNat BaseType.tyString BaseType.tyBool

          BaseType.btPair BaseType.btNat BaseType.btBool BaseType.btString



          ListType.tyList ListType.btList



          SubstType.tyVar SubstType.tyVal SubstType.tySubst

          SubstType.stSubst



constD

z_opD

int_opD

valueD

evalD

otherD

sepD

dataD

typD

funcs.funcD

smxD



typeof_func

typeof_const

typeof_z_op

typeof_int_op

typeof_value

typeof_eval

typeof_other

typeof_sep

typeof_data

typeof_smx



          goalD propD exprD'_typ0 exprD split_env



          amap_substD

          substD

          FMapSubst.SUBST.raw_substD

          UVarMap.MAP.fold

          FMapPositive.PositiveMap.fold

          FMapPositive.PositiveMap.xfoldi

          FMapPositive.append

          UVarMap.MAP.from_key

          pred

          plus

          Pos.to_nat

          Pos.iter_op

          app

          HList.hlist_app

          Quant._foralls

          Quant._exists

          goalD_Prop



typ_eq_dec typ_rec typ_rect sumbool_rec sumbool_rect eq_rec eq_rect eq_rec_r eq_rect_r False_ind eq_ind expr.eqb_type expr.eqb_intsize expr.eqb_signedness expr.eqb_attr

expr.eqb_option expr.eqb_floatsize Bool.eqb BinNat.N.eqb expr.eqb_calling_convention expr.eqb_ident

f_equal False_rect False_rec



SymEnv.funcD

SymEnv.fdenote

SymEnv.RSym_func

SymEnv.func_typeof_sym

SymEnv.ftype

FMapPositive.PositiveMap.find

elem_ctor

Tactics.elem_ctor



Ext

func_defs.reflect



exprD_Prop

Tactics.exprD_Prop



goalD_Prop

Tactics.exprD_Prop



goalD_aux

Tactics.goalD_aux

Typ0_tyProp



func_defs.RSym_ilfunc

func_defs.ilops

ILogic.lforall

ILogic.ILogicOps_Prop

ILogic.lentails

ILogicOps_mpred



ILogic.land



reptyp_reptype

reptype_reptyp

typD_reptyp_reptype

data_at_lemmas.type_mut

proj1T

proj2T

data_at_lemmas.is_Fnil

ModularFunc.ILogicFunc.typeof_func

reptyp

reptyp_structlist

reptyp_unionlist



 exportclight.Clightdefs.tvoid

 exportclight.Clightdefs.tschar

 exportclight.Clightdefs.tuchar

 exportclight.Clightdefs.tshort

 exportclight.Clightdefs.tushort

 exportclight.Clightdefs.tint

 exportclight.Clightdefs.tuint

 exportclight.Clightdefs.tbool

 exportclight.Clightdefs.tlong

 exportclight.Clightdefs.tulong

 exportclight.Clightdefs.tfloat

 exportclight.Clightdefs.tdouble

 exportclight.Clightdefs.tptr

 exportclight.Clightdefs.tarray



eq_ind_r

eq_ind

          ] in e.



Ltac cbv_denote_goal :=

match goal with

[ |- ?G] => let x := cbv_denote hd G in change x

end.



Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)



