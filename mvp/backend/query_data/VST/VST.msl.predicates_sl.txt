

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.ageable.
(* VST.msl.ageable:
Require Import VST.msl.base.
  Require Coq.funind.Recdef.

Local Open Scope nat_scope.

Record ageable_facts (A:Type) (level: A -> nat) (age1:A -> option A)  :=
{ af_unage : forall x':A, exists x, age1 x = Some x'
; af_level1 : forall x, age1 x = None <-> level x = 0
; af_level2 : forall x y, age1 x = Some y -> level x = S (level y)
}.

Arguments af_unage [A] [level] [age1] _ _.
Arguments af_level1 [A] [level] [age1] _ _.
Arguments af_level2 [A] [level] [age1] _ _ _ _.

Class ageable (A:Type) := mkAgeable
{ level : A -> nat
; age1 : A -> option A
; age_facts : ageable_facts A level age1
}.

Definition age {A} `{ageable A} (x y:A) := age1 x = Some y.

Lemma af_wf {A} `{ageable A} :
 well_founded (fun x y => age y x).
Arguments af_wf [A] _ _.

Definition age_induction {A} `{ageable A} :=
  well_founded_induction (af_wf _).

Definition fashionR {A1} `{ageable A1} {A2}`{ageable A2} (x:A1) (y: A2) : Prop :=
  level x = level y.

Lemma fashionR_refl {A} `{ageable A} : reflexive _ fashionR.

Lemma fashionR_trans {A} `{ageable A} {B} `{ageable B} {C} `{ageable C} :
    forall (x: A) (y: B) (z: C), fashionR x y -> fashionR y z -> fashionR x z.

Lemma fashionR_sym {A} `{ageable A} {B} `{ageable B}:
   forall (x: A) (y: B), fashionR x y -> fashionR y x.

Lemma age_level {A} `{ageable A} : forall (x y:A),
  age x y -> level x = S (level y).

Lemma age1_level0 {A} `{ageable A} : forall (x:A),
  age1 x = None <-> level x = 0.

  Theorem level_level' : forall x:A, level x = level' x.
End level'.

Lemma levelS_age1 {A} `{ageable A} : forall (x:A) n,
  level x = S n ->
  exists y, age1 x = Some y.

Lemma age1_levelS {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  exists n, level x = S n.

Lemma age1_level0_absurd {A} `{ageable A} : forall (x y:A),
  age1 x = Some y ->
  level x = 0 ->
  False.

Lemma age1None_levelS_absurd {A} `{ageable A} : forall (x:A) n,
  age1 x = None ->
  level x = S n ->
  False.

Section RtRft.
  Variable A:Type.
  Variable R:relation A.

  Let Rt := clos_trans A R.
  Let Rft := clos_refl_trans A R.

  Lemma Rt_Rft : forall x y, Rt x y -> Rft x y.

  Lemma Rt_Rft_trans : forall x y z, Rt x y -> Rft y z -> Rt x z.

  Lemma Rft_Rt_trans : forall x y z, Rft x y -> Rt y z -> Rt x z.

  Lemma transpose_clos_trans : forall A R x y,
    clos_trans A (transp A R) x y <-> transp A (clos_trans A R) x y.
End RtRft.

Hint Resolve rt_refl.

Definition laterR {A} `{ageable A} : relation A := clos_trans A age.
Definition necR   {A} `{ageable A} : relation A := clos_refl_trans A age.

Require Coq.Wellfounded.Wellfounded.
Lemma laterR_wf {A} `{ageable A} :
  well_founded (transp _ laterR).

Definition laterR_induction {A} `{ageable A} :=
  @well_founded_induction A (transp A laterR) laterR_wf.

Lemma age_irreflexive {A}  `{ageable A}: forall x, age x x -> False.

Lemma laterR_irreflexive {A} `{HA: ageable A} : forall x, laterR x x -> False.

Lemma nec_refl_or_later {A} `{ageable A} : forall x y,
  necR x y -> x = y \/ laterR x y.

Lemma necR_antisym {A} `{ageable A} : forall x y,
  necR x y -> necR y x -> x = y.

Lemma age_later_nec {A} `{HA: ageable A} : forall x y z,
  age x y ->
  laterR x z ->
  necR y z.

Lemma necR_level {A} `{X: ageable A} : forall (x y:A),
  necR x y ->
  level x >= level y.

Lemma laterR_level {A} `{X: ageable A} : forall (x y:A),
  laterR x y ->
  level x > level y.

Section NAT_AGEABLE.

  Definition natLevel (x:nat) : nat := x.
  Definition natAge1 (x:nat) : option nat :=
    match x with
    | 0 => None
    | S n => Some n
    end.
  Definition natUnage (x:nat) : nat := S x.

  Lemma ag_nat_facts :
    ageable_facts nat natLevel natAge1.

  Definition ag_nat : ageable nat :=
    mkAgeable nat natLevel natAge1 ag_nat_facts.

  Lemma nec_nat : forall (n n':nat),
    @necR _ ag_nat n n' <-> n' <= n.

  Lemma later_nat : forall (n n':nat),
    @laterR _ ag_nat n n' <-> n' < n.

End NAT_AGEABLE.

Lemma laterR_level' {A} `{H : ageable A}: forall {w1 w2: A}, laterR w1 w2 -> @laterR _ ag_nat (level w1) (level w2).

Lemma necR_nat {A} `{H : ageable A}:
    forall {x y: A}, necR x y -> @necR nat ag_nat (level x) (level y).

Section BIJECTION.
  Variable A B : Type.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.

  Let levelB (x:B) : nat :=
    level (bij_g _ _ bijAB x).

  Let age1B  (x: B) : option B :=
     match age1 (bij_g _ _ bijAB x) with
     | Some y => Some (bij_f _ _ bijAB y)
     | None => None
     end.

  Let ageB (x y: B) :=age1B x = Some y.

  Lemma age_bij_unage :
    forall x', exists x, age1B x = Some x'.

  Lemma age_bij_level1 :
    forall x, age1B x = None <-> levelB x = 0.

  Lemma age_bij_level2 :
    forall x y, age1B x = Some y -> levelB x = S (levelB y).

  Lemma ag_bij_facts : ageable_facts B levelB age1B.

  Definition ag_bij : ageable B :=
    mkAgeable B levelB age1B ag_bij_facts.
End BIJECTION.

Section PROD.
  Variable A B : Type.
  Variable agA: ageable A.

  Let levelAB (x:prod A B) := level (fst x).
  Let age1AB (x:prod A B) :=
    match age1 (fst x) with
    | None => None
    | Some a' => Some (a',snd x)
    end.

  Lemma ag_prod_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod :=
    mkAgeable (prod A B) levelAB age1AB ag_prod_facts.

  Lemma prod_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod (n,x) (n',x') <-> necR n n' /\ x = x'.

  Lemma prod_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod (n,x) (n',x') <-> laterR n n' /\ x = x'.

End PROD.

Section PROD'.
  Variable A B : Type.
  Variable agB: ageable B.

  Let levelAB (x:prod A B) := level (snd x).
  Let age1AB (x:prod A B) :=
    match age1 (snd x) with
    | None => None
    | Some a' => Some (fst x, a')
    end.

  Lemma ag_prod'_facts : ageable_facts (prod A B) levelAB age1AB.

  Definition ag_prod' :=
    mkAgeable (prod A B) levelAB age1AB ag_prod'_facts.

  Lemma prod'_nec_split : forall n x n' x',
    @necR (prod A B) ag_prod' (x,n) (x',n') <-> necR n n' /\ x = x'.

  Lemma prod'_later_split : forall n x n' x',
    @laterR (prod A B) ag_prod' (x,n) (x',n') <-> laterR n n' /\ x = x'.

End PROD'.

Fixpoint composeOptN (A: Type) (f: A -> option A)
         (n: nat) (w: A) {struct n} : option A :=
 match n  with
 | S n' => match f w with Some w' => composeOptN A f n' w' | None => None end
 | O => Some w
 end.
Arguments composeOptN [A] _ _ _.

Definition ageN {A} `{ageable A}: nat -> A -> option A := composeOptN age1.

Lemma ageN1  {A} `{ageable A}: ageN 1 = age1.

Lemma ageN_compose {A} `{agA : ageable A}:
 forall a b c phi1 phi2 phi3,ageN a phi1 = Some phi2 ->
       ageN b phi2 = Some phi3 ->  (a+b=c)%nat ->  ageN c phi1 = Some phi3.

Lemma ageN_compose' {A} `{agA : ageable A}:
  forall a b phi1 phi3,
   ageN (a+b)%nat phi1 = Some phi3 -> exists phi2, ageN a phi1 = Some phi2 /\ ageN b phi2 = Some phi3.

Lemma necR_evolve {A} `{agA : ageable A}:
    necR = fun (phi phi': A) => exists n, ageN n phi = Some phi'.

Lemma age_noetherian  {A} `{ageable A}: forall phi, exists n, ageN n phi = None.

Lemma predicate_max:
  forall (F: nat -> Prop) (Fdec: forall n, {F n}+{~ F n}) n,
  F 0%nat ->
  ~ F n ->
  exists i, F i /\ (i<n)%nat /\ ~ F (S i).

Lemma age_noetherian'  {A} `{agA : ageable A}:
       forall phi, exists! n, exists phi', ageN n phi = Some phi' /\ age1 phi' = None.

Lemma ageable_ext:
   forall A (B C: ageable A),
      @age1 _ B = @age1 _ C -> @level _ B = @level _ C -> B=C.

Lemma necR_linear {A} `{H : ageable A}:
  forall {a b c}, necR a b -> necR a c -> necR b c \/ necR c b.

Lemma necR_linear' {A} `{H : ageable A}:
   forall {a b c}, necR a b -> necR a c -> level b = level c -> b=c.

Lemma laterR_necR {A} `{agA : ageable A}:
  forall {x y}, laterR x y -> necR x y.

Lemma necR_refl {A} `{H : ageable A}:
  forall phi, necR phi phi.

Hint Resolve @necR_refl.

Lemma necR_trans  {A} `{H : ageable A}:
  forall phi1 phi2 phi3, necR phi1 phi2 -> necR phi2 phi3 -> necR phi1 phi3.

Lemma necR_laterR {A} `{agA : ageable A}:
  forall w1 w2 w3, necR w1 w2 -> laterR w2 w3 -> laterR w1 w3. *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)

Require Import VST.msl.sepalg_generators.
(* VST.msl.sepalg_generators:
Lemma join_equiv_refl: forall A (v: A), @join A (Join_equiv A) v v v.
End SepAlgFun.

Existing Instance Join_fun.
Existing Instance Perm_fun.
Existing Instance Sep_fun.
Existing Instance Sing_fun.
Existing Instance Canc_fun.
Existing Instance Disj_fun.

Section SepAlgPi.
  Variable I:Type.
  Variable Pi: I -> Type.
  Variable pi_J: forall i, Join (Pi i).
  Variable PA:  forall i, Perm_alg (Pi i).

  Let P := forall i:I, Pi i.

End SepAlgPi.
Existing Instance Join_pi.
Existing Instance Perm_pi.
Existing Instance Sep_pi.
Existing Instance Canc_pi.
Existing Instance Disj_pi.

Section SepAlgSigma.
  Variable I:Type.
  Variable Sigma: I -> Type.
  Variable JOIN: forall i, Join (Sigma i).
  Variable PA: forall i, Perm_alg (Sigma i).
  Let S := sigT Sigma.

End sa_list.
Existing Instance Join_list.
Existing Instance Perm_list.
Existing Instance Sep_list.
Existing Instance Canc_list.
Existing Instance Disj_list.

Definition raw_join_hom A B (j1: A -> A -> A -> Prop) (j2: B -> B -> B -> Prop) (f:A ->B) :=
  forall x y z,
    j1 x y z ->
    j2 (f x) (f y) (f z).
Arguments raw_join_hom [A B] _ _ _.

Definition join_hom {A} {JA: Join A} {B} {JB: Join B} (f:A ->B) :=
  forall x y z,
    join x y z ->
    join (f x) (f y) (f z).

Section sa_preimage.
  Variables A B:Type.
  Variable B_J: Join B.
   Variable PA: Perm_alg B.

  Variable f:A -> B.
  Variable f':B -> A.

  Hypothesis Hf'_f : forall x, f' (f x) = x.
  Hypothesis Hf_f' : join_hom (f oo f').

  Lemma f_inj : forall x y : A,  f x = f y -> x = y.

End sa_preimage.

Existing Instance Join_preimage.
Existing Instance Perm_preimage.
Existing Instance Sep_preimage.
Existing Instance Sing_preimage.
Existing Instance Canc_preimage.
Existing Instance Disj_preimage.

Section SepAlgBijection.
  Variables (A: Type) (Ja: Join A)(PAa: Perm_alg A).
  Variable B:Type .

  Variable bij : bijection A B.
  Instance Join_bij: Join B := fun (x y z : B) => join (bij_g _ _ bij x) (bij_g _ _ bij y) (bij_g _ _ bij z).

  Lemma Perm_bij  : Perm_alg B.

 Lemma Sing_bij {SAa: Sep_alg A}{SingA: Sing_alg A} : Sing_alg B.

End SepAlgBijection.
Existing Instance Join_bij.
Existing Instance Perm_bij.
Existing Instance Sep_bij.
Existing Instance Sing_bij.
Existing Instance Canc_bij.
Existing Instance Disj_bij. *)

Require Import VST.msl.age_sepalg.
(* VST.msl.age_sepalg:
Require Import VST.msl.base.
Require Import VST.msl.ageable.
Require Import VST.msl.sepalg.
Require Import VST.msl.sepalg_generators.

Class Age_alg (A:Type) {JOIN: Join A}{as_age : ageable A} :=
mkAge {
  age1_join : forall x {y z x'}, join x y z -> age x x' ->
    exists y':A, exists z':A, join x' y' z' /\ age y y' /\ age z z'
; age1_join2 : forall x {y z z'}, join x y z -> age z z' ->
    exists x':A, exists y':A, join x' y' z' /\ age x x' /\ age y y'
; unage_join : forall x {x' y' z'}, join x' y' z' -> age x x' ->
    exists y:A, exists z:A, join x y z /\ age y y' /\ age z z'
; unage_join2 : forall z {x' y' z'}, join x' y' z' -> age z z' ->
    exists x:A, exists y:A, join x y z /\ age x x' /\ age y y'
}.

Lemma age1_None_joins {A}{JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2, joins phi1 phi2 -> age1 phi1 = None -> age1 phi2 = None.

Lemma age1_joins_eq {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A}: forall phi1 phi2,
        joins phi1 phi2 ->
        forall phi1', age1 phi1 = Some phi1' ->
        forall phi2', age1 phi2 = Some phi2' ->
        joins phi1' phi2'.

Section BIJECTION.
  Variables A B : Type.
  Variable JA: Join A.
  Variable PA: Perm_alg A.
  Variable ag: ageable A.
  Variable bijAB: bijection A B.
  Variable asa : Age_alg A.

  Existing Instance PA.

  Instance agB : ageable B := (ag_bij _ _ ag bijAB).

  Theorem asa_bijection : @Age_alg B (Join_bij _ _ _ bijAB) agB.
End BIJECTION.

Section PROD.
  Variable A : Type.
  Variable J_A: Join A.
  Variable saA : Perm_alg A.
  Variable agA : ageable A.
  Variable B: Type.
  Variable J_B: Join B.
  Variable saB : Perm_alg B.
  Variable asa : Age_alg A.

  Theorem asa_prod : @Age_alg (prod A B) _ (ag_prod A B agA).
End PROD.

Section PROD'.
  Variable A : Type.
  Variable J_A: Join A.
  Variable saA : Perm_alg A.
  Variable B: Type.
  Variable J_B: Join B.
  Variable saB : Perm_alg B.
  Variable agB : ageable B.
  Variable asb : Age_alg B.

  Theorem asa_prod' : @Age_alg (prod A B) _ (ag_prod' A B agB).
End PROD'.

Lemma joins_fashionR {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{XA: Age_alg A} : forall x y,
  joins x y -> fashionR x y.

Lemma comparable_fashionR {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A} {XA: Age_alg A} : forall x y,
  comparable x y -> fashionR x y.

Lemma age_identity {A} `{asaA: Age_alg A}: forall phi phi', age phi phi'->
    identity phi -> identity phi'.

Lemma age_comparable {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} {agA: ageable A}{asaA: Age_alg A}:
    forall phi1 phi2 phi1' phi2', age phi1 phi1' -> age phi2 phi2' ->
      comparable phi1 phi2 -> comparable phi1' phi2'.

  Lemma asa_nat : @Age_alg nat (Join_equiv nat) ag_nat.

Lemma nec_identity {A} `{asaA: Age_alg A}: forall phi phi', necR phi phi'->
    identity phi -> identity phi'.

Lemma nec_join2 {A} `{asaA : Age_alg A}: forall {x y z z' : A},
       join x y z ->
       necR z z' ->
       exists x',
         exists y',
           join x' y' z' /\ necR x x' /\ necR y y'.

Lemma nec_join {A} `{asaA : Age_alg A}: forall {x y z x' : A},
       join x y z ->
       necR x x' ->
       exists y' ,
         exists z' ,
           join x' y' z' /\ necR y y' /\ necR z z'.

Lemma nec_join4 {A} `{asaA : Age_alg A}: forall z x' y' z' : A,
       join x' y' z' ->
       necR z z' ->
       exists x,
         exists y,
           join x y z /\ necR x x' /\ necR y y'.

Lemma join_level {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{AgeA: Age_alg A}:
  forall x y z, join x y z -> level x = level z /\ level y = level z.

 Lemma level_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
     forall m:A, level (core m) = level m.

Lemma age_core_eq {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y x' y', age x x' -> age y y' -> core x = core y -> core x' = core y'.

Lemma age_twin {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:
  forall phi1 phi2 n phi1',
  level phi1 = level phi2 ->
  ageN n phi1 = Some phi1' ->
  exists phi2', ageN n phi2 = Some phi2' /\ level phi1' = level phi2'.

Lemma age1_join_eq {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3,
        join phi1 phi2 phi3 ->
        forall phi1', age1 phi1 = Some phi1' ->
        forall phi2', age1 phi2 = Some phi2' ->
        forall phi3', age1 phi3 = Some phi3' ->
        join phi1' phi2' phi3'.

Lemma strong_nat_ind (P : nat -> Prop) (IH : forall n, (forall i, lt i n -> P i) -> P n) n : P n.

Lemma age_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y : A, age x y -> age (core x) (core y).

Lemma necR_core {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{agA: ageable A}{AgeA: Age_alg A}:
  forall x y : A, necR x y -> necR (core x) (core y).

Definition relation_mul {A: Type} (R0 R1: relation A) (x y: A) := exists z, R0 x z /\ R1 z y.

Fixpoint relation_power {A: Type} (n: nat) (R: relation A) :=
  match n with
  | O => eq
  | S n0 => relation_mul R (relation_power n0 R)
  end.

Fixpoint partial_fun_power {A: Type} (n: nat) (f: A -> option A) (x: A) :=
  match n with
  | O => Some x
  | S n0 => match f x with
            | Some fx => partial_fun_power n0 f fx
            | None => None
            end
  end.

Lemma laterR_power_age: forall {A:Type} {agA:ageable A} (x y: A),
  laterR x y <-> (exists n, relation_power (S n) age x y).

Lemma necR_power_age: forall {A:Type} {agA:ageable A} (x y: A),
  necR x y <-> (exists n, relation_power n age x y).

Lemma power_age_age1: forall {A:Type} {agA:ageable A} n x y,
  relation_power n age x y <-> partial_fun_power n age1 x = Some y.

Lemma power_age1_level_small: forall {A:Type} {agA:ageable A} n x,
  partial_fun_power n age1 x = None <-> level x < n.

Lemma power_age_core: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x y: A) n,
  relation_power n age x y -> relation_power n age (core x) (core y).

Lemma power_age_core_eq: forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y y': A) n,
  relation_power n age x x' -> relation_power n age y y' -> core x = core y -> core x' = core y'.

Lemma levelS_age {A: Type} {agA: ageable A} : forall (x:A) n,
  S n = level x ->
  exists y, age x y /\ n = level y.

Lemma clos_refl_trans_addone: forall (A : Type) (R : relation A) (x y z: A), R x y -> clos_refl_trans A R y z -> clos_refl_trans A R x z.

Lemma necR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), necR x x' -> level x = level y -> exists y', (necR y y' /\ level x' = level y').

Lemma laterR_same_level: forall {A:Type} {agA:ageable A} (x y x': A), laterR x x' -> level x = level y -> exists y', (laterR y y' /\ level x' = level y').

Lemma power_age_parallel: forall {A:Type} {agA:ageable A} (x x' y: A) n,
  level x = level y ->
  relation_power n age x x' ->
  exists y', relation_power n age y y'.

Lemma power_age_parallel': forall {A:Type} {agA:ageable A} {JA: Join A} {PA: Perm_alg A} {SaA: Sep_alg A} {XA: Age_alg A} (x x' y: A) n,
  core x = core y ->
  relation_power n age x x' ->
  exists y', relation_power n age y y' /\ core x' = core y'. *)

Require Import VST.msl.predicates_hered.
(* VST.msl.predicates_hered:
Require Import VST.msl.base.
Require Import VST.msl.ageable.

Delimit Scope pred with pred.
Local Open Scope pred.

Definition hereditary {A} (R:A->A->Prop) (p:A->Prop) :=
  forall a a':A, R a a' -> p a -> p a'.

Definition pred (A:Type) {AG:ageable A} :=
  { p:A -> Prop | hereditary age p }.

Bind Scope pred with pred.

Definition app_pred {A} `{ageable A} (p:pred A) : A -> Prop := proj1_sig p.
Definition pred_hereditary `{ageable} (p:pred A) := proj2_sig p.
Coercion app_pred : pred >-> Funclass.
Global Opaque pred.

Hint Resolve @pred_hereditary.

Lemma nec_hereditary {A} `{ageable A} (p: A -> Prop) : hereditary age p ->
  forall a a':A, necR a a' -> p a -> p a'.

Lemma pred_nec_hereditary {A} `{ageable A} (p:pred A) :
  forall a a':A, necR a a' -> p a -> p a'.

Program Definition mkPred {A} `{ageable A} (p:A -> Prop) : pred A :=
  fun x => forall x', necR x x' -> p x'.

Definition derives {A} `{ageable A} (P Q:pred A) := forall a:A, P a -> Q a.
Arguments derives [A] [H] _ _.

Definition valid_rel {A} `{ageable A} (R:relation A) : Prop :=
  commut A age R /\ commut A R age.

Definition modality {A} `{ageable A} := { R:relation A | valid_rel R }.

Definition app_mode {A} `{ageable A} (m:modality) : A -> A -> Prop := proj1_sig m.
Definition mode_valid {A} `{ageable A} (m:modality) := proj2_sig m.
Global Opaque modality.
Coercion app_mode : modality >-> Funclass.

Lemma valid_rel_commut_later1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A laterR R.

Lemma valid_rel_commut_later2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R laterR.

Lemma valid_rel_commut_nec1 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A necR R.

Lemma valid_rel_commut_nec2 {A} `{ageable A} : forall R,
  valid_rel R ->
  commut A R necR.

Lemma valid_rel_age {A} `{ageable A} : valid_rel age.

Lemma valid_rel_later {A} `{ageable A} : valid_rel laterR.

Lemma valid_rel_nec {A} `{ageable A} : valid_rel necR.

Definition ageM {A} `{ageable A} : modality
  := exist _ age valid_rel_age.
Definition laterM {A} `{ageable A} : modality
  := exist _ laterR valid_rel_later.

Hint Resolve rt_refl rt_trans t_trans.
Hint Unfold necR.
Obligation Tactic := unfold hereditary; intuition;
    first [eapply pred_hereditary; eauto; fail | eauto ].

Program Definition prop {A} `{ageable A}  (P: Prop) : pred A := (fun _  => P).

Definition TT {A} `{ageable A}: pred A := prop True.
Definition FF  {A} `{ageable A}: pred A := prop False.

Program Definition imp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => forall a':A, necR a a' -> P a' -> Q a'.
Program Definition orp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a \/ Q a.

Program Definition andp {A} `{ageable A} (P Q:pred A) : pred A :=
   fun a:A => P a /\ Q a.

Program Definition allp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => forall b, f b a.

Program Definition exp {A} `{ageable A} {B: Type} (f: B -> pred A) : pred A
  := fun a => exists b, f b a.

Program Definition box {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => forall a', M a a' -> P a'.

Program Definition diamond {A} `{ageable A} (M:modality) (P:pred A) : pred A :=
  fun a:A => exists a', M a' a /\ P a'.

Definition boxy {A} `{ageable A} (m: modality) (p: pred A): Prop :=  box m p = p.

Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).
Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.
Infix "||" := orp (at level 50, left associativity) : pred.
Infix "&&" := andp (at level 40, left associativity) : pred.
Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.
Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.

Notation "'|>' e" := (box laterM e) (at level 30, right associativity): pred.
Notation "'!!' e" := (prop e) (at level 25) : pred.

Lemma modus_ponens {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- (P --> Q) ->
  X |-- Q.

Lemma andp_right {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P ->
  X |-- Q ->
  X |-- P && Q.

  Lemma pred_ext' {A} `{ageable A}: forall (p1 p2:pred A),
    app_pred p1 = app_pred p2 ->
    p1 = p2.

Lemma pred_ext : forall A `{ageable A} (P Q:pred A),
  derives P Q -> derives Q P -> P = Q.

Lemma andp_dup {A}{agA: ageable A}: forall P: pred A, P && P = P.

Lemma andp_left1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Lemma andp_left2{A}{agA: ageable A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Lemma orp_left{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Lemma orp_right1{A}{agA: ageable A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Lemma orp_right2{A}{agA: ageable A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Lemma derives_trans {A}`{ageable A}:
    forall P Q R: pred A, P |-- Q -> Q |-- R -> P |-- R.

Lemma exp_right:
  forall {B A: Type}{agA: ageable A}(x:B) p (q: B -> pred A),
    p |-- q x ->
    p |-- exp q.

Lemma exp_left:
  forall {B A: Type}{agA: ageable A}(p: B -> pred A) q,
  (forall x, p x |-- q) ->
   exp p |-- q.

Lemma and1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> P.

Lemma and2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P && Q --> Q.

Lemma and3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Lemma or1 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- P --> P || Q.

Lemma or2 {A} `{ageable A} : forall (X P Q:pred A),
  X |-- Q --> P || Q.

Lemma or3 {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Lemma TTrule {A} `{ageable A} : forall X P,
  X |-- P --> TT.

Lemma FFrule {A} `{ageable A} : forall X P,
  X |-- FF --> P.

Lemma distribution {A} `{ageable A} : forall (X P Q R:pred A),
  X |-- P && (Q || R) --> (P && Q) || (P && R).

Lemma imp_andp_adjoint {A} `{ageable A} : forall (P Q R:pred A),
  (P && Q) |-- R <-> P |-- (Q --> R).

Lemma box_e0 {A} `{ageable A}: forall (M: modality) Q,
            reflexive _ M -> box M Q  |-- Q.
Arguments box_e0 [A] _ _ _ _ _ _.

Lemma boxy_i {A} `{ageable A}:
  forall (Q: pred A) (M: modality),
    reflexive _ M ->
    (forall w w', M w w' -> Q w -> Q w') ->
    boxy M Q.

Lemma box_diamond {A} `{ageable A} : forall M (P Q:pred A),
  (diamond M P) |-- Q <-> P |-- (box M Q).

Lemma ruleNec {A} `{ageable A} : forall M (P:pred A),
  derives TT P ->
  derives TT (box M P).

Lemma axiomK {A} `{ageable A}: forall M (P Q:pred A),
  (box M (P --> Q)) |-- (box M P --> box M Q).

Lemma box_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  box M P |-- box M Q.

Lemma diamond_positive {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->
  diamond M P |-- diamond M Q.

Lemma box_refl_trans {A} `{ageable A}: forall (m:modality) p,
  reflexive _ m ->
  transitive _ m ->
  box m (box m p) = box m p.

Lemma box_and {A} `{ageable A}: forall R (P Q:pred A),
  box R (P && Q) = box R P && box R Q.

Lemma box_all {A} `{ageable A} : forall B R (F:B -> pred A),
  box R (allp F) = ALL x:B, box R (F x).

Lemma box_ex {A} `{ageable A} : forall B R (F:B->pred A),
  EX x:B, box R (F x) |-- box R (exp F).

Lemma box_or {A} `{ageable A} : forall R (P Q:pred A),
   box R P || box R Q |-- box R (P || Q).

Lemma diamond_or {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P || Q) = diamond R P || diamond R Q.

Lemma diamond_ex {A} `{ageable A} : forall B R (F:B -> pred A),
  diamond R (exp F) = EX x:B, diamond R (F x).

Lemma diamond_and {A} `{ageable A} : forall R (P Q:pred A),
  diamond R (P && Q) |-- diamond R P && diamond R Q.

Lemma diamond_all {A} `{ageable A} : forall B R (F:B->pred A),
  diamond R (allp F) |-- ALL x:B, diamond R (F x).

Lemma later_age {A} `{ageable A} : forall P,
  |>P = box ageM P.

Lemma now_later {A} `{ageable A} : forall P,
  P |-- |>P.

Lemma now_later2 {A} `{ageable A} : forall G P,
  G |-- P ->
  G |-- |>P.

Lemma goedel_loeb {A} `{ageable A} : forall (P Q:pred A),
  Q && |>P |-- P ->
  Q |-- P.

Lemma loeb {A} `{ageable A} : forall (P:pred A),
     |>P |-- P    ->     TT |-- P.

Lemma later_commute_dia {A} `{ageable A} : forall M (P:pred A),
  diamond M (|> P) |-- |> (diamond M P).

Lemma later_commute {A} `{ageable A} : forall M (P:pred A),
  box M (|>P) = |>(box M P).

Lemma later_and {A} `{ageable A} : forall P Q,
  |>(P && Q) = |>P && |> Q.

Lemma later_or {A} `{ageable A} : forall (P Q:pred A),
  |>(P || Q) = |>P || |>Q.

Lemma later_ex {A} `{ageable A} : forall B (F:B->pred A),
  B ->
  |>(exp F) = EX x:B, |>(F x).

Lemma later_ex'' {A} `{ageable A} : forall B (F:B->pred A),
  |>(exp F) |-- (EX x:B, |>(F x)) || |> FF.

Lemma later_imp {A} `{ageable A} : forall P Q,
  |>(P --> Q) = |>P --> |>Q.

Lemma TT_boxy {A} `{ageable A} : forall M,
  boxy M TT.

Lemma positive_boxy {A} `{ageable A} : forall P Q M,
  boxy M P ->
  P |-- Q ->
  P |-- box M Q.

Lemma forallI {A} `{ageable A} : forall A G X,
  (forall x:A, G |-- X x) ->
  G |-- allp X.

Lemma TT_and {A} `{ageable A} : forall P,
  TT && P = P.

Lemma andp_comm {A} `{ageable A} : forall P Q,
  P && Q = Q && P.

Lemma andp_assoc {A} `{ageable A} : forall P Q R,
  (P && Q) && R = P && (Q && R).

Lemma ex_and : forall {A} `{ageable A} B (P:B->pred A) Q,
  (exp P) && Q = EX x:B, P x && Q.

Lemma FF_and : forall {A} `{ageable A} (P:pred A),
  FF && P = FF.

Lemma boxy_e {A} `{H : ageable A}: forall (M: modality) P,  boxy M P ->
           forall w w', app_mode M w w' -> P w -> P w'.

Lemma boxy_andp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P && Q).

Hint Resolve @boxy_andp.

Lemma boxy_disjunction {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Hint Resolve @boxy_disjunction.

Lemma boxy_exp {A} `{agA : ageable A}:
    forall (M: modality) T (P: T -> pred A),
     reflexive _ (app_mode M) ->
     (forall x, boxy M (P x)) -> boxy M (exp P).

Hint Resolve @boxy_exp.

Lemma boxy_prop {A} `{H : ageable A}:  forall (M: modality) P, reflexive _ (app_mode M) -> boxy M (prop P).

Lemma boxy_TT {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M TT.

Lemma boxy_FF {A} `{H : ageable A}:  forall (M: modality), reflexive _ (app_mode M) -> boxy M FF.

Hint Resolve @boxy_TT.
Hint Resolve @boxy_FF.

Lemma TT_i  {A} `{ageable A}: forall w: A,  app_pred TT w.

Hint Resolve @TT_i.

Lemma prop_andp_left {A}{agA: ageable A}: forall (P: Prop) Q R, (P -> Q |-- R) -> !!P && Q |-- R.

Lemma prop_andp_right {A}{agA: ageable A}: forall (P: Prop) Q R, P -> Q |-- R -> Q |-- !!P && R.

Lemma prop_true_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A), P -> (!! P && Q = Q).

Lemma prop_false_andp:
  forall (P: Prop) A `{ageable A} (Q: pred A),
   ~P -> !! P && Q = FF.

Lemma prop_andp_e {A} `{ageable A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Lemma prop_andp_i {A} `{ageable A}:  forall P Q (w:A), P /\ app_pred Q w -> (!! P && Q) w.

Lemma later_derives {A} `{agA : ageable A}: forall {P Q}, (P |-- Q) -> (|> P |-- |> Q).

Lemma boxy_allp {A} `{agA : ageable A}:
  forall (M: modality) (B: Type) F,
     reflexive _ (app_mode M) ->
     (forall (x:B), boxy M (F x)) -> boxy M (allp F).
Hint Resolve @boxy_allp.

Lemma later_allp {A} `{agA : ageable A}:
       forall B P, |> (allp P) = allp (fun x:B => |> (P x)).

Lemma later_prop {A} `{agA : ageable A}:
       forall P: Prop, |> (prop P) |-- prop P || |> FF.

Lemma box_derives {A} `{ageable A} : forall M (P Q:pred A),
  P |-- Q ->  box M P |-- box M Q.

Lemma allp_derives:
       forall {A: Type} `{agA: ageable A} (B: Type) (P Q: B -> pred A),
               (forall x:B, P x |-- Q x) -> (allp P |-- allp Q).

Lemma forall_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (ALL x : B, P x) <--> (ALL x: B, Q x) .

Lemma exists_pred_ext  {A} `{agA : ageable A}: forall B (P Q: B -> pred A),
 (ALL x : B, (P x <--> Q x)) |-- (EX x : B, P x) <--> (EX x: B, Q x) .

Lemma imp_pred_ext  {A} `{agA : ageable A}: forall B B' P Q,
       (B <--> B') && (B --> (P <--> Q))
 |-- (B --> P) <-->  (B' --> Q).

Lemma derives_refl {A: Type} `{ageable A}:
  forall (P: pred A), (P |-- P).

Hint Resolve @derives_refl.

Lemma andp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Lemma orp_derives {A} `{ageable A}:
  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P || Q |-- P' || Q'.

Lemma exp_derives {A} `{HA : ageable A}:
       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Lemma box_ext {A} `{agA : ageable A}: forall (M: modality) P Q,
    box M (P <--> Q) |--  box M P <--> box M Q.

Lemma andp_pred_ext {A} `{agA : ageable A}: forall P Q P' Q',
       (P <--> P') && (Q <--> Q') |--  (P && Q) <--> (P' && Q').

Program Definition exactly {A} `{ageable A} (x: A) : pred A := necR x.

Lemma derives_TT {A} `{ageable A}: forall (P: pred A), P |-- TT.
Hint Resolve @derives_TT.

Lemma FF_derives {A} `{ageable A}: forall P, FF |-- P.
Hint Immediate @FF_derives.

Lemma necR_level' {A} `{H : ageable A}: forall {w w': A}, necR w w' ->
       @necR _ ag_nat (level w) (level w').

Lemma derives_imp {A} `{agA : ageable A}:
  forall P Q w, (P |-- Q) -> (P --> Q) w.

Lemma exp_andp1 {A} `{ageable A}:
 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Lemma exp_andp2 {A} `{HA: ageable A}:
 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Lemma exp_imp_left {A} `{agA : ageable A}:  forall B (p: B -> pred A) q,
     (exp p --> q)%pred = allp (fun x => p x --> q)%pred.

Lemma app_ext  {A: Type} `{ageable A} : forall (F G: A -> Prop) p1 p2 w,
         (F w = G w) ->
         app_pred (exist (hereditary age) F p1) w = app_pred (exist (hereditary age) G p2) w.

Lemma imp_derives {A} `{agA : ageable A}:
  forall P P' Q Q',
    P' |-- P ->
    Q |-- Q' ->
    P --> Q |-- P' --> Q'.

Lemma imp_lem0  {A} `{agA : ageable A}:  forall P st, (TT --> P) st -> P st.

Lemma conjoin_hyp0  {A} `{H : ageable A}:
      forall (P Q: pred A) w,  P w -> (P --> Q) w -> (TT --> Q) w.

Lemma conjoin_hyp1 {A} `{agA : ageable A}: forall (P Q R: pred A)  w,
            P w -> (P&&Q --> R) w -> (Q --> R) w.

Lemma derives_e {A: Type} `{agA : ageable A}: forall p q (st: A),
      (p |-- q) -> p st -> q st.

Ltac slurp :=
 apply imp_lem0;
  match goal with |-  app_pred (_ --> _)  ?st =>
        repeat match goal with
                   | H: app_pred ?P st |- app_pred (?b --> ?c) st =>
                       (apply (@conjoin_hyp0 _ _ P c st H) ||
                        (apply (@conjoin_hyp1 _ _ P b c st H)));
                       clear H
                   end;
        try (revert st; apply derives_e)
  end.

Lemma test_slurp {A} `{agA : ageable A} :  forall  (P Q R S : pred A) w ,
        (P && (Q && R) --> S) w -> P w -> Q w -> R w -> S w.

Lemma later_andp {A} `{H : ageable A}:
  forall P Q, |> (P && Q) = |>P && |>Q.

Lemma True_andp_eq {A}`{ageable A}:
  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

Lemma distrib_orp_andp {A}{agA: ageable A}:
   forall P Q R, (P||Q)&&R = (P&&R)||(Q&&R).

Lemma allp_right {B A: Type}{agA: ageable A}:
  forall (P: pred A) (Q: B -> pred A),
  (forall v, P |-- Q v) ->
   P |-- allp Q.

Lemma allp_left {B}{A}{agA: ageable A}:
   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

Lemma later_imp2 {A}{agA: ageable A}: forall P Q: pred A,
                 |> (P <--> Q) = |> P <--> |> Q. *)

Require Import VST.msl.cross_split.
(* VST.msl.cross_split:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.
Require Import VST.msl.psepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.cjoins.
Require Import VST.msl.eq_dec.

  Definition sa_distributive (A: Type) {JOIN: Join A} :=
    forall a b x z,
      join a b z ->
      constructive_join_sub x z ->
      {a' : A & {b' : A &
           (constructive_join_sub a' a * constructive_join_sub b' b * join a' b' x)%type}}.

  Theorem cross_split_distibutive {A} `{Perm_alg A}{SA: Sep_alg A}{CS: Cross_alg A} :
          sa_distributive A.

  Theorem distributive_cross_split {A} `{Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     sa_distributive A -> Cross_alg A.

Lemma distributive_equiv: forall A, @sa_distributive  _ (@Join_equiv A).

Lemma cross_split_equiv : forall A,  @Cross_alg _ (@Join_equiv A).

Lemma distributive_fun: forall A (JOIN: Join A) (key: Type),
               sa_distributive A -> @sa_distributive (key -> A) (Join_fun key A JOIN).

Lemma sa_distributive_prod : forall A B saA saB,
  @sa_distributive A saA ->
  @sa_distributive B saB ->
  @sa_distributive (A * B) (Join_prod A _ B _).

Lemma sa_distributive_bij : forall A B JA bij,
  @sa_distributive A JA ->
  @sa_distributive B (Join_bij A JA B bij).

Lemma Cross_bij : forall A B JA bij,
  @Cross_alg A  JA ->
  @Cross_alg B (Join_bij A JA B bij).

Lemma constructive_join_sub_smash {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  (forall x:A, {identity x}+{~identity x}) ->
  forall a c : lifted JA,
    constructive_join_sub (proj1_sig a) (proj1_sig c) ->
    @constructive_join_sub (option (lifted JA)) _ (Some a) (Some c).

Lemma sa_distributive_smash : forall A JA {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  @sa_distributive A JA ->
  sa_distributive (option (lifted JA)).

Lemma Cross_smash : forall A (JA: Join A) {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  Cross_alg A ->
  Cross_alg (option (lifted JA)).

Lemma cross_split_fpm : forall A B
      (JB: Join B) (PB: Perm_alg B)(SB : Sep_alg B)(CB: Disj_alg B)
  (Bdec: forall x:B, {identity x}+{~identity x}) ,
  Cross_alg B  ->
  Cross_alg (fpm A (lifted JB)) .

Lemma Cross_fpm (A B: Type){JB: Join B} {PB: Perm_alg B}{PosB : Pos_alg B}
  {CrB: Cross_alg B}:   Cross_alg (fpm A B) .

Definition opposite_bij {A B} (b: bijection A B) : bijection B A :=
 Bijection _ _ (bij_g _ _ b) (bij_f _ _ b) (bij_gf _ _ b) (bij_fg _ _ b).

Lemma Cross_bij' : forall A B JA JB bij,
  @Cross_alg B JB ->
   JB =  (Join_bij A JA B bij) ->
  @Cross_alg A  JA.

Definition option_bij {A B} (D: bijection A B) : bijection (option A) (option B). *)



Definition compareR {A} {JA: Join A}{SA: Sep_alg A}{AG: ageable A} : relation A

   := comparable.

Definition extendR  {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A} : relation A := join_sub.



Lemma valid_rel_compare {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : valid_rel compareR.

Proof.

  split; hnf; intros.



  apply comparable_common_unit in H0.

  destruct H0 as [w [? ?]].

  destruct (age1_join2  _ H1 H)

    as [u [v [? [? ?]]]].

  destruct (age1_join _ H0 H3)

    as [u' [v' [? [? ?]]]].

  assert (u' = v').

  unfold age in *; congruence.

  subst v'.

  exists u'; auto.

  assert (x = v).

  unfold age in *; congruence.

  subst v.

  apply common_unit_comparable.

  exists u; auto.



  apply comparable_common_unit in H.

  destruct H as [w [? ?]].

  destruct (unage_join2 _ H H0)

    as [u [v [? [? ?]]]].

  destruct (unage_join _ H1 H3)

    as [u' [v' [? [? ?]]]].

  exists v'; auto.

  apply common_unit_comparable.

  destruct (join_ex_units u) as [uu Huu].

  red in Huu.

  exists uu; split.

  destruct (join_assoc Huu H2) as [q [? ?]].

  assert (q = z).

  eapply join_eq; eauto.

  subst q; auto.

  destruct (join_assoc Huu H5) as [q [? ?]].

  assert (q = v').

  eapply join_eq; eauto.

  subst q.

  auto.

Qed.



Lemma valid_rel_extend {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : valid_rel extendR.

Proof.

  intros; split; hnf; intros.

  destruct H0 as [w ?].

  destruct (age1_join2 _ H0 H)

    as [u [v [? [? ?]]]].

  exists u; auto.

  exists v; auto.



  destruct H.

  destruct (unage_join _ H H0)

    as [u [v [? [? ?]]]].

  exists v; auto.

  exists u; auto.

Qed.



Definition compareM {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : modality

  := exist _ compareR valid_rel_compare.

Definition extendM {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : modality

  := exist _ extendR valid_rel_extend.



Obligation Tactic := unfold hereditary; intros; try solve [intuition].



Program Definition emp {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : pred A := identity.

Next Obligation.

  repeat intro.

  destruct (unage_join _ H1 H) as [a0' [b' [? [? ?]]]].

  apply H0 in H2. subst b'. unfold age in H3, H4. congruence.

Qed.



Program Definition sepcon {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (p q:pred A) : pred A := fun x:A =>

  exists y:A, exists z:A, join y z x /\ p y /\ q z.

Next Obligation.

  destruct H0 as [y [z [? [? ?]]]].

  destruct (age1_join2 _ H0 H) as [w [v [? [? ?]]]].

  exists w; exists v; split; auto.

  split.

  apply pred_hereditary with y; auto.

  apply pred_hereditary with z; auto.

Qed.



Program Definition wand {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (p q:pred A) : pred A := fun x =>

  forall x' y z, necR x x' -> join x' y z -> p y -> q z.

Next Obligation.

  apply H0 with x' y; auto.

  apply rt_trans with a'; auto.

  apply rt_step; auto.

Qed.



Notation "P '*' Q" := (sepcon P Q) : pred.

Notation "P '-*' Q" := (wand P Q) (at level 60, right associativity) : pred.

Notation "'%' e"  := (box extendM e)(at level 30, right associativity): pred.



Lemma extendM_refl {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: reflexive _ extendM.

Proof.

intros; intro; simpl; apply join_sub_refl.

Qed.



Lemma compareM_refl {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : reflexive _ compareM.

Proof.

intros; intro; simpl.

apply comparable_refl.

Qed.



Hint Resolve @extendM_refl.

Hint Resolve @compareM_refl.



Lemma wand_sepcon_adjoint {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P Q R:pred A),

  ((P * Q) |-- R) = (P |-- (Q -* R)).

Proof.

  intros. apply prop_ext.

  split; intros.

  hnf; intros; simpl; intros.

  apply H.

  exists x'; exists y.

  intuition.

  apply pred_nec_hereditary with a; auto.

  hnf; intros.

  hnf in H.

  unfold wand in H; simpl in H.

  destruct H0 as [w [v [? [? ?]]]].

  eapply H; eauto.

Qed.



Lemma sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P Q R:pred A),

  ((P * Q) * R = P * (Q * R))%pred.

Proof.

  pose proof I.

  intros; apply pred_ext; hnf; intros.

  destruct H0 as [x [y [? [? ?]]]].

  destruct H1 as [z [w [? [? ?]]]].

  destruct (join_assoc H1 H0) as [q [? ?]].

  exists z; exists q; intuition.

  exists w; exists y; intuition.

  destruct H0 as [x [y [? [? ?]]]].

  destruct H2 as [z [w [? [? ?]]]].

  apply join_comm in H0.

  apply join_comm in H2.

  destruct (join_assoc H2 H0) as [q [? ?]].

  exists q; exists w; intuition.

  exists x; exists z; intuition.

Qed.



Lemma sepcon_comm {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P Q:pred A),

  (P * Q = Q * P)%pred.

Proof.

  pose proof I.

  intros; apply pred_ext; hnf; intros.

  destruct H0 as [x [y [? [? ?]]]].

  exists y; exists x; intuition; apply join_comm; auto.

  destruct H0 as [x [y [? [? ?]]]].

  exists y; exists x; intuition; apply join_comm; auto.

Qed.



Lemma split_sepcon {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P Q R S:pred A),

  P |-- Q ->

  R |-- S ->

  (P * R) |-- (Q * S).

Proof.

  intros; hnf; intros.

  destruct H1 as [x [y [? [? ?]]]].

  exists x; exists y; intuition.

Qed.



Lemma sepcon_cut {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P Q R S:pred A),

  P |-- (Q -* R) ->

  S |-- Q ->

  (P * S) |-- R.

Proof.

  intros.

  rewrite wand_sepcon_adjoint.

  hnf; intros.

  simpl; intros.

  eapply H; eauto.

Qed.



Lemma emp_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : forall (P:pred A),

  (emp * P = P)%pred.

Proof.

  intros; apply pred_ext; hnf; intros.

  destruct H as [x [y [? [? ?]]]].

  simpl in H0.

  replace a with y; auto.

  destruct (join_ex_identities a) as [u [Hu [? Hj]]].

  exists u; exists a. split; auto.

  specialize (Hu _ _ Hj); subst; auto.

Qed.



Lemma sepcon_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}  : forall (P:pred A),

  (P * emp = P)%pred.

Proof.

  intros.

  rewrite sepcon_comm.

  apply emp_sepcon.

Qed.



Lemma later_wand {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} : forall P Q,

  (|>(P -* Q) = |>P -* |>Q)%pred.

Proof.

  pose proof I.

  intros.

  repeat rewrite later_age.

  apply pred_ext; hnf; intros.

  simpl; intros.

  simpl in H0.

  case_eq (age1 a); intros.

  specialize ( H0 a0 H5).

  apply nec_refl_or_later in H1.

  destruct H1; subst.

  destruct (age1_join2 _ H2 H4) as [w [v [? [? ?]]]].

  eapply H0; eauto.

  replace a0 with w; auto.

  congruence.

  assert (necR a0 x').

  eapply age_later_nec; eauto.

  destruct (age1_join2 _ H2 H4) as [w [v [? [? ?]]]].

  apply H0 with w v; auto.

  apply rt_trans with x'; auto.

  apply rt_step; auto.

  apply nec_refl_or_later in H1; destruct H1; subst.

  destruct (age1_join2 _  H2 H4) as [w [v [? [? ?]]]].

  hnf in H6.

  rewrite H5 in H6; discriminate.

  clear -H1 H5.

  elimtype False.

  revert H5; induction H1; auto.

  intros.

  unfold age in H.

  rewrite H in H5; discriminate.



  simpl; intros.

  simpl in H0.

  destruct (valid_rel_nec).

  destruct (H6 _ _ H2 _ H1).

  destruct (unage_join _ H3 H7) as [w [v [? [? ?]]]].

  apply H0 with x w v; auto.

  intros.

  replace a'0 with y; auto.

  congruence.

Qed.



Lemma later_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : forall P Q,

  (|>(P * Q) = |>P * |>Q)%pred.

Proof.

  pose (H:=True).

  intros.

  repeat rewrite later_age.

  apply pred_ext; hnf; intros.

  simpl in H0.

  case_eq (age1 a); intros.

  destruct (H0 a0) as [w [v [? [? ?]]]]; auto.

  destruct (unage_join2 _ H2 H1) as [w' [v' [? [? ?]]]].

  exists w'; exists v'; intuition.

  simpl; intros.

  replace a' with w; auto.

  unfold age in *; congruence.

  simpl; intros.

  replace a' with v; auto.

  unfold age in *; congruence.

  destruct (join_ex_units a).

  exists x; exists a.

  intuition.

  hnf; intros.

  red in u.

  simpl in H2.

  destruct (age1_join _ u H2) as [s [t [? [? ?]]]].

  unfold age in H5.

  rewrite H1 in H5; discriminate.

  hnf; intros.

  simpl in H2.

  unfold age in H2.

  rewrite H1 in H2; discriminate.



  destruct H0 as [w [v [? [? ?]]]].

  hnf; intros.

  simpl in H3.

  destruct (age1_join2 _ H0 H3) as [w' [v' [? [? ?]]]].

  exists w'; exists v'; intuition.

Qed.



Lemma FF_sepcon : forall {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (P:pred A),

  (FF * P = FF)%pred.

Proof.

  intros. apply pred_ext; repeat intro.

  destruct H as [? [? [? [? ?]]]].  elim H0.

  elim H.

Qed.



Lemma sepcon_derives {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall p q p' q', (p |-- p') -> (q |-- q') -> (p * q |-- p' * q').

Proof.

intros.

do 2 intro.

destruct H1 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; repeat split ;auto.

Qed.



Lemma exp_sepcon1 {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall T (P: T ->  pred A) Q,  (exp P * Q = exp (fun x => P x * Q))%pred.

Proof.

intros.

apply pred_ext; intros ? ?.

destruct H as [w1 [w2 [? [[x ?] ?]]]].

exists x; exists w1; exists w2; split; auto.

destruct H as [x [w1 [w2 [? [? ?]]]]].

exists w1; exists w2; split; auto.

split; auto.

exists x; auto.

Qed.



Lemma exp_sepcon2 {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall T (P: pred A) (Q: T -> pred A),  (P * exp Q = exp (fun x => P * Q x))%pred.

Proof.

intros.

apply pred_ext; intros ? ?.

destruct H as [w1 [w2 [? [? [x ?]]]]].

exists x; exists w1; exists w2; split; auto.

destruct H as [x [w1 [w2 [? [? ?]]]]].

exists w1; exists w2; split; auto.

split; auto.

exists x; auto.

Qed.



Lemma extend_later {A}  {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}: forall P, (%|>P = |>%P)%pred.

Proof.

  intros; rewrite later_commute; auto.

Qed.



Lemma extend_later' {A}{JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}: forall P, boxy extendM P -> boxy extendM (|> P).

Proof.

intros. unfold boxy in *. rewrite later_commute. rewrite H. auto.

Qed.

Hint Resolve @extend_later'.



Lemma age_sepcon {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} :

      forall P Q, (box ageM (P * Q) = box ageM P * box ageM Q)%pred.

Proof.

  pose proof I.

  intros.

  apply pred_ext; hnf; intros.

  hnf in H0.

  case_eq (age1 a); intros.

  destruct (H0 a0) as [u [v [? [? ?]]]]; auto.

  red.

  destruct (unage_join2 _ H2 H1) as [x [y [? [? ?]]]].

  exists x; exists y.

  intuition.

  hnf; intros.

  replace a' with u; auto.

  unfold age in *; congruence.

  hnf; intros.

  replace a' with v; auto.

  unfold age in *; congruence.

  destruct (join_ex_units a).

  exists x; exists a.

  intuition.

  hnf; intros.

  red in u.

  destruct (age1_join _ u H2)

    as [p [q [? [? ?]]]]; auto.

  unfold age in *.

  rewrite H1 in H4; discriminate.

  hnf; intros.

  simpl in *.

  unfold age in *.

  rewrite H1 in H2; discriminate.



  destruct H0 as [u [v [? [? ?]]]].

  hnf; intros.

  destruct (age1_join2 _ H0 H3)

    as [p [q [? [? ?]]]]; auto.

  exists p; exists q; intuition.

Qed.



Lemma age_twin {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall phi1 phi2 n phi1',

  comparable phi1 phi2 ->

  ageN n phi1 = Some phi1' ->

  exists phi2', ageN n phi2 = Some phi2' /\ comparable phi1' phi2'.

Proof.

intros until n; revert n phi1 phi2.

induction n; intros.

exists phi2.

split; trivial.

inversion H0.

subst phi1'.

trivial.

unfold ageN in H0.

simpl in H0.

revert H0; case_eq (age1 phi1); intros; try discriminate.

rename a into phi.

assert (exists ophi2, age phi2 ophi2 /\ comparable phi ophi2).

destruct (comparable_common_unit H) as [e [? ?]].

destruct (age1_join _ (join_comm H2) H0) as [eo [phi1'a [eof [? ?]]]].

destruct (age1_join _ H3 H4) as [phi2' [phi2'a [eof' [? ?]]]].

unfold age in H7. rewrite H6 in H7. symmetry in H7; inv H7.

rewrite H5 in H0. inv H0.

exists phi2'. split; auto.

apply common_unit_comparable; exists eo; split; auto.

destruct H2 as [ophi2 [? ?]].

specialize (IHn _ _ _ H3 H1).

destruct IHn as [phi2' [? ?]].

exists phi2'.

split; trivial.

unfold ageN.

simpl.

rewrite H2.

trivial.

Qed.



Lemma ageN_different {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: forall n phi phi', ageN (S n) phi = Some phi' ->

    ~ comparable phi phi'.

Proof.

   intros.

   intro.

   generalize (age_noetherian' phi); intros [k [[? [? ?]] H4]].

   assert (k <= n \/ k > n)%nat by omega.

   destruct H3.

   replace (S n) with (k + (S n - k))%nat in H by omega.

   destruct (ageN_compose' _ _ _ _ H) as [b [? ?]].

   rewrite H1 in H5; inv H5.

   replace (S n - k)%nat with (S (n-k))%nat in H6 by omega.

   unfold ageN in H6; simpl in H6. rewrite H2 in H6; inv H6.

   replace k with (S n + (k - S n))%nat in H1 by omega.

   destruct (ageN_compose' _ _ _ _ H1) as [c [? ?]].

   rewrite H in H5; inv H5.

   destruct (age_twin phi c _ _ H0 H1) as [b [? ?]].

   replace (S n + (k - S n))%nat with ((k - S n) + S n)%nat in H5 by omega.

   destruct (ageN_compose' _ _ _ _ H5) as [d [? ?]].

   rewrite H6 in H8; inv H8.

   clear - H9 H2.

   unfold ageN in H9; simpl  in H9; rewrite H2 in H9; inv H9.

Qed.



Lemma necR_comparable{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall w w', necR w w' -> comparable w w' -> w=w'.

Proof.

intros.

rewrite necR_evolve in H.

destruct H as [n H].

destruct n.

inv H; auto.

contradiction (ageN_different _ _ _ H); auto.

Qed.



Lemma sepcon_andp_prop {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q R, (P * (!!Q && R) = !!Q && (P * R))%pred.

Proof.

intros.

apply pred_ext; intros w ?.

destruct H as [w1 [w2 [? [? [? ?]]]]].

split. apply H1.

exists w1; exists w2; split; [|split]; auto.

destruct H.

destruct H0 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; repeat split; auto.

Qed.



Lemma TT_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: (TT * TT = TT)%pred.

Proof.

intros.

apply pred_ext; intros w ?; auto.

destruct (join_ex_units w).

exists x; exists w; split; auto.

Qed.



Lemma join_exactly {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall w1 w2 w3, join w1 w2 w3 ->  (exactly w1 * exactly w2 = exactly w3)%pred.

Proof.

pose proof I.

intros.

unfold exactly.

apply pred_ext; intros w ?; simpl in *.

destruct H1 as [? [? [? [? ?]]]].

destruct (nec_join H0 H2) as [a [b [? [? ?]]]].

assert (x0=a).

 eapply necR_linear'; eauto.

  transitivity (level x).

  symmetry; apply comparable_fashionR. eapply join_comparable2; eauto.

  apply comparable_fashionR. eapply join_comparable2; eauto.

subst x0.

generalize (join_eq H4 H1); clear H4; intro; subst.

auto.

eapply nec_join2; eauto.

Qed.



Lemma extend_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q R, boxy extendM Q -> P * (Q && R) |-- Q && (P * R).

Proof.

intros.

intros ?w [?w [?w [? [? [? ?]]]]].

split.

rewrite <- H in H2.

eapply H2.

exists w0.

apply join_comm; auto.

exists w0; exists w1; auto.

Qed.

Arguments extend_sepcon_andp : clear implicits.



Lemma distrib_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q R, P * (Q && R) |-- (P * Q) && (P * R).

Proof.

intros. intros w [w1 [w2 [? [? ?]]]].

destruct H1.

split; exists w1; exists w2; split; auto.

Qed.



Lemma modus_wand {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q,  P * (P -* Q) |-- Q.

Proof.

intros.

intros w  [?w [?w [? [? ?]]]].

eapply H1; eauto.

Qed.



Lemma extend_sepcon {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall {Q R: pred A}, boxy extendM Q ->  Q * R |-- Q.

Proof.

intros.

intros w [w1 [w2 [? [? _]]]].

rewrite <- H in H1. eapply H1; eauto.

simpl; eauto.

exists w2; auto.

Qed.



Definition precise {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} (P: pred A) : Prop :=

     forall w w1 w2, P w1 -> P w2 -> join_sub w1 w -> join_sub w2 w -> w1=w2.



Definition precise2  {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} (P: pred A) : Prop :=

     forall Q R, (P * (Q && R) = (P * Q) && (P * R))%pred.



Lemma precise_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}{AG: ageable A}{XA: Age_alg A}: precise =

                 fun P : pred A => forall Q R, (P * (Q && R) = (P * Q) && (P * R))%pred.

Proof.

extensionality P.

unfold precise.

apply prop_ext; split; intros.

apply pred_ext; unfold derives; intros; rename a into w.

destruct H0 as [phi1 [phi2 [? [? [? ?]]]]].

split; exists phi1; exists phi2; auto.

destruct H0 as [[phi1a [phi2a [? [? ?]]]] [phi1b [phi2b [? [? ?]]]]].

specialize (H w _ _ H1 H4).

spec H.

econstructor; eauto.

spec H.

econstructor; eauto.

subst phi1b.

generalize (join_canc (join_comm H0) (join_comm H3)).

intro; subst phi2b.

exists phi1a; exists phi2a; split; auto.

split; auto.

split; auto.

rename w1 into w1a.

rename w2 into w1b.

destruct H2 as [w2a ?].

destruct H3 as [w2b ?].

assert (((P * exactly w2a) && (P * exactly w2b)) w)%pred.

split; do 2 econstructor; repeat split;

try solve [simpl; apply necR_refl].

eassumption. auto. eassumption. auto.

rewrite <- H in H4.

destruct H4 as [w1 [w2 [? [? [? ?]]]]].

simpl in H6,H7.

rewrite (necR_comparable _ _ H6) in H2.

rewrite (necR_comparable _ _ H7) in H3.

eapply join_canc; eauto.

apply comparable_trans with w.

apply join_comparable with w1b; auto.

apply comparable_sym; apply join_comparable with w1; auto.

apply comparable_trans with w.

apply join_comparable with w1a; auto.

apply comparable_sym; apply join_comparable with w1; auto.

Qed.



Lemma derives_precise {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q, (P |-- Q) -> precise Q -> precise P.

Proof.

intros; intro; intros; eauto.

Qed.



Lemma precise_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: precise emp.

Proof.

repeat intro.

eapply join_sub_same_identity with (a := w1)(c := w); auto.

apply identity_unit'; auto.

eapply join_sub_unit_for; eauto.

apply identity_unit'; auto.

Qed.



Definition superprecise {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} (P: pred A) :=

   forall w1 w2, P w1 -> P w2 -> comparable w1 w2 -> w1=w2.



Lemma superprecise_exactly {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: forall w, superprecise (exactly w).

Proof.

unfold superprecise; intros.

hnf in H,H0.

eapply necR_linear'; eauto.

apply comparable_fashionR; auto.

Qed.

Hint Resolve @superprecise_exactly.



Lemma superprecise_precise {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}: forall (P: pred A) , superprecise P -> precise P.

Proof.

  pose proof I.

  unfold precise. unfold superprecise.

  intros.

  assert (comparable w1 w2). assert (comparable w1 w) by apply (join_sub_comparable H3).

  assert (comparable w w2).

    apply comparable_sym; destruct H4; eapply join_comparable; eauto.

    apply (comparable_trans H5 H6).

  apply (H0 _ _ H1 H2 H5).

Qed.



Program Definition ewand {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (P Q: pred A) : pred A :=

  fun w => exists w1, exists w2, join w1 w w2 /\ P w1 /\ Q w2.

Next Obligation.

destruct H0 as [w1 [w2 [? [? ?]]]].

apply join_comm in H0; eapply age1_join in H0; eauto.

destruct H0 as [w1' [w3' [? [? ?]]]].

exists w1'; exists w3'; split; auto.

split;   eapply pred_nec_hereditary; try eassumption.

constructor 1; auto.

constructor 1; auto.

Qed.



Lemma later_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A} : forall P Q,

  (|>(ewand P Q) = ewand (|>P) (|>Q))%pred.

Proof.

intros.

apply pred_ext.

intros w ?.

case_eq (age1 w); intros.

destruct (H a (t_step _ _ _ _ H0)) as [a1 [a2 [? [? ?]]]].

destruct (unage_join _ (join_comm H1) H0) as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; split; [|split]; auto.

hnf; intros.

apply pred_nec_hereditary with a1; auto.

eapply age_later_nec; eauto.

hnf; intros.

apply pred_nec_hereditary with a2; auto.

eapply age_later_nec; eauto.

exists (core w), w.

split; [|split].

apply core_unit.

hnf; intros.

assert (age1 (core w) = None).

apply age1_None_joins with w; auto.

exists w; apply join_comm; apply core_unit.

unfold laterM in H1. simpl in H1.

unfold laterR in H1.

apply clos_trans_t1n in H1. inv H1; rewrite H3 in H2; inv H2.

intros w' ?.

hnf in H1. apply clos_trans_t1n in H1.

inv H1; rewrite H2 in H0; inv H0.



intros w [w1 [w2 [? [? ?]]]].

intros w' ?.

hnf in H2. apply clos_trans_t1n in H2.

revert w1 w2 H H0 H1; induction H2; intros.

destruct (age1_join _ (join_comm H0) H) as [w1' [w2' [? [? ?]]]].

exists w1'; exists w2'; split; auto.

split.

eapply H1. hnf; apply clos_t1n_trans. constructor 1; auto.

eapply H2. hnf; apply clos_t1n_trans. constructor 1; auto.

destruct (age1_join _ (join_comm H0) H) as [w1' [w2' [? [? ?]]]].

apply (IHclos_trans_1n _ _ (join_comm H4)); auto; eapply pred_hereditary; eauto.

Qed.



Lemma emp_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{AG: ageable A}{XA: Age_alg A}:

      forall P, ewand emp P = P.

Proof.

intros.

apply pred_ext; intros w ?.

destruct H as [w1 [w2 [? [? ?]]]].

replace w with w2; auto.

eapply join_eq; eauto.

eapply identity_unit; eauto.

destruct (join_ex_identities w) as [e [He [? Hj]]].

exists e; exists w.

split; auto.

specialize (He _ _ Hj); subst; auto.

Qed.



Lemma pry_apart {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}{DA: Disj_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall G P Q, superprecise G -> P = ewand G (G * P) ->

                       (P * Q) && (G * TT) |-- (P * G * (ewand G Q)).

Proof.

 pose proof I. intros.

intros w [? ?].

destruct H2 as [w2 [w3 [? [? Hq]]]].

destruct H3 as [w4 [w5 [? [? _]]]].

rewrite H1 in H4.

destruct H4 as [wa [wb [? [? ?]]]].

assert (wa = w4). apply H0; auto.

apply comparable_trans with w2. apply join_comparable2 with wb; auto.

apply comparable_trans with w. apply join_comparable with w3; auto.

apply comparable_sym. apply join_comparable with w5; auto.

subst wa; clear H6.

destruct H7 as [w4' [w2' [? [? ?]]]].

assert (w4' = w4). apply H0; auto.

apply comparable_trans with wb. eapply join_comparable; eauto.

apply comparable_sym.  eapply join_comparable; eauto.

subst w4'; clear H7.

assert (w2' = w2). eapply join_canc; try apply join_comm; eauto.

subst w2'; clear H6.

destruct (CrA _ _ _ _ _ H2 H3) as [[[[w24 w25] w34] w35] [? [? [? ?]]]].

assert (identity w24).

  destruct (join_assoc (join_comm H9) H4) as [f [? ?]].

  destruct (join_assoc (join_comm H6) (join_comm H11)) as [g [? ?]].

  eapply join_self; eauto.

assert (w34=w4). eapply join_eq; [eapply identity_unit; eauto | auto ].

subst w34.

assert (w25 = w2). eapply join_eq; [eapply identity_unit; eauto | auto ].

subst w25.

clear H11 H9 H6 w24.

destruct (join_assoc (join_comm H10) (join_comm H3)) as [h [? ?]].

generalize (join_eq H6 (join_comm H4)); clear H6; intro; subst h.

destruct (join_assoc (join_comm H4) (join_comm H9)) as [h [? ?]].

generalize (join_eq H6 H7); clear H6; intro; subst h.

clear H11.

exists wb; exists w35.

split. apply join_comm; auto.

split; auto.

exists w2; exists w4; split; auto.

unfold ewand.

exists w4; exists w3; split; auto.

Qed.



Definition wk_split {A} {JA: Join A} :=

      forall a b c d e : A, join a b c -> join d e c -> joins a d -> join_sub d b.



Lemma crosssplit_wkSplit {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DA: Disj_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

    wk_split.

Proof.

unfold wk_split; intros.

destruct (CrA _ _ _ _ _ H H0) as [[[[ad ae] bd] be] [myH1 [myH2 [myH3 myH4]]]].

destruct H1 as [x H_x].

assert (exists X, join ad X be) as [X HX].

2:{   exists X.

               destruct (join_assoc (join_comm HX) (join_comm myH2)) as [y [myH5 myH6]].

               assert (y=d) by apply (join_eq myH5 myH3).  subst y.

               apply (join_comm myH6).

}

destruct (join_assoc (join_comm myH1) H_x) as [y [myH5 myH6]].

destruct (join_assoc (join_comm myH3) (join_comm myH5)) as [? [Had ?]].

apply join_self in Had.

pose proof (Had _ _ myH1); subst.

destruct (join_assoc (join_comm myH1) myH4) as [? [Hbe ?]].

specialize (Had _ _ Hbe); subst; eauto.

Qed.



Lemma wk_pry_apart {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}{DA: Disj_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall G P Q, wk_split -> superprecise G -> P = ewand G (G * P) ->

                       (P * Q) && (G * TT) |-- (P * G * (ewand G Q)).

Proof.

intros.

intros w [? ?]. unfold ewand.

destruct H2 as [w2 [w3 [? [? Hq]]]].

destruct H3 as [w4 [w5 [? [? _]]]].

rewrite H1 in H4.

destruct H4 as [wa [wb [? [? ?]]]].

assert (wa = w4). apply H0; auto.

apply comparable_trans with w2. eapply join_comparable2; eauto.

apply comparable_trans with w. eapply join_comparable; eauto.

apply comparable_sym.  eapply join_comparable; eauto.

subst wa; clear H6.

destruct H7 as [w4' [w2' [? [? ?]]]].

assert (w4' = w4). apply H0; auto.

apply comparable_trans with wb. eapply join_comparable; eauto.

apply comparable_sym.  eapply join_comparable; eauto.

subst w4'; clear H7.

assert (w2' = w2). eapply join_canc; try apply join_comm; eauto.

subst w2'; clear H6.

assert (exists y, join w2 y w5).

    destruct (H _ _ _ _ _ H2 H3 (join_joins (join_comm H4))).

    destruct (join_assoc H6 (join_comm H2)) as [y [myH1 myH2]].

    assert (y=w5) by apply (join_canc  (join_comm myH2) (join_comm H3)). subst y.

    exists x. apply (join_comm myH1).

exists wb.

destruct H6 as [y w2_y_w5].

               destruct (join_assoc w2_y_w5 (join_comm H3)) as [x [myH1 myH2]].

               destruct (join_assoc  (join_comm myH1) (join_comm myH2)) as [z [myH3 myH4]].

                                        assert (w5=z) by apply  (join_canc (join_comm H3) (join_comm myH4)). subst w5.

                                        assert (w3=x) by apply (join_canc (join_comm H2) (join_comm myH2)).  subst w3.

                                        destruct (join_assoc myH3 (join_comm myH4)) as [u [myH5 myH6]].

                                        assert (wb=u) by apply (join_eq H4 (join_comm myH5)). subst wb.

               exists y. split. apply (join_comm myH6).

               split. exists w2. exists w4. split. apply (join_comm H4). split; assumption.

               exists w4. exists x; split. apply (join_comm myH1). split; assumption.

Qed.



Lemma ewand_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}{DA: Disj_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

    forall (P Q: pred A),

       superprecise Q ->

       ewand TT (P * Q) * Q |-- ewand TT (P * Q).

Proof.

intros P Q PrecQ.

intros w [w1 [w2 [? [? ?]]]].

destruct H0 as [w5 [w6 [? [_ ?]]]].

destruct H2 as [w3 [w4 [? [? ?]]]].

generalize (PrecQ  _ _ H4 H1); clear H4; intro.

spec H4.

apply comparable_trans with w6.

apply join_comparable with w3; apply join_comm; auto.

apply comparable_trans with w1.

apply comparable_sym; apply join_comparable with w5; apply join_comm; auto.

eapply join_comparable2; eauto.

subst w4.

destruct (CrA _ _ _ _ _ H0 H2) as [[[[a b] c] d] [? [? [? ?]]]].

destruct (join_assoc H5 H) as [f [? ?]].

destruct (join_assoc H7 (join_comm H8)) as [g [? ?]].

generalize (join_self' H10); intro.

subst g.

assert (identity d).

eapply unit_identity; eauto.

assert (b=w2).

eapply join_canc; eauto.

subst b.

assert (f=w2).

eapply join_eq; eauto.

subst f.

clear H11 H10 H7.

assert (c=w1).

 specialize ( H12 c w1). apply H12. auto.

subst c.

clear H9 H5.

destruct (join_assoc H6 H2) as [h [? ?]].

generalize (join_eq H5 H); clear H5; intro; subst h.

exists a; exists w6; split; auto.

split; auto.

exists w3; exists w2; split; auto.

Qed.



Lemma ewand_derives {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P P' Q Q',  P |-- P' -> Q |-- Q' -> ewand P Q |-- ewand P' Q'.

Proof.

intros.

intros w ?.

destruct H1 as [?w [?w [? [? ?]]]].

exists w0; exists w1; split; auto.

Qed.



Lemma ewand_sepcon {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}: forall P Q R,

      (ewand (P * Q) R = ewand P (ewand Q R))%pred.

Proof.

intros; apply pred_ext; intros w ?.

destruct H as [w1 [w2 [? [? ?]]]].

destruct H0 as [w3 [w4 [? [? ?]]]].

exists w3.

destruct (join_assoc (join_comm H0) H) as [wf [? ?]].

exists wf.

split; [|split]; auto.

exists w4. exists w2. split; auto.

destruct H as [w1 [w2 [? [? ?]]]].

destruct H1 as [w3 [w4 [? [? ?]]]].

destruct (join_assoc (join_comm H) (join_comm H1)) as [wf [? ?]].

exists wf. exists w4. split; [|split]; auto.

exists w1; exists w3; split; auto.

Qed.



Lemma ewand_sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

  Trip_alg A ->

  forall P Q R: pred A,

      (forall w1 w2 w3, join w1 w2 w3 -> P w3 -> P w1) ->

      (forall w w', comparable w w' -> P w -> R w' -> joins w w') ->

      (ewand TT P) && (ewand TT R) |-- emp ->

     (ewand P (Q * R) = (ewand P Q * R))%pred.

Proof.

intros TRIPLE P Q R ?H Hjoins ?H.

apply pred_ext; intros w ?.

destruct H1 as [w1 [w2 [? [? ?]]]].

destruct H3 as [w3 [w4 [? [? ?]]]].

destruct (CrA _ _ _ _ _ H1 H3) as [[[[? ?] ?] ?] [? [? [? ?]]]].

generalize (H _ _ _ (join_comm H6) H2); intro.

assert (emp a0).

apply H0.

split.

2:{ do 2 econstructor; (split; [|split]). 3: eauto. eauto. auto. }

exists a; exists w1; split; [|split]; eauto.

apply join_unit2_e in H6; auto.

subst a.

apply join_unit1_e in H9; auto.

subst a2.

exists a1; exists w4; split; [|split]; auto.

do 2 econstructor; eauto.



destruct H1 as [w1 [wR [? [? ?]]]].

destruct H2 as [wP [wQ [? [? ?]]]].

apply join_comm in H2.

specialize (Hjoins wP wR).

spec Hjoins.

apply comparable_trans with w1; eapply join_comparable2; eauto.

destruct Hjoins as [w6 ?]; auto.

destruct (TRIPLE _ _ _ _ _ _ H1 (join_comm H6) H2) as [wQR ?].

exists wP. exists wQR.

split; [|split]; auto.

destruct (join_assoc H1 j) as [wf [? ?]].

generalize (join_eq H6 (join_comm H7)); clear H6; intros; subst w6.

destruct (join_assoc H7 (join_comm H8)) as [wg [? ?]].

generalize (join_eq H2 (join_comm H6)); clear H6; intros; subst wg.

do 2 econstructor; eauto.

Qed.



Lemma ewand_sepcon2 {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}{DA: Disj_alg A}{CrA: Cross_alg A}{AG: ageable A}{XA: Age_alg A}:

      forall

          R (SP: superprecise R)

          P (H: P = ewand R (R * P))

          Q,

          ewand P (Q * R) |-- ewand P Q * R.

Proof.

intros.

intros w ?.

destruct H0 as [w1 [w34 [? [? [w3 [w4 [? [? ?]]]]]]]].

generalize (crosssplit_wkSplit  _ _ _ _ _ H0 (join_comm H2)); unfold wk_split; intro.

spec H5.

rewrite H in H1.

destruct H1 as [wa [wb [? [? ?]]]].

generalize (SP _ _ H6 H4); clear H4; intro.

spec H4.

apply comparable_trans with w34. apply comparable_trans with w1.

eapply join_comparable2; eauto. eapply join_comparable; eauto.

apply comparable_sym; eapply join_comparable; eauto.

subst wa.

destruct H7 as [wx [wy [? [? ?]]]].

generalize (SP _ _ H7 H6); clear H7; intro.

spec H7.

apply comparable_trans with wb.  eapply join_comparable; eauto.

apply comparable_sym; eapply join_comparable; eauto.

subst wx.

generalize (join_canc (join_comm H1) (join_comm H4)); clear H4; intro.

subst wy.

econstructor; eauto.

destruct H5 as [w5 ?].

exists w5; exists w4; split; [|split]; auto.

exists w1; exists w3; split; [|split]; auto.

destruct (join_assoc H5 (join_comm H0)) as [wf [? ?]].

generalize (join_canc (join_comm H7) H2); clear H7; intro.

subst wf.

auto.

Qed.



Lemma sepcon_andp_prop2 {A} {JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A}:

  forall P Q R,  (P * (!!Q && R) = !!Q && (P * R))%pred.

Proof.

intros.

apply pred_ext; intros w ?.

destruct H as [w1 [w2 [? [? [? ?]]]]].

split. apply H1.

exists w1; exists w2; split; [|split]; auto.

destruct H.

destruct H0 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; repeat split; auto.

Qed.



Lemma sepcon_andp_prop1 {A}{JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}:

   forall (P: Prop) (Q R: pred A) , ((!! P && Q) * R = !! P && (Q * R))%pred.

Proof.

 intros. rewrite (sepcon_comm). rewrite sepcon_andp_prop2. rewrite sepcon_comm; auto.

Qed.



Lemma distrib_orp_sepcon {A : Type}{JA : Join A}{PA : Perm_alg A}{agA : ageable A}

    {AgeA : Age_alg A}:

  forall (P Q R : pred A), ((P || Q) * R = P * R || Q * R)%pred.

Proof.

 intros. apply pred_ext.

  intros w [w1 [w2 [? [[?|?] ?]]]]; [left|right]; exists w1; exists w2; repeat split; auto.

 intros ? [?|?];  destruct H as [w1 [w2 [? [? ?]]]]; exists w1; exists w2; repeat split; auto.

  left; auto. right; auto.

Qed.



Lemma distrib_orp_sepcon2{A : Type}{JA : Join A}{PA : Perm_alg A}{agA : ageable A}

    {AgeA : Age_alg A}:

  forall (P Q R : pred A),

     (R * (P || Q) = R * P || R * Q)%pred.

Proof.

intros. rewrite !(sepcon_comm R). apply distrib_orp_sepcon.

Qed.



Lemma ewand_conflict {T}{agT:ageable T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}{AT: Age_alg T}:

       forall P Q R, sepcon P Q |-- FF -> andp P (ewand Q R) |-- FF.

Proof.

 intros. intros w [? [w1 [w2 [? [? ?]]]]].

 specialize (H w2). apply H. exists w; exists w1; repeat split; auto.

Qed.



Lemma ewand_TT_sepcon {T}{agT:ageable T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}{AT: Age_alg T}:

      forall P Q R,

(P * Q && ewand R (!!True))%pred |-- (P && ewand R (!!True) * (Q && ewand R (!!True)))%pred.

Proof.

intros.

intros w [[w1 [w2 [? [? ?]]]] [w3 [w4 [? [? ?]]]]].

exists w1; exists w2; repeat split; auto.

destruct (join_assoc (join_comm H) (join_comm H2)) as [f [? ?]].

exists w3; exists f; repeat split; auto.

destruct (join_assoc H (join_comm H2)) as [g [? ?]].

exists w3; exists g; repeat split; auto.

Qed.

