
Require Import compcert.lib.Axioms.
(* compcert.lib.Axioms:
Require ClassicalFacts.
Require FunctionalExtensionality.

Lemma functional_extensionality_dep:
  forall {A: Type} {B : A -> Type} (f g : forall x : A, B x),
  (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality_dep.

Lemma functional_extensionality:
  forall {A B: Type} (f g : A -> B), (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality.

Lemma extensionality:
  forall {A B: Type} (f g : A -> B),  (forall x, f x = g x) -> f = g.
Proof @functional_extensionality.

Axiom proof_irr: ClassicalFacts.proof_irrelevance.

Arguments proof_irr [A]. *)

Require Import VST.concurrency.common.sepcomp.
Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.

Require Import VST.concurrency.common.pos.

Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
(* compcert.common.AST:
Require Import String.
Require Import Coqlib Maps Errors Integers Floats.
Require Archi.

Set Implicit Arguments.

Definition ident := positive.

Definition ident_eq := peq.

Inductive typ : Type :=
  | Tint                
  | Tfloat              
  | Tlong               
  | Tsingle             
  | Tany32              
  | Tany64.             

Lemma typ_eq: forall (t1 t2: typ), {t1=t2} + {t1<>t2}.
Global Opaque typ_eq.

Definition opt_typ_eq: forall (t1 t2: option typ), {t1=t2} + {t1<>t2}
                     := option_eq typ_eq.

Definition list_typ_eq: forall (l1 l2: list typ), {l1=l2} + {l1<>l2}
                     := list_eq_dec typ_eq.

Definition Tptr : typ := if Archi.ptr64 then Tlong else Tint.

Definition typesize (ty: typ) : Z :=
  match ty with
  | Tint => 4
  | Tfloat => 8
  | Tlong => 8
  | Tsingle => 4
  | Tany32 => 4
  | Tany64 => 8
  end.

Lemma typesize_pos: forall ty, typesize ty > 0.

Lemma typesize_Tptr: typesize Tptr = if Archi.ptr64 then 8 else 4.

Definition subtype (ty1 ty2: typ) : bool :=
  match ty1, ty2 with
  | Tint, Tint => true
  | Tlong, Tlong => true
  | Tfloat, Tfloat => true
  | Tsingle, Tsingle => true
  | (Tint | Tsingle | Tany32), Tany32 => true
  | _, Tany64 => true
  | _, _ => false
  end.

Fixpoint subtype_list (tyl1 tyl2: list typ) : bool :=
  match tyl1, tyl2 with
  | nil, nil => true
  | ty1::tys1, ty2::tys2 => subtype ty1 ty2 && subtype_list tys1 tys2
  | _, _ => false
  end.

Record calling_convention : Type := mkcallconv {
  cc_vararg: bool;                      
  cc_unproto: bool;                     
  cc_structret: bool                    
}.

Definition cc_default :=
  {| cc_vararg := false; cc_unproto := false; cc_structret := false |}.

Definition calling_convention_eq (x y: calling_convention) : {x=y} + {x<>y}.
Global Opaque calling_convention_eq.

Record signature : Type := mksignature {
  sig_args: list typ;
  sig_res: option typ;
  sig_cc: calling_convention
}.

Definition proj_sig_res (s: signature) : typ :=
  match s.(sig_res) with
  | None => Tint
  | Some t => t
  end.

Definition signature_eq: forall (s1 s2: signature), {s1=s2} + {s1<>s2}.
Global Opaque signature_eq.

Definition signature_main :=
  {| sig_args := nil; sig_res := Some Tint; sig_cc := cc_default |}.

Inductive memory_chunk : Type :=
  | Mint8signed     
  | Mint8unsigned   
  | Mint16signed    
  | Mint16unsigned  
  | Mint32          
  | Mint64          
  | Mfloat32        
  | Mfloat64        
  | Many32          
  | Many64.         

Definition chunk_eq: forall (c1 c2: memory_chunk), {c1=c2} + {c1<>c2}.
Global Opaque chunk_eq.

Definition Mptr : memory_chunk := if Archi.ptr64 then Mint64 else Mint32.

Definition type_of_chunk (c: memory_chunk) : typ :=
  match c with
  | Mint8signed => Tint
  | Mint8unsigned => Tint
  | Mint16signed => Tint
  | Mint16unsigned => Tint
  | Mint32 => Tint
  | Mint64 => Tlong
  | Mfloat32 => Tsingle
  | Mfloat64 => Tfloat
  | Many32 => Tany32
  | Many64 => Tany64
  end.

Lemma type_of_Mptr: type_of_chunk Mptr = Tptr.

Definition chunk_of_type (ty: typ) :=
  match ty with
  | Tint => Mint32
  | Tfloat => Mfloat64
  | Tlong => Mint64
  | Tsingle => Mfloat32
  | Tany32 => Many32
  | Tany64 => Many64
  end.

Lemma chunk_of_Tptr: chunk_of_type Tptr = Mptr.

Inductive init_data: Type :=
  | Init_int8: int -> init_data
  | Init_int16: int -> init_data
  | Init_int32: int -> init_data
  | Init_int64: int64 -> init_data
  | Init_float32: float32 -> init_data
  | Init_float64: float -> init_data
  | Init_space: Z -> init_data
  | Init_addrof: ident -> ptrofs -> init_data.  

Definition init_data_size (i: init_data) : Z :=
  match i with
  | Init_int8 _ => 1
  | Init_int16 _ => 2
  | Init_int32 _ => 4
  | Init_int64 _ => 8
  | Init_float32 _ => 4
  | Init_float64 _ => 8
  | Init_addrof _ _ => if Archi.ptr64 then 8 else 4
  | Init_space n => Z.max n 0
  end.

Fixpoint init_data_list_size (il: list init_data) {struct il} : Z :=
  match il with
  | nil => 0
  | i :: il' => init_data_size i + init_data_list_size il'
  end.

Lemma init_data_size_pos:
  forall i, init_data_size i >= 0.

Lemma init_data_list_size_pos:
  forall il, init_data_list_size il >= 0.

Record globvar (V: Type) : Type := mkglobvar {
  gvar_info: V;                    
  gvar_init: list init_data;       
  gvar_readonly: bool;             
  gvar_volatile: bool              
}.

Inductive globdef (F V: Type) : Type :=
  | Gfun (f: F)
  | Gvar (v: globvar V).

Arguments Gfun [F V].
Arguments Gvar [F V].

Record program (F V: Type) : Type := mkprogram {
  prog_defs: list (ident * globdef F V);
  prog_public: list ident;
  prog_main: ident
}.

Definition prog_defs_names (F V: Type) (p: program F V) : list ident :=
  List.map fst p.(prog_defs).

Definition prog_defmap (F V: Type) (p: program F V) : PTree.t (globdef F V) :=
  PTree_Properties.of_list p.(prog_defs).

Section DEFMAP.

Variables F V: Type.
Variable p: program F V.

Lemma in_prog_defmap:
  forall id g, (prog_defmap p)!id = Some g -> In (id, g) (prog_defs p).

Lemma prog_defmap_dom:
  forall id, In id (prog_defs_names p) -> exists g, (prog_defmap p)!id = Some g.

Lemma prog_defmap_unique:
  forall defs1 id g defs2,
  prog_defs p = defs1 ++ (id, g) :: defs2 ->
  ~In id (map fst defs2) ->
  (prog_defmap p)!id = Some g.

Lemma prog_defmap_norepet:
  forall id g,
  list_norepet (prog_defs_names p) ->
  In (id, g) (prog_defs p) ->
  (prog_defmap p)!id = Some g.

End DEFMAP.

Section TRANSF_PROGRAM.

Variable A B V: Type.
Variable transf: A -> B.

Definition transform_program_globdef (idg: ident * globdef A V) : ident * globdef B V :=
  match idg with
  | (id, Gfun f) => (id, Gfun (transf f))
  | (id, Gvar v) => (id, Gvar v)
  end.

Definition transform_program (p: program A V) : program B V :=
  mkprogram
    (List.map transform_program_globdef p.(prog_defs))
    p.(prog_public)
    p.(prog_main).

End TRANSF_PROGRAM.

Local Open Scope error_monad_scope.

Section TRANSF_PROGRAM_GEN.

Variables A B V W: Type.
Variable transf_fun: ident -> A -> res B.
Variable transf_var: ident -> V -> res W.

Definition transf_globvar (i: ident) (g: globvar V) : res (globvar W) :=
  do info' <- transf_var i g.(gvar_info);
  OK (mkglobvar info' g.(gvar_init) g.(gvar_readonly) g.(gvar_volatile)).

Fixpoint transf_globdefs (l: list (ident * globdef A V)) : res (list (ident * globdef B W)) :=
  match l with
  | nil => OK nil
  | (id, Gfun f) :: l' =>
    match transf_fun id f with
      | Error msg => Error (MSG "In function " :: CTX id :: MSG ": " :: msg)
      | OK tf =>
        do tl' <- transf_globdefs l'; OK ((id, Gfun tf) :: tl')
    end
  | (id, Gvar v) :: l' =>
    match transf_globvar id v with
      | Error msg => Error (MSG "In variable " :: CTX id :: MSG ": " :: msg)
      | OK tv =>
        do tl' <- transf_globdefs l'; OK ((id, Gvar tv) :: tl')
    end
  end.

Definition transform_partial_program2 (p: program A V) : res (program B W) :=
  do gl' <- transf_globdefs p.(prog_defs);
  OK (mkprogram gl' p.(prog_public) p.(prog_main)).

End TRANSF_PROGRAM_GEN.

Section TRANSF_PARTIAL_PROGRAM.

Variable A B V: Type.
Variable transf_fun: A -> res B.

Definition transform_partial_program (p: program A V) : res (program B V) :=
  transform_partial_program2 (fun i f => transf_fun f) (fun i v => OK v) p.

End TRANSF_PARTIAL_PROGRAM.

Lemma transform_program_partial_program:
  forall (A B V: Type) (transf_fun: A -> B) (p: program A V),
  transform_partial_program (fun f => OK (transf_fun f)) p = OK (transform_program transf_fun p).

Inductive external_function : Type :=
  | EF_external (name: string) (sg: signature)
       | EF_builtin (name: string) (sg: signature)
       | EF_runtime (name: string) (sg: signature)
       | EF_vload (chunk: memory_chunk)
       | EF_vstore (chunk: memory_chunk)
       | EF_malloc
       | EF_free
       | EF_memcpy (sz: Z) (al: Z)
     
  | EF_annot (kind: positive) (text: string) (targs: list typ)
       | EF_annot_val (kind: positive) (text: string) (targ: typ)
       | EF_inline_asm (text: string) (sg: signature) (clobbers: list string)
       | EF_debug (kind: positive) (text: ident) (targs: list typ).
     Definition ef_sig (ef: external_function): signature :=
  match ef with
  | EF_external name sg => sg
  | EF_builtin name sg => sg
  | EF_runtime name sg => sg
  | EF_vload chunk => mksignature (Tptr :: nil) (Some (type_of_chunk chunk)) cc_default
  | EF_vstore chunk => mksignature (Tptr :: type_of_chunk chunk :: nil) None cc_default
  | EF_malloc => mksignature (Tptr :: nil) (Some Tptr) cc_default
  | EF_free => mksignature (Tptr :: nil) None cc_default
  | EF_memcpy sz al => mksignature (Tptr :: Tptr :: nil) None cc_default
  | EF_annot kind text targs => mksignature targs None cc_default
  | EF_annot_val kind text targ => mksignature (targ :: nil) (Some targ) cc_default
  | EF_inline_asm text sg clob => sg
  | EF_debug kind text targs => mksignature targs None cc_default
  end.

Definition ef_inline (ef: external_function) : bool :=
  match ef with
  | EF_external name sg => false
  | EF_builtin name sg => true
  | EF_runtime name sg => false
  | EF_vload chunk => true
  | EF_vstore chunk => true
  | EF_malloc => false
  | EF_free => false
  | EF_memcpy sz al => true
  | EF_annot kind text targs => true
  | EF_annot_val kind Text rg => true
  | EF_inline_asm text sg clob => true
  | EF_debug kind text targs => true
  end.

Definition ef_reloads (ef: external_function) : bool :=
  match ef with
  | EF_annot kind text targs => false
  | EF_debug kind text targs => false
  | _ => true
  end.

Definition external_function_eq: forall (ef1 ef2: external_function), {ef1=ef2} + {ef1<>ef2}.
Global Opaque external_function_eq.

Inductive fundef (F: Type): Type :=
  | Internal: F -> fundef F
  | External: external_function -> fundef F.

Arguments External [F].

Section TRANSF_FUNDEF.

Variable A B: Type.
Variable transf: A -> B.

Definition transf_fundef (fd: fundef A): fundef B :=
  match fd with
  | Internal f => Internal (transf f)
  | External ef => External ef
  end.

End TRANSF_FUNDEF.

Section TRANSF_PARTIAL_FUNDEF.

Variable A B: Type.
Variable transf_partial: A -> res B.

Definition transf_partial_fundef (fd: fundef A): res (fundef B) :=
  match fd with
  | Internal f => do f' <- transf_partial f; OK (Internal f')
  | External ef => OK (External ef)
  end.

End TRANSF_PARTIAL_FUNDEF.

Set Contextual Implicit.

Inductive rpair (A: Type) : Type :=
  | One (r: A)
  | Twolong (rhi rlo: A).

Definition typ_rpair (A: Type) (typ_of: A -> typ) (p: rpair A): typ :=
  match p with
  | One r => typ_of r
  | Twolong rhi rlo => Tlong
  end.

Definition map_rpair (A B: Type) (f: A -> B) (p: rpair A): rpair B :=
  match p with
  | One r => One (f r)
  | Twolong rhi rlo => Twolong (f rhi) (f rlo)
  end.

Definition regs_of_rpair (A: Type) (p: rpair A): list A :=
  match p with
  | One r => r :: nil
  | Twolong rhi rlo => rhi :: rlo :: nil
  end.

Fixpoint regs_of_rpairs (A: Type) (l: list (rpair A)): list A :=
  match l with
  | nil => nil
  | p :: l => regs_of_rpair p ++ regs_of_rpairs l
  end.

Lemma in_regs_of_rpairs:
  forall (A: Type) (x: A) p, In x (regs_of_rpair p) -> forall l, In p l -> In x (regs_of_rpairs l).

Lemma in_regs_of_rpairs_inv:
  forall (A: Type) (x: A) l, In x (regs_of_rpairs l) -> exists p, In p l /\ In x (regs_of_rpair p).

Definition forall_rpair (A: Type) (P: A -> Prop) (p: rpair A): Prop :=
  match p with
  | One r => P r
  | Twolong rhi rlo => P rhi /\ P rlo
  end.

Inductive builtin_arg (A: Type) : Type :=
  | BA (x: A)
  | BA_int (n: int)
  | BA_long (n: int64)
  | BA_float (f: float)
  | BA_single (f: float32)
  | BA_loadstack (chunk: memory_chunk) (ofs: ptrofs)
  | BA_addrstack (ofs: ptrofs)
  | BA_loadglobal (chunk: memory_chunk) (id: ident) (ofs: ptrofs)
  | BA_addrglobal (id: ident) (ofs: ptrofs)
  | BA_splitlong (hi lo: builtin_arg A)
  | BA_addptr (a1 a2: builtin_arg A).

Inductive builtin_res (A: Type) : Type :=
  | BR (x: A)
  | BR_none
  | BR_splitlong (hi lo: builtin_res A).

Fixpoint globals_of_builtin_arg (A: Type) (a: builtin_arg A) : list ident :=
  match a with
  | BA_loadglobal chunk id ofs => id :: nil
  | BA_addrglobal id ofs => id :: nil
  | BA_splitlong hi lo => globals_of_builtin_arg hi ++ globals_of_builtin_arg lo
  | BA_addptr a1 a2 => globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2
  | _ => nil
  end.

Definition globals_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list ident :=
  List.fold_right (fun a l => globals_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_arg (A: Type) (a: builtin_arg A) : list A :=
  match a with
  | BA x => x :: nil
  | BA_splitlong hi lo => params_of_builtin_arg hi ++ params_of_builtin_arg lo
  | BA_addptr a1 a2 => params_of_builtin_arg a1 ++ params_of_builtin_arg a2
  | _ => nil
  end.

Definition params_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list A :=
  List.fold_right (fun a l => params_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_res (A: Type) (a: builtin_res A) : list A :=
  match a with
  | BR x => x :: nil
  | BR_none => nil
  | BR_splitlong hi lo => params_of_builtin_res hi ++ params_of_builtin_res lo
  end.

Fixpoint map_builtin_arg (A B: Type) (f: A -> B) (a: builtin_arg A) : builtin_arg B :=
  match a with
  | BA x => BA (f x)
  | BA_int n => BA_int n
  | BA_long n => BA_long n
  | BA_float n => BA_float n
  | BA_single n => BA_single n
  | BA_loadstack chunk ofs => BA_loadstack chunk ofs
  | BA_addrstack ofs => BA_addrstack ofs
  | BA_loadglobal chunk id ofs => BA_loadglobal chunk id ofs
  | BA_addrglobal id ofs => BA_addrglobal id ofs
  | BA_splitlong hi lo =>
      BA_splitlong (map_builtin_arg f hi) (map_builtin_arg f lo)
  | BA_addptr a1 a2 =>
      BA_addptr (map_builtin_arg f a1) (map_builtin_arg f a2)
  end.

Fixpoint map_builtin_res (A B: Type) (f: A -> B) (a: builtin_res A) : builtin_res B :=
  match a with
  | BR x => BR (f x)
  | BR_none => BR_none
  | BR_splitlong hi lo =>
      BR_splitlong (map_builtin_res f hi) (map_builtin_res f lo)
  end.

Inductive builtin_arg_constraint : Type :=
  | OK_default
  | OK_const
  | OK_addrstack
  | OK_addressing
  | OK_all. *)
Require Import compcert.common.Values. 
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)
Require Import compcert.common.Globalenvs.
(* compcert.common.Globalenvs:
Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Senv.

Record t: Type := mksenv {
  
  find_symbol: ident -> option block;
  public_symbol: ident -> bool;
  invert_symbol: block -> option ident;
  block_is_volatile: block -> bool;
  nextblock: block;
  
  find_symbol_injective:
    forall id1 id2 b, find_symbol id1 = Some b -> find_symbol id2 = Some b -> id1 = id2;
  invert_find_symbol:
    forall id b, invert_symbol b = Some id -> find_symbol id = Some b;
  find_invert_symbol:
    forall id b, find_symbol id = Some b -> invert_symbol b = Some id;
  public_symbol_exists:
    forall id, public_symbol id = true -> exists b, find_symbol id = Some b;
  find_symbol_below:
    forall id b, find_symbol id = Some b -> Plt b nextblock;
  block_is_volatile_below:
    forall b, block_is_volatile b = true -> Plt b nextblock
}.

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Definition equiv (se1 se2: t) : Prop :=
     (forall id, find_symbol se2 id = find_symbol se1 id)
  /\ (forall id, public_symbol se2 id = public_symbol se1 id)
  /\ (forall b, block_is_volatile se2 b = block_is_volatile se1 b).

End Senv.

Module Genv.

Section GENV.

Variable F: Type.  
Variable V: Type.  

Record t: Type := mkgenv {
  genv_public: list ident;              
  genv_symb: PTree.t block;             
  genv_defs: PTree.t (globdef F V);     
  genv_next: block;                     
  genv_symb_range: forall id b, PTree.get id genv_symb = Some b -> Plt b genv_next;
  genv_defs_range: forall b g, PTree.get b genv_defs = Some g -> Plt b genv_next;
  genv_vars_inj: forall id1 id2 b,
    PTree.get id1 genv_symb = Some b -> PTree.get id2 genv_symb = Some b -> id1 = id2
}.

Definition find_symbol (ge: t) (id: ident) : option block :=
  PTree.get id ge.(genv_symb).

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Definition public_symbol (ge: t) (id: ident) : bool :=
  match find_symbol ge id with
  | None => false
  | Some _ => In_dec ident_eq id ge.(genv_public)
  end.

Definition find_def (ge: t) (b: block) : option (globdef F V) :=
  PTree.get b ge.(genv_defs).

Definition find_funct_ptr (ge: t) (b: block) : option F :=
  match find_def ge b with Some (Gfun f) => Some f | _ => None end.

Definition find_funct (ge: t) (v: val) : option F :=
  match v with
  | Vptr b ofs => if Ptrofs.eq_dec ofs Ptrofs.zero then find_funct_ptr ge b else None
  | _ => None
  end.

Definition invert_symbol (ge: t) (b: block) : option ident :=
  PTree.fold
    (fun res id b' => if eq_block b b' then Some id else res)
    ge.(genv_symb) None.

Definition find_var_info (ge: t) (b: block) : option (globvar V) :=
  match find_def ge b with Some (Gvar v) => Some v | _ => None end.

Definition block_is_volatile (ge: t) (b: block) : bool :=
  match find_var_info ge b with
  | None => false
  | Some gv => gv.(gvar_volatile)
  end.

Program Definition add_global (ge: t) (idg: ident * globdef F V) : t :=
  @mkgenv
    ge.(genv_public)

Definition add_globals (ge: t) (gl: list (ident * globdef F V)) : t :=
  List.fold_left add_global gl ge.

Lemma add_globals_app:
  forall gl2 gl1 ge,
  add_globals ge (gl1 ++ gl2) = add_globals (add_globals ge gl1) gl2.

Program Definition empty_genv (pub: list ident): t :=
  @mkgenv pub (PTree.empty _) (PTree.empty _) 1%positive _ _ _.

Definition globalenv (p: program F V) :=
  add_globals (empty_genv p.(prog_public)) p.(prog_defs).

Section GLOBALENV_PRINCIPLES.

Variable P: t -> Prop.

Lemma add_globals_preserves:
  forall gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  P ge -> P (add_globals ge gl).

Lemma add_globals_ensures:
  forall id g gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> P (add_globals ge gl).

Lemma add_globals_unique_preserves:
  forall id gl ge,
  (forall ge id1 g, P ge -> In (id1, g) gl -> id1 <> id -> P (add_global ge (id1, g))) ->
  ~In id (map fst gl) -> P ge -> P (add_globals ge gl).

Lemma add_globals_unique_ensures:
  forall gl1 id g gl2 ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  ~In id (map fst gl2) -> P (add_globals ge (gl1 ++ (id, g) :: gl2)).

Remark in_norepet_unique:
  forall id g (gl: list (ident * globdef F V)),
  In (id, g) gl -> list_norepet (map fst gl) ->
  exists gl1 gl2, gl = gl1 ++ (id, g) :: gl2 /\ ~In id (map fst gl2).

Lemma add_globals_norepet_ensures:
  forall id g gl ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> list_norepet (map fst gl) -> P (add_globals ge gl).

End GLOBALENV_PRINCIPLES.

Theorem public_symbol_exists:
  forall ge id, public_symbol ge id = true -> exists b, find_symbol ge id = Some b.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Theorem find_funct_inv:
  forall ge v f,
  find_funct ge v = Some f -> exists b, v = Vptr b Ptrofs.zero.

Theorem find_funct_find_funct_ptr:
  forall ge b,
  find_funct ge (Vptr b Ptrofs.zero) = find_funct_ptr ge b.

Theorem find_funct_ptr_iff:
  forall ge b f, find_funct_ptr ge b = Some f <-> find_def ge b = Some (Gfun f).

Theorem find_var_info_iff:
  forall ge b v, find_var_info ge b = Some v <-> find_def ge b = Some (Gvar v).

Theorem find_def_symbol:
  forall p id g,
  (prog_defmap p)!id = Some g <-> exists b, find_symbol (globalenv p) id = Some b /\ find_def (globalenv p) b = Some g.

Theorem find_symbol_exists:
  forall p id g,
  In (id, g) (prog_defs p) ->
  exists b, find_symbol (globalenv p) id = Some b.

Theorem find_symbol_inversion : forall p x b,
  find_symbol (globalenv p) x = Some b ->
  In x (prog_defs_names p).

Theorem find_def_inversion:
  forall p b g,
  find_def (globalenv p) b = Some g ->
  exists id, In (id, g) (prog_defs p).

Corollary find_funct_ptr_inversion:
  forall p b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Corollary find_funct_inversion:
  forall p v f,
  find_funct (globalenv p) v = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Theorem find_funct_ptr_prop:
  forall (P: F -> Prop) p b f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct_ptr (globalenv p) b = Some f ->
  P f.

Theorem find_funct_prop:
  forall (P: F -> Prop) p v f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct (globalenv p) v = Some f ->
  P f.

Theorem global_addresses_distinct:
  forall ge id1 id2 b1 b2,
  id1 <> id2 ->
  find_symbol ge id1 = Some b1 ->
  find_symbol ge id2 = Some b2 ->
  b1 <> b2.

Theorem invert_find_symbol:
  forall ge id b,
  invert_symbol ge b = Some id -> find_symbol ge id = Some b.

Theorem find_invert_symbol:
  forall ge id b,
  find_symbol ge id = Some b -> invert_symbol ge b = Some id.

Definition advance_next (gl: list (ident * globdef F V)) (x: positive) :=
  List.fold_left (fun n g => Pos.succ n) gl x.

Remark genv_next_add_globals:
  forall gl ge,
  genv_next (add_globals ge gl) = advance_next gl (genv_next ge).

Remark genv_public_add_globals:
  forall gl ge,
  genv_public (add_globals ge gl) = genv_public ge.

Theorem globalenv_public:
  forall p, genv_public (globalenv p) = prog_public p.

Theorem block_is_volatile_below:
  forall ge b, block_is_volatile ge b = true ->  Plt b ge.(genv_next).

Definition to_senv (ge: t) : Senv.t :=
 @Senv.mksenv
    (find_symbol ge)
    (public_symbol ge)
    (invert_symbol ge)
    (block_is_volatile ge)
    ge.(genv_next)
    ge.(genv_vars_inj)
    (invert_find_symbol ge)
    (find_invert_symbol ge)
    (public_symbol_exists ge)
    ge.(genv_symb_range)
    (block_is_volatile_below ge).

Section INITMEM.

Variable ge: t.

Definition store_init_data (m: mem) (b: block) (p: Z) (id: init_data) : option mem :=
  match id with
  | Init_int8 n => Mem.store Mint8unsigned m b p (Vint n)
  | Init_int16 n => Mem.store Mint16unsigned m b p (Vint n)
  | Init_int32 n => Mem.store Mint32 m b p (Vint n)
  | Init_int64 n => Mem.store Mint64 m b p (Vlong n)
  | Init_float32 n => Mem.store Mfloat32 m b p (Vsingle n)
  | Init_float64 n => Mem.store Mfloat64 m b p (Vfloat n)
  | Init_addrof symb ofs =>
      match find_symbol ge symb with
      | None => None
      | Some b' => Mem.store Mptr m b p (Vptr b' ofs)
      end
  | Init_space n => Some m
  end.

Fixpoint store_init_data_list (m: mem) (b: block) (p: Z) (idl: list init_data)
                              {struct idl}: option mem :=
  match idl with
  | nil => Some m
  | id :: idl' =>
      match store_init_data m b p id with
      | None => None
      | Some m' => store_init_data_list m' b (p + init_data_size id) idl'
      end
  end.

Definition perm_globvar (gv: globvar V) : permission :=
  if gv.(gvar_volatile) then Nonempty
  else if gv.(gvar_readonly) then Readable
  else Writable.

Definition alloc_global (m: mem) (idg: ident * globdef F V): option mem :=
  match idg with
  | (id, Gfun f) =>
      let (m1, b) := Mem.alloc m 0 1 in
      Mem.drop_perm m1 b 0 1 Nonempty
  | (id, Gvar v) =>
      let init := v.(gvar_init) in
      let sz := init_data_list_size init in
      let (m1, b) := Mem.alloc m 0 sz in
      match store_zeros m1 b 0 sz with
      | None => None
      | Some m2 =>
          match store_init_data_list m2 b 0 init with
          | None => None
          | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)
          end
      end
  end.

Fixpoint alloc_globals (m: mem) (gl: list (ident * globdef F V))
                       {struct gl} : option mem :=
  match gl with
  | nil => Some m
  | g :: gl' =>
      match alloc_global m g with
      | None => None
      | Some m' => alloc_globals m' gl'
      end
  end.

Lemma alloc_globals_app : forall gl1 gl2 m m1,
  alloc_globals m gl1 = Some m1 ->
  alloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2).

Remark store_zeros_nextblock:
  forall m b p n m', store_zeros m b p n = Some m' -> Mem.nextblock m' = Mem.nextblock m.

Remark store_init_data_list_nextblock:
  forall idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  Mem.nextblock m' = Mem.nextblock m.

Remark alloc_global_nextblock:
  forall g m m',
  alloc_global m g = Some m' ->
  Mem.nextblock m' = Pos.succ(Mem.nextblock m).

Remark alloc_globals_nextblock:
  forall gl m m',
  alloc_globals m gl = Some m' ->
  Mem.nextblock m' = advance_next gl (Mem.nextblock m).

Remark store_zeros_perm:
  forall k prm b' q m b p n m',
  store_zeros m b p n = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_perm:
  forall k prm b' q i b m p m',
  store_init_data m b p i = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_list_perm:
  forall k prm b' q idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark alloc_global_perm:
  forall k prm b' q idg m m',
  alloc_global m idg = Some m' ->
  Mem.valid_block m b' ->

Remark alloc_globals_perm:
  forall k prm b' q gl m m',
  alloc_globals m gl = Some m' ->
  Mem.valid_block m b' ->

Remark store_zeros_unchanged:
  forall (P: block -> Z -> Prop) m b p n m',
  store_zeros m b p n = Some m' ->
  (forall i, p <= i < p + n -> ~ P b i) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_unchanged:
  forall (P: block -> Z -> Prop) b i m p m',
  store_init_data m b p i = Some m' ->
  (forall ofs, p <= ofs < p + init_data_size i -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_list_unchanged:
  forall (P: block -> Z -> Prop) b il m p m',
  store_init_data_list m b p il = Some m' ->
  (forall ofs, p <= ofs -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Definition readbytes_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall p n,
  ofs <= p -> p + Z.of_nat n <= ofs + len ->
  Mem.loadbytes m b p (Z.of_nat n) = Some (list_repeat n (Byte Byte.zero)).

Lemma store_zeros_loadbytes:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  readbytes_as_zero m' b p n.

Definition bytes_of_init_data (i: init_data): list memval :=
  match i with
  | Init_int8 n => inj_bytes (encode_int 1%nat (Int.unsigned n))
  | Init_int16 n => inj_bytes (encode_int 2%nat (Int.unsigned n))
  | Init_int32 n => inj_bytes (encode_int 4%nat (Int.unsigned n))
  | Init_int64 n => inj_bytes (encode_int 8%nat (Int64.unsigned n))
  | Init_float32 n => inj_bytes (encode_int 4%nat (Int.unsigned (Float32.to_bits n)))
  | Init_float64 n => inj_bytes (encode_int 8%nat (Int64.unsigned (Float.to_bits n)))
  | Init_space n => list_repeat (Z.to_nat n) (Byte Byte.zero)
  | Init_addrof id ofs =>
      match find_symbol ge id with
      | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b ofs)
      | None   => list_repeat (if Archi.ptr64 then 8%nat else 4%nat) Undef
      end
  end.

Remark init_data_size_addrof:
  forall id ofs, init_data_size (Init_addrof id ofs) = size_chunk Mptr.

Lemma store_init_data_loadbytes:
  forall m b p i m',
  store_init_data m b p i = Some m' ->
  readbytes_as_zero m b p (init_data_size i) ->
  Mem.loadbytes m' b p (init_data_size i) = Some (bytes_of_init_data i).

Fixpoint bytes_of_init_data_list (il: list init_data): list memval :=
  match il with
  | nil => nil
  | i :: il => bytes_of_init_data i ++ bytes_of_init_data_list il
  end.

Lemma store_init_data_list_loadbytes:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  readbytes_as_zero m b p (init_data_list_size il) ->
  Mem.loadbytes m' b p (init_data_list_size il) = Some (bytes_of_init_data_list il).

Definition read_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall chunk p,
  ofs <= p -> p + size_chunk chunk <= ofs + len ->
  (align_chunk chunk | p) ->
  Mem.load chunk m b p =
  Some (match chunk with
        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 => Vint Int.zero
        | Mint64 => Vlong Int64.zero
        | Mfloat32 => Vsingle Float32.zero
        | Mfloat64 => Vfloat Float.zero
        | Many32 | Many64 => Vundef
        end).

Remark read_as_zero_unchanged:
  forall (P: block -> Z -> Prop) m b ofs len m',
  read_as_zero m b ofs len ->
  Mem.unchanged_on P m m' ->

Lemma store_zeros_read_as_zero:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  read_as_zero m' b p n.

Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | Init_int8 n :: il' =>
      Mem.load Mint8unsigned m b p = Some(Vint(Int.zero_ext 8 n))
      /\ load_store_init_data m b (p + 1) il'
  | Init_int16 n :: il' =>
      Mem.load Mint16unsigned m b p = Some(Vint(Int.zero_ext 16 n))
      /\ load_store_init_data m b (p + 2) il'
  | Init_int32 n :: il' =>
      Mem.load Mint32 m b p = Some(Vint n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_int64 n :: il' =>
      Mem.load Mint64 m b p = Some(Vlong n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_float32 n :: il' =>
      Mem.load Mfloat32 m b p = Some(Vsingle n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_float64 n :: il' =>
      Mem.load Mfloat64 m b p = Some(Vfloat n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_addrof symb ofs :: il' =>
      (exists b', find_symbol ge symb = Some b' /\ Mem.load Mptr m b p = Some(Vptr b' ofs))
      /\ load_store_init_data m b (p + size_chunk Mptr) il'
  | Init_space n :: il' =>
      read_as_zero m b p n
      /\ load_store_init_data m b (p + Z.max n 0) il'
  end.

Lemma store_init_data_list_charact:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  read_as_zero m b p (init_data_list_size il) ->
  load_store_init_data m' b p il.

Remark alloc_global_unchanged:
  forall (P: block -> Z -> Prop) m id g m',
  alloc_global m (id, g) = Some m' ->
  Mem.unchanged_on P m m'.

Remark alloc_globals_unchanged:
  forall (P: block -> Z -> Prop) gl m m',
  alloc_globals m gl = Some m' ->
  Mem.unchanged_on P m m'.

Remark load_store_init_data_invariant:
  forall m m' b,
  (forall chunk ofs, Mem.load chunk m' b ofs = Mem.load chunk m b ofs) ->

Definition globals_initialized (g: t) (m: mem) :=
  forall b gd,
  find_def g b = Some gd ->
  match gd with
  | Gfun f =>
         Mem.perm m b 0 Cur Nonempty
      /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty)
  | Gvar v =>
         Mem.range_perm m b 0 (init_data_list_size v.(gvar_init)) Cur (perm_globvar v)
      /\ (forall ofs k p, Mem.perm m b ofs k p ->
            0 <= ofs < init_data_list_size v.(gvar_init) /\ perm_order (perm_globvar v) p)
      /\ (v.(gvar_volatile) = false -> load_store_init_data m b 0 v.(gvar_init))
      /\ (v.(gvar_volatile) = false -> Mem.loadbytes m b 0 (init_data_list_size v.(gvar_init)) = Some (bytes_of_init_data_list v.(gvar_init)))
  end.

Lemma alloc_global_initialized:
  forall g m id gd m',
  genv_next g = Mem.nextblock m ->

Lemma alloc_globals_initialized:
  forall gl ge m m',
  alloc_globals m gl = Some m' ->
  genv_next ge = Mem.nextblock m ->

End INITMEM.

Definition init_mem (p: program F V) :=
  alloc_globals (globalenv p) Mem.empty p.(prog_defs).

Lemma init_mem_genv_next: forall p m,
  init_mem p = Some m ->
  genv_next (globalenv p) = Mem.nextblock m.

Theorem find_symbol_not_fresh:
  forall p id b m,
  init_mem p = Some m ->
  find_symbol (globalenv p) id = Some b -> Mem.valid_block m b.

Theorem find_def_not_fresh:
  forall p b g m,
  init_mem p = Some m ->
  find_def (globalenv p) b = Some g -> Mem.valid_block m b.

Theorem find_funct_ptr_not_fresh:
  forall p b f m,
  init_mem p = Some m ->
  find_funct_ptr (globalenv p) b = Some f -> Mem.valid_block m b.

Theorem find_var_info_not_fresh:
  forall p b gv m,
  init_mem p = Some m ->
  find_var_info (globalenv p) b = Some gv -> Mem.valid_block m b.

Lemma init_mem_characterization_gen:
  forall p m,
  init_mem p = Some m ->
  globals_initialized (globalenv p) (globalenv p) m.

Theorem init_mem_characterization:
  forall p b gv m,
  find_var_info (globalenv p) b = Some gv ->
  init_mem p = Some m ->
  Mem.range_perm m b 0 (init_data_list_size gv.(gvar_init)) Cur (perm_globvar gv)

Theorem init_mem_characterization_2:
  forall p b fd m,
  find_funct_ptr (globalenv p) b = Some fd ->
  init_mem p = Some m ->
  Mem.perm m b 0 Cur Nonempty

Section INITMEM_INJ.

Variable ge: t.
Variable thr: block.
Hypothesis symb_inject: forall id b, find_symbol ge id = Some b -> Plt b thr.

Lemma store_zeros_neutral:
  forall m b p n m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_neutral:
  forall m b p id m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_list_neutral:
  forall b idl m p m',
  Mem.inject_neutral thr m ->

Lemma alloc_global_neutral:
  forall idg m m',
  alloc_global ge m idg = Some m' ->
  Mem.inject_neutral thr m ->

Remark advance_next_le: forall gl x, Ple x (advance_next gl x).

Lemma alloc_globals_neutral:
  forall gl m m',
  alloc_globals ge m gl = Some m' ->
  Mem.inject_neutral thr m ->

End INITMEM_INJ.

Theorem initmem_inject:
  forall p m,
  init_mem p = Some m ->
  Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m.

Definition init_data_alignment (i: init_data) : Z :=
  match i with
  | Init_int8 n => 1
  | Init_int16 n => 2
  | Init_int32 n => 4
  | Init_int64 n => 8
  | Init_float32 n => 4
  | Init_float64 n => 4
  | Init_addrof symb ofs => if Archi.ptr64 then 8 else 4
  | Init_space n => 1
  end.

Fixpoint init_data_list_aligned (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | i1 :: il => (init_data_alignment i1 | p) /\ init_data_list_aligned (p + init_data_size i1) il
  end.

Section INITMEM_INVERSION.

Variable ge: t.

Lemma store_init_data_aligned:
  forall m b p i m',
  store_init_data ge m b p i = Some m' ->
  (init_data_alignment i | p).

Lemma store_init_data_list_aligned:
  forall b il m p m',
  store_init_data_list ge m b p il = Some m' ->
  init_data_list_aligned p il.

Lemma store_init_data_list_free_idents:
  forall b i o il m p m',
  store_init_data_list ge m b p il = Some m' ->
  In (Init_addrof i o) il ->
  exists b', find_symbol ge i = Some b'.

End INITMEM_INVERSION.

Theorem init_mem_inversion:
  forall p m id v,
  init_mem p = Some m ->
  In (id, Gvar v) p.(prog_defs) ->

Section INITMEM_EXISTS.

Variable ge: t.

Lemma store_zeros_exists:
  forall m b p n,
  Mem.range_perm m b p (p + n) Cur Writable ->

Lemma store_init_data_exists:
  forall m b p i,
  Mem.range_perm m b p (p + init_data_size i) Cur Writable ->

Lemma store_init_data_list_exists:
  forall b il m p,
  Mem.range_perm m b p (p + init_data_list_size il) Cur Writable ->

Lemma alloc_global_exists:
  forall m idg,
  match idg with
  | (id, Gfun f) => True
  | (id, Gvar v) =>
        init_data_list_aligned 0 v.(gvar_init)

End INITMEM_EXISTS.

Theorem init_mem_exists:
  forall p,
  (forall id v, In (id, Gvar v) (prog_defs p) ->
        init_data_list_aligned 0 v.(gvar_init)

End GENV.

Section MATCH_GENVS.

Context {A B V W: Type} (R: globdef A V -> globdef B W -> Prop).

Record match_genvs (ge1: t A V) (ge2: t B W): Prop := {
  mge_next:
    genv_next ge2 = genv_next ge1;
  mge_symb:
    forall id, PTree.get id (genv_symb ge2) = PTree.get id (genv_symb ge1);
  mge_defs:
    forall b, option_rel R (PTree.get b (genv_defs ge1)) (PTree.get b (genv_defs ge2))
}.

Lemma add_global_match:
  forall ge1 ge2 id g1 g2,
  match_genvs ge1 ge2 ->
  R g1 g2 ->
  match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).

Lemma add_globals_match:
  forall gl1 gl2,
  list_forall2 (fun idg1 idg2 => fst idg1 = fst idg2 /\ R (snd idg1) (snd idg2)) gl1 gl2 ->
  forall ge1 ge2, match_genvs ge1 ge2 ->
  match_genvs (add_globals ge1 gl1) (add_globals ge2 gl2).

End MATCH_GENVS.

Section MATCH_PROGRAMS.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.
Variable ctx: C.
Variable p: program F1 V1.
Variable tp: program F2 V2.
Hypothesis progmatch: match_program_gen match_fundef match_varinfo ctx p tp.

Lemma globalenvs_match:
  match_genvs (match_globdef match_fundef match_varinfo ctx) (globalenv p) (globalenv tp).

Theorem find_def_match_2:
  forall b, option_rel (match_globdef match_fundef match_varinfo ctx)
                       (find_def (globalenv p) b) (find_def (globalenv tp) b).
Proof (mge_defs globalenvs_match).

Theorem find_def_match:
  forall b g,
  find_def (globalenv p) b = Some g ->
  exists tg,
  find_def (globalenv tp) b = Some tg /\ match_globdef match_fundef match_varinfo ctx g tg.

Theorem find_funct_ptr_match:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists cunit tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_funct_match:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists cunit tf,
  find_funct (globalenv tp) v = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_var_info_match:
  forall b v,
  find_var_info (globalenv p) b = Some v ->
  exists tv,
  find_var_info (globalenv tp) b = Some tv /\ match_globvar match_varinfo v tv.

Theorem find_symbol_match:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_match:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Lemma store_init_data_list_match:
  forall idl m b ofs m',
  store_init_data_list (globalenv p) m b ofs idl = Some m' ->
  store_init_data_list (globalenv tp) m b ofs idl = Some m'.

Lemma alloc_globals_match:
  forall gl1 gl2, list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) gl1 gl2 ->
  forall m m',
  alloc_globals (globalenv p) m gl1 = Some m' ->
  alloc_globals (globalenv tp) m gl2 = Some m'.

Theorem init_mem_match:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End MATCH_PROGRAMS.

Section TRANSFORM_PARTIAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> res B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => transf f = OK tf) eq p tp.

Theorem find_funct_ptr_transf_partial:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ transf f = OK tf.

Theorem find_funct_transf_partial:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists tf,
  find_funct (globalenv tp) v = Some tf /\ transf f = OK tf.

Theorem find_symbol_transf_partial:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf_partial:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf_partial:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_PARTIAL.

Section TRANSFORM_TOTAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => tf = transf f) eq p tp.

Theorem find_funct_ptr_transf:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  find_funct_ptr (globalenv tp) b = Some (transf f).

Theorem find_funct_transf:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  find_funct (globalenv tp) v = Some (transf f).

Theorem find_symbol_transf:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_TOTAL.

End Genv.

Coercion Genv.to_senv: Genv.t >-> Senv.t. *)
Require Import compcert.common.Memory.
(* compcert.common.Memory:
Require Import Zwf.
Require Import Axioms.
Require Import Coqlib.
Require Intv.
Require Import Maps.
Require Archi.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Export Memdata.
Require Export Memtype.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Local Notation "a # b" := (PMap.get b a) (at level 1).

Module Mem <: MEM.

Definition perm_order' (po: option permission) (p: permission) :=
  match po with
  | Some p' => perm_order p' p
  | None => False
 end.

Definition perm_order'' (po1 po2: option permission) :=
  match po1, po2 with
  | Some p1, Some p2 => perm_order p1 p2
  | _, None => True
  | None, Some _ => False
 end.

Record mem' : Type := mkmem {
  mem_contents: PMap.t (ZMap.t memval);  
  mem_access: PMap.t (Z -> perm_kind -> option permission);
                                         
  nextblock: block;
  access_max:
    forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
  nextblock_noaccess:
    forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
  contents_default:
    forall b, fst mem_contents#b = Undef
}.

Definition mem := mem'.

Lemma mkmem_ext:
 forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.

Definition valid_block (m: mem) (b: block) := Plt b (nextblock m).

Theorem valid_not_valid_diff:
  forall m b b', valid_block m b -> ~(valid_block m b') -> b <> b'.

Local Hint Resolve valid_not_valid_diff: mem.

Definition perm (m: mem) (b: block) (ofs: Z) (k: perm_kind) (p: permission) : Prop :=
   perm_order' (m.(mem_access)#b ofs k) p.

Theorem perm_implies:
  forall m b ofs k p1 p2, perm m b ofs k p1 -> perm_order p1 p2 -> perm m b ofs k p2.

Local Hint Resolve perm_implies: mem.

Theorem perm_cur_max:
  forall m b ofs p, perm m b ofs Cur p -> perm m b ofs Max p.

Theorem perm_cur:
  forall m b ofs k p, perm m b ofs Cur p -> perm m b ofs k p.

Theorem perm_max:
  forall m b ofs k p, perm m b ofs k p -> perm m b ofs Max p.

Local Hint Resolve perm_cur perm_max: mem.

Theorem perm_valid_block:
  forall m b ofs k p, perm m b ofs k p -> valid_block m b.

Local Hint Resolve perm_valid_block: mem.

Remark perm_order_dec:
  forall p1 p2, {perm_order p1 p2} + {~perm_order p1 p2}.

Remark perm_order'_dec:
  forall op p, {perm_order' op p} + {~perm_order' op p}.

Theorem perm_dec:
  forall m b ofs k p, {perm m b ofs k p} + {~ perm m b ofs k p}.

Definition range_perm (m: mem) (b: block) (lo hi: Z) (k: perm_kind) (p: permission) : Prop :=
  forall ofs, lo <= ofs < hi -> perm m b ofs k p.

Theorem range_perm_implies:
  forall m b lo hi k p1 p2,
  range_perm m b lo hi k p1 -> perm_order p1 p2 -> range_perm m b lo hi k p2.

Theorem range_perm_cur:
  forall m b lo hi k p,
  range_perm m b lo hi Cur p -> range_perm m b lo hi k p.

Theorem range_perm_max:
  forall m b lo hi k p,
  range_perm m b lo hi k p -> range_perm m b lo hi Max p.

Local Hint Resolve range_perm_implies range_perm_cur range_perm_max: mem.

Lemma range_perm_dec:
  forall m b lo hi k p, {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.

Definition valid_access (m: mem) (chunk: memory_chunk) (b: block) (ofs: Z) (p: permission): Prop :=
  range_perm m b ofs (ofs + size_chunk chunk) Cur p
  /\ (align_chunk chunk | ofs).

Theorem valid_access_implies:
  forall m chunk b ofs p1 p2,
  valid_access m chunk b ofs p1 -> perm_order p1 p2 ->
  valid_access m chunk b ofs p2.

Theorem valid_access_freeable_any:
  forall m chunk b ofs p,
  valid_access m chunk b ofs Freeable ->
  valid_access m chunk b ofs p.

Local Hint Resolve valid_access_implies: mem.

Theorem valid_access_valid_block:
  forall m chunk b ofs,
  valid_access m chunk b ofs Nonempty ->
  valid_block m b.

Local Hint Resolve valid_access_valid_block: mem.

Lemma valid_access_perm:
  forall m chunk b ofs k p,
  valid_access m chunk b ofs p ->
  perm m b ofs k p.

Lemma valid_access_compat:
  forall m chunk1 chunk2 b ofs p,
  size_chunk chunk1 = size_chunk chunk2 ->
  align_chunk chunk2 <= align_chunk chunk1 ->
  valid_access m chunk1 b ofs p->
  valid_access m chunk2 b ofs p.

Lemma valid_access_dec:
  forall m chunk b ofs p,
  {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.

Definition valid_pointer (m: mem) (b: block) (ofs: Z): bool :=
  perm_dec m b ofs Cur Nonempty.

Theorem valid_pointer_nonempty_perm:
  forall m b ofs,
  valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.

Theorem valid_pointer_valid_access:
  forall m b ofs,
  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.

Definition weak_valid_pointer (m: mem) (b: block) (ofs: Z) :=
  valid_pointer m b ofs || valid_pointer m b (ofs - 1).

Lemma weak_valid_pointer_spec:
  forall m b ofs,
  weak_valid_pointer m b ofs = true <->
    valid_pointer m b ofs = true \/ valid_pointer m b (ofs - 1) = true.
Lemma valid_pointer_implies:
  forall m b ofs,
  valid_pointer m b ofs = true -> weak_valid_pointer m b ofs = true.

Program Definition empty: mem :=
  mkmem (PMap.init (ZMap.init Undef))

Program Definition alloc (m: mem) (lo hi: Z) :=
  (mkmem (PMap.set m.(nextblock)

Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
  mkmem m.(mem_contents)

Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
  if range_perm_dec m b lo hi Cur Freeable
  then Some(unchecked_free m b lo hi)
  else None.

Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
  match l with
  | nil => Some m
  | (b, lo, hi) :: l' =>
      match free m b lo hi with
      | None => None
      | Some m' => free_list m' l'
      end
  end.

Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
  match n with
  | O => nil
  | S n' => ZMap.get p c :: getN n' (p + 1) c
  end.

Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
  if valid_access_dec m chunk b ofs Readable
  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
  else None.

Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
  match addr with
  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
  | _ => None
  end.

Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
  if range_perm_dec m b ofs (ofs + n) Cur Readable
  then Some (getN (nat_of_Z n) ofs (m.(mem_contents)#b))
  else None.

Fixpoint setN (vl: list memval) (p: Z) (c: ZMap.t memval) {struct vl}: ZMap.t memval :=
  match vl with
  | nil => c
  | v :: vl' => setN vl' (p + 1) (ZMap.set p v c)
  end.

Remark setN_other:
  forall vl c p q,
  (forall r, p <= r < p + Z.of_nat (length vl) -> r <> q) ->

Remark setN_outside:
  forall vl c p q,
  q < p \/ q >= p + Z.of_nat (length vl) ->

Remark getN_setN_same:
  forall vl p c,
  getN (length vl) p (setN vl p c) = vl.

Remark getN_exten:
  forall c1 c2 n p,
  (forall i, p <= i < p + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->

Remark getN_setN_disjoint:
  forall vl q c n p,
  Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (length vl)) ->

Remark getN_setN_outside:
  forall vl q c n p,
  p + Z.of_nat n <= q \/ q + Z.of_nat (length vl) <= p ->

Remark setN_default:
  forall vl q c, fst (setN vl q c) = fst c.

Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val): option mem :=
  if valid_access_dec m chunk b ofs Writable then
    Some (mkmem (PMap.set b

Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
  match addr with
  | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
  | _ => None
  end.

Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
  if range_perm_dec m b ofs (ofs + Z.of_nat (length bytes)) Cur Writable then

Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
  if range_perm_dec m b lo hi Cur Freeable then
    Some (mkmem m.(mem_contents)

Theorem nextblock_empty: nextblock empty = 1%positive.

Theorem perm_empty: forall b ofs k p, ~perm empty b ofs k p.

Theorem valid_access_empty: forall chunk b ofs p, ~valid_access empty chunk b ofs p.

Theorem valid_access_load:
  forall m chunk b ofs,
  valid_access m chunk b ofs Readable ->
  exists v, load chunk m b ofs = Some v.

Theorem load_valid_access:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  valid_access m chunk b ofs Readable.

Lemma load_result:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).

Local Hint Resolve load_valid_access valid_access_load: mem.

Theorem load_type:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  Val.has_type v (type_of_chunk chunk).

Theorem load_cast:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v

Theorem load_int8_signed_unsigned:
  forall m b ofs,
  load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).

Theorem load_int16_signed_unsigned:
  forall m b ofs,
  load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).

Theorem range_perm_loadbytes:
  forall m b ofs len,
  range_perm m b ofs (ofs + len) Cur Readable ->
  exists bytes, loadbytes m b ofs len = Some bytes.

Theorem loadbytes_range_perm:
  forall m b ofs len bytes,
  loadbytes m b ofs len = Some bytes ->
  range_perm m b ofs (ofs + len) Cur Readable.

Theorem loadbytes_load:
  forall chunk m b ofs bytes,
  loadbytes m b ofs (size_chunk chunk) = Some bytes ->
  (align_chunk chunk | ofs) ->
  load chunk m b ofs = Some(decode_val chunk bytes).

Theorem load_loadbytes:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
             /\ v = decode_val chunk bytes.

Lemma getN_length:
  forall c n p, length (getN n p c) = n.

Theorem loadbytes_length:
  forall m b ofs n bytes,
  loadbytes m b ofs n = Some bytes ->
  length bytes = nat_of_Z n.

Theorem loadbytes_empty:
  forall m b ofs n,
  n <= 0 -> loadbytes m b ofs n = Some nil.

Lemma getN_concat:
  forall c n1 n2 p,
  getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z.of_nat n1) c.

Theorem loadbytes_concat:
  forall m b ofs n1 n2 bytes1 bytes2,
  loadbytes m b ofs n1 = Some bytes1 ->
  loadbytes m b (ofs + n1) n2 = Some bytes2 ->
  n1 >= 0 -> n2 >= 0 ->
  loadbytes m b ofs (n1 + n2) = Some(bytes1 ++ bytes2).

Theorem loadbytes_split:
  forall m b ofs n1 n2 bytes,
  loadbytes m b ofs (n1 + n2) = Some bytes ->
  n1 >= 0 -> n2 >= 0 ->
  exists bytes1, exists bytes2,
     loadbytes m b ofs n1 = Some bytes1
  /\ loadbytes m b (ofs + n1) n2 = Some bytes2
  /\ bytes = bytes1 ++ bytes2.

Theorem load_rep:
 forall ch m1 m2 b ofs v1 v2,
  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->

Theorem load_int64_split:
  forall m b ofs v,
  load Mint64 m b ofs = Some v -> Archi.ptr64 = false ->

Lemma addressing_int64_split:
  forall i,
  Archi.ptr64 = false ->

Theorem loadv_int64_split:
  forall m a v,
  loadv Mint64 m a = Some v -> Archi.ptr64 = false ->

Theorem valid_access_store:
  forall m1 chunk b ofs v,
  valid_access m1 chunk b ofs Writable ->
  { m2: mem | store chunk m1 b ofs v = Some m2 }.

Local Hint Resolve valid_access_store: mem.

Section STORE.
Variable chunk: memory_chunk.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable v: val.
Variable m2: mem.
Hypothesis STORE: store chunk m1 b ofs v = Some m2.

Lemma store_access: mem_access m2 = mem_access m1.

Lemma store_mem_contents:
  mem_contents m2 = PMap.set b (setN (encode_val chunk v) ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_store_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_store_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_store_1 perm_store_2: mem.

Theorem nextblock_store:
  nextblock m2 = nextblock m1.

Theorem store_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem store_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.

Theorem store_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem store_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Theorem store_valid_access_3:
  valid_access m1 chunk b ofs Writable.

Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.

Theorem load_store_similar:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  exists v', load chunk' m2 b ofs = Some v' /\ decode_encode_val v chunk chunk' v'.

Theorem load_store_similar_2:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  type_of_chunk chunk' = type_of_chunk chunk ->
  load chunk' m2 b ofs = Some (Val.load_result chunk' v).

Theorem load_store_same:
  load chunk m2 b ofs = Some (Val.load_result chunk v).

Theorem load_store_other:
  forall chunk' b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk' <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.

Theorem loadbytes_store_same:
  loadbytes m2 b ofs (size_chunk chunk) = Some(encode_val chunk v).

Theorem loadbytes_store_other:
  forall b' ofs' n,
  b' <> b
  \/ n <= 0
  \/ ofs' + n <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.

Lemma setN_in:
  forall vl p q c,
  p <= q < p + Z.of_nat (length vl) ->

Lemma getN_in:
  forall c q n p,
  p <= q < p + Z.of_nat n ->

End STORE.

Local Hint Resolve perm_store_1 perm_store_2: mem.
Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.
Local Hint Resolve store_valid_access_1 store_valid_access_2
             store_valid_access_3: mem.

Lemma load_store_overlap:
  forall chunk m1 b ofs v m2 chunk' ofs' v',
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b ofs' = Some v' ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  exists mv1 mvl mv1' mvl',
      shape_encoding chunk v (mv1 :: mvl)
  /\  shape_decoding chunk' (mv1' :: mvl') v'
  /\  (   (ofs' = ofs /\ mv1' = mv1)
       \/ (ofs' > ofs /\ In mv1' mvl)
       \/ (ofs' < ofs /\ In mv1 mvl')).

Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
  match chunk1, chunk2 with
  | (Mint32 | Many32), (Mint32 | Many32) => True
  | (Mint64 | Many64), (Mint64 | Many64) => True
  | _, _ => False
  end.

Lemma compat_pointer_chunks_true:
  forall chunk1 chunk2,
  (chunk1 = Mint32 \/ chunk1 = Many32 \/ chunk1 = Mint64 \/ chunk1 = Many64) ->
  (chunk2 = Mint32 \/ chunk2 = Many32 \/ chunk2 = Mint64 \/ chunk2 = Many64) ->
  quantity_chunk chunk1 = quantity_chunk chunk2 ->
  compat_pointer_chunks chunk1 chunk2.

Theorem load_pointer_store:
  forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b' ofs' = Some(Vptr v_b v_o) ->
  (v = Vptr v_b v_o /\ compat_pointer_chunks chunk chunk' /\ b' = b /\ ofs' = ofs)
  \/ (b' <> b \/ ofs' + size_chunk chunk' <= ofs \/ ofs + size_chunk chunk <= ofs').

Theorem load_store_pointer_overlap:
  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs' = Some v ->
  ofs' <> ofs ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  v = Vundef.

Theorem load_store_pointer_mismatch:
  forall chunk m1 b ofs v_b v_o m2 chunk' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs = Some v ->
  ~compat_pointer_chunks chunk chunk' ->
  v = Vundef.

Lemma store_similar_chunks:
  forall chunk1 chunk2 v1 v2 m b ofs,
  encode_val chunk1 v1 = encode_val chunk2 v2 ->
  align_chunk chunk1 = align_chunk chunk2 ->
  store chunk1 m b ofs v1 = store chunk2 m b ofs v2.

Theorem store_signed_unsigned_8:
  forall m b ofs v,
  store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.

Theorem store_signed_unsigned_16:
  forall m b ofs v,
  store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.

Theorem store_int8_zero_ext:
  forall m b ofs n,
  store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =

Theorem store_int8_sign_ext:
  forall m b ofs n,
  store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =

Theorem store_int16_zero_ext:
  forall m b ofs n,
  store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =

Theorem store_int16_sign_ext:
  forall m b ofs n,
  store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =

Theorem range_perm_storebytes:
  forall m1 b ofs bytes,
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable ->

Theorem storebytes_store:
  forall m1 b ofs chunk v m2,
  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
  (align_chunk chunk | ofs) ->
  store chunk m1 b ofs v = Some m2.

Theorem store_storebytes:
  forall m1 b ofs chunk v m2,
  store chunk m1 b ofs v = Some m2 ->
  storebytes m1 b ofs (encode_val chunk v) = Some m2.

Section STOREBYTES.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable bytes: list memval.
Variable m2: mem.
Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.

Lemma storebytes_access: mem_access m2 = mem_access m1.

Lemma storebytes_mem_contents:
   mem_contents m2 = PMap.set b (setN bytes ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_storebytes_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_storebytes_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.

Theorem storebytes_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem storebytes_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Local Hint Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.

Theorem nextblock_storebytes:
  nextblock m2 = nextblock m1.

Theorem storebytes_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem storebytes_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.

Theorem storebytes_range_perm:
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable.

Theorem loadbytes_storebytes_same:
  loadbytes m2 b ofs (Z.of_nat (length bytes)) = Some bytes.

Theorem loadbytes_storebytes_disjoint:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b \/ Intv.disjoint (ofs', ofs' + len) (ofs, ofs + Z.of_nat (length bytes)) ->

Theorem loadbytes_storebytes_other:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b
  \/ ofs' + len <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

Theorem load_storebytes_other:
  forall chunk b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

End STOREBYTES.

Lemma setN_concat:
  forall bytes1 bytes2 ofs c,
  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z.of_nat (length bytes1)) (setN bytes1 ofs c).

Theorem storebytes_concat:
  forall m b ofs bytes1 m1 bytes2 m2,
  storebytes m b ofs bytes1 = Some m1 ->
  storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2 ->

Theorem storebytes_split:
  forall m b ofs bytes1 bytes2 m2,
  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
  exists m1,
     storebytes m b ofs bytes1 = Some m1
  /\ storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2.

Theorem store_int64_split:
  forall m b ofs v m',
  store Mint64 m b ofs v = Some m' -> Archi.ptr64 = false ->

Theorem storev_int64_split:
  forall m a v m',
  storev Mint64 m a v = Some m' -> Archi.ptr64 = false ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: block.
Hypothesis ALLOC: alloc m1 lo hi = (m2, b).

Theorem nextblock_alloc:
  nextblock m2 = Pos.succ (nextblock m1).

Theorem alloc_result:
  b = nextblock m1.

Theorem valid_block_alloc:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem fresh_block_alloc:
  ~(valid_block m1 b).

Theorem valid_new_block:
  valid_block m2 b.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.

Theorem valid_block_alloc_inv:
  forall b', valid_block m2 b' -> b' = b \/ valid_block m1 b'.

Theorem perm_alloc_1:
  forall b' ofs k p, perm m1 b' ofs k p -> perm m2 b' ofs k p.

Theorem perm_alloc_2:
  forall ofs k, lo <= ofs < hi -> perm m2 b ofs k Freeable.

Theorem perm_alloc_inv:
  forall b' ofs k p,
  perm m2 b' ofs k p ->
  if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p.

Theorem perm_alloc_3:
  forall ofs k p, perm m2 b ofs k p -> lo <= ofs < hi.

Theorem perm_alloc_4:
  forall b' ofs k p, perm m2 b' ofs k p -> b' <> b -> perm m1 b' ofs k p.

Local Hint Resolve perm_alloc_1 perm_alloc_2 perm_alloc_3 perm_alloc_4: mem.

Theorem valid_access_alloc_other:
  forall chunk b' ofs p,
  valid_access m1 chunk b' ofs p ->
  valid_access m2 chunk b' ofs p.

Theorem valid_access_alloc_same:
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  valid_access m2 chunk b ofs Freeable.

Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem valid_access_alloc_inv:
  forall chunk b' ofs p,
  valid_access m2 chunk b' ofs p ->
  if eq_block b' b
  then lo <= ofs /\ ofs + size_chunk chunk <= hi /\ (align_chunk chunk | ofs)
  else valid_access m1 chunk b' ofs p.

Theorem load_alloc_unchanged:
  forall chunk b' ofs,
  valid_block m1 b' ->
  load chunk m2 b' ofs = load chunk m1 b' ofs.

Theorem load_alloc_other:
  forall chunk b' ofs v,
  load chunk m1 b' ofs = Some v ->
  load chunk m2 b' ofs = Some v.

Theorem load_alloc_same:
  forall chunk ofs v,
  load chunk m2 b ofs = Some v ->
  v = Vundef.

Theorem load_alloc_same':
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  load chunk m2 b ofs = Some Vundef.

Theorem loadbytes_alloc_unchanged:
  forall b' ofs n,
  valid_block m1 b' ->
  loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.

Theorem loadbytes_alloc_same:
  forall n ofs bytes byte,
  loadbytes m2 b ofs n = Some bytes ->
  In byte bytes -> byte = Undef.

End ALLOC.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem range_perm_free:
  forall m1 b lo hi,
  range_perm m1 b lo hi Cur Freeable ->
  { m2: mem | free m1 b lo hi = Some m2 }.

Section FREE.

Variable m1: mem.
Variable bf: block.
Variables lo hi: Z.
Variable m2: mem.
Hypothesis FREE: free m1 bf lo hi = Some m2.

Theorem free_range_perm:
  range_perm m1 bf lo hi Cur Freeable.

Lemma free_result:
  m2 = unchecked_free m1 bf lo hi.

Theorem nextblock_free:
  nextblock m2 = nextblock m1.

Theorem valid_block_free_1:
  forall b, valid_block m1 b -> valid_block m2 b.

Theorem valid_block_free_2:
  forall b, valid_block m2 b -> valid_block m1 b.

Local Hint Resolve valid_block_free_1 valid_block_free_2: mem.

Theorem perm_free_1:
  forall b ofs k p,
  b <> bf \/ ofs < lo \/ hi <= ofs ->
  perm m1 b ofs k p ->
  perm m2 b ofs k p.

Theorem perm_free_2:
  forall ofs k p, lo <= ofs < hi -> ~ perm m2 bf ofs k p.

Theorem perm_free_3:
  forall b ofs k p,
  perm m2 b ofs k p -> perm m1 b ofs k p.

Theorem perm_free_inv:
  forall b ofs k p,
  perm m1 b ofs k p ->
  (b = bf /\ lo <= ofs < hi) \/ perm m2 b ofs k p.

Theorem valid_access_free_1:
  forall chunk b ofs p,
  valid_access m1 chunk b ofs p ->
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  valid_access m2 chunk b ofs p.

Theorem valid_access_free_2:
  forall chunk ofs p,
  lo < hi -> ofs + size_chunk chunk > lo -> ofs < hi ->
  ~(valid_access m2 chunk bf ofs p).

Theorem valid_access_free_inv_1:
  forall chunk b ofs p,
  valid_access m2 chunk b ofs p ->
  valid_access m1 chunk b ofs p.

Theorem valid_access_free_inv_2:
  forall chunk ofs p,
  valid_access m2 chunk bf ofs p ->
  lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs.

Theorem load_free:
  forall chunk b ofs,
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  load chunk m2 b ofs = load chunk m1 b ofs.

Theorem load_free_2:
  forall chunk b ofs v,
  load chunk m2 b ofs = Some v -> load chunk m1 b ofs = Some v.

Theorem loadbytes_free:
  forall b ofs n,
  b <> bf \/ lo >= hi \/ ofs + n <= lo \/ hi <= ofs ->
  loadbytes m2 b ofs n = loadbytes m1 b ofs n.

Theorem loadbytes_free_2:
  forall b ofs n bytes,
  loadbytes m2 b ofs n = Some bytes -> loadbytes m1 b ofs n = Some bytes.

End FREE.

Local Hint Resolve valid_block_free_1 valid_block_free_2
             perm_free_1 perm_free_2 perm_free_3
             valid_access_free_1 valid_access_free_inv_1: mem.

Theorem range_perm_drop_1:
  forall m b lo hi p m', drop_perm m b lo hi p = Some m' -> range_perm m b lo hi Cur Freeable.

Theorem range_perm_drop_2:
  forall m b lo hi p,
  range_perm m b lo hi Cur Freeable -> {m' | drop_perm m b lo hi p = Some m' }.

Section DROP.

Variable m: mem.
Variable b: block.
Variable lo hi: Z.
Variable p: permission.
Variable m': mem.
Hypothesis DROP: drop_perm m b lo hi p = Some m'.

Theorem nextblock_drop:
  nextblock m' = nextblock m.

Theorem drop_perm_valid_block_1:
  forall b', valid_block m b' -> valid_block m' b'.

Theorem drop_perm_valid_block_2:
  forall b', valid_block m' b' -> valid_block m b'.

Theorem perm_drop_1:
  forall ofs k, lo <= ofs < hi -> perm m' b ofs k p.

Theorem perm_drop_2:
  forall ofs k p', lo <= ofs < hi -> perm m' b ofs k p' -> perm_order p p'.

Theorem perm_drop_3:
  forall b' ofs k p', b' <> b \/ ofs < lo \/ hi <= ofs -> perm m b' ofs k p' -> perm m' b' ofs k p'.

Theorem perm_drop_4:
  forall b' ofs k p', perm m' b' ofs k p' -> perm m b' ofs k p'.

Lemma valid_access_drop_1:
  forall chunk b' ofs p',
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p p' ->
  valid_access m chunk b' ofs p' -> valid_access m' chunk b' ofs p'.

Lemma valid_access_drop_2:
  forall chunk b' ofs p',
  valid_access m' chunk b' ofs p' -> valid_access m chunk b' ofs p'.

Theorem load_drop:
  forall chunk b' ofs,
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p Readable ->
  load chunk m' b' ofs = load chunk m b' ofs.

Theorem loadbytes_drop:
  forall b' ofs n,
  b' <> b \/ ofs + n <= lo \/ hi <= ofs \/ perm_order p Readable ->
  loadbytes m' b' ofs n = loadbytes m b' ofs n.

End DROP.

Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
  mk_mem_inj {
    mi_perm:
      forall b1 b2 delta ofs k p,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs k p ->
      perm m2 b2 (ofs + delta) k p;
    mi_align:
      forall b1 b2 delta chunk ofs p,
      f b1 = Some(b2, delta) ->
      range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->
      (align_chunk chunk | delta);
    mi_memval:
      forall b1 ofs b2 delta,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs Cur Readable ->
      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
  }.

Lemma perm_inj:
  forall f m1 m2 b1 ofs k p b2 delta,
  mem_inj f m1 m2 ->
  perm m1 b1 ofs k p ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p.

Lemma range_perm_inj:
  forall f m1 m2 b1 lo hi k p b2 delta,
  mem_inj f m1 m2 ->
  range_perm m1 b1 lo hi k p ->
  f b1 = Some(b2, delta) ->
  range_perm m2 b2 (lo + delta) (hi + delta) k p.

Lemma valid_access_inj:
  forall f m1 m2 b1 b2 delta chunk ofs p,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Lemma getN_inj:
  forall f m1 m2 b1 b2 delta,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  forall n ofs,
  range_perm m1 b1 ofs (ofs + Z.of_nat n) Cur Readable ->

Lemma load_inj:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  mem_inj f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Lemma loadbytes_inj:
  forall f m1 m2 len b1 ofs b2 delta bytes1,
  mem_inj f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Lemma setN_inj:
  forall (access: Z -> Prop) delta f vl1 vl2,
  list_forall2 (memval_inject f) vl1 vl2 ->
  forall p c1 c2,
  (forall q, access q -> memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2)) ->

Definition meminj_no_overlap (f: meminj) (m: mem) : Prop :=
  forall b1 b1' delta1 b2 b2' delta2 ofs1 ofs2,
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m b1 ofs1 Max Nonempty ->
  perm m b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Lemma store_mapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Lemma store_unmapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma store_outside_inj:
  forall f m1 m2 chunk b ofs v m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  mem_inj f m1 m2'.

Lemma storebytes_mapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ mem_inj f n1 n2.

Lemma storebytes_unmapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma storebytes_outside_inj:
  forall f m1 m2 b ofs bytes2 m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Lemma storebytes_empty_inj:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  mem_inj f m1' m2'.

Lemma alloc_right_inj:
  forall f m1 m2 lo hi b2 m2',
  mem_inj f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  mem_inj f m1 m2'.

Lemma alloc_left_unmapped_inj:
  forall f m1 m2 lo hi m1' b1,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  f b1 = None ->
  mem_inj f m1' m2.

Definition inj_offset_aligned (delta: Z) (size: Z) : Prop :=
  forall chunk, size_chunk chunk <= size -> (align_chunk chunk | delta).

Lemma alloc_left_mapped_inj:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  inj_offset_aligned delta (hi-lo) ->
  (forall ofs k p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) ->
  f b1 = Some(b2, delta) ->
  mem_inj f m1' m2.

Lemma free_left_inj:
  forall f m1 m2 b lo hi m1',
  mem_inj f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  mem_inj f m1' m2.

Lemma free_right_inj:
  forall f m1 m2 b lo hi m2',
  mem_inj f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  mem_inj f m1 m2'.

Lemma drop_unmapped_inj:
  forall f m1 m2 b lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b lo hi p = Some m1' ->
  f b = None ->
  mem_inj f m1' m2.

Lemma drop_mapped_inj:
  forall f m1 m2 b1 b2 delta lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b1 lo hi p = Some m1' ->
  meminj_no_overlap f m1 ->
  f b1 = Some(b2, delta) ->
  exists m2',
      drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'
   /\ mem_inj f m1' m2'.

Lemma drop_outside_inj: forall f m1 m2 b lo hi p m2',
  mem_inj f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs' k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs' k p ->
    lo <= ofs' + delta < hi -> False) ->
  mem_inj f m1 m2'.

Record extends' (m1 m2: mem) : Prop :=
  mk_extends {
    mext_next: nextblock m1 = nextblock m2;
    mext_inj:  mem_inj inject_id m1 m2;
    mext_perm_inv: forall b ofs k p,
      perm m2 b ofs k p ->
      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
  }.

Definition extends := extends'.

Theorem extends_refl:
  forall m, extends m m.

Theorem load_extends:
  forall chunk m1 m2 b ofs v1,
  extends m1 m2 ->
  load chunk m1 b ofs = Some v1 ->
  exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.

Theorem loadv_extends:
  forall chunk m1 m2 addr1 addr2 v1,
  extends m1 m2 ->
  loadv chunk m1 addr1 = Some v1 ->
  Val.lessdef addr1 addr2 ->

Theorem loadbytes_extends:
  forall m1 m2 b ofs len bytes1,
  extends m1 m2 ->
  loadbytes m1 b ofs len = Some bytes1 ->
  exists bytes2, loadbytes m2 b ofs len = Some bytes2
              /\ list_forall2 memval_lessdef bytes1 bytes2.

Theorem store_within_extends:
  forall chunk m1 m2 b ofs v1 m1' v2,
  extends m1 m2 ->
  store chunk m1 b ofs v1 = Some m1' ->
  Val.lessdef v1 v2 ->

Theorem store_outside_extends:
  forall chunk m1 m2 b ofs v m2',
  extends m1 m2 ->
  store chunk m2 b ofs v = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) ->
  extends m1 m2'.

Theorem storev_extends:
  forall chunk m1 m2 addr1 v1 m1' addr2 v2,
  extends m1 m2 ->
  storev chunk m1 addr1 v1 = Some m1' ->
  Val.lessdef addr1 addr2 ->

Theorem storebytes_within_extends:
  forall m1 m2 b ofs bytes1 m1' bytes2,
  extends m1 m2 ->
  storebytes m1 b ofs bytes1 = Some m1' ->
  list_forall2 memval_lessdef bytes1 bytes2 ->
  exists m2',
     storebytes m2 b ofs bytes2 = Some m2'
  /\ extends m1' m2'.

Theorem storebytes_outside_extends:
  forall m1 m2 b ofs bytes2 m2',
  extends m1 m2 ->
  storebytes m2 b ofs bytes2 = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem alloc_extends:
  forall m1 m2 lo1 hi1 b m1' lo2 hi2,
  extends m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists m2',
     alloc m2 lo2 hi2 = (m2', b)
  /\ extends m1' m2'.

Theorem free_left_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  extends m1' m2.

Theorem free_right_extends:
  forall m1 m2 b lo hi m2',
  extends m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall ofs k p, perm m1 b ofs k p -> lo <= ofs < hi -> False) ->
  extends m1 m2'.

Theorem free_parallel_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  exists m2',
     free m2 b lo hi = Some m2'
  /\ extends m1' m2'.

Theorem valid_block_extends:
  forall m1 m2 b,
  extends m1 m2 ->
  (valid_block m1 b <-> valid_block m2 b).

Theorem perm_extends:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m1 b ofs k p -> perm m2 b ofs k p.

Theorem perm_extends_inv:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m2 b ofs k p -> perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty.

Theorem valid_access_extends:
  forall m1 m2 chunk b ofs p,
  extends m1 m2 -> valid_access m1 chunk b ofs p -> valid_access m2 chunk b ofs p.

Theorem valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 -> valid_pointer m1 b ofs = true -> valid_pointer m2 b ofs = true.

Theorem weak_valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 ->
  weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.

Record inject' (f: meminj) (m1 m2: mem) : Prop :=
  mk_inject {
    mi_inj:
      mem_inj f m1 m2;
    mi_freeblocks:
      forall b, ~(valid_block m1 b) -> f b = None;
    mi_mappedblocks:
      forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
    mi_no_overlap:
      meminj_no_overlap f m1;
    mi_representable:
      forall b b' delta ofs,
      f b = Some(b', delta) ->
      perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/ perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
      delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
    mi_perm_inv:
      forall b1 ofs b2 delta k p,
      f b1 = Some(b2, delta) ->
      perm m2 b2 (ofs + delta) k p ->
      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
  }.
Definition inject := inject'.

Local Hint Resolve mi_mappedblocks: mem.

Theorem valid_block_inject_1:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m1 b1.

Theorem valid_block_inject_2:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m2 b2.

Local Hint Resolve valid_block_inject_1 valid_block_inject_2: mem.

Theorem perm_inject:
  forall f m1 m2 b1 b2 delta ofs k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.

Theorem perm_inject_inv:
  forall f m1 m2 b1 ofs b2 delta k p,
  inject f m1 m2 ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p ->
  perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty.

Theorem range_perm_inject:
  forall f m1 m2 b1 b2 delta lo hi k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  range_perm m1 b1 lo hi k p -> range_perm m2 b2 (lo + delta) (hi + delta) k p.

Theorem valid_access_inject:
  forall f m1 m2 chunk b1 ofs b2 delta p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Theorem valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_pointer m1 b1 ofs = true ->
  valid_pointer m2 b2 (ofs + delta) = true.

Theorem weak_valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  weak_valid_pointer m1 b1 ofs = true ->
  weak_valid_pointer m2 b2 (ofs + delta) = true.

Lemma address_inject:
  forall f m1 m2 b1 ofs1 b2 delta p,
  inject f m1 m2 ->
  perm m1 b1 (Ptrofs.unsigned ofs1) Cur p ->

Lemma address_inject':
  forall f m1 m2 chunk b1 ofs1 b2 delta,
  inject f m1 m2 ->
  valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty ->

Theorem weak_valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem weak_valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem inject_no_overlap:
  forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
  inject f m1 m2 ->
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m1 b1 ofs1 Max Nonempty ->
  perm m1 b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Theorem different_pointers_inject:
  forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  inject f m m' ->
  b1 <> b2 ->
  valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->

Theorem disjoint_or_equal_inject:
  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
  inject f m m' ->
  f b1 = Some(b1', delta1) ->
  f b2 = Some(b2', delta2) ->
  range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty ->
  range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty ->
  sz > 0 ->
  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
             \/ ofs1 + delta1 + sz <= ofs2 + delta2
             \/ ofs2 + delta2 + sz <= ofs1 + delta1.

Theorem aligned_area_inject:
  forall f m m' b ofs al sz b' delta,
  inject f m m' ->
  al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz > 0 ->
  (al | sz) ->
  range_perm m b ofs (ofs + sz) Cur Nonempty ->
  (al | ofs) ->
  f b = Some(b', delta) ->
  (al | ofs + delta).

Theorem load_inject:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  inject f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Theorem loadv_inject:
  forall f m1 m2 chunk a1 a2 v1,
  inject f m1 m2 ->
  loadv chunk m1 a1 = Some v1 ->
  Val.inject f a1 a2 ->

Theorem loadbytes_inject:
  forall f m1 m2 b1 ofs len b2 delta bytes1,
  inject f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Theorem store_mapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Theorem store_unmapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem store_outside_inject:
  forall f m1 m2 chunk b ofs v m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  inject f m1 m2'.

Theorem storev_mapped_inject:
  forall f chunk m1 a1 v1 n1 m2 a2 v2,
  inject f m1 m2 ->
  storev chunk m1 a1 v1 = Some n1 ->
  Val.inject f a1 a2 ->

Theorem storebytes_mapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ inject f n1 n2.

Theorem storebytes_unmapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem storebytes_outside_inject:
  forall f m1 m2 b ofs bytes2 m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem storebytes_empty_inject:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  inject f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  inject f m1' m2'.

Theorem alloc_right_inject:
  forall f m1 m2 lo hi b2 m2',
  inject f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  inject f m1 m2'.

Theorem alloc_left_unmapped_inject:
  forall f m1 m2 lo hi m1' b1,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  exists f',
     inject f' m1' m2
  /\ inject_incr f f'
  /\ f' b1 = None
  /\ (forall b, b <> b1 -> f' b = f b).

Theorem alloc_left_mapped_inject:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  0 <= delta <= Ptrofs.max_unsigned ->

Theorem alloc_parallel_inject:
  forall f m1 m2 lo1 hi1 m1' b1 lo2 hi2,
  inject f m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b1) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists f', exists m2', exists b2,
  alloc m2 lo2 hi2 = (m2', b2)
  /\ inject f' m1' m2'
  /\ inject_incr f f'
  /\ f' b1 = Some(b2, 0)
  /\ (forall b, b <> b1 -> f' b = f b).

Lemma free_left_inject:
  forall f m1 m2 b lo hi m1',
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  inject f m1' m2.

Lemma free_list_left_inject:
  forall f m2 l m1 m1',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  inject f m1' m2.

Lemma free_right_inject:
  forall f m1 m2 b lo hi m2',
  inject f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) -> perm m1 b1 ofs k p ->
    lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma perm_free_list:
  forall l m m' b ofs k p,
  free_list m l = Some m' ->
  perm m' b ofs k p ->
  perm m b ofs k p /\
  (forall lo hi, In (b, lo, hi) l -> lo <= ofs < hi -> False).

Theorem free_inject:
  forall f m1 l m1' m2 b lo hi m2',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) ->
    perm m1 b1 ofs k p -> lo <= ofs + delta < hi ->
    exists lo1, exists hi1, In (b1, lo1, hi1) l /\ lo1 <= ofs < hi1) ->
  inject f m1' m2'.

Theorem free_parallel_inject:
  forall f m1 m2 b lo hi m1' b' delta,
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  f b = Some(b', delta) ->
  exists m2',
     free m2 b' (lo + delta) (hi + delta) = Some m2'
  /\ inject f m1' m2'.

Lemma drop_outside_inject: forall f m1 m2 b lo hi p m2',
  inject f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma mem_inj_compose:
  forall f f' m1 m2 m3,
  mem_inj f m1 m2 -> mem_inj f' m2 m3 -> mem_inj (compose_meminj f f') m1 m3.

Theorem inject_compose:
  forall f f' m1 m2 m3,
  inject f m1 m2 -> inject f' m2 m3 ->
  inject (compose_meminj f f') m1 m3.

Lemma val_lessdef_inject_compose:
  forall f v1 v2 v3,
  Val.lessdef v1 v2 -> Val.inject f v2 v3 -> Val.inject f v1 v3.

Lemma val_inject_lessdef_compose:
  forall f v1 v2 v3,
  Val.inject f v1 v2 -> Val.lessdef v2 v3 -> Val.inject f v1 v3.

Lemma extends_inject_compose:
  forall f m1 m2 m3,
  extends m1 m2 -> inject f m2 m3 -> inject f m1 m3.

Lemma inject_extends_compose:
  forall f m1 m2 m3,
  inject f m1 m2 -> extends m2 m3 -> inject f m1 m3.

Lemma extends_extends_compose:
  forall m1 m2 m3,
  extends m1 m2 -> extends m2 m3 -> extends m1 m3.

Definition flat_inj (thr: block) : meminj :=
  fun (b: block) => if plt b thr then Some(b, 0) else None.

Definition inject_neutral (thr: block) (m: mem) :=
  mem_inj (flat_inj thr) m m.

Remark flat_inj_no_overlap:
  forall thr m, meminj_no_overlap (flat_inj thr) m.

Theorem neutral_inject:
  forall m, inject_neutral (nextblock m) m -> inject (flat_inj (nextblock m)) m m.

Theorem empty_inject_neutral:
  forall thr, inject_neutral thr empty.

Theorem alloc_inject_neutral:
  forall thr m lo hi b m',
  alloc m lo hi = (m', b) ->
  inject_neutral thr m ->
  Plt (nextblock m) thr ->
  inject_neutral thr m'.

Theorem store_inject_neutral:
  forall chunk m b ofs v m' thr,
  store chunk m b ofs v = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  Val.inject (flat_inj thr) v v ->

Theorem drop_inject_neutral:
  forall m b lo hi p m' thr,
  drop_perm m b lo hi p = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  inject_neutral thr m'.

Section UNCHANGED_ON.

Variable P: block -> Z -> Prop.

Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
  unchanged_on_nextblock:
    Ple (nextblock m_before) (nextblock m_after);
  unchanged_on_perm:
    forall b ofs k p,
    P b ofs -> valid_block m_before b ->
    (perm m_before b ofs k p <-> perm m_after b ofs k p);
  unchanged_on_contents:
    forall b ofs,
    P b ofs -> perm m_before b ofs Cur Readable ->
    ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
    ZMap.get ofs (PMap.get b m_before.(mem_contents))
}.

Lemma unchanged_on_refl:
  forall m, unchanged_on m m.

Lemma valid_block_unchanged_on:
  forall m m' b,
  unchanged_on m m' -> valid_block m b -> valid_block m' b.

Lemma perm_unchanged_on:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs ->
  perm m b ofs k p -> perm m' b ofs k p.

Lemma perm_unchanged_on_2:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs -> valid_block m b ->
  perm m' b ofs k p -> perm m b ofs k p.

Lemma unchanged_on_trans:
  forall m1 m2 m3, unchanged_on m1 m2 -> unchanged_on m2 m3 -> unchanged_on m1 m3.

Lemma loadbytes_unchanged_on_1:
  forall m m' b ofs n,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m' b ofs n = loadbytes m b ofs n.

Lemma loadbytes_unchanged_on:
  forall m m' b ofs n bytes,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m b ofs n = Some bytes ->
  loadbytes m' b ofs n = Some bytes.

Lemma load_unchanged_on_1:
  forall m m' chunk b ofs,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m' b ofs = load chunk m b ofs.

Lemma load_unchanged_on:
  forall m m' chunk b ofs v,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m b ofs = Some v ->
  load chunk m' b ofs = Some v.

Lemma store_unchanged_on:
  forall chunk m b ofs v m',
  store chunk m b ofs v = Some m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> ~ P b i) ->
  unchanged_on m m'.

Lemma storebytes_unchanged_on:
  forall m b ofs bytes m',
  storebytes m b ofs bytes = Some m' ->
  (forall i, ofs <= i < ofs + Z.of_nat (length bytes) -> ~ P b i) ->

Lemma alloc_unchanged_on:
  forall m lo hi m' b,
  alloc m lo hi = (m', b) ->
  unchanged_on m m'.

Lemma free_unchanged_on:
  forall m b lo hi m',
  free m b lo hi = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

Lemma drop_perm_unchanged_on:
  forall m b lo hi p m',
  drop_perm m b lo hi p = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

End UNCHANGED_ON.

Lemma unchanged_on_implies:
  forall (P Q: block -> Z -> Prop) m m',
  unchanged_on P m m' ->
  (forall b ofs, Q b ofs -> valid_block m b -> P b ofs) ->
  unchanged_on Q m m'.

End Mem.

Notation mem := Mem.mem.

Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.

Hint Resolve
  Mem.valid_not_valid_diff
  Mem.perm_implies
  Mem.perm_cur
  Mem.perm_max
  Mem.perm_valid_block
  Mem.range_perm_implies
  Mem.range_perm_cur
  Mem.range_perm_max
  Mem.valid_access_implies
  Mem.valid_access_valid_block
  Mem.valid_access_perm
  Mem.valid_access_load
  Mem.load_valid_access
  Mem.loadbytes_range_perm
  Mem.valid_access_store
  Mem.perm_store_1
  Mem.perm_store_2
  Mem.nextblock_store
  Mem.store_valid_block_1
  Mem.store_valid_block_2
  Mem.store_valid_access_1
  Mem.store_valid_access_2
  Mem.store_valid_access_3
  Mem.storebytes_range_perm
  Mem.perm_storebytes_1
  Mem.perm_storebytes_2
  Mem.storebytes_valid_access_1
  Mem.storebytes_valid_access_2
  Mem.nextblock_storebytes
  Mem.storebytes_valid_block_1
  Mem.storebytes_valid_block_2
  Mem.nextblock_alloc
  Mem.alloc_result
  Mem.valid_block_alloc
  Mem.fresh_block_alloc
  Mem.valid_new_block
  Mem.perm_alloc_1
  Mem.perm_alloc_2
  Mem.perm_alloc_3
  Mem.perm_alloc_4
  Mem.perm_alloc_inv
  Mem.valid_access_alloc_other
  Mem.valid_access_alloc_same
  Mem.valid_access_alloc_inv
  Mem.range_perm_free
  Mem.free_range_perm
  Mem.nextblock_free
  Mem.valid_block_free_1
  Mem.valid_block_free_2
  Mem.perm_free_1
  Mem.perm_free_2
  Mem.perm_free_3
  Mem.valid_access_free_1
  Mem.valid_access_free_2
  Mem.valid_access_free_inv_1
  Mem.valid_access_free_inv_2
  Mem.unchanged_on_refl
: mem. *)
Require Import compcert.common.Events.
(* compcert.common.Events:
Require Import String.
Require Import Coqlib.
Require Intv.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Globalenvs.

Inductive eventval: Type :=
  | EVint: int -> eventval
  | EVlong: int64 -> eventval
  | EVfloat: float -> eventval
  | EVsingle: float32 -> eventval
  | EVptr_global: ident -> ptrofs -> eventval.

Inductive event: Type :=
  | Event_syscall: string -> list eventval -> eventval -> event
  | Event_vload: memory_chunk -> ident -> ptrofs -> eventval -> event
  | Event_vstore: memory_chunk -> ident -> ptrofs -> eventval -> event
  | Event_annot: string -> list eventval -> event.

Definition trace := list event.

Definition E0 : trace := nil.

Definition Eapp (t1 t2: trace) : trace := t1 ++ t2.

CoInductive traceinf : Type :=
  | Econsinf: event -> traceinf -> traceinf.

Fixpoint Eappinf (t: trace) (T: traceinf) {struct t} : traceinf :=
  match t with
  | nil => T
  | ev :: t' => Econsinf ev (Eappinf t' T)
  end.

Infix "**" := Eapp (at level 60, right associativity).
Infix "***" := Eappinf (at level 60, right associativity).

Lemma E0_left: forall t, E0 ** t = t.

Lemma E0_right: forall t, t ** E0 = t.

Lemma Eapp_assoc: forall t1 t2 t3, (t1 ** t2) ** t3 = t1 ** (t2 ** t3).

Lemma Eapp_E0_inv: forall t1 t2, t1 ** t2 = E0 -> t1 = E0 /\ t2 = E0.
Proof (@app_eq_nil event).

Lemma E0_left_inf: forall T, E0 *** T = T.

Lemma Eappinf_assoc: forall t1 t2 T, (t1 ** t2) *** T = t1 *** (t2 *** T).

Hint Rewrite E0_left E0_right Eapp_assoc
             E0_left_inf Eappinf_assoc: trace_rewrite.

Opaque trace E0 Eapp Eappinf.

Ltac substTraceHyp :=
  match goal with
  | [ H: (@eq trace ?x ?y) |- _ ] =>
       subst x || clear H
  end.

Ltac decomposeTraceEq :=
  match goal with
  | [ |- (_ ** _) = (_ ** _) ] =>
      apply (f_equal2 Eapp); auto; decomposeTraceEq
  | _ =>
      auto
  end.

Ltac traceEq :=
  repeat substTraceHyp; autorewrite with trace_rewrite; decomposeTraceEq.

CoInductive traceinf_sim: traceinf -> traceinf -> Prop :=
  | traceinf_sim_cons: forall e T1 T2,
      traceinf_sim T1 T2 ->
      traceinf_sim (Econsinf e T1) (Econsinf e T2).

Lemma traceinf_sim_refl:
  forall T, traceinf_sim T T.

Lemma traceinf_sim_sym:
  forall T1 T2, traceinf_sim T1 T2 -> traceinf_sim T2 T1.

Lemma traceinf_sim_trans:
  forall T1 T2 T3,
  traceinf_sim T1 T2 -> traceinf_sim T2 T3 -> traceinf_sim T1 T3.

CoInductive traceinf_sim': traceinf -> traceinf -> Prop :=
  | traceinf_sim'_cons: forall t T1 T2,
      t <> E0 -> traceinf_sim' T1 T2 -> traceinf_sim' (t *** T1) (t *** T2).

Lemma traceinf_sim'_sim:
  forall T1 T2, traceinf_sim' T1 T2 -> traceinf_sim T1 T2.

CoInductive traceinf': Type :=
  | Econsinf': forall (t: trace) (T: traceinf'), t <> E0 -> traceinf'.

Program Definition split_traceinf' (t: trace) (T: traceinf') (NE: t <> E0): event * traceinf' :=
  match t with
  | nil => _
  | e :: nil => (e, T)
  | e :: t' => (e, Econsinf' t' T _)
  end.

CoFixpoint traceinf_of_traceinf' (T': traceinf') : traceinf :=
  match T' with
  | Econsinf' t T'' NOTEMPTY =>
      let (e, tl) := split_traceinf' t T'' NOTEMPTY in
      Econsinf e (traceinf_of_traceinf' tl)
  end.

Remark unroll_traceinf':
  forall T, T = match T with Econsinf' t T' NE => Econsinf' t T' NE end.

Remark unroll_traceinf:
  forall T, T = match T with Econsinf t T' => Econsinf t T' end.

Lemma traceinf_traceinf'_app:
  forall t T NE,
  traceinf_of_traceinf' (Econsinf' t T NE) = t *** traceinf_of_traceinf' T.

Definition trace_prefix (t1 t2: trace) :=
  exists t3, t2 = t1 ** t3.

Definition traceinf_prefix (t1: trace) (T2: traceinf) :=
  exists T3, T2 = t1 *** T3.

Lemma trace_prefix_app:
  forall t1 t2 t,
  trace_prefix t1 t2 ->
  trace_prefix (t ** t1) (t ** t2).

Lemma traceinf_prefix_app:
  forall t1 T2 t,
  traceinf_prefix t1 T2 ->
  traceinf_prefix (t ** t1) (t *** T2).

Set Implicit Arguments.

Section EVENTVAL.

Variable ge: Senv.t.

Inductive eventval_match: eventval -> typ -> val -> Prop :=
  | ev_match_int: forall i,
      eventval_match (EVint i) Tint (Vint i)
  | ev_match_long: forall i,
      eventval_match (EVlong i) Tlong (Vlong i)
  | ev_match_float: forall f,
      eventval_match (EVfloat f) Tfloat (Vfloat f)
  | ev_match_single: forall f,
      eventval_match (EVsingle f) Tsingle (Vsingle f)
  | ev_match_ptr: forall id b ofs,
      Senv.public_symbol ge id = true ->
      Senv.find_symbol ge id = Some b ->
      eventval_match (EVptr_global id ofs) Tptr (Vptr b ofs).

Inductive eventval_list_match: list eventval -> list typ -> list val -> Prop :=
  | evl_match_nil:
      eventval_list_match nil nil nil
  | evl_match_cons:
      forall ev1 evl ty1 tyl v1 vl,
      eventval_match ev1 ty1 v1 ->
      eventval_list_match evl tyl vl ->
      eventval_list_match (ev1::evl) (ty1::tyl) (v1::vl).

Lemma eventval_match_type:
  forall ev ty v,
  eventval_match ev ty v -> Val.has_type v ty.

Lemma eventval_list_match_length:
  forall evl tyl vl, eventval_list_match evl tyl vl -> List.length vl = List.length tyl.

Lemma eventval_match_lessdef:
  forall ev ty v1 v2,
  eventval_match ev ty v1 -> Val.lessdef v1 v2 -> eventval_match ev ty v2.

Lemma eventval_list_match_lessdef:
  forall evl tyl vl1, eventval_list_match evl tyl vl1 ->
  forall vl2, Val.lessdef_list vl1 vl2 -> eventval_list_match evl tyl vl2.

Lemma eventval_match_determ_1:
  forall ev ty v1 v2, eventval_match ev ty v1 -> eventval_match ev ty v2 -> v1 = v2.

Lemma eventval_match_determ_2:
  forall ev1 ev2 ty v, eventval_match ev1 ty v -> eventval_match ev2 ty v -> ev1 = ev2.

Lemma eventval_list_match_determ_2:
  forall evl1 tyl vl, eventval_list_match evl1 tyl vl ->
  forall evl2, eventval_list_match evl2 tyl vl -> evl1 = evl2.

Definition eventval_valid (ev: eventval) : Prop :=
  match ev with
  | EVint _ => True
  | EVlong _ => True
  | EVfloat _ => True
  | EVsingle _ => True
  | EVptr_global id ofs => Senv.public_symbol ge id = true
  end.

Definition eventval_type (ev: eventval) : typ :=
  match ev with
  | EVint _ => Tint
  | EVlong _ => Tlong
  | EVfloat _ => Tfloat
  | EVsingle _ => Tsingle
  | EVptr_global id ofs => Tptr
  end.

Lemma eventval_match_receptive:
  forall ev1 ty v1 ev2,
  eventval_match ev1 ty v1 ->
  eventval_valid ev1 -> eventval_valid ev2 -> eventval_type ev1 = eventval_type ev2 ->
  exists v2, eventval_match ev2 ty v2.

Lemma eventval_match_valid:
  forall ev ty v, eventval_match ev ty v -> eventval_valid ev.

Lemma eventval_match_same_type:
  forall ev1 ty v1 ev2 v2,
  eventval_match ev1 ty v1 -> eventval_match ev2 ty v2 -> eventval_type ev1 = eventval_type ev2.

End EVENTVAL.

Section EVENTVAL_INV.

Variables ge1 ge2: Senv.t.

Hypothesis public_preserved:
  forall id, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id.

Lemma eventval_valid_preserved:
  forall ev, eventval_valid ge1 ev -> eventval_valid ge2 ev.

Hypothesis symbols_preserved:
  forall id, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id.

Lemma eventval_match_preserved:
  forall ev ty v,
  eventval_match ge1 ev ty v -> eventval_match ge2 ev ty v.

Lemma eventval_list_match_preserved:
  forall evl tyl vl,
  eventval_list_match ge1 evl tyl vl -> eventval_list_match ge2 evl tyl vl.

End EVENTVAL_INV.

Section EVENTVAL_INJECT.

Variable f: block -> option (block * Z).
Variable ge1 ge2: Senv.t.

Definition symbols_inject : Prop :=
   (forall id, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id)
/\ (forall id b1 b2 delta,
     f b1 = Some(b2, delta) -> Senv.find_symbol ge1 id = Some b1 ->
     delta = 0 /\ Senv.find_symbol ge2 id = Some b2)
/\ (forall id b1,
     Senv.public_symbol ge1 id = true -> Senv.find_symbol ge1 id = Some b1 ->
     exists b2, f b1 = Some(b2, 0) /\ Senv.find_symbol ge2 id = Some b2)
/\ (forall b1 b2 delta,
     f b1 = Some(b2, delta) ->
     Senv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1).

Hypothesis symb_inj: symbols_inject.

Lemma eventval_match_inject:
  forall ev ty v1 v2,
  eventval_match ge1 ev ty v1 -> Val.inject f v1 v2 -> eventval_match ge2 ev ty v2.

Lemma eventval_match_inject_2:
  forall ev ty v1,
  eventval_match ge1 ev ty v1 ->
  exists v2, eventval_match ge2 ev ty v2 /\ Val.inject f v1 v2.

Lemma eventval_list_match_inject:
  forall evl tyl vl1, eventval_list_match ge1 evl tyl vl1 ->
  forall vl2, Val.inject_list f vl1 vl2 -> eventval_list_match ge2 evl tyl vl2.

End EVENTVAL_INJECT.

Section MATCH_TRACES.

Variable ge: Senv.t.

Inductive match_traces: trace -> trace -> Prop :=
  | match_traces_E0:
      match_traces nil nil
  | match_traces_syscall: forall id args res1 res2,
      eventval_valid ge res1 -> eventval_valid ge res2 -> eventval_type res1 = eventval_type res2 ->
      match_traces (Event_syscall id args res1 :: nil) (Event_syscall id args res2 :: nil)
  | match_traces_vload: forall chunk id ofs res1 res2,
      eventval_valid ge res1 -> eventval_valid ge res2 -> eventval_type res1 = eventval_type res2 ->
      match_traces (Event_vload chunk id ofs res1 :: nil) (Event_vload chunk id ofs res2 :: nil)
  | match_traces_vstore: forall chunk id ofs arg,
      match_traces (Event_vstore chunk id ofs arg :: nil) (Event_vstore chunk id ofs arg :: nil)
  | match_traces_annot: forall id args,
      match_traces (Event_annot id args :: nil) (Event_annot id args :: nil).

End MATCH_TRACES.

Section MATCH_TRACES_INV.

Variables ge1 ge2: Senv.t.

Hypothesis public_preserved:
  forall id, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id.

Lemma match_traces_preserved:
  forall t1 t2, match_traces ge1 t1 t2 -> match_traces ge2 t1 t2.

End MATCH_TRACES_INV.

Definition output_event (ev: event) : Prop :=
  match ev with
  | Event_syscall _ _ _ => False
  | Event_vload _ _ _ _ => False
  | Event_vstore _ _ _ _ => True
  | Event_annot _ _ => True
  end.

Fixpoint output_trace (t: trace) : Prop :=
  match t with
  | nil => True
  | ev :: t' => output_event ev /\ output_trace t'
  end.

Inductive volatile_load (ge: Senv.t):
                   memory_chunk -> mem -> block -> ptrofs -> trace -> val -> Prop :=
  | volatile_load_vol: forall chunk m b ofs id ev v,
      Senv.block_is_volatile ge b = true ->
      Senv.find_symbol ge id = Some b ->
      eventval_match ge ev (type_of_chunk chunk) v ->
      volatile_load ge chunk m b ofs
                      (Event_vload chunk id ofs ev :: nil)
                      (Val.load_result chunk v)
  | volatile_load_nonvol: forall chunk m b ofs v,
      Senv.block_is_volatile ge b = false ->
      Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v ->
      volatile_load ge chunk m b ofs E0 v.

Inductive volatile_store (ge: Senv.t):
                  memory_chunk -> mem -> block -> ptrofs -> val -> trace -> mem -> Prop :=
  | volatile_store_vol: forall chunk m b ofs id ev v,
      Senv.block_is_volatile ge b = true ->
      Senv.find_symbol ge id = Some b ->
      eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v) ->
      volatile_store ge chunk m b ofs v
                      (Event_vstore chunk id ofs ev :: nil)
                      m
  | volatile_store_nonvol: forall chunk m b ofs v m',
      Senv.block_is_volatile ge b = false ->
      Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m' ->
      volatile_store ge chunk m b ofs v E0 m'.

Definition extcall_sem : Type :=
  Senv.t -> list val -> mem -> trace -> val -> mem -> Prop.

Definition loc_out_of_bounds (m: mem) (b: block) (ofs: Z) : Prop :=
  ~Mem.perm m b ofs Max Nonempty.

Definition loc_not_writable (m: mem) (b: block) (ofs: Z) : Prop :=
  ~Mem.perm m b ofs Max Writable.

Definition loc_unmapped (f: meminj) (b: block) (ofs: Z): Prop :=
  f b = None.

Definition loc_out_of_reach (f: meminj) (m: mem) (b: block) (ofs: Z): Prop :=
  forall b0 delta,
  f b0 = Some(b, delta) -> ~Mem.perm m b0 (ofs - delta) Max Nonempty.

Definition inject_separated (f f': meminj) (m1 m2: mem): Prop :=
  forall b1 b2 delta,
  f b1 = None -> f' b1 = Some(b2, delta) ->
  ~Mem.valid_block m1 b1 /\ ~Mem.valid_block m2 b2.

Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
  mk_extcall_properties {

  ec_well_typed:
    forall ge vargs m1 t vres m2,
    sem ge vargs m1 t vres m2 ->
    Val.has_type vres (proj_sig_res sg);

  ec_symbols_preserved:
    forall ge1 ge2 vargs m1 t vres m2,
    Senv.equiv ge1 ge2 ->
    sem ge1 vargs m1 t vres m2 ->
    sem ge2 vargs m1 t vres m2;

  ec_valid_block:
    forall ge vargs m1 t vres m2 b,
    sem ge vargs m1 t vres m2 ->
    Mem.valid_block m1 b -> Mem.valid_block m2 b;

  ec_max_perm:
    forall ge vargs m1 t vres m2 b ofs p,
    sem ge vargs m1 t vres m2 ->
    Mem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p;

  ec_readonly:
    forall ge vargs m1 t vres m2,
    sem ge vargs m1 t vres m2 ->
    Mem.unchanged_on (loc_not_writable m1) m1 m2;

  ec_mem_extends:
    forall ge vargs m1 t vres m2 m1' vargs',
    sem ge vargs m1 t vres m2 ->
    Mem.extends m1 m1' ->
    Val.lessdef_list vargs vargs' ->
    exists vres', exists m2',
       sem ge vargs' m1' t vres' m2'
    /\ Val.lessdef vres vres'
    /\ Mem.extends m2 m2'
    /\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2';

  ec_mem_inject:
    forall ge1 ge2 vargs m1 t vres m2 f m1' vargs',
    symbols_inject f ge1 ge2 ->
    sem ge1 vargs m1 t vres m2 ->
    Mem.inject f m1 m1' ->
    Val.inject_list f vargs vargs' ->
    exists f', exists vres', exists m2',
       sem ge2 vargs' m1' t vres' m2'
    /\ Val.inject f' vres vres'
    /\ Mem.inject f' m2 m2'
    /\ Mem.unchanged_on (loc_unmapped f) m1 m2
    /\ Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'
    /\ inject_incr f f'
    /\ inject_separated f f' m1 m1';

  ec_trace_length:
    forall ge vargs m t vres m',
    sem ge vargs m t vres m' -> (length t <= 1)%nat;

  ec_receptive:
    forall ge vargs m t1 vres1 m1 t2,
    sem ge vargs m t1 vres1 m1 -> match_traces ge t1 t2 ->
    exists vres2, exists m2, sem ge vargs m t2 vres2 m2;

  ec_determ:
    forall ge vargs m t1 vres1 m1 t2 vres2 m2,
    sem ge vargs m t1 vres1 m1 -> sem ge vargs m t2 vres2 m2 ->
    match_traces ge t1 t2 /\ (t1 = t2 -> vres1 = vres2 /\ m1 = m2)
}.

Inductive volatile_load_sem (chunk: memory_chunk) (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | volatile_load_sem_intro: forall b ofs m t v,
      volatile_load ge chunk m b ofs t v ->
      volatile_load_sem chunk ge (Vptr b ofs :: nil) m t v m.

Lemma volatile_load_preserved:
  forall ge1 ge2 chunk m b ofs t v,
  Senv.equiv ge1 ge2 ->

Lemma volatile_load_extends:
  forall ge chunk m b ofs t v m',
  volatile_load ge chunk m b ofs t v ->
  Mem.extends m m' ->

Lemma volatile_load_inject:
  forall ge1 ge2 f chunk m b ofs t v b' ofs' m',
  symbols_inject f ge1 ge2 ->
  volatile_load ge1 chunk m b ofs t v ->
  Val.inject f (Vptr b ofs) (Vptr b' ofs') ->

Lemma volatile_load_receptive:
  forall ge chunk m b ofs t1 t2 v1,
  volatile_load ge chunk m b ofs t1 v1 -> match_traces ge t1 t2 ->
  exists v2, volatile_load ge chunk m b ofs t2 v2.

Lemma volatile_load_ok:
  forall chunk,
  extcall_properties (volatile_load_sem chunk)
                     (mksignature (Tptr :: nil) (Some (type_of_chunk chunk)) cc_default).

Inductive volatile_store_sem (chunk: memory_chunk) (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | volatile_store_sem_intro: forall b ofs m1 v t m2,
      volatile_store ge chunk m1 b ofs v t m2 ->
      volatile_store_sem chunk ge (Vptr b ofs :: v :: nil) m1 t Vundef m2.

Lemma volatile_store_preserved:
  forall ge1 ge2 chunk m1 b ofs v t m2,
  Senv.equiv ge1 ge2 ->

Lemma volatile_store_readonly:
  forall ge chunk1 m1 b1 ofs1 v t m2,
  volatile_store ge chunk1 m1 b1 ofs1 v t m2 ->
  Mem.unchanged_on (loc_not_writable m1) m1 m2.

Lemma volatile_store_extends:
  forall ge chunk m1 b ofs v t m2 m1' v',
  volatile_store ge chunk m1 b ofs v t m2 ->
  Mem.extends m1 m1' ->

Lemma volatile_store_inject:
  forall ge1 ge2 f chunk m1 b ofs v t m2 m1' b' ofs' v',
  symbols_inject f ge1 ge2 ->
  volatile_store ge1 chunk m1 b ofs v t m2 ->
  Val.inject f (Vptr b ofs) (Vptr b' ofs') ->

Lemma volatile_store_receptive:
  forall ge chunk m b ofs v t1 m1 t2,
  volatile_store ge chunk m b ofs v t1 m1 -> match_traces ge t1 t2 -> t1 = t2.

Lemma volatile_store_ok:
  forall chunk,
  extcall_properties (volatile_store_sem chunk)
                     (mksignature (Tptr :: type_of_chunk chunk :: nil) None cc_default).

Inductive extcall_malloc_sem (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_malloc_sem_intro: forall sz m m' b m'',
      Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b) ->
      Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m'' ->
      extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b Ptrofs.zero) m''.

Lemma extcall_malloc_ok:
  extcall_properties extcall_malloc_sem
                     (mksignature (Tptr :: nil) (Some Tptr) cc_default).

Inductive extcall_free_sem (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_free_sem_intro: forall b lo sz m m',
      Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz) ->
      Ptrofs.unsigned sz > 0 ->
      Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m' ->
      extcall_free_sem ge (Vptr b lo :: nil) m E0 Vundef m'.

Lemma extcall_free_ok:
  extcall_properties extcall_free_sem
                     (mksignature (Tptr :: nil) None cc_default).

Inductive extcall_memcpy_sem (sz al: Z) (ge: Senv.t):
                        list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_memcpy_sem_intro: forall bdst odst bsrc osrc m bytes m',
      al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz >= 0 -> (al | sz) ->
      (sz > 0 -> (al | Ptrofs.unsigned osrc)) ->
      (sz > 0 -> (al | Ptrofs.unsigned odst)) ->
      bsrc <> bdst \/ Ptrofs.unsigned osrc = Ptrofs.unsigned odst
                   \/ Ptrofs.unsigned osrc + sz <= Ptrofs.unsigned odst
                   \/ Ptrofs.unsigned odst + sz <= Ptrofs.unsigned osrc ->
      Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes ->
      Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m' ->
      extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m E0 Vundef m'.

Lemma extcall_memcpy_ok:
  forall sz al,
  extcall_properties (extcall_memcpy_sem sz al)
                     (mksignature (Tptr :: Tptr :: nil) None cc_default).

Inductive extcall_annot_sem (text: string) (targs: list typ) (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_annot_sem_intro: forall vargs m args,
      eventval_list_match ge args targs vargs ->
      extcall_annot_sem text targs ge vargs m (Event_annot text args :: E0) Vundef m.

Lemma extcall_annot_ok:
  forall text targs,
  extcall_properties (extcall_annot_sem text targs)
                     (mksignature targs None cc_default).

Inductive extcall_annot_val_sem (text: string) (targ: typ) (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_annot_val_sem_intro: forall varg m arg,
      eventval_match ge arg targ varg ->
      extcall_annot_val_sem text targ ge (varg :: nil) m (Event_annot text (arg :: nil) :: E0) varg m.

Lemma extcall_annot_val_ok:
  forall text targ,
  extcall_properties (extcall_annot_val_sem text targ)
                     (mksignature (targ :: nil) (Some targ) cc_default).

Inductive extcall_debug_sem (ge: Senv.t):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_debug_sem_intro: forall vargs m,
      extcall_debug_sem ge vargs m E0 Vundef m.

Lemma extcall_debug_ok:
  forall targs,
  extcall_properties extcall_debug_sem
                     (mksignature targs None cc_default).

Parameter external_functions_sem: String.string -> signature -> extcall_sem.

Axiom external_functions_properties:
  forall id sg, extcall_properties (external_functions_sem id sg) sg.

Parameter inline_assembly_sem: String.string -> signature -> extcall_sem.

Axiom inline_assembly_properties:
  forall id sg, extcall_properties (inline_assembly_sem id sg) sg.

Definition external_call (ef: external_function): extcall_sem :=
  match ef with
  | EF_external name sg  => external_functions_sem name sg
  | EF_builtin name sg   => external_functions_sem name sg
  | EF_runtime name sg   => external_functions_sem name sg
  | EF_vload chunk       => volatile_load_sem chunk
  | EF_vstore chunk      => volatile_store_sem chunk
  | EF_malloc            => extcall_malloc_sem
  | EF_free              => extcall_free_sem
  | EF_memcpy sz al      => extcall_memcpy_sem sz al
  | EF_annot kind txt targs   => extcall_annot_sem txt targs
  | EF_annot_val kind txt targ => extcall_annot_val_sem txt targ
  | EF_inline_asm txt sg clb => inline_assembly_sem txt sg
  | EF_debug kind txt targs => extcall_debug_sem
  end.

Theorem external_call_spec:
  forall ef,
  extcall_properties (external_call ef) (ef_sig ef).

Definition external_call_well_typed ef := ec_well_typed (external_call_spec ef).
Definition external_call_symbols_preserved ef := ec_symbols_preserved (external_call_spec ef).
Definition external_call_valid_block ef := ec_valid_block (external_call_spec ef).
Definition external_call_max_perm ef := ec_max_perm (external_call_spec ef).
Definition external_call_readonly ef := ec_readonly (external_call_spec ef).
Definition external_call_mem_extends ef := ec_mem_extends (external_call_spec ef).
Definition external_call_mem_inject_gen ef := ec_mem_inject (external_call_spec ef).
Definition external_call_trace_length ef := ec_trace_length (external_call_spec ef).
Definition external_call_receptive ef := ec_receptive (external_call_spec ef).
Definition external_call_determ ef := ec_determ (external_call_spec ef).

Lemma external_call_nextblock:
  forall ef ge vargs m1 t vres m2,
  external_call ef ge vargs m1 t vres m2 ->
  Ple (Mem.nextblock m1) (Mem.nextblock m2).

Definition meminj_preserves_globals (F V: Type) (ge: Genv.t F V) (f: block -> option (block * Z)) : Prop :=
     (forall id b, Genv.find_symbol ge id = Some b -> f b = Some(b, 0))
  /\ (forall b gv, Genv.find_var_info ge b = Some gv -> f b = Some(b, 0))
  /\ (forall b1 b2 delta gv, Genv.find_var_info ge b2 = Some gv -> f b1 = Some(b2, delta) -> b2 = b1).

Lemma external_call_mem_inject:
  forall ef F V (ge: Genv.t F V) vargs m1 t vres m2 f m1' vargs',

Lemma external_call_match_traces:
  forall ef ge vargs m t1 vres1 m1 t2 vres2 m2,
  external_call ef ge vargs m t1 vres1 m1 ->
  external_call ef ge vargs m t2 vres2 m2 ->
  match_traces ge t1 t2.

Lemma external_call_deterministic:
  forall ef ge vargs m t vres1 m1 vres2 m2,
  external_call ef ge vargs m t vres1 m1 ->
  external_call ef ge vargs m t vres2 m2 ->
  vres1 = vres2 /\ m1 = m2.

Section EVAL_BUILTIN_ARG.

Variable A: Type.
Variable ge: Senv.t.
Variable e: A -> val.
Variable sp: val.
Variable m: mem.

Inductive eval_builtin_arg: builtin_arg A -> val -> Prop :=
  | eval_BA: forall x,
      eval_builtin_arg (BA x) (e x)
  | eval_BA_int: forall n,
      eval_builtin_arg (BA_int n) (Vint n)
  | eval_BA_long: forall n,
      eval_builtin_arg (BA_long n) (Vlong n)
  | eval_BA_float: forall n,
      eval_builtin_arg (BA_float n) (Vfloat n)
  | eval_BA_single: forall n,
      eval_builtin_arg (BA_single n) (Vsingle n)
  | eval_BA_loadstack: forall chunk ofs v,
      Mem.loadv chunk m (Val.offset_ptr sp ofs) = Some v ->
      eval_builtin_arg (BA_loadstack chunk ofs) v
  | eval_BA_addrstack: forall ofs,
      eval_builtin_arg (BA_addrstack ofs) (Val.offset_ptr sp ofs)
  | eval_BA_loadglobal: forall chunk id ofs v,
      Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v ->
      eval_builtin_arg (BA_loadglobal chunk id ofs) v
  | eval_BA_addrglobal: forall id ofs,
      eval_builtin_arg (BA_addrglobal id ofs) (Senv.symbol_address ge id ofs)
  | eval_BA_splitlong: forall hi lo vhi vlo,
      eval_builtin_arg hi vhi -> eval_builtin_arg lo vlo ->
      eval_builtin_arg (BA_splitlong hi lo) (Val.longofwords vhi vlo)
  | eval_BA_addptr: forall a1 a2 v1 v2,
      eval_builtin_arg a1 v1 -> eval_builtin_arg a2 v2 ->
      eval_builtin_arg (BA_addptr a1 a2)
                       (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).

Definition eval_builtin_args (al: list (builtin_arg A)) (vl: list val) : Prop :=
  list_forall2 eval_builtin_arg al vl.

Lemma eval_builtin_arg_determ:
  forall a v, eval_builtin_arg a v -> forall v', eval_builtin_arg a v' -> v' = v.

Lemma eval_builtin_args_determ:
  forall al vl, eval_builtin_args al vl -> forall vl', eval_builtin_args al vl' -> vl' = vl.

End EVAL_BUILTIN_ARG.

Hint Constructors eval_builtin_arg: barg.

Section EVAL_BUILTIN_ARG_PRESERVED.

Variables A F1 V1 F2 V2: Type.
Variable ge1: Genv.t F1 V1.
Variable ge2: Genv.t F2 V2.
Variable e: A -> val.
Variable sp: val.
Variable m: mem.

Hypothesis symbols_preserved:
  forall id, Genv.find_symbol ge2 id = Genv.find_symbol ge1 id.

Lemma eval_builtin_arg_preserved:
  forall a v, eval_builtin_arg ge1 e sp m a v -> eval_builtin_arg ge2 e sp m a v.

Lemma eval_builtin_args_preserved:
  forall al vl, eval_builtin_args ge1 e sp m al vl -> eval_builtin_args ge2 e sp m al vl.

End EVAL_BUILTIN_ARG_PRESERVED.

Section EVAL_BUILTIN_ARG_LESSDEF.

Variable A: Type.
Variable ge: Senv.t.
Variables e1 e2: A -> val.
Variable sp: val.
Variables m1 m2: mem.

Hypothesis env_lessdef: forall x, Val.lessdef (e1 x) (e2 x).
Hypothesis mem_extends: Mem.extends m1 m2.

Lemma eval_builtin_arg_lessdef:
  forall a v1, eval_builtin_arg ge e1 sp m1 a v1 ->
  exists v2, eval_builtin_arg ge e2 sp m2 a v2 /\ Val.lessdef v1 v2.

Lemma eval_builtin_args_lessdef:
  forall al vl1, eval_builtin_args ge e1 sp m1 al vl1 ->
  exists vl2, eval_builtin_args ge e2 sp m2 al vl2 /\ Val.lessdef_list vl1 vl2.

End EVAL_BUILTIN_ARG_LESSDEF. *)
Require Import VST.concurrency.common.addressFiniteMap.
Require Import compcert.lib.Integers.
(* compcert.lib.Integers:
Require Import Eqdep_dec Zquot Zwf.
Require Import Coqlib.
Require Archi.

Inductive comparison : Type :=
  | Ceq : comparison               
  | Cne : comparison               
  | Clt : comparison               
  | Cle : comparison               
  | Cgt : comparison               
  | Cge : comparison.              

Definition negate_comparison (c: comparison): comparison :=
  match c with
  | Ceq => Cne
  | Cne => Ceq
  | Clt => Cge
  | Cle => Cgt
  | Cgt => Cle
  | Cge => Clt
  end.

Definition swap_comparison (c: comparison): comparison :=
  match c with
  | Ceq => Ceq
  | Cne => Cne
  | Clt => Cgt
  | Cle => Cge
  | Cgt => Clt
  | Cge => Cle
  end.

Module Type WORDSIZE.
  Parameter wordsize: nat.
  Axiom wordsize_not_zero: wordsize <> 0%nat.
End WORDSIZE.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Make(WS: WORDSIZE).

Definition wordsize: nat := WS.wordsize.
Definition zwordsize: Z := Z.of_nat wordsize.
Definition modulus : Z := two_power_nat wordsize.
Definition half_modulus : Z := modulus / 2.
Definition max_unsigned : Z := modulus - 1.
Definition max_signed : Z := half_modulus - 1.
Definition min_signed : Z := - half_modulus.

Remark wordsize_pos: zwordsize > 0.

Remark modulus_power: modulus = two_p zwordsize.

Remark modulus_pos: modulus > 0.

Record int: Type := mkint { intval: Z; intrange: -1 < intval < modulus }.

Fixpoint P_mod_two_p (p: positive) (n: nat) {struct n} : Z :=
  match n with
  | O => 0
  | S m =>
      match p with
      | xH => 1
      | xO q => Z.double (P_mod_two_p q m)
      | xI q => Z.succ_double (P_mod_two_p q m)
      end
  end.

Definition Z_mod_modulus (x: Z) : Z :=
  match x with
  | Z0 => 0
  | Zpos p => P_mod_two_p p wordsize
  | Zneg p => let r := P_mod_two_p p wordsize in if zeq r 0 then 0 else modulus - r
  end.

Lemma P_mod_two_p_range:
  forall n p, 0 <= P_mod_two_p p n < two_power_nat n.

Lemma P_mod_two_p_eq:
  forall n p, P_mod_two_p p n = (Zpos p) mod (two_power_nat n).

Lemma Z_mod_modulus_range:
  forall x, 0 <= Z_mod_modulus x < modulus.

Lemma Z_mod_modulus_range':
  forall x, -1 < Z_mod_modulus x < modulus.

Lemma Z_mod_modulus_eq:
  forall x, Z_mod_modulus x = x mod modulus.

Definition unsigned (n: int) : Z := intval n.

Definition signed (n: int) : Z :=
  let x := unsigned n in
  if zlt x half_modulus then x else x - modulus.

Definition repr (x: Z) : int :=
  mkint (Z_mod_modulus x) (Z_mod_modulus_range' x).

Definition zero := repr 0.
Definition one  := repr 1.
Definition mone := repr (-1).
Definition iwordsize := repr zwordsize.

Lemma mkint_eq:
  forall x y Px Py, x = y -> mkint x Px = mkint y Py.

Lemma eq_dec: forall (x y: int), {x = y} + {x <> y}.

Definition eq (x y: int) : bool :=
  if zeq (unsigned x) (unsigned y) then true else false.
Definition lt (x y: int) : bool :=
  if zlt (signed x) (signed y) then true else false.
Definition ltu (x y: int) : bool :=
  if zlt (unsigned x) (unsigned y) then true else false.

Definition neg (x: int) : int := repr (- unsigned x).

Definition add (x y: int) : int :=
  repr (unsigned x + unsigned y).
Definition sub (x y: int) : int :=
  repr (unsigned x - unsigned y).
Definition mul (x y: int) : int :=
  repr (unsigned x * unsigned y).

Definition divs (x y: int) : int :=
  repr (Z.quot (signed x) (signed y)).
Definition mods (x y: int) : int :=
  repr (Z.rem (signed x) (signed y)).

Definition divu (x y: int) : int :=
  repr (unsigned x / unsigned y).
Definition modu (x y: int) : int :=
  repr ((unsigned x) mod (unsigned y)).

Definition and (x y: int): int := repr (Z.land (unsigned x) (unsigned y)).
Definition or (x y: int): int := repr (Z.lor (unsigned x) (unsigned y)).
Definition xor (x y: int) : int := repr (Z.lxor (unsigned x) (unsigned y)).

Definition not (x: int) : int := xor x mone.

Definition shl (x y: int): int := repr (Z.shiftl (unsigned x) (unsigned y)).
Definition shru (x y: int): int := repr (Z.shiftr (unsigned x) (unsigned y)).
Definition shr (x y: int): int := repr (Z.shiftr (signed x) (unsigned y)).

Definition rol (x y: int) : int :=
  let n := (unsigned y) mod zwordsize in
  repr (Z.lor (Z.shiftl (unsigned x) n) (Z.shiftr (unsigned x) (zwordsize - n))).
Definition ror (x y: int) : int :=
  let n := (unsigned y) mod zwordsize in
  repr (Z.lor (Z.shiftr (unsigned x) n) (Z.shiftl (unsigned x) (zwordsize - n))).

Definition rolm (x a m: int): int := and (rol x a) m.

Definition shrx (x y: int): int :=
  divs x (shl one y).

Definition mulhu (x y: int): int := repr ((unsigned x * unsigned y) / modulus).
Definition mulhs (x y: int): int := repr ((signed x * signed y) / modulus).

Definition negative (x: int): int :=
  if lt x zero then one else zero.

Definition add_carry (x y cin: int): int :=
  if zlt (unsigned x + unsigned y + unsigned cin) modulus then zero else one.

Definition add_overflow (x y cin: int): int :=
  let s := signed x + signed y + signed cin in
  if zle min_signed s && zle s max_signed then zero else one.

Definition sub_borrow (x y bin: int): int :=
  if zlt (unsigned x - unsigned y - unsigned bin) 0 then one else zero.

Definition sub_overflow (x y bin: int): int :=
  let s := signed x - signed y - signed bin in
  if zle min_signed s && zle s max_signed then zero else one.

Definition shr_carry (x y: int) : int :=
  if lt x zero && negb (eq (and x (sub (shl one y) one)) zero)
  then one else zero.

Definition Zshiftin (b: bool) (x: Z) : Z :=
  if b then Z.succ_double x else Z.double x.

Definition Zzero_ext (n: Z) (x: Z) : Z :=
  Z.iter n
    (fun rec x => Zshiftin (Z.odd x) (rec (Z.div2 x)))
    (fun x => 0)
    x.

Definition Zsign_ext (n: Z) (x: Z) : Z :=
  Z.iter (Z.pred n)
    (fun rec x => Zshiftin (Z.odd x) (rec (Z.div2 x)))
    (fun x => if Z.odd x then -1 else 0)
    x.

Definition zero_ext (n: Z) (x: int) : int := repr (Zzero_ext n (unsigned x)).

Definition sign_ext (n: Z) (x: int) : int := repr (Zsign_ext n (unsigned x)).

Fixpoint Z_one_bits (n: nat) (x: Z) (i: Z) {struct n}: list Z :=
  match n with
  | O => nil
  | S m =>
      if Z.odd x
      then i :: Z_one_bits m (Z.div2 x) (i+1)
      else Z_one_bits m (Z.div2 x) (i+1)
  end.

Definition one_bits (x: int) : list int :=
  List.map repr (Z_one_bits wordsize (unsigned x) 0).

Definition is_power2 (x: int) : option int :=
  match Z_one_bits wordsize (unsigned x) 0 with
  | i :: nil => Some (repr i)
  | _ => None
  end.

Definition cmp (c: comparison) (x y: int) : bool :=
  match c with
  | Ceq => eq x y
  | Cne => negb (eq x y)
  | Clt => lt x y
  | Cle => negb (lt y x)
  | Cgt => lt y x
  | Cge => negb (lt x y)
  end.

Definition cmpu (c: comparison) (x y: int) : bool :=
  match c with
  | Ceq => eq x y
  | Cne => negb (eq x y)
  | Clt => ltu x y
  | Cle => negb (ltu y x)
  | Cgt => ltu y x
  | Cge => negb (ltu x y)
  end.

Definition is_false (x: int) : Prop := x = zero.
Definition is_true  (x: int) : Prop := x <> zero.
Definition notbool  (x: int) : int  := if eq x zero then one else zero.

Definition divmodu2 (nhi nlo: int) (d: int) : option (int * int) :=
  if eq_dec d zero then None else
   (let (q, r) := Z.div_eucl (unsigned nhi * modulus + unsigned nlo) (unsigned d) in
    if zle q max_unsigned then Some(repr q, repr r) else None).

Definition divmods2 (nhi nlo: int) (d: int) : option (int * int) :=
  if eq_dec d zero then None else
   (let (q, r) := Z.quotrem (signed nhi * modulus + unsigned nlo) (signed d) in
    if zle min_signed q && zle q max_signed then Some(repr q, repr r) else None).

Remark half_modulus_power:
  half_modulus = two_p (zwordsize - 1).

Remark half_modulus_modulus: modulus = 2 * half_modulus.

Remark half_modulus_pos: half_modulus > 0.

Remark min_signed_neg: min_signed < 0.

Remark max_signed_pos: max_signed >= 0.

Remark wordsize_max_unsigned: zwordsize <= max_unsigned.

Remark two_wordsize_max_unsigned: 2 * zwordsize - 1 <= max_unsigned.

Remark max_signed_unsigned: max_signed < max_unsigned.

Lemma unsigned_repr_eq:
  forall x, unsigned (repr x) = Z.modulo x modulus.

Lemma signed_repr_eq:
  forall x, signed (repr x) = if zlt (Z.modulo x modulus) half_modulus then Z.modulo x modulus else Z.modulo x modulus - modulus.

Section EQ_MODULO.

Variable modul: Z.
Hypothesis modul_pos: modul > 0.

Definition eqmod (x y: Z) : Prop := exists k, x = k * modul + y.

Lemma eqmod_refl: forall x, eqmod x x.

Lemma eqmod_refl2: forall x y, x = y -> eqmod x y.

Lemma eqmod_sym: forall x y, eqmod x y -> eqmod y x.

Lemma eqmod_trans: forall x y z, eqmod x y -> eqmod y z -> eqmod x z.

Lemma eqmod_small_eq:
  forall x y, eqmod x y -> 0 <= x < modul -> 0 <= y < modul -> x = y.

Lemma eqmod_mod_eq:
  forall x y, eqmod x y -> x mod modul = y mod modul.

Lemma eqmod_mod:
  forall x, eqmod x (x mod modul).

Lemma eqmod_add:
  forall a b c d, eqmod a b -> eqmod c d -> eqmod (a + c) (b + d).

Lemma eqmod_neg:
  forall x y, eqmod x y -> eqmod (-x) (-y).

Lemma eqmod_sub:
  forall a b c d, eqmod a b -> eqmod c d -> eqmod (a - c) (b - d).

Lemma eqmod_mult:
  forall a b c d, eqmod a c -> eqmod b d -> eqmod (a * b) (c * d).

End EQ_MODULO.

Lemma eqmod_divides:
  forall n m x y, eqmod n x y -> Z.divide m n -> eqmod m x y.

Hint Resolve modulus_pos: ints.

Definition eqm := eqmod modulus.

Lemma eqm_refl: forall x, eqm x x.
Proof (eqmod_refl modulus).
Hint Resolve eqm_refl: ints.

Lemma eqm_refl2:
  forall x y, x = y -> eqm x y.
Proof (eqmod_refl2 modulus).
Hint Resolve eqm_refl2: ints.

Lemma eqm_sym: forall x y, eqm x y -> eqm y x.
Proof (eqmod_sym modulus).
Hint Resolve eqm_sym: ints.

Lemma eqm_trans: forall x y z, eqm x y -> eqm y z -> eqm x z.
Proof (eqmod_trans modulus).
Hint Resolve eqm_trans: ints.

Lemma eqm_small_eq:
  forall x y, eqm x y -> 0 <= x < modulus -> 0 <= y < modulus -> x = y.
Proof (eqmod_small_eq modulus).
Hint Resolve eqm_small_eq: ints.

Lemma eqm_add:
  forall a b c d, eqm a b -> eqm c d -> eqm (a + c) (b + d).
Proof (eqmod_add modulus).
Hint Resolve eqm_add: ints.

Lemma eqm_neg:
  forall x y, eqm x y -> eqm (-x) (-y).
Proof (eqmod_neg modulus).
Hint Resolve eqm_neg: ints.

Lemma eqm_sub:
  forall a b c d, eqm a b -> eqm c d -> eqm (a - c) (b - d).
Proof (eqmod_sub modulus).
Hint Resolve eqm_sub: ints.

Lemma eqm_mult:
  forall a b c d, eqm a c -> eqm b d -> eqm (a * b) (c * d).
Proof (eqmod_mult modulus).
Hint Resolve eqm_mult: ints.

Lemma eqm_samerepr: forall x y, eqm x y -> repr x = repr y.

Lemma eqm_unsigned_repr:
  forall z, eqm z (unsigned (repr z)).
Hint Resolve eqm_unsigned_repr: ints.

Lemma eqm_unsigned_repr_l:
  forall a b, eqm a b -> eqm (unsigned (repr a)) b.
Hint Resolve eqm_unsigned_repr_l: ints.

Lemma eqm_unsigned_repr_r:
  forall a b, eqm a b -> eqm a (unsigned (repr b)).
Hint Resolve eqm_unsigned_repr_r: ints.

Lemma eqm_signed_unsigned:
  forall x, eqm (signed x) (unsigned x).

Theorem unsigned_range:
  forall i, 0 <= unsigned i < modulus.
Hint Resolve unsigned_range: ints.

Theorem unsigned_range_2:
  forall i, 0 <= unsigned i <= max_unsigned.
Hint Resolve unsigned_range_2: ints.

Theorem signed_range:
  forall i, min_signed <= signed i <= max_signed.

Theorem repr_unsigned:
  forall i, repr (unsigned i) = i.
Hint Resolve repr_unsigned: ints.

Lemma repr_signed:
  forall i, repr (signed i) = i.
Hint Resolve repr_signed: ints.

Opaque repr.

Lemma eqm_repr_eq: forall x y, eqm x (unsigned y) -> repr x = y.

Theorem unsigned_repr:
  forall z, 0 <= z <= max_unsigned -> unsigned (repr z) = z.
Hint Resolve unsigned_repr: ints.

Theorem signed_repr:
  forall z, min_signed <= z <= max_signed -> signed (repr z) = z.

Theorem signed_eq_unsigned:
  forall x, unsigned x <= max_signed -> signed x = unsigned x.

Theorem signed_positive:
  forall x, signed x >= 0 <-> unsigned x <= max_signed.

Theorem unsigned_zero: unsigned zero = 0.

Theorem unsigned_one: unsigned one = 1.

Theorem unsigned_mone: unsigned mone = modulus - 1.

Theorem signed_zero: signed zero = 0.

Theorem signed_one: zwordsize > 1 -> signed one = 1.

Theorem signed_mone: signed mone = -1.

Theorem one_not_zero: one <> zero.

Theorem unsigned_repr_wordsize:
  unsigned iwordsize = zwordsize.

Theorem eq_sym:
  forall x y, eq x y = eq y x.

Theorem eq_spec: forall (x y: int), if eq x y then x = y else x <> y.

Theorem eq_true: forall x, eq x x = true.

Theorem eq_false: forall x y, x <> y -> eq x y = false.

Theorem eq_signed:
  forall x y, eq x y = if zeq (signed x) (signed y) then true else false.

Theorem add_unsigned: forall x y, add x y = repr (unsigned x + unsigned y).

Theorem add_signed: forall x y, add x y = repr (signed x + signed y).

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_zero: forall x, add x zero = x.

Theorem add_zero_l: forall x, add zero x = x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_neg_zero: forall x, add x (neg x) = zero.

Theorem unsigned_add_carry:
  forall x y,
  unsigned (add x y) = unsigned x + unsigned y - unsigned (add_carry x y zero) * modulus.

Corollary unsigned_add_either:
  forall x y,
  unsigned (add x y) = unsigned x + unsigned y
  \/ unsigned (add x y) = unsigned x + unsigned y - modulus.

Theorem neg_repr: forall z, neg (repr z) = repr (-z).

Theorem neg_zero: neg zero = zero.

Theorem neg_involutive: forall x, neg (neg x) = x.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_l: forall x, sub x zero = x.

Theorem sub_zero_r: forall x, sub zero x = neg x.

Theorem sub_add_opp: forall x y, sub x y = add x (neg y).

Theorem sub_idem: forall x, sub x x = zero.

Theorem sub_add_l: forall x y z, sub (add x y) z = add (sub x z) y.

Theorem sub_add_r: forall x y z, sub x (add y z) = add (sub x z) (neg y).

Theorem sub_shifted:
  forall x y z,
  sub (add x z) (add y z) = sub x y.

Theorem sub_signed:
  forall x y, sub x y = repr (signed x - signed y).

Theorem unsigned_sub_borrow:
  forall x y,
  unsigned (sub x y) = unsigned x - unsigned y + unsigned (sub_borrow x y zero) * modulus.

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_zero: forall x, mul x zero = zero.

Theorem mul_one: forall x, mul x one = x.

Theorem mul_mone: forall x, mul x mone = neg x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem neg_mul_distr_l:
  forall x y, neg(mul x y) = mul (neg x) y.

Theorem neg_mul_distr_r:
   forall x y, neg(mul x y) = mul x (neg y).

Theorem mul_signed:
  forall x y, mul x y = repr (signed x * signed y).

Lemma modu_divu_Euclid:
  forall x y, y <> zero -> x = add (mul (divu x y) y) (modu x y).

Theorem modu_divu:
  forall x y, y <> zero -> modu x y = sub x (mul (divu x y) y).

Lemma mods_divs_Euclid:
  forall x y, x = add (mul (divs x y) y) (mods x y).

Theorem mods_divs:
  forall x y, mods x y = sub x (mul (divs x y) y).

Theorem divu_one:
  forall x, divu x one = x.

Theorem divs_one:
  forall x, zwordsize > 1 -> divs x one = x.

Theorem modu_one:
  forall x, modu x one = zero.

Theorem divs_mone:
  forall x, divs x mone = neg x.

Theorem mods_mone:
  forall x, mods x mone = zero.

Theorem divmodu2_divu_modu:
  forall n d,
  d <> zero -> divmodu2 zero n d = Some (divu n d, modu n d).

Lemma unsigned_signed:
  forall n, unsigned n = if lt n zero then signed n + modulus else signed n.

Theorem divmods2_divs_mods:
  forall n d,
  d <> zero -> n <> repr min_signed \/ d <> mone ->
  divmods2 (if lt n zero then mone else zero) n d = Some (divs n d, mods n d).

Remark Ztestbit_0: forall n, Z.testbit 0 n = false.
Proof Z.testbit_0_l.

Remark Ztestbit_1: forall n, Z.testbit 1 n = zeq n 0.

Remark Ztestbit_m1: forall n, 0 <= n -> Z.testbit (-1) n = true.

Remark Zshiftin_spec:
  forall b x, Zshiftin b x = 2 * x + (if b then 1 else 0).

Remark Zshiftin_inj:
  forall b1 x1 b2 x2,
  Zshiftin b1 x1 = Zshiftin b2 x2 -> b1 = b2 /\ x1 = x2.

Remark Zdecomp:
  forall x, x = Zshiftin (Z.odd x) (Z.div2 x).

Remark Ztestbit_shiftin:
  forall b x n,
  0 <= n ->
  Z.testbit (Zshiftin b x) n = if zeq n 0 then b else Z.testbit x (Z.pred n).

Remark Ztestbit_shiftin_base:
  forall b x, Z.testbit (Zshiftin b x) 0 = b.

Remark Ztestbit_shiftin_succ:
  forall b x n, 0 <= n -> Z.testbit (Zshiftin b x) (Z.succ n) = Z.testbit x n.

Remark Ztestbit_eq:
  forall n x, 0 <= n ->
  Z.testbit x n = if zeq n 0 then Z.odd x else Z.testbit (Z.div2 x) (Z.pred n).

Remark Ztestbit_base:
  forall x, Z.testbit x 0 = Z.odd x.

Remark Ztestbit_succ:
  forall n x, 0 <= n -> Z.testbit x (Z.succ n) = Z.testbit (Z.div2 x) n.

Lemma eqmod_same_bits:
  forall n x y,
  (forall i, 0 <= i < Z.of_nat n -> Z.testbit x i = Z.testbit y i) ->

Lemma eqm_same_bits:
  forall x y,
  (forall i, 0 <= i < zwordsize -> Z.testbit x i = Z.testbit y i) ->
  eqm x y.
Proof (eqmod_same_bits wordsize).

Lemma same_bits_eqmod:
  forall n x y i,
  eqmod (two_power_nat n) x y -> 0 <= i < Z.of_nat n ->

Lemma same_bits_eqm:
  forall x y i,
  eqm x y ->
  0 <= i < zwordsize ->
  Z.testbit x i = Z.testbit y i.
Proof (same_bits_eqmod wordsize).

Remark two_power_nat_infinity:
  forall x, 0 <= x -> exists n, x < two_power_nat n.

Lemma equal_same_bits:
  forall x y,
  (forall i, 0 <= i -> Z.testbit x i = Z.testbit y i) ->

Lemma Z_one_complement:
  forall i, 0 <= i ->
  forall x, Z.testbit (-x-1) i = negb (Z.testbit x i).

Lemma Ztestbit_above:
  forall n x i,
  0 <= x < two_power_nat n ->
  i >= Z.of_nat n ->

Lemma Ztestbit_above_neg:
  forall n x i,
  -two_power_nat n <= x < 0 ->
  i >= Z.of_nat n ->

Lemma Zsign_bit:
  forall n x,
  0 <= x < two_power_nat (S n) ->
  Z.testbit x (Z.of_nat n) = if zlt x (two_power_nat n) then false else true.

Lemma Zshiftin_ind:
  forall (P: Z -> Prop),
  P 0 ->
  (forall b x, 0 <= x -> P x -> P (Zshiftin b x)) ->
  forall x, 0 <= x -> P x.

Lemma Zshiftin_pos_ind:
  forall (P: Z -> Prop),
  P 1 ->
  (forall b x, 0 < x -> P x -> P (Zshiftin b x)) ->
  forall x, 0 < x -> P x.

Lemma Ztestbit_le:
  forall x y,
  0 <= y ->
  (forall i, 0 <= i -> Z.testbit x i = true -> Z.testbit y i = true) ->

Definition testbit (x: int) (i: Z) : bool := Z.testbit (unsigned x) i.

Lemma testbit_repr:
  forall x i,
  0 <= i < zwordsize ->
  testbit (repr x) i = Z.testbit x i.

Lemma same_bits_eq:
  forall x y,
  (forall i, 0 <= i < zwordsize -> testbit x i = testbit y i) ->
  x = y.

Lemma bits_above:
  forall x i, i >= zwordsize -> testbit x i = false.

Lemma bits_zero:
  forall i, testbit zero i = false.

Remark bits_one: forall n, testbit one n = zeq n 0.

Lemma bits_mone:
  forall i, 0 <= i < zwordsize -> testbit mone i = true.

Hint Rewrite bits_zero bits_mone : ints.

Ltac bit_solve :=
  intros; apply same_bits_eq; intros; autorewrite with ints; auto with bool.

Lemma sign_bit_of_unsigned:
  forall x, testbit x (zwordsize - 1) = if zlt (unsigned x) half_modulus then false else true.

Lemma bits_signed:
  forall x i, 0 <= i ->
  Z.testbit (signed x) i = testbit x (if zlt i zwordsize then i else zwordsize - 1).

Lemma bits_le:
  forall x y,
  (forall i, 0 <= i < zwordsize -> testbit x i = true -> testbit y i = true) ->
  unsigned x <= unsigned y.

Lemma bits_and:
  forall x y i, 0 <= i < zwordsize ->
  testbit (and x y) i = testbit x i && testbit y i.

Lemma bits_or:
  forall x y i, 0 <= i < zwordsize ->
  testbit (or x y) i = testbit x i || testbit y i.

Lemma bits_xor:
  forall x y i, 0 <= i < zwordsize ->
  testbit (xor x y) i = xorb (testbit x i) (testbit y i).

Lemma bits_not:
  forall x i, 0 <= i < zwordsize ->
  testbit (not x) i = negb (testbit x i).

Hint Rewrite bits_and bits_or bits_xor bits_not: ints.

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem and_zero: forall x, and x zero = zero.

Corollary and_zero_l: forall x, and zero x = zero.

Theorem and_mone: forall x, and x mone = x.

Corollary and_mone_l: forall x, and mone x = x.

Theorem and_idem: forall x, and x x = x.

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem or_zero: forall x, or x zero = x.

Corollary or_zero_l: forall x, or zero x = x.

Theorem or_mone: forall x, or x mone = mone.

Theorem or_idem: forall x, or x x = x.

Theorem and_or_distrib:
  forall x y z,
  and x (or y z) = or (and x y) (and x z).

Corollary and_or_distrib_l:
  forall x y z,
  and (or x y) z = or (and x z) (and y z).

Theorem or_and_distrib:
  forall x y z,
  or x (and y z) = and (or x y) (or x z).

Corollary or_and_distrib_l:
  forall x y z,
  or (and x y) z = and (or x z) (or y z).

Theorem and_or_absorb: forall x y, and x (or x y) = x.

Theorem or_and_absorb: forall x y, or x (and x y) = x.

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem xor_zero: forall x, xor x zero = x.

Corollary xor_zero_l: forall x, xor zero x = x.

Theorem xor_idem: forall x, xor x x = zero.

Theorem xor_zero_one: xor zero one = one.

Theorem xor_one_one: xor one one = zero.

Theorem xor_zero_equal: forall x y, xor x y = zero -> x = y.

Theorem xor_is_zero: forall x y, eq (xor x y) zero = eq x y.

Theorem and_xor_distrib:
  forall x y z,
  and x (xor y z) = xor (and x y) (and x z).

Theorem and_le:
  forall x y, unsigned (and x y) <= unsigned x.

Theorem or_le:
  forall x y, unsigned x <= unsigned (or x y).

Theorem not_involutive:
  forall (x: int), not (not x) = x.

Theorem not_zero:
  not zero = mone.

Theorem not_mone:
  not mone = zero.

Theorem not_or_and_not:
  forall x y, not (or x y) = and (not x) (not y).

Theorem not_and_or_not:
  forall x y, not (and x y) = or (not x) (not y).

Theorem and_not_self:
  forall x, and x (not x) = zero.

Theorem or_not_self:
  forall x, or x (not x) = mone.

Theorem xor_not_self:
  forall x, xor x (not x) = mone.

Lemma unsigned_not:
  forall x, unsigned (not x) = max_unsigned - unsigned x.

Theorem not_neg:
  forall x, not x = add (neg x) mone.

Theorem neg_not:
  forall x, neg x = add (not x) one.

Theorem sub_add_not:
  forall x y, sub x y = add (add x (not y)) one.

Theorem sub_add_not_3:
  forall x y b,
  b = zero \/ b = one ->
  sub (sub x y) b = add (add x (not y)) (xor b one).

Theorem sub_borrow_add_carry:
  forall x y b,
  b = zero \/ b = one ->
  sub_borrow x y b = xor (add_carry x (not y) (xor b one)) one.

Lemma Z_add_is_or:
  forall i, 0 <= i ->
  forall x y,
  (forall j, 0 <= j <= i -> Z.testbit x j && Z.testbit y j = false) ->

Theorem add_is_or:
  forall x y,
  and x y = zero ->
  add x y = or x y.

Theorem xor_is_or:
  forall x y, and x y = zero -> xor x y = or x y.

Theorem add_is_xor:
  forall x y,
  and x y = zero ->
  add x y = xor x y.

Theorem add_and:
  forall x y z,
  and y z = zero ->
  add (and x y) (and x z) = and x (or y z).

Lemma bits_shl:
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shl x y) i =
  if zlt i (unsigned y) then false else testbit x (i - unsigned y).

Lemma bits_shru:
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shru x y) i =
  if zlt (i + unsigned y) zwordsize then testbit x (i + unsigned y) else false.

Lemma bits_shr:
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shr x y) i =
  testbit x (if zlt (i + unsigned y) zwordsize then i + unsigned y else zwordsize - 1).

Hint Rewrite bits_shl bits_shru bits_shr: ints.

Theorem shl_zero: forall x, shl x zero = x.

Lemma bitwise_binop_shl:
  forall f f' x y n,
  (forall x y i, 0 <= i < zwordsize -> testbit (f x y) i = f' (testbit x i) (testbit y i)) ->
  f' false false = false ->
  f (shl x n) (shl y n) = shl (f x y) n.

Theorem and_shl:
  forall x y n,
  and (shl x n) (shl y n) = shl (and x y) n.

Theorem or_shl:
  forall x y n,
  or (shl x n) (shl y n) = shl (or x y) n.

Theorem xor_shl:
  forall x y n,
  xor (shl x n) (shl y n) = shl (xor x y) n.

Lemma ltu_inv:
  forall x y, ltu x y = true -> 0 <= unsigned x < unsigned y.

Lemma ltu_iwordsize_inv:
  forall x, ltu x iwordsize = true -> 0 <= unsigned x < zwordsize.

Theorem shl_shl:
  forall x y z,
  ltu y iwordsize = true ->
  ltu z iwordsize = true ->
  ltu (add y z) iwordsize = true ->
  shl (shl x y) z = shl x (add y z).

Theorem sub_ltu:
  forall x y,
    ltu x y = true ->
    0 <= unsigned y - unsigned x <= unsigned y.

Theorem shru_zero: forall x, shru x zero = x.

Lemma bitwise_binop_shru:
  forall f f' x y n,
  (forall x y i, 0 <= i < zwordsize -> testbit (f x y) i = f' (testbit x i) (testbit y i)) ->
  f' false false = false ->
  f (shru x n) (shru y n) = shru (f x y) n.

Theorem and_shru:
  forall x y n,
  and (shru x n) (shru y n) = shru (and x y) n.

Theorem or_shru:
  forall x y n,
  or (shru x n) (shru y n) = shru (or x y) n.

Theorem xor_shru:
  forall x y n,
  xor (shru x n) (shru y n) = shru (xor x y) n.

Theorem shru_shru:
  forall x y z,
  ltu y iwordsize = true ->
  ltu z iwordsize = true ->
  ltu (add y z) iwordsize = true ->
  shru (shru x y) z = shru x (add y z).

Theorem shr_zero: forall x, shr x zero = x.

Lemma bitwise_binop_shr:
  forall f f' x y n,
  (forall x y i, 0 <= i < zwordsize -> testbit (f x y) i = f' (testbit x i) (testbit y i)) ->
  f (shr x n) (shr y n) = shr (f x y) n.

Theorem and_shr:
  forall x y n,
  and (shr x n) (shr y n) = shr (and x y) n.

Theorem or_shr:
  forall x y n,
  or (shr x n) (shr y n) = shr (or x y) n.

Theorem xor_shr:
  forall x y n,
  xor (shr x n) (shr y n) = shr (xor x y) n.

Theorem shr_shr:
  forall x y z,
  ltu y iwordsize = true ->
  ltu z iwordsize = true ->
  ltu (add y z) iwordsize = true ->
  shr (shr x y) z = shr x (add y z).

Theorem and_shr_shru:
  forall x y z,
  and (shr x z) (shru y z) = shru (and x y) z.

Theorem shr_and_shru_and:
  forall x y z,
  shru (shl z y) y = z ->
  and (shr x y) z = and (shru x y) z.

Theorem shru_lt_zero:
  forall x,
  shru x (repr (zwordsize - 1)) = if lt x zero then one else zero.

Theorem shr_lt_zero:
  forall x,
  shr x (repr (zwordsize - 1)) = if lt x zero then mone else zero.

Lemma bits_rol:
  forall x y i,
  0 <= i < zwordsize ->
  testbit (rol x y) i = testbit x ((i - unsigned y) mod zwordsize).

Lemma bits_ror:
  forall x y i,
  0 <= i < zwordsize ->
  testbit (ror x y) i = testbit x ((i + unsigned y) mod zwordsize).

Hint Rewrite bits_rol bits_ror: ints.

Theorem shl_rolm:
  forall x n,
  ltu n iwordsize = true ->
  shl x n = rolm x n (shl mone n).

Theorem shru_rolm:
  forall x n,
  ltu n iwordsize = true ->
  shru x n = rolm x (sub iwordsize n) (shru mone n).

Theorem rol_zero:
  forall x,
  rol x zero = x.

Lemma bitwise_binop_rol:
  forall f f' x y n,
  (forall x y i, 0 <= i < zwordsize -> testbit (f x y) i = f' (testbit x i) (testbit y i)) ->
  rol (f x y) n = f (rol x n) (rol y n).

Theorem rol_and:
  forall x y n,
  rol (and x y) n = and (rol x n) (rol y n).

Theorem rol_or:
  forall x y n,
  rol (or x y) n = or (rol x n) (rol y n).

Theorem rol_xor:
  forall x y n,
  rol (xor x y) n = xor (rol x n) (rol y n).

Theorem rol_rol:
  forall x n m,
  Z.divide zwordsize modulus ->

Theorem rolm_zero:
  forall x m,
  rolm x zero m = and x m.

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  Z.divide zwordsize modulus ->

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (or m1 m2).

Theorem ror_rol:
  forall x y,
  ltu y iwordsize = true ->
  ror x y = rol x (sub iwordsize y).

Theorem ror_rol_neg:
  forall x y, (zwordsize | modulus) -> ror x y = rol x (neg y).

Theorem or_ror:
  forall x y z,
  ltu y iwordsize = true ->
  ltu z iwordsize = true ->
  add y z = iwordsize ->
  ror x z = or (shl x y) (shru x z).

Fixpoint powerserie (l: list Z): Z :=
  match l with
  | nil => 0
  | x :: xs => two_p x + powerserie xs
  end.

Lemma Z_one_bits_powerserie:
  forall x, 0 <= x < modulus -> x = powerserie (Z_one_bits wordsize x 0).

Lemma Z_one_bits_range:
  forall x i, In i (Z_one_bits wordsize x 0) -> 0 <= i < zwordsize.

Lemma is_power2_rng:
  forall n logn,
  is_power2 n = Some logn ->
  0 <= unsigned logn < zwordsize.

Theorem is_power2_range:
  forall n logn,
  is_power2 n = Some logn -> ltu logn iwordsize = true.

Lemma is_power2_correct:
  forall n logn,
  is_power2 n = Some logn ->
  unsigned n = two_p (unsigned logn).

Remark two_p_range:
  forall n,
  0 <= n < zwordsize ->
  0 <= two_p n <= max_unsigned.

Remark Z_one_bits_zero:
  forall n i, Z_one_bits n 0 i = nil.

Remark Z_one_bits_two_p:
  forall n x i,
  0 <= x < Z.of_nat n ->

Lemma is_power2_two_p:
  forall n, 0 <= n < zwordsize ->
  is_power2 (repr (two_p n)) = Some (repr n).

Lemma Zshiftl_mul_two_p:
  forall x n, 0 <= n -> Z.shiftl x n = x * two_p n.

Lemma shl_mul_two_p:
  forall x y,
  shl x y = mul x (repr (two_p (unsigned y))).

Theorem shl_mul:
  forall x y,
  shl x y = mul x (shl one y).

Theorem mul_pow2:
  forall x n logn,
  is_power2 n = Some logn ->
  mul x n = shl x logn.

Theorem shifted_or_is_add:
  forall x y n,
  0 <= n < zwordsize ->
  unsigned y < two_p n ->
  or (shl x (repr n)) y = repr(unsigned x * two_p n + unsigned y).

Lemma Zshiftr_div_two_p:
  forall x n, 0 <= n -> Z.shiftr x n = x / two_p n.

Lemma shru_div_two_p:
  forall x y,
  shru x y = repr (unsigned x / two_p (unsigned y)).

Theorem divu_pow2:
  forall x n logn,
  is_power2 n = Some logn ->
  divu x n = shru x logn.

Lemma shr_div_two_p:
  forall x y,
  shr x y = repr (signed x / two_p (unsigned y)).

Theorem divs_pow2:
  forall x n logn,
  is_power2 n = Some logn ->
  divs x n = shrx x logn.

Lemma Ztestbit_mod_two_p:
  forall n x i,
  0 <= n -> 0 <= i ->
  Z.testbit (x mod (two_p n)) i = if zlt i n then Z.testbit x i else false.

Corollary Ztestbit_two_p_m1:
  forall n i, 0 <= n -> 0 <= i ->
  Z.testbit (two_p n - 1) i = if zlt i n then true else false.

Theorem modu_and:
  forall x n logn,
  is_power2 n = Some logn ->
  modu x n = and x (sub n one).

Lemma Zquot_Zdiv:
  forall x y,
  y > 0 ->
  Z.quot x y = if zlt x 0 then (x + y - 1) / y else x / y.

Theorem shrx_zero:
  forall x, zwordsize > 1 -> shrx x zero = x.

Theorem shrx_shr:
  forall x y,
  ltu y (repr (zwordsize - 1)) = true ->
  shrx x y = shr (if lt x zero then add x (sub (shl one y) one) else x) y.

Theorem shrx_shr_2:
  forall x y,
  ltu y (repr (zwordsize - 1)) = true ->
  shrx x y = shr (add x (shru (shr x (repr (zwordsize - 1))) (sub iwordsize y))) y.

Lemma Zdiv_shift:
  forall x y, y > 0 ->
  (x + (y - 1)) / y = x / y + if zeq (Z.modulo x y) 0 then 0 else 1.

Theorem shrx_carry:
  forall x y,
  ltu y (repr (zwordsize - 1)) = true ->
  shrx x y = add (shr x y) (shr_carry x y).

Lemma shr_shru_positive:
  forall x y,
  signed x >= 0 ->
  shr x y = shru x y.

Lemma and_positive:
  forall x y, signed y >= 0 -> signed (and x y) >= 0.

Theorem shr_and_is_shru_and:
  forall x y z,
  lt y zero = false -> shr (and x y) z = shru (and x y) z.

Lemma Ziter_base:
  forall (A: Type) n (f: A -> A) x, n <= 0 -> Z.iter n f x = x.

Lemma Ziter_succ:
  forall (A: Type) n (f: A -> A) x,
  0 <= n -> Z.iter (Z.succ n) f x = f (Z.iter n f x).

Lemma Znatlike_ind:
  forall (P: Z -> Prop),
  (forall n, n <= 0 -> P n) ->
  (forall n, 0 <= n -> P n -> P (Z.succ n)) ->

Lemma Zzero_ext_spec:
  forall n x i, 0 <= i ->
  Z.testbit (Zzero_ext n x) i = if zlt i n then Z.testbit x i else false.

Lemma bits_zero_ext:
  forall n x i, 0 <= i ->
  testbit (zero_ext n x) i = if zlt i n then testbit x i else false.

Lemma Zsign_ext_spec:
  forall n x i, 0 <= i -> 0 < n ->
  Z.testbit (Zsign_ext n x) i = Z.testbit x (if zlt i n then i else n - 1).

Lemma bits_sign_ext:
  forall n x i, 0 <= i < zwordsize -> 0 < n ->
  testbit (sign_ext n x) i = testbit x (if zlt i n then i else n - 1).

Hint Rewrite bits_zero_ext bits_sign_ext: ints.

Theorem zero_ext_above:
  forall n x, n >= zwordsize -> zero_ext n x = x.

Theorem sign_ext_above:
  forall n x, n >= zwordsize -> sign_ext n x = x.

Theorem zero_ext_and:
  forall n x, 0 <= n -> zero_ext n x = and x (repr (two_p n - 1)).

Theorem zero_ext_mod:
  forall n x, 0 <= n < zwordsize ->
  unsigned (zero_ext n x) = Z.modulo (unsigned x) (two_p n).

Theorem zero_ext_widen:
  forall x n n', 0 <= n <= n' ->
  zero_ext n' (zero_ext n x) = zero_ext n x.

Theorem sign_ext_widen:
  forall x n n', 0 < n  <= n' ->
  sign_ext n' (sign_ext n x) = sign_ext n x.

Theorem sign_zero_ext_widen:
  forall x n n', 0 <= n < n' ->
  sign_ext n' (zero_ext n x) = zero_ext n x.

Theorem zero_ext_narrow:
  forall x n n', 0 <= n <= n' ->
  zero_ext n (zero_ext n' x) = zero_ext n x.

Theorem sign_ext_narrow:
  forall x n n', 0 < n <= n' ->
  sign_ext n (sign_ext n' x) = sign_ext n x.

Theorem zero_sign_ext_narrow:
  forall x n n', 0 < n <= n' ->
  zero_ext n (sign_ext n' x) = zero_ext n x.

Theorem zero_ext_idem:
  forall n x, 0 <= n -> zero_ext n (zero_ext n x) = zero_ext n x.

Theorem sign_ext_idem:
  forall n x, 0 < n -> sign_ext n (sign_ext n x) = sign_ext n x.

Theorem sign_ext_zero_ext:
  forall n x, 0 < n -> sign_ext n (zero_ext n x) = sign_ext n x.

Theorem zero_ext_sign_ext:
  forall n x, 0 < n -> zero_ext n (sign_ext n x) = zero_ext n x.

Theorem sign_ext_equal_if_zero_equal:
  forall n x y, 0 < n ->
  zero_ext n x = zero_ext n y ->
  sign_ext n x = sign_ext n y.

Theorem zero_ext_shru_shl:
  forall n x,
  0 < n < zwordsize ->
  let y := repr (zwordsize - n) in
  zero_ext n x = shru (shl x y) y.

Theorem sign_ext_shr_shl:
  forall n x,
  0 < n < zwordsize ->
  let y := repr (zwordsize - n) in
  sign_ext n x = shr (shl x y) y.

Lemma zero_ext_range:
  forall n x, 0 <= n < zwordsize -> 0 <= unsigned (zero_ext n x) < two_p n.

Lemma eqmod_zero_ext:
  forall n x, 0 <= n < zwordsize -> eqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x).

Lemma sign_ext_range:
  forall n x, 0 < n < zwordsize -> -two_p (n-1) <= signed (sign_ext n x) < two_p (n-1).

Lemma eqmod_sign_ext':
  forall n x, 0 < n < zwordsize ->
  eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x).

Lemma eqmod_sign_ext:
  forall n x, 0 < n < zwordsize ->
  eqmod (two_p n) (signed (sign_ext n x)) (unsigned x).

Theorem one_bits_range:
  forall x i, In i (one_bits x) -> ltu i iwordsize = true.

Fixpoint int_of_one_bits (l: list int) : int :=
  match l with
  | nil => zero
  | a :: b => add (shl one a) (int_of_one_bits b)
  end.

Theorem one_bits_decomp:
  forall x, x = int_of_one_bits (one_bits x).

Theorem negate_cmp:
  forall c x y, cmp (negate_comparison c) x y = negb (cmp c x y).

Theorem negate_cmpu:
  forall c x y, cmpu (negate_comparison c) x y = negb (cmpu c x y).

Theorem swap_cmp:
  forall c x y, cmp (swap_comparison c) x y = cmp c y x.

Theorem swap_cmpu:
  forall c x y, cmpu (swap_comparison c) x y = cmpu c y x.

Lemma translate_eq:
  forall x y d,
  eq (add x d) (add y d) = eq x y.

Lemma translate_ltu:
  forall x y d,
  0 <= unsigned x + unsigned d <= max_unsigned ->
  0 <= unsigned y + unsigned d <= max_unsigned ->
  ltu (add x d) (add y d) = ltu x y.

Theorem translate_cmpu:
  forall c x y d,
  0 <= unsigned x + unsigned d <= max_unsigned ->
  0 <= unsigned y + unsigned d <= max_unsigned ->
  cmpu c (add x d) (add y d) = cmpu c x y.

Lemma translate_lt:
  forall x y d,
  min_signed <= signed x + signed d <= max_signed ->
  min_signed <= signed y + signed d <= max_signed ->
  lt (add x d) (add y d) = lt x y.

Theorem translate_cmp:
  forall c x y d,
  min_signed <= signed x + signed d <= max_signed ->
  min_signed <= signed y + signed d <= max_signed ->
  cmp c (add x d) (add y d) = cmp c x y.

Theorem notbool_isfalse_istrue:
  forall x, is_false x -> is_true (notbool x).

Theorem notbool_istrue_isfalse:
  forall x, is_true x -> is_false (notbool x).

Theorem ltu_range_test:
  forall x y,
  ltu x y = true -> unsigned y <= max_signed ->
  0 <= signed x < unsigned y.

Theorem lt_sub_overflow:
  forall x y,
  xor (sub_overflow x y zero) (negative (sub x y)) = if lt x y then one else zero.

Lemma signed_eq:
  forall x y, eq x y = zeq (signed x) (signed y).

Lemma not_lt:
  forall x y, negb (lt y x) = (lt x y || eq x y).

Lemma lt_not:
  forall x y, lt y x = negb (lt x y) && negb (eq x y).

Lemma not_ltu:
  forall x y, negb (ltu y x) = (ltu x y || eq x y).

Lemma ltu_not:
  forall x y, ltu y x = negb (ltu x y) && negb (eq x y).

Definition no_overlap (ofs1: int) (sz1: Z) (ofs2: int) (sz2: Z) : bool :=
  let x1 := unsigned ofs1 in let x2 := unsigned ofs2 in
     zlt (x1 + sz1) modulus && zlt (x2 + sz2) modulus
  && (zle (x1 + sz1) x2 || zle (x2 + sz2) x1).

Lemma no_overlap_sound:
  forall ofs1 sz1 ofs2 sz2 base,
  sz1 > 0 -> sz2 > 0 -> no_overlap ofs1 sz1 ofs2 sz2 = true ->
  unsigned (add base ofs1) + sz1 <= unsigned (add base ofs2)
  \/ unsigned (add base ofs2) + sz2 <= unsigned (add base ofs1).

Definition Zsize (x: Z) : Z :=
  match x with
  | Zpos p => Zpos (Pos.size p)
  | _ => 0
  end.

Definition size (x: int) : Z := Zsize (unsigned x).

Remark Zsize_pos: forall x, 0 <= Zsize x.

Remark Zsize_pos': forall x, 0 < x -> 0 < Zsize x.

Lemma Zsize_shiftin:
  forall b x, 0 < x -> Zsize (Zshiftin b x) = Z.succ (Zsize x).

Lemma Ztestbit_size_1:
  forall x, 0 < x -> Z.testbit x (Z.pred (Zsize x)) = true.

Lemma Ztestbit_size_2:
  forall x, 0 <= x -> forall i, i >= Zsize x -> Z.testbit x i = false.

Lemma Zsize_interval_1:
  forall x, 0 <= x -> 0 <= x < two_p (Zsize x).

Lemma Zsize_interval_2:
  forall x n, 0 <= n -> 0 <= x < two_p n -> n >= Zsize x.

Lemma Zsize_monotone:
  forall x y, 0 <= x <= y -> Zsize x <= Zsize y.

Theorem size_zero: size zero = 0.

Theorem bits_size_1:
  forall x, x = zero \/ testbit x (Z.pred (size x)) = true.

Theorem bits_size_2:
  forall x i, size x <= i -> testbit x i = false.

Theorem size_range:
  forall x, 0 <= size x <= zwordsize.

Theorem bits_size_3:
  forall x n,
  0 <= n ->
  (forall i, n <= i < zwordsize -> testbit x i = false) ->
  size x <= n.

Theorem bits_size_4:
  forall x n,
  0 <= n ->
  testbit x (Z.pred n) = true ->

Theorem size_interval_1:
  forall x, 0 <= unsigned x < two_p (size x).

Theorem size_interval_2:
  forall x n, 0 <= n -> 0 <= unsigned x < two_p n -> n >= size x.

Theorem size_and:
  forall a b, size (and a b) <= Z.min (size a) (size b).

Corollary and_interval:
  forall a b, 0 <= unsigned (and a b) < two_p (Z.min (size a) (size b)).

Theorem size_or:
  forall a b, size (or a b) = Z.max (size a) (size b).

Corollary or_interval:
  forall a b, 0 <= unsigned (or a b) < two_p (Z.max (size a) (size b)).

Theorem size_xor:
  forall a b, size (xor a b) <= Z.max (size a) (size b).

Corollary xor_interval:
  forall a b, 0 <= unsigned (xor a b) < two_p (Z.max (size a) (size b)).

End Make.

Module Wordsize_32.
  Definition wordsize := 32%nat.
  Remark wordsize_not_zero: wordsize <> 0%nat.
End Wordsize_32.

Strategy opaque [Wordsize_32.wordsize].

Module Int := Make(Wordsize_32).

Strategy 0 [Wordsize_32.wordsize].

Notation int := Int.int.

Remark int_wordsize_divides_modulus:
  Z.divide (Z.of_nat Int.wordsize) Int.modulus.

Module Wordsize_8.
  Definition wordsize := 8%nat.
  Remark wordsize_not_zero: wordsize <> 0%nat.
End Wordsize_8.

Strategy opaque [Wordsize_8.wordsize].

Module Byte := Make(Wordsize_8).

Strategy 0 [Wordsize_8.wordsize].

Notation byte := Byte.int.

Module Wordsize_64.
  Definition wordsize := 64%nat.
  Remark wordsize_not_zero: wordsize <> 0%nat.
End Wordsize_64.

Strategy opaque [Wordsize_64.wordsize].

Module Int64.

Include Make(Wordsize_64).

Definition iwordsize': Int.int := Int.repr zwordsize.

Definition shl' (x: int) (y: Int.int): int :=
  repr (Z.shiftl (unsigned x) (Int.unsigned y)).
Definition shru' (x: int) (y: Int.int): int :=
  repr (Z.shiftr (unsigned x) (Int.unsigned y)).
Definition shr' (x: int) (y: Int.int): int :=
  repr (Z.shiftr (signed x) (Int.unsigned y)).
Definition rol' (x: int) (y: Int.int): int :=
  rol x (repr (Int.unsigned y)).
Definition shrx' (x: int) (y: Int.int): int :=
  divs x (shl' one y).
Definition shr_carry' (x: int) (y: Int.int): int :=
  if lt x zero && negb (eq (and x (sub (shl' one y) one)) zero)
  then one else zero.

Lemma bits_shl':
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shl' x y) i =
  if zlt i (Int.unsigned y) then false else testbit x (i - Int.unsigned y).

Lemma bits_shru':
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shru' x y) i =
  if zlt (i + Int.unsigned y) zwordsize then testbit x (i + Int.unsigned y) else false.

Lemma bits_shr':
  forall x y i,
  0 <= i < zwordsize ->
  testbit (shr' x y) i =
  testbit x (if zlt (i + Int.unsigned y) zwordsize then i + Int.unsigned y else zwordsize - 1).

Lemma shl'_mul_two_p:
  forall x y,
  shl' x y = mul x (repr (two_p (Int.unsigned y))).

Lemma shl'_one_two_p:
  forall y, shl' one y = repr (two_p (Int.unsigned y)).

Theorem shl'_mul:
  forall x y,
  shl' x y = mul x (shl' one y).

Theorem shl'_zero:
  forall x, shl' x Int.zero = x.

Theorem shru'_zero :
  forall x, shru' x Int.zero = x.

Theorem shr'_zero :
  forall x, shr' x Int.zero = x.

Theorem shrx'_zero:
  forall x, shrx' x Int.zero = x.

Theorem shrx'_carry:
  forall x y,
  Int.ltu y (Int.repr 63) = true ->

Theorem shrx'_shr_2:
  forall x y,
  Int.ltu y (Int.repr 63) = true ->

Remark int_ltu_2_inv:
  forall y z,
  Int.ltu y iwordsize' = true ->

Theorem or_ror':
  forall x y z,
  Int.ltu y iwordsize' = true ->

Theorem shl'_shl':
  forall x y z,
  Int.ltu y iwordsize' = true ->

Theorem shru'_shru':
  forall x y z,
  Int.ltu y iwordsize' = true ->

Theorem shr'_shr':
  forall x y z,
  Int.ltu y iwordsize' = true ->

Definition one_bits' (x: int) : list Int.int :=
  List.map Int.repr (Z_one_bits wordsize (unsigned x) 0).

Definition is_power2' (x: int) : option Int.int :=
  match Z_one_bits wordsize (unsigned x) 0 with
  | i :: nil => Some (Int.repr i)
  | _ => None
  end.

Theorem one_bits'_range:
  forall x i, In i (one_bits' x) -> Int.ltu i iwordsize' = true.

Fixpoint int_of_one_bits' (l: list Int.int) : int :=
  match l with
  | nil => zero
  | a :: b => add (shl' one a) (int_of_one_bits' b)
  end.

Theorem one_bits'_decomp:
  forall x, x = int_of_one_bits' (one_bits' x).

Lemma is_power2'_rng:
  forall n logn,
  is_power2' n = Some logn ->
  0 <= Int.unsigned logn < zwordsize.

Theorem is_power2'_range:
  forall n logn,
  is_power2' n = Some logn -> Int.ltu logn iwordsize' = true.

Lemma is_power2'_correct:
  forall n logn,
  is_power2' n = Some logn ->
  unsigned n = two_p (Int.unsigned logn).

Theorem mul_pow2':
  forall x n logn,
  is_power2' n = Some logn ->
  mul x n = shl' x logn.

Theorem divu_pow2':
  forall x n logn,
  is_power2' n = Some logn ->
  divu x n = shru' x logn.

Definition loword (n: int) : Int.int := Int.repr (unsigned n).

Definition hiword (n: int) : Int.int := Int.repr (unsigned (shru n (repr Int.zwordsize))).

Definition ofwords (hi lo: Int.int) : int :=
  or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize)) (repr (Int.unsigned lo)).

Lemma bits_loword:
  forall n i, 0 <= i < Int.zwordsize -> Int.testbit (loword n) i = testbit n i.

Lemma bits_hiword:
  forall n i, 0 <= i < Int.zwordsize -> Int.testbit (hiword n) i = testbit n (i + Int.zwordsize).

Lemma bits_ofwords:
  forall hi lo i, 0 <= i < zwordsize ->
  testbit (ofwords hi lo) i =
  if zlt i Int.zwordsize then Int.testbit lo i else Int.testbit hi (i - Int.zwordsize).

Lemma lo_ofwords:
  forall hi lo, loword (ofwords hi lo) = lo.

Lemma hi_ofwords:
  forall hi lo, hiword (ofwords hi lo) = hi.

Lemma ofwords_recompose:
  forall n, ofwords (hiword n) (loword n) = n.

Lemma ofwords_add:
  forall lo hi, ofwords hi lo = repr (Int.unsigned hi * two_p 32 + Int.unsigned lo).

Lemma ofwords_add':
  forall lo hi, unsigned (ofwords hi lo) = Int.unsigned hi * two_p 32 + Int.unsigned lo.

Remark eqm_mul_2p32:
  forall x y, Int.eqm x y -> eqm (x * two_p 32) (y * two_p 32).

Lemma ofwords_add'':
  forall lo hi, signed (ofwords hi lo) = Int.signed hi * two_p 32 + Int.unsigned lo.

Lemma decompose_bitwise_binop:
  forall f f64 f32 xh xl yh yl,
  (forall x y i, 0 <= i < zwordsize -> testbit (f64 x y) i = f (testbit x i) (testbit y i)) ->
  (forall x y i, 0 <= i < Int.zwordsize -> Int.testbit (f32 x y) i = f (Int.testbit x i) (Int.testbit y i)) ->

Lemma decompose_and:
  forall xh xl yh yl,
  and (ofwords xh xl) (ofwords yh yl) = ofwords (Int.and xh yh) (Int.and xl yl).

Lemma decompose_or:
  forall xh xl yh yl,
  or (ofwords xh xl) (ofwords yh yl) = ofwords (Int.or xh yh) (Int.or xl yl).

Lemma decompose_xor:
  forall xh xl yh yl,
  xor (ofwords xh xl) (ofwords yh yl) = ofwords (Int.xor xh yh) (Int.xor xl yl).

Lemma decompose_not:
  forall xh xl,
  not (ofwords xh xl) = ofwords (Int.not xh) (Int.not xl).

Lemma decompose_shl_1:
  forall xh xl y,
  0 <= Int.unsigned y < Int.zwordsize ->

Lemma decompose_shl_2:
  forall xh xl y,
  Int.zwordsize <= Int.unsigned y < zwordsize ->

Lemma decompose_shru_1:
  forall xh xl y,
  0 <= Int.unsigned y < Int.zwordsize ->

Lemma decompose_shru_2:
  forall xh xl y,
  Int.zwordsize <= Int.unsigned y < zwordsize ->

Lemma decompose_shr_1:
  forall xh xl y,
  0 <= Int.unsigned y < Int.zwordsize ->

Lemma decompose_shr_2:
  forall xh xl y,
  Int.zwordsize <= Int.unsigned y < zwordsize ->

Lemma decompose_add:
  forall xh xl yh yl,
  add (ofwords xh xl) (ofwords yh yl) =
  ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))

Lemma decompose_sub:
  forall xh xl yh yl,
  sub (ofwords xh xl) (ofwords yh yl) =
  ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))

Lemma decompose_sub':
  forall xh xl yh yl,
  sub (ofwords xh xl) (ofwords yh yl) =
  ofwords (Int.add (Int.add xh (Int.not yh)) (Int.add_carry xl (Int.not yl) Int.one))

Definition mul' (x y: Int.int) : int := repr (Int.unsigned x * Int.unsigned y).

Lemma mul'_mulhu:
  forall x y, mul' x y = ofwords (Int.mulhu x y) (Int.mul x y).

Lemma decompose_mul:
  forall xh xl yh yl,
  mul (ofwords xh xl) (ofwords yh yl) =
  ofwords (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh)) (Int.mul xh yl))

Lemma decompose_mul_2:
  forall xh xl yh yl,
  mul (ofwords xh xl) (ofwords yh yl) =
  ofwords (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh)) (Int.mul xh yl))

Lemma decompose_ltu:
  forall xh xl yh yl,
  ltu (ofwords xh xl) (ofwords yh yl) = if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh.

Lemma decompose_leu:
  forall xh xl yh yl,
  negb (ltu (ofwords yh yl) (ofwords xh xl)) =
  if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh.

Lemma decompose_lt:
  forall xh xl yh yl,
  lt (ofwords xh xl) (ofwords yh yl) = if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh.

Lemma decompose_le:
  forall xh xl yh yl,
  negb (lt (ofwords yh yl) (ofwords xh xl)) =
  if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh.

Remark int_unsigned_range:
  forall x, 0 <= Int.unsigned x <= max_unsigned.

Remark int_unsigned_repr:
  forall x, unsigned (repr (Int.unsigned x)) = Int.unsigned x.

Lemma int_sub_ltu:
  forall x y,
    Int.ltu x y= true ->

End Int64.

Strategy 0 [Wordsize_64.wordsize].

Notation int64 := Int64.int.

Global Opaque Int.repr Int64.repr Byte.repr.

Module Wordsize_Ptrofs.
  Definition wordsize := if Archi.ptr64 then 64%nat else 32%nat.
  Remark wordsize_not_zero: wordsize <> 0%nat.
End Wordsize_Ptrofs.

Strategy opaque [Wordsize_Ptrofs.wordsize].

Module Ptrofs.

Include Make(Wordsize_Ptrofs).

Definition to_int (x: int): Int.int := Int.repr (unsigned x).

Definition to_int64 (x: int): Int64.int := Int64.repr (unsigned x).

Definition of_int (x: Int.int) : int := repr (Int.unsigned x).

Definition of_intu := of_int.

Definition of_ints (x: Int.int) : int := repr (Int.signed x).

Definition of_int64 (x: Int64.int) : int := repr (Int64.unsigned x).

Definition of_int64u := of_int64.

Definition of_int64s (x: Int64.int) : int := repr (Int64.signed x).

Section AGREE32.

Hypothesis _32: Archi.ptr64 = false.

Lemma modulus_eq32: modulus = Int.modulus.

Lemma eqm32:
  forall x y, Int.eqm x y <-> eqm x y.

Definition agree32 (a: Ptrofs.int) (b: Int.int) : Prop :=
  Ptrofs.unsigned a = Int.unsigned b.

Lemma agree32_repr:
  forall i, agree32 (Ptrofs.repr i) (Int.repr i).

Lemma agree32_signed:
  forall a b, agree32 a b -> Ptrofs.signed a = Int.signed b.

Lemma agree32_of_int:
  forall b, agree32 (of_int b) b.

Lemma agree32_of_ints:
  forall b, agree32 (of_ints b) b.

Lemma agree32_of_int_eq:
  forall a b, agree32 a b -> of_int b = a.

Lemma agree32_of_ints_eq:
  forall a b, agree32 a b -> of_ints b = a.

Lemma agree32_to_int:
  forall a, agree32 a (to_int a).

Lemma agree32_to_int_eq:
  forall a b, agree32 a b -> to_int a = b.

Lemma agree32_neg:
  forall a1 b1, agree32 a1 b1 -> agree32 (Ptrofs.neg a1) (Int.neg b1).

Lemma agree32_add:
  forall a1 b1 a2 b2,
  agree32 a1 b1 -> agree32 a2 b2 -> agree32 (Ptrofs.add a1 a2) (Int.add b1 b2).

Lemma agree32_sub:
  forall a1 b1 a2 b2,
  agree32 a1 b1 -> agree32 a2 b2 -> agree32 (Ptrofs.sub a1 a2) (Int.sub b1 b2).

Lemma agree32_mul:
  forall a1 b1 a2 b2,
  agree32 a1 b1 -> agree32 a2 b2 -> agree32 (Ptrofs.mul a1 a2) (Int.mul b1 b2).

Lemma agree32_divs:
  forall a1 b1 a2 b2,
  agree32 a1 b1 -> agree32 a2 b2 -> agree32 (Ptrofs.divs a1 a2) (Int.divs b1 b2).

Lemma of_int_to_int:
  forall n, of_int (to_int n) = n.

Lemma to_int_of_int:
  forall n, to_int (of_int n) = n.

End AGREE32.

Section AGREE64.

Hypothesis _64: Archi.ptr64 = true.

Lemma modulus_eq64: modulus = Int64.modulus.

Lemma eqm64:
  forall x y, Int64.eqm x y <-> eqm x y.

Definition agree64 (a: Ptrofs.int) (b: Int64.int) : Prop :=
  Ptrofs.unsigned a = Int64.unsigned b.

Lemma agree64_repr:
  forall i, agree64 (Ptrofs.repr i) (Int64.repr i).

Lemma agree64_signed:
  forall a b, agree64 a b -> Ptrofs.signed a = Int64.signed b.

Lemma agree64_of_int:
  forall b, agree64 (of_int64 b) b.

Lemma agree64_of_int_eq:
  forall a b, agree64 a b -> of_int64 b = a.

Lemma agree64_to_int:
  forall a, agree64 a (to_int64 a).

Lemma agree64_to_int_eq:
  forall a b, agree64 a b -> to_int64 a = b.

Lemma agree64_neg:
  forall a1 b1, agree64 a1 b1 -> agree64 (Ptrofs.neg a1) (Int64.neg b1).

Lemma agree64_add:
  forall a1 b1 a2 b2,
  agree64 a1 b1 -> agree64 a2 b2 -> agree64 (Ptrofs.add a1 a2) (Int64.add b1 b2).

Lemma agree64_sub:
  forall a1 b1 a2 b2,
  agree64 a1 b1 -> agree64 a2 b2 -> agree64 (Ptrofs.sub a1 a2) (Int64.sub b1 b2).

Lemma agree64_mul:
  forall a1 b1 a2 b2,
  agree64 a1 b1 -> agree64 a2 b2 -> agree64 (Ptrofs.mul a1 a2) (Int64.mul b1 b2).

Lemma agree64_divs:
  forall a1 b1 a2 b2,
  agree64 a1 b1 -> agree64 a2 b2 -> agree64 (Ptrofs.divs a1 a2) (Int64.divs b1 b2).

Lemma of_int64_to_int64:
  forall n, of_int64 (to_int64 n) = n.

Lemma to_int64_of_int64:
  forall n, to_int64 (of_int64 n) = n.

End AGREE64.

Hint Resolve
  agree32_repr agree32_of_int agree32_of_ints agree32_of_int_eq agree32_of_ints_eq
  agree32_to_int agree32_to_int_eq agree32_neg agree32_add agree32_sub agree32_mul agree32_divs
  agree64_repr agree64_of_int agree64_of_int_eq
  agree64_to_int agree64_to_int_eq agree64_neg agree64_add agree64_sub agree64_mul agree64_divs : ptrofs.

End Ptrofs.

Strategy 0 [Wordsize_Ptrofs.wordsize].

Notation ptrofs := Ptrofs.int.

Global Opaque Ptrofs.repr.

Hint Resolve Int.modulus_pos Int.eqm_refl Int.eqm_refl2 Int.eqm_sym Int.eqm_trans
  Int.eqm_small_eq Int.eqm_add Int.eqm_neg Int.eqm_sub Int.eqm_mult
  Int.eqm_unsigned_repr Int.eqm_unsigned_repr_l Int.eqm_unsigned_repr_r
  Int.unsigned_range Int.unsigned_range_2
  Int.repr_unsigned Int.repr_signed Int.unsigned_repr : ints.

Hint Resolve Int64.modulus_pos Int64.eqm_refl Int64.eqm_refl2 Int64.eqm_sym Int64.eqm_trans
  Int64.eqm_small_eq Int64.eqm_add Int64.eqm_neg Int64.eqm_sub Int64.eqm_mult
  Int64.eqm_unsigned_repr Int64.eqm_unsigned_repr_l Int64.eqm_unsigned_repr_r
  Int64.unsigned_range Int64.unsigned_range_2
  Int64.repr_unsigned Int64.repr_signed Int64.unsigned_repr : ints.

Hint Resolve Ptrofs.modulus_pos Ptrofs.eqm_refl Ptrofs.eqm_refl2 Ptrofs.eqm_sym Ptrofs.eqm_trans
  Ptrofs.eqm_small_eq Ptrofs.eqm_add Ptrofs.eqm_neg Ptrofs.eqm_sub Ptrofs.eqm_mult
  Ptrofs.eqm_unsigned_repr Ptrofs.eqm_unsigned_repr_l Ptrofs.eqm_unsigned_repr_r
  Ptrofs.unsigned_range Ptrofs.unsigned_range_2
  Ptrofs.repr_unsigned Ptrofs.repr_signed Ptrofs.unsigned_repr : ints. *)
Require Import VST.concurrency.common.tactics.

Require Import Coq.ZArith.ZArith.
Require Import Coq.Logic.ClassicalFacts.
 
Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.permjoin_def.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.dry_machine_step_lemmas.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.memory_lemmas.
Require Import VST.concurrency.sc_drf.mem_obs_eq.

Set Bullet Behavior "None".
Set Bullet Behavior "Strict Subproofs".

Import ThreadPool CoreLanguage AsmContext
       HybridMachine DryHybridMachine HybridMachineSig.
Import CoreInjections ThreadPoolInjections.

Import StepType InternalSteps.

Import MemObsEq ValObsEq MemoryLemmas.
Import CoreInjections ValueWD MemoryWD Renamings.

Module SimDefs.

  Section SimDefs.
  Context {asmSem : Semantics}
          {semAxioms : SemAxioms}
          {semDet : SemDet}
          {CI: CoreInj}
          {initU : seq nat}.

  Existing Instance OrdinalPool.OrdinalThreadPool.
  Existing Instance DryHybridMachine.DryHybridMachineSig.
  Existing Instance dryFineMach.
  Existing Instance dryCoarseMach.

  Notation Sch := schedule.
  Notation CoarseSem := coarse_semantics.

  Notation threadStep := (HybridMachineSig.threadStep the_ge).
  Notation cmachine_step := ((corestep (AsmContext.coarse_semantics initU))).
  Notation fmachine_step := ((corestep (AsmContext.fine_semantics initU))).

  Record weak_tsim {tpc tpf : t} (mc mf : Mem.mem)
             {i} (f: memren) (pfc : containsThread tpc i)
             (pff : containsThread tpf i) (compc: mem_compatible tpc mc)
             (compf: mem_compatible tpf mf) : Prop :=
    { weak_tsim_data:
        weak_mem_obs_eq f (restrPermMap (((compat_th _ _ compc) pfc).1))
                        (restrPermMap (((compat_th _ _ compf) pff).1));
      weak_tsim_locks:
        weak_mem_obs_eq f (restrPermMap (((compat_th _ _ compc) pfc).2))
                        (restrPermMap (((compat_th _ _ compf) pff).2))}.

  Record strong_tsim {tpc tpf : threadPool.ThreadPool.t} (mc mf : Mem.mem) {i}
         (f: memren) (pfc : containsThread tpc i)
         (pff : containsThread tpf i) (compc: mem_compatible tpc mc)
         (compf: mem_compatible tpf mf) : Prop :=
    { code_eq: ctl_inj f (getThreadC pfc) (getThreadC pff);
      obs_eq_data: mem_obs_eq f (restrPermMap ((fst (compc i pfc))))
                         (restrPermMap (fst (compf i pff)));
      obs_eq_locks: mem_obs_eq f (restrPermMap ((snd (compc i pfc))))
                         (restrPermMap (snd (compf i pff)));
    }.

  Definition pmap_inj f (pmap1 pmap2 : access_map) :=
    (forall b1 b2,
        f b1 = Some b2 ->
        Maps.PMap.get b1 pmap1 = Maps.PMap.get b2 pmap2) /\
    (forall b1, f b1 = None ->
           Maps.PMap.get b1 pmap1 = fun _ => None) /\
    (forall b2, (exists ofs, Maps.PMap.get b2 pmap2 ofs <> None) ->
           exists b1, f b1 = Some b2).      

  Definition isProjection (f : memren) (deltaMap deltaMap' : delta_map) : Prop :=
    (forall b b',
      f b = Some b' ->
      Maps.PTree.get b deltaMap = Maps.PTree.get b' deltaMap').

   Definition delta_inj (f : memren) (deltaMap deltaMap' : delta_map) : Prop :=
    (forall b b',
        f b = Some b' ->
        match Maps.PTree.get b deltaMap, Maps.PTree.get b' deltaMap' with
        | Some d1, Some d2 => d1 = d2
        | Some d1, None => forall ofs, d1 ofs = None \/ d1 ofs = Some None
        | None, None => True
        | _, _ => False
        end) /\
    (forall b, f b = None ->
          match Maps.PTree.get b deltaMap with
          | None => True
          | Some d => forall ofs, d ofs = None \/ d ofs = Some None
          end ) /\
    (forall b', (~exists b, f b = Some b') ->
           Maps.PTree.get b' deltaMap' = None).

  Definition delta_content_inj (f : memren) (deltaMap deltaMap' : delta_content) : Prop :=
    (forall b b',
        f b = Some b' ->
        match Maps.PTree.get b deltaMap, Maps.PTree.get b' deltaMap' with
        | Some d1, Some d2 => forall ofs, match d1 ofs, d2 ofs with
                                    | Some mv1, Some mv2 =>
                                      memval_obs_eq f mv1 mv2
                                    | None, None => True
                                    | _, _ => False
                                    end  
        | None, None => True
        | Some d1, None => forall ofs, d1 ofs = None
        | None, Some d2 => False
        end) /\
    (forall b, f b = None ->
          match Maps.PTree.get b deltaMap with
          | None => True
          | Some d => forall ofs, d ofs = None
          end ) /\
    (forall b', (~exists b, f b = Some b') ->
           Maps.PTree.get b' deltaMap' = None).
  
  Inductive event_sim (f:memren) : Events.machine_event -> Events.machine_event -> Prop :=
  | ReleaseSim : forall i b1 b2 ofs dc1 dc2
                   (Hf: f b1 = Some b2)
                   (Hdelta_inj: delta_content_inj f dc1 dc2),
      event_sim f (Events.external i (Events.release (b1,ofs) (Some dc1)))
                (Events.external i (Events.release (b2,ofs) (Some dc2)))
  | AcquireSim : forall i b1 b2 ofs dc1 dc2
                   (Hf: f b1 = Some b2)
                   (Hpmap1_inj: delta_content_inj f dc1 dc2),
      event_sim f (Events.external i (Events.acquire (b1,ofs) (Some dc1)))
                (Events.external i (Events.acquire (b2,ofs) (Some dc2)))
  | MkLockSim : forall i b1 b2 ofs
                   (Hf: f b1 = Some b2),
      event_sim f (Events.external i (Events.mklock (b1,ofs)))
                (Events.external i (Events.mklock (b2, ofs)))
  | FreeLockSim : forall i b1 b2 ofs
                  (Hf: f b1 = Some b2),
      event_sim f (Events.external i (Events.freelock (b1,ofs)))
                (Events.external i (Events.freelock (b2, ofs)))
  | SpawnSim : forall i b1 b2 ofs dc1a dc2a dc1b dc2b
                 (Hf: f b1 = Some b2)
                 (Hinj1: delta_content_inj f dc1a dc2a)
                 (Hinj2: delta_content_inj f dc1b dc2b),
      event_sim f (Events.external i (Events.spawn (b1, ofs) (Some dc1a) (Some dc1b)))
                (Events.external i (Events.spawn (b2, ofs) (Some dc2a) (Some dc2b)))
  | FAcqSim: forall i b1 b2 ofs
               (Hf: f b1 = Some b2),
      event_sim f (Events.external i (Events.failacq (b1,ofs)))
                (Events.external i (Events.failacq (b2, ofs))).
      
  Inductive trace_sim (f:memren) : event_trace -> event_trace -> Prop :=
  | TraceEmpty : trace_sim f [::] [::]
  | TraceCons : forall ev ev' tr tr'
                  (Hev: event_sim f ev ev')
                  (Htr: trace_sim f tr tr'),
      trace_sim f (tr ++ [:: ev]) (tr' ++ [:: ev']).

  Definition fpool tpc : Type :=
    forall i (cnti: containsThread tpc i), memren.

  Definition max_inv mf := forall b ofs, Mem.valid_block mf b ->
                                    permission_at mf b ofs Max = Some Freeable.
    Record sim tpc trc mc tpf (trf : event_trace) mf (xs : seq nat) (f fg: memren) (fp: fpool tpc) fuelF : Prop :=
    { numThreads : forall i, containsThread tpc i <-> containsThread tpf i;
      mem_compc: mem_compatible tpc mc;
      mem_compf: mem_compatible tpf mf;
      safeCoarse: forall sched tr,
          HybridCoarseMachine.csafe (sched,tr,tpc) mc (fuelF + size xs);
      simWeak:
        forall tid
          (pfc: containsThread tpc tid)
          (pff: containsThread tpf tid),
          weak_tsim f pfc pff mem_compc mem_compf;
      fpSeperate: forall i j
                    (cnti: containsThread tpc i)
                    (cntj: containsThread tpc j)
                    (Hij: i <> j) b b' b2 b2'
                    (Hfb: f b = None)
                    (Hfb': f b' = None)
                    (Hfib: (fp _ cnti) b = Some b2)
                    (Hfjb': (fp _ cntj) b' = Some b2'),
          b2 <> b2';
      simStrong:
        forall tid (pfc: containsThread tpc tid) (pff: containsThread tpf tid),
        exists tpc' mc', ren_incr f (fp _ pfc) /\
                    ([seq x <- xs | x == tid] = nil -> f = (fp _ pfc)) /\
                    internal_execution ([seq x <- xs | x == tid])
                                       tpc mc tpc' mc' /\
                    (forall (pfc': containsThread tpc' tid)
                       (mem_compc': mem_compatible tpc' mc'),
                        strong_tsim (fp _ pfc) pfc' pff mem_compc' mem_compf) /\
                    (forall tid2 (pff2: containsThread tpf tid2)
                       (Hneq: tid <> tid2) b1 b2 ofs,
                        (fp _ pfc) b1 = Some b2 ->
                        f b1 = None ->
                        (getThreadR pff2).1 # b2 ofs = None /\ (getThreadR pff2).2 # b2 ofs = None) /\
                    (forall bl ofsl rmap b1 b2 ofs,
                        (fp _ pfc) b1 = Some b2 ->
                        f b1 = None ->
                        lockRes tpf (bl,ofsl) = Some rmap ->
                        rmap.1 # b2 ofs = None /\ rmap.2 # b2 ofs = None) /\
                    (forall b2, (~exists b1, fp _ pfc b1 = Some b2) ->
                            forall ofs, (getThreadR pff).1 # b2 ofs = None /\
                                   (getThreadR pff).2 # b2 ofs = None);
      simLockRes: (forall bl1 bl2 ofs rmap1 rmap2
                    (Hf: f bl1 = Some bl2)
                    (Hl1: lockRes tpc (bl1,ofs) = Some rmap1)
                    (Hl2: lockRes tpf (bl2,ofs) = Some rmap2),
                      strong_mem_obs_eq f (restrPermMap (fst ((compat_lp _ _ mem_compc) _ _ Hl1)))
                                        (restrPermMap (fst ((compat_lp _ _ mem_compf) _ _ Hl2))) /\
                      strong_mem_obs_eq f (restrPermMap (snd ((compat_lp _ _ mem_compc) _ _ Hl1)))
                                        (restrPermMap (snd ((compat_lp _ _ mem_compf) _ _ Hl2)))) /\
                  (forall bl2 ofs,
                    lockRes tpf (bl2, ofs) ->
                    exists bl1, f bl1 = Some bl2) /\
                  (forall bl1 bl2 ofs,
                      f bl1 = Some bl2 ->
                      lockRes tpc (bl1, ofs) <-> lockRes tpf (bl2, ofs));
      unmappedRes:
        forall bl ofsl rmap,
          lockRes tpf (bl, ofsl) = Some rmap ->
        forall b2, (~exists b1, f b1 = Some b2) ->
                forall ofs, rmap.1 # b2 ofs = None /\
                       rmap.2 # b2 ofs = None;
      invF: invariant tpf;
      maxF: max_inv mf;
      memc_wd: valid_mem mc;
      tpc_wd: tp_wd f tpc;
      thege_wd: ge_wd fg the_ge;
      fg_spec: ren_incr fg f /\ forall b b', fg b = Some b' -> b = b';
      xs_wd: forall i, List.In i xs -> containsThread tpc i;
      
      traceSim: trace_sim f trc trf
    }.

  Arguments sim : clear implicits.
  Notation "cnt '$' m '@'  'I'" := (getStepType cnt m Internal) (at level 80).
  Notation "cnt '$' m '@'  'E'" := (getStepType cnt m Concurrent) (at level 80).
  Notation "cnt '$' m '@'  'S'" := (getStepType cnt m Suspend) (at level 80).

  Definition sim_internal_def :=
    forall tpc trc tpf trf (mc mf : Mem.mem) fuelF
      (xs : Sch) (f fg : memren) (fp : fpool tpc) (i : NatTID.tid)
      (pff: containsThread tpf i)
      (Hsim: sim tpc trc mc tpf trf mf xs f fg fp (S (S fuelF))),
      let mrestr := restrPermMap (((compat_th _ _ (mem_compf Hsim)) pff).1) in
      forall (Hinternal: pff$mrestr @ I),
      exists tpf' mf' fp' tr',
        (forall U, fmachine_step (i :: U, trf, tpf) mf (U, tr', tpf') mf') /\
        sim tpc trc mc tpf' trf mf' (i :: xs) f fg fp' (S fuelF).

  Definition sim_external_def :=
    forall tpc trc tpf trf (mc mf : Mem.mem) fuelF
      (xs : Sch) (f fg : memren) (fp : fpool tpc) (i : NatTID.tid)
      (pff: containsThread tpf i)
      (Hsynced: ~ List.In i xs)
      (Hsim: sim tpc trc mc tpf trf mf xs f fg fp (S (S fuelF))),
      let mrestr := restrPermMap (((compat_th _ _ (mem_compf Hsim)) pff).1) in
      forall (Hexternal: pff$mrestr @ E),
    exists tpc' trc' mc' tpf' mf' f' fp' tr',
      (forall U, fmachine_step (i :: U, trf, tpf) mf (U, tr', tpf') mf') /\
      sim tpc' trc' mc' tpf' tr' mf' xs f' fg fp' (S fuelF).

  Definition sim_suspend_def :=
    forall tpc trc tpf trf (mc mf : Mem.mem) fuelF
      (xs : Sch) (f fg : memren) (fp : fpool tpc) (i : NatTID.tid)
      (pff: containsThread tpf i)
      (Hsim: sim tpc trc mc tpf trf mf xs f fg fp (S (S fuelF))),
      let mrestr := restrPermMap (((compat_th _ _ (mem_compf Hsim)) pff).1) in
      forall (Hsuspend: pff$mrestr @ S),
    exists tpc' trc' mc' tpf' mf' f' fp' tr',
      (forall U, fmachine_step (i :: U, trf, tpf) mf (U, tr', tpf') mf') /\
      sim tpc' (trc ++ trc') mc' tpf' trf mf' [seq x <- xs | x != i] f' fg fp'
          (S fuelF).

  Definition sim_fail_def :=
    forall tpc trc tpf trf (mc mf : Mem.mem) fuelF
      (xs : Sch) (f fg : memren) (fp : fpool tpc) (i : NatTID.tid)
      (pff: ~ containsThread tpf i)
      (Hsim: sim tpc trc mc tpf trf mf xs f fg fp (S (S fuelF))),
    exists tr',
      (forall U, fmachine_step (i :: U, trf, tpf) mf (U, tr', tpf) mf) /\
      sim tpc trc mc tpf trf mf xs f fg fp (S fuelF).

  End SimDefs.

  Arguments sim {asmSem} {CI} tpc trc mc tpf trf mf xs f fg fp fuelF.

End SimDefs.

Module SimProofs.

  Section SimProofs.
    Context {asmSem : Semantics}
            {semAxioms : SemAxioms}
            {semDet : SemDet}
            {CI: CoreInj}
            {initU : seq nat}.

    Existing Instance OrdinalPool.OrdinalThreadPool.
    Existing Instance DryHybridMachine.DryHybridMachineSig.
    Existing Instance dryFineMach.
    Existing Instance FineDilMem.
    Existing Instance dryCoarseMach.
    Existing Instance HybridFineMachine.scheduler.
    Existing Instance HybridCoarseMachine.scheduler.
    Existing Instance FineDilMem.
    Existing Instance HybridCoarseMachine.DilMem.

    Import SimDefs ThreadPoolWF.
    Import event_semantics Events.

  Notation csafe := (HybridCoarseMachine.csafe).
  Notation sim_fail_def := (@sim_fail_def _ _ initU).
  Notation threadStep := (HybridMachineSig.threadStep).
  Notation cmachine_step := ((corestep (AsmContext.coarse_semantics initU))).
  Notation fmachine_step := ((corestep (AsmContext.fine_semantics initU))).
  Notation "cnt '$' m '@'  'I'" := (getStepType cnt m Internal) (at level 80).
  Notation "cnt '$' m '@'  'E'" := (getStepType cnt m Concurrent) (at level 80).
  Notation "cnt '$' m '@'  'S'" := (getStepType cnt m Suspend) (at level 80).

  Notation internal_step := (internal_step).
  Notation internal_execution := (internal_execution).
  Notation fyield := (@yield HybridFineMachine.scheduler).
  Notation fdiluteMem := (@diluteMem FineDilMem).

  Notation sim_internal_def := (@sim_internal_def _ _ initU).
  Notation sim_suspend_def := (@sim_suspend_def _ _ initU).
  Notation sim_external_def := (@sim_external_def _ _ initU).

  Hypothesis em : excluded_middle.

  Definition projectAngel (f : memren) (deltaMap : delta_map) : delta_map :=
    Maps.PTree.fold (fun acc b bperm =>
                       match f b with
                       | Some b' =>
                         Maps.PTree.set b' bperm acc
                       | None =>
                         acc end)
                    deltaMap (Maps.PTree.empty _).

  Lemma projectAngel_correct:
    forall (f:memren) deltaMap
      (Hf_injective: forall b1 b1' b2,
          f b1 = Some b2 ->
          f b1' = Some b2 ->
          b1 = b1'),
      isProjection f deltaMap (projectAngel f deltaMap).
  Proof.
    intros.
    eapply Maps.PTree_Properties.fold_rec with (P := isProjection f).
    { intros dmap dmap' a Heq Hprojection. intros b b' Hf.
      specialize (Heq b). rewrite <- Heq.
      unfold isProjection in Hprojection. eauto.
    }
    { unfold isProjection.
      intros;
        by do 2 rewrite Maps.PTree.gempty.
    }
    { intros dmap a bnew fnew Hget_dmap Hget_delta Hprojection.
      intros b b' Hf.
      destruct (Pos.eq_dec b bnew) as [Heq | Hneq].
      - subst bnew. rewrite Maps.PTree.gss.
        rewrite Hf.
          by rewrite Maps.PTree.gss.
      - rewrite Maps.PTree.gso; auto.
        unfold isProjection in Hprojection.
        destruct (f bnew) as [b'0|] eqn:Hfnew;
          try eauto.
        rewrite Maps.PTree.gso.
        eapply Hprojection; eauto.
        intros Hcontra.
        subst b'0;
          by eauto.
    }
  Qed.

  Lemma projectAngel_correct_2:
    forall (f:memren) deltaMap b'
      (Hf: ~ exists b, f b = Some b'),
      Maps.PTree.get b' (projectAngel f deltaMap) = None.
  Proof.
    intros.
    unfold projectAngel.
    eapply Maps.PTree_Properties.fold_rec. auto.
    rewrite Maps.PTree.gempty. reflexivity.
    intros.
    destruct (f k) as [b'0 |] eqn:Hf'.
    destruct (Pos.eq_dec b' b'0); subst.
    exfalso.
      by eauto.
      rewrite Maps.PTree.gso;
        by auto.
        by assumption.
  Qed.

  Lemma computeMap_projection_1:
    forall (mc mf : mem) f
      pmap pmapF
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (virtue : delta_map)
      (Hobs_eq: mem_obs_eq f (restrPermMap Hlt)
                           (restrPermMap HltF))
      b1 b2
      (Hf: f b1 = Some b2),
      (computeMap pmapF (projectAngel f virtue)) # b2 =
      (computeMap pmap virtue) # b1.
  Proof.
    intros.
    extensionality ofs.
    destruct Hobs_eq as [Hweak_obs Hstrong_obs].
    destruct Hweak_obs.
    assert (Hangel := projectAngel_correct _ virtue injective0).
    specialize (Hangel _ _ Hf).
    symmetry in Hangel.
    destruct (Maps.PTree.get b1 virtue) as [df |] eqn:Hget.
    destruct (df ofs) as [p|] eqn:Hdf.
    erewrite (computeMap_1 _ _ _ _ Hget Hdf).
    erewrite (computeMap_1 _ _ _ _ Hangel Hdf);
      by reflexivity.
    erewrite (computeMap_2 _ _ _ _ Hget Hdf).
    erewrite (computeMap_2 _ _ _ _ Hangel Hdf).
    destruct Hstrong_obs.
    specialize (perm_obs_strong0 b1 b2 ofs Hf);
      by do 2 rewrite restrPermMap_Cur in perm_obs_strong0.
    erewrite (computeMap_3 _ _ _ _ Hget).
    erewrite (computeMap_3 _ _ _ _ Hangel).
    destruct Hstrong_obs.
    specialize (perm_obs_strong0 b1 b2 ofs Hf);
      by do 2 rewrite restrPermMap_Cur in perm_obs_strong0.
  Qed.

  Lemma computeMap_projection_2:
    forall f pmap
      (virtue : delta_map) b2
      (Hb1: ~ (exists b1 : block, f b1 = Some b2)),
      (computeMap pmap (projectAngel f virtue)) # b2 =
      pmap # b2.
  Proof.
    intros.
    assert (H := projectAngel_correct_2 _ virtue Hb1).
    extensionality ofs';
      by erewrite computeMap_3.
  Qed.

  Lemma computeMap_projection_3 :
    forall  (f : memren) (virtue : delta_map) b1 b2
       (Hf: f b1 = Some b2)
       (Hinjective : forall b1 b1' b2 : block,
           f b1 = Some b2 -> f b1' = Some b2 -> b1 = b1'),
      (computeMap empty_map (projectAngel f virtue)) # b2 =
      (computeMap empty_map virtue) # b1.
  Proof.
    intros.
    extensionality ofs.
    assert (Hangel := projectAngel_correct _ virtue Hinjective).
    specialize (Hangel _ _ Hf).
    symmetry in Hangel.
    destruct (Maps.PTree.get b1 virtue) as [df |] eqn:Hget.
    destruct (df ofs) as [p|] eqn:Hdf.
    erewrite (computeMap_1 _ _ _ _ Hget Hdf).
    erewrite (computeMap_1 _ _ _ _ Hangel Hdf);
      by reflexivity.
    erewrite (computeMap_2 _ _ _ _ Hget Hdf).
    erewrite (computeMap_2 _ _ _ _ Hangel Hdf);
      by do 2 rewrite empty_map_spec.
    erewrite (computeMap_3 _ _ _ _ Hget).
    erewrite (computeMap_3 _ _ _ _ Hangel);
      by do 2 rewrite empty_map_spec.
  Qed.

  Definition projectMap (f : memren) (pmap : access_map) : access_map :=
    (pmap#1, Maps.PTree.fold (fun acc b bperm =>
                                match f b with
                                | Some b' =>
                                  Maps.PTree.set b' bperm acc
                                | None =>
                                  acc end)
                             pmap.2 (Maps.PTree.empty _)).

  Lemma projectMap_tree:
    forall (f:memren) pmap
      (Hf_injective: forall b1 b1' b2,
          f b1 = Some b2 ->
          f b1' = Some b2 ->
          b1 = b1') b b'
      (Hf: f b = Some b'),
      Maps.PTree.get b pmap.2 = Maps.PTree.get b' (projectMap f pmap).2.
  Proof.
    intros.
    unfold projectMap.
    eapply Maps.PTree_Properties.fold_rec; eauto.
    { intros dmap dmap' a Heq Hprojection. simpl in *.
      specialize (Heq b). rewrite <- Heq. auto.
    }
    { by do 2 rewrite Maps.PTree.gempty.
    }
    { intros dmap a bnew fnew Hget_dmap Hget_delta Hprojection.
      destruct (Pos.eq_dec b bnew) as [Heq | Hneq].
      - subst bnew. rewrite Maps.PTree.gss.
        rewrite Hf.
          by rewrite Maps.PTree.gss.
      - rewrite Maps.PTree.gso; auto.
        unfold isProjection in Hprojection.
        destruct (f bnew) as [b'0|] eqn:Hfnew;
          try eauto.
        rewrite Maps.PTree.gso.
        eapply Hprojection; eauto.
        intros Hcontra.
        subst b'0;
          by eauto.
    }
  Qed.

  Lemma projectMap_correct:
    forall (f:memren) pmap
      (Hf_injective: forall b1 b1' b2,
          f b1 = Some b2 ->
          f b1' = Some b2 ->
          b1 = b1') b b'
      (Hf: f b = Some b'),
      Maps.PMap.get b pmap = Maps.PMap.get b' (projectMap f pmap).
  Proof.
    intros.
    unfold Maps.PMap.get.
    erewrite projectMap_tree;
      by eauto.
  Qed.

  Lemma projectMap_tree_2:
    forall (f:memren) pmap b'
      (Hf: ~ exists b, f b = Some b'),
      Maps.PTree.get b' (projectMap f pmap).2 = None.
  Proof.
    intros.
    unfold projectMap.
    eapply Maps.PTree_Properties.fold_rec. auto.
    rewrite Maps.PTree.gempty. reflexivity.
    intros.
    destruct (f k) as [b'0 |] eqn:Hf'.
    destruct (Pos.eq_dec b' b'0); subst.
    exfalso.
      by eauto.
      rewrite Maps.PTree.gso;
        by auto.
        by assumption.
  Qed.

  Lemma projectMap_tree_unchanged :
    forall f (pmap : access_map) (b2 : positive)
      (Hb1: ~ (exists b1 : block, f b1 = Some b2)),
      Maps.PTree.get b2 (projectMap f pmap).2 = None.
  Proof.
    intros.
    unfold projectMap.
    eapply Maps.PTree_Properties.fold_rec; auto.
    rewrite Maps.PTree.gempty. reflexivity.
    intros.
    destruct (f k) as [b'0 |] eqn:Hf'.
    destruct (Pos.eq_dec b2 b'0); subst.
    exfalso;
      by eauto.
    rewrite Maps.PTree.gso;
      by auto.
      by assumption.
  Qed.

  Lemma projectMap_correct_2:
    forall f pmap b2
      (Hb1: ~ (exists b1 : block, f b1 = Some b2)),
      (projectMap f pmap) # b2 = pmap.1.
  Proof.
    intros.
    assert (H := projectMap_tree_2 _ pmap Hb1).
    extensionality ofs'.
    unfold Maps.PMap.get. rewrite H.
      by reflexivity.
  Qed.
  
  Lemma pmap_inj_incr:
    forall f f' pmap pmap'
      (Hincr: ren_incr f f')
      (Hinjective: forall b1 b1' b2,
          f' b1 = Some b2 ->
          f' b1' = Some b2 ->
          b1 = b1')
      (Hinj: pmap_inj f pmap pmap'),
      pmap_inj f' pmap pmap'.
  Proof.
    intros.
    destruct Hinj as [H1 [H2 H3]].
    repeat split.
    - intros b1 b2 Hf'.
      destruct (f b1) eqn:Hf.
      + eapply H1.
        pose proof (Hincr _ _ Hf) as Hf2.
        rewrite Hf2 in Hf'; inversion Hf'; subst.
        assumption.
      + rewrite H2; auto.
        apply extensionality.
        intros ofs.
        destruct (pmap' # b2 ofs) eqn:Hpmap'; auto.
        exfalso.
        specialize (H3 b2 ltac:(exists ofs; rewrite Hpmap'; intros Hcontra; congruence)).
        destruct H3.
        pose proof (Hincr _ _ H).
        specialize (Hinjective _ _ _ H0 Hf'); subst.
        congruence.
    - intros b1 Hf'.
      eapply H2.
      destruct (f b1) eqn:Hf; auto.
      eapply Hincr in Hf.
      congruence.
    - intros b2 Hnonempty.
      specialize (H3 _ Hnonempty).
      destruct H3.
      eapply Hincr in H.
      eexists; eauto.
  Qed.

  Lemma delta_inj_incr:
    forall f f' pmap pmap'
      (Hincr: ren_incr f f')
      (Hinjective: forall b1 b1' b2,
          f' b1 = Some b2 ->
          f' b1' = Some b2 ->
          b1 = b1')
      (Hinj: delta_inj f pmap pmap'),
      delta_inj f' pmap pmap'.
  Proof.
    intros.
    repeat split.
    - intros b b' Hf'.
      destruct (f b) eqn:Hfb.
      + pose proof (Hincr _ _ Hfb) as Hf'b.
        rewrite Hf'b in Hf'.
        inversion Hf'; subst.
        eapply Hinj;
          now auto.
      + destruct Hinj as [H0 [H1 H2]].
        specialize (H1 b Hfb).
        destruct (pmap ! b) eqn:Hpmap.
        * assert ((exists b, f b = Some b') \/ (~ exists b, f b = Some b'))
            by (eapply em).
          destruct H as [H | H].
          ** destruct H as [b0 Hf0].
             pose proof (Hincr _ _ Hf0) as Hf0'.
             specialize (Hinjective _ _ _ Hf' Hf0'); subst.
             congruence.
          ** erewrite H2 by eauto.
             assumption.
        * erewrite H2.
          auto.
          intros (b0 & Hf0).
          pose proof (Hincr _ _ Hf0) as Hf0'.
          specialize (Hinjective _ _ _ Hf' Hf0'); subst.
          congruence.
    - intros b Hf'.
      destruct (f b) eqn:Hfb.
      +  eapply Hincr in Hfb.
         congruence.
      +  eapply Hinj;
           eauto.
    - intros b' Hf'.
      eapply Hinj.
      intros Hcontra.
      eapply Hf'.
      destruct Hcontra as [b0 Hf0].
      exists b0.
      eapply Hincr;
        now eauto.
  Qed.

  Lemma memval_obs_eq_incr:
    forall (f f': memren) mv1 mv2
      (Hincr: ren_incr f f')
      (Hobs_eq: memval_obs_eq f mv1 mv2),
      memval_obs_eq f' mv1 mv2.
  Proof.
    intros.
    inversion Hobs_eq;
      constructor.
    inversion Hval_obs; subst; constructor.
    apply Hincr in H1.
      by auto.
  Qed.

  Lemma delta_content_inj_incr:
    forall f f' pmap pmap'
      (Hincr: ren_incr f f')
      (Hinjective: forall b1 b1' b2,
          f' b1 = Some b2 ->
          f' b1' = Some b2 ->
          b1 = b1')
      (Hinj: delta_content_inj f pmap pmap'),
      delta_content_inj f' pmap pmap'.
  Proof.
    intros.
    unfold delta_content_inj in *.
    repeat split.
    - intros b b' Hf'.
      destruct (f b) eqn:Hfb.
      + pose proof (Hincr _ _ Hfb) as Hf'b.
        rewrite Hf'b in Hf'.
        inversion Hf'; subst.
        destruct Hinj as [H0 [H1 H2]].
        specialize (H0 _ _ Hfb).
        repeat match goal with
               |[ |- match ?Expr with _ => _ end] =>
                destruct Expr eqn:?
               | [|- forall _, _] => intros
               end; auto;
        specialize (H0 ofs);
        rewrite Heqo1 Heqo2 in H0;
        auto.
        eapply memval_obs_eq_incr;
          eauto.
      + destruct Hinj as [H0 [H1 H2]].
        specialize (H1 b Hfb).
        destruct (pmap ! b) eqn:Hpmap.
        * assert ((exists b, f b = Some b') \/ (~ exists b, f b = Some b'))
            by (eapply em).
          destruct H as [H | H].
          ** destruct H as [b0 Hf0].
             pose proof (Hincr _ _ Hf0) as Hf0'.
             specialize (Hinjective _ _ _ Hf' Hf0'); subst.
             congruence.
          ** specialize (H2 _ H).
             rewrite H2.
             now auto.
        * erewrite H2.
          auto.
          intros (b0 & Hf0).
          pose proof (Hincr _ _ Hf0) as Hf0'.
          specialize (Hinjective _ _ _ Hf' Hf0'); subst.
          congruence.
    - intros b Hf'.
      destruct (f b) eqn:Hfb.
      +  eapply Hincr in Hfb.
         congruence.
      +  eapply Hinj;
           eauto.
    - intros b' Hf'.
      eapply Hinj.
      intros Hcontra.
      eapply Hf'.
      destruct Hcontra as [b0 Hf0].
      exists b0.
      eapply Hincr;
        now eauto.
  Qed.

  Lemma delta_content_inj_correct:
    forall f pmapc pmapf dmap mc mf
      (Hf_injective: forall b1 b1' b2,
          f b1 = Some b2 ->
          f b1' = Some b2 ->
          b1 = b1')
      (Hdelta_inj: delta_inj f dmap (projectAngel f dmap))
      (Hltc: permMapLt (computeMap pmapc dmap) (getMaxPerm mc))
      (Hltf: permMapLt (computeMap pmapf (projectAngel f dmap)) (getMaxPerm mf))
      (Hobs_eq: mem_obs_eq f (restrPermMap Hltc) (restrPermMap Hltf)),
      delta_content_inj f (build_delta_content dmap mc)
                        (build_delta_content (projectAngel f dmap) mf).
  Proof.
    intros.
    repeat (split).
    - intros.
      inversion Hobs_eq.
      destruct strong_obs_eq0.
      destruct ((build_delta_content dmap mc) ! b) eqn:Hdeltac.
      + destruct ((build_delta_content (projectAngel f dmap) mf) ! b') eqn:Hdeltaf.
        * intros.
          unfold build_delta_content in *.
          rewrite PTree.gmap in Hdeltac.
          rewrite PTree.gmap in Hdeltaf.
          unfold Coqlib.option_map in *.
          erewrite <- projectAngel_correct in Hdeltaf by eauto.
          
          destruct (dmap ! b) eqn:Hdmap.
          ** rewrite Hdmap in Hdeltac.
             inversion Hdeltac; subst.
             inversion Hdeltaf; subst. clear Hdeltac Hdeltaf.
             destruct (o1 ofs) as [o|] eqn:Ho1; auto.
             destruct o as [p|]; auto.
             specialize (val_obs_eq0 _ _ ofs H).
             unfold Mem.perm in val_obs_eq0.
             assert (permission_at (restrPermMap Hltc) b ofs Cur =
                     (Mem.mem_access (restrPermMap Hltc)) # b ofs Cur)
               by reflexivity.
             rewrite <- H0 in val_obs_eq0.
             rewrite restrPermMap_Cur in val_obs_eq0.
             erewrite computeMap_1 in val_obs_eq0 by eauto.
             simpl in val_obs_eq0.
             destruct p;
               now eauto using perm_order.
          ** rewrite Hdmap in Hdeltac.
             inversion Hdeltac.
        * unfold build_delta_content in *.
          rewrite PTree.gmap in Hdeltac.
          rewrite PTree.gmap in Hdeltaf.
          unfold Coqlib.option_map in *.
          erewrite <- projectAngel_correct in Hdeltaf by eauto.
          destruct (dmap ! b) eqn:Hdmap.
          ** rewrite Hdmap in Hdeltac.
             discriminate.
          ** rewrite Hdmap in Hdeltac.
             discriminate.
      + unfold build_delta_content in *.
        erewrite PTree.gmap in *.
        unfold Coqlib.option_map in *.
        erewrite <- projectAngel_correct by eauto.
        destruct (dmap ! b) eqn:Hdmap.
        * rewrite Hdmap in Hdeltac.
          discriminate.
        * auto.
    - destruct Hdelta_inj as [_ [Heq _]].
      intros.
      specialize (Heq b H).
      destruct ((build_delta_content dmap mc) ! b) eqn:Hbuild; auto.
      unfold build_delta_content in Hbuild.
      erewrite PTree.gmap in *.
      unfold Coqlib.option_map in *.
      destruct (dmap ! b) eqn:Hdmap;
        rewrite Hdmap in Hbuild; try discriminate.
      inversion Hbuild.
      intros ofs.
      specialize (Heq ofs).
      destruct Heq as [Heq| Heq]; rewrite Heq;
        auto.
    - intros.
      unfold build_delta_content.
      erewrite PTree.gmap in *.
      unfold Coqlib.option_map in *.
      erewrite projectAngel_correct_2;
        now eauto.
  Qed.
      
  Lemma ev_sim_incr:
    forall f f' ev ev'
      (Hincr: ren_incr f f')
      (Hinjective: forall b1 b1' b2,
          f' b1 = Some b2 ->
          f' b1' = Some b2 ->
          b1 = b1')
      (Hev_sim: event_sim f ev ev'),
      event_sim f' ev ev'.
  Proof.
    intros.
    inversion Hev_sim;
      econstructor; eauto using pmap_inj_incr, delta_content_inj_incr.
  Qed.
  
  Lemma trace_sim_incr:
    forall f f' trc trf
      (Hincr: ren_incr f f')
      (Hinjective: forall b1 b1' b2,
          f' b1 = Some b2 ->
          f' b1' = Some b2 ->
          b1 = b1')
      (Htr: trace_sim f trc trf),
      trace_sim f' trc trf.
  Proof.
    intros.
    induction Htr;
      econstructor;
      eauto using ev_sim_incr.
  Qed.       
  
  Lemma ctlType_inj :
    forall st c c' m m' (f fg: memren)
      (Hfg:forall b1 b2 : block, fg b1 = Some b2 -> b1 = b2)
      (Hincr: ren_incr fg f)
      (Hge_wd: ge_wd fg the_ge)
      (Hvalid: valid_mem m)
      (Hmem: mem_obs_eq f m m')
      (Hinj: ctl_inj f c c'),
      ctlType c m st <-> ctlType c' m' st.
  Proof.
    intros. unfold ctl_inj in Hinj.
    destruct c; destruct c'; try (by exfalso);
      unfold ctlType in *; try tauto.
    assert (Hat_ext := core_inj_ext _ _  Hfg Hge_wd Hincr Hvalid Hinj Hmem).
    destruct (at_external semSem s m) as [[? ?]|] eqn:Hext; simpl in *.
    - destruct (at_external semSem s0 m') as [[? ?]|];
        now tauto.
    - destruct (at_external semSem s0 m') as [[? ?]|]; [tauto|].
      split; auto.
  Qed.

  Lemma stepType_inj:
    forall tpc tpf i (pffi:containsThread tpf i) (pfci: containsThread tpc i) m m' f fg st
      (Hfg:forall b1 b2 : block, fg b1 = Some b2 -> b1 = b2)
      (Hincr: ren_incr fg f)
      (Hge_wd: ge_wd fg the_ge)
      (Hvalid_mem: valid_mem m)
      (Hmem_obs_eq: mem_obs_eq f m m'),
      ctl_inj f (getThreadC pfci) (getThreadC pffi) ->
      getStepType pfci m st <-> getStepType pffi m' st.
  Proof.
    intros.
    eapply ctlType_inj;
      try eauto.
  Qed.

  Lemma sim_reduce:
    forall tpc trc mc tpf trf mf xs f fg fp n m,
      sim tpc trc mc tpf trf mf xs f fg fp n ->
      m <= n ->
      sim tpc trc mc tpf trf mf xs f fg fp m.
  Proof.
    intros.
    inversion H.
    econstructor; eauto.
    intros.
    eapply HybridCoarseMachine.csafe_reduce; eauto.
    ssromega.
  Qed.

  Lemma sim_fail: sim_fail_def.
  Proof.
    unfold sim_fail_def.
    intros.
    exists trf.
    split.
    intros. econstructor 6; simpl; eauto.
    eapply (invF Hsim); eauto.
    eapply (mem_compf Hsim); eauto.
    eapply sim_reduce; eauto.
  Qed.

  Existing Instance HybridCoarseMachine.DilMem.
  Existing Instance HybridCoarseMachine.scheduler.
  
  Lemma internal_step_cmachine_step :
    forall (i : NatTID.tid) (tp tp' : thread_pool) (m m' : mem)
      (U : list nat) tr
      (Hcnt: containsThread tp i)
      (Hcomp: mem_compatible tp m)
      (Hstep_internal: internal_step Hcnt Hcomp tp' m'),
      exists tr',
      cmachine_step (((i :: U)), tr, tp) m
                    (((i :: U)), tr ++ tr', tp') m' /\
      (forall tp'' tr'' m'' U',
          cmachine_step (((i :: U)), tr,tp) m
                        ((U'), tr ++ tr'', tp'') m'' ->
          tp' = tp'' /\ m' = m'' /\ i :: U = U').
  Proof.
    intros.
    inversion Hstep_internal as [[? Hcore] | [[Hresume ?] | Hstart]]; subst;
      autounfold.
    - exists (List.map (fun mev => internal i mev) x).
      split.
      + replace m' with (diluteMem m') by reflexivity.
        assert (Heq: i :: U = @yield HybridCoarseMachine.scheduler (i :: U)) by reflexivity.
        rewrite Heq.
        eapply thread_step.
        reflexivity.
        simpl.
        eapply Hcore.
      + intros tp'' tr'' m'' U' Hstep.
        Opaque mem_compatible.
        assert (Hstep_internal': internal_step Hcnt Hcomp tp'' m'' /\ i :: U = U').
        { inversion Hstep; subst; clear Hstep; Tactics.pf_cleanup;
          simpl in *;
          inversion HschedN; subst;
          Tactics.pf_cleanup;
          unfold internal_step; try (by eexists; eauto);
            eapply internal_step_type in Hstep_internal;
          exfalso; simpl in *;
          unfold getStepType, ctlType in Hstep_internal;
            try inversion Htstep;
            try (inversion Hhalted); subst; Tactics.pf_cleanup;
              try inversion Hperm; subst;
          repeat match goal with
                 | [H1: context[match ?Expr with | _ => _ end],
                        H2: ?Expr = _ |- _] =>
                   rewrite H2 in H1
                 end; try discriminate;
            try (match goal with
                 | [H: match at_external ?A ?B ?C with _ => _ end |- _] =>
                   destruct (at_external A B C) eqn:Hext
                 end);
            try discriminate.
        }
        destruct Hstep_internal' as [Hstep_internal' Heq]; subst.
        destruct (internal_step_det Hstep_internal Hstep_internal'); subst;
          now auto.
    - exists [::].
      rewrite cats0.
      split.
      + assert (Heq: i :: U = @yield HybridCoarseMachine.scheduler (i :: U)) by reflexivity.
        rewrite Heq.
        eapply resume_step;
          now eauto.
      + intros tp'' tr'' m'' U' Hstep.
        Opaque mem_compatible.
        assert (Hstep_internal': internal_step Hcnt Hcomp tp'' m'' /\ i :: U = U').
        { inversion Hstep; subst; clear Hstep; Tactics.pf_cleanup;
            simpl in *;
            inversion HschedN; subst;
              Tactics.pf_cleanup;
              unfold internal_step; try (by eexists; eauto);
                eapply internal_step_type in Hstep_internal;
                exfalso; simpl in *;
                  unfold getStepType, ctlType in Hstep_internal;
                  try inversion Htstep;
                  try (inversion Hhalted); subst; Tactics.pf_cleanup;
                    try inversion Hperm; subst;
                      repeat match goal with
                             | [H1: context[match ?Expr with | _ => _ end],
                                    H2: ?Expr = _ |- _] =>
                               rewrite H2 in H1
                             end; try discriminate;
                        try (match goal with
                             | [H: match at_external ?A ?B ?C with _ => _ end |- _] =>
                               destruct (at_external A B C) eqn:Hext
                             end);
                        try discriminate.
        }
        destruct Hstep_internal' as [Hstep_internal' Heq]; subst.
        destruct (internal_step_det Hstep_internal Hstep_internal'); subst;
          now auto.
    - exists [::].
      rewrite cats0.
      split.
      + assert (Heq: i :: U = @yield HybridCoarseMachine.scheduler (i :: U)) by reflexivity.
        rewrite Heq.
        replace m' with (@diluteMem HybridCoarseMachine.DilMem m') by reflexivity.
        eapply start_step;
          now eauto.
      + intros tp'' tr'' m'' U' Hstep.
        Opaque mem_compatible.
        assert (Hstep_internal': internal_step Hcnt Hcomp tp'' m'' /\ i :: U = U').
        { inversion Hstep; subst; clear Hstep; Tactics.pf_cleanup;
            simpl in *;
            inversion HschedN; subst;
              Tactics.pf_cleanup;
              unfold internal_step; try (by eexists; eauto);
                eapply internal_step_type in Hstep_internal;
                exfalso; simpl in *;
                  unfold getStepType, ctlType in Hstep_internal;
                  try inversion Htstep;
                  try (inversion Hhalted); subst; Tactics.pf_cleanup;
                    try inversion Hperm; subst;
                      repeat match goal with
                             | [H1: context[match ?Expr with | _ => _ end],
                                    H2: ?Expr = _ |- _] =>
                               rewrite H2 in H1
                             end; try discriminate;
                        try (match goal with
                             | [H: match at_external ?A ?B ?C with _ => _ end |- _] =>
                               destruct (at_external A B C) eqn:Hext
                             end);
                        try discriminate.
        }
        destruct Hstep_internal' as [Hstep_internal' Heq]; subst.
        destruct (internal_step_det Hstep_internal Hstep_internal'); subst;
          now auto.
  Qed.

  Notation corestepN := (corestepN (AsmContext.coarse_semantics initU)).
  Lemma safety_det_corestepN_internal:
    forall xs i U tpc trc mc tpc' mc' fuelF
      (Hsafe : csafe ((i :: U),trc,tpc) mc
                     (fuelF.+1 + size xs))
      (Hexec : internal_execution [seq x <- xs | x == i] tpc mc tpc' mc'),
      exists trc',
      corestepN (size [seq x <- xs | x == i])
                ((i :: U), trc, tpc) mc ((i :: U), trc ++ trc', tpc') mc'
      /\ csafe ((i :: U),trc ++ trc',tpc') mc'
              (fuelF.+1 + size [seq x <- xs | x != i]).
  Proof.
    intros xs.
    induction xs as [ | x xs]; intros.
    { simpl in *. inversion Hexec; subst.
      exists [::]; rewrite cats0;
        now eauto.
      simpl in HschedN. discriminate.
    }
    { simpl in *.
      destruct (x == i) eqn:Hx; move/eqP:Hx=>Hx; subst.
      - inversion Hsafe.
        + simpl in H; by exfalso.
        + simpl in *.
          subst.
          inversion Hexec; subst; simpl in *; clear Hexec;
          inversion HschedN; subst i.
          assert (Hmach_step_det :=
                    internal_step_cmachine_step U trc Hstep0).
          destruct Hmach_step_det as [tr' [Hmach_step' Hmach_det]].
          specialize (Hmach_det _ _ _ _ Hstep).
          destruct Hmach_det as [? [? ?]]; subst.
          rewrite <- addSnnS in Hsafe0.
          destruct (IHxs tid U tp' _ m' tpc' mc' _ Hsafe0 Htrans)
            as [trc' [HcorestepN Hsafe']].
          exists (tr ++ trc').
          rewrite catA.
          split;
            now eauto.
        + exfalso.
          inversion Hexec; subst; simpl in *; clear Hexec;
          inversion HschedN; subst i.
          assert (Hmach_step_det := internal_step_cmachine_step U trc Hstep0).
          destruct Hmach_step_det as [tr' [Hmach_step' Hmach_det]].
          specialize (Hmach_det _ _ _ _ Hstep).
          destruct Hmach_det as [? [? ?]]; subst.
          exfalso;
            eapply list_cons_irrefl;
            now eauto.
      - simpl.
        rewrite <- addSnnS in Hsafe.
        destruct (IHxs i U tpc trc mc tpc' mc' (fuelF.+1) Hsafe Hexec) as [? [? ?]].
        eexists; split;
          [now eauto| rewrite <- addSnnS; now eauto].
    }
  Qed.

  Ltac absurd_internal Hstep :=
    inversion Hstep; try inversion Htstep; subst; simpl in *; Tactics.pf_cleanup;
    try match goal with
        | [H: Some _ = Some _ |- _] => inversion H; subst
        end; Tactics.pf_cleanup;
    repeat match goal with
           | [H: OrdinalPool.getThreadC ?Pf = _, Hint: ?Pf$_ @ I |- _] =>
             unfold getStepType, ctlType in Hint; simpl in *;
             rewrite H in Hint; simpl in Hint
           | [H: getThreadC ?Pf = _, Hint: ?Pf$_ @ I |- _] =>
             unfold getStepType, ctlType in Hint; simpl in *;
             rewrite H in Hint; simpl in Hint
           | [H1: match ?Expr with _ => _ end = _,
                  H2: ?Expr = _ |- _] => rewrite H2 in H1
                      end; try discriminate; try (exfalso; by auto).

  Lemma at_internal_cmachine_step :
    forall i U U' tp tr tr' tp' m m'
      (cnt: containsThread tp i)
      (Hcomp: mem_compatible tp m),
      let mrestr := restrPermMap (((compat_th _ _ Hcomp) cnt).1) in
      forall (Hinternal: cnt$mrestr @ I)
      (Hstep: cmachine_step ((i :: U), tr,tp) m (U', tr ++ tr', tp') m'),
        internal_step cnt Hcomp tp' m' /\ U' = (i :: U).
  Proof.
    intros.
    absurd_internal Hstep.
    - split; auto.
      do 2 right;
        by auto.
    - split; auto.
      right; left;
        by auto.
    - split; auto.
      left; now eauto.
    - inversion Hperm; subst.
      subst mrestr.
      rewrite Hat_external in Hinternal.
      discriminate.
  Qed.

  Lemma internal_step_wd:
    forall tp m tp' m' i (cnti: containsThread tp i) f fg
      (Hcomp: mem_compatible tp m)
      (Hmem_wd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Htp_wd: tp_wd f tp)
      (Hge_wd: ge_wd fg the_ge)
      (Hfg_incr: ren_domain_incr fg f)
      (Hstep: internal_step cnti Hcomp tp' m'),
      valid_mem m' /\
      (exists f' : memren, ren_domain_incr f f' /\ domain_memren f' m') /\
      (forall f' : memren, domain_memren f' m' -> tp_wd f' tp').
  Proof.
    intros.
    inversion Hstep as [[? Htstep] | [[Htstep ?] | Htstep]].
    - inversion Htstep; subst.
      erewrite restrPermMap_mem_valid with (Hlt := fst (compat_th _ _ Hcomp cnti)) in Hmem_wd.
      eapply ev_step_ax1 in Hcorestep.
      eapply @corestep_wd with (f := f) (fg := fg) in Hcorestep;
        eauto.
      destruct Hcorestep as [Hmem_wd' [Hf' Hcore_wd']].
      destruct Hf' as [f' [Hincr Hdomain']].
      assert (Hcore_wd_f':= Hcore_wd' _ Hdomain').
      split; auto.
      split; first by (eexists; eauto).
      intros f'' Hdomain''.
      intros j cntj.
      specialize (Hcore_wd' f'' Hdomain'').
      destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
      rewrite gssThreadCode.
      simpl;
        by auto.
      assert (cntj' := containsThread_internal_step' Hstep cntj).
      erewrite @gsoThreadCode with (cntj := cntj') by eauto.
      specialize (Htp_wd _ cntj').
      assert (Hincr': ren_domain_incr f f'').
        by (eapply domain_memren_incr with (f' := f'); eauto).
      eapply ctl_wd_incr;
        by eauto.
      specialize (Htp_wd _ cnti).
      rewrite Hcode in Htp_wd;
        by simpl in Htp_wd.
    - subst. split; auto.
      inversion Htstep; subst.
      split.
      exists f.
      split; unfold ren_domain_incr;
        by auto.
      intros f'' Hdomain''.
      intros j cntj'.
      assert (cntj: containsThread tp j)
        by (eapply cntUpdateC'; eauto).
      assert (Hincr: ren_domain_incr f f'')
        by (eapply domain_memren_incr with (f' := f) (f'' := f''); eauto;
            apply ren_domain_incr_refl).
      destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
      + rewrite gssThreadCC.
        Tactics.pf_cleanup.
        specialize (Htp_wd _ ctn).
        rewrite Hcode in Htp_wd.
      destruct X as [? ?].
      simpl in *.
      destruct Htp_wd as [Hcore_wd _].
      inversion Hperm; subst.
      erewrite restrPermMap_domain with (Hlt := (compat_th _ _ Hcomp ctn)#1) in Hdomain.
      erewrite restrPermMap_mem_valid with (Hlt := (compat_th _ _ Hcomp ctn)#1) in Hmem_wd.
      assert (Hargs:= at_external_wd _ Hmem_wd Hdomain Hcore_wd Hat_external).
      eapply after_external_wd; eauto.
      eapply core_wd_incr; eauto.
      eapply valid_val_list_incr;
        by eauto.
      simpl; auto.
      + erewrite <- @gsoThreadCC with (cntj := cntj); eauto.
        specialize (Htp_wd _ cntj).
        eapply ctl_wd_incr;
          by eauto.
    - inversion Htstep; subst.
      Tactics.pf_cleanup.
      inversion Hperm; subst.
      erewrite restrPermMap_mem_valid with (Hlt := fst (compat_th _ _ Hcomp cnti)) in Hmem_wd.
      eapply @initial_core_wd with (f := f) in Hinitial; eauto.
      destruct Hinitial as [Hmem_Wd' [Hf' Hcore_wd']].
      destruct Hf' as [f' [Hincr Hdomain']].
      assert (Hcore_wd_f' := Hcore_wd' _ Hdomain').
      split; auto.
      split; first by (eexists; eauto).
      intros f'' Hdomain''.
      intros j cntj.
      specialize (Hcore_wd' f'' Hdomain'').
      destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
      rewrite gssThreadCode.
      simpl.
      apply Hcore_wd'.
      assert (cntj' := containsThread_internal_step' Hstep cntj).
      erewrite @gsoThreadCode with (cntj := cntj') by eauto.
      specialize (Htp_wd _ cntj').
      assert (Hincr': ren_domain_incr f f'').
        by (eapply domain_memren_incr with (f' := f'); eauto).
      eapply ctl_wd_incr;
        by eauto.
      specialize (Htp_wd _ cnti).
      rewrite Hcode in Htp_wd;
        simpl in Htp_wd.
      econstructor.
      destruct Htp_wd; now auto.
      now econstructor.
  Qed.

  Lemma internal_execution_wd:
    forall tp m tp' m' i xs f fg
      (Hdomain: domain_memren f m)
      (Hmem_wd: valid_mem m)
      (Htp_wd: tp_wd f tp)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_domain_incr fg f)
      (Hexec: internal_execution [seq x <- xs | x == i] tp m tp' m'),
      valid_mem m' /\
      (exists f' : memren, ren_domain_incr f f' /\ domain_memren f' m') /\
      (forall f' : memren, domain_memren f' m' -> tp_wd f' tp').
  Proof.
    intros.
    generalize dependent m.
    generalize dependent f.
    generalize dependent tp.
    induction xs; intros.
    - simpl in Hexec; inversion Hexec; subst;
        [idtac| simpl in HschedN; by discriminate];
        split; auto;
          split; [exists f; split; unfold ren_domain_incr; auto | eauto].
      intros.
      eapply tp_wd_domain;
        by eauto.
    - simpl in Hexec.
      destruct (a == i) eqn:Heq; move/eqP:Heq=>Heq; try eauto.
      subst a. inversion Hexec; subst.
      simpl in Htrans.
      simpl in HschedN; inversion HschedN; subst tid.
      assert (H := internal_step_wd Hmem_wd Hdomain Htp_wd Hge_wd Hge_incr Hstep).
      destruct H as [Hmem_wd0' [[f' [Hincr Hdomain0']] Htp_wd0']].
      specialize (Htp_wd0' f' Hdomain0').
      assert (Hge_incr0': ren_domain_incr fg f')
        by ( eapply ren_domain_incr_trans; eauto).
      assert (Hge_wd0': ge_wd f' the_ge)
        by (eapply ge_wd_incr; eauto).
      destruct (IHxs _ f' Htp_wd0' Hge_incr0'  m'0 Hdomain0' Hmem_wd0' Htrans)
        as (Hwd_mem' & Hf'' & Htp_wd').
      destruct Hf'' as [f'' [Hincr'' Hdomain'']].
      specialize (Htp_wd' _ Hdomain'').
      assert (ren_domain_incr f f'')
        by (eapply ren_domain_incr_trans; eauto).
      repeat match goal with
             | [|- _ /\ _] => split; eauto
             | [|- exists _, _] => eexists; eauto
             | [|- forall _, _] => intros
             end.
      eapply tp_wd_domain;
        by eauto.
  Qed.

  Lemma suspend_tp_wd:
    forall m tpc tpc' (f : memren) i (pfc : containsThread tpc i)
      (Hsuspend: suspend_thread m pfc tpc')
      (Htp_wd: tp_wd f tpc),
      tp_wd f tpc'.
  Proof.
    intros.
    inversion Hsuspend; subst.
    intros j cntj.
    destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
    rewrite gssThreadCC.
    simpl. specialize (Htp_wd _ ctn).
    rewrite Hcode in Htp_wd.
    simpl in Htp_wd;
      by assumption.
    assert (ctnj0: containsThread tpc j)
      by (eapply cntUpdateC'; eauto).
    specialize (Htp_wd _ ctnj0).
    erewrite <- @gsoThreadCC with (cntj := ctnj0);
      by auto.
  Qed.

  Lemma weak_obs_eq_restr :
    forall (m m' : Mem.mem) (f : memren)
      (weakObsEq: weak_mem_obs_eq f m m')
      (pf: permMapLt (getCurPerm m) (getMaxPerm m))
      (pf': permMapLt (getCurPerm m') (getMaxPerm (setMaxPerm m'))),
      weak_mem_obs_eq f (restrPermMap pf) (restrPermMap pf').
  Proof.
    intros. inversion weakObsEq.
    constructor; auto.
    intros.
    assert (Hrestr := restrPermMap_correct pf b1 ofs).
    destruct Hrestr as [_ Hcur].
    assert (Hrestr' :=
              restrPermMap_correct pf' b2 ofs).
    destruct Hrestr' as [_ Hcur'].
    rewrite Hcur; rewrite Hcur';
    do 2 rewrite getCurPerm_correct; eauto.
  Qed.

  Lemma mem_obs_eq_restr :
    forall (m m' : Mem.mem) (f : memren)
      (memObsEq: mem_obs_eq f m m')
      (pf: permMapLt (getCurPerm m) (getMaxPerm m))
      (pf': permMapLt (getCurPerm m') (getMaxPerm (setMaxPerm m'))),
      mem_obs_eq f (restrPermMap pf) (restrPermMap pf').
  Proof.
    intros.
    destruct memObsEq as [HweakObs HstrongObs].
    destruct HstrongObs as [Hperm_eq Hval].
    assert (Hrestr := restrPermMap_correct pf).
    assert (Hrestr' :=
              restrPermMap_correct pf').
    constructor;
      first by (eapply weak_obs_eq_restr; eauto).
    constructor;
      first by
        (intros;
          destruct (Hrestr b1 ofs) as [_ Hcur];
          destruct (Hrestr' b2 ofs) as [_ Hcur'];
          rewrite Hcur Hcur';
          do 2 rewrite getCurPerm_correct; auto).
    intros b1 b2 ofs Hf Hperm. unfold restrPermMap; simpl.
    eapply Hval; eauto.
    unfold Mem.perm in *.
    destruct (Hrestr b1 ofs) as [_ Hcur].
    unfold permission_at in *.
    rewrite Hcur in Hperm.
    rewrite getCurPerm_correct in Hperm;
      by assumption.
  Qed.

  Lemma weak_obs_eq_setMax:
    forall (f : memren) (m m' : mem),
      weak_mem_obs_eq f m m' <-> weak_mem_obs_eq f m (setMaxPerm m').
  Proof.
    intros. split; intros Hweak_obs;
            inversion Hweak_obs;
            constructor; auto;
            intros.
    rewrite setMaxPerm_Cur;
      by auto.
    specialize (perm_obs_weak0 _ _ ofs Hrenaming).
    rewrite setMaxPerm_Cur in perm_obs_weak0.
      by auto.
  Qed.

  Lemma weak_mem_obs_eq_restrEq:
    forall f f' mc mf mc' mf' pmap pmapF
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (Hlt': permMapLt pmap (getMaxPerm mc'))
      (HltF': permMapLt pmapF (getMaxPerm mf'))
      (Hobs_eq: weak_mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hobs_eq': weak_mem_obs_eq f' mc' mf')
      (Hincr: ren_incr f f')
      (Hsep: ren_separated f f' mc mf),
      weak_mem_obs_eq f' (restrPermMap Hlt') (restrPermMap HltF').
  Proof.
    intros.
    destruct Hobs_eq'.
    econstructor; intros; eauto.
    erewrite restrPermMap_valid; eauto.
    destruct (valid_block_dec mc b1) as [Hvalid | Hinvalid].
    - apply (domain_valid Hobs_eq) in Hvalid.
      destruct Hvalid as [b2' Hf].
      assert (b2 = b2')
        by (apply Hincr in Hf; rewrite Hf in Hrenaming; inversion Hrenaming; subst; auto).
      subst b2'.
      pose proof (perm_obs_weak Hobs_eq b1 ofs Hf).
      rewrite! restrPermMap_Cur.
      rewrite! restrPermMap_Cur in H.
      assumption.
    - apply (domain_invalid Hobs_eq) in Hinvalid.
      destruct (Hsep b1 b2 Hinvalid Hrenaming) as [_ Hnone].
      pose proof (invalid_block_empty HltF Hnone ofs) as HnoneCur.
      rewrite! restrPermMap_Cur. rewrite HnoneCur.
      now apply po_None.
  Qed.

  Lemma strong_mem_obs_eq_disjoint_step:
    forall f f' mc mf mc' mf' pmap pmapF
      (Hlt: permMapLt pmap (getMaxPerm mc))
      (HltF: permMapLt pmapF (getMaxPerm mf))
      (Hlt': permMapLt pmap (getMaxPerm mc'))
      (HltF': permMapLt pmapF (getMaxPerm mf'))
      (Hobs_eq: mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hstable: forall b ofs, Mem.perm (restrPermMap Hlt) b ofs Cur Readable ->
                         ZMap.get ofs (Mem.mem_contents mc) # b = ZMap.get ofs (Mem.mem_contents mc') # b)
      (HstableF: forall b ofs, Mem.perm (restrPermMap HltF) b ofs Cur Readable ->
                          ZMap.get ofs (Mem.mem_contents mf) # b = ZMap.get ofs (Mem.mem_contents mf') # b)
      (Hincr: ren_incr f f')
      (Hsep: ren_separated f f' mc mf),
      strong_mem_obs_eq f' (restrPermMap Hlt') (restrPermMap HltF').
  Proof.
    intros.
    econstructor; intros.
    - destruct (valid_block_dec mc b1) as [Hvalid | Hinvalid].
      + 
        pose proof (weak_obs_eq Hobs_eq) as Hweak_obs_eq.
        apply (domain_valid Hweak_obs_eq) in Hvalid.
        destruct Hvalid as [b2' Hf].
        assert (b2 = b2')
          by (apply Hincr in Hf; rewrite Hrenaming in Hf; inversion Hf; subst; auto);
          subst b2'.
        rewrite! restrPermMap_Cur.
        pose proof (perm_obs_strong (strong_obs_eq Hobs_eq) _ ofs Hf) as Heq.
        rewrite! restrPermMap_Cur in Heq.
        now assumption.
      + 
        apply (domain_invalid (weak_obs_eq Hobs_eq)) in Hinvalid.
        destruct (Hsep b1 b2 Hinvalid Hrenaming) as [Hnone HnoneF].
        pose proof (invalid_block_empty Hlt Hnone ofs) as HnoneCur.
        pose proof (invalid_block_empty HltF HnoneF ofs) as HnoneCurF.
        rewrite! restrPermMap_Cur. rewrite HnoneCur HnoneCurF; reflexivity.
    - simpl.
      pose proof (val_obs_eq (strong_obs_eq Hobs_eq)) as Hval_eq.
      unfold Mem.perm in *.
      destruct (valid_block_dec mc b1) as [Hvalid | Hinvalid].
      + 
        apply (domain_valid (weak_obs_eq Hobs_eq)) in Hvalid.
        destruct Hvalid as [b2' Hf].
        assert (b2 = b2')
          by (apply Hincr in Hf; rewrite Hrenaming in Hf; inversion Hf; subst; auto);
          subst b2'.
        pose proof (restrPermMap_Cur Hlt b1 ofs) as H1.
        pose proof (restrPermMap_Cur Hlt' b1 ofs) as H1'.
        unfold permission_at in *.
        specialize (Hval_eq b1 b2 ofs Hf).
        rewrite H1' in Hperm; rewrite H1 in Hval_eq.
        specialize (Hval_eq Hperm).
        simpl in Hval_eq.
        erewrite <- Hstable by (rewrite H1; assumption).
        erewrite <- HstableF by (pose proof (perm_obs_strong (strong_obs_eq Hobs_eq)) as Heq;
                                unfold permission_at in Heq;
                                erewrite Heq; eauto;
                                rewrite H1; assumption).
        eauto using memval_obs_eq_incr.
      + 
        exfalso.
        apply (domain_invalid (weak_obs_eq Hobs_eq)) in Hinvalid.
        destruct (Hsep b1 b2 Hinvalid Hrenaming) as [Hnone HnoneF].
        pose proof (invalid_block_empty Hlt Hnone ofs) as HnoneCur.
        pose proof (restrPermMap_Cur Hlt' b1 ofs) as H1'.
        unfold permission_at in *.
        rewrite H1' in Hperm.
        rewrite HnoneCur in Hperm.
        simpl in Hperm.
        now assumption.
  Qed.

  Lemma tsim_fstep_safe:
    forall tpc tpc' tpf mc mc' mf i fi fg tr
      (pfc: containsThread tpc i) (pff: containsThread tpf i)
      (Hcompc: mem_compatible tpc mc)
      (Hcompf: mem_compatible tpf mf)
      (HmaxF: max_inv mf)
      (HinvF: invariant tpf)
      (Hge_wd: ge_wd fg the_ge)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hren_incr: ren_incr fg fi)
      (Hstrong_sim: strong_tsim fi pfc pff Hcompc Hcompf)
      (Hmem_wd: valid_mem mc)
      (Hstep_internal: internal_step pfc Hcompc tpc' mc'),
    exists tpf' mf' fi' tr',
      (forall U, fmachine_step (i :: U, tr, tpf) mf (U, tr', tpf') mf') /\
      max_inv mf' /\
      ren_incr fi fi' /\
      ren_separated fi fi' mc mf /\
      (forall (pfc': containsThread tpc' i) (pff': containsThread tpf' i)
         (Hcompc': mem_compatible tpc' mc') (Hcompf': mem_compatible tpf' mf'),
          strong_tsim fi' pfc' pff' Hcompc' Hcompf' /\
          (forall b2, (~exists b1, fi' b1 = Some b2) ->
                 forall ofs, (getThreadR pff').1 # b2 ofs = (getThreadR pff).1 # b2 ofs /\
                        (getThreadR pff').2 # b2 ofs = (getThreadR pff).2 # b2 ofs)) /\
      (forall j (pffj : containsThread tpf j),
          i <> j ->
          forall (b1 b2 : block),
            fi' b1 = Some b2 ->
            fi b1 = None ->
            forall ofs, (getThreadR pffj).1 # b2 ofs = None /\ (getThreadR pffj).2 # b2 ofs = None) /\
      (forall (bl : block) (ofsl : Z)
         rmap
         (b1 b2 : block) (ofs : Z),
          fi' b1 = Some b2 ->
          fi b1 = None ->
          lockRes tpf (bl, ofsl) = Some rmap -> rmap.1 # b2 ofs = None /\ rmap.2 # b2 ofs = None).
  Proof.
    intros.
    assert (HinvC': invariant tpc')
      by (eapply internal_step_invariant; eauto).
    destruct Hstep_internal as [[? Hcstep] | [Hresume | Hstart]].
    { inversion Hcstep; subst; clear Hcstep.
      destruct Hstrong_sim as [Hcode_eq memObsEq_data memObsEq_locks].
      rewrite Hcode in Hcode_eq.
      
      simpl in Hcode_eq.
      destruct (OrdinalPool.getThreadC pff) as [cf| ? | ? | ?] eqn:Hcodef;
        try (by exfalso).
      assert (H' := Hcorestep).
      apply ev_step_ax1 in Hcorestep.
      eapply corestep_obs_eq in Hcorestep; eauto. 
      destruct Hcorestep as
          (cf' & mf' & fi' & HcorestepF & Hcode_eq'
           & Hobs_eq' & Hincr & Hseparated
           & Hblocks & _ & _ & Hperm_unmapped).
      remember (restrPermMap (fst (compat_th _ _ Hcompf pff))) as mf1 eqn:Hrestrict.
      symmetry in Hrestrict.
      remember (updThread pff (Krun cf') (getCurPerm mf', (getThreadR pff).2))
        as tpf' eqn:Hupd.
      assert (Hevent_stepF:=ev_step_ax2 _ _ _ _ _ HcorestepF).
      destruct Hevent_stepF as [evF Hev_stepF].
      exists tpf', (setMaxPerm mf'), fi', (tr ++ (List.map (fun mev => internal i mev) evF)).
      split.
      { 
        intros U.
        simpl.
        unfold MachStep. simpl.

        replace U with (fyield (i :: U)) at 2 by reflexivity.
        replace (setMaxPerm mf') with (fdiluteMem mf') by reflexivity.
        eapply thread_step; simpl; eauto.
        econstructor;
          now eauto.
      }
      {
        split.
        unfold max_inv.
        intros b ofs Hvalid.
        rewrite setMaxPerm_MaxV;
          by auto.
        split; first by assumption.
        split.
        
        clear - Hupd Hseparated Hrestrict HmaxF.
        subst mf1.
        unfold ren_separated in *.
        intros b1 b2 Hfi Hfi'.
        specialize (Hseparated _ _ Hfi Hfi').
        do 2 erewrite restrPermMap_valid in Hseparated;
          by assumption.
        split.
        { intros. split.
          - 
            intros.
            econstructor;
              first by (subst tpf'; by do 2 erewrite gssThreadCode).
            + 
              assert (Hlt_mc' : permMapLt (getCurPerm mc')
                                          (getMaxPerm mc'))
                by (unfold permMapLt; intros;
                    rewrite getCurPerm_correct; rewrite getMaxPerm_correct;
                    apply Mem.access_max).
              erewrite restrPermMap_irr' with (Hlt' := Hlt_mc')
                by (by rewrite gssThreadRes).
              assert (Hlt_mf': permMapLt (getCurPerm mf')
                                         (getMaxPerm (setMaxPerm mf'))).
              { unfold permMapLt. intros.
                rewrite getCurPerm_correct. rewrite getMaxPerm_correct.
                destruct (valid_block_dec mf' b) as [Hvalid | Hinvalid].
                erewrite setMaxPerm_MaxV by assumption. simpl.
                destruct (permission_at mf' b ofs Cur); constructor.
                erewrite setMaxPerm_MaxI by assumption. simpl.
                apply Mem.nextblock_noaccess with (ofs := ofs) (k := Cur) in Hinvalid.
                unfold permission_at. rewrite Hinvalid. constructor.
              }
              erewrite restrPermMap_irr' with (Hlt' := Hlt_mf')
                by (subst tpf'; rewrite gssThreadRes; eauto);
                by eapply mem_obs_eq_restr.
            + 
                            subst.
              assert (Hlt: permMapLt (getThreadR pfc').2 (getMaxPerm mc))
                by (rewrite gssThreadRes; simpl; destruct Hcompc; destruct (compat_th0 _ pfc); eauto).
              assert (HltF: permMapLt (getThreadR pff').2 (getMaxPerm mf))
                by (rewrite gssThreadRes; simpl; destruct Hcompf as [compat_thf ?]; destruct (compat_thf _ pff); eauto).
              constructor.
              
              pose proof (weak_obs_eq memObsEq_locks) as Hobs_weak_locks.
              erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
              erewrite restrPermMap_irr' with (Hlt' := HltF) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
              
              eapply weak_mem_obs_eq_restrEq with (Hlt := Hlt) (HltF := HltF); eauto.
              erewrite <- weak_obs_eq_setMax; now eapply (weak_obs_eq Hobs_eq').
              
              erewrite restrPermMap_irr' with (Hlt' := Hlt) in memObsEq_locks by (rewrite gssThreadRes; simpl; auto).
              erewrite restrPermMap_irr' with (Hlt' := HltF) in memObsEq_locks by (rewrite gssThreadRes; simpl; auto).
              eapply strong_mem_obs_eq_disjoint_step; eauto.
              
              intros.
              pose proof (fst (thread_data_lock_coh _ Hinv _ pfc) _ pfc).
              apply ev_step_ax1 in H'.
              eapply CoreLanguageDry.corestep_stable_val with (Hlt2 := Hlt); eauto.
              rewrite gssThreadRes; simpl;
                by eauto.
              
              intros.
              pose proof (fst (thread_data_lock_coh _ HinvF _ pff) _ pff).
              simpl.
              eapply CoreLanguageDry.corestep_stable_val with (Hlt2 := HltF); eauto.
              rewrite gssThreadRes; simpl;
                by eauto.
          - 
            intros b2 Hfi' ofs.
            subst.
            rewrite gssThreadRes. simpl.
            specialize (Hperm_unmapped _ Hfi' ofs).
            rewrite! restrPermMap_Cur in Hperm_unmapped.
            rewrite Hperm_unmapped.
            rewrite getCurPerm_correct;
              by auto.
        }
        
        split.
        * intros j pffj Hij b1 b2 Hfi' Hfi ofs.
          specialize (Hseparated _ _ Hfi Hfi').
          destruct Hseparated as [Hinvalidmc1 Hinvalidmf1].
          subst mf1.
          erewrite restrPermMap_valid in Hinvalidmf1.
          pose proof (invalid_block_empty (fst (compat_th _ _ Hcompf pffj)) Hinvalidmf1 ofs).
          pose proof (invalid_block_empty (snd (compat_th _ _ Hcompf pffj)) Hinvalidmf1 ofs);
            split; by assumption.
        * intros bl ofsl rmap b1 b2 ofs Hfi' Hfi Hres.
          specialize (Hseparated _ _ Hfi Hfi').
          destruct Hseparated as [Hinvalidmc1 Hinvalidmf1].
          subst mf1.
          erewrite restrPermMap_valid in Hinvalidmf1.
          pose proof (invalid_block_empty (fst (compat_lp _ _ Hcompf _ _ Hres)) Hinvalidmf1 ofs).
          pose proof (invalid_block_empty (snd (compat_lp _ _ Hcompf _ _ Hres)) Hinvalidmf1 ofs);
            split; by assumption.
      }
    }
    { destruct Hresume as [Hresume Heq]; subst.
      inversion Hresume; subst; clear Hresume; Tactics.pf_cleanup.
      destruct Hstrong_sim as [Hcode_eq memObsEq].
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (OrdinalPool.getThreadC pff) as [?|?|cf |? ] eqn:HcodeF;
        try (by exfalso).
      destruct Hcode_eq as [Hcode_eq Hval_eq].
      inversion Hval_eq; subst.
      
      assert (Hvalid_val: match (Some (Vint Int.zero)) with
                          | Some v1 => valid_val fi v1
                          | None => True
                          end)
        by (by simpl).
      inversion Hperm; subst.
      assert (Hafter_externalF :=
                core_inj_after_ext _ _ None Hfg Hge_wd Hren_incr Hcode_eq
                                   memObsEq Hvalid_val Hafter_external).
      destruct Hafter_externalF as [ov2 [cf' [Hafter_externalF [Hcode_eq' Hval_obs]]]].
      destruct ov2 as [v2 |]; try by exfalso.
      inversion Hval_obs; subst.
      erewrite restrPermMap_mem_valid with (Hlt := (compat_th _ _ Hcompc pfc)#1) in Hmem_wd.
      
      assert (Hat_externalF_spec := core_inj_ext _ _  Hfg Hge_wd Hren_incr Hmem_wd Hcode_eq memObsEq).
      rewrite Hat_external in Hat_externalF_spec.
      simpl in Hat_externalF_spec.
      destruct X as [ef val].
      destruct (at_external semSem cf (restrPermMap (proj1 (compat_th _ _ Hcompf pff))))
        as [[ef' val']|] eqn:Hat_externalF;
        rewrite Hat_externalF in Hat_externalF_spec;
        try by exfalso.
      destruct Hat_externalF_spec as [? Harg_obs]; subst.
      remember (updThreadC pff (Krun cf')) as tpf' eqn:Hupd.
      exists tpf', mf, fi, tr.
      split.
      { 
        intros.
        simpl.
        unfold MachStep. simpl.
        replace U with (fyield (i :: U)) at 2 by reflexivity.
        eapply @resume_step with (Htid := pff); simpl; eauto.
        subst.

        eapply @ResumeThread with (c := cf);
          eauto.
        simpl. unfold DryHybridMachine.install_perm.
        reflexivity.
      }
      { split; first by auto.
        split; first by auto.
        split; first by congruence.
        split.
        intros.
        split.
        constructor;
          first by (subst tpf';
                    do 2 rewrite gssThreadCC; by simpl).
        erewrite restrPermMap_irr' with
        (Hlt' := fst (compat_th _ _ Hcompf pff)) by (subst; by erewrite @gThreadCR with (cntj := pff)).
        erewrite restrPermMap_irr; eauto;
          by rewrite gThreadCR.
        erewrite restrPermMap_irr' with
        (Hlt' := snd (compat_th _ _ Hcompf pff)) by (subst; by erewrite @gThreadCR with (cntj := pff)).
        erewrite restrPermMap_irr; eauto;
          by rewrite gThreadCR.
        intros. subst. rewrite gThreadCR; auto.
        split; [ | split]; intros; by congruence.
      }
    }
    { inversion Hstart; subst; clear Hstart; Tactics.pf_cleanup.
      destruct Hstrong_sim as [Hcode_eq memObsEq].
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (OrdinalPool.getThreadC pff) as [?|?|? |vf' arg'] eqn:HcodeF;
        try (by exfalso).
      destruct Hcode_eq as [Hvf Harg_obs].
      assert (Harg_obs_list: val_obs_list fi [:: arg] [:: arg'])
        by (constructor; auto; constructor).
      inversion Hperm; subst.
      assert (HinitF := core_inj_init _ _ i  Hge_wd Hfg Hren_incr Harg_obs_list Hvf memObsEq Hinitial).
      destruct HinitF as
          (cf' & mf' & fi' & HcorestepF & Hcode_eq'
           & Hobs_eq' & Hincr & Hseparated
           & Hblocks & _ & _ & Hperm_unmapped).
      remember (updThread pff (Krun cf') (add_block Hcompf pff mf')) as tpf' eqn:Hupd.
      exists tpf', (@diluteMem FineDilMem mf'), fi', tr.
      split.
      { 
        intros.
        simpl.
        unfold MachStep; simpl.
        replace U with (fyield (i :: U)) at 2 by reflexivity.
        eapply @start_step; simpl; eauto.
        eapply @StartThread with (c_new := cf') (Hcmpt := Hcompf);
          try eauto.
        simpl.
        unfold DryHybridMachine.install_perm.
        reflexivity.
      }
      { repeat match goal with
                 [|- _ /\ _] => split
               end; auto.
        - intros b ofs Hvalid.
          rewrite setMaxPerm_MaxV;
            by auto.
        - intros. split.
          + 
            intros.
            econstructor;
              first by (subst tpf'; by do 2 erewrite gssThreadCode).
            * 
              assert (Hlt_mc' : permMapLt (getCurPerm mc')
                                          (getMaxPerm mc'))
                by (unfold permMapLt; intros;
                    rewrite getCurPerm_correct; rewrite getMaxPerm_correct;
                    apply Mem.access_max).
              erewrite restrPermMap_irr' with (Hlt' := Hlt_mc')
                by (by rewrite gssThreadRes).
              assert (Hlt_mf': permMapLt (getCurPerm mf')
                                         (getMaxPerm (setMaxPerm mf'))).
              { unfold permMapLt. intros.
                rewrite getCurPerm_correct. rewrite getMaxPerm_correct.
                destruct (valid_block_dec mf' b) as [Hvalid | Hinvalid].
                erewrite setMaxPerm_MaxV by assumption. simpl.
                destruct (permission_at mf' b ofs Cur); constructor.
                erewrite setMaxPerm_MaxI by assumption. simpl.
                apply Mem.nextblock_noaccess with (ofs := ofs) (k := Cur) in Hinvalid.
                unfold permission_at. rewrite Hinvalid. constructor.
              }
              erewrite restrPermMap_irr' with (Hlt' := Hlt_mf')
                by (subst tpf'; rewrite gssThreadRes; eauto);
                by eapply mem_obs_eq_restr.
            * 
                            subst.
              assert (Hlt: permMapLt (getThreadR pfc').2 (getMaxPerm mc))
                by (rewrite gssThreadRes; simpl; destruct Hcompc; destruct (compat_th0 _ pfc); eauto).
              assert (HltF: permMapLt (getThreadR pff').2 (getMaxPerm mf))
                by (rewrite gssThreadRes; simpl; destruct Hcompf as [compat_thf ?]; destruct (compat_thf _ pff); eauto).
              constructor.
              
              pose proof (weak_obs_eq obs_eq_locks0) as Hobs_weak_locks.
              erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
              erewrite restrPermMap_irr' with (Hlt' := HltF) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
              
              eapply weak_mem_obs_eq_restrEq with (Hlt := Hlt) (HltF := HltF); eauto.
              erewrite <- weak_obs_eq_setMax; now eapply (weak_obs_eq Hobs_eq').
              
              erewrite restrPermMap_irr' with (Hlt' := Hlt) in obs_eq_locks0 by (rewrite gssThreadRes; simpl; auto).
              erewrite restrPermMap_irr' with (Hlt' := HltF) in obs_eq_locks0 by (rewrite gssThreadRes; simpl; auto).
              eapply strong_mem_obs_eq_disjoint_step; eauto.
              
              intros.
              pose proof (fst (thread_data_lock_coh _ Hinv _ pfc) _ pfc).
              eapply CoreLanguageDry.initial_core_stable_val with (Hlt2 := Hlt); eauto.
              rewrite gssThreadRes; simpl;
                by eauto.
              
              intros.
              pose proof (fst (thread_data_lock_coh _ HinvF _ pff) _ pff).
              simpl.
              eapply CoreLanguageDry.initial_core_stable_val with (Hlt2 := HltF); eauto.
              rewrite gssThreadRes; simpl;
                by eauto.
          + 
            intros b2 Hfi' ofs.
            subst.
            rewrite gssThreadRes. simpl.
            specialize (Hperm_unmapped _ Hfi' ofs).
            rewrite! restrPermMap_Cur in Hperm_unmapped.
            rewrite Hperm_unmapped.
            rewrite getCurPerm_correct;
              by auto.
        - 
                    intros j pffj Hij b1 b2 Hfi' Hfi ofs.
          specialize (Hseparated _ _ Hfi Hfi').
          destruct Hseparated as [Hinvalidmc1 Hinvalidmf1].

            erewrite restrPermMap_valid in Hinvalidmf1.
            pose proof (invalid_block_empty (fst (compat_th _ _ Hcompf pffj)) Hinvalidmf1 ofs).
            pose proof (invalid_block_empty (snd (compat_th _ _ Hcompf pffj)) Hinvalidmf1 ofs);
              split; by assumption.
        - intros bl ofsl rmap b1 b2 ofs Hfi' Hfi Hres.
          specialize (Hseparated _ _ Hfi Hfi').
          destruct Hseparated as [Hinvalidmc1 Hinvalidmf1].
          erewrite restrPermMap_valid in Hinvalidmf1.
          pose proof (invalid_block_empty (fst (compat_lp _ _ Hcompf _ _ Hres)) Hinvalidmf1 ofs).
          pose proof (invalid_block_empty (snd (compat_lp _ _ Hcompf _ _ Hres)) Hinvalidmf1 ofs);
            split; by assumption.
      }
    }
  Qed.

  Lemma setMaxPerm_valid:
    forall m b, Mem.valid_block m b <-> Mem.valid_block (setMaxPerm m) b.
  Proof.
    intros.
    unfold Mem.valid_block, setMaxPerm. simpl.
    now auto.
  Qed.

  Lemma weak_tsim_fstep:
    forall tpc tpf tpf' mc mf mf' i j f U tr tr'
      (pffi: containsThread tpf i)
      (pfcj: containsThread tpc j) (pffj: containsThread tpf j)
      (pffj': containsThread tpf' j)
      (Hcompc: mem_compatible tpc mc)
      (Hcompf: mem_compatible tpf mf)
      (Hcompf': mem_compatible tpf' mf')
      (HinvF: invariant tpf),
      let mrestr := restrPermMap (((compat_th _ _ Hcompf) pffi).1) in
      forall (Hinternal: pffi$mrestr @ I)
        (Hstep: fmachine_step (i :: U, tr, tpf) mf (U, tr',tpf') mf')
        (HweakSim: weak_tsim f pfcj pffj Hcompc Hcompf),
      weak_tsim f pfcj pffj' Hcompc Hcompf'.
  Proof.
    intros.
    Opaque OrdinalPool.containsThread OrdinalPool.getThreadR.
    destruct HweakSim as [Hweak_data Hweak_locks].
    destruct Hweak_data
      as [Hdomain_invalid Hdomain_valid Hcodomain_valid Hinjective Hperm_obs_weak_data].
    pose proof (perm_obs_weak Hweak_locks) as Hperm_obs_weak_lock.
    absurd_internal Hstep;
      do 2 constructor; auto.
    - 
      intros b1 b2 Hf.
      erewrite restrPermMap_valid.
      erewrite <- diluteMem_valid.
      specialize (Hcodomain_valid b1 b2 Hf).
      erewrite restrPermMap_valid in Hcodomain_valid.
      simpl.
      inversion Hperm; subst.
      erewrite <- setMaxPerm_valid.
      eapply initial_core_validblock;
        now eauto.
    - 
      intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_data _ _ ofs Hf).
      clear - Hinitial Hperm Hf Hcodomain_valid Hperm_obs_weak_data semAxioms.
      inversion Hperm; subst.
      destruct (j == tid) eqn:Hjtid; move/eqP:Hjtid=>Hjtid.
      + subst.
        eapply initial_core_decay in Hinitial.
        specialize (Hinitial b2 ofs).
        destruct Hinitial as [_ Hold].
        apply Hcodomain_valid in Hf.
        specialize (Hold Hf).
        unfold permission_at in Hperm_obs_weak_data.
        do 2 erewrite restrPermMap_Cur.
        rewrite gssThreadRes.
        rewrite getCurPerm_correct.
        unfold permission_at.
        rewrite <- Hold.
        rewrite <- restrPermMap_Cur with (Hlt := fst (compat_th _ _ Hcompc pfcj)).
        unfold permission_at.
        Tactics.pf_cleanup.
        assumption.
      + do 2 rewrite restrPermMap_Cur.
        simpl in *.
        erewrite OrdinalPool.gsoThreadRes with (cntj := pffj); eauto.
        do 2 rewrite restrPermMap_Cur in Hperm_obs_weak_data;
          by assumption.
    - 
      intros b1 b2 Hf.
      erewrite restrPermMap_valid.
      erewrite <- diluteMem_valid.
      specialize (Hcodomain_valid b1 b2 Hf).
      erewrite restrPermMap_valid in Hcodomain_valid.
      simpl.
      inversion Hperm; subst.
      erewrite <- setMaxPerm_valid.
      eapply initial_core_validblock;
        now eauto.
    - intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_lock _ _ ofs Hf).
      clear - Hinitial Hperm Hf Hcodomain_valid Hperm_obs_weak_lock.
      inversion Hperm; subst.
      rewrite! restrPermMap_Cur in Hperm_obs_weak_lock.
      do 2 rewrite restrPermMap_Cur.
      destruct (j == tid) eqn:Hjtid; move/eqP:Hjtid=>Hjtid.
      + subst.
        simpl. erewrite OrdinalPool.gssThreadRes. simpl.
        Tactics.pf_cleanup.
        assumption.
      + simpl.
        erewrite OrdinalPool.gsoThreadRes with (cntj := pffj) by eauto.
        assumption.
    - 
      intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_data b1 b2 ofs Hf).
      do 2 rewrite restrPermMap_Cur.
      do 2 rewrite restrPermMap_Cur in Hperm_obs_weak_data.
      simpl in *.
      erewrite OrdinalPool.gThreadCR with (cntj := pffj);
        by assumption.
    - intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_lock b1 b2 ofs Hf).
      do 2 rewrite restrPermMap_Cur.
      do 2 rewrite restrPermMap_Cur in Hperm_obs_weak_lock.
      simpl in *.
      erewrite OrdinalPool.gThreadCR with (cntj := pffj);
        by assumption.
    - 
      intros b1 b2 Hf.
      erewrite restrPermMap_valid.
      erewrite <- diluteMem_valid.
      specialize (Hcodomain_valid b1 b2 Hf).
      erewrite restrPermMap_valid in Hcodomain_valid.
      simpl.
      erewrite <- setMaxPerm_valid.
      eapply ev_step_validblock;
        by eauto.
    - intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_data _ _ ofs Hf).
      clear - Hcorestep Hf Hcodomain_valid Hperm_obs_weak_data semAxioms.
      eapply ev_step_ax1 in Hcorestep.
      destruct (j == tid) eqn:Hjtid; move/eqP:Hjtid=>Hjtid.
      + subst.
        eapply corestep_decay in Hcorestep.
        specialize (Hcorestep b2 ofs).
        destruct Hcorestep as [_ Hold].
        apply Hcodomain_valid in Hf.
        specialize (Hold Hf).
        unfold permission_at in Hperm_obs_weak_data.
        do 2 erewrite restrPermMap_Cur.
        rewrite gssThreadRes.
        rewrite getCurPerm_correct.
        unfold permission_at.
        destruct Hold as [Hfree | Heq].
        * destruct (Hfree Cur) as [Hfreeable Hempty].
          rewrite Hempty.
          simpl in *.
          destruct ((OrdinalPool.getThreadR pfcj).1 # b1 ofs); simpl;
            by constructor.
        * rewrite <- Heq.
          rewrite <- restrPermMap_Cur with (Hlt := fst (compat_th _ _ Hcompc pfcj)).
          unfold permission_at.
          Tactics.pf_cleanup.
            by assumption.
      + do 2 rewrite restrPermMap_Cur.
        simpl in *.
        erewrite OrdinalPool.gsoThreadRes with (cntj := pffj); eauto.
        do 2 rewrite restrPermMap_Cur in Hperm_obs_weak_data;
          by assumption.
    - intros b1 b2 Hf.
      erewrite restrPermMap_valid.
      erewrite <- diluteMem_valid.
      specialize (Hcodomain_valid b1 b2 Hf).
      erewrite restrPermMap_valid in Hcodomain_valid.
      simpl.
      erewrite <- setMaxPerm_valid.
      eapply ev_step_validblock;
        by eauto.
    - intros b1 b2 ofs Hf.
      specialize (Hperm_obs_weak_lock _ _ ofs Hf).
      clear - Hcorestep Hf Hcodomain_valid Hperm_obs_weak_lock.
      rewrite! restrPermMap_Cur in Hperm_obs_weak_lock.
      do 2 rewrite restrPermMap_Cur.
      destruct (j == tid) eqn:Hjtid; move/eqP:Hjtid=>Hjtid.
      + subst.
        simpl. erewrite OrdinalPool.gssThreadRes. simpl.
        Tactics.pf_cleanup.
        assumption.
      + simpl.
        erewrite OrdinalPool.gsoThreadRes with (cntj := pffj) by eauto.
        assumption.
    - inversion Hperm; subst.
      unfold mrestr in Hinternal.
      rewrite Hat_external in Hinternal.
      discriminate.
    - inversion Hperm; subst.
      unfold mrestr in Hinternal.
      rewrite Hat_external in Hinternal.
      discriminate.
  Qed.

  Lemma cmachine_step_invariant:
    forall tpc mc trc tpc' mc' trc' tpc'' trc'' mc'' U U' U'' n
      (HstepN: corestepN n
                         (U, trc, tpc) mc (U', trc',tpc') mc')
      (Hstep: cmachine_step (U', trc', tpc') mc' (U'',trc'', tpc'') mc''),
      invariant tpc.
  Proof.
    intros. destruct n; simpl in HstepN. inversion HstepN; subst.
    inversion Hstep; subst; try inversion Htstep; auto.
    simpl in *; subst; auto.
    destruct HstepN as [tpc''' [mc''' [Hstep0 _]]].
    clear Hstep.
    inversion Hstep0; subst; try inversion Htstep; auto.
    simpl in *; subst; auto.
  Qed.

  Definition updateFP {tpc i} (cnti: containsThread tpc i)
             (fp: fpool tpc) (f' : memren) :=
    fun j cntj => if i == j then f' else fp j cntj.

  Lemma gssFP :
    forall tpc i f' (fp : fpool tpc) (cnti: containsThread tpc i),
      (updateFP cnti fp f') i cnti = f'.
  Proof.
    intros. unfold updateFP.
    rewrite if_true; auto.
  Qed.

  Lemma gsoFP :
    forall tpc i j f' (fp : fpool tpc) (cnti: containsThread tpc i)
      (cntj: containsThread tpc j) (Hneq: i <> j),
      (updateFP cnti fp f') j cntj = fp j cntj.
  Proof.
    intros. unfold updateFP.
    erewrite if_false; auto.
    apply/eqP; auto.
  Qed.

  Definition addFP {tp} (fp: fpool tp) (f': memren) vf arg pmap :
    fpool (addThread tp vf arg pmap).
  Proof.
    refine( fun j cntj =>
              let n := Ordinal cntj in
              match unlift (ordinal_pos_incr (OrdinalPool.num_threads tp)) n with
              | Some (Ordinal _ cntj') => _
              | None => f'
              end).
    simpl in *.
    eapply (fp n0 cntj').
  Defined.

  Transparent OrdinalPool.containsThread.
  Lemma gsoAddFP :
    forall tp fp f vf arg pmap i
      (cnti: containsThread tp i)
      (cnti': containsThread (addThread tp vf arg pmap) i),
      addFP fp f cnti' = fp _ cnti.
  Proof.
    intros.
    unfold addFP in *.
    match goal with
    | [|- match ?Expr with _ => _ end = _] =>
      destruct Expr eqn:Hunlift
    end.
    destruct o. simpl in *.
    apply unlift_m_inv in Hunlift.
    subst. simpl.
    unfold OrdinalPool.containsThread in cnti.
    simpl in cnti;
      by Tactics.pf_cleanup.
    exfalso.
    simpl in *.
    unfold OrdinalPool.containsThread in *.
    simpl in *.
    assert (Hcontra: (ordinal_pos_incr (OrdinalPool.num_threads tp))
                       != (Ordinal (n:=(OrdinalPool.num_threads tp).+1) (m:=i) cnti')).
    { apply/eqP. intros Hcontra.
      unfold ordinal_pos_incr in Hcontra.
      inversion Hcontra; auto. subst.
        by ssromega.
    }
    apply unlift_some in Hcontra. rewrite Hunlift in Hcontra.
    destruct Hcontra;
      by discriminate.
  Qed.

  Lemma gssAddFP:
    forall tp fp f vf arg pmap j
      (Heq: j = latestThread tp)
      (cnt': containsThread (addThread tp vf arg pmap) j),
      addFP fp f cnt' = f.
  Proof.
    intros. subst.
    unfold addFP.
    unfold containsThread in cnt'. simpl in cnt'.
    destruct (unlift (ordinal_pos_incr (OrdinalPool.num_threads tp))
                     (Ordinal (n:=(OrdinalPool.num_threads tp).+1)
                              (m:=OrdinalPool.num_threads tp) cnt')) eqn:H.
    apply unlift_m_inv in H.
    destruct o. simpl in *.
    subst. exfalso;
      ssromega.
    rewrite H.
      by reflexivity.
  Qed.
  Opaque OrdinalPool.containsThread.

  Lemma csafe_internal_step:
    forall tp tr m i (cnti: containsThread tp i) U n
      (Hn: n > 0)
      (Hcmpt: mem_compatible tp m),
      let mrestr := restrPermMap ((compat_th _ _ Hcmpt cnti).1) in
      forall (Hinternal: cnti$mrestr @ I)
        (Hsafe: csafe ((i :: U),tr,tp) m n),
    exists tp' tr' m', cmachine_step ((i :: U), tr, tp) m
                            ((i :: U), tr ++ tr', tp') m'.
  Proof.
    intros.
    inversion Hsafe; simpl in *.
    - subst; by exfalso.
    - subst; by exfalso.
    - do 3 eexists; eauto.
    - inversion Hstep; progress subst;
      simpl in *;
      try match goal with
          | [H: ?X :: ?Y = ?Y |- _] =>
            exfalso; eapply list_cons_irrefl; eauto
          end;
      subst; (try by exfalso);
      unfold getStepType in Hinternal; inversion HschedN; subst.
      inversion Htstep; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hinternal.
      simpl in Hinternal.
      inversion Hperm; subst.
      unfold mrestr in Hinternal.
      rewrite Hat_external in Hinternal;
        by discriminate.
      inversion Htstep;
      Tactics.pf_cleanup;
      rewrite Hcode in Hinternal;
      simpl in Hinternal;
        by discriminate.
      exfalso;
        now eauto.
  Qed.

  Lemma sim_internal : sim_internal_def.
  Proof.
    unfold sim_internal_def.
    intros.
    inversion Hsim as
        [HnumThreads HmemCompC HmemCompF HsafeC
                     HsimWeak Hfpsep HsimStrong HsimRes HunmappedRes
                     HinvF HmaxF Hmemc_wd Htpc_wd Hge_wd Hge_spec Hxs HtraceSim].
    assert (pfc: containsThread tpc i)
      by (eapply HnumThreads; eauto).
    
    destruct (HsimStrong i pfc pff)
      as (tpc' &  mc' & Hincr & Hsynced & Hexec & Htsim &
          Hownedi & Hownedi_lp & Hunmapped);
      clear HsimStrong.
    assert (pfc': containsThread tpc' i)
      by (clear - Hexec pfc;
           eapply containsThread_internal_execution in pfc; eauto).
    specialize (Htsim pfc').
    assert (HmemCompF = mem_compf Hsim)
      by (eapply proof_irr).
    subst.
    
    assert (memCompC' := internal_execution_compatible HmemCompC Hexec).
    specialize (Htsim memCompC').
    assert (Hdomainf: domain_memren f mc)
      by (destruct (HsimWeak _ pfc pff) as [HsimWeak' _];
          eapply weak_obs_eq_domain_ren in HsimWeak'; eauto).
    assert (Hwd := internal_execution_wd _ _ Hdomainf Hmemc_wd Htpc_wd
                                         Hge_wd(ren_incr_domain_incr
                                                  (Hge_spec).1) Hexec).
    destruct Hwd as [Hwd_mem' [[f' [Hincrf' Hdomainf']] Htp_wd']].
    assert (Hinternal_pfc': pfc' $ (restrPermMap ((compat_th _ _ memCompC') pfc')#1) @ I).
    { assert(Hmemc_wd': valid_mem (restrPermMap ((compat_th _ _ memCompC') pfc')#1))
        by (erewrite <- restrPermMap_mem_valid; now eauto).
      assert (Hincr_ge': ren_incr fg (fp i pfc))
        by (eapply ren_incr_trans; eauto; now destruct Hge_spec).
      erewrite (stepType_inj pff pfc' Internal Hge_spec.2 Hincr_ge' Hge_wd
                             Hmemc_wd' (obs_eq_data Htsim) (code_eq Htsim)).
      assumption.
    }
    
    specialize (HsafeC ([:: i]) trc).
    assert (HcoreN := safety_det_corestepN_internal xs HsafeC Hexec).
    destruct HcoreN as [trc' [HcorestepN Hsafety]].
    destruct (@csafe_internal_step _ _ _ _ pfc' _ (fuelF.+2 + size [seq x <- xs | x != i])
                                   ltac:(ssromega) memCompC' Hinternal_pfc' Hsafety) as
        (tpc'' & trc'' & mc'' & Hstep').
    assert (HinvC: invariant tpc)
      by (eapply cmachine_step_invariant; eauto).
    eapply at_internal_cmachine_step with (cnt := pfc') in Hstep'; eauto.
    destruct Hstep' as [Hstep' _].
    assert (Hge_incr': ren_incr fg (fp i pfc))
      by (destruct Hge_spec; eapply ren_incr_trans; eauto).
    
    destruct (tsim_fstep_safe trf HmaxF HinvF Hge_wd (snd Hge_spec)
                              Hge_incr' Htsim Hwd_mem' Hstep')
      as (tpf' & mf' & fi' & tr' & HstepF & HmaxF' & Hincr' & Hsepi & Htsim'
          & Howned' & Hownedlp').
    assert (HstepF_empty := HstepF [::]).
    assert (pfc'': containsThread tpc'' i)
      by (eapply containsThread_internal_step; eauto).
    assert (pff': containsThread tpf' i).
    { eapply (@StepLemmas.step_containsThread _  HybridFineMachine.scheduler
                                              FineDilMem _ _ _ _ _ _ _ _ _  pff); eauto.
      unfold fmachine_step in *. simpl in HstepF_empty.
      now eapply HstepF_empty.
    }
    assert (memCompC'': mem_compatible tpc'' mc'').
    eapply internal_step_compatible with (Hcompatible := memCompC'); eauto.
    assert (memCompF': mem_compatible tpf' mf')
      by (eapply fmachine_step_compatible with (pf := pff); eauto).
    exists tpf', mf', (updateFP pfc fp fi'), tr'.
    split.
    
    assumption.
    
    clear HsafeC HcorestepN.
    eapply Build_sim with (mem_compc := HmemCompC) (mem_compf := memCompF').
    - unfold fmachine_step in HstepF_empty. simpl in HstepF_empty.
      intros k;
      split;
      intro pfk;
      [apply HnumThreads in pfk | apply HnumThreads]; eauto.
      eapply (@StepLemmas.step_containsThread _  HybridFineMachine.scheduler
                                              FineDilMem _ _ _ _ _ _ _ _ _ pfk);
        now eauto.
      eapply fstep_containsThread';
        now eauto.
    - intros.
      simpl.
      rewrite <- addSnnS.
      apply (safeCoarse Hsim).
    - 
      intros j pfcj pffj'.
      assert (pffj: containsThread tpf j)
        by (eapply fstep_containsThread';
            now eauto).
      eapply weak_tsim_fstep with (pffi := pff); eauto.
    - 
      
      intros k j cntk cntj Hkj.
      
      destruct (i == k) eqn:Hik;
        move/eqP:Hik=>Hik;
        try subst k;
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
      + by exfalso.
      + Tactics.pf_cleanup.
        rewrite gssFP. rewrite gsoFP; auto.
        intros b b' b2 b2' Hf Hf' Hfi' Hfj.
        destruct (fp i pfc b) as [b2''|] eqn:Hfi.
        assert (Heq:b2 = b2'')
          by (apply Hincr' in Hfi; rewrite Hfi in Hfi';
                by inversion Hfi'); subst b2''.
        eapply Hfpsep with (i := i) (j := j) (b := b); eauto.
        unfold ren_separated in Hsepi.
        specialize (Hsepi _ _ Hfi Hfi').
        destruct Hsepi as [HinvalidC' HinvalidF'].
        assert (pfj: containsThread tpf j)
          by (eapply HnumThreads; eauto).
        assert (Hsimj := (simStrong Hsim) j cntj pfj).
        destruct Hsimj as [tpcj' [mc'j [_ [_ [Hexecj [Htsimj _]]]]]].
        assert (pfj': containsThread tpcj' j)
          by (eapply containsThread_internal_execution; eauto).
        assert (HmemCompCj': mem_compatible tpcj' mc'j)
          by (eapply internal_execution_compatible with (tp := tpc); eauto).
        specialize (Htsimj pfj' HmemCompCj').
        assert (Hcodomain := codomain_valid (weak_obs_eq (obs_eq_data Htsimj))).
        specialize (Hcodomain _ _ Hfj).
        erewrite restrPermMap_valid in Hcodomain.
        intros Hcontra. subst.
          by auto.
      + Tactics.pf_cleanup.
        rewrite gssFP.
        rewrite gsoFP; auto.
        intros b b' b2 b2' Hf Hf' Hfk' Hfj'.
        destruct (fp j pfc b') as [b2''|] eqn:Hfj.
        assert (Heq:b2' = b2'')
          by (apply Hincr' in Hfj; rewrite Hfj in Hfj';
                by inversion Hfj'); subst b2''.
        intros Hcontra.
        eapply Hfpsep with (i := j) (j := k) (b := b') (b' := b) (b2 := b2');
          by eauto.
        unfold ren_separated in Hsepi.
        specialize (Hsepi _ _ Hfj Hfj').
        destruct Hsepi as [HinvalidC' HinvalidF'].
        assert (pffk: containsThread tpf k)
          by (by eapply HnumThreads).
        assert (Hsimk := (simStrong Hsim) k cntk pffk).
        destruct Hsimk as [tpck' [mck' [_ [_ [Hexeck [Htsimk _]]]]]].
        assert (pfck': containsThread tpck' k)
          by (eapply containsThread_internal_execution; eauto).
        assert (HmemCompCk': mem_compatible tpck' mck')
          by (eapply internal_execution_compatible with (tp := tpc); eauto).
        specialize (Htsimk pfck' HmemCompCk').
        assert (Hcodomain := codomain_valid (weak_obs_eq (obs_eq_data Htsimk))).
        specialize (Hcodomain _ _ Hfk').
        erewrite restrPermMap_valid in Hcodomain.
        intros Hcontra. subst. by auto.
      + rewrite gsoFP; auto.
        rewrite gsoFP; eauto.
    - 
      intros j pfcj pffj'.
      destruct (i == j) eqn:Heq; move/eqP:Heq=>Heq.
      { subst j. exists tpc'', mc''.
        Tactics.pf_cleanup. rewrite gssFP.
        split;
          first by (eapply ren_incr_trans; eauto).
        split.
        intros Hnostep.
        simpl in Hnostep.
        erewrite if_true in Hnostep by (apply eq_refl);
          by discriminate.
        split.
        simpl. erewrite if_true by (apply eq_refl).
        assert (Heq: i :: [seq x <- xs | x == i] =
                     [seq x <- xs | x == i] ++ [:: i]).
        { clear. induction xs. reflexivity.
          simpl. destruct (a==i) eqn:Heq; move/eqP:Heq=>Heq.
          subst. simpl. rewrite IHxs. reflexivity.
          auto.
        }
        rewrite Heq.
        eapply internal_execution_trans;
          by eauto.
        split;
          first by (intros; eapply Htsim').
        split.
        
        intros k pffk' Hik b1 b2 ofs Hfi' Hf.
        assert (pffk: containsThread tpf k)
          by (eapply fstep_containsThread';
              now eauto).
        erewrite <- @StepLemmas.gsoThreadR_step with (Sch:= HybridFineMachine.scheduler)
                                                    (DilMem := FineDilMem) (pfj := pffk)
          by (eauto; unfold fmachine_step in HstepF_empty; simpl in HstepF_empty;
              eapply HstepF_empty).
        destruct (valid_block_dec mc' b1) as [Hvalidmc'b1 | Hinvalidmc'b1].
        
        assert (Hfb1 := (domain_valid (weak_obs_eq (obs_eq_data Htsim))) b1).
        erewrite restrPermMap_valid in Hfb1.
        destruct (Hfb1 Hvalidmc'b1) as [b2' Hfi].
        assert (b2' = b2)
          by (apply Hincr' in Hfi; rewrite Hfi in Hfi';
              inversion Hfi'; by subst); subst;
          by eauto.
        
        assert (Hfb1 := (domain_invalid
                           (weak_obs_eq (obs_eq_data Htsim))) b1).
        erewrite restrPermMap_valid in Hfb1.
        specialize (Hfb1 Hinvalidmc'b1);
          by eauto.
        split.
        
        intros bl ofsl rmap b1 b2 ofs Hfi' Hf Hres.
        erewrite gsoLockRes_fstepI with (tp := tpf) in Hres; eauto.
        destruct (valid_block_dec mc' b1) as [Hvalidmc'b1 | Hinvalidmc'b1].
        assert (Hfb1 := (domain_valid (weak_obs_eq (obs_eq_data Htsim))) b1).
        erewrite restrPermMap_valid in Hfb1.
        destruct (Hfb1 Hvalidmc'b1) as [b2' Hfi].
        assert (b2' = b2)
          by (apply Hincr' in Hfi; rewrite Hfi in Hfi';
              inversion Hfi'; by subst); subst;
          by eauto.
        assert (Hfb1 := (domain_invalid
                           (weak_obs_eq (obs_eq_data Htsim))) b1).
        erewrite restrPermMap_valid in Hfb1.
        specialize (Hfb1 Hinvalidmc'b1);
          by eauto.
        
        intros b2 Hfi' ofs.
        destruct (Htsim' pfc'' pff' memCompC'' memCompF') as [_ Hunmapped'].
        specialize (Hunmapped' b2 Hfi' ofs).
        erewrite Hunmapped'.1, Hunmapped'.2.
        eapply Hunmapped.
        intros (b1 & Hf).
        apply Hincr' in Hf.
        eapply Hfi'; by eexists; eauto.
      }
      { 
        simpl.
        rewrite gsoFP; auto.
        erewrite if_false by (apply/eqP; intros Hcontra; auto).
        clear HsimWeak Htsim Hincr Hincr'.
        assert (HsimStrong := simStrong Hsim).
        assert (pffj: containsThread tpf j)
          by (eapply (fstep_containsThread' pff pffj'); now eauto).
        destruct (HsimStrong j pfcj pffj)
          as (tpcj' & mcj' & Hincrj & Hsyncedj & Hexecj & Htsimj & Hownedj
              & Hownedj_lp & Hunmappedj).
        exists tpcj', mcj'. split; auto. split; [ by auto | split; auto].
        split.
        
        intros pfcj' memCompCj'.
        specialize (Htsimj pfcj' memCompCj').
        inversion Htsimj as [code_eqjj memObsEqj memObsEqj_locks].
        constructor;
          first by (erewrite <- gsoThreadC_fstepI
                    with (pfj' := pffj') (pfj := pffj); by eauto).
        { 
          constructor. 
          { constructor.
            - apply (domain_invalid (weak_obs_eq memObsEqj)).
            - apply (domain_valid (weak_obs_eq memObsEqj)).
            - assert (Hcodomain := (codomain_valid (weak_obs_eq memObsEqj))).
              intros b1 b2 Hfj.
              specialize (Hcodomain b1 b2 Hfj).
              erewrite restrPermMap_valid.
              erewrite restrPermMap_valid in Hcodomain.
              eapply fstep_valid_block;
                by eauto.
            - by apply (injective (weak_obs_eq (obs_eq_data Htsimj))).
            - intros b1 b2 ofs.
              pose proof (StepLemmas.permission_at_step Heq pffj pffj' (mem_compf Hsim)
                                                        memCompF' HstepF_empty b2 ofs) as Hperm_eq.
              rewrite <- Hperm_eq.
                now apply (perm_obs_weak (weak_obs_eq memObsEqj)).
          }
          constructor. 
          { intros b1 b2 ofs.
            pose proof (StepLemmas.permission_at_step Heq pffj pffj' (mem_compf Hsim)
                                                      memCompF' HstepF_empty b2 ofs) as Hperm_eq.
            rewrite <- Hperm_eq.
              now apply (perm_obs_strong (strong_obs_eq memObsEqj)).
          }
          { intros b1 b2 ofs Hfj Hperm. unfold restrPermMap. simpl.
            assert (Hval := val_obs_eq (strong_obs_eq memObsEqj)).
            specialize (Hval b1 b2 ofs Hfj Hperm).
            unfold restrPermMap in Hval. simpl in Hval.
            assert (Hpermf: Mem.perm (restrPermMap (fst (compat_th _ _ (mem_compf Hsim) pffj)))
                                     b2 ofs Cur Readable).
            { specialize (HstepF [::]).
              assert (Hperm_eqf :=
                        StepLemmas.permission_at_step Heq pffj pffj' (mem_compf Hsim) memCompF'
                                            HstepF b2 ofs).
              unfold permission_at in Hperm_eqf.
              assert (Hperm_weak := (perm_obs_weak (weak_obs_eq memObsEqj) b1
                                                   ofs Hfj)).
              assert (Hperm_strong := (perm_obs_strong (strong_obs_eq memObsEqj))
                                        b1 b2 ofs Hfj).
              clear - Hperm Hperm_eqf Hperm_strong Hperm_weak.
              unfold permission_at in *.
              unfold Mem.perm. rewrite Hperm_strong.
                by auto.
            }
            specialize (HstepF [::]).
            erewrite <- @fmachine_step_disjoint_val with
            (tp := tpf) (i := i) (j := j) (m' := mf')
                        (m := mf) (tp' := tpf') (U := [::]);
              by eauto.
          }
        }
        { 
          constructor. 
          { constructor.
            - apply (domain_invalid (weak_obs_eq memObsEqj)).
            - apply (domain_valid (weak_obs_eq memObsEqj)).
            - assert (Hcodomain := (codomain_valid (weak_obs_eq memObsEqj))).
              intros b1 b2 Hfj.
              specialize (Hcodomain b1 b2 Hfj).
              erewrite restrPermMap_valid.
              erewrite restrPermMap_valid in Hcodomain.
              eapply fstep_valid_block;
                by eauto.
            - by apply (injective (weak_obs_eq (obs_eq_locks Htsimj))).
            - intros b1 b2 ofs.
              rewrite !restrPermMap_Cur.
              erewrite <- @StepLemmas.gsoThreadR_step with (Sch := HybridFineMachine.scheduler)
                                                          (DilMem := FineDilMem)
                                                          (pfj := pffj) (pfj' := pffj');
                eauto.
              rewrite <- restrPermMap_Cur with (Hlt := snd (compat_th _ _ memCompCj' pfcj')).
              rewrite <- restrPermMap_Cur with (Hlt := snd (compat_th _ _ (mem_compf Hsim) pffj)).
              now apply (perm_obs_weak (weak_obs_eq memObsEqj_locks)).
              now eapply HstepF_empty.
          }
          constructor. 
          { intros b1 b2 ofs.
            rewrite !restrPermMap_Cur.
            erewrite <- @StepLemmas.gsoThreadR_step with (Sch := HybridFineMachine.scheduler)
                                                        (DilMem := FineDilMem)
                                                        (pfj := pffj) (pfj' := pffj');
              eauto.
            rewrite <- restrPermMap_Cur with (Hlt := snd (compat_th _ _ memCompCj' pfcj')).
            rewrite <- restrPermMap_Cur with (Hlt := snd (compat_th _ _ (mem_compf Hsim) pffj)).
            now apply (perm_obs_strong (strong_obs_eq memObsEqj_locks)).
            now eapply HstepF_empty.
          }
          { intros b1 b2 ofs Hfj Hperm. unfold restrPermMap. simpl.
            assert (Hval := val_obs_eq (strong_obs_eq memObsEqj_locks)).
            specialize (Hval b1 b2 ofs Hfj Hperm).
            unfold restrPermMap in Hval. simpl in Hval.
            assert (Hpermf: Mem.perm (restrPermMap (snd (compat_th _ _ (mem_compf Hsim) pffj)))
                                     b2 ofs Cur Readable).
            { specialize (HstepF [::]).
              assert (Hperm_eqf :=
                        StepLemmas.permission_at_step Heq pffj pffj' (mem_compf Hsim) memCompF'
                                            HstepF b2 ofs).
              unfold permission_at in Hperm_eqf.
              assert (Hperm_weak := (perm_obs_weak (weak_obs_eq memObsEqj_locks) b1
                                                   ofs Hfj)).
              assert (Hperm_strong := (perm_obs_strong (strong_obs_eq memObsEqj_locks))
                                        b1 b2 ofs Hfj).
              clear - Hperm Hperm_eqf Hperm_strong Hperm_weak.
              unfold permission_at in *.
              unfold Mem.perm. rewrite Hperm_strong.
                by auto.
            }
            specialize (HstepF [::]).
            erewrite <- @fmachine_step_disjoint_val with
            (tp := tpf) (i := i) (j := j) (m' := mf')
                        (m := mf) (tp' := tpf') (U := [::]);
              by eauto.
          }
        }
        split.
        
        intros k pffk' Hjk b1 b2 ofs Hfj Hf.
        assert (pffk: containsThread tpf k)
          by (eapply fstep_containsThread'; eauto).
        specialize (Hownedj _ pffk Hjk b1 b2 ofs Hfj Hf).
        destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
        
        subst k.
        assert (pfcj': containsThread tpcj' j)
          by (eapply containsThread_internal_execution; eauto).
        assert (Hcompcj': mem_compatible tpcj' mcj')
          by (eapply internal_execution_compatible with (tp := tpc) (m := mc);
               eauto).
        specialize (Htsimj pfcj' Hcompcj').
        assert (Hcodomain := (codomain_valid (weak_obs_eq
                                                (obs_eq_data Htsimj)))). {
        specialize (Hcodomain _ _ Hfj).
        erewrite restrPermMap_valid in Hcodomain.
        clear - Hownedj Hcodomain Hjk HstepF_empty Hinternal semAxioms.
        absurd_internal HstepF_empty;
          try by erewrite OrdinalPool.gThreadCR with (cntj := pff).
        
        inversion Hperm; subst.
        apply initial_core_decay in Hinitial.
        destruct (Hinitial b2 ofs) as [_ Hdecay_valid].
        assert (Hp := restrPermMap_Cur (fst (compat_th _ _ (mem_compf Hsim) pff)) b2 ofs).
        unfold permission_at in Hp.
        specialize (Hdecay_valid Hcodomain).
        specialize (Hdecay_valid Cur).
        rewrite Hp in Hdecay_valid.
        destruct Hownedj as [Hownedj1 Hownedj2].
        rewrite Hownedj1 in Hdecay_valid.
        erewrite OrdinalPool.gssThreadRes.
        rewrite getCurPerm_correct;
          by auto.
        
        apply ev_step_ax1 in Hcorestep.
        apply corestep_decay in Hcorestep.
        destruct (Hcorestep b2 ofs) as [_ Hdecay_valid].
        assert (Hp := restrPermMap_Cur (fst (compat_th _ _ (mem_compf Hsim) pff)) b2 ofs).
        unfold permission_at in Hp.
        destruct (Hdecay_valid Hcodomain) as [Hnew | Hstable].
        destruct (Hnew Cur) as [Hcontra _].
        rewrite Hp in Hcontra.
        destruct Hownedj; simpl in *;
          by congruence.
        specialize (Hstable Cur).
        rewrite Hp in Hstable.
        destruct Hownedj as [Hownedj1 Hownedj2].
        rewrite Hownedj1 in Hstable.
        erewrite OrdinalPool.gssThreadRes.
        rewrite getCurPerm_correct;
          by auto.
        }
        
        replace (OrdinalPool.getThreadR pffk') with (getThreadR pffk') by reflexivity.
        erewrite <- @StepLemmas.gsoThreadR_step with (Sch := HybridFineMachine.scheduler)
                                                   (DilMem := FineDilMem)
                                                   (pfj := pffk);
          eauto.
        now eapply HstepF_empty.
        split.
        
        intros bl ofsl rmap b1 b2 ofs Hfj Hf Hres.
        replace (OrdinalPool.lockRes) with lockRes in Hres by reflexivity.
        erewrite gsoLockRes_fstepI with (tp := tpf) in Hres;
          by eauto.
        
        intros b2 Hfj ofs.
        specialize (Hunmappedj _ Hfj ofs).
        replace (OrdinalPool.getThreadR pffj') with (getThreadR pffj') by reflexivity.
        erewrite <- @StepLemmas.gsoThreadR_step with  (Sch := HybridFineMachine.scheduler)
                                          (DilMem := FineDilMem)
                                          (pfj := pffj); eauto.
        now apply HstepF_empty.
      }
    - 
        destruct HsimRes as [HsimRes [Hlock_mapped Hlock_if]].
        split.
        + intros.
          assert (Hl_eq := gsoLockRes_fstepI pff (mem_compf Hsim) Hinternal HstepF_empty).
          assert (Hl2': lockRes tpf (bl2, ofs) = Some rmap2)
            by (rewrite <- Hl_eq; assumption).
          destruct (HsimRes _ _ _ _ _ Hf Hl1 Hl2') as [HsimRes1 HsimRes2].
          split.
          * destruct HsimRes1 as [HpermRes1 HvalRes1].
            constructor.
            intros b1 b2 ofs0 Hf1.
            do 2 rewrite restrPermMap_Cur.
            specialize (HpermRes1 _ _ ofs0 Hf1);
              by do 2 rewrite restrPermMap_Cur in HpermRes1.
            intros b1 b2 ofs0 Hf1 Hperm.
            simpl in *.
            specialize (HvalRes1 _ _ ofs0 Hf1 Hperm).
            assert (HpermF: Mem.perm (restrPermMap (fst (compat_lp _ _ (mem_compf Hsim)
                                                                   (bl2,ofs) _ Hl2')))
                                     b2 ofs0 Cur Readable).
            { unfold Mem.perm in *.
              specialize (HpermRes1 _ _ ofs0 Hf1).
              unfold permission_at in HpermRes1.
                by rewrite HpermRes1.
            }
            absurd_internal HstepF_empty; auto.
            
            inversion Hperm0; subst.
            assert (Hcmpt = mem_compf Hsim)
              by (eapply proof_irr); subst.
            erewrite <- @CoreLanguageDry.initial_core_disjoint_val_lockpool with (m := mf) (m' := m');
              simpl; eauto. eapply Hinitial.
            
            apply ev_step_ax1 in Hcorestep.
            assert (Hcmpt = mem_compf Hsim)
              by (eapply proof_irr).
            subst.
            erewrite <- @CoreLanguageDry.corestep_disjoint_val_lockpool with (m := mf) (m' := m');
              simpl; now eauto.
          * destruct HsimRes2 as [HpermRes2 HvalRes2].
            constructor.
            intros b1 b2 ofs0 Hf1.
            do 2 rewrite restrPermMap_Cur.
            specialize (HpermRes2 _ _ ofs0 Hf1);
              by do 2 rewrite restrPermMap_Cur in HpermRes2.
            intros b1 b2 ofs0 Hf1 Hperm.
            simpl in *.
            specialize (HvalRes2 _ _ ofs0 Hf1 Hperm).
            assert (HpermF: Mem.perm (restrPermMap (snd (compat_lp _ _ (mem_compf Hsim)
                                                                   (bl2,ofs) _ Hl2')))
                                     b2 ofs0 Cur Readable).
            { unfold Mem.perm in *.
              specialize (HpermRes2 _ _ ofs0 Hf1).
              unfold permission_at in HpermRes2.
                by rewrite HpermRes2.
            }
            absurd_internal HstepF_empty; auto.
            
            inversion Hperm0; subst.
            assert (Hcmpt = mem_compf Hsim)
              by (eapply proof_irr); subst.
            erewrite <- @CoreLanguageDry.initial_core_disjoint_val_lockpool with (m := mf) (m' := m');
              simpl; eauto. eapply Hinitial.
            
            apply ev_step_ax1 in Hcorestep.
            assert (Hcmpt = mem_compf Hsim)
              by (eapply proof_irr).
            subst.
            erewrite <- @CoreLanguageDry.corestep_disjoint_val_lockpool with (m := mf) (m' := m');
              simpl; now eauto.
        +  split.
           intros bl2 ofs Hres.
           erewrite gsoLockRes_fstepI with (tp := tpf) (tp' := tpf') in Hres; eauto.
           intros bl1 bl2 ofs Hf.
           erewrite gsoLockRes_fstepI with (tp' := tpf');
             now eauto.
    - 
      intros bl ofsl rmap Hres b2 Hf ofs.
      erewrite gsoLockRes_fstepI with (tp := tpf) in Hres by eauto.
      eapply HunmappedRes;
        now eauto.
    - 
      eapply fmachine_step_invariant with (tp := tpf);
        now eauto.
    - assumption.
    - assumption.
    - assumption.
    - assumption.
    - assumption.
    - intros j Hin.
      inversion Hin; subst;
        now auto.
    - assumption.
      Unshelve. all:eauto.     
  Qed.

  Opaque containsThread getThreadC getThreadR.
  
  Lemma suspend_step_inverse:
    forall i U U' tpc trc tpc' trc' mc mc'
      (cnt: containsThread tpc i)
      (Hcompc: mem_compatible tpc mc),
      let mrestr := restrPermMap (((compat_th _ _ Hcompc) cnt).1) in
      forall (Hsuspend: cnt$mrestr @ S)
        (Hstep: cmachine_step (i :: U, trc, tpc) mc (U', trc', tpc') mc'),
        U = U' /\ mc = mc' /\ trc = trc' /\ mem_compatible tpc mc /\
        suspend_thread mc cnt tpc'.
  Proof.
    intros.
    inversion Hstep; simpl in *; subst; inversion HschedN; subst;
      try (inversion Htstep || inversion Hhalted); subst; Tactics.pf_cleanup;
    unfold getStepType in Hsuspend;
    try rewrite Hcode in Hsuspend; simpl in Hsuspend;
    try match goal with
        | [H: match ?Expr with _ => _ end = _, H2: ?Expr = _ |- _] =>
          rewrite H2 in H
        end; try discriminate;
    try match goal with
        | [H: ~ containsThread _ _, H2: containsThread _ _ |- _] =>
          exfalso; by auto
        | [H: halted _ _ _  |- _] =>
          destruct (at_external_halted_excl c mrestr) as [Hnot_ext | Hcontra];
            [rewrite Hnot_ext in Hsuspend;
             destruct Hsuspend as [[_ ?] | [? _]]; discriminate |
             exfalso; eapply Hcontra; now eauto]
        end.
    apply ev_step_ax1 in Hcorestep.
    eapply corestep_not_at_external in Hcorestep.
    rewrite Hcorestep in Hsuspend.
    discriminate.
    inversion Hperm; subst.
    repeat (split; eauto).
  Qed.

  Lemma mem_obs_eq_step:
    forall tp1 tp2 tp1' m1 m2 m1' j f fg
      (pf1j: containsThread tp1 j)
      (pf1j': containsThread tp1' j)
      (Hcomp1: mem_compatible tp1 m1)
      (Hcomp1': mem_compatible tp1' m1')
      (Hinv: invariant tp1')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_incr fg f)
      (Hvalid_mem: valid_mem m1)
      (Hcode_eq: ctl_inj f (getThreadC pf1j) (getThreadC pf1j'))
      (Hmem_obs_eq: mem_obs_eq f (restrPermMap (compat_th _ _ Hcomp1 pf1j).1)
                               (restrPermMap (compat_th _ _ Hcomp1' pf1j').1))
      (Hstep: internal_step pf1j Hcomp1 tp2 m2),
    exists tp2' m2' f',
      internal_step pf1j' Hcomp1' tp2' m2' /\
      ren_incr f f' /\
      ren_separated f f' m1 m1' /\
      ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
              (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive))
       \/ ((Mem.nextblock m2 = Mem.nextblock m1) /\
          (Mem.nextblock m2' = Mem.nextblock m1'))) /\
      (forall b,
          Mem.valid_block m2' b ->
          ~ Mem.valid_block m1' b ->
          let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                 (Zpos (Mem.nextblock m1))))%Z in
          f' (Z.to_pos bz) = Some b /\
          f (Z.to_pos bz) = None) /\
      (exists (pf2j: containsThread tp2 j)
         (pf2j': containsThread tp2' j)
         (Hcomp2: mem_compatible tp2 m2)
         (Hcomp2': mem_compatible tp2' m2'),
          ctl_inj f' (getThreadC pf2j) (getThreadC pf2j') /\
          mem_obs_eq f' (restrPermMap (compat_th _ _ Hcomp2 pf2j).1)
                     (restrPermMap (compat_th _ _ Hcomp2' pf2j').1)) /\
      (Mem.nextblock m1 = Mem.nextblock m1' ->
       (forall b1 b2 : block, f b1 = Some b2 -> b1 = b2) ->
       forall b1 b2 : block, f' b1 = Some b2 -> b1 = b2).
  Proof.
    intros.
    inversion Hstep as [[? Hcstep] | [[Hresume ?] | Hstart]].
    - inversion Hcstep; subst.
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [c1' | | |] eqn:Hcodej'; try by exfalso.
      apply ev_step_ax1 in Hcorestep.
      assert (H := corestep_obs_eq _ _ _ _ Hmem_obs_eq Hcode_eq Hfg Hge_wd
                                   Hge_incr Hcorestep).
      destruct H
        as (c2' & m2' & f' & Hcorestep' & Hcode_eq'
            & Hobs_eq & Hincr & Hseparated
            & Hnextblock & Hinverse & Hid & Hunmapped).
      exists (updThread pf1j' (Krun c2') (getCurPerm m2', (getThreadR pf1j').2)), m2', f'.
      eapply ev_step_ax2 in Hcorestep'.
      destruct Hcorestep' as [evF Hcorestep'].
      assert (Hinternal':
                internal_step pf1j' Hcomp1'
                              (updThread pf1j' (Krun c2') (getCurPerm m2', (getThreadR pf1j').2)) m2')
        by (left; eexists; econstructor; eauto).
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split.
      { assert (pf2j := containsThread_internal_step Hstep pf1j).
        assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
        assert (Hcomp2 := internal_step_compatible Hstep).
        assert (Hcomp2' := internal_step_compatible Hinternal').
        exists pf2j, pf2j', Hcomp2, Hcomp2'.
        constructor; first by do 2 rewrite gssThreadCode.
        destruct Hobs_eq as [[Hinvalid' Hvalid' ? ? Hweak_perm] [Hstrong_perm Hval]].
        constructor.
        + 
          constructor.
          * intros b Hinvalid;
              erewrite restrPermMap_valid in Hinvalid;
                by eauto.
          * intros b Hvalid;
              erewrite restrPermMap_valid in Hvalid;
                by eauto.
          * eauto.
          * eauto.
          * intros b1 b2 ofs Hf';
              do 2 rewrite restrPermMap_Cur;
              do 2 rewrite gssThreadRes;
              do 2 rewrite getCurPerm_correct;
                by eauto.
        +
          constructor.
          * intros b1 b2 ofs Hf'.
            do 2 rewrite restrPermMap_Cur;
              do 2 rewrite gssThreadRes;
              do 2 rewrite getCurPerm_correct;
                by eauto.
          * 
            intros b1 b2 ofs Hf' Hreadable.
            simpl.
            eapply Hval; eauto.
            unfold Mem.perm in *.
            assert (H:= restrPermMap_Cur (fst (compat_th _ _ Hcomp2 pf2j)) b1 ofs).
            unfold permission_at in H.
            rewrite H in Hreadable.
            rewrite gssThreadRes in Hreadable;
              rewrite getCurPerm_correct in Hreadable.
              by assumption.
      }
      do 2 erewrite restrPermMap_nextblock in Hid;
        by eauto.
    - {
      subst m2.
      inversion Hresume; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [ | |c1'|] eqn:Hcode'; try by exfalso.
      destruct Hcode_eq as [Hcode_eq Hval_eq].
      inversion Hval_eq; subst.
      inversion Hperm; subst.
      assert (Hvalid_mem': valid_mem (restrPermMap (compat_th _ _ Hcomp1 pf1j)#1))
        by (erewrite <- restrPermMap_mem_valid; eauto).
      assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr Hvalid_mem'
                                                Hcode_eq Hmem_obs_eq).
      rewrite Hat_external in Hat_external_spec.
      destruct X as [ef vs].
      destruct (at_external semSem c1' (restrPermMap (compat_th _ _ Hcomp1' pf1j')#1))
        as [[? ?] | ] eqn:Hat_external';
        try by exfalso.
      destruct Hat_external_spec as [? ?]; subst.
      assert (Hvalid_val: match (Some (Vint Int.zero)) with
                          | Some v1 => valid_val f v1
                          | None => True
                          end)
        by (now simpl).
      assert (Hafter_external' :=
                core_inj_after_ext _ _ None Hfg Hge_wd Hge_incr
                                   Hcode_eq Hmem_obs_eq Hvalid_val Hafter_external).
      destruct Hafter_external' as [ov2 [c2' [Hafter_external'
                                                [Hcore_inj' Hval_obs]]]].
      destruct ov2 as [? |]; try by exfalso.
      inversion Hval_obs; subst.
      exists (updThreadC pf1j' (Krun c2')), m1', f.
      assert (Hinternal':
                internal_step pf1j' Hcomp1' (updThreadC pf1j' (Krun c2')) m1'). {
          clear - Hat_external' Hafter_external' Hcode' Hinv.
          right; left; split; econstructor; eauto.
          simpl; unfold DryHybridMachine.install_perm.
          reflexivity.
     }
      { split;
          first by assumption.
        split; first by auto.
        split; first by congruence.
        split; first by auto.
        split; first by
            (intros; by exfalso).
        split; try by eauto.
        assert (pf2j := containsThread_internal_step Hstep pf1j).
        assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
        assert (Hcomp2 := internal_step_compatible Hstep).
        assert (Hcomp2' := internal_step_compatible Hinternal').
        exists pf2j, pf2j', Hcomp2, Hcomp2'.
        constructor; first by do 2 rewrite gssThreadCC.
        
       erewrite restrPermMap_irr' with (Hlt' := fst (compat_th _ _ Hcomp1 pf1j)) by (rewrite gThreadCR; eauto).
       erewrite restrPermMap_irr' with (Hlt' := fst (compat_th _ _ Hcomp1' pf1j')) by (rewrite gThreadCR; eauto);
         by eauto.
      }
      }
    - 
      inversion Hstart; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [| | |vf' arg'] eqn:Hcodej'; try by exfalso.
      destruct Hcode_eq as [Hval_obs Harg_obs].
      inversion Hperm; subst.
      assert (Hargs_obs: val_obs_list f [:: arg] [:: arg'])
             by (econstructor; eauto using val_obs_list).
      assert (H := core_inj_init _ _ _ Hge_wd Hfg Hge_incr Hargs_obs Hval_obs Hmem_obs_eq Hinitial).
      destruct H
        as (c_new' & m2' & f' & Hinitial' & Hcode_eq'
            & Hobs_eq & Hincr & Hseparated
            & Hnextblock & Hinverse & Hid & Hunmapped).
      exists (updThread pf1j' (Krun c_new') (getCurPerm m2', (getThreadR pf1j').2)), m2', f'.
      assert (Hinternal':
                internal_step pf1j' Hcomp1'
                              (updThread pf1j' (Krun c_new') (getCurPerm m2', (getThreadR pf1j').2)) m2').
      { right. right. econstructor; eauto. simpl.
        unfold DryHybridMachine.install_perm. reflexivity.
      }
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split.
      erewrite! restrPermMap_nextblock in Hnextblock.
      left; assumption.
      split; first by assumption.
      split.
      { assert (pf2j := containsThread_internal_step Hstep pf1j).
        assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
        assert (Hcomp2 := internal_step_compatible Hstep).
        assert (Hcomp2' := internal_step_compatible Hinternal').
        exists pf2j, pf2j', Hcomp2, Hcomp2'.
        constructor; first by do 2 rewrite gssThreadCode.
        destruct Hobs_eq as [[Hinvalid' Hvalid' ? ? Hweak_perm] [Hstrong_perm Hval]].
        constructor.
        + 
          constructor.
          * intros b Hinvalid;
              erewrite restrPermMap_valid in Hinvalid;
                by eauto.
          * intros b Hvalid;
              erewrite restrPermMap_valid in Hvalid;
                by eauto.
          * eauto.
          * eauto.
          * intros b1 b2 ofs Hf';
              do 2 rewrite restrPermMap_Cur;
              do 2 rewrite gssThreadRes;
              do 2 rewrite getCurPerm_correct;
                by eauto.
        +
          constructor.
          * intros b1 b2 ofs Hf'.
            do 2 rewrite restrPermMap_Cur;
              do 2 rewrite gssThreadRes;
              do 2 rewrite getCurPerm_correct;
                by eauto.
          * 
            intros b1 b2 ofs Hf' Hreadable.
            simpl.
            eapply Hval; eauto.
            unfold Mem.perm in *.
            assert (H:= restrPermMap_Cur (fst (compat_th _ _ Hcomp2 pf2j)) b1 ofs).
            unfold permission_at in H.
            rewrite H in Hreadable.
            rewrite gssThreadRes in Hreadable;
              rewrite getCurPerm_correct in Hreadable.
              by assumption.
      }
      do 2 erewrite restrPermMap_nextblock in Hid;
        by eauto.
  Qed.

  Lemma mem_obs_eq_execution:
    forall tp1 tp2 tp1' m1 m2 m1' j xs f fg
      (pf1j: containsThread tp1 j)
      (pf1j': containsThread tp1' j)
      (Hcomp1: mem_compatible tp1 m1)
      (Hcomp1': mem_compatible tp1' m1')
      (Hinv: invariant tp1')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_incr fg f)
      (Hvalid_mem: valid_mem m1)
      (Htp_wd: tp_wd f tp1)
      (Hcode_eq: ctl_inj f (getThreadC pf1j) (getThreadC pf1j'))
      (Hmem_obs_eq: mem_obs_eq f (restrPermMap (compat_th _ _ Hcomp1 pf1j).1)
                               (restrPermMap (compat_th _ _ Hcomp1' pf1j').1))
      (Hexec: internal_execution [seq x <- xs | x == j] tp1 m1 tp2 m2),
    exists tp2' m2' f',
      internal_execution [seq x <- xs | x == j] tp1' m1' tp2' m2' /\
      ren_incr f f' /\
      ren_separated f f' m1 m1' /\
      ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
              (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive))
       \/ ((Mem.nextblock m2 = Mem.nextblock m1) /\
          (Mem.nextblock m2' = Mem.nextblock m1'))) /\
      (forall b,
          Mem.valid_block m2' b ->
          ~ Mem.valid_block m1' b ->
          let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                 (Zpos (Mem.nextblock m1))))%Z in
          f' (Z.to_pos bz) = Some b /\
          f (Z.to_pos bz) = None) /\
      (exists (pf2j: containsThread tp2 j)
         (pf2j': containsThread tp2' j)
         (Hcomp2: mem_compatible tp2 m2)
         (Hcomp2': mem_compatible tp2' m2'),
          ctl_inj f' (getThreadC pf2j) (getThreadC pf2j') /\
          mem_obs_eq f' (restrPermMap (compat_th _ _ Hcomp2 pf2j).1)
                     (restrPermMap (compat_th _ _ Hcomp2' pf2j').1)) /\
      (Mem.nextblock m1 = Mem.nextblock m1' ->
       (forall b1 b2 : block, f b1 = Some b2 -> b1 = b2) ->
       forall b1 b2 : block, f' b1 = Some b2 -> b1 = b2).
  Proof.
    intros.
    generalize dependent tp1.
    generalize dependent m1.
    generalize dependent f.
    generalize dependent tp1'. generalize dependent m1'.
    induction xs as [|x xs]; simpl; intros.
    - inversion Hexec; subst.
      + exists tp1', m1', f.
        split; first by constructor.
        split; first by auto.
        split; first by congruence.
        split; first by auto.
        split; first by (intros; by exfalso).
        split; eauto.
        do 4 eexists; split; eauto.
     + simpl in HschedN;
        by inversion HschedN.
    - destruct (x == j) eqn:Hxj; move/eqP:Hxj=>Hxj.
      + subst x. inversion Hexec as [|tid U U' tp1a m1a tp0 m0].
        subst U U' tp1a m1a tp'' m''.
        simpl in Htrans. simpl in HschedN;
                           inversion HschedN; subst tid; clear HschedN Hexec.
        Tactics.pf_cleanup.
        assert (Htsim := mem_obs_eq_step _ _ Hinv Hfg Hge_wd Hge_incr Hvalid_mem Hcode_eq Hmem_obs_eq Hstep).
        destruct Htsim as
            (tp0' & m0' & f0 & Hstep0' & Hincr0' & Hsep0'
             & Hnextblock0' & Hinverse0' & Htsim0' & Hid0').
        destruct Htsim0' as [pfj' [pfj0' [Hcomp' [Hcomp0' [Hcode_eq0 Hmem_obs_eq0]]]]].
        Tactics.pf_cleanup.
        assert (Hinv0': invariant tp0')
          by (eapply internal_step_invariant; eauto).
        assert (Hge_incr0': ren_incr fg f0)
          by (eapply ren_incr_trans; eauto).
        assert (H_wd0: valid_mem m0 /\ tp_wd f0 tp0).
        { pose proof (internal_step_wd Hvalid_mem
                                       ltac:(erewrite restrPermMap_domain;
                                             eapply mem_obs_eq_domain_ren; eauto)
                                              Htp_wd Hge_wd
                                              ltac:(eapply ren_incr_domain_incr; eauto)
                                                     Hstep) as [? [? Htp_wd0]].
          split; [assumption |].
          eapply Htp_wd0;
            eauto.
          erewrite restrPermMap_domain;
            eapply mem_obs_eq_domain_ren;
            now eauto.
        }
        destruct H_wd0 as [Hvalid_mem0 Htp_wd0].
        destruct (IHxs _ _ _ _ Hinv0' _ Hge_incr0' _  Hvalid_mem0 _ _ _ Htp_wd0
                       Hcode_eq0 Hmem_obs_eq0 Htrans)
          as (tp2' & m2' & f2' & Hexec & Hincr2 & Hsep2
              & Hnextblock2 & Hinverse2 & Hsim2 & Hid2);
          exists tp2', m2', f2'.
        destruct Hsim2 as [pf2j [pf2j' [Hcomp2 [Hcomp2' [Hcode_eq2 Hmem_obs_eq2]]]]].
        split; first by (econstructor; simpl; eauto).
        split; first by (eapply ren_incr_trans; eauto).
        split.
        { 
          intros b1 b2 Hf Hf2'.
          unfold ren_separated in *.
          destruct (valid_block_dec m0 b1) as [Hvalidm0 | Hinvalidm0].
          * apply (domain_valid (weak_obs_eq Hmem_obs_eq0)) in Hvalidm0.
            destruct Hvalidm0 as [x Hf0].
            assert (b2 = x).
            {  assert (Hf2'' : f2' b1 = Some x)
                by (eapply Hincr2; eauto).
               rewrite Hf2' in Hf2''. inversion Hf2''; by subst. }
            subst x.
            eapply Hsep0';
              by eauto.
          * apply (domain_invalid (weak_obs_eq Hmem_obs_eq0)) in Hinvalidm0.
            destruct (Hsep2 _ _ Hinvalidm0 Hf2') as [Hinvalid Hinvalidm0'].
            split;
              intros Hcontra;
              eapply internal_step_valid in Hcontra; eauto.
        }
        split.
        { 
          destruct Hnextblock0' as [[p0 [Hnextblock0 Hnextblock0']]
                                   | [Hnextblock0 Hnextblock0']];
            destruct Hnextblock2 as [[p2 [Hnextblock2 Hnextblock2']]
                                    | [Hnextblock2 Hnextblock2']];
            clear - Hnextblock0 Hnextblock0' Hnextblock2 Hnextblock2';
            rewrite Hnextblock2 Hnextblock2';
            rewrite Hnextblock0 Hnextblock0'.
          - left. exists (p0+p2)%positive.
            split; by rewrite Pos.add_assoc.
          - left;
              exists p0; by split.
          - left; exists p2;
              by split.
          - right; by split.
        } split.
        { 
          clear - Hinverse2 Hinverse0' Hincr2 Hincr0' Hnextblock0' Hnextblock2.
          intros b Hvalidm2' Hinvalidm1'.
          destruct (valid_block_dec m0' b) as [Hvalidm0' | Hinvalidm0'].
          - specialize (Hinverse0' _ Hvalidm0' Hinvalidm1').
            simpl in Hinverse0'.
            destruct Hinverse0' as [Hf0 Hf].
            apply Hincr2 in Hf0. by split.
          - specialize (Hinverse2 _ Hvalidm2' Hinvalidm0').
            simpl in Hinverse2.
            destruct Hinverse2 as [Hf2' Hf0].
            
            assert (Heq: ((Z.pos (Mem.nextblock m1') - Z.pos (Mem.nextblock m1)) =
                          Z.pos (Mem.nextblock m0') - Z.pos(Mem.nextblock m0))%Z).
            { clear - Hnextblock0'.
              destruct Hnextblock0' as [[p0 [Hnextblock0 Hnextblock0']]
                                       | [Hnextblock0 Hnextblock0']];
                rewrite Hnextblock0 Hnextblock0';
                [do 2 rewrite Pos2Z.inj_add;
                 rewrite Zminus_plus_simpl_r;
                   by reflexivity | by reflexivity].
            }
            simpl in *.
            rewrite <- Heq in Hf2', Hf0.
            split; first by assumption.
            match goal with
            | [|- ?Expr = None] =>
              destruct Expr as [?|] eqn:Hf
            end;
              [apply Hincr0' in Hf; by congruence | trivial].
        }
        split; first by (do 4 eexists; simpl in *; split; eauto).
        intros Hnb1 Hf.
        specialize (Hid0' Hnb1 Hf).
        assert (Hnb0: Mem.nextblock m0 = Mem.nextblock m0')
          by (destruct Hnextblock0' as [[p [Hnb0 Hnb0']] | [Hnb0 Hnb0']];
                by rewrite Hnb0 Hnb0' Hnb1).
        specialize (Hid2 Hnb0 Hid0').
          by assumption.
    + destruct (IHxs _ _ _ _ Hinv _ Hge_incr _ Hvalid_mem _ _ _ Htp_wd Hcode_eq Hmem_obs_eq Hexec)
        as
          [tp2' [m2' [f2' [Hexec2
                             [Hincr2
                                [Hsep2 [Hnextblock2 [Hinverse2 [Hsim2 Hid2]]]]]]]]];
        exists tp2', m2', f2'.
      repeat (split; auto).
  Qed.

  Lemma strong_tsim_step:
    forall tp1 tp2 tp1' m1 m2 m1' j f fg
      (pf1j: containsThread tp1 j)
      (pf1j': containsThread tp1' j)
      (Hcomp1: mem_compatible tp1 m1)
      (Hcomp1': mem_compatible tp1' m1')
      (Hinv: invariant tp1')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_incr fg f)
      (Hvalid_mem: valid_mem m1)
      (Hsim: strong_tsim f pf1j pf1j' Hcomp1 Hcomp1')
      (Hstep: internal_step pf1j Hcomp1 tp2 m2),
    exists tp2' m2' f',
      internal_step pf1j' Hcomp1' tp2' m2' /\
      ren_incr f f' /\
      ren_separated f f' m1 m1' /\
      ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
              (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive))
       \/ ((Mem.nextblock m2 = Mem.nextblock m1) /\
          (Mem.nextblock m2' = Mem.nextblock m1'))) /\
      (forall b,
          Mem.valid_block m2' b ->
          ~ Mem.valid_block m1' b ->
          let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                 (Zpos (Mem.nextblock m1))))%Z in
          f' (Z.to_pos bz) = Some b /\
          f (Z.to_pos bz) = None) /\
      (exists (pf2j: containsThread tp2 j)
         (pf2j': containsThread tp2' j)
         (Hcomp2: mem_compatible tp2 m2)
         (Hcomp2': mem_compatible tp2' m2'),
          strong_tsim f' pf2j pf2j' Hcomp2 Hcomp2') /\
      (Mem.nextblock m1 = Mem.nextblock m1' ->
       (forall b1 b2 : block, f b1 = Some b2 -> b1 = b2) ->
       forall b1 b2 : block, f' b1 = Some b2 -> b1 = b2).
  Proof.
    intros.
    inversion Hstep as [[? Hcstep] | [[Hresume ?] | Hstart]].
    - inversion Hcstep; subst.
      inversion Hsim as [Hcode_eq Hmem_obs_eq Hmem_obs_locks].
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [c1' | | |] eqn:Hcodej'; try by exfalso.
      apply ev_step_ax1 in Hcorestep.
      assert (H := corestep_obs_eq _ _ _ _ Hmem_obs_eq Hcode_eq Hfg Hge_wd
                                   Hge_incr Hcorestep).
      destruct H
        as (c2' & m2' & f' & Hcorestep' & Hcode_eq'
            & Hobs_eq & Hincr & Hseparated
            & Hnextblock & Hinverse & Hid & Hunmapped).
      exists (updThread pf1j' (Krun c2') (getCurPerm m2', (getThreadR pf1j').2)), m2', f'.
      eapply ev_step_ax2 in Hcorestep'.
      destruct Hcorestep' as [evF Hcorestep'].
      assert (Hinternal':
                internal_step pf1j' Hcomp1'
                              (updThread pf1j' (Krun c2') (getCurPerm m2', (getThreadR pf1j').2)) m2')
        by (left; eexists; econstructor; eauto).
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split.
      { assert (pf2j := containsThread_internal_step Hstep pf1j).
        assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
        assert (Hcomp2 := internal_step_compatible Hstep).
        assert (Hcomp2' := internal_step_compatible Hinternal').
        exists pf2j, pf2j', Hcomp2, Hcomp2'.
        constructor; first by do 2 rewrite gssThreadCode.
        - destruct Hobs_eq as [[Hinvalid' Hvalid' ? ? Hweak_perm] [Hstrong_perm Hval]].
          constructor.
          + 
            constructor.
            * intros b Hinvalid;
                erewrite restrPermMap_valid in Hinvalid;
                  by eauto.
            * intros b Hvalid;
                erewrite restrPermMap_valid in Hvalid;
                  by eauto.
            * eauto.
            * eauto.
            * intros b1 b2 ofs Hf';
                do 2 rewrite restrPermMap_Cur;
                do 2 rewrite gssThreadRes;
                do 2 rewrite getCurPerm_correct;
                  by eauto.
          +
            constructor.
            * intros b1 b2 ofs Hf'.
              do 2 rewrite restrPermMap_Cur;
                do 2 rewrite gssThreadRes;
                do 2 rewrite getCurPerm_correct;
                  by eauto.
            * 
              intros b1 b2 ofs Hf' Hreadable.
              simpl.
              eapply Hval; eauto.
              unfold Mem.perm in *.
              assert (H:= restrPermMap_Cur (fst (compat_th _ _ Hcomp2 pf2j)) b1 ofs).
              unfold permission_at in H.
              rewrite H in Hreadable.
              rewrite gssThreadRes in Hreadable;
                rewrite getCurPerm_correct in Hreadable.
                by assumption.
        - subst.
          assert (Hlt: permMapLt (getThreadR pf2j).2 (getMaxPerm m1))
            by (rewrite gssThreadRes; simpl; destruct Hcomp1; destruct (compat_th0 _ pf1j); eauto).
          assert (Hlt': permMapLt (getThreadR pf2j').2 (getMaxPerm m1'))
            by (rewrite gssThreadRes; simpl; destruct Hcomp1'; destruct (compat_th0 _ pf1j'); eauto).
          constructor.
          
          pose proof (weak_obs_eq Hmem_obs_locks) as Hobs_weak_locks.
          erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
          erewrite restrPermMap_irr' with (Hlt' := Hlt') in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
          
          eapply weak_mem_obs_eq_restrEq with (Hlt := Hlt) (HltF := Hlt'); eauto.
          now eapply (weak_obs_eq Hobs_eq).
          
          erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hmem_obs_locks by (rewrite gssThreadRes; simpl; auto).
          erewrite restrPermMap_irr' with (Hlt' := Hlt') in Hmem_obs_locks by (rewrite gssThreadRes; simpl; auto).
          eapply strong_mem_obs_eq_disjoint_step; eauto.
          
          intros.
          eapply CoreLanguageDry.corestep_stable_val with (Hlt2 := Hlt); eauto.
          rewrite gssThreadRes; simpl; right;
            by (eapply (fst ((thread_data_lock_coh _ Hinv0) _ pf1j) _ pf1j)).
          
          intros.
          simpl.
          apply ev_step_ax1 in Hcorestep'.
          eapply CoreLanguageDry.corestep_stable_val with (Hlt2 := Hlt'); eauto.
          rewrite gssThreadRes; simpl; right;
            by (eapply (fst ((thread_data_lock_coh _ Hinv) _ pf1j') _ pf1j')).
      }
      do 2 erewrite restrPermMap_nextblock in Hid;
        by eauto.
    - 
      subst m2.
      inversion Hsim as [Hcode_eq Hmem_obs_eq].
      inversion Hresume; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [ | |c1'|] eqn:Hcode'; try by exfalso.
      destruct Hcode_eq as [Hcode_eq Hval_eq].
      inversion Hval_eq; subst.
      assert (Hvalid_mem': valid_mem (restrPermMap (compat_th _ _ Hcomp1 pf1j)#1))
        by (erewrite <- restrPermMap_mem_valid; eauto).
      assert (Hat_external_spec := core_inj_ext _ _  Hfg Hge_wd Hge_incr Hvalid_mem' Hcode_eq Hmem_obs_eq).
      inversion Hperm; subst.
      rewrite Hat_external in Hat_external_spec.
      destruct X as [? vs].
      destruct (at_external semSem c1' (restrPermMap (compat_th _ _ Hcomp1' pf1j')#1))
        as [[? ?] | ] eqn:Hat_external';
        try by exfalso.
      destruct Hat_external_spec as [?  ?]; subst.
      assert (Hvalid_val: match (Some (Vint Int.zero)) with
                          | Some v1 => valid_val f v1
                          | None => True
                          end)
        by (now simpl).
      assert (Hafter_external' :=
                core_inj_after_ext _ _  None
                                    Hfg Hge_wd Hge_incr Hcode_eq Hmem_obs_eq Hvalid_val Hafter_external).
      destruct Hafter_external' as [ov2 [c2' [Hafter_external'
                                                [Hcore_inj' Hval_obs]]]].
      destruct ov2 as [? |]; try by exfalso.
      inversion Hval_obs; subst.
      exists (updThreadC pf1j' (Krun c2')), m1', f.
      assert (Hinternal':
                internal_step pf1j' Hcomp1' (updThreadC pf1j' (Krun c2')) m1'). {
         { clear - Hat_external' Hafter_external' Hcode' Hinv.
             right; left; econstructor; eauto.
             eapply ResumeThread with (Hcmpt := Hcomp1');
               now eauto.
         }
      }
      split;
        first by assumption.
      split; first by auto.
      split; first by congruence.
      split; first by auto.
      split; first by
          (intros; by exfalso).
      split; try by eauto.
      assert (pf2j := containsThread_internal_step Hstep pf1j).
      assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
      assert (Hcomp2 := internal_step_compatible Hstep).
      assert (Hcomp2' := internal_step_compatible Hinternal').
      exists pf2j, pf2j', Hcomp2, Hcomp2'.
      constructor; first by do 2 rewrite gssThreadCC.
      
      erewrite restrPermMap_irr' with (Hlt' := fst (compat_th _ _ Hcomp1 pf1j)) by (rewrite gThreadCR; eauto).
      erewrite restrPermMap_irr' with (Hlt' := fst (compat_th _ _ Hcomp1' pf1j')) by (rewrite gThreadCR; eauto);
        by eauto.
      erewrite restrPermMap_irr' with (Hlt' := snd (compat_th _ _ Hcomp1 pf1j)) by (rewrite gThreadCR; eauto).
      erewrite restrPermMap_irr' with (Hlt' := snd (compat_th _ _ Hcomp1' pf1j')) by (rewrite gThreadCR; eauto);
        by eauto.
    - 
      inversion Hsim as [Hcode_eq Hmem_obs_eq Hmem_obs_locks].
      inversion Hstart; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hcode_eq.
      simpl in Hcode_eq.
      destruct (getThreadC pf1j') as [| | |vf' arg'] eqn:Hcodej'; try by exfalso.
      destruct Hcode_eq as [Hval_obs Harg_obs].
      inversion Hperm; subst.
      assert (Hargs_obs: val_obs_list f [:: arg] [:: arg'])
        by (econstructor; eauto using val_obs_list).
      assert (H := core_inj_init _ _ _ Hge_wd Hfg Hge_incr Hargs_obs Hval_obs Hmem_obs_eq Hinitial).
      destruct H
        as (c_new' & m2' & f' & Hinitial' & Hcode_eq'
            & Hobs_eq & Hincr & Hseparated
            & Hnextblock & Hinverse & Hid & Hunmapped).
      exists (updThread pf1j' (Krun c_new') (getCurPerm m2', (getThreadR pf1j').2)), m2', f'.
      assert (Hinternal':
                internal_step pf1j' Hcomp1'
                              (updThread pf1j' (Krun c_new') (getCurPerm m2', (getThreadR pf1j').2)) m2').
      { right. right. econstructor; eauto. simpl.
        unfold DryHybridMachine.install_perm. reflexivity.
      }
      split; first by assumption.
      split; first by assumption.
      split; first by assumption.
      split.
      erewrite! restrPermMap_nextblock in Hnextblock.
      left; assumption.
      split; first by assumption.
      split.
      { assert (pf2j := containsThread_internal_step Hstep pf1j).
        assert (pf2j' := containsThread_internal_step Hinternal' pf1j').
        assert (Hcomp2 := internal_step_compatible Hstep).
        assert (Hcomp2' := internal_step_compatible Hinternal').
        exists pf2j, pf2j', Hcomp2, Hcomp2'.
        constructor; first by do 2 rewrite gssThreadCode.
        - destruct Hobs_eq as [[Hinvalid' Hvalid' ? ? Hweak_perm] [Hstrong_perm Hval]].
          constructor.
          + 
            constructor.
            * intros b Hinvalid;
                erewrite restrPermMap_valid in Hinvalid;
                  by eauto.
            * intros b Hvalid;
                erewrite restrPermMap_valid in Hvalid;
                  by eauto.
            * eauto.
            * eauto.
            * intros b1 b2 ofs Hf';
                do 2 rewrite restrPermMap_Cur;
                do 2 rewrite gssThreadRes;
                do 2 rewrite getCurPerm_correct;
                  by eauto.
          +
            constructor.
            * intros b1 b2 ofs Hf'.
              do 2 rewrite restrPermMap_Cur;
                do 2 rewrite gssThreadRes;
                do 2 rewrite getCurPerm_correct;
                  by eauto.
            * 
              intros b1 b2 ofs Hf' Hreadable.
              simpl.
              eapply Hval; eauto.
              unfold Mem.perm in *.
              assert (H:= restrPermMap_Cur (fst (compat_th _ _ Hcomp2 pf2j)) b1 ofs).
              unfold permission_at in H.
              rewrite H in Hreadable.
              rewrite gssThreadRes in Hreadable;
                rewrite getCurPerm_correct in Hreadable.
                by assumption.
        - subst.
          assert (Hlt: permMapLt (getThreadR pf2j).2 (getMaxPerm m1))
            by (rewrite gssThreadRes; simpl; destruct Hcomp1; destruct (compat_th0 _ pf1j); eauto).
          assert (Hlt': permMapLt (getThreadR pf2j').2 (getMaxPerm m1'))
            by (rewrite gssThreadRes; simpl; destruct Hcomp1'; destruct (compat_th0 _ pf1j'); eauto).
          constructor.
          
          pose proof (weak_obs_eq Hmem_obs_locks) as Hobs_weak_locks.
          erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
          erewrite restrPermMap_irr' with (Hlt' := Hlt') in Hobs_weak_locks by (rewrite gssThreadRes; simpl; auto).
          
          eapply weak_mem_obs_eq_restrEq with (Hlt := Hlt) (HltF := Hlt'); eauto.
          now eapply (weak_obs_eq Hobs_eq).
          
          erewrite restrPermMap_irr' with (Hlt' := Hlt) in Hmem_obs_locks by (rewrite gssThreadRes; simpl; auto).
          erewrite restrPermMap_irr' with (Hlt' := Hlt') in Hmem_obs_locks by (rewrite gssThreadRes; simpl; auto).
          eapply strong_mem_obs_eq_disjoint_step; eauto.
          
          intros.
          eapply CoreLanguageDry.initial_core_stable_val with (Hlt2 := Hlt); eauto.
          rewrite gssThreadRes; simpl; right;
            by (eapply (fst ((thread_data_lock_coh _ Hinv0) _ pf1j) _ pf1j)).
          
          intros.
          simpl.
          eapply CoreLanguageDry.initial_core_stable_val with (Hlt2 := Hlt'); eauto.
          rewrite gssThreadRes; simpl; right;
            by (eapply (fst ((thread_data_lock_coh _ Hinv) _ pf1j') _ pf1j')).
      }
      do 2 erewrite restrPermMap_nextblock in Hid;
        by eauto.
  Qed.

  Lemma strong_tsim_execution:
    forall tp1 tp2 tp1' m1 m2 m1' j xs f fg
      (pf1j: containsThread tp1 j)
      (pf1j': containsThread tp1' j)
      (Hcomp1: mem_compatible tp1 m1)
      (Hcomp1': mem_compatible tp1' m1')
      (Hinv: invariant tp1')
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_incr fg f)
      (Hvalid_mem: valid_mem m1)
      (Htp_wd: tp_wd f tp1)
      (Hsim: strong_tsim f pf1j pf1j' Hcomp1 Hcomp1')
      (Hexec: internal_execution [seq x <- xs | x == j] tp1 m1 tp2 m2),
    exists tp2' m2' f',
      internal_execution [seq x <- xs | x == j] tp1' m1' tp2' m2' /\
      ren_incr f f' /\
      ren_separated f f' m1 m1' /\
      ((exists p, ((Mem.nextblock m2 = Mem.nextblock m1 + p)%positive /\
              (Mem.nextblock m2' = Mem.nextblock m1' + p)%positive))
       \/ ((Mem.nextblock m2 = Mem.nextblock m1) /\
          (Mem.nextblock m2' = Mem.nextblock m1'))) /\
      (forall b,
          Mem.valid_block m2' b ->
          ~ Mem.valid_block m1' b ->
          let bz := ((Zpos b) - ((Zpos (Mem.nextblock m1')) -
                                 (Zpos (Mem.nextblock m1))))%Z in
          f' (Z.to_pos bz) = Some b /\
          f (Z.to_pos bz) = None) /\
      (exists (pf2j: containsThread tp2 j)
         (pf2j': containsThread tp2' j)
         (Hcomp2: mem_compatible tp2 m2)
         (Hcomp2': mem_compatible tp2' m2'),
          strong_tsim f' pf2j pf2j' Hcomp2 Hcomp2') /\
      (Mem.nextblock m1 = Mem.nextblock m1' ->
       (forall b1 b2 : block, f b1 = Some b2 -> b1 = b2) ->
       forall b1 b2 : block, f' b1 = Some b2 -> b1 = b2).
  Proof.
    intros.
    generalize dependent tp1.
    generalize dependent m1.
    generalize dependent f.
    generalize dependent tp1'. generalize dependent m1'.
    induction xs as [|x xs]; simpl; intros.
    - inversion Hexec; subst.
      exists tp1', m1', f.
      split; first by constructor.
      split; first by auto.
      split; first by congruence.
      split; first by auto.
      split; first by (intros; by exfalso).
      split; by eauto.
      simpl in HschedN;
        by inversion HschedN.
    - destruct (x == j) eqn:Hxj; move/eqP:Hxj=>Hxj.
      + subst x. inversion Hexec as [|tid U U' tp1a m1a tp0 m0].
        subst U U' tp1a m1a tp'' m''.
        simpl in Htrans. simpl in HschedN;
          inversion HschedN; subst tid; clear HschedN Hexec.
        Tactics.pf_cleanup.
        assert (Htsim := strong_tsim_step Hinv Hfg Hge_wd Hge_incr Hvalid_mem Hsim Hstep).
        destruct Htsim as
            (tp0' & m0' & f0 & Hstep0' & Hincr0' & Hsep0'
             & Hnextblock0' & Hinverse0' & Htsim0' & Hid0').
        destruct Htsim0' as [pfj' [pfj0' [Hcomp' [Hcomp0' Htsim0]]]].
        Tactics.pf_cleanup.
        assert (Hinv0': invariant tp0')
          by (eapply internal_step_invariant; eauto).
        assert (Hge_incr0': ren_incr fg f0)
          by (eapply ren_incr_trans; eauto).
        assert (H_wd0: valid_mem m0 /\ tp_wd f0 tp0).
        { destruct Hsim.
          pose proof (internal_step_wd Hvalid_mem
                                       ltac:(erewrite restrPermMap_domain;
                                             eapply mem_obs_eq_domain_ren; eauto)
                                              Htp_wd Hge_wd
                                              ltac:(eapply ren_incr_domain_incr; eauto)
                                                     Hstep) as [? [? Htp_wd0]].
          split; [assumption |].
          eapply Htp_wd0;
            eauto.
          destruct Htsim0.
          erewrite restrPermMap_domain;
            eapply mem_obs_eq_domain_ren;
            now eauto.
        }
        destruct H_wd0 as [Hvalid_mem0 Htp_wd0].
        destruct (IHxs _ _ _ _ Hinv0' _ Hge_incr0' _ Hvalid_mem0 _ _ _ Htp_wd0 Htsim0 Htrans)
          as (tp2' & m2' & f2' & Hexec & Hincr2 & Hsep2
             & Hnextblock2 & Hinverse2 & Hsim2 & Hid2);
          exists tp2', m2', f2'.
        destruct Hsim2 as [pf2j [pf2j' [Hcomp2 [Hcomp2' Htsim2]]]].
        split; first by (econstructor; simpl; eauto).
        split; first by (eapply ren_incr_trans; eauto).
        split.
        { 
          intros b1 b2 Hf Hf2'.
          unfold ren_separated in *.
          destruct (valid_block_dec m0 b1) as [Hvalidm0 | Hinvalidm0].
          * apply (domain_valid (weak_obs_eq (obs_eq_data Htsim0))) in Hvalidm0.
            destruct Hvalidm0 as [x Hf0].
            assert (b2 = x).
            {  assert (Hf2'' : f2' b1 = Some x)
                by (eapply Hincr2; eauto).
               rewrite Hf2' in Hf2''. inversion Hf2''; by subst. }
            subst x.
            eapply Hsep0';
              by eauto.
          * apply (domain_invalid (weak_obs_eq (obs_eq_data Htsim0))) in Hinvalidm0.
            destruct (Hsep2 _ _ Hinvalidm0 Hf2') as [Hinvalid Hinvalidm0'].
            split;
              intros Hcontra;
              eapply internal_step_valid in Hcontra; eauto.
        }
        split.
        { 
          destruct Hnextblock0' as [[p0 [Hnextblock0 Hnextblock0']]
                                   | [Hnextblock0 Hnextblock0']];
          destruct Hnextblock2 as [[p2 [Hnextblock2 Hnextblock2']]
                                  | [Hnextblock2 Hnextblock2']];
          clear - Hnextblock0 Hnextblock0' Hnextblock2 Hnextblock2';
          rewrite Hnextblock2 Hnextblock2';
          rewrite Hnextblock0 Hnextblock0'.
          - left. exists (p0+p2)%positive.
            split; by rewrite Pos.add_assoc.
          - left;
            exists p0; by split.
          - left; exists p2;
              by split.
          - right; by split.
        } split.
        { 
          clear - Hinverse2 Hinverse0' Hincr2 Hincr0' Hnextblock0' Hnextblock2.
          intros b Hvalidm2' Hinvalidm1'.
          destruct (valid_block_dec m0' b) as [Hvalidm0' | Hinvalidm0'].
          - specialize (Hinverse0' _ Hvalidm0' Hinvalidm1').
            simpl in Hinverse0'.
            destruct Hinverse0' as [Hf0 Hf].
            apply Hincr2 in Hf0. by split.
          - specialize (Hinverse2 _ Hvalidm2' Hinvalidm0').
            simpl in Hinverse2.
            destruct Hinverse2 as [Hf2' Hf0].
            
            assert (Heq: ((Z.pos (Mem.nextblock m1') - Z.pos (Mem.nextblock m1)) =
                          Z.pos (Mem.nextblock m0') - Z.pos(Mem.nextblock m0))%Z).
            { clear - Hnextblock0'.
              destruct Hnextblock0' as [[p0 [Hnextblock0 Hnextblock0']]
                                       | [Hnextblock0 Hnextblock0']];
                rewrite Hnextblock0 Hnextblock0';
                [do 2 rewrite Pos2Z.inj_add;
                  rewrite Zminus_plus_simpl_r;
                    by reflexivity | by reflexivity].
            }
            simpl in *.
            rewrite <- Heq in Hf2', Hf0.
            split; first by assumption.
            match goal with
            | [|- ?Expr = None] =>
              destruct Expr as [?|] eqn:Hf
            end;
              [apply Hincr0' in Hf; by congruence | trivial].
        }
        split; first by eauto.
        intros Hnb1 Hf.
        specialize (Hid0' Hnb1 Hf).
        assert (Hnb0: Mem.nextblock m0 = Mem.nextblock m0')
          by (destruct Hnextblock0' as [[p [Hnb0 Hnb0']] | [Hnb0 Hnb0']];
                by rewrite Hnb0 Hnb0' Hnb1).
        specialize (Hid2 Hnb0 Hid0').
          by assumption.
      + destruct (IHxs _ _ _ _ Hinv f Hge_incr _ Hvalid_mem _ _ _ Htp_wd Hsim Hexec)
        as
          [tp2' [m2' [f2' [Hexec2
                             [Hincr2
                                [Hsep2 [Hnextblock2 [Hinverse2 [Hsim2 Hid2]]]]]]]]];
      exists tp2', m2', f2'.
      repeat (split; auto).
  Qed.

  Lemma strong_tsim_stop:
    forall tpc trc tpc' trc' tpf mc mc' mf i fi fg
      (pfc: containsThread tpc i) (pff: containsThread tpf i)
      (Hcompc: mem_compatible tpc mc) (Hcompf: mem_compatible tpf mf)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hge_incr: ren_incr fg fi)
      (HinvF: invariant tpf)
      (Hstrong_sim: strong_tsim fi pfc pff Hcompc Hcompf)
      (Hmem_wd: valid_mem mc)
      (Hstep: cmachine_step ([:: i], trc, tpc) mc ([::], trc', tpc') mc'),
      let mrestr := restrPermMap ((compat_th _ _ Hcompc pfc).1) in
      forall (Hsuspend: pfc$mrestr @ S),
    exists tpf',
      suspend_thread mf pff tpf' /\
      forall (Hcompc': mem_compatible tpc' mc') (Hcompf' : mem_compatible tpf' mf)
        (pfc': containsThread tpc' i) (pff': containsThread tpf' i),
        strong_tsim fi pfc' pff' Hcompc' Hcompf'.
  Proof.
    intros.
    inversion Hstep; simpl in *; subst; inversion HschedN; subst;
      try (inversion Htstep || inversion Hhalted); subst; Tactics.pf_cleanup;
    unfold getStepType in Hsuspend;
    try rewrite Hcode in Hsuspend; simpl in Hsuspend;
    try match goal with
        | [H: match ?Expr with _ => _ end = _, H2: ?Expr = _ |- _] =>
          rewrite H2 in H
        end; try discriminate;
    try match goal with
        | [H: ~ containsThread _ _, H2: containsThread _ _ |- _] =>
          exfalso; by auto
        | [H: halted _ _ _  |- _] =>
          destruct (at_external_halted_excl c mrestr) as [Hnot_ext | Hcontra];
            [rewrite Hnot_ext in Hsuspend;
             destruct Hsuspend as [[_ ?] | [? _]]; discriminate |
             exfalso; eapply Hcontra; now eauto]
        end.
    destruct Hstrong_sim as [Hcode_eq memObsEq].
    rewrite Hcode in Hcode_eq.
    simpl in Hcode_eq.
    destruct (getThreadC pff) as [c'| | |] eqn:Hcode';
      try by exfalso.
    assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr
                                              ltac:(erewrite <- restrPermMap_mem_valid; eauto)
                                                         Hcode_eq memObsEq).
    inversion Hperm; subst.
    rewrite Hat_external in Hat_external_spec.
    destruct X as [? ?].
    destruct (at_external semSem c' (restrPermMap (compat_th _ _ Hcompf pff)#1))
      as [[? ?]|] eqn:Hat_external';
      try by exfalso.
    destruct Hat_external_spec as [? ?]; subst.
    exists (updThreadC pff (Kblocked c')).
    split.
    eapply SuspendThread with (Hcmpt := Hcompf); now eauto.
    intros.
    constructor;
      first by do 2 rewrite gssThreadCC.
    erewrite restrPermMap_irr' with
    (Hlt := fst (compat_th _ _ Hcompc' pfc')) (Hlt' := fst (compat_th _ _ Hcompc pfc))
      by (erewrite gThreadCR with (cntj := pfc); reflexivity).
    erewrite restrPermMap_irr' with
    (Hlt := fst (compat_th _ _ Hcompf' pff')) (Hlt' := fst (compat_th _ _ Hcompf pff))
      by (erewrite gThreadCR with (cntj := pff); reflexivity);
      by assumption.
    erewrite restrPermMap_irr' with
    (Hlt := snd (compat_th _ _ Hcompc' pfc')) (Hlt' := snd (compat_th _ _ Hcompc pfc))
      by (erewrite gThreadCR with (cntj := pfc); reflexivity).
    erewrite restrPermMap_irr' with
    (Hlt := snd (compat_th _ _ Hcompf' pff')) (Hlt' := snd (compat_th _ _ Hcompf pff))
      by (erewrite gThreadCR with (cntj := pff); reflexivity);
      by assumption.
  Qed.

  Opaque lockRes.
    Lemma strong_tsim_id :
    forall tp tp' tp'' m m' i j xs f fg
      (Hij: i <> j)
      (pfj: containsThread tp j)
      (pfj': containsThread tp' j)
      (pfj'': containsThread tp'' j)
      (pfi': containsThread tp' i)
      (Hmem_wd: valid_mem m)
      (Hdomain: domain_memren f m)
      (Htp_wd: tp_wd f tp)
      (Hfg: forall b1 b2, fg b1 = Some b2 -> b1 = b2)
      (Hge_wd: ge_wd fg the_ge)
      (Hcomp: mem_compatible tp m)
      (Hcomp'': mem_compatible tp'' m')
      (Hsuspend: suspend_thread m' pfi' tp'')
      (Hexec: internal_execution [seq x <- xs | x == i] tp m tp' m'),
      strong_tsim (id_ren m) pfj pfj'' Hcomp Hcomp''.
  Proof.
    intros.
    assert (Hdomain_id: domain_memren (id_ren m) m)
      by (apply id_ren_domain).
    assert (Htp_wd_id: tp_wd (id_ren m) tp)
      by (eapply tp_wd_domain; eauto).
    assert (Hid := id_ren_correct m).
    assert (Heq: (getThreadR pfj) = (getThreadR pfj''))
      by (erewrite @gsoThreadR_execution with (pfj' := pfj') by eauto;
          erewrite @StepLemmas.gsoThreadR_suspend with (cntj' := pfj'') by eauto;
          reflexivity).
    constructor.
    - 
      assert (Hcore := StepLemmas.gsoThreadC_suspend pfj' pfj'' Hij Hsuspend).
      rewrite <- Hcore.
      erewrite <- @gsoThreadC_exec with (pfj := pfj) (pfj' := pfj'); eauto.
      specialize (Htp_wd_id _ pfj).
      eapply ctl_inj_id;
        by eauto.
    - 
      assert (Hlt : permMapLt ((getThreadR pfj'').1) (getMaxPerm m))
        by (rewrite <- Heq; by  (eapply (fst (compat_th _ _ Hcomp pfj)))).
      assert (mem_obs_eq (id_ren m) (restrPermMap (fst (compat_th _ _ Hcomp pfj)))
                         (restrPermMap (fst (compat_th _ _ Hcomp pfj))))
        by (erewrite id_ren_restr with (Hlt := (compat_th _ _ Hcomp pfj).1); apply mem_obs_eq_id; eauto).
      erewrite restrPermMap_irr' with (Hlt' := Hlt) in H at 2 by (rewrite Heq; auto).
      eapply mem_obs_eq_extend; eauto using internal_execution_valid.
      intros.
      eapply @internal_exec_disjoint_val with (Hcomp := Hcomp) (pfj := pfj) (tp' := tp'); eauto using containsThread_internal_execution'.
      left.
      unfold Mem.perm in *.
      erewrite restrPermMap_irr' with (Hlt' := Hlt) by (rewrite Heq; eauto).
      assumption.
    - 
      assert (Hlt : permMapLt ((getThreadR pfj'').2) (getMaxPerm m))
        by (rewrite <- Heq; by  (eapply (compat_th _ _ Hcomp pfj).2)).
      assert (mem_obs_eq (id_ren m) (restrPermMap (compat_th _ _ Hcomp pfj).2)
                         (restrPermMap (compat_th _ _ Hcomp pfj).2))
        by (erewrite id_ren_restr with (Hlt := (compat_th _ _ Hcomp pfj).2); eapply mem_obs_eq_id; eauto).
      erewrite restrPermMap_irr' with (Hlt' := Hlt) in H at 2 by (rewrite Heq; auto).
      eapply mem_obs_eq_extend; eauto using internal_execution_valid.
      intros.
      eapply @internal_exec_disjoint_val with (Hcomp := Hcomp) (pfj := pfj) (tp' := tp'); eauto using containsThread_internal_execution'.
      right.
      unfold Mem.perm in *.
      erewrite restrPermMap_irr' with (Hlt' := Hlt) by (rewrite Heq; eauto).
      assumption.
  Qed.

  Lemma csafe_pop_step :
    forall (tp : thread_pool) tr (m : mem) i (cnti : containsThread tp i)
      U n
      (Hcomp: mem_compatible tp m),
      let mrestr := restrPermMap ((compat_th _ _ Hcomp cnti).1) in
      forall (Hpop: cnti$mrestr @ E \/ cnti$mrestr @ S)
        (Hsafe: csafe ((i :: U),tr,tp) m (S n)),
      exists (tp' : thread_pool) tr' (m' : mem),
         (cnti$mrestr @ S -> tr' = [::]) /\
        cmachine_step ((i :: U), tr,tp) m (U, tr++tr',tp') m' /\
        forall U'', csafe (U'',tr ++ tr',tp') m' n.
  Proof.
    intros.
    inversion Hsafe; simpl in *.
    - subst; by exfalso.
    - unfold getStepType in Hpop.
      inversion Hstep; subst; simpl in *;
      inversion HschedN; subst tid;
      try match goal with
          | [H: ?X = ?Y :: ?X |- _] =>
            exfalso;
              clear - HschedS; induction U; simpl in *; try discriminate;
              inversion HschedS;
                by auto
          end.
      inversion Htstep; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hpop. simpl in Hpop.
      destruct Hpop;
        by discriminate.
      inversion Htstep; subst.
      Tactics.pf_cleanup.
      rewrite Hcode in Hpop; simpl in Hpop.
      destruct Hpop;
        by discriminate.
      inversion Htstep; subst; Tactics.pf_cleanup.
      rewrite Hcode in Hpop. simpl in Hpop.
      apply ev_step_ax1 in Hcorestep.
      apply corestep_not_at_external in Hcorestep.
      rewrite Hcorestep in Hpop.
      destruct Hpop as [?|?];
        discriminate.
    - subst.
      exists tp', tr0, m'; split; eauto.
      intros.
      subst mrestr.
      eapply @suspend_step_inverse with (cnt := cnti) (Hcompc := Hcomp) in Hstep; eauto.
      destruct Hstep as [_ [_ [Heq _]]].
      rewrite <- List.app_nil_r in Heq at 1.
      eapply List.app_inv_head in Heq;
        now auto.
  Qed.

  Lemma sim_suspend : sim_suspend_def.
  Proof.
    unfold sim_suspend_def.
    intros.
    inversion Hsim as
        [HnumThreads HmemCompC HmemCompF HsafeC HsimWeak Hfpsep
                     HsimStrong HsimRes HunmappedRes HinvF HmaxF
                     Hwd_mem Htp_wd Hge_wd [Hge_incr Hfg] Hxs HtraceSim].
    assert (pfc: containsThread tpc i)
      by (eapply HnumThreads; eauto).
    destruct (HsimStrong i pfc pff)
      as (tpc' & mc' & Hincr & Hsynced & Hexec & Htsim & Hownedi & Hownedi_lp & Hunmappedi);
      clear HsimStrong.
    
    assert (pfc': containsThread tpc' i)
      by (clear - Hexec pfc; eapply containsThread_internal_execution in pfc;
          eauto).
    assert (memCompC' := internal_execution_compatible HmemCompC Hexec).
    specialize (Htsim pfc' memCompC').
    assert (HmemCompF = mem_compf Hsim)
      by (eapply proof_irr); subst.
    assert (Hincr_ge': ren_incr fg (fp i pfc))
      by (eapply ren_incr_trans; eauto; now destruct Hge_spec).
    assert (Hstop_pfc': pfc'$(restrPermMap (compat_th _ _ memCompC' pfc').1)@ S)
      by (erewrite (stepType_inj pff pfc' _ Hfg Hincr_ge' Hge_wd _ 
                           (obs_eq_data Htsim) (code_eq Htsim)); eauto).
    
    specialize (HsafeC ([:: i]) trc).
    assert (HcoreN := safety_det_corestepN_internal xs HsafeC Hexec).
    destruct HcoreN as [trc' [HcorestepN Hsafety]].
    destruct (csafe_pop_step pfc' _ ltac:(eauto) Hsafety) as
        (tpc'' & trc'' & mc'' & Htrc'' & Hstep' & Hsafe').
    specialize (Htrc'' Hstop_pfc'); subst.
    assert (HinvC: invariant tpc)
      by (eapply cmachine_step_invariant; eauto).
    
    assert (Heq : mc' = mc'' /\ trc ++ trc' = (trc ++ trc') ++ [::] /\ mem_compatible tpc' mc' /\
                  suspend_thread mc' pfc' tpc'')
      by (eapply suspend_step_inverse; eauto).
    destruct Heq as [? [Heq_tr [Hcomp' HsuspendC]]]; subst mc'.
    rewrite <- List.app_nil_r  in Heq_tr at 1.
    eapply List.app_inv_head in Heq_tr; subst.
    assert (memCompC'': mem_compatible tpc'' mc'')
      by (eapply StepLemmas.suspend_compatible; eauto).
    assert (Hwd_mem'': valid_mem mc'').
    { destruct (HsimWeak _ pfc pff).
      eapply internal_execution_wd; eauto.
      erewrite restrPermMap_domain.
      eapply weak_obs_eq_domain_ren;
        eauto.
      eapply ren_incr_domain_incr;
        now assumption.
    }
    assert (HstepF := strong_tsim_stop Hfg Hge_wd Hincr_ge' HinvF Htsim Hwd_mem'' Hstep' Hstop_pfc').
    destruct HstepF as [tpf' [HstepF Htsim']].
    assert (memCompF': mem_compatible tpf' mf).
      by (destruct Hsim; eapply StepLemmas.suspend_compatible; eauto).
    exists tpc'', [::], mc'', tpf', mf.
    
    exists (fp i pfc).
    assert (pfci': containsThread tpc' i)
      by (eapply containsThread_internal_execution; eauto).
    assert (pfci'': containsThread tpc'' i)
      by (eapply StepLemmas.suspend_containsThread with (tp := tpc'); eauto).
    
    exists (fun j (cntj'': containsThread tpc'' j) =>
         let cntj := (containsThread_internal_execution'
                        Hexec ((snd (StepLemmas.suspend_containsThread j HsuspendC)) cntj'')) in
         if i == j then
           fp i pfc else
           fun b1 =>
             if valid_block_dec mc b1 then f b1
             else
               if valid_block_dec mc'' b1 then
                 (fp i pfc) b1
               else
                 let bz :=
                     (Z.pos b1 - (Z.pos (Mem.nextblock mc'') -
                                  Z.pos (Mem.nextblock mc)))%Z in
                 (fp j cntj) (Z.to_pos bz)), trf.
    split.
    { 
      intros U; eapply suspend_step; simpl; eauto.
    }
    { 
            assert (Hle: (Mem.nextblock mc <= Mem.nextblock mc'')%positive)
        by (eapply internal_execution_nextblock; eauto).
      assert (Hdomainf: domain_memren f mc)
        by (destruct (HsimWeak _ pfc pff) as [HsimWeak' _];
             eapply weak_obs_eq_domain_ren in HsimWeak'; eauto).
      assert (Hwd := internal_execution_wd _ _ Hdomainf Hwd_mem Htp_wd
                                           Hge_wd (ren_incr_domain_incr
                                                     Hge_incr) Hexec).
      destruct Hwd as [Hwd_mem' [[f' [Hincrf' Hdomainf']] Htp_wd']].
      assert (pffi': containsThread tpf' i)
        by (eapply StepLemmas.suspend_containsThread with (cnti := pff); eauto).
      specialize (Htsim' memCompC'' memCompF' pfci'' pffi').
      assert (Hdomain_fi: domain_memren (fp i pfc) mc'')
        by (eapply (mem_obs_eq_domain_ren (obs_eq_data Htsim')); eauto).
      specialize (Htp_wd' _ Hdomain_fi).
      eapply @Build_sim with (mem_compc := memCompC'') (mem_compf := memCompF').
      { 
        clear - HnumThreads Hexec HsuspendC HstepF.
        intros j. assert (Hpffj := StepLemmas.suspend_containsThread j HstepF).
        assert (Hpfcj' := StepLemmas.suspend_containsThread j HsuspendC).
        split; intros;
        [apply Hpffj; apply HnumThreads;
         destruct Hpfcj'; eapply containsThread_internal_execution'; eauto
        |  apply Hpfcj';
          destruct Hpffj;
          eapply containsThread_internal_execution; eauto;
          destruct (HnumThreads j); by auto].
      }
      { 
        intros.
        rewrite cats0 in Hsafe'.
        specialize (Hsafe' sched).
        eapply HybridCoarseMachine.csafe_trace with (tr' := tr) in Hsafe'.
        assumption.
      }
      { 
        clear HsafeC. Tactics.pf_cleanup.
        intros j pfcj'' pffj'.
        pose proof (weak_obs_eq (obs_eq_data Htsim)) as Hweak_obs_eq_data.
        
        assert (Hperm_weak: forall (b1 b2 : block) (ofs : Z),
                   fp i pfc b1 = Some b2 ->
                   Mem.perm_order'' (permission_at (restrPermMap (fst (compat_th _ _ memCompC'' pfcj''))) b1 ofs Cur)
                                    (permission_at (restrPermMap (fst (compat_th _ _ memCompF' pffj'))) b2 ofs Cur) /\
                   Mem.perm_order'' (permission_at (restrPermMap (snd (compat_th _ _ memCompC'' pfcj''))) b1 ofs Cur)
                                    (permission_at (restrPermMap (snd (compat_th _ _ memCompF' pffj'))) b2 ofs Cur)).
        { 
                    intros b1 b2 ofs Hfi.
          
          assert (pffj: containsThread tpf j)
            by (eapply StepLemmas.suspend_containsThread; eauto).
          assert (Hperm_eqF: permission_at (restrPermMap (compat_th _ _ memCompF' pffj').1)
                                           b2 ofs Cur =
                             permission_at (restrPermMap (compat_th _ _ (mem_compf Hsim) pffj).1)
                                           b2 ofs Cur)
            by (do 2 rewrite restrPermMap_Cur;
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffj); eauto).
          assert (Hperm_eqF_locks: permission_at (restrPermMap (compat_th _ _ memCompF' pffj').2)
                                           b2 ofs Cur =
                             permission_at (restrPermMap (compat_th _ _ (mem_compf Hsim) pffj).2)
                                           b2 ofs Cur)
            by (do 2 rewrite restrPermMap_Cur;
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffj); eauto).
          rewrite Hperm_eqF Hperm_eqF_locks.
          
          assert (pfcj': containsThread tpc' j)
            by (eapply StepLemmas.suspend_containsThread; eauto).
          assert (Hperm_eqC: permission_at (restrPermMap (compat_th _ _ memCompC'' pfcj'').1)
                                           b1 ofs Cur =
                             permission_at (restrPermMap (compat_th _ _ memCompC' pfcj').1)
                                           b1 ofs Cur)
            by (do 2 rewrite restrPermMap_Cur;
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pfcj'); eauto).
          assert (Hperm_eqC_locks: permission_at (restrPermMap (compat_th _ _ memCompC'' pfcj'').2)
                                           b1 ofs Cur =
                             permission_at (restrPermMap (compat_th _ _ memCompC' pfcj').2)
                                           b1 ofs Cur)
            by (do 2 rewrite restrPermMap_Cur;
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pfcj'); eauto).
          rewrite Hperm_eqC Hperm_eqC_locks.
          clear Hperm_eqF Hperm_eqC HcorestepN HstepF Hstep'.
          destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
          { 
            subst.
            clear - Htsim Hfi.
            destruct Htsim as [_ Hmem_obs_eq_data Hmem_obs_eq_locks];
              destruct Hmem_obs_eq_data as [Hweak_data _];
              destruct Hweak_data as [_ _ _ _ Hperm_weak_data];
              destruct Hmem_obs_eq_locks as [Hweak_locks _];
              destruct Hweak_locks as [_ _ _ _ Hperm_weak_locks].
            specialize (Hperm_weak_data b1 b2 ofs Hfi).
            specialize (Hperm_weak_locks b1 b2 ofs Hfi);
              by Tactics.pf_cleanup.
          }
          { 
            assert (pfcj: containsThread tpc j)
              by (eapply containsThread_internal_execution'; eauto).
            destruct (HsimWeak _ pfcj pffj) as [Hweak_data Hweak_locks].
            destruct Hweak_data as [Hinvdomain Hdomain Hcodomain Hinjective Hobs_weak_data].
            destruct Hweak_locks as [_ _ _ _ Hobs_weak_locks].
            destruct (valid_block_dec mc b1) as [Hvalid_mc | Hinvalid_mc].
            - 
              assert (Hvalid: Mem.valid_block (restrPermMap (compat_th _ _ HmemCompC pfcj).1) b1)
                by (unfold Mem.valid_block in *;
                      by rewrite restrPermMap_nextblock).
              apply Hdomain in Hvalid.
              destruct Hvalid as [b2' Hf].
              assert (b2 = b2')
                by (apply Hincr in Hf; rewrite Hf in Hfi;
                    inversion Hfi; by subst); subst b2'.
              destruct (permission_at_execution xs pfc pfcj pfcj' Hij HmemCompC memCompC' Hexec b1 ofs) as [H1 H2].
              erewrite <- H1, <- H2;
                by eauto.
            - 
                            apply Hinvdomain in Hinvalid_mc.
              destruct (Hownedi j pffj Hij _ _ ofs Hfi Hinvalid_mc) as [Hownedi_data Hownedi_locks].
              rewrite! restrPermMap_Cur.
              rewrite Hownedi_data Hownedi_locks.
              destruct ((getThreadR pfcj').1 # b1 ofs), ((getThreadR pfcj').2 # b1 ofs); simpl;
                by auto.
          }
        }
        constructor;
          constructor; try (by (destruct Hweak_obs_eq_data; eauto));
            intros; by (destruct (Hperm_weak _ _ ofs Hrenaming)).
      }
      { 
        intros k j cntk cntj Hkj b b' b2 b2' Hfi Hfi' Hfk Hfj.
        simpl in Hfk, Hfj.
        destruct (i == k) eqn:Hik; destruct (i == j) eqn: Hij;
        move/eqP:Hik=> Hik; move/eqP:Hij => Hij.
        - subst k j. by exfalso.
        - subst k.
            by congruence.
        - subst j.
            by congruence.
        - destruct (valid_block_dec mc b) as [Hvalidb | Hinvalidb];
          first by (apply Hincr in Hfk; by congruence).
          destruct (valid_block_dec mc'' b) as [Hvalidib | Hinvalidib];
            first by (simpl in *; congruence).
          destruct (valid_block_dec mc b') as [Hvalidb' | Hinvalidb'];
            first by (apply Hincr in Hfj; by congruence).
          destruct (valid_block_dec mc'' b') as [Hvalidib' | Hinvalidib'];
            first by (simpl in *; congruence).
          specialize (HsimWeak _ pfc pff).
          apply Pos.lt_eq_cases in Hle.
          simpl in Hfj, Hfk.
          destruct Hle as [Hlt | Heq].
          + apply Pos.le_nlt in Hinvalidb.
            apply Pos.le_nlt in Hinvalidib.
            assert (Hinvalid:
                      (Mem.nextblock mc <=
                       Z.to_pos (Z.pos_sub b (Mem.nextblock mc'' -
                                              Mem.nextblock mc)))%positive)
              by (eapply le_sub; eauto).
            eapply Hfpsep with (i := k) (j := j); eauto.
            apply Pos.le_nlt in Hinvalid.
            apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid.
            rewrite Z.pos_sub_gt; auto.
            apply Pos.le_nlt in Hinvalidb'.
            apply Pos.le_nlt in Hinvalidib'.
            assert (Hinvalid':
                      (Mem.nextblock mc <=
                       Z.to_pos (Z.pos_sub b' (Mem.nextblock mc'' -
                                               Mem.nextblock mc)))%positive)
              by (eapply le_sub; eauto).
            apply Pos.le_nlt in Hinvalid'.
            apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid'.
            rewrite Z.pos_sub_gt; auto.
          + eapply Hfpsep with (i := k) (j := j); eauto;
            rewrite Heq;
            rewrite Z.pos_sub_diag; simpl;
            [ by apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidb
            | by apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidb'].
      }
      { 
        intros j pfcj'' pffj'.
        case (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        { subst j. exists tpc'', mc''. simpl.
          split;
            first by (apply ren_incr_refl).
          split; auto. split.
          assert (Hempty: [seq x <- [seq x <- xs | x != i] | x == i] = nil).
          { clear. induction xs as [|x xs]; first by reflexivity.
            simpl; destruct (x == i) eqn:Heq;
            simpl; first by assumption.
            erewrite if_false
              by (apply/eqP; intro Hcontra; subst;
                    by move/eqP:Heq=>Heq).
              by assumption.
          }
          rewrite Hempty;
            by constructor.
          split; first by (intros; Tactics.pf_cleanup; auto).
          split; first by congruence.
          split; first by congruence.
          intros b2 Hfi ofs.
          erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pff);
            by eauto.
        }
        { 
          assert (pfc'j: containsThread tpc' j)
            by (eapply StepLemmas.suspend_containsThread with (cnti := pfc'); eauto).
          assert (pfcj: containsThread tpc j)
            by (eapply containsThread_internal_execution'; eauto).
          specialize (HsimWeak _ pfc pff).
          
          assert (Hdomain_f: domain_memren f mc)
            by (apply (weak_obs_eq_domain_ren (weak_tsim_data HsimWeak))).
          
          assert (Hdomain_id: domain_memren (id_ren mc) mc)
            by (apply id_ren_domain).
          
          assert (Htp_wd_id: tp_wd (id_ren mc) tpc)
            by (eapply tp_wd_domain; eauto).
          simpl.
          assert (H : containsThread_internal_execution'
                        Hexec (snd (StepLemmas.suspend_containsThread
                                        j HsuspendC) pfcj'') = pfcj) by
              (erewrite proof_irr
               with (a1 := (containsThread_internal_execution'
                              Hexec (snd (StepLemmas.suspend_containsThread j HsuspendC)
                                           pfcj'')))
                      (a2 := pfcj); auto).
          rewrite H; clear H.
                    assert (Hsim_c_ci: strong_tsim (id_ren mc)
                                         pfcj pfcj'' HmemCompC memCompC'')
            by (eapply strong_tsim_id with (f := id_ren mc) (pfi' := pfc'); eauto).
          assert (pffj: containsThread tpf j)
            by (eapply StepLemmas.suspend_containsThread; eauto).
          assert (Htsimj := (simStrong Hsim) j pfcj pffj).
                    destruct Htsimj as
              (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
               & Hownedj & Hownedj_lp & Hunmappedj).
                    assert (Hinv'': invariant tpc'')
            by (eapply StepLemmas.suspend_invariant with (tp := tpc');
                 [eapply internal_execution_invariant with (tp := tpc);
                   eauto | eauto]).
          assert (Hge_incr_id: ren_incr fg (id_ren mc))
            by (clear - Hge_incr Hfg Hdomain_f;
                 eapply incr_domain_id; eauto).
          assert (Hsimjj':= strong_tsim_execution xs Hinv'' Hfg Hge_wd
                                                  Hge_incr_id Hwd_mem Htp_wd_id Hsim_c_ci Hexecj).
          destruct Hsimjj'
            as (tpcj' & mcj' & fij & Hexecij
                & Hincr' & Hsep  & Hnextblockj' & Hinverse & Hsimjj').
          destruct Hsimjj' as [[pfcjj [pfij [Hcompjj [Hcompij Hsimij]]]] Hid_case].
          Tactics.pf_cleanup.
                    specialize (Htsimj pfcjj Hcompjj).
          exists tpcj', mcj'.
                    assert (Hvalidmcj':
                    forall b1 b2 (pf: containsThread tpc j),
                      ~ Mem.valid_block mc b1 ->
                      ~ Mem.valid_block mc'' b1 ->
                      fp j pf
                         (Z.to_pos ((Z.pos b1 -
                                     (Z.pos (Mem.nextblock mc'') -
                                      Z.pos (Mem.nextblock mc)))%Z)) = Some b2 ->
                      Mem.valid_block mcj' b1).
          { 
            intros b1 b2 pf Hinvalidmc Hinvalidmc'' Hf'.
            destruct (valid_block_dec mcj' b1) as [? | Hinvalidmcj'];
              first by assumption.
            exfalso.
            clear - Hnextblockj' Hinvalidmc Hinvalidmc''
                                 Hf' Hinvalidmcj' Htsimj Hle.
            Tactics.pf_cleanup.
            apply Pos.le_lteq in Hle.
            destruct Hle as [Hlt | Hnbeq].
            - 
              assert (Hnblocks:
                        (Z.pos (Mem.nextblock mc'') + Z.neg (Mem.nextblock mc) =
                         Z.pos (Mem.nextblock mcj') + Z.neg (Mem.nextblock mcj))%Z).
              { clear -Hnextblockj'.
                destruct Hnextblockj' as [[p [Hmcj Hmcj']]|[Hmcj Hmcj']];
                  rewrite Hmcj Hmcj'; try reflexivity.
                replace (Z.neg (Mem.nextblock mc + p)) with
                (Z.opp (Z.pos (Mem.nextblock mc + p))%Z)
                  by (by rewrite Pos2Z.opp_pos).
                rewrite Z.add_opp_r.
                do 2 rewrite Pos2Z.inj_add.
                rewrite Zminus_plus_simpl_r.
                  by reflexivity.
              }
              simpl in Hf'.
              rewrite <- Pos2Z.add_pos_neg in Hf'.
              rewrite Hnblocks in Hf'. simpl in Hf'.
              assert (Hnb': (Mem.nextblock mcj < Mem.nextblock mcj')%positive).
              { simpl in Hnblocks.
                rewrite Z.pos_sub_gt in Hnblocks; auto.
                destruct (Coqlib.plt (Mem.nextblock mcj) (Mem.nextblock mcj'))
                  as [? | Hcontra];
                  first by assumption.
                unfold Coqlib.Plt in Hcontra.
                apply Pos.le_nlt in Hcontra.
                apply Pos.le_lteq in Hcontra.
                exfalso.
                destruct Hcontra as [Hcontra | Hcontra].
                rewrite Z.pos_sub_lt in Hnblocks; auto.
                  by congruence.
                  rewrite Hcontra in Hnblocks.
                  rewrite Z.pos_sub_diag in Hnblocks.
                  assert (H:= Pos2Z.is_pos (Mem.nextblock mc'' - Mem.nextblock mc)).
                  rewrite Hnblocks in H.
                    by apply Z.lt_irrefl with (x :=0%Z).
              }
              rewrite Z.pos_sub_gt in Hf'; auto.
              simpl in Hf'.
              apply Pos.le_nlt in Hinvalidmcj'.
              assert (Hinvalid: (Mem.nextblock mcj
                                 <=
                                 Z.to_pos (Z.pos_sub b1 (Mem.nextblock mcj'
                                                         - Mem.nextblock mcj)))%positive)
                by (eapply le_sub; eauto).
              apply Pos.le_nlt in Hinvalid.
              apply (domain_invalid (weak_obs_eq (obs_eq_data Htsimj))) in Hinvalid.
                by congruence.
            - rewrite Hnbeq in Hf'.
              simpl in Hf'.
              rewrite Z.pos_sub_diag in Hf'.
              simpl in Hf'.
              destruct Hnextblockj' as [[p [Hmcj Hmcj']] | [Hmcj Hmcj']].
              + rewrite Hnbeq in Hmcj.
                rewrite <- Hmcj' in Hmcj.
                assert (Hcontra: ~ Mem.valid_block mcj b1)
                  by (unfold Mem.valid_block in *; rewrite Hmcj; auto).
                apply (domain_invalid (weak_obs_eq (obs_eq_data Htsimj))) in Hcontra.
                  by congruence.
              + assert (Hcontra: ~ Mem.valid_block mcj b1)
                  by (unfold Mem.valid_block in *; rewrite Hmcj; auto).
                apply (domain_invalid (weak_obs_eq (obs_eq_data Htsimj))) in Hcontra.
                  by congruence.
          }
          split.
          { 
            intros b1 b2 Hfi.
            destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
            - assert (Hf_val := (domain_valid (weak_tsim_data HsimWeak)) b1).
              specialize (Hf_val
                            ((snd (restrPermMap_valid
                                       (compat_th _ _ HmemCompC pfc).1 b1)) Hvalidmc)).
              destruct Hf_val as [b2' Hf_val].
              assert (Heq: b2 = b2')
                by (apply Hincr in Hf_val;
                     rewrite Hf_val in Hfi; inversion Hfi; by subst);
                subst b2';
                  by assumption.
            - destruct (valid_block_dec mc'' b1) as [Hvalidmc'' | Hinvalidmc''];
              first by assumption.
              destruct (valid_block_dec mcj' b1) as [Hvalidmcj'_b1 | Hinvalidmcj'];
                assert (Hcontra := domain_invalid (weak_obs_eq (obs_eq_data Htsim')));
                assert (Hinvalid: ~ Mem.valid_block
                                    (restrPermMap (compat_th _ _ memCompC'' pfci'').1) b1)
                  by (intros Hcontra2;
                        by apply restrPermMap_valid in Hcontra2);
                specialize (Hcontra _ Hinvalid);
                  by congruence.
          } split.
          { 
            intros Hsynced'.
            assert (Hlst :[seq x <- [seq x <- xs | x != i] | x == j] =
                          [seq x <- xs | x == j]) by (by eapply filter_neq_eq).
            rewrite Hlst in Hsynced'.
            rewrite Hsynced' in Hexecij.
            inversion Hexecij; subst;
            [|simpl in HschedN; inversion HschedN; subst; discriminate].
            rewrite Hsynced' in Hexecj.
            specialize (Hsyncedj Hsynced'). simpl. subst f.
            extensionality b.
            destruct (valid_block_dec mc b) as [Hvalidmc | Hinvalidmc].
            - assert (Hfb := (domain_valid (weak_tsim_data HsimWeak)) b Hvalidmc).
              destruct Hfb as [b' Hfb].
              rewrite Hfb. by apply Hincr in Hfb.
            - destruct (valid_block_dec mcj' b) as [? | Hinvalidmcj'];
              first by reflexivity.
              assert (Hinvdomain := domain_invalid (weak_obs_eq (obs_eq_data Htsim))).
              assert (Hinvalidmcji':
                        ~ Mem.valid_block (restrPermMap (compat_th _ _ memCompC' pfc').1) b)
                by (intros Hcontra; by apply restrPermMap_valid in Hcontra).
              specialize (Hinvdomain _ Hinvalidmcji'). rewrite Hinvdomain.
              assert (Heq: mc = mcj)
                by (inversion Hexecj; [subst mcj; auto |
                                       simpl in HschedN; discriminate]).
              subst mcj.
              apply Pos.lt_eq_cases in Hle.
              simpl.
              destruct Hle as [Hlt | Heq].
              + apply Pos.le_nlt in Hinvalidmc.
                apply Pos.le_nlt in Hinvalidmcj'.
                assert (Hinvalid:
                          (Mem.nextblock mc <=
                           Z.to_pos (Z.pos_sub b (Mem.nextblock mcj' -
                                                  Mem.nextblock mc)))%positive)
                  by (eapply le_sub; eauto).
                rewrite Z.pos_sub_gt; auto.
                simpl.
                apply Pos.le_nlt in Hinvalid.
                apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid.
                  by auto.
              + rewrite Heq. rewrite Z.pos_sub_diag. simpl.
                apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc;
                  by auto.
          } split.
          { 
              by rewrite filter_neq_eq.
          } split.
          { 
            intros pfcj' Hcompcj'. Tactics.pf_cleanup.
                        assert (Hinvalid_domain:
                      forall b,
                        ~ Mem.valid_block mcj' b ->
                        (if valid_block_dec mc b
                         then f b
                         else
                           if valid_block_dec mc'' b
                           then fp i pfc b
                           else
                             fp j pfcj
                                (Z.to_pos
                                   match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                   | 0%Z => Z.pos b
                                   | Z.pos y' => Z.pos (b + y')
                                   | Z.neg y' => Z.pos_sub b y'
                                   end)) = None).
            { intros b Hinvalid.
              assert (Hinvalidmc'': ~ Mem.valid_block mc'' b)
                by (intros Hcontra;
                    eapply internal_execution_valid with (m' := mcj')
                      in Hcontra;
                    eauto).
              assert (Hinvalidmc: ~ Mem.valid_block mc b)
                by (intros Hcontra;
                    eapply internal_execution_valid with (m' := mc'')
                      in Hcontra;
                    eauto).
              simpl.
              unfold is_left.
              erewrite Coqlib2.if_false by eassumption.
              erewrite Coqlib2.if_false by eassumption.
              match goal with
              | [|- fp _ _ ?Expr = _] =>
                destruct (valid_block_dec mcj Expr) as [Hvalidmcj | Hinvalidmcj]
              end.
              + apply Pos.lt_eq_cases in Hle.
                destruct Hle as [Hlt | Heq].
                * apply Pos.le_nlt in Hinvalidmc''.
                  apply Pos.le_nlt in Hinvalidmc.
                  assert (Hinvalid':
                            (Mem.nextblock mc <=
                             Z.to_pos (Z.pos_sub b (Mem.nextblock mc'' -
                                                    Mem.nextblock mc)))%positive)
                    by (eapply le_sub; eauto).
                  apply Pos.le_nlt in Hinvalid'.
                  apply (domain_valid (weak_obs_eq (obs_eq_data Hsimij))) in Hvalidmcj.
                  apply (domain_invalid (weak_obs_eq (obs_eq_data Hsim_c_ci))) in Hinvalid'.
                  destruct Hvalidmcj as [b2 Hfij].
                  rewrite Z.pos_sub_gt in Hfij; auto.
                  assert (Hinvalid2 := Hsep _ _ Hinvalid' Hfij).
                  assert (Hvalidb2 :=
                            (codomain_valid (weak_obs_eq (obs_eq_data Hsimij))) _ _ Hfij).
                  erewrite restrPermMap_valid in Hvalidb2.
                  destruct Hinvalid2 as [_ Hinvalidb2''].
                  specialize (Hinverse _ Hvalidb2 Hinvalidb2'').
                  simpl in Hinverse.
                  destruct Hinverse as [Hcontra _].
                  assert (Heq_contra :=
                            (injective (weak_obs_eq (obs_eq_data Hsimij)))
                              _ _ _ Hfij Hcontra).
                  assert (Heq : b = b2).
                  { apply Pos.le_nlt in Hinvalidb2''.
                    assert (((Mem.nextblock mc'' - Mem.nextblock mc) < b)%positive)
                      by (eapply lt_lt_sub; eauto).
                    assert (((Mem.nextblock mc'' - Mem.nextblock mc) < b2)%positive)
                      by (eapply lt_lt_sub; eauto).
                    rewrite Z.pos_sub_gt in Heq_contra; auto.
                    simpl in Heq_contra.
                    apply Z2Pos.inj_iff in Heq_contra;
                      try (rewrite Z.pos_sub_gt; auto;
                           apply Pos2Z.is_pos).
                    rewrite Z.pos_sub_gt in Heq_contra; auto.
                    rewrite Z.pos_sub_gt in Heq_contra; auto.
                    inversion Heq_contra as [Heq_contra2].
                    apply Pos.compare_eq_iff in Heq_contra2.
                    rewrite Pos.sub_compare_mono_r in Heq_contra2;
                      try (eapply lt_lt_sub; eauto).
                      by apply Pos.compare_eq_iff.
                  } subst b. by exfalso.
                * rewrite Heq in Hvalidmcj.
                  rewrite Z.pos_sub_diag in Hvalidmcj.
                  simpl in Hvalidmcj.
                  rewrite Heq. rewrite Z.pos_sub_diag.
                  simpl.
                  apply (domain_valid (weak_obs_eq (obs_eq_data Hsimij))) in Hvalidmcj.
                  apply (domain_invalid (weak_obs_eq (obs_eq_data Hsim_c_ci ))) in Hinvalidmc.
                  destruct Hvalidmcj as [b2 Hfij].
                  assert (Hinvalid2 := Hsep _ _ Hinvalidmc Hfij).
                  assert (Hvalidb2 :=
                            (codomain_valid (weak_obs_eq (obs_eq_data Hsimij))) _ _ Hfij).
                  erewrite restrPermMap_valid in Hvalidb2.
                  destruct Hinvalid2 as [_ Hinvalidb2''].
                  specialize (Hinverse _ Hvalidb2 Hinvalidb2'').
                  simpl in Hinverse.
                  destruct Hinverse as [Hcontra _].
                  rewrite Heq in Hcontra.
                  rewrite Z.pos_sub_diag in Hcontra.
                  simpl in Hcontra.
                  assert (Heq_contra :=
                            (injective (weak_obs_eq (obs_eq_data Hsimij)))
                              _ _ _ Hfij Hcontra).
                  subst;
                    by exfalso.
              + apply (domain_invalid (weak_obs_eq (obs_eq_data Htsimj))) in Hinvalidmcj.
                  by assumption.
            }
            assert (Hvalid_domain:
                      forall b,
                        Mem.valid_block mcj' b ->
                        exists b' : block,
                          (if valid_block_dec mc b
                           then f b
                           else
                             if valid_block_dec mc'' b
                             then fp i pfc b
                             else
                               fp j pfcj
                                  (Z.to_pos
                                     match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                     | 0%Z => Z.pos b
                                     | Z.pos y' => Z.pos (b + y')
                                     | Z.neg y' => Z.pos_sub b y'
                                     end)) = Some b').
            { intros b1 Hvalid.
              simpl.
              destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
              - assert (Hf := (domain_valid (weak_tsim_data HsimWeak)) b1).
                erewrite restrPermMap_valid in Hf.
                destruct (Hf Hvalidmc) as [b2 Hf_val].
                eexists; eassumption.
              - destruct (valid_block_dec mc'' b1)
                  as [Hvalidmc'' | Hinvalidmc''].
                + assert (Hfi := (domain_valid
                                    (weak_obs_eq (obs_eq_data Htsim'))) b1).
                  erewrite restrPermMap_valid in Hfi.
                  eauto.
                + specialize (Hinverse b1 Hvalid Hinvalidmc'').
                  simpl in Hinverse.
                  destruct Hinverse as [Hfij Hf'].
                  destruct (
                      valid_block_dec mcj
                                      (Z.to_pos
                                         match
                                           (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z
                                         with
                                         | 0%Z => Z.pos b1
                                         | Z.pos y' => Z.pos (b1 + y')
                                         | Z.neg y' => Z.pos_sub b1 y'
                                         end)) as [Hvalidmcj | Hinvalidmcj];
                    [ apply (domain_valid (weak_obs_eq (obs_eq_data Htsimj))) in Hvalidmcj;
                        by assumption |
                      apply (domain_invalid (weak_obs_eq (obs_eq_data Hsimij))) in Hinvalidmcj;
                        by congruence].
            }
            
            assert (Hcodomain: forall b1 b2 : block,
                       (if valid_block_dec mc b1
                        then f b1
                        else
                          if valid_block_dec mc'' b1
                          then fp i pfc b1
                          else
                            fp j pfcj
                               (Z.to_pos
                                  match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                  | 0%Z => Z.pos b1
                                  | Z.pos y' => Z.pos (b1 + y')
                                  | Z.neg y' => Z.pos_sub b1 y'
                                  end)) = Some b2 -> Mem.valid_block mf b2).
              {  intros b1 b2 Hf'.
                  assert (Hfj_codomain := codomain_valid (weak_obs_eq (obs_eq_data Htsimj))).
                  assert (Hfi_codomain := codomain_valid (weak_obs_eq (obs_eq_data Htsim))).
                  simpl in Hf'.
                  unfold is_left in Hf'.
                  repeat match goal with
                         | [H: context[match valid_block_dec ?M ?B with
                                       | _ => _ end] |- _] =>
                           destruct (valid_block_dec M B)
                         end; try discriminate.
                  specialize (Hfj_codomain b1 b2);
                    erewrite restrPermMap_valid in *.
                  eauto.
                  specialize (Hfi_codomain b1 b2);
                    erewrite restrPermMap_valid in *.
                  eauto.
                  specialize (Hfj_codomain _ _ Hf');
                    by erewrite restrPermMap_valid in *.
              }
              
              assert (Hinjective: forall b1 b1' b2 : block,
                         (if valid_block_dec mc b1
                          then f b1
                          else
                            if valid_block_dec mc'' b1
                            then fp i pfc b1
                            else
                              fp j pfcj
                                 (Z.to_pos
                                    match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                    | 0%Z => Z.pos b1
                                    | Z.pos y' => Z.pos (b1 + y')
                                    | Z.neg y' => Z.pos_sub b1 y'
                                    end)) = Some b2 ->
                         (if valid_block_dec mc b1'
                          then f b1'
                          else
                            if valid_block_dec mc'' b1'
                            then fp i pfc b1'
                            else
                              fp j pfcj
                                 (Z.to_pos
                                    match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                    | 0%Z => Z.pos b1'
                                    | Z.pos y' => Z.pos (b1' + y')
                                    | Z.neg y' => Z.pos_sub b1' y'
                                    end)) = Some b2 -> b1 = b1').
              {  intros b1 b1' b2 Hfb1 Hfb1'.
                  destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
                  { 
                    destruct (valid_block_dec mc b1') as [Hvalidmc' | Hinvalidmc'].
                    - 
                      eapply (injective (weak_tsim_data HsimWeak)); eauto.
                    - 
                      destruct (valid_block_dec mc'' b1') as [Hvalidmc''' | Hinvalidmc'''].
                      + apply Hincr in Hfb1.
                        eapply (injective (weak_obs_eq (obs_eq_data Htsim))); eauto.
                      + 
                                                clear - Hfb1' Hfb1 Hincrj Htsimj Hvalidmc Hexec
                                      Hinvalidmc''' Hinvalidmc' Hle.
                        apply Hincrj in Hfb1.
                        apply Pos.le_lteq in Hle.
                        destruct Hle as [Hlt | Hnbeq].
                        * rewrite Z.pos_sub_gt in Hfb1'; auto. simpl in Hfb1'.
                          apply Pos.le_nlt in Hinvalidmc'''.
                          assert (Hinvalid: (Mem.nextblock mc
                                             <=
                                             Z.to_pos (Z.pos_sub b1' (Mem.nextblock mc''
                                                                      - Mem.nextblock mc)))%positive)
                            by (eapply le_sub; eauto).
                          apply Pos.le_nlt in Hinvalid.
                          assert (Hcontra:= (injective
                                               (weak_obs_eq (obs_eq_data Htsimj)))
                                              _ _ _ Hfb1 Hfb1').
                          subst b1.
                            by exfalso.
                        * rewrite Hnbeq in Hfb1'.
                          rewrite Z.pos_sub_diag in Hfb1'.
                          simpl in Hfb1'.
                          assert (Hcontra := (injective (weak_obs_eq (obs_eq_data Htsimj)))
                                               _ _ _ Hfb1 Hfb1').
                          subst b1;
                            by exfalso.
                  }
                  { 
                    destruct (valid_block_dec mc b1') as [Hvalidmc' | Hinvalidmc'].
                    - 
                      
                      destruct (valid_block_dec mc'' b1) as [Hvalidmc''' | Hinvalidmc'''].
                      + apply Hincr in Hfb1'.
                        eapply (injective (weak_obs_eq (obs_eq_data Htsim)));
                          by eauto.
                      + 
                                                clear - Hfb1' Hfb1 Hincrj Htsimj Hvalidmc' Hexec
                                      Hinvalidmc''' Hinvalidmc Hle.
                        apply Hincrj in Hfb1'.
                        apply Pos.le_lteq in Hle.
                        destruct Hle as [Hlt | Hnbeq].
                        * rewrite Z.pos_sub_gt in Hfb1; auto. simpl in Hfb1.
                          apply Pos.le_nlt in Hinvalidmc'''.
                          assert (Hinvalid: (Mem.nextblock mc
                                             <=
                                             Z.to_pos (Z.pos_sub b1 (Mem.nextblock mc''
                                                                      - Mem.nextblock mc)))%positive)
                            by (eapply le_sub; eauto).
                          apply Pos.le_nlt in Hinvalid.
                          assert (Hcontra:= (injective
                                               (weak_obs_eq (obs_eq_data Htsimj)))
                                              _ _ _ Hfb1 Hfb1').
                          subst b1';
                            by exfalso.
                        * rewrite Hnbeq in Hfb1.
                          rewrite Z.pos_sub_diag in Hfb1.
                          simpl in Hfb1.
                          assert (Hcontra := (injective (weak_obs_eq (obs_eq_data Htsimj)))
                                               _ _ _ Hfb1 Hfb1').
                          subst b1';
                            by exfalso.
                    - 
                      destruct (valid_block_dec mc'' b1) as [Hvalidmci | Hinvalidmci].
                      + destruct (valid_block_dec mc'' b1') as [Hvalidmci' | Hinvalidmci'];
                        first by (eapply (injective (weak_obs_eq (obs_eq_data Htsim))); eauto).
                                                clear - Hfb1' Hfb1 Htsimj Hfpsep Hinvalidmc Hexec
                                      Hinvalidmc' Hinvalidmci' HsimWeak Hij Hle.
                        exfalso.
                        simpl in Hfb1', Hfb1.
                        apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc.
                        apply Pos.le_lteq in Hle.
                        destruct Hle as [Hlt | Hnbeq].
                        * rewrite Z.pos_sub_gt in Hfb1'; auto. simpl in Hfb1'.
                          apply Pos.le_nlt in Hinvalidmci'.
                          assert (Hinvalid: (Mem.nextblock mc
                                             <=
                                             Z.to_pos (Z.pos_sub b1' (Mem.nextblock mc''
                                                                      - Mem.nextblock mc)))%positive)
                            by (eapply le_sub; eauto).
                          apply Pos.le_nlt in Hinvalid.
                          apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid.
                          eapply Hfpsep with (b := b1) (i := i) (j := j); eauto.
                        * rewrite Hnbeq in Hfb1'.
                          rewrite Z.pos_sub_diag in Hfb1'.
                          simpl in Hfb1', Hfb1.
                          apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc'.
                          eapply Hfpsep with (b := b1) (i:=i) (j:=j); eauto.
                      + 
                        destruct (valid_block_dec mc'' b1') as [Hvalidmci' | Hinvalidmci'].
                        { 
                          clear - Hfb1' Hfb1 Htsimj Hfpsep Hexec Hinvalidmc
                                        Hinvalidmc' Hinvalidmci Hvalidmci' HsimWeak Hij
                                        Hle.
                          exfalso.
                          simpl in Hfb1', Hfb1.
                          apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc'.
                          apply Pos.le_lteq in Hle.
                          destruct Hle as [Hlt | Hnbeq].
                          * rewrite Z.pos_sub_gt in Hfb1; auto. simpl in Hfb1.
                            apply Pos.le_nlt in Hinvalidmci.
                            assert (Hinvalid: (Mem.nextblock mc
                                               <=
                                               Z.to_pos (Z.pos_sub b1 (Mem.nextblock mc''
                                                                       - Mem.nextblock mc)))%positive)
                              by (eapply le_sub; eauto).
                            apply Pos.le_nlt in Hinvalid.
                            apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid.
                            eapply Hfpsep with (b := b1') (i := i) (j := j); eauto.
                          * rewrite Hnbeq in Hfb1.
                            rewrite Z.pos_sub_diag in Hfb1.
                            simpl in Hfb1.
                            apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc.
                            eapply Hfpsep with (b := b1') (b' := b1) (i:=i) (j:=j);
                              by eauto.
                        }
                        { 
                          simpl in Hfb1, Hfb1'.
                          apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc.
                          apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc'.
                          assert (Heq := (injective (weak_obs_eq (obs_eq_data Htsimj)))
                                           _ _ _ Hfb1 Hfb1').
                          apply Pos.le_lteq in Hle.
                          destruct Hle as [Hlt | Hnbeq].
                          * eapply Pos.le_nlt in Hinvalidmci.
                            eapply Pos.le_nlt in Hinvalidmci'.
                            assert (((Mem.nextblock mc'' - Mem.nextblock mc) < b1)%positive)
                              by (eapply lt_lt_sub; eauto).
                            assert (((Mem.nextblock mc'' - Mem.nextblock mc) < b1')%positive)
                              by (eapply lt_lt_sub; eauto).
                            rewrite Z.pos_sub_gt in Heq; auto.
                            simpl in Heq.
                            apply Z2Pos.inj in Heq;
                              try (rewrite Z.pos_sub_gt; auto;
                                   apply Pos2Z.is_pos).
                            rewrite Z.pos_sub_gt in Heq; auto.
                            rewrite Z.pos_sub_gt in Heq; auto.
                            inversion Heq as [Heq2].
                            apply Pos.compare_eq_iff in Heq2.
                            rewrite Pos.sub_compare_mono_r in Heq2;
                              try (eapply lt_lt_sub; eauto).
                              by apply Pos.compare_eq_iff.
                          * rewrite Hnbeq in Heq.
                            rewrite Z.pos_sub_diag in Heq.
                            simpl in Heq;
                              by assumption.
                        }
                  }
              }

              assert (HpermC_mc_block: forall b1 ofs,
                         Mem.valid_block mc b1 ->
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).1)
                                       b1 ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompjj pfcjj).1)
                                       b1 ofs Cur /\
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).2)
                                       b1 ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompjj pfcjj).2)
                                       b1 ofs Cur).
              { intros b1 ofs Hvalidmc.
                specialize (Hincr' b1 b1 ltac:(eapply id_ren_validblock; eauto)).
                pose proof ((perm_obs_strong (strong_obs_eq (obs_eq_locks Hsimij)))
                            b1 b1 ofs Hincr');
                  pose proof ((perm_obs_strong (strong_obs_eq (obs_eq_data Hsimij)))
                                b1 b1 ofs Hincr');
                  by eauto.
              }
              
              assert (HpermF_mcj_data :=
                        perm_obs_weak (weak_obs_eq (obs_eq_data Htsimj))).
              assert (HpermF_mcj_locks :=
                        perm_obs_weak (weak_obs_eq (obs_eq_locks Htsimj))).

              assert (Hpermmcj_F_data := perm_obs_strong (strong_obs_eq
                                                       (obs_eq_data Htsimj))).
              assert (Hpermmcj_F_locks := perm_obs_strong (strong_obs_eq
                                                       (obs_eq_locks Htsimj))).

              assert (Hpermj_mc'':
                        forall b1 ofs,
                          ~ Mem.valid_block mc b1 ->
                          Mem.valid_block mc'' b1 ->
                          permission_at (restrPermMap (compat_th _ _  memCompC'' pfcj'').1)
                                        b1 ofs Cur = None /\
                          permission_at (restrPermMap (compat_th _ _ memCompC'' pfcj'').2)
                                        b1 ofs Cur = None).
              { intros b1 ofs Hinvalidmc Hvalidmc''.
                
                assert (Hinitp:
                          permission_at (restrPermMap (compat_th _ _ HmemCompC pfcj).1) b1 ofs Cur = None /\
                          permission_at (restrPermMap (compat_th _ _ HmemCompC pfcj).2) b1 ofs Cur = None).
                { apply Mem.nextblock_noaccess with (k := Max) (ofs := ofs)
                    in Hinvalidmc.
                  assert (Hlt := (compat_th _ _ HmemCompC pfcj).1 b1 ofs).
                  assert (Hlt_lock := (compat_th _ _ HmemCompC pfcj).2 b1 ofs).
                  rewrite getMaxPerm_correct in Hlt, Hlt_lock.
                  unfold permission_at in Hlt, Hlt_lock. rewrite Hinvalidmc in Hlt, Hlt_lock.
                  simpl in Hlt, Hlt_lock.
                  rewrite! restrPermMap_Cur.
                  destruct ((getThreadR pfcj).1 # b1 ofs); destruct ((getThreadR pfcj).2 # b1 ofs);
                    by tauto.
                }
                                assert (pfcj': containsThread tpc' j)
                  by (eapply containsThread_internal_execution; eauto).
                assert (Hp': permission_at (restrPermMap (compat_th _ _ memCompC' pfcj').1) b1 ofs Cur = None /\
                             permission_at (restrPermMap (compat_th _ _ memCompC' pfcj').2) b1 ofs Cur = None).
                { rewrite! restrPermMap_Cur.
                  erewrite <- gsoThreadR_execution with (pfj := pfcj); eauto.
                  rewrite! restrPermMap_Cur in Hinitp. by assumption.
                }
                rewrite! restrPermMap_Cur.
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj:= pfcj'); eauto.
                rewrite! restrPermMap_Cur in Hp'.
                  by assumption.
              }

              assert (Hpermj_mcj': forall b1 ofs,
                         ~ Mem.valid_block mc b1 ->
                         Mem.valid_block mc'' b1 ->
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).1) b1 ofs Cur = None /\
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).2) b1 ofs Cur = None).
              { 
                intros b1 ofs Hinvalidmc Hvalidmc''.
                specialize (Hpermj_mc'' b1 ofs Hinvalidmc Hvalidmc'').
                unfold permission_at in Hpermj_mc''.
                erewrite! restrPermMap_Cur.
                assert (Hdecay := @InternalSteps.internal_execution_decay _ _).
                specialize (Hdecay _ _ _ _ _ _ pfcj'' pfij memCompC''
                                   Hcompij Hexecij).
                specialize (Hdecay b1 ofs).
                destruct Hdecay as [_ Hold].
                erewrite restrPermMap_valid in Hold.
                specialize (Hold Hvalidmc'').
                destruct Hpermj_mc'' as [Hpermj_mc''_data Hpermj_mc''_locks].
                destruct Hold as [Hold | Heq];
                  first by (destruct (Hold Cur); simpl in *; congruence).
                specialize (Heq Cur).
                rewrite Hpermj_mc''_data in Heq.
                assert (Hperm_at := restrPermMap_Cur (compat_th _ _ Hcompij pfij).1 b1 ofs).
                unfold permission_at in Hperm_at. rewrite Hperm_at in Heq.
                rewrite <- Heq.
                
                pose proof (internal_execution_locks_eq Hexecij pfcj'' pfij) as Heq_locks.
                rewrite <- Heq_locks.
                assert (Hperm_at_locks := restrPermMap_Cur (compat_th _ _ memCompC'' pfcj'').2 b1 ofs).
                unfold permission_at in Hperm_at_locks.
                rewrite <- Hperm_at_locks.
                rewrite Hpermj_mc''_locks.
                split; reflexivity.
              }

              assert (Hpermj_eqF: forall b1 b2 ofs,
                         ~ Mem.valid_block mc b1 ->
                         Mem.valid_block mc'' b1 ->
                         fp i pfc b1 = Some b2 ->
                         permission_at (restrPermMap (compat_th _ _ memCompF' pffj').1) b2 ofs Cur = None /\
                         permission_at (restrPermMap (compat_th _ _ memCompF' pffj').2) b2 ofs Cur = None).
              { 
                intros b1 b2 ofs Hinvalidmc Hvalidmc'' Hfi.
                rewrite! restrPermMap_Cur.
                erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffj) by eauto.
                assert (Hf := (domain_invalid (weak_tsim_data HsimWeak))).
                specialize (Hf b1).
                erewrite restrPermMap_valid in Hf.
                eapply Hownedi;
                  by eauto.
              }

              assert (Hpermmcj_mcj': forall b1' b1 ofs,
                         fij b1' = Some b1 ->
                         permission_at (restrPermMap (compat_th _ _ Hcompjj pfcjj).1)
                                       b1' ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).1)
                                       b1 ofs Cur /\
                         permission_at (restrPermMap (compat_th _ _ Hcompjj pfcjj).2)
                                       b1' ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).2)
                                       b1 ofs Cur).
              { intros b1' b1 ofs Hfij;
                pose proof (perm_obs_strong (strong_obs_eq (obs_eq_data Hsimij))
                                            b1' ofs Hfij);
                pose proof (perm_obs_strong (strong_obs_eq (obs_eq_locks Hsimij))
                                            b1' ofs Hfij);
                  by eauto.
              }

              assert (Hperm_weak:
                        forall (b1 b2 : block) (ofs : Z),
                          (if valid_block_dec mc b1
                           then f b1
                           else
                             if valid_block_dec mc'' b1
                             then fp i pfc b1
                             else
                               fp j pfcj
                                  (Z.to_pos
                                     match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                     | 0%Z => Z.pos b1
                                     | Z.pos y' => Z.pos (b1 + y')
                                     | Z.neg y' => Z.pos_sub b1 y'
                                     end)) = Some b2 ->
                          Mem.perm_order'' (permission_at (restrPermMap (fst (compat_th _ _ Hcompij pfij))) b1 ofs Cur)
                                           (permission_at (restrPermMap (fst (compat_th _ _ memCompF' pffj'))) b2 ofs Cur) /\
                          Mem.perm_order'' (permission_at (restrPermMap (snd (compat_th _ _ Hcompij pfij))) b1 ofs Cur)
                                           (permission_at (restrPermMap (snd (compat_th _ _ memCompF' pffj'))) b2 ofs Cur)).
              { intros b1 b2 ofs Hf'.
                simpl in Hf'.
                destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
                { 
                  specialize (HpermC_mc_block b1 ofs Hvalidmc).
                  apply Hincrj in Hf'.
                  specialize (HpermF_mcj_data b1 b2 ofs Hf').
                  specialize (HpermF_mcj_locks b1 b2 ofs Hf').
                  rewrite <- HpermC_mc_block.1 in HpermF_mcj_data;
                    rewrite <- HpermC_mc_block.2 in HpermF_mcj_locks.
                  erewrite! restrPermMap_Cur in *.
                  erewrite <- StepLemmas.gsoThreadR_suspend
                  with (cntj := pffj) (cntj' := pffj'); eauto.
                }
                { 
                  destruct (valid_block_dec mc'' b1)
                    as [Hvalidmc'' | Hinvalidmc''].
                  
                  specialize (Hpermj_eqF _ _ ofs Hinvalidmc Hvalidmc'' Hf').
                  rewrite Hpermj_eqF.1 Hpermj_eqF.2.
                  specialize (Hpermj_mcj' b1 ofs Hinvalidmc Hvalidmc'').
                  rewrite Hpermj_mcj'.1 Hpermj_mcj'.2.
                  simpl;
                    by constructor.
                  
                  specialize (Hvalidmcj' _ _ pfcj Hinvalidmc Hinvalidmc'' Hf').
                  specialize (Hinverse b1 Hvalidmcj' Hinvalidmc'').
                  simpl in Hinverse.
                  destruct Hinverse as [Hfij _].
                  specialize (HpermF_mcj_data _ _ ofs Hf').
                  specialize (HpermF_mcj_locks _ _ ofs Hf').
                  specialize (Hpermmcj_F_data _ _ ofs Hf').
                  specialize (Hpermmcj_F_locks _ _ ofs Hf').
                  replace (permission_at (restrPermMap (fst (compat_th _ _ memCompF' pffj'))) b2 ofs Cur)
                  with ((getThreadR pffj').1 # b2 ofs)
                    by (rewrite restrPermMap_Cur; reflexivity).
                  replace (permission_at (restrPermMap (snd (compat_th _ _ memCompF' pffj'))) b2 ofs Cur)
                  with ((getThreadR pffj').2 # b2 ofs)
                    by (rewrite restrPermMap_Cur; reflexivity).
                  erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffj) (cntj' := pffj'); eauto.
                  replace ((getThreadR pffj).1 # b2 ofs) with
                  (permission_at (restrPermMap (fst (compat_th _ _ (mem_compf Hsim) pffj))) b2 ofs Cur)
                    by (rewrite restrPermMap_Cur; reflexivity).
                  replace ((getThreadR pffj).2 # b2 ofs) with
                  (permission_at (restrPermMap (snd (compat_th _ _ (mem_compf Hsim) pffj))) b2 ofs Cur)
                    by (rewrite restrPermMap_Cur; reflexivity).
                  specialize (Hpermmcj_mcj' _ _ ofs Hfij).
                  rewrite <- Hpermmcj_mcj'.1; rewrite <- Hpermmcj_mcj'.2;
                    by auto.
                }
              }

              assert (Hstrong_perm_eq: forall b1 b2 ofs
                                         (Hrenaming: (if is_left (valid_block_dec mc b1)
                                                      then f b1
                                                      else
                                                        if is_left (valid_block_dec mc'' b1)
                                                        then fp i pfc b1
                                                        else
                                                          fp j pfcj
                                                             (Z.to_pos
                                                                match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                                                | 0%Z => Z.pos b1
                                                                | Z.pos y' => Z.pos (b1 + y')
                                                                | Z.neg y' => Z.pos_sub b1 y'
                                                                end)) = Some b2),
                         permission_at (restrPermMap (compat_th _ _  memCompF' pffj').1) b2 ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).1) b1 ofs Cur /\
                         permission_at (restrPermMap (compat_th _ _ memCompF'  pffj').2) b2 ofs Cur =
                         permission_at (restrPermMap (compat_th _ _ Hcompij pfij).2) b1 ofs Cur).
              { intros b1 b2 ofs Hf'.
                                rewrite! restrPermMap_Cur.
                erewrite <- StepLemmas.gsoThreadR_suspend
                with (cntj := pffj) (cntj' := pffj'); eauto.
                rewrite <- restrPermMap_Cur with (Hlt := (compat_th _ _ (mem_compf Hsim) pffj).1).
                rewrite <- restrPermMap_Cur with (Hlt := (compat_th _ _ (mem_compf Hsim) pffj).2).
                destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
                - 
                  specialize (HpermC_mc_block _ ofs Hvalidmc).
                  apply Hincrj in Hf'.
                  specialize (Hpermmcj_F_data _ _ ofs Hf').
                  specialize (Hpermmcj_F_locks _ _ ofs Hf').
                  rewrite <- HpermC_mc_block.1 in Hpermmcj_F_data.
                  rewrite <- HpermC_mc_block.2 in Hpermmcj_F_locks.
                  rewrite Hpermmcj_F_data Hpermmcj_F_locks.
                  rewrite! restrPermMap_Cur; auto.
                - destruct (valid_block_dec mc'' b1)
                    as [Hvalidmc'' | Hinvalidmc''].
                  + 
                    specialize (Hpermj_mcj' _ ofs Hinvalidmc Hvalidmc'').
                    rewrite! restrPermMap_Cur in Hpermj_mcj'.
                    rewrite Hpermj_mcj'.1 Hpermj_mcj'.2.
                    simpl in Hf'.
                    apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc.
                    rewrite! restrPermMap_Cur;
                      by eauto.
                  + specialize (Hvalidmcj' _ _ _ Hinvalidmc Hinvalidmc'' Hf').
                    specialize (Hinverse b1 Hvalidmcj' Hinvalidmc'').
                    simpl in Hinverse.
                    destruct Hinverse as [Hfij _].
                    specialize (Hpermmcj_mcj' _ _ ofs Hfij).
                    simpl in Hf'.
                    rewrite <- restrPermMap_Cur with (Hlt := (compat_th _ _ Hcompij pfij).1).
                    rewrite <- restrPermMap_Cur with (Hlt := (compat_th _ _ Hcompij pfij).2).
                    rewrite <- Hpermmcj_mcj'.1, <- Hpermmcj_mcj'.2;
                      by eauto.
              }

              assert (Hval_obs_eq:   forall (b1 b2 : block) (ofs : Z),
                         (if is_left (valid_block_dec mc b1)
                          then f b1
                          else
                            if is_left (valid_block_dec mc'' b1)
                            then fp i pfc b1
                            else
                              fp j pfcj
                                 (Z.to_pos
                                    match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                    | 0%Z => Z.pos b1
                                    | Z.pos y' => Z.pos (b1 + y')
                                    | Z.neg y' => Z.pos_sub b1 y'
                                    end)) = Some b2 ->
                         (Mem.perm (restrPermMap (fst (compat_th _ _ Hcompij pfij))) b1 ofs Cur Readable \/
                          Mem.perm (restrPermMap (snd (compat_th _ _ Hcompij pfij))) b1 ofs Cur Readable) ->
                         memval_obs_eq
                           (fun b0 : block =>
                              if is_left (valid_block_dec mc b0)
                              then f b0
                              else
                                if is_left (valid_block_dec mc'' b0)
                                then fp i pfc b0
                                else
                                  fp j pfcj
                                     (Z.to_pos
                                        match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                        | 0%Z => Z.pos b0
                                        | Z.pos y' => Z.pos (b0 + y')
                                        | Z.neg y' => Z.pos_sub b0 y'
                                        end)) (ZMap.get ofs (Mem.mem_contents mcj') # b1)
                                                        (ZMap.get ofs (Mem.mem_contents mf) # b2)).
                { intros b1 b2 ofs Hf' Hreadable.
                  simpl.
                  assert (Hvalmcj_mcj'_data := val_obs_eq (strong_obs_eq (obs_eq_data Hsimij)));
                    simpl in Hvalmcj_mcj'_data.
                  assert (Hvalmcj_mcj'_locks := val_obs_eq (strong_obs_eq (obs_eq_locks Hsimij)));
                    simpl in Hvalmcj_mcj'_locks.
                  assert (Hvalmcj_mf_data := (val_obs_eq (strong_obs_eq (obs_eq_data Htsimj))));
                    simpl in Hvalmcj_mf_data.
                  assert (Hvalmcj_mf_locks := (val_obs_eq (strong_obs_eq (obs_eq_locks Htsimj))));
                    simpl in Hvalmcj_mf_locks.
                  destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc] eqn:Hvalidmcdec.
                - 
                                    assert (Hincr'_b1 := Hincr' b1 b1 ltac:(eapply id_ren_validblock; eauto)).
                  apply Hincrj in Hf'.

                  assert (Hvalmcj_mcj'_b1_data := Hvalmcj_mcj'_data _ _ ofs Hincr'_b1).
                  assert (Hvalmcj_mcj'_b1_locks := Hvalmcj_mcj'_locks _ _ ofs Hincr'_b1).
                  assert (Hvalmcj_mf_b1_data := Hvalmcj_mf_data _ _ ofs Hf').
                  assert (Hvalmcj_mf_b1_locks := Hvalmcj_mf_locks _ _ ofs Hf').
                  unfold Mem.perm in Hreadable, Hvalmcj_mcj'_b1_data, Hvalmcj_mcj'_b1_locks,
                                     Hvalmcj_mf_b1_data, Hvalmcj_mf_b1_locks.
                  destruct (Hpermmcj_mcj' _ _ ofs Hincr'_b1) as [Hreadable'_data Hreadable'_locks].
                  unfold permission_at in *.
                  rewrite <- Hreadable'_data, <- Hreadable'_locks in Hreadable.
                  assert (Hvalmcj_mf_b1:  memval_obs_eq (fp j pfcj)
                                                        (ZMap.get ofs (Mem.mem_contents mcj) # b1)
                                                        (ZMap.get ofs (Mem.mem_contents mf) # b2))
                    by (destruct Hreadable as [Hreadable | Hreadable]; eauto).
                  assert (Hvalmcj_mcj'_b1: memval_obs_eq fij
                                                         (ZMap.get ofs (Mem.mem_contents mcj) # b1)
                                                         (ZMap.get ofs (Mem.mem_contents mcj') # b1))
                    by (destruct Hreadable as [Hreadable | Hreadable]; eauto).

                  inversion Hvalmcj_mcj'_b1 as
                      [n Hn_mcj Hn_mcj' | vj vj' q1 n Hval_obsjj' Hvj Hvj'
                       | Hundef_mcj Hmv_mcj'].
                  + rewrite <- Hn_mcj in Hvalmcj_mf_b1.
                    inversion Hvalmcj_mf_b1 as [n0 Heq Hn_mf| |];
                      first by constructor.
                  + 
                    rewrite <- Hvj in Hvalmcj_mf_b1.
                    inversion Hvalmcj_mf_b1 as [| vj0 vf q n0 Hval_obsjf Hvj0 Hvf |];
                      subst vj0 q1 n0.
                    constructor.
                    inversion Hval_obsjj' as [| | | | bpj1 bpj'2 ofsp Hfijp|]; subst;
                    inversion Hval_obsjf as [| | | | bpj0 bpf2 ofspf Hf'p|];
                    try subst bpj0; subst; try by constructor.
                    clear Hval_obsjf Hval_obsjj' Hvf Hvj.
                    constructor.
                    destruct (valid_block_dec mc bpj1) as [Hvalidmcbpj1 | Hinvalidmcbpj1]
                                                            eqn:Hdecbpj1.
                    { assert (Hincr'_bpj1 := Hincr' bpj1 bpj1 ltac:(eapply id_ren_validblock; eauto)).
                      rewrite Hincr'_bpj1 in Hfijp; inversion Hfijp; subst bpj'2.
                      rewrite Hdecbpj1.
                      clear Hfijp Hdecbpj1.
                      simpl.
                      apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalidmcbpj1.
                      destruct Hvalidmcbpj1 as [b2' Hf].
                      assert (b2' = bpf2)
                        by (apply Hincrj in Hf; rewrite Hf in Hf'p; by inversion Hf'p);
                        by subst.
                    }
                    { 
                      unfold inject_separated in Hsep.
                      specialize (Hsep bpj1 bpj'2
                                       ltac:(eapply id_ren_invalidblock; eauto) Hfijp).
                      destruct Hsep as [_ Hinvalidmc''bpj'2].
                      assert (Hinvalidbmcpj'2: ~ Mem.valid_block mc bpj'2).
                      { intros Hcontra.
                        eapply internal_execution_valid with
                        (b := bpj'2) (m' := mc'') in Hcontra;
                          by eauto.
                      }
                      destruct (valid_block_dec mc bpj'2) as
                          [Hvalidmcbpj'2 | Hinvalidmcbpj'2];
                        first (by exfalso; auto).
                      simpl.
                      destruct (valid_block_dec mc'' bpj'2) as [? | ?];
                        first by (exfalso; auto).
                      simpl.
                      destruct (valid_block_dec mcj' bpj'2) as [Hvalidmcj'bpj'2 | Hcontra].
                      specialize (Hinverse _ Hvalidmcj'bpj'2 Hinvalidmc''bpj'2).
                      simpl in Hinverse.
                      destruct Hinverse as [Hfij0 Hfid0].
                      clear HpermC_mc_block HpermF_mcj_data HpermF_mcj_locks
                            Hpermmcj_F_data Hpermmcj_F_locks Hpermj_mc'' Hreadable'_data
                            Hreadable'_locks Hreadable Hpermmcj_mcj' Hpermj_eqF Hvj'.
                      clear Hdecbpj1.
                      apply (domain_invalid (weak_obs_eq (obs_eq_data Hsim_c_ci)))
                        in Hinvalidmcbpj1.
                      assert (Hinj := injective (weak_obs_eq (obs_eq_data Hsimij))).
                      specialize (Hinj _ _ _ Hfij0 Hfijp).
                      subst bpj1;
                        by assumption.
                      apply (codomain_valid (weak_obs_eq (obs_eq_data Hsimij))) in Hfijp.
                      erewrite restrPermMap_valid in Hfijp;
                        by exfalso.
                    }
                  + rewrite <- Hundef_mcj in Hvalmcj_mf_b1.
                    inversion Hvalmcj_mf_b1;
                      by constructor.
                - 
                  destruct (valid_block_dec mc'' b1) as [Hvalidmc'' | Hinvalidmc''].
                  destruct (Hpermj_mcj' _ ofs Hinvalidmc Hvalidmc'')
                           as [Hreadable_data Hreadable_locks].
                  unfold Mem.perm in Hreadable.
                  unfold permission_at in Hreadable_data, Hreadable_locks.
                  rewrite Hreadable_data Hreadable_locks in Hreadable.
                  simpl in Hreadable; destruct Hreadable;
                    by exfalso.
                  specialize (Hvalidmcj' _ _ _ Hinvalidmc Hinvalidmc'' Hf').
                  assert (Hinverse_b1 := Hinverse _ Hvalidmcj' Hinvalidmc'').
                  simpl in Hinverse_b1.
                  destruct Hinverse_b1 as [Hfij _].
                  assert (Hpermeq := Hpermmcj_mcj' _ _ ofs Hfij).
                  simpl in Hf'.
                  assert (Hmem_val_obs_eq:
                            memval_obs_eq fij (ZMap.get ofs (Mem.mem_contents mcj) #
                                                        (Z.to_pos
                                                           match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                                           | 0%Z => Z.pos b1
                                                           | Z.pos y' => Z.pos (b1 + y')
                                                           | Z.neg y' => Z.pos_sub b1 y'
                                                           end)) (ZMap.get ofs (Mem.mem_contents mcj') # b1) /\
                            memval_obs_eq (fp j pfcj) (ZMap.get ofs (Mem.mem_contents mcj) #
                                                                (Z.to_pos
                                                                   match (- Z.pos_sub (Mem.nextblock mc'') (Mem.nextblock mc))%Z with
                                                                   | 0%Z => Z.pos b1
                                                                   | Z.pos y' => Z.pos (b1 + y')
                                                                   | Z.neg y' => Z.pos_sub b1 y'
                                                                   end)) (ZMap.get ofs (Mem.mem_contents mf) # b2)).
                  { assert (Hreadable': Mem.perm (restrPermMap (compat_th _ _ Hcompjj pfcjj).1)
                                                 ((Z.to_pos
                                                     match
                                                       (- Z.pos_sub (Mem.nextblock mc'')
                                                                    (Mem.nextblock mc))%Z
                                                     with
                                                     | 0%Z => Z.pos b1
                                                     | Z.pos y' => Z.pos (b1 + y')
                                                     | Z.neg y' => Z.pos_sub b1 y'
                                                     end)) ofs Cur Readable \/
                                        Mem.perm (restrPermMap (compat_th _ _ Hcompjj pfcjj).2)
                                                 ((Z.to_pos
                                                     match
                                                       (- Z.pos_sub (Mem.nextblock mc'')
                                                                    (Mem.nextblock mc))%Z
                                                     with
                                                     | 0%Z => Z.pos b1
                                                     | Z.pos y' => Z.pos (b1 + y')
                                                     | Z.neg y' => Z.pos_sub b1 y'
                                                     end)) ofs Cur Readable)
                      by (unfold Mem.perm in *; unfold permission_at in Hpermeq;
                          rewrite Hpermeq.1 Hpermeq.2; eauto).
                    destruct Hreadable' as [Hreadable' | Hreadable'];
                    [specialize (Hvalmcj_mcj'_data _ _ ofs Hfij Hreadable');
                     specialize (Hvalmcj_mf_data _ _ ofs Hf' Hreadable') |
                     specialize (Hvalmcj_mcj'_locks _ _ ofs Hfij Hreadable');
                     specialize (Hvalmcj_mf_locks _ _ ofs Hf' Hreadable')]; eauto.
                  }
                  clear Hreadable Hpermeq Hpermmcj_mcj' Hpermj_eqF Hpermj_mcj'
                  Hpermj_mc'' Hpermmcj_F_data Hpermmcj_F_locks HpermF_mcj_data HpermF_mcj_locks HpermC_mc_block.
                  destruct Hmem_val_obs_eq as [Hvalmcj_mcj' Hvalmcj_mf].
                  inversion Hvalmcj_mcj' as
                      [n Hn_mcj Hn_mcj' | vj vj' q1 n Hval_obsjj' Hvj Hvj'| Hundef_mcj Hmv_mcj'].
                  + rewrite <- Hn_mcj in Hvalmcj_mf.
                    inversion Hvalmcj_mf as [n0 Heq Hn_mf| |];
                      first by constructor.
                  + 
                    rewrite <- Hvj in Hvalmcj_mf.
                    inversion Hvalmcj_mf as [| vj0 vf q n0 Hval_obsjf Hvj0 Hvf |];
                      subst vj0 q1 n0.
                    constructor.
                    inversion Hval_obsjj' as [| | | | bpj1 bpj'2 ofsp Hfijp|]; subst;
                    inversion Hval_obsjf as [| | | | bpj0 bpf2 ofspf Hf'p|];
                    try subst bpj0; subst; try by constructor.
                    clear Hval_obsjf Hval_obsjj' Hvf Hvj.
                    constructor.
                    destruct (valid_block_dec mc bpj1) as [Hvalidmcbpj1 | Hinvalidmcbpj1]
                                                            eqn:Hdecbpj1.
                    { assert (Hincr'_bpj1 := Hincr' bpj1 bpj1
                                                    ltac:(eapply id_ren_validblock; eauto)).
                      rewrite Hincr'_bpj1 in Hfijp; inversion Hfijp; subst bpj'2.
                      rewrite Hdecbpj1.
                      clear Hfijp Hdecbpj1.
                      simpl.
                      apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalidmcbpj1.
                      destruct Hvalidmcbpj1 as [b2' Hf].
                      assert (b2' = bpf2)
                        by (apply Hincrj in Hf; rewrite Hf in Hf'p; by inversion Hf'p);
                        by subst.
                    }
                    { 
                      unfold inject_separated in Hsep.
                      specialize (Hsep bpj1 bpj'2
                                       ltac:(eapply id_ren_invalidblock; eauto) Hfijp).
                      destruct Hsep as [_ Hinvalidmc''bpj'2].
                      assert (Hinvalidbmcpj'2: ~ Mem.valid_block mc bpj'2).
                      { intros Hcontra.
                        eapply internal_execution_valid with
                        (b := bpj'2) (m' := mc'') in Hcontra;
                          by eauto.
                      }
                      destruct (valid_block_dec mc bpj'2) as
                          [Hvalidmcbpj'2 | Hinvalidmcbpj'2];
                        first (by exfalso; auto).
                      destruct (valid_block_dec mc'' bpj'2) as [? | ?];
                        first by (exfalso; auto).
                      destruct (valid_block_dec mcj' bpj'2) as [Hvalidmcj'bpj'2 | Hcontra].
                      simpl.
                      specialize (Hinverse _ Hvalidmcj'bpj'2 Hinvalidmc''bpj'2).
                      simpl in Hinverse.
                      destruct Hinverse as [Hfij0' Hfid0'].
                                            clear Hdecbpj1.
                      apply (domain_invalid (weak_obs_eq (obs_eq_data Hsim_c_ci)))
                        in Hinvalidmcbpj1.
                      assert (Hinj := injective (weak_obs_eq (obs_eq_data Hsimij))).
                      specialize (Hinj _ _ _  Hfij0' Hfijp).
                      subst bpj1;
                        by assumption.
                      apply (codomain_valid (weak_obs_eq (obs_eq_data Hsimij))) in Hfijp.
                      erewrite restrPermMap_valid in Hfijp;
                        by exfalso.
                    }
                  + rewrite <- Hundef_mcj in Hvalmcj_mf.
                    inversion Hvalmcj_mf.
                      by constructor.
                }
                constructor.
            - 
              assert (Hctlij := code_eq Hsimij).
              assert (Hctljj := code_eq Htsimj).
              erewrite <- StepLemmas.gsoThreadC_suspend with (cntj := pffj) (cntj' := pffj');
                eauto.
              eapply ctl_inj_trans with (c:= getThreadC pfcjj); eauto.
              
              intros b b' b'' Hfpj Hfij.
              destruct (valid_block_dec mc b'); simpl.
              assert (Hfid := (domain_valid (weak_obs_eq (obs_eq_data Hsim_c_ci))) _ v).
              destruct Hfid as [b2' Hfid].
              assert (b' = b2')
                by (apply id_ren_correct in Hfid; auto); subst b2'.
              apply Hincr' in Hfid.
              assert (b = b')
                by (eapply (injective (weak_obs_eq (obs_eq_data Hsimij))); eauto);
                subst.
              apply (domain_valid (weak_tsim_data HsimWeak)) in v.
              destruct v as [b2' Hf].
              assert (b2' = b'')
                by ( apply Hincrj in Hf;
                     rewrite Hf in Hfpj; by inversion Hfpj);
                by subst b2'.
              destruct (valid_block_dec mc'' b').
              destruct (valid_block_dec mc b) eqn:dec_mc_b.
              assert (v0' := v0).
              apply (domain_valid (weak_obs_eq (obs_eq_data Hsim_c_ci))) in v0'.
              destruct v0' as [b2' Hid].
              assert (b = b2')
                by (apply id_ren_correct in Hid; auto); subst b2'.
              apply Hincr' in Hid. rewrite Hfij in Hid.
              inversion Hid; subst;
                by exfalso.
              clear dec_mc_b.
              apply (domain_invalid (weak_obs_eq (obs_eq_data Hsim_c_ci))) in n0.
              specialize (Hsep _ _ n0 Hfij).
              destruct Hsep as [? ?];
                by exfalso.
              destruct (valid_block_dec mc b) as [Hcontra | ?].
              assert (Hfid :=
                        (domain_valid (weak_obs_eq (obs_eq_data Hsim_c_ci))) _ Hcontra).
              destruct Hfid as [b2' Hfid].
              assert (b = b2')
                by (apply id_ren_correct in Hfid; auto); subst b2'.
              apply Hincr' in Hfid. rewrite Hfij in Hfid.
              inversion Hfid; subst;
                by exfalso.
              assert (Hvalidb': Mem.valid_block mcj' b')
                by ( apply (codomain_valid (weak_obs_eq (obs_eq_data Hsimij))) in Hfij;
                       by erewrite restrPermMap_valid in Hfij).
              specialize (Hinverse _ Hvalidb' n0).
              simpl in Hinverse.
              destruct Hinverse as [Hfij' Hg].
              assert (Hinj := injective (weak_obs_eq (obs_eq_data Hsimij))).
              assert (b = Z.to_pos
                            match
                              (- Z.pos_sub (Mem.nextblock mc'')
                                           (Mem.nextblock mc))%Z
                            with
                            | 0%Z => Z.pos b'
                            | Z.pos y' => Z.pos (b' + y')
                            | Z.neg y' => Z.pos_sub b' y'
                            end)
                by (eapply Hinj; eauto;
                    assert (Hfid_domain:= iffLRn (id_ren_domain mc b) n1);
                    subst b; eauto);
                by subst.
            - 
              do 2 constructor; intros; eauto.
              erewrite restrPermMap_valid; eauto.
              now eapply ((Hperm_weak _ _ ofs Hrenaming).1).
              now eapply (Hstrong_perm_eq _ _ ofs Hrenaming).1.
            - do 2 constructor; intros; eauto.
              erewrite restrPermMap_valid; eauto.
              now eapply ((Hperm_weak _ _ ofs Hrenaming).2).
              now eapply (Hstrong_perm_eq _ _ ofs Hrenaming).2.
          }
          split.
          { 
            intros k pffk' Hjk b1 b2 ofs Hf' Hfi.
            destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
            - 
              simpl in Hf'.
              apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalidmc.
              destruct Hvalidmc as [? Hf].
              apply Hincr in Hf. by congruence.
            - destruct (valid_block_dec mc'' b1) as [Hvalidmc'' | Hinvalidmc''];
              first by (simpl in Hf'; congruence).
              specialize (Hvalidmcj' _ _ _ Hinvalidmc Hinvalidmc'' Hf').
              destruct (Hinverse _ Hvalidmcj' Hinvalidmc'') as [Hfij ?].
              unfold inject_separated in Hsep.
              specialize (Hsep _ _ H Hfij).
              destruct Hsep as [Hinvalidb0 _].
              apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidb0.
              assert (pffk: containsThread tpf k)
                by (eapply StepLemmas.suspend_containsThread with (cnti := pff); eauto).
              specialize (Hownedj _ pffk Hjk _ _ ofs Hf' Hinvalidb0).
              erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffk);
                by eauto.
          }
          split.
          { 
            intros bl ofsl rmap b1 b2 ofs Hf' Hfi Hres.
            destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
            - 
              simpl in Hf'.
              apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalidmc.
              destruct Hvalidmc as [? Hf].
              apply Hincr in Hf. by congruence.
            - destruct (valid_block_dec mc'' b1) as [Hvalidmc'' | Hinvalidmc''];
              first by (simpl in Hf'; congruence).
              specialize (Hvalidmcj' _ _ _ Hinvalidmc Hinvalidmc'' Hf').
              destruct (Hinverse _ Hvalidmcj' Hinvalidmc'') as [Hfij Hfinv].
              unfold inject_separated in Hsep.
              specialize (Hsep _ _ Hfinv Hfij).
              destruct Hsep as [Hinvalidb0 _].
              apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidb0.
              simpl in Hf'.
              erewrite <- StepLemmas.suspend_lockPool with (tp := tpf) in Hres;
                eauto.
          }
          { intros b2 Hf ofs.
            erewrite <- StepLemmas.gsoThreadR_suspend with (cntj := pffj); eauto.
            assert  (Hmappedi: (exists b1, fp j pfcj b1 = Some b2) \/ ~exists b1, fp j pfcj b1 = Some b2) by (eapply em; eauto).
            
            destruct Hmappedi as [Hfj | Hfj].
            - destruct Hfj as [b1 Hfj].
              
              exfalso.
              apply Hf.
              destruct (valid_block_dec mc b1).
              + 
                exists b1.
                erewrite if_true by (by apply/Coqlib.proj_sumbool_is_true).
                apply (domain_valid (weak_tsim_data HsimWeak)) in v.
                destruct v as [b2' Hf0].
                assert (b2 = b2') by (apply Hincrj in Hf0; rewrite Hf0 in Hfj; inversion Hfj; by subst).
                subst; auto.
              + 
                apply Pos.le_lteq in Hle.
                destruct Hle as [Hlt | Heq].
                * rewrite Z.pos_sub_opp.
                  erewrite Z.pos_sub_lt by eauto.
                  
                  exists (b1 + (Mem.nextblock mc'' - Mem.nextblock mc))%positive.
                  erewrite if_false
                    by (apply negbT;
                        eapply proj_sumbool_is_false;
                        intros Hcontra;
                        clear - Hcontra Hlt n;
                        unfold Mem.valid_block, Coqlib.Plt in *; zify; omega).
                  erewrite if_false
                    by (apply negbT;
                        eapply proj_sumbool_is_false;
                        intros Hcontra;
                        clear - Hcontra Hlt n;
                        unfold Mem.valid_block, Coqlib.Plt in *;
                        zify;
                        destruct H2 as [[? ?] | [? ?]];
                        subst;
                        omega).
                  erewrite Z.pos_sub_gt by (zify; omega).
                  rewrite Pos.add_sub.
                  simpl.
                  assumption.
                * rewrite Heq.
                  rewrite Z.pos_sub_diag. simpl.
                  exists b1.
                  erewrite! if_false by
                      (apply negbT; apply proj_sumbool_is_false;
                       unfold Mem.valid_block in *;
                       auto; try (rewrite <- Heq; auto)).
                  assumption.
            - 
              apply Hunmappedj; auto.
            }
        }
      }
      { 
        clear - HstepF Hexec HsuspendC HsimRes Hincr Htsim
                       HsimWeak Hownedi_lp semAxioms.
        destruct HsimRes as [HsimRes [Hlock_mapped Hlock_if]].
        split.
        - intros bl1 bl2 ofs rmap1 rmap2 Hfl Hl1'' Hl2'.
          
          assert (Hl1: lockRes tpc (bl1,ofs) = Some rmap1)
            by (erewrite <- @StepLemmas.suspend_lockPool with (pfc := pfc') in Hl1''; eauto;
                erewrite <- gsoLockPool_execution in Hl1''; eauto).

          assert (Hl2: lockRes tpf (bl2,ofs) = Some rmap2)
            by (erewrite <- @StepLemmas.suspend_lockPool with (pfc := pff) in Hl2'; eauto).

          assert (pff': containsThread tpf' i)
            by (eapply StepLemmas.suspend_containsThread with (cnti := pff); eauto).

          assert (Hperm_eq: forall b ofs,
                     permission_at (restrPermMap (compat_lp _ _ memCompC'' _ _ Hl1'').1) b ofs Cur =
                     permission_at (restrPermMap (compat_lp _ _ HmemCompC _ _ Hl1).1) b ofs Cur /\
                     permission_at (restrPermMap (compat_lp _ _ memCompC'' _ _ Hl1'').2) b ofs Cur =
                     permission_at (restrPermMap (compat_lp _ _ HmemCompC _ _ Hl1).2) b ofs Cur)
            by (intros; split; by rewrite! restrPermMap_Cur).

          assert (Hvalid: Mem.valid_block mc (bl1, ofs).1)
            by (eapply (lockRes_blocks _ _ HmemCompC); eauto).
          specialize (HsimWeak _ pfc pff).
          apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalid.
          destruct Hvalid as [bl2' Hfl0].
          assert (bl2 = bl2')
            by (apply Hincr in Hfl0; rewrite Hfl in Hfl0; by inversion Hfl0); subst.

          specialize (HsimRes _ _ _ _ _ Hfl0 Hl1 Hl2).
          destruct HsimRes as [HsimRes_data HsimRes_locks].
          destruct HsimRes_data as [HpermRes_data HvalRes_data].
          destruct HsimRes_locks as [HpermRes_locks HvalRes_locks].
          assert (Hperm_strong:
                    forall (b1 b2 : block) (ofs0 : Z),
                      fp i pfc b1 = Some b2 ->
                      permission_at (restrPermMap (compat_lp _ _ memCompF' (bl2', ofs) _ Hl2')#1) b2 ofs0 Cur =
                      permission_at (restrPermMap (compat_lp _ _ memCompC'' (bl1, ofs) _ Hl1'')#1) b1 ofs0 Cur /\
                      permission_at (restrPermMap (compat_lp _ _ memCompF' (bl2', ofs) _ Hl2')#2) b2 ofs0 Cur =
                      permission_at (restrPermMap (compat_lp _ _ memCompC'' (bl1, ofs) _ Hl1'')#2) b1 ofs0 Cur).
          { intros b1 b2 ofs0 Hf1.
            specialize (Hperm_eq b1 ofs0).
            rewrite Hperm_eq.1 Hperm_eq.2.

            rewrite! restrPermMap_Cur.
            destruct (valid_block_dec mc b1) as [Hvalid | Hinvalid].
            - apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalid.
              destruct Hvalid as [b2' Hf].
              assert (b2' = b2)
                by (apply Hincr in Hf; rewrite Hf in Hf1; by inversion Hf1);
                subst b2'.
              specialize (HpermRes_data _ _ ofs0 Hf);
                specialize (HpermRes_locks _ _ ofs0 Hf);
                  by rewrite! restrPermMap_Cur in HpermRes_locks HpermRes_data.
            - assert (Hempty:= Mem.nextblock_noaccess _ _ ofs0 Max Hinvalid).
              assert (Hlt1:= ((compat_lp _ _ HmemCompC _ _ Hl1).1 b1 ofs0)).
              assert (Hlt2:= ((compat_lp _ _ HmemCompC _ _ Hl1).2 b1 ofs0)).
              rewrite getMaxPerm_correct in Hlt1 Hlt2. unfold permission_at in Hlt1, Hlt2.
              rewrite Hempty in Hlt1 Hlt2. simpl in Hlt1, Hlt2.
              destruct (rmap1.1 # b1 ofs0);
                first by exfalso.
              destruct (rmap1.2 # b1 ofs0);
                first by exfalso.
              apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalid.
              eapply Hownedi_lp;
                by eauto.
          }

          assert (Hval_obs_eq:
                    forall (b1 b2 : block) (ofs0 : Z),
                      fp i pfc b1 = Some b2 ->
                      (Mem.perm (restrPermMap (proj1 (compat_lp _ _ memCompC'' (bl1, ofs) _ Hl1''))) b1 ofs0 Cur Readable \/
                      Mem.perm (restrPermMap (proj2 (compat_lp _ _ memCompC'' (bl1, ofs) _ Hl1''))) b1 ofs0 Cur Readable) ->
                      memval_obs_eq (fp i pfc) (ZMap.get ofs0 (Mem.mem_contents mc'') # b1) (ZMap.get ofs0 (Mem.mem_contents mf) # b2)).
          { intros b1 b2 ofs0 Hfi Hperm.
            simpl.
            unfold Mem.perm in *.
            unfold permission_at in Hperm_eq.
            rewrite (Hperm_eq b1 ofs0).1 in Hperm.
            rewrite (Hperm_eq b1 ofs0).2 in Hperm.
            destruct (valid_block_dec mc b1) as [Hvalidmc | Hinvalidmc].
            - apply (domain_valid (weak_tsim_data HsimWeak)) in Hvalidmc.
              destruct Hvalidmc as [b2' Hf].
              assert (b2 = b2')
                by (apply Hincr in Hf; rewrite Hfi in Hf; by inversion Hf);
                subst b2'.
              erewrite <- internal_exec_disjoint_val_lockPool with (m := mc) (tp := tpc);
                unfold Mem.perm; eauto.
              assert (HvalRes: memval_obs_eq f (ZMap.get ofs0 (Mem.mem_contents mc) # b1) (ZMap.get ofs0 (Mem.mem_contents mf) # b2)).
              { destruct Hperm as [Hperm | Hperm].
                specialize (HvalRes_data _ _ ofs0 Hf Hperm); eauto.
                specialize (HvalRes_locks _ _ _ Hf Hperm); eauto.
              }
              eapply memval_obs_eq_incr;
                by eauto.
            - assert (Hempty:= Mem.nextblock_noaccess _ _ ofs0 Max Hinvalidmc).
              assert (Hlt1:= (compat_lp _ _ HmemCompC _ _ Hl1).1 b1 ofs0).
              assert (Hlt2:= (compat_lp _ _ HmemCompC _ _ Hl1).2 b1 ofs0).
              rewrite getMaxPerm_correct in Hlt1 Hlt2. unfold permission_at in Hlt1, Hlt2.
              rewrite Hempty in Hlt1 Hlt2. simpl in Hlt1, Hlt2.
              apply (domain_invalid (weak_tsim_data HsimWeak)) in Hinvalidmc.
              assert (Hcontra1:= restrPermMap_Cur (compat_lp _ _ HmemCompC _ _ Hl1).1 b1 ofs0).
              assert (Hcontra2:= restrPermMap_Cur (compat_lp _ _ HmemCompC _ _ Hl1).2 b1 ofs0).
              unfold permission_at in Hcontra1, Hcontra2. rewrite Hcontra1 Hcontra2 in Hperm.
              destruct (rmap1.1 # b1 ofs0);
                try by (simpl in Hperm; exfalso).
              destruct (rmap1.2 # b1 ofs0);
                try by (simpl in Hperm; exfalso).
              destruct Hperm as [Hperm | Hperm];
                by inversion Hperm.
          }
          split; constructor;
            intros; destruct (Hperm_strong _ _ ofs0 Hrenaming);
              by eauto.
        - split.
          + 
            intros bl2 ofs Hres.
            erewrite <- StepLemmas.suspend_lockRes with (tp := tpf) in Hres by eauto.
            specialize (Hlock_mapped _ _ Hres).
            destruct Hlock_mapped as [bl1 Hf].
            eapply Hincr in Hf.
            eexists; eauto.
          + 
            intros bl1 bl2 ofs Hf.
            erewrite <- StepLemmas.suspend_lockRes with (tp' := tpf') (tp := tpf) by eauto.
            erewrite <- StepLemmas.suspend_lockPool with (tp := tpc') (tp' := tpc'') by eauto.
            erewrite <- gsoLockPool_execution; eauto.
            specialize (HsimWeak _ pfc pff).
            split; intros Hres.
            eapply Hlock_if; eauto.
            destruct (lockRes tpc (bl1, ofs)) eqn:Hres'; try by exfalso.
            apply (lockRes_blocks _ _ HmemCompC) in Hres'.
            apply (domain_valid (weak_tsim_data HsimWeak)) in Hres'.
            destruct Hres' as [bl2' Hf'].
            assert (bl2 = bl2')
              by (apply Hincr in Hf'; rewrite Hf in Hf';
                  inversion Hf'; subst; auto);
              subst bl2'.
            auto.
            specialize (Hlock_mapped _ _ Hres).
            destruct Hlock_mapped as [bl1' Hf'].
            assert (bl1 = bl1')
              by (apply Hincr in Hf'; eapply (injective ((weak_obs_eq (obs_eq_data Htsim)))); eauto).
            subst.
            eapply Hlock_if; eauto.
      }
      { 
        intros  bl ofsl rmap Hres b2 Hf ofs.
        erewrite <- StepLemmas.suspend_lockRes with (tp := tpf) in Hres by eauto.
        eapply HunmappedRes;
          eauto.
        intros (b1 & Hcontra).
        apply Hincr in Hcontra.
        eapply Hf; by eauto.
      }
      { 
          by eapply @StepLemmas.suspend_invariant with (pff := pff); eauto.
      }
      { 
          by auto.
      }
      { by auto. }
      { eapply suspend_tp_wd;
          by eauto.
      }
      { apply ren_incr_domain_incr in Hincr.
        eapply ge_wd_incr;
          by eauto.
      }
      { split; auto.
      }
      { intros k Hin.
        clear - pfc Hxs Hin Hexec HsuspendC.
        assert (List.In k xs).
        { clear - Hin.
          induction xs; first by simpl in *.
          destruct (a == i) eqn:Heq; move/eqP:Heq=>Heq.
          subst. simpl in *.
          rewrite if_false in Hin; auto.
          do 2 apply/eqP.
          rewrite Bool.negb_true_iff;
            by apply/eqP.
          simpl in *.
          rewrite if_true in Hin; auto.
          simpl in *. destruct Hin; auto.
            by apply/eqP.
        }
        specialize (Hxs k H).
        eapply StepLemmas.suspend_containsThread with (tp := tpc'); eauto.
        eapply containsThread_internal_execution;
          by eauto.
      }
      { rewrite cats0.
        assert (ren_incr f (fp i pfc)).
        auto.
        assert (Hinjective:
                  forall b1 b1' b2,
                    (fp i pfc) b1 = Some b2 ->
                    (fp i pfc) b1' = Some b2 ->
                    b1 = b1')
          by (destruct Htsim';
              destruct obs_eq_data0;
              destruct weak_obs_eq0;
              eauto).
        eapply trace_sim_incr;
          eauto.
      } 
    }
    Unshelve. all: eauto.
    erewrite <- restrPermMap_mem_valid.
    eapply internal_execution_wd; eauto.
    destruct (HsimWeak _ pfc pff).
    erewrite restrPermMap_domain.
    eapply weak_obs_eq_domain_ren;
      eauto.
    eapply ren_incr_domain_incr;
      now eauto.
  Qed.

  Lemma external_step_inverse :
    forall U U' tp tr m tp' tr' m' i (cnti: containsThread tp i)
      (Hcomp: mem_compatible tp m),
      let mrestr := restrPermMap (((compat_th _ _ Hcomp) cnti).1) in
      forall (Hexternal: cnti$mrestr @ E)
        (Hstep: MachStep (i :: U, tr, tp) m (U', tr ++ tr', tp') m'),
        U = U' /\ exists ev, syncStep true cnti Hcomp tp' m' ev /\ tr' = [:: external i ev].
  Proof.
    intros.
    inversion Hstep;
      try inversion Htstep; subst; simpl in *;
        unfold mrestr in *;
        try match goal with
            | [H: Some _ = Some _ |- _] => inversion H; subst
            end; Tactics.pf_cleanup;
          repeat match goal with
                 | [H: getThreadC ?Pf = _, Hext: ?Pf$_ @ E |- _] =>
                   unfold getStepType in Hext;
                     rewrite H in Hext; simpl in Hext
                 | [H: DryHybridMachine.install_perm _ _ _ _ _ _ |- _] =>
                   inversion H; subst
                 | [H: ev_step _ _ _ _ _ _ |- _] =>
                   eapply ev_step_ax1 in H;
                     eapply corestep_not_at_external in Hcorestep;
                     rewrite Hcorestep in Hexternal;
                     destruct Hexternal as [[_ ?]|[? _]]; try discriminate
                 | [H: _ ++ _ = _ ++ _ |- _] =>
                   apply List.app_inv_head in H; subst
                 end; try rewrite Hat_external in Hexternal; try discriminate;
            try (now exfalso; eauto);
            try (now (split; eexists; split; eauto)).
    destruct (at_external semSem c (restrPermMap (proj1 (compat_th _ _ Hcomp cnti))));
      [discriminate|].
    discriminate.
  Qed.
    
  Lemma strong_tsim_store_id:
    forall tp tp' m m' i b ofs v pmap
      (pfi: containsThread tp i)
      (pfi': containsThread tp' i)
      (Hresi: getThreadR pfi' = getThreadR pfi)
      (Hcodei: getThreadC pfi' = getThreadC pfi)
      (Hcomp: mem_compatible tp m)
      (Hcomp': mem_compatible tp' m')
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hno_race: permMapCoherence (getThreadR pfi).1 pmap \/
                 permMapsDisjoint (getThreadR pfi).1 pmap)
      (Hmem_wd: valid_mem m)
      (Htp_wd: tp_wd (id_ren m) tp)
      (Hstore: Mem.store Mint32 (restrPermMap Hlt) b ofs v = Some m'),
      (ctl_inj (id_ren m) (getThreadC pfi) (getThreadC pfi')) /\
      (mem_obs_eq (id_ren m) (restrPermMap (compat_th _ _ Hcomp pfi).1)
                  (restrPermMap ((compat_th _ _ Hcomp' pfi').1))) /\
      (Mem.nextblock m = Mem.nextblock m').
  Proof.
    intros.
    split.
    { 
      rewrite Hcodei.
      specialize (Htp_wd _ pfi).
      destruct (getThreadC pfi); simpl in *;
      repeat match goal with
             | [|- core_inj _ _ _] =>
               apply core_inj_id; auto
             | [H: _ /\ _ |- _] => destruct H
             | [|- _ /\ _] => split
             | [|- val_obs _ _ _] =>
               apply val_obs_id; auto
             end;
      try (apply id_ren_correct).
    }
    split.
    { 
      constructor.
      constructor.
      intros b0 Hinvalid. erewrite restrPermMap_valid in Hinvalid;
        by apply id_ren_invalidblock.
      intros b1 Hvalid. erewrite restrPermMap_valid in Hvalid.
      exists b1;
        by apply id_ren_validblock.
      intros b1 b2 Hf.
      erewrite restrPermMap_valid.
      eapply Mem.store_valid_block_1; eauto.
      erewrite restrPermMap_valid.
      unfold id_ren in Hf.
      destruct (valid_block_dec m b1);
        by [simpl in Hf; inversion Hf; by subst | by exfalso].
      intros b1 b1' b2 Hf1 Hf1'.
      apply id_ren_correct in Hf1.
      apply id_ren_correct in Hf1';
        by subst.
      intros b1 b2 ofs0 Hf.
      do 2 rewrite restrPermMap_Cur.
      rewrite Hresi.
      apply id_ren_correct in Hf; subst;
        by eapply po_refl.
      constructor.
      intros b1 b2 ofs0 Hf.
      do 2 rewrite restrPermMap_Cur.
      rewrite Hresi.
      apply id_ren_correct in Hf;
        by subst.
      intros b1 b2 ofs0 Hf Hperm.
      assert (Hvalid: Mem.valid_block m b1)
        by (assert (Hdomain := id_ren_domain m);
             apply Hdomain;
             by rewrite Hf).
      apply id_ren_correct in Hf; subst.
      simpl.
      destruct (Pos.eq_dec b b2).
      - subst.
        destruct (Intv.In_dec ofs0 (ofs, ofs + size_chunk Mint32)%Z).
        + exfalso.
          apply Mem.store_valid_access_3 in Hstore.
          destruct Hstore as [Hstore _].
          pose proof (restrPermMap_Cur (compat_th _ _ Hcomp pfi).1 b2 ofs0) as Heq_perm.
          unfold permission_at in Heq_perm.
          pose proof (restrPermMap_Cur Hlt b2 ofs0) as Heq_perm_lock.
          specialize (Hstore ofs0 i0).
          unfold permission_at, Mem.perm in *.
          rewrite Heq_perm in Hperm.
          rewrite Heq_perm_lock in Hstore.
          destruct Hno_race as [Hno_race | Hno_race];
          specialize (Hno_race b2 ofs0).
          * destruct ((getThreadR pfi).1 # b2 ofs0) as [p|]; simpl in Hperm; auto;
              inversion Hperm; subst;
                simpl in Hno_race; destruct (pmap # b2 ofs0); auto.
          * eapply perm_order_clash; now eauto.
        + eapply Mem.store_mem_contents in Hstore.
          rewrite Hstore. simpl.
          rewrite Maps.PMap.gss.
          erewrite Mem.setN_outside.
          eapply memval_obs_eq_id; eauto using id_ren_correct.
          specialize (Hmem_wd b2 Hvalid ofs0 _ (Logic.eq_refl _)).
          destruct (Maps.ZMap.get ofs0 (Mem.mem_contents m) # b2);
            auto.
          unfold mem_wd.val_valid in Hmem_wd.
          unfold valid_memval, valid_val.
          destruct v0; eauto.
          exists b.
          apply id_ren_validblock; auto.
          eapply Intv.range_notin in n.
          rewrite encode_val_length. eauto.
          simpl. omega.
      - eapply Mem.store_mem_contents in Hstore.
        rewrite Hstore. simpl.
        erewrite Maps.PMap.gso by eauto.
        eapply memval_obs_eq_id; eauto using id_ren_correct.
          specialize (Hmem_wd b2 Hvalid ofs0 _ (Logic.eq_refl _)).
          destruct (Maps.ZMap.get ofs0 (Mem.mem_contents m) # b2);
            auto.
          unfold mem_wd.val_valid in Hmem_wd.
          unfold valid_memval, valid_val.
          destruct v0; eauto.
          exists b0.
          apply id_ren_validblock; auto.
    }
    { erewrite Mem.nextblock_store with
      (m1 := (restrPermMap Hlt)) (m2 := m');
        by eauto.
    }
  Qed.

  Lemma strong_tsim_id_trans:
    forall (tp1 tp1' tp2 : thread_pool) (m1 m1' m2 : mem)
      (f : memren) i
      (pf1 : containsThread tp1 i)
      (pf1' : containsThread tp1' i)
      (pf2 : containsThread tp2 i)
      (Hcomp1 : mem_compatible tp1 m1)
      (Hcomp1' : mem_compatible tp1' m1')
      (Hcomp2 : mem_compatible tp2 m2)
      (Hvalid: forall b, Mem.valid_block m1 b <-> Mem.valid_block m1' b)
      (Hctl_id: ctl_inj (id_ren m1) (getThreadC pf1) (getThreadC pf1'))
      (Hobs_eq_id: mem_obs_eq (id_ren m1) (restrPermMap (compat_th _ _ Hcomp1 pf1).1)
                              (restrPermMap (compat_th _ _ Hcomp1' pf1').1))
      (Hctl_eq: ctl_inj f (getThreadC pf1) (getThreadC pf2))
      (Hmem_obs_eq: mem_obs_eq f (restrPermMap (compat_th _ _ Hcomp1 pf1).1)
                               (restrPermMap (compat_th _ _ Hcomp2 pf2).1)),
      ctl_inj f (getThreadC pf1') (getThreadC pf2) /\
      mem_obs_eq f (restrPermMap (compat_th _ _ Hcomp1' pf1').1) (restrPermMap (compat_th _ _ Hcomp2 pf2).1).
  Proof.
    intros.
    constructor.
    - destruct (getThreadC pf1'), (getThreadC pf1); simpl in *;
        try (by exfalso);
        destruct (getThreadC pf2); simpl in *; try (by exfalso);
          repeat match goal with
                 | [H: _ /\ _ |- _] =>
                   destruct H
                 | [|- _ /\ _] => split
                 | [|- core_inj _ _ _] =>
                   eapply core_inj_trans; eauto
                 | [|- val_obs _ _ _] =>
                   eapply val_obs_trans; eauto
                 | [|- forall _, _] =>
                   intros b b' b'' Hf Hfid;
                     apply id_ren_correct in Hfid;
                     subst
                 end; subst; auto.
    - destruct Hmem_obs_eq. destruct weak_obs_eq0.
      destruct Hobs_eq_id as [weak_obs_eq_id strong_obs_eq_id].
      destruct strong_obs_eq_id as [Hperm_id Hval_id].
      destruct weak_obs_eq_id.
      assert (Hinvalid: forall b, ~ Mem.valid_block m1 b <-> ~Mem.valid_block m1' b)
        by (intros b; specialize (Hvalid b); destruct Hvalid;
            split; intros; intro Hcontra; eauto).
      constructor.
      + constructor; eauto.
        intros b Hb.
        erewrite restrPermMap_valid in Hb.
        apply Hinvalid in Hb;
          by auto.
        intros b Hb.
        erewrite restrPermMap_valid in Hb.
        apply Hvalid in Hb;
          by auto.
        intros b1 b2 ofs Hf.
        specialize (perm_obs_weak0 _ _ ofs Hf).
        assert (Hb1: Mem.valid_block m1 b1)
          by (destruct (valid_block_dec m1 b1) as [? | Hcontra]; auto;
              apply domain_invalid0 in Hcontra;
                by congruence).
        apply domain_valid1 in Hb1.
        destruct Hb1 as [b2' Hfid].
        assert (b1 = b2')
          by (apply id_ren_correct in Hfid; by subst);
          subst b2'.
        specialize (Hperm_id _ _ ofs Hfid).
        rewrite Hperm_id;
          by auto.
      + destruct strong_obs_eq0.
        constructor.
        * intros b1 b2 ofs Hf.
          specialize (perm_obs_strong0 _ _ ofs Hf).
          assert (Hb1: Mem.valid_block m1 b1)
            by (destruct (valid_block_dec m1 b1) as [? | Hcontra]; auto;
                apply domain_invalid0 in Hcontra;
                  by congruence).
          apply domain_valid1 in Hb1.
          destruct Hb1 as [b2' Hfid].
          assert (b1 = b2')
            by (apply id_ren_correct in Hfid; by subst);
            subst b2'.
          specialize (Hperm_id _ _ ofs Hfid).
          rewrite Hperm_id;
            by auto.
        *  intros b1 b2 ofs Hf Hperm.
           clear - Hperm Hf val_obs_eq0 domain_invalid0 Hval_id
                         Hperm_id domain_valid1.
           assert (Hb1: Mem.valid_block m1 b1)
             by (destruct (valid_block_dec m1 b1) as [? | Hcontra]; auto;
                 apply domain_invalid0 in Hcontra;
                   by congruence).
           apply domain_valid1 in Hb1.
           destruct Hb1 as [b2' Hfid].
           assert (b1 = b2')
             by (apply id_ren_correct in Hfid; by subst);
             subst b2'.
           specialize (Hperm_id _ _ ofs Hfid).
           unfold permission_at in Hperm_id.
           unfold Mem.perm in *.
           rewrite Hperm_id in Hperm.
           specialize (val_obs_eq0 _ _ _ Hf Hperm).
           specialize (Hval_id _ _ _ Hfid Hperm).
           eapply memval_obs_trans; eauto.
           intros b b' b'' Hf' Hfid'.
           apply id_ren_correct in Hfid';
             by subst.
  Qed.

  Lemma invariant_project:
    forall (tpc tpf : thread_pool) (mc mf : mem) f rmap1 b1 b2 ofs
      i (pff : containsThread tpf i) (pfc : containsThread tpc i)
      (HmemCompC : mem_compatible tpc mc)
      (HmemCompF : mem_compatible tpf mf)
      (Hcanonical: isCanonical rmap1.1)
      (Hcanonical2: isCanonical rmap1.2)
      virtue c cf
      (HinvF: invariant tpf)
      (Hf: f b1 = Some b2),
      let tpc' := updLockSet
                    (updThread pfc c (computeMap (getThreadR pfc)#1 virtue#1,
                                      computeMap (getThreadR pfc)#2 virtue#2))
                    (b1, ofs) rmap1 in
      let tpf' := updLockSet (updThread pff cf
                                        (computeMap (getThreadR pff).1
                                                    (projectAngel f virtue.1),
                                         computeMap (getThreadR pff).2
                                                    (projectAngel f virtue.2))) (b2, ofs)
                             (projectMap f rmap1.1, projectMap f rmap1.2) in
      forall
        (HinvC': invariant tpc')
        (HsimWeak: forall tid (pfc0 : containsThread tpc tid)
                     (pff0 : containsThread tpf tid),
            weak_tsim f pfc0 pff0 HmemCompC HmemCompF)
        (Htsim: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).1)
                           (restrPermMap (compat_th _ _ HmemCompF pff).1))
        (HtsimL: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).2)
                            (restrPermMap (compat_th _ _ HmemCompF pff).2))
        (Hlocks: forall (bl2 : block) (ofs : Z),
            lockRes tpf (bl2, ofs) ->
            exists bl1 : block, f bl1 = Some bl2)
        (HsimRes:
           forall (bl1 bl2 : block) (ofs : Z)
             rmap1 rmap2,
             f bl1 = Some bl2 ->
             forall (Hl1 : lockRes tpc (bl1, ofs) = Some rmap1)
               (Hl2 : lockRes tpf (bl2, ofs) = Some rmap2),
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).1)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).1) /\
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).2)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).2))
        (Hlock_if: forall (bl1 bl2 : block) (ofs : Z),
            f bl1 = Some bl2 ->
            lockRes tpc (bl1, ofs) <-> lockRes tpf (bl2, ofs))
        (HnumThreads: forall i, containsThread tpc i <-> containsThread tpf i),
        invariant tpf'.
  Proof.
    intros.
    assert (HnumThreads': forall i, containsThread tpc' i <-> containsThread tpf' i)
      by (intros; subst tpc' tpf'; split; intros Hcnt;
          apply cntUpdateL; apply cntUpdate;
          apply cntUpdateL' in Hcnt; apply cntUpdate' in Hcnt;
          apply HnumThreads; now auto).
    assert (Hthread_mapped: forall k (pfck': containsThread tpc' k) (pffk': containsThread tpf' k),
               forall b1 b2 ofs,
                 f b1 = Some b2 ->
                 Mem.perm_order'' ((getThreadR pfck').1 # b1 ofs) ((getThreadR pffk').1 # b2 ofs) /\
                 Mem.perm_order'' ((getThreadR pfck').2 # b1 ofs) ((getThreadR pffk').2 # b2 ofs)).
    { intros.
      rewrite! gLockSetRes.
      destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik; subst.
      - rewrite! gssThreadRes.
        simpl.
        erewrite! computeMap_projection_1 by eauto.
        split; now apply po_refl.
      - assert (pfck := cntUpdate' _ _ _ (cntUpdateL' _ _ pfck')).
        assert (pffk := cntUpdate' _ _ _ (cntUpdateL' _ _ pffk')).
        erewrite! gsoThreadRes with (cntj := pfck) by eauto.
        erewrite! gsoThreadRes with (cntj := pffk) by eauto.
        destruct (HsimWeak _ pfck pffk).
        destruct weak_tsim_data0.
        destruct weak_tsim_locks0.
        specialize (perm_obs_weak0 _ _ ofs0 H).
        specialize (perm_obs_weak1 _ _ ofs0 H).
        rewrite! restrPermMap_Cur in perm_obs_weak0.
        rewrite! restrPermMap_Cur in perm_obs_weak1.
        split; now assumption.
    }
    assert (Hthread_unmapped: forall k (pffk: containsThread tpf k)(pffk': containsThread tpf' k),
               forall b2 ofs,
                 (~exists b1, f b1 = Some b2) ->
                 ((getThreadR pffk').1 # b2 ofs = (getThreadR pffk).1 # b2 ofs) /\
                 ((getThreadR pffk').2 # b2 ofs = (getThreadR pffk).2 # b2 ofs)).
    { intros k pffk pffk' b0 ofs0 Hunmmaped.
      rewrite! gLockSetRes.
      destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik; subst.
      - rewrite! gssThreadRes.
        simpl.
        erewrite! computeMap_projection_2 by eauto.
        Tactics.pf_cleanup.
        split; reflexivity.
      - erewrite! gsoThreadRes with (cntj := pffk) by eauto.
        split; reflexivity.
    }

    assert (Hlock_mapped: forall laddrF rmapF (HresF: lockRes tpf' laddrF = Some rmapF),
               exists bc rmap,
                 lockRes tpc' (bc, laddrF.2) = Some rmap /\ f bc = Some laddrF.1 /\
                 forall b1 b2 ofs,
                   f b1 = Some b2 ->
                   Mem.perm_order'' (rmap.1 # b1 ofs) (rmapF.1 # b2 ofs) /\
                   Mem.perm_order'' (rmap.2 # b1 ofs) (rmapF.2 # b2 ofs)).
    { intros.
      subst tpf' tpc'.
      destruct (EqDec_address (b2, ofs) laddrF).
      - subst.
        rewrite gsslockResUpdLock in HresF.
        exists b1, rmap1.
        split. rewrite gsslockResUpdLock; reflexivity.
        split; auto.
        intros.
        inversion HresF.
        simpl.
        pose proof (injective (weak_obs_eq Htsim)).
        erewrite <- projectMap_correct by eauto.
        erewrite <- projectMap_correct by eauto.
        split; now apply po_refl.
      - erewrite gsolockResUpdLock in HresF by eauto.
        erewrite gsoThreadLPool in HresF.
        destruct laddrF as [bl ofsl].
        specialize (Hlocks bl ofsl).
        unfold isSome in Hlocks.
        rewrite HresF in Hlocks.
        specialize (Hlocks (Logic.eq_refl _)).
        destruct Hlocks as [bl1 Hfbl1].
        assert (Hneq: (b1, ofs) <> (bl1, ofsl))
          by (intros Hcontra; inversion Hcontra; subst;
              rewrite Hfbl1 in Hf; inversion Hf; subst; auto).
        specialize (Hlock_if _ _ ofsl Hfbl1).
        destruct (lockRes tpc (bl1, ofsl)) as [rmapC |] eqn:Hres.
        + exists bl1, rmapC.
          erewrite gsolockResUpdLock by eauto.
          erewrite gsoThreadLPool by eauto.
          split; auto. split; auto.
          intros b0 b3 ofs0 Hrenaming.
          specialize (HsimRes _ _ _ _ _ Hfbl1 Hres HresF).
          destruct HsimRes as [[Hperm1 _] [Hperm2 _]].
          specialize (Hperm1 _ _ ofs0 Hrenaming).
          specialize (Hperm2 _ _ ofs0 Hrenaming).
          rewrite! restrPermMap_Cur in Hperm1 Hperm2.
          rewrite Hperm1 Hperm2.
          split; now apply po_refl.
        + exfalso. erewrite HresF in Hlock_if.
          simpl in Hlock_if.
          destruct Hlock_if; now auto.
    }

    assert (Hlock_unmapped: forall laddrF rmapF (HresF: lockRes tpf' laddrF = Some rmapF),
               lockRes tpf laddrF = Some rmapF \/
               forall b2, ~ (exists b1, f b1 = Some b2) -> forall ofs, rmapF.1 # b2 ofs = None
                                                       /\ rmapF.2 # b2 ofs = None).
    { intros (bl & ofsl) rmapF HresF'.
      subst tpf'.
      destruct (EqDec_address (b2, ofs) (bl, ofsl)).
      - inversion e; subst.
        rewrite gsslockResUpdLock in HresF'.
        right.
        intros b2 Hunmapped ofs.
        inversion HresF'; subst.
        simpl.
        erewrite! projectMap_correct_2 by eauto.
        rewrite Hcanonical Hcanonical2;
          split; reflexivity.
      - erewrite gsolockResUpdLock in HresF' by eassumption.
        erewrite gsoThreadLPool in HresF'.
        left; assumption.
    }
    constructor.
    { 
      
      assert (Hno_raceC:= no_race_thr _ HinvC').
      assert (Hno_raceF:= no_race_thr _ HinvF).
      intros k j pffk' pffj' Hkj.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros bf ofs0.
      assert (Hbf: (exists b1, f b1 = Some bf) \/
                   ~ (exists b1, f b1 = Some bf))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - assert (pfck': containsThread tpc' k)
          by (apply HnumThreads' in pffk'; auto).
        assert (pfcj': containsThread tpc' j)
          by (apply HnumThreads' in pffj'; auto).
        specialize (Hno_raceC _ _ pfck' pfcj' Hkj).
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_raceC.
        erewrite <- forall2_and in Hno_raceC.
        destruct (Hno_raceC b ofs0) as [HpermD HpermL].
        pose proof (Hthread_mapped _ pfck' pffk' b bf ofs0 Hbfm) as Hk.
        destruct Hk as [HkD HkL].
        pose proof (Hthread_mapped _ pfcj' pffj' b bf ofs0 Hbfm) as Hj.
        destruct Hj as [HjD HjL].
        split;
          eapply perm_union_lower; eauto;
            rewrite perm_union_comm;
            eapply perm_union_lower; eauto;
              rewrite perm_union_comm; eauto.
      - assert (pffk: containsThread tpf k)
          by (apply cntUpdateL' in pffk';
              apply cntUpdate' in pffk'; auto).
        assert (pffj: containsThread tpf j)
          by (apply cntUpdateL' in pffj';
              apply cntUpdate' in pffj'; auto).
        erewrite (Hthread_unmapped _ pffk pffk' bf ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffk pffk' bf ofs0 Hbfu).2.
        erewrite (Hthread_unmapped _ pffj pffj' bf ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffj pffj' bf ofs0 Hbfu).2.
        specialize (Hno_raceF _ _ pffk pffj Hkj).
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_raceF.
        erewrite <- forall2_and in Hno_raceF.
        now eauto.
    }
    { 
      intros laddr1 laddr2 rmap0 rmap2 Hneq Hres0 Hres2.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros bf ofs0.
      assert (Hbf: (exists b1, f b1 = Some bf) \/
                   ~ (exists b1, f b1 = Some bf))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - destruct (Hlock_mapped _ _ Hres0) as [bc1 [rmap0C [HresC [Hfl1 Hperm0]]]].
        destruct (Hperm0 _ _ ofs0 Hbfm).
        destruct (Hlock_mapped _ _ Hres2) as [bc2 [rmap2C [Hres2C [Hfl2 Hperm2]]]].
        destruct (Hperm2 _ _ ofs0 Hbfm).
        assert (HneqC: (bc1, laddr1.2) <> (bc2, laddr2.2)) by
            (intros Hcontra;
             inversion Hcontra; subst;
             rewrite Hfl1 in Hfl2; inversion Hfl2;
             destruct laddr1, laddr2; simpl in *; subst;
             now auto).
        pose proof (no_race_lr _ HinvC' _ _ _ _ HneqC HresC Hres2C) as Hdisjoint.
        unfold permMapsDisjoint2, permMapsDisjoint in Hdisjoint.
        erewrite <- forall2_and in Hdisjoint.
        destruct (Hdisjoint b ofs0).
        split;
          eapply perm_union_lower; eauto;
            rewrite perm_union_comm;
            eapply perm_union_lower; eauto;
              rewrite perm_union_comm; now eauto.
      - subst tpf'.
        destruct (Hlock_unmapped _ _ Hres0) as [Heq0 | Hempty0].
        + destruct (Hlock_unmapped _ _ Hres2) as [Heq2 | Hempty2].
          * pose proof (no_race_lr _ HinvF  _ _ _ _ Hneq Heq0 Heq2) as Hdisjoint.
            unfold permMapsDisjoint2, permMapsDisjoint in Hdisjoint.
            erewrite <- forall2_and in Hdisjoint.
            now eauto.
          * specialize (Hempty2 _ Hbfu ofs0).
            destruct Hempty2 as [H1 H2].
            rewrite H1 H2.
            split; rewrite perm_union_comm; apply not_racy_union;
              now constructor.
        + specialize (Hempty0 _ Hbfu ofs0).
          destruct Hempty0 as [H1 H2].
          rewrite H1 H2.
          split; apply not_racy_union;
            now constructor.
    }
    { 
      intros k laddrF pffk' rmapF HresF.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros b0 ofs0.
      assert (Hbf: (exists b1, f b1 = Some b0) \/
                   ~ (exists b1, f b1 = Some b0))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - assert (pfck': containsThread tpc' k)
          by (apply HnumThreads' in pffk'; auto).
        destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
        destruct (HpermC _ _ ofs0 Hbfm).
        pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
        destruct Hk as [HkD HkL].
        pose proof (no_race _ HinvC' _ _ pfck' _ HresC).
        unfold permMapsDisjoint2, permMapsDisjoint in H1.
        erewrite <- forall2_and in H1.
        destruct (H1 b ofs0).
        split;
          eapply perm_union_lower; eauto;
            rewrite perm_union_comm;
            eapply perm_union_lower; eauto;
              rewrite perm_union_comm; eauto.
      - assert (pffk: containsThread tpf k)
          by (apply cntUpdateL' in pffk';
              apply cntUpdate' in pffk'; auto).
        erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
        subst tpf'.
        destruct (Hlock_unmapped _ _ HresF) as [Heq0 | Hempty0].
        + pose proof ((no_race _ HinvF) _ _ pffk _ Heq0) as Hno_race.
          unfold permMapsDisjoint2, permMapsDisjoint in Hno_race.
          erewrite <- forall2_and in Hno_race.
          now eauto.
        + erewrite (Hempty0 _ Hbfu ofs0).1.
          erewrite (Hempty0 _ Hbfu ofs0).2.
          split;
            rewrite perm_union_comm;
            apply not_racy_union;
            now constructor.
    }
    { 
      intros k pffk'.
      split.
      - intros j pffj' b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfck': containsThread tpc' k)
            by (apply HnumThreads' in pffk'; auto).
          assert (pfcj': containsThread tpc' j)
            by (apply HnumThreads' in pffj'; auto).
          pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
          destruct Hk as [_ HkL].
          pose proof (Hthread_mapped _ pfcj' pffj' b b0 ofs0 Hbfm) as Hj.
          destruct Hj as [HjD].
          pose proof ((thread_data_lock_coh _ HinvC' _ pfck').1 _ pfcj' b ofs0).
          eapply perm_coh_lower;
            now eauto.
        + assert (pffj: containsThread tpf j)
            by (apply cntUpdateL' in pffj';
                apply cntUpdate' in pffj'; auto).
          erewrite (Hthread_unmapped _ pffj pffj' b0 ofs0 Hbfu).1.
          assert (pffk: containsThread tpf k)
            by (apply cntUpdateL' in pffk';
                apply cntUpdate' in pffk'; auto).
          erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
          now eapply ((thread_data_lock_coh _ HinvF _ pffk).1 _ pffj b0 ofs0).
      - intros laddrF rmapF HresF b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfck': containsThread tpc' k)
            by (apply HnumThreads' in pffk'; auto).
          pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
          destruct Hk as [_ HkL].
          destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          pose proof ((thread_data_lock_coh _ HinvC' _ pfck').2 _ _ HresC b ofs0).
          eapply perm_coh_lower;
            now eauto.
        + assert (pffk: containsThread tpf k)
            by (apply cntUpdateL' in pffk';
                apply cntUpdate' in pffk'; auto).
          erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
          subst tpf'.
          destruct (Hlock_unmapped _ _ HresF) as [Heq0 | Hempty0].
          pose proof ((thread_data_lock_coh _ HinvF _ pffk).2 _ _ Heq0 b0 ofs0) as Hno_race.
          now eauto.
          erewrite (Hempty0 _ Hbfu ofs0).1.
          simpl.
          pose proof ((invariant_not_freeable HinvF b0 ofs0).1 _ pffk).
          destruct ((getThreadR pffk).2 # b0 ofs0) as [p|];
            try (destruct p); auto.
    }
    { 
      intros laddrF rmapF HresF.
      split.
      - intros j pffj' b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfcj': containsThread tpc' j)
            by (apply HnumThreads' in pffj'; auto).
          pose proof (Hthread_mapped _ pfcj' pffj' b b0 ofs0 Hbfm).1 as Hj.
          destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          pose proof ((locks_data_lock_coh _ HinvC' _ _ HresC).1 _ pfcj' b ofs0).
          eapply perm_coh_lower;
            now eauto.
        +  assert (pffj: containsThread tpf j)
            by (apply cntUpdateL' in pffj';
                apply cntUpdate' in pffj'; auto).
           erewrite (Hthread_unmapped _ pffj pffj' b0 ofs0 Hbfu).1.
           subst tpf'.
           destruct (Hlock_unmapped _ _ HresF) as [Heq0 | Hempty0].
           * pose proof ((locks_data_lock_coh _ HinvF _ _ Heq0).1 _ pffj) as Hno_race.
             now eauto.
           * erewrite (Hempty0 _ Hbfu ofs0).2.
             now apply perm_coh_empty_1.
      - intros laddr2F' rmap2F' Hres2F' b0 ofs0.
        subst tpf'.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          destruct (Hlock_mapped _ _ Hres2F') as [bc2 [rmapC2 [HresC2 [Hfl2 HpermC2]]]].
          destruct (HpermC2 _ _ ofs0 Hbfm).
          pose proof ((locks_data_lock_coh _ HinvC' _ _ HresC).2 _ _ HresC2 b ofs0).
          eapply perm_coh_lower;
            now eauto.
        + destruct (Hlock_unmapped _ _ HresF) as [Heq0 | Hempty0].
          * destruct (Hlock_unmapped _ _ Hres2F') as [Heq2 | Hempty2];
              first by (eapply ((locks_data_lock_coh _ HinvF _ _ Heq0).2 _ _ Heq2 b0 ofs0)).
            erewrite (Hempty2 _ Hbfu ofs0).1.
            pose proof ((invariant_not_freeable HinvF b0 ofs0).2 _ _ Heq0).
            destruct (rmapF.2 # b0 ofs0) as [p|];
              try (destruct p); simpl;
              now auto.
          * erewrite (Hempty0 _ Hbfu ofs0).2.
            now apply perm_coh_empty_1.
    }
    { 
      intros b0 ofs0.
      destruct (lockRes tpf') eqn:Hres0; auto.
      intros ofs1 Hofs1.
      pose proof (lockRes_valid _ HinvC') as HlrC'.
      subst tpc' tpf'.
      destruct (Pos.eq_dec b0 b2).
      { subst.
        destruct (Z.eq_dec ofs ofs1).
        - subst.
          specialize (HlrC' b1 ofs0).
          erewrite gsolockResUpdLock in HlrC'
            by (intros Hcontra; inversion Hcontra; subst; omega).
          erewrite gsolockResUpdLock in Hres0
            by (intros Hcontra; inversion Hcontra; subst; omega).
          rewrite gsoThreadLPool in Hres0.
          rewrite gsoThreadLPool in HlrC'.
          specialize (snd (Hlock_if _ _ ofs0 Hf) ltac:(rewrite Hres0;auto)).
          intro HresC.
          destruct (lockRes tpc (b1, ofs0)); try by exfalso.
          specialize (HlrC' ofs1 Hofs1).
          rewrite gsslockResUpdLock in HlrC'.
          discriminate.
        - erewrite gsolockResUpdLock
            by (intros Hcontra; inversion Hcontra; subst; auto).
          rewrite gsoThreadLPool.
          destruct (Z.eq_dec ofs ofs0).
          + subst.
            specialize (HlrC' b1 ofs0).
            rewrite gsslockResUpdLock in HlrC'.
            specialize (HlrC' ofs1 Hofs1).
            unfold lksize.LKSIZE in Hofs1. simpl in Hofs1.
            erewrite gsolockResUpdLock in HlrC'
              by (intro Hcontra; inversion Hcontra; subst; omega).
            rewrite gsoThreadLPool in HlrC'.
            destruct (lockRes tpf (b2, ofs1)) eqn:HlockF; auto.
            specialize (snd (Hlock_if _ _ ofs1 Hf) ltac:(rewrite HlockF; auto)).
            intro Hcontra. rewrite HlrC' in Hcontra; by exfalso.
          + erewrite gsolockResUpdLock in Hres0
              by (intro Hcontra; inversion Hcontra; subst; omega).
            rewrite gsoThreadLPool in Hres0.
            pose proof (lockRes_valid _ HinvF).
            specialize (H b2 ofs0).
            rewrite Hres0 in H; eauto.
      }
      { erewrite gsolockResUpdLock
          by (intro Hcontra; inversion Hcontra; subst; auto).
        rewrite gsoThreadLPool.
        erewrite gsolockResUpdLock in Hres0
          by (intro Hcontra; inversion Hcontra; subst; auto).
        rewrite gsoThreadLPool in Hres0.
        pose proof (lockRes_valid _ HinvF).
        specialize (H b0 ofs0).
        rewrite Hres0 in H; eauto.
      }
    }
  Qed.

  Lemma gss_mem_obs_eq_lock:
    forall mc mf mc' mf' rmap rmapF bl1 bl2 ofsl f v
      rmap' rmapF' virtue
      (Hlt: permMapLt rmap (getMaxPerm mc))
      (HltF: permMapLt rmapF (getMaxPerm mf))
      (Hlt': permMapLt rmap' (getMaxPerm mc))
      (HltF': permMapLt rmapF' (getMaxPerm mf))
      (Hlt2: permMapLt (computeMap rmap virtue) (getMaxPerm mc'))
      (Hlt2F: permMapLt (computeMap rmapF (projectAngel f virtue)) (getMaxPerm mf'))
      (Hf: f bl1 = Some bl2)
      (Hobs_eq: mem_obs_eq f (restrPermMap Hlt) (restrPermMap HltF))
      (Hobs_eq': strong_mem_obs_eq f (restrPermMap Hlt') (restrPermMap HltF'))
      (Hstore: Mem.mem_contents mc' = PMap.set bl1 (Mem.setN (encode_val Mint32 (Vint v)) ofsl (Mem.mem_contents mc) # bl1)
                                               (Mem.mem_contents mc))
      (HstoreF: Mem.mem_contents mf' = PMap.set bl2 (Mem.setN (encode_val Mint32 (Vint v)) ofsl (Mem.mem_contents mf) # bl2)
                                                (Mem.mem_contents mf))
      (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b)
      (HvbF: forall b, Mem.valid_block mf b <-> Mem.valid_block mf' b)
      (Hjoin: permMapJoin rmap' rmap (computeMap rmap virtue)),
      mem_obs_eq f (restrPermMap Hlt2) (restrPermMap Hlt2F).
  Proof.
    intros.
    inversion Hobs_eq.
    destruct weak_obs_eq0.
    assert (Hvb': forall b, ~ Mem.valid_block mc b <-> ~ Mem.valid_block mc' b)
      by (intros; split; intros Hinvalid Hcontra;
            by apply Hvb in Hcontra).
    constructor.
    { 
      constructor;
        try (intros b1; erewrite restrPermMap_valid);
        try (erewrite <- Hvb');
        try (erewrite <- Hvb);
        try by eauto.
      intros b1 b2 Hf1. erewrite restrPermMap_valid.
      erewrite <- HvbF.
      specialize (codomain_valid0 _ _ Hf1);
        by erewrite restrPermMap_valid in codomain_valid0.
      intros b1 b2 ofs0 Hf1.
      do 2 rewrite restrPermMap_Cur.
      specialize (perm_obs_weak0 _ _ ofs0 Hf1).
      erewrite computeMap_projection_1; eauto;
        by apply po_refl.
    }
    { 
      constructor.
      - intros b1 b2 ofs0 Hf1.
        do 2 rewrite restrPermMap_Cur.
        erewrite computeMap_projection_1; eauto;
          by apply po_refl.
      - intros b1 b2 ofs0 Hf1 Hperm.
        unfold Mem.perm in *.
        assert (Hperm_eq := restrPermMap_Cur Hlt2 b1 ofs0).
        unfold permission_at in Hperm_eq.
        rewrite Hperm_eq in Hperm.
        
        assert (Hval_eq: memval_obs_eq f (ZMap.get ofs0 (Mem.mem_contents mc) # b1) (ZMap.get ofs0 (Mem.mem_contents mf) # b2)).
        {
          specialize (Hjoin b1 ofs0).
          apply permjoin_readable_iff in Hjoin.
          apply Hjoin in Hperm.
          simpl.
          
          destruct Hperm as [Hperm | Hperm];
            [assert (Heq := restrPermMap_Cur Hlt' b1 ofs0);
             pose proof ((val_obs_eq Hobs_eq') b1 b2 ofs0 Hf1) as Hval_eq|
             assert (Heq := restrPermMap_Cur Hlt b1 ofs0);
             pose proof ((val_obs_eq strong_obs_eq0) b1 b2 ofs0 Hf1) as Hval_eq];
            unfold Mem.perm, permission_at in *;
            rewrite Heq in Hval_eq;
            specialize (Hval_eq Hperm);
            simpl in Hval_eq;
            assumption.
        }

        simpl.
        rewrite Hstore HstoreF.

        destruct (Pos.eq_dec b1 bl1) as [Heq | Hneq];
          [| assert (b2 <> bl2)
             by (intros Hcontra; subst;
                 apply Hneq; eapply injective0; eauto);
             subst;
             erewrite! Maps.PMap.gso by auto;
             assumption].
        subst bl1.
        assert (b2 = bl2)
          by (rewrite Hf1 in Hf; inversion Hf; by subst); subst bl2.
        rewrite! Maps.PMap.gss.
        destruct (Z_lt_le_dec ofs0 ofsl) as [Hofs_lt | Hofs_ge].
        erewrite! Mem.setN_outside by (left; auto);
          by assumption.
        destruct (Z_lt_ge_dec
                    ofs0 (ofsl + (size_chunk Mint32)))
          as [Hofs_lt | Hofs_ge'].

        apply setN_obs_eq with (access := fun q => q = ofs0);
          eauto using encode_val_obs_eq, val_obs.
        intros; subst; assumption.
        erewrite! Mem.setN_outside by (right; rewrite size_chunk_conv in Hofs_ge';
                                         by rewrite encode_val_length);
          by auto.
    }
  Qed.

  Lemma gss_mem_obs_eq_unlock:
    forall mc mf mc' mf' rmap rmapF bl1 bl2 ofsl f v
      rmap' rmapF' rmap2 rmap2F
      (Hlt': permMapLt rmap' (getMaxPerm mc'))
      (HltF': permMapLt rmapF' (getMaxPerm mf'))
      (Hlt2: permMapLt rmap2 (getMaxPerm mc))
      (Hlt2F: permMapLt rmap2F (getMaxPerm mf))
      (Hf: f bl1 = Some bl2)
      (Hobs_eq2: mem_obs_eq f (restrPermMap Hlt2) (restrPermMap Hlt2F))
      (Hstore: Mem.mem_contents mc' = PMap.set bl1 (Mem.setN (encode_val Mint32 (Vint v)) ofsl (Mem.mem_contents mc) # bl1)
                                               (Mem.mem_contents mc))
      (HstoreF: Mem.mem_contents mf' = PMap.set bl2 (Mem.setN (encode_val Mint32 (Vint v)) ofsl (Mem.mem_contents mf) # bl2)
                                                (Mem.mem_contents mf))
      (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b)
      (HvbF: forall b, Mem.valid_block mf b <-> Mem.valid_block mf' b)
      (Hjoin: permMapJoin rmap' rmap rmap2)
      (HpmapF: forall b, (~exists b', f b' = Some b) ->
                    forall ofs, (rmapF # b ofs = None /\ rmap2F # b ofs = rmapF' # b ofs) \/
                           (rmapF' # b ofs = None /\ rmap2F # b ofs = rmapF # b ofs))
      (Hrmap': forall b1 b2 ofs, f b1 = Some b2 -> (rmap' # b1) ofs = (rmapF' # b2) ofs)
      (Hrmap': forall b1 b2 ofs, f b1 = Some b2 -> (rmap # b1) ofs = (rmapF # b2) ofs),
      mem_obs_eq f (restrPermMap Hlt') (restrPermMap HltF').
  Proof.
     intros.
     inversion Hobs_eq2.
     destruct weak_obs_eq0.
     assert (Hvb': forall b, ~ Mem.valid_block mc b <-> ~ Mem.valid_block mc' b)
       by (intros; split; intros Hinvalid Hcontra;
             by apply Hvb in Hcontra).
     constructor.
     { 
       constructor;
         try (intros b1; erewrite restrPermMap_valid);
         try (erewrite <- Hvb');
         try (erewrite <- Hvb);
         try by eauto.
       intros b1 b2 Hf1. erewrite restrPermMap_valid.
       erewrite <- HvbF.
       specialize (codomain_valid0 _ _ Hf1);
         by erewrite restrPermMap_valid in codomain_valid0.
       intros b1 b2 ofs0 Hf1.
       do 2 rewrite restrPermMap_Cur.
       specialize (perm_obs_weak0 _ _ ofs0 Hf1).
       erewrite Hrmap';
         eauto using po_refl.
     }
     { 
       constructor.
       - intros b1 b2 ofs0 Hf1.
         do 2 rewrite restrPermMap_Cur.
         erewrite Hrmap';
           by eauto.
       - intros b1 b2 ofs0 Hf1 Hperm.
         unfold Mem.perm in *.
         assert (Hperm_eq := restrPermMap_Cur Hlt' b1 ofs0).
         unfold permission_at in Hperm_eq.
         rewrite Hperm_eq in Hperm.
         
         assert (Hval_eq: memval_obs_eq f (ZMap.get ofs0 (Mem.mem_contents mc) # b1) (ZMap.get ofs0 (Mem.mem_contents mf) # b2)).
         {
           specialize (Hjoin b1 ofs0).
           apply permjoin_readable_iff in Hjoin.
           pose proof (Hjoin.2 (or_introl Hperm)) as Hreadable.
           assert (Heq:= restrPermMap_Cur Hlt2 b1 ofs0).
           pose proof ((val_obs_eq strong_obs_eq0) b1 b2 ofs0 Hf1) as Hval_eq.
           unfold Mem.perm, permission_at in *.
           rewrite Heq in Hval_eq.
           simpl in Hval_eq.
           now eauto.
         }

         simpl.
         rewrite Hstore HstoreF.
         destruct (Pos.eq_dec b1 bl1) as [Heq | Hneq];
           [| assert (b2 <> bl2)
              by (intros Hcontra; subst;
                  apply Hneq; eapply injective0; eauto);
              subst;
              erewrite! Maps.PMap.gso by auto;
              assumption].
         subst bl1.
         assert (b2 = bl2)
           by (rewrite Hf1 in Hf; inversion Hf; by subst); subst bl2.
         rewrite! Maps.PMap.gss.
         destruct (Z_lt_le_dec ofs0 ofsl) as [Hofs_lt | Hofs_ge].
         erewrite! Mem.setN_outside by (left; auto);
           by assumption.
         destruct (Z_lt_ge_dec
                     ofs0 (ofsl + (size_chunk Mint32)))
           as [Hofs_lt | Hofs_ge'].

         apply setN_obs_eq with (access := fun q => q = ofs0);
           eauto using encode_val_obs_eq, val_obs.
         intros; subst; assumption.
         erewrite! Mem.setN_outside by (right; rewrite size_chunk_conv in Hofs_ge';
                                          by rewrite encode_val_length);
           by auto.
     }
  Qed.

  Lemma store_compatible:
    forall tpf mf pmap chunk b ofs v mf' (Hlt: permMapLt pmap (getMaxPerm mf))
      (Hcomp: mem_compatible tpf mf)
      (Hstore: Mem.store chunk (restrPermMap Hlt) b ofs v = Some mf'),
      mem_compatible tpf mf'.
  Proof.
   intros.
    inversion Hcomp.
    constructor.
    - intros.
      unfold permMapLt.
      erewrite <- forall2_and.
      intros b' ofs'.
      erewrite <- mem_store_max by eauto.
      rewrite getMax_restr.
      destruct (compat_th0 _ cnt).
      split; eauto.
    - intros l rmap Hres.
      unfold permMapLt.
      erewrite <- forall2_and.
      intros b' ofs'.
      erewrite <- mem_store_max with (b' := b') (ofs' := ofs') by eauto.
      rewrite getMax_restr.
      destruct (compat_lp0 _ _ Hres).
      split; eauto.
    - intros.
      eapply Mem.store_valid_block_1; eauto.
      rewrite restrPermMap_valid.
      eauto.
  Qed.

  Lemma mem_compatible_sync:
    forall tpf mf cf virtue1 virtue2 f bl1 bl2 ofsl i
      (pff: containsThread tpf i)
      (Hcanonical1: isCanonical virtue2.1)
      (Hcanonical2: isCanonical virtue2.2)
      (Hf: f bl1 = Some bl2)
      (HmaxF: max_inv mf)
      (HmemCompF: mem_compatible tpf mf)
      (Hcodomain_valid : forall b1 b2 : block,
          f b1 = Some b2 -> Mem.valid_block mf b2),
      let newPermMap := (computeMap (getThreadR pff).1 (projectAngel f virtue1.1),
                         computeMap (getThreadR pff).2 (projectAngel f virtue1.2)) in
      let newLockMap := (projectMap f virtue2.1, projectMap f virtue2.2) in
      mem_compatible (updLockSet (updThread pff cf newPermMap)
                                            (bl2, ofsl) newLockMap) mf.
  Proof.
    intros.
    constructor.
    { intros j pffj.
      rewrite gLockSetRes.
      destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
      - subst.
        rewrite gssThreadRes.
        unfold permMapLt.
        rewrite <- forall2_and.
        intros b2 ofs.
        simpl.
        assert (Hb2: (exists b', f b' = Some b2) \/
                     ~ (exists b', f b' = Some b2))
          by eapply em.
        destruct Hb2 as [Hbm | Hbu].
        
        destruct Hbm as [b1 Hfb1].
        apply Hcodomain_valid in Hfb1.
        specialize (HmaxF _ ofs Hfb1).
        rewrite getMaxPerm_correct.
        rewrite HmaxF.
        simpl.
        split;
          match goal with
          | [|- match ?Expr with _ => _ end] =>
            destruct Expr
          end; constructor.
        erewrite! computeMap_projection_2 by eauto.
        destruct (compat_th _ _ HmemCompF pff);
          auto.
      - rewrite gsoThreadRes; auto.
        eapply HmemCompF.
    }
    { intros (bl', ofsl') rmap Hres.
      destruct (EqDec_address (bl2, ofsl) (bl', ofsl')).
      - inversion e; subst.
        rewrite gssLockRes in Hres. inversion Hres; subst.
        unfold permMapLt.
        rewrite <- forall2_and.
        simpl.
        intros b2 ofs.
        assert (Hb2: (exists b', f b' = Some b2) \/
                     ~ (exists b', f b' = Some b2))
          by eapply em.
        destruct Hb2 as [Hbm | Hbu].
        
        destruct Hbm as [b1 Hfb1].
        apply Hcodomain_valid in Hfb1.
        specialize (HmaxF _ ofs Hfb1).
        rewrite getMaxPerm_correct.
        rewrite HmaxF.
        simpl.
        split;
          match goal with
          | [|- match ?Expr with _ => _ end] =>
            destruct Expr
          end; constructor.
        erewrite! projectMap_correct_2 by eauto.
        rewrite Hcanonical1 Hcanonical2.
        split;
          by apply po_None.
      - rewrite gsoLockRes in Hres; auto.
        rewrite gsoThreadLPool in Hres.
        eapply HmemCompF; eauto.
    }
    { intros (bl' & ofsl') rmap Hres.
      destruct (EqDec_address (bl2, ofsl) (bl', ofsl')).
      - inversion e; subst.
        eapply Hcodomain_valid; eauto.
      - erewrite gsoLockRes in Hres by assumption.
        rewrite gsoThreadLPool in Hres.
        eapply (lockRes_blocks _ _ HmemCompF);
          by eassumption.
    }
  Qed.

  Lemma mem_compatible_spawn :
    forall (tpf : thread_pool) (mf : mem) (cf : ctl)
      virtue1 virtue2 (f : block -> option block)
      vf args i (pff : containsThread tpf i)
      (Hmax_inv: max_inv mf)
      (HmemCompF: mem_compatible tpf mf)
      (Hcodomain: forall b1 b2 : block, f b1 = Some b2 -> Mem.valid_block mf b2),
      mem_compatible
        (addThread
           (updThread pff cf
                      (computeMap (getThreadR pff).1 (projectAngel f virtue1.1),
                       computeMap (getThreadR pff).2 (projectAngel f virtue1.2)))
                      vf args (computeMap empty_map (projectAngel f virtue2.1),
                               computeMap empty_map (projectAngel f virtue2.2))) mf.
  Proof.
    intros.
    constructor.
    { intros j pffj''.
      assert (pffj' := cntAdd' _ _ _ pffj'').
      destruct pffj' as [[pffj' Hneq] | Heq].
      - 
        erewrite gsoAddRes with (cntj := pffj') by eauto.
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        + subst.
          rewrite gssThreadRes.
          unfold permMapLt.
          erewrite <- forall2_and.
          intros b2 ofs.
          assert (Hb2: (exists b', f b' = Some b2) \/
                       ~ (exists b', f b' = Some b2))
            by eapply em.
          destruct Hb2 as [Hbm | Hbu].
          * 
            destruct Hbm as [b1 Hfb1].
            apply Hcodomain in Hfb1.
            specialize (Hmax_inv _ ofs Hfb1).
            rewrite getMaxPerm_correct.
            rewrite Hmax_inv.
            simpl.
            split;
              match goal with
            | [ |- match ?Expr with _ => _ end] =>
              destruct Expr
              end;
              now constructor.
          * simpl.
            erewrite! computeMap_projection_2 by eauto.
            split;
            now eapply HmemCompF.
        + rewrite gsoThreadRes; auto.
          split;
            now eapply HmemCompF.
      - 
        subst.
        erewrite gssAddRes; eauto.
        unfold permMapLt.
        erewrite <- forall2_and.
        intros b2 ofs.
        assert (Hb2: (exists b', f b' = Some b2) \/
                     ~ (exists b', f b' = Some b2))
          by eapply em.
        destruct Hb2 as [Hbm | Hbu].
        + 
          destruct Hbm as [b1 Hfb1].
          apply Hcodomain in Hfb1.
          specialize (Hmax_inv _ ofs Hfb1).
          rewrite getMaxPerm_correct.
          rewrite Hmax_inv.
          simpl.
          split;
            match goal with
            | [|- match ?Expr with _ => _ end] =>
              destruct Expr
            end;
            now constructor.
        + simpl.
          erewrite! computeMap_projection_2 by eauto.
          rewrite empty_map_spec.
          split;
            now apply po_None.
    }
    { intros (bl', ofsl') rmap Hres.
      rewrite gsoAddLPool in Hres.
      rewrite gsoThreadLPool in Hres.
      eapply HmemCompF; eauto.
    }
    { intros l rmap Hres.
      rewrite gsoAddLPool in Hres.
      rewrite gsoThreadLPool in Hres.
      eapply (lockRes_blocks _ _ HmemCompF);
        now eassumption.
    }
  Qed.

  Lemma permMapJoin_project:
    forall (f : memren)
      pmap pmapF pmap' pmapF' pmapR pmapRF
      (HpmapF: forall b, (~exists b', f b' = Some b) ->
                    forall ofs, (pmapF # b ofs = None /\ pmapRF # b ofs = pmapF' # b ofs) \/
                           (pmapF' # b ofs = None /\ pmapRF # b ofs = pmapF # b ofs))
      (Hangel: permMapJoin pmap pmap' pmapR)
      (Hpmap: forall b1 b2 ofs, f b1 = Some b2 -> (pmap # b1) ofs = (pmapF # b2) ofs)
      (Hpmap': forall b1 b2 ofs, f b1 = Some b2 -> (pmap' # b1) ofs = (pmapF' # b2) ofs)
      (HpmapR: forall b1 b2 ofs, f b1 = Some b2 -> (pmapR # b1) ofs = (pmapRF # b2) ofs),
      permMapJoin pmapF pmapF' pmapRF.
  Proof.
    intros.
    intros b2 ofs.
    
    assert (Hb2: (exists b1, f b1 = Some b2) \/
                 ~ (exists b1, f b1 = Some b2))
      by eapply em.
    destruct Hb2 as [[b1 Hf1] | Hunmapped].
    - specialize (Hangel b1 ofs).
      erewrite <- Hpmap, <- Hpmap', <- HpmapR
        by eassumption.
      assumption.
    - destruct (HpmapF _ Hunmapped ofs) as [[Hempty Heq] | [Hempty Heq]];
        rewrite Hempty Heq;
        now constructor.
  Qed.

  Lemma invariant_mklock:
    forall tp c b ofs  i (cnti: containsThread tp i)
      (Hinv: invariant tp)
      (Hperm: forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
                      Mem.perm_order' ((getThreadR cnti)#1 # b ofs') Writable),
      let tp' := (updThread cnti c
                            (setPermBlock (Some Nonempty) b ofs (getThreadR cnti)#1 lksize.LKSIZE_nat,
                             setPermBlock (Some Writable) b ofs
                                          (getThreadR cnti)#2 lksize.LKSIZE_nat)) in
      invariant tp'.
  Proof.
    intros.
    inversion Hinv.
    assert (Hperm_thr1: forall k (cntk: containsThread tp k) (Hik: i <> k) ofs',
               Intv.In ofs' (ofs, ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               Mem.perm_order'' (Some Nonempty) ((getThreadR cntk).1 # b ofs')).
    { intros.
      specialize ((no_race_thr0 _ _ cnti cntk Hik).1 b ofs').
      intros.
      specialize (Hperm ofs' H).
      destruct ((getThreadR cnti).1 # b ofs'); simpl in Hperm;
        inversion Hperm; subst; simpl in H0;
          destruct (((getThreadR cntk)#1) # b ofs');
          simpl; try (destruct p); auto using perm_order;
            destruct H0; discriminate.
    }
    assert (Hperm_thr2: forall k (cntk: containsThread tp k) ofs',
               Intv.In ofs' (ofs, ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               (getThreadR cntk).2 # b ofs' = None).
    { intros.
      specialize ((thread_data_lock_coh0 _ cntk).1 _ cnti b ofs').
      intros.
      specialize (Hperm ofs' H).
      destruct ((getThreadR cnti).1 # b ofs'); simpl in Hperm;
        inversion Hperm; subst; simpl in H0;
          destruct (((getThreadR cntk)#2) # b ofs');
          simpl; tauto.
    }

    assert (Hperm_res1: forall laddr rmap (Hres: lockRes tp laddr = Some rmap) ofs',
               Intv.In ofs' (ofs, ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               Mem.perm_order'' (Some Nonempty) (rmap.1 # b ofs')).
    { intros.
      specialize ((no_race0 _ _ cnti _ Hres).1 b ofs').
      intros.
      specialize (Hperm ofs' H).
      destruct ((getThreadR cnti).1 # b ofs'); simpl in Hperm;
        inversion Hperm; subst; simpl in H0;
          destruct (rmap#1 # b ofs');
          simpl; try (destruct p); auto using perm_order;
            destruct H0; discriminate.
    }
    assert (Hperm_res2: forall laddr rmap (Hres: lockRes tp laddr = Some rmap) ofs',
               Intv.In ofs' (ofs, ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               rmap.2 # b ofs' = None).
    { intros.
      specialize ((locks_data_lock_coh0 _ _ Hres).1 _ cnti b ofs').
      intros.
      specialize (Hperm ofs' H).
      destruct ((getThreadR cnti).1 # b ofs'); simpl in Hperm;
        inversion Hperm; subst; simpl in H0;
          destruct (rmap.2 # b ofs');
          simpl; tauto.
    }

    constructor.

    { intros k j cntk' cntj' Hkj.
      pose proof (cntUpdate c ((setPermBlock (Some Nonempty) b ofs (getThreadR cnti)#1 lksize.LKSIZE_nat,
                                setPermBlock (Some Writable) b ofs
                                             (getThreadR cnti)#2 lksize.LKSIZE_nat)) cnti cnti) as cnti'.
      assert (Hdisjoint_i': forall x (cntx': containsThread tp' x), i <> x -> permMapsDisjoint2 (getThreadR cnti') (getThreadR cntx')).
      { intros.
        rewrite gssThreadRes.
        pose proof (cntUpdate' _ _ _ cntx') as cntx.
        unfold permMapsDisjoint2, permMapsDisjoint.
        erewrite <- forall2_and.
        intros b' ofs'.
        subst tp'.
        destruct (Pos.eq_dec b b').
        + subst.
          destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
          * rewrite! setPermBlock_same; auto.
            erewrite @gsoThreadRes with (cntj := cntx) by eauto.
            split.
            specialize (Hperm_thr1 _ cntx ltac:(auto) ofs' i0).
            destruct (((getThreadR cntx)#1) # b' ofs'); simpl in Hperm_thr1;
              inversion Hperm_thr1; subst; simpl;
                now eauto.
            specialize (Hperm_thr2 _ cntx ofs' i0).
            erewrite Hperm_thr2.
            rewrite perm_union_comm;
              eapply not_racy_union;
              now constructor.
          * apply Intv.range_notin in n;
              try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
            rewrite! setPermBlock_other_1; eauto.
            erewrite @gsoThreadRes with (cntj := cntx) by eauto.
            destruct (no_race_thr0 _ _ cnti cntx ltac:(auto));
              now eauto.
        + rewrite! setPermBlock_other_2; eauto.
          erewrite @gsoThreadRes with (cntj := cntx) by eauto.
          destruct (no_race_thr0 _ _ cnti cntx ltac:(auto));
            now eauto.
      }
      destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
      - subst tp' k. Tactics.pf_cleanup.
        eapply Hdisjoint_i';
          now eauto.
      - destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        + subst.
          Tactics.pf_cleanup.
          destruct (Hdisjoint_i' k cntk'); eauto.
          split; apply permMapsDisjoint_comm;
            eauto using permMapsDisjoint_comm.
        + subst tp'.
          pose proof (cntUpdate' _ _ _ cntj') as cntj.
          pose proof (cntUpdate' _ _ _ cntk') as cntk.
          erewrite @gsoThreadRes with (cntj := cntk) by eauto.
          erewrite @gsoThreadRes with (cntj := cntj) by eauto.
          now eauto.
    }
    { intros.
      subst tp'.
      erewrite gsoThreadLPool in Hres1, Hres2.
      now eauto.
    }
    { intros.
      subst tp'.
      erewrite gsoThreadLPool in Hres.
      destruct (i == i0) eqn:Heq; move/eqP:Heq=>Heq.
      - subst.
        unfold permMapsDisjoint2, permMapsDisjoint.
        erewrite <- forall2_and.
        intros b' ofs'.
        erewrite gssThreadRes.
        destruct (Pos.eq_dec b b').
        + subst.
          destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
          * rewrite! setPermBlock_same; auto.
            split.
            specialize (Hperm_res1 _ _ Hres  ofs' i).
            simpl in Hperm_res1.
            destruct (rmap.1 # b' ofs'); inversion Hperm_res1; subst;
              simpl; now eauto.
            specialize (Hperm_res2 _ _ Hres ofs' i).
            rewrite Hperm_res2.
            rewrite perm_union_comm;
              eapply not_racy_union;
              now constructor.
          * apply Intv.range_notin in n;
              try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
            rewrite! setPermBlock_other_1; eauto.
            destruct (no_race0 _ _ cnti _ Hres);
              now eauto.
        + rewrite! setPermBlock_other_2; eauto.
          destruct (no_race0 _ _ cnti _ Hres);
            now eauto.
      - pose proof (cntUpdate' _ _ _ cnti0) as cnti00.
        erewrite gsoThreadRes with (cntj := cnti00) by eauto.
        eauto.
    }
    { intros k cntk'.
      split.
      { intros j cntj'.
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        - subst.
          intros b' ofs'.
          rewrite gssThreadRes.
          destruct (j == k) eqn:Hjk; move/eqP:Hjk=>Hjk.
          { subst.
            rewrite gssThreadRes.
            destruct (Pos.eq_dec b b').
            - subst.
              destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
              + rewrite! setPermBlock_same; auto.

                simpl; auto.
              + apply Intv.range_notin in n;
                  try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
                rewrite! setPermBlock_other_1; eauto.
                specialize ((thread_data_lock_coh0 _ cnti).1 _ cnti b' ofs');
                  now eauto.
            - rewrite! setPermBlock_other_2; eauto.
              specialize ((thread_data_lock_coh0 _ cnti).1 _ cnti b' ofs');
                now eauto.
          }
          { subst tp'.
            pose proof (cntUpdate' _ _ _ cntk') as cntk.
            erewrite gsoThreadRes with (cntj := cntk) by eauto.
            destruct (Pos.eq_dec b b').
            - subst.
              destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
              + rewrite! setPermBlock_same; auto.
                simpl.
                pose proof ((invariant_not_freeable Hinv b' ofs').1 _ cntk).
                destruct ((getThreadR cntk).2 # b' ofs') as [p|];
                  try (destruct p); simpl; auto.
              + apply Intv.range_notin in n;
                  try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
                rewrite! setPermBlock_other_1; eauto.
                specialize ((thread_data_lock_coh0 _ cntk).1 _ cnti b' ofs');
                  now eauto.
            - rewrite! setPermBlock_other_2; eauto.
              specialize ((thread_data_lock_coh0 _ cntk).1 _ cnti b' ofs');
                now eauto.
          }
        - subst tp'.
          pose proof (cntUpdate' _ _ _ cntj') as cntj.
          erewrite @gsoThreadRes with (cntj := cntj) by eauto.
          intros b' ofs'.
          destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
          + subst.
            rewrite gssThreadRes.
            destruct (Pos.eq_dec b b').
            * subst.
              destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
              rewrite! setPermBlock_same; auto.
              specialize (Hperm_thr1 _ cntj Hij ofs' i).
              simpl in Hperm_thr1.
              destruct ((getThreadR cntj).1 # b' ofs'); simpl; auto;
                inversion Hperm_thr1; subst;
                  now auto.
              apply Intv.range_notin in n;
                try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
              rewrite! setPermBlock_other_1; eauto.
              specialize ((thread_data_lock_coh0 _ cnti).1 _ cntj b' ofs');
                now eauto.
            * rewrite! setPermBlock_other_2; eauto.
              specialize ((thread_data_lock_coh0 _ cnti).1 _ cntj b' ofs');
                now eauto.
          + pose proof (cntUpdate' _ _ _ cntk') as cntk.
            rewrite gsoThreadRes; eauto.
            now eapply ((thread_data_lock_coh0 _ cntk).1 _ cntj b' ofs').
      }
      { intros laddr rmap Hres.
        subst tp'.
        rewrite gsoThreadLPool in Hres.
        intros b' ofs'.
        destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik; subst.
        - rewrite gssThreadRes.
          destruct (Pos.eq_dec b b').
          + subst.
            destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
            * rewrite! setPermBlock_same; auto.
              specialize (Hperm_res1 _ _ Hres ofs' i).
              simpl in Hperm_res1.
              destruct (rmap.1 # b' ofs'); simpl; auto;
                inversion Hperm_res1; subst;
                  now auto.
            * apply Intv.range_notin in n;
                try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
              rewrite! setPermBlock_other_1; eauto.
              specialize ((thread_data_lock_coh0 _ cnti).2 _ _ Hres b' ofs');
                now eauto.
          + rewrite! setPermBlock_other_2; eauto.
            specialize ((thread_data_lock_coh0 _ cnti).2 _ _ Hres b' ofs');
              now eauto.
        - pose proof (cntUpdate' _ _ _ cntk') as cntk.
          erewrite gsoThreadRes with (cntj := cntk) by eauto.
          now eapply ((thread_data_lock_coh0 _ cntk).2 _ _ Hres b' ofs').
      }
    }
    { intros laddr rmap Hres.
      subst tp'.
      rewrite gsoThreadLPool in Hres.
      split.
      - intros j cntj'.
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij; subst.
        + rewrite gssThreadRes.
          intros b' ofs'.
          destruct (Pos.eq_dec b b').
          * subst.
            destruct (Intv.In_dec ofs' (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
            rewrite! setPermBlock_same; auto.
            pose proof ((invariant_not_freeable Hinv b' ofs').2 _ _ Hres).
            simpl;
              destruct (rmap.2 # b' ofs') as [p|];
              try (destruct p);
              by auto.
            apply Intv.range_notin in n;
              try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
            rewrite! setPermBlock_other_1; eauto.
            specialize ((locks_data_lock_coh0 _ _ Hres).1 _ cnti b' ofs');
              now eauto.
          * rewrite! setPermBlock_other_2; eauto.
            specialize ((locks_data_lock_coh0 _ _ Hres).1 _ cnti b' ofs');
              now eauto.
        + pose proof (cntUpdate' _ _ _ cntj') as cntj.
          erewrite @gsoThreadRes with (cntj := cntj) by eauto.
          now eapply ((locks_data_lock_coh0 _ _ Hres).1 _ cntj).
      - intros laddr' rmap' Hres'.
        rewrite gsoThreadLPool in Hres'.
        eapply locks_data_lock_coh0;
          by eauto.
    }
    { subst tp'.
      intros b' ofs'.
      rewrite gsoThreadLPool.
      destruct (lockRes tp (b', ofs')) eqn:Hres; auto.
      specialize (lockRes_valid0 b' ofs').
      rewrite Hres in lockRes_valid0.
      intros.
      rewrite gsoThreadLPool.
      now eauto.
    }
  Qed.

  Lemma invariant_spawn:
    forall (tpc tpf : thread_pool) (mc mf : mem) f
      i (pff : containsThread tpf i) (pfc : containsThread tpc i)
      (HmemCompC : mem_compatible tpc mc)
      (HmemCompF : mem_compatible tpf mf)
      virtue1 virtue2  c cf vf vff arg arg',
      let threadPerm' := (computeMap (getThreadR pfc).1 virtue1.1,
                          computeMap (getThreadR pfc).2 virtue1.2) in
      let threadPermF' := (computeMap (getThreadR pff).1 (projectAngel f virtue1.1),
                           computeMap (getThreadR pff).2 (projectAngel f virtue1.2)) in
      let newThreadPerm := (computeMap empty_map virtue2#1, computeMap empty_map virtue2#2) in
      let newThreadPermF := (computeMap empty_map (projectAngel f virtue2#1),
                             computeMap empty_map (projectAngel f virtue2#2)) in
      forall
        (HinvF: invariant tpf)
        (HinvC': invariant
                   (addThread
                      (updThread pfc c threadPerm') vf arg newThreadPerm))
        (HsimWeak: forall tid (pfc0 : containsThread tpc tid)
                     (pff0 : containsThread tpf tid),
            weak_tsim f pfc0 pff0 HmemCompC HmemCompF)
        (Htsim_data: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).1)
                                (restrPermMap (compat_th _ _ HmemCompF pff).1))
        (Htsim_locks: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).2)
                                 (restrPermMap (compat_th _ _ HmemCompF pff).2))
        (HnumThreads: forall i, containsThread tpc i <-> containsThread tpf i)
        (Hlock_mapped: forall (bl2 : block) (ofs : Z),
            lockRes tpf (bl2, ofs) ->
            exists bl1 : block, f bl1 = Some bl2)
        (HsimRes:
           forall (bl1 bl2 : block) (ofs : Z)
             rmap1 rmap2,
             f bl1 = Some bl2 ->
             forall (Hl1 : lockRes tpc (bl1, ofs) = Some rmap1)
               (Hl2 : lockRes tpf (bl2, ofs) = Some rmap2),
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).1)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).1) /\
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).2)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).2))
        (Hunmapped_res: forall (bl : block) (ofsl : Z) rmap,
            lockRes tpf (bl, ofsl) = Some rmap ->
            forall b2 : block,
              ~ (exists b1 : block, f b1 = Some b2) ->
              forall ofs : Z,
                (rmap#1) # b2 ofs = None /\ (rmap#2) # b2 ofs = None)
        (Hlock_if: forall (bl1 bl2 : block) (ofs : Z),
            f bl1 = Some bl2 ->
            lockRes tpc (bl1, ofs) <-> lockRes tpf (bl2, ofs)),
        invariant
          (addThread
             (updThread pff cf threadPermF') vff arg'
             newThreadPermF).
  Proof.
    intros.
    pose proof (injective (weak_obs_eq Htsim_data)) as Hinjective.
    assert (Hnum: OrdinalPool.num_threads tpc = OrdinalPool.num_threads tpf)
      by (eapply OrdinalPool.contains_iff_num; eauto).
    Transparent containsThread OrdinalPool.containsThread.
    assert (Hthreads: forall k, containsThread (addThread (updThread pff cf threadPermF')
                                                     vff arg' newThreadPermF) k <->
                           containsThread (addThread (updThread pfc c threadPerm') vf arg newThreadPerm) k)
      by (intros j;
          split;
            intros cntj;
            apply cntAdd' in cntj;
            destruct cntj as [[cntj _] | Heq];
            try (apply cntAdd;
                  apply cntUpdate;
                  apply HnumThreads;
                    by apply cntUpdate' in cntj);
            try (unfold containsThread;
                 subst; simpl; unfold OrdinalPool.containsThread;
                 unfold OrdinalPool.latestThread, OrdinalPool.updThread;
                 simpl; rewrite Hnum;
                   by ssromega)).
    Opaque containsThread OrdinalPool.containsThread.
    assert (Hthread_mapped:
              forall k (pfck': containsThread (addThread (updThread pfc c threadPerm') vf arg newThreadPerm) k)
                (pffk': containsThread (addThread (updThread pff cf threadPermF') vff arg' newThreadPermF) k),
              forall b1 b2 ofs,
                f b1 = Some b2 ->
                Mem.perm_order'' ((getThreadR pfck').1 # b1 ofs) ((getThreadR pffk').1 # b2 ofs) /\
                Mem.perm_order'' ((getThreadR pfck').2 # b1 ofs) ((getThreadR pffk').2 # b2 ofs)).
    { intros.
      assert (Hcnt := cntAdd' _ _ _ pffk').
      destruct Hcnt as [[pffk Hneqk] | Hk].
      - erewrite gsoAddRes with (cntj := pffk); eauto.
        assert (pfck: containsThread (updThread pfc c threadPerm') k)
          by (eapply cntUpdate; eauto; eapply HnumThreads; eauto).
        erewrite gsoAddRes with (cntj := pfck).
        destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
        + subst.
          rewrite! gssThreadRes.
          simpl.
          erewrite! computeMap_projection_1 by eauto.
          split; now apply po_refl.
        + rewrite! gsoThreadRes; auto.
          destruct (HsimWeak _ pfck pffk).
          destruct weak_tsim_data0.
          specialize (perm_obs_weak0 _ _ ofs H).
          rewrite! restrPermMap_Cur in perm_obs_weak0.
          destruct weak_tsim_locks0.
          specialize (perm_obs_weak1 _ _ ofs H).
          rewrite! restrPermMap_Cur in perm_obs_weak1;
            by eauto.
      - subst.
        erewrite gssAddRes by
            (unfold latestThread; simpl; unfold OrdinalPool.latestThread, OrdinalPool.updThread; simpl; by rewrite Hnum).
        erewrite gssAddRes by
            reflexivity.
        simpl.
        erewrite! computeMap_projection_3 by eauto;
          split;
          now apply po_refl.
    }
    assert (Hthread_unmapped:
              forall k
                (pffk': containsThread (addThread (updThread pff cf threadPermF') vff arg' newThreadPermF) k),
               forall b2 ofs,
                 (~exists b1, f b1 = Some b2) ->
                 (exists (pffk: containsThread tpf k),
                  ((getThreadR pffk').1 # b2 ofs = (getThreadR pffk).1 # b2 ofs) /\
                  ((getThreadR pffk').2 # b2 ofs = (getThreadR pffk).2 # b2 ofs)) \/
                 ((getThreadR pffk').1 # b2 ofs = None /\ (getThreadR pffk').2 # b2 ofs = None)).
    { intros k pffk' b0 ofs0 Hunmmaped.
      assert (Hcnt := cntAdd' _ _ _ pffk').
      destruct Hcnt as [[pffk Hneqk] | Hk].
      - erewrite gsoAddRes with (cntj := pffk); eauto.
        destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
        + subst.
          rewrite! gssThreadRes.
          simpl.
          Tactics.pf_cleanup.
          left. exists pff.
          erewrite! computeMap_projection_2 by eauto.
          split;
            reflexivity.
        + left.
          exists pffk.
          rewrite! gsoThreadRes;
            by auto.
      - subst.
        right.
        erewrite gssAddRes
          by (unfold latestThread; reflexivity).
        simpl.
        erewrite! computeMap_projection_2 by eauto.
        split;
          now apply empty_map_spec.
    }
    destruct HinvC'.
    assert (Hlocks: forall laddrF rmapF (HresF: lockRes tpf laddrF = Some rmapF),
               exists bc rmap,
                 lockRes tpc (bc, laddrF.2) = Some rmap /\ f bc = Some laddrF.1 /\
                 forall b1 b2 ofs,
                   f b1 = Some b2 ->
                   Mem.perm_order'' (rmap.1 # b1 ofs) (rmapF.1 # b2 ofs) /\
                   Mem.perm_order'' (rmap.2 # b1 ofs) (rmapF.2 # b2 ofs)).
    { intros.
      destruct laddrF as [bl ofsl].
      specialize (Hlock_mapped bl ofsl).
      unfold isSome in Hlock_mapped.
      rewrite HresF in Hlock_mapped.
      specialize (Hlock_mapped (Logic.eq_refl _)).
      destruct Hlock_mapped as [bl1 Hfbl1].
      specialize (Hlock_if _ _ ofsl Hfbl1).
      destruct (lockRes tpc (bl1, ofsl)) as [rmapC |] eqn:Hres.
      + exists bl1, rmapC.
        split; auto. split; auto.
        intros b0 b3 ofs0 Hrenaming.
        specialize (HsimRes _ _ _ _ _ Hfbl1 Hres HresF).
        destruct HsimRes as [[Hperm1 _] [Hperm2 _]].
        specialize (Hperm1 _ _ ofs0 Hrenaming).
        specialize (Hperm2 _ _ ofs0 Hrenaming).
        rewrite! restrPermMap_Cur in Hperm1 Hperm2.
        rewrite Hperm1 Hperm2.
        split; now apply po_refl.
      + exfalso. erewrite HresF in Hlock_if.
        simpl in Hlock_if.
        destruct Hlock_if; now auto.
    }

    constructor.
    { 
      intros.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros b2 ofs.
      assert (Hb2: (exists b1, f b1 = Some b2) \/
                   ~ (exists b1, f b1 = Some b2))
        by eapply em.
      destruct Hb2 as [[b1 Hf] | Hunmapped].
      - pose proof ((Hthreads i0).1 cnti) as pfci0.
        pose proof ((Hthreads j).1 cntj) as pfcj0.
        specialize (no_race_thr0 _ _ pfci0 pfcj0 Hneq).
        unfold permMapsDisjoint2, permMapsDisjoint in no_race_thr0.
        erewrite <- forall2_and in no_race_thr0.
        destruct (no_race_thr0 b1 ofs).
        destruct (Hthread_mapped _ pfci0 cnti b1 b2 ofs Hf).
        destruct (Hthread_mapped _ pfcj0 cntj b1 b2 ofs Hf).
        split.
        eapply perm_union_lower_2
        with (p1 := ((getThreadR pfci0)#1) # b1 ofs); eauto.
        eapply perm_union_lower_2
        with (p1 := ((getThreadR pfci0)#2) # b1 ofs); eauto.
      - destruct (Hthread_unmapped i0 cnti b2 ofs Hunmapped) as [[pffi0 [Heq1 Heq2]]| [Heq1 Heq2]].
        + destruct (Hthread_unmapped j cntj b2 ofs Hunmapped) as [[pffj0 [Heq3 Heq4]]| [Heq3 Heq4]].
          rewrite Heq1 Heq2 Heq3 Heq4.
          pose proof (no_race_thr _ HinvF _ _ pffi0 pffj0 Hneq) as Hno_race.
          unfold permMapsDisjoint2, permMapsDisjoint in Hno_race.
          destruct Hno_race.
          now eauto.
          rewrite Heq3 Heq4.
          split;
            rewrite perm_union_comm;
            apply not_racy_union;
            now constructor.
        + rewrite Heq1 Heq2.
          split; apply not_racy_union;
          now constructor.
    }
    { 
      intros.
      erewrite gsoAddLPool, gsoThreadLPool in Hres1, Hres2.
      eapply HinvF;
        by eauto.
    }
    { intros.
      rewrite gsoAddLPool gsoThreadLPool in Hres.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and. intros b2 ofs.
      assert (Hb2: (exists b1, f b1 = Some b2) \/
                   ~ (exists b1, f b1 = Some b2))
        by eapply em.
      destruct Hb2 as [[b1 Hf] | Hunmapped].
      - destruct (Hlocks _ _ Hres) as [bc [rmapC [HresC [Hfl Hperm]]]].
        destruct (Hperm _ _ ofs Hf).
        pose proof ((Hthreads i0).1 cnti) as pfci0.
        destruct (Hthread_mapped _ pfci0 cnti _ _ ofs Hf).
        pose proof (no_race0 _ _ pfci0 _ HresC) as Hno_race.
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_race.
        erewrite <- forall2_and in Hno_race.
        destruct (Hno_race b1 ofs).
        split.
        eapply perm_union_lower_2 with (p1 := (getThreadR pfci0).1 # b1 ofs); eauto.
        eapply perm_union_lower_2 with (p1 := (getThreadR pfci0).2 # b1 ofs); eauto.
      - destruct laddr.
        rewrite (Hunmapped_res _ _ _ Hres _ Hunmapped ofs).1.
        rewrite (Hunmapped_res _ _ _ Hres _ Hunmapped ofs).2.
        split; rewrite perm_union_comm; eapply not_racy_union;
        now constructor.
    }
    { 
      intros.
      split.
      - intros.
        intros b2 ofs.
        assert (Hb2: (exists b1, f b1 = Some b2) \/
                     ~ (exists b1, f b1 = Some b2))
          by eapply em.
        destruct Hb2 as [[b1 Hf] | Hunmapped].
        + pose proof ((Hthreads i0).1 cnti) as pfci0.
          pose proof ((Hthreads j).1 cntj) as pfcj0.
          destruct (Hthread_mapped _ pfci0 cnti _ _ ofs Hf).
          destruct (Hthread_mapped _ pfcj0 cntj _ _ ofs Hf).
          pose proof ((thread_data_lock_coh0 _ pfci0).1 _ pfcj0 b1 ofs).
          eapply perm_coh_lower; eauto.
        + destruct (Hthread_unmapped i0 cnti b2 ofs Hunmapped) as [[pffi0 [Heq1 Heq2]]| [Heq1 Heq2]].
          * destruct (Hthread_unmapped j cntj b2 ofs Hunmapped)
              as [[pffj0 [Heq3 Heq4]]| [Heq3 Heq4]].
            rewrite Heq2 Heq3.
            pose proof ((thread_data_lock_coh _ HinvF _ pffi0).1 _ pffj0) as Hno_race.
            now eauto.
            rewrite Heq2 Heq3.
            pose proof ((invariant_not_freeable HinvF b2 ofs).1 _ pffi0).
            simpl.
            destruct ((getThreadR pffi0).2 # b2 ofs) as [p|];
              try (destruct p); auto.
          * rewrite Heq2.
            now apply perm_coh_empty_1.
      - intros.
        intros b2 ofs.
        rewrite gsoAddLPool gsoThreadLPool in H.
        assert (Hb2: (exists b1, f b1 = Some b2) \/
                     ~ (exists b1, f b1 = Some b2))
          by eapply em.
        destruct Hb2 as [[b1 Hf] | Hunmapped].
        + pose proof ((Hthreads i0).1 cnti) as pfci0.
          destruct (Hthread_mapped _ pfci0 cnti _ _ ofs Hf).
          destruct (Hlocks _ _ H) as [bc [rmapC [HresC [Hfl Hperm]]]].
          destruct (Hperm _ _ ofs Hf).
          pose proof ((thread_data_lock_coh0 _ pfci0).2 _ _ HresC b1 ofs) as Hno_race.
          eapply perm_coh_lower; eauto.
        + destruct laddr.
          rewrite (Hunmapped_res _ _ _ H _ Hunmapped ofs).1.
          destruct (Hthread_unmapped i0 cnti b2 ofs Hunmapped) as [[pffi0 [Heq1 Heq2]]
                                                                  | [Heq1 Heq2]].
          * rewrite Heq2.
            pose proof ((invariant_not_freeable HinvF b2 ofs).1 _ pffi0).
            destruct ((getThreadR pffi0).2 # b2 ofs) as [p|];
              try (destruct p); by auto.
          * rewrite Heq2.
            now apply perm_coh_empty_1.
    }
    { 
      intros.
      rewrite gsoAddLPool gsoThreadLPool in Hres.
      split.
      - intros j cntj b2 ofs.
        pose proof ((Hthreads j).1 cntj) as pfcj0.
        assert (Hb2: (exists b1, f b1 = Some b2) \/
                     ~ (exists b1, f b1 = Some b2))
          by eapply em.
        destruct Hb2 as [[b1 Hf] | Hunmapped].
        + destruct (Hthread_mapped _ pfcj0 cntj _ _ ofs Hf).
          destruct (Hlocks _ _ Hres) as [bc [rmapC [HresC [Hfl Hperm]]]].
          destruct (Hperm _ _ ofs Hf).
          pose proof ((locks_data_lock_coh0 _ _ HresC).1 _ pfcj0 b1 ofs).
          eapply perm_coh_lower; eauto.
        + destruct laddr.
          rewrite (Hunmapped_res _ _ _ Hres _ Hunmapped ofs).2.
          now apply perm_coh_empty_1.
      - intros laddr' rmap' Hres'.
        rewrite gsoAddLPool gsoThreadLPool in Hres'.
        eapply HinvF; eauto.
    }
    { 
      intros b ofs.
      rewrite gsoAddLPool gsoThreadLPool.
      pose proof (lockRes_valid _ HinvF).
      specialize (H b ofs).
      now eauto.
    }
  Qed.

  Lemma invariant_freelock:
    forall tpc tpf mc mf f c cf b1 b2 ofs pdata i
      (Hf: f b1 = Some b2)
      (pfc: containsThread tpc i)
      (pff: containsThread tpf i),
      let tpc' := remLockSet
                    (updThread pfc c
                               (setPermBlock_var pdata b1 ofs (getThreadR pfc)#1 lksize.LKSIZE_nat,
                                setPermBlock None b1 ofs
                                             (getThreadR pfc)#2 lksize.LKSIZE_nat)) (b1,ofs) in
      let tpf' := remLockSet (updThread pff cf
                                        (setPermBlock_var pdata b2 ofs (getThreadR pff)#1 lksize.LKSIZE_nat,
                                         setPermBlock None b2 ofs
                                                      (getThreadR pff)#2 lksize.LKSIZE_nat)) (b2, ofs) in
      forall
        (HinvF: invariant tpf)
        (HinvC': invariant tpc')
        (HmemCompC: mem_compatible tpc mc)
        (HmemCompF: mem_compatible tpf mf)
        (HsimWeak: forall tid (pfc0 : containsThread tpc tid)
                     (pff0 : containsThread tpf tid),
            weak_tsim f pfc0 pff0 HmemCompC HmemCompF)
        (Htsim: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).1)
                           (restrPermMap (compat_th _ _ HmemCompF pff).1))
        (HtsimL: mem_obs_eq f (restrPermMap (compat_th _ _ HmemCompC pfc).2)
                            (restrPermMap (compat_th _ _ HmemCompF pff).2))
        (Hneq_perms: forall i,
            (0 <= Z.of_nat i < lksize.LKSIZE)%Z ->
            Mem.perm_order'' (pdata (S i)) (Some Writable)
        )
        (Hlocks: forall (bl2 : block) (ofs : Z),
            lockRes tpf (bl2, ofs) ->
            exists bl1 : block, f bl1 = Some bl2)
        (HsimRes:
           forall (bl1 bl2 : block) (ofs : Z)
             rmap1 rmap2,
             f bl1 = Some bl2 ->
             forall (Hl1 : lockRes tpc (bl1, ofs) = Some rmap1)
               (Hl2 : lockRes tpf (bl2, ofs) = Some rmap2),
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).1)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).1) /\
               strong_mem_obs_eq f
                                 (restrPermMap (compat_lp _ _ HmemCompC (bl1, ofs) _ Hl1).2)
                                 (restrPermMap (compat_lp _ _ HmemCompF (bl2, ofs) _ Hl2).2))
        (Hlock_if: forall (bl1 bl2 : block) (ofs : Z),
            f bl1 = Some bl2 ->
            lockRes tpc (bl1, ofs) <-> lockRes tpf (bl2, ofs))
        (HnumThreads: forall i, containsThread tpc i <-> containsThread tpf i),
        invariant tpf'.
  Proof.
    intros.
    assert (HnumThreads': forall i, containsThread tpc' i <-> containsThread tpf' i)
      by (intros; subst tpc' tpf'; split; intros Hcnt; apply cntRemoveL;
          apply cntUpdate;
          apply cntRemoveL' in Hcnt;
          apply cntUpdate' in Hcnt; apply HnumThreads; now auto).
    assert (Hthread_mapped: forall k (pfck': containsThread tpc' k) (pffk': containsThread tpf' k),
               forall b1 b2 ofs,
                 f b1 = Some b2 ->
                 Mem.perm_order'' ((getThreadR pfck').1 # b1 ofs) ((getThreadR pffk').1 # b2 ofs) /\
                 Mem.perm_order'' ((getThreadR pfck').2 # b1 ofs) ((getThreadR pffk').2 # b2 ofs)).
    { intros.
      destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik; subst.
      - rewrite! gRemLockSetRes.
        rewrite! gssThreadRes.
        destruct (HsimWeak _ pfc pff).
        destruct weak_tsim_data0.
        destruct weak_tsim_locks0.
        specialize (perm_obs_weak0 _ _ ofs0 H).
        specialize (perm_obs_weak1 _ _ ofs0 H).
        rewrite! restrPermMap_Cur in perm_obs_weak0.
        rewrite! restrPermMap_Cur in perm_obs_weak1.
        destruct (Pos.eq_dec b1 b0).
        + subst.
          assert (b2 = b3)
            by (rewrite Hf in H; inversion H; subst; auto); subst.
          destruct (Intv.In_dec ofs0 (ofs, ofs + Z.of_nat (lksize.LKSIZE_nat))%Z).
          * rewrite! setPermBlock_same; auto.
            rewrite! setPermBlock_var_same; auto.
            split; now apply po_refl.
          * apply Intv.range_notin in n;
              try (simpl; eapply Z.lt_add_pos_r; now apply lksize.LKSIZE_pos).
            rewrite! setPermBlock_other_1; auto.
            rewrite! setPermBlock_var_other_1; auto.
        + assert (b2 <> b3)
            by (intros Hcontra; subst;
                specialize (injective1 _ _ _ Hf H);
                auto).
          rewrite! setPermBlock_other_2; auto.
          rewrite! setPermBlock_var_other_2; now auto.
      - assert (pfck :=cntUpdate' _  _ _ (cntRemoveL' _ pfck')).
        subst tpf' tpc'.
        assert (pffk := cntUpdate' _ _ _ (cntRemoveL' _ pffk')).
        rewrite! gRemLockSetRes.
        erewrite! gsoThreadRes with (cntj := pfck) by eauto.
        erewrite! gsoThreadRes with (cntj := pffk) by eauto.
        destruct (HsimWeak _ pfck pffk).
        destruct weak_tsim_data0.
        destruct weak_tsim_locks0.
        specialize (perm_obs_weak0 _ _ ofs0 H).
        specialize (perm_obs_weak1 _ _ ofs0 H).
        rewrite! restrPermMap_Cur in perm_obs_weak0.
        rewrite! restrPermMap_Cur in perm_obs_weak1.
        split; now assumption.
    }
    assert (Hthread_unmapped: forall k (pffk: containsThread tpf k)(pffk': containsThread tpf' k),
               forall b2 ofs,
                 (~exists b1, f b1 = Some b2) ->
                 ((getThreadR pffk').1 # b2 ofs = (getThreadR pffk).1 # b2 ofs) /\
                 ((getThreadR pffk').2 # b2 ofs = (getThreadR pffk).2 # b2 ofs)).
    { intros k pffk pffk' b0 ofs0 Hunmmaped.
      rewrite gRemLockSetRes.
      destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik; subst.
      - rewrite! gssThreadRes.
        assert (b2 <> b0)
          by (intros Hcontra; subst; eauto).
        rewrite! setPermBlock_other_2; auto.
        rewrite! setPermBlock_var_other_2; auto.
        Tactics.pf_cleanup.
        split; reflexivity.
      - subst tpf'. erewrite! gsoThreadRes with (cntj := pffk) by eauto.
        split; reflexivity.
    }

    assert (Hlock_mapped: forall laddrF rmapF (HresF: lockRes tpf' laddrF = Some rmapF),
               exists bc rmap,
                 lockRes tpc' (bc, laddrF.2) = Some rmap /\ f bc = Some laddrF.1 /\
                 forall b1 b2 ofs,
                   f b1 = Some b2 ->
                   rmap.1 # b1 ofs = rmapF.1 # b2 ofs /\
                   rmap.2 # b1 ofs = rmapF.2 # b2 ofs).
    { intros.
      subst tpf' tpc'.
      destruct laddrF as [bl ofsl].
      destruct (EqDec_address (b2, ofs) (bl, ofsl)).
      - inversion e; subst.
        rewrite gsslockResRemLock in HresF.
        discriminate.
      - erewrite gsolockResRemLock in HresF by eauto.
        erewrite gsoThreadLPool in HresF.
        specialize (Hlocks bl ofsl).
        unfold isSome in Hlocks.
        rewrite HresF in Hlocks.
        specialize (Hlocks (Logic.eq_refl _)).
        destruct Hlocks as [bl1 Hfbl1].
        specialize (Hlock_if _ _ ofsl Hfbl1).
        destruct (lockRes tpc (bl1, ofsl)) as [rmapC |] eqn:Hres.
        + exists bl1, rmapC.
          assert ((b1, ofs) <> (bl1, ofsl))
            by (intros Hcontra; inversion Hcontra; subst;
                rewrite Hfbl1 in Hf; inversion Hf; subst; auto).
          erewrite gsolockResRemLock by eauto.
          erewrite gsoThreadLPool by eauto.
          split; auto. split; auto.
          intros b0 b3 ofs0 Hrenaming.
          specialize (HsimRes _ _ _ _ _ Hfbl1 Hres HresF).
          destruct HsimRes as [[Hperm1 _] [Hperm2 _]].
          specialize (Hperm1 _ _ ofs0 Hrenaming).
          specialize (Hperm2 _ _ ofs0 Hrenaming).
          rewrite! restrPermMap_Cur in Hperm1 Hperm2.
          rewrite Hperm1 Hperm2.
          split; reflexivity.
        + exfalso. erewrite HresF in Hlock_if.
          simpl in Hlock_if.
          destruct Hlock_if; now auto.
    }

    assert (Hlock_eq: forall laddrF rmapF (HresF: lockRes tpf' laddrF = Some rmapF),
               lockRes tpf laddrF = Some rmapF).
    { intros (bl & ofsl) rmapF HresF'.
      subst tpf'.
      destruct (EqDec_address (b2, ofs) (bl, ofsl)).
      inversion e; subst. rewrite gsslockResRemLock in HresF'.
      discriminate.
      erewrite gsolockResRemLock in HresF' by eauto.
      erewrite gsoThreadLPool in HresF'.
      assumption.
    }
    constructor.
    { 
      
      assert (Hno_raceC:= no_race_thr _ HinvC').
      assert (Hno_raceF:= no_race_thr _ HinvF).
      intros k j pffk' pffj' Hkj.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros bf ofs0.
      assert (Hbf: (exists b1, f b1 = Some bf) \/
                   ~ (exists b1, f b1 = Some bf))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - assert (pfck': containsThread tpc' k)
          by (apply HnumThreads' in pffk'; auto).
        assert (pfcj': containsThread tpc' j)
          by (apply HnumThreads' in pffj'; auto).
        specialize (Hno_raceC _ _ pfck' pfcj' Hkj).
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_raceC.
        erewrite <- forall2_and in Hno_raceC.
        destruct (Hno_raceC b ofs0) as [HpermD HpermL].
        pose proof (Hthread_mapped _ pfck' pffk' b bf ofs0 Hbfm) as Hk.
        destruct Hk as [HkD HkL].
        pose proof (Hthread_mapped _ pfcj' pffj' b bf ofs0 Hbfm) as Hj.
        destruct Hj as [HjD HjL].
        split;
          eapply perm_union_lower; eauto;
            rewrite perm_union_comm;
            eapply perm_union_lower; eauto;
              rewrite perm_union_comm; eauto.
      - assert (pffk: containsThread tpf k)
          by (apply cntRemoveL' in pffk';
              apply cntUpdate' in pffk'; auto).
        assert (pffj: containsThread tpf j)
          by (apply cntRemoveL' in pffj';
              apply cntUpdate' in pffj'; auto).
        erewrite (Hthread_unmapped _ pffk pffk' bf ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffk pffk' bf ofs0 Hbfu).2.
        erewrite (Hthread_unmapped _ pffj pffj' bf ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffj pffj' bf ofs0 Hbfu).2.
        specialize (Hno_raceF _ _ pffk pffj Hkj).
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_raceF.
        erewrite <- forall2_and in Hno_raceF.
        now eauto.
    }
    { 
      intros laddr1 laddr2 rmap0 rmap2 Hneq Hres0 Hres2.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros bf ofs0.
      assert (Hbf: (exists b1, f b1 = Some bf) \/
                   ~ (exists b1, f b1 = Some bf))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - destruct (Hlock_mapped _ _ Hres0) as [bc1 [rmap0C [HresC [Hfl1 Hperm0]]]].
        destruct (Hperm0 _ _ ofs0 Hbfm) as [H1 H2].
        destruct (Hlock_mapped _ _ Hres2) as [bc2 [rmap2C [Hres2C [Hfl2 Hperm2]]]].
        destruct (Hperm2 _ _ ofs0 Hbfm) as [H3 H4].
        assert (HneqC: (bc1, laddr1.2) <> (bc2, laddr2.2)) by
            (intros Hcontra;
             inversion Hcontra; subst;
             rewrite Hfl1 in Hfl2; inversion Hfl2;
             destruct laddr1, laddr2; simpl in *; subst;
             now auto).
        pose proof (no_race_lr _ HinvC' _ _ _ _ HneqC HresC Hres2C) as Hdisjoint.
        unfold permMapsDisjoint2, permMapsDisjoint in Hdisjoint.
        erewrite <- forall2_and in Hdisjoint.
        rewrite <- H1, <- H2, <- H3, <- H4.
        destruct (Hdisjoint b ofs0).
        now auto.
      - subst tpf'.
        pose proof (Hlock_eq _ _ Hres0) as Heq0.
        pose proof (Hlock_eq _ _ Hres2) as Heq2.
        pose proof (no_race_lr _ HinvF  _ _ _ _ Hneq Heq0 Heq2) as Hdisjoint.
        unfold permMapsDisjoint2, permMapsDisjoint in Hdisjoint.
        erewrite <- forall2_and in Hdisjoint.
        now eauto.
    }
    { 
      intros k laddrF pffk' rmapF HresF.
      unfold permMapsDisjoint2, permMapsDisjoint.
      erewrite <- forall2_and.
      intros b0 ofs0.
      assert (Hbf: (exists b1, f b1 = Some b0) \/
                   ~ (exists b1, f b1 = Some b0))
        by eapply em.
      destruct Hbf as [[b Hbfm] | Hbfu].
      - assert (pfck': containsThread tpc' k)
          by (apply HnumThreads' in pffk'; auto).
        destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
        destruct (HpermC _ _ ofs0 Hbfm).
        pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
        destruct Hk as [HkD HkL].
        pose proof (no_race _ HinvC' _ _ pfck' _ HresC).
        unfold permMapsDisjoint2, permMapsDisjoint in H1.
        erewrite <- forall2_and in H1.
        destruct (H1 b ofs0).
        rewrite <- H, <- H0.
        split.
        eapply perm_union_lower_2 with (p1 := (getThreadR pfck').1 # b ofs0); eauto using po_refl.
        eapply perm_union_lower_2 with (p1 := (getThreadR pfck').2 # b ofs0); eauto using po_refl.
      - assert (pffk: containsThread tpf k)
          by (apply cntRemoveL' in pffk';
              apply cntUpdate' in pffk'; auto).
        erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).1.
        erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
        subst tpf'.
        pose proof (Hlock_eq _ _ HresF) as Heq0.
        pose proof ((no_race _ HinvF) _ _ pffk _ Heq0) as Hno_race.
        unfold permMapsDisjoint2, permMapsDisjoint in Hno_race.
        erewrite <- forall2_and in Hno_race.
        now eauto.
    }
    { 
      intros k pffk'.
      split.
      - intros j pffj' b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfck': containsThread tpc' k)
            by (apply HnumThreads' in pffk'; auto).
          assert (pfcj': containsThread tpc' j)
            by (apply HnumThreads' in pffj'; auto).
          pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
          destruct Hk as [_ HkL].
          pose proof (Hthread_mapped _ pfcj' pffj' b b0 ofs0 Hbfm) as Hj.
          destruct Hj as [HjD].
          pose proof ((thread_data_lock_coh _ HinvC' _ pfck').1 _ pfcj' b ofs0).
          eapply perm_coh_lower;
            now eauto.
        + assert (pffj: containsThread tpf j)
            by (apply cntRemoveL' in pffj';
                apply cntUpdate' in pffj'; auto).
          erewrite (Hthread_unmapped _ pffj pffj' b0 ofs0 Hbfu).1.
          assert (pffk: containsThread tpf k)
            by (apply cntRemoveL' in pffk';
                apply cntUpdate' in pffk'; auto).
          erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
          now eapply ((thread_data_lock_coh _ HinvF _ pffk).1 _ pffj b0 ofs0).
      - intros laddrF rmapF HresF b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfck': containsThread tpc' k)
            by (apply HnumThreads' in pffk'; auto).
          pose proof (Hthread_mapped _ pfck' pffk' b b0 ofs0 Hbfm) as Hk.
          destruct Hk as [_ HkL].
          destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          pose proof ((thread_data_lock_coh _ HinvC' _ pfck').2 _ _ HresC b ofs0).
          rewrite <- H.
          eapply perm_coh_lower with (p2 := (getThreadR pfck').2 # b ofs0);
            now eauto using po_refl.
        + assert (pffk: containsThread tpf k)
            by (apply cntRemoveL' in pffk';
                apply cntUpdate' in pffk'; auto).
          erewrite (Hthread_unmapped _ pffk pffk' b0 ofs0 Hbfu).2.
          subst tpf'.
          pose proof (Hlock_eq _ _ HresF) as Heq0.
          pose proof ((thread_data_lock_coh _ HinvF _ pffk).2 _ _ Heq0 b0 ofs0) as Hno_race.
          now eauto.
    }
    { 
      intros laddrF rmapF HresF.
      split.
      - intros j pffj' b0 ofs0.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + assert (pfcj': containsThread tpc' j)
            by (apply HnumThreads' in pffj'; auto).
          pose proof (Hthread_mapped _ pfcj' pffj' b b0 ofs0 Hbfm).1 as Hj.
          destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          pose proof ((locks_data_lock_coh _ HinvC' _ _ HresC).1 _ pfcj' b ofs0).
          rewrite <- H0.
          eapply perm_coh_lower;
            now eauto using po_refl.
        + assert (pffj: containsThread tpf j)
            by (apply cntRemoveL' in pffj';
                apply cntUpdate' in pffj'; auto).
          erewrite (Hthread_unmapped _ pffj pffj' b0 ofs0 Hbfu).1.
          subst tpf'.
          pose proof (Hlock_eq _ _ HresF) as Heq0.
          pose proof ((locks_data_lock_coh _ HinvF _ _ Heq0).1 _ pffj) as Hno_race.
          now eauto.
      - intros laddr2F' rmap2F' Hres2F' b0 ofs0.
        subst tpf'.
        assert (Hbf: (exists b1, f b1 = Some b0) \/
                     ~ (exists b1, f b1 = Some b0))
          by eapply em.
        destruct Hbf as [[b Hbfm] | Hbfu].
        + destruct (Hlock_mapped _ _ HresF) as [bc [rmapC [HresC [Hfl HpermC]]]].
          destruct (HpermC _ _ ofs0 Hbfm).
          destruct (Hlock_mapped _ _ Hres2F') as [bc2 [rmapC2 [HresC2 [Hfl2 HpermC2]]]].
          destruct (HpermC2 _ _ ofs0 Hbfm).
          pose proof ((locks_data_lock_coh _ HinvC' _ _ HresC).2 _ _ HresC2 b ofs0).
          rewrite <- H1, <- H0.
          assumption.
        + pose proof (Hlock_eq _ _ HresF) as Heq0.
          pose proof (Hlock_eq _ _ Hres2F') as Heq2.
          now apply ((locks_data_lock_coh _ HinvF _ _ Heq0).2 _ _ Heq2 b0 ofs0).
    }
    { subst tpc' tpf'.
      intros b' ofs'.
      destruct (EqDec_address (b2, ofs) (b', ofs')).
      - inversion e; subst.
        rewrite gsslockResRemLock. auto.
      - erewrite gsolockResRemLock by eauto.
        rewrite gsoThreadLPool.
        destruct (lockRes tpf (b', ofs')) eqn:Hres; auto.
        intros.
        pose proof (lockRes_valid _ HinvF) as Hvalid.
        specialize (Hvalid b' ofs').
        rewrite Hres in Hvalid.
        destruct (EqDec_address (b2, ofs) (b', ofs0)).
        + inversion e; subst.
          rewrite gsslockResRemLock.
          reflexivity.
        + erewrite gsolockResRemLock by eauto.
          rewrite gsoThreadLPool.
          now eauto.
    }
  Qed.

  Lemma sim_external: sim_external_def.
  Proof.
    unfold sim_external_def.
    intros.
    inversion Hsim as
        [HnumThreads HmemCompC HmemCompF HsafeC HsimWeak HfpSep HsimStrong
                     [HsimRes [Hlock_mapped Hlock_if]] HunmappedRes HinvF HmaxF
                     Hmemc_wd Htpc_wd Hge_wd [Hge_incr Hfg] Hxs HtraceSim].
    
    assert (pfc: containsThread tpc i)
      by (eapply HnumThreads; eauto).
    
    apply @not_in_filter with (xs := xs) in Hsynced.
    destruct (HsimStrong i pfc pff)
      as [tpc' [mc' [Hincr [Hsyncf [Hexec [Htsim [Hownedi [Hownedi_ls Hunmapped_ls]]]]]]]];
      clear HsimStrong.
    
    rewrite Hsynced in Hexec.
    assert (Heq: tpc = tpc' /\ mc = mc')
      by (clear -Hexec; inversion Hexec; subst; auto; simpl in HschedN; discriminate).
    destruct Heq; subst tpc' mc'; clear Hexec.
    
    specialize (Hsyncf Hsynced); subst f.
    clear Hincr.
    
    specialize (Htsim pfc HmemCompC).
        assert (HmemCompF = mem_compf Hsim)
      by (eapply proof_irr); subst.
    assert (Hvalid_mem': valid_mem (restrPermMap (compat_th _ _ HmemCompC pfc)#1))
      by (erewrite <- restrPermMap_mem_valid; eauto).
    assert (HexternalC: pfc$(restrPermMap (compat_th _ _ HmemCompC pfc).1)@ E)
      by (erewrite (stepType_inj pff pfc _  Hfg Hge_incr Hge_wd Hvalid_mem'
                           (obs_eq_data Htsim) (code_eq Htsim)); eauto).
    
    specialize (HsafeC ([:: i]) trc).
    destruct (csafe_pop_step pfc _ ltac:(eauto) HsafeC) as
        (tpc' & trc' & mc' & _ & Hstep' & Hsafe').
    
    assert (Hsafe := safeCoarse Hsim).
    assert (HinvC: invariant tpc)
      by (eapply StepLemmas.safeC_invariant with (n := (fuelF.+2 + size xs)); eauto).
    
    assert (HconcC: exists ev, syncStep true pfc HmemCompC tpc' mc' ev /\ trc' = [:: external i ev])
      by (destruct (external_step_inverse _ _ _ HexternalC Hstep') as [_ [? [? ?]]];
          eexists; eauto).
    destruct HconcC as [ev [HconcC ?]]; subst.
    assert (HmemCompC': mem_compatible tpc' mc')
      by (eapply StepLemmas.safeC_compatible with (n := (fuelF.+1 + size xs)); eauto).
    
    assert (Hdomain_f: domain_memren (fp i pfc) mc)
      by (apply (weak_obs_eq_domain_ren (weak_tsim_data (HsimWeak _ pfc pff)))).
    pose proof (injective (weak_tsim_data (HsimWeak _ pfc pff))) as Hinjective.
    
    assert (Hge_incr_id: ren_incr fg (id_ren mc))
      by (clear - Hge_incr Hfg Hdomain_f;
           eapply incr_domain_id; eauto).

    exists tpc', (trc ++ [:: external i ev]), mc'.
    
    inversion HconcC; try subst tp' tp''; try subst m'.
    { 
              assert (Hvalidb: Mem.valid_block m0 b)
          by (subst; eapply load_valid_block; eauto).
        rewrite <- Hrestrict_pmap0 in Hvalidb.
        
        destruct ((domain_valid (weak_obs_eq (obs_eq_data Htsim))) _ Hvalidb)
          as [b2 Hfb].
        assert (Hvalidb2 := (codomain_valid (weak_obs_eq (obs_eq_data Htsim))) _ _ Hfb).
        erewrite restrPermMap_valid in Hvalidb2.
        
        remember (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).2) as mf0 eqn:Hrestrict_pmapF.
        subst m0 m1.
                assert (HloadF: Mem.load Mint32 mf0 b2 (Ptrofs.intval ofs) = Some (Vint Int.one)).
        { subst mf0.
          destruct (load_val_obs _ _ _ Hload Hfb Hinjective ((strong_obs_eq (obs_eq_locks Htsim))))
            as [v2 [Hloadf Hobs_eq]].
          inversion Hobs_eq; subst.
            by auto.
        }
        assert (Hval_obs: val_obs (fp i pfc) (Vint Int.zero) (Vint Int.zero))
          by constructor.
        
        remember (setPermBlock (Some Writable) b2 (Ptrofs.intval ofs) (getThreadR pff).2 lksize.LKSIZE_nat)
          as pmap_tidF' eqn:Hset_permF.
        
        assert (HltF': permMapLt pmap_tidF' (getMaxPerm mf)).
        {
          subst.
          eapply setPermBlock_lt; eauto.
          eapply (compat_th _ _ (mem_compf Hsim) pff).2.
        }

        assert (Hobs_eq_locks: mem_obs_eq (fp i pfc) (restrPermMap Hlt') (restrPermMap HltF')).
        { subst.
          apply Mem.load_valid_access in Hload.
          destruct Hload as [Hload _]. simpl in Hload.
          pose proof (obs_eq_locks Htsim).
          eapply setPermBlock_obs_eq with (Hlt := (compat_th _ _ HmemCompC pfc).2); eauto.
          intros.
          eapply (val_obs_eq (strong_obs_eq H));
            by eauto. 
        }

        assert (HstoreF := store_val_obs _ _ _ Hstore Hfb Hval_obs Hobs_eq_locks).
        destruct HstoreF as [mf' [HstoreF HsimLocks']].
                assert (Hcore_inj:= code_eq Htsim).
        rewrite Hcode in Hcore_inj.
        simpl in Hcore_inj.
        destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
          try by exfalso.
        subst.
        
        assert (Hat_external_spec := core_inj_ext _ _  Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj (obs_eq_data Htsim)).
        rewrite Hat_external in Hat_external_spec.
        destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
          as [[? vsf] | ] eqn:Hat_externalF;
          try by exfalso.
                destruct Hat_external_spec as [? Harg_obs]; subst.
        inversion Harg_obs as [|? ? ? ? Hptr_obs Hl]; subst.
        inversion Hl; subst.
        inversion Hptr_obs as [| | | |b1 bf ofs0 Hf|];
          subst b1 ofs0 v'.
        assert (bf = b2)
          by (rewrite Hf in Hfb; by inversion Hfb);
          subst bf.
                pose (projectAngel (fp i pfc) virtueThread.1, projectAngel (fp i pfc) virtueThread.2) as virtueF.
        remember (updThread pff (Kresume cf Vundef)
                            (computeMap (getThreadR pff).1 virtueF.1, computeMap (getThreadR pff).2 virtueF.2))
          as tpf' eqn:Htpf'.
        
        assert (HresF: lockRes tpf (b2, Ptrofs.intval ofs))
          by (eapply Hlock_if; eauto; rewrite HisLock; auto).
        destruct (lockRes tpf (b2, Ptrofs.intval ofs)) as [pmapF|] eqn:HisLockF;
          try by exfalso.
        clear HresF.
        
        destruct (HsimRes _ _ _ _ _ Hfb HisLock HisLockF) as [HsimRes1 HsimRes2].

        assert (HangelF1: permMapJoin pmapF.1 (getThreadR pff).1
                                      (computeMap (getThreadR pff).1 virtueF.1)).
        { pose proof (obs_eq_data Htsim) as Hmem_obs_eq.
          eapply permMapJoin_project with (f := fp i pfc) (pmap := pmap.1) (pmap' := (getThreadR pfc).1); eauto.
          intros b0 Hunmapped ofs0. subst.
          simpl. erewrite computeMap_projection_2 by eauto.
          left; split; [eapply HunmappedRes|]; now eauto.
          intros.
          pose proof (perm_obs_strong HsimRes1 _ ofs0 H) as Heq.
          rewrite! restrPermMap_Cur in Heq. now auto.
          intros.
          pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq)) as Hperm_eq.
          specialize (Hperm_eq _ _ ofs0 H).
          rewrite! restrPermMap_Cur in Hperm_eq.
          now auto.
          intros. subst. simpl.
          erewrite computeMap_projection_1 by eauto.
          reflexivity.
        }
        assert (HangelF2: permMapJoin pmapF.2 (getThreadR pff).2
                                      (computeMap (getThreadR pff).2 virtueF.2)).
        { pose proof (obs_eq_locks Htsim) as Hmem_obs_eq.
          eapply permMapJoin_project with (f := fp i pfc) (pmap := pmap.2) (pmap' := (getThreadR pfc).2); eauto.
          intros b0 Hunmapped ofs0. subst.
          simpl. erewrite computeMap_projection_2 by eauto.
          left; split; [eapply HunmappedRes|]; now eauto.
          intros.
          pose proof (perm_obs_strong HsimRes2 _ ofs0 H) as Heq.
          rewrite! restrPermMap_Cur in Heq. now auto.
          intros.
          pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq)) as Hperm_eq.
          specialize (Hperm_eq _ _ ofs0 H).
          rewrite! restrPermMap_Cur in Hperm_eq.
          now auto.
          intros. subst. simpl.
          erewrite computeMap_projection_1 by eauto.
          reflexivity.
        }
        
        assert(HaccessF : Mem.range_perm (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#2) b2 (Ptrofs.intval ofs)
                                         (Ptrofs.intval ofs + lksize.LKSIZE) Cur Readable).
        { destruct Htsim.
          intros ofs' Hrange.
          destruct obs_eq_locks0 as [_ [Hperm_eq _]].
          unfold Mem.range_perm, permission_at, Mem.perm in *.
          erewrite Hperm_eq;
            by eauto.
        }        
        
        pose (empty_map, empty_map) as emptyRes.
        remember (updLockSet tpf' (b2, Ptrofs.intval ofs) (projectMap (fp i pfc) emptyRes.1, projectMap (fp i pfc) emptyRes.2))
          as tpf'' eqn:Htpf'';
          symmetry in Htpf''.
        exists tpf'', mf' , (fp i pfc), fp,
        (trf ++ [:: (external i (acquire (b2, Ptrofs.intval ofs)
                                       (Some (build_delta_content virtueF#1 mf'))))]).
        split.
        
        intros U.
        assert (HsyncStepF: syncStep false pff (mem_compf Hsim) tpf'' mf'
                                     (acquire (b2, Ptrofs.intval ofs)
                                              (Some (build_delta_content virtueF#1 mf'))))
          by (eapply step_acquire with (b0:=b2); eauto).
        econstructor;
           now eauto.
        
        assert (HinvC':
                  invariant (updLockSet
                               (updThread pfc (Kresume c Vundef) newThreadPerm)
                               (b, Ptrofs.intval ofs) (emptyRes.1,  emptyRes.2)))
          by  (eapply StepLemmas.safeC_invariant with (n := fuelF.+1 + size xs); eauto).

        assert (HmaxF': max_inv mf')
          by (eapply max_inv_store; eauto).

        assert (HmemCompF'' : mem_compatible tpf'' mf').
        { subst tpf' tpf'' newThreadPerm virtueF.
          eapply store_compatible; eauto.
          eapply mem_compatible_sync; eauto.
          unfold isCanonical. reflexivity.
          unfold isCanonical. reflexivity.
          eapply (mem_compf Hsim).
          eapply (codomain_valid (weak_obs_eq (obs_eq_data Htsim))).
        }
        subst.

        assert (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b).
        intros.
          by (intros;
              erewrite <- restrPermMap_valid with (Hlt := Hlt');
              split;
              [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
                by eauto).
        assert (Hvb': forall b, ~ Mem.valid_block mc b <-> ~ Mem.valid_block mc' b)
          by (intros; split; intros Hinvalid Hcontra;
                by apply Hvb in Hcontra).

        assert (HvbF: forall b, Mem.valid_block mf b <-> Mem.valid_block mf' b)
          by (
              intros;
              erewrite <- restrPermMap_valid with (Hlt := HltF');
              split;
              [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
                by eauto).

        assert (Hstrong_tsim:
                  forall (tid : nat)
                    (pfc0 : containsThread
                              (updLockSet (updThread pfc (Kresume c Vundef) newThreadPerm)
                                          (b, Ptrofs.intval ofs) (empty_map, empty_map)) tid)
                    (pff0 : containsThread
                              (updLockSet
                                 (updThread pff (Kresume cf Vundef)
                                            (computeMap (getThreadR pff)#1 virtueF#1,
                                             computeMap (getThreadR pff)#2 virtueF#2)) (b2, Ptrofs.intval ofs)
                                 (projectMap (fp i pfc) emptyRes#1, projectMap (fp i pfc) emptyRes#2)) tid),
                  exists (tpc' : t) (mc'0 : mem),
                    ren_incr (fp i pfc) (fp tid pfc0) /\
                    ([seq x <- xs | x == tid] = [::] -> fp i pfc = fp tid pfc0) /\
                    internal_execution [seq x <- xs | x == tid]
                                       (updLockSet (updThread pfc (Kresume c Vundef) newThreadPerm) 
                                                   (b, Ptrofs.intval ofs) (empty_map, empty_map)) mc' tpc' mc'0 /\
                    (forall (pfc' : containsThread tpc' tid) (mem_compc' : mem_compatible tpc' mc'0),
                        strong_tsim (fp tid pfc0) pfc' pff0 mem_compc' HmemCompF'') /\
                    (forall (tid2 : nat)
                       (pff2 : containsThread
                                 (updLockSet
                                    (updThread pff (Kresume cf Vundef)
                                               (computeMap (getThreadR pff)#1 virtueF#1,
                                                computeMap (getThreadR pff)#2 virtueF#2)) 
                                    (b2, Ptrofs.intval ofs)
                                    (projectMap (fp i pfc) emptyRes#1, projectMap (fp i pfc) emptyRes#2))
                                 tid2),
                        tid <> tid2 ->
                        forall (b1 b0 : block) (ofs0 : Z),
                          fp tid pfc0 b1 = Some b0 ->
                          fp i pfc b1 = None ->
                          ((getThreadR pff2)#1) # b0 ofs0 = None /\ ((getThreadR pff2)#2) # b0 ofs0 = None) /\
                    (forall (bl : block) (ofsl : Z) (rmap : lock_info) (b1 b0 : block) (ofs0 : Z),
                        fp tid pfc0 b1 = Some b0 ->
                        fp i pfc b1 = None ->
                        lockRes
                          (updLockSet
                             (updThread pff (Kresume cf Vundef)
                                        (computeMap (getThreadR pff)#1 virtueF#1,
                                         computeMap (getThreadR pff)#2 virtueF#2)) (b2, Ptrofs.intval ofs)
                             (projectMap (fp i pfc) emptyRes#1, projectMap (fp i pfc) emptyRes#2)) 
                          (bl, ofsl) = Some rmap -> (rmap#1) # b0 ofs0 = None /\ (rmap#2) # b0 ofs0 = None) /\
                    (forall b0 : block,
                        ~ (exists b1 : block, fp tid pfc0 b1 = Some b0) ->
                        forall ofs0 : Z,
                          ((getThreadR pff0)#1) # b0 ofs0 = None /\ ((getThreadR pff0)#2) # b0 ofs0 = None)).
        { 
          intros.
          destruct (tid == i) eqn:Htid; move/eqP:Htid=>Htid; subst.
          { 
            exists (updLockSet
                 (updThread pfc (Kresume c Vundef)
                            (computeMap (getThreadR pfc).1 virtueThread.1,
                             computeMap (getThreadR pfc).2 virtueThread.2))
                 (b, Ptrofs.intval ofs) (emptyRes.1, emptyRes.2)), mc'.
            assert (pfc0 = pfc)
              by (eapply cnt_irr; eauto); subst pfc0.
            rewrite Hsynced.
            
            split; first by apply ren_incr_refl.
            split; first by auto.
            split; first by constructor.
            split.
            
            intros.
            destruct Htsim as [_ Hmem_obs_eq_data Hmem_obs_eq_locks].
            constructor.
            rewrite! gLockSetCode.
            do 2 rewrite gssThreadCode;
              by (split; [assumption | constructor]).

            assert (Hlt1: permMapLt (computeMap (getThreadR pfc).1 virtueThread.1) (getMaxPerm mc')).
            { destruct mem_compc'.
              destruct (compat_th0 _ pfc').
              rewrite gLockSetRes  gssThreadRes in H.
              eauto.
            }
            erewrite restrPermMap_irr' with (Hlt' := Hlt1)
              by (rewrite gLockSetRes gssThreadRes; eauto).

            assert (Hlt1F: permMapLt (computeMap (getThreadR pff).1 virtueF.1) (getMaxPerm mf')).
            { destruct HmemCompF''.
              destruct (compat_th0 _ pff0).
              rewrite gLockSetRes  gssThreadRes in H.
              eauto.
            }
            erewrite restrPermMap_irr' with (Hlt' := Hlt1F)
              by (rewrite gLockSetRes gssThreadRes; eauto).
            eapply gss_mem_obs_eq_lock with (Hlt' := ((compat_lp _ _ HmemCompC) _ _ HisLock).1); simpl;
              try (erewrite! Mem.store_mem_contents by eauto);
              eauto; try reflexivity.

            assert (Hlt2: permMapLt (computeMap (getThreadR pfc).2 virtueThread.2) (getMaxPerm mc')).
            { destruct mem_compc'.
              destruct (compat_th0 _ pfc').
              rewrite gLockSetRes  gssThreadRes in H0.
              eauto.
            }
            erewrite restrPermMap_irr' with (Hlt' := Hlt2)
              by (rewrite gLockSetRes gssThreadRes; eauto).

            assert (Hlt2F: permMapLt (computeMap (getThreadR pff).2 virtueF.2) (getMaxPerm mf')).
            { destruct HmemCompF''.
              destruct (compat_th0 _ pff0).
              rewrite gLockSetRes  gssThreadRes in H0.
              eauto.
            }
            erewrite restrPermMap_irr' with (Hlt' := Hlt2F)
              by (rewrite gLockSetRes gssThreadRes; eauto).
            eapply gss_mem_obs_eq_lock with (Hlt' := ((compat_lp _ _ HmemCompC) _ _ HisLock).2); simpl;
              try (erewrite! Mem.store_mem_contents by eauto);
              eauto; try reflexivity.

            split; first by congruence.
            split; first by congruence.
            rewrite gLockSetRes gssThreadRes;
              simpl; intros; rewrite! computeMap_projection_2;
                eauto.
          }
          { 
            assert (Hstrong_sim := simStrong Hsim).
            assert (pfcj: containsThread tpc tid)
              by (eapply cntUpdateL' in pfc0;
                  eapply cntUpdate' in pfc0;
                  eauto).
            assert (pffj: containsThread tpf tid)
              by (eapply cntUpdateL' in pff0;
                  eapply cntUpdate' in pff0;
                  eauto).
            specialize (Hstrong_sim _ pfcj pffj).
            destruct Hstrong_sim
              as (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
                  & Hownedj & Hownedj_lp & Hunmapped_j).
            
            assert (pfcij:= containsThread_internal_execution Hexecj pfc).

            assert (pfcjj: containsThread tpcj tid)
              by (eapply containsThread_internal_execution; eauto).
            assert (Hcompj: mem_compatible tpcj mcj)
              by (eapply internal_execution_compatible with (tp := tpc); eauto).
            specialize (Htsimj pfcjj Hcompj).

            assert (Htsimj_id:
                      tp_wd (id_ren mc) tpc /\
                      ctl_inj (id_ren mc) (getThreadC pfcj) (getThreadC pfc0) /\
                      mem_obs_eq (id_ren mc) (restrPermMap (compat_th _ _ HmemCompC pfcj).1) (restrPermMap (compat_th _ _ HmemCompC' pfc0).1) /\
                      Mem.nextblock mc = Mem.nextblock mc').
            { split.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
              eapply strong_tsim_store_id; eauto.
              erewrite gLockSetRes.
              rewrite gsoThreadRes; eauto.
              erewrite gLockSetCode.
              rewrite gsoThreadCode; eauto.
              destruct HinvC.
              pose proof ((thread_data_lock_coh0 _ pfc ).1 _ pfcj) as Hcoh.
              left.
              eapply permMapCoherence_increase; eauto.
              apply Mem.load_valid_access in Hload.
              destruct Hload as [Hload _].
              intros.
              specialize (Haccess ofs' H).
              unfold Mem.perm in Haccess.
              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC pfc).2 b ofs') as Hperm_at.
              unfold permission_at in Hperm_at.
              rewrite Hperm_at in Haccess.
              assumption.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
            }
            destruct Htsimj_id as [Htpc_id_wd [Hctlj_id [Hmem_obs_eqj_id Hnextblock]]].

            assert (H := mem_obs_eq_execution _ _ _ _ _ HinvC' Hfg Hge_wd Hge_incr_id
                                              Hmemc_wd Htpc_id_wd Hctlj_id Hmem_obs_eqj_id Hexecj).
            destruct H as
                (tp2' & m2' & f' & Hexecj'& Hincrj' & Hsepj'
                 & Hnextblock' & Hinvj' & Htsimj' & Hid').
            destruct Htsimj' as (pf2j & pf2j' & Hcomp2 & Hcomp2' & Hctl_eqj' & Hmem_obs_eq').
            specialize (Hid' Hnextblock (id_ren_correct mc)).
            assert (f' = id_ren mcj)
              by ( pose ((mem_obs_eq_domain_ren Hmem_obs_eq'));
                   eapply is_id_ren; eauto); subst f'.
            exists tp2', m2'.
            erewrite cnt_irr with (cnt1 := pfc0) (cnt2 := pfcj).
            split; first by auto.
            split; first by auto.
            split; first by auto.
            split.
            
            intros.
            Tactics.pf_cleanup.
            
            assert (Htsim2j: ctl_inj (fp tid pfcj) (getThreadC pf2j') (getThreadC pffj) /\
                             mem_obs_eq (fp tid pfcj) (restrPermMap (compat_th _ _ Hcomp2' pf2j').1)
                                        (restrPermMap (compat_th _ _ (mem_compf Hsim) pffj).1)).
            { destruct Htsimj.
              eapply strong_tsim_id_trans
                with (f := fp tid pfcj) (Hcomp1 := Hcompj) (Hcomp1' := Hcomp2');
                eauto.
              destruct Hnextblock' as [[p [Hmcj Hm2']] | [Hmcj Hm2']];
                unfold Mem.valid_block;
                rewrite Hmcj Hm2' Hnextblock;
                  by tauto.
            }

            destruct Htsim2j as [Hcodeq2j Hmem_obs_eq2j].
            constructor.
            rewrite gLockSetCode.
            rewrite gsoThreadCode;
              by auto.
            clear - Hmem_obs_eq2j HstoreF HinvF Htid HloadF HaccessF.
            assert (HeqRes: getThreadR pff0 = getThreadR pffj)
              by (rewrite gLockSetRes;
                  rewrite gsoThreadRes; auto).
            assert (Hlt : permMapLt (getThreadR pff0).1 (getMaxPerm mf))
              by (rewrite HeqRes; eapply (compat_th _ _ (mem_compf Hsim) pffj).1).
            eapply mem_obs_eq_storeF with (mf := mf) (Hlt :=  Hlt);
              eauto. 
            apply Mem.load_valid_access in HloadF.
            pose proof (((thread_data_lock_coh _ HinvF) _ pff).1 _ pffj).
            pose proof (cntUpdateL' _ _ pff0) as pffj'.
            erewrite gLockSetRes with (cnti := pffj').
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            left.
            apply setPermBlock_coherent; eauto.
            intros ofs' Hrange Hcontra.
            specialize (HaccessF ofs' Hrange).
            unfold Mem.perm in HaccessF.
            specialize (H b2 ofs').
            pose proof (restrPermMap_Cur (compat_th _ _ (mem_compf Hsim) pff).2 b2 ofs') as Heq.
            unfold permission_at in Heq.
            rewrite Heq in HaccessF.
            destruct ((getThreadR pffj).1 # b2 ofs') as [p1|]; simpl in Hcontra;
              [| assumption];
              inversion Hcontra; subst;
                destruct ((getThreadR pff).2 # b2 ofs') as [p2|]; simpl in HaccessF;
                  now auto.
            erewrite restrPermMap_irr' with (Hlt := Hlt)
                                            (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).1); eauto.
            rewrite HeqRes. reflexivity.

            pose proof (obs_eq_locks Htsimj).

            assert (HRj_eq: (getThreadR pf2j').2 = (getThreadR pfcjj).2).
            { erewrite <- internal_execution_locks_eq with (cntj := pfc0) by eauto.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) by eauto.
              rewrite gLockSetRes.
              erewrite gsoThreadRes by eauto;
                reflexivity.
            }

            assert (Hlt2C: permMapLt (getThreadR pfcjj).2 (getMaxPerm m2'))
              by ( rewrite <- HRj_eq;
                   eapply (compat_th _ _ Hcomp2' pf2j').2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2C) by eauto.

            assert (HRj_eqF: (getThreadR pff0)#2 = (getThreadR pffj)#2)
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pffj) by eauto;
                  reflexivity).

            assert (Hlt2F: permMapLt (getThreadR pffj).2 (getMaxPerm mf'))
              by (rewrite <- HRj_eqF; eapply (compat_th _ _ HmemCompF'' pff0).2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2F) by eassumption.

            assert (Hstable_mc2': forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                             ZMap.get ofs1 (Mem.mem_contents mc') # b1 = ZMap.get ofs1 (Mem.mem_contents m2') # b1).
            { intros.
              erewrite <- internal_exec_disjoint_locks with (Hcomp := HmemCompC') (m := mc') (m' := m2') (pfj := pfc0); eauto.
              unfold Mem.perm.
              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).2 b1 ofs1) as Hpermj.
              unfold permission_at in Hpermj.
              rewrite Hpermj.
              rewrite gLockSetRes.
              erewrite gsoThreadRes with (cntj := pfcj) by eauto.
              assumption.
            }

            assert (Hstable_mcj: forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                            ZMap.get ofs1 (Mem.mem_contents mc) # b1 =
                                            ZMap.get ofs1 (Mem.mem_contents mcj) # b1).
            { intros.
              erewrite internal_exec_disjoint_locks
                with (Hcomp := HmemCompC) (pfj := pfcj) (m := mc) (tp := tpc) (tp' := tpcj); eauto.
              unfold Mem.perm in *.

              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC pfcj).2 b1 ofs1) as Hpermj.
              unfold permission_at in *.
              rewrite Hpermj. assumption.
            }

            assert (Hperm_eqj: forall b1 ofs1, (Mem.mem_access (restrPermMap (compat_th _ _ Hcompj pfcjj).2)) # b1 ofs1 Cur =
                                          (getThreadR pfcj).2 # b1 ofs1).
            { intros.
              pose proof (restrPermMap_Cur (compat_th _ _ Hcompj pfcjj).2 b1 ofs1) as Hpermjj.
              unfold permission_at in Hpermjj.
              rewrite Hpermjj.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) at 1
                by eauto.
              reflexivity.
            }

            eapply mem_obs_eq_disjoint_lock
              with (ofsl := Ptrofs.intval ofs) (bl1 := b)
                   (bl2 := b2) (sz := size_chunk Mint32); eauto.
            
            intros. unfold Mem.valid_block in *.
            destruct Hnextblock' as [[p [Hnextj Hnext2]] | [Hnextj Hnext2]];
              rewrite Hnextj Hnext2 Hnextblock;
              split; now auto.

            intros ofs0 Hrange.
                        assert (Hlock_unwrittable: ~ Mem.perm (restrPermMap (compat_th _ _ HmemCompC' pfc0)#1) b ofs0 Cur Writable).
            { clear - Hload HinvC Hrange pfcj Htid.
              pose proof (((thread_data_lock_coh _ HinvC _ pfc).1) _ pfcj b ofs0) as Hcoh.
              apply Mem.load_valid_access in Hload.
              destruct Hload as [Hperm _].
              specialize (Hperm ofs0 Hrange).
              unfold Mem.perm in *.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).1) b ofs0) as Hpermj'.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC pfc).2) b ofs0) as Hpermi.
              unfold permission_at in *.
              rewrite Hpermi in Hperm.
              rewrite Hpermj'.
              rewrite gLockSetRes.
              erewrite gsoThreadRes with (cntj := pfcj) by eauto.
              intros Hcontra.
              destruct ((getThreadR pfcj).1 # b ofs0) as [p|]; try (by exfalso);
                destruct p; simpl in Hcontra; inversion Hcontra; subst;
                  destruct ((getThreadR pfc).2 # b ofs0) as [p|];
                  try (by exfalso); inversion Hcontra; subst.
            }

            erewrite <- internal_exec_stable with (m := mc') (Hcomp := HmemCompC') (pfi := pfc0); eauto.
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            rewrite! Maps.PMap.gss.
            erewrite! setN_inside
              by (simpl; eauto).
            
            destruct ((List.nth_in_or_default (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (encode_val Mint32 (Vint Int.zero)) Undef)).
            apply inj_bytes_type in i0.
            destruct (List.nth (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (encode_val Mint32 (Vint Int.zero)) Undef);
              now constructor.
            rewrite e. now constructor.
            eapply Mem.store_valid_block_1; eauto.
            
            intros.
            unfold Mem.perm in H1.
            erewrite Hperm_eqj in H1.
            erewrite <- Hstable_mc2' by eauto.
            erewrite <- Hstable_mcj by eauto.
            
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            destruct H0 as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.

            intros b0 ofs0 Hneq Hreadable.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            destruct Hneq as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.
            eauto.
            split.
            
            intros k pff2k Hjk b1 b0 ofs0 Hfj Hfi.
            destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
            { subst k.
              rewrite gLockSetRes.
              rewrite gssThreadRes; auto.
              assert (Hunmapped: ~ (exists b, (fp i pfc) b = Some b0)).
              { intros Hcontra.
                destruct Hcontra as [b3 Hcontra].
                assert (Hfj' := Hincrj _ _ Hcontra).
                assert (Heq := injective (weak_obs_eq (obs_eq_data Htsimj)) _ _ Hfj Hfj');
                  subst b3.
                  by congruence.
              }
              simpl.
              erewrite! computeMap_projection_2;
                by eauto.
            }
            { rewrite gLockSetRes.
              rewrite gsoThreadRes; auto.
              eapply Hownedj;
                by eauto.
            }
            split.
            
            intros bl ofsl rmap b1 b0 ofs0 Hfj Hfi Hres.
            destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)) as [Heq | Hneq].
            
            inversion Heq; subst.
            rewrite gssLockRes in Hres. inversion Hres.
            assert (~ exists b, fp i pfc b = Some b0).
            { intros Hcontra.
              destruct Hcontra as [b' Hfb'].
              assert (Hfb'' := Hincrj _ _ Hfb').
              assert (b' = b1)
                by (eapply (injective (weak_obs_eq (obs_eq_data Htsimj)));
                    eauto). subst b'.
                by congruence.
            }
            rewrite! projectMap_correct_2; auto.
            
            rewrite gsoLockRes in Hres; auto.
            rewrite gsoThreadLPool in Hres;
              by eauto.
            
            intros b0 Hunmapped ofs0.
            rewrite gLockSetRes.
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            eapply Hunmapped_j;
              by eauto.
          }
        }
        
        eapply Build_sim with (mem_compc := HmemCompC') (mem_compf := HmemCompF'').
        - 
          clear - HnumThreads.
          intros j.
          split; intros cntj;
          eapply cntUpdateL;
          eapply cntUpdate;
          apply cntUpdateL' in cntj;
          apply cntUpdate' in cntj;
            by eapply HnumThreads.
        - 
          intros sched tr.
          eapply HybridCoarseMachine.csafe_trace;
            now eauto.
        - 
          
          intros j pfcj' pffj'.
          assert (pfcj: containsThread tpc j)
            by auto.
          assert (pffj: containsThread tpf j)
            by auto.
          specialize (HsimWeak _ pfcj pffj).

          clear - Hvb Hvb' HvbF HsimWeak Hsim.

          assert (Hlt:
                    forall (b1 b0 : block) (ofs0 : Z),
                      fp i pfc b1 = Some b0 ->
                      Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#1) b1 ofs0 Cur)
                                       (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj').1) b0 ofs0 Cur) /\
                      Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#2) b1 ofs0 Cur)
                                       (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj').2) b0 ofs0 Cur)).
          { intros b1 b0 ofs0 Hrenaming.
            pose proof (perm_obs_weak (weak_tsim_data HsimWeak)) as Hperm_data.
            pose proof (perm_obs_weak (weak_tsim_locks HsimWeak)) as Hperm_locks.
            specialize (Hperm_data _ _ ofs0 Hrenaming).
            specialize (Hperm_locks _ _ ofs0 Hrenaming).
            destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
            - 
              subst j.
              Tactics.pf_cleanup.
              rewrite! restrPermMap_Cur gLockSetRes gssThreadRes;
                rewrite! gLockSetRes gssThreadRes.
              pose proof (injective (weak_tsim_data HsimWeak)).

              assert (Hproject1: Maps.PTree.get b0 (projectAngel (fp i pfc) virtueThread.1) =
                                 Maps.PTree.get b1 virtueThread.1)
                by (symmetry; eapply projectAngel_correct; eauto).
              assert (Hproject2: Maps.PTree.get b0 (projectAngel (fp i pfc) virtueThread.2) =
                                 Maps.PTree.get b1 virtueThread.2)
                by (symmetry; eapply projectAngel_correct; eauto).
              split; simpl in *.
              + destruct (Maps.PTree.get b1 virtueThread.1) as [df|] eqn:Hdelta.
                * destruct (df ofs0) as [pnew |] eqn:Hdf.
                  rewrite (computeMap_1 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_1 _ _ _ _ Hproject1 Hdf);
                    by eapply po_refl.
                rewrite (computeMap_2 _ _ _ _ Hdelta Hdf).
                rewrite (computeMap_2 _ _ _ _ Hproject1 Hdf);
                  by do 2 rewrite restrPermMap_Cur in Hperm_data.
                *  rewrite (computeMap_3 _ _ _ _ Hdelta).
                rewrite (computeMap_3 _ _ _ _ Hproject1);
                  by do 2 rewrite restrPermMap_Cur in Hperm_data.
              + destruct (Maps.PTree.get b1 virtueThread.2) as [df|] eqn:Hdelta.
                * destruct (df ofs0) as [pnew |] eqn:Hdf.
                  rewrite (computeMap_1 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_1 _ _ _ _ Hproject2 Hdf);
                    by eapply po_refl.
                  rewrite (computeMap_2 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_2 _ _ _ _ Hproject2 Hdf);
                    by do 2 rewrite restrPermMap_Cur in Hperm_locks.
                *  rewrite (computeMap_3 _ _ _ _ Hdelta).
                   rewrite (computeMap_3 _ _ _ _ Hproject2);
                     by do 2 rewrite restrPermMap_Cur in Hperm_locks.
            - erewrite! restrPermMap_Cur.
              assert (pfcj0: containsThread (updThread pfc (Kresume c Vundef) newThreadPerm) j)
                by (apply cntUpdate; auto).
              assert (pffj0: containsThread (updThread pff (Kresume cf Vundef)
                                                       (computeMap (getThreadR pff)#1 virtueF#1, computeMap (getThreadR pff)#2 virtueF#2)) j)
                by (apply cntUpdate; auto).
              erewrite gLockSetRes with (cnti := pfcj0).
              erewrite gLockSetRes with (cnti := pffj0).
              erewrite gsoThreadRes with (cntj := pfcj); eauto.
              erewrite gsoThreadRes with (cntj := pffj); eauto.
              split;
                [do 2 erewrite restrPermMap_Cur in Hperm_data |
                 do 2 erewrite restrPermMap_Cur in Hperm_locks];
                  by assumption. }

          destruct HsimWeak. destruct weak_tsim_data0.
          constructor; intros; constructor; intros; simpl;
          repeat
            (match goal with
             | [H: context[Mem.valid_block (restrPermMap _) _] |- _] =>
               erewrite restrPermMap_valid in H
             | [H: ~ Mem.valid_block _ _ |- _] =>
               apply Hvb' in H; clear Hvb'
             | [H: Mem.valid_block _ _ |- _] =>
               apply Hvb in H; clear Hvb
             | [|- Mem.valid_block (restrPermMap _) _] =>
               erewrite restrPermMap_valid
             | [|- Mem.valid_block _ _] =>
               eapply HvbF; clear HvbF
             end); eauto;
            try (by specialize (codomain_valid0 _ _ H));
            destruct (Hlt _ _ ofs0 Hrenaming);
            eauto.
        - 
          intros k j cntk' cntj' Hkj b0 b0' b3 b3' Hf0 Hf0' Hfk' Hfj'.
          assert (cntk: containsThread tpc k)
            by auto.
          assert (cntj: containsThread tpc j)
            by auto.
          erewrite cnt_irr with (cnt1 := cntk') (cnt2 := cntk) in Hfk'.
          erewrite cnt_irr with (cnt1 := cntj') (cnt2 := cntj) in Hfj'.
          eapply (HfpSep _ _ cntk cntj Hkj b0 b0');
            by eauto.
        - eauto.
        - 
          
          split.
          { intros bl1 bl2 ofs0 rmap1 rmap2 Hfi Hres1 Hres2.
            destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)) as [Heq | Hneq].
            { 
              inversion Heq; subst.
              assert (bl2 = b2)
                by (rewrite Hfi in Hfb; by inversion Hfb).
              subst bl2.
              assert (Hperm_eq: forall b1 b0 ofs0, fp i pfc b1 = Some b0 ->
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#1) b0 ofs0 Cur =
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#1) b1 ofs0 Cur /\
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#2) b0 ofs0 Cur =
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#2) b1 ofs0 Cur).
              { intros.
                rewrite! restrPermMap_Cur.
                rewrite gssLockRes in Hres1.
                rewrite gssLockRes in Hres2.
                inversion Hres1; inversion Hres2.
                unfold Maps.PMap.get.
                rewrite! Maps.PTree.gempty;
                  split;
                    by reflexivity.
              }
              split;
                constructor; intros;
                  try (destruct (Hperm_eq b1 b0 ofs0 Hrenaming); by auto).
              assert (H:= restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs)
                                                      _ Hres1).1 b1 ofs0).
              unfold permission_at in H.
              unfold Mem.perm in Hperm.
              rewrite H in Hperm.
              clear H Hperm_eq.
              exfalso.
              rewrite gssLockRes in Hres1.
              inversion Hres1; subst.
              unfold Maps.PMap.get in Hperm.
              rewrite Maps.PTree.gempty in Hperm.
              simpl in Hperm;
                by auto.
              assert (H:= restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs)
                                                      _ Hres1).2 b1 ofs0).
              unfold permission_at in H.
              unfold Mem.perm in Hperm.
              rewrite H in Hperm.
              clear H Hperm_eq.
              exfalso.
              rewrite gssLockRes in Hres1.
              inversion Hres1; subst.
              unfold Maps.PMap.get in Hperm.
              rewrite Maps.PTree.gempty in Hperm.
              simpl in Hperm;
                by auto.
            }
            { 
              assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
              { clear - Hneq Hfi Hf Hfb Htsim.
                intros Hcontra; inversion Hcontra; subst.
                assert (b = bl1)
                  by (eapply (injective (weak_obs_eq (obs_eq_data Htsim))); eauto).
                subst;
                  by auto.
              }
                pose proof Hres1 as Hres1';
                  pose proof Hres2 as Hres2'.
                erewrite gsoLockRes, gsoThreadLPool in Hres1' by auto.
                erewrite gsoLockRes, gsoThreadLPool in Hres2' by auto.
                destruct (HsimRes _ _ _ _ _ Hfi Hres1' Hres2') as [Hsim1 Hsim2].
                split;
                  eapply strong_mem_obs_eq_store with (bl1 := b) (bl2 := b2); eauto;
                    try (erewrite Mem.store_mem_contents by eauto; reflexivity).
            }
          }
          split.
          
          intros bl2 ofs0 Hres.
          destruct (EqDec_address (bl2, ofs0) (b2, Ptrofs.intval ofs)) as [Heq | Hneq].
          inversion Heq; subst.
          eexists;
            by eauto.
          erewrite gsoLockRes, gsoThreadLPool in Hres by auto.
          eapply Hlock_mapped;
            by eauto.
          
          { intros bl1 bl2 ofs0 Hfl1.
            destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)).
            - inversion e; subst.
              assert (b2 = bl2)
                by (rewrite Hf in Hfl1; inversion Hfl1; subst; auto).
              subst.
              do 2 rewrite gsslockResUpdLock.
              split;
              auto.
            - erewrite gsolockResUpdLock by auto.
              assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
              { intros Hcontra.
                inversion Hcontra; subst.
                specialize (Hinjective _ _ _ Hfl1 Hfb).
                subst; auto.
              }
              erewrite gsolockResUpdLock by eauto.
              do 2 rewrite gsoThreadLPool.
              eauto.
          }
        - 
          intros bl ofsl rmap Hres b0 Hunmapped ofs0.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)).
          + inversion e; subst.
            rewrite gsslockResUpdLock in Hres.
            inversion Hres; subst.
            simpl.
            erewrite! projectMap_correct_2 by auto.
            split; reflexivity.
          + erewrite gsolockResUpdLock in Hres by auto.
            rewrite gsoThreadLPool in Hres.
            eapply HunmappedRes; eauto.
        - 
          destruct Htsim.
          eapply invariant_project; by eauto.
        - 
          assumption.
        - 
          eapply store_wd_domain with
          (m := (restrPermMap Hlt')); eauto.
            by simpl.
        - 
          apply tp_wd_lockSet.
          intros j cntj'.
          destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
          subst. rewrite gssThreadCode.
          specialize (Htpc_wd _ pfc).
          rewrite Hcode in Htpc_wd.
          simpl in *;
            by auto.
          assert (cntj := cntUpdate' _ _ _ cntj').
          erewrite @gsoThreadCode with (cntj := cntj) by assumption.
          specialize (Htpc_wd _ cntj);
            by auto.
        - 
          assumption.
        - 
          split; assumption.
        - intros.
          apply cntUpdateL;
            apply cntUpdate;
              by eauto.
        - econstructor 2;
            eauto.
          unfold virtueF.
          destruct virtueThread as [vT1 vT2].
          econstructor; eauto.
          + simpl.
            assert (cnti': containsThread
                             (updLockSet (updThread pfc (Kresume c Vundef) newThreadPerm)
                                         (b, Ptrofs.intval ofs) (emptyRes#1, emptyRes#2)) i)
              by (eapply cntUpdateL; eapply cntUpdate; now eauto).
            assert (cntiF': containsThread
                              (updLockSet
                                 (updThread pff (Kresume cf Vundef)
                                            (computeMap (getThreadR pff)#1 virtueF#1,
                                             computeMap (getThreadR pff)#2 virtueF#2))
                                 (b2, Ptrofs.intval ofs)
                                 (projectMap (fp i pfc) emptyRes#1,
                                  projectMap (fp i pfc) emptyRes#2)) i)
              by (eapply cntUpdateL; eapply cntUpdate; now eauto).
            pose proof (compat_th _ _ HmemCompC' cnti').1 as Hltc.
            rewrite gLockSetRes in Hltc.
            rewrite gssThreadRes in Hltc.
            simpl in Hltc.
            pose proof (compat_th _ _ HmemCompF'' cntiF').1 as HltF.
            rewrite gLockSetRes in HltF.
            rewrite gssThreadRes in HltF.
            simpl in HltF.
            specialize (Hstrong_tsim i cnti' cntiF').
            rewrite Hsynced in Hstrong_tsim.
            destruct Hstrong_tsim as [tpc' [mc'0 [_ [Heq [Hexec_eq [Hstrong_tsim _]]]]]].
            specialize (Heq ltac:(reflexivity)).
            erewrite <- Heq in *.
            inversion Hexec_eq; subst. clear Hexec_eq.
            specialize (Hstrong_tsim cnti' HmemCompC').
            destruct Hstrong_tsim as [_ ?].
            
            eapply @delta_content_inj_correct with (Hltc := Hltc)
                                                   (Hltf := HltF);
              eauto.
            
            { repeat (split).
            * intros.
              erewrite <- projectAngel_correct with (b := b0) by eauto.
              simpl.
              destruct (vT1 ! b0) eqn:HvT1; auto.
            * intros b0 Hf0.
              assert (Hinvalid: ~ Mem.valid_block mc b0).
              { destruct (HsimWeak _ pfc pff).
                destruct weak_tsim_data0.
                intros Hcontra.
                eapply domain_valid0 in Hcontra.
                destruct Hcontra.
                congruence.
              }
              destruct (vT1 ! b0) eqn:HvT1; auto.
              intros ofs0.
              destruct (o ofs0) eqn:Hofs0; auto.
              eapply Hvb' in Hinvalid.
              eapply @mem_compatible_invalid_block with (ofs := ofs0) in Hinvalid; eauto.
              destruct Hinvalid.
              assert (pfc': containsThread
                              (updLockSet (updThread pfc (Kresume c Vundef) newThreadPerm)
                                          (b, Ptrofs.intval ofs) (empty_map, empty_map)) i).
              { eapply cntUpdateL; eapply cntUpdate; eauto. }
              specialize (H _ pfc').
              rewrite gLockSetRes gssThreadRes in H.
              simpl in H.
              erewrite computeMap_1 in H by eauto.
              destruct H. subst.
              auto.
            * intros.
              erewrite projectAngel_correct_2 by eauto.
              reflexivity.
            }
            assert (HeqC:restrPermMap Hltc = (restrPermMap (compat_th _ _ HmemCompC' cnti')#1)).
            { erewrite restrPermMap_irr; eauto.
              rewrite gLockSetRes gssThreadRes.
              reflexivity.
            }
            assert (HeqF:restrPermMap HltF = (restrPermMap (compat_th _ _ HmemCompF'' cntiF')#1)).
            { erewrite restrPermMap_irr; eauto.
              rewrite gLockSetRes gssThreadRes.
              reflexivity.
            }
            rewrite HeqC HeqF.
            assumption.
            simpl in HschedN.
            discriminate.
    }
    { 
            assert (Hvalidb: Mem.valid_block m0 b)
        by (eapply load_valid_block; eauto).
      rewrite <- Hrestrict_pmap0 in Hvalidb.
      
      destruct ((domain_valid (weak_obs_eq (obs_eq_data Htsim))) _ Hvalidb)
        as [b2 Hfb].
      assert (Hvalidb2 := (codomain_valid (weak_obs_eq (obs_eq_data Htsim))) _ _ Hfb).
      erewrite restrPermMap_valid in Hvalidb2.
      
      remember (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).2) as mf0 eqn:Hrestrict_pmapF.
      subst m1 m0.
            assert (HloadF: Mem.load Mint32 mf0 b2 (Ptrofs.intval ofs) = Some (Vint Int.zero)).
      { subst mf0.
        destruct (load_val_obs _ _ _ Hload Hfb Hinjective ((strong_obs_eq (obs_eq_locks Htsim))))
          as [v2 [Hloadf Hobs_eq]].
        inversion Hobs_eq; subst.
          by auto.
      }
      assert (Hval_obs: val_obs (fp i pfc) (Vint Int.one) (Vint Int.one))
        by constructor.
      
      remember (setPermBlock (Some Writable) b2 (Ptrofs.intval ofs) (getThreadR pff).2 lksize.LKSIZE_nat)
        as pmap_tidF' eqn:Hset_permF.
      
      assert (HltF': permMapLt pmap_tidF' (getMaxPerm mf)).
      {
        subst.
        eapply setPermBlock_lt; eauto.
        eapply (compat_th _ _ (mem_compf Hsim) pff).2.
      }

      assert (Hobs_eq_locks: mem_obs_eq (fp i pfc) (restrPermMap Hlt') (restrPermMap HltF')).
      { subst.
        apply Mem.load_valid_access in Hload.
        destruct Hload as [Hload _]. simpl in Hload.
        pose proof (obs_eq_locks Htsim).
        eapply setPermBlock_obs_eq with (Hlt := (compat_th _ _ HmemCompC pfc).2); eauto.
        intros.
        eapply (val_obs_eq (strong_obs_eq H));
          by eauto.
      }

      assert (HstoreF := store_val_obs _ _ _ Hstore Hfb Hval_obs Hobs_eq_locks).
      destruct HstoreF as [mf' [HstoreF HsimLocks']].
            assert (Hcore_inj:= code_eq Htsim).
      rewrite Hcode in Hcore_inj.
      simpl in Hcore_inj.
      subst.
      destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
        try by exfalso.
      
      assert (Hat_external_spec := core_inj_ext _ _  Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj (obs_eq_data Htsim)).
      rewrite Hat_external in Hat_external_spec.
      destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
        as [[?  vsf] | ] eqn:Hat_externalF;
        try by exfalso.
            destruct Hat_external_spec as [? Harg_obs]; subst.
      inversion Harg_obs as [|? ? ? ? Hptr_obs Hl]; subst.
      inversion Hl; subst.
      inversion Hptr_obs as [| | | |b1 bf ofs0 Hf|];
        subst b1 ofs0 v'.
      assert (bf = b2)
        by (rewrite Hf in Hfb; by inversion Hfb);
        subst bf.
            pose (projectAngel (fp i pfc) virtueThread.1, projectAngel (fp i pfc) virtueThread.2) as virtueF.
      remember (updThread pff (Kresume cf Vundef)
                          (computeMap (getThreadR pff).1 virtueF.1, computeMap (getThreadR pff).2 virtueF.2))
        as tpf' eqn:Htpf'.
      
      remember (projectMap (fp i pfc) virtueLP.1, projectMap (fp i pfc) virtueLP.2) as virtueLPF eqn:HvirtueLPF.
      
      assert (HresF: lockRes tpf (b2, Ptrofs.intval ofs))
        by (eapply Hlock_if; eauto; rewrite HisLock; auto).
      destruct (lockRes tpf (b2, Ptrofs.intval ofs)) as [pmapF|] eqn:HisLockF;
        try by exfalso.
      destruct (HsimRes _ _ _ _ _ Hfb HisLock HisLockF) as [HsimRes1 HsimRes2].

      assert (HangelF1: permMapJoin (computeMap (getThreadR pff).1 virtueF.1) virtueLPF.1 (getThreadR pff).1).
      { assert (Hcanonical: isCanonical virtueLP.1)
          by (destruct (@compat_lp _ _ _ _ HmemCompC' (b, Ptrofs.intval ofs) virtueLP
                                   ltac:(rewrite gsslockResUpdLock; reflexivity));
              eapply canonical_lt; eauto).
        pose proof (obs_eq_data Htsim) as Hmem_obs_eq.
        pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq)) as Hperm_eq.
        eapply permMapJoin_project with (f := fp i pfc) (pmap := newThreadPerm.1) (pmap' := virtueLP.1); eauto.
        unfold isCanonical in Hcanonical.
        intros b0 Hunmapped ofs0. subst.
        simpl. erewrite projectMap_correct_2 by eauto.
        erewrite computeMap_projection_2 by eauto.
        right.
        rewrite Hcanonical. split; reflexivity.
        subst virtueF.
        intros. simpl.
        erewrite computeMap_projection_1 by eauto;
          now reflexivity.
        intros. subst.
        erewrite projectMap_correct by eauto;
          now reflexivity.
        intros b1 b0 ofs0 Hrenaming;
          specialize (Hperm_eq _ _ ofs0 Hrenaming); rewrite! restrPermMap_Cur in Hperm_eq;
            auto.
      }

      assert (HangelF2: permMapJoin (computeMap (getThreadR pff).2 virtueF.2) virtueLPF.2 (getThreadR pff).2).
      { assert (Hcanonical: isCanonical virtueLP.2)
          by (destruct (@compat_lp _ _ _ _ HmemCompC' (b, Ptrofs.intval ofs) virtueLP
                                   ltac:(rewrite gsslockResUpdLock; reflexivity));
              eapply canonical_lt; eauto).
        pose proof (obs_eq_locks Htsim) as Hmem_obs_eq.
        pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq)) as Hperm_eq.
        eapply permMapJoin_project with (f := fp i pfc) (pmap := newThreadPerm.2) (pmap' := virtueLP.2); eauto.
        unfold isCanonical in Hcanonical.
        intros b0 Hunmapped ofs0. subst.
        simpl. erewrite projectMap_correct_2 by eauto.
        erewrite computeMap_projection_2 by eauto.
        right.
        rewrite Hcanonical. split; reflexivity.
        subst virtueF.
        intros. simpl.
        erewrite computeMap_projection_1 by eauto;
          now reflexivity.
        intros. subst.
        erewrite projectMap_correct by eauto;
          now reflexivity.
        intros b1 b0 ofs0 Hrenaming;
          specialize (Hperm_eq _ _ ofs0 Hrenaming); rewrite! restrPermMap_Cur in Hperm_eq;
            auto.
      }

      assert(HpmapF: forall b ofs, pmapF.1 !! b ofs = None /\ pmapF.2 !! b ofs = None).
      { intros b0 ofs0.
        assert (Hb0: (exists b1, (fp i pfc) b1 = Some b0) \/
                     ~ (exists b1, (fp i pfc) b1 = Some b0))
          by eapply em.
        destruct Hb0 as [[b1 Hf1] | Hunmapped].
        - 
          pose proof (perm_obs_strong HsimRes1 _ ofs0 Hf1) as Hpmap1.
          pose proof (perm_obs_strong HsimRes2 _ ofs0 Hf1) as Hpmap2.
          rewrite! restrPermMap_Cur in Hpmap1 Hpmap2.
          erewrite Hpmap1, Hpmap2, (Hrmap b1 ofs0).1, (Hrmap b1 ofs0).2.
          split; reflexivity.
        - specialize (HunmappedRes _ _ _ HisLockF _ Hunmapped ofs0).
          assumption.
      }

      assert(HaccessF : Mem.range_perm (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#2) b2 (Ptrofs.intval ofs)
                                       (Ptrofs.intval ofs + lksize.LKSIZE) Cur Readable).
      { destruct Htsim.
        intros ofs' Hrange.
        destruct obs_eq_locks0 as [_ [Hperm_eq _]].
        unfold Mem.range_perm, permission_at, Mem.perm in *.
        erewrite Hperm_eq;
          by eauto.
      }
      
      remember (updLockSet tpf' (b2, Ptrofs.intval ofs) virtueLPF)
        as tpf'' eqn:Htpf'';
        symmetry in Htpf''.
      exists tpf'', mf', (fp i pfc), fp,
      (trf ++ [:: (external i (release (b2, Ptrofs.intval ofs)
                                     (Some (build_delta_content virtueF#1 mf'))))]).
      split.
      
      intros U.
      assert (HsyncStepF: syncStep false pff (mem_compf Hsim) tpf'' mf'
                                   (release (b2, Ptrofs.intval ofs)
                                            (Some (build_delta_content virtueF#1 mf'))))
        by (eapply step_release with (b0:=b2); now eauto).
      econstructor; simpl;
        by eauto.
      
      assert (HinvC':
                invariant (updLockSet
                             (updThread pfc (Kresume c Vundef) newThreadPerm)
                             (b, Ptrofs.intval ofs) virtueLP))
        by  (eapply StepLemmas.safeC_invariant with (n := fuelF.+1 + size xs); eauto).
      
      assert (HmaxF': max_inv mf')
        by (eapply max_inv_store; eauto).

      assert (Hcanonical: isCanonical virtueLP.1 /\ isCanonical virtueLP.2).
      { clear - HmemCompC'.
        destruct HmemCompC'.
        destruct (compat_lp0 (b, Ptrofs.intval ofs) virtueLP
                               ltac:(erewrite gssLockRes; eauto)).
        split;
        eapply canonical_lt; eauto.
      }

      assert (HmemCompF'' : mem_compatible tpf'' mf').
      { subst.
        eapply store_compatible; eauto.
        eapply mem_compatible_sync; eauto.
        unfold isCanonical.
        rewrite Hcanonical.1. reflexivity.
        unfold isCanonical.
        rewrite Hcanonical.2. reflexivity.
        eapply (mem_compf Hsim).
        eapply (codomain_valid (weak_obs_eq (obs_eq_data Htsim))).
      }
      subst.

      assert (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b).
      intros.
        by (intros;
            erewrite <- restrPermMap_valid with (Hlt := Hlt');
            split;
            [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
              by eauto).
        assert (Hvb': forall b, ~ Mem.valid_block mc b <-> ~ Mem.valid_block mc' b)
          by (intros; split; intros Hinvalid Hcontra;
                by apply Hvb in Hcontra).

        assert (HvbF: forall b, Mem.valid_block mf b <-> Mem.valid_block mf' b)
          by (
              intros;
              erewrite <- restrPermMap_valid with (Hlt := HltF');
              split;
              [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
                by eauto).

      eapply Build_sim with (mem_compc := HmemCompC') (mem_compf := HmemCompF'').
      - 
        clear - HnumThreads.
        intros j.
        split; intros cntj;
        eapply cntUpdateL;
        eapply cntUpdate;
        apply cntUpdateL' in cntj;
        apply cntUpdate' in cntj;
          by eapply HnumThreads.
      - 
        intros sched tr.
        eapply HybridCoarseMachine.csafe_trace;
          now eauto.
      - 
        intros j pfcj' pffj'.
        assert (pfcj: containsThread tpc j)
          by auto.
        assert (pffj: containsThread tpf j)
          by auto.
        specialize (HsimWeak _ pfcj pffj).

        clear - Hvb Hvb' HvbF HstoreF Hstore HsimWeak Hsim newThreadPerm.
      
          assert (Hlt:
                    forall (b1 b0 : block) (ofs0 : Z),
                      fp i pfc b1 = Some b0 ->
                      Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#1) b1 ofs0 Cur)
                                       (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj').1) b0 ofs0 Cur) /\
                      Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#2) b1 ofs0 Cur)
                                       (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj').2) b0 ofs0 Cur)).
          { intros b1 b0 ofs0 Hrenaming.
            pose proof (perm_obs_weak (weak_tsim_data HsimWeak)) as Hperm_data.
            pose proof (perm_obs_weak (weak_tsim_locks HsimWeak)) as Hperm_locks.
            specialize (Hperm_data _ _ ofs0 Hrenaming).
            specialize (Hperm_locks _ _ ofs0 Hrenaming).
            destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
            - 
              subst j.
              Tactics.pf_cleanup.
              rewrite! restrPermMap_Cur gLockSetRes gssThreadRes;
                rewrite! gLockSetRes gssThreadRes.
              pose proof (injective (weak_tsim_data HsimWeak)).

              assert (Hproject1: Maps.PTree.get b0 (projectAngel (fp i pfc) virtueThread.1) =
                                 Maps.PTree.get b1 virtueThread.1)
                by (symmetry; eapply projectAngel_correct; eauto).
              assert (Hproject2: Maps.PTree.get b0 (projectAngel (fp i pfc) virtueThread.2) =
                                 Maps.PTree.get b1 virtueThread.2)
                by (symmetry; eapply projectAngel_correct; eauto).
              split; simpl in *.
              + destruct (Maps.PTree.get b1 virtueThread.1) as [df|] eqn:Hdelta.
                * destruct (df ofs0) as [pnew |] eqn:Hdf.
                  rewrite (computeMap_1 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_1 _ _ _ _ Hproject1 Hdf);
                    by eapply po_refl.
                rewrite (computeMap_2 _ _ _ _ Hdelta Hdf).
                rewrite (computeMap_2 _ _ _ _ Hproject1 Hdf);
                  by do 2 rewrite restrPermMap_Cur in Hperm_data.
                *  rewrite (computeMap_3 _ _ _ _ Hdelta).
                rewrite (computeMap_3 _ _ _ _ Hproject1);
                  by do 2 rewrite restrPermMap_Cur in Hperm_data.
              + destruct (Maps.PTree.get b1 virtueThread.2) as [df|] eqn:Hdelta.
                * destruct (df ofs0) as [pnew |] eqn:Hdf.
                  rewrite (computeMap_1 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_1 _ _ _ _ Hproject2 Hdf);
                    by eapply po_refl.
                  rewrite (computeMap_2 _ _ _ _ Hdelta Hdf).
                  rewrite (computeMap_2 _ _ _ _ Hproject2 Hdf);
                    by do 2 rewrite restrPermMap_Cur in Hperm_locks.
                *  rewrite (computeMap_3 _ _ _ _ Hdelta).
                   rewrite (computeMap_3 _ _ _ _ Hproject2);
                     by do 2 rewrite restrPermMap_Cur in Hperm_locks.
            - erewrite! restrPermMap_Cur.
              assert (pfcj0: containsThread (updThread pfc (Kresume c Vundef) newThreadPerm) j)
                by (apply cntUpdate; auto).
              assert (pffj0: containsThread (updThread pff (Kresume cf Vundef)
                                                       (computeMap (getThreadR pff)#1 virtueF#1, computeMap (getThreadR pff)#2 virtueF#2)) j)
                by (apply cntUpdate; auto).
              erewrite gLockSetRes with (cnti := pfcj0).
              erewrite gLockSetRes with (cnti := pffj0).
              erewrite gsoThreadRes with (cntj := pfcj); eauto.
              erewrite gsoThreadRes with (cntj := pffj); eauto.
              split;
                [do 2 erewrite restrPermMap_Cur in Hperm_data |
                 do 2 erewrite restrPermMap_Cur in Hperm_locks];
                  by assumption. }

          destruct HsimWeak. destruct weak_tsim_data0.
          constructor; intros; constructor; intros; simpl;
          repeat
            (match goal with
             | [H: context[Mem.valid_block (restrPermMap _) _] |- _] =>
               erewrite restrPermMap_valid in H
             | [H: ~ Mem.valid_block _ _ |- _] =>
               apply Hvb' in H; clear Hvb'
             | [H: Mem.valid_block _ _ |- _] =>
               apply Hvb in H; clear Hvb
             | [|- Mem.valid_block (restrPermMap _) _] =>
               erewrite restrPermMap_valid
             | [|- Mem.valid_block _ _] =>
               eapply HvbF; clear HvbF
             end); eauto;
            try (by specialize (codomain_valid0 _ _ H));
            destruct (Hlt _ _ ofs0 Hrenaming);
            eauto.
          
      - intros k j cntk' cntj' Hkj b0 b0' b3 b3' Hf0 Hf0' Hfk' Hfj'.
        assert (cntk: containsThread tpc k)
          by auto.
        assert (cntj: containsThread tpc j)
          by auto.
        erewrite cnt_irr with (cnt1 := cntk') (cnt2 := cntk) in Hfk'.
        erewrite cnt_irr with (cnt1 := cntj') (cnt2 := cntj) in Hfj'.
        eapply (HfpSep _ _ cntk cntj Hkj b0 b0');
          by eauto.
      - 
        intros.
        destruct (tid == i) eqn:Htid; move/eqP:Htid=>Htid; subst.
        { 
          exists (updLockSet
               (updThread pfc (Kresume c Vundef)
                          (computeMap (getThreadR pfc).1 virtueThread.1,
                           computeMap (getThreadR pfc).2 virtueThread.2))
               (b, Ptrofs.intval ofs) virtueLP), mc'.
          assert (pfc0 = pfc)
            by (eapply cnt_irr; eauto); subst pfc0.
          rewrite Hsynced.
          split; first by apply ren_incr_refl.
          split; first by auto.
          split; first by constructor.
          split.
          
          intros.
          destruct Htsim as [_ Hmem_obs_eq_data Hmem_obs_eq_locks].
          constructor.
          rewrite! gLockSetCode.
          do 2 rewrite gssThreadCode;
            by (split; [assumption | constructor]).

          assert (Hlt1: permMapLt (computeMap (getThreadR pfc).1 virtueThread.1) (getMaxPerm mc')).
          { destruct mem_compc'.
            destruct (compat_th0 _ pfc').
            rewrite gLockSetRes  gssThreadRes in H.
            eauto.
          }

          erewrite restrPermMap_irr' with (Hlt' := Hlt1)
            by (rewrite gLockSetRes gssThreadRes; eauto).

          assert (Hlt1F: permMapLt (computeMap (getThreadR pff).1 virtueF.1) (getMaxPerm mf')).
          { destruct HmemCompF''.
            destruct (compat_th0 _ pff0).
            rewrite gLockSetRes  gssThreadRes in H.
            eauto.
          }
          erewrite restrPermMap_irr' with (Hlt' := Hlt1F)
            by (rewrite gLockSetRes gssThreadRes; eauto).

          eapply gss_mem_obs_eq_unlock with (Hlt2 := (compat_th _ _ HmemCompC pfc).1) (Hlt2F := (compat_th _ _ (mem_compf Hsim) pff).1)
                                                                          (rmapF := projectMap (fp i pfc) virtueLP#1);
            eauto; try reflexivity.
          try (erewrite! Mem.store_mem_contents by eauto).
          reflexivity.
          try (erewrite! Mem.store_mem_contents by eauto); reflexivity.
          intros b0 Hunmapped ofs0.
          erewrite projectMap_correct_2 by eauto.
          simpl.
          erewrite computeMap_projection_2 by eauto.
          rewrite Hcanonical.1. left; auto.
          intros; simpl; erewrite computeMap_projection_1 by eauto.
          reflexivity.
          intros; erewrite projectMap_correct by eauto.
          reflexivity.
          
          assert (Hlt2: permMapLt (computeMap (getThreadR pfc).2 virtueThread.2) (getMaxPerm mc')).
          { destruct mem_compc'.
            destruct (compat_th0 _ pfc').
            rewrite gLockSetRes  gssThreadRes in H0.
            eauto.
          }
          erewrite restrPermMap_irr' with (Hlt' := Hlt2)
            by (rewrite gLockSetRes gssThreadRes; eauto).

          assert (Hlt2F: permMapLt (computeMap (getThreadR pff).2 virtueF.2) (getMaxPerm mf')).
          { destruct HmemCompF''.
            destruct (compat_th0 _ pff0).
            rewrite gLockSetRes  gssThreadRes in H0.
            eauto.
          }
          erewrite restrPermMap_irr' with (Hlt' := Hlt2F)
            by (rewrite gLockSetRes gssThreadRes; eauto).
          eapply gss_mem_obs_eq_unlock with
              (Hlt2 := (compat_th _ _ HmemCompC pfc).2)
              (Hlt2F := (compat_th _ _ (mem_compf Hsim) pff).2)
                                        (rmapF := projectMap (fp i pfc) virtueLP#2);
            try (erewrite! Mem.store_mem_contents by eauto);
            eauto; try reflexivity.
          intros b0 Hunmapped ofs0.
          erewrite projectMap_correct_2 by eauto.
          simpl.
          erewrite computeMap_projection_2 by eauto.
          rewrite Hcanonical.2. left; auto.
          intros; simpl; erewrite computeMap_projection_1 by eauto.
          reflexivity.
          intros; erewrite projectMap_correct by eauto.
          reflexivity.

          split; first by congruence.
            split; first by congruence.
            rewrite gLockSetRes gssThreadRes;
              simpl; intros; rewrite! computeMap_projection_2;
            eauto.
          }
          { 
            assert (Hstrong_sim := simStrong Hsim).
            assert (pfcj: containsThread tpc tid)
              by (eapply cntUpdateL' in pfc0;
                   eapply cntUpdate' in pfc0;
                   eauto).
            assert (pffj: containsThread tpf tid)
              by (eapply cntUpdateL' in pff0;
                   eapply cntUpdate' in pff0;
                   eauto).
            specialize (Hstrong_sim _ pfcj pffj).
            destruct Hstrong_sim
              as (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
                  & Hownedj & Hownedj_lp & Hunmapped_j).
            
            assert (pfcij:= containsThread_internal_execution Hexecj pfc).

            assert (pfcjj: containsThread tpcj tid)
              by (eapply containsThread_internal_execution; eauto).
            assert (Hcompj: mem_compatible tpcj mcj)
              by (eapply internal_execution_compatible with (tp := tpc); eauto).
            specialize (Htsimj pfcjj Hcompj).

            assert (Htsimj_id:
                      tp_wd (id_ren mc) tpc /\
                      ctl_inj (id_ren mc) (getThreadC pfcj) (getThreadC pfc0) /\
                      mem_obs_eq (id_ren mc) (restrPermMap (compat_th _ _ HmemCompC pfcj).1) (restrPermMap (compat_th _ _ HmemCompC' pfc0).1) /\
                      (Mem.nextblock mc = Mem.nextblock mc')).
            { split.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
              eapply strong_tsim_store_id; eauto.
              erewrite gLockSetRes.
              rewrite gsoThreadRes; eauto.
              erewrite gLockSetCode.
              rewrite gsoThreadCode; eauto.
              destruct HinvC.
              pose proof ((no_race_thr0 _ _ pfcj pfc Htid).1) as Hdisjoint.
              pose proof ((thread_data_lock_coh0 _ pfc ).1 _ pfcj) as Hcoh.
              left.
              apply setPermBlock_coherent; eauto.
              
              apply Mem.load_valid_access in Hload.
              destruct Hload as [Hload _].
              intros.
              specialize (Haccess ofs' H).
              unfold Mem.perm in Haccess.
              intros Hcontra.
              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC pfc).2 b ofs') as Hperm_at.
              unfold permission_at in Hperm_at.
              rewrite Hperm_at in Haccess.
              specialize (Hcoh b ofs').
              destruct ((getThreadR pfcj).1 # b ofs') as [p1|];
                destruct ((getThreadR pfc).2 # b ofs') as [p2|];
                simpl in Hcontra, Haccess; auto;
                  inversion Hcontra; inversion Haccess; subst;
                    simpl in Hcoh;
                    now auto.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
            }
            destruct Htsimj_id as [Htpc_id_wd [Hctlj_id [Hmem_obs_eqj_id Hnextblock]]].

            assert (H := mem_obs_eq_execution _ _ _ _ _ HinvC' Hfg Hge_wd Hge_incr_id
                                              Hmemc_wd Htpc_id_wd Hctlj_id Hmem_obs_eqj_id Hexecj).
            destruct H as
                (tp2' & m2' & f' & Hexecj'& Hincrj' & Hsepj'
                 & Hnextblock' & Hinvj' & Htsimj' & Hid').
            destruct Htsimj' as (pf2j & pf2j' & Hcomp2 & Hcomp2' & Hctl_eqj' & Hmem_obs_eq').
            specialize (Hid' Hnextblock (id_ren_correct mc)).
            assert (f' = id_ren mcj)
              by ( pose ((mem_obs_eq_domain_ren Hmem_obs_eq'));
                   eapply is_id_ren; eauto); subst f'.
            exists tp2', m2'.
            erewrite cnt_irr with (cnt1 := pfc0) (cnt2 := pfcj).
            split; first by auto.
            split; first by auto.
            split; first by auto.
            split.
            
            intros.
            Tactics.pf_cleanup.
            
            assert (Htsim2j: ctl_inj (fp tid pfcj) (getThreadC pf2j') (getThreadC pffj) /\
                             mem_obs_eq (fp tid pfcj) (restrPermMap (compat_th _ _ Hcomp2' pf2j').1)
                                        (restrPermMap (compat_th _ _ (mem_compf Hsim) pffj).1)).
            { destruct Htsimj.
              eapply strong_tsim_id_trans
              with (f := fp tid pfcj) (Hcomp1 := Hcompj) (Hcomp1' := Hcomp2');
              eauto.
              destruct Hnextblock' as [[p [Hmcj Hm2']] | [Hmcj Hm2']];
              unfold Mem.valid_block;
              rewrite Hmcj Hm2' Hnextblock;
                by tauto.
            }

            destruct Htsim2j as [Hcodeq2j Hmem_obs_eq2j].
            constructor.
            rewrite gLockSetCode.
            rewrite gsoThreadCode;
              by auto.
            clear - Hmem_obs_eq2j HstoreF HinvF Htid HloadF HaccessF.
            assert (HeqRes: getThreadR pff0 = getThreadR pffj)
              by (rewrite gLockSetRes;
                   rewrite gsoThreadRes; auto).
            assert (Hlt : permMapLt (getThreadR pff0).1 (getMaxPerm mf))
            by (rewrite HeqRes; eapply (compat_th _ _ (mem_compf Hsim) pffj).1).
            eapply mem_obs_eq_storeF with (mf := mf) (Hlt :=  Hlt);
              eauto.
            apply Mem.load_valid_access in HloadF.
            pose proof (((thread_data_lock_coh _ HinvF) _ pff).1 _ pffj).
            pose proof (cntUpdateL' _ _ pff0) as pffj'.
            erewrite gLockSetRes with (cnti := pffj').
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            left.
            apply setPermBlock_coherent; eauto.
            intros ofs' Hrange Hcontra.
            specialize (HaccessF ofs' Hrange).
            unfold Mem.perm in HaccessF.
            specialize (H b2 ofs').
            pose proof (restrPermMap_Cur (compat_th _ _ (mem_compf Hsim) pff).2 b2 ofs') as Heq.
            unfold permission_at in Heq.
            rewrite Heq in HaccessF.
            destruct ((getThreadR pffj).1 # b2 ofs') as [p1|]; simpl in Hcontra;
              [| assumption];
              inversion Hcontra; subst;
              destruct ((getThreadR pff).2 # b2 ofs') as [p2|]; simpl in HaccessF;
                now auto.
            erewrite restrPermMap_irr' with (Hlt := Hlt)
                                            (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).1);
              eauto.
            rewrite HeqRes. reflexivity.

            pose proof (obs_eq_locks Htsimj).

            assert (HRj_eq: (getThreadR pf2j').2 = (getThreadR pfcjj).2).
            { erewrite <- internal_execution_locks_eq with (cntj := pfc0) by eauto.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) by eauto.
              rewrite gLockSetRes.
              erewrite gsoThreadRes by eauto;
                reflexivity.
            }

            assert (Hlt2C: permMapLt (getThreadR pfcjj).2 (getMaxPerm m2'))
              by ( rewrite <- HRj_eq;
                   eapply (compat_th _ _ Hcomp2' pf2j').2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2C) by eauto.

            assert (HRj_eqF: (getThreadR pff0)#2 = (getThreadR pffj)#2)
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pffj) by eauto;
                  reflexivity).

            assert (Hlt2F: permMapLt (getThreadR pffj).2 (getMaxPerm mf'))
              by (rewrite <- HRj_eqF; eapply (compat_th _ _ HmemCompF'' pff0).2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2F) by eassumption.

            assert (Hstable_mc2': forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                             ZMap.get ofs1 (Mem.mem_contents mc') # b1 = ZMap.get ofs1 (Mem.mem_contents m2') # b1).
            { intros.
              erewrite <- internal_exec_disjoint_locks with (Hcomp := HmemCompC') (m := mc') (m' := m2') (pfj := pfc0); eauto.
              unfold Mem.perm.
              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).2 b1 ofs1) as Hpermj.
              unfold permission_at in Hpermj.
              rewrite Hpermj.
              rewrite gLockSetRes.
              erewrite gsoThreadRes with (cntj := pfcj) by eauto.
              assumption.
            }

            assert (Hstable_mcj: forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                            ZMap.get ofs1 (Mem.mem_contents mc) # b1 =
                                            ZMap.get ofs1 (Mem.mem_contents mcj) # b1).
            { intros.
              erewrite internal_exec_disjoint_locks
              with (Hcomp := HmemCompC) (pfj := pfcj) (m := mc) (tp := tpc) (tp' := tpcj); eauto.
              unfold Mem.perm in *.

              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC pfcj).2 b1 ofs1) as Hpermj.
              unfold permission_at in *.
              rewrite Hpermj. assumption.
            }

            assert (Hperm_eqj: forall b1 ofs1, (Mem.mem_access (restrPermMap (compat_th _ _ Hcompj pfcjj).2)) # b1 ofs1 Cur =
                                          (getThreadR pfcj).2 # b1 ofs1).
            { intros.
              pose proof (restrPermMap_Cur (compat_th _ _ Hcompj pfcjj).2 b1 ofs1) as Hpermjj.
              unfold permission_at in Hpermjj.
              rewrite Hpermjj.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) at 1
                by eauto.
              reflexivity.
            }

            eapply mem_obs_eq_disjoint_lock
            with (ofsl := Ptrofs.intval ofs) (bl1 := b)
                                          (bl2 := b2) (sz := size_chunk Mint32); eauto.
            
            intros. unfold Mem.valid_block in *.
            destruct Hnextblock' as [[p [Hnextj Hnext2]] | [Hnextj Hnext2]];
              rewrite Hnextj Hnext2 Hnextblock;
              split; now auto.

            intros ofs0 Hrange.
                        assert (Hlock_unwrittable: ~ Mem.perm (restrPermMap (compat_th _ _ HmemCompC' pfc0)#1) b ofs0 Cur Writable).
            { clear - Hload HinvC Hrange pfcj Htid.
              pose proof (((thread_data_lock_coh _ HinvC _ pfc).1) _ pfcj b ofs0) as Hcoh.
              apply Mem.load_valid_access in Hload.
              destruct Hload as [Hperm _].
              specialize (Hperm ofs0 Hrange).
              unfold Mem.perm in *.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).1) b ofs0) as Hpermj'.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC pfc).2) b ofs0) as Hpermi.
              unfold permission_at in *.
              rewrite Hpermi in Hperm.
              rewrite Hpermj'.
              rewrite gLockSetRes.
              erewrite gsoThreadRes with (cntj := pfcj) by eauto.
              intros Hcontra.
              destruct ((getThreadR pfcj).1 # b ofs0) as [p|]; try (by exfalso);
                destruct p; simpl in Hcontra; inversion Hcontra; subst;
                  destruct ((getThreadR pfc).2 # b ofs0) as [p|];
                  try (by exfalso); inversion Hcontra; subst.
            }

            erewrite <- internal_exec_stable with (m := mc') (Hcomp := HmemCompC') (pfi := pfc0); eauto.
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            simpl.
            rewrite! Maps.PMap.gss.
            erewrite! setN_inside
              by (rewrite length_inj_bytes encode_int_length; simpl in Hrange; auto).
            destruct (List.nth_in_or_default (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.one))) Undef).
            apply inj_bytes_type in i0.
            destruct (List.nth (Z.to_nat  (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.one))) Undef); try by exfalso.
            now constructor.
            rewrite e. now constructor.
            eapply Mem.store_valid_block_1; eauto.
            
            intros.
            unfold Mem.perm in H1.
            erewrite Hperm_eqj in H1.
            erewrite <- Hstable_mc2' by eauto.
            erewrite <- Hstable_mcj by eauto.
            
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            destruct H0 as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.

            intros b0 ofs0 Hneq Hreadable.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            destruct Hneq as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.
            eauto.
            split.
            
            intros k pff2k Hjk b1 b0 ofs0 Hfj Hfi.
            destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
            { subst k.
              rewrite gLockSetRes.
              rewrite gssThreadRes; auto.
              assert (Hunmapped: ~ (exists b, (fp i pfc) b = Some b0)).
              { intros Hcontra.
                destruct Hcontra as [b3 Hcontra].
                assert (Hfj' := Hincrj _ _ Hcontra).
                assert (Heq := injective (weak_obs_eq (obs_eq_data Htsimj)) _ _ Hfj Hfj');
                  subst b3.
                  by congruence.
              }
              simpl.
              erewrite! computeMap_projection_2;
                by eauto.
            }
            { rewrite gLockSetRes.
              rewrite gsoThreadRes; auto.
              eapply Hownedj;
                by eauto.
            }
            split.
            
            intros bl ofsl rmap0 b1 b0 ofs0 Hfj Hfi Hres.
            destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)) as [Heq | Hneq].
            
            inversion Heq; subst.
            rewrite gssLockRes in Hres. inversion Hres.
            assert (~ exists b, fp i pfc b = Some b0).
            { intros Hcontra.
              destruct Hcontra as [b' Hfb'].
              assert (Hfb'' := Hincrj _ _ Hfb').
              assert (b' = b1)
                by (eapply (injective (weak_obs_eq (obs_eq_data Htsimj)));
                     eauto). subst b'.
                by congruence.
            }
            simpl.
            erewrite! projectMap_correct_2 by eauto.
            rewrite Hcanonical.1 Hcanonical.2.
            split;
              reflexivity.
            
            rewrite gsoLockRes in Hres; auto.
            rewrite gsoThreadLPool in Hres;
              by eauto.
            
            intros b0 Hunmapped ofs0.
            rewrite gLockSetRes.
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            eapply Hunmapped_j;
              by eauto.
          }
          
      - split.
        { intros bl1 bl2 ofs0 rmap1 rmap2 Hfi Hres1 Hres2.
          destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)) as [Heq | Hneq].
            { 
              inversion Heq; subst.
              assert (bl2 = b2)
                by (rewrite Hfi in Hfb; by inversion Hfb).
              subst bl2.
              assert (Hperm_eq: forall b1 b0 ofs0, fp i pfc b1 = Some b0 ->
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#1) b0 ofs0 Cur =
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#1) b1 ofs0 Cur /\
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#2) b0 ofs0 Cur =
                                    permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#2) b1 ofs0 Cur).
              { intros.
                rewrite! restrPermMap_Cur.
                rewrite gssLockRes in Hres1.
                rewrite gssLockRes in Hres2.
                inversion Hres1; inversion Hres2.
                subst. simpl.
                split;
                  erewrite <- projectMap_correct by eauto;
                  reflexivity.
              }

              assert(forall b1 b0 ofs0,
                        (fp i pfc) b1 = Some b0 ->
                        (Mem.perm (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#1) b1 ofs0 Cur Readable \/
                         Mem.perm (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#2) b1 ofs0 Cur Readable) ->
                        memval_obs_eq (fp i pfc) (ZMap.get ofs0 (Mem.mem_contents mc') # b1) (ZMap.get ofs0 (Mem.mem_contents mf') # b0)).
              { intros b1 b0 ofs0 Hrenaming Hperm.
                pose proof Hres1 as Hres1b.
                rewrite gssLockRes in Hres1b.
                inversion Hres1b; subst.
                pose proof (restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#1 b1 ofs0) as Hperm_1.
                pose proof (restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#2 b1 ofs0) as Hperm_2.
                unfold permission_at, Mem.perm in Hperm_1, Hperm_2, Hperm.
                rewrite Hperm_1 Hperm_2 in Hperm.
                
                destruct Hperm as [Hperm | Hperm].
                - specialize (Hangel1 b1 ofs0).
                  apply permjoin_comm in Hangel1.
                  apply permjoin_readable_if in Hangel1.
                  
                  pose proof (strong_obs_eq (obs_eq_data Htsim)) as Hstrong_obs_eq.
                  pose proof ((compat_th _ _ (store_compatible _ _ _ _ _ HmemCompC Hstore) pfc).1) as Hlt.
                  eapply strong_mem_obs_eq_store with (bl1 := bl1) (Hlt2 := Hlt); eauto.
                  erewrite Mem.store_mem_contents by eauto; reflexivity.
                  erewrite Mem.store_mem_contents by eauto; reflexivity.
                  unfold Mem.perm.
                  rewrite <- restrPermMap_Cur with (Hlt := Hlt) in Hangel1.
                  assumption.
                  assumption.
                - specialize (Hangel2 b1 ofs0).
                  apply permjoin_comm in Hangel2.
                  apply permjoin_readable_if in Hangel2.
                  
                  pose proof (strong_obs_eq (obs_eq_locks Htsim)) as Hstrong_obs_eq.
                  pose proof ((compat_th _ _ (store_compatible _ _ _ _ _ HmemCompC Hstore) pfc).2) as Hlt.
                  eapply strong_mem_obs_eq_store with (bl1 := bl1) (Hlt2 := Hlt); eauto.
                  erewrite Mem.store_mem_contents by eauto; reflexivity.
                  erewrite Mem.store_mem_contents by eauto; reflexivity.
                  unfold Mem.perm.
                  rewrite <- restrPermMap_Cur with (Hlt := Hlt) in Hangel2.
                  assumption.
                  assumption.
              }
              split;
                constructor; intros;
                  try (destruct (Hperm_eq b1 b0 ofs0 Hrenaming); by auto).
            }
            { 
              assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
              { clear - Hneq Hfi Hf Hfb Htsim.
                intros Hcontra; inversion Hcontra; subst.
                assert (b = bl1)
                  by (eapply (injective (weak_obs_eq (obs_eq_data Htsim))); eauto).
                subst;
                  by auto.
              }
                pose proof Hres1 as Hres1';
                  pose proof Hres2 as Hres2'.
                erewrite gsoLockRes, gsoThreadLPool in Hres1' by auto.
                erewrite gsoLockRes, gsoThreadLPool in Hres2' by auto.
                destruct (HsimRes _ _ _ _ _ Hfi Hres1' Hres2') as [Hsim1 Hsim2].
                split;
                  eapply strong_mem_obs_eq_store with (bl1 := b) (bl2 := b2); eauto;
                    try (erewrite Mem.store_mem_contents by eauto; reflexivity).
            }
          }
          split.
          
          intros bl2 ofs0 Hres.
          destruct (EqDec_address (bl2, ofs0) (b2, Ptrofs.intval ofs)) as [Heq | Hneq].
          inversion Heq; subst.
          eexists;
            by eauto.
          erewrite gsoLockRes, gsoThreadLPool in Hres by auto.
          eapply Hlock_mapped;
            by eauto.
          
          { intros bl1 bl2 ofs0 Hfl1.
            destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)).
            - inversion e; subst.
              assert (b2 = bl2)
                by (rewrite Hf in Hfl1; inversion Hfl1; subst; auto).
              subst.
              do 2 rewrite gsslockResUpdLock.
              split;
              auto.
            - erewrite gsolockResUpdLock by auto.
              assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
              { intros Hcontra.
                inversion Hcontra; subst.
                specialize (Hinjective _ _ _ Hfl1 Hfb).
                subst; auto.
              }
              erewrite gsolockResUpdLock by eauto.
              do 2 rewrite gsoThreadLPool.
              eauto.
          }
      - 
          intros bl ofsl rmap0 Hres b0 Hunmapped ofs0.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)).
          + inversion e; subst.
            rewrite gsslockResUpdLock in Hres.
            inversion Hres; subst.
            simpl.
            erewrite! projectMap_correct_2 by auto.
            rewrite Hcanonical.1 Hcanonical.2.
            split; reflexivity.
          + erewrite gsolockResUpdLock in Hres by auto.
            rewrite gsoThreadLPool in Hres.
            eapply HunmappedRes;
              now eauto.
        - 
          destruct Htsim.
          eapply invariant_project; eauto;
            by destruct Hcanonical.
        - 
          assumption.
        - 
          eapply store_wd_domain with
              (m := (restrPermMap Hlt')); eauto.
            by simpl.
        - 
          apply tp_wd_lockSet.
          intros j cntj'.
          destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
          subst. rewrite gssThreadCode.
          specialize (Htpc_wd _ pfc).
          rewrite Hcode in Htpc_wd.
          simpl in *;
            by auto.
          assert (cntj := cntUpdate' _ _ _ cntj').
          erewrite @gsoThreadCode with (cntj := cntj) by assumption.
          specialize (Htpc_wd _ cntj);
            by auto.
        - 
          assumption.
        - 
          split; assumption.
        - intros.
          apply cntUpdateL;
            apply cntUpdate;
              by eauto.
        - econstructor 2;
            eauto.
          destruct virtueLP as [vLP1 vLP2].
          assert (Hempty: forall b1 ofs, fp i pfc b1 = None ->
                                    (getThreadR pfc)#1 # b1 ofs = None /\
                                    (getThreadR pfc)#2 # b1 ofs = None).
          { intros.
            assert (Hinvalid: ~ Mem.valid_block mc b1).
            { destruct (HsimWeak _ pfc pff).
              destruct weak_tsim_data0.
              intros Hcontra.
              eapply domain_valid0 in Hcontra.
              destruct Hcontra.
              congruence.
            }
            eapply @mem_compatible_invalid_block with (ofs := ofs0) in Hinvalid; eauto.
            destruct Hinvalid.
            now eauto.
          }
          econstructor; eauto using projectAngel_correct;
          repeat (split);
          try (now eapply projectMap_correct).
                    admit.
          admit.
          admit.
    }
    { 
      subst.
            assert (Hcore_inj:= code_eq Htsim).
      rewrite Hcode in Hcore_inj.
      simpl in Hcore_inj.
      subst.
      destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
        try by exfalso.
      
      assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj (obs_eq_data Htsim)).
      rewrite Hat_external in Hat_external_spec.
      destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
        as [[? vsf] | ] eqn:Hat_externalF;
        try by exfalso.
            destruct Hat_external_spec as [? Harg_obs]; subst.
      inversion Harg_obs as [|? vff argf vsf' Hptr_obs Hl]; subst.
      inversion Hl; subst.
      inversion H3; subst. clear H3.
      inversion Hptr_obs; subst.
            remember (projectAngel (fp i pfc) virtue1.1, projectAngel (fp i pfc) virtue1.2)
        as virtue1F eqn:Hvirtue1F.
      remember (projectAngel (fp i pfc) virtue2.1, projectAngel (fp i pfc) virtue2.2)
        as virtue2F eqn:Hvirtue2F.
      pose (computeMap (getThreadR pff).1 virtue1F.1, computeMap (getThreadR pff).2 virtue1F.2)
        as threadPermF'.
      pose (computeMap empty_map virtue2F.1, computeMap empty_map virtue2F.2) as newThreadPermF.
      remember (updThread pff (Kresume cf Vundef) threadPermF')
        as tpf_upd eqn:Htpf_upd.
      remember (addThread tpf_upd (Vptr b2 ofs) v' newThreadPermF)
        as tpf' eqn:Htpf'.

      assert (HangelF1: permMapJoin newThreadPermF.1 threadPermF'.1 (getThreadR pff).1).
      { pose proof (obs_eq_data Htsim) as Hmem_obs_eq.
        eapply permMapJoin_project with (f := fp i pfc) (pmap := newThreadPerm.1) (pmap' := threadPerm'.1);
          eauto.
        intros b0 Hunmapped ofs0.
        subst; simpl.
        erewrite! computeMap_projection_2 by eauto.
        left; split;
          by eauto using empty_map_spec.
        subst; simpl; intros;
          by erewrite computeMap_projection_3 by eauto.
        subst; simpl; intros;
          by erewrite computeMap_projection_1 by eauto.
        intros b1 b0 ofs0 Hrenaming.
        pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq) b1 ofs0 Hrenaming) as Hperm_eq.
        rewrite! restrPermMap_Cur in Hperm_eq.
        now auto.
      }

      assert (HangelF2: permMapJoin newThreadPermF.2 threadPermF'.2 (getThreadR pff).2).
      { pose proof (obs_eq_locks Htsim) as Hmem_obs_eq.
        eapply permMapJoin_project with (f := fp i pfc) (pmap := newThreadPerm.2) (pmap' := threadPerm'.2);
          eauto.
        intros b0 Hunmapped ofs0.
        subst; simpl.
        erewrite! computeMap_projection_2 by eauto.
        left; split;
          by eauto using empty_map_spec.
        subst; simpl; intros;
          by erewrite computeMap_projection_3 by eauto.
        subst; simpl; intros;
          by erewrite computeMap_projection_1 by eauto.
        intros b1 b0 ofs0 Hrenaming.
        pose proof (perm_obs_strong (strong_obs_eq Hmem_obs_eq) b1 ofs0 Hrenaming) as Hperm_eq.
        rewrite! restrPermMap_Cur in Hperm_eq.
        now auto.
      }

      exists tpf', mf, (fp i pfc),
      (@addFP _ fp (fp i pfc) (Vptr b ofs) arg newThreadPerm),
      (trf ++ [:: (external i (spawn (b2,Ptrofs.intval ofs) (Some (build_delta_content virtue1F#1 mf)) (Some (build_delta_content virtue2F#1 mf))))]).
      split.
      
      intros U.
      
      assert (HargF: val_inject (Mem.flat_inj (Mem.nextblock mf)) v' v').
      { inversion H1; subst; auto.
        eapply (codomain_valid (weak_tsim_data (HsimWeak _ pfc pff))) in H.
        erewrite restrPermMap_valid in H.
        unfold Mem.flat_inj.
        econstructor.
        destruct (Coqlib.plt b0 (Mem.nextblock mf));
          [reflexivity |
           unfold Mem.valid_block in H;
           now exfalso].
        now rewrite Ptrofs.add_zero.
      } 
      assert (HsyncStepF: syncStep false pff (mem_compf Hsim) tpf' mf
                                   (spawn (b2,Ptrofs.intval ofs) (Some ((build_delta_content virtue1F#1 mf))) (Some (build_delta_content virtue2F#1 mf))))
        by (eapply step_create;
            now eauto).

      econstructor; now eauto.
      
      assert (HinvC': invariant
                        (addThread (updThread pfc (Kresume c Vundef) threadPerm')
                                   (Vptr b ofs) arg newThreadPerm))
        by  (eapply StepLemmas.safeC_invariant with (n := fuelF.+1 + size xs); eauto).

      assert (HmemCompF'' : mem_compatible tpf' mf)
        by (pose proof (codomain_valid (weak_obs_eq (obs_eq_data Htsim))); subst;
            pose proof (mem_compf Hsim);
            eapply mem_compatible_spawn; eauto).
      subst.

      assert (Hnum: OrdinalPool.num_threads tpc = OrdinalPool.num_threads tpf)
          by (eapply OrdinalPool.contains_iff_num; eauto).
      eapply Build_sim with (mem_compc := HmemCompC') (mem_compf := HmemCompF'').
        - 
          clear - HnumThreads Hnum.
          intros j.
          Transparent containsThread OrdinalPool.containsThread.
          split;
            intros cntj;
            apply cntAdd' in cntj;
            destruct cntj as [[cntj _] | Heq];
            try (apply cntAdd;
                 apply cntUpdate;
                 apply HnumThreads;
                   by apply cntUpdate' in cntj);
            try (unfold containsThread;
                 subst; simpl; unfold OrdinalPool.containsThread;
                 unfold OrdinalPool.latestThread, OrdinalPool.updThread;
                 simpl; rewrite Hnum;
                   by ssromega).
          Opaque containsThread OrdinalPool.containsThread.
        - 
          intros sched tr.
          eapply HybridCoarseMachine.csafe_trace;
            now eauto.
        - 
          clear - HsimWeak HnumThreads Htsim Hnum.
          intros j pfcj' pffj'.
          destruct (HsimWeak _ pfc pff) as [Hweak_data Hweak_locks];
            destruct Hweak_data as [? ? ? ? _].
          
          assert (Hperm: forall b1 b0 ofs0, fp i pfc b1 = Some b0 ->
                                       Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#1) b1 ofs0 Cur)
                                                        (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj')#1) b0 ofs0 Cur) /\
                                       Mem.perm_order'' (permission_at (restrPermMap (compat_th _ _ HmemCompC' pfcj')#2) b1 ofs0 Cur)
                                                        (permission_at (restrPermMap (compat_th _ _ HmemCompF'' pffj')#2) b0 ofs0 Cur)).
          { 
            intros b1 b0 ofs0 Hrenaming.
            rewrite! restrPermMap_Cur.
            assert (pfcj := cntAdd' _ _ _ pfcj').
            destruct pfcj as [[pfcj _] | pfcj].
            { 
              assert (pffj: containsThread
                              (updThread pff (Kresume cf Vundef) threadPermF') j)
                by (apply cntUpdate;
                    apply cntUpdate' in pfcj;
                      by eapply HnumThreads).
              erewrite gsoAddRes with (cntj := pfcj); eauto.
              erewrite gsoAddRes with (cntj := pffj); eauto.
                            destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
              - subst i.
                rewrite gssThreadRes.
                rewrite gssThreadRes.
                destruct Htsim.
                simpl; subst.
                erewrite! computeMap_projection_1 by eauto.
                split;
                  now apply po_refl.
              - assert (pfcj0 := cntUpdate' _ _ _ pfcj).
                assert (pffj0 := cntUpdate' _ _ _ pffj).
                erewrite gsoThreadRes with (cntj := pfcj0); eauto.
                erewrite gsoThreadRes with (cntj := pffj0); eauto.
                specialize (HsimWeak _ pfcj0 pffj0).
                clear - HsimWeak Hrenaming.
                destruct HsimWeak as [Hweak_data Hweak_locks].
                destruct Hweak_locks, Hweak_data.
                specialize (perm_obs_weak0 _ _ ofs0 Hrenaming).
                specialize (perm_obs_weak1 _ _ ofs0 Hrenaming).
                rewrite! restrPermMap_Cur in perm_obs_weak0 perm_obs_weak1;
                  split;
                  now assumption.
            }
            { 
              assert (pffj := cntAdd' _ _ _ pffj').
              destruct pffj as [[_ Hcontra] | pffj].
              subst. simpl in Hcontra.
              unfold OrdinalPool.latestThread in Hcontra.
              rewrite Hnum in Hcontra;
                by exfalso.
              subst.
              erewrite gssAddRes by eauto.
              erewrite gssAddRes by eauto.
              simpl; subst.
              erewrite! computeMap_projection_3 by eauto.
              split;
                now apply po_refl.
            }
          }
          constructor;
          constructor; intros;
          repeat
            (match goal with
             | [H: context[Mem.valid_block (restrPermMap _) _] |- _] =>
               erewrite restrPermMap_valid in H
             | [|- Mem.valid_block (restrPermMap _) _] =>
               erewrite restrPermMap_valid
             end); eauto;
            try (by specialize (codomain_valid0 _ _ H));
            now eapply Hperm.
        - 
          intros k j cntk' cntj' Hkj b0 b0' b3 b3' Hf0 Hf0' Hfk' Hfj'.
          
          destruct (i == j) eqn:Hij; move/eqP:Hij=> Hij;
            first by (subst j; rewrite gsoAddFP in Hfj'; by congruence).
          
          destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik;
            first by (subst k; rewrite gsoAddFP in Hfk'; by congruence).
          
          assert (cntj := cntAdd' _ _ _ cntj').
          destruct cntj as [[cntj _] | cntj].
          + 
            rewrite gsoAddFP in Hfj'.
            assert (cntk := cntAdd' _ _ _ cntk').
            destruct cntk as [[cntk _] | cntk].
            * 
              rewrite gsoAddFP in Hfk'.
              eapply (HfpSep k j cntk cntj Hkj b0 b0');
                by eauto.
            * 
              subst k.
              erewrite gssAddFP in Hfk'; auto.
                by congruence.
          + 
            subst.
            erewrite gssAddFP in Hfj'; auto.
              by congruence.
        - 
          intros j pfcj' pffj'.
          
          assert (pfcj := cntAdd' _ _ _ pfcj').
          destruct pfcj as [[pfcj _] | pfcj].
          + 
            assert (pffj: containsThread
                            (updThread pff (Kresume cf Vundef) threadPermF') j)
              by (apply cntUpdate;
                  apply cntUpdate' in pfcj;
                  eapply HnumThreads; eauto).
            destruct (j == i) eqn:Hj; move/eqP:Hj=>Hj; subst.
            { 
              exists (addThread
                   (updThread pfc (Kresume c Vundef) threadPerm') (Vptr b ofs)
                   arg newThreadPerm), mc'.
              rewrite Hsynced.
              rewrite gsoAddFP.
              assert (pfc'' : containsThread (updThread pfc (Kresume c Vundef) threadPerm') i)
                by (eapply cntUpdate; eauto).
              assert (pff'' : containsThread (updThread pff (Kresume cf Vundef) threadPermF') i)
                by (eapply cntUpdate; eauto).
              split; first by apply ren_incr_refl.
              split; first by auto.
              split; first by constructor.
              split.
              intros.
              
              destruct Htsim as [HcodeEq Hmem_obs_eq_data Hmem_obs_eq_locks].
              constructor.
              erewrite gsoAddCode with (cntj := pfcj); eauto.
              erewrite gsoAddCode with (cntj := pffj); eauto.
              rewrite Hcode HcodeF in HcodeEq.
              do 2 rewrite gssThreadCode.
              simpl in *;
                by (split; [auto | constructor]).
              
              eapply mem_obs_eq_changePerm with (Hlt := (compat_th _ _ HmemCompC pfc)#1)
                                                  (HltF := (compat_th _ _ (mem_compf Hsim) pff)#1); eauto.
              intros.
              erewrite gsoAddRes with (cntj := pfc'').
              erewrite gsoAddRes with (cntj := pff'').
              rewrite! gssThreadRes.
              simpl.
              erewrite computeMap_projection_1;
                by eauto.
              intros b0 ofs0 Hreadable'.
              erewrite gsoAddRes with (cntj := pfc'') in Hreadable'.
              rewrite gssThreadRes in Hreadable'.
              simpl in Hreadable'.
              specialize (Hangel1 b0 ofs0).
              apply permjoin_readable_iff in Hangel1.
              eapply Hangel1;
                 by eauto.

              eapply mem_obs_eq_changePerm with (Hlt := (compat_th _ _ HmemCompC pfc)#2)
                                                  (HltF := (compat_th _ _ (mem_compf Hsim) pff)#2); eauto.
              intros.
              erewrite gsoAddRes with (cntj := pfc'').
              erewrite gsoAddRes with (cntj := pff'').
              rewrite! gssThreadRes.
              simpl.
              erewrite computeMap_projection_1;
                by eauto.
              intros b0 ofs0 Hreadable'.
              erewrite gsoAddRes with (cntj := pfc'') in Hreadable'.
              rewrite gssThreadRes in Hreadable'.
              simpl in Hreadable'.
              specialize (Hangel2 b0 ofs0).
              apply permjoin_readable_iff in Hangel2.
              eapply Hangel2;
                by eauto.

              repeat (split; try (intros; by congruence));
              
              erewrite gsoAddRes with (cntj := pff'');
              rewrite gssThreadRes;
              simpl;
              erewrite computeMap_projection_2 by eauto;
              eapply Hunmapped_ls;
                by eauto.
            }
            { 
                             assert (Hstrong_sim := simStrong Hsim).
               assert (pfcj0: containsThread tpc j)
                 by ( eapply cntUpdate' in pfcj;
                      eauto).
               assert (pffj0: containsThread tpf j)
                 by (eapply HnumThreads; eauto).
               specialize (Hstrong_sim _ pfcj0 pffj0).
               destruct Hstrong_sim
                 as (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
                     & Hownedj & Hownedj_ls & Hownedj_lp).
               rewrite gsoAddFP.
               
               assert (pfcji := containsThread_internal_execution Hexecj pfc).
               
               exists (addThread (updThread pfcji
                                       (Kresume c Vundef) threadPerm')
                            (Vptr b ofs) arg newThreadPerm), mcj.
               assert (pfcjj := containsThread_internal_execution Hexecj pfcj0).
               assert (Hcompj: mem_compatible tpcj mcj)
                 by (eapply internal_execution_compatible with (tp := tpc); eauto).
               specialize (Htsimj pfcjj Hcompj).
               destruct Htsimj as [Hcode_eqj Hobs_eqj_data Hobs_eqj_locks].
               split; eauto.
               split; eauto.
               split.
               eapply addThread_internal_execution; eauto.
               apply updThread_internal_execution; eauto.
               eapply ThreadPoolWF.invariant_decr; eauto;
                 try (eapply permMapJoin_order; eauto).
               eapply mem_compatible_add;
                 by eauto.
               split.
               
               Tactics.pf_cleanup.
               intros.
               assert (pfcjj': containsThread
                                 (updThread pfcji (Kresume c Vundef) threadPerm') j)
                 by  (apply cntUpdate; auto).
               constructor.
                              erewrite gsoAddCode with (cntj := pfcjj'); eauto.
               rewrite gsoThreadCode; eauto.
               erewrite gsoAddCode with (cntj := pffj); eauto.
               rewrite gsoThreadCode;
                 by auto.
               
               erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ Hcompj pfcjj).1)
                 by (rewrite gsoAddRes gsoThreadRes; auto).
               erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj0).1)
                 by (rewrite gsoAddRes gsoThreadRes; auto).
               assumption.
               
               erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ Hcompj pfcjj).2)
                 by (rewrite gsoAddRes gsoThreadRes; auto).
               erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj0).2)
                 by (rewrite gsoAddRes gsoThreadRes; auto).
               assumption.
               split.
               
               intros k pffk' Hjk b0 b2' ofs0 Hfk Hfi.
               
               assert (Hunmapped: ~ (exists b, (fp i pfc) b = Some b2')).
               { intros Hcontra.
                 destruct Hcontra as [b3 Hcontra].
                 assert (Hfj' := Hincrj _ _ Hcontra).
                 assert (Heq := injective (weak_obs_eq Hobs_eqj_data) _ _ Hfk Hfj');
                   subst b3.
                   by congruence.
               }
               assert (pfck := cntAdd' _ _ _ pffk').
               destruct pfck as [[pfck _] | pfck].
               
               assert (pffk: containsThread
                               (updThread pff (Kresume cf Vundef) threadPermF') j)
                 by (apply cntUpdate; auto).
               erewrite gsoAddRes with (cntj := pfck); eauto.
               destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
               subst k.
               rewrite gssThreadRes.
               simpl.
               erewrite! computeMap_projection_2;
                 by eauto.
               rewrite gsoThreadRes; auto.
               eapply Hownedj;
                 by eauto.
               
               subst k.
               erewrite gssAddRes; eauto.
               simpl.
               erewrite! computeMap_projection_2 by eauto;
                 split;
                   by apply empty_map_spec.
               split.
               intros b0 b2' ofs0 Hfj Hfi.
               intros ofs1 ? ? Hres.
               rewrite gsoAddLPool in Hres.
               rewrite gsoThreadLPool in Hres;
                 by eauto.
               
               intros b0 Hunmapped ofs0.
               erewrite gsoAddRes with (cntj := pffj).
               erewrite gsoThreadRes with (cntj := pffj0) by eauto.
               now eauto.
            }
          + 
                        exists (addThread
                 (updThread pfc (Kresume c Vundef) threadPerm') (Vptr b ofs) arg
                 newThreadPerm), mc'.
            subst j.
            rewrite gssAddFP; eauto.
            split; first by eapply ren_incr_refl.
            split; eauto.
            rewrite not_in_filter.
            split; first by constructor.
            split.
            
            intros ? Hcompj'.
            Tactics.pf_cleanup.
            constructor.
            erewrite gssAddCode; eauto.
            erewrite gssAddCode; eauto.
            simpl; eauto.
            unfold latestThread. simpl.
            unfold OrdinalPool.latestThread. simpl.
            apply f_equal;
              by auto.
            
            eapply mem_obs_eq_changePerm with (Hlt := (compat_th _ _ HmemCompC pfc).1)
                                              (HltF := (compat_th _ _ (mem_compf Hsim) pff).1).
            rewrite! gssAddRes.
            intros; simpl;
              erewrite computeMap_projection_3 by eauto.
            reflexivity.
            unfold latestThread. simpl.
            pose proof (OrdinalPool.contains_iff_num HnumThreads).
            unfold OrdinalPool.latestThread. simpl.
            apply f_equal; auto.
            unfold latestThread. simpl.
            unfold OrdinalPool.latestThread. reflexivity.
            now apply (obs_eq_data Htsim).
            intros.
            eapply permMapJoin_order with (b := b0) (ofs := ofs0) in Hangel1; eauto.
            erewrite gssAddRes in H by (unfold latestThread; reflexivity).
            destruct Hangel1 as [? _].
            erewrite po_oo in *.
            eapply po_trans;
              now eauto.
            
            eapply mem_obs_eq_changePerm with (Hlt := (compat_th _ _ HmemCompC pfc).2)
                                              (HltF := (compat_th _ _ (mem_compf Hsim) pff).2).
            rewrite! gssAddRes.
            intros; simpl;
              erewrite computeMap_projection_3 by eauto.
            reflexivity.
            unfold latestThread. simpl.
            pose proof (OrdinalPool.contains_iff_num HnumThreads).
            unfold OrdinalPool.latestThread. simpl.
            apply f_equal; auto.
            reflexivity.
            now apply (obs_eq_locks Htsim).
            intros.
            eapply permMapJoin_order with (b := b0) (ofs := ofs0) in Hangel2; eauto.
            erewrite gssAddRes in H by (unfold latestThread; reflexivity).
            destruct Hangel2 as [? _].
            erewrite po_oo in *.
            eapply po_trans;
              now eauto.
            split.
            intros; by congruence.
            split.
            intros; by congruence.
            
            intros.
            rewrite gssAddRes.
            simpl.
            erewrite! computeMap_projection_2 by eauto.
            split;
              now apply empty_map_spec.
            unfold latestThread. simpl.
            unfold OrdinalPool.latestThread. simpl.
            pose proof (OrdinalPool.contains_iff_num HnumThreads).
            apply f_equal; auto.
            intros Hin.
            specialize (Hxs _ Hin).
            clear - Hxs.
            Transparent containsThread OrdinalPool.containsThread.
            unfold containsThread in Hxs. simpl in Hxs.
            unfold OrdinalPool.containsThread, OrdinalPool.latestThread in Hxs.
            simpl in Hxs;
              by ssromega.
            Opaque containsThread  OrdinalPool.containsThread.
        - 
          split.
          + intros bl1 bl2 ofs0 rmap1 rmap2 Hf Hl1 Hl2.
            assert (Hl1' : lockRes tpc (bl1, ofs0) = Some rmap1)
              by (rewrite gsoAddLPool gsoThreadLPool in Hl1; auto).
            assert (Hl2' : lockRes tpf (bl2, ofs0) = Some rmap2)
              by (rewrite gsoAddLPool gsoThreadLPool in Hl2; auto).
            specialize (HsimRes _ _ _ _ _ Hf Hl1' Hl2').
            destruct HsimRes as [HsimRes1 HsimRes2].
            split.
            erewrite restrPermMap_irr' with (Hlt' := (compat_lp _ _ HmemCompC (bl1, ofs0) _ Hl1')#1) by eauto.
            erewrite restrPermMap_irr' with (Hlt' := (compat_lp _ _ (mem_compf Hsim) (bl2, ofs0) _ Hl2')#1) by eauto.
            now assumption.
            erewrite restrPermMap_irr' with (Hlt' := (compat_lp _ _ HmemCompC (bl1, ofs0) _ Hl1')#2) by eauto.
            erewrite restrPermMap_irr' with (Hlt' := (compat_lp _ _ (mem_compf Hsim) (bl2, ofs0) _ Hl2')#2) by eauto.
            now assumption.
          + split.
            * intros.
              rewrite gsoAddLPool gsoThreadLPool in H.
              eauto.
            * intros.
              do 2 rewrite gsoAddLPool gsoThreadLPool.
              eauto.
        - 
          intros.
          rewrite gsoAddLPool gsoThreadLPool in H.
          eauto.
        - 
          destruct Htsim.
          eapply invariant_spawn;
          eauto.
        - assumption.
        - assumption.
        - clear - Htpc_wd Hcode Hat_external Hvalid_mem' Hdomain_f.
          intros j cntj'.
          assert (cntj := cntAdd' _ _ _ cntj').
          destruct cntj as [[cntj _] | cntj].
          + assert (cntj0 := cntUpdate' _ _ _ cntj).
            erewrite @gsoAddCode with (cntj := cntj); eauto.
            destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
            * subst.
              rewrite gssThreadCode.
              specialize (Htpc_wd _ cntj0).
              Tactics.pf_cleanup.
              rewrite Hcode in Htpc_wd.
              simpl in *;
                by auto.
            * rewrite gsoThreadCode;
                by auto.
          + subst.
            erewrite gssAddCode; eauto.
            simpl.
            assert (Hcore_wd := Htpc_wd _ pfc).
            rewrite Hcode in Hcore_wd. simpl in Hcore_wd.
            eapply at_external_wd in Hat_external; eauto.
            inversion Hat_external; subst.
            inversion H2; subst.
              by auto.
        - 
          assumption.
        - 
          split; assumption.
        - intros j Hin.
          specialize (Hxs _ Hin).
          apply cntAdd;
            by apply cntUpdate.
        - econstructor; eauto.
          econstructor; eauto.
          admit.
                    admit.
    }
    { 
      Opaque updThread.
      
      assert (Hvalidb: Mem.valid_block m1 b).
      { eapply Mem.store_valid_access_3 in Hstore.
        eapply Mem.valid_access_valid_block; eauto.
        eapply Mem.valid_access_implies; eauto.
        constructor.
      }
      rewrite <- Hrestrict_pmap in Hvalidb.

      destruct ((domain_valid (weak_obs_eq (obs_eq_data Htsim))) _ Hvalidb)
        as [b2 Hfb].
      assert (Hvalidb2 := (codomain_valid (weak_obs_eq (obs_eq_data Htsim))) _ _ Hfb).
      erewrite restrPermMap_valid in Hvalidb2.

      remember (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).1) as mf1 eqn:Hrestrict_pmapF.
      assert (Hval_obs: val_obs (fp i pfc) (Vint Int.zero) (Vint Int.zero))
        by constructor.
            subst m1.
      destruct Htsim as [Hcore_inj Hmem_obs_eq_data Hmem_obs_eq_locks].
      assert (HstoreF := store_val_obs _ _ _ Hstore Hfb Hval_obs Hmem_obs_eq_data).
      destruct HstoreF as [mf' [HstoreF Hmem_obs_eq_data']].
            rewrite Hcode in Hcore_inj.
      simpl in Hcore_inj.
      destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
        try by exfalso.
      subst.
      
      assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj Hmem_obs_eq_data).
      rewrite Hat_external in Hat_external_spec.
        destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
        as [[? vsf] | ] eqn:Hat_externalF;
        try by exfalso.
            destruct Hat_external_spec as [? Harg_obs]; subst.
      inversion Harg_obs as [|? ? ? ? Hptr_obs Hl]; subst.
      inversion Hl; subst.
      inversion Hptr_obs as [| | | |b1 bf ofs0 Hf|];
        subst b1 ofs0 v'.
      assert (bf = b2)
        by (rewrite Hf in Hfb; by inversion Hfb);
        subst bf.
      
      remember (setPermBlock (Some Nonempty) b2 (Ptrofs.intval ofs) (getThreadR pff).1
                             lksize.LKSIZE_nat) as pmap_tidF' eqn:Hdata_permF.
      symmetry in Hdata_permF.
      remember (setPermBlock (Some Writable) b2 (Ptrofs.intval ofs) (getThreadR pff).2
                             lksize.LKSIZE_nat) as pmap_tidF2' eqn:Hlock_permF.
      symmetry in Hlock_permF.
      
      assert (hresF: lockRes tpf (b2, Ptrofs.intval ofs) = None).
      { pose proof ((Hlock_if _ _ (Ptrofs.intval ofs) Hf).2) as Hlock.
        rewrite HlockRes in Hlock.
        destruct (lockRes tpf (b2, Ptrofs.intval ofs));
          [exfalso; auto | reflexivity].
      }

      assert(HaccessF : Mem.range_perm (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1) b2 (Ptrofs.intval ofs)
                                       (Ptrofs.intval ofs + lksize.LKSIZE) Cur Writable).
      { destruct Hmem_obs_eq_data as [ _ [Hperm_eq _]].
        intros ofs' Hrange.
        unfold Mem.range_perm, permission_at, Mem.perm in *.
        erewrite Hperm_eq;
          by eauto.
      }
      
      remember (updThread pff (Kresume cf Vundef) (pmap_tidF', pmap_tidF2')) as tpf' eqn:Htpf'.
      
      remember (updLockSet tpf' (b2, Ptrofs.intval ofs) (empty_map, empty_map)) as tpf'' eqn:Htpf'';
        symmetry in Htpf''.
      exists tpf'', mf', (fp i pfc), fp, (trf ++ [:: (external i (mklock (b2, Ptrofs.intval ofs)))]).
      split.
      
      intros U.
      assert (HsyncStepF: syncStep false pff (mem_compf Hsim) tpf'' mf' (mklock (b2, Ptrofs.intval ofs))). {
         eapply step_mklock with (b0:=b2); subst pmap_tidF' pmap_tidF2'; eauto; try reflexivity.
      }
      econstructor;
        by eauto.

      assert (HinvC':
                invariant (updLockSet (updThread pfc (Kresume c Vundef) pmap_tid')
                                      (b, Ptrofs.intval ofs) (empty_map, empty_map)))
        by  (eapply StepLemmas.safeC_invariant with (n := fuelF.+1 + size xs); eauto).
      
      assert (HmaxF': max_inv mf')
        by (eapply max_inv_store; eauto).
      
      assert (HmemCompF'': mem_compatible tpf'' mf').
      { subst.
        clear - HmaxF' Hf Hvalidb2 HstoreF.
        constructor.
        - intros.
          rewrite gLockSetRes.
          unfold permMapLt.
          erewrite <- forall2_and.
          intros b0 ofs0.
          destruct (i == tid) eqn:Heq; move/eqP:Heq=>Heq.
          + subst. rewrite gssThreadRes.
            destruct (Pos.eq_dec b2 b0).
            * subst.
              assert (Hvalidb2' := Mem.store_valid_block_1 _ _ _ _ _ _
                                                           HstoreF b0 Hvalidb2).
              specialize (HmaxF' _ ofs0 Hvalidb2').
              rewrite getMaxPerm_correct.
              rewrite HmaxF'.
              simpl; split;
                match goal with
                | [|-match ?Expr with _ => _ end] =>
                  destruct Expr
                end;
                now constructor.
            * rewrite! setPermBlock_other_2; auto.
              erewrite <- mem_store_max by eauto.
              rewrite getMax_restr.
              split;
              now eapply (mem_compf Hsim).
          + erewrite <- mem_store_max by eauto.
            rewrite getMax_restr.
            erewrite! gsoThreadRes with (cntj := cntUpdate' _ _ _ (cntUpdateL' _  _ cnt))  by eauto.
            split;
            now eapply (mem_compf Hsim).
        - intros l rmap Hres.
          unfold permMapLt.
          erewrite <- forall2_and.
          intros b0 ofs0.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) l).
          + inversion e; subst.
            rewrite gsslockResUpdLock in Hres.
            inversion Hres.
            rewrite empty_map_spec.
            destruct ((getMaxPerm mf') # b0 ofs0); simpl; auto.
          + erewrite gsolockResUpdLock in Hres by eauto.
            erewrite <- mem_store_max by eauto.
            rewrite gsoThreadLPool in Hres.
            rewrite getMax_restr.
            split;
              eapply (mem_compf Hsim);
              now eassumption.
        - intros l rmap Hres.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) l).
          + subst.
            simpl.
            eapply Mem.store_valid_block_1;
              now eauto.
          + erewrite gsolockResUpdLock in Hres by eauto.
            rewrite gsoThreadLPool in Hres.
            eapply Mem.store_valid_block_1; eauto.
            eapply (mem_compf Hsim);
              now eassumption.
      }
      subst.

      assert (Hvb: forall b, Mem.valid_block mc b <-> Mem.valid_block mc' b)
        by (
            intros;
            erewrite <- restrPermMap_valid with (Hlt := (compat_th _ _ HmemCompC pfc).1);
            split;
            [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
            eauto).
      assert (Hvb': forall b, ~ Mem.valid_block mc b <-> ~ Mem.valid_block mc' b)
        by (intros; split; intros Hinvalid Hcontra;
              by apply Hvb in Hcontra).
      assert (HvbF: forall b, Mem.valid_block mf b <-> Mem.valid_block mf' b)
        by (
            intros;
            erewrite <- restrPermMap_valid with (Hlt := (compat_th _ _ (mem_compf Hsim) pff).1);
            split;
            [eapply Mem.store_valid_block_1 | eapply Mem.store_valid_block_2];
            eauto).

      eapply Build_sim with (mem_compc := HmemCompC') (mem_compf := HmemCompF'').
      - 
        clear - HnumThreads.
        intros j.
        split; intros cntj;
        eapply cntUpdateL;
        eapply cntUpdate;
        apply cntUpdateL' in cntj;
        apply cntUpdate' in cntj;
          by eapply HnumThreads.
      - 
        intros sched tr.
        eapply HybridCoarseMachine.csafe_trace;
          now eauto.
      - 
        intros j pfcj' pffj'.
        assert (pfcj: containsThread tpc j)
          by auto.
        assert (pffj: containsThread tpf j)
          by auto.
        specialize (HsimWeak _ pfcj pffj).
        clear - Hvb Hvb' HvbF HstoreF Hstore HsimWeak Hsim Hfb Hdata_perm Hlock_perm.

        assert (Hlt1': permMapLt (getThreadR pfcj).1 (getMaxPerm mc'))
          by (intros b0 ofs0;
              erewrite <- mem_store_max by eauto;
              rewrite getMaxPerm_correct;
              rewrite restrPermMap_Max;
              now apply HmemCompC;
              unfold permission_at;
              erewrite Mem.store_access by eauto).

        assert (Hlt1F': permMapLt (getThreadR pffj).1 (getMaxPerm mf'))
          by (intros b0 ofs0;
              erewrite <- mem_store_max by eauto;
              rewrite getMaxPerm_correct;
              rewrite restrPermMap_Max;
              now apply (mem_compf Hsim);
              unfold permission_at;
              erewrite Mem.store_access by eauto).

        assert (HltL': permMapLt (getThreadR pfcj).2 (getMaxPerm mc'))
          by (intros b0 ofs0;
              erewrite <- mem_store_max by eauto;
              rewrite getMaxPerm_correct;
              rewrite restrPermMap_Max;
              now apply HmemCompC;
              unfold permission_at;
              erewrite Mem.store_access by eauto).

        assert (HltLF': permMapLt (getThreadR pffj).2 (getMaxPerm mf'))
          by (intros b0 ofs0;
              erewrite <- mem_store_max by eauto;
              rewrite getMaxPerm_correct;
              rewrite restrPermMap_Max;
              now apply (mem_compf Hsim);
              unfold permission_at;
              erewrite Mem.store_access by eauto).

        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        + subst.
          Tactics.pf_cleanup.
          constructor.
          * 
            subst.
            assert (Hlt1: permMapLt (setPermBlock (Some Nonempty) b (Ptrofs.intval ofs) (getThreadR pfc)#1 lksize.LKSIZE_nat) (getMaxPerm mc'))
              by (pose proof (compat_th _ _ HmemCompC' pfcj') as Hlt;
                  rewrite gLockSetRes gssThreadRes in Hlt;
                  rewrite <- Hdata_perm in Hlt;
                destruct Hlt; assumption).
            assert (Hlt1F: permMapLt (setPermBlock (Some Nonempty) b2 (Ptrofs.intval ofs) (getThreadR pff)#1 lksize.LKSIZE_nat) (getMaxPerm mf'))
              by (pose proof (compat_th _ _ HmemCompF'' pffj') as Hlt;
                  rewrite gLockSetRes gssThreadRes in Hlt;
                  destruct Hlt; assumption).
            erewrite restrPermMap_irr' with (Hlt' := Hlt1)
              by (rewrite gLockSetRes gssThreadRes; rewrite <- Hdata_perm; reflexivity).
            erewrite restrPermMap_irr' with (Hlt' := Hlt1F)
              by (rewrite gLockSetRes gssThreadRes; reflexivity).
            destruct HsimWeak.
            eapply weak_mem_obs_eq_store with (Hlt2 := Hlt1') (Hlt2F := Hlt1F') in weak_tsim_data0; eauto.
            eapply setPermBlock_weak_obs_eq; eauto.
            now eapply (injective (weak_tsim_data0)).
          * 
            subst.
            assert (Hlt2: permMapLt (setPermBlock (Some Writable) b
                                                  (Ptrofs.intval ofs) (getThreadR pfc)#2 lksize.LKSIZE_nat) (getMaxPerm mc'))
              by (pose proof (compat_th _ _ HmemCompC' pfcj') as Hlt;
                  rewrite gLockSetRes gssThreadRes in Hlt;
                  rewrite <- Hlock_perm in Hlt;
                  destruct Hlt; assumption).

            assert (Hlt2F: permMapLt (setPermBlock (Some Writable)
                                                   b2 (Ptrofs.intval ofs) (getThreadR pff)#2 lksize.LKSIZE_nat) (getMaxPerm mf'))
              by (pose proof (compat_th _ _ HmemCompF'' pffj') as Hlt;
                  rewrite gLockSetRes gssThreadRes in Hlt;
                  destruct Hlt; assumption).

            assert (Hlt2': permMapLt (getThreadR pfc).2 (getMaxPerm mc'))
              by (intros b0 ofs0;
                  erewrite <- mem_store_max by eauto;
                  rewrite getMaxPerm_correct;
                  rewrite restrPermMap_Max;
                  now apply HmemCompC;
                  unfold permission_at;
                  erewrite Mem.store_access by eauto).

            assert (Hlt2F': permMapLt (getThreadR pff).2 (getMaxPerm mf'))
              by (intros b0 ofs0;
                  erewrite <- mem_store_max by eauto;
                  rewrite getMaxPerm_correct;
                  rewrite restrPermMap_Max;
                  now apply (mem_compf Hsim);
                  unfold permission_at;
                  erewrite Mem.store_access by eauto).

            erewrite restrPermMap_irr' with (Hlt' := Hlt2)
              by (rewrite gLockSetRes gssThreadRes; rewrite <- Hlock_perm; reflexivity).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2F)
              by (rewrite gLockSetRes gssThreadRes; reflexivity).
            destruct HsimWeak.
            eapply weak_mem_obs_eq_store with (Hlt2 := Hlt2') (Hlt2F := Hlt2F') in weak_tsim_locks0; eauto.
            eapply setPermBlock_weak_obs_eq; eauto.
            now eapply (injective (weak_tsim_data0)).
        + 
          destruct HsimWeak.
          constructor.
          * erewrite restrPermMap_irr' with (Hlt' := Hlt1')
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pfcj);
                  eauto).
            erewrite restrPermMap_irr' with (Hlt' := Hlt1F')
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pffj);
                  eauto).
            eapply weak_mem_obs_eq_store; eauto.
            now apply (injective weak_tsim_data0).
          * erewrite restrPermMap_irr' with (Hlt' := HltL')
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pfcj);
                  eauto).
            erewrite restrPermMap_irr' with (Hlt' := HltLF')
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pffj);
                  eauto).
            eapply weak_mem_obs_eq_store; eauto.
            now apply (injective weak_tsim_data0).
      - 
        intros k j cntk' cntj' Hkj b0 b0' b3 b3' Hf0 Hf0' Hfk' Hfj'.
        assert (cntk: containsThread tpc k)
          by auto.
        assert (cntj: containsThread tpc j)
          by auto.
        erewrite cnt_irr with (cnt1 := cntk') (cnt2 := cntk) in Hfk'.
        erewrite cnt_irr with (cnt1 := cntj') (cnt2 := cntj) in Hfj'.
        eapply (HfpSep _ _ cntk cntj Hkj b0 b0');
          by eauto.
      - 
        intros.
        destruct (tid == i) eqn:Htid; move/eqP:Htid=>Htid; subst.
        { 
          exists  (updLockSet (updThread pfc (Kresume c Vundef) pmap_tid')
                         (b, Ptrofs.intval ofs) (empty_map, empty_map)), mc'.
          assert (pfc0 = pfc)
            by (eapply cnt_irr; eauto); subst pfc0.
          rewrite Hsynced.
          split; first by apply ren_incr_refl.
          split; first by auto.
          split; first by constructor.
          split.
          intros.
          constructor.
          do 2 rewrite gLockSetCode.
          do 2 rewrite gssThreadCode;
            by (split; [assumption | constructor]).
          
          Tactics.pf_cleanup.

          assert (Hlt1': permMapLt (getThreadR pfc).1 (getMaxPerm mc'))
            by (intros b0 ofs0;
                erewrite <- mem_store_max by eauto;
                rewrite getMaxPerm_correct;
                rewrite restrPermMap_Max;
                now apply HmemCompC;
                unfold permission_at;
                erewrite Mem.store_access by eauto).

          assert (Hlt1F': permMapLt (getThreadR pff).1 (getMaxPerm mf'))
            by (intros b0 ofs0;
                erewrite <- mem_store_max by eauto;
                rewrite getMaxPerm_correct;
                rewrite restrPermMap_Max;
                now apply (mem_compf Hsim);
                unfold permission_at;
                erewrite Mem.store_access by eauto).

          assert (Hlt1: permMapLt (setPermBlock (Some Nonempty) b (Ptrofs.intval ofs) (getThreadR pfc)#1 lksize.LKSIZE_nat) (getMaxPerm mc'))
            by (pose proof (compat_th _ _ HmemCompC' pfc') as Hlt;
                rewrite gLockSetRes gssThreadRes in Hlt;
                rewrite <- Hdata_perm in Hlt;
                destruct Hlt; assumption).
          assert (Hlt1F: permMapLt (setPermBlock (Some Nonempty) b2 (Ptrofs.intval ofs) (getThreadR pff)#1 lksize.LKSIZE_nat) (getMaxPerm mf'))
            by (pose proof (compat_th _ _ HmemCompF'' pff0) as Hlt;
                rewrite gLockSetRes gssThreadRes in Hlt;
                destruct Hlt; assumption).

          erewrite restrPermMap_irr' with (Hlt' := Hlt1)
            by (rewrite gLockSetRes gssThreadRes; rewrite <- Hdata_perm; reflexivity).
          erewrite restrPermMap_irr' with (Hlt' := Hlt1F)
            by (rewrite gLockSetRes gssThreadRes; reflexivity).

          eapply Mem.store_mem_contents in Hstore.
          eapply Mem.store_mem_contents in HstoreF.
          assert (Hmem_obs_eq_data_old := Hmem_obs_eq_data).
          eapply mem_obs_eq_store with (Hlt2 := Hlt1') (Hlt2F := Hlt1F') in Hmem_obs_eq_data; eauto.
          eapply setPermBlock_obs_eq; eauto.
          intros ofs0 Hrange.
          rewrite Hstore HstoreF. simpl.
          rewrite! Maps.PMap.gss.
          destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, (Ptrofs.intval ofs) + (Z.of_nat 4)))%Z.
          { erewrite! setN_inside by eauto.
            destruct (List.nth_in_or_default (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef).
            apply inj_bytes_type in i1.
            destruct (List.nth (Z.to_nat  (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef); try by exfalso.
            now constructor.
            rewrite e. now constructor.
          }
          { erewrite! Mem.setN_outside.
            destruct Hmem_obs_eq_data_old as [_ [_ Hval_obs_eq]].
            specialize (Hval_obs_eq _ _ ofs0 Hfb).
            simpl in Hval_obs_eq.
            eapply Hval_obs_eq.
            unfold Mem.range_perm, Mem.perm in *.
            replace (Z.of_nat lksize.LKSIZE_nat) with lksize.LKSIZE in Hrange
              by (unfold lksize.LKSIZE, lksize.LKSIZE_nat; reflexivity).
            specialize (Hfreeable ofs0 Hrange).
            erewrite po_oo in *.
            eapply po_trans; eauto.
            simpl; now constructor.
            rewrite length_inj_bytes encode_int_length.
            eapply Intv.range_notin in n; simpl in n;
              eauto.
            simpl. omega.
            rewrite length_inj_bytes encode_int_length.
            eapply Intv.range_notin in n; simpl in n;
              eauto.
            simpl. omega.
          }
          
          assert (Hlt2: permMapLt (setPermBlock (Some Writable) b
                                                (Ptrofs.intval ofs) (getThreadR pfc)#2 lksize.LKSIZE_nat) (getMaxPerm mc'))
            by (pose proof (compat_th _ _ HmemCompC' pfc') as Hlt;
                rewrite gLockSetRes gssThreadRes in Hlt;
                rewrite <- Hlock_perm in Hlt;
                destruct Hlt; assumption).

          assert (Hlt2F: permMapLt (setPermBlock (Some Writable)
                                                 b2 (Ptrofs.intval ofs) (getThreadR pff)#2 lksize.LKSIZE_nat) (getMaxPerm mf'))
            by (pose proof (compat_th _ _ HmemCompF'' pff0) as Hlt;
                rewrite gLockSetRes gssThreadRes in Hlt;
                destruct Hlt; assumption).

          assert (Hlt2': permMapLt (getThreadR pfc).2 (getMaxPerm mc'))
            by (intros b0 ofs0;
                erewrite <- mem_store_max by eauto;
                rewrite getMaxPerm_correct;
                rewrite restrPermMap_Max;
                now apply HmemCompC;
                unfold permission_at;
                erewrite Mem.store_access by eauto).

          assert (Hlt2F': permMapLt (getThreadR pff).2 (getMaxPerm mf'))
            by (intros b0 ofs0;
                erewrite <- mem_store_max by eauto;
                rewrite getMaxPerm_correct;
                rewrite restrPermMap_Max;
                now apply (mem_compf Hsim);
                unfold permission_at;
                erewrite Mem.store_access by eauto).

          erewrite restrPermMap_irr' with (Hlt' := Hlt2)
            by (rewrite gLockSetRes gssThreadRes; rewrite <- Hlock_perm; reflexivity).
          erewrite restrPermMap_irr' with (Hlt' := Hlt2F)
            by (rewrite gLockSetRes gssThreadRes; reflexivity).
          eapply Mem.store_mem_contents in Hstore.
          eapply Mem.store_mem_contents in HstoreF.
          eapply mem_obs_eq_store with (Hlt2 := Hlt2') (Hlt2F := Hlt2F') in Hmem_obs_eq_locks; eauto.
          eapply setPermBlock_obs_eq; eauto.
          intros ofs0 Hrange.
          rewrite Hstore HstoreF.
          simpl.
          rewrite! Maps.PMap.gss.
          destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, (Ptrofs.intval ofs) + (Z.of_nat 4)))%Z.
          { erewrite! setN_inside by eauto.
            destruct (List.nth_in_or_default (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef).
            apply inj_bytes_type in i1.
            destruct (List.nth (Z.to_nat  (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef); try by exfalso.
            now constructor.
            rewrite e. now constructor.
          }
          { erewrite! Mem.setN_outside.
            destruct Hmem_obs_eq_data as [_ [_ Hval_obs_eq]].
            specialize (Hval_obs_eq _ _ ofs0 Hfb).
            simpl in Hval_obs_eq.
            eapply Hval_obs_eq.
            unfold Mem.range_perm, Mem.perm in *.
            replace (Z.of_nat lksize.LKSIZE_nat) with lksize.LKSIZE in Hrange
              by (unfold lksize.LKSIZE, lksize.LKSIZE_nat; reflexivity).
            specialize (Hfreeable ofs0 Hrange).
            erewrite po_oo in *.
            eapply po_trans; eauto.
            simpl; now constructor.
            rewrite length_inj_bytes encode_int_length.
            eapply Intv.range_notin in n; simpl in n;
              eauto.
            simpl. omega.
            rewrite length_inj_bytes encode_int_length.
            eapply Intv.range_notin in n; simpl in n;
              eauto.
            simpl. omega.
          }
          
          split; first by congruence.
          split; first by congruence.
          rewrite gLockSetRes gssThreadRes.
          intros b0 Hunmapped ofs0.
          assert (b0 <> b2)
            by (intros Hcontra; inversion Hcontra; subst;
                eauto).
          rewrite! setPermBlock_other_2;
            now eauto.
        }
        { 
          assert (Hstrong_sim := simStrong Hsim).
            assert (pfcj: containsThread tpc tid)
              by (eapply cntUpdateL' in pfc0;
                   eapply cntUpdate' in pfc0;
                   eauto).
            assert (pffj: containsThread tpf tid)
              by (eapply cntUpdateL' in pff0;
                   eapply cntUpdate' in pff0;
                   eauto).
            specialize (Hstrong_sim _ pfcj pffj).
            destruct Hstrong_sim
              as (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
                  & Hownedj & Hownedj_lp & Hunmapped_j).
            
            assert (pfcij:= containsThread_internal_execution Hexecj pfc).

            assert (pfcjj: containsThread tpcj tid)
              by (eapply containsThread_internal_execution; eauto).
            assert (Hcompj: mem_compatible tpcj mcj)
              by (eapply internal_execution_compatible with (tp := tpc); eauto).
            specialize (Htsimj pfcjj Hcompj).

            assert (Htsimj_id:
                      tp_wd (id_ren mc) tpc /\
                      ctl_inj (id_ren mc) (getThreadC pfcj) (getThreadC pfc0) /\
                      mem_obs_eq (id_ren mc) (restrPermMap (compat_th _ _ HmemCompC pfcj).1)
                                 (restrPermMap (compat_th _ _ HmemCompC' pfc0).1) /\
                      (Mem.nextblock mc = Mem.nextblock mc')).
            { split.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
              eapply strong_tsim_store_id; eauto.
              erewrite gLockSetRes.
              rewrite gsoThreadRes; eauto.
              erewrite gLockSetCode.
              rewrite gsoThreadCode; eauto.
              destruct HinvC.
              pose proof ((thread_data_lock_coh0 _ pfc ).1 _ pfcj) as Hcoh.
              right.
              eapply Hinv; now eauto.
              eapply tp_wd_domain;
                by eauto using id_ren_domain.
            }
            destruct Htsimj_id as [Htpc_id_wd [Hctlj_id [Hmem_obs_eqj_id Hnextblock]]].

            assert (H := mem_obs_eq_execution _ _ _ _ _ HinvC' Hfg Hge_wd Hge_incr_id
                                               Hmemc_wd Htpc_id_wd Hctlj_id Hmem_obs_eqj_id Hexecj).
            destruct H as
                (tp2' & m2' & f' & Hexecj'& Hincrj' & Hsepj'
                 & Hnextblock' & Hinvj' & Htsimj' & Hid').
            destruct Htsimj' as (pf2j & pf2j' & Hcomp2 & Hcomp2' & Hctl_eqj' & Hmem_obs_eq').
            specialize (Hid' Hnextblock (id_ren_correct mc)).
            assert (f' = id_ren mcj)
              by ( pose ((mem_obs_eq_domain_ren Hmem_obs_eq'));
                   eapply is_id_ren; eauto); subst f'.
            exists tp2', m2'.
            erewrite cnt_irr with (cnt1 := pfc0) (cnt2 := pfcj).
            split; first by auto.
            split; first by auto.
            split; first by auto.
            split.
            
            intros.
            Tactics.pf_cleanup.
            
            assert (Htsim2j: ctl_inj (fp tid pfcj) (getThreadC pf2j') (getThreadC pffj) /\
                             mem_obs_eq (fp tid pfcj) (restrPermMap (compat_th _ _ Hcomp2' pf2j').1)
                                        (restrPermMap (compat_th _ _ (mem_compf Hsim) pffj).1)).
            { destruct Htsimj.
              eapply strong_tsim_id_trans
              with (f := fp tid pfcj) (Hcomp1 := Hcompj) (Hcomp1' := Hcomp2');
              eauto.
              destruct Hnextblock' as [[p [Hmcj Hm2']] | [Hmcj Hm2']];
              unfold Mem.valid_block;
              rewrite Hmcj Hm2' Hnextblock;
                by tauto.
            }

            destruct Htsim2j as [Hcodeq2j Hmem_obs_eq2j].
            constructor.
            rewrite gLockSetCode.
            rewrite gsoThreadCode;
              by auto.
            clear - Hmem_obs_eq2j HstoreF HinvF Htid.
            assert (HeqRes: getThreadR pff0 = getThreadR pffj)
              by (rewrite gLockSetRes;
                   rewrite gsoThreadRes; auto).
            assert (Hlt : permMapLt (getThreadR pff0).1 (getMaxPerm mf))
            by (rewrite HeqRes; eapply (compat_th _ _ (mem_compf Hsim) pffj).1).
            eapply mem_obs_eq_storeF with (mf := mf) (Hlt :=  Hlt);
              eauto.
            right.
            apply Mem.store_valid_access_3 in HstoreF.
            pose proof (cntUpdateL' _ _ pff0) as pffj'.
            erewrite gLockSetRes with (cnti := pffj').
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            eapply HinvF;
              now eauto.

            erewrite restrPermMap_irr' with (Hlt := Hlt)
                                              (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).1); eauto.
            rewrite HeqRes. reflexivity.

            pose proof (obs_eq_locks Htsimj).

            assert (HRj_eq: (getThreadR pf2j').2 = (getThreadR pfcjj).2).
            { erewrite <- internal_execution_locks_eq with (cntj := pfc0) by eauto.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) by eauto.
              rewrite gLockSetRes.
              erewrite gsoThreadRes by eauto;
                reflexivity.
            }

            assert (Hlt2C: permMapLt (getThreadR pfcjj).2 (getMaxPerm m2'))
              by ( rewrite <- HRj_eq;
                   eapply (compat_th _ _ Hcomp2' pf2j').2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2C) by eauto.

            assert (HRj_eqF: (getThreadR pff0)#2 = (getThreadR pffj)#2)
              by (rewrite gLockSetRes; erewrite gsoThreadRes with (cntj := pffj) by eauto;
                  reflexivity).

            assert (Hlt2F: permMapLt (getThreadR pffj).2 (getMaxPerm mf'))
              by (rewrite <- HRj_eqF; eapply (compat_th _ _ HmemCompF'' pff0).2).
            erewrite restrPermMap_irr' with (Hlt' := Hlt2F) by eassumption.

            assert (Hstable_mc2': forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                             ZMap.get ofs1 (Mem.mem_contents mc') # b1 = ZMap.get ofs1 (Mem.mem_contents m2') # b1).
            { intros.
              erewrite <- internal_exec_disjoint_locks with (Hcomp := HmemCompC') (m := mc') (m' := m2') (pfj := pfc0); eauto.
              unfold Mem.perm.
              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).2 b1 ofs1) as Hpermj.
              unfold permission_at in Hpermj.
              rewrite Hpermj.
              rewrite gLockSetRes.
              erewrite gsoThreadRes with (cntj := pfcj) by eauto.
              assumption.
            }

            assert (Hstable_mcj: forall b1 ofs1, Mem.perm_order' ((getThreadR pfcj).2 # b1 ofs1) Readable ->
                                            ZMap.get ofs1 (Mem.mem_contents mc) # b1 =
                                            ZMap.get ofs1 (Mem.mem_contents mcj) # b1).
            { intros.
              erewrite internal_exec_disjoint_locks
              with (Hcomp := HmemCompC) (pfj := pfcj) (m := mc) (tp := tpc) (tp' := tpcj); eauto.
              unfold Mem.perm in *.

              pose proof (restrPermMap_Cur (compat_th _ _ HmemCompC pfcj).2 b1 ofs1) as Hpermj.
              unfold permission_at in *.
              rewrite Hpermj. assumption.
            }

            assert (Hperm_eqj: forall b1 ofs1, (Mem.mem_access (restrPermMap (compat_th _ _ Hcompj pfcjj).2)) # b1 ofs1 Cur =
                                          (getThreadR pfcj).2 # b1 ofs1).
            { intros.
              pose proof (restrPermMap_Cur (compat_th _ _ Hcompj pfcjj).2 b1 ofs1) as Hpermjj.
              unfold permission_at in Hpermjj.
              rewrite Hpermjj.
              erewrite <- internal_execution_locks_eq with (cntj' := pfcjj) (cntj := pfcj) at 1
                by eauto.
              reflexivity.
            }

            eapply mem_obs_eq_disjoint_lock
            with (ofsl := Ptrofs.intval ofs) (bl1 := b)
                                          (bl2 := b2) (sz := size_chunk Mint32); eauto.
            
            intros. unfold Mem.valid_block in *.
            destruct Hnextblock' as [[p [Hnextj Hnext2]] | [Hnextj Hnext2]];
              rewrite Hnextj Hnext2 Hnextblock;
              split; now auto.

            intros ofs0 Hrange.
                        assert (Hlock_unwrittable: ~ Mem.perm (restrPermMap (compat_th _ _ HmemCompC' pfc0)#1) b ofs0 Cur Writable).
            { clear - Hstore HinvC Hrange pfcj Htid.
              intros Hcontra.
              apply Mem.store_valid_access_3 in Hstore.
              destruct Hstore as [Hperm _].
              specialize (Hperm ofs0 Hrange).
              unfold Mem.perm in *.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC' pfc0).1) b ofs0) as Hpermj'.
              pose proof ((restrPermMap_Cur (compat_th _ _ HmemCompC pfc).1) b ofs0) as Hpermi.
              unfold permission_at in *.
              rewrite Hpermi in Hperm.
              rewrite Hpermj' in Hcontra.
              rewrite gLockSetRes in Hcontra.
              erewrite gsoThreadRes with (cntj := pfcj) in Hcontra by eauto.
              pose proof ((no_race_thr _ HinvC _ _ pfcj pfc Htid).1 b ofs0).
              rewrite perm_union_comm in H.
              eapply perm_order_clash; eauto.
              erewrite po_oo in *.
              eapply po_trans; eauto.
              simpl; constructor.
            }

            erewrite <- internal_exec_stable with (m := mc') (Hcomp := HmemCompC') (pfi := pfc0); eauto.
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            simpl.
            rewrite! Maps.PMap.gss.
            erewrite! setN_inside
              by (rewrite length_inj_bytes encode_int_length; simpl in Hrange; auto).
            destruct (List.nth_in_or_default (Z.to_nat (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef).
            apply inj_bytes_type in i0.
            destruct (List.nth (Z.to_nat  (ofs0 - Ptrofs.intval ofs)) (inj_bytes (encode_int 4 (Int.unsigned Int.zero))) Undef); try by exfalso.
            now constructor.
            rewrite e. now constructor.
            eapply Mem.store_valid_block_1; eauto.
            
            intros.
            unfold Mem.perm in H1.
            erewrite Hperm_eqj in H1.
            erewrite <- Hstable_mc2' by eauto.
            erewrite <- Hstable_mcj by eauto.
            
            erewrite Mem.store_mem_contents with (m2 := mc') by eauto.
            destruct H0 as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.

            intros b0 ofs0 Hneq Hreadable.
            erewrite Mem.store_mem_contents with (m2 := mf') by eauto.
            destruct Hneq as [Hb_neq | [? Hofs_neq]].
            
            erewrite Maps.PMap.gso by eauto.
            reflexivity.
            
            subst.
            rewrite Maps.PMap.gss.
            erewrite Mem.setN_outside
              by (rewrite encode_val_length; eapply Intv.range_notin in Hofs_neq; eauto; simpl; omega).
            reflexivity.
            eauto.
            split.
            
            intros k pff2k Hjk b1 b0 ofs0 Hfj Hfi.
            destruct (i == k) eqn:Hik; move/eqP:Hik=>Hik.
            { subst k.
              rewrite gLockSetRes.
              rewrite gssThreadRes; auto.
              assert (b0 <> b2).
              { intros Hcontra; subst.
                pose proof (Hincrj _ _ Hf) as Hf'.
                pose proof (injective (weak_obs_eq (obs_eq_data Htsimj)) _ _ Hfj Hf'); subst.
                now congruence.
              }

              rewrite! setPermBlock_other_2;
                by eauto.
            }
            { rewrite gLockSetRes.
              rewrite gsoThreadRes; auto.
              eapply Hownedj;
                by eauto.
            }
            split.
            
            intros bl ofsl rmap b1 b0 ofs0 Hfj Hfi Hres.
            destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)) as [Heq | Hneq].
            
            inversion Heq; subst.
            rewrite gssLockRes in Hres. inversion Hres.
            simpl. split; now apply empty_map_spec.
            
            rewrite gsoLockRes in Hres; auto.
            rewrite gsoThreadLPool in Hres;
              by eauto.
            
            intros b0 Hunmapped ofs0.
            rewrite gLockSetRes.
            erewrite gsoThreadRes with (cntj := pffj) by eauto.
            eapply Hunmapped_j;
              by eauto.
          }
      - split.
        {  
          intros bl1 bl2 ofs0 rmap1 rmap2 Hfi Hres1 Hres2.
          destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)) as [Heq | Hneq].
          { 
            inversion Heq; subst.
            assert (bl2 = b2)
              by (rewrite Hfi in Hfb; by inversion Hfb).
            subst bl2.
            assert (Hperm_eq: forall b1 b0 ofs0, fp i pfc b1 = Some b0 ->
                                            permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#1) b0 ofs0 Cur =
                                            permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#1) b1 ofs0 Cur /\
                                            permission_at (restrPermMap (compat_lp _ _ HmemCompF'' (b2, Ptrofs.intval ofs) _ Hres2)#2) b0 ofs0 Cur =
                                            permission_at (restrPermMap (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs) _ Hres1)#2) b1 ofs0 Cur).
            { intros.
              rewrite! restrPermMap_Cur.
              rewrite gssLockRes in Hres1.
              rewrite gssLockRes in Hres2.
              inversion Hres1; inversion Hres2.
              simpl;
                split; by rewrite! empty_map_spec.
            }
            split;
              constructor; intros;
                try (destruct (Hperm_eq b1 b0 ofs0 Hrenaming); by auto).
            assert (H:= restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs)
                                                    _ Hres1).1 b1 ofs0).
            unfold permission_at in H.
            unfold Mem.perm in Hperm.
            rewrite H in Hperm.
            clear H Hperm_eq.
            exfalso.
            rewrite gssLockRes in Hres1.
            inversion Hres1; subst.
            unfold Maps.PMap.get in Hperm.
            rewrite Maps.PTree.gempty in Hperm.
            simpl in Hperm;
              by auto.
            assert (H:= restrPermMap_Cur (compat_lp _ _ HmemCompC' (bl1, Ptrofs.intval ofs)
                                                    _ Hres1).2 b1 ofs0).
            unfold permission_at in H.
            unfold Mem.perm in Hperm.
            rewrite H in Hperm.
            clear H Hperm_eq.
            exfalso.
            rewrite gssLockRes in Hres1.
            inversion Hres1; subst.
            unfold Maps.PMap.get in Hperm.
            rewrite Maps.PTree.gempty in Hperm.
            simpl in Hperm;
              by auto.
          }
          { 
            assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
            { clear - Hneq Hfi Hf Hfb Hmem_obs_eq_data.
              intros Hcontra; inversion Hcontra; subst.
              assert (b = bl1)
                by (eapply (injective (weak_obs_eq Hmem_obs_eq_data)); eauto).
              subst;
                by auto.
            }
            pose proof Hres1 as Hres1';
              pose proof Hres2 as Hres2'.
            erewrite gsoLockRes, gsoThreadLPool in Hres1' by auto.
            erewrite gsoLockRes, gsoThreadLPool in Hres2' by auto.
            destruct (HsimRes _ _ _ _ _ Hfi Hres1' Hres2') as [Hsim1 Hsim2].
            split;
              eapply strong_mem_obs_eq_store with (bl1 := b) (bl2 := b2); eauto;
                try (erewrite Mem.store_mem_contents by eauto; reflexivity).
          }
        }
        split.
        
        intros bl2 ofs0 Hres.
        destruct (EqDec_address (bl2, ofs0) (b2, Ptrofs.intval ofs)) as [Heq | Hneq].
        inversion Heq; subst.
        eexists;
          by eauto.
        erewrite gsoLockRes, gsoThreadLPool in Hres by auto.
        eapply Hlock_mapped;
          by eauto.
        
        { intros bl1 bl2 ofs0 Hfl1.
          destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)).
          - inversion e; subst.
            assert (b2 = bl2)
              by (rewrite Hf in Hfl1; inversion Hfl1; subst; auto).
            subst.
            do 2 rewrite gsslockResUpdLock.
            split;
              auto.
          - erewrite gsolockResUpdLock by auto.
            assert ((b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
            { intros Hcontra.
              inversion Hcontra; subst.
              specialize (Hinjective _ _ _ Hfl1 Hfb).
              subst; auto.
            }
            erewrite gsolockResUpdLock by eauto.
            do 2 rewrite gsoThreadLPool.
            eauto.
        }
        
      - intros bl ofsl rmap0 Hres b0 Hunmapped ofs0.
        destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)).
        +  inversion e; subst.
           rewrite gsslockResUpdLock in Hres.
           inversion Hres; subst.
           simpl.
           split;
             now apply empty_map_spec.
        + erewrite gsolockResUpdLock in Hres by auto.
          rewrite gsoThreadLPool in Hres.
          eapply HunmappedRes;
            now eauto.
      - 
        clear - HinvF HstoreF HinvC' Hlock_if Hf HaccessF.
        Opaque getThreadR.
        eapply updLock_inv;
          try (intros; simpl; split; intros ? ?; rewrite empty_map_spec; simpl; eauto);
          try (rewrite perm_union_comm; simpl; eauto);
          try (now apply perm_coh_empty_1).
        eapply invariant_mklock; eauto.
        apply Mem.store_valid_access_3 in HstoreF.
        intros ofs' Hrange.
        pose proof (restrPermMap_Cur (compat_th _ _ (mem_compf Hsim) pff).1 b2 ofs') as Heq.
        unfold permission_at in Heq.
        unfold Mem.range_perm, Mem.perm in HaccessF.
        specialize (HaccessF ofs' Hrange).
        rewrite Heq in HaccessF.
        now assumption.
        rewrite gsoThreadLPool in H0.
        pose proof ((invariant_not_freeable HinvF b0 ofs0).2 _ _ H0).
        destruct ((rmap').2 # b0 ofs0) as [p|];
          try (destruct p);
          by auto.
        intros ? ?.
        rewrite empty_map_spec;
          now apply perm_coh_empty_1.
        destruct (i == i0) eqn:Heq; move/eqP:Heq=>Heq.
        subst.
        rewrite gssThreadRes.
        destruct (setPermBlock_or (Some Writable) b2 (Ptrofs.intval ofs) (lksize.LKSIZE_nat)
                                  (getThreadR pff).2 b0 ofs0).
        simpl.
        rewrite H; auto.
        rewrite H.
        pose proof ((invariant_not_freeable HinvF b0 ofs0).1 _ pff).
        destruct ((getThreadR pff).2 # b0 ofs0) as [p|];
          try (destruct p); auto.
        pose proof (cntUpdate' _ _ _ cnti) as cnti0.
        pose proof ((invariant_not_freeable HinvF b0 ofs0).1 _ cnti0).
        erewrite gsoThreadRes with (cntj := cnti0) by eauto.
        destruct ((getThreadR cnti0).2 # b0 ofs0) as [p|];
          try (destruct p); auto.
        intros ofs' Hrange.
        rewrite gsoThreadLPool.
        destruct (lockRes tpf (b2, ofs')) eqn:HresF; auto.
        exfalso.
        specialize (Hlock_if _ _ ofs' Hf).
        pose proof (Hlock_if.2 ltac:(rewrite HresF; auto)) as Hres.
        pose proof (lockRes_valid _ HinvC' b (Ptrofs.intval ofs)) as HvalidC'.
        rewrite gssLockRes in HvalidC'.
        specialize (HvalidC' _ Hrange).
        erewrite gsoLockRes in HvalidC'
          by (intros Hcontra; inversion Hcontra; subst; omega).
        rewrite gsoThreadLPool in HvalidC'.
        rewrite HvalidC' in Hres.
        now auto.
        intros ofs' Hrange.
        rewrite gsoThreadLPool.
        pose proof (lockRes_valid _ HinvC' b ofs') as HvalidC'.
        erewrite gsoLockRes in HvalidC' by (intros Hcontra; inversion Hcontra; subst; omega).
        rewrite gsoThreadLPool in HvalidC'.
        destruct (lockRes tpf (b2, ofs')) eqn:HresF; auto.
        specialize (Hlock_if _ _ ofs' Hf).
        pose proof (Hlock_if.2 ltac:(rewrite HresF; auto)) as Hres.
        destruct (lockRes tpc (b, ofs')); try (by exfalso).
        specialize (HvalidC' _ Hrange).
        rewrite gssLockRes in HvalidC'.
        discriminate.
      - 
        assumption.
      - 
        eapply store_wd_domain with (m := restrPermMap (compat_th _ _ HmemCompC pfc)#1); eauto.
          by simpl.
      - 
        apply tp_wd_lockSet.
        intros j cntj'.
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        subst. rewrite gssThreadCode.
        specialize (Htpc_wd _ pfc).
        rewrite Hcode in Htpc_wd.
        simpl in *;
          by auto.
        assert (cntj := cntUpdate' _ _ _ cntj').
        erewrite @gsoThreadCode with (cntj := cntj) by assumption.
        specialize (Htpc_wd _ cntj);
          by auto.
      - 
        assumption.
      - 
        split; assumption.
      - intros.
        apply cntUpdateL;
          apply cntUpdate;
            by eauto.
      - econstructor;
          eauto.
        econstructor;
          now eauto.
    }
    { 
      subst mc'.

      remember (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).2) as mf1 eqn:Hrestrict_pmapF.

      destruct Htsim as [Hcore_inj Hmem_obs_eq_data Hmem_obs_eq_locks].
            rewrite Hcode in Hcore_inj.
      simpl in Hcore_inj.
      subst.
      destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
        try by exfalso.
      
      assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj Hmem_obs_eq_data).
      rewrite Hat_external in Hat_external_spec.
      destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
        as [[? vsf] | ] eqn:Hat_externalF;
          try by exfalso.
            destruct Hat_external_spec as [? Harg_obs]; subst.
      inversion Harg_obs as [|? ? ? ? Hptr_obs Hl]; subst.
      inversion Hl; subst.
      inversion Hptr_obs as [| | | |b1 b2 ofs0 Hf|];
        subst b1 ofs0 v'.

      remember (setPermBlock None b2 (Ptrofs.intval ofs) (getThreadR pff).2
                             lksize.LKSIZE_nat) as pmap_tidF2' eqn:Hlock_permF.
      symmetry in Hlock_permF.
      remember (setPermBlock_var pdata b2 (Ptrofs.intval ofs) (getThreadR pff).1
                             lksize.LKSIZE_nat) as pmap_tidF' eqn:Hdata_permF.
      symmetry in Hdata_permF.
            assert (HfreeableF: Mem.range_perm (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).2) b2 (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + lksize.LKSIZE) Cur Writable).
      { intros ofs' Hrange.
        pose proof ((perm_obs_strong (strong_obs_eq Hmem_obs_eq_locks)) _ _ ofs' Hf) as Hperm_eq.
        specialize (Hfreeable _ Hrange).
        unfold Mem.perm in *.
        unfold permission_at in Hperm_eq.
        rewrite Hperm_eq.
        now auto.
      }
      
      assert (Hsome_lockF: lockRes tpf (b2, Ptrofs.intval ofs))
        by (eapply Hlock_if; eauto; rewrite His_lock; eauto).
      destruct (lockRes tpf (b2, Ptrofs.intval ofs)) as [rmapF|] eqn:His_lockF;
        try (by exfalso).

      assert(HrmapF: forall b ofs, rmapF.1 !! b ofs = None /\ rmapF.2 !! b ofs = None).
      { intros b0 ofs0.
        assert (Hb0: (exists b1, (fp i pfc) b1 = Some b0) \/
                     ~ (exists b1, (fp i pfc) b1 = Some b0))
          by eapply em.
        destruct Hb0 as [[b1 Hf1] | Hunmapped].
        - 
          destruct (HsimRes _ _ _ _ _ Hf His_lock His_lockF) as [HsimRes1 HsimRes2].
          pose proof (perm_obs_strong HsimRes1 _ ofs0 Hf1) as Hpmap1.
          pose proof (perm_obs_strong HsimRes2 _ ofs0 Hf1) as Hpmap2.
          rewrite! restrPermMap_Cur in Hpmap1 Hpmap2.
          erewrite Hpmap1, Hpmap2, (Hrmap b1 ofs0).1, (Hrmap b1 ofs0).2.
          split; reflexivity.
        - specialize (HunmappedRes _ _ _ His_lockF _ Hunmapped ofs0).
          assumption.
      }

      remember (updThread pff (Kresume cf Vundef) (pmap_tidF', pmap_tidF2'))
        as tpf' eqn:Htpf'.
      
      remember (remLockSet tpf' (b2, Ptrofs.intval ofs)) as tpf'' eqn:Htpf''.
      exists tpf'', mf, (fp i pfc), fp, (trf ++ [:: (external i (freelock (b2, Ptrofs.intval ofs)))]).
      split.
      
      intros U.
      assert (HsyncStepF: syncStep false pff (mem_compf Hsim) tpf'' mf (freelock (b2, Ptrofs.intval ofs)))
        by (eapply step_freelock with (b0 := b2); now eauto).
      econstructor;
        by eauto.

      assert (HinvC':
                invariant (remLockSet
                             (updThread pfc (Kresume c Vundef) pmap_tid')
                             (b, Ptrofs.intval ofs)))
        by  (eapply StepLemmas.safeC_invariant with (n := fuelF.+1 + size xs); eauto).
      assert (HlockRes_valid:  lr_valid
                                 (lockRes
                                    (updThread pff (Kresume cf Vundef) (pmap_tidF', pmap_tidF2')))).
      { intros b0 ofs0.
        rewrite gsoThreadLPool.
        pose proof (lockRes_valid _ HinvF) as Hlr_valid.
        specialize (Hlr_valid b0 ofs0).
        now eauto.
      }

      assert (HmemCompF' : mem_compatible tpf'' mf).
      { subst.
        constructor.
        { intros j pffj.
          rewrite gRemLockSetRes.
          destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
          - subst j.
            rewrite gssThreadRes.
            unfold permMapLt.
            erewrite <- forall2_and.
            intros b' ofs'.
            destruct (Pos.eq_dec b2 b').
            + subst.
              apply (codomain_valid (weak_obs_eq (Hmem_obs_eq_data))) in Hf.
              erewrite restrPermMap_valid in Hf.
              specialize (HmaxF _ ofs' Hf).
              rewrite getMaxPerm_correct HmaxF; simpl.
              simpl; split;
                match goal with
                | [|-match ?Expr with _ => _ end] =>
                  destruct Expr
                end;
                now constructor.
            + rewrite! setPermBlock_other_2; auto.
              rewrite setPermBlock_var_other_2; auto.
              pose proof ((compat_th _ _ (mem_compf Hsim) pff).1 b' ofs').
              pose proof ((compat_th _ _ (mem_compf Hsim) pff).2 b' ofs');
                split; now auto.
          - rewrite gsoThreadRes; auto.
            pose proof (compat_th _ _ (mem_compf Hsim) pffj); auto.
        }
        { intros (bl' & ofsl') rmap' Hres'.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl', ofsl')) as [Heq |Hneq].
          - inversion Heq; subst.
            rewrite gsslockResRemLock in Hres';
              by discriminate.
          - rewrite gsolockResRemLock in Hres'; auto.
            rewrite gsoThreadLPool in Hres'.
            eapply (compat_lp _ _ (mem_compf Hsim)); eauto.
        }
        { intros (bl' & ofsl') ? Hres.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl', ofsl')) as [Heq |Hneq].
          - inversion Heq; subst.
            rewrite gsslockResRemLock in Hres;
              by discriminate.
          - rewrite gsolockResRemLock in Hres; auto.
            rewrite gsoThreadLPool in Hres.
            eapply (lockRes_blocks _ _ (mem_compf Hsim)); eauto.
        }
      }
      subst.

      assert (Hlt1: forall (pfc': containsThread (remLockSet (updThread pfc (Kresume c Vundef) pmap_tid') (b, Ptrofs.intval ofs)) i),
                 permMapLt (setPermBlock_var pdata b (Ptrofs.intval ofs) (getThreadR pfc)#1 lksize.LKSIZE_nat) (getMaxPerm mc))
        by (intros; pose proof (compat_th _ _ HmemCompC' pfc') as Hlt;
            rewrite gRemLockSetRes gssThreadRes in Hlt;
            rewrite <- Hdata_perm in Hlt;
            destruct Hlt; assumption).
      assert (Hlt1F: forall (pff' : containsThread
                                 (remLockSet
                                    (updThread pff (Kresume cf Vundef)
                                               (setPermBlock (((getThreadR pff)#2) # b2 (Ptrofs.intval ofs)) b2 (Ptrofs.intval ofs) (getThreadR pff)#1 lksize.LKSIZE_nat,
                                                setPermBlock None b2 (Ptrofs.intval ofs) (getThreadR pff)#2 lksize.LKSIZE_nat)) (b2, Ptrofs.intval ofs)) i),
                 permMapLt (setPermBlock_var pdata b2 (Ptrofs.intval ofs)
                                         (getThreadR pff)#1 lksize.LKSIZE_nat) (getMaxPerm mf))
        by (intros; pose proof (compat_th _ _ HmemCompF' pff') as Hlt;
            rewrite gRemLockSetRes gssThreadRes in Hlt;
            destruct Hlt; assumption).

      assert (Hlt2:  forall (pfc': containsThread (remLockSet (updThread pfc (Kresume c Vundef) pmap_tid') (b, Ptrofs.intval ofs)) i),
                 permMapLt (setPermBlock None b (Ptrofs.intval ofs) (getThreadR pfc)#2 lksize.LKSIZE_nat) (getMaxPerm mc))
        by (intros; pose proof (compat_th _ _ HmemCompC' pfc') as Hlt;
            rewrite gRemLockSetRes gssThreadRes in Hlt;
            rewrite <- Hlock_perm in Hlt;
            destruct Hlt; eauto).
      assert (Hlt2F: forall (pff' : containsThread
                                 (remLockSet
                                    (updThread pff (Kresume cf Vundef)
                                               (setPermBlock (((getThreadR pff)#2) # b2 (Ptrofs.intval ofs)) b2 (Ptrofs.intval ofs) (getThreadR pff)#1 lksize.LKSIZE_nat,
                                                setPermBlock None b2 (Ptrofs.intval ofs) (getThreadR pff)#2 lksize.LKSIZE_nat)) (b2, Ptrofs.intval ofs)) i),
                 permMapLt (setPermBlock None b2 (Ptrofs.intval ofs)
                                         (getThreadR pff)#2 lksize.LKSIZE_nat) (getMaxPerm mf))
        by (intros; pose proof (compat_th _ _ HmemCompF' pff') as Hlt;
            rewrite gRemLockSetRes gssThreadRes in Hlt;
            destruct Hlt; assumption).

      eapply Build_sim with (mem_compc := HmemCompC') (mem_compf := HmemCompF').
      - 
        clear - HnumThreads.
        intros j.
        split; intros cntj;
        eapply cntRemoveL;
        eapply cntUpdate;
        apply cntRemoveL' in cntj;
        apply cntUpdate' in cntj;
          by eapply HnumThreads.
      - 
        intros sched tr.
        eapply HybridCoarseMachine.csafe_trace;
          now eauto.
      - 
        intros j pfcj' pffj'.
        assert (pfcj: containsThread tpc j)
          by auto.
        assert (pffj: containsThread tpf j)
          by auto.
        specialize (HsimWeak _ pfcj pffj).
        clear - HsimWeak Hsim Hf Hdata_perm Hlock_perm Hmem_obs_eq_locks Hlt1 Hlt1F Hlt2 Hlt2F.
        
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        + subst.
          Tactics.pf_cleanup.
          constructor.
          * 
            subst.
            erewrite restrPermMap_irr' with (Hlt' := (Hlt1 pfcj'))
              by (rewrite gRemLockSetRes gssThreadRes; rewrite <- Hdata_perm; reflexivity).
            erewrite restrPermMap_irr' with (Hlt' := (Hlt1F pffj'))
              by (rewrite gRemLockSetRes gssThreadRes; reflexivity).
            destruct HsimWeak.
            eapply setPermBlock_var_weak_obs_eq; eauto.
          * 
            subst.
            erewrite restrPermMap_irr' with (Hlt' := (Hlt2 pfcj'))
              by (rewrite gRemLockSetRes gssThreadRes; rewrite <- Hlock_perm; reflexivity).
            erewrite restrPermMap_irr' with (Hlt' := (Hlt2F pffj'))
              by (rewrite gRemLockSetRes gssThreadRes; reflexivity).
            destruct HsimWeak.
            eapply setPermBlock_weak_obs_eq;
              now eauto.
        + 
          destruct HsimWeak.
          constructor.
          * erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ HmemCompC pfcj).1)
              by (rewrite gRemLockSetRes; erewrite gsoThreadRes with (cntj := pfcj);
                  eauto).
            erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).1)
              by (rewrite gRemLockSetRes; erewrite gsoThreadRes with (cntj := pffj);
                  eauto).
            assumption.
          *  erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ HmemCompC pfcj).2)
              by (rewrite gRemLockSetRes; erewrite gsoThreadRes with (cntj := pfcj);
                  eauto).
            erewrite restrPermMap_irr' with (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).2)
              by (rewrite gRemLockSetRes; erewrite gsoThreadRes with (cntj := pffj);
                  eauto).
            assumption.
      - 
        intros k j cntk' cntj' Hkj b0 b0' b3 b3' Hf0 Hf0' Hfk' Hfj'.
        assert (cntk: containsThread tpc k)
          by auto.
        assert (cntj: containsThread tpc j)
          by auto.
        erewrite cnt_irr with (cnt1 := cntk') (cnt2 := cntk) in Hfk'.
        erewrite cnt_irr with (cnt1 := cntj') (cnt2 := cntj) in Hfj'.
        eapply (HfpSep _ _ cntk cntj Hkj b0 b0');
          by eauto.
      - 
        intros.
        destruct (tid == i) eqn:Htid; move/eqP:Htid=>Htid; subst.
        { 
          exists (remLockSet
                (updThread pfc (Kresume c Vundef) pmap_tid')
                (b, Ptrofs.intval ofs)), mc.
          assert (pfc0 = pfc)
            by (eapply cnt_irr; eauto); subst pfc0.
          assert (pff0 = pff)
            by (eapply cnt_irr; eauto); subst pff0.
          rewrite Hsynced.
          repeat (split; (auto || constructor)).
          split; first by apply ren_incr_refl.
          split; first by auto.
          split; first by constructor.
          split.
          intros.
          constructor.
          do 2 rewrite gRemLockSetCode.
          do 2 rewrite gssThreadCode;
            by (split; [assumption | constructor]).
          
          erewrite restrPermMap_irr' with (Hlt' := (Hlt1 pfc'))
            by (rewrite gRemLockSetRes gssThreadRes; rewrite <- Hdata_perm; reflexivity).
          erewrite restrPermMap_irr' with (Hlt' := (Hlt1F pff))
            by (rewrite gRemLockSetRes gssThreadRes; reflexivity).
          eapply setPermBlock_var_obs_eq; eauto.
          intros ofs0 Hrange.
          pose proof (val_obs_eq (strong_obs_eq Hmem_obs_eq_locks)  _ ofs0 Hf) as Hval.
          specialize (Hfreeable _ Hrange).
          simpl in Hval.
          eapply Hval.
          unfold Mem.perm in *.
          erewrite po_oo in *.
          eapply po_trans; eauto.
          simpl; eauto using perm_order.
          
          erewrite restrPermMap_irr' with (Hlt' := (Hlt2 pfc'))
            by (rewrite gRemLockSetRes gssThreadRes; rewrite <- Hlock_perm; reflexivity).
          erewrite restrPermMap_irr' with (Hlt' := (Hlt2F pff))
            by (rewrite gRemLockSetRes gssThreadRes; reflexivity).
          eapply setPermBlock_obs_eq; eauto.
          intros ofs0 Hrange.
          pose proof (val_obs_eq (strong_obs_eq Hmem_obs_eq_locks)  _ ofs0 Hf) as Hval.
          specialize (Hfreeable _ Hrange).
          simpl in Hval.
          eapply Hval.
          unfold Mem.perm in *.
          erewrite po_oo in *.
          eapply po_trans; eauto.
          simpl; eauto using perm_order.
          repeat split;
            try (by congruence);
          destruct (Hunmapped_ls _ H ofs0).
          rewrite gRemLockSetRes gssThreadRes.
          rewrite setPermBlock_var_other_2.
          assumption.
            by (intros Hcontra; subst;
                eapply H; eexists; eauto).
            rewrite gRemLockSetRes gssThreadRes.
            rewrite setPermBlock_other_2.
            assumption.
              by (intros Hcontra; subst;
                  eapply H; eexists; eauto).
        }
        { 
          assert (Hstrong_sim := simStrong Hsim).
          assert (pfcj: containsThread tpc tid)
            by (eapply cntRemoveL' in pfc0;
                 eapply cntUpdate' in pfc0;
                 eauto).
          assert (pffj: containsThread tpf tid)
            by (eapply cntRemoveL' in pff0;
                 eapply cntUpdate' in pff0;
                 eauto).
          specialize (Hstrong_sim _ pfc0 pffj).
          destruct Hstrong_sim
            as (tpcj & mcj & Hincrj & Hsyncedj & Hexecj & Htsimj
                & Hownedj & Hownedj_lp & Hunmappedj).
          
          assert (pfcij:= containsThread_internal_execution Hexecj pfc).
          exists (remLockSet
                (updThread pfcij (Kresume c Vundef) pmap_tid')
                (b, Ptrofs.intval ofs)), mcj.
          split; eauto.
          split; eauto.
          split.
          do 2 rewrite remLock_updThread_comm.
          eapply updThread_internal_execution; eauto.
          eapply remLock_internal_execution; eauto.
          apply mem_compatible_remlock; auto.
          now apply (lockRes_valid _ HinvC).
          split.
          
          intros.
          assert (Hcompj: mem_compatible tpcj mcj)
            by (eapply internal_execution_compatible with (tp := tpc); eauto).
          specialize (Htsimj pfc' Hcompj).
          destruct Htsimj as [Hcorej Hmem_obs_eqj].
          constructor.
          rewrite gRemLockSetCode.
          rewrite gsoThreadCode; auto.
          rewrite gRemLockSetCode.
          rewrite gsoThreadCode; auto.
          erewrite restrPermMap_irr' with (Hlt := (compat_th _ _ mem_compc' pfc').1)
                                            (Hlt' := (compat_th _ _ Hcompj pfc').1)
            by (rewrite gRemLockSetRes gsoThreadRes; auto).
          erewrite restrPermMap_irr' with (Hlt := (compat_th _ _ HmemCompF' pff0).1)
                                            (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).1)
            by (rewrite gRemLockSetRes gsoThreadRes; auto).
          eauto.
          erewrite restrPermMap_irr' with (Hlt := (compat_th _ _ mem_compc' pfc').2)
                                            (Hlt' := (compat_th _ _ Hcompj pfc').2)
            by (rewrite gRemLockSetRes gsoThreadRes; auto).
          erewrite restrPermMap_irr' with (Hlt := (compat_th _ _ HmemCompF' pff0).2)
                                            (Hlt' := (compat_th _ _ (mem_compf Hsim) pffj).2)
            by (rewrite gRemLockSetRes gsoThreadRes; auto).
          eauto.
          split.
          intros.
          rewrite gRemLockSetRes.
          destruct (i == tid2) eqn:Hi2; move/eqP:Hi2=>Hi2.
          { subst tid2.
            rewrite gssThreadRes.
            destruct (Pos.eq_dec b2 b0).
            - subst.
              assert (b = b1).
              { apply Hincrj in Hf.
                assert (HmemCompCj: mem_compatible tpcj mcj)
                  by (eapply internal_execution_compatible with (tp := tpc); eauto).
                specialize (Htsimj (containsThread_internal_execution Hexecj pfcj)
                                   HmemCompCj).
                eapply (injective (weak_obs_eq (obs_eq_data Htsimj)));
                  by eauto.
              }
              subst b1. congruence.
            - rewrite! setPermBlock_other_2; auto.
              rewrite! setPermBlock_var_other_2; auto.
              eapply Hownedj; eauto.
          }
          { rewrite gsoThreadRes; auto.
            eapply Hownedj; eauto.
          }
          split.
          
          { intros.
            destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)).
            - inversion e; subst.
              rewrite gsslockResRemLock in H1.
              discriminate.
            - rewrite gsolockResRemLock in H1; auto.
              rewrite gsoThreadLPool in H1.
              now eauto.
          }
          
          intros.
          rewrite gRemLockSetRes.
          rewrite gsoThreadRes;
            now eauto.
        }
      - split.
        
        intros bl1 bl2 ofs0 rmap1' rmap2' Hfi Hres1' Hres2'.
        destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)) as [Heql1 | Hneql1].
        { 
          exfalso.
          inversion Heql1; subst.
          rewrite gsslockResRemLock in Hres1'.
          discriminate.
        }
        { assert (Hneq2: (b2, Ptrofs.intval ofs) <> (bl2, ofs0)).
          { intros Hcontra; inversion Hcontra; subst.
            rewrite gsslockResRemLock in Hres2'.
            discriminate.
          }
          assert (Hres1: lockRes tpc (bl1, ofs0) = Some rmap1')
            by ( rewrite gsolockResRemLock in Hres1'; auto;
                 rewrite gsoThreadLPool in Hres1'; auto).
          assert (Hres2: lockRes tpf (bl2, ofs0) = Some rmap2')
            by ( rewrite gsolockResRemLock in Hres2'; auto;
                 rewrite gsoThreadLPool in Hres2'; auto).
          assert (Heq1: restrPermMap ((compat_lp _ _ HmemCompC' (bl1, ofs0) _ Hres1').1) =
                       restrPermMap ((compat_lp _ _ HmemCompC (bl1, ofs0) _ Hres1).1))
            by (erewrite restrPermMap_irr'; eauto).
          assert (HeqF: restrPermMap ((compat_lp _ _  HmemCompF' (bl2, ofs0) _ Hres2').1) =
                       restrPermMap ((compat_lp _ _ (mem_compf Hsim) (bl2, ofs0) _ Hres2).1))
            by (erewrite restrPermMap_irr'; eauto).
          assert (Heq2: restrPermMap ((compat_lp _ _ HmemCompC' (bl1, ofs0) _ Hres1').2) =
                        restrPermMap ((compat_lp _ _ HmemCompC (bl1, ofs0) _ Hres1).2))
            by (erewrite restrPermMap_irr'; eauto).
          assert (Heq2F: restrPermMap ((compat_lp _ _ HmemCompF' (bl2, ofs0) _ Hres2').2) =
                        restrPermMap ((compat_lp _ _ (mem_compf Hsim) (bl2, ofs0) _ Hres2).2))
            by (erewrite restrPermMap_irr'; eauto).
          rewrite Heq1 HeqF Heq2 Heq2F.
          eauto.
        }
        split.
        { 
          intros bl2 ofs0 Hres.
          destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl2, ofs0)).
          - inversion e; subst.
            eexists; eauto.
          - rewrite gsolockResRemLock in Hres; auto.
            rewrite gsoThreadLPool in Hres;
            eauto.
        }
        { 
          intros bl1 bl2 ofs0 Hrenaming.
          destruct (EqDec_address (b, Ptrofs.intval ofs) (bl1, ofs0)) as [Heql1 | Hneql1].
          - 
            inversion Heql1; subst.
            assert (b2 = bl2)
              by (rewrite Hf in Hrenaming; inversion Hrenaming; by subst).
            subst bl2.
            split; intro Hcontra;
            rewrite gsslockResRemLock in Hcontra;
              by exfalso.
          - assert (Hneq2: (b2, Ptrofs.intval ofs) <> (bl2, ofs0))
              by (intros Hcontra; inversion Hcontra; subst;
                  specialize (Hinjective _ _ _ Hf Hrenaming); by subst).
            rewrite gsolockResRemLock; auto.
            rewrite gsoThreadLPool.
            rewrite gsolockResRemLock; auto.
            rewrite gsoThreadLPool.
            eauto.
        }
      - 
        intros.
        destruct (EqDec_address (b2, Ptrofs.intval ofs) (bl, ofsl)) as [Heql1 | Hneql1].
        + inversion Heql1; subst.
          rewrite gsslockResRemLock in H.
          discriminate.
        + rewrite gsolockResRemLock in H; auto.
          rewrite gsoThreadLPool in H.
          now eauto.
      - 
        destruct pmap_tid'. simpl in Hdata_perm, Hlock_perm.
        subst.
        eapply invariant_freelock;
          now eauto.
      - 
          by assumption.
      - 
        assumption.
      - 
        eapply tp_wd_remLock.
        intros j cntj'.
        destruct (i == j) eqn:Hij; move/eqP:Hij=>Hij.
        subst. rewrite gssThreadCode.
        specialize (Htpc_wd _ pfc).
        rewrite Hcode in Htpc_wd.
        simpl in *;
          by auto.
        assert (cntj := cntUpdate' _ _ _ cntj').
        erewrite @gsoThreadCode with (cntj := cntj) by assumption.
        specialize (Htpc_wd _ cntj).
          by auto.
      - 
        assumption.
      - 
        split; assumption.
      - intros.
        apply cntRemoveL;
          apply cntUpdate;
            by eauto.
      - econstructor;
          eauto.
        econstructor;
          now eauto.
    }
    { 
      subst tpc' mc'.
            assert (Hcore_inj:= code_eq Htsim).
      rewrite Hcode in Hcore_inj.
      simpl in Hcore_inj.
      subst.
      destruct (getThreadC pff) as [? | cf |? | ?] eqn:HcodeF;
        try by exfalso.
      
      assert (Hat_external_spec := core_inj_ext _ _ Hfg Hge_wd Hge_incr Hvalid_mem' Hcore_inj (obs_eq_data Htsim)).
      rewrite Hat_external in Hat_external_spec.
      destruct (at_external semSem cf (restrPermMap (compat_th _ _ (mem_compf Hsim) pff)#1))
        as [[? vsf] | ] eqn:Hat_externalF;
        try by exfalso.
            destruct Hat_external_spec as [? Harg_obs]; subst.
      inversion Harg_obs as [|? ? ? ? Hptr_obs Hl]; subst.
      inversion Hl; subst.
      inversion Hptr_obs as [| | | |b1 b2 ofs0 Hf|];
        subst b1 ofs0 v'.
      
      remember (restrPermMap (compat_th _ _ (mem_compf Hsim) pff).2) as mf1 eqn:Hrestrict_pmapF.
            assert (HloadF: Mem.load Mint32 mf1 b2 (Ptrofs.intval ofs) = Some (Vint Int.zero)).
      { destruct (load_val_obs _ _ _ Hload Hf Hinjective (strong_obs_eq (obs_eq_locks Htsim)))
          as [v2 [Hloadf Hobs_eq]].
        inversion Hobs_eq; subst.
          by auto.
      }
      
      exists tpf, mf, (fp i pfc), fp, (trf ++ [:: (external i (failacq (b2, Ptrofs.intval ofs)))]).
      split.
      intros U.
      subst.
      econstructor 5; simpl; eauto.
      econstructor 6; eauto.
      destruct Htsim.
      destruct obs_eq_locks0 as [_ [Hperm_eq ?]].
      unfold Mem.range_perm, Mem.perm, permission_at in *.
      intros.
      erewrite Hperm_eq;
        now eauto.
      
      eapply sim_reduce; eauto.
      econstructor; eauto.
      destruct Hsim.
      eauto.
      econstructor;
        eauto.
      econstructor;
        now eauto.
    }
    Unshelve. all:eauto.
    eapply store_compatible; eauto. eapply (mem_compf Hsim).
    eapply store_compatible; eauto. eapply (mem_compf Hsim).
Admitted.

End SimProofs.

End SimProofs.
