

Require Import ProofIrrelevance.



Require Import compcert.common.Memory.
(* compcert.common.Memory:
Require Import Zwf.
Require Import Axioms.
Require Import Coqlib.
Require Intv.
Require Import Maps.
Require Archi.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Export Memdata.
Require Export Memtype.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Local Notation "a # b" := (PMap.get b a) (at level 1).

Module Mem <: MEM.

Definition perm_order' (po: option permission) (p: permission) :=
  match po with
  | Some p' => perm_order p' p
  | None => False
 end.

Definition perm_order'' (po1 po2: option permission) :=
  match po1, po2 with
  | Some p1, Some p2 => perm_order p1 p2
  | _, None => True
  | None, Some _ => False
 end.

Record mem' : Type := mkmem {
  mem_contents: PMap.t (ZMap.t memval);  
  mem_access: PMap.t (Z -> perm_kind -> option permission);
                                         
  nextblock: block;
  access_max:
    forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
  nextblock_noaccess:
    forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
  contents_default:
    forall b, fst mem_contents#b = Undef
}.

Definition mem := mem'.

Lemma mkmem_ext:
 forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.

Definition valid_block (m: mem) (b: block) := Plt b (nextblock m).

Theorem valid_not_valid_diff:
  forall m b b', valid_block m b -> ~(valid_block m b') -> b <> b'.

Local Hint Resolve valid_not_valid_diff: mem.

Definition perm (m: mem) (b: block) (ofs: Z) (k: perm_kind) (p: permission) : Prop :=
   perm_order' (m.(mem_access)#b ofs k) p.

Theorem perm_implies:
  forall m b ofs k p1 p2, perm m b ofs k p1 -> perm_order p1 p2 -> perm m b ofs k p2.

Local Hint Resolve perm_implies: mem.

Theorem perm_cur_max:
  forall m b ofs p, perm m b ofs Cur p -> perm m b ofs Max p.

Theorem perm_cur:
  forall m b ofs k p, perm m b ofs Cur p -> perm m b ofs k p.

Theorem perm_max:
  forall m b ofs k p, perm m b ofs k p -> perm m b ofs Max p.

Local Hint Resolve perm_cur perm_max: mem.

Theorem perm_valid_block:
  forall m b ofs k p, perm m b ofs k p -> valid_block m b.

Local Hint Resolve perm_valid_block: mem.

Remark perm_order_dec:
  forall p1 p2, {perm_order p1 p2} + {~perm_order p1 p2}.

Remark perm_order'_dec:
  forall op p, {perm_order' op p} + {~perm_order' op p}.

Theorem perm_dec:
  forall m b ofs k p, {perm m b ofs k p} + {~ perm m b ofs k p}.

Definition range_perm (m: mem) (b: block) (lo hi: Z) (k: perm_kind) (p: permission) : Prop :=
  forall ofs, lo <= ofs < hi -> perm m b ofs k p.

Theorem range_perm_implies:
  forall m b lo hi k p1 p2,
  range_perm m b lo hi k p1 -> perm_order p1 p2 -> range_perm m b lo hi k p2.

Theorem range_perm_cur:
  forall m b lo hi k p,
  range_perm m b lo hi Cur p -> range_perm m b lo hi k p.

Theorem range_perm_max:
  forall m b lo hi k p,
  range_perm m b lo hi k p -> range_perm m b lo hi Max p.

Local Hint Resolve range_perm_implies range_perm_cur range_perm_max: mem.

Lemma range_perm_dec:
  forall m b lo hi k p, {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.

Definition valid_access (m: mem) (chunk: memory_chunk) (b: block) (ofs: Z) (p: permission): Prop :=
  range_perm m b ofs (ofs + size_chunk chunk) Cur p
  /\ (align_chunk chunk | ofs).

Theorem valid_access_implies:
  forall m chunk b ofs p1 p2,
  valid_access m chunk b ofs p1 -> perm_order p1 p2 ->
  valid_access m chunk b ofs p2.

Theorem valid_access_freeable_any:
  forall m chunk b ofs p,
  valid_access m chunk b ofs Freeable ->
  valid_access m chunk b ofs p.

Local Hint Resolve valid_access_implies: mem.

Theorem valid_access_valid_block:
  forall m chunk b ofs,
  valid_access m chunk b ofs Nonempty ->
  valid_block m b.

Local Hint Resolve valid_access_valid_block: mem.

Lemma valid_access_perm:
  forall m chunk b ofs k p,
  valid_access m chunk b ofs p ->
  perm m b ofs k p.

Lemma valid_access_compat:
  forall m chunk1 chunk2 b ofs p,
  size_chunk chunk1 = size_chunk chunk2 ->
  align_chunk chunk2 <= align_chunk chunk1 ->
  valid_access m chunk1 b ofs p->
  valid_access m chunk2 b ofs p.

Lemma valid_access_dec:
  forall m chunk b ofs p,
  {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.

Definition valid_pointer (m: mem) (b: block) (ofs: Z): bool :=
  perm_dec m b ofs Cur Nonempty.

Theorem valid_pointer_nonempty_perm:
  forall m b ofs,
  valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.

Theorem valid_pointer_valid_access:
  forall m b ofs,
  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.

Definition weak_valid_pointer (m: mem) (b: block) (ofs: Z) :=
  valid_pointer m b ofs || valid_pointer m b (ofs - 1).

Lemma weak_valid_pointer_spec:
  forall m b ofs,
  weak_valid_pointer m b ofs = true <->
    valid_pointer m b ofs = true \/ valid_pointer m b (ofs - 1) = true.
Lemma valid_pointer_implies:
  forall m b ofs,
  valid_pointer m b ofs = true -> weak_valid_pointer m b ofs = true.

Program Definition empty: mem :=
  mkmem (PMap.init (ZMap.init Undef))

Program Definition alloc (m: mem) (lo hi: Z) :=
  (mkmem (PMap.set m.(nextblock)

Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
  mkmem m.(mem_contents)

Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
  if range_perm_dec m b lo hi Cur Freeable
  then Some(unchecked_free m b lo hi)
  else None.

Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
  match l with
  | nil => Some m
  | (b, lo, hi) :: l' =>
      match free m b lo hi with
      | None => None
      | Some m' => free_list m' l'
      end
  end.

Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
  match n with
  | O => nil
  | S n' => ZMap.get p c :: getN n' (p + 1) c
  end.

Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
  if valid_access_dec m chunk b ofs Readable
  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
  else None.

Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
  match addr with
  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
  | _ => None
  end.

Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
  if range_perm_dec m b ofs (ofs + n) Cur Readable
  then Some (getN (nat_of_Z n) ofs (m.(mem_contents)#b))
  else None.

Fixpoint setN (vl: list memval) (p: Z) (c: ZMap.t memval) {struct vl}: ZMap.t memval :=
  match vl with
  | nil => c
  | v :: vl' => setN vl' (p + 1) (ZMap.set p v c)
  end.

Remark setN_other:
  forall vl c p q,
  (forall r, p <= r < p + Z.of_nat (length vl) -> r <> q) ->

Remark setN_outside:
  forall vl c p q,
  q < p \/ q >= p + Z.of_nat (length vl) ->

Remark getN_setN_same:
  forall vl p c,
  getN (length vl) p (setN vl p c) = vl.

Remark getN_exten:
  forall c1 c2 n p,
  (forall i, p <= i < p + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->

Remark getN_setN_disjoint:
  forall vl q c n p,
  Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (length vl)) ->

Remark getN_setN_outside:
  forall vl q c n p,
  p + Z.of_nat n <= q \/ q + Z.of_nat (length vl) <= p ->

Remark setN_default:
  forall vl q c, fst (setN vl q c) = fst c.

Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val): option mem :=
  if valid_access_dec m chunk b ofs Writable then
    Some (mkmem (PMap.set b

Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
  match addr with
  | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
  | _ => None
  end.

Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
  if range_perm_dec m b ofs (ofs + Z.of_nat (length bytes)) Cur Writable then

Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
  if range_perm_dec m b lo hi Cur Freeable then
    Some (mkmem m.(mem_contents)

Theorem nextblock_empty: nextblock empty = 1%positive.

Theorem perm_empty: forall b ofs k p, ~perm empty b ofs k p.

Theorem valid_access_empty: forall chunk b ofs p, ~valid_access empty chunk b ofs p.

Theorem valid_access_load:
  forall m chunk b ofs,
  valid_access m chunk b ofs Readable ->
  exists v, load chunk m b ofs = Some v.

Theorem load_valid_access:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  valid_access m chunk b ofs Readable.

Lemma load_result:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).

Local Hint Resolve load_valid_access valid_access_load: mem.

Theorem load_type:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  Val.has_type v (type_of_chunk chunk).

Theorem load_cast:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v

Theorem load_int8_signed_unsigned:
  forall m b ofs,
  load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).

Theorem load_int16_signed_unsigned:
  forall m b ofs,
  load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).

Theorem range_perm_loadbytes:
  forall m b ofs len,
  range_perm m b ofs (ofs + len) Cur Readable ->
  exists bytes, loadbytes m b ofs len = Some bytes.

Theorem loadbytes_range_perm:
  forall m b ofs len bytes,
  loadbytes m b ofs len = Some bytes ->
  range_perm m b ofs (ofs + len) Cur Readable.

Theorem loadbytes_load:
  forall chunk m b ofs bytes,
  loadbytes m b ofs (size_chunk chunk) = Some bytes ->
  (align_chunk chunk | ofs) ->
  load chunk m b ofs = Some(decode_val chunk bytes).

Theorem load_loadbytes:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
             /\ v = decode_val chunk bytes.

Lemma getN_length:
  forall c n p, length (getN n p c) = n.

Theorem loadbytes_length:
  forall m b ofs n bytes,
  loadbytes m b ofs n = Some bytes ->
  length bytes = nat_of_Z n.

Theorem loadbytes_empty:
  forall m b ofs n,
  n <= 0 -> loadbytes m b ofs n = Some nil.

Lemma getN_concat:
  forall c n1 n2 p,
  getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z.of_nat n1) c.

Theorem loadbytes_concat:
  forall m b ofs n1 n2 bytes1 bytes2,
  loadbytes m b ofs n1 = Some bytes1 ->
  loadbytes m b (ofs + n1) n2 = Some bytes2 ->
  n1 >= 0 -> n2 >= 0 ->
  loadbytes m b ofs (n1 + n2) = Some(bytes1 ++ bytes2).

Theorem loadbytes_split:
  forall m b ofs n1 n2 bytes,
  loadbytes m b ofs (n1 + n2) = Some bytes ->
  n1 >= 0 -> n2 >= 0 ->
  exists bytes1, exists bytes2,
     loadbytes m b ofs n1 = Some bytes1
  /\ loadbytes m b (ofs + n1) n2 = Some bytes2
  /\ bytes = bytes1 ++ bytes2.

Theorem load_rep:
 forall ch m1 m2 b ofs v1 v2,
  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->

Theorem load_int64_split:
  forall m b ofs v,
  load Mint64 m b ofs = Some v -> Archi.ptr64 = false ->

Lemma addressing_int64_split:
  forall i,
  Archi.ptr64 = false ->

Theorem loadv_int64_split:
  forall m a v,
  loadv Mint64 m a = Some v -> Archi.ptr64 = false ->

Theorem valid_access_store:
  forall m1 chunk b ofs v,
  valid_access m1 chunk b ofs Writable ->
  { m2: mem | store chunk m1 b ofs v = Some m2 }.

Local Hint Resolve valid_access_store: mem.

Section STORE.
Variable chunk: memory_chunk.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable v: val.
Variable m2: mem.
Hypothesis STORE: store chunk m1 b ofs v = Some m2.

Lemma store_access: mem_access m2 = mem_access m1.

Lemma store_mem_contents:
  mem_contents m2 = PMap.set b (setN (encode_val chunk v) ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_store_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_store_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_store_1 perm_store_2: mem.

Theorem nextblock_store:
  nextblock m2 = nextblock m1.

Theorem store_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem store_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.

Theorem store_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem store_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Theorem store_valid_access_3:
  valid_access m1 chunk b ofs Writable.

Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.

Theorem load_store_similar:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  exists v', load chunk' m2 b ofs = Some v' /\ decode_encode_val v chunk chunk' v'.

Theorem load_store_similar_2:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  type_of_chunk chunk' = type_of_chunk chunk ->
  load chunk' m2 b ofs = Some (Val.load_result chunk' v).

Theorem load_store_same:
  load chunk m2 b ofs = Some (Val.load_result chunk v).

Theorem load_store_other:
  forall chunk' b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk' <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.

Theorem loadbytes_store_same:
  loadbytes m2 b ofs (size_chunk chunk) = Some(encode_val chunk v).

Theorem loadbytes_store_other:
  forall b' ofs' n,
  b' <> b
  \/ n <= 0
  \/ ofs' + n <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.

Lemma setN_in:
  forall vl p q c,
  p <= q < p + Z.of_nat (length vl) ->

Lemma getN_in:
  forall c q n p,
  p <= q < p + Z.of_nat n ->

End STORE.

Local Hint Resolve perm_store_1 perm_store_2: mem.
Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.
Local Hint Resolve store_valid_access_1 store_valid_access_2
             store_valid_access_3: mem.

Lemma load_store_overlap:
  forall chunk m1 b ofs v m2 chunk' ofs' v',
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b ofs' = Some v' ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  exists mv1 mvl mv1' mvl',
      shape_encoding chunk v (mv1 :: mvl)
  /\  shape_decoding chunk' (mv1' :: mvl') v'
  /\  (   (ofs' = ofs /\ mv1' = mv1)
       \/ (ofs' > ofs /\ In mv1' mvl)
       \/ (ofs' < ofs /\ In mv1 mvl')).

Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
  match chunk1, chunk2 with
  | (Mint32 | Many32), (Mint32 | Many32) => True
  | (Mint64 | Many64), (Mint64 | Many64) => True
  | _, _ => False
  end.

Lemma compat_pointer_chunks_true:
  forall chunk1 chunk2,
  (chunk1 = Mint32 \/ chunk1 = Many32 \/ chunk1 = Mint64 \/ chunk1 = Many64) ->
  (chunk2 = Mint32 \/ chunk2 = Many32 \/ chunk2 = Mint64 \/ chunk2 = Many64) ->
  quantity_chunk chunk1 = quantity_chunk chunk2 ->
  compat_pointer_chunks chunk1 chunk2.

Theorem load_pointer_store:
  forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b' ofs' = Some(Vptr v_b v_o) ->
  (v = Vptr v_b v_o /\ compat_pointer_chunks chunk chunk' /\ b' = b /\ ofs' = ofs)
  \/ (b' <> b \/ ofs' + size_chunk chunk' <= ofs \/ ofs + size_chunk chunk <= ofs').

Theorem load_store_pointer_overlap:
  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs' = Some v ->
  ofs' <> ofs ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  v = Vundef.

Theorem load_store_pointer_mismatch:
  forall chunk m1 b ofs v_b v_o m2 chunk' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs = Some v ->
  ~compat_pointer_chunks chunk chunk' ->
  v = Vundef.

Lemma store_similar_chunks:
  forall chunk1 chunk2 v1 v2 m b ofs,
  encode_val chunk1 v1 = encode_val chunk2 v2 ->
  align_chunk chunk1 = align_chunk chunk2 ->
  store chunk1 m b ofs v1 = store chunk2 m b ofs v2.

Theorem store_signed_unsigned_8:
  forall m b ofs v,
  store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.

Theorem store_signed_unsigned_16:
  forall m b ofs v,
  store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.

Theorem store_int8_zero_ext:
  forall m b ofs n,
  store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =

Theorem store_int8_sign_ext:
  forall m b ofs n,
  store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =

Theorem store_int16_zero_ext:
  forall m b ofs n,
  store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =

Theorem store_int16_sign_ext:
  forall m b ofs n,
  store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =

Theorem range_perm_storebytes:
  forall m1 b ofs bytes,
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable ->

Theorem storebytes_store:
  forall m1 b ofs chunk v m2,
  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
  (align_chunk chunk | ofs) ->
  store chunk m1 b ofs v = Some m2.

Theorem store_storebytes:
  forall m1 b ofs chunk v m2,
  store chunk m1 b ofs v = Some m2 ->
  storebytes m1 b ofs (encode_val chunk v) = Some m2.

Section STOREBYTES.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable bytes: list memval.
Variable m2: mem.
Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.

Lemma storebytes_access: mem_access m2 = mem_access m1.

Lemma storebytes_mem_contents:
   mem_contents m2 = PMap.set b (setN bytes ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_storebytes_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_storebytes_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.

Theorem storebytes_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem storebytes_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Local Hint Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.

Theorem nextblock_storebytes:
  nextblock m2 = nextblock m1.

Theorem storebytes_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem storebytes_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.

Theorem storebytes_range_perm:
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable.

Theorem loadbytes_storebytes_same:
  loadbytes m2 b ofs (Z.of_nat (length bytes)) = Some bytes.

Theorem loadbytes_storebytes_disjoint:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b \/ Intv.disjoint (ofs', ofs' + len) (ofs, ofs + Z.of_nat (length bytes)) ->

Theorem loadbytes_storebytes_other:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b
  \/ ofs' + len <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

Theorem load_storebytes_other:
  forall chunk b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

End STOREBYTES.

Lemma setN_concat:
  forall bytes1 bytes2 ofs c,
  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z.of_nat (length bytes1)) (setN bytes1 ofs c).

Theorem storebytes_concat:
  forall m b ofs bytes1 m1 bytes2 m2,
  storebytes m b ofs bytes1 = Some m1 ->
  storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2 ->

Theorem storebytes_split:
  forall m b ofs bytes1 bytes2 m2,
  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
  exists m1,
     storebytes m b ofs bytes1 = Some m1
  /\ storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2.

Theorem store_int64_split:
  forall m b ofs v m',
  store Mint64 m b ofs v = Some m' -> Archi.ptr64 = false ->

Theorem storev_int64_split:
  forall m a v m',
  storev Mint64 m a v = Some m' -> Archi.ptr64 = false ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: block.
Hypothesis ALLOC: alloc m1 lo hi = (m2, b).

Theorem nextblock_alloc:
  nextblock m2 = Pos.succ (nextblock m1).

Theorem alloc_result:
  b = nextblock m1.

Theorem valid_block_alloc:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem fresh_block_alloc:
  ~(valid_block m1 b).

Theorem valid_new_block:
  valid_block m2 b.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.

Theorem valid_block_alloc_inv:
  forall b', valid_block m2 b' -> b' = b \/ valid_block m1 b'.

Theorem perm_alloc_1:
  forall b' ofs k p, perm m1 b' ofs k p -> perm m2 b' ofs k p.

Theorem perm_alloc_2:
  forall ofs k, lo <= ofs < hi -> perm m2 b ofs k Freeable.

Theorem perm_alloc_inv:
  forall b' ofs k p,
  perm m2 b' ofs k p ->
  if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p.

Theorem perm_alloc_3:
  forall ofs k p, perm m2 b ofs k p -> lo <= ofs < hi.

Theorem perm_alloc_4:
  forall b' ofs k p, perm m2 b' ofs k p -> b' <> b -> perm m1 b' ofs k p.

Local Hint Resolve perm_alloc_1 perm_alloc_2 perm_alloc_3 perm_alloc_4: mem.

Theorem valid_access_alloc_other:
  forall chunk b' ofs p,
  valid_access m1 chunk b' ofs p ->
  valid_access m2 chunk b' ofs p.

Theorem valid_access_alloc_same:
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  valid_access m2 chunk b ofs Freeable.

Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem valid_access_alloc_inv:
  forall chunk b' ofs p,
  valid_access m2 chunk b' ofs p ->
  if eq_block b' b
  then lo <= ofs /\ ofs + size_chunk chunk <= hi /\ (align_chunk chunk | ofs)
  else valid_access m1 chunk b' ofs p.

Theorem load_alloc_unchanged:
  forall chunk b' ofs,
  valid_block m1 b' ->
  load chunk m2 b' ofs = load chunk m1 b' ofs.

Theorem load_alloc_other:
  forall chunk b' ofs v,
  load chunk m1 b' ofs = Some v ->
  load chunk m2 b' ofs = Some v.

Theorem load_alloc_same:
  forall chunk ofs v,
  load chunk m2 b ofs = Some v ->
  v = Vundef.

Theorem load_alloc_same':
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  load chunk m2 b ofs = Some Vundef.

Theorem loadbytes_alloc_unchanged:
  forall b' ofs n,
  valid_block m1 b' ->
  loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.

Theorem loadbytes_alloc_same:
  forall n ofs bytes byte,
  loadbytes m2 b ofs n = Some bytes ->
  In byte bytes -> byte = Undef.

End ALLOC.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem range_perm_free:
  forall m1 b lo hi,
  range_perm m1 b lo hi Cur Freeable ->
  { m2: mem | free m1 b lo hi = Some m2 }.

Section FREE.

Variable m1: mem.
Variable bf: block.
Variables lo hi: Z.
Variable m2: mem.
Hypothesis FREE: free m1 bf lo hi = Some m2.

Theorem free_range_perm:
  range_perm m1 bf lo hi Cur Freeable.

Lemma free_result:
  m2 = unchecked_free m1 bf lo hi.

Theorem nextblock_free:
  nextblock m2 = nextblock m1.

Theorem valid_block_free_1:
  forall b, valid_block m1 b -> valid_block m2 b.

Theorem valid_block_free_2:
  forall b, valid_block m2 b -> valid_block m1 b.

Local Hint Resolve valid_block_free_1 valid_block_free_2: mem.

Theorem perm_free_1:
  forall b ofs k p,
  b <> bf \/ ofs < lo \/ hi <= ofs ->
  perm m1 b ofs k p ->
  perm m2 b ofs k p.

Theorem perm_free_2:
  forall ofs k p, lo <= ofs < hi -> ~ perm m2 bf ofs k p.

Theorem perm_free_3:
  forall b ofs k p,
  perm m2 b ofs k p -> perm m1 b ofs k p.

Theorem perm_free_inv:
  forall b ofs k p,
  perm m1 b ofs k p ->
  (b = bf /\ lo <= ofs < hi) \/ perm m2 b ofs k p.

Theorem valid_access_free_1:
  forall chunk b ofs p,
  valid_access m1 chunk b ofs p ->
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  valid_access m2 chunk b ofs p.

Theorem valid_access_free_2:
  forall chunk ofs p,
  lo < hi -> ofs + size_chunk chunk > lo -> ofs < hi ->
  ~(valid_access m2 chunk bf ofs p).

Theorem valid_access_free_inv_1:
  forall chunk b ofs p,
  valid_access m2 chunk b ofs p ->
  valid_access m1 chunk b ofs p.

Theorem valid_access_free_inv_2:
  forall chunk ofs p,
  valid_access m2 chunk bf ofs p ->
  lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs.

Theorem load_free:
  forall chunk b ofs,
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  load chunk m2 b ofs = load chunk m1 b ofs.

Theorem load_free_2:
  forall chunk b ofs v,
  load chunk m2 b ofs = Some v -> load chunk m1 b ofs = Some v.

Theorem loadbytes_free:
  forall b ofs n,
  b <> bf \/ lo >= hi \/ ofs + n <= lo \/ hi <= ofs ->
  loadbytes m2 b ofs n = loadbytes m1 b ofs n.

Theorem loadbytes_free_2:
  forall b ofs n bytes,
  loadbytes m2 b ofs n = Some bytes -> loadbytes m1 b ofs n = Some bytes.

End FREE.

Local Hint Resolve valid_block_free_1 valid_block_free_2
             perm_free_1 perm_free_2 perm_free_3
             valid_access_free_1 valid_access_free_inv_1: mem.

Theorem range_perm_drop_1:
  forall m b lo hi p m', drop_perm m b lo hi p = Some m' -> range_perm m b lo hi Cur Freeable.

Theorem range_perm_drop_2:
  forall m b lo hi p,
  range_perm m b lo hi Cur Freeable -> {m' | drop_perm m b lo hi p = Some m' }.

Section DROP.

Variable m: mem.
Variable b: block.
Variable lo hi: Z.
Variable p: permission.
Variable m': mem.
Hypothesis DROP: drop_perm m b lo hi p = Some m'.

Theorem nextblock_drop:
  nextblock m' = nextblock m.

Theorem drop_perm_valid_block_1:
  forall b', valid_block m b' -> valid_block m' b'.

Theorem drop_perm_valid_block_2:
  forall b', valid_block m' b' -> valid_block m b'.

Theorem perm_drop_1:
  forall ofs k, lo <= ofs < hi -> perm m' b ofs k p.

Theorem perm_drop_2:
  forall ofs k p', lo <= ofs < hi -> perm m' b ofs k p' -> perm_order p p'.

Theorem perm_drop_3:
  forall b' ofs k p', b' <> b \/ ofs < lo \/ hi <= ofs -> perm m b' ofs k p' -> perm m' b' ofs k p'.

Theorem perm_drop_4:
  forall b' ofs k p', perm m' b' ofs k p' -> perm m b' ofs k p'.

Lemma valid_access_drop_1:
  forall chunk b' ofs p',
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p p' ->
  valid_access m chunk b' ofs p' -> valid_access m' chunk b' ofs p'.

Lemma valid_access_drop_2:
  forall chunk b' ofs p',
  valid_access m' chunk b' ofs p' -> valid_access m chunk b' ofs p'.

Theorem load_drop:
  forall chunk b' ofs,
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p Readable ->
  load chunk m' b' ofs = load chunk m b' ofs.

Theorem loadbytes_drop:
  forall b' ofs n,
  b' <> b \/ ofs + n <= lo \/ hi <= ofs \/ perm_order p Readable ->
  loadbytes m' b' ofs n = loadbytes m b' ofs n.

End DROP.

Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
  mk_mem_inj {
    mi_perm:
      forall b1 b2 delta ofs k p,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs k p ->
      perm m2 b2 (ofs + delta) k p;
    mi_align:
      forall b1 b2 delta chunk ofs p,
      f b1 = Some(b2, delta) ->
      range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->
      (align_chunk chunk | delta);
    mi_memval:
      forall b1 ofs b2 delta,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs Cur Readable ->
      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
  }.

Lemma perm_inj:
  forall f m1 m2 b1 ofs k p b2 delta,
  mem_inj f m1 m2 ->
  perm m1 b1 ofs k p ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p.

Lemma range_perm_inj:
  forall f m1 m2 b1 lo hi k p b2 delta,
  mem_inj f m1 m2 ->
  range_perm m1 b1 lo hi k p ->
  f b1 = Some(b2, delta) ->
  range_perm m2 b2 (lo + delta) (hi + delta) k p.

Lemma valid_access_inj:
  forall f m1 m2 b1 b2 delta chunk ofs p,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Lemma getN_inj:
  forall f m1 m2 b1 b2 delta,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  forall n ofs,
  range_perm m1 b1 ofs (ofs + Z.of_nat n) Cur Readable ->

Lemma load_inj:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  mem_inj f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Lemma loadbytes_inj:
  forall f m1 m2 len b1 ofs b2 delta bytes1,
  mem_inj f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Lemma setN_inj:
  forall (access: Z -> Prop) delta f vl1 vl2,
  list_forall2 (memval_inject f) vl1 vl2 ->
  forall p c1 c2,
  (forall q, access q -> memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2)) ->

Definition meminj_no_overlap (f: meminj) (m: mem) : Prop :=
  forall b1 b1' delta1 b2 b2' delta2 ofs1 ofs2,
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m b1 ofs1 Max Nonempty ->
  perm m b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Lemma store_mapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Lemma store_unmapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma store_outside_inj:
  forall f m1 m2 chunk b ofs v m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  mem_inj f m1 m2'.

Lemma storebytes_mapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ mem_inj f n1 n2.

Lemma storebytes_unmapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma storebytes_outside_inj:
  forall f m1 m2 b ofs bytes2 m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Lemma storebytes_empty_inj:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  mem_inj f m1' m2'.

Lemma alloc_right_inj:
  forall f m1 m2 lo hi b2 m2',
  mem_inj f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  mem_inj f m1 m2'.

Lemma alloc_left_unmapped_inj:
  forall f m1 m2 lo hi m1' b1,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  f b1 = None ->
  mem_inj f m1' m2.

Definition inj_offset_aligned (delta: Z) (size: Z) : Prop :=
  forall chunk, size_chunk chunk <= size -> (align_chunk chunk | delta).

Lemma alloc_left_mapped_inj:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  inj_offset_aligned delta (hi-lo) ->
  (forall ofs k p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) ->
  f b1 = Some(b2, delta) ->
  mem_inj f m1' m2.

Lemma free_left_inj:
  forall f m1 m2 b lo hi m1',
  mem_inj f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  mem_inj f m1' m2.

Lemma free_right_inj:
  forall f m1 m2 b lo hi m2',
  mem_inj f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  mem_inj f m1 m2'.

Lemma drop_unmapped_inj:
  forall f m1 m2 b lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b lo hi p = Some m1' ->
  f b = None ->
  mem_inj f m1' m2.

Lemma drop_mapped_inj:
  forall f m1 m2 b1 b2 delta lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b1 lo hi p = Some m1' ->
  meminj_no_overlap f m1 ->
  f b1 = Some(b2, delta) ->
  exists m2',
      drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'
   /\ mem_inj f m1' m2'.

Lemma drop_outside_inj: forall f m1 m2 b lo hi p m2',
  mem_inj f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs' k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs' k p ->
    lo <= ofs' + delta < hi -> False) ->
  mem_inj f m1 m2'.

Record extends' (m1 m2: mem) : Prop :=
  mk_extends {
    mext_next: nextblock m1 = nextblock m2;
    mext_inj:  mem_inj inject_id m1 m2;
    mext_perm_inv: forall b ofs k p,
      perm m2 b ofs k p ->
      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
  }.

Definition extends := extends'.

Theorem extends_refl:
  forall m, extends m m.

Theorem load_extends:
  forall chunk m1 m2 b ofs v1,
  extends m1 m2 ->
  load chunk m1 b ofs = Some v1 ->
  exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.

Theorem loadv_extends:
  forall chunk m1 m2 addr1 addr2 v1,
  extends m1 m2 ->
  loadv chunk m1 addr1 = Some v1 ->
  Val.lessdef addr1 addr2 ->

Theorem loadbytes_extends:
  forall m1 m2 b ofs len bytes1,
  extends m1 m2 ->
  loadbytes m1 b ofs len = Some bytes1 ->
  exists bytes2, loadbytes m2 b ofs len = Some bytes2
              /\ list_forall2 memval_lessdef bytes1 bytes2.

Theorem store_within_extends:
  forall chunk m1 m2 b ofs v1 m1' v2,
  extends m1 m2 ->
  store chunk m1 b ofs v1 = Some m1' ->
  Val.lessdef v1 v2 ->

Theorem store_outside_extends:
  forall chunk m1 m2 b ofs v m2',
  extends m1 m2 ->
  store chunk m2 b ofs v = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) ->
  extends m1 m2'.

Theorem storev_extends:
  forall chunk m1 m2 addr1 v1 m1' addr2 v2,
  extends m1 m2 ->
  storev chunk m1 addr1 v1 = Some m1' ->
  Val.lessdef addr1 addr2 ->

Theorem storebytes_within_extends:
  forall m1 m2 b ofs bytes1 m1' bytes2,
  extends m1 m2 ->
  storebytes m1 b ofs bytes1 = Some m1' ->
  list_forall2 memval_lessdef bytes1 bytes2 ->
  exists m2',
     storebytes m2 b ofs bytes2 = Some m2'
  /\ extends m1' m2'.

Theorem storebytes_outside_extends:
  forall m1 m2 b ofs bytes2 m2',
  extends m1 m2 ->
  storebytes m2 b ofs bytes2 = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem alloc_extends:
  forall m1 m2 lo1 hi1 b m1' lo2 hi2,
  extends m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists m2',
     alloc m2 lo2 hi2 = (m2', b)
  /\ extends m1' m2'.

Theorem free_left_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  extends m1' m2.

Theorem free_right_extends:
  forall m1 m2 b lo hi m2',
  extends m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall ofs k p, perm m1 b ofs k p -> lo <= ofs < hi -> False) ->
  extends m1 m2'.

Theorem free_parallel_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  exists m2',
     free m2 b lo hi = Some m2'
  /\ extends m1' m2'.

Theorem valid_block_extends:
  forall m1 m2 b,
  extends m1 m2 ->
  (valid_block m1 b <-> valid_block m2 b).

Theorem perm_extends:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m1 b ofs k p -> perm m2 b ofs k p.

Theorem perm_extends_inv:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m2 b ofs k p -> perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty.

Theorem valid_access_extends:
  forall m1 m2 chunk b ofs p,
  extends m1 m2 -> valid_access m1 chunk b ofs p -> valid_access m2 chunk b ofs p.

Theorem valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 -> valid_pointer m1 b ofs = true -> valid_pointer m2 b ofs = true.

Theorem weak_valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 ->
  weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.

Record inject' (f: meminj) (m1 m2: mem) : Prop :=
  mk_inject {
    mi_inj:
      mem_inj f m1 m2;
    mi_freeblocks:
      forall b, ~(valid_block m1 b) -> f b = None;
    mi_mappedblocks:
      forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
    mi_no_overlap:
      meminj_no_overlap f m1;
    mi_representable:
      forall b b' delta ofs,
      f b = Some(b', delta) ->
      perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/ perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
      delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
    mi_perm_inv:
      forall b1 ofs b2 delta k p,
      f b1 = Some(b2, delta) ->
      perm m2 b2 (ofs + delta) k p ->
      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
  }.
Definition inject := inject'.

Local Hint Resolve mi_mappedblocks: mem.

Theorem valid_block_inject_1:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m1 b1.

Theorem valid_block_inject_2:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m2 b2.

Local Hint Resolve valid_block_inject_1 valid_block_inject_2: mem.

Theorem perm_inject:
  forall f m1 m2 b1 b2 delta ofs k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.

Theorem perm_inject_inv:
  forall f m1 m2 b1 ofs b2 delta k p,
  inject f m1 m2 ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p ->
  perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty.

Theorem range_perm_inject:
  forall f m1 m2 b1 b2 delta lo hi k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  range_perm m1 b1 lo hi k p -> range_perm m2 b2 (lo + delta) (hi + delta) k p.

Theorem valid_access_inject:
  forall f m1 m2 chunk b1 ofs b2 delta p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Theorem valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_pointer m1 b1 ofs = true ->
  valid_pointer m2 b2 (ofs + delta) = true.

Theorem weak_valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  weak_valid_pointer m1 b1 ofs = true ->
  weak_valid_pointer m2 b2 (ofs + delta) = true.

Lemma address_inject:
  forall f m1 m2 b1 ofs1 b2 delta p,
  inject f m1 m2 ->
  perm m1 b1 (Ptrofs.unsigned ofs1) Cur p ->

Lemma address_inject':
  forall f m1 m2 chunk b1 ofs1 b2 delta,
  inject f m1 m2 ->
  valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty ->

Theorem weak_valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem weak_valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem inject_no_overlap:
  forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
  inject f m1 m2 ->
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m1 b1 ofs1 Max Nonempty ->
  perm m1 b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Theorem different_pointers_inject:
  forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  inject f m m' ->
  b1 <> b2 ->
  valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->

Theorem disjoint_or_equal_inject:
  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
  inject f m m' ->
  f b1 = Some(b1', delta1) ->
  f b2 = Some(b2', delta2) ->
  range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty ->
  range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty ->
  sz > 0 ->
  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
             \/ ofs1 + delta1 + sz <= ofs2 + delta2
             \/ ofs2 + delta2 + sz <= ofs1 + delta1.

Theorem aligned_area_inject:
  forall f m m' b ofs al sz b' delta,
  inject f m m' ->
  al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz > 0 ->
  (al | sz) ->
  range_perm m b ofs (ofs + sz) Cur Nonempty ->
  (al | ofs) ->
  f b = Some(b', delta) ->
  (al | ofs + delta).

Theorem load_inject:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  inject f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Theorem loadv_inject:
  forall f m1 m2 chunk a1 a2 v1,
  inject f m1 m2 ->
  loadv chunk m1 a1 = Some v1 ->
  Val.inject f a1 a2 ->

Theorem loadbytes_inject:
  forall f m1 m2 b1 ofs len b2 delta bytes1,
  inject f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Theorem store_mapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Theorem store_unmapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem store_outside_inject:
  forall f m1 m2 chunk b ofs v m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  inject f m1 m2'.

Theorem storev_mapped_inject:
  forall f chunk m1 a1 v1 n1 m2 a2 v2,
  inject f m1 m2 ->
  storev chunk m1 a1 v1 = Some n1 ->
  Val.inject f a1 a2 ->

Theorem storebytes_mapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ inject f n1 n2.

Theorem storebytes_unmapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem storebytes_outside_inject:
  forall f m1 m2 b ofs bytes2 m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem storebytes_empty_inject:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  inject f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  inject f m1' m2'.

Theorem alloc_right_inject:
  forall f m1 m2 lo hi b2 m2',
  inject f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  inject f m1 m2'.

Theorem alloc_left_unmapped_inject:
  forall f m1 m2 lo hi m1' b1,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  exists f',
     inject f' m1' m2
  /\ inject_incr f f'
  /\ f' b1 = None
  /\ (forall b, b <> b1 -> f' b = f b).

Theorem alloc_left_mapped_inject:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  0 <= delta <= Ptrofs.max_unsigned ->

Theorem alloc_parallel_inject:
  forall f m1 m2 lo1 hi1 m1' b1 lo2 hi2,
  inject f m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b1) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists f', exists m2', exists b2,
  alloc m2 lo2 hi2 = (m2', b2)
  /\ inject f' m1' m2'
  /\ inject_incr f f'
  /\ f' b1 = Some(b2, 0)
  /\ (forall b, b <> b1 -> f' b = f b).

Lemma free_left_inject:
  forall f m1 m2 b lo hi m1',
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  inject f m1' m2.

Lemma free_list_left_inject:
  forall f m2 l m1 m1',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  inject f m1' m2.

Lemma free_right_inject:
  forall f m1 m2 b lo hi m2',
  inject f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) -> perm m1 b1 ofs k p ->
    lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma perm_free_list:
  forall l m m' b ofs k p,
  free_list m l = Some m' ->
  perm m' b ofs k p ->
  perm m b ofs k p /\
  (forall lo hi, In (b, lo, hi) l -> lo <= ofs < hi -> False).

Theorem free_inject:
  forall f m1 l m1' m2 b lo hi m2',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) ->
    perm m1 b1 ofs k p -> lo <= ofs + delta < hi ->
    exists lo1, exists hi1, In (b1, lo1, hi1) l /\ lo1 <= ofs < hi1) ->
  inject f m1' m2'.

Theorem free_parallel_inject:
  forall f m1 m2 b lo hi m1' b' delta,
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  f b = Some(b', delta) ->
  exists m2',
     free m2 b' (lo + delta) (hi + delta) = Some m2'
  /\ inject f m1' m2'.

Lemma drop_outside_inject: forall f m1 m2 b lo hi p m2',
  inject f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma mem_inj_compose:
  forall f f' m1 m2 m3,
  mem_inj f m1 m2 -> mem_inj f' m2 m3 -> mem_inj (compose_meminj f f') m1 m3.

Theorem inject_compose:
  forall f f' m1 m2 m3,
  inject f m1 m2 -> inject f' m2 m3 ->
  inject (compose_meminj f f') m1 m3.

Lemma val_lessdef_inject_compose:
  forall f v1 v2 v3,
  Val.lessdef v1 v2 -> Val.inject f v2 v3 -> Val.inject f v1 v3.

Lemma val_inject_lessdef_compose:
  forall f v1 v2 v3,
  Val.inject f v1 v2 -> Val.lessdef v2 v3 -> Val.inject f v1 v3.

Lemma extends_inject_compose:
  forall f m1 m2 m3,
  extends m1 m2 -> inject f m2 m3 -> inject f m1 m3.

Lemma inject_extends_compose:
  forall f m1 m2 m3,
  inject f m1 m2 -> extends m2 m3 -> inject f m1 m3.

Lemma extends_extends_compose:
  forall m1 m2 m3,
  extends m1 m2 -> extends m2 m3 -> extends m1 m3.

Definition flat_inj (thr: block) : meminj :=
  fun (b: block) => if plt b thr then Some(b, 0) else None.

Definition inject_neutral (thr: block) (m: mem) :=
  mem_inj (flat_inj thr) m m.

Remark flat_inj_no_overlap:
  forall thr m, meminj_no_overlap (flat_inj thr) m.

Theorem neutral_inject:
  forall m, inject_neutral (nextblock m) m -> inject (flat_inj (nextblock m)) m m.

Theorem empty_inject_neutral:
  forall thr, inject_neutral thr empty.

Theorem alloc_inject_neutral:
  forall thr m lo hi b m',
  alloc m lo hi = (m', b) ->
  inject_neutral thr m ->
  Plt (nextblock m) thr ->
  inject_neutral thr m'.

Theorem store_inject_neutral:
  forall chunk m b ofs v m' thr,
  store chunk m b ofs v = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  Val.inject (flat_inj thr) v v ->

Theorem drop_inject_neutral:
  forall m b lo hi p m' thr,
  drop_perm m b lo hi p = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  inject_neutral thr m'.

Section UNCHANGED_ON.

Variable P: block -> Z -> Prop.

Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
  unchanged_on_nextblock:
    Ple (nextblock m_before) (nextblock m_after);
  unchanged_on_perm:
    forall b ofs k p,
    P b ofs -> valid_block m_before b ->
    (perm m_before b ofs k p <-> perm m_after b ofs k p);
  unchanged_on_contents:
    forall b ofs,
    P b ofs -> perm m_before b ofs Cur Readable ->
    ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
    ZMap.get ofs (PMap.get b m_before.(mem_contents))
}.

Lemma unchanged_on_refl:
  forall m, unchanged_on m m.

Lemma valid_block_unchanged_on:
  forall m m' b,
  unchanged_on m m' -> valid_block m b -> valid_block m' b.

Lemma perm_unchanged_on:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs ->
  perm m b ofs k p -> perm m' b ofs k p.

Lemma perm_unchanged_on_2:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs -> valid_block m b ->
  perm m' b ofs k p -> perm m b ofs k p.

Lemma unchanged_on_trans:
  forall m1 m2 m3, unchanged_on m1 m2 -> unchanged_on m2 m3 -> unchanged_on m1 m3.

Lemma loadbytes_unchanged_on_1:
  forall m m' b ofs n,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m' b ofs n = loadbytes m b ofs n.

Lemma loadbytes_unchanged_on:
  forall m m' b ofs n bytes,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m b ofs n = Some bytes ->
  loadbytes m' b ofs n = Some bytes.

Lemma load_unchanged_on_1:
  forall m m' chunk b ofs,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m' b ofs = load chunk m b ofs.

Lemma load_unchanged_on:
  forall m m' chunk b ofs v,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m b ofs = Some v ->
  load chunk m' b ofs = Some v.

Lemma store_unchanged_on:
  forall chunk m b ofs v m',
  store chunk m b ofs v = Some m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> ~ P b i) ->
  unchanged_on m m'.

Lemma storebytes_unchanged_on:
  forall m b ofs bytes m',
  storebytes m b ofs bytes = Some m' ->
  (forall i, ofs <= i < ofs + Z.of_nat (length bytes) -> ~ P b i) ->

Lemma alloc_unchanged_on:
  forall m lo hi m' b,
  alloc m lo hi = (m', b) ->
  unchanged_on m m'.

Lemma free_unchanged_on:
  forall m b lo hi m',
  free m b lo hi = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

Lemma drop_perm_unchanged_on:
  forall m b lo hi p m',
  drop_perm m b lo hi p = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

End UNCHANGED_ON.

Lemma unchanged_on_implies:
  forall (P Q: block -> Z -> Prop) m m',
  unchanged_on P m m' ->
  (forall b ofs, Q b ofs -> valid_block m b -> P b ofs) ->
  unchanged_on Q m m'.

End Mem.

Notation mem := Mem.mem.

Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.

Hint Resolve
  Mem.valid_not_valid_diff
  Mem.perm_implies
  Mem.perm_cur
  Mem.perm_max
  Mem.perm_valid_block
  Mem.range_perm_implies
  Mem.range_perm_cur
  Mem.range_perm_max
  Mem.valid_access_implies
  Mem.valid_access_valid_block
  Mem.valid_access_perm
  Mem.valid_access_load
  Mem.load_valid_access
  Mem.loadbytes_range_perm
  Mem.valid_access_store
  Mem.perm_store_1
  Mem.perm_store_2
  Mem.nextblock_store
  Mem.store_valid_block_1
  Mem.store_valid_block_2
  Mem.store_valid_access_1
  Mem.store_valid_access_2
  Mem.store_valid_access_3
  Mem.storebytes_range_perm
  Mem.perm_storebytes_1
  Mem.perm_storebytes_2
  Mem.storebytes_valid_access_1
  Mem.storebytes_valid_access_2
  Mem.nextblock_storebytes
  Mem.storebytes_valid_block_1
  Mem.storebytes_valid_block_2
  Mem.nextblock_alloc
  Mem.alloc_result
  Mem.valid_block_alloc
  Mem.fresh_block_alloc
  Mem.valid_new_block
  Mem.perm_alloc_1
  Mem.perm_alloc_2
  Mem.perm_alloc_3
  Mem.perm_alloc_4
  Mem.perm_alloc_inv
  Mem.valid_access_alloc_other
  Mem.valid_access_alloc_same
  Mem.valid_access_alloc_inv
  Mem.range_perm_free
  Mem.free_range_perm
  Mem.nextblock_free
  Mem.valid_block_free_1
  Mem.valid_block_free_2
  Mem.perm_free_1
  Mem.perm_free_2
  Mem.perm_free_3
  Mem.valid_access_free_1
  Mem.valid_access_free_2
  Mem.valid_access_free_inv_1
  Mem.valid_access_free_inv_2
  Mem.unchanged_on_refl
: mem. *)



Require Import VST.veric.compcert_rmaps.
(* VST.veric.compcert_rmaps:
Require Export VST.msl.msl_standard.
Require Import VST.veric.base.
Require Import compcert.cfrontend.Ctypes.
Require Import VST.veric.shares.
Require Import VST.veric.rmaps.
Require Import VST.veric.rmaps_lemmas.
Require Export VST.veric.Memory. 

Instance EqDec_type: EqDec type := type_eq.

Definition funsig := (list (ident*type) * type)%type. 

Inductive kind : Type := VAL : memval -> kind
                                   | LK : forall n i : Z, kind
                                   | FUN: funsig -> calling_convention -> kind.

Definition isVAL (k: kind) := match k with | VAL _ => True | _ => False end.
Definition isFUN (k: kind) := match k with | FUN _ _ => True | _ => False end.

Lemma isVAL_i: forall v, isVAL (VAL v).
Hint Resolve isVAL_i.

Lemma isVAL_dec: forall k, {isVAL k}+{~isVAL k}.

Module CompCert_AV <: ADR_VAL.

Definition address := address.
Definition some_address : address := (xH,0).
Definition kind := kind.

End CompCert_AV.

Lemma getVAL: forall k, {v : memval & k = VAL v}  + {~isVAL k}.

Lemma VAL_inj: forall v v', VAL v = VAL v' -> v = v'.

Module R := Rmaps (CompCert_AV).
Module RML := Rmaps_Lemmas(R).

Export RML.
Export R.

Definition mk_rshare: forall p: Share.t, pure_readable_share p -> rshare := exist pure_readable_share.
Definition rshare_sh (p: rshare) : Share.t := proj1_sig p.

Lemma mk_rshare_sh: forall (p:rshare) (H: pure_readable_share (rshare_sh p)),
  mk_rshare (rshare_sh p) H = p.

Definition fixup_splitting
  (a:address -> Share.t) (z: address -> option (rshare * kind)) : address -> option (rshare * kind) :=
  fun l => 
    match z l with
    | Some (sh, k) =>
       match dec_readable (a l) with
       | left p => Some (readable_part p,  k)
       | right _ => None
       end
    | None => None
    end.

Definition share_of (x: option (rshare * kind)) : Share.t :=
  match x with Some (p,_) => proj1_sig p | None => Share.bot end.

Definition Join_pk := (Join_lower (Join_prod rshare _ kind (Join_equiv _))).

Lemma share_of_Some: forall p: rshare * AV.kind, readable_share (share_of (Some p)).

Lemma join_sub_same_k:
 forall {a a' : rshare} {k k': AV.kind},

Lemma pure_readable_glb_Rsh:
 forall sh, pure_readable_share sh -> Share.glb Share.Rsh sh = sh.

Lemma join_glb_Rsh:  
  forall a b c : Share.t,

Lemma pure_readable_share_glb:
  forall a, pure_readable_share a -> Share.glb Share.Rsh a = a.

Lemma glb_Rsh_bot_unreadable:
  forall a, Share.glb Share.Rsh a = Share.bot -> ~readable_share a.

Lemma fixup_join : forall a (ac ad: address -> Share.t)  z,

Lemma join_share_of: forall a b c,
     @join _ Join_pk a b c -> join (share_of a) (share_of b) (share_of c).

Lemma pure_readable_share_i:
  forall sh, readable_share sh -> (pure_readable_share (Share.glb Share.Rsh sh)).

Obligation Tactic := Tactics.program_simpl.

Lemma pure_readable_Rsh: pure_readable_share Share.Rsh.

Definition rfullshare : rshare := mk_rshare _ pure_readable_Rsh.

Program Definition writable (l: address): pred rmap :=
 fun phi =>
  match phi @ l with
    | YES sh _ k lp => writable0_share sh /\ isVAL k
    | _ => False
  end.

Program Definition readable (loc: address) : pred rmap :=
   fun phi => match phi @ loc with YES _ _ k _ => isVAL k | _ => False end.

Lemma readable_join:
  forall phi1 phi2 phi3 loc, join phi1 phi2 phi3 ->
            readable loc phi1 -> readable loc phi3.

Lemma readable_writable_join:
forall phi1 phi2 l, readable l phi1 -> writable l phi2 -> joins phi1 phi2 -> False.

Lemma writable0_join_sub:
  forall sh sh', join_sub sh sh' -> writable0_share sh -> writable0_share sh'.

Lemma writable_join: forall loc phi1 phi2, join_sub phi1 phi2 ->
            writable loc phi1 -> writable loc phi2.

Lemma writable_readable: forall loc m, writable loc m -> readable loc m.

Lemma writable_e: forall loc m, 
   writable loc m -> 
   exists sh, exists rsh, exists v, exists p, 
     m @ loc = YES sh rsh (VAL v) p /\ writable0_share sh.
Arguments writable_e [loc] [m] _.

Lemma readable_e: forall loc m, 
   readable loc m -> 
  exists sh, exists rsh, exists v, exists p, m @ loc = YES sh rsh (VAL v) p.
Arguments readable_e [loc] [m] _.

Definition bytes_writable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> writable (adr_add loc i) phi.

Definition bytes_readable (loc: address) (size: Z) (phi: rmap) : Prop :=
  forall i, (0 <= i < size) -> readable (adr_add loc i) phi.

Lemma readable_dec (loc: address) (phi: rmap) : {readable loc phi} + {~readable loc phi}.

Lemma writable_dec: forall loc phi, {writable loc phi}+{~writable loc phi}.

Lemma bytes_writable_dec:
   forall loc n m, {bytes_writable loc n m}+{~bytes_writable loc n m}.

Lemma bytes_readable_dec:
   forall loc n m, {bytes_readable loc n m}+{~bytes_readable loc n m}.

Lemma bytes_writable_readable:
  forall m loc n, bytes_writable m loc n -> bytes_readable m loc n.

Hint Resolve bytes_writable_readable : mem.

Lemma rmap_age_i:
 forall w w' : rmap,
    level w = S (level w') ->
   (forall l, resource_fmap (approx (level w')) (approx (level w')) (w @ l) = w' @ l) ->
    ghost_fmap (approx (level w')) (approx (level w')) (ghost_of w) = ghost_of w' ->
    age w w'. *)

Require Import VST.veric.juicy_mem.
(* VST.veric.juicy_mem:
Require Import VST.veric.base.
Require Import VST.veric.Memory.
Require Import VST.veric.juicy_base.
Require Import VST.veric.shares.
Import cjoins.

Definition dec_share_nonidentity (sh: Share.t) : {~identity sh}+{identity sh} :=
   (Sumbool.sumbool_not _ _ (dec_share_identity sh)).

Definition perm_of_sh (sh: Share.t): option permission :=
  if writable0_share_dec sh
  then if eq_dec sh Share.top
            then Some Freeable
            else Some Writable
    else if readable_share_dec sh
         then Some Readable
         else if eq_dec sh Share.bot
                   then None
              else Some Nonempty.
Functional Scheme perm_of_sh_ind := Induction for perm_of_sh Sort Prop.

Definition contents_at (m: mem) (loc: address) : memval :=
  ZMap.get (snd loc) (PMap.get (fst loc) (mem_contents m)).

Definition contents_cohere (m: mem) (phi: rmap) :=
  forall rsh sh v loc pp, phi @ loc = YES rsh sh (VAL v) pp -> contents_at m loc = v /\ pp=NoneP.

Definition valshare (r: resource) : share :=
    match r with
      | YES sh rsh _ _ => Share.glb Share.Rsh sh
      | _ => Share.bot
    end.

Definition res_retain' (r: resource) : Share.t :=
 match r with
  | NO sh _ => sh
  | YES sh _ _ _ => Share.glb Share.Lsh sh
  | PURE _ _ => Share.top
 end.

Definition perm_of_res (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh rsh (VAL _) _ => perm_of_sh sh
 | YES sh rsh _ _ => Some Nonempty
 end.

Definition perm_of_res_lock_explicit
             (r : compcert_rmaps.RML.R.resource):=
    match r with
    | compcert_rmaps.RML.R.NO _ _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ =>
      if writable0_share_dec (Share.glb Share.Rsh sh)
      then if eq_dec (Share.glb Share.Rsh sh) Share.top then Some Freeable else Some Writable
      else if readable_share_dec (Share.glb Share.Rsh sh) then Some Readable else
             if eq_dec  (Share.glb Share.Rsh sh) Share.bot then None else Some Nonempty
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => None
    | compcert_rmaps.RML.R.PURE _ _ => None
    end.
      
  Functional Scheme perm_of_res_lock_expl_ind := Induction for perm_of_res_lock_explicit Sort Prop.

Definition perm_of_res' (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh _ _ _ => perm_of_sh sh
 end.

Definition perm_of_res_lock (r: resource) := 
  
 match r with
 | YES sh rsh (LK _ _) _ => perm_of_sh (Share.glb Share.Rsh sh)
 | _ => None 
 end.

Definition perm_of_res_explicit
               (r : compcert_rmaps.RML.R.resource):=
        match r with
        | compcert_rmaps.RML.R.NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ =>
             if writable0_share_dec sh
             then if eq_dec sh Share.top then Some Freeable else Some Writable
             else
               if readable_share_dec sh
               then Some Readable
               else if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.PURE _ _ => Some Nonempty
        end.
      
Functional Scheme perm_of_res_expl_ind := Induction for perm_of_res_explicit Sort Prop.

Lemma Rsh_not_top: Share.Rsh <> Share.top.

Lemma nonidentity_Rsh: ~identity Share.Rsh.

Lemma perm_of_sh_fullshare: perm_of_sh fullshare = Some Freeable.

Lemma nonreadable_extern_retainer: ~readable_share extern_retainer.

Lemma Lsh_nonreadable: ~readable_share Share.Lsh.

Lemma perm_of_res_op1:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res r).

Lemma perm_of_res_op2:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res_lock r).

Definition access_cohere (m: mem)  (phi: rmap) :=
  forall loc,  access_at m loc Cur = perm_of_res (phi @ loc).

Definition max_access_at m loc := access_at m loc Max.

Definition max_access_cohere (m: mem) (phi: rmap)  :=
  forall loc,
    perm_order'' (max_access_at m loc) (perm_of_res' (phi @ loc)).

Definition alloc_cohere (m: mem) (phi: rmap) :=
 forall loc,  (fst loc >= nextblock m)%positive -> phi @ loc = NO Share.bot bot_unreadable.

Inductive juicy_mem: Type :=
  mkJuicyMem: forall (m: mem) (phi: rmap)
    (JMcontents: contents_cohere m phi)
    (JMaccess: access_cohere m phi)
    (JMmax_access: max_access_cohere m phi)
    (JMalloc: alloc_cohere m phi),
       juicy_mem.

Section selectors.
Variable (j: juicy_mem).
Definition m_dry := match j with mkJuicyMem m _ _ _ _ _ => m end.
Definition m_phi := match j with mkJuicyMem _ phi _ _ _ _ => phi end.
Lemma juicy_mem_contents: contents_cohere m_dry m_phi.
Lemma juicy_mem_access: access_cohere m_dry m_phi.
Lemma juicy_mem_max_access: max_access_cohere m_dry m_phi.
Lemma juicy_mem_alloc_cohere: alloc_cohere m_dry m_phi.
End selectors.

Definition juicy_mem_resource: forall jm m', resource_at m' = resource_at (m_phi jm) ->
  {jm' | m_phi jm' = m' /\ m_dry jm' = m_dry jm}.

Lemma perm_of_empty_inv {s} : perm_of_sh s = None -> s = Share.bot.

Lemma writable_join_sub: forall loc phi1 phi2,
  join_sub phi1 phi2 -> writable loc phi1 -> writable loc phi2.

Lemma writable_inv: forall phi loc, writable loc phi ->
  exists sh, exists rsh, exists k, exists pp, 
       phi @ loc = YES sh rsh k pp /\ 
       writable0_share sh /\
       isVAL k.

Lemma nreadable_inv: forall phi loc, ~readable loc phi 
  -> (exists sh, exists nsh, phi @ loc = NO sh nsh)
   \/ (exists sh, exists rsh, exists k, exists pp, phi @ loc = YES sh rsh k pp /\ ~isVAL k)
   \/ (exists k, exists pp, phi @ loc = PURE k pp).

Lemma age1_joinx {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3 phi1' phi2' phi3',
             age phi1 phi1' -> age phi2 phi2' -> age phi3 phi3' ->
             join phi1 phi2 phi3 -> join phi1' phi2' phi3'.

Lemma constructive_age1_join  {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall x y z x' : A,
       join x y z ->
       age x x' ->
       { yz' : A*A | join x' (fst yz') (snd yz') /\ age y (fst yz') /\ age z (snd yz')}.

Lemma age1_constructive_joins_eq : forall {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}  {phi1 phi2},
  constructive_joins phi1 phi2
  -> forall {phi1'}, age1 phi1 = Some phi1'
  -> forall {phi2'}, age1 phi2 = Some phi2'
  -> constructive_joins phi1' phi2'.

Program Definition age1_juicy_mem (j: juicy_mem): option juicy_mem :=
      match age1 (m_phi j) with
        | Some phi' => Some (mkJuicyMem (m_dry j) phi' _ _ _ _)
        | None => None
      end.

Lemma age1_juicy_mem_unpack: forall j j',
  age1_juicy_mem j = Some j' ->
  age (m_phi j)  (m_phi j')
  /\ m_dry j = m_dry j'.

Lemma age1_juicy_mem_unpack': forall j j',
  age (m_phi j)  (m_phi j')  /\ m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma age1_juicy_mem_unpack'': forall j j',
  age (m_phi j)  (m_phi j')  -> m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma rmap_join_eq_level: forall phi1 phi2: rmap, joins phi1 phi2 -> level phi1 = level phi2.

Lemma rmap_join_sub_eq_level: forall phi1 phi2: rmap,
          join_sub phi1 phi2 -> level phi1 = level phi2.

Lemma age1_juicy_mem_None1:
  forall j, age1_juicy_mem j = None -> age1 (m_phi j) = None.

Lemma age1_juicy_mem_None2:
  forall j, age1 (m_phi j) = None -> age1_juicy_mem j = None.

Lemma age1_juicy_mem_Some:
  forall j j', age1_juicy_mem j = Some j' -> age1 (m_phi j) = Some (m_phi j').

Lemma unage_juicy_mem: forall j' : juicy_mem,
   exists j : juicy_mem, age1_juicy_mem j = Some j'.

Lemma level1_juicy_mem: forall j: juicy_mem,
  age1_juicy_mem j = None <-> level (m_phi j) = 0%nat.

Lemma level2_juicy_mem: forall j1 j2: juicy_mem,
   age1_juicy_mem j1 = Some j2 -> level (m_phi j1) = S (level (m_phi j2)).

Lemma juicy_mem_ageable_facts: ageable_facts juicy_mem (fun j => level (m_phi j)) age1_juicy_mem.

Instance juicy_mem_ageable: ageable juicy_mem :=
  mkAgeable _ (fun j => level (m_phi j)) age1_juicy_mem juicy_mem_ageable_facts.

Lemma level_juice_level_phi: forall (j: juicy_mem), level j = level (m_phi j).

Lemma juicy_mem_ext: forall j1 j2,
       m_dry j1 = m_dry j2  ->
       m_phi j1 = m_phi j2 ->
       j1=j2.

Lemma unage_writable: forall (phi phi': rmap) loc,
  age phi phi' -> writable loc phi' -> writable loc phi.

Lemma unage_readable: forall (phi phi': rmap) loc,
  age phi phi' -> readable loc phi' -> readable loc phi.

Lemma readable_inv: forall phi loc, readable loc phi ->
  exists rsh, exists sh, exists v, exists pp, phi @ loc = YES rsh sh (VAL v) pp.

Definition fmap_option {A B} (v: option A) (m: B) (f: A -> B): B :=
  match v with
    | None => m
    | Some v' => f v'
  end.

Lemma resource_at_make_rmap: forall f g lev H Hg, resource_at (proj1_sig (make_rmap f g lev H Hg)) = f.

Lemma resource_at_remake_rmap: forall f g lev H Hg, resource_at (proj1_sig (remake_rmap f g lev H Hg)) = f.

Lemma ghost_of_make_rmap: forall f g lev H Hg, ghost_of (proj1_sig (make_rmap f g lev H Hg)) = g.

Lemma ghost_of_remake_rmap: forall f g lev H Hg, ghost_of (proj1_sig (remake_rmap f g lev H Hg)) = g.

Lemma level_make_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (make_rmap f g lev H Hg)) = lev.

Lemma level_remake_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (remake_rmap f g lev H Hg)) = lev.

Section inflate.
Variables (m: mem) (phi: rmap).

Definition inflate_initial_mem' (w: rmap) (loc: address) :=
   match access_at m loc Cur with
           | Some Freeable => YES Share.top readable_share_top (VAL (contents_at m loc)) NoneP
           | Some Writable => YES Ews (writable_readable writable_Ews) (VAL (contents_at m loc)) NoneP
           | Some Readable => YES Ers readable_Ers (VAL (contents_at m loc)) NoneP
           | Some Nonempty => 
                         match w @ loc with PURE _ _ => w @ loc | _ => NO _ nonreadable_extern_retainer end
           | None =>  NO Share.bot bot_unreadable
         end.

Lemma inflate_initial_mem'_fmap:
 forall w, resource_fmap (approx (level w)) (approx (level w)) oo inflate_initial_mem' w =
                inflate_initial_mem' w.

Definition inflate_initial_mem (w: rmap): rmap :=
    proj1_sig (make_rmap (inflate_initial_mem' w) (ghost_of w) _
            (inflate_initial_mem'_fmap w) (ghost_of_approx w)).

Lemma inflate_initial_mem_level: forall w, level (inflate_initial_mem w) = level w.

Definition all_VALs (phi: rmap) :=
  forall l, match phi @ l with
              | YES _ _ k _ => isVAL k
              | _ => True
            end.

Lemma inflate_initial_mem_all_VALs: forall lev, all_VALs (inflate_initial_mem lev).

Definition inflate_alloc: rmap.

Lemma approx_map_idem: forall n (lp: preds),
  preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) lp) =
  preds_fmap (approx n) (approx n) lp.

Definition inflate_store: rmap. refine (

End inflate.

Lemma adr_inv0: forall (b b': block) (ofs ofs': Z) (sz: Z),
  ~ adr_range (b, ofs) sz (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + sz.

Lemma adr_inv: forall (b b': block) (ofs ofs': Z) ch,
  ~ adr_range (b, ofs) (size_chunk ch) (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + size_chunk ch.

Lemma range_inv0: forall ofs ofs' sz,
  ~ ofs <= ofs' < ofs + sz ->
  ofs' < ofs \/ ofs' >= ofs + sz.

Lemma range_inv: forall ofs ofs' ch,
  ~ ofs <= ofs' < ofs + size_chunk ch ->
  ofs' < ofs \/ ofs' >= ofs + size_chunk ch.

Lemma perm_of_sh_Freeable_top: forall sh, perm_of_sh sh = Some Freeable -> 
     sh = Share.top.

Lemma nextblock_access_empty: forall m b ofs k, (b >= nextblock m)%positive
  -> access_at m (b, ofs) k = None.

Section initial_mem.
Variables (m: mem) (w: rmap).

Definition initial_rmap_ok := 
   forall loc, ((fst loc >= nextblock m)%positive -> core w @ loc = NO Share.bot bot_unreadable) /\
                   (match w @ loc with 
                    | PURE _ _ => (fst loc < nextblock m)%positive /\ 
                                           access_at m loc Cur = Some Nonempty /\  
                                            max_access_at m loc = Some Nonempty 
                    | _ => True end).
Hypothesis IOK: initial_rmap_ok.
End initial_mem.

Definition empty_retainer (loc: address) := Share.bot.

Lemma perm_of_freeable: perm_of_sh Share.top = Some Freeable.

Lemma perm_of_writable: 
   forall sh, writable_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

Lemma perm_of_readable:
  forall sh (rsh: readable_share sh), ~writable0_share sh -> perm_of_sh sh = Some Readable.

Lemma perm_of_nonempty:
  forall sh, sh <> Share.bot -> ~readable_share sh -> perm_of_sh sh = Some Nonempty.

Lemma perm_of_empty:
    perm_of_sh Share.bot = None.

Lemma perm_of_Ews: perm_of_sh Ews = Some Writable.

Lemma perm_of_Ers: perm_of_sh Ers = Some Readable.

Lemma extern_retainer_neq_bot: extern_retainer <> Share.bot.

Lemma perm_order''_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Definition initial_mem (m: mem) lev (IOK: initial_rmap_ok m lev) : juicy_mem.

Definition juicy_mem_level (j: juicy_mem) (lev: nat) :=
  level (m_phi j) = lev.

Lemma initial_mem_level: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_level j (level lev).

Lemma initial_mem_all_VALs: forall lev m j IOK, j = initial_mem m lev IOK
  -> all_VALs (m_phi j).

Lemma perm_mem_access: forall m b ofs p,
  perm m b ofs Cur p ->
  exists p', (perm_order p' p /\ access_at m (b, ofs) Cur = Some p').

Section store.
Variables (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m').

Lemma store_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (size_chunk ch) loc'
  -> (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP -> contents_at m' loc' = mv.

Definition store_juicy_mem: juicy_mem.

End store.

Section storebytes.
Variables (jm: juicy_mem) (m': mem) (b: block) (ofs: Z) (bytes: list memval)
  (STOREBYTES: storebytes (m_dry jm) b ofs bytes = Some m').

Lemma storebytes_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (Zlength bytes) loc' ->
  (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP ->
  contents_at m' loc' = mv.

Definition storebytes_juicy_mem: juicy_mem.

End storebytes.

Lemma free_smaller_None : forall m b b' ofs lo hi m',
  access_at m (b, ofs) Cur = None
  -> free m b' lo hi = Some m'
  -> access_at m' (b, ofs) Cur = None.

Lemma free_nadr_range_eq : forall m b b' ofs' lo hi m',
  ~ adr_range (b, lo) (hi - lo) (b', ofs')
  -> free m b lo hi = Some m'
  -> access_at m (b', ofs') = access_at m' (b', ofs')
  /\  contents_at m (b', ofs') = contents_at m' (b', ofs').

Section free.
Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable).

Definition inflate_free: rmap. refine (

Definition free_juicy_mem: juicy_mem.

End free.

Lemma free_not_freeable_eq : forall m b lo hi m' b' ofs',
  free m b lo hi = Some m'
  -> access_at m (b', ofs') Cur <> Some Freeable
  -> access_at m (b', ofs') Cur = access_at m' (b', ofs') Cur.

Definition after_alloc' 
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else phi @ loc.

Lemma adr_range_eq_block : forall b ofs n b' ofs',
  adr_range (b,ofs) n (b',ofs') ->
  b=b'.

Lemma after_alloc'_ok : forall lo hi b phi H,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (after_alloc' lo hi b phi H)
  = after_alloc' lo hi b phi H.

Definition after_alloc
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable) : rmap :=
  proj1_sig (make_rmap (after_alloc' lo hi b phi H) (ghost_of phi)
    (level phi)
    (after_alloc'_ok lo hi b phi H) (ghost_of_approx phi)).

Definition mod_after_alloc' (phi: rmap) (lo hi: Z) (b: block)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else core phi @ loc.

Lemma mod_after_alloc'_ok : forall phi lo hi b,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (mod_after_alloc'  phi lo hi b)
  = mod_after_alloc' phi lo hi b.

Definition mod_after_alloc (phi: rmap) (lo hi: Z) (b: block) :=
  proj1_sig (make_rmap (mod_after_alloc' phi lo hi b) (ghost_of phi)
    _
    (mod_after_alloc'_ok phi lo hi b) (ghost_of_approx phi)).

Transparent alloc.

Lemma adr_range_inv: forall loc loc' n,
  ~ adr_range loc n loc' ->
  fst loc <> fst loc' \/ (fst loc=fst loc' /\ ~snd loc <= snd loc' < snd loc + n).

Lemma dry_noperm_juicy_nonreadable : forall m loc,
  access_at (m_dry m) loc Cur = None ->   ~readable loc (m_phi m).

Lemma fullempty_after_alloc : forall m1 m2 lo n b ofs,
  alloc m1 lo n = (m2, b) ->
  access_at m2 (b, ofs) Cur = None \/ access_at m2 (b, ofs) Cur = Some Freeable.

Lemma alloc_dry_unchanged_on : forall m1 m2 loc lo hi b0,
  alloc m1 lo hi = (m2, b0) ->
  ~adr_range (b0,lo) (hi-lo) loc ->
  access_at m1 loc = access_at m2 loc /\
  (access_at m1 loc Cur <> None -> contents_at m1 loc= contents_at m2 loc).

Lemma adr_range_zle_fact : forall b lo hi loc,
  adr_range (b,lo) (hi-lo) loc ->
  zle lo (snd loc) && zlt (snd loc) hi = true.

Lemma alloc_dry_updated_on : forall m1 m2 lo hi b loc,
  alloc m1 lo hi = (m2, b) ->
  adr_range (b, lo) (hi - lo) loc ->
  access_at m2 loc Cur=Some Freeable /\
  contents_at m2 loc=Undef.

Definition resource_decay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
 forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = 
                       YES sh (writable0_readable wsh) (VAL v) NoneP /\ 
       phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)
  \/ ((fst l >= nextb)%positive /\ exists v, phi2 @ l = YES Share.top readable_share_top (VAL v) NoneP)
  \/ (exists v, exists pp, phi1 @ l = YES Share.top readable_share_top (VAL v) pp 
                        /\ phi2 @ l = NO Share.bot bot_unreadable)).

Definition resource_nodecay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
  forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = YES sh (writable0_readable wsh) (VAL v) NoneP
      /\ phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)).

Lemma resource_nodecay_decay:
   forall b phi1 phi2, resource_nodecay b phi1 phi2 -> resource_decay b phi1 phi2.

Lemma resource_decay_refl: forall b phi, 
  (forall l, (fst l >= b)%positive -> phi @ l = NO Share.bot bot_unreadable) ->

Lemma resource_decay_trans: forall b b' m1 m2 m3,
  (b <= b')%positive ->
  resource_decay b m1 m2 -> resource_decay b' m2 m3 -> resource_decay b m1 m3.

Lemma level_store_juicy_mem:
 forall jm m ch b i v H, level (store_juicy_mem jm m ch b i v H) = level jm.

Lemma level_storebytes_juicy_mem:
 forall jm m b i bytes H, level (storebytes_juicy_mem jm m b i bytes H) = level jm.

Lemma inflate_store_resource_nodecay:
  forall (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable))
          phi',
  inflate_store m' (m_phi jm) = phi' -> resource_nodecay (nextblock (m_dry jm)) (m_phi jm) phi'.

Lemma inflate_free_resource_decay:
 forall (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs : Z,
             lo <= ofs < hi -> perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),
   resource_decay (nextblock (m_dry jm)) (m_phi jm) (inflate_free jm b lo hi).

Lemma juicy_store_nodecay:
  forall jm m' ch b ofs v
       (H: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable)),
       resource_nodecay (nextblock (m_dry jm)) (m_phi jm) (m_phi (store_juicy_mem jm _ _ _ _ _ H)).

Lemma can_age1_juicy_mem: forall j r,
  age (m_phi j) r -> exists j', age1 j = Some j'.

Lemma can_age_jm:
  forall jm, age1 (m_phi jm) <> None -> exists jm', age jm jm'.

Lemma age_jm_dry: forall {jm jm'}, age jm jm' -> m_dry jm = m_dry jm'.

Lemma age_jm_phi: forall {jm jm'}, age jm jm' -> age (m_phi jm) (m_phi jm').

Lemma age1_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma age1_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma age1_PURE_2 {phi phi' l k P} :
  age1 phi = Some phi' ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma perm_of_res_age x y loc :
  age x y -> perm_of_res (x @ loc) = perm_of_res (y @ loc).

Lemma contents_cohere_age m : hereditary age (contents_cohere m).

Lemma access_cohere_age m : hereditary age (access_cohere m).

Lemma max_access_cohere_age m : hereditary age (max_access_cohere m).

Lemma alloc_cohere_age m : hereditary age (alloc_cohere m).

Definition unage {A} {_:ageable A} x y := age y x.

Lemma unage_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma unage_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma unage_PURE_2 {phi phi' l k P} :
  age1 phi' = Some phi ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma contents_cohere_unage m : hereditary unage (contents_cohere m).

Lemma access_cohere_unage m : hereditary unage (access_cohere m).

Lemma max_access_cohere_unage m : hereditary unage (max_access_cohere m).

Lemma alloc_cohere_unage m : hereditary unage (alloc_cohere m).

Lemma juicy_mem_unage jm' : { jm | age jm jm' }. *)

Require Import VST.veric.res_predicates.
(* VST.veric.res_predicates:
Require Import VST.msl.log_normalize.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.  
Require Import VST.veric.shares. 
Require Import VST.veric.address_conflict.

Import RML. Import R.
Local Open Scope pred.

Program Definition kind_at (k: kind) (l: address) : pred rmap :=
   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.

Program Definition yesat_raw (pp: preds) (k: kind) 
                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=
   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

Obligation Tactic := idtac.

Program Definition yesat (pp: preds) (k: kind) : spec :=
 fun (sh: share) (l: AV.address) (m: rmap) =>

Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

Ltac do_map_arg :=
match goal with |- ?a = ?b =>
  match a with context [map ?x _] =>
    match b with context [map ?y _] => replace y with x; auto end end end.

Lemma yesat_raw_eq_aux:
  forall pp k rsh sh l,
    hereditary age
    (fun phi : rmap =>
     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Lemma yesat_raw_eq: yesat_raw =
  fun pp k rsh sh l =>
  ((exist (hereditary age)
   (fun phi =>
   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))
   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Lemma yesat_eq_aux: 
  forall pp k sh l, 
    hereditary age
    (fun m : rmap =>
      exists rsh, 
     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =
     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Lemma yesat_eq: yesat = fun pp k sh l =>
 exist (hereditary age)
  (fun m => 
  exists rsh, 
   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 
   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))
   (yesat_eq_aux pp k sh l).

Lemma map_compose_approx_succ_e:
  forall A n pp pp',
       map (compose (A:=A) (approx (S n))) pp =
    map (compose (A:=A) (approx (S n))) pp' ->
  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Program Definition noat (l: AV.address) : pred rmap :=

Definition resource_share (r: resource) : option share :=
 match r with
 | YES sh _ _ _ => Some sh
 | NO sh _ => Some sh
 | PURE _ _ => None
 end.

Definition nonlock (r: resource) : Prop :=
 match r with
 | YES _ _ k _ => isVAL k \/ isFUN k
 | NO _ _ => True
 | PURE _ _ => False
 end.

Lemma age1_nonlock: forall phi phi' l,
  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Lemma age1_resource_share: forall phi phi' l,
  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  join sh1 sh2 sh ->
  resource_share r = Some sh.

Lemma resource_share_joins: forall r1 r2 sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  joins r1 r2 ->
  joins sh1 sh2.

Lemma nonlock_join: forall r1 r2 r,
  nonlock r1 ->
  nonlock r2 ->
  join r1 r2 r ->
  nonlock r.

Program Definition nonlockat (l: AV.address): pred rmap :=

Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=
  fun (l: B) m => if S l then P l m else Q l m.

Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,
      (forall (x: A), boxy m (P x)) ->
      (forall x, boxy m (Q x)) ->
      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),
      (forall (x: A), boxy extendM (P x)) ->
      (forall x, boxy extendM (Q x)) ->
      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Definition jam_vacuous:
  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),
  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  {w' | level w' = level w /\ resource_at w' =
       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=
  forall l w, (p l) w = q (w @ l) l (level w).

Definition resource_stable (p: address -> pred rmap) :=
  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.

Lemma is_resource_pred_resource_stable: forall {p},
  (exists q, is_resource_pred p q) -> resource_stable p.

Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l})
  (R_DEC: forall l, {R l} + {~ R l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (exists resp, is_resource_pred r resp) ->
  Ensemble_join Q R P ->
  (forall l, Q l -> p l = q l) ->
  (forall l, R l -> p l = r l) ->
  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  allp (jam P_DEC p noat) && noghost =
  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->
  (exists l, P l /\ Q l) ->
  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Lemma yesat_join_diff:
  forall pp pp' k k' sh sh' l w, k <> k' -> 
                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Lemma yesat_raw_join:
  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),
  nonunit x -> join x y z -> nonunit z.

Lemma yesat_join:
  forall pp k sh1 sh2 sh3 l m1 m2 m3,
   join sh1 sh2 sh3 ->   
   yesat pp k sh1 l m1 ->
   yesat pp k sh2 l m2 ->
   join m1 m2 m3 ->
   yesat pp k sh3 l m3.

Definition spec_parametric (Q: address -> spec) : Prop :=
   forall l l', exists pp, exists ok,
             forall sh m,
           Q l sh l' m = 
            (exists p, exists k, ok k /\ m @ l' = 
                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).

Lemma YES_ext:
  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Definition VALspec : spec :=
       fun (sh: Share.t) (l: address) =>
          allp (jam (eq_dec l)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat) && noghost.

Definition VALspec_range (n: Z) : spec :=
     fun (sh: Share.t) (l: address) =>
          andp (allp (jam (adr_range_dec l n)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat)) noghost.

Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=
  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.

Definition nthbyte (n: Z) (l: list memval) : memval :=
     nth (nat_of_Z n) l Undef.

Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address)  => 
             allp (jam (adr_range_dec l (size_chunk ch)) 
                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')
                           noat).

Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address) =>
           EX bl: list memval, 
               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&
                (allp (jam (adr_range_dec l (size_chunk ch))
                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)
                                    noat)) && noghost.

Lemma address_mapsto_align: forall ch v sh l,
  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Lemma address_mapsto_fun:
  forall ch sh sh' l v v',
          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Definition LKspec lock_size (R: pred rmap) : spec :=
   fun (sh: Share.t) (l: AV.address)  =>
    allp (jam (adr_range_dec l lock_size)
               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')
               noat) && noghost.

Definition TTat (l: address) : pred rmap := TT.

Lemma address_mapsto_old_parametric: forall ch v, 
   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Lemma VALspec_parametric: 
  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Lemma LKspec_parametric lock_size: forall R: pred rmap,
  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Definition val2address (v: val) : option AV.address := 
  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.

Lemma VALspec_readable:
  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.

Lemma address_mapsto_VALspec:
  forall ch v sh l i, 0 <= i < size_chunk ch ->
        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Lemma address_mapsto_exists:
  forall ch v sh (rsh: readable_share sh) loc w0
      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

Lemma VALspec1: VALspec_range 1 = VALspec.

Lemma VALspec_range_exp_address_mapsto:
  forall ch sh l,
    (align_chunk ch | snd l) ->
    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Lemma address_mapsto_VALspec_range:
  forall ch v sh l,
        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Lemma approx_eq_i:
  forall (P Q: pred rmap) (w: rmap),
      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},
         laterR (level w) n' ->
       exists w', laterR w w' /\ n' = level w'.

Lemma VALspec_range_bytes_readable:
  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Lemma VALspec_range_bytes_writable:
  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Lemma yesat_join_sub:
  forall pp k l sh m m',
          join_sub m m' ->
          yesat pp k sh l m ->
         exists sh', yesat pp k sh' l m'.

Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Lemma nonlock_permission_bytes_precise: forall sh p n,
  precise (nonlock_permission_bytes sh p n).

Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=
  EX bl: list memval,
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)
  : pred rmap :=
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.
Hint Resolve VALspec_range_0: normalize.

Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,
  ~ nonunit sh ->
  nonlock_permission_bytes sh p n |-- emp.

Lemma is_resource_pred_YES_VAL sh:
  is_resource_pred
    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')
    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_YES_VAL' sh v:
  is_resource_pred
    (fun l' => yesat NoneP (VAL (v l')) sh l')
    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_nonlock_shareat sh:
  is_resource_pred
    (fun i : address => shareat i sh && nonlockat i)
    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Lemma VALspec_range_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma nonlock_permission_bytes_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma VALspec_range_VALspec:
  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,
  adr_range p1 n1 p2 ->
  n2 > 0 ->
  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Lemma address_mapsto_overlap':
  forall sh ch1 v1 ch2 v2 a1 a2,
     adr_range a1 (size_chunk ch1) a2 ->
     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,
  range_overlap l1 n1 l2 n2 ->
  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,
  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->
  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Lemma nonlock_permission_bytes_overlap:
  forall sh n1 n2 p1 p2,
  nonunit sh ->
  range_overlap p1 n1 p2 n2 ->
  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Lemma address_mapsto_value_cohere':
  forall ch v1 v2 sh1 sh2 a r
 (Hmaps1 : address_mapsto ch v1 sh1 a r)
 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Lemma address_mapsto_value_cohere:
  forall ch v1 v2 sh1 sh2 a,
 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Definition almost_empty rm: Prop:=
  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.

Definition no_locks phi :=
  forall addr sh sh' z z' P,
phi @ addr <> YES sh sh' (LK z z') P. *)



Require Import VST.concurrency.common.threadPool. Import addressFiniteMap.
(* VST.concurrency.common.threadPool:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.

Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.threads_lemmas.
Require Import compcert.lib.Axioms.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
Require Import VST.msl.Coqlib2.

Require Import VST.concurrency.common.lksize.

Set Implicit Arguments.

Inductive ctl {cT:Type} : Type :=
| Krun : cT -> ctl
| Kblocked : cT -> ctl
| Kresume : cT -> val -> ctl 
| Kinit : val -> val -> ctl. 

Definition EqDec: Type -> Type :=
  fun A : Type => forall a a' : A, {a = a'} + {a <> a'}.

Module ThreadPool.
  Section ThreadPool.

    Context {resources: Resources}.
    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Class ThreadPool :=
      { t : Type;
        mkPool : ctl -> res -> t;
        containsThread : t -> tid -> Prop;
        getThreadC : forall {tid tp}, containsThread tp tid -> ctl;
        getThreadR : forall {tid tp}, containsThread tp tid -> res;
        resourceList : t -> seq.seq res;
        lockGuts : t -> AMap.t lock_info;  
        lockSet : t -> access_map;         
        lockRes : t -> address -> option lock_info;
        addThread : t -> val -> val -> res -> t;
        updThreadC : forall {tid tp}, containsThread tp tid -> ctl -> t;
        updThreadR : forall {tid tp}, containsThread tp tid -> res -> t;
        updThread : forall {tid tp}, containsThread tp tid -> ctl -> res -> t;
        updLockSet : t -> address -> lock_info -> t;
        remLockSet : t -> address -> t;
        latestThread : t -> tid;
        lr_valid : (address -> option lock_info) -> Prop;
                find_thread_: t -> (ctl -> bool) -> option tid
        ; resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti)          
        ;  containsThread_dec_:
             forall i tp, {containsThread tp i} + { ~ containsThread tp i}

        ;  cnt_irr: forall t tid
                      (cnt1 cnt2: containsThread t tid),
            cnt1 = cnt2

        ;  cntAdd:
             forall {j tp} vf arg p,
               containsThread tp j ->
               containsThread (addThread tp vf arg p) j

        ;  cntAddLatest:
             forall {tp} vf arg p,
               containsThread (addThread tp vf arg p) (latestThread tp)

        ;  cntAdd':
             forall {j tp} vf arg p,
               containsThread (addThread tp vf arg p) j ->
               (containsThread tp j /\ j <> latestThread tp) \/ j = latestThread tp

        ;  cntUpdateC:
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread tp tid0->
               containsThread (updThreadC cnt c) tid0
        ;  cntUpdateC':
             forall {tid tid0 tp} c
               (cnt: containsThread tp tid),
               containsThread (updThreadC cnt c) tid0 ->
               containsThread tp tid0

        ;  cntUpdateR:
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread tp j->
               containsThread (updThreadR cnti r) j
        ;  cntUpdateR':
             forall {i j tp} r
               (cnti: containsThread tp i),
               containsThread (updThreadR cnti r) j ->
               containsThread tp j

        ;  cntUpdate:
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread tp j ->
               containsThread (updThread cnti c p) j
        ;  cntUpdate':
             forall {i j tp} c p
               (cnti: containsThread tp i),
               containsThread (updThread cnti c p) j ->
               containsThread tp j

        ;  cntUpdateL:
             forall {j tp} add lf,
               containsThread tp j ->
               containsThread (updLockSet tp add lf) j
        ;  cntRemoveL:
             forall {j tp} add,
               containsThread tp j ->
               containsThread (remLockSet tp add) j

        ;  cntUpdateL':
             forall {j tp} add lf,
               containsThread (updLockSet tp add lf) j ->
               containsThread tp j
        ;  cntRemoveL':
             forall {j tp} add,
               containsThread (remLockSet tp add) j ->
               containsThread tp j

        ;  gsoThreadLock:
             forall {i tp} c p (cnti: containsThread tp i),
               lockSet (updThread cnti c p) = lockSet tp

        ;  gsoThreadCLock :
             forall {i tp} c (cnti: containsThread tp i),
               lockSet (updThreadC cnti c) = lockSet tp

        ;  gsoThreadRLock :
             forall {i tp} p (cnti: containsThread tp i),
               lockSet (updThreadR cnti p) = lockSet tp

        ;  gsoAddLock :
             forall tp vf arg p,
               lockSet (addThread tp vf arg p) = lockSet tp

        ;  gssAddRes :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadR cnt' = pmap

        ;  gssThreadCode :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCode :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadC cntj' = getThreadC cntj

        ;  gssThreadRes :
             forall {tid tp} (cnt: containsThread tp tid) c' p'
               (cnt': containsThread (updThread cnt c' p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRes :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) (Hneq: i <> j) c' p'
               (cntj': containsThread (updThread cnti c' p') j),
               getThreadR cntj' = getThreadR cntj

        ;  gssThreadCC :
             forall {tid tp} (cnt: containsThread tp tid) c'
               (cnt': containsThread (updThreadC cnt c') tid),
               getThreadC cnt' = c'

        ;  gsoThreadCC :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadC cntj = getThreadC cntj'

        ;  getThreadCC :
             forall {tp} i j
               (cnti : containsThread tp i) (cntj : containsThread tp j)
               c' (cntj' : containsThread (updThreadC cnti c') j),
               getThreadC cntj' = if Nat.eq_dec i j then c' else getThreadC cntj

        ;  gssThreadRR :
             forall {tid tp} (cnt: containsThread tp tid) p'
               (cnt': containsThread (updThreadR cnt p') tid),
               getThreadR cnt' = p'

        ;  gsoThreadRR :
             forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
               (cntj: containsThread tp j) p'
               (cntj': containsThread (updThreadR cnti p') j),
               getThreadR cntj = getThreadR cntj'

        ;  gThreadCR :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) c'
               (cntj': containsThread (updThreadC cnti c') j),
               getThreadR cntj' = getThreadR cntj

        ;  gThreadRC :
             forall {i j tp} (cnti: containsThread tp i)
               (cntj: containsThread tp j) p
               (cntj': containsThread (updThreadR cnti p) j),
               getThreadC cntj' = getThreadC cntj

        ;  gsoThreadCLPool :
             forall {i tp} c (cnti: containsThread tp i) addr,
               lockRes (updThreadC cnti c) addr = lockRes tp addr

        ;  gsoThreadLPool :
             forall {i tp} c p (cnti: containsThread tp i) addr,
               lockRes (updThread cnti c p) addr = lockRes tp addr

        ;  gsoAddLPool :
             forall tp vf arg p (addr : address),
               lockRes (addThread tp vf arg p) addr = lockRes tp addr

        ;  gLockSetRes :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadR cnti' = getThreadR cnti

        ;  gLockSetCode :
             forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
               (cnti': containsThread (updLockSet tp addr res) i),
               getThreadC cnti' = getThreadC cnti

        ;  gssLockRes :
             forall tp addr pmap,
               lockRes (updLockSet tp addr pmap) addr = Some pmap

        ;  gsoLockRes:
             forall tp addr addr' pmap
               (Hneq: addr <> addr'),
               lockRes (updLockSet tp addr pmap) addr' =
               lockRes tp addr'

        ;  gssLockSet :
             forall tp b ofs rmap ofs',
               (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->
               (Maps.PMap.get b (lockSet (updLockSet tp (b, ofs) rmap)) ofs') = Some Writable

        ;  gsoLockSet_1 :
             forall tp b ofs ofs'  pmap
               (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),
               (Maps.PMap.get b (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b (lockSet tp)) ofs'
        ;  gsoLockSet_2 :
             forall tp b b' ofs ofs' pmap,
               b <> b' ->
               (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =
               (Maps.PMap.get b' (lockSet tp)) ofs'

        ;  lockSet__updLockSet:
             forall tp i (pf: containsThread tp i) c pmap addr rmap,
               lockSet (updLockSet tp addr rmap) =
               lockSet (updLockSet (updThread pf c pmap) addr rmap)

        ;  updThread_updThreadC__comm :
             forall tp i j c pmap' c'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThreadC cnti c) j),
               updThreadC cnti' c = updThread cntj' c' pmap'

        ;  updThread_comm :
             forall tp i j c pmap c' pmap'
               (Hneq: i <> j)
               (cnti : containsThread tp i)
               (cntj : containsThread tp j)
               (cnti': containsThread (updThread cntj c' pmap') i)
               (cntj': containsThread (updThread cnti c pmap) j),
               updThread cnti' c pmap = updThread cntj' c' pmap'

        ;  add_updateC_comm :
             forall tp i vf arg pmap c'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThreadC cnti c') vf arg pmap =
               updThreadC cnti' c'

        ;  add_update_comm :
             forall tp i vf arg pmap c' pmap'
               (cnti: containsThread tp i)
               (cnti': containsThread (addThread tp vf arg pmap) i),
               addThread (updThread cnti c' pmap') vf arg pmap =
               updThread cnti' c' pmap'

        ;  updThread_lr_valid :
             forall tp i (cnti: containsThread tp i) c' m',
               lr_valid (lockRes tp) ->
               lr_valid (lockRes (updThread cnti c' m'))

        ; lockSet_spec_2 :
            forall (js : t) (b : block) (ofs ofs' : Z),
              Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->
              lockRes js (b, ofs) -> (lockSet js) !! b ofs' = Some Memtype.Writable

        ;  lockSet_spec_3 :
             forall ds b ofs,
               (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
               (lockSet ds) !! b ofs = None

        ;  gsslockSet_rem : forall ds b ofs ofs0,
            lr_valid (lockRes ds) ->
            Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->
            isSome ((lockRes ds) (b,ofs)) ->  
            (lockSet (remLockSet ds (b, ofs))) !! b ofs0 =
            None

        ;  gsolockSet_rem1 : forall ds b ofs b' ofs',
            b  <> b' ->
            (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
            (lockSet ds)  !! b' ofs'

        ;  gsolockSet_rem2 : forall ds b ofs ofs',
            lr_valid (lockRes ds) ->
            ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->
            (lockSet (remLockSet ds (b, ofs))) !! b ofs' =
            (lockSet ds)  !! b ofs'
        ;  gsslockResUpdLock: forall js a res,
            lockRes (updLockSet js a res) a =
            Some res
        ;  gsolockResUpdLock : forall js loc a res,
            loc <> a ->
            lockRes (updLockSet js loc res) a =
            lockRes js a

        ;  gsslockResRemLock : forall js a,
            lockRes (remLockSet js a) a =
            None
        ;  gsolockResRemLock : forall js loc a,
            loc <> a ->
            lockRes (remLockSet js loc) a =
            lockRes js a

        ;  gRemLockSetCode :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadC cnti' = getThreadC cnti

        ;  gRemLockSetRes :
             forall {i tp} addr (cnti: containsThread tp i)
               (cnti': containsThread (remLockSet tp addr) i),
               getThreadR cnti' = getThreadR cnti

        ;  gsoAddCode :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j)
               (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadC cntj' = getThreadC cntj

        ;  gssAddCode :
             forall {tp} vf arg pmap j
               (Heq: j = latestThread tp)
               (cnt': containsThread (addThread tp vf arg pmap) j),
               getThreadC cnt' = Kinit vf arg

        ;  gsoAddRes :
             forall {tp} vf arg pmap j
               (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
               getThreadR cntj' = getThreadR cntj

        ;  updLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l lmap,
             forall (cnti': containsThread (updLockSet ds l lmap) i),
               updLockSet
                 (@updThread _ ds cnti c map) l lmap =
               @updThread  _ (updLockSet ds l lmap) cnti' c map

        ;  remLock_updThread_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c map l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet
                 (updThread cnti c map)
                 l =
               updThread cnti' c map
        ;  remLock_updThreadC_comm :
             forall ds,
             forall i (cnti: containsThread ds i) c l,
             forall (cnti': containsThread (remLockSet ds l) i),
               remLockSet (updThreadC cnti c) l = updThreadC cnti' c
      }.

  End ThreadPool.
End ThreadPool.

Module OrdinalPool.

  Definition empty_lset {lock_info}:AMap.t lock_info:=
    AMap.empty lock_info.

  Lemma find_empty:
    forall a l,
      @AMap.find a l empty_lset = None.

  Section OrdinalThreadPool.

    Context {resources: Resources}.

    Context {Sem: Semantics}.
    
    Local Notation ctl := (@ctl semC).

    Notation tid:= nat.
    
    Record t := mk
                  { num_threads : pos
                    ; pool :> 'I_num_threads -> ctl
                    ; perm_maps : 'I_num_threads -> res
                    ; lset : AMap.t lock_info
                  }.

    Definition one_pos : pos.pos := pos.mkPos NPeano.Nat.lt_0_1.
    
    Definition mkPool c res :=
      mk one_pos
        (fun _ =>  c)
        (fun _ => res) 
        empty_lset.
    
    Definition lockGuts := lset.
    Definition lockSet (tp:t) := A2PMap (lset tp).

    Definition lockRes t : address -> option lock_info:=
      AMap.find (elt:=lock_info)^~ (lockGuts t).

    Definition lr_valid (lr: address -> option lock_info):=
      forall b ofs,
        match lr (b,ofs) with
        | Some r => forall ofs0:Z, (ofs < ofs0 < ofs+LKSIZE)%Z -> lr (b, ofs0) = None
        | _ => True
        end.

    Lemma is_pos: forall n, (0 < S n)%coq_nat.
    Definition mk_pos_S (n:nat):= mkPos (is_pos n).
    Lemma lt_decr: forall n m: nat, S n < m -> n < m.
    Program Fixpoint find_thread' {st:t}{filter:ctl -> bool} n (P: n < num_threads st) {struct n}:=
      if filter (@pool st (@Ordinal (num_threads st) n P))
      then Some n
      else match n with
           | S n' =>  find_thread' n' (lt_decr  n' _ P)
           | O => None
           end.
    Definition pos_pred (n:pos): nat.

    Program Definition find_thread (st:t)(filter:ctl -> bool): option tid:=
      @find_thread' st filter (pos_pred (num_threads st)) _ .

    Import Coqlib.

    Lemma lockSet_WorNE: forall js b ofs,
        (lockSet js) !! b ofs = Some Memtype.Writable \/

    Lemma lockSet_spec_2 :
      forall (js : t) (b : block) (ofs ofs' : Z),
        Intv.In ofs' (ofs, (ofs + Z.of_nat lksize.LKSIZE_nat)%Z) ->

    Lemma lockSet_spec_1: forall js b ofs,
        lockRes js (b,ofs) ->
        (lockSet js) !! b ofs = Some Memtype.Writable.

    Open Scope nat_scope.

    Definition containsThread (tp : t) (i : NatTID.tid) : Prop:=
      i < num_threads tp.

    Definition containsThread_dec:
      forall i tp, {containsThread tp i} + { ~ containsThread tp i}.

    Definition getThreadC {i tp} (cnt: containsThread tp i) : ctl :=
      tp (Ordinal cnt).

    Definition unique_Krun' tp i :=
      ( forall j cnti q,
          @getThreadC j tp cnti = Krun q ->
          eq_nat_dec i j ).

    Definition is_running tp i:=
      exists cnti q, @getThreadC i tp cnti = Krun q.

    Lemma unique_runing_not_running:
      forall tp i,
        unique_Krun' tp i ->
        ~ is_running tp i ->
        forall j, unique_Krun' tp j.

    Definition getThreadR {i tp} (cnt: containsThread tp i) : res :=
      (perm_maps tp) (Ordinal cnt).

    Definition latestThread tp := n (num_threads tp).

    Definition addThread (tp : t) (vf arg : val) (pmap : res) : t :=
      let: new_num_threads := pos_incr (num_threads tp) in
      let: new_tid := ordinal_pos_incr (num_threads tp) in
      mk new_num_threads
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => Kinit vf arg
            | Some n' => tp n'
            end)
         (fun (n : 'I_new_num_threads) =>
            match unlift new_tid n with
            | None => pmap
            | Some n' => (perm_maps tp) n'
            end)
         (lset tp).

    Definition updLockSet tp (add:address) (lf:lock_info) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.add add lf (lockGuts tp)).

    Definition remLockSet tp  (add:address) : t :=
      mk (num_threads tp)
         (pool tp)
         (perm_maps tp)
         (AMap.remove add (lockGuts tp)).

    Definition updThreadC {tid tp} (cnt: containsThread tp tid) (c' : ctl) : t :=
      mk (num_threads tp)
         (fun n => if n == (Ordinal cnt) then c' else (pool tp)  n)
         (perm_maps tp)
         (lset tp).

    Definition updThreadR {tid tp} (cnt: containsThread tp tid)
               (pmap' : res) : t :=
      mk (num_threads tp) (pool tp)
         (fun n =>
            if n == (Ordinal cnt) then pmap' else (perm_maps tp) n)
         (lset tp).

    Definition updThread {tid tp} (cnt: containsThread tp tid) (c' : ctl)
               (pmap : res) : t :=
      mk (num_threads tp)
         (fun n =>
            if n == (Ordinal cnt) then c' else tp n)
         (fun n =>
            if n == (Ordinal cnt) then pmap else (perm_maps tp) n)
         (lset tp).

    Lemma cnt_irr: forall t tid
                     (cnt1 cnt2: containsThread t tid),
        cnt1 = cnt2.

    Lemma numUpdateC :
      forall {tid tp} (cnt: containsThread tp tid) c,
        num_threads tp =  num_threads (updThreadC cnt c).

    Lemma cntUpdateC :
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread tp tid0 ->
        containsThread (updThreadC cnt c) tid0.
    Lemma cntUpdateC':
      forall {tid tid0 tp} c
        (cnt: containsThread tp tid),
        containsThread (updThreadC cnt c) tid0 ->
        containsThread tp tid0.

    Lemma cntUpdateR:
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread tp j->
        containsThread (updThreadR cnti r) j.

    Lemma cntUpdateR':
      forall {i j tp} r
        (cnti: containsThread tp i),
        containsThread (updThreadR cnti r) j ->
        containsThread tp j.

    Lemma cntUpdate :
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread tp j ->
        containsThread (updThread cnti c p) j.

    Lemma cntUpdate':
      forall {i j tp} c p
        (cnti: containsThread tp i),
        containsThread (updThread cnti c p) j ->
        containsThread tp j.

    Lemma cntUpdateL:
      forall {j tp} add lf,
        containsThread tp j ->
        containsThread (updLockSet tp add lf) j.
    Lemma cntRemoveL:
      forall {j tp} add,
        containsThread tp j ->
        containsThread (remLockSet tp add) j.

    Lemma cntUpdateL':
      forall {j tp} add lf,
        containsThread (updLockSet tp add lf) j ->
        containsThread tp j.
    Lemma cntRemoveL':
      forall {j tp} add,
        containsThread (remLockSet tp add) j ->
        containsThread tp j.

    Lemma cntAdd:
      forall {j tp} vf arg p,
        containsThread tp j ->
        containsThread (addThread tp vf arg p) j.

    Lemma cntAddLatest:
      forall {tp} vf arg p,
        containsThread (addThread tp vf arg p) (latestThread tp).

    Lemma cntAdd':
      forall {j tp} vf arg p,
        containsThread (addThread tp vf arg p) j ->
        (containsThread tp j /\ j <> num_threads tp) \/ j = num_threads tp.

    Lemma contains_add_latest: forall ds p a r,
        containsThread (addThread ds p a r)
                       (latestThread ds).

    Lemma updLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l lmap,
      forall (cnti': containsThread (updLockSet ds l lmap) i),
        updLockSet
          (@updThread _ ds cnti c map) l lmap =
        @updThread _ (updLockSet ds l lmap) cnti' c map.
    Lemma remLock_updThread_comm:
      forall ds,
      forall i (cnti: containsThread ds i) c map l,
      forall (cnti': containsThread (remLockSet ds l) i),
        remLockSet
          (updThread cnti c map)
          l =
        updThread cnti' c map.

    Lemma remLock_updThreadC_comm :
      forall ds i (cnti: containsThread ds i) c l
        (cnti': containsThread (remLockSet ds l) i),
        remLockSet (updThreadC cnti c) l = updThreadC cnti' c.

    Set Bullet Behavior "None".
    Set Bullet Behavior "Strict Subproofs".

    Lemma gsslockResUpdLock: forall js a res,
        lockRes (updLockSet js a res) a =
        Some res.

    Ltac address_ordered_auto :=
      auto; repeat match goal with
                   | H: AddressOrdered.eq ?A ?A |- _ => clear H
                   | H: AddressOrdered.eq ?A ?B |- _ => hnf in H; subst A
                   | H: ?A <> ?A |- _ => contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?A |- _ =>
                     apply AddressOrdered.lt_not_eq in H; contradiction H; reflexivity
                   | H: AddressOrdered.lt ?A ?B, H': AddressOrdered.lt ?B ?A |- _ =>
                     contradiction (AddressOrdered.lt_not_eq (AddressOrdered.lt_trans H H')); reflexivity
                   end.

    Lemma gsolockResUpdLock: forall js loc a res,
        loc <> a ->
        lockRes (updLockSet js loc res) a =
        lockRes js a.

    Lemma gsslockResRemLock: forall js a,
        lockRes (remLockSet js a) a =
        None.

    Lemma gsolockResRemLock: forall js loc a,
        loc <> a ->
        lockRes (remLockSet js loc) a =
        lockRes js a.

    Lemma gsoThreadLock:
      forall {i tp} c p (cnti: containsThread tp i),
        lockSet (updThread cnti c p) = lockSet tp.

    Lemma gsoThreadCLock:
      forall {i tp} c (cnti: containsThread tp i),
        lockSet (updThreadC cnti c) = lockSet tp.

    Lemma gsoThreadRLock:
      forall {i tp} p (cnti: containsThread tp i),
        lockSet (updThreadR cnti p) = lockSet tp.

    Lemma gsoAddLock:
      forall tp vf arg p,
        lockSet (addThread tp vf arg p) = lockSet tp.

    Lemma PX_in_rev:
      forall elt a m, AMap.Raw.PX.In (elt:=elt) a m <-> AMap.Raw.PX.In a (rev m).

    Import SetoidList.
    Arguments InA {A}{eqA} x _.
    Arguments AMap.In {elt} x m.

    Lemma lockRes_range_dec: forall tp b ofs,
        { (exists z, z <= ofs < z+LKSIZE /\ lockRes tp (b,z) )%Z  } + {(forall z, z <= ofs < z+LKSIZE -> lockRes tp (b,z) = None)%Z }.

    Lemma lockSet_spec_3:
      forall ds b ofs,
        (forall z, z <= ofs < z+LKSIZE -> lockRes ds (b,z) = None)%Z ->
        (lockSet ds) !! b ofs = None.

    Lemma gsslockSet_rem: forall ds b ofs ofs0,
        lr_valid (lockRes ds) ->
        Intv.In ofs0 (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gsolockSet_rem1: forall ds b ofs b' ofs',
        b  <> b' ->
        (lockSet (remLockSet ds (b, ofs))) !! b' ofs' =
        (lockSet ds)  !! b' ofs'.

    Lemma gsolockSet_rem2: forall ds b ofs ofs',
        lr_valid (lockRes ds) ->
        ~ Intv.In ofs' (ofs, ofs + lksize.LKSIZE)%Z ->

    Lemma gssThreadCode {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadC cnt' = c'.

    Lemma eq_op_false: forall A i j, i <>j -> @eq_op A i j = false.

    Lemma gsoThreadCode:
      forall {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
        (cntj: containsThread tp j) c' p'
        (cntj': containsThread (updThread cnti c' p') j),
        getThreadC cntj' = getThreadC cntj.

    Lemma gssThreadRes {tid tp} (cnt: containsThread tp tid) c' p'
          (cnt': containsThread (updThread cnt c' p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRes {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) (Hneq: i <> j) c' p'
          (cntj': containsThread (updThread cnti c' p') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gssThreadCC {tid tp} (cnt: containsThread tp tid) c'
          (cnt': containsThread (updThreadC cnt c') tid) :
      getThreadC cnt' = c'.

    Lemma gsoThreadCC {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadC cntj = getThreadC cntj'.

    Lemma getThreadCC
          {tp} i j
          (cnti : containsThread tp i) (cntj : containsThread tp j)
          c' (cntj' : containsThread (updThreadC cnti c') j):
      getThreadC cntj' = if eq_nat_dec i j then c' else getThreadC cntj.

    Lemma gssThreadRR {tid tp} (cnt: containsThread tp tid) p'
          (cnt': containsThread (updThreadR cnt p') tid) :
      getThreadR cnt' = p'.

    Lemma gsoThreadRR {i j tp} (Hneq: i <> j) (cnti: containsThread tp i)
          (cntj: containsThread tp j) p'
          (cntj': containsThread (updThreadR cnti p') j) :
      getThreadR cntj = getThreadR cntj'.

    Lemma gThreadCR {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) c'
          (cntj': containsThread (updThreadC cnti c') j) :
      getThreadR cntj' = getThreadR cntj.

    Lemma gThreadRC {i j tp} (cnti: containsThread tp i)
          (cntj: containsThread tp j) p
          (cntj': containsThread (updThreadR cnti p) j) :
      getThreadC cntj' = getThreadC cntj.

    Lemma unlift_m_inv :
      forall tp i (Htid : i < (num_threads tp).+1) ord

    Lemma gssAddRes:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadR cnt' = pmap.

    Lemma gsoAddRes:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j) (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadR cntj' = getThreadR cntj.

    Lemma gssAddCode:
      forall {tp} vf arg pmap j
        (Heq: j = latestThread tp)
        (cnt': containsThread (addThread tp vf arg pmap) j),
        getThreadC cnt' = Kinit vf arg.

    Lemma gsoAddCode:
      forall {tp} vf arg pmap j
        (cntj: containsThread tp j)
        (cntj': containsThread (addThread tp vf arg pmap) j),
        getThreadC cntj' = getThreadC cntj.

    Lemma add_update_comm:
      forall tp i vf arg pmap c' pmap'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThread cnti c' pmap') vf arg pmap =
        updThread cnti' c' pmap'.

    Lemma add_updateC_comm:
      forall tp i vf arg pmap c'
        (cnti: containsThread tp i)
        (cnti': containsThread (addThread tp vf arg pmap) i),
        addThread (updThreadC cnti c') vf arg pmap =
        updThreadC cnti' c'.

    Lemma updThread_comm :
      forall tp  i j c pmap c' pmap'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThread cnti c pmap) j),
        updThread cnti' c pmap = updThread cntj' c' pmap'.

    Lemma updThread_updThreadC_comm :
      forall tp i j c pmap' c'
        (Hneq: i <> j)
        (cnti : containsThread tp i)
        (cntj : containsThread tp j)
        (cnti': containsThread (updThread cntj c' pmap') i)
        (cntj': containsThread (updThreadC cnti c) j),
        updThreadC cnti' c = updThread cntj' c' pmap'.

    Lemma updThread_same :
      forall tp i (cnti : containsThread tp i),
      updThread cnti (getThreadC cnti) (getThreadR cnti) = tp.

    Lemma updThread_twice :
      forall tp i (cnti : containsThread tp i) c c' r r'
        (cnti' : containsThread (updThread cnti c r) i),
      updThread cnti' c' r' = updThread cnti c' r'.

    Lemma updThreadRC : forall tp i (cnti : containsThread tp i) c,
      updThread cnti c (getThreadR cnti) = updThreadC cnti c.

    Lemma gsoThreadCLPool:
      forall {i tp} c (cnti: containsThread tp i) addr,
        lockRes (updThreadC cnti c) addr = lockRes tp addr.

    Lemma gsoThreadLPool:
      forall {i tp} c p (cnti: containsThread tp i) addr,
        lockRes (updThread cnti c p) addr = lockRes tp addr.

    Lemma gsoAddLPool:
      forall tp vf arg p (addr : address),
        lockRes (addThread tp vf arg p) addr = lockRes tp addr.

    Lemma gLockSetRes:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gLockSetCode:
      forall {i tp} addr (res : lock_info) (cnti: containsThread tp i)
        (cnti': containsThread (updLockSet tp addr res) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetCode:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadC cnti' = getThreadC cnti.

    Lemma gRemLockSetRes:
      forall {i tp} addr (cnti: containsThread tp i)
        (cnti': containsThread (remLockSet tp addr) i),
        getThreadR cnti' = getThreadR cnti.

    Lemma gssLockRes:
      forall tp addr pmap,
        lockRes (updLockSet tp addr pmap) addr = Some pmap.

    Lemma gsoLockRes:
      forall tp addr addr' pmap
        (Hneq: addr <> addr'),
        lockRes (updLockSet tp addr pmap) addr' =
        lockRes tp addr'.

    Lemma gssLockSet:
      forall tp b ofs rmap ofs',
        (ofs <= ofs' < ofs + Z.of_nat lksize.LKSIZE_nat)%Z ->

    Lemma gsoLockSet_12 :
      forall tp b b' ofs ofs' pmap,
        ~ adr_range (b,ofs) LKSIZE (b',ofs') ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma gsoLockSet_1:
      forall tp b ofs ofs'  pmap
        (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat lksize.LKSIZE_nat))%Z),

    Lemma gsoLockSet_2 :
      forall tp b b' ofs ofs' pmap,
        b <> b' ->
        (Maps.PMap.get b' (lockSet (updLockSet tp (b,ofs) pmap))) ofs' =

    Lemma lockSet_updLockSet:
      forall tp i (pf: containsThread tp i) c pmap addr rmap,
        lockSet (updLockSet tp addr rmap) =
        lockSet (updLockSet (updThread pf c pmap) addr rmap).

    Lemma updThread_lr_valid:
      forall tp i (cnti: containsThread tp i) c' m',
        lr_valid (lockRes tp) ->
        lr_valid (lockRes (updThread cnti c' m')).

    Lemma contains_iff_num:
      forall tp tp'
        (Hcnt: forall i, containsThread tp i <-> containsThread tp' i),
        num_threads tp = num_threads tp'.

    Lemma leq_stepdown:
      forall {m n},
        S n <= m -> n <= m.
    
    Lemma lt_sub:
      forall {m n},
        S n <= m ->
        m - (S n) <  m.

    Fixpoint containsList_upto_n (n m:nat): n <= m -> seq.seq (sigT (fun i => i < m)):=
      match n with
      | O => fun _ => nil
      | S n' => fun (H: S n' <= m) =>
                 (existT (fun i => i < m) (m-(S n')) (lt_sub H)) ::
                 (containsList_upto_n n' m) (leq_stepdown H)                                  
      end.

    Lemma containsList_upto_n_spec:
      forall m n (H: n <= m)
        i (cnti:  (fun i => i < m) (m - n + i)),
        i < n ->
        nth_error (containsList_upto_n n m H) i = Some (existT _ (m - n + i) (cnti)). 
    
    Definition containsList' (n:nat): seq.seq (sigT (fun i => i < n)):=
      containsList_upto_n n n (leq_refl n).

    Definition contains_from_ineq (tp:t):
        {i : tid & i < num_threads tp } -> {i : tid & containsThread tp i}:=
       fun (H : {i : tid & i < num_threads tp}) =>
         let (x, i) := H in existT (containsThread tp) x i.

    Definition containsList (tp:t): seq.seq (sigT (containsThread tp)):=
      map (contains_from_ineq tp) (containsList' (num_threads tp)).

    Lemma containsList'_spec: forall i n
            (cnti: (fun i => i < n) i),
            List.nth_error (containsList' n) i = Some (existT _ i (cnti)).

    Lemma containsList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (containsList tp) i = Some (existT _ i cnti).
      
    Definition indexed_contains tp:= (fun Ncontained: (sigT (containsThread tp)) =>
             let (i, cnti) := Ncontained in getThreadR cnti).
    
    Definition resourceList (tp:t): seq.seq res:=
      map (@indexed_contains tp)
          (containsList tp).

    Lemma resourceList_spec: forall i tp
            (cnti: containsThread tp i),
            List.nth_error (resourceList tp) i = Some (getThreadR cnti).
        
    Definition OrdinalThreadPool: ThreadPool.ThreadPool :=
      (@ThreadPool.Build_ThreadPool _ _
                                    t
                                    mkPool
                                    containsThread
                                    (@getThreadC) 
                                    (@getThreadR) 
                                    resourceList
                                    lockGuts
                                    lockSet
                                    (@lockRes) 
                                    addThread
                                    (@updThreadC) 
                                    (@updThreadR)
                                    (@updThread) 
                                    updLockSet 
                                    remLockSet 
                                    latestThread 
                                    lr_valid 
                                    
                                    find_thread
                                    resourceList_spec
                                    containsThread_dec
                                    
                                    cnt_irr
                                    (@cntAdd)
                                    (@cntAddLatest)
                                    (@cntAdd')
                                    (@cntUpdateC)
                                    (@cntUpdateC')
                                    (@cntUpdateR)
                                    (@cntUpdateR')
                                    (@cntUpdate)
                                    (@cntUpdate')
                                    (@cntUpdateL)
                                    (@cntRemoveL)
                                    (@cntUpdateL')
                                    (@cntRemoveL')
                                    (@gsoThreadLock)
                                    (@gsoThreadCLock)
                                    (@gsoThreadRLock)
                                    (@gsoAddLock)
                                    (@gssAddRes)
                                    (@gssThreadCode)
                                    (@gsoThreadCode)
                                    (@gssThreadRes)
                                    (@gsoThreadRes)
                                    (@gssThreadCC)
                                    (@gsoThreadCC)
                                    (@getThreadCC)
                                    (@gssThreadRR)
                                    (@gsoThreadRR)
                                    (@gThreadCR)
                                    (@gThreadRC)
                                    (@gsoThreadCLPool)
                                    (@gsoThreadLPool)
                                    (@gsoAddLPool)
                                    (@gLockSetRes)
                                    (@gLockSetCode)
                                    (@gssLockRes)
                                    (@gsoLockRes)
                                    (@gssLockSet)
                                    (@gsoLockSet_1)
                                    gsoLockSet_2
                                    lockSet_updLockSet
                                    updThread_updThreadC_comm
                                    updThread_comm
                                    add_updateC_comm
                                    add_update_comm
                                    updThread_lr_valid
                                    lockSet_spec_2
                                    lockSet_spec_3
                                    gsslockSet_rem
                                    gsolockSet_rem1
                                    gsolockSet_rem2
                                    gsslockResUpdLock
                                    gsolockResUpdLock
                                    gsslockResRemLock
                                    gsolockResRemLock
                                    (@ gRemLockSetCode)
                                    (@gRemLockSetRes)
                                    (@gsoAddCode)
                                    (@gssAddCode)
                                    (@gsoAddRes)
                                    updLock_updThread_comm
                                    remLock_updThread_comm
                                    remLock_updThreadC_comm
      ).

  End OrdinalThreadPool.
End OrdinalPool. *)

Require Import VST.concurrency.common.HybridMachineSig.
(* VST.concurrency.common.HybridMachineSig:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.

Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.event_semantics.
Require Export VST.concurrency.common.semantics.
Require Import VST.concurrency.common.threadPool.

Require Import VST.concurrency.common.machine_semantics.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.common.addressFiniteMap.
Require Import Coq.Program.Program.

Notation EXIT :=
  (EF_external "EXIT" (mksignature (AST.Tint::nil) None)).
Notation CREATE_SIG := (mksignature (AST.Tint::AST.Tint::nil) None cc_default).
Notation CREATE := (EF_external "spawn" CREATE_SIG).
Notation MKLOCK :=
  (EF_external "makelock" (mksignature (AST.Tptr::nil) None cc_default)).
Notation FREE_LOCK :=
  (EF_external "freelock" (mksignature (AST.Tptr::nil) None cc_default)).
Notation LOCK_SIG := (mksignature (AST.Tptr::nil) None cc_default).
Notation LOCK := (EF_external "acquire" LOCK_SIG).
Notation UNLOCK_SIG := (mksignature (AST.Tptr::nil) None cc_default).
Notation UNLOCK := (EF_external "release" UNLOCK_SIG).

Module Events.
    Definition evRes := (access_map * access_map)%type.
  Definition evDelta := (delta_map * delta_map)%type.

  Definition delta_content := (Maps.PTree.t (Z -> option memval)).
  Inductive sync_event : Type :=
  | release : address -> option delta_content -> sync_event
  | acquire : address -> option delta_content -> sync_event
  | mklock :  address -> sync_event
  | freelock : address -> sync_event
  | spawn : address -> option delta_content -> option delta_content -> sync_event
  | failacq: address -> sync_event.
  
  Inductive machine_event : Type :=
  | internal: nat -> mem_event -> machine_event
  | external : nat -> sync_event -> machine_event.

  Definition thread_id ev : nat :=
    match ev with
    | internal i _ => i
    | external i _ => i
    end.

  Inductive act : Type :=
  | Read : act
  | Write : act
  | Alloc : act
  | Free : act
  | Release : act
  | Acquire : act
  | Mklock : act
  | Freelock : act
  | Failacq : act
  | Spawn : act.

  Definition is_internal ev :=
    match ev with
    | internal _ _ => true
    | _ => false
    end.

  Definition is_external ev :=
    match ev with
    | external _ _ => true
    | _ => false
    end.

  Definition action ev : act :=
    match ev with
    | internal _ mev =>
      match mev with
      | event_semantics.Write _ _ _ => Write
      | event_semantics.Read _ _ _ _ => Read
      | event_semantics.Alloc _ _ _ => Alloc
      | event_semantics.Free _ => Free
      end
    | external _ sev =>
      match sev with
      | release _ _ => Release
      | acquire _ _ => Acquire
      | mklock _ => Mklock
      | freelock _ => Freelock
      | failacq _ => Failacq
      | spawn _ _ _ => Spawn
      end
    end.

  Definition location ev : option (address*nat) :=
    match ev with
    | internal _ mev =>
      match mev with
      | event_semantics.Write b ofs vs => Some ((b, ofs), length vs)
      | event_semantics.Read b ofs _ vs => Some ((b, ofs), length vs)
      | _ => None
      end
    | external _ sev =>
      match sev with
      | release addr _ => Some (addr, lksize.LKSIZE_nat)
      | acquire addr _ => Some (addr, lksize.LKSIZE_nat)
      | mklock addr => Some (addr, lksize.LKSIZE_nat)
      | freelock addr => Some (addr, lksize.LKSIZE_nat)
      | spawn addr _ _ => Some (addr, lksize.LKSIZE_nat)
      | failacq addr => Some (addr, lksize.LKSIZE_nat)
      end
    end.

End Events.

Module HybridMachineSig.
  Import Events ThreadPool.

  Class DiluteMem :=
    { diluteMem: mem -> mem;
      diluteMem_valid: forall m,
          forall b, Memory.Mem.valid_block (diluteMem m) b <-> Memory.Mem.valid_block m b
    }.
  
  Section HybridMachineSig.
    
    Variable n: option nat.
    Context {resources: Resources}
            {Sem: Semantics}
            {ThreadPool : ThreadPool.ThreadPool}
            {DilMem : DiluteMem}.
    Definition thread_pool := ThreadPool.t.
    Definition C:= (@semC Sem).
    Definition G:= (@semG Sem).
    Local Notation ctl := (@ctl C).

    Class MachineSig :=
      {
        richMem: Type
        ; dryMem: richMem -> mem

        ; mem_compatible: thread_pool -> mem -> Prop
        ; invariant: thread_pool -> Prop
        ; install_perm: forall {ms m tid},
            mem_compatible ms m -> containsThread ms tid -> mem -> Prop
        ; add_block: forall {ms m tid},
            mem_compatible ms m -> containsThread ms tid -> mem -> res
                                     
        ; threadStep:
            forall {tid0 ms m},
              containsThread ms tid0 -> mem_compatible ms m ->
              thread_pool -> mem -> seq mem_event -> Prop

        ; threadStep_at_Krun:
            forall i tp m cnt cmpt tp' m' tr,
              @threadStep i tp m cnt cmpt tp' m' tr ->
              (exists q, @getThreadC _ _ _ i tp cnt = Krun q)                                        
                                                    
        ;  threadStep_equal_run:
             forall i tp m cnt cmpt tp' m' tr,
               @threadStep i tp m cnt cmpt tp' m' tr ->
               forall (j: nat),
                 (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
                 (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q')

        ; syncStep:
            bool -> 
            forall {tid0 ms m},
                containsThread ms tid0 -> mem_compatible ms m ->
                thread_pool -> mem -> sync_event -> Prop
                                                   
        ;  syncstep_equal_run:
             forall b i tp m cnt cmpt tp' m' tr,
               @syncStep b i tp m cnt cmpt tp' m' tr ->
               forall j,
                 (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
                 (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q')
                   
        ;  syncstep_not_running:
             forall b i tp m cnt cmpt tp' m' tr,
               @syncStep b i tp m cnt cmpt tp' m' tr ->
               forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q

        ; init_mach : option res -> mem -> thread_pool -> mem -> val -> list val -> Prop}.

    Context {machineSig: MachineSig}.

    Definition event_trace := (seq machine_event).
    Definition schedule := (seq nat).
    Definition MachState : Type:= (schedule * event_trace * t)%type.
  
    Definition schedPeek sch: option nat:=
      match sch with
        nil => None
      | cons hd tl => Some hd
      end.
  
  Definition schedSkip sch: (seq nat):= List.tl sch.
  Definition machine_state := thread_pool.

   Inductive start_thread : forall (m: mem) {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> mem -> Prop:=
  | StartThread: forall m m' m_new tid0 ms ms' c_new vf arg
                    (ctn: containsThread ms tid0)
                    (Hcode: getThreadC ctn = Kinit vf arg)
                    (Hcmpt: mem_compatible ms m)
                    (Hperm: install_perm Hcmpt ctn m')
                    (Hinitial: initial_core semSem tid0
                                            m' c_new m_new vf (arg::nil))
                    (Hinv: invariant ms)
                    (Hms': updThread ctn (Krun c_new) (add_block Hcmpt ctn m_new) = ms'),
                    
      start_thread m ctn ms' m_new.

   Inductive resume_thread' : forall (m: mem) {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> Prop:=
  | ResumeThread: forall m tid0 ms ms' c c' X m'
                    (ctn: containsThread ms tid0)
                    (Hcmpt: mem_compatible ms m)
                    (Hperm: install_perm Hcmpt ctn m')
                    (Hat_external: at_external semSem c m' = Some X)
                    (Hafter_external: after_external semSem None c m' = Some c')
                    (Hcode: getThreadC ctn = Kresume c Vundef)
                    (Hinv: invariant ms)
                    (Hms': updThreadC ctn (Krun c')  = ms'),
      resume_thread' m ctn ms'.
  Definition resume_thread: forall m {tid0 ms},
      containsThread ms tid0 -> machine_state -> Prop:=
    @resume_thread'.

  Inductive suspend_thread': forall m {tid0} {ms:machine_state},
      containsThread ms tid0 -> machine_state -> Prop:=
  | SuspendThread: forall m tid0 ms ms' c X m'
                     (ctn: containsThread ms tid0)
                     (Hcmpt: mem_compatible ms m)
                     (Hcode: getThreadC ctn = Krun c)
                     (Hperm: install_perm Hcmpt ctn m')
                     (Hat_external: at_external semSem c m'  = Some X)
                     (Hinv: invariant ms)
                     (Hms': updThreadC ctn (Kblocked c) = ms'),
      suspend_thread' m ctn ms'.
  Definition suspend_thread: forall (m: mem) {tid0 ms},
      containsThread ms tid0 -> machine_state -> Prop:=
    @suspend_thread'.
      Class Scheduler :=
    { isCoarse : bool;
      yield: schedule -> schedule}.
  Context {scheduler : Scheduler}.

  Inductive machine_step:
    schedule -> event_trace -> machine_state -> mem -> schedule ->
    event_trace -> machine_state -> mem -> Prop :=
  | start_step:
        forall tid U ms ms' m m' tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Htstep: start_thread m Htid ms' m'),
          machine_step U tr ms m (yield U) tr ms' (diluteMem m')
    | resume_step:
        forall tid U ms ms' m tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Htstep: resume_thread m Htid ms'),
          machine_step U tr ms m (yield U) tr ms' m
    | thread_step:
        forall tid U ms ms' m m' ev tr
          (HschedN: schedPeek U = Some tid)
          (Htid: containsThread ms tid)
          (Hcmpt: mem_compatible ms m)
          (Htstep: threadStep Htid Hcmpt ms' m' ev),
          machine_step U tr ms m (yield U)
                       (tr ++ (List.map (fun mev => internal tid mev) ev)) ms' (diluteMem m')
    | suspend_step:
        forall tid U U' ms ms' m tr
          (HschedN: schedPeek U = Some tid)
          (HschedS: schedSkip U = U')        
          (Htid: containsThread ms tid)
          (Htstep:suspend_thread m Htid ms'),
          machine_step U tr ms m U' tr ms' m
    | sync_step:
        forall tid U U' ms ms' m m' ev tr
          (HschedN: schedPeek U = Some tid)
          (HschedS: schedSkip U = U')        
          (Htid: containsThread ms tid)
          (Hcmpt: mem_compatible ms m)
          (Htstep: syncStep isCoarse Htid Hcmpt ms' m' ev),
          machine_step U tr ms m U' (tr ++ [:: external tid ev]) ms' m'
    | schedfail :
        forall tid U U' ms m tr
          (HschedN: schedPeek U = Some tid)
          (Htid: ~ containsThread ms tid)
          (Hinv: invariant ms)
          (Hcmpt: mem_compatible ms m)
          (HschedS: schedSkip U = U'),        
          machine_step U tr ms m U' tr ms m.

    Definition MachStep (c:MachState) (m:mem)
               (c':MachState) (m':mem) :=
      @machine_step (fst (fst c)) (snd (fst c)) (snd c)  m
                    (fst (fst c')) (snd (fst c')) (snd c')  m'.

    Definition at_external_mach (st : MachState) (m: mem)
      : option (external_function * list val) := None.
    
    Definition after_external_mach (ov : option val) (st : MachState) (m : mem) :
      option (MachState) := None.
    
    Definition halted_machine (st : MachState) : option val :=
      match schedPeek (fst (fst st)) with
      | Some _ => None
      | _ => Some Vundef
      end.

    Definition init_machine (U:schedule) (r : option res) (m: mem)
               (st : MachState) (m': mem) (f : val) (args : list val)
      : Prop :=
      match st with (U', [::], c) => U' = U /\ init_mach r m c m' f args | _ => False end.

    Program Definition MachineCoreSemantics (U:schedule) (r : option res):
      CoreSemantics MachState mem.

    Definition make_init_machine c r:= 
        mkPool (Krun c) r.
    Definition init_machine' (the_ge : semG) m
               c m' (f : val) (args : list val) 
      : option res -> Prop := fun op_r =>
                            if op_r is Some r then 
                              init_mach op_r m (make_init_machine c r) m' f args
                            else False.
    Definition init_machine'' (op_m: option mem)(op_r : option res)(m: mem)
               (tp : thread_pool) (m': mem) (f : val) (args : list val)
      : Prop :=
      op_m = Some m /\
      if op_r is Some r then 
        init_mach op_r m tp m' f args
      else False.
    
    Definition unique_Krun tp i :=
      forall j cnti q, 
        @getThreadC _ _ _ j tp cnti = Krun q ->
        eq_nat_dec i j.

    Lemma hybrid_initial_schedule: forall m m' main vals U p st n,
        initial_core (MachineCoreSemantics U p) n m st m' main vals ->
        exists c, st = (U, nil, c).

    Inductive internal_step:
      schedule -> machine_state -> mem -> machine_state -> mem -> Prop :=
      | thread_step':
          forall tid U ms ms' m m' ev
            (HschedN: schedPeek U = Some tid)
            (Htid: containsThread ms tid)
            (Hcmpt: mem_compatible ms m)
            (Htstep: threadStep Htid Hcmpt ms' m' ev),
            internal_step U ms m ms' (diluteMem m').

      Inductive external_step:
        schedule -> event_trace -> machine_state -> mem -> schedule ->
        event_trace -> machine_state -> mem -> Prop :=
      | start_state': forall tid U ms ms' m m' tr
                        (HschedN: schedPeek U = Some tid)
                        (Htid: containsThread ms tid)
                        (Htstep: start_thread m Htid ms' m'),
          external_step U tr ms m (yield U) tr ms' (diluteMem m')
      | resume_step':
          forall tid U ms ms' m tr
            (HschedN: schedPeek U = Some tid)
            (Htid: containsThread  ms tid)
            (Htstep: resume_thread m Htid ms'),
            external_step U tr ms m (yield U) tr ms' m
      | suspend_step':
          forall tid U U' ms ms' m tr
            (HschedN: schedPeek U = Some tid)
            (HschedS: schedSkip U = U')        
            (Htid: containsThread ms tid)
            (Htstep:suspend_thread m Htid ms'),
            external_step U tr ms m U' tr ms' m
      | sync_step':
          forall tid U U' ms ms' m m' ev tr
            (HschedN: schedPeek U = Some tid)
            (HschedS: schedSkip U = U')        
            (Htid: containsThread ms tid)
            (Hcmpt: mem_compatible ms m)
            (Htstep: syncStep isCoarse Htid Hcmpt ms' m' ev),
            external_step U tr ms m  U' (tr ++ [:: external tid ev]) ms' m'
      | schedfail':
          forall tid U U' ms m tr
            (HschedN: schedPeek U = Some tid)
            (Htid: ~ containsThread ms tid)
            (Hinv: invariant ms)
            (Hcmpt: mem_compatible ms m)
            (HschedS: schedSkip U = U'),        
            external_step U tr ms m U' tr ms m.

      Lemma step_equivalence1: forall U tr st m U' tr' st' m',
          @machine_step U tr st m U' tr' st' m' ->
          (U' = yield U /\ @internal_step U st m st' m') \/
          @external_step U tr st m U' tr' st' m'.

      Lemma step_equivalence2: forall U st m st' m' tr,
          @internal_step U st m st' m' ->
          exists tr',
            @machine_step U tr st m (yield U) (tr ++ tr') st' m'.
      Lemma step_equivalence3: forall U tr st m U' tr' st' m',
          @external_step U tr st m U' tr' st' m' ->
          exists tr1, tr' = tr ++ tr1 /\ @machine_step U tr st m U' tr' st' m'.

      Set Printing Implicit.
      Program Definition new_MachineSemantics (op_m:option Mem.mem):
      
      Instance scheduler : Scheduler :=
        {| isCoarse := true;
           yield := fun x => x |}.

      Notation thread_pool := t.
      Notation C:= (semC).
      Notation G:= (semG).
      Local Notation ctl := (@ctl C).
      Notation machine_state := thread_pool.
      Notation schedule := (seq nat).
      Notation event_trace := (seq machine_event).

      Definition HybridCoarseMachine : HybridMachine :=
        @Build_HybridMachine resources Sem ThreadPool _ _ _
                             (MachineCoreSemantics)
                             (new_MachineSemantics)
                             (hybrid_initial_schedule).

      Inductive csafe (st : MachState) (m : mem) : nat -> Prop :=
      | Safe_0: csafe st m 0
      | HaltedSafe: forall n, halted_machine st -> csafe st m n
      | CoreSafe : forall tp' m' n tr
                     (Hstep: MachStep st m (fst (fst st),(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: csafe (fst (fst st),(snd (fst st)) ++ tr,tp') m' n),
          csafe st m (S n)
      | AngelSafe: forall tp' m' n (tr: event_trace)
                     (Hstep: MachStep st m (schedSkip (fst (fst st)),(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: forall U'', csafe (U'',(snd (fst st)) ++ tr,tp') m' n),
          csafe st m (S n).

      Inductive concur_safe U tp (m : mem) : nat -> Prop :=
      | concur_Safe_0: concur_safe U tp m 0
      | concur_HaltedSafe: forall n, halted_machine (U, nil, tp) -> concur_safe U tp m n
      | concur_Internal : forall tp' m' n
                     (Hstep: internal_step U tp m tp' m')
                     (Hsafe: concur_safe U tp' m' n),
          concur_safe U tp m (S n)
      | concur_External: forall tp' m' n (tr tr': event_trace)
                     (Hstep: external_step U tr tp m U tr' tp' m')
                     (Hsafe: concur_safe U tp' m' n),
          concur_safe U tp m (S n)
      | concur_External_Angel: forall tp' m' n (tr tr': event_trace)
                     (Hstep: external_step U tr tp m (schedSkip U) tr' tp' m')
                     (Hsafe: forall U'', concur_safe U'' tp' m' n),
          concur_safe U tp m (S n).
      
      Lemma csafe_reduce:
        forall sched tp tr mem n m,
          csafe (sched, tr, tp) mem n ->
          m <= n ->
          csafe (sched, tr, tp) mem m.

      Lemma schedSkip_id: forall U, schedSkip U = U -> U = nil.

      Lemma csafe_trace: forall n U tr tp m,
        csafe (U, tr, tp) m n ->
        forall tr', csafe (U, tr', tp) m n.

      Lemma csafe_concur_safe: forall U tr tp m n, csafe (U, tr, tp) m n -> concur_safe U tp m n.

      Lemma concur_safe_csafe: forall U tr tp m n, concur_safe U tp m n -> csafe (U, tr, tp) m n.

      Inductive ctrace (st : MachState) (m : mem) : event_trace -> Prop :=
      | Trace_0: ctrace st m nil 
      | Trace_Step : forall tp' m' U' tr tr'
                     (Hstep: MachStep st m (U',(snd (fst st)) ++ tr,tp') m')
                     (Hsafe: ctrace (U',(snd (fst st)) ++ tr,tp') m' tr'),
          ctrace st m (tr ++ tr').

    End HybridCoarseMachine.
  End HybridCoarseMachine.
  
  Module HybridFineMachine.
    Section HybridFineMachine.

      Variable n: nat.
      Context {resources: Resources}
              {Sem: Semantics}
              {ThreadPool : ThreadPool.ThreadPool}
              {machineSig: MachineSig}.

      Notation thread_pool := t.
      Notation C:= (semC).
      Notation G:= (semG).
      Local Notation ctl := (@ctl C).
      Notation machine_state := thread_pool.
      Notation schedule := (seq nat).  
      Notation event_trace := (seq machine_event).

      Context {dilMem : DiluteMem}.
      
      Instance scheduler : Scheduler :=
        {| isCoarse := false;
           yield := fun x => schedSkip x |}.

      Definition HybridFineMachine : HybridMachine:=
        @Build_HybridMachine resources Sem ThreadPool _ _ _
                             (MachineCoreSemantics)
                             (new_MachineSemantics)
                             (hybrid_initial_schedule).

      Inductive fsafe (tp : thread_pool) (m : mem) (U : schedule)
        : nat -> Prop :=
      | Safe_0: fsafe tp m U 0
      | HaltedSafe : forall n tr, halted_machine (U, tr, tp) -> fsafe tp m U n
      | StepSafe : forall (tp' : thread_pool) (m' : mem)
                     (tr tr': event_trace) n,
          MachStep (U, tr, tp) m (schedSkip U, tr', tp') m' ->
          fsafe tp' m' (schedSkip U) n ->
          fsafe tp m U (S n).

      Inductive ftrace (tp : thread_pool) (m : mem) (U : schedule)
        : event_trace -> Prop :=
      | Trace_0: ftrace tp m U nil
      | StepTrace : forall (tp' : thread_pool) (m' : mem)
                     (tr tr' tr'': event_trace),
          MachStep (U, tr, tp) m (schedSkip U, tr ++ tr', tp') m' ->
          ftrace tp' m' (schedSkip U) tr'' ->
          ftrace tp m U (tr' ++ tr'').
    End HybridFineMachine.
End HybridFineMachine.

End HybridMachineSig. *)

Require Import VST.concurrency.common.bounded_maps.
(* VST.concurrency.common.bounded_maps:
Require Import compcert.lib.Axioms.
Require Import compcert.lib.Maps.

Require Import VST.concurrency.common.sepcomp. Import SepComp.

Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.konig.
Require Import VST.concurrency.common.addressFiniteMap. 
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permjoin_def.
Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import VST.concurrency.common.ssromega. 

Require Import Coq.ZArith.ZArith.

Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.threadPool.

Require Import compcert.common.Memory. 
Set Bullet Behavior "Strict Subproofs".

Definition map_leq {A B} (m1: PTree.t A)(m2: PTree.t B): Prop :=
  forall p, m1 ! p -> m2 ! p.

Lemma map_leq_apply:
  forall {A B} (m1: PTree.t A)(m2: PTree.t B) p f1,

Lemma treemap_sub_map: forall {A B} (f: positive -> B -> A) m2,
    map_leq (PTree.map f m2) m2.

Definition map_empty_def {A} (m1: PMap.t (Z -> option A)):=
  m1.1 = fun _ => None.

Definition fun_leq' {A B} (f1: Z -> option A) (f2: Z -> option B): Prop :=
  forall p, f1 p -> f2 p.

Definition fun_leq {A B} (o1: option (Z -> option A)) (o2: option (Z -> option B)): Prop :=
  match o1, o2 with
  | Some f1, Some f2 => fun_leq' f1 f2
  | None, None => True
  | _, _ => False
  end.

Definition option_eq {A B} (a:option A) (b: option B): Prop :=
  match a, b with
  | Some _ , Some _ => True
  | None, None => True
  | _, _ => False
  end.

Definition bounded_nat_func_aux {A} (f: nat -> option A) hi: Prop :=
  (forall p, (p >= hi )%nat -> f p = None).

Definition bounded_nat_func' {A} (f: nat -> option A) hi: Prop :=
  (forall p, (p > hi )%nat -> f p = None).

Definition bounded_func' {A} (f: Z -> option A) hi lo: Prop :=
  (forall p, (p > hi )%Z -> f p = None) /\
  (forall p, (p < lo)%Z -> f p = None).

Definition bounded_func_op {A} (f: option (Z -> option A)) hi lo: Prop :=
  match f with
  | Some f' => bounded_func' f' hi lo
  | None => True
  end.

Definition bounded_func {A} (f: Z -> option A): Prop :=
  exists hi lo,
  bounded_func' f hi lo.

Definition bounded_map {A} (m: PTree.t (Z -> option A)):=
  forall p f, m ! p = Some f -> bounded_func f.

Fixpoint strong_tree_leq {A B}
         (t1: PTree.t A) (t2: PTree.t B)
         (leq: option A -> option B -> Prop):=
  match t1, t2 with
  | PTree.Leaf, PTree.Leaf => True
  | PTree.Node l1 o1 r1, PTree.Node l2 o2 r2 =>
    leq o1 o2 /\
    strong_tree_leq l1 l2 leq /\
    strong_tree_leq r1 r2 leq
  | _, _ => False
  end.

Definition same_shape {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=
  strong_tree_leq m1 m2 option_eq.

Definition sub_map' {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=
  forall p f1, m1 ! p = Some f1 ->
          exists f2, m2 ! p = Some f2 /\ fun_leq' f1 f2.

Definition sub_map {A B} (m1: PTree.t (Z -> option A))(m2: PTree.t (Z -> option B)):=
  strong_tree_leq m1 m2 fun_leq.

Lemma sub_map_and_shape:
  forall { A B} m1 m2,
  @same_shape A B m1 m2 ->
  sub_map' m1 m2 ->
  sub_map m1 m2.

Definition nat_to_perm (i:nat) :=
  (match i with
  | 0 => Some None
  | 1 => Some (Some Nonempty)
  | 2 => Some (Some Readable)
  | 3 => Some (Some Writable)
  | 4 => Some (Some Freeable)
  | _ => None
  end)%nat.

Definition perm_to_nat (p: option (option permission)) :=
  match p with
  | Some (None) => 0
  | Some (Some Nonempty) => 1
  | Some (Some Readable) => 2
  | Some (Some Writable) => 3
  | Some (Some Freeable) => 4
  | None => 5
  end.

Definition nat_to_perm_simpl (i:nat) :=
  (match i with
  | 0 => None
  | 1 => Some Nonempty
  | 2 => Some Readable
  | 3 => Some Writable
  | 4 => Some Freeable
  | _ => None
  end)%nat.

Definition perm_to_nat_simpl (p: option permission) :=
  match p with
  | None => 0
  | Some Nonempty => 1
  | Some Readable => 2
  | Some Writable => 3
  | Some Freeable => 4
  end.
Lemma perm_to_nat_bound:
  forall p,
    perm_to_nat p < 6.

Lemma perm_to_nat_bound_simpl:
  forall p,
    perm_to_nat_simpl p < 5.

Lemma nat_to_perm_perm_to_nat:
  forall p,
    nat_to_perm (perm_to_nat p) = p.

Lemma nat_to_perm_perm_to_nat_simpl:
  forall p,
    nat_to_perm_simpl (perm_to_nat_simpl p) = p.

Lemma finite_bounded_nat_aux_func:
  forall hi ,
    konig.finite

Lemma finite_bounded_nat_aux_func_simpl:
  forall hi ,
    konig.finite

Lemma finite_bounded_nat_func:
  forall hi ,
    konig.finite

Lemma finite_bounded_nat_func_simpl:
  forall hi ,
    konig.finite

Lemma finite_bounded_func:
  forall hi lo,
    konig.finite

Lemma finite_bounded_func_simpl:
  forall hi lo,
    konig.finite

Lemma finite_bounded_op_func_simpl:
  forall hi lo,
    konig.finite

Lemma finite_bounded_op_func:
  forall hi lo,
    konig.finite

Lemma finite_sub_maps:
  forall m2,
    @bounded_map permission m2 ->
    konig.finite
      (fun m1 => @sub_map (option permission) permission m1 m2).
Proof.
  induction m2.
  - move => _.
    exists 1%nat.
    exists (fun _ => PTree.Leaf).
    intros .
    exists 0%nat.
    split; auto.
    destruct x; auto.
    unfold strong_tree_leq in H;
      simpl in H.
    destruct o; inversion H.
  - move => H.
    assert (HH1:
              forall (p : positive) (f : Z -> option permission),
                m2_1 ! p = Some f ->
                exists hi lo : Z,
                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\
                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).
    { clear - H.
      move=> p f Hget.
      move : H => /(_ (p~0)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.
      exists hi, lo; assumption.
    }
    move: IHm2_1=> /(_ HH1) [] N1 [] F1 spec_F1.
    assert (HH2:
              forall (p : positive) (f : Z -> option permission),
                m2_2 ! p = Some f ->
                exists hi lo : Z,
                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\
                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).
    { clear - H.
      move=> p f Hget.
      move : H => /(_ (p~1)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.
      exists hi, lo; assumption.
    }
    move: IHm2_2=> /(_ HH2) [] N2 [] F2 spec_F2.
    destruct o as [f1|].
    + move : H => /(_ 1%positive f1 ltac:(reflexivity)) [] hi [] lo BNDD.
      move : (finite_bounded_op_func hi lo) => [] N [] F F_spec.
      exists (S( N * N1 * N2)).
      exists (fun n => if n == 0
               then PTree.Leaf
               else
                 PTree.Node
                   (F1 ( (n-1) mod N1))
                   (F ((n-1) / (N1 * N2)))
                   (F2 (((n-1) / N1 ) mod N2))).
      intros x spec.
      destruct x.
      * exists 0%nat; split; auto.
        omega.
      * move: spec .
        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.
        assert (bounded_func_op o hi lo).
        { Lemma fun_le_bounded_func_op:
            forall {A} o f hi lo,
              @bounded_func' A f hi lo ->
              fun_leq o (Some f) ->
              @bounded_func_op (option A) o hi lo.

Lemma finite_sub_maps_simpl:
  forall m2,
    @bounded_map permission m2 ->
    konig.finite
      (fun m1 => @sub_map permission permission m1 m2).
Proof.

  induction m2.
  - move => _.
    exists 1%nat.
    exists (fun _ => PTree.Leaf).
    intros .
    exists 0%nat.
    split; auto.
    destruct x; auto.
    unfold strong_tree_leq in H;
      simpl in H.
    destruct o; inversion H.
  - move => H.
    assert (HH1:
              forall (p : positive) (f : Z -> option permission),
                m2_1 ! p = Some f ->
                exists hi lo : Z,
                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\
                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).
    { clear - H.
      move=> p f Hget.
      move : H => /(_ (p~0)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.
      exists hi, lo; assumption.
    }
    move: IHm2_1=> /(_ HH1) [] N1 [] F1 spec_F1.
    assert (HH2:
              forall (p : positive) (f : Z -> option permission),
                m2_2 ! p = Some f ->
                exists hi lo : Z,
                  (forall p0 : Z, (p0 > hi)%Z -> f p0 = None) /\
                  (forall p0 : Z, (p0 < lo)%Z -> f p0 = None)).
    { clear - H.
      move=> p f Hget.
      move : H => /(_ (p~1)%positive f ltac:(simpl;auto)) [] hi [] lo BOUND.
      exists hi, lo; assumption.
    }
    move: IHm2_2=> /(_ HH2) [] N2 [] F2 spec_F2.
    destruct o as [f1|].
    + move : H => /(_ 1%positive f1 ltac:(reflexivity)) [] hi [] lo BNDD.
      move : (finite_bounded_op_func_simpl hi lo) => [] N [] F F_spec.
      exists (S( N * N1 * N2)).
      exists (fun n => if n == 0
               then PTree.Leaf
               else
                 PTree.Node
                   (F1 ( (n-1) mod N1))
                   (F ((n-1) / (N1 * N2)))
                   (F2 (((n-1) / N1 ) mod N2))).
      intros x spec.
      destruct x.
      * exists 0%nat; split; auto.
        omega.
      * move: spec .
        rewrite /sub_map /= => [] [] FUN_lq [] tree1 tree2.
        assert (bounded_func_op o hi lo).
        { Lemma fun_le_bounded_func_op_simpl:
            forall {A} o f hi lo,
              @bounded_func' A f hi lo ->
              fun_leq o (Some f) ->
              @bounded_func_op A o hi lo.

Lemma fun_leq_trans: forall {A B C} f1 f2 f3, @fun_leq A B f1 f2 -> @fun_leq B C f2 f3 ->
  @fun_leq A C f1 f3.

Lemma sub_map_trans: forall {A B C} m1 m2 m3, @sub_map A B m1 m2 -> @sub_map B C m2 m3 ->
  @sub_map A C m1 m3.

Lemma same_shape_map:
  forall {A B} m f,
    @same_shape A B (PTree.map f m) m. *)

Require Import VST.concurrency.juicy.juicy_machine.
(* VST.concurrency.juicy.juicy_machine:
Require Import compcert.lib.Axioms.

Require Import VST.msl.age_to.
Require Import VST.veric.base.
Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.

Require Import VST.concurrency.common.enums_equality.
Require Import VST.concurrency.common.pos.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.addressFiniteMap. 
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.juicy.rmap_locking.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.permjoin.
Require Import Coq.Program.Program.
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat ssrfun eqtype seq fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Coqlib.

Require Import List.
Require Import Coq.ZArith.ZArith.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.jstep.

Set Bullet Behavior "Strict Subproofs".

Require Import  VST.concurrency.common.permissions VST.concurrency.common.threadPool.
Import OrdinalPool ThreadPool.

Notation "x <= y" := (x <= y)%nat.
Notation "x < y" := (x < y)%nat.

Instance LocksAndResources : Resources := { res := rmap; lock_info := option rmap }.

Module ThreadPool.
  Section ThreadPool.

  Context {Sem: Semantics}.

  Definition is_lock t:= fun loc => AMap.mem loc (lset t).

  End ThreadPool.

End ThreadPool.

Module Concur.

  Section JuicyMachineShell.

    Import event_semantics Events.

    Context {Sem: Semantics}.

    Notation C:= (semC).
    Notation G:= (semG).
    Notation tid:= nat.

    Notation lockMap:= (AMap.t lock_info).
    Notation SSome x:= (Some (Some x)).
    Notation SNone:= (Some None).

    Definition richMem: Type:= juicy_mem.
    Definition dryMem: richMem -> mem:= m_dry.

    Notation the_sem := (csem (event_semantics.msem semSem)).

    Existing Instance OrdinalThreadPool.
    Notation thread_pool := (@ThreadPool.t _ _ OrdinalThreadPool).

    Definition lp_id : tid:= (0)%nat. 

    Definition access_cohere' m phi:= forall loc,
        Mem.perm_order'' (max_access_at m loc) (perm_of_res (phi @ loc)).

    Record mem_cohere' m phi :=
      { cont_coh: contents_cohere m phi;
        
        max_coh: max_access_cohere m phi;
        all_coh: alloc_cohere m phi
      }.
    Definition mem_thcohere (tp : thread_pool) m :=
      forall {tid} (cnt: containsThread tp tid), mem_cohere' m (getThreadR cnt).

    Definition mem_lock_cohere (ls:lockMap) m:=
      forall loc rm, AMap.find loc ls = SSome rm -> mem_cohere' m rm.

    Lemma length_enum_from n m pr : List.length (@enums_equality.enum_from n m pr) = n.

    Lemma length_enum n : List.length (enums_equality.enum n) = n.

    Definition getThreadsR (tp : thread_pool):=
      map (perm_maps tp) (enums_equality.enum (num_threads tp)).

    Fixpoint join_list (ls: seq.seq res) r:=
      if ls is phi::ls' then exists r', join phi r' r /\ join_list ls' r' else
        app_pred emp r.  
    Definition join_threads (tp : thread_pool) r:= join_list (getThreadsR tp) r.

    Lemma list_nth_error_eq : forall {A} (l1 l2 : list A)
      (Heq : forall j, nth_error l1 j = nth_error l2 j), l1 = l2.

    Lemma nth_error_enum : forall n m (H : (n <= m)%coq_nat) i, i < n ->
      exists Hlt, nth_error (enum_from H) i = Some (@Ordinal m (n - 1 - i)%coq_nat Hlt).

    Lemma minus_comm : forall a b c, ((a - b)%coq_nat - c = (a - c)%coq_nat - b)%coq_nat.

    Lemma getThreadsR_addThread tp v1 v2 phi :
      getThreadsR (addThread tp v1 v2 phi) = getThreadsR tp ++ phi :: nil.

    Fixpoint join_list' (ls: seq.seq (option res)) (r:option res):=
      if ls is phi::ls' then exists (r':option res),
          @join _ (@Join_lower res _) phi r' r /\ join_list' ls' r' else r=None.
    Definition join_locks tp r:= join_list' (map snd (AMap.elements (lset tp))) r.

    Inductive join_all: thread_pool -> res -> Prop:=
      AllJuice tp r0 r1 r:
        join_threads tp r0 ->
        join_locks tp r1 ->
        join (Some r0) r1 (Some r) ->
        join_all tp r.

    Definition juicyLocks_in_lockSet (lset : lockMap) (juice: rmap):=
      forall loc, 
       (forall i, 0 <= i < LKSIZE -> exists sh psh P, juice @ (fst loc, snd loc + i) = YES sh psh (LK LKSIZE i) P)  ->  
          AMap.find loc lset.

    Definition lockSet_in_juicyLocks (lset : lockMap) (juice: rmap):=
      forall loc, AMap.find loc lset ->
	     (exists sh, 
           forall i, 0 <= i < LKSIZE -> exists sh' psh' P, join_sub sh sh' /\ juice @ (fst loc, snd loc + i) = YES sh' psh' (LK LKSIZE i) P).

    Definition lockSet_in_juicyLocks' (lset : lockMap) (juice: rmap):=
      forall loc, AMap.find loc lset ->
             Mem.perm_order'' (Some Nonempty) (perm_of_res (juice @ loc)).
    Lemma lockSet_in_juic_weak: forall lset juice,
        lockSet_in_juicyLocks lset juice -> lockSet_in_juicyLocks' lset juice.

    Definition lockSet_Writable (lset : lockMap) m :=
      forall b ofs, AMap.find (b,ofs) lset ->
               forall ofs0, Intv.In ofs0 (ofs, ofs + LKSIZE)%Z ->
             Mem.perm_order'' ((Mem.mem_access m)!! b ofs0 Max) (Some Writable) .

    Definition locks_writable (juice: rmap):=
      forall loc sh psh P z i, juice @ loc = YES sh psh (LK z i) P  ->
                    Mem.perm_order'' (perm_of_res (juice @ loc)) (Some Writable).

    Record mem_compatible_with' (tp : thread_pool) m all_juice : Prop :=
      {   juice_join : join_all tp all_juice
        ; all_cohere : mem_cohere' m all_juice
        ; loc_writable : lockSet_Writable (lockGuts tp) m
        ; jloc_in_set : juicyLocks_in_lockSet (lockGuts tp) all_juice
        ; lset_in_juice: lockSet_in_juicyLocks  (lockGuts tp) all_juice
      }.

    Definition mem_compatible_with := mem_compatible_with'.

    Definition mem_compatible tp m := ex (mem_compatible_with tp m).

    Lemma jlocinset_lr_valid: forall ls juice,
        lockSet_in_juicyLocks ls juice ->
        lr_valid (AMap.find (elt:=lock_info)^~ (ls)).

    Lemma compat_lr_valid: forall js m,
        mem_compatible js m ->
        lr_valid (lockRes js).

    Lemma mem_compatible_locks_ltwritable':
      forall js m, lockSet_Writable (lockGuts js) m ->
                permMapLt (lockSet js) (getMaxPerm m ).

    Lemma mem_compatible_locks_ltwritable:
      forall tp m, mem_compatible tp m ->
              permMapLt (lockSet tp) (getMaxPerm m ).
        Lemma compat_lt_m: forall m js,
        mem_compatible js m ->
        forall b ofs,
          Mem.perm_order'' ((getMaxPerm m) !! b ofs)

    Lemma compatible_lockRes_join:
      forall (js : thread_pool) (m : mem),
        mem_compatible js m ->
        forall (l1 l2 : address) (phi1 phi2 : rmap),
          l1 <> l2 ->
          ThreadPool.lockRes js l1 = Some (Some phi1) ->

    Definition disjoint_threads tp :=
      forall i j (cnti : containsThread tp i)
        (cntj: containsThread tp j) (Hneq: i <> j),
        joins (getThreadR(resources:=LocksAndResources) cnti)
              (getThreadR cntj).
    
    Definition disjoint_locks tp :=
      forall loc1 loc2 r1 r2,
        lockRes tp loc1 = SSome r1 ->
        lockRes tp loc2 = SSome r2 ->
        joins r1 r2.
    
    Definition disjoint_lock_thread tp :=
      forall i loc r (cnti : containsThread tp i),
        lockRes tp loc = SSome r ->
        joins (getThreadR cnti)r.

    Variant invariant' (tp:t) := True. 
         Definition invariant := invariant'.

    Definition mapmap {A B} (def:B) (f:positive -> A -> B) (m:PMap.t A): PMap.t B:=
      (def, PTree.map f m#2).
    
    Definition juice2Perm (phi:rmap)(m:mem): access_map:=
      mapmap (fun _ => None) (fun block _ => fun ofs => perm_of_res (phi @ (block, ofs)) ) (getMaxPerm m).
    Definition juice2Perm_locks (phi:rmap)(m:mem): access_map:=
      mapmap (fun _ => None) (fun block _ => fun ofs => perm_of_res_lock (phi @ (block, ofs)) ) (getMaxPerm m).
    Lemma juice2Perm_canon: forall phi m, isCanonical (juice2Perm phi m).
    Lemma juice2Perm_locks_canon: forall phi m, isCanonical (juice2Perm_locks phi m).
    Lemma juice2Perm_nogrow: forall phi m b ofs,
        Mem.perm_order'' (perm_of_res (phi @ (b, ofs)))
    Lemma juice2Perm_locks_nogrow: forall phi m b ofs,
        Mem.perm_order'' (perm_of_res_lock (phi @ (b, ofs)))
    Lemma juice2Perm_cohere: forall phi m,
        access_cohere' m phi ->
        permMapLt (juice2Perm phi m) (getMaxPerm m).
    Lemma juice2Perm_locks_cohere: forall phi m,
        max_access_cohere m phi ->
        permMapLt (juice2Perm_locks phi m) (getMaxPerm m).

    Lemma Mem_canonical_useful: forall m loc k,
        (Mem.mem_access m)#1 loc k = None.

    Lemma juic2Perm_locks_correct:
      forall r m b ofs,
        max_access_cohere m r ->
        perm_of_res_lock (r @ (b,ofs)) = (juice2Perm_locks r m) !! b ofs.

    Lemma juic2Perm_correct:
      forall r m b ofs,
        access_cohere' m r ->
        perm_of_res (r @ (b,ofs)) = (juice2Perm r m) !! b ofs.

    Definition juicyRestrict {phi:rmap}{m:Mem.mem}(coh:access_cohere' m phi): Mem.mem:=
      restrPermMap (juice2Perm_cohere coh).
    Definition juicyRestrict_locks {phi:rmap}{m:Mem.mem}(coh:max_access_cohere m phi): Mem.mem:=
      restrPermMap (juice2Perm_locks_cohere coh).
    Lemma juicyRestrictContents: forall phi m (coh:access_cohere' m phi),
        forall loc, contents_at m loc = contents_at (juicyRestrict coh) loc.
    Lemma juicyRestrictMax: forall phi m (coh:access_cohere' m phi),
        forall loc, max_access_at m loc = max_access_at (juicyRestrict coh) loc.
    Lemma juicyRestrictNextblock: forall phi m (coh:access_cohere' m phi),
        Mem.nextblock m = Mem.nextblock (juicyRestrict coh).
    Lemma juicyRestrictContentCoh: forall phi m (coh:access_cohere' m phi) (ccoh:contents_cohere m phi),
        contents_cohere (juicyRestrict coh) phi.
    Lemma juicyRestrictMaxCoh: forall phi m (coh:access_cohere' m phi) (ccoh:max_access_cohere m phi),
        max_access_cohere (juicyRestrict coh) phi.
    Lemma juicyRestrictAllocCoh: forall phi m (coh:access_cohere' m phi) (ccoh:alloc_cohere m phi),
        alloc_cohere (juicyRestrict coh) phi.

    Lemma juicyRestrictCurEq:
      forall (phi : rmap) (m : mem) (coh : access_cohere' m phi)
     (loc : Address.address),

    Lemma juicyRestrictAccCoh: forall phi m (coh:access_cohere' m phi),
        access_cohere (juicyRestrict coh) phi.

    Lemma po_perm_of_res: forall r,
       Mem.perm_order''  (perm_of_res' r) (perm_of_res r).

    Lemma max_acc_coh_acc_coh: forall m phi,
        max_access_cohere m phi -> access_cohere' m phi.

    Definition juicyRestrict':=
      fun phi m macoh => @juicyRestrict phi m (max_acc_coh_acc_coh macoh).

    Lemma juicyRestrictAccCoh': forall phi m (coh:max_access_cohere m phi),
        access_cohere (juicyRestrict' coh) phi.

    Lemma po_join_sub': forall r1 r2 : resource,
       join_sub r2 r1 ->
       Mem.perm_order'' (perm_of_res' r1) (perm_of_res' r2).

    Lemma mem_access_coh_sub: forall phi1 phi2 m,
          max_access_cohere m phi1 ->
          join_sub phi2 phi1 ->
          max_access_cohere m phi2.

    Lemma mem_cohere_sub: forall phi1 phi2 m,
          mem_cohere' m phi1 ->
          join_sub phi2 phi1 ->
          mem_cohere' m phi2.

    Lemma compatible_threadRes_sub:
        forall js i (cnt:containsThread js i),
        forall all_juice,
          join_all js all_juice ->
          join_sub (getThreadR cnt) all_juice.

    Lemma mem_compat_thread_max_cohere {tp m} (compat: mem_compatible tp m):
      forall {i} cnti,
        max_access_cohere m (@getThreadR _ _ _ i tp cnti).

    Lemma thread_mem_compatible: forall tp m,
        mem_compatible tp m ->
        mem_thcohere tp m.

    Lemma compatible_lockRes_sub: forall js l phi,
        lockRes js l = Some (Some phi) ->
        forall all_juice,
          join_all js all_juice ->
          join_sub phi all_juice.

    Lemma lock_mem_compatible: forall tp m,
        mem_compatible tp m ->
        mem_lock_cohere (lockGuts tp) m.

    Definition acc_coh:= fun m phi pr => @max_acc_coh_acc_coh m phi (max_coh pr).
    Definition personal_mem {m phi} (pr : mem_cohere' m phi) : juicy_mem:=
      mkJuicyMem
        (@juicyRestrict phi m (acc_coh pr))
        phi
        (juicyRestrictContentCoh (acc_coh pr) (cont_coh pr))
        (juicyRestrictAccCoh (acc_coh pr))
        (juicyRestrictMaxCoh (acc_coh pr) (max_coh pr))
        (juicyRestrictAllocCoh (acc_coh pr) (all_coh pr)).

    Definition juicy_sem := (FSem.F _ _ JuicyFSem.t) _ the_sem.
    
    Program Definition first_phi (tp : thread_pool) : rmap := (@getThreadR _ _ _ 0%nat tp _).

    Program Definition level_tp (tp : thread_pool) := level (first_phi tp).

    Definition tp_level_is_above n tp :=
      (forall i (cnti : containsThread tp i), le n (level (getThreadR cnti))) /\
      (forall i phi, lockRes(resources:=LocksAndResources) tp i = Some (Some phi) -> le n (level phi)).

    Definition tp_level_is n tp :=
      (forall i (cnti : containsThread tp i), level (getThreadR cnti) = n) /\
      (forall i phi, lockRes(resources:=LocksAndResources) tp i = Some (Some phi) -> level phi = n).

    Definition cnt_from_ordinal tp : forall i : ordinal (pos.n (num_threads tp)), containsThread tp i.

    Definition age_tp_to (k : nat) (tp : thread_pool) : thread_pool :=
      match tp with
        mk n pool maps lset =>
        mk n pool
           ((age_to k) oo maps)
           (AMap.map (option_map (age_to k)) lset)
      end.

    Lemma level_age_tp_to tp k : tp_level_is_above k tp -> tp_level_is k (age_tp_to k tp).

    Lemma map_compose {A B C} (g : A -> B) (f : B -> C) l : map (f oo g) l = map f (map g l).

    Lemma join_list_age_to k l Phi :
      le k (level Phi) ->
      join_list l Phi ->
      join_list (map (age_to k) l) (age_to k Phi).

    Lemma join_list'_age_to k (l : list (option res)) (Phi : option res) :
      (match Phi with None => Logic.True | Some phi => le k (level phi) end) ->

    Lemma join_all_age_to k tp Phi :
      le k (level Phi) ->
      join_all tp Phi ->
      join_all (age_tp_to k tp) (age_to k Phi).

    Lemma perm_of_age rm age loc :
      perm_of_res (age_to age rm @ loc) = perm_of_res (rm @ loc).

    Lemma perm_of_age_lock rm age loc :
      perm_of_res_lock (age_to age rm @ loc) = perm_of_res_lock (rm @ loc).

    Lemma almost_empty_perm: forall rm,
        res_predicates.almost_empty rm ->

    Lemma cnt_age {js i age} :
        containsThread (age_tp_to age js) i ->
        containsThread js i.

    Lemma cnt_age' {js i age} :
        containsThread js i ->
        containsThread (age_tp_to age js) i.

    Lemma age_getThreadCode:
      forall i tp age cnt cnt',
        @getThreadC _ _ _ i tp cnt = @getThreadC _ _ _ i (age_tp_to age tp) cnt'.

    Inductive juicy_step  {tid0 tp m} (cnt: containsThread tp tid0)
      (Hcompatible: mem_compatible tp m) : thread_pool -> mem -> list mem_event -> Prop :=
    | step_juicy :
        forall (tp':thread_pool) c jm jm' m' (c' : C),
          forall (Hpersonal_perm:
               personal_mem (thread_mem_compatible Hcompatible cnt) = jm)
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt = Krun c)
            (Hcorestep: corestep juicy_sem c jm c' jm')
            (Htp': tp' = @updThread _ _ _ tid0 (age_tp_to (level jm') tp) (cnt_age' cnt) (Krun c') (m_phi jm'))
            (Hm': m_dry jm' = m'),
            juicy_step  cnt Hcompatible tp' m' [::].

    Definition pack_res_inv (R: pred rmap) := SomeP rmaps.Mpred (fun _ => R) .
  
    Definition lock_at_least sh R phi b ofs :=
          forall i, 0 <= i < LKSIZE -> exists sh' rsh', join_sub sh sh' /\ phi@(b,ofs+i) = YES sh' rsh' (LK LKSIZE i) (pack_res_inv R).

    Notation Kblocked := (threadPool.Kblocked).
    Open Scope Z_scope.
    Inductive syncStep' {isCoarse: bool} {tid0 tp m}
              (cnt0:containsThread tp tid0)(Hcompat:mem_compatible tp m):
      thread_pool -> mem -> sync_event -> Prop :=
    | step_acquire :
        forall (tp' tp'' tp''':thread_pool) c m0 m1 b ofs d_phi phi phi' m' pmap_tid',
          forall
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (LOCK, Vptr b ofs::nil))
            (Hcompatible: mem_compatible tp m)
                        (Hpersonal_juice: getThreadR cnt0 = phi)
            (sh:Share.t)(R:pred rmap)
            (HJcanwrite: lock_at_least sh R phi b (Ptrofs.intval ofs))
            (Hrestrict_map0: juicyRestrict_locks
                              (mem_compat_thread_max_cohere Hcompat cnt0) = m0)
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.one))
                        (Hset_perm: setPermBlock (Some Writable)
                                       b (Ptrofs.intval ofs) (juice2Perm_locks phi m) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
                        (Hrestrict_pmap: restrPermMap Hlt' = m1)
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
            (His_unlocked: lockRes tp (b, Ptrofs.intval ofs) = SSome d_phi )
            (Hadd_lock_res: join phi d_phi phi')
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) phi')
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) None )
            (Htp''': tp''' = age_tp_to (level phi - 1)%coq_nat tp''),
            syncStep' cnt0 Hcompat tp''' m' (acquire (b, Ptrofs.intval ofs) None)
    | step_release :
        forall  (tp' tp'' tp''':thread_pool) c m0 m1 b ofs  (phi d_phi :rmap) (R: pred rmap) phi' m' pmap_tid',
          forall
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (UNLOCK, Vptr b ofs::nil))
            (Hcompatible: mem_compatible tp m)
                        (Hpersonal_juice: getThreadR cnt0 = phi)
            (sh:Share.t) 
            (HJcanwrite: lock_at_least sh R phi b (Ptrofs.intval ofs))
            (Hrestrict_map0: juicyRestrict_locks
                              (mem_compat_thread_max_cohere Hcompat cnt0) = m0)
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.zero))
                        (Hset_perm: setPermBlock (Some Writable)
                                       b (Ptrofs.intval ofs) (juice2Perm_locks phi m) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
                        (Hrestrict_pmap: restrPermMap Hlt' = m1)
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.one) = Some m')
            (His_locked: lockRes tp (b, Ptrofs.intval ofs) = SNone )
            (Hsat_lock_inv: R (age_by 1 d_phi))
            (Hrem_lock_res: join d_phi phi' phi)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) phi')
            (Htp'': tp'' =
                    updLockSet tp' (b, Ptrofs.intval ofs) (Some d_phi))
            (Htp''': tp''' = age_tp_to (level phi - 1)%coq_nat tp''),
            syncStep' cnt0 Hcompat tp''' m' (release (b, Ptrofs.intval ofs) None)
    | step_create :
        forall  (tp_upd tp':thread_pool) c vf arg jm (d_phi phi': rmap) b ofs ,
          forall
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (CREATE, vf::arg::nil))
            (Harg: Val.inject (Mem.flat_inj (Mem.nextblock m)) arg arg)
            (Hfun_sepc: vf = Vptr b ofs)
            (Hcompatible: mem_compatible tp m)
            (Hpersonal_perm:
               personal_mem (thread_mem_compatible Hcompatible cnt0) = jm)
            (Hrem_fun_res: join d_phi phi' (m_phi jm))
            (Htp': tp_upd = updThread cnt0 (Kresume c Vundef) phi')
            (Htp'': tp' = age_tp_to (level (m_phi jm) - 1)%coq_nat (addThread tp_upd vf arg d_phi)),
            syncStep' cnt0 Hcompat tp' m (spawn (b, Ptrofs.intval ofs) None None)
    | step_mklock :
        forall  (tp' tp'': thread_pool)  jm c b ofs R ,
          let: phi := m_phi jm in
          forall
            phi' m'
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (MKLOCK, Vptr b ofs::nil))
            (Hcompatible: mem_compatible tp m)
            
            (Hpersonal_perm:
               personal_mem (thread_mem_compatible Hcompatible cnt0) = jm)
            (Hpersonal_juice: getThreadR cnt0 = phi)
            
            (Hstore:
               Mem.store Mint32 (m_dry jm) b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
                        (Hrmap : rmap_makelock phi phi' (b, Ptrofs.unsigned ofs) R LKSIZE)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) phi')
            (Htp'': tp'' = age_tp_to (level phi - 1)%coq_nat
                    (updLockSet tp' (b, Ptrofs.intval ofs) None )),
            syncStep' cnt0 Hcompat tp'' m' (mklock (b, Ptrofs.intval ofs))
    | step_freelock :
        forall  (tp' tp'': thread_pool) c b ofs phi R phi',
          forall
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (FREE_LOCK, Vptr b ofs::nil))
            (Hcompatible: mem_compatible tp m)
            (Hpersonal_juice: getThreadR cnt0 = phi)
            
            (His_acq: lockRes tp (b, (Ptrofs.intval ofs)) = SNone)
            
            (Hrmap : rmap_freelock phi phi' m (b, Ptrofs.unsigned ofs) R LKSIZE)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) phi')
            (Htp'': tp'' = age_tp_to (level phi - 1)%coq_nat
                    (remLockSet tp' (b, Ptrofs.intval ofs) )),
            syncStep' cnt0 Hcompat  tp'' m (freelock (b, Ptrofs.intval ofs))

    | step_acqfail :
        forall  c b ofs jm m1,
          let: phi := m_phi jm in
          forall
            (Hinv : invariant tp)
            (Hthread: getThreadC cnt0 = Kblocked c)
            (Hat_external: at_external the_sem c m =
                           Some (LOCK, Vptr b ofs::nil))
            (Hcompatible: mem_compatible tp m)
            (Hpersonal_perm:
               personal_mem (thread_mem_compatible Hcompatible cnt0) = jm)
            (Hrestrict_map: juicyRestrict_locks
                              (mem_compat_thread_max_cohere Hcompat cnt0) = m1)
            (sh:Share.t) (R:pred rmap)
            (HJcanwrite: lock_at_least sh R phi b (Ptrofs.intval ofs))
            (Hload: Mem.load Mint32 m1 b (Ptrofs.intval ofs) = Some (Vint Int.zero)),
            syncStep' cnt0 Hcompat tp m (failacq (b,Ptrofs.intval ofs)).

    Definition threadStep : forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> list mem_event -> Prop:=
      @juicy_step.

    Lemma threadStep_at_Krun:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        (exists q, @getThreadC _ _ _ i tp cnt = Krun q).

    Lemma threadStep_equal_run:
    forall i tp m cnt cmpt tp' m' tr,
      @threadStep i tp m cnt cmpt tp' m' tr ->
      forall j,
        (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
        (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Definition syncStep (isCoarse:bool) :
      forall {tid0 ms m}, containsThread ms tid0 -> mem_compatible ms m ->
                     thread_pool -> mem -> sync_event ->  Prop:=
      @syncStep' isCoarse.

  Lemma syncstep_equal_run:
    forall b i tp m cnt cmpt tp' m' tr,
      @syncStep b i tp m cnt cmpt tp' m' tr ->
      forall j,
        (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
        (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

  Lemma syncstep_not_running:
    forall b i tp m cnt cmpt tp' m' tr,
      @syncStep b i tp m cnt cmpt tp' m' tr ->
      forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q.

    Definition initial_machine rmap c:=
      mk
        (mkPos (le_n 1))
        (fun _ => (Krun c))
        (fun _ => rmap)
        (AMap.empty (option res)).

    Definition init_mach rmap (m:mem) (tp:thread_pool) (m':mem) (v:val) (args:list val) : Prop :=
      exists c, initial_core the_sem 0 m c m' v args /\
        match rmap with Some rmap => tp = initial_machine rmap c | None => False end.

    Section JuicyMachineLemmas.

      Lemma compat_lockLT': forall js m,
        mem_compatible js m ->
        forall l r,
          ThreadPool.lockRes js l = Some (Some r) ->

      Lemma compat_lockLT: forall js m,
             mem_compatible js m ->
             forall l r,
             ThreadPool.lockRes js l = Some (Some r) ->

    Lemma access_cohere_sub': forall phi1 phi2 m,
        access_cohere' m phi1 ->
        join_sub phi2 phi1 ->
        access_cohere' m phi2.

      Lemma mem_cohere'_juicy_mem jm : mem_cohere' (m_dry jm) (m_phi jm).

      Lemma compatible_threadRes_join:
        forall js m,
          mem_compatible js m ->
          forall i (cnti: containsThread js i) j (cntj: containsThread js j),
            i <> j ->
            sepalg.joins (getThreadR cnti) (getThreadR cntj).

      Lemma compatible_threadRes_lockRes_join:
        forall js m,
          mem_compatible js m ->
          forall i (cnti: containsThread js i) l phi,
            ThreadPool.lockRes js l = Some (Some phi) ->

      Lemma compatible_lockRes_cohere: forall js m l phi,
          lockRes js l = Some (Some phi) ->
          mem_compatible js m ->
          mem_cohere' m phi .

      Lemma compatible_threadRes_cohere:
        forall js m i (cnt:containsThread js i),
          mem_compatible js m ->
          mem_cohere' m (getThreadR cnt) .

      Lemma cnt_age_iff {js i n} :
          containsThread js i <->
          containsThread (age_tp_to n js) i.

      Lemma gtc_age : forall js i n,
          forall (cnt: containsThread js i)
            (cnt': containsThread (age_tp_to n js) i),
            getThreadC cnt = getThreadC cnt'.

      Lemma getThreadR_age: forall js i age,
          forall (cnt: containsThread js i)
            (cnt': containsThread (age_tp_to age js) i),
            age_to age (getThreadR cnt) = getThreadR cnt'.

      Lemma LockRes_age: forall js age a,
          isSome (lockRes (age_tp_to age js) a) = isSome(lockRes js a).

      Lemma LockRes_age_content1: forall js age a,
          lockRes (age_tp_to age js) a = Some None ->
          lockRes js a = Some None.

      Lemma LockRes_age_content2: forall js age a rm,
          lockRes (age_tp_to age js) a = Some (Some rm) ->
          exists r, lockRes js a = Some (Some r) /\ rm = age_to age r.

      Lemma access_cohere'_age m : hereditary age (access_cohere' m).

      Lemma access_cohere'_unage m : hereditary unage (access_cohere' m).

      Lemma mem_cohere'_age m : hereditary age (mem_cohere' m).

      Lemma mem_cohere'_unage m : hereditary unage (mem_cohere' m).

      Lemma mem_cohere_age_to n m phi :
        mem_cohere' m phi ->
        mem_cohere' m (age_to n phi).

      Lemma mem_cohere_age_to_opp n m phi :
        mem_cohere' m (age_to n phi) ->
        mem_cohere' m phi.

    End JuicyMachineLemmas.

    Definition install_perm {tp m tid} (Hcompat : mem_compatible tp m) (cnt : containsThread tp tid) :=
      juicyRestrict (max_acc_coh_acc_coh (max_coh (thread_mem_compatible Hcompat cnt))).

    Definition add_block {tp m tid} (Hcompat : mem_compatible tp m) (cnt : containsThread tp tid) (m' : mem) :=
      getThreadR cnt.

    Instance JuicyMachineShell : HybridMachineSig.MachineSig :=
      HybridMachineSig.Build_MachineSig richMem dryMem mem_compatible invariant
        (fun _ _ _ compat cnt m => m = install_perm compat cnt) (fun _ _ _ => add_block)
        (@threadStep)
        threadStep_at_Krun threadStep_equal_run syncStep syncstep_equal_run syncstep_not_running
        init_mach.

  End JuicyMachineShell.

End Concur. *)

Require Import VST.concurrency.common.HybridMachine.
(* VST.concurrency.common.HybridMachine:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool ssrfun.
Require Import compcert.common.Memory.
Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.

Require Import VST.msl.Axioms.
Require Import Coq.ZArith.ZArith.
Require Import VST.concurrency.common.core_semantics.
Require Import VST.sepcomp.event_semantics.
Require Export VST.concurrency.common.semantics.
Require Export VST.concurrency.common.lksize.
Require Import VST.concurrency.common.threadPool.

Require Import VST.concurrency.common.machine_semantics.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.bounded_maps.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.scheduler.
Require Import Coq.Program.Program.

Require Import VST.concurrency.common.HybridMachineSig.

Module DryHybridMachine.
  Import Events ThreadPool.

  Instance dryResources: Resources:=
    {| res := access_map * access_map;
       lock_info := access_map * access_map |}.

  Section DryHybridMachine.
        
    Context {Sem: Semantics}
            {tpool : @ThreadPool.ThreadPool dryResources Sem}.
    
    Notation C:= (@semC Sem).
    Notation G:= (@semG Sem).
    Notation semSem:= (@semSem Sem).

    Notation thread_pool := (@t dryResources Sem).
    
    Definition richMem: Type:= mem.
    Definition dryMem: richMem -> mem:= fun x => x.
    
    Record mem_compatible (tp: thread_pool) m : Prop :=
      { compat_th :> forall {tid} (cnt: containsThread tp tid),
            permMapLt (getThreadR cnt).1 (getMaxPerm m) /\
            permMapLt (getThreadR cnt).2 (getMaxPerm m);
        compat_lp : forall l pmaps, lockRes tp l = Some pmaps ->
                               permMapLt pmaps.1 (getMaxPerm m) /\
                               permMapLt pmaps.2 (getMaxPerm m);
        lockRes_blocks: forall l rmap, lockRes tp l = Some rmap ->
                                  Mem.valid_block m l.1}.

    Record invariant (tp: thread_pool) :=
      { no_race_thr :
          forall i j (cnti: containsThread tp i) (cntj: containsThread tp j)
            (Hneq: i <> j),
            permMapsDisjoint2 (getThreadR cnti)
                              (getThreadR cntj); 
        no_race_lr:
          forall laddr1 laddr2 rmap1 rmap2
            (Hneq: laddr1 <> laddr2)
            (Hres1: lockRes tp laddr1 = Some rmap1)
            (Hres2: lockRes tp laddr2 = Some rmap2),
            permMapsDisjoint2 rmap1 rmap2; 
        no_race:
          forall i laddr (cnti: containsThread tp i) rmap
            (Hres: lockRes tp laddr = Some rmap),
            permMapsDisjoint2 (getThreadR cnti) rmap; 
        thread_data_lock_coh:
          forall i (cnti: containsThread tp i),
            (forall j (cntj: containsThread tp j),
                permMapCoherence (getThreadR cntj).1 (getThreadR cnti).2) /\
            (forall laddr rmap,
                lockRes tp laddr = Some rmap ->
                permMapCoherence rmap.1 (getThreadR cnti).2);
        locks_data_lock_coh:
          forall laddr rmap
            (Hres: lockRes tp laddr = Some rmap),
            (forall j (cntj: containsThread tp j),
                permMapCoherence (getThreadR cntj).1 rmap.2) /\
            (forall laddr' rmap',
                lockRes tp laddr' = Some rmap' ->
                permMapCoherence rmap'.1 rmap.2);
        lockRes_valid: lr_valid (lockRes tp) 
      }.

    Inductive dry_step {tid0 tp m} (cnt: containsThread tp tid0)
              (Hcompatible: mem_compatible tp m) :
      thread_pool -> mem -> seq.seq mem_event -> Prop :=
    | step_dry :
        forall (tp':thread_pool) c m1 m' (c' : C) ev
          
          (Hrestrict_pmap: restrPermMap (Hcompatible tid0 cnt).1 = m1)
          (Hinv: invariant tp)
          (Hcode: getThreadC cnt = Krun c)
          (Hcorestep: ev_step semSem c m1 ev c' m')
                    (Htp': tp' = updThread cnt (Krun c') (getCurPerm m', (getThreadR cnt).2)),
          dry_step cnt Hcompatible tp' m' ev.

    Definition option_function {A B} (opt_f: option (A -> B)) (x:A): option B:=
      match opt_f with
        Some f => Some (f x)
      | None => None
      end.
    Infix "??" := option_function (at level 80, right associativity).

    Definition build_delta_content (dm: delta_map) (m:mem): delta_content :=
      PTree.map (fun b dm_f =>
                   fun ofs =>
                     match dm_f ofs with
                     | None | Some (None) 
                     | Some (Some Nonempty) => None
                     | Some _ => Some (ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m)))
                     end) dm.
    
    Inductive ext_step {isCoarse:bool} {tid0 tp m}
              (cnt0:containsThread tp tid0)(Hcompat:mem_compatible tp m):
      thread_pool -> mem -> sync_event -> Prop :=
    | step_acquire :
        forall (tp' tp'':thread_pool) marg m0 m1 c m' b ofs
          (pmap : lock_info)
          (pmap_tid' : access_map)
          (virtueThread : delta_map * delta_map)
          (Hbounded: if isCoarse then
                       ( sub_map virtueThread.1 (getMaxPerm m).2 /\
                         sub_map virtueThread.2 (getMaxPerm m).2)
                     else
                       True ),
          let newThreadPerm := (computeMap (getThreadR cnt0).1 virtueThread.1,
                                computeMap (getThreadR cnt0).2 virtueThread.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (LOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap0: restrPermMap (Hcompat tid0 cnt0).2 = m0)
            
            (Haccess: Mem.range_perm m0 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
            
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.one))
            
            (Hset_perm: setPermBlock (Some Writable)
                                     b (Ptrofs.intval ofs) ((getThreadR cnt0).2) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
            (Hrestrict_pmap: restrPermMap Hlt' = m1)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
            (HisLock: lockRes tp (b, Ptrofs.intval ofs) = Some pmap)
            (Hangel1: permMapJoin pmap.1 (getThreadR cnt0).1 newThreadPerm.1)
            (Hangel2: permMapJoin pmap.2 (getThreadR cnt0).2 newThreadPerm.2)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) newThreadPerm)
            
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) (empty_map, empty_map)),
            ext_step cnt0 Hcompat tp'' m'
                     (acquire (b, Ptrofs.intval ofs)
                              (Some (build_delta_content (fst virtueThread) m')))

    | step_release :
        forall (tp' tp'':thread_pool) marg m0 m1 c m' b ofs virtueThread virtueLP pmap_tid' rmap
          (Hbounded: if isCoarse then
                       ( sub_map virtueThread.1 (getMaxPerm m).2 /\
                         sub_map virtueThread.2 (getMaxPerm m).2)
                     else
                       True )
          (HboundedLP: if isCoarse then
                         ( map_empty_def virtueLP.1 /\
                           map_empty_def virtueLP.2 /\
                           sub_map virtueLP.1.2 (getMaxPerm m).2 /\
                           sub_map virtueLP.2.2 (getMaxPerm m).2)
                       else
                         True ),
          let newThreadPerm := (computeMap (getThreadR cnt0).1 virtueThread.1,
                                computeMap (getThreadR cnt0).2 virtueThread.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg =
                           Some (UNLOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap0: restrPermMap (Hcompat tid0 cnt0).2 = m0)
            
            (Haccess: Mem.range_perm m0 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
            (Hload: Mem.load Mint32 m0 b (Ptrofs.intval ofs) = Some (Vint Int.zero))
            
            (Hset_perm: setPermBlock (Some Writable)
                                     b (Ptrofs.intval ofs) ((getThreadR cnt0).2) LKSIZE_nat = pmap_tid')
            (Hlt': permMapLt pmap_tid' (getMaxPerm m))
            (Hrestrict_pmap: restrPermMap Hlt' = m1)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.one) = Some m')
            (HisLock: lockRes tp (b, Ptrofs.intval ofs) = Some rmap)
            (Hrmap: forall b ofs, rmap.1 !! b ofs = None /\ rmap.2 !! b ofs = None)
            (Hangel1: permMapJoin newThreadPerm.1 virtueLP.1 (getThreadR cnt0).1)
            (Hangel2: permMapJoin newThreadPerm.2 virtueLP.2 (getThreadR cnt0).2)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef)
                                   (computeMap (getThreadR cnt0).1 virtueThread.1,
                                    computeMap (getThreadR cnt0).2 virtueThread.2))
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) virtueLP),
            ext_step cnt0 Hcompat tp'' m'
                     (release (b, Ptrofs.intval ofs)
                              (Some (build_delta_content (fst virtueThread) m')))
    | step_create :
        forall (tp_upd tp':thread_pool) c marg b ofs arg virtue1 virtue2
          (Hbounded: if isCoarse then
                       ( sub_map virtue1.1 (getMaxPerm m).2 /\
                         sub_map virtue1.2 (getMaxPerm m).2)
                     else
                       True )
          (Hbounded_new: if isCoarse then
                           ( sub_map virtue2.1 (getMaxPerm m).2 /\
                             sub_map virtue2.2 (getMaxPerm m).2)
                         else
                           True ),
          let threadPerm' := (computeMap (getThreadR cnt0).1 virtue1.1,
                              computeMap (getThreadR cnt0).2 virtue1.2) in
          let newThreadPerm := (computeMap empty_map virtue2.1,
                                computeMap empty_map virtue2.2) in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (CREATE, Vptr b ofs::arg::nil))
            (Harg: Val.inject (Mem.flat_inj (Mem.nextblock m)) arg arg)
                        (Hangel1: permMapJoin newThreadPerm.1 threadPerm'.1 (getThreadR cnt0).1)
            (Hangel2: permMapJoin newThreadPerm.2 threadPerm'.2 (getThreadR cnt0).2)
            (Htp_upd: tp_upd = updThread cnt0 (Kresume c Vundef) threadPerm')
            (Htp': tp' = addThread tp_upd (Vptr b ofs) arg newThreadPerm),
            ext_step cnt0 Hcompat tp' m
                     (spawn (b, Ptrofs.intval ofs)
                            (Some (build_delta_content (fst virtue1) m))
                            (Some (build_delta_content (fst virtue2) m)))

    | step_mklock :
        forall  (tp' tp'': thread_pool) marg m1 c m' b ofs pmap_tid',
          let: pmap_tid := getThreadR cnt0 in
          forall
            (Hinv : invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (MKLOCK, Vptr b ofs::nil))
            
            (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).1 = m1)
            
            (Hfreeable: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Writable)
            
            (Hstore: Mem.store Mint32 m1 b (Ptrofs.intval ofs) (Vint Int.zero) = Some m')
            
            (Hdata_perm: setPermBlock
                           (Some Nonempty)
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.1
                           LKSIZE_nat = pmap_tid'.1)
            
            (Hlock_perm: setPermBlock
                           (Some Writable)
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.2
                           LKSIZE_nat = pmap_tid'.2)
            
            (HlockRes: lockRes tp (b, Ptrofs.intval ofs) = None)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) pmap_tid')
            
            (Htp'': tp'' = updLockSet tp' (b, Ptrofs.intval ofs) (empty_map, empty_map)),
            ext_step cnt0 Hcompat tp'' m' (mklock (b, Ptrofs.intval ofs))

    | step_freelock :
        forall  (tp' tp'': thread_pool) c marg b ofs pmap_tid' m1 pdata rmap
           (Hbounded: if isCoarse then
                        ( bounded_maps.bounded_nat_func' pdata LKSIZE_nat)
                      else
                        True ),
          let: pmap_tid := getThreadR cnt0 in
          forall
            (Hinv: invariant tp)
            (Hcode: getThreadC cnt0 = Kblocked c)
            
            (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
            (Hat_external: semantics.at_external semSem c marg = Some (FREE_LOCK, Vptr b ofs::nil))
            
            (His_lock: lockRes tp (b, (Ptrofs.intval ofs)) = Some rmap)
            
            (Hrmap: forall b ofs, rmap.1 !! b ofs = None /\ rmap.2 !! b ofs = None)
            
            (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).2 = m1)
            
            (Hfreeable: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Writable)
            
            (Hlock_perm: setPermBlock
                           None
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.2
                           LKSIZE_nat = pmap_tid'.2)
            
            (Hneq_perms: forall i,
                (0 <= Z.of_nat i < LKSIZE)%Z ->
                Mem.perm_order'' (pdata (S i)) (Some Writable)
            )
            
            (Hdata_perm: setPermBlock_var 
                           pdata
                           b
                           (Ptrofs.intval ofs)
                           pmap_tid.1
                           LKSIZE_nat = pmap_tid'.1)
            (Htp': tp' = updThread cnt0 (Kresume c Vundef) pmap_tid')
            (Htp'': tp'' = remLockSet tp' (b, Ptrofs.intval ofs)),
            ext_step cnt0 Hcompat  tp'' m (freelock (b, Ptrofs.intval ofs))
    | step_acqfail :
        forall  c b ofs marg m1
           (Hinv : invariant tp)
           (Hcode: getThreadC cnt0 = Kblocked c)
           
           (Hrestrict_pmap_arg: restrPermMap (Hcompat tid0 cnt0).1 = marg)
           (Hat_external: semantics.at_external semSem c marg = Some (LOCK, Vptr b ofs::nil))
           
           (Hrestrict_pmap: restrPermMap (Hcompat tid0 cnt0).2 = m1)
           
           (Haccess: Mem.range_perm m1 b (Ptrofs.intval ofs) ((Ptrofs.intval ofs) + LKSIZE) Cur Readable)
           
           (Hload: Mem.load Mint32 m1 b (Ptrofs.intval ofs) = Some (Vint Int.zero)),
          ext_step cnt0 Hcompat tp m (failacq (b, Ptrofs.intval ofs)).

    Definition threadStep: forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> seq.seq mem_event -> Prop:=
      @dry_step.

    Lemma threadStep_at_Krun:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        (exists q, @getThreadC _ _ _ i tp cnt = Krun q).
    
    Lemma threadStep_equal_run:
      forall i tp m cnt cmpt tp' m' tr,
        @threadStep i tp m cnt cmpt tp' m' tr ->
        forall j,
          (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
          (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Definition syncStep (isCoarse:bool) :
      forall {tid0 ms m},
        containsThread ms tid0 -> mem_compatible ms m ->
        thread_pool -> mem -> sync_event -> Prop:=
      @ext_step isCoarse.

    Lemma syncstep_equal_run:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall j,
          (exists cntj q, @getThreadC _ _ _ j tp cntj = Krun q) <->
          (exists cntj' q', @getThreadC _ _ _ j tp' cntj' = Krun q').

    Lemma syncstep_not_running:
      forall b i tp m cnt cmpt tp' m' tr,
        @syncStep b i tp m cnt cmpt tp' m' tr ->
        forall cntj q, ~ @getThreadC _ _ _ i tp cntj = Krun q.

    Definition initial_machine pmap c := mkPool (Krun c) (pmap, empty_map).

    Definition init_mach (pmap : option res) (m: mem)
               (ms:thread_pool) (m' : mem) (v:val) (args:list val) : Prop :=
      exists c, semantics.initial_core semSem 0 m c m' v args /\
           ms = mkPool (Krun c) (getCurPerm m', empty_map).
    Set Printing All.
    Section HybDryMachineLemmas.

      Lemma build_delta_content_restr: forall d m p Hlt,
        build_delta_content d (@restrPermMap p m Hlt) = build_delta_content d m.

      Lemma threads_canonical:
        forall ds m i (cnt:containsThread ds i),
          mem_compatible ds m ->
          isCanonical (getThreadR cnt).1 /\
      
    End HybDryMachineLemmas.

    Definition install_perm tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) m' :=
      m' = restrPermMap (Hcmpt tid Hcnt).1.

    Definition add_block tp m tid (Hcmpt: mem_compatible tp m) (Hcnt: containsThread tp tid) m' :=
      (getCurPerm m', (getThreadR Hcnt).2).

    Instance DryHybridMachineSig: @HybridMachineSig.MachineSig dryResources Sem tpool :=
      (@HybridMachineSig.Build_MachineSig dryResources Sem tpool
                             richMem
                             dryMem
                             mem_compatible
                             invariant
                             install_perm
                             add_block
                             (@threadStep)
                             threadStep_at_Krun
                             threadStep_equal_run
                             (@syncStep)
                             syncstep_equal_run
                             syncstep_not_running
                             init_mach
      ).

  End DryHybridMachine.
End DryHybridMachine.

Export DryHybridMachine. *)

Require Import VST.concurrency.common.dry_machine_lemmas.
(* VST.concurrency.common.dry_machine_lemmas:
Require Import compcert.lib.Axioms.

Require Import VST.concurrency.common.sepcomp. Import SepComp.
Require Import VST.sepcomp.semantics_lemmas.

Require Import VST.concurrency.common.pos.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat seq ssrfun eqtype fintype finfun.
Set Implicit Arguments.

Require Import compcert.common.AST.     
Require Import compcert.common.Values. 
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.

Require Import compcert.lib.Integers.
Require Import Coq.ZArith.ZArith.

Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.tactics.

Global Notation "a # b" := (Maps.PMap.get b a) (at level 1).

Module ThreadPoolWF.
  Import HybridMachine ThreadPool DryHybridMachine HybridMachineSig.
  Section ThreadPoolWF.
    Context {Sem : Semantics}.
    
    Existing Instance DryHybridMachine.dryResources.
    Existing Instance OrdinalPool.OrdinalThreadPool.   
    
    Existing Instance DryHybridMachine.DryHybridMachineSig.

  Lemma unlift_m_inv :
    forall tp tid (Htid : tid < (OrdinalPool.num_threads tp).+1) ord

  Lemma initial_invariant0: forall pmap c,
      DryHybridMachine.invariant (mkPool c (pmap, empty_map)).

  Lemma updThread_inv: forall ds i (cnt: containsThread ds i) c pmap,
      invariant ds ->
      (forall j (cnt: containsThread ds j),
          i<>j -> permMapsDisjoint pmap.1 (getThreadR cnt).1 /\

  Lemma invariant_decr:
    forall tp c pmap i (cnti: containsThread tp i)
      (Hinv: invariant tp)
      (Hdecr1: forall b ofs,
          Mem.perm_order'' ((getThreadR cnti).1 # b ofs)

  Lemma updThreadC_invariant:
    forall (tp : t) i c
      (ctn : containsThread tp i)
      (Hinv : invariant tp),
      invariant (updThreadC ctn c).

  Lemma updLock_inv:
    forall tp b ofs rmap
      (Hinv: invariant tp)
      (Hdisjoint_res: forall laddr rmap',
          laddr <> (b, ofs) ->
          lockRes tp laddr = Some rmap' ->
          permMapsDisjoint2 rmap rmap')
      (Hdisjoint_thr: forall i (cnti: containsThread tp i),
          permMapsDisjoint2 (getThreadR cnti) rmap)
      (Hcoh_res: forall laddr rmap',
          laddr <> (b, ofs) ->
          lockRes tp laddr = Some rmap' ->
          permMapCoherence rmap.1 rmap'.2 /\

  Lemma mem_compatible_add:
    forall tp i (cnti: containsThread tp i) c pmap vf arg pmap2 m
      (Hcomp: mem_compatible
                (addThread
                   (updThread cnti c pmap) vf arg pmap2) m),
      mem_compatible (updThread cnti c pmap) m.

  Lemma mem_compatible_remlock:
    forall tp m addr
      (Hinv: lr_valid (lockRes tp))
      (Hcomp: mem_compatible tp m),
      mem_compatible (remLockSet tp addr) m.

  Lemma remLock_inv: forall ds a,
           invariant ds ->
           invariant (remLockSet ds a).

  Lemma invariant_add:
    forall tp i (cnti: containsThread tp i) c pmap1 pmap2 vf arg
      (Hinv: invariant
               (addThread
                  (updThread cnti c pmap1)
                  vf arg pmap2)),
      invariant (updThread cnti c pmap1).

  Lemma invariant_not_freeable:
    forall tp
      (Hinv: invariant tp),
    forall b ofs,
      (forall i (cnti: containsThread tp i), (getThreadR cnti).2 # b ofs <> Some Freeable) /\

  Lemma invariant_freeable_empty_threads:
    forall tp i (cnti: containsThread tp i) b ofs
      (Hinv: invariant tp)
      (Hfreeable: (getThreadR cnti).1 !! b ofs = Some Freeable),

  Lemma invariant_freeable_empty_locks:
    forall tp i (cnti: containsThread tp i) b ofs
      (Hinv: invariant tp)
      (Hfreeable: (getThreadR cnti).1 !! b ofs = Some Freeable),

  Lemma mem_compatible_invalid_block:
    forall tp m b ofs
      (Hcomp: mem_compatible tp m)
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma init_thread:
    forall m m' pmap f arg tp i
      (Hinit: init_mach pmap m tp m' f arg),
      containsThread tp i ->
      i = 0.

  Lemma getThreadR_init:
    forall pmap m m' f arg tp
      (Hinit: init_mach pmap m tp m' f arg)
      (cnt: containsThread tp 0),
      getThreadR cnt = (getCurPerm m', empty_map).

  Lemma init_lockRes_empty:
    forall m m' pmap f arg tp laddr
      (Hinit: init_mach pmap m tp m' f arg),
      lockRes tp laddr = None.

  Lemma initial_invariant:
    forall m m' pmap f arg tp
      (Hinit: init_mach pmap m tp m' f arg),
      invariant tp.

End ThreadPoolWF.
End ThreadPoolWF.

Module CoreLanguage.
  Import event_semantics.
    Section CoreLanguage.
      Context {Sem : Semantics}.

      Class SemAxioms :=
        { 
          corestep_unchanged_on:
            forall  c m c' m' b ofs
              (Hstep: corestep (msem semSem) c m c' m')
              (Hvalid: Mem.valid_block m b)
              (Hstable: ~ Mem.perm m b ofs Cur Writable),
              Maps.ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m)) =
              Maps.ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m'));          
          
          corestep_decay:
            forall c c' m m',
              corestep semSem c m c' m' ->
              decay m m';
          
          corestep_nextblock:
            forall c m c' m',
              corestep semSem c m c' m' ->
              (Mem.nextblock m <= Mem.nextblock m')%positive;
          
          at_external_halted_excl:
            forall q m, at_external semSem q m = None \/ forall i, ~ halted semSem q i;
                    initial_core_unchanged_on:
            forall  i v args c m m' b ofs
               (Hstep: initial_core semSem i m c m' v args)
               (Hvalid: Mem.valid_block m b)
               (Hstable: ~ Mem.perm m b ofs Cur Writable),
              Maps.ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m)) =
              Maps.ZMap.get ofs (Maps.PMap.get b (Mem.mem_contents m'));
          
          initial_core_decay:
            forall i v args c m m',
              initial_core semSem i m c m' v args ->
              strong_decay m m';
          
          initial_core_nextblock:
            forall i v args c m m',
              initial_core semSem i m c m' v args ->
              (Mem.nextblock m <= Mem.nextblock m')%positive;
        }.
      Class SemDet :=
        { 
          corestep_det: corestep_fun semSem;
          
          initial_core_det:
            forall i m v args c c' m' m'',
              initial_core semSem i m c m' v args ->
              initial_core semSem i m c' m'' v args ->
              c = c' /\ m' = m''
        }.

      Context {SemAx : SemAxioms} {SemD : SemDet}.

      Lemma corestep_validblock:
        forall c m c' m',
          corestep semSem c m c' m' ->
          forall b, Mem.valid_block m b ->

      Lemma initial_core_validblock:
        forall i c m m' v args,
          initial_core semSem i m c m' v args ->
          forall b, Mem.valid_block m b ->

      Definition ev_step_det:
        forall (m m' m'' : mem) (c c' c'' : semC) ev ev',
          ev_step semSem c m ev c' m' ->
          ev_step semSem c m ev' c'' m'' -> c' = c'' /\ m' = m'' /\ ev = ev'.

      Lemma ev_unchanged_on:
        forall c m c' m' b ofs ev
          (Hstep: ev_step semSem c m ev c' m')
          (Hvalid: Mem.valid_block m b)

      Lemma ev_step_decay:
        forall c c' m m' ev,
          ev_step semSem c m ev c' m' ->
          decay m m'.

      Lemma ev_step_nextblock:
        forall  c m ev c' m',
          ev_step semSem c m ev c' m' ->
          (Mem.nextblock m <= Mem.nextblock m')%positive.

      Lemma ev_step_validblock:
        forall  c m ev c' m',
          ev_step semSem c m ev c' m' ->
          forall b, Mem.valid_block m b ->

    End CoreLanguage.
End CoreLanguage.

Module CoreLanguageDry.
  Import CoreLanguage.
  Import HybridMachine ThreadPool event_semantics HybridMachineSig.

  Section CoreLanguageDry.
    Context {Sem : Semantics}
            {SemAx : SemAxioms}.

    Existing Instance OrdinalPool.OrdinalThreadPool.
    Existing Instance DryHybridMachine.dryResources.
    
    Existing Instance DryHybridMachine.DryHybridMachineSig.

  Lemma corestep_containsThread:
    forall (tp : t)  c c' m m' p i j ev
      (Hcnti : containsThread tp i)
      (Hcntj: containsThread tp j)
      (Hcorestep: ev_step semSem c m ev c' m')
      (Hcode: getThreadC Hcnti = Krun c),
      containsThread (updThread Hcnti (Krun c') p) j.

  Lemma corestep_containsThread':
    forall (tp : t)  c c' m m' p i j ev
      (Hcnti : containsThread tp i)
      (Hcntj : containsThread (updThread Hcnti (Krun c') p) j)
      (Hcorestep: ev_step semSem c m ev c' m')
      (Hcode: getThreadC Hcnti = Krun c),
      containsThread tp j.

  Lemma decay_compatible:
    forall (tp : t)  (m m' : mem) i
      (pf : containsThread tp i) (c': semC)
      (Hinv: invariant tp)
      (Hcompatible : mem_compatible tp m)
      (Hdecay: decay (restrPermMap (DryHybridMachine.compat_th _ _ Hcompatible pf).1) m')

  Lemma corestep_compatible:
    forall (tp : t)  (m m' : mem) i ev
      (pf : containsThread tp i) (c c': semC)
      (Hinv: invariant tp)
      (Hcode: getThreadC pf = Krun c)
      (Hcompatible : mem_compatible tp m)
      (Hcorestep: ev_step semSem c (restrPermMap (DryHybridMachine.compat_th _ _ Hcompatible pf).1) ev c' m'),

  Lemma initial_core_compatible:
    forall (tp : t)  (m m' : mem) i n vf arg
      (pf : containsThread tp i) (c: semC)
      (Hinv: invariant tp)
      (Hcompatible : mem_compatible tp m)
      (Hinitial: initial_core semSem n (restrPermMap (DryHybridMachine.compat_th _ _ Hcompatible pf).1) c m' vf arg),

  Lemma decay_disjoint:
    forall m m' p
      (Hdecay: decay m m')
      (Hlt: permMapLt p (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint (getCurPerm m) p),
      permMapsDisjoint (getCurPerm m') p.

  Lemma decay_coherence :
    forall (m m' : mem) (pmap : access_map)
      (Hdecay: decay m m')
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hcoh: permMapCoherence (getCurPerm m) pmap),
      permMapCoherence (getCurPerm m') pmap.

  Lemma decay_invariant:
    forall tp m m1 m1' i (pf: containsThread tp i) c
      (Hinv : invariant tp)
      (Hcompatible : mem_compatible tp m)
      (Hrestrict_pmap : restrPermMap (Hcompatible i pf)#1 = m1)
      (Hdecay: decay m1 m1'),
      invariant (updThread pf (Krun c) (getCurPerm m1', (getThreadR pf)#2)).
  
  Lemma initial_core_invariant:
    forall (tp : t)  (m : mem) (i : nat) n
      (pf : containsThread tp i) c m1 m' vf arg
      (Hinv: invariant tp)
      (Hcompatible: mem_compatible tp m)
      (Hrestrict_pmap: restrPermMap (DryHybridMachine.compat_th _ _ Hcompatible pf).1 = m1)
  
  Lemma corestep_invariant:
    forall (tp : t)  (m : mem) (i : nat)
      (pf : containsThread tp i) c m1 m1' c'
      (Hinv: invariant tp)
      (Hcompatible: mem_compatible tp m)
      (Hrestrict_pmap: restrPermMap (DryHybridMachine.compat_th _ _ Hcompatible pf).1 = m1)

  Lemma corestep_stable_val:
    forall  c c' m m' pmap1 pmap2
      (Hlt1: permMapLt pmap1 (getMaxPerm m))
      (Hlt2: permMapLt pmap2 (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pmap1 pmap2 \/ permMapCoherence pmap1 pmap2)
      (Hstep: corestep semSem c (restrPermMap Hlt1) c' m'),
    forall b ofs (Hreadable: Mem.perm (restrPermMap Hlt2) b ofs Cur Readable),

  Corollary corestep_disjoint_val:
    forall (tp : t)  (m m' : mem) i j (Hneq: i <> j)
      (c c' : semC)
      (pfi : containsThread tp i) (pfj : containsThread tp j)
      (Hcomp : mem_compatible tp m) (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_th _ _ Hcomp pfj).1) b ofs Cur Readable \/

  Corollary corestep_disjoint_locks:
    forall (tp : t) (m m' : mem) i j (c c' : semC)
      (pfi : containsThread tp i) (pfj : containsThread tp j)
      (Hcomp : mem_compatible tp m) (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_th _ _ Hcomp pfj).2) b ofs Cur Readable)

  Lemma corestep_disjoint_val_lockpool :
    forall (tp : t)  (m m' : mem) i (c c' : semC)
      (pfi : containsThread tp i) (Hcomp : mem_compatible tp m) addr pmap
      (Hlock: lockRes tp addr = Some pmap)
      (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_lp _ _ Hcomp _ _ Hlock).1)

  Lemma initial_core_stable_val:
    forall  n c m m' pmap1 pmap2 v arg
      (Hlt1: permMapLt pmap1 (getMaxPerm m))
      (Hlt2: permMapLt pmap2 (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pmap1 pmap2 \/ permMapCoherence pmap1 pmap2)
      (Hstep: initial_core semSem n (restrPermMap Hlt1) c m' v arg),
    forall b ofs (Hreadable: Mem.perm (restrPermMap Hlt2) b ofs Cur Readable),

    Corollary initial_core_disjoint_val:
    forall (tp : t)  (m m' : mem) i j (Hneq: i <> j) n v arg
      (c c' : semC)
      (pfi : containsThread tp i) (pfj : containsThread tp j)
      (Hcomp : mem_compatible tp m) (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_th _ _ Hcomp pfj).1) b ofs Cur Readable \/

  Corollary initial_core_disjoint_locks:
    forall (tp : t) (m m' : mem) i j (c : semC) n v arg
      (pfi : containsThread tp i) (pfj : containsThread tp j)
      (Hcomp : mem_compatible tp m) (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_th _ _ Hcomp pfj).2) b ofs Cur Readable)

  Lemma initial_core_disjoint_val_lockpool :
    forall (tp : t)  (m m' : mem) i (c c' : semC) n v arg
      (pfi : containsThread tp i) (Hcomp : mem_compatible tp m) addr pmap
      (Hlock: lockRes tp addr = Some pmap)
      (b : block) (ofs : Z)
      (Hreadable: Mem.perm (restrPermMap (DryHybridMachine.compat_lp _ _ Hcomp _ _ Hlock).1)

  Lemma permMapLt_decay:
    forall pmap m m'
      (Hdecay: strong_decay m m')
      (Hlt: permMapLt pmap (getMaxPerm m)),
      permMapLt pmap (getMaxPerm m').
    
  End CoreLanguageDry.
End CoreLanguageDry. *)

Require Import VST.concurrency.common.lksize.
(* VST.concurrency.common.lksize:
Require Import compcert.common.AST.
Require Import compcert.common.Memdata.
Require Import Coq.ZArith.ZArith.

Definition LKSIZE:= (2 * size_chunk Mptr)%Z.
Definition LKSIZE_nat:= Z.to_nat LKSIZE.

Lemma LKSIZE_pos : (0 < LKSIZE)%Z.

Lemma LKSIZE_int : (size_chunk Mint32 < LKSIZE)%Z.

Ltac lkomega := pose proof LKSIZE_pos; pose proof LKSIZE_int; simpl in *; try omega. *)

Require Import VST.concurrency.common.permissions.
(* VST.concurrency.common.permissions:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool
        ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.
Require Import VST.msl.Coqlib2.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permjoin_def.
Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import compcert.lib.Integers.
Require Export compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
From VST.veric Require Import shares juicy_mem juicy_mem_lemmas.
Require Import VST.msl.msl_standard.
Require Import FunInd.
Import cjoins.

Require Import ProofIrrelevance.

Lemma po_refl: forall p, Mem.perm_order'' p p.

Lemma perm_order_antisym :
  forall p p'
    (Hlt: Mem.perm_order'' p p')

Definition access_map := Maps.PMap.t (Z -> option permission).
Definition delta_map := Maps.PTree.t (Z -> option (option permission)).

Section permMapDefs.

  Definition empty_map : access_map :=
    (fun z => None, Maps.PTree.empty (Z -> option permission)).

  Lemma empty_map_spec: forall b ofs,
      Maps.PMap.get b empty_map ofs = None.

  Definition permission_at (m : mem) (b : block) (ofs : Z) (k : perm_kind) :=
    Maps.PMap.get b (Mem.mem_access m) ofs k.

  Definition perm_coh (p1 p2 : option permission) :=
    match p1 with
    | Some Freeable | Some Writable | Some Readable =>
                                      match p2 with
                                      | None => True
                                      | _ => False
                                      end
    | Some Nonempty | None =>
                      match p2 with
                      | Some Freeable => False
                      | _ => True
                      end
    end.

  Lemma perm_coh_lower:
    forall p1 p2 p3 p4
      (Hpu: perm_coh p1 p2)
      (Hperm2: Mem.perm_order'' p2 p4)

  Lemma perm_coh_not_freeable:
    forall p p',
      perm_coh p p' ->
      p' <> Some Freeable.

  Lemma perm_coh_empty_1:
    forall p,
      perm_coh p None.

  Lemma perm_coh_empty_2:
    forall p : option permission,
      Mem.perm_order'' (Some Writable) p ->

  Lemma perm_of_glb_not_Freeable: forall sh,
      ~ perm_of_sh (Share.glb Share.Rsh sh) = Some Freeable.

  Lemma perm_coh_self: forall res,
      perm_coh (perm_of_res res)
               (perm_of_res_lock res).

  Lemma perm_coh_joins:
    forall a b, joins a b ->
           perm_coh (perm_of_res a) (perm_of_res_lock b).

  Lemma po_join_sub_lock:
  forall r1 r2 ,
    join_sub r2 r1 ->
    Mem.perm_order'' (perm_of_res_lock r1) (perm_of_res_lock r2).

  Definition permMapCoherence (pmap1 pmap2 : access_map) :=
    forall b ofs, perm_coh (pmap1 !! b ofs) (pmap2 !! b ofs).

  Lemma permCoh_empty: forall r,
      (forall b ofs, Mem.perm_order'' (Some Writable) (r !! b ofs)) ->

  Lemma permCoh_empty': forall x,
      permMapCoherence x empty_map.

  Lemma perm_of_res_lock_not_Freeable:
    forall r,
      Mem.perm_order'' (Some Writable) (perm_of_res_lock r).

  Definition perm_union (p1 p2 : option permission) : option (option permission) :=
    match p1,p2 with
      | None, _ => Some p2
      | _, None => Some p1
      | Some p1', Some p2' =>
        match p1', p2' with
          | Freeable, _ => None
          | _, Freeable => None
          | Nonempty, _ => Some p2
          | _, Nonempty => Some p1
          | Writable, _ => None
          | _, Writable => None
          | Readable, Readable => Some (Some Readable)
        end
    end.

  Lemma perm_union_comm :
    forall p1 p2,
      perm_union p1 p2 = perm_union p2 p1.

  Lemma perm_union_result : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                              pu = p1 \/ pu = p2.

  Lemma perm_union_ord : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Lemma perm_union_lower:
    forall p1 p2 p3
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p2 p3),

  Lemma perm_union_lower_2:
    forall p1 p2 p3 p4
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p1 p3)

  Inductive not_racy : option permission -> Prop :=
  | empty : not_racy None.

  Inductive racy : option permission -> Prop :=
  | freeable : racy (Some Freeable).

  Lemma not_racy_union :
    forall p1 p2 (Hnot_racy: not_racy p1),
    exists pu, perm_union p1 p2 = Some pu.

  Lemma no_race_racy : forall p1 p2 (Hracy: racy p1)
                              (Hnorace: exists pu, perm_union p1 p2 = Some pu),
                         not_racy p2.

  Lemma perm_order_clash:
    forall p p'
      (Hreadable: Mem.perm_order' p Readable)

  Lemma perm_order_incompatible:
    forall p p'
      (Hreadable: Mem.perm_order'' p (Some Readable))

  Definition perm_max (p1 p2 : option permission) : option permission :=
    match p1,p2 with
      | Some Freeable, _ => p1
      | _, Some Freeable => p2
      | Some Writable, _ => p1
      | _, Some Writable => p2
      | Some Readable, _ => p1
      | _, Some Readable => p2
      | Some Nonempty, _ => p1
      | _, Some Nonempty => p2
      | None, None => None
    end.

  Lemma perm_max_comm :
    forall p1 p2,
      perm_max p1 p2 = perm_max p2 p1.

  Lemma perm_max_result : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                            pu = p1 \/ pu = p2.

  Lemma perm_max_ord : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Definition getMaxPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Max) (Mem.mem_access m).

  Definition getCurPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Cur) (Mem.mem_access m).

  Definition getPermMap (m : mem) : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    Mem.mem_access m.

  Lemma getCur_Max : forall m b ofs,
                       Mem.perm_order'' (Maps.PMap.get b (getMaxPerm m) ofs)

  Lemma getMaxPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getMaxPerm m) ofs = permission_at m b ofs Max.

  Lemma getCurPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getCurPerm m) ofs = permission_at m b ofs Cur.

  Definition permDisjoint p1 p2:=
    exists pu : option permission,
      perm_union p1 p2 = Some pu.

   Lemma permDisjoint_None: forall p,
      permDisjoint None p.

  Lemma permDisjoint_comm: forall p1 p2,
      permDisjoint p1 p2 -> permDisjoint p2 p1.

  Lemma permDisjointLT: forall a b c,
      permDisjoint a c ->
      Mem.perm_order'' a b ->

  Ltac if_simpl:=
    repeat match goal with
           | [ H: ?X = true |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = false |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = left _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: ?X = right _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: (@is_left _ _ ?X) = true |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           | [ H: (@is_left _ _ ?X) = false |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           end.

  Ltac permDisj_solve:= eexists; simpl; reflexivity.
  
  Lemma join_sh_permDisjoint:
        forall sh1 sh2,
          joins sh1 sh2 ->
          permDisjoint (perm_of_sh sh1) (perm_of_sh sh2).
  
  Lemma writable0_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ readable_share sh2.

  Lemma writable0_not_join_writable0 :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ writable0_share sh2.
 
  Lemma joins_permDisjoint: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res r1) (perm_of_res r2).
  
  Ltac glb_contradictions:=
    repeat match goal with
           | [ H: writable0_share_dec _ = _ |- _ ] => clear H
           end;
    match goal with
    | [ H:  Share.glb Share.Rsh ?sh = Share.top  |- _ ] =>
      exfalso; eapply glb_Rsh_not_top; eassumption
    | [ H: writable0_share (Share.glb Share.Rsh ?sh) |- _ ] =>
      eapply writable0_right in H
    end; join_sh_contradiction.
  
  Lemma joins_permDisjoint_lock: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res_lock r1) (perm_of_res_lock r2).
  
  Definition permMapsDisjoint (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs, exists pu,
      perm_union ((Maps.PMap.get b pmap1) ofs)
                 ((Maps.PMap.get b pmap2) ofs) = Some pu.

  Definition permMapsDisjoint2 (pmap pmap': access_map * access_map) :=
    permMapsDisjoint pmap.1 pmap'.1 /\
    permMapsDisjoint pmap.2 pmap'.2.

  Lemma permDisjoint_permMapsDisjoint: forall r1 r2,
      (forall b ofs, permDisjoint (r1 !! b ofs) (r2 !! b ofs))->
      permMapsDisjoint r1 r2.

  Lemma permMapsDisjoint_permDisjoint: forall r1 r2 b ofs,
      permMapsDisjoint r1 r2 ->
      permDisjoint (r1 !! b ofs) (r2 !! b ofs).

  Lemma empty_disjoint':
    forall pmap,
      permMapsDisjoint empty_map pmap.
  Lemma empty_disjoint:
    permMapsDisjoint empty_map
                     empty_map.

  Lemma permMapsDisjoint_comm :
    forall pmap1 pmap2
      (Hdis: permMapsDisjoint pmap1 pmap2),
      permMapsDisjoint pmap2 pmap1.

  Lemma permMapsDisjoint2_comm:
    forall pmaps pmaps',
      permMapsDisjoint2 pmaps pmaps' <-> permMapsDisjoint2 pmaps' pmaps.

  Lemma disjoint_norace:
    forall (mi mj : mem) (b : block) (ofs : Z)
      (Hdisjoint: permMapsDisjoint (getCurPerm mi) (getCurPerm mj))
      (Hpermj: Mem.perm mj b ofs Cur Readable)

  Definition isCanonical (pmap : access_map) := pmap.1 = fun _ => None.
  Import Maps.
  Definition TreeMaxIndex {A} (t:Maps.PTree.t A): positive:=
    compcert.lib.Coqlib.list_fold_left (fun a => [eta Pos.max a.1]) 1%positive (Maps.PTree.elements t) .
  Lemma fold_max_monoton: forall  {A} (ls: seq.seq (positive * A)), forall i,
  Lemma fold_max_monoton': forall  {A} (ls: seq.seq (positive * A)), forall i j,
  Lemma TreeMaxIndex_help: forall {A} (ls: seq.seq (positive * A)), forall i v,

  Lemma max_works: forall A (t:PTree.t A) m, (m > TreeMaxIndex t)%positive ->

  Lemma Cur_isCanonical: forall m, isCanonical (getCurPerm m).

  Lemma Max_isCanonical: forall m, isCanonical (getMaxPerm m).

  Definition permMapLt (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs,
      Mem.perm_order'' (Maps.PMap.get b pmap2 ofs)
                       (Maps.PMap.get b pmap1 ofs).

  Lemma empty_LT: forall pmap,
             permMapLt empty_map pmap.

  Lemma canonical_lt :
    forall p' m
      (Hlt: permMapLt p' (getMaxPerm m)),
      isCanonical p'.

   Lemma invalid_block_empty:
    forall pmap m
      (Hlt: permMapLt pmap (getMaxPerm m)),
    forall b, ~ Mem.valid_block m b ->

  Definition setPerm (p : option permission) (b : block)
             (ofs : Z) (pmap : access_map) : access_map :=
    Maps.PMap.set b (fun ofs' => if compcert.lib.Coqlib.zeq ofs ofs' then
                                p
                              else
                                Maps.PMap.get b pmap ofs')
                  pmap.

   Fixpoint setPermBlock (p : option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm p b (ofs + (Z_of_nat len))%Z (setPermBlock p b ofs pmap len)
    end.

  Lemma setPermBlock_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock p b ofs pmap sz)) ofs' =

  Lemma setPermBlock_or:
    forall p b ofs sz pmap b' ofs',
      (setPermBlock p b ofs pmap sz) !! b' ofs' = p \/
      (setPermBlock p b ofs pmap sz) !! b' ofs' = pmap !! b' ofs'.

  Fixpoint setPermBlock_var (fp : nat -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp length) b (ofs + (Z_of_nat len))%Z
              (setPermBlock_var fp b ofs pmap len)
    end.

  Lemma setPermBlock_var_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock_var p b ofs pmap sz)) ofs' =

   Lemma setPermBlock_var_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_var_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_setPermBlock_var:
    forall b ofs sz pmap p,
      setPermBlock p b ofs pmap sz =
      setPermBlock_var (fun _ => p) b ofs pmap sz.

  Lemma permMapCoherence_increase:
    forall pmap pmap' b ofs sz_nat sz
      (Hsz: sz = Z.of_nat (sz_nat))

  Fixpoint setPermBlockFunc (fp : Z -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp (ofs + (Z_of_nat len))%Z) b (ofs + (Z_of_nat len))%Z (setPermBlockFunc fp b ofs pmap len)
    end.

  Lemma setPermBlockFunc_same:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_1:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_2:
    forall fp b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock fp b ofs pmap sz)) ofs' =

  Lemma setPermBlock_coherent:
    forall pmap pmap' b ofs sz
      (Hcoh: permMapCoherence pmap pmap')
      (Hnonempty: forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat sz)%Z ->

  Definition computeMap (pmap : access_map) (delta : delta_map) : access_map :=
    (pmap.1,
     @Maps.PTree.combine (Z -> option permission) (Z -> option (option permission))
                         (Z -> option permission)
                         (fun p1 pd => match pd, p1 with
                                    | Some pd', Some p1' =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => p1' z
                                                  end)
                                    | Some pd', None =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => pmap.1 z
                                                  end)
                                    | None, _ => p1
                                    end)
                         pmap.2 delta).

  Lemma computeMap_1 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df (p : option permission),
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_2 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df,
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_3 :
    forall (pmap : access_map) (dmap : delta_map) b ofs,
      Maps.PTree.get b dmap = None ->

  Import Maps BlockList.

  Definition maxF (f : Z -> perm_kind -> option permission) :=
    fun ofs k => match k with
              | Max => Some Freeable
              | Cur => f ofs k
              end.

  Definition allF (f : Z -> perm_kind -> option permission) :=
    fun (_ : Z) (_ : perm_kind) => Some Freeable.

  Fixpoint PList (f : (Z -> perm_kind -> option permission) ->
                      Z -> perm_kind -> option permission)
           l m : list (positive * (Z -> perm_kind -> option permission)) :=
    match l with
      | nil => nil
      | x :: l =>
        (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m)
  end.

  Lemma PList_app :
    forall l m x f,
      (PList f l m) ++ ((Pos.of_nat x,

  Lemma PList_cons :
    forall f l m x,
      (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m) =

  Lemma PList_correct :
    forall f l m k v
           (HInl: List.In k l)

  Lemma PList_mkBlock_complete :
    forall f k v m n
           (Hk: k > 0)
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m)),

  Lemma PList_mkBlock_det :
    forall n f k v v' m
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m))

  Fixpoint canonicalPTree (l : list (positive * (Z -> perm_kind -> option permission))) :=
    match l with
      | nil => PTree.empty _
      | x :: l =>
        PTree.set (fst x) (snd x) (canonicalPTree l)
    end.

  Lemma canonicalPTree_elements :
    forall l x
           (Hin: List.In x (PTree.elements (canonicalPTree l))),

  Lemma canonicalPTree_get_complete :
    forall l m k f fn
           (HGet: (canonicalPTree (PList fn l m)) ! k = Some f),
      List.In (k, f) (PList fn l m).

  Lemma canonicalPTree_get_sound :
    forall n m k fn
           (Hk: k > 0)
           (Hn: n > 1)
           (HGet: (canonicalPTree (PList fn (mkBlockList n) m)) ! (Pos.of_nat k) = None),

  Definition canonicalPMap fn n m : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    let l := mkBlockList n in
    (fun _ _ => None, canonicalPTree (PList fn l m)).

  Lemma canonicalPMap_sound :
    forall k n m fn
           (Hk : k > 0)
           (Hkn : k < n),
      fn (m !! (Pos.of_nat k)) = (canonicalPMap fn n m) !! (Pos.of_nat k).

  Lemma canonicalPMap_default :
    forall n k m fn
           (Hkn : k >= n),
      (canonicalPMap fn n m) !! (Pos.of_nat k) = fun _ _ => None.

  Definition setMaxPerm (m : mem) : mem.

  Lemma setMaxPerm_Max :
    forall m b ofs,
      (Mem.valid_block m b ->

   Lemma setMaxPerm_MaxV :
    forall m b ofs,
      Mem.valid_block m b ->

  Lemma setMaxPerm_MaxI :
    forall m b ofs,
      ~ Mem.valid_block m b ->

  Lemma setMaxPerm_Cur :
    forall m b ofs,
      permission_at (setMaxPerm m) b ofs Cur = permission_at m b ofs Cur.

  Definition makeCurMax_map (mem_access:PMap.t (Z -> perm_kind -> option permission)):
    PMap.t (Z -> perm_kind -> option permission):=
    PMap.map (fun f => fun z k => f z Max) mem_access.

  Definition makeCurMax (m:mem): mem.

  Lemma makeCurMax_correct :
    forall m b ofs k,
      permission_at m b ofs Max = permission_at (makeCurMax m) b ofs k.

  Lemma makeCurMax_valid :
    forall m b,
      Mem.valid_block m b <-> Mem.valid_block (makeCurMax m) b.

  Definition restrPermMap p' m (Hlt: permMapLt p' (getMaxPerm m)) : mem.

Lemma restrPermMap_irr:
      forall p1 p2 m1 m2
        (P1: permMapLt p1 (getMaxPerm m1))
        (P2: permMapLt p2 (getMaxPerm m2)),
        p1 = p2 -> m1 = m2 ->
        restrPermMap P1 = restrPermMap P2.
    Lemma restrPermMap_ext:
      forall p1 p2 m
        (P1: permMapLt p1 (getMaxPerm m))
        (P2: permMapLt p2 (getMaxPerm m)),
        (forall b, (p1 !! b) = (p2 !! b)) ->
        restrPermMap P1 = restrPermMap P2.

  Lemma restrPermMap_nextblock :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      Mem.nextblock (restrPermMap Hlt) = Mem.nextblock m.

  Lemma restrPermMap_valid :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      Mem.valid_block (restrPermMap Hlt) b <-> Mem.valid_block m b.

  Lemma restrPermMap_contents :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      contents_at (restrPermMap Hlt) = contents_at m.

  Lemma restrPermMap_max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      max_access_at (restrPermMap Hlt) = max_access_at m.

  Lemma getMax_restr :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      (getMaxPerm (restrPermMap Hlt)) !!  b = (getMaxPerm m) !! b.

  Lemma restrPermMap_irr' : forall p' p'' m
                             (Hlt : permMapLt p' (getMaxPerm m))
                             (Hlt': permMapLt p'' (getMaxPerm m))
                             (Heq_new: p' = p''),
                             restrPermMap Hlt = restrPermMap Hlt'.

  Lemma restrPermMap_disjoint_inv:
    forall (mi mj m : mem) (pi pj : access_map)
      (Hltj: permMapLt pj (getMaxPerm m))
      (Hlti: permMapLt pi (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pi pj)
      (Hrestrj: restrPermMap Hltj = mj)
      (Hrestri: restrPermMap Hlti = mi),
      permMapsDisjoint (getCurPerm mi) (getCurPerm mj).

  Lemma restrPermMap_correct :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m))
      b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs /\

  Corollary restrPermMap_Cur :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Cur =
      Maps.PMap.get b p' ofs.

  Corollary restrPermMap_Max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs.

  Lemma restrPermMap_can : forall (p : access_map) (m m': mem)
                             (Hlt: permMapLt p (getMaxPerm m))
                             (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getCurPerm m').

  Lemma restrPermMap_can_max : forall (p : access_map) (m m': mem)
                                 (Hlt: permMapLt p (getMaxPerm m))
                                 (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getMaxPerm m').

  Definition erasePerm (m : mem) : mem.

  Lemma erasePerm_Perm :
    forall m b ofs k ,
      (Mem.valid_block m b ->

   Lemma erasePerm_V :
    forall m b ofs k,
      Mem.valid_block m b ->

  Lemma erasePerm_I :
    forall m b ofs k,
      ~ Mem.valid_block m b ->

   Definition decay m_before m_after := forall b ofs,
      (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k,
           (Maps.PMap.get b (Mem.mem_access m_before) ofs k = Some Freeable /\
            Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) \/
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Definition strong_decay m_before m_after := forall b ofs,
       (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Lemma strong_decay_implies_decay:
     forall m m',
       strong_decay m m' ->
       decay m m'.

  Lemma decay_refl:
    forall m,
      decay m m.

  Lemma decay_trans :
    forall m m' m'',
      (forall b, Mem.valid_block m b -> Mem.valid_block m' b) ->

  Definition permMapJoin (pmap1 pmap2 pmap3: access_map) :=
    forall b ofs,
      permjoin ((pmap1 !! b) ofs) ((pmap2 !! b) ofs) ((pmap3 !! b) ofs).

  Lemma permMapJoin_order:
    forall p1 p2 p3
      (Hjoin: permMapJoin p1 p2 p3),
    forall b ofs,
      Mem.perm_order'' (p3 !! b ofs) (p1 !! b ofs) /\

  Lemma permMapLt_invalid_block:
    forall pmap m b ofs
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma perm_order_valid_block:
    forall pmap m b ofs p
      (Hperm: Mem.perm_order'' (pmap !! b ofs) (Some p))

  Definition perm_order''_dec : forall (op op' : option permission),
      {Mem.perm_order'' op op'} + {~ Mem.perm_order'' op op'}.

  Definition perm_eq_dec: forall (op op' : option permission),
      {op = op'} + {~ op = op'}.

End permMapDefs.

Require Import VST.concurrency.common.core_semantics.
Require Import compcert.lib.Coqlib.

Lemma storebytes_decay:
  forall m loc p vl m', Mem.storebytes m loc p vl = Some m' -> decay m m'.

Lemma alloc_decay:
  forall m lo hi m1 b1, Mem.alloc m lo hi = (m1,b1) -> decay m m1.

Lemma free_decay: forall m b lo hi m', Mem.free m b lo hi = Some m' -> decay m m'.

Lemma msem_decay: 
  forall C (Sem: MemSem C) c m c' m',
   corestep (csem Sem)  c m c' m' ->
  decay m m'. *)

Require Import VST.concurrency.juicy.sync_preds.
(* VST.concurrency.juicy.sync_preds:
Require Import Coq.Strings.String.

Require Import compcert.lib.Integers.
Require Import compcert.common.AST.
Require Import compcert.cfrontend.Clight.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Memdata.
Require Import compcert.common.Values.

Require Import VST.msl.Coqlib2.
Require Import VST.msl.eq_dec.
Require Import VST.msl.seplog.
Require Import VST.msl.age_to.
Require Import VST.veric.aging_lemmas.
Require Import VST.veric.initial_world.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.semax_prog.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.veric.semax.
Require Import VST.veric.semax_ext.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.semax_ext.
Require Import VST.veric.res_predicates.
Require Import VST.veric.age_to_resource_at.
Require Import VST.veric.coqlib4.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.juicy.semax_conc_pred.
Require Import VST.concurrency.juicy.semax_conc.
Require Import VST.concurrency.juicy.juicy_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.juicy.JuicyMachineModule.
Require Import VST.concurrency.juicy.sync_preds_defs.
Require Import VST.concurrency.common.lksize.
Import threadPool.

Set Bullet Behavior "Strict Subproofs".

Lemma isSome_find_map addr f lset :
  ssrbool.isSome (AMap.find (elt:=option rmap) addr (AMap.map f lset)) =

Lemma interval_adr_range b start length i :
  Intv.In i (start, start + length) <->

Lemma join_YES_l {r1 r2 r3 sh1 sh1' k pp} :
  sepalg.join r1 r2 r3 ->

Local Open Scope nat_scope.

Import THE_JUICY_MACHINE.
Import Concur OrdinalPool ThreadPool.

Section Machine.

Context (ge : genv).

Lemma fst_snd0: forall loc: address,
   (fst loc, (snd loc + 0)%Z) = loc.

Lemma same_locks_juicyLocks_in_lockSet phi phi' lset :
  same_locks phi phi' ->
  juicyLocks_in_lockSet lset phi ->
  juicyLocks_in_lockSet lset phi'.

Lemma lockSet_Writable_lockSet_block_bound m lset  :
  lockSet_Writable lset m ->
  lockSet_block_bound lset (Mem.nextblock m).

Lemma join_all_age_updThread_level (tp : jstate ge) i (cnti : ThreadPool.containsThread tp i) c phi Phi :

Lemma join_all_level_lset (tp : jstate ge) Phi l phi :
  join_all tp Phi ->
  AMap.find l (lset tp) = Some (Some phi) ->

Lemma lset_range_perm m (tp : jstate ge) b ofs
  (compat : mem_compatible tp m)
  (Efind : AMap.find (elt:=option rmap) (b, ofs) (lset tp) <> None) :

Lemma age_to_updThread i (tp : jstate ge) n c phi cnti cnti' :
  age_tp_to n (@updThread _ _ _ i tp cnti c phi) =
  @updThread _ _ _ i (age_tp_to n tp) cnti' c (age_to n phi).

Lemma lset_age_tp_to n (tp : jstate ge) :
  lset (age_tp_to n tp) = AMap.map (option_map (age_to n)) (lset tp).

Lemma getThreadC_fun i (tp : jstate ge) cnti cnti' x y :
  @getThreadC _ _ _ i tp cnti = x ->
  @getThreadC _ _ _ i tp cnti' = y ->
  x = y.

Lemma getThreadR_fun i (tp : jstate ge) cnti cnti' x y :
  @getThreadR _ _ _ i tp cnti = x ->
  @getThreadR _ _ _ i tp cnti' = y ->
  x = y.

Lemma lockSet_Writable_age n (tp : jstate ge) m :
  lockSet_Writable (lset tp) m ->
  lockSet_Writable (lset (age_tp_to n tp)) m.

Lemma lockSet_age_to n (tp : jstate ge) :
  lockSet (age_tp_to n tp) = lockSet tp.

Lemma juicyLocks_in_lockSet_age n (tp : jstate ge) phi :
  juicyLocks_in_lockSet (lset tp) phi ->
  juicyLocks_in_lockSet (lset (age_tp_to n tp)) (age_to n phi).

Lemma lockSet_in_juicyLocks_age n (tp : jstate ge) phi :
  lockSet_in_juicyLocks (lset tp) phi ->
  lockSet_in_juicyLocks (lset (age_tp_to n tp)) (age_to n phi).

Definition same_except_cur (m m' : Mem.mem) :=
  Mem.mem_contents m = Mem.mem_contents m' /\
  max_access_at m = max_access_at m' /\
  Mem.nextblock m = Mem.nextblock m'.

Lemma mem_cohere_same_except_cur m m' phi :
  same_except_cur m m' ->
  mem_cohere' m phi ->
  mem_cohere' m' phi.

Lemma mem_compatible_with_same_except_cur (tp : jstate ge) m m' phi :
  same_except_cur m m' ->
  mem_compatible_with tp m phi ->
  mem_compatible_with tp m' phi.

Lemma resource_at_joins phi1 phi2 loc :
  joins phi1 phi2 -> joins (phi1 @ loc) (phi2 @ loc).

Lemma juicyRestrict_Max b ofs phi m (coh : access_cohere' m phi):
  (Mem.mem_access (juicyRestrict coh)) !! b ofs Max =

Lemma juicyRestrict_Cur b ofs phi m (coh : access_cohere' m phi):
  (Mem.mem_access (juicyRestrict coh)) !! b ofs Cur =

Lemma same_perm_spec m1 m2 :
  Mem.perm m1 = Mem.perm m2 <->

Lemma PTree_xmap_ext (A B : Type) (f f' : positive -> A -> B) t :
  (forall a, f a = f' a) ->
  PTree.xmap f t = PTree.xmap f' t.

Lemma juicyRestrictCur_ext m phi phi'
      (coh : access_cohere' m phi)
      (coh' : access_cohere' m phi')
      (same : forall loc, perm_of_res (phi @ loc) = perm_of_res (phi' @ loc)) :
  Mem.mem_access (juicyRestrict coh) =

Lemma PTree_xmap_self A f (m : PTree.t A) i :

Lemma PTree_map_self (A : Type) (f : positive -> A -> A) t :
  (forall b a, t ! b = Some a -> f b a = a) ->
  PTree.map f t = t.

Lemma juicyRestrictCur_unchanged m phi
      (coh : access_cohere' m phi)
      (pres : forall loc, perm_of_res (phi @ loc) = access_at m loc Cur) :
  Mem.mem_access (juicyRestrict coh) = Mem.mem_access m.

Lemma ZIndexed_index_surj p : { z : Z | ZIndexed.index z = p }.

Lemma self_join_pshare_false (psh psh' : pshare) : ~sepalg.join psh psh psh'.

Lemma approx_eq_app_pred {P1 P2 : mpred} x n :
  level x < n ->
  @approx n P1 = approx n P2 ->
  app_pred P1 x ->
  app_pred P2 x.

Lemma exclusive_approx R n : exclusive_mpred R -> exclusive_mpred (approx n R).

Import shares.

Lemma exclusive_joins_false R phi1 phi2 :
  exclusive_mpred R ->
  app_pred R phi1 ->
  app_pred R phi2 ->
  joins phi1 phi2 ->
  False.

Lemma weak_exclusive_joins_false R phi phi1 phi2 :
  level phi = level phi1 ->
  app_pred (weak_exclusive_mpred R) phi ->
  app_pred R phi1 ->
  app_pred R phi2 ->
  joins phi1 phi2 ->
  False.

Lemma isLK_age_to n phi loc : isLK (age_to n phi @ loc) = isLK (phi @ loc).

Lemma predat_inj {phi loc R1 R2} :
  predat phi loc R1 ->
  predat phi loc R2 ->
  R1 = R2.

Lemma predat1 {phi loc} {R: mpred} {z sh psh} :
  phi @ loc = YES sh psh (LK z 0) (SomeP rmaps.Mpred (fun _ => R)) ->

Lemma predat2 {phi loc R sh } :
  LKspec_ext R sh loc phi ->
  predat phi loc (approx (level phi) R).

Lemma predat3 {phi loc R sh} :
  LK_at R sh loc phi ->
  predat phi loc (approx (level phi) R).

Lemma predat4 {phi b ofs sh R} :
  app_pred (lock_inv sh (Vptr b ofs) R) phi ->
  predat phi (b, Ptrofs.unsigned ofs) (approx (level phi) R).

Lemma predat5 {phi loc R} :
  islock_pred R (phi @ loc) ->
  predat phi loc R.

Lemma predat6 {R loc phi} : lkat R loc phi -> predat phi loc (approx (level phi) R).

Lemma predat_join_sub {phi1 phi2 loc R} :
  join_sub phi1 phi2 ->
  predat phi1 loc R ->
  predat phi2 loc R.

Lemma lock_inv_at sh v R phi :
  app_pred (lock_inv sh v R) phi ->
  exists b ofs, v = Vptr b ofs /\ exists R, islock_pred R (phi @ (b, Ptrofs.unsigned ofs)).

Lemma lkat_hered R loc : hereditary age (lkat R loc).

End Machine. *)



Require Import VST.concurrency.juicy.JuicyMachineModule.
(* VST.concurrency.juicy.JuicyMachineModule:
Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import ProofIrrelevance.

Require Export VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.juicy.juicy_machine. Import Concur.
Require Import VST.concurrency.common.HybridMachine. Import Concur.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.

Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.common.ClightSemanticsForMachines.

Module THE_JUICY_MACHINE.

  Module JuicyMachine := HybridMachineSig.
  Export JuicyMachine.

  Section THE_JUICY_MACHINE.

  Context {ge : Clight.genv}.
  Instance JSem : Semantics := Clight_newSem ge.
  Definition JMachineSem := MachineSemantics(HybridMachine := HybridCoarseMachine.HybridCoarseMachine(machineSig:=JuicyMachineShell)).
  Definition jstate := ThreadPool.t(resources := LocksAndResources)(ThreadPool := OrdinalPool.OrdinalThreadPool).
  Definition jmachine_state := MachState(resources := LocksAndResources)(ThreadPool := OrdinalPool.OrdinalThreadPool).

  Import threadPool.ThreadPool.

  Definition tp_update (tp : jstate) phi tp' phi' :=
    level phi' = level phi /\ resource_at phi' = resource_at phi /\
    join_all tp' phi' /\
    exists (Hiff : forall t, containsThread tp' t <-> containsThread tp t),
      (forall t (cnt : containsThread tp t), getThreadC cnt = getThreadC (proj2 (Hiff _) cnt) /\
         level (getThreadR cnt) = level (getThreadR (proj2 (Hiff _) cnt)) /\
         resource_at (getThreadR cnt) = resource_at (getThreadR (proj2 (Hiff _) cnt))) /\
      lockGuts tp' = lockGuts tp /\ lockSet tp' = lockSet tp /\
      lockRes tp' = lockRes tp /\ latestThread tp'= latestThread tp.

  Lemma tp_update_refl : forall tp phi, join_all tp phi -> tp_update tp phi tp phi.

  Definition tp_bupd P (tp : jstate) :=
    (exists phi, join_all tp phi /\ joins (ghost_of phi) (Some (ghost_PCM.ext_ref tt, NoneP) :: nil)) /\
  forall phi, join_all tp phi ->
    forall c : ghost, join_sub (Some (ghost_PCM.ext_ref tt, NoneP) :: nil) c ->
     joins (ghost_of phi) (ghost_fmap (approx (level phi)) (approx (level phi)) c) ->
     exists b : ghost,
       joins b (ghost_fmap (approx (level phi)) (approx (level phi)) c) /\
       exists phi' tp', tp_update tp phi tp' phi' /\ ghost_of phi' = b /\ P tp'.

  Existing Instance JuicyMachineShell.
  Existing Instance HybridMachineSig.HybridCoarseMachine.DilMem.
  Existing Instance HybridMachineSig.HybridCoarseMachine.scheduler.

  Inductive jm_csafe (st : jmachine_state) (m : mem) : nat -> Prop :=
  | Safe_0 : jm_csafe st m 0
  | HaltedSafe : forall n : nat,
                 is_true (ssrbool.isSome (halted_machine st)) ->
                 jm_csafe st m n
  | CoreSafe : forall tr' (tp' : jstate) (m' : mem) (n : nat)
               (Hstep : MachStep(Sem := JSem) st m (fst (fst st), tr', tp') m')
               (Hsafe : tp_bupd (fun tp' => jm_csafe (fst (fst st), tr', tp') m' n) tp'),
               jm_csafe st m (S n)
  | AngelSafe : forall tr' (tp' : jstate) (m' : mem) (n : nat)
                (Hstep : MachStep(Sem := JSem) st m
                  (schedSkip (fst (fst st)), tr', tp') m')
                (Hsafe : forall U'',
                 tp_bupd (fun tp' => jm_csafe (U'', tr', tp') m' n) tp'),
                jm_csafe st m (S n).

  Inductive jm_ctrace (st : jmachine_state) (m : mem) : event_trace -> nat -> Prop :=
  | Trace_0 : jm_ctrace st m nil 0
  | HaltedTrace : forall n : nat,
                 is_true (ssrbool.isSome (halted_machine st)) ->
                 jm_ctrace st m nil n
  | CoreTrace : forall tr (tp' : jstate) (m' : mem) tr' (n : nat)
               (Hstep : MachStep(Sem := JSem) st m (fst (fst st), snd (fst st) ++ tr, tp') m')
               (Hsafe : tp_bupd (fun tp' => jm_ctrace (fst (fst st), snd (fst st) ++ tr, tp') m' tr' n) tp'),
               jm_ctrace st m (tr ++ tr') (S n)
  | AngelTrace : forall tr (tp' : jstate) (m' : mem) tr' (n : nat)
                (Hstep : MachStep(Sem := JSem) st m
                  (schedSkip (fst (fst st)), snd (fst st) ++ tr, tp') m')
                (Hsafe : forall U'',
                 tp_bupd (fun tp' => jm_ctrace (U'', snd (fst st) ++ tr, tp') m' tr' n) tp'),
                jm_ctrace st m (tr ++ tr') (S n).

  End THE_JUICY_MACHINE.

  Arguments jstate : clear implicits.

End THE_JUICY_MACHINE. *)

Require Import VST.concurrency.common.ClightMachine.
(* VST.concurrency.common.ClightMachine:
Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import ProofIrrelevance.

Require Import VST.concurrency.common.scheduler.

Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.

Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.common.dry_context.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.erased_machine.

Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.sepcomp.event_semantics.

Require Import VST.concurrency.common.ClightSemanticsForMachines.
Require Import VST.concurrency.common.Clight_bounds.

From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Require Import VST.concurrency.common.ssromega. 
Set Bullet Behavior "Strict Subproofs".

Import threadPool.

Module Clight_newMachine.

  Import HybridMachineSig.

  Module DMS.
  Section DMS.

  Context {ge : Clight.genv}.
  Existing Instance OrdinalPool.OrdinalThreadPool.
  Instance DSem : Semantics := Clight_newSem ge.

  Definition ClightMachine :=(HybridCoarseMachine.HybridCoarseMachine
                                 (machineSig := DryHybridMachine.DryHybridMachineSig)).
  Definition ClightMachineSem := (MachineSemantics(HybridMachine := ClightMachine)).
  Definition ClightConcurSem := (ConcurMachineSemantics(HybridMachine := ClightMachine)).   
  End DMS.
  End DMS.
End Clight_newMachine.

Module ClightMachine.

  Import HybridMachineSig.

  Module DMS.
  Section DMS.

  Context {ge : Clight.genv}.
  Existing Instance OrdinalPool.OrdinalThreadPool.
  Instance DSem : Semantics := ClightSem ge.

  Definition ClightMachine :=(HybridCoarseMachine.HybridCoarseMachine
                                 (machineSig := DryHybridMachine.DryHybridMachineSig)).
  Definition ClightMachineSem := (MachineSemantics(HybridMachine := ClightMachine)).
  Definition ClightConcurSem := (ConcurMachineSemantics(HybridMachine := ClightMachine)).   
  End DMS.
  End DMS.
End ClightMachine.

Module FiniteBranching.

  End FiniteBranching. *)



Require Import VST.concurrency.juicy.erasure_signature.
(* VST.concurrency.juicy.erasure_signature:
Require Import compcert.common.Memory.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.juicy.juicy_machine. Import Concur.
Require Import VST.concurrency.common.HybridMachine.

Definition init_inj_ok (j: Values.Val.meminj) m:=
  forall b b' ofs, j b = Some (b', ofs) ->
              b = b' /\
              Mem.valid_block m b.

Module Type ErasureSig.

  Import HybridMachineSig.

  Declare Instance Sem (ge : Clight.genv) : Semantics.

  Declare Instance JR : Resources.
  Declare Instance JTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).
  Declare Instance JMS (ge : Clight.genv) : MachineSig(ThreadPool := JTP ge).
  Declare Instance DilMem : DiluteMem.
  Declare Instance scheduler : Scheduler.
  Declare Instance JuicyMachine (ge : Clight.genv) : HybridMachine(machineSig:=JMS ge).
  Notation JMachineSem ge := (MachineSemantics(HybridMachine := JuicyMachine ge)).
  Notation jres := (@res JR).
  Notation jstate ge := (@ThreadPool.t _ _ (JTP ge)).
  Notation jmachine_state ge := (@MachState _ _ (JTP ge)).
  Declare Instance DR : Resources.
  Declare Instance DTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).
  Declare Instance DMS (ge : Clight.genv) : MachineSig(ThreadPool := DTP ge).
  Declare Instance DryMachine (ge : Clight.genv) : HybridMachine(machineSig := DMS ge).
  Notation DMachineSem ge := (MachineSemantics(HybridMachine := DryMachine ge)).
  Notation dres := (@res DR).
  Notation dstate ge := (@ThreadPool.t _ _ (DTP ge)).
  Notation dmachine_state ge := (@MachState _ _ (DTP ge)).

  Parameter match_st : forall (ge : Clight.genv), jstate ge -> dstate ge -> Prop.

  Axiom MTCH_cnt: forall {ge js tid ds},
      match_st ge js ds ->
      ThreadPool.containsThread js tid -> ThreadPool.containsThread ds tid.
  Axiom MTCH_cnt': forall {ge js tid ds},
      match_st ge js ds ->
      ThreadPool.containsThread ds tid -> ThreadPool.containsThread js tid.

  Axiom  MTCH_getThreadC: forall ge js ds tid c,
      forall (cnt: ThreadPool.containsThread js tid)
        (cnt': ThreadPool.containsThread ds tid)
        (M: match_st ge js ds),
        ThreadPool.getThreadC cnt =  c ->
        ThreadPool.getThreadC cnt'  =  c.

  Axiom MTCH_compat: forall ge js ds m,
      match_st ge js ds ->
      mem_compatible js m ->
      mem_compatible ds m.

  Axiom MTCH_updt:
    forall ge js ds tid c
      (H0:match_st ge js ds)
      (cnt: ThreadPool.containsThread js tid)
      (cnt': ThreadPool.containsThread ds tid),
      match_st ge (ThreadPool.updThreadC cnt c)
               (ThreadPool.updThreadC cnt' c).

  Axiom core_diagram:
    forall ge (m : mem)  (U0 U U': _) rmap pmap
      (ds : dstate ge) dtr (js js': jstate ge) jtr jtr'
      (m' : mem),
      corestep (JMachineSem ge U0 rmap) (U, jtr, js) m (U', jtr', js') m' ->
      match_st ge js ds ->
      invariant ds ->
      exists (ds' : dstate ge),
        invariant ds' /\
        match_st ge js' ds' /\
        exists dtr', corestep (DMachineSem ge U0 pmap) (U, dtr, ds) m (U', app dtr dtr', ds') m'.

  Axiom halted_diagram:
    forall ge U (ds : dmachine_state ge) (js : jmachine_state ge)  rmap pmap,
      fst (fst js) = fst (fst ds) ->
      halted (JMachineSem ge U rmap) js = halted (DMachineSem ge U pmap) ds.

End ErasureSig.

Module ErasureFnctr (PC:ErasureSig).
  Import HybridMachineSig PC.

  Section ErasureFnctr.

    Context (ge : Clight.genv).
    Notation jres := (@res JR).
    Notation jstate := (@ThreadPool.t _ _ (JTP ge)).
    Notation jmachine_state := (@MachState _ _ (JTP ge)).
    Notation dres := (@res DR).
    Notation dstate := (@ThreadPool.t _ _ (DTP ge)).
    Notation dmachine_state := (@MachState _ _ (DTP ge)).
    Instance DMS : MachineSig(ThreadPool := DTP ge) := DMS ge.
    Instance Sem : Semantics := Sem ge.
    Notation match_st := (match_st ge).

    Inductive init_inv:  Values.Val.meminj ->
                         semG -> list Values.val -> mem ->
                         semG -> list Values.val -> mem -> Prop:=
    |InitEq: forall j g1 args1 m1 g2 args2 m2,
        g1 = g2 ->
        args1 = args2 ->
        m1 = m2 ->
        init_inj_ok j m1 ->
        init_inv j g1 args1 m1 g2 args2 m2.

    Inductive halt_inv:  Values.Val.meminj ->
                         semG -> Values.val -> mem ->
                         semG -> Values.val -> mem -> Prop:=
    |HaltEq: forall j g1 args1 m1 g2 args2 m2,
        g1 = g2 ->
        args1 = args2 ->
        m1 = m2 ->
        halt_inv j g1 args1 m1 g2 args2 m2.

    Definition ge_inv: semG -> semG -> Prop:= @eq semG.
    Definition core_data:= unit.
    Definition core_ord: unit-> unit -> Prop := fun _ _ => False.

    Inductive match_state :
      core_data ->  Values.Val.meminj -> jmachine_state ->  mem -> dmachine_state -> mem -> Prop:=
      MATCH: forall d j js ds U m,
        invariant ds -> 
        match_st js ds ->
        match_state d j  (U, nil, js) m (U, nil, ds) m.

    Lemma core_ord_wf:  well_founded core_ord.

  End ErasureFnctr.

End ErasureFnctr. *)



From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.

Require Import Coq.ZArith.ZArith.

Require Import PreOmega.

Require Import VST.concurrency.common.ssromega. 
(* VST.concurrency.common.ssromega:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Set Implicit Arguments.

Ltac arith_hypo_ssrnat2coqnat :=
  match goal with
    | H : context [andb _ _] |- _ => let H0 := fresh in case/andP: H => H H0
    | H : context [orb _ _] |- _ => case/orP: H => H
    | H : context [?L <= ?R] |- _ => move/leP: H => H
    | H : context [?L < ?R] |- _ => move/ltP : H => H
    | H : context [?L == ?R] |- _ => move/eqP : H => H
    | H : context [addn ?L ?R] |- _ => rewrite -plusE in H
    | H : context [muln ?L ?R] |- _ => rewrite -multE in H
    | H : context [subn ?L ?R] |- _ => rewrite -minusE in H
  end.

Ltac arith_goal_ssrnat2coqnat :=
  rewrite ?NatTrec.trecE -?plusE -?minusE -?multE -?leqNgt -?ltnNge;
  repeat match goal with
           | |- is_true (andb _ _) => apply/andP; split
           | |- is_true (orb _ _) => try apply/orP
           | |- is_true (_ <= _) => try apply/leP
           | |- is_true (_ < _) => try apply/ltP
         end.

Ltac ssromega :=
  repeat arith_hypo_ssrnat2coqnat;
  arith_goal_ssrnat2coqnat; simpl;
  omega. *)

From mathcomp.ssreflect Require Import ssreflect seq.



Set Bullet Behavior "Strict Subproofs".



Module Parching <: ErasureSig.

  Import THE_JUICY_MACHINE.

  Import Clight_newMachine.

  Import DMS.

  Import ThreadPoolWF.



  Section Parching.



  Context (ge : Clight.genv).



  Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem ge.



  Instance JR : Resources := LocksAndResources.

  Instance JTP : ThreadPool.ThreadPool := OrdinalPool.OrdinalThreadPool.

  Instance JMS : MachineSig := Concur.JuicyMachineShell.

  Instance DilMem : DiluteMem := HybridMachineSig.HybridCoarseMachine.DilMem.

  Instance scheduler : Scheduler := HybridCoarseMachine.scheduler.

  Instance JuicyMachine : HybridMachine := HybridCoarseMachine.HybridCoarseMachine.

  Definition jstate := jstate ge.



  Instance DR : Resources := DryHybridMachine.dryResources.

  Instance DTP : ThreadPool.ThreadPool := OrdinalPool.OrdinalThreadPool.

  Instance DMS : MachineSig := DryHybridMachine.DryHybridMachineSig.

  Instance DryMachine : HybridMachine := HybridCoarseMachine.HybridCoarseMachine.

  Definition dstate := ThreadPool.t

                         (ThreadPool := OrdinalPool.OrdinalThreadPool)

                         
.

                         

  Definition dmachine_state:= MachState(ThreadPool := OrdinalPool.OrdinalThreadPool).



  Import event_semantics threadPool.ThreadPool.



  Inductive match_st' : jstate ->  dstate -> Prop:=

    MATCH_ST: forall (js:jstate) (ds:dstate)

                (mtch_cnt: forall {tid},  containsThread js tid -> containsThread ds tid )

                (mtch_cnt': forall {tid}, containsThread ds tid -> containsThread js tid )

                (mtch_gtc: forall {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),

                    getThreadC Htid = getThreadC Htid' )

                (mtch_perm1: forall b ofs {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),

                    juicy_mem.perm_of_res (resource_at (getThreadR Htid) (b, ofs)) =

                    ((getThreadR Htid').1 !! b) ofs )

                (mtch_perm2: forall b ofs {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),

                    juicy_mem.perm_of_res_lock (resource_at (getThreadR Htid) (b, ofs)) =

                    ((getThreadR Htid').2 !! b) ofs )

                (mtch_locks: forall a,

                    ssrbool.isSome (lockRes js a) = ssrbool.isSome (lockRes ds a))

                (mtch_locksEmpty: forall lock dres,

                    lockRes js lock = Some (None) ->

                    lockRes ds lock = Some dres ->

                   dres = (empty_map, empty_map))

                (mtch_locksRes: forall lock jres dres,

                    lockRes js lock = Some (Some jres) ->

                    lockRes ds lock = Some dres ->

                     forall b ofs,

                       juicy_mem.perm_of_res (resource_at jres (b, ofs)) = (dres.1 !! b) ofs )

                (mtch_locksRes: forall lock jres dres,

                    lockRes js lock = Some (Some jres) ->

                    lockRes ds lock = Some dres ->

                     forall b ofs,

                    juicy_mem.perm_of_res_lock (resource_at jres (b, ofs)) = (dres.2 !! b) ofs )

                ,

      match_st' js ds.

  Definition match_st:= match_st'.



  Lemma MTCH_cnt: forall {js tid ds},

           match_st js ds ->

           containsThread js tid -> containsThread ds tid.

  Proof. intros ? ? ? MTCH. inversion MTCH. apply mtch_cnt. Qed.

  

  Lemma MTCH_cnt': forall {js tid ds},

           match_st js ds ->

           containsThread ds tid -> containsThread js tid.

  Proof. intros ? ? ? MTCH. inversion MTCH. apply mtch_cnt'. Qed.



  Lemma MTCH_perm: forall {js ds i},

      forall (cnt: containsThread js i)

      (MTCH: match_st js ds),

      forall b ofs,

        juicy_mem.perm_of_res ((getThreadR cnt) @ (b, ofs)) = ((getThreadR (MTCH_cnt MTCH cnt)).1 !! b) ofs.

  Proof. intros ? ? ? ? MTCH ? ?. inversion MTCH. apply mtch_perm1. Qed.



  Lemma MTCH_perm2: forall {js ds i},

      forall (cnt: containsThread js i)

      (MTCH: match_st js ds),

      forall b ofs,

        juicy_mem.perm_of_res_lock  ((getThreadR cnt) @ (b, ofs)) = ((getThreadR (MTCH_cnt MTCH cnt)).2 !! b) ofs.

  Proof. intros. inversion MTCH. apply mtch_perm2. Qed.



  Lemma MTCH_perm': forall {js ds i},

      forall (cnt: containsThread ds i)

      (MTCH: match_st js ds),

      forall b ofs,

        ((getThreadR cnt).1 !! b) ofs =

        juicy_mem.perm_of_res ((getThreadR (MTCH_cnt' MTCH cnt)) @ (b, ofs)).

  Proof. intros. inversion MTCH. symmetry. apply mtch_perm1; eauto. Qed.



  Lemma MTCH_perm2': forall {js ds i},

      forall (cnt: containsThread ds i)

      (MTCH: match_st js ds),

      forall b ofs,

        ((getThreadR cnt).2 !! b) ofs =

        juicy_mem.perm_of_res_lock ((getThreadR (MTCH_cnt' MTCH cnt)) @ (b, ofs)).

  Proof. intros. inversion MTCH. symmetry; apply mtch_perm2. Qed.



  Lemma cnt_irr: forall tid (ds : dstate) (cnt1 cnt2: containsThread ds tid),

      getThreadC cnt1 = getThreadC cnt2.

  Proof. intros.

         unfold getThreadC.

         destruct ds; simpl.

         f_equal; f_equal.

         eapply proof_irrelevance.

  Qed.



  Lemma MTCH_locks: forall ds js laddr rmap,

      match_st js ds ->

      lockRes ds laddr = Some rmap ->

      exists x, lockRes js laddr = Some x.

  Proof.

    move=> ? js laddr ? MTCH HH.

    destruct (lockRes js laddr) eqn:AA.

    - exists l; reflexivity.

    - inversion MTCH.

      specialize (mtch_locks laddr).

      rewrite HH AA in mtch_locks; inversion mtch_locks.

  Qed.



  Lemma MTCH_getThreadC: forall js ds tid c,

      forall (cnt: containsThread js tid)

        (cnt': containsThread ds tid)

        (M: match_st js ds),

        getThreadC cnt =  c ->

        getThreadC cnt'  =  c.

  Proof. intros ? ? ? ? ? MTCH; inversion MTCH; subst.

         intros HH; inversion HH; subst.

         intros AA; rewrite <- AA. symmetry; apply mtch_gtc.

  Qed.



  Lemma MTCH_lockSet: forall js ds,

      match_st js ds ->

      forall b ofs, (lockSet js) !! b ofs = (lockSet ds) !! b ofs.

  Proof.

    intros js ds MATCH b ofs.

    inversion MATCH. clear - mtch_locks.

    destruct (OrdinalPool.lockRes_range_dec ds b ofs).

    - destruct e as [z [ineq dLR]].

      specialize (mtch_locks (b, z)).

      destruct ( lockRes ds (b, z)) eqn:AA; inversion dLR.

      destruct (lockRes js (b, z)) eqn:BB; inversion mtch_locks.

      erewrite lockSet_spec_2; eauto.

      erewrite lockSet_spec_2; eauto.

      rewrite BB; constructor.

      setoid_rewrite AA in dLR; inversion dLR.

    - destruct (OrdinalPool.lockRes_range_dec js b ofs).

      + clear e.

        destruct e0 as [z [ineq dLR]].

        specialize (mtch_locks (b, z)).

        destruct (lockRes js (b, z)) eqn:AA; inversion dLR.

        * destruct ( lockRes ds (b, z)) eqn:BB; inversion mtch_locks.

          erewrite lockSet_spec_2; eauto.

          erewrite lockSet_spec_2; eauto.

          rewrite BB; constructor.

        * setoid_rewrite AA in dLR; inversion dLR.

      + erewrite lockSet_spec_3; eauto.

        erewrite lockSet_spec_3; eauto.

  Qed.



  Lemma MTCH_compat: forall js ds m,

      match_st js ds ->

      mem_compatible js m ->

      mem_compatible ds m.

  Proof.

    intros ? ? ? MTCH mc.

    inversion MTCH; subst.

    constructor.

    - intros tid cnt.

      assert (th_coh:= Concur.thread_mem_compatible mc).

      specialize (th_coh tid (mtch_cnt' _ cnt)).

      inversion th_coh.

      unfold permMapLt;

        split; intros b ofs; rewrite getMaxPerm_correct; eapply po_trans;

      try solve [eapply (max_coh (b,ofs))].

      + rewrite <- (mtch_perm1 _ _ _ (mtch_cnt' tid cnt));

        eapply perm_of_res_op1.

      + rewrite <- (mtch_perm2 _ _ _ (mtch_cnt' tid cnt));

        eapply perm_of_res_op2.

    - intros.

      assert(HH: exists jres, lockRes js l = Some jres).

      { specialize (mtch_locks  l); rewrite H in mtch_locks.

      destruct (lockRes js l); try solve[inversion mtch_locks].

      exists l0; reflexivity. }

      destruct HH as [jres HH].

      destruct jres.

      + specialize (mtch_locksRes _ _ _ HH H).

        specialize (mtch_locksRes0 _ _ _ HH H).

        split; intros b ofs.

        * rewrite <- mtch_locksRes.

          eapply Concur.compat_lockLT; eauto.

          apply mc.

        * rewrite <- mtch_locksRes0.

          eapply po_trans.

          eapply Concur.compat_lockLT'; eauto.

          { apply mc. }

          eapply perm_of_res_op2.

      + specialize (mtch_locksEmpty _ _ HH H).

        rewrite mtch_locksEmpty.

        split; apply empty_LT.

   
    - intros l rmap0 H.

      destruct (valid_block_dec m l.1); try assumption.

      eapply m with (ofs:=l.2) (k:=Max) in n.

      specialize (mtch_locks l).

      rewrite H in mtch_locks.

      destruct (lockRes js l) eqn:lock_in_l; try solve[inversion mtch_locks]; clear mtch_locks.

      destruct mc as [all_juice mc']; destruct mc'.

      move lset_in_juice at bottom.

      specialize (lset_in_juice l).

      setoid_rewrite lock_in_l in lset_in_juice. simpl in lset_in_juice.

      assert (HH:true) by auto; apply lset_in_juice in HH.

      destruct HH as [sh HH].

      destruct all_cohere.

      specialize (max_coh l).

      specialize (HH 0). spec HH. pose proof LKSIZE_pos; omega. destruct HH as [sh' [psh' [P [? HH]]]].

      rewrite fst_snd0 in HH.

      rewrite HH in max_coh.

      simpl in max_coh.

      unfold max_access_at, access_at in max_coh.

      rewrite n in max_coh.

      cut (Mem.perm_order'' None (Some Nonempty)).

      { intros AA; inversion AA. }

      eapply po_trans; eauto.

      destruct (perm_of_sh _) eqn:?; inversion max_coh.

      apply perm_of_empty_inv in Heqo.

      subst.

      exfalso; apply shares.bot_unreadable; assumption.

  Qed.



  Lemma MTCH_updt:

    forall js ds tid c

      (H0:match_st js ds)

      (cnt: containsThread js tid)

      (cnt': containsThread ds tid),

      match_st (updThreadC cnt c)

               (updThreadC cnt' c).

  Proof.

    intros. constructor; intros.

    - apply cntUpdateC.

      inversion H0; subst.

      apply mtch_cnt.

      eapply cntUpdateC'; apply H.

    - apply cntUpdateC.

      inversion H0; subst.

      apply mtch_cnt'.

        eapply cntUpdateC'; apply H.

    - destruct (eq_dec tid tid0) as [e|ine].

      + subst.

          rewrite gssThreadCC;

          rewrite gssThreadCC.

          reflexivity.

      + assert (cnt2:= cntUpdateC' _ _ Htid).

        rewrite <- (gsoThreadCC ine _ cnt2) by assumption.

        inversion H0; subst.

          

          assert (cnt2':= cntUpdateC' _ _ Htid').

          

          rewrite <- (gsoThreadCC ine _ cnt2') by assumption.

          apply mtch_gtc; assumption.

    - inversion H0; apply mtch_perm1.

    - inversion H0; apply mtch_perm2.

    - inversion H0; apply mtch_locks.

    - rewrite gsoThreadCLPool in H; rewrite gsoThreadCLPool in H1.

      inversion H0; eapply mtch_locksEmpty; eauto.

    - rewrite gsoThreadCLPool in H; rewrite gsoThreadCLPool in H1.

      inversion H0; eapply mtch_locksRes; eauto.

    - rewrite gsoThreadCLPool in H; rewrite gsoThreadCLPool in H1.

      inversion H0; eapply mtch_locksRes0; eauto.

  Qed.



  Lemma MTCH_updt':

    forall js ds tid c m

      (H0:match_st js ds)

      (cnt: containsThread js tid)

      (cnt': containsThread ds tid)

      (Hcmpt : mem_compatible js m)

      (Hcmpt' : HybridMachineSig.mem_compatible ds m),

      match_st (updThread cnt c (add_block Hcmpt cnt (Concur.install_perm Hcmpt cnt)))

               (updThread cnt' c (HybridMachineSig.add_block Hcmpt' cnt' (Concur.install_perm Hcmpt cnt))).

  Proof.

    intros. constructor; intros.

    - apply cntUpdate.

      inversion H0; subst.

      apply mtch_cnt.

      eapply cntUpdate'; apply H.

    - apply cntUpdate.

      inversion H0; subst.

      apply mtch_cnt'.

        eapply cntUpdate'; apply H.

    - destruct (eq_dec tid tid0) as [e|ine].

      + subst.

          rewrite gssThreadCode;

          rewrite gssThreadCode.

          reflexivity.

      + assert (cnt2:= cntUpdate' _ _ _ Htid).

        rewrite (gsoThreadCode ine _ cnt2).

        inversion H0; subst.

          

          assert (cnt2':= cntUpdate' _ _ _ Htid').

          

          rewrite (gsoThreadCode ine _ cnt2').

          apply mtch_gtc; assumption.

    - inversion H0.

      destruct (eq_dec tid tid0); [|rewrite !gsoThreadRes; auto].

      subst.

      rewrite !gssThreadRes.

      simpl.

      unfold Concur.add_block, Concur.install_perm.

      rewrite getCurPerm_correct.

      unfold permission_at.

      pose proof Concur.juicyRestrictCurEq (Concur.max_acc_coh_acc_coh (Concur.max_coh (Concur.thread_mem_compatible Hcmpt cnt)))

        (b, ofs); auto.

    - inversion H0.

      destruct (eq_dec tid tid0); [|rewrite !gsoThreadRes; auto].

      subst.

      rewrite !gssThreadRes.

      apply mtch_perm2.

    - inversion H0; apply mtch_locks.

    - rewrite gsoThreadLPool in H; rewrite gsoThreadLPool in H1.

      inversion H0; eapply mtch_locksEmpty; eauto.

    - rewrite gsoThreadLPool in H; rewrite gsoThreadLPool in H1.

      inversion H0; eapply mtch_locksRes; eauto.

    - rewrite gsoThreadLPool in H; rewrite gsoThreadLPool in H1.

      inversion H0; eapply mtch_locksRes0; eauto.

  Qed.



    Lemma MTCH_restrict_personal:

      forall ds js m i

        (MTCH: match_st js ds)

        (Hi: containsThread js i)

        (Hi': containsThread ds i)

        Hcmpt

        (Hcmpt': DryHybridMachine.mem_compatible ds m),

        restrPermMap (DryHybridMachine.compat_th _ _ Hcmpt' Hi').1 =

        m_dry (@Concur.personal_mem m (@getThreadR _ _ _ i js Hi) Hcmpt).

    Proof.

      intros.

      inversion MTCH; subst.

      unfold Concur.personal_mem; simpl; unfold Concur.juicyRestrict; simpl.

      apply restrPermMap_ext; intros.

      extensionality ofs;

      setoid_rewrite <- mtch_perm1.

      instantiate(1:=Hi).

      erewrite Concur.juic2Perm_correct. reflexivity.

      apply Concur.acc_coh; assumption.

    Qed.



    Lemma MTCH_updLockS:

             forall js ds loc jres dres1 dres2,

               match_st js ds ->

             (forall b ofs, perm_of_res (jres @ (b, ofs)) = dres1 !! b ofs) ->

             (forall b ofs, perm_of_res_lock (jres @ (b, ofs)) = dres2 !! b ofs) ->

                      match_st

                        (updLockSet js loc (Some jres))

                        (updLockSet ds loc (dres1,dres2)).

    Proof. intros.

           constructor.

           + intros. apply cntUpdateL.

             destruct H; apply mtch_cnt.

             apply cntUpdateL' in H2; assumption.

           + intros. apply cntUpdateL.

             destruct H; apply mtch_cnt'.

             apply cntUpdateL' in H2; assumption.

           + intros. rewrite gLockSetCode gLockSetCode.

             inversion H; subst. apply mtch_gtc.

           + intros. rewrite gLockSetRes gLockSetRes.

             inversion H; subst. apply mtch_perm1.

           + intros. rewrite gLockSetRes gLockSetRes.

             inversion H; subst. apply mtch_perm2.

           + intros.

             destruct (AMap.E.eq_dec loc a) as [EQ | NEQ].

             * subst loc. rewrite gsslockResUpdLock gsslockResUpdLock.

               reflexivity.

             * rewrite gsolockResUpdLock.

               rewrite gsolockResUpdLock.

               inversion H. solve[apply mtch_locks].

               assumption.

               assumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc. rewrite gsslockResUpdLock in H2; inversion H2.

             * rewrite gsolockResUpdLock in H2. rewrite gsolockResUpdLock in H3.

               inversion H. eapply mtch_locksEmpty; eassumption.

               assumption. assumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResUpdLock in H2.

               rewrite gsslockResUpdLock in H3.

               inversion H2; inversion H3; subst.

               apply H0.

             * rewrite gsolockResUpdLock in H2. rewrite gsolockResUpdLock in H3.

               inversion H. eapply mtch_locksRes; eassumption.

               assumption.

               assumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResUpdLock in H2.

               rewrite gsslockResUpdLock in H3.

               inversion H2; inversion H3; subst.

               apply H1.

             * rewrite gsolockResUpdLock in H2. rewrite gsolockResUpdLock in H3.

               inversion H. eapply mtch_locksRes0; eassumption.

               assumption.

               assumption.

    Qed.



    Lemma MTCH_updLockN:

      forall js ds loc,

        match_st js ds ->

        match_st

          (updLockSet js loc None)

          (updLockSet ds loc (empty_map,empty_map)).

           intros.

           constructor.

           + intros. apply cntUpdateL.

             destruct H; apply mtch_cnt.

             apply cntUpdateL' in H0; assumption.

           + intros. apply cntUpdateL.

             destruct H; apply mtch_cnt'.

             apply cntUpdateL' in H0; assumption.

           + intros. rewrite gLockSetCode gLockSetCode.

             inversion H; subst. apply mtch_gtc.

           + intros. rewrite gLockSetRes gLockSetRes.

             inversion H; subst. apply mtch_perm1.

           + intros. rewrite gLockSetRes gLockSetRes.

             inversion H; subst. apply mtch_perm2.

           + intros.

             destruct (AMap.E.eq_dec loc a) as [EQ | NEQ].

             * subst loc. rewrite gsslockResUpdLock gsslockResUpdLock.

               reflexivity.

             * rewrite gsolockResUpdLock.

               rewrite gsolockResUpdLock.

               inversion H. solve[apply mtch_locks].

               assumption. assumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc. rewrite gsslockResUpdLock in H1; inversion H1; reflexivity.

             * rewrite gsolockResUpdLock in H1.

               rewrite gsolockResUpdLock in H0.

               inversion H. eapply mtch_locksEmpty; eassumption.

               assumption.

               assumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResUpdLock in H0.

               rewrite gsslockResUpdLock in H1.

               inversion H0.

             * rewrite gsolockResUpdLock in H0. 2: assumption.

               rewrite gsolockResUpdLock in H1. 2: assumption.

               inversion H. eapply mtch_locksRes; eassumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResUpdLock in H0.

               rewrite gsslockResUpdLock in H1.

               inversion H0.

             * rewrite gsolockResUpdLock in H0. 2: assumption.

               rewrite gsolockResUpdLock in H1. 2: assumption.

               inversion H. eapply mtch_locksRes0; eassumption.

    Qed.



    Lemma MTCH_remLockN:

      forall js ds loc,

        match_st js ds ->

        match_st

          (remLockSet js loc)

          (remLockSet ds loc).

           intros.

           constructor.

           + intros. apply cntRemoveL.

             destruct H; apply mtch_cnt.

             apply cntRemoveL' in H0; assumption.

           + intros. apply cntRemoveL.

             destruct H; apply mtch_cnt'.

             apply cntRemoveL' in H0; assumption.

           + intros. rewrite gRemLockSetCode gRemLockSetCode.

             inversion H; subst. apply mtch_gtc.

           + intros. rewrite gRemLockSetRes  gRemLockSetRes.

             inversion H; subst. apply mtch_perm1.

           + intros. rewrite gRemLockSetRes  gRemLockSetRes.

             inversion H; subst. apply mtch_perm2.

           + intros.

             destruct (AMap.E.eq_dec loc a) as [EQ | NEQ].

             * subst loc. rewrite gsslockResRemLock gsslockResRemLock.

               reflexivity.

             * rewrite gsolockResRemLock.

               2: exact NEQ.

               rewrite gsolockResRemLock.

               2: exact NEQ.

               inversion H. solve[apply mtch_locks].

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc. rewrite gsslockResRemLock in H1; inversion H1; reflexivity.

             * rewrite gsolockResRemLock in H1.

               2: exact NEQ.

               rewrite gsolockResRemLock in H0.

               2: exact NEQ.

               inversion H. eapply mtch_locksEmpty; eassumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResRemLock in H0.

               rewrite gsslockResRemLock in H1.

               inversion H0.

             * rewrite gsolockResRemLock in H0.

               2: exact NEQ.

               rewrite gsolockResRemLock in H1.

               2: exact NEQ.

               inversion H. eapply mtch_locksRes; eassumption.

           + intros.

             destruct (AMap.E.eq_dec loc lock) as [EQ | NEQ].

             * subst loc.

               rewrite gsslockResRemLock in H0.

               rewrite gsslockResRemLock in H1.

               inversion H0.

             * rewrite gsolockResRemLock in H0.

               2: exact NEQ.

               rewrite gsolockResRemLock in H1.

               2: exact NEQ.

               inversion H. eapply mtch_locksRes0; eassumption.

    Qed.



    Lemma MTCH_update:

      forall js ds Kc phi p1 p2 i

        (Hi : containsThread js i)

        (Hi': containsThread ds i),

        match_st js ds ->

        ( forall b ofs,

            perm_of_res (phi @ (b, ofs)) = p1 !! b ofs) ->

        ( forall b ofs,

            perm_of_res_lock (phi @ (b, ofs)) = p2 !! b ofs) ->

        match_st (updThread Hi  Kc phi)

                 (updThread Hi' Kc (p1,p2)).

    Proof.

      intros. inversion H; subst.

      constructor; intros.

      - apply cntUpdate. apply mtch_cnt.

        eapply cntUpdate'; eassumption.

      - apply cntUpdate. apply mtch_cnt'.

        eapply cntUpdate'; eassumption.

      - destruct (eq_dec i tid).

        + subst.

          rewrite gssThreadCode gssThreadCode; reflexivity.

        + assert (jcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi Htid).

          assert (dcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi' Htid').

          rewrite (gsoThreadCode n _ jcnt2); auto.

          rewrite (gsoThreadCode n _ dcnt2); auto.

      - destruct (eq_dec i tid).

        + subst.

          rewrite (gssThreadRes _ _ _ Htid); auto.

          rewrite (gssThreadRes _ _ _ Htid'); auto.

        + assert (jcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi Htid).

          assert (dcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi' Htid').

          rewrite (gsoThreadRes _ jcnt2); auto.

          rewrite (gsoThreadRes _ dcnt2); auto.

      - destruct (eq_dec i tid).

        + subst.

          rewrite (gssThreadRes _ _ _ Htid); auto.

          rewrite (gssThreadRes _ _ _ Htid'); simpl; auto.

        + assert (jcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi Htid).

          assert (dcnt2:= @cntUpdateC' _ _ _ _ _ _ Kc Hi' Htid').

          rewrite (gsoThreadRes _ jcnt2); auto.

          rewrite (gsoThreadRes _ dcnt2); auto.

      - simpl;  apply mtch_locks.

      - rewrite gsoThreadLPool in H2; rewrite gsoThreadLPool in H3.

        eapply mtch_locksEmpty; eassumption.

      - rewrite gsoThreadLPool in H2; rewrite gsoThreadLPool in H3.

        eapply mtch_locksRes; eassumption.

      - rewrite gsoThreadLPool in H2; rewrite gsoThreadLPool in H3.

        eapply mtch_locksRes0; eassumption.

    Qed.



    Lemma match_st_age_tp_to tp n ds :

      match_st tp ds -> match_st (Concur.age_tp_to n tp) ds.

    Proof.

      intros M.

      inversion M as [? ? A B C D E F G H I J]; subst.

      constructor; intros.

      - now apply A; (eapply Concur.cnt_age, H0).

      - apply Concur.cnt_age', B; auto.

      - now erewrite <-Concur.gtc_age; eauto.

      - erewrite <-D.

        erewrite <-Concur.getThreadR_age; eauto.

        erewrite Concur.perm_of_age.

        reflexivity.

      - erewrite <- E.

        erewrite <-Concur.getThreadR_age; eauto.

        erewrite Concur.perm_of_age_lock.

        reflexivity.

      - erewrite <-F.

        apply Concur.LockRes_age.

      - unshelve eapply G with (lock := lock); auto.

        simpl in *.

        unfold OrdinalPool.lockRes, OrdinalPool.lockGuts in *.

        rewrite lset_age_tp_to in H0.

        rewrite AMap_find_map_option_map in H0.

        simpl in *.

        destruct (AMap.find (elt:=option rmap) lock (OrdinalPool.lset tp))

          as [[o|]|]; simpl in *; congruence.

      - simpl in *.

        specialize (H lock).

        unfold OrdinalPool.lockRes in *.

        unfold OrdinalPool.lockGuts in *.

        rewrite lset_age_tp_to in H0.

        simpl in *.

        rewrite AMap_find_map_option_map in H0.

        destruct (AMap.find (elt:=option rmap) lock (OrdinalPool.lset tp))

          as [[o|]|]; simpl in *; try congruence.

        specialize (H o dres Logic.eq_refl ltac:(assumption)).

        rewrite <-H.

        injection H0 as <-.

        apply Concur.perm_of_age.

        

      - simpl in *.

        specialize (I lock).

        unfold OrdinalPool.lockRes in *.

        unfold OrdinalPool.lockGuts in *.

        rewrite lset_age_tp_to in H0.

        simpl in *.

        rewrite AMap_find_map_option_map in H0.

        destruct (AMap.find (elt:=option rmap) lock (OrdinalPool.lset tp))

          as [[o|]|]; simpl in *; try congruence.

        specialize (I o dres Logic.eq_refl ltac:(assumption)).

        rewrite <-I.

        injection H0 as <-.

        apply Concur.perm_of_age_lock.

        

        Unshelve. auto. auto. auto.

    Qed.



    Definition match_rmap_perm (rmap : rmap) (pmap: access_map * access_map): Prop:=

      (forall b ofs, perm_of_res (rmap @ (b, ofs)) = pmap.1 !! b ofs) /\

               pmap.2 = empty_map.



     Definition no_locks_perm (rmap : rmap): Prop:=

      forall b ofs, perm_of_res_lock (rmap @ (b, ofs)) = None.



    Lemma MTCH_initial:

      forall  c rmap pmap,

        match_rmap_perm rmap pmap ->

        no_locks_perm rmap ->

        match_st (Concur.initial_machine rmap c) (DryHybridMachine.initial_machine  pmap.1 c).

    Proof.

      intros.

      constructor.

      - intro i. unfold containsThread, Concur.initial_machine; simpl.

        unfold containsThread, DryHybridMachine.initial_machine; simpl.

        trivial.

      - intro i. unfold containsThread, Concur.initial_machine; simpl.

        unfold containsThread, DryHybridMachine.initial_machine; simpl.

        trivial.

      - reflexivity.

      - intros.

        unfold getThreadR; unfold Concur.initial_machine; simpl.

        unfold getThreadR; unfold DryHybridMachine.initial_machine; simpl.

        unfold match_rmap_perm in H. apply H.

      - intros.

        unfold getThreadR; unfold Concur.initial_machine; simpl.

        rewrite empty_map_spec; apply H0.

      - unfold empty_rmap, "@"; simpl.

        reflexivity.

      - unfold lockRes, DryHybridMachine.initial_machine; simpl.

        intros. setoid_rewrite OrdinalPool.find_empty in H2; inversion H2.

      - unfold lockRes, DryHybridMachine.initial_machine; simpl.

        intros. setoid_rewrite OrdinalPool.find_empty in H2; inversion H2.

      - unfold lockRes, DryHybridMachine.initial_machine; simpl.

        intros. setoid_rewrite OrdinalPool.find_empty in H2; inversion H2.

    Qed.



    Lemma contains_iff_num:

      forall (js : jstate) (ds : dstate)

        (Hcnt: forall i, containsThread js i <-> containsThread ds i),

        OrdinalPool.num_threads js = OrdinalPool.num_threads ds.

    Proof.

      intros.

      simpl in *.

      unfold OrdinalPool.containsThread in *.

      remember (OrdinalPool.num_threads js).

      remember (OrdinalPool.num_threads ds).

      destruct p, p0; simpl in *.

      assert (n = n0).

      { clear - Hcnt.

        generalize dependent n0.

        induction n; intros.

        destruct n0; auto.

        destruct (Hcnt 0%nat).

        exfalso.

        specialize (H0 ltac:(ssromega));

          by ssromega.



        destruct n0.

        exfalso.

        destruct (Hcnt 0%nat).

        specialize (H ltac:(ssromega));

          by ssromega.

        erewrite IHn; eauto.

        intros; split; intro H.

        assert (i.+1 < n.+1) by ssromega.

        specialize (proj1 (Hcnt (i.+1)) H0).

        intros.

        clear -H1;

          by ssromega.

        assert (i.+1 < n0.+1) by ssromega.

        specialize (proj2 (Hcnt (i.+1)) H0).

        intros.

        clear -H1;

          by ssromega. }

      subst.

        by erewrite proof_irr with (a1 := N_pos) (a2 := N_pos0).

    Qed.



    Lemma MTCH_latestThread: forall js ds,

        match_st js ds ->

        latestThread js = latestThread ds.

    Proof.

      intros js ds MATCH.

      simpl.

      unfold OrdinalPool.latestThread.

      erewrite contains_iff_num.

      - reflexivity.

      - split; generalize i; inversion MATCH; assumption.

    Qed.



Lemma perm_of_writable0: 

   forall sh, shares.writable0_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

Proof.

intros.

unfold perm_of_sh.

rewrite if_true; auto. rewrite if_false; auto.

Qed.



    Lemma MTCH_addThread: forall js ds parg arg phi res lres,

        match_st js ds ->

        (forall b0 ofs0, perm_of_res (phi@(b0, ofs0)) = res !! b0 ofs0) ->

        (forall b0 ofs0, perm_of_res_lock (phi@(b0, ofs0)) = lres !! b0 ofs0) ->

        match_st

          (addThread js parg arg phi)

          (addThread ds parg arg (res,lres)).

    Proof.

      intros ? ? ? ? ? ? ? MATCH DISJ. constructor.

      - intros tid HH.

        apply cntAdd' in HH. destruct HH as [[HH ineq] | HH].

        + apply cntAdd. inversion MATCH. apply mtch_cnt. assumption.

        +

          erewrite MTCH_latestThread in HH.

          rewrite HH.

          apply OrdinalPool.contains_add_latest.

          assumption.

      - intros tid HH.

        apply cntAdd' in HH. destruct HH as [[HH ineq] | HH].

        + apply cntAdd. inversion MATCH. eapply  mtch_cnt'; assumption.

        + erewrite <- MTCH_latestThread in HH.

          rewrite HH.

          apply OrdinalPool.contains_add_latest.

          assumption.

      - intros.

        destruct (cntAdd' _ _ _ Htid) as [[jcnt jNLast]| jLast];

          destruct (cntAdd' _ _ _ Htid') as [[dcnt dNLast]| dLast].

        * erewrite !gsoAddCode; try eassumption.

          inversion MATCH. eapply mtch_gtc.

        * contradict jNLast.

          rewrite <- (MTCH_latestThread js ds) in dLast.

          rewrite dLast; reflexivity.

          assumption.

        * contradict dNLast.

          rewrite (MTCH_latestThread js ds) in jLast.

          rewrite jLast; reflexivity.

          assumption.

        * erewrite !gssAddCode; try eassumption.

          reflexivity.

      - intros.

        destruct (cntAdd' _ _ _ Htid) as [[jcnt jNLast]| jLast];

          destruct (cntAdd' _ _ _ Htid') as [[dcnt dNLast]| dLast].

        * erewrite !gsoAddRes; try eassumption.

          inversion MATCH. eapply mtch_perm1.

        * contradict jNLast.

          rewrite <- (MTCH_latestThread js ds) in dLast.

          rewrite dLast; reflexivity.

          assumption.

        * contradict dNLast.

          rewrite (MTCH_latestThread js ds) in jLast.

          rewrite jLast; reflexivity.

          assumption.

        * erewrite !gssAddRes; try eassumption.

          apply DISJ.

      - intros.

        destruct (cntAdd' _ _ _ Htid) as [[jcnt jNLast]| jLast];

          destruct (cntAdd' _ _ _ Htid') as [[dcnt dNLast]| dLast].

        * erewrite !gsoAddRes; try eassumption.

          inversion MATCH. eapply mtch_perm2.

        * contradict jNLast.

          rewrite <- (MTCH_latestThread js ds) in dLast.

          rewrite dLast; reflexivity.

          assumption.

        * contradict dNLast.

          rewrite (MTCH_latestThread js ds) in jLast.

          rewrite jLast; reflexivity.

          assumption.

        * erewrite !gssAddRes; try eassumption.

          simpl; apply H.

      - intros. rewrite gsoAddLPool gsoAddLPool.

        inversion MATCH. apply mtch_locks.

      - intros lock dres.

        rewrite gsoAddLPool gsoAddLPool.

        inversion MATCH. apply mtch_locksEmpty.

      - intros lock jres dres .

        rewrite gsoAddLPool gsoAddLPool.

        inversion MATCH. apply mtch_locksRes.

      - intros lock jres dres .

        rewrite gsoAddLPool gsoAddLPool.

        inversion MATCH. apply mtch_locksRes0.

        Grab Existential Variables.

        assumption.

        assumption.

        assumption.

        assumption.

        assumption.

        assumption.

    Qed.



    Lemma MTCH_age: forall js ds age,

        match_st js ds ->

        match_st (Concur.age_tp_to age js) ds.

    Proof.

      intros js ds age MATCH; inversion MATCH. constructor.

      -

        intros i HH. apply Concur.cnt_age in HH.

        apply mtch_cnt; assumption.

      - intros i HH. apply @Concur.cnt_age'.

        apply mtch_cnt'; assumption.

      - intros i cnt cnt'.

        simpl; setoid_rewrite <- Concur.gtc_age.

        eapply mtch_gtc.

      - intros.

        setoid_rewrite <- Concur.getThreadR_age. simpl.

        rewrite Concur.perm_of_age.

        apply mtch_perm1.

      - intros.

        erewrite <- Concur.getThreadR_age. simpl.

        rewrite Concur.perm_of_age_lock.

        apply mtch_perm2.

      - intros.

        rewrite Concur.LockRes_age. apply mtch_locks.

      - intros.



        apply Concur.LockRes_age_content1 in H1.

        eapply mtch_locksEmpty; eassumption.

      -

        intros. apply Concur.LockRes_age_content2 in H1.

        destruct H1 as [r [AA BB]].

        rewrite BB.

        rewrite Concur.perm_of_age.

        eapply mtch_locksRes; eassumption.

      -

        intros. apply Concur.LockRes_age_content2 in H1.

        destruct H1 as [r [AA BB]].

        rewrite BB.

        rewrite Concur.perm_of_age_lock.

        eapply mtch_locksRes0; eassumption.



        Grab Existential Variables.

        eapply Concur.cnt_age; eassumption.

        eapply Concur.cnt_age; eassumption.

        eapply Concur.cnt_age; eassumption.

    Qed.



    Lemma MTCH_tp_update: forall js ds phi js' phi',

        match_st js ds -> tp_update js phi js' phi' ->

        match_st js' ds.

    Proof.

      inversion 1; subst.

      intros (Hl & Hr & Hj & Hcnt & Hget & Hlock). constructor.

      - intros i HH. apply Hcnt in HH.

        apply mtch_cnt; assumption.

      - intros i HH. apply Hcnt.

        apply mtch_cnt'; assumption.

      - intros i cnt cnt'.

        assert (containsThread js i) as cnt0 by (apply Hcnt; auto).

        specialize (Hget _ cnt0) as [Hget _].

        replace (proj2 _ _) with cnt in Hget by apply proof_irr.

        rewrite <- Hget; auto.

      - intros.

        assert (containsThread js tid) as cnt0 by (apply Hcnt; auto).

        specialize (Hget _ cnt0) as (_ & _ & Hget).

        replace (proj2 _ _) with Htid in Hget by apply proof_irr.

        rewrite <- Hget; auto.

      - intros.

        assert (containsThread js tid) as cnt0 by (apply Hcnt; auto).

        specialize (Hget _ cnt0) as (_ & _ & Hget).

        replace (proj2 _ _) with Htid in Hget by apply proof_irr.

        rewrite <- Hget; auto.

      - intros.

        destruct Hlock as (_ & _ & -> & _); auto.

      - intros.

        destruct Hlock as (_ & _ & Hlock & _); rewrite Hlock in H0.

        eapply mtch_locksEmpty; eassumption.

      - intros.

        destruct Hlock as (_ & _ & Hlock & _); rewrite Hlock in H0.

        eapply mtch_locksRes; eassumption.

      - intros.

        destruct Hlock as (_ & _ & Hlock & _); rewrite Hlock in H0.

        eapply mtch_locksRes0; eassumption.

    Qed.



  Lemma perm_of_readable' : forall sh, shares.readable_share sh ->

    Mem.perm_order' (perm_of_sh (Share.glb Share.Rsh sh)) Readable.

  Proof.

    intros; unfold perm_of_sh.

    if_tac.

    - erewrite if_false by (apply shares.glb_Rsh_not_top); constructor.

    - erewrite if_true by (apply shares.readable_glb; auto); constructor.

  Qed.



  Lemma perm_of_writable' : forall sh, shares.writable0_share sh ->

    Mem.perm_order' (perm_of_sh sh) Writable.

  Proof.

    intros; unfold perm_of_sh.

    erewrite if_true by auto.

    if_tac; constructor.

  Qed.



  Lemma lock_range_perm : forall m js ds (MATCH : match_st js ds) i (Hi : containsThread js i)

    (Hcmpt : mem_compatible js m) b ofs 

    sh R (HJcanwrite : Concur.lock_at_least sh R (getThreadR Hi) b (Ptrofs.intval ofs)),

    Mem.range_perm (Concur.juicyRestrict_locks (Concur.mem_compat_thread_max_cohere Hcmpt Hi)) b

      (Ptrofs.intval ofs) (Ptrofs.intval ofs + LKSIZE) Cur Readable.

  Proof.

    intros.

    intros j ?. specialize (HJcanwrite (j-Ptrofs.intval ofs)). spec HJcanwrite; [omega|].

    destruct HJcanwrite as [sh' [rsh' [? ?]]].

    replace (Ptrofs.intval ofs + (j - Ptrofs.intval ofs)) with j in H1 by omega.

    unfold Concur.juicyRestrict_locks, Mem.perm.

    setoid_rewrite restrPermMap_Cur.

    rewrite <- Concur.juic2Perm_locks_correct by (eapply Concur.mem_compat_thread_max_cohere; auto).

    rewrite H1. 

      apply perm_of_readable'; auto.

  Qed.

  

  Inductive deltaMap_cases (dmap:delta_map) b ofs:=

  | DMAPS df p:  dmap ! b = Some df -> df ofs = Some p -> deltaMap_cases dmap b ofs

  | DNONE1 df:  dmap ! b = Some df -> df ofs = None -> deltaMap_cases dmap b ofs

  | DNONE2:  dmap ! b = None -> deltaMap_cases dmap b ofs.



  Lemma deltaMap_dec: forall dmap b ofs, deltaMap_cases dmap b ofs.

  Proof.

    intros. destruct (dmap ! b) eqn:H1; [destruct (o ofs) eqn:H2 | ]; econstructor; eassumption.

  Qed.

 

  Lemma permMapsDisjoint2_empty: forall rmap,

      permMapsDisjoint2 (empty_map, empty_map) rmap.

  Proof.

    intros rmap.

    split; simpl;

      apply permDisjoint_permMapsDisjoint;

      intros b ofs.

    - rewrite empty_map_spec.

      apply permDisjoint_None.

    - rewrite empty_map_spec.

      apply permDisjoint_None.

  Qed.

  

  Lemma po_None1: forall p, Mem.perm_order'' None p -> p = None.

  Proof. intros. simpl in H. destruct p; inversion H; reflexivity. Qed.



  Lemma addThrd_inv: forall (ds : dstate) vf arg new_perm,

      invariant ds  ->

      (forall i cnti,

          permMapsDisjoint2 new_perm (@getThreadR _ _ _ i ds cnti)) ->

      (forall l rm,  lockRes ds l = Some rm ->

                permMapsDisjoint2 new_perm rm) ->

      permMapCoherence new_perm.1 new_perm.2 ->

      (forall i cnti,

          permMapCoherence new_perm.1 (@getThreadR _ _ _ i ds cnti).2) ->

      (forall i cnti,

          permMapCoherence (@getThreadR _ _ _ i ds cnti).1 new_perm.2) ->

      (forall l rm,  lockRes ds l = Some rm ->

                permMapCoherence new_perm.1 rm.2) ->

      (forall l rm,  lockRes ds l = Some rm ->

                permMapCoherence rm.1 new_perm.2) ->

      invariant (addThread ds vf arg new_perm).

  Proof.

    move => ds vf arg new_perm dinv

              DISJ_RES DISJ_LOCK COH_SELF COH_RES1

              COH_RES2 COH_LOCK1 COH_LOCK2.

    constructor.

    - move => i j cnti cntj neq.

      assert (cntj':=cntj).

      assert (cnti':=cnti).

      apply cntAdd' in cnti'.

      apply cntAdd' in cntj'.

      destruct cntj' as [[H1 H2] | H1];

        destruct cnti' as [[H3 H4] | H3]; subst;

          try solve[exfalso; apply neq; reflexivity].

      + rewrite (gsoAddRes _ _ _ _ H1) .

        rewrite (gsoAddRes _ _ _ _ H3).

        inversion dinv; eauto.

      + rewrite (gsoAddRes _ _ _ _ H1).

        erewrite gssAddRes; auto.

      + rewrite (gsoAddRes _ _ _ _ H3).

        apply permMapsDisjoint2_comm.

        erewrite gssAddRes; auto.

    - move => l1 l2 mr1 mr2.

      rewrite gsoAddLPool.

      rewrite gsoAddLPool.

      inversion dinv; eauto.

    - move => i l cnti rm.

      rewrite gsoAddLPool.

      assert (cnti':=cnti).

      apply cntAdd' in cnti'.

      destruct cnti' as [[H1 H2] | H1].

      + rewrite (gsoAddRes _ _ _ _ H1).

        inversion dinv; eauto.

      + erewrite gssAddRes; eauto.

    - move => i cnti; split.

      + assert (cnti':=cnti).

        apply cntAdd' in cnti'.

        destruct cnti' as [[H1 H2] | H1].

        * inversion dinv.

          move: (thread_data_lock_coh0 i H1)=> [] AA _.

          move => j cntj.

          assert (cntj':=cntj).

          apply cntAdd' in cntj'.

          destruct cntj' as [[H3 H4] | H3].

          -- rewrite (gsoAddRes _ _ _ _ H1) .

             rewrite (gsoAddRes _ _ _ _ H3).

             eapply AA.

          -- rewrite (gsoAddRes _ _ _ _ H1) .

             rewrite (gssAddRes); auto.

        * move => j cntj.

          assert (cntj':=cntj).

          apply cntAdd' in cntj'.

          destruct cntj' as [[H3 H4] | H3].

          -- rewrite (gsoAddRes _ _ _ _ H3).

             rewrite (gssAddRes); auto.

          -- do 2 (rewrite (gssAddRes); auto).

      + assert (cnti':=cnti).

        apply cntAdd' in cnti'.

        destruct cnti' as [[H1 H2] | H1].

        * inversion dinv.

          move: (thread_data_lock_coh0 i H1)=> [] _ BB.

          move => l rm.

          rewrite (gsoAddRes _ _ _ _ H1).

          rewrite gsoAddLPool.

          eauto.

        * move => l rm.

          rewrite (gssAddRes); auto.

          rewrite gsoAddLPool.

          eauto.

    - move=> l rm;

              rewrite gsoAddLPool => isLock.

      inversion dinv.

      move: (locks_data_lock_coh0 l rm isLock)=> [] AA BB.

      split.

      + move => j cntj.

        assert (cntj':=cntj).

        apply cntAdd' in cntj'.

        destruct cntj' as [[H3 H4] | H3].

        -- rewrite (gsoAddRes _ _ _ _ H3).

           inversion dinv; eauto.

        -- (rewrite (gssAddRes); auto).

           eauto.

      + move => l2 rm2;

                 rewrite gsoAddLPool => isLock2.

        eauto.

    - move => b ofs.

      inversion dinv; simpl; eauto.

      apply lockRes_valid0.

  Qed.



  Lemma sync_step_diagram:

    forall (m m':Memory.mem) (U:seq nat) js js' ds i ev

          (MATCH: match_st js ds)

          (dinv: invariant ds)

            (Hi: containsThread js i)

            (Hcmpt: mem_compatible js m)

            (HschedN: schedPeek U = Some i)

      (Htstep:  syncStep true Hi Hcmpt js' m' ev),

      exists ds' : dstate, exists ev',

        invariant ds' /\ match_st js' ds' /\

        syncStep true (MTCH_cnt MATCH Hi) (MTCH_compat _ _ _ MATCH Hcmpt) ds' m' ev'.

  Proof.

    intros.

    inversion Htstep; try subst.

    

    { 

        

    assert (Htid':= MTCH_cnt MATCH Hi).

    pose (inflated_delta1:=

            fun loc => match (d_phi @ loc ) with

                      NO s _ => if Share.EqDec_share s Share.bot then None else Some ( perm_of_res (phi' @ loc))

                    | _ => Some (perm_of_res (phi' @ loc))

                    end).

    pose (inflated_delta2:=

            fun loc =>  match (d_phi @ loc ) with

                       NO s _ => if Share.EqDec_share s Share.bot then None else

                                Some ( perm_of_res_lock (phi' @ loc))

                    | _ => Some (perm_of_res_lock (phi' @ loc))

                    end).

         pose (virtue1:= PTree.map

                                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                                         (inflated_delta1 (block, ofs))) (snd (getMaxPerm m)) ).



         pose (virtue2:= PTree.map

                                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                                         (inflated_delta2 (block, ofs))) (snd (getMaxPerm m)) ).

         assert (virtue_some1: forall l p, inflated_delta1 l = Some p ->

                             p = perm_of_res (phi' @ l)).

            {

              intros l p; unfold inflated_delta1.

              destruct (d_phi @ l); try solve[intros HH; inversion HH; reflexivity].

              destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot));

                [congruence| intros HH; inversion HH; reflexivity]. }

            assert (virtue_some2: forall l p, inflated_delta2 l = Some p ->

                                        p = perm_of_res_lock (phi' @ l)).

            {

               intros l p; unfold inflated_delta2.

              destruct (d_phi @ l); try solve[intros HH; inversion HH; reflexivity].

              destruct ( proj_sumbool (Share.EqDec_share sh0 Share.bot));

                [congruence| intros HH; inversion HH; reflexivity]. }



            assert (virtue_correct1: forall b ofs,

                       (computeMap (getThreadR Htid').1 virtue1)  !! b ofs

                       = perm_of_res (phi' @ (b, ofs))

                   ).

            { intros.

              destruct (deltaMap_dec virtue1 b0 ofs0).

              -  rewrite (computeMap_1 _ _ _ _ e e0).

                 move: e.

                 rewrite /virtue1 /inflated_delta1 PTree.gmap.

                 destruct (((getMaxPerm m).2) ! b0);

                   intros HH; inversion HH as [H0].

                 move :e0; rewrite -H0.

                 destruct (d_phi @ (b0, ofs0)); intros HH';

                 try solve[inversion HH'; reflexivity].

                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)); inversion HH'.

                 reflexivity.

              -  rewrite (computeMap_2 _ _ _ _ e).

                 move: e.

                 rewrite /virtue1 /inflated_delta1 PTree.gmap.

                 destruct (((getMaxPerm m).2) ! b0);

                   intros HH; inversion HH as [H0].

                 move :e0; rewrite -H0.

                 destruct (d_phi @ (b0, ofs0)) eqn:dphibo; intros HH';

                 try solve[inversion HH'].

                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)) eqn:isBot; inversion HH'.

                 move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).

                 rewrite dphibo.

                 replace (NO sh0 n) with (NO Share.bot shares.bot_unreadable).

                 move => /join_comm

                 /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.

                 symmetry. inversion MATCH; auto.

                 destruct (Share.EqDec_share sh0 Share.bot); inversion isBot.

                 subst sh0; f_equal. apply proof_irr.

                 assumption.

              - rewrite (computeMap_3 _ _ _ _ e).

                move: e.

                rewrite /virtue1 /inflated_delta1 PTree.gmap.

                destruct (((getMaxPerm m).2) ! b0) eqn:isNO;

                  intros HH; try solve[inversion HH].

                clear HH.

                move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).

                cut (d_phi @ (b0,ofs0) = NO Share.bot shares.bot_unreadable).

                { move => -> .

                  move => /join_comm

                          /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.

                  symmetry. inversion MATCH; auto.

                }

                destruct Hcmpt as [x Hcmpt']; inversion Hcmpt'.

                move: juice_join => /Concur.compatible_lockRes_sub.

                move => /(_ _ _ His_unlocked) /(resource_at_join_sub _ _ (b0, ofs0)) .

                cut (x @ (b0, ofs0) = NO Share.bot shares.bot_unreadable).

                { move=> -> . elim=> X Join. inversion Join; subst.

                  apply permjoin.join_to_bot_l in RJ; subst sh1.

                  f_equal. apply proof_irr. }

                { inversion all_cohere.

                  specialize (max_coh (b0, ofs0)). move: isNO max_coh.

                  rewrite /max_access_at /access_at /getMaxPerm /PMap.get PTree.gmap1 /=.

                  destruct (((Mem.mem_access m).2) ! b0)=> HH; try solve[ inversion HH].

                  rewrite Concur.Mem_canonical_useful /=.

                  destruct (x @ (b0, ofs0))=> /=.

                  - destruct (eq_dec sh0 Share.bot); subst => //.

                    intros; f_equal. apply proof_irr.

                  - destruct (perm_of_sh sh0) eqn:POSsh0;

                      try (intros ?; exfalso; assumption).

                    apply perm_of_empty_inv in POSsh0; subst.

                    exfalso; apply shares.bot_unreadable; assumption.

                  - tauto.

                }

            }



             assert (virtue_correct2: forall b ofs,

                       (computeMap (getThreadR Htid').2 virtue2)  !! b ofs

                       = perm_of_res_lock (phi' @ (b, ofs))

                   ).

            { intros.

              destruct (deltaMap_dec virtue2 b0 ofs0).

              -  rewrite (computeMap_1 _ _ _ _ e e0).

                 move: e.

                 rewrite /virtue2 /inflated_delta2 PTree.gmap.

                 destruct (((getMaxPerm m).2) ! b0);

                   intros HH; inversion HH as [H0].

                 move :e0; rewrite -H0.

                 destruct (d_phi @ (b0, ofs0)); intros HH';

                 try solve[inversion HH'; reflexivity].

                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)); inversion HH'.

                 reflexivity.

              -  rewrite (computeMap_2 _ _ _ _ e).

                 move: e.

                 rewrite /virtue2 /inflated_delta2 PTree.gmap.

                 destruct (((getMaxPerm m).2) ! b0);

                   intros HH; inversion HH as [H0].

                 move :e0; rewrite -H0.

                 destruct (d_phi @ (b0, ofs0)) eqn:dphibo; intros HH';

                 try solve[inversion HH'].

                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)) eqn:isBot; inversion HH'.

                 move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).

                 rewrite dphibo;

                 replace (NO sh0 n) with (NO Share.bot shares.bot_unreadable).

                 move => /join_comm

                         /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.

                 symmetry. inversion MATCH; auto.

                 destruct (Share.EqDec_share sh0 Share.bot); inversion isBot; auto.

                 subst sh0; f_equal; apply proof_irr.

                 assumption.

              - rewrite (computeMap_3 _ _ _ _ e).

                move: e.

                rewrite /virtue2 /inflated_delta2 PTree.gmap.

                destruct (((getMaxPerm m).2) ! b0) eqn:isNO;

                  intros HH; try solve[inversion HH].

                clear HH.

                move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).

                cut (d_phi @ (b0,ofs0) = NO Share.bot shares.bot_unreadable).

                { move => -> .

                  move => /join_comm /(@join_unit1_e _ _ _ (NO Share.bot _) _ _

                                                    (NO_identity shares.bot_unreadable)) <-.

                  symmetry. inversion MATCH; auto.

                }

                destruct Hcmpt as [x Hcmpt']; inversion Hcmpt'.

                move: juice_join => /Concur.compatible_lockRes_sub.

                move => /(_ _ _ His_unlocked) /(resource_at_join_sub _ _ (b0, ofs0)) .

                cut (x @ (b0, ofs0) = NO Share.bot shares.bot_unreadable).

                { move=> -> . elim=> X Join. inversion Join; subst.

                  apply permjoin.join_to_bot_l in RJ.

                  subst. f_equal; apply proof_irr. }

                { inversion all_cohere.

                  specialize (max_coh (b0, ofs0)). move: isNO max_coh.

                  rewrite /max_access_at /access_at /getMaxPerm /PMap.get PTree.gmap1 /=.

                  destruct (((Mem.mem_access m).2) ! b0)=> HH; try solve[ inversion HH].

                  rewrite Concur.Mem_canonical_useful /=.

                  destruct (x @ (b0, ofs0))=> /=.

                  - destruct (eq_dec sh0 Share.bot) eqn:?; subst => //.

                    intros; f_equal; apply proof_irr.

                  - destruct (perm_of_sh sh0) eqn:POSsh0;

                      try (intros ?; exfalso; assumption).

                    apply perm_of_empty_inv in POSsh0; subst.

                    exfalso; apply shares.bot_unreadable; assumption.

                  - tauto.

                }

            }



         pose (ds':= updThread Htid' (Kresume c Vundef)

                  (computeMap

                     (getThreadR Htid').1 virtue1,

              computeMap

                     (getThreadR Htid').2 virtue2)).

         pose (ds'':= updLockSet ds'

                      (b, Ptrofs.intval ofs) (empty_map,empty_map)).

                      SearchAbout Events.delta_content.

         exists ds'', (Events.acquire (b, Ptrofs.intval ofs) (Some (build_delta_content virtue1 m')) ).

         split; [|split].

    - { 



        unfold ds''.

        rewrite updLock_updThread_comm.

        pose (ds0:= (updLockSet ds (b, (Ptrofs.intval ofs)) (empty_map,empty_map))).



        cut (invariant ds0).

        { 

          intros dinv0.

          apply updThread_inv.



          - assumption.

          - intros.

            assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).

            {assert (Hcmpt':=Hcmpt).

              assert (Hcmpt'':=Hcmpt).

              eapply

                Concur.compatible_threadRes_join

                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))

                in Hcmpt'; auto.

              eapply

                Concur.compatible_threadRes_lockRes_join

              with (cnti:=(MTCH_cnt' MATCH cnt))

                     (l:=(b, Ptrofs.intval ofs))

                     (phi:=d_phi)

                in Hcmpt''; auto.

              intro l; apply resource_at_joins with (loc := l) in Hcmpt';

                apply resource_at_joins with (loc := l) in Hcmpt'';

                apply resource_at_join with (loc := l) in Hadd_lock_res.

              eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;

              eapply joins_comm; auto.

            }



            split;

            eapply permDisjoint_permMapsDisjoint; intros b0 ofs0; simpl.

            + rewrite virtue_correct1 (MTCH_perm' _ MATCH b0 ofs0).

              apply joins_permDisjoint; auto.

            + rewrite virtue_correct2 (MTCH_perm2' _ MATCH b0 ofs0).

              apply joins_permDisjoint_lock; auto.

          - intros; intros b0 ofs0.

            destruct (eq_dec i j).

            + subst j.

              rewrite virtue_correct2 (MTCH_perm' _ MATCH b0 ofs0).

              contradiction.

            + rewrite virtue_correct2 (MTCH_perm' _ MATCH b0 ofs0).

              assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).

              {assert (Hcmpt':=Hcmpt).

               assert (Hcmpt'':=Hcmpt).

               eapply

                Concur.compatible_threadRes_join

                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))

                in Hcmpt'; auto.

               eapply

                 Concur.compatible_threadRes_lockRes_join

                 with (cnti:=(MTCH_cnt' MATCH cnt))

                     (l:=(b, Ptrofs.intval ofs))

                     (phi:=d_phi)

                 in Hcmpt''; auto.

               intro l; apply resource_at_joins with (loc := l) in Hcmpt';

                 apply resource_at_joins with (loc := l) in Hcmpt'';

                 apply resource_at_join with (loc := l) in Hadd_lock_res.

               eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;

               eapply joins_comm; auto.

             }



              apply perm_coh_joins.

              apply joins_comm; auto.



          - intros; intros b0 ofs0.

            destruct (eq_dec i j).

            + subst j.

              contradiction.

            + rewrite virtue_correct1 (MTCH_perm2' _ MATCH b0 ofs0).

              assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).

              {assert (Hcmpt':=Hcmpt).

               assert (Hcmpt'':=Hcmpt).

               eapply

                Concur.compatible_threadRes_join

                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))

                in Hcmpt'; auto.

               eapply

                 Concur.compatible_threadRes_lockRes_join

                 with (cnti:=(MTCH_cnt' MATCH cnt))

                     (l:=(b, Ptrofs.intval ofs))

                     (phi:=d_phi)

                 in Hcmpt''; auto.

               intro l; apply resource_at_joins with (loc := l) in Hcmpt';

                 apply resource_at_joins with (loc := l) in Hcmpt'';

                 apply resource_at_join with (loc := l) in Hadd_lock_res.

               eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;

               eapply joins_comm; auto.

              }

              apply perm_coh_joins; auto.

          - intros l pmap0.

            destruct (AMap.E.eq_dec l (b, Ptrofs.intval ofs)).

            + subst l; rewrite gssLockRes; simpl; intros HH; inversion HH; simpl.

              split; apply empty_disjoint'.

            + rewrite gsoLockRes; auto; simpl; intros HH.

              assert (exists pmap1, lockRes js l = Some pmap1).

              { inversion MATCH.

                specialize (mtch_locks l).

                setoid_rewrite HH in mtch_locks.

                destruct (lockRes js l).

                - exists l0; reflexivity.

                - inversion mtch_locks.

              }

              destruct H as [pmap1 HH'].

              destruct pmap1.

              * assert (forall l, joins (r @ l) (phi' @ l)).

               { assert (Hcmpt':=Hcmpt).

                 assert (Hcmpt'':=Hcmpt).

                 eapply

                   Concur.compatible_threadRes_lockRes_join

                 with (cnti:=Hi)

                        (l0:=l)

                        (phi:=r)

                   in Hcmpt'; auto.

                 eapply

                   Concur.compatible_lockRes_join

                 with (l2:=(b, Ptrofs.intval ofs))

                        (l1:=l)

                        (phi2:=d_phi)

                        (phi1:=r)

                   in Hcmpt''; auto.

                 intro l0; apply resource_at_joins with (loc := l0) in Hcmpt';

                   apply resource_at_joins with (loc := l0) in Hcmpt'';

                   apply resource_at_join with (loc := l0) in Hadd_lock_res.

                 eapply joins_comm.

                 eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;

                 eapply joins_comm; auto. }

               split;

                 eapply permDisjoint_permMapsDisjoint; intros b0 ofs0.

               -- rewrite virtue_correct1.

                inversion MATCH.

                erewrite <- mtch_locksRes; eauto.

                apply joins_permDisjoint; auto.

               -- rewrite virtue_correct2.

                  inversion MATCH.

                  erewrite <- mtch_locksRes0; eauto.

                  apply joins_permDisjoint_lock; auto.

              * inversion MATCH.

                specialize (mtch_locksEmpty l pmap0 HH' HH);

                  subst pmap0;

                  simpl; split; apply permDisjoint_permMapsDisjoint; intros b0 ofs0;

                rewrite empty_map_spec;

                apply permDisjoint_None.

          - intros l pmap0.

            destruct (AMap.E.eq_dec l (b, Ptrofs.intval ofs)).

            + subst l; rewrite gssLockRes; simpl; intros HH; inversion HH; simpl.

              

              split; [apply permCoh_empty | apply permCoh_empty'].

              { move=> b0 ofs0;

                  rewrite virtue_correct2.

                apply perm_of_res_lock_not_Freeable. }



            + rewrite gsoLockRes; auto; simpl; intros HH.

              assert (HH':=HH).

              eapply MTCH_locks in HH'; eauto.

              destruct HH' as [x HH'].

              destruct x.

              * assert (forall l, joins (r @ l) (phi' @ l)).

               { assert (Hcmpt':=Hcmpt).

                 assert (Hcmpt'':=Hcmpt).

                 eapply

                   Concur.compatible_threadRes_lockRes_join

                 with (cnti:=Hi)

                        (l0:=l)

                        (phi:=r)

                   in Hcmpt'; auto.

                 eapply

                   Concur.compatible_lockRes_join

                 with (l2:=(b, Ptrofs.intval ofs))

                        (l1:=l)

                        (phi2:=d_phi)

                        (phi1:=r)

                   in Hcmpt''; auto.

                 intro l0; apply resource_at_joins with (loc := l0) in Hcmpt';

                   apply resource_at_joins with (loc := l0) in Hcmpt'';

                   apply resource_at_join with (loc := l0) in Hadd_lock_res.

                 eapply joins_comm.

                 eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;

                 eapply joins_comm; auto. }

                split; intros b0 ofs0.

                -- rewrite virtue_correct2.

                   inversion MATCH.

                   erewrite <- mtch_locksRes; eauto.

                   apply perm_coh_joins; auto.

                -- rewrite virtue_correct1.

                   inversion MATCH.

                   erewrite <- mtch_locksRes0; eauto.

                   apply perm_coh_joins; apply joins_comm; auto.

              * inversion MATCH.

                specialize (mtch_locksEmpty l _ HH' HH).

                subst pmap0; split; intros b0 ofs0;

                simpl; rewrite empty_map_spec.



                apply perm_coh_empty_2.

                rewrite virtue_correct2.

                apply perm_of_res_lock_not_Freeable.

                apply perm_coh_empty_1.

          - simpl. intros b0 ofs0.

            rewrite virtue_correct1 virtue_correct2.

            eapply perm_coh_self.

        }



            { apply updLock_inv.

              - assumption.

              - intros.

                apply permMapsDisjoint2_empty.



              - intros.

                apply permMapsDisjoint2_comm.

                apply permMapsDisjoint2_empty.

              - intros.

                split; [apply permCoh_empty | apply permCoh_empty'].

                { move=> b0 ofs0.

                  apply (invariant_not_freeable) with (b1:=b0)(ofs1:= ofs0) in dinv.

                  destruct dinv as [AA BB].

                  eapply BB in H0.

                  destruct ((rmap'0.2) # b0 ofs0); try constructor.

                  destruct p; try constructor.

                  exfalso; apply H0; reflexivity. }

              - simpl.

                apply permCoh_empty'.

              - intros.

                split; [apply permCoh_empty | apply permCoh_empty'].

                { move=> b0 ofs0.

                  rewrite (MTCH_perm2' _ MATCH).

                  apply perm_of_res_lock_not_Freeable. }

              - simpl; intros.

                cut (lockRes js (b, ofs0) = None).

                { intros HH. inversion MATCH.

                  specialize (mtch_locks (b, ofs0)).

                  rewrite HH in mtch_locks.

                  clear - mtch_locks.

                  destruct (lockRes ds (b, ofs0)) eqn:AA; auto.

                  - inv mtch_locks.

                }

                {

                  move HJcanwrite at bottom.

                  destruct Hcmpt as [all_juice Hcmpt].

                  inversion Hcmpt.

                  unfold Concur.juicyLocks_in_lockSet in jloc_in_set.

                  eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.

                  destruct juice_join as [x H0].

                  assert (H0':= fun loc => resource_at_join _ _ _ loc H0).

                  apply resource_at_join with (loc:=(b, Ptrofs.intval ofs)) in H0.

                  rewrite <- (fst_snd0 (b, Ptrofs.intval ofs)) in H0.

                  destruct (HJcanwrite 0) as [sh' [rsh' [HJc1 HJc2]]]. pose proof LKSIZE_pos; omega.

                  rewrite HJc2 in H0.

                  simpl in H0; inversion H0.

                  - subst.

                    symmetry in H6.

                    assert (H1 := jloc_in_set (b, Ptrofs.intval ofs)).

                    spec H1. { intros. destruct (HJcanwrite _ H2) as [sh'' [rsh'' [HJc3 HJc4]]].

                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.

                            clear - H0'. inv H0'; eauto.

                    }

                    assert (VALID:= Concur.compat_lr_valid Hcompatible).

                    specialize (VALID b (Ptrofs.intval ofs)).

                    simpl in *.

                    unfold OrdinalPool.lockRes in *.

                    simpl in *.

                    destruct (AMap.find (elt:=option rmap)

                                        (b, Ptrofs.intval ofs) (OrdinalPool.lockGuts js)) eqn:AA;

                      rewrite AA in H1, VALID; try solve[inversion H1].

                    apply VALID. auto.

                  -

                    symmetry in H6.

                    assert (H1 := jloc_in_set (b, Ptrofs.intval ofs)).

                    spec H1. { intros. destruct (HJcanwrite _ H7) as [sh'' [rsh'' [HJc3 HJc4]]].

                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.

                            clear - H0'. inv H0'; eauto.

                    }

                    assert (VALID:= Concur.compat_lr_valid Hcompatible).

                    specialize (VALID b (Ptrofs.intval ofs)).

                    simpl in *.

                    unfold OrdinalPool.lockRes in *.

                    simpl in *.

                    destruct (AMap.find (elt:=option rmap)

                                        (b, Ptrofs.intval ofs) (OrdinalPool.lockGuts js)) eqn:AA;

                      rewrite AA in H1, VALID; try solve[inversion H1].

                    apply VALID. auto.

                }

              - simpl. intros ofs0 ineq. move HJcanwrite at bottom.

                cut ( lockRes js (b, ofs0) = None).

                { intros HH. inversion MATCH.

                  specialize (mtch_locks (b, ofs0)). rewrite HH in mtch_locks.

                  destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto. }

                {

                  destruct (lockRes js (b, ofs0)) eqn:MAP; try reflexivity. exfalso.

                  move HJcanwrite at bottom.

                  destruct Hcmpt as [all_juice Hcmpt].

                  inversion Hcmpt.

                  unfold Concur.juicyLocks_in_lockSet in jloc_in_set.

                  eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.

                  destruct juice_join as [x H0].

                  assert (H0':= fun loc => resource_at_join _ _ _ loc H0).

                  apply resource_at_join with (loc:=(b, Ptrofs.intval ofs)) in H0.

                  rewrite <- (fst_snd0 (b, Ptrofs.intval ofs)) in H0.

                  destruct (HJcanwrite 0) as [sh' [rsh' [HJc1 HJc2]]]. pose proof LKSIZE_pos; omega.

                  rewrite HJc2 in H0.

                  simpl in H0; inversion H0.

                  -

                    symmetry in H5.

                    assert (H8 := jloc_in_set (b, Ptrofs.intval ofs)).

                    spec H8. { intros. destruct (HJcanwrite _ H4) as [sh'' [rsh'' [HJc3 HJc4]]].

                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.

                            clear - H0'. inv H0'; eauto.

                    } 

                    assert (VALID:= Concur.compat_lr_valid Hcompatible).

                    specialize (VALID b ofs0).

                    rewrite MAP in VALID.

                    apply VALID in ineq.

                    move ineq at bottom.

                    setoid_rewrite ineq in H8.

                    inversion H8.

                  -

                    symmetry in H5.

                    assert (H8 := jloc_in_set (b, Ptrofs.intval ofs)).

                    spec H8. { intros. destruct (HJcanwrite _ H4) as [sh'' [rsh'' [HJc3 HJc4]]].

                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.

                            clear - H0'. inv H0'; eauto.

                   }

                    assert (VALID:= Concur.compat_lr_valid Hcompatible).

                    specialize (VALID b ofs0).

                    rewrite MAP in VALID.

                    apply VALID in ineq.

                    move ineq at bottom.

                    setoid_rewrite ineq in H8.

                    inversion H8.

                }

            }

      }

    - unfold ds''.

      apply match_st_age_tp_to.

      apply MTCH_updLockN.

      unfold ds'.

      apply MTCH_update; auto.



    - assert (H: exists l, lockRes ds (b, Ptrofs.intval ofs) = Some l).

      { inversion MATCH; subst.

        specialize (mtch_locks (b, (Ptrofs.intval ofs) )).

        rewrite His_unlocked in mtch_locks.

        destruct (lockRes ds (b, Ptrofs.intval ofs));

          try solve[inversion mtch_locks]. exists l; reflexivity. }

      destruct H as [l dlockRes].

      assert (Hlt'':  permMapLt (setPermBlock (Some Writable) b (Ptrofs.intval ofs)

                                              (getThreadR

                                                 (MTCH_cnt MATCH Hi)).2 LKSIZE_nat)

                                (getMaxPerm m)).

      { intros b0 ofs0.

        move: (Hlt' b0 ofs0).

        

        destruct (peq b b0);

          [subst b0;

            destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

        - do 2 (rewrite setPermBlock_same; auto).

        - apply Intv.range_notin in n; [|simpl; pose proof LKSIZE_pos; omega].

          do 2 (rewrite setPermBlock_other_1; auto).



          destruct Hcmpt as [jall Hcmpt];

            inversion Hcmpt; inversion all_cohere.

          rewrite -Concur.juic2Perm_locks_correct.

          rewrite -(MTCH_perm2 _ MATCH); auto.

          apply Concur.mem_access_coh_sub with (phi1:=jall).

          assumption.

          eapply Concur.compatible_threadRes_sub; eauto.

        - do 2 (rewrite setPermBlock_other_2; auto).

          destruct Hcmpt as [jall Hcmpt];

            inversion Hcmpt; inversion all_cohere.

          rewrite -Concur.juic2Perm_locks_correct.

          rewrite -(MTCH_perm2 _ MATCH); auto.

          apply Concur.mem_access_coh_sub with (phi1:=jall).

          assumption.

          eapply Concur.compatible_threadRes_sub; eauto.

      }



      change virtue1 with (virtue1, virtue2).1.

      econstructor 1.



      15: reflexivity.

      15: now unfold ds'', ds'; repeat f_equal; apply proof_irr.

      8: eassumption.

      10: eassumption.

      + 

        split.

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].



          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta1 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh0 Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption.

          }

          { move: (Concur.compat_lockLT

                        Hcmpt _ His_unlocked p b0).



            rewrite /PMap.get HH' is_none => /po_None1 //.

            }

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta2 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh0 Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          { move: (Concur.compat_lockLT

                        Hcmpt _ His_unlocked p b0).

            rewrite /PMap.get HH' is_none => /po_None1 //.

            }



      + assumption.

      + eapply MTCH_getThreadC; eassumption.

      + reflexivity.

      + eassumption.

      + unfold Concur.juicyRestrict_locks.

        apply restrPermMap_ext;

          intros b0.

        inversion MATCH; subst.

        extensionality ofs0.

        rewrite <- Concur.juic2Perm_locks_correct.

        symmetry. apply mtch_perm2.

        apply Concur.mem_compat_thread_max_cohere.

        assumption.

      + eapply lock_range_perm;  eauto.

      + reflexivity.

      + instantiate (1:= Hlt'').

        apply restrPermMap_ext.

        intros b0.

        extensionality ofs0.

        destruct (ident_eq b b0); [

            destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z) |].

        * unfold Intv.In in i0.

          subst. repeat (rewrite setPermBlock_same; auto).

        * subst. apply Intv.range_notin in n; auto.

          repeat (rewrite setPermBlock_other_1; auto).

          rewrite -Concur.juic2Perm_locks_correct.

          inversion MATCH. symmetry. eapply mtch_perm2.

          eapply Concur.mem_compat_thread_max_cohere; auto.

          simpl; pose proof LKSIZE_pos; xomega.

        * repeat (rewrite setPermBlock_other_2; auto).

          rewrite -Concur.juic2Perm_locks_correct.

          inversion MATCH. symmetry. eapply mtch_perm2.

          eapply Concur.mem_compat_thread_max_cohere; auto.

      + exact dlockRes.

      + intros b0 ofs0. inversion MATCH; subst.

        specialize (mtch_locksRes _ _ _ His_unlocked dlockRes).

        rewrite <- mtch_locksRes.

        rewrite <- mtch_perm1 with (Htid:=Hi).

        replace (MTCH_cnt MATCH Hi) with Htid' by eapply proof_irr.

        rewrite virtue_correct1.

        eapply permjoin.join_permjoin.

        eapply resource_at_join.

        apply join_comm.

        assumption.

      + intros b0 ofs0. inversion MATCH; subst.

        specialize (mtch_locksRes0 _ _ _ His_unlocked dlockRes).

        rewrite <- mtch_locksRes0.

        rewrite <- mtch_perm2 with (Htid:=Hi).

        replace (MTCH_cnt MATCH Hi) with Htid' by eapply proof_irr.

        rewrite virtue_correct2.



             apply permjoin.join_permjoin_lock.

             eapply resource_at_join.

             apply join_comm.

             assumption.

    }



    {



    assert (Htid':= MTCH_cnt MATCH Hi).

    pose (inflated_delta1:=

            fun loc => match (d_phi @ loc ) with

                      NO s _ => if Share.EqDec_share s Share.bot then None else Some ( perm_of_res (phi' @ loc))

                    | _ => Some (perm_of_res (phi' @ loc))

                    end).

    pose (inflated_delta2:=

            fun loc => match (d_phi @ loc ) with

                      NO s _ => if Share.EqDec_share s Share.bot then None

                             else Some ( perm_of_res_lock (phi' @ loc))

                    | _ => Some (perm_of_res_lock (phi' @ loc))

                    end).

    pose (virtue1:= PTree.map

                     (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                        (inflated_delta1 (block, ofs))) (snd (getMaxPerm m)) ).

    pose (virtue2:= PTree.map

                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                         (inflated_delta2 (block, ofs))) (snd (getMaxPerm m)) ).

    pose (ds':= updThread Htid' (Kresume c Vundef)

                                          (computeMap

                                             (getThreadR Htid').1 virtue1,

                                           computeMap

                                             (getThreadR Htid').2 virtue2)).

    pose (ds'':= updLockSet ds' (b, Ptrofs.intval ofs)

                                            (Concur.juice2Perm d_phi m, Concur.juice2Perm_locks d_phi m )).



    assert (virtue_spec1: forall b0 ofs0, perm_of_res (phi' @ (b0, ofs0)) =

                                    (computeMap (getThreadR Htid').1 virtue1) !! b0 ofs0).

    {

      intros b0 ofs0.

      destruct (virtue1 ! b0) eqn:VIRT.

      destruct (o ofs0) eqn:O.

      - erewrite computeMap_1; try eassumption.

        unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.

        destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.

        unfold inflated_delta1 in H0. rewrite <- H0 in O.

        clear VIRT H0.

        replace o0 with (perm_of_res (phi' @ (b0, ofs0))).

        + reflexivity.

        + destruct (d_phi @ (b0, ofs0)) eqn:AA;

            rewrite AA in O;

            try destruct (Share.EqDec_share sh0 Share.bot);

          inversion O; reflexivity.

           - erewrite computeMap_2; try eassumption.

             unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.

             unfold inflated_delta1 in H0. rewrite <- H0 in O.

             apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.

             move Hrem_lock_res at bottom.

             replace (d_phi @ (b0, ofs0)) with (NO Share.bot shares.bot_unreadable)

               in Hrem_lock_res.

             + inversion MATCH; rewrite <- mtch_perm1 with (Htid:= Hi).

               f_equal.

               eapply join_unit1_e; eauto.

               eapply NO_identity.

             + destruct (d_phi @ (b0, ofs0)) eqn:HH; rewrite HH in O; try solve[inversion O].

               destruct ((Share.EqDec_share sh0 Share.bot)); try solve[ inversion O].

               subst; f_equal; apply proof_irr.

           - erewrite computeMap_3; try eassumption.

             unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m)) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m) !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR Htid').1 !! b0 ofs0) with

             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).

             + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.

               unfold Concur.access_cohere' in acc_coh.

               specialize (acc_coh (b0,ofs0)).

               unfold max_access_at, access_at in acc_coh.

               unfold permission_at in the_cure.

               rewrite the_cure in acc_coh.



               apply po_None1 in acc_coh.

               move Hrem_lock_res at bottom.

               apply join_comm in Hrem_lock_res.

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.

               apply join_join_sub in Hrem_lock_res.

               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_lock_res).

               rewrite acc_coh in HH. rewrite acc_coh.

               apply po_None1 in HH. assumption.

             + inversion MATCH; rewrite mtch_perm1; reflexivity.

    }



    assert (virtue_spec2: forall b0 ofs0, perm_of_res_lock (phi' @ (b0, ofs0)) =

                                    (computeMap (getThreadR Htid').2 virtue2) !! b0 ofs0).

    {

      intros b0 ofs0.

      destruct (virtue2 ! b0) eqn:VIRT.

      destruct (o ofs0) eqn:O.

      - erewrite computeMap_1; try eassumption.

        unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.

        destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.

        unfold inflated_delta2 in H0. rewrite <- H0 in O.

        clear VIRT H0.

        replace o0 with (perm_of_res_lock (phi' @ (b0, ofs0))).

        + reflexivity.

        + destruct (d_phi @ (b0, ofs0)) eqn:AA; rewrite AA in O;

            try destruct (Share.EqDec_share sh0 Share.bot);

          inversion O; reflexivity.

           - erewrite computeMap_2; try eassumption.

             unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.

             unfold inflated_delta2 in H0. rewrite <- H0 in O.

             apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.

             move Hrem_lock_res at bottom.

             replace (d_phi @ (b0, ofs0)) with (NO Share.bot shares.bot_unreadable) in Hrem_lock_res.

             + inversion MATCH; rewrite <- mtch_perm2 with (Htid:= Hi).

               f_equal.

               eapply join_unit1_e; eauto.

               eapply NO_identity.

             + destruct (d_phi @ (b0, ofs0)) eqn:HH; rewrite HH in O; try solve[inversion O].

               destruct ((Share.EqDec_share sh0 Share.bot)); try solve[ inversion O].

               subst; f_equal; apply proof_irr. 

           - erewrite computeMap_3; try eassumption.

             unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m)) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m) !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR Htid').2 !! b0 ofs0) with

             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).

             + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.

               unfold max_access_cohere in max_coh.

               specialize (max_coh (b0,ofs0)).

               unfold max_access_at, access_at in max_coh.

               unfold permission_at in the_cure.

               rewrite the_cure in max_coh.



               pose (HERE:= perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).

               eapply juicy_mem_lemmas.perm_order''_trans in HERE; eauto.

               apply po_None1 in HERE.

               move Hrem_lock_res at bottom.

               apply join_comm in Hrem_lock_res.

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.

               apply join_join_sub in Hrem_lock_res.

               assert (HH:= po_join_sub_lock Hrem_lock_res).

               rewrite HERE in HH. rewrite HERE.

               apply po_None1 in HH. assumption.

             + inversion MATCH; rewrite mtch_perm2; reflexivity.

}

SearchAbout Events.delta_content.

SearchAbout access_map delta_map.

    eexists ds'', _.

    split; [|split].

    - unfold ds''.

      cut (invariant ds').

      { intros dinv'.

        apply updLock_inv.

        - assumption.

        - move=> laddr ramp0 laddr_neq .

          unfold ds'; rewrite gsoThreadLPool => get_lres.

          

          move: (get_lres) => /(MTCH_locks) /= /(_ _ MATCH) [] l.

          destruct l.

          + 

            inversion MATCH => jget_lres.

            split.

            * apply permDisjoint_permMapsDisjoint;

              intros b0 ofs0.

              move : (mtch_locksRes _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.

              rewrite -Concur.juic2Perm_correct.

              apply joins_permDisjoint.

              apply resource_at_joins.

              eapply join_sub_joins_trans.

              -- exists phi'; eassumption.

              -- eapply Concur.compatible_threadRes_lockRes_join; eauto.

              -- apply Concur.max_acc_coh_acc_coh.

                 destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

            * apply permDisjoint_permMapsDisjoint;

              intros b0 ofs0.

              move : (mtch_locksRes0 _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.

              rewrite -Concur.juic2Perm_locks_correct.

              apply joins_permDisjoint_lock.

              apply resource_at_joins.

              eapply join_sub_joins_trans.

              -- exists phi'; eassumption.

              -- eapply Concur.compatible_threadRes_lockRes_join; eauto.

              -- destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

          + 

            inversion MATCH.

            move => /(mtch_locksEmpty) // /(_ _ get_lres) ->.

            apply permMapsDisjoint2_comm;

            apply permMapsDisjoint2_empty.



        - rewrite /ds'=> i0.

          destruct (eq_dec i i0).

          + subst=> cnti.

            rewrite gssThreadRes; split=> /=;

              apply permDisjoint_permMapsDisjoint => b0 ofs0.

            * rewrite - virtue_spec1.

              rewrite - Concur.juic2Perm_correct.

              apply joins_permDisjoint.

              apply resource_at_joins.

              apply joins_comm.

              eexists; eassumption.



              apply Concur.max_acc_coh_acc_coh.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

            * rewrite - virtue_spec2.

              rewrite - Concur.juic2Perm_locks_correct.

              apply joins_permDisjoint_lock.

              apply resource_at_joins.

              apply joins_comm.

              eexists; eassumption.



              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

          + move => cnti. rewrite gsoThreadRes => //.

            split=> /=;

              apply permDisjoint_permMapsDisjoint => b0 ofs0.

            * rewrite (MTCH_perm' _ MATCH).

              rewrite - Concur.juic2Perm_correct.

              apply joins_permDisjoint.

              apply resource_at_joins.

              apply joins_comm.

              eapply join_sub_joins_trans.

              exists phi'; eassumption.

              eapply Concur.compatible_threadRes_join;

                eassumption.



              apply Concur.max_acc_coh_acc_coh.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

            * rewrite (MTCH_perm2' _ MATCH).

              rewrite - Concur.juic2Perm_locks_correct.

              apply joins_permDisjoint_lock.

              apply resource_at_joins.

              apply joins_comm.

              eapply join_sub_joins_trans.

              exists phi'; eassumption.

              eapply Concur.compatible_threadRes_join;

                eassumption.



              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

        - move=> laddr ramp0 laddr_neq .

          unfold ds'; rewrite gsoThreadLPool => get_lres.

          

          move: (get_lres) => /(MTCH_locks) /= /(_ _ MATCH) [] l.

          destruct l.

          + 

            inversion MATCH => jget_lres.

            split.

            * intros b0 ofs0.

              move : (mtch_locksRes0 _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.

              rewrite - Concur.juic2Perm_correct.

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply join_sub_joins_trans.

              exists phi'; eassumption.

              eapply Concur.compatible_threadRes_lockRes_join ; eassumption.



              apply Concur.max_acc_coh_acc_coh.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

            * intros b0 ofs0.

              move : (mtch_locksRes _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.

              rewrite - Concur.juic2Perm_locks_correct.

               apply perm_coh_joins.

               apply resource_at_joins.

               apply joins_comm.

              eapply join_sub_joins_trans.

              exists phi'; eassumption.

              eapply Concur.compatible_threadRes_lockRes_join ; eassumption.



              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.



          + 

            inversion MATCH.

            move => /(mtch_locksEmpty) // /(_ _ get_lres) -> /=.

            split; first [apply permCoh_empty'| apply permCoh_empty].

            { move => b0 ofs0.

              rewrite -Concur.juic2Perm_locks_correct.

              apply perm_of_res_lock_not_Freeable.



              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.



            }



        - move=> b0 ofs0 /=.

          assert ( max_access_cohere m d_phi).

          {

             destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption. }



          rewrite - Concur.juic2Perm_locks_correct.

          rewrite - Concur.juic2Perm_correct.

          apply perm_coh_self.



          + apply Concur.max_acc_coh_acc_coh; assumption.

          + assumption.

        - rewrite /ds'=> i0.

          destruct (eq_dec i i0).

          + subst=> cnti. rewrite gssThreadRes; split=> /= b0 ofs0.

            * rewrite - virtue_spec2.

              rewrite - Concur.juic2Perm_correct.

              apply perm_coh_joins.

              apply resource_at_joins.

              eexists; eassumption.



              apply Concur.max_acc_coh_acc_coh.

               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.



            * rewrite - virtue_spec1.

              rewrite - Concur.juic2Perm_locks_correct.

              apply perm_coh_joins.

              apply joins_comm.

              apply resource_at_joins.

              eexists; eassumption.



               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

          + move => cnti. rewrite gsoThreadRes => //.

            split=> /= b0 ofs0.

            * rewrite (MTCH_perm2' _ MATCH).

              rewrite - Concur.juic2Perm_correct.

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply join_sub_joins_trans.

              eexists phi'; eassumption.

              eapply Concur.compatible_threadRes_join; eassumption.



               apply Concur.max_acc_coh_acc_coh.

               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.

            * rewrite (MTCH_perm' _ MATCH).

              rewrite - Concur.juic2Perm_locks_correct.

              apply perm_coh_joins.

              apply resource_at_joins.

              apply joins_comm.

              eapply join_sub_joins_trans.

              eexists phi'; eassumption.

              eapply Concur.compatible_threadRes_join; eassumption.



               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.

                 apply Concur.mem_access_coh_sub with (phi1:= jall).

                  inversion  all_cohere; assumption.

                 apply join_sub_trans with (b1:=(getThreadR Hi)).

                 exists phi'; assumption.

                 apply Concur.compatible_threadRes_sub; assumption.



        - intros ofs0 ineq.

          rewrite gsoThreadLPool.

          cut (lockRes js (b, ofs0) = None).

          { intros HH. inversion MATCH. specialize (mtch_locks (b, ofs0)).

            rewrite HH in mtch_locks.

            destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto.

          }

          { destruct Hcompatible as [allj Hcompatible].

            inversion Hcompatible.

            assert (VALID:= Concur.compat_lr_valid Hcmpt).

            specialize (VALID b (Ptrofs.intval ofs)).

            eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join. 

            rewrite His_locked in VALID. apply VALID; auto.

           }

        - intros ofs0 ineq.

          rewrite gsoThreadLPool.

          cut (lockRes js (b, ofs0) = None).

          { intros HH. inversion MATCH. specialize (mtch_locks (b, ofs0)).

            rewrite HH in mtch_locks.

            destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto.

          }

          { destruct (lockRes js (b, ofs0)) eqn:AA; try reflexivity. exfalso.

             destruct Hcompatible as [allj Hcompatible].

            inversion Hcompatible.

            assert (VALID:= Concur.compat_lr_valid Hcmpt).

            specialize (VALID b ofs0).

            rewrite AA in VALID.

            apply VALID in ineq.

            eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.

            specialize (jloc_in_set (b,Ptrofs.intval ofs)).

            spec jloc_in_set. { intros. simpl. 

                  apply resource_at_join_sub with (l:=(b,Ptrofs.intval ofs+i0)) in juice_join.

                  destruct (HJcanwrite _ H) as [sh' [rsh' [? ?]]]. rewrite H1 in juice_join.

                 destruct juice_join as [x HH].

                 inversion HH; eauto.

            }

           setoid_rewrite ineq in jloc_in_set. inv jloc_in_set.

          }



      }



      {  

        

        apply invariant_decr.

        - assumption.

        - move=> /= b0 ofs0.

          rewrite -virtue_spec1 (MTCH_perm' _ MATCH).

          apply juicy_mem_lemmas.po_join_sub;

            apply resource_at_join_sub.

          exists (d_phi); apply join_comm.

          replace (MTCH_cnt' MATCH Htid') with Hi by (apply proof_irrelevance); assumption.

        - move=> /= b0 ofs0.

          rewrite -virtue_spec2 (MTCH_perm2' _ MATCH).



          apply po_join_sub_lock.

           apply resource_at_join_sub.

          exists (d_phi); apply join_comm.

          replace (MTCH_cnt' MATCH Htid') with Hi by (apply proof_irrelevance); assumption.

      }



    - 

      unfold ds''.

      apply match_st_age_tp_to.

      cut (max_access_cohere m d_phi).

      intros maxcoh.

      apply MTCH_updLockS.



      2:{

      inversion MATCH; subst.

      intros; apply Concur.juic2Perm_correct.

      inversion Hcompatible; inversion H; inversion all_cohere.

      apply Concur.max_acc_coh_acc_coh.

      assumption.

      
 }



      unfold ds'.

      apply MTCH_update; eauto.

      move=> b0 ofs0.

      apply Concur.juic2Perm_locks_correct.

      assumption.



      { inversion Hcompatible; inversion H; inversion all_cohere.

        eapply Concur.mem_access_coh_sub.

         - eassumption.

         - eapply join_sub_trans.

           + unfold join_sub. exists phi'. eassumption.

           + eapply Concur.compatible_threadRes_sub.

             assumption.

      }



    - assert (H: exists l, lockRes ds (b, Ptrofs.intval ofs) = Some l).

      { inversion MATCH; subst.

        specialize (mtch_locks (b, (Ptrofs.intval ofs) )).

        rewrite His_locked in mtch_locks.

        destruct (lockRes ds (b, Ptrofs.intval ofs)); try solve[inversion mtch_locks]. exists l; reflexivity. }

           destruct H as [l dlockRes].

      econstructor 2.

      17: reflexivity.

      16: instantiate (2:= (virtue1, virtue2));

          instantiate (1 := (Concur.juice2Perm d_phi m, Concur.juice2Perm_locks d_phi m));

        unfold ds'; repeat f_equal; try reflexivity; try apply proof_irrelevance.

      9: eassumption.

      11: eassumption.

      9: reflexivity.

      + 

        split.

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta1 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh0 Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_lock_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }

          

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta2 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh0 Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_lock_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }



      + 

        repeat split.

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { intros HHH; rewrite HHH in f1b0.

            inversion f1b0.  }

          {

            apply join_join_sub in Hrem_lock_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }

          

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res_lock (d_phi @ (p, b0)) = None).

          { intros HHH; rewrite HHH in f1b0.

            inversion f1b0.  }

          {

            apply join_join_sub in Hrem_lock_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.

            apply po_join_sub_lock in Hrem_lock_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;

              [|eapply perm_of_res_op2].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }

      + assumption.

      + eapply MTCH_getThreadC; eassumption.

      + reflexivity.

      + eassumption.

      + apply restrPermMap_ext.

        intros b0.

        inversion MATCH; subst.

        extensionality ofs0.

        rewrite -Concur.juic2Perm_locks_correct.

        symmetry; apply mtch_perm2.

        inversion Hcompatible; inversion H; inversion all_cohere.

        eapply Concur.mem_access_coh_sub.

        * eassumption.

        *  eapply Concur.compatible_threadRes_sub.

           assumption.

      + eapply lock_range_perm; eauto.

      + apply restrPermMap_ext.

        intros b0.

        extensionality ofs0.

        destruct (peq b b0); [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

        * unfold Intv.In in i0; simpl in i0.

          repeat rewrite setPermBlock_same; auto.

        * apply Intv.range_notin in n; auto.

          repeat rewrite setPermBlock_other_1; auto.

          rewrite -Concur.juic2Perm_locks_correct.

          symmetry; eapply MTCH_perm2.

          destruct Hcmpt as [jall Hcmpt];

            inversion Hcmpt. inversion all_cohere.

          eapply Concur.mem_access_coh_sub; eauto.

          apply Concur.compatible_threadRes_sub; assumption.

          pose proof LKSIZE_pos; simpl; xomega.

        * repeat rewrite setPermBlock_other_2; auto.

          rewrite -Concur.juic2Perm_locks_correct.

          symmetry; eapply MTCH_perm2.

          destruct Hcmpt as [jall Hcmpt];

            inversion Hcmpt. inversion all_cohere.

          eapply Concur.mem_access_coh_sub; eauto.

          apply Concur.compatible_threadRes_sub; assumption.



      + exact dlockRes.

      + inversion MATCH.

        specialize (mtch_locksEmpty _ _ His_locked dlockRes).

        inversion mtch_locksEmpty; simpl.

        move=> b0 ofs0.

        rewrite empty_map_spec; tauto.

      + simpl; intros b0 ofs0.

        replace (MTCH_cnt MATCH Hi) with Htid'.

        rewrite -virtue_spec1.

        rewrite -Concur.juic2Perm_correct.

        rewrite (MTCH_perm' _ MATCH b0 ofs0).

        apply permjoin.join_permjoin.

        move Hrem_lock_res at bottom.

        eapply resource_at_join; apply join_comm.

        replace (MTCH_cnt' MATCH Htid') with Hi.

        assumption.

        apply proof_irrelevance.

        2:

        apply proof_irrelevance.

        apply Concur.max_acc_coh_acc_coh.

        inversion Hcompatible; inversion H; inversion all_cohere.

        eapply Concur.mem_access_coh_sub.

        * eassumption.

        *  eapply join_sub_trans.

           -- unfold join_sub. exists phi'. eassumption.

           -- eapply Concur.compatible_threadRes_sub.

              assumption.

      + simpl; intros b0 ofs0.

        replace (MTCH_cnt MATCH Hi) with Htid'.

        rewrite -virtue_spec2.

        rewrite -Concur.juic2Perm_locks_correct.

        rewrite (MTCH_perm2' _ MATCH b0 ofs0).

        apply permjoin.join_permjoin_lock.

        apply resource_at_join.

        apply join_comm.

        replace (MTCH_cnt' MATCH Htid') with Hi by apply proof_irrelevance.

        assumption.

        2:

        apply proof_irrelevance.

        inversion Hcompatible; inversion H; inversion all_cohere.

        eapply Concur.mem_access_coh_sub.

        * eassumption.

        *  eapply join_sub_trans.

           -- unfold join_sub. exists phi'. eassumption.

           -- eapply Concur.compatible_threadRes_sub.

              assumption.

      + replace (MTCH_cnt MATCH Hi) with Htid' by apply proof_irrelevance.

        reflexivity.

    }



    {



      pose (inflated_delta11:=

              fun loc => match (d_phi @ loc ) with

                        NO s _ => if Share.EqDec_share s Share.bot then None else  Some ( perm_of_res (phi' @ loc))

                      | _ => Some ( perm_of_res (phi' @ loc))

                      end).

      pose (virtue11:= PTree.map

                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                          (inflated_delta11 (block, ofs))) (snd (getMaxPerm m')) ).

      assert (virtue_spec11: forall b0 ofs0,

                 (computeMap (getThreadR (MTCH_cnt MATCH Hi)).1 virtue11) !! b0 ofs0 =

                 perm_of_res (phi' @ (b0, ofs0))).

      { intros b0 ofs0.

        destruct (virtue11 ! b0) eqn:VIRT.

        destruct (o ofs0) eqn:O.

        - erewrite computeMap_1; try eassumption.

          unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta11 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          reflexivity.

        - erewrite computeMap_2; try eassumption.

          unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta11 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          subst.

          apply resource_at_join with (loc:= (b0,ofs0)) in Hrem_fun_res.

          rewrite AA in Hrem_fun_res.

          eapply (join_unit1_e) in Hrem_fun_res.

          rewrite Hrem_fun_res.

          inversion MATCH.

          symmetry.

          apply mtch_perm1.

          apply NO_identity.

        - erewrite computeMap_3; try eassumption.

             unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR (MTCH_cnt MATCH Hi)).1 !! b0 ofs0) with

             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).

             + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.

               unfold Concur.access_cohere' in acc_coh.

               specialize (acc_coh (b0,ofs0)).

               unfold max_access_at, access_at in acc_coh.

               unfold permission_at in the_cure.

               rewrite the_cure in acc_coh.

               apply po_None1 in acc_coh.

               move Hrem_fun_res at bottom.

               apply join_comm in Hrem_fun_res.

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.

               apply join_join_sub in Hrem_fun_res.

               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_fun_res).

               rewrite acc_coh in HH. rewrite acc_coh.

               apply po_None1 in HH. symmetry; assumption.

             + inversion MATCH.  apply mtch_perm1.

      }



      pose (inflated_delta12:=

              fun loc => match (d_phi @ loc ) with

                        NO s _ => if Share.EqDec_share s Share.bot then None

                               else  Some ( perm_of_res_lock (phi' @ loc))

                      | _ => Some ( perm_of_res_lock (phi' @ loc))

                      end).

      pose (virtue12:= PTree.map

                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                          (inflated_delta12 (block, ofs))) (snd (getMaxPerm m')) ).

      assert (virtue_spec12: forall b0 ofs0,

                 (computeMap (getThreadR (MTCH_cnt MATCH Hi)).2 virtue12) !! b0 ofs0 =

                 perm_of_res_lock (phi' @ (b0, ofs0))).

      { intros b0 ofs0.

        destruct (virtue12 ! b0) eqn:VIRT.

        destruct (o ofs0) eqn:O.

        - erewrite computeMap_1; try eassumption.

          unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta12 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          reflexivity.

        - erewrite computeMap_2; try eassumption.

          unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta12 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          subst.

          apply resource_at_join with (loc:= (b0,ofs0)) in Hrem_fun_res.

          rewrite AA in Hrem_fun_res.

          apply join_unit1_e in Hrem_fun_res; try apply NO_identity; rewrite Hrem_fun_res.

          inversion MATCH.

          symmetry.

          apply mtch_perm2.

        - erewrite computeMap_3; try eassumption.

             unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR (MTCH_cnt MATCH Hi)).2 !! b0 ofs0) with

             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).

             + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               
               specialize (max_coh (b0,ofs0)).

               unfold max_access_at, access_at in max_coh.

               unfold permission_at in the_cure.

               rewrite the_cure in max_coh.

               apply po_None1 in max_coh.

               move Hrem_fun_res at bottom.

               apply join_comm in Hrem_fun_res.

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.

               apply join_join_sub in Hrem_fun_res.

               assert (HH:= po_join_sub_lock Hrem_fun_res).



               move:

                 (perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).



               rewrite max_coh => /po_None1 is_none.

               rewrite is_none in HH; rewrite is_none.

               apply po_None1 in HH. symmetry; assumption.

             + inversion MATCH.  apply mtch_perm2.

      }



      pose (inflated_delta21:=

              fun loc => match (d_phi @ loc ) with

                        NO s _ => if Share.EqDec_share s Share.bot then None

                               else  Some ( perm_of_res (d_phi @ loc))

                      | _ => Some ( perm_of_res (d_phi @ loc))

                      end).

      pose (virtue21:= PTree.map

                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                          (inflated_delta21 (block, ofs))) (snd (getMaxPerm m')) ).

      assert (virtue_spec21: forall b0 ofs0,

                 (computeMap empty_map virtue21) !! b0 ofs0 = (perm_of_res (d_phi @(b0, ofs0)))).

      { intros b0 ofs0.

        destruct (virtue21 ! b0) eqn:VIRT.

        destruct (o ofs0) eqn:O.

        - erewrite computeMap_1; try eassumption.

          unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta21 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          reflexivity.

        - erewrite computeMap_2; try eassumption.

          unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta21 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          subst; simpl.

          destruct (eq_dec Share.bot Share.bot).

          + rewrite empty_map_spec; auto.

          + exfalso; apply n; auto. contradiction.

        - erewrite computeMap_3; try eassumption.

             unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR (MTCH_cnt MATCH Hi)).1 !! b0 ofs0) with

             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).

             + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.

               unfold Concur.access_cohere' in acc_coh.

               specialize (acc_coh (b0,ofs0)).

               unfold max_access_at, access_at in acc_coh.

               unfold permission_at in the_cure.

               rewrite the_cure in acc_coh.

               apply po_None1 in acc_coh.

               move Hrem_fun_res at bottom.

               

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.

               apply join_join_sub in Hrem_fun_res.

               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_fun_res).

               rewrite acc_coh in HH.

               apply po_None1 in HH.

               rewrite empty_map_spec.

               symmetry; assumption.

             + inversion MATCH.  apply mtch_perm1.

      }



      pose (inflated_delta22:=



              fun loc => match (d_phi @ loc ) with

                        NO s _ => if Share.EqDec_share s Share.bot then None

                               else  Some ( perm_of_res_lock (d_phi @ loc))

                      | _ => Some (perm_of_res_lock (d_phi @ loc))

                      end).



      pose (virtue22:= PTree.map

                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>

                          (inflated_delta22 (block, ofs))) (snd (getMaxPerm m')) ).

      assert (virtue_spec22: forall b0 ofs0,

                 (computeMap empty_map virtue22) !! b0 ofs0 =

                 (perm_of_res_lock (d_phi @(b0, ofs0)))).

      {intros b0 ofs0.

        destruct (virtue22 ! b0) eqn:VIRT.

        destruct (o ofs0) eqn:O.

        - erewrite computeMap_1; try eassumption.

          unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta22 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          reflexivity.

        - erewrite computeMap_2; try eassumption.

          unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.

          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.

          rewrite <- H0 in O.

          unfold inflated_delta22 in O.

          destruct (d_phi @ (b0, ofs0)) eqn:AA;

          try (inversion O; reflexivity).

          destruct (Share.EqDec_share sh Share.bot); inversion O.

          subst. simpl;

            rewrite empty_map_spec; auto.

        - erewrite computeMap_3; try eassumption.

             unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.

             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.

             clear VIRT.

             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).

             { unfold PMap.get. rewrite notInMem.

               apply Max_isCanonical.

             }

             assert (the_cure:= equal_f THE_CURE ofs0).

             rewrite getMaxPerm_correct in the_cure.

             replace ((getThreadR (MTCH_cnt MATCH Hi)).2 !! b0 ofs0) with

             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).

          + assert (Hcohere':= Hcompatible).

               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.

               inversion Hcohere'.

               
               specialize (max_coh (b0,ofs0)).

                unfold max_access_at, access_at in max_coh.

               unfold permission_at in the_cure.



               rewrite the_cure in max_coh.

               apply po_None1 in max_coh.

               move Hrem_fun_res at bottom.

               

               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.

               apply join_join_sub in Hrem_fun_res.

               assert (HH:= po_join_sub_lock Hrem_fun_res).



               move:

                 (perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).



               rewrite max_coh => /po_None1 is_none.

               rewrite empty_map_spec.

               rewrite is_none in HH.

               apply po_None1 in HH. symmetry; assumption.

             + inversion MATCH.  apply mtch_perm2.



      }



      pose (ds_upd:= updThread

                       (MTCH_cnt MATCH Hi)

                       (Kresume c Vundef)

                       (computeMap (getThreadR (MTCH_cnt MATCH Hi)).1 virtue11,

                        computeMap (getThreadR (MTCH_cnt MATCH Hi)).2 virtue12)).



      pose (ds':= addThread

                    ds_upd

                    (Vptr b ofs)

                    arg

                    (computeMap empty_map virtue21,

                     computeMap empty_map virtue22)).

      exists ds'.

      eexists.

      split ;[|split].

      { 

        cut (invariant ds_upd).

        { 

          intro HH; apply addThrd_inv.

          - assumption.

          - move=> j cntj .

            split;

              apply permDisjoint_permMapsDisjoint => b0 ofs0.

            + rewrite virtue_spec21.

              destruct (eq_dec i j).

              * subst. rewrite gssThreadRes.

                rewrite virtue_spec11.

                apply joins_permDisjoint.

                apply resource_at_joins.

                eexists; eassumption.

              * rewrite gsoThreadRes; auto.

                rewrite (MTCH_perm' _ MATCH).

                apply joins_permDisjoint.

                apply resource_at_joins.

                eapply join_sub_joins_trans; eauto.

                exists phi'; eauto.

                simpl.

                eapply Concur.compatible_threadRes_join; eauto.

            + rewrite virtue_spec22.

              destruct (eq_dec i j).

              * subst. rewrite gssThreadRes.

                rewrite virtue_spec12.

                apply joins_permDisjoint_lock.

                apply resource_at_joins.

                eexists; eassumption.

              * rewrite gsoThreadRes; auto.

                rewrite (MTCH_perm2' _ MATCH).

                apply joins_permDisjoint_lock.

                apply resource_at_joins.

                eapply join_sub_joins_trans; eauto.

                exists phi'; eauto.

                simpl.

                eapply Concur.compatible_threadRes_join; eauto.

          - move => l rm.

            rewrite gsoThreadLPool => isLock2.

            split; apply permDisjoint_permMapsDisjoint=> b0 ofs0 /=.

            + rewrite virtue_spec21.



              assert (exists pmap1, lockRes js l = Some pmap1).

              { inversion MATCH.

                specialize (mtch_locks l).

                rewrite isLock2 in mtch_locks.

                destruct (lockRes js l).

                - exists l0; reflexivity.

                - inversion mtch_locks.

              }

              destruct H as [rm' H].

              destruct rm'.

              * inversion MATCH.

                rewrite -(mtch_locksRes _ _ _ H isLock2).

                apply joins_permDisjoint.

                apply resource_at_joins.

                eapply join_sub_joins_trans.

                exists phi'; eassumption.

                eapply Concur.compatible_threadRes_lockRes_join;

                  eauto.

              * inversion MATCH.

                specialize (mtch_locksEmpty _ _ H isLock2).

                inversion mtch_locksEmpty.

                rewrite empty_map_spec.

                eapply permDisjoint_comm.

                eapply permDisjoint_None.

            + rewrite virtue_spec22.



              assert (exists pmap1, lockRes js l = Some pmap1).

              { inversion MATCH.

                specialize (mtch_locks l).

                rewrite isLock2 in mtch_locks.

                destruct (lockRes js l).

                - exists l0; reflexivity.

                - inversion mtch_locks.

              }

              destruct H as [rm' H].

              destruct rm'.

              * inversion MATCH.

                rewrite -(mtch_locksRes0 _ _ _ H isLock2).

                apply joins_permDisjoint_lock.

                apply resource_at_joins.

                eapply join_sub_joins_trans.

                exists phi'; eassumption.

                eapply Concur.compatible_threadRes_lockRes_join;

                  eauto.

              * inversion MATCH.

                specialize (mtch_locksEmpty _ _ H isLock2).

                inversion mtch_locksEmpty.

                rewrite empty_map_spec.

                eapply permDisjoint_comm.

                eapply permDisjoint_None.

          - move=> b0 ofs0;

              simpl.

            rewrite virtue_spec21 virtue_spec22.

            apply perm_coh_self.

          - move=> j cntj b0 ofs0.

            rewrite virtue_spec21.

            destruct (eq_dec i j).

            * subst. rewrite gssThreadRes.

              rewrite virtue_spec12.

              apply perm_coh_joins.

              apply resource_at_joins.

              eexists; eauto.

            * rewrite gsoThreadRes; auto.

              rewrite (MTCH_perm2' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply join_sub_joins_trans.

              -- eexists; eauto.

              --  eapply Concur.compatible_threadRes_join; eauto.

          - move=> j cntj b0 ofs0.

            rewrite virtue_spec22.

            destruct (eq_dec i j).

            * subst. rewrite gssThreadRes.

              rewrite virtue_spec11.

              apply perm_coh_joins.

              apply resource_at_joins.

              eexists; eauto.

            * rewrite gsoThreadRes; auto.

              rewrite (MTCH_perm' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              apply joins_comm.

              eapply join_sub_joins_trans.

              -- eexists; eauto.

              --  eapply Concur.compatible_threadRes_join; eauto.

          - move => l rm .

            rewrite gsoThreadLPool => isLock b0 ofs0.

            rewrite virtue_spec21.

             assert (exists pmap1, lockRes js l = Some pmap1).

              { inversion MATCH.

                specialize (mtch_locks l).

                rewrite isLock in mtch_locks.

                destruct (lockRes js l).

                - exists l0; reflexivity.

                - inversion mtch_locks.

              }

              destruct H as [rm' H].

              destruct rm'.

              + inversion MATCH.

                rewrite -(mtch_locksRes0 _ _ _ H isLock).

                apply perm_coh_joins.

                apply resource_at_joins.

                eapply join_sub_joins_trans.

                exists phi'; eassumption.

                eapply Concur.compatible_threadRes_lockRes_join;

                  eauto.

              + inversion MATCH.

                specialize (mtch_locksEmpty _ _ H isLock).

                inversion mtch_locksEmpty.

                rewrite empty_map_spec.

                eapply perm_coh_empty_1.

          - move => l rm .

            rewrite gsoThreadLPool => isLock b0 ofs0.

            rewrite virtue_spec22.

             assert (exists pmap1, lockRes js l = Some pmap1).

              { inversion MATCH.

                specialize (mtch_locks l).

                rewrite isLock in mtch_locks.

                destruct (lockRes js l).

                - exists l0; reflexivity.

                - inversion mtch_locks.

              }

              destruct H as [rm' H].

              destruct rm'.

              + inversion MATCH.

                rewrite -(mtch_locksRes _ _ _ H isLock).

                apply perm_coh_joins.

                apply resource_at_joins.

                apply joins_comm.

                eapply join_sub_joins_trans.



                exists phi'; eassumption.

                eapply Concur.compatible_threadRes_lockRes_join;

                  eauto.

              + inversion MATCH.

                specialize (mtch_locksEmpty _ _ H isLock).

                inversion mtch_locksEmpty.

                rewrite empty_map_spec.

                eapply perm_coh_empty_2.

                apply juicy_mem_lemmas.perm_of_res_lock_not_Freeable.

        }



        { 

          

          apply invariant_decr.

          - assumption.

          - simpl=> b0 ofs0.

            rewrite virtue_spec11.

            rewrite -MTCH_perm.

            apply juicy_mem_lemmas.po_join_sub.

            move Hrem_fun_res at bottom.

            replace

              (m_phi

                      (Concur.personal_mem

                         (Concur.thread_mem_compatible Hcompatible Hi)))

            with

            (getThreadR Hi) in Hrem_fun_res by reflexivity.

            eapply resource_at_join_sub.

            exists d_phi. apply join_comm; assumption.

          - simpl=> b0 ofs0.

            rewrite virtue_spec12.

            rewrite -MTCH_perm2.

            

            apply po_join_sub_lock.

            apply resource_at_join_sub.

            exists d_phi.

            apply join_comm.

            assumption.

        }

      }



      { 

        apply match_st_age_tp_to.

        apply MTCH_addThread.

        - apply MTCH_update.

          + assumption.

          + intros. symmetry; apply virtue_spec11.

          + intros. symmetry; apply virtue_spec12.

        - intros. symmetry; apply virtue_spec21.

        - intros. symmetry; apply virtue_spec22.

      }

      {

        eapply DryHybridMachine.step_create with

        (virtue1:=(virtue11,virtue12))

          (virtue2:=(virtue21,virtue22)).

        - 

          split.

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p0 f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta11 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p0, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p0, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_fun_res.

            apply resource_at_join_sub with (l:=(p0,b0)) in Hrem_fun_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p0, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p0, b0)).

            destruct m'; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p0) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }

          

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta12 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_fun_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_fun_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m'; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }



        - 

           split.

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p0 f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta21 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p0, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p0, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_fun_res.

            apply resource_at_join_sub with (l:=(p0,b0)) in Hrem_fun_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p0, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p0, b0)).

            destruct m'; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p0) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }

          

        * eapply sub_map_and_shape;

          [eapply same_shape_map|].

          move=> p f1 HH.

          assert (HH':= HH).

          eapply map_leq_apply in HH';

            try apply treemap_sub_map.

          rewrite PTree.gmap in HH.

          destruct HH'  as [f2 HH'].

          rewrite HH' in HH; simpl in HH; inversion HH.

          exists f2; split; auto.

          move => b0 f1b0.

          unfold inflated_delta22 in f1b0.

          destruct (f2 b0) eqn:is_none; auto.

          cut (perm_of_res (d_phi @ (p, b0)) = None).

          { rewrite /perm_of_res.

            destruct (d_phi @ (p, b0)) eqn:DELT;

              try solve[intros delt; inversion delt].

            destruct (eq_dec sh Share.bot) eqn:DELT';

              try solve[intros delt; inversion delt].

            unfold eq_dec in DELT'.

            rewrite DELT' in f1b0; inversion f1b0.

            destruct k; intros NADA; inversion NADA.

            apply perm_of_empty_inv in NADA.

            subst; exfalso. apply shares.bot_unreadable; assumption. }

          {

            apply join_join_sub in Hrem_fun_res.

            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_fun_res.

            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.

            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;

              [|eapply perm_of_res_op1].



            cut ((perm_of_res'

                    (getThreadR Hi @ (p, b0))) = None).

            intros to_rewrite;

              eapply po_None1; rewrite -to_rewrite; eauto.



            move: (Concur.mem_compat_thread_max_cohere

                        Hcmpt Hi (p, b0)).

            destruct m'; simpl in *.

            rewrite  /max_access_at

                    /access_at

                    /PMap.get /=.



            move : HH'.



            rewrite /getMaxPerm PTree.gmap1; simpl.

            destruct ((mem_access.2) ! p) eqn:AA;

              try solve [simpl; intros FALSE; inversion FALSE].

            simpl; intros TT; inversion TT.

            rewrite -H1 in is_none.

            rewrite is_none => /po_None1.

            auto.

            }



        - assumption.

        - inversion MATCH. erewrite <- mtch_gtc; eassumption.

        - reflexivity.

        - eassumption.

        - eassumption.

        - move => b0 ofs0.

          rewrite virtue_spec11.

          rewrite virtue_spec21.

          inversion MATCH. erewrite <- MTCH_perm.

          eapply permjoin.join_permjoin.

          apply resource_at_join.

          move Hrem_fun_res at bottom.

            replace

              (m_phi

                      (Concur.personal_mem

                         (Concur.thread_mem_compatible Hcompatible Hi)))

            with

            (getThreadR Hi) in Hrem_fun_res by reflexivity.

            assumption.

        -move => b0 ofs0.

          rewrite virtue_spec12.

          rewrite virtue_spec22.

          inversion MATCH. erewrite <- MTCH_perm2.

          eapply permjoin.join_permjoin_lock. 

          apply resource_at_join.

          move Hrem_fun_res at bottom.

            replace

              (m_phi

                      (Concur.personal_mem

                         (Concur.thread_mem_compatible Hcompatible Hi)))

            with

            (getThreadR Hi) in Hrem_fun_res by reflexivity.

            assumption.

        - reflexivity.



        - reflexivity.

      }

    }



    {

      assert (Htid':= MTCH_cnt MATCH Hi).

     
      pose (pmap_tid  := getThreadR Htid').

      pose (pdata:= fun i:nat => pmap_tid.1 !! b (Z.of_nat i)).

      pose (pmap_tid' :=

              (setPermBlock

                (Some Nonempty)

                b

                (Ptrofs.intval ofs)

                pmap_tid.1

                LKSIZE_nat,

               (setPermBlock

                  (Some Writable)

                  b

                  (Ptrofs.intval ofs)

                  pmap_tid.2

                  LKSIZE_nat



           ))).

   assert (pmap_spec1: forall b0 ofs0, perm_of_res (phi' @ (b0, ofs0)) =

                                    pmap_tid'.1 !! b0 ofs0).

   { move => b0 ofs0.

     rewrite /pmap_tid'.

     destruct (peq b b0);

       [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

     - rewrite setPermBlock_same; auto.



       assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).

       { split; auto. }



       move: Hrmap => /=.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

       intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.

       rewrite sh_after.

       reflexivity.

     - rewrite setPermBlock_other_1.



       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).

        { intros [ H1 [H2 H2']]; apply n; split; auto.  }

        move: Hrmap.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].

       move=> /(_ _ HH') => <- _ /=.

       rewrite (MTCH_perm' _ MATCH); simpl; repeat f_equal;

       apply proof_irrelevance.



       apply Intv.range_notin in n; auto.

       pose proof LKSIZE_pos; simpl. xomega.

     - rewrite setPermBlock_other_2.



       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0,ofs0)).

        { intros [ H1 [H2 H2']]; apply n. auto.  }

        move: Hrmap.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].

       move=> /(_ _ HH') => <- _ /=.

       rewrite (MTCH_perm' _ MATCH); simpl; repeat f_equal;

       apply proof_irrelevance.



       auto.



       }



   assert (pmap_spec2: forall b0 ofs0, perm_of_res_lock (phi' @ (b0, ofs0)) =

                                    pmap_tid'.2 !! b0 ofs0).

    { move => b0 ofs0.

     rewrite /pmap_tid'.

     destruct (peq b b0);

       [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

     - rewrite setPermBlock_same.



       assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).

       { split; auto. }



       move: Hrmap => /=.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

       intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.

       rewrite sh_after.

       apply perm_of_writable0;

         try apply shares.writable0_share_glb_Rsh; eauto;

           apply shares.glb_Rsh_not_top.

       auto.



     - rewrite setPermBlock_other_1.



       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).

        { intros [ H1 [H2 H2']]; apply n; split; auto.  }

        move: Hrmap.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].

       move=> /(_ _ HH') => <- _ /=.

       rewrite (MTCH_perm2' _ MATCH); simpl; repeat f_equal;

       apply proof_irrelevance.



       apply Intv.range_notin in n; auto.

       pose proof LKSIZE_pos; simpl. xomega.

     - rewrite setPermBlock_other_2.



       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0,ofs0)).

        { intros [ H1 [H2 H2']]; apply n. auto.  }

        move: Hrmap.

       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].

       move=> /(_ _ HH') => <- _ /=.

       rewrite (MTCH_perm2' _ MATCH); simpl; repeat f_equal;

       apply proof_irrelevance.



       auto.



       }



      pose (ds':= updThread Htid' (Kresume c Vundef) (pmap_tid')).

      pose (ds'':= updLockSet ds' (b, Ptrofs.intval ofs) (empty_map,empty_map)).

      exists ds'',  (Events.mklock (b, Ptrofs.intval ofs)).

      split ; [|split].

      - 

        cut (invariant ds').

        { intros dinv'.

          apply updLock_inv.

          - assumption.

          - intros i0 cnt0 ofs0 ineq.

            apply permMapsDisjoint2_empty.

          - intros i0 cnti.

            apply permMapsDisjoint2_comm;

            apply permMapsDisjoint2_empty.

          - intros laddr rmap'0 H H0; split;

            first [ apply permCoh_empty | apply permCoh_empty'].

            { move=> b0 ofs0.

              apply (invariant_not_freeable) with (b1:=b0)(ofs1:= ofs0) in dinv.

              destruct dinv as [AA BB].

              eapply BB in H0.

              destruct ((rmap'0.2) # b0 ofs0); try constructor.

              destruct p; try constructor.

              exfalso; apply H0; reflexivity. }

          - intros i0 cnti; apply permCoh_empty'.

          - intros i0 cnti; split;

            first [ apply permCoh_empty | apply permCoh_empty'].

            { move=> b0 ofs0.

              destruct (eq_dec i0 i).

              - subst i0.

                rewrite gssThreadRes.

                rewrite <- pmap_spec2.

                apply perm_of_res_lock_not_Freeable.

              - rewrite gsoThreadRes; auto.



                rewrite (MTCH_perm2' _ MATCH).



              apply perm_of_res_lock_not_Freeable. }

          - intros ofs0  ineq.

            rewrite gsoThreadLPool.



          destruct (lockRes ds (b, ofs0)) eqn:AA;  auto.



          inversion MATCH. specialize (mtch_locks (b,ofs0)).

          rewrite AA in mtch_locks.

          destruct (lockRes js (b, ofs0)) eqn:BB; inversion mtch_locks.

          destruct Hcompatible as [allj Hcompatible].

          inversion Hcompatible.

          specialize (lset_in_juice (b, ofs0)). setoid_rewrite BB in lset_in_juice.

          spec lset_in_juice; auto.

          destruct lset_in_juice as [sh' MAP]; auto.

          assert (HH:= Concur.compatible_threadRes_sub Hi juice_join).

          apply resource_at_join_sub with (l:= (b,ofs0)) in HH.

          assert (MAP0 := MAP 0). spec MAP0; [pose proof LKSIZE_pos; omega|]. 

            simpl in MAP0. destruct MAP0 as [shx [pshx [P [MAPx MAP0]]]]. rewrite Z.add_0_r in MAP0.

          rewrite MAP0 in HH.



          assert (ineq': Ptrofs.intval ofs <= ofs0 < Ptrofs.intval ofs + LKSIZE).

          { clear - ineq.

            destruct ineq; auto. simpl in *.

            xomega.

          }

          assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).

          { split; auto. }

          move: Hrmap => /=.

          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

          intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.



          rewrite sh_before in HH.

          destruct HH as [x HH]. inversion HH.



        - intros ofs0 ineq.

          rewrite gsoThreadLPool.

          destruct (lockRes ds (b, ofs0)) eqn:AA; auto.

          inversion MATCH. specialize (mtch_locks (b,ofs0)).

          rewrite AA in mtch_locks.

          destruct (lockRes js (b, ofs0)) eqn:BB; inversion mtch_locks.

          destruct Hcompatible as [allj Hcompatible].

          inversion Hcompatible.

          specialize (lset_in_juice (b, ofs0)). setoid_rewrite BB in lset_in_juice.

          destruct lset_in_juice as [sh' MAP]; auto.

          assert (HH:= Concur.compatible_threadRes_sub Hi juice_join).

          assert (ineq': 0 <= Ptrofs.intval ofs - ofs0 < LKSIZE).

          { clear - ineq. simpl in ineq; destruct ineq. xomega. }

          apply resource_at_join_sub with (l:= (b,Ptrofs.intval ofs)) in HH.

          specialize (MAP _ ineq'). destruct MAP as [shx [pshx [P [MAPx MAP]]]]. simpl in MAP.

          replace (ofs0 + (Ptrofs.intval ofs - ofs0)) with (Ptrofs.intval ofs) in MAP by omega.

          move: Hrmap => /=.

          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2 H3.

          assert (adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, Ptrofs.unsigned ofs)).

          { split; auto.

            split; omega. }

          destruct H3 as [H3 Hg].

          move: (H3 _ H4)=> [] v [] sh [] Rsh [] HH1 [] Wsh HH2.

          rewrite HH1 in HH.

          destruct HH as [x HH]. simpl in HH2. rewrite Z.sub_diag in HH2.

          clear - MAP HH. rewrite MAP in HH. inv HH.

        }



        { 

          

          assert (H:forall j cntj, i<> j ->

                              joins phi' (@getThreadR _ _ _ j js (MTCH_cnt' MATCH cntj))).

          { 

            intros j cntj neq.

            assert (Hcmpt':=Hcmpt).

            apply Concur.compatible_threadRes_join  with

            (cnti:= Hi)(cntj0:= (MTCH_cnt' MATCH cntj)) in Hcmpt'; auto.

              destruct Hcmpt' as [x thread_join].

              simpl in Hrmap.

              apply (rmap_locking.rmap_makelock_join

                       _ _ _ _

                       _ _ _

                       LKSIZE_pos

                       Hrmap) in thread_join.

              destruct thread_join as [X [_ THEY_JOIN]].

              exists X; assumption. }



          assert (H':forall (l : address)

                      pmap,

                     lockRes js l = Some (Some pmap) ->

                     joins phi' pmap).

          { 

            intros l pmap is_lock.

            assert (Hcmpt':=Hcmpt).

            apply Concur.compatible_threadRes_lockRes_join  with

            (cnti:= Hi)(l0:=l)(phi:=pmap) in Hcmpt'; auto.

              destruct Hcmpt' as [x thread_lock_join].

              simpl in Hrmap.

              apply (rmap_locking.rmap_makelock_join

                       _ _ _ _

                       _ _ _

                       LKSIZE_pos

                       Hrmap) in thread_lock_join.

              destruct thread_lock_join as [X [_ THEY_JOIN]].

              exists X; assumption.



          }



          apply updThread_inv.

          - eassumption.

          - intros j cnt H1.

            split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.

            + rewrite <- pmap_spec1.

              rewrite (MTCH_perm' _ MATCH).

              apply joins_permDisjoint.

              apply resource_at_joins; apply H; assumption.

            + rewrite <- pmap_spec2.

              rewrite (MTCH_perm2' _ MATCH).

              apply joins_permDisjoint_lock.

              apply resource_at_joins; apply H; assumption.

          - intros j cnt neq b0 ofs0.

            rewrite (MTCH_perm' _ MATCH).

            destruct (peq b b0);

              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

            + rewrite setPermBlock_same; auto.



              move: Hrmap.

              rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { split; auto. }

              intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Y & H5); clear X.

              

              assert (H0: joins (getThreadR (MTCH_cnt' MATCH cnt))

                            (getThreadR Hi)).

              { eapply Concur.compatible_threadRes_join;

                eauto. }

              apply resource_at_joins with (loc:=(b, ofs0))   in H0.

              rewrite Hpersonal_juice in H0.

              rewrite H4 in H0.

              destruct H0 as [x H0]; inversion H0; subst.

              -- rewrite - H7; simpl;

                 destruct (eq_dec sh1 Share.bot); constructor.

              -- rewrite -H7; simpl.

                 apply join_comm in RJ.

                 exfalso. eapply shares.join_writable0_readable; eauto.

            + apply Intv.range_notin in n; simpl in n; try (pose proof LKSIZE_pos; simpl; omega).

              rewrite setPermBlock_other_1; auto.

              rewrite /pmap_tid.

              rewrite (MTCH_perm2' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply Concur.compatible_threadRes_join; eauto.

            + rewrite setPermBlock_other_2; auto.

              rewrite /pmap_tid.

              rewrite (MTCH_perm2' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply Concur.compatible_threadRes_join; eauto.



          - intros j cnt neq b0 ofs0.

            rewrite (MTCH_perm2' _ MATCH).

            destruct (peq b b0);

              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

            + rewrite setPermBlock_same; auto.



              move: Hrmap.

              rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { split; auto. }

              intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Wsh & H5); clear X.

              assert (H0: joins (getThreadR (MTCH_cnt' MATCH cnt))

                            (getThreadR Hi)).

              { eapply Concur.compatible_threadRes_join;

                eauto. }

              apply resource_at_joins with (loc:=(b, ofs0))   in H0.

              rewrite Hpersonal_juice in H0.

              rewrite H4 in H0.

              destruct H0 as [x H0]; inversion H0; subst.

              -- rewrite - H7; simpl;

                 destruct (eq_dec sh1 Share.bot); constructor.

              -- rewrite -H7; simpl.

                 apply join_comm in RJ.

                 exfalso. eapply shares.join_writable0_readable; eauto.

            + apply Intv.range_notin in n; simpl in n; try (pose proof LKSIZE_pos; simpl; omega).

              rewrite setPermBlock_other_1; auto.

              rewrite /pmap_tid.

              rewrite (MTCH_perm' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply Concur.compatible_threadRes_join; eauto.

            + rewrite setPermBlock_other_2; auto.

              rewrite /pmap_tid.

              rewrite (MTCH_perm' _ MATCH).

              apply perm_coh_joins.

              apply resource_at_joins.

              eapply Concur.compatible_threadRes_join; eauto.

          - move=> l pmap is_lock.

            assert (is_lock': exists p, lockRes js l = Some p).

            { destruct (lockRes js l) eqn:is_lock'.

              + exists l0; reflexivity.

              + inversion MATCH. specialize (mtch_locks l).

                rewrite is_lock is_lock' in mtch_locks.

                inversion mtch_locks. }

            destruct is_lock' as [p is_lock'];

              destruct p.

            + assert (is_lock'':=is_lock').

              apply H' in is_lock''.

              split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.

              * rewrite - pmap_spec1.

                inversion MATCH.

                erewrite <- mtch_locksRes; eauto.

                apply joins_permDisjoint.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

              * rewrite - pmap_spec2.

                inversion MATCH.

                erewrite <- mtch_locksRes0; eauto.

                apply joins_permDisjoint_lock.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

            + inversion MATCH.

              eapply mtch_locksEmpty in is_lock';

                eauto; rewrite is_lock'.

              split; first [apply empty_disjoint' | apply empty_disjoint].

          - move=> l pmap is_lock.

            assert (is_lock': exists p, lockRes js l = Some p).

            { destruct (lockRes js l) eqn:is_lock'.

              + exists l0; reflexivity.

              + inversion MATCH. specialize (mtch_locks l).

                rewrite is_lock is_lock' in mtch_locks.

                inversion mtch_locks. }

            destruct is_lock' as [p is_lock'];

              destruct p.

             + assert (is_lock'':=is_lock').

              apply H' in is_lock''.

              split; move=> b0 ofs0.

              * rewrite - pmap_spec2.

                inversion MATCH.

                erewrite <- mtch_locksRes; eauto.

                apply perm_coh_joins.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

              * rewrite - pmap_spec1.

                inversion MATCH.

                erewrite <- mtch_locksRes0; eauto.

                apply perm_coh_joins.

                apply resource_at_joins.

                eapply H'; eauto.

            + inversion MATCH.

              eapply mtch_locksEmpty in is_lock';

                eauto; rewrite is_lock'.

              split;

                first [ apply permCoh_empty' | apply permCoh_empty].



              { move=> b0 ofs0.

                rewrite -pmap_spec2.

                apply perm_of_res_lock_not_Freeable. }

          - intros b0 ofs0.

            rewrite - pmap_spec2 - pmap_spec1.

            apply perm_coh_self.

        }



      -     unfold ds''.

                                apply MTCH_age.

                                apply MTCH_updLockN.

                                 unfold ds'.

                                apply MTCH_update.

                                assumption.



                                intros b0 ofs0.

                                apply pmap_spec1.



                                intros b0 ofs0.

                                apply pmap_spec2.

      - econstructor 4. 

        11: reflexivity.

        11: reflexivity.

        + assumption.

        + eapply MTCH_getThreadC; eassumption.

        + reflexivity.

        + eassumption.

        + reflexivity.

        + destruct Hrmap as (_ & _ & Hl & _).

          intros ??.

          specialize (Hl (b, ofs0)) as (? & sh & ? & Hl & ? & _); [split; auto|].

          simpl in Hl.

          unfold Mem.perm; setoid_rewrite restrPermMap_Cur.

          replace (MTCH_cnt _ _) with Htid' by apply proof_irr.

          inv MATCH.

          erewrite <- mtch_perm1; setoid_rewrite Hl; simpl.

          apply perm_of_writable'; auto.

        + rewrite <- Hstore. f_equal.

          erewrite <- (MTCH_restrict_personal ).

          * reflexivity.

          * auto.

        
        + replace (MTCH_cnt MATCH Hi) with Htid' by

              apply proof_irrelevance; reflexivity.

        + replace (MTCH_cnt MATCH Hi) with Htid' by

              apply proof_irrelevance; reflexivity.

        + destruct (lockRes ds (b, Ptrofs.intval ofs)) eqn:AA; auto.

          inversion MATCH.

          specialize (mtch_locks (b, Ptrofs.intval ofs)).

          rewrite AA in mtch_locks.



          move: Hrmap.

          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.

          assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, Ptrofs.unsigned ofs)).

          { split; auto.

            pose proof LKSIZE_pos.

            split; omega. }

          intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Y & H5); clear X.

          assert (Hcmpt':=Hcmpt).

          destruct Hcmpt as [jall Hcmpt].

          inversion Hcmpt.

          apply Concur.compatible_threadRes_sub with (cnt:=Hi) in juice_join.

          apply resource_at_join_sub with (l:=(b, Ptrofs.unsigned ofs)) in juice_join.

          destruct juice_join as [X HH].

          simpl in H4.

          rewrite H4 in HH.

          hnf in lset_in_juice.

          specialize (lset_in_juice (b, Ptrofs.intval ofs)).

          spec lset_in_juice; auto. destruct lset_in_juice as [sh' ?].

          destruct (H6 0). pose proof LKSIZE_pos; omega. simpl in H7.

          destruct H7 as [psh [P [H7' H7]]].

          rewrite Z.add_0_r in H7; rewrite H7 in HH; inv HH.

    }



        { assert (Htid':= MTCH_cnt MATCH Hi).

          
          Definition WorF (sh: share): permission:=

            if eq_dec sh Share.top then Freeable else Writable.

          pose (delta_b:=

                  fun ofs0 => if (Intv.In_dec ofs0 ( Ptrofs.intval ofs,  Ptrofs.intval ofs + LKSIZE)%Z) then

                             Some (perm_of_res (phi' @ (b, ofs0)))

                           else None).

          Definition empty_delta_map: delta_map:= PTree.empty (Z -> option (option permission)).

          pose (virtue:= PTree.set b delta_b empty_delta_map).



          pose (pmap_tid  := getThreadR Htid').

          pose (pdata:= fun i:nat =>

                          if (i > LKSIZE_nat)%N  then

                            None

                          else

                            perm_of_res (phi' @ (b, Ptrofs.intval ofs + Z.of_nat (i)-1))

               ).

          pose (pmap_tid' := (setPermBlock_var 

                                pdata

                                b

                                (Ptrofs.intval ofs)

                                pmap_tid.1

                                LKSIZE_nat,

                              setPermBlock

                                None

                                b

                                (Ptrofs.intval ofs)

                                pmap_tid.2

                                LKSIZE_nat)).

          assert (pmap_spec1: forall b0 ofs0, perm_of_res (phi' @ (b0, ofs0)) =

                                         pmap_tid'.1 !! b0 ofs0).

          { move => b0 ofs0.

            rewrite /pmap_tid'.

            destruct (peq b b0);

              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

            - rewrite setPermBlock_var_same; auto.

              unfold pdata.

              replace

                (Ptrofs.intval ofs + Z.of_nat (nat_of_Z (ofs0 - Ptrofs.intval ofs + 1)) -1)

              with

              ofs0.

              assert ((LKSIZE_nat < nat_of_Z (ofs0 - Ptrofs.intval ofs + 1) )%N = false).

              {

                move: i0. clear.

                move => [] /= A B.

                rewrite /LKSIZE_nat /nat_of_Z.

                apply /ltP => / lt_not_le HH.

                apply: HH.

                

                eapply Z2Nat.inj_le; eauto.

                xomega.

                xomega.

                xomega.

              }

              rewrite H.

              reflexivity.

              rewrite Coqlib.nat_of_Z_eq.

              xomega.



              unfold LKSIZE in i0; destruct i0 as [A B].

              simpl in A. simpl in B.

              assert (ofs0 - Ptrofs.intval ofs >= 0).

              omega.

              omega.

            - rewrite setPermBlock_var_other_1; auto.

              move: Hrmap  => [] [] H1 [].

              assert (H3: ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { move => [] AA BB.

                apply: n; auto. }

              move => /(_ _ H3) => <- _.



                rewrite (MTCH_perm' _ MATCH).

                replace (MTCH_cnt' MATCH Htid') with Hi by

                    apply proof_irrelevance.

                reflexivity.

                apply Intv.range_notin in n; auto.

                pose proof LKSIZE_pos; simpl; omega.

            - rewrite setPermBlock_var_other_2; auto.

              move: Hrmap  => [] [] H1 [].

              assert (H3: ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0, ofs0)).

              { move => [] AA BB.

                apply: n; auto. }

              move => /(_ _ H3) => <- _.



                rewrite (MTCH_perm' _ MATCH).

                replace (MTCH_cnt' MATCH Htid') with Hi by

                    apply proof_irrelevance.

                reflexivity.

          }



          assert (pmap_spec2: forall b0 ofs0, perm_of_res_lock (phi' @ (b0, ofs0)) =

                                         pmap_tid'.2 !! b0 ofs0).

          {

            move => b0 ofs0.

            rewrite /pmap_tid'.

            destruct (peq b b0);

              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

            - rewrite setPermBlock_same; auto.

              move: Hrmap  => [] [] H1 [] _.

              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { split; auto. }

              intros [X Hg]; destruct (X _ H3) as (sh & Rsh & -> & Wsh & BB); clear X.

              reflexivity.

            - rewrite setPermBlock_other_1; auto.

               move: Hrmap  => [] [] H1 [].

              assert (H3: ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { move => [] AA BB.

                apply: n; auto. }

              move => /(_ _ H3) => <- _.



                rewrite (MTCH_perm2' _ MATCH).

                replace (MTCH_cnt' MATCH Htid') with Hi by

                    apply proof_irrelevance.

                reflexivity.

                apply Intv.range_notin in n; auto.

                pose proof LKSIZE_pos; simpl; omega.

            - rewrite setPermBlock_other_2; auto.

              move: Hrmap  => [] [] H1 [].

              assert (H3: ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0, ofs0)).

              { move => [] AA BB.

                apply: n; auto. }

              move => /(_ _ H3) => <- _.



                rewrite (MTCH_perm2' _ MATCH).

                replace (MTCH_cnt' MATCH Htid') with Hi by

                    apply proof_irrelevance.

                reflexivity.

          }



          pose (ds':= updThread Htid' (Kresume c Vundef) pmap_tid').

          pose (ds'':= remLockSet ds' (b,(Ptrofs.intval ofs))).



          exists ds'', (Events.freelock (b, Ptrofs.intval ofs)).

          split ; [|split].



          unfold ds''; rewrite remLock_updThread_comm.

          pose (ds0:= (remLockSet ds (b, (Ptrofs.intval ofs)))).



          - cut (invariant ds0).

            { 

              

          assert (H:forall j cntj, i<> j ->

                              joins phi' (@getThreadR _ _ _ j js (MTCH_cnt' MATCH cntj))).

          { 

            move => j cntj neq.

            assert (Hcmpt':=Hcmpt).

            apply Concur.compatible_threadRes_join  with

            (cnti:= Hi)(cntj0:= (MTCH_cnt' MATCH cntj)) in Hcmpt'; auto.

              destruct Hcmpt' as [x thread_join].

              simpl in Hrmap.

              apply (rmap_locking.rmap_freelock_join

                       _ _ _ _

                       _ _ _ _

                       LKSIZE_pos

                       Hrmap) in thread_join.

              destruct thread_join as [X [_ THEY_JOIN]].

              exists X; assumption. }



          assert (H':forall (l : address)

                      pmap,

                     lockRes js l = Some (Some pmap) ->

                     joins phi' pmap).

          { intros l pmap is_lock.

            assert (Hcmpt':=Hcmpt).

            apply Concur.compatible_threadRes_lockRes_join  with

            (cnti:= Hi)(l0:=l)(phi:=pmap) in Hcmpt'; auto.

              destruct Hcmpt' as [x thread_lock_join].

              simpl in Hrmap.

              apply (rmap_locking.rmap_freelock_join

                       _ _ _ _

                       _ _ _ _

                       LKSIZE_pos

                       Hrmap) in thread_lock_join.

              destruct thread_lock_join as [X [_ THEY_JOIN]].

              exists X; assumption.

          }



          intros dinv0.

          apply updThread_inv.

          - eassumption.

          - intros.

            split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.

            + rewrite -pmap_spec1.

              rewrite (MTCH_perm' _ MATCH).

              apply joins_permDisjoint.

              apply resource_at_joins.

              apply H; assumption.

            + rewrite -pmap_spec2.

              rewrite (MTCH_perm2' _ MATCH).

              apply joins_permDisjoint_lock.

              apply resource_at_joins.

              apply H; assumption.

          - move => j cntj neq b0 ofs0.

            rewrite -pmap_spec2.

            rewrite (MTCH_perm' _ MATCH).

            apply perm_coh_joins.

            apply resource_at_joins.

            apply joins_comm.

            eapply H; assumption.

          - intros j cntj neq b0 ofs0.

            rewrite <- pmap_spec1.

            rewrite (MTCH_perm2' _ MATCH).

            apply perm_coh_joins.

            apply resource_at_joins.

            eapply H; assumption.

          - move=> l pmap is_lock0.

            assert (is_lock: lockRes ds l =  Some pmap).

            { destruct (AMap.E.eq_dec (b, Ptrofs.intval ofs) l).

                * subst l.

                  rewrite gsslockResRemLock in is_lock0; inversion is_lock0.

                * rewrite gsolockResRemLock in is_lock0; auto. }

            assert (is_lock': exists p, lockRes js l = Some p).

            { destruct (lockRes js l) eqn:is_lock'.

              + exists l0; reflexivity.

              + inversion MATCH. specialize (mtch_locks l).

                move mtch_locks at bottom.

                move is_lock at bottom.

                move is_lock' at bottom.

                  rewrite is_lock is_lock' in mtch_locks.

                  inversion mtch_locks. }

            destruct is_lock' as [p is_lock'];

              destruct p.

            + assert (is_lock'':=is_lock').

              apply H' in is_lock''.

              split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.

              * rewrite - pmap_spec1.

                inversion MATCH.

                erewrite <- mtch_locksRes; eauto.

                apply joins_permDisjoint.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

              * rewrite - pmap_spec2.

                inversion MATCH.

                erewrite <- mtch_locksRes0; eauto.

                apply joins_permDisjoint_lock.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

            + inversion MATCH.

              eapply mtch_locksEmpty in is_lock';

                eauto; rewrite is_lock'.

              split; first [apply empty_disjoint'| apply permCoh_empty].

          - move=> l pmap is_lock0.

            assert (is_lock: lockRes ds l =  Some pmap).

            { destruct (AMap.E.eq_dec (b, Ptrofs.intval ofs) l).

                * subst l.

                  rewrite gsslockResRemLock in is_lock0; inversion is_lock0.

                * rewrite gsolockResRemLock in is_lock0; auto. }

            assert (is_lock': exists p, lockRes js l = Some p).

            { destruct (lockRes js l) eqn:is_lock'.

              + exists l0; reflexivity.

              + inversion MATCH. specialize (mtch_locks l).

                rewrite is_lock is_lock' in mtch_locks.

                inversion mtch_locks. }

            destruct is_lock' as [p is_lock'];

              destruct p.

             + assert (is_lock'':=is_lock').

              apply H' in is_lock''.

              split; move=> b0 ofs0.

              * rewrite - pmap_spec2.

                inversion MATCH.

                erewrite <- mtch_locksRes; eauto.

                apply perm_coh_joins.

                apply resource_at_joins.

                apply joins_comm.

                eapply H'; eauto.

              * rewrite - pmap_spec1.

                inversion MATCH.

                erewrite <- mtch_locksRes0; eauto.

                apply perm_coh_joins.

                apply resource_at_joins.

                eapply H'; eauto.

            + inversion MATCH.

              eapply mtch_locksEmpty in is_lock';

                eauto; rewrite is_lock'.

              split; first [apply permCoh_empty'| apply permCoh_empty].



              { move=> b0 ofs0.

                rewrite -pmap_spec2.

                apply perm_of_res_lock_not_Freeable. }

          - intros b0 ofs0.

            rewrite - pmap_spec2 - pmap_spec1.

            apply perm_coh_self.

            }



            {

              eapply remLock_inv.

              - assumption.



            }



          - unfold ds''.

            apply MTCH_age.

            apply MTCH_remLockN.

            unfold ds'.

            apply MTCH_update.

            assumption.



            apply pmap_spec1.

            apply pmap_spec2.



          - 



            destruct (lockRes ds (b, Ptrofs.intval ofs)) eqn:is_lock.

            2:{ inversion MATCH.

              specialize (mtch_locks (b, Ptrofs.intval ofs)).

              rewrite is_lock His_acq in mtch_locks.

              inversion mtch_locks.

            }



            econstructor 5. 

            13: reflexivity.

            13: reflexivity.

            8: reflexivity.



            + instantiate (1:=pdata) => p.

              rewrite /pdata => -> //.

            + assumption.

            + eapply MTCH_getThreadC; eassumption.

            + reflexivity.

            + eassumption.

            + eassumption.

            + move=> b0 ofs0.

              inversion MATCH;

                specialize (mtch_locksEmpty _ _ His_acq is_lock); rewrite mtch_locksEmpty.

              simpl; rewrite empty_map_spec; split; reflexivity.

            + intros ofs0 ineq.

              rewrite /Mem.perm.

              assert (HH:=@restrPermMap_Cur _ m' (DryHybridMachine.compat_th _ _ (MTCH_compat js ds m' MATCH Hcmpt)

              (MTCH_cnt MATCH Hi)).2 b ofs0).

              unfold permission_at in HH. rewrite HH.

              rewrite -(MTCH_perm2 _ MATCH).

              move: Hrmap  => [] [] H1 [] AA.

              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).

              { split; auto. }

              intros [X Hg]; destruct (X _ H3) as (sh & Rsh & _ & Wsh & Heq); clear X.

              rewrite Heq.

              simpl.

                rewrite perm_of_writable0.

                 constructor.

                 eapply shares.writable0_share_glb_Rsh; eauto.

                 apply shares.glb_Rsh_not_top.

            + replace (MTCH_cnt MATCH Hi) with Htid' by apply proof_irrelevance.

              reflexivity.

            + intros indx ineq.

              

              unfold pdata.

              assert ((LKSIZE_nat < indx.+1)%N = false).

              { destruct ineq.

                move: H0.

                simpl.

                destruct (LKSIZE_nat < indx.+1)%N eqn:NN; auto.

                assert ((LKSIZE_nat < indx.+1)%N) by

                (rewrite NN; auto).

                move: H0 => /ltP.

                intros. unfold LKSIZE_nat in *. apply Z2Nat.inj_lt in H0; try omega. rewrite Nat2Z.id in H0; omega. }

              rewrite H.



              move: Hrmap  => [] [] H1 [] AA.

              assert (H3: adr_range (b, Ptrofs.unsigned ofs)

                                    LKSIZE

                     (b, Ptrofs.unsigned ofs + Z.of_nat indx.+1 - 1)).

              { split; auto.

                unfold LKSIZE.

                move:  ineq.

                clear.

                rewrite /LKSIZE => [] [] /= A B.

                replace (Ptrofs.unsigned ofs + Z.pos (Pos.of_succ_nat indx) - 1)

                with

                (Ptrofs.unsigned ofs + Z.of_nat indx).

                split; simpl.

                replace (Ptrofs.unsigned ofs) with (Ptrofs.unsigned ofs + 0) at 1.

                apply Z.add_le_mono; omega.

                omega.

                omega.

                rewrite Zpos_P_of_succ_nat; omega. }

              unfold Ptrofs.unsigned in H3.

              intros [X Hg]; destruct (X _ H3) as (sh & ? & -> & Wsh & _); clear X; simpl.

              destruct (eq_dec sh Share.top); try subst.

              * rewrite perm_of_freeable; constructor.

              * rewrite perm_of_writable0; auto; constructor.

            + replace (MTCH_cnt MATCH Hi) with Htid' by apply proof_irrelevance.

              reflexivity.

        }



        {

          exists ds, (Events.failacq (b, Ptrofs.intval ofs)).

          split ; [|split].

          + assumption.

          + assumption.

          + { econstructor 6.

              + assumption.

              + inversion MATCH; subst.

                rewrite <- (mtch_gtc i Hi).

                eassumption.

              + reflexivity.

              + eassumption.

              + reflexivity.

              + eapply lock_range_perm in HJcanwrite; eauto.

                intros ? H; specialize (HJcanwrite _ H).

                unfold Mem.perm in *; setoid_rewrite restrPermMap_Cur.

                inversion MATCH.

                setoid_rewrite <- mtch_perm2.

                erewrite Concur.juic2Perm_locks_correct

                  by (apply Concur.mem_compat_thread_max_cohere; eauto).

                setoid_rewrite restrPermMap_Cur in HJcanwrite; eauto.

              + erewrite restrPermMap_ext.

                eassumption.

                intros b0.

                inversion MATCH; subst.

                extensionality x.

                rewrite -Concur.juic2Perm_locks_correct.

                symmetry; apply mtch_perm2.

                apply Concur.mem_compat_thread_max_cohere.

                assumption.

            }

        }



        Grab Existential Variables.

        auto.

    { 

       intros b0 ofs0.

             move: (Hlt' b0 ofs0).

             

             destruct (peq b b0);

               [subst b0;

                 destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].

             - do 2 (rewrite setPermBlock_same; auto).

             - apply Intv.range_notin in n; [|simpl; pose proof LKSIZE_pos; omega].

               do 2 (rewrite setPermBlock_other_1; auto).



               destruct Hcmpt as [jall Hcmpt];

               inversion Hcmpt; inversion all_cohere.

               rewrite -Concur.juic2Perm_locks_correct.

               rewrite -(MTCH_perm2 _ MATCH); auto.

               apply Concur.mem_access_coh_sub with (phi1:=jall).

               assumption.

               eapply Concur.compatible_threadRes_sub; eauto.

             - do 2 (rewrite setPermBlock_other_2; auto).

               destruct Hcmpt as [jall Hcmpt];

               inversion Hcmpt; inversion all_cohere.

               rewrite -Concur.juic2Perm_locks_correct.

               rewrite -(MTCH_perm2 _ MATCH); auto.

               apply Concur.mem_access_coh_sub with (phi1:=jall).

               assumption.

               eapply Concur.compatible_threadRes_sub; eauto.

    }

  Qed.



  Lemma step_decay_invariant:

    forall (tp : dstate)  (m : Mem.mem) i

      (Hi : containsThread tp i) m1 m1' c'

      (Hinv: invariant tp)

      (Hcompatible: DryHybridMachine.mem_compatible tp m)

      (Hrestrict_pmap :restrPermMap ((DryHybridMachine.compat_th _ _ Hcompatible) Hi).1 = m1)

      (Hdecay: decay m1 m1'),

      invariant

        (updThread Hi (Krun c')

                   (getCurPerm m1', (getThreadR Hi).2)).

  Proof.

    intros.

    

    assert (CASES: forall b0 ofs0,

               Mem.perm_order''

                 ((getCurPerm m1) !! b0 ofs0) ((getCurPerm m1') !! b0 ofs0) \/

               ~ Mem.valid_block m b0).

    { move=> b ofs.

      rewrite getCurPerm_correct getCurPerm_correct /permission_at /=.

      destruct (Hdecay b ofs) as [_ VAL].

      destruct (valid_block_dec m1 b); [left|right].

      - move :( VAL v) => [] /(_ Cur).

        move => [] -> -> //.

        move => -> . apply po_refl.

      - intros HH; apply n.

        subst m1;

          eapply restrPermMap_valid; eauto.

    }

    assert (m1_spec: forall b0 ofs0,

               (getCurPerm m1) !! b0 ofs0 = (getThreadR Hi).1 !! b0 ofs0).

    { move=> b ofs.

      subst m1.

      rewrite getCurPerm_correct restrPermMap_Cur //. }



    apply updThread_inv.

    - assumption.

    - intros j cnt H; split;

        apply permDisjoint_permMapsDisjoint=> b0 ofs0.

      + destruct (CASES b0 ofs0) as [PO | NV].

        * eapply permDisjointLT; eauto.

          rewrite m1_spec.

          apply permMapsDisjoint_permDisjoint.

          inversion Hinv; apply no_race_thr; auto.

        * move: (mem_compatible_invalid_block ofs0 Hcompatible NV)

          => [] /(_ j cnt) [] -> _ _.

          apply permDisjoint_comm;

            apply permDisjoint_None.

      + apply permMapsDisjoint_permDisjoint.

        inversion Hinv; apply no_race_thr; auto.

    - intros j cnt H.

      inversion Hinv.

      simpl. apply thread_data_lock_coh0.

    - intros j cnt H b0 ofs0.

      destruct (CASES b0 ofs0) as [PO | NV].

      + eapply perm_coh_lower; [| apply po_refl | eauto].

        rewrite m1_spec.

        inversion Hinv.

        apply thread_data_lock_coh0.

      + move: (mem_compatible_invalid_block ofs0 Hcompatible NV)

        => [] /(_ j cnt) [] _ -> _.

        apply perm_coh_empty_1.

    - intros l pmap0 H; split;

        apply permDisjoint_permMapsDisjoint=> b0 ofs0.

      + destruct (CASES b0 ofs0) as [PO | NV].

        * eapply permDisjoint_comm;

            eapply permDisjointLT; eauto.

          rewrite m1_spec.

          apply permMapsDisjoint_permDisjoint.

          inversion Hinv. eapply no_race; eauto.

        * move: (mem_compatible_invalid_block ofs0 Hcompatible NV)

          => [] _ /(_ l pmap0 H) [] -> _.

          apply permDisjoint_None.

      + eapply permDisjoint_comm;

          apply permMapsDisjoint_permDisjoint.

        inversion Hinv; eapply no_race; eauto.

    - intros l pmap0 H; split=> b0 ofs0.

      + inversion Hinv. eapply thread_data_lock_coh0; eauto.

      + destruct (CASES b0 ofs0) as [PO | NV].

        * eapply perm_coh_lower; [| apply po_refl | eauto].

          rewrite m1_spec.

          inversion Hinv.

          destruct (locks_data_lock_coh0 _ _ H).

          eapply H0.

        * move: (mem_compatible_invalid_block ofs0 Hcompatible NV)

          => [] _ /(_ l pmap0 H) [] _ -> .

          apply perm_coh_empty_1.

    - move => b0 ofs0.

      destruct (CASES b0 ofs0) as [PO | NV].

      * eapply perm_coh_lower; [| apply po_refl | eauto].

        rewrite m1_spec.

        inversion Hinv.

        destruct (thread_data_lock_coh0 i Hi).

        eapply H.

      * move: (mem_compatible_invalid_block ofs0 Hcompatible NV)

        => [] /(_ i Hi) [] _ -> _.

        apply perm_coh_empty_1.



  Qed.



  Lemma mtch_install_perm:

    forall js ds m m' tid (MATCH : match_st js ds)

      (Hcmpt : mem_compatible js m) (Htid : containsThread js tid)

      (Hperm : install_perm Hcmpt Htid m'),

      DryHybridMachine.install_perm _ _ _ (MTCH_compat _ _ _ MATCH Hcmpt) (MTCH_cnt MATCH Htid) m'.

  Proof.

    simpl; intros; hnf.

    subst.

    unshelve erewrite MTCH_restrict_personal; eauto; simpl.

    { apply Concur.compatible_threadRes_cohere; auto. }

    unfold Concur.install_perm; simpl; f_equal.

    apply proof_irr.

  Qed.



  Lemma core_diagram':

    forall (m : Mem.mem)  (U0 U U': schedule)

      (ds : dstate) dtr (js js': jstate) jtr jtr' rmap pmap

      (m' : Mem.mem),

      match_st js ds ->

      invariant ds ->

      corestep (JMachineSem U0 rmap) (U, jtr, js) m (U', jtr', js') m' ->

      exists (ds' : dstate),

        invariant ds' /\

        match_st js' ds' /\

        exists dtr', corestep (ClightMachineSem U0 pmap) (U, dtr, ds) m (U', dtr ++ dtr', ds') m'.

  Proof.

    intros m U0 U U' ds dtr js js' jtr jtr' rmap pmap m' MATCH dinv.

    unfold JuicyMachine.MachineSemantics; simpl.

    unfold JuicyMachine.MachStep; simpl.

    intros STEP;

      inversion STEP; subst.



    *         

      { inversion Htstep; subst.

        pose proof MTCH_updt' _ _ _ (Krun c_new) _ MATCH ctn (MTCH_cnt MATCH ctn) Hcmpt (MTCH_compat js ds m MATCH Hcmpt) as MATCH'.

        pose (ds':= (updThread (MTCH_cnt MATCH ctn) (Krun c_new)

          (HybridMachineSig.add_block (MTCH_compat js ds m MATCH Hcmpt) (MTCH_cnt MATCH ctn) m'0))).

        exists ds'.

        assert (DryHybridMachine.invariant ds').

        { eapply step_decay_invariant with (Hcompatible := MTCH_compat _ _ _ MATCH Hcmpt); auto.

          destruct Hinitial as (? & Harg & ?); subst.

          hnf in Hperm; subst.

          split; intros.

          + right; intro. contradiction H0. 

          + apply restrPermMap_valid in H0.

            right; intro. 

            unfold Concur.install_perm; destruct k.

            * pose proof restrPermMap_max ((MTCH_compat js ds m MATCH Hcmpt) tid (MTCH_cnt MATCH ctn)).1

                as Hmax1.

              apply equal_f with (b, ofs) in Hmax1.

              pose proof Concur.juicyRestrictMax (Concur.max_acc_coh_acc_coh (Concur.max_coh (Concur.thread_mem_compatible Hcmpt ctn)))

                (b, ofs) as Hmax2.

              unfold max_access_at, access_at in Hmax1, Hmax2; rewrite Hmax1 -Hmax2; auto.

            * destruct (restrPermMap_correct ((MTCH_compat js ds m MATCH Hcmpt) tid (MTCH_cnt MATCH ctn)).1 b ofs) as [_ Hcur1].

              unfold permission_at in Hcur1; rewrite Hcur1.

              pose proof Concur.juicyRestrictCurEq (Concur.max_acc_coh_acc_coh (Concur.max_coh (Concur.thread_mem_compatible Hcmpt ctn)))

                (b, ofs) as Hcur2.

              unfold access_at in Hcur2; rewrite Hcur2.

              inversion MATCH.

              symmetry; apply mtch_perm1. }

        split; auto; split.

        - hnf in Hperm; destruct Hinitial as (? & ? & ?); subst; auto.

        - exists nil; rewrite <- app_nil_end.

          eapply (HybridMachineSig.start_step tid) with (Htid0 := @MTCH_cnt js tid ds MATCH Htid).

          + assumption.

          + { simpl in Hperm; subst.

              econstructor.

              - eapply MTCH_getThreadC. eassumption. eassumption.

              - reflexivity.

              - simpl in *.

                destruct Hinitial as (? & ? & ?); split; eauto.

                split; auto.

                replace Htid with ctn by apply proof_irr.

                remember (Concur.install_perm _ _) as m1.

                apply mtch_install_perm with (ds := ds)(MATCH := MATCH) in Heqm1; hnf in Heqm1.

                rewrite Heqm1 in e; rewrite e; simpl.

                replace Htid with ctn by apply proof_irr; reflexivity.

              - eassumption.

              - replace Htid with ctn by apply proof_irr; reflexivity.

            }

      }



    *          

      { inversion MATCH; subst.

        inversion Htstep; subst.

        exists (updThreadC (mtch_cnt _ ctn) (Krun c')).

        split;[|split].

        

        { apply updThreadC_invariant; assumption. }

        

        { apply MTCH_updt; assumption.

        }

        

        { exists nil; rewrite <- app_nil_end.

          econstructor 2; try eassumption.

          - simpl. econstructor; try eassumption.

            + apply mtch_install_perm; eauto.

            + setoid_rewrite <- Hcode. symmetry. apply mtch_gtc.

            + reflexivity.

        }

      }



    *          

      {

        inversion MATCH; subst.

        inversion Htstep; subst.

        assert (Htid':=mtch_cnt _ Htid).



        exists (updThread Htid'

                     (Krun c')

                     (permissions.getCurPerm (m_dry jm'),

                      (getThreadR Htid').2

           )).

        split ; [|split].

        {

          inversion Hcorestep.

          eapply ev_step_ax2 in H; destruct H as [T H].

          apply ClightSemanticsForMachines.CLN_step_decay in H.

          

          eapply step_decay_invariant

            with (Hcompatible:= MTCH_compat _ _ _ MATCH Hcmpt); try eapply H; eauto.



  eapply MTCH_restrict_personal.

  auto.

  }

{

  apply MTCH_update.

  apply MTCH_age.

  assumption.

  - intros.

    assert (HH:= juicy_mem_access jm').

    rewrite <- HH.

    rewrite getCurPerm_correct.

    reflexivity.

  - intros.

    rewrite (MTCH_perm2' _ MATCH).

    

    inversion Hcorestep.

    eapply ev_step_ax2 in H; destruct H as [T H].

    apply ClightSemanticsForMachines.CLN_step_decay in H.

    { 

      replace (MTCH_cnt' MATCH Htid') with Htid by apply proof_irrelevance.

      move: H0 => [] [] _ /(_ (b,ofs)) [] A B _.

      destruct B as [B| [B|B]].

      - rewrite - B; simpl.

        destruct ((getThreadR Htid @ (b, ofs))) eqn:HH;

          try rewrite HH; simpl; eauto.

      - destruct B as [rsh [Wsh [v [v' [B1 B2]]]] ].

        rewrite B2.

        simpl in B1.

        destruct (OrdinalPool.getThreadR Htid @ (b, ofs)) eqn:HH;

          try ( try destruct k; simpl in B1; inversion B1).

        rewrite HH; simpl; auto.

      - destruct B as [[M [v B]]|[v[pp [B1 B2]]]].

        + rewrite B; simpl.

          { 

            destruct Hcmpt as [jall Hcmpt].

            inversion Hcmpt.

            inversion all_cohere.



            symmetry.

            apply po_None1.

            eapply po_trans;

            [ |eapply perm_of_res_op2].

            replace None with (max_access_at m  (b, ofs)).

            eapply po_trans.

            eapply max_coh.

            eapply Concur.po_join_sub'.

            apply resource_at_join_sub.

            apply Concur.compatible_threadRes_sub; auto.

            apply nextblock_access_empty.

            apply M.

            }

        + rewrite B2 B1; auto. }

}

{  assert (Hcmpt': DryHybridMachine.mem_compatible ds m) by

      (eapply MTCH_compat; eassumption).

   inversion Hcorestep.

   eapply ev_step_ax2 in H.

   destruct H as [T evSTEP].

   exists (map (Events.internal tid) T).

   eapply HybridMachineSig.thread_step; simpl.

   - eassumption.

   - econstructor; try eassumption.

      3: reflexivity.

     Focus 2. eapply (MTCH_getThreadC _ _ _ _ _ _ _ Hthread).

     instantiate(1:=Hcmpt').

     apply MTCH_restrict_personal.

     assumption.

}

  }



* 

inversion MATCH; subst.

  inversion Htstep; subst.

  exists (updThreadC (mtch_cnt _ ctn) (Kblocked c)).

  split;[|split].

  

  { apply updThreadC_invariant ; assumption. }

  

  { apply MTCH_updt; assumption.        }

  

  { exists nil; rewrite <- app_nil_end.

    econstructor 4; try eassumption.

    - simpl. reflexivity.

    - simpl. econstructor; try eassumption.

      + setoid_rewrite <- Hcode. symmetry. apply mtch_gtc.

      + apply mtch_install_perm; eauto.

      + reflexivity.

  }



*  

  {

    destruct (sync_step_diagram m m' U js js' ds tid ev MATCH dinv Htid Hcmpt HschedN Htstep)

      as [ds' [ev' [dinv' [MTCH' step']]]]; eauto.

    exists ds'; split; [| split]; try assumption.

    eexists; econstructor 5; simpl; try eassumption.

    reflexivity.

  }



*  

  { exists ds.

    split;[|split]; try eassumption.

    exists nil; rewrite <- app_nil_end.

    econstructor 6; try eassumption; try reflexivity.

    unfold not; simpl; intros.

    apply Htid. inversion MATCH; apply mtch_cnt'; assumption.

    { eapply MTCH_compat; eassumption. } }



  Grab Existential Variables.



  - assumption.

  - assumption.

  - assumption.

  Qed.



  Lemma core_diagram:

    forall (m : Mem.mem)  (U0 U U': schedule) rmap pmap

      (ds : dstate) dtr (js js': jstate) jtr jtr'

      (m' : Mem.mem),

      corestep (JMachineSem U0 rmap) (U, jtr, js) m (U', jtr', js') m' ->

      match_st js ds ->

      invariant ds ->

      exists (ds' : dstate),

        invariant ds' /\

        match_st js' ds' /\

        exists dtr', corestep (ClightMachineSem U0 pmap) (U, dtr, ds) m (U', dtr ++ dtr', ds') m'.

  Proof.

    intros. destruct (core_diagram' m U0 U U' ds dtr js js' jtr jtr' rmap0 pmap m' H0 H1 H) as [ds' [A[B C]]].

    exists ds'; split;[|split]; try assumption.

  Qed.



  Lemma halted_diagram:

    forall U ds js rmap pmap,

      fst (fst js) = fst (fst ds) ->

      halted (JMachineSem(ge := ge) U rmap) js = halted (ClightMachineSem(ge := ge) U pmap) ds.

        intros until pmap. destruct ds as [dp ?], js as [jp ?]; destruct dp, jp; simpl; intros HH; rewrite HH.

        reflexivity.

  Qed.



  End Parching.



End Parching.



