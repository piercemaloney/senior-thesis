Require Import VST.floyd.proofauto.
(* VST.floyd.proofauto:
From compcert Require Export common.AST cfrontend.Ctypes cfrontend.Clight.
Export Cop.
Require Export VST.floyd.base2.
Require Export VST.floyd.functional_base.
Require Export VST.floyd.client_lemmas.
Require Export VST.floyd.go_lower.
Require Export VST.floyd.closed_lemmas.
Require Export VST.floyd.compare_lemmas.
Require Export VST.floyd.semax_tactics.
Require Export VST.floyd.forward.
Require Export VST.floyd.subsume_funspec.
Require Export VST.floyd.call_lemmas.
Require Export VST.floyd.forward_lemmas.
Require Export VST.floyd.for_lemmas.
Require Export VST.floyd.nested_pred_lemmas.
Require Export VST.floyd.nested_field_lemmas.
Require Export VST.floyd.efield_lemmas.
Require Export VST.floyd.mapsto_memory_block.
Require Export VST.floyd.aggregate_type.
Require VST.floyd.aggregate_pred. Export floyd.aggregate_pred.aggregate_pred.
Require Export VST.floyd.reptype_lemmas.
Require Export VST.floyd.simpl_reptype.
Require Export VST.floyd.data_at_rec_lemmas.
Require Export VST.floyd.field_at.
Require Export VST.floyd.field_at_wand.
Require Export VST.floyd.field_compat.
Require Export VST.floyd.stronger.
Require Export VST.floyd.loadstore_mapsto.
Require Export VST.floyd.loadstore_field_at.
Require Export VST.floyd.nested_loadstore.
Require Export VST.floyd.local2ptree_denote.
Require Export VST.floyd.local2ptree_eval.
Require Export VST.floyd.local2ptree_typecheck.
Require Export VST.floyd.proj_reptype_lemmas.
Require Export VST.floyd.replace_refill_reptype_lemmas.
Require Export VST.floyd.sc_set_load_store.
Require Export VST.floyd.unfold_data_at.
Require Export VST.floyd.entailer.
Require Export VST.floyd.globals_lemmas.
Require Export VST.floyd.diagnosis.
Require Export VST.floyd.freezer.
Require Export VST.floyd.deadvars.
Require Export VST.floyd.hints.
Require Export VST.floyd.Clightnotations.
Require VST.msl.iter_sepcon.
Require VST.msl.wand_frame.
Require VST.msl.wandQ_frame.

Arguments semax {CS} {Espec} Delta Pre%assert cmd%C Post%assert.
Export ListNotations.
Export Clight_Cop2.

Hint Rewrite add_repr mul_repr sub_repr : entailer_rewrite.
Hint Rewrite ptrofs_add_repr ptrofs_mul_repr ptrofs_sub_repr : entailer_rewrite.
Hint Rewrite mul64_repr add64_repr sub64_repr or64_repr and64_repr : entailer_rewrite.
Hint Rewrite neg_repr neg64_repr : entailer_rewrite.
Hint Rewrite ptrofs_to_int_repr: entailer_rewrite norm.

Lemma Vptrofs_unfold_false: 
Archi.ptr64 = false -> Vptrofs = fun x => Vint (Ptrofs.to_int x).

Lemma Vptrofs_unfold_true: 
Archi.ptr64 = true -> Vptrofs = fun x => Vlong (Ptrofs.to_int64 x).

Lemma modu_repr: forall x y, 
   0 <= x <= Int.max_unsigned ->
Hint Rewrite modu_repr using rep_omega : entailer_rewrite norm.

Hint Rewrite Vptrofs_unfold_false using reflexivity: entailer_rewrite norm.
Hint Rewrite Vptrofs_unfold_true using reflexivity: entailer_rewrite norm.

Hint Extern 1 (Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef) => reflexivity : cancel.
Hint Extern 1 (list_repeat _ Vundef = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = list_repeat _ Vundef) => reflexivity : cancel.
Hint Extern 1 (Vundef :: _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = Vundef :: _) => reflexivity : cancel.
Hint Extern 1 (@nil _ = default_val _) => reflexivity : cancel.
Hint Extern 1 (default_val _ = @nil _) => reflexivity : cancel.

Instance Inhabitant_mpred : Inhabitant mpred := @FF mpred Nveric.
Instance Inhabitant_share : Inhabitant share := Share.bot.

Arguments deref_noload ty v / .
Arguments nested_field_array_type {cs} t gfs lo hi / .
Arguments nested_field_type {cs} t gfs / .  
Arguments nested_field_offset {cs} t gfs / .  
Arguments Z.mul !x !y.
Arguments Z.sub !m !n.
Arguments Z.add !x !y.
Global Transparent peq.
Global Transparent Archi.ptr64.

Ltac step :=
first [ progress Intros
       | let x := fresh "x" in Intros x
       | forward
       | forward_if
       | forward_call
       | rep_omega | cstring' | list_solve
       | EExists
       | progress (autorewrite with sublist in *|-)
       | progress (autorewrite with sublist)
       | progress (autorewrite with norm)
       | cstring1
       | deadvars!
       | progress_entailer
       ]. *)

Require Import VST.progs.bst.
(* VST.progs.bst:
From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats AST Ctypes Cop Clight Clightdefs.
Local Open Scope Z_scope.

Module Info.
  Definition version := "3.3"%string.
  Definition build_number := ""%string.
  Definition build_tag := ""%string.
  Definition arch := "x86"%string.
  Definition model := "32sse2"%string.
  Definition abi := "standard"%string.
  Definition bitsize := 32.
  Definition big_endian := false.
  Definition source_file := "progs/bst.c"%string.
  Definition normalized := true.
End Info.

Definition ___builtin_ais_annot : ident := 6%positive.
Definition ___builtin_annot : ident := 13%positive.
Definition ___builtin_annot_intval : ident := 14%positive.
Definition ___builtin_bswap : ident := 7%positive.
Definition ___builtin_bswap16 : ident := 9%positive.
Definition ___builtin_bswap32 : ident := 8%positive.
Definition ___builtin_bswap64 : ident := 39%positive.
Definition ___builtin_clz : ident := 40%positive.
Definition ___builtin_clzl : ident := 41%positive.
Definition ___builtin_clzll : ident := 42%positive.
Definition ___builtin_ctz : ident := 43%positive.
Definition ___builtin_ctzl : ident := 44%positive.
Definition ___builtin_ctzll : ident := 45%positive.
Definition ___builtin_debug : ident := 57%positive.
Definition ___builtin_fabs : ident := 10%positive.
Definition ___builtin_fmadd : ident := 48%positive.
Definition ___builtin_fmax : ident := 46%positive.
Definition ___builtin_fmin : ident := 47%positive.
Definition ___builtin_fmsub : ident := 49%positive.
Definition ___builtin_fnmadd : ident := 50%positive.
Definition ___builtin_fnmsub : ident := 51%positive.
Definition ___builtin_fsqrt : ident := 11%positive.
Definition ___builtin_membar : ident := 15%positive.
Definition ___builtin_memcpy_aligned : ident := 12%positive.
Definition ___builtin_nop : ident := 56%positive.
Definition ___builtin_read16_reversed : ident := 52%positive.
Definition ___builtin_read32_reversed : ident := 53%positive.
Definition ___builtin_va_arg : ident := 17%positive.
Definition ___builtin_va_copy : ident := 18%positive.
Definition ___builtin_va_end : ident := 19%positive.
Definition ___builtin_va_start : ident := 16%positive.
Definition ___builtin_write16_reversed : ident := 54%positive.
Definition ___builtin_write32_reversed : ident := 55%positive.
Definition ___compcert_i64_dtos : ident := 24%positive.
Definition ___compcert_i64_dtou : ident := 25%positive.
Definition ___compcert_i64_sar : ident := 36%positive.
Definition ___compcert_i64_sdiv : ident := 30%positive.
Definition ___compcert_i64_shl : ident := 34%positive.
Definition ___compcert_i64_shr : ident := 35%positive.
Definition ___compcert_i64_smod : ident := 32%positive.
Definition ___compcert_i64_smulh : ident := 37%positive.
Definition ___compcert_i64_stod : ident := 26%positive.
Definition ___compcert_i64_stof : ident := 28%positive.
Definition ___compcert_i64_udiv : ident := 31%positive.
Definition ___compcert_i64_umod : ident := 33%positive.
Definition ___compcert_i64_umulh : ident := 38%positive.
Definition ___compcert_i64_utod : ident := 27%positive.
Definition ___compcert_i64_utof : ident := 29%positive.
Definition ___compcert_va_composite : ident := 23%positive.
Definition ___compcert_va_float64 : ident := 22%positive.
Definition ___compcert_va_int32 : ident := 20%positive.
Definition ___compcert_va_int64 : ident := 21%positive.
Definition ___stringlit_1 : ident := 81%positive.
Definition ___stringlit_2 : ident := 82%positive.
Definition ___stringlit_3 : ident := 83%positive.
Definition ___stringlit_4 : ident := 84%positive.
Definition __l : ident := 71%positive.
Definition _b : ident := 65%positive.
Definition _delete : ident := 78%positive.
Definition _freeN : ident := 59%positive.
Definition _insert : ident := 70%positive.
Definition _key : ident := 1%positive.
Definition _l : ident := 72%positive.
Definition _left : ident := 4%positive.
Definition _lookup : ident := 80%positive.
Definition _main : ident := 85%positive.
Definition _mallocN : ident := 58%positive.
Definition _mid : ident := 74%positive.
Definition _p : ident := 60%positive.
Definition _pa : ident := 62%positive.
Definition _pb : ident := 63%positive.
Definition _pushdown_left : ident := 77%positive.
Definition _q : ident := 76%positive.
Definition _r : ident := 73%positive.
Definition _right : ident := 5%positive.
Definition _t : ident := 66%positive.
Definition _tree : ident := 3%positive.
Definition _tree_free : ident := 64%positive.
Definition _treebox_free : ident := 67%positive.
Definition _treebox_new : ident := 61%positive.
Definition _turn_left : ident := 75%positive.
Definition _v : ident := 79%positive.
Definition _value : ident := 2%positive.
Definition _x : ident := 68%positive.
Definition _y : ident := 69%positive.
Definition _t'1 : ident := 86%positive.

Definition v___stringlit_3 := {|
  gvar_info := (tarray tschar 5);
  gvar_init := (Init_int8 (Int.repr 102) :: Init_int8 (Int.repr 111) ::
                Init_int8 (Int.repr 117) :: Init_int8 (Int.repr 114) ::
                Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_1 := {|
  gvar_info := (tarray tschar 6);
  gvar_init := (Init_int8 (Int.repr 116) :: Init_int8 (Int.repr 104) ::
                Init_int8 (Int.repr 114) :: Init_int8 (Int.repr 101) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_4 := {|
  gvar_info := (tarray tschar 4);
  gvar_init := (Init_int8 (Int.repr 79) :: Init_int8 (Int.repr 78) ::
                Init_int8 (Int.repr 69) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition v___stringlit_2 := {|
  gvar_info := (tarray tschar 4);
  gvar_init := (Init_int8 (Int.repr 111) :: Init_int8 (Int.repr 110) ::
                Init_int8 (Int.repr 101) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition f_treebox_new := {|
  fn_return := (tptr (tptr (Tstruct _tree noattr)));
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_p, (tptr (tptr (Tstruct _tree noattr)))) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Scall (Some _t'1)
      (Evar _mallocN (Tfunction (Tcons tint Tnil) (tptr tvoid) cc_default))
      ((Esizeof (tptr (Tstruct _tree noattr)) tuint) :: nil))
    (Sset _p
      (Ecast (Etempvar _t'1 (tptr tvoid))
        (tptr (tptr (Tstruct _tree noattr))))))
  (Ssequence
    (Sassign
      (Ederef (Etempvar _p (tptr (tptr (Tstruct _tree noattr))))
        (tptr (Tstruct _tree noattr)))
      (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
    (Sreturn (Some (Etempvar _p (tptr (tptr (Tstruct _tree noattr))))))))
|}.

Definition f_tree_free := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_p, (tptr (Tstruct _tree noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_pa, (tptr (Tstruct _tree noattr))) ::
               (_pb, (tptr (Tstruct _tree noattr))) :: nil);
  fn_body :=
(Sifthenelse (Ebinop One (Etempvar _p (tptr (Tstruct _tree noattr)))
               (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
  (Ssequence
    (Sset _pa
      (Efield
        (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
          (Tstruct _tree noattr)) _left (tptr (Tstruct _tree noattr))))
    (Ssequence
      (Sset _pb
        (Efield
          (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
            (Tstruct _tree noattr)) _right (tptr (Tstruct _tree noattr))))
      (Ssequence
        (Scall None
          (Evar _freeN (Tfunction (Tcons (tptr tvoid) (Tcons tint Tnil))
                         tvoid cc_default))
          ((Etempvar _p (tptr (Tstruct _tree noattr))) ::
           (Esizeof (Tstruct _tree noattr) tuint) :: nil))
        (Ssequence
          (Scall None
            (Evar _tree_free (Tfunction
                               (Tcons (tptr (Tstruct _tree noattr)) Tnil)
                               tvoid cc_default))
            ((Etempvar _pa (tptr (Tstruct _tree noattr))) :: nil))
          (Scall None
            (Evar _tree_free (Tfunction
                               (Tcons (tptr (Tstruct _tree noattr)) Tnil)
                               tvoid cc_default))
            ((Etempvar _pb (tptr (Tstruct _tree noattr))) :: nil))))))
  Sskip)
|}.

Definition f_treebox_free := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_b, (tptr (tptr (Tstruct _tree noattr)))) :: nil);
  fn_vars := nil;
  fn_temps := ((_t, (tptr (Tstruct _tree noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sset _t
    (Ederef (Etempvar _b (tptr (tptr (Tstruct _tree noattr))))
      (tptr (Tstruct _tree noattr))))
  (Ssequence
    (Scall None
      (Evar _tree_free (Tfunction (Tcons (tptr (Tstruct _tree noattr)) Tnil)
                         tvoid cc_default))
      ((Etempvar _t (tptr (Tstruct _tree noattr))) :: nil))
    (Scall None
      (Evar _freeN (Tfunction (Tcons (tptr tvoid) (Tcons tint Tnil)) tvoid
                     cc_default))
      ((Etempvar _b (tptr (tptr (Tstruct _tree noattr)))) ::
       (Esizeof (tptr (Tstruct _tree noattr)) tuint) :: nil))))
|}.

Definition f_insert := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_t, (tptr (tptr (Tstruct _tree noattr)))) :: (_x, tint) ::
                (_value, (tptr tvoid)) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr (Tstruct _tree noattr))) :: (_y, tint) ::
               (_t'1, (tptr tvoid)) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _p
        (Ederef (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
          (tptr (Tstruct _tree noattr))))
      (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _tree noattr)))
                     (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))
                     tint)
        (Ssequence
          (Ssequence
            (Scall (Some _t'1)
              (Evar _mallocN (Tfunction (Tcons tint Tnil) (tptr tvoid)
                               cc_default))
              ((Esizeof (Tstruct _tree noattr) tuint) :: nil))
            (Sset _p
              (Ecast (Etempvar _t'1 (tptr tvoid))
                (tptr (Tstruct _tree noattr)))))
          (Ssequence
            (Sassign
              (Efield
                (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                  (Tstruct _tree noattr)) _key tint) (Etempvar _x tint))
            (Ssequence
              (Sassign
                (Efield
                  (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                    (Tstruct _tree noattr)) _value (tptr tvoid))
                (Etempvar _value (tptr tvoid)))
              (Ssequence
                (Sassign
                  (Efield
                    (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                      (Tstruct _tree noattr)) _left
                    (tptr (Tstruct _tree noattr)))
                  (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
                (Ssequence
                  (Sassign
                    (Efield
                      (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                        (Tstruct _tree noattr)) _right
                      (tptr (Tstruct _tree noattr)))
                    (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
                  (Ssequence
                    (Sassign
                      (Ederef
                        (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
                        (tptr (Tstruct _tree noattr)))
                      (Etempvar _p (tptr (Tstruct _tree noattr))))
                    (Sreturn None)))))))
        (Ssequence
          (Sset _y
            (Efield
              (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                (Tstruct _tree noattr)) _key tint))
          (Sifthenelse (Ebinop Olt (Etempvar _x tint) (Etempvar _y tint)
                         tint)
            (Sset _t
              (Eaddrof
                (Efield
                  (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                    (Tstruct _tree noattr)) _left
                  (tptr (Tstruct _tree noattr)))
                (tptr (tptr (Tstruct _tree noattr)))))
            (Sifthenelse (Ebinop Olt (Etempvar _y tint) (Etempvar _x tint)
                           tint)
              (Sset _t
                (Eaddrof
                  (Efield
                    (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                      (Tstruct _tree noattr)) _right
                    (tptr (Tstruct _tree noattr)))
                  (tptr (tptr (Tstruct _tree noattr)))))
              (Ssequence
                (Sassign
                  (Efield
                    (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                      (Tstruct _tree noattr)) _value (tptr tvoid))
                  (Etempvar _value (tptr tvoid)))
                (Sreturn None))))))))
  Sskip)
|}.

Definition f_turn_left := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((__l, (tptr (tptr (Tstruct _tree noattr)))) ::
                (_l, (tptr (Tstruct _tree noattr))) ::
                (_r, (tptr (Tstruct _tree noattr))) :: nil);
  fn_vars := nil;
  fn_temps := ((_mid, (tptr (Tstruct _tree noattr))) :: nil);
  fn_body :=
(Ssequence
  (Sset _mid
    (Efield
      (Ederef (Etempvar _r (tptr (Tstruct _tree noattr)))
        (Tstruct _tree noattr)) _left (tptr (Tstruct _tree noattr))))
  (Ssequence
    (Sassign
      (Efield
        (Ederef (Etempvar _l (tptr (Tstruct _tree noattr)))
          (Tstruct _tree noattr)) _right (tptr (Tstruct _tree noattr)))
      (Etempvar _mid (tptr (Tstruct _tree noattr))))
    (Ssequence
      (Sassign
        (Efield
          (Ederef (Etempvar _r (tptr (Tstruct _tree noattr)))
            (Tstruct _tree noattr)) _left (tptr (Tstruct _tree noattr)))
        (Etempvar _l (tptr (Tstruct _tree noattr))))
      (Sassign
        (Ederef (Etempvar __l (tptr (tptr (Tstruct _tree noattr))))
          (tptr (Tstruct _tree noattr)))
        (Etempvar _r (tptr (Tstruct _tree noattr)))))))
|}.

Definition f_pushdown_left := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_t, (tptr (tptr (Tstruct _tree noattr)))) :: nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr (Tstruct _tree noattr))) ::
               (_q, (tptr (Tstruct _tree noattr))) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _p
        (Ederef (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
          (tptr (Tstruct _tree noattr))))
      (Ssequence
        (Sset _q
          (Efield
            (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
              (Tstruct _tree noattr)) _right (tptr (Tstruct _tree noattr))))
        (Sifthenelse (Ebinop Oeq (Etempvar _q (tptr (Tstruct _tree noattr)))
                       (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))
                       tint)
          (Ssequence
            (Sset _q
              (Efield
                (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                  (Tstruct _tree noattr)) _left
                (tptr (Tstruct _tree noattr))))
            (Ssequence
              (Sassign
                (Ederef (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
                  (tptr (Tstruct _tree noattr)))
                (Etempvar _q (tptr (Tstruct _tree noattr))))
              (Ssequence
                (Scall None
                  (Evar _freeN (Tfunction
                                 (Tcons (tptr tvoid) (Tcons tint Tnil)) tvoid
                                 cc_default))
                  ((Etempvar _p (tptr (Tstruct _tree noattr))) ::
                   (Esizeof (Tstruct _tree noattr) tuint) :: nil))
                (Sreturn None))))
          (Ssequence
            (Scall None
              (Evar _turn_left (Tfunction
                                 (Tcons (tptr (tptr (Tstruct _tree noattr)))
                                   (Tcons (tptr (Tstruct _tree noattr))
                                     (Tcons (tptr (Tstruct _tree noattr))
                                       Tnil))) tvoid cc_default))
              ((Etempvar _t (tptr (tptr (Tstruct _tree noattr)))) ::
               (Etempvar _p (tptr (Tstruct _tree noattr))) ::
               (Etempvar _q (tptr (Tstruct _tree noattr))) :: nil))
            (Sset _t
              (Eaddrof
                (Efield
                  (Ederef (Etempvar _q (tptr (Tstruct _tree noattr)))
                    (Tstruct _tree noattr)) _left
                  (tptr (Tstruct _tree noattr)))
                (tptr (tptr (Tstruct _tree noattr))))))))))
  Sskip)
|}.

Definition f_delete := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_t, (tptr (tptr (Tstruct _tree noattr)))) :: (_x, tint) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr (Tstruct _tree noattr))) :: (_y, tint) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _p
        (Ederef (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
          (tptr (Tstruct _tree noattr))))
      (Sifthenelse (Ebinop Oeq (Etempvar _p (tptr (Tstruct _tree noattr)))
                     (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))
                     tint)
        (Sreturn None)
        (Ssequence
          (Sset _y
            (Efield
              (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                (Tstruct _tree noattr)) _key tint))
          (Sifthenelse (Ebinop Olt (Etempvar _x tint) (Etempvar _y tint)
                         tint)
            (Sset _t
              (Eaddrof
                (Efield
                  (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                    (Tstruct _tree noattr)) _left
                  (tptr (Tstruct _tree noattr)))
                (tptr (tptr (Tstruct _tree noattr)))))
            (Sifthenelse (Ebinop Olt (Etempvar _y tint) (Etempvar _x tint)
                           tint)
              (Sset _t
                (Eaddrof
                  (Efield
                    (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                      (Tstruct _tree noattr)) _right
                    (tptr (Tstruct _tree noattr)))
                  (tptr (tptr (Tstruct _tree noattr)))))
              (Ssequence
                (Scall None
                  (Evar _pushdown_left (Tfunction
                                         (Tcons
                                           (tptr (tptr (Tstruct _tree noattr)))
                                           Tnil) tvoid cc_default))
                  ((Etempvar _t (tptr (tptr (Tstruct _tree noattr)))) :: nil))
                (Sreturn None))))))))
  Sskip)
|}.

Definition f_lookup := {|
  fn_return := (tptr tvoid);
  fn_callconv := cc_default;
  fn_params := ((_t, (tptr (tptr (Tstruct _tree noattr)))) :: (_x, tint) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_p, (tptr (Tstruct _tree noattr))) :: (_v, (tptr tvoid)) ::
               (_y, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _p
    (Ederef (Etempvar _t (tptr (tptr (Tstruct _tree noattr))))
      (tptr (Tstruct _tree noattr))))
  (Ssequence
    (Swhile
      (Ebinop One (Etempvar _p (tptr (Tstruct _tree noattr)))
        (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)) tint)
      (Ssequence
        (Sset _y
          (Efield
            (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
              (Tstruct _tree noattr)) _key tint))
        (Sifthenelse (Ebinop Olt (Etempvar _x tint) (Etempvar _y tint) tint)
          (Sset _p
            (Efield
              (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                (Tstruct _tree noattr)) _left (tptr (Tstruct _tree noattr))))
          (Sifthenelse (Ebinop Olt (Etempvar _y tint) (Etempvar _x tint)
                         tint)
            (Sset _p
              (Efield
                (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                  (Tstruct _tree noattr)) _right
                (tptr (Tstruct _tree noattr))))
            (Ssequence
              (Sset _v
                (Efield
                  (Ederef (Etempvar _p (tptr (Tstruct _tree noattr)))
                    (Tstruct _tree noattr)) _value (tptr tvoid)))
              (Sreturn (Some (Etempvar _v (tptr tvoid)))))))))
    (Sreturn (Some (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))))))
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := nil;
  fn_temps := ((_p, (tptr (tptr (Tstruct _tree noattr)))) ::
               (_t'1, (tptr (tptr (Tstruct _tree noattr)))) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Ssequence
      (Scall (Some _t'1)
        (Evar _treebox_new (Tfunction Tnil
                             (tptr (tptr (Tstruct _tree noattr))) cc_default))
        nil)
      (Sset _p (Etempvar _t'1 (tptr (tptr (Tstruct _tree noattr))))))
    (Ssequence
      (Scall None
        (Evar _insert (Tfunction
                        (Tcons (tptr (tptr (Tstruct _tree noattr)))
                          (Tcons tint (Tcons (tptr tvoid) Tnil))) tvoid
                        cc_default))
        ((Etempvar _p (tptr (tptr (Tstruct _tree noattr)))) ::
         (Econst_int (Int.repr 3) tint) ::
         (Evar ___stringlit_1 (tarray tschar 6)) :: nil))
      (Ssequence
        (Scall None
          (Evar _insert (Tfunction
                          (Tcons (tptr (tptr (Tstruct _tree noattr)))
                            (Tcons tint (Tcons (tptr tvoid) Tnil))) tvoid
                          cc_default))
          ((Etempvar _p (tptr (tptr (Tstruct _tree noattr)))) ::
           (Econst_int (Int.repr 1) tint) ::
           (Evar ___stringlit_2 (tarray tschar 4)) :: nil))
        (Ssequence
          (Scall None
            (Evar _insert (Tfunction
                            (Tcons (tptr (tptr (Tstruct _tree noattr)))
                              (Tcons tint (Tcons (tptr tvoid) Tnil))) tvoid
                            cc_default))
            ((Etempvar _p (tptr (tptr (Tstruct _tree noattr)))) ::
             (Econst_int (Int.repr 4) tint) ::
             (Evar ___stringlit_3 (tarray tschar 5)) :: nil))
          (Ssequence
            (Scall None
              (Evar _insert (Tfunction
                              (Tcons (tptr (tptr (Tstruct _tree noattr)))
                                (Tcons tint (Tcons (tptr tvoid) Tnil))) tvoid
                              cc_default))
              ((Etempvar _p (tptr (tptr (Tstruct _tree noattr)))) ::
               (Econst_int (Int.repr 1) tint) ::
               (Evar ___stringlit_4 (tarray tschar 4)) :: nil))
            (Ssequence
              (Scall None
                (Evar _treebox_free (Tfunction
                                      (Tcons
                                        (tptr (tptr (Tstruct _tree noattr)))
                                        Tnil) tvoid cc_default))
                ((Etempvar _p (tptr (tptr (Tstruct _tree noattr)))) :: nil))
              (Sreturn (Some (Econst_int (Int.repr 0) tint)))))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

Definition composites : list composite_definition :=
(Composite _tree Struct
   ((_key, tint) :: (_value, (tptr tvoid)) ::
    (_left, (tptr (Tstruct _tree noattr))) ::
    (_right, (tptr (Tstruct _tree noattr))) :: nil)
   noattr :: nil).

Definition global_definitions : list (ident * globdef fundef type) :=
((___stringlit_3, Gvar v___stringlit_3) ::
 (___stringlit_1, Gvar v___stringlit_1) ::
 (___stringlit_4, Gvar v___stringlit_4) ::
 (___stringlit_2, Gvar v___stringlit_2) ::
 (___builtin_ais_annot,
   Gfun(External (EF_builtin "__builtin_ais_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___compcert_i64_dtos,
   Gfun(External (EF_runtime "__compcert_i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___compcert_i64_dtou,
   Gfun(External (EF_runtime "__compcert_i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___compcert_i64_stod,
   Gfun(External (EF_runtime "__compcert_i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___compcert_i64_utod,
   Gfun(External (EF_runtime "__compcert_i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___compcert_i64_stof,
   Gfun(External (EF_runtime "__compcert_i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___compcert_i64_utof,
   Gfun(External (EF_runtime "__compcert_i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___compcert_i64_sdiv,
   Gfun(External (EF_runtime "__compcert_i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_udiv,
   Gfun(External (EF_runtime "__compcert_i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_smod,
   Gfun(External (EF_runtime "__compcert_i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umod,
   Gfun(External (EF_runtime "__compcert_i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___compcert_i64_shl,
   Gfun(External (EF_runtime "__compcert_i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_shr,
   Gfun(External (EF_runtime "__compcert_i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___compcert_i64_sar,
   Gfun(External (EF_runtime "__compcert_i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___compcert_i64_smulh,
   Gfun(External (EF_runtime "__compcert_i64_smulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___compcert_i64_umulh,
   Gfun(External (EF_runtime "__compcert_i64_umulh"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___builtin_bswap64,
   Gfun(External (EF_builtin "__builtin_bswap64"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tulong Tnil) tulong cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_mallocN,
   Gfun(External (EF_external "mallocN"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tint Tnil) (tptr tvoid) cc_default)) ::
 (_freeN,
   Gfun(External (EF_external "freeN"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tint Tnil))
     tvoid cc_default)) :: (_treebox_new, Gfun(Internal f_treebox_new)) ::
 (_tree_free, Gfun(Internal f_tree_free)) ::
 (_treebox_free, Gfun(Internal f_treebox_free)) ::
 (_insert, Gfun(Internal f_insert)) ::
 (_turn_left, Gfun(Internal f_turn_left)) ::
 (_pushdown_left, Gfun(Internal f_pushdown_left)) ::
 (_delete, Gfun(Internal f_delete)) :: (_lookup, Gfun(Internal f_lookup)) ::
 (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _lookup :: _delete :: _pushdown_left :: _turn_left :: _insert ::
 _treebox_free :: _tree_free :: _treebox_new :: _freeN :: _mallocN ::
 ___builtin_debug :: ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_ctzll :: ___builtin_ctzl :: ___builtin_ctz ::
 ___builtin_clzll :: ___builtin_clzl :: ___builtin_clz ::
 ___builtin_bswap64 :: ___compcert_i64_umulh :: ___compcert_i64_smulh ::
 ___compcert_i64_sar :: ___compcert_i64_shr :: ___compcert_i64_shl ::
 ___compcert_i64_umod :: ___compcert_i64_smod :: ___compcert_i64_udiv ::
 ___compcert_i64_sdiv :: ___compcert_i64_utof :: ___compcert_i64_stof ::
 ___compcert_i64_utod :: ___compcert_i64_stod :: ___compcert_i64_dtou ::
 ___compcert_i64_dtos :: ___compcert_va_composite ::
 ___compcert_va_float64 :: ___compcert_va_int64 :: ___compcert_va_int32 ::
 ___builtin_va_end :: ___builtin_va_copy :: ___builtin_va_arg ::
 ___builtin_va_start :: ___builtin_membar :: ___builtin_annot_intval ::
 ___builtin_annot :: ___builtin_memcpy_aligned :: ___builtin_fsqrt ::
 ___builtin_fabs :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___builtin_ais_annot :: nil).

Definition prog : Clight.program := 
  mkprogram composites global_definitions public_idents _main Logic.I. *)



Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.



Definition t_struct_tree := Tstruct _tree noattr.



Section TREES.

Variable V : Type.

Variable default: V.



Definition key := Z.



Inductive tree : Type :=

 | E : tree

 | T: tree -> key -> V -> tree -> tree.



Definition empty_tree : tree := E.



Fixpoint lookup (x: key) (t : tree) : V :=

  match t with

  | E => default

  | T tl k v tr => if x <? k then lookup x tl

                         else if k <? x then lookup x tr

                         else v

  end.



Fixpoint insert (x: key) (v: V) (s: tree) : tree :=

 match s with

 | E => T E x v E

 | T a y v' b => if  x <? y then T (insert x v a) y v' b

                        else if y <? x then T a y v' (insert x v b)

                        else T a x v b

 end.



Fixpoint pushdown_left (a: tree) (bc: tree) : tree :=

 match bc with

 | E => a

 | T b y vy c => T (pushdown_left a b) y vy c

 end.



Fixpoint delete (x: key) (s: tree) : tree :=

 match s with

 | E => E

 | T a y v' b => if  x <? y then T (delete x a) y v' b

                        else if y <? x then T a y v' (delete x b)

                        else pushdown_left a b

 end.



End TREES.

Arguments E {V}.

Arguments T {V} _ _ _ _.

Arguments insert {V} x v s.

Arguments lookup {V} default x t.

Arguments pushdown_left {V} a bc.

Arguments delete {V} x s.



Fixpoint tree_rep (t: tree val) (p: val) : mpred :=

 match t with

 | E => !!(p=nullval) && emp

 | T a x v b => !! (Int.min_signed <= x <= Int.max_signed /\ tc_val (tptr Tvoid) v) &&

    EX pa:val, EX pb:val,

    data_at Tsh t_struct_tree (Vint (Int.repr x),(v,(pa,pb))) p *

    tree_rep a pa * tree_rep b pb

 end.



Definition treebox_rep (t: tree val) (b: val) :=

 EX p: val, data_at Tsh (tptr t_struct_tree) p b * tree_rep t p.



Lemma treebox_rep_spec: forall (t: tree val) (b: val),

  treebox_rep t b =

  EX p: val, 

  match t with

  | E => !!(p=nullval) && data_at Tsh (tptr t_struct_tree) p b

  | T l x v r => !! (Int.min_signed <= x <= Int.max_signed /\ tc_val (tptr Tvoid) v) &&

      data_at Tsh (tptr t_struct_tree) p b *

      spacer Tsh (sizeof tint) (sizeof size_t) p *

      field_at Tsh t_struct_tree [StructField _key] (Vint (Int.repr x)) p *

      field_at Tsh t_struct_tree [StructField _value] v p *

      treebox_rep l (field_address t_struct_tree [StructField _left] p) *

      treebox_rep r (field_address t_struct_tree [StructField _right] p)

  end.

Proof.

  intros.

  unfold treebox_rep at 1.

  f_equal.

  extensionality p.

  destruct t; simpl.

  + apply pred_ext; entailer!.

  + unfold treebox_rep.

    apply pred_ext; entailer!.

    - Intros pa pb.

      Exists pb pa.

      unfold_data_at (data_at _ _ _ p).

      rewrite (field_at_data_at _ t_struct_tree [StructField _left]).

      rewrite (field_at_data_at _ t_struct_tree [StructField _right]).

      cancel.

    - Intros pa pb.

      Exists pb pa.

      unfold_data_at (data_at _ _ _ p).

      rewrite (field_at_data_at _ t_struct_tree [StructField _left]).

      rewrite (field_at_data_at _ t_struct_tree [StructField _right]).

      cancel.

Qed.



Definition mallocN_spec :=

 DECLARE _mallocN

  WITH n: Z

  PRE [ 1%positive OF tint]

     PROP (4 <= n <= Int.max_unsigned)

     LOCAL (temp 1%positive (Vint (Int.repr n)))

     SEP ()

  POST [ tptr tvoid ]

     EX v: val,

     PROP (malloc_compatible n v)

     LOCAL (temp ret_temp v)

     SEP (memory_block Tsh n v).



Definition freeN_spec :=

 DECLARE _freeN

  WITH p : val , n : Z

  PRE [ 1%positive OF tptr tvoid , 2%positive OF tint]

     

      PROP() LOCAL (temp 1%positive p; temp 2%positive (Vint (Int.repr n)))

      SEP (memory_block Tsh n p)

  POST [ tvoid ]

    PROP () LOCAL () SEP ().



Definition treebox_new_spec :=

 DECLARE _treebox_new

  WITH u : unit

  PRE  [  ]

       PROP() LOCAL() SEP ()

  POST [ tptr (tptr t_struct_tree) ]

    EX v:val,

    PROP()

    LOCAL(temp ret_temp v)

    SEP (data_at Tsh (tptr t_struct_tree) nullval v).



Definition insert_spec :=

 DECLARE _insert

  WITH b: val, x: Z, v: val, t: tree val

  PRE  [ _t OF (tptr (tptr t_struct_tree)), _x OF tint,

        _value OF (tptr Tvoid)   ]

    PROP( Int.min_signed <= x <= Int.max_signed; is_pointer_or_null v)

    LOCAL(temp _t b; temp _x (Vint (Int.repr x)); temp _value v)

    SEP (treebox_rep t b)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (treebox_rep (insert x v t) b).



Definition lookup_spec :=

 DECLARE _lookup

  WITH b: val, x: Z, v: val, t: tree val

  PRE  [ _t OF (tptr (tptr t_struct_tree)), _x OF tint  ]

    PROP( Int.min_signed <= x <= Int.max_signed)

    LOCAL(temp _t b; temp _x (Vint (Int.repr x)))

    SEP (treebox_rep t b)

  POST [ tptr Tvoid ]

    PROP()

    LOCAL(temp ret_temp (lookup nullval x t))

    SEP (treebox_rep t b).



Definition turn_left_spec :=

 DECLARE _turn_left

  WITH ta: tree val, x: Z, vx: val, tb: tree val, y: Z, vy: val, tc: tree val, b: val, l: val, pa: val, r: val

  PRE  [ __l OF (tptr (tptr (Tstruct _tree noattr))),

        _l OF (tptr (Tstruct _tree noattr)),

        _r OF (tptr (Tstruct _tree noattr))]

    PROP(Int.min_signed <= x <= Int.max_signed; is_pointer_or_null vx)

    LOCAL(temp __l b; temp _l l; temp _r r)

    SEP (data_at Tsh (tptr t_struct_tree) l b;

         data_at Tsh t_struct_tree (Vint (Int.repr x), (vx, (pa, r))) l;

         tree_rep ta pa;

         tree_rep (T tb y vy tc) r)

  POST [ Tvoid ] 

    EX pc: val,

    PROP(Int.min_signed <= y <= Int.max_signed; is_pointer_or_null vy)

    LOCAL()

    SEP (data_at Tsh (tptr t_struct_tree) r b;

         data_at Tsh t_struct_tree (Vint (Int.repr y), (vy, (l, pc))) r;

         tree_rep (T ta x vx tb) l;

         tree_rep tc pc).



Definition pushdown_left_spec :=

 DECLARE _pushdown_left

  WITH ta: tree val, x: Z, v: val, tb: tree val, b: val, p: val

  PRE  [ _t OF (tptr (tptr (Tstruct _tree noattr)))]

    PROP(Int.min_signed <= x <= Int.max_signed; tc_val (tptr Tvoid) v)

    LOCAL(temp _t b)

    SEP (data_at Tsh (tptr t_struct_tree) p b;

         field_at Tsh t_struct_tree [StructField _key] (Vint (Int.repr x)) p;

         field_at Tsh t_struct_tree [StructField _value] v p;

         treebox_rep ta (field_address t_struct_tree [StructField _left] p);

         treebox_rep tb (field_address t_struct_tree [StructField _right] p))

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (treebox_rep (pushdown_left ta tb) b).



Definition delete_spec :=

 DECLARE _delete

  WITH b: val, x: Z, t: tree val

  PRE  [ _t OF (tptr (tptr t_struct_tree)), _x OF tint]

    PROP( Int.min_signed <= x <= Int.max_signed)

    LOCAL(temp _t b; temp _x (Vint (Int.repr x)))

    SEP (treebox_rep t b)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (treebox_rep (delete x t) b).



Definition tree_free_spec :=

 DECLARE _tree_free

  WITH t: tree val, p: val

  PRE  [ _p OF (tptr t_struct_tree) ]

       PROP() LOCAL(temp _p p) SEP (tree_rep t p)

  POST [ Tvoid ]

    PROP()

    LOCAL()

    SEP (emp).



Definition treebox_free_spec :=

 DECLARE _treebox_free

  WITH t: tree val, b: val

  PRE  [ _b OF (tptr (tptr t_struct_tree)) ]

       PROP() LOCAL(temp _b b) SEP (treebox_rep t b)

  POST [ Tvoid ]

    PROP()

    LOCAL()

    SEP (emp).



Definition Gprog : funspecs :=

    ltac:(with_library prog [

    mallocN_spec; freeN_spec; treebox_new_spec;

    tree_free_spec; treebox_free_spec;

    insert_spec; lookup_spec;

    turn_left_spec; pushdown_left_spec; delete_spec

  ]).



Lemma tree_rep_saturate_local:

   forall t p, tree_rep t p |-- !! is_pointer_or_null p.

Proof.

destruct t; simpl; intros.

entailer!.

Intros pa pb. entailer!.

Qed.



Hint Resolve tree_rep_saturate_local: saturate_local.



Lemma tree_rep_valid_pointer:

  forall t p, tree_rep t p |-- valid_pointer p.

Proof.

intros.

destruct t; simpl; normalize; auto with valid_pointer.

Qed.

Hint Resolve tree_rep_valid_pointer: valid_pointer.



Lemma treebox_rep_saturate_local:

   forall t b, treebox_rep t b |-- !! field_compatible (tptr t_struct_tree) [] b.

Proof.

intros.

unfold treebox_rep.

Intros p.

entailer!.

Qed.



Hint Resolve treebox_rep_saturate_local: saturate_local.



Definition insert_inv (b0: val) (t0: tree val) (x: Z) (v: val): environ -> mpred :=

  EX b: val, EX t: tree val,

  PROP()

  LOCAL(temp _t b; temp _x (Vint (Int.repr x));   temp _value v)

  SEP(treebox_rep t b;  (treebox_rep (insert x v t) b -* treebox_rep (insert x v t0) b0)).



Lemma ramify_PPQQ {A: Type} {NA: NatDed A} {SA: SepLog A} {CA: ClassicalSep A}: forall P Q,

  P |-- P * (Q -* Q).

Proof.

  intros.

  apply RAMIF_PLAIN.solve with emp.

  + rewrite sepcon_emp; auto.

  + rewrite emp_sepcon; auto.

Qed.



Lemma tree_rep_nullval: forall t,

  tree_rep t nullval |-- !! (t = E).

Proof.

  intros.

  destruct t; [entailer! |].

  simpl tree_rep.

  Intros pa pb. entailer!.

Qed.



Hint Resolve tree_rep_nullval: saturate_local.



Lemma treebox_rep_leaf: forall x p b (v: val),

  is_pointer_or_null v ->

  Int.min_signed <= x <= Int.max_signed ->

  data_at Tsh t_struct_tree (Vint (Int.repr x), (v, (nullval, nullval))) p * data_at Tsh (tptr t_struct_tree) p b |-- treebox_rep (T E x v E) b.

Proof.

  intros.

  unfold treebox_rep, tree_rep. Exists p nullval nullval. entailer!.

Qed.



Lemma bst_left_entail: forall (t1 t1' t2: tree val) k (v p1 p2 p b: val),

  Int.min_signed <= k <= Int.max_signed ->

  is_pointer_or_null v ->

  data_at Tsh (tptr t_struct_tree) p b *

  data_at Tsh t_struct_tree (Vint (Int.repr k), (v, (p1, p2))) p *

  tree_rep t1 p1 * tree_rep t2 p2

  |-- treebox_rep t1 (field_address t_struct_tree [StructField _left] p) *

       (treebox_rep t1'

         (field_address t_struct_tree [StructField _left] p) -*

        treebox_rep (T t1' k v t2) b).

Proof.

  intros.

  unfold_data_at (data_at _ _ _ p).

  rewrite (field_at_data_at _ t_struct_tree [StructField _left]).

  unfold treebox_rep at 1. Exists p1. cancel.



  rewrite <- wand_sepcon_adjoint.

  clear p1.

  unfold treebox_rep.

  Exists p.

  simpl.

  Intros p1.

  Exists p1 p2.

  entailer!.

  unfold_data_at (data_at _ _ _ p).

  rewrite (field_at_data_at _ t_struct_tree [StructField _left]).

  cancel.

Qed.



Lemma bst_right_entail: forall (t1 t2 t2': tree val) k (v p1 p2 p b: val),

  Int.min_signed <= k <= Int.max_signed ->

  is_pointer_or_null v ->

  data_at Tsh (tptr t_struct_tree) p b *

  data_at Tsh t_struct_tree (Vint (Int.repr k), (v, (p1, p2))) p *

  tree_rep t1 p1 * tree_rep t2 p2

  |-- treebox_rep t2 (field_address t_struct_tree [StructField _right] p) *

       (treebox_rep t2'

         (field_address t_struct_tree [StructField _right] p) -*

        treebox_rep (T t1 k v t2') b).

Proof.

  intros.

  unfold_data_at (data_at _ _ _ p).

  rewrite (field_at_data_at _ t_struct_tree [StructField _right]).

  unfold treebox_rep at 1. Exists p2. cancel.



  rewrite <- wand_sepcon_adjoint.

  clear p2.

  unfold treebox_rep.

  Exists p.

  simpl.

  Intros p2.

  Exists p1 p2.

  entailer!.

  unfold_data_at (data_at _ _ _ p).

  rewrite (field_at_data_at _ t_struct_tree [StructField _right]).

  cancel.

Qed.



Lemma modus_ponens_wand' {A}{ND: NatDed A}{SL: SepLog A}:

  forall P Q R: A, P |-- Q -> P * (Q -* R) |-- R.

Proof.

  intros.

  eapply derives_trans; [| apply modus_ponens_wand].

  apply sepcon_derives; [| apply derives_refl].

  auto.

Qed.



Lemma if_trueb: forall {A: Type} b (a1 a2: A), b = true -> (if b then a1 else a2) = a1.

Proof. intros; subst; auto. Qed.



Lemma if_falseb: forall {A: Type} b (a1 a2: A), b = false -> (if b then a1 else a2) = a2.

Proof. intros; subst; auto. Qed.



Ltac simpl_compb := first [ rewrite if_trueb by (apply Z.ltb_lt; omega)

                          | rewrite if_falseb by (apply Z.ltb_ge; omega)].



Lemma body_insert: semax_body Vprog Gprog f_insert insert_spec.

Proof.

  start_function.

  eapply semax_pre; [

    | apply (semax_loop _ (insert_inv b t x v) (insert_inv b t x v) )].

  * 

    unfold insert_inv.

    Exists b t. entailer.

    apply ramify_PPQQ.

  * 

    unfold insert_inv.

    Intros b1 t1.

    forward. 

    unfold treebox_rep at 1. Intros p1.

    forward. 

    forward_if.

    + 

      subst p1.

      Time forward_call (sizeof t_struct_tree).

        1: simpl; rep_omega.

      Intros p'.

      rewrite memory_block_data_at_ by auto.

      forward. 

      simpl.

      forward. 

      forward. 

      forward. 

      assert_PROP (t1= (@E _)).

        1: entailer!.

      subst t1. simpl tree_rep. rewrite !prop_true_andp by auto.

      forward. 

      forward. 

      apply modus_ponens_wand'.

      apply treebox_rep_leaf; auto.

    + 

      destruct t1.

        { simpl tree_rep. normalize. }

      simpl tree_rep.

      Intros pa pb. clear H1.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        unfold insert_inv.

        Exists (offset_val 8 p1) t1_1.

        entailer!. simpl.

        simpl_compb.

        

        replace (offset_val 8 p1)

          with (field_address t_struct_tree [StructField _left] p1)

          by (unfold field_address; simpl;

              rewrite if_true by auto with field_compatible; auto).

        apply RAMIF_PLAIN.trans'.

        apply bst_left_entail; auto.

      - 

        forward. 

        unfold insert_inv.

        Exists (offset_val 12 p1) t1_2.

        entailer!. simpl.

        simpl_compb; simpl_compb.

        

        replace (offset_val 12 p1)

          with (field_address t_struct_tree [StructField _right] p1)

          by (unfold field_address; simpl;

              rewrite if_true by auto with field_compatible; auto).

        apply RAMIF_PLAIN.trans'.

        apply bst_right_entail; auto.

      - 

        assert (x=k) by omega.

        subst x.  clear H H1 H3.

        forward. 

        forward.  simpl.

        

        simpl_compb.

        simpl_compb.

        apply modus_ponens_wand'.

        unfold treebox_rep. Exists p1.

        simpl tree_rep. Exists pa pb. entailer!.

  * 

    forward.

    unfold loop2_ret_assert. apply andp_left2. normalize. 

Qed.



Definition lookup_inv (b0 p0: val) (t0: tree val) (x: Z): environ -> mpred :=

  EX p: val, EX t: tree val, 

  PROP(lookup nullval x t = lookup nullval x t0) 

  LOCAL(temp _p p; temp _x (Vint (Int.repr x)))

  SEP(tree_rep t p;  (tree_rep t p -* tree_rep t0 p0)).



Lemma body_lookup: semax_body Vprog Gprog f_lookup lookup_spec.

Proof.

  start_function.

  unfold treebox_rep. Intros p.

  forward. 

  apply (semax_post_ret1 nil

          (data_at Tsh (tptr t_struct_tree) p b :: tree_rep t p :: nil)).

  1: intro HH; inversion HH.

  1: unfold treebox_rep; Exists p; entailer!.

  apply semax_frame''.

  forward_while (lookup_inv b p t x).

  * 

    Exists p t. entailer!.

    apply -> wand_sepcon_adjoint. cancel.

  * 

    entailer!.

  * 

    destruct t0; unfold tree_rep at 1; fold tree_rep. normalize.

    Intros pa pb.

    forward.

    forward_if; [ | forward_if ].

    + 

      forward. 

      Exists (pa,t0_1). unfold fst,snd.

      entailer!.

      - rewrite <- H0; simpl.

        simpl_compb; auto.

      - 

        apply RAMIF_PLAIN.trans''.

        apply -> wand_sepcon_adjoint.

        simpl. Exists pa pb; entailer!.

    + 

      forward. 

      Exists (pb,t0_2). unfold fst,snd.

      entailer!.

      - rewrite <- H0; simpl.

        simpl_compb; simpl_compb; auto.

      - 

        apply RAMIF_PLAIN.trans''.

        apply -> wand_sepcon_adjoint.

        simpl. Exists pa pb; entailer!.

    + 

      assert (x=k) by omega. subst x. clear H H3 H4.

      forward. 

      forward.  simpl.

      unfold treebox_rep. unfold normal_ret_assert.

      entailer!.

      - rewrite <- H0. simpl.

        simpl_compb; simpl_compb; auto.

      - 

        apply modus_ponens_wand'.

        Exists pa pb; entailer!.

  * 

    forward. 

    entailer!.

    apply modus_ponens_wand.

Qed.



Lemma body_turn_left: semax_body Vprog Gprog f_turn_left turn_left_spec.

Proof.

  start_function.

  simpl.

  Intros pb pc.

  forward. 

  forward. 

  forward. 

  forward. 

  Opaque tree_rep. forward. Transparent tree_rep. 

  

  Exists pc.

  entailer!.

  simpl.

  Exists pa pb.

  entailer!.

Qed.



Definition pushdown_left_inv (b_res: val) (t_res: tree val): environ -> mpred :=

  EX b: val, EX ta: tree val, EX x: Z, EX v: val, EX tb: tree val,

  PROP  () 

  LOCAL (temp _t b)

  SEP   (treebox_rep (T ta x v tb) b;

         (treebox_rep (pushdown_left ta tb) b -* treebox_rep t_res b_res)).



Lemma cancel_emp_spacer:

  forall sh x y p, x=y -> 

    emp |-- spacer sh x y p.

Proof.

intros.

subst.

unfold spacer.

rewrite Z.sub_diag. simpl. auto.

Qed.



Lemma cancel_spacer_emp:

  forall sh x y p, x=y -> 

    spacer sh x y p |-- emp.

Proof.

intros.

subst.

unfold spacer.

rewrite Z.sub_diag. simpl. auto.

Qed.



Lemma body_pushdown_left: semax_body Vprog Gprog f_pushdown_left pushdown_left_spec.

Proof.

  start_function.

  eapply semax_pre; [

    | apply (semax_loop _ (pushdown_left_inv b (pushdown_left ta tb))

                         (pushdown_left_inv b (pushdown_left ta tb)))].

  + 

    unfold pushdown_left_inv.

    Exists b ta x v tb.

    entailer!.

    eapply derives_trans; [| apply ramify_PPQQ].

    rewrite (treebox_rep_spec (T ta x v tb)).

    Exists p.

    entailer!.

  + 

    unfold pushdown_left_inv.

    clear x v H H0.

    Intros b0 ta0 x vx tbc0.

    unfold treebox_rep at 1.

    Intros p0.

    forward. 

    forward. 

      

    simpl tree_rep.

    Intros pa pbc.

    forward. 

    forward_if.

    - subst.

      assert_PROP (tbc0 = (@E _)).

        1: entailer!.

      subst.

      forward. 

      forward. 

      Time forward_call (p0, sizeof t_struct_tree). 

      {

        entailer!.

        rewrite memory_block_data_at_ by auto.

        cancel.

      }

      forward. 

      simpl.

      apply modus_ponens_wand'.

      Exists pa.

      entailer!.

    - destruct tbc0 as [| tb0 y vy tc0].

        { simpl tree_rep. normalize. }

      Time forward_call (ta0, x, vx, tb0, y, vy, tc0, b0, p0, pa, pbc). 

      Intros pc.

      forward. 

      Exists (field_address t_struct_tree [StructField _left] pbc) ta0 x vx tb0.

      

      Opaque tree_rep. entailer!. Transparent tree_rep.

        

      apply RAMIF_PLAIN.trans'.

      apply bst_left_entail; auto.

  + forward. 

    apply andp_left2; auto.

Qed.



Definition delete_inv (b0: val) (t0: tree val) (x: Z): environ -> mpred :=

  EX b: val, EX t: tree val,

  PROP()

  LOCAL(temp _t b; temp _x (Vint (Int.repr x)))

  SEP(treebox_rep t b;  (treebox_rep (delete x t) b -* treebox_rep (delete x t0) b0)).



Lemma body_delete: semax_body Vprog Gprog f_delete delete_spec.

Proof.

  start_function.

  eapply semax_pre; [

    | apply (semax_loop _ (delete_inv b t x) (delete_inv b t x) )].

  * 

    unfold delete_inv.

    Exists b t. entailer.

    apply ramify_PPQQ.

  * 

    unfold delete_inv.

    Intros b1 t1.

    forward. 

    unfold treebox_rep at 1. Intros p1.

    forward. 

    forward_if.

    + 

      subst p1.

      assert_PROP (t1= (@E _)).

        1: entailer!.

      subst t1. simpl tree_rep. rewrite !prop_true_andp by auto.

      forward. 

      unfold treebox_rep at 1.

      apply modus_ponens_wand'.

      Exists nullval.

      simpl tree_rep.

      entailer!.

    + 

      destruct t1.

        { simpl tree_rep. normalize. }

      simpl tree_rep.

      Intros pa pb. clear H0.

      forward. 

      forward_if; [ | forward_if ].

      - 

        forward. 

        unfold delete_inv.

        Exists (offset_val 8 p1) t1_1.

        entailer!. simpl.

        simpl_compb.

        

        replace (offset_val 8 p1)

          with (field_address t_struct_tree [StructField _left] p1)

          by (unfold field_address; simpl;

              rewrite if_true by auto with field_compatible; auto).

        apply RAMIF_PLAIN.trans'.

        apply bst_left_entail; auto.

      - 

        forward. 

        unfold delete_inv.

        Exists (offset_val 12 p1) t1_2.

        entailer!. simpl.

        simpl_compb; simpl_compb.

        

        replace (offset_val 12 p1)

          with (field_address t_struct_tree [StructField _right] p1)

          by (unfold field_address; simpl;

              rewrite if_true by auto with field_compatible; auto).

        apply RAMIF_PLAIN.trans'.

        apply bst_right_entail; auto.

      - 

        assert (x=k) by omega.

        subst x.

        unfold_data_at (data_at _ _ _ p1).

        gather_SEP 3 5.

        replace_SEP 0 (treebox_rep t1_1 (field_address t_struct_tree [StructField _left] p1)).

        {

          unfold treebox_rep; entailer!.

          Exists pa.

          rewrite field_at_data_at.

          entailer!.

        }

        gather_SEP 4 5.

        replace_SEP 0 (treebox_rep t1_2 (field_address t_struct_tree [StructField _right] p1)).

        {

          unfold treebox_rep; entailer!.

          Exists pb.

          rewrite field_at_data_at.

          entailer!.

        }

        Time forward_call (t1_1, k, v, t1_2, b1, p1).

        forward. 

        simpl.

        simpl_compb.

        simpl_compb.

        apply modus_ponens_wand'.

        auto.

  * 

    forward. apply andp_left2; auto. 

Qed.



Lemma body_treebox_new: semax_body Vprog Gprog f_treebox_new treebox_new_spec.

Proof.

  start_function.

  Time forward_call (sizeof (tptr t_struct_tree)).

  simpl sizeof; computable.

  Intros p.

  rewrite memory_block_data_at_ by auto.

  forward.

  forward.

  Exists p. entailer!.

Qed.



Lemma body_tree_free: semax_body Vprog Gprog f_tree_free tree_free_spec.

Proof.

  start_function.

  forward_if (PROP()LOCAL()SEP()).

  + destruct t; simpl tree_rep.

      1: Intros. contradiction.

    Intros pa pb.

    forward.

    forward.

    Time forward_call (p, sizeof t_struct_tree).

    {

      entailer!.

      rewrite memory_block_data_at_ by auto.

      cancel.

    }

    Time forward_call (t1,pa).

    Time forward_call (t2,pb).

    entailer!.

  + forward.

    subst.

    entailer!.

    simpl; normalize.

  + forward.

Qed.



Lemma body_treebox_free: semax_body Vprog Gprog f_treebox_free treebox_free_spec.

Proof.

  start_function.

  unfold treebox_rep.

  Intros p.

  forward.

  Time forward_call (t,p).

  Time forward_call (b, sizeof (tptr t_struct_tree)).

  entailer!.

  rewrite memory_block_data_at_ by auto.

  cancel.

  forward.

Qed.



Module Abstractions.



Section TREE_ABS.



Definition total_map (A:Type) := key -> A.

Definition t_empty {A:Type} (v : A) : total_map A :=

  (fun _ => v).

Definition t_update {A:Type} (m : total_map A)

                    (x : key) (v : A) :=

  fun x' => if x =? x' then v else m x'.



Definition combine {A} (pivot: key) (m1 m2: total_map A) : total_map A :=

  fun x : key => if zlt x pivot  then m1 x else m2 x.



Inductive Abs:  tree val -> total_map val -> Prop :=

| Abs_E: Abs E (t_empty nullval)

| Abs_T: forall a b l k v r,

      Abs l a ->

      Abs r b ->

      Abs (T l k v r)  (t_update (combine k a b) k v).



Theorem insert_relate:

 forall k v t cts,

    Abs t cts ->

    Abs (insert k v t) (t_update cts k v).

Admitted.  



Theorem lookup_relate:

  forall k t cts ,

    Abs t cts -> lookup nullval k t =  cts k.

Admitted.  



Definition tmap_rep (m: total_map val) (p: val) : mpred :=

   EX t: tree val, !! Abs t m && treebox_rep t p.



Definition abs_insert_spec :=

 DECLARE _insert

  WITH b: val, x: Z, v: val, m: total_map val

  PRE  [ _t OF (tptr (tptr t_struct_tree)), _x OF tint,

        _value OF (tptr Tvoid)   ]

    PROP( Int.min_signed <= x <= Int.max_signed; is_pointer_or_null v)

    LOCAL(temp _t b; temp _x (Vint (Int.repr x)); temp _value v)

    SEP (tmap_rep m b)

  POST [ Tvoid ] 

    PROP()

    LOCAL()

    SEP (tmap_rep (t_update m x v) b).



Definition abs_treebox_new_spec :=

 DECLARE _treebox_new

  WITH u : unit

  PRE  [  ]

       PROP() LOCAL() SEP ()

  POST [ tptr (tptr t_struct_tree) ]

    EX v:val,

    PROP()

    LOCAL(temp ret_temp v)

    SEP (tmap_rep (t_empty nullval) v).



Definition abs_treebox_free_spec :=

 DECLARE _treebox_free

  WITH m: total_map val, p: val

  PRE  [ _b OF (tptr (tptr t_struct_tree)) ]

       PROP() LOCAL(temp _b p) SEP (tmap_rep m p)

  POST [ Tvoid ]

    PROP()

    LOCAL()

    SEP (emp).



Definition main_spec :=

 DECLARE _main

  WITH gv : globals

  PRE  [] main_pre prog nil gv

  POST [ tint ] main_post prog nil gv.



Lemma subsume_insert:

 subsume_funspec (snd insert_spec) (snd abs_insert_spec).

Proof.

apply NDsubsume_subsume.

split; reflexivity.

split3; auto.

intros [[[b x] v] m].

unfold tmap_rep.

Intros t.

Exists (b, x, v, t).

Exists emp.

change (`emp) with (@emp (environ->mpred) _ _); rewrite !emp_sepcon.

apply andp_right; auto.

entailer!.

apply prop_right.

simplify_Delta.

Exists (insert x v t).

entailer!.

apply insert_relate; auto.

Qed.



Lemma subsume_treebox_new:

 subsume_funspec (snd treebox_new_spec) (snd abs_treebox_new_spec).

Proof.

apply NDsubsume_subsume.

split; reflexivity.

split3; auto.

intros x. simpl in x.

Exists x.

Exists emp.

change (`emp) with (@emp (environ->mpred) _ _); rewrite !emp_sepcon.

apply andp_right; auto.

apply prop_right.

simplify_Delta.

Intros v.

Exists v.

unfold tmap_rep.

Exists (empty_tree val).

unfold treebox_rep.

Exists nullval.

entailer!.

constructor.

simpl. entailer!. 

Qed.



Lemma subsume_treebox_free:

 subsume_funspec (snd treebox_free_spec) (snd abs_treebox_free_spec).

Proof.

apply NDsubsume_subsume.

split; reflexivity.

split3; auto.

intros [m p].

unfold tmap_rep.

Intros t.

Exists (t,p).

Exists emp.

change (`emp) with (@emp (environ->mpred) _ _); rewrite !emp_sepcon.

apply andp_right; auto.

apply prop_right.

simplify_Delta.

entailer!.

Qed.



Lemma body_main: semax_body Vprog Gprog f_main main_spec.

Proof.

start_function.

assert_PROP (isptr (gv ___stringlit_1)) by entailer!.

assert_PROP (isptr (gv ___stringlit_2)) by entailer!.

assert_PROP (isptr (gv ___stringlit_3)) by entailer!.

assert_PROP (isptr (gv ___stringlit_4)) by entailer!.

freeze [0;1;2;3] FR1.

forward_call subsume_treebox_new tt.

Intros p.

forward_call subsume_insert (p, 3, gv ___stringlit_1, t_empty nullval).

split. computable. auto.

forward_call subsume_insert (p, 1, gv ___stringlit_2, (t_update (t_empty nullval) 3 (gv ___stringlit_1))).

split. computable. auto.

forward_call subsume_insert (p, 4, gv ___stringlit_3, (t_update

             (t_update (t_empty nullval) 3

                (gv ___stringlit_1)) 1 (gv ___stringlit_2))).

split. computable. auto.

forward_call subsume_insert (p, 1, gv ___stringlit_4, 

           (t_update

             (t_update

                (t_update (t_empty nullval) 3

                   (gv ___stringlit_1)) 1

                (gv ___stringlit_2)) 4 (gv ___stringlit_3))).

split. computable. auto.

forward_call subsume_treebox_free ((t_update

             (t_update

                (t_update

                   (t_update (t_empty nullval) 3

                      (gv ___stringlit_1)) 1

                   (gv ___stringlit_2)) 4

                (gv ___stringlit_3)) 1 (gv ___stringlit_4)), p).

forward.

Qed.



End TREE_ABS.



End Abstractions.



