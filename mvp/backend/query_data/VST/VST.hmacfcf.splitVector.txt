

Set Implicit Arguments.



Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)

Require Import FCF.SemEquiv.
(* FCF.SemEquiv:
Set Implicit Arguments.

Require Import FCF.Comp.
Require Import FCF.DetSem.
Require Import FCF.DistSem.
Require Import FCF.Rat.
Require Import Arith.
Require Import FCF.StdNat.
Require Import FCF.Fold.
Require Import FCF.Limit.
Require Import Permutation.

Local Open Scope rat_scope.
Local Open Scope list_scope.

Lemma evalDet_step_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,
  evalDet_step c nil = (cs_done a s) ->
  evalDist c a' == if (eqd a a') then 1 else 0.

Lemma evalDet_step_nil_dist_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' a, 
    evalDet_step c nil = cs_more c' nil ->
    evalDist c a == evalDist c' a.

Lemma evalDet_steps_done_evalDist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (eqd : eq_dec A)(c : Comp A) a a' s,
    x = (cs_more c nil) -> 
    y = (cs_done a s) -> 
    well_formed_comp c ->
    evalDist c a' == if (eqd a a') then 1 else 0.
  
Lemma evalDet_steps_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,
  well_formed_comp c ->
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  evalDist c a' == if (eqd a a') then 1 else 0.

Definition lowDistApprox (A : Set)(c : Comp A)(a : A)(n : nat)(v : Rat) :=
  exists vals count,
    rel_map (evalDet c) (getAllBlists n) vals /\
    pred_count (eq (ca_done a)) vals count  /\
    v == (count / expnat 2 n).

Lemma map_Ret_repeat : forall (A : Set)(eqd : eq_dec A)(a : A) ls ls',
  rel_map (evalDet (Ret eqd a)) ls ls' ->
  ls' = listRepeat (ca_done a) (length ls).

Theorem lowDistApprox_Ret_inv : forall (A : Set)(eqd : eq_dec A)(a a' : A) n v,
  lowDistApprox (Ret eqd a) a' n v ->
  v == (if (eqd a a') then 1 else 0).

Inductive lowDistApprox_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(a : A)(n : nat) : Rat -> Prop :=
| lda_b_intro : 
  forall v,
    sumList_rel (fun (b : B) r => forall r1 r2, lowDistApprox c1 b n r1 -> lowDistApprox (c2 b) a n r2 -> r == r1 * r2) (getSupport c1) v ->
    lowDistApprox_bind c1 c2  a n v.

Inductive DistApproxTree(A : Set) :=
| dat_leaf : option A -> DistApproxTree A
| dat_internal : DistApproxTree A -> DistApproxTree A -> DistApproxTree A.

Inductive dat_correct_h(A : Set)(c : Comp A)(s : Blist) : nat -> DistApproxTree A -> Prop :=
    | dat_correct_h_leaf_Some :
      forall a n, 
        evalDet c s (ca_done a) ->
        dat_correct_h c s n (dat_leaf (Some a))
    | dat_correct_h_leaf_None :
        (forall a, ~ evalDet c s (ca_done a)) ->
        dat_correct_h c s 0 (dat_leaf None)
    | dat_correct_h_internal :
      forall t1 t2 n, 
        (forall a, ~ evalDet c s (ca_done a)) ->
        dat_correct_h c (s ++ (true :: nil)) n t1 ->
        dat_correct_h c (s ++ (false :: nil)) n t2 ->
        dat_correct_h c s (S n) (dat_internal t1 t2).

Definition dat_correct(A : Set)(c : Comp A)(n : nat) :=
    dat_correct_h c nil n.

Lemma dat_correct_func : forall (A : Set)(c : Comp A) ls n t1,
  dat_correct_h c ls n t1 ->
  forall t2, 
    dat_correct_h c ls n t2 ->
    t1 = t2.

Fixpoint getTreeSupport_dups(A : Set)(t : DistApproxTree A) :=
  match t with
    | dat_leaf o =>
      match o with
        | None => nil
        | Some a => a :: nil
      end
    | dat_internal t1 t2 =>
      getTreeSupport_dups t1 ++ getTreeSupport_dups t2
  end.

Definition getTreeSupport(A : Set)(eqd : eq_dec A)(t : DistApproxTree A) : list A :=
  getUnique (getTreeSupport_dups t) eqd.

Lemma getTreeSupport_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n,
  dat_correct c n t ->
  forall a,
    In a (getTreeSupport eqd t) ->
    In a (getSupport c).

Lemma getTreeSupport_not_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n a,
  dat_correct c n t ->
  ~In a (getSupport c) ->
  ~In a (getTreeSupport eqd t).

Lemma dat_exists_h : forall n s (A : Set)(c : Comp A),
  well_formed_comp c ->
  exists t : DistApproxTree A,
    dat_correct_h c s n t.

Theorem dat_exists : forall n (A : Set)(c : Comp A),
  well_formed_comp c ->
  exists t : DistApproxTree A,
    dat_correct c n t.

Fixpoint lowDistApproxFromTree(A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(a : A) :=
  match t with
    | dat_leaf o =>
      match o with
        | None => 0
        | Some a' => if (eqd a a') then 1 else 0
      end
    | dat_internal t1 t2 =>
      (lowDistApproxFromTree eqd t1 a) * (1 / 2) + (lowDistApproxFromTree eqd t2 a) * (1 / 2)
  end.

Definition lowDistApprox_ls (A : Set)(c : Comp A) a n (ls : Blist) r :=
  exists vals count,
    rel_map (fun s v => (evalDet c (ls ++ s) v)) (getAllBlists n) vals /\
    pred_count (eq (ca_done a)) vals count /\
    count /expnat 2 n == r.

Lemma lowDistApprox_ls_impl : forall n (A : Set)(c : Comp A) a r,
  lowDistApprox c a n r ->
  lowDistApprox_ls c a n nil r.

Lemma evalDet_lowDistApprox_ls_done_inv : forall (A : Set)(eqd : eq_dec A)(c : Comp A) s a1 a2 n r,
  evalDet c s (ca_done a1) ->
  lowDistApprox_ls c a2 n s r ->
  r == if (eqd a2 a1) then 1 else 0.
 
Lemma low_tree_approx_same_inv_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A) ls t,
  dat_correct_h c ls n t -> 
  forall a r, 
    lowDistApprox_ls c a n ls r ->
    lowDistApproxFromTree eqd t a == r.

Theorem low_tree_approx_same_inv : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) (a : A) r,
    dat_correct c n t -> 
    lowDistApprox c a n r ->
    lowDistApproxFromTree eqd t a == r.   

Theorem getSupport_not_In_lowDistApprox : forall n (A : Set)(c : Comp A)(a : A) r,
  ~In a (getSupport c) ->
  lowDistApprox c a n r ->
  r == 0.

Definition getSupport_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * (list A)) :=
  (map (fun b => (b , (getSupport (c2 b)))) (getSupport c1)).

Fixpoint flattenPair (A B : Type)(ls : list (A * list B)) :=
  match ls with
    | nil => nil
    | (a, ls_b) :: ls' =>
      (map (fun b => (a, b)) ls_b) ++ (flattenPair ls')
  end.

Theorem in_flattenPair : forall (A B : Type)(ls : list (A * (list B))) a b entryList,
  In (a, entryList) ls ->
  In b entryList ->
  In (a, b) (flattenPair ls).

Definition getSupport_bind_cp (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * A) :=
  flattenPair (getSupport_bind c1 c2).

Lemma In_getSupport_bind_cp : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) b a,
  In b (getSupport c1) ->
  In a (getSupport (c2 b)) ->
  In (b, a) (getSupport_bind_cp c1 c2).

Lemma not_In_getSupport_bind_cp : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(c1 : Comp B)(c2 : B -> Comp A) b a,
  ~ In (b, a) (getSupport_bind_cp c1 c2) ->
  ~ In b (getSupport c1) \/ 
  ~ In a (getSupport (c2 b)).

Lemma evalDet_lowDistApprox_ls_done:
  forall (A : Set) (eqd : eq_dec A) (c : Comp A) (s : Blist) 
    (a1 a2 : A) (n : nat),
    evalDet c s (ca_done a1) ->
    lowDistApprox_ls c a2 n s (if eqd a2 a1 then 1 else 0).

Lemma evalDet_lowDistApprox_ls_not_done:
  forall (A : Set) (c : Comp A) (s : Blist) 
    (a2 : A) (n : nat),
    well_formed_comp c ->
    (forall s' (a : A), In s' (getAllBlists n) -> evalDet c (s ++ s') (ca_done a) -> False) ->
    lowDistApprox_ls c a2 n s 0.

Lemma low_tree_approx_same_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) ls,
                                 dat_correct_h c ls n t ->
                                 forall a, 
                                   well_formed_comp c ->
                                   lowDistApprox_ls c a n ls (lowDistApproxFromTree eqd t a).

Theorem low_tree_approx_same : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A),
  well_formed_comp c ->
  dat_correct c n t -> 
  forall a, 
    lowDistApprox c a n (lowDistApproxFromTree eqd t a).

Lemma lowDistApprox_left_total : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a,
  well_formed_comp c ->
  left_total (lowDistApprox c a).

Inductive datMap(A B : Set)(f : A -> DistApproxTree B -> Prop) : DistApproxTree A -> DistApproxTree B  -> Prop :=
| datMap_leaf_None :
    datMap f (dat_leaf None) (dat_leaf None)
| datMap_leaf_Some : 
  forall a t,
    f a t ->
    datMap f (dat_leaf (Some a)) t
| datMap_internal : 
  forall t1a t2a t1b t2b,
    datMap f t1a t1b ->
    datMap f t2a t2b ->
    datMap f (dat_internal t1a t2a) (dat_internal t1b t2b).

Inductive datMap_depth(A B : Set)(f : nat -> A -> DistApproxTree B -> Prop) : nat -> DistApproxTree A -> DistApproxTree B -> Prop :=
| datMap_depth_leaf_None :
  forall n, 
    datMap_depth f n (dat_leaf None) (dat_leaf None)
| datMap_depth_leaf_Some :
  forall n a t,
    f n a t ->
    datMap_depth f n (dat_leaf (Some a)) t
| datMap_depth_internal :
  forall n t1a t2a t1b t2b,
    datMap_depth f n t1a t1b ->
    datMap_depth f n t2a t2b ->
    datMap_depth f (S n) (dat_internal t1a t2a) (dat_internal t1b t2b).

Definition dat_correct_bind(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=
  exists tb, dat_correct c1 n tb /\
    (datMap_depth (fun n' b ta => (dat_correct (c2 b) n' ta)) n tb t).

Definition dat_correct_bind2(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=
  exists tb, dat_correct c1 n tb /\
    (datMap (fun b ta => (dat_correct (c2 b) n ta)) tb t).

Lemma lowDistApproxFromTree_eq_0 : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,
  ~In a (getTreeSupport eqd t) ->
  lowDistApproxFromTree eqd t a == 0.

Lemma lowDistApproxFromTree_datMap_inv : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(tb : DistApproxTree B)(ta : DistApproxTree A)(mapRel : B -> DistApproxTree A -> Prop),
  datMap mapRel tb ta ->
  (forall b, In b (getTreeSupport eqdb tb) -> exists t,  mapRel b t) ->
  (forall b t1 t2, mapRel b t1 -> mapRel b t2 -> t1 = t2) -> 
  forall a r, 
    sumList_rel 
    (fun b r' => 
      forall ta', mapRel b ta' ->  
        lowDistApproxFromTree eqdb tb b * lowDistApproxFromTree eqda ta' a == r')
    (getTreeSupport eqdb tb)
    r ->
    lowDistApproxFromTree eqda ta a == r.

Lemma getTreeSupport_approx_0: forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,
  ~In a (getTreeSupport eqd t) ->
  lowDistApproxFromTree eqd t a == 0.

Lemma lowDistApprox_le_1 : forall (A : Set)(c : Comp A) a n r,
  lowDistApprox c a n r ->
  r <= 1.

Theorem bind_low_tree_approx_same_inv : forall (A B : Set)(eqda : eq_dec A)(c1 : Comp B)(c2 : B -> Comp A) n a t r,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b))->
  lowDistApprox_bind c1 c2 a n r ->
  dat_correct_bind2 c1 c2 n t ->
  r == lowDistApproxFromTree eqda t a.

Lemma in_flattenPair_inv : forall (A B : Set)(ls : list (A * list B)) a b,
  In (a, b) (flattenPair ls) ->
  exists lsb,
    In b lsb /\ In (a , lsb) ls.

Lemma in_getSupport_bind_cp_fst : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a0,
  In a0 (getSupport_bind_cp c1 c2) -> 
  In (fst a0) (getSupport c1).

Lemma lowDistApprox_bind_evalDist_limit : forall (A B :Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  (forall (a : B),
    rat_inf_limit (lowDistApprox c1 a) (evalDist c1 a)) ->
  (forall (b : B) (a : A),
    In b (getSupport c1) ->
    rat_inf_limit (lowDistApprox (c2 b) a) (evalDist (c2 b) a)) ->
  rat_inf_limit (lowDistApprox_bind c1 c2 a) (evalDist (Bind c1 c2) a).

Lemma datMap_left_total : forall (A B : Set)(eqdb : eq_dec A)(t : DistApproxTree A)(f : A -> DistApproxTree B -> Prop),
  (forall a, In a (getTreeSupport eqdb t) -> exists b, f a b) ->
  exists t',
    datMap f t t'.
    
Lemma dat_exists_bind2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  exists t, dat_correct_bind2 c1 c2 n t.

Inductive dat_better(A : Set) : DistApproxTree A -> DistApproxTree A -> Prop :=
| dat_better_leaf_None : forall t,
  dat_better t (dat_leaf None)
| dat_better_leaf_Some : forall a,
  dat_better (dat_leaf (Some a)) (dat_leaf (Some a))
| dat_better_internal : forall ta1 ta2 tb1 tb2,
  dat_better ta1 tb1 ->
  dat_better ta2 tb2 ->
  dat_better (dat_internal ta1 ta2) (dat_internal tb1 tb2).

Hint Constructors dat_better : dat.

Lemma dat_better_refl : forall (A : Set)(t : DistApproxTree A),
  dat_better t t.

Lemma dat_better_trans : forall (A : Set)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  forall t3, 
    dat_better t2 t3 ->
    dat_better t1 t3.

Lemma dat_correct_dat_better : forall (A : Set)(c : Comp A) ls n1 t1,
  dat_correct_h c ls n1 t1 ->
  forall n2 t2,
    dat_correct_h c ls n2 t2 ->
    n1 >= n2 ->
    dat_better t1 t2.

Lemma lowDistApprox_dat_better_le : forall (A : Set)(eqd : eq_dec A)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  forall (a : A), 
    lowDistApproxFromTree eqd t2 a <= lowDistApproxFromTree eqd t1 a.

Lemma datMap_better : forall (A B : Set)(t : DistApproxTree B) n (rel : nat -> B -> DistApproxTree A -> Prop) t1 t2,
  (forall n b t1 t2, rel n b t1 -> rel (pred n) b t2 -> dat_better t1 t2) ->
  datMap (rel n) t t1 ->
  datMap (rel (pred n)) t t2 ->
  dat_better t1 t2.

Lemma datMap_depth_better : forall (A B : Set)(tb1 tb2 : DistApproxTree B),
  dat_better tb1 tb2 ->
  forall  n1 n2 (f : nat -> B -> DistApproxTree A -> Prop) t1 t2,
    (forall n1 n2 b t1 t2, n1 >= n2 -> f n1 b t1 -> f n2 b t2 -> dat_better t1 t2) ->
    datMap (f n1) tb1 t1 ->
    datMap_depth f n2 tb2 t2 ->
    n1 >= n2 ->
    dat_better t1 t2.

Lemma dat_bind_2_better : forall (n : nat) (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1 t2,
  dat_correct_bind2 c1 c2 n t1 ->
  dat_correct_bind c1 c2 n t2 ->
  dat_better t1 t2.

Lemma dat_correct_h_bind_app : forall (A B : Set) t (c1 : Comp B)(c2 : B -> Comp A) n ls1 ls2 a,
  evalDet_steps (cs_more c1 ls1) (cs_done a nil) ->
  dat_correct_h (Bind c1 c2) (ls1 ++ ls2) n t ->
  dat_correct_h (c2 a) ls2 n t.

Lemma dat_correct_bind_same_h : forall n (A : Set)(c : Comp A) ls t,
  dat_correct_h c ls n t ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1,
    c = Bind c1 c2 ->
    well_formed_comp c1 ->
    (forall a ls', evalDet_steps (cs_more c1 ls) (cs_done a ls') -> ls' = nil) -> 
    dat_correct_h c1 ls n t1 ->  
    datMap_depth
    (fun (depth : nat) (b : B) t2 => dat_correct_h (c2 b) nil depth t2) 
    n t1 t.

Lemma lowDistApprox_le_bind : forall n (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a r1 r2,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  lowDistApprox (Bind c1 c2) a n r1 -> 
  lowDistApprox_bind c1 c2 a n r2 ->
  r1 <= r2.

Lemma dat_correct_bind_same: forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t,
  well_formed_comp c1 ->
  dat_correct (Bind c1 c2) n t ->
  dat_correct_bind c1 c2 n t.
    
Fixpoint datDepth (A : Set)(t : DistApproxTree A) : nat :=
  match t with
    | dat_leaf o => O
    | dat_internal t1 t2 =>
      S (max (datDepth t1) (datDepth t2))
  end.

Lemma datMap_depth_better' : forall (B : Set)(tb1 tb2 : DistApproxTree B),
  dat_better tb1 tb2 ->
  forall (A : Set)(rel : nat -> B -> DistApproxTree A -> Prop) n n' t1 t2,
    datMap_depth rel n tb1 t1 ->
    datMap (rel n') tb2 t2 ->
    n >= n' + (datDepth tb2) ->
    (forall b n1 n2 t1 t2, rel n1 b t1 -> rel n2 b t2 -> n1 >= n2 -> dat_better t1 t2) -> 
    dat_better t1 t2.

Lemma datCorrect_datDepth : forall (A : Set)(c : Comp A) n t,
  dat_correct c n t ->
  (datDepth t <= n)%nat.

Lemma dat_better_bind_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t1 t2,
  dat_correct_bind c1 c2 n t1 ->
  dat_correct_bind2 c1 c2 (div2 n) t2 ->
  dat_better t1 t2.

Lemma lowDistApprox_bind_le_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a n r1 r2,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  lowDistApprox_bind c1 c2 a (div2 n) r1 ->
  lowDistApprox (Bind c1 c2) a n r2 ->
  r1 <= r2.

Lemma lowDistApprox_func : forall (A : Set)(c : Comp A) a n r1 r2,
  well_formed_comp c ->
  lowDistApprox c a n r1 ->
  lowDistApprox c a n r2 ->
  r1 == r2.

Lemma lowDistApprox_bind_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) -> 
  left_total (lowDistApprox_bind c1 c2 a).

Lemma lowDistApprox_bind_div2_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  left_total (fun n => lowDistApprox_bind c1 c2 a (div2 n)).

Lemma rel_map_Rnd_NoDup : forall n ls,
  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->
  NoDup ls.

Lemma rel_map_Rnd_any_in : forall n ls (a : Bvector n),
  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->
  In (ca_done a) ls.

Theorem lowDistApprox_Rnd: forall n2 n1 (a : Bvector n1) r,
  lowDistApprox (Rnd n1) a (n1 + n2) r ->
  r == (1 / (expnat 2 n1)).

Definition indicator_rel (A : Set)(P : A -> bool) a (r : Rat) :=
  (P a = true /\ r == 1) \/ (P a = false /\ r == 0).

Definition lowDistApprox_repeat (A : Set)(c : Comp A)(P : A -> bool) a n : Rat -> Prop := 
  let approx := lowDistApprox c a n in
    let empty := sumList_rel (fun a => lowDistApprox c a n) (filter (fun a => negb (P a)) (getSupport c)) in
  ratMult_rel (ratMult_rel (indicator_rel P a)
    (sumList_rel (fun i => (expRat_rel empty i)) (getNats O (S n)))) 
  approx.

Lemma lowDistApprox_repeat_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  left_total (lowDistApprox_repeat c P a).

Lemma lowDistApprox_repeat_sqrt_div2_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  left_total (fun n => (lowDistApprox_repeat c P a (Nat.sqrt (div2 n)))).

Inductive datRepeat (A : Set)(f : DistApproxTree A -> Prop)(P : A -> bool) : nat -> DistApproxTree A -> DistApproxTree A -> Prop :=
  | datRepeat_leaf_None : forall n,
    datRepeat f P n (dat_leaf None) (dat_leaf None)
  | datRepeat_leaf_Some_yes : forall a n,
    P a = true ->
    datRepeat f P n (dat_leaf (Some a)) (dat_leaf (Some a))
  | datRepeat_leaf_Some_no : forall a,
    P a = false ->
    datRepeat f P O (dat_leaf (Some a)) (dat_leaf None)
  | datRepeat_leaf_Some_repeat : forall a t t' n,
    f t ->
    P a = false ->
    datRepeat f P n t t' ->
    datRepeat f P (S n) (dat_leaf (Some a)) t'
  | datRepeat_internal : forall n t1 t2 t1' t2',
    datRepeat f P n t1 t1' ->
    datRepeat f P n t2 t2' ->
    datRepeat f P n (dat_internal t1 t2) (dat_internal t1' t2').

Definition dat_correct_repeat2(A : Set)(c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=
exists t1 : DistApproxTree A,
  dat_correct c n t1 /\
  datRepeat (dat_correct c n) P n t1 t. 

Lemma datRepeat_left_total : forall n (A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(f : DistApproxTree A -> Prop) P,
   (exists b : DistApproxTree A, f b) ->
   exists t', datRepeat f P n t t'.

Lemma dat_exists_repeat2 : forall (A : Set)(c : Comp A)(P : A -> bool)(n : nat),
  well_formed_comp c ->
  exists t : DistApproxTree A, dat_correct_repeat2 c P n t.

Fixpoint computeEmptySpace(A : Set)(t : DistApproxTree A)(P : A -> bool) :=
  match t with
    | dat_leaf o =>
      match o with
        | Some a => indicator (fun a' => (negb (P a'))) a 
        | None => 0
      end
    | dat_internal t1 t2 =>
      (1 / 2) * (computeEmptySpace t1 P)  + (1 / 2) * (computeEmptySpace t2 P)
  end.

Lemma computeEmptySpace_correct : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) P,
  sumList (filter (fun a => negb (P a)) (getTreeSupport eqd t)) (lowDistApproxFromTree eqd t) == (computeEmptySpace t P).

Lemma lowDistApprox_val_eq : forall (A : Set)(c : Comp A) a n r1 r2,
  lowDistApprox c a n r1 ->
  r1 == r2 ->
  lowDistApprox c a n r2.

Lemma repeat_low_tree_approx_same_tree_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> bool)(t1 t2 t3 : DistApproxTree A) n a,
  datRepeat (eq t3) P n t1 t2 ->
  lowDistApproxFromTree eqd t2 a == 
  indicator P a * 
  ((lowDistApproxFromTree eqd t1 a) + 
    (computeEmptySpace t1 P) * 
    sumList (getNats 0 n) (expRat (computeEmptySpace t3 P)) * (lowDistApproxFromTree eqd t3 a)).

Lemma datRepeat_func_eq : forall n (A : Set)(t1 t2 : DistApproxTree A) f P (P' : DistApproxTree A -> Prop),
  datRepeat f P n t1 t2 ->
  (forall t, f t -> P' t) ->
  datRepeat P' P n t1 t2.

Lemma repeat_low_tree_approx_same_inv
  : forall (A : Set) (eqd : eq_dec A)(c : Comp A)(P : A -> bool) (n : nat) (a : A) (t : DistApproxTree A) (r : Rat),
    well_formed_comp c ->
    (exists a, In a (filter P (getSupport c))) ->
    lowDistApprox_repeat c P a n r ->
    dat_correct_repeat2 c P n t -> 
    n > 0 ->
    r == lowDistApproxFromTree eqd t a.

Lemma dat_better_antisymm : forall (A : Set)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  dat_better t2 t1 ->
  t1 = t2.

Lemma dat_correct_h_repeat_app : forall (A : Set) t (c : Comp A)(P : A -> bool) n ls1 ls2 a,
  evalDet_steps (cs_more c ls1) (cs_done a nil) ->
  P a = false ->
  dat_correct_h (Repeat c P) (ls1 ++ ls2) n t ->
  dat_correct_h (Repeat c P) ls2 n t.

Inductive datRepeat_depth (A : Set)(f : nat -> DistApproxTree A -> Prop)(P : A -> bool) : nat -> nat -> DistApproxTree A -> DistApproxTree A -> Prop :=
  | datRepeat_depth_leaf_None : forall n depth,
    datRepeat_depth f P n depth (dat_leaf None) (dat_leaf None)
  | datRepeat_depth_leaf_Some_yes : forall a n depth,
    P a = true ->
    datRepeat_depth f P n depth (dat_leaf (Some a)) (dat_leaf (Some a))
  | datRepeat_depth_leaf_Some_no : forall a depth,
    P a = false ->
    datRepeat_depth f P O depth (dat_leaf (Some a)) (dat_leaf None)
  | datRepeat_depth_leaf_Some_repeat : forall a t t' n depth,
    P a = false ->
    f depth t ->
    datRepeat_depth f P n depth t t' ->
    datRepeat_depth f P (S n) depth (dat_leaf (Some a)) t'
  | datRepeat_depth_internal : forall n depth t1 t2 t1' t2',
    datRepeat_depth f P n depth t1 t1' ->
    datRepeat_depth f P n depth t2 t2' ->
    datRepeat_depth f P n (S depth) (dat_internal t1 t2) (dat_internal t1' t2').

Definition dat_correct_repeat(A : Set) (c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=
exists t1 : DistApproxTree A,
  dat_correct c n t1 /\
  datRepeat_depth (dat_correct c) P n n t1 t.

Lemma datRepeat_depth_0 : forall n2 n1 (A : Set)(f : nat -> DistApproxTree A -> Prop) P t1 t2,
  datRepeat_depth f P n1 O t1 t2 ->
  n2 >= n1 ->
  f O (dat_leaf None) ->
  datRepeat_depth f P n2 O t1 t2.

Lemma dat_correct_repeat_same_h : forall depth repeats (A : Set)(c : Comp A) P ls t a t1,
  dat_correct_h (Repeat c P) ls depth t ->
  well_formed_comp c ->
  In a (filter P (getSupport c)) ->
  (forall a' n' ls', 
    evalDet_steps (cs_more c (firstn n' ls)) (cs_done a' ls') -> 
    ls' = nil)  -> 
  dat_correct_h c ls depth t1 ->  
  repeats >= depth ->
  datRepeat_depth (dat_correct_h c nil) P repeats depth t1 t.

Lemma dat_correct_repeat_same:
  forall n (A : Set) (t : DistApproxTree A) (c : Comp A) (P : A -> bool),
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  dat_correct (Repeat c P) n t -> 
  dat_correct_repeat c P n t.

Lemma datRepeat_depth_better: forall (n2 : nat) (A : Set) (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),
  datRepeat_depth rel P reps depth t1 t1' ->
  forall n1 (t2' : DistApproxTree A),
    reps >= n2 ->
    datRepeat (rel n1) P n2 t2 t2' ->
    dat_better t1 t2 ->
    depth >= n1 * n2 + datDepth t2 -> 
    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),
      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->
    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->
    (forall n t, rel n t -> datDepth t <= n)%nat ->
    dat_better t1' t2'.

Lemma dat_better_repeat_sqrt : forall (A : Set) (c : Comp A)(P : A -> bool)(n : nat) (t1 t2 : DistApproxTree A),
  (exists a, In a (filter P (getSupport c))) ->
  dat_correct_repeat c P n t1 ->
  dat_correct_repeat2 c P (Nat.sqrt (div2 n)) t2 -> 

Lemma lowDistApprox_repeat_sqrt_le : forall n (A : Set)(c : Comp A)(P : A -> bool) a v1 v2,
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  lowDistApprox (Repeat c P) a n v1 ->
  lowDistApprox_repeat c P a (Nat.sqrt (div2 n)) v2 -> 

Lemma datRepeat_better_depth: forall (A : Set) n2 (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),
  forall n1 (t2' : DistApproxTree A),
    datRepeat (rel n1) P n2 t2 t2' ->
    datRepeat_depth rel P reps depth t1 t1' ->
    dat_better t2 t1 ->
    n1 >= depth ->
    n2 >= reps ->  
    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),
      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->
    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->
    (forall n t, rel n t -> datDepth t <= n)%nat ->
    dat_better t2' t1'.

Lemma dat_repeat_better:
  forall (A : Set) n (c : Comp A) (P : A -> bool)
    (t1 t2 : DistApproxTree A),
    (exists a : A, In a (filter P (getSupport c))) ->
    dat_correct_repeat c P n t1 ->
    dat_correct_repeat2 c P n t2 -> 
    dat_better t2 t1.

Lemma lowDistApprox_le_repeat:
  forall (n : nat) (A : Set) (c : Comp A) (P : A -> bool)(a : A) (v1 v2 : Rat),
    well_formed_comp c ->
    (exists a0 : A, In a0 (filter P (getSupport c))) ->
    lowDistApprox (Repeat c P) a n v1 ->
    lowDistApprox_repeat c P a n v2 -> 
    n > O ->
    v1 <= v2.

Lemma lowDistApprox_Rnd_lt : forall n1 n2 a r,
  lowDistApprox (Rnd n1) a n2 r ->
  n2 < n1 ->
  r == 0.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_step c nil = (cs_done a s) ->
  getSupport c = a :: nil.

Lemma lowDistApprox_low : forall (A : Set)(c : Comp A),
  well_formed_comp c -> 
  forall n a r, 
  lowDistApprox c a n r ->
  r <= evalDist c a.

Lemma lowDistApprox_repeat_scale_limit : forall (A : Set)(c : Comp A)(P : A -> bool),
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) -> 
  rat_inf_limit
     (fun n : nat =>
      sumList_rel
        (fun i : nat =>
         expRat_rel
           (sumList_rel (fun a0 : A => lowDistApprox c a0 n)
              (filter (fun a0 : A => negb (P a0)) (getSupport c))) i)
        (getNats O n))
     (ratInverse (sumList (filter P (getSupport c)) (evalDist c))).

Lemma lowDistApprox_repeat_limit : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  (exists b, In b (filter P (getSupport c))) ->
  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) ->
  rat_inf_limit (lowDistApprox_repeat c P a) (evalDist (Repeat c P) a).

Lemma lowDistApprox_limit_repeat : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  (forall a', rat_inf_limit (lowDistApprox c a') (evalDist c a')) ->
  rat_inf_limit (lowDistApprox (Repeat c P) a) (evalDist (Repeat c P) a).

Theorem evalDet_evalDist_equiv : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a).

Lemma evalDet_equiv_impl_lowDistApprox_equiv : 
  forall (A : Set)(c1 c2 : Comp A), 
    evalDet_equiv c1 c2 ->
    forall a n r,
      lowDistApprox c1 a n r <-> lowDistApprox c2 a n r.

Theorem det_eq_impl_dist_sem_eq : forall (A : Set)(c1 c2 : Comp A),
  well_formed_comp c1 ->
  well_formed_comp c2 -> 
  evalDet_equiv c1 c2 -> 
  dist_sem_eq c1 c2.

Print Assumptions det_eq_impl_dist_sem_eq. *)

Require Import FCF.DetSem.
(* FCF.DetSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Import FCF.Blist.
Require Import FCF.Fold.
Require Import Permutation.
Require Import Omega.

Local Open Scope list_scope. 
Local Open Scope comp_scope.

Inductive comp_state(A : Set) :=
  | cs_done : A -> Blist -> comp_state A
  | cs_eof : comp_state A
  | cs_more : Comp A -> Blist -> comp_state A.

Inductive comp_answer(A : Set) :=
  | ca_done : A -> comp_answer A
  | ca_eof : comp_answer A.

Lemma comp_answer_eq_dec : forall (A : Set),
      eq_dec A ->
      eq_dec (comp_answer A).

Fixpoint evalDet_step(A : Set)(c : Comp A)(s : Blist) : comp_state A :=
  match c in Comp A return comp_state A with
    | Ret pf a => cs_done a s
    | Rnd n  => 
      match (shiftOut s n) with
        | Some (v, s') => cs_more (Ret (@Bvector_eq_dec n) v) s'
        | None => (@cs_eof (Bvector n))
      end
    | Bind c1 c2 =>     
      match (evalDet_step c1 s) with
        | cs_eof _ => (@cs_eof _)
        | cs_done b s' => cs_more (c2 b) s'
        | cs_more c1' s' => cs_more (Bind c1' c2) s'
      end
    | Repeat c P =>
      cs_more (Bind c (fun a => if (P a) then (Ret (comp_eq_dec c) a) else (Repeat c P))) s
   end.

Inductive evalDet_steps(A : Set) : comp_state A -> comp_state A -> Prop :=
  | evalDet_steps_refl : forall ans,
    evalDet_steps ans ans
  | evalDet_steps_step : 
    forall c s ans ans',
      (evalDet_step c s) = ans ->
      evalDet_steps ans ans' ->
      evalDet_steps (cs_more c s) ans'.

Hint Constructors evalDet_steps : evalDet.

Inductive evalDet(A : Set)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_done : forall a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    evalDet c s (ca_done a)
  | evalDet_eof :
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet c s (@ca_eof A).
    
Theorem evalDet_steps_trans : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall z, 
  evalDet_steps y z ->
  evalDet_steps x z.

Theorem evalDet_steps_bind_more_h : forall(A B : Set) x y,
  evalDet_steps x y ->
  forall (c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  x = (cs_more c1 s) ->
  y =  (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Theorem evalDet_steps_bind_more : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  evalDet_steps (cs_more c1 s) (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Lemma evalDet_steps_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a : A) s s',
  x = (cs_more c s) -> 
  y = (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_done_inv : forall (A : Set)(c : Comp A)(a : A) s s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s,
  x = (cs_more c s) -> 
  y = (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Lemma evalDet_steps_eof_inv : forall (A : Set)(c : Comp A) s,
  evalDet_steps (cs_more c s) (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Theorem evalDet_steps_bind_done : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a s s',
  evalDet_steps (cs_more c1 s) (cs_done a s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (c2 a) s').

Theorem evalDet_bind_eof : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more c1 s) (@cs_eof B) ->
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A).

Inductive comp_state_eq(A : Set) : comp_state A -> comp_state A -> Prop :=
  | cse_done : 
    forall a s, 
      comp_state_eq (cs_done a s) (cs_done a s)
  | cse_eof : 
    comp_state_eq (@cs_eof A) (@cs_eof A)
  | cse_more : 
    forall c1 c2 s,
      Comp_eq c1 c2 ->
      comp_state_eq (cs_more c1 s) (cs_more c2 s).

Theorem comp_state_eq_refl : forall (A : Set)(c : comp_state A),
  comp_state_eq c c.

Lemma evalDet_steps_done_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a a' s s',
  y1 = (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Theorem evalDet_steps_done_func : forall (A : Set) x (a a' : A) s s',
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Lemma evalDet_steps_done_eof_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a s,
  y1 = (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_steps_done_eof_func : forall (A : Set) x (a : A) s,
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_func : forall (A : Set)(c : Comp A)(s : Blist)(y1 y2 : comp_answer A),
  evalDet c s y1 ->
  evalDet c s y2 ->
  y1 = y2.

Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) :=
  (forall s y, evalDet c1 s y <-> evalDet c2 s y).

Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A),
  evalDet_equiv c1 c2 ->
  evalDet_equiv c2 c1.

Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
    x = (cs_more (Bind c1 c2) s) ->
    y = (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_eof_inv_h : 
  forall (A : Set)(x y : comp_state A),
    evalDet_steps x y ->
    forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
      x = (cs_more (Bind c1 c2) s) ->
      y = (@cs_eof A) ->
      evalDet_steps (cs_more c1 s) (@cs_eof B) \/
      exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
        evalDet_steps (cs_more (c2 b) s') (@cs_eof A).
  
Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) ->
  evalDet_steps (cs_more c1 s) (@cs_eof B) \/
  exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
    evalDet_steps (cs_more (c2 b) s') (@cs_eof A).

Theorem evalDet_bind_assoc : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),
  evalDet_equiv (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).

Theorem evalDet_done_eof_func:
  forall (A : Set) (c : Comp A) (a : A) (s : Blist),
    evalDet c s (ca_done a) -> evalDet c s (@ca_eof A) -> False.

Lemma getSupport_In_evalDet_step_done : forall (A : Set)(c : Comp A) a s s',
  evalDet_step c s = cs_done a s' ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_step_more : forall (A : Set)(c c' : Comp A) s s' a,
  evalDet_step c s = cs_more c' s' ->
  In a (getSupport c') ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_steps_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a s s',
    x = (cs_more c s)  ->
    y = (cs_done a s') -> 
    In a (getSupport c).

Lemma getSupport_In_evalDet_steps : forall (A : Set)(c : Comp A) a s s',
  evalDet_steps (cs_more c s) (cs_done a s') -> 
  In a (getSupport c).

Theorem getSupport_In_evalDet : forall (A : Set)(c : Comp A) a s,
  evalDet c s (ca_done a) -> 
  In a (getSupport c).

Inductive evalDet_repeat_steps (A : Set)(P : A -> bool) : comp_state A -> comp_state A -> Prop :=
| evalDet_repeat_steps_done : 
  forall c s a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = true ->
    evalDet_repeat_steps P (cs_more c s) (cs_done a s')
| evalDet_repeat_steps_eof :
  forall c s,
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A)
| evalDet_repeat_steps_step :
  forall c s a s' y,
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = false ->
    evalDet_repeat_steps P (cs_more c s') y ->
    evalDet_repeat_steps P (cs_more c s) y.

Inductive evalDet_repeat(A : Set)(P : A -> bool)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_repeat_done : forall a s',
    evalDet_repeat_steps P (cs_more c s) (cs_done a s') ->
    evalDet_repeat P c s (ca_done a)
  | evalDet_repeat_eof :
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A) ->
    evalDet_repeat P c s (@ca_eof A).

Lemma list_skipn_strong_ind_h : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  (forall n, P (skipn n l)).

Lemma list_skipn_strong_ind : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  P l.

Lemma evalDet_step_nil_inv : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_step c nil = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_step c nil = (cs_done a ls) ->
  ls = nil.

Lemma evalDet_step_more_nil_inv : forall (A : Set)(c c' : Comp A) ls,
  evalDet_step c nil = (cs_more c' ls) ->
  ls = nil.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) s a,
  evalDet_step c s = cs_done a s ->
  getSupport c = (a :: nil).

Lemma getUnique_NoDup_eq : forall (A : Set)(eqd : eq_dec A)(ls : list A),
  NoDup ls ->
  getUnique ls eqd = ls.

Lemma getUnique_Permutation : forall (A : Set)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  Permutation (getUnique ls1 eqd1) (getUnique ls2 eqd2).

Lemma flatten_Permutation : forall (A : Type)(ls1 ls2 : list (list A)),
  Permutation ls1 ls2 ->
  Permutation (flatten ls1) (flatten ls2).

Lemma to_list_nil_inv : forall (A : Type)(n : nat)(v : Vector.t A n),

Lemma app_second_eq :
  forall (A : Type) (ls2 ls1 ls3 : list A),
    ls1 = ls2 ++ ls3 -> length ls1 = length ls3 -> ls1 = ls3 /\ ls2 = nil.

Lemma shiftOut_same_inv : forall s n v,
  shiftOut s n = Some (v, s) ->
  n = O.

Lemma filter_Permutation : forall (A : Set)(ls1 ls2 : list A)(P : A -> bool),
  Permutation ls1 ls2 ->
  Permutation (filter P ls1) (filter P ls2).

Lemma evalDet_step_more_support_preserved : forall (A : Set)(c c' : Comp A) s,
  evalDet_step c s = (cs_more c' s) ->
  Permutation (getSupport c) (getSupport c').

Lemma evalDet_steps_nil_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a1 a2 : A) s2,
  x = (cs_more c nil) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_steps_nil_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_steps (cs_more c nil) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_val_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_ls_eq : forall (A : Set)(c : Comp A)(a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  s1 = s2.

Lemma shiftOut_skipn : forall n (v : Bvector n) s s',
  shiftOut s n = Some (v, s') ->
  s' = skipn n s.

Lemma evalDet_step_more_skipn_eq : forall (A : Set)(c c' : Comp A)(a1 : A) s1 s2,
  evalDet_step c s1 = (cs_more c' s2) ->
  In a1 (getSupport c) ->
  (s1 = s2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_step_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_step  c s = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma skipn_sum : forall (A : Type)(n2 n1 : nat)(ls : list A),
  skipn n1 (skipn n2 ls) = skipn (n2 + n1) ls.

Lemma evalDet_step_more_skipn : forall (A : Set)(c c' : Comp A) s s',
  evalDet_step  c s = (cs_more c' s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s a s', 
    x = (cs_more c s) ->
    y = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_skipn_h : forall (A : Set) a1 (x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a2 : A) s1 s2,
  x = (cs_more c s1) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_steps_skipn : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_steps (cs_more c s1) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_repeat_steps_dec : forall (s : Blist)(A : Set)(c : Comp A)(P : A -> bool),
  (exists a, In a (getSupport c) /\ P a = true) ->
  (forall s', (exists a s'', evalDet_steps (cs_more c s') (cs_done a s'')) \/ evalDet_steps (cs_more c s') (@cs_eof A)) ->
  exists y, evalDet_repeat_steps P (cs_more c s) y.

Lemma evalDet_repeat_steps_done_inv_h : forall (A : Set)(P : A -> bool) x y,
  evalDet_repeat_steps P x y ->
  forall c s,
  x = (cs_more c s) -> 
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_done_inv : forall (A : Set)(c : Comp A)(P : A -> bool) s y,
  evalDet_repeat_steps P (cs_more c s) y ->
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_more_inv_h : forall (A : Set)(x y : comp_state A) P,
  evalDet_repeat_steps P x y ->
  forall (c: Comp A)(P : A -> bool) s,
  y = (cs_more c s) ->
  False.

Lemma evalDet_repeat_steps_more_inv : forall (A : Set) x (c : Comp A)(P : A -> bool) s,
  evalDet_repeat_steps P x (cs_more c s) ->
  False.

Lemma evalDet_steps_dec : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall s, 
  (exists a s', evalDet_steps (cs_more c s) (cs_done a s')) \/ 
  (evalDet_steps (cs_more c s) (@cs_eof A)).

Lemma evalDet_dec : forall (A : Set)(c : Comp A)(s : Blist),
  well_formed_comp c ->
  (exists a, evalDet c s (ca_done a)) \/ (evalDet c s (@ca_eof A)).

Lemma evalDet_step_app_done_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_step c s = (cs_done a s'') ->
  evalDet_step c (s ++ s') = (cs_done a (s'' ++ s')).

Lemma evalDet_step_app_more_eq : forall (A : Set)(c c': Comp A) s s' s'',
  evalDet_step c s = (cs_more c' s'') ->
  evalDet_step c (s ++ s') = (cs_more c' (s'' ++ s')).

Lemma evalDet_steps_app_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s s' s'' a,
    x = (cs_more c s) ->
    y = (cs_done a s'') ->
    evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_steps_app_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_steps (cs_more c s) (cs_done a s'') ->
  evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_app_eq : forall (A : Set)(c : Comp A) s s' a,
  evalDet c s (ca_done a) ->
  evalDet c (s ++ s') (ca_done a).

Lemma evalDet_steps_done_nil_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls,
    x = (cs_more c nil) ->
    y = (cs_done a ls) ->
    ls = nil.

Lemma evalDet_steps_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma app_eq_nil_inv : forall (A : Set)(ls2 ls1 ls3 : list A),
  ls1 = ls2 ++ ls3 ->
  length ls1 = length ls2 ->
  ls3 = nil.

Lemma evalDet_steps_repeat_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s a s',
  evalDet_steps x (cs_more (Repeat c P) s) ->
  y = (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_done_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s a s',
  evalDet_steps (cs_more (Repeat c P) s) (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s,
    evalDet_steps x (cs_more (Repeat c P) s) ->
    y = (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_steps_repeat_eof_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s,
  evalDet_steps (cs_more (Repeat c P) s) (cs_eof A)->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_repeat_steps_nil_inv_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall (P : A -> bool) c a ls',
  x = (cs_more c nil) ->
  y = (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_nil_inv : forall (A : Set)(P : A -> bool) c a ls',
  evalDet_repeat_steps P (cs_more c nil) (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_app_nil_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall c ls1 ls2 b a,
    x = (cs_more c ls1) ->
    y = (cs_eof A) ->
    evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2)->
    (forall s s' b a,
      evalDet_steps (cs_more c s) (cs_eof A) ->
      evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
      s' = nil) ->
    ls2 = nil.

Lemma evalDet_repeat_steps_app_nil : forall (A : Set)(c : Comp A) P ls1 ls2 b a,
  evalDet_repeat_steps P (cs_more c ls1) (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  (forall s s' b a,
    evalDet_steps (cs_more c s) (cs_eof A) ->
    evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
    s' = nil) ->
  ls2 = nil.

Lemma evalDet_app_nil : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall ls1 ls2 b a,
  evalDet c ls1 (ca_eof A) ->
  evalDet_steps (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  ls2 = nil.

Lemma evalDet_step_done_inv : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_step c ls = cs_done a ls' ->
  exists eqd, 
    c = Ret eqd a.

Lemma evalDet_step_more_sublist : forall (A : Set)(c : Comp A) c' ls ls',
  evalDet_step c ls = (cs_more c' ls') ->
  exists ls'', ls = ls'' ++ ls'.
    
Lemma evalDet_sublist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls ls' ,
    x = (cs_more c ls) ->
    y = (cs_done a ls') ->
    exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_sublist : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_steps (cs_more c ls) (cs_done a ls') ->
  exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_nil : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma evalDet_left_total : forall (A : Set)(c : Comp A) s,
  well_formed_comp c ->
  exists ans, evalDet c s ans.
  
Lemma evalDet_steps_done_support_singleton_h : forall (A : Set)(x1 x2 : comp_state A),
  evalDet_steps x1 x2 ->
  forall (c : Comp A) a s,
    x1 = (cs_more c nil) ->
    x2 = (cs_done a s) ->
    getSupport c = a :: nil.

Lemma evalDet_steps_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  getSupport c = a :: nil.

Lemma evalDet_step_well_formed_comp_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' s s',
    evalDet_step c s = (cs_more c' s') ->
    well_formed_comp c'. *)



Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=

  match n with

          | 0 =>

            fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)

          | S n' =>

            fun (v : Vector.t A (S n' + m)) =>

              let (v1, v2) := splitVector _ _ (Vector.tl v) in

                (Vector.cons _ (Vector.hd v) _ v1, v2)

    end.



Theorem splitVector_append :

  forall (A : Set) n1 (v1 : Vector.t A n1) n2 (v2 : Vector.t A n2),

    splitVector n1 n2 (Vector.append v1 v2) = (v1, v2).



  induction v1; intuition; simpl in *.

  remember ( splitVector n n2 (Vector.append v1 v2)) as z.

  destruct z.

  rewrite IHv1 in Heqz.

  inversion Heqz; subst.

  trivial.

Qed.



Theorem append_splitVector_h :

  forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)),

   (Vector.append (fst (splitVector n1 n2 x)) (snd (splitVector n1 n2 x))) = x.



  induction n1; intuition; simpl in *.

  destruct (vector_S x).

  destruct H.

  subst.

  simpl.

  remember (splitVector n1 n2 x1) as z.

  destruct z.

  simpl.

  f_equal.

  specialize (IHn1 n2 x1).

  rewrite <- Heqz in IHn1.

  simpl in *.

  trivial.



Qed.



Theorem append_splitVector:

  forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)) x1 x2,

    (x1, x2) = (splitVector n1 n2 x) ->

   (Vector.append x1 x2) = x.



  intuition.

  specialize (append_splitVector_h _ _ x); intuition.

  rewrite <- H in H0.

  simpl in *.

  trivial.



Qed.



Theorem shiftOut_plus :

  forall (n1 n2 : nat) s b s',

    shiftOut s (n1 + n2) = Some (b, s') ->

    exists b1 b2 s'',

      shiftOut s n1 = Some (b1, s'') /\

      shiftOut s'' n2 = Some (b2, s') /\

      splitVector n1 n2 b = (b1, b2).



  induction n1; intuition; simpl in *.

  rewrite shiftOut_0.

  econstructor.

  econstructor.

  econstructor.

  intuition.

  trivial.



  destruct s; simpl in *.

  discriminate.

  case_eq (shiftOut s (n1 + n2)); intuition.

  rewrite H0 in H.

  destruct p.

  inversion H; clear H; subst.

  edestruct IHn1.

  eauto.

  destruct H.

  destruct H.

  intuition.

  rewrite H1.

  econstructor.

  econstructor.

  econstructor.

  intuition.

  eauto.

  simpl.

  rewrite H3.

  trivial.



  rewrite H0 in H.

  discriminate.



Qed.



Theorem shiftOut_plus_None :

  forall n1 n2 s,

    shiftOut s (n1 + n2) = None ->

    shiftOut s n1 = None \/

    (exists x s', shiftOut s n1 = Some (x, s') /\

      shiftOut s' n2 = None).



  induction n1; intuition; simpl in *.

  rewrite shiftOut_0.

  right.

  econstructor.

  econstructor.

  intuition.



  destruct s; simpl in *.

  intuition.



  case_eq (shiftOut s (n1 + n2)); intuition.

  rewrite H0 in H.

  destruct p.

  discriminate.

  edestruct IHn1.

  eauto.

  rewrite H1.

  intuition.



  destruct H1.

  destruct H1.

  intuition.



  rewrite H2.

  right.



  econstructor.

  econstructor.

  intuition.

Qed.



Theorem Vector_cons_app_assoc :

  forall (A : Type)(a : A)(n1 n2 : nat)(v1 : Vector.t A n1)(v2 : Vector.t A n2),

    Vector.cons _ a _ (Vector.append v1 v2) =

    Vector.append (Vector.cons _ a _ v1) v2.



  induction n1; intuition; simpl in *.



Qed.



Theorem shiftOut_plus_if :

  forall n1 n2 s s' s'' b1 b2,

    shiftOut s n1 = Some (b1, s') ->

    shiftOut s' n2 = Some (b2, s'') ->

    shiftOut s (n1 + n2) = Some (Vector.append b1 b2, s'').



  induction n1; intuition; simpl in *.

  rewrite shiftOut_0 in H.

  inversion H; clear H; subst.

  simpl in *.

  trivial.



  destruct s; simpl in *.

  discriminate.

  case_eq (shiftOut s n1); intuition.

  rewrite H1 in H.

  destruct p.

  inversion H; clear H; subst.

  erewrite IHn1; eauto.



  rewrite Vector_cons_app_assoc.

  trivial.



  rewrite H1 in H.

  discriminate.

Qed.



Theorem shiftOut_plus_None_if :

  forall n1 n2 s,

    (shiftOut s n1 = None \/

      (exists b s', shiftOut s n1 = Some (b, s') /\

        shiftOut s' n2 = None)) ->

    shiftOut s (n1 + n2) = None.



  induction n1; intuition; simpl in *.

  rewrite shiftOut_0 in H0.

  discriminate.

  destruct H0.

  destruct H.

  intuition.

  rewrite shiftOut_0 in H0.

  inversion H0; clear H0; subst.

  trivial.



  destruct s; simpl in *.

  trivial.



  case_eq (shiftOut s n1); intuition.

  rewrite H in H0.

  destruct p.

  discriminate.



  rewrite H in H0.

  erewrite IHn1.

  trivial.

  intuition.



  destruct H0.

  destruct H.

  intuition.

  destruct s; simpl in *.

  discriminate.



  case_eq (shiftOut s n1); intuition.

  rewrite H in H0.

  destruct p.

  inversion H0; clear H0; subst.

  erewrite IHn1.

  trivial.

  right.

  econstructor.

  econstructor.

  intuition.

  eauto.

  trivial.



  rewrite H in H0.

  discriminate.



Qed.



Theorem Rnd_split_equiv :

  forall n1 n2 z ,

    evalDist

    (x <-$ {0, 1}^(n1 + n2);

      ret (splitVector n1 n2 x)) z ==

    evalDist

    (x1 <-$ {0, 1}^n1;

      x2 <-$ {0, 1}^n2;

      ret (x1, x2)) z.



  intuition.



  eapply det_eq_impl_dist_sem_eq; wftac.

  unfold evalDet_equiv.

  intuition.

  inversion H; clear H; subst.

  inversion H0; clear H0; subst.

  simpl in *.

  case_eq (shiftOut s (plus n1 n2)); intuition.

  destruct p.

  specialize (shiftOut_plus _ _ _ H); intuition.

  destruct H0.

  destruct H0.

  destruct H0.

  intuition.



  rewrite H in H4.

  inversion H4; clear H4; subst.

  simpl in *.

  inversion H8; clear H8; subst.

  simpl in *.

  inversion H7; clear H7; subst.

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H1.

  econstructor.

  eauto.

  simpl.

  econstructor.

  eauto.

  simpl.

  rewrite H0.

  econstructor.

  eauto.

  simpl.

  econstructor.

  eauto.

  rewrite H3.

  econstructor.



  rewrite H in H4.

  inversion H4; clear H4; subst.



  inversion H0; clear H0; subst.

  simpl in *.

  case_eq (shiftOut s (n1 + n2)); intuition.

  rewrite H in H4.

  destruct p.

  inversion H4; clear H4; subst.

  simpl in *.

  inversion H5; clear H5; subst.

  simpl in *.

  inversion H4.



  specialize (shiftOut_plus_None _ _ _ H); intuition.

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H1.

  econstructor.

  destruct H1.

  destruct H0.

  intuition.

  econstructor.

  econstructor.

  eauto.

  simpl.

  rewrite H1.

  econstructor.

  eauto.

  simpl.

  econstructor.

  eauto.

  simpl.

  rewrite H2.

  econstructor.



  inversion H; clear H; subst.

  inversion H0; clear H0; subst.

  simpl in *.

  case_eq (shiftOut s n1); intuition.

  rewrite H in H4.

  destruct p.

  inversion H4; clear H4; subst.

  inversion H5; clear H5; subst.

  simpl in *.

  case_eq (shiftOut b1 n2); intuition.

  rewrite H0 in H4.

  destruct p.

  inversion H4; clear H4; subst.

  simpl in *.

  inversion H6; clear H6; subst.

  simpl in *.

  inversion H5; clear H5; subst.

  econstructor.

  econstructor.

  eauto.

  simpl.



  erewrite shiftOut_plus_if; eauto.

  econstructor.

  eauto.

  simpl.

  econstructor.

  eauto.

  simpl.



  rewrite splitVector_append.

  econstructor.



  rewrite H0 in H4.

  inversion H4; clear H4; subst.

  rewrite H in H4.

  inversion H4.



  inversion H0; clear H0; subst.

  simpl in *.

  case_eq (shiftOut s n1); intuition.

  rewrite H in H4.

  destruct p.

  inversion H4; clear H4; subst.

  simpl in *.

  inversion H5; clear H5; subst.

  simpl in *.

  case_eq (shiftOut b1 n2); intuition.

  rewrite H0 in H4.

  destruct p.

  inversion H4; clear H4; subst.

  simpl in *.

  inversion H6; clear H6; subst.

  simpl in *.

  inversion H5.



  econstructor.

  econstructor.

  eauto.

  simpl.



  erewrite shiftOut_plus_None_if.

  econstructor.

  right.

  econstructor.

  econstructor.

  intuition.

  eauto.

  trivial.



  rewrite H in H4.

  econstructor.

  econstructor.

  eauto.

  simpl.

  erewrite shiftOut_plus_None_if.

  econstructor.



  intuition.

Qed.
