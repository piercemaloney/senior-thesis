Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)

Require Import VST.msl.sepalg.
(* VST.msl.sepalg:
Require Import VST.msl.Extensionality.

Set Implicit Arguments.

Class Join (t: Type) : Type := join: t -> t -> t -> Prop.

Class Perm_alg (t: Type) {J: Join t} : Type :=
  mkPerm   {
   join_eq: forall {x y z z'}, join x y z -> join x y z' -> z = z';
   join_assoc: forall {a b c d e}, join a b d -> join d c e ->
                    {f : t & join b c f /\ join a f e};
   join_comm: forall {a b c}, join a b c -> join b a c;
   join_positivity: forall {a a' b b'}, join a a' b -> join b b' a -> a=b
}.
Arguments Perm_alg _ [J].

Definition unit_for {t}{J: Join t} (e a: t) := join e a a.
Definition identity {t} {J: Join t} (e: t) := forall a b, join e a b -> a=b.

Hint Extern 2 (@join _ _ _ _ _) =>
   (eapply join_comm; trivial;
     try eassumption;
          match goal with H: @join _ _ _ _ _ |- _ => apply H end).
 
Hint Unfold unit_for.

Lemma join_assoc_uniq:
  forall {t} {J: Join t} (PA1 PA2: @Perm_alg t J),
      forall a b c d e H H',
         (projT1 (@join_assoc _ _ PA1  a b c d e H H'))
        = (projT1 (@join_assoc _ _ PA2  a b c d e H H')).

  Class Sep_alg A {J: Join A} : Type :=
    mkSep {
      core: A -> A;
      core_unit: forall t, unit_for (core t) t;
      join_core: forall {a b c}, join a b c -> core a = core c
    }.
Arguments Sep_alg _ [J].

Lemma core_duplicable {A}{J: Join A}{SA: Sep_alg A}:
  forall a, join (core a) (core a) (core a).

Lemma core_self_join {A}{J: Join A}{SA: Sep_alg A}:
  forall a, a = core a -> join a a a.

Lemma core_idem {A}{J: Join A}{SA: Sep_alg A}:
  forall a, core (core a) = core a.

Lemma core_hom {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall {a b c}, join a b c -> join (core a) (core b) (core c).

Lemma split_core' {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> a = core a.

Lemma split_core{A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b (core c) -> unit_for a a.

Lemma core_uniq {t} {J: Join t}{PA: Perm_alg t}:
   forall (SA1: @Sep_alg _ J)
          (SA2: @Sep_alg _ J),
     forall x, @core _ _ SA1 x = @core _ _ SA2 x.

Lemma join_core2 {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a b c, join a b c -> core a = core b.

Class Disj_alg  (t: Type) {J: Join t} :=
   join_self: forall {a b}, join a a b -> identity a.
Arguments Disj_alg _ [J].

Lemma join_self' {A}{J: Join A}{DA: Disj_alg A} :
  forall {a b}, join a a b -> a = b.

Lemma   unit_identity {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
        forall {e} b, unit_for e b -> identity e.

Lemma core_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity (core a).

Lemma join_ex_identity  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
     forall a, {e : A & prod (identity e) (unit_for e a) }.

Lemma identity_core  {A}{J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall a, identity a -> a = core a.

Class Sing_alg A {J: Join A}{SA: Sep_alg A} :=
    mkSing {
      the_unit: A;
      the_unit_core: forall a, core a = the_unit
    }.
Arguments Sing_alg _ [J] [SA].
Arguments mkSing [A] [J] [SA] _ _.

  Class Pos_alg  {A} {J: Join A} :=
    no_units: forall e a, ~unit_for e a.
Arguments Pos_alg _ [J].

Class Cross_alg (t: Type)  `{J: Join t} :=
   cross_split :
      forall a b c d z : t,
       join a b z ->
       join c d z ->
    { x:(t*t*t*t) &  match x with (ac,ad,bc,bd) =>
         join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d
       end
    }.
Arguments Cross_alg _ [J].

Class Trip_alg {A} {J: Join A} :=
  triple_join_exists:
  forall (a b c ab bc ac : A), join a b ab -> join b c bc -> join a c ac ->
       {abc | join ab c abc}.
Arguments Trip_alg _ [J].

Lemma  join_ex_units{A}{J: Join A}{SA: Sep_alg A}:
    forall a, {e : A & unit_for e a }.

Lemma same_identity {A}{J: Join A}{PA: Perm_alg A}:
  forall e e' a, identity e -> unit_for e a -> identity e' -> unit_for e' a -> e = e'.

Lemma same_unit {A}{J: Join A}{PA: Perm_alg A}{SA:Sep_alg A}{CA: Disj_alg A}:
       forall {e1 e2 a}, unit_for e1 a -> unit_for e2 a -> e1 = e2.

  Definition joins {A} {J: Join A} (a b : A) : Prop :=
    exists c, join a b c.

  Definition overlap {A}{J: Join A} (a b: A) := ~(joins a b).

  Lemma join_joins {A} {J: Join A}: forall {a b c},
    join a b c -> joins a b.

  Lemma join_joins' {A} {J: Join A} {PA: Perm_alg A}: forall {a b c},
    join a b c -> joins b a.

  Lemma joins_sym {A}  {J: Join A} {PA: Perm_alg A}: forall a b,
    joins a b <-> joins b a.

  Lemma joins_sym': forall {A} `{Perm_alg A} {phi1 phi2}, joins phi1 phi2 -> joins phi2 phi1.

  Definition join_sub {A} `{Join A} (a c : A) : Prop :=
    exists b, join a b c.

  Lemma join_join_sub {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub a c.

  Lemma join_join_sub' {A} `{Perm_alg A}: forall {a b c},
    join a b c ->
    join_sub b c.

  Lemma join_sub_refl {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    join_sub a a.

  Hint Resolve @join_sub_refl.

  Lemma join_sub_trans {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    join_sub a b ->
    join_sub b c ->
    join_sub a c.

  Lemma join_sub_unit_for {A} {J: Join A}{PA: Perm_alg A}:
    forall e a b, unit_for e a -> join_sub a b -> unit_for e b.

Lemma join_sub_same_identity {A} {J: Join A}{PA: Perm_alg A}:
   forall e e' a c,  identity e -> unit_for e a -> identity e' -> unit_for e' c ->
                  join_sub a c -> e = e'.

  Lemma join_sub_joins {A} `{HA: Perm_alg A}: forall {a b},
    join_sub a b -> joins a b -> joins a a.
    Lemma join_sub_joins_trans {A} `{HA: Perm_alg A}: forall {a b c},
    join_sub a c -> joins c b -> joins a b.

  Lemma join_sub_joins'  {A} `{HA: Perm_alg A}:
    forall {a a' b b' : A},
      join_sub a a' -> join_sub b b' -> joins a' b' -> joins a b.

  Definition sub_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c b -> joins c a.

  Definition same_silhouette {A} `{Perm_alg A} (a b: A) : Prop :=
    forall c, joins c a <-> joins c b.

  Lemma sub_silhouette_refl {A} `{Perm_alg A}: forall a, sub_silhouette a a.

  Lemma sub_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    sub_silhouette a b -> sub_silhouette b c -> sub_silhouette a c.

  Lemma same_silhouette_refl {A} `{Perm_alg A}: forall a, same_silhouette a a.

  Lemma same_silhouette_sym {A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> same_silhouette b a.

  Lemma same_silhouette_trans {A} `{Perm_alg A}: forall a b c,
    same_silhouette a b -> same_silhouette b c -> same_silhouette a c.

  Lemma same_silhouette_sub1{A} `{Perm_alg A}: forall a b,
    same_silhouette a b -> sub_silhouette a b.

  Lemma same_silhouette_sub2 {A} `{Perm_alg A}: forall a b,
     same_silhouette a b -> sub_silhouette b a.

  Lemma sub_same_silhouette {A} `{Perm_alg A}:
    forall a b, sub_silhouette a b -> sub_silhouette b a -> same_silhouette a b.

  Lemma same_silhouette_join {A} `{HA: Perm_alg A}:
    forall phi phi' phiy phiz phiz',
      same_silhouette phi phi' ->
      join phi phiy phiz ->
      join phi' phiy phiz' ->
      same_silhouette phiz phiz'.

Hint Resolve @join_joins @join_joins' @join_join_sub @join_join_sub'.

  Definition nonidentity {A} `{Perm_alg A} (a: A) := ~(identity a).

  Lemma join_sub_units_eq {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall {a b} ea eb,
    join_sub a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea = eb.

  Lemma unit_core{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
      forall {a}, unit_for a a -> a = (core a).

  Lemma unit_self_unit {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
   forall a ea,   unit_for ea a ->  unit_for ea ea.

  Lemma joins_units_eq {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
   forall {a b} ea eb,
    joins a b ->
    unit_for ea a ->
    unit_for eb b ->
    ea  = eb.

  Lemma join_ex_identities {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a,
    {e : A & identity e /\ joins e a}.

  Lemma identity_unit {A} `{HA: Perm_alg A}: forall e a,
    identity e ->
    joins e a ->
    unit_for e a.

  Lemma identity_unit' {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
    forall a,  identity a -> unit_for a a.

  Lemma identity_unit_equiv {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
    forall a,  identity a <-> unit_for a a.

  Lemma identities_unique {A} `{HA: Perm_alg A} :
   forall e1 e2,  identity e1 ->  identity e2 ->  joins e1 e2 ->  e1 = e2.

Lemma split_identity{A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
 forall a b c, join a b c -> identity c -> identity a.

  Lemma join_nonidentity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall a b c,
    nonidentity a -> join a b c -> nonidentity c.

  Lemma join_sub_antisym {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x y,
    join_sub x y ->
    join_sub y x ->
    x = y.

  Lemma join_sub_joins_identity {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> joins a b -> identity a.

  Lemma join_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{DS: Disj_alg A}: forall a b,
    join_sub a b -> nonidentity a -> overlap a b.

Definition full {A} {JA: Join A}(sigma : A) : Prop :=
   forall sigma', joins sigma sigma' -> identity sigma'.

Definition maximal {A} {JA: Join A} (sigma : A) : Prop :=
  forall sigma', join_sub sigma sigma' -> sigma = sigma'.

Lemma full_maximal {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} :
       forall a, full a <-> maximal a.

  Definition comparable {A} `{Sep_alg A}  (a b:A)
    := core a = core b.

  Lemma comparable_refl {A} `{Sep_alg A} : forall a, comparable a a.

  Lemma comparable_sym {A} `{Sep_alg A}: forall a b, comparable a b -> comparable b a.

  Lemma comparable_trans {A} `{Sep_alg A}: forall a b c, comparable a b -> comparable b c -> comparable a c.

  Lemma comparable_common_unit {A} `{Sep_alg A}: forall a b,
    comparable a b ->
    exists e, join e a a /\ join e b b.

  Lemma common_unit_comparable {A} `{Sep_alg A} : forall a b,
    (exists e, join e a a /\ join e b b) ->
    comparable a b.

Lemma join_comparable  {A} `{Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi3.

Lemma join_comparable2  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall phi1 phi2 phi3, join phi1 phi2 phi3 -> comparable phi1 phi2.

Lemma join_sub_comparable  {A} `{Sep_alg A} : forall a c,
  join_sub a c -> comparable a c.

Lemma joins_comparable  {A} {J: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : forall a c,
  joins a c -> comparable a c.

Lemma join_unit1 {A} `{Perm_alg A}:
  forall x y z, unit_for x z -> y = z -> join x y z.

Lemma join_unit2 {A} `{Perm_alg A}:
  forall x y z, unit_for y z -> x = z -> join x y z.

Lemma join_unit1_e {A} `{Perm_alg A}:
  forall x y z, identity x -> join x y z -> y = z.

Lemma join_unit2_e {A} `{Perm_alg A}:
  forall x y z, identity y -> join x y z -> x = z.

Lemma PermAlg_ext:
  forall (T: Type) (J: @Join T) (sa1 sa2: @Perm_alg T J), sa1=sa2.

Lemma Sep_alg_ext {T} {J} {PA: @Perm_alg _ J}:
   forall (sa1 sa2: @Sep_alg T J), sa1=sa2.

Definition nonunit {A} `{Join A}  (a: A) := forall x, ~ unit_for a x.

Lemma nonidentity_nonunit {A} {JA: Join A} {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  forall {a}, nonidentity a -> nonunit a.

Lemma nonunit_nonidentity {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:
  forall x, nonunit x -> ~identity x.

Class Canc_alg (t: Type) {J: Join t} :=
    join_canc: forall {a1 a2 b c}, join a1 b c -> join a2 b c -> a1 = a2.
Arguments Canc_alg _ [J]. *)



Require Import Coq.funind.Recdef.

Require Coq.Wellfounded.Wellfounded. 


Delimit Scope pred with pred.

Local Open Scope pred.



Definition pred (A:Type) := A -> Prop.

Bind Scope pred with pred.



Definition derives (A:Type) (P Q:pred A) := forall a:A, P a -> Q a.

Arguments derives [A] _ _.



Lemma pred_ext : forall A (P Q:pred A),

  derives P Q -> derives Q P -> P = Q.

Proof.

  intros.

  extensionality a.

  apply prop_ext; intuition.

Qed.



Lemma derives_cut {A}  : forall Q P R : pred A,

  derives P Q ->

  derives Q R ->

  derives P R.

Proof.

  repeat intro; intuition.

Qed.



Definition prop {A: Type}  (P: Prop) : pred A := (fun _  => P).

Hint Unfold prop.



Definition TT {A}: pred A := prop True.

Definition FF  {A}: pred A := prop False.



Set Implicit Arguments.



Definition imp {A}  (P Q:pred A) :=

   fun a:A => P a -> Q a.

Definition orp {A} (P Q:pred A) :=

   fun a:A => P a \/ Q a.

Definition andp {A} (P Q:pred A) :=

   fun a:A => P a /\ Q a.



Definition allp {A B: Type} (f: B -> pred A) : pred A

  := fun a => forall b, f b a.

Definition exp {A B: Type} (f: B -> pred A) : pred A

  := fun a => exists b, f b a.



Notation "'emp'" := identity.



Definition sepcon {A} {JA: Join A}(p q:pred A) := fun z:A =>

  exists x:A, exists y:A, join x y z /\ p x /\ q y.

Definition wand {A}  {JA: Join A}  (p q:pred A) := fun y =>

  forall x z, join x y z -> p x -> q z.



Notation "P '|--' Q" := (derives P Q) (at level 80, no associativity).

Notation "'EX'  x ':' T ',' P " := (exp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.

Notation "'ALL'  x ':' T  ',' P " := (allp (fun x:T => P%pred)) (at level 65, x at level 99) : pred.

Infix "||" := orp (at level 50, left associativity) : pred.

Infix "&&" := andp (at level 40, left associativity) : pred.

Notation "P '-->' Q" := (imp P Q) (at level 55, right associativity) : pred.

Notation "P '<-->' Q" := (andp (imp P Q) (imp Q P)) (at level 57, no associativity) : pred.

Notation "P '*' Q" := (sepcon P Q) : pred.

Notation "P '-*' Q" := (wand P Q) (at level 60, right associativity) : pred.

Notation "'!!' e" := (prop e) (at level 25) : pred.



Definition precise {A}  {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=

     forall w w1 w2, P w1 -> P w2 -> join_sub w1 w -> join_sub w2 w -> w1=w2.



Definition precise2  {A} {JA: Join A}{PA: Perm_alg A}  (P: pred A) : Prop :=

     forall Q R, P * (Q && R) = (P * Q) && (P * R).



Lemma precise_eq {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:

     precise =

                 fun P : pred A => forall Q R, P * (Q && R) = (P * Q) && (P * R).

Proof.

extensionality P.

unfold precise.

apply prop_ext; split; intros.

extensionality w.

apply prop_ext; split; intros.

destruct H0 as [phi1 [phi2 [? [? [? ?]]]]].

split; exists phi1; exists phi2; auto.

destruct H0 as [[phi1a [phi2a [? [? ?]]]] [phi1b [phi2b [? [? ?]]]]].

specialize (H w _ _ H1 H4).

spec H.

econstructor; eauto.

spec H.

econstructor; eauto.

subst phi1b.

generalize (join_canc (join_comm H0) (join_comm H3)).

intro; subst phi2b.

exists phi1a; exists phi2a; split; auto.

split; auto.

split; auto.

rename w1 into w1a.

rename w2 into w1b.

destruct H2 as [w2a ?].

destruct H3 as [w2b ?].

pose (fa x := x=w2a).

pose (fb x := x=w2b).

assert (((P * fa) && (P * fb)) w).

split; do 2 econstructor; repeat split; eauto.

rewrite <- H in H4.

destruct H4 as [w1 [w2 [? [? [? ?]]]]].

unfold fa,fb in *.

subst.

generalize (join_canc H2 H4); intro.

subst.

eapply join_canc; eauto.

Qed.



Lemma derives_precise {A} {JA: Join A}{PA: Perm_alg A}:

  forall P Q, (P |-- Q) -> precise Q -> precise P.

Proof.

intros; intro; intros; eauto.

Qed.



Lemma prop_true_and:

  forall (P: Prop) A (Q: pred A), P -> (!! P && Q = Q).

Proof.

intros. unfold prop, andp;

extensionality w; apply prop_ext; split; intuition.

Qed.



Lemma prop_andp_e {A}:  forall P Q (w:A), (!! P && Q) w -> P /\ Q w.

Proof.

intuition; destruct H; auto.

Qed.



Lemma prop_andp_i {A}:  forall P Q (w:A), P /\ Q w -> (!! P && Q) w.

Proof.

intuition.

split; auto.

Qed.



Lemma derives_trans {A}:  forall (P Q R: pred A), P |-- Q -> Q |-- R -> P |-- R.

Proof.

firstorder.

Qed.



Lemma and_i {A}: forall (P Q R: pred A),

    P |-- Q -> P |-- R -> P |-- Q && R.

Proof. intuition.

intros w ?.

split; eauto.

Qed.



Lemma andp_derives {A}  :

  forall P Q P' Q': pred A, P |-- P' -> Q |-- Q' -> P && Q |-- P' && Q'.

Proof.

intros.

intros w [? ?]; split; auto.

Qed.



Lemma sepcon_assoc {A} {JA: Join A}{PA: Perm_alg A}:

  forall p q r, (((p * q) * r) = (p * (q * r))).

Proof.

pose proof I.

intros.

extensionality w; apply prop_ext; split; intros.

destruct H0 as [w12 [w3 [? [[w1 [w2 [? [? ?]]]] ?]]]].

destruct (join_assoc H1 H0) as [w23 [? ?]].

exists w1; exists w23; repeat split; auto.

exists w2; exists w3; split; auto.

destruct H0 as [w1 [w23 [? [? [w2 [w3 [? [? ?]]]]]]]].

 destruct (join_assoc (join_comm H2) (join_comm H0)) as [w12 [? ?]].

exists w12; exists w3; repeat split; auto.

exists w1; exists w2; repeat split; auto.

Qed.



Lemma sepcon_comm {A} {JA: Join A}{PA: Perm_alg A}:  forall (P Q: pred A) , P * Q = Q * P.

Proof.

intros.

extensionality w; apply prop_ext; split; intros;

(destruct H as [w1 [w2 [? [? ?]]]]; exists w2; exists w1; split ; [apply join_comm; auto | split; auto]).

Qed.



Lemma sepcon_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall P, (P * emp) = P.

Proof.

intros.

extensionality w; apply prop_ext; split; intros.

destruct H as [w1 [w2 [? [? ?]]]].

generalize (identity_unit (a:=w1) H1); intro.

spec H2.

econstructor; eauto.

unfold unit_for in H2.

generalize (join_eq H (join_comm H2)).

intros; subst; auto.

destruct (join_ex_identities w) as [e [? ?]].

exists w; exists e; repeat split; auto.

apply join_comm.

apply identity_unit; auto.

Qed.



Lemma emp_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

    forall P, (emp*P) = P.

Proof. intros. rewrite sepcon_comm; rewrite sepcon_emp; auto. Qed.



Lemma precise_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

     precise emp.

Proof.

repeat intro.

eapply join_sub_same_identity with (a := w1); eauto.

apply identity_unit'; auto.

eapply join_sub_unit_for; eauto.

apply identity_unit'; auto.

Qed.



Definition exactly {A} (x: A) : pred A := fun w => w=x.



Lemma join_exactly {A} {JA: Join A}{PA: Perm_alg A}:

  forall w1 w2 w3, join w1 w2 w3 -> exactly w1 * exactly w2 = exactly w3.

Proof.

intros.

unfold exactly.

extensionality w.

apply prop_ext; split; intros.

destruct H0 as [? [? [? [? ?]]]].

subst. eapply join_eq; eauto.

subst w3.

exists w1; exists w2; split; auto.

Qed.



Lemma exists_and1 {A: Type} : forall {T: Type} (P: T -> pred A) (Q: pred A),

                   exp P && Q = EX x:T, P x && Q.

Proof.

intros.

extensionality w.

apply prop_ext; split; intros.

destruct H as [[x ?] ?].

exists x; split; auto.

destruct H as [x [? ?]].

split; auto.

exists x; auto.

Qed.



Lemma andp_comm {A: Type}: forall (P Q: pred A), P && Q = Q && P.

Proof.

intros.

extensionality w.

unfold andp;

apply prop_ext; split; intuition.

Qed.



Lemma andp_assoc {A}: forall (P Q R: pred A),

                 ((P && Q) && R = P && (Q && R)).

Proof.

intros.

extensionality w.

unfold andp.

apply prop_ext; intuition.

Qed.



Lemma True_andp_eq {A}:

  forall (P: Prop) (Q: pred A), P -> (!!P && Q)%pred = Q.

intros.

extensionality w; apply prop_ext; split; unfold prop, andp; simpl; intros; intuition.

Qed.



Lemma TT_i  {A} : forall w: A,  TT w.

Proof.

unfold TT, prop; simpl; auto.

Qed.



Hint Resolve @TT_i.



Lemma TT_and {A}: forall (Q: pred A), TT && Q = Q.

intros; unfold andp,  TT, prop; extensionality w.

apply prop_ext; intuition.

Qed.



Lemma andp_TT {A}: forall (P: pred A), P && TT = P.

Proof.

intros.

extensionality w; apply prop_ext; split; intros.

destruct H; auto.

split; auto.

Qed.



Lemma emp_wand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

    forall P, emp -* P = P.

Proof.

intros.

extensionality w; apply prop_ext; split; intros.

destruct (join_ex_identities w) as [e [He [? Hj]]].

eapply H; eauto.

specialize (He _ _ Hj); subst; auto.

intro; intros.

replace z with w; auto.

Qed.



Lemma wand_derives {A} {JA: Join A}{PA: Perm_alg A}:

  forall P P' Q Q',  P' |-- P -> Q |-- Q' -> P -* Q |-- P' -* Q'.

Proof.

intros.

intros w ?.

intro; intros.

eauto.

Qed.



Lemma TT_sepcon_TT {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: TT * TT = TT.

Proof.

intros.

extensionality w; apply prop_ext; split; intros; auto.

destruct (join_ex_units w).

exists x; exists w; split; auto.

Qed.



Definition ewand {A} {JA: Join A} (P Q: pred A) : pred A :=

  fun w => exists w1, exists w2, join w1 w w2 /\ P w1 /\ Q w2.



Lemma emp_ewand {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:  forall P, ewand emp P = P.

Proof.

intros.

extensionality w; apply prop_ext; split; intros.

destruct H as [w1 [w2 [? [? ?]]]].

replace w with w2; auto.

eapply join_eq; eauto.

eapply identity_unit; eauto.

destruct (join_ex_identities w) as [e [He [? Hj]]].

exists e; exists w.

split; auto.

specialize (He _ _ Hj); subst; auto.

Qed.



Lemma exists_sepcon1 {A} {JA: Join A}{PA: Perm_alg A}:

  forall T (P: T ->  pred A) Q,  exp P * Q = exp (fun x => P x * Q).

Proof.

intros.

extensionality w.

apply prop_ext; split; intros.

destruct H as [w1 [w2 [? [[x ?] ?]]]].

exists x; exists w1; exists w2; split; auto.

destruct H as [x [w1 [w2 [? [? ?]]]]].

exists w1; exists w2; split; auto.

split; auto.

exists x; auto.

Qed.



Lemma derives_refl {A: Type}:

  forall (P: pred A), (P |-- P).

Proof. firstorder.

Qed.



Hint Resolve @derives_refl.



Lemma derives_TT {A}: forall (P: pred A), P |-- TT.

Proof.

intros.

intros ? ?; auto.

Qed.

Hint Resolve @derives_TT.



Lemma sepcon_derives {A} {JA: Join A}{PA: Perm_alg A}:

  forall p q p' q', (p |-- p') -> (q |-- q') -> (p * q |-- p' * q').

Proof.

intros.

do 2 intro.

destruct H1 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; repeat split ;auto.

Qed.



Lemma derives_e {A: Type}: forall p q (st: A),

      (p |-- q) -> p st -> q st.

Proof.

auto.

Qed.



Lemma exp_derives {A} :

       forall B (P: B -> pred A) Q , (forall x:B, P x |-- Q x) -> (exp P |-- exp Q).

Proof.

intros.

intros w [b ?].

exists b; eapply H; eauto.

Qed.



Lemma unmodus_wand {A}  {JA: Join A}{PA: Perm_alg A}:

 forall P Q R, Q = P * R ->  Q |-- P * (P -* Q).

Proof.

intros.

subst.

apply sepcon_derives; auto.

intros ?w ?; intro; intros.

exists x; exists w; split; auto.

Qed.



Definition superprecise {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} (P: pred A) :=

   forall w1 w2, P w1 -> P w2 -> comparable w1 w2 -> w1=w2.



Lemma modus_ewand {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} :  forall P Q, superprecise P -> P * (ewand P Q) |-- Q.

Proof.

pose proof I.

intros.

intros w ?.

destruct H1 as [w1 [w2 [? [? ?]]]].

unfold ewand in H3.

destruct H3 as [w1' [w3 [? [? ?]]]].

assert (w1'=w1).

  apply H0; auto.

  apply comparable_trans with w2. eapply join_comparable2; eauto.

  apply comparable_sym.  eapply join_comparable2; eauto.

  subst.

replace w with w3; auto.

eapply join_eq; eauto.

Qed.



Lemma exists_expand_sepcon {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

 forall B (p: B -> pred A) q, (exp p * q)%pred = (exp (fun x => p x * q))%pred.

Proof.

intros; extensionality w; apply prop_ext; split; intros.

destruct H as [? [? [? [? ?]]]].

destruct H0.

exists x1; exists x; exists x0; split; auto.

destruct H as [? [? [? [? [? ?]]]]].

exists x0; exists x1; split; auto.

split; auto.

exists x; auto.

Qed.



Lemma exists_expand_sepcon' {A}  {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

 forall B p (q: B -> pred A), (p * exp q)%pred = (exp (fun x => p * q x))%pred.

Proof.

intros; extensionality w; apply prop_ext; split; intros.

destruct H as [? [? [? [? ?]]]].

destruct H1.

exists x1; exists x; exists x0; split; auto.

destruct H as [? [? [? [? [? ?]]]]].

exists x0; exists x1; split; auto.

split; auto.

exists x; auto.

Qed.



Lemma exists_expand_and {A}  {JA: Join A}:

 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Proof.

intros; extensionality w; apply prop_ext; split; intros.

destruct H.

destruct H.

exists x; split; auto.

destruct H. destruct H.

split; auto.

exists x; auto.

Qed.



Lemma exists_expand_and' {A} {JA: Join A}:

 forall B p (q: B -> pred A), (p && exp q)%pred = (exp (fun x => p && q x))%pred.

Proof.

intros; extensionality w; apply prop_ext; split; intros.

destruct H.

destruct H0.

exists x; split; auto.

destruct H. destruct H.

split; auto.

exists x; auto.

Qed.



Lemma allp_derives_right {A} : forall B p (q: B -> pred A),

  ((p |-- allp q) <-> (forall x, p |-- q x)).

Proof.

intros.

split; intros.

eapply derives_trans; eauto.

intros ? ?. apply H0.

intros ? ? ?.

eapply (H b).

auto.

Qed.



Lemma wand_exists {A} {JA: Join A}{PA: Perm_alg A}:

   forall B P Q,  (EX x: B, P -* Q x) |-- (P -* EX x : B, Q x).

Proof.

pose proof I.

intros.

intros w ?.

destruct H0 as [x ?].

intros ?w ?w ? ?.

specialize ( H0 w0 w1 H1 H2).

exists x; auto.

Qed.



Lemma modus_wand {A} {JA: Join A}{PA: Perm_alg A}:

  forall P Q,  P * (P -* Q) |-- Q.

Proof.

intros.

intros w  [?w [?w [? [? ?]]]].

eapply H1; eauto.

Qed.



Lemma distrib_sepcon_andp {A} {JA: Join A}{PA: Perm_alg A}:

  forall P Q R, P * (Q && R) |-- (P * Q) && (P * R).

Proof.

intros. intros w [w1 [w2 [? [? ?]]]].

destruct H1.

split; exists w1; exists w2; split; auto.

Qed.



Lemma andp_r {A: Type} : forall (P Q R: pred A), P |-- Q -> P |-- R -> P |-- Q && R.

Proof.

intros.

intros w ?; split; auto.

Qed.



Definition list_sepcon {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A} : list (pred A) -> pred A := fold_right sepcon emp.



Lemma sepcon_andp_prop {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R, P * (!!Q && R) = !!Q && (P * R).

Proof.

intros.

extensionality w; apply prop_ext; split; intros.

destruct H as [w1 [w2 [? [? [? ?]]]]].

split. apply H1.

exists w1; exists w2; split; [|split]; auto.

destruct H.

destruct H0 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; repeat split; auto.

Qed.



Require Import VST.msl.cross_split.
(* VST.msl.cross_split:
Require Import VST.msl.base.
Require Import VST.msl.sepalg.
Require Import VST.msl.psepalg.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.cjoins.
Require Import VST.msl.eq_dec.

  Definition sa_distributive (A: Type) {JOIN: Join A} :=
    forall a b x z,
      join a b z ->
      constructive_join_sub x z ->
      {a' : A & {b' : A &
           (constructive_join_sub a' a * constructive_join_sub b' b * join a' b' x)%type}}.

  Theorem cross_split_distibutive {A} `{Perm_alg A}{SA: Sep_alg A}{CS: Cross_alg A} :
          sa_distributive A.

  Theorem distributive_cross_split {A} `{Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:
     sa_distributive A -> Cross_alg A.

Lemma distributive_equiv: forall A, @sa_distributive  _ (@Join_equiv A).

Lemma cross_split_equiv : forall A,  @Cross_alg _ (@Join_equiv A).

Lemma distributive_fun: forall A (JOIN: Join A) (key: Type),
               sa_distributive A -> @sa_distributive (key -> A) (Join_fun key A JOIN).

Lemma sa_distributive_prod : forall A B saA saB,
  @sa_distributive A saA ->
  @sa_distributive B saB ->
  @sa_distributive (A * B) (Join_prod A _ B _).

Lemma sa_distributive_bij : forall A B JA bij,
  @sa_distributive A JA ->
  @sa_distributive B (Join_bij A JA B bij).

Lemma Cross_bij : forall A B JA bij,
  @Cross_alg A  JA ->
  @Cross_alg B (Join_bij A JA B bij).

Lemma constructive_join_sub_smash {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A}:
  (forall x:A, {identity x}+{~identity x}) ->
  forall a c : lifted JA,
    constructive_join_sub (proj1_sig a) (proj1_sig c) ->
    @constructive_join_sub (option (lifted JA)) _ (Some a) (Some c).

Lemma sa_distributive_smash : forall A JA {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  @sa_distributive A JA ->
  sa_distributive (option (lifted JA)).

Lemma Cross_smash : forall A (JA: Join A) {PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A},
  (forall x:A, {identity x}+{~identity x}) ->
  Cross_alg A ->
  Cross_alg (option (lifted JA)).

Lemma cross_split_fpm : forall A B
      (JB: Join B) (PB: Perm_alg B)(SB : Sep_alg B)(CB: Disj_alg B)
  (Bdec: forall x:B, {identity x}+{~identity x}) ,
  Cross_alg B  ->
  Cross_alg (fpm A (lifted JB)) .

Lemma Cross_fpm (A B: Type){JB: Join B} {PB: Perm_alg B}{PosB : Pos_alg B}
  {CrB: Cross_alg B}:   Cross_alg (fpm A B) .

Definition opposite_bij {A B} (b: bijection A B) : bijection B A :=
 Bijection _ _ (bij_g _ _ b) (bij_f _ _ b) (bij_gf _ _ b) (bij_fg _ _ b).

Lemma Cross_bij' : forall A B JA JB bij,
  @Cross_alg B JB ->
   JB =  (Join_bij A JA B bij) ->
  @Cross_alg A  JA.

Definition option_bij {A B} (D: bijection A B) : bijection (option A) (option B). *)



Lemma exactly_i {A} : forall x: A, exactly x x.

Proof. intros. reflexivity.

Qed.

Hint Resolve @exactly_i.



Lemma superprecise_exactly {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}: forall x, superprecise (exactly x).

Proof.

unfold exactly, superprecise; intros.

subst; auto.

Qed.

Hint Resolve @superprecise_exactly.



Lemma find_overlap {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

     Cross_alg A ->

     forall S P Q R, (S * P) && (Q * R) |--

                          EX SQ:_, EX SR:_, EX PQ:_, EX PR:_,

                            (((SQ* SR) && S)*((PQ* PR) && P)) &&

                            (((SQ* PQ) && Q)*((SR* PR) && R)) &&

                            !! (superprecise SQ /\ superprecise SR /\ superprecise PQ /\ superprecise PR).

Proof.

pose proof I.

intros.

intros w [[w1 [w2 [? [? ?]]]] [w3 [w4 [? [? ?]]]]].

destruct (X _ _ _ _ _ H0 H3) as [[[[wa wb] wc] wd] [? [? [? ?]]]].

exists (exactly wa); exists (exactly wb); exists (exactly wc); exists (exactly wd).

repeat split; auto.

exists w1; exists w2; split; [|split]; auto; split; auto.

exists wa; exists wb; split; [|split]; auto.

exists wc; exists wd; split; [|split]; auto.

exists w3; exists w4; split; [|split]; auto; split; auto.

exists wa; exists wc; split; [|split]; auto.

exists wb; exists wd; split; [|split]; auto.

Qed.



Lemma modus_ponens {A} : forall (X P Q:pred A),

  X |-- P ->

  X |-- (P --> Q) ->

  X |-- Q.

Proof.

  unfold derives, imp; simpl; intuition eauto.

Qed.



Lemma and_intro {A}  : forall (X P Q:pred A),

  X |-- P ->

  X |-- Q ->

  X |-- P && Q.

Proof.

  unfold derives, imp, andp; simpl; intuition.

Qed.



Lemma and1 {A}  : forall (X P Q:pred A),

  X |-- P && Q --> P.

Proof.

  unfold derives, imp, andp; simpl; intuition eauto.

Qed.



Lemma and2 {A}  : forall (X P Q:pred A),

  X |-- P && Q --> Q.

Proof.

  unfold derives, imp, andp; simpl; intuition eauto.

Qed.



Lemma and3 {A}  : forall (X P Q R:pred A),

  X |-- (P --> Q) --> (P --> R) --> (P --> Q && R).

Proof.

  unfold derives, imp, andp; simpl; intuition eauto.

Qed.



Lemma or1 {A}  : forall (X P Q:pred A),

  X |-- P --> P || Q.

Proof.

  unfold derives, imp, orp; simpl; intuition.

Qed.



Lemma or2 {A}  : forall (X P Q:pred A),

  X |-- Q --> P || Q.

Proof.

  unfold derives, imp, orp; simpl; intuition.

Qed.



Lemma or3 {A}  : forall (X P Q R:pred A),

  X |-- (P --> R) --> (Q --> R) --> (P || Q --> R).

Proof.

  unfold derives, imp, orp; simpl; intuition eauto.

Qed.



Lemma TTrule {A}  : forall X (P: pred A),

  X |-- P --> TT.

Proof.

  unfold derives, imp, TT; simpl; intuition.

Qed.



Lemma FFrule {A}  : forall X (P: pred A),

  X |-- FF --> P.

Proof.

  unfold derives, imp, FF; simpl; intuition.

hnf in H0; contradiction.

Qed.



Lemma distribution {A}  : forall (X P Q R:pred A),

  X |-- P && (Q || R) --> (P && Q) || (P && R).

Proof.

  unfold derives, imp, orp, andp; simpl; intuition.

Qed.



Lemma wand_sepcon_adjoint {A} {JA: Join A}{PA: Perm_alg A} : forall (P Q R:pred A),

  ((P * Q) |-- R) = (P |-- (Q -* R)).

Proof.

  intros. apply prop_ext.

  split; intros.

  hnf; intros; simpl; intros.

  hnf; intros.

  apply H.

  exists a; exists x; split; auto.

  hnf; intros.

  destruct H0 as [w [v [? [? ?]]]].

  eapply H; eauto.

Qed.



Lemma ewand_sepcon {A} {JA: Join A}{PA: Perm_alg A}: forall P Q R,

      (ewand (P * Q) R = ewand P (ewand Q R))%pred.

Proof.

intros; apply pred_ext; intros w ?.

destruct H as [w1 [w2 [? [? ?]]]].

destruct H0 as [w3 [w4 [? [? ?]]]].

exists w3.

destruct (join_assoc (join_comm H0) H) as [wf [? ?]].

exists wf.

split; [|split]; auto.

exists w4. exists w2. split; auto.

destruct H as [w1 [w2 [? [? ?]]]].

destruct H1 as [w3 [w4 [? [? ?]]]].

destruct (join_assoc (join_comm H) (join_comm H1)) as [wf [? ?]].

exists wf. exists w4. split; [|split]; auto.

exists w1; exists w3; split; auto.

Qed.



Lemma andp_right {A}  : forall (X P Q:pred A),

  X |-- P ->

  X |-- Q ->

  X |-- P && Q.

Proof.

  unfold derives, imp, andp; simpl; intuition.

Qed.



Lemma andp_left1{A}: forall P Q R: pred A,  P |-- R -> P && Q |-- R.

Proof. repeat intro. destruct H0; auto.

Qed.



Lemma andp_left2{A}: forall P Q R: pred A,  Q |-- R -> P && Q |-- R.

Proof. repeat intro. destruct H0; auto.

Qed.



Lemma orp_left{A}: forall P Q R: pred A,  P |-- R -> Q |-- R -> P || Q |-- R.

Proof. repeat intro. destruct H1; auto.

Qed.



Lemma orp_right1{A}: forall P Q R: pred A,  P |-- Q -> P |-- Q || R.

Proof. repeat intro. left; auto.

Qed.



Lemma orp_right2{A}: forall P Q R: pred A,  P |-- R -> P |-- Q || R.

Proof. repeat intro. right; auto.

Qed.



Lemma exp_right:

  forall {B A: Type}(x:B) p (q: B -> pred A),

    p |-- q x ->

    p |-- exp q.

Proof.

intros.

eapply derives_trans; try apply H.

intros w ?; exists x; auto.

Qed.



Lemma exp_left:

  forall {B A: Type}(p: B -> pred A) q,

  (forall x, p x |-- q) ->

   exp p |-- q.

Proof.

intros.

intros w [x' ?].

eapply H; eauto.

Qed.



Lemma allp_right {B A: Type}:

  forall (P: pred A) (Q: B -> pred A),

  (forall v, P |-- Q v) ->

   P |-- allp Q.

Proof.

 intros. intros w ? v; apply (H v); auto.

Qed.



Lemma allp_left {B}{A}:

   forall (P: B -> pred A) x Q, P x |-- Q -> allp P |-- Q.

 Proof.

   intros. intros ? ?. apply H. apply H0.

Qed.



Lemma imp_andp_adjoint {A}  : forall (P Q R:pred A),

  (P && Q) |-- R <-> P |-- (Q --> R).

Proof.

  split; intros.

  hnf; intros; simpl; intros.

  intro; intros. apply H. split; auto.

  intro; intros. destruct H0. apply H; auto.

Qed.



Lemma exp_andp1 {A} :

 forall B (p: B -> pred A) q, (exp p && q)%pred = (exp (fun x => p x && q))%pred.

Proof.

intros; apply pred_ext; intros w ?.

destruct H as [[x ?] ?].

exists x; split; auto.

destruct H as [x [? ?]]; split; auto. exists x; auto.

Qed.



Lemma exp_sepcon1 {A}  {JA: Join A}{PA: Perm_alg A}:

  forall T (P: T ->  pred A) Q,  (exp P * Q = exp (fun x => P x * Q))%pred.

Proof.

intros.

apply pred_ext; intros ? ?.

destruct H as [w1 [w2 [? [[x ?] ?]]]].

exists x; exists w1; exists w2; split; auto.

destruct H as [x [w1 [w2 [? [? ?]]]]].

exists w1; exists w2; split; auto.

split; auto.

exists x; auto.

Qed.



Definition pure {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}

     (P: pred A) : Prop :=

   P |-- emp.



Lemma sepcon_pure_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

 forall P Q, pure P -> pure Q -> ((P * Q) = (P && Q)).

Proof.

intros.

apply pred_ext; intros w ?.

destruct H1 as [w1 [w2 [? [? ?]]]].

unfold pure in *.

assert (unit_for w1 w2). apply H in H2; simpl in H2;

apply identity_unit; auto. exists w; auto.

unfold unit_for in H4.

assert (w2=w) by (apply (join_eq H4 H1)).

subst w2.

assert (join w w1 w1).

apply identity_unit; apply H0 in H3; simpl in H3; auto. exists w; auto.

assert (w1=w) by (apply (join_eq H5 (join_comm H1))).

subst w1.

split; auto.

destruct H1.

exists w; exists w; split; [|split]; auto.

apply H in H1.

clear dependent P. clear dependent Q.

pose proof (core_unit w); unfold unit_for in *.

pose proof (H1 _ _ (join_comm H)).

rewrite H0 in H; auto.

Qed.



Lemma pure_sepcon_TT_andp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall P Q, pure P -> (P * TT) && Q = (P*Q).

Proof.

 pose proof I.

intros.

apply pred_ext.

intros w [? ?].

destruct H1 as [w1 [w2 [? [? ?]]]].

exists w1; exists w2; split; [|split]; auto.

apply join_unit1_e in H1; auto.

subst; auto.

apply andp_right.

apply sepcon_derives; auto.

intros w [w1 [w2 [? [? ?]]]].

apply join_unit1_e in H1; auto.

subst; auto.

Qed.



Lemma ewand_conflict {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:

       forall P Q R, sepcon P Q |-- FF -> andp P (ewand Q R) |-- FF.

Proof.

 intros. intros w [? [w1 [w2 [? [? ?]]]]].

 specialize (H w2). apply H. exists w; exists w1; repeat split; auto.

Qed.



Lemma ewand_TT_sepcon {T}{JT: Join T}{PT: Perm_alg T}{ST: Sep_alg T}:

      forall P Q R,

(P * Q && ewand R (!!True))%pred |-- (P && ewand R (!!True) * (Q && ewand R (!!True)))%pred.

Proof.

intros.

intros w [[w1 [w2 [? [? ?]]]] [w3 [w4 [? [? ?]]]]].

exists w1; exists w2; repeat split; auto.

destruct (join_assoc (join_comm H) (join_comm H2)) as [f [? ?]].

exists w3; exists f; repeat split; auto.

destruct (join_assoc H (join_comm H2)) as [g [? ?]].

exists w3; exists g; repeat split; auto.

Qed.

